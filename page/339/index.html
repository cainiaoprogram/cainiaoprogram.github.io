<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb7d9a56aafb8d6deb7e84601b323c1e/" rel="bookmark">
			jquery年月日时分秒控件_支持时分秒的jQuery时间选择插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间选择插件 - jQuery版 msg time1
time2
$('#time').setTime();
$('#time2').setTime({
drag:true,
h:[5,20],
i:[5,50],
s:[5,45],
a:0.05,
constraint:'',
'starteffect': function(d){
$('#msg').html(d[0]);
},
'onmove':function(e){
$('#msg').html(e[0] + '/' + e[1])
},
zindex:'0',
'cursor':'move',
'area':[[50,600],[10 ,5000]],
'callback':function(){
}
});
$('#time3').setTime({
drag:true,
a:0.05
});
$('#button').click(function(){
alert( $('#time').val() );
alert( $('#time2').val() );
alert( $('#time3').val() );
});
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d80b03c2efbbf393c7645018d06ef805/" rel="bookmark">
			惠普局域网共享打印机设置_Windows7局域网共享打印机教程，HP M1136 MFP打印机共享方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows7共享局域网打印机比较麻烦，要设置很多东西。本文以HP M1136 MFP打印机为例详细说明一下。
1、右击打印机属性，共享打印机，为其起一个共享名：
2、打开控制面板，更改高级共享设置。
3、在这里更改共享选项，能开的开启，该关闭的关闭
4、关闭密码保护共享，这样，连接这台电脑，不需要输入密码。
5、关闭密码保护共享
6、设备：防止用户安装打印机驱动程序，改为已启用。
7、从网络访问此计算机(打印机所在的计算机)，追加Guest用户。注意：打印机所在计算机，要启用来宾帐户。在控制面板里启用一下。
8、假如打印机所在计算机IP为192.168.100.60，需要使用打印的计算机IP为192.168.100.50，那么请在192.168.100.50上运行中，输入60的地址：
9、笔者所测试的打印机安装在192.168.100.75上，笔者连接192.168.100.75计算机，点击确定后，由于是首次访问(第二次再访问，不会再提示登录)，会跳出如下登录框：
10、这时候，输入用户名administrator，密码为空，可以勾选记住我的凭据。
11、确定，看到：
12、可以看到192.168.100.75上共享的打印机，双击这个打印机，或者右击-安装(连接)：
13、之后，系统会显示正在安装驱动，等安装驱动完成，也就大功告成了。
14、连接成功后的打印机在控制面板中可以看见：
15、当你打印的时候，Ctrl+P后，选择这个打印机即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dddffd1b0de778f8a598ecaf4555aec9/" rel="bookmark">
			bootstrap下拉框选择没反应_基于Bootstrap做的下拉菜单不能选择菜单项？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Bootstrap做的下拉菜单在电脑浏览器中可正常使用，在手机浏览器中能弹出下拉列表，却不能选择列表中的菜单项，
通过自己百度查找原因将bootstrap脚本文件中的ontouchstart 替换为 disable-ontouchstart可以解决，替换后并不能解决。(红米手机UC浏览器不支持，小米手机UC浏览器正常，其他暂时未测试)
希望高手指点！非常感谢！
jquery：v1.11.2
bootstrap：v3.3.4
以下为前台页面代码：
本外地福利：
value="" aria-expanded="false"&gt;
请选择本外地福利… 本地福利外地福利 以下为JS脚本：(给下拉菜单项添加click)
DataBindFuLi: function () {
$("#UiFuLi li a").bind("click", function () {
var $this = $(this);
var $a = $this.parent().parent().prev()
var t = $this.text();
$a.val($this.attr('title'));
$('#txtFuLi').val($this.attr('title'));
$a.text($this.text());
$a.append("");
});
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31182776d26080c6dae6d748047a833c/" rel="bookmark">
			List＜Object＞ 转List＜String＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Object是无法强转成String的，只能用下面方法：
List&lt;String&gt; strs = (List&lt;String&gt;)(List)object 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec1b8507f1c3c4e48274753c2c1cdc6/" rel="bookmark">
			golang插入字符串,如何在Golang的字符串中每X个字符插入一个字符？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Aim: to insert a character every x characters in a string in Golang
Input: helloworldhelloworldhelloworld
Expected Output: hello-world-hello-world-hello-world
Attempts
Attempt one
package main
import (
"fmt"
"strings"
)
func main() {
s := "helloworldhelloworldhelloworld"
s = strings.Replace(s, "world", ",", -1)
fmt.Println(s)
}
results in: hello,hello,hello,
Attempt two
Count number of characters
For loop
If X=5 then insert a -
Attempt three
Scan combined with join
Problem
The reason that attempts two and three do not contain code snippets at the moment is that I am still thinking what approach should be used to insert a character every X characters in a string in Golang.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ec1b8507f1c3c4e48274753c2c1cdc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bdc2c617d147264b1cafb1fbe657855/" rel="bookmark">
			python2输出中文乱码各种办法都不行_python2输出中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python2输出中文乱码问题
1、在源码文件第一行添加 #-*-coding:utf-8-*- 或 #encoding=utf-8 或 #encoding=UTF-8
注意：一定要在第一行！
2、在字符串前加 ‘ u ’
例： spring=u"这是一个测试字符串"
3、若上述2种方式仍然不能保证能输出正常输出中文，就需要做编码解码设置
即encode： 编码(真实字符与二进制串的对应关系，真实字符→二进制串)
decode： 解码(二进制串与真实字符的对应关系，二进制串→真实字符)
① 打印字符串时，字符串本身的编码，与输出终端中所用编码不匹配
例：本身是UTF-8类型的字符串，但是却将其输出到Windows的cmd中，而cmd中默认是GBK编码的，导致两者不匹配
解决办法：
可以把UTF-8的字符，解码为对应的Unicode，(也可以进一步的，把Unicode字符串，编码为GBK)。然后再输出到
GBK的cmd中，就可以正常显示，不是乱码了：
② 打印含某些特殊字符的Unicode类型字符串，但是输出终端中字符编码集中不包含这些特殊字符
例：把Unicode字符串，打印到Windows的cmd中，结果出错：
解决办法：
实例：
1. str 转换为 unicode
2. unicode 转换为str
参考文档：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776be449357a7d5b7530505641814271/" rel="bookmark">
			上传身份证照片js_html&#43;css&#43;js 实现拍照预览上传图片功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：我们在做网页时经常会需要有上传图片的需求，可能是选择图片或者拍照上传，如果简单的使用这种方式虽然也能实现功能，但用户体验上可能会差了一些，所以本文记录了使用css+js实现图片选中后的预览及压缩上传功能，部分带来来源于网络，此处做了记录整理。
效果预览：
1.创建index.html
拍照上传 身份证 身份证正面照
身份证反面照
提交
2.创建index.css
body{
margin: 0
}
.content{
padding:0.5rem;
display: flex;
align-items: center;
border-bottom: 1px #999 solid
}
.label{
width:5rem;
}
.img-area{
flex:1
}
.container{
background-color:#e7e7e7;
position: relative;
}
.container div{
text-align: center;
padding:0.5rem 0
}
.container input{
opacity:0;
filter:alpha(opacity=0);
height: 100%;
width: 100%;
position: absolute;
top: 0;
left: 0;
z-index: 9;
}
.container p{
font-size: 0.9rem;
color:#999
}
.btn{
background-color: #4363ab;
color: #fff;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776be449357a7d5b7530505641814271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df0347cfc5cbbd6ce722278b27df2dfb/" rel="bookmark">
			pandas series取值_数据分析pandas的简单操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要用pandas呢？ numpy能够帮我们处理数值的数据，pandas除了处理数值以外还可以处理字符串，时间序列等数据类型；
正常我们还是主要用pandas来读取数据；以下是读取不同类型的文件：
pd.read_csv() pd.read_excel() pd.read_html() pd.read_hdf() 读取数据后，我们说一下pd对数据的一些处理；
1.pandas的常用数据类型
series 一维，带标签的数组；
dataframe 二维，seiries的容器；
2.series 我们用一个字典来作为series创建data对象的内容；字典的键就作为series的索引了；
import pandas as pd import string dic={string.ascii_uppercase[i]:i for i in range(1,10)}#创建一个字典字母对应数字 data=pd.Series(dic) print(data.shape) 查看一下data的维度：
(9,) series的切片和索引：和序列的切片和索引相同；
print(data[[0,1,2,3]]) print(data[2:3])#切片 print(data[data&lt;3])#布尔索引 结果：dtype就是数据的类型了；
B 1 C 2 D 3 E 4 dtype: int64 D 3 dtype: int64 B 1 C 2 dtype: int64 对于陌生的series对象
我们可以用index和values来查看他的索引和标签：
data.index data.values 结果：
Index(['B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'], dtype='object') [1 2 3 4 5 6 7 8 9] 查看一下series索引和标签的类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df0347cfc5cbbd6ce722278b27df2dfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7daa60e76b5819649385c3f2741cf22/" rel="bookmark">
			android usb数据抓包_在Android平台，使用tcpdump构建USB抓包工具 (lembed.com)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://onesheepishgirl.com/wp-content/uploads/2013/11/app.php?p=307{Occhiali Da Sole Ray Ban Rb7010 Lente Grigio Nero Rosso Telaio}
http://www.notmormon.com/wp-content/uploads/2013/10/system.php?p=115{mcm boston}
http://www.batteryeater.com//new/img/medals/thumb.php?p=643{Prada Messaggi Borsa B7338 in Nero}
http://www.tinakarr.com/wp-content/gallery/photos/system.php?p=55{hollister londres}
http://www.stephaniemiller.com/dev/bits/edd.php?p=527{handbags gucci}
http://www.ville-bollene.fr/newsletter/images/thumb.php?p=63{pigalle louboutin}
http://steamgames.ro/banlist/cgi-bin/system.php?p=222{borse chanel prezzi 2013}
http://www.epicdevelopment.com/icon/other/system.php?p=91{ray ban prix}
http://www.testspa.com/wp-content/uploads/logo/cache.php?p=99{gucci bauletto}
http://supernaturalcymbals.com/shop/system/helper/helper.php?p=405{mulberry clothes}
发表评论电子邮件地址不会被公开。 必填项已用*标注
评论
姓名 *
电子邮件 *
站点
在此浏览器中保存我的名字、电邮和网站。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59047504d6a7af74e50fe36facbdb6d1/" rel="bookmark">
			华为s5720默认用户名和密码_华为华为交换机的默认用户名和密码是多少？谢谢！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
一般都是admin,也有可能是用户名是huawei，密码是admin，或是huawei@123。
拓展资料
传统华为交636f707962616964757a686964616f31333366303137换机从网桥发展而来，属于OSI第二层即数据链路层设备。它根据MAC地址寻址，通过站表选择路由，站表的建立和维护由CISCO思科交换机自动进行。路由器属于OSI第三层即网络层设备，它根据IP地址进行寻址，通过路由表路由协议产生。三层万兆交换机最大的好处是快速，由于交换机只须识别帧中MAC地址，直接根据MAC地址产生选择转发端口算法简单，便于ASIC实现，因此转发速度极高。但交换机的工作机制也带来一些问题。
1.回路：根据华为交换机地址学习和站表建立算法，交换机之间不允许存在回路。一旦存在回路，必须启动生成树算法，阻塞掉产生回路的端口。而路由器的路由协议没有这个问题，路由器之间可以有多条通路来平衡负载，提高可靠性。
2.负载集中：华为交换机之间只能有一条通路，使得信息集中在一条通信链路上，不能进行动态分配，以平衡负载。而路由器的路由协议算法可以避免这一点，OSPF路由协议算法不但能产生多条路由，而且能为不同的网络应用选择各自不同的最佳路由。
3.广播控制：华为交换机只能缩小冲突域，而不能缩小广播域。整个交换式网络就是一个大的广播域，广播报文散到整个交换式网络。而路由器可以隔离广播域，广播报文不能通过路由器继续进行广播。
4.子网划分：华为交换机只能识别MAC地址。MAC地址是物理地址，而且采用平坦的地址结构，因此不能根据MAC地址来划分子网。而路由器识别IP地址，IP地址由网络管理员分配，是逻辑地址且IP地址具有层次结构，被划分成网络号和主机号，可以非常方便地用于划分子网，路由器的主要功能就是用于连接不同的网络。
5.保密问题：虽说华为交换机也可以根据帧的源MAC地址、目的MAC地址和其他帧中内容对帧实施过滤，但路由器根据报文的源IP地址、目的IP地址、TCP端口地址等内容对报文实施过滤，更加直观方便。
6.介质相关：华为交换机作为桥接设备也能完成不同链路层和物理层之间的转换，但这种转换过程比较复杂，不适合ASIC实现，势必降低交换机的转发速度。因此目前交换机主要完成相同或相似物理介质和链路协议的网络互连，而不会用来在物理介质和链路层协议相差甚元的网络之间进行互连。而路由器则不同，它主要用于不同网络之间互连，因此能连接不同物理介质、链路层协议和网络层协议的网络。路由器在功能上虽然占据了优势，但价格昂贵，报文转发速度低。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/901b6dcd5c898ec1aa7a3e29172d8746/" rel="bookmark">
			python做pc端微信自动回复_测试进阶之路：pywinauto助你打开pc端自动化之门！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们柠檬班的小可爱，在学完我们柠檬班自动化的课程之后，就掌握了接口自动化，web自动化，app自动化，这些工作中常用的自动化技能，在工作足以够应对90%以上的自动化需求了。
不过近期也有部分小可爱在问PC端自动化怎么去做？
对这个技术比较好奇，使用python可以不可以实现PC客户端自动化测试？
答案当然是可以的，所以今天在这边专门整理了一遍文章，和大家一起聊聊如何使用python做PC端自动化！
环境安装 使用python实现来做PC端自动化，前提是先安装好python。
那么还需要用到一个第三方库：pywinauto。
在这边我们首先需要安装好这个库，安装命令如下：
使用说明 安装好了之后，关于使用说明大家可以参照官方文档上的说明。
如下图：
上述内容翻译如下：
就是说在我们安装好Pywinauto之后，首先要确定哪种可访问性技术(pywinauto的backend)可以用于我们的应用程序。
在windows上受支持的辅助功能技术有两种：
◆ Win32 API (backend="win32") 默认backend
◆ MS UI Automation (backend="uia")
如果您不能确定程序到底适用于那种backend，可以借助于GUI对象检查工具来做，常用的检查工具有Inspect.ex，Spy++ 等。
这个不做过多介绍，大家自行学习和下载，使用很简单，也非常便捷。
快速入门 在安装好环境之后，并且确定了应用程序适用的backend，那么接下来我们就可以使用Pywinauto这个模块来对应用程序进行自动化操作了。
01 连接到应用程序 这边用window自带的记事本程序作为案例，给大家做讲解。 连接应用程序，首先需要用到pywinauto.application.Application()来创建一个应用程序对象，然后再连接到应用程序。
有如下两种方法：
方式一：直接通过start方法打开操作的应用程序
方式二：连接已经打开应用程序，可以通过connect连接到指定的应用程序
运行以上代码，就会自动打开记事本记事本，如下
02 窗口选择 打开这个窗口之后，我们要操作该窗口的话，那么就的先选中这个窗口，关于窗口的选择有一下几种方式
03 控件操作 程序窗口中的每一块内容，都是一个控件，我们要对这个窗口的某一块内容进行操作，就需要选择到对应的控件。
◆ 获取所有控件
我们可以通过print_control_identifiers()这个方法，来获取这个窗口下的直接子控件，如下：
打印出来的结果如下：
上面打印出来的内容分别对应窗口种的以一下部分：
◆ 选择控件
关于控件选择的方法有好几种，最简单的方法如下：
◆ 内容输入
在上面选择到编辑窗口之后，我们就可以进行内容输入了
内容输入的方法：type_key()
运行结果如下：
04 键盘操作 输入完上述内容之后，接下来我们要修改编辑框中的内容
通过键盘完成以下操作：全选(ctrl+A) 复制(Ctrl+C) 粘贴(Ctrl+V) 回车(Enter) 粘贴(Ctrl+V)
◆ pywinauto.keyboard.send_key pywinauto模拟操作键盘，需要使用到 pywinauto.keyboard.send_keys这个方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/901b6dcd5c898ec1aa7a3e29172d8746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8289dd305a64172791ded73669c1e1fd/" rel="bookmark">
			万兆局域网方案_组建万兆局域网对网络设备的要求 （原创）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组建万兆局域网对网络设备的要求 \r\n\r\n万兆局域网是属于新型的高带宽网络，在提升网络性能的同时，更多的是关注网络的安全性、多业务融合能力与自适应能力。\r\n\r\n　万兆局域网是什么？\r\n\r\n　万兆局域网，狭义的讲是采用万兆技术进行组网的局域网；从广义的角度看，指具有高带宽、多业务、自适应、高安全、高扩展能力的新型局域网络。\r\n\r\n　新型万兆局域网一般采用两层扁平化结构，采用中高端以太网交换机进行组网，一般核心层采用两台以上核心交换机，进行冗余备份负载分担设计；接入层直接采用中端以太网通过高密度千兆口接入终端用户；核心与接入两个层次之间，通过万兆接口进行双归属级连，既实现了高密度千兆用户的接入，同时保障了网络的高效稳定，减少设备总数量，方便管理与维护。\r\n\r\n　提高网络性能只是万兆局域网的一项基本功能，却不是万兆局域网的所有功能。万兆局域网是属于新型的高带宽网络，在提升网络性能的同时，更多的是关注网络的安全性、多业务融合能力与自适应能力。\r\n\r\n　\r\n\r\n　从多层面发挥优势\r\n\r\n　\r\n\r\n　万兆局域网可以在高安全性、无QoS网络属性、多业务融合能力、扁平化网络体系结构降低布线成本、网络自适应能力、强扩展能力等几个层面发挥更多的优势，势必成为今后局域网发展的主导方向。\r\n\r\n　高安全性\r\n\r\n　万兆局域网组网模型中，直接采用了中端以太网交换机作为接入设备使用，提供高密度的千兆端口实现大量千兆用户的接入。中端交换机一般都是三层交换机，具备完善的三层特性，采用中端交换机作为接入设备，不但实现了高密度千兆接入，同时意味着三层到桌面的实现。\r\n\r\n　网络管理者可以充分利用三层交换技术的安全性，充分发挥三层到桌面的优势，全面提升网络的安全性。目前，网络攻击中有半数攻击是在链路层发起，通过诸如ARP攻击、广播风暴、MAC地址假冒等二层手段，对网络设备造成严重干扰甚至宕机。\r\n\r\n　网络管理者可以在地址规划时，利用三层到桌面的优势从根本上解决这一问题；可以采用每个端口一个VLAN，每个VLAN配置一个虚接口，每个虚接口配置30位掩码的网关，如此以来，每个端口只有一个合法的主机IP和一个网关。所有用户之间的交换，无论是同一业务板上，还是不同业务板之间、不同设备之间均为三层交换，所有的二层报文均被限制在一个端口上。这样部署所带来的直接好处有以下几点：\r\n\r\n　◆ 网络中彻底排除了二层报文，所有的二层攻击事件被彻底禁止，网络防攻击能力提高。\r\n\r\n　◆ 网络中所有物理链路上的报文均为三层报文；精华了网络流量，提高了网络带宽的利用率。\r\n\r\n　◆ 每一个IP地址只能在某一个固定端口使用，杜绝了IP地址假冒事件的发生，提高了网络安全性。\r\n\r\n　◆ 各端口的网段地址连续分配，在上一级进行路由聚合，有利于网络的管理与维护。\r\n\r\n　无QoS网络属性\r\n\r\n　万兆局域网解决方案通过万兆级连、千兆多桌面的组网方式，从根本上解决了网络的带宽问题，所有业务均可以实现无阻塞交换，从而网络管理者再也不必为每种业务部署端到端的QoS策略，极大地简化了网络配置的复杂度与维护难度。这一点，正是高带宽网络的直接利益所在。\r\n\r\n　多业务融合能力\r\n\r\n　新型的万兆局域网组网模式能够顺应潮流，对新型的多种网络应用进行很好的支持。目前，常见的网络应用主要包括数据业务、视频业务和IP语音业务。万兆局域网能够为每个用户提供最大千兆的网络带宽，在多业务支持方面提供了充足的带宽保障。\r\n\r\n　万兆局域网除了进行数据高速转发之外，还具备良好的组播业务特性，支持IGMP、PIM-SM、PIM-DM、DVMRP、MBGP等多种大型组播路由协议，能够在局域网内直接开展IP组播视频业务，可以实现多媒体教学、IPTV等多种基于IP组播协议的视频应用。\r\n\r\n　扁平化降低布线成本\r\n\r\n　由于采用了万兆级连、千兆多桌面的两层体系结构，减少了中间的汇聚层，所以在光纤布线上比以往的三层结构有了不小的降低。同时，相比以往采用多个千兆端口捆绑级连的方式，采用了万兆接口可以极大地节省设备级连的光纤资源，必然会导致布线成本的幅度降低。\r\n\r\n　网络自适应能力\r\n\r\n　万兆局域网相比以往局域网，另外一个不同之处在于综合管理服务器、策略服务器、安全管理服务器等业务管理系统成为局域网的必选组件。正是由于业务管理服务器的加入，赋予了网络更多的灵性与活力。\r\n\r\n　网络设备通过与业务服务器有机配合，可以实现对多种业务的自适应，可以对语音、视频、数据业务进行自动识别并进行区分服务。业务服务器可以实现用户网络管理策略的集中配置与管理，网络设备可以根据策略服务器的自定义策略，对不同网络业务、流量进行按需自动管理与实施。\r\n\r\n　强扩展能力\r\n\r\n　万兆局域网属于两层体系结构，具有设备数量少、性能高的特点，在今后网络需要扩容时，可以通过增加中端设备进行小规模扩容，也可以通过增加一层新的接入层，实现三层体系结构，实现更高的端口接入容量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c78ca9bd859f1304e06ec64db7448283/" rel="bookmark">
			VS2019 c&#43;&#43;使用sqlite3中文乱码解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlite3乱码，小白搜了一下午，终于，windows系统下（我是VS2019编辑器）默认c++默认编码为GB2312，而sqlite3的编码为UTF-8，取出来时自然乱码
操作 需执行SQL语句时将执行的SQL字符串转化为UTF-8编码
从数据库取出数据后再转化为GB2321，即可在C++中正确显示
#include &lt;atlstr.h&gt; //UTF-8到GB2312的转换 char* U2G(const char* utf8) { int len = MultiByteToWideChar(CP_UTF8, 0, utf8, -1, NULL, 0); wchar_t* wstr = new wchar_t[len + 1]; memset(wstr, 0, len + 1); MultiByteToWideChar(CP_UTF8, 0, utf8, -1, wstr, len); len = WideCharToMultiByte(CP_ACP, 0, wstr, -1, NULL, 0, NULL, NULL); char* str = new char[len + 1]; memset(str, 0, len + 1); WideCharToMultiByte(CP_ACP, 0, wstr, -1, str, len, NULL, NULL); if (wstr) delete[] wstr; return str; } //GB2312到UTF-8的转换 char* G2U(const char* gb2312) { int len = MultiByteToWideChar(CP_ACP, 0, gb2312, -1, NULL, 0); wchar_t* wstr = new wchar_t[len + 1]; memset(wstr, 0, len + 1); MultiByteToWideChar(CP_ACP, 0, gb2312, -1, wstr, len); len = WideCharToMultiByte(CP_UTF8, 0, wstr, -1, NULL, 0, NULL, NULL); char* str = new char[len + 1]; memset(str, 0, len + 1); WideCharToMultiByte(CP_UTF8, 0, wstr, -1, str, len, NULL, NULL); if (wstr) delete[] wstr; return str; } int main() { sqlite3 * db; sqlite3_open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c78ca9bd859f1304e06ec64db7448283/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba772be6e4562eec9c1a519d78903173/" rel="bookmark">
			shmget物理内存_共享内存的常用函数详解shmget shmat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		共享内存区域是被多个进程共享的一部分物理内存。如果多个进程都把该内存区域映射到自己的虚拟地址空间，则这些进程就都可以直接访问该共享内存区域，从而可以通过该区域进行通信。共享内存是进程间共享数据的一种最快的方法，一个进程向共享内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。这块共享虚拟内存的页面，出现在每一个共享该页面的进程的页表中。但是它不需要在所有进程的虚拟内存中都有相同的虚拟地址。
象所有的 System V IPC对象一样，对于共享内存对象的获取是由key控制。内存共享之后，对进程如何使用这块内存就不再做检查。它们必须依赖于其它机制，比如System V的信号灯来同步对于共享内存区域的访问(信号灯如何控制对临界代码的访问另起一篇说话)。
每一个新创建的共享内存对象都用一个shmid_kernel数据结构来表达。系统中所有的shmid_kernel数据结构都保存在shm_segs向量表中，该向量表的每一个元素都是一个指向shmid_kernel数据结构的指针。
shm_segs向量表的定义如下：
struct shmid_kernel *shm_segs[SHMMNI];
SHMMNI为128，表示系统中最多可以有128个共享内存对象。
数据结构shmid_kernel的定义如下：struct shmid_kernel
{
struct shmid_ds u;
unsigned long shm_npages;
unsigned long *shm_pages;
struct vm_area_struct *attaches;
};
其中：
shm_pages代表该共享内存对象的所占据的内存页面数组，数组里面的每个元素当然是每个内存页面的起始地址.
shm_npages则是该共享内存对象占用内存页面的个数，以页为单位。这个数量当然涵盖了申请空间的最小整数倍.
(A new shared memory segment, with size equal to the value of size rounded up to a multiple of PAGE_SIZE)
shmid_ds是一个数据结构，它描述了这个共享内存区的认证信息，字节大小，最后一次粘附时间、分离时间、改变时间，创建该共享区域的进程，最后一次对它操作的进程，当前有多少个进程在使用它等信息。
其定义如下：
struct shmid_ds {
struct ipc_perm shm_perm;
int shm_segsz;
__kernel_time_t shm_atime;
__kernel_time_t shm_dtime;
__kernel_time_t shm_ctime;
__kernel_ipc_pid_t shm_cpid;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba772be6e4562eec9c1a519d78903173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e14a1d72ad33f05746247bbdccbde1d7/" rel="bookmark">
			米家的扫地机器人是灰色_米家扫地机器人怎么清理灰尘盒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是时间财富网智能客服时间君，上述问题将由我为大家进行解答。
米家扫地机器人清理灰尘盒的方法如下：
1、首先将扫地机器人的尘盒与手柄拆开，并单独从主机上盖红圈处揭开上盖。
2、然后紧按住红圈处的尘盒扣拿出尘盒。
3、最后，将尘盒里面的垃圾清理干净即可。
4、如果要水洗尘盒时，一定要将滤网取下。
米家扫地机器人采用NIDEC无刷电机，具备1800Pa风压。浮动主刷设计，可以根据地面的高低上下浮动，紧贴地面。在清扫墙边缝隙的过程依靠沿墙传感器，米家扫地机器人和墙精确保持约1cm的距离，配合边刷的工作将墙边缝隙的灰尘清理干净。米家扫地机器人配备5200mAh锂电池，充满电一次可清扫250平米。扫地机器人，又称自动打扫机、智能吸尘、机器人吸尘器等，是智能家用电器的一种，能凭借一定的人工智能，自动在房间内完成地板清理工作。一般采用刷扫和真空方式，将地面杂物先吸纳进入自身的垃圾收纳盒，从而完成地面清理的功能。一般来说，将完成清扫、吸尘、擦地工作的机器人，也统一归为扫地机器人。扫地机器人最早在欧美市场进行销售，随着国内生活水平的提高，逐步进入中国。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065f3bca09b81603c7ba020bfbb7cc9f/" rel="bookmark">
			AOP实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AOP（Aspect Oriented Programming）面向切面编程
在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
总结：在AOP中切面就是与业务逻辑独立，但又垂直存在于业务逻辑的代码结构中的通用功能组合；切面与业务逻辑相交的点就是切点；连接点就是把业务逻辑离散化后的关键节点；切点属于连接点，是连接点的子集；Advice（增强）就是切面在切点上要执行的功能增加的具体操作；在切点上可以把要完成增强操作的目标对象（Target）连接到切面里，这个连接的方式就叫织入。
基本名词： Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。
Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。
Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。
Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。
Target（目标对象）：织入 Advice 的目标对象.。
Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程
设计模式 责任链模式：
一个请求的处理需要多个对象当中的一个或几个协作处理
角色：
抽象处理者(Handler)：定义出一个处理请求的接口。如果需要，接口可以定义出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。
具体处理者(ConcreteHandler)：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。
优点： 实现了请求者与处理者代码分离
适配器模式：
一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。
角色：
Target：目标抽象类
Adapter：适配器类
Adaptee：适配者类
Client：客户类
桥接模式：
角色：
Abstraction：抽象类
RefinedAbstraction：扩充抽象类
Implementor：实现类接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/065f3bca09b81603c7ba020bfbb7cc9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1973b3bb62222c7123974f83b5507c83/" rel="bookmark">
			Java方法返回值类型归纳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java方法返回值类型归纳 我们再调用一个方法时，将方法体内产生的一条数据输出到方法体外使用，这条数据我们叫做返回值。
返回值类型分为两大类： 第一类，无返回值类型：void。 第二类，有返回值类型，返回值的类型就是被返回数据的类型。 有返回值的类型 ，
如何返回一条数据呢？ 使用return语句。 return语法： return 数据(需要返回的数据);//表示返回一条数据，然后结束方法。 如果这个方法有返回值，那么定义方法时必须指定返回数据的数据类型。
并且，在方法执行的最后一句必须是return语句。
无返回值的类型 void void表示调用方法后无返回数据。里面可以写return语句，也可以不写。 当return;时，后面没有写返回数据时，仅仅表示方法体的结束。 这里说一下打印语句System.out.println();打印语句只是将信息打印在控制台上，没有向外输出数据的能力。
return语句可以将数据从方法体内输出到方法体外使用，但没有打印能力。
案例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85f89595fcba0379c1a03e4035a70446/" rel="bookmark">
			js kettle 修改字段值_Kettle 使用JS脚本 增加UUID输出列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		image.png
image.png
####JavaScript 脚本如下####################################################
//Script here
//Script here
function UUID(){
this.id = this.createUUID();
}
UUID.prototype.valueOf = function(){ return this.id; }
UUID.prototype.toString = function(){ return this.id; }
UUID.prototype.createUUID = function(){
var dg = new Date(1582, 10, 15, 0, 0, 0, 0);
var dc = new Date();
var t = dc.getTime() - dg.getTime();
var h = '';
var tl = UUID.getIntegerBits(t,0,31);
var tm = UUID.getIntegerBits(t,32,47);
var thv = UUID.getIntegerBits(t,48,59) + '1';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85f89595fcba0379c1a03e4035a70446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e8be4fe120dbcd1dbcd542971cf2a9/" rel="bookmark">
			为什么自动关闭_智能插座&#43;快捷指令=充满电自动断电
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般人的习惯都是晚上将手机放床头边上充电，第二天早上起来就可以拿着充满电的手机去上班了。
可是有些人就会担心手机充满电后一直不拔会不会对手机有什么影响? 更有些人会比较担心充电器一直不拔会不会有安全隐患?
那为什么不试试用智能插座+快捷指令来实现手机充满电之后自动断电呢？只需要简单几个步骤就可以实现。
1)首先你得有一个智能插座，这里使用的是米家生态下的gosund智能插座，将插座添加到米家APP中；
2)然后再米家APP的“智能-&gt;我的”页面中新增一个“手动执行”的场景，执行动作为关闭充电器插座；
3)将新增的手动执行的场景添加到Siri中，图中设置的手动场景名称为“充电器关闭开关”，添加成功后打开“快捷指令”APP，在“我的快捷指令”中能找到添加的快捷指令，图中设置的快捷指令名称为“关闭充电器”。这里可以关闭“运行时显示”；
4)在“快捷指令”APP中添加一个自动化指令。设置为当电池电量等于100%时运行“关闭充电器”快捷指令。
那么最后效果就是这样子
如果本篇文章对你有所帮助，欢迎点赞、收藏、分享，谢谢~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4ea4598ba5876c37815542859beac5/" rel="bookmark">
			Android开发必须掌握！Kotlin可能带来的一个深坑，使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、项目介绍 Flutter是目前比较流行的跨平台开发技术，凭借其出色的性能获得很多前端技术爱好者的关注，比如阿里闲鱼，美团，腾讯等大公司都有投入相关案例生产使用。
基于Flutter+Dart+chewie+photo_view+image_picker等技术开发的跨平台仿微信app聊天界面应用，实现了消息/表情发送、图片预览、长按菜单、红包/小视频/朋友圈等功能。
笔记内容概要 一、架构师必备Java基础 1、深入理解Java泛型
2、注解深入浅出
3、并发编程
4、数据传输与序列化
5、Java虚拟机原理
6、高效IO
二、设计思想解读开源框架 1、热修复设计
2、插件化框架设计
3、组件化框架设计
4、图片加载框架
5、网络访问框架设计
6、RXJava响应式编程框架设计
三、360°全方位性能调优 1、设计思想与代码质量优化
2、程序性能优化
启动速度与执行效率优化布局检测与优化内存优化耗电优化网络传输与数据储存优化APK大小优化 3、开发效率优化
分布式版本控制系统Git自动化构建系统Gradle 4、项目实战
启动速度流畅度抖音在APK包大小资源优化的实践优酷响应式布局技术全解析网络优化手机淘宝双十一性能优化项目揭秘高德APP全链路源码依赖分析彻底干掉OOM的实战经验分享微信Android终端内存优化实践 四、Android框架体系架构 1、高级UI晋升
2、Android内核组件
3、大型项目必备IPC
4、数据持久与序列化
5、Framework内核解析
五、NDK模块开发（音视频系列） 1、NDK开发之C/C++入门
2、JNI模块开发
3、Linux编程
4、底层图片处理
5、音视频开发
6、机器学习
六、Flutter学习进阶 1、Flutter跨平台开发概述
2、Windows中Flutter开发环境搭建
3、编写你的第一个Flutter APP
4、Flutter Dart语言系统入门
七、微信小程序开发 1、小程序概述及入门
2、小程序UI开发
3、API操作
4、购物商场项目实战
最后 文末放一个小福利给大家，点击我的GitHub即可领取
群内有许多技术大牛，有任何问题，欢迎广大网友一起来交流，群内还不定期免费分享高阶Android学习视频资料和面试资料包~
偷偷说一句：群里高手如云，欢迎大家加群和大佬们一起交流讨论啊！
内还不定期免费分享高阶Android学习视频资料和面试资料包~**
偷偷说一句：群里高手如云，欢迎大家加群和大佬们一起交流讨论啊！
[外链图片转存中…(img-G44zHXZI-1608307242054)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2886eb7999a8506914397b14e78b20/" rel="bookmark">
			server安装 sql 发生mof语法错误_SQL Server 安装程序无法编译托管对象格式(MOF)文件(转)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在windows 2003 中安装SQL时，出现如下错误信息：
标题: Microsoft SQL Server 2005 安装程序
------------------------------
SQL Server 安装程序无法编译托管对象格式(MOF)文件 E:\Program Files\Microsoft SQL
Server\MSSQL.2\MSSQL\Binn\sqlwep-uni.mof。若要继续，请参阅 SQL Server 2005
安装程序帮助文档中的“排除 SQL Server 2005 安装故障”或“如何查看 SQL Server 2005 安装日志文件”。
解决办法:
根据我的研究，这个问题可能是由于被损坏的wmi库造成的。您可以参考下面的步骤来建一个bat文件来重建wmi库，然后再安装sql 2005：
net stop winmgmt
c:
cd %systemroot%\system32\wbem
rd /S /Q repository
regsvr32 /s %systemroot%\system32\scecli.dll
regsvr32 /s %systemroot%\system32\userenv.dll
mofcomp cimwin32.mof
mofcomp cimwin32.mfl
mofcomp rsop.mof
mofcomp rsop.mfl
for /f %%s in (''dir /b /s *.dll'') do regsvr32 /s %%s
for /f %%s in (''dir /b *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b2886eb7999a8506914397b14e78b20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64255dcb92a1a83d87fe4b1e9e19838b/" rel="bookmark">
			server安装 sql 发生mof语法错误_从新安装SQLserver 过程中报错问题合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在sql安装过程中，遇到了这样的问题：
[错误消息]
为 SQL Server 代理服务提供的凭据无效。若要继续操作，请为 SQL Server 代理服务提供有效的帐户和密码。
是用户名选择错误或者没选，正确选择如下：
3、SQL Server 2008 R2 安装程序 Upgrade Failed due to the following Error.The error code is :-2147467259.Mes
SQL Server 2008 R2 安装程序
------------------------------
出现以下错误:
Upgrade Failed due to the following Error.The error code is :-2147467259.Message:未指定的错误
把microsoft visual studio tools for applications 2.0 -ENU文件和
microsoft visual studio tools for applications 2.0 -LANG 文件程序卸载掉，重启电脑，重新安装Sqlserver2008即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2be358bb659e769ad8970bc839611a8/" rel="bookmark">
			zigzag算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zigzag编码的出现是为了解决varint对负数编码效率低的问题。zigzag编码的原理非常简单，就是将有符号整数映射为无符号整数。在实现上，映射通过移位即可实现，而不需要使用映射表来存储。
zigzag编码原理解析 对于正整数，可以把无意义的0去掉，只存储从1开始的"有效"数据，这样就可以压缩数据了。
例如，对于正整数1，其补码(当代计算机中实际按补码表示整数)按位展开，即为(00000000 00000000 00000000 00000001)补，显然，我们可以只用一个字节甚至1bit来存储有效数据。
负数的补码可没有这么容易压缩。
例如，对于负数-1，(11111111 11111111 11111111 11111111)补，全为1，并没有压缩的空间了啊！怎么办？
我们知道补码的最高位是符号位，对于负数，符号位为1，它阻碍了对于无意义0的压缩；既然有阻碍，那就得想办法解决这个阻碍；是否可以将符号位移动到补码的最后，然后数据位整体左移1位，这样就能把这个“阻碍”解决呢？
(-1)10
(11111111 11111111 11111111 11111111)补
符号位移动到最低位，数据位整体相对左移1位
(11111111 11111111 11111111 11111111)移位
对于绝对值小的负数，冗余的前导1还是很多；似乎解决的并不彻底
把数据位按位取反，符号位保持不变
(00000000_00000000_00000000_00000001)取反
经过移位和取反操作后，-1被“编码”成了1。如此，便能很好的压缩数据，彩！
对于非负整数，只需完成 符号位移到最低位，数据位整体左移1位
我们再来看看整数1通过同样的处理后被“编码”成什么值。
(1)10
(00000000 00000000 00000000 00000001)补
(00000000 00000000 00000000 00000010)移位
经过移位操作后，1被“编码”成了2。
似乎能得到这样的结论：
对于负数，经过移位和数据位取反，也能将绝对值小的负数进行压缩；
对于非负数，经过移位，也可以压缩；
那么又有一个问题来了，这两种结论怎样在代码实现层面合二为一呢？
知识点：
算术左移低位补0；算术右移，若符号位为0，高位补0；若符号位为1，高位补1；
对于n=-1(32位)，(11111111 11111111 11111111 11111111)补
n &lt;&lt; 1， a= (11111111 11111111 11111111 11111110)补，数据位整体左移1位
n &gt;&gt; 31，b= (11111111 11111111 11111111 11111111)补，符号位移到最低位
负数的算数右移高位补1，所以右移31位后，b为全1，这点非常重要
c=a^b， c= (00000000 00000000 0000000 00000001)补，将-1“编码”成了1，与前面的分析一致
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2be358bb659e769ad8970bc839611a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acae151dd11df3bcf7f3cc2c81303d43/" rel="bookmark">
			多媒体技术第一次作业：将24位真彩色图像转换为灰度图（无调色板）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;malloc.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; /* 位图头结构 */ #pragma pack(1) typedef struct tagBITMAPFILEHEADER { unsigned char bfType[2];//文件格式 unsigned long bfSize;//文件大小 unsigned short bfReserved1;//保留 unsigned short bfReserved2; unsigned long bfOffBits; //DIB数据在文件中的偏移量 }fileHeader; #pragma pack() /* 位图数据信息结构 */ #pragma pack(1) typedef struct tagBITMAPINFOHEADER { unsigned long biSize;//该结构的大小 long biWidth;//文件宽度 long biHeight;//文件高度 unsigned short biPlanes;//平面数 unsigned short biBitCount;//颜色位数 unsigned long biCompression;//压缩类型 unsigned long biSizeImage;//DIB数据区大小 long biXPixPerMeter; long biYPixPerMeter; unsigned long biClrUsed;//多少颜色索引表 unsigned long biClrImporant;//多少重要颜色 }fileInfo; #pragma pack() int main() { /*存储RGB图像的一行像素点*/ unsigned char ImgData[3000][3]; /*将灰度图的像素存到一个二维数组中*/ unsigned char ImgData2[3000][3]; int i,j,k; FILE * fpBMP,* fpGray; fileHeader * fh; fileInfo * fi; char filename1[20],filename2[20]; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acae151dd11df3bcf7f3cc2c81303d43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2996d8a6b257bba674f6333e5a7c6f/" rel="bookmark">
			Neo4j登录报错Neo4j Server shutdown initiated by request解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Neo4j登录报错Neo4j Server shutdown initiated by request解决 cmd运行neo4j.bat console，出现一大串错误，如图
丧心病狂，一通百度谷歌bing，最后还是靠依稀留存的记忆解决了问题。。其实超级简单。
别人的方法 方法一：删除data\database下的文件，重新neo4j.bat console。
方法二：在命令行中运行neo4j stop，再运行neo4j.bat console
但我这里都没有成功
我有用的方法 使用管理员身份打开cmd，运行neo4j.bat console，成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e0b62a98ca48ed0aa7a348ecc91f818/" rel="bookmark">
			C#32位bmp转透明底png
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#32位bmp转透明底png 说明效果图代码 说明 将bmp以编码形式读出来，得到每个像素的argb值，赋值给png图像。
仅支持位深度为32位的bmp图像。
另外代码部分还包括文件拖拽和根据窗口大小动态改变控件大小和位置的方法。
效果图 代码 using System; using System.Drawing; using System.IO; using System.Windows.Forms; namespace bmptopng { public partial class Form1 : Form { public Form1() { InitializeComponent(); ImageList imgList = new ImageList { ImageSize = new Size(1, 25) }; listView1.SmallImageList = imgList; listView1.View = View.Details; listView1.Columns.Add("序号", 80, HorizontalAlignment.Right); listView1.Columns.Add("文件路径", 478, HorizontalAlignment.Left); listView1.CheckBoxes = false; listView1.FullRowSelect = true; listView1.Width = 558; listView1.Height = 300; listView1.Location = new Point(12, 12); button1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e0b62a98ca48ed0aa7a348ecc91f818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6e0f3e4fe78ff6f4bbd87d8524539ba/" rel="bookmark">
			transformers 加载模型时报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		transformers加载模型时报错 安装transformers后，拿下面的代码测试：
from transformers import AutoTokenizer, TFAutoModel tokenizer = AutoTokenizer.from_pretrained("bert-base-uncased") model = TFAutoModel.from_pretrained("bert-base-uncased") inputs = tokenizer("Hello world!", return_tensors="tf") outputs = model(inputs) print(inputs) print(outputs) 报错：
HTTPSConnectionPool(host='cdn-lfs.huggingface.co', port=443): Max retries exceeded with url: /bert-base-uncased/a7a17d6d844b5de815ccab5f42cad6d24496db3850a2a43d8258221018ce87d2 (Caused by NewConnectionError('&lt;urllib3.connection.VerifiedHTTPSConnection object at 0x0000022BEE03A6A0&gt;: Failed to establish a new connection: [Errno 11001] getaddrinfo failed',)) Traceback (most recent call last): File "D:\Anaconda3\envs\tensorflow_gpu\lib\site-packages\urllib3\connection.py", line 157, in _new_conn (self._dns_host, self.port), self.timeout, **extra_kw File "D:\Anaconda3\envs\tensorflow_gpu\lib\site-packages\urllib3\util\connection.py", line 61, in create_connection for res in socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6e0f3e4fe78ff6f4bbd87d8524539ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc72ae37ed0f8fc47b03712ac22ac70/" rel="bookmark">
			unipp 使用uni.createCanvasContext画图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官网uni.createCanvasContext有详细介绍
&lt;button @click="getImg"&gt;生成海报&lt;/button&gt; &lt;view class="" style="opacity: 1;"&gt; &lt;canvas class="canvas" canvas-id="firstCanvas" id="firstCanvas"&gt;&lt;/canvas&gt; &lt;/view&gt; getImg(){ const ctx = uni.createCanvasContext('firstCanvas'); ctx.drawImage('/static/canvas.png', 0, 0, uni.upx2px(420), uni.upx2px(800)); ctx.save(); ctx.beginPath(); ctx.arc(uni.upx2px(100), uni.upx2px(80), uni.upx2px(50), 0, 2 * Math.PI); ctx.translate(uni.upx2px(110), uni.upx2px(30)); ctx.clip(); ctx.drawImage(this.user.picture2, uni.upx2px(50), uni.upx2px(30), uni.upx2px(100), uni.upx2px(100)); ctx.restore(); ctx.draw() } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0efc854310ffb3ad3b28e2ff7bf6e09/" rel="bookmark">
			Nginx在局域网内实现真正的ip_hash负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx在局域网内实现真正的ip_hash负载均衡 遇到的问题 本人在以前公司的局域网内搭载Nginx负载均衡的时候发现使用ip_hash实现负载均衡会发生一个奇怪的显现，所有客户端的请求访问都打在了同一个服务器上！这使得负载均衡根本就没有起到任何作用，本人查阅了相关资料最终发现解决方法，多谢网上的各位大神，参考文献在最后说明。 为什么无法实现在同一局域网内ip_hash负载均衡说明 在同一个局域网中，大多数情况下我们在同一局域网内的所有机器IP前3位都是相同的，假设都为192.168.1.xxx。
根据官方的解析（参考网上大神的说法）
This directive causes requests to be distributed between upstreams based on the IP-address of the client.
The key for the hash is the class-C network address or the entire IPv6-address of the client. IPv6 is supported for ip_hash since 1.3.2 or 1.2.2. This method guarantees that the client request will always be transferred to the same server. But if this server is considered inoperative, then the request of this client will be transferred to another server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0efc854310ffb3ad3b28e2ff7bf6e09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93fafe0706d2928e67d0097deca3f1fe/" rel="bookmark">
			[转载] Java8 Stream流遍历 如何使用索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接： Java 8中迭代带有索引的流Stream
1. 问题来源 Java8的Stream流为我们的遍历集合带来了方便，基本可以取代for循环了。但是有一些情况需要知道当前遍历的索引，使用for循环当然可以轻易获得，但使用stream就很难了。 比如下面这个情况： 有一个集合list，里面存储的是引用类型。 使用for循环可以轻易的操作索引i for (int i = 0; i &lt; list.size(); i++){
System.out.println(list.get(i));
System.out.println(i);
}
使用Stream流遍历list如下，其中handle是一个方法，想在handle方法里面拿到当前索引是很困难的。 list.stream().map(t -&gt; handle(t)).collect(Collectors.toList());
2. 解决办法 使用IntStream流来构造一个Int类型的流出来，然后遍历这个Int的流，list中的对象可以通过get方法来取。具体解决代码如下： IntStream.range(0, lists.size())
.mapToObj(i -&gt; handle(lists.get(i), i))
.collect(Collectors.toList());
可以看到代码里的这一句：handle(lists.get(i), i)，这样就成功的把索引带入到了handle方法中。 需要注意的是：在流中必须使用mapToObj，而不能使用map映射 3. map映射和mapToObj的区别 首先Stream流下面的类包含了IntStream, LongStream, DoubleStream等 那么究竟下面两者有什么区别呢？ Stream&lt;Integer&gt; // 包装类型
IntStream //基本类型
所以对于mapToObj和mapToInt也是同样的 mapToObj 方法主要是将Stream中的元素进行装箱操作， 转换成一个引用类型的值。 mapToInt 方法是将Stream中的 元素转换成基本类型int。 比如下面的例子 Stream s = IntStream.of(4, 5, 6).mapToObj(e -&gt; e); //mapToObj method is needed
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93fafe0706d2928e67d0097deca3f1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85a397111cd037eb59620d0809d62069/" rel="bookmark">
			尝鲜！微软首个AI量化投资开源平台Qlib上手体验！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，微软亚洲研究院正式发布了业内首个AI量化投资开源平台Qlib，发布一个月以来已经在GitHub收获2.3k star！ 值得关注的一点就是这套量化系统的框架分为多层，每层由多个松散耦合的模块组成，因此每个模块用户都可以自行修改、定制、使用，如下图所示 通过这样的方式，可以让用户更快的了解整个工作流程，并灵活的进行调整，同时也支持在线和离线两种模式，嗯，本地取数据、本地跑策略，隐私上也有一定的提升。
更多的宣传点，本文不再过多介绍，下面将从用户使用的角度讲解如何安装配置Qlib并构建一个量化交易模型。
安装
安装Qlib其实和其他第三方库安装类似，但毕竟要跑模型，并且依赖较多，所以可能会由于不同机器环境的问题，导致不同的错误，首先还是尝试直接pip安装
pip install pyqlib 当然我建议从GitHub上把源码拉下来安装
git clone https://github.com/microsoft/qlib.git &amp;&amp; cd qlib pip install . 我分别在macOS Big Sur和centos7下测试，在配置anaconda环境下，均出现不同的报错，如果出现任何类似如下报错
Failed building wheel for xxx command 'x86_64-apple-darwin13.4.0-clang' failed with exit status 254 大概率是gcc编译出现问题，可以先在shell中用gcc -v查看gcc的版本信息，之后在mac下可以尝试检查Xcode是否安装并升级GCC版本之后尝试如下代码
export CC=gcc export CXX=g++ 如果提示任何与PyYAML包安装失败相关的报错，可以尝试自己手动卸载sudo pip uninstall PyYAML这个包再重新安装。
为了更好的使用，我们还需要安装配置好redis并启动，并不困难此处不做更多讲解。
总之安装过程中，可能会出现不同的问题，我们只要耐下心来，仔细阅读报错代码，一点一点解决，总能成功安装好。
配置数据
下载与初始化 在安装好pyqlib后，我们还需要准备数据，官方提供了从Yahoo Finance爬数据的方法，可以在命令行进入之前从GitHub拉下来的文件夹后执行如下命令
python scripts/get_data.py qlib_data --target_dir ~/.qlib/qlib_data/cn_data --region cn 等待一会即可，之后我们可以进入~/.qlib/qlib_data/目录下检查数据是否被正确存储 在搞定数据之后，在使用之前还需要进行初始化，进入Python后执行如下命令
import qlib # region in [REG_CN, REG_US] from qlib.config import REG_CN provider_uri = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85a397111cd037eb59620d0809d62069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90155513971e3f5200c9683392d2a1a/" rel="bookmark">
			sql server 没有备份怎么恢复误删的表数据_恢复误删的数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址： 13sai​blog.13sai.com 前段时间，某开发人员误删了一个数据库，导致我们的服务不可用，最后是恢复了，过程我并不清楚，但引起了我的兴趣。因为误操作真的是很难避免的，开发人员那么多，一个不小心，就可能影响了其他人的使用，所以慎重操作，最好能禁用一些操作，比如drop！
那么如何来恢复呢？
如果有备份的话，当然去寻找最新的，然后恢复，如果不在意新增的数据，那么这样就足够了。
来看一下备份，
// 备份某个数据库某些表 mysqldump [options] db_name [tbl_name ...] &gt; bak.sql // 备份多个数据库 mysqldump [options] --databases db_name ...&gt; bak.sql // 备份所有数据库 mysqldump [options] --all-databases&gt; bak.sql 个人建议单个备份，好独立操作。
了解更多请看：
4.5.4 mysqldump - A Database Backup Program​dev.mysql.com 恢复操作（以单个数据库为例）
mysql -h127.0.0.1 -uroot -p del &lt; bak.sql 操作是不是很简单？
那么如果没有备份怎么办呢？
第二种操作前提是开启了binlog，通过log恢复。
误删后可以保存下binlog
mysqlbinlog mysql-bin.000011 &gt; del.log 打开文件，去掉drop操作并保存。
mysql -h127.0.0.1 -uroot -p &lt;del.log 当然，比较建议通过dump全备份操作，然后找出备份到drop的pos。
通过mysqlbinlog 的start-position和stop-position生成sql后恢复。这里就不赘述了。
有兴趣可以看看
4.6.7 mysqlbinlog - Utility for Processing Binary Log Files​dev.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c90155513971e3f5200c9683392d2a1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183f44761eab0eb86afb41e0499cd7b6/" rel="bookmark">
			NRF52833学习笔记（2）——双UART串口使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 UARTE 是带有 EasyDMA 的通用异步接收器/发送器 UART。提供快速、全双工、异步的串口通信，内置流量控制（CTS，RTS）支持硬件，速率高达 1 Mbps。
以下是 UARTE 的主要功能：
全双工操作自动硬件流控制生成9位数据带奇偶校验EasyDMA波特率高达 1 Mbps在支持的事务之间返回 IDLE（使用HW流控制时）一个停止位最低有效位（LSB）优先 用于每个 UART 接口的 GPIO 可以从设备上的任何 GPIO 来选择并且独立地为可配置的。这使得能够在器件的引脚和有效地利用电路板空间和信号路有很大的灵活性。
二、硬件连接 功能引脚描述UART0_TXD6串口0发送端UART0_RXD8串口0接收端UART1_TXD5串口1发送端UART1_RXD7串口1接收端 三、修改文件 3.1 app_uart.h app_uart.h 位于 SDK\components\libraries\uart，将原文件备份，将以下内容替换到原文件
/** * Copyright (c) 2013 - 2020, Nordic Semiconductor ASA * * All rights reserved. * * Redistribution and use in source and binary forms, with or without modification, * are permitted provided that the following conditions are met: * * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183f44761eab0eb86afb41e0499cd7b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/411c4958be342b6ea12fb19f7aa9bbc8/" rel="bookmark">
			安装linux 系统出现An Unknown Error Has Occurred报错原因和解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：http://www.hellokvm.com/?p=659
An Unknown Error Has Occurred
This program has encountered an unknown error. You may report the buy below or quit the program.
This program has encountered an unknown error. You may report the buy below or quit the program.
可能是硬盘里面有些raid的数据或分区不规范引起的，与安装程序发生了冲突，需要将硬盘格式化掉。
格式化硬盘
方法一（推荐）
利用安装盘启动到光盘修复界面
格式化你需要安装系统的硬盘即可，也可以先用fdisk命令进行删除现有分区。看具体需求
方法二（不推荐，原因是比较分费时间）
利用windows PE 格式化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/112fdc57d2ba7dd56e21bec0e8cb85a0/" rel="bookmark">
			AI上推荐 之 基于内容的推荐(ContentBasedRecommend)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 随着信息技术和互联网的发展， 我们已经步入了一个信息过载的时代，这个时代，无论是信息消费者还是信息生产者都遇到了很大的挑战：
信息消费者：如何从大量的信息中找到自己感兴趣的信息？信息生产者：如何让自己生产的信息脱颖而出， 受到广大用户的关注？ 为了解决这个矛盾， 推荐系统应时而生， 并飞速前进，在用户和信息之间架起了一道桥梁，一方面帮助用户发现对自己有价值的信息， 一方面让信息能够展现在对它感兴趣的用户前面。 推荐系统近几年有了深度学习的助推发展之势迅猛， 从前深度学习的传统推荐模型(协同过滤，矩阵分解，LR, FM, FFM, GBDT)到深度学习的浪潮之巅(DNN, Deep Crossing, DIN, DIEN, Wide&amp;Deep, Deep&amp;Cross, DeepFM, AFM, NFM, PNN, FNN, DRN), 现在正无时无刻不影响着大众的生活。
推荐系统通过分析用户的历史行为给用户的兴趣建模， 从而主动给用户推荐给能够满足他们兴趣和需求的信息， 能够真正的“懂你”。 想上网购物的时候， 推荐系统在帮我们挑选商品， 想看资讯的时候， 推荐系统为我们准备了感兴趣的新闻， 想学习充电的时候， 推荐系统为我们提供最合适的课程， 想消遣放松的时候， 推荐系统为我们奉上欲罢不能的短视频…, 所以当我们淹没在信息的海洋时， 推荐系统正在拨开一层层波浪， 为我们追寻多姿多彩的生活！
这篇文章又回到了传统的推荐方式协同过滤的时代了， 因为最近刚好学习到基于内容的推荐和基于回归模型的推荐， 之前在刚开始学习协同过滤的时候， 其实也了解过这两种推荐方式， 但当时并不是太了解具体是怎么做的， 这次又重温了一下， 知道了里面的一些实施细节， 所以借机会整理一下。
今天首先是看一下基于内容的推荐方式， 这种推荐方式是非常直接的， 它是以物品的内容描述信息为依据做出的推荐， 本质上是基于对物品和用户自身的特征或者属性直接分析和计算。 再白话一点， 就是事先先给出物品的画像和用户的画像， 这样， 我们就能根据用户喜欢什么直接给用户推荐物品， 这也是一种非常简单和快捷的方式，例如，假设已知电影A是一部喜剧，而恰巧我们得知某个用户喜欢看喜剧电影，那么我们基于这样的已知信息，就可以将电影A推荐给该用户。 (PS：之前从福哥的口中了解到，虽然现在深度学习模型很火， 但大多数还停留在理论的研究阶段，真正能够应用到实践中的并不是太多，因为模型本身的部署比较复杂，且对于数据， 设备等要求也非常高， 对于中小规模的公司来讲，早期的一些简单的推荐方法可以作为初版推荐系统的不二之选， 所以有时候还是有必要学习一下那些简单推荐方式的思想的， 而基于内容的推荐的思想就挺简单的哈哈)。
之前学习的时候， 也是停留在理论阶段， 也知道先构建物品画像(给物品打标签)和用户画像(给用户打标签）,然后实施推荐。 但是并没有理解到一些细节，比如如何给物品打标签， 如何给用户打标签？ 如何解决物品冷启动问题？ 等， 所以这次想通过之前用到过的比较简单的movielens数据集， 来走一波基于内容的推荐流程， 这里面会涉及到tf-idf技术， word2vec技术， doc2vec技术等， 所以通过这次的学习， 收获还是蛮大的， 把之前的知识也串联了一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/112fdc57d2ba7dd56e21bec0e8cb85a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad31f0b00a6cebe0fce6767f35e2ac35/" rel="bookmark">
			python read函数返回值_python read()方法定义及使用（实例解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天这篇文章我们来了解一下pythonread方法，不知道没什么关系。因为今天讲的就是python之中的read()方法，以及知晓read是什么意思，所以今天我们在今天的文章之中来了解一下吧。
概述
read() 方法用于从文件读取指定的字节数，如果未给定或为负则读取所有。
语法
read() 方法语法如下：fileObject.read();
参数
size -- 从文件中读取的字节数
返回值
返回从字符串中读取的字节。
实例
以下实例演示了 read() 方法的使用：
文件 runoob.txt 的内容如下：1:www.runoob.com
2:www.runoob.com
3:www.runoob.com
4:www.runoob.com
5:www.runoob.com
循环读取文件的内容：#!/usr/bin/python
# -*- coding: UTF-8 -*-
# 打开文件
fo = open("runoob.txt", "rw+")
print "文件名为: ", fo.name
line = fo.read(10)
print "读取的字符串: %s" % (line)
# 关闭文件
fo.close()
以上实例输出结果为：文件名为: runoob.txt
读取的字符串: 1:www.runo
在这次的文章之中，我们了解了什么是read() 方法，不明白的话其实自己可以动手去试一试，毕竟动手实践才是验证所学的最好的方法与途径。最后我也希望这篇文章能够给正在学习python的你带来一点帮助。
更多相关知识，请访问php中文网Python教程栏目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/229c55e96f85f6fe207fd40bad93229b/" rel="bookmark">
			C#和Visionpro混合编程实现工业相机实时图像采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C s h a r p 和 V i s i o n p r o 混 合 编 程 实 现 工 业 相 机 实 时 图 像 采 集 Csharp和Visionpro混合编程实现工业相机实时图像采集 Csharp和Visionpro混合编程实现工业相机实时图像采集 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ImageFile; using System.IO; using PylonC.NET; using System.Runtime.InteropServices; using System.Threading; namespace Demo { public partial class Form1 : Form { private CogImageFileTool m_ImageFileTool; private Thread ThreadObject; //线程 private bool ThreadStop = false; public Form1() { InitializeComponent(); //线程对象实例化 ThreadObject = new Thread(new ThreadStart(ThreadFunction)); //打开相机 OpenCameraSoftTrigger(); } private void DisplayImage(object sender, EventArgs e) { if (ThreadObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/229c55e96f85f6fe207fd40bad93229b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2f450ecb4a3fc5931967d5d84679b83/" rel="bookmark">
			C&#43;&#43;----矩阵转置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 要求将一个矩阵转置
由用户输入行列
思路：
如果有用户输入行列的话，我们不知道用户输入了一个几维的数组，所以这样要回归到数组的本来定义是申请一块连续的存储空间，比如一个二维数组存储情况的一维表现就是a11,a12,a21,a22。所以利用这个特性，来解决这个问题。
#include&lt;iostream&gt; using namespace std; void convert(int *array,int n) { int i,j,k; for(i=0;i&lt;n;i++) { for(j=0;j&lt;i;j++) { k=*(array+i*n+j); *(array+i*n+j)=*(array+i+j*n); *(array+i+j*n)=k; } } } int main() { int i,j,n; int *p; cout&lt;&lt;"input n"&lt;&lt;endl; cin&gt;&gt;n; p=new int[n*n]; cout&lt;&lt;"input element"&lt;&lt;endl; for(i=0;i&lt;n;i++) { for(j=0;j&lt;n;j++) { cin&gt;&gt;p[i*n+j]; } } cout&lt;&lt;"before: "&lt;&lt;endl; for(i=0;i&lt;n;i++) { for(j=0;j&lt;n;j++) { cout&lt;&lt;p[i*n+j]&lt;&lt;" "; } cout&lt;&lt;endl; } cout&lt;&lt;"afetr: "&lt;&lt;endl; convert(p,n); for(i=0;i&lt;n;i++) { for(j=0;j&lt;n;j++) { cout&lt;&lt;p[i*n+j]&lt;&lt;" "; } cout&lt;&lt;endl; } } 结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2f450ecb4a3fc5931967d5d84679b83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e26de2e4630a67a6d3c320790e70556c/" rel="bookmark">
			并发相关工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“晏霖”，选择“置顶或者星标”
曾经有人关注了我
后来他有了女朋友
我们在并发编程中，经常会使用到一些工具来帮助我们控制线程。本章节就会对CountDownLatch、CyclicBarrier、Semaphore工具的应用进行简单的介绍。
2.11.1 CountDownLatch
CountDownLatch，使用AQS状态表示计数，可以把它看成是一个计数器，源码注释第一句话：A synchronization aid that allows one or more threads to wait until，翻译过来就是：允许一个或多个线程等待。好，让我们揭开CountDownLatch的面纱。当我们打开CountDownLatch源码时，可以看到300多行代码，80%是注释。CountDownLatch类中官方的解释是：允许一个或多个线程等待，在其他线程中执行的一组操作完成。用给定的count初始化。方法块{@link#await await}直到当前计数达到由于调用{@link#countDown}方法为零，之后释放所有等待的线程以及随后的任何调用。
使用CountDownLatch最重要2个方法，一个是countDown();函数，另一个是await();函数。countDown是递减锁存器的计数，如果计数到达零，则释放所有等待的线程。如果当前计数大于零，则将计数减少1。await方法可以使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断 ， 如果当前的计数为零，则此方法立即返回。让我们利用一个demo介绍一下CountDownLatch如何的应用，请看示例代码2-48所示。
代码清单2-48 CountDownLatchDemo.java
public class CountDownLatchDemo { private static CountDownLatch countDownLatch = new CountDownLatch(5); public static void main(String[] args) throws InterruptedException { // 创建定长线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); for (int i = 1; i &lt;= 5; i++) { executorService.execute(() -&gt; { int consumeTime = new Random().nextInt(10) + 1; String name = Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e26de2e4630a67a6d3c320790e70556c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79309fd815e38605e5932fbbcd0b3e0f/" rel="bookmark">
			纯CSS制作各种图形(多图预警)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在国外一网站(The Shapes of CSS)看到的，看了一下 css，也不复杂，只是平时没有用心去思考~用心思考~埋头赶路~~
Square(正方形) #square { width: 100px; height: 100px; background: red; } Rectangle(矩形) #rectangle { width: 200px; height: 100px; background: red; } Circle(圆形) #circle { width: 100px; height: 100px; background: red; -moz-border-radius: 50px; -webkit-border-radius: 50px; border-radius: 50px; } /* 可以使用百分比值(大于50%)，但是低版本的Android不支持 */ Oval(椭圆形) #oval { width: 200px; height: 100px; background: red; -moz-border-radius: 100px / 50px; -webkit-border-radius: 100px / 50px; border-radius: 100px / 50px; } /* 可以使用百分比值(大于50%)，但是低版本的Android不支持 */ Triangle Up(向上的三角形) #triangle-up { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; } Triangle Down(向下) #triangle-down { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; } Triangle Left(向左) #triangle-left { width: 0; height: 0; border-top: 50px solid transparent; border-right: 100px solid red; border-bottom: 50px solid transparent; } Triangle Right(向右) #triangle-right { width: 0; height: 0; border-top: 50px solid transparent; border-left: 100px solid red; border-bottom: 50px solid transparent; } Triangle Top Left(左上) #triangle-topleft { width: 0; height: 0; border-top: 100px solid red; border-right: 100px solid transparent; } Triangle Top Right(右上) #triangle-topright { width: 0; height: 0; border-top: 100px solid red; border-left: 100px solid transparent; } Triangle Bottom Left(左下) #triangle-bottomleft { width: 0; height: 0; border-bottom: 100px solid red; border-right: 100px solid transparent; } Triangle Bottom Right(右下) #triangle-bottomright { width: 0; height: 0; border-bottom: 100px solid red; border-left: 100px solid transparent; } Curved Tail Arrow(弯尾箭头) 可以通过修改 #curvedarrow 的 rotate() 值来形成不同的方向
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79309fd815e38605e5932fbbcd0b3e0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad4b1cdb63f4644272d28cc7a8efa37/" rel="bookmark">
			找出两个字符串中所有共同的字符_蹲在马桶看算法(Day11—LeetCode之NO.599两个列表的最小索引和)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目概述： 给定两个字符串列表，找到两个列表中的公共字符串，并且满足两个相同字符串(列表公共字符串各自索引的和最小)的索引和最小。
思路： 1、首先两个列表中的公共字符串，最先想到的用set或者map。(具体操作是把第一个把一个列表list1中的全部字符串添加到set或map中。再遍历第二个列表list2。判断list2中的元素是不是在set或map中contain就好。)。 但是这里还有一个条件是“满足两个列表的索引和最少”。 所以使用map可以顺带记录一下索引。摒弃set。
2、找出共同的字符串的问题解决了。如何让其索引和最小呢(可以试着写一个求数组的最小值或者最大值的代码：这里说求最小值的思路，设置一个变量，假设其是最小值，跟数组中的每一个元素比较，如果数组中的元素还有比它小的，用当前元素替换掉最小值的值即可，如此直到数组遍历完成)？下面贴一下代码
public class FindRestaurant {public String[] findRestaurant(String[] list1,String[] list2) {if (list1==null||list1.length==0||list2==null||list2.length==0) return null;Map map=new HashMap&lt;&gt;();List help=new LinkedList&lt;&gt;();for(int i=0;i 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a94477c396bbaa8a291bfc52a6d9bafe/" rel="bookmark">
			人脸识别小区门禁系统_终于明白了！小区为什么要装人脸识别门禁系统？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如我们关注科技新闻，就经常会看的有关人脸识别方面的内容。当前有很多一线城市的小区都在安装使用人脸识别门禁系统以替代传统的门禁系统。为什么这些小区都在安装使用人脸识别门禁系统呢？
终于明白了！小区为什么要装人脸识别门禁系统？
简单来说，人脸识别门禁系统能够实现小区的智能化管理，有效的降低小区发生安全事件的可能性，消除隐患。同时，还能整体的提升小区业主的生活体验与改善陈旧的居住环境，大力推进小区的智能化服务，并建设物业智能化的管理新模式。
一、 增强小区的安全保障 对任何小区来讲，门禁系统需要做到防止陌生人或不法分子随意进出，而传统的小区大多存在门禁系统落后与管理不严等问题。这无疑会让小区存在一定的安全隐患，无法有效阻止陌生人随意进出小区。当采用人脸识别门禁系统后，小区的物业管理只需要把业主的身份信息以及面部信息进行采集录入系统后台，即可实现人脸识别通行。在人脸识别门禁闸机使用时，如果在系统后台没有做过信息录入将无法实现通行。这种方式能做到有效的阻止陌生人随意进出小区，发挥了很大的安防作用。
不过，假如业主的亲朋好友等访客需要进入小区时时如何操作？这种情况下，业主或住户其实只需要通过手机或视频通话等方式确认好访客身份即可进行临时性的人脸识别和身份验证，然后就可以轻松通行。此外，诸如搬家、房屋租赁等常见的情形，在人脸识别门禁系统管理下，仅需在小区物业管理录入身份和面部信息即可随意通行，这也能在某种程度上减轻了小区人员迁移管理的成本。
二、提高小区的安全与便捷性 基于人脸识别技术是利用人的脸部特征信息进行身份识别的一种生物识别方式，而人脸是具有唯一性，不易复制性的特点。当小区安装使用人脸识别门禁系统之后，能彻底解决以前传统小区那些门禁卡易被复制等问题。因此，人脸识别门禁系统与传统小区的刷门禁卡、密码锁、指纹锁对比，则具有更加安全并且不易被复制的优点。
人脸识别门禁的便捷性也是一个亮点，无需钥匙，无需按指纹更无需门禁卡，全程无接触“刷脸”即可轻松通行。这无疑给小区业主居民解放了双手，腾出来双手！即使抱住孩子或者提着包，拎着菜等等情况下，仅靠“刷脸”就能便捷通行，更具人性化。
当然，现在的人脸识别技术已经发展到一个新的高度，识别的准确率高达99.99%。即使在夜晚，也能精准的识别出来。而且针对企图利用照片、模型、视频等手段干扰人脸识别的问题也通过技术升级与改进算法解决了，无论是精准度与安全系数都更高。
总的来说，一项新技术的普及必然会有一个漫长的过程。期待人脸识别门禁系统能给更多的小区居民带去更好与更轻松安全的生活体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ce673785ed7d4dc113cd920a2fad1b/" rel="bookmark">
			springboot集成flowable modeler 6.5.0整合实现在线编辑免登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 把官方flowable-ui-modeler-app\src\main\resources\static下面的代码拷贝至我们自己的工程Pom引入新增2个配置类 集成flowable rest apiACT_DE的包无法生成,使用如下的配置类破解登录配置文件如下：大功告成,效果图如下 因公司需求需要用到工作流，选型flowable，本篇博客记录下整合
把官方flowable-ui-modeler-app\src\main\resources\static下面的代码拷贝至我们自己的工程 Pom引入 &lt;?xml version="1.0" encoding="UTF-8"?&gt;
4.0.0
&lt;groupId&gt;com.promote&lt;/groupId&gt; &lt;artifactId&gt;flowable&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;flowable.version&gt;6.4.2&lt;/flowable.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;6.4.2&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;!--flowable支持 包含flowable-spring-boot-starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-spring-boot-starter-process&lt;/artifactId&gt; &lt;version&gt;6.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-rest&lt;/artifactId&gt; &lt;version&gt;6.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-ui-modeler-rest&lt;/artifactId&gt; &lt;version&gt;${flowable.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-ui-modeler-conf&lt;/artifactId&gt; &lt;version&gt;${flowable.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-ui-modeler-logic&lt;/artifactId&gt; &lt;version&gt;${flowable.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-ui-common&lt;/artifactId&gt; &lt;version&gt;${flowable.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50ce673785ed7d4dc113cd920a2fad1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6dc06c1644849a43a14556e31c396e2/" rel="bookmark">
			运营新人也可以做的副业平台丨闲鱼运营（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章上半部分给大家深度分享了关于闲鱼的赚钱方法和店铺权重建设该如何提升，如果没有看上半部分内容，直接翻阅主页就可以查阅到，接下来我们分享关于闲鱼运营的下半部分（店铺运营）
闲鱼何运营总共分为三个部分
第一个部分是闲鱼养号，第二部分是内容编辑，第三部分是产品运营。
关于第一部分的内容上篇文章有写，接下来分享2/3部分
二、内容编辑 内容编辑这个方面，主要是围绕标题、正文和图片三个部分组成
也就是说你想上一个商品这三部分是一定要做好编辑，一定要填写完整的标题正文和图片
我们先看这个标题
标题我们的要求是什么呢？就是尽量做到求全，要将产业和产品相关的关键词都覆盖进去，然后获取到最大的更大的一个搜索流量。所以这里那就不建议大家去写一些特别简单的一个标题
比较好的方式是什么呢？大家可以参照一下淘宝。大家浏览淘宝的时候，会发现淘宝这个商品标题很长，而且覆盖了很多相关的关键词。但是这里也要注意一点。
商品的文案不要直接复制粘贴淘宝，京东上的那些商品信息。
商品同质化很严重的话，平台就不太可能给你分发流量。尤其你是淘系的产品
这些商品他们的数据库是相通的。也就是说你直接从这些平台的商品把标题直接扒过来，你粘贴到自己的商品上，那其实是被系统判定为抄袭
那抄袭标题其实等于死路一条，就把自己的推荐流量这个大门给锁死了。
所以尽量建议大家不要去直接抄袭。那么如果去抄袭的话，有什么办法？
分享大家一个电商标题写作方法
像电商平台，他的这个商品标题本质是什么呀？是关键词的组合。
给大家举个例子，比如说淘宝有个商品标题叫做运动鞋2020新款男透气网面跑步鞋。那这样一个标题，我们可以提取一些独立的关键词，比如说这样。
运动、2020、新款、跑步。那这些都是一些独立的关键词。把这些关键词组合在一起就成为一个新的标题，其实你想推荐的是一个运动鞋
那根据运动鞋相关的一些关键词，像运动，2020、新款跑步这些都是围绕这个关键词做的一些延伸，做的一些长尾词
那这里我给大家一个建议是什么呢？就是说如果你想自己设计一个标题的话，就是先选好一款商品，比如说就是像一款运动鞋。
然后用这个图片搜索功能，淘宝他都有商品搜索功能，你去找出同款的多个商品，然后你去看一下这些商品店铺他们的这些标题。然后整理一下。
然后找一下他们的差异化。然后再重新组合一下，那这是一个非常稳妥的方法
说完了标题，接下来我们看一下正文。
正文也就是说这个商品的信息了，其实标题它已经展示了一部分的商品信息
具体的正文当中，我们需要解决什么问题呢？
就是一个用户你需要去针对性的给用户一个购买理由，你要对于用户存在的一些疑问提出一些解决方案啊。
那首先我们看一下用户的一个购买逻辑是什么。
当用户的购买理由超过了阻碍购买理由的时候，这个时候他会更容易的去下单做出选择，
你要做的肯定是给出用户这样的一个购买理由，然后将用户可能会存在的一些问题给他解决
那正文主要是做解决问题一个作用。那这有问题了，假如说我只是售卖一款产品，我不知道用户有什么样的购买理由，或者说我不知道用户对这款产品有什么担忧或者问题，怎么办呢？
淘宝如果大家用过的话，会发现在这个某个淘宝的商品的详情页，有一个问大家的模
这个模块有什么用呢？这个模块就是用户对这款产品最关心的问题是什么。大家可以看一下
那你看这些问题肯定就是用户对这款产品存在的一些疑虑，那这个时候你就可以利用问大家这样一个模块。找到用户真正担心的这些问题
把用户可能感兴趣的问题给罗列出来，然后组织成文案。那这个就是挖掘用户疑虑的一个技巧。然后接下来这还不算完了，接下来我们要去写
商品文案主要是包括两个方面。
第一个部分是解决阻碍用户购买的理由第二个方式是给用户提供购买你这个商品的理由，怎么提供呢？去评论区去提取这个素材，你就找出评论中出现的高频的词语。 这些词肯定就是用户购买和满意的一些理由。然后你按照出现频率从上到下罗列一下，然后组织一下语言。
那这就是一个优秀的商品文案了，其实这两个方面都是可以借鉴的，完全不需要你个人去构思，再去做一些创意什么的。我们要站在巨人的肩膀上思考问题
别人有一些现成的优秀文案，我们可以拿出来借鉴。注意这里只是借鉴，不是完全照抄复制粘贴。我们肯定要对于他的完做一些修改，那这个是关于商品正文方面。
第三个方面是配图
不要复直接复制粘贴淘宝的那些商品详情页。
相似度太高，肯定是要被限流的，就是说你的头图肯定是可以自己用相机拍摄的，现在的相机拍照像素也都比较好。
所以没有必要再去引用别的商家别的店铺他们的图片，那如果你非要用的话，我建议你用那些买家的。淘宝的那些买家秀，当图片是比较好的选择
前面的技巧，虽然说跟大家说了，但实际上还是需要你动手去实操，多去练习。如果说你不去练习的话呢，前面说的方法其实都等于零，你还是没有学会。所以必须要多去练习
三、产品运营 最后和大家分享些运营技巧，就是在运营闲鱼这个平台时候可能会遇到的问题，我们应该如何去解决。
首先第一个问题就是商品上架以后不出单怎么办，有时候卖不出去。
在线交易平台，只要你是电商平台，出单都是概率性的问题。尤其是前期你这个店的曝光量小，流量也小，你不出单是很正常。
我给大家的建议是，先上线50个宝贝。
也就是说50个商品，然后定期将那些没有浏览量的商品清理掉，然后继续。这是周而复始，持续循环
闲鱼前期运营就是一个测试产品的过程，不测试你也不知道哪个产品会爆款，因为用户做买二手商品，你也不知道用户会喜欢哪种二手商品。所以前期是一个过程。前期出单你不要太焦虑。
然后就是选择什么样的商品会出单这个问题，首先选择被时间检验过的爆款商品出单较容易
就是说你要做咸鱼的话，你肯定不能闭门造车，你肯定要学会去收集一些同行
你去看一下他们的爆款是什么，然后用我之前教给大家的方法，你去重新优化一下文案，然后把这个商品再重新上架一下。
不需要去创新，还是我刚才说的，站在巨人的肩膀上去思考，将模仿做到极致
接下来我们看一下用什么指标去评估爆款商品。前面我们说啊，你可以去多去参考一些竞品。参考一些同行或者说做的好的卖家。怎么评判呢？
看“我想要”这个关键指标
我想要这个功能是在哪呢？是在这个产商品的详情页，或者说你在首页推荐当中，你是可以看到每个商品他底下会标注。有多少个人想要这款产品，那这个我想要。就是指的就是用户对这款产品的认可程度。
我给大家的建议是，就是我想要这个数据要大于300，我觉得他才能被判定为一款爆款产品，低于300以下的，其实都不能算爆款产品。
那其实这个标准大家可以记一下。
就是商品我想要这个数据一定要大于300。那其实这样的话你就可以做一些引导。比如说你在商品正文当中就可以提一下，如果大家对这款商品感兴趣，可以点击我想要，然后与我私聊
你去看一下很多那个闲鱼的卖家，他们都会用这样的文案去引导你去点击这我想要。那这个是关于爆款商品的评估标准。
然后用户处理
接下来你要去哪些平台去找货源了。那你怎么去做呢？你去淘宝、拼多多、淘宝联盟，1688，等这些低价的商品平台下单，然后转手你再加价去闲鱼卖给别人
那其实你赚钱赚的这个利润就是一个信息差，赚的是一个价格差
但是你说为什么不直接开淘宝店。首先在闲鱼创办店铺都非常容易，每个人都是卖家，你直接拍个照片，把商品信息一填，你就可以卖上买商品了
你也不需要资质认证，唯一需要认证的就是你的芝麻信用分
然后还有就是搜索方法，如果说用户在这个平台下单了，那你把这个商品用图片搜索功能，还是跟之前的方式一样，或者说标题复制粘贴的功能去找这款商品，然后去下单就可以了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6dc06c1644849a43a14556e31c396e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b33fc648076ddcbc2c75d29c9f4849/" rel="bookmark">
			程序员高效查找开源项目小技巧：GitHub高级搜索筛选关键词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面对世界上最全的代码开源库github（https://github.com/），身为一名需要不断利用开源项目来身经百战的程序猿前传版，你是否感觉海选关键词搜到的内容非常多非常杂，如大海捞针一般。这时，我们可以运用一些小技巧在gihub上筛选出想要的内容。
提取标题中关键词方法： in:name 你想搜的关键词
例如你要搜 3D object detection
在这里你搜到所有标题内容就包含了你想要的的关键词。
类似的还有：
点赞数筛选（例如大于100的情况下）：stars:&gt;100
fork数筛选（例如大于200的情况下）：fork:&gt;200
read me中关键词筛选命令：in:read me 3D object detection
语言筛选命令： language:java
发布时间筛选命令： pushed:&gt;2019-09-03
描述中关键词筛选命令：in:description
加上了这些命令之后，你会发现你搜索的内容更加有指向性！
具体步骤也可以参照视频（我觉得此大佬讲的挺好的）：https://www.bilibili.com/video/BV1yJ411S7Wu?from=search&amp;seid=10218069631564707832
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a695fc9ff78678b7a80f5071d1fa6f1b/" rel="bookmark">
			剑桥雅思真题精讲10pdf_剑桥雅思真题及精讲1-15高清无水印版PDF＋MP3音频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，剑桥4-剑桥10可以用来反复练习使用，剑桥11-14可以留到考前作为模考使用。
初级阶段：了解雅思考试的内容、题型以及考试逻辑,积累高频以及生僻词汇, 学习同义替换，重在积累、熟悉模式及过程，锻炼雅思的思维能力。
中级阶段：总结错题，精听、精读，如果初级阶段重在积累，那么这一阶段重在自我思考以及提炼总结。
高级阶段：考前冲刺，一切按考试的标准来，包括每部分完成时间，考试顺序，阅读篇章难易度选择等等。
看着雅思频频上热搜，烤鸭们心里有点数吗？
相信还没和雅思分手的烤鸭们对剑桥雅思真题并不陌生，毕竟剑桥雅思真题是由雅思考试命题方出品，暗含着2020-2021雅思考试的考试难度和出题方向，是雅思备考的必备指南。而距离剑桥14发布时隔已久，同学们也早就不淡定了：剑桥15到底啥时候出？！
终于，千呼万唤始出来，剑桥15体验版和烤鸭们见面啦~
这次，免费为大家送上最新版剑桥雅思1-15的高清无水印版和MP3音频资料，助力屠鸭！注意哦，是难得的无水印版！无水印！
我预测你高分 领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deeebc9646bb42f34b3f3ba42b4de2b3/" rel="bookmark">
			[Opengl]图形学final_project作业记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 提示信息a.函数1、2、4、5b.函数3c.注意代码复用d.程序运行截图e.操作界面 半边数据结构VS小技巧查找查看定义查找所有引用 1. 计算三角网格中每个三角形的面积 (10分)题目说明算法思想代码示例 2. 计算三角网格中每个顶点(vertex)的法向 (20分)题目说明算法思想代码示例 3. 用OpenGL把三角网格中每个三角形面片的法向画出来（在每个三角面片的重心处画） (20分)题目说明算法思想代码示例ogl_writer() 算法思想 4. 实现一种三角网格去噪算法(30分)题目说明算法思想代码示例 5. （可选/可做可不做）实现一种基于三角网格的操作（例如，特征点/边提取，给三角网格添加随机高斯噪声，求三角网格每个顶点的高斯曲率，三角网格简化，三角网格四边形化等等） (20分)题目说明算法思想代码示例 本次结课大作业5个题目，最后一道题为选做题。老师给的原项目非常复杂，得仔细研究，在这之前还得了解C++的语法，特别是标准库的一些功能，函数等，可参考我写的一点内容(C++模板、命名空间)：
模板.
命名空间.
另外，好好阅读文档“final_project作业题2020.docx”，还有课件PPT“计算机图形学8-2020-第二学期”，有对本项目的简单介绍。
配置环境我也有博客介绍：环境配置.
提示信息 a.函数1、2、4、5 其中1. 2. 4. 5的函数声明在 mesh/extension/ExKernelT.h(截图如下)
函数实现请在mesh/extension/ExkernelT.cpp中完成 (务必)
b.函数3 b. 其中3的函数声明在read_write/read_write.h
函数实现请在read_write/read_write.cpp中完成 (务必)
c.注意代码复用 请把整个代码看明白，里面实现了各种基本操作，例如求三角网格中每个三角形的重心、求每个三角面片的法向等等。
d.程序运行截图 如下：
e.操作界面 鼠标点击右键，会出现一个操作界面，里面有一些灯光和其他绘制效果。
半边数据结构 定义如下：
简单来说，半边有方向，一条边由两个半边组成，一个面片唯一对应三个半边，如下图：
黑色的三个半边仅属于蓝色的面片，而绿色的半边不属于。如果一条半边不属于任何面片，那么该半边称作边界半边，并配有相关函数(KernelT.h)：
半边之间可以相互转换，半边①可以使用函数prev_halfedge_handle()，得到半边③；还可以使用函数next_halfedge_handle()，得到半边②；或者使用函数opposite_halfedge_handle()得到半边④；(如下图)
顶点可以通过函数halfedge_handle_，得到一条半边，该半边指向该顶点。
其余的就不一一介绍了。
VS小技巧 查找 本项目过于复杂，经常找不到函数位置，所以“查找”功能使用的比较多，快捷键为==“Ctrl + F”==，并且我常常使用“在项目中查找”，因为常常会出现在意想不到的文件中。
查看定义 注意代码复用，例如老师已经完成了边长计算函数：
(鼠标拖动选择函数，点击右键，转到“查看定义”；)
(得到如下小窗口提示：)
重点关注函数名，输入参数以及返回参数类型。老师写的函数名比较规范，见名知意，用来计算边的长度，需要输入 EdgeHandle 类型的参数，返回的长度是浮点数类型的。以后还有很多的函数、变量等通过“查看定义”的方式弄清楚其含义。
(有可能“查看定义”会找不到什么实质性东西，建议用第一种“查找”来解决)
查找所有引用 鼠标拖动选择函数，点击右键，转到“查找所有引用”：
在下方弹出提示信息：
找到项目调用它的地方。
1. 计算三角网格中每个三角形的面积 (10分) 题目说明 此函数已经被声明为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deeebc9646bb42f34b3f3ba42b4de2b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b503fd4da7c7f2a2e28e445e7d8263c4/" rel="bookmark">
			让NotePad&#43;&#43;添加到右键快捷方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击查看。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78aa73a2098f283402bcf94182a8a4b3/" rel="bookmark">
			软件开发面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Windows内存管理方法 windows内存管理方式主要分为:页式管理，段式管理，段页式管理。
2.IP和 Mac的解析协议是什么? IP和Mac的解析协议是地址解析协议ARP，是根据IP地址获取物理地址的一个TCP/IP协议。
3.解释VPN VPN的英文全称是“Virtual Private Networ议，为虚拟专用网络，虚拟专用网(VPN〉被定义为通过一个公用网络（通常是因特网）建立一个临时的、安全的连接，是一条穿过混乱的公用网络的安全、稳定的隧道。虚拟专用网是对企业内部网的扩展。虚拟专用网可以帮助
4.继承和多态 (1)继承:当两个或两个以上的类，具有部分相同的内容(属性和方法)并且可抽象出另一个类彼此之间满足is-a关系，这种关系就是继承。在继承关系中，父类更通用、子类更具体更有一版特性和行为，而子类除了具有父类的特性和行为，还具有一些自己的特殊的特征和行为。在子类继承父类中构造方法和私有方法不能被继承。继承具有代码的可重用性、父类的属性和方法可用于子类、设计应用程序变得更加简单、可以轻松地自定义子类。
(2)多态:同一个实现接口，使用不同的实例而执行不同的操作。多态不仅能减少编码的工作量，也能大大提高程序的可维护性及可扩展性。能改善代码结构，提高其可读性。多态是从类的角度来处理逻辑上的分离。能把多个类(派生同一个基类)当做一个类来处理。这样就能作用于不同的类型了。
5.排序算法的种类 (1)插入排序:每次将一个待排序的数据元素，插入到前面已经排好序的数列中的适当位置，使数列依然有序，直到待排序数据元素全部插入完为止。
(2〉选择排序:每一趟从待排序的数据元素中选出最小(或最大〉的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。
(3）冒泡排序:两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没有反序的数据元素为止。
(4〉快速排序:在当前无序区中任取一个数据元素作为比较的"基准"，用此基准将当前无序区划分为左右两个较小的无序区，且左边的无序子区中数据元素均小于等于基准元素，右边的无序子区中数据元素均大于等于基准元素，而基准则位于最终排序的位置上，直至所有无序子区中的数据元素均已排序为止。
(5）堆排序:堆排序是一树形选择排序，在排序过程中，将数据看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。
(6）分配排序、归并排序、希尔排序
6.进程和线程的区别 一个程序至少有一个进程，一个进程至少有一个线程。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源。进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程.
7.软件开发模型 软件开发模型是指软件开发全部过程﹑活动和任务的结构框架。软件开发包括需求、设计、编码和测试等阶段，有时也包括维护阶段。软件开发模型能清晰﹑直观地表达软件开发全过程，明确规定了要完成的主要活动和任务，用来作为软件项目工作的基础o
(1）瀑布模型:每个软件过程顺序衔接、一次性通过。最常用。需求明确且很少变更的项目，如二次开发或升级型项目。
(2〉螺旋模型:以原型为基础沿螺线旋转﹑每转―圈都经过计划/风险分析/实施/评估等过程且得到相应新版本、经过若干次螺旋上升得到最终版本。需求经常变化的大型复杂系统。
(3）增里模型:采用随时间进展而交错的线性序列﹑每个序列产生一个可发布的增里﹑每个增里产生一个可操作的产品﹑第一个增里是核心产品。需求经常发生改变的软件开发过程。
(4）快速原型模型:快速构建可运行的软件模型﹐以便理解和澄清问题，进一步细化需求﹐在新获取需求基础上进行系统开发。用户需求模糊不明的情况下。
(5〉迭代模型:一次迭代过程包括了所有软件开发流程﹑每一次迭代均产生一个可发布的产品、该产品为最终产品的一个子集。适用于事先不能完整定义产品的所有需求，计划多期开发的项目。
(6〉喷泉模型:以用户需求为动力、以对象为驱动的模型，支持软件复用及多项开发活动的集成，主要支持面向对象的开发方法。
8.TCP三次握手 TCP 是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:位码即tcp标志位,有6种*示:SYN(synchronous建立联机)ACK(acknowledgement确认) PSH(push传送) FIN(finish结束)RST(reset重置)URG(urgent 紧急)Sequencnumber(顺序号码y Acknowledge numbei确认号码)。
第一次握手∶主机A发送位码为syn =1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机
第二次握手:主机B收到请求后要确认联机信息，向A发送ack numbere=住机A的seq+1)syn=1,ack=1,随机产生seq=7654321的包。
第三次握手:主机A收到后检查ack number是否正确，即第一次发送的seq number+1以及位码ack 是否为1，若正确。主机A会再发送acnumbere=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=-1则连接建立成功。
完成三次握手，主机A与主机B开始传送数据。第一次握手∶建立连接时，客户端发送syn 包(yn=j)到服务器﹐并进入SYN_SEND 状态，等待服务器确认﹔第二次握手:服务器收到sy包，必须确认客户的SYN (ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态﹔第:次握手∶客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=t±1)，此包发送完毕，客户端和服务器进入ESTABLISHEI状态,完成三次握手。完成三次握手,客户端与朋务器开始传送数据。
9.osi七层模型 第一层:物理层比特流设备之间比特流的传输,物理接口，电气特性等。
第二层:数据链路层帧将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正。
第三层:网络层包提供逻辑地址（P)、选路，数据从源端到目的端的传输。
第四层:传输层段实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流里控制等。
第五层:会话层数据允许不同机器上的用户之间建立会话关系，如WINDOws
第六层:表示层数据数据的表现形式，特定功能的实现，如数据加密。
第七层:应用层数据用户接口,提供用户程序“接口”。
10.谈谈Overload和l Override 的区别。 方法的重写Overriding 和重载Overloading 是 Java 多态性的不同表现。
重写Overriding是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78aa73a2098f283402bcf94182a8a4b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63707ad69955524082ba703bd73a1e8b/" rel="bookmark">
			CASA方法估算NPP（IDL&#43;ENVI）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CASA方法估算NPP（IDL+ENVI） 一、NPP的定义二、估算流程三、实现代码 （IDL) 一、NPP的定义 NPP是什么：净第一性生产力，又称净初级生产力，是指从绿色植物在单位时间内单位面积上能固定的总能量中除去其自身呼吸消耗掉的部分，单位为焦耳/厘米2/年或克/米2/年。
可表示为：NPP = GPP - Ra
在上式中Ra表示自养呼吸的消耗量、GPP表示总初级生产力。
意义：NPP反映着植物固定和转化光合作用产物的效率，也决定了可供利用的物质和能量。是人类生活所需食物、原料及燃料的来源。植物通过光合作用将太阳能固定并转化为植物生物量。
以上摘自百度百科
二、估算流程 CASA模型反演NPP流程图：
1、温度胁迫因子1
Topt(x,y) 为某一区域一年内 NDVI 值到达最高时的当月平均气温（单位℃），当某个月的平均气温低于或等于-10℃，Tε1(x,y) 取值为0，此时不会发生光合作用。
2、温度胁迫因子2
当某个月平均温度 T(x,y,t) 比适宜温度 Topt(x,y) 高10℃或者低13℃时，该月的 Tε2(x,y,t) 等于月平均温度为最适宜温度 Topt(x,y) 时 Tε2(x,y,t) 的一半。
3、水分胁迫因子
EET(x,y,t) 表示(x,y)处像元t月份的实际蒸散发量（单位mm），PET(x,y,t) 表示(x,y)处像元t月份的潜在蒸散发量（单位mm）。
P(x,y,t)表示(x,y)处像元 t月份的降水（单位mm），Rn(x,y,t) 表示(x,y)处像元t月份的地表净辐射量（单位MJ/m2）。
Ep0(x,y,t) 表示局地潜在蒸发量（单位mm）。
a(x,y) 为因地而异的常数。
I(x,y) 代表12个月总和热量指标。
T(x,y,t) 为 (x,y) 处像元 t 月份的平均温度。
4、实际光能利用率
式中，Tε1(x,y) 和 Tε2(x,y) 为温度胁迫因子，Wε(x,y) 为水分胁迫因子，εMAX 为最大光能利用率。
5、植被层对入射光和有效辐射的吸收比例
NDVImax 和 NDVImin 代表草地的 NDVI 最大值和最小值，FPARmin 和 FPARmax 的取值与植被类型无关，分别为0.001 和0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63707ad69955524082ba703bd73a1e8b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/338/">«</a>
	<span class="pagination__item pagination__item--current">339/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/340/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>