<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315412ad2e45d8dace6ddde992e2333d/" rel="bookmark">
			C# Socket实现两台电脑通信（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自哔哩哔哩课程https://www.bilibili.com/video/BV1FJ411W7e5?p=186 第181-186 一、服务器端
1.GUI使用到的控件及其命名(Name)：注意txtServer和txtPort中的Text参数默认设置为如图，也就是我们把地址和端口号默认为此，地址可以更改或设置为自动获取本机IP地址
2.Server的主程序
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; using System.Threading.Tasks; using System.Windows.Forms; namespace _181_Socket网络编程 { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { try { //创建监听的Socket Socket socketWatch = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); //创建IP地址和端口号对象 IPAddress ip = IPAddress.Any; //IPAddress.Parse(txtServer.Text); IPEndPoint point = new IPEndPoint(ip, Convert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/315412ad2e45d8dace6ddde992e2333d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b1625dcada347df49506638b50b478a/" rel="bookmark">
			创建docker镜像并push到docker hub上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在上一篇文章中我已经安装好了redis6.0及gcc7.1。
先同步一下系统和硬件的时间，要不然docker hub会出错
同步命令：hwclock
创建容器：docker build -t redis50 .
查看容器：docker images
运行容器：docker run -itd --name redis50 redis
查看容器信息：docker ps
进入容器：docker exec -it redis50 bash
退出容器：exit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a30c257acc8930fb773a7713b79d038a/" rel="bookmark">
			3_Docker 常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程命令 启动docker服务:
systemctl start docker 停止docker服务:
systemctl stop docker 重启docker服务:
systemctl restart docker 查看docker服务状态:
systemctl status docker 设置开机启动docker服务:
systemctl enable docker 帮助命令 查看 docker 版本
docker version 查看 docker 镜像数、Register等详细信息
docker info 更多指令查看
docker --help 镜像命令 （1）查看 docker 本地主机镜像 docker images 各个选项说明:
REPOSITORY：表示镜像的仓库源 TAG：镜像的标签[类似版本号] IMAGE ID：镜像ID[唯一] CREATED：镜像创建时间 SIZE：镜像大小 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用ubuntu:latest镜像
OPTIONS说明： -a :列出本地所有的镜像（含中间映像层）[一个镜像可能不止一层，类似千层饼] -q :只显示镜像ID [在删除镜像时,可能要 -qa 结合使用] --digests :显示镜像的摘要信息 --no-trunc :显示完整的镜像信息 （2）docker search 某个XXX镜像名字 网站：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a30c257acc8930fb773a7713b79d038a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/908969f24980dd75b4d2783c2ca419ce/" rel="bookmark">
			easyUI 在datagrid中进行单元格编辑，并在单元格加入自定义combobox下拉框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中需要使用easyUI的datagrid表格来展示数据，并允许用户对部分列单元格进行编辑、保存。单元格格式为文本（text）或者下拉框（combobox）。
（1）datagrid的创建使用可以参考easyUI官网。https://www.jeasyui.net/plugins/183.html
（2）datagrid默认是不允许编辑里面的单元格的，需要一些配置才可以进行编辑操作。官网也有例子。https://www.jeasyui.net/demo/332.html
注意：只要你写的代码和官网一致，是可以实现编辑操作的。但是我自己试的时候，是部分copy的，有些部分冲突了，找了半天才找到原因。我在html部分定义了表格的列信息
&lt;table id="dg" class="easyui-datagrid" style="width:1010px;height:auto" data-options=" iconCls: 'icon-edit', singleSelect: true, toolbar: '#tb', method: 'get', onClickCell: onClickCell"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th data-options="field:'id',width:150,hidden:true"&gt;用户需求内部编号&lt;/th&gt; &lt;th data-options="field:'userReqBocNo',width:150"&gt;用户需求内部编号&lt;/th&gt; &lt;th data-options="field:'sysReqBocNo',width:150"&gt;系统需求需求内部编号&lt;/th&gt; &lt;th data-options="field:'sysReqName',width:150"&gt;系统需求名称&lt;/th&gt; &lt;th data-options="field:'milestone',width:150,editor:'text'"&gt;当前里程碑点&lt;/th&gt; &lt;th data-options="field:'startTime',width:100,editor:'datebox'"&gt;开始时间&lt;/th&gt; &lt;th data-options="field:'endTime',width:100,editor:'datebox'"&gt;结束时间&lt;/th&gt; &lt;th data-options="field:'status',width:100,editor:'text'"&gt;状态&lt;/th&gt; &lt;th data-options="field:'percent',width:100,editor:{type:'combobox',options: {url:'loadComboxData.action?projectId=&lt;%=projectId %&gt;&amp;comboxKey=enum&amp;enumId=percent',valueField: 'value', textField: 'text'}}"&gt;完成百分比&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; 在js也定义了表格的列信息，但是在js中定义的列数和html中定义的列数不一致（html多出来一个了，没注意到）。导致单元格编辑无效。所以写代码要仔细，慢，切忌赶工。
（3）现在单元格已经可以进行编辑了，看上面的html代码，&lt;th&gt; 中有个属性 editor，这个就是你的单元格进行编辑的时候编辑类型。
editor:'text' 文本类型、editor:'datebox' 日期类型、还有最后一个 editor:{type:'combobox', ……} 下拉框类型。
主要是combobox
url ： 下拉框数据的地址
valueField : 下拉框内容中每个选项的value
textField: 下拉框内容中每个选项的text（就是你可以看到的选项）
数据演示：
loadComboxData.action?projectId=&lt;%=projectId %&gt;&amp;comboxKey=enum&amp;enumId=percent 下面这个地址获取到的内容如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/908969f24980dd75b4d2783c2ca419ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506667fcab7a1ea37db14ecf0043ea82/" rel="bookmark">
			Photoshop CS6调整界面字体大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找到应用程序photoshops.exe或快捷方式，右键，属性，兼容性，选替代高dpi缩放行为，选“系统”即可。
最终效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54dfb4ec6c6962a5e233e45837a8d592/" rel="bookmark">
			10个数平均分两组，差值最小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 10个球员准备分两队进行训练赛，教练希望两个队战斗力差值能尽可能小，以达到最佳的训练效果。
输入：
10个队员的战斗力，如[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
输出：
最小的战斗力差值，如：1
用递归解决：
class Solution: def balance(self, candidates): res = [] cur = [] self.back(candidates, 0, cur, res) return min(res) def back(self, candidates, start, cur, res): if len(cur) == 5: res.append(abs(sum(candidates) - sum(cur) - sum(cur))) return for i in candidates[start:]: cur.append(i) self.back(candidates, candidates.index(i) + 1, cur, res) cur.pop() print(Solution().balance([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4821b81e0a4f97e9bfa27564828ea5a/" rel="bookmark">
			图像分类的 PyTorch 实现 (CIFAR10)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像分类是最基本的问题之一，对于人类大脑来说可能是微不足道的，但对于计算机来说却似乎是不可能完成的任务。但是只要有正确的技巧，这是很容易做到的！
本文的目的是简要介绍如何在 PyTorch 的帮助下开始任何图像分类任务。我采用了一个相当简单的线性层次结构，因此关注的是广泛的想法，而不是细节，比如卷积神经网络。
好了，让我们开始吧。
我假设你已经安装了 PyTorch，并可以正确调用gpu进行任务的执行。当然也可以在 Kaggle 或者 Google Colab 提供的免费计算机上运行这个程序。他们是相当容易安装，并且通过 import torch 命令便可以顺利进行导入。好了，让我们进入有趣的部分。
尝试多种不同的神经网络架构来解决问题的能力使得深度学习变得非常强大，尤其是相对于像线性回归、 Logit模型等浅层学习技术而言。在本教程中，我们将首先试验一个线性网络，然后尝试一个卷积设置。
数据集: CIFAR10。CIFAR-10数据集由10个类别的60000张32x32彩色图像组成，每个类别有6000张图像。有50000张训练图片和10000张测试图片。
该数据集被分为五个训练批次和一个测试批次，每个批次有10000张图像。这个测试批处理包含从每个类中随机选择的1000张图像。训练批次包含随机顺序的剩余图像，但某些训练批次可能包含来自一个类的图像多于另一个类的图像。在他们之间，训练批次包含来自每个类别中的5000张图像。
导入所需的库：
import torch import torchvision import numpy as np import matplotlib.pyplot as plt import torch.nn as nn import torch.nn.functional as F from torchvision.datasets import CIFAR10 from torchvision.transforms import ToTensor from torchvision.utils import make_grid from torch.utils.data.dataloader import DataLoader from torch.utils.data import random_split %matplotlib inline ‍ 现在让我们来看看我们一直在讨论的数据集：
dataset = CIFAR10(root='data/', download=True, transform=ToTensor()) test_dataset = CIFAR10(root='data/', train=False, transform=ToTensor()) Downloading https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4821b81e0a4f97e9bfa27564828ea5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a2d5594733f61a122a8bc0d214a88b/" rel="bookmark">
			q87主板支持cpu型号_AMD锐龙2600该如何选主板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天小伙伴提问amd r5 2600配什么主板好？重点要求要越便宜越好，说实话这年头配件一分钱一分货如果要便宜那么自然在品质方面就有所缩水，今天我们就来盘点一下AMD锐龙2600可以搭配那些便宜主板；
首先我们来看看R5 2600的具体参数；
CPU品牌 AMD
所属系列 二代锐龙
制作工艺 12纳米
CPU主频 3.4GHz动态加速频率3.9GHz
核心数量 六核心线程数量十二线程
二级缓存3MB 三级缓存16MB
热设计功耗 (TDP)65W
​内存类型 DDR4 2933MHz
内存最大内存通道数：2
从上面的参数得知这是一颗性能非常不错的处理器，在主板选择上面尽量选择与其性能相当的主板，支持二代锐龙的主板有主板有以下型号主板，关于这个型号A320定位入门级，B350 B450定位中端主流级，X370 X470定位高端级，(下面全部是以技嘉部分主板型号为例，并不代表所以型号，只作为部分参考)
A320 主板
A320 主板支持CPU接口类型AM4，兼容AM4 插槽： - 支持锐龙AMD Ryzen处理器 - 支持AMD第七代A系列/Athlon处理器，2个DDR4 DIMM插槽，内存支持频率DDR4 2667、DDR4 2400、DDR4 2133，最大内存容量32GB，支持双通道，其中大部分型号都不支持M.2插口！
B350主板
B350主板 接口类型为AM4，兼容AM4 插槽： - 支持AMD 锐龙Ryzen处理器 搭载4个DDR4 DIMM插槽，部分型号搭载2根内存插槽，自己在购买的时候看清楚，价格上自然也是不一样的，支持内存频率为DDR4 3200(O.C.)、2933(O.C.)，2667、2400、2133MHz，最大支持内存容量64G，支持双通道，搭载1个M.2插口，部分型号2个！
X370主板
支持CPU接口类型AM4，兼容AM4 插槽： - 支持AMD 锐龙RYZEN处理器，前段总线/HT总线，4个DDR4 DIMM插槽，最高 支持到64 GB ，内存频率DDR4 3200(O.C.) 2933(O.C.)DDR4 2667、2400、2133，最大内存容量64G，支持双通道，交火/SLI，支持 NVIDIA Quad-GPU SLI 及 2-Way NVIDIA SLI技术;支持 AMD Quad-GPU CrossFireX 及 2-Way AMD CrossFire技术，2个M.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a2d5594733f61a122a8bc0d214a88b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2784200a70a01957cce793ea68c0c2d/" rel="bookmark">
			c语言   *p[N], (*P)[N],及**p的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先明白什么是指针变量，和指针。指针其实就是存储单位的地址，指针变量是一个变量，用来存放指针（即地址）;
int *p[N]表示指针数组，也就是说定义了N个int型的指针变量。
其中p[0] p[1] p[2] ...... p[N-1] 为指针变量，每个指针变量存放任意int型指针。
p是一个二重指针，p为是指针变量p[0]的指针（就是p[0]的地址）。
int (*p)[N]表示定义p为一个指针变量，它指向包含N个整形元素的一维数组。
其中(*P)[0] (*P)[1] ...... (*P)[N-1] 这些为一维数组的N元素。每个元素表示一个整形的变量，和int a中a表示的含义一样。
(*p)表示的就是(*P)[0]的指针（即地址），就和int a[] 中的a含义一样。
p为一个指针变量，存放的是(*p)的指针（地址的地址）。指针变量p存放的一个二重指针，和int **p中的p含义一样。
int **p 表示定义一个指向指针的指针。
p为一个指针变量，存放的是指针的指针（地址的地址）。
注：*p[N] ， (*p)[N] 它们中的p表示含义不同，一个表示的指针，一个表示的指针变量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d34c6b75a2a589fb86de864fcfa1b4dd/" rel="bookmark">
			助力高考|为117万艺考学子保驾护航
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		助力高考|为117万艺考学子保驾护航 演员请就位“艺考”这座独木桥为艺考保驾护航，云掣在行动 演员请就位 在最近的一档综艺节目《演员请就位》中，李诚儒和郭敬明的“掰头”赚足了网友们的关注，事件中心的何昶希，因演技受到质疑而引发导演间争议。更是引起了其他选手的不满，提出“what？他以为他是在选秀节目吗？”这样的疑问。
随着事件在网上的发酵升温，网友们将关注点从节目本身转移到何昶希未来发展上，对他接下来的在节目中的命运，乃至今后演艺生涯都有着不同的猜测，更有甚者认为郭敬明的这张“S卡”断送了何昶希的前程。
在最新的一期节目中，郭敬明竟然第二次为何昶希亮出了“S卡”，让网友们瞋目结舌。意想不到的是，尔冬升导演也亮出了他的“S卡”。何昶希的表现狠狠的打了吃瓜网友一巴掌，“演技上一小步，未来发展的一大步”，这一次演技上的提升，使得大家对他都刮目相看。
张艺谋导演曾说过：“人的潜力是无限的，一个人就像橡皮筋一样，需要不断地拉，在这个过程中挑战自己的极限，不断扩展自己的能力。”可能正是郭敬明的“S卡”激发了何昶希的潜力，让他有了0→1的过程。何昶希的这个事件，让我们不禁的思考一名优秀演员的标准是什么？演员的专业要求有多高？演员真的这么好当吗？
答案当然是否定的！虽然艺人光鲜靓丽的一面充斥在我们日常生活的各个角落，并且这一职业的高收入现状吸引了越来越多的年轻人踏入艺术行业，但是这条道路上第一道关卡就是“艺考”。
“艺考”这座独木桥 2016年参加艺考人数突破100万，就此拉开了“艺考热”的序幕。近几年各大艺术院校的报考人数，更是屡次创下历史新高，截至2020年艺考生高达117万人。
同时114:1的高专业录取比，表演力的高难度考核，使得艺考生日以继夜的努力成为生活常态。从考试报名到考试准备，各个环节都要十分的注意。尤其是报名，如若失误，相当于“不战而败”。
为艺考保驾护航，云掣在行动 互联网的快速发展正在潜移默化地改变着我们的生活，一款为艺考“全程陪护”的线上应用软件应需而生，专注为国内艺术生提供考试报名、院校资讯、考程安排、报考提醒、文化分测算、艺术备考公开课等服务。
为了给考生提供更大的便利，避免在各大院校间辗转奔波，随之又上线了考试模块，新增提交试卷上传监考视频等功能。
这一改变，给该软件的业务系统带来了不小的挑战，为保证考试的顺利进行，需要有丰富高压高并发场景下护航经验的运维团队来保障应用系统平稳运行。 云掣不胜荣幸担此重任，为艺考出一份力。
模拟测压，盘查隐藏风险点
云掣全面梳理系统架构及业务数据流，根据历年考试期间的情况，模拟真实考试场景进行多次多点压测，针对不同环节的业务（如：考试报名、试卷查看、提交试卷业务等）盘查隐藏风险点。发现该软件在实际的高压场景下，极容易发生系统异常的状况，如：闪退，图片乱码，语音错误等。资源扩容，分析问题来源
云掣对系统运行情况进行倒推分析，检测服务器资源使用情况，发现服务器现有资源有限，无法承载业务高峰期运行的压力，提出资源扩容方案。性能优化，从源头解决问题
同时根据检测结果，针对应用层软件和数据库遇到的性能瓶颈，提出详尽的优化方案和整改建议，直接从源头上解决问题。架构优化，分流业务压力
云掣考虑到同一时刻多人提交试卷、上传监考视频的场景，为避免对后端业务造成负担。缩短原本需要经过多层转发的数据流转路径，从前端直接调用存储接口上传答题照片及视频材料文件。利用对象存储海量可扩容和不受硬盘容量限制的特性，实现多地域分流，调高上行带宽的限制，开放QPS限制。全景监测，多级预案保障
云掣全程提供7*24实时监控，设置多级应急预案避免突发风险，顺利保障了数万考生的首次线上艺考交卷，为“艺考梦”保驾护航。考试当天同一时间峰值人数10000+，系统处于稳定状态。 今年的艺考季即将开始，又将有一群可爱的考生们，不畏严寒追逐梦想，成为那天空中美丽的一颗星，云掣也将尽自己的一份力，以一种特殊的方式为考生们加油！
更多业务信息请查看云掣官网https://www.dtstack.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b31c2ec57e733afad576c354cb396d0/" rel="bookmark">
			2020-11-10 更换CentOS的yum repo源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近重新装了CentOS，结果源很慢，通过置换为国内的阿里云源完美地解决了。
备份
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
下载新的CentOS-Base.repo 到/etc/yum.repos.d/
CentOS 5 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo
curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo
CentOS 6
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo
CentOS 7
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46951c981fbc5c2ce11dc5e7070b317/" rel="bookmark">
			python的requests模块参数详解[转载]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import requests print(dir(requests)) # 1、方法 # ['ConnectTimeout', 'ConnectionError', 'DependencyWarning', 'FileModeWarning', 'HTTPError', 'NullHandler', 'PreparedRequest', 'ReadTimeout', 'Request', 'RequestException', 'RequestsDependencyWarning', 'Response', 'Session', 'Timeout', 'TooManyRedirects', 'URLRequired', '__author__', '__author_email__', '__build__', '__builtins__', '__cached__', '__cake__', '__copyright__', '__description__', '__doc__', '__file__', '__license__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '__title__', '__url__', '__version__', '_check_cryptography', '_internal_utils', 'adapters', 'api', 'auth', 'certs', 'chardet', 'check_compatibility', 'codes', 'compat', 'cookies', 'delete', 'exceptions', 'get', 'head', 'hooks', 'logging', 'models', 'options', 'packages', 'patch', 'post', 'put', 'request', 'session', 'sessions', 'status_codes', 'structures', 'urllib3', 'utils', 'warnings'] # 2、参数 requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46951c981fbc5c2ce11dc5e7070b317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd10230942f5cb85863035e16a1b9e6b/" rel="bookmark">
			一不小心画了 24 张图剖析计网应用层协议！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章的整体脉络如下
在有了之前两篇文章的介绍后，相信读者对计算机网络有了初步的认识，那么下面我们就要对不同的协议层进行分类介绍了，我们还是采用自上而下的方式来介绍，这种介绍对读者来说更容易接纳，吸收程度更好(说白了就是更容易给我的文章点赞，逃)。
一般情况下，用户不太在意网络应用程序实际上是按照怎样的机制运行的，但我们是程序员吖，就套用朱伟的一句话说：你觉得计算机网络程序员不了解，你指着互联网用户去了解吗？有内个味儿没？
应用层指的是 OSI 标准模型的第 5、6、7层，也就是会话层、表现层、应用层。
我们介绍的时候都会使用 OSI 标准模型来介绍，因为这样涵盖的层次比较多，这样对于 TCP/IP 模型来说，你也能加深理解。
应用层概念 应用层协议的定义 现如今，越来越多的应用程序利用网络进行通信，这些应用有 Web 浏览器、远程登录、电子邮件、文件传输、文件下载等，应用层的协议正是进行这些行为活动的规则和标准。
应用层协议(application layer protocol) 定义了在不同端系统上的应用程序进程如何相互传递报文。一般来说，会定义如下内容
交换的报文类型：是请求报文还是相应报文报文字段的解释：对报文中各个字段的详细描述报文字段的语义：报文各个字段的含义是什么进程何时、以什么方式发送报文以及响应 应用层体系结构 应用层体系结构 的英文是 Application Architecture，它指的是应用层的结构，一般来说，应用层有两种主流体系结构
客户 - 服务器体系结构 ( client-server architecture )对等体系结构 ( P2P architecture ) 下面我们先来聊一下客户 - 服务器体系结构的概念
在客户-服务器体系结构中，有一个总是打开的主机称为 服务器(Server)，它提供来自于 客户(client) 的服务。我们最常见的服务器就是 Web 服务器，Web 服务器服务于来自 浏览器 的请求。
当 Web 服务器通过浏览器接收到用户请求后，它会经过一系列的处理把信息或者页面等通过浏览器呈现给应用。这种模式就是客户 - 服务器模式。
有两点需要注意
在客户 - 服务器模式下，通常客户彼此之间是并不互相通信的。服务器通常具有固定的、周知的 IP 地址可以提供访问。 客户 - 服务器模式通常会出现随着客户数量的急剧增加导致单台服务器无法完成大量客户请求的情况。为此，通常需要配备大量主机的 数据中心(data center) ，用来跟踪所有的用户请求。
于此相反，P2P 也就是对等体系结构对这种数据中心的依赖性很低，因为在 P2P 体系结构中，应用程序在两个主机之间直接通信，这些主机被称为对等方，与有中心服务器的中央网络系统不同，对等网络的每个用户端既是一个节点，也有服务器的功能。常见的 P2P 体系结构的应用有 文件共享、视频会议、网络电话等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd10230942f5cb85863035e16a1b9e6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea7d7d4d75d358d8667eb36747d78b1/" rel="bookmark">
			Mytime说明书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mytime说明书 一、版本介绍 1、最新版本 最新版是3.0，发布于2020年11月21号。
版本3.0来啦~~~1、添加“时间”功能模块，倒计时、闹钟、计时器、专注等功能一网打尽！2、优化对“保持窗口最上方显示”体验；3、优化“启动时播放”的体验；4、优化记事本功能，更加舒适记录信息；5、美化页面，美观美观~6、修复了你没发现的BUG~ 2、其他版本 1）版本2.61，发布于2020年11月13号 下载地址。提取码：hqob 1）增加颜色选择面板，更方便设置自定义颜色。
2）调整窗口大小，减少对其他应用的干扰。
3）随意设置窗体的显示是否保持最上。
4）美化页面，心情舒畅。
5）修复了部分bug~
2）版本2.6，发布于2020年11月11号。 下载地址，提取码：7y27 1）修复了显示白色后直接消失的错误；
2）可更加便捷地反馈意见或建议；
3）修复了其他BUG~
二、问题实例 1、窗口设置 1）如何开启（或关闭）软件的开机自启动？
3）为什么要以管理员身份打开？
2）如何将显示窗体固定在我想放的位置？
3）如何使用窗体靠边自动隐藏？
4）如何使用备忘录？
2、实用工具 4）如何使用“网络测速”功能？
5）进行网络测速时，怎么选择网卡？
3、帮助 1、如何进行反馈或提意见？
2、“发送反馈”能直接发给你吗？
3、能不能加个好友进一步交流？
三、写在最后 我希望能得到您的任何意见或建议，这能够使您用到更加实用的产品。如果你对项目技术本身感兴趣，欢迎进一步交流。
编写此软件所用的语言大概有90%的C#+10%的C++。奈何学识浅薄，对很多知识不甚理解。幸运的是在互联网上直接或间接的得到了很多大佬的帮助，在此不一一感谢。有时会参考某些大佬的技术博客或论坛帖子中的一些代码或者设计思想，在此列下。
1、程序加壳与反编译
另外此项目持续更新，感谢我的朋友支持（以汉字拼音为序） 可·乐
爽哥
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69c9c61ce2db5f30f8d1dadf36a472be/" rel="bookmark">
			word文档中打钩的8种方法【实用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、直接插入符号
将光标定位于需要打钩的地方，选择【插入】→【符号】→【其他符号】。 在符号栏里，字体改成【Windings2】，然后选择√号 2、用输入法自带的字符
把搜狗输入法或者QQ拼音输入法直接搜索【对】，即可出现下方字符
3、快捷键
按住键盘上的Alt键不松开，然后敲击小键盘上的9745，输入完以后再松开Alt键，此时我们会发现页面中就会出现一个方框内打钩的符号了
4、还是快捷键
先在文档中输入2611，然后使用按下键盘上的组合键【Alt+X】，这个时候你会神奇的发现数字也变成了方框内打钩这个符号。
5、艺术字
这一个方法是将√浮在文字上方
首先借用搜狗输入法，在文档中输入“√”，然后选中文本，点击【插入】——【文本】——【艺术字】，选择一种颜色，随后将艺术字的布局设置为【浮于文字上方】，之后移动到合适的位置即可。
6、借用域代码
按快捷键Ctrl+F9插入域符号{}，之后输入代码：eq \o(A,\s\down6(√))，然后再次选中内容按Shift+F9切换域代码即可在字母下方添加√。
Ctrl+F9
输入代码：eq \o(A,\s\down6(√))
Shift+F9
在字母上方打勾输入代码：eq \o(A,\s\up6(√))
7、加边框法
我们先在文档中插入对号。然后，我们选择开始，在字体和段落中都有为文字添加边框的选项，点击图示字符边框选项，即可为对号加上边框。 8、设置带圈字符
我们还可以设置带圈字符，选择开始--字体--带圈字符。在带圈字符中选择对号和正方框，点击确定即可！
以上内容转自：https://zhuanlan.zhihu.com/p/142103469?utm_source=wechatMessage_article_bottom
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f9092327d3b901766312312e4d5f12/" rel="bookmark">
			两台电脑navicat数据传输_【笔记】两台西门子S7-200Smart PLC进行无线通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章转载自微信公众号“自动化电气工程师技术交流与分享”
关键词：无线网桥
本文目标：以西门子S7-200 Smart PLC为例，实现基于以太网、无线网桥的通讯
主要步骤一，硬件选型、接线二，参数设置 正文开始
一，硬件选型、接线 1，这里选择无线网桥，型号随意，一个主网桥，一个子网桥，作为无线交换设备，一个PLC与无线网桥的接线如下图所示，另外一个PLC同理。
//第一步结束
二，参数设置 2
2，根据自己所需，先对无线网桥进行参数变更、配置。比如设置密码、IP地址等。(将插到PLC的网线拔出插到电脑，参考附带的说明书设置步骤进行操作即可)
3，STEP 7-MicroWIN SMART软件(公众号首页导航栏有下载地址)，进行PLC的IP地址设置，如图所示。
注：假如两台PLC进行通讯，则两台PLC+两个无线网桥模块=四个IP地址，需设置为同一网段下的不同地址，避免冲突，如分别设为
192.168.1.0
192.168.1.1
192.168.1.2
192.168.1.3
即可
4，两个PLC如需进行数据传输，则参考本公众号历史文章，☞【笔记】多台西门子S7-200 Smart通过以太网实现通信
/第二步结束
本文目标完成。
往期文章：
【笔记】西门子S7-200Smart与读卡器、温湿度传感器、扫码枪等设备通讯
【笔记】多台西门子S7-200 Smart通过以太网实现通信
【笔记】ABB机器人零基础编程步骤详解
【机器人篇】ABB、库卡、安川、发那科等工业机器人资源汇总
【电工基础篇】电工电子技术、常用仪器、维修等资源汇总
【触摸屏篇】Proface、威纶、三菱、松下、组态王等资源汇总
【PLC篇】西门子、三菱、松下、欧姆龙等品牌的软件、视频、资料下载
【相关软件篇】485参数配置软件、USB转485模块驱动程序等资源下载
本公众号长期分享自动化电气工程师的必备干货，内容涉电工基础、电气制图、设备选型，以及各种主流型号的PLC、触摸屏、伺服驱动、步进驱动、变频器、机器人、视觉、MES上位机等的软件、教程、资料，升级之路需学习的Python、C#、LabView、VB等资源
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b93747040295fb7aba4faed315fc49/" rel="bookmark">
			Wireshark抓包实验验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据链路层 实作一 熟悉 Ethernet 帧结构
使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。
问题：你会发现 Wireshark 展现给我们的帧中没有校验字段，请了解一下原因。
答：这是因为有时校验和会由网卡计算，这时wireshark抓到的本机发送的数据包的校验和都是错误的，所以默认关闭了WireShark自己的校验。
实作二 了解子网内/外通信时的 MAC 地址
1、ping 你旁边的计算机（同一子网），同时用 Wireshark 抓这些包（可使用 icmp 关键字进行过滤以利于分析），记录一下发出帧的目的 MAC 地址以及返回帧的源 MAC 地址是多少？这个 MAC 地址是谁的？
2、然后 ping qige.io （或者本子网外的主机都可以），同时用 Wireshark 抓这些包（可 icmp 过滤），记录一下发出帧的目的 MAC 地址以及返回帧的源 MAC 地址是多少？这个 MAC 地址是谁的？
3、再次 ping www.cqjtu.edu.cn （或者本子网外的主机都可以），同时用 Wireshark 抓这些包（可 icmp 过滤），记录一下发出帧的目的 MAC 地址以及返回帧的源 MAC 地址又是多少？这个 MAC 地址又是谁的？
问题;
通过以上的实验，你会发现：
1、访问本子网的计算机时，目的 MAC 就是该主机的
访问非本子网的计算机时，目的 MAC 是网关的
2、请问原因是什么？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b93747040295fb7aba4faed315fc49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d3df0bfe9ca89b40e1ea11e815ce44/" rel="bookmark">
			2020-11-09 VSCode在Ubuntu&#43;Snap下无法启动的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Ubuntu的Snap下安装了VS Code无法启动 sudo apt install snapd sudo snap install code --classic mkdir ($id -u) sudo mv ($id -u) /run/user/ code &amp; [1] 18060 安装snap和code以后，运行code毫无反应结束。
执行code verbose 执行code verbose如下，以后发现是X-Window打不开。详细内容请见附录。
code --verbose ... Xlib: extension "XInputExtension" missing on display ":1". Xlib: extension "XInputExtension" missing on display ":1". [12192:1109/190657.768585:ERROR:electron_browser_main_parts.cc(200)] X IO error received (X server probably went away) 解决 参考这个帖子
Unable to open VS Code on Ubuntu VM instance on Google Cloud
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2d3df0bfe9ca89b40e1ea11e815ce44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/641024b3ed76be45031abd9c9dfbaf67/" rel="bookmark">
			uft自动化测试工具安装步骤_10款好用的自动化测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都希望为 Web 应用程序构建易维护的测试。作为这个目标的一部分，我们都希望能集中精力在测试本身，而尽量避免困在实施的具体细节中。从长远来看，测试应该是可维护的，对软件定期的变更并不会破坏测试本身或者让团队的开发节奏变慢。
迭代速度 / 现实环境
某些测试工具可以在做出更改和查看结果之间提供简短的反馈循环，但不能精确地模仿浏览器的行为。其他工具可能会使用实际的浏览器环境，但会降低迭代速度，并且在连续集成系统中可能会变得更加脆弱。
Selenium 知名的浏览器 web 应用测试框架，可以用 Java、C#、Ruby、JavaScript、R 和 Python 等多种编程语言编写测试案例。
Selenium 为每种语言提供客户端 API。
Selenium WebDriver 尽可能使用原生操作系统级别的功能，而非基于浏览器 JavaScript 的命令来驱动浏览器。
这样就绕过了原生功能和 JavaScript 命令之间由于细微差别而产生的问题(包括安全限制)。它提供了很大的灵活性，甚至还支持 iframe 和多个浏览器标签。
卓越的跨浏览器功能令人印象深刻。可以在主流浏览器(Chrome、Firefox、Safari、Edge、Internet Explorer)上执行 Selenium 测试。
Selenium Grid 可以与 WebDriver 一起使用，以在远程系统上执行测试。
使用 Selenium 的唯一缺点是，它需要大量的技能，并且编写测试非常耗时。对没有编程经验的人来说，乍一看用 Selenium 编写测试似乎很容易；但是如果没有最佳实践，将导致项目内的测试自动化框架难以维护且不够稳定可靠。
https://www.selenium.dev/
Endtest Endtest 是智能自动化测试解决方案，它使用多个开源和闭源组件去简化创建和执行测试的流程。其中之一就是 Recorder 组件可以让用户不用编程技巧就能创建和执行测试。你可以用图形化界面编辑管理自己的测试案例，而不用编写任何代码。
它和 Selenium 一样拥有灵活性，允许你自动化测试场景，其中包含 iframe、多个浏览器标签、文件上传、ShadowDOM， 等等。它同 Selenium 一样拥有跨浏览器的特性， 支持所有主流的浏览器(Chrome、Firefox、Safari、Edge、Internet Explorer)。同时，它也包括跨浏览器的云框架，支持 Windows、Mac 以及移动设备上的浏览器。
此外，它还有支持 JavaScripts 执行的组件，以及发送 API 请求和连接数据库执行 SQL 语句的组件。
这些组件可用于在测试中添加额外的验证步骤，并可准备或清理测试环境。
https://endtest.io
Watir Watir 是一个 Ruby 的浏览器自动化测试开源库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/641024b3ed76be45031abd9c9dfbaf67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adfb017f693b8b644fdb09531c73f4c8/" rel="bookmark">
			【ros学习】14.urdf、xacro机器人建模与rviz、gazebo仿真详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、起因 学校的这学期课程是ros机器人开发实战，我们学习小组也要搞一个自己的机器人模型，我们组又叫葫芦组，所以我就做了个葫芦形状的机器人，虽说有点丑，本来想用maya建模再导入的，奈何不太懂maya，于是乎就用基础三形状构建了这个机器人模型。
接下来我将会将urdf建模与gazebo仿真过程详细写出，共大家参考与互相学习，如有疏漏，敬请指正。
源码：hulu机器人源码-百度网盘 提取码：hctm
不过这个葫芦机器人走路实在是不稳定，所以又写了另外的俩个机器人，源码和演示视频在文末。
二、机器人结构图 首先我们得把要构建的机器人画出来，把每个肢节的长宽高和半径都标注好，听说可以用CAD/SW/UG等软件画，我当时懒得画，画了个躯体就没画了，纯粹靠手调调节相对位置，耗费了不少时间，如果你会CAD可以减少很多调整时间，效果图大概是这样子的，找了个E100的图作为参考
三、准备工作 创建一个机器人建模的功能包 virtual-machine:~$ catkin_crate_pkg hulu_gazebo urdf xacro 依赖urdf、xacro功能包
创建各个放置文件的文件夹
总源码包文件联系结构如图： config: 配置文件launch：启动文件meshes：dae模型文件scripts：脚本文件urdf：机器人模型文件world：gazebo地图文件CMakeLists.txt: 依赖及编译规则package.xml: 包信息 修改Cmake编译系统的规则文件CMakeLists.txt，添加依赖
find_package(catkin REQUIRED COMPONENTS urdf xacro gazebo_plugins gazebo_ros gazebo_ros_control geometry_msgs roscpp rospy ) 修改软件包的描述文件package.xml
&lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt; &lt;!--编译依赖项 --&gt; &lt;build_depend&gt;urdf&lt;/build_depend&gt; &lt;build_depend&gt;xacro&lt;/build_depend&gt; &lt;build_depend&gt;gazebo_plugins&lt;/build_depend&gt; &lt;build_depend&gt;gazebo_ros&lt;/build_depend&gt; &lt;build_depend&gt;gazebo_ros_control&lt;/build_depend&gt; &lt;build_depend&gt;geometry_msgs&lt;/build_depend&gt; &lt;build_depend&gt;roscpp&lt;/build_depend&gt; &lt;build_depend&gt;rospy&lt;/build_depend&gt; &lt;!-- 导出依赖项 --&gt; &lt;build_export_depend&gt;urdf&lt;/build_export_depend&gt; &lt;build_export_depend&gt;xacro&lt;/build_export_depend&gt; &lt;build_export_depend&gt;gazebo_plugins&lt;/build_export_depend&gt; &lt;build_export_depend&gt;gazebo_ros&lt;/build_export_depend&gt; &lt;build_export_depend&gt;gazebo_ros_control&lt;/build_export_depend&gt; &lt;build_export_depend&gt;geometry_msgs&lt;/build_export_depend&gt; &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt; &lt;build_export_depend&gt;rospy&lt;/build_export_depend&gt; &lt;!-- 运行依赖项 --&gt; &lt;exec_depend&gt;urdf&lt;/exec_depend&gt; &lt;exec_depend&gt;xacro&lt;/exec_depend&gt; &lt;exec_depend&gt;gazebo_plugins&lt;/exec_depend&gt; &lt;exec_depend&gt;gazebo_ros&lt;/exec_depend&gt; &lt;exec_depend&gt;gazebo_ros_control&lt;/exec_depend&gt; &lt;exec_depend&gt;geometry_msgs&lt;/exec_depend&gt; &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt; &lt;exec_depend&gt;rospy&lt;/exec_depend&gt; 关于CMakeLists.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adfb017f693b8b644fdb09531c73f4c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa5eface26f2fb5a737b24e182f92515/" rel="bookmark">
			我开源了一个基于Vue的组织架构树组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点赞再看，养成习惯
本文 GitHub https://github.com/qq449245884/xiaozhi 上已经收录，更多往期高赞文章的分类，也整理了很多我的文档，和教程资料。欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。
大家都说简历没项目写，我就帮大家找了一个项目，还附赠【搭建教程】。
开门见山 Demo 演示地址：http://www.longstudy.club/vue-okr-tree-doc/index.html
github 地址：https://github.com/qq449245884/vue-okr-tree
项目背景 因为最近公司需要做一个OKR，OKR 里面有个对齐视图，是一个数型结构，如下图所示：
就拿我 小智 来说，如果有人对齐我的 KR 就放到我的右边，如果是我对齐了谁的 KR，就放到我的左边，类似一个上下级的关系，所以这里我用两棵树来表示左边与右边的关系。
在GitHub上找了半天，这类组件不多，也没有符合业务需求的组件，所以决定自己造轮子！
分析 既然是树，那么每个节点都应该是相同的组件节点下面套节点，所以节点组件应该是一个递归组件整棵树应该有一个全局的状态，用来管理从外部传入的值以及向外部提供的属性和方法。每相树节点应该也要有一个对应的节点状态，来管理节点自身属性和方法。 实现思路 递归组件 对于递归组件，Vue 官方文档是这样说的：
组件在它的模板内可以递归地调用自己。不过，只有当它有 name 选项时才可以这么做。
这里我用 OkrTreeNode.vue 来表示树的节点，里面是这样用递归，下面是该组件简定：
&lt;template&gt; &lt;OkrTreeNode v-for="child in leftChildNodes" :node="child" &gt;&lt;/OkrTreeNode&gt; &lt;/template&gt; export default { name: 'OkrTreeNode' } 递归组件的使用需要注意的两点是组件里面要有组件name 以及结束递归的条件。
树的状态 对于树的状态，我用一个 TreeStore 类来表示，该实现方式主要是参考 ElementUI 中的 tree 组件。TreeStore 中的属性就表示我外部传入的 pros 或者 attr 或者 事件和方法，都在这个对象里面管理，具体的代码可以看这里：
https://github.com/qq449245884/vue-okr-tree/blob/main/src/lib/vue-okr-tree/model/tree-store.js
节点的状态 对于节点的状态，我用一个 Node 对象来表示，具体的代码可以看下面这个地址，这里就不展开说了：
https://github.com/qq449245884/vue-okr-tree/blob/main/src/lib/vue-okr-tree/model/node.js
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa5eface26f2fb5a737b24e182f92515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/135cb31a9d256ddc2b78992487383a09/" rel="bookmark">
			我用英语了结你的一生1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语法概述
10+9+8三个数字囊概住所有语法
简单句
1.陈述句 4个系动词：be动词
动作之前就是主语
动作之后没东西了叫主谓
us 和carrot是动作后的对象是宾语双宾
主语谓语后面如果都是动词的对象就是宾语或双宾
如果是宾语和宾语的补充就是宾补
验证：如果可以改为被动语态就是双宾，改不了被动语态就是宾补
词性 主语：动词之前就是主语
谓语：只有动词或动词短语
宾语：动词之后就是宾
表语：系动词之后就是表语 宾涵括表语都当成宾就可
双宾：一般情况下，双宾就是一个人加一个物
同位语：对名词的解释说明，翻译为是这个字
宾补：对宾语的补充说明，有一个可以改成被动语态
定语：有被修饰的名词
状语：没有被修饰的名词
一个句子的主干 6+3，6个组成最基本的句式
**实意动词后面不能加not **
只能加在情态动词，系动词，助动词后
不能用yes或no回答
祈使句动词开头或者Let’s开头
只要在动作之后就是宾语
只要有一个动词的就叫简单句
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41978770469744d64c6637007d38ef63/" rel="bookmark">
			使用Proteus仿真运行stm32程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Proteus仿真运行stm32程序 一、安装proteus8.9二、创建proteus工程三、绘制仿真图1.stm322.led3.电阻RES4.电路图 四、使用keil5五、仿真1.hex文件2.运行 六、总结 一、安装proteus8.9 proteus8.9版本自带stm库，使用起来比较方便，安装包等文件是由同学提供，在网络上大家也可以很容易找到，很简单哟！注意注意，安装目录一定要全英文哟，不然后面可能会出现麻烦！
二、创建proteus工程 1.点击创建新工程，输入工程名并选择自己想要保存的路径（注意不要带中文名字！）。
2.选择从选中的模板中创建原理图（这一步直接点next即可）。
3.选择不创建PCB布版设计，然后next。
4.选择创建固件项目，并按照要求设置参数，如图所示，然后再点击下一步完成即可。
三、绘制仿真图 1.stm32 按找“二、创建proteus工程”步骤进行设置，创建好的工程，自带stm32芯片。
2.led 根据下图所示，查找并选择led灯，需要8个led灯。
3.电阻RES 根据下图所示，查找并选择电阻，在图中点击电阻，将参数设置为50欧姆，如果太大，led不会亮。
4.电路图 根据下图连接好电路即可。
四、使用keil5 这里是使用大佬的程序代码，直接打开进行设置即可。
五、仿真 1.hex文件 如下图所示，将keil5中程序代码生成的hex文件，添加到芯片中，并设置相关参数。
2.运行 点击左下角绿色三角符号进行运行仿真，可以发现led等从c1到c8一次闪烁，然后全部一起闪烁，之后重复这个过程。
六、总结 本次使用keil5软件，需要支持stm32模块的软件，本次实验是将程序与电路结合起来，对程序的编辑和电路原理都要求，同时也熟悉了proteus和keil软件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77614b23f8b47d1c54674c4b317603da/" rel="bookmark">
			vue3 中使用 element-ui 时出现的 Property ‘$notify‘ does not exist on type ‘App‘.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3 中使用 element-ui 时出现的 Property ‘$notify‘ does not exist on type ‘App‘. 上手研究了下 vue + typescript 开发 发现使用 element-ui之后 element库里的一些对vue的扩展方法无法使用
比如调用 this.$notify 方法显示通知会报以下错误
百度找了半天 找到几种方案
强转 any (&lt;any&gt;this).$notifyas (this as any).$notify在类中增加声明 private $notify: any; 这几种办法异曲同工，但是我用的是typescript,遇到麻烦就转any 还用ts干嘛，仔细想了下这种问题出现的原因是typescript没有找到方法的声明，虽然vscode识别出来了但是ts编译器并不知道方法的存在。
解决办法 找到 tsconfig.json 在 types 节点下 加入 element-ui 来告诉编译器 我们用到了这个库，然后重启编译器 npm run serve
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c27550cf7283310104e3ec8f171e1b/" rel="bookmark">
			【论文速递】PolarNet: An Improved Grid Representation for Online LiDAR Point Clouds Semantic Segmentation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 自动驾驶系统中对细粒度感知的需求导致最近对单扫描LiDAR的在线语义分割的研究增加。尽管出现了新的数据集和技术进步，但由于以下三个原因，它仍然具有挑战性：（1）需要有限硬件的近实时延迟； （2）LiDAR点在整个空间中的分布不均匀甚至长尾； （3）越来越多的极细粒度的语义类。为了共同解决所有上述挑战，提出了一种新的特定于LiDAR的，无近邻的分割算法-PolarNet。我们的极鸟瞰图表示法不是使用通用的球面或鸟瞰图投影，而是在极坐标系中平衡网格单元之间的点，从而使分割网络的注意力与沿点的长尾分布间接对齐径向轴。经试验，其编码方案大大提高了真实城市LiDAR单次扫描的三个不同的分割数据集中的mIoU，同时保持了接近实时的吞吐量。
代码链接：https://github.com/edwardzhou130/PolarSeg
主要贡献： 作者提出极鸟瞰图表示法和环链接卷积，在SemanticKITTI，A2D2 和Paris-Lille-3D 数据集上验证了方法。 结果表明，在仅使用参数和MAC的1/3的平均交叉-联合（mIoU）评估指标上，方法分别比现有方法高出2.1％，4.5％和3.7％。 工作贡献概括如下：
•提出了一种更合适的LiDAR扫描表示形式，它考虑了点的不平衡空间分布。
•展示的PolarNet网络经过极网格数据表示法的端到端训练，以较低的计算成本超越了基于公共基准的先进方法。
•与其他表示法（如笛卡尔BEV）相比，使用极坐标网格对基于不同主干分段网络的语义分割性能进行了全面分析。
算法框架：
极化鸟瞰图 基于LiDAR扫描俯视图出现的环形结构，作者展示了图3所示的Polar分区，取代了图3中的笛卡尔分区。具体地，首先以传感器的位置为原点，计算XY平面上每个点的方位角和半径，而不是对笛卡尔坐标系中的点进行量化。然后将点云分配给根据量化方位角和半径确定的网格单元。
极化BEV有两个好处，首先，它可以更平均地分配点。通过统计SemanticKITTI数据集拆分的验证集，发现每个极点栅格像元靠近传感器时的点数远小于笛卡尔BEV中的点数。 因而，用于密集区域的网格的表示更精细。 在相同数量的网格单元中，传统的BEV网格单元平均为0.7±3.2点，而极性BEV网格单元平均为0.7±1.4点。 标准偏差之间的差异表明，总体而言，这些点在极地BEV网格上分布更均匀。
极化BEV的第二个好处是，更平衡的点分布减轻了预测变量的负担。由于将2D网络输出重塑为体素以进行点预测，因此不可避免地，某些具有不同真实值标签的点将分配给同一体素。而且其中有些无论如何都会被错误分类。使用笛卡尔BEV，每个网格单元中平均98.75％的点共享相同的标签。在极化BEV中，这一数字跃升至99.3％。这表明由于空间表示特性，极化BEV中的点较少遭受错误分类。考虑到小物体更有可能被体素中的多数标签所淹没，这种0.6％的差异可能会对最终的mIoU产生更深远的影响。研究mIoU的上限表明，笛卡尔BEV的mIoU达到97.3％。极化BEV达到98.5％。极化BEV的较高上限可能会提高下游模型的性能。
环形卷积 无需随意为每个网格手工绘制特征，而是使用固定长度的表示形式捕获每个网格中的点分布。 它是由可学习的简化PointNet [22] h和最大池化产生的。 该网络仅包含完全连接的层，批处理规范化和ReLu层。 扫描中第i，第j网格单元中的特征为：
其中w和l是量化大小。 px和py是地图中点p的位置。 注意，位置和量化大小可以是极坐标或笛卡尔坐标。 我们不对沿z轴的输入点云进行量化。 类似于point pillar，学习到的表示表示网格的整个垂直列。
如果表示是在极坐标系中学习的，则特征矩阵的两侧将在物理空间中沿方位轴连接，如图2所示。作者开发了离散卷积，称为环形卷积。假设矩阵在半径轴的两端相连，则环形卷积核将对矩阵进行卷积。同时，位于相反一侧的梯度可以通过该环形卷积核传播回另一侧。通过在2D网络中将常规卷积替换为环形卷积，该网络将能够端到端处理极坐标网格，而不会忽略其连通性。这为模型提供了扩展的应用范围。由于它是一个2D神经网络，因此最终的预测也将是一个极坐标网格，其特征维等于量化的高度通道和类数的乘积。然后，可以将预测重塑为4D矩阵，以得出基于体素的分割损失。将卷积替换为环形卷积，则大多数CNN在技术上都可以处理极坐标网格。作者将具有环形卷积的网络称为经过训练以处理极化网格的环CNN。
实验结果 在实验中使用了SemanticKITTI ，A2D2 和ParisLille-3D 数据集。表1显示了方法与多个基准之间的性能在SemanticKITTI上的比较。
结果表明，即使参数数量较少且延迟较低，基于Unet的极化BEV分割网络仍能胜过最新技术。PointNet和TangentConv等基于点的方法与大型LiDAR点云一起使用时效率低下，并且分割精度较差。对于每类IoU，极化BEV方法在大多数类中均取得了改进，尤其是在那些不规则且空间分布稀疏的类中，这与极性BEV的规模和范围保持特性相匹配。但是，“其他人”和“摩托车手”的表现特别差。调查表明它们在视觉上与其他类别没有区别。根据SemanticKITTI的定义，“其他地面”本质上类似于人行道/地形，但可用于其他目的，例如交通岛。对于“骑摩托的人”来说，即使是人也很难区分“人”或“骑单车的人”，这是因为这个类别本身通常在很大程度上被遮挡。 此外，摩托车手是数据集中最稀有的一类-构成训练点的0.004％，并且在官方验证序列中仅出现一个实例。
Abstract The need for fine-grained perception in autonomous driving systems has resulted in recently increased research on online semantic segmentation of single-scan LiDAR. Despite the emerging datasets and technological advancements, it remains challenging due to three reasons: (1) the need for near-real-time latency with limited hardware; (2) uneven or even long-tailed distribution of LiDAR points across space; and (3) an increasing number of extremely fine-grained semantic classes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05c27550cf7283310104e3ec8f171e1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b35d852c84a821166817e3bc2a6445e/" rel="bookmark">
			python socket接收c传输的字节流数据时遇到的“字节对齐”问题struct.error: unpack requires a buffer of 35 bytes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python和c通过socket进行数据传输时，会用到pack和unpack包来进行数据的打包和解包，对于不同类型的数据往往会存在一个“字节对齐”问题：
struct.error: unpack requires a buffer of 35 bytes 比如在一字节Byte型变量和八字节double型变量的中间可能会插入四个字节的0x00来自动对齐字节长度。
可以看到接收程序源代码如下：
dataFromCar_jingwei_from_car =client.recv(36) y11, y12, y13, y14, y15, y16, y17, y18, y19, y20, y21, y22, y23, y24, y25, y26, y27, y28, y29, y30, y31, y32= struct.unpack( '!4i2d16B',dataFromCar_jingwei_from_car) dataFromCar_jingwei_from_car =client.recv(4) 问题就出在“!4B2d”这里，在Byte型变量后接double型变量时，程序默认给你加上了四个字节的0x000x000x000x00来对齐字节。
解决办法之一是分段接收数据，先接收前四个字节的数据，再接收后面的double型数据。
dataFromCar_jingwei_from_car =client.recv(4) # 接收GPS等 y11 , y12, y13,y14 =struct.unpack('!4B',dataFromCar_jingwei_from_car) GPS = y11 # GPS协议类型 Star = y12 # 卫星个数 dataFromCar_jingwei_from_car = client.recv(32) y15, y16, y17, y18, y19, y20, y21, y22, y23, y24, y25, y26, y27, y28, y29, y30, y31, y32= struct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b35d852c84a821166817e3bc2a6445e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a8d773503743fda6663b673e5e790b/" rel="bookmark">
			Java学习笔记 面向对象（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四章 面向对象（上） 1. 类2. 对象3. 构造方法与finalize4. 非访问修饰符 1. 类 关系：
对象是类的实例，类是对象的模板方法的定义
格式：
[修饰符] 返回值类型 方法名（参数类型，参数1，…）{
方法体
}
Tips：类中方法可以进行递归调用public class Fibonacci{ public static int fseq(int n){ if(n&lt;1) return -1; if(n==1||n==2) return 1; else return fseq(n-1)+fsqe(n-2); } public static void main(String args[]){ System.out.prinln(fseq(10)); } 2. 对象 创建
FighterPlane（类） fp（对象）； //对象声明 fp = new FighterPlane（）； //产生对象 或：FighterPlane（类） fp（对象）= new FighterPlane（）； //先产生对象再赋予声明，声明被赋予对象之后（即二者合在一起），叫引用 对象作为参数的特点
方法中的参数可以作为基本数据类，也可以为对象，基本数据类型是值传递，对象是引用传递（传地址）
public class PassPara { private static int a; public static void main(String []args){ modify(a); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18a8d773503743fda6663b673e5e790b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85bd467a163d0b3c206f7972f7e54a3d/" rel="bookmark">
			C&#43;&#43;知识点43——解引用运算符和箭头运算符的重载及智能指针类的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念、
在自定义行为类似指针的类时，需要重载*和-&gt;。C++中的智能指针就重载了这两个运算符。-&gt;必须是成员函数，*也应该是成员函数。与内置类型保持一致，这两个函数通常都是const的。以为*和-&gt;通常不会也不应该改变对象的状态
*运算符的返回值通常都是一个类型的引用（因为类内部的数据不一定非得指向T的对象，也可能指向一个T的派生类对象。如果是这样并且operator*返回的是个T对象，而非一个引用（代表真正的派生类对象），那么，operator*函数便是返回一个错误类型的对象！，也就是导致子类对象转基类对象的切割问题）
-&gt;运算符的返回值必须是一个类的指针。因为当自定义类型的operator-&gt;被调用时，编译器会将operator-&gt;转化为
(obejct.operator-&gt;())-&gt;member 所以，operator-&gt;的返回值必须是一个指针
二、示例
通过实现一个智能指针来熟悉这两个运算符的重载，类的整体实现如下
#include &lt;iostream&gt; #include &lt;memory&gt; using namespace std; template &lt;typename T&gt; class mysmartpointer { public: mysmartpointer(T *ptr=nullptr): ptr_(ptr), pcount_(new size_t(0)) { cout&lt;&lt;__func__&lt;&lt;endl; if (ptr_==nullptr) {//空指针不增加引用计数 *(this-&gt;pcount_)=0; } else { *(this-&gt;pcount_)=1; } } mysmartpointer(const mysmartpointer &amp;rval): ptr_(rval.ptr_), pcount_(rval.pcount_) { if (ptr_) {//拷贝初始化，如果指针不为空，增加引用计数 ++*pcount_; } cout&lt;&lt;"mysmartpointer(const mysmartpointer &amp;rval)"&lt;&lt;endl; } mysmartpointer &amp;operator=(const mysmartpointer &amp;rval) { cout&lt;&lt;__func__&lt;&lt;endl; mysmartpointer t(rval); this-&gt;swap(t); --*pcount_;//减少左值的引用计数 if (*pcount_==0) {//此时如果引用计数为0，那么释放指向的对象和引用计数 cout&lt;&lt;"delete object when operator="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85bd467a163d0b3c206f7972f7e54a3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d60d8b7ad2217a911d933aa73150a2/" rel="bookmark">
			【ros学习】13.URDF机器人建模详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、URDF简介 URDF（Unified Robot Description Format）统一机器人描述格式，URDF使用XML格式描述机器人文件。URDF语法规范，参考链接：http://wiki.ros.org/urdf/XML，URDF组件，是由不同的功能包和组件组成：
本文不作具体的构建步骤解析与各部分的教学，仅解释urdf文件。如需教学资料，请参考以下链接：
1.统一机器人描述格式-中国大学慕课教程
2.深蓝学院-ROS理论与实践
3.【古月居】古月 · ROS入门21讲
4.找我
二、mbot机器人解析 话不多说，先上代码
&lt;?xml version="1.0" ?&gt; &lt;robot name="mbot"&gt; &lt;link name="base_link"&gt; &lt;visual&gt; &lt;origin xyz="0 0 0" rpy="0 0 0"/&gt; &lt;geometry&gt; &lt;cylinder length="0.16" radius="0.20"/&gt; &lt;/geometry&gt; &lt;material name="yellow"&gt; &lt;color rgba="1 0.4 0 1"/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;joint name="left_wheel_joint" type="continuous"&gt; &lt;origin xyz="0 0.19 -0.05" rpy="0 0 0"/&gt; &lt;parent link="base_link"/&gt; &lt;child link="left_wheel_link"/&gt; &lt;axis xyz="0 1 0"/&gt; &lt;/joint&gt; &lt;link name="left_wheel_link"&gt; &lt;visual&gt; &lt;origin xyz="0 0 0"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7d60d8b7ad2217a911d933aa73150a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a397d4f00f3f7c89691e554a29a0fd58/" rel="bookmark">
			C语言实现哥德巴赫猜想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言实现哥德巴赫猜想 大家好，今天我们来用c语言实现哥德巴赫猜想。由于本人c语言刚学了2个月，写的代码如果有疏漏之处，还望大家海涵！
不含注释的代码
#include&lt;stdio.h&gt; int main(void) { int n; int a=0,x,fw1,zs1=0; int b=0,y,fw2,zs2=0; printf("请输入请输入哥德巴赫猜想中的偶数:"); scanf("%d",&amp;n); for(fw1=3;fw1&lt;n/2;fw1++) { a=0; for(x=2;x&lt;fw1;x++) { if(fw1%x==0) { a=1; } if(1!=a&amp;&amp;x==fw1-1) { zs1=fw1; for(fw2=3;fw2&lt;n;fw2++) { b=0; for(y=2;y&lt;fw2;y++) { if(fw2%y==0) { b=1; } if(1!=b&amp;&amp;y==fw2-1) { zs2=fw2; if(zs1+zs2==n) { printf("%d=%d+%d\n",n,zs1,zs2); } } } } } } } return 0; } 含有注释的代码
#include&lt;stdio.h&gt; int main(void) { int n; //n为哥德巴赫猜想中的偶数 int a=0,x,fw1,zs1=0; //a,x,fw1为外层循环寻找[3,n/2)内的质素用到的变量,zs1是第一组中寻找到的质素 int b=0,y,fw2,zs2=0; //b,y,fw2为内层循环寻找[3,n)内的质素用到的变量,zs2是第二组中寻找到的质素 printf("请输入请输入哥德巴赫猜想中的偶数:"); scanf("%d",&amp;n); for(fw1=3;fw1&lt;n/2;fw1++) //外层循环，寻找【3，n/2)之内的质素 { a=0; for(x=2;x&lt;fw1;x++) //x的范围是（2，fw1），目的是下面让fw1%x,如果结果均不为0，说明fw1是质素 { if(fw1%x==0) { a=1; } if(1!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a397d4f00f3f7c89691e554a29a0fd58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ffc08c26cfe1632904710dde841ff10/" rel="bookmark">
			C语言：一元二次方程(输入系数a,b,c输出一元二次方程解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言：一元二次方程
考虑了a与0的关系和△与0的关系。
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { double a, b, c, x1, x2, d,x3 ,x0; printf("输入方程的三个系数:"); scanf_s("%lf %lf %lf", &amp;a, &amp;b, &amp;c); if (a != 0) { d = sqrt(b * b - 4 * a * c); if (d == 0) { x0 = (-b) / (2 * a); printf("%.2lf\n", x0); } else if(d&gt;0) { x1 = (-b + d) / (2 * a); x2 = (-b - d) / (2 * a); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ffc08c26cfe1632904710dde841ff10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9700bf70ff59ecfdc6d36fc330548cd7/" rel="bookmark">
			JUC进阶3---Volatile和原子引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JMM JMM ： Java内存模型，不存在的东西，概念！约定！
关于JMM的一些同步的约定：
1、线程解锁前，必须把共享变量立刻刷回主存。
2、线程加锁前，必须读取主存中的最新值到工作内存中！
3、加锁和解锁是同一把锁
内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）
lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态
unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中
JMM对这八种指令的使用，制定了如下规则：
不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
不允许一个线程将没有assign的数据从工作内存同步回主内存
一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作
一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
对一个变量进行unlock操作之前，必须把此变量同步回主内存
public class JMMDemo { private static int num = 0; public static void main(String[] args) { new Thread(() -&gt; { while (num == 0) { //线程的工作空间不知道主内存的值发生的变化，所以不会停 } }).start(); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9700bf70ff59ecfdc6d36fc330548cd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781eef91e715b0540076b054474ff608/" rel="bookmark">
			我是如何把自己的电脑搭建成简易数据服务器的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：服务器无人更新维护，不得不从PHP转型为Java Web，而且是要在刚刚接触C不久的新成员学习Java基础后才能开始搭建新的服务器。唉，这个过程实在是有些漫长，必须的服务器端测试没法进行，无奈只能想办法自己搭建一个测试用的简易服务器了。。。
因此，作为一天半前才刚刚接触服务器概念的萌新，很多代码只是照葫芦画瓢，并不知其意，服务器也只求能用。博客仅描述搭建过程与解决所遇到的问题，不喜勿喷，大佬勿喷。
搭建工具：IDEA 2020.2.3、Tomcat 9.0.39、ngrok
数据库：MySQL 8.0
构建项目
首先使用IDEA创建一个SpringBoot框架的项目（选择Spring Initializr，在Dependencies页勾选Web --&gt; Spring Web），在项目自动补充pom.xml配置并一番下载后，你就可能遇到第一个错误：
spring-boot-maven-plugin报红
一番搜索后大致找出原因在于maven远程库并不包含该jar文件，为避免下载时自动到maven远程库，需指定版本，具体添加版本可根据pom配置中以下代码确定（选择其它的版本可能不会解决问题）
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 于是如此添加
&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;/plugin&gt; 重新下载一下即可
项目代码
首先是代码结构，以最常见的User下手：
项目包名下： 包名controller（个人认为应该是做业务处理的） 类UserController（在此类中部分方法前有注解映射） 包名entity（其下为实体类） 类User 包名repository 包名impl 类UserRepository（类前要加@Repository注解） 接口UserRepository 具体的代码可由此参阅（其中也有项目的构建过程），个人只做了部分名字的更改以及不同电脑不同版本下错误的修正。
数据库环境
这里使用MySQL 8.0作为数据库服务，在IDEA的项目结构中，选中Modules，右侧 “+” 添加JAR文件，可在MySQL安装目录的 Connector J 8.0 文件夹下找到 mysql-connector-java-8.0.21.jar 文件，配置好后确定即可在项目中与MySQL做交互。
与数据库交互
可额外增建一个用于与数据库交互的工具类，如下：
public class SQLTools { private static final String URL = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/781eef91e715b0540076b054474ff608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8876bdc731df8b4a58eac5b9a79c8d23/" rel="bookmark">
			python求解线性规划问题———单纯形法（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单纯形法（一） ——————————————————————————
——————————————————————————
！！2021-10-18更新
这篇文写了挺久了，也有蛮多人在看，也有不少错误被提出来。
看着自己以前写的代码也很烂（也很累），所以稍作修改。
——————————————————————————
——————————————————————————
1、为什么叫单纯形法 单纯形是N 维空间中的N+1 个顶点的凸包，是一个多胞体：直线上的一个线段，平面上的一个三角形，三维空间中的一个四面体等等，都是单纯形。可以证明线性规划问题如果存在可行域，那么可行域必然是个凸集，其最优解必然在顶点取到——单纯形。单纯形法的基本原理就是从可行域的一个顶点出发，不断转轴到下一个顶点从而最终找到最优解。 2、单纯形法怎么用 单纯形法的一般解题步骤可归纳如下：
1、把线性规划问题的约束方程组表达成典范型（标准型）方程组，找出基本可行解作为初始基本可行解。2、若基本可行解不存在，即约束条件有矛盾，则问题无解。3、若基本可行解存在，从初始基可行解作为起点，根据最优性条件和可行性条件，引入非基变量取代某一基变量，找出目标函数值更优的另一基本可行解。4、按步骤3进行迭代,直到对应检验数满足最优性条件（这时目标函数值不能再改善），即得到问题的最优解。5、若迭代过程中发现问题的目标函数值无界，则终止迭代。 3、我们先讨论最简单的情况：初始基本可行解已知 e.g.
m a x z = − 2 x 1 + x 2 s . t . { 3 x 1 + 2 x 2 + x 3 = 18 − x 1 + 4 x 2 + x 4 = 8 x i ≥ 0 , i = 1 , 2 , 3 , 4 max \ \ z=-2x_1+x_2 \\ s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8876bdc731df8b4a58eac5b9a79c8d23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/094cca426ab01dfda06b0dfe95de9316/" rel="bookmark">
			SSM使用UEditor富文本编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 富文本编辑器（UEditor）1. 下载UEditor富文本编辑器下载解压完成后打开 `index.html` 可查看 `ueditor` 庐山真面目 2. 创建测试项目注意：在以下步骤之前，你得有一个搭建完成的SSM框架的项目2.1 在 `SSM` 项目的 `web` 目录下创建 `ueditor` 目录 ，将下载好的目录解压并导入2.2 在 `jsp` 文件加下的 `lib` 目录下包含ueditor开发所需jar包，将jar包导入SSM项目中 3. 创建测试项目3.1 在web目录下创建一个 `ueditor.jsp`3.2 配置 `springmvc.xml`启动Web项目，你会看到如下3.3 创建 `UeditorController.java`3.4 编写 `ueditorList.jsp ` 页面3.5 测试注意：如果使用IDEA，并且打包的方式是 `war` ， 则需要到项目下的 `class` 路径去寻找上传的文件 4. UEditor配置属性（需要注意）1.config.json1.1 在 `config.json` 中可以配置 `ueditor` 的其他属性，可以根据自己需求进行更改1.2 从这可以看出我的 `Web` 项目没有项目名 富文本编辑器（UEditor） 1. 下载UEditor富文本编辑器 建议下载 utf8-jsp 版本的，结构目录如下：
下载地址：链接：百度网盘 提取码：sjxy 下载解压完成后打开 index.html 可查看 ueditor 庐山真面目 2. 创建测试项目 注意：在以下步骤之前，你得有一个搭建完成的SSM框架的项目 2.1 在 SSM 项目的 web 目录下创建 ueditor 目录 ，将下载好的目录解压并导入 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/094cca426ab01dfda06b0dfe95de9316/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51963d7065b83826b54b2a77d1481ac7/" rel="bookmark">
			maya mel语言打开文件及访问网站链接方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般在编写mel程序插件时，如果需要链接到自己的主页或帮助网页时，可以使用showHelp和launch命令。
1、打开web网页方法。
showHelp -absolute "http://blog.sina.com.cn/tiancgweb" ； launch -web "http://www.autodesk.com"; 的方式。
2、打开本地文件。比如要直接打开pdf 文档、目录、影片。(推荐使用此方法！效率较高！)
可以使用launch [-directory string] [-movie string] [-pdfFile string] [-webPage string]
launch -pdf "D:/nokelu/AFMUG-02.10.15_Common-Workflows.pdf"； 3、 使用system 调用系统命令打开指定文件。
例如如下方式使用editplus脚本编辑工具打开maya mel脚本。
system("start E:/TJH_maya_mel_scripts/EditPlus3/editplus.exe " + "E:/tjh_tools1.0/scripts/effect/tjh_flower_fall.mel"); 4、打开本地文件夹的方法。
注意：maya默认路径为反斜杠/,此法调用window系统命令explorer, 所以路径必须使用win 风格正斜杠\ ,转义后为\。maya 提供了 encodeString( toNativePath( ) ) 方法转换maya与系统路径方式。
string $path = "C:/Program Files/Autodesk"; $path = encodeString(toNativePath($path)); system ("explorer "+$path); // 等价于 system ("explorer C:\\Program Files\\Autodesk"); //南无阿弥陀佛，哈哈哈。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e03be6e4f0ea94e2a125552a85f86c/" rel="bookmark">
			Gitee导入Github仓库并同步更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 仓库导入2. 同步更新Github 和 Gitee仓库2.1 将仓库clone到本地2.2 将本地仓库与 Gitee 和 GitHub 两个远程库关联2.3 同步更新2.4 强制同步 1. 仓库导入 如果要导入的github的仓库是私有的，还需要提供github的账号和密码
点击导入
2. 同步更新Github 和 Gitee仓库 2.1 将仓库clone到本地 git clone xxx.git
2.2 将本地仓库与 Gitee 和 GitHub 两个远程库关联 git remote -v 查看本地仓库的远程库列表
如果在列表中没有 Gitee 的远程库地址，则需要新增一个地址
git remote add 远程库名 远程库地址
eg：eg: git remote add gitee git@gitee.com:xxx/xxx.git
如果在 add 的时候出现 error: Could not remove config section ‘remote.xxx’.一类的错误，通过把仓库下.git/config 文件里的 [remote “xxx”]删除或者是用其他远程库名即可。
如果原本只有 GitHub 一个远程库，则要注意，git 给远程库起的默认名称是 origin，需要用不同的名称来标识不同的远程库（GitHub &amp; Gitee），则先删除已关联的名为 origin 的远程库：git remote rm origin
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10e03be6e4f0ea94e2a125552a85f86c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05205b69e440275512fe6208ccf67060/" rel="bookmark">
			xpath获取同级、父级、子级元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xpath获取同级元素
XPath轴(XPath Axes)可定义某个相对于当前节点的节点集：
1、child 选取当前节点的所有子元素
2、parent 选取当前节点的父节点
3、descendant 选取当前节点的所有后代元素（子、孙等）
4、ancestor 选取当前节点的所有先辈（父、祖父等）
5、descendant-or-self 选取当前节点的所有后代元素（子、孙等）以及当前节点本身
6、ancestor-or-self 选取当前节点的所有先辈（父、祖父等）以及当前节点本身
7、preceding-sibling 选取当前节点之前的所有同级节点
8、following-sibling 选取当前节点之后的所有同级节点
9、preceding 选取文档中当前节点的开始标签之前的所有节点
10、following 选取文档中当前节点的结束标签之后的所有节点
11、self 选取当前节点
12、attribute 选取当前节点的所有属性
13、namespace 选取当前节点的所有命名空间节点
如：要定位当前td同级后的一个td
//td[.=‘text’]/following-sibling::td
following-sibling 选取当前节点之后的所有同级节点,跟preceding-sibling一样都是选取同级同父的节点，只不过following是取对应节点之后的节点，preceding-sibling取的是该节点之前的节点。 /AAA/BBB/following-sibling::* 取/AAA/BBB节点的之后的所有同级节点 //CCC/following-sibling::* 选取所有CCC元素的之后所有同级节点 今天跟大家分享下selenium中根据父子、兄弟、相邻节点定位的方法，很多人在实际应用中会遇到想定位的节点无法直接定位，需要通过附近节点来相对定位的问题，但从父节点定位子节点容易，从子节点定位父节点、定位一个节点的哥哥节点就一筹莫展了，别急，且看博主一步步讲解。
由父节点定位子节点
最简单的肯定就是由父节点定位子节点了，我们有很多方法可以定位，下面上个例子： 对以下代码：
parent to child 1 2 3 4 5 6 7 8 9 10 想要根据 B节点 定位无id的子节点，代码示例如下： -- coding: utf-8 -- from selenium import webdriver
driver = webdriver.Firefox()
driver.get(‘D:\py\AutoTestFramework\src\others\test.html’)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05205b69e440275512fe6208ccf67060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f48e4bea0edf3f326ddcf00e64ed73c/" rel="bookmark">
			采购流程控制的六个重点环节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，“管理下的支出（SUM）”是指企业积极管理的支出所占的百分比，管理依据是类别管理原则，或者明智的决策——企业通过最高价值的解决方案购买相同种类的商品和服务。SUM百分比是支出控制方式的主要决定因素。
“请购-采购-收货”流程要确保：
▪ 所有采购申请都有记录，并且审批通过。
▪ 根据采购类型、费用和组织架构定制审批路线工作流。
▪ 从首选供应商中选择物品。
▪ 采购申请单在预算范围内。
▪ 采购代理审查采购申请单，利用现有库存（如果有的话）获取需要采购的物品，推荐替代产品，并从供应商处获得关于新产品的竞争性报价。
通常，企业采购显著的成本节省来自：
▪ 避免的不必要采购，采购的物品或许能从其他地方获得。
▪ 超出预算的采购，这些采购可能会被推迟或不是必需的。
▪ 以较低的价格识别来自不同供应商的产品。
▪ 解决短货或账单差异问题的纠正措施。
非采购订单发票（支票申请）流程
尽管在提高SUM百分比方面付出了很多努力，但现实情况是，许多公司的应付账款（AP）部门收到相当多的非采购订单发票。这些发票涉及紧急支出、法律服务、咨询、设施服务和维修、公用事业设备等。
如果没有发票申请（非采购订单）流程，这些发票就会流向AP部门，并且可能得到支付，整个过程常常缺少必要的供应商选择、价格审查、审批和预算控制流程。
当供应商或内部员工通过电子邮件、传真或物理文档扫描将非采购订单发票提交到文件夹或门户时，非采购订单发票就具有可控性。工作流发票自动化解决方案创建了附有相关供应商和日期的支票申请解决方案，还采用了适当的路径和审批规则。
因此，发票自动化解决方案采用了特定交易相同的准则，这些交易源于采购申请单和采购订单。针对非采购订单采用可控流程，由工作订单和口头承诺的差异或顾问时间超额计费所产生的欠款单据，就能转换为显著的成本节省。
如何控制好采购流程？
8MSaaS SRM电子采购等现代电子采购软件拥有内置的流程控制机制，能够帮助你提升合规性，加强对采购流程的控制。
1、采购需求的确定和采购计划的制定
8MSaaS SRM可以从客户需求的源头控制企业的采购需求与计划，每一个采购需求量都有据可依，减少不合规的多采购或少采购的情况，从根本上减少人为干预而导致的不必要的损失。
企业可通过系统的BOM（物料清单）功能进一步分析具体的物料需求并生成详细的采购计划。
2、供应商的寻找和确定
根据采购计划，企业在市场上寻找合适的供应商，8MSaaS SRM供应商管理能更容易地邀请更多潜在供应商。
系统支持从供应商注册信息到审核供应商资格及结果通知的全过程管理，可对供应商进行资格审核和等级评定，只有通过了资格审核才能成为合格的供应商。
3、成本分析
8MSaaS SRM可自动计算基于 BOM（物料清单）的采购成本，自动校验采购预算，并且可根据不同的成本及预算总额设置不同的审批流程。
系统还能自动获取生效的报价信息统计预测的采购成本，所有账目实时汇总，清楚明了。
4、定价和合同管理
采购价格的监控是整个采购过程的关键。8MSaaS SRM通过多种定价方式，帮助企业在线询比价定价，以最高效的方式获取最优的采购价格。
另外，系统可实现采购合同的电子化管理，实时追踪和记录此电子采购合同的生成、接收、审批和执行过程与结果。
5、验货和收货
合同签订后，需要继续跟踪供应商催货，以保证生产进度，并且和需求部门、质保部门等组织预验收和终验收。
8MSaaS SRM提供严密的流程与监控机制管理整个交付的过程，记录与跟踪交付的具体进度与状态，及时解决交付过程中的各种问题以确保交付的顺利完成。
6、开票和付款
采购订单/合同完整交付完成后，供应商可把自动生成的电子发票通过系统自动发送给企业采购负责人，企业可根据此电子发票生成付款申请，付款申请审批通过后即可进行付款安排。
系统支持不同的付款方式，并且多维度跟踪付款进度和状态（如按照采购订单的时间，负责部门，供应商等）。
在完成以上所有采购环节的控制管理后，我们可以认为一个采购任务完满结束。只有将采购环节控制的设计与执行有效落实，合理运用8MSaaS SRM等电子采购新技术，才能够降低企业的采购成本及后续成本，是资源达到最优配置，更有利于企业经营活动畅通有序进行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/848b21943d79b5a9daeb8e23d59e734e/" rel="bookmark">
			SSM框架整合 完整版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
SSM框架整合 项目结构 一、搭建数据库环境二、基本环境搭建1. 创建maven项目2、导入依赖3、建立项目基本结构 三、MyBatis层编写1、编写数据库配置文件2、IDEA关联数据库3、编写MyBatis核心配置文件4、编写pojo实体类5、编写dao(mapper)层1. 编写Mapper接口2. 编写Mapper接口对应的Mapper.xml 6、编写service层编写service层接口实现类 四、Spring层编写1、Spring整合dao层2、Spring整合service层 五、SpringMVC层编写1、编写spring-mvc.xml2、Spring配置文件整合3、配置web.xml4、编写Controller5、编写视图层1. 编写index.jsp2. 编写展示所有书籍页面allBooks.jsp 6、运行测试 项目结构 项目结构
数据库表格
一、搭建数据库环境 创建数据库表
CREATE DATABASE `ssmbuild`; USE `ssmbuild`; DROP TABLE IF EXISTS `books`; CREATE TABLE `books` ( `bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id', `bookName` VARCHAR(100) NOT NULL COMMENT '书名', `bookCounts` INT(11) NOT NULL COMMENT '数量', `detail` VARCHAR(200) NOT NULL COMMENT '描述', KEY `bookID` (`bookID`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES (1,'Java',1,'从入门到放弃'), (2,'MySQL',10,'从删库到跑路'), (3,'Linux',5,'从进门到进牢'); 二、基本环境搭建 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/848b21943d79b5a9daeb8e23d59e734e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f4fd4219c9f8733b5a2162c3313135/" rel="bookmark">
			brew 镜像_黑苹果APFS纯净恢复版镜像 macOS Catalina 10.15.7(19H2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Mac 上你喜爱的一切，都因 macOS Catalina 而变得更精彩。你可以享用两款全新媒体 app；用新的查找 app 定位遗失的 Mac；而你常用的 iPad app 现在也有了 Mac 版。你甚至可以将 iPad 当作第二个显示屏，扩展桌面空间。现在，无论做什么，你将拥有远超以往的体验。
安装前必读：
macOS版本：macOS Catalina (19H2)此为恢复版镜像，90%的流程都可在 Windows 环境下完成。需要注意的是，目前所有黑苹果网站及论坛都不推荐使用这种方式安装黑苹果(其原理是把全新安装的macOS做了一个系统备份，然后恢复这个备份到其它电脑上，所以在某些机型上也有可能完全无法使用)。但是总体来讲，恢复版镜像确实能大大降低安装门槛。「注意」需要自行准备 EFI 文件，远景论坛、GitHub、黑果小兵、码云等网站均有网友分享，去找尽量接近你的实际情况的配置，越接近需要解决的问题越少。最后，恢复版镜像目前处于测试状态，不保证一定能安装，欢迎反馈使用问题，查看恢复版镜像安装教程。 其它信息：
macOS 新内容 macOS Catalina 解决了 macOS 无法自动连接至 WiFi 的问题；修复了一个可能阻止文件通过 iCloud Drive 同步的错误；修复了 Radeon Pro 5700 XT 版新 iMac 用户遇到的屏幕白线问题。
解决了 macOS 无法自动连接到 Wi-Fi 网络的问题；解决了可能阻止文件通过‌iCloud Drive 同步的问题；解决了 Radeon Pro 5700 XT 版 iMac‌(Retina 5K，27 英寸，2020)可能出现的图形问题； 镜像特点 不少于 50GB 硬盘可用空间；macOS 版本 (19H2)，系统无任何修改；必须使用 Paragon Hard Disk Manager 17 及以上版本；在应用程序中集成部分黑苹果基本工具： HackintoolClover.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8f4fd4219c9f8733b5a2162c3313135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7375c374ef1ee6f3a7eec3a55f4f2e99/" rel="bookmark">
			《计算机程序设计（C&#43;&#43;）》第9周编程作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《计算机程序设计（C++）》第9周编程作业 1 设计Person类（20分）
题目内容：
设计一个Person类，包含name、age、sex属性以及对这些属性操作的方法。实现并测试这个类。
根据类的封装性要求，把name、age、sex声明为私有的数据成员，声明公有的成员函数Register()、ShowMe()来访问这些属性，在Register()函数中对数据成员进行初始化。person1通过cin来得到信息，person2通过Register(“Zhang3”,19, ‘m’) 来得到信息。
输入格式:
person1的信息
输出格式：
person1和person2的信息
输入样例：
Li4 18 f
输出样例：
Li4 18 f
Zhang3 19 m
时间限制：500ms内存限制：32000kb
#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; class Person { private: char name[20]; int age; char sex[2]; public: void Register(char* n, int a, char* s); void ShowMe() { cout &lt;&lt; name &lt;&lt; ' ' &lt;&lt; age &lt;&lt; ' ' &lt;&lt; sex &lt;&lt; endl; } }; void Person::Register(char* n, int a, char* s) { strcpy(name, n); age = a; strcpy(sex, s); } int main() { Person person[2]; char n[20], s[2]; int a; cin &gt;&gt; n &gt;&gt; a &gt;&gt; s; person[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7375c374ef1ee6f3a7eec3a55f4f2e99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7bd319f52f0b772db8b2f70cfe33871/" rel="bookmark">
			怎么查找电脑中的流氓软件_电脑流氓软件多？只需1个神器，彻底清除，运行如飞！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近韩博士很久没有好好地休息了，想看看电影来放松放松心情，于是乎就下载了个视频播放器。好不容易下载完成，结果发现桌面多出来几个其他软件，原来是播放器的“亲戚”啊。其实这种事情大家可能已经是司空见惯了，有时不小心点到一个弹窗都有一堆流氓软件，直接在下载的时候取消勾选流氓软件即可。
终归是道高一尺魔高一丈，毕竟有时候没有让你选择的地步，直接强行下载，找个取消安装按键比找对象还难！而且不管你乐不乐意，反正我就是不看你脸色，管你三七二十一。甚至在安装软件时有的流氓软件隐藏特别深，不仔细看还发现不了。结果电脑就出现一堆“全家桶”，内存都快撑爆了。官方发“福利”，最为致命！
其实平常这些流氓软件不鸣则已，不好好地做一个“废柴”，偏偏在我们使用电脑的时候就来拖后腿，严重拖慢电脑的运行速度；而且还会出现各种弹窗广告，就算是电脑卡死还是“照弹不误”！严重影响了日常使用。
所以一般出现这些软件时都是直接将其“卸载”。卸载的方式也有讲究，如果你只是用“常规操作”，可能流氓软件依旧会卷土重来。这时候才会发现系统上竟然还有遗留文件和注册表等残留信息，这下子又占用空间了。
所以平常我们在安装的时候就要注意，如果真的不小心中招了，如何干净有效地去除也是有方法的。
步骤一：结束流氓软件进程 打开任务管理器，选中所有正在运行的流氓软件将其结束进程！防止后续无法完成删除源文件等操作。
步骤二：删除残留文件 1.右键选中流氓软件“打开文件所在位置”，用Uninstall Tool进行卸载。
2.虽然此时已经是显示卸载完成，但大家不要忘记它的残留气息。直接返回上级目录并找到流氓软件的目录名开始进行删除。
如果此过程删除不掉，电脑提示你正在使用该文件夹。别慌，在任务管理器中结束该项进程；如果文件夹拒绝访问，那说明你没有权限啦。我们只需要获取管理员权限即可。
如何获得管理员权限 右键选中该文件夹的“属性”，将鼠标切换至“安全”，点击“高级”进入。
开始“更改”所有者，输入“everyone”后并“确定”。
最后直接勾选“使用可从此对象继承的权限项目替换所有子对象的权限项目”复选框，最后“确定”保存设置。
这个时候就可以有权限进行删除了。删除残留文件后大家可以开启杀毒软件进行扫描，如果发现注册表中有残留信息，同样也需要进行删除。
步骤三：删除残留注册表信息 按下win+R调出运行窗口，输入“regedit”命令打开注册表。
在注册表界面中点击“编辑”中的“查找”搜索程序名称。
找到程序名之后，右键选中它并开始“删除”即可。
通过以上的小步骤我们就可以成功删除这些流氓软件，整个世界瞬间就干净了很多。当然，大家也可以使用其他的小工具进行删除，如果你还有什么其他方法的话，现在就可以告诉韩博士哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7fadb48df260666550c1fce5d90af7/" rel="bookmark">
			jQuery获取选中的checkbox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先搞一堆复选框
&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;全选&lt;input type="checkbox" name="selectAll" id="selectAll" class="selectAll"&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="contentCheckbox"&gt;内容1&lt;/td&gt; &lt;td&gt;内容1&lt;/td&gt; &lt;td&gt;内容1&lt;/td&gt; &lt;td&gt;内容1&lt;/td&gt; &lt;td&gt;内容1&lt;/td&gt; &lt;td&gt;&lt;input type="checkbox" name="" id="" class="content"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="contentCheckbox"&gt;内容222&lt;/td&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;td&gt;&lt;input type="checkbox" name="" id="" class="content"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="contentCheckbox"&gt;内容3&lt;/td&gt; &lt;td&gt;内容333&lt;/td&gt; &lt;td&gt;内容3&lt;/td&gt; &lt;td&gt;内容3&lt;/td&gt; &lt;td&gt;内容3&lt;/td&gt; &lt;td&gt;&lt;input type="checkbox" name="" id="" class="content"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="contentCheckbox"&gt;内容4&lt;/td&gt; &lt;td&gt;内容444&lt;/td&gt; &lt;td&gt;内容4&lt;/td&gt; &lt;td&gt;内容4&lt;/td&gt; &lt;td&gt;内容4&lt;/td&gt; &lt;td&gt;&lt;input type="checkbox" name="" id="" class="content"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e7fadb48df260666550c1fce5d90af7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a04c55aa1f247cd197e6dbbcb6d746cb/" rel="bookmark">
			小项目分享：51单片机音乐喷泉制作全过程资料（附送给初学者的忠告）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为最近忙着考试，所以都没时间更新博客了，在后台有个小姐姐给我留言说自己对单片机很感兴趣，但是又不知道从哪里开始学起，是先学硬件好还是先学软件好，其实在我们复杂的电子学里，硬件和软件是分不开的，硬件就像是我们的心脏和四肢，软件就像我们的大脑，如果只有软件没有硬件，纳我们的系统就是一个没用的程序，不能执行任何操作，而如果只有硬件没有软件那么整个系统就是一个行尸走肉，是一个没有“大脑”的躯壳，我说到现在大家也应该明白了，硬不离软，软不离硬，只有软硬兼修，方能大成！好了，回到刚才的问题，我建议先从硬件开始学起，先理解了硬件的架构和各部分的工作原理，然后再去看软件，这样能更好的理解原理，就像我推荐大家先用汇编后用C一样 ，好了，写了这么多，如果你有不同意见或者想法欢迎留言和私信。
今天送给大家一个比较简单的小项目吧，如果你有兴趣的话可以试着做一下呦！
好了老规矩先上实物图
正面图：
反面图：
电气原理图
PCB LAYOUT 图
音乐喷泉的元器件清单列表
音乐喷泉单片机C语言参考源代码如下：
#include&lt;reg51.h&gt;
#define uchar unsigned char
#define uint unsigned int
sbit out=P3^7;
sbit led1=P0^7;
sbit led2=P0^6;
sbit led3=P0^5;
sbit led4=P0^4;
sbit led5=P0^3;
sbit led6=P0^2;
sbit led7=P0^1;
sbit led8=P0^0;
sbit SCL=P1^2; //SCL定义为P1口的第3位脚，连接ADC0832SCL脚
sbit DO=P1^3; //DO定义为P1口的第4位脚，连接ADC0832DO脚
sbit CS=P1^0; //CS定义为P1口的第4位脚，连接ADC0832CS脚
uchar h1,date;
unsigned char adval;
void delay(uint z)
{
uchar y;
for(;z&gt;0;z–)
for(y=120;y&gt;0;y–);
}
/读数模转换数据*********************/
//请先了解ADC0832模数转换的串行协议，再来读本函数，主要是对应时序图来理解，本函数是模拟0832的串行协议进行的
// 1 1 0 通道
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a04c55aa1f247cd197e6dbbcb6d746cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a2afc24b21a412036556d729f70458b/" rel="bookmark">
			leetcode 127. 单词接龙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode127
给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典中的单词。
说明:
如果不存在这样的转换序列，返回 0。
所有单词具有相同的长度。
所有单词只由小写字母组成。
字典中不存在重复的单词。
你可以假设 beginWord 和 endWord 是非空的，且二者不相同。
示例 1:
输入:
beginWord = “hit”,
endWord = “cog”,
wordList = [“hot”,“dot”,“dog”,“lot”,“log”,“cog”]
输出: 5
解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,
返回它的长度 5。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/word-ladder
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
class Solution { public: unordered_map&lt;string, int&gt; mp; vector&lt;vector&lt;int&gt;&gt; edge; int nodeNum = 0; //经过自己的思路（BFS+两个字符串的相似判断函数）无数次的超时，最终还是打开官方题解。。 //BFS+虚拟节点 //建立单词与节点id的映射 void addWord(string &amp;word) { //虚拟的节点也需要id if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a2afc24b21a412036556d729f70458b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07c950253410d40588c21f52379a5348/" rel="bookmark">
			坑人的raid5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司的测试服务器，使用三块硬盘做了个raid5，然而没有UPS,公司经常断电，多的时候一个月两次，一旦开机就是verify，等啊等啊，终于等到normal，ok
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b94561b629144d96f7a5e62cd32cf5/" rel="bookmark">
			rsa算法简单例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.选择一对素数 p 和 q
2.n = p * q
3.f(n) = (p -1) * (q - 1)
4.找一个与f(n)互质的数加密秘钥e，且1&lt;e&lt;f(n)
5.计算解密秘钥d,d * e ≡ 1 mod f(n), ≡为互余符号，符号左边必须和符号右边同余，也就是两边模运算结果相同，即(d * e) mod f(n) = 1 mod f(n) = 1, (d * e) mod f(n) = 1, d*e = k*(f(n) + 1)
6.公钥(e, n),私钥(d, n)
7.设明文m,明文加密,密文c = m^e mod n
8.密文解密，明文m = c^d mod n
假设需要加密的明文信息为m=14，选择：e=3，p=5，q=11，试说明使用RSA算法的加密和解密过程及结果？ n=p*q=55 φ(n)=(p-1)*(q-1)=4*10=40 根据e*d≡1 mod φ(n) 又3*d mod 40=1 得出d=27 公钥(n,e)=(55,3) 得到密文c=m^e mod 55=14^3 mod 55=49 私钥(n,d)=(55,27) 得到明文m=c^d mod 55=49^27 mod 55=14 来源：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b94561b629144d96f7a5e62cd32cf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6416192862b731a98f100d3f12ee06ed/" rel="bookmark">
			关于int *p[]和int (*p)[] 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int *p[] []优先级高于*，所以p先是一个数组，然后数组每个元素的类型是int*， int *p[]是一个(int *)类型的指针数组，p本质上是一个数组；
int (*p)[] ()优先级高于[]，所以p先与*结合，是一个指针，指针的类型是一个int[]数组，int (*p)[]是一个数组指针，p本质上是一个指针。
#include &lt;stdio.h&gt; int main(void) { printf("=====int (*p)[]=====\n"); int a[2][3] = {{1, 2, 3},{4, 5, 6}}; //C/C++没有多维数组，实质上是数组的数组; //a先是一个维度为2的数组，该数组每一个元素又是维度为3的数组。 int (*p)[3] = a; //p是指向维度为3的数组的指针，a转化为指向int[2]数组第一维的指针， //第一维是维度为3的数组。 for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 3; j++) printf("*(*(p+%d)+%d)=%d\n", i, j,*(*(p + i) + j)); //*(p+i)等于a[i] //(*(p+i)+j)等于(a[i])[j]，即a[i][j] printf("=====int *q[]=====\n"); int b[4] = {11, 22, 33, 44}; int c[4] = {55, 66, 77, 88}; int *q[2]; //q是指针的数组，注意此处数组维度为2，而不一定要是4 *q = b; //*q即*(q+0)，也即q[0]，即第一个指针，指向数组b *(q + 1) = c; //*(q+1)，即q[1]，即第二个指针，指向数组c for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 4; j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6416192862b731a98f100d3f12ee06ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b16fea02bd5f42d442b47d9ce60787/" rel="bookmark">
			aplay 命令-D
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # aplay -l
**** List of PLAYBACK Hardware Devices ****
card 0: ecodecsoundcard [ecodec-sound-card], device 0: x2000 ecodec pcm ak4493-aif-0 []
Subdevices: 1/1
Subdevice #0: subdevice #0
card 1: spdifsoundcard [spdif-sound-card], device 0: x2000 SPDIF snd-soc-dummy-dai-0 []
Subdevices: 1/1
Subdevice #0: subdevice #0
# aplay -D hw:1,0 adobe.wav aplay -D hw:card,device adobe.wav 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/346/">«</a>
	<span class="pagination__item pagination__item--current">347/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/348/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>