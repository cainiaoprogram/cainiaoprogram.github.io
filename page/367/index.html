<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d06e6cda82f4b3f70d24fb716a8286/" rel="bookmark">
			vue页面监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue页面监听 Vue - 监听页面刷新和关闭 Vue - 监听页面刷新和关闭 Vue - 监听页面刷新和关闭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcbcad1314f7dfbc6bb56efdaf489801/" rel="bookmark">
			155. 最小栈(java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		155. 最小栈 题目描述 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。
示例:
输入：
[“MinStack”,“push”,“push”,“push”,“getMin”,“pop”,“top”,“getMin”]
[[],[-2],[0],[-3],[],[],[],[]]
输出：
[null,null,null,null,-3,null,0,-2]
解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); --&gt; 返回 -3.
minStack.pop();
minStack.top(); --&gt; 返回 0.
minStack.getMin(); --&gt; 返回 -2.
提示：
pop、top 和 getMin 操作总是在 非空栈 上调用。
解法一：辅助双栈 栈1作为正常出入栈，栈2存储栈1中最小值
class MinStack { Stack&lt;Integer&gt; stack1; Stack&lt;Integer&gt; stack2; /** initialize your data structure here.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcbcad1314f7dfbc6bb56efdaf489801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6c85bbf8d14916e087469717d58990/" rel="bookmark">
			mycat 实现读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. mycat简介 mycat是一个开源数据库中间件；它可以管理你的所有数据库，并对他们进行读写分离，分库分表等。
使用起来的话Mycat就是一个近似于MySQL的数据库服务器，你可以用连接MySQL的方式去连接Mycat（除了端口不同，默认的Mycat端口是8066而非MySQL的3306），大多数情况下，可以用你熟悉的对象映射框架比如MyBatis操作Mycat。
它最主要的两个功能就是：
数据库的读写分离分库分表 2. 下载mycat mycat的官网：https://github.com/MyCATApache/Mycat-Server
可以从这里去下载，我下载的是1.6版本的
下载后，直接解压
tar –zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz 然后进入bin目录，执行以下命令就可以启动了
./mycat start MyCat关闭命令：
./mycat stop 登录mycat：用类似mysql的登录方式就可以登录了，初始账号下面会有说明
mysql -uroot -p -P8066 -h127.0.0.1 mycat默认数据访问端口是8066
3. 配置文件 其实进行读写分离 我们只需要配置2个文件就可以使用了，进入conf文件夹：
server.xml：系统配置，比如用户，白名单等schema.xml： 配置关联的数据库，在这里面做读写分离，分库分表等操作 3.1 server.xml讲解 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mycat:server SYSTEM "server.dtd"&gt; &lt;mycat:server xmlns:mycat="http://io.mycat/"&gt; &lt;system&gt; &lt;property name="useSqlStat"&gt;0&lt;/property&gt; &lt;!-- 1为开启实时统计、0为关闭 --&gt; &lt;property name="useGlobleTableCheck"&gt;0&lt;/property&gt; &lt;!-- 1为开启全加班一致性检测、0为关闭 --&gt; &lt;!-- 指定使用Mycat全局序列的类型：即数据库主键的生成方式 0为本地文件方式，1为数据库方式，2为时间戳序列方式。 对于读写分离而言，是不需要考虑主键生成方式的，也就是不需要配置全局序列号的。 --&gt; &lt;property name="sequnceHandlerType"&gt;2&lt;/property&gt; &lt;property name="processorBufferPoolType"&gt;0&lt;/property&gt; &lt;property name="handleDistributedTransactions"&gt;0&lt;/property&gt; &lt;property name="useOffHeapForMerge"&gt;1&lt;/property&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6c85bbf8d14916e087469717d58990/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be96f654b4add0323f4618660231607/" rel="bookmark">
			Java并发学习笔记（六）：不可变、final、保护性拷贝、享元模式、final原理、无状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不可变 一、 日期转换的问题 1、引入 下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); for (int i = 0; i &lt; 10; i++) { new Thread(() -&gt; { try { System.out.println(sdf.parse("1951-04-21")); } catch (Exception e) { e.printStackTrace(); } }).start(); } 运行之后会出现下面的结果：
Mon Apr 21 00:00:00 CST 4 Sat Apr 21 00:00:00 CST 1951 Sat Apr 21 00:00:00 CST 1951 Sat Apr 21 00:00:00 CST 1951 Thu Apr 21 00:00:00 CST 214 Fri Apr 21 00:00:00 CST 4000 java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3be96f654b4add0323f4618660231607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c618be5b2df6e7de4ba3c8f98dc3937/" rel="bookmark">
			含重根的三阶实对称矩阵的快速对角化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，实对称矩阵一定可以相似对角化。而考试中考察的三阶实对称矩阵对角化基本都是三阶的。而且正常情况下特征根一定是整数。因此基于此，有一些特殊的方法可以快速计算三阶实对称矩阵的特征值和特征向量。
一. 猜根法计算特征值
特征值之和等于矩阵的对角线元素之和
特征值之积等于矩阵的行列式
假设矩阵的特征值都是整数
例题1
在假设特征值为整数的情况下，特征值之积为5，特征值之和为3，那么特征值只可能为5，-1 ,-1 因此直接选出答案。
注意：有经验的命题人会把矩阵的行列式的值弄成一个合数。这样就不会一下子被看出来。
二. 秩一矩阵的应用
秩一矩阵是指秩为一的矩阵，由于其特殊性，常常在考试中出现
设A是秩为1的n阶方阵, 则
1. A可表示为αβ^T, 其中α,β为n维列向量
2. A^k = (α^Tβ)^(k-1)A
3. tr(A)=α^Tβ
4. A的特征值为 α^Tβ,0,0,...,0
5. 秩一矩阵一定可以对角化，其中一个特征向量是α
注意:秩一矩阵的直观快速判断法是矩阵为一行都相等或成比例。
定理一:
如果一个矩阵A可以分解为一个秩一矩阵B加上一个常数c乘上单位矩阵，那么这个矩阵A的特征值就是tr(B)+c, c, ..., c。这个矩阵的特征向量和B的特征向量相同。
定理二：
如果一个三阶实对称矩阵具有一个二重特征根，那么一定可以分解为一个秩一矩阵B加上一个常数c乘上单位矩阵
证明： 设这个二重特征根为c，很容易证明R(A-cE) = 1, 令A= A-cE + cE即可。
例题2
​求下列矩阵A的特征值和特征向量
​​
A = 2*B - E，其中B为全1矩阵，E为单位矩阵, 显然A的特征值就是5,-1,-1
对于矩阵B来说，很容易看出一个特征向量(1,1,1)^T, 另外两个特征向量分别是(1,-1,0)^T
以及(1,0,-1)^T, 秩一矩阵对应的特征向量是很好求的。如果要求正交矩阵。可以借助向量外积公式来计算。
容易看出，当矩阵能分解为全一矩阵的倍数加上一个常数乘上一个单位阵时，这种情况是最简单。一眼就能看出来怎么分解。
对于一般的例子，很难直接看出怎么分解。解决的办法是先猜/算出特征根，然后再根据算出的二重根分解。
实战演练
很容易计算出来，tr(A）=1， det(A）=-12， 很容易猜出特征根，-3，2，2，计算
A-2E，很容易看出秩一矩阵，证明计算正确。
-3对应的特征向量是(-1,0,2)
2对应的特征向量是(2, 0, 1) 以及(0,1,0) (快速口算）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c618be5b2df6e7de4ba3c8f98dc3937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa78527bfd6668ea9fa7137e19c4200/" rel="bookmark">
			【WeUI】关于jQuery WeUI和WeUI版本兼容的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做的一个小demo，在添加Dialog的时候出现了对话框显示的问题，如下左图所示。
一开始以为自己的写的CSS文件影响了，注释掉还是这个问题，所以问题指向很明确了，是官方weui.css的问题。但是官方demo里的运行是正常显示的。
index.jsp页面引入了weui.css还有jquery-weui.css
一般使用jQuery WeUI时也需要依赖weui.css的，所以在jQuery WeUI解压后的dist/lib还会提供对应的weui.css
我的demo里用的 weui.css 是 v2.1.3 ，而jQuery WeUI依赖的这个weui.css 是 v1.1.3，由于版本不一致，导致页面显示不兼容。
解决办法也很简单，直接替换成可兼容的weui.css即可，但是现在发布的jQuery WeUI版本是比WeUI要低一个版本的，所以页面显示会有点点差异，如果不想修改页面其他元素的样式，又想保证Dialog正常显示，可以直接把上图里那段.weui-dialog替换或者修改一下位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e3b98852b1207ce7c7a839593eb567f/" rel="bookmark">
			错误error while loading shared libraries: xxx.so.x的原因和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误"error while loading shared libraries: xxx.so.x" 的原因和解决办法 li27z 2017-06-17 23:46:42 7154 收藏 3
展开
一般我们在Linux下执行某些外部程序的时候可能会提示找不到共享库的错误，比如：
error while loading shared libraries: libprotobuf.so.9: cannot open shared object file: No such file or directory
原因一般有两个，一个是操作系统里确实没有包含该共享库(lib*.so.*文件)或者共享库版本不对，遇到这种情况那就去网上下载并安装上即可。
另外一个原因就是已经安装了该共享库，但执行需要调用该共享库的程序的时候，程序按照默认共享库路径找不到该共享库文件。
如上图，编译、执行protobuf示例代码时报该错，但在目录/usr/local/lib下我们可以看到libprotobuf.so.9是存在的：
所以安装共享库后要注意共享库路径设置问题，如下：
1）如果共享库文件安装到了/lib或/usr/lib目录下, 那么需执行一下ldconfig命令。
ldconfig命令的用途，主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下，搜索出可共享的动态链接库(格式如lib*.so*)，进而创建出动态装入程序(ld.so)所需的链接和缓存文件。缓存文件默认为/etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表。
2）如果共享库文件安装到了/usr/local/lib（很多开源的共享库都会安装到该目录下）或其它“非/lib或/usr/lib”目录下，那么在执行ldconfig命令前，还要把新共享库目录加入到共享库配置文件/etc/ld.so.conf中，如下:
# cat /etc/ld.so.conf include ld.so.conf.d/*.conf # echo "/usr/local/lib" &gt;&gt; /etc/ld.so.conf # ldconfig 123456 3）如果共享库文件安装到了其它“非/lib或/usr/lib”目录下, 但是又不想在/etc/ld.so.conf中加路径（或者是没有权限加路径）。那么可以export一个全局变量LD_LIBRARY_PATH，然后运行程序的时候就会去这个目录中找共享库。
LD_LIBRARY_PATH的意思是告诉loader在哪些目录中可以找到共享库。可以设置多个搜索目录，这些目录之间用冒号分隔开。比如安装了一个mysql到/usr/local/mysql目录下，其中有一大堆库文件在/usr/local/mysql/lib下面，则可以在.bashrc或.bash_profile或shell里加入以下语句：
export LD_LIBRARY_PATH=/usr/local/mysql/lib:$LD_LIBRARY_PATH 1 一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a158d020ce3dad852ff1deb993b0c6/" rel="bookmark">
			【Linux指令】Centos网卡链路聚合标准操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器网卡链路聚合标准操作指导（Centos系统） 前期准备和说明相关命令聚合步骤 前期准备和说明 1：服务器挂载同一个交换机下面
2：服务器上安装了两个网卡且与交换机连接网线
相关命令 网络聚合相关指令
1：创建一个新的team类型的连接 名字是team0 ，其中loadbalance表示负载均衡，activebackup 表示热备
nmcli connection add type team con-name team0 ifname team0 config ‘{“runner”:{“name”:“loadbalance”}}’
2：将物理网卡加入到team0中
nmcli connection add type team-slave con-name team0-1 ifname enp2s0f1 master team0
nmcli connection add type team-slave con-name team0-2 ifname enp2s0f0 master team0
其他指令
1：删除逻辑口
nmcli connection delete team0
2：修改逻辑网口模式
nmcli connection modify team0 team.config ‘{“runner”:{“name”:“loadbalance”}}’
3：查看所有网口的状态
nmcli connection show
4：查看某个网口的状态
teamdctl team0 state
5：激活某个连接
nmcli connection up/down team0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27a158d020ce3dad852ff1deb993b0c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b5aa629a8a98864ed5e593bfdf7648e/" rel="bookmark">
			今天开始学Convex Optimization：第3章(part2) Optimization basics
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 重写约束条件部分优化：消除等式约束：引入Slack变量：例子： SVM的hinge loss form凸函数的一阶最优条件（First-order optimality conditions)例子：二次优化参考资料 本章来自Ryan Tibshirani的Convex Optimization: Fall 2019课程的Convexity II: Optimization basics小节。
先看一个比较容易理解的概念：最优解组成的集合是一个convex set
如果强凸的函数f，最优解是唯一的：
重写约束条件 限制条件在形式上也可以写成这样的形式（Indicator函数的形式很常见）
对凸函数来说，Local min就是Global min
下面是几个基本技巧:
部分优化： 如果有两个（多个）变量的优化函数，我们可以先求一个变量的最优解（表示成另一个变量的函数），然后优化这个最优解函数。
消除等式约束： 其实有点复杂，不是很明白动机。把x转化为My+x0，要求M的列空间等于A的零空间。这里可以稍微补充一句关于线性代数中矩阵列空间和零空间的概念[2][3][4]。
列空间：列空间是指由矩阵A的列向量线性组合而成，因此称为该矩阵的列空间。Col(A) = span(v1,v2,…,vn)，其中vi是A的列向量。零空间：矩阵A的零空间就Ax=0的解的集合，是方程特解的任意线性组合。记为Null(A)。
引入Slack变量： 让不等式变方向，并且不是一个函数而是一个变量。但是多了一个等式约束。
例子： SVM的hinge loss form SVM如果引入松弛因子，就可以写成hinge function形式：
凸函数的一阶最优条件（First-order optimality conditions) 对于一个凸优化问题，有定义域C，如果函数 f f f可微，那么一个点 x x x是最优点，当且仅当：
∇ f ( x ) T ( y − x ) ≥ 0 ， ∀ y ∈ C \nabla f(x)^T (y-x) \geq 0， \forall y \in C ∇f(x)T(y−x)≥0，∀y∈C
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b5aa629a8a98864ed5e593bfdf7648e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a689a5e2594e04c70a4fa23f94aab4c6/" rel="bookmark">
			小程序中输入框input的type属性 text、number、idcard、digit 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微信小程序的 input 有个属性叫 type，这个 type 有几个可选值：
text：不必解释number：数字键盘（无小数点）idcard：数字键盘（无小数点、有个 X 键）digit：数字键盘（有小数点） 注意：number 是无小数点的，digit 是有小数点的
&lt;text class="lxr" decode&gt;联系人&lt;/text&gt; &lt;view class="lxrinput"&gt; &lt;input type="text" class="" name="lxr" bind="lxr" placeholder=""&gt;&lt;/input&gt; &lt;/view&gt; &lt;text class="tel" decode&gt;电话&lt;/text&gt; &lt;view class="telinput"&gt; &lt;input type="number" class="" name="tel" bindblur="tel" placeholder=""&gt;&lt;/input&gt; &lt;/view&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a289abffe7b39b34c657aa9c879c995/" rel="bookmark">
			docker push 到阿里云镜像仓库过程中发生了 denied: requested access to the resource is denied 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker push 到阿里云镜像仓库过程中发生了 denied: requested access to the resource is denied 错误 问题发生环境 Vagrant 2.2.6 + VirtualBox 6.0.14docker 19.03.9 问题发生情况 本人在学习docker 过程，想通过push 命令将本地的image上传到阿里云镜像仓库中去在执行 sudo docker push registry.cn-hangzhou.aliyuncs.com/itcrazyasf2020/test-docker-image:v1.0 命令就报如上错了 问题原由 本人向阿里云push镜像的时候，阿里云镜像仓库中不存在 itcrazyasf2020 命名空间导致资源不可访问 问题解决 如下所示创建命名空间
再执行docker push 命令 ， sudo docker push registry.cn-hangzhou.aliyuncs.com/itcrazyasf2020/test-docker-image:v1.0
刷新阿里云镜像仓库，会发现多出了一条刚刚push成功的镜像
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f54cf53d40a02e28dbdf9925a9d224/" rel="bookmark">
			Java并发学习笔记（五）：乐观锁、CAS(比较交换)使用和原理、原子整数、原子引用、原子数组、原子累加器、Unsafe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乐观锁（非阻塞） 一、CAS（比较交换） 与 volatile 1、引入 现在需要在多线程的情况下对一个账户扣款操作，除了使用synchronized方法， 还可以使用AtomicInteger 的解决问题：
private AtomicInteger balance; ... public void withdraw(Integer amount) { // 需要不断尝试，直到成功为止 while (true) { int prev = balance.get(); int next = prev - amount; //进行比较设置 if (balance.compareAndSet(prev, next)) { break; } } } AtomicInteger::compareAndSet内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？
2、原理 其实compareAndSet方法的名字已经说明了，它的执行原理是：
compareAndSet 方法在设置 amount的值为next，前做了个检查，先比较 prev 与主内存中amount当前值不一致了，next 作废，返回 false 表示失败一致，以 next 设置为新值，返回 true 表示成功 其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap （比较交换）的说法），它必须是原子操作（操作系统保证）。CAS是乐观锁一种。下图用时序图表示了compareAndSet在上面代码中的工作流程：
当线程1从主内存获得余额为100并对其减10得到90之后，其他线程已经将余额更改了90，那么执行compareAndSet(100,90)时，将prev与主内存中余额的值比较之后发现不一样，则next作废，返回false。（下一次循环同理）
当线程1从主内存获得余额为80并对其减10得到70之后，执行compareAndSet(80,70)时，发现主内存中也是80，说明可进行设置，就将余额的值设为70，并返回true。
注意：
其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94f54cf53d40a02e28dbdf9925a9d224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27fc6df0424da78bf47116a51ca0f99b/" rel="bookmark">
			Mockito教程：使用Mockito进行测试和模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程大纲 Mockito是根据MIT许可证发布的Java开源测试框架，该框架允许在自动化单元测试中创建测试双重对象（模拟对象），以实现测试驱动开发（TDD）或行为驱动开发（BDD）的目的。 如官方文档所述：“ Mockito是一个非常不错的模拟框架。 它使您可以使用简洁的API编写漂亮的测试。 Mockito不会给您带来麻烦，因为测试的可读性很强，并且会产生清晰的验证错误。” 在本课程中，您将深入了解Mockito的魔力。 您将了解有关“模拟”，“间谍”和“部分模拟”的信息，以及它们相应的存根行为。 您还将看到使用测试双打和对象匹配器进行验证的过程。 最后，讨论了使用Mockito的测试驱动开发（TDD），以了解该库如何适合TDD的概念。 关于作者 Hugh是位于爱尔兰戈尔韦的高级软件工程师和认证Scrum大师。 他获得了理学学士学位。 2002年获得沃特福德理工学院应用计算专业的博士学位，从那时起一直从事工业研究。 他曾在纳斯达克和纽约证券交易所上市的几家大型蓝筹软件公司工作。 他的主要兴趣领域包括Core Java，JEE，Spring，Design Patterns，TDD，Maven和Agile Software Development。 经验教训 在本课程中，您将开始使用Mockito。 您将学习为什么以及何时使用Mocks，以及如何执行Mockito，存根和验证这两个阶段。 然后，您将看到如何将Mockito集成到您的项目中以及一些最佳实践。 现在，我们准备进入有关模拟，存根和间谍的更多详细信息。 我们将深入研究使用Mockito对类和接口进行存根，并且还将讨论对void方法进行存根和对返回值进行存根。 最后，我们将讨论参数匹配器和间谍程序以及部分存根。 验证是确认模拟行为的过程。 这对于确定我们正在测试的类是否已按预期方式与其任何依赖项进行交互非常有用。 我们将在Mockito的验证阶段中进行详细研究，并探讨可立即验证行为，创建自己的验证模式以及使用Argument Captors对数据进行更复杂的断言的方法。 Hamcrest是用于创建匹配对象的框架。 这些匹配器对象是谓词，用于编写在某些条件下可以满足的规则。 在本教程中，我们将研究Hamcrest Matcher库以及如何将其与JUnit和Mockito集成。 我们会不时遇到Matchers Hamcrest库的限制。 在本教程中，我们将使用Hamcrest提供的工具为各种情况创建匹配器。 我们将使用Hamcrest API创建我们自己的自定义匹配器，以扩展Hamcrest提供的“开箱即用”功能。 请确保转发此消息，让您的社交粉丝知道！ #Mockito教程：测试和嘲讽用的Mockito https://t.co/zhgvDeuYVI pic.twitter.com/gr2uDmmD4V — Java Code Geeks（@javacodegeeks） ，2015年11月15日 翻译自: https://www.javacodegeeks.com/2015/11/testing-with-mockito.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f0963d9fb10acb7fe941bea9675a3f/" rel="bookmark">
			RocketMQ监控平台（附网盘链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RocketMQ有一个对其扩展的开源项目incubator-rocketmq-externals，这个项目中有一个子模块叫rocketmq-console，这个便是管理控制台项目了，先将incubator-rocketmq-externals拉到本地，因为我们需要自己对rocketmq-console进行编译打包运行。
在linux环境下，使用nohub java -jar xxxx &amp; 启动，为了防止端口冲突，已经修改其端口为9999
链接：https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA
提取码：jpg0
### 3.5.2 下载并编译打包
git clone https://github.com/apache/rocketmq-externals cd rocketmq-console mvn clean package -Dmaven.test.skip=true 注意：打包前在rocketmq-console中配置namesrv集群地址：
rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876 启动rocketmq-console：
java -jar rocketmq-console-ng-1.0.0.jar 启动成功后，我们就可以通过浏览器访问http://localhost:8080进入控制台界面了，如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f35bc99ec498477fdff1dd077f4b22c/" rel="bookmark">
			ubuntu server 20.04 连接WiFi  用netplan
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#列出你的网络 ip a /etc/netplan/下面有个YAML配置文件
修改配置文件
ubuntu@ubuntu:~$ cat /etc/netplan/50-cloud-init.yaml network: ethernets: eth0: dhcp4: true optional: true version: 2 wifis: wlan0: dhcp4: true access-points: "你的wifi的ssid": password: "你的密码" netplan try netplan apply 我当时重启了一下才可以的，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f59086c26cde6eca8378aa42d951d54/" rel="bookmark">
			SWAP使用情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SWAP使用情况 ​ 当系统内存不足时，操作系统会从 SWAP 分区中分配一部分空间来临时
[mysql@ip131 ~]$ free -h total used free shared buff/cache available Mem: 1.8G 288M 1.2G 9.5M 256M 1.3G 输出项说明 Mem 行(第二行)是内存的使用情况。 Swap 行(第三行)是交换空间的使用情况。 total 列显示系统总的可用物理内存和交换空间大小。 used 列显示已经被使用的物理内存和交换空间。 free 列显示还有多少物理内存和交换空间可用使用。 shared 列显示被共享使用的物理内存大小。 buff/cache 列显示被 buffer 和 cache 使用的物理内存大小。 available 列显示还可以被应用程序使用的物理内存大小。 参考连接 https://www.cnblogs.com/ultranms/p/9254160.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f412e67564e09e353b4a96104917c3/" rel="bookmark">
			十款性能最佳的压缩算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据压缩是保留相同或绝大部分数据前提下减小文件大小的过程。它的原理是消除不必要的数据或以更高效的格式重新组织数据。在进行数据压缩时，你可以选择使用有损方法或无损方法。有损方法会永久性地擦除掉一些数据，而无损方法则能保证持有全部的数据。使用哪类方法取决于你要让你的文件保持多大的精准度。
本文会为你介绍6种不同的无损数据压缩算法，以及4种基于深度学习的图像/视频压缩算法。
6款无损数据压缩算法
无损压缩算法通常被用于归档或其他高保真目的。这些算法能够让你在确保文件可被完整恢复的同时减少文件大小。有很多种无损压缩算法供你选择。下面介绍6种常用的算法。
1. LZ77
LZ77算法发布于1977年。作为很多其他无损压缩算法的基础，它使用了“滑动窗口”的概念。在这个概念中，LZ77管理了一个字典。该字典使用三元组的方式：
偏移量（Offset）：短语起始处于文件开头之间的距离
行程长度（Run length）：组成短语的字符数
偏离字符：表明新短语的标记符，匹配结束后，前向缓冲区中的第一个符号
当文件被解析时，字典会被实时更新以反映最新的压缩数据和大小。举个例子，如果一个文件包含字符串"abbadabba"，那么被压缩到字典中的项就是"abb(0,1,'d')(0,3,'a')"。你可以看下下表的拆解过程：
这个例子中，被压缩后的数据并不比初始数据小多少。但一般情况下，当文件很长时，这种压缩效果就会显现出来。
2. LZR
LZR由Michael Rodeh于1981年提出，它是在LZ77的基础上发展而来。这个算法目标是成为LZ77的一个线性时间替换算法，但编码后Udell指针可能指向文件的任意偏移量，意味着需要耗费可观的内存，因此表现不如LZ77。
3. LZSS
LZSS，全称Lempel-Ziv-Storer-Szymanski，于1982年提出。它也是旨在提升LZ77的一个算法。它引入了一个方法能够检测是否真的减少了文件大小。如果未能起到压缩效果，就保持原来的输入格式。LZSS还移除了对偏离字符的使用，只使用&lt;偏移量，长度&gt;对。这个压缩算法广泛用于归档格式，如RAR以及网络数据的压缩。
4. DEFLATE
DEFLATE算法于1993年提出。作者是Phil Katz。该算法结合了LZ77或LZSS预处理器与霍夫曼编码。霍夫曼编码是1952年提出的诉法。它是一种熵编码，主要基于字符出现频度分配编码。
5. LZMA
LZMA算法，全称是Lempel-Ziv Markov chain Algorithm（LZMA)，于1998年提出，是LZ77的改进版，旨在实现.7z格式的7-ZIp文件归档。它使用链式压缩方法，在比特而非字节级别上应用修改后的LZ77算法。该压缩算法的输出稍后被算数编码进行处理以便后续进一步压缩。根据具体的实现不同，可能会引入其他的压缩步骤。
6. LZMA2
LZMA2算法于2009年提出，是LZMA的改良版。它提升了LZMA在多线程能力上的性能以及提升了处理不可压缩类型数据的表现。
4种基于深度学习的图像/视频压缩算法
除了上面介绍的静态压缩算法，还有基于深度学习的压缩算法可供选择。
1. 基于多层感知机的压缩算法
多层感知机（Multi-Layer Perceptron，MLP）技术使用多层神经元来获取、处理以及输出数据。它能够被应用到数据降维任务和数据压缩。首个基于MLP的算法于1988年被提出，目前已经被应用到：
二进制编码——标准的双符号编码
量化——限制从连续集到离散集的输入
特定领域内的转换——像素级的数据变更
MLP算法利用分解神经网络上一步的输出来确定最佳的二进制码组合。后面，使用预测技术优化这个方法。预测技术能够通过反向传播基于相邻数据来提升数据准确度。
2. DeepCoder -- 基于视频压缩的深度神经网络
DeepCoder是一个基于卷积神经网络（CNN）的框架，它是传统视频压缩技术的替代。该模型为预测信号和残留信号使用单独的CNN。它使用标量量化技术和一个传统的文件压缩算法——霍夫曼编码——将编码特征映射到一个二进制流中。一般认为，该模型的性能要优于著名的H.264/AVC视频编码规范。
3. 基于CNN的压缩算法
CNN是分层的神经网络，通常用于图像识别和特征检测。当应用到压缩时，这些神经网络使用卷积操作来计算相邻像素点之间的相关性。CNN展示出了比基于MLP算法更好的压缩结果，提升了超分辨率下的性能以及减少了伪影。另外，基于CNN的压缩还提升了JPEG图像的品质，因为它减少了峰值信噪比（PSNR）和结构相似性（SSIM）。基于CNN的压缩通过使用熵估计法还实现了HEVC的性能。
4. 基于生成式对抗网络（GAN）的压缩算法
GAN属于神经网络的一种，它使用两个神经网络彼此竞争的方式来产生更精确的分析和预测。最早基于GAN的压缩算法于2017年被提出。这些算法的文件压缩比例是其他常见方法（如JPEG、WebP等）的2.5倍。你可以使用基于GAN的方法通过并行化处理来实现实时压缩。主要的原理是基于最相关的特征来压缩图片。当解码的时候，算法基于这些特征来重建图像。和基于CNN算法相比，基于GAN的压缩算法通过消除对抗损失能够产生更高品质的图像。
总结
压缩算法能够帮助你优化文件大小。不同的算法有不同的结果。本文简述了6种静态的无损压缩算法以及4种基于深度学习的压缩算法。当然，如果这些算法都不适用于你的场景，你可以查看这篇文章来寻找适合你场景的算法。算法有很多，总有一款适合你！
原文地址：https://dzone.com/articles/crunch-time-10-best-compression-algorithms
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae3b42553d62a3abe30c1e5316a99e1e/" rel="bookmark">
			【转载】[网络安全自学篇] 八十.WHUCTF之WEB类解题思路WP（代码审计、文件包含、过滤绕过、SQL注入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/Eastmount/article/details/106409569?utm_medium=distribute.pc_category.none-task-blog-hot-5.nonecase&amp;depth_1-utm_source=distribute.pc_category.none-task-blog-hot-5.nonecase&amp;request_id=
链接.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6a508da1489d9514db0369d10b6917/" rel="bookmark">
			如何将char数组转换回字符串？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自：How to convert a char array back to a string?
I have a char array: 我有一个char数组： char[] a = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'}; My current solution is to do 我目前的解决方案是做 String b = new String(a); But surely there is a better way of doing this? 但肯定有更好的方法吗？ #1楼 参考：https://stackoom.com/question/W7Rn/如何将char数组转换回字符串
#2楼 This will convert char array back to string: 这会将char数组转换回字符串： char[] charArray = {'a', 'b', 'c'}; String str = String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd6a508da1489d9514db0369d10b6917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bd5f711a517642084975de2dfb1577/" rel="bookmark">
			微信小程序蓝牙发送数据给设备，支持发送字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
wsml
&lt;view&gt;{{shuju}}&lt;/view&gt; &lt;wxs module="utils"&gt; module.exports.max = function(n1, n2) { return Math.max(n1, n2) } module.exports.len = function(arr) { arr = arr || [] return arr.length } &lt;/wxs&gt; &lt;button bindtap="openBluetoothAdapter"&gt;开始扫描&lt;/button&gt; &lt;button bindtap="stopBluetoothDevicesDiscovery"&gt;停止扫描&lt;/button&gt; &lt;!-- &lt;button bindtap="closeBluetoothAdapter"&gt;结束流程&lt;/button&gt; --&gt; &lt;button bindtap="nav_map"&gt;进入地图&lt;/button&gt; &lt;view class="devices_summary"&gt;已发现 {{devices.length}} 个外围设备：&lt;/view&gt; &lt;scroll-view class="device_list" scroll-y scroll-with-animation&gt; &lt;view wx:for="{{devices}}" wx:key="index" data-device-id="{{item.deviceId}}" data-name="{{item.name || item.localName}}" bindtap="createBLEConnection" class="device_item" hover-class="device_item_hover"&gt; &lt;view style="font-size: 16px; color: #333;"&gt;{{item.name}}&lt;/view&gt; &lt;view style="font-size: 10px"&gt;信号强度: {{item.RSSI}}dBm ({{utils.max(0, item.RSSI + 100)}}%)&lt;/view&gt; &lt;view style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60bd5f711a517642084975de2dfb1577/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/decc6a7c016faecbcbd1f1c4a81089fc/" rel="bookmark">
			教你Vim编辑器，如何删除一行或者多行内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何从Vim中删除行？如何删除多行？本文介绍在Vim编辑器中删除行的不同方法文内含长段代码可复制可往左滑，希望对大家有帮助！
安装Vim
#在Ubuntu/Debian中的安装方式 $ sudo apt install vim #在RHEL/Centos中的安装方式 #] yum -y install vim &lt;以上代码可复制粘贴，可往左滑&gt;
删除单行内容
将光标移动到需要删除的行
按一下ESC键，确保退出编辑模式
按两次键盘上面的d键，就可以删除了。
删除所有的行
下面是三种删除方式
第一种方式
按一下ESC键，确保退出编辑模式
按两次键盘上面的g键，让光标移动到文本的首行
然后按键盘上面的d和G键。其中d键是小写，G键要切换成大写的。
这样就可以删除所有内容了。
第二种方式
按一下ESC键，确保退出编辑模式
按一下:冒号键，(shift + ;)就可以输入：冒号了。
然后输入1,$d
第三种方式
按一下ESC键，确保退出编辑模式
按一下:冒号键，shift + ; 就可以输入：冒号了。
然后输入%d。%表示文件中的所有行。
删除多行
将光标移动到需要删除的行
按一下ESC键，确保退出编辑模式
在dd命令前面加上要删除的行数。例如，如果要删除第4行以下的3行，请按下 3 dd
删除给定范围的行
实例一
如果你想要删除指定范围的行，比如从第3行到第5行，按ESC，然后输入下面的命令，然后回车。
:3,5d &lt;以上代码可复制粘贴，可往左滑&gt;
实例二
删除最后一行，按ESC，然后输入下面的命令，然后回车。
:$d &lt;以上代码可复制粘贴，可往左滑&gt;
实例三
删除当前行之前的所有行
:1,.-1d &lt;以上代码可复制粘贴，可往左滑&gt;
实例四
删除当前行之后的所有行
:.+1,$d &lt;以上代码可复制粘贴，可往左滑&gt;
通过条件匹配删除行
实例一
删除包含text关键字的行
:g/text/d &lt;以上代码可复制粘贴，可往左滑&gt;
实例二
删除不包含#关键字的行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/decc6a7c016faecbcbd1f1c4a81089fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c22ab7f1bd59acc640a6f4e7bdda6f/" rel="bookmark">
			线程优化Python写GUI业务卡顿问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用线程的思想去写代码 软件中的线程 我课余学的是Python，在GUI编程方面，Python确实没有想C#和VB一样那么方便，但是由于项目需要的并不是很复杂的GUI界面以及业务处理，考虑到Python在数据处理方面的优越性，所以就用了Python写GUI界面，刚开始的时候写一些简单的业务逻辑还是算比较正常的，但是在写注册、登录、业务单循环等功能的时候，出现了卡顿，后来在网上找了一些解决办法，有加定时器的，有用线程的，而我就是采用了线程的思想去解决这个问题。话不多说，直接上代码
**#***************************************************************************************""" ''' * @brief :将任务函数打包进线性执行 * @param : * @func ：function_name * @*args : the params of your function which you need to package * @note : null * @return: null ''' def thread_pack(func,*args): t = threading.Thread(target=func,args=args) #守护进程 t.setDaemon(True) #启动进程 t.start()** 代码解释：这里用的可能比较简单，首先就是创建一个线程，target参数就是线程要去执行的业务函数，args就是这个业务函数可能需要用到的参数，可以传多个进来，最后就是对线程进行守护和启动。下面给一个调用的例子：
btn3_quit = tkinter.Button(win, text="退出系统", bg="red", fg="#87CEEB", command=lambda: event.thread_pack(win.destroy)) btn4_help = tkinter.Button(win, text="使用帮助", bg="red", fg="#87CEEB", command=lambda: event.thread_pack(event.button_Event.Help)) btn_mail = tkinter.Button(win,text="发送数据至邮箱", bg="#B4EEB4", fg="#0A0A0A", command = lambda: event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7c22ab7f1bd59acc640a6f4e7bdda6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87721ee4ce8593cd38db4f33ed6ae0f0/" rel="bookmark">
			邓公《数据结构》第五章习题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		邓公《数据结构》
第五章 二叉树
Q5
From the node node u of the binary tree of n nodes to the root node node by node, the following mistakes are:从n个节点的二叉树的叶节点u逐个节点地上溯到根节点的过程中，以下说法中错误的是：
A The passing nodes are all ancestors of u.经过的节点都是u的祖先。
B The worst time complexity is O(n)最坏时间复杂度为O(n)
C The path that is passed is uniquely determined经过的路径是唯一确定的
D Each time it goes up one level, the depth of the current node decreases by one and the height increases by one.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87721ee4ce8593cd38db4f33ed6ae0f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e53be2773ac892418efe0ee65f63ac/" rel="bookmark">
			如何使用Docker暴露多个端口？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自：How can I expose more than 1 port with Docker?
So I have 3 ports that should be exposed to the machine's interface. 所以我有3个端口应该暴露在机器的界面上。 Is it possible to do this with a Docker container? 是否可以使用Docker容器执行此操作？ #1楼 参考：https://stackoom.com/question/1PSka/如何使用Docker暴露多个端口
#2楼 To expose just one port, this is what you need to do: 要暴露一个端口，这是您需要做的： docker run -p &lt;host_port&gt;:&lt;container_port&gt; To expose multiple ports, simply provide multiple -p arguments: 要公开多个端口，只需提供多个-p参数： docker run -p &lt;host_port1&gt;:&lt;container_port1&gt; -p &lt;host_port2&gt;:&lt;container_port2&gt; #3楼 Step1 步骤1 In your Dockerfile , you can use the verb EXPOSE to expose multiple ports.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14e53be2773ac892418efe0ee65f63ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7355d5347b2975a5f45d96d089077a31/" rel="bookmark">
			老卫带你学---图形推理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图形推理50中规律，自行阅读
大小变化方向旋转笔画增减 ( 数字 , 线条数 )图形求同相同部份去掉图形叠加 ( 简单叠加 , 合并叠加 , 去同叠加 )图形组合变化 ( 如: 首尾两个图形中都包含中间图形 )对应位置阴影变化 ( 两图相同或不同则第三图对应位置变阴影或变空白 )顺时针或逆时针旋转总笔画成等差数列由内向外逐步包含相同部件 , 上下 , 左右组合类似组合 ( 如平行 , 图形个数一样等 )横竖线条之比有规律 ( 如横线 3条竖线 4条, 横线 4条竖线 5条等 )缺口相似或变化趋势相似（如逐步远离或靠近）图形运动变化 ( 同一个图形从各个角度看的不同样子 )图形拆分 ( 有三个图构成 , 后两个图为第一个图的构成部件 )线条交点数有规律方向规律 ( 上, 下, 左, 右)相隔一个图形分别对称 (如 : 以第三个图为中心 ,1 和 5对称 ,2 和4对称 )含义依据条件而变 ( 如一个错号 , 可以表 " 划 ", 也可以表示 " 两划 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7355d5347b2975a5f45d96d089077a31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90200d3cb230fde5a3497bf089214526/" rel="bookmark">
			idea创建Maven报错Cannot resolve plugin org.apache.maven.plugins:maven-compiler-plugin:3.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因是本地maven的配置文件和仓库地址不一致
解决方法
打开setting搜索Maven将下面图中的override勾选，然后选择自己电脑本地的Maven下载仓库安装目录
之后就会匹配自己本地电脑仓库中的包，然后查看
完成下载更新之后，就不会出现上面的报错。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19c9ed29d8150eb3bca5a946c46322d/" rel="bookmark">
			afl覆盖率统计工具afl-cov常见问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“官网”http://cipherdyne.com/afl-cov/ https://github.com/mrash/afl-cov编译
需要使用gcc -fprofile-arcs -ftest-coverage test.c (-o cov.out)对源码进行插桩从而支持覆盖率的统计C++ lcov reached unexpected end of file问题
A：将编译信息清空make clean all
ref：https://stackoverflow.com/questions/35965415/c-lcov-reached-unexpected-end-of-file对afl覆盖统计命令 afl-cov -d /path/to/afl-fuzz-output/ --live --coverage-cmd \ "cat AFL_FILE | LD_LIBRARY_PATH=./lib/.libs ./bin/.libs/somebin -a -b -c" \ --code-dir . 先执行afl-cov，再执行afl，afl-cov将读取afl output/queue中的所有文件，--live将实时读取新生成的文件。 --coverage-cmd里面用带覆盖率插桩的可执行文件“./cov.out AFL_FILE". AFL_FILE为固定写法，代表从queue中读取到的文件。 如果使用stdin读取输入，需要使用cat。 对klee覆盖统计命令
afl-cov -d klee-last --live --coverage-cmd "cat AFL_FILE | ./gcccov.out" --code-dir . --klee --overwrite覆盖路径、时间
在kleetmp-cov和afltmp-cov文件夹中*.extra的文件对于klee-last/testxxx, afl/output/queue/xxx，可以在python中用pickle处理文件
注意：afl-cov一开始执行就会计时，统计覆盖信息会等klee/afl生成测试用例，后者开始的时间影响覆盖计时。Non-zero exit status '1' for CMD: /usr/bin/readelf -a cat Could not find an executable binary with code coverage support ('-fprofile-arcs -ftest-coverage' ) in --coverage-cmd 'cat -A AFL_FILE|.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e19c9ed29d8150eb3bca5a946c46322d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00cc6eb7ce42f3f1483c314d4b837b6a/" rel="bookmark">
			矩阵可对角化的条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结：对于任意方阵，如果没有重根，矩阵总是可以对角化。麻烦的是重根问题 如果有重根，那么需要验证所谓几何重数，与代数重数相等。
那么对于有重根，不能对角化的矩阵怎么办？这就引入了Jordan标准型的故事。
因此从应用的角度来说，线性代数最重要的就是矩阵的对角化。由矩阵对角化的推广就引出了奇异值分解和Jordan标准型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e282c7a0ea444dce3d9f8cb8e3608708/" rel="bookmark">
			Python实验：循环结构程序设计、字符串的应用、列表与元组的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.从键盘输入5组数，每组有6个数，求出每组中的元素绝对值之和的最大者和最小者，请补充程序
2.利用公式计算：
3.求数列前20项之和
4.求满足如下条件的3位数，它除以9的商等于它各位数字的平方和。例如224，它除以9的商为24，而2²+2²+4²=24。
5.如果一个整数等于它的因子（不包括该数本身）之和，则称该数为完数。例如，6的因子是1,2,3，因为6=1+2+3，因此6是完数。找出1000以内的所有完数。
6.下面是打印如下图所示金字塔图案的程序，请补充程序
7.输入一行字符，分别统计出其中英文字母、空格、数字和其他字符的个数。
8.输入一个英文句子，将其中的小写字母转换为大写字母后并输出。
9.输入一个字母标识符，计算标识符中各个字母的数值之和，其中A=a=1，B=b=2，„，Z=z=26，例如“Lucy”的数值为12+21+3+25=61。
10.筛选法求[2,n]范围内全部素数的基本思路是：在2~n中消去2的倍数（不包括2），再消去3的倍数（不包括3），由于4已被消去，再找5的倍数，···，直到消去不超过n的倍数，剩下的数都是素数。下面是用筛选法求[2,n]范围内的全部素数的程序，请补充程序。
11.将列表的元素按逆序重新存放。
12.将列表 s 中的偶数变成它的平方，奇数保持不变。
13.生成包含 100 个 2 位随机整数的元组，统计每一个数出现的次数。
14.生成包含20个随机整数的元组，将前十个数按升序排列，后十个数按降序排列。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a2ff5204a3b86c23a9d1e72f3bb1dfd/" rel="bookmark">
			@Mock和@InjectMocks之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自：Difference between @Mock and @InjectMocks
Mockito框架中的@Mock和@InjectMocks什么区别？ #1楼 参考：https://stackoom.com/question/175zp/Mock和-InjectMocks之间的区别
#2楼 @Mock creates a mock. @Mock创建了一个模拟。 @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock (or @Spy ) annotations into this instance. @InjectMocks创建该类的实例，并将使用@Mock （或@Spy ）注释创建的@Spy注入此实例。 Note that you must use @RunWith(MockitoJUnitRunner.class) or Mockito.initMocks(this) to initialize these mocks and inject them. 请注意，您必须使用@RunWith(MockitoJUnitRunner.class)或Mockito.initMocks(this)来初始化这些Mockito.initMocks(this)并注入它们。 @RunWith(MockitoJUnitRunner.class) public class SomeManagerTest { @InjectMocks private SomeManager someManager; @Mock private SomeDependency someDependency; // this will be injected into someManager //tests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a2ff5204a3b86c23a9d1e72f3bb1dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7ea56d35da025b45df2091b1d30874b/" rel="bookmark">
			查找重复元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 找出数组 arr 中重复出现过的元素
示例1
输入 复制
[1, 2, 4, 4, 3, 3, 1, 5, 3] 输出 复制
[1, 3, 4] function duplicates(arr) { const map = new Map() const arr1 = [] arr.forEach((val) =&gt; { if(!map.has(val)) { map.set(val, 1) } else { arr1.push(val) } }) const set = new Set(arr1) const arr2 = Array.from(set) arr2.sort((a,b) =&gt; a-b) return arr2 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/239c3b88c9abc9dc110aab64c6ac05f6/" rel="bookmark">
			手工编写继承keras.utils.Sequence类的图像生成器用于图像回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之所以要手动编写数据生成器是因为我做的工作是图像回归，而不是图像分类。也就是说作为监督学习的标签是连续型变量而不是离散型变量，而据我所知keras自带的ImageDataGenerator类只能用于图像分类。网上已有不少自己写的数据生成器，但如果希望对比训练数据集和测试数据集的效果（如损失函数），在用fit_generator()方法训练模型时参数validation_data支持的数据生成器最好是keras.utils.Sequence的子类，否则validation_steps参数不能为空。查了一遍keras文档，继承Sequence的类并不难写，文档里给了一个简单的例子。
from skimage.io import imread from skimage.transform import resize import numpy as np # 这里，`x_set` 是图像的路径列表 # 以及 `y_set` 是对应的类别 class CIFAR10Sequence(Sequence): def __init__(self, x_set, y_set, batch_size): self.x, self.y = x_set, y_set self.batch_size = batch_size def __len__(self): return int(np.ceil(len(self.x) / float(self.batch_size))) def __getitem__(self, idx): batch_x = self.x[idx * self.batch_size:(idx + 1) * self.batch_size] batch_y = self.y[idx * self.batch_size:(idx + 1) * self.batch_size] return np.array([ resize(imread(file_name), (200, 200)) for file_name in batch_x]), np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/239c3b88c9abc9dc110aab64c6ac05f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6283350eee84c447c89ad085868a501d/" rel="bookmark">
			android  IntentFilter详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.由一个问题引发的思考：
对于启动一个广播，静态注册一个广播，intent-filter中什么也不设置，在发送广播中对intent也不设置，是否可以匹配到？
写代码验证，直接编译不通过：
Missing one of the key attributes ‘action#name,category#name’ on element intent-filter at AndroidManifest.xml:20:13-25:29
2.IntentFilter过滤规则的全面学习
(1)IntentFilter的解释：
Structured description of Intent values to be matched. An IntentFilter can
match against actions, categories, and data (either via its type, scheme,
and/or path) in an Intent. It also includes a “priority” value which is
used to order multiple matching filters.
IntentFilter objects are often created in XML as part of a package's {@link android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6283350eee84c447c89ad085868a501d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add35d1954b965753b01bbbc4b975042/" rel="bookmark">
			常用巡检命令1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vmstat 2 5 df -h
uptime
w
last -n 20
top
crontab -l
free -m
netstat -s
netstat -antp
1、用户登录、定时任务
crontab -l
last
who
2、系统版本
cat /etc/issue #
cat /etc/redhat-release #
uname -a #
uname -r #
3、性能
top
free -m
df -h
ps -ef
4、安全
cat /etc/passwd
cat /etc/group
5、日志
dmesg
6、其他
hostname
cat /proc/cpuinfo
#du -sh &lt; 目录名&gt; # 查看指定目录的大小
#grep MemTotal /proc/meminfo # 查看内存总量
#grep MemFree /proc/meminfo # 查看空闲内存量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/add35d1954b965753b01bbbc4b975042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe62b489075f6406b5126a2795f7c4c/" rel="bookmark">
			（4.6.12）Android  Resource详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、构造函数1.1 成员变量1.2 构造函数1.3 提供功能1.3.1 getString(int id)、getIntArray(int id) 、getStringArray(int id)1.3.2 基于getValue的1.3.2.1 getDimension1.3.2.2 getDrawable1.3.2.2 getColor、getBoolean、getInteger1.3.2.3 loadXmlResourceParser加载getLayout、getAnimation、getXml 1.3.4 obtainTypedArray(@ArrayRes int id)1.3.5 getMovie(int id) 二、Resource的获取三、Resource的生成四、ResourceManager4.1 单例模式4.2 getTopLevelResources生成Resource 参考文献 Resource实例
Resource的实例保存在ContextImpl中，每次构建ContextImpl时，会从LoadedApk中拿到对应的ResourceLoadedapk中的getResource会有成员实例mResource，命中直接返回，没命中委托Activitythread—ResourceManager生成ResourceMamager里有map缓存，命中直接返回，没命中则先新建Assetmanager，再构建Resource实例 全局唯一性
mResources通过一系列的缓存或者成员实例引用，实现了全局唯一。如果通过打补丁的方式，会全局生效（small替换了resourcemanager中瓜缓存的resource的assetmanager，实现全局替换）。但是在插件化方案中，为了避免id冲突，有的使用的是替换法，那就是所有有缓存和成员实例的地方都要替换为我们自己的resource; 一、构造函数 Resource.java
1.1 成员变量 重要成员变量 AssetManager mAssets; 构建时需要传入 public class Resources { private static final LongSparseArray&lt;ConstantState&gt;[] sPreloadedDrawables; private static final LongSparseArray&lt;ConstantState&gt; sPreloadedColorDrawables = new LongSparseArray&lt;ConstantState&gt;(); private static final LongSparseArray&lt;ColorStateList&gt; sPreloadedColorStateLists = new LongSparseArray&lt;ColorStateList&gt;(); // Pool of TypedArrays targeted to this Resources object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe62b489075f6406b5126a2795f7c4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6d872a573e88b241e5b34b416f58ab/" rel="bookmark">
			人脸识别损失函数之Center Loss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人脸识别的难点在于:
1、不同类人脸类别之间的分类界限不明显；
2、人脸之间的相似度很高，人类也难以区分；
3、人脸的特征分类困难。
解决途径：
1、网络模型：
残差 深度可分类 稠密网络 densenet alexet inception net 等等。。
2、损失函数：
对于回归问题，常用的损失函数是均方误差（MSE，Mean Squared Error）。
对于分类问题，常用的损失函数为交叉熵（CE，Cross Entropy）。交叉熵一般与one-hot和softmax在一起使用。
改进多分类损失函数，对细微特征的能达到好的分类效果。
一、One-Hot
在分类问题中，one-hot编码是目标类别的表达方式。目标类别需要由文字标签，转换为one-hot编码的标签。one-hot向量，在目标类别的索引位置是1，在其他位置是0。类别的数量就是one-hot向量的维度。在one-hot编码中，假设类别变量之间相互独立。同时，在多分类问题中，one-hot与softmax组合使用。
import numpy as np def one_hot(arr): """ 概率矩阵转换为One-Hot矩阵 arr = np.array([[0.1, 0.5, 0.4], [0.2, 0.1, 0.6]]) :param arr: 概率矩阵 :return: One-Hot矩阵 """ arr_size = arr.shape[1] # 类别数 arr_max = np.argmax(arr, axis=1) # 最大值位置 oh_arr = np.eye(arr_size)[arr_max] # One-Hot矩阵 return oh_arr 二、Softmax
softmax使得神经网络的多个输出值的总和为1，softmax的输出值就是概率分布，应用于多分类问题。softmax也属于激活函数。softmax、one-hot和cross-entropy，一般组合使用。
import numpy as np def softmax(x): orig_shape=x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e6d872a573e88b241e5b34b416f58ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc622705325fc014571651ace4d43c33/" rel="bookmark">
			删除数组中的指定元素——C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序分析：
第一行输入一个整数(0≤N≤50)。
第二行输入N个整数，输入用空格分隔的N个整数。
第三行输入想要进行删除的一个整数。
输出为一行，删除指定数字之后的序列。
C++代码：
#include&lt;iostream&gt; using namespace std; int main() { int n, array[50], target; cin &gt;&gt; n; for (int i = 0; i&lt;n; i++) { cin &gt;&gt; array[i]; } cin &gt;&gt; target; cout &lt;&lt; endl; int j = 0; for (int i = 0; i&lt;n; i++) { if (array[i] != target) { array[j] = array[i]; cout &lt;&lt; array[j]; j++; } } } C++运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e52356e57866ef7f425ea6db03dbef/" rel="bookmark">
			矩阵转置——C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++代码：
#include&lt;iostream&gt; using namespace std; int main() { int m, n, array[50][50], result[50][50]; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i&lt;m; i++) { for (int j = 0; j&lt;n; j++) { cin &gt;&gt; array[i][j]; result[j][i] = array[i][j]; } } cout&lt;&lt;endl; for (int i = 0; i&lt;n; i++) { for (int j = 0; j&lt;m; j++) { cout &lt;&lt; result[i][j] &lt;&lt; " "; } cout &lt;&lt; endl; } } C++运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d06e38abbadd7b36a54baa68326a92d1/" rel="bookmark">
			删除数组中的重复元素——C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序分析：
输入包含两行，第一行包含一个正整数n（1 ≤ n ≤ 1000），表示第二行序列中数字的个数；第二行包含n个整数（范围1~5000），用空格分隔。
输出为一行，按照输入的顺序输出去重之后的数字，用空格分隔。
C++代码：
#include&lt;iostream&gt; using namespace std; int main() { int n, array[100], flag = 1; cin &gt;&gt; n; for (int i = 0; i&lt;n; i++) { cin &gt;&gt; array[i]; for (int k = 0; k&lt;i; k++) { if (array[i] == array[k]) { flag = 0; } } if (flag) { cout &lt;&lt; array[i] &lt;&lt; " "; } flag = 1; } } C++运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678a37508eea4f9b26bbb662de6422c1/" rel="bookmark">
			Eclipse安装JRebel(一款JVM级别的热部署插件)2020最新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eclipse安装JRebel(一款JVM级别的热部署插件)2020最新 1.JRebel介绍: JRebel是一套JavaEE开发工具。JRebel允许开发团队在有限的时间内完成更多的任务修正更多的问题，发布更高质量的软件产品。 JRebel是收费软件，用户可以在JRebel官方站点下载30天的评估版本。
Jrebel 可快速实现热部署，节省了大量重启时间，提高了个人开发效率。
JRebel是一款JAVA虚拟机插件，它使得JAVA程序员能在不进行重部署的情况下，即时看到代码的改变对一个应用程序带来的影响。JRebel使你能即时分别看到代码、类和资源的变化，你可以一个个地上传而不是一次性全部部署。当程序员在开发环境中对任何一个类或者资源作出修改的时候，这个变化会直接反应在部署好的应用程序上，从而跳过了构建和部署的过程，每年可以省去部署用的时间花费高达5.25个星期。
2.Eclipse安装JRebel 1.点击顶部菜单栏Help-&gt;Eclipse Marketplace进入插件市场 2.搜索JReble，进行点击安装(install)，由于我已经安装了所以这里显示的是installed
Eclipse安装完插件必须重启，否则无法看到接下来的右侧菜单栏，如果没有这个右侧菜单栏就点击右上角的JRebel图标即可！！！
3.激活JRebel
说到激活JRebel这里有个开源项目:https://github.com/ilanyu/ReverseProxy/releases
这里按照自己的系统下载对应版本，我的系统是windows10下载了ReverseProxy_windows_386.exe
并且在自己的云服务器也部署了一个，云服务器系统Centos7 下载的是ReverseProxy_linux_386
下载以后双击打开刚刚下载的exe可执行文件
说明已经启动成功了，可以打开命令行窗口输入
netstat -ano|find "8888" 进行测试，是否成功启动
接着我们回到eclipse，打开JRebel激活界面
选择第一种URL地址激活
填入:
http://0.0.0.0:8888/88414687-3b91-4286-89ba-2dc813b107ce 第二个位置的邮箱可以随便填写!
然后点击change license即可激活成功!
使用JRebel 点击Project configuration-&gt;Projects 左边会显示出你的项目，需要使用JRebel的直接勾上即可
重要提示：这里虽然我们已经对项目开放了JRebel但是我们还没有对指定项目启动JRebel插件，启动方式:
1.打开项目启动配置:
2.对指定项目启动JRebel代理
到这里就可以直接启动项目了
如果出现了如上所述的JRebel日志说明已经成功了，本项目的Java代码编译后即可直接调试无需重启!!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6106ea50f236ea89126dcdefc3a44ba1/" rel="bookmark">
			datagrid调用getEditor为null?这样你试过了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		datagrid调用getEditor为null?这样你试过了吗？ 前言问题引入问题解决方案一方案二 前言 在使用easyui的datagrid时遇到了这么一个问题，使用getEditor获取editor的结果为空，记录一下解决过程。
问题引入 var row = $('#tt').datagrid('getSelected'); var rowIndex = $('#tt').datagrid('getRowIndex',row); let ed ed = $('#tt').datagrid('getEditor', {index:rowIndex, field:'aa'}); $(ed.target).combobox('reload', url); 在上面一段代码中，最后一行报错，Cannot read property ‘target’ of null
无法获取到target，如果此时在控制台打印editor就会发现是null，说明并没有实际取到editor。
问题解决 在网上搜索datagrid editor 为null 大概可以找到这个方案
方案一 在设置值之前开启行编辑，也就是在最前面加上这一行
$('#tt').datagrid('beginEdit', 0); 那么问题解决了没有呢？并没有，这种方案在编辑行是适用的，在datagrid的编辑行中前面获取到的rowIndex确实可以取到对应行，但在新增行中rowIndex=-1，而-1是没办法获取到对应行的此时就需要用另一种方法
方案二 var row = $('#tt').datagrid('getSelected'); var rowIndex = $('#tt').datagrid('getRowIndex',row); let ed if (rowIndex == -1) { ed = $('#tt').datagrid('getEditor', {index:$('#tt').datagrid('getRows').length-1, field:'aa'}); $(ed.target).combobox('reload', url); } else { ed = $('#tt').datagrid('getEditor', {index:rowIndex, field:'aa'}); $(ed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6106ea50f236ea89126dcdefc3a44ba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16485ee1277ab80c6050fa812464a5e9/" rel="bookmark">
			快速上手Android蓝牙串口开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/ 今日科技快讯 /
近日，快手科技与京东零售集团正式签署战略合作协议。双方将在快手小店的供应链能力打造、品牌营销和数据能力共建等方面展开深入合作，共同打造短视频直播电商新生态。
/ 作者简介 /
本篇文章来自gtf35的投稿，分享了Android中的蓝牙开发的内容，相信会对大家有所帮助！同时也感谢作者贡献的精彩文章。
gtf35的博客地址：
https://blog.gtf35.top/
/ 前言 /
最近在做做物联网相关的内容，经常需要用到蓝牙串口来和单片机通讯。引出了几个问题：
蓝牙串口是什么？
如何扫描蓝牙设备
如何连接蓝牙设备
如何收发串口数据
/ 蓝牙串口是什么？ /
先介绍下串口，串行接口简称串口，就是一种通信的方式，类似于「USB」，只是比USB低级多了。但是手机等设备他没外置这个串口，解决方式就是手机用蓝牙连接一个小硬件，小硬件有个串口，他的和单片机连接，来达到手机和单片机的串口连接，这种方式就是蓝牙串口。
在开发之前你最好有那个小硬件，那个小硬件通常叫「蓝牙透传模块」，淘宝不到30块钱就能买一个。我的长这样，有专用的上位机，这个你不明的请联系卖你模块的人，他会给予技术支持的：
你要做的就是打开电脑上蓝牙模块的上位机的串口界面，能正常的收发数据即可：
/ 如何扫描蓝牙设备 /
你肯定是有个问题，为啥不直接连接，而是要扫描呢？
因为连接需要使用「BluetoothDevice」，这个东西要么搜索到，要么用 「MAC」地址构造。「MAC」地址是每个设备独一无二的，所以必须要扫描设备，获取周围所有的设备列表，拿到 「BluetoothDevice」来连接。同时取出里面的 「MAC」地址，保存，用来下次连接。
我们先获取系统的蓝牙适配器，所有的搜索，连接，等操作都要靠他：
BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); 然后判断下用户的蓝牙是否已经开启：
/** * 获取用户是否打开了蓝牙 */ boolean isBluetoothEnable() { return mBluetoothAdapter.isEnabled(); } 要是一个没开蓝牙就想连蓝牙的人，我们就勉为其难帮他开启下吧 #(笑
/** * 开启蓝牙 */ void enableBluetooth() { mBluetoothAdapter.enable(); } 现在蓝牙已经开启了，那就开始搜索设备列表
mBluetoothAdapter.startDiscovery(); 但是我们还需要考虑下是不是已经正在搜索：
mBluetoothAdapter.isDiscovering() 如果正在搜索就给他取消掉：
mBluetoothAdapter.cancelDiscovery() 所以结合起来就是：
/** * 开始搜索 */ void startDiscovery() { if (mBluetoothAdapter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16485ee1277ab80c6050fa812464a5e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5432cad6b45afffd8dad7013457ebce2/" rel="bookmark">
			js设置input输入框为必选输入框，判断空格或null值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置input为输入框为必选输入框，即判空：
&lt;form action="demo-form.php"&gt; Username:&lt;span style="color:red"&gt;*&lt;/span&gt; &lt;input type="text" name="usrname" required&gt; &lt;input type="submit"&gt; &lt;/form&gt; 判断输入值为空格或null值：
if((n.indexOf(" ") &gt;= 0 || n == null)){ alert("用户名或用户名不能为空格或null值"); return false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd51f3db8b672701b82aa26bacd82ffa/" rel="bookmark">
			windows环境下Mycat的安装、配置和测试使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mycat是什么 详见（官网）
一个彻底开源的，面向企业应用开发的大数据库集群 支持事务、ACID、可以替代MySQL的加强版数据库 一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群 一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server 结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品 一个新颖的数据库中间件产品 Mycat作用 (1). 集中管理多个数据库连接（分布式解决方案）
(2). 配置读写分离
(3). 配置数据库分片（分表、分库）等 （本文视角）
安装配置 1. 准备 环境：jdk1.8、mysql5.6、mycat1.6.7（官网）
测试工具：Navicat12
2. 目录结构 图中分别对应执行、配置、日志等文件目录
3. 配置 主要配置server.xml、schema.xml、rule.xml等文件，下面每个配置的内容均来自本地测试分表分库配置结果。内容已经包含详细介绍和说明。
server.xml：启动服务相关配置
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- - - Licensed under the Apache License, Version 2.0 (the "License"); - you may not use this file except in compliance with the License. - You may obtain a copy of the License at - - http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd51f3db8b672701b82aa26bacd82ffa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/decc1139396276a6be319baa3850d51b/" rel="bookmark">
			动态绑定 class 的几种实现方式 - Vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常开发中难免会遇到动态渲染修改样式的需求出现，So 简单归纳如下三种实现方式，虽然还是学时的时候有所了解但事后很久不在接触，此次重新初识前端不久，哪里可以更优还请大佬多多指教！
方式一：通过Class 与 Style 绑定的方式 即三目运算的判断方式设置样式，也是 Vue 官方推荐的方式，具体 code 实现如下：
html 代码片段
&lt;button type="button" :disabled="btnDisabledState" :class="[btnDisabledState ? 'btnDisabledStyle' : 'btnStyle']" @click="arcExamPaper"&gt;点击抽题&lt;/button&gt; js 代码片段
&lt;script&gt; import ProjectEnviroment from "../../expand/define/ProjectEnviroment"; import YHHttpRequestManage from "../../expand/network/YHHttpRequestManage"; import { Toast } from "vant"; export default { // 随机抽提 name : "YHArcExamPaper", data() { return { btnDisabledState: false, // 按钮状态 - 初始设置 } }, methods: { arcExamPaper : function () { var urlLink = ProjectEnviroment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/decc1139396276a6be319baa3850d51b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ccd4cf31af1b9de391db082915b7fa4/" rel="bookmark">
			使用openMVG的openMVG_main_ComputeMatches命令报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令行使用openMVG_main_ComputeMatches命令时报错，原因可能是因为其中涉及到了一些cpu不支持的操作。github issues
解决办法：在命令后加上选项-n ANNL2，就可以使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b255f9766c6a411aa846c862d50f0681/" rel="bookmark">
			在滴滴和头条干了 2 年后端开发，太真实…
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：syntax_error https://www.nowcoder.com/discuss/351805
先简单交代一下背景吧，某不知名985的本硕，17年毕业加入滴滴，今年下半年跳槽到了头条，一直从事后端研发相关的工作。
之前没有实习经历，算是两年半的工作经验吧。这两年半之间完成了一次晋升，换了一家公司，有过开心满足的时光，也有过迷茫挣扎的日子，不过还算顺利地从一只职场小菜鸟转变为了一名资深划水员。
在这个过程中，总结出了一些还算实用的划水经验，有些是自己领悟到的，有些是跟别人交流学到的，在这里跟大家分享一下。
学会深入思考，总结沉淀 我想说的第一条就是要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。
‌先来说深入思考。在程序员这个圈子里，常能听到一些言论：我这个工作一点技术含量都没有，每天就CRUD，再写写if-else，这TM能让我学到什么东西？
抛开一部分调侃和戏谑的论调不谈，这可能确实是一部分同学的真实想法，至少曾经的我，就这么认为过。
后来随着工作经验的积累，加上和一些高level的同学交流探讨之后，我发现这个想法其实是非常错误的。之所以出现没什么可学的这样的看法，基本上是思维懒惰的结果。
任何一件看起来很不起眼的小事，只要进行深入思考，稍微纵向挖深或者横向拓宽一下，都是足以让人沉溺的知识海洋。
‌举一个例子。某次有个同学跟我说，这周有个服务OOM了，查了一周发现有个地方defer写的有问题，改了几行代码上线修复了，周报都没法写。
可能大家也遇到过这样的场景，还算是有一定的代表性。其实就查bug这件事来说，是一个发现问题，排查问题，解决问题的过程，包含了触发、定位、复现、根因、修复、复盘等诸多步骤。
花了一周来做这件事，一定有不断尝试与纠错的过程，这里面其实就有很多思考的空间。比如说定位，如何缩小范围的？走了哪些弯路？用了哪些分析工具？
比如说根因，可以研究的点起码有linux的OOM，k8s的OOM，go的内存管理，defer机制，函数闭包的原理等等。如果这些真的都不涉及，仍然花了一周时间做这件事，那复盘应该会有很多思考，提出来几十个WHY没问题吧…
‌再来说下总结沉淀。这个我觉得也是大多数程序员比较欠缺的地方，只顾埋头干活，可以把一件事做的很好。但是几乎从来不做抽象总结，以至于工作好几年了，所掌握的知识还是零星的几点，不成体系，不仅容易遗忘，而且造成自己视野比较窄，看问题比较局限。
适时地做一些总结沉淀是很重要的，这是一个从术到道的过程，会让自己看问题的角度更广，层次更高。遇到同类型的问题，可以按照总结好的方法论，系统化、层次化地推进和解决。
‌还是举一个例子。做后台服务，今天优化了1G内存，明天优化了50%的读写耗时，是不是可以做一下性能优化的总结？
比如说在应用层，可以管理服务对接的应用方，梳理他们访问的合理性；在架构层，可以做缓存、预处理、读写分离、异步、并行等等；在代码层，可以做的事情更多了，资源池化、对象复用、无锁化设计、大key拆分、延迟处理、编码压缩、gc调优还有各种语言相关的高性能实践…
等下次再遇到需要性能优化的场景，一整套思路立马就能套用过来了，剩下的就是工具和实操的事儿了。大家也可以关注微信公众号：Java技术栈，在后台回复：架构，可以获取我整理的 N 篇 Java 架构教程，都是干货。
‌还有的同学说了，我就每天跟PM撕撕逼，做做需求，也不做性能优化啊。先不讨论是否可以搞性能优化，单就做业务需求来讲，也有可以总结的地方。比如说，如何做系统建设？系统核心能力，系统边界，系统瓶颈，服务分层拆分，服务治理这些问题有思考过吗？
每天跟PM讨论需求，那作为技术同学该如何培养产品思维，引导产品走向，如何做到架构先行于业务，这些问题也是可以思考和总结的吧。就想一下，连接手维护别人烂代码这种蛋疼的事情，都能让Martin Fowler整出来一套重构理论，还显得那么高大上，我们确实也没啥必要对自己的工作妄自菲薄…
‌所以说学习和成长是一个自驱的过程，如果觉得没什么可学的，大概率并不是真的没什么可学的，而是因为自己太懒了，不仅是行动上太懒了，思维上也太懒了。
‌可以多写技术文章，多分享，强迫自己去思考和总结，毕竟如果文章深度不够，大家也不好意思公开分享。说到分享，大家可以关注微信公众号：Java技术栈，在后台回复：Java，可以获取我写的过的 N 篇 Java 技术教程，都是干货。
积极学习，保持技术热情 ‌最近两年在互联网圈里广泛传播的一种焦虑论叫做35岁程序员现象，大意是说程序员这个行业干到35岁就基本等着被裁员了。程序员究竟能干多少年？这篇推荐大家看下。
不可否认，互联网行业在这一点上确实不如公务员等体制内职业。但是这个问题里35岁程序员并不是绝对生理意义上的35岁，应该是指那些工作十几年和工作两三年没什么太大区别的程序员。
后面的工作基本是在吃老本，没有主动学习与充电，35岁和25岁差不多，而且没有了25岁时对学习成长的渴望，反而添了家庭生活的诸多琐事，薪资要求往往也较高，在企业看来这确实是没什么竞争力。
‌而如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了35岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？但是学习这件事，其实是一个反人类的过程，这就需要我们强迫自己跳出自己的安逸区，主动学习，保持技术热情。
在滴滴时有一句话大概是，主动跳出自己的舒适区，感到挣扎与压力的时候，往往是黎明前的黑暗，那才是成长最快的时候。相反如果感觉自己每天都过得很安逸，工作只是在混时长，那可能真的是温水煮青蛙了。
‌刚毕业的这段时间，往往空闲时间还比较多，正是努力学习技术的好时候。借助这段时间夯实基础，培养出良好的学习习惯，保持积极的学习态度，应该是受益终身的。至于如何高效率学习，网上有很多大牛写这样的帖子，到了公司后内网也能找到很多这样的分享，我就不多谈了。
‌可以加入学习小组和技术社区，公司内和公司外的都可以，关注前沿技术。
‌主动承担，及时交流反馈 ‌前两条还是从个人的角度出发来说的，希望大家可以提升个人能力，保持核心竞争力，但从公司角度来讲，公司招聘员工入职，最重要的是让员工创造出业务价值，为公司服务。
虽然对于校招生一般都会有一定的培养体系，但实际上公司确实没有帮助我们成长的义务。而在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。
我当初刚入职的时候，基本就是leader给分配什么任务就把本职工作做好，然后就干自己的事了，几乎从来不主动去跟别人交流或者主动去思考些能帮助项目发展的点子。自以为把本职工作保质保量完成就行了，后来发现这么做其实是非常不够的，这只是最基本的要求。
而有些同学的做法则是leader只需要同步一下最近要做什么方向，下面的一系列事情基本不需要leader操心了 ，这样的同学我是leader我也喜欢啊。入职后经常会听到的一个词叫owner意识，大概就是这个意思吧。
‌在这个过程中，另外很重要的一点就是及时向上沟通反馈。项目进展不顺利，遇到什么问题，及时跟leader同步，技术方案拿捏不准可以跟leader探讨，一些资源协调不了可以找leader帮忙，不要有太多顾忌，认为这些会太麻烦，leader其实就是干这个事的。。
如果项目进展比较顺利，确实也不需要leader介入，那也需要及时把项目的进度，取得的收益及时反馈，自己有什么想法也提出来探讨，问问leader对当前进展的建议，还有哪些地方需要改进，消除信息误差。
做这些事一方面是合理利用leader的各种资源，另一方面也可以让leader了解到自己的工作量，对项目整体有所把控，毕竟leader也有leader，也是要汇报的。可能算是大家比较反感的向上管理吧，有内味了，这个其实我也做得不好。但是最基本的一点，不要接了一个任务闷着头干活甚至与世隔绝了，一个月了也没跟leader同步过，想着憋个大招之类的，那基本凉凉。
‌一定要主动，可以先从强迫自己在各种公开场合发言开始，有问题或想法及时one-one
‌除了以上几点，还有一些小点我觉得也是比较重要的，列在下面：‌
第一件事建立信任 ‌无论是校招还是社招，刚入职的第一件事是非常重要的，直接决定了leader和同事对自己的第一印象。入职后要做的第一件事一定要做好，最起码的要顺利完成而且不能出线上事故。这件事的目的就是为了建立信任，让团队觉得自己起码是靠谱的。
如果这件事做得比较好，后面一路都会比较顺利。如果这件事就搞杂了，可能有的leader还会给第二次机会，再搞不好，后面就很难了，这一条对于社招来说更为重要。
‌而刚入职，公司技术栈不熟练，业务繁杂很难理清什么头绪，压力确实比较大。这时候一方面需要自己投入更多的精力，另一方面要多跟组内的同学交流，不懂就问。
最有效率的学习方式，我觉得不是什么看书啊学习视频啊，而是直接去找对应的人聊，让别人讲一遍自己基本就全懂了，这效率比看文档看代码快多了，不仅省去了过滤无用信息的过程，还了解到了业务的演变历史。当然，这需要一定的沟通技巧，毕竟同事们也都很忙。
‌脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。
超出预期 ‌超出预期这个词的外延范围很广，比如leader让去做个值周，解答用户群里大家的问题，结果不仅解答了大家的问题，还收集了这些问题进行分类，进而做了一个智能问答机器人解放了值周的人力，这可以算超出预期。比如leader让给运营做一个小工具，结果建设了一系列的工具甚至发展成了一个平台，成为了一个完整的项目，这也算超出预期。
超出预期要求我们有把事情做大的能力，也就是想到了leader没想到的地方，并且创造了实际价值，拿到了业务收益。这个能力其实也比较重要，在工作中发现，有的人能把一个小盘子越做越大，而有的人恰好反之，那么那些有创新能力，经常超出预期的同学发展空间显然就更大一点。
‌这块其实比较看个人能力，暂时没想到什么太好的捷径，多想一步吧。
体系化思考，系统化建设 ‌这句话是晋升时候总结出来的，大意就是做系统建设要有全局视野，不要局限于某一个小点，应该有良好的规划能力和清晰的演进蓝图。比如，今天加了一个监控，明天加一个报警，这些事不应该成为一个个孤岛，而是属于稳定性建设一期其中的一小步。
这一期稳定性建设要做的工作是报警配置和监控梳理，包括机器监控、系统监控、业务监控、数据监控等，预期能拿到XXX的收益。
这个工作还有后续的roadmap，稳定性建设二期要做容量规划，接入压测，三期要做降级演练，多活容灾，四期要做…给人的感觉就是这个人思考非常全面，办事有体系有规划。
‌平时积极总结沉淀，多跟别人交流，形成方法论。‌
提升自己的软素质能力 ‌这里的软素质能力其实想说的就是PPT、沟通、表达、时间管理、设计、文档等方面的能力。说实话，我觉得我当时能晋升就是因为PPT做的好了一点…可能大家平时对这些能力都不怎么关注，以前我也不重视，觉得比较简单，用时候直接上就行了，但事实可能并不像想象得那样简单。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b255f9766c6a411aa846c862d50f0681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2367e34beffa8825c2123f37c11925b6/" rel="bookmark">
			最实用的Makefile教程 真的很简单（搞不明白网上的教程写那么复杂干嘛）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 其实我的要求不高，我就是想要写个Makefile，把我那些需要反复编译的文件处理一下就可以了，所以我当时就拼命地在网上找关于Makefile的教程，结果看到的教程都是啰里啰嗦一大堆，看得我云里雾里。
大家要知道，在一些大公司里面，有一个职业是专门写Makefile的，可是我就想用Makefile完成那么一点基础的工作，你给我整那么多乱七八糟的东西干嘛。
在经受网上各种教程的毒打之后，我实在是忍不住了，我自己写一个教程算了。大家看这篇文章的时候，如果你也和我一样，一开始只是想解决最基础的问题，你就只要看第一个章节就可以了，后面的大家视情况而定。
一、Makefile的显式规则 首先，在Makefile中，#代表着注释，这个是不会被编译进去的。
其次，Makefile的基本语法是：
目标文件：依赖文件
[TAB]指令
大家注意，在Makefile里，有一个很反人类的规定，指令前必须打一个[Tab]键，按四下空格会报错。
越是接近目标文件的命令，就越是要写在前面。因为程序是按照递归的方式进行依赖文件查找的，看到第一行有一个没见过的依赖文件，就往下一行进行查找，以此类推。
但是有些同学反映，不按照这个顺序来写好像也不会报错，我觉得这可能是和版本有关系，不过保险起见，我建议大家还是按照规范来写Makefile。
举个例子：
hello:hello.o gcc hello.o -o hello hello.o:hello.S gcc -c hello.S -o hello.o hello.S:hello.i gcc -S hello.i -o hello.S hello.i:hello.c gcc -E hello.c -o hello.i 假设当前文件夹中有hello.c和Makefile两个文件，当我们在终端输入make指令的时候，就会自动编译出hello.o，hello.S，hello.i以及hello可执行文件。
可是，我们又不想要这些不相关的文件，想对这些文件做一些操作，我们把这样的操作叫做伪目标，标志位.PHONY:
在上述代码的最后面加上：
.PHONY: clear: rm hello.o hello.S hello.i .PHONY:这是固定格式，不能变的，但是下面的clear是自己取的名字，你随便取什么名字都可以，但是clear比较直观。
这样，当我们执行make clear指令后，将只剩下hello.c 和 hello可执行文件。
再来个复杂一点的例子：
# 目标文件：test # 现有文件：program1.c program1.h program2.c program2.h main.c main.h test:program1.o program2.o main.o gcc program1.o program2.o main.o -o test program1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2367e34beffa8825c2123f37c11925b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80486b78c04b4c4923dc4a880c17964c/" rel="bookmark">
			div中子元素input设置flex无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在flex布局下input设置flex:1失效的原因
由于input默认存在最小宽度，所以在父元素宽度太小的情况下input设置了flex:1会失效
解决办法
1:给input在嵌套一层div，设置flex
2:在给input设置width：100%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/625907cb9795d110537a3e5334d930fb/" rel="bookmark">
			C&#43;&#43;检测网络端口是否被占用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++检测网络端口是否被占用 最近在使用Nginx搭建Web服务器，Nginx（发音同 engine x）是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个 BSD-like 协议下发行，可以在 UNIX、GNU/Linux、BSD、Mac OS X、Solaris，以及 Microsoft Windows 等操作系统中运行。将nginx设置成服务并开机自启动，在配置文件中需要写入端口号，但是系统中的端口号存在被占用的情况，需要对端口号进行检测，大体思路就是检测8080端口是否被占用，如果被占用了端口号+1，如果仍被占用再+1。
方法一：通过GetTcpTable/GetUdpTable方法判断端口是否被占用
#include &lt;tcpmib.h&gt; #include &lt;IPHlpApi.h&gt; //依赖lib库 Iphlpapi.lib Ws2_32.lib //获取Tcp端口状态 BOOL GetTcpPortState(ULONG nPort, ULONG *nStateID) { MIB_TCPTABLE TcpTable[100]; DWORD nSize = sizeof(TcpTable); if(NO_ERROR == GetTcpTable(&amp;TcpTable[0],&amp;nSize,TRUE)) { DWORD nCount = TcpTable[0].dwNumEntries; if (nCount &gt; 0) { for(DWORD i=0;i&lt;nCount;i++) { MIB_TCPROW TcpRow = TcpTable[0].table[i]; DWORD temp1 = TcpRow.dwLocalPort; int temp2 = temp1 / 256 + (temp1 % 256) * 256; if(temp2 == nPort) { *nStateID = TcpRow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/625907cb9795d110537a3e5334d930fb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/366/">«</a>
	<span class="pagination__item pagination__item--current">367/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/368/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>