<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f819438901ebc62a84a590056f3c4fb7/" rel="bookmark">
			python中chr函数是什么意思_ord函数和chr函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ord函数（order）返回一个字符对应的unicode编码，而chr函数（char）正好反过来，它返回一个unicode编码对应的字符。他们都是python内置函数。
为什么是unicode？因为unicode长度统一，都是2个byte，非常利于代码处理。UTF-8编码其实是一种压缩编码，字符长度不统一，适合存储和传输。（不管什么编码，ASCII符号对应的值都是一样的，英语是最佳计算机语言，不分国界，正如阿拉伯数字是最佳数字语言，也不分国界一样。）
&gt;&gt;&gt; for c in '麦新杰的www.pynote.net':
... print(c,ord(c),chr(ord(c)))
...
麦 40614 麦
新 26032 新
杰 26480 杰
的 30340 的
w 119 w
w 119 w
w 119 w
. 46 .
p 112 p
y 121 y
n 110 n
o 111 o
t 116 t
e 101 e
. 46 .
n 110 n
e 101 e
t 116 t
以上代码遍历一个字符串，一个个调用ord和chr函数并显示出来。
ord函数返回unicode编码，这样就可以将任意可以打出来的字符，都通过ord函数来寻找其对应的unicode值了。比如我们想找出所有中文标调符号的unicode值，只需要将所有中文标点符号输入ord函数即可。
chr函数的输入是unicode值，因此就存在一个有效范围的问题，官方解释有效范围是0到0x10ffff，否则会有ValueError抛出。既然unicode都是2个bytes，为什么有效范围的上限是3个bytes呢？我也不懂...
-- EOF --
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e91704e3aa5c6b63924afb33d75596a9/" rel="bookmark">
			手把手教你学Python之常见运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
算术运算符
关系运算符
逻辑运算符
位运算符
成员运算符
身份运算符
前面给大家介绍了Python中的一些基本数据类型，这些数据之间如何进行运算呢？这就需要借助于一些运算符了，Python中提供了一些常见的运算符用于执行一些基本运算，例如算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、成员运算符等。
算术运算符 算术运算符主要用于执行加减乘除、取余等基本的数学运算，其中为了方便输入用斜杠"/"表示除号。和其它编程语言中两个整数相除结果为整数不同，Python中两个整数相除结果为小数，如果需要获取整除结果则需要使用两个斜杠"//"。Python中用两个“*”号表示求幂，例如 2**3=8，3**2=9。
关系运算符 关系运算符用于比较两个操作数之间的大小关系，返回值为True或False。前提是两个操作数之间能够进行比较。比较两个操作数是否相等时需要使用两个等号，即==，一个等号用于赋值操作。和其他编程语言不同：Python中支持连写的关系运算，如 5&lt;a&lt;10，表示 a 是否在（5,10）之间。
逻辑运算符 逻辑运算符主要用于判断多个条件之间的逻辑关系，例如是否都满足、只需满足一个等。与其他编程语言不同的是：Python中用not 表示逻辑非，and 表示逻辑与， or 表示逻辑或。逻辑非的结果一定为True 或 Flase，而逻辑与和逻辑或的结果不一定为True或False，和具体的表达式有关。
逻辑与和逻辑或都是短路操作符，即从左到右对表达式进行求解，如果某一步即可确定最终结果，则不会继续对后面的表达式进行求解。
位运算符 执行位运算时会将整数转化为二进制形式，然后从最低位开始依次每位对齐，然后执行按位与、按位或、按位异或等操作。按位与时，只有两个都为1时才为1，其他都为0；按位或时，只要有一个为1结果为1，两个都为0时，结果才为0 ；按位异或时，两个相同是为0，两个不同时为1。按位反，原来为1，现在则为0，原来为0，现在则为1。
Python中支持算术运算符、位运算符和赋值运算符联合使用，形成复合赋值运算符。等价于先执行算术运算或位运算，然后将结果重新进行赋值。
成员运算符 成员运算符用于判断对象是否在指定的序列或集合中。
身份运算符 身份运算符用于判断两个对象是否是同一个对象。
不同的运算符拥有不同的优先级，和数学四则运算中，先做乘除，后做加减类似，当表达式中包含多种运算符时，结果并不是按照从左到右的顺序执行，而是根据运算符的优先级依次执行。优先级越高，越早执行，在实际应用中，当不清楚执行顺序时，可通过加括号改变运算符的执行顺序。
小小练习题
更多关于手把手教你学Python的文章和视频请关注微信公众号：手把手教你学编程。或者腾讯课堂、CSDN学院 里的手把手教你学Python系列视频。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e1044ae07b4e6d2c84407cd9fd26e5/" rel="bookmark">
			cv mat 灰度值和_深度学习CV实践指南！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Datawhale干货 作者：黄星源、樊亮、陈桦、斯国一
深度学习的发展不仅突破了许多视觉难题，也加速了计算机视觉领域相关技术的进步。本文主要从CV数据处理、CV模型(CNN)、CV模型训练流程以及CV模型集成对计算机视觉的基础知识和基本环节进行了讲解。
CV数据下载 https://tianchi.aliyun.com/competition/entrance/531795/information(阿里天池-零基础入门CV赛事)
CV数据处理 五种数据读取方法 目前较为主流的Python图像库的基本使用方法： 1. matplotlib
matplotlib是Python的绘图库，在科学绘图领域被广泛使用。使用plt.imread()读取图片将其储存为一个RGB像素值矩阵，再进行处理。故其可以与opencv或pillow结合使用，只需要传入像素值矩阵，matplotlib便可以接手处理接下来想要完成的操作。 2. PIL(pillow) PIL即Python Imaging Library，而pillow是PIL的一个分支。pillow提供了常见的图像读取和处理的操作，它比opencv更为轻巧，且可以与ipython notebook无缝集成。使用Image.open()读取图片储存为一个对象，并非是numpy矩阵。
3. OpenCV
OpenCV是一个跨平台的计算机视觉库，是今天介绍的所有图像库中最全面也最强大的库。使用cv2.imread()读取图片将其储存为一个BGR像素值矩阵，故若要结合使用matplotlib则要先进行转化。 4. skimage
skimage包是scikit-image SciKit (toolkit for SciPy) 的简称，它对scipy.ndimage进行了扩展，提供了更多的图片处理功能。skimage包由许多的子模块组成，各个子模块功能不同。使用io.imread()读取图片将其储存为一个RGB像素值矩阵。 5. imageio Imageio是一个Python库，提供了一个简单的接口用于读取和写入各种图像数据，包括动画图像，视频，体积数据和科学格式。使用imageio.imread()读取图片将其储存为一个RGB像素值矩阵。 五种数据扩增技巧
在深度学习模型的训练过程中，数据扩增是必不可少的环节。现有深度学习的参数非常多，一般的模型可训练的参数量基本上都是万到百万级别，而训练集样本的数量很难有这么多，数据扩增可以扩展样本空间。
扩增一般不会改变标签；对于物体检测，数据扩增会改变物体坐标位置；对于图像分割，数数据扩增方法有很多：从颜色空间、尺度空间到样本空间，同时根据不同任务数据扩增都有相应的区别。对于图像分类，数据据扩增会改变像素标签。以torchvision.transforms为例，首先整体了解数据扩增的方法，包括： 1. 裁剪
中心裁剪：transforms.CenterCrop；
随机裁剪：transforms.RandomCrop；
随机长宽比裁剪：transforms.RandomResizedCrop；
上下左右中心裁剪：transforms.FiveCrop；
上下左右中心裁剪后翻转: transforms.TenCrop。
2. 翻转和旋转 依概率p水平翻转：transforms.RandomHorizontalFlip(p=0.5)；
依概率p垂直翻转：transforms.RandomVerticalFlip(p=0.5)；
随机旋转：transforms.RandomRotation。
3. 随机遮挡 对图像进行随机遮挡: transforms.RandomErasing。
4. 图像变换 尺寸变换：transforms.Resize；
标准化：transforms.Normalize；
填充：transforms.Pad；
修改亮度、对比度和饱和度：transforms.ColorJitter；
转灰度图：transforms.Grayscale；
依概率p转为灰度图：transforms.RandomGrayscale；
线性变换：transforms.LinearTransformation()；
仿射变换：transforms.RandomAffine；
将数据转换为PILImage：transforms.ToPILImage；
转为tensor，并归一化至[0-1]：transforms.ToTensor；
用户自定义方法：transforms.Lambda。
5. 对transforms操作，使数据增强更灵活 transforms.RandomChoice(transforms): 从给定的一系列transforms中选一个进行操作；
transforms.RandomApply(transforms, p=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00e1044ae07b4e6d2c84407cd9fd26e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e020c6d158db6743bb8416ce90eb65d/" rel="bookmark">
			距离矢量路由算法_动态路由的相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家讲讲动态路由的相关知识。
一、路由选择基础
默认管理距离
路由源 默认AD
直连接口 0
静态路由 1
EIGRP汇总路由 5
EBGP 20
EIGRP 90
OSPF 110
ISIS 115
RIP 120
ExEIGRP 170
IBGP 200
未知 255
1.管理距离(administrative_distance，AD)，衡量来自相邻路由器上的路由选择信息的可信度的。管理距离是一个从0～255的整数值，0是最可信赖的，而255意味着不会有业务通过这个路由。
2.度量值(Metric)，某一个路由协议判别到目的网络的最佳路径的方法。当一路由器有多条路径到达某一目的网络时，路由协议必须判断其中的哪一条是最佳的并把它放到路由表中，路由协议会给每一条路径计算出一个数，这个数就是度量值，通常这个值是没有单位的。度量值越小，这条路径越佳。然而不同的路由协议定义度量值的方法是不一样的，所以不同的路由协议选择出的最佳距离可能是不一样的。
注：①如果一台路由器接收到两个对同一远程网络的更新内容，路由器首先要检查的是AD，如果一个被通告的路由比另一个具有较低的AD值，则那个带有较低AD值的路由将会被放置在路由表中。
②如果两个被通告的到同一网络的路由具有相同的AD值，则路由协议的度量值(metric，如跳数或链路的带宽值)将被用作寻找到达远程网络的最佳路径的依据。被通告的带有较低度量值的路由将被提交给IP路由表。
③如果两个被通告的路由具有相同的AD值及相同的度量值，那么路由选择协议将会对这一远程网络使用负载均衡(即它所发送的数据包会平分到每个链路上)。
二、距离矢量路由选择算法的特点
1.仅和相邻路由器交换信息；
2.路由器交换的信息是当前本路由器全部路由信息即自己的路由表(距离矢量路由协议与链路状态路由协议的一个根本区别就是距离矢量路由协议交换的是路由信息，而链路状态路由协议交换的是链路状态信息)；
3.按固定的时间间隔交换路由信息(如：RIP是30秒，实际上它是一个浮动的值)。
三、路由环路的限制办法
由于路由算法的问题或者网络中各种异常因素，造成从网络中某个路由器发出的报文经过一段时间后，又回到了本路由器，这样的一个过程就叫做路由环路。
1.最大跳计数，RIP允许跳计数最大可以达到15，所以任何需要经过16条到达的网络在使用RIP作为路由选择协议的网络中都被认为是不可达的。
2.水平分割，路由选择协议区分网络路由信息是哪个接口获取的，一旦这个判断被确定，它将不再把有关这一路由的信息再从这个接口发送出去。
3.路由中毒，定义最大值在一定程度上解决了路由环路问题，但并不彻底。可以看到，在达到最大值之前路由环路还是存在的。为此，路由中毒就可以彻底解决这个问题。其原理是这样的：假设有三台路由器A、B、C(拓扑为路由器C与网络X直接相连，B连接到C，A连接到B)，当网络X出现故障无法访问的时候，路由器C便向邻居路由B发送相关路由更新信息，并将到达网络X的度量值标为initify或不可达(有时视为是无穷大)的表项来引发一个路由中毒，告诉邻居路由器B网络X已经不可达，路由器B收到毒化消息后将该链路路由表项也标记为无穷大，表示该路径已经失效，并向邻居路由器A通告，依次毒化各个路由器，告诉邻居网络X这个网络已经失效，从而尽量避免路由环路的发生几率。
4.毒性逆转：结合上面的例子，当路由器B看到到达网络X的度量值为无穷大的，就发送一个叫做毒化逆转的更新信息给C路由器，说明X这个网络不可达到，这是超越水平分割的一个特列，这样保证所有的路由器都接受到了毒化的路由信息。
5.保持关闭，可以阻止定期的更新消息去恢复一个不断开闭(称为翻动)的路由，即设置一个保持失效定时器。
6.触发更新：检测到网络发生变化的路由器会立即发送一个更新信息给邻居路由器，并依次产生触发更新通知它们的邻居路由器，使整个网络上的路由器在最短的时间内收到更新信息，从而快速了解整个网络的变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38cbe20200a9e24033aa3bc12daa459/" rel="bookmark">
			您的设备不支持googleplay服务_googleplay服务无法使用和商店使用方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ​提示:在使用谷歌服务之前必须有科学工具/代理
不然无法使用谷歌服务
大家在使用需要支持Googleplay服务的软件或者游戏的时候，都无法正常使用，因为国内的手机都没有这些框架，下面就教你怎么解决这些问题！ 1.针对你的设备不支持googleplay服务因此无法运行的
或者需要使用googleplay下载软件或者玩游戏的！
​如图提示:
教程:
http://t.cn/Air0zmZj 复制以后打开手机浏览器黏黏打开点击
立即下载↓
如图:
下载以后安装并打开软件
如图:
然后等待软件检测
并依次选择安装界面上提示的
google服务框架
google账号管理程序
googleplay服务
最后安装googleplay市场
也就是谷歌应用商店
所有安装完成以后
然后就可以用谷歌商店下载软件使用了！
其他需要支持googleplay服务的软件也可以使用了！
​
希望大家多多分享给不会使用的人
更多网络技术问题一定要
关注微信公众号: 网络信号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b662ad1d09ee7ff700a7b0c1e613c99b/" rel="bookmark">
			sklearn逻辑回归参数设置_逻辑回归模型预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何用分类模型预测消费者行为？ 针对类别型变量进行分析预测的方式——逻辑回归分析
分类模型和回归模型最明显的区别在于：
回归模型预测的Y是数字型变量，如销售额分类模型中，所预测的Y主要是类别型变量，如用户是否购买的标签只会有0（未购买）和1（购买） 什么是分类模型？
分类模型是机器通过学习与训练已有的数据，从而预测新数据的类别。
逻辑回归的定义
最主流的分类分析方法就是进行逻辑回归建模 模型性能稳定模型的解释变量和目标变量之间的关系容易解释逻辑回归不仅是分类模型的主力军，更是最常用的数据分析模型之一 逻辑回归模型的建立
建立逻辑回归模型，就是考虑在各种X的情况下，实现Y=1的概率。 Y=1 用户的点击/购买/注册Y=0 用户未点击/未购买/未注册对于每个需要预测的记录，都会生成一个预测的期望值 预测值，在0和1之间真实值，是1或者0预测值和真实值之间存在差值 逻辑回归模型的评估和优化
真实值和预测值会形成左图ABCD四种可能的组合。评判模型预测效果的好坏时，可用预测的正确数除以总数： (A+D)/(A+B+C+D)因此模型的优化过程就是尽可能减少 预测值和真实值之间的差值错误预测结果的数量 最常见的分类模型应用场景：
医疗肿瘤预测垃圾邮件识别个人信用评分 使用逻辑回归预测恶性肿瘤 调包与数据导入
# 导入pandas与numpy工具包。 查看数据
使用head()函数，查看前5行数据。
data.head() 数据特征解释：每个维度特征都是1～10之间的数字
Sample code number 样本代码编号Clump Thickness 肿块厚度Uniformity of Cell Size 细胞大小的均匀性Uniformity of Cell Shape 细胞形状的均匀性Marginal Adhesion 边缘粘Single Epithelial Cell Size 单上皮细胞的大小Bare Nuclei 裸核Bland Chromatin 乏味染色体Normal Nucleoli 正常核Mitoses 有丝分裂class 类别 2为良性，4为恶性 关键步骤一：缺失值处理
发现数据中有'?', 为了后续的分析，使用replace()将异常值替换为标准缺失值，用dropna()将带缺失值的行舍弃，代码如下
# 将?替换为标准缺失值表示。 data = data.replace(to_replace='?', value=np.nan) # 丢弃带有缺失值的数据（只要有一个维度有缺失）。 data = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b662ad1d09ee7ff700a7b0c1e613c99b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36a62430ca8bd782270fe14b6f23482e/" rel="bookmark">
			信息传播学习笔记（2）——SIS模型python代码实现（基于全局与基于节点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是讲解python代码实现SIS模型，共有两部分代码：
第一部分是传统的SIS模型，是获得全局感染者（I）和易感者（S）的比率。
第二部分是基于节点的SIS模型，是获得每个节点的受感染率。
对了宝贝儿们，卑微小李的公众号【野指针小李】已开通，期待与你一起探讨学术哟~摸摸大！
目录 1 传统SIS模型1.1 初始值设定1.2 微分方程1.2 微分方程调用与绘图1.3 结果展示1.4 完整代码 2. 基于节点的SIS模型2.1 微分方程2.2 另一条曲线2.3 结果展示2.4 完整代码 3 参考 1 传统SIS模型 传统的SIS模型如果不熟悉的同学，可以参考我的上一篇文章《信息传播学习笔记（1）——SIS模型原理与公式推导》。
1.1 初始值设定 本文设定的初始值如下：
nodes = np.arange(0, 5, 1) lamb = 0.5 # 传染率 mu = 0.2 # 治愈率 t_range = np.arange(0, 50, 0.1) # 时间步长 init_i = 2 # 初始感染者 即 λ = 0.5 , μ = 0.2 \lambda=0.5, \mu=0.2 λ=0.5,μ=0.2，迭代次数500次，共5个节点，2个感染者（I），3个易感者（S）。
1.2 微分方程 def sis_i(i, t): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36a62430ca8bd782270fe14b6f23482e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef7299c45cb9ef8ee489cd8748ecf40/" rel="bookmark">
			[转载] Python中str跟int的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接： Python中的类型转换
字符串str转换成int: int_value = int(str_value) int转换成字符串str: str_value = str(int_value) a=100
b='666'
#int转str类型
print('int转str类型')
print('int转str： '+str(a))
#str转int类型
print('str转int类型')
print(4+int(b))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13efed80363d38bf9bbef78cd3cd0671/" rel="bookmark">
			Qt事件：自定义事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qt的自定义事件分成两个步骤：
1、注册一个自定义事件的类型值
2、继承QEvent，继承时指定注册的类型值
下面注册一个文本改变事件。
#include &lt;QEvent&gt; #include &lt;QString&gt; extern int TextChangeEvent; class textChangeEvent : public QEvent { public: textChangeEvent(); virtual ~textChangeEvent(); void setString(QString string) { this-&gt;newString = string; } QString getString()const { return this-&gt;newString; } private: QString newString; }; int TextChangeEvent = QEvent::registerEventType();//1、注册自定义事件类型 textChangeEvent::textChangeEvent():QEvent(Type(TextChangeEvent)) //2、指定事件类型 { } textChangeEvent::~textChangeEvent() { } 非常简单的代码，自定义文本改变事件里定义了一个QString用来保存改变之后的文本。
然后来使用这个事件：
界面添加一个编辑框和按钮，当按钮按下时生成一个自定义的文本改变事件：
void Widget::on_pushButton_clicked() { QString text = ui-&gt;lineEdit-&gt;text().trimmed(); textChangeEvent * event = new textChangeEvent; event-&gt;setString(text); qApp-&gt;postEvent(this, event); } 注意事件只能定义在堆上，也不用手动释放，系统会自动释放的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13efed80363d38bf9bbef78cd3cd0671/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69fddaa4b0d4a5a50357a14c0507cbb9/" rel="bookmark">
			[社招][杭州]阿里菜鸟 P6 可帮内推，期待你的加入～
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 走过路过不要错过 ps:简历发到我邮箱lanstarhua@gmail.com，或者csdn私信我！！！
菜鸟技术团队介绍： 我们团队主要致力于全国24小时必达，全球72小时必达的使命。我们致力于提供极致的消费者物流体验，构建高效的智慧供应链服务，用技术创新驱动的社会协同平台和阿里经济体大技术团队共享技术平台资源，努力成为技术推动业务发展的典范。 团队介绍 从事核心开发工作，参与构建菜鸟的新零售末端的支付，营销平台，用户画像服务平台的建设；深入理解业务，实现业务系统的产品化和平台化，通过技术赋能和驱动业务；owner具体一个产品和系统，具备良好团队协助和沟通能力； 职位描述 Java基础扎实，熟练掌握JVM，web开发、缓存，分布式架构、消息中间件等核心技术，拥有分布式、大数据系统开发经验者优先；具备良好的复杂业务建模和抽象能力，具备产品化和平台化设计和研发经验；良好的代码习惯，良好的质量和效能意识，具备一定的创新意识；具备数据研发能力和经验的优先；良好的团队沟通和协作能力； CSDN博客：https://lxhua.blog.csdn.net/
Github地址：https://github.com/chenxingxing6
邮箱：lanstarhua@gmail.com
技能清单 IO、多线程、集合：掌握TCP/IP协议栈：熟悉Synchornized&amp;Volatile：较深了解Redis缓存服务：熟练掌握消息队列RocketMq：掌握Dubbo分布式服务框架：掌握Mysql索引、事务、锁：掌握常用垃圾回收算法，常见垃圾收集器，JVM调优：掌握Spring、SpringMvc、Mybatis：掌握Linux：掌握；有较强的线上问题解决能力Git，Maven项目管理和项目构建工具：熟练掌握自己实现过简易版SpringMvc、ORM、RPC等框架Jquery、Ajax、Node、Vue等前端知识：了解Hadoop、Hdfs、MapReduce、Hive、Hbase、Spark：自学 自我评价 积极阳光，喜欢研究一些东西，拥抱开源，坚持写博客4年具备良好的沟通能力和高度的团队合作意识，能快速融入团队爱音乐并且会弹吉他，热爱编程，喜欢挑战，能保持不断进取的精神有自己独特学习方法，定期复盘，持续完善自己的知识树，善于用分而治之思想解决问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571a03fb9ae53c986180a21214027b6f/" rel="bookmark">
			函数=delete
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数=delete 表明虽然声明了此函数但是不希望使用它，可以用在任何函数上面。
class oneClass { public: oneClass() = delete;//禁止创建默认构造函数 oneClass(const oneClass &amp;) = delete;//禁止拷贝 oneClass &amp; operator = (const oneClass &amp;) = delete;//禁止赋值 }; 如果析构函数 = delete，不能调用析构函数，这时候编译器不允许在栈内存创建对象，因为当对象生存期结束时无法调用析构函数释放对象，编译器不允许在栈内存创建不能释放的对象。这时候可以在堆内存创建对象，但不能释放对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac310bb37e6d4acbf45ae7173109dd6d/" rel="bookmark">
			LInux环境下ANTs软件安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ANTs软件安装 写在最前面的，我使用的是Ubuntu18.04进行环境的安装与配置，安装ANTs前需要检查是否已经安装CMake以及ITK，如果已经安装了，请直接跳过前两个部分。本教程参考了医学配准软件ANTs安装Tutorial+避坑指南以及官方的安装指导
CMake安装 下载安装包
wget https://cmake.org/files/v3.12/cmake-3.12.1-Linux-x86_64.sh 执行sh文件
sh cmake-3.12.1-Linux-x86_64.sh 继续输入
sudo apt-get install cmake-curses-gui 注意：如果在执行过程中，不能正确运行，那么请使用sudo重新执行命令
ITK安装 下载ITK并解压，这里我我下载的版本是InsightToolkit-5.1.1,因此在当前路径下有一个名称为InsightToolkit-5.1.1的文件夹，创建ITK文件夹并进入，之后进行构建ITK
mkdir ITK cd ITK ccmake /填写你的路径/InsightToolkit-5.1.1 键盘输入c进行configure构建将这些参数BUILD_DOXYGEN, BUILD_EXAMPLES, BUILD_SHARED_LIBS,BUILD_TESTING调节为调节OFF,重新c构建，不报错进行g生成文件
make -j 2 安装完成
ANTs安装 ANTs官方安装指南
下载最新的代码，解压到安装路径获得得到的文件夹为ANTs
git clone https://github.com/ANTsX/ANTs.git 运行CMake去构建配置 如安装ITK类似，首先创建文件antsbin并进入，通过ccmake将ANTs文件进行编译
mkdir antsbin cd antsbin ccmake /填写你的路径/ANTs 在Terminate出现新的命令之后，输入c进行配置，将参数SuperBuild_ANTS_USE_GIT_PROTOCOL，BUILD_TESTING，RUN_LONG_TESTS,RUN_SHORT_TESTS置为OFF，重新点击c，没有报错之后输入g生成
构建步骤 构建，tee是用于在命令行显示输出结果
make 2&gt;&amp;1 | tee build.log 为了加速编译，可以使用多线程，如下,使用了双线程
make -j 2 2&gt;&amp;1 | tee build.log 多线程，需要占用更多的RAM和CPU资源，如果在多线程构建时看起来很慢，报错或者完全hangs up，尝试通过单线程构建，并将在CMAKE时将RUN_LONG_TESTS关闭，或者完全关闭测试turning off testing entirely
编译成功 [100%] Built target ANTS 安装步骤 在完成编译之后，生成一个子目录ANTS-build
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac310bb37e6d4acbf45ae7173109dd6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f33bbb3d34623562d1d5fc03b6034e/" rel="bookmark">
			catkin init 或 catkin build 报错catkin：command not found 的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 安装ROS环境之后，使用 catkin_make 编译 package 可以运行，但是如果跑 catkin init 或者 catkin build 就会出现 catkin：command not found。
主要原因是 catkin 包默认情况下是没有安装的。
二、解决方法： 直接安装 python-catkin-tools。
sudo apt-get update sudo apt-get install python-catkin-tools 这样基本就OK了。
如果报错的话，可以增加一个 ROS 软件源，然后再次安装。
sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu `lsb_release -sc` main" &gt; /etc/apt/sources.list.d/ros-latest.list' wget http://packages.ros.org/ros.key -O - | sudo apt-key add - sudo apt-get update sudo apt-get install python-catkin-tools 参考链接：
[1] Installing catkin_tools – https://catkin-tools.readthedocs.io/en/latest/installing.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa0f6a12f77fa9a8c70bdb9779d3010/" rel="bookmark">
			动手实现简易Spring Ioc和AOP、Spring Bean的生命周期、循环依赖问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简易 Ioc 实现 最简单的 IOC 容器只需4步即可实现，如下：
加载 xml 配置文件，遍历其中的标签获取标签中的 id 和 class 属性，加载 class 属性对应的类，并创建 bean遍历标签中的标签，获取属性值，并将属性值填充到 bean 中将 bean 注册到 bean 容器中 下面就是实现的代码，其中包含的文件作用分别是：
SimpleIOC：IOC 的实现类，实现了上面所说的4个步骤SimpleIOCTest： IOC 的测试类Car： IOC 测试使用的 beanWheel：同上ioc.xml：配置文件 容器实现类 SimpleIOC 的代码：
/** * 模仿Spring Ioc实现的简单Ioc类 */ public class SimpleIOC { //用来实际存储bean对象 private Map&lt;String, Object&gt; beanMap = new HashMap&lt;String, Object&gt;(); public SimpleIOC(String location) throws Exception { loadBean(location); } /** * 通过name获取对象 * @param name * @return */ public Object getBean(String name) throws IllegalAccessException { Object bean = beanMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fa0f6a12f77fa9a8c70bdb9779d3010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4c5bcb014d4213a660fc182dceea1d/" rel="bookmark">
			Apriori算法是什么？适用于什么情境？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apriori适用于什么场景？ Apriori算法是常用的用于挖掘出数据关联规则的算法，它用来找出数据值中频繁出现的数据集合，找出这些集合的模式有助于我们做一些决策。
例如什么商品集合顾客会在同一次购物中购买？最著名的例子莫过于啤酒与尿布的故事。看似两个无关的商品，沃尔玛却发现它们经常被一起购买。这是为什么呢？
沃尔玛经过分析后发现，美国的家庭主妇们经常会让她们的丈夫在回家的路上顺道买一些尿布给孩子用，而这些丈夫们辛苦工作了一天也想犒劳一下自己，于是在买尿布之余也给捎带上了自己最爱的啤酒。这就是著名的啤酒与尿布的故事。
研究“啤酒与尿布”关联的方法就是购物篮分析，购物篮分析曾经是沃尔玛秘而不宣的独门武器，购物篮分析可以帮助门店的销售过程中找到具有关联关系的商品，并以此获得销售收益的增长。而Apriori就是用来挖掘数据关联规则最经典的算法。
Apriori算法是什么？ 介绍 Apriori算法之前需要先介绍几个概念。频繁项集，支持度（Support）和置信度（confidence）。
支持度（Support） 关联规则A-&gt;B的支持度support=P(AB)，指的是事件A和事件B同时发生的概率（相当于联合概率）。
同理多个事件的支持度等于，多个时间同时发生的概率。
在实际使用过程中，我们需要先设置一个支持度的阙值来进行项集的选择
置信度（confidence） 置信度confidence=P(B|A)=P(AB)/P(A),指的是发生事件A的基础上发生事件B的概率（相当与条件概率）。
举个栗子：在购物数据中，纸巾对应鸡爪的置信度为40%，支持度为1%。则意味着在购物数据中，总共有1%的用户既买鸡爪又买纸巾；同时买鸡爪的用户中有40%的用户购买纸巾。
频繁k项集 顾名思义，频繁项集表示的就是在数据集中频繁出现的项集（可以是一个，也可以是多个）。如果事件A中包含k个元素，那么称这个事件A为k项集，并且事件A满足最小支持度阈值的事件称为频繁k项集
Apriori算法思想 对于Apriori算法，我们使用支持度来作为我们判断频繁项集的标准。Apriori算法的目标是找到最大的K项频繁集。
这里有两层意思，首先，我们要找到符合支持度标准的频繁集。但是这样的频繁集可能有很多。第二层意思就是我们要找到最大个数的频繁集。
比如我们找到符合支持度的频繁集AB和ABE，那么我们会抛弃AB，只保留ABE，因为AB是2项频繁集，而ABE是3项频繁集。
那么具体的，Apriori算法是如何做到挖掘K项频繁集的呢？
Apriori算法采用了迭代的方法，先搜索出候选1项集及对应的支持度，剪枝去掉低于支持度阙值的1项集，得到频繁1项集。
然后对剩下的频繁1项集进行连接，得到频繁2项集，筛选去掉低于支持度阙值的候选2项集，得到真正的频繁2项集。
以此类推，迭代下去，直到无法找到频繁k+1项集为止，对应的频繁k项集的集合即为算法的输出结果。
下面时是使用Aprioris算法获取频繁项集的一个简单的例栗子：
Apriori性质 其实上面的算法隐含了Apriori的两个性值：
频繁项集的所有非空子集都必须也是频繁的： 如果 {beer, diaper, nuts} 是频繁的， 那{beer, diaper}在数据集中肯定也是频繁的。任何非频繁项集的超集一定也是非频繁的： 如果 {beer}是非频繁的（支持度小于阙值），那么{beer, diaper}肯定也是非频繁的。 使用性质2，可以进行剪枝，所有非频繁项的超集都不用进行测试，因为他们肯定也是分频繁的，所有在算法中去掉了所有非频繁项才进行的连接。
关联规则生成 至此我们已经找到了所有的频繁项集，接下来就是要根据频繁项集生成关联规则
对于每个频繁项集L，生成其所有的非空子集对于L的每个非空子集x, 计算其置信度Confidence（x）≥ minConfidence，那么“ x -&gt; (L-x)”成立。
由于规则由频繁项集产生，每个规则都自动满足最小支持度。 下面给出一个简单的例子：
Apriori算法的瓶颈 Apriori算法简单，易于实现。但是它也有自己的缺点，数据集很大的时会出现下面两个问题。
需要多次扫描数据集可能会产生庞大的候选集 针对Apriori算法的性能瓶颈问题，2000年Jiawei Han等人提出了基于FP树生成频繁项集的FP-growth算法。
该算法只进行2次数据库扫描且它不使用侯选集，直接压缩数据库成一个频繁模式树，最后通过这棵树生成关联规则。
研究表明它比Apriori算法大约快一个数量级。
下次有机会的话，我们再对FP-growth算法进行介绍。
参考文献 [1] 数据挖掘十大算法–Apriori算法. https://blog.csdn.net/u011067360/article/details/24810415
[2] Apriori算法原理总结. https://www.cnblogs.com/pinard/p/6293298.html
[3] Apriori算法详解. https://www.jianshu.com/p/ff82fb98855d
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e45acd4a9f657dbccd19c2f81953841/" rel="bookmark">
			style 字体加粗_第9篇 Qt Quick入门教程之基础（九）文本显示和字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 文本显示是界面开发必不可少的内容，在Qt Quick模块中提供了 Text 项目来进行文本的显示，其中可以使用 font 属性组对文本字体进行设置。这一篇我们来看看它们的具体使用。
使用字体 就像前面教程中提到过的，在文本中可以使用 font 属性组来设置字体，常用的属性如下：
font.bold：是否加粗，取值为true或false
font.capitalization：大写策略，取值为
Font.MixedCase不改变大小写(默认值)；
Font.AllUppercase全部大写；
Font.AllLowercase全部小写；
Font.SmallCaps小型大写字母(即小写字母变为大写但不改变字体原始的大小)；
Font.Capitalize：首字母大写
font.family：字体族，取值为字体族的名字(区分大小写)
font.italic：是否斜体，取值为true或false
font.letterSpacing：字符间距，正值加大间距，负值减小间距
font.pixelSize：字号大小，取值为整数(单位为像素，依赖于设备)
font.pointSize：字号大小，取值为大于0的值(是设备无关的)
font.strikeout：是否有删除线，取值为true或false
font.underline：是否有下划线，取值为true或false
font.weight：字体重量，取值为Font.Thin、Font.Light、Font.ExtraLight、Font.Normal(默认)、Font.Medium、Font.DemiBold、Font.Bold、Font.ExtraBold 和 Font.Black
font.wordSpacing：单词间距，正值加大间距，负值减小间距
我们可以直接使用点表示法来使用一个属性，也可以使用组表示法来一次指定多个属性，建议使用组表示法，这样代码的可读性更好。下面来看一个示例：
Text {
id: text1
anchors.centerIn: parent
text: "hello qt! Hello World!"
}
Text {
id: text2
anchors.top: text1.bottom
anchors.topMargin: 10
anchors.horizontalCenter: text1.horizontalCenter
text: "hello qt! Hello World!"
font.weight: Font.ExtraBold
font.pointSize: 20
font.letterSpacing: 3
font.wordSpacing: 6
font {
capitalization: Font.AllLowercase
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e45acd4a9f657dbccd19c2f81953841/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a205fcf36f65c8d6e85ff6e7dac8a7/" rel="bookmark">
			在sublime中配置virtualenv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		project-&gt;add folder to project-&gt;&lt;打开自己虚拟环境的文件夹地址&gt;
ctrl shift P-&gt;virtualenv activate,选择对应的虚拟环境
激活成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/428cedea75958417ddda8df74c198fea/" rel="bookmark">
			python画笛卡尔心形线_参加数学考试——python画极坐标，笛卡尔心形，玫瑰线，阿基米德螺线，伯努利双旋钮（加深对图像的理解）,考研,Python,绘制,图画,心形线,双纽线...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《张宇基础30讲》第一讲的几张极坐标图象，这里用Python来实现一下，加深理解，并学习绘制极坐标图像。
1.笛卡尔心形线
公式：
import numpy as np
import matplotlib.pyplot as plt
# 心形线
a = 1
theta = np.linspace(0, 2*np.pi, 1000)
r = a*(1 - np.cos(theta))
plt.axes(polar = True)
plt.plot(theta, r)
plt.show()
np.linspace来选取0到2π的1000个点，计算r，polar=True 为极坐标图
扩展调试
我们改变a和cos的正负，怎么样，发现规律了吗？
a负 cos 负
a正 cos 正
我们再来将cos替换为sin
r = a*(1 - np.sin(theta))
2.玫瑰线
# 玫瑰线
a = 1
theta = np.linspace(0, 2*np.pi, 1000)
r = a* np.sin(3*theta)
plt.axes(polar = True)
plt.plot(theta, r)
plt.show()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/428cedea75958417ddda8df74c198fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30922caa8676a4a458ecff382c857c06/" rel="bookmark">
			LEETCODE4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LEETCODE4
题目描述 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。
进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？
示例 1：
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
示例 3：
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
示例 4：
输入：nums1 = [], nums2 = [1]
输出：1.00000
示例 5：
输入：nums1 = [2], nums2 = []
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30922caa8676a4a458ecff382c857c06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e409c57e3e4ca5b3e520b0236815c278/" rel="bookmark">
			VS Code Remote SSH配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载vscode remote ssh插件
2.安装ssh并生成私钥
windows可通过git来安装ssh
从git官网安装git客户端，一路下一步之后，鼠标右键，点开git bash
配置你的git用户名和邮箱
git config --global user.name “yuzhenrong“
git config --global user.email “zhenrongyu9@gmail.com”
生成私钥
ssh-keygen -t rsa -C “zhenrongyu9@gmail.com”
连续三次enter键之后，操作成功，会提示秘钥生成位置，即ssh目录，如下
把密钥同步到服务器
scp C:\Users\yu137.ssh\id_rsa.pub yuzhenrong@192.168.88.131:~/tmp.pub
ssh yuzhenrong@192.168.88.131 “mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; cat ~/tmp.pub &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys &amp;&amp; rm -f ~/tmp.pub”
3.配置remote ssh
新建config文件，并在文件里面添加用户名和远程服务器ip地址
其中
Host zhenrong-server：远程主机命名，随便起，爱咋咋写
HostName 192.168.88.131：远程主机的ip地址
User yuzhenrong：远程主机的用户名
ForwardAgent yes：远程多主机转发，选yes
Port 22:远程主机port口
IdentityFile C:\Users\yu137.ssh\id_rsa：私钥路径
再把config配置到remote-ssh中即可
紧接着在vscode的远程服务那里就可以看到zhenrong-server这个远程服务器了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e409c57e3e4ca5b3e520b0236815c278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a67222c66c6dd92f2d7abed1229bafd5/" rel="bookmark">
			大恒相机开发实践(2)——触发采图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言正文开启采图模式开启实时采图功能点击触发按钮 总结 前言 这部分完成的功能是触发采图，所谓触发采图，基本的过程是在先开启连续采图，然后，在某个触发信号到来的时候，读取其中的某一帧的信号，显示在主界面上这个触发可以是软触发，也可以是硬件触发信号，看具体的需求，下面开讲大恒相机的触发采图。
正文 开启采图模式 首先，我们要让程序先开启采图模式，也就是处于回调抓图的模式，才能让相机在触发信号到来的信号进行抓图。我们这里使用的函数是GrabThreadStart：
GrabThreadStart
qint32 MDeviceDahengG3UC::GrabThreadStart() { qint32 ret = RETURN_FAIL; #ifdef WIN32_DAHENG_GEV if(m_bLoaded) { CGXFeatureControlPointer m_objFeatureControlPtr2 = m_objDevicePtr-&gt;GetRemoteFeatureControl(); if((!m_objDevicePtr.IsNull())&amp;&amp;(!m_objFeatureControlPtr2.IsNull())) { if(!m_objStreamPtr.IsNull()) { m_objStreamPtr-&gt;RegisterCaptureCallback(m_pCaptureEventHandler,this);// m_objStreamPtr-&gt;StartGrab();//startGrab } else qDebug()&lt;&lt;"MDeviceDahengG3UC::GrabThreadStart m_objStreamPtr is null"; m_objFeatureControlPtr2-&gt;GetCommandFeature("AcquisitionStart")-&gt;Execute(); ret = RETURN_OK; } else { if(m_objDevicePtr.IsNull()) qDebug()&lt;&lt;"MDeviceDahengG3UC::GrabThreadStart m_objDevicePtr is null"; } } #endif return ret; } 下面进行解析：
这里面最重要的肯定是进行回调注册了，也就是这个函数： m_objStreamPtr-&gt;RegisterCaptureCallback(m_pCaptureEventHandler,this); 这个函数在大恒相机的文档上有，我这里稍微解释一下，就是把这个this的指针传给m_pCaptureEventHandler这个对象，它这个注册函数的定义是这个：
//---------------------------------------------------------------------------------- virtual void RegisterCaptureCallback(ICaptureEventHandler* pEventHandler, void *pUserParam) = 0; 相当于，在这里注册了pEventHandler这个对象，并把this指针往下传，在你按下触发按钮的时候，就会执行这个对象里面的函数，也就是ICaptureEventHandler，我就顺势在这里给出这个函数的解析：
//回调处理类 class CSampleCaptureEventHandler : public ICaptureEventHandler { public: void DoOnImageCaptured(CImageDataPointer&amp; objImageDataPointer, void* pUserParam) { MDeviceDahengG3UC* pDev = static_cast&lt;MDeviceDahengG3UC*&gt;(pUserParam); pDev-&gt;triggerEvent(objImageDataPointer); } }; 注意，这个类是大恒相机给的，不是我自己创造的，所以，看文档就显得至关重要了，包括这个RegisterCaptureCallback这个函数也是文档里有的，我这里只是给你一个这种问题的解决方向。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a67222c66c6dd92f2d7abed1229bafd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4a3d27274d1c1c487eeb0ebb54a6eb/" rel="bookmark">
			tkinter checkbutton_Tkinter简明教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文我们将学习如何使用Tkinter包编写一些图形用户界面程序。Tkinter是Python的一个标准包，因此我们并不需要安装它。我们将从创建一个窗口开始，然后我们在其之上加入一些小组件，比如按钮，复选框等，并使用它们的一些属性。话不多说，让我们开始吧！
创建一个窗口 首先，我们导入Tkinter包，然后创建一个窗口，最后给这个窗口设置标题。
from tkinter import * window = Tk() window.title("First Window") window.mainloop() 结果如下：
最后一行我们调用了mainloop函数，这个函数将让窗口等待用户与之交互，直到我们关闭它。如果忘记调用mainloop函数的话，将不会向用户显示任何内容（没有窗口）。
添加一个标签组件 为了给之前的例子增加一个标签组件，我们可以使用Label类：
lbl = Label(window, text="Hello") 我们可以通过grid函数设置其在窗口的位置：
lbl.grid(column=0, row=0) 完整代码如下所示：
from tkinter import * window = Tk() window.title("First Window") lbl = Label(window, text="Hello") lbl.grid(column=0, row=0) window.mainloop() 结果如下：
值得注意的是lbl没有调用grid函数的话是不会显示的。
设置标签字体大小 我们可以使用font参数设置标签字体大小：
lbl = Label(window, text="Hello", font=("Arial Bold", 50)) font参数不光可以在标签组件中用，其他组件也可以使用呢！
可是，现在窗口貌似太小了，连窗口的标题都看不全，如何设置窗口大小呢？
设置窗口大小 我们可以用geometry函数来设置窗口大小：
window.geometry("350x200") 以上代码将会把窗口设置成350个像素宽，200个像素高。
添加一个按钮组件 让我们给窗口增加一个按钮组件，它的创建和添加方式和标签组件差不多：
btn = Button(window, text="Click Me") btn.grid(column=1, row=0) 完整代码如下所示：
from tkinter import * window = Tk() window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d4a3d27274d1c1c487eeb0ebb54a6eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d72688851cfb8b15be927c13c9a4d6de/" rel="bookmark">
			Bootstrap的class属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Bootstrap的class属性
1，role
增强语义性，用于自定义组件，可增强组件的访问性，可用性和可交互性
2，文字
属性名含义font-size字体大小line-height行高font-family默认字体h1-h6标题大小Disolay控制标题样式small创建字号更小颜色更浅的文本mark为黄色背景及有一定的内边距（高亮文本）abbr显示在文本底部的一条虚线边框(似标记文本）font-weight-bold更细文本font-weight-light控制标题样式font-weight-normal普通文本font-italic斜体文本lead让段落更突出text-left左对齐text-center居中text-right右对齐text-justify设定文本对齐,段落中超出屏幕部分文字自动换行text-nowrap超出屏幕不换行text-justify文本对齐，超出屏幕部分自动换行text-nowrap超出屏幕不换行text-lowercase文本小写text-uppercase文本大写text-capitalize单词首字母大写 3，文本颜色
属性名含义text-muted柔和文本（很淡的灰）text-primary重要文本（蓝色）text-success执行成功的文本（绿色）text-info提示信息（很淡的蓝）text-warning警告文本（黄色）text-danger危险文本（红色）text-dark深灰色文字text-light浅灰色文本text-white白色文本 4，背景颜色
属性名含义bg-primary text-white重要背景颜色（蓝色）bg-success text-white成功背景颜色（绿色）bg-info text-white信息提示背景颜色（青色）bg-warning text-white警告背景颜色（黄色）bg-danger text-white危险背景（红色）bg-dark text-white深灰色bg-light text-dark浅灰色 5，表格
属性名含义table设置基础表格样式table-striped条纹表格table-bordered带边框的表格table-hover鼠标悬停状态表格（鼠标在哪个哪个高亮）table-responsive响应式表格，当屏幕较小的时候会出现滚动条 注：若要设置表格颜色基本和设置文本颜色一样：eg:table-primary
6，图像形状
属性名含义rounded圆角图片rounded-circle椭圆图片img-thumbnail缩略图（有边框）img-responsive响应式图片 7，图片对齐方式
属性名含义float-right右对齐float-left左对齐center-block居中 8，导航
属性名含义nav导航类nav-item导航项nav-link导航链接 9，其他
属性名含义sr-only隐藏某个标签 10，媒体特性的属性
属性名含义orientation设置是是横屏或者竖屏width渲染界面的宽度device-width设置屏幕的输出宽度 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74704bda31e0049bc7aa82333b26b591/" rel="bookmark">
			golang byte转string_学习笔记-GRPC简单实例(golang)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了golang版GRPC实例，本实例主要包含三部分，客户端代码，服务端代码，协议文件代码。(GRPC详见学习笔记-GRPC简单理解)
实例功能说明 本例子是一个ToUpper程序，接收客户端请求包含一个传入字符串参数，服务端返回大写字符串。
定义protoc文件 定义了一个ToUpper服务，定义了两个消息UpperRequest和UpperReply分别用来接收消息和回复消息。(protobuf详见学习笔记-Protobuf简单理解)
syntax = "proto3";package proto;// The service definition.service ToUpper{// Sends a greetingrpc Upper (UpperRequest) returns (UpperReply) {}}// The request messagemessage UpperRequest {string name = 1;}// The response messagemessage UpperReply {string message = 1;} 更据协议文件生成的go代码
// Code generated by protoc-gen-go. DO NOT EDIT.// source: toupper.protopackage protoimport (context "context"fmt "fmt"proto "github.com/golang/protobuf/proto"grpc "google.golang.org/grpc"codes "google.golang.org/grpc/codes"status "google.golang.org/grpc/status"math "math")// Reference imports to suppress errors if they are not otherwise used.var _ = proto.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74704bda31e0049bc7aa82333b26b591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f9ba30fa33908c1d8c225e5765b23b/" rel="bookmark">
			c&#43;&#43; map 获取key列表_好未来Golang源码系列一：Map实现原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享老师：学而思网校 郭雨田
一、map的结构与设计原理 golang中map是一个kv对集合。底层使用hash table，用链表来解决冲突 ，出现冲突时，不是每一个key都申请一个结构通过链表串起来，而是以bmap为最小粒度挂载，一个bmap可以放8个kv。在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。每个map的底层结构是hmap，是有若干个结构为bmap的bucket组成的数组。每个bucket底层都采用链表结构。接下来，我们来详细看下map的结构： // A header for a Go map.type hmap struct { count int // 元素个数 flags uint8 B uint8 // 扩容常量相关字段B是buckets数组的长度的对数 2^B noverflow uint16 // 溢出的bucket个数 hash0 uint32 // hash seed buckets unsafe.Pointer // buckets 数组指针 oldbuckets unsafe.Pointer // 结构扩容的时候用于赋值的buckets数组 nevacuate uintptr // 搬迁进度 extra *mapextra // 用于扩容的指针}type mapextra struct { overflow *[]*bmap oldoverflow *[]*bmap nextOverflow *bmap}// A bucket for a Go map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f9ba30fa33908c1d8c225e5765b23b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5063732110ac3af2aea77e12672b7e4e/" rel="bookmark">
			前端校验还是后端校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端校验的 唯一性验证，验证码，敏感词，出错概率高的要做异步校验。
后端校验可以防止接口被私自调用导致破坏数据库结构；避免有人模拟浏览器行为直接给服务器发请求。
前端校验的 必填项、（邮箱、电话号、地址）格式、密码强度检测。
前端校验便于用户纠正（快速反馈），并且减少服务器压力、节省流量（减少无意义的请求），主要对用户友好。
比如手机号码，邮箱号不合法，或者密码强度太弱，在前端校验可以不等后端返回，直接提醒用户不合法，让用户及时知晓并更改，避免不必要的提交，再等待服务器返回错误信息。
接口的校验 我的理解主要分为三种
开放式接口：允许任何人调用得基础信息
验证接口：你们登录了账号密码 通过账号密码访问的接口信息
Token加密性：携带密钥访问
2021年3月20号 又经过一段时间的学习 刚好现在我在做一个社团管理的项目 发现 较验的重要性真的超级nice 以为为了 提高数据的简单度 （想法是美好的 在DB就没有添加外键进行关联 数据的添加会以为 一些恶意行为 变得 – 不知道这是不是真正的有用 但是进行一系列的添加限制后 如果不是太恶意已经没法添加大量无用信息了 哭 ）
上面的话只是感慨 没有啥意思 大哥看了别说
2021年4月20号 时间过去了 一个月 在4月初的时候因为 眼睛（干眼症 ：我泪膜破裂才3秒征正常14秒）的原因 暂停打码超过了两个周 因为 这是 大家阅读量最大的一篇文章 希望看到的朋友 一定注意劳逸结合 不能一味的肝 祝大家都有个好身体 我们还年轻
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b2fb38ee32d41f119a8b2d45e0bc20c/" rel="bookmark">
			python爬虫爬取天气预报信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标天气预报网站：http://www.weather.com.cn/weather/101210701.shtml
需要用到的库有requests（用来发送请求和接收url）BeautifulSoup（用来解析html文本）
爬虫的基本思路：
1.首先发送请求并返回requests（最好模拟谷歌浏览器的头部访问（即下面的headers），并且设置一个每次访问的间隔时间，这样就不容易触发网站的反爬机制（说白了就是模拟人类的访问行为））
2.获得requests对象后使用BeautifulSoup (美丽的汤？？也不知道为啥要起这个名)来解析requests对象，注意这里要用request.text，就取文本，解析后的soup打印出来其实就是整个html的字符串内容，但是类型并不是string，应该是bs4类型，这就是这个美丽的汤的魅力所在，它可以直接在python用类似于ccs选择器那样的方式一层一层的寻找我们要的div内容。
3.搜寻soup对象中我们需要的内容，就是一层一层div找到对应的属性，然后拿取我们需要的内容。（看html或者把之前的soup对象打印出来）
4.打印或保存文件
所有代码 import requests from bs4 import BeautifulSoup headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36'} url= 'http://www.weather.com.cn/weather/101210701.shtml' res = requests.get(url, headers=headers,timeout=20) res.encoding = 'utf-8' #print(res.status_code) soup = BeautifulSoup(res.text,'html.parser') tem_list = soup.find_all('p',class_='tem') #存温度 #print(tem_list) day = soup.find('ul',class_='t clearfix') #存日期 day_list = day.find_all('h1') #print(day_list) wealist = soup.find_all('p',class_='wea') #存天气 day_pre = {} for i in range(7): try: temHigh = tem_list[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b2fb38ee32d41f119a8b2d45e0bc20c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/960cacd06424c5c2fdc36f3ba7b1ddfc/" rel="bookmark">
			LVS负载均衡之FullNat模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LVS负载均衡之FullNat模式 server1内核编译编译keepalived编译ipvsadm 小结 准备工作
虚拟机server1配置两块网卡
两台环境干净的虚拟机作后端服务器
扩展
rpmbuild-bp只作准备 （解压与打补丁）-bc准备并编译-bi编译并安装-bl检验文件是否齐全-ba编译后做成*.rpm和src.rpm，建立源码和二进制包-bb编译后做成*.rpm，只建立二进制包-bs只做成*.src.rpm ，只建立源码包 –buildroot=DIRECTORY确定以root目录建立包–clean完成打包后清除BUILD下的文件目录–nobuild不进行BUILD的阶段–nodeps不检查建立包时的关联文件–rmsource完成打包后清除sources–rmspec完成打包后清除specfile–short-circuit跳过–target=CPU-VENDOR-OS确定包的最终使用平台-D, --define=‘MACRO EXPR’预定义-E, --eval=‘EXPR’显示大量EXPR扩展信息–macros=&lt;FILE:…&gt;读&lt;FILE:…&gt;文件代替默认文件–nodigest不检查包的说明信息–nosignature不检查包的签名信息–rcfile=&lt;FILE:…&gt;读&lt;FILE:…&gt;文件代替默认文件-r, --root=ROOT使ROOT为最高级别的路径–querytags显示已知的有疑问的地方–showrc显示最终的配置信息–quiet提供少量的信息-v, --verbose提供大量的详细的信息–version显示rpm包的版本 RPM的工作方式：
1，打开rpm数据库 2，从.软件包中提取h#,并且检查h#的需要是否被满足？(这里的依赖关系，有的是软件包自己给出的，有的是你系统自带，当然还可能有你没有的。) 是：转第4步 不是：转第3步 3，显示失败的依赖关系 4，安装软件，解压缩软件包，并且放到合适的位置，这里应该是有一定的规则。 5，关闭rpm数据库 显然，我这个软件包不满足依赖关系，如果强制用－force安装的话可能出错误。 如果你失败了，那就少什么补什么 介绍一下可以用来搞定安装的全部工具。
gcc-这个是编译器make-包含从makefiles产生二进制文件的make命令，当然还有其他的一些功能。glibc-重要的共享库，c库和基本的数学库。没有这个连系统都没有办法运行。glibc-devel-包含了创建可执行文件所需要的标准头文件。binutils-包含编译程序需要的使用工具，主要是汇编和链接程序。kernel-source-包含内核源代码libc-包含libc5,而上面我们提到的glibc是linc6 filename－4.2.3.i386.rpm这个表示可以用rpm来安装，我们最喜欢的方式。filename－4.2.3.tar.gz这个表示用gz压缩，用tar归档，至于是什么，那就不知道了filename－4.2.3.src.tar.gz这个表示用gz压缩，用tar归档，内容是源代码filename－4.2.3.bin.SPARC.tar.gz这个是表示用gz压缩，用tar归档，可以在SPARC工作站上运行，的2进制代码。filename－4.2.3.bin.ELF.static.tar.gz这个表示用gz压缩，用tar归档，由静态连接的, FLF的可执行文件组成的2进制文件。4.2.3 表示第4版，第2个补丁，第3次修改。 rpm.有这个后缀表示是fedora使用的2进制文件，这个不是说里面的内容2进制的，而是说他可以被fedora的软件管理器使用。可以用归档文件管理器把他打开。tar.这个是用tar归档，使用tar 命令打开gz.和z.这个是说用gzip压缩的，用gzip命令打开tgz.这个扩展名和以上的结合，容易搞定bz2.用bzip2压缩的，可以用bip2命令打开taz.和tz.这个表示用tar压缩，也用tar命令打开lsm.这个通常是介绍归档内容的文本，可以和软件包一起下载。deb.这个同rpm但是用于Debian server1 内核编译 下载包：
kernel-2.6.32-220.23.1.el6.src.rpm asciidoc-8.4.5-4.1.el6.noarch.rpm newt-devel-0.52.11-3.el6.x86_64.rpm slang-devel-2.2.1-1.el6.x86_64.rpm Lvs-fullnat-synproxy.tar.gz Lvs-fullnat-synproxy.tar.gz 安装kernel出现rembuild
rpm -ivh kernel-2.6.32-220.23.1.e16.src.rp error: Failed build dependencies: redhat-rpm-config is needed by kernel-2.6.32-220.23.1.el6.x86_64 patchutils is needed by kernel-2.6.32-220.23.1.el6.x86_64 xmlto is needed by kernel-2.6.32-220.23.1.el6.x86_64 asciidoc is needed by kernel-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/960cacd06424c5c2fdc36f3ba7b1ddfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eacc05622d8d8cf8824ed743d7bf69e8/" rel="bookmark">
			springboot 上传图片到指定位置 并保存到数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
springboot 上传图片到指定位置 并保存到数据库 **
自己在开发项目的时候，卡在了上传图片的地方，为了以后可以轻松开发特地记录，也希望看见次文章的人能够少走弯路
废话不多说，上代码
@PostMapping("/upfile/image") @ResponseBody public ResultDTO updateSource(@RequestParam("file") MultipartFile file){ AbnormalOrder abnormalOrder=new AbnormalOrder(); // abnormalOrder.setReason(reason); //给予文件新的随机名字 String newname=null; String oldname= file.getOriginalFilename(); newname= UUID.randomUUID().toString()+ oldname.substring(oldname.lastIndexOf(".")); //创建存放路径的文件 File upload = new File("G:/back-server/images/upload/"); if(!upload.exists()){ upload.mkdirs(); } try { //将图片存放到指定的文件里面 File resultpath= new File(upload+newname); file.transferTo(resultpath); String finalpath=resultpath.toString(); abnormalOrder.setImage(finalpath); } catch (IOException e) { e.printStackTrace(); } ResultDTO resultDTO=new ResultDTO(ResultCodeEnum.IMPORTSUCESS); resultDTO.setData(abnormalOrder); return resultDTO; } 另外
在测试的时候
我只写了上传图片的
希望可以帮助大家!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34b34972e2dc99524f9e14f2897c01d/" rel="bookmark">
			c&#43;&#43;中两个key确定一个value_找到一个合适Redis数据结构，最起码可以减少80%的内存占用...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
redis作为目前最流行的nosql缓存数据库，凭借其优异的性能、丰富的数据结构已成为大部分场景下首选的缓存工具。
由于redis是一个纯内存的数据库，在存放大量数据时，内存的占用将会非常可观。那么在一些场景下，通过选用合适数据结构来存储，可以大幅减少内存的占用，甚至于可以减少80%-99%的内存占用。
利用zipList来替代大量的Key-Value 先来看一下场景，在Dsp广告系统、海量用户系统经常会碰到这样的需求，要求根据用户的某个唯一标识迅速查到该用户id。譬如根据mac地址或uuid或手机号的md5，去查询到该用户的id。
特点是数据量很大、千万或亿级别，key是比较长的字符串，如32位的md5或者uuid这种。
如果不加以处理，直接以key-value形式进行存储，我们可以简单测试一下，往redis里插入1千万条数据，1550000000 - 1559999999，形式就是key(md5(1550000000))→ value(1550000000)这种。
然后在Redis内用命令info memory看一下内存占用。
可以看到，这1千万条数据，占用了redis共计1.17G的内存。当数据量变成1个亿时，实测大约占用8个G。
同样的一批数据，我们换一种存储方式，先来看结果：
在我们利用zipList后，内存占用为123M，大约减少了85%的空间占用，这是怎么做到的呢？
redis的底层存储来剖析。 redis数据结构和编码方式 redis如何存储字符串 string是redis里最常用的数据结构，redis的默认字符串和C语言的字符串不同，它是自己构建了一种名为“简单动态字符串SDS”的抽象类型。
具体到string的底层存储，redis共用了三种方式，分别是int、embstr和raw。
譬如set k1 abc和set k2 123就会分别用embstr、int。当value的长度大于44(或39，不同版本不一样)个字节时，会采用raw。
int是一种定长的结构，占8个字节(注意，相当于java里的long)，只能用来存储长整形。
embstr是动态扩容的，每次扩容1倍，超过1M时，每次只扩容1M。
raw用来存储大于44个字节的字符串。
具体到我们的案例中，key是32个字节的字符串(embstr)，value是一个长整形(int)，所以如果能将32位的md5变成int，那么在key的存储上就可以直接减少3/4的内存占用。
这是第一个优化点。
redis如何存储Hash 从1.1的图上我们可以看到Hash数据结构，在编码方式上有两种，1是hashTable，2是zipList。
hashTable大家很熟悉，和java里的hashMap很像，都是数组+链表的方式。java里hashmap为了减少hash冲突，设置了负载因子为0.75。同样，redis的hash也有类似的扩容负载因子。细节不提，只需要留个印象，用hashTable编码的话，则会花费至少大于存储的数据25%的空间才能存下这些数据。它大概长这样：
zipList，压缩链表，它大概长这样：
可以看到，zipList最大的特点就是，它根本不是hash结构，而是一个比较长的字符串，将key-value都按顺序依次摆放到一个长长的字符串里来存储。如果要找某个key的话，就直接遍历整个长字符串就好了。
所以很明显，zipList要比hashTable占用少的多的空间。但是会耗费更多的cpu来进行查询。
那么何时用hashTable、zipList呢？在redis.conf文件中可以找到：
就是当这个hash结构的内层field-value数量不超过512，并且value的字节数不超过64时，就使用zipList。
通过实测，value数量在512时，性能和单纯的hashTable几乎无差别，在value数量不超过1024时，性能仅有极小的降低，很多时候可以忽略掉。
而内存占用，zipList可比hashTable降低了极多。
这是第二个优化点。
用zipList来代替key-value 通过上面的知识，我们得出了两个结论。用int作为key，会比string省很多空间。用hash中的zipList，会比key-value省巨大的空间。
那么我们就来改造一下当初的1千万个key-value。
第一步：
我们要将1千万个键值对，放到N个bucket中，每个bucket是一个redis的hash数据结构，并且要让每个bucket内不超过默认的512个元素(如果改了配置文件，如1024，则不能超过修改后的值)，以避免hash将编码方式从zipList变成hashTable。
1千万 / 512 = 19531。由于将来要将所有的key进行哈希算法，来尽量均摊到所有bucket里，但由于哈希函数的不确定性，未必能完全平均分配。所以我们要预留一些空间，譬如我分配25000个bucket，或30000个bucket。
第二步：
选用哈希算法，决定将key放到哪个bucket。这里我们采用高效而且均衡的知名算法crc32，该哈希算法可以将一个字符串变成一个long型的数字，通过获取这个md5型的key的crc32后，再对bucket的数量进行取余，就可以确定该key要被放到哪个bucket中。
第三步：
通过第二步，我们确定了key即将存放在的redis里hash结构的外层key，对于内层field，我们就选用另一个hash算法，以避免两个完全不同的值，通过crc32(key) % COUNT后，发生field再次相同，产生hash冲突导致值被覆盖的情况。内层field我们选用bkdr哈希算法(或直接选用Java的hashCode)，该算法也会得到一个long整形的数字。value的存储保持不变。
第四步：
装入数据。原来的数据结构是key-value，0eac261f1c2d21e0bfdbd567bb270a68 → 1550000000。
现在的数据结构是hash，key为14523，field是1927144074，value是1550000000。
通过实测，将1千万数据存入25000个bucket后，整体hash比较均衡，每个bucket下大概有300多个field-value键值对。理论上只要不发生两次hash算法后，均产生相同的值，那么就可以完全依靠key-field来找到原始的value。这一点可以通过计算总量进行确认。实际上，在bucket数量较多时，且每个bucket下，value数量不是很多，发生连续碰撞概率极低，实测在存储50亿个手机号情况下，未发生明显碰撞。
测试查询速度：
在存储完这1千万个数据后，我们进行了查询测试，采用key-value型和hash型，分别查询100万条数据，看一下对查询速度的影响。
key-value耗时：10653、10790、11318、9900、11270、11029毫秒
hash-field耗时：12042、11349、11126、11355、11168毫秒。
可以看到，整体上采用hash存储后，查询100万条耗时，也仅仅增加了500毫秒不到。对性能的影响极其微小。但内存占用从1.1G变成了120M，带来了接近90%的内存节省。
总结 大量的key-value，占用过多的key，redis里为了处理hash碰撞，需要占用更多的空间来存储这些key-value数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34b34972e2dc99524f9e14f2897c01d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16ce32fd27a91eb2f4200419f44372db/" rel="bookmark">
			使用函数求最大公约数 pta_13个数学函数应用技巧解读，易学易懂，远离数学计算困扰...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Excel中的函数种类很多，其中有一类为数学函数，如果能够熟练掌握，将会远离数学计算的困扰，提高工作效率。
一、Excel数学函数：Sign。
功能：确定数字的符号，如果为正数、则返回1；如果为0，则返回0；如果为负数，则返回-1。
语法：=Sign(数值或引用)。
目的：标识商品的销售完成情况。
方法：
在目标单元格中输入公式：=SIGN(D3-C3)。
解读：
除了标识商品的销售完成情况外，还可以标识商品的盈亏等情况，可以灵活应用哦！
二、Excel数学函数：Abs。
功能：返回给定数值的绝对值。
语法结构：=Abs(数值或引用)。
目的：计算两地的温差。
方法：
在目标单元格中输入公式：=ABS(D3-C3)。
解读：
Abs函数对于正数和0返回本身，对于负数返回相反数，即去掉符号后的值。
三、Excel数学函数：Sum系列。
（一）Sum普通求和。
目的：计算总销量。
方法：
在目标单元格中输入公式：=SUM(C3:C9)。
解读：
Sum函数除了普通的单元格或单个区域的求和外，还可以是多个区域的求和，即语法结构可以是：=Sum(数据范围1,数据范围2,数据范围3……数据范围N)。
（二）Sumif单条件求和。
功能：对符合条件的值进行求和运算。
语法结构：=Sumif(条件范围,条件,[求和范围])，当【条件范围】和【求和范围】相同时，【求和范围】可以省略。
目的：计算销量大于300000的销量总额。
方法：
在目标单元格中输入公式：=SUMIF(F3:F9,"&gt;300000")。
解读：
1、F3:F9为条件范围，条件为&gt;300000,由于条件范围和求和范围相同，所以省略了求和范围F3:F9。
2、对于上述需求，还可以用Sum函数来完成，你知道怎么做吗？欢迎在留言区留言讨论哦！答对有奖励哦！
（三）多条件求和Sumifs。
功能：对符合多个条件的值进行求和运算。
语法结构：=Sumifs(求和范围,条件1范围,条件1,条件2范围,条件2……条件N范围,条件N)。
目的：对商品销量大于“40”，销量额大于300000的销售额进行汇总。
方法：
在目标单元格中输入公式：=SUMIFS(F3:F9,C3:C9,"&gt;40",F3:F9,"&gt;300000")。
解读：
公式中的第一个F3:F9为求和范围，而第二个F3:F9为条件范围，所以要根据具体情况确定参数的作用。
四、Excel数据函数：Product。
功能：计算参数之积。
语法结构：=Product(数值1或引用1,数值2或引用2,……数值N或引用N)。
目的：计算商品的销售额。
方法：
在目标单元格中输入公式：=PRODUCT(C3,D3)。
解读：
1、公式=PRODUCT(C3,D3)的计算过程为C3*D3，如果有多个参数则为每个参数相乘的积。
2、普通的计算方法为=C3*D3，为了使数据更具可读性，建议使用Product函数来做求积运算。
五、Excel数学函数：Sqrt。
功能：计算正平方根。
语法结构：=Sqrt(数值或引用)。
目的：计算对应正方形的边长。
方法：
在目标单元格中输入公式：=SQRT(C3)。
解读：
Sqrt函数的参数必须为正数或可转换为数值的数据。
六、Excel数学函数：Mod。
功能：计算两个数相除后的余数。
语法结构：=Mod(被除数,除数)。
目的：计算余数。
方法：
在目标单元格中输入公式：=MOD(B3,C3)。
解读：
Mod函数的作用为计算余数，而不是商。
七、Excel数学函数：Quotient。
功能：对商向下取整。
语法：=Quotient(被除数,除数)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16ce32fd27a91eb2f4200419f44372db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238f006264460daefe86513a41d053a0/" rel="bookmark">
			python猜字游戏猜三次_python3学习猜字游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近正在学习一门新的编程语言python3，用于自动化测试。python3从设计之初就已经是一门面向对象的语言，正因为如此，在python3中创建一个类和对象是很容易的。
本篇我会已实例为主，通过一个猜字的游戏来开篇。
前提说明：
默认情况下，python3是的文件用UTF-8进行编码的，当然你也可以为文件指定编码方式：
注释是使用#进行单行注释的，多行注释可以用多个#号，还有’’和’’’’：。
变量没有类型，赋值后才会生成变量对象的类型
程序实现：
#导入random对象
import random
#控制台输出字符串
print("猜字游戏");
actualData=random.randint(1,10) # 生成一个1-10随机数
state= True# 定义是否猜测成功的状态标识
count= 0 # 表示用户猜错的次数
actuaCount = 3 # 表示用户猜错的次数
# while循环，使猜字游戏可以持续进行
while state:
# 接收用户键盘输入的数据
x = input("请猜测数字：")
guess = int(x) # 将输入的数据转换成int类型的值
# 如果用户输入的数据不是系统随机生成的数据，则表示猜错了
if guess != actualData:
count += 1 # 猜错则让记录用户猜错次数的变量count加1
# 如果用户猜的值如果比系统随机生成的值大，则表示猜大了
if guess &gt; actualData:
print("猜大了")
# 如果用户猜的值如果比系统随机生成的值小，则表示猜小了
else:
print("猜小了");
else :
print("恭喜，猜对了")
break
# 进行次数判断
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238f006264460daefe86513a41d053a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45540b6f327a2ac971687860d86b1df9/" rel="bookmark">
			未能加载程序集或它的一个依赖项_linux服务管理程序systemd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		systemd是Linux操作系统的系统和管理服务程序，作为系统启动的第一个进程（进程id为1)，用于初始化系统，启动和维护用户空间服务。
为了与sysv(Sysvinit:较早的系统启动管理服务)兼容，如果systemd被当作init并且pid不是1，它将执行telinit(用来改变SysV的运行级别)并传递所有未修改的命令行参数。这意味着当从正常登录会话调用init和telinit时，它们基本上是等价的。
当作为系统实例运行时，systemd将解释system.conf配置文件和system.conf.d目录中的文件。
﻿﻿systemd提供了一个12种不同类型的实体被称作“units”的依赖系统。单元封装了各种相关的对象用于系统启动和维护。大多数单元配置在单元配置文件，描述其语法和基本选项集，但是有些是从其他配置，正在运行的系统状态或以编程方式动态地进行配置。单元可以是“活动的”（意思是启动、绑定、插入等，具体取决于单位类型，见下文）或“不活动”（表示已停止、未绑定，拔掉，…），以及在被激活或停用的过程中，即在两种状态之间（这些状态称为“激活”，“停用”）。一个特殊的“失败”状态也可用，这是非常类似于“不活动”，当服务以某种方式失败时输入（进程在退出时返回错误代码，或崩溃，或操作超时）。如果输入此状态，则会记录原因，以供以后参考。注释不同的单元类型可能有一些附加的子状态，这些子状态映射到这里描述的五个广义单元状态。
下列十二种单元类型是可用的：
1. Service units：服务单元，启动和控制守护进程及它们包含的进程。有关详细信息，请参阅systemd.service。
2. Socket units：套接字单元，将本地IPC或网络套接字封装在系统，用于激活套接字。
3. Target units：目标单元，用于单元组，为系统启动期间提供同步点。
4. Device units ：设备单元，在systemd中公开内核设备，并可用于实现基于设备的激活。有关详细信息，请参阅systemd.device。
5. Mount units：挂载单元，控制文件系统中的挂载点。
6. Automount units：自动挂载单元，提供自动挂载功能，用于按需挂载文件系统以及并行启动。请参阅systemd.automount。
7. Snapshot units：快照单元，可用于临时保存系统单元集合的状态，稍后会保存激活的快照单元。请参见systemd.snapshot。
8. Timer units：计时器单元，基于计时器用于触发激活其他单元。请参见systemd.timer。
9. Swap units：交换单元，非常类似于挂载单元和封装内存交换分区或操作系统文件。
10. Path units：路径单元，当文件系统对象被改变或修改来激活其他服务。
11. Slice units：切片单元,可用于对管理系统过程的单元进行分组(如服务和作用域单元）在资源管理的层次树中。
12. Scope units：作用域单元，类似于服务单元，但它管理外部进程而不是启动它们。
应用程序和单元（通过依赖项）可以请求改变单元的状态。在systemd中，这些请求被封装为“jobs”和在作业队列中维护。工作可能成功，也可能失败，它们执行的顺序是基于它们所属单元之间的排序依赖关系排序而定的。
一.systemctl是Systemd的主命令，用于对系统进行管理。相当于将 service 和 chkconfig 这两个命令组合到一起。 如：systemctl reboot //重启电源
systemctl poweroff //关闭系统，切断电源
二.systemd-analyze命令用于查看启动耗时。
systemd-analyze //查看启动耗时
systemd-analyze blame //查看每个服务的耗时
systemd-analyze critical-chain //显示瀑布状的启动过程流
systemd-analyze critical-chain atd.service //显示指定服务的启动流
三.hostnamctl命令用于查看当前主机的信息。
hostnamectl //显示当前主机的信息(hostname值显示主机名）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45540b6f327a2ac971687860d86b1df9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9327fe6e7ef18d38787bd8feb1803a9c/" rel="bookmark">
			python打包代码中涉及的图片_python程序使用pyinstaller打包带图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python程序使用pyinstaller打包带图标。
工具/原料
pyinstaller
方法/步骤
1
在cmd中输入pip install pyinstaller进行pytinstaller的安装
因为已经安装模块后的效果
2
在cmd中，输入 pyinstaller -F test.py即可进行打包
注意test.py的路径文件，可以直接拖进cmd中这样便自带路径
3
打包好的exe程序提示在C:\Users\xxxx\dist文件夹下
4
到对应的文件下既可以看到打包好的exe程序
5
如果需要给exe程序带上图标，可以网上自行下载.ico后缀名的图片，然后使用命名
pyinstaller -F -i test.ico test.py
注意路径
6
最后需要注意的是，需要移动下生成可执行程序的位置，才可以显示图片
END
注意事项
如果帮助到了你，请点赞和投票哦
经验内容仅供参考，如果您需解决具体问题(尤其法律、医学等领域)，建议您详细咨询相关领域专业人士。
举报作者声明：本篇经验系本人依照真实经历原创，未经许可，谢绝转载。
展开阅读全部
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5cc591e3f7633102758d2c4271ba51d/" rel="bookmark">
			python英文词云代码_Python &#43; wordcloud 十分钟学会生成英文词云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于python生成的wordcloud
词云在这两年一直都热门话题，如果你耐下性子花个10分钟看看这篇文章，或许你就再也不用羡慕那些会词云的人了。这不是一项高深莫测的技术，你也可以学会。快来试试吧！
本篇我们讲解的是如何制作英文词云，下一期我们将给大家带来如何制作中文词云，敬请期待！
快速生成词云from wordcloud import WordCloud
f = open(u'txt/AliceEN.txt','r').read()
wordcloud = WordCloud(background_color="white",width=1000, height=860, margin=2).generate(f)
# width,height,margin可以设置图片属性
# generate 可以对全部文本进行自动分词,但是他对中文支持不好,对中文的分词处理请看我的下一篇文章
#wordcloud = WordCloud(font_path = r'D:\Fonts\simkai.ttf').generate(f)
# 你可以通过font_path参数来设置字体集
#background_color参数为设置背景颜色,默认颜色为黑色
import matplotlib.pyplot as plt
plt.imshow(wordcloud)
plt.axis("off")
plt.show()
wordcloud.to_file('test.png')
# 保存图片,但是在第三模块的例子中 图片大小将会按照 mask 保存
自定义字体颜色
这段代码主要来自wordcloud的github,你可以在github下载该例子#!/usr/bin/env python
"""
Colored by Group Example
========================
Generating a word cloud that assigns colors to words based on
a predefined mapping from colors to words
"""
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5cc591e3f7633102758d2c4271ba51d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f3731cc05415d932881a5b4a540d44/" rel="bookmark">
			python提取前几行数据_获取datafram的前几行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		In [7]:
df = pd.DataFrame(np.random.randn(10,3))
df
Out[7]:
0 1 2
0 -1.230919 1.482451 0.221723
1 -0.302693 -1.650244 0.957594
2 -0.656565 0.548343 1.383227
3 0.348090 -0.721904 -1.396192
4 0.849480 -0.431355 0.501644
5 0.030110 0.951908 -0.788161
6 2.104805 -0.302218 -0.660225
7 -0.657953 0.423303 1.408165
8 -1.940009 0.476254 -0.014590
9 -0.753064 -1.083119 -0.901708
In [8]:
df.head(5)
Out[8]:
0 1 2
0 -1.230919 1.482451 0.221723
1 -0.302693 -1.650244 0.957594
2 -0.656565 0.548343 1.383227
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f3731cc05415d932881a5b4a540d44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61cad402fb84e49ce51f32b1b995f1eb/" rel="bookmark">
			python输入123输出321_python逆序输出,编程从键盘输入一个三位数，将它们逆序输出。如输入123，输出321.谢谢...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python逆序输出,编程从键盘输入一个三位数，将它们逆序输出。如输入123，输出321.谢谢
python教程实现三位数的反序输出2020-10-06 12:32:19人已围观
7-12 逆序的三位数 python计算机编程题
print li[1:] #输出[2,3,4,5,6,7]，省略终止，表示取起始索引之所有值，等li[1:len(li)]
print li[:3] #输出[1,2,3]，起始索引，表示从0开始取，等效于li[0:3]
print li[:] #输出[1,2,3,4,5,6,7]，省略起始索引、终止索引、步长值表示取全部，等效于li[0:len(li):1]
print li[::] #输出[1,2,3,4,5,6,7]，省略起始索引、终止索引、步长值表示取全部，等效于li[0:len(li):1]
print li[::-1] #输出[7,6,5,4,3,2,1]，省略起始索引、终止索引，步长值为-1，表示反向获取
不研究源码的话，就只好先记着这就是一个快捷的用法
编程从键盘输入一个三位数，将它们逆序输出。如输入123，输出321.谢谢
# include# includevoid main()
{
char a,b,c;
a=getch();b=getch();
c=getch();
putchar(c);putchar(b);
putchar(a);putchar('\n');
}
版权声明：本站所有文章皆为原创，欢迎转载或转发，请保留网站地址和作者信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439ef15ddd4e27d83899a411f14aac01/" rel="bookmark">
			python的应用领域主要有_Python的应用领域有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python
的应用领域有哪些？
Python
是一门简单、易学并且很有前途的编程语言，很多人都对
Python
感兴趣，但是当
学完
Python
基础用法之后，
又会产生迷茫，尤其是自学的人员，不知道接下来的
Python
学习
方向，以及学完之后能干些什么？以下是
Python
十大应用领域！
1. WEB
开发
Python
拥有很多免费数据函数库、免费
web
网页模板系统、以及与
web
服务器进行交互
的库，可以实现
web
开发，搭建
web
框架，目前比较有名气的
Python web
框架为
Django
。从
事该领域应从数据、组件、安全等多领域进行学习，从底层了解其工作原理并可驾驭任何业内
主流的
Web
框架。
2.
网络编程
网络编程是
Python
学习的另一方向，网络编程在生活和开发中无处不在，哪里有通讯就
有网络，它可以称为是一切开发的“基石”。对于所有编程开发人员必须要知其然并知其所以
然，所以网络部分将从协议、封包、解包等底层进行深入剖析。
3.
爬虫开发
在爬虫领域，
Python
几乎是霸主地位，将网络一切数据作为资源，通过自动化程序进行
有针对性的数据采集以及处理。
从事该领域应学习爬虫策略、
高性能异步
IO
、
分布式爬虫等，
并针对
Scrapy
框架源码进行深入剖析，从而理解其原理并实现自定义爬虫框架。
4.
云计算开发
Python
是从事云计算工作需要掌握的一门编程语言，目前很火的云计算框架
OpenStack
就是由
Python
开发的，如果想要深入学习并进行二次开发，就需要具备
Python
的技能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/439ef15ddd4e27d83899a411f14aac01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36ab69e99f7d5088808606ee21afcc5e/" rel="bookmark">
			python微信机器人pc端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多玩python的都知道，以前有个第三方库可以操作微信，实现自动回复等等功能，其原理是用https进行通信的， 但是现在大部分微信都不能登录网页版了，很多好玩的项目都受到了影响。因此，我来了。
通过截取电脑版微信的消息可以做到功能更全面的效果，项目地址：https://github.com/huihuilo/pchat
pchat 微信pc端python代码操控(欢迎提出问题，作者尽最大努力改进)
先点个赞吧
背景 很多系统有监控群聊消息的需求大部分微信都登录不了网页版，python操纵微信的第三方库已无法使用，如itchat实时同步微信公众号文章，目前实现无非以下几种： 爬取搜狗搜索接口，但会被限制请求次数，不能实时同步，并且拿到的文章信息也不全登录微信订阅号，爬取搜索文章接口，不能实时获取，有被封号封IP的风险获取pc微信窗口点击公众号文章，再通过mitmproxy拦截请求，这种方法也实现不了实时获取，而且微信对阅读文章数有限制通过登录网页版实时获取，大部分微信无法登录网页版，行不通 项目原理 接收消息： pc微信接收到消息 ---&gt; 拦截工具拦截消息 ---&gt; 发送到服务端
发送消息： 服务端发送消息 ---&gt; 拦截工具接收消息转发 ---&gt; 发送到pc微信
项目介绍 可以发送文字，图片，文件，实时获取消息(包括公众号推文)服务端可部署到外网服务器上服务端如果部署到其他机器上，发送文件，图片时，确保传入的路径在微信客户端存在，或者先把文件传到微信客户端机器上，再将路径发送过去服务端重启不会丢失已登录微信的个人消息，客户端重新连接即可可以接入多个微信客户端拦截工具按每个微信号一元一天收取费用添加微信付费后，作者会返回使用有效期，有效期内可以正常使用拦截功能具体消息类型的处理自行研究开发，如有需求可联系作者微信 环境配置： 客户端需要用window系统，服务端不受限制，Python3.2+, 服务端可以使用进程管理工具部署，如：supervisor
使用示例 安装2.6.8.51版本微信（必须安装此版本）
编写服务端代码
from chat import Server, BaseChat class MyChat(BaseChat): def receiver(self, msg): print("收到来自 %s 的消息：%s" % (msg['from'], msg['content'])) server = Server() chat = MyChat(wx_nickname='Python开发') server.bind(chat) # 绑定登录的微信 server.run() 打开拦截工具wechathelper.exe，输入服务端绑定的地址和端口
点击启动按钮后，微信客户端会自动打开，登录与服务端绑定的微信号
拦截工具为付费功能，一块钱一天，添加微信付费后即可使用 具体业务需求可以看源码进行相应的开发，如：实现获取公众号消息，自动回复功能，聊天机器人等
其他语言开发 此项目为python语言开发，也可以用其他语言进行开发， 只需实现一个socket服务端即可接受到微信客户端的消息，根据消息格式进行相关逻辑的编写。
如果服务端自己开发需要注意以下几点：
socket读取消息粘包和漏包的问题服务端崩溃时，重启后如果想保持正常使用，最好将微信个人信息，通讯录，这些登录时才能获取到的信息保存下来 声明 请勿使用该工具扰乱他人，或者违反法律，如被封号概不负责(请尽量使用小号)，使用此工具造成的法律纠纷，本人概不负责。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85e369acb8c762f33dd8b519100dd7f5/" rel="bookmark">
			pycharm中python版本_pycharm怎么切换python版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们在使用pycharm的时候，想切换python版本，怎么切换呢，下面来分享一下方法
工具/原料
pycharm
切换python版本方法
方法/步骤
1
第一步在我们的电脑上打开pycharm，点击file-&gt;settings，如下图所示：
2
第二步进去之后，点击project test-&gt;Porject Interpreter，如果没有项目直接点击Porject Interpreter，可以看到现在的python版本，如下图所示：
3
第三步点击旁边的设置图标，选择“Add”，如下图所示：
4
第四步进去之后，点击“Existing environment”，然后选择要切换的python版本路径，如下图所示：
5
第五步选择要切换python版本的安装路径，将python.exe加载进来，点击ok之后，点击下拉列表，选择切换的python版本，点击ok就完成了，如下图所示：
END
注意事项
如果你觉得这篇对你有用的话，请投一下票
经验内容仅供参考，如果您需解决具体问题(尤其法律、医学等领域)，建议您详细咨询相关领域专业人士。
举报作者声明：本篇经验系本人依照真实经历原创，未经许可，谢绝转载。
展开阅读全部
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f998618872ee02ffcdef11626487943b/" rel="bookmark">
			Derby教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Derby教程 简介目的教程主题下一步 简介 Apache Derby是Apache DB子项目，是用Java实现的关系数据库。它的占用空间非常小，可以很容易地将其嵌入任何基于Java的解决方案中。除了嵌入式框架外，Derby还支持一个与Derby网络服务器更为熟悉的客户机/服务器框架。本教程介绍Derby的基本特性，并指导您使用这两种框架；首先是使用Derby嵌入式JDBC驱动程序的嵌入式框架，然后是使用Derby网络客户端JDBC驱动程序的网络服务器框架。
目的 本教程由@克己在学习Derby数据库时整理而成。面向至少接触过SQL、Java和JDBC的新Derby用户。
教程主题 本教程分为以下几节：
Derby安装与环境配置演示如何： 安装Apache Derby软件。配置您的环境以使用Derby嵌入式JDBC驱动程序。使用sysinfo工具验证安装。 ij工具的基础操作展示了如何使用ij工具和嵌入式derbyjdbc驱动程序来创建数据库和执行SQL查询。Derby的嵌入式配置演示了如何编译和运行一个使用Derby嵌入式JDBC驱动程序的简单Java应用程序。Derby网络服务器配置演示如何： 启动Derby网络服务器。配置您的环境以使用Derby网络客户端JDBC驱动程序。编译并运行一个使用网络服务器的简单Java应用程序。 下一步 完成本教程中的四个步骤后，您将了解如何在嵌入式和网络服务器框架中使用Derby。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e01e5a28ee6388be66336cd308f012b1/" rel="bookmark">
			脏写是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库事务并发执行存在着几个问题，如脏读，不可重复度，幻读等。
那么脏写又是什么呢？
如果两个事务并发执行，修改同一条数据，两个事务都还没提交，第一个事务正常执行修改，但是第二个事务却想要回滚，此时由于undo log日志中存放的是一开始的数据记录，那么第二个事务回滚就会把这条数据回滚为最初的数据值，导致第一个事务的修改无效。这就是脏写了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f4e2a0ef2d089029a70d077306079b/" rel="bookmark">
			[转载] 基于LSTM的股票预测模型_python实现_超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接： 从Python获取输入
文章目录
一、背景二、主要技术介绍1、RNN模型2、LSTM模型3、控制门工作原理四、代码实现五、案例分析六、参数设置七、结论完整程序下载
一、背景 近年来，股票预测还处于一个很热门的阶段，因为股票市场的波动十分巨大，随时可能因为一些新的政策或者其他原因，进行大幅度的波动，导致自然人股民很难对股票进行投资盈利。因此本文想利用现有的模型与算法，对股票价格进行预测，从而使自然人股民可以自己对股票进行预测。 理论上，股票价格是可以预测的，但是影响股票价格的因素有很多，而且目前为止，它们对股票的影响还不能清晰定义。这是因为股票预测是高度非线性的，这就要预测模型要能够处理非线性问题，并且，股票具有时间序列的特性，因此适合用循环神经网络，对股票进行预测。 虽然循环神经网络（RNN），允许信息的持久化，然而，一般的RNN模型对具备长记忆性的时间序列数据刻画能力较弱，在时间序列过长的时候，因为存在梯度消散和梯度爆炸现象RNN训练变得非常困难。Hochreiter 和 Schmidhuber 提出的长短期记忆（ Long Short-Term Memory，LSTM）模型在RNN结构的基础上进行了改造，从而解决了RNN模型无法刻画时间序列长记忆性的问题。 综上所述，深度学习中的LSTM模型能够很好地刻画时间序列的长记忆性。 二、主要技术介绍 1、RNN模型 在传统的RNN（循环神经网络）中，所有的w都是同一个w，经过同一个cell的时候，都会保留输入的记忆，再加上另外一个要预测的输入，所以预测包含了之前所有的记忆加上此次的输入。所有RNN都具有一种重复神经网络模块的链式的形式。在标准的RNN中，这个重复的模块只有一个非常简单的结构，例如一个tanh层。 当权中大于1时，反向传播误差时，误差将会一直放大，导致梯度爆炸；当权中小于1时，误差将会一直缩小，导致梯度消失，进而导致网络权重更新缓慢，无法体现出RNN的长期记忆的效果，使得RNN太过健忘。RNN模型的结构如图： 2、LSTM模型 长短期记忆模型（long-short term memory）是一种特殊的RNN模型，是为了解决反向传播过程中存在梯度消失和梯度爆炸现象，通过引入门（gate）机制，解决了RNN模型不具备的长记忆性问题，LSTM模型的结构如图： 具体来说，LSTM模型的1个神经元包含了1个细胞状态（cell）和3个门（gate）机制。细胞状态（cell）是LSTM模型的关键所在，类似于存储器，是模型的记忆空间。细胞状态随着时间而变化，记录的信息由门机制决定和更新。门机制是让信息选择式通过的方法，通过sigmoid函数和点乘操作实现。sigmoid取值介于0～1之间，乘即点乘则决定了传送的信息量（每个部分有多少量可以通过），当sigmoid取0时表示舍弃信息，取1时表示完全传输(即完全记住)[2]。 LSTM 拥有三个门，来保护和控制细胞状态：遗忘门（forget gate）、更新门（update gate）和输出门（output gate）。 细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。 如图： 3、控制门工作原理 遗忘门 更新门 输出门 四、代码实现 UI demo.py
import tensorflow as tf
import numpy as np
import tkinter as tk
from tkinter import filedialog
import time
import pandas as pd
import stock_predict as pred
def creat_windows():
win = tk.Tk() # 创建窗口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0f4e2a0ef2d089029a70d077306079b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a226d929089b62903e5fe4160071c5dd/" rel="bookmark">
			统计24小时内每个小时最后一条数据_如你所愿，一篇文章搞定8种Excel多表统计...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创作者： 卢子 转自：Excel不加班
同样一个任务，一个人花了5小时，吃了很多苦，做到60分；另一个人花了5分钟，轻轻松松，做到了80分。你会给第一个人点赞，夸她棒吗？
在职场，过程不重要，结果才是最重要的。
1.格式相同的表格，要在第一个表汇总后面所有表格D列的总量。
格式相同的表，多少个都一样，一个SUM函数就秒杀了。
=SUM('4.1:4.7'!D3)
语法：
SUM(起始表格名称:结束表格名称!单元格)
表格名称没有规律也可以，在有特殊字符的情况下需要加单引号'。
我们知道*是通配符，代表所有的意思，在这里也可以用*来实现统计。
=SUM('*'!D3)
2.同样也是格式相同，但要汇总的形式不一样，要汇总每一个月份的总销量。
这里是用SUM+INDIRECT函数的组合实现。
可能很多人一开始直接就用SUM，可惜得到的是错误值。A2&amp;"!C:C"被当成文本处理，而不是区域。
=SUM(A2&amp;"!C:C")
我们正常的引用都是直接引用，如区域C:C。间接引用就是通过第三者才能获得的，如INDIRECT("C:C")。也就是说，只要嵌套个INDIRECT函数就可以。
3.跟上一个例子很像，唯一的差别就是最后多一个合计的实发数量，而每一个表格的行数不确定。现在要获取每个表合计的实发数量。
这种有很多种处理方法，最简单的办法有两种
01 查找每个表，最后一个数量。
=LOOKUP(9E+307,INDIRECT(A2&amp;"!B:B"))
02 统计每个表的数量后再除以2。
=SUM(INDIRECT(A2&amp;"!B:B"))/2
4.现在换成统计商品的销售量。
明细表
汇总表
难度瞬间就上来了，要结合好多函数。
=SUMPRODUCT(SUMIF(INDIRECT(ROW($1:$6)&amp;"月!B:B"),A2,INDIRECT(ROW($1:$6)&amp;"月!C:C")))
看起来很复杂，但实际上也不是太难理解。
INDIRECT(ROW($1:$6)&amp;"月!B:B")这部分就是获取1-6月的B列
INDIRECT(ROW($1:$6)&amp;"月!C:C")这部分就是获取1-6月的C列
SUMIF(1-6月的B列,A2,1-6月的C列)就是分别统计这6个表
SUMPRODUCT(SUMIF())就是将最终这6个表进行求和
如果不会也没事，下面还有技巧法。
5.格式相同的多个表格，现在要统计所有人员的工资数据。
Step 01 新建一个空白的汇总表，点击汇总表任意空白单元格，再点击数据→合并计算，这时会弹出合并计算对话框。
Step 02 鼠标引用第一个表的区域，点击添加。
Step 03 重复添加剩下的所有表格，添加完毕以后，勾选首行和最左列，点击确定。
瞬间就统计出来，非常快。
Step 04 统一格式，搞定收工。
6.格式相同的12个表格，现在要统计每个销售人员销售的产品对应的总数量。
关于多表统计，高手可以借助VBA和SQL，普通人也有非常方便的方法。一起来看看超级透视表如何进行统计的？
Step 01 新建一个工作簿，点击数据→新建查询→从文件→从工作簿。
Step 02 浏览到工作簿所在位置，点击导入。
Step 03 选择整个工作簿，点击编辑。
Step 04 删除不需要的列，展开Data获取所有数据。
Step 05 将第一行作用作标题，取消多余的标题筛选，关闭并上载。
Step 06 根据合并后的数据创建数据透视表统计。不包含空格的数据，可以直接用勾选而不需要用拖拉字段，更方便。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a226d929089b62903e5fe4160071c5dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f97682fe9953f358a36abf15f5a9cbf/" rel="bookmark">
			vue @input带参数_重读 VUE 官方文档 &amp;lt;2&amp;gt;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当在一个自定义组件上使用 class 属性时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。
当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。
v-if vs v-show
v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。
你也可以提供第二个的参数为 property 名称 (也就是键名)：
&lt;div v-for="(value, name) in object"&gt; {{ name }}: {{ value }} &lt;/div&gt;
Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：
push()pop()shift()unshift()splice()sort()reverse()例如filter()、concat()和slice()。它们不会改变原始数组，而总是返回一个新数组。当使用非变异方法时，也可以触发试图更新。 Vue.set(object, propertyName, value)方法向嵌套对象添加响应式属性
v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。
&lt;div&gt; &lt;span v-for="n in 10"&gt;{{ n }} &lt;/span&gt; &lt;/div&gt;
当它们处于同一节点，v-for的优先级比v-if更高，这意味着v-if将分别重复运行于每个v-for循环中
需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f97682fe9953f358a36abf15f5a9cbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8237fca370da4a8251f5020d2d22025b/" rel="bookmark">
			cmd 顺序启动服务_springboot项目注册为windows系统服务并设置开机自启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot项目注册为windows系统服务并设置开机自启
关于springboot项目的部署与SSM(框架)部署war包到Tomcat下有所不同，比较明显的是springboot打包为jar包，运行则是执行通过java -jar xxx.jar，不再需要放置在Tomcat下面运行。
关于springboot项目部署相对于之前简化了一些步骤，只需要在服务器中安装好jdk环境，然后执行java -jar xxx.jar就可以把项目跑起来，如下所示。
我们通过传统---&gt;改进版---&gt;改进版plus---&gt;最终版演变方式来一步步探讨一下。
1、方式一(传统版)
(1)
假设这是window服务器，D盘中有一个名为demo-0.0.1-SNAPSHOT.jar项目
(2)
打开cmd，运行项目。
......
下图所示：
端口：9527
/：去项目名
(3)
实际测试项目(demo-0.0.1-SNAPSHOT.jar)中的一个接口
(4)
测试访问
2、改进版
以上方式运行项目还需要手动进入cmd输入命令，相对来说比较麻烦。
下面我们可以通过一个bat脚本来实现这个功能。
(1)
脚本内容，比较简单。
(2)
执行cmd脚本
(3)
测试访问
3、 改进版plus
关于以上的两种方式不能满足开机自启动需求。
假设服务器宕机，重启启动服务还需要人工操作。
所以下面我们利用windows启动菜单添加快捷方式来完成开机自启的需求。
(1)
win+R打开运行窗口，输入shell:startup
(2)
将步骤2的脚本start.cmd新建一个快捷方式，然后将快捷方式拷贝到启动项文件中。
(3)
重启电脑进行测试，自行操作。
4、 最终版
关于以上的3种方式都有一个通病：
一直显示着一个CMD窗口，而且这个窗口不能关，关了程序就停了。
继而引出了我们今天的主角：
可以将Windows上的任何一个程序注册为服务的工具--winsw
关于winsw官方发言：
WinSW is an executable binary, which can be used to wrap and manage a custom process as a Windows service.
WinSW是一个可执行的二进制文件，可用于将自定义进程包装和管理为Windows服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8237fca370da4a8251f5020d2d22025b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d089c6939e1a780530cf8c3e2327d702/" rel="bookmark">
			win10 miniconda pytorch1.5安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先自己先装好自己的cuda驱动，我自己装的是9.2的版本，装的方法可自行百度
miniconda 安装 mini conda 是conda的轻量级版本，相比anaconda占用空间小。直接在清华镜像下载安装包 https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/
选择python3.8的最新版本，下载完后直接双击安装，选择自己的安装路径，一路next 就行 中间勾选添加环境变量的选项，这里要注意下如果安装的不是默认路径，在安装完后要设置安装主路径的权限，右键-&gt;属性-&gt;安全-&gt;SYSTEM-&gt;确认。不然后面安装torch的时候会出错。
安装完后在win10开始栏哪里找到miniconda的快捷方式
打开输入下面命令，显示当前conda 的虚拟环境的路径
conda env list base为默认环境，可以使用
conda create --name （虚拟环境的名字） python=（python的版本） 创建新的环境，这里我直接使用默认环境
更换为国内源 在c盘的用户目录下打开 .condarc文件更换下载源为国内源，这里用的清华镜像，也可以选择阿里，中科大，豆瓣的镜像，同时添加了pytorch的镜像地址，删除文件中的default选项
channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch//win-64/ show_channel_urls: true 更换pip下载为豆瓣源，在同样的目录下新建一个名为pip的文件夹，里面新建一个pip.ini文件，填入下面信息保存
[global] timeout = 60 index-url = https://pypi.douban.com/simple trusted-host = pypi.douban.com timeout是超时时间，单位是秒
opencv-python 安装
python -m pip install opencv-python pytorch 安装直接可以用下面命令 注意自己CUDA驱动版本要和Pytorch版本相匹配
conda install pytorch==1.5.1 torchvision==0.6.1 cudatoolkit=9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d089c6939e1a780530cf8c3e2327d702/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065fc47158aeaf37b2bb0828f083aa59/" rel="bookmark">
			qtcreator 使用不同版本的编译器进行编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般情况通过官方安装包安装的 qt 会自动检测编译器添加到 qtcreator。如果是自己编译的 qt 就需要手动添加。把不同版本的 qt 安装到不同的目录，然后在 qtcreator 配置 qt 版本和对应版本的编译器，就可以在一个qtcreator 上使用不同版本的 qt。
添加 qt 版本 依次点击 工具 -&gt; 选项
添加 qmake
根据 qt 版本修改版本名称，方便切换的时候分辨版本。
添加编译器 添加下拉框依次选择 GCC -&gt; C++
通过路径选择 g++ 编译器
修改构建套件 选择上面添加的 qt 版本，把刚才添加编译器添加进去，调试器和 CMake 选用系统的就可以了。
配置完成后，可以在打开/新建项目的时候选择编译器，或者在项目页面修改
不同版本的 qtcreator 界面有点区别，修改的地方多找一下就好了。
使用 qtcreator 指定了 qmake 之后，会根据 qmake 记录去找对应版本的库文件和头文件进行编译和运行调试。
如果编译出应用程序，然后直接运行程序的话需要指定动态库的路径，不然会报错。
Linux 终端临时添加动态库的环境
$ export LD_LIBRARY_PATH=xxx:$LD_LIBRARY_PATH
xxx 填动态库的路径，这样设置在当前终端有效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cc3b983115790e86b0b9a6e87a0c0a2/" rel="bookmark">
			第二篇：MySQL之InnoDB物理存储结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第二篇：MySQL中InnoDB引擎的物理存储结构 1. 个人理解 看了很多MySQL的书籍和博客，感觉都是互相抄来抄去，把知识点的罗列，讲不清楚前因后果，让人看起来莫名其妙的。所以，我决定从MySQL的底层物理存储结构了解，掌握了InnoDB的物理存储结构，再理解索引，锁，事务，日志之类的上层优化就很容易了。
2. 知识来源 本文主要观点来自于阿里数据库内核月报
http://mysql.taobao.org/monthly/2016/02/01/
和一篇CSDN博客
https://blog.csdn.net/jiang18238032891/article/details/108471750
本文主要梳理大致组织结构，不会深入每个细节，主要想让读者明白大致原理即可，因为InnoDB的组织过于复杂。如果文章存在错误，请多多包涵，望批评指正。
3. 基本知识 3.1、页PAGE 首先，InnoDB将物理磁盘划分为页page，每页的大小默认为16KB，页是最小的存储单位。因为上层应用的需要，比如索引、日志等，页有很多的格式。我们主要说数据页，也就是存储实际数据的页。
首先看，数据页的基本格式，如下图
3.1.1、File Header
描述数据页的外部信息，比如属于哪一个表空间、前后页的页号等。
名称描述check_sum数据页的校验和page_num数据页的编号space_id数据页所属的表空间idprev_page_num上一个数据页的页号next_page_num下一个数据页的页号lsn最近刷新的日志编号 数据页在物理磁盘上是按照双向链表的方式来连接的
3.1.2、User Records
用户纪录，也就是数据库表中对应的数据，这里我们说常用的compact格式。
3.1.2.1、变长字段长度列表
InnoDB支持变成VARCHAR等数据格式，所以，在纪录的最前边纪录起占用的字节数，通过字节数来正确的读取数据
3.1.2.2、NULL值列表
通过NULL值列表用一个bit来标记为NULL的列，代替用NULL来标记真实数据，可以省空间
3.1.2.3、纪录头信息
用来描述纪录的一些信息
比如是否删除、下一条纪录的位置等信息
名称描述next_record下一条纪录的位置信息delete是否被删除type0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录 3.1.2.4、列对应的真实数据
InnoDB除了我们插入的数据外，还有一些隐藏列，transaction_id（事务ID）、roll_pointer（回滚指针）是一定添加的。row_id则不一定，根据以下策略生成：
优先使用用户建表时指定的主键，若用户没有指定主键，则使用unique键。若unique键都没有，则系统自动生成row_id，为隐藏列。
3.1.3、Page Header
PAGE_HEADER用来描述数据页中的具体信息，比如存在多少条纪录，第一条纪录的位置等
名称描述rec_count纪录的数量free_topfreespace的最小地址delete_addr第一条被删除的纪录地址delete_space删除纪录的总空间btree_level当前页在B+树中的层级 3.1.4、infimum和supremum纪录
infimum和supremum是系统生成的纪录，分别为最小和最大纪录值，infimum的下一条是用户纪录中键值最小的纪录，supremum的上一条是用户纪录中键值最大的纪录，通过next_record字段来相连。
3.1.5、Free Space
页中目前空闲的存储，可以插入纪录
3.1.6、Page Dictionary
类似于字典的目录结构，根据主键大小，每隔4-8个纪录设置一个槽，用来纪录其位置，当根据主键查找数据时，首先一步到位找到数据所在的槽，然后在槽中线性搜素。这种方法比从前到后遍历页的链表的效率更快。
3.1.7、Page Tailer
File Header存储刷盘前内存的校验和，Page Tailer储存刷盘后的校验和。当刷盘的时候，出现异常，Page Tailer和File Header中的校验和不一致，则说明出现刷盘错误。
3.1.8、插入纪录过程
如果Free Space的空间足够的话，直接分配空间来添加纪录，并将插入前最后一条纪录的next_record指向当前插入的纪录，将当前插入纪录的next_record指向supremum纪录。
如果Free Space的空间不够的话，则首先将之前删除造成的碎片重新整理之后，按照上述步骤插入纪录。
如果当前页空间整理碎片之后仍然不足的话，则重新申请一个页，将页初始化之后，按照上述步骤插入纪录
3.2、区EXTENT 引入EXTENT的原因：
如果只有页这一层次的话，页的个数是非常多的，存储空间的分配和回收都会很麻烦，因为要维护这么多的页的状态是非常麻烦的。
所以，InnoDB又引入了区extent。一个区默认是64个连续的页组成的，也就是1MB。通过对EXTENT进行管理来进行存储空间的分配和回收就比较容易了。
3.3、段SEGMENT 为什么要引入段呢，这要从索引说起。我们都知道索引的目的是为了加快查找速度，是一种典型的用空间换时间的方法。
我们首先看没有索引的时候，数据是怎么查找的：
根据page的列表，从头到尾来遍历，速度极慢。可以看出没有索引的话，数据的查找效率极慢
那么索引是怎么来解决问题的呢
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cc3b983115790e86b0b9a6e87a0c0a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/607ac396d6bbda5b6b4ef88e1d7e9bd7/" rel="bookmark">
			java 远程执行linux命令_Pikachu-RCE远程命令执行漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RCE：远程代码、命令执行漏洞 给攻击者向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。
远程系统命令执行
一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上
一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器
远程代码执行同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。你可以通过“RCE”对应的测试栏目，来进一步的了解该漏洞。
exec"ping":
远程命令执行，直接输入： 127.0.0.1 &amp; ipconfig 。。。。发现出现了乱码
可以执行以下步骤
1. 同时按"win + R" ，并输入 regedit 进入注册表
2. 找到 HKEY_CURRENT_USERConsole%SystemRoot%_system32_cmd.exe，如果该项下已存在 CodePage 项，则把值改为十进制 "65001"，点击确定即可；如果不存在，在该项下新建一个 DWORD(32位值)，命名为 "CodePage"，值设为 "65001"。然后关闭注册表管理器。
然后再重新输入命令查看结果：
exec"eval":
后台会执行响应的 php 代码，我们可以输入下面的代码：phpinfo();
得到当前网站的系统版本，PHP版本以及储存路径等信息。
﻿
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/344/">«</a>
	<span class="pagination__item pagination__item--current">345/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/346/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>