<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>yocto machine class解析之st-partitions-image - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="yocto machine class解析之st-partitions-image" />
<meta property="og:description" content="yocto machine class解析之st-partitions-image stm32mp157 yocto的meta-st-stm32mp layer中提供了几个class,后续几篇文章重点分析这些class文件：
第一篇就从st-partitions-image.bbclass 开始，st所有创建image的bb文件都会引用st-partitions-image，包括bootfs userfs vendorfs等image的bb 文件。这个class会在image编译以后生成分区镜像。
ENABLE_PARTITIONS_IMAGE ?= &#34;1&#34; PARTITIONS_CONFIG ??= &#34;&#34; PARTITIONS_IMAGE ??= &#34;&#34; PARTITIONS_MOUNTPOINT ??= &#34;&#34; python __anonymous () { # We check first if it is requested to generate any partition images if d.getVar(&#39;ENABLE_PARTITIONS_IMAGE&#39;) != &#34;1&#34;: bb.note(&#39;ENABLE_PARTITIONS_IMAGE not enabled&#39;) return # ----------------------------------------------------------------------------- # Update the partition configuration set by user # ----------------------------------------------------------------------------- partitionsconfigflags = d.getVarFlags(&#39;PARTITIONS_CONFIG&#39;) # The &#34;doc&#34; varflag is special, we don&#39;t want to see it here partitionsconfigflags." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ea31bad60454af8e0667f349a1a4c897/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-28T00:23:18+08:00" />
<meta property="article:modified_time" content="2022-11-28T00:23:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">yocto machine class解析之st-partitions-image</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="yocto_machine_classstpartitionsimage_0"></a>yocto machine class解析之st-partitions-image</h2> 
<p>stm32mp157 yocto的meta-st-stm32mp layer中提供了几个class,后续几篇文章重点分析这些class文件：<br> <img src="https://images2.imgbox.com/3e/9d/6Bt1jYWu_o.png" alt="在这里插入图片描述">第一篇就从st-partitions-image.bbclass 开始，st所有创建image的bb文件都会引用st-partitions-image，包括bootfs userfs vendorfs等image的bb 文件。这个class会在image编译以后生成分区镜像。</p> 
<pre><code>
ENABLE_PARTITIONS_IMAGE ?= "1"

PARTITIONS_CONFIG ??= ""
PARTITIONS_IMAGE ??= ""
PARTITIONS_MOUNTPOINT ??= ""

python __anonymous () {
    # We check first if it is requested to generate any partition images
    if d.getVar('ENABLE_PARTITIONS_IMAGE') != "1":
        bb.note('ENABLE_PARTITIONS_IMAGE not enabled')
        return

    # -----------------------------------------------------------------------------
    # Update the partition configuration set by user
    # -----------------------------------------------------------------------------
    partitionsconfigflags = d.getVarFlags('PARTITIONS_CONFIG')
    # The "doc" varflag is special, we don't want to see it here
    partitionsconfigflags.pop('doc', None)
    partitionsconfig = (d.getVar('PARTITIONS_CONFIG') or "").split()
    # Init image_summary_list
    image_summary_list = ''
    if len(partitionsconfig) &gt; 0:
        for config in partitionsconfig:
            for f, v in partitionsconfigflags.items():
                if config == f:
                    items = v.split(',')
                    if items[0]:
                        if len(items) &gt; 5:
                            raise bb.parse.SkipRecipe('Only image,label,mountpoint,size,type can be specified!')
                        # Make sure that we're dealing with partition image and not rootfs image
                        if len(items) &gt; 2 and items[2]:
                            # Mount point available, so we're dealing with partition image
                            # PARTITIONS_IMAGE appending
                            bb.debug(1, "Appending '%s' to PARTITIONS_IMAGE." % items[0])
                            d.appendVar('PARTITIONS_IMAGE', ' ' + items[0])
                            # PARTITIONS_MOUNTPOINT appending
                            bb.debug(1, "Appending '%s' to PARTITIONS_MOUNTPOINT." % items[2])
                            d.appendVar('PARTITIONS_MOUNTPOINT', ' ' + items[2])

                        # Update IMAGE vars for each partition image
                        if items[1]:
                            bb.debug(1, "Set UBI_VOLNAME to %s for %s partition image." % (items[1], items[0]))
                            d.setVar('UBI_VOLNAME_pn-%s' % d.expand(items[0]), items[1])
                            if d.expand(items[1])[-2:] != 'fs':
                                bb.debug(1, "Set IMAGE_NAME_SUFFIX to '.%sfs' for %s partition image." % (items[1], items[0]))
                                d.setVar('IMAGE_NAME_SUFFIX_pn-%s' % d.expand(items[0]), '.' + items[1] + 'fs')
                            else:
                                bb.debug(1, "Set IMAGE_NAME_SUFFIX to '.%s' for %s partition image." % (items[1], items[0]))
                                d.setVar('IMAGE_NAME_SUFFIX_pn-%s' % d.expand(items[0]), '.' + items[1])
                        else:
                            bb.fatal('[PARTITIONS_CONFIG] Missing label setting for %s image' % items[0])
                        if items[2]:
                            bb.debug(1, "Set IMAGE_PARTITION_MOUNTPOINT to %s for %s partition image." % (items[2], items[0]))
                            d.setVar('IMAGE_PARTITION_MOUNTPOINT_pn-%s' % d.expand(items[0]), items[2])
                        if items[3]:
                            bb.debug(1, "Set IMAGE_ROOTFS_SIZE to %s for %s partition image." % (items[3], items[0]))
                            d.setVar('IMAGE_ROOTFS_SIZE_pn-%s' % d.expand(items[0]), items[3])
                        else:
                            bb.fatal('[PARTITIONS_CONFIG] Missing size setting for %s image' % items[0])

                        # Manage IMAGE_SUMMARY_LIST configuration according to PARTITION_CONFIG set
                        if d.getVar('ENABLE_IMAGE_LICENSE_SUMMARY') == "1":
                            if not items[2]:
                                # Set '/' as default mountpoint for rootfs in IMAGE_SUMMARY_LIST
                                items[2] = '/'
                            image_summary_list += items[0] + ':' + items[2] + ';'

                        # Manage multiubi volume list STM32MP_UBI_VOLUME
                        if bb.utils.contains('IMAGE_FSTYPES', 'stmultiubi', True, False, d) and d.getVar('ENABLE_MULTIVOLUME_UBI') == "1":
                            bb.debug(1, "Appending '%s' image with %s size to STM32MP_UBI_VOLUME." % (items[0], items[3]))
                            d.appendVar('STM32MP_UBI_VOLUME', ' ' + items[0] + ':' + items[3])

                    else:
                        bb.fatal('[PARTITIONS_CONFIG] Missing image setting')

                    break

    # Reset IMAGE_LIST_SUMMARY with computed partition configuration
    if d.getVar('ENABLE_IMAGE_LICENSE_SUMMARY') == "1":
        bb.debug(1, "Set IMAGE_SUMMARY_LIST with configuration: %s." % image_summary_list)
        d.setVar('IMAGE_SUMMARY_LIST', image_summary_list)

    # Init partition list from PARTITIONS_IMAGE
    image_partitions = (d.getVar('PARTITIONS_IMAGE') or "").split()
    # -----------------------------------------------------------------------------
    # Make sure to append the partition build to current image target
    # -----------------------------------------------------------------------------
    if len(image_partitions) &gt; 0:
        # Gather all current tasks
        tasks = filter(lambda k: d.getVarFlag(k, "task", True), d.keys())
        for task in tasks:
            # Check that we are dealing with image recipe
            if task == 'do_image_complete':
                # Init current image name
                current_image_name = d.getVar('PN') or ""
                # Init RAMFS image if any
                initramfs = d.getVar('INITRAMFS_IMAGE') or ""
                # Init INITRD image if any
                initrd = d.getVar('INITRD_IMAGE') or ""
                # We need to append partition images generation only to image
                # that are not one of the defined partitions and not the InitRAMFS image.
                # Without this check we would create circular dependency
                if current_image_name not in image_partitions and current_image_name != initramfs and current_image_name != initrd:
                    for partition in image_partitions:
                        bb.debug(1, "Appending %s image build to 'do_image_complete' depends tasks." % partition)
                        d.appendVarFlag('do_image_complete', 'depends', ' %s:do_image_complete' % partition)
                    bb.debug(1, "Appending 'image_rootfs_image_clean_task' to IMAGE_PREPROCESS_COMMAND.")
                    d.appendVar('IMAGE_PREPROCESS_COMMAND', 'image_rootfs_image_clean_task;')
                    # Manage multiubi volume build enable for current image
                    if bb.utils.contains('IMAGE_FSTYPES', 'stmultiubi', True, False, d) and d.getVar('ENABLE_MULTIVOLUME_UBI') == "1":
                        bb.debug(1, "Appending 'st_multivolume_ubifs' to IMAGE_POSTPROCESS_COMMAND.")
                        d.appendVar('IMAGE_POSTPROCESS_COMMAND', 'st_multivolume_ubifs;')
}

image_rootfs_image_clean_task() {
    bbnote "PARTITIONS_IMAGE"
    bbnote "&gt;&gt;&gt; ${PARTITIONS_IMAGE}"
    bbnote "PARTITIONS_MOUNTPOINT"
    bbnote "&gt;&gt;&gt; ${PARTITIONS_MOUNTPOINT}"
    unset i j
    for img in ${PARTITIONS_IMAGE}; do
        i=$(expr $i + 1);
        for part in ${PARTITIONS_MOUNTPOINT}; do
            j=$(expr $j + 1);
            if [ $j -eq $i ]; then
                bbnote "Expecting to clean folder:"
                bbnote "&gt;&gt;&gt; ${IMAGE_ROOTFS}/$part"
                if [ -d ${IMAGE_ROOTFS}/$part ]; then
                    rm -rf ${IMAGE_ROOTFS}/$part/*
                    bbnote "&gt;&gt;&gt; DONE"
                else
                    bbnote "&gt;&gt;&gt; NOT DONE : $part folder doesn't exist in image rootfs"
                fi
            fi
        done
        unset j
    done
    unset i
}

</code></pre> 
<p>st-partitions-image.bbclass 整个文件看起来比较长，其实里面大部分都是调试日志。 总共有几部分组成：</p> 
<ol><li> <p>重要的三个变量<br> <strong>ENABLE_PARTITIONS_IMAGE</strong>:用来控制是否使能生成分区镜像，在镜像bb文件中可以覆盖此变量控制该class的功能<br> <strong>PARTITIONS_CONFIG</strong>：设置的分区配置<br> <strong>PARTITIONS_IMAGE</strong>：分区镜像的名字<br> <strong>PARTITIONS_MOUNTPOINT</strong>：分区镜像的挂载点</p> </li><li> <p>一个匿名函数<br> 以PARTITIONS_CONFIG 为输入，PARTITIONS_IMAGE 和PARTITIONS_MOUNTPOINT 为输出<br> 通过bitbake -e fs-mp1a-qt可以先看一下最终的变量值：</p> </li></ol> 
<pre><code>PARTITIONS_CONFIG=" bootfs vendorfs rootfs userfs"
//PARTITIONS_CONFIG[xxxfs] 字段含义
// "${STM32MP_XXFS_IMAGE},${STM32MP_XXFS_LABEL},${STM32MP_XXFS_MOUNTPOINT},${XXFS_PARTITION_SIZE},System"

PARTITIONS_CONFIG[bootfs]      ?= "st-image-bootfs,boot,/boot,65536,System"
PARTITIONS_CONFIG[vendorfs] ?= "st-image-vendorfs,vendorfs,/vendor,16384,FileSystem"
PARTITIONS_CONFIG[rootfs]       ?= "fs-mp1a-qt-openstlinux-eglfs,rootfs,1253376,FileSystem"
PARTITIONS_CONFIG[userfs]       ?= "st-image-userfs,userfs,/usr/local,131072,FileSystem"

PARTITIONS_IMAGE=" st-image-bootfs st-image-vendorfs st-image-userfs"
PARTITIONS_MOUNTPOINT=" /boot /vendor /usr/local"
</code></pre> 
<p>下面详细分析python __anonymous是怎么处理的：<br> 输入变量PARTITIONS_CONFIG：<br> PARTITIONS_CONFIG=" bootfs vendorfs rootfs userfs"<br> PARTITIONS_CONFIG[bootfs] ?= “st-image-bootfs,boot,/boot,65536,System”<br> PARTITIONS_CONFIG[vendorfs] ?= “st-image-vendorfs,vendorfs,/vendor,16384,FileSystem”<br> PARTITIONS_CONFIG[rootfs] ?= “fs-mp1a-qt-openstlinux-eglfs,rootfs,1253376,FileSystem”<br> PARTITIONS_CONFIG[userfs] ?= “st-image-userfs,userfs,/usr/local,131072,FileSystem”</p> 
<p>partitionsconfigflags：<br> bootfs “st-image-bootfs,boot,/boot,65536,System”<br> vendorfs “st-image-vendorfs,vendorfs,/vendor,16384,FileSystem”<br> rootfs “fs-mp1a-qt-openstlinux-eglfs,rootfs,1253376,FileSystem”<br> userfs “st-image-userfs,userfs,/usr/local,131072,FileSystem”</p> 
<p>partitionsconfig：<br> bootfs vendorfs rootfs userfs</p> 
<pre><code>        for config in partitionsconfig:
            for f, v in partitionsconfigflags.items():
                if config == f:
                    items = v.split(',')
</code></pre> 
<p>上面这段判断可以知道(以第一个bootfs为例) <strong>items</strong>= {st-image-bootfs boot /boot 65536 System }</p> 
<pre><code>                        if len(items) &gt; 2 and items[2]:
                            # Mount point available, so we're dealing with partition image
                            # PARTITIONS_IMAGE appending
                            bb.debug(1, "Appending '%s' to PARTITIONS_IMAGE." % items[0])
                            d.appendVar('PARTITIONS_IMAGE', ' ' + items[0])
                            # PARTITIONS_MOUNTPOINT appending
                            bb.debug(1, "Appending '%s' to PARTITIONS_MOUNTPOINT." % items[2])
                            d.appendVar('PARTITIONS_MOUNTPOINT', ' ' + items[2])
</code></pre> 
<p>如果items大于2且items[2]存在，则<br> PARTITIONS_IMAGE += items[0] //items[0] = st-image-bootfs<br> PARTITIONS_MOUNTPOINT += items[2] //items[2] = /boot</p> 
<p>如此循环下来：<br> PARTITIONS_IMAGE =" st-image-bootfs st-image-vendorfs fs-mp1a-qt-openstlinux-eglfs st-image-userfs"<br> PARTITIONS_MOUNTPOINT=" /boot /vendor rootfs /usr/local"</p> 
<p>这里PARTITIONS_MOUNTPOINT 和我们通过实际bitbake -e看到的环境变量对不上，我们接着往下分析</p> 
<pre><code>                        # Update IMAGE vars for each partition image
                        if items[1]:
                            bb.debug(1, "Set UBI_VOLNAME to %s for %s partition image." % (items[1], items[0]))
                            d.setVar('UBI_VOLNAME_pn-%s' % d.expand(items[0]), items[1])
                            if d.expand(items[1])[-2:] != 'fs':
                                bb.debug(1, "Set IMAGE_NAME_SUFFIX to '.%sfs' for %s partition image." % (items[1], items[0]))
                                d.setVar('IMAGE_NAME_SUFFIX_pn-%s' % d.expand(items[0]), '.' + items[1] + 'fs')
                            else:
                                bb.debug(1, "Set IMAGE_NAME_SUFFIX to '.%s' for %s partition image." % (items[1], items[0]))
                                d.setVar('IMAGE_NAME_SUFFIX_pn-%s' % d.expand(items[0]), '.' + items[1])
                        else:
                            bb.fatal('[PARTITIONS_CONFIG] Missing label setting for %s image' % items[0])
                        if items[2]:
                            bb.debug(1, "Set IMAGE_PARTITION_MOUNTPOINT to %s for %s partition image." % (items[2], items[0]))
                            d.setVar('IMAGE_PARTITION_MOUNTPOINT_pn-%s' % d.expand(items[0]), items[2])
                        if items[3]:
                            bb.debug(1, "Set IMAGE_ROOTFS_SIZE to %s for %s partition image." % (items[3], items[0]))
                            d.setVar('IMAGE_ROOTFS_SIZE_pn-%s' % d.expand(items[0]), items[3])
                        else:
                            bb.fatal('[PARTITIONS_CONFIG] Missing size setting for %s image' % items[0])
</code></pre> 
<ul><li>如果items[1]存在（以第一个bootfs为例）<br> UBI_VOLNAME_pn-st-image-bootfs=/boot</li><li>如果items[1]的最后2位不是fs结尾则手动添加fs结尾以后设置IMAGE_NAME_SUFFIX_pn变量<br> IMAGE_NAME_SUFFIX_pn-st-image-bootfs=.boot</li><li>如果items[2]存在<br> IMAGE_PARTITION_MOUNTPOINT_pn-st-image-bootfs=/boot</li><li>如果items[3]存在<br> IMAGE_ROOTFS_SIZE_pn-st-image-bootfs=65536</li></ul> 
<pre><code>                        # Manage IMAGE_SUMMARY_LIST configuration according to PARTITION_CONFIG set
                        if d.getVar('ENABLE_IMAGE_LICENSE_SUMMARY') == "1":
                            if not items[2]:
                                # Set '/' as default mountpoint for rootfs in IMAGE_SUMMARY_LIST
                                items[2] = '/'
                            image_summary_list += items[0] + ':' + items[2] + ';'

                        # Manage multiubi volume list STM32MP_UBI_VOLUME
                        if bb.utils.contains('IMAGE_FSTYPES', 'stmultiubi', True, False, d) and d.getVar('ENABLE_MULTIVOLUME_UBI') == "1":
                            bb.debug(1, "Appending '%s' image with %s size to STM32MP_UBI_VOLUME." % (items[0], items[3]))
                            d.appendVar('STM32MP_UBI_VOLUME', ' ' + items[0] + ':' + items[3])
                           
    # Reset IMAGE_LIST_SUMMARY with computed partition configuration
    if d.getVar('ENABLE_IMAGE_LICENSE_SUMMARY') == "1":
        bb.debug(1, "Set IMAGE_SUMMARY_LIST with configuration: %s." % image_summary_list)
        d.setVar('IMAGE_SUMMARY_LIST', image_summary_list)
</code></pre> 
<ul><li> <p>如果环境变量ENABLE_IMAGE_LICENSE_SUMMARY被设置<br> image_summary_list += st-image-bootfs:/boot;<br> 循环下来image_summary_list=“st-image-bootfs:/boot;st-image-vendorfs:/vendor;fs-mp1a-qt-openstlinux-eglfs:rootfs;st-image-userfs:/usr/local;”<br> IMAGE_SUMMARY_LIST = image_summary_list</p> </li><li> <p>如果IMAGE_FSTYPES 中包含stmultiubi类型且ENABLE_MULTIVOLUME_UBI变量被设置<br> STM32MP_UBI_VOLUME +=" st-image-bootfs:65536"<br> 循环下来STM32MP_UBI_VOLUME=" st-image-bootfs:65536 st-image-vendorfs:16384 fs-mp1a-qt-openstlinux-eglfs:1253376 st-image-userfs:131072"</p> </li></ul> 
<p>这里循环结束，总结一下设置了哪些变量：<br> PARTITIONS_IMAGE =" st-image-bootfs st-image-vendorfs fs-mp1a-qt-openstlinux-eglfs st-image-userfs"<br> PARTITIONS_MOUNTPOINT=" /boot /vendor rootfs /usr/local"</p> 
<pre><code>UBI_VOLNAME_pn-st-image-bootfs=/boot
IMAGE_NAME_SUFFIX_pn-st-image-bootfs=.boot
IMAGE_PARTITION_MOUNTPOINT_pn-st-image-bootfs=/boot
IMAGE_ROOTFS_SIZE_pn-st-image-bootfs=65536
</code></pre> 
<p>IMAGE_SUMMARY_LIST=“st-image-bootfs:/boot;st-image-vendorfs:/vendor;fs-mp1a-qt-openstlinux-eglfs:rootfs;st-image-userfs:/usr/local;”<br> STM32MP_UBI_VOLUME=" st-image-bootfs:65536 st-image-vendorfs:16384 fs-mp1a-qt-openstlinux-eglfs:1253376 st-image-userfs:131072"</p> 
<p>继续分析</p> 
<pre><code>    image_partitions = (d.getVar('PARTITIONS_IMAGE') or "").split()
    if len(image_partitions) &gt; 0:
        # Gather all current tasks
        tasks = filter(lambda k: d.getVarFlag(k, "task", True), d.keys())
        for task in tasks:
            # Check that we are dealing with image recipe
            if task == 'do_image_complete':
                # Init current image name
                current_image_name = d.getVar('PN') or ""
                # Init RAMFS image if any
                initramfs = d.getVar('INITRAMFS_IMAGE') or ""
                # Init INITRD image if any
                initrd = d.getVar('INITRD_IMAGE') or ""
                # We need to append partition images generation only to image
                # that are not one of the defined partitions and not the InitRAMFS image.
                # Without this check we would create circular dependency
                if current_image_name not in image_partitions and current_image_name != initramfs and current_image_name != initrd:
                    for partition in image_partitions:
                        bb.debug(1, "Appending %s image build to 'do_image_complete' depends tasks." % partition)
                        d.appendVarFlag('do_image_complete', 'depends', ' %s:do_image_complete' % partition)
                    bb.debug(1, "Appending 'image_rootfs_image_clean_task' to IMAGE_PREPROCESS_COMMAND.")
                    d.appendVar('IMAGE_PREPROCESS_COMMAND', 'image_rootfs_image_clean_task;')
                    # Manage multiubi volume build enable for current image
                    if bb.utils.contains('IMAGE_FSTYPES', 'stmultiubi', True, False, d) and d.getVar('ENABLE_MULTIVOLUME_UBI') == "1":
                        bb.debug(1, "Appending 'st_multivolume_ubifs' to IMAGE_POSTPROCESS_COMMAND.")
                        d.appendVar('IMAGE_POSTPROCESS_COMMAND', 'st_multivolume_ubifs;')
</code></pre> 
<p>image_partitions = [“st-image-bootfs”, “st-image-vendorfs”, “fs-mp1a-qt-openstlinux-eglfs”, “st-image-userfs” ]<br> 找到所有非initramfs 、initrd和 image_partitions中包含的image 的 do_image_complete的task，设置他们的依赖：<br> do_image_complete[depends] = st-image-bootfs:do_image_complete<br> do_image_complete[depends] = st-image-vendorfs:do_image_complete<br> do_image_complete[depends] = fs-mp1a-qt-openstlinux-eglfs:do_image_complete<br> do_image_complete[depends] = st-image-userfs:do_image_complete<br> IMAGE_POSTPROCESS_COMMAND+=st_multivolume_ubifs<br> 到这里，可以看到所有的iamge 菜谱生成进行必须先等image_partitions 中的镜像生成以后才可以生成。</p> 
<p>这部分分析结束，还有个疑问：bitbake中的变量里面没有rootfs相关的设置，但是分析下来是有的，这里等后续image生成流程都分析完了在回头看看是不是那里过滤掉了。<br> PARTITIONS_IMAGE=" st-image-bootfs st-image-vendorfs st-image-userfs"<br> PARTITIONS_MOUNTPOINT=" /boot /vendor /usr/local"</p> 
<p>PARTITIONS_IMAGE =" st-image-bootfs st-image-vendorfs fs-mp1a-qt-openstlinux-eglfs st-image-userfs"<br> PARTITIONS_MOUNTPOINT=" /boot /vendor rootfs /usr/local"</p> 
<ol start="3"><li>一个 task<br> image_rootfs_image_clean_task</li></ol> 
<p>最后还生名了一个task，里面比较简单：</p> 
<pre><code>    for img in ${PARTITIONS_IMAGE}; do
        i=$(expr $i + 1);
        for part in ${PARTITIONS_MOUNTPOINT}; do
            j=$(expr $j + 1);
            if [ $j -eq $i ]; then
                bbnote "Expecting to clean folder:"
                bbnote "&gt;&gt;&gt; ${IMAGE_ROOTFS}/$part"
                if [ -d ${IMAGE_ROOTFS}/$part ]; then
                    rm -rf ${IMAGE_ROOTFS}/$part/*
                    bbnote "&gt;&gt;&gt; DONE"
                else
                    bbnote "&gt;&gt;&gt; NOT DONE : $part folder doesn't exist in image rootfs"
                fi
            fi
        done
        unset j
    done
</code></pre> 
<p>最终效果就是把tmp-glibc/work/fsmp1a-ostl-linux-gnueabi/fs-mp1a-qt/1.0-r0/rootfs/boot/*删除（以bootfs为例）</p> 
<p>DONE</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b69918be0952b40af63d26ca5d75e0da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity3D UGUI文档</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6f250ba14cb2914688af2dfaae20551a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">YOLOv5_5.0训练自己的数据集</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>