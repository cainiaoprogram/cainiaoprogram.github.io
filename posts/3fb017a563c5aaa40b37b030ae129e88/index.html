<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>嵌出式学习又一天 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="嵌出式学习又一天" />
<meta property="og:description" content="关于485通讯
485属于串口通信，属于物理层的，规定为2线，半双工的多点通信标准，它的电气特性不一样，用缆线两端电压差值来表示传递信号，rs485仅仅规定了接收端和发送端的电气特性，没有规定任何数据协议。
rs485特点如下：
1.接口电平低，不易损坏芯片，接口信号电平比232低，不易损坏芯片，高电平1以两线的电压差表示2-6v 低电平以两线电压-（2-6）v表示，且该电平与TTL电平兼容（TTL电平信号规定，&#43;5V等价于逻辑“1”，0V等价于逻辑“0”）
2.传输速率高
3.抗干扰能力强
4.传输距离远
rs485可以用于线型和总线型，不可用于星形和环形
理想情况下485需要两个匹配电阻，其阻值一般要求等于传输电缆线的阻抗（一般为120Ω）
直流（DC） 交流（AC）
阻抗越小导电性能越好
PD7控制485的收发，当0表示接收 1表示发送
R14和R17是偏置电阻用来保证空闲的时候电压差大于200mv用来表示逻辑1，避免造成逻辑错乱
#include &#34;sys.h&#34; #include &#34;rs485.h&#34; #include &#34;delay.h&#34; #ifdef EN_USART2_RX //如果使能了接收 //接收缓存区 u8 RS485_RX_BUF[64]; //用一个数组来接收缓冲,最大 64 个字节. //接收到的数据长度 u8 RS485_RX_CNT=0; void USART2_IRQHandler(void)//中断处理事件 { u8 res; if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) //接收到数据 { res =USART_ReceiveData(USART2); //读取接收到的数据 if(RS485_RX_CNT&lt;64) { RS485_RX_BUF[RS485_RX_CNT]=res; //记录接收到的值 RS485_RX_CNT&#43;&#43;; //接收数据增加 1 } } } #endif //初始化 IO 串口 2 //bound:波特率 void RS485_Init(u32 bound) { GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOD, ENABLE); //使能 GPIOA,D 时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);//使能串口 2 时钟 GPIO_InitStructure." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3fb017a563c5aaa40b37b030ae129e88/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T00:57:14+08:00" />
<meta property="article:modified_time" content="2024-01-11T00:57:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌出式学习又一天</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>关于485通讯<br> 485属于串口通信，属于物理层的，规定为2线，半双工的多点通信标准，它的电气特性不一样，用缆线两端电压差值来表示传递信号，rs485仅仅规定了接收端和发送端的电气特性，没有规定任何数据协议。<br> rs485特点如下：<br> 1.接口电平低，不易损坏芯片，接口信号电平比232低，不易损坏芯片，高电平1以两线的电压差表示2-6v 低电平以两线电压-（2-6）v表示，且该电平与TTL电平兼容（TTL电平信号规定，+5V等价于逻辑“1”，0V等价于逻辑“0”）<br> 2.传输速率高<br> 3.抗干扰能力强<br> 4.传输距离远</p> 
<p>rs485可以用于线型和总线型，不可用于星形和环形</p> 
<p>理想情况下485需要两个匹配电阻，其阻值一般要求等于传输电缆线的阻抗（一般为120Ω）</p> 
<p>直流（DC） 交流（AC）<br> 阻抗越小导电性能越好</p> 
<p><img src="https://images2.imgbox.com/36/c6/8CGTAfAh_o.png" alt="32F1芯片与s485连接"><br> PD7控制485的收发，当0表示接收 1表示发送</p> 
<p>R14和R17是偏置电阻用来保证空闲的时候电压差大于200mv用来表示逻辑1，避免造成逻辑错乱</p> 
<pre><code class="prism language-bash"><span class="token comment">#include "sys.h" </span>
<span class="token comment">#include "rs485.h"</span>
<span class="token comment">#include "delay.h"</span>
<span class="token comment">#ifdef EN_USART2_RX //如果使能了接收</span>
//接收缓存区
u8 RS485_RX_BUF<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span> //用一个数组来接收缓冲,最大 <span class="token number">64</span> 个字节.
//接收到的数据长度
u8 <span class="token assign-left variable">RS485_RX_CNT</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> 
void USART2_IRQHandler<span class="token punctuation">(</span>void<span class="token punctuation">)</span>//中断处理事件
<span class="token punctuation">{<!-- --></span>
u8 res<span class="token punctuation">;</span> 
if<span class="token punctuation">(</span>USART_GetITStatus<span class="token punctuation">(</span>USART2, USART_IT_RXNE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span> //接收到数据
<span class="token punctuation">{<!-- --></span>
res <span class="token operator">=</span>USART_ReceiveData<span class="token punctuation">(</span>USART2<span class="token punctuation">)</span><span class="token punctuation">;</span> //读取接收到的数据
if<span class="token punctuation">(</span>RS485_RX_CNT<span class="token operator">&lt;</span><span class="token number">64</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
RS485_RX_BUF<span class="token punctuation">[</span>RS485_RX_CNT<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">;</span> //记录接收到的值
RS485_RX_CNT++<span class="token punctuation">;</span> //接收数据增加 <span class="token number">1</span> 
<span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 
<span class="token comment">#endif</span>
//初始化 IO 串口 <span class="token number">2</span>
//bound:波特率 
void RS485_Init<span class="token punctuation">(</span>u32 bound<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> 
GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>
USART_InitTypeDef USART_InitStructure<span class="token punctuation">;</span>
NVIC_InitTypeDef NVIC_InitStructure<span class="token punctuation">;</span>
RCC_APB2PeriphClockCmd<span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token operator">|</span>RCC_APB2Periph_GPIOD, ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> //使能 GPIOA,D 时钟
RCC_APB1PeriphClockCmd<span class="token punctuation">(</span>RCC_APB1Periph_USART2,ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>//使能串口 <span class="token number">2</span> 时钟
GPIO_InitStructure.GPIO_Pin <span class="token operator">=</span> GPIO_Pin_9<span class="token punctuation">;</span> //PG9 端口配置
GPIO_InitStructure.GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span> //推挽输出
GPIO_InitStructure.GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>
GPIO_Init<span class="token punctuation">(</span>GPIOD, <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>

GPIO_InitStructure.GPIO_Pin <span class="token operator">=</span> GPIO_Pin_2<span class="token punctuation">;</span> //PA2
GPIO_InitStructure.GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AF_PP<span class="token punctuation">;</span> //复用推挽
GPIO_Init<span class="token punctuation">(</span>GPIOA, <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
GPIO_InitStructure.GPIO_Pin <span class="token operator">=</span> GPIO_Pin_3<span class="token punctuation">;</span>//PA3
GPIO_InitStructure.GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IN_FLOATING<span class="token punctuation">;</span> //浮空输入
GPIO_Init<span class="token punctuation">(</span>GPIOA, <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>//等号以上常规配置时钟
RCC_APB1PeriphResetCmd<span class="token punctuation">(</span>RCC_APB1Periph_USART2,ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> //复位串口 <span class="token number">2</span>
RCC_APB1PeriphResetCmd<span class="token punctuation">(</span>RCC_APB1Periph_USART2,DISABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>//停止复位
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>//使能串口时钟
<span class="token comment">#ifdef EN_USART2_RX //如果使能了接收</span>
USART_InitStructure.USART_BaudRate <span class="token operator">=</span> bound<span class="token punctuation">;</span> //波特率设置<span class="token punctuation">;</span>
USART_InitStructure.USART_WordLength <span class="token operator">=</span> USART_WordLength_8b<span class="token punctuation">;</span>//8 位数据长度
USART_InitStructure.USART_StopBits <span class="token operator">=</span> USART_StopBits_1<span class="token punctuation">;</span> //一个停止位
USART_InitStructure.USART_Parity <span class="token operator">=</span> USART_Parity_No<span class="token punctuation">;</span> //奇偶校验位
<span class="token assign-left variable">USART_InitStructure.USART_HardwareFlowControl</span><span class="token operator">=</span> USART_HardwareFlowControl_None<span class="token punctuation">;</span> //无硬件数据流控制
USART_InitStructure.USART_Mode <span class="token operator">=</span> USART_Mode_Rx <span class="token operator">|</span> USART_Mode_Tx<span class="token punctuation">;</span>//收发
USART_Init<span class="token punctuation">(</span>USART2, <span class="token operator">&amp;</span>USART_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> //初始化串口
 
NVIC_InitStructure.NVIC_IRQChannel <span class="token operator">=</span> USART2_IRQn<span class="token punctuation">;</span> //使能串口 <span class="token number">2</span> 中断
NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> //先占优先级 <span class="token number">3</span> 级
NVIC_InitStructure.NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> //从优先级 <span class="token number">3</span> 级
NVIC_InitStructure.NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span> //使能外部中断通道
NVIC_Init<span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> //初始化 NVIC 寄存器
USART_ITConfig<span class="token punctuation">(</span>USART2, USART_IT_RXNE, ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> //开启中断
USART_Cmd<span class="token punctuation">(</span>USART2, ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> //使能串口
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>//常规中断配置
<span class="token comment">#endif</span>
<span class="token assign-left variable">RS485_TX_EN</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> //默认为接收模式
<span class="token punctuation">}</span>
//RS485 发送 len 个字节.
//buf:发送区首地址
//len:发送的字节数<span class="token punctuation">(</span>为了和本代码的接收匹配,这里建议不要超过 <span class="token number">64</span> 个字节<span class="token punctuation">)</span>
void RS485_Send_Data<span class="token punctuation">(</span>u8 *buf,u8 len<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
u8 t<span class="token punctuation">;</span>
<span class="token assign-left variable">RS485_TX_EN</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> //设置为发送模式
 for<span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>t<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>t++<span class="token punctuation">)</span> //循环发送数据
<span class="token punctuation">{<!-- --></span> 
while<span class="token punctuation">(</span>USART_GetFlagStatus<span class="token punctuation">(</span>USART2, USART_FLAG_TC<span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span> 
USART_SendData<span class="token punctuation">(</span>USART2,buf<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token punctuation">}</span>
while<span class="token punctuation">(</span>USART_GetFlagStatus<span class="token punctuation">(</span>USART2, USART_FLAG_TC<span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token assign-left variable">RS485_RX_CNT</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token assign-left variable">RS485_TX_EN</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> //设置为接收模式
<span class="token punctuation">}</span>
//RS485 查询接收到的数据
//buf:接收缓存首地址
//len:读到的数据长度
void RS485_Receive_Data<span class="token punctuation">(</span>u8 *buf,u8 *len<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
u8 <span class="token assign-left variable">rxlen</span><span class="token operator">=</span>RS485_RX_CNT<span class="token punctuation">;</span>
u8 <span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
*len<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> //默认为 <span class="token number">0</span>
delay_ms<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //等待 10ms,连续超过 10ms 没有接收到一个数据,则认为接收结束
if<span class="token punctuation">(</span>rxlen<span class="token operator">==</span>RS485_RX_CNT<span class="token operator">&amp;&amp;</span>rxlen<span class="token punctuation">)</span>//接收到了数据,且接收完成了
<span class="token punctuation">{<!-- --></span>
for<span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>rxlen<span class="token punctuation">;</span>i++<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>RS485_RX_BUF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
*len<span class="token operator">=</span>RS485_RX_CNT<span class="token punctuation">;</span> //记录本次数据长度
<span class="token assign-left variable">RS485_RX_CNT</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> //清零
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0700a067a6d8bc84b82c3295d4363cf7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【LeetCode】27. 移除元素（简单）——代码随想录算法训练营第1天</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f66b778676fdf45de2e30db264cbf681/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Nginx上对同一IP访问的特定URL进行限流</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>