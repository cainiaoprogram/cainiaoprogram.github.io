<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SCS【10】单细胞转录组之差异表达分析 (Monocle 3) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SCS【10】单细胞转录组之差异表达分析 (Monocle 3)" />
<meta property="og:description" content="点击关注，桓峰基因
桓峰基因公众号推出单细胞系列教程，有需要生信分析的老师可以联系我们！首选看下转录分析教程整理如下：
Topic 6. 克隆进化之 Canopy
Topic 7. 克隆进化之 Cardelino
Topic 8. 克隆进化之 RobustClone
SCS【1】今天开启单细胞之旅，述说单细胞测序的前世今生
SCS【2】单细胞转录组 之 cellranger
SCS【3】单细胞转录组数据 GEO 下载及读取
SCS【4】单细胞转录组数据可视化分析 (Seurat 4.0)
SCS【5】单细胞转录组数据可视化分析 (scater)
SCS【6】单细胞转录组之细胞类型自动注释 (SingleR)
SCS【7】单细胞转录组之轨迹分析 (Monocle 3) 聚类、分类和计数细胞
SCS【8】单细胞转录组之筛选标记基因 (Monocle 3)
SCS【9】单细胞转录组之构建细胞轨迹 (Monocle 3)
SCS【10】单细胞转录组之差异表达分析 (Monocle 3)
今天来说说单细胞转录组数据的细胞轨迹分析，学会这些分析结果，距离发文章就只差样本的选择了，有创新性的样本将成为文章的亮点，并不是分析内容了！
这期继续介绍 Monocle 3 软件包用于差异表达分析。
前 言 单细胞转录组测序(scRNA-seq)实验使我们能够发现新的细胞类型，并帮助我们了解它们是如何在发育过程中产生的。Monocle 3包提供了一个分析单细胞基因表达实验的工具包。
Monocle 3可以执行三种主要类型的分析:
聚类、分类和计数细胞。单细胞RNA-Seq实验允许发现新的(可能是罕见的)细胞亚型。
构建单细胞轨迹。在发育、疾病和整个生命过程中，细胞从一种状态过渡到另一种状态。Monocle 3可以发现这些转变。
差异表达分析。对新细胞类型和状态的描述，首先要与其他更容易理解的细胞进行比较。Monocle 3包括一个复杂的，但易于使用的表达系统。
工作流程图如下：
差异基因表达分析是RNA-Seq实验中的一项常见任务。Monocle可以帮助你找到细胞组之间表达差异的基因，并评估这些变化的统计意义。Monocle 3包含一个强大的系统，可以找到在不同类型的细胞中不同的基因，在不同的发育时间点收集的基因，或者以不同的方式被干扰的基因。
在Monocle中有两种差异分析方法:
回归分析:使用fit_models()，可以评估每个基因是否依赖于诸如时间、治疗等变量。
图自相关分析:使用 graph_test()，可以找到沿着轨迹或在簇之间变化的基因。
Monocle还具有寻找差异表达基因的协同调节模块的专门功能。Monocle还允许交互式地查询轨迹的特定 cluster或 partition (例如分支点)，以寻找其中变化的基因。
数据读取 expression_matrix &lt;- readRDS(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d79148d05665b7b789b119c6940dc100/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-15T15:34:50+08:00" />
<meta property="article:modified_time" content="2022-09-15T15:34:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SCS【10】单细胞转录组之差异表达分析 (Monocle 3)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/3d/b4/H5hxTIJi_o.gif" alt="图片"></p> 
<p>点击关注，桓峰基因</p> 
<p>桓峰基因公众号推出单细胞系列教程，有需要生信分析的老师可以联系我们！首选看下转录分析教程整理如下：</p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247483888&amp;idx=1&amp;sn=823811c2126938cf65fd94f5049ac58f&amp;chksm=fb79fb3bcc0e722d88f23f28bb23b6b6efd60668446c4cb2bac5cbf30020056a88a31e97aaec&amp;scene=21#wechat_redirect" rel="nofollow">Topic 6. 克隆进化之 Canopy</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247483897&amp;idx=1&amp;sn=6368eb8c4c554b2f9a94f53af7f3da37&amp;chksm=fb79fb32cc0e722455012fdac88dd1ff925c12deb4ee372ea6b47a5fec9875e49d437a004ce9&amp;scene=21#wechat_redirect" rel="nofollow">Topic 7. 克隆进化之 Cardelino</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247483907&amp;idx=1&amp;sn=b3019237edc67037dead18087e6feb9d&amp;chksm=fb79f8c8cc0e71deddd1570170c97cf928d2248c566f70f1f4117c9c86b997503cff9ebac082&amp;scene=21#wechat_redirect" rel="nofollow">Topic 8. 克隆进化之 RobustClone</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247487851&amp;idx=1&amp;sn=731575d593bae66aa91b29f49b6e5336&amp;chksm=fb79eba0cc0e62b68d36bac980962f6362f1d7b1dca033457604058175c60a9a455edd2d9c96&amp;scene=21#wechat_redirect" rel="nofollow">SCS【1】今天开启单细胞之旅，述说单细胞测序的前世今生</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247488337&amp;idx=1&amp;sn=5142015a512f03a29b7160fb5b9412d1&amp;chksm=fb79e99acc0e608c8afbfd45897667eb2f5dac7a205229a324c34753e188bdca7d97f6f9ca3f&amp;scene=21#wechat_redirect" rel="nofollow">SCS【2】单细胞转录组 之 cellranger</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247488386&amp;idx=1&amp;sn=64907558954c43f19e9e41c59508fe94&amp;chksm=fb79e949cc0e605f765c1a323f52e99340eab5b6c938dc72fa7b4bfba1e2f7b177926fff09b5&amp;scene=21#wechat_redirect" rel="nofollow">SCS【3】单细胞转录组数据 GEO 下载及读取</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247488454&amp;idx=1&amp;sn=eada05aadb85098fad116bd0211f0f76&amp;chksm=fb79e90dcc0e601b95218633a1519dc608c941141a665acae778667b1bb6531d3f63472e6496&amp;scene=21#wechat_redirect" rel="nofollow">SCS【4】单细胞转录组数据可视化分析 (Seurat 4.0)</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247488706&amp;idx=1&amp;sn=042eb3b7cd15844eb40db9cc32ccc63d&amp;chksm=fb79ee09cc0e671fccca8ca75e24ccf0dda78636ce236f1566ca1f99a02197cfa24d8fcb0cf0&amp;scene=21#wechat_redirect" rel="nofollow">SCS【5】单细胞转录组数据可视化分析 (scater)</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247488842&amp;idx=1&amp;sn=1819425966c31d320f12062344687c44&amp;chksm=fb79ef81cc0e6697144401543ff9ea981a4f1f4f9f39a0b029c36ac1408224f96639a6c7b71c&amp;scene=21#wechat_redirect" rel="nofollow">SCS【6】单细胞转录组之细胞类型自动注释 (SingleR)</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247488893&amp;idx=1&amp;sn=bc0e4eb66eb8ee42f9cc62d22dbfd726&amp;chksm=fb79efb6cc0e66a0db38f5168feb2c747158ba8a1d8e0b9d45faae6245563c20bd9b642fe5bf&amp;scene=21#wechat_redirect" rel="nofollow">SCS【7】单细胞转录组之轨迹分析 (Monocle 3) 聚类、分类和计数细胞</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247488963&amp;idx=1&amp;sn=ab7dd51c79234a1349d24ed4a8492d2a&amp;chksm=fb79ef08cc0e661efa477800ea0ff8518c7b841409985d7f8456c07a1baf040a2fc5c915759f&amp;scene=21#wechat_redirect" rel="nofollow">SCS【8】单细胞转录组之筛选标记基因 (Monocle 3)</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU0NDY2NTUwOA==&amp;mid=2247488996&amp;idx=1&amp;sn=281c4b3d1d1790cb44f0fec6bbdd9140&amp;chksm=fb79ef2fcc0e66399338113fc109a4155332082c579178b522541c402589094080152a29a081&amp;scene=21#wechat_redirect" rel="nofollow">SCS【9】单细胞转录组之构建细胞轨迹 (Monocle 3)</a></p> 
<p>SCS【10】单细胞转录组之差异表达分析 (Monocle 3)</p> 
<p>今天来说说单细胞转录组数据的细胞轨迹分析，学会这些分析结果，距离发文章就只差样本的选择了，有创新性的样本将成为文章的亮点，并不是分析内容了！</p> 
<hr> 
<p><strong>这期继续介绍 Monocle 3 软件包用于差异表达分析。</strong></p> 
<h3><a id="__________40"></a>前 言</h3> 
<p>单细胞转录组测序(scRNA-seq)实验使我们能够发现新的细胞类型，并帮助我们了解它们是如何在发育过程中产生的。Monocle 3包提供了一个分析单细胞基因表达实验的工具包。</p> 
<p>Monocle 3可以执行三种主要类型的分析:</p> 
<ol><li> <p>聚类、分类和计数细胞。单细胞RNA-Seq实验允许发现新的(可能是罕见的)细胞亚型。</p> </li><li> <p>构建单细胞轨迹。在发育、疾病和整个生命过程中，细胞从一种状态过渡到另一种状态。Monocle 3可以发现这些转变。</p> </li><li> <p>差异表达分析。对新细胞类型和状态的描述，首先要与其他更容易理解的细胞进行比较。Monocle 3包括一个复杂的，但易于使用的表达系统。</p> </li></ol> 
<p>工作流程图如下：</p> 
<p><img src="https://images2.imgbox.com/a1/4e/ig4JvnMH_o.png" alt="图片"></p> 
<p>差异基因表达分析是RNA-Seq实验中的一项常见任务。Monocle可以帮助你找到细胞组之间表达差异的基因，并评估这些变化的统计意义。Monocle 3包含一个强大的系统，可以找到在不同类型的细胞中不同的基因，在不同的发育时间点收集的基因，或者以不同的方式被干扰的基因。</p> 
<p>在Monocle中有两种差异分析方法:</p> 
<ol><li> <p>回归分析:使用fit_models()，可以评估每个基因是否依赖于诸如时间、治疗等变量。</p> </li><li> <p>图自相关分析:使用 graph_test()，可以找到沿着轨迹或在簇之间变化的基因。</p> </li></ol> 
<p>Monocle还具有寻找差异表达基因的协同调节模块的专门功能。Monocle还允许交互式地查询轨迹的特定 cluster或 partition (例如分支点)，以寻找其中变化的基因。</p> 
<h3><a id="_71"></a>数据读取</h3> 
<pre><code>expression_matrix &lt;- readRDS("packer_embryo_expression.rds")
cell_metadata &lt;- readRDS("packer_embryo_colData.rds")
gene_annotation &lt;- readRDS("packer_embryo_rowData.rds")

cds &lt;- new_cell_data_set(expression_matrix, cell_metadata = cell_metadata, gene_metadata = gene_annotation)

</code></pre> 
<h3><a id="_83"></a>数据集处理</h3> 
<pre><code>## Step 1: Normalize and pre-process the data
cds &lt;- preprocess_cds(cds, num_dim = 100)

## Step 2: Remove batch effects with cell alignment
cds &lt;- align_cds(cds, alignment_group = "batch")

## Step 3: Reduce the dimensions using 'UMAP', 'tSNE', 'PCA', 'LSI', 'Aligned'
cds &lt;- reduce_dimension(cds, reduction_method = "UMAP")

## Step 4: Cluster the cells
cds &lt;- cluster_cells(cds)

## Step 5: Learn a graph
cds &lt;- learn_graph(cds)

## Step 6: Order cells
cds &lt;- order_cells(cds)

</code></pre> 
<h4><a id="Regression_analysis_107"></a>Regression analysis</h4> 
<p>如何使用 Monocle 来查找根据几种不同标准差异表达的基因。对 cell_data_set 对象中的所有基因执行差异表达分析可能需要几分钟到几个小时，具体时间取决于分析的复杂程度。为了使小图简单快速，我们将使用小组基因。不过，请放心，Monocle可以分析数千个基因，甚至在大型实验中也可以分析，这使得有助于发现正在研究的生物过程中动态调节的基因。</p> 
<p>让我们从一小组在纤毛神经元中很重要的基因开始:</p> 
<pre><code>ciliated_genes &lt;- c("che-1", "hlh-17", "nhr-6", "dmd-6", "ceh-36", "ham-1")
cds_subset &lt;- cds[rowData(cds)$gene_short_name %in% ciliated_genes, ]

</code></pre> 
<p>Monocle 中的差异分析工具非常灵活。Monocle的工作原理是为每个基因拟合一个回归模型。可以指定这个模型来考虑实验中的各种因素(时间、治疗等)。例如，在胚胎数据中，细胞被收集在不同的时间点。我们可以测试上述基因的表达是否会随着时间的推移而发生变化，首先对每个基因拟合一个广义线性模型:</p> 
<p><img src="https://images2.imgbox.com/91/10/5YcuS2CC_o.png" alt="图片"></p> 
<p>y是有一个随机变量对应于基因I的表达值, xt是收集每个细胞的时间(以分钟为单位)，βt 捕捉时间对表达的影响，和β0 是截距项。我们可以通过将这个模型拟合到每一个基因上，来识别随时间变化的基因，然后测试是否βt明显不同于零。为此，我们首先调用fit_models()函数:</p> 
<pre><code>gene_fits &lt;- fit_models(cds_subset, model_formula_str = "~embryo.time")

</code></pre> 
<p>Gene_fits是包含每个基因一行的tibble。模型列包含广义线性模型对象，每个对象的目的是使用上面的方程解释基因在细胞中的表达。参数model_formula_str应该是一个指定模型公式的字符串。在测试中使用的模型公式可以包括colData表中作为列存在的任何术语，包括Monocle在其他分析步骤中添加的那些列。例如，如果您使用cluster_cells，您可以使用<sub>cluster或</sub>partition(分别)作为模型公式来测试cluster和partition之间的差异基因。还可以包含多个变量，例如~embryo。时间+批次，这对于减去不需要的效果非常有帮助。</p> 
<p>现在让我们看看这些基因中哪些有时间依赖性的表达。首先，我们使用argument_table()函数从每个模型中提取一个系数表:</p> 
<pre><code>fit_coefs &lt;- coefficient_table(gene_fits)

</code></pre> 
<p>请注意，表格中每个基因模型的每一项都包含一行。我们通常不关心截距项β0 ，所以我们可以很容易地提取时间项:</p> 
<pre><code>emb_time_terms &lt;- fit_coefs %&gt;%
    filter(term == "embryo.time")

</code></pre> 
<p>现在，让我们找出那些具有显著时间成分的基因。argument_table()测试在Wald检验下，每个系数是否显著不同于零。默认情况下，coefficient_table()使用Benjamini和Hochberg方法调整这些p值以进行多重假设检验。这些调整的值可以在q_value列中找到。我们可以对结果进行过滤，并控制误发现率如下:</p> 
<pre><code>emb_time_terms %&gt;%
    filter(q_value &lt; 0.05) %&gt;%
    select(gene_short_name, term, q_value, estimate)

</code></pre> 
<p>我们可以看到6个基因中的5个随着时间的变化而显著变化。</p> 
<p>Monocle还提供了一些简单的方法来绘制按差异分析中使用的因素分组的一小组基因的表达。这有助于将上面的测试显示的差异形象化。其中一种绘制方法是“小提琴”。</p> 
<pre><code>plot_genes_violin(cds_subset, group_cells_by = "embryo.time.bin", ncol = 2) + theme(axis.text.x = element_text(angle = 45,
    hjust = 1))

</code></pre> 
<p><img src="https://images2.imgbox.com/07/97/mj981yVz_o.png" alt="图片"></p> 
<h4><a id="Controlling_for_batch_effects_and_other_factors_168"></a>Controlling for batch effects and other factors</h4> 
<pre><code>gene_fits &lt;- fit_models(cds_subset, model_formula_str = "~embryo.time + batch")
fit_coefs &lt;- coefficient_table(gene_fits)
fit_coefs %&gt;%
    filter(term != "(Intercept)") %&gt;%
    select(gene_short_name, term, q_value, estimate)

</code></pre> 
<h4><a id="Evaluating_models_of_gene_expression_179"></a>Evaluating models of gene expression</h4> 
<p>这些模型在“解释”基因表达方面有多好? 我们可以使用evaluate_fits()函数来计算每个模型的适合度:</p> 
<pre><code>evaluate_fits(gene_fits)

</code></pre> 
<p>我们是否应该在我们的基因表达模型中包含批次? Monocle提供了一个compare_models()函数，可以帮助您做出决定。比较模型采用两个模型，并返回它们之间的似然比检验结果。每当您向模型添加术语时，它都会提高拟合性。但我们应该总是尽可能使用最简单的模型来解释我们的数据。似然比检验帮助我们确定拟合性的改善是否大到足以证明我们引入的额外术语的复杂性。像这样运行compare_models():</p> 
<pre><code>time_batch_models &lt;- fit_models(cds_subset, model_formula_str = "~embryo.time + batch",
    expression_family = "negbinomial")
time_models &lt;- fit_models(cds_subset, model_formula_str = "~embryo.time", expression_family = "negbinomial")
compare_models(time_batch_models, time_models) %&gt;%
    select(gene_short_name, q_value)

</code></pre> 
<p>两个模型中的第一个被称为完整模型。这个模型本质上是一种预测给定细胞中每个基因表达值的方法，既知道它是什么时候收集的，又知道它来自哪批细胞。第二个模型称为简化模型，它做同样的事情，但它只知道每个细胞被收集的时间。因为完整的模型有更多关于每个细胞的信息，它能更好地预测基因在每个细胞中的表达。Monocle必须为每个基因回答的问题是，完整模型的预测比简化模型的预测好多少。通过了解每个细胞的批次获得的改进越大，似然比检验的结果就越显著。</p> 
<p>我们可以看到，所有基因的似然比检验都是显著的，这表明数据中存在大量的批处理效应。因此，我们有理由将批处理项添加到模型中。</p> 
<h4><a id="Choosing_a_distribution_for_modeling_gene_expression_203"></a>Choosing a distribution for modeling gene expression</h4> 
<p>Monocle使用广义线性模型来捕捉基因的表达如何依赖于实验中的每个变量。这些模型要求您指定一个描述基因表达值的分布。大多数使用这种方法分析基因表达数据的研究使用负二项分布，这通常适用于测序读取或UMI计数数据。负二项式是许多RNA-seq分析包的核心，如DESeq2。</p> 
<p>Monocle的fit_models()支持负二项分布和下表中列出的其他几个分布。默认值是“拟泊松”，它与负二项式非常相似。与负二项式相比，Quasipoisson的精度略低，但拟合速度快得多，这使得它非常适合具有数千个细胞的数据集。</p> 
<p>expression_family有几个允许的值:</p> 
<pre><code>quasipoisson	Quasi-poisson	++	++	Default for fit_models(). Recommended for most users.
negbinomial	Negative binomial	+++	+	Recommended for users with small datasets (fewer than 1,000 cells).
poisson	Poisson	-	+++	Not recommended. For debugging and testing only.
binomial	Binomial	++	++	Recommended for single-cell ATAC-seq

</code></pre> 
<h4><a id="Finding_genes_that_change_as_a_function_of_pseudotime_219"></a>Finding genes that change as a function of pseudotime</h4> 
<p>这种分析的核心目标是识别随着细胞沿轨迹发展而发生变化的基因。了解基因启动和关闭的顺序可以为新的发育模式提供信息。例如，Sharon和Chawla等人最近分析了拟时间依赖基因，得出了胰岛如何在胰腺中形成的全新模型。</p> 
<p>让我们看看胚胎数据:</p> 
<pre><code>plot_cells(cds, color_cells_by = "cell.type", label_groups_by_cluster = FALSE, label_leaves = FALSE,
    label_branch_points = FALSE)

</code></pre> 
<p><img src="https://images2.imgbox.com/e1/99/pJMHOIJv_o.png" alt="图片"></p> 
<ol><li> <p>我们如何找到在不同路径上不同表达的基因?</p> </li><li> <p>我们如何找到那些被限制在轨迹起点的?</p> </li><li> <p>还是被排除在外?</p> </li></ol> 
<p>再次，我们转向graph_test()，这一次传递给它neighbor_graph=“principal_graph”，这告诉它测试轨迹上相似位置的单元格是否有相关表达式:</p> 
<pre><code>ciliated_cds_pr_test_res &lt;- graph_test(cds, neighbor_graph = "principal_graph", cores = 4)
pr_deg_ids &lt;- row.names(subset(ciliated_cds_pr_test_res, q_value &lt; 0.05))

</code></pre> 
<p>下面是graph_test()给出的一些非常重要的有趣基因:</p> 
<pre><code>plot_cells(cds, genes = c("hlh-4", "gcy-8", "dac-1", "oig-8"), show_trajectory_graph = FALSE,
    label_cell_groups = FALSE, label_leaves = FALSE)

</code></pre> 
<p><img src="https://images2.imgbox.com/e7/1a/OUhbPIhD_o.png" alt="图片"></p> 
<p>和前面一样，我们可以将轨迹可变的基因收集到模块中:</p> 
<pre><code>gene_module_df &lt;- find_gene_modules(cds[pr_deg_ids, ], resolution = c(10^seq(-6,
    -1)))

</code></pre> 
<p>在这里，我们绘制了Packer和Zhu等人注释的每组细胞类型的模块总分:</p> 
<pre><code>cell_group_df &lt;- tibble::tibble(cell = row.names(colData(cds)), cell_group = colData(cds)$cell.type)
agg_mat &lt;- aggregate_gene_expression(cds, gene_module_df, cell_group_df)
row.names(agg_mat) &lt;- stringr::str_c("Module ", row.names(agg_mat))
pheatmap::pheatmap(agg_mat, scale = "column", clustering_method = "ward.D2")

</code></pre> 
<p><img src="https://images2.imgbox.com/47/a2/hCVMsoPM_o.png" alt="图片"></p> 
<p>我们还可以将gene_module_df传递给plot_cells()。</p> 
<pre><code>plot_cells(cds, genes = gene_module_df %&gt;%
    filter(module %in% c(27, 10, 7, 30)), label_cell_groups = FALSE, show_trajectory_graph = FALSE)

</code></pre> 
<p><img src="https://images2.imgbox.com/de/30/u9GWZlsp_o.png" alt="图片"></p> 
<p>Monocle提供了另一个绘图功能，有时可以更清楚地看到基因沿单一路径的动态。您可以使用choose_cells()选择一个路径，也可以通过按cluster、细胞类型或其他限制于该路径的注释对细胞数据集进行子集设置。让我们选择一个这样的路径，AFD细胞:</p> 
<pre><code>AFD_genes &lt;- c("gcy-8", "dac-1", "oig-8")
AFD_lineage_cds &lt;- cds[rowData(cds)$gene_short_name %in% AFD_genes, colData(cds)$cell.type %in%
    c("AFD")]

</code></pre> 
<p>函数plot_genes_in_pseudotime()取一小组基因，并显示它们作为拟时间函数的动态，你可以看到dac -1在其他两个基因之前被激活。</p> 
<pre><code>plot_genes_in_pseudotime(AFD_lineage_cds, color_cells_by = "embryo.time.bin", min_expr = 0.5)

</code></pre> 
<p><img src="https://images2.imgbox.com/ec/78/hA27vVwm_o.png" alt="图片"></p> 
<h4><a id="Analyzing_branches_in_singlecell_trajectories_306"></a>Analyzing branches in single-cell trajectories</h4> 
<p>分析在轨迹分支点周围被调节的基因通常可以帮助我们深入了解控制细胞命运决定的遗传回路。Monocle可以萃取与系统中的命运决定相对应的分支点。这样做就像选择感兴趣的细胞(和分支点)一样简单choose_cells():</p> 
<pre><code>cds_subset &lt;- choose_cells(cds)

</code></pre> 
<p><img src="https://images2.imgbox.com/56/a1/8bzOJoiU_o.gif" alt="图片"></p> 
<p>然后在子集上调用graph_test()。这将识别出具有有趣的表达模式的基因，这些基因只在您所选择的轨迹区域内，从而为您提供更精确和相关的基因集。</p> 
<pre><code>subset_pr_test_res &lt;- graph_test(cds_subset, neighbor_graph = "principal_graph",
    cores = 4)
pr_deg_ids &lt;- row.names(subset(subset_pr_test_res, q_value &lt; 0.05))

</code></pre> 
<p>将这些基因分组到模块中可以揭示命运特定基因或那些在分支点之前或之后立即被激活的基因:</p> 
<pre><code>gene_module_df &lt;- find_gene_modules(cds_subset[pr_deg_ids, ], resolution = 0.001)

</code></pre> 
<p>我们将根据模块在轨迹上的相似度(使用hclust)来组织模块，这样更容易看到哪些模块先于其他模块启动:</p> 
<pre><code>agg_mat &lt;- aggregate_gene_expression(cds_subset, gene_module_df)
module_dendro &lt;- hclust(dist(agg_mat))
gene_module_df$module &lt;- factor(gene_module_df$module, levels = row.names(agg_mat)[module_dendro$order])

plot_cells(cds_subset, genes = gene_module_df, label_cell_groups = FALSE, show_trajectory_graph = FALSE)

</code></pre> 
<p><img src="https://images2.imgbox.com/e1/3a/HcXWyuqL_o.png" alt="图片"></p> 
<h4><a id="Graphautocorrelation_analysis_for_comparing_clusters_346"></a>Graph-autocorrelation analysis for comparing clusters</h4> 
<p>在L2蠕虫的数据中，我们发现了一些非常独特的神经元聚类:</p> 
<pre><code># reload and reprocess the data as described in the 'Clustering and classifying
# your cells' section
expression_matrix &lt;- readRDS("cao_l2_expression.rds")
cell_metadata &lt;- readRDS("cao_l2_colData.rds")
gene_annotation &lt;- readRDS("cao_l2_rowData.rds")

# Make the CDS object
cds &lt;- new_cell_data_set(expression_matrix, cell_metadata = cell_metadata, gene_metadata = gene_annotation)
cds &lt;- preprocess_cds(cds, num_dim = 100)
cds &lt;- reduce_dimension(cds)
cds &lt;- cluster_cells(cds, resolution = 1e-05)

colData(cds)$assigned_cell_type &lt;- as.character(partitions(cds))
colData(cds)$assigned_cell_type &lt;- dplyr::recode(colData(cds)$assigned_cell_type,
    `1` = "Body wall muscle", `2` = "Germline", `3` = "Motor neurons", `4` = "Seam cells",
    `5` = "Sex myoblasts", `6` = "Socket cells", `7` = "Marginal_cell", `8` = "Coelomocyte",
    `9` = "Am/PH sheath cells", `10` = "Ciliated neurons", `11` = "Intestinal/rectal muscle",
    `12` = "Excretory gland", `13` = "Chemosensory neurons", `14` = "Interneurons",
    `15` = "Unclassified eurons", `16` = "Ciliated neurons", `17` = "Pharyngeal gland cells",
    `18` = "Unclassified neurons", `19` = "Chemosensory neurons", `20` = "Ciliated neurons",
    `21` = "Ciliated neurons", `22` = "Inner labial neuron", `23` = "Ciliated neurons",
    `24` = "Ciliated neurons", `25` = "Ciliated neurons", `26` = "Hypodermal cells",
    `27` = "Mesodermal cells", `28` = "Motor neurons", `29` = "Pharyngeal gland cells",
    `30` = "Ciliated neurons", `31` = "Excretory cells", `32` = "Amphid neuron",
    `33` = "Pharyngeal muscle")


# Reload and re-process the data as described in the 'Clustering and
# classifying your cells' section In some clusters the majority of cells may
# have NA as the cell type so use this function with caution.
consensus &lt;- function(x) {
    uniqx &lt;- unique(na.omit(x))
    uniqx[which.max(tabulate(match(x, uniqx)))]
}

l_partition &lt;- unique(partitions(cds))
l_cell_type &lt;- list()
for (i_partition in l_partition) {
    l_cell_type[as.character(i_partition)] &lt;- consensus(colData(cds)[partitions(cds) ==
        i_partition, ][["cao_cell_type"]])
}
colData(cds)[["assigned_cell_type"]] &lt;- as.character(l_cell_type[as.character(partitions(cds))])

</code></pre> 
<p>只对神经元进行子集:</p> 
<pre><code>neurons_cds &lt;- cds[, grepl("neurons", colData(cds)$assigned_cell_type, ignore.case = TRUE)]
plot_cells(neurons_cds, color_cells_by = "partition")

</code></pre> 
<p><img src="https://images2.imgbox.com/a5/80/5MUWzdBQ_o.png" alt="图片"></p> 
<p>神经元有许多子类型，所以可能不同的神经元簇对应不同的子类型。为了研究哪些基因在cluster中表达差异，我们可以使用上面讨论的回归分析工具。然而，Monocle提供了一种寻找UMAP或t-SNE空间中不同细胞组间差异基因的替代方法。函数graph_test()使用了来自空间自相关分析的统计数据，称为Moran’s I, Cao和Spielmann等人证明该统计数据可以有效地发现单细胞RNA-seq数据集中变化的基因。</p> 
<p>你可以像这样运行graph_test():</p> 
<pre><code>pr_graph_test_res &lt;- graph_test(neurons_cds, neighbor_graph = "knn", cores = 8)
pr_deg_ids &lt;- row.names(subset(pr_graph_test_res, q_value &lt; 0.05))

</code></pre> 
<p>数据框pr_graph_test_res包含cell_data_set中每个基因的Moran’s I测试结果。如果您想按效应大小对基因进行排序，请按morans_Icolumn对该表进行排序，其范围从-1到+1。值为0表示没有影响，而+1表示完全正自相关，表明附近的细胞具有非常相似的基因表达值。远小于零的显著值通常很少。</p> 
<p>阳性值表示基因在UMAP空间的一个焦点区域表达(例如，特定于一个或多个簇)。但是我们如何把基因和簇联系起来呢?</p> 
<h4><a id="Finding_modules_of_coregulated_genes_420"></a>Finding modules of co-regulated genes</h4> 
<p>一旦有了一组基因，在簇中以某种有趣的方式发生变化，Monocle就提供了一种将它们分组为模块的方法。你可以调用find_gene_modules()，它实际上是在基因上运行UMAP(与细胞相反)，然后使用Louvain社区分析将它们分组到模块中:</p> 
<pre><code>gene_module_df &lt;- find_gene_modules(neurons_cds[pr_deg_ids, ], resolution = 0.01)

</code></pre> 
<p>数据帧gene_module_df包含每个基因的一行，并标识它所属的模块。要查看哪些模块在哪些集群或分区中表示，可以使用两种不同的可视化方法。第一种方法是制作一个简单的表，显示所有集群中每个模块中所有基因的聚合表达。Monocle为此提供了一个简单的实用函数aggregate_gene_expression:</p> 
<pre><code>cell_group_df &lt;- tibble::tibble(cell = row.names(colData(neurons_cds)), cell_group = partitions(cds)[colnames(neurons_cds)])
agg_mat &lt;- aggregate_gene_expression(neurons_cds, gene_module_df, cell_group_df)
row.names(agg_mat) &lt;- stringr::str_c("Module ", row.names(agg_mat))
colnames(agg_mat) &lt;- stringr::str_c("Partition ", colnames(agg_mat))

pheatmap::pheatmap(agg_mat, cluster_rows = TRUE, cluster_cols = TRUE, scale = "column",
    clustering_method = "ward.D2", fontsize = 6)

</code></pre> 
<p><img src="https://images2.imgbox.com/6c/ad/pJFqhjqr_o.png" alt="图片"></p> 
<p>有些模块高度特定于单元的某些分区，而其他模块则跨多个分区共享。注意，aggregate_gene_expression可以用于细胞和基因的任意分组。您不局限于查看来自find_gene_modules()、clusters()和partitions()的模块。</p> 
<p>查看模块及其表达式的第二种方法是将gene_module_df直接传递给plot_cells()。如果有很多模块，就很难看到每个模块在哪里表示，所以我们只看它们的一个子集:</p> 
<pre><code>plot_cells(neurons_cds, genes = gene_module_df %&gt;%
    filter(module %in% c(8, 28, 33, 37)), group_cells_by = "partition", color_cells_by = "partition",
    show_trajectory_graph = FALSE)

</code></pre> 
<p><img src="https://images2.imgbox.com/dc/25/Rxz7jxn7_o.png" alt="图片"></p> 
<p>我们这期主要介绍差异表达分析，内容过多，一次完成有点太乱了，目前单细胞测序的费用也在降低，单细胞系列可算是目前的测序神器，有这方面需求的老师，联系桓峰基因，提供最高端的科研服务！</p> 
<p>桓峰基因，铸造成功的您！</p> 
<p>未来桓峰基因公众号将不间断的推出单细胞系列生信分析教程，</p> 
<p>敬请期待！！</p> 
<p>有想进生信交流群的老师可以扫最后一个二维码加微信，备注“单位+姓名+目的”，有些想发广告的就免打扰吧，还得费力气把你踢出去！</p> 
<h5><a id="References_471"></a>References:</h5> 
<ol><li> <p>Trapnell C. et. al. The dynamics and regulators of cell fate decisions are revealed by pseudotemporal ordering of single cells. Nat. Biotechnol. 32, 381-386 (2014).</p> </li><li> <p>Qiu, X. et. al. Reversed graph embedding resolves complex single-cell trajectories. Nat. Methods 14, 979-982 (2017).</p> </li><li> <p>Cao, J. et. al. The single-cell transcriptional landscape of mammalian organogenesis. Nature 566, 496-502 (2019).</p> </li><li> <p>Haghverdi, L. et. al. Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors. Nat. Biotechnol. 36, 421-427 (2018).</p> </li><li> <p>McInnes, L., Healy, J. &amp; Melville, J. UMAP: Uniform Manifold Approximation and Projection for dimension reduction. Preprint at https://arxiv.org/abs/1802.03426 (2018).</p> </li><li> <p>Traag, V.A., Waltman, L. &amp; van Eck, N.J. From Louvain to Leiden: guaranteeing well-connected communities. Scientific Reportsvolume 9, Article number: 5233 (2019).</p> </li><li> <p>Levine, J. H. et. al. Data-driven phenotypic dissection of AML reveals progenitor-like cells that correlate with prognosis. Cell 162, 184-197 (2015).</p> </li><li> <p>Levine, J. H., et. al. Data-driven phenotypic dissection of AML reveals progenitor-like cells that correlate with prognosis. Cell 162, 184-197 (2015).</p> </li></ol> 
<p><img src="https://images2.imgbox.com/4c/ae/0PoOziwA_o.gif" alt="图片"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88039c6d0657c40e5ca5fb0bc49f00e1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">高性能 Java 计算服务的性能调优实战</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de62b49ee24459e64ef5546c34facf26/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">88：第七章：开发前台首页、作家个人展示页、粉丝等功能：9：【前台，作家中心，分页查看粉丝列表，接口】；（注意点：简单的条件查询，不一定非得使用tkmybatis的Example的；）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>