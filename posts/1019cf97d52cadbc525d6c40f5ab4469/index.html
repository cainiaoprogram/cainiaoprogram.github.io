<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【深入理解计算机系统 第三版 导读】第六章 存储器的层次结构 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【深入理解计算机系统 第三版 导读】第六章 存储器的层次结构" />
<meta property="og:description" content="第六章 存储器的层次结构 文章目录 第六章 存储器的层次结构1. 存储技术1.1. 随机访问存储器1.1.1. 层次结构1.1.2. 随机访问存储器1.1.3. DRAM内存模块 1.2. 磁盘存储1.2.1. 磁盘构造1.2.2. 磁盘容量1.2.3. 磁盘操作1.2.4. 时间估计1.2.5. 练习题 1.3. 固态硬盘 2. 局部性3. 存储器层次结构3.1. 存储器层次结构中的缓存 4. 高速缓存存储器4.1. 通用的高速缓存存储器组织结构4.2. 直接映射高速缓存4.3. 组相联高速缓存4.4. 全相联高速缓存 5. 后记 在本章中我们会看看基本的存储技术——SRAM存储器、DRAM存储器、ROM存储器以及旋转的和固态的硬盘——并描述它们是如何被组织成层次结构的
1. 存储技术 1.1. 随机访问存储器 1.1.1. 层次结构 如果程序需要的数据是存储在CPU寄存器中的，那么在指令的执行期间，在0个时钟周期就可以访问到它们，如果存储在高速缓存中，需要4-75个周期，如果存储在主存中，需要上百个周期，而如果存储在磁盘上，需要大约几千万个周期。
1.1.2. 随机访问存储器 随机访问存储器RAM分为两类：静态的和动态的。静态的SRAM比动态的DRAM更快，但也更贵。SRAM用来作为高速缓存存储器可以在CPU芯片上也可以在片下。一个桌面系统的SRAM不会超过几兆字节，但是DRAM却有几百或几千兆字节。
SRAM：SRAM将每一个位存储在一个双稳态的存储单元里，每个单元是用一个六晶体管电路来实现的。这个电路有一个属性，它可以无限期保持在两个不同电压配置或状态之一。从不稳定的状态开始，电路会迅速转移到两个稳定状态中的一个——双稳态特性，由于SRAM存储器单元具有双稳态特性，只要有电，他就会永远保持它的值(0或1)，即使有干扰，当干扰消除时，电路也会恢复到它的稳定值——抗干扰。
DRAM：DRAM使用非常小的电容来存储每个位，电容的典型值是几十毫微微法拉；由于电容容易漏电所以DRAM需要周期性地刷新来维持存储的数据(计算机运行的时钟周期是以纳秒来衡量的，DRAM漏电是在几十毫秒内)；DRAM 单元由一个晶体管和一个电容组成，因此它能够以更高的密度存储更多的数据，但这也意味着它的速度较慢。
常规的DRAM： 为了读出超单元(i,j)的内容，内存控制器将行地址i(RAS)和列地址j(CAS)发送到DRAM，DRAM把相应的内容发回给控制器作为相应。过程：发送行地址i，然后DRAM将整个行复制到一个内部行缓冲区，再发送列地址j，最后DRAM从内部行缓冲区中复制相应的内容发送到内存控制器（为什么这样设计：DRAM芯片是一个二维的，而不是一个线性的数组，通过这样来获取数据，可以减少芯片上地址引脚的数量，但会增加数据的访问时间）。每个超单元可以存储8bit的数据。
1.1.3. DRAM内存模块 图中展示了一个内存模块，示例用8个DRAM芯片。每个DRAM芯片大小是8M×8，也就是8MB，所以这个内存模块是64MB的。每个超单元可以存储8bit的数据，那么对于8字节的数据就要使用8个超单元来存储。不过这8个超单元并不在同一个DRAM芯片上，而是平均分布在8个DRAM芯片上，其中DRAM0存储低8位，DRAM1存储下一个8位，以此类推。内存控制器需要这些数据时，会发送行地址和列地址，然后内存模块会将行地址和列地址广播到每个DRAM，每个DRAM都会输出它们对应的超单元数据，最终内存模块会将所有超单元的数据合并成一个64bit的数据返回给内存控制器。
1.2. 磁盘存储 前面的随机访问存储器是在有点的情况下才能存储信息，而磁盘存储在断电的情况下也能保存信息。
1.2.1. 磁盘构造 磁盘是由多个盘片构成的，每个盘片都有两面被称为表面，表面覆盖了磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常是5400-15000转每分钟(RPM)。磁盘表面存在着一组被称为磁道的同心圆，磁道以主轴为中心向外扩散，每个磁道被分为一组扇区，每个扇区包含相等的数据位，通常是512字节，这些数据被编码在扇区的磁性材料中。扇区之间用一些间隙分隔开，这些间隙中不存储数据位，而是用来存储扇区的格式化位。
1.2.2. 磁盘容量 记录密度：位/英寸 磁道一英寸的段中可以放入的位数。磁道密度：到/英寸 从盘片中心出发半径上一英寸的段内可以有的磁道数。面密度：位/平方英寸 记录密度与磁道密度的乘积。 1.2.3. 磁盘操作 磁盘用读/写头来读写存储在磁性表面的位，读写头在一个传动臂上，它们的运动叫做寻道。一旦读写头定位到了期望的磁道上，那么当磁道上的每一个位通过它下面时，读写头可以感知，也可以修改有多个盘片的磁盘针对于每一个盘面都有一个独立的读写头，读写头垂直排列，一致行动。 1.2.4. 时间估计 对扇区的访问时间有三个主要的部分：寻道时间、旋转时间、传送时间。
寻道时间：平均寻道时间是3~9ms，最高可达20ms。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1019cf97d52cadbc525d6c40f5ab4469/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-10T23:49:14+08:00" />
<meta property="article:modified_time" content="2024-01-10T23:49:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【深入理解计算机系统 第三版 导读】第六章 存储器的层次结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="__0"></a>第六章 存储器的层次结构</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#__0" rel="nofollow">第六章 存储器的层次结构</a></li><li><ul><li><a href="#1__6" rel="nofollow">1. 存储技术</a></li><li><ul><li><a href="#11__8" rel="nofollow">1.1. 随机访问存储器</a></li><li><ul><li><a href="#111__10" rel="nofollow">1.1.1. 层次结构</a></li><li><a href="#112__17" rel="nofollow">1.1.2. 随机访问存储器</a></li><li><a href="#113_DRAM_35" rel="nofollow">1.1.3. DRAM内存模块</a></li></ul> 
    </li><li><a href="#12__42" rel="nofollow">1.2. 磁盘存储</a></li><li><ul><li><a href="#121__46" rel="nofollow">1.2.1. 磁盘构造</a></li><li><a href="#122__53" rel="nofollow">1.2.2. 磁盘容量</a></li><li><a href="#123__62" rel="nofollow">1.2.3. 磁盘操作</a></li><li><a href="#124__71" rel="nofollow">1.2.4. 时间估计</a></li><li><a href="#125__93" rel="nofollow">1.2.5. 练习题</a></li></ul> 
    </li><li><a href="#13__101" rel="nofollow">1.3. 固态硬盘</a></li></ul> 
   </li><li><a href="#2__110" rel="nofollow">2. 局部性</a></li><li><a href="#3__120" rel="nofollow">3. 存储器层次结构</a></li><li><ul><li><a href="#31__128" rel="nofollow">3.1. 存储器层次结构中的缓存</a></li></ul> 
   </li><li><a href="#4__145" rel="nofollow">4. 高速缓存存储器</a></li><li><ul><li><a href="#41__147" rel="nofollow">4.1. 通用的高速缓存存储器组织结构</a></li><li><a href="#42__159" rel="nofollow">4.2. 直接映射高速缓存</a></li><li><a href="#43__167" rel="nofollow">4.3. 组相联高速缓存</a></li><li><a href="#44__171" rel="nofollow">4.4. 全相联高速缓存</a></li></ul> 
   </li><li><a href="#5__175" rel="nofollow">5. 后记</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>在本章中我们会看看基本的存储技术——SRAM存储器、DRAM存储器、ROM存储器以及旋转的和固态的硬盘——并描述它们是如何被组织成层次结构的</p> 
<h3><a id="1__6"></a>1. 存储技术</h3> 
<h4><a id="11__8"></a>1.1. 随机访问存储器</h4> 
<h5><a id="111__10"></a>1.1.1. 层次结构</h5> 
<p><img src="https://images2.imgbox.com/70/c7/UYCdOwCr_o.png" alt="在这里插入图片描述"></p> 
<p>如果程序需要的数据是存储在CPU寄存器中的，那么在指令的执行期间，在0个时钟周期就可以访问到它们，如果存储在高速缓存中，需要4-75个周期，如果存储在主存中，需要上百个周期，而如果存储在磁盘上，需要大约几千万个周期。</p> 
<h5><a id="112__17"></a>1.1.2. 随机访问存储器</h5> 
<p>随机访问存储器RAM分为两类：静态的和动态的。静态的SRAM比动态的DRAM更快，但也更贵。SRAM用来作为高速缓存存储器可以在CPU芯片上也可以在片下。一个桌面系统的SRAM不会超过几兆字节，但是DRAM却有几百或几千兆字节。</p> 
<ul><li> <p>SRAM：SRAM将<strong>每一个位存储在一个双稳态的存储单元</strong>里，<strong>每个单元是用一个六晶体管电路</strong>来实现的。这个电路有一个属性，它可以无限期保持在两个不同电压配置或状态之一。从不稳定的状态开始，电路会迅速转移到两个稳定状态中的一个——<strong>双稳态特性</strong>，由于SRAM存储器单元具有双稳态特性，<strong>只要有电，他就会永远保持它的值(0或1)</strong>，即使有干扰，当干扰消除时，电路也会恢复到它的稳定值——抗干扰。</p> </li><li> <p>DRAM：DRAM使用非常小的电容来存储每个位，电容的典型值是几十毫微微法拉；由于电容容易漏电所以DRAM需要周期性地刷新来维持存储的数据(计算机运行的时钟周期是以纳秒来衡量的，DRAM漏电是在几十毫秒内)；DRAM 单元由一个晶体管和一个电容组成，因此它能够以更高的密度存储更多的数据，但这也意味着它的速度较慢。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/17/d9/AR9BWL28_o.png" alt="在这里插入图片描述"></p> 
<ul><li>常规的DRAM：</li></ul> 
<p><img src="https://images2.imgbox.com/a6/dc/A9Uet7nF_o.png" alt="在这里插入图片描述"></p> 
<p>为了读出超单元(i,j)的内容，内存控制器将行地址i(RAS)和列地址j(CAS)发送到DRAM，DRAM把相应的内容发回给控制器作为相应。过程：发送行地址i，然后DRAM将整个行复制到一个内部行缓冲区，再发送列地址j，最后DRAM从内部行缓冲区中复制相应的内容发送到内存控制器（为什么这样设计：DRAM芯片是一个二维的，而不是一个线性的数组，通过这样来获取数据，可以减少芯片上地址引脚的数量，但会增加数据的访问时间）。<strong>每个超单元可以存储8bit的数据</strong>。</p> 
<h5><a id="113_DRAM_35"></a>1.1.3. DRAM内存模块</h5> 
<p><img src="https://images2.imgbox.com/00/37/2oB897S4_o.png" alt="在这里插入图片描述"></p> 
<p>图中展示了一个内存模块，示例用8个DRAM芯片。每个DRAM芯片大小是8M×8，也就是8MB，所以这个内存模块是64MB的。每个超单元可以存储8bit的数据，那么对于8字节的数据就要使用8个超单元来存储。不过这8个超单元并不在同一个DRAM芯片上，而是平均分布在8个DRAM芯片上，其中DRAM0存储低8位，DRAM1存储下一个8位，以此类推。内存控制器需要这些数据时，会发送行地址和列地址，然后内存模块会将行地址和列地址广播到每个DRAM，每个DRAM都会输出它们对应的超单元数据，最终内存模块会将所有超单元的数据合并成一个64bit的数据返回给内存控制器。</p> 
<h4><a id="12__42"></a>1.2. 磁盘存储</h4> 
<p>前面的随机访问存储器是在有点的情况下才能存储信息，而磁盘存储在断电的情况下也能保存信息。</p> 
<h5><a id="121__46"></a>1.2.1. 磁盘构造</h5> 
<p>磁盘是由<strong>多个盘片</strong>构成的，每个盘片都有两面被称为<strong>表面</strong>，表面覆盖了磁性记录材料。盘片中央有一个可以旋转的<strong>主轴</strong>，它使得盘片以固定的旋转速率旋转，通常是5400-15000转每分钟(RPM)。磁盘表面存在着一组被称为<strong>磁道</strong>的同心圆，磁道以主轴为中心向外扩散，每个磁道被分为一组<strong>扇区</strong>，每个扇区包含相等的数据位，通常是512字节，这些数据被编码在扇区的磁性材料中。扇区之间用一些<strong>间隙</strong>分隔开，这些间隙中不存储数据位，而是用来存储扇区的格式化位。</p> 
<p><img src="https://images2.imgbox.com/e3/59/od9YcLwy_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="122__53"></a>1.2.2. 磁盘容量</h5> 
<ul><li>记录密度：位/英寸 磁道一英寸的段中可以放入的位数。</li><li>磁道密度：到/英寸 从盘片中心出发半径上一英寸的段内可以有的磁道数。</li><li>面密度：位/平方英寸 记录密度与磁道密度的乘积。</li></ul> 
<p><img src="https://images2.imgbox.com/07/91/oOnsy5SI_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="123__62"></a>1.2.3. 磁盘操作</h5> 
<ul><li>磁盘用读/写头来读写存储在磁性表面的位，读写头在一个传动臂上，它们的运动叫做寻道。</li><li>一旦读写头定位到了期望的磁道上，那么当磁道上的每一个位通过它下面时，读写头可以感知，也可以修改</li><li>有多个盘片的磁盘针对于每一个盘面都有一个独立的读写头，读写头垂直排列，<strong>一致行动</strong>。</li></ul> 
<p><img src="https://images2.imgbox.com/67/eb/K8yiCuhy_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="124__71"></a>1.2.4. 时间估计</h5> 
<p>对扇区的访问时间有三个主要的部分：寻道时间、旋转时间、传送时间。</p> 
<ul><li> <p>寻道时间：平均寻道时间是3~9ms，最高可达20ms。</p> </li><li> <p>旋转时间：一旦读写头到了期望的磁道，驱动器就等到目标扇区的第一个位旋转到读写头下，而盘面位置是不可预期的，所以最大的旋转时间如下(以秒为单位，其中RPM是转每分钟)：<br> <img src="https://images2.imgbox.com/96/24/K7dnxnpg_o.png" alt="在这里插入图片描述"></p> </li><li> <p>传送时间：当目标扇区的第一个位位于读写头下面时，驱动器就开始读/写该扇区的内容了，一个扇区的传送时间依赖于旋转速度和每条磁道的扇区数目，因此粗略估计一个扇区的平均传送时间如下(以秒为单位)：</p> </li></ul> 
<p><img src="https://images2.imgbox.com/ff/87/FioRycUu_o.png" alt="在这里插入图片描述"></p> 
<p>综上：<img src="https://images2.imgbox.com/70/6e/TjpIq2eq_o.png" alt="在这里插入图片描述"></p> 
<p>示例：</p> 
<p><img src="https://images2.imgbox.com/2b/d4/H23sYGdY_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="125__93"></a>1.2.5. 练习题</h5> 
<p><img src="https://images2.imgbox.com/fd/3b/EF38RVmC_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/3b/4c/C0sLLjWq_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="13__101"></a>1.3. 固态硬盘</h4> 
<p>固态硬盘SSD是一种基于闪存的存储技术是由半导体存储器构成的，一个SSD封装由一个或多闪存芯片和闪存翻译层组成，闪存芯片代替传统旋转磁盘中的机械驱动器，而闪存翻译层是一个硬件，它和磁盘控制器一样，将逻辑块的请求翻译成对底层物理设备的访问。SSD读比写快，这是由于底层闪存基本属性决定的。一个闪存由B个块的序列组成，每个块是由P页组成，通常页的大小是512字节~4KB，块是由32~128页组成的，块的大小为16KB~512KB。</p> 
<p>数据是以页为单位读写的，只有在一页所属的整个块被擦除时候，才能够写这一页，在写入的时候由于闪存编程原理的限制，只能将1变成0，而不能将0变成1，所有擦除操作就是将所有的位变成1。因为这样，所以一个块被擦除之后，块中的每一个页都可以不需要再进行擦除就可以写一次。在大约进行100000次重复的写之后，块就会磨损，就不能再使用了。当然，它的编程原理也会将这些损耗平均下去。</p> 
<p><img src="https://images2.imgbox.com/b4/c6/KliZhIkx_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__110"></a>2. 局部性</h3> 
<ul><li>时间局部性：在一个具有较好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用。</li><li>空间局部性：在一个具有较好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。</li></ul> 
<p>例子：如下图变量sum具有较好的时间局部性，数组v具有较好的空间局部性：</p> 
<p><img src="https://images2.imgbox.com/ff/52/TaBMTJAs_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__120"></a>3. 存储器层次结构</h3> 
<ul><li>存储技术：不同存储技术的访问时间差异很大。</li><li>计算机软件：一个编写良好的程序倾向于展示出良好的局部性 。</li></ul> 
<p><img src="https://images2.imgbox.com/dc/81/ypyM1AoG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="31__128"></a>3.1. 存储器层次结构中的缓存</h4> 
<p>高速缓存是一个小而快速的存储设备，他作为存储再更大更慢的设备中的数据对象的缓冲区域，使用高速缓存的过程称为缓存。存储器层次结构的中心思想是：对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。</p> 
<p>存储下一层数据对象总是以块大小作为传送单元在第k层和第k+1层之间来回复制的，位于k层的存储器被分为较少的块集合，每个块大小与k+1层的块的带下一样，在任何时候，位于k层的存储器包含第k+1层块的一个子集副本。</p> 
<p><img src="https://images2.imgbox.com/3f/ce/LhtM2qVH_o.png" alt="在这里插入图片描述"></p> 
<p>缓存命中：当程序需要第k+1层的数据时候，他首先在当前存储在第k层的数据块中检索是否包含目标数据的副本，如果有，就称为缓存命中。当发生缓存不命中时，第k层的缓存从第k+1层缓存中取出包含目标数据的那个块，如果第k层的缓存已经满了，可能就会覆盖现存的数据块，覆盖的过程被称为替换，被替换的块被称为牺牲块。决定替换哪一个块是由缓存的替换策略来控制的，会随机或者选择最后访问较远的块(LRU)。</p> 
<p>缓存不命中种类：</p> 
<ul><li>强制性不命中(冷不命中)：第k层的缓存是空的(冷缓存)，那么对于任何目标对象的搜索都不可能搜索到。</li><li>冲突不命中：有限制性放置策略引起的不命中。</li><li>容量不命中：工作集大小超过这个缓存的大小时，缓存会经历缓存不命中。</li></ul> 
<h3><a id="4__145"></a>4. 高速缓存存储器</h3> 
<h4><a id="41__147"></a>4.1. 通用的高速缓存存储器组织结构</h4> 
<p>有一个计算机系统，其中每一个存储器地址有m位，那么会形成M=2^m个不同的地址。一个机器的高速缓存被组织为一个有S个高速缓存组的数组，每个组缓存组包含E个高速缓存行，每个行是一个B字节的数据块、一个有效位指明这个行是否包含有意义的信息(为1有效为0无效)，还有t个标记位(是当前块的内存地址的位的一个子集，唯一标识存储在这个高速缓存行中的块)组成的。高速缓存的结构可以用元组(S，E，B，m)来描述，高速缓存的大小指的是所有块的大小和，标记为不包括在内，所以大小=S×B×E。</p> 
<p><img src="https://images2.imgbox.com/49/85/vMB1SQuK_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f8/83/92DQT4mP_o.png" alt="在这里插入图片描述"></p> 
<p>如何寻找目标数据的副本：s个组索引位是一个到第S个组的索引之后通过标记位知道了数据在哪一个块并且过程中会检查有效位，找到后通过块偏移在数据块中查找目标数据。</p> 
<h4><a id="42__159"></a>4.2. 直接映射高速缓存</h4> 
<p>根据每个组的高速缓存行数E，高速缓存被分为不同的类，其中每个组只有一行(E=1)的高速缓存被称为直接映射高速缓存。高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程分为三步：组选择、行匹配、字抽取。</p> 
<ul><li>直接映射高速缓存中的组选择：就是在高速缓存中选择第几个组</li><li>直接映射高速缓存中的行匹配：在地址中的第一个小块是标记，如果第一步组中行的标记位和地址中的一样，并且有效位设置了，那么就缓存命中；如果没有设置标记为或者不匹配，那么缓存不命中。</li><li>直接映射高速缓存中的字抽取：可以讲数据块看作是一个数组，而块偏移就是一个二进制的数组下标，通过偏移就可以找到相应的数据。</li></ul> 
<h4><a id="43__167"></a>4.3. 组相联高速缓存</h4> 
<p>就是每个组多于一个行。</p> 
<h4><a id="44__171"></a>4.4. 全相联高速缓存</h4> 
<p>只有一个组的组相联高速缓存称为全相联高速缓存，没有组选择这一步。</p> 
<h3><a id="5__175"></a>5. 后记</h3> 
<p>书本上cache的映射例题一定要做一下</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2922e0608a31555dae71fd9d002eff19/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">k8s云原生环境搭建笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c115b93a58be8b14fc07c70f35d8fc6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jQuery入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>