<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Dijkstra算法及代码详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Dijkstra算法及代码详解" />
<meta property="og:description" content="迪杰斯特拉算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值，其在运行过程中维持的关键信息是一组节点集合S。算法重复从结点集V-S中选择最短路径估计最小的结点u，将u加入到集合S，然后对所有从u发生的边进行松弛，运行结束后，从源节点到集合S中每个结点之间的最短路径已经被找到。
下面，通过一个实例讲解该过程！
一、示例详解 如图，是一个有向无环图，假定出发点为V1，迪杰斯特拉算法将算出V1到其他所有点的最短路径，则所求V1到终点的最短路径也可得到，该算法主要完成以下几步：
找到V1 得到以V1出发的邻接点的最短距离，将V1加到S集合中（代码中通过vis数组标记） 从S集合之外的点中找到距离最短者，对以其为出发点的邻接点进行松弛操作，若距离被更新，则记录前驱 重复3，直到所有点被S集合收录 完成后，将得到V1到所有点的最短距离，同时，通过每一个点记录的前驱得到最短路径。
1.问题 1.1 松弛操作是啥？ 松弛操作意味着比起原来的路径，找到了一条距离更短的路，则将原来点的距离更新为新的距离。注意本文中某个点的距离全部指的是从出发点即V1到该点的距离。代码如下：
if(dis[j]&gt;dis[k]&#43;map[k][j]) { dis[j]=dis[k]&#43;map[k][j]; path[j]=k; } 1.2 为啥每个点记录前驱能用于V1到所有终点？ 我的理解是最短路是由最短路&#43;某一条固定路组成，所以前驱适用全部点，比如该图中V1到V7的最短路径为V1-&gt;V2-&gt;V3-&gt;V5-&gt;V6-&gt;V7，因为V6-&gt;V7的距离固定为50，所以V7的最短路径中V1-&gt;V6的一段必然是V1-&gt;V6的最短路径，因此每个结点只需记录一个前驱。要想打印出路径，从终点开始一次次找前驱即可，可通过递归实现。代码如下：
void print(int x)//x为终点 { if(x == -1) return; //递归 print(path[x]); printf(&#34;%d-&gt;&#34;,x); } 2. 算法过程 程序运行过程中，数据的更新情况如图所示：
红色数据代表每次迭代中被更新的数据，下标代表了结点前驱。由上图可得，当所有结点加入S后，就得到了V1到所有结点的最短距离和最短路径，例如V1到V7的最短距离为130，V7的前驱为V6，V6的前驱为V5，V5的前驱为V3，V3的前驱为V2，V2的前驱为V1，则V1到V7的最短路径为V1-&gt;V2-&gt;V3-&gt;V5-&gt;V6-&gt;V7。
3. 算法复杂度分析 二、代码实现 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; /*问题描述： * 输入n和m，代表n个节点，m条边，然后是m行输入，每行有x,y,z，代表x到y的路距离为z。 * 问题：从1出发到各点的最短路径。 * 测试样例： 7 12 1 2 20 1 3 50 1 4 30 2 3 25 2 6 70 3 4 40 3 6 50 3 5 25 4 5 55 5 6 10 5 7 70 6 7 50 */ using namespace std; const int maxn = 100; int map[maxn][maxn]; int dis[maxn]; int path[maxn]; int vis[maxn];//记录更新过的点 int n; void dijk(int s) { //初始化 memset(path,-1,sizeof(path)); /*INF使用0x3f3f3f3f的好处： * 1：满足无穷大加一个有穷的数依然是无穷大（在DijKstra算法松弛操作中避免了溢出而出现负数） * 2：满足无穷大加无穷大依然是无穷大（两个0x3f3f3f3f相加并未溢出） * 3：初始化时，由于每一个字节为0x3f，所以只需要memset（buf，0x3f,sizeof(buf)）即可 */ memset(dis,0x3f,sizeof(dis)); //初始化为无穷大 memset(vis,0,sizeof(vis)); dis[s] = 0; //自身到自身的距离为0 while(1) { int k = 0; for(int j = 1; j &lt;= n; j&#43;&#43;) { if(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8e9d454d206a04c865bb81d64c747604/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-15T17:48:48+08:00" />
<meta property="article:modified_time" content="2020-05-15T17:48:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Dijkstra算法及代码详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>迪杰斯特拉算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值，其在运行过程中维持的关键信息是一组节点集合S。算法重复从结点集V-S中选择最短路径估计最小的结点u，将u加入到集合S，然后对所有从u发生的边进行松弛，运行结束后，从源节点到集合S中每个结点之间的最短路径已经被找到。<br> 下面，通过一个实例讲解该过程！</p> 
<h3><a id="_2"></a>一、示例详解</h3> 
<p><img src="https://images2.imgbox.com/bf/06/4miDQCSH_o.png" alt="在这里插入图片描述"><br> 如图，是一个有向无环图，假定出发点为V1，迪杰斯特拉算法将算出V1到其他所有点的最短路径，则所求V1到终点的最短路径也可得到，该算法主要完成以下几步：</p> 
<pre><code>找到V1
得到以V1出发的邻接点的最短距离，将V1加到S集合中（代码中通过vis数组标记）
从S集合之外的点中找到距离最短者，对以其为出发点的邻接点进行松弛操作，若距离被更新，则记录前驱
重复3，直到所有点被S集合收录
</code></pre> 
<p>完成后，将得到V1到所有点的最短距离，同时，通过每一个点记录的前驱得到最短路径。</p> 
<h4><a id="1_12"></a>1.问题</h4> 
<h5><a id="11__13"></a>1.1 松弛操作是啥？</h5> 
<p>松弛操作意味着比起原来的路径，找到了一条距离更短的路，则将原来点的距离更新为新的距离。注意本文中某个点的距离全部指的是从出发点即V1到该点的距离。代码如下：</p> 
<pre><code> if(dis[j]&gt;dis[k]+map[k][j])
 {
      dis[j]=dis[k]+map[k][j];
      path[j]=k;
 }
</code></pre> 
<h5><a id="12_V1_22"></a>1.2 为啥每个点记录前驱能用于V1到所有终点？</h5> 
<p>我的理解是最短路是由最短路+某一条固定路组成，所以前驱适用全部点，比如该图中V1到V7的最短路径为V1-&gt;V2-&gt;V3-&gt;V5-&gt;V6-&gt;V7，因为V6-&gt;V7的距离固定为50，所以V7的最短路径中V1-&gt;V6的一段必然是V1-&gt;V6的最短路径，因此每个结点只需记录一个前驱。要想打印出路径，从终点开始一次次找前驱即可，可通过递归实现。代码如下：</p> 
<pre><code>void print(int x)//x为终点
{
    if(x == -1) return;
    //递归
    print(path[x]);
    printf("%d-&gt;",x);
}
</code></pre> 
<h4><a id="2__34"></a>2. 算法过程</h4> 
<p>程序运行过程中，数据的更新情况如图所示：<br> <img src="https://images2.imgbox.com/64/74/VEZCHRcJ_o.png" alt="在这里插入图片描述"></p> 
<p>红色数据代表每次迭代中被更新的数据，下标代表了结点前驱。由上图可得，当所有结点加入S后，就得到了V1到所有结点的最短距离和最短路径，例如V1到V7的最短距离为130，V7的前驱为V6，V6的前驱为V5，V5的前驱为V3，V3的前驱为V2，V2的前驱为V1，则V1到V7的最短路径为V1-&gt;V2-&gt;V3-&gt;V5-&gt;V6-&gt;V7。</p> 
<h4><a id="3__39"></a>3. 算法复杂度分析</h4> 
<p><img src="https://images2.imgbox.com/3a/13/dsgNyXUW_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_43"></a>二、代码实现</h3> 
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;

/*问题描述：
 * 输入n和m，代表n个节点，m条边，然后是m行输入，每行有x,y,z，代表x到y的路距离为z。
 * 问题：从1出发到各点的最短路径。
 * 测试样例：
7 12
1 2 20
1 3 50
1 4 30
2 3 25
2 6 70
3 4 40
3 6 50
3 5 25
4 5 55
5 6 10
5 7 70
6 7 50
 */
using namespace std;
const int maxn = 100;
int map[maxn][maxn];
int dis[maxn];
int path[maxn];
int vis[maxn];//记录更新过的点
int n;
void dijk(int s)
{
    //初始化
    memset(path,-1,sizeof(path));
    /*INF使用0x3f3f3f3f的好处：
     * 1：满足无穷大加一个有穷的数依然是无穷大（在DijKstra算法松弛操作中避免了溢出而出现负数）
     * 2：满足无穷大加无穷大依然是无穷大（两个0x3f3f3f3f相加并未溢出）
     * 3：初始化时，由于每一个字节为0x3f，所以只需要memset（buf，0x3f,sizeof(buf)）即可
     */
    memset(dis,0x3f,sizeof(dis)); //初始化为无穷大
    memset(vis,0,sizeof(vis));
    dis[s] = 0; //自身到自身的距离为0
    while(1)
    {
        int k = 0;
        for(int j = 1; j &lt;= n; j++)
        {
            if(!vis[j]&amp;&amp;dis[j]&lt;dis[k])//找未收录顶点中dis值最小的
                k=j; //这里第一次找到的是起点
        }
        if(!k) return; //没有未收录的点，则返回
        vis[k] = 1;
        //松弛操作
        for(int j = 1; j &lt;= n; j++)
        {
            //第一次循环只有起点的邻接点距离被更新，每次都更新新找到的点的邻接点
            if(dis[j]&gt;dis[k]+map[k][j])
            {
                dis[j]=dis[k]+map[k][j];
                path[j]=k;//路径被改变，重新记录前驱，最短路是由最短路+某一条固定路组成，所以前驱是有效的
            }
        }
    }
}

void print(int x)//x为终点
{
    if(x == -1) return;
    //递归
    print(path[x]);
    printf("%d-&gt;",x);
}
int main()
{
    int m,x,y,z,order;
    scanf("%d%d",&amp;n,&amp;m);
    memset(map,0x3f,sizeof(map));
    for(int i = 0; i &lt; m; i++)
    {
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        map[x][y] = z;
    }
    dijk(1);
    scanf("%d",&amp;order);//order为终点
    print(path[order]);
    printf("%d\n",order);
    //打印最短距离
    printf("%d\n",dis[order]);
    return 0;
}


</code></pre> 
<h3><a id="_138"></a>参考</h3> 
<p><a href="https://blog.csdn.net/Selenitic_G/article/details/89657943">Dijkstra算法及代码详解</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a842c4102cfdf7173c0381687508c17a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;操作Windows防火墙添加例外程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed5916b8d76329bdd4e8879648134a5c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">flask路由与视图函数中参数传递</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>