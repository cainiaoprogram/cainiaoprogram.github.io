<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Halcon 《机器视觉算法及应用》十例（其一） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Halcon 《机器视觉算法及应用》十例（其一）" />
<meta property="og:description" content="*该程序显示了如何在水平对准的晶圆上找到管芯
* * 显示初始化
read_image (WaferDies, &#39;wafer_dies&#39;)
dev_close_window ()
dev_open_window_fit_image (WaferDies, 0, 0, 700, 500, WindowHandle)
set_display_font (WindowHandle, 16, &#39;mono&#39;, &#39;true&#39;, &#39;false&#39;)
get_window_extents (WindowHandle, WindowRow, WindowColumn, WindowWidth, WindowHeight)
dev_update_off ()
dev_set_draw (&#39;margin&#39;)
get_image_size (WaferDies, Width, Height)
dev_display (WaferDies)
dev_disp_text (&#39;Image of a wafer&#39;, &#39;window&#39;, 12, 12, &#39;black&#39;, [], [])
dev_disp_text (&#39;Press Run (F5) to continue&#39;, &#39;window&#39;, &#39;bottom&#39;, &#39;right&#39;, &#39;black&#39;, [], [])
stop ()
* * 1. 通过使用自动关联确定芯片的尺寸
* rft_generic (WaferDies, ImageFFT, &#39;to_freq&#39;, &#39;none&#39;, &#39;complex&#39;, Width) //计算图像的实值快速傅立叶变换。时域到频域" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/853eb2e827169957ec777dfebd2ce23c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-17T14:36:13+08:00" />
<meta property="article:modified_time" content="2020-11-17T14:36:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Halcon 《机器视觉算法及应用》十例（其一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#e579b6;">*该程序显示了如何在水平对准的晶圆上找到管芯<br> * <br> * 显示初始化</span><br> read_image (WaferDies, 'wafer_dies')<br> dev_close_window ()<br> dev_open_window_fit_image (WaferDies, 0, 0, 700, 500, WindowHandle)<br> set_display_font (WindowHandle, 16, 'mono', 'true', 'false')<br> get_window_extents (WindowHandle, WindowRow, WindowColumn, WindowWidth, WindowHeight)<br> dev_update_off ()<br> dev_set_draw ('margin')<br> get_image_size (WaferDies, Width, Height)<br> dev_display (WaferDies)<br> dev_disp_text ('Image of a wafer', 'window', 12, 12, 'black', [], [])<br> dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])<br> stop ()<br> * <br><span style="color:#e579b6;">* 1. 通过使用自动关联确定芯片的尺寸</span><br> * <br> rft_generic (WaferDies, ImageFFT, 'to_freq', 'none', 'complex', Width) <span style="color:#3399ea;"> //计算图像的实值快速傅立叶变换。时域到频域</span><br> correlation_fft (ImageFFT, ImageFFT, CorrelationFFT) <span style="color:#3399ea;">//在频域中计算两个图像的相关性。</span><br> rft_generic (CorrelationFFT, Correlation, 'from_freq', 'n', 'real', Width) <span style="color:#3399ea;"> //频域到时域</span><br><span style="color:#e579b6;">*排除图像边界处的局部最大值。 提取图像左上角的最大值就足够了，因为自相关是一个偶函数。</span><br> gen_rectangle1 (Rectangle, 1, 1, Height / 2, Width / 2) //图像区域限定在左上1/4<br> reduce_domain (Correlation, Rectangle, CorrelationReduced)<br> * <br><span style="color:#e579b6;">*提取自动相关函数的局部最大值</span><br> local_max_sub_pix (CorrelationReduced, 'gauss', 2, 5000000, Row, Col)<br> * <br><span style="color:#e579b6;">*获得芯片的尺寸<br> * 找到最接近原点的最大值,此最大值对应于芯片的相对矩形角。</span><br> distance_pp (gen_tuple_const(|Row|,0), gen_tuple_const(|Col|,0), Row, Col, Distance)  <span style="color:#3399ea;">//(gen_tuple_const(|Row|,0) 创建一个具有|Row|个元素的,每个元素都为0的数组，计算到原点的距离</span><br> SortedIndex := sort_index(Distance)<span style="color:#3399ea;"> //排序,注意SortedIndex=[0, 2, 4, 1, 3]，是先排序，再得到索引</span></p> 
<hr> 
<p><img alt="" height="94" src="https://images2.imgbox.com/64/7a/MfQ1DWwv_o.png" width="596"></p> 
<p><span style="color:#7c79e5;">Distance正确的排序：180，231，255，300，333，对应原原来数组中的位置刚好是[0,2,4,1,3]</span></p> 
<hr> 
<p>Row1 := Row[SortedIndex[0]]<span style="color:#3399ea;"> //<strong>选择距离原点最近的</strong></span><strong><span style="color:#e579b6;">局部最大值</span></strong><br> Col1 := Col[SortedIndex[0]]<br> DiagonalLength := sqrt(Row1 * Row1 + Col1 * Col1)<br> Phi := atan2(Row1,Col1)<br> DieWidth := DiagonalLength * cos(Phi)<br> DieHeight := DiagonalLength * sin(Phi)<br> * <br><span style="color:#e579b6;">* 中心，第一个最大值和第二个最大值 一起定义芯片的方向和尺寸。</span><br> dev_set_color ('blue')<br> gen_cross_contour_xld (Crosses, Row, Col, 10, 0.785398)<br> gen_ellipse_contour_xld (Circle, Row1, Col1, 0, 12, 12, 0, 6.28318, 'positive', 1.5)<br> dev_display (Correlation)<br> dev_display (Crosses)<br> dev_display (Circle)<br> dev_set_color ('green')<br> dev_display (Rectangle)<br> dev_disp_text ('Autocorrelation, region of interest, and local maxima', 'window', 12, 12, 'black', [], [])<br> dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])<br> stop ()<br> * <br><span style="color:#e579b6;">* 可视化提取图片大小</span><br> gen_rectangle2_contour_xld (Die, Height / 2, Width / 2, 0, DieWidth / 2, DieHeight / 2)<br> dev_display (WaferDies)<br> dev_set_color ('blue')<br> dev_display (Die)<br> dev_disp_text ('Extracted die size', 'window', 12, 12, 'black', [], [])<br> dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])<br> stop ()<br> * <br><span style="color:#e579b6;">* 2.通过使用基于形状的匹配来确定芯片的位置</span><br> * <br> LineWidth := 7 <span style="color:#3399ea;">//每个芯片间隙的宽度</span><br> LineWidthFraction := 0.6<br> * <br><span style="color:#e579b6;">*生成芯片之间线条的人工模型图像</span><br> gen_image_const (Template, 'byte', Width, Height) <span style="color:#3399ea;">//创建具有恒定灰度值的图像</span><br> scale_image (Template, Template, 1, 128)<span style="color:#3399ea;"> //缩放图像的灰度值</span><br> RefRow := round(0.5 * Height) <span style="color:#3399ea;">//rand最邻近整数，即四舍五入</span><br> RefCol := round(0.5 * Width)<br> for Row := -0.5 to 0.5 by 1<br>     for Col := -0.5 to 0.5 by 1<br>         gen_rectangle2_contour_xld (Rectangle, RefRow + Row * DieHeight, RefCol + Col * DieWidth, 0, 0.5 * DieWidth - 0.5 * LineWidth, 0.5 * DieHeight - 0.5 * LineWidth)</p> 
<hr> 
<p>gen_rectangle2_contour_xld</p> 
<p>官方解释:gen_rectangle2_contour_xld creates one or more XLD contours in the shape of a rectangle with arbitrary orientation. The rectangle has the center (Row, Column), the orientation Phi, and the half edge lengths Length1 and Length2.</p> 
<p>gen_rectangle2_contour_xld 以任意方向创建一个或多个矩形的XLD轮廓。 矩形具有中心 center (Row, Column)，方向Phi和<u><strong><span style="color:#f33b45;">半边长</span></strong></u>Length1和Length2。</p> 
<p>这里做个解释：是图像中心点（RefRow RefCol）以  （-0.5，-0.5), (-0.5,0.5), (0.5,-0.5), (0.5,0.5）倍平移（DieHeight，DieWidth），刚好是4个相邻芯片的矩形坐在位置。</p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/66/3d/cv0EystP_o.png" width="608"><img alt="" height="422" src="https://images2.imgbox.com/2c/52/5uVAWQ1f_o.png" width="614"></p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/e3/9f/x8oKDmjO_o.png" width="608"><img alt="" height="422" src="https://images2.imgbox.com/6b/e9/blLLHya9_o.png" width="615"></p> 
<p> </p> 
<hr> 
<p><span style="color:#4d4d4d;">          paint_xld (Rectangle, Template, Template, 0) </span><span style="color:#3399ea;">//画出模板</span><br>     endfor<br> endfor<br> gen_rectangle2_contour_xld (Rectangle, RefRow, RefCol, 0, 0.5 * LineWidthFraction * LineWidth, DieHeight)</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/17/b8/VfZyR89G_o.png" width="433"><span style="color:#3399ea;">（生成芯片 竖直 间隙）(每个矩形覆盖60%的线宽，LineWidthFraction := 0.6）</span><br> paint_xld (Rectangle, Template, Template, 0)<br> gen_rectangle2_contour_xld (Rectangle, RefRow, RefCol, 0, DieWidth, 0.5 * LineWidthFraction * LineWidth) <span style="color:#3399ea;">//生成芯片 水平间隙</span><br> paint_xld (Rectangle, Template, Template, 0)<br> gen_rectangle2 (ROI, RefRow, RefCol, 0, DieWidth + 5, DieHeight + 5)<span style="color:#3399ea;">  //生成包含四个临近dies的矩形</span><br> reduce_domain (Template, ROI, TemplateReduced)<br> create_shape_model (TemplateReduced, 'auto', 0, 0, 'auto', 'auto', 'ignore_local_polarity', 'auto', 5, ModelID)<span style="color:#3399ea;"> //生成模板 ModelID</span></p> 
<hr> 
<p>create_shape_model(Template : : NumLevels, AngleStart, AngleExtent, AngleStep, Optimization, Metric, Contrast, MinContrast : ModelID)</p> 
<p><strong>create_shape_model</strong>(</p> 
<p>                    <strong>Template</strong> : : //reduce_domain后的模板图像</p> 
<p>                    <strong>NumLevels,    //金字塔的层数，可设为“auto”或0—10的整数</strong></p> 
<p>                     <strong>AngleStart</strong>,//模板旋转的起始角度</p> 
<p>                     <strong>AngleExtent</strong>,//模板旋转角度范围, &gt;=0</p> 
<p>                     <strong>AngleStep</strong>,//旋转角度的步长， &gt;=0 and &lt;=pi/16</p> 
<p>                     <u><strong>Optimization</strong></u>,//设置模板优化和模板创建方法</p> 
<p>                     <strong>Metric</strong>, //匹配方法设置</p> 
<p>                     <strong>Contrast</strong>,//设置对比度</p> 
<p>                     <strong>MinContrast </strong>://设置最小对比度</p> 
<p>                     <strong>ModelID</strong>) //输出模板句柄</p> 
<hr> 
<p>dev_display (Template)<br> dev_set_color ('blue')<br> dev_display (ROI)<br> dev_disp_text ('Template of 4 adjacent dies', 'window', 12, 12, 'black', [], []) <span style="color:#3399ea;">//4个相邻dies的模板显示</span><br> dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</p> 
<p><img alt="" height="439" src="https://images2.imgbox.com/f6/b4/DSdk3kFD_o.png" width="604"><br> stop ()<br> * <br><span style="color:#e579b6;">*在原始图像中找到人工模型的最佳实例</span><br> MinScore := 0.7<br> Greediness := 0.5<br> NumMatches := 1<br> find_shape_model (WaferDies, ModelID, 0, 0, MinScore, NumMatches, 0.5, 'least_squares', 0, Greediness, MatchRow, MatchColumn, MatchAngle, MatchScore)</p> 
<hr> 
<p>find_shape_model(Image : : ModelID, AngleStart, AngleExtent, MinScore, NumMatches, MaxOverlap, SubPixel, NumLevels, Greediness : Row, Column, Angle, Score)</p> 
<p><strong>find_shape_model</strong>(Image : :  //搜索图像</p> 
<p>                   ModelID, //模板句柄</p> 
<p>                  AngleStart,  // 搜索时的起始角度</p> 
<p>                  AngleExtent, //搜索时的角度范围，必须与创建模板时的有交集</p> 
<p>                  MinScore, //最小匹配值，输出的匹配的得分Score 大于该值</p> 
<p>                  NumMatches, //定义要输出的匹配的最大个数</p> 
<p>                  MaxOverlap, //当找到的目标存在重叠时，且重叠大于该值时选择一个好的输出</p> 
<p>                 SubPixel, //计算精度的设置，五种模式，多选2，3</p> 
<p>                 NumLevels, //搜索时金字塔的层数</p> 
<p>                Greediness : //贪婪度，搜索启发式，一般都设为0.9，越高速度快,容易出现找不到的情况</p> 
<p>                Row, Column, Angle, Score) //输出匹配位置的行和列坐标、角度、得分。</p> 
<hr> 
<p>* <br> get_shape_model_contours (ModelContours, ModelID, 1)<span style="color:#3399ea;"> //返回形状模型的轮廓表示</span><br> vector_angle_to_rigid (0, 0, 0, MatchRow, MatchColumn, MatchAngle, HomMat2D) <span style="color:#3399ea;">//从点和角度计算刚性仿射变换</span><br> affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2D)<span style="color:#3399ea;"> //对XLD轮廓应用任意仿射2D变换</span><br> dev_display (WaferDies)<br> dev_set_color ('blue')<br> dev_display (ContoursAffinTrans)<br> dev_disp_text ('Best match', 'window', 12, 12, 'black', [], [])<br> dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])<br> stop ()<br> * <img alt="" height="421" src="https://images2.imgbox.com/aa/f1/629yCcJq_o.png" width="613"><br> *<span style="color:#e579b6;"> 3.根据芯片的的尺寸和位置计算切割线</span><br> * <br> dev_clear_window ()<br> dev_display (WaferDies)<br> dev_set_color ('blue')<br> NumRowMax := ceil(Height / DieHeight)<br> NumColMax := ceil(Width / DieWidth)<br> for RowIndex := -NumRowMax to NumRowMax by 1<br>     RowCurrent := MatchRow + RowIndex * DieHeight<br>     gen_contour_polygon_xld (CuttingLine, [RowCurrent,RowCurrent], [0,Width - 1])<span style="color:#3399ea;"> //从多边形（作为元组）生成XLD轮廓。</span><br>     dev_display (CuttingLine)<br> endfor<br> for ColIndex := -NumColMax to NumColMax by 1<br>     ColCurrent := MatchColumn + ColIndex * DieWidth<br>     gen_contour_polygon_xld (CuttingLine, [0,Height - 1], [ColCurrent,ColCurrent])<br>     dev_display (CuttingLine)<br> endfor<br> dev_disp_text ('Resulting cutting lines', 'window', 12, 12, 'black', [], [])<br> dev_disp_text ('      End of program      ', 'window', 'bottom', 'right', 'black', [], [])</p> 
<p> </p> 
<p>总结：</p> 
<p>1.自相关g是图像本身相关性（g*g)，通过傅里叶变换将图像转换到频域并与其共轭相乘计算相关，最后频域得到的相关结果再反傅里叶变换回时域。</p> 
<p><img alt="" height="455" src="https://images2.imgbox.com/a5/11/LW4a5sRJ_o.png" width="392"><img alt="" height="456" src="https://images2.imgbox.com/84/ca/s4YI5RDg_o.png" width="611"></p> 
<p>上图较亮的灰度值代表较高的相关值，cross代表图像左上1/4区域中的局部最大值，被圈住的是距离原点最近的局部最大值。</p> 
<p>2.比较值得思考的地方：</p> 
<p>（1）建立模板的时候，生成模板的矩形中心：以图像中心点(RefRow,RefCol)为中心，分别加上（-0.5，-0.5）、（-0.5，0.5)、（0.5，-0.5）、（0.5，0.5）倍的(DieHeight,DieWidth)</p> 
<p>RefRow := round(0.5 * Height) <span style="color:#3399ea;">//rand最邻近整数，即四舍五入</span><br> RefCol := round(0.5 * Width)<br> for Row := -0.5 to 0.5 by 1<br>     for Col := -0.5 to 0.5 by 1<br>         gen_rectangle2_contour_xld (Rectangle, RefRow + Row * DieHeight, RefCol + Col * DieWidth, 0, 0.5 * DieWidth - 0.5 * LineWidth, 0.5 * DieHeight - 0.5 * LineWidth)</p> 
<p>（2）生成芯片dies的分割线时，采用最匹配模型 MatchRow加上：-6 to 6 by 1 倍芯片高DieHeight</p> 
<p>for RowIndex := -NumRowMax to NumRowMax by 1<br>     RowCurrent := MatchRow + RowIndex * DieHeight<br>     gen_contour_polygon_xld (CuttingLine, [RowCurrent,RowCurrent], [0,Width - 1])<span style="color:#3399ea;"> //从多边形（作为元组）生成XLD轮廓。</span><br>     dev_display (CuttingLine)<br> endfor</p> 
<p>为什么这么做我不太明白？</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7729f52e98767d861db48f516b5a8554/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">学习笔记｜fmri_4 预处理 co- register segment normalize smooth SPM12</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d0851a43da6d9ac8ec822ff2d8ec62f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《性格色彩》测试加分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>