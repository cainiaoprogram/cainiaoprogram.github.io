<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>嵌入式应用复习知识点总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="嵌入式应用复习知识点总结" />
<meta property="og:description" content="一.期末考试题型 1.单选题40’2.判断题10’3.简答题20’4.综合设计题（6&#43;6&#43;10&#43;8） 二.单选题知识点 1.嵌入式系统 1.定义 IEEE（国际电气和电子工程师协会）的定义：
Devices used to control, monitor, or assist the operation of equipment, machinery orplants。
翻译：嵌入式系统是“用于控制、监视或者辅助操作机器和设备或装置运行的装置
从中可以看出，嵌入式系统是软件和硬件的综合体，还可以涵盖机械等附属装置，可认为是一个广泛定义。
国内普遍认同的定义：
以应用为中心、以计算机技术为基础，软件硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗等严格要求的专用计算机系统。
我们把这个国内的定义收缩一下，就有了嵌入式的特点：嵌入性、专用性与计算机系统。
2.特点 嵌入性：必须满足对象系统的环境要求，如物理环境(小型)、电气/气氛环境(可靠)、成本(价廉)等要求。专用性：软、硬件的裁剪性；满足对象要求的最小软、硬件配置等。计算机系统：嵌入式系统必须是能满足对象系统控制要求的计算机系统。 3.硬软件 嵌入式系统的硬件特征：
(1)嵌入式系统由嵌入式处理器、存储器、相关支撑器件等电子元器件组成的电子装置或设备;(2)嵌入式系统的电气性能指标均能够参数化;(3)嵌入式系统需要通过硬件架构、电路原理图、电路板、产品模具的设计、生产、测试的系列工艺过程来实现。 这里注意，个人电脑并不是我们所说的嵌入式，而车载控制系统、网络数字机顶盒、智能手机等则是我们所说的嵌入式。
所以如果遇到判断下面哪些属于嵌入式系统的题，首先把计算机系统和笔记本电脑排除。
嵌入式系统的软件特征：
(1)软件要求固化存储;(2)软件代码要求高度精练、高质量、高可靠性、高稳定性;(3)系统软件(OS)的高实时性是基本要求;(4)多任务操作系统是知识集成的平台和走向工业标准化道路的基础。 嵌入式系统的产品特征：
(1)嵌入式系统必须面向用户、面向产品、面向应用;(2)嵌入式系统处理器的功耗、体积、成本、可靠性、速度、处理能力、电磁兼容性等方面均受到应用要求的制约，这些均是各半导体厂商之间竞争的热点;(3)嵌入式系统的软硬件都必须高效率地设计，量体裁衣、去除冗余，力争在同样的硅片面积上实现更高的性能。 这里的硬软件特征才是重点。
2.嵌入式系统组成的典型结构 嵌入式计算机系统一般由硬件层、硬件抽象层(中间层)、、操作系统层和应用软件层构成。
（该层次是由下到上描述的）
1.硬件层 嵌入式微处理器，嵌入式系统硬件层的核心，与通用微处理器不同(将通用计算机板卡完成的任务集成在芯片中)。
其体系结构可采用冯·诺伊曼结构或哈佛结构。指令系统可采用CISC或RISC。
存储器
CACHE：位于主存与微处理器内核之间，存放最近一段时间微处理器使用最多的一段程序代
码和数据。容量小，存取速度快。主存是微处理器能直接访问的寄存器，存放系统和用户的程序及数据。片内容量小，速度快，片外容量大。辅助存储器，存放大数据量的程序代码或信息，用来长期保存用户的信息。容量大，速度慢(与主存比)。 嵌入式系统与外界交互需要一定形式的通用设备接口。通用设备接口有: A/D、D/A转换接口等。I/0接口有: RS -232接口、Ethernet接口、USB接口、音频接口、视频接口、I2C接口、SPI及IrDA接口等。
2.中间层（HAL或BSP） 作用：将系统上层软件与底层硬件分离开来，使系统的底层驱动程序与硬件无关。
该层一般包括:
相关底层硬件的初始化数据的输入/输出操作硬件设备的配置 BSP具有以下两个特点:
硬件相关性操作系统相关性 BSP是一个介于操作系统和底层硬件之间的一个软件层次，包括了系统中大部分与硬件联系紧密的软件模块。
设计一个完整的BSP，应该包括硬件初始化和硬件相关的设备驱动两个部分。
3.操作系统层（系统软件层） 系统软件层由实时多任务操作系统(RTOS) 、文件系统、图形用户接口(GUI)、网络系统及通用组件模块组成。RTOS是嵌入式应用软件的基础和开发平台。
4.应用软件层 应用软件层是由基于实时系统开发的应用程序组成，用来实现对被控对象的控制功能。功能层是面向被控对象和用户的，为方便用户操作，往往需要提供一个友好的人机界面。
3.冯·诺伊曼结构和哈佛结构 冯·诺伊曼结构：指令和数据共享同一存储器和总线。
哈佛结构：指令和数据分别存储在独立的存储器和总线中。
4.嵌入式最小系统 构建一个嵌入式系统,首先需要.让系统核心部件嵌入式处理器工作,这样才可以逐步增加系统的功能,最终形成符合需求的完整系统。
5.RISC与CISC RISC结构一般特点:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2e8d49c49f637e5dd623f1d0ee2809db/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-13T16:45:03+08:00" />
<meta property="article:modified_time" content="2023-07-13T16:45:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式应用复习知识点总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>一.期末考试题型</h2> 
<ul><li>1.单选题40’</li><li>2.判断题10’</li><li>3.简答题20’</li><li>4.综合设计题（6+6+10+8）</li></ul> 
<h2><a id="_7"></a>二.单选题知识点</h2> 
<h3><a id="1_9"></a>1.嵌入式系统</h3> 
<h4><a id="1_11"></a>1.定义</h4> 
<p>IEEE（国际电气和电子工程师协会）的定义：</p> 
<ul><li> <p>Devices used to control, monitor, or assist the operation of equipment, machinery orplants。</p> 
  <blockquote> 
   <p>翻译：嵌入式系统是“用于控制、监视或者辅助操作机器和设备或装置运行的装置</p> 
  </blockquote> <p>从中可以看出，嵌入式系统是<strong>软件和硬件的综合体</strong>，还可以涵盖机械等附属装置，可认为是一个<strong>广泛定义</strong>。</p> </li></ul> 
<p>国内普遍认同的定义：</p> 
<ul><li> <p>以<strong>应用</strong>为中心、以<strong>计算机技术</strong>为基础，软件硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗等严格要求的<strong>专用计算机系统</strong>。</p> 
  <blockquote> 
   <p>我们把这个国内的定义收缩一下，就有了嵌入式的特点：嵌入性、专用性与计算机系统。</p> 
  </blockquote> </li></ul> 
<h4><a id="2_27"></a>2.特点</h4> 
<ul><li><strong>嵌入性</strong>：必须满足对象系统的环境要求，如物理环境(小型)、电气/气氛环境(可靠)、成本(价廉)等要求。</li><li><strong>专用性</strong>：软、硬件的裁剪性；满足对象要求的最小软、硬件配置等。</li><li><strong>计算机系统</strong>：嵌入式系统必须是能满足对象系统控制要求的计算机系统。</li></ul> 
<h4><a id="3_33"></a>3.硬软件</h4> 
<p><img src="https://images2.imgbox.com/4a/9d/BtXI2xID_o.jpg" alt="在这里插入图片描述"></p> 
<p>嵌入式系统的<strong>硬件特征</strong>：</p> 
<ul><li>(1)嵌入式系统由嵌入式处理器、存储器、相关支撑器件等电子元器件组成的电子装置或设备;</li><li>(2)嵌入式系统的电气性能指标均能够参数化;</li><li>(3)嵌入式系统需要通过硬件架构、电路原理图、电路板、产品模具的设计、生产、测试的系列工艺过程来实现。</li></ul> 
<blockquote> 
 <p>这里注意，个人电脑并不是我们所说的嵌入式，而车载控制系统、网络数字机顶盒、智能手机等则是我们所说的嵌入式。</p> 
 <p>所以如果遇到判断下面哪些属于嵌入式系统的题，首先把计算机系统和笔记本电脑排除。</p> 
</blockquote> 
<p>嵌入式系统的<strong>软件特征</strong>：</p> 
<ul><li>(1)软件要求固化存储;</li><li>(2)软件代码要求高度精练、高质量、高可靠性、高稳定性;</li><li>(3)系统软件(OS)的高实时性是基本要求;</li><li>(4)多任务操作系统是知识集成的平台和走向工业标准化道路的基础。</li></ul> 
<p>嵌入式系统的产品特征：</p> 
<ul><li>(1)嵌入式系统必须面向用户、面向产品、面向应用;</li><li>(2)嵌入式系统处理器的功耗、体积、成本、可靠性、速度、处理能力、电磁兼容性等方面均受到应用要求的制约，这些均是各半导体厂商之间竞争的热点;</li><li>(3)嵌入式系统的软硬件都必须高效率地设计，量体裁衣、去除冗余，力争在同样的硅片面积上实现更高的性能。</li></ul> 
<blockquote> 
 <p>这里的硬软件特征才是重点。</p> 
</blockquote> 
<h3><a id="2_63"></a>2.嵌入式系统组成的典型结构</h3> 
<blockquote> 
 <p>嵌入式计算机系统一般由硬件层、硬件抽象层(中间层)、、操作系统层和应用软件层构成。</p> 
 <p>（该层次是由下到上描述的）</p> 
</blockquote> 
<h4><a id="1_69"></a>1.硬件层</h4> 
<p><strong>嵌入式微处理器</strong>，嵌入式系统硬件层的核心，与通用微处理器不同(将通用计算机板卡完成的任务集成在芯片中)。<br> 其体系结构可采用<strong>冯·诺伊曼结构</strong>或<strong>哈佛结构</strong>。指令系统可采用CISC或RISC。</p> 
<blockquote> 
 <p>存储器</p> 
 <ul><li>CACHE：位于主存与微处理器内核之间，存放最近一段时间微处理器使用最多的一段程序代<br> 码和数据。容量小，存取速度快。</li><li><strong>主存</strong>是微处理器能直接访问的寄存器，存放系统和用户的程序及数据。片内容量小，速度快，片外容量大。</li><li><strong>辅助存储器</strong>，存放大数据量的程序代码或信息，用来长期保存用户的信息。容量大，速度慢(与主存比)。</li></ul> 
</blockquote> 
<p>嵌入式系统与外界交互需要一定形式的通用设备接口。通用设备接口有: A/D、D/A转换接口等。I/0接口有: RS -232接口、Ethernet接口、USB接口、音频接口、视频接口、I2C接口、SPI及IrDA接口等。</p> 
<h4><a id="2HALBSP_83"></a>2.中间层（HAL或BSP）</h4> 
<p>作用：将系统上层软件与底层硬件分离开来，使系统的底层驱动程序与硬件无关。</p> 
<p>该层一般包括:</p> 
<ul><li>相关底层硬件的初始化</li><li>数据的输入/输出操作</li><li>硬件设备的配置</li></ul> 
<p>BSP具有以下两个特点:</p> 
<ul><li>硬件相关性</li><li>操作系统相关性</li></ul> 
<p>BSP是一个介于操作系统和底层硬件之间的一个<strong>软件</strong>层次，包括了系统中大部分与硬件联系紧密的软件模块。</p> 
<p>设计一个完整的BSP，应该包括<strong>硬件初始化</strong>和<strong>硬件相关的设备驱动</strong>两个部分。</p> 
<h4><a id="3_102"></a>3.操作系统层（系统软件层）</h4> 
<p>系统软件层由<strong>实时多任务操作系统(RTOS)</strong> 、文件系统、图形用户接口(GUI)、网络系统及通用组件模块组成。<strong>RTOS</strong>是嵌入式应用软件的<strong>基础</strong>和开发平台。</p> 
<h4><a id="4_106"></a>4.应用软件层</h4> 
<p>应用软件层是由基于实时系统开发的应用程序组成，<strong>用来实现对被控对象的控制功能</strong>。功能层是面向被控对象和用户的，为方便用户操作，往往需要提供一个友好的人机界面。</p> 
<h3><a id="3_110"></a>3.冯·诺伊曼结构和哈佛结构</h3> 
<p><img src="https://images2.imgbox.com/33/72/FvlSdM72_o.jpg" alt="在这里插入图片描述"></p> 
<p>冯·诺伊曼结构：指令和数据共享同一存储器和总线。</p> 
<p><img src="https://images2.imgbox.com/02/cd/QDoDwd9g_o.jpg" alt="在这里插入图片描述"></p> 
<p>哈佛结构：指令和数据分别存储在独立的存储器和总线中。</p> 
<h3><a id="4_122"></a>4.嵌入式最小系统</h3> 
<p>构建一个嵌入式系统,首先需要.让系统核心部件嵌入式处理器工作,这样才可以逐步增加系统的功能,最终形成符合需求的完整系统。</p> 
<p><img src="https://images2.imgbox.com/05/14/h51xvLPt_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="5RISCCISC_128"></a>5.RISC与CISC</h3> 
<p>RISC结构一般特点:</p> 
<ul><li>单周期的执行。</li><li>采用高效的流水线操作。</li><li>无微代码的硬连线控制。</li><li>指令格式的规格化和简单化。</li><li>采用面向寄存器组的指令。</li><li>采用Load/Store (装载/存储)指令结构。</li><li>注重编译的优化，力求有效地支撑高级语言程序。</li></ul> 
<p><img src="https://images2.imgbox.com/37/86/9Q286bJ9_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="6ARM_143"></a>6.ARM内核体系结构、特点</h3> 
<p>ARM处理器的特点：</p> 
<ul><li>➢体积小、低功耗、低成本、高性能。</li><li>➢支持Thumb (16位) /ARM (32位) 双指令集，能很好地兼容8位/16位器件。</li><li>➢大量使用寄存器，指令执行速度更快。</li><li>➢大多数数据操作都在寄存器中完成。</li><li>➢寻址方式灵活简单，执行效率高。</li><li>➢指令长度固定。</li></ul> 
<p>常见的ARM内核体系结构包括ARMv6、ARMv6、ARMv7、ARMv8等。</p> 
<h3><a id="7_156"></a>7.处理工作模式、工作状态</h3> 
<p><img src="https://images2.imgbox.com/41/55/nonexPc2_o.png" alt="在这里插入图片描述"></p> 
<p>Cortex- A9处理器是32位处理器，可执行32位ARM指令集指令，同时兼容16位Thumb-2指令集指令和数据类型。有<strong>3种工作状态</strong>，这些状态由<strong>程序状态寄存器</strong>(CPSR)的<strong>T位和J位</strong>控制与切换。</p> 
<ul><li>➢ARM状态:执行32位的字对齐的ARM指令集指令，T位和J位为0;</li><li>➢Thumb状态:执行16位或32位半字对齐的Thumb-2指令集指令，T位为1, J位为0;</li><li>➢ThumbEE状态:执行为动态产生目标而设计的16位或32位半字对齐的Thumb-2指令集的变体，T位和J位为1。</li></ul> 
<blockquote> 
 <p>ARM指令必须在ARM状态下执行;Thumb指令也必须在Thumb状态下执行。<br> ARM处理器可以在两种状态下切换，只要遵循ATPCS调用规则，ARM子程序和Thumb子程序之间可以相互调用。<br> ARM状态和Thumb状态之间的切换并不影响处理器工作模式和寄存器组的内容。<strong>处理器复位后开始执行代码时，处于ARM状态。</strong></p> 
</blockquote> 
<p>处理器状态之间的切换:</p> 
<ul><li> <p>(1) ARM状态和Thumb状态之间切换<br> 执行BX和BL.X指令时，将通用寄存器的中所存储的目标地址值复制到程序寄存器PC，该目标地址值的最低一位为1则切换到Thumb状态。如果处理器在Thumb状态时发生<strong>异常</strong>(异常处理必须在ARM状态下)，当异常处理返回时自动切换到Thumb状态。<br> 执行BX和BL.X指令时，将通用寄存器的中所存储的目标地址值复制到程序寄存器PC，该目标地址值的最低一位为0则切换到ARM状态。处理器进行异常处理时，把PC的值放入异常模式链接寄存器中，从异常向量地址开始执行程序，系统自动进入ARM状态。</p> </li><li> <p>(2) Thumb状态和ThumbEE状态之间切换<br> 使用ENTERX指令和LEAVEX指令。</p> 
  <blockquote> 
   <p>得出结论：ARM处理器切换工作状态是自动的。</p> 
  </blockquote> </li></ul> 
<h3><a id="8_182"></a>8.大/小端存储模式</h3> 
<p><strong>大端模式</strong>是被存放字数据的高字节存储在存储系统的低地址中，而被存放的字数据的低字节则存放在存储系统的高地址中。（高对低，低对高）<br> <strong>小端模式</strong>中，存储系统的低地址中存放的是被放字数据中的低字节内容，存储系统的高地址存放的是被存字数据中的高字节内容。（低对低，高对高）</p> 
<h3><a id="9MMU_187"></a>9.内存管理单元MMU</h3> 
<p>面对一些复杂的、多任务的嵌入式应用时，常使用嵌入式操作系统来管理整个系统和任务的运行。高级的嵌入式操作系统都带有内存管理单元MMU ( Memory Management Unit)来管理每个任务各自的存储空间。</p> 
<blockquote> 
 <p>虚拟地址的范围（虚拟地址空间）由CPU的位数决定，物理地址空间只是它的一个子集。</p> 
</blockquote> 
<p>虚拟地址由编译器和连接器在定位程序时分配;物理地址用来访问实际的主存储器硬件模块。在ARM中采用了页(Page)式虚拟存储管理方式。虚拟地址空间划分成称为页的单位，而相应的物理地址空间也被进行划分，单位是页帧(frame)。</p> 
<blockquote> 
 <p>进程中的块叫页，内存中的块叫页帧或页框，外存的块叫块或盘块。</p> 
</blockquote> 
<p>页与页帧之间在MMU的调度下是如何进行映射:</p> 
<p>虚拟地址0被送往MMU,MMU发现该地址在页<code>0 (0~4095)</code>的范围内，页0所映射的页框为2(页框2的地址范围是8192~12287)。因此MMU将该虚拟地址转化为物理地址8192，并把地址8192送到内存地址总线上。内存对地址的映射过程并不清楚，它只是接收到一个对地址8192的访问请求并执行。</p> 
<blockquote> 
 <p>如果这段话看不懂，请点击<a href="" rel="nofollow">从操作系统角度了解内存管理</a></p> 
</blockquote> 
<p>MMU的一个<strong>重要任务</strong>就是<strong>让每个任务都运行在各自的虚拟存储空间中</strong>。MM∪做为转换器，将程序和数据的虚拟地址转换成实际的物理地址，也就是实现虚拟存储空间到物理存储空间的映射。<br> 除此之外，MMU的其他重要功能还包括:</p> 
<ul><li>(1)存储器访问权限的控制，提供硬件机制的内存访问授权。</li><li>(2)设置虚拟存储空间缓冲的特性。</li></ul> 
<h3><a id="10_209"></a>10.异常处理</h3> 
<p>异常是ARM处理器处理外部异步事件的一种方法，也称为<strong>中断</strong>。当处理器在正常执行程序的过程中，一个来自外部或内部的异常事件发生，处理器暂时中断当前程序的执行，跳转到相应的异常处理程序入口执行异常处理。在处理这个异常事件之前，处理器要保存当前处.理器的状态和返回地址，以便异常处理程序结束后能返回原来的程序继续执行。若同时有多个异常发生，处理器将根据异常中断优先级来处理这些异常。</p> 
<blockquote> 
 <p>这里把异常与中断等效了，在计组中，异常是内中断，它是在指令执行过程中发生的中断，而外中断属于硬件等外部设备中断。</p> 
</blockquote> 
<h4><a id="1_215"></a>1.异常向量与优先级</h4> 
<p>在ARM体系结构中有<strong>7</strong>种异常中断。异常发生时，处理器会将PC寄存器设置为一个特定的存储器地址，这些特定的存储器地址称为异常向量。所有异常的异常向量被集中放在程序存储器的一个连续地址空间中，称为<strong>异常向量表</strong>。每个异常向量只占4个字节，异常向量处是一些跳转指令，跳转到对应的异常处理程序。</p> 
<p><img src="https://images2.imgbox.com/ac/3b/rI54Phzr_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rVPw7cOU-1687739242359)(C:\Users\洪泽林\AppData\Roaming\Typora\typora-user-images\image-20230622091906948.png)]"></p> 
<blockquote> 
 <p>在上表中可以看到，每一种异常都会导致内核进入一种特定的模式。此外，也可以通过编程改变CPSR，进入ARM处理器模式要说明的是，用户模式和系统模式是仅有的不可通过异常进入的两种模式，也就是说，要进入这两种模式，必须通过编程改变CPSR。<br> 当多个异常同时发生时，由系统根据不同异常的优先级按照从高到低的顺序处理。7种异常分成6个级别，1优先级最高，6优先级最低。其中，未定义指令异常和软件中断异常都依靠指令的特殊译码产生，这两者是互斥的，不可能同时产生。</p> 
</blockquote> 
<h4><a id="2_225"></a>2.异常响应过程</h4> 
<p>通常，异常(中断)响应大致可以分为以下几个步骤:</p> 
<ul><li>(1) 保护断点，即保存下一个将要执行的指令的地址，就是把这个地址送入堆栈;</li><li>(2)寻找中断入口，根据不同的中断源所产生的中断，查找不同的入口地址;</li><li>(3)执行中断处理程序;</li><li>(4) 中断返回，执行完中断指令后，就从中断处返回到主程序，继续执行。</li></ul> 
<blockquote> 
 <p>1和2由硬件自动完成，其余是由中断程序完成。</p> 
</blockquote> 
<blockquote> 
 <p>中断处理过程实在指令执行周期之后，所以除了复位异常会立即中断程序以外，其余中断均在中断周期内完成。</p> 
</blockquote> 
<h4><a id="3_238"></a>3.异常返回过程</h4> 
<p>复位异常发生后，由于系统自动从0x00000000开始重新执行程序，因此复位异常处理程序执行完后无须返回。其它异常处理完后必须返回到原来程序的断点处继续执行。<br> ARM处理器从异常处理程序中返回的过程如下:</p> 
<ul><li>(1)恢复原来被保存的用户寄存器。</li><li>(2)将SPSR_ mode 寄存器的值复制到CPSR中，以恢复被中断的程序工作状态。</li><li>(3)根据异常类型将PC寄存器值恢复成断点地址，以执行原来被中断打断的程序。</li><li>(4)清除CPSR中的中断屏蔽标志位I和F，开放外部中断和快速中断。</li></ul> 
<h3><a id="11ARM_248"></a>11.ARM指令特点</h3> 
<ul><li>大多数数据操作都在寄存器中完成。</li><li>寻址方式灵活简单,执行效率高。</li><li>指令长度固定。</li></ul> 
<p>为了保证ARM处理器具有高性能的同时，进一步减少芯片的体积和功耗，ARM处理器采用了以下一些比较特别的技术</p> 
<ul><li>所有的指令都可根据前面的执行结果决定是否被执行,从而提高指令的执行效率。</li><li>可用加载/存储指令批量传输数据,以提高数据的传输效率。</li><li>可在一条数据处理指令中同时完成逻辑处理和移位处理。</li><li>在循环处理中使用地址的自动增减来提高运行效率。</li></ul> 
<h3><a id="12_261"></a>12.嵌入式操作系统</h3> 
<blockquote> 
 <p>定义：运行在嵌入式硬件平台上,对整个系统及其所操作的部件、装置等资源进行统一协调、 指挥和<br> 控制的系统软件。</p> 
</blockquote> 
<p>特点：</p> 
<ul><li>微型化</li><li>可裁剪性</li><li>实时性</li><li>高可靠度性</li><li>易移植性</li></ul> 
<h3><a id="13RTOS_274"></a>13.实时操作系统（RTOS）</h3> 
<p>有两种定义方式：</p> 
<ul><li>RTOS是具有实时性能且能支持实时控制系统工作的操作系统。</li><li>RTOS是一个程序， 它按时序方式调度执行,管理系统资源,并为开发应用代码提供一致的基础。</li></ul> 
<blockquote> 
 <p>学习了操作系统，我们知道操作系统本身就属于软件层次，只不过那一层叫系统软件。</p> 
</blockquote> 
<p>RTOS的<strong>首要</strong>任务是<strong>调度一切可利用的资源来完成实时控制任务</strong>,<strong>其次</strong>才着眼于<strong>提高计算机系统的使用效率</strong>,其重要特点是<strong>能满足对时间的限制和要求</strong>。在实时计算中,系统的正确性不仅依赖于计算的逻辑结果,而依赖于结果产生的时间。</p> 
<h3><a id="14_285"></a>14.交叉编译</h3> 
<p>本地编译：在当前平台编译，编译得到的程序在本地执行。</p> 
<p>交叉编译：在一个平台上生成另一个平台的可执行代码。</p> 
<p>常见的三种交叉编译方法:</p> 
<ul><li>Windows PC. 上，利用ADS (ARM开发环境)，使用armcc编 .译器，编译出针对ARM CPU的可执行代码</li><li>Linux PC上，利用arm-linux-gc编译器，编译出针对Linux ARM平台的可执行代码</li><li>Windows PC上，利用cygwin环境，运行arm-elf-gcc编译器，编译出针对ARM CPU的可执行代码</li></ul> 
<p>一般嵌入式开发系统存储大小是有限的, 通常都要在性能优越的PC上建立一个用于目标机的交叉编译工具链。</p> 
<p>交叉编译工具链是一个由编译器、连接器和解释器组成的综合开发环境，交叉编译工具链主要由binutils、gcc和glibc3个部分组成。有时出于减小libc库大小的考虑，也可以用别的c库来代替g| ibc， 例如uClibc、dietlibc和newlib。</p> 
<blockquote> 
 <p>交叉编译工具链的制作：</p> 
 <p>制作arm- linux交叉编译工具链的一般通过crosstool或者crosstool_ NG。前者使用方便，但是制作会受到一些限制,使用crosstool最多只能编译gcc 4.1.1、glibc 2. x的版本。而crosstool_ NG则 有更好的定制性，并且一直保持着更新，对新版本的编译工具链的支持比较好，必须先配置安装。</p> 
</blockquote> 
<h3><a id="15Linux_305"></a>15.Linux文件系统</h3> 
<p>文件系统是负责存取和管理文件信息的机构,用于对数据、文件以及设备的存取控制,它提供对文件和目录的分层组织形式、数据缓冲以及对文件存取权限的控制功能。</p> 
<p>文件系统具有以下主要功能:</p> 
<ul><li>1.对文件存储设备进行管理,分别记录空闲区和被占用区,以便于用户创建、修改以及删除文件时对空间的操作。</li><li>2.对文件和目录的按名访问、分层组织功能。</li><li>3.创建、删除及修改文件功能。</li><li>4.数据保护功能。</li><li>5.文件共享功能</li></ul> 
<blockquote> 
 <p>补充（虚拟文件系统VFS）：</p> 
 <p>为了支持多种不同的文件系统，采用了虚拟文件系统VFS (Virtual File system)技术。虚拟文件系统是<strong>对多种实际文件系统的共有功能的抽象</strong>，它<strong>屏蔽了各种不同文件系统在实现细节上的差异</strong>，为用户程序提供了统一的、抽象的、标准的接口以便对文件系统，进行访问，如打开，读，写等操作。<br> <strong>虚拟文件系统VFS确保了对所有文件的访问方式都是完全相同的</strong>。</p> 
</blockquote> 
<p>主要的Linux文件系统由ext2、ext3、ext4。</p> 
<h3><a id="16_324"></a>16.嵌入式文件系统</h3> 
<blockquote> 
 <p><strong>嵌入式文件系统是指嵌入式系统中实现文件存取管理等功能的模块，这些模块提供一系列文件输入</strong><br> <strong>输出等文件管理功能，为嵌入式系统和设备提供文件系统支持。</strong></p> 
</blockquote> 
<p>在嵌入式系统中，文件系统是嵌入式系统的一个组成模块。它是作为系统的一个可加载选项提供给用户，由用户决定是否需要加载它。嵌入式文件系统具有结构紧凑、使用简单便捷、安全可靠及支持多种存储设备、可伸缩、可剪裁、可移植等特点。</p> 
<p>主流的嵌入式文件操作系统：QNX、VxWorks、yaffs/yaffs2、Cramfs、NFS（网络文件系统）、</p> 
<p><img src="https://images2.imgbox.com/0d/c5/irezHuZd_o.png" alt="在这里插入图片描述"></p> 
<p>根文件系统是-种特殊的文件系统，该文件系统不仅具有普通文件系统的存储数据文件的功能，它还是内核启动时所挂载(mount)的第一个文件系统，内核代码的映像文件保存在根文件系统中，系统引导启动程序会在根文件系统挂载之后从中把一些初始化脚本和服务加载到内存中去运行。</p> 
<h3><a id="17Flash_338"></a>17.Flash</h3> 
<p>Flash是一种基于ROM的存储器，其主要特点是既可在不加电的情况下长期保存信息，又能在线进行快速擦除和重写。</p> 
<p>Nor Flash和Nand Flash的对比：</p> 
<p>Nor Flash通常容量较小,其主要特点是程序代码可以直接在Flash内运行。Nor Flash具有RAM接口,易于访问，缺点<br> 是擦除电路复杂,写速度和擦除速度都比较慢,最大擦写次数约10万次,典型的块大小是128kB。<br> Nand Flash通常容量较大，具有很高的存储密度，从而降低了单位价格。Nand Flash的块尺寸较小,典型大小为8kB，<br> 擦除速度快,使用寿命也更长,最大擦写次数可以达到100万次,但是其访问接口是复杂的I/O口，并且坏块和位反转现象较多，对驱动程序的要求较高。</p> 
<blockquote> 
 <p>一般结论:由于Nor Flash和Nand Flash各具特色，因此它们的用途也各不相同, Nor Flash 一般用来存储体积较小的代码，而Nand Flash则用来存放大体积的数据。</p> 
</blockquote> 
<h3><a id="18Uboot_351"></a>18.U-boot</h3> 
<p>U-Boot ,全称为Universal Boot Loader(通用bootloader) ,是遵循GPL条款的开放源码项目。由德国DENX小组开发和维护的 ,其高超的技术使得U-Boot能够非常容易地被移植到多种嵌入式CPU中，支持多种嵌入式操作系统内核的引|导。</p> 
<p>这里赠送U-boot所有版本的下载地址：<a href="http://ftp.denx.de/pub/u-boot/" rel="nofollow">下载请点击我</a></p> 
<p>BootLoader的实现依赖于处理器的体系结构,为了移植的方便,大多数BootLoader可以分为两个阶段stage1和stage2。依赖于处理器体系结构的代码,比如CPU初始化, 一般都放在stage1阶段,通常多用汇编语言来实现, stage1必须是位置无关码。stage2通常用C语言来实现,这样可以实现给复杂的功能,而且代码会具有更好的可读性和可移植性。</p> 
<blockquote> 
 <p>U-Boot第一阶段主要使用<strong>汇编语言</strong>编写,程序的入口在start.s中，经常会出现<strong>CONFIG_ SPL _BUILD</strong>宏,用于控制程序的条件编译。</p> 
</blockquote> 
<p>U-boot移植步骤：</p> 
<p><img src="https://images2.imgbox.com/4c/3b/pYFinveR_o.png" alt="在这里插入图片描述"></p> 
<ul><li>步骤一:建立自己的平台</li><li>步骤二:创建开发板信息</li><li>步骤三:修改顶层Makefile</li><li>步骤四:修改start.S和lowlevel init.S</li><li>步骤五:实现串口输出</li><li>步骤六:网卡移植</li><li>步骤七: Flash移植</li></ul> 
<h3><a id="19Linux_374"></a>19.Linux设备驱动</h3> 
<blockquote> 
 <p>Linux的一个重要特性:将所有的设备都视为文件进行处理------设备文件。</p> 
</blockquote> 
<p>设备驱动程序是内核的一部分，主要完成以下功能:</p> 
<ul><li>对设备初始化和释放</li><li>把数据从内核传送到硬件和从硬件读取数据</li><li>读取应用程序传送给设备文件的数据和回送应用程序请求的数据</li><li>检测错误和处理中断</li></ul> 
<p><img src="https://images2.imgbox.com/6f/e8/Nol1xBJD_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="20GPIO_387"></a>20.GPIO驱动</h3> 
<p>“通用输入输出”GPI0 (general purpose .input output)是嵌入式系统中最简单，最常用的I/0接口。GPI0是一组可编程控制的管脚，由多个寄存器同时控制。通过设置对应的寄存器可以达到设置GPI0口对应状态与功能如读取数据状态，设置输入输出方向，清零，中断使能等功能。</p> 
<p>GPI0的驱动主要作用就是读取GPI0口的内容,或者设置GPI0口的状态。GPIO是与硬件体系密切相关,在linux内核目录<br> 下的相关文件中我们可以发现针对不同硬件芯片的GPI0定义和使用方法，linux内 核中也有相应的驱动程序支持( 在/drivers/gpio/)。当然，linux内核也提供了一个模型框架，能够使用统一的接口来操作GPI0，这个架构被作”gpiolib"，系统通过gpiolib. c文件来描述该架构。</p> 
<h3><a id="21SoC_394"></a>21.SoC片上系统</h3> 
<p>SoC（System-on-a-Chip，片上系统）是一种将多个功能模块集成在一个单一的芯片上的技术。SoC通常包含处理器核心（如CPU、GPU）、内存、外设接口以及其他功能模块，这些模块共同构成了一个完整的系统。SoC技术可以降低设备的功耗、尺寸和成本，因此在嵌入式系统、移动设备等领域得到了广泛应用。</p> 
<p>SoC的主要优势如下：</p> 
<ul><li>1.集成度高：SoC将多个功能模块集成在一个芯片上，减少了外部连接器和电路板的需求，从而降低了系统的复杂度。</li><li>2.体积小、重量轻：由于集成度高，SoC可以大幅减小设备的体积和重量，使得其适用于各种便携式设备。</li><li>3.功耗低：SoC采用高度集成的设计，减少了电路间的信号传输距离，从而降低了功耗。</li><li>4.成本低：SoC将多个功能模块集成在一个芯片上，减少了组装和测试的成本，使得设备的总成本降低。</li></ul> 
<p>然而，SoC的设计和制造过程相对复杂，需要投入较多的研发资源。此外，SoC的可扩展性和可升级性相对有限，因为硬件功能已经集成在芯片上，难以进行单独的升级或替换。</p> 
<blockquote> 
 <p>片上系统(System on a Chip， SoC) 是ASIC(Application Specific Integrated Circuits)设计方法学中产生的一种新技术，是指以嵌入式系统为核心，以IP (Intellectual Property) 复用技术为基础，集软、硬件于一体，并追求产品系统最大包容的集成芯片。</p> 
</blockquote> 
<h3><a id="22Linux_409"></a>22.Linux内核裁剪</h3> 
<p>Linux内核裁剪是指根据特定的应用需求，移除不需要的功能模块，以减小内核的体积和资源占用。这在嵌入式系统中尤为重要，因为嵌入式设备通常具有有限的存储空间和计算能力。通过裁剪内核，可以提高系统的性能和效率，降低功耗，满足嵌入式设备的特殊需求。</p> 
<p>进行Linux内核裁剪的主要步骤如下：</p> 
<ol><li>获取Linux内核源代码：从官方网站或设备制造商处获取适用于目标硬件平台的Linux内核源代码。</li><li>配置内核选项：使用内核配置工具（如<code>make menuconfig</code>）来选择需要保留的功能模块和驱动程序，禁用不需要的部分。可以根据目标设备的硬件特性和应用需求进行选择。</li><li>编译内核：在宿主机上使用交叉编译工具链编译定制后的内核源代码，生成内核映像文件（如<code>zImage</code>或<code>uImage</code>）。</li><li>安装内核：将编译好的内核映像文件部署到目标设备上，替换原有的内核。这可以通过烧写到设备的闪存或者通过网络引导等方式实现。</li><li>测试和验证：启动目标设备，验证定制后的内核是否正常运行，以及所需功能是否完整可用。</li></ol> 
<p>需要注意的是，进行Linux内核裁剪时要确保保留必要的驱动程序和功能模块，以保证系统的正常运行。在裁剪过程中，可能需要多次尝试和调整配置选项，以达到最佳的性能和资源占用平衡。</p> 
<h3><a id="23_423"></a>23.微控制器</h3> 
<p>微控制器的最大特点是单片化，体积大大减小，从而使功耗和成本下降、可靠性提高。</p> 
<h2><a id="_427"></a>三.判断题知识点</h2> 
<h3><a id="1_429"></a>1.嵌入式系统的设计过程</h3> 
<p>嵌入式系统设计是指为特定应用需求开发和实现一个高度集成、专用的计算系统。嵌入式系统通常由硬件和软件两部分组成，硬件包括处理器、内存、外设接口等，软件包括操作系统、驱动程序、应用程序等。嵌入式系统设计需要考虑多种因素，如性能、功耗、可靠性、成本等，以满足特定应用场景的需求。</p> 
<ol><li>需求分析：分析应用场景的需求，确定系统的功能、性能、尺寸、功耗等指标。</li><li>体系结构设计：体系结构设计是指根据应用需求和性能指标，确定系统的整体结构和各个模块之间的关系。这涉及到处理器的选择、总线结构的设计、内存和存储系统的组织、外设接口的配置等。</li><li>硬件设计：选择合适的处理器、内存、外设接口等硬件组件，设计电路板和硬件架构。</li><li>软件设计：选择合适的操作系统（如Linux、RTOS等），开发驱动程序、中间件和应用程序。这可能涉及到编写底层硬件控制代码、实现通信协议、开发用户界面等。</li><li>系统集成：将硬件和软件组件整合到一起，进行系统级的测试和验证。这可能包括功能测试、性能测试、稳定性测试等。</li><li>优化和调试：根据测试结果，对硬件和软件进行优化和调试，以提高系统的性能、稳定性和可靠性。</li><li>生产和部署：将设计好的嵌入式系统进行量产，并部署到实际应用环境中。</li></ol> 
<h3><a id="2ARM_441"></a>2.ARM处理器寄存器</h3> 
<p>Cortex-A9处理器共有40个32位寄存器，包括33个通用寄存器和7个状态寄存器。其中状态寄存器包括1个CPSR (CurrentProgram Status Register， 当前程序状态寄存器)和6个SPSR(Saved Program Status Register， 备份程序状态寄存器)。这些寄存器不能同时访问，在不同的处理器工作模式下只能够访问一组相应的寄存器组。</p> 
<p><img src="https://images2.imgbox.com/14/51/RZc1je7O_o.png" alt="在这里插入图片描述"></p> 
<p>1)通用寄存器组：</p> 
<ul><li>R0~R7是不分组的通用寄存器;</li><li>R8~R15是分组的通用寄存器;</li><li>在ARM状态下，任何时刻，16个数据寄存器R0~ R15和1~2个状态寄存器是可访问的。在特权模式下，特定模式下的寄存器阵列才是有效的。</li></ul> 
<blockquote> 
 <p><strong>未分组的通用寄存器R0~R7</strong>用于保存数据和地址。在处理器的所有工作模式下，它们中的每一个都指向一个物理寄存器,且没有被系统用于特殊用途。在处理器工作模式切换时，由于使用的是相同的物理存储器，可能会破坏寄存器中的数据。</p> 
 <p><strong>分组的通用寄存器R8~ R15</strong>则具有不同的处理器工作模式决定访问的物理寄存器不同的特点。如上图所示，每个物理寄存器名字的形式为<code>Rx_ &lt;mode&gt;，&lt;mode&gt;</code> 是模式标识符，每个模式标识符指示当前所处的工作模式。</p> 
</blockquote> 
<p>2)状态寄存器:<br> ARM处理器有两类程序状态寄存器:1个当前程序状态寄存器CPSR和6个备份程序状态寄存器SPSR。它们的主要功能是:</p> 
<ul><li>➢保存最近执行的算术或逻辑运算的信息;</li><li>➢控制中断的允许或禁止;</li><li>➢设置处理器工作模式。</li></ul> 
<p>每一种处理器模式下使用专用的备份程序状态寄存器。当特定的中断或异常发生时，处理器切换到对应的工作模式下，该模式下的备份程序状态寄存器保存当前程序状态寄存器的内容。当异常处理程序返回时，再将其内容从备份程序状态寄存器回复到当前程序状态寄存。</p> 
<h3><a id="3_467"></a>3.处理器工作模式</h3> 
<p><img src="https://images2.imgbox.com/2c/80/ohqpxS3L_o.jpg" alt="在这里插入图片描述"></p> 
<ul><li><strong>特权模式</strong>：是为了服务中断或异常，或访问受保护的资源，具有多系统资源的完全访问权限，可自由的切换工作模式。</li><li><strong>系统模式</strong>：系统模式不能由任何异常进入，它有与用户模式完全相同的寄存器，系统模式供需要访问系统资源的操作系统任务使用，这样避免使用和异常模式相关的寄存器，保证在任何异常发生时都不会使任务的状态不可靠。</li><li><strong>异常模式</strong>：除了可以通过程序切换进入外，还可以在发生特定的异常中断时进入。每一种异常模式都有一组专用的寄存器，以保证在进入异常模式时用户模式下的寄存器(保存着工作模式切换前的程序运行状态)不被破坏。</li></ul> 
<h3><a id="4_476"></a>4.处理器工作状态</h3> 
<p>Cortex- A9处理器是32位处理器，可执行32位ARM指令集指令，同时兼容16位Thumb-2指令集指令和数据类型。有<strong>3种工作状态</strong>，这些状态由<strong>程序状态寄存器</strong>(CPSR)的<strong>T位和J位</strong>控制与切换。</p> 
<ul><li>➢ARM状态:执行32位的字对齐的ARM指令集指令，T位和J位为0;</li><li>➢Thumb状态:执行16位或32位半字对齐的Thumb-2指令集指令，T位为1, J位为0;</li><li>➢ThumbEE状态:执行为动态产生目标而设计的16位或32位半字对齐的Thumb-2指令集的变体，T位和J位为1。</li></ul> 
<blockquote> 
 <p>ARM指令必须在ARM状态下执行;Thumb指令也必须在Thumb状态下执行。<br> ARM处理器可以在两种状态下切换，只要遵循ATPCS调用规则，ARM子程序和Thumb子程序之间可以相互调用。<br> ARM状态和Thumb状态之间的切换并不影响处理器工作模式和寄存器组的内容。<strong>处理器复位后开始执行代码时，处于ARM状态。</strong></p> 
</blockquote> 
<p>处理器状态之间的切换:</p> 
<ul><li> <p>(1) ARM状态和Thumb状态之间切换<br> 执行BX和BL.X指令时，将通用寄存器的中所存储的目标地址值复制到程序寄存器PC，该目标地址值的最低一位为1则切换到Thumb状态。如果处理器在Thumb状态时发生<strong>异常</strong>(异常处理必须在ARM状态下)，当异常处理返回时自动切换到Thumb状态。<br> 执行BX和BL.X指令时，将通用寄存器的中所存储的目标地址值复制到程序寄存器PC，该目标地址值的最低一位为0则切换到ARM状态。处理器进行异常处理时，把PC的值放入异常模式链接寄存器中，从异常向量地址开始执行程序，系统自动进入ARM状态。</p> </li><li> <p>(2) Thumb状态和ThumbEE状态之间切换<br> 使用ENTERX指令和LEAVEX指令。</p> 
  <blockquote> 
   <p>得出结论：ARM处理器切换工作状态是自动的。</p> 
  </blockquote> </li></ul> 
<h3><a id="5CISCRISC_499"></a>5.CISC和RISC</h3> 
<p>看单选题部分知识点</p> 
<h3><a id="6Linux_503"></a>6.嵌入式Linux操作系统</h3> 
<p>看单选题部分知识点</p> 
<h3><a id="7Linux_507"></a>7.嵌入式Linux操作系统移植</h3> 
<p>嵌入式Linux操作系统移植是指将Linux操作系统定制和优化，使其能够在特定的嵌入式硬件平台上运行。这个过程通常包括内核定制、驱动开发、文件系统构建和引导程序配置等步骤。</p> 
<p>以下是嵌入式Linux操作系统移植的主要步骤：</p> 
<ol><li>准备工作：获取目标硬件平台的技术文档和参考资料，了解硬件的特性和接口。同时，搭建交叉编译环境，用于在宿主机上编译目标硬件平台的Linux内核和应用程序。</li><li>内核定制：根据目标硬件平台的特性，对Linux内核进行裁剪和优化。这包括选择合适的处理器架构、禁用不需要的功能模块、添加硬件支持等。使用内核配置工具（如<code>make menuconfig</code>）进行配置，然后使用交叉编译工具链编译内核。</li><li>驱动开发：根据目标硬件平台的外设接口，开发相应的设备驱动程序。这可能包括GPIO、UART、SPI、I2C等接口的驱动开发。将驱动程序集成到内核中，或作为模块进行加载。</li><li>文件系统构建：为目标硬件平台创建适用的文件系统。这可以是只读的根文件系统（如SquashFS）、可读写的根文件系统（如ext4）、或者基于RAM的临时文件系统（如initramfs）。文件系统中需要包含Linux操作系统的基本组件，如库文件、系统工具、配置文件等，以及针对特定应用的程序和数据。</li><li>引导程序配置：配置引导程序（如U-Boot）以加载定制的Linux内核和文件系统。引导程序需要设置正确的内核参数、内存布局、设备树等信息，以确保系统能够正常启动。</li><li>测试和调试：将定制的Linux操作系统部署到目标硬件平台上，进行功能测试、性能测试和稳定性测试。根据测试结果，对内核、驱动程序和应用程序进行调整和优化，以提高系统的性能、稳定性和可靠性。</li><li>问题定位和解决：在测试和调试过程中，可能会遇到各种问题，如系统启动失败、驱动程序无法加载、应用程序崩溃等。针对这些问题，需要使用调试工具（如gdb、strace等）和日志信息进行定位和分析，并采取相应的措施进行解决。</li></ol> 
<h3><a id="8_521"></a>8.嵌入式系统开发调试</h3> 
<p>嵌入式系统开发调试是在嵌入式系统开发过程中，通过各种工具和方法对硬件和软件进行测试和分析，以找出潜在问题并解决，确保系统的正常运行和性能。</p> 
<p>以下是一些常用的嵌入式系统开发调试方法和工具：</p> 
<ol><li>模拟器和仿真器：在开发初期，可以使用模拟器和仿真器在PC上模拟目标硬件平台，进行软件开发和初步测试。这可以节省硬件成本，加速开发过程。常用的模拟器和仿真器有QEMU、Keil MDK等。</li><li>JTAG调试：JTAG（Joint Test Action Group）是一种常用的硬件调试接口，可以通过JTAG接口直接访问目标硬件的CPU、内存和寄存器等资源。使用JTAG调试器（如OpenOCD、J-Link等）和调试软件（如GDB、IAR Embedded Workbench等），可以实现代码的单步执行、断点设置、内存查看等功能，方便进行硬件级别的调试。</li><li>串口调试：在嵌入式系统中，串口通常用于输出调试信息和与外部设备通信。通过串口调试工具（如minicom、putty等），可以实时查看系统的运行状态、错误信息等，方便进行软件调试。</li><li>逻辑分析仪：逻辑分析仪是一种硬件调试工具，可以捕获和分析数字信号的波形和时序。通过逻辑分析仪，可以观察硬件接口（如GPIO、SPI、I2C等）的信号变化，帮助定位硬件问题和通信错误。</li><li>示波器：示波器是一种常用的电子测量仪器，可以观察信号的波形和频率。对于模拟信号和高速数字信号的调试，示波器是必不可少的工具。</li></ol> 
<h3><a id="9ARM_533"></a>9.ARM中断异常概念</h3> 
<p>异常是ARM处理器处理外部异步事件的一种方法，也称为中断。当处理器在正常执行程序的过程中，一个来自外部或内部的异常事件发生，处理器暂时中断当前程序的执行，跳转到相应的异常处理程序入口执行异常处理。在处理这个异常事件之前，处理器要保存当前处理器的状态和返回地址，以便异常处理程序结束后能返回原来的程序继续执行。若同时有多个异常发生，处理器将根据异常中断优先级来处理这些异常。</p> 
<h3><a id="10_537"></a>10.冯诺依曼结构和哈佛结构</h3> 
<p>看单选题部分。</p> 
<h2><a id="_541"></a>四.简答题知识点</h2> 
<h3><a id="1_543"></a>1.嵌入式系统定义、特点和组成</h3> 
<blockquote> 
 <p>定义：以<strong>应用</strong>为中心、以<strong>计算机技术</strong>为基础，软件硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗等严格要求的<strong>专用计算机系统</strong>。</p> 
</blockquote> 
<blockquote> 
 <p>特点：嵌入性、专用性、计算机系统</p> 
</blockquote> 
<blockquote> 
 <p>组成：硬件层、中间层、操作系统层、应用软件层</p> 
</blockquote> 
<h3><a id="2_551"></a>2.嵌入式硬件系统</h3> 
<h4><a id="1_553"></a>1.嵌入式处理器</h4> 
<p><img src="https://images2.imgbox.com/22/f1/sopVoT0x_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_558"></a>2.异常响应过程</h4> 
<p>通常，异常(中断)响应大致可以分为以下几个步骤:</p> 
<ul><li>(1)保护断点，即保存下一个将要执行的指令的地址，就是把这个地址送入堆栈;</li><li>(2)寻找中断入口，根据不同的中断源所产生的中断，查找不同的入口地址;</li><li>(3)执行中断处理程序;</li><li>(4)中断返回，执行完中断指令后，就从中断处返回到主程序，继续执行。</li></ul> 
<h3><a id="3_567"></a>3.嵌入式软件系统</h3> 
<h4><a id="1Linux_569"></a>1.嵌入式Linux内核</h4> 
<p>Linux操作系统的灵魂是Linux内核,内核为系统其他部分提供系统服务。ARM-Linux内核是专门适应ARM体系结构设计的Linux内核,负责整个系统的:进程管理和调度、内存管理、文件管理、设备管理和网络管理等主要系统功能。</p> 
<blockquote> 
 <p>ARM-Linux内核版本变化与Linux内核版本变化保持同步。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/69/50/dfOGog2w_o.png" alt="在这里插入图片描述"></p> 
<p>这五个系统相互依赖,缺一不可,但是相对而言进程管理处于比较重要的地位,其他子系统的挂起和恢复进程的运行都必须依靠进程调度子系统的参与。</p> 
<h4><a id="2_580"></a>2.实时操作系统</h4> 
<p>有两种定义方式：</p> 
<ul><li>RTOS是具有实时性能且能支持实时控制系统工作的操作系统。</li><li>RTOS是一个程序， 它按时序方式调度执行,管理系统资源,并为开发应用代码提供一致的基础。</li></ul> 
<blockquote> 
 <p>学习了操作系统，我们知道操作系统本身就属于软件层次，只不过那一层叫系统软件。</p> 
</blockquote> 
<p>RTOS的<strong>首要</strong>任务是<strong>调度一切可利用的资源来完成实时控制任务</strong>,<strong>其次</strong>才着眼于<strong>提高计算机系统的使用效率</strong>,其重要特点是<strong>能满足对时间的限制和要求</strong>。在实时计算中,系统的正确性不仅依赖于计算的逻辑结果,而依赖于结果产生的时间。</p> 
<h4><a id="3VFS_591"></a>3.VFS</h4> 
<blockquote> 
 <p>虚拟文件系统是<strong>对多种实际文件系统的共有功能的抽象</strong>，它<strong>屏蔽了各种不同文件系统在实现细节上的差异</strong>，为用户程序提供了统一的、抽象的、标准的接口以便对文件系统，进行访问，如打开，读，写等操作。<br> <strong>虚拟文件系统VFS确保了对所有文件的访问方式都是完全相同的</strong>。</p> 
</blockquote> 
<p>VFS是底层文件系统的主要组件(接口)。这个组件导出一组接口，然后将它们抽象到行为可能差异很大的各个文件系统。VFS具有两个针对文件系统对象的缓存:<strong>inode索引节点对象</strong>和<strong>dentry目录项对象</strong>，它们缓存最近使用过的文件系统对象。每个文件系统实现(如ext2、JFFS2等等) 可以导出一组通用接口供VFS使用。缓冲区缓存会缓存文件系统和相关块设备之间的请求。</p> 
<p>思想：<strong>面向对象设计思想</strong></p> 
<h3><a id="4_600"></a>4.嵌入式系统应用领域</h3> 
<ul><li><strong>无线通讯产品</strong>:比如手机、基站和无线交换机等无线通信设备大量使用嵌入式OS和中间件(通信协议等)。</li><li><strong>网络产品</strong>:比如路由器、交换机、接入设备和信息安全产品等大量使用RTOS和开源的Linux OS。</li><li><strong>智能家电</strong>:比如智能电视、IP机顶盒、互联网冰箱等产品大量使用包括Android在内的嵌入式OS。</li><li><strong>航空航天和军事装备</strong>:包括飞机、宇航器、舰船和武器装备等都在使用经过认证的RTOS ,这个领域也是嵌入式OS最早开发的市场之一。</li><li><strong>汽车电子</strong>:现代汽车和运输工具大量使用MCU技术,正在从采用私有的RTOS转向标准和开放的RTOS和通用的嵌入式OS技术，随着智能交通和车联网发展,汽车电子将给嵌入式OS发展带来一个新的春天。</li><li>**物联网产业和技术:**物联网和云计算是IT产业技术发展的两大推手。其中物联网技术和产业的发展都嵌入式系统和嵌入式OS的影响更大,需要嵌入式OS支持更加优秀的低功耗和无线网络技术,随着产业发展和成熟,需求会越来越大。</li></ul> 
<h3><a id="5Linux_609"></a>5.嵌入式Linux系统构建流程</h3> 
<p><img src="https://images2.imgbox.com/1c/2f/qnzUVaDX_o.png" alt="在这里插入图片描述"></p> 
<p>一个嵌入式linux系统通常由引导程序及参数、linux内核、文件系统和用户应用程序组成。由于嵌入式系统与开发主机运行的环境不同,这就为开发嵌入式系统提出了开发环境特殊化的要求。交叉开发环境正是在这种背景下应运而生。</p> 
<ul><li>第一步:根据系统硬件平台的状况进行移植</li><li>第二步:采取交叉编译对源代码进校编译，形成运行时需要的映像文件</li></ul> 
<h2><a id="_619"></a>五.综合设计题</h2> 
<h3><a id="1makefilemake_621"></a>1.makefile、make</h3> 
<p>make的作用：1.自动化编译 2.处理多个文件 3.文档处理</p> 
<blockquote> 
 <p>makefile的工作原理：</p> 
 <ul><li>Makefile的工作需要make程序及makefile文本文件</li><li>调用系统中的make命令解释当前的makefile，完成其中特定的功能</li></ul> 
</blockquote> 
<p><a href="https://blog.csdn.net/weixin_51496226/article/details/130462583">书写makefile代码请点击</a></p> 
<h3><a id="2GPIOLED_632"></a>2.GPIO编程、LED驱动</h3> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED2_GPIO</span> <span class="token expression"><span class="token number">87</span> </span><span class="token comment">// GPX2_7</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED3_GPIO</span> <span class="token expression"><span class="token number">16</span> </span><span class="token comment">// GPX1_0</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED4_GPIO</span> <span class="token expression"><span class="token number">84</span> </span><span class="token comment">// GPX2_4</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED5_GPIO</span> <span class="token expression"><span class="token number">125</span> </span><span class="token comment">// GPF3_5</span></span>

<span class="token comment">// 导出GPIO</span>
<span class="token keyword">void</span> <span class="token function">gpio_export</span><span class="token punctuation">(</span><span class="token keyword">int</span> gpio<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/sys/class/gpio/export"</span><span class="token punctuation">,</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 设置GPIO方向</span>
<span class="token keyword">void</span> <span class="token function">gpio_set_direction</span><span class="token punctuation">(</span><span class="token keyword">int</span> gpio<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>direction<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"/sys/class/gpio/gpio%d/direction"</span><span class="token punctuation">,</span> gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> direction<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>direction<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 设置GPIO值</span>
<span class="token keyword">void</span> <span class="token function">gpio_set_value</span><span class="token punctuation">(</span><span class="token keyword">int</span> gpio<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"/sys/class/gpio/gpio%d/value"</span><span class="token punctuation">,</span> gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> led_gpios<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>LED2_GPIO<span class="token punctuation">,</span> LED3_GPIO<span class="token punctuation">,</span> LED4_GPIO<span class="token punctuation">,</span> LED5_GPIO<span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 导出GPIO并设置为输出模式</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>led_gpios<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>led_gpios<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">gpio_export</span><span class="token punctuation">(</span>led_gpios<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_set_direction</span><span class="token punctuation">(</span>led_gpios<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 循环控制LED的亮灭</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>led_gpios<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>led_gpios<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">gpio_set_value</span><span class="token punctuation">(</span>led_gpios<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出高电平，点亮LED</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">gpio_set_value</span><span class="token punctuation">(</span>led_gpios<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出低电平，熄灭LED</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="3_700"></a>3.实验案例</h3> 
<blockquote> 
 <p>嵌入式系统不是都需要操作系统，要学会分析和判断! ! !</p> 
</blockquote> 
<p>嵌入式硬件平台选型：</p> 
<p>嵌入式软件可以根据功能和层次划分为以下几类：</p> 
<ol><li><strong>应用软件</strong>：这是嵌入式系统中直接与用户或其他系统交互的软件部分。应用软件负责实现特定的功能或任务，如数据采集、控制算法、图形界面等。应用软件通常基于操作系统或其他底层软件进行开发，使用高级编程语言（如 C、C++、Python 等）编写。</li><li><strong>网络软件</strong>：这部分软件负责嵌入式系统中的网络通信功能，如 TCP/IP 协议栈、Wi-Fi、蓝牙、LoRa 等。网络软件可以是操作系统内置的组件，也可以是第三方库或驱动程序。网络软件使嵌入式设备能够与其他设备或云端服务进行数据交换和远程控制。</li><li><strong>系统软件</strong>：这是嵌入式系统中的核心部分，包括操作系统、实时操作系统（RTOS）或裸机系统。系统软件负责管理硬件资源（如 CPU、内存、外设等），为应用软件提供基本的运行环境和服务。常见的嵌入式操作系统有 Linux、FreeRTOS、VxWorks、uC/OS 等。</li><li><strong>驱动软件</strong>：驱动软件是嵌入式系统中负责与硬件设备通信的底层软件。驱动程序将硬件设备的操作抽象为简单的接口，供上层软件调用。驱动软件通常与操作系统或硬件平台紧密相关，可能需要使用汇编语言或硬件相关的 C 语言编写。常见的驱动类型包括 GPIO、UART、I2C、SPI、USB 等</li></ol> 
<h3><a id="4_713"></a>4.主要存储器的设备特征</h3> 
<ol><li> <p><strong>SRAM（静态随机存取存储器）</strong>：</p> 
  <ul><li>易失性：是的，断电后数据丢失</li><li>读写速度：非常快，通常比 DRAM 和 NAND Flash 快</li><li>特点：无刷新需求，低功耗，高速，成本高，集成度低，容量较小，通常用于高速缓存（如 CPU 缓存）</li></ul> </li><li> <p><strong>DRAM（动态随机存取存储器）</strong>：</p> 
  <ul><li>易失性：是的，断电后数据丢失</li><li>读写速度：较快，通常比 NAND Flash 快，但比 SRAM 慢</li><li>特点：需要定期刷新以保持数据，功耗较高，速度较快，成本适中，集成度较高，容量较大，通常用于主内存（如计算机、手机的 RAM）</li></ul> </li><li> <p><strong>NAND Flash（NAND型闪存）</strong>：</p> 
  <ul><li>易失性：否，断电后数据保持</li><li>读写速度：较慢，通常比 SRAM 和 DRAM 慢</li><li>特点：非易失性，无需刷新，低功耗，速度较慢，成本低，集成度高，容量大，通常用于数据存储（如 SSD、U盘、SD卡、嵌入式设备的存储器）<br> 系统。系统软件负责管理硬件资源（如 CPU、内存、外设等），为应用软件提供基本的运行环境和服务。常见的嵌入式操作系统有 Linux、FreeRTOS、VxWorks、uC/OS 等。</li></ul> </li></ol> 
<p><img src="https://images2.imgbox.com/59/a3/igdetshZ_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0375f4e5b9bb84399291ca0ab9717000/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">实现虚拟机（VM15.5.0）与本机相互通信</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/91f878fe84411a74f9c646be9872f639/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VMware15.5.0虚拟机安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>