<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>opencv&#43;GDAL 遥感影像滤波 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="opencv&#43;GDAL 遥感影像滤波" />
<meta property="og:description" content="参考： 1、https://docs.opencv.org/3.2.0/
1、python版 其中m1 参考：http://blog.csdn.net/wc781708249/article/details/78394933
#!/usr/bin/env python # -*- coding: UTF-8 -*- &#34;&#34;&#34; 数据：遥感图像 16bit 4波段 对应opencv数据格式为CV_16UC4，转成float32对应的数据格式为CV_32FC4 操作：滤波操作 &#34;&#34;&#34; from scipy import ndimage try: from osgeo import gdal except: import gdal import gdalnumeric from osgeo.gdalconst import * import numpy as np from datetime import datetime import m1 import cv2 start_time=datetime.now() # 为了支持中文路径，请添加下面这句代码 gdal.SetConfigOption(&#34;GDAL_FILENAME_IS_UTF8&#34;,&#34;NO&#34;) gdal.AllRegister() #注册驱动 img1_path=&#34;D:/test.tiff&#34; img=m1.Multiband2Array(img1_path) raster_fn=&#34;D:/test_2.tif&#34; # 各种滤波处理 dst=cv2.blur(img,(15,15)) # 均值滤波 可以处理CV_32FC4 dst=cv2.GaussianBlur(img,(5,5),0) # 高斯滤波 可以处理CV_32FC4 dst=cv2.medianBlur(img,5) # 中值滤波 可以处理CV_32FC4 # 双边过滤 只能处理CV_32FC3数据 只取前3个波段处理，处理CV_32FC4报错 dst=cv2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/69ab1180a418f5a40893d3b07e6e56b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-09T09:07:52+08:00" />
<meta property="article:modified_time" content="2017-11-09T09:07:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">opencv&#43;GDAL 遥感影像滤波</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考： <br> 1、<a href="https://docs.opencv.org/3.2.0/" rel="nofollow noopener noreferrer" target="_blank">https://docs.opencv.org/3.2.0/</a></p> 
<hr> 
<h2 id="1python版">1、python版</h2> 
<p>其中m1 参考：<a href="http://blog.csdn.net/wc781708249/article/details/78394933" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/wc781708249/article/details/78394933</a></p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment">#!/usr/bin/env python</span>
<span class="hljs-comment"># -*- coding: UTF-8 -*-</span>

<span class="hljs-string">"""
数据：遥感图像 16bit 4波段 
对应opencv数据格式为CV_16UC4，转成float32对应的数据格式为CV_32FC4

操作：滤波操作
"""</span>

<span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> ndimage
<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">from</span> osgeo <span class="hljs-keyword">import</span> gdal
<span class="hljs-keyword">except</span>:
    <span class="hljs-keyword">import</span> gdal
<span class="hljs-keyword">import</span> gdalnumeric
<span class="hljs-keyword">from</span> osgeo.gdalconst <span class="hljs-keyword">import</span> *
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">import</span> m1
<span class="hljs-keyword">import</span> cv2

start_time=datetime.now()
<span class="hljs-comment"># 为了支持中文路径，请添加下面这句代码</span>
gdal.SetConfigOption(<span class="hljs-string">"GDAL_FILENAME_IS_UTF8"</span>,<span class="hljs-string">"NO"</span>)

gdal.AllRegister() <span class="hljs-comment">#注册驱动</span>

img1_path=<span class="hljs-string">"D:/test.tiff"</span>

img=m1.Multiband2Array(img1_path)

raster_fn=<span class="hljs-string">"D:/test_2.tif"</span>

<span class="hljs-comment"># 各种滤波处理</span>
dst=cv2.blur(img,(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>)) <span class="hljs-comment"># 均值滤波  可以处理CV_32FC4</span>
dst=cv2.GaussianBlur(img,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<span class="hljs-number">0</span>) <span class="hljs-comment"># 高斯滤波 可以处理CV_32FC4</span>
dst=cv2.medianBlur(img,<span class="hljs-number">5</span>) <span class="hljs-comment"># 中值滤波  可以处理CV_32FC4</span>

<span class="hljs-comment"># 双边过滤 只能处理CV_32FC3数据 只取前3个波段处理，处理CV_32FC4报错</span>
dst=cv2.bilateralFilter(img[:,:,:-<span class="hljs-number">1</span>],<span class="hljs-number">9</span>,<span class="hljs-number">75</span>,<span class="hljs-number">75</span>)


src_ds = gdal.Open(img1_path,GA_ReadOnly)
geoTrans = src_ds.GetGeoTransform()
srcPro = src_ds.GetProjection()
src_ds=<span class="hljs-keyword">None</span>

<span class="hljs-comment"># 输出影像</span>
target_ds = gdal.GetDriverByName(<span class="hljs-string">'GTiff'</span>).Create(raster_fn, dst.shape[<span class="hljs-number">1</span>], dst.shape[<span class="hljs-number">0</span>], dst.shape[<span class="hljs-number">2</span>], gdal.GDT_UInt16)
target_ds.SetGeoTransform(geoTrans)  <span class="hljs-comment"># 设置掩膜的地理参考</span>
target_ds.SetProjection(srcPro)  <span class="hljs-comment"># 设置掩膜坐标引用</span>
<span class="hljs-comment"># target_ds.GetRasterBand(1).WriteRaster(0,0,img.shape[1],img.shape[0],img.tobytes())</span>
[target_ds.GetRasterBand(i+<span class="hljs-number">1</span>).WriteArray(dst[:,:,i],<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(dst.shape[<span class="hljs-number">2</span>])]

target_ds.FlushCache()
target_ds=<span class="hljs-keyword">None</span>

end_time=datetime.now()
print((end_time-start_time).total_seconds())</code></pre> 
<hr> 
<h2 id="2c版">2、C++版</h2> 
<p>参考：<a href="http://blog.csdn.net/wc781708249/article/details/78479584" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/wc781708249/article/details/78479584</a></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include "opencv2/core.hpp"</span>
<span class="hljs-preprocessor">#include "opencv2/imgproc.hpp"</span>
<span class="hljs-preprocessor">#include "opencv2/highgui.hpp"</span>
<span class="hljs-preprocessor">#include &lt;gdal.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;gdal_priv.h&gt;  </span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;

<span class="hljs-comment">//创建一个存放影像信息的structure</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>
{
    <span class="hljs-comment">//GDALDataset *poDataset = NULL;</span>
    <span class="hljs-keyword">int</span> Xsize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> Ysize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> nbands = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">double</span> *tmpadfGeoTransform = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">6</span>]; <span class="hljs-comment">//存储地理6参数</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* proj = NULL;<span class="hljs-comment">//存储投影</span>
    GDALDataType iDataType = GDT_Byte;
}MyStruct;

cv::Mat GDAL2Mat(GDALDataset *poDataset, MyStruct &amp;St);
<span class="hljs-keyword">bool</span> Mat2File(cv::Mat img, MyStruct &amp;St, GDALDataset *poDataset);

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-comment">//注册驱动  </span>
    GDALAllRegister();

    <span class="hljs-built_in">string</span>  src_path = <span class="hljs-string">"D:/test.tiff"</span>;
    <span class="hljs-built_in">string</span> dst_path = <span class="hljs-string">"D:/test_2.tif"</span>;

    MyStruct St;
    GDALDataset *srcDataset = (GDALDataset *)GDALOpen(src_path.c_str(), GA_ReadOnly);

    St.Xsize = srcDataset-&gt;GetRasterXSize();
    St.Ysize = srcDataset-&gt;GetRasterYSize();
    St.nbands = srcDataset-&gt;GetRasterCount();
    srcDataset-&gt;GetGeoTransform(St.tmpadfGeoTransform);
    St.proj = srcDataset-&gt;GetProjectionRef();
    <span class="hljs-comment">//获取数据类型</span>
    St.iDataType = srcDataset-&gt;GetRasterBand(<span class="hljs-number">1</span>)-&gt;GetRasterDataType();

    <span class="hljs-comment">//影像转Mat</span>
    Mat img = GDAL2Mat(srcDataset, St);

    <span class="hljs-comment">//判断是否加载成功</span>
    <span class="hljs-keyword">if</span> (!img.data) <span class="hljs-comment">//或者image.empty()</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; src_path &lt;&lt; <span class="hljs-string">"  cannot open!"</span> &lt;&lt; endl;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">//</span>
    <span class="hljs-comment">/*各种滤波处理*/</span>
    Mat dst;<span class="hljs-comment">//输出Mat</span>
    <span class="hljs-comment">//如果将数据转成CV_32FC4，再滤波会出现问题（Python中却不会）</span>
    blur(img, dst, Size(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), Point(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)); <span class="hljs-comment">//均匀滤波</span>
    GaussianBlur(img, dst, Size(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//高斯滤波</span>
    medianBlur(img, dst, <span class="hljs-number">5</span>);                  <span class="hljs-comment">//中值滤波</span>
    <span class="hljs-comment">//bilateralFilter(img, dst, 3, 3 * 2, 3 / 2);//双边滤波 </span>

    <span class="hljs-comment">//注：输入数据的格式CV_16UC4</span>
    <span class="hljs-comment">//Bilateral filtering is only implemented for 8u and 32f images</span>
    img.convertTo(dst, CV_32FC4); <span class="hljs-comment">//转成32F类型</span>
    bilateralFilter(dst, dst, <span class="hljs-number">3</span>, <span class="hljs-number">3</span> * <span class="hljs-number">2</span>, <span class="hljs-number">3</span> / <span class="hljs-number">2</span>);<span class="hljs-comment">//双边滤波 </span>
    <span class="hljs-comment">//src.type() == CV_32FC1 || src.type() == CV_32FC3</span>
    <span class="hljs-comment">//可以取前3个波段使用双边滤波处理</span>

    <span class="hljs-comment">/</span>

    <span class="hljs-comment">//定义输出数据</span>
    GDALDataset *dstDataset;   <span class="hljs-comment">//GDAL数据集</span>
    GDALDriver *poDriver;      <span class="hljs-comment">//驱动，用于创建新的文件</span>
    <span class="hljs-comment">//poDriver = GetGDALDriverManager()-&gt;GetDriverByName("ENVI");</span>
    poDriver = GetGDALDriverManager()-&gt;GetDriverByName(<span class="hljs-string">"GTiff"</span>);

    <span class="hljs-keyword">if</span> (poDriver == NULL)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    dstDataset = poDriver-&gt;Create(dst_path.c_str(), St.Xsize, St.Ysize, St.nbands,
        St.iDataType, NULL);<span class="hljs-comment">//GDT_Float32</span>

    <span class="hljs-comment">//重新设置地理参考和投影系</span>
    dstDataset-&gt;SetGeoTransform(St.tmpadfGeoTransform);
    dstDataset-&gt;SetProjection(St.proj);

    GDALClose((GDALDatasetH)srcDataset);

    <span class="hljs-comment">//保存Mat到影像</span>
    Mat2File(dst, St, dstDataset);

    GDALClose((GDALDatasetH)dstDataset);


    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//GDAL数据转opencv的Mat格式 </span>
cv::Mat GDAL2Mat(GDALDataset *poDataset, MyStruct &amp;St)  <span class="hljs-comment">//const QString fileName</span>
{
    <span class="hljs-comment">//获取数据类型</span>
    <span class="hljs-comment">//GDALDataType iDataType = poDataset-&gt;GetRasterBand(1)-&gt;GetRasterDataType();</span>
    <span class="hljs-comment">//int idepth = GDALGetDataTypeSize((GDALDataType)iDataType);</span>

    <span class="hljs-comment">//将GDAL的数据类型与Mat的数据类型对应起来</span>
    <span class="hljs-keyword">auto</span> MdataType = NULL;
    <span class="hljs-keyword">auto</span> MdataTypes = NULL;

    <span class="hljs-keyword">if</span> (St.iDataType == GDT_Byte)
    {
        MdataType = CV_MAKETYPE(CV_8U, <span class="hljs-number">1</span>);
        MdataTypes = CV_MAKETYPE(CV_8U, St.nbands);
    }
    <span class="hljs-keyword">if</span> (St.iDataType == GDT_UInt16)
    {
        MdataType = CV_MAKETYPE(CV_16U, <span class="hljs-number">1</span>);
        MdataTypes = CV_MAKETYPE(CV_16U, St.nbands);
    }


    <span class="hljs-comment">//QVector &lt;cv::Mat&gt; imgMat;  </span>
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Mat&gt;</span> imgMat;<span class="hljs-comment">// 每个波段</span>
    <span class="hljs-keyword">float</span> *pafScan = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[St.Xsize*St.Ysize];   <span class="hljs-comment">// 存储数据</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; St.nbands; i++)
    {
        GDALRasterBand *pBand = poDataset-&gt;GetRasterBand(i + <span class="hljs-number">1</span>);
        <span class="hljs-comment">//pafScan = new float[tmpCols*tmpRows];</span>
        pBand-&gt;RasterIO(GF_Read, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, St.Xsize, St.Ysize, pafScan,
            St.Xsize, St.Ysize, St.iDataType, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//GDT_Float32</span>
        cv::Mat tmpMat = cv::Mat(St.Ysize, St.Xsize, MdataType, pafScan);<span class="hljs-comment">//CV_32FC1</span>
        imgMat.push_back(tmpMat.clone());
    }
    <span class="hljs-keyword">delete</span>[]pafScan;
    pafScan = NULL;

    cv::Mat img;
    img.create(St.Ysize, St.Xsize, MdataTypes);<span class="hljs-comment">// CV_32FC(St.nbands)</span>
    <span class="hljs-comment">//cv::merge(imgMat.toStdVector(), img);</span>
    cv::merge(imgMat, img);
    <span class="hljs-comment">//释放内存</span>
    imgMat.clear();
    <span class="hljs-comment">//GDALClose((GDALDatasetH)poDataset);</span>
    <span class="hljs-keyword">return</span> img;
}

<span class="hljs-comment">//Mat 数据保存成影像</span>
<span class="hljs-keyword">bool</span> Mat2File(cv::Mat img, MyStruct &amp;St, GDALDataset *poDataset)<span class="hljs-comment">//const QString fileName</span>
{
    <span class="hljs-keyword">if</span> (img.empty())    <span class="hljs-comment">//    判断是否为空</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> nBandCount = St.nbands;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> nImgSizeX = St.Xsize;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> nImgSizeY = St.Ysize;

    <span class="hljs-comment">//    将通道分开</span>
    <span class="hljs-comment">//  imgMat每个通道数据连续</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;cv::Mat&gt;</span> imgMat(nBandCount);
    cv::split(img, imgMat);

    <span class="hljs-comment">//  分波段写入文件</span>
    GDALAllRegister();


    <span class="hljs-comment">//  循环写入文件</span>
    GDALRasterBand *pBand = NULL;
    <span class="hljs-keyword">float</span> *ppafScan = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[nImgSizeX*nImgSizeY];
    cv::Mat tmpMat;<span class="hljs-comment">// = cv::Mat(nImgSizeY,nImgSizeX,CV_32FC1);</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nBandCount; i++)
    {
        pBand = poDataset-&gt;GetRasterBand(i);
        tmpMat = imgMat.at(i - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (tmpMat.isContinuous())
        {
            <span class="hljs-keyword">if</span> (St.iDataType == GDT_Byte)
                memmove(ppafScan, (<span class="hljs-keyword">void</span>*)tmpMat.ptr(<span class="hljs-number">0</span>), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)*nImgSizeX*nImgSizeY);<span class="hljs-comment">//GDT_Byte</span>
            <span class="hljs-keyword">if</span> (St.iDataType == GDT_UInt16)
                memmove(ppafScan, (<span class="hljs-keyword">void</span>*)tmpMat.ptr(<span class="hljs-number">0</span>), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>)*nImgSizeX*nImgSizeY);<span class="hljs-comment">//GDT_Uint16</span>
                                                                                                    <span class="hljs-comment">//memmove(ppafScan, (void*)tmpMat.ptr(0),sizeof(float)*nImgSizeX*nImgSizeY);//GDT_Float32</span>
        }
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

        CPLErr err = pBand-&gt;RasterIO(GF_Write, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, nImgSizeX, nImgSizeY, ppafScan,
            nImgSizeX, nImgSizeY, St.iDataType, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    }
    <span class="hljs-keyword">delete</span>[] ppafScan;
    ppafScan = NULL;
    imgMat.clear();
    <span class="hljs-comment">//GDALClose(poDataset);</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21a8c00a0a5fd7af1484ead325210792/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大数据经典学习路线（学习中）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4249217e9a83ba4b7ad27041b5743a4e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">authentication failure的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>