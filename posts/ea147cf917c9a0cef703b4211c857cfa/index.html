<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2022.3.22 双向链表 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2022.3.22 双向链表" />
<meta property="og:description" content="1. 双向链表
与单链表相比，双向链表有两个指针域，既可以保存右边节点的地址(后继)，也可以保存左边的节点地址(前驱)。
2. 双向链表图
其中：next指针域，保存下一个节点的地址(后继)， prior指针域， 保存上一个节点的地址(前驱)
3. 双向链表可执行函数
注意：头插：① 插入新节点时，一般情况下，需要修改4给我指针域：自身的next和prior；上一个节点的next；下一个节点的prior；如
调整规则：③④②①
第一次：先修改pnewnode自身的next域和prior域
第二次：再修改后一个节点的前驱
第三次：最后修改前一个节点的后继
代码为：
pnewnode-&gt;next=plist-&gt;next;
pnewnode-&gt;prior=plist;
plist-&gt;next-&gt;prior=pnewnode;
plist-&gt;next=pnewnode;
注意：如果是给空的双向链表进行头插，那么上述第三行代码不一定能实现，要特殊处理、
4. 代码
Dlist.h文件
#pragma once //双向链表结构体设计 typedef int ELEM_TYPE; typedef struct Dlist { ELEM_TYPE data; //数据域 保存有效值 struct Dlist* next; //指针域 保存下一个节点的地址(后继) struct Dlist* prior; //指针域 保存上一个节点的地址(前驱) }Dlist,*PDlist; //双向链表可执行函数声明 //初始化 void Init_dlist(struct Dlist* plist); //购买新节点 struct Dlist* Buynewnode(ELEM_TYPE val); //头插 bool Insert_head(PDlist plist, ELEM_TYPE val); //尾插 bool Insert_tail(PDlist plist, ELEM_TYPE val); //按位置插 bool Insert_pos(PDlist plist, int pos, ELEM_TYPE val); //头删 bool Del_head(PDlist plist ); //尾删 bool Del_tail(PDlist plist); //按位置删除 bool Del_pos(PDlist plist, int pos); //按值删 bool Del_val(PDlist plist, ELEM_TYPE val); //查找 （如果值重复，返回第一个值的下标） struct Dlist* Search(PDlist plist, ELEM_TYPE val); //判空 bool IsEmpty(PDlist plist); //判满(链表不用，因为要用malloc) //获取有效长度 int GetLength(PDlist plist); //清空 void Clear(PDlist plist);//链表里面的清空直接调用销毁就可以 //销毁1 void Destroy(PDlist plist); //销毁2 void Destroy2(PDlist plist); //打印 void Show(PDlist plist); Dlist." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ea147cf917c9a0cef703b4211c857cfa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-22T12:19:35+08:00" />
<meta property="article:modified_time" content="2022-03-22T12:19:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2022.3.22 双向链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1. 双向链表</p> 
<p>与单链表相比，双向链表有两个指针域，既可以保存右边节点的地址(后继)，也可以保存左边的节点地址(前驱)。</p> 
<p>2. 双向链表图</p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/12/8c/BJKAcOpd_o.png" width="839"></p> 
<p>其中：next指针域，保存下一个节点的地址(后继)， prior指针域， 保存上一个节点的地址(前驱)</p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/7f/bd/qrIrYt8Z_o.png" width="655"></p> 
<p>3. 双向链表可执行函数</p> 
<p>注意：头插：① 插入新节点时，一般情况下，需要修改4给我指针域：自身的next和prior；上一个节点的next；下一个节点的prior；如</p> 
<p><img alt="" height="452" src="https://images2.imgbox.com/6f/39/k2Y8kaNc_o.png" width="921"></p> 
<p> 调整规则：③④②①</p> 
<p>第一次：先修改pnewnode自身的next域和prior域</p> 
<p>第二次：再修改后一个节点的前驱</p> 
<p>第三次：最后修改前一个节点的后继</p> 
<p>代码为：</p> 
<p>pnewnode-&gt;next=plist-&gt;next;</p> 
<p>pnewnode-&gt;prior=plist;</p> 
<p>plist-&gt;next-&gt;prior=pnewnode;</p> 
<p>plist-&gt;next=pnewnode;</p> 
<p>注意：如果是给空的双向链表进行头插，那么上述第三行代码不一定能实现，要特殊处理、</p> 
<p>4. 代码</p> 
<p>Dlist.h文件</p> 
<pre><code>#pragma once
//双向链表结构体设计
typedef int ELEM_TYPE;
typedef struct Dlist
{
	ELEM_TYPE data;  //数据域   保存有效值
	struct Dlist* next;   //指针域   保存下一个节点的地址(后继)
	struct Dlist* prior;   //指针域   保存上一个节点的地址(前驱)
}Dlist,*PDlist;

//双向链表可执行函数声明
//初始化
void Init_dlist(struct Dlist* plist);

//购买新节点
struct Dlist* Buynewnode(ELEM_TYPE val);

//头插
bool Insert_head(PDlist plist, ELEM_TYPE val);

//尾插
bool Insert_tail(PDlist plist, ELEM_TYPE val);

//按位置插
bool Insert_pos(PDlist plist, int pos, ELEM_TYPE val);

//头删
bool Del_head(PDlist plist );

//尾删
bool Del_tail(PDlist plist);

//按位置删除
bool Del_pos(PDlist plist, int pos);

//按值删
bool Del_val(PDlist plist, ELEM_TYPE val);

//查找   （如果值重复，返回第一个值的下标）
struct Dlist* Search(PDlist plist, ELEM_TYPE val);

//判空
bool IsEmpty(PDlist plist);

//判满(链表不用，因为要用malloc)


//获取有效长度
int GetLength(PDlist plist);

//清空
void Clear(PDlist plist);//链表里面的清空直接调用销毁就可以

//销毁1
void Destroy(PDlist plist);

//销毁2
void Destroy2(PDlist plist);

//打印
void Show(PDlist plist);



</code></pre> 
<p>Dlist.cpp文件</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
#include"Dlist.h"

//初始化
void Init_dlist(struct Dlist* plist)
{
	assert(plist != NULL);
	if (plist == NULL)
	{
		return;
	}
	plist-&gt;next = NULL;
	plist-&gt;prior = NULL;
}

//购买新节点
struct Dlist* Buynewnode(ELEM_TYPE val)
{
	assert(val != NULL);
	struct Dlist* pnewnode = (struct Dlist*)malloc(1 * sizeof(struct Dlist));
	assert(pnewnode != NULL);
	if (pnewnode == NULL)//购买失败
	{
		return NULL;
	}
	pnewnode-&gt;data = val;
	pnewnode-&gt;next = NULL;
	pnewnode-&gt;prior = NULL;

	return pnewnode;
}

//头插
bool Insert_head(PDlist plist, ELEM_TYPE val)
{
	assert(plist != NULL);
	if (plist == NULL)
	{
		return false;
	}
	//1.购买新节点、
	struct Dlist* pnewnode = (struct Dlist*)malloc(1 * sizeof(struct Dlist));
	assert(pnewnode != NULL);
	if (pnewnode == NULL)
	{
		return NULL;
	}
	pnewnode-&gt;data = val;
	pnewnode-&gt;next = NULL;
	pnewnode-&gt;prior = NULL;
	//2.找到合适的插入位置
	// 头插不用找，因为plist就指向插入位置的上一个节点
	//3.插入
	pnewnode-&gt;next = plist-&gt;next;
	pnewnode-&gt;prior = plist;
	if (plist-&gt;next != NULL)
	{
        pnewnode-&gt;next-&gt;prior = pnewnode;//为空的话，pnewnode-&gt;next-&gt;prior 没有，这条代码失败
	}
	plist-&gt;next = pnewnode;
	
	return true;
}

//尾插   尾插的话，下一个节点肯定不存在，所以下一个节点的前驱这根线，不用写
bool Insert_tail(PDlist plist, ELEM_TYPE val)
{
	assert(plist != NULL);
	if (plist == NULL)
	{
		return false;
	}	
	//购买新节点
	struct Dlist* pnewnode = (struct Dlist*)malloc(1 * sizeof(struct Dlist));
	assert(pnewnode != NULL);
	if (pnewnode == NULL)
	{
		return NULL;
	}
	pnewnode-&gt;data = val;
	pnewnode-&gt;next = NULL;
	pnewnode-&gt;prior = NULL;
	//找到合适的插入位置(找一个指针p指向尾节点)
	struct Dlist* p = plist;
	for (p; p-&gt;next != NULL; p = p-&gt;next);
	//此时，for循环结束，p指向尾节点
	
	//插入3421，这块2不用写，因为后面的节点不存在
	pnewnode-&gt;next = p-&gt;next;
	pnewnode-&gt;prior = p;
	p-&gt;next = pnewnode;

	return true;
}

//按位置插
bool Insert_pos(PDlist plist, int pos, ELEM_TYPE val)
{
	assert(plist != NULL);
	if (plist == NULL)
	{
		return false;
	}
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= GetLength(plist));//pos = 0，头插，pos = GetLength(plist)，尾插
	if (pos == 0)
	{
		return Insert_head(plist, val);
	}
	else if (pos == GetLength(plist))
	{
		return Insert_tail(plist, val);
	}
	//购买新节点
	struct Dlist* pnewnode = (struct Dlist*)malloc(1 * sizeof(struct Dlist));
	assert(pnewnode != NULL);
	if (pnewnode == NULL)
	{
		return NULL;
	}
	pnewnode-&gt;data = val;
	pnewnode-&gt;next = NULL;
	pnewnode-&gt;prior = NULL;
	//找到合适插入位置    pos=（），指针p从头结点开始向后跑（）
	struct Dlist* p = plist;
	for (int i = 0; i &lt; pos; i++)
	{
		p = p-&gt;next;
	}
	//插入
	pnewnode-&gt;next = p-&gt;next;
	pnewnode-&gt;prior = p;
	p-&gt;next-&gt;prior = pnewnode;
	p-&gt;next = pnewnode;

	return true;

}

//头删
bool Del_head(PDlist plist)
{
	assert(plist != NULL);
	if (plist == NULL)
	{
		return false;
	}
	//插入不需要判满，但是删除一定记得判空
	if (IsEmpty(plist))
	{
		return false;
	}
	//找个指针p指向待删除节点
	struct Dlist* p = plist -&gt;next;

	//找个指针q指向待删除节点的是上一个节点

	//跨越指向+释放内存
	plist-&gt;next = p-&gt;next;
	if (p-&gt;next != NULL)//代表不仅仅只有一个有效节点
	{
         p-&gt;next-&gt;prior = plist;
	}
	free(p);

	return true;
}

//尾删
bool Del_tail(PDlist plist)
{
	assert(plist != NULL);
	if (plist == NULL)
	{
		return false;
	}
	struct Dlist* q = plist;
	for (q; q-&gt;next-&gt;next != NULL; q = q-&gt;next);
	//此时，for循环结束，q指向倒数第二个节点
	struct Dlist* p = q-&gt;next;

	//跨越指向+内存释放
	q-&gt;next = p-&gt;next;//让上一个节点指向下一个节点
	//让下一个节点指向上一个节点(因为是尾删，所以待删除节点后面没有加点了)
	free(p);//释放待删除节点
	return true;
}

//按位置删除  (一般来说，头和尾得注意，一开始处理掉)
bool Del_pos(PDlist plist, int pos)
{
	assert(plist != NULL);
	if (plist == NULL)
	{
		return false;
	}
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= GetLength(plist));//pos = 0，头删，pos = GetLength(plist)，尾删
	if (pos == 0)
	{
		return Del_head( plist );
	}
	else if (pos == GetLength(plist)-1)
	{
		return Del_tail(plist );
	}
	//先找q再找p
	struct Dlist* q = plist;
	for (int i = 0; i &lt; pos; i++)
	{
		q = q-&gt;next;
	}
	struct Dlist* p = q-&gt;next;


	q-&gt;next = p-&gt;next;
	p-&gt;next-&gt;prior = q;

	free(p);
	return true;
}

//按值删
bool Del_val(PDlist plist, ELEM_TYPE val)
{
	struct Dlist* p = Search(plist, val);
	if (IsEmpty(p))
	{
		return false;
	}
	//再申请一个指针q，指向p的前一个节点
	struct Dlist* q = plist;
	for (q; q-&gt;next != p; q = q-&gt;next);
	//此时，q在p的前面

	//跨越指向+释放内存
	q-&gt;next = p-&gt;next;
	if (p-&gt;next != NULL)
	{
         p-&gt;next-&gt;prior = q;
	}
	
	free(p);
	return true;
}

//查找   （如果值重复，返回第一个值的下标）
struct Dlist* Search(PDlist plist, ELEM_TYPE val)
{
	assert(plist != NULL);
	
	for (struct Dlist* p = plist-&gt;next; p != NULL; p = p-&gt;next)
	{
		if (p-&gt;data == val)
		{
			return p;
		}
	}
	return NULL;
}

//判空
bool IsEmpty(PDlist plist)
{
	return plist-&gt;next == NULL;

}

//判满(链表不用，因为要用malloc)


//获取有效长度
int GetLength(PDlist plist)
{
	assert(plist != NULL);
	if (plist == NULL)
	{
		return false;
	}
	int count = 0;
	for (struct Dlist* p = plist-&gt;next; p != NULL; p = p-&gt;next)
	{
		count ++;
	}
	return count;
}

//清空
void Clear(PDlist plist)//链表里面的清空直接调用销毁就可以
{
	Destroy(plist);
}

//销毁1
void Destroy(PDlist plist)
{
	assert(plist != NULL);
	if (plist == NULL)
	{
		return ;
	}
	while (plist-&gt;next != NULL)
	{
		struct Dlist* p = plist-&gt;next;
		plist-&gt;next = plist;
		free(p);
	}
	plist-&gt;next = plist-&gt;prior = NULL;
}

//销毁2
void Destroy2(PDlist plist)
{
	assert(plist != NULL);
	if (plist == NULL)
	{
		return;
	}
	struct Dlist* p = plist-&gt;next;
	struct Dlist* q = NULL;
	plist-&gt;next = plist-&gt;prior = NULL;
	
	while (p != NULL)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}

}

//打印
void Show(PDlist plist)
{
	assert(plist != NULL);
	if (plist == NULL)
	{
		return ;
	}
	for (struct Dlist* p = plist-&gt;next; p != NULL; p = p-&gt;next)
	{
		printf("%d ",p-&gt;data);
	}
	printf("\n");
}</code></pre> 
<p>主函数运行结果代码：</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include"Dlist.h"


int main()
{
	struct Dlist head;
	Init_dlist(&amp;head);
	for (int i = 0; i &lt; 20; i++)
	{
		Insert_pos(&amp;head, i, i + 1);
	}
	Show(&amp;head);
	printf("length=%d\n", GetLength(&amp;head));

	Insert_head(&amp;head, 100);
	Insert_tail(&amp;head, 200);
	Show(&amp;head);
	printf("length=%d\n", GetLength(&amp;head));

	Del_head(&amp;head);
	Del_tail(&amp;head);
	Show(&amp;head);
	printf("length=%d\n", GetLength(&amp;head));

	Del_pos(&amp;head,4);
	Del_val(&amp;head,14);
	Show(&amp;head);
	printf("length=%d\n", GetLength(&amp;head));

	Destroy(&amp;head);

	return 0;
}

</code></pre> 
<p>运行后如下的结果：</p> 
<p><img alt="" height="172" src="https://images2.imgbox.com/15/7c/arLAAo0I_o.png" width="487"></p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e085e3582e965bb2210cc4024bce1d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Anaconda/pip 更换阿里源，助力 conda create -n 虚拟环境搭建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/873eefa4b4e0ebe4a42b5001d56469af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">docker开放端口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>