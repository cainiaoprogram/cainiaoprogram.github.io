<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LwIP 之四 超时处理（timeouts.c/h）、定时器（ timers.c/h） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LwIP 之四 超时处理（timeouts.c/h）、定时器（ timers.c/h）" />
<meta property="og:description" content="目前，网络上多数文章所使用的 LwIP 版本为1.4.1。最新版本为 2.0.3。从 1.4.1 到 2.0.3（貌似从 2.0.0 开始），LwIP 的源码有了一定的变化，甚至于源码的文件结构也不一样，内部的一些实现源文件也被更新和替换了。
2023.4.25 更新到最新版 2.1.3 简介 在 LwIP 中很多时候都要用到超时处理，超时处理的实现是 TCP/IP 协议栈中一个重要部分。LwIP 为每个与外界网络连接的任务都有设定了 timeout 属性，即等待超时时间。超时处理的相关代码实现在 timeouts.c/h 中，基本内容整理如下：
/* 第一部分：定义LwIP内部使用使用的循环定时器 */ const struct lwip_cyclic_timer lwip_cyclic_timers[]; /* 第二部分：各函数 */ #if LWIP_TIMERS &amp;&amp; !LWIP_TIMERS_CUSTOM /* 使用 LwIP提供的定时器 */ /* 对外提供的第一个函数*/ void tcp_timer_needed(void); lwip_cyclic_timer(void *arg); void sys_timeouts_init(void);	/* 初始化本模块 */ void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg) /* 注册函数 */ void sys_untimeout(sys_timeout_handler handler, void *arg) void sys_check_timeouts(void) void sys_restart_timeouts(void) u32_t sys_timeouts_sleeptime(void) #else /* 用户自定义定时器 */ void tcp_timer_needed(void)	/* 必须由外部实现该函数 */ { } #endif 在 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d7c89d73f96b27468c26df0467c3c5b6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-09T14:18:29+08:00" />
<meta property="article:modified_time" content="2023-06-09T14:18:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LwIP 之四 超时处理（timeouts.c/h）、定时器（ timers.c/h）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>  目前，网络上多数文章所使用的 LwIP 版本为1.4.1。最新版本为 2.0.3。从 1.4.1 到 2.0.3（貌似从 2.0.0 开始），LwIP 的源码有了一定的变化，甚至于源码的文件结构也不一样，内部的一些实现源文件也被更新和替换了。</p> 
<ul><li>2023.4.25 更新到最新版 2.1.3</li></ul> 
<h2><a id="_3"></a>简介</h2> 
<p>  在 LwIP 中很多时候都要用到超时处理，超时处理的实现是 TCP/IP 协议栈中一个重要部分。LwIP 为每个与外界网络连接的任务都有设定了 timeout 属性，即等待超时时间。超时处理的相关代码实现在 <code>timeouts.c/h</code> 中，基本内容整理如下：</p> 
<pre><code class="prism language-c"><span class="token comment">/* 第一部分：定义LwIP内部使用使用的循环定时器 */</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">lwip_cyclic_timer</span> lwip_cyclic_timers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">/* 第二部分：各函数 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_TIMERS <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>LWIP_TIMERS_CUSTOM   </span><span class="token comment">/* 使用 LwIP提供的定时器 */</span></span>
<span class="token comment">/* 对外提供的第一个函数*/</span>
<span class="token keyword">void</span>
<span class="token function">tcp_timer_needed</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">lwip_cyclic_timer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">sys_timeouts_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">/* 初始化本模块 */</span>

<span class="token keyword">void</span>
<span class="token function">sys_timeout</span><span class="token punctuation">(</span><span class="token class-name">u32_t</span> msecs<span class="token punctuation">,</span> sys_timeout_handler handler<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token comment">/* 注册函数 */</span>

<span class="token keyword">void</span>
<span class="token function">sys_untimeout</span><span class="token punctuation">(</span>sys_timeout_handler handler<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>

<span class="token keyword">void</span>
<span class="token function">sys_check_timeouts</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>

<span class="token keyword">void</span>
<span class="token function">sys_restart_timeouts</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>

<span class="token class-name">u32_t</span>
<span class="token function">sys_timeouts_sleeptime</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>      <span class="token comment">/* 用户自定义定时器 */</span></span>
<span class="token keyword">void</span>
<span class="token function">tcp_timer_needed</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>		<span class="token comment">/* 必须由外部实现该函数 */</span>
<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p>  <em><strong>在 2.x 之前版本的 LwIP 中，<code>timeouts.c/h</code> 被称之为 <code>timers.c/h</code>，但是，在最新版的 LwIP 中，为了避免与 FreeRTOS 中的 <code>timers.c/h</code> 重名，从而重命名为了 <code>timeouts.c/h</code>。</strong></em> 重名后在源码实现上也有一定的改进。<br> <img src="https://images2.imgbox.com/c2/f3/Rk3FzqHu_o.png" alt="在这里插入图片描述"><br>   当使用操作系统（配置项 <code>NO_SYS</code> 为 0）时，LwIP 内部的 tcp_ip 线程（<code>static void tcpip_thread(void *arg)</code>）中就会通过 <code>tcpip_timeouts_mbox_fetch</code> 来处理各个定时器（其内部调用 <code>sys_check_timeouts</code>）。<br> <img src="https://images2.imgbox.com/07/6c/7Skmk3GW_o.png" alt="在这里插入图片描述"><br>   <em><strong>当我们不使用操作系统时，必须在主循环中处理自行检测各个定时器的超时。</strong></em> 此外，LwIP 还提供了 <code>NO_SYS_NO_TIMERS</code> 这个配置项，允许在不使用系统时，不启用 timeouts 内部的 TIMER 处理，从而兼容旧版本（使用系统时，则默认启用 timeouts 内部的 TIMER）。在旧版本中，用户自己来需要处理每个 Timer；新版中，则通过提供 <code>sys_check_timeouts</code> 这个封装好的接口。<br> <img src="https://images2.imgbox.com/bc/f7/Ue9I3pv5_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_46"></a>内部定时器</h2> 
<p>  内部定时器即 LwIP 协议栈内部自己使用的一些定时器。在 <code>timeouts.h</code> 中，第一部分便是一个被称为 <code>lwip_cyclic_timer</code> 的结构，如下所示。LwIP 使用该结构存放了其内部使用的循环定时器。在 2.0.0 之前的版本中，是没有该部分的，之前版本把该部分分开在了 LwIP 内部，现在则进行了统一处理。</p> 
<pre><code class="prism language-c"><span class="token comment">/** Function prototype for a stack-internal timer function that has to be
 * called at a defined interval */</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> lwip_cyclic_timer_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/** This struct contains information about a stack-internal timer function
 that has to be called at a defined interval */</span>
<span class="token keyword">struct</span> <span class="token class-name">lwip_cyclic_timer</span> <span class="token punctuation">{<!-- --></span>
  <span class="token class-name">u32_t</span> interval_ms<span class="token punctuation">;</span>
  lwip_cyclic_timer_handler handler<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_DEBUG_TIMERNAMES</span></span>
  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> handler_name<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_DEBUG_TIMERNAMES */</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>  在 <code>timeouts.c</code> 中，有如下全局变量，存放了 LwIP 内部使用的各定时器。这些定时器在 LwIP 初始化时通过函数 <code>void sys_timeouts_init(void)</code> 调用定时器注册函数 <code>void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)</code> 注册进入超时管理链表中。</p> 
<pre><code class="prism language-c"><span class="token comment">/** This array contains all stack-internal cyclic timers. To get the number of
 * timers, use LWIP_ARRAYSIZE() */</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">lwip_cyclic_timer</span> lwip_cyclic_timers<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_TCP</span></span>
  <span class="token comment">/* The TCP timer is a special case: it does not have to run always and
     is triggered to start from TCP using tcp_timer_needed() */</span>
  <span class="token punctuation">{<!-- --></span>TCP_TMR_INTERVAL<span class="token punctuation">,</span> <span class="token function">HANDLER</span><span class="token punctuation">(</span>tcp_tmr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_TCP */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_IPV4</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">IP_REASSEMBLY</span></span>
  <span class="token punctuation">{<!-- --></span>IP_TMR_INTERVAL<span class="token punctuation">,</span> <span class="token function">HANDLER</span><span class="token punctuation">(</span>ip_reass_tmr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* IP_REASSEMBLY */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_ARP</span></span>
  <span class="token punctuation">{<!-- --></span>ARP_TMR_INTERVAL<span class="token punctuation">,</span> <span class="token function">HANDLER</span><span class="token punctuation">(</span>etharp_tmr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_ARP */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_DHCP</span></span>
  <span class="token punctuation">{<!-- --></span>DHCP_COARSE_TIMER_MSECS<span class="token punctuation">,</span> <span class="token function">HANDLER</span><span class="token punctuation">(</span>dhcp_coarse_tmr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{<!-- --></span>DHCP_FINE_TIMER_MSECS<span class="token punctuation">,</span> <span class="token function">HANDLER</span><span class="token punctuation">(</span>dhcp_fine_tmr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_DHCP */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_AUTOIP</span></span>
  <span class="token punctuation">{<!-- --></span>AUTOIP_TMR_INTERVAL<span class="token punctuation">,</span> <span class="token function">HANDLER</span><span class="token punctuation">(</span>autoip_tmr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_AUTOIP */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_IGMP</span></span>
  <span class="token punctuation">{<!-- --></span>IGMP_TMR_INTERVAL<span class="token punctuation">,</span> <span class="token function">HANDLER</span><span class="token punctuation">(</span>igmp_tmr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_IGMP */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_IPV4 */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_DNS</span></span>
  <span class="token punctuation">{<!-- --></span>DNS_TMR_INTERVAL<span class="token punctuation">,</span> <span class="token function">HANDLER</span><span class="token punctuation">(</span>dns_tmr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_DNS */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_IPV6</span></span>
  <span class="token punctuation">{<!-- --></span>ND6_TMR_INTERVAL<span class="token punctuation">,</span> <span class="token function">HANDLER</span><span class="token punctuation">(</span>nd6_tmr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_IPV6_REASS</span></span>
  <span class="token punctuation">{<!-- --></span>IP6_REASS_TMR_INTERVAL<span class="token punctuation">,</span> <span class="token function">HANDLER</span><span class="token punctuation">(</span>ip6_reass_tmr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_IPV6_REASS */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_IPV6_MLD</span></span>
  <span class="token punctuation">{<!-- --></span>MLD6_TMR_INTERVAL<span class="token punctuation">,</span> <span class="token function">HANDLER</span><span class="token punctuation">(</span>mld6_tmr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_IPV6_MLD */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_IPV6 */</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>  在 LwIP 初始化过程中，就会调用 <code>void sys_timeouts_init(void);</code> 函数遍历整个 <code>lwip_cyclic_timers</code> 数组，将内部使用的各个延时定时器注册进入链表中，调用过程如下图所示：<br> <img src="https://images2.imgbox.com/e9/19/OtRB0KOH_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_108"></a>超时处理链表</h2> 
<p>  超时定时器是按链表的形式进行组织的，<em><strong>且按时间长短进行排序，时间最短的永远在最前面</strong></em>。使用全局变量 <code>static struct sys_timeo *next_timeout;</code> 指示超时链表，该指针即为超时链表的头。超时链表需要通过函数 <code>void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)</code>进行注册。链表的节点使用如下结构体表示：</p> 
<pre><code class="prism language-c"><span class="token comment">/** Function prototype for a timeout callback function. Register such a function
 * using sys_timeout().
 *
 * @param arg Additional argument to pass to the function - set up by sys_timeout()
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> sys_timeout_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">sys_timeo</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">struct</span> <span class="token class-name">sys_timeo</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
  <span class="token class-name">u32_t</span> time<span class="token punctuation">;</span>
  sys_timeout_handler h<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_DEBUG_TIMERNAMES</span></span>
  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> handler_name<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_DEBUG_TIMERNAMES */</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_129"></a>超时定时器注册</h3> 
<p>  下面详细分析一下 <code>void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)</code> 是如何对超时函数进行注册的。源码很简单，直接注释：</p> 
<pre><code class="prism language-c">  <span class="token class-name">u32_t</span> now<span class="token punctuation">,</span> diff<span class="token punctuation">;</span>
	<span class="token comment">/* 1. 申请节点内存 */</span>
  timeout <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sys_timeo</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">memp_malloc</span><span class="token punctuation">(</span>MEMP_SYS_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">LWIP_ASSERT</span><span class="token punctuation">(</span><span class="token string">"sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty"</span><span class="token punctuation">,</span> timeout <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">/* 2.计算差值，至于为什么要额外搞个差值，暂时还没搞明白！！！ */</span>
  now <span class="token operator">=</span> <span class="token function">sys_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>next_timeout <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    diff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    timeouts_last_time <span class="token operator">=</span> now<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    diff <span class="token operator">=</span> now <span class="token operator">-</span> timeouts_last_time<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">/* 3. 节点各变量赋值 */</span>
  timeout<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  timeout<span class="token operator">-&gt;</span>h <span class="token operator">=</span> handler<span class="token punctuation">;</span>
  timeout<span class="token operator">-&gt;</span>arg <span class="token operator">=</span> arg<span class="token punctuation">;</span>
  timeout<span class="token operator">-&gt;</span>time <span class="token operator">=</span> msecs <span class="token operator">+</span> diff<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_DEBUG_TIMERNAMES</span></span>
  timeout<span class="token operator">-&gt;</span>handler_name <span class="token operator">=</span> handler_name<span class="token punctuation">;</span>
  <span class="token function">LWIP_DEBUGF</span><span class="token punctuation">(</span>TIMERS_DEBUG<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"sys_timeout: %p msecs=%"</span>U32_F<span class="token string">" handler=%s arg=%p\n"</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>timeout<span class="token punctuation">,</span> msecs<span class="token punctuation">,</span> handler_name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_DEBUG_TIMERNAMES */</span></span>
<span class="token comment">/* 4. 如果创建的是第一个定时器，则不用特殊处理，next_timeout是一个全局指针，指向定时器链表中第一个定时器 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>next_timeout <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    next_timeout <span class="token operator">=</span> timeout<span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token comment">/* 4. 从第二个定时器开始就要添加到链表中，添加原则是定时最短的定时器始终在前面。如果新添加的定时器时长小于当前链首定时器，则新添加的定时器成为链首，旧的链首定时器的定时值要减去新链首定时器定时值，
如果新添加的定时器大于等于当前链首定时器的时长，则要在整个链表里逐个比较，
最终插入到合适位置，当然其后定时器的定时值也要进行调整 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>next_timeout<span class="token operator">-&gt;</span>time <span class="token operator">&gt;</span> msecs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    next_timeout<span class="token operator">-&gt;</span>time <span class="token operator">-=</span> msecs<span class="token punctuation">;</span>
    timeout<span class="token operator">-&gt;</span>next <span class="token operator">=</span> next_timeout<span class="token punctuation">;</span>
    next_timeout <span class="token operator">=</span> timeout<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> next_timeout<span class="token punctuation">;</span> t <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      timeout<span class="token operator">-&gt;</span>time <span class="token operator">-=</span> t<span class="token operator">-&gt;</span>time<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> t<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>time <span class="token operator">&gt;</span> timeout<span class="token operator">-&gt;</span>time<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          t<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>time <span class="token operator">-=</span> timeout<span class="token operator">-&gt;</span>time<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token operator">-&gt;</span>time <span class="token operator">&gt;</span> msecs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">/* If this is the case, 'timeouts_last_time' and 'now' differs too much.
             This can be due to sys_check_timeouts() not being called at the right
             times, but also when stopping in a breakpoint. Anyway, let's assume
             this is not wanted, so add the first timer's time instead of 'diff' */</span>
          timeout<span class="token operator">-&gt;</span>time <span class="token operator">=</span> msecs <span class="token operator">+</span> next_timeout<span class="token operator">-&gt;</span>time<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        timeout<span class="token operator">-&gt;</span>next <span class="token operator">=</span> t<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        t<span class="token operator">-&gt;</span>next <span class="token operator">=</span> timeout<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<p>下面举例说明（由于在处理链表时，仅 time 有用，因此下面的的其他参数用字母代替）：</p> 
<ol><li>插入第一个节点，参数为 <code>time = 20, 其他两个参数用 A、B 表示</code><br> <img src="https://images2.imgbox.com/ee/03/dgjOW1Ty_o.png" alt="1"></li><li>插入第二个节点，参数为 <code>time = 15, 其他两个参数用 C、D 表示</code>，延时时间比之前的短<br> <img src="https://images2.imgbox.com/fc/e9/D5xgQgaL_o.png" alt="2"></li><li>插入第三个节点，参数为 <code>time = 14, 其他两个参数用 E、F 表示</code>，延时时间比之前的短。<br> <img src="https://images2.imgbox.com/1f/54/VMTuJ7lj_o.png" alt="3"></li><li>插入第四个节点，参数为 <code>time = 30, 其他两个参数用 G、H 表示</code>，延时时间比之前的长。<br> <img src="https://images2.imgbox.com/e4/29/qw4oDHl4_o.png" alt="4"></li><li>插入第五个节点，参数为 <code>time = 23, 其他两个参数用 I、J 表示</code>，延时时间比之前的长。<br> <img src="https://images2.imgbox.com/11/ba/cZYwXVPx_o.png" alt="5"><br>   从上面的举例可以看出，如果新添加的定时器比头结点（<code>next_timeout</code>指向的第一个节点）的时间短，则直接往链表头插入，同时对头结点（<code>next_timeout</code> 指向的第一个节点）的时间进行调整，后续节点的时间不动。</li></ol> 
<p>  如果新添加的定时器比头结点（<code>next_timeout</code>指向的第一个节点）的时间长，则需要遍历链表，查找合适位置（比其短的定时器之后，比其长的定时器之前）插入，其后定时器的定时值也要进行调整，其前的定时器无需调整。</p> 
<h3><a id="_204"></a>超时定时器删除</h3> 
<p>  从超时链表中删除指定的定时器时通过函数 <code>void sys_untimeout(sys_timeout_handler handler, void *arg)</code> 来完成的。源码很简单，直接注释：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span>
<span class="token function">sys_untimeout</span><span class="token punctuation">(</span>sys_timeout_handler handler<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">struct</span> <span class="token class-name">sys_timeo</span> <span class="token operator">*</span><span class="token class-name">prev_t</span><span class="token punctuation">,</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>
	<span class="token comment">/* 超时链表为空的判断 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>next_timeout <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">/* 从链表头开始遍历这个链表 */</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> next_timeout<span class="token punctuation">,</span> <span class="token class-name">prev_t</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> t <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token class-name">prev_t</span> <span class="token operator">=</span> t<span class="token punctuation">,</span> t <span class="token operator">=</span> t<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>h <span class="token operator">==</span> handler<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>arg <span class="token operator">==</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>   <span class="token comment">/* 条件匹配 */</span>
      <span class="token comment">/* We have a match */</span>
      <span class="token comment">/* Unlink from previous in list */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">prev_t</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        next_timeout <span class="token operator">=</span> t<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">prev_t</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> t<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">/* If not the last one, add time of this one back to next */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        t<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>time <span class="token operator">+=</span> t<span class="token operator">-&gt;</span>time<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token function">memp_free</span><span class="token punctuation">(</span>MEMP_SYS_TIMEOUT<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/* 释放节点资源 */</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_237"></a>超时定时器检查</h2> 
<p>  不管是否有 os 支持，超时定时器都可以使用。LwIP 中如下两个函数可以实现对超时的处理：</p> 
<ul><li><code>void sys_check_timeouts(void)</code>： 裸机应用程序在外部周期性调用该函数，每次进来检查定时器链表上定时最短的定时器是否到期，如果没有到期，直接退出该函数，否则，执行该定时器回调函数，并从链表上删除该定时器，然后继续检查下一个定时器，直到没有一个定时器到期退出。</li><li><code>void sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)</code>： 这个函数可在 os 线程中循环调用，主要是等待 mbox 消息，并可阻塞，如果等待 mbox 时超时，则会同时执行超时事件处理，即调用定时器回调函数，如果一直没有 mbox 消息，则会永久性地循环将所有超时定时器检查一遍（内部调用了 <code>void sys_check_timeouts(void)</code>），一举两得。<br>   LwIP 中的 tcpip 线程就是靠这种方法，即处理了上层及底层的 mbox 消息，同时处理了所有需要定时处理的事件。</li></ul> 
<p>在检查超时定时器链表时，对于已经超时的则进行删除，下面以添加时的例子说明一下检查函数：</p> 
<ul><li>第一次检查：<br> <img src="https://images2.imgbox.com/11/c7/3EfoM8WM_o.png" alt="check1"></li><li>第二次检查：<br> <img src="https://images2.imgbox.com/62/78/mU6alvJf_o.png" alt="check2"></li><li>第三次检查：<br> <img src="https://images2.imgbox.com/06/07/Dd3xrtCI_o.png" alt="check3"></li></ul> 
<h2><a id="sys_now_252"></a><code>sys_now</code></h2> 
<p>  无论是否有操作系统支持，用户都需要在移植层文件中实现 <code>sys_now</code> 这个接口，不实现这个函数意味着你不能使用某些模块（例如，TCP 时间戳，<code>NO_SYS == 1</code> 的内部超时）。这个可选函数以<strong>毫秒为单位</strong>返回当前时间（通常就是个1 毫秒的 Tick 计数，且不关心循环溢出，这只用于时间差异）。</p> 
<pre><code class="prism language-c"><span class="token class-name">u32_t</span> <span class="token function">sys_now</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> your_sys_tick<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_261"></a>参考</h2> 
<ol><li>官方文档</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/40d17e3946001db6289f4815addd3aa5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows python TA-Lib 库 源码安装 Python安装talib库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53f1395d61e7c9119bca0e2a1ff053a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">06_ MySQL优化实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>