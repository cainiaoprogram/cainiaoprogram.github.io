<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>连接池 Druid （一） - 初始化过程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="连接池 Druid （一） - 初始化过程" />
<meta property="og:description" content="HikariPool之后，今天研究另一主流连接池Druid。
#### 关于数据库连接池的基本认知
先对数据库连接池的基本工作原理做个了解，不管是HikariPool、还是druid，所有的数据库连接池应该都是按照这个基本原理工作和实现的，带着这个思路去学习数据库连接池，避免盲人摸象。
数据库连接池一定会包含以下基本逻辑：
1. 创建连接并池化：初始化的时候创建、或者是在应用获取连接的过程中创建，连接创建好之后放在连接池（内存中的容器，比如List）中保存。
2. 获取数据库连接：接管了获取数据库连接的方法，从连接池中获取、而不是创建连接。
3. 关闭数据库连接：接管了关闭数据库连接的方法，将连接归还到连接池、而不是真正的关闭数据库连接。
4. 连接池维护：连接池容量、连接超时清理等工作。
带着这个思路研究HikariPool的源码，会有事半功倍的功效。
#### 认识Druid的结构
包括以下几个部分：
1. DruidConnectionHolder
2. Connections
3. evictConnections
4. keepAliveConnections
5. destroyConnectionThread/destroySchedulerFuture
6. createConnectionThread/createSchedulerFuture
#### DruidConnectionHolder
HikariPool通过poolEntry持有数据库连接，Druid通过DruidConnectionHolder持有数据库连接。
DruidConnectionHolder持有物理数据库连接Connectin对象，以及该连接的相关属性，比如connectTimeMillis、lastActiveTimeMillis、lastExecTimeMillis，以及underlyingReadOnly、underlyingAutoCommit、underlyingTransactionIsolation等等。连接池可以根据这些属性以及相关参数执行相应的houseKeep。
#### Connections
Connections是DruidConnectionHolder组成的数组，是Druid连接池中唯一存储可用连接的地方，看起来会比HikariPool简单许多（HikariPool有三个存储连接的地方），但是这可能也是Druid在性能上稍逊于HikariPool的原因之一。
#### evictConnections
存储需要被回收的连接的数组，在连接池进行清理的时候用来存储需要被关闭的连接。
#### keepAliveConnections
存储保持活动的连接的数组。
#### createConnectionThread/createSchedulerFuture
Druid根据配置，可以通过createConnectionThread线程、或者createSchedulerFuture线程任务创建数据库连接并加入连接池。
Druid也许并没有默认的createSchedulerFuture的实现，如果要启用createSchedulerFuture，需要配置createSchedulerFuture的实现类。
createConnectionThread是Druid默认的创建连接的线程，负责获取物理连接、组装物理连接为DruidConnectionHolder并加入到connections数组中。
#### destroyConnectionThread/destroySchedulerFuture
与创建连接的方式类似，Druid提供两种不同的方式销毁（或者关闭）过期的数据库连接。默认实现是destroyConnectionThread。
***好了，Druid的基础结构了解完了，我们采用和HikariPool完全一样的分析套路，接下来要进入源码分析了，主要包括：***
1. Druid连接池的初始化
2. 获取数据库连接 - getConnection方法
3. 关闭数据库连接 - close方法
#### Druid的初始化
Druid的初始化过程貌似和HikariPool稍有不同，因为HikariPool默认的在获取连接之前的HikariPool实例化过程中就完成了连接池的初始化。
所谓完成连接池的初始化，指的是按照参数的设定，完成了数据库连接的创建和池化，也就是说连接池已经准备好了，应用在通过getConnecton方法获取连接的时候，直接从连接池中borrow就可以了。
Druid貌似不这样。我们看一下DruidDataSource的实例化方法：
```
public DruidDataSource(){" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/72864748d85b59fc98b19cca299baff1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-22T22:29:48+08:00" />
<meta property="article:modified_time" content="2023-04-22T22:29:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">连接池 Druid （一） - 初始化过程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>HikariPool之后，今天研究另一主流连接池Druid。</p> 
<p>#### 关于数据库连接池的基本认知<br> 先对数据库连接池的基本工作原理做个了解，不管是HikariPool、还是druid，所有的数据库连接池应该都是按照这个基本原理工作和实现的，带着这个思路去学习数据库连接池，避免盲人摸象。</p> 
<p>数据库连接池一定会包含以下基本逻辑：<br> 1. 创建连接并池化：初始化的时候创建、或者是在应用获取连接的过程中创建，连接创建好之后放在连接池（内存中的容器，比如List）中保存。<br> 2. 获取数据库连接：接管了获取数据库连接的方法，从连接池中获取、而不是创建连接。<br> 3. 关闭数据库连接：接管了关闭数据库连接的方法，将连接归还到连接池、而不是真正的关闭数据库连接。<br> 4. 连接池维护：连接池容量、连接超时清理等工作。</p> 
<p>带着这个思路研究HikariPool的源码，会有事半功倍的功效。</p> 
<p><br> #### 认识Druid的结构<br> 包括以下几个部分：<br> 1. DruidConnectionHolder<br> 2. Connections<br> 3. evictConnections<br> 4. keepAliveConnections<br> 5. destroyConnectionThread/destroySchedulerFuture<br> 6. createConnectionThread/createSchedulerFuture</p> 
<p><br> #### DruidConnectionHolder<br> HikariPool通过poolEntry持有数据库连接，Druid通过DruidConnectionHolder持有数据库连接。</p> 
<p>DruidConnectionHolder持有物理数据库连接Connectin对象，以及该连接的相关属性，比如connectTimeMillis、lastActiveTimeMillis、lastExecTimeMillis，以及underlyingReadOnly、underlyingAutoCommit、underlyingTransactionIsolation等等。连接池可以根据这些属性以及相关参数执行相应的houseKeep。</p> 
<p><br> #### Connections<br> Connections是DruidConnectionHolder组成的数组，是Druid连接池中唯一存储可用连接的地方，看起来会比HikariPool简单许多（HikariPool有三个存储连接的地方），但是这可能也是Druid在性能上稍逊于HikariPool的原因之一。</p> 
<p>#### evictConnections<br> 存储需要被回收的连接的数组，在连接池进行清理的时候用来存储需要被关闭的连接。<br> #### keepAliveConnections<br> 存储保持活动的连接的数组。</p> 
<p>#### createConnectionThread/createSchedulerFuture</p> 
<p>Druid根据配置，可以通过createConnectionThread线程、或者createSchedulerFuture线程任务创建数据库连接并加入连接池。</p> 
<p>Druid也许并没有默认的createSchedulerFuture的实现，如果要启用createSchedulerFuture，需要配置createSchedulerFuture的实现类。</p> 
<p>createConnectionThread是Druid默认的创建连接的线程，负责获取物理连接、组装物理连接为DruidConnectionHolder并加入到connections数组中。</p> 
<p>#### destroyConnectionThread/destroySchedulerFuture</p> 
<p>与创建连接的方式类似，Druid提供两种不同的方式销毁（或者关闭）过期的数据库连接。默认实现是destroyConnectionThread。</p> 
<p><br> ***好了，Druid的基础结构了解完了，我们采用和HikariPool完全一样的分析套路，接下来要进入源码分析了，主要包括：***<br> 1. Druid连接池的初始化<br> 2. 获取数据库连接 - getConnection方法<br> 3. 关闭数据库连接 - close方法</p> 
<p>#### Druid的初始化<br> Druid的初始化过程貌似和HikariPool稍有不同，因为HikariPool默认的在获取连接之前的HikariPool实例化过程中就完成了连接池的初始化。</p> 
<p>所谓完成连接池的初始化，指的是按照参数的设定，完成了数据库连接的创建和池化，也就是说连接池已经准备好了，应用在通过getConnecton方法获取连接的时候，直接从连接池中borrow就可以了。</p> 
<p>Druid貌似不这样。我们看一下DruidDataSource的实例化方法：<br> ```<br> public DruidDataSource(){<!-- --><br>         this(false);<br>     }</p> 
<p>    public DruidDataSource(boolean fairLock){<!-- --><br>         super(fairLock);</p> 
<p>        configFromPropety(System.getProperties());<br>     }<br> ```</p> 
<p>super指的是DruidAbstractDataSource，他的构造方法：<br> ```<br> public DruidAbstractDataSource(boolean lockFair){<!-- --><br>         lock = new ReentrantLock(lockFair);</p> 
<p>        notEmpty = lock.newCondition();<br>         empty = lock.newCondition();<br>     }<br> ```<br> 只初始化了ReentrantLock，以及他的两个Condition：empty和notEmpty。</p> 
<p>而configFromPropety只是负责把参数从配置文件中读入，不做其他的事情。</p> 
<p>所以，连接池的初始化过程没有放在DruidDataSource的创建过程中。</p> 
<p>既然构造方法中没有完成连接池的初始化，我们自然而然的就想到去看看getConnection方法，不做初始化、怎么能获取到数据库连接？</p> 
<p>果然，getConnectin方法的第一行代码就是：调用init()方法。</p> 
<p>init的方法很长，不过有很多代码都是检查参数合理性的，这部分代码我们直接跳过：<br> ```<br>             ...忽略n多行代码<br>             connections = new DruidConnectionHolder[maxActive];<br>             evictConnections = new DruidConnectionHolder[maxActive];<br>             keepAliveConnections = new DruidConnectionHolder[maxActive];<br> ```</p> 
<p>创建了我们前面说过的存储数据库连接的connections（其实就是池），以及另外两个辅助数组evictConnections和keepAliveConnections，连接池的大小初始化为maxActive。</p> 
<p>接下来：<br> ```<br>             if (createScheduler != null &amp;&amp; asyncInit) {<!-- --><br>                 for (int i = 0; i &lt; initialSize; ++i) {<!-- --><br>                     submitCreateTask(true);<br>                 }<br>             } else if (!asyncInit) {<!-- --><br>                 // init connections<br>                 while (poolingCount &lt; initialSize) {<!-- --><br>                     try {<!-- --><br>                         PhysicalConnectionInfo pyConnectInfo = createPhysicalConnection();<br>                         DruidConnectionHolder holder = new DruidConnectionHolder(this, pyConnectInfo);<br>                         connections[poolingCount++] = holder;<br>                     } catch (SQLException ex) {<!-- --><br>                         LOG.error("init datasource error, url: " + this.getUrl(), ex);<br>                         if (initExceptionThrow) {<!-- --><br>                             connectError = ex;<br>                             break;<br>                         } else {<!-- --><br>                             Thread.sleep(3000);<br>                         }<br>                     }<br>                 }</p> 
<p>                if (poolingCount &gt; 0) {<!-- --><br>                     poolingPeak = poolingCount;<br>                     poolingPeakTime = System.currentTimeMillis();<br>                 }<br>             }<br> ```<br> 检查createScheduler不空、并且参数设置为asyncInit（异步初始化）的话，则提交initialSize个连接创建任务。***我们说过createScheduler并非Druid的默认实现，所以我们暂时不管这部分代码。***</p> 
<p>下面的代码逻辑是：如果不是异步初始化的话，那就是要同步初始化，也就是当前线程要负责完成连接池的初始化，则循环创建initialSize个物理连接、封装为DruidConnectionHolder后直接加入到connections中。</p> 
<p>***这个过程就相当于完成了数据库连接池的初始化，但是建议设置asyncInit参数为true：异步初始化。因为如果同步初始化、并且initialSize设置比较大的话，应用的首个getConnection方法肯定会耗时比较长，用户体验不好。***</p> 
<p>继续看代码，如果asyncInit设置为true，异步初始化的话：<br> ```<br>             createAndLogThread();<br>             createAndStartCreatorThread();<br>             createAndStartDestroyThread();</p> 
<p>```<br> 从方法名上看，应该是启动了3个线程，分别是createAndLogThread线程、负责线程创建连接的线程和负责销毁（关闭）连接的线程。</p> 
<p>createAndLogThread线程负责定期收集Druid连接池的状态并通过log打印出来，是Druid统计分析的一部分。</p> 
<p>createAndStartCreatorThread是启动连接创建线程，异步初始化的情况下，连接池就是通过createAndStartCreatorThread线程创建的。</p> 
<p>createAndStartDestroyThread是启动连接销毁的线程，作用类似于HikariPool的houseKeep线程。</p> 
<p>createAndStartCreatorThread方法以及连接创建线程、reateAndStartDestroyThread方法以及连接销毁线程的源码我们先放放，稍后分析。</p> 
<p>我们先一鼓作气完成init()方法源码的剩余部分：<br> ```<br>             initedLatch.await();<br>             init = true;</p> 
<p>            initedTime = new Date();<br>             registerMbean();</p> 
<p>            if (connectError != null &amp;&amp; poolingCount == 0) {<!-- --><br>                 throw connectError;<br>             }<br> ```<br> initedLatch是数量=2的CountDownLatch，在DruidDataSource类成员变量初始化的时候定义好的，这里initedLatch.await();的意思是等待连接创建线程和连接销毁线程完成启动。</p> 
<p>之后，打标签init=true，表明初始化已完成，进行异常处理、锁释放等扫尾工作。</p> 
<p>***初始化完成！***</p> 
<p>#### createAndStartCreatorThread<br> 创建并启动“创建连接线程”：<br> ```<br>    protected void createAndStartCreatorThread() {<!-- --><br>         if (createScheduler == null) {<!-- --><br>             String threadName = "Druid-ConnectionPool-Create-" + System.identityHashCode(this);<br>             createConnectionThread = new CreateConnectionThread(threadName);<br>             createConnectionThread.start();<br>             return;<br>         }</p> 
<p>        initedLatch.countDown();<br>     }<br> ```<br> 代码非常简单，就是创建并启动createConnectionThread。createConnectionThread线程负责物理连接的创建、以及连接的池化。</p> 
<p>#### createConnectionThread#run<br> 连接的创建及池化是在createConnectionThread线程的run方法中完成的。<br> ```<br>        public void run() {<!-- --><br>             initedLatch.countDown();</p> 
<p>            long lastDiscardCount = 0;<br>             int errorCount = 0;<br>             for (;;) {<!-- --><br>                 // addLast<br>                 try {<!-- --><br>                     lock.lockInterruptibly();<br>                 } catch (InterruptedException e2) {<!-- --><br>                     break;<br>                 }</p> 
<p>               long discardCount = DruidDataSource.this.discardCount;<br>                 boolean discardChanged = discardCount - lastDiscardCount &gt; 0;<br>                 lastDiscardCount = discardCount;</p> 
<p>                try {<!-- --><br>                     boolean emptyWait = true;</p> 
<p>                    if (createError != null<br>                             &amp;&amp; poolingCount == 0<br>                             &amp;&amp; !discardChanged) {<!-- --><br>                         emptyWait = false;<br>                     }</p> 
<p>                    if (emptyWait<br>                             &amp;&amp; asyncInit &amp;&amp; createCount &lt; initialSize) {<!-- --><br>                         emptyWait = false;<br>                     }<br> ```<br> 线程启动之后会不断检测是否需要创建连接，在run方法的无条件for循环中完成。</p> 
<p>首先获得锁。</p> 
<p>discardChanged变量表示在每次循环检测过程中，被discardCount的连接数是否有增长。</p> 
<p>然后定义了一个emptyWait变量，用来表示是否需要暂缓创建连接、直到等待获取连接的线程唤醒之后才创建。</p> 
<p>对emptyWait的处理逻辑是：如果创建连接发生了错误并且当前连接池空、并且没有发生discardChanged，则不等待。或者，如果是异步初始化并且初始化的连接池数量尚未满足initialSize的要求，则不等待。</p> 
<p>然后：<br> ```<br>                   if (emptyWait) {<!-- --><br>                         // 必须存在线程等待，才创建连接<br>                         if (poolingCount &gt;= notEmptyWaitThreadCount //<br>                                 &amp;&amp; (!(keepAlive &amp;&amp; activeCount + poolingCount &lt; minIdle))<br>                                 &amp;&amp; !isFailContinuous()<br>                         ) {<!-- --><br>                             empty.await();<br>                         }</p> 
<p>                        // 防止创建超过maxActive数量的连接<br>                         if (activeCount + poolingCount &gt;= maxActive) {<!-- --><br>                             empty.await();<br>                             continue;<br>                         }<br>                     }</p> 
<p>                } catch (InterruptedException e) {<!-- --><br>                     lastCreateError = e;<br>                     lastErrorTimeMillis = System.currentTimeMillis();</p> 
<p>                    if ((!closing) &amp;&amp; (!closed)) {<!-- --><br>                         LOG.error("create connection Thread Interrupted, url: " + jdbcUrl, e);<br>                     }<br>                     break;<br>                 } finally {<!-- --><br>                     lock.unlock();<br>                 }<br> ```</p> 
<p>这段代码是需要等待的情况，判断当前线程池数量满足等待条件（连接池数量大于notEmptyWaitThreadCount数量，activeCount + poolingCount数量大于等于minIdle或者是keepAlive）。或者，activeCount + poolingCount已经大于等于maxActive了，则调用empty.await();也就是暂时不再创建连接了，等待获取连接的线程唤醒之后再创建。***当然，等待是需要释放锁资源的。***</p> 
<p>接下来是不等待的代码：<br> ```<br>                PhysicalConnectionInfo connection = null;</p> 
<p>                try {<!-- --><br>                     connection = createPhysicalConnection();<br>                 } catch (SQLException e) {<!-- --><br>          //下面是一堆创建连接失败的异常处理，忽略<br> ```<br> 创建数据库物理连接。之后：<br> ```</p> 
<p>                if (connection == null) {<!-- --><br>                     continue;<br>                 }</p> 
<p>                boolean result = put(connection);<br>                 if (!result) {<!-- --><br>                     JdbcUtils.close(connection.getPhysicalConnection());<br>                     LOG.info("put physical connection to pool failed.");<br>                 }</p> 
<p>                errorCount = 0; // reset errorCount</p> 
<p>                if (closing || closed) {<!-- --><br>                     break;<br>                 }<br>             }<br>         }<br>     }<br> ```<br> 如果创建连接过程中发生异常，connection==null，则continue，继续创建。</p> 
<p>否则，调用put方法，将新创建的连接加入连接池。当然，如果加入失败的话则关闭刚创建好的连接，以免资源浪费。</p> 
<p>接下来看一下连接放入connections的put方法。<br> #### put方法<br> ```<br>    protected boolean put(PhysicalConnectionInfo physicalConnectionInfo) {<!-- --><br>         DruidConnectionHolder holder = null;<br>         try {<!-- --><br>             holder = new DruidConnectionHolder(DruidDataSource.this, physicalConnectionInfo);<br>         } catch (SQLException ex) {<!-- --><br>             lock.lock();<br>             try {<!-- --><br>                 if (createScheduler != null) {<!-- --><br>                     clearCreateTask(physicalConnectionInfo.createTaskId);<br>                 }<br>             } finally {<!-- --><br>                 lock.unlock();<br>             }<br>             LOG.error("create connection holder error", ex);<br>             return false;<br>         }</p> 
<p>        return put(holder, physicalConnectionInfo.createTaskId);<br>     }<br> ```<br> 将connection封装为DruidConnectionHolder，之后调用put：<br> ```<br> private boolean put(DruidConnectionHolder holder, long createTaskId) {<!-- --><br>         lock.lock();<br>         try {<!-- --><br>             if (this.closing || this.closed) {<!-- --><br>                 return false;<br>             }</p> 
<p>            if (poolingCount &gt;= maxActive) {<!-- --><br>                 if (createScheduler != null) {<!-- --><br>                     clearCreateTask(createTaskId);<br>                 }<br>                 return false;<br>             }<br>             connections[poolingCount] = holder;<br>             incrementPoolingCount();</p> 
<p>            if (poolingCount &gt; poolingPeak) {<!-- --><br>                 poolingPeak = poolingCount;<br>                 poolingPeakTime = System.currentTimeMillis();<br>             }</p> 
<p>            notEmpty.signal();<br>             notEmptySignalCount++;</p> 
<p>            if (createScheduler != null) {<!-- --><br>                 clearCreateTask(createTaskId);</p> 
<p>                if (poolingCount + createTaskCount &lt; notEmptyWaitThreadCount //<br>                     &amp;&amp; activeCount + poolingCount + createTaskCount &lt; maxActive) {<!-- --><br>                     emptySignal();<br>                 }<br>             }<br>         } finally {<!-- --><br>             lock.unlock();<br>         }<br>         return true;<br>     }<br> ```<br> 首先获取锁资源。</p> 
<p>之后判断如果创建的连接数大于最大活动连接数poolingCount &gt;= maxActive的话，则不放入连接池直接返回。</p> 
<p>接下来，连接放入连接池connections中，poolingCount加1。</p> 
<p>接下来notEmpty.signal();通知等待获取连接的线程。</p> 
<p>之后释放锁资源，连接加入连接池完成！</p> 
<p>#### createAndStartDestroyThread方法<br> 创建并启动DestroyThread，直接看destroyConnectionThread的run方法：<br> ```<br>         public void run() {<!-- --><br>             initedLatch.countDown();</p> 
<p>            for (;;) {<!-- --><br>                 // 从前面开始删除<br>                 try {<!-- --><br>                     if (closed || closing) {<!-- --><br>                         break;<br>                     }</p> 
<p>                    if (timeBetweenEvictionRunsMillis &gt; 0) {<!-- --><br>                         Thread.sleep(timeBetweenEvictionRunsMillis);<br>                     } else {<!-- --><br>                         Thread.sleep(1000); //<br>                     }</p> 
<p>                    if (Thread.interrupted()) {<!-- --><br>                         break;<br>                     }</p> 
<p>                    destroyTask.run();<br>                 } catch (InterruptedException e) {<!-- --><br>                     break;<br>                 }<br>             }<br>         }</p> 
<p>    }<br> ```<br> 检查timeBetweenEvictionRunsMillis，该参数的意思是执行连接回收的间隔时间，如果该参数设置为&gt;0，则线程睡眠timeBetweenEvictionRunsMillis之后再执行，否则线程每秒执行一次。</p> 
<p>调用destroyTask.run();-&gt; shrink()方法执行线程回收。</p> 
<p><br> 连接回收的主要工作是shrink方法完成的，篇幅原因，放在下一篇文章研究。</p> 
<p>#### 小结<br> 了解了Druid连接池的基础结构及其初始化过程，以及连接池中连接销毁的发起机制：通过destroyConnectionThread线程调用destroyTask对空闲超时的连接进行回收，确保连接池中的连接保持在健康状态。连接回收的主要逻辑是在shrink方法中，其实也是Druid连接池中比较关键的一部分，下一篇文章分析。</p> 
<p>Thanks a lot!</p> 
<p>上一篇 [连接池 HikariPool （二） - 获取及关闭连接](https://segmentfault.com/a/1190000043648602)<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53f715c78b13d1f83caaf8bce3937807/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">github文件上传全流程-新手入门系列（超详细！！！）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a12e6abf71fec43be58bef33639722a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Web3.0介绍与应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>