<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ConcurrentHashMap源码夺命15问，你能坚持到第几问？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ConcurrentHashMap源码夺命15问，你能坚持到第几问？" />
<meta property="og:description" content="临近秋招，备战暑期实习，祝大家每天进步亿点点！Day11本篇总结的是 ConcurrentHashMap 相关的面试题，后续会每日更新~对 ConcurrentHashMap 源码不熟悉的可以参考我的往期博客：ConcurrentHashMap源码解析文章总目录卷吗？卷就对了，Java 就是这么卷卷单单！ 1、请你描述一下ConcurrentHashMap存储数据结构是什么样子呢？ ConcurrentHashMap 内部的 map 结构和 HashMap 是一致的，都是由：数组 &#43; 链表 &#43; 红黑树 构成。
ConcurrentHashMap 存储数据的单元和 HashMap 也是一致的，即，Node 结构：
static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { // hash值 final int hash; // key final K key; // value volatile V val; // 后驱节点 volatile Node&lt;K,V&gt; next; .... } ConcurrentHashMap 和 HashMap 区别就在于前者支持并发扩容，其内部通过加锁（自旋锁 &#43; CAS &#43; synchronized &#43; 分段锁）来保证线程安全。
2、请问ConcurrentHashMap的负载因子可以新指定吗？ 普通的 HashMap 的负载因子可以修改，但是 ConcurrentHashMap 不可以，因为它的负载因子使用 final关键字修饰，值是固定的 0.75 ： // 负载因子：表示散列表的填满程度~ 在ConcurrentHashMap中，该属性是固定值0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/23867a179882efa8736a11131292179f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-30T08:05:44+08:00" />
<meta property="article:modified_time" content="2021-05-30T08:05:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ConcurrentHashMap源码夺命15问，你能坚持到第几问？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ul><li>临近秋招，备战暑期实习，祝大家每天进步亿点点！<mark>Day11</mark></li><li>本篇总结的是 <strong>ConcurrentHashMap</strong> 相关的面试题，后续会每日更新~</li><li>对 <strong>ConcurrentHashMap</strong> 源码不熟悉的可以参考我的往期博客：<a href="https://blog.csdn.net/weixin_43591980/article/details/116502499?spm=1001.2014.3001.5501">ConcurrentHashMap源码解析文章总目录</a></li><li><mark>卷吗？卷就对了，Java 就是这么卷卷单单！</mark></li></ul> 
<p><img src="https://images2.imgbox.com/b5/97/F3BEHLfK_o.jpg" alt="在这里插入图片描述" width="400" height="400"></p> 
<hr> 
<h3><a id="1ConcurrentHashMap_9"></a>1、请你描述一下ConcurrentHashMap存储数据结构是什么样子呢？</h3> 
<ul><li> <p>ConcurrentHashMap 内部的 map 结构和 HashMap 是一致的，都是由：<strong>数组 + 链表 + 红黑树</strong> 构成。</p> </li><li> <p>ConcurrentHashMap 存储数据的单元和 HashMap 也是一致的，即，Node 结构：</p> <pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// hash值</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token comment">// key</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token comment">// value</span>
    <span class="token keyword">volatile</span> <span class="token class-name">V</span> val<span class="token punctuation">;</span>
    <span class="token comment">// 后驱节点</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
    
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>ConcurrentHashMap 和 HashMap 区别就在于前者支持并发扩容，其内部通过加锁（<strong>自旋锁 + CAS + synchronized + 分段锁</strong>）来保证线程安全。</p> </li></ul> 
<hr> 
<h3><a id="2ConcurrentHashMap_34"></a>2、请问ConcurrentHashMap的负载因子可以新指定吗？</h3> 
<ul><li>普通的 HashMap 的负载因子可以修改，但是 ConcurrentHashMap 不可以，因为它的负载因子使用 <code>final</code>关键字修饰，值是固定的 <em>0.75</em> ：</li></ul> 
<pre><code class="prism language-java"><span class="token comment">// 负载因子：表示散列表的填满程度~ 在ConcurrentHashMap中，该属性是固定值0.75，不可修改~</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h3><a id="3_Nodehash__0__45"></a>3、请问节点的 Node.hash 字段一般情况下必须 &gt;=0 这是为什么？</h3> 
<blockquote> 
 <p>或者说，Node 节点的 hash 值有几种情况？针对不同情况分析一下？</p> 
</blockquote> 
<ul><li>如果 <code>Node.hash = -1</code>，表示当前节点是 **FWD(ForWardingNode) **节点(表示已经被迁移的节点)。</li><li>如果 <code>Node.hash = -2</code>，表示当前节点已经树化，且当前节点为 <strong>TreeBin</strong> 对象，<strong>TreeBin</strong> 对象代理操作红黑树。</li><li>如果 <code>Node.hash &gt; 0</code>，表示当前节点是正常的 <em>Node</em> 节点，可能是链表，或者单个 <strong>Node</strong>。</li></ul> 
<hr> 
<h3><a id="4_ConcurrentHashMap__sizeCtl__55"></a>4、请你简述 ConcurrentHashMap 中 sizeCtl 字段的作用（不同情况下的含义）？</h3> 
<blockquote> 
 <p><code>sizeCtr</code> 即 Size Control，这个字段一定要仔细去理解一下，这个字段看不懂，可能会整个 ConcurrentHashMap 源码都一脸懵逼。</p> 
</blockquote> 
<h4><a id="_sizeCtl__0__59"></a>① sizeCtl == 0 时，表示的是什么情况？</h4> 
<ul><li><code>izeCtl == 0</code>，是默认值，<strong>表示在真正第一次初始化散链表的时候使用默认容量 <em>16</em> 进行初始化</strong>。</li></ul> 
<h4><a id="_sizeCtl__1__63"></a>② sizeCtl == -1 时，表示什么情况呢？</h4> 
<ul><li> <p><code>sizeCtl == -1</code><strong>表示当前散链表正处于初始化状态</strong>。有线程正在对当前散列表(<strong>table</strong>) 进行初始化操作。</p> </li><li> <p>ConcurrentHashMap 的散链表是延迟初始化的，在并发条件下必须确保只能初始化一次，所以 <code>sizeCtl == -1</code> 就相当于一个"标识锁"，防止多个线程去初始化散列表。</p> </li><li> <p>具体初始化操作就是在<code>initTable()</code>方法中，会通过 CAS 的方式去修改 <code>sizeCtl</code> 的值为 <code>-1</code>，表示已经有线程正在对散链表进行初始化，其他线程不可以再次初始化，只能等待！</p> <pre><code class="prism language-java"><span class="token comment">// SIZECTL：期望值，初始为0</span>
<span class="token comment">// this 就表示当前 ConcurrentHashMap对象</span>
<span class="token comment">// sc 表示要修改的 sizeCtrl </span>
<span class="token comment">// -1 表示将 sc 修改为 -1</span>
<span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>如果 CAS 修改 <code>sizeCtl = -1</code> 操作成功的线程，可以接着执行对散链表初始化的逻辑。而 CAS 修改失败的线程，在这里会不断的自旋检查，直到散链表初始化结束。</p> </li><li> <p>这里 CAS 失败的线程会走如下逻辑，即自旋的线程会通过<code>Thread.yield();</code>方法，短暂释放 CPU 资源，把 CPU 资源让给更饥饿的线程去使用。目的是为了减轻自旋对CPU 性能的消耗。</p> </li></ul> 
<h4><a id="_mapsizeCtl__0__83"></a>③ 初始化完散列表后，map.sizeCtl &gt; 0 时，表示什么情况呢？</h4> 
<ul><li><code>sizeCtl &gt; 0</code> 时，<strong>表示初始化或扩容完成后下一次触发扩容的阈值</strong>。</li><li>比如，<code>sizeCtl = 12</code> 时，当散链表中数据的个数 <code>&gt;=12</code> 时，就会触发扩容操作。</li></ul> 
<h4><a id="_sizeCtl__0__sizeCtl__1__88"></a>④ sizeCtl &lt; 0 &amp;&amp; sizeCtl != -1 时，代表什么情况呢？</h4> 
<ul><li><code>sizeCtl &lt; 0 &amp;&amp; sizeCtl != -1</code> 时，<strong>表示当前散链表正处于扩容状态</strong>。</li><li><code>-(1 + nThreads)</code>，表示有n个线程正在一起扩容。</li><li>这时候，<code>sizeCtl</code> 的高 <em>16</em> 位表示<strong>扩容标识戳</strong>，低 <em>16</em> 位<strong>表示参与并发扩容线程数</strong>：<code>1 + nThread</code>， 即当前参与并发扩容的线程数量为 <code>n</code> 个。</li></ul> 
<hr> 
<h3><a id="5_96"></a>5、请你说一下扩容标识戳的作用及其计算方式？</h3> 
<ul><li>根据老表的长度 <code>tab.length</code> 去获取扩容唯一标识戳。</li><li>假设 <strong>16 -&gt; 32</strong> 这样扩容，那么扩容标识戳的作用就是在多线程并发扩容条件下，所有 <strong>16 -&gt; 32</strong> 扩容的线程都可以参与并发扩容。</li></ul> 
<pre><code class="prism language-java"><span class="token comment">// 固定值16，与扩容相关，计算扩容时会根据该属性值生成一个扩容标识戳</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> RESIZE_STAMP_BITS <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * table数组扩容时，计算出一个扩容标识戳，当需要并发扩容时，当前线程必须拿到扩容标识戳才能参与扩容：
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// RESIZE_STAMP_BITS：固定值16，与扩容相关，计算扩容时会根据该属性值生成一个扩容标识戳</span>
    <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">numberOfLeadingZeros</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>RESIZE_STAMP_BITS <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><code>sizeCtl &lt; 0 &amp;&amp; sizeCtl != -1</code> 时，这时候<code>sizeCtl</code> 的高 <em>16</em> 位就表示<strong>扩容标识戳</strong>，低 <em>16</em> 位<strong>表示参与并发扩容线程数</strong>：<code>1 + nThread</code>， 即当前参与并发扩容的线程数量为 <code>n</code> 个。</li></ul> 
<hr> 
<h3><a id="6ConcurrentHashMap_118"></a>6、ConcurrentHashMap如何保证写数据线程安全？</h3> 
<blockquote> 
 <p>这个问题其实就是问，向 ConcurrentHashMap 中添加数据确保线程安全是如何实现的。</p> 
</blockquote> 
<ul><li>ConcurrentHashMap 内部通过加锁（<strong>自旋锁 + CAS + synchronized + 分段锁</strong>）来保证线程安全。</li></ul> 
<p>添加数据具体流程如下：</p> 
<ul><li>① 首先，先判断散链表是否已经初始化，如果没初始化则先初始化散链表，再进行写入操作。</li><li>② 当向桶位中写数据时，先判断桶中是否为空，如果是空桶，则直接通过 <mark>CAS</mark> 的方式将新增数据节点写入桶中。如果 CAS 写入失败，则说明有其他线程已经在当前桶位中写入数据，当前线程竞争失败，回到自旋位置，<mark>自旋</mark>等待。</li><li>如果当前桶中不为空，就需要判断当前桶中头结点的类型： 
  <ul><li>③ 如果桶中头结点的 hash 值 为 <code>-1</code>，表示当前桶位的头结点为 <strong>FWD</strong> 结点，目前散链表正处于扩容过程中。这时候当前线程需要去协助扩容。</li><li>④ 如果 ②、③ 条件不满足，则表示当前桶位的存放的可能是一条链表，也可能是红黑树的代理对象 <strong>TreeBin</strong>。这种情况下会使用 <mark>synchronized</mark> 锁住桶中的头结点，来保证桶内的写操作是线程安全的。</li></ul> </li></ul> 
<hr> 
<h3><a id="7ConcurrentHashMaphash_134"></a>7、描述一下ConcurrentHashMap中的hash寻址算法</h3> 
<p>ConcurrentHashMap 的寻址算法和 HashMap 差别不大：</p> 
<ul><li> <p>首先是通过 Node 节点的 Key 获取到它的 HashCode 值，再将 HashCode 值通过 <code>spread(int h)</code>方法进行绕道运算，进而得到最终的 Hash 值。</p> <pre><code class="prism language-java"><span class="token comment">/**
 * 计算Node节点hash值的算法：参数h为hash值
 * eg: 
 * h二进制为 --&gt; 	 		 		 1100 0011 1010 0101 0001 1100 0001 1110
 * (h &gt;&gt;&gt; 16) --&gt;  					0000 0000 0000 0000 1100 0011 1010 0101 
 * (h ^ (h &gt;&gt;&gt; 16)) --&gt;				1100 0011 1010 0101 1101 1111 1011 1011
 * 注：(h ^ (h &gt;&gt;&gt; 16)) 目的是让h的高16位也参与寻址计算，使得到的hash值更分散，减少hash冲突产生~
 * ------------------------------------------------------------------------------
 * HASH_BITS --&gt;					0111 1111 1111 1111 1111 1111 1111 1111
 * (h ^ (h &gt;&gt;&gt; 16)) --&gt;				1100 0011 1010 0101 1101 1111 1011 1011
 * (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS --&gt; 0100 0011 1010 0101 1101 1111 1011 1011
 * 注： (h ^ (h &gt;&gt;&gt; 16))得到的结果再&amp; HASH_BITS，目的是为了让得到的hash值结果始终是一个正数
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 让原来的hash值异或^原来hash值的右移16位，再与&amp;上HASH_BITS(0x7fffffff: 二进制为31个1)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> HASH_BITS<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>获取到最终的 hash 值后，再通过寻址公式：<code>index = (tab.length -1) &amp; hash</code> 获得桶位下标。</p> </li></ul> 
<hr> 
<h3><a id="8ConcurrentHashMap_164"></a>8、ConcurrentHashMap如何统计当前散列表中的数据量?</h3> 
<p>ConcurrentHashMap 统计存储数据的数量是通过 <code>addCount(long x, int check)</code> 方法实现的，本质上是借助了 <strong>LongAdder</strong> 原子类。（参考文章：<a href="https://blog.csdn.net/weixin_43591980/article/details/116146008">LongAdder源码解析</a>）</p> 
<blockquote> 
 <p>ConcurrentHashMap为什么不采用 ConcurrentHashMap为什么不采用 AtomicLong 统计散列表数据量呢？统计散列表数据量呢？</p> 
</blockquote> 
<ul><li>因为 <strong>AtomicLong</strong> 原子类自增操作是基于 CAS 实现的，基于 CAS 实现会导致一个问题，就是当大量线程同时执行 CAS 操作时，只能有一个线程执行成功，而其他所有线程都会因为失败而进入自旋状态，自旋本身就是一个 <code>while(true)</code> 的循环，非常耗费系统资源。</li></ul> 
<blockquote> 
 <p>那么 LongAdder 是如何保证大并发量下，性能依旧高效呢？</p> 
</blockquote> 
<p>先看下<code>LongAdder</code>的操作原理图：（图片参考自<a href="http://www.wazhi.com.cn/SchoolManage/NewsDispatcher?NewsId=942ee429-0c82-4e3b-8df3-4910795d7cfc&amp;SchoolId=1166&amp;action=singlenews#" rel="nofollow">面试官问我LongAdder，我惊了…</a>）</p> 
<p><img src="https://images2.imgbox.com/94/77/CIHe8Piv_o.png" alt=""></p> 
<p><code>LongAdder</code>采用"<strong>分段</strong>"的方式降低<code>CAS</code>失败的频次，<strong>典型的用空间换时间</strong>：</p> 
<ul><li><code>LongAdder</code>有一个全局变量<code>volatile long base;</code>值，当并发不高的情况下都是通过<code>CAS</code>来直接操作<code>base</code>值，如果<code>CAS</code>失败，则针对<code>LongAdder</code>中的<code>Cell[]</code>数组中的<code>Cell</code>进行<code>CAS</code>操作，减少失败的概率。</li></ul> 
<p>如当前类中<code>base = 10</code>，有三个线程进行<code>CAS</code>原子性的 <strong>加1操作</strong>，<strong>线程一执行成功，此时base=11</strong>，<strong>线程二、线程三执行失败后</strong>开始针对于<code>Cell[]</code>数组中的<code>Cell</code>元素进行<strong>加1操作</strong>，同样也是<code>CAS</code>操作，此时数组<code>index=1</code>和<code>index=2</code>中<code>Cell</code>的<code>value</code>都被设置为了1。</p> 
<p>执行完成后，统计累加数据：<code>sum = 11 + 1 + 1 = 13</code>，利用<code>LongAdder</code>进行累加的操作就执行完了，流程图如下：</p> 
<p>（图片参考自<a href="http://www.wazhi.com.cn/SchoolManage/NewsDispatcher?NewsId=942ee429-0c82-4e3b-8df3-4910795d7cfc&amp;SchoolId=1166&amp;action=singlenews#" rel="nofollow">面试官问我LongAdder，我惊了…</a>）</p> 
<p><img src="https://images2.imgbox.com/b3/20/KVbUYiaj_o.png" alt=""></p> 
<hr> 
<h3><a id="9_192"></a>9、触发扩容条件的线程，执行的预处理工作都有哪些？</h3> 
<ul><li>首先，触发扩容条件的线程，要做的第一件事就是通过 CAS 的方式修改 <code>sizeCtl</code> 字段值，使其高 <em>16</em> 位为扩容唯一标识戳，低 <em>16</em> 位为(<strong>参与扩容的线程数 + 1</strong>)，表示有线程正在进行扩容逻辑！ 
  <ul><li><strong>注意</strong>：这里高 <em>16</em> 位的扩容唯一标识戳是根据当前散链表的长度计算得来，其最高位是 <em>1</em>。那么最终得到的 <code>sizeCtl</code> 就应该是一个负数。</li></ul> </li><li>然后，当前触发扩容条件的线程会创建一个新的散链表，大小为原来旧散链表的 <em>2</em> 倍。并且将新散链表的引用赋给 <code>map.nextTable</code> 字段。</li><li>又因为 ConcurrentHashMap 是支持多线程并发扩容的，所以需要让协助扩容的线程知道旧散链表数据迁移到新散链表的进度。为此 ConcurrentHashMap 提供了一个 <code>transferIndex</code> 字段，用于记录旧散链表数据的总迁移进度！迁移工作进度是从 高位桶开始，一直迁移到下标是 <em>0</em> 的桶位。</li></ul> 
<hr> 
<h3><a id="10_201"></a>10、旧散链表中迁移完毕后的桶，如何做标记？</h3> 
<ul><li>旧散链表中迁移完毕的桶，需要用 <strong>ForwardingNode</strong> 对象表示桶内节点，这种 Node 比较特殊，是用来表示当前桶中的数据已经被迁移到新散链表的桶中去了。</li></ul> 
<blockquote> 
 <p>ForwardingNode 有哪些作用？</p> 
</blockquote> 
<ul><li><strong>ForwardingNode</strong> 对象内部提供了一个用于向新散链表中查询目标数据的<code>find()</code>方法。</li><li>当此时某个线程刚好在旧散链表中查询目标元素时，刚好遇到当前桶位中存放的是 <strong>FWD</strong> 节点，那么就可以通过 <strong>FWD</strong> 节点的 <code>find()</code> 方法重新定向到新散链表中去查询目标元素！</li></ul> 
<hr> 
<h3><a id="11_212"></a>11、如果散列表正在库容时，再来新的写入请求该如何处理呢？</h3> 
<blockquote> 
 <p>这里要分两种情况考虑：</p> 
</blockquote> 
<ul><li>如果当前线程执行写入操作时，根据寻址算法访问到的桶中不是 FWD 节点(即，当前桶中数据没有被迁移)。那么此时先判断桶中是否为空，如果为空则 CAS 方式写入数据。而如果桶不为空，则可能是链表或者 <strong>TreeBin</strong>，这时候需要通过 <code>synchronized</code> 关键字锁住桶的头结点再进行写入操作。</li><li>而如果如果当前线程执行写入操作时，根据寻址算法访问到的桶中是 FWD 节点(即，当前桶中数据已经被迁移)。 
  <ul><li>碰到 FWD 节点，说明此时散链表正在进行扩容，这时候需要当前线程也加入进去，去协助散链表扩容（<code>helpTransfer(tab, f);</code>协助扩容是为了尽量减少扩容所花费在数据迁移上的时间）。</li><li>当前线程加入到协助扩容中后，ConcurrentHashMap 会根据全局的<code>transferIndex</code>字段去给当前线程分配迁移工作任务（需要负责迁移旧散链表的桶位区间）。例如，让当前线程负责迁移旧散链表中 【0-4】桶位上的数据到新散链表。</li><li>一直到当前线程分配不到要负责迁移的任务时，则退出协助扩容，即扩容结束。这时候，当前线程就可以继续执行写入数据的逻辑了！</li></ul> </li></ul> 
<hr> 
<h3><a id="12sizeCtl16_224"></a>12、扩容期间，扩容工作线程如何维护sizeCtl的低16位呢？</h3> 
<ul><li>每一个执行扩容任务的线程(包含协助扩容)，它在开始工作之前，都会更新 <code>sizeCtl</code>的低 <em>16</em> 位，即让低 <em>16</em> 位 <code>+1</code>，说明又加入一个新的线程去执行扩容。</li><li>每个执行扩容的线程都会被分配一个迁移工作任务区间，如果当前线程所负责的任务区间迁移工作完成了，没有再被分配迁移任务区间，那么此时当前线程就可以退出协助扩容了，这时候更新 <code>sizeCtl</code>的低 <em>16</em> 位，即让低 <em>16</em> 位 <code>-1</code>，说明有一个线程退出并发扩容了。</li><li>如果 <code>sizeCtl</code> 低 <em>16</em> 位<code>-1</code>后的值为 <em>1</em>，则说明当前线程是最后一个退出并发扩容的线程。</li></ul> 
<hr> 
<h3><a id="13_232"></a>13、当桶位中链表升级为红黑树，且当前红黑树上有读线程正在访问，那么如果再来新的写线程请求该怎么处理？</h3> 
<ul><li><strong>写线程会被阻塞</strong>，因为红黑树比较特殊，新写入数据，可能会触发红黑树的自平衡，这就会导致树的结构发生变化，会影响读线程的读取结果！</li></ul> 
<p>在红黑树上读取数据和写入数据是互斥的，具体原理分析如下：</p> 
<ul><li>我们知道 ConcurrentHashMap 中的红黑树由 <strong>TreeBin</strong> 来代理，<strong>TreeBin</strong> 内部有一个 Int 类型的 <code>state</code> 字段。</li><li>当读线程在读取数据时，会使用 CAS 的方式将 <code>state</code> 值 <code>+4</code>（表示加了读锁），读取数据完毕后，再使用CAS 的方式将 <code>state</code> 值 <code>-4</code>。</li><li>如果写线程去向红黑树中写入数据时，会先检查 <code>state</code> 值是否等于 <code>0</code>，如果是 <em>0</em>，则说明没有读线程在检索数据，这时候可以直接写入数据，写线程也会通过 CAS 的方式将 <code>state</code> 字段值设置为 <code>1</code>（表示加了写锁）。</li><li>如果写线程检查 <code>state</code> 值不是 <code>0</code>，这时候就会<code>park()</code>挂起当前线程，使其等待被唤醒。挂起写线程时，写线程会先将 <code>state</code> 值的第 2 个 bit 位设置为 1（二进制为 <code>10</code>），转换成十进制就是 2，表示有写线程等待被唤醒。</li></ul> 
<blockquote> 
 <p>反过来，当红黑树上有写线程正在执行写入操作，那么如果有新的读线程请求该怎么处理？</p> 
</blockquote> 
<ul><li><strong>TreeBin</strong> 对象内部保留了一个链表结构，就是为了这种情况而设计的。这时候会让新来的读线程到链表上去访问数据，而不经过红黑树。</li></ul> 
<hr> 
<h3><a id="14_249"></a>14、挂起等待的写线程后，什么时候将其唤醒再继续执行写操作呢？</h3> 
<ul><li>上一个问题中，我们分析了：当读线程在读取数据时，会使用 CAS 的方式将 <code>state</code> 值 <code>+4</code>（表示加了读锁），读取数据完毕后，再使用CAS 的方式将 <code>state</code> 值 <code>-4</code>。</li><li>当 <code>state</code> 值减去 <em>4</em> 后，读线程会先检查一下 <code>state</code> 值是不是 <em>2</em>，如果是 <em>2</em> ，则说明有等待被唤醒的写线程在挂起等候，这时候调用 <code>unsafe.unpark()</code> 方法去唤醒该写线程。</li></ul> 
<h3><a id="15_ConcurrentHashMaplastRun_254"></a>15、 请你说一下ConcurrentHashMap中的lastRun机制？</h3> 
<ul><li>文章参考：<a href="https://blog.csdn.net/dataiyangu/article/details/105063685">ConcurrentHashMap扩容？lastRun到底是个啥？</a></li></ul> 
<hr> 
<p><font color="red">总结的面试题也挺费时间的，文章会不定时更新，有时候一天多更新几篇，如果帮助您复习巩固了知识点，还请三连支持一下，后续会亿点点的更新！</font></p> 
<p><img src="https://images2.imgbox.com/4d/e4/idOWK0cc_o.gif" alt="在这里插入图片描述"></p> 
<hr> 
<p><font color="orange" size="4">为了帮助更多小白从零进阶 Java 工程师，从CSDN官方那边搞来了一套 《Java 工程师学习成长知识图谱》，尺寸 <code>870mm x 560mm</code>，展开后有一张办公桌大小，也可以折叠成一本书的尺寸，有兴趣的小伙伴可以了解一下，当然，不管怎样博主的文章一直都是免费的~</font><br> <img src="https://images2.imgbox.com/a5/81/NmE1IPUW_o.jpg" alt="在这里插入图片描述" width="400"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b2926c325241175155f0761756751e50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">android string.contains,The given artifact contains a string literal with a package reference &#39;andro...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/776f529d69337991500335aac8a0b9ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SSM整合配置文件超详细步骤总结 :</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>