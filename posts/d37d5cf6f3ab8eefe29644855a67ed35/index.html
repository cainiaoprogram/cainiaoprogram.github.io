<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kubernetes（二）创建集群 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="kubernetes（二）创建集群" />
<meta property="og:description" content="kubernetes（一）概述与架构
云原生实战 · 语雀
官网 Kubernetes 文档 | Kubernetes
更新：移除 Dockershim 的常见问题 | Kubernetes
B站课程：https://www.bilibili.com/video/BV13Q4y1C7hS/?p=26
安装版本说明：
视频教程安装Docker指定版本20.10.7（我实际安装24.0.7，并装了cri-dockerd版本v0.3.8）
视频教程安装kubelet、kubeadm、kubectl指定版本1.20.9（我实际安装1.28.2）
视频教程安装网络组件为calico版本v3.20（我实际安装kube-flannel版本v0.22.0）
视频教程安装dashboard指定版本v2.3.1（我实际安装v2.7.0）
3.kubernetes创建集群 弹幕：想省钱的可以看看阿里云的抢占式实例，选性能突发实例t6，2核4G一个小时0.04元，花几块钱够玩好几天
3.1 安装Docker 请参照以前Docker安装。先提前为所有机器安装Docker
本视频教程安装Docker指定版本20.10.7（而我实际安装24.0.7）
yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io-1.4.6 3.2 安装cri-dockerd 若Kubernetes版本在v1.24及以上，想使用Docker，所有机器需额外安装cri-dockerd。
cri-dockerd 是一种基于 Docker 的容器运行时实现，它通过实现 CRI 接口，使 Kubernetes 能够与 Docker 进行交互，创建和管理容器
将 Docker Engine 节点从 dockershim 迁移到 cri-dockerd | Kubernetes
容器运行时 | Kubernetes
按照源代码仓库中的说明安装 cri-dockerd。
对于 cri-dockerd，默认情况下，CRI 套接字是 /run/cri-dockerd.sock
下载安装并启动
# 直接点击下载丢到服务器，网络好的话可以直接服务器执行以下命令下载 sudo wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.8/cri-dockerd-0.3.8-3.el7.x86_64.rpm # 通过rpm安装 -i安装软件包 -v显示详细的安装过程 -h显示进度条 sudo rpm -ivh cri-dockerd-0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d37d5cf6f3ab8eefe29644855a67ed35/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T12:29:03+08:00" />
<meta property="article:modified_time" content="2024-01-05T12:29:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kubernetes（二）创建集群</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://blog.csdn.net/Shinka_YXS/article/details/135405392">kubernetes（一）概述与架构</a><br> <a href="https://www.yuque.com/leifengyang/oncloud" rel="nofollow">云原生实战 · 语雀</a><br> <a href="https://kubernetes.io/zh-cn/docs/home/" rel="nofollow">官网 Kubernetes 文档 | Kubernetes</a><br> <a href="https://kubernetes.io/zh-cn/blog/2022/02/17/dockershim-faq/" rel="nofollow">更新：移除 Dockershim 的常见问题 | Kubernetes</a><br> B站课程：https://www.bilibili.com/video/BV13Q4y1C7hS/?p=26</p> 
<p>安装版本说明：<br> 视频教程安装<strong>Docker</strong>指定版本20.10.7（我实际安装24.0.7，并装了cri-dockerd版本v0.3.8）<br> 视频教程安装<strong>kubelet、kubeadm、kubectl</strong>指定版本1.20.9（我实际安装1.28.2）<br> 视频教程安装<strong>网络组件</strong>为<strong>calico</strong>版本v3.20（我实际安装kube-flannel版本v0.22.0）<br> 视频教程安装<strong>dashboard</strong>指定版本v2.3.1（我实际安装v2.7.0）</p> 
<h2><a id="3kubernetes_12"></a>3.kubernetes创建集群</h2> 
<p><img src="https://images2.imgbox.com/5c/76/ZfxsT7Ac_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>弹幕：想省钱的可以看看阿里云的抢占式实例，选性能突发实例t6，2核4G一个小时0.04元，花几块钱够玩好几天</p> 
<h3><a id="31_Docker_19"></a>3.1 安装Docker</h3> 
<p>请参照以前Docker安装。先提前为所有机器安装Docker</p> 
<p>本视频教程安装Docker指定版本20.10.7（而我实际安装24.0.7）</p> 
<pre><code class="prism language-shell">yum <span class="token function">install</span> <span class="token parameter variable">-y</span> docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io-1.4.6
</code></pre> 
<h3><a id="32_cridockerd_29"></a>3.2 安装cri-dockerd</h3> 
<p>若Kubernetes版本在v1.24及以上，想使用Docker，所有机器需额外安装cri-dockerd。</p> 
<blockquote> 
 <p><em>cri-dockerd 是一种基于 Docker 的容器运行时实现，它通过实现 CRI 接口，使 Kubernetes 能够与 Docker 进行交互，创建和管理容器</em></p> 
 <p><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/migrate-dockershim-dockerd/" rel="nofollow">将 Docker Engine 节点从 dockershim 迁移到 cri-dockerd | Kubernetes</a></p> 
 <p><a href="https://v1-28.docs.kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/" rel="nofollow">容器运行时 | Kubernetes</a></p> 
 <p>按照源代码仓库中的说明安装 <a href="https://github.com/Mirantis/cri-dockerd"><code>cri-dockerd</code></a>。</p> 
 <p>对于 <code>cri-dockerd</code>，默认情况下，CRI 套接字是 <code>/run/cri-dockerd.sock</code></p> 
</blockquote> 
<p>下载安装并启动</p> 
<pre><code class="prism language-shell"><span class="token comment"># 直接点击下载丢到服务器，网络好的话可以直接服务器执行以下命令下载</span>
<span class="token function">sudo</span> <span class="token function">wget</span> https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.8/cri-dockerd-0.3.8-3.el7.x86_64.rpm
<span class="token comment"># 通过rpm安装 -i安装软件包 -v显示详细的安装过程 -h显示进度条</span>
<span class="token function">sudo</span> <span class="token function">rpm</span> <span class="token parameter variable">-ivh</span> cri-dockerd-0.3.8-3.el7.x86_64.rpm
<span class="token comment"># 没有rpm命令，可以执行安装该命令</span>
<span class="token comment"># yum - y intall rpm</span>

<span class="token comment"># 启动cri-dockerd</span>
<span class="token comment"># 重载系统守护进程</span>
<span class="token function">sudo</span> systemctl daemon-reload 
<span class="token comment"># 设置cri-dockerd自启动</span>
<span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> cri-docker.socket cri-docker 
<span class="token comment"># 启动cri-dockerd</span>
<span class="token function">sudo</span> systemctl start cri-docker.socket cri-docker 
<span class="token comment"># 查看cri-dockerd状态</span>
<span class="token function">sudo</span> systemctl status cri-docker.socket
</code></pre> 
<p>改下cri-docker.service</p> 
<p>否则在kubeadm init时会报错</p> 
<p>detected that the sandbox image “registry.k8s.io/pause:3.6” of the container runtime is inconsistent with that used by kubeadm. It is recommended that using “registry.aliyuncs.com/google_containers/pause:3.9” as the CRI sandbox image.<br> 然后导致Initial timeout of 40s passed.</p> 
<pre><code class="prism language-shell">systemctl stop cri-docker
<span class="token function">vim</span> /usr/lib/systemd/system/cri-docker.service
<span class="token comment"># 找到ExecStart，在后面添加 --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9</span>
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/bin/cri-dockerd --container-runtime-endpoint fd:// --pod-infra-container-image<span class="token operator">=</span>registry.aliyuncs.com/google_containers/pause:3.9

<span class="token comment"># 重新加载服务</span>
<span class="token function">sudo</span> systemctl daemon-reload
<span class="token comment"># 启动cri-docker服务</span>
<span class="token function">sudo</span> systemctl start cri-docker
<span class="token comment"># 查看cri-docker服务状态</span>
<span class="token function">sudo</span> systemctl status cri-docker <span class="token parameter variable">-l</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0a/cd/c6084WZE_o.png" alt="在这里插入图片描述" width="600"></p> 
<h3><a id="33_kubeadm_88"></a>3.3 安装kubeadm</h3> 
<ul><li> <p>一台兼容的 Linux 主机。Kubernetes 项目为基于 Debian 和 Red Hat 的 Linux 发行版以及一些不提供包管理器的发行版提供通用的指令</p> </li><li> <p>每台机器 2 GB 或更多的 RAM （如果少于这个数字将会影响你应用的运行内存)</p> </li><li> <p>2 CPU 核或更多</p> </li><li> <p>集群中的所有机器的网络彼此均能相互连接(公网和内网都可以)</p> 
  <ul><li><strong>设置防火墙放行规则</strong></li></ul> </li><li> <p>节点之中不可以有重复的主机名、MAC 地址或 product_uuid。请参见<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#verify-mac-address" rel="nofollow">这里</a>了解更多详细信息。</p> 
  <ul><li><strong>设置不同hostname</strong></li></ul> </li><li> <p>开启机器上的某些端口。请参见<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#check-required-ports" rel="nofollow">这里</a> 了解更多详细信息。</p> 
  <ul><li><strong>内网互信</strong></li></ul> </li><li> <p>禁用交换分区。为了保证 kubelet 正常工作，必须关闭交换分区（kubelet 自 v1.22 起已开始支持交换分区。自 v1.28 起，仅针对 cgroup v2 支持交换分区； kubelet 的 NodeSwap 特性门控处于 Beta 阶段，但默认被禁用）</p> 
  <ul><li>输入<code>free -m</code>后，swap所在的行，显示的【total、used、free】都得是0</li></ul> </li></ul> 
<h4><a id="331__109"></a>3.3.1 基础环境</h4> 
<p>所有机器执行以下操作</p> 
<pre><code class="prism language-shell"><span class="token comment"># 各个机器设置自己的主机名</span>
hostnamectl set-hostname xxxx
<span class="token comment"># xxxx 参考：k8s-master、k8s-node1、k8s-node2</span>
<span class="token comment"># 查看主机名</span>
<span class="token function">hostname</span>


<span class="token comment"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span>
<span class="token comment"># 第一句是临时禁用，第二句是改配置文件永久禁用，两个都要执行</span>
<span class="token function">sudo</span> setenforce <span class="token number">0</span>
<span class="token function">sudo</span> <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/^SELINUX=enforcing$/SELINUX=permissive/'</span> /etc/selinux/config

<span class="token comment"># 关闭swap</span>
<span class="token comment"># 第一句是临时禁用，第二句是改配置文件永久禁用，两个都要执行</span>
swapoff <span class="token parameter variable">-a</span>  
<span class="token function">sed</span> <span class="token parameter variable">-ri</span> <span class="token string">'s/.*swap.*/#&amp;/'</span> /etc/fstab

<span class="token comment"># 允许 iptables 检查桥接流量</span>
<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/modules-load.d/k8s.conf</span>
br_netfilter
EOF</span>

<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/sysctl.d/k8s.conf</span>
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF</span>

<span class="token comment"># 让以上的配置生效</span>
<span class="token function">sudo</span> <span class="token function">sysctl</span> <span class="token parameter variable">--system</span>
</code></pre> 
<p>关防火墙</p> 
<p>systemctl stop firewalld.service<br> systemctl status firewalld.service<br> systemctl disable firewalld.service</p> 
<h4><a id="332_kubeletkubeadmkubectl_151"></a>3.3.2 安装kubelet、kubeadm、kubectl</h4> 
<p>kubelet是“厂长”，在集群中的每个节点上用来管理、监控节点上的Pod 和容器。</p> 
<p>kubectl是与集群通信的命令行工具，</p> 
<p>kubeadm是引导我们创建集群的</p> 
<blockquote> 
 <p><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/" rel="nofollow">安装工具 | Kubernetes</a></p> 
 <p>Kubernetes 命令行工具 <a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/kubectl/" rel="nofollow">kubectl</a>， 可以对 Kubernetes 集群运行命令。 可以用 kubectl 来部署应用、监测和管理集群资源以及查看日志。</p> 
 <p>可以使用 <a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/" rel="nofollow">kubeadm</a> 工具来创建和管理 Kubernetes 集群。 该工具能够执行必要的动作并用一种用户友好的方式启动一个可用的、安全的集群。</p> 
</blockquote> 
<p><code>gpgcheck=0</code>表示禁用GPG签名检查。</p> 
<blockquote> 
 <p><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/" rel="nofollow">在 Linux 系统中安装并设置 kubectl | Kubernetes</a>用原生包管理工具安装</p> 
 <ul><li> <p><code>gpgcheck</code>决定了是否在安装包时进行GPG签名检验。若为1，在安装包时会验证该包是否是被信任的发布者所签名发行的，这是一种防止因安装被篡改或者无意识安装恶意软件包的方式。如果你确定软件源可信或者明确知道软件包没有使用GPG签名，你可以设置<code>gpgcheck=0</code>来禁用GPG签名检查，yum将不会检查软件包的GPG签名直接进行安装，可以加速安装过程，但是降低了安全性。</p> </li><li> <p><code>repo_gpgcheck=0</code>：这个配置表示是否检查存储库元数据的 GPG 签名。设置为 0 表示关闭 GPG 签名检查，设置为 1 则表示开启。</p> </li><li> <p><code>gpgkey=http://xxx</code>：这个配置指向了 GPG 公钥的 URL 地址。当gpgcheck 或 repo_gpgcheck 打开时，这个公钥将用于检查软件包或存储库元数据的签名。</p> </li><li> <p><code>exclude=kubelet kubeadm kubectl</code>：这个配置表示在软件包更新或安装过程中忽略指定的软件包。</p> </li></ul> 
</blockquote> 
<p>三台机器都执行以下命令，添加yum存储库配置文件kubernetes.repo</p> 
<pre><code class="prism language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/yum.repos.d/kubernetes.repo</span>
[kubernetes]
name=Kubernetes
baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
exclude=kubelet kubeadm kubectl
EOF</span>
</code></pre> 
<p><a href="https://kubernetes.io/zh-cn/releases/version-skew-policy/" rel="nofollow">版本偏差策略 | Kubernetes</a></p> 
<pre><code class="prism language-shell"><span class="token comment"># 安装kubelet、kubeadm、kubectl</span>
<span class="token comment"># 视频教程安装的</span>
<span class="token function">sudo</span> yum <span class="token function">install</span> <span class="token parameter variable">-y</span> kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 <span class="token parameter variable">--disableexcludes</span><span class="token operator">=</span>kubernetes
<span class="token comment"># 我实际安装的1.28.2 (发布日期: 2023-09-13）。截至2023.12.19最新版本1.29.1（发布日期2023-12-13），但镜像源中没有，所以装的1.28.2</span>
<span class="token function">sudo</span> yum <span class="token function">install</span> <span class="token parameter variable">-y</span> kubelet-1.28.2 kubeadm-1.28.2 kubectl-1.28.2 <span class="token parameter variable">--disableexcludes</span><span class="token operator">=</span>kubernetes

<span class="token comment"># 查看版本信息的命令</span>
kubelet <span class="token parameter variable">--version</span>
kubeadm version
kubectl version <span class="token parameter variable">--client</span>

<span class="token comment"># 三台机器都启动kubelet</span>
<span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> kubelet
<span class="token comment"># enable将kubelet服务设置为开机启动。而通过添加</span>
<span class="token comment"># --now选项，kubelet服务将立即启动</span>

<span class="token comment"># 补充命令</span>
<span class="token comment"># 手动启动</span>
<span class="token comment"># systemctl start kubelet</span>
<span class="token comment"># sudo journalctl -u kubelet</span>
</code></pre> 
<p>用<code>watch -n1 systemctl status kubelet</code>实时查看kubelet状态（或者<code>systemctl status kubelet</code>命令，这个kubelet状态启动的频率很小，要狂刷才能看到），发现kubelet 每隔几秒就会重启，因为它陷入了一个等待 kubeadm 指令的死循环，这是正常的，等待发号施令。</p> 
<p>在使用kubeadm初始化Kubernetes集群时，需要在Master节点上运行一些kubeadm命令来完成初始化过程。其中一个命令是kubeadm init，它将生成一个用于加入其他节点的令牌。kubelet服务在启动时会检查是否存在这个令牌，如果没有找到，它会陷入一个等待kubeadm指令的死循环。</p> 
<h3><a id="34_kubeadm_224"></a>3.4 使用kubeadm引导集群</h3> 
<p>除了kubelet，其他的都是以容器的方式运行，因此可以先提前下载好需要的镜像</p> 
<h4><a id="341__228"></a>3.4.1 下载各个机器需要的镜像</h4> 
<p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#preparing-the-required-container-images" rel="nofollow">使用 kubeadm 创建集群 | Kubernetes</a></p> 
<blockquote> 
 <p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#preparing-the-required-container-images" rel="nofollow">准备所需的容器镜像</a></p> 
 <p>这个步骤是可选的，只适用于你希望 <code>kubeadm init</code> 和 <code>kubeadm join</code> 时不从 <code>registry.k8s.io</code> 下载默认容器镜像的情况。</p> 
 <p>当在离线的节点上创建一个集群的时，Kubeadm 有一些命令可以预拉取所需的镜像。 阅读<a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-init#without-internet-connection" rel="nofollow">离线运行 kubeadm</a> 获取更多的详情。</p> 
 <p>Kubeadm 允许你给所需要的镜像指定一个自定义的镜像仓库。 阅读<a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-init#custom-images" rel="nofollow">使用自定义镜像</a>获取更多的详情。</p> 
</blockquote> 
<p><code>kubeadm config images list</code>可以列出所需的Kubernetes组件的容器镜像，包含每个控制平面组件所需的镜像及其版本。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@主机名 ~<span class="token punctuation">]</span><span class="token comment"># kubeadm config images list</span>
I1220 <span class="token number">10</span>:27:55.955150    <span class="token number">9367</span> version.go:256<span class="token punctuation">]</span> remote version is much newer: v1.29.0<span class="token punctuation">;</span> falling back to: stable-1.28
registry.k8s.io/kube-apiserver:v1.28.4
registry.k8s.io/kube-controller-manager:v1.28.4
registry.k8s.io/kube-scheduler:v1.28.4
registry.k8s.io/kube-proxy:v1.28.4
registry.k8s.io/pause:3.9
registry.k8s.io/etcd:3.5.9-0
registry.k8s.io/coredns/coredns:v1.10.1


<span class="token comment"># 我实际执行的命令</span>
<span class="token comment"># 主节点执行</span>
<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.28.4
<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.28.4
<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.28.4
<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-proxy:v1.28.4
<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/pause:3.9
<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/etcd:3.5.9-0
<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/coredns:v1.10.1
<span class="token comment"># 从节点执行</span>
<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-proxy:v1.28.4
</code></pre> 
<pre><code class="prism language-shell"><span class="token comment"># 只有master机器需要这么多镜像。视频教程所用的版本1.20.9。以下命令产生了文件images.sh。</span>
<span class="token function">sudo</span> <span class="token function">tee</span> ./images.sh <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'
#!/bin/bash
images=(
kube-apiserver:v1.20.9
kube-proxy:v1.20.9
kube-controller-manager:v1.20.9
kube-scheduler:v1.20.9
coredns:1.7.0
etcd:3.4.13-0
pause:3.2
)
for imageName in ${images[@]} ; do
docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/$imageName
done
EOF</span>

<span class="token comment"># 赋予执行权限 并且执行该脚本</span>
<span class="token function">chmod</span> +x ./images.sh <span class="token operator">&amp;&amp;</span> ./images.sh

<span class="token comment"># 两台node机器只下载kube-proxy就可以</span>
<span class="token function">docker</span> pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/kube-proxy:v1.20.9
</code></pre> 
<h4><a id="342__292"></a>3.4.2 初始化主节点</h4> 
<p>弹幕：如果是arm架构的linux系统，用老师的dockerhub上的镜像init的时候会报超时错误，因为docker容器启不起来，要找对应的linux/arm架构的镜像</p> 
<pre><code class="prism language-shell"><span class="token comment"># 所有机器添加master域名映射（所有机器都粘贴执行），以下需要修改为自己的master机器的ip</span>
<span class="token comment"># master节点也叫做集群的入口节点（cluster-endpoint，可以自己起名）</span>
<span class="token comment"># 这是在/etc/hosts添加域名映射，访问cluster-endpoint域名则去到172.31.0.4</span>
<span class="token comment"># 待验证：弹幕说这个地方不要用公网ip，会报错</span>
<span class="token builtin class-name">echo</span> <span class="token string">"172.31.0.4  cluster-endpoint"</span> <span class="token operator">&gt;&gt;</span> /etc/hosts
<span class="token comment"># 以下两句可以不用配置</span>
<span class="token comment"># echo "master的ip  master" &gt;&gt; /etc/hosts</span>
<span class="token comment"># echo "node1的ip  node01" &gt;&gt; /etc/hosts</span>
<span class="token comment"># 测试，在所有机器上（包括master）能ping通</span>
<span class="token function">ping</span> cluster-endpoint


<span class="token comment"># 主节点初始化。只在主节点运行。修改以下</span>
<span class="token comment"># apiserver-advertise-address是master节点ip</span>
<span class="token comment"># control-plane-endpoint上方配置的域名的值</span>
<span class="token comment"># image-repository镜像仓库。不配置的话，文档说默认使用registry.k8s.io，看你能不能ping通吧</span>
<span class="token comment"># kubernetes-version是k8s版本，与安装时的版本号保持一致</span>
<span class="token comment"># service-cidr是service的网络范围，k8s集群内部对大量服务进行负载均衡时用的，尽量不要改</span>
<span class="token comment"># pod-network-cidr是pod的网络范围，也最好不要改</span>
kubeadm init <span class="token punctuation">\</span>
--apiserver-advertise-address<span class="token operator">=</span><span class="token number">172.31</span>.0.4 <span class="token punctuation">\</span>
--control-plane-endpoint<span class="token operator">=</span>cluster-endpoint <span class="token punctuation">\</span>
--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images <span class="token punctuation">\</span>
--kubernetes-version v1.20.9 <span class="token punctuation">\</span>
--service-cidr<span class="token operator">=</span><span class="token number">10.96</span>.0.0/16 <span class="token punctuation">\</span>
--pod-network-cidr<span class="token operator">=</span><span class="token number">192.168</span>.0.0/16
<span class="token comment"># 我实际执行的</span>
kubeadm init <span class="token punctuation">\</span>
--apiserver-advertise-address<span class="token operator">=</span><span class="token number">172.31</span>.254.210 <span class="token punctuation">\</span>
--node-name<span class="token operator">=</span>cluster-endpoint <span class="token punctuation">\</span>
--control-plane-endpoint<span class="token operator">=</span>cluster-endpoint <span class="token punctuation">\</span>
--image-repository<span class="token operator">=</span>registry.aliyuncs.com/google_containers <span class="token punctuation">\</span>
--kubernetes-version v1.28.2 <span class="token punctuation">\</span>
--service-cidr<span class="token operator">=</span><span class="token number">10.96</span>.0.0/16 <span class="token punctuation">\</span>
--pod-network-cidr<span class="token operator">=</span><span class="token number">192.168</span>.0.0/16 <span class="token punctuation">\</span>
--cri-socket<span class="token operator">=</span>unix:///var/run/cri-dockerd.sock
<span class="token comment"># 教程里的--pod-network-cidr是calico的默认配置，如果使用flannel应该写--pod-network-cidr=10.244.0.0/16</span>

<span class="token comment"># 如果要改service-cidr和pod-network-cidr，要保证【所有网络范围不重叠】，同时也不能跟机器的ip范围重叠</span>
<span class="token comment"># 比如，若service-cidr配的是172.31.0.0/16，就跟机器重叠了。</span>
<span class="token comment"># 执行命令【ip a】可以看到Docker把172.17占用了，服务器若再选172.17可能有问题，因此教程购买服务器时选的是172.31、根据提示继续</span>
<span class="token comment"># 弹幕：主机IP是192.168的可以把pod-network-cidr设置为10.244.0.0/16</span>
</code></pre> 
<p>如果初始化报错失败</p> 
<blockquote> 
 <p>要重新初始化kubeadm，可以按照以下步骤进行操作：</p> 
 <ol><li> <p>首先，使用root用户登录到主节点或控制平面节点。</p> </li><li> <p>停止kubelet服务：运行命令<code>systemctl stop kubelet</code>。</p> </li><li> <p>删除当前集群的所有网络接口：运行命令<code>ip link delete cni0</code>和<code>ip link delete flannel.1</code>。</p> </li><li> <p>删除当前集群的所有容器（把相关的删掉就行，别删所有的）：运行命令<code>docker rm -f $(docker ps -qa)</code>（该命令删除所有容器）。</p> </li><li> <p>删除当前集群的所有数据：运行命令<code>rm -rf /var/lib/cni/ /var/lib/kubelet /etc/cni/ /var/run/kubernetes /var/lib/cni/ /var/run/calico/ /etc/kubernetes /var/lib/etcd</code>。</p> </li><li> <p>执行kubeadm reset命令以重置kubeadm和相关配置：运行命令<code>kubeadm reset</code>。</p> </li><li> <p>如果您使用了网络插件（如Flannel、Calico等），则需要删除其相关配置。例如，对于Flannel，运行命令<code>rm -rf /etc/cni/net.d/10-flannel.conflist</code>。</p> </li><li> <p>最后，重新初始化kubeadm。您可以按照之前的步骤重新运行kubeadm init命令来初始化新的集群。</p> </li></ol> 
 <p>请注意，重新初始化kubeadm将清除当前集群中的所有数据和配置，包括节点和Pod信息。确保在执行此操作之前备份重要数据，并谨慎操作。</p> 
 <p>再不行可以reboot重启机器试下</p> 
</blockquote> 
<p>master成功后提示如下，复制一下提前保留，根据它的提示做。</p> 
<p>弹幕：出现 It seems like the kubelet isn’t running or healthy. 说明docker服务未配置cgroupfs 可以参考 dockers 部署安装那一篇文章</p> 
<pre><code class="prism language-shell">Your Kubernetes control-plane has initialized successfully<span class="token operator">!</span>

<span class="token comment"># 先做这三步命令。</span>
To start using your cluster, you need to run the following as a regular user:

  <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token environment constant">$HOME</span>/.kube
  <span class="token function">sudo</span> <span class="token function">cp</span> <span class="token parameter variable">-i</span> /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config
  <span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-u</span><span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-g</span><span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/config

Alternatively, <span class="token keyword">if</span> you are the root user, you can run:

  <span class="token builtin class-name">export</span> <span class="token assign-left variable">KUBECONFIG</span><span class="token operator">=</span>/etc/kubernetes/admin.conf

<span class="token comment"># 部署一个pod网络插件。可以从下面的链接看文档，教程选用calico</span>
You should now deploy a pod network to the cluster.
Run <span class="token string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

<span class="token comment"># 可以按照以下命令加入任意多的【主节点】</span>
You can now <span class="token function">join</span> any number of control-plane nodes by copying certificate authorities
and <span class="token function">service</span> account keys on each <span class="token function">node</span> and <span class="token keyword">then</span> running the following as root:

  kubeadm <span class="token function">join</span> cluster-endpoint:6443 <span class="token parameter variable">--token</span> hums8f.vyx71prsg74ofce7 <span class="token punctuation">\</span>
    --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3 <span class="token punctuation">\</span>
    --control-plane 

<span class="token comment"># 可以按照以下命令加入任意多的【工作节点】</span>
Then you can <span class="token function">join</span> any number of worker nodes by running the following on each as root:

kubeadm <span class="token function">join</span> cluster-endpoint:6443 <span class="token parameter variable">--token</span> hums8f.vyx71prsg74ofce7 <span class="token punctuation">\</span>
    --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3
</code></pre> 
<p>我自己实际显示的</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>init<span class="token punctuation">]</span> Using Kubernetes version: v1.28.2
<span class="token punctuation">[</span>preflight<span class="token punctuation">]</span> Running pre-flight checks
<span class="token punctuation">[</span>preflight<span class="token punctuation">]</span> Pulling images required <span class="token keyword">for</span> setting up a Kubernetes cluster
<span class="token punctuation">[</span>preflight<span class="token punctuation">]</span> This might take a minute or two, depending on the speed of your internet connection
<span class="token punctuation">[</span>preflight<span class="token punctuation">]</span> You can also perform this action <span class="token keyword">in</span> beforehand using <span class="token string">'kubeadm config images pull'</span>
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Using certificateDir folder <span class="token string">"/etc/kubernetes/pki"</span>
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"ca"</span> certificate and key
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"apiserver"</span> certificate and key
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> apiserver serving cert is signed <span class="token keyword">for</span> DNS names <span class="token punctuation">[</span>cluster-endpoint kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local<span class="token punctuation">]</span> and IPs <span class="token punctuation">[</span><span class="token number">10.96</span>.0.1 <span class="token number">172.31</span>.254.210<span class="token punctuation">]</span>
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"apiserver-kubelet-client"</span> certificate and key
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"front-proxy-ca"</span> certificate and key
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"front-proxy-client"</span> certificate and key
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"etcd/ca"</span> certificate and key
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"etcd/server"</span> certificate and key
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> etcd/server serving cert is signed <span class="token keyword">for</span> DNS names <span class="token punctuation">[</span>cluster-endpoint localhost<span class="token punctuation">]</span> and IPs <span class="token punctuation">[</span><span class="token number">172.31</span>.254.210 <span class="token number">127.0</span>.0.1 ::1<span class="token punctuation">]</span>
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"etcd/peer"</span> certificate and key
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> etcd/peer serving cert is signed <span class="token keyword">for</span> DNS names <span class="token punctuation">[</span>cluster-endpoint localhost<span class="token punctuation">]</span> and IPs <span class="token punctuation">[</span><span class="token number">172.31</span>.254.210 <span class="token number">127.0</span>.0.1 ::1<span class="token punctuation">]</span>
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"etcd/healthcheck-client"</span> certificate and key
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"apiserver-etcd-client"</span> certificate and key
<span class="token punctuation">[</span>certs<span class="token punctuation">]</span> Generating <span class="token string">"sa"</span> key and public key
<span class="token punctuation">[</span>kubeconfig<span class="token punctuation">]</span> Using kubeconfig folder <span class="token string">"/etc/kubernetes"</span>
<span class="token punctuation">[</span>kubeconfig<span class="token punctuation">]</span> Writing <span class="token string">"admin.conf"</span> kubeconfig <span class="token function">file</span>
<span class="token punctuation">[</span>kubeconfig<span class="token punctuation">]</span> Writing <span class="token string">"kubelet.conf"</span> kubeconfig <span class="token function">file</span>
<span class="token punctuation">[</span>kubeconfig<span class="token punctuation">]</span> Writing <span class="token string">"controller-manager.conf"</span> kubeconfig <span class="token function">file</span>
<span class="token punctuation">[</span>kubeconfig<span class="token punctuation">]</span> Writing <span class="token string">"scheduler.conf"</span> kubeconfig <span class="token function">file</span>
<span class="token punctuation">[</span>etcd<span class="token punctuation">]</span> Creating static Pod manifest <span class="token keyword">for</span> <span class="token builtin class-name">local</span> etcd <span class="token keyword">in</span> <span class="token string">"/etc/kubernetes/manifests"</span>
<span class="token punctuation">[</span>control-plane<span class="token punctuation">]</span> Using manifest folder <span class="token string">"/etc/kubernetes/manifests"</span>
<span class="token punctuation">[</span>control-plane<span class="token punctuation">]</span> Creating static Pod manifest <span class="token keyword">for</span> <span class="token string">"kube-apiserver"</span>
<span class="token punctuation">[</span>control-plane<span class="token punctuation">]</span> Creating static Pod manifest <span class="token keyword">for</span> <span class="token string">"kube-controller-manager"</span>
<span class="token punctuation">[</span>control-plane<span class="token punctuation">]</span> Creating static Pod manifest <span class="token keyword">for</span> <span class="token string">"kube-scheduler"</span>
<span class="token punctuation">[</span>kubelet-start<span class="token punctuation">]</span> Writing kubelet environment <span class="token function">file</span> with flags to <span class="token function">file</span> <span class="token string">"/var/lib/kubelet/kubeadm-flags.env"</span>
<span class="token punctuation">[</span>kubelet-start<span class="token punctuation">]</span> Writing kubelet configuration to <span class="token function">file</span> <span class="token string">"/var/lib/kubelet/config.yaml"</span>
<span class="token punctuation">[</span>kubelet-start<span class="token punctuation">]</span> Starting the kubelet
<span class="token punctuation">[</span>wait-control-plane<span class="token punctuation">]</span> Waiting <span class="token keyword">for</span> the kubelet to boot up the control plane as static Pods from directory <span class="token string">"/etc/kubernetes/manifests"</span><span class="token builtin class-name">.</span> This can take up to 4m0s
<span class="token punctuation">[</span>apiclient<span class="token punctuation">]</span> All control plane components are healthy after <span class="token number">8.003598</span> seconds
<span class="token punctuation">[</span>upload-config<span class="token punctuation">]</span> Storing the configuration used <span class="token keyword">in</span> ConfigMap <span class="token string">"kubeadm-config"</span> <span class="token keyword">in</span> the <span class="token string">"kube-system"</span> Namespace
<span class="token punctuation">[</span>kubelet<span class="token punctuation">]</span> Creating a ConfigMap <span class="token string">"kubelet-config"</span> <span class="token keyword">in</span> namespace kube-system with the configuration <span class="token keyword">for</span> the kubelets <span class="token keyword">in</span> the cluster
<span class="token punctuation">[</span>upload-certs<span class="token punctuation">]</span> Skipping phase. Please see --upload-certs
<span class="token punctuation">[</span>mark-control-plane<span class="token punctuation">]</span> Marking the <span class="token function">node</span> cluster-endpoint as control-plane by adding the labels: <span class="token punctuation">[</span>node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers<span class="token punctuation">]</span>
<span class="token punctuation">[</span>mark-control-plane<span class="token punctuation">]</span> Marking the <span class="token function">node</span> cluster-endpoint as control-plane by adding the taints <span class="token punctuation">[</span>node-role.kubernetes.io/control-plane:NoSchedule<span class="token punctuation">]</span>
<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> Using token: 72iez2.4m121dqbx5no00vk
<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles
<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> Configured RBAC rules to allow Node Bootstrap tokens to get nodes
<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> Configured RBAC rules to allow Node Bootstrap tokens to post CSRs <span class="token keyword">in</span> order <span class="token keyword">for</span> nodes to get long term certificate credentials
<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> Configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token
<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> Configured RBAC rules to allow certificate rotation <span class="token keyword">for</span> all <span class="token function">node</span> client certificates <span class="token keyword">in</span> the cluster
<span class="token punctuation">[</span>bootstrap-token<span class="token punctuation">]</span> Creating the <span class="token string">"cluster-info"</span> ConfigMap <span class="token keyword">in</span> the <span class="token string">"kube-public"</span> namespace
<span class="token punctuation">[</span>kubelet-finalize<span class="token punctuation">]</span> Updating <span class="token string">"/etc/kubernetes/kubelet.conf"</span> to point to a rotatable kubelet client certificate and key
<span class="token punctuation">[</span>addons<span class="token punctuation">]</span> Applied essential addon: CoreDNS
<span class="token punctuation">[</span>addons<span class="token punctuation">]</span> Applied essential addon: kube-proxy

Your Kube
rnetes control-plane has initialized successfully<span class="token operator">!</span>

<span class="token comment"># 先做这三步命令。</span>
To start using your cluster, you need to run the following as a regular user:

  <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token environment constant">$HOME</span>/.kube
  <span class="token function">sudo</span> <span class="token function">cp</span> <span class="token parameter variable">-i</span> /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config
  <span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-u</span><span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-g</span><span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/config

Alternatively, <span class="token keyword">if</span> you are the root user, you can run:

  <span class="token builtin class-name">export</span> <span class="token assign-left variable">KUBECONFIG</span><span class="token operator">=</span>/etc/kubernetes/admin.conf

<span class="token comment"># 部署一个pod网络插件。可以从下面的链接看文档，教程选用calico，个人实际操作选择flannel</span>
You should now deploy a pod network to the cluster.
Run <span class="token string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

<span class="token comment"># 可以按照以下命令加入任意多的【主节点】</span>
You can now <span class="token function">join</span> any number of control-plane nodes by copying certificate authorities
and <span class="token function">service</span> account keys on each <span class="token function">node</span> and <span class="token keyword">then</span> running the following as root:

  kubeadm <span class="token function">join</span> cluster-endpoint:6443 <span class="token parameter variable">--token</span> 72iez2.4m121dqbx5no00vk <span class="token punctuation">\</span>
        --discovery-token-ca-cert-hash sha256:71ae2cb27b517e0531ed358f3545989b45583bb3f62b6c3dabe6fe1be5e4b529 <span class="token punctuation">\</span>
        --control-plane 

<span class="token comment"># 可以按照以下命令加入任意多的【工作节点】</span>
Then you can <span class="token function">join</span> any number of worker nodes by running the following on each as root:

kubeadm <span class="token function">join</span> cluster-endpoint:6443 <span class="token parameter variable">--token</span> 72iez2.4m121dqbx5no00vk <span class="token punctuation">\</span>
        --discovery-token-ca-cert-hash sha256:71ae2cb27b517e0531ed358f3545989b45583bb3f62b6c3dabe6fe1be5e4b529
</code></pre> 
<p>其他命令</p> 
<pre><code class="prism language-shell"><span class="token comment"># 查看集群所有节点</span>
<span class="token comment"># 没做【部署一个pod网络插件】时执行此命令可看到master的status是【NotReady】</span>
kubectl get nodes

<span class="token comment"># 根据配置文件，给集群创建资源</span>
kubectl apply <span class="token parameter variable">-f</span> xxxx.yaml

<span class="token comment"># 查看集群部署了哪些应用？</span>
<span class="token function">docker</span> <span class="token function">ps</span>   <span class="token operator">==</span><span class="token operator">=</span>   kubectl get pods <span class="token parameter variable">-A</span>
<span class="token comment"># 运行中的应用，在docker里面叫容器，在k8s里面叫Pod</span>
kubectl get pods <span class="token parameter variable">-A</span>

<span class="token comment"># 查看kubelet日志</span>
<span class="token function">sudo</span> journalctl <span class="token parameter variable">-u</span> kubelet    <span class="token comment"># 这个命令日志不自动换行</span>
<span class="token function">sudo</span> journalctl <span class="token parameter variable">-u</span> kubelet --no-pager <span class="token parameter variable">--follow</span>
</code></pre> 
<h4><a id="343__512"></a>3.4.3 根据提示继续</h4> 
<h5><a id="_HOMEkubeconfig_514"></a>设置 $HOME/.kube/config</h5> 
<p>复制上面命令</p> 
<h5><a id="_518"></a>安装网络组件</h5> 
<p><a href="https://docs.projectcalico.org/getting-started/kubernetes/self-managed-onprem/onpremises#install-calico-with-kubernetes-api-datastore-more-than-50-nodes" rel="nofollow">calico官网</a></p> 
<p>https://github.com/projectcalico/calico/releases/tag/v3.17.0</p> 
<p>另外弹幕建议不用calico而用flannel：<code>kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml</code></p> 
<p><code>curl https://github.com/flannel-io/flannel/releases/download/v0.22.0/kube-flannel.yml -O</code></p> 
<p>注意配置文件中的网段应该与init时配置的–pod-network-cidr一致</p> 
<pre><code class="prism language-shell"><span class="token comment"># 在master节点上执行，把calico的配置文件下载下来，再传给其他机器。</span>
<span class="token comment"># 检查下当前的k8s和calico对应的版本下正确的版本后再运行，此处若报错只需要换一个版本就行了。</span>
<span class="token comment"># no matches for kind "PodDisruptionBudget" in version "policy/v1"这个报错是因为网络插件与k8s版本不匹配，换一个就可以了</span>
<span class="token function">curl</span> https://docs.projectcalico.org/v3.20/manifests/calico.yaml <span class="token parameter variable">-O</span>
<span class="token comment"># 确认有calico.yaml</span>
<span class="token function">ls</span>

<span class="token comment"># 只要有配置文件，执行以下命令会自动创建很多东西，这一步就把网络插件部署好了</span>
<span class="token comment"># 直接执行该命令的前提是【初始化主节点】时没有修改cidr，否则需要修改calico.yaml的相应的配置</span>
kubectl apply <span class="token parameter variable">-f</span> calico.yaml
<span class="token comment"># 弹幕：这个可以回滚刚才的操作</span>
<span class="token comment"># kubectl delete -f calico.yaml</span>
<span class="token comment"># 我实际执行的</span>
kubectl apply <span class="token parameter variable">-f</span> kube-flannel.yml

kubectl get pods <span class="token parameter variable">-A</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/93/64/y2X1aw4I_o.png" alt="在这里插入图片描述" width="500"></p> 
<p><img src="https://images2.imgbox.com/20/a0/1KVDrlEv_o.png" alt="在这里插入图片描述" width="600"></p> 
<h4><a id="344_node_555"></a>3.4.4 加入node节点</h4> 
<p>弹幕：后面子节点join不上的话，把防火墙关一下，老师之前那个关防火墙的命令不管用，可以用firewall-cmd --state查看是不是真的关了</p> 
<pre><code class="prism language-shell">systemctl disable firewalld <span class="token parameter variable">--now</span>
systemctl stop firewalld
systemctl disable firewalld    <span class="token comment"># 设置开机不启动防火墙</span>
<span class="token function">sudo</span> firewall-cmd --add-port<span class="token operator">=</span><span class="token number">6443</span>/tcp <span class="token parameter variable">--permanent</span> <span class="token function">sudo</span> firewall-cmd <span class="token parameter variable">--reload</span>
<span class="token function">service</span> firewalld stop
systemctl status firewalld.service    <span class="token comment"># 查看防火墙状态</span>
</code></pre> 
<p>云服务器的安全组要开放6443端口</p> 
<pre><code class="prism language-shell"><span class="token comment"># 复制前面master成功后保留的命令，该命令24小时有效</span>
kubeadm <span class="token function">join</span> cluster-endpoint:6443 <span class="token parameter variable">--token</span> x5g4uy.wpjjdbgra92s25pp <span class="token punctuation">\</span>
    --discovery-token-ca-cert-hash sha256:6255797916eaee52bf9dda9429db616fcd828436708345a308f4b917d3457a22
<span class="token comment"># 若24小时后该令牌失效了，可以在master上再重新生成加入集群的密码</span>
<span class="token comment"># sudo kubeadm token create --print-join-command</span>
<span class="token comment"># 弹幕：加入节点卡主不动，可以在master节点上用kubeadm token create --print-join-command重新申请一个token，就可以了</span>


<span class="token comment"># 我实际执行</span>
kubeadm <span class="token function">join</span> cluster-endpoint:6443 <span class="token parameter variable">--token</span> 72iez2.4m121dqbx5no00vk <span class="token punctuation">\</span>
        --discovery-token-ca-cert-hash sha256:71ae2cb27b517e0531ed358f3545989b45583bb3f62b6c3dabe6fe1be5e4b529 <span class="token punctuation">\</span>
--cri-socket<span class="token operator">=</span>unix:///var/run/cri-dockerd.sock
</code></pre> 
<p>如果加入失败，想重新加入</p> 
<blockquote> 
 <p>sudo systemctl stop kubelet</p> 
 <p>sudo kubeadm reset --cri-socket=unix:///var/run/cri-dockerd.sock</p> 
 <p>sudo systemctl enable --now kubelet</p> 
 <p>watch -n1 systemctl status kubelet</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/17/bb/l8ALqmLb_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>看到“This node has joined the cluster”就代表该工作节点已经加入该集群</p> 
<pre><code class="prism language-shell">This <span class="token function">node</span> has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.
<span class="token comment"># 可以使用kubectl get nodes这个命令在控制平面（主节点）看，必须在主节点看，node节点会报错。</span>
Run <span class="token string">'kubectl get nodes'</span> on the control-plane to see this <span class="token function">node</span> <span class="token function">join</span> the cluster
</code></pre> 
<p>等一会儿，监控进度状态</p> 
<pre><code class="prism language-shell"><span class="token comment"># -w参数，有变化会追加显示</span>
kubectl get pods <span class="token parameter variable">-A</span> <span class="token parameter variable">-w</span>
<span class="token comment"># 或者用Linux命令每1秒查看状态</span>
<span class="token function">watch</span> <span class="token parameter variable">-n</span> <span class="token number">1</span> kubectl get pods <span class="token parameter variable">-A</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/9a/82/KRQqMvnJ_o.png" alt="在这里插入图片描述" width="600"></p> 
<p><img src="https://images2.imgbox.com/e0/76/HI9apqoi_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>等到ready全部都是1/1，status全部都是running之后，查看nodes状态也都会是Ready</p> 
<pre><code class="prism language-shell">kubectl get nodes
</code></pre> 
<p>机器重启后k8s集群会自动恢复的，如果有问题试试restart，以及关防火墙、检查网络</p> 
<pre><code class="prism language-shell">systemctl restart docker.service
systemctl restart kubelet.service
</code></pre> 
<p>生成新令牌</p> 
<p>kubeadm token create --print-join-command</p> 
<p><em><strong>高可用部署方式，也是在这一步的时候，使用添加主节点的命令即可</strong></em></p> 
<h4><a id="345__641"></a>3.4.5 验证集群</h4> 
<p>验证集群节点状态<code>kubectl get nodes</code></p> 
<h2><a id="4dashboard_644"></a>4.部署dashboard</h2> 
<h3><a id="41__646"></a>4.1 部署</h3> 
<p>kubernetes官方提供的可视化界面</p> 
<p>https://github.com/kubernetes/dashboard</p> 
<p>https://github.com/kubernetes/dashboard/releases</p> 
<pre><code class="prism language-bash"><span class="token comment"># 该命令需要先下载远程的yaml文件，可能比较慢，可以先用wget命令下载</span>
kubectl apply <span class="token parameter variable">-f</span> https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml
<span class="token comment"># 我实际执行的：安装v3.0.0-alpha0有问题没解决，【kubectl delete -f 该url】卸载了之后，又重新安装的v2.7.0版本</span>
kubectl apply <span class="token parameter variable">-f</span> https://raw.githubusercontent.com/kubernetes/dashboard/v3.0.0-alpha0/charts/kubernetes-dashboard.yaml
kubectl apply <span class="token parameter variable">-f</span> https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml
</code></pre> 
<h3><a id="42__662"></a>4.2 设置访问端口</h3> 
<pre><code class="prism language-shell"><span class="token comment"># 把【type: ClusterIP】改为【type: NodePort】，这步操作相当于暴露web界面的端口</span>
kubectl edit svc kubernetes-dashboard <span class="token parameter variable">-n</span> kubernetes-dashboard
<span class="token comment"># 找到端口，在云服务器的安全组放行。显示的随机生成的三万多的端口（比如30753）就是访问k8s控制台的</span>
kubectl get svc <span class="token parameter variable">-A</span> <span class="token operator">|</span><span class="token function">grep</span> kubernetes-dashboard
<span class="token comment"># 获取集群中所有命名空间下的Pod的信息。-A参数将在所有命名空间中获取Pod的信息，而不仅仅在当前命名空间。</span>
kubectl get pods <span class="token parameter variable">-A</span>
</code></pre> 
<p>访问【https://集群任意IP:端口】https://139.198.165.238:32759</p> 
<p>弹幕讨论：</p> 
<p>如果出现进入不了dashboard界面，报错显示connection time out的话，可能是兼容性问题导致的，换另一个版本的calico或者flannel即可</p> 
<p>谷歌浏览器如果没有“继续前往”选项的话，键盘直接敲thisisunsafe</p> 
<p>用node的IP可以访问dashboard，用master的IP却无法访问时，可以在master上执行<code>iptables -P FORWARD ACCEPT</code></p> 
<h3><a id="43__683"></a>4.3 创建访问账号</h3> 
<p>1.24版本的k8s用kubectl -n kubernetes-dashboard create token admin-user</p> 
<p>视频中1.20.9版本，创建访问账号，准备一个yaml文件<code>vim dash.yaml</code></p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard
<span class="token punctuation">---</span>
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user
<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io
  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole
  <span class="token key atrule">name</span><span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>admin
<span class="token key atrule">subjects</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount
  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard
</code></pre> 
<p>应用配置</p> 
<pre><code class="prism language-shell">kubectl apply <span class="token parameter variable">-f</span> dash.yaml
<span class="token comment"># 会显示admin-user已创建</span>
<span class="token comment"># serviceaccount/admin-user created</span>
<span class="token comment"># clusterrolebinding.rbac.authorization.k8s.io/admin-user created</span>
</code></pre> 
<h3><a id="44__719"></a>4.4 令牌访问</h3> 
<p>输入以下命令，把输出的结果（令牌）复制备份，粘贴到登录界面的token处。</p> 
<pre><code class="prism language-shell"><span class="token comment"># 教程k8s是v1.20.9 获取访问令牌</span>
kubectl <span class="token parameter variable">-n</span> kubernetes-dashboard get secret <span class="token variable"><span class="token variable">$(</span>kubectl <span class="token parameter variable">-n</span> kubernetes-dashboard get sa/admin-user <span class="token parameter variable">-o</span> <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">"{.secrets[0].name}"</span><span class="token variable">)</span></span> <span class="token parameter variable">-o</span> go-template<span class="token operator">=</span><span class="token string">"{<!-- -->{.data.token | base64decode}}"</span>
</code></pre> 
<p>我实际安装v1.28.2，获取访问令牌方式</p> 
<pre><code class="prism language-shell">kubectl <span class="token parameter variable">-n</span> kubernetes-dashboard describe secret <span class="token variable"><span class="token variable">$(</span>kubectl <span class="token parameter variable">-n</span> kubernetes-dashboard get secret <span class="token operator">|</span> <span class="token function">grep</span> admin-user <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span><span class="token variable">)</span></span>
<span class="token comment"># 上面的命令没有生成token，参考解决：https://zhuanlan.zhihu.com/p/655525723</span>
<span class="token comment"># 1）创建serviceaccount</span>
kubectl create serviceaccount myadmin <span class="token parameter variable">-n</span> kubernetes-dashboard
<span class="token comment"># 2）查看账户信息</span>
kubectl get serviceaccount myadmin <span class="token parameter variable">-o</span> yaml  <span class="token parameter variable">-n</span> kubernetes-dashboard
<span class="token comment"># 3）绑定角色</span>
kubectl create clusterrolebinding myadmin <span class="token parameter variable">--clusterrole</span><span class="token operator">=</span>cluster-admin <span class="token parameter variable">--serviceaccount</span><span class="token operator">=</span>kubernetes-dashboard:myadmin   <span class="token parameter variable">-n</span> kubernetes-dashboard
<span class="token comment"># 4）生成token</span>
kubectl create token myadmin  <span class="token parameter variable">-n</span> kubernetes-dashboard
</code></pre> 
<p>生成了token类似以下：</p> 
<blockquote> 
 <p>eyJhbGciOiJSUzI1NiIsImtpZCI6InNOSUU0SGtoeTJQNVYwcHFGeUUxN3pMaV9VdjJnU1hfZi1oYmRlWWJWS3MifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNzA0MzU0NzI4LCJpYXQiOjE3MDQzNTExMjgsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJteWFkbWluIiwidWlkIjoiYzczNTE4MzMtNjk1Yy00ZjIzLTg1MjAtYWUyNjNmMWZkOWZiIn19LCJuYmYiOjE3MDQzNTExMjgsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlcm5ldGVzLWRhc2hib2FyZDpteWFkbWluIn0.A0Gpahsxvc9jWH4o6b1ZJNB90ez9hN86Up23UeSMtKm_tFK0d9hgWjvVijOkTRnLW1Tg8K3sTBS8HtNPwdyKzwDIt0XPKgmecq2csU2Ca_tngbuR04DCnGUbQgvDe_HXaQlREvnV_pWdcey85exsYmClcXst5FDfHpfNYtKbbeYSTmu-jJKwphrHeuJXzjFrCGEaM5RKmcupyXFVOYE6QEcstYvzukBMxd76AVAgKMEVAz1–A70TykvqhVU2thgdudslCA2HJsyNNGkrsHQW7t5Nj6YFvXgwE6TPmjTROek4VXINPkPCjUaLUg_WSjzjzk-poVmkBffCTdNSYpPeg</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/9b/bc/nwbNcGOz_o.png" alt="在这里插入图片描述" width="500"></p> 
<h3><a id="45__750"></a>4.5 界面</h3> 
<p><img src="https://images2.imgbox.com/44/b2/C28ZnCJ6_o.png" alt="在这里插入图片描述" width="600"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4fd60d9f00d7982d79ecc13409b14bb8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MyBatis】MyBatis基础操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b2d3ac49bcb2a14b5089f98918aca6e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kubernetes（一）概述与架构</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>