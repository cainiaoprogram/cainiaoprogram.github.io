<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Tuxedo数据buffer基本类型介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Tuxedo数据buffer基本类型介绍" />
<meta property="og:description" content="Tuxedo数据buffer基本类型介绍
一、 课程目标
通过本课程学习，你可以掌握如下知识： 掌握tuxedo中STRING类型buffer的用途
掌握tuxedo中CARRAY类型buffer的用途
掌握tuxedo中FML(FML32)类型buffer的用途
掌握tuxedo中VIEW(VIEW32)类型buffer的用途
注:后续的课程将介绍Tuxedo新增的数据类型:EFML(Embedded Record in FML)、XML Buffer 二、 String类型buffer介绍
（1）STRING类型buffer简介
STRING类型buffer是主要用于面向行、变长度的文本信息类型buffer。STRING类型buffer要求必须以NULL作为结束符的。如果系统采用STRING类型，那么在配置ubbconfig文件时，必须在*MACHINE部分配置TYPE，指明buffer类型为STRING类型。在两种不同类型架构的机器进行buffer传输时候，TUXEDO对STRING类型buffer进行加码、解码过程。无论系统申请了多少长度的buffer，系统自动按着NULL所在的位置决定STRING类型的buffer长度。
（2）STRING类型buffer如何申请
char *SndBuf;
SndBuf = (char *) tpalloc(&#34;STRING&#34;,NULL,1024)
（3）STRING类型使用方法和调用方法
strcpy(SndBuf,&#34;Bea Tuxedo&#34;);
tpcall(&#34;TOUPPER&#34;,SndBuf,0,&amp;RcvBuf,&amp;len,0);
三、 CARRAY类型buffer介绍
（1）CARRAY类型buffer简介
CARRAY类型buffer是一种独立于机器的buffer类型。用户在使用时必须指定CARRAY类型数据的长度，CARRAY类型数据可以包含NULL字符。CARRAY类型数据不需要加、解码过程。CARRAY类型数据可以用来传输汉字、二进制数据、文件、图形等。CARRAY类型可以作为FML（FML32）、VIEW（VIEW32）的数据类型子项buffer。
（2）CARRAY类型buffer如何申请
tpalloc(&#34;CARRAY&#34;,NULL,1024*2)
（3）CARRAY类型使用方法和调用方法
四、 VIEW（VIEW32）类型buffer介绍
（1）VIEW类型buffer简介
Tuxedo使用VIEW类型buffer处理类似C语言的结构等数据类型复杂数据。使用VIEW类型buffer可以将各数据元素与一种结构数据类型结合，通过结构就可以访问各数据元素。VIEW类型数据即使没有没有数据也占用空间，结构发生变化，需要重新编译程序。
注明:(VIEW类型buffer是16位寻址的,VIEW32是32位寻址的.)
（2）VIEW类型buffer使用方法
使用VIEW类型数据步骤：
建立VIEW文件
设置环境变量
编译VIEW文件
在代码中包含VIEW头文件，在程序中使用VIEW结构及API函数
编译程序
运行程序
（1）建立VIEW文件
VIEW user
$ /* VIEW structure for user information */
#type cname fbname count flag size null
long count COUNT 1 - - “” 0" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/55d995b8e01b60229bbd59a75391b02e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-10-10T14:19:25+08:00" />
<meta property="article:modified_time" content="2012-10-10T14:19:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Tuxedo数据buffer基本类型介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>Tuxedo数据buffer基本类型介绍</strong></p> 
<p><strong></strong>一、 课程目标</p> 通过本课程学习，你可以掌握如下知识： 
<br> 
<div id="content" class="content mod-cs-content text-content clearfix"> 
 <ul><li>掌握tuxedo中STRING类型buffer的用途<br> </li><li>掌握tuxedo中CARRAY类型buffer的用途<br> </li><li>掌握tuxedo中FML(FML32)类型buffer的用途<br> </li><li>掌握tuxedo中VIEW(VIEW32)类型buffer的用途<br> 注:后续的课程将介绍Tuxedo新增的数据类型:EFML(Embedded Record in FML)、XML Buffer <p>二、 String类型buffer介绍<br> （1）STRING类型buffer简介<br> STRING类型buffer是主要用于面向行、变长度的文本信息类型buffer。STRING类型buffer要求必须以NULL作为结束符的。如果系统采用STRING类型，那么在配置ubbconfig文件时，必须在*MACHINE部分配置TYPE，指明buffer类型为STRING类型。在两种不同类型架构的机器进行buffer传输时候，TUXEDO对STRING类型buffer进行加码、解码过程。无论系统申请了多少长度的buffer，系统自动按着NULL所在的位置决定STRING类型的buffer长度。<br> （2）STRING类型buffer如何申请<br> char *SndBuf;<br> SndBuf = (char *) tpalloc("STRING",NULL,1024)<br> （3）STRING类型使用方法和调用方法<br> strcpy(SndBuf,"Bea Tuxedo");<br> tpcall("TOUPPER",SndBuf,0,&amp;RcvBuf,&amp;len,0);<br> <br> 三、 CARRAY类型buffer介绍<br> （1）CARRAY类型buffer简介<br> CARRAY类型buffer是一种独立于机器的buffer类型。用户在使用时必须指定CARRAY类型数据的长度，CARRAY类型数据可以包含NULL字符。CARRAY类型数据不需要加、解码过程。CARRAY类型数据可以用来传输汉字、二进制数据、文件、图形等。CARRAY类型可以作为FML（FML32）、VIEW（VIEW32）的数据类型子项buffer。<br> （2）CARRAY类型buffer如何申请<br> tpalloc("CARRAY",NULL,1024*2)<br> （3）CARRAY类型使用方法和调用方法<br> <br> 四、 VIEW（VIEW32）类型buffer介绍<br> （1）VIEW类型buffer简介<br> Tuxedo使用VIEW类型buffer处理类似C语言的结构等数据类型复杂数据。使用VIEW类型buffer可以将各数据元素与一种结构数据类型结合，通过结构就可以访问各数据元素。VIEW类型数据即使没有没有数据也占用空间，结构发生变化，需要重新编译程序。<br> 注明:(VIEW类型buffer是16位寻址的,VIEW32是32位寻址的.)<br> <br> （2）VIEW类型buffer使用方法<br> 使用VIEW类型数据步骤：<br> </p> </li><li>建立VIEW文件<br> </li><li>设置环境变量<br> </li><li>编译VIEW文件<br> </li><li>在代码中包含VIEW头文件，在程序中使用VIEW结构及API函数<br> </li><li>编译程序<br> </li><li>运行程序<br> （1）建立VIEW文件<br> <br> <p>VIEW user</p> <p>$ /* VIEW structure for user information */</p> <p>#type   cname   fbname count flag size null</p> <p>long    count COUNT 1      -    - “”    0</p> <p>float   sumfee SUMFEE   1      -    -     0.0</p> <p>string usrname USRNAME 1      -    80   “”</p> <p>short   num      NUM      1      -    -     0</p> <p>END</p> <p>  </p> <br> （2）设置环境变量<br> /* view文件存放路径，使用冒号分割(NT用分号)*/<br> VIEWDIR＝$APPDIR/inc<br> /* 用逗号分割的二进制view文件 */<br> VIEWFILES=user.V <br> export VIEWDIR VIEWFILES <p>（3）编译VIEW文件<br> </p> </li><li>使用viewc（viewc32）编译view文件<br> $viewc -n user.v<br> </li><li>view命令简介：<br> viewc [-n] [-d viewdir] viewfile [viewfile ...]<br> 或者：<br> viewc32 [-n] [-d viewdir] viewfile [viewfile ...]<br> [-d viewdir]：指定输出文件的路径（默认在当前目录下）<br> [-n]：指定在编译view结构类型数据不产生FML buffer数据结构<br> <br> （4）view编译后生成的头文件<br> <br> <p>struct user {<!-- --></p> <p>/* VIEW structure for user information */</p> <p>    long      count;</p> <p>    float     sumfee;</p> <p>    char      usrname[80];</p> <p>    short  num;</p> <p>};</p> <br> <br> （5）VIEW类型buffer的使用<br> struct user *pszUser;<br> pszUser=(struct user *)tpalloc("VIEW"," user",sizeof(user));<br> …………………<br> pszUser -&gt;count = 1680;<br> pszUser -&gt;sumfee = 198.96;<br> strcpy(pszUser-&gt;usrname,"Wsy");<br> pszUser-&gt;num = 160;<br> …………………<br> tpcall("PSVC",(char *)pszUser,0,(char **)&amp;pszUser,&amp;rcvlen,0);<br> ………………… <p>五、 FML（FML32）类型buffer介绍<br> （1）VIEW类型buffer简介<br> FML类型buffer允许存取多个命名的字段。例如：（NAME: "BEA",ADDRESS "China Beijing",PHONE "010-85281188"）。每一个命名的字段可以在buffer中存放零个或更多个（occurrences）的值.<br> 注明:(FML类型buffer是16位寻址的,FML32是32位寻址的.)<br> </p> <br> （2）FML支持的数据类型：<br> </li><li>Short<br> </li><li>Char<br> </li><li>Long<br> </li><li>Float<br> </li><li>Double<br> </li><li>String<br> </li><li>Carray<br> （3）FML类型buffer使用方法<br> 使用FML类型数据步骤：<br> </li><li>建立FML文件<br> </li><li>设置环境变量<br> </li><li>编译FML文件<br> </li><li>在代码中包含FML头文件，在程序中使用FML API函数<br> </li><li>编译程序<br> </li><li>运行程序<br> （1）建立FML Field Table文件<br> <p>*base 1000</p> <p># name   number type flags comments</p> <p>COUNT    1        long    -   -</p> <p>SUMFEE   2        float   - -</p> <p>USRNAME 3        string -   -</p> <p>NUM       4        short  -   -</p> <br> （2）设置环境变量<br> set FLDTBLDIR32="c:\tuxedo\wsy"<br> set FIELDTBLS32=user.fld<br> 其中：<br> FLDTBLDIR（FLDTBLDIR32）：指明Field Table文件的名字，多个用逗号分割<br> FIELDTBLS （FIELDTBLS32）：Filed Table文件的所在路径，多个用冒号分割，在WinNT系统中使用分号分割.<br> （3）编译FML Field Table文件<br> </li><li>使用mkfldhdr（mkfldhdr32）编译Field Table文件<br> $mkfldhdr32 user.fld<br> （4）FML Field Table编译后生成的头文件<br> <br> <p>/*  fname   fldid            */</p> <p>/*  -----   -----            */</p> <p>#define COUNT   ((FLDID32)33555433) /* number: 1001 type: long */</p> <p>#define SUMFEE  ((FLDID32)100664298)/* number: 1002 type: float */</p> <p>#define USRNAME ((FLDID32)167773163)/* number: 1003 type: string */</p> <p>#define NUM ((FLDID32)1004) /* number: 1004 type: short */</p> <br> <br> （5）FML类型buffer的使用<br> FBFR32 *SndBuf;<br> SndBuf = (FBFR32 *)tpalloc("FML32",NULL,1024);<br> …………………<br> lCount = 1680;<br> Fchg32(SndBuf, COUNT,0,(char *)&amp;lCount ,0);<br> fSumFee = 198.96;<br> Fchg32(SndBuf, SUMFEE, (char *)&amp;fSumFee,0);<br> Strcpy(sUsrName , "wsy");<br> Fchg32(SndBuf, USRNAME, (char *)sUsrName,0);<br> iNum = 160;<br> Fchg32(SndBuf, SUMFEE, (char *)&amp;iNum,0);<br> …………………<br> tpcall("PSVC",(char *) SndBuf,0,(char **)&amp; SndBuf,&amp;rcvlen,0);<br> Fget32(SndBuf, COUNT,0, (char *)&amp;lCount ,0);<br> Fget32(SndBuf, USRNAME,0, (char *)sUsrName,0);<br> …………………<br> 注:FML和VIEW类型buffer的API函数在后续的文章有详细的介绍和代码分析.</li></ul></div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c318a8f8e4ba0e5baaa876027a81ea62/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《flex与bison》读书笔记--ch01 flex和bison简介（上）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e114fa2245d341938bba1bc704578f91/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数组 按行，列存储</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>