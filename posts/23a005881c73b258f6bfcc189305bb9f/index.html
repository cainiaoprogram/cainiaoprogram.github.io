<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java常量池详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java常量池详解" />
<meta property="og:description" content="目录
1. 常量池
1.1 Class 常量池
1.2 运行时常量池 2. 字符串常量池
2.1 字符串常量池设计思想
2.2 三种字符串的操作（JDK1.7及以上版本）
2.3 字符串常量池位置
2.4 字符串常量池设计原理
2.5 String常量池分析示例
3. 八种基本类型的包装类和对象池
1. 常量池 1.1 Class 常量池 Class常量池可以理解为是Class文件中的资源仓库。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译期生成的各种字面量(Literal)和符号引用(Symbolic References)。
下图中字节码指令文件中的constant pool就是class 常量池，主要存放字面量和符号引用。
字面量
字面量就是指由字母、数字等构成的字符串或者数值常量。
字面量只可以右值出现，所谓右值是指等号右边的值
如：int a=1 这里的a为左值，1为右值。在这个例子中1就是字面量。
符号引用
符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量：
类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 package com.test.jvm; public class ConstantPoolTest { public static void main(String[] args) { Math math = new Math(); int compute = math.compute(); System.out.println(compute); int i =1; } } 上面的i、ompute、math就是字段名称，就是一种符号引用，com." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/23a005881c73b258f6bfcc189305bb9f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-28T01:12:24+08:00" />
<meta property="article:modified_time" content="2023-09-28T01:12:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java常量池详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E5%B8%B8%E9%87%8F%E6%B1%A0-toc" style="margin-left:0px;"><a href="#1.%20%E5%B8%B8%E9%87%8F%E6%B1%A0" rel="nofollow">1. 常量池</a></p> 
<p id="1.1%20Class%20%E5%B8%B8%E9%87%8F%E6%B1%A0-toc" style="margin-left:40px;"><a href="#1.1%20Class%20%E5%B8%B8%E9%87%8F%E6%B1%A0" rel="nofollow">1.1 Class 常量池</a></p> 
<p id="1.2%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%C2%A0-toc" style="margin-left:40px;"><a href="#1.2%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%C2%A0" rel="nofollow">1.2 运行时常量池 </a></p> 
<p id="2.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0-toc" style="margin-left:0px;"><a href="#2.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0" rel="nofollow">2. 字符串常量池</a></p> 
<p id="2.1%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-toc" style="margin-left:40px;"><a href="#2.1%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3" rel="nofollow">2.1 字符串常量池设计思想</a></p> 
<p id="2.2%20%E4%B8%89%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88JDK1.7%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.2%20%E4%B8%89%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88JDK1.7%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%EF%BC%89" rel="nofollow">2.2 三种字符串的操作（JDK1.7及以上版本）</a></p> 
<p id="2.3%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BD%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#2.3%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BD%8D%E7%BD%AE" rel="nofollow">2.3 字符串常量池位置</a></p> 
<p id="2.4%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#2.4%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86" rel="nofollow">2.4 字符串常量池设计原理</a></p> 
<p id="2.5%20String%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#2.5%20String%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B" rel="nofollow">2.5 String常量池分析示例</a></p> 
<p id="3.%20%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%B1%A0-toc" style="margin-left:0px;"><a href="#3.%20%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%B1%A0" rel="nofollow">3. 八种基本类型的包装类和对象池</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>1. 常量池</h2> 
<h3 id="1.1%20Class%20%E5%B8%B8%E9%87%8F%E6%B1%A0">1.1 Class 常量池</h3> 
<p><strong>        Class常量池可以理解为是Class文件中的资源仓库</strong>。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译期生成的各种字面量(Literal)和符号引用(Symbolic References)。</p> 
<p>下图中字节码指令文件中的<strong>constant pool就是class 常量池，主要存放字面量和符号引用</strong>。</p> 
<p><img alt="" height="968" src="https://images2.imgbox.com/20/2a/yDQWYjCh_o.png" width="1200"></p> 
<blockquote> 
 <p><strong>字面量</strong></p> 
 <p>字面量<strong>就是指由字母、数字等构成的字符串或者数值常量。</strong></p> 
 <p>字面量<strong>只可以右值出现，所谓右值是指等号右边的值</strong></p> 
 <p>如：int a=1 这里的a为左值，1为右值。在这个例子中1就是字面量。</p> 
</blockquote> 
<blockquote> 
 <p><strong>符号引用</strong></p> 
 <p>符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量：</p> 
 <ul><li>类和接口的全限定名 </li><li>字段的名称和描述符 </li><li>方法的名称和描述符</li></ul> 
 <pre><code>package com.test.jvm;


public class ConstantPoolTest {

    public static void main(String[] args) {
        Math math = new Math();
        int compute = math.compute();
        System.out.println(compute);
        int i =1;
        
    }
}</code></pre> 
 <p>上面的i、ompute、math就是字段名称，就是一种符号引用，com.test.jvm是类的全限定名，main是方法名称，()是一种UTF8格式的描述符，这些都是符号引用。</p> 
</blockquote> 
<h3 id="1.2%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%C2%A0">1.2 运行时常量池 </h3> 
<p>        Class 常量池是.java文件编译后的静态信息，当这些信息到<strong>运行时被加载到内存后，这些符号才有对应的内存地址信息，这些常量池一旦<span style="color:#fe2c24;">被装入内存</span>就变成运行时常量池</strong>，对应的符号引用在程序加载或运行时会被转变为被加载到内存区域的代码的直接引用，也就是我们说的动态链接了。例如，compute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的地址，主要通过对象头里的类型指针去转换直接引用。</p> 
<h2 id="2.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0">2. 字符串常量池</h2> 
<h3 id="2.1%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3">2.1 字符串常量池设计思想</h3> 
<ol><li>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能。</li><li>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。</li></ol> 
<ul><li>为字符串开辟一个字符串常量池，类似于缓存区。</li><li>创建字符串常量时，首先查询字符串常量池是否存在该字符串。</li><li>存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中。</li><li><img alt="" height="504" src="https://images2.imgbox.com/26/c7/pwfCNqfv_o.png" width="620"></li></ul> 
<h3 id="2.2%20%E4%B8%89%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88JDK1.7%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%EF%BC%89">2.2 三种字符串的操作（JDK1.7及以上版本）</h3> 
<blockquote> 
 <p><strong>直接赋值字符串</strong></p> 
 <pre><code>String s = "zhnangSan"; // s指向常量池中的引用</code></pre> 
 <p>这种方式创建的字符串对象，只会在常量池中。</p> 
 <p>因为有"zhnangSan"这个字面量，创建对象s的时候，JVM会先去常量池中通过 equals(key) 方法，判断是否有相同的对象</p> 
 <p>如果有，则直接返回该对象在常量池中的引用；</p> 
 <p>如果没有，则会在常量池中创建一个新对象，再返回引用。</p> 
</blockquote> 
<blockquote> 
 <p><strong>new String();</strong></p> 
 <pre><code>String s1 = new String("zhangsan"); // s1指向内存中的对象引用</code></pre> 
 <p>这种方式会保证字符串常量池和堆中都有这个对象，没有就创建，最后返回堆内存中的对象引用。</p> 
 <p>步骤大致如下：</p> 
 <p>因为有"zhangsan"这个字面量，所以会先检查字符串常量池中是否存在字符串"zhangsan"</p> 
 <p>不存在，先在字符串常量池里创建一个字符串对象；再去内存中创建一个字符串对象"zhangsan"；</p> 
 <p>存在的话，就直接去堆内存中创建一个字符串对象"zhangsan"；</p> 
 <p>最后，将内存中的引用返回。</p> 
</blockquote> 
<blockquote> 
 <p><strong>intern方法</strong></p> 
 <pre><code>String s1 = new String("zhangsan"); 
String s2 = s1.intern(); 
System.out.println(s1 == s2); //false</code></pre> 
 <p>String中的intern方法是一个 native 的方法，当调用 intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(oject)方法确定），则返回池中的字符串。否则<strong>，将intern返回的引用指向当前字符串 s1(jdk1.6版本需要将 s1 复制到字符串常量池里)。</strong></p> 
</blockquote> 
<h3 id="2.3%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BD%8D%E7%BD%AE">2.3 字符串常量池位置</h3> 
<ul><li><strong>Jdk1.6及之前：</strong> 有永久代, 运行时常量池<strong>在永久代</strong>，<strong>运行时常量池包含字符串常量池</strong>。</li><li><strong>Jdk1.7：</strong>有永久代，但已经逐步“去永久代”，字符串常量池从永久代里的运行时常量池分离到<strong>堆里</strong>。</li><li><strong>Jdk1.8及之后：</strong> 无永久代，<strong>运行时常量池在元空间</strong>，<strong>字符串常量池里依然在堆里</strong>。</li></ul> 
<h3 id="2.4%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86">2.4 字符串常量池设计原理</h3> 
<p>       <strong> 字符串常量池底层是hotspot的C++实现的，底层类似一个 HashTable， 保存的本质上是字符串对象的引用。</strong></p> 
<blockquote> 
 <strong>示例：</strong> 
 <pre><code>String s1 = new String("he") + new String("llo");
String s2 = s1.intern();
 
System.out.println(s1 == s2);
// 在 JDK 1.6 下输出是 false，创建了 6 个对象
// 在 JDK 1.7 及以上的版本输出是 true，创建了 5 个对象
// 当然我们这里没有考虑GC，但这些对象确实存在或存在过</code></pre> 
</blockquote> 
<p>上面示例中为什么在不同版本下同样的代码会有不一样的结果呢？主要还是字符串池从永久代中脱离、移入堆区的原因， intern() 方法也相应发生了变化，接下来我们从jdk不同版本JVM的运行时数据区来分析下一。</p> 
<p>1、在 JDK 1.6 中，调用 intern() 首先会在字符串池中寻找 equal() 相等的字符串，假如字符串存在就返回该字符串在字符串池中的引用；假如字符串不存在，虚拟机会重新在永久代上创建一个实例，将 StringTable 的一个表项指向这个新创建的实例。</p> 
<p><img alt="" height="773" src="https://images2.imgbox.com/95/b4/0DGNYK4N_o.png" width="1200"></p> 
<p>2、在 JDK 1.7 (及以上版本)中，由于字符串池不在永久代了，intern() 做了一些修改，更方便地利用堆中的对象。字符串存在时和 JDK 1.6一样，但是<strong>字符串不存在时不再需要重新创建实例，可以直接指向堆上的实例。</strong></p> 
<p><img alt="" height="801" src="https://images2.imgbox.com/54/f4/QceFUMlm_o.png" width="1200"></p> 
<p></p> 
<h3 id="2.5%20String%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B">2.5 String常量池分析示例</h3> 
<p><span style="color:#fe2c24;"><strong>注意：以下示例都是基于jdk1.7及以上版本讨论的</strong></span></p> 
<blockquote> 
 <p>示例1:</p> 
 <pre><code>String s0="zhangsan";
String s1="zhangsan";
String s2="zhang" + "san";
System.out.println( s0==s1 ); //true
System.out.println( s0==s2 ); //true</code></pre> 
 <p>分析：因为例子中的 s0和s1中的”zhangsan”都是字符串常量，它们在编译期就被确定了，所以s0==s1为true；而”zhang”和”san”也都是字符串常量，当一个字 符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被优化为一个字符串常量"zhangsan"，所以s2也是常量池中” zhangsan”的一个引用。所以我们得出s0==s1==s2；</p> 
</blockquote> 
<blockquote> 
 <p>示例2：</p> 
 <pre><code>String s0="zhangsan"; 
String s1=new String("zhangsan");
 String s2="zhang" + new String("san"); 
System.out.println( s0==s1 );　　// false 
System.out.println( s0==s2 )；　 // false 
System.out.println( s1==s2 );　　// false</code></pre> 
 <p>分析：用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。</p> 
 <p>s0还是常量池 中"zhangsan”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”zhangsan”的引用，s2因为有后半部分 new String(”san”)所以也无法在编译期确定，所以也是一个新创建对象”zhangsan”的引用;明白了这些也就知道为何得出此结果了。</p> 
</blockquote> 
<blockquote> 
 <p>示例3：</p> 
 <pre><code> String a = "a1";
  String b = "a" + 1;
  System.out.println(a == b); // true 
  
  String a = "atrue";
  String b = "a" + "true";
  System.out.println(a == b); // true 
  
  String a = "a3.4";
  String b = "a" + 3.4;
  System.out.println(a == b); // true</code></pre> 
 <p>分析：JVM对于字符串常量的"+"号连接，将在程序编译期，JVM就将常量字符串的"+"连接优化为连接后的值，拿"a" + 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为true。</p> 
</blockquote> 
<blockquote> 
 <p>示例4：</p> 
 <pre><code>String a = "ab";
String bb = "b";
String b = "a" + bb;

System.out.println(a == b); // false</code></pre> 
 <p>分析：JVM对于字符串引用，由于在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即"a" + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为false。</p> 
</blockquote> 
<blockquote> 
 <p>示例5：</p> 
 <pre><code>String a = "ab";
final String bb = "b";
String b = "a" + bb;

System.out.println(a == b); // true</code></pre> 
 <p>分析：和示例4中唯一不同的是bb字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的"a" + bb和"a" + "b"效果是一样的。故上面程序的结果为true。</p> 
</blockquote> 
<blockquote> 
 <p>示例6：</p> 
 <pre><code>String a = "ab";
final String bb = getBB();
String b = "a" + bb;

System.out.println(a == b); // false

private static String getBB() 
{  
    return "b";  
 }</code></pre> 
 <p>分析：JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和"a"来动态连接并分配地址为b，故上面 程序的结果为false。</p> 
</blockquote> 
<blockquote> 
 <p>示例7：</p> 
 <pre><code>//字符串常量池："计算机"和"技术"     堆内存：str1引用的对象"计算机技术"  
//堆内存中还有个StringBuilder的对象，但是会被gc回收，StringBuilder的toString方法会new String()，这个String才是真正返回的对象引用
String str2 = new StringBuilder("计算机").append("技术").toString();   //没有出现"计算机技术"字面量，所以不会在常量池里生成"计算机技术"对象
System.out.println(str2 == str2.intern());  //true
//"计算机技术" 在池中没有，但是在heap中存在，则intern时，会直接返回该heap中的引用

//字符串常量池："ja"和"va"     堆内存：str1引用的对象"java"  
//堆内存中还有个StringBuilder的对象，但是会被gc回收，StringBuilder的toString方法会new String()，这个String才是真正返回的对象引用
String str1 = new StringBuilder("ja").append("va").toString();    //没有出现"java"字面量，所以不会在常量池里生成"java"对象
System.out.println(str1 == str1.intern());  //false
//java是关键字，在JVM初始化的相关类里肯定早就放进字符串常量池了

String s1=new String("test");  
System.out.println(s1==s1.intern());   //false
//"test"作为字面量，放入了池中，而new时s1指向的是heap中新生成的string对象，s1.intern()指向的是"test"字面量之前在池中生成的字符串对象

String s2=new StringBuilder("abc").toString();
System.out.println(s2==s2.intern());  //false
//同上</code></pre> 
</blockquote> 
<h2 id="3.%20%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%B1%A0">3. 八种基本类型的包装类和对象池</h2> 
<p>        java中基本类型的包装类的大部分都实现了常量池技术(严格来说应该叫对象池，在堆上)，<strong>这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现</strong>。另外<strong>Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池</strong>，也即对象不负责创建和管理大于127的这些类的对象。因为一般这种比较小的数用到的概率相对较大。</p> 
<blockquote> 
 <p>示例：</p> 
 <pre><code>public class Test {

    public static void main(String[] args) {
        //5种整形的包装类Byte,Short,Integer,Long,Character的对象，  
        //在值小于127时可以使用对象池  
        Integer i1 = 127;  //这种调用底层实际是执行的Integer.valueOf(127)，里面用到了IntegerCache对象池
        Integer i2 = 127;
        System.out.println(i1 == i2);//输出true  

        //值大于127时，不会从对象池中取对象  
        Integer i3 = 128;
        Integer i4 = 128;
        System.out.println(i3 == i4);//输出false  
        
        //用new关键词新生成对象不会使用对象池
        Integer i5 = new Integer(127);  
        Integer i6 = new Integer(127);
        System.out.println(i5 == i6);//输出false 

        //Boolean类也实现了对象池技术  
        Boolean bool1 = true;
        Boolean bool2 = true;
        System.out.println(bool1 == bool2);//输出true  

        //浮点类型的包装类没有实现对象池技术  
        Double d1 = 1.0;
        Double d2 = 1.0;
        System.out.println(d1 == d2);//输出false  
    }
} </code></pre> 
 <p></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c9e2e69ad1a897e54e720a4742e512b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jsp 九大内置对象详解以及示例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/054adf8b5f7bf58edf0ed7ec5852a56c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">国内免费ChatGPT&#43;AI绘画创作网站工具&#43;支持GPT-4&#43;Midjourney绘画</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>