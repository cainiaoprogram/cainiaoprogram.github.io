<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>注解式参数校验@Valid，拒绝if-else炼狱 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="注解式参数校验@Valid，拒绝if-else炼狱" />
<meta property="og:description" content="前言 在软件开发中，与客户进行数据的交互是比较频繁的数据采集方式，而为了确保数据的正确落库，数据校验的部分必不可少。参数校验具体指的是对输入数据的大小、类型、正则匹配等对数据本身属性的校验，这一块的校验通常是在前端进行第一轮校验，确保参数具备一定逻辑正确性才将其打包至后端处理，而为了进一步增强安全性，也同样需要在后端板块进行二次校验。而对于此类校验，最常见也是最臃肿的处理方案就是if-else炼狱，如果说参数个数较少，那么无可厚非，但如果包含了七八个参数，那么这就很拉跨了，下面介绍一种基于注解的校验方案，进一步优化校验参数代码的可读性。
效果演示 本例子基于通过在实体类映射接收请求参数的MVC接口，对实体类中需要对属性进行如下验证：
name - 用户姓名，不能为空；
age - 年龄，大于0小于20；
phone - 手机号，满足手机号格式；
实体类代码 @Data public class TestPojo { @NotBlank(message = &#34;不满足时抛出的自定义异常回馈信息&#34;) private String name; @Min(value = 0, message = &#34;不满足时抛出的自定义异常回馈信息&#34;) @Max(value = 20, message = &#34;不满足时抛出的自定义异常回馈信息&#34;) private Integer age; @Pattern(regexp = &#34;^((13[0-9])|(15[^4])|(18[0-9])|(17[0-9])|(147))\d{8}$&#34;, message = &#34;不满足时抛出的自定义异常回馈信息&#34;) private String phone; } 业务接口 @PostMapping(&#34;/test&#34;) public ResultVO test(@Valid @RequestBody TestPojo testPojo) { // 直接写业务代码，无需编写if-else校验.... return ResultVO.ok(&#34;响应数据&#34;); } 结果VO类 @Data public class ResultVO&lt;T&gt; implements Serializable { private int code; private boolean success; private T data; private String msg; ​ private ResultVO(int code, T data, String msg) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d4a1fe5ad60a6195993df5540e4acacb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T17:37:01+08:00" />
<meta property="article:modified_time" content="2024-01-08T17:37:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">注解式参数校验@Valid，拒绝if-else炼狱</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>        在软件开发中，与客户进行数据的交互是比较频繁的数据采集方式，而为了确保数据的正确落库，数据校验的部分必不可少。参数校验具体指的是对输入数据的大小、类型、正则匹配等对数据本身属性的校验，这一块的校验通常是在前端进行第一轮校验，确保参数具备一定逻辑正确性才将其打包至后端处理，而为了进一步增强安全性，也同样需要在后端板块进行二次校验。而对于此类校验，最常见也是最臃肿的处理方案就是<strong>if-else炼狱</strong>，如果说参数个数较少，那么无可厚非，但如果包含了七八个参数，那么这就很拉跨了，下面介绍一种基于注解的校验方案，进一步优化校验参数代码的可读性。</p> 
<hr> 
<h3>效果演示</h3> 
<p>本例子基于通过在实体类映射接收请求参数的MVC接口，对实体类中需要对属性进行如下验证：</p> 
<ul><li> <p><code>name</code> - 用户姓名，不能为空；</p> </li><li> <p><code>age</code> - 年龄，大于0小于20；</p> </li><li> <p><code>phone</code> - 手机号，满足手机号格式；</p> </li></ul> 
<h4>实体类代码</h4> 
<pre><code class="language-java"> @Data
 public class TestPojo {
   @NotBlank(message = "不满足时抛出的自定义异常回馈信息")
   private String name;
   
   @Min(value = 0, message = "不满足时抛出的自定义异常回馈信息")
   @Max(value = 20, message = "不满足时抛出的自定义异常回馈信息")
   private Integer age;
   
   @Pattern(regexp = "^((13[0-9])|(15[^4])|(18[0-9])|(17[0-9])|(147))\d{8}$", message = "不满足时抛出的自定义异常回馈信息")
   private String phone;
 }</code></pre> 
<h4>业务接口</h4> 
<pre><code class="language-java">@PostMapping("/test")
public ResultVO test(@Valid @RequestBody TestPojo testPojo) {
     // 直接写业务代码，无需编写if-else校验....
    
     return ResultVO.ok("响应数据");
 }</code></pre> 
<h4>结果VO类</h4> 
<pre><code class="language-java">@Data
public class ResultVO&lt;T&gt; implements Serializable {
    private int code;
    private boolean success;
    private T data;
    private String msg;
​
    private ResultVO(int code, T data, String msg) {
        this.code = code;
        this.data = data;
        this.msg = msg;
        this.success = code == 200;
    }
​
    public static &lt;T&gt; ResultVO&lt;T&gt; ok(T data) {
        return new ResultVO&lt;&gt;(200, data, null);
    }
​
    public static &lt;T&gt; ResultVO&lt;T&gt; error(String msg) {
        return new ResultVO&lt;&gt;(500, null, msg);
    }
}</code></pre> 
<h4>全局异常处理类</h4> 
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {
    
    /*  
     *  这里的BindException不是自定义的，是该参数校验框架自带的
     *  当设置的参数规则不满足，就会抛出该类型的异常，并且把不满足的哪个校验参数自定义的异常信息封装到该对象中
     */
    @ExceptionHandler(BindException.class)  
    public ResultVO handleError(BindException e) {
        BindingResult bindingResult = e.getBindingResult();
        return R.error(bindingResult.getFieldError().getDefaultMessage());
    }
}</code></pre> 
<blockquote> 
 <p><strong>        通过以上代码，就可以实现对接收的请求数据的参数校验，并且当校验失败就会抛出指定异常被异常处理类进行捕捉处理，返回自定义的不满足参数所对应的自定义提示信息</strong></p> 
</blockquote> 
<hr> 
<h3>快速使用</h3> 
<h4>引入依赖</h4> 
<pre><code class="language-XML">&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
 &lt;/dependency&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
 &lt;/dependency&gt;</code></pre> 
<h4>编写校验实体类</h4> 
<p>        其实这一块和上方"结果VO类"的演示中可以了解到使用的方式，咱主要要知道它有哪些常用的校验注解可以使用就好</p> 
<table><thead><tr><th style="text-align:center;">常用注解</th><th style="text-align:center;">作用解释</th></tr></thead><tbody><tr><td style="text-align:center;">@NotNull</td><td style="text-align:center;">值不能为null</td></tr><tr><td style="text-align:center;">@NotEmpty</td><td style="text-align:center;">字符串、集合或数组的值不能为空，即长度大于0</td></tr><tr><td style="text-align:center;">@NotBlank</td><td style="text-align:center;">字符串的值不能为空白，即不能只包含空格</td></tr><tr><td style="text-align:center;">@Size</td><td style="text-align:center;">字符串、集合或数组的大小是否在指定范围内</td></tr><tr><td style="text-align:center;">@Min</td><td style="text-align:center;">数值的最小值</td></tr><tr><td style="text-align:center;">@Max</td><td style="text-align:center;">数值的最大值</td></tr><tr><td style="text-align:center;">@DecimalMin</td><td style="text-align:center;">数值的最小值，可以包含小数</td></tr><tr><td style="text-align:center;">@DecimalMax</td><td style="text-align:center;">数值的最大值，可以包含小数</td></tr><tr><td style="text-align:center;">@Pattern</td><td style="text-align:center;">字符串是否匹配指定的正则表达式</td></tr></tbody></table> 
<p>还有许多有关的校验可以自行查询，这里不作过多赘述</p> 
<h4>校验失败异常捕获处理</h4> 
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {
    
    /*  
     *  这里的BindException不是自定义的，是该参数校验框架自带的
     *  当设置的参数规则不满足，就会抛出该类型的异常，并且把不满足的哪个校验参数自定义的异常信息封装到该对象中
     */
    @ExceptionHandler(BindException.class)  
    public ResultVO handleError(BindException e) {
        BindingResult bindingResult = e.getBindingResult();
        String 自定义的不满足参数校验结果信息 = bindingResult.getFieldError().getDefaultMessage();
    }
}</code></pre> 
<h4>启用校验</h4> 
<p>其实就是在接收实体类上加一个@Valid注解就可以启用实体类中校验逻辑</p> 
<pre><code class="language-java">@PostMapping("/test")
public void test(@Valid @RequestBody TestPojo testPojo) {
     // 直接写业务代码，无需编写if-else校验....
 }</code></pre> 
<blockquote> 
 <p>        也许会有疑惑，一个实体类我不一定要用来校验数据呀，这样子设置后会不会以后用这个实体类都要进行参数校验了？并不会，不想校验就不要加@Valid注解就完事了嘛</p> 
</blockquote> 
<hr> 
<h3>总结</h3> 
<p>        通过以上的方案，我们可以较为简洁实现简单的参数校验，为shi山的削减贡献了一份力量，当然，我们会发现通过这种方案，我们能够校验的方式实际上是比较单薄的，往往我们需要针对项目业务需求对参数进行一些自定义的校验逻辑，那么这点可以参考我写的另一篇文章：<a href="https://blog.csdn.net/weixin_73077810/article/details/130854283" title="基于 AOP + 自定义注解 的校验业务讲解">基于 AOP + 自定义注解 的校验业务讲解</a>，希望本文对大家有所帮助。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/78d92a7d749790be07380912f55d1b0f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">后端程序员开发win小工具(未完待续)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/071e63945b583adc4ca888f61b79c3bd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue3用户权限管理（路由控制等）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>