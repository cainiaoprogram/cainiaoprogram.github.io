<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GN介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GN介绍" />
<meta property="og:description" content="GN INTRODUCTION What’s GN 1、GN Generate Ninja，是Google为Ninja专门开发的上层编译框架，可以生成Ninja可以识别的输入文件。GN由c&#43;&#43;编译，相比于基于python的gyp，速度快接近20倍。
2、GN Language 由于GN和GYP都可以生成Ninja，所以我们可以稍稍将GN和GYP进行对比。风格方面，GYP有Json格式的文件组成，可以将所有的GYP文件和GYPI文件看成一个大的Json格式文件。而GN是函数式风格，最后的依赖关系可以由栈式函数调用来组成。
变量 和大多数脚本语言一样,GN的变量种类不多,包含字符串(string)，整形(int64),布尔(Boolean),列表(List)，字典(dictionary)。使用方式也和脚本语言一样，不需要声明变量类型，直接对变量赋值即可，例如 a=”hello world”。
函数 和GYP是基于JSON格式的组织方式不同，GN使用函数来组织依赖。
例如：
a：简单函数调用：
print(&#34;hello, world&#34;) b：复试函数调用
static_library(&#34;mylibrary&#34;) { sources = [ &#34;a.cc&#34; ] } 这种调用乍一看以为是函数定义，其实是一种函数调用，可以将函数体的返回值理解为函数的一个参数，上述例子的含义就是使用源文件a.cc编译出静态库mylibrary
目标 和Makefile中的目标类似，GN中的目标通常也就是一种可执行文件或者依赖库。一个目标可以依赖另一个目标，从而形成依赖树。
action: Run a script to generate a file. action_foreach: Run a script once for each source file. bundle_data: Declare data to go into a Mac/iOS bundle. create_bundle: Creates a Mac/iOS bundle. executable: Generates an executable file. group: A virtual dependency node that refers to one or more other targets." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/63ceae0ad9f816792141c0818473874b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-17T21:22:12+08:00" />
<meta property="article:modified_time" content="2019-07-17T21:22:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GN介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0cm;"><span style="color:#2f5496;">GN INTRODUCTION</span></h2> 
<ul><li> <h3><span style="color:#c45911;">What’s GN</span></h3> </li></ul> 
<h4><span style="color:#a8d08d;">    1、GN</span></h4> 
<p style="margin-left:0cm;">Generate Ninja，是Google为Ninja专门开发的上层编译框架，可以生成Ninja可以识别的输入文件。GN由c++编译，相比于基于python的gyp，速度快接近20倍。</p> 
<h4 style="text-indent:0px;"><span style="color:#a8d08d;">    2、GN Language</span></h4> 
<p style="margin-left:0cm;">由于GN和GYP都可以生成Ninja，所以我们可以稍稍将GN和GYP进行对比。风格方面，GYP有Json格式的文件组成，可以将所有的GYP文件和GYPI文件看成一个大的Json格式文件。而GN是函数式风格，最后的依赖关系可以由栈式函数调用来组成。</p> 
<ul><li>变量</li></ul> 
<p style="margin-left:0cm;">和大多数脚本语言一样,GN的变量种类不多,包含字符串(string)，整形(int64),布尔(Boolean),列表(List)，字典(dictionary)。使用方式也和脚本语言一样，不需要声明变量类型，直接对变量赋值即可，例如 a=”hello world”。</p> 
<ul><li>函数</li></ul> 
<p style="margin-left:0cm;">和GYP是基于JSON格式的组织方式不同，GN使用函数来组织依赖。</p> 
<p style="margin-left:0cm;">例如：</p> 
<p>    a：简单函数调用：</p> 
<pre class="has"><code>print("hello, world")</code></pre> 
<p>    b：复试函数调用</p> 
<pre class="has"><code>static_library("mylibrary") {

  sources = [ "a.cc" ]

}</code></pre> 
<p style="margin-left:0cm;">这种调用乍一看以为是函数定义，其实是一种函数调用，可以将函数体的返回值理解为函数的一个参数，上述例子的含义就是使用源文件a.cc编译出静态库mylibrary</p> 
<ul><li>目标</li></ul> 
<p style="margin-left:0cm;">和Makefile中的目标类似，GN中的目标通常也就是一种可执行文件或者依赖库。一个目标可以依赖另一个目标，从而形成依赖树。</p> 
<pre class="has"><code>action: Run a script to generate a file.

action_foreach: Run a script once for each source file.

bundle_data: Declare data to go into a Mac/iOS bundle.

create_bundle: Creates a Mac/iOS bundle.

executable: Generates an executable file.

group: A virtual dependency node that refers to one or more other targets.

shared_library: A .dll or .so.

loadable_module: A .dll or .so loadable only at runtime.

source_set: A lightweight virtual static library (usually preferrable over a real static library since it will build faster).

static_library: A .lib or .a file (normally you'll want a source_set instead).</code></pre> 
<ul><li> <h3><span style="color:#c45911;">Example</span></h3> </li></ul> 
<p style="margin-left:0cm;">要编译成最终可以执行文件，需要三个部分构件系统，1、GN,2、Ninja,3、GCC。GN作为编译逻辑部分，和GYP起到相同的作用，通常和实际工程的配置息息相关。Ninja作为构建中间部分，他用最简单最快速的方式将编译文件编译参数传递给编译系统。GCC作为编译部分，通常随编译系统而变化。</p> 
<p style="margin-left:0cm;">1,gn_test/mian/main.cc:</p> 
<pre class="has"><code>
#include&lt;stdio.h&gt;

#include"lib2/libtest1.h"



int main(void)

{

  printf("hello world\n");

  func1();

}

</code></pre> 
<p style="margin-left:0cm;">2,gn_test/main/BUILD.gn</p> 
<pre class="has"><code>executable("main"){

  sources = [

    "main.c",

  ]

  deps = [

    "//lib2",

  ] 

}

</code></pre> 
<p style="margin-left:0cm;"><br>  </p> 
<p style="margin-left:0cm;">3, gn_test/lib2/ libtest1.c</p> 
<pre class="has"><code>
#include"libtest1.h"

#include&lt;stdio.h&gt;



void func1()

{

         printf("func1\n");

}

</code></pre> 
<p style="margin-left:0cm;">4, gn_test/lib2/ libtest1.h</p> 
<p style="margin-left:0cm;"> </p> 
<pre class="has"><code>extern void func1();</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">5, gn_test/lib2/ BUILD.gn</p> 
<pre class="has"><code>source_set("lib2"){

  sources = [

    "libtest1.c",

    "libtest1.h",

  ]

  public = [

    "libtest1.h",

  ]

}

</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">6,gn_test/.gn</p> 
<p style="margin-left:0cm;"> </p> 
<pre class="has"><code>buildconfig = "//build/BUILDCONFIG.gn"

</code></pre> 
<p style="margin-left:0cm;">7, gn_test/ BUILD.gn</p> 
<pre class="has"><code>group("executable"){

  deps = [ "//main" ]

}</code></pre> 
<p style="margin-left:0cm;">8, gn_test/build/BUILDCONFIG.gn</p> 
<pre class="has"><code>set_default_toolchain("//build/toolchains:gcc")



cflags_cc = [ "-std=c++14" ]

include_dirs = [ "//" ]</code></pre> 
<p style="margin-left:0cm;">9, gn_test/build/ toolchains/BUILD.gn</p> 
<p style="margin-left:0cm;">//参考官网</p> 
<pre class="has"><code>toolchain("gcc") {

  tool("cc") {

    depfile = "{<!-- -->{output}}.d"

    command = "gcc -MMD -MF $depfile {<!-- -->{defines}} {<!-- -->{include_dirs}} {<!-- -->{cflags}} {<!-- -->{cflags_c}} -c {<!-- -->{source}} -o {<!-- -->{output}}"

    depsformat = "gcc"

    description = "CC {<!-- -->{output}}"

    outputs = [

      "{<!-- -->{source_out_dir}}/{<!-- -->{target_output_name}}.{<!-- -->{source_name_part}}.o",

    ]

  }

  tool("cxx") {

    depfile = "{<!-- -->{output}}.d"

    command = "g++ -MMD -MF $depfile {<!-- -->{defines}} {<!-- -->{include_dirs}} {<!-- -->{cflags}} {<!-- -->{cflags_cc}} -c {<!-- -->{source}} -o {<!-- -->{output}}"

    depsformat = "gcc"

    description = "CXX {<!-- -->{output}}"

    outputs = [

      "{<!-- -->{source_out_dir}}/{<!-- -->{target_output_name}}.{<!-- -->{source_name_part}}.o",

    ]

  }

  tool("alink") {

    rspfile = "{<!-- -->{output}}.rsp"

    command = "rm -f {<!-- -->{output}} &amp;&amp; ar rcs {<!-- -->{output}} @$rspfile"

    description = "AR {<!-- -->{target_output_name}}{<!-- -->{output_extension}}"

    rspfile_content = "{<!-- -->{inputs}}"

    outputs = [

      "{<!-- -->{target_out_dir}}/{<!-- -->{target_output_name}}{<!-- -->{output_extension}}",

    ]

    default_output_extension = ".a"

    output_prefix = "lib"

  }

  tool("solink") {

    soname = "{<!-- -->{target_output_name}}{<!-- -->{output_extension}}"  # e.g. "libfoo.so".

    rspfile = soname + ".rsp"

    command = "g++ -shared {<!-- -->{ldflags}} -o $soname -Wl,-soname=$soname @$rspfile"

    rspfile_content = "-Wl,--whole-archive {<!-- -->{inputs}} {<!-- -->{solibs}} -Wl,--no-whole-archive {<!-- -->{libs}}"

    description = "SOLINK $soname"

    # Use this for {<!-- -->{output_extension}} expansions unless a target manually

    # overrides it (in which case {<!-- -->{output_extension}} will be what the target

    # specifies).

    default_output_extension = ".so"

    outputs = [

      soname,

    ]

    link_output = soname

    depend_output = soname

    output_prefix = "lib"

  }

  tool("link") {

    outfile = "{<!-- -->{target_output_name}}{<!-- -->{output_extension}}"

    rspfile = "$outfile.rsp"

    command = "g++ {<!-- -->{ldflags}} -o $outfile @$rspfile {<!-- -->{solibs}} {<!-- -->{libs}}"

    description = "LINK $outfile"

    rspfile_content = "{<!-- -->{inputs}}"

    outputs = [

      outfile,

    ]

  }

  tool("stamp") {

    command = "touch {<!-- -->{output}}"

    description = "STAMP {<!-- -->{output}}"

  }

  tool("copy") {

    command = "cp -af {<!-- -->{source}} {<!-- -->{output}}"

    description = "COPY {<!-- -->{source}} {<!-- -->{output}}"

  }

}

</code></pre> 
<p style="margin-left:0cm;">编译：</p> 
<p style="margin-left:0cm;">注意，gn生成的是ninja的输入文件，所以gn需要和ninja的版本适配。可以都从git上下载各自最新代码进行编译。</p> 
<p style="margin-left:0cm;">下载编译ninja</p> 
<pre class="has"><code>git clone https://github.com/ninja-build/ninja.git

cd ninja

./configure.py –bootstrap</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">下载编译gn</p> 
<pre class="has"><code>git clone https://gn.googlesource.com/gn

cd gn

python build/gen.py

ninja -C out</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">代码组织结构为</p> 
<pre class="has"><code>gn_test

ninja

gn</code></pre> 
<p style="margin-left:0cm;">编译测试代码</p> 
<pre class="has"><code>cd gn_test

../gn/out/gn gen out

##可以看到out目录下有build.ninja文件生成

../ninja/ninja –C out/ main

##可以看到main文件生成了

out/main

#打印如下结果
hello world

func1</code></pre> 
<ul><li> <h3><span style="color:#c45911;">Reference</span></h3> </li></ul> 
<p style="margin-left:0cm;">1)、https://blog.simplypatrick.com/posts/2016/01-23-gn/</p> 
<p style="margin-left:0cm;">2）、https://github.com/p47t/GN-demo</p> 
<p style="margin-left:0cm;">3)、https://gn.googlesource.com/gn</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f9cca8b85af4b73ff9c4e84d70c62846/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">电商项目-订单模块</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7583acd74002a569cadf44dbadfb0541/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">古月居ROS入门21讲笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>