<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一个人做饭简单食谱_通过这5条简单食谱学习SQL - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一个人做饭简单食谱_通过这5条简单食谱学习SQL" />
<meta property="og:description" content="一个人做饭简单食谱
SQL (Structured Query Language) is a powerful and expressive language for dealing with data from relational databases. But it can seem daunting to the uninitiated.
SQL(结构化查询语言)是一种功能强大的表达性语言，用于处理关系数据库中的数据。 但是对于初学者来说，这似乎令人生畏。 The &#34;recipes&#34; I&#39;m going to share with you today are some basic examples from a simple database. But the patterns you&#39;ll learn here can help you write precise queries. These will have you feeling like the data equivalent of a MasterChef in no time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/27f606be98978e06171b507febb04489/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-21T15:18:14+08:00" />
<meta property="article:modified_time" content="2020-08-21T15:18:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一个人做饭简单食谱_通过这5条简单食谱学习SQL</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size: 16px;"> 
 <p>一个人做饭简单食谱</p> 
 <p>SQL (Structured Query Language) is a powerful and expressive language for dealing with data from relational databases. But it can seem daunting to the uninitiated.</p> 
 <p> SQL(结构化查询语言)是一种功能强大的表达性语言，用于处理关系数据库中的数据。 但是对于初学者来说，这似乎令人生畏。 </p> 
 <p>The "recipes" I'm going to share with you today are some basic examples from a simple database. But the patterns you'll learn here can help you write precise queries. These will have you feeling like the data equivalent of a MasterChef in no time.</p> 
 <p> 我今天要与您分享的“食谱”是来自简单数据库的一些基本示例。 但是您将在此处学习的模式可以帮助您编写精确的查询。 这些将使您立即感觉就像MasterChef的数据一样。 </p> 
 <p><em>A note about syntax: Most of the queries below are written in the style used for PostgreSQL from the psql command line. Different SQL engines can use slightly different commands.</em></p> 
 <p> <em>有关语法的注释：以下大多数查询都是通过psql命令行以PostgreSQL所使用的样式编写的。</em> <em>不同SQL引擎可以使用略有不同的命令。</em> </p> 
 <p><em>Most of the queries below should work in most engines without tweaking, although some engines or GUI tools might require the omission of quotation marks around table and column names.</em></p> 
 <p> <em>尽管某些引擎或GUI工具可能要求省略表名和列名的引号，但下面的大多数查询都应在大多数引擎中运行，而无需进行调整。</em> </p> 
 <h3 id="dish-1-return-all-the-users-created-within-a-particular-date-range"> 菜式1：返回在特定日期范围内创建的所有用户 <span style="font-weight: bold;">(</span>Dish 1: Return all the users created within a particular date range<span style="font-weight: bold;">)</span></h3> 
 <h4 id="ingredients"> 配料 <span style="font-weight: bold;">(</span>Ingredients<span style="font-weight: bold;">)</span></h4> 
 <ul><li>SELECT<p class="nodelete"></p> 选择 </li><li>FROM<p class="nodelete"></p> 从 </li><li>WHERE<p class="nodelete"></p> 哪里 </li><li>AND<p class="nodelete"></p> 和 </li></ul> 
 <h4 id="method"> 方法 <span style="font-weight: bold;">(</span>Method<span style="font-weight: bold;">)</span></h4> 
 <pre class="has"><code class="language-sql">SELECT *
FROM "Users"
WHERE "created_at" &gt; "2020-01-01"
AND "created_at" &lt; "2020-02-01";</code></pre> 
 <p>This simple dish is a versatile staple. Here we are returning users that meet two particular conditions by chaining the <code>WHERE</code> conditions with an <code>AND</code> statement. We can extend this further with more <code>AND</code> statements.</p> 
 <p> 这道简单的菜是多用途的主食。 在这里，我们通过将<code>WHERE</code>条件与<code>AND</code>语句链接在一起来返回满足两个特定条件的用户。 我们可以使用更多的<code>AND</code>语句进一步扩展它。 </p> 
 <p>While the example here is for a specific date range, most queries require some sort of condition to filter the data usefully.</p> 
 <p> 虽然此处的示例是针对特定日期范围的，但大多数查询都需要某种条件才能有效过滤数据。 </p> 
 <h3 id="dish-2-find-all-comments-for-a-book-including-the-user-that-made-the-comment"> 菜式2：查找书籍的所有评论，包括发表评论的用户 <span style="font-weight: bold;">(</span>Dish 2: Find all comments for a book, including the user that made the comment<span style="font-weight: bold;">)</span></h3> 
 <h4 id="-new-ingredients"> (新)成分 <span style="font-weight: bold;">(</span>(New) Ingredients<span style="font-weight: bold;">)</span></h4> 
 <ul><li>JOIN<p class="nodelete"></p> 加入 </li></ul> 
 <h4 id="method-1"> 方法 <span style="font-weight: bold;">(</span>Method<span style="font-weight: bold;">)</span></h4> 
 <pre class="has"><code class="language-sql">SELECT "Comments"."comment", "Users"."username"
FROM "Comments"
JOIN "Users"
ON "Comments"."userId" = "Users"."id"
WHERE "Comments"."bookId" = 1;</code></pre> 
 <p>This query assumes the following table structure:</p> 
 <p> 该查询采用以下表结构： </p> 
 <p>One of the things that can start to confuse novices with SQL is the use of JOINs to find data from associated tables.</p> 
 <p> 可能使新手与SQL混淆的一件事是使用JOIN从关联表中查找数据。 </p> 
 <p>The ERD (Entity Relationship Diagram) above shows three tables, Users, Books, and Comments, and their associations.</p> 
 <p> 上面的ERD(实体关系图)显示了三个表，用户，书籍和注释，以及它们的关联。 </p> 
 <p>Each table has an <code>id</code> which is <strong>bold</strong> in the diagram to show that it is the primary key for the table. This primary key is always a unique value and is used to tell records in tables apart.</p> 
 <p> 每个表都有一个<code>id</code> ，该<code>id</code>在图中是<strong>粗体的</strong> ，以表明它是该表的主键。 该主键始终是唯一值，用于区分表中的记录。 </p> 
 <p>The <em>italic</em> column names <code>userId</code> and <code>bookId</code> in the Comments table are foreign keys, which means they are the primary key in other tables and are used here to reference those tables.</p> 
 <p> 注释表中的<em>斜体</em>列名称<code>userId</code>和<code>bookId</code>是外键，这意味着它们是其他表中的主键，在这里用于引用这些表。 </p> 
 <p>The connectors in the ERD above also show the nature of the relationships between the 3 tables. </p> 
 <p> 上面的ERD中的连接器还显示了3个表之间关系的性质。 </p> 
 <p>The single point end on the connector means 'one' and the split end on the connector means 'many', so the User table has a 'one-to-many' relationship with the Comments table. </p> 
 <p> 连接器上的单点端表示“一个”，连接器上的分叉端表示“许多”，因此“用户”表与“注释”表具有“一对多”关系。 </p> 
 <p>A user can have many comments, for example, but a comment can only belong to a single user. Books and Comments have the same relationship in the diagram above.</p> 
 <p> 例如，一个用户可以有很多评论，但是一个评论只能属于一个用户。 上图中的书籍和注释具有相同的关系。 </p> 
 <p>The SQL query should make sense based on what we now know. We are returning only the named columns, i.e. the comment column from the Comments table and the username from the associated Users table (based on the referenced foreign key). In the example above we constrain the search to a single book, again based on the foreign key in the Comments table.</p> 
 <p> 根据我们现在所知道的，SQL查询应该有意义。 我们仅返回命名列，即Comments表中的comment列和关联的Users表中的用户名(基于引用的外键)。 在上面的示例中，我们再次基于“注释”表中的外键将搜索限制为一本书。 </p> 
 <h3 id="dish-3-count-the-number-of-comments-added-by-each-user"> 菜式3：计算每个用户添加的评论数 <span style="font-weight: bold;">(</span>Dish 3: Count the number of comments added by each user<span style="font-weight: bold;">)</span></h3> 
 <h4 id="-new-ingredients-1"> (新)成分 <span style="font-weight: bold;">(</span>(New) Ingredients<span style="font-weight: bold;">)</span></h4> 
 <ul><li>COUNT<p class="nodelete"></p> 计数 </li><li>AS<p class="nodelete"></p> 如 </li><li>GROUP BY<p class="nodelete"></p> 通过...分组 </li></ul> 
 <h4 id="method-2"> 方法 <span style="font-weight: bold;">(</span>Method<span style="font-weight: bold;">)</span></h4> 
 <pre class="has"><code class="language-sql">SELECT "Users"."username", COUNT("Comments"."id") AS "CommentCount"
FROM "Comments"
JOIN "Users"
ON "Comments"."userId" = "Users"."id"
GROUP BY "Users"."id";</code></pre> 
 <p>This little query does a few interesting things. The easiest to understand is the <code>AS</code> statement. This allows us to arbitrarily, and temporarily, rename columns in the data that gets returned. Here we rename the derived column, but it's also useful when you have multiple <code>id</code> columns, since you can rename them things like <code>userId</code> or <code>commentId</code> and so on.</p> 
 <p> 这个小查询做了一些有趣的事情。 最容易理解的是<code>AS</code>语句。 这使我们可以任意地，临时地重命名要返回的数据中的列。 在这里，我们重命名了派生列，但是当您有多个<code>id</code>列时，它也很有用，因为您可以将它们重命名为<code>userId</code>或<code>commentId</code>等。 </p> 
 <p>The <code>COUNT</code> statement is a SQL function that, as you'd expect, counts things. Here we count the number of comments associated with a user. How does it work? Well the <code>GROUP BY</code> is the important final ingredient.</p> 
 <p> 如您所料， <code>COUNT</code>语句是一个SQL函数，它对事物进行计数。 在这里，我们计算与用户关联的评论数。 它是如何工作的？ 好吧， <code>GROUP BY</code>是重要的最终成分。 </p> 
 <p>Let's briefly imagine a slightly different query:</p> 
 <p> 让我们简要地想象一下一个稍微不同的查询： </p> 
 <pre class="has"><code class="language-sql">SELECT "Users"."username", "Comments"."comment"
FROM "Comments"
JOIN "Users"
ON "Comments"."userId" = "Users"."id";</code></pre> 
 <p>Notice, no counting or grouping. We just want each comment and who made it.</p> 
 <p> 注意，没有计数或分组。 我们只想要每个评论以及发表评论的人。 </p> 
 <p>The output might look something like this:</p> 
 <p> 输出可能看起来像这样： </p> 
 <pre class="has"><code>|----------|-----------------------------|
| username | comment                     |
|----------|-----------------------------|
| jackson  | it's good, I liked it       |
| jackson  | this was ok, not the best   |
| quincy   | excellent read, recommended |
| quincy   | not worth reading           |
| quincy   | I haven't read this yet     |
------------------------------------------</code></pre> 
 <p>Now imagine we wanted to count Jackson's and Quincy's comments - easy to see at a glance here, but harder with a larger dataset as you can imagine.</p> 
 <p> 现在想象一下，我们想计算一下Jackson和Quincy的评论-在这里一目了然，但想像中的更大数据集却很难。 </p> 
 <p>The <code>GROUP BY</code> statement essentially tells the query to treat all the <code>jackson</code> records as one group, and all the <code>quincy</code> records as another. The <code>COUNT</code> function then counts the records in that group and returns that value:</p> 
 <p> <code>GROUP BY</code>语句实质上是告诉查询将所有<code>jackson</code>记录视为一组，而将所有<code>quincy</code>记录视为另一组。 然后， <code>COUNT</code>函数计算该组中的记录并返回该值： </p> 
 <pre class="has"><code>|----------|--------------|
| username | CommentCount |
|----------|--------------|
| jackson  | 2            |
| quincy   | 3            |
---------------------------</code></pre> 
 <h3 id="dish-4-find-users-that-have-not-made-a-comment"> 菜式4：查找未发表评论的用户 <span style="font-weight: bold;">(</span>Dish 4: Find users that have not made a comment<span style="font-weight: bold;">)</span></h3> 
 <h4 id="-new-ingredients-2"> (新)成分 <span style="font-weight: bold;">(</span>(New) Ingredients<span style="font-weight: bold;">)</span></h4> 
 <ul><li>LEFT JOIN<p class="nodelete"></p> 左联接 </li><li>IS NULL<p class="nodelete"></p> 一片空白 </li></ul> 
 <h4 id="method-3"> 方法 <span style="font-weight: bold;">(</span>Method<span style="font-weight: bold;">)</span></h4> 
 <pre class="has"><code class="language-sql">SELECT "Users"."username"
FROM "Users"
LEFT JOIN "Comments"
ON "Users"."id" = "Comments"."userId"
WHERE "Comments"."id" IS NULL;</code></pre> 
 <p>The various joins can get very confusing, so I won't unpack them here. There is an excellent breakdown of them here: <a href="https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins" rel="nofollow">Visual Representations of SQL Joins</a>, which also accounts for some of the syntax differences between various flavours or SQL.</p> 
 <p> 各种连接可能会非常混乱，因此在这里我不会解压缩它们。 这里有一个很好的细分： <a href="https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins" rel="nofollow">SQL Joins的可视表示</a> ，它也解释了各种形式或SQL之间的某些语法差异。 </p> 
 <p>Let's imagine an alternate version of this query quickly:</p> 
 <p> 让我们快速想象一下该查询的替代版本： </p> 
 <pre class="has"><code>SELECT "Users"."username", "Comments"."id" AS "commentId"
FROM "Users"
LEFT JOIN "Comments"
ON "Users"."id" = "Comments"."userId";</code></pre> 
 <p>We still have the <code>LEFT JOIN</code> but we've added a column and removed the <code>WHERE</code> clause.</p> 
 <p> 我们仍然有<code>LEFT JOIN</code>但是我们添加了一个列并删除了<code>WHERE</code>子句。 </p> 
 <p>The return data might look something like this:</p> 
 <p> 返回数据可能看起来像这样： </p> 
 <pre class="has"><code>|----------|-----------|
| username | commentId |
|----------|-----------|
| jackson  | 1         |
| jackson  | 2         |
| quincy   | NULL      |
| abbey    | 3         |
------------------------</code></pre> 
 <p>So Jackson is responsible for comments 1 and 2, Abbey for 3, and Quincy has not commented.</p> 
 <p> 因此，杰克逊负责评论1和2，修道院负责3，而昆西没有评论。 </p> 
 <p>The difference between a <code>LEFT JOIN</code> and an <code>INNER JOIN</code> (what we've been calling just a <code>JOIN</code> until now, which is valid) is that the inner join only shows records where there are values for both tables. A left join, on the other hand, returns everything from the first, or left, table (the <code>FROM</code> one) even if there is nothing in the right table. An inner join would therefore only show the records for Jackson and Abbey.</p> 
 <p> <code>LEFT JOIN</code>和<code>INNER JOIN</code> (到目前为止，我们一直称其为<code>JOIN</code> ，这是有效的)之间的区别在于，内部<code>INNER JOIN</code>仅显示两个表都具有值的记录。 另一方面，即使右表中没有任何内容，左<code>FROM</code>也会<code>FROM</code>一个表或左表( <code>FROM</code>之一)返回所有内容。 因此，内部联接只会显示Jackson和Abbey的记录。 </p> 
 <p>Now that we can visualize what the <code>LEFT JOIN</code> returns, it's easier to reason about what the <code>WHERE...IS NULL</code> part does. We return only those users where the commentId is a null value, and we don't actually need the null value column included in the output, hence its original omission.</p> 
 <p> 现在我们可以看到<code>LEFT JOIN</code>返回的内容，现在更容易<code>WHERE...IS NULL</code>部分的作用。 我们仅返回commentId为空值的那些用户，并且实际上不需要输出中包括空值列，因此可以忽略其原始内容。 </p> 
 <h3 id="dish-5-list-all-comments-added-by-each-user-in-a-single-field-pipe-separated"> 菜式5：在单个字段中列出每个用户添加的所有评论，并用管道分隔 <span style="font-weight: bold;">(</span>Dish 5: List all comments added by each user in a single field, pipe separated<span style="font-weight: bold;">)</span></h3> 
 <h4 id="-new-ingredients-3"> (新)成分 <span style="font-weight: bold;">(</span>(New) Ingredients<span style="font-weight: bold;">)</span></h4> 
 <ul><li>GROUP_CONCAT or STRING_AGG<p class="nodelete"></p> GROUP_CONCAT或STRING_AGG </li></ul> 
 <h4 id="method-mysql-"> 方法(MySQL) <span style="font-weight: bold;">(</span>Method (MySQL)<span style="font-weight: bold;">)</span></h4> 
 <pre class="has"><code class="language-sql">SELECT "Users"."username", GROUP_CONCAT("Comments"."comment" SEPARATOR " | ") AS "comments"
FROM "Users"
JOIN "Comments"
ON "Users"."id" = "Comments"."userId"
GROUP BY "Users"."id";</code></pre> 
 <h4 id="method-postgresql-"> 方法(PostgreSQL) <span style="font-weight: bold;">(</span>Method (Postgresql)<span style="font-weight: bold;">)</span></h4> 
 <pre class="has"><code class="language-sql">SELECT "Users"."username", STRING_AGG("Comments"."comment", " | ") AS "comments"
FROM "Users"
JOIN "Comments"
ON "Users"."id" = "Comments"."userId"
GROUP BY "Users"."id";</code></pre> 
 <p>This final recipe shows a difference in syntax for a similar function in two of the most popular SQL engines.</p> 
 <p> 最后的配方显示了两个最受欢迎SQL引擎中相似函数的语法差异。 </p> 
 <p>Here is a sample output we might expect:</p> 
 <p> 这是我们可能期望的示例输出： </p> 
 <pre class="has"><code>|----------|---------------------------------------------------|
| username | comments                                          |
|----------|---------------------------------------------------|
| jackson  | it's good, I liked it | this was ok, not the best |
| quincy   | excellent read, recommended | not worth reading   |
----------------------------------------------------------------</code></pre> 
 <p>We can see here that the comments have been grouped and concatenated / aggregated, that is joined together in a single record field.</p> 
 <p> 我们在这里可以看到，注释已被分组和连接/聚合，并在单个记录字段中连接在一起。 </p> 
 <h3 id="bon-appetit"> <strong>好</strong> <strong>胃口</strong> <span style="font-weight: bold;">(</span><strong>Bon</strong> <strong>Appetit</strong><span style="font-weight: bold;">)</span></h3> 
 <p>Now that you have some SQL recipes to fall back on, get creative and serve up your own data dishes! </p> 
 <p> 现在您有了一些可以依靠SQL食谱，可以发挥创意并提供自己的数据服务！ </p> 
 <p>I like to think of <code>WHERE</code>, <code>JOIN</code>, <code>COUNT</code>, <code>GROUP_CONCAT</code> as the <em>Salt, Fat, Acid, Heat</em> of database cooking. Once you know what you're doing with these core elements, you are well on your way to mastery.</p> 
 <p> 我喜欢将<code>WHERE</code> ， <code>JOIN</code> ， <code>COUNT</code> ， <code>GROUP_CONCAT</code>视为数据库烹饪的<em>盐，脂肪，酸，热</em> 。 一旦了解了这些核心元素的功能，就可以很好地掌握。 </p> 
 <p>If this has been a useful collection, or you have other favourite recipes to share, drop me a comment or follow on Twitter: <a href="https://twitter.com/jacksonbates" rel="nofollow">@JacksonBates</a>.</p> 
 <p> 如果这是一个有用的收藏，或者您有其他喜欢的食谱可以分享，请给我评论或在Twitter上关注<a href="https://twitter.com/jacksonbates" rel="nofollow">@JacksonBates</a> 。 </p> 
 <blockquote> 
  <p>翻译自: <a href="https://www.freecodecamp.org/news/sql-recipes/" rel="nofollow">https://www.freecodecamp.org/news/sql-recipes/</a></p> 
 </blockquote> 
 <p>一个人做饭简单食谱</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c28e6f7a330f61237be9d7cbb40792e1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mac启动pg数据库失败 “Is another postmaster (PID 370) running in data directory“</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/761c6169b604b33fefa63ca36f926f70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">gitlab配置https方式访问</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>