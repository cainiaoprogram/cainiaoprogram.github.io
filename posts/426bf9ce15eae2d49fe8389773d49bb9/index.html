<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>写给go开发者的gRPC教程-metadata - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="写给go开发者的gRPC教程-metadata" />
<meta property="og:description" content="导语
和在普通HTTP请求中一样，gRPC提供了在每一次RPC中携带上下文的结构：metadata。在Go语言中，它与context.Context紧密结合，帮助我们实现服务端与客户端之间互相传递信息
什么是 metadata？ gRPC 的 metadata 简单理解，就是 HTTP Header 中的 key-value 对
metadata 是以 key-value 的形式存储数据的，其中 key 是 string 类型，而 value 是 []string，即一个字符串数组类型
metadata 使得 client 和 server 能够为对方提供关于本次调用的一些信息，就像一次HTTP请求的Request Header和Response Header一样
HTTP Header 的生命周期是一次 HTTP 请求，那么 metadata 的生命周期就是一次 RPC 调用
metadata 创建 🌲 使用New()： md := metadata.New(map[string]string{&#34;key1&#34;:&#34;value1&#34;,&#34;key2&#34;:&#34;value2&#34;}) 🌲 使用Pairs()： 要注意如果有相同的 key 会自动合并
md := metadata.Pairs( &#34;key1&#34;, &#34;value1&#34;, &#34;key1&#34;, &#34;value1.2&#34;, // &#34;key1&#34; will have map value []string{&#34;value1&#34;, &#34;value1.2&#34;} &#34;key2&#34;, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/426bf9ce15eae2d49fe8389773d49bb9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-07T18:00:35+08:00" />
<meta property="article:modified_time" content="2023-03-07T18:00:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">写给go开发者的gRPC教程-metadata</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <blockquote> 
  <p><strong>导语</strong></p> 
  <p>和在普通<code>HTTP</code>请求中一样，gRPC提供了在每一次RPC中携带上下文的结构：<code>metadata</code>。在Go语言中，它与<code>context.Context</code>紧密结合，帮助我们实现服务端与客户端之间互相传递信息</p> 
 </blockquote> 
 <h3>什么是 <code>metadata</code>？</h3> 
 <p><strong>gRPC 的 <code>metadata</code> 简单理解，就是 <code>HTTP Header</code>  中的 key-value 对</strong></p> 
 <ul><li><p><code>metadata</code> 是以 <code>key-value</code> 的形式存储数据的，其中 key 是 string 类型，而 value 是 []string，即一个字符串数组类型</p></li><li><p><code>metadata</code> 使得 client 和 server 能够为对方提供关于本次调用的一些信息，就像一次HTTP请求的<code>Request Header</code>和<code>Response Header</code>一样</p></li><li><p><code>HTTP Header</code> 的生命周期是一次 HTTP 请求，那么 <code>metadata</code> 的生命周期就是一次 RPC 调用</p></li></ul> 
 <h3>metadata 创建</h3> 
 <h4>🌲 使用New()：</h4> 
 <pre class="has"><code class="language-go">md := metadata.New(map[string]string{"key1":"value1","key2":"value2"})</code></pre> 
 <h4>🌲 使用Pairs()：</h4> 
 <p>要注意如果有相同的 key 会自动合并</p> 
 <pre class="has"><code class="language-go">md := metadata.Pairs(
    "key1", "value1",
    "key1", "value1.2", // "key1" will have map value []string{"value1", "value1.2"}
    "key2", "value2",
)</code></pre> 
 <h4>🌲 合并多个metadata</h4> 
 <pre class="has"><code class="language-go">md1 :=  metadata.Pairs("k1", "v1", "k2", "v2")
md2 := metadata.New(map[string]string{"key1":"value1","key2":"value2"})

md := metadata.Join(md1, md2)</code></pre> 
 <h4>🌲 存储二进制数据</h4> 
 <p>在 metadata 中，key 永远是 string 类型，但是 value 可以是 string 也可以是二进制数据。为了在 metadata 中存储二进制数据，我们仅仅需要在 key 的后面加上一个 - bin 后缀。具有 - bin 后缀的 key 所对应的 value 在创建 metadata 时会被编码（base64），收到的时候会被解码：</p> 
 <pre class="has"><code class="language-go">md := metadata.Pairs(
    "key", "string value",
    "key-bin", string([]byte{96, 102}),
)</code></pre> 
 <p>metadata 结构本身也有一些操作方法，参考文档非常容易理解。这里不再赘述：https://pkg.go.dev/google.golang.org/grpc@v1.44.0/metadata</p> 
 <h3>metadata 发送与接收</h3> 
 <p>让我们再次回顾下pb文件和生成出来的client与server端的接口</p> 
 <pre class="has"><code class="language-go">service OrderManagement {
    rpc getOrder(google.protobuf.StringValue) returns (Order);
}</code></pre> 
 <pre class="has"><code class="language-go">type OrderManagementClient interface {
 GetOrder(ctx context.Context, 
           in *wrapperspb.StringValue, opts ...grpc.CallOption) (*Order, error)
}</code></pre> 
 <pre class="has"><code class="language-go">type OrderManagementServer interface {
 GetOrder(context.Context, *wrapperspb.StringValue) (*Order, error)
 mustEmbedUnimplementedOrderManagementServer()
}</code></pre> 
 <p>可以看到相比pb中的接口定义，生成出来的Go代码除了增加了<code>error</code>返回值，还多了<code>context.Context</code></p> 
 <p>和错误处理类似，gRPC中的<code>context.Context</code> 也符合Go语言的使用习惯：通常情况下我们在函数首个参数放置<code>context.Context</code>用来传递一次RPC中有关的上下文，借助<code>context.WithValue()</code>或<code>ctx.Value()</code>往<code>context</code>添加变量或读取变量</p> 
 <p><code>metadata</code>就是gRPC中可以传递的上下文信息之一，所以<code>metadata</code>的使用方式就是：<code>metadata</code>记录到<code>context</code>，从<code>context</code>读取<code>metadata</code></p> 
 <img src="https://images2.imgbox.com/5d/85/HkgKc2g9_o.png" alt="57b29bcfc2050275f812366c8db6e345.png"> 
 <h3>Clinet发送Server接收</h3> 
 <p><code>client</code>发送<code>metadata</code>，那就是把<code>metadata</code>存储到<code>contex.Context</code></p> 
 <p><code>server</code>接收<code>metadata</code>，就是从<code>contex.Context</code>中读取<code>Metadata</code></p> 
 <h4>Clinet 发送 Metadata</h4> 
 <p>把<code>Metadata</code>放到<code>contex.Context</code>，有几种方式</p> 
 <h5>🌲 使用<code>NewOutgoingContext</code></h5> 
 <p>将新创建的<code>metadata</code>添加到<code>context</code>中，这样会 <strong>覆盖</strong> 掉原来已有的<code>metadata</code></p> 
 <pre class="has"><code class="language-go">// 将metadata添加到context中，获取新的context
md := metadata.Pairs("k1", "v1", "k1", "v2", "k2", "v3")
ctx := metadata.NewOutgoingContext(context.Background(), md)

// unary RPC
response, err := client.SomeRPC(ctx, someRequest)

// streaming RPC
stream, err := client.SomeStreamingRPC(ctx)</code></pre> 
 <h5>🌲 使用<code>AppendToOutgoingContext</code></h5> 
 <p>可以直接将 key-value 对添加到已有的<code>context</code>中</p> 
 <ul><li><p>如果<code>context</code>中没有<code>metadata</code>，那么就会 <strong>创建</strong> 一个</p></li><li><p>如果已有<code>metadata</code>，那么就将数据 <strong>添加</strong> 到原来的<code>metadata</code></p></li></ul> 
 <pre class="has"><code class="language-go">// 如果对应的 context 没有 metadata，那么就会创建一个
ctx := metadata.AppendToOutgoingContext(ctx, "k1", "v1", "k1", "v2", "k2", "v3")

// 如果已有 metadata 了，那么就将数据添加到原来的 metadata  (例如在拦截器中)
ctx := metadata.AppendToOutgoingContext(ctx, "k3", "v4")

// 普通RPC（unary RPC）
response, err := client.SomeRPC(ctx, someRequest)

// 流式RPC（streaming RPC）
stream, err := client.SomeStreamingRPC(ctx)</code></pre> 
 <h4>Server 接收 Metedata</h4> 
 <p>普通RPC与流式RPC的区别不大，都是从<code>contex.Context</code>中读取<code>metadata</code></p> 
 <h5>🌲 使用<code>FromIncomingContext</code></h5> 
 <p><strong>普通RPC（unary RPC）</strong></p> 
 <pre class="has"><code class="language-go">//Unary Call
func (s *server) SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    // do something with metadata
}</code></pre> 
 <p><strong>流式RPC（streaming RPC）</strong></p> 
 <pre class="has"><code class="language-go">//Streaming Call
func (s *server) SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) error {
    md, ok := metadata.FromIncomingContext(stream.Context()) // get context from stream
    // do something with metadata
}</code></pre> 
 <h3>Server发送Clinet接收</h3> 
 <p>服务端发送的<code>metadata</code>被分成了<code>header</code>和 <code>trailer</code>两者，因而客户端也可以读取两者</p> 
 <h4>Server 发送 Metadata</h4> 
 <p>对于<strong>普通RPC（unary RPC）</strong>server可以使用grpc包中提供的函数向client发送 <code>header</code> 和<code>trailer</code></p> 
 <ul><li><p><code>grpc.SendHeader()</code></p></li><li><p><code>grpc.SetHeader()</code></p></li><li><p><code>grpc.SetTrailer()</code></p></li></ul> 
 <p>对于**流式RPC（streaming RPC）server可以使用ServerStream<sup>[1]</sup>接口中定义的函数向client发送<code>header</code>和 <code>trailer</code></p> 
 <ul><li><p><code>ServerStream.SendHeader()</code></p></li><li><p><code>ServerStream.SetHeader()</code></p></li><li><p><code>ServerStream.SetTrailer()</code></p></li></ul> 
 <h5>🌲 普通RPC（unary RPC）</h5> 
 <p>使用 <code>grpc.SendHeader()</code>  和 <code>grpc.SetTrailer()</code> 方法 ，这两个函数将<code>context.Context</code>作为第一个参数</p> 
 <pre class="has"><code class="language-go">func (s *server) SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, error) {
  // 创建并发送header
  header := metadata.Pairs("header-key", "val")
  grpc.SendHeader(ctx, header)
  
  // 创建并发送trailer
  trailer := metadata.Pairs("trailer-key", "val")
  grpc.SetTrailer(ctx, trailer)
}</code></pre> 
 <p>如果不想立即发送<code>header</code>，也可以使用<code>grpc.SetHeader()</code>。<code>grpc.SetHeader()</code>可以被多次调用，在如下时机会把多个<code>metadata</code>合并发送出去</p> 
 <ul><li><p>调用<code>grpc.SendHeader()</code></p></li><li><p>第一个响应被发送时</p></li><li><p>RPC结束时（包含成功或失败）</p></li></ul> 
 <pre class="has"><code class="language-go">func (s *server) SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, error) {
  // 创建header，在适当时机会被发送
  header := metadata.Pairs("header-key1", "val1")
  grpc.SetHeader(ctx, header)
    
  // 创建header，在适当时机会被发送
  header := metadata.Pairs("header-key2", "val2")
  grpc.SetHeader(ctx, header)
  
  // 创建并发送trailer
  trailer := metadata.Pairs("trailer-key", "val")
  grpc.SetTrailer(ctx, trailer)
}</code></pre> 
 <h5>🌲 <strong>流式RPC（streaming RPC）</strong></h5> 
 <p>使用 <code>ServerStream.SendHeader()</code> 和 <code>ServerStream.SetTrailer()</code> 方法</p> 
 <pre class="has"><code class="language-go">func (s *server) SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) error {
  // create and send header
  header := metadata.Pairs("header-key", "val")
  stream.SendHeader(header)
  
  // create and set trailer
  trailer := metadata.Pairs("trailer-key", "val")
  stream.SetTrailer(trailer)
}</code></pre> 
 <p>如果不想立即发送<code>header</code>，也可以使用<code>ServerStream.SetHeader()</code>。<code>ServerStream.SetHeader()</code>可以被多次调用，在如下时机会把多个<code>metadata</code>合并发送出去</p> 
 <ul><li><p>调用<code>ServerStream.SendHeader()</code></p></li><li><p>第一个响应被发送时</p></li><li><p>RPC结束时（包含成功或失败）</p></li></ul> 
 <pre class="has"><code class="language-go">func (s *server) SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) error {
  // create and send header
  header := metadata.Pairs("header-key", "val")
  stream.SetHeader(header)
  
  // create and set trailer
  trailer := metadata.Pairs("trailer-key", "val")
  stream.SetTrailer(trailer)
}</code></pre> 
 <h4>Client 接收 Metadata</h4> 
 <h5>🌲 <strong>普通RPC（unary RPC）</strong></h5> 
 <p><strong>普通RPC（unary RPC）</strong>使用<code>grpc.Header()</code>和<code>grpc.Trailer()</code>方法来接收 Metadata</p> 
 <pre class="has"><code class="language-go">// RPC using the context with new metadata.
var header, trailer metadata.MD

// Add Order
order := pb.Order{Id: "101", Items: []string{"iPhone XS", "Mac Book Pro"}, Destination: "San Jose, CA", Price: 2300.00}
res, err := client.AddOrder(ctx, &amp;order, grpc.Header(&amp;header), grpc.Trailer(&amp;trailer))
if err != nil {
  panic(err)
}</code></pre> 
 <h5>🌲 <strong>流式RPC（streaming RPC）</strong></h5> 
 <p><strong>流式RPC（streaming RPC）</strong>通过调用返回的 <code>ClientStream</code>接口的<code>Header()</code>和<code> Trailer()</code>方法接收 <code>metadata</code></p> 
 <pre class="has"><code class="language-go">stream, err := client.SomeStreamingRPC(ctx)

// retrieve header
header, err := stream.Header()

stream.CloseAndRecv()

// retrieve trailer
trailer := stream.Trailer()</code></pre> 
 <h4><code>Header</code>和<code>Trailer</code>区别</h4> 
 <p>根本区别：发送的时机不同！</p> 
 <p>✨ <code>headers</code>会在下面三种场景下被发送</p> 
 <ul><li><p><code>SendHeader()</code> 被调用时（包含<code>grpc.SendHeader</code>和<code>stream.SendHeader</code>)</p></li><li><p>第一个响应被发送时</p></li><li><p>RPC结束时（包含成功或失败）</p></li></ul> 
 <p>✨ <code>trailer</code>会在rpc返回的时候，即这个请求结束的时候被发送</p> 
 <p>差异在流式RPC（streaming RPC）中比较明显：</p> 
 <p>因为<code>trailer</code>是在服务端发送完请求之后才发送的，所以client获取<code>trailer</code>的时候需要在<code>stream.CloseAndRecv</code>或者<code>stream.Recv</code> 返回非nil错误 (包含 io.EOF)之后</p> 
 <p>如果<code>stream.CloseAndRecv</code>之前调用<code>stream.Trailer()</code>获取的是空</p> 
 <pre class="has"><code class="language-go">stream, err := client.SomeStreamingRPC(ctx)

// retrieve header
header, err := stream.Header()

// retrieve trailer 
// `trailer`会在rpc返回的时候，即这个请求结束的时候被发送
// 因此此时调用`stream.Trailer()`获取的是空
trailer := stream.Trailer()

stream.CloseAndRecv()

// retrieve trailer 
// `trailer`会在rpc返回的时候，即这个请求结束的时候被发送
// 因此此时调用`stream.Trailer()`才可以获取到值
trailer := stream.Trailer()</code></pre> 
 <h3>使用场景</h3> 
 <p>既然我们把<code>metadata</code>类比成<code>HTTP Header</code>，那么<code>metadata</code>的使用场景也可以借鉴<code>HTTP</code>的<code>Header</code>。如传递用户<code>token</code>进行用户认证，传递<code>trace</code>进行链路追踪等</p> 
 <h4>拦截器中的metadata</h4> 
 <p>在拦截器中，我们不但可以获取或修改<strong>接收</strong>到的<code>metadata</code>，甚至还可以截取并修改要<strong>发送</strong>出去的<code>metadata</code></p> 
 <p>还记得拦截器如何实现么？如果已经忘了快快回顾一下吧：</p> 
 <p>🌰 举个例子：</p> 
 <p>我们在客户端拦截器中从要发送给服务端的<code>metadata</code>中读取一个时间戳字段，如果没有则补充这个时间戳字段</p> 
 <p>注意这里用到了一个上文没有提到的<code>FromOutgoingContext(ctx)</code>函数</p> 
 <pre class="has"><code class="language-go">func orderUnaryClientInterceptor(ctx context.Context, method string, req, reply interface{},
 cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {

 var s string

 // 获取要发送给服务端的`metadata`
 md, ok := metadata.FromOutgoingContext(ctx)
 if ok &amp;&amp; len(md.Get("time")) &gt; 0 {
  s = md.Get("time")[0]
 } else {
        // 如果没有则补充这个时间戳字段
  s = "inter" + strconv.FormatInt(time.Now().UnixNano(), 10)
  ctx = metadata.AppendToOutgoingContext(ctx, "time", s)
 }

 log.Printf("call timestamp: %s", s)

 // Invoking the remote method
 err := invoker(ctx, method, req, reply, cc, opts...)

 return err
}

func main() {
 conn, err := grpc.Dial("127.0.0.1:8009",
  grpc.WithInsecure(),
  grpc.WithChainUnaryInterceptor(
   orderUnaryClientInterceptor,
  ),
 )
 if err != nil {
  panic(err)
 }
    
    c := pb.NewOrderManagementClient(conn)

 ctx = metadata.AppendToOutgoingContext(context.Background(), "time",
  "raw"+strconv.FormatInt(time.Now().UnixNano(), 10))

 // RPC using the context with new metadata.
 var header, trailer metadata.MD

 // Add Order
 order := pb.Order{
  Id:          "101",
  Items:       []string{"iPhone XS", "Mac Book Pro"},
  Destination: "San Jose, CA",
  Price:       2300.00,
 }
 res, err := c.AddOrder(ctx, &amp;order)
 if err != nil {
  panic(err)
 }
}</code></pre> 
 <p>以上的思路在server同样适用。基于以上原理我们可以实现链路追踪、用户认证等功能</p> 
 <h4>错误信息</h4> 
 <p>还记得<a href="" rel="nofollow">错误处理</a>一文中留下的问题么：gRPC 中如何传递错误消息<code>Status</code>的呢？没错！也是使用的<code>metadata</code>或者说<code>http2.0</code> 的<code>header</code>。<code>Status</code>的三种信息分别使用了三个<code>header</code>头</p> 
 <ul><li><p><code>Grpc-Status</code>: 传递<code>Status</code>的<code>code</code></p></li><li><p><code>Grpc-Message</code>: 传递<code>Status</code>的<code>message</code></p></li><li><p><code>Grpc-Status-Details-Bin</code>: 传递<code>Status</code>的<code>details</code></p></li></ul> 
 <pre class="has"><code class="language-go">func (ht *serverHandlerTransport) WriteStatus(s *Stream, st *status.Status) error {
 // ...
  h := ht.rw.Header()
  h.Set("Grpc-Status", fmt.Sprintf("%d", st.Code()))
  if m := st.Message(); m != "" {
   h.Set("Grpc-Message", encodeGrpcMessage(m))
  }

  if p := st.Proto(); p != nil &amp;&amp; len(p.Details) &gt; 0 {
   stBytes, err := proto.Marshal(p)
   if err != nil {
    // TODO: return error instead, when callers are able to handle it.
    panic(err)
   }

   h.Set("Grpc-Status-Details-Bin", encodeBinHeader(stBytes))
  }
    // ...
}</code></pre> 
 <h3>总结</h3> 
 <p>一张图总结下整个<code>metadata</code>的使用方法</p> 
 <img src="https://images2.imgbox.com/fa/f5/N6dTCW6Q_o.png" alt="25f3373c47a2b7a6e05e4f73578ee5d7.png"> 
 <p style="text-align:left;">- END -</p> 
 <p style="text-align:center;">扫码关注公众号「网管叨bi叨」</p> 
 <p style="text-align:center;">给网管个星标，第一时间吸我的知识 👆</p> 
 <p style="text-align:left;">网管整理了一本《Go 开发参考书》收集了70多条开发实践。去公众号回复【gocookbook】领取！还有一本《k8s 入门实践》讲解了常用软件在K8s上的部署过程，公众号回复【k8s】即可领取！</p> 
 <p style="text-align:right;">觉得有用就点个在看  👇👇👇</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9321ccf91a8b75a3185ecab8e8d5622d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器学习与目标检测作业：连通块算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/82ba30fb727bf54cabf7ef3c2fa09491/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">redisTemplate 根据key前缀批量删除</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>