<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Oracle数据并发和一致性（English） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Oracle数据并发和一致性（English）" />
<meta property="og:description" content="It is cited from Data Concurrency and Consistency.
20
Data Concurrency and Consistency This chapter explains how Oracle maintains consistent data in a multiuser database environment. The chapter includes:
Introduction to Data Concurrency and Consistency in a Multiuser Environment How Oracle Manages Data Concurrency and Consistency How Oracle Locks Data Flashback Query Introduction to Data Concurrency and Consistency in a Multiuser Environment In a single-user database, the user can modify data in the database without concern for other users modifying the same data at the same time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e834efbbce7793782ae683404dfde0a8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2009-01-05T11:46:00+08:00" />
<meta property="article:modified_time" content="2009-01-05T11:46:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Oracle数据并发和一致性（English）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> It is cited from <a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm" name="CNCPT021"><font face="Arial" color="#330099">Data Concurrency and Consistency</font></a>.</p> 
<p> </p> 
<h2 class="Title"><font face="Arial, Helvetica, sans-serif" color="#330099">20<br><a name="CNCPT021">Data Concurrency and Consistency</a></font></h2> 
 
<a name="2423"></a> 
<p class="BP">This chapter explains how Oracle maintains consistent data in a multiuser database environment. The chapter includes:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="2425"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2434"><u><font color="#800080">Introduction to Data Concurrency and Consistency in a Multiuser Environment</font></u></a> </li><li class="LB1" type="disc"><a name="2427"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2570"><u><font color="#800080">How Oracle Manages Data Concurrency and Consistency</font></u></a> </li><li class="LB1" type="disc"><a name="2429"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2841"><u><font color="#800080">How Oracle Locks Data</font></u></a> </li><li class="LB1" type="disc"><a name="20325"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#20178"><u><font color="#800080">Flashback Query</font></u></a> </li></ul> 
<a name="2434"></a> 
 
<h3 class="H1"><a name="CNCPT121"><font face="Arial, Helvetica, sans-serif" color="#330099">Introduction to Data Concurrency and Consistency in a Multiuser Environment</font></a></h3> 
 
<a name="5894"></a> 
<p class="BP">In a single-user database, the user can modify data in the database without concern for other users modifying the same data at the same time. However, in a multiuser database, the statements within multiple simultaneous transactions can update the same data. Transactions executing at the same time need to produce meaningful and consistent results. Therefore, control of data concurrency and data consistency is vital in a multiuser database.</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="5897"></a><strong class="Bold">Data concurrency</strong> means that many users can access data at the same time. </li><li class="LB1" type="disc"><a name="5903"></a><strong class="Bold">Data consistency</strong> means that each user sees a consistent view of the data, including visible changes made by the user's own transactions and transactions of other users. </li></ul> 
<a name="5907"></a> 
<p class="BP">To describe consistent transaction behavior when transactions execute at the same time, database researchers have defined a transaction isolation model called <strong class="Bold">serializability</strong>. The serializable mode of transaction behavior tries to ensure that transactions execute in such a way that they appear to be executed one at a time, or serially, rather than concurrently.</p> 
<a name="2454"></a> 
<p class="BP">While this degree of isolation between transactions is generally desirable, running many applications in this mode can seriously compromise application throughput. Complete isolation of concurrently running transactions could mean that one transaction cannot perform an insert into a table being queried by another transaction. In short, real-world considerations usually require a compromise between perfect transaction isolation and performance.</p> 
<a name="2456"></a> 
<p class="BP">Oracle offers two isolation levels, providing application developers with operational modes that preserve consistency and provide high performance.</p> 
<a name="18016"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="17558"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="17559"></a> <p class="NB"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c22integ.htm#3191"><u><font color="#0000ff">Chapter 21, "Data Integrity"</font></u></a> for information about data integrity, which enforces business rules associated with a database</p></td></tr></tbody></table> 
</div> 
<a name="2458"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Preventable Phenomena and Transaction Isolation Levels</font></h4> 
 
<a name="2464"></a> 
<p class="BP">The ANSI/ISO SQL standard (SQL92) defines four levels of transaction isolation with differing degrees of impact on transaction processing throughput. These isolation levels are defined in terms of three phenomena that must be prevented between concurrently executing transactions.</p> 
<a name="2468"></a> 
<p class="BP">The three preventable phenomena are:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="22323"></a>Dirty reads: A transaction reads data that has been written by another transaction that has not been committed yet. </li><li class="LB1" type="disc"><a name="22326"></a>Nonrepeatable (fuzzy) reads: A transaction rereads data it has previously read and finds that another committed transaction has modified or deleted the data. </li><li class="LB1" type="disc"><a name="22333"></a>Phantom reads: A transaction re-executes a query returning a set of rows that satisfies a search condition and finds that another committed transaction has inserted additional rows that satisfy the condition. </li></ul> 
<a name="2495"></a> 
<p class="BP">SQL92 defines four levels of isolation in terms of the phenomena a transaction running at a particular isolation level is permitted to experience. They are shown in <a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#18061"><u><font color="#800080">Table 20-1</font></u></a>:</p> 
<h6 class="TT"><a name="18070"></a><a name="18061"></a><strong><font face="Arial, Helvetica, sans-serif"><em>Table 20-1 Preventable Read Phenomena by Isolation Level</em></font></strong></h6> 
<p> </p> 
<table class="Formal" dir="ltr" title="" cellspacing="0" cellpadding="3" width="100%" border="1"><thead><tr class="Formal"><th class="Formal" align="left"><a name="8763"></a><font face="Arial, Helvetica, sans-serif"><strong>Isolation Level</strong></font></th><th class="Formal" align="left"><a name="8771"></a><font face="Arial, Helvetica, sans-serif"><strong>Dirty Read</strong></font></th><th class="Formal" align="left"><a name="8775"></a><font face="Arial, Helvetica, sans-serif"><strong>Nonrepeatable Read</strong></font></th><th class="Formal" align="left"><a name="8779"></a><font face="Arial, Helvetica, sans-serif"><strong>Phantom Read</strong></font></th></tr></thead><tbody><tr class="Formal" align="left"><td class="Formal"><a name="8784"></a> <p class="TB">Read uncommitted</p></td><td class="Formal"><a name="8786"></a> <p class="TB">Possible</p></td><td class="Formal"><a name="8788"></a> <p class="TB">Possible</p></td><td class="Formal"><a name="8790"></a> <p class="TB">Possible</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="8792"></a> <p class="TB">Read committed</p></td><td class="Formal"><a name="8794"></a> <p class="TB">Not possible</p></td><td class="Formal"><a name="8796"></a> <p class="TB">Possible</p></td><td class="Formal"><a name="8798"></a> <p class="TB">Possible</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="8801"></a> <p class="TB">Repeatable read</p></td><td class="Formal"><a name="8803"></a> <p class="TB">Not possible</p></td><td class="Formal"><a name="8805"></a> <p class="TB">Not possible</p></td><td class="Formal"><a name="8807"></a> <p class="TB">Possible</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="8809"></a> <p class="TB">Serializable</p></td><td class="Formal"><a name="8811"></a> <p class="TB">Not possible</p></td><td class="Formal"><a name="8813"></a> <p class="TB">Not possible</p></td><td class="Formal"><a name="8815"></a> <p class="TB">Not possible</p></td></tr></tbody></table> 
<a name="2497"></a> 
<p></p> 
<p class="BP">Oracle offers the read committed and serializable isolation levels, as well as a read-only mode that is not part of SQL92. Read committed is the default.</p> 
<a name="18019"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="17576"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="17577"></a> <p class="NB"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2570"><u><font color="#800080">"How Oracle Manages Data Concurrency and Consistency"</font></u></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2570"></a> for a full discussion of read committed and serializable isolation levels</p></td></tr></tbody></table> 
</div> 
<a name="2499"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Overview of Locking Mechanisms</font></h4> 
 
<a name="2505"></a> 
<p class="BP">In general, multiuser databases use some form of data locking to solve the problems associated with data concurrency, consistency, and integrity. <strong class="Bold">Locks</strong> are mechanisms that prevent destructive interaction between transactions accessing the same resource.</p> 
<a name="2507"></a> 
<p class="BP">Resources include two general types of objects:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="2509"></a>User objects, such as tables and rows (structures and data) </li><li class="LB1" type="disc"><a name="2511"></a>System objects not visible to users, such as shared data structures in the memory and data dictionary rows <p><a name="18022"></a></p> 
  <div align="center"> 
   <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="17596"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="17597"></a> <p class="NB"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2841"><u><font color="#800080">"How Oracle Locks Data"</font></u></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2841"></a> for more information about locks</p></td></tr></tbody></table> 
  </div></li></ul> 
<a name="2570"></a> 
 
<h3 class="H1"><a name="CNCPT221"><font face="Arial, Helvetica, sans-serif" color="#330099">How Oracle Manages Data Concurrency and Consistency</font></a></h3> 
 
<a name="2572"></a> 
<p class="BP">Oracle maintains data consistency in a multiuser environment by using a multiversion consistency model and various types of locks and transactions. The following topics are discussed in this section:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="17836"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#17882"><u><font color="#800080">Multiversion Concurrency Control</font></u></a> </li><li class="LB1" type="disc"><a name="17840"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2611"><u><font color="#800080">Statement-Level Read Consistency</font></u></a> </li><li class="LB1" type="disc"><a name="17876"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2627"><u><font color="#800080">Transaction-Level Read Consistency</font></u></a> </li><li class="LB1" type="disc"><a name="17880"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#19443"><u><font color="#800080">Read Consistency with Real Application Clusters</font></u></a> </li><li class="LB1" type="disc"><a name="17885"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2641"><u><font color="#800080">Oracle Isolation Levels</font></u></a> </li><li class="LB1" type="disc"><a name="17893"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2778"><u><font color="#800080">Comparison of Read Committed and Serializable Isolation</font></u></a> </li><li class="LB1" type="disc"><a name="17898"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2799"><u><font color="#800080">Choice of Isolation Level</font></u></a> </li></ul> 
<a name="17882"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Multiversion Concurrency Control</font></h4> 
 
<a name="2578"></a> 
<p class="BP">Oracle automatically provides read consistency to a query so that all the data that the query sees comes from a single point in time <em class="Italic">(</em><strong class="Bold">statement-level read consistency</strong><em class="Italic">)</em>. Oracle can also provide read consistency to all of the queries in a transaction <em class="Italic">(</em><strong class="Bold">transaction-level read consistency</strong><em class="Italic">)</em>.</p> 
<a name="2580"></a> 
<p class="BP">Oracle uses the information maintained in its rollback segments to provide these consistent views. The rollback segments contain the old values of data that have been changed by uncommitted or recently committed transactions. <a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#8842"><u><font color="#800080">Figure 20-1</font></u></a> shows how Oracle provides statement-level read consistency using data in rollback segments.</p> 
<a name="8842"></a> 
<h5 class="FT"><font face="Arial, Helvetica, sans-serif"><em>Figure 20-1 Transactions and Read Consistency</em></font></h5> 
<p><a name="8846"><img alt="Text description of cncpt069.gif follows" src="https://images2.imgbox.com/fb/bf/UIvRSiBi_o.gif"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/img_text/cncpt069.htm"><br><u><font color="#0000ff">Text description of the illustration cncpt069.gif</font></u></a><br><br><a name="8850"></a></p> 
<p class="BP">As a query enters the execution stage, the current system change number (SCN) is determined. In <a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#8842"><u><font color="#800080">Figure 20-1</font></u></a>, this system change number is 10023. As data blocks are read on behalf of the query, only blocks written with the observed SCN are used. Blocks with changed data (more recent SCNs) are reconstructed from data in the rollback segments, and the reconstructed data is returned for the query. Therefore, each query returns all committed data with respect to the SCN recorded at the time that query execution began. Changes of other transactions that occur during a query's execution are not observed, guaranteeing that consistent data is returned for each query.</p> 
<a name="2611"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Statement-Level Read Consistency</font></h4> 
 
<a name="2619"></a> 
<p class="BP">Oracle always enforces <strong class="Bold"><em class="Italic">statement-level</em></strong> read consistency. This guarantees that all the data returned by a single query comes from a single point in time--the time that the query began. Therefore, a query never sees dirty data nor any of the changes made by transactions that commit during query execution. As query execution proceeds, only data committed before the query began is visible to the query. The query does not see changes committed after statement execution begins.</p> 
<a name="21176"></a> 
<p class="BP">A consistent result set is provided for every query, guaranteeing data consistency, with no action on the user's part. The SQL statements <code>SELECT</code>, <code>INSERT</code> with a subquery, <code>UPDATE</code>, and <code>DELETE</code> all query data, either explicitly or implicitly, and all return consistent data. Each of these statements uses a query to determine which data it will affect (<code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>, respectively).</p> 
<a name="21180"></a> 
<p class="BP">A <code>SELECT</code> statement is an explicit query and can have nested queries or a join operation. An <code>INSERT</code> statement can use nested queries. <code>UPDATE</code> and <code>DELETE</code> statements can use <code>WHERE</code> clauses or subqueries to affect only some rows in a table rather than all rows.</p> 
<a name="21181"></a> 
<p class="BP">Queries used in <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements are guaranteed a consistent set of results. However, they do not see the changes made by the DML statement itself. In other words, the query in these operations sees data as it existed before the operation began to make changes.</p> 
<a name="2627"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Transaction-Level Read Consistency</font></h4> 
 
<a name="2639"></a> 
<p class="BP">Oracle also offers the option of enforcing <strong class="Bold">transaction-level read consistency</strong><em class="Italic">.</em> When a transaction executes in serializable mode, all data accesses reflect the state of the database as of the time the transaction began. This means that the data seen by all queries within the same transaction is consistent with respect to a single point in time, except that queries made by a serializable transaction do see changes made by the transaction itself. Transaction-level read consistency produces repeatable reads and does not expose a query to phantoms.</p> 
<a name="19443"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Read Consistency with Real Application Clusters</font></h4> 
 
<a name="19452"></a> 
<p class="BP">Real Application Clusters use a cache-to-cache block transfer mechanism known as Cache Fusion to transfer read-consistent images of blocks from one instance to another. Real Application Clusters does this using high speed, low latency interconnects to satisfy remote requests for data blocks.</p> 
<a name="13683"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="17614"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="17814"></a> <p class="NB"><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/rac.920/a96597/toc.htm"><u><font color="#0000ff">Oracle9i Real Application Clusters Concepts</font></u></a></em> for more information</p></td></tr></tbody></table> 
</div> 
<a name="2641"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Oracle Isolation Levels</font></h4> 
 
<a name="2643"></a> 
<p class="BP">Oracle provides these transaction isolation levels.</p> 
<p><a name="22347"></a> </p> 
<table class="Informal" dir="ltr" title="" cellspacing="0" cellpadding="3" width="100%" border="1"><thead><tr class="Informal"><th class="Informal" align="left"><a name="22350"></a><font face="Arial, Helvetica, sans-serif"><strong>Isolation Level</strong></font></th><th class="Informal" align="left"><a name="22352"></a><font face="Arial, Helvetica, sans-serif"><strong>Description</strong></font></th></tr></thead><tbody><tr class="Informal" align="left"><td class="Informal"><a name="22354"></a> <p class="TB">Read committed</p></td><td class="Informal"><a name="22356"></a> <p class="TB">This is the default transaction isolation level. Each query executed by a transaction sees only data that was committed before the query (not the transaction) began. An Oracle query never reads dirty (uncommitted) data. <a name="22376"></a></p> <p class="TS">Because Oracle does not prevent other transactions from modifying the data read by a query, that data can be changed by other transactions between two executions of the query. Thus, a transaction that executes a given query twice can experience both nonrepeatable read and phantoms.</p></td></tr><tr class="Informal" align="left"><td class="Informal"><a name="22358"></a> <p class="TB">Serializable</p></td><td class="Informal"><a name="22386"></a> <p class="TS">Serializable transactions see only those changes that were committed at the time the transaction began, plus those changes made by the transaction itself through <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements. Serializable transactions do not experience nonrepeatable reads or phantoms.</p></td></tr><tr class="Informal" align="left"><td class="Informal"><a name="22362"></a> <p class="TB">Read-only</p></td><td class="Informal"><a name="22395"></a> <p class="TS">Read-only transactions see only those changes that were committed at the time the transaction began and do not allow <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements.</p></td></tr></tbody></table> 
<a name="2665"></a> 
 
<p></p> 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Set the Isolation Level</font></h5> 
 
<a name="2669"></a> 
<p class="BP">Application designers, application developers, and database administrators can choose appropriate isolation levels for different transactions, depending on the application and workload. You can set the isolation level of a transaction by using one of these statements at the beginning of a transaction:</p> 
<pre class="CE"><a name="2673"></a>SET TRANSACTION ISOLATION LEVEL READ COMMITTED; 
<a name="8655"></a>
<a name="8656"></a>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; 
<a name="8651"></a>
<a name="8652"></a>SET TRANSACTION ISOLATION LEVEL READ ONLY; 
<a name="8648"></a>
</pre> 
<a name="2679"></a> 
<p class="BP">To save the networking and processing cost of beginning each transaction with a <code>SET</code> <code>TRANSACTION</code> statement, you can use the <code>ALTER</code> <code>SESSION</code> statement to set the transaction isolation level for all subsequent transactions:</p> 
<pre class="CE"><a name="2681"></a>ALTER SESSION SET ISOLATION_LEVEL SERIALIZABLE; 
<a name="8659"></a>
<a name="8661"></a>ALTER SESSION SET ISOLATION_LEVEL READ COMMITTED; 
<a name="8660"></a>
</pre> 
<a name="8881"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="8885"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="8886"></a> <p class="NB"><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96540/toc.htm"><u><font color="#0000ff">Oracle9i SQL Reference</font></u></a></em> for detailed information on any of these SQL statements</p></td></tr></tbody></table> 
</div> 
<a name="2689"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Read Committed Isolation</font></h5> 
 
<a name="2695"></a> 
<p class="BP">The default isolation level for Oracle is read committed. This degree of isolation is appropriate for environments where few transactions are likely to conflict. Oracle causes each query to execute with respect to its own materialized view time, thereby permitting nonrepeatable reads and phantoms for multiple executions of a query, but providing higher potential throughput. Read committed isolation is the appropriate level of isolation for environments where few transactions are likely to conflict.</p> 
<a name="2699"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Serializable Isolation</font></h5> 
 
<a name="2705"></a> 
<p class="BP">Serializable isolation is suitable for environments:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="6186"></a>With large databases and short transactions that update only a few rows </li><li class="LB1" type="disc"><a name="2707"></a>Where the chance that two concurrent transactions will modify the same rows is relatively low </li><li class="LB1" type="disc"><a name="2709"></a>Where relatively long-running transactions are primarily read-only </li></ul> 
<a name="2711"></a> 
<p class="BP">Serializable isolation permits concurrent transactions to make only those database changes they could have made if the transactions had been scheduled to execute one after another. Specifically, Oracle permits a serializable transaction to modify a data row only if it can determine that prior changes to the row were made by transactions that had committed when the serializable transaction began.</p> 
<a name="6267"></a> 
<p class="BP">To make this determination efficiently, Oracle uses control information stored in the data block that indicates which rows in the block contain committed and uncommitted changes. In a sense, the block contains a recent history of transactions that affected each row in the block. The amount of history that is retained is controlled by the <code>INITRANS</code> parameter of <code>CREATE</code> <code>TABLE</code> and <code>ALTER</code> <code>TABLE</code>.</p> 
<a name="6262"></a> 
<p class="BP">Under some circumstances, Oracle can have insufficient history information to determine whether a row has been updated by a "too recent" transaction. This can occur when many transactions concurrently modify the same data block, or do so in a very short period. You can avoid this situation by setting higher values of <code>INITRANS</code> for tables that will experience many transactions updating the same blocks. Doing so enables Oracle to allocate sufficient storage in each block to record the history of recent transactions that accessed the block.</p> 
<a name="2715"></a> 
<p class="BP">Oracle generates an error when a serializable transaction tries to update or delete data modified by a transaction that commits <em class="Italic">after</em> the serializable transaction began:</p> 
<pre class="CE"><a name="2717"></a>ORA-08177: Cannot serialize access for this transaction 
<a name="8647"></a>
</pre> 
<a name="8924"></a> 
<p class="BP">When a serializable transaction fails with the "Cannot serialize access" error, the application can take any of several actions:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="8925"></a>Commit the work executed to that point </li><li class="LB1" type="disc"><a name="8926"></a>Execute additional (but different) statements (perhaps after rolling back to a savepoint established earlier in the transaction) </li><li class="LB1" type="disc"><a name="8927"></a>Roll back the entire transaction </li></ul> 
<a name="8922"></a> 
<p class="BP"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#5650"><u><font color="#800080">Figure 20-2</font></u></a> shows an example of an application that rolls back and retries the transaction after it fails with the "Cannot serialize access" error:</p> 
<a name="5650"></a> 
<h5 class="FT"><font face="Arial, Helvetica, sans-serif"><em>Figure 20-2 Serializable Transaction Failure</em></font></h5> 
<p><a name="7098"><img alt="Text description of cncpt103.gif follows" src="https://images2.imgbox.com/57/24/Ogs9SgnY_o.gif"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/img_text/cncpt103.htm"><br><u><font color="#0000ff">Text description of the illustration cncpt103.gif</font></u></a><br><br><a name="2778"></a> 
 </p> 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Comparison of Read Committed and Serializable Isolation</font></h4> 
 
<a name="2786"></a> 
<p class="BP">Oracle gives the application developer a choice of two transaction isolation levels with different characteristics. Both the read committed and serializable isolation levels provide a high degree of consistency and concurrency. Both levels provide the contention-reducing benefits of Oracle's read consistency multiversion concurrency control model and exclusive row-level locking implementation and are designed for real-world application deployment.</p> 
<a name="2790"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Transaction Set Consistency</font></h5> 
 
<a name="6375"></a> 
<p class="BP">A useful way to view the read committed and serializable isolation levels in Oracle is to consider the following scenario: Assume you have a collection of database tables (or any set of data), a particular sequence of reads of rows in those tables, and the set of transactions committed at any particular time. An operation (a query or a transaction) is <strong class="Bold">transaction set consistent</strong> if all its reads return data written by the same set of committed transactions. An operation is not transaction set consistent if some reads reflect the changes of one set of transactions and other reads reflect changes made by other transactions. An operation that is not transaction set consistent in effect sees the database in a state that reflects no single set of committed transactions.</p> 
<a name="2792"></a> 
<p class="BP">Oracle provides transactions executing in read committed mode with transaction set consistency for each statement. Serializable mode provides transaction set consistency for each transaction.</p> 
<a name="6404"></a> 
<p class="BP"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#9033"><u><font color="#800080">Table 20-2</font></u></a> summarizes key differences between read committed and serializable transactions in Oracle.</p> 
<h6 class="TT"><a name="17107"></a><a name="9033"></a><strong><font face="Arial, Helvetica, sans-serif"><em>Table 20-2 Read Committed and Serializable Transactions</em></font></strong></h6> 
<p> </p> 
<table class="Formal" dir="ltr" title="" cellspacing="0" cellpadding="3" width="100%" border="1"><thead><tr class="Formal"><th class="Formal" align="left"><a name="8989"></a></th><th class="Formal" align="left"><a name="9046"></a><font face="Arial, Helvetica, sans-serif"><strong>Read Committed</strong></font></th><th class="Formal" align="left"><a name="9050"></a><font face="Arial, Helvetica, sans-serif"><strong>Serializable</strong></font></th></tr></thead><tbody><tr class="Formal" align="left"><td class="Formal"><a name="9057"></a> <p class="TB">Dirty write</p></td><td class="Formal"><a name="9059"></a> <p class="TB">Not possible</p></td><td class="Formal"><a name="9061"></a> <p class="TB">Not possible</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9064"></a> <p class="TB">Dirty read</p></td><td class="Formal"><a name="9066"></a> <p class="TB">Not possible</p></td><td class="Formal"><a name="9068"></a> <p class="TB">Not possible</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9071"></a> <p class="TB">Nonrepeatable read</p></td><td class="Formal"><a name="9073"></a> <p class="TB">Possible</p></td><td class="Formal"><a name="9075"></a> <p class="TB">Not possible</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9078"></a> <p class="TB">Phantoms</p></td><td class="Formal"><a name="9080"></a> <p class="TB">Possible</p></td><td class="Formal"><a name="9082"></a> <p class="TB">Not possible</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9085"></a> <p class="TB">Compliant with ANSI/ISO SQL 92</p></td><td class="Formal"><a name="9087"></a> <p class="TB">Yes</p></td><td class="Formal"><a name="9089"></a> <p class="TB">Yes</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9092"></a> <p class="TB">Read materialized view time</p></td><td class="Formal"><a name="9094"></a> <p class="TB">Statement</p></td><td class="Formal"><a name="9096"></a> <p class="TB">Transaction</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9099"></a> <p class="TB">Transaction set consistency</p></td><td class="Formal"><a name="9101"></a> <p class="TB">Statement level</p></td><td class="Formal"><a name="9103"></a> <p class="TB">Transaction level</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9106"></a> <p class="TB">Row-level locking</p></td><td class="Formal"><a name="9108"></a> <p class="TB">Yes</p></td><td class="Formal"><a name="9110"></a> <p class="TB">Yes</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9113"></a> <p class="TB">Readers block writers</p></td><td class="Formal"><a name="9115"></a> <p class="TB">No</p></td><td class="Formal"><a name="9117"></a> <p class="TB">No</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9120"></a> <p class="TB">Writers block readers</p></td><td class="Formal"><a name="9122"></a> <p class="TB">No</p></td><td class="Formal"><a name="9124"></a> <p class="TB">No</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9127"></a> <p class="TB">Different-row writers block writers</p></td><td class="Formal"><a name="9129"></a> <p class="TB">No</p></td><td class="Formal"><a name="9131"></a> <p class="TB">No</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9134"></a> <p class="TB">Same-row writers block writers</p></td><td class="Formal"><a name="9136"></a> <p class="TB">Yes</p></td><td class="Formal"><a name="9138"></a> <p class="TB">Yes</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9141"></a> <p class="TB">Waits for blocking transaction</p></td><td class="Formal"><a name="9143"></a> <p class="TB">Yes</p></td><td class="Formal"><a name="9145"></a> <p class="TB">Yes</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9148"></a> <p class="TB">Subject to "cannot serialize access"</p></td><td class="Formal"><a name="9150"></a> <p class="TB">No</p></td><td class="Formal"><a name="9152"></a> <p class="TB">Yes</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9155"></a> <p class="TB">Error after blocking transaction terminatess</p></td><td class="Formal"><a name="9157"></a> <p class="TB">No</p></td><td class="Formal"><a name="9159"></a> <p class="TB">No</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9161"></a> <p class="TB">Error after blocking transaction commits</p></td><td class="Formal"><a name="9163"></a> <p class="TB">No</p></td><td class="Formal"><a name="9165"></a> <p class="TB">Yes</p></td></tr></tbody></table> 
<a name="6297"></a> 
 
<p></p> 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Row-Level Locking</font></h5> 
 
<a name="6299"></a> 
<p class="BP">Both read committed and serializable transactions use row-level locking, and both will wait if they try to change a row updated by an uncommitted concurrent transaction. The second transaction that tries to update a given row waits for the other transaction to commit or roll back and release its lock. If that other transaction rolls back, the waiting transaction, regardless of its isolation mode, can proceed to change the previously locked row as if the other transaction had not existed.</p> 
<a name="6298"></a> 
<p class="BP">However, if the other blocking transaction commits and releases its locks, a read committed transaction proceeds with its intended update. A serializable transaction, however, fails with the error "Cannot serialize access", because the other transaction has committed a change that was made since the serializable transaction began.</p> 
<a name="6321"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Referential Integrity</font></h5> 
 
<a name="6323"></a> 
<p class="BP">Because Oracle does not use read locks in either read-consistent or serializable transactions, data read by one transaction can be overwritten by another. Transactions that perform database consistency checks at the application level cannot assume that the data they read will remain unchanged during the execution of the transaction even though such changes are not visible to the transaction. Database inconsistencies can result unless such application-level consistency checks are coded with this in mind, even when using serializable transactions.</p> 
<a name="9172"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="9175"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="9176"></a> <p class="NB"><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/appdev.920/a96590/toc.htm"><u><font color="#0000ff">Oracle9i Application Developer's Guide - Fundamentals</font></u></a></em> for more information about referential integrity and serializable transactions</p></td></tr></tbody></table> 
</div> 
<a name="6330"></a> 
<div align="center"> 
 <table class="Note" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="Note"><td class="Note"> 
     <hr> <a name="18212"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Note:</strong></font> <a name="18213"></a> <p class="NB">You can use both read committed and serializable transaction isolation levels with Real Application Clusters.</p> 
     <hr> </td></tr></tbody></table> 
</div> 
<a name="6347"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Distributed Transactions</font></h5> 
 
<a name="6333"></a> 
<p class="BP">In a distributed database environment, a given transaction updates data in multiple physical databases protected by two-phase commit to ensure all nodes or none commit. In such an environment, all servers, whether Oracle or non-Oracle, that participate in a <strong class="Bold">serializable</strong> transaction are required to support serializable isolation mode.</p> 
<a name="6358"></a> 
<p class="BP">If a serializable transaction tries to update data in a database managed by a server that does not support serializable transactions, the transaction receives an error. The transaction can roll back and retry only when the remote server does support serializable transactions.</p> 
<a name="6369"></a> 
<p class="BP">In contrast, <strong class="Bold">read committed</strong> transactions can perform distributed transactions with servers that do not support serializable transactions.</p> 
<a name="18028"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="17908"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="17909"></a> <p class="NB"><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96521/toc.htm"><u><font color="#0000ff">Oracle9i Database Administrator's Guide</font></u></a></em></p></td></tr></tbody></table> 
</div> 
<a name="2799"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Choice of Isolation Level</font></h4> 
 
<a name="2803"></a> 
<p class="BP">Application designers and developers should choose an isolation level based on application performance and consistency needs as well as application coding requirements.</p> 
<a name="2805"></a> 
<p class="BP">For environments with many concurrent users rapidly submitting transactions, designers must assess transaction performance requirements in terms of the expected transaction arrival rate and response time demands. Frequently, for high-performance environments, the choice of isolation levels involves a trade-off between consistency and concurrency.</p> 
<a name="6538"></a> 
<p class="BP">Application logic that checks database consistency must take into account the fact that reads do not block writes in either mode.</p> 
<a name="2807"></a> 
<p class="BP">Oracle isolation modes provide high levels of consistency, concurrency, and performance through the combination of row-level locking and Oracle's multiversion concurrency control system. Readers and writers do not block one another in Oracle. Therefore, while queries still see consistent data, both read committed and serializable isolation provide a high level of concurrency for high performance, without the need for reading uncommitted ("dirty") data.</p> 
<a name="2811"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Read Committed Isolation</font></h5> 
 
<a name="2813"></a> 
<p class="BP">For many applications, read committed is the most appropriate isolation level. Read committed isolation can provide considerably more concurrency with a somewhat increased risk of inconsistent results due to phantoms and non-repeatable reads for some transactions.</p> 
<a name="6556"></a> 
<p class="BP">Many high-performance environments with high transaction arrival rates require more throughput and faster response times than can be achieved with serializable isolation. Other environments that supports users with a very low transaction arrival rate also face very low risk of incorrect results due to phantoms and nonrepeatable reads. Read committed isolation is suitable for both of these environments.</p> 
<a name="2817"></a> 
<p class="BP">Oracle read committed isolation provides transaction set consistency for every query. That is, every query sees data in a consistent state. Therefore, read committed isolation will suffice for many applications that might require a higher degree of isolation if run on other database management systems that do not use multiversion concurrency control.</p> 
<a name="2819"></a> 
<p class="BP">Read committed isolation mode does not require application logic to trap the "Cannot serialize access" error and loop back to restart a transaction. In most applications, few transactions have a functional need to issue the same query twice, so for many applications protection against phantoms and non-repeatable reads is not important. Therefore many developers choose read committed to avoid the need to write such error checking and retry code in each transaction.</p> 
<a name="2821"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Serializable Isolation</font></h5> 
 
<a name="2823"></a> 
<p class="BP">Oracle's serializable isolation is suitable for environments where there is a relatively low chance that two concurrent transactions will modify the same rows and the long-running transactions are primarily read-only. It is most suitable for environments with large databases and short transactions that update only a few rows.</p> 
<a name="2825"></a> 
<p class="BP">Serializable isolation mode provides somewhat more consistency by protecting against phantoms and nonrepeatable reads and can be important where a read/write transaction executes a query more than once.</p> 
<a name="6551"></a> 
<p class="BP">Unlike other implementations of serializable isolation, which lock blocks for read as well as write, Oracle provides nonblocking queries and the fine granularity of row-level locking, both of which reduce write/write contention. For applications that experience mostly read/write contention, Oracle serializable isolation can provide significantly more throughput than other systems. Therefore, some applications might be suitable for serializable isolation on Oracle but not on other systems.</p> 
<a name="2827"></a> 
<p class="BP">All queries in an Oracle serializable transaction see the database as of a single point in time, so this isolation level is suitable where multiple consistent queries must be issued in a read/write transaction. A report-writing application that generates summary data and stores it in the database might use serializable mode because it provides the consistency that a <code>READ</code> <code>ONLY</code> transaction provides, but also allows <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>.</p> 
<a name="13492"></a> 
<div align="center"> 
 <table class="Note" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="Note"><td class="Note"> 
     <hr> <a name="13495"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Note:</strong></font> <a name="13496"></a> <p class="NB">Transactions containing DML statements with subqueries should use serializable isolation to guarantee consistent read.</p> 
     <hr> </td></tr></tbody></table> 
</div> 
<a name="2829"></a> 
<p class="BP">Coding serializable transactions requires extra work by the application developer to check for the "Cannot serialize access" error and to roll back and retry the transaction. Similar extra coding is needed in other database management systems to manage deadlocks. For adherence to corporate standards or for applications that are run on multiple database management systems, it may be necessary to design transactions for serializable mode. Transactions that check for serializability failures and retry can be used with Oracle read committed mode, which does not generate serializability errors.</p> 
<a name="2831"></a> 
<p class="BP">Serializable mode is probably not the best choice in an environment with relatively long transactions that must update the same rows accessed by a high volume of short update transactions. Because a longer running transaction is unlikely to be the first to modify a given row, it will repeatedly need to roll back, wasting work. Note that a conventional read-locking, pessimistic implementation of serializable mode would not be suitable for this environment either, because long-running transactions--even read transactions--would block the progress of short update transactions and vice versa.)</p> 
<a name="2833"></a> 
<p class="BP">Application developers should take into account the cost of rolling back and retrying transactions when using serializable mode. As with read-locking systems, where deadlocks occur frequently, use of serializable mode requires rolling back the work done by terminated transactions and retrying them. In a high contention environment, this activity can use significant resources.</p> 
<a name="2835"></a> 
<p class="BP">In most environments, a transaction that restarts after receiving the "Cannot serialize access" error is unlikely to encounter a second conflict with another transaction. For this reason it can help to execute those statements most likely to contend with other transactions as early as possible in a serializable transaction. However, there is no guarantee that the transaction will complete successfully, so the application should be coded to limit the number of retries.</p> 
<a name="2837"></a> 
<p class="BP">Although Oracle serializable mode is compatible with SQL92 and offers many benefits compared with read-locking implementations, it does not provide semantics identical to such systems. Application designers must take into account the fact that reads in Oracle do not block writes as they do in other systems. Transactions that check for database consistency at the application level can require coding techniques such as the use of <code>SELECT</code> <code>FOR</code> <code>UPDATE</code>. This issue should be considered when applications using serializable mode are ported to Oracle from other environments.</p> 
<a name="19024"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Quiesce Database</font></h5> 
 
<a name="20357"></a> 
<p class="BP">You can put the system into <strong class="GlossaryTerm">quiesced state</strong>. The system is in quiesced state if there are no active sessions, other than <code>SYS</code> and <code>SYSTEM</code>. An active session is defined as a session that is currently inside a transaction, a query, a fetch or a PL/SQL procedure, or a session that is currently holding any shared resources (for example, enqueues). Database administrators are the only users who can proceed when the system is in quiesced state.</p> 
<a name="19063"></a> 
<p class="BP">Database administrators can perform certain actions in the quiesced state that cannot be safely done when the system is not quiesced. These actions include:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="19039"></a>Actions that might fail if there are concurrent user transactions or queries. For example, changing the schema of a database table will fail if a concurrent transaction is accessing the same table. </li><li class="LB1" type="disc"><a name="19040"></a>Actions whose intermediate effect could be detrimental to concurrent user transactions or queries. For example: 
  <ol class="LN2" type="1"><li class="LN2" type="1" value="1"><a name="19071"></a>Change the schema of a database table. </li><li class="LN2" type="1" value="2"><a name="19076"></a>Update a PL/SQL procedure to a new version that uses this new schema of the database table. </li></ol><a name="19081"></a> <p class="BP1">Between Step 1 and Step 2, the new schema of the table is inconsistent with the implementation of the PL/SQL procedure. This inconsistency would adversely affect users concurrently trying to execute the PL/SQL procedure.</p></li></ul> 
<a name="19041"></a> 
<p class="BP">For systems that must operate continuously, the ability to perform such actions without shutting down the database is critical.</p> 
<a name="19042"></a> 
<p class="BP">The Database Resource Manager blocks all actions that were initiated by a user other than <code>SYS</code> or <code>SYSTEM</code> while the system is quiesced. Such actions are allowed to proceed when the system goes back to normal (unquiesced) state. Users do not get any additional error messages from the quiesced state.</p> 
<a name="19290"></a> 
 
<h6 class="H4"><font face="Arial, Helvetica, sans-serif" color="#330099">How a Database Is Quiesced</font></h6> 
 
<a name="21185"></a> 
<p class="BP">The database administrator uses the <code>ALTER</code> <code>SYSTEM</code> <code>QUIESCE</code> <code>RESTRICTED</code> statement to quiesce the database. Only users <code>SYS</code> and <code>SYSTEM</code> can issue the <code>ALTER</code> <code>SYSTEM</code> <code>QUIESCE</code> <code>RESTRICTED</code> statement. For all instances with the database open, issuing this statement has the following effect:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="20457"></a>Oracle instructs the Database Resource Manager in all instances to prevent all inactive sessions (other than <code>SYS</code> and <code>SYSTEM</code>) from becoming active. No user other than <code>SYS</code> and <code>SYSTEM</code> can start a new transaction, a new query, a new fetch, or a new PL/SQL operation. </li><li class="LB1" type="disc"><a name="20458"></a>Oracle waits for all existing transactions in all instances that were initiated by a user other than <code>SYS</code> or <code>SYSTEM</code> to finish (either commit or terminate). Oracle also waits for all running queries, fetches, and PL/SQL procedures in all instances that were initiated by users other than <code>SYS</code> or <code>SYSTEM</code> and that are not inside transactions to finish. If a query is carried out by multiple successive OCI fetches, Oracle does not wait for all fetches to finish. It waits for the current fetch to finish and then blocks the next fetch. Oracle also waits for all sessions (other than those of <code>SYS</code> or <code>SYSTEM</code>) that hold any shared resources (such as enqueues) to release those resources. After all these operations finish, Oracle places the database into quiesced state and finishes executing the <code>QUIESCE</code> <code>RESTRICTED</code> statement. </li><li class="LB1" type="disc"><a name="20459"></a>If an instance is running in shared server mode, Oracle instructs the Database Resource Manager to block logins (other than <code>SYS</code> or <code>SYSTEM</code>) on that instance. If an instance is running in non-shared-server mode, Oracle does not impose any restrictions on user logins in that instance. </li></ul> 
<a name="20460"></a> 
<p class="BP">During the quiesced state, you cannot change the Resource Manager plan in any instance.</p> 
<a name="19246"></a> 
<p class="BP">The <code>ALTER</code> <code>SYSTEM</code> <code>UNQUIESCE</code> statement puts all running instances back into normal mode, so that all blocked actions can proceed.</p> 
<a name="19256"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="19249"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="19250"></a> 
     <ul class="NL"><li class="NL" type="disc"><a name="19254"></a><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96540/toc.htm"><u><font color="#0000ff">Oracle9i SQL Reference</font></u></a></em> </li><li class="NL" type="disc"><a name="19255"></a><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96521/toc.htm"><u><font color="#0000ff">Oracle9i Database Administrator's Guide</font></u></a></em> </li></ul></td></tr></tbody></table> 
</div> 
<a name="2841"></a> 
 
<h3 class="H1"><a name="CNCPT321"><font face="Arial, Helvetica, sans-serif" color="#330099">How Oracle Locks Data</font></a></h3> 
 
<a name="2847"></a> 
<p class="BP"><em class="Italic">Locks</em> are mechanisms that prevent destructive interaction between transactions accessing the same <strong class="Bold">resource</strong>--either user objects such as tables and rows or system objects not visible to users, such as shared data structures in memory and data dictionary rows.</p> 
<a name="18112"></a> 
<p class="BP">In all cases, Oracle automatically obtains necessary locks when executing SQL statements, so users need not be concerned with such details. Oracle automatically uses the lowest applicable level of restrictiveness to provide the highest degree of data concurrency yet also provide fail-safe data integrity. Oracle also allows the user to lock data manually.</p> 
<a name="18123"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="18115"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="18122"></a> <p class="NB"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2937"><u><font color="#800080">"Types of Locks"</font></u></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#2937"></a></p></td></tr></tbody></table> 
</div> 
<a name="18124"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Transactions and Data Concurrency</font></h4> 
 
<a name="2879"></a> 
<p class="BP">Oracle provides data concurrency and integrity between transactions using its locking mechanisms. Because the locking mechanisms of Oracle are tied closely to transaction control, application designers need only define transactions properly, and Oracle automatically manages locking.</p> 
<a name="6660"></a> 
<p class="BP">Keep in mind that Oracle locking is fully automatic and requires no user action. Implicit locking occurs for all SQL statements so that database users never need to lock any resource explicitly. Oracle's default locking mechanisms lock data at the lowest level of restrictiveness to guarantee data integrity while allowing the highest degree of data concurrency.</p> 
<a name="18034"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="17647"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="17648"></a> <p class="NB"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#3330"><u><font color="#800080">"Explicit (Manual) Data Locking"</font></u></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#3330"></a></p></td></tr></tbody></table> 
</div> 
<a name="2881"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Modes of Locking</font></h5> 
 
<a name="6016"></a> 
<p class="BP">Oracle uses two modes of locking in a multiuser database:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="22406"></a>Exclusive lock mode prevents the associates resource from being shared. This lock mode is obtained to modify data. The first transaction to lock a resource exclusively is the only transaction that can alter the resource until the exclusive lock is released. </li><li class="LB1" type="disc"><a name="22413"></a>Share lock mode allows the associated resource to be shared, depending on the operations involved. Multiple users reading data can share the data, holding share locks to prevent concurrent access by a writer (who needs an exclusive lock). Several transactions can acquire share locks on the same resource. </li></ul> 
<a name="6015"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Lock Duration</font></h5> 
 
<a name="2883"></a> 
<p class="BP">All locks acquired by statements within a transaction are held for the duration of the transaction, preventing destructive interference including dirty reads, lost updates, and destructive DDL operations from concurrent transactions. The changes made by the SQL statements of one transaction become visible only to other transactions that start <em class="Italic">after</em> the first transaction is committed.</p> 
<a name="2885"></a> 
<p class="BP">Oracle releases all locks acquired by the statements within a transaction when you either commit or roll back the transaction. Oracle also releases locks acquired after a savepoint when rolling back to the savepoint. However, only transactions not waiting for the previously locked resources can acquire locks on the now available resources. Waiting transactions will continue to wait until after the original transaction commits or rolls back completely.</p> 
<a name="2891"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Data Lock Conversion Versus Lock Escalation</font></h5> 
 
<a name="2901"></a> 
<p class="BP">A transaction holds exclusive row locks for all rows inserted, updated, or deleted within the transaction. Because row locks are acquired at the highest degree of restrictiveness, no lock conversion is required or performed.</p> 
<a name="2903"></a> 
<p class="BP">Oracle automatically converts a table lock of lower restrictiveness to one of higher restrictiveness as appropriate. For example, assume that a transaction uses a <code>SELECT</code> statement with the <code>FOR</code> <code>UPDATE</code> clause to lock rows of a table. As a result, it acquires the exclusive row locks and a row share table lock for the table. If the transaction later updates one or more of the locked rows, the row share table lock is automatically converted to a row exclusive table lock.</p> 
<a name="6111"></a> 
<p class="BP"><strong class="Bold">Lock escalation</strong> occurs when numerous locks are held at one level of granularity (for example, rows) and a database raises the locks to a higher level of granularity (for example, table). For example, if a single user locks many rows in a table, some databases automatically escalate the user's row locks to a single table. The number of locks is reduced, but the restrictiveness of what is being locked is increased.</p> 
<a name="6112"></a> 
<p class="BP"><em class="Italic">Oracle never escalates locks.</em> Lock escalation greatly increases the likelihood of deadlocks. Imagine the situation where the system is trying to escalate locks on behalf of transaction T1 but cannot because of the locks held by transaction T2. A deadlock is created if transaction T2 also requires lock escalation of the same data before it can proceed.</p> 
<a name="18037"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="17663"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="17664"></a> <p class="NB"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#3017"><u><font color="#800080">"Table Locks (TM)"</font></u></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#3017"></a></p></td></tr></tbody></table> 
</div> 
<a name="6037"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Deadlocks</font></h4> 
 
<a name="6042"></a> 
<p class="BP">A <strong class="Bold">deadlock</strong> can occur when two or more users are waiting for data locked by each other. Deadlocks prevent some transactions from continuing to work. <a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#6047"><u><font color="#800080">Figure 20-3</font></u></a> illustrates two transactions in a deadlock.</p> 
<a name="9216"></a> 
<p class="BP">In <a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#6047"><u><font color="#800080">Figure 20-3</font></u></a>, no problem exists at time point A, as each transaction has a row lock on the row it attempts to update. Each transaction proceeds without being terminated. However, each tries next to update the row currently held by the other transaction. Therefore, a deadlock results at time point B, because neither transaction can obtain the resource it needs to proceed or terminate. It is a deadlock because no matter how long each transaction waits, the conflicting locks are held.</p> 
<a name="6047"></a> 
<h5 class="FT"><font face="Arial, Helvetica, sans-serif"><em>Figure 20-3 Two Transactions in a Deadlock</em></font></h5> 
<p><a name="6051"><img alt="Text description of cncpt068.gif follows" src="https://images2.imgbox.com/e7/ed/lriS6oC9_o.gif"></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/img_text/cncpt068.htm"><br><u><font color="#0000ff">Text description of the illustration cncpt068.gif</font></u></a><br><br><a name="2907"></a> 
 </p> 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Deadlock Detection</font></h5> 
 
<a name="2913"></a> 
<p class="BP">Oracle automatically detects deadlock situations and resolves them by rolling back one of the statements involved in the deadlock, thereby releasing one set of the conflicting row locks. A corresponding message also is returned to the transaction that undergoes statement-level rollback. The statement rolled back is the one belonging to the transaction that detects the deadlock. Usually, the signalled transaction should be rolled back explicitly, but it can retry the rolled-back statement after waiting. </p> 
<a name="9196"></a> 
<div align="center"> 
 <table class="Note" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="Note"><td class="Note"> 
     <hr> <a name="9203"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Note:</strong></font> <a name="9204"></a> <p class="NB">In distributed transactions, local deadlocks are detected by analyzing a "waits for" graph, and global deadlocks are detected by a time-out. Once detected, nondistributed and distributed deadlocks are handled by the database and application in the same way.</p> 
     <hr> </td></tr></tbody></table> 
</div> 
<a name="2925"></a> 
<p class="BP">Deadlocks most often occur when transactions explicitly override the default locking of Oracle. Because Oracle itself does no lock escalation and does not use read locks for queries, but does use row-level locking (rather than page-level locking), deadlocks occur infrequently in Oracle.</p> 
<a name="18040"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="17680"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="17681"></a> <p class="NB"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#3330"><u><font color="#800080">"Explicit (Manual) Data Locking"</font></u></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#3330"></a> for more information about manually acquiring locks</p></td></tr></tbody></table> 
</div> 
<a name="2927"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Avoid Deadlocks</font></h5> 
 
<a name="2933"></a> 
<p class="BP">Multitable deadlocks can usually be avoided if transactions accessing the same tables lock those tables in the same order, either through implicit or explicit locks. For example, all application developers might follow the rule that when both a master and detail table are updated, the master table is locked first and then the detail table. If such rules are properly designed and then followed in all applications, deadlocks are very unlikely to occur.</p> 
<a name="2935"></a> 
<p class="BP">When you know you will require a sequence of locks for one transaction, consider acquiring the most exclusive (least compatible) lock first.</p> 
<a name="2937"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Types of Locks</font></h4> 
 
<a name="2943"></a> 
<p class="BP">Oracle automatically uses different types of locks to control concurrent access to data and to prevent destructive interaction between users. Oracle automatically locks a resource on behalf of a transaction to prevent other transactions from doing something also requiring exclusive access to the same resource. The lock is released automatically when some event occurs so that the transaction no longer requires the resource.</p> 
<a name="2957"></a> 
<p class="BP">Throughout its operation, Oracle automatically acquires different types of locks at different levels of restrictiveness depending on the resource being locked and the operation being performed.</p> 
<a name="9232"></a> 
<p class="BP">Oracle locks fall into one of three general categories.</p> 
<p><a name="22423"></a> </p> 
<table class="Informal" dir="ltr" title="" cellspacing="0" cellpadding="3" width="100%" border="1"><thead><tr class="Informal"><th class="Informal" align="left"><a name="22426"></a><font face="Arial, Helvetica, sans-serif"><strong>Lock</strong></font></th><th class="Informal" align="left"><a name="22428"></a><font face="Arial, Helvetica, sans-serif"><strong>Description</strong></font></th></tr></thead><tbody><tr class="Informal" align="left"><td class="Informal"><a name="22445"></a> <p class="TS">DML locks (data locks)</p></td><td class="Informal"><a name="22454"></a> <p class="TS">DML locks protect data. For example, table locks lock entire tables, row locks lock selected rows.</p></td></tr><tr class="Informal" align="left"><td class="Informal"><a name="22463"></a> <p class="TS">DDL locks (dictionary locks)</p></td><td class="Informal"><a name="22472"></a> <p class="TS">DDL locks protect the structure of schema objects--for example, the definitions of tables and views.</p></td></tr><tr class="Informal" align="left"><td class="Informal"><a name="22481"></a> <p class="TS">Internal locks and latches</p></td><td class="Informal"><a name="22490"></a> <p class="TS">Internal locks and latches protect internal database structures such as datafiles. Internal locks and latches are entirely automatic.</p></td></tr></tbody></table> 
<a name="2987"></a> 
<p></p> 
<p class="BP">The following sections discuss DML locks, DDL locks, and internal locks.</p> 
<a name="2989"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">DML Locks</font></h4> 
 
<a name="2995"></a> 
<p class="BP">The purpose of a DML (data) lock is to guarantee the integrity of data being accessed concurrently by multiple users. DML locks prevent destructive interference of simultaneous conflicting DML or DDL operations. For example, Oracle DML locks guarantee that a specific row in a table can be updated by only one transaction at a time and that a table cannot be dropped if an uncommitted transaction contains an insert into the table.</p> 
<a name="2997"></a> 
<p class="BP">DML operations can acquire data locks at two different levels: for specific rows and for entire tables.</p> 
<a name="9233"></a> 
<div align="center"> 
 <table class="Note" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="Note"><td class="Note"> 
     <hr> <a name="9236"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Note:</strong></font> <a name="9241"></a> <p class="NB">The acronym in parentheses after each type of lock or lock mode is the abbreviation used in the Locks Monitor of Enterprise Manager. Enterprise Manager might display TM for any table lock, rather than indicate the mode of table lock (such as RS or SRX).</p> 
     <hr> </td></tr></tbody></table> 
</div> 
<a name="2999"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Row Locks (TX)</font></h5> 
 
<a name="6615"></a> 
<p class="BP">The only DML locks Oracle acquires automatically are row-level locks. There is no limit to the number of row locks held by a statement or transaction, and Oracle does not escalate locks from the row level to a coarser granularity. Row locking provides the finest grain locking possible and so provides the best possible concurrency and throughput.</p> 
<a name="6616"></a> 
<p class="BP">The combination of multiversion concurrency control and row-level locking means that users contend for data only when accessing the same rows, specifically:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="6618"></a>Readers of data do not wait for writers of the same data rows. </li><li class="LB1" type="disc"><a name="6619"></a>Writers of data do not wait for readers of the same data rows unless <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> is used, which specifically requests a lock for the reader. </li><li class="LB1" type="disc"><a name="6620"></a>Writers only wait for other writers if they attempt to update the same rows at the same time. <p><a name="9282"></a></p> 
  <div align="center"> 
   <table class="Note" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="Note"><td class="Note"> 
       <hr> <a name="9285"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Note:</strong></font> <a name="9286"></a> <p class="NB">Readers of data may have to wait for writers of the same data blocks in some very special cases of pending distributed transactions.</p> 
       <hr> </td></tr></tbody></table> 
  </div></li></ul> 
<a name="21189"></a> 
<p class="BP">A transaction acquires an exclusive DML lock for each individual row modified by one of the following statements: <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>SELECT</code> with the <code>FOR</code> <code>UPDATE</code> clause.</p> 
<a name="3011"></a> 
<p class="BP">A modified row is <strong class="Bold">always</strong> locked exclusively so that other users cannot modify the row until the transaction holding the lock is committed or rolled back. However, if the transaction dies due to instance failure, block-level recovery makes a row available before the entire transaction is recovered. Row locks are always acquired automatically by Oracle as a result of the statements listed previously.</p> 
<a name="5280"></a> 
<p class="BP">If a transaction obtains a row lock for a row, the transaction also acquires a table lock for the corresponding table. The table lock prevents conflicting DDL operations that would override data changes in a current transaction.</p> 
<a name="18044"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="17699"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="19708"></a> <p class="NB"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#3188"><u><font color="#800080">"DDL Locks"</font></u></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#3188"></a></p></td></tr></tbody></table> 
</div> 
<a name="3017"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Table Locks (TM)</font></h5> 
 
<a name="21195"></a> 
<p class="BP">A transaction acquires a table lock when a table is modified in the following DML statements: <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>SELECT</code> with the <code>FOR</code> <code>UPDATE</code> clause, and <code>LOCK</code> <code>TABLE</code>. These DML operations require table locks for two purposes: to reserve DML access to the table on behalf of a transaction and to prevent DDL operations that would conflict with the transaction. Any table lock prevents the acquisition of an exclusive DDL lock on the same table and thereby prevents DDL operations that require such locks. For example, a table cannot be altered or dropped if an uncommitted transaction holds a table lock for it.</p> 
<a name="5296"></a> 
<p class="BP">A table lock can be held in any of several modes: row share (RS), row exclusive (RX), share (S), share row exclusive (SRX), and exclusive (X). The restrictiveness of a table lock's mode determines the modes in which other table locks on the same table can be obtained and held.</p> 
<a name="3032"></a> 
<p class="BP"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#9975"><u><font color="#800080">Table 20-3</font></u></a> shows the table lock modes that statements acquire and operations that those locks permit and prohibit.</p> 
<h6 class="TT"><a name="21817"></a><a name="9975"></a><strong><font face="Arial, Helvetica, sans-serif"><em>Table 20-3 Summary of Table Locks  </em></font></strong></h6> 
<p> </p> 
<table class="Formal" dir="ltr" title="" cellspacing="0" cellpadding="3" width="100%" border="1"><thead><tr class="Formal"><th class="Formal" rowspan="2"><a name="9921"></a><font face="Arial, Helvetica, sans-serif"><strong>SQL Statement</strong></font></th><th class="Formal" rowspan="2"><a name="9923"></a><font face="Arial, Helvetica, sans-serif"><strong>Mode of Table Lock</strong></font></th><th class="Formal" colspan="5"><a name="9925"></a><font face="Arial, Helvetica, sans-serif"><strong>Lock Modes Permitted?</strong></font></th></tr></thead><thead><tr class="Formal"><th class="Formal" align="left"><a name="9939"></a><font face="Arial, Helvetica, sans-serif"><strong>RS</strong></font></th><th class="Formal" align="left"><a name="9941"></a><font face="Arial, Helvetica, sans-serif"><strong>RX</strong></font></th><th class="Formal" align="left"><a name="9943"></a><font face="Arial, Helvetica, sans-serif"><strong>S</strong></font></th><th class="Formal" align="left"><a name="9945"></a><font face="Arial, Helvetica, sans-serif"><strong>SRX</strong></font></th><th class="Formal" align="left"><a name="9947"></a><font face="Arial, Helvetica, sans-serif"><strong>X</strong></font></th></tr></thead><tbody><tr class="Formal" align="left"><td class="Formal"><a name="9834"></a> <p class="TB"><code>SELECT...FROM</code> <em><code>table</code></em><code>...</code></p></td><td class="Formal"><a name="9836"></a> <p class="TB">none</p></td><td class="Formal"><a name="9838"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9840"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9842"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9844"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9846"></a> <p class="TB">Y</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9820"></a> <p class="TB"><code>INSERT INTO</code> <em><code>table</code></em> <code>...</code></p></td><td class="Formal"><a name="9822"></a> <p class="TB">RX</p></td><td class="Formal"><a name="9824"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9826"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9828"></a> <p class="TB">N</p></td><td class="Formal"><a name="9830"></a> <p class="TB">N</p></td><td class="Formal"><a name="9832"></a> <p class="TB">N</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9806"></a> <p class="TB"><code>UPDATE</code> <em><code>table</code></em> <code>...</code></p></td><td class="Formal"><a name="9808"></a> <p class="TB">RX</p></td><td class="Formal"><a name="9810"></a> <p class="TB">Y*</p></td><td class="Formal"><a name="9812"></a> <p class="TB">Y*</p></td><td class="Formal"><a name="9814"></a> <p class="TB">N</p></td><td class="Formal"><a name="9816"></a> <p class="TB">N</p></td><td class="Formal"><a name="9818"></a> <p class="TB">N</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9792"></a> <p class="TB"><code>DELETE FROM</code> <em><code>table</code></em> <code>...</code></p></td><td class="Formal"><a name="9794"></a> <p class="TB">RX</p></td><td class="Formal"><a name="9796"></a> <p class="TB">Y*</p></td><td class="Formal"><a name="9798"></a> <p class="TB">Y*</p></td><td class="Formal"><a name="9800"></a> <p class="TB">N</p></td><td class="Formal"><a name="9802"></a> <p class="TB">N</p></td><td class="Formal"><a name="9804"></a> <p class="TB">N</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9778"></a> <p class="TB"><code>SELECT ... FROM</code> <em><code>table</code></em> <code>   FOR UPDATE OF ...</code></p></td><td class="Formal"><a name="9780"></a> <p class="TB">RS</p></td><td class="Formal"><a name="9782"></a> <p class="TB">Y*</p></td><td class="Formal"><a name="9784"></a> <p class="TB">Y*</p></td><td class="Formal"><a name="9786"></a> <p class="TB">Y*</p></td><td class="Formal"><a name="9788"></a> <p class="TB">Y*</p></td><td class="Formal"><a name="9790"></a> <p class="TB">N</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9764"></a> <p class="TB"><code>LOCK TABLE</code> <em><code>table</code></em> <code>IN    ROW SHARE MODE</code></p></td><td class="Formal"><a name="9766"></a> <p class="TB">RS</p></td><td class="Formal"><a name="9768"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9770"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9772"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9774"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9776"></a> <p class="TB">N</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9750"></a> <p class="TB"><code>LOCK TABLE</code> <em><code>table</code></em> <code>IN    ROW EXCLUSIVE MODE</code></p></td><td class="Formal"><a name="9752"></a> <p class="TB">RX</p></td><td class="Formal"><a name="9754"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9756"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9758"></a> <p class="TB">N</p></td><td class="Formal"><a name="9760"></a> <p class="TB">N</p></td><td class="Formal"><a name="9762"></a> <p class="TB">N</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9736"></a> <p class="TB"><code>LOCK TABLE</code> <em><code>table</code></em> <code>IN    SHARE MODE</code></p></td><td class="Formal"><a name="9738"></a> <p class="TB">S</p></td><td class="Formal"><a name="9740"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9742"></a> <p class="TB">N</p></td><td class="Formal"><a name="9744"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9746"></a> <p class="TB">N</p></td><td class="Formal"><a name="9748"></a> <p class="TB">N</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9722"></a> <p class="TB"><code>LOCK TABLE</code> <em><code>table</code></em> <code>IN    SHARE ROW EXCLUSIVE    MODE</code></p></td><td class="Formal"><a name="9724"></a> <p class="TB">SRX</p></td><td class="Formal"><a name="9726"></a> <p class="TB">Y</p></td><td class="Formal"><a name="9728"></a> <p class="TB">N</p></td><td class="Formal"><a name="9730"></a> <p class="TB">N</p></td><td class="Formal"><a name="9732"></a> <p class="TB">N</p></td><td class="Formal"><a name="9734"></a> <p class="TB">N</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="9708"></a> <p class="TB"><code>LOCK TABLE</code> <em><code>table</code></em> <code>IN    EXCLUSIVE MODE</code></p></td><td class="Formal"><a name="9710"></a> <p class="TB">X</p></td><td class="Formal"><a name="9712"></a> <p class="TB">N</p></td><td class="Formal"><a name="9714"></a> <p class="TB">N</p></td><td class="Formal"><a name="9716"></a> <p class="TB">N</p></td><td class="Formal"><a name="9718"></a> <p class="TB">N</p></td><td class="Formal"><a name="9720"></a> <p class="TB">N</p></td></tr></tbody><tfoot><tr class="Footer" align="left"><td class="Footer"> <p class="TableKeyFoot"><font size="-1"><br><a name="9680"></a></font></p></td><td class="Footer" colspan="2"> <p class="TableKeyFoot"><font size="-1"><br><a name="9962"></a>RS: row share<br><a name="9887"></a>RX: row exclusive<br><a name="9958"></a>S: share<br><a name="9880"></a>SRX: share row exclusive<br><a name="9852"></a>X: exclusive</font></p></td><td class="Footer" colspan="4"> <p class="TableKeyFoot"><font size="-1"><br><a name="9879"></a>*Yes, if no conflicting row locks are held by another transaction. Otherwise, waits occur.</font></p></td></tr></tfoot></table> 
<a name="3036"></a> 
<p></p> 
<p class="BP">The following sections explain each mode of table lock, from least restrictive to most restrictive. They also describe the actions that cause the transaction to acquire a table lock in that mode and which actions are permitted and prohibited in other transactions by a lock in that mode.</p> 
<a name="18047"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="17751"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="17764"></a> <p class="NB"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#3330"><u><font color="#800080">"Explicit (Manual) Data Locking"</font></u></a><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#3330"></a></p></td></tr></tbody></table> 
</div> 
<a name="3046"></a> 
 
<h6 class="H4"><font face="Arial, Helvetica, sans-serif" color="#330099">Row Share Table Locks (RS)</font></h6> 
 
<a name="5196"></a> 
<p class="BP">A row share table lock (also sometimes called a <strong class="Bold">subshare table lock, SS</strong>) indicates that the transaction holding the lock on the table has locked rows in the table and intends to update them. A row share table lock is automatically acquired for a <em class="Italic">table</em> when one of the following SQL statements is executed:</p> 
<pre class="CE"><a name="3048"></a>SELECT ... FROM <em class="Italic">table</em> ... FOR UPDATE OF ... ;  
<a name="10015"></a>
<a name="10016"></a>LOCK TABLE <em class="Italic">table</em> IN ROW SHARE MODE; 
<a name="10017"></a>
</pre> 
<a name="3052"></a> 
<p class="BP">A row share table lock is the least restrictive mode of table lock, offering the highest degree of concurrency for a table.</p> 
<a name="3054"></a> 
<p class="BP"><em class="Italic">Permitted Operations:</em> A row share table lock held by a transaction allows other transactions to query, insert, update, delete, or lock rows concurrently in the same table. Therefore, other transactions can obtain simultaneous row share, row exclusive, share, and share row exclusive table locks for the same table.</p> 
<a name="3056"></a> 
<p class="BP"><em class="Italic">Prohibited Operations:</em> A row share table lock held by a transaction prevents other transactions from exclusive write access to the same table using only the following statement:</p> 
<pre class="CE"><a name="3058"></a>LOCK TABLE <em class="Italic">table</em> IN EXCLUSIVE MODE;
</pre> 
<a name="3066"></a> 
 
<h6 class="H4"><font face="Arial, Helvetica, sans-serif" color="#330099">Row Exclusive Table Locks (RX)</font></h6> 
 
<a name="5197"></a> 
<p class="BP">A row exclusive table lock (also called a <strong class="Bold">subexclusive table lock, SX</strong>) generally indicates that the transaction holding the lock has made one or more updates to rows in the table. A row exclusive table lock is acquired automatically for a <em class="Italic">table</em> modified by the following types of statements:</p> 
<pre class="CE"><a name="3068"></a>INSERT INTO <em class="Italic">table</em> ... ; 
<a name="10021"></a>
<a name="10022"></a>UPDATE <em class="Italic">table</em> ... ; 
<a name="10025"></a>
<a name="10026"></a>DELETE FROM <em class="Italic">table</em> ... ;  
<a name="10029"></a>
<a name="10030"></a>LOCK TABLE <em class="Italic">table</em> IN ROW EXCLUSIVE MODE; 
<a name="10031"></a>
</pre> 
<a name="3076"></a> 
<p class="BP">A row exclusive table lock is slightly more restrictive than a row share table lock.</p> 
<a name="3078"></a> 
<p class="BP"><em class="Italic">Permitted Operations:</em> A row exclusive table lock held by a transaction allows other transactions to query, insert, update, delete, or lock rows concurrently in the same table. Therefore, row exclusive table locks allow multiple transactions to obtain simultaneous row exclusive and row share table locks for the same table.</p> 
<a name="3080"></a> 
<p class="BP"><em class="Italic">Prohibited Operations:</em> A row exclusive table lock held by a transaction prevents other transactions from manually locking the table for exclusive reading or writing. Therefore, other transactions cannot concurrently lock the table using the following statements:</p> 
<pre class="CE"><a name="3082"></a>LOCK TABLE <em class="Italic">table</em> IN SHARE MODE;  
<a name="10037"></a>
<a name="10038"></a>LOCK TABLE <em class="Italic">table</em> IN SHARE EXCLUSIVE MODE; 
<a name="10041"></a>
<a name="18262"></a>LOCK TABLE <em class="Italic">table</em> IN EXCLUSIVE MODE; 
</pre> 
<a name="18266"></a> 
 
<h6 class="H4"><font face="Arial, Helvetica, sans-serif" color="#330099">Share Table Locks (S)</font></h6> 
 
<a name="5198"></a> 
<p class="BP">A share table lock is acquired automatically for the <em class="Italic">table</em> specified in the following statement:</p> 
<pre class="CE"><a name="3094"></a>LOCK TABLE <em class="Italic">table</em> IN SHARE MODE; 
<a name="10053"></a>
</pre> 
<a name="3096"></a> 
<p class="BP"><em class="Italic">Permitted Operations:</em> A share table lock held by a transaction allows other transactions only to query the table, to lock specific rows with <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code>, or to execute <code>LOCK</code> <code>TABLE</code> ... <code>IN</code> <code>SHARE</code> <code>MODE</code> statements successfully. No updates are allowed by other transactions. Multiple transactions can hold share table locks for the same table concurrently. In this case, no transaction can update the table (even if a transaction holds row locks as the result of a <code>SELECT</code> statement with the <code>FOR</code> <code>UPDATE</code> clause). Therefore, a transaction that has a share table lock can update the table only if no other transactions also have a share table lock on the same table.</p> 
<a name="3098"></a> 
<p class="BP"><em class="Italic">Prohibited Operations:</em> A share table lock held by a transaction prevents other transactions from modifying the same table and from executing the following statements:</p> 
<pre class="CE"><a name="3100"></a>LOCK TABLE <em class="Italic">table</em> IN SHARE ROW EXCLUSIVE MODE; 
<a name="10046"></a>
<a name="10047"></a>LOCK TABLE <em class="Italic">table</em> IN EXCLUSIVE MODE; 
<a name="10050"></a>
<a name="10051"></a>LOCK TABLE <em class="Italic">table</em> IN ROW EXCLUSIVE MODE; 
</pre> 
<a name="3112"></a> 
 
<h6 class="H4"><font face="Arial, Helvetica, sans-serif" color="#330099">Share Row Exclusive Table Locks (SRX)</font></h6> 
 
<a name="5199"></a> 
<p class="BP">A share row exclusive table lock (also sometimes called a <strong class="Bold">share-subexclusive table lock, SSX</strong>) is more restrictive than a share table lock. A share row exclusive table lock is acquired for a <em class="Italic">table</em> as follows:</p> 
<pre class="CE"><a name="3114"></a>LOCK TABLE <em class="Italic">table</em> IN SHARE ROW EXCLUSIVE MODE; 
<a name="10054"></a>
</pre> 
<a name="21204"></a> 
<p class="BP"><em class="Italic">Permitted Operations:</em> Only one transaction at a time can acquire a share row exclusive table lock on a given table. A share row exclusive table lock held by a transaction allows other transactions to query or lock specific rows using <code>SELECT</code> with the <code>FOR</code> <code>UPDATE</code> clause, but not to update the table.</p> 
<a name="21200"></a> 
<p class="BP"><em class="Italic">Prohibited Operations:</em> A share row exclusive table lock held by a transaction prevents other transactions from obtaining row exclusive table locks and modifying the same table. A share row exclusive table lock also prohibits other transactions from obtaining share, share row exclusive, and exclusive table locks, which prevents other transactions from executing the following statements:</p> 
<pre class="CE"><a name="3120"></a>LOCK TABLE <em class="Italic">table</em> IN SHARE MODE; 
<a name="10057"></a>
<a name="8955"></a>LOCK TABLE <em class="Italic">table</em> IN SHARE ROW EXCLUSIVE MODE; 
<a name="10060"></a>
<a name="8959"></a>LOCK TABLE <em class="Italic">table</em> IN ROW EXCLUSIVE MODE; 
<a name="10063"></a>
<a name="8963"></a>LOCK TABLE <em class="Italic">table</em> IN EXCLUSIVE MODE; 
</pre> 
<a name="3130"></a> 
 
<h6 class="H4"><font face="Arial, Helvetica, sans-serif" color="#330099">Exclusive Table Locks (X)</font></h6> 
 
<a name="5200"></a> 
<p class="BP">An exclusive table lock is the most restrictive mode of table lock, allowing the transaction that holds the lock exclusive write access to the table. An exclusive table lock is acquired for a <em class="Italic">table</em> as follows:</p> 
<pre class="CE"><a name="3132"></a>LOCK TABLE <em class="Italic">table</em> IN EXCLUSIVE MODE; 
<a name="10067"></a>
</pre> 
<a name="3134"></a> 
<p class="BP"><em class="Italic">Permitted Operations:</em> Only one transaction can obtain an exclusive table lock for a table. An exclusive table lock permits other transactions only to query the table.</p> 
<a name="3136"></a> 
<p class="BP"><em class="Italic">Prohibited Operations:</em> An exclusive table lock held by a transaction prohibits other transactions from performing any type of DML statement or placing any type of lock on the table.</p> 
<a name="3138"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">DML Locks Automatically Acquired for DML Statements</font></h5> 
 
<a name="3145"></a> 
<p class="BP">The previous sections explained the different types of data locks, the modes in which they can be held, when they can be obtained, when they are obtained, and what they prohibit. The following sections summarize how Oracle automatically locks data on behalf of different DML operations.</p> 
<a name="10341"></a> 
<p class="BP"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c21cnsis.htm#10188"><u><font color="#800080">Table 20-4</font></u></a> summarizes the information in the following sections.</p> 
<h6 class="TT"><a name="10096"></a><a name="10188"></a><strong><font face="Arial, Helvetica, sans-serif"><em>Table 20-4 Locks Obtained By DML Statements</em></font></strong></h6> 
<p> </p> 
<table class="Formal" dir="ltr" title="" cellspacing="0" cellpadding="3" width="100%" border="1"><thead><tr class="Formal"><th class="Formal" align="left"><a name="10166"></a><font face="Arial, Helvetica, sans-serif"><strong>DML Statement</strong></font></th><th class="Formal" align="left"><a name="10171"></a><font face="Arial, Helvetica, sans-serif"><strong>Row Locks?</strong></font></th><th class="Formal" align="left"><a name="10176"></a><font face="Arial, Helvetica, sans-serif"><strong>Mode of Table Lock</strong></font></th></tr></thead><tbody><tr class="Formal" align="left"><td class="Formal"><a name="10194"></a> <p class="TB"><code>SELECT ... FROM</code> <em><code>table</code></em></p></td><td class="Formal"><a name="10196"></a></td><td class="Formal"><a name="10198"></a></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="10200"></a> <p class="TB"><code>INSERT INTO</code> <em><code>table</code></em> <code>...</code></p></td><td class="Formal"><a name="10202"></a> <p class="TB">X</p></td><td class="Formal"><a name="10204"></a> <p class="TB">RX</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="10206"></a> <p class="TB"><code>UPDATE</code> <em><code>table</code></em> <code>...</code></p></td><td class="Formal"><a name="10208"></a> <p class="TB">X</p></td><td class="Formal"><a name="10210"></a> <p class="TB">RX</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="10212"></a> <p class="TB"><code>DELETE FROM</code> <em><code>table</code></em> <code>...</code></p></td><td class="Formal"><a name="10214"></a> <p class="TB">X</p></td><td class="Formal"><a name="10216"></a> <p class="TB">RX</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="10218"></a> <p class="TB"><code>SELECT ... FROM</code> <em><code>table</code></em> <code>...    FOR UPDATE OF ...</code></p></td><td class="Formal"><a name="10220"></a> <p class="TB">X</p></td><td class="Formal"><a name="10222"></a> <p class="TB">RS</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="10224"></a> <p class="TB"><code>LOCK TABLE</code> <em><code>table</code></em> <code>IN ...</code></p></td><td class="Formal"><a name="10226"></a></td><td class="Formal"><a name="10228"></a></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="10230"></a> <p class="TB"><code>ROW SHARE MODE</code></p></td><td class="Formal"><a name="10232"></a></td><td class="Formal"><a name="10234"></a> <p class="TB">RS</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="10236"></a> <p class="TB"><code>ROW EXCLUSIVE MODE</code></p></td><td class="Formal"><a name="10238"></a></td><td class="Formal"><a name="10240"></a> <p class="TB">RX</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="10242"></a> <p class="TB"><code>SHARE MODE</code></p></td><td class="Formal"><a name="10244"></a></td><td class="Formal"><a name="10246"></a> <p class="TB">S</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="10248"></a> <p class="TB"><code>SHARE EXCLUSIVE MODE</code></p></td><td class="Formal"><a name="10250"></a></td><td class="Formal"><a name="10252"></a> <p class="TB">SRX</p></td></tr><tr class="Formal" align="left"><td class="Formal"><a name="10254"></a> <p class="TB"><code>EXCLUSIVE MODE</code></p></td><td class="Formal"><a name="10256"></a></td><td class="Formal"><a name="10258"></a> <p class="TB">X</p></td></tr></tbody><tfoot><tr class="Footer" align="left"><td class="Footer"> <p class="TableKeyFoot"><font size="-1"><br><a name="10153"></a></font></p></td><td class="Footer"> <p class="TableKeyFoot"><font size="-1"><br><a name="10265"></a>X: exclusive<br><a name="10281"></a>RX: row exclusive</font></p></td><td class="Footer"> <p class="TableKeyFoot"><font size="-1"><br><a name="10271"></a>RS: row share<br><a name="10273"></a>S: share<br><a name="10274"></a>SRX: share row exclusive</font></p></td></tr></tfoot></table> 
<a name="3152"></a> 
 
<p></p> 
<h6 class="H4"><font face="Arial, Helvetica, sans-serif" color="#330099">Default Locking for Queries</font></h6> 
 
<a name="10323"></a> 
<p class="BP">Queries are the SQL statements least likely to interfere with other SQL statements because they only read data. <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements can have implicit queries as part of the statement. Queries include the following kinds of statements:</p> 
<pre class="CE"><a name="3154"></a>SELECT 
<a name="10309"></a>
<a name="10310"></a>INSERT ... SELECT ... ; 
<a name="10306"></a>
<a name="10303"></a>UPDATE ... ; 
<a name="10296"></a>
<a name="10292"></a>DELETE ... ; 
<a name="10288"></a>
</pre> 
<a name="3162"></a> 
<p class="BP">They do <strong class="Bold">not</strong> include the following statement:</p> 
<pre class="CE"><a name="3164"></a>SELECT ... FOR UPDATE OF ... ; 
<a name="10311"></a>
</pre> 
<a name="10317"></a> 
<p class="BP">The following characteristics are true of all queries that do not use the <code>FOR</code> <code>UPDATE</code> clause:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="3170"></a>A query acquires no data locks. Therefore, other transactions can query and update a table being queried, including the specific rows being queried. Because queries lacking <code>FOR</code> <code>UPDATE</code> clauses do not acquire any data locks to block other operations, such queries are often referred to in Oracle as <strong class="Bold">nonblocking queries</strong>. </li><li class="LB1" type="disc"><a name="3172"></a>A query does not have to wait for any data locks to be released; it can always proceed. (Queries may have to wait for data locks in some very specific cases of pending distributed transactions.) </li></ul> 
<a name="3178"></a> 
 
<h6 class="H4"><font face="Arial, Helvetica, sans-serif" color="#330099">Default Locking for INSERT, UPDATE, DELETE, and SELECT ... FOR UPDATE</font></h6> 
 
<a name="5202"></a> 
<p class="BP">The locking characteristics of <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statements are as follows:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="3180"></a>The transaction that contains a DML statement acquires exclusive row locks on the rows modified by the statement. Other transactions cannot update or delete the locked rows until the locking transaction either commits or rolls back. </li><li class="LB1" type="disc"><a name="3182"></a>The transaction that contains a DML statement does not need to acquire row locks on any rows selected by a subquery or an implicit query, such as a query in a <code>WHERE</code> clause. A subquery or implicit query in a DML statement is guaranteed to be consistent as of the start of the query and does not see the effects of the DML statement it is part of. </li><li class="LB1" type="disc"><a name="3184"></a>A query in a transaction can see the changes made by previous DML statements in the same transaction, but cannot see the changes of other transactions begun after its own transaction. </li><li class="LB1" type="disc"><a name="3186"></a>In addition to the necessary exclusive row locks, a transaction that contains a DML statement acquires at least a row exclusive table lock on the table that contains the affected rows. If the containing transaction already holds a share, share row exclusive, or exclusive table lock for that table, the row exclusive table lock is not acquired. If the containing transaction already holds a row share table lock, Oracle automatically converts this lock to a row exclusive table lock. </li></ul> 
<a name="3188"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">DDL Locks</font></h4> 
 
<a name="3198"></a> 
<p class="BP">A data dictionary lock (DDL) protects the definition of a schema object while that object is acted upon or referred to by an ongoing DDL operation. Recall that a DDL statement implicitly commits its transaction. For example, assume that a user creates a procedure. On behalf of the user's single-statement transaction, Oracle automatically acquires DDL locks for all schema objects referenced in the procedure definition. The DDL locks prevent objects referenced in the procedure from being altered or dropped before the procedure compilation is complete.</p> 
<a name="3200"></a> 
<p class="BP">Oracle acquires a dictionary lock automatically on behalf of any DDL transaction requiring it. Users cannot explicitly request DDL locks. Only individual schema objects that are modified or referenced are locked during DDL operations. The whole data dictionary is never locked.</p> 
<a name="3202"></a> 
<p class="BP">DDL locks fall into three categories: exclusive DDL locks, share DDL locks, and breakable parse locks.</p> 
<a name="3204"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Exclusive DDL Locks</font></h5> 
 
<a name="3210"></a> 
<p class="BP">Most DDL operations, except for those listed in the next section, "Share DDL Locks", require exclusive DDL locks for a resource to prevent destructive interference with other DDL operations that might modify or reference the same schema object. For example, a <code>DROP</code> <code>TABLE</code> operation is not allowed to drop a table while an <code>ALTER TABLE</code> operation is adding a column to it, and vice versa.</p> 
<a name="6787"></a> 
<p class="BP">During the acquisition of an exclusive DDL lock, if another DDL lock is already held on the schema object by another operation, the acquisition waits until the older DDL lock is released and then proceeds.</p> 
<a name="3212"></a> 
<p class="BP">DDL operations also acquire DML locks (data locks) on the schema object to be modified.</p> 
<a name="3218"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Share DDL Locks</font></h5> 
 
<a name="3224"></a> 
<p class="BP">Some DDL operations require share DDL locks for a resource to prevent destructive interference with conflicting DDL operations, but allow data concurrency for similar DDL operations. For example, when a <code>CREATE</code> <code>PROCEDURE</code> statement is executed, the containing transaction acquires share DDL locks for all referenced tables. Other transactions can concurrently create procedures that reference the same tables and therefore acquire concurrent share DDL locks on the same tables, but no transaction can acquire an exclusive DDL lock on any referenced table. No transaction can alter or drop a referenced table. As a result, a transaction that holds a share DDL lock is guaranteed that the definition of the referenced schema object will remain constant for the duration of the transaction.</p> 
<a name="21234"></a> 
<p class="BP">A share DDL lock is acquired on a schema object for DDL statements that include the following statements: <code>AUDIT</code>, <code>NOAUDIT</code>, <code>COMMENT</code>, <code>CREATE</code> <code>[OR</code> <code>REPLACE] VIEW</code>/ <code>PROCEDURE</code>/<code>PACKAGE/PACKAGE</code> <code>BODY</code>/<code>FUNCTION</code>/ <code>TRIGGER</code>, <code>CREATE SYNONYM</code>, and <code>CREATE</code> <code>TABLE</code> (when the <code>CLUSTER</code> parameter is not included).</p> 
<a name="21235"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Breakable Parse Locks</font></h5> 
 
<a name="3262"></a> 
<p class="BP">A SQL statement (or PL/SQL program unit) in the shared pool holds a parse lock for each schema object it references. Parse locks are acquired so that the associated shared SQL area can be invalidated if a referenced object is altered or dropped. A parse lock does not disallow any DDL operation and can be broken to allow conflicting DDL operations, hence the name <strong class="Bold">breakable parse lock</strong>.</p> 
<a name="3264"></a> 
<p class="BP">A parse lock is acquired during the parse phase of SQL statement execution and held as long as the shared SQL area for that statement remains in the shared pool.</p> 
<a name="18049"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="17795"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="17796"></a> <p class="NB"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96524/c19depnd.htm#369"><u><font color="#0000ff">Chapter 15, "Dependencies Among Schema Objects"</font></u></a></p></td></tr></tbody></table> 
</div> 
<a name="3266"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Duration of DDL Locks</font></h5> 
 
<a name="3270"></a> 
<p class="BP">The duration of a DDL lock depends on its type. Exclusive and share DDL locks last for the duration of DDL statement execution and automatic commit. A parse lock persists as long as the associated SQL statement remains in the shared pool.</p> 
<a name="3272"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">DDL Locks and Clusters</font></h5> 
 
<a name="3278"></a> 
<p class="BP">A DDL operation on a cluster acquires exclusive DDL locks on the cluster and on all tables and materialized views in the cluster. A DDL operation on a table or materialized view in a cluster acquires a share lock on the cluster, in addition to a share or exclusive DDL lock on the table or materialized view. The share DDL lock on the cluster prevents another operation from dropping the cluster while the first operation proceeds.</p> 
<a name="3280"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Latches and Internal Locks</font></h4> 
 
<a name="3284"></a> 
<p class="BP">Latches and internal locks protect internal database and memory structures. Both are inaccessible to users, because users have no need to control over their occurrence or duration. The following section helps to interpret the Enterprise Manager or SQL*Plus <code>LOCKS</code> and <code>LATCHES</code> monitors.</p> 
<a name="3286"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Latches</font></h5> 
 
<a name="3292"></a> 
<p class="BP">Latches are simple, low-level serialization mechanisms to protect shared data structures in the system global area (SGA). For example, latches protect the list of users currently accessing the database and protect the data structures describing the blocks in the buffer cache. A server or background process acquires a latch for a very short time while manipulating or looking at one of these structures. The implementation of latches is operating system dependent, particularly in regard to whether and how long a process will wait for a latch.</p> 
<a name="6820"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Internal Locks</font></h5> 
 
<a name="3294"></a> 
<p class="BP">Internal locks are higher-level, more complex mechanisms than latches and serve a variety of purposes.</p> 
<a name="3302"></a> 
 
<h6 class="H4"><font face="Arial, Helvetica, sans-serif" color="#330099">Dictionary Cache Locks</font></h6> 
 
<a name="5203"></a> 
<p class="BP">These locks are of very short duration and are held on entries in dictionary caches while the entries are being modified or used. They guarantee that statements being parsed do not see inconsistent object definitions.</p> 
<a name="3304"></a> 
<p class="BP">Dictionary cache locks can be shared or exclusive. Shared locks are released when the parse is complete. Exclusive locks are released when the DDL operation is complete.</p> 
<a name="6824"></a> 
 
<h6 class="H4"><font face="Arial, Helvetica, sans-serif" color="#330099">File and Log Management Locks</font></h6> 
 
<a name="6828"></a> 
<p class="BP">These locks protect various files. For example, one lock protects the control file so that only one process at a time can change it. Another lock coordinates the use and archiving of the redo log files. Datafiles are locked to ensure that multiple instances mount a database in shared mode or that one instance mounts it in exclusive mode. Because file and log locks indicate the status of files, these locks are necessarily held for a long time.</p> 
<a name="3328"></a> 
 
<h6 class="H4"><font face="Arial, Helvetica, sans-serif" color="#330099">Tablespace and Rollback Segment Locks</font></h6> 
 
<a name="5205"></a> 
<p class="BP">These locks protect tablespaces and rollback segments. For example, all instances accessing a database must agree on whether a tablespace is online or offline. Rollback segments are locked so that only one instance can write to a segment.</p> 
<a name="3330"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Explicit (Manual) Data Locking</font></h4> 
 
<a name="3342"></a> 
<p class="BP">Oracle always performs locking automatically to ensure data concurrency, data integrity, and statement-level read consistency. However, you can override the Oracle default locking mechanisms. Overriding the default locking is useful in situations such as these:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="3344"></a>Applications require transaction-level read consistency or <strong class="Bold">repeatable reads</strong>. In other words, queries in them must produce consistent data for the duration of the transaction, not reflecting changes by other transactions. You can achieve transaction-level read consistency by using explicit locking, read-only transactions, serializable transactions, or by overriding default locking. </li><li class="LB1" type="disc"><a name="3346"></a>Applications require that a transaction have exclusive access to a resource so that the transaction does not have to wait for other transactions to complete. </li></ul> 
<a name="4780"></a> 
<p class="BP">Oracle's automatic locking can be overridden at the transaction level or the session level.</p> 
<a name="22510"></a> 
<p class="BP">At the transaction level, transactions that include the following SQL statements override Oracle's default locking:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="22512"></a>The <code>SET</code> <code>TRANSACTION</code> <code>ISOLATION</code> <code>LEVEL</code> statement </li><li class="LB1" type="disc"><a name="22513"></a>The <code>LOCK</code> <code>TABLE</code> statement (which locks either a table or, when used with views, the underlying base tables) </li><li class="LB1" type="disc"><a name="22514"></a>The <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statement </li></ul> 
<a name="22506"></a> 
<p class="BP">Locks acquired by these statements are released after the transaction commits or rolls back.</p> 
<a name="22518"></a> 
<p class="BP">At the session level, a session can set the required transaction isolation level with the <code>ALTER</code> <code>SESSION</code> statement.</p> 
<a name="8492"></a> 
<div align="center"> 
 <table class="Note" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="Note"><td class="Note"> 
     <hr> <a name="8517"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Note:</strong></font> <a name="8518"></a> <p class="NB">If Oracle's default locking is overridden at any level, the database administrator or application developer should ensure that the overriding locking procedures operate correctly. The locking procedures must satisfy the following criteria: data integrity is guaranteed, data concurrency is acceptable, and deadlocks are not possible or are appropriately handled.</p> 
     <hr> </td></tr></tbody></table> 
</div> 
<a name="8542"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="8545"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="21250"></a> <p class="NB"><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96540/toc.htm"><u><font color="#0000ff">Oracle9i SQL Reference</font></u></a></em> for detailed descriptions of the SQL statements <code>LOCK</code> <code>TABLE</code> and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code></p></td></tr></tbody></table> 
</div> 
<a name="3374"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Examples of Concurrency under Explicit Locking</font></h5> 
 
<a name="21263"></a> 
<p class="BP">The following illustration shows how Oracle maintains data concurrency, integrity, and consistency when <code>LOCK</code> <code>TABLE</code> and <code>SELECT</code> with the <code>FOR</code> <code>UPDATE</code> clause statements are used.</p> 
<a name="12171"></a> 
<div align="center"> 
 <table class="Note" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="Note"><td class="Note"> 
     <hr> <a name="8532"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Note:</strong></font> <a name="8533"></a> <p class="NB">For brevity, the message text for <code>ORA-00054</code> ("resource busy and acquire with <code>NOWAIT</code> specified") is not included. User-entered text is in <strong class="Bold">bold</strong>.</p> 
     <hr> </td></tr></tbody></table> 
</div> 
<p><a name="11755"></a><a name="19646"></a> </p> 
<table class="Informal" dir="ltr" title="" cellspacing="0" cellpadding="3" width="100%" border="1"><thead><tr class="Informal"><th class="Informal" align="left"><a name="11384"></a><font face="Arial, Helvetica, sans-serif"><strong>Transaction 1</strong></font></th><th class="Informal" align="left"><a name="11386"></a><font face="Arial, Helvetica, sans-serif"><strong>Time Point</strong></font></th><th class="Informal" align="left"><a name="11388"></a><font face="Arial, Helvetica, sans-serif"><strong>Transaction 2</strong></font></th></tr></thead><tbody><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11390"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13178"></a><strong><code>IN ROW SHARE MODE; 
</code></strong><a name="11391"></a><code>Statement processed
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11393"></a> <code>1
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11395"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11397"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11399"></a> <code>2
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11401"></a><strong><code>DROP TABLE scott.dept; 
</code></strong><a name="11402"></a><code>DROP TABLE scott.dept 
</code><a name="13180"></a> <code>        * 
</code><a name="13182"></a><code>ORA-00054
</code><a name="12286"></a><em><code>(exclusive DDL lock not possible 
because of T1's table lock)
</code></em>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11407"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11409"></a> <code>3
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11411"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13184"></a><strong><code>IN EXCLUSIVE MODE NOWAIT; 
</code></strong><a name="11412"></a><code>ORA-00054
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11414"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11416"></a> <code>4
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11418"></a><strong><code>SELECT LOC 
</code></strong><a name="13186"></a><strong><code>FROM scott.dept 
</code></strong><a name="13188"></a><strong><code>WHERE deptno = 20 
</code></strong><a name="13190"></a><strong><code>FOR UPDATE OF loc; 
</code></strong><a name="11419"></a><code>LOC 
</code><a name="13192"></a><code>- - - - - - - 
</code><a name="13194"></a><code>DALLAS 
</code><a name="13196"></a><code>1 row selected
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11421"></a><strong><code>UPDATE scott.dept 
</code></strong><a name="13198"></a><strong><code>SET loc = 'NEW YORK' 
</code></strong><a name="13200"></a><strong><code>WHERE deptno = 20; 
</code></strong><a name="11422"></a><em><code>(waits because T2 has locked same 
rows)
</code></em>
</pre></td><td class="Informal"><pre class="CEW"><a name="11424"></a> <code>5
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11426"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11428"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11430"></a> <code>6
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11432"></a><strong><code>ROLLBACK; 
</code></strong><a name="11433"></a><em><code>(releases row locks)
</code></em>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11435"></a><code>1 row processed. 
</code><a name="11436"></a><strong><code>ROLLBACK; 
</code></strong>
</pre></td><td class="Informal"><pre class="CEW"><a name="11438"></a> <code>7
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11440"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11442"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13202"></a><strong><code>IN ROW EXCLUSIVE MODE; 
</code></strong><a name="11443"></a><code>Statement processed.
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11445"></a> <code>8
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11447"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11449"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11451"></a> <code>9
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11453"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13204"></a><strong><code>IN EXCLUSIVE MODE 
</code></strong><a name="13206"></a><strong><code>NOWAIT; 
</code></strong><a name="11454"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11456"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11458"></a><code>10
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="12298"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13208"></a><strong><code>IN SHARE ROW EXCLUSIVE 
</code></strong><a name="13210"></a><strong><code>MODE NOWAIT; 
</code></strong><a name="12301"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11462"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11464"></a><code>11
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="12306"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13212"></a><strong><code>IN SHARE ROW EXCLUSIVE 
</code></strong><a name="13214"></a><strong><code>MODE NOWAIT; 
</code></strong><a name="12309"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11468"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11470"></a><code>12
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="12311"></a><strong><code>UPDATE scott.dept 
</code></strong><a name="13216"></a><strong><code>SET loc = 'NEW YORK' 
</code></strong><a name="13218"></a><strong><code>WHERE deptno = 20;  
</code></strong><a name="12314"></a><code>1 row processed. 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11474"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11476"></a><code>13
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11478"></a><strong><code>ROLLBACK; 
</code></strong>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11480"></a><strong><code>SELECT loc 
</code></strong><a name="13220"></a><strong><code>FROM scott.dept 
</code></strong><a name="13222"></a><strong><code>WHERE deptno = 20 
</code></strong><a name="13224"></a><strong><code>FOR UPDATE OF loc;   
</code></strong><a name="12319"></a><code>LOC 
</code><a name="13230"></a><code>- - - - - - 
</code><a name="13232"></a><code>DALLAS 
</code><a name="13234"></a><code>1 row selected. 
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11482"></a><code>14
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11484"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11486"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11488"></a><code>15
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11490"></a><strong><code>UPDATE scott.dept 
</code></strong><a name="13236"></a><strong><code>SET loc = 'NEW YORK' 
</code></strong><a name="13238"></a><strong><code>WHERE deptno = 20; 
</code></strong><a name="12325"></a><em><code>(waits because T1 has locked same 
rows)
</code></em>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11492"></a><strong><code>ROLLBACK; 
</code></strong>
</pre></td><td class="Informal"><pre class="CEW"><a name="11494"></a><code>16
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11496"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11498"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11500"></a><code>17
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11502"></a><code>1 row processed. 
</code><a name="12337"></a><em><code>(conflicting locks were released) 
</code></em><a name="12336"></a><strong><code>ROLLBACK;
</code></strong>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11504"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13240"></a><strong><code>IN SHARE MODE 
</code></strong><a name="12342"></a><code>Statement processed
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11506"></a><code>18
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11508"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11510"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11512"></a><code>19
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="12346"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13242"></a><strong><code>IN EXCLUSIVE MODE NOWAIT; 
</code></strong><a name="12348"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11516"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11518"></a><code>20
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11520"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13244"></a><strong><code>IN SHARE ROW EXCLUSIVE 
</code></strong><a name="13246"></a><strong><code>MODE NOWAIT; 
</code></strong><a name="12355"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11522"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11524"></a><code>21
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11526"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13248"></a><strong><code>IN SHARE MODE;   
</code></strong><a name="12383"></a><code>Statement processed. 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11528"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11530"></a><code>22
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11532"></a><strong><code>SELECT loc 
</code></strong><a name="13250"></a><strong><code>FROM scott.dept 
</code></strong><a name="13252"></a><strong><code>WHERE deptno = 20;   
</code></strong><a name="12382"></a><code>LOC 
</code><a name="13254"></a><code>- - - - - - 
</code><a name="13256"></a><code>DALLAS 
</code><a name="13258"></a><code>1 row selected. 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11534"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11536"></a><code>23
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11538"></a><strong><code>SELECT loc 
</code></strong><a name="13260"></a><strong><code>FROM scott.dept 
</code></strong><a name="13262"></a><strong><code>WHERE deptno = 20 
</code></strong><a name="13264"></a><strong><code>FOR UPDATE OF loc; 
</code></strong><a name="12381"></a><code>LOC 
</code><a name="13266"></a><code>- - - - - - 
</code><a name="13268"></a><code>DALLAS 
</code><a name="13270"></a><code>1 row selected. 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11540"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11542"></a><code>24
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11544"></a><strong><code>UPDATE scott.dept 
</code></strong><a name="13272"></a><strong><code>SET loc = 'NEW YORK' 
</code></strong><a name="13274"></a><strong><code>WHERE deptno = 20; 
</code></strong><a name="12380"></a><em><code>(waits because T1 holds 
conflicting table lock)
</code></em>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11546"></a><strong><code>ROLLBACK; 
</code></strong>
</pre></td><td class="Informal"><pre class="CEW"><a name="11548"></a><code>25
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11550"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11552"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11554"></a><code>26
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11556"></a><code>1 row processed. 
</code><a name="12389"></a><em><code>(conflicting table lock released)  
</code></em><a name="12388"></a><strong><code>ROLLBACK; 
</code></strong>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11558"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13276"></a><strong><code>IN SHARE ROW 
</code></strong><a name="13278"></a><strong><code>EXCLUSIVE MODE; 
</code></strong><a name="12394"></a><code>Statement processed.
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11560"></a><code>27
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11562"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11564"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11566"></a><code>28
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="12398"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13280"></a><strong><code>IN EXCLUSIVE MODE 
</code></strong><a name="13282"></a><strong><code>NOWAIT; 
</code></strong><a name="11568"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11570"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11572"></a><code>29
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="12403"></a><strong><code>LOCK TABLE  scott.dept 
</code></strong><a name="13284"></a><strong><code>IN SHARE ROW 
</code></strong><a name="13287"></a><strong><code>EXCLUSIVE MODE 
</code></strong><a name="13289"></a><strong><code>NOWAIT; 
</code></strong><a name="11574"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11576"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11578"></a><code>30
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11580"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13291"></a><strong><code>IN SHARE MODE NOWAIT; 
</code></strong><a name="13078"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11582"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11584"></a><code>31
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11586"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13293"></a><strong><code>IN ROW EXCLUSIVE 
</code></strong><a name="13295"></a><strong><code>MODE NOWAIT; 
</code></strong><a name="12551"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11588"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11590"></a><code>32
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11592"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13297"></a><strong><code>IN SHARE MODE NOWAIT; 
</code></strong><a name="13079"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11594"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11596"></a><code>33
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11598"></a><strong><code>SELECT loc 
</code></strong><a name="13299"></a><strong><code>FROM scott.dept 
</code></strong><a name="13301"></a><strong><code>WHERE deptno = 20;   
</code></strong><a name="12645"></a><code>LOC 
</code><a name="13303"></a><code>- - - - - -  
</code><a name="13305"></a><code>DALLAS 
</code><a name="13307"></a><code>1 row selected. 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11600"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11602"></a><code>34
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11604"></a><strong><code>SELECT loc 
</code></strong><a name="13309"></a><strong><code>FROM scott.dept 
</code></strong><a name="13311"></a><strong><code>WHERE deptno = 20 
</code></strong><a name="13313"></a><strong><code>FOR UPDATE OF loc; 
</code></strong><a name="12649"></a><code>LOC 
</code><a name="13316"></a><code>- - - - - - 
</code><a name="13318"></a><code>DALLAS 
</code><a name="13320"></a><code>1 row selected. 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11606"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11608"></a><code>35
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11610"></a><strong><code>UPDATE scott.dept 
</code></strong><a name="13322"></a><strong><code>SET loc = 'NEW YORK' 
</code></strong><a name="13324"></a><strong><code>WHERE deptno = 20;  
</code></strong><a name="12443"></a><em><code>(waits because T1 holds 
conflicting table lock)
</code></em>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11612"></a><strong><code>UPDATE scott.dept 
</code></strong><a name="13326"></a><strong><code>SET loc = 'NEW YORK' 
</code></strong><a name="13328"></a><strong><code>WHERE deptno = 20; 
</code></strong><a name="12444"></a><em><code>(waits because T2 has locked same 
rows)
</code></em>
</pre></td><td class="Informal"><pre class="CEW"><a name="11614"></a><code>36
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11616"></a>
<a name="12440"></a><em><code>(deadlock)
</code></em>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11618"></a><code>Cancel operation 
</code><a name="13080"></a><strong><code>ROLLBACK;
</code></strong>
</pre></td><td class="Informal"><pre class="CEW"><a name="11620"></a><code>37
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11622"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11624"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11626"></a><code>38
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11628"></a><code>1 row processed. 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11630"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13330"></a><strong><code>IN EXCLUSIVE MODE;
</code></strong>
</pre></td><td class="Informal"><pre class="CEW"><a name="11632"></a><code>39
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11634"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11636"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11638"></a><code>40
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11640"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13332"></a><strong><code>IN EXCLUSIVE MODE; 
</code></strong><a name="13081"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11642"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11644"></a><code>41
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11646"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13334"></a><strong><code>IN ROW EXCLUSIVE MODE 
</code></strong><a name="13336"></a><strong><code>NOWAIT; 
</code></strong><a name="12582"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11648"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11650"></a><code>42
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11652"></a><strong><code>LOCK TABLE scott.dept 
</code></strong><a name="13338"></a><strong><code>IN SHARE MODE; 
</code></strong><a name="13082"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11654"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11656"></a><code>43
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11658"></a><strong><code>LOCK TABLE  scott.dept 
</code></strong><a name="13340"></a><strong><code>IN ROW EXCLUSIVE 
</code></strong><a name="13342"></a><strong><code>MODE NOWAIT; 
</code></strong><a name="12589"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11660"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11662"></a><code>44
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11664"></a><strong><code>LOCK TABLE  scott.dept 
</code></strong><a name="13344"></a><strong><code>IN ROW SHARE MODE 
</code></strong><a name="13346"></a><strong><code>NOWAIT; 
</code></strong><a name="12593"></a><code>ORA-00054 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11666"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11668"></a><code>45
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11670"></a><strong><code>SELECT loc 
</code></strong><a name="13348"></a><strong><code>FROM scott.dept 
</code></strong><a name="13350"></a><strong><code>WHERE deptno = 20; 
</code></strong><a name="12683"></a><code>LOC 
</code><a name="13352"></a><code>- - - - - - 
</code><a name="13354"></a><code>DALLAS 
</code><a name="13356"></a><code>1 row selected. 
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11672"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11674"></a><code>46
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11676"></a><strong><code>SELECT loc 
</code></strong><a name="13358"></a><strong><code>FROM scott.dept 
</code></strong><a name="13360"></a><strong><code>WHERE deptno = 20 
</code></strong><a name="13362"></a><strong><code>FOR UPDATE OF loc; 
</code></strong><a name="13083"></a><em><code>(waits because T1 has conflicting 
table lock)
</code></em>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11678"></a><strong><code>UPDATE scott.dept 
</code></strong><a name="13364"></a><strong><code>SET deptno = 30 
</code></strong><a name="13370"></a><strong><code>WHERE deptno = 20; 
</code></strong><a name="12688"></a><code>1 row processed.
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11680"></a><code>47
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11682"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11684"></a><strong><code>COMMIT; 
</code></strong>
</pre></td><td class="Informal"><pre class="CEW"><a name="11686"></a><code>48
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11688"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11690"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11692"></a><code>49
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11694"></a><code>0 rows selected. 
</code><a name="13084"></a><em><code>(T1 released conflicting lock)
</code></em>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11696"></a><strong><code>SET TRANSACTION READ ONLY; 
</code></strong>
</pre></td><td class="Informal"><pre class="CEW"><a name="11698"></a><code>50
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11700"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11702"></a><strong><code>SELECT loc 
</code></strong><a name="13373"></a><strong><code>FROM scott.dept 
</code></strong><a name="13375"></a><strong><code>WHERE deptno = 10; 
</code></strong><a name="12701"></a><code>LOC 
</code><a name="13378"></a><code>- - - - - - 
</code><a name="13380"></a><code>BOSTON 
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11704"></a><code>51
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11706"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11708"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11710"></a><code>52
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11712"></a><strong><code>UPDATE scott.dept 
</code></strong><a name="13382"></a><strong><code>SET loc = 'NEW YORK' 
</code></strong><a name="13384"></a><strong><code>WHERE deptno = 10; 
</code></strong><a name="12707"></a><code>1 row processed.
</code>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11714"></a><strong><code>SELECT loc 
</code></strong><a name="13386"></a><strong><code>FROM scott.dept 
</code></strong><a name="13388"></a><strong><code>WHERE deptno = 10; 
</code></strong><a name="12709"></a><code>LOC 
</code><a name="13390"></a><code>- - - - - - 
</code><a name="13512"></a><code>BOSTON 
</code><a name="13085"></a><em><code>(T1 does not see uncommitted 
data)
</code></em>
</pre></td><td class="Informal"><pre class="CEW"><a name="11716"></a><code>53
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11718"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11720"></a>
</pre></td><td class="Informal"><pre class="CEW"><a name="11722"></a><code>54
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11724"></a><strong><code>COMMIT; 
</code></strong>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11726"></a><strong><code>SELECT loc 
</code></strong><a name="13392"></a><strong><code>FROM scott.dept 
</code></strong><a name="13394"></a><strong><code>WHERE deptno = 10; 
</code></strong><a name="12716"></a><code>LOC 
</code><a name="13396"></a><code>- - - - - - 
</code><a name="13086"></a><em><code>(same results seen even after T2 
commits)
</code></em>
</pre></td><td class="Informal"><pre class="CEW"><a name="11728"></a><code>55
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11730"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11732"></a><strong><code>COMMIT; 
</code></strong>
</pre></td><td class="Informal"><pre class="CEW"><a name="11734"></a><code>56
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11736"></a>
</pre></td></tr><tr class="Informal" align="left"><td class="Informal"><pre class="CEW"><a name="11738"></a><strong><code>SELECT loc 
</code></strong><a name="13398"></a><strong><code>FROM scott.dept 
</code></strong><a name="13400"></a><strong><code>WHERE deptno = 10; 
</code></strong><a name="12723"></a><code>LOC 
</code><a name="13402"></a><code>- - - - - - 
</code><a name="13404"></a><code>NEW YORK 
</code><a name="13087"></a><em><code>(committed data is seen)
</code></em>
</pre></td><td class="Informal"><pre class="CEW"><a name="11740"></a><code>57
</code>
</pre></td><td class="Informal"><pre class="CEW"><a name="11742"></a>
</pre></td></tr></tbody></table> 
<a name="3391"></a> 
 
<p></p> 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Oracle Lock Management Services</font></h4> 
 
<a name="3397"></a> 
<p class="BP">With Oracle Lock Management services, an application developer can include statements in PL/SQL blocks that:</p> 
<ul class="LB1"><li class="LB1" type="disc"><a name="3399"></a>Request a lock of a specific type </li><li class="LB1" type="disc"><a name="3401"></a>Give the lock a unique name recognizable in another procedure in the same or in another instance </li><li class="LB1" type="disc"><a name="3403"></a>Change the lock type </li><li class="LB1" type="disc"><a name="3405"></a>Release the lock </li></ul> 
<a name="20636"></a> 
<p class="BP">Because a reserved user lock is the same as an Oracle lock, it has all the Oracle lock functionality including deadlock detection. User locks never conflict with Oracle locks, because they are identified with the prefix <code>UL</code>.</p> 
<a name="20638"></a> 
<p class="BP">The Oracle Lock Management services are available through procedures in the <code>DBMS_LOCK</code> package.</p> 
<a name="20102"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="10395"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="10396"></a> 
     <ul class="NL"><li class="NL" type="disc"><a name="20033"></a><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/appdev.920/a96590/toc.htm"><u><font color="#0000ff">Oracle9i Application Developer's Guide - Fundamentals</font></u></a></em> for more information about Oracle Lock Management services </li><li class="NL" type="disc"><a name="20037"></a><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/appdev.920/a96612/toc.htm"><u><font color="#0000ff">Oracle9i Supplied PL/SQL Packages and Types Reference</font></u></a></em> for information about <code>DBMS_LOCK</code> </li></ul></td></tr></tbody></table> 
</div> 
<a name="20178"></a> 
 
<h3 class="H1"><a name="CNCPT421"><font face="Arial, Helvetica, sans-serif" color="#330099">Flashback Query</font></a></h3> 
 
<a name="21902"></a> 
<p class="BP">Flashback query lets you view and repair historical data. You can perform queries on the database as of a certain wall clock time or user-specified system commit number (SCN).</p> 
<a name="20163"></a> 
<p class="BP">Flashback query uses Oracle's multiversion read-consistency capabilities to restore data by applying undo as needed. Administrators can configure undo retention by simply specifying how long undo should be kept in the database. Using flashback query, a user can query the database as it existed this morning, yesterday, or last week. The speed of this operation depends only on the amount of data being queried and the number of changes to the data that need to be backed out.</p> 
<a name="20307"></a> 
<p class="BP">You set the date and time you want to view. Then, any SQL query you execute operates on data as it existed at that time. If you are an authorized user, then you can correct errors and back out the restored data without needing the intervention of an administrator.</p> 
<a name="22044"></a> 
<p class="BP">With the <code>AS</code> <code>OF</code> SQL clause, you can choose different snapshots for each table in the query. Associating a snapshot with a table is known as <em class="Italic">table decoration</em>. If you do not decorate a table with a snapshot, then a default snapshot is used for it. All tables without a specified snapshot get the same default snapshot.</p> 
<a name="22132"></a> 
<p class="BP">For example, suppose you want to write a query to find all the new customer accounts created in the past hour. You could do set operations on two instances of the same table decorated with different <code>AS</code> <code>OF</code> clauses.</p> 
<a name="22113"></a> 
<p class="BP">DML and DDL operations can use table decoration to choose snapshots within subqueries. Operations such as <code>INSERT</code> <code>TABLE</code> <code>AS</code> <code>SELECT</code> and <code>CREATE</code> <code>TABLE</code> <code>AS</code> <code>SELECT</code> can be used with table decoration in the subqueries to repair tables from which rows have been mistakenly deleted. Table decoration can be any arbitrary expression: a bind variable, a constant, a string, date operations, and so on. You can open a cursor and dynamically bind a snapshot value (a timestamp or an SCN) to decorate a table with.</p> 
<a name="22174"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="22177"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="22178"></a> <p class="NB"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96540/toc.htm"><em class="Italic"><u><font color="#0000ff">Oracle9i SQL Reference</font></u></em></a> for information on the <code>AS</code> <code>OF</code> clause</p></td></tr></tbody></table> 
</div> 
<a name="20577"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Flashback Query Benefits</font></h4> 
 
<ul class="LB1"><li class="LB1" type="disc"><a name="20586"></a>Application Transparency <p><a name="20598"></a></p> <p class="BP1">Packaged applications, like report generation tools that only do queries, can run in flashback query mode by using logon triggers. Applications can run transparently without requiring changes to code. All the constraints that the application needs to be satisfied are guaranteed to hold good, because ther is a consistent version of the database as of the flashback query time.</p> </li><li class="LB1" type="disc"><a name="20587"></a>Application Performance <p><a name="20597"></a></p> <p class="BP1">If an application requires recovery actions, it can do so by saving SCNs and flashing back to those SCNs. This is a lot easier and faster than saving data sets and restoring them later, which would be required if the application were to do explicit versioning. Using flashback query, there are no costs for logging that would be incurred by explicit versioning.</p> </li><li class="LB1" type="disc"><a name="20588"></a>Online Operation <p><a name="22142"></a></p> <p class="BP1">Flashback query is an online operation. Concurrent DMLs and queries from other sessions are permitted while an object is being queried inside flashback query.The speed of these operations is unaffected. Moreover, different sessions can flash back to different flashback times or SCNs on the same object concurrently. The speed of the flashback query itself depends on the amount of undo that needs to be applied, which is proportional to how far back in time the query goes.</p> </li><li class="LB1" type="disc"><a name="20589"></a>Easy Manageability <p><a name="20595"></a></p> <p class="BP1">There is no additional management on the part of the user, except setting the appropriate retention interval, having the right privileges, and so on. No additional logging has to be turned on, because past versions are constructed automatically, as needed.</p><a name="20821"></a> 
  <div align="center"> 
   <table class="Note" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="Note"><td class="Note"> 
       <hr> <a name="20988"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Notes:</strong></font> <a name="20989"></a> 
       <ul class="NL"><li class="NL" type="disc"><a name="21003"></a>Flashback query does <em class="Italic">not</em> undo anything. It is only a query mechanism. You can take the output from a flashback query and perform an undo yourself in many circumstances. </li><li class="NL" type="disc"><a name="21007"></a>Flashback query does <em class="Italic">not</em> tell you what changed. LogMiner does that. </li><li class="NL" type="disc"><a name="21011"></a>Flashback query can be used to undo changes and can be very efficient if you know the rows that need to be moved back in time. You can in theory use it to move a full table back in time but this is very expensive if the table is large since it involves a full table copy. </li><li class="NL" type="disc"><a name="21015"></a>Flashback query does not work through DDL operations that modify columns, or drop or truncate tables. </li><li class="NL" type="disc"><a name="21016"></a>LogMiner is very good for getting change history, but it gives you changes in terms of deltas (insert, update, delete), not in terms of the before and after image of a row. These can be difficult to deal with in some applications. </li></ul> 
       <hr> </td></tr></tbody></table> 
  </div></li></ul> 
<a name="20939"></a> 
 
<h4 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Some Uses of Flashback Query</font></h4> 
 
<a name="20206"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Self-Service Repair</font></h5> 
 
<a name="20218"></a> 
<p class="BP">Perhaps you accidentally deleted some important rows from a table and wanted to recover the deleted rows. To do the repair, you can move backward in time and see the missing rows and re-insert the deleted row into the current table.</p> 
<a name="20207"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">E-Mail or Voice Mail Applications</font></h5> 
 
<a name="20226"></a> 
<p class="BP">You might have deleted mail in the past. Using flashback query, you can restore the deleted mail by moving back in time and re-inserting the deleted message into the current message box.</p> 
<a name="20234"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Account Balances</font></h5> 
 
<a name="20235"></a> 
<p class="BP">You can view account prior account balances as of a certain day in the month.</p> 
<a name="20829"></a> 
 
<h5 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">Packaged Applications</font></h5> 
 
<a name="20839"></a> 
<p class="BP">Packaged applications (like report generation tools) can make use of flashback query without any changes to application logic. Any constraints that the application expects are guaranteed to be satisfied, because users see a consistent version of the Database as of the given time or SCN.</p> 
<a name="22159"></a> 
<p class="BP">In addition, flashback query could be used after examination of audit information to see the before-image of the data. In DSS enviornments, it could be used for extraction of data as of a consistent point in time from OLTP systems.</p> 
<a name="20196"></a> 
<div align="center"> 
 <table class="NoteAlso" dir="ltr" title="This is a layout table to format a note" cellspacing="0" cellpadding="0" width="80%" border="0"><tbody><tr class="NoteAlso"><td class="NoteAlso"><a name="20333"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="20334"></a> 
     <ul class="NL"><li class="NL" type="disc"><a name="20613"></a><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/appdev.920/a96590/toc.htm"><u><font color="#0000ff">Oracle9i Application Developer's Guide - Fundamentals</font></u></a></em> for more information about using flashback query </li><li class="NL" type="disc"><a name="20617"></a><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/appdev.920/a96612/toc.htm"><u><font color="#0000ff">Oracle9i Supplied PL/SQL Packages and Types Reference</font></u></a></em> for a description of the <code>DBMS_FLASHBACK</code> package </li><li class="NL" type="disc"><a name="20773"></a><em class="Italic"><a href="http://download.oracle.com/docs/cd/B10501_01/server.920/a96521/undo.htm#ADMIN013"><u><font color="#0000ff">Oracle9i Database Administrator's Guide</font></u></a></em> for information about undo tablespaces and setting retention period </li></ul></td></tr></tbody></table> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51c0ce506c198c41c12b8e9a2dd58ab1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">因以下文的损坏或丢失windows/system32/config/system 解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/373dc86c49bf6eb0ed7c8b201bcf8b0d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">我的测试感想</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>