<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（七）系统信息图形化显示 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（七）系统信息图形化显示" />
<meta property="og:description" content="前面我们读取了CPU的信息，并且以QLabel的形式显示了出来，但是只是一些文字的显示，所以这次我想对这些信息做一下美化，让他们看起来好看一些。
首先，我们参考一下Windows是怎么做的。
这是Windows下任务管理器中的信息，以波形图的方式展现了出来，那么我就仿造他做一个吧
我要显示4个信息的波形图，CPU使用率，CPU温度，内存信息，硬盘信息，所以要创建四个Widget窗口，并且画波形图的方法都是一样的，只是传入的值不一样，所以我子类化了一个QWidget，命名为QGraph，在ui设计界面，将控件的类提升为自定义的QGraph类
首先，头文件中的构造函数
#define ROWS 5 //5行 #define COLS 20 //20列 class QGraph : public QWidget { Q_OBJECT public: explicit QGraph(QWidget *parent = 0); ~QGraph(); QColor background_color, line_color; //保存背景色和前景色 int graph_heigh,graph_width; //行间距和列间距 int startX,startY; //起始的坐标 void setColor(QColor bgcolor, QColor lcolor); //设置背景色和前景色，上级调用 void setRate(double rate); //设置数据，上级调用 void dataReset(); //清空数据，上级调用 protected: void paintEvent(QPaintEvent *); //画图事件 private: int cur; //最近一次更新数据的数组索引值 int length = COLS*2&#43;2; //数组长度 double RateData[COLS*2&#43;2]; //用于保存数据，只保存最近的42个数据 }; 观察Windows的界面发现，背景的栅栏使用很浅的颜色画的，线条用深色的颜色，而用于填充的颜色介于背景色与前景色之间。在主窗口实例化了4个窗口，分别为" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5aa846c8d8305e3260c64b13ae52aef9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-23T13:53:03+08:00" />
<meta property="article:modified_time" content="2019-05-23T13:53:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（七）系统信息图形化显示</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p style="margin-left:0cm;">前面我们读取了CPU的信息，并且以QLabel的形式显示了出来，但是只是一些文字的显示，所以这次我想对这些信息做一下美化，让他们看起来好看一些。</p> 
</blockquote> 
<p style="margin-left:0cm;">首先，我们参考一下Windows是怎么做的。</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="484" src="https://images2.imgbox.com/0e/3d/FMWQMtI2_o.png" width="727"></p> 
<p style="margin-left:0cm;">这是Windows下任务管理器中的信息，以波形图的方式展现了出来，那么我就仿造他做一个吧</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">我要显示4个信息的波形图，CPU使用率，CPU温度，内存信息，硬盘信息，所以要创建四个Widget窗口，并且画波形图的方法都是一样的，只是传入的值不一样，所以我子类化了一个QWidget，命名为QGraph，在ui设计界面，将控件的类提升为自定义的QGraph类</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="516" src="https://images2.imgbox.com/62/33/z9cV4iGc_o.png" width="510"></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://images2.imgbox.com/55/1f/TdqlUmvg_o.png" width="456"></p> 
<p style="margin-left:0cm;">首先，头文件中的构造函数</p> 
<pre class="has"><code class="hljs language-cpp">#define ROWS 5 //5行
#define COLS 20 //20列

class QGraph : public QWidget
{
    Q_OBJECT
public:
    explicit QGraph(QWidget *parent = 0);
    ~QGraph();

    QColor background_color, line_color; //保存背景色和前景色

    int graph_heigh,graph_width; //行间距和列间距
    int startX,startY; //起始的坐标

    void setColor(QColor bgcolor, QColor lcolor); //设置背景色和前景色，上级调用
    void setRate(double rate); //设置数据，上级调用

    void dataReset(); //清空数据，上级调用

protected:
    void paintEvent(QPaintEvent *); //画图事件

private:
    int cur; //最近一次更新数据的数组索引值
    int length = COLS*2+2; //数组长度
    double RateData[COLS*2+2]; //用于保存数据，只保存最近的42个数据
};
</code></pre> 
<p style="margin-left:0cm;">观察Windows的界面发现，背景的栅栏使用很浅的颜色画的，线条用深色的颜色，而用于填充的颜色介于背景色与前景色之间。在主窗口实例化了4个窗口，分别为</p> 
<pre class="has"><code class="hljs language-cpp">ui-&gt;cpu_info_widget
ui-&gt;cpu_temp_widget
ui-&gt;mem_info_widget
ui-&gt;disk_info_widget
</code></pre> 
<p style="margin-left:0cm;">所以我们在主窗口为每个对象都传入各自的背景色和前景色</p> 
<pre class="has"><code class="hljs language-cpp">ui-&gt;cpu_info_widget-&gt;setColor(QColor(QRgb(0xd9f4fc)), QColor(QRgb(0x12bff3))); //浅蓝色
ui-&gt;cpu_temp_widget-&gt;setColor(QColor(QRgb(0xfeb9bb)), QColor(QRgb(0xe53439))); //红色
ui-&gt;mem_info_widget-&gt;setColor(QColor(QRgb(0xeed8f9)), QColor(QRgb(0x9e2ed6))); //紫色
ui-&gt;disk_info_widget-&gt;setColor(QColor(QRgb(0xeaf9e2)), QColor(QRgb(0x65c133))); //绿色
</code></pre> 
<p style="margin-left:0cm;">我们每次打开界面的时候，要从界面的最右端开始画图，所以设置了一个清零的方法，每次显示时调用一次。</p> 
<p style="margin-left:0cm;">最重要的就是数据的保存和画图的过程了。</p> 
<p style="margin-left:0cm;">首先我说一下数据的保存。因为我们有20列，所以我初始化了40+2个数组，最后增加的2个是为了在数组循环的时候不重复。一开始，将数组全部赋值为1，每传入一个值就往数组中写入，然后cur标志位+1，当然这里要用length进行模除，是为了当cur超过length的长度时，又可以从0开始计数，达到了循环数组的目的，也就是超过40后的数据会覆盖最远一次记录的数据。</p> 
<pre class="has"><code class="hljs language-cpp">void QGraph::setRate(double rate)
{
    double Rate;
    Rate = static_cast&lt;double&gt;(rate / 100.00);

    cur = (cur+1) % length;
    RateData[cur] = (1.00 - Rate);

    //qDebug() &lt;&lt; QString("RateData[%1] : %2").arg(cur).arg(QString::number(RateData[cur],'f',6));
    this-&gt;update();
}
</code></pre> 
<p style="margin-left:0cm;">画背景栅栏</p> 
<p style="margin-left:0cm;">也就是根据背景色，总行数和总列数画线，主要是坐标值的计算，多理解一下就好了。代码如下</p> 
<pre class="has"><code class="hljs">    QPainter painter(this);
    painter.setPen(background_color);

    painter.setRenderHint(QPainter::Antialiasing, true);  //设置渲染,启动反锯齿

    //画背景
    graph_heigh = this-&gt;height() / ROWS;
    graph_width = this-&gt;width()  / COLS;

    for(int row = 0; row &lt; ROWS+1; row++)
    {
        painter.drawLine(startX,startY+row*graph_heigh,startX+COLS*graph_width,startY+row*graph_heigh);
    }
    for(int col = 0; col &lt; COLS+1; col++)
    {
        painter.drawLine(startX+col*graph_width,startY,startX+col*graph_width,startY+ROWS*graph_heigh);
    }
</code></pre> 
<p style="margin-left:0cm;">画波形线</p> 
<p style="margin-left:0cm;">最近一次更新的数据是cur所标志的数组数据，所以cur+1所指向的数据就是最远一次的数据，我们画图是从左往右画，所以要从最远一次的数据开始，画到最近一次的数据，所以从cur+1的位置往后遍历，一直遍历到cur的位置，就将数组从远到近遍历了一次。</p> 
<p style="margin-left:0cm;">首先设置一下画笔</p> 
<pre class="has"><code class="hljs language-cpp">    QPen line_pen;
    line_pen.setColor(line_color);
    line_pen.setWidth(3);
    line_pen.setStyle(Qt::SolidLine);
    painter.setPen(line_pen);
</code></pre> 
<p style="margin-left:0cm;">开始计算数据</p> 
<pre class="has"><code class="hljs language-cpp">    int line_width = this-&gt;width() / (COLS*2);
    int index = (cur + 1) % length;
    QPointF point;
    QPainterPath linePath(QPointF(startX-5,this-&gt;height()));

    for(int i = 0; i &lt; length; i++)
    {
        point.setX(startX+i*line_width);
        point.setY(static_cast&lt;double&gt;((double)(this-&gt;height())*RateData[index]));
        linePath.lineTo(point);

        index = (index+1) % length;
        //qDebug() &lt;&lt; point;
        //qDebug() &lt;&lt; QString("%1 RateData[%4]:%5").arg(i).arg(index).arg(QString::number(RateData[index],'f',6));
    }
    //linePath.lineTo(QPointF(this-&gt;width()+5,this-&gt;height()));
    linePath.lineTo(QPointF(startX+COLS*graph_width,startY+ROWS*graph_heigh));

    painter.drawPath(linePath);
</code></pre> 
<p style="margin-left:0cm;">通过QPainterPath记录每次经过的点，最后用drawPath将路线绘制出来</p> 
<p style="margin-left:0cm;">最后是颜色的填充</p> 
<p style="margin-left:0cm;">先计算填充的颜色，介于背景色和前景色之间，取中间值</p> 
<pre class="has"><code class="hljs language-cpp">    int bg_r,bg_g,bg_b,l_r,l_g,l_b,r,g,b;
    line_color.getRgb(&amp;l_r,&amp;l_g,&amp;l_b);
    background_color.getRgb(&amp;bg_r,&amp;bg_g,&amp;bg_b);
    r = (l_r + bg_r) / 2;
    g = (l_g + bg_g) / 2;
    b = (l_b + bg_b) / 2;
    QColor brush_color(r,g,b,100);
</code></pre> 
<p style="margin-left:0cm;">设置画刷</p> 
<pre class="has"><code class="hljs language-cpp">    QBrush line_brush;
    line_brush.setColor(brush_color);
    line_brush.setStyle(Qt::SolidPattern);
</code></pre> 
<p style="margin-left:0cm;">将画刷交给画家</p> 
<pre class="has"><code class="hljs language-cpp">    painter.setBrush(line_brush);</code></pre> 
<p><img alt="" class="has" height="408" src="https://images2.imgbox.com/3d/dc/RBfp6KSB_o.png" width="739"></p> 
<p style="margin-left:0cm;">完成，这是在PC机上运行，所以没有CPU温度</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">完整的源码放在github上，有需要可以自行下载。 代码名称为190522.zip</p> 
<p style="margin-left:0cm;">https://github.com/ljy980330/opencv_face_sys</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">有任何问题可以在下面给我留言！大家一起学习！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/522ebae63e051e69eb2cd524ded34dbf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">libevent 的 Android 编译过程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ccb34a8e524b53c8243a29d3baf5363e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Unity中Scale详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>