<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android NDK开发详解连接性之连接蓝牙设备 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android NDK开发详解连接性之连接蓝牙设备" />
<meta property="og:description" content="Android NDK开发详解连接性之连接蓝牙设备 连接技术作为服务器连接作为客户端连接 如需在两台设备之间创建连接，您必须同时实现服务器端和客户端机制，因为其中一台设备必须开放服务器套接字，而另一台设备必须使用服务器设备的 MAC 地址发起连接。服务器设备和客户端设备分别以不同的方式获取所需的 BluetoothSocket。接受传入连接时，服务器会收到套接字信息。客户端会在打开到服务器的 RFCOMM 通道时提供套接字信息。 当服务器和客户端在同一 RFCOMM 通道上都具有已连接的 BluetoothSocket 时，就会将两者视为彼此连接。此时，每台设备都可以获得输入和输出流，并且可以开始传输数据，我们将在有关传输蓝牙数据的部分对此进行讨论。本部分介绍如何在两台设备之间发起连接。
在尝试查找蓝牙设备之前，请确保您拥有适当的蓝牙权限并为应用设置蓝牙。
连接技术 一种实现技术是自动将每个设备准备为服务器，使每台设备打开服务器套接字并监听连接。在这种情况下，任一设备都可以发起与另一台设备的连接并成为客户端。或者，其中一台设备可明确托管连接并按需打开服务器套接字，而另一台设备则发起连接。
图 1. “蓝牙配对”对话框。
注意 ：如果这两个设备之前尚未配对，则 Android 框架会在连接过程中自动向用户显示配对请求通知或对话框，如图 1 所示。因此，当您的应用尝试连接设备时，无需担心设备是否已配对。在用户成功配对两台设备之前，您的 RFCOMM 连接尝试会被阻止；如果用户拒绝配对，或者配对过程失败或超时，尝试连接就会失败。
作为服务器连接 当您想要连接两台设备时，其中一台设备必须保持打开状态的 BluetoothServerSocket 来充当服务器。服务器套接字的用途是监听传入的连接请求，并在请求被接受后提供已连接的 BluetoothSocket。从 BluetoothServerSocket 获取 BluetoothSocket 后，您可以（并且应该）舍弃 BluetoothServerSocket，除非您希望设备接受更多连接。
如需设置服务器套接字并接受连接，请完成以下步骤序列：
通过调用 listenUsingRfcommWithServiceRecord(String, UUID) 获取 BluetoothServerSocket。 该字符串是您的服务的可识别名称，系统会自动将其写入设备上的新服务发现协议 (SDP) 数据库条目。该名称可以任意设置，可以直接使用应用名称。 通用唯一标识符 (UUID) 也包含在 SDP 条目中，并且构成了与客户端设备连接协议的基础。也就是说，当客户端尝试与此设备连接时，它会携带 UUID，该 UUID 可唯一标识其想要连接的服务。这两个 UUID 必须匹配，系统才会接受连接。 UUID 是用于唯一标识信息的字符串 ID 的 128 位标准化格式。UUID 用于标识在系统或网络中需要具有唯一性的信息，因为 UUID 重复的概率实际上为零。它可以独立生成，无需使用集中式授权机构。在这种情况下，它用于唯一标识应用的蓝牙服务。如需获取用于您的应用的 UUID，您可以使用网络上的众多随机 UUID 生成器之一，然后使用 fromString(String) 初始化该 UUID。 通过调用 accept() 开始监听连接请求。 这是阻塞调用。它会在连接被接受或发生异常时返回。仅当远程设备发送的连接请求中包含的 UUID 与使用此监听服务器套接字注册的 UUID 相匹配时，系统才会接受连接。如果操作成功，accept() 会返回一个已连接的 BluetoothSocket。 除非您想接受其他连接，否则请调用 close()。 此方法调用会释放服务器套接字及其所有资源，但不会关闭 accept() 返回的已连接 BluetoothSocket。与 TCP/IP 不同，RFCOMM 一次只允许每个通道有一个已连接的客户端，因此在大多数情况下，在接受已连接的套接字后立即在 BluetoothServerSocket 上调用 close() 是合理的。 由于 accept() 调用是一个阻塞调用，因此请勿在主 activity 界面线程中执行该调用。在其他线程中执行该操作可确保您的应用仍然可以响应其他用户互动。通常而言，可以在应用管理的新线程中执行涉及 BluetoothServerSocket 或 BluetoothSocket 的所有工作。如需取消被阻塞的调用（例如 accept()），请从另一个线程对 BluetoothServerSocket 或 BluetoothSocket 调用 close()。请注意，BluetoothServerSocket 或 BluetoothSocket 上的所有方法都是线程安全的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5f866cdef5dc1d19bd1083975c885ac0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T00:29:15+08:00" />
<meta property="article:modified_time" content="2023-12-28T00:29:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android NDK开发详解连接性之连接蓝牙设备</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Android NDK开发详解连接性之连接蓝牙设备</h4> 
 <ul><li><ul><li><a href="#_6" rel="nofollow">连接技术</a></li><li><ul><li><a href="#_14" rel="nofollow">作为服务器连接</a></li><li><a href="#_137" rel="nofollow">作为客户端连接</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br> 如需在两台设备之间创建连接，您必须同时实现服务器端和客户端机制，因为其中一台设备必须开放服务器套接字，而另一台设备必须使用服务器设备的 MAC 地址发起连接。服务器设备和客户端设备分别以不同的方式获取所需的 BluetoothSocket。接受传入连接时，服务器会收到套接字信息。客户端会在打开到服务器的 RFCOMM 通道时提供套接字信息。 
<p></p> 
<p>当服务器和客户端在同一 RFCOMM 通道上都具有已连接的 BluetoothSocket 时，就会将两者视为彼此连接。此时，每台设备都可以获得输入和输出流，并且可以开始传输数据，我们将在有关传输蓝牙数据的部分对此进行讨论。本部分介绍如何在两台设备之间发起连接。</p> 
<p>在尝试查找蓝牙设备之前，请确保您拥有适当的蓝牙权限并为应用设置蓝牙。</p> 
<h3><a id="_6"></a>连接技术</h3> 
<p>一种实现技术是自动将每个设备准备为服务器，使每台设备打开服务器套接字并监听连接。在这种情况下，任一设备都可以发起与另一台设备的连接并成为客户端。或者，其中一台设备可明确托管连接并按需打开服务器套接字，而另一台设备则发起连接。<br> <img src="https://images2.imgbox.com/67/fe/wPUYxKDu_o.png" alt="在这里插入图片描述"></p> 
<p>图 1. “蓝牙配对”对话框。<br> 注意 ：如果这两个设备之前尚未配对，则 Android 框架会在连接过程中自动向用户显示配对请求通知或对话框，如图 1 所示。因此，当您的应用尝试连接设备时，无需担心设备是否已配对。在用户成功配对两台设备之前，您的 RFCOMM 连接尝试会被阻止；如果用户拒绝配对，或者配对过程失败或超时，尝试连接就会失败。</p> 
<h4><a id="_14"></a>作为服务器连接</h4> 
<p>当您想要连接两台设备时，其中一台设备必须保持打开状态的 BluetoothServerSocket 来充当服务器。服务器套接字的用途是监听传入的连接请求，并在请求被接受后提供已连接的 BluetoothSocket。从 BluetoothServerSocket 获取 BluetoothSocket 后，您可以（并且应该）舍弃 BluetoothServerSocket，除非您希望设备接受更多连接。</p> 
<p>如需设置服务器套接字并接受连接，请完成以下步骤序列：</p> 
<pre><code>通过调用 listenUsingRfcommWithServiceRecord(String, UUID) 获取 BluetoothServerSocket。

该字符串是您的服务的可识别名称，系统会自动将其写入设备上的新服务发现协议 (SDP) 数据库条目。该名称可以任意设置，可以直接使用应用名称。 通用唯一标识符 (UUID) 也包含在 SDP 条目中，并且构成了与客户端设备连接协议的基础。也就是说，当客户端尝试与此设备连接时，它会携带 UUID，该 UUID 可唯一标识其想要连接的服务。这两个 UUID 必须匹配，系统才会接受连接。

UUID 是用于唯一标识信息的字符串 ID 的 128 位标准化格式。UUID 用于标识在系统或网络中需要具有唯一性的信息，因为 UUID 重复的概率实际上为零。它可以独立生成，无需使用集中式授权机构。在这种情况下，它用于唯一标识应用的蓝牙服务。如需获取用于您的应用的 UUID，您可以使用网络上的众多随机 UUID 生成器之一，然后使用 fromString(String) 初始化该 UUID。

通过调用 accept() 开始监听连接请求。

这是阻塞调用。它会在连接被接受或发生异常时返回。仅当远程设备发送的连接请求中包含的 UUID 与使用此监听服务器套接字注册的 UUID 相匹配时，系统才会接受连接。如果操作成功，accept() 会返回一个已连接的 BluetoothSocket。

除非您想接受其他连接，否则请调用 close()。

此方法调用会释放服务器套接字及其所有资源，但不会关闭 accept() 返回的已连接 BluetoothSocket。与 TCP/IP 不同，RFCOMM 一次只允许每个通道有一个已连接的客户端，因此在大多数情况下，在接受已连接的套接字后立即在 BluetoothServerSocket 上调用 close() 是合理的。
</code></pre> 
<p>由于 accept() 调用是一个阻塞调用，因此请勿在主 activity 界面线程中执行该调用。在其他线程中执行该操作可确保您的应用仍然可以响应其他用户互动。通常而言，可以在应用管理的新线程中执行涉及 BluetoothServerSocket 或 BluetoothSocket 的所有工作。如需取消被阻塞的调用（例如 accept()），请从另一个线程对 BluetoothServerSocket 或 BluetoothSocket 调用 close()。请注意，BluetoothServerSocket 或 BluetoothSocket 上的所有方法都是线程安全的。<br> 示例</p> 
<p>以下是接受传入连接的服务器组件的简化线程：<br> Kotlin</p> 
<pre><code>private inner class AcceptThread : Thread() {

   private val mmServerSocket: BluetoothServerSocket? by lazy(LazyThreadSafetyMode.NONE) {
       bluetoothAdapter?.listenUsingInsecureRfcommWithServiceRecord(NAME, MY_UUID)
   }

   override fun run() {
       // Keep listening until exception occurs or a socket is returned.
       var shouldLoop = true
       while (shouldLoop) {
           val socket: BluetoothSocket? = try {
               mmServerSocket?.accept()
           } catch (e: IOException) {
               Log.e(TAG, "Socket's accept() method failed", e)
               shouldLoop = false
               null
           }
           socket?.also {
               manageMyConnectedSocket(it)
               mmServerSocket?.close()
               shouldLoop = false
           }
       }
   }

   // Closes the connect socket and causes the thread to finish.
   fun cancel() {
       try {
           mmServerSocket?.close()
       } catch (e: IOException) {
           Log.e(TAG, "Could not close the connect socket", e)
       }
   }
}

</code></pre> 
<p>Java</p> 
<pre><code>private class AcceptThread extends Thread {
   private final BluetoothServerSocket mmServerSocket;

   public AcceptThread() {
       // Use a temporary object that is later assigned to mmServerSocket
       // because mmServerSocket is final.
       BluetoothServerSocket tmp = null;
       try {
           // MY_UUID is the app's UUID string, also used by the client code.
           tmp = bluetoothAdapter.listenUsingRfcommWithServiceRecord(NAME, MY_UUID);
       } catch (IOException e) {
           Log.e(TAG, "Socket's listen() method failed", e);
       }
       mmServerSocket = tmp;
   }

   public void run() {
       BluetoothSocket socket = null;
       // Keep listening until exception occurs or a socket is returned.
       while (true) {
           try {
               socket = mmServerSocket.accept();
           } catch (IOException e) {
               Log.e(TAG, "Socket's accept() method failed", e);
               break;
           }

           if (socket != null) {
               // A connection was accepted. Perform work associated with
               // the connection in a separate thread.
               manageMyConnectedSocket(socket);
               mmServerSocket.close();
               break;
           }
       }
   }

   // Closes the connect socket and causes the thread to finish.
   public void cancel() {
       try {
           mmServerSocket.close();
       } catch (IOException e) {
           Log.e(TAG, "Could not close the connect socket", e);
       }
   }
}
</code></pre> 
<p>在此示例中，只需要一个传入连接，因此在接受连接并获取 BluetoothSocket 后，应用会立即将获取的 BluetoothSocket 传递给单独的线程、关闭 BluetoothServerSocket 并终止循环。</p> 
<p>请注意，当 accept() 返回 BluetoothSocket 时，表示套接字已连接。因此，您不应像从客户端那样调用 connect()。</p> 
<p>应用专用的 manageMyConnectedSocket() 方法旨在启动用于传输数据的线程，我们在传输蓝牙数据的主题中对此进行了讨论。</p> 
<p>通常，在完成对传入连接的监听后，您应立即关闭 BluetoothServerSocket。在本例中，获取 BluetoothSocket 后会立即调用 close()。您可能还希望在线程中提供一个公共方法，以便在您需要停止监听该服务器套接字时关闭专用 BluetoothSocket。</p> 
<h4><a id="_137"></a>作为客户端连接</h4> 
<p>如需发起与在开放式服务器套接字上接受连接的远程设备的连接，您必须先获取一个表示该远程设备的 BluetoothDevice 对象。如需了解如何创建 BluetoothDevice，请参阅查找蓝牙设备。然后，您必须使用 BluetoothDevice 获取 BluetoothSocket 并发起连接。</p> 
<p>基本步骤如下所示：</p> 
<pre><code>使用 BluetoothDevice，通过调用 createRfcommSocketToServiceRecord(UUID) 获取 BluetoothSocket。

此方法会初始化允许客户端连接到 BluetoothDevice 的 BluetoothSocket 对象。此处传递的 UUID 必须与服务器设备在调用 listenUsingRfcommWithServiceRecord(String, UUID) 以打开其 BluetoothServerSocket 时使用的 UUID 相匹配。如要使用匹配的 UUID，请将 UUID 字符串硬编码到您的应用中，然后通过服务器代码和客户端代码引用该字符串。

通过调用 connect() 发起连接。请注意，此方法为阻塞调用。

在客户端调用此方法后，系统会执行 SDP 查找，以查找具有匹配 UUID 的远程设备。如果查找成功并且远程设备接受连接，则会共享 RFCOMM 通道以便在连接期间使用，并且 connect() 方法会返回。如果连接失败，或者 connect() 方法超时（大约 12 秒后），该方法会抛出 IOException。
</code></pre> 
<p>由于 connect() 是阻塞调用，因此您应始终在独立于主 activity（界面）线程的线程中执行此连接过程。<br> 示例</p> 
<p>以下是发起蓝牙连接的客户端线程的基本示例：<br> Kotlin</p> 
<pre><code>private inner class ConnectThread(device: BluetoothDevice) : Thread() {

   private val mmSocket: BluetoothSocket? by lazy(LazyThreadSafetyMode.NONE) {
       device.createRfcommSocketToServiceRecord(MY_UUID)
   }

   public override fun run() {
       // Cancel discovery because it otherwise slows down the connection.
       bluetoothAdapter?.cancelDiscovery()

       mmSocket?.let { socket -&gt;
           // Connect to the remote device through the socket. This call blocks
           // until it succeeds or throws an exception.
           socket.connect()

           // The connection attempt succeeded. Perform work associated with
           // the connection in a separate thread.
           manageMyConnectedSocket(socket)
       }
   }

   // Closes the client socket and causes the thread to finish.
   fun cancel() {
       try {
           mmSocket?.close()
       } catch (e: IOException) {
           Log.e(TAG, "Could not close the client socket", e)
       }
   }
}

</code></pre> 
<p>Java</p> 
<pre><code>private class ConnectThread extends Thread {
   private final BluetoothSocket mmSocket;
   private final BluetoothDevice mmDevice;

   public ConnectThread(BluetoothDevice device) {
       // Use a temporary object that is later assigned to mmSocket
       // because mmSocket is final.
       BluetoothSocket tmp = null;
       mmDevice = device;

       try {
           // Get a BluetoothSocket to connect with the given BluetoothDevice.
           // MY_UUID is the app's UUID string, also used in the server code.
           tmp = device.createRfcommSocketToServiceRecord(MY_UUID);
       } catch (IOException e) {
           Log.e(TAG, "Socket's create() method failed", e);
       }
       mmSocket = tmp;
   }

   public void run() {
       // Cancel discovery because it otherwise slows down the connection.
       bluetoothAdapter.cancelDiscovery();

       try {
           // Connect to the remote device through the socket. This call blocks
           // until it succeeds or throws an exception.
           mmSocket.connect();
       } catch (IOException connectException) {
           // Unable to connect; close the socket and return.
           try {
               mmSocket.close();
           } catch (IOException closeException) {
               Log.e(TAG, "Could not close the client socket", closeException);
           }
           return;
       }

       // The connection attempt succeeded. Perform work associated with
       // the connection in a separate thread.
       manageMyConnectedSocket(mmSocket);
   }

   // Closes the client socket and causes the thread to finish.
   public void cancel() {
       try {
           mmSocket.close();
       } catch (IOException e) {
           Log.e(TAG, "Could not close the client socket", e);
       }
   }
}
</code></pre> 
<p>请注意，在此代码段中，系统会在尝试连接之前调用 cancelDiscovery()。您始终应在 connect() 之前调用 cancelDiscovery()，尤其是因为无论设备发现当前是否正在进行，cancelDiscovery() 都会成功。如果您的应用需要确定设备是否正在进行中，您可以使用 isDiscovering() 进行检查。</p> 
<p>应用专用的 manageMyConnectedSocket() 方法旨在启动用于传输数据的线程（详见传输蓝牙数据的部分）。</p> 
<p>使用完 BluetoothSocket 后，请始终调用 close()。这样做会立即关闭已连接的套接字并释放所有相关的内部资源。</p> 
<p>本页面上的内容和代码示例受内容许可部分所述许可的限制。Java 和 OpenJDK 是 Oracle 和/或其关联公司的注册商标。</p> 
<p>最后更新时间 (UTC)：2023-11-08。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be983cdf91a408fd482faa486821fac7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">科研学习|论文解读——融合类目偏好和数据场聚类的协同过滤推荐算法研究</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d18f237ab93cc57c5a7db4ece10e78c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">蓝桥圣诞树（C&#43;&#43;）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>