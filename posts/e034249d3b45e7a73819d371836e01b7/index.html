<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023前端面试题总汇（持续更新中...） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2023前端面试题总汇（持续更新中...）" />
<meta property="og:description" content="目录
1、HTML、XHTML、XML 有什么区别？⭐
2、 XML和JSON的区别？
3、是否了解W3C的规范？⭐
4、什么是语义化标签？⭐⭐
5、常用的块级元素和行内元素有哪一些? ⭐
6、行内元素和块级元素的区别？⭐ 7、css盒子模型有几种类型？它们区别是什么 ⭐ 8、标签上title与alt属性有什么区别？
9、 H5新特性有哪些？⭐⭐
10、css3的新特性有哪些？⭐⭐
11、css的引用有哪些，link和@import的区别？
12、href和src的区别？⭐
13、CSS常用尺寸单位有哪些？应用场景？
14、移动端适配方案有哪些？⭐
15、什么是浮动？
16、清除浮动有哪些方法? ⭐
17、css选择器有哪些？⭐
18、CSS 样式覆盖规则？⭐
19、CSS 样式的优先级？⭐⭐
20、display: none 和 visibily: hidden 区别? 21、相对定位，绝对定位，固定定位的区别？
22、说几个未知宽高元素水平垂直居中方法? 二、JS 篇
1、JS数据类型有哪些？区别？⭐⭐⭐
2、JS中检测数据类型的有哪些？⭐⭐
3、JS中的栈和堆是什么？优缺点？⭐⭐⭐
4、深克隆和浅克隆？⭐⭐⭐
5、JS垃圾回收机制？⭐
6、JS哪些操作会造成内存泄露？⭐⭐
7、闭包？⭐⭐
8、什么是原型链？⭐⭐⭐
9、JS继承的方法有哪些？优缺点？⭐
10、new操作符具体都干了什么?⭐⭐
11、JS的几种具体异常类型(报错)
12、什么是事件冒泡？什么是事件委托？
13、事件对象？ 14、undefined 和 null 区别？⭐
15、说一说伪数组和数组的区别？
16、对于数组去重都有哪些方法？⭐⭐ 17、 对join、push、split、splic、slice的理解？
18、说一下this指向？⭐⭐ 19、 js中call、apply、bind有什么区别?⭐⭐
20、箭头函数和普通函数有什么区别？⭐⭐ 21、JQ对象和DOM元素之间如何转换？ 22、JS模块化有哪些？
23、如何操作DOM元素？
24、防抖与节流的区别，并分别用代码表示 24、数组迭代的方法有哪些？ 25、for循环和forEach有什么区别?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e034249d3b45e7a73819d371836e01b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-17T11:16:36+08:00" />
<meta property="article:modified_time" content="2023-11-17T11:16:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023前端面试题总汇（持续更新中...）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81HTML%E3%80%81XHTML%E3%80%81XML%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#1%E3%80%81HTML%E3%80%81XHTML%E3%80%81XML%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90" rel="nofollow">1、HTML、XHTML、XML 有什么区别？⭐</a></p> 
<p id="2%E3%80%81%C2%A0XML%E5%92%8CJSON%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#2%E3%80%81%C2%A0XML%E5%92%8CJSON%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">2、 XML和JSON的区别？</a></p> 
<p id="%C2%A03%E3%80%81%E6%98%AF%E5%90%A6%E4%BA%86%E8%A7%A3W3C%E7%9A%84%E8%A7%84%E8%8C%83%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#%C2%A03%E3%80%81%E6%98%AF%E5%90%A6%E4%BA%86%E8%A7%A3W3C%E7%9A%84%E8%A7%84%E8%8C%83%EF%BC%9F%E2%AD%90" rel="nofollow">3、是否了解W3C的规范？⭐</a></p> 
<p id="%C2%A04%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%EF%BC%9F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#%C2%A04%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%EF%BC%9F%E2%AD%90%E2%AD%90" rel="nofollow">4、什么是语义化标签？⭐⭐</a></p> 
<p id="5%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B%3F%20%E2%AD%90-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B%3F%20%E2%AD%90" rel="nofollow">5、常用的块级元素和行内元素有哪一些? ⭐</a></p> 
<p id="6%E3%80%81%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%C2%A0-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%C2%A0" rel="nofollow">6、行内元素和块级元素的区别？⭐ </a></p> 
<p id="7%E3%80%81css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%20%E2%AD%90%C2%A0-toc" style="margin-left:80px;"><a href="#7%E3%80%81css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%20%E2%AD%90%C2%A0" rel="nofollow">7、css盒子模型有几种类型？它们区别是什么 ⭐ </a></p> 
<p id="8%E3%80%81%E6%A0%87%E7%AD%BE%E4%B8%8Atitle%E4%B8%8Ealt%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#8%E3%80%81%E6%A0%87%E7%AD%BE%E4%B8%8Atitle%E4%B8%8Ealt%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">8、标签上title与alt属性有什么区别？</a></p> 
<p id="9%E3%80%81%20H5%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#9%E3%80%81%20H5%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90" rel="nofollow">9、 H5新特性有哪些？⭐⭐</a></p> 
<p id="10%E3%80%81css3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#10%E3%80%81css3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90" rel="nofollow">10、css3的新特性有哪些？⭐⭐</a></p> 
<p id="11%E3%80%81css%E7%9A%84%E5%BC%95%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8Clink%E5%92%8C%40import%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#11%E3%80%81css%E7%9A%84%E5%BC%95%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8Clink%E5%92%8C%40import%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">11、css的引用有哪些，link和@import的区别？</a></p> 
<p id="12%E3%80%81href%E5%92%8Csrc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#12%E3%80%81href%E5%92%8Csrc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90" rel="nofollow">12、href和src的区别？⭐</a></p> 
<p id="13%E3%80%81CSS%E5%B8%B8%E7%94%A8%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F-toc" style="margin-left:80px;"><a href="#13%E3%80%81CSS%E5%B8%B8%E7%94%A8%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F" rel="nofollow">13、CSS常用尺寸单位有哪些？应用场景？</a></p> 
<p id="14%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#14%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90" rel="nofollow">14、移动端适配方案有哪些？⭐</a></p> 
<p id="%C2%A015%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%AE%E5%8A%A8%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%C2%A015%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%AE%E5%8A%A8%EF%BC%9F" rel="nofollow">15、什么是浮动？</a></p> 
<p id="16%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%3F%20%E2%AD%90-toc" style="margin-left:80px;"><a href="#16%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%3F%20%E2%AD%90" rel="nofollow">16、清除浮动有哪些方法? ⭐</a></p> 
<p id="%C2%A017%E3%80%81css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#%C2%A017%E3%80%81css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90" rel="nofollow">17、css选择器有哪些？⭐</a></p> 
<p id="18%E3%80%81CSS%20%E6%A0%B7%E5%BC%8F%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#18%E3%80%81CSS%20%E6%A0%B7%E5%BC%8F%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99%EF%BC%9F%E2%AD%90" rel="nofollow">18、CSS 样式覆盖规则？⭐</a></p> 
<p id="19%E3%80%81CSS%20%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#19%E3%80%81CSS%20%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E2%AD%90%E2%AD%90" rel="nofollow">19、CSS 样式的优先级？⭐⭐</a></p> 
<p id="%C2%A020%E3%80%81display%3A%20none%20%E5%92%8C%20visibily%3A%20hidden%20%E5%8C%BA%E5%88%AB%3F%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A020%E3%80%81display%3A%20none%20%E5%92%8C%20visibily%3A%20hidden%20%E5%8C%BA%E5%88%AB%3F%C2%A0" rel="nofollow">20、display: none 和 visibily: hidden 区别? </a></p> 
<p id="%C2%A021%E3%80%81%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%EF%BC%8C%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%EF%BC%8C%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%C2%A021%E3%80%81%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%EF%BC%8C%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%EF%BC%8C%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">21、相对定位，绝对定位，固定定位的区别？</a></p> 
<p id="22%E3%80%81%E8%AF%B4%E5%87%A0%E4%B8%AA%E6%9C%AA%E7%9F%A5%E5%AE%BD%E9%AB%98%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%3F%C2%A0-toc" style="margin-left:80px;"><a href="#22%E3%80%81%E8%AF%B4%E5%87%A0%E4%B8%AA%E6%9C%AA%E7%9F%A5%E5%AE%BD%E9%AB%98%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%3F%C2%A0" rel="nofollow">22、说几个未知宽高元素水平垂直居中方法? </a></p> 
<p id="%E4%BA%8C%E3%80%81JS%20%E7%AF%87-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81JS%20%E7%AF%87" rel="nofollow">二、JS 篇</a></p> 
<p id="1%E3%80%81JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#1%E3%80%81JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">1、JS数据类型有哪些？区别？⭐⭐⭐</a></p> 
<p id="2%E3%80%81JS%E4%B8%AD%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#2%E3%80%81JS%E4%B8%AD%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90" rel="nofollow">2、JS中检测数据类型的有哪些？⭐⭐</a></p> 
<p id="3%E3%80%81JS%E4%B8%AD%E7%9A%84%E6%A0%88%E5%92%8C%E5%A0%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#3%E3%80%81JS%E4%B8%AD%E7%9A%84%E6%A0%88%E5%92%8C%E5%A0%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">3、JS中的栈和堆是什么？优缺点？⭐⭐⭐</a></p> 
<p id="4%E3%80%81%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">4、深克隆和浅克隆？⭐⭐⭐</a></p> 
<p id="5%E3%80%81JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#5%E3%80%81JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%E2%AD%90" rel="nofollow">5、JS垃圾回收机制？⭐</a></p> 
<p id="6%E3%80%81JS%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#6%E3%80%81JS%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F%E2%AD%90%E2%AD%90" rel="nofollow">6、JS哪些操作会造成内存泄露？⭐⭐</a></p> 
<p id="%C2%A07%E3%80%81%E9%97%AD%E5%8C%85%EF%BC%9F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#%C2%A07%E3%80%81%E9%97%AD%E5%8C%85%EF%BC%9F%E2%AD%90%E2%AD%90" rel="nofollow">7、闭包？⭐⭐</a></p> 
<p id="8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">8、什么是原型链？⭐⭐⭐</a></p> 
<p id="9%E3%80%81JS%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#9%E3%80%81JS%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E2%AD%90" rel="nofollow">9、JS继承的方法有哪些？优缺点？⭐</a></p> 
<p id="10%E3%80%81new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%3F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#10%E3%80%81new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%3F%E2%AD%90%E2%AD%90" rel="nofollow">10、new操作符具体都干了什么?⭐⭐</a></p> 
<p id="11%E3%80%81JS%E7%9A%84%E5%87%A0%E7%A7%8D%E5%85%B7%E4%BD%93%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B(%E6%8A%A5%E9%94%99)-toc" style="margin-left:80px;"><a href="#11%E3%80%81JS%E7%9A%84%E5%87%A0%E7%A7%8D%E5%85%B7%E4%BD%93%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%28%E6%8A%A5%E9%94%99%29" rel="nofollow">11、JS的几种具体异常类型(报错)</a></p> 
<p id="12%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%9F-toc" style="margin-left:80px;"><a href="#12%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%9F" rel="nofollow">12、什么是事件冒泡？什么是事件委托？</a></p> 
<p id="13%E3%80%81%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%EF%BC%9F%C2%A0-toc" style="margin-left:80px;"><a href="#13%E3%80%81%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%EF%BC%9F%C2%A0" rel="nofollow">13、事件对象？ </a></p> 
<p id="14%E3%80%81undefined%20%E5%92%8C%20null%20%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#14%E3%80%81undefined%20%E5%92%8C%20null%20%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90" rel="nofollow">14、undefined 和 null 区别？⭐</a></p> 
<p id="%C2%A015%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BC%AA%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%C2%A015%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BC%AA%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">15、说一说伪数组和数组的区别？</a></p> 
<p id="16%E3%80%81%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F%E2%AD%90%E2%AD%90%C2%A0-toc" style="margin-left:80px;"><a href="#16%E3%80%81%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F%E2%AD%90%E2%AD%90%C2%A0" rel="nofollow">16、对于数组去重都有哪些方法？⭐⭐ </a></p> 
<p id="17%E3%80%81%C2%A0%E5%AF%B9join%E3%80%81push%E3%80%81split%E3%80%81splic%E3%80%81slice%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F-toc" style="margin-left:80px;"><a href="#17%E3%80%81%C2%A0%E5%AF%B9join%E3%80%81push%E3%80%81split%E3%80%81splic%E3%80%81slice%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F" rel="nofollow">17、 对join、push、split、splic、slice的理解？</a></p> 
<p id="18%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8Bthis%E6%8C%87%E5%90%91%EF%BC%9F%E2%AD%90%E2%AD%90%C2%A0-toc" style="margin-left:80px;"><a href="#18%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8Bthis%E6%8C%87%E5%90%91%EF%BC%9F%E2%AD%90%E2%AD%90%C2%A0" rel="nofollow">18、说一下this指向？⭐⭐ </a></p> 
<p id="19%E3%80%81%C2%A0js%E4%B8%ADcall%E3%80%81apply%E3%80%81bind%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#19%E3%80%81%C2%A0js%E4%B8%ADcall%E3%80%81apply%E3%80%81bind%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F%E2%AD%90%E2%AD%90" rel="nofollow">19、 js中call、apply、bind有什么区别?⭐⭐</a></p> 
<p id="20%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%C2%A0-toc" style="margin-left:80px;"><a href="#20%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%C2%A0" rel="nofollow">20、箭头函数和普通函数有什么区别？⭐⭐ </a></p> 
<p id="21%E3%80%81JQ%E5%AF%B9%E8%B1%A1%E5%92%8CDOM%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F%C2%A0-toc" style="margin-left:80px;"><a href="#21%E3%80%81JQ%E5%AF%B9%E8%B1%A1%E5%92%8CDOM%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F%C2%A0" rel="nofollow">21、JQ对象和DOM元素之间如何转换？ </a></p> 
<p id="22%E3%80%81JS%E6%A8%A1%E5%9D%97%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:80px;"><a href="#22%E3%80%81JS%E6%A8%A1%E5%9D%97%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow">22、JS模块化有哪些？</a></p> 
<p id="23%E3%80%81%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9CDOM%E5%85%83%E7%B4%A0%EF%BC%9F-toc" style="margin-left:80px;"><a href="#23%E3%80%81%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9CDOM%E5%85%83%E7%B4%A0%EF%BC%9F" rel="nofollow">23、如何操作DOM元素？</a></p> 
<p id="24%E3%80%81%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%B9%B6%E5%88%86%E5%88%AB%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%C2%A0-toc" style="margin-left:80px;"><a href="#24%E3%80%81%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%B9%B6%E5%88%86%E5%88%AB%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%C2%A0" rel="nofollow">24、防抖与节流的区别，并分别用代码表示 </a></p> 
<p id="24%E3%80%81%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%C2%A0-toc" style="margin-left:80px;"><a href="#24%E3%80%81%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%C2%A0" rel="nofollow">24、数组迭代的方法有哪些？ </a></p> 
<p id="%C2%A025%E3%80%81for%E5%BE%AA%E7%8E%AF%E5%92%8CforEach%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F-toc" style="margin-left:80px;"><a href="#%C2%A025%E3%80%81for%E5%BE%AA%E7%8E%AF%E5%92%8CforEach%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F" rel="nofollow">25、for循环和forEach有什么区别?</a></p> 
<p id="26%E3%80%81%E4%BD%BF%E7%94%A8JQ%E5%92%8Cvue%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#26%E3%80%81%E4%BD%BF%E7%94%A8JQ%E5%92%8Cvue%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">26、使用JQ和vue的区别？</a></p> 
<p id="%E4%B8%89%E3%80%81ES6%20%E7%AF%87-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81ES6%20%E7%AF%87" rel="nofollow">三、ES6 篇</a></p> 
<p id="1%E3%80%81ES6%E6%96%B0%E5%A2%9E%E7%9A%84%E5%86%85%E5%AE%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#1%E3%80%81ES6%E6%96%B0%E5%A2%9E%E7%9A%84%E5%86%85%E5%AE%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">1、ES6新增的内容有哪些？⭐⭐⭐</a></p> 
<p id="2%E3%80%81ES6%E4%B8%AD%EF%BC%8CSet%E5%92%8CMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#2%E3%80%81ES6%E4%B8%AD%EF%BC%8CSet%E5%92%8CMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">2、ES6中，Set和Map的区别？⭐⭐⭐</a></p> 
<p id="3%E3%80%81map%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#3%E3%80%81map%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">3、map和forEach的区别？</a></p> 
<p id="%C2%A04%E3%80%81es6%20%E4%B8%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#%C2%A04%E3%80%81es6%20%E4%B8%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">4、es6 中的箭头函数？⭐⭐⭐</a></p> 
<p id="5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F%E2%AD%90%E2%AD%90" rel="nofollow">5、什么是扩展运算符，用于什么场景？⭐⭐</a></p> 
<p id="6%E3%80%81JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%9F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#6%E3%80%81JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%9F%E2%AD%90%E2%AD%90" rel="nofollow">6、JS变量提升？⭐⭐</a></p> 
<p id="7%E3%80%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0Module%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F-toc" style="margin-left:80px;"><a href="#7%E3%80%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0Module%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F" rel="nofollow">7、怎么实现Module模块化？</a></p> 
<p id="8%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0%E5%92%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#8%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0%E5%92%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90" rel="nofollow">8、同步和异步的区别？同步函数和异步函数的区别？⭐</a></p> 
<p id="%C2%A09%E3%80%81JS%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#%C2%A09%E3%80%81JS%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">9、JS的执行顺序？同步任务和异步任务？⭐⭐⭐</a></p> 
<p id="10%E3%80%81%C2%A0promise%E5%92%8Casync%20await%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90%C2%A0-toc" style="margin-left:80px;"><a href="#10%E3%80%81%C2%A0promise%E5%92%8Casync%20await%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90%C2%A0" rel="nofollow">10、 promise和async await区别？⭐⭐⭐ </a></p> 
<p id="%E5%9B%9B%E3%80%81TS%20%E7%AF%87-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81TS%20%E7%AF%87" rel="nofollow">四、TS 篇</a></p> 
<p id="%E4%BA%94%E3%80%81VUE%20%E7%AF%87-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81VUE%20%E7%AF%87" rel="nofollow">五、VUE 篇</a></p> 
<p id="1%E3%80%81%E5%86%99%E5%87%BAvue%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%86%99%E5%87%BAvue%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4" rel="nofollow">1、写出vue的常用指令</a></p> 
<p id="2%E3%80%81v-if%20%E5%92%8C%20v-show%20%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#2%E3%80%81v-if%20%E5%92%8C%20v-show%20%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">2、v-if 和 v-show 的区别</a></p> 
<p id="3%E3%80%81v-if%20%E5%92%8C%20v-for%20%E9%82%A3%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E9%AB%98%C2%A0-toc" style="margin-left:80px;"><a href="#3%E3%80%81v-if%20%E5%92%8C%20v-for%20%E9%82%A3%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E9%AB%98%C2%A0" rel="nofollow">3、v-if 和 v-for 那个优先级更高 </a></p> 
<p id="4%E3%80%81v-if%20%E5%92%8C%20v-for%20%E5%8F%AF%E4%BB%A5%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F-toc" style="margin-left:80px;"><a href="#4%E3%80%81v-if%20%E5%92%8C%20v-for%20%E5%8F%AF%E4%BB%A5%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F" rel="nofollow">4、v-if 和 v-for 可以一起使用吗？</a></p> 
<p id="4%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B%EF%BC%88v-on%20%E6%8C%87%E4%BB%A4%EF%BC%89%C2%A0-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B%EF%BC%88v-on%20%E6%8C%87%E4%BB%A4%EF%BC%89%C2%A0" rel="nofollow">5、常用的事件修饰符有哪一些（v-on 指令） </a></p> 
<p id="5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%20DOM-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%20DOM" rel="nofollow">6、什么是虚拟 DOM</a></p> 
<p id="6%E3%80%81%E8%99%9A%E6%8B%9F%20DOM%20%E6%98%AF%E6%80%8E%E4%B9%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E7%9A%84%C2%A0-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E8%99%9A%E6%8B%9F%20DOM%20%E6%98%AF%E6%80%8E%E4%B9%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E7%9A%84%C2%A0" rel="nofollow">7、虚拟 DOM 是怎么更新数据的 </a></p> 
<p id="7%E3%80%81%C2%A0%E8%99%9A%E6%8B%9F%20DOM%20%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E7%9A%84-toc" style="margin-left:80px;"><a href="#7%E3%80%81%C2%A0%E8%99%9A%E6%8B%9F%20DOM%20%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E7%9A%84" rel="nofollow">8、 虚拟 DOM 是怎么生成的</a></p> 
<p id="8%E3%80%81Diff%20%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#8%E3%80%81Diff%20%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93" rel="nofollow">9、Diff 算法总结</a></p> 
<p id="9%E3%80%81%E7%9C%9F%E5%AE%9E%20DOM%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#9%E3%80%81%E7%9C%9F%E5%AE%9E%20DOM%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">10、真实 DOM 的优缺点</a></p> 
<p id="10%E3%80%81%E8%99%9A%E6%8B%9F%20DOM%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#10%E3%80%81%E8%99%9A%E6%8B%9F%20DOM%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">11、虚拟 DOM 的优缺点</a></p> 
<p id="%C2%A012%E3%80%81v-for%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%20key%EF%BC%9F%E4%B8%8D%E5%8A%A0%20key%20%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%C2%A012%E3%80%81v-for%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%20key%EF%BC%9F%E4%B8%8D%E5%8A%A0%20key%20%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F" rel="nofollow">12、v-for 为什么加 key？不加 key 会怎么样？</a></p> 
<p id="11%E3%80%81v-for%20%E5%86%99%E5%9C%A8%20template%20%E4%B8%8A%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%8A%A0%20key%20%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%C2%A0-toc" style="margin-left:80px;"><a href="#11%E3%80%81v-for%20%E5%86%99%E5%9C%A8%20template%20%E4%B8%8A%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%8A%A0%20key%20%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%C2%A0" rel="nofollow">13、v-for 写在 template 上，不能加 key 怎么办？ </a></p> 
<p id="12%E3%80%81vue2%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#12%E3%80%81vue2%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">14、vue2 生命周期？⭐⭐⭐</a></p> 
<p id="13%E3%80%81vue3%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%C2%A0-toc" style="margin-left:80px;"><a href="#13%E3%80%81vue3%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%C2%A0" rel="nofollow">15、vue3 生命周期 </a></p> 
<p id="14%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:80px;"><a href="#14%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">16、小程序生命周期</a></p> 
<p id="15%E3%80%81vue%20%E9%87%8C%E8%BE%B9%E5%A6%82%E4%BD%95%E8%AE%A9%20css%20%E6%A0%B7%E5%BC%8F%E5%8F%AA%E5%9C%A8%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%94%9F%E6%95%88%3F%C2%A0-toc" style="margin-left:80px;"><a href="#15%E3%80%81vue%20%E9%87%8C%E8%BE%B9%E5%A6%82%E4%BD%95%E8%AE%A9%20css%20%E6%A0%B7%E5%BC%8F%E5%8F%AA%E5%9C%A8%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%94%9F%E6%95%88%3F%C2%A0" rel="nofollow">17、vue 里边如何让 css 样式只在当前组件中生效? </a></p> 
<p id="16%E3%80%81vue%20%E7%9A%84%20watch%20%E5%92%8C%20computed%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%96%E4%BB%AC%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F-toc" style="margin-left:80px;"><a href="#16%E3%80%81vue%20%E7%9A%84%20watch%20%E5%92%8C%20computed%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%96%E4%BB%AC%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F" rel="nofollow">18、vue 的 watch 和 computed 有什么区别？他们的应用场景？</a></p> 
<p id="17%E3%80%81%24nextTick%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%9F-toc" style="margin-left:80px;"><a href="#17%E3%80%81%24nextTick%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%9F" rel="nofollow">19、$nextTick 是什么？有什么作用？什么时候用？</a></p> 
<p id="18%E3%80%81%E5%93%AA%E4%B8%AA%E9%98%B6%E6%AE%B5%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%20DOM%20%E8%8A%82%E7%82%B9%EF%BC%9F%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F-toc" style="margin-left:80px;"><a href="#18%E3%80%81%E5%93%AA%E4%B8%AA%E9%98%B6%E6%AE%B5%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%20DOM%20%E8%8A%82%E7%82%B9%EF%BC%9F%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F" rel="nofollow">20、哪个阶段无法获取 DOM 节点？怎么处理？</a></p> 
<p id="19%E3%80%81vue%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20refs%20%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E7%9A%84%20dom%20%E5%85%83%E7%B4%A0%E6%8A%A5%20undefined%20%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F-toc" style="margin-left:80px;"><a href="#19%E3%80%81vue%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20refs%20%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E7%9A%84%20dom%20%E5%85%83%E7%B4%A0%E6%8A%A5%20undefined%20%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F" rel="nofollow">21、vue 中使用 refs 获取组件的 dom 元素报 undefined 如何解决？</a></p> 
<p id="20%E3%80%81%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%E5%90%8E%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#20%E3%80%81%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%E5%90%8E%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">22、多种数据修改后页面不刷新？怎么解决？⭐⭐⭐</a></p> 
<p id="21%E3%80%81Vue.extend%20%E5%92%8C%20Vue.component%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#21%E3%80%81Vue.extend%20%E5%92%8C%20Vue.component%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">23、Vue.extend 和 Vue.component 的区别？</a></p> 
<p id="22%E3%80%81vue%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9%20vue%20%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F-toc" style="margin-left:80px;"><a href="#22%E3%80%81vue%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9%20vue%20%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F" rel="nofollow">24、vue 是什么？说一下对 vue 的理解？⭐⭐⭐⭐</a></p> 
<p id="23%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%90%E8%BF%9B%E5%BC%8F%EF%BC%9F-toc" style="margin-left:80px;"><a href="#23%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%90%E8%BF%9B%E5%BC%8F%EF%BC%9F" rel="nofollow">25、什么是渐进式？⭐⭐⭐</a></p> 
<p id="24%E3%80%81vue%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%3F%20%EF%BC%88%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BC%BA%E9%99%B7%EF%BC%89%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#24%E3%80%81vue%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%3F%20%EF%BC%88%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BC%BA%E9%99%B7%EF%BC%89%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">26、vue 是如何实现双向数据绑定? （原理与缺陷）⭐⭐⭐</a></p> 
<p id="25%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%EF%BC%9F%E2%AD%90%C2%A0-toc" style="margin-left:80px;"><a href="#25%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%EF%BC%9F%E2%AD%90%C2%A0" rel="nofollow">27、什么是订阅发布模式？⭐ </a></p> 
<p id="26%E3%80%81vue2%20%E5%92%8C%20vue3%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#26%E3%80%81vue2%20%E5%92%8C%20vue3%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">28、vue2 和 vue3 有什么区别？⭐⭐⭐</a></p> 
<p id="27%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20mvvm%3F%20mvc%20%E6%98%AF%E4%BB%80%E4%B9%88%3F%E5%8C%BA%E5%88%AB%3F%E5%8E%9F%E7%90%86%3F-toc" style="margin-left:80px;"><a href="#27%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20mvvm%3F%20mvc%20%E6%98%AF%E4%BB%80%E4%B9%88%3F%E5%8C%BA%E5%88%AB%3F%E5%8E%9F%E7%90%86%3F" rel="nofollow">29、什么是 mvvm? mvc 是什么?区别?原理?⭐⭐⭐</a></p> 
<p id="28%E3%80%81react%20%E5%92%8C%20vue%20%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%A1%86%E6%9E%B6%E7%9A%84%E7%9C%8B%E6%B3%95-toc" style="margin-left:80px;"><a href="#28%E3%80%81react%20%E5%92%8C%20vue%20%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%A1%86%E6%9E%B6%E7%9A%84%E7%9C%8B%E6%B3%95" rel="nofollow">30、react 和 vue 有哪些不同，说说你对这两个框架的看法</a></p> 
<p id="29%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20vue%20%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%20SSR%EF%BC%9F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#29%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20vue%20%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%20SSR%EF%BC%9F%E2%AD%90%E2%AD%90" rel="nofollow">31、说一下 vue 的服务端渲染 SSR？⭐⭐</a></p> 
<p id="30%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20%E2%80%9C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E2%80%9D%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#30%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20%E2%80%9C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E2%80%9D%EF%BC%9F%E2%AD%90" rel="nofollow">32、什么是 “状态管理”？⭐</a></p> 
<p id="31%E3%80%81vuex%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#31%E3%80%81vuex%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%E2%AD%90" rel="nofollow">33、vuex 实现原理？⭐</a></p> 
<p id="32%E3%80%81vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#32%E3%80%81vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">34、vuex是什么？怎么用？优点和缺点？什么时候用？⭐⭐⭐</a></p> 
<p id="33%E3%80%81vuex%20%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E5%90%8E%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E2%AD%90%E2%AD%90%E2%AD%90%C2%A0-toc" style="margin-left:80px;"><a href="#33%E3%80%81vuex%20%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E5%90%8E%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E2%AD%90%E2%AD%90%E2%AD%90%C2%A0" rel="nofollow">35、vuex 刷新页面后数据丢失如何解决⭐⭐⭐ </a></p> 
<p id="34%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F-toc" style="margin-left:80px;"><a href="#34%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F" rel="nofollow">36、什么是路由懒加载？为什么要路由懒加载？如何实现？</a></p> 
<p id="35%E3%80%81%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%20vue-router%20%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%9F%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%80%BC%EF%BC%9F%C2%A0-toc" style="margin-left:80px;"><a href="#35%E3%80%81%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%20vue-router%20%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%9F%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%80%BC%EF%BC%9F%C2%A0" rel="nofollow">37、怎么定义 vue-router 的动态路由？怎么获取传过来的值？ </a></p> 
<p id="36%E3%80%81vue%20%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%20%EF%BC%88%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%EF%BC%89%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F-toc" style="margin-left:80px;"><a href="#36%E3%80%81vue%20%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%20%EF%BC%88%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%EF%BC%89%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F" rel="nofollow">38、vue 路由钩子函数 （路由守卫）</a></p> 
<p id="37%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F-toc" style="margin-left:80px;"><a href="#37%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F" rel="nofollow">39、小程序路由跳转有哪些方式？</a></p> 
<p id="38%E3%80%81vue%20%E9%87%8C%E9%9D%A2%20%24route%20%E5%92%8C%20%24router%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#38%E3%80%81vue%20%E9%87%8C%E9%9D%A2%20%24route%20%E5%92%8C%20%24router%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">40、vue 里面 $route 和 $router 的区别？</a></p> 
<p id="39%E3%80%81%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F%20%E2%AD%90-toc" style="margin-left:80px;"><a href="#39%E3%80%81%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F%20%E2%AD%90" rel="nofollow">41、组件开发有什么好处？为什么要封装组件？ ⭐</a></p> 
<p id="40%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F-toc" style="margin-left:80px;"><a href="#40%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F" rel="nofollow">42、什么情况下需要封装组件？</a></p> 
<p id="41%E3%80%81%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E6%B5%81%E7%A8%8B%EF%BC%9F%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E7%9A%84%EF%BC%9F%20%E2%AD%90-toc" style="margin-left:80px;"><a href="#41%E3%80%81%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E6%B5%81%E7%A8%8B%EF%BC%9F%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E7%9A%84%EF%BC%9F%20%E2%AD%90" rel="nofollow">43、组件封装流程？怎么封装组件的？ ⭐</a></p> 
<p id="42%E3%80%81vue%20%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%20%E2%AD%90-toc" style="margin-left:80px;"><a href="#42%E3%80%81vue%20%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%20%E2%AD%90" rel="nofollow">44、vue 的组件通信有哪些方法 ⭐</a></p> 
<p id="43%E3%80%81%24eventBus%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E9%A1%B5%E9%9D%A2%E4%BC%A0%E6%95%B0%E6%8D%AE%EF%BC%9F-toc" style="margin-left:80px;"><a href="#43%E3%80%81%24eventBus%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E9%A1%B5%E9%9D%A2%E4%BC%A0%E6%95%B0%E6%8D%AE%EF%BC%9F" rel="nofollow">45、$eventBus 如何实现跨页面传数据？</a></p> 
<p id="44%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%E7%9A%84%20data%20%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F-toc" style="margin-left:80px;"><a href="#44%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%E7%9A%84%20data%20%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F" rel="nofollow">46、为什么组件的 data 必须是一个函数？</a></p> 
<p id="46%E3%80%81keep-alive%20%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#46%E3%80%81keep-alive%20%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90" rel="nofollow">47、keep-alive 的作用是什么？⭐</a></p> 
<p id="%E5%85%AD%E3%80%81uni-app%20%E7%AF%87-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81uni-app%20%E7%AF%87" rel="nofollow">六、uni-app 篇</a></p> 
<p id="1%E3%80%81uniapp%20APP%20%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%20%EF%BC%88%E5%AE%89%E5%8D%93%20Android%EF%BC%89%E2%AD%90-toc" style="margin-left:80px;"><a href="#1%E3%80%81uniapp%20APP%20%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%20%EF%BC%88%E5%AE%89%E5%8D%93%20Android%EF%BC%89%E2%AD%90" rel="nofollow">1、uniapp 打包过程（安卓 Android）⭐</a></p> 
<p id="2%E3%80%81uniapp%20APP%20%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%20%EF%BC%88%E8%8B%B9%E6%9E%9C%20ISO%EF%BC%89%E2%AD%90-toc" style="margin-left:80px;"><a href="#2%E3%80%81uniapp%20APP%20%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%20%EF%BC%88%E8%8B%B9%E6%9E%9C%20ISO%EF%BC%89%E2%AD%90" rel="nofollow">2、uniapp 打包过程（苹果 ISO）⭐</a></p> 
<p id="3%E3%80%81uniapp%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%20%E2%AD%90-toc" style="margin-left:80px;"><a href="#3%E3%80%81uniapp%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%20%E2%AD%90" rel="nofollow">3、uniapp 小程序打包过程 ⭐</a></p> 
<p id="4%E3%80%81uniapp%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%9F-toc" style="margin-left:80px;"><a href="#4%E3%80%81uniapp%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%9F" rel="nofollow">4、uniapp 的基本配置？</a></p> 
<p id="5%E3%80%81uniapp%20%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%20api%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%20%E6%A0%BC%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#5%E3%80%81uniapp%20%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%20api%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%20%E6%A0%BC%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">5、uniapp 上传文件时用到的 api 是什么？ 格式是什么？</a></p> 
<p id="6%E3%80%81uniapp%20%E8%8E%B7%E5%8F%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E7%9A%84API%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#6%E3%80%81uniapp%20%E8%8E%B7%E5%8F%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E7%9A%84API%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">6、uniapp 获取地理位置的API 是什么？</a></p> 
<p id="7%E3%80%81rpx%E3%80%81px%E3%80%81em%E3%80%81rem%E3%80%81%25%E3%80%81vh%E3%80%81vw%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90-toc" style="margin-left:80px;"><a href="#7%E3%80%81rpx%E3%80%81px%E3%80%81em%E3%80%81rem%E3%80%81%25%E3%80%81vh%E3%80%81vw%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90" rel="nofollow">7、rpx、px、em、rem、%、vh、vw 的区别是什么？⭐</a></p> 
<p id="8%E3%80%81uniapp%20%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%EF%BC%9F-toc" style="margin-left:80px;"><a href="#8%E3%80%81uniapp%20%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%EF%BC%9F" rel="nofollow">8、uniapp 如何监听页面滚动？</a></p> 
<p id="9%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E5%9B%BE%E7%89%87%E5%AE%BD%E5%BA%A6%E4%B8%8D%E5%8F%98%EF%BC%8C%E9%AB%98%E5%BA%A6%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%EF%BC%8C%E4%BF%9D%E6%8C%81%E5%8E%9F%E5%9B%BE%E5%AE%BD%E9%AB%98%E6%AF%94%E4%B8%8D%E5%8F%98%EF%BC%9F-toc" style="margin-left:80px;"><a href="#9%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E5%9B%BE%E7%89%87%E5%AE%BD%E5%BA%A6%E4%B8%8D%E5%8F%98%EF%BC%8C%E9%AB%98%E5%BA%A6%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%EF%BC%8C%E4%BF%9D%E6%8C%81%E5%8E%9F%E5%9B%BE%E5%AE%BD%E9%AB%98%E6%AF%94%E4%B8%8D%E5%8F%98%EF%BC%9F" rel="nofollow">9、如何让图片宽度不变，高度自动变化，保持原图宽高比不变？</a></p> 
<p id="10%E3%80%81uni-app%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F-toc" style="margin-left:80px;"><a href="#10%E3%80%81uni-app%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F" rel="nofollow">10、uni-app 的优缺点？</a></p> 
<p id="11%E3%80%81%E5%88%86%E5%88%AB%E5%86%99%E5%87%BA%20jQuery%E3%80%81vue%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%81uni-app%20%E4%B8%AD%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%C2%A0-toc" style="margin-left:80px;"><a href="#11%E3%80%81%E5%88%86%E5%88%AB%E5%86%99%E5%87%BA%20jQuery%E3%80%81vue%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%81uni-app%20%E4%B8%AD%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%C2%A0" rel="nofollow">11、分别写出 jQuery、vue、小程序、uni-app 中的本地存储 </a></p> 
<p id="12%E3%80%81jq%E3%80%81vue%E3%80%81uni-app%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%3F%20%E2%AD%90-toc" style="margin-left:80px;"><a href="#12%E3%80%81jq%E3%80%81vue%E3%80%81uni-app%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%3F%20%E2%AD%90" rel="nofollow">12、JQ、VUE、uni-app、小程序的页面传参方式? ⭐</a></p> 
<p id="13%E3%80%81vue%20%2C%20%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%2C%20uni-app%20%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#13%E3%80%81vue%20%2C%20%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%2C%20uni-app%20%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">13、vue、微信小程序、uni-app 绑定变量属性区别？</a></p> 
<p id="14%E3%80%81uni-app%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%C2%A0-toc" style="margin-left:80px;"><a href="#14%E3%80%81uni-app%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%C2%A0" rel="nofollow">14、uni-app 的生命周期？ </a></p> 
<p id="15%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#15%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F" rel="nofollow">15、小程序组件传参有哪些方式</a></p> 
<p id="%E4%B8%83%E3%80%81HTTP%20%E8%AF%B7%E6%B1%82%E7%AF%87-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81HTTP%20%E8%AF%B7%E6%B1%82%E7%AF%87" rel="nofollow">七、HTTP 请求篇</a></p> 
<p id="1%E3%80%81%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">1、浏览器输入url后都经历了什么？⭐⭐⭐</a></p> 
<p id="2%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%20HashRouter%20%E5%92%8C%20HistoryRouter%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%20HashRouter%20%E5%92%8C%20HistoryRouter%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">2、HashRouter 和 HistoryRouter 的区别？⭐⭐⭐</a></p> 
<p id="3%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%20cookie%20sessionStorage%20localStorage%20%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%20cookie%20sessionStorage%20localStorage%20%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">3、cookie、sessionStorage、localStorage的区别？⭐⭐⭐</a></p> 
<p id="4%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%BF%87%E6%9C%9F%E7%9A%84%20localstorage%20%E6%95%B0%E6%8D%AE%EF%BC%9F-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%BF%87%E6%9C%9F%E7%9A%84%20localstorage%20%E6%95%B0%E6%8D%AE%EF%BC%9F" rel="nofollow">4、如何实现可过期的 localstorage 数据？</a></p> 
<p id="5%E3%80%81%E8%AF%B7%E5%86%99%E5%87%BA%20http%20%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E8%AF%B7%E6%B1%82%E8%A1%8C%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E3%80%81%E8%AF%B7%E6%B1%82%E4%BD%93%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E8%AF%B7%E5%86%99%E5%87%BA%20http%20%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E8%AF%B7%E6%B1%82%E8%A1%8C%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E3%80%81%E8%AF%B7%E6%B1%82%E4%BD%93%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8" rel="nofollow">5、HTTP 中请求行、请求头、请求体有什么作用？</a></p> 
<p id="6%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8Btoken%20%E8%83%BD%E6%94%BE%E5%9C%A8cookie%E4%B8%AD%E5%90%97%EF%BC%9F-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8Btoken%20%E8%83%BD%E6%94%BE%E5%9C%A8cookie%E4%B8%AD%E5%90%97%EF%BC%9F" rel="nofollow">6、Token 能放在 cookie 中吗？</a></p> 
<p id="7%E3%80%81Token%C2%A0%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%EF%BC%9F-toc" style="margin-left:80px;"><a href="#7%E3%80%81Token%C2%A0%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%EF%BC%9F" rel="nofollow">7、Token 认证流程？</a></p> 
<p id="7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F%E2%AD%90%E2%AD%90" rel="nofollow">8、什么是同源策略？为什么要有同源策略？⭐⭐</a></p> 
<p id="8%E3%80%81XSS%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#8%E3%80%81XSS%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">9、XSS攻击是什么？</a></p> 
<p id="9%E3%80%81CSRF%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#9%E3%80%81CSRF%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">10、CSRF攻击是什么？</a></p> 
<p id="10%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#10%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">11、什么是跨域？为什么有跨域问题？⭐⭐⭐</a></p> 
<p id="11%E3%80%81%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#11%E3%80%81%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">12、跨域的解决方案有哪几种？⭐⭐⭐</a></p> 
<p id="12%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B%EF%BC%9F-toc" style="margin-left:80px;"><a href="#12%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B%EF%BC%9F" rel="nofollow">13、什么是浏览器内核？有什么用？有哪一些？</a></p> 
<p id="13%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%3F-toc" style="margin-left:80px;"><a href="#13%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%3F" rel="nofollow">14、什么是浏览器兼容问题?</a></p> 
<p id="14%E3%80%81%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA(%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98)-toc" style="margin-left:80px;"><a href="#14%E3%80%81%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%28%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%29" rel="nofollow">15、优雅降级和渐进增强(浏览器兼容问题)</a></p> 
<p id="15%E3%80%81http%20%E5%92%8C%20https%20%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8%EF%BC%9F-toc" style="margin-left:80px;"><a href="#15%E3%80%81http%20%E5%92%8C%20https%20%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8%EF%BC%9F" rel="nofollow">16、http 和 https 有何区别？</a></p> 
<p id="16%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F-toc" style="margin-left:80px;"><a href="#16%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F" rel="nofollow">17、常见的HTTP状态码？</a></p> 
<p id="17%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90-toc" style="margin-left:80px;"><a href="#17%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90" rel="nofollow">18、说一说前端性能优化手段？⭐⭐⭐</a></p> 
<p id="18%E3%80%81%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F-toc" style="margin-left:80px;"><a href="#18%E3%80%81%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F" rel="nofollow">19、网站性能优化的好处？怎么优化？</a></p> 
<p id="20%E3%80%81axios%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%EF%BC%9F-toc" style="margin-left:80px;"><a href="#20%E3%80%81axios%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%EF%BC%9F" rel="nofollow">20、axios的拦截器原理及应用？</a></p> 
<p id="21%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%88%9B%E5%BB%BA%20ajax%20%E8%BF%87%E7%A8%8B%EF%BC%9F-toc" style="margin-left:80px;"><a href="#21%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%88%9B%E5%BB%BA%20ajax%20%E8%BF%87%E7%A8%8B%EF%BC%9F" rel="nofollow">21、创建 ajax 过程？</a></p> 
<p id="22%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20fetch%20%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F-toc" style="margin-left:80px;"><a href="#22%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20fetch%20%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F" rel="nofollow">22、说一下 fetch 请求方式？</a></p> 
<p id="23%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%EF%BC%9F-toc" style="margin-left:80px;"><a href="#23%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%EF%BC%9F" rel="nofollow">23、说一下浏览器如何渲染页面的？</a></p> 
<p id="24%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E4%BF%9D%E6%8C%81%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%EF%BC%9F-toc" style="margin-left:80px;"><a href="#24%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E4%BF%9D%E6%8C%81%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%EF%BC%9F" rel="nofollow">24、说一下有什么方法可以保持前后端实时通信？</a></p> 
<p id="%E5%85%AB%E3%80%81git%20%E7%AF%87-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81git%20%E7%AF%87" rel="nofollow">八、git 篇</a></p> 
<p id="1%E3%80%81git%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#1%E3%80%81git%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">1、git 是什么？⭐</a></p> 
<p id="2%E3%80%81git%20%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%9F-toc" style="margin-left:80px;"><a href="#2%E3%80%81git%20%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%9F" rel="nofollow">2、git 常用的命令？⭐</a></p> 
<p id="3%E3%80%81git%20%E5%92%8C%20svn%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#3%E3%80%81git%20%E5%92%8C%20svn%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">3、git 和 svn 的区别？⭐⭐</a></p> 
<p id="4%E3%80%81Git%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub%3F-toc" style="margin-left:80px;"><a href="#4%E3%80%81Git%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub%3F" rel="nofollow">4、Git项目如何配置，如何上传至GitHub?</a></p> 
<p id="5%E3%80%81%E4%BD%A0%E4%BB%AC%E5%85%AC%E5%8F%B8%20git%20%E5%88%86%E6%94%AF%E6%98%AF%E6%80%8E%E4%B9%88%E7%AE%A1%E7%90%86%E7%9A%84%EF%BC%9F-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E4%BD%A0%E4%BB%AC%E5%85%AC%E5%8F%B8%20git%20%E5%88%86%E6%94%AF%E6%98%AF%E6%80%8E%E4%B9%88%E7%AE%A1%E7%90%86%E7%9A%84%EF%BC%9F" rel="nofollow">5、你们公司git分支是怎么管理的？⭐⭐</a></p> 
<p id="6%E3%80%81git%20%E5%B7%A5%E4%BD%9C%E6%B5%81-toc" style="margin-left:80px;"><a href="#6%E3%80%81git%20%E5%B7%A5%E4%BD%9C%E6%B5%81" rel="nofollow">6、git 工作流⭐</a></p> 
<p id="6%E3%80%81git%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#6%E3%80%81git%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">6、git版本冲突是什么？⭐</a></p> 
<p id="7%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3git%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%EF%BC%9F-toc" style="margin-left:80px;"><a href="#7%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3git%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%EF%BC%9F" rel="nofollow">7、如何解决git版本冲突？⭐</a></p> 
<p id="%E4%B9%9D%E3%80%81%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">九、功能的实现</a></p> 
<p id="1%E3%80%81vuex%20%E5%AE%9E%E7%8E%B0%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#1%E3%80%81vuex%20%E5%AE%9E%E7%8E%B0%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD" rel="nofollow">1、vuex 实现购物车功能</a></p> 
<p id="%E5%8D%81%E3%80%81%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E3%80%81%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81" rel="nofollow">十、手撕代码</a></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81%E6%9C%BA%E8%AF%95-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%9C%BA%E8%AF%95" rel="nofollow">十一、机试</a></p> 
<p id="%E4%B9%9D%E3%80%81%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97" rel="nofollow">十二、其他</a></p> 
<p id="1%E3%80%81%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D" rel="nofollow">1、自我介绍</a></p> 
<p id="2%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E7%9A%84-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E7%9A%84" rel="nofollow">2、说一下你是怎么样优化代码的</a></p> 
<p id="3%E3%80%81%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%9A%84-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%9A%84" rel="nofollow">3、你是如何优化项目的</a></p> 
<p id="4%E3%80%81%E5%BC%80%E5%8F%91%E4%B8%AD%E9%83%BD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B7%A5%E5%85%B7-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%BC%80%E5%8F%91%E4%B8%AD%E9%83%BD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B7%A5%E5%85%B7" rel="nofollow">4、开发中都使用了哪些工具</a></p> 
<p id="5%E3%80%81%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E8%BF%87%E4%BB%80%E4%B9%88bug-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E8%BF%87%E4%BB%80%E4%B9%88bug" rel="nofollow">5、开发中遇到过什么bug</a></p> 
<p id="6%E3%80%81%E4%BD%A0%E5%AF%B9%E5%8A%A0%E7%8F%AD%E7%9A%84%E7%9C%8B%E6%B3%95-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E4%BD%A0%E5%AF%B9%E5%8A%A0%E7%8F%AD%E7%9A%84%E7%9C%8B%E6%B3%95" rel="nofollow">6、你对加班的看法</a></p> 
<p id="7%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E5%BC%80%E4%B8%8A%E4%B8%80%E5%AE%B6%E5%85%AC%E5%8F%B8-toc" style="margin-left:80px;"><a href="#7%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E5%BC%80%E4%B8%8A%E4%B8%80%E5%AE%B6%E5%85%AC%E5%8F%B8" rel="nofollow">7、为什么离开上一家公司</a></p> 
<p id="8%E3%80%81%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%9A%84-toc" style="margin-left:80px;"><a href="#8%E3%80%81%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%9A%84" rel="nofollow">8、你是如何学习的</a></p> 
<h4>1、HTML、XHTML、XML 有什么区别？⭐</h4> 
<ol><li><strong>XML： </strong><span style="color:#fe2c24;">XML 是可扩展标记语言</span>，主要是用来存储和传输数据，而非显示数据，可以用来标记数据，定义数据类型，允许用户对自己的标记语言进行定义。</li><li><strong>HTML：</strong><span style="color:#fe2c24;">HTML 是超文本标记语言</span>，主要是用来描述网页的一种标记语言，通过标记标签来描述网页。</li><li><strong>XHTML：</strong><span style="color:#fe2c24;">XHTML 是可扩展超文本标记语言</span>，XHTML 基于 XML 和 HTML 而来，也是用来描述网页的标记语言，是更严格的 HTML 版本。例如：XHTML 元素必须被正确地嵌套，标签名必须用小写字母， 文档必须拥有根元素，对于图片需添加 alt 属性等。XHTML 和 HTML 4.01 几乎是相同的，XHTML 是 W3C 标准。</li><li><strong>XML和HTML区别：</strong>XML 相比 HTML 语法要求严格。HTML 是预定义的，XML 标签是免费的、自定义的、可扩展的。HTML 的设计目的是显示数据并集中于数据外观，XML 的设计目的是描述数据、存放数据并集中于数据的内容。XML 是一种跨平台的，数据处理和传输的工具。总的来说，XML用来传输数据，而 HTML 和 XHTML 用来描述网页，XHTML 比 HTML 更为严格。 </li></ol> 
<h4 id="2%E3%80%81%C2%A0XML%E5%92%8CJSON%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">2、 XML和JSON的区别？</h4> 
<ol><li><strong>JSON：</strong>JSON 是一种轻量级的数据交换格式，它基于 JavaScript 的一个子集，简单的说 JSON 就是一串字符串用于不同平台的数据交换。</li><li><strong>XML：</strong>XML 是可扩展标记语言，是标准通用标记语言 (SGML) 的子集，XML 主要是用来存储和传输数据，而非显示数据，可以用来标记数据、定义数据类型，允许用户对自己的标记语言进行定义。</li><li><strong>JSON和XML区别：</strong>JSON 数据的体积小，传递速度更快，与 JavaScript 数据交互更加方便，更容易解析处理。XML 对数据的描述性比较好。JSON 支持数组，XML 不支持数组。JSON 不支持命名空间，XML 支持命名空间。JSON 容易阅读，XML 难以阅读和解释。JSON 不使用结束标记，XML 有开始和结束标签。JSON 的安全性较低，不支持注释，仅支持 UTF-8 编码。XML 比 JSON 更安全，支持注释，支持各种编码。</li></ol> 
<h4 id="%C2%A03%E3%80%81%E6%98%AF%E5%90%A6%E4%BA%86%E8%A7%A3W3C%E7%9A%84%E8%A7%84%E8%8C%83%EF%BC%9F%E2%AD%90">3、是否了解W3C的规范？⭐</h4> 
<ul><li><strong>w3c 标准指</strong>的是万维网联盟标准，万维网联盟标准指的不是一个标准，而是一系列标准的集合。web 可以简单分为结构、表现、行为三部分，三部分独立开来使其模块化，w3c 是对 web 做出规范，使代码更加严谨，做出来的网页更加容易使用和维护。</li><li><strong>结构标准</strong>主要包括 XHTML 和 XML ，比如像标签闭合、标签元素和属性名字小写、标签不乱嵌套、属性必须有属性值、属性值必须用引号括起来、特殊符号用编码表示、定义语言编码等。标签规范可以提高搜索引擎对页面的抓取效率，对 SEO (搜索引擎优化) 很有帮助，越规范的网站搜索排名越靠前。</li><li><strong>表现标准</strong>主要包括 CSS，<strong>行为标准</strong>主要包括对象模型（像 W3C DOM，ECMAScript），比如说尽量使用外链的 css 和 js 脚本，提高页面的渲染效率，尽量少使用行内样式，类名要做到见名知意。遵循 w3c 标准可以让我们的页面，我们的程序能够支持所有浏览器，能够满足尽可能多的用户。</li><li><strong>W3C 标准的体现</strong>，也就是说是开发者在开发过程中怎么去准守 W3C 标准，其实这里面很多规范是为了 XHTML 的，jQurry 不符合 W3C 标准。</li></ul> 
<h4 id="%C2%A04%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%EF%BC%9F%E2%AD%90%E2%AD%90">4、什么是语义化标签？⭐⭐</h4> 
<ol><li>语义化标签就是标签语义化，让标签有自己的含义，使浏览器和搜索引擎能直观的认识标签的用途和内容。</li><li>虽然可以采用 DIV + CSS 的方式布局页面，但 DIV 标签本身没有特殊含义，文档结构不够清晰，不利于浏览器对页面的读取，在分离 CSS 样式后，体验不友好。</li><li>使用语义化标签可以使代码结构清晰，可读性高，便于团队开放和维护。在页面没有加载 CSS 的情况下也能呈现良好的结构，易于阅读。有利于 SEO（搜索引擎优化）。</li><li>语义化标签是 H5 新特性，语义化标签有：&lt;header&gt; 定义页面的头部，&lt;footer&gt; 定义页面尾部，&lt;nav&gt; 定义导航链接，&lt;article&gt; 内容标签等。</li></ol> 
<h4 id="5%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B%3F%20%E2%AD%90">5、常用的块级元素和行内元素有哪一些? ⭐</h4> 
<ul><li><strong>块级元素：</strong>div、p、h1~h6、ol、ul、li、table、form。</li><li><strong>行内标签：</strong>a、span、img、input、lable、button。</li><li><strong>行内块元素：</strong>img、input、button。</li></ul> 
<h4 id="6%E3%80%81%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%C2%A0">6、行内元素和块级元素的区别？⭐ </h4> 
<ul><li><strong>块级元素：</strong>默认换行，独占一行，可设置宽高 (宽度是父容器的100%)，块级元素可以嵌套任意元素，块级文字不能放入其他块级元素。</li><li><strong>行内元素：</strong>默认不换行，设置宽高无效 (默认宽度是本身内容宽度)，不能包含块级元素，只能包含文本或者其它行内元素，设置 margin，padding 上下无效。</li><li><strong>行内块元素：</strong>综合块级元素与行内元素的特性，可设宽高（默认是内容宽高），也可以设置内外边距。</li><li><strong>转换：</strong>display:block，display:inline，display:inline-block。</li></ul> 
<h4 id="7%E3%80%81css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%20%E2%AD%90%C2%A0">7、css盒子模型有几种类型？它们区别是什么 ⭐ </h4> 
<ul><li>根据盒子大小的计算方式不同，css 盒子模型分成了两种类型，分别是 W3C 标准盒子模型和怪异盒子模型也叫 IE 盒子模型。</li><li>标准盒子模型：设置的宽度 = 内容的宽度，盒子的宽度 = 内容的宽度 + padding*2 + margin*2 + border*2。</li><li>IE盒子模型：设置的宽度 = 盒子的宽度，内容的宽度 = 盒子的宽度 - padding*2 - margin*2 - border*2。</li><li>默认情况下都是标准盒子模型，设置 IE 盒子模型：box-sizing:border-box，设置标准模型：box-sizing:content-box </li></ul> 
<h4 id="8%E3%80%81%E6%A0%87%E7%AD%BE%E4%B8%8Atitle%E4%B8%8Ealt%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">8、标签上title与alt属性有什么区别？</h4> 
<ol><li> <p>alt 是给搜索引擎识别，在图像无法显示时的替代文本。</p> </li><li> <p>title 是元素的注释信息，主要是给用户解读。</p> </li><li> <p>当鼠标放到文字或是图片上时有 title 文字显示。在 IE 浏览器中 alt 起到了 title 的作用，变成文字提示。</p> </li></ol> 
<h4 id="9%E3%80%81%20H5%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90">9、 H5新特性有哪些？⭐⭐</h4> 
<ol><li>语义化标签 
  <table align="left" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td id="fSOe">&lt;header&gt;</td><td>定义文档的头部区域</td></tr><tr><td>&lt;nav&gt;</td><td>定义导航链接</td></tr><tr><td>&lt;article&gt;</td><td>内容标签</td></tr><tr><td>&lt;section&gt;</td><td>定义文档某个区域</td></tr><tr><td>&lt;aside&gt;</td><td>侧边栏标签</td></tr><tr><td>&lt;footer&gt;</td><td>定义了文档的尾部区域</td></tr><tr><td>&lt;figure&gt;</td><td>规定独立的流内容（图像、图表、照片、代码等）</td></tr><tr><td>&lt;figcaption&gt;</td><td>定义 &lt;figure&gt; 元素的标题</td></tr></tbody></table></li><li>增强表单功能 (类型和属性)</li><li>音频视频：&lt;Audio&gt; 、&lt;video&gt;</li><li>画布：&lt;Canvas&gt;</li><li>SVG 绘图</li><li>地理位置</li><li>拖拽 APL</li><li>WebStorage （本地存储：LocalStorage / SessionStorage ）</li></ol> 
<h4 id="10%E3%80%81css3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90">10、css3的新特性有哪些？⭐⭐</h4> 
<ol><li>选择器：层级选择器，属性选择器，状态伪类选择器，结构伪类选择器，伪元素选择器</li><li>文本效果：文本阴影 ，文本自动换行，文本溢出，（单词拆分，文本拆分）</li><li>边框：圆角边框 border-radius，边框阴影 box-shadow，边框图片 border-image</li><li>背景：渐变背景，多重背景 (设定背景图像的尺寸，指定背景图像的位置区域，背景的绘制)</li><li>透明度：opacity （ 取值0-1，通常用于做元素的遮罩效果）</li><li>高斯模糊：filter</li><li>渐变：background: linear-gradient (线性渐变，径向渐变 ，文字渐变)</li><li>过渡：transition</li><li>2D转换 / 3D转换： transform</li><li>动画：Animation （@keyframes 动画帧）</li><li>媒体查询：@media</li><li>多列布局 (兼容性不好，还不够成熟)</li><li>弹性布局 （flex）</li><li>网格布局</li></ol> 
<h4 id="11%E3%80%81css%E7%9A%84%E5%BC%95%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8Clink%E5%92%8C%40import%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">11、css的引用有哪些，link和@import的区别？</h4> 
<p><strong>css 的引用有哪些：</strong></p> 
<ol><li>内联方式（直接在 html 标签中的 style 样式）</li><li>嵌入方式（在 &lt; style &gt; 标签下书写 css 代码）</li><li>链接方式（使用 link 引入外部的 css 文件）</li></ol> 
<p><strong> link 和 @import 的区别：</strong></p> 
<ol><li>link 和 import 写法不同，link 通过 &lt;link&gt; 标签的 href 属性引入，import 通过 @import url() 引入。</li><li>link 是 XHTML 标签，还可以定义其他事务，@import 属于 CSS 范畴，只能加载 CSS。</li><li>link 无兼容问题，@import 兼容 IE5 以上。</li><li>link 支持使用 Javascript 控制 DOM 去改变样式，@import 不支持改变样式。</li><li>link 是连接整个 css 文件，@import 可以模块化引入 css 文件。</li><li>link 引用 CSS 时，在页面加载时同时加载 css，而 @import 会把 css 文件放在页面的最底部，导致 css 最后才加载完毕，等到页面完全加载才加载 css，导致页面留白时间长，影响用户体验。</li></ol> 
<h4 id="12%E3%80%81href%E5%92%8Csrc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90">12、href和src的区别？⭐</h4> 
<ol><li><strong>请求资源不同：</strong>href 超文本引用，用来建立当前元素和文档之间的连接，常用的是link、a 标签。src 会将指向的资源下载并引用到当前文档中，常用的标签有 script，img，iframe 标签。</li><li><strong>作用结果不同：</strong>href 用于在当前文档和引用资源之间确立联系，src 用于替换当前内容。</li><li><strong>浏览器解析方式不同：</strong>herf 引用的资源时，浏览器会将其识别为 CSS 文档，并行下载资源并且不会停止对当前文档的处理。当浏览器解析到 src 时，会暂停其他资源的下载和处理，直接将该资源下载，编译，执行完毕。</li></ol> 
<h4 id="13%E3%80%81CSS%E5%B8%B8%E7%94%A8%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F">13、CSS常用尺寸单位有哪些？应用场景？</h4> 
<ol><li><strong>px：</strong>像素，相对长度单位，它的大小取决于屏幕的分辨率，是一个固定值，不能够自适应。</li><li><strong>em：</strong>相对长度的单位，相对于当前对象内文本的字体尺寸，未设置则默认是浏览器默认字体尺寸。</li><li> <p><strong>rem：</strong>CSS3 中新增的一个相对长度单位，相对于根元素 &lt;html&gt; 的 font-size 字体大小，根元素字体大小未设置，使用浏览器默认字体大小。</p> </li><li> <p><strong>vw：</strong>相对于视口的宽度。视口被均分为100单位的 vw。</p> </li><li> <p><strong>vh：</strong>相对视口高度，视口被均分为100单位的 vh。</p> </li><li> <p><strong>vmin：</strong>相对于视口宽度或高度中较小的那个。其中最小的那个被均分为100单位的 vmin。</p> </li><li> <p><strong>vmax：</strong>相对于视口宽度或高度中较大的那个。其中最大的那个被均分为100单位的 vmax。</p> </li><li> <p><strong>cm：</strong>厘米，绝对长度单位。</p> </li><li> <p><strong>mm：</strong>毫米，绝对长度单位。</p> </li><li> <p><strong>in：</strong>英寸，绝对长度单位。</p> </li><li> <p><strong>%：</strong>百法比</p> </li></ol> 
<p><strong>应用场景：</strong></p> 
<ol><li>在移动端网页开发中，页面要做成响应式的，可使用 rem 配合媒体查询实现。<strong>原理：</strong>通过媒体查询，能够在屏幕尺寸发生改变时，重置 html 根元素的字体大小，页面中的元素都是使用rem 为单位设置的尺寸，因此只要改变根元素字体大小，页面中的其他元素的尺寸就自动跟着修改。</li><li>利用 vw 和 rem 实现响应式。<strong>原理：</strong>由于 vw 被更多浏览器兼容之后，在做移动端响应式页面时，通常使用 vw 配合 rem。原理是使用 vw 设置根元素 html 字体的大小，当窗口大小发生改变，vw 代表的尺寸随着修改，无需加入媒体查询，页面中的其他元素仍使用 rem 为单位，就可实现响应式。</li></ol> 
<h4 id="14%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90">14、移动端适配方案有哪些？⭐</h4> 
<blockquote> 
 <p>vw、rem、em、rpx、%</p> 
</blockquote> 
<h4 id="%C2%A015%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%AE%E5%8A%A8%EF%BC%9F">15、什么是浮动？</h4> 
<p>设置浮动的图片，可以实现文字环绕图片。设置了浮动的块级元素可以排列在同一行。设置了浮动的行内元素可以设置宽高。浮动造成的影响：使盒子脱离文档流，如果父级盒子没有设置高度，需要被子盒子撑开，那么这时候父级盒子的高度就塌陷了，同时也会造成后面的盒子布局受到影响。</p> 
<h4 id="16%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%3F%20%E2%AD%90">16、清除浮动有哪些方法? ⭐</h4> 
<blockquote> 
 <p>清除浮动，主要是为了解决父级元素因为子级浮动引起的内部高度为 0 的问题</p> 
</blockquote> 
<ol><li>父级div定义height （只适合高度固定的布局）</li><li>结尾处加空div标签然后添加一个clear:both样式 （浮动多的话要加很多个div）</li><li>父级 div 定义 overflow：hidden 超出盒子部分会被隐藏 （不推荐）</li><li>父级div定义伪类:（推荐） <pre><code class="language-css"> clearfix：after
     {
          content：""；
          display：block；
          visibility：hidden；
          height：0；
          line-height：0；
          clear：both；
      }</code></pre> </li></ol> 
<h4 id="%C2%A017%E3%80%81css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90">17、css选择器有哪些？⭐</h4> 
<p><strong>基本选择器：</strong></p> 
<ol><li>标签选择器 　  （ div { } ）</li><li>id 选择器　      （ id=”a”, #a { } ）</li><li>类选择器 class （class=”b”, .b { } ）</li><li>通配符选择器   （ * { } ）</li></ol> 
<p><strong> CSS3新增选择器：</strong> </p> 
<ol><li>层级选择器： 
  <table align="left" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>后代选择器</td><td>ul li { } : 选择子类元素，包括间接子类</td></tr><tr><td>子代选择器</td><td>ul&gt;li { } ：选择子类元素，只包括直接子类</td></tr><tr><td>相邻兄弟选择器</td><td>div+p { } : 选择紧跟在 div 元素后面的 p 元素</td></tr><tr><td>通用兄弟选择器</td><td>div~p { } : 选择 div 元素后面的所有 p 元素</td></tr><tr><td>共享选择器</td><td>div1，div2 { } ：选择所有元素</td></tr></tbody></table></li><li>状态伪类选择器</li><li>结构伪类选择器</li><li>表单伪类选择器</li><li>伪元素选择器</li><li>属性选择器</li></ol> 
<h4 id="18%E3%80%81CSS%20%E6%A0%B7%E5%BC%8F%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99%EF%BC%9F%E2%AD%90">18、CSS 样式覆盖规则？⭐</h4> 
<ul><li>规则一：由于继承而发生样式冲突时，最近祖先获胜。</li><li>规则二：继承的样式和直接指定的样式冲突时，直接指定的样式获胜。</li><li>规则三：直接指定的样式发生冲突时，样式权值高者获胜。</li><li>规则四：样式权值相同时，后者获胜。</li><li>规则五：!important 的样式属性不被覆盖。</li></ul> 
<h4 id="19%E3%80%81CSS%20%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E2%AD%90%E2%AD%90">19、CSS 样式的优先级？⭐⭐</h4> 
<ol><li><strong>引入方式：</strong>内联样式的优先级高于嵌入和外链，嵌入和外链的选择器相同就看他们在页面的插入顺序，后面插入的会覆盖前面的。</li><li><strong>选择器优先级：</strong>id 选择器高于 ( 类选择器/伪类选择器/属性选择器 ) 高于 ( 标签选择器/后代选择器/伪元素选择器 ) 高于 ( 子选择器/相邻选择器 ) 高于通配符 *。</li><li><strong>继承样式：</strong>继承样式是所有样式中优先级比较低的，浏览器默认样式优先级最低。</li><li><strong>!important：</strong>!important 最高权重，无论引入方式是什么，选择器是什么，它的优先级都是最高的。所以 !important 使用要谨慎，一定要优先考虑使用样式优先级的规则来解决问题而不是 !important 。只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important。永远不要在插件中使用 !important ，永远不要在全站范围的 CSS 代码中使用 !important.</li></ol> 
<blockquote> 
 <p>!important &gt;&gt; 内联样式 &gt;&gt; id 选择器 &gt;&gt; 类选择器/伪类选择器/属性选择器 &gt;&gt; 标签选择器/后代选择器/伪元素选择器 &gt;&gt; 子选择器/相邻选择器 &gt;&gt; 通配符 * &gt;&gt; 继承样式 &gt;&gt; 浏览器默认样式 </p> 
</blockquote> 
<h4 id="%C2%A020%E3%80%81display%3A%20none%20%E5%92%8C%20visibily%3A%20hidden%20%E5%8C%BA%E5%88%AB%3F%C2%A0">20、display: none 和 visibily: hidden 区别? </h4> 
<ol><li><strong>display:none：</strong>隐藏对应的元素，整个元素消失不占空间。</li><li><strong>visibily:hidden：</strong>隐藏对应的元素，元素还会占用空间。</li><li><strong>disapaly </strong>还可以转换元素类型，可以转换成块级元素、行内元素，行内块元素、弹性布局、网格布局等。<strong>visibility </strong>只能做隐藏。</li></ol> 
<h4 id="%C2%A021%E3%80%81%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%EF%BC%8C%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%EF%BC%8C%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">21、相对定位，绝对定位，固定定位的区别？</h4> 
<ol><li> <p><strong>position:relative：</strong>相对定位，相对于自己进行定位。</p> </li><li> <p><strong>position:absolute：</strong>绝对定位，相对于有相对定位的父级元素进行定位，没有就找 body。</p> </li><li><strong>position:fixed：</strong>固定定位，相对于浏览器定位。</li></ol> 
<h4 id="22%E3%80%81%E8%AF%B4%E5%87%A0%E4%B8%AA%E6%9C%AA%E7%9F%A5%E5%AE%BD%E9%AB%98%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%3F%C2%A0"><strong>22、说几个未知宽高元素水平垂直居中方法? </strong></h4> 
<ul><li><strong>绝对定位：</strong>通过 left，top 和 transform 属性实现水平垂直居中，其中 translate 属性取值为负数时表示向左和向下移动。<span style="color:#fe2c24;">这种方式兼容性好，被广泛使用的一种方式。</span></li></ul> 
<pre><code class="language-css">&lt;style&gt;
    .box {
        position: absolute;
        width: 100px;
        height: 100px;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
    }
&lt;/style&gt;</code></pre> 
<ul><li><strong>弹性布局：</strong>设置父级为弹性盒子：<strong>display:flex </strong>，设置水平和垂直居中：<strong>justify-content:center、align-items:center。</strong><span style="color:#fe2c24;">这种方式代码简洁，但是兼容性 ie11 以上支持。</span></li></ul> 
<pre><code class="language-css">&lt;style&gt;
    .box {
        width: 400px;
        height: 300px;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 1px solid black;
    }
    .child {
        width: 200px;
        height: 150px;
        background-color: red;
    }
&lt;/style&gt;
&lt;body&gt;
    &lt;div class="box"&gt;
        &lt;div class="child"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre> 
<ul><li><strong>网格布局：</strong>设置父级为网格元素：<strong>display: table-cell，</strong>设置水平和垂直居中：<strong>justify-content:center、align-items:center。</strong><span style="color:#fe2c24;">这种方式代码简洁，但是兼容性 ie10 以上支持</span></li><li><strong>表格布局  ：</strong>设置父级为表格元素：<strong>display: table-cell</strong>，内部元素水平和垂直居中：<strong>text-align: center、vertical-align: middle</strong>，设置子元素为行内块：<strong>display: inline-block。</strong><span style="color:#fe2c24;">兼容性好。</span></li></ul> 
<pre><code class="language-css">&lt;style&gt;
    .box {
        width: 400px;
        height: 300px;
        display: table-cell;
        text-align: center;
        vertical-align: middle;
        border: 1px solid black;
    }
    .child {
        width: 200px;
        height: 150px;
        background-color: red;
        display: inline-block;
    }
&lt;/style&gt;
&lt;body&gt;
    &lt;div class="box"&gt;
        &lt;div class="child"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81JS%20%E7%AF%87"><span style="color:#1a439c;">二、JS 篇</span></h2> 
<h4 id="1%E3%80%81JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">1、JS数据类型有哪些？区别？⭐⭐⭐</h4> 
<blockquote> 
 <p>JS 的数据类型分为两类，分别是基本数据类型和引用数据类型。它们主要区别是在内存中的存储方式不同。</p> 
</blockquote> 
<ul><li><strong>基本数据类型：</strong>number 数字、string 字符串、boolean 布尔值、null 空值、undefined 未定义、symbol 唯一值、BigInt 最大值。基本数据类型有固定的大小和值，存放在栈中，可以直接访问，而引用数据类型不确定大小，但是其引用地址是固定的，因此，它的地址存在栈中，指向存储在堆中的对象。</li><li><strong>引用数据类型：</strong>Object (包括普通对象，数组，正则，日期，Math 数学函数等)。引用数据类型是存放在堆中的对象，在栈中保存的是对象在堆中的引用地址(引用变量)，通过引用地址可以快速查找到保存在堆中的对象。</li><li><strong>Symbol </strong>是 Es6 新出的一种数据类型，这种数据类型的特点就是没有重复的数据，可以做 object 的 key。</li><li><strong>BigInt </strong>也是 ES6 新出的一种数据类型，BigInt 可以表示任意大的整数，能够解决解精度缺失的问题 (超过 Number 类型支持范围的数值都会失去精度)。<strong>使用方法：</strong>(1) 整数末尾直接加n：647326483767797n。(2) 调用 BigInt() 构造函数：BigInt("647326483767797")。</li></ul> 
<h4 id="2%E3%80%81JS%E4%B8%AD%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90">2、JS中检测数据类型的有哪些？⭐⭐</h4> 
<ul><li><strong>typeof：</strong>常用于判断基本数据类型，除了 null 检测为 object。对于引用数据类型除了 function 返回 function，其余全部返回 object。</li><li><strong>instanceof：</strong>主要用于检测引用数据类型，不适合用来检测基本数据类型。如果检测的类型在当前实例的原型链上，则返回 true，说明这个实例属于这个类型，否则返回 false。例如： A instanceof B<strong>，</strong>判断 B 在不在 A 的原型链上，如果在就返回 true，如果找到原型链的尽头 null 都没找到，就返回 false。<span style="color:#fe2c24;">(由于原型链的指向可以随意改动，导致检测不准确)</span></li><li><strong>constructor：</strong>获取实例的构造函数判断和某个类型是否相同，如果相同就说明该数据是符合那个数据类型的。使用方法是："实例.constructor"。constructor 可以检测出除了 undefined 和 null 以外的其他类型，因为 undefined 和 null 没有原生构造函数。<span style="color:#fe2c24;">(不可靠，容易被修改)</span></li><li><strong>object.prototype.toString.call( )：</strong>适用于所有类型的判断检测，检测方法是： Object.prototype.toString.call(数据) ，返回的是该数据类型的字符串。</li></ul> 
<h4 id="3%E3%80%81JS%E4%B8%AD%E7%9A%84%E6%A0%88%E5%92%8C%E5%A0%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">3、JS中的栈和堆是什么？优缺点？⭐⭐⭐</h4> 
<blockquote> 
 <p>JS 的变量都储存到内存中，内存中开辟了两个区域储存变量，分别是栈区域和堆区域。<span style="color:#4d4d4d;"> </span>栈与堆实际上是操作系统对进程占用的内存空间的两种管理方式。</p> 
</blockquote> 
<p><strong>栈：</strong></p> 
<ol><li>栈是一种先进后出的数据解构，由操作系统自动分配内存空间，自动释放，占固定的大小空间。</li><li>栈存储的是基本数据类型的值以及引用数据类型的引用地址。</li><li>栈中存储的数据的生命周期随着当前环境的执行完成而结束。</li></ol> 
<p><strong>堆： </strong></p> 
<ol><li>堆由操作系统动态分配内存空间，大小不定也不会自动释放，一般由程序员分配释放也可由垃圾回收机制回收。</li><li>栈存储的是对象和复杂数据结构，存储的是对象的实际数据，而不是对象的引用。</li><li>引用数据类型只有在引用的它的变量不在时，被垃圾回收机制回收。</li></ol> 
<p><strong>栈和堆的优缺点： </strong></p> 
<ol><li>栈相对于堆存取速度更快，且栈内存中数据是可以共享的，但内存空间有限。</li><li>堆存取效率相对较低，但内存空间大。</li><li>栈内存可以及时得到回收，相对来说更容易管理内存空间，但存储在栈中的数据大小和生存期必须是确定的，缺乏灵活性。</li><li>堆的内存是操作系统动态分配的，方便存储和开辟内存空间。有垃圾回收机制，生存周期比较灵活。</li></ol> 
<h4 id="4%E3%80%81%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">4、深克隆和浅克隆？⭐⭐⭐</h4> 
<p><strong>浅克隆：</strong></p> 
<ol><li>克隆对象的第一层属性。</li><li>如果是基本数据类型，直接将存储在栈中的值赋值给对应的变量，原始值改变不会影响。</li><li>如果是引用数据类型，则克隆的是对象的引用地址，改变引用地址，新对象也会跟着改变，想要改变这种继承的现象就要使用深度克隆。</li><li>在 JS 中可以通过 <strong>Object.assign( )</strong> 或者<strong>扩展运算符 ... </strong>合并对象实现浅克隆。</li></ol> 
<p><strong> 深克隆：</strong></p> 
<ol><li>克隆对象各个层级的属性。</li><li>深克隆是指创建一个与原对象完全相同的新对象 (数据源不同，数据地址已变化)。</li><li>可以通过递归的方式实现深克隆，也可以通过简单粗暴的方式实现 JSON.parse (JSON.stringify(obj))。<span style="color:#fe2c24;">但需要注意：</span>时间对象会变成字符串的形式。RegExp、Error 对象序列化的结果将只得到空对象。函数、undefined 序列化的结果会把函数或 undefined 丢失。NaN、Infinity 序列化的结果会变成 null。如果对象中存在循环引用的情况也无法正确实现深拷贝。JSON.stringify() 只能序列化对象的可枚举的自有属性。</li></ol> 
<h4 id="5%E3%80%81JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%E2%AD%90">5、JS垃圾回收机制？⭐</h4> 
<ul><li><strong>内存泄漏：</strong>JS 代码运行时，需要分配内存空间存储变量和值，当这些变量不再作用时，需要释放内存，如果没有及时释放，就会引起内存泄漏，堆积起来会影响性能甚至造成系统崩溃。垃圾回收机制就是为了防止内存泄漏，及时释放不再使用的内存，提高程序性能。</li><li><strong>垃圾回收机制：</strong>垃圾回收机制是一种自动管理内存的机制，它会自动监测和回收不再使用的对象，从而释放内存空间。实现的原理主要有标记清除、引用计数、复制算法。</li><li><strong> 标记清除算法：</strong>垃圾回收器会定期扫描内存中的对象，标记那些可达对象和不可达对象。可达对象指的是正在被使用的对象。不可达对象指的是不再被引用的对象。垃圾回收器会将不可达对象标记为垃圾对象，并将他们从内存中清除。该算法的优点是可以处理循环引用的情况，缺点是由于垃圾回收器的工作需要消耗一定的系统资源，因此如果程序中存在大量的内存占用或者存在频繁创建和销毁对象的操作，执行垃圾回收操作的时间会比较长，对性能造成一定的影响。</li><li><strong>引用计数算法：</strong>垃圾回收器会记录每个对象被引用的次数，当对象被引用的次数为0时，该对象就会被清除。该算法的优点是实现较为简单，但无法处理循环引用的情况，即两个对象相互引用，但是它们的引用次数都不为 0，导致内存无法被释放，可能会导致内存泄漏。</li><li><strong>复制算法：</strong>将内存空间划分为两个相等的区域，每次只使用一个区域，这个区域满时，将其中存活的对象复制到另外一个区域，再将原区域的对象全部清除。优点是可以避免由于产生大量内存碎片而引发的内存分配失败问题。</li></ul> 
<p><strong>存在问题？怎么优化？</strong></p> 
<blockquote> 
 <p>虽然浏览器可以自动的进行垃圾回收，但是当代码比较复杂时，垃圾回收对性能的消耗比较大，所以应该尽量减少垃圾回收。需要根据具体应用的需求和环境进行优化。</p> 
</blockquote> 
<ol><li>对数组进行优化。清空数组时，赋值为[ ]，同时将数组的长度设置为0。</li><li>对象复用，尽量减少对象的创建和销毁次数。</li><li>不再使用的对象就设置为 null。</li><li>函数优化，函数功能单一化。</li><li>尽早释放资源。</li><li>使用闭包，在闭包中的变量不会被垃圾回收机制回收。</li></ol> 
<h4 id="6%E3%80%81JS%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F%E2%AD%90%E2%AD%90">6、JS哪些操作会造成内存泄露？⭐⭐</h4> 
<ol><li>意外的全局变量。由于使用未声明的变量而意外的创建了一个全局变量，而使用这个变量一直留在内存中无法被回收。</li><li>没有清理的DOM元素引用。获取一个DOM元素的引用，元素被删除了，由于保留了元素的引用，所以也无法被回收。</li><li>被遗忘的定时器或者回调函数。</li><li>闭包。</li></ol> 
<h4 id="%C2%A07%E3%80%81%E9%97%AD%E5%8C%85%EF%BC%9F%E2%AD%90%E2%AD%90"><strong>7、闭包？</strong>⭐⭐</h4> 
<p><strong>什么是闭包？</strong></p> 
<p>因为作用域链的存在，函数的内部可以直接读取全局变量，而函数内部无法读取另一个函数内部的局部变量，如果想读取函数内部的局部变量，可以通过闭包来实现。闭包就是在一个函数内部创建另外一个函数，让你可以在一个内层函数中访问到外层函数的局部变量。简单来说，闭包就是可以读取其他函数内部局部变量的函数，本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p> 
<p><strong>为什么要使用闭包？</strong></p> 
<ol><li>局部变量无法共享和长久的保存，而全局变量可能造成变量污染。</li><li>闭包可以读取函数内部的局部变量，且不会被垃圾回收机制回收，可以长期保存。</li></ol> 
<p><strong>闭包的作用？</strong></p> 
<ol><li>在函数外部可以访问函数内部的局部变量。</li><li>可以使函数内部的变量在函数执行结束之后不被销毁 ，长久保存在内存中，不会被垃圾回收机制回收。</li><li>使用闭包，可以封装自己的函数代码，实现模块化。</li><li>保护：避免命名冲突。</li><li>保存：解决循环绑定引发的索引问题。</li></ol> 
<p><strong>闭包的缺点？</strong></p> 
<p>由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出。如何解决：在销毁函数之前，将不使用的局部变量全部删除。</p> 
<p><strong>闭包的应用？</strong></p> 
<ol><li>能够模仿块级作用域。</li><li>设计模式中的单例模式。</li><li>for 循环中的保留 i 的操作。</li><li>防抖和节流。</li><li>函数柯里化。</li><li>在构造函数中定义特权方法。</li><li>Vue 中数据响应式 Observer 中使用闭包。</li></ol> 
<h4 id="8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">8、什么是原型链？⭐⭐⭐</h4> 
<ul><li>每个函数身上都有一个 prototype 的原型对象，并且有一个__proto__的指针指向下一级原型对象，如果一个对象的属性或方法在自身中找不到，那么就会去 prototype 原型对象中查找，如果还找不到继续向上查找直到 null，当_proto_指针指向 null 时形成一个链条，这个链条叫做原型链。</li><li>在原型链中，对象可以继承原型对象的属性和方法。如果想在构造函数中添加属性和方法，可以将它们添加到构造函数的 prototype 属性中，这样通过该构造函数创建的对象都可以访问到这些属性和方法。</li><li>原型链的特点是：对象可以沿着原型链向上查找属性和方法，实现了属性和方法的共享和继承。</li></ul> 
<h4 id="9%E3%80%81JS%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E2%AD%90">9、JS继承的方法有哪些？优缺点？⭐</h4> 
<blockquote> 
 <p>JS继承的方法有以下几种：原型链继承、构造函数继承、组合继承、原型式继承和寄生式继承，寄生组合式继承，ES6 Class实现继承。继承的目的是：重复利用另外一个对象的属性和方法。</p> 
</blockquote> 
<ul><li> <p><strong>原型链继承：</strong>将父类的实例作为子类的原型，从而实现对父类属性和方法的继承。<strong>优点：</strong>写法方便简洁，容易理解。<strong>缺点：</strong>不能传递参数和共享所有继承的属性和方法，当一个发生改变另外一个随之改变。</p> </li><li> <p><strong>构造函数继承：</strong>在子类的构造函数中调用父类的构造函数，使用 apply() 或 call() 方法将父对象的构造函数绑定在子对象上，从而实现对父类实例属性的继承。<strong>优点：</strong>解决了原型链继承不能传参的问题和父类的原型共享的问题。<strong>缺点：</strong>方法都在构造函数中定义，因此无法实现函数复用。</p> </li><li> <p><strong>组合继承：</strong>将原型链继承和构造函数继承结合起来，既可以实现对父类原型属性和方法的继承，又可以实现对父类实例属性的继承。<strong>优点：</strong> 解决了原型链继承和构造函数继承造成的影响。<strong>缺点: </strong>无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p> </li><li> <p><strong>原型式继承：</strong>通过创建一个临时构造函数来实现对父类的属性和方法的继承。<strong>优点：</strong>不需要单独创建构造函数。<strong>缺点：</strong>属性中包含的引用值始终会在相关对象间共享。</p> </li><li> <p><strong>寄生式继承：</strong>在原型式继承的基础上，通过在临时构造函数中添加方法和属性，从而实现对父类的继承。<strong>优点：</strong>写法简单，不需要单独创建构造函数。<strong>缺点：</strong>通过寄生式继承给对象添加函数会导致函数难以重用。</p> </li><li> <p><strong>寄生组合式继承：</strong>通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。<strong>优点：</strong>高效率只调用一次父构造函数，并且因此避免了在子原型上面创建不必要，多余的属性。与此同时，原型链还能保持不变。<strong>缺点：</strong>代码复杂。</p> </li><li> <p><strong>ES6 Class实现继承：</strong>ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面 (Parent.apply(this))。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法加到 this 上面 (所以必须先调用super方法)，然后再用子类的构造函数修改 this。需要注意的是，class 关键字只是原型的语法糖，JS继承仍然是基于原型实现的。<strong> 优点：</strong>语法简单易懂，操作更方便。<strong>缺点：</strong>并不是所有的浏览器都支持 class 关键字 lass Person。</p> </li></ul> 
<h4 id="10%E3%80%81new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%3F%E2%AD%90%E2%AD%90">10、new操作符具体都干了什么?⭐⭐</h4> 
<ol><li>创建一个新对象 obj。</li><li>将该对象与构造函数通过原型链连接起来（设置该对象的构造函数）。</li><li>将构造函数中的 this 绑定到该对象上。</li><li>根据构造函数返回类型作判断，如果是值类型则返回新对象 obj，如果返回对象，则返回构造函数里的对象。</li></ol> 
<pre><code class="language-javascript">// 手写 new 操作符
function mockNew(constructor, ...args) {
    // 1.创建一个新对象 obj
    const obj = {};
    // 2.把构造函数当参数传入，新对象指向构造函数原型对象
    obj.__proto__ = constructor.prototype;
    // 3.通过 apply 将构建函数的 this 指向新对象
    let result = constructor.apply(obj, args);
    // 4.根据返回值判断
    return result instanceof Object ? result : obj;
}</code></pre> 
<h4 id="11%E3%80%81JS%E7%9A%84%E5%87%A0%E7%A7%8D%E5%85%B7%E4%BD%93%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B(%E6%8A%A5%E9%94%99)">11、JS的几种具体异常类型(报错)</h4> 
<ul><li>SyntaxError：语法错误</li><li>ReferenceError：引用错误</li><li>RangeError：范围错误</li><li>ypeError：类型错误</li><li>URLError：与 url 相关参数不正确</li><li>EvalError：全局函数 eval 执行错误</li></ul> 
<h4 id="12%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%9F">12、什么是事件冒泡？什么是事件委托？</h4> 
<ul><li><strong>事件冒泡：</strong>在一个对象上触发某类事件，这个事件会向这个对象的的父级传播，从里到外，直至它被处理或者到达了对象层次的最顶层，即 document 对象。这个过程就是事件冒泡。</li><li><strong>事件委托：</strong>事件委托就是利用事件冒泡，指定一个事件处理程序，就可以管理某一类型的所有事件。<strong>原理：</strong>在元素的父级元素添加事件，点击元素时，因为事件冒泡的作用实现事件委托。简单来说，事件委托就是将子元素的事件通过冒泡的形式交由父元素来执行。<strong>优点：</strong>使用事件委托可以减少代码执行优化资源。 </li></ul> 
<h4 id="13%E3%80%81%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%EF%BC%9F%C2%A0">13、事件对象？ </h4> 
<ul><li><strong>event：</strong>事件对象。</li><li><strong>currentTarget：绑</strong>定的事件。</li><li><strong>target：</strong>触发的事件。</li><li><strong>eventPhase：</strong>返回当前触发的阶段（捕获阶段１，事件派发阶段２，冒泡阶段３）</li><li><strong>type：</strong>返回当前event对象的事件名。</li></ul> 
<h4 id="14%E3%80%81undefined%20%E5%92%8C%20null%20%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90">14、undefined 和 null 区别？⭐</h4> 
<ol><li>undefind 是全局对象的一个属性，当一个变量没有被赋值或者一个函数没有返回值或者某个对象不存在某个属性却去访问或者函数定义了形参但没有传递实参，这时候都是 undefined ，undefined 通过 typeof 判断类型是 undefined。</li><li>null 代表空值，代表一个空对象指针，代表对象的值未设置，相当于一个对象没有设置指针地址就是 null。null 通过 typeof 判断类型是 object。</li><li>undefined 表示一个变量初始状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。当需要释放一个对象时，直接赋值为 null 即可，对象被赋值了null 以后，对象对应的堆内存中的值就是游离状态了，GC 会择机回收该值并释放内存。因此，需要释放某个对象，就将变量设置为 null，即表示该对象已经被清空，目前无效状态。</li><li>null 是 javascript 的关键字，和其它语言一样都是代表<strong>空值</strong>， undefined 却是 javascript 才有的。是为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。</li></ol> 
<h4 id="%C2%A015%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BC%AA%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">15、说一说伪数组和数组的区别？</h4> 
<ol><li>伪数组它的类型不是 Array，而是 Object，而数组类型是 Array。</li><li>伪数组可以使用的 length 属性查看长度，也可以使用 index 获取某个元素，但是不能使用数组的其他方法，也不能改变长度，遍历使用 for in 方法。</li><li>伪数组转换成真数组方法：(1)Array.prototype.slice.call(伪数组) 、(2)[].slice.call(伪数组) (3)Array.from(伪数组)，转换后的数组长度由 length 属性决定，索引不连续时转换结果是连续的，会自动补位。</li></ol> 
<h4 id="16%E3%80%81%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F%E2%AD%90%E2%AD%90%C2%A0">16、对于数组去重都有哪些方法？⭐⭐ </h4> 
<ol><li><strong>双重 for 循环：</strong>这是一个最笨的方法。</li><li><strong>对象属性 key：</strong>利用对象属性名 key 不可以重复这一特点，如果对象中不存在，就 push 进空数组。</li><li><strong>for 循环 + indexOf：</strong>主要是利用 indexOf 的特性，查找元素返回下标，找不到就返回-1。-1就 push 进空数组。</li><li><strong>for 循环 + sort 排序：</strong>利用数组的 sort 排序方法去重，如果第 i 项 和 i-1 项不一致，就 push 进空数组。</li><li><strong>filter + indexOf：</strong>利用 filter 过滤配合 indexOf 查找元素，判断返回元素下标和过滤数组的 index 是否相等。</li><li><strong>Set：</strong>Es6 中新增了数据类型 Set，Set 的最大一个特点就是数据不重复，可以用作数组去重。new Set 方法，返回是一个类数组，需要结合扩展运算符...，转成真实数组。</li><li><strong>set + Array.from：</strong>Set 去重结合 Array.from 转成真实数组。Array.from(new Set(原数组))</li><li><strong>for 循环 + includes：</strong>includes 用来判断一个数组是否包含一个指定的值，是就返回 true，否则返回 false。判断空数组是否包含原数组的某个元素，不包含就 push 进空数组。</li><li><strong>reduce + includes：</strong>利用 reduce 遍历结合 includes去重。</li></ol> 
<h4 id="17%E3%80%81%C2%A0%E5%AF%B9join%E3%80%81push%E3%80%81split%E3%80%81splic%E3%80%81slice%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F">17、 对join、push、split、splic、slice的理解？</h4> 
<ol><li><strong>join：</strong>把数组变成字符串。</li><li><strong>split：</strong>把字符串变成数组。</li><li><strong>push：</strong>往数组最后一位添加成员。</li><li><strong>splice：</strong>增加、修改、删除数组的成员。</li><li><strong>slice：</strong>截取数组，然后返回一个新数组。</li></ol> 
<h4 id="18%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8Bthis%E6%8C%87%E5%90%91%EF%BC%9F%E2%AD%90%E2%AD%90%C2%A0">18、说一下this指向？⭐⭐ </h4> 
<ul><li><strong>全局作用域：</strong>无论是否在严格模式下，this 指向 window 对象。严格模式下全局作用域中函数中的 this 等于 undefined。不是严格模式时，全局作用域中函数中的 this 指向 window。</li><li><strong>对象中的函数：</strong>对象的函数中的 this 指向调用函数的对象实例。谁调用函数 this，this 就指向谁。</li><li> <p><strong><span style="color:#0d0016;">事件处理函数：</span></strong>在事件处理函数中，this 指向触发事件的目标对象。</p> </li><li><strong>构造函数：</strong>构造函数中的 this 指向构造函数创建的对象实例。</li><li><strong>箭头函数：</strong>this 对应定义时所在的对象，也就是上一级作用域中的 this。箭头函数的 this 不会被改变。</li><li><strong>嵌套函数：</strong>嵌套函数中的 this 不会继承外层函数的 this 值。</li><li><strong>new：</strong>由 new 调用的话，this 指向新创建的对象。</li><li><strong>call、apply、bind：</strong>由 call、apply、bind 调用，this 指向指定的对象。</li><li> <p><strong>定时器：</strong>定时器中的 this，指向的是 window。</p> </li></ul> 
<h4 id="19%E3%80%81%C2%A0js%E4%B8%ADcall%E3%80%81apply%E3%80%81bind%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F%E2%AD%90%E2%AD%90">19、 js中call、apply、bind有什么区别?⭐⭐</h4> 
<ol><li>原生 JS 提供了 call、apply、bind 三种方式来修改 this 指向。</li><li>call 和 bind 是选项式参数，apply 是数组式参数。</li><li>call、apply 会立即执行，bind 返回一个新函数，不会立即执行。</li><li>call、apply 临时改变 this 指向一次，bind 永久改变 this 指向。</li><li>应用场景：call 用于对象的继承 、伪数组转换成真数组。apply 用于找出数组中的最大值和最小值以及数组合并。bind 用于 vue 或者 react 框架中改变函数的 this 指向。</li></ol> 
<h4 id="20%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%C2%A0"><strong>20、箭头函数和普通函数有什么区别？⭐⭐ </strong></h4> 
<ol><li>普通函数的 this 指针指向调用者，可以修改。</li><li>箭头函数没有自己的 this，它的 this 是继承而来，默认指向在定义它时所处的对象 (父级作用域)，不能修改。</li></ol> 
<h4 id="21%E3%80%81JQ%E5%AF%B9%E8%B1%A1%E5%92%8CDOM%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F%C2%A0">21、JQ对象和DOM元素之间如何转换？ </h4> 
<ul><li>DOM转JQ对象：$(DOM对象) 或 $("div")。</li><li>JQ对象转DOM：可以通过[index] 或者 .get(index)方法，例如 $("div")[0] 或者 $("div").get(1)。</li></ul> 
<h4 id="22%E3%80%81JS%E6%A8%A1%E5%9D%97%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">22、JS模块化有哪些？</h4> 
<p> commonjs、es6、amd、cmd</p> 
<h4 id="23%E3%80%81%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9CDOM%E5%85%83%E7%B4%A0%EF%BC%9F">23、如何操作DOM元素？</h4> 
<p>原生操作DOM元素：</p> 
<ul><li>直接给相应的元素加 id ,然后再 document.getElementById("id") 获取。</li></ul> 
<p>vue操作DOM元素：</p> 
<ul><li>获取/操作根元素 DOM：$root。</li><li>获取/操作父元素 DOM：$parent。</li><li>获取/操作子元素 DOM： $refs $children。</li><li>使用 ref，给相应的元素加 ref=“name” 然后再 this.$refs.name 获取到该元素。</li></ul> 
<h4 id="24%E3%80%81%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%B9%B6%E5%88%86%E5%88%AB%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%C2%A0">24、防抖与节流的区别，并分别用代码表示 </h4> 
<ul><li><strong>防抖：</strong>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间。<strong>作用：</strong>防止事件连续或高频触发，让它只触发一次或者最后一次。</li><li><strong>节流：</strong>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率。作用：降低事件触发的频率，比如1s内最多执行一次。</li><li><strong>区别：</strong>防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行一次。 <pre><code class="language-javascript">//防抖和节流函数都是用于防止事件高频率的重复触发
//防抖: 在一定时间内，如果方法没用再次被触发，则执行最后一次
&lt;body&gt;
    &lt;button&gt;点我&lt;/button&gt;
    &lt;script&gt;
        var btn = document.querySelector("button");
        var tiemr = null;
        btn.onclick = function () {
            clearInterval(tiemr);
            tiemr = setTimeout(() =&gt; {
                console.log("我触发了")
            }, 500)
        }
    &lt;/script&gt;
&lt;/body&gt;

//节流：在规定时间内只只执行一次或数次
&lt;body&gt;
	&lt;button&gt;按钮&lt;/button&gt;
	&lt;script&gt;
	    var btn = document.querySelector("button");
		var jie = true;
		btn.onclick = function() {
			if(jie) {
			    jie = flase;
				console.log('发送了请求');
                setTimeout(()=&gt;{
				    jie = true;
				},2000)
			}
		}	
	&lt;/script&gt;
&lt;/body&gt;</code></pre> </li></ul> 
<h4 id="24%E3%80%81%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%C2%A0"><strong>24、数组迭代的方法有哪些？ </strong></h4> 
<ol><li>for。</li><li>for in：可以遍历对象, 首个行参是 key。</li><li>for of：只能遍历数组，首个行参是 value：。</li><li>forEach：for的增强版，特殊简化版，不支持在循环中添加删除操作。</li><li>while ：先判断后执行。</li><li>do while：先执行后判断。</li><li>some：所有返回值都为真则返回真，否则返回假。</li><li>every：反之。</li></ol> 
<h4 id="%C2%A025%E3%80%81for%E5%BE%AA%E7%8E%AF%E5%92%8CforEach%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F">25、for循环和forEach有什么区别?</h4> 
<ol><li>for 循环的 return 是终止循环 forEach 是返回参数。</li><li>for 循环实际上是可以使用 break 和 continue 去终止循环的，但是 forEach 不行。</li><li>forEach 不支持在循环中添加删除操作。</li><li>for 多数时候都可以使用，一般我们需要知道循环次数。而 forEach 更适合于集合对象的遍历和操作。</li></ol> 
<h4 id="26%E3%80%81%E4%BD%BF%E7%94%A8JQ%E5%92%8Cvue%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">26、使用JQ和vue的区别？</h4> 
<p>JQ 是函数库，本质上还是操控 JS，只不过更简便了。vue 是 mvvm 框架，核心是双向数据绑定，</p> 
<p>一般情况下不需要操控 DOM 元素，而是操控数据为主。</p> 
<h2 id="%E4%B8%89%E3%80%81ES6%20%E7%AF%87"><span style="color:#1a439c;">三、ES6 篇</span></h2> 
<h4 id="1%E3%80%81ES6%E6%96%B0%E5%A2%9E%E7%9A%84%E5%86%85%E5%AE%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><strong>1、</strong>ES6新增的内容有哪些？⭐⭐⭐</h4> 
<p>let、const、结构赋值、class 类、箭头函数、map、set、promise、async await(es7)、扩展运算符...、Module 模块化。</p> 
<h4 id="2%E3%80%81ES6%E4%B8%AD%EF%BC%8CSet%E5%92%8CMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span style="color:#0d0016;">2、</span>ES6中，Set和Map的区别  ？⭐⭐⭐</h4> 
<blockquote> 
 <p><strong>set：</strong>ES6 提供新的数据结构 set，它类似于数组，但是成员的值都是唯一的，没有重复的值。可以用来做数组去重，但是 set 是伪数组，可以通过 Array.from() 或者扩展运算符...转换成数组。Set 结构没有键名，只有键值 (或者说键名和键值是同一个值)。可以使用 keys()、values()、entries()、forEach() 方法遍历成员，使用 for..of... 循环遍历 Set。如果想直接在遍历操作中改变原来的 Set 结构，可以利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构，或者使用 Array.from 方法。</p> 
</blockquote> 
<p> 实例操作方法: size、add、delete、has、clear。</p> 
<ul><li>size：返回 set 实例的成员总数。</li><li>add(value)：添加某个值，返回 set 结构本身。</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li><li>has(value)：返回一个布尔值，表示该值是否为 set 的成员。</li><li>clear()：清除所有成员，没有返回值。</li></ul> 
<blockquote> 
 <p><strong>Map：</strong>"键值对" 的数据结构，可以实现数组重组。JavaScript 对象 object 本质上是键值对的集合，缺陷是只能使用字符串作为键，而 map 结构优化了这个缺陷，它提供了 "值-值" 对的形式，让键名不再局限于字符串，是一种更完善的 Hash 结构实现。简单来说：Map 类似于对象，也是键值对的集合，但是 "键" 的范围不限于字符串， 各种类型的值（包括对象）都可以当作键。遍历方法：keys( )、values( )、entries( )、forEach( )、for..of...。注意：由于一个 key 只能对应一个 value，所以多次对一个 key 放入 value，后面的值会把前面的值冲掉。</p> 
</blockquote> 
<p> 实例操作方法：size、set、get、has、delete、clear。</p> 
<ul><li>size：返回 Map 实例的成员总数。</li><li>set：添加新的 key-value。</li><li>get：传入一个 key 返回一个 val。</li><li>delete：传入一个 key，删除这个 key-value。</li><li>has：查看是否有这个 key。</li><li>clear：清除所有成员，没有返回值。</li></ul> 
<p><strong>Set 和 Map 的区别：</strong></p> 
<ol><li>Map 类似于对象也是键值对的集合，但 '键' 的范围不限于字符串可以是各种数据类型。Set 类似于数组，Set 对象是值的集合。</li><li>Map 存储 key-value 键值对，是一组映射关系。Set 只存储 key，没有 value，value 就是 key。</li><li>Set 的值是唯一的、不重复的，Map 的 key 是唯一的。</li><li>Map 可以通过 get 方法获取值，而 Set 不能因为它只有值。</li><li>Set 的值是唯一的可以做数组去重，Map 由于没有格式限制，可以做数据存储。</li><li>初始化需要值不一样，Map 需要的是一个二维数组，而 Set 需要的是一维 Array 数组。</li><li>都能通过迭代器进行 for...of 遍历。</li></ol> 
<h4 id="3%E3%80%81map%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">3、map和forEach的区别？</h4> 
<ul><li>map：map 有返回值，可以开辟新空间，return 出来一个 length 和原数组一致的数组，即便数组元素是 undefined 或者是 null，map 能新增删除元素。</li><li>forEach 默认无返回值，返回结果为 undefined，可以通过在函数体内部使用索引修改数组元素，forEach 不能新增删除元素。</li></ul> 
<h4 id="%C2%A04%E3%80%81es6%20%E4%B8%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">4、es6 中的箭头函数？⭐⭐⭐</h4> 
<ol><li>箭头函数相当于匿名函数，简化了函数定义。</li><li>箭头函数有两种写法，当函数体是单条语句的时候可以省略 {} 和 return，另一种是包含多条语句，不可以省略 {} 和 return。</li><li>箭头函数最大的特点就是没有自己的 this，它的 this 是从外部获取，就是继承外部的执行上下文中的 this。</li><li>由于没有 this 关键字所以箭头函数也不能作为构造函数。</li><li>箭头函数也没有原型和 super。</li><li>不能使用 yield 关键字，因此箭头函数不能用作 Generator 函数。</li><li> <p>适用场景：简单的函数表达式，内部没有 this 引用，没有递归、事件绑定、解绑定，适用于 map、filter 等方法中。</p> </li></ol> 
<h4 id="5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F%E2%AD%90%E2%AD%90">5、什么是扩展运算符，用于什么场景？⭐⭐</h4> 
<ol><li>扩展运算符(…) 是一个展开语法，用于取出对象或数组中的所有可遍历属性或元素，然后将它们展开到当前的位置，展开的内容可以放在任何它可以存在的地方(数组，函数，对象)。</li><li>在对象中：扩展运算符可以用于创建新的对象，将多个对象合并成一个对象，或者复制一个对象。</li><li>在数组中：在函数调用时将一个数组参数转为用逗号分隔的参数序列。数组拷贝[...arr]。合并数组。扩展运算符与解构赋值结合，用于生成数组。将伪数组转为真正的数组。数组去重 [...new Set(arr)]。做为函数传递参数时不确定形参个数的时候使用。</li><li>扩展运算符可以提高代码的可读性和简洁性，减少重复代码的编写。</li></ol> 
<h4 id="6%E3%80%81JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%9F%E2%AD%90%E2%AD%90">6、JS变量提升？⭐⭐</h4> 
<p>变量提升是指 JS 的变量和函数声明会在代码编译期，提升到代码的最前面。 变量提升成立的前提是使用 Var 关键字进行声明的变量，并且变量提升的时候只有声明被提升，赋值并不会被提升，同时函数的声明提升会比变量的提升优先。</p> 
<h4 id="7%E3%80%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0Module%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F"><strong>7、怎么实现Module模块化？</strong></h4> 
<ol><li>模块的功能主要由 export(导出) 和 import(导入) 组成。</li><li>每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过 import 来引用其它模块提供的接口。</li><li>同时还为模块创造了命名空间，防止函数的命名冲突。</li></ol> 
<h4 id="8%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0%E5%92%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90"><strong>8、同步和异步的区别？同步函数和异步函数的区别？⭐</strong></h4> 
<ul><li>同步就是同时执行，异步就是分开来执行。</li><li>同步函数就是把同步变成异步执行，异步函数就是把异步变成同步执行。</li><li>场景：同步和异步的问题通常是指 ajax 的回调问题。如果是同步调用，在发起请求的时候就会暂停，等到服务器响应后继续运行。如果是异步调用，发起请求后不会暂停，立即执行后面的代码，服务器响应后会自动触发回调函数进行处理。异步的性能佳，同步则用于需要立即获取结果并实时处理的情况。</li></ul> 
<h4 id="%C2%A09%E3%80%81JS%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><strong>9、JS</strong>的执行顺序？<strong>实现异步的方法</strong>？⭐⭐⭐</h4> 
<blockquote> 
 <p>js 是单线程语言，同一个时间只能做一件事，这样很容易造成阻塞，所以把任务分成了同步任务和异步任务两种。当主线程遇到异步任务，比如说计时器或者 ajax 请求回调问题，就把异步任务放进 "任务队列" 里，执行完同步任务后，再循环的去检查任务队列里面有哪些异步任务要执行。这是一个异步执行，分开来执行的，如果想要变成同步执行，比如说等到计时器执行完后再执行或者等请求服务器响应后再继续运行，可以使用回调函数，或者使用异步函数 promise 或 async await，把异步变成同步执行。所有异步任务都是在同步任务执行结束之后，从任务队列中依次取出执行。</p> 
</blockquote> 
<p>JS<strong>实现异步的方法：</strong></p> 
<ol><li><strong>回调函数：</strong>回调函数是异步操作最基本的方法，优点是简单，容易理解和实现，缺点是不利于代码的阅读和维护，有回调地狱问题 (多个回调函数嵌套的情况)。</li><li><strong>promise：</strong>为了解决回调地狱和代码不规范问题，es6 出了个 promise ，promise 是一个异步函数，是异步编程的一种解决和优化的方案，在异步操作成功时通过状态调用 resolve 或 reject 并把结果作为参数传递出去，通过 then 接收到对应的数据，做出相应的处理。相比回调函数 promise 不仅能捕捉错误，还能解决回调地狱问题，通过多个 promise 调用 then 方法来把地狱回调转化为链式编程。缺点是错误需要通过回调函数捕获，只能异步的处理错误，Promise 链式调用相当于一个新的回调地狱。</li><li><strong>async/await：</strong>async/await 是基于 Promise 实现的，async/await 使异步代码看起来像同步代码。优点是使用方法清晰明了，更加优雅，可读性强，可以以通过 try-catch 捕捉错误，同步的处理错误，且 async/await 完美解决了回调地狱的问题。缺点是 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise 去实现。</li></ol> 
<h4 id="10%E3%80%81%C2%A0promise%E5%92%8Casync%20await%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90%C2%A0">10、 promise和async await区别？⭐⭐⭐ </h4> 
<p><strong>什么是 promise ? 为什么要有 promise ？</strong></p> 
<p>promise 是 es6 中的一个内置对象，实际是一个构造函数，是一个异步函数，是异步编程的一种解决方案，把异步执行变成同步执行。比传统的解决方案 “回调函数” 更加合理强大，解决了 “回调函数” 中的回调地狱，代码不规范，可读性低，不便维护等问题。(通过多个 promise 调用 then 方法来把地狱回调转化为链式编程)</p> 
<p><strong>promise 有什么作用？</strong></p> 
<p> 通常用来解决异步调用问题。解决多层回调嵌套的方案。提高代码可读性，更便于维护。</p> 
<p><strong>promise 写法？如何实现的？</strong></p> 
<p>可以使用 promise 构造函数 new 一个实例，promise 构造函数接收一个函数作为参数，这个函数有两个参数， 分别是成功回调 resolve 和失败回调 reject。在异步操作成功时调用 resolve，把 promise的状态从 pending 转变到 resolved，并将异步操作的结果作为参数传递出去。在异步操作失败时调用 reject，把 Promise 的状态从从 pending 变为 rejected，并将异步操作报出的错误，作为参数传递出去。Promise 实例生成后，当 promise 状态一改变，不管是成功还是失败，就都会来到 promise 对象的 .then 方法，根据其状态，选择特定的响应函数执行。then 方法返回的是一个新的 Promise 实例，因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法，把回调地狱转为链式编程。如果 Promise 的状态变为 reject 时，会被 catch 捕捉到，所以就把成功的处理逻辑写在 .then()里，把失败的处理逻辑写在 .cache() 里。</p> 
<p><strong>什么是 async await ？</strong></p> 
<p>async await 是 ES7 新特性，也是一个异步函数，把异步执行变同步执行，它是基于 promise 实现的，是一个语法糖。</p> 
<p><strong>async await 写法？</strong></p> 
<p>async await 基于 promise 实现的，async 写在方法前面，用于声明一个 function 是异步的，async 和 await 是配对使用的，await 只能写在 async 的内部，await 后面跟着的是一个 promise 对象，async 执行期间一旦遇到 await，会等后面的 Promise（异步）执行完毕再执行后面的代码，如果是 reject 状态，可以使用 try-catch 捕捉</p> 
<p><strong>promise 和 async await 区别：</strong></p> 
<p><strong>相同点：</strong>promise 和 async await 都是优化异步编程的解决方案。</p> 
<p><strong>不同点：</strong></p> 
<ol><li>promise 是 ES6 的一个内置对象，是应用层的解决方案，通过 catch 来捕捉，只能异步的处理错误。async/await 是 ES7 的新特性，是基于 promise 的，可以说是 promise 的补充，是语言层的解决方案，可以让用户像编写同步代码一样编写异步代码，可以通过 try-catch 捕捉错误，同步的处理错误。</li><li>promise 更多应用在函数封装中，async/await 用在函数的使用中。</li><li>链式调用相当于一个新的回调Promise 地狱， 也不能统一处理异常。async/await 完美解决了回调地狱的问题。</li><li>async/await 相对于 promise 来讲，写法更加优雅。async/await 用同步的写法使得可读性更强，同时方便 try-catch 捕获异常。</li></ol> 
<h2 id="%E5%9B%9B%E3%80%81TS%20%E7%AF%87"><span style="color:#1a439c;">四、TS 篇</span></h2> 
<p></p> 
<h2 id="%E4%BA%94%E3%80%81VUE%20%E7%AF%87"><span style="color:#1a439c;">五、VUE 篇</span></h2> 
<h4 id="1%E3%80%81%E5%86%99%E5%87%BAvue%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">1、写出vue的常用指令</h4> 
<blockquote> 
 <p>指令的本质：语法糖。在编译阶段 render 函数里，会把指令编译成 JavaScript 代码</p> 
</blockquote> 
<ul><li>v-for：遍历 data 中的数据，实现列表的渲染（数组或对象）</li><li> <p>v-if：通 过 true 和 false 控制元素是否需要被渲染</p> </li><li> <p>v-else：搭配 v-if 使用，不需要表达式，当 vi-if 为 false 时才被渲染出来 </p> </li><li> <p>v-show：通过 true 和 false 控制元素是否显示或隐藏 </p> </li><li> <p>v-model：实现表单控件和数据的双向绑定（&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;、components）</p> </li><li> <p>v-bind：动态绑定元素属性</p> </li><li> <p>v-on：简写@，事件绑定</p> </li><li> <p>v-text：渲染字符串，会覆盖原先的字符串</p> </li><li> <p>v-html：渲染 Html，{<!-- -->{}} 和 v-text 都是输出文本，v-html 输出 Html （XSS攻击）</p> </li><li> <p>v-once：只渲染元素和组件一次，当数据发生改变时，不会再变化（用于优化更新性能）</p> </li><li> <p>v-slot：定义一个具名插槽或作用域插槽。可缩写为 #</p> </li></ul> 
<h4 id="2%E3%80%81v-if%20%E5%92%8C%20v-show%20%E7%9A%84%E5%8C%BA%E5%88%AB">2、v-if 和 v-show 的区别</h4> 
<p><strong>相同的是：</strong>都是条件渲染指令，通过 true 和 false 控制元素的显示和隐藏。</p> 
<p><strong>不同的是：</strong></p> 
<ol><li> <p>v-if 当条件为 true 时， 把元素创建并渲染到 Html，为 false 时把元素删除，不会渲染到 Html 上。是一个创建和删除的过程，删除时并不会占用空间位置。</p> </li><li> <p>v-shou 无论是 true 还是 false 元素都被渲染出来，当条件为 false 时通过 display: none 控制元素隐藏。是一个显示和隐藏的过程，隐藏时还是会占用空间位置。</p> </li></ol> 
<p><strong>应用场景： </strong></p> 
<ol><li>v-show：适合使用在切换频繁的元素上 （显示/隐藏）</li><li>v-if：适合使用在切换不频繁，且元素内容很多，渲染一次性能消耗很大的元素上</li></ol> 
<h4 id="3%E3%80%81v-if%20%E5%92%8C%20v-for%20%E9%82%A3%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E9%AB%98%C2%A0">3、v-if 和 v-for 那个优先级更高？</h4> 
<ol><li>在 vue2 中 v-for 比 v-if 的优先级更高。这意味着 v-if 将分别重复运行于每个 v-for 循环中，比较消耗性能，所以不建议 v-for 和 v-if 一起使用，可以把 v-if 放在 v-for 的外层或者把需要使用 v-for 遍历的属性先从计算属性中过滤一次。</li><li>在 vue3 中 v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名，会报错。可以把 v-for 放在 v-if 的外层。</li></ol> 
<h4 id="4%E3%80%81v-if%20%E5%92%8C%20v-for%20%E5%8F%AF%E4%BB%A5%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F">4、v-if 和 v-for 可以一起使用吗？</h4> 
<ul><li><strong>Vue2：</strong>可以一起使用，但不建议。在 vue2，v-for 的优先级比 v-if 的高，这意味着 v-if 运行于每一个 v-for 循环中，会造成性能的消耗。<strong><span style="color:#1c7331;">解决办法：</span></strong>可以把 v-if 放在 v-for 的外层或者把需要使用 v-for 遍历的属性先从计算属性中过滤一次。</li><li><strong>Vue3：</strong>不可以一起使用，在 vue3，v-if 的优先级比 v-for 的高，这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名，会报错。<strong><span style="color:#1c7331;">解决办法：</span></strong>可以把 v-for 放在 v-if 的外层。</li></ul> 
<h4 id="4%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B%EF%BC%88v-on%20%E6%8C%87%E4%BB%A4%EF%BC%89%C2%A0">5、常用的事件修饰符有哪一些（v-on 指令）         </h4> 
<ul><li>prevent：阻止事件的默认行为</li><li>stop：阻止冒泡</li><li>self：只监听触发该元素的事件，其他不管（currentTarget 和 target为同一个元素时候触发）</li><li>capture：阻止捕获</li><li>once：事件只触发一次</li><li>left：左键事件</li><li>right：右键事件</li><li>middle：中间滚轮事件</li></ul> 
<h4 id="5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%20DOM">6、什么是虚拟 DOM</h4> 
<ol><li>虚拟 DOM 是一种在内存中构建和操作的 JavaScript 对象树，用来描述真实 DOM 的结构信息，是为了解决浏览器性能问题引入的概念。虚拟 DOM 是相对于浏览器渲染出来的真实 DOM 而言的。</li><li>在传统的前端开发中，当数据发生改变时，我们需要直接操作真实的 DOM 来更新页面，但是这种直接操作会带来性能上的问题。因为改变 DOM 会触发浏览器的重绘和重排，频繁操作消耗了大量的计算资源。而且直接操作 DOM 几乎都要遍历整颗 DOM 树，相比之下查找 js 对象属性变化要比查询 DOM 树开销小。</li><li>虚拟 DOM 的出现解决了这个问题。当数据发生改变的时候，我们首先在内存中创建一个虚拟 DOM 树，然后与之前保存的旧的虚拟 DOM 树进行对比，然后通过 diff 算法找出差异，并只更新差异部分对应的真实 DOM。这样就避免了直接操作真实 DOM，减少了性能的开销。</li><li>虚拟 DOM 的好处是通过 diff 算法只更新需要更新的部分，减少了对真实 DOM 的操作次数，避免频繁的重构和重排，减少了性能的开销，提高了渲染效率。支持跨平台，虚拟 DOM 本质上是一个 JS 对象，而 DOM 与平台强相关。相比之下虚拟 DOM 可以在不同的平台上使用，例如浏览器、移动端和桌面应用等。简化逻辑，虚拟 DOM 提供了一个抽象层，让开发者可以更简洁的操作 DOM，提高了代码的可读性和可维护性，简化了代码逻辑。</li><li>虚拟 DOM 结构：sel 标签，date 标签属性，text 标签的文本，children 嵌套的子标签。</li></ol> 
<h4 id="6%E3%80%81%E8%99%9A%E6%8B%9F%20DOM%20%E6%98%AF%E6%80%8E%E4%B9%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E7%9A%84%C2%A0">7、虚拟 DOM 是怎么更新数据的 </h4> 
<p>虚拟 DOM 可以很好的跟踪当前 DOM 的状态，他会根据当前数据生成一个描述当前 DOM 的虚拟 DOM，然后数据改变的时候又会生成一个新的虚拟 DOM，然后通过 diff 算法计算出前后两个虚拟DOM 之间的差异，得出一个最优的更新方法。</p> 
<h4 id="7%E3%80%81%C2%A0%E8%99%9A%E6%8B%9F%20DOM%20%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E7%9A%84">8、 虚拟 DOM 是怎么生成的</h4> 
<p> 首先代码运行会走生命周期，当生命周期走到 created 到 beforeMount 之间的时候，会编译 template 模板成 render 函数。然后在 beforeMount 和 mounted 之间执行 render 函数。当 render 函数运行时 h 函数会被调用，而 h 函数最主要的就是执行了 vnode 函数，vnode 函数主要作用就是将 h 函数传进来的参数转换成 js 对象，即生成虚拟 DOM。之后当数据发生改变时会重新编译生成一个新虚拟 DOM (vdom)，然后通过 diff 算法计算出前后两个虚拟 DOM 之间的差异，得出一个最优的更新方法。从而减少了不必要的 DOM 操作，提高了页面的渲染速度和性能。</p> 
<h4 id="8%E3%80%81Diff%20%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93">9、Diff 算法总结</h4> 
<ol><li>调用 patch 函数比较两个虚拟 DOM 的根节点是否是相同节点。如果不同直接替换。</li><li>如果相同，则调用 patchVnode 函数比较两个节点的子级，既属性、文本和子节点。此时，要么新增，要么删除，要么替换。只有都存在子节点时，会执行 updateChildren 函数进一步比较他们的子节点。</li><li>子节点在 updateChildren 函数中进行比较更新，首先会分别添加两个指针指向子节点的第一个节点和最后一个节点，然后会进行 头头比较，头尾比较，尾头比较，尾尾比较，如果匹配上，那么会将旧节点对应的真实 DOM 移到新节点的位置上，指针向中间移动，同时匹配的两个节点会继续调用 patchVnode 函数进行进一步的对比。当指向第一个节点的指针大于指向最后一个节点指针的时候表示匹配结束，此时，多余的元素删除，新增的元素新增。如果上面这几种情况都没有出现，key 就起到了关键性作用，存在 key 时，可以直接通过 key 去找到节点的原来的位置。如果没有找到，就新增节点。找到了就移动节点位置，执行 patchVnode 函数进行进一步的对比，指针向后移。这样查找效率非常高。而如果没有 key 呢，那么压根就不会去原来的节点中查找了。而是直接新增这个节点。这就导致这个节点下的所有子节点都会被重新新增。会出现明显的性能耗。所以，合理的使用 key，也是一种性能上的优化。</li><li>总的来说，diff 的过程，就是一个执行 patch 函数，patchVnode 函数，updateChildren 函数……这样的一个循环递归的过程 （patch 只执行一次）</li></ol> 
<h4 id="9%E3%80%81%E7%9C%9F%E5%AE%9E%20DOM%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">10、真实 DOM 的优缺点</h4> 
<p><strong>优点：</strong></p> 
<ol><li>易用</li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li>效率低：解析速度慢，内存占用高。</li><li>性能差：频繁操作真实 DOM，容易导致重绘和回流。</li></ol> 
<h4 id="10%E3%80%81%E8%99%9A%E6%8B%9F%20DOM%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">11、虚拟 DOM 的优缺点</h4> 
<p><strong>优点：</strong></p> 
<ol><li>虚拟 DOM 通过 diff 算法只更新需要更新的部分，减少了对真实 DOM 的操作次数，避免频繁的重构和重排，减少了性能的开销，提高了渲染效率。（重绘和回流）</li><li>支持跨平台，虚拟 DOM 本质上是一个 JS 对象，而 DOM 与平台强相关。相比之下虚拟 DOM 可以在不同的平台上使用，例如浏览器、移动端和桌面应用等。（服务器渲染）</li><li>简化逻辑，虚拟 DOM 提供了一个抽象层，让开发者可以更简洁的操作 DOM，提高了代码的可读性和可维护性，简化了代码逻辑。</li><li>提升用户体验</li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li>额外的内存消耗和性能开销，虚拟 DOM 需要在内存中维护一个额外的数据结构，并且在每次更新时都要进行比较和计算差异，可能会增加一定的内存消耗和性能的开销。</li><li>首次渲染时慢一些，由于虚拟 DOM 需要在内存中构建一颗 DOM 树，然后再将其转为真实的 DOM 树，所以首次渲染的耗时可能比直接操作 DOM 要长一些。</li><li>不适合所有场景，对于静态内容或较少变化的页面，使用虚拟 DOM 可能会带来不必要的开销。</li><li>提高学习成本。无法进行极致优化。</li></ol> 
<h4 id="%C2%A012%E3%80%81v-for%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%20key%EF%BC%9F%E4%B8%8D%E5%8A%A0%20key%20%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"> 12、v-for 为什么加 key？不加 key 会怎么样？</h4> 
<p><span style="color:#ff9900;">什么是就地复用策略？</span></p> 
<p>就地复用策略是 Vue 在 DOM 更新时采用的一种优化方式。在更新现有 DOM 树时，Vue 会尽可能地复用已存在的 DOM 元素，而不是删除并重新插入。这样可以减少不必要的 DOM 操作，提高性能。</p> 
<p>Vue 在执行 DOM 更新时会进行四个步骤：</p> 
<ol><li>创建一个新的虚拟 DOM 树</li><li>对比新旧虚拟 DOM 树，找出差异</li><li>根据差异对现有的 DOM 树进行更新</li><li>触发 DOM 更新后的钩子函数</li></ol> 
<p>在第二步中，Vue 会对比新旧虚拟 DOM 树的节点，找出它们之间的差异。对于相同的节点，在更新时 Vue 会尽可能地复用已存在的 DOM 元素。这样做可以避免不必要的 DOM 操作，提高性能。就地复用策略只适用于同一层级的元素之间进行比较。如果两个元素的父元素不同，Vue 会直接删除旧元素并在新父元素中创建新元素。</p> 
<p><span style="color:#ff9900;">key 是什么？</span></p> 
<p>唯一标识。</p> 
<p><span style="color:#ff9900;">为什么要在 v-for 上加 key？</span></p> 
<p>v-for 中加上 key 是为了提高列表的渲染性能和提供更好的更新策略。</p> 
<p><span style="color:#ff9900;">不加 key 会怎么样？key 有什么用？</span></p> 
<ol><li>性能问题：如果没有 key，vue 在更新列表时会使用一种“就地复用”策略，既复用已经存在的 DOM 元素，而不是删除重新插入。这可能会导致错误的元素被复用，导致渲染错误或者不符合预期的结果。加上 key 可以确保正确地复用和更新元素，提高渲染性能。</li><li>顺序问题：如果顺序发生改变，没有设置 key，Vue 将无法识别新旧节点的对应关系，从而导致重新渲染整个列表，而不仅仅是更新需要修改的部分。加上 key 可以帮助 vue 更好的识别新旧节点对应的关系，只更新变化的部分。</li><li>组件状态问题：如果列表中的组件包含状态，没有设置 key 会导致状态丢失或混乱。加上 key 可以确保组件在重用时保持自己的状态。</li></ol> 
<h4 id="11%E3%80%81v-for%20%E5%86%99%E5%9C%A8%20template%20%E4%B8%8A%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%8A%A0%20key%20%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%C2%A0">13、v-for 写在 template 上，不能加 key 怎么办？ </h4> 
<ol><li>方法一：在 template 里面套上两层 div，v-for 和 key 写在里面的 div 上面。</li><li>方法二：在下一层需要循环遍历的真实 DOM 上加一个 Key 就可以了。</li></ol> 
<h4 id="12%E3%80%81vue2%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">14、vue2 生命周期？⭐⭐⭐</h4> 
<p><span style="color:#ff9900;">什么是钩子函数？什么是生命周期？</span></p> 
<ol><li>vue 生命周期是指 vue 对象从创建到销毁的过程。</li><li>每个生命周期都有对应的函数，我们把这些函数称为钩子函数。生命周期有11个阶段，即有11个构造函数。</li></ol> 
<p><span style="color:#ff9900;"> vue2 的生命周期有哪些？</span></p> 
<ol><li><strong>beforeCreate 创建前：</strong><span style="color:#fe2c24;">在实例初始化之后，数据观测(data observer) 之前被调用。</span>（只有一些默认的生命周期钩子和默认事件，没有 data，没有 el）</li><li><strong>created 创建后：</strong><span style="color:#fe2c24;">在实例创建完成后同步调用。</span>可访问 data、computed、watch、methods 上的方法和数据，未挂载到 DOM，不能访问到 el 属性，常用于简单的 ajax 请求。如果要进行 dom 操作，那就要用 $nextTick 函数。</li><li><strong>beforeMount 挂载前</strong>：<span style="color:#fe2c24;">在挂载开始之前被调用。</span>在 beforeMount 之前已经将 template 模板编译成 render 函数。在 beforeMount 的时候 render 函数首次被调用。（还没有挂载到界面，有data有 el）</li><li><strong>mounted 挂载后：</strong><span style="color:#fe2c24;">实例被挂载后调用，Vue 实例已经初始化完成了。</span>实例挂载到 DOM 上，此时可以通过 DOM API 获取到 DOM 节点，可进行数据请求。（el 被新创建的 vm.$el 替换》？）</li><li><strong>beforeUpdate 更新前：</strong><span style="color:#fe2c24;">在数据发生改变后，DOM 被更新之前被调用。</span>适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器 （此时页面旧数据，data 新数据，还没有同步）</li><li><strong>updated 更新后</strong>：<span style="color:#fe2c24;">在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后调用。</span>组件 DOM 已经更新 （ 此时页面和 data 的数据已经同步，都是最新数据 ）</li><li><strong>beforeDestroy 销毁前：</strong><span style="color:#fe2c24;">实例销毁之前调用。</span>this 仍能获取到实例，常用于销毁定时器、解绑全局事件、销毁插件对象等操作。</li><li><strong>destroyed 销毁后: </strong><span style="color:#fe2c24;">实例销毁之后调用。</span>该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</li><li><strong>activated 激活 ：</strong><span style="color:#fe2c24;">被 keep-alive 缓存的组件激活时调用。</span></li><li><strong>deactivated 取消激活：</strong><span style="color:#fe2c24;">被 keep-alive 缓存的组件失活时调用。</span></li><li><strong>errorCaptured 错误捕捉：</strong><span style="color:#fe2c24;">在捕获错误时被调用。</span>收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传，防止组件无限的渲染循环。</li></ol> 
<blockquote> 
 <p>注意：mounted 和 updated 不会保证所有的子组件都被挂载或重新渲染，如果希望等到整个视图都渲染完毕再执行某些操作，可以在 mounted  或 updated 内部使用 $nextTick 函数。</p> 
</blockquote> 
<p><span style="color:#ff9900;">父子组件生命周期执行顺序？</span></p> 
<ul><li>挂载：父created -&gt; 子created -&gt; 子mounted&gt; 父mounted</li><li>更新：父beforeUpdate -&gt; 子beforeUpdated -&gt; 子updated -&gt; 父亲updated</li><li>销毁：父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</li></ul> 
<p><span style="color:#ff9900;">vue 生命周期的作用是什么? </span></p> 
<p>vue 的生命周期中有多个事件钩子，通过不同阶段对应不同的钩子函数来实现组件数据管理和 DOM渲染两大功能。</p> 
<p><span style="color:#ff9900;">第一次页面加载会触发哪几个钩子?</span></p> 
<p>beforeCreate，created，beforeMount，mounted </p> 
<p><span style="color:#ff9900;">如果加入了 keep-alive 多两个生命周期:</span></p> 
<p>activated，deactiated</p> 
<p><span style="color:#ff9900;">如果加入了 keep-alive ，第一次进入组件会执行那些生命周期？</span></p> 
<p>beforeCreate，created，beforeMount，mounted，activated</p> 
<p><span style="color:#ff9900;">如果加入了 keep-alive，第 n 次进入组件会执行那些生命周期？</span></p> 
<p>只执行 activated</p> 
<p><span style="color:#ff9900;"> 创建后和渲染后有什么区别？</span></p> 
<p>created 是实例创建完成后调用，只能访问 data、computed、watch、methods 上的方法和数据，未挂载 dom，还不能获取 dom 节点，如果要进行 dom 操作，那就要用 $nextTick 函数。常用于简单的 ajax 请求。不能访问到 el 属性。mounted 是实例被挂载后调用，vue 实例已经初始化完成了，已经可以获取 dom节点和操作 dom 节点了。可以访问 el 属性。</p> 
<p><span style="color:#ff9900;">渲染后和更新后有什么区别？</span></p> 
<p>updated 与 mounted 不同的是，在每一次的 DOM 结构更新 vue 都会调用一次 updated() 钩子函数！而 mounted 仅仅只执行一次而已。</p> 
<p><span style="color:#ff9900;">简述每个周期具体适合哪些场景？</span></p> 
<ul><li>beforecreate : 可以在这加个 loading 事件，在加载实例时触发。</li><li>created : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用。</li><li>mounted : 挂载元素，获取到 DOM 节点。</li><li>updated : 如果对数据统一处理，在这里写上相应函数。</li><li>beforeDestroy : 可以做一个确认停止事件的确认框。</li><li>nextTick : 更新数据后立即操作 dom。</li></ul> 
<h4 id="13%E3%80%81vue3%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%C2%A0">15、vue3 生命周期 </h4> 
<p><span style="color:#ff9900;">配置项形式：</span></p> 
<ul><li>vue3 可以继续使用 vue2 中的生命周期钩子，但流程设计上有了一些区别，一些钩子名称发生了变化，也新增了两个钩子。除此之外 Vue3 还可以通过组合式 API 形式去使用生命组件钩子。</li><li><strong>流程设计上的区别：</strong>Vue3 先将 el 挂载了之后再进行的 beforeCreate，而 Vue2 是 created 之后进行判断是否挂载 el，如果没，则流程终止，beforeCreate 和 created 俩个钩子冗余使用，因此 Vue3 进行了优化的。</li><li><strong>钩子名称上的区别：</strong>beforeDestroy 改名为 beforeUnmount，destroyed 改名为 unmounted。</li><li><strong>新增的钩子函数：</strong>renderTracked：跟踪虚拟 DOM 重新渲染时调用。renderTriggered：当虚拟 DOM 重新渲染被触发时调用。</li></ul> 
<p><span style="color:#ff9900;">组合式 API 形式： </span></p> 
<table align="left" border="1" cellpadding="1" cellspacing="1"><thead><tr><th>Vue2生命周期</th><th>Vue3生命周期</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup</td></tr><tr><td>created</td><td>created</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td></tr><tr><td>mounted</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>onUpdated</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount</td></tr><tr><td>destroyed</td><td>onUnmounted</td></tr><tr><td>activated</td><td>onActivated</td></tr><tr><td>deactivated</td><td> <p>onDeactivated</p> </td></tr><tr><td>errorCaptured</td><td>onErrorCaptured</td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h4 id="14%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">16、小程序生命周期</h4> 
<p><span style="color:#ff9900;">全局生命周期：</span></p> 
<ul><li>onLaunch 第一次全局执行</li><li>onShow 第一次执行，或者关闭后重新打开后执行</li><li>onHide 关闭小程序，但是没完全关闭，切换到后台</li><li>onError 小程序报错</li></ul> 
<p><span style="color:#ff9900;">页面生命周期：</span></p> 
<ul><li>onLoad 当前页面第一次加载的时候</li><li>onShow 第一次执行当前页面，或者关闭后重新打开后执行</li><li>onReady 当渲染页（视图层-wxml）加载完毕执行</li><li>onHide 关闭当前页面，但是没完全关闭，切换到后台</li><li>onUnload 销毁当前页</li><li>onPullDownRefresh 下拉刷新</li><li>onReachBottom 页面触底时执行，一般用于做上拉加载</li><li>onShareAppMessage 分享页面执行</li><li>onPageScroll 当前页面滚动执行</li><li>onResize 放大缩小页面的时候执行</li><li>onTabItemTap 点击底部导航栏触发</li></ul> 
<p><span style="color:#ff9900;">组件生命周期：</span></p> 
<ul><li>created 创建组件时执行</li><li>attached 被插入到父组件节点时执行</li><li>ready 渲染完后执行</li><li>moved 移动组件节点</li><li>detached 从父组件节点移除时执行</li><li>error 组件方法抛出错误时执行</li></ul> 
<h4 id="15%E3%80%81vue%20%E9%87%8C%E8%BE%B9%E5%A6%82%E4%BD%95%E8%AE%A9%20css%20%E6%A0%B7%E5%BC%8F%E5%8F%AA%E5%9C%A8%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%94%9F%E6%95%88%3F%C2%A0">17、vue 里边如何让 css 样式只在当前组件中生效? </h4> 
<p>在组件中的 style 前面加上 scoped 就可以了</p> 
<h4 id="16%E3%80%81vue%20%E7%9A%84%20watch%20%E5%92%8C%20computed%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%96%E4%BB%AC%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F">18、vue 的 watch 和 computed 有什么区别？他们的应用场景？</h4> 
<ul><li>computed 是计算属性，可以修改数据，通过 get 获取数据 set 修改数据，而且它是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值，否则就拿上一次已经计算好存在栈里的值。</li><li>watch 是监听属性，可以监听数据 (data 值) 的改变，支持异步，每当监听的数据变化时都会执行回调进行后续操作。有三个属性：handler 事件句柄，immediate 默认监听，deep 深度监听。</li></ul> 
<p><span style="color:#ff9900;">应用场景：</span></p> 
<ul><li><strong>computed 应用场景：</strong>在需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算。</li><li><strong>watch 应用场景：</strong>需要在数据变化时执行异步或开销较大的操作时，应该使用 watch。使用 watch 选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul> 
<h4 id="17%E3%80%81%24nextTick%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%9F">19、$nextTick 是什么？有什么作用？什么时候用？</h4> 
<p><span style="color:#ff9900;">$nextTick 是什么？</span></p> 
<p>事件轮询，把所有的触发事件都放在一个事件栈里 (事件队列)，再根据实际情况先后执行。</p> 
<p><span style="color:#ff9900;">$nextTick 有什么作用？</span></p> 
<ol><li>在 DOM 下一次更新完成后延迟回调。</li><li>Vue 在更新 DOM 时是异步执行的，在修改数据后视图不会立刻更新，而是等同一事件循环中的所有数据修改完成之后，再统一进行视图更新。所以修改完数据，立即在方法中获取 DOM，获取的仍是未修改的 DOM。为了在修改数据后等待 Vue 更新 DOM，可以在数据变化之后立即使用 $nextTick ，这样回调函数将在 DOM 更新完成后被调用，可以获取更新后的 DOM，解决了异步渲染获取不到更新后 DOM 的问题。</li></ol> 
<p><span style="color:#ff9900;">$nextTick 的原理？</span></p> 
<p>$nextTick 本质是返回一个 Promise 对象。</p> 
<p><span style="color:#ff9900;">$nextTick 的应用场景？</span></p> 
<ol><li>在钩子函数 created 里面想要获取操作 Dom，把操作 DOM 的方法放在 $nextTick 中。</li><li>mounted 和 updated 不会保证所有的子组件都被挂载或重新渲染，如果希望等到整个视图都渲染完毕再执行某些操作，可以在 mounted  或 updated 内部使用 $nextTick 函数。</li></ol> 
<h4 id="18%E3%80%81%E5%93%AA%E4%B8%AA%E9%98%B6%E6%AE%B5%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%20DOM%20%E8%8A%82%E7%82%B9%EF%BC%9F%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F">20、哪个阶段无法获取 DOM 节点？怎么处理？</h4> 
<p>可能是因为在 beforeCreated，Created，beforeMount 里获取，可能是获取的节点的祖先节点用 v-if 控制了。将获取节点的操作放在 $nextTick 中，在 DOM 下一次更新完成后延迟回调。</p> 
<h4 id="19%E3%80%81vue%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20refs%20%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E7%9A%84%20dom%20%E5%85%83%E7%B4%A0%E6%8A%A5%20undefined%20%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F">21、vue 中使用 refs 获取组件的 dom 元素报 undefined 如何解决？</h4> 
<ul><li>如果想要真正地在 DOM 加载完成后拿到数据，就需要调用 VUE 的全局api:  $nextTick 延迟到 DOM 下一次更新后执行。( Vue 中的 nextTick 涉及到 Vue 中 DOM 的异步更新 )</li><li> <p>因为在 mounted 阶段可以拿到子组件的实例，但此时数据还没有更新到 DOM 的阶段，要在 updated 阶段才完成了数据更新到 DOM 的阶段 ( 对加载回来的数据进行处理 )</p> </li></ul> 
<h4 id="20%E3%80%81%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%E5%90%8E%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">22、多种数据修改后页面不刷新？怎么解决？⭐⭐⭐</h4> 
<p><strong><span style="color:#ff9900;">为什么修改数据后页面不更新？</span></strong></p> 
<p>由于 vue2 双向数据绑定的核心原理是数据劫持，通过 Object.defineProperty 来劫持对象的 geter 和 seter 属性，当数据发生改变发出通知。而 Object.defineProperty 必须要递归才能劫持深层数据，导致性能严重受影响所以默认不提供递归，即数组对象更新不会触发渲染更新。</p> 
<p><span style="color:#1c7892;"><strong>情况1：vue 无法检测实例被创建时不存在于 data 中的变量</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>原因：</strong></span>由于 Vue 会在初始化实例时对 data 中的数据执行 getter/setter 转化，所以变量必在 data 对象上存在才能让 Vue 将它转换为响应式的。</p> 
<p><span style="color:#1c7331;"><strong>解决方法：</strong></span>把变量放到 data 里面。</p> 
<p><span style="color:#1c7892;"><strong>情况2：vue 无法检测到 data 中对象的动态添加和删除</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>原因：</strong></span></p> 
<p><span style="color:#1c7331;"><strong>解决方法：</strong></span>通过 this.$set 动态添加，通过 Object.assign({},{}) 合并对象并返回新对象。通过 this.$delete 动态移除。</p> 
<p><span style="color:#1c7892;"><strong>情况3：数组的时候，不能添加和删除，不能通过索引直接修改或者赋值，也不能修改数组的长度</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>原因：</strong></span></p> 
<p><span style="color:#1c7331;"><strong>解决方法：</strong></span>通过 this.$set 动态添加，通过 Object.assign({},{}) 合并数组并返回新数组。通过 push、pop、shift、unshift、splice、sort、reverse 等直接改变原数组的方法会触发更新。</p> 
<p><span style="color:#1c7892;"><strong>情况4：异步获取接口数据，DOM 数据不发现变化</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>原因：</strong></span>Vue 在更新 DOM 时是异步执行的。在修改数据后视图不会立刻更新，而是等同一事件循环中的所有数据修改完成之后，再统一进行视图更新。所以修改完数据，立即在方法中获取 DOM，获取的仍是未修改的 DOM。</p> 
<p><span style="color:#1c7331;"><strong>解决方法：</strong></span>可以在数据变化之后立即使用 $nextTick，这样回调函数将在 DOM 更新完成后被调用，可以获取更新后的 DOM，$nextTick 解决了异步渲染获取不到更新后 DOM 的问题。</p> 
<p><span style="color:#1c7892;"><strong>情况5：循环嵌套层级太深，视图不更新</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>原因：</strong></span></p> 
<p><span style="color:#1c7331;"><strong>解决方法：</strong></span>可以让页面强制刷新，this.$forceUpdate (不建议用)</p> 
<p><strong><span style="color:#1c7892;">拓展：路由参数变化时，页面不更新(数据不更新)</span></strong></p> 
<p><span style="color:#fe2c24;"><strong>原因：</strong></span>路由视图组件引用了相同组件时，当路由参会变化时，会导致该组件无法更新，也就是我们常说中的页面无法更新的问题。路由切换时页面只会渲染第一次路由匹配到的参数。</p> 
<p><span style="color:#1c7331;"><strong>解决方法：</strong></span>通过 watch 监听 $route 的变化。给 &lt;router-view&gt; 绑定 key 属性，这样 Vue 就会认为这是不同的&lt;router-view&gt;。<span style="color:#fe2c24;">弊端：跳转到某些路由下没有这个问题，key 属性是多余的</span></p> 
<h4 id="21%E3%80%81Vue.extend%20%E5%92%8C%20Vue.component%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">23、Vue.extend 和 Vue.component 的区别？</h4> 
<p><span style="color:#ff9900;">区别：</span></p> 
<ol><li>vue.extend 的写法步骤更加繁琐一些，要创建构造器，还要 new 一个实例，还要将实例通过 $mount 挂载到特定的元素上。Vue.component 注册组件会自动使用给定的 id 设置组件的名称，然后想在哪里用就在哪里写组件名就可以了。</li><li>vue.extend 只能通过自身初始化结构，使用范围可以挂载在某元素下，可以被 Vue 实例的components 引用，可以被 Vue.component 组件引用。vue.component 可通过自身初始化组件结构，可通过引入 vue.extend 初始化组件结构，可通过第三方模板 temple.html 初始化组件结构，使用范围是任何已被 vue 初始化过的元素内。</li><li>vue.component 是用来注册全局组件的方法，可以在任何地方使用。而 Vue.extend 是用来创建一个 vue 子类的方法 (一个可复用的组件模板)，可以在局部组件中使用。</li><li>Vue.component 注册的组件可以直接在模板中使用。而 Vue.extend 创建的子类需要先进行实例化，然后才能在模板中使用。</li></ol> 
<p><span style="color:#ff9900;">extend 的基础用法： </span></p> 
<p>使用基础 Vue 构造器函数，创建一个子类，参数是一个包含组件选项的对象。然后 new 一个实例并通过 $mount 挂载到特定的元素上，就可以把这个实例 append 到页面 body 里。</p> 
<p><span style="color:#ff9900;">extend 的应用场景：</span></p> 
<p>Vue.extend 属于 Vue 的全局 API，在实际业务开发中我们很少使用，因为相比常用的  Vue.component 写法，使用 extend 步骤要更加繁琐一些。但是在一些独立组件开发场景中，Vue.extend + $mount 这对组合是我们需要去关注的。<strong>比如：</strong>如 alert 弹窗组件，你肯定希望 alert 可以动态插入到 body 中，而不需要在 dom 文档流中放一个莫名其妙的 alert，大部分时间他还是隐藏的。</p> 
<h4 id="22%E3%80%81vue%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9%20vue%20%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F">24、vue 是什么？说一下对 vue 的理解？⭐⭐⭐⭐</h4> 
<blockquote> 
 <p>Vue 是一款渐进式 JavaScript 框架，用于构建用户界面。它采用了 MVVM 的设计模式，通过数据驱动和组件化的开发方式，使得前端开发变得更加简单、高效。</p> 
</blockquote> 
<p><span style="color:#ff9900;">vue 核心概念(优点)：</span></p> 
<ol><li><strong>双向数据绑定：</strong>Vue 框架采用的是 mvvm 模式，相比 MVC 模式，不再局限于数据单向绑定，而是能够实现数据双向绑定、将数据和视图进行实时的同步更新。<strong>实现的原理：</strong>vue2 是通过 （Object.defineProperty 数据劫持）结合（订阅发布模式）实现双向数据绑定的。vue3 是通过 new Proxy 数据代理实现的。实现了当数据发生改变时，视图会自动更新；当用户操作视图时，数据也会相应地进行更新。</li><li><strong>组件化开发：</strong>Vue 鼓励使用组件化开发，将页面拆分成多个独立的组件，每个组件负责特定的功能。组件可以复用、嵌套和组合，提高代码的可维护性和复用性。</li><li><strong>虚拟 DOM：</strong>Vue 采用了虚拟 DOM 技术，通过在内存中构建虚拟 DOM，并与真实 DOM 进行比较，只更新需要更新的部分，减少真实 DOM 操作，提高了渲染性能。</li><li><strong>渐进式：</strong>Vue 是一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性，根据业务需求逐步选择需要的 vue 功能模块。</li><li><strong>生态丰富：</strong>Vue 拥有一个活跃的社区，有大量的第三方插件和工具可以使用。同时，Vue 也提供了官方的路由、状态管理和构建工具等配套库，方便开发者进行项目开发。</li></ol> 
<blockquote> 
 <p>简单来说，Vue 是一款渐进式 JavaScript 框架，综合了 Angular（模块化）和 React（虚拟 DOM）的优点。采用了 MVVM 的设计模式，实现了双向数据绑定。通过数据驱动和组件化的开发方式，使得前端开发变得更加简单、高效。</p> 
</blockquote> 
<h4 id="23%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%90%E8%BF%9B%E5%BC%8F%EF%BC%9F">25、什么是渐进式？⭐⭐⭐</h4> 
<ol><li>技术上的渐进式选型，也就是说你不用一上来就要选 vue 的全家桶，可以根据自己的业务逐步的选择你需要的 vue 功能模块。</li><li>业务模块的渐进式的调用，这就涉及 vue 中的一个重要的概念－组件化，组件在不需要的时候不加载，当业务需要时再加载。</li></ol> 
<h4 id="24%E3%80%81vue%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%3F%20%EF%BC%88%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BC%BA%E9%99%B7%EF%BC%89%E2%AD%90%E2%AD%90%E2%AD%90">26、vue 是如何实现双向数据绑定? （原理与缺陷）⭐⭐⭐</h4> 
<p><span style="color:#ff9900;">什么是数据双向绑定？</span></p> 
<p>Vue 框架采用的是 mvvm 模式，实现了双向数据绑定，当数据发生改变时，立即触发视图的更新。当用户操作视图时，数据也会相应地进行更新。</p> 
<p><span style="color:#ff9900;">vue2 是如何实现双向数据绑定的？</span></p> 
<p><span style="color:#1c7892;"><strong>原理：</strong></span></p> 
<p>vue2 是通过 <span style="color:#fe2c24;"><span style="background-color:#fef2f0;">Object.defineProperty 数据劫持</span></span> 结合 <span style="color:#fe2c24;"><span style="background-color:#fef2f0;">订阅发布模式</span></span> 实现双向数据绑定的。通过 Object.defineProperty 来劫持各个属性的 getter 和 setter，当数据对象的属性被读取或修改时，会触发相应的 getter 和 setter 函数。当数据发生变化时，触发 setter 函数会通知相应的订阅者对象 Dep，然后 Dep 触发相应的监听回调进行更新视图。也就是说数据和视图同步。</p> 
<p><span style="color:#fe2c24;"><strong>缺点：</strong></span></p> 
<ol><li>Object.defineProperty 数据劫持，只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历，如果对象里面还有对象，需要递归。所以性能差。</li><li>Object.defineproperty 只能监听到已有数据是否被修改，不能监听到对象的新增删除属性，需要调用相应的方法更新，如 this.$set 和 this.$delete。由于 Object.defineProperty 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再使用 Object.defineProperty 进行劫持。</li><li>Object.defineproperty 也不能监听到数组的添加删除，而且无法监控到数组下标的变化，导致不能通过索引直接修改或者赋值，也不能修改数组的长度。依然可以 this.$set 和 this.$delete 去更新数据，当然也可以使用数组重写的方法实现了数组的响应，比如使用 push 给数组添加一个数据，不需要调用 this.$set 页面也能够更新响应。( <strong>数组方法：</strong>push 添加、pop 删除、shift 删除、unshift 添加、splice 插入、sort 排序、reverse 反转)</li></ol> 
<p><span style="color:#ff9900;"> vue3 是如何实现双向数据绑定的？</span></p> 
<p><span style="color:#1c7892;"><strong>原理：</strong></span></p> 
<p>Vue3 是通过 Proxy 数据代理来实现的数据双向绑定，Proxy 是 ES6 中新增的一个特性，可以劫持整个对象，并返回一个新对象。实现过程是当一个普通的 javaScript 对象传入 vue 实例的时候，vue 会使用 Proxy 对象包装该对象，并在外界访问和修改对象属性时进行拦截。当属性发生改变的时候，vue 就能捕获到变化并更新相应的视图。ES6 提供 Proxy 构造函数，用来生成 Proxy 实例，接收两个参数 target 和 handler。target 是用 Proxy 包装的被代理对象，可以是任何类型的对象，包括原生数组，函数，甚至是另外一个代理。handler 是一个对象，其声明了代理 target 的一些操作，当任何一个对象属性发生变化时，就会触发 handler 中的 set 方法，从而更新对应的DOM节点。</p> 
<p><strong><span style="color:#1c7331;">优点：</span></strong></p> 
<ol><li>可以劫持整个对象，而非对象属性，并返回一个新的对象。</li><li>代理对象可以劫持对象属性的访问、新增、删除等操作，不需要初始化时遍历所有属性。</li><li>如果有多层属性嵌套，只有在访问到某个属性的时候才会递归处理下一级属性。</li><li>可以监听到数组变化，例如索引。</li><li>不仅可以代理对象，还可以代理数组，还可以代理动态增加的属性</li></ol> 
<p><strong><span style="color:#fe2c24;"> 缺点：</span></strong>存在兼容性问题，IE 无法兼容，vue2 兼容到了 IE8，如果不考虑兼容 IE 浏览器，可以考虑使用 vue3。</p> 
<h4 id="25%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%EF%BC%9F%E2%AD%90%C2%A0">27、什么是订阅发布模式？⭐ </h4> 
<blockquote> 
 <p>订阅发布模式是一种软件设计模式，其原理是基于一个中心的事件调度器 (或者称为消息队列) 组件可以订阅感兴趣的事件，当事件发生时，调度器会通知所有订阅了该事件的组件进行相应的处理。</p> 
</blockquote> 
<p id="%E7%BB%84%E6%88%90%EF%BC%9A"><strong><span style="color:#1c7892;">组成：</span></strong></p> 
<ol><li>发布者：负责发布事件。当某个事件发生时，发布者会将事件发布到调度器中。</li><li>订阅者：订阅感兴趣的事件。订阅者通过向调度器注册自己对某个事件的关注，以便在事件发生时接收通知。</li><li>调度器：负责接收发布者发布的事件，并将事件分发给所有订阅了该事件的订阅者。</li></ol> 
<p><span style="color:#1c7892;"><strong> 原理：</strong></span></p> 
<ul><li>当发布者发布一个事件时，调度器会遍历所有订阅了该事件的订阅者，并将事件传递给它们。订阅者收到事件后，可以执行相应的处理逻辑。这种方式实现了组件之间的解耦，使得发布者和订阅者可以独立地进行开发和演化。</li><li>订阅发布模式的优点是灵活性和可扩展性。通过在调度器中注册和管理订阅关系，我们可以方便地添加新的发布者和订阅者，而不会影响现有的组件。同时，由于订阅者只关注自己感兴趣的事件，可以有效地减少不必要的通信和处理开销。</li><li>总结来说，订阅发布模式通过调度器实现了组件之间的松耦合通信。发布者将事件发布到调度器，而订阅者通过订阅感兴趣的事件来接收通知并执行相应的处理逻辑。这种模式提供了一种灵活、可扩展的组件间通信方式。</li></ul> 
<h4 id="26%E3%80%81vue2%20%E5%92%8C%20vue3%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">28、vue2 和 vue3 有什么区别？⭐⭐⭐</h4> 
<p><span style="color:#1c7892;">1、生命周期发生了改变 </span></p> 
<p><span style="color:#1c7892;">2、Vue2 只支持一个根节点，Vue3 支持多个根节点</span></p> 
<p><span style="color:#1c7892;">3、Vue2 使用的是选项式 api，Vue3 使用的是函数式 api</span></p> 
<ul><li>vue2 使用 optionsApi（选项式 api）</li><li>vue3 使用 CompositionApi（函数式\组合式）代码复用性更强</li></ul> 
<p><span style="color:#1c7892;">4、核心原理不同</span></p> 
<ul><li>vue2 是通过 【Object.defineProperty 数据劫持】结合【订阅发布模式】实现双向数据绑定的。</li><li>vue3 是通过 Proxy 数据代理来实现的数据双向绑定的。</li></ul> 
<p><span style="color:#1c7892;">5、优缺点</span></p> 
<ul><li>vue2 的 【Object.defineProperty 数据劫持】只能劫持对象的某个属性，不能对整个对象进行监听，劫持多个属性需要遍历，如果对象里面还有对象需要递归，性能差。而且只能监听已有对象属性的修改，不能监听到对象的新增删除属性，需要调用相应的方法更新，如 this.$set 和 this.$delete。也不能监听到数组的添加删除，而且无法监控到数组下标的变化，导致不能通过索引直接修改或者赋值，也不能修改数组的长度。 可以通过 this.$set 和 this.$delete 去更新数据，当然也可以使用数组重写的方法实现了数组的响应。</li><li>vue3 的 Proxy 数据代理，代理对象可以劫持对象属性的访问、新增、删除等操作，不需要初始化时遍历所有属性，可以劫持整个对象，而非对象属性。可以监听到数组变化，例如索引。不仅可以代理对象，还可以代理数组，还可以代理动态增加的属性。缺点是存在兼容性问题，IE 无法兼容，如果不考虑兼容 IE 浏览器，可以考虑使用 vue3。</li></ul> 
<p><span style="color:#1c7892;">6、父子传参不同，setup() 函数特性</span></p> 
<p>vue2 是把数据放入 data 中，vue3 就需要使用一个新的 setup() 方法，此方法在组件初始化构造得时候触发。使用一下三个步骤来简=建立反应性数据： 1. 从 vue 引入 reactive。2. 使用 reactive() 方法来声明数据为响应性数据。3. 使用 setup() 方法来返回我们得响应性数据，从而 template 可以获取这些响应性数据。</p> 
<h4 id="27%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20mvvm%3F%20mvc%20%E6%98%AF%E4%BB%80%E4%B9%88%3F%E5%8C%BA%E5%88%AB%3F%E5%8E%9F%E7%90%86%3F">29、什么是 mvvm? mvc 是什么?区别?原理?⭐⭐⭐</h4> 
<p><span style="color:#ff9900;"><strong>MVC（Model-View-Controller）</strong></span></p> 
<p>MVC 是比较直观的架构模式，用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）。MVC 使用非常广泛，比如 JavaEE 中的 SSH 框。</p> 
<p><strong><span style="color:#ff9900;">MVVM（Model-View-ViewModel） （vue \ react \ angular）</span></strong></p> 
<ol><li>m ( module ) 模型，存放数据的地方</li><li>v ( view ) 视图，template 本身，渲染数据的地方</li><li>vm ( view-module ) 视图模型，转换机制 ( vue 本身 )，把 m 层 ( 数据层 ) 上的数据，自动渲染到 v 层 ( 视图层 )</li><li>vm 是如何实现的？通过双向数据绑定的原理，vue2 的底层核心是数据劫持 ( 订阅发布模式 )，在 v ( 视图层 ) 和 m ( 数据层 ) 之间是没有联系的，通过 vm 进行交互，而且 m 和 vm 之间的交互也是双向的，因此视图层的数据改变的时候同时会修改数据源，而数据源数据的变化也会立即反应 view。</li><li>Vue 框架采用的模式是 mvvm 模式，响应式布局，与 MVC 模式相比，不再局限于数据单向绑定，而是能够实现数据双向绑定、同步刷新。m 是 module 模型，存放数据的地方。v 是 view 视图，渲染数据的地方。vm 是 view-module 视图模型，是一个转换机制，把 module 层 上的数据，自动渲染到 view 层。vm 是通过双向数据绑定实现的，vue2 的核心是数据劫持 ( 订阅发布模式 )，vue3 的核心是 new Proxy() 数据代理。实现了视图层的数据改变的时候同时会修改数据源，而数据源数据的变化也会立即反应视图层。</li></ol> 
<h4 id="28%E3%80%81react%20%E5%92%8C%20vue%20%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%A1%86%E6%9E%B6%E7%9A%84%E7%9C%8B%E6%B3%95">30、react 和 vue 有哪些不同，说说你对这两个框架的看法</h4> 
<p><span style="color:#ff9900;">相同点：</span></p> 
<ul><li>都支持服务器端渲染。</li><li>都有 Virtual DOM，组件化开发，通过 props 参数进行父子组件数据的传递，都实现webComponent 规范。</li><li>数据驱动视图。</li><li>都有支持 native 的方案，React 的 React native，Vue 的 weex。</li></ul> 
<p><span style="color:#ff9900;">不同点： </span></p> 
<ul><li>React 严格上只针对 MVC 的 view 层，Vue 则是 MVVM 模式。</li><li>virtual DOM 不一样，vue 会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对于 React 而言，每当应用的状态被改变时，全部组件都会重新渲染，所以 react 中会需要shouldComponentUpdate 这个生命周期函数方法来进行控制。</li><li>组件写法不一样， React 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进JavaScript 了，即 'all in js'。 Vue 推荐的做法是 webpack+vue-loader 的单文件组件格式，即html，css，js 写在同一个文件。</li><li>数据绑定：vue 实现了数据的双向绑定，react数据流动是单向的。</li><li>state 对象在 react 应用中不可变的，需要使用 setState 方法更新状态。在 vue 中，state<br> 对象不是必须的，数据由 data 属性在 vue 对象中管理。</li></ul> 
<h4 id="29%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20vue%20%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%20SSR%EF%BC%9F%E2%AD%90%E2%AD%90">31、说一下 vue 的服务端渲染 SSR？⭐⭐</h4> 
<p><span style="color:#ff9900;"><strong>什么是 服务端渲染 SSR？</strong></span></p> 
<p>服务端渲染 SSR 顾名思义页面上的内容是通过服务端渲染生成的，浏览器直接显示服务端返回的html 就可以了。和它对应的是 CSR，CSR 是客户端在请求时，服务端不做任何处理，直接将前端资源打包后生成的 html 返回给客户端，此时的 html 中无任何网页内容， 需要客户端去加载执行 js 代码才能渲染生成页面内容，同时完成事件绑定，然后客户端再去通过 ajax 请求后端的 API 获取数据更新视图。</p> 
<p><span style="color:#ff9900;"><strong>服务端渲染的优势？</strong></span></p> 
<p>减少网络传输，响应快，用户体验好，首屏渲染快，对搜索引擎友好，搜索引擎爬虫可以看到完整的程序源码，有利于SEO。</p> 
<p><span style="color:#ff9900;"><strong>服务端渲染的缺点？</strong></span></p> 
<ol><li>网络传输数据量大，占用部分服务器运算资源，不容易维护，前端修改部分 html/css 后端也要改用户体验差。</li><li>开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数（lifecycle hook）中使用。一些外部扩展库（external library）可能需要特殊处理，才能在服务器渲染应用程序中运行。</li><li>涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序（SPA）不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</li><li>更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源（CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 （high traffic） 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ol> 
<h4 id="30%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20%E2%80%9C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E2%80%9D%EF%BC%9F%E2%AD%90">32、什么是 “状态管理”？⭐</h4> 
<p>把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，我们的组件树构成了一个巨大的视图，不管在树的哪个位置，任何组件都能获取状态或者触发行为！这就是状态管理模式。简单来说就是把组件的共享状态抽出来，不管任何组件在任何地方都能直接获取这个状态或者触发里面的行为。</p> 
<h4 id="31%E3%80%81vuex%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%E2%AD%90">33、vuex 实现原理？⭐</h4> 
<p>把多个组件需要共享的变量全部储存在一个对象里面，然后将这个对象放在顶层的 Vue 实例中，让其他组件可以使用，并且让这个对象里面的属性做到响应式。</p> 
<h4 id="32%E3%80%81vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">34、vuex是什么？怎么用？优点和缺点？什么时候用？⭐⭐⭐</h4> 
<p><span style="color:#ff9900;"><strong>vuex 是什么？</strong></span></p> 
<p>Vuex 是 vue 框架中状态管理库，是集中管理项目公共数据的。</p> 
<p><strong><span style="color:#ff9900;">vuex 怎么用？</span></strong></p> 
<ol><li>vuex 主要有五大核心属性，分别是 state 数据状态、getter 计算属性、mutation 同步提交、action 异步提交、module 模块化。</li><li>state 属性用来存储公共管理的数据，可以通过 this.$store.state 调用数据。</li><li>getters 属性可以认为是定义 store 的计算属性（过滤数据），就像计算属性一样，getter 的返回值会根据它的依 赖缓存起来，只有当它的依赖值发生改变才会重新计算。通过 this.$store.getters调用属性（获取过滤后的数据）。</li><li>mutation 用来存放更改 state 数据的同步方法，不可以写异步方法，理论上是修改 state 的唯一途径。通过 this.$store.commit(”function”) 来调用 mutation 中的同步方法。</li><li>action 用来存放异步方法，类似于 mutation，不同在于 action 不能直接更改 state 里面的状态，通过 context.commit 提交 mutation，触发 mutation 里面的逻辑方法去修改 state 里面的状态，action 可以包含任意的异步操作。可以通过 this.$store.dispatch('function') 去调用 action 里面的异步方法。</li><li>moudle 属性是将 store 分割成模块。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。</li></ol> 
<p><span style="color:#ff9900;"><strong>vuex 的优点？ </strong></span></p> 
<ol><li>能够在 vuex 中，集中管理共享的数据，易于开发和后期维护。</li><li>js 原生的数据对象写法，比起 localStorage 不需要做转换, 使用方便。</li><li>减少 http 请求，提高浏览器性能。</li><li>多层嵌套的组件、兄弟组件间的状态会更好管理维护，高效的实现组件间的数据共享，提高开发效率。</li><li>vuex 的状态管理是响应式的，如果 state 里面的状态发生变化，相应的组件也会渲染更新，能够实时保持数据与页面的同步。</li></ol> 
<p><span style="color:#ff9900;"><strong>vuex 的缺点？ </strong></span></p> 
<p>刷新浏览器，vuex 中的 state 会重新变为初始状态。</p> 
<p><span style="color:#ff9900;"><strong>什么时候适合使用 Vuex，什么时候不适合使用 Vuex？</strong></span></p> 
<p>项目中，如果不打算开发大型单页应用，使用 vuex 可能是繁琐冗余的。如果项目比较小比较简单，使用 prop 和 $emit 完成父子间的传参，或者订阅发布模式 $eventBus 实现复杂的组件间的通信也是可以满足需求的。vuex 具体应用在哪取决于项目的规模以及具体的业务场景，可能是为了解决多层嵌套组件之间的通信问题，或是为了更好地管理应用中错综复杂的状态关系，而不能为了用 vuex 而在项目中使用 vuex。</p> 
<p><span style="color:#ff9900;"><strong>vuex 的应用场景？</strong></span></p> 
<ol><li>登录状态（token）</li><li>购物车</li><li>权限码</li><li>复杂的组件通信(比如兄弟组件的通信,多层嵌套的组件的传值等等)</li><li>vuex 可配合 sessionStorage 做用户基本信息的持久化存储。</li></ol> 
<h4 id="33%E3%80%81vuex%20%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E5%90%8E%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E2%AD%90%E2%AD%90%E2%AD%90%C2%A0">35、vuex 刷新页面后数据丢失如何解决⭐⭐⭐ </h4> 
<blockquote> 
 <p>项目用 vuex 做全局状态管理，页面刷新后，仓库内的 state 被初始化，所以存的数据也会丢失。</p> 
</blockquote> 
<p>在刷新前把 state 的数据 (通过 localStorage 或者 sessionStorage) 本地存储起来，刷新之后再把存储起来的数据放回 store 的根状态（store.state）。</p> 
<h4 id="34%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F">36、什么是路由懒加载？为什么要路由懒加载？如何实现？</h4> 
<p><strong><span style="color:#ff9900;">什么是路由懒加载？</span></strong></p> 
<p>路由懒加载也叫延迟加载，既在需要的时候加载，随用随载。</p> 
<p><span style="color:#ff9900;"><strong>为什么要路由懒加载？（官方解析）</strong></span></p> 
<ol><li>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。</li><li>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</li></ol> 
<p><span style="color:#ff9900;"><strong>继续解释为什么要路由懒加载： </strong></span></p> 
<p>像 vue 这种单页面应用，如果没有应用懒加载，运用 webpack 打包后的文件将会异常的大。造成进入首页时，需要加载的内容过多，时间过长，会出现长时间的白屏，即使做了 loading 也是不利于用户体验。而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。<strong><strong>也就是说：进入页面不用也不需要一次性加载过多资源造成加载时间过长！</strong></strong></p> 
<p><span style="color:#ff9900;"><strong>路由懒加载如何实现？三种实现方式？</strong></span></p> 
<ol><li>Vue 异步组件 component: resolve=&gt;(require(['../views/About'],resolve))</li><li>ES6 标准语法 import（）---------推荐使用！！！！！ component: () =&gt; import(/* webpackChunkName: "about" */ '../views/About.vue'),</li><li>webpack 的 require，ensure()</li></ol> 
<h4 id="35%E3%80%81%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%20vue-router%20%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%9F%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%80%BC%EF%BC%9F%C2%A0">37、怎么定义 vu<strong>e-router 的动态路由？怎么获取传过来的值？</strong> </h4> 
<ol><li>通过标签 router-link 跳转传参，query 和 param</li><li>通过事件 this.$router.push（{}）跳转传参</li></ol> 
<pre><code class="language-javascript">// query 
&lt;router-link :to="{path:'/跳转的地址b',query:{id:传的参数}}"&gt;跳转到b页面&lt;/router-link&gt;
// param
&lt;router-link :to="{name:'routeB',params:{id:JSON.stringify({name:'小明',gae:18})}}"&gt;跳转到b页面&lt;/router-link&gt;
// $router
this.$router.push({path:"/home",query:{id:1}})

// 区别:
1. query : query 通过 path 引用路由
					 通过 url 传参，刷新还在
					 接收参数: this.$route.query.id
					 query 类似于 get 传参，在浏览器地址栏显示
2. param : params 通过 name 引用路由，name 要在路由内配置
					 刷新消失，需要设置动态路由加冒号 ：绑定动态参数，path："/routeB/:id"
					 接收参数: this.$route.params.id
					 params 类似于 post 传参，不在地址栏显示</code></pre> 
<h4 id="36%E3%80%81vue%20%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%20%EF%BC%88%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%EF%BC%89%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F">38、vue 路由钩子函数 （路由守卫）</h4> 
<ul><li><strong>全局前置守卫：</strong>每一个路由进去之前进行拦截 beforeEach</li><li><strong>全局解析守卫：</strong>同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用</li><li><strong>全局后置守卫：</strong>每一个路由进去之后进行拦截 afterEach</li><li><strong>路由独享守卫：</strong>写在路由，控制具体的某一个路由</li><li><strong>组件守卫：</strong>写在组件</li></ul> 
<h4 id="37%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F">39、小程序路由跳转有哪些方式？</h4> 
<ul><li><strong>navigateTo：</strong>页面跳转（非tab页）</li><li><strong>switchTab：</strong>tab页的跳转</li><li><strong>redirectTo：</strong>页面重定向</li><li><strong>navigateBack：</strong>返回上一页</li></ul> 
<h4 id="38%E3%80%81vue%20%E9%87%8C%E9%9D%A2%20%24route%20%E5%92%8C%20%24router%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">40、vue 里面 $route 和 $router 的区别？</h4> 
<ul><li>$route 是当前路由对象</li><li>$router 是一个全局部的路由对象</li></ul> 
<h4 id="39%E3%80%81%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F%20%E2%AD%90">41、组件开发有什么好处？为什么要封装组件？ ⭐</h4> 
<ol><li>组件可以提升整个项目的开发效率，避免重复的工作量。</li><li>提高复用性。</li><li>能够把页面抽象成多个相对独立的模块，使代码逻辑清晰，方便项目的后期维护。</li><li>便于协同开发，不用把大量精力放在内部的实现上，实现模块化开发。</li></ol> 
<blockquote> 
 <p>提高开发效率、提高复用性、使代码逻辑更加清晰，方便项目的后期维护、便于协同开发 </p> 
</blockquote> 
<h4 id="40%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F">42、什么情况下需要封装组件？</h4> 
<ol><li><strong>解决避免重复的工作量问题：</strong>在项目中多次出现相同特征的模块，该组件未来还有可能出现在其他的地方，且开发这样一个功能模块成本比较高，或者是该组件后续会发生部分特征的改变，且会影响类似特征的模块。</li><li><strong>使代码逻辑更加清晰：</strong>如果每一个模块都写到同一个页面，这样模块的交互功能和处理逻辑很多，造成页面代码量很大，各个模块中也会有相类似的方法，后续代码的可读性不高，功能的维护复杂度提高。</li><li><strong>不用把大量的精力放在内部实现上：</strong>提高团队的协作问题，在一个团队里，每个人擅长部分都不一样的，针对这样的情况，我们可以<span style="color:#4d4d4d;">将其单独进行封装，使使用组件者不用把大量精力放在内部的实现上。</span></li></ol> 
<h4 id="41%E3%80%81%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E6%B5%81%E7%A8%8B%EF%BC%9F%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E7%9A%84%EF%BC%9F%20%E2%AD%90">43、组件封装流程？怎么封装组件的？ ⭐</h4> 
<p>使用 Vue.extend 方法创建一个组件，然后使用 Vue.component 方法注册组件。但是我们一般用脚手架开发项目，每个 .vue 单文件就是一个组件。在另一组件 import 导入，并在 components 中注册。首先建立好自定义模板，准备好组件的数据的输入，子组件定好 props 里面的数据和类型，接收父组件传过来的数据，然后通过 $emit( )暴露输出子组件的数据返回给父组件。</p> 
<p><strong>传统流程：</strong></p> 
<ol><li>创建 Xxx.vue 文件，对组件进行封装</li><li>通过 import 的方式将组件导入 import Xxx from '...'</li><li>对组件进行注册 componments:{ Xxx }</li><li>使用组件：&lt;xxx/&gt;</li></ol> 
<blockquote> 
 <p>views 放页面级的组件、commen 放公共组件、feature 放功能组件</p> 
</blockquote> 
<h4 id="42%E3%80%81vue%20%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%20%E2%AD%90">44、vue 的组件通信有哪些方法 ⭐</h4> 
<p><span style="color:#ff9900;"><strong>父子传参：</strong></span></p> 
<ul><li>父传子：props</li><li>子传父：$emit</li></ul> 
<p><span style="color:#ff9900;"><strong>边界访问 (父子通信)： </strong></span></p> 
<ul><li>访问父组件：$parent</li><li>访问子组件：$children</li><li>访问根实例：$root</li><li>访问子组件实例或子元素：$refs</li></ul> 
<p><span style="color:#ff9900;"><strong>兄弟通信：</strong></span></p> 
<ul><li>通过父组件进行兄弟组件之间通讯</li><li>订阅发布模式：$eventBus （$emit / $on / $off）</li><li>状态管理模式：vuex </li></ul> 
<p><strong><span style="color:#ff9900;">跨级通信： </span></strong></p> 
<ul><li>依赖注入：provide / inject （父传子）</li><li>$attrs / $listeners （inheritAttrs）</li><li>状态管理模式：vuex</li></ul> 
<h4 id="43%E3%80%81%24eventBus%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E9%A1%B5%E9%9D%A2%E4%BC%A0%E6%95%B0%E6%8D%AE%EF%BC%9F">45、$eventBus 如何实现跨页面传数据？</h4> 
<p>在 beforeDestoried(销毁之前) 执行提交事件。</p> 
<h4 id="44%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%E7%9A%84%20data%20%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F">46、为什么组件的 data 必须是一个函数？</h4> 
<ol><li>可以反复的调用</li><li>可以反复创建新对象</li><li>避免组件间的数据冲突</li></ol> 
<h4 id="46%E3%80%81keep-alive%20%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90">47、keep-alive 的作用是什么？⭐</h4> 
<blockquote> 
 <p>&lt;keep-alive&gt;&lt;/keep-alive&gt; 是 vue 内置的一个组件 (是一个抽象组件)</p> 
</blockquote> 
<p><strong><span style="color:#ff9900;">作用：</span></strong></p> 
<p>它自身不会渲染一个 DOM 元素，也不会出现在父组件链中，使用 keep-alive 包裹动态组件时，会缓存不活动的组件实例（组件进行切换的时候，默认会进行销毁，消耗资源）</p> 
<p><span style="color:#ff9900;"><strong>优点：</strong></span></p> 
<p>保留组件状态，避免重新渲染，缓存组件能加快速度，降低消耗资源。</p> 
<p><span style="color:#ff9900;"><strong>用法：</strong></span></p> 
<p>当组件在 &lt;keep-alive&gt; 内被切换的时候，activated (激活) 和 deactivated (取消激活) 这两个生命周期钩子函数将会被对应执行。页面第一次进入的时候，钩子触发的顺序是 created-&gt;mounted-&gt;activated。页面退出的时候会触发 deactivated，当再次前进或者后退的时候只触发 activated。当 keep-alive 组件激活时，触发 activated。keep-alive 组件停用时调用 deactivated。</p> 
<h2 id="%E5%85%AD%E3%80%81uni-app%20%E7%AF%87"><span style="color:#1a439c;">六、uni-app 篇</span></h2> 
<h4 id="1%E3%80%81uniapp%20APP%20%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%20%EF%BC%88%E5%AE%89%E5%8D%93%20Android%EF%BC%89%E2%AD%90">1、uniapp 打包过程（安卓 Android）⭐</h4> 
<ol><li>如果是使用私有证书，打包前得生成安卓的 .keystore 证书文件。</li><li>打开 manifest.json 配置文件进行配置： 基础配置 (AppID、应用名称、应用描述、应用版本号、vue 版本号)、App 图标配置 (不配置默认是 uni-app 图标)、App 启动界面配置 (不配置启动时是 uni-app 默认图)、APP 模块配置、APP 权限配置等。</li><li>配置好后，点击 HbuilderX 的发行，选择原生APP-云打包，勾选 Android 选项，填写 Android 包名，勾选私有证书 (也可以选择使用 DCloud 公有证书)，填写证书别名 alias，证书私钥密码 (自己设置的)，上传证书文件 (生成 keystore 文件的地址)，取消广告联盟中的所有广告 (个人选择)，点击打包。</li><li>打包成功后 HbuilderX 控制台会自动返回 APP 下载地址，然后可以对该链接在电脑中进行下载，也可以将该链接复制到手机浏览器，在手机中对该软件进行下载。</li></ol> 
<p><strong>详细步骤：</strong><a href="https://www.notion.so/uni-app-APP-Android-86294fe86c2a4f68aa6d2492ed04af3a?pvs=4" rel="nofollow" title="uni-app Android 打包详细步骤">uni-app Android 打包详细步骤</a></p> 
<h4 id="2%E3%80%81uniapp%20APP%20%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%20%EF%BC%88%E8%8B%B9%E6%9E%9C%20ISO%EF%BC%89%E2%AD%90">2、uniapp 打包过程（苹果 ISO）⭐</h4> 
<ol><li> ISO 系统打包需要有苹果开发者账号，新建一个 APPid，设置 Bundle ID，申请 IOS 发布证书并保存证书私钥密码，申请 IOS 发布描述文件。</li><li> 打开 hbuilderx 点击发行-原生 APP 云打包，勾选 ISO 选项，填写 Bundle ID 和证书私钥密码，上传描述文件和发布证书，点击打包。</li><li> 等待控制后台返回下载链接，点击链接进行下载 IPA 文件。</li><li> 在 iTunes connect 上创建 APP，上传 IPA 到 APP store，设置 app 信息提交到商店进行审核</li></ol> 
<p><strong>详细步骤：</strong> <a href="https://www.notion.so/uni-app-ISO-8201ddc10801424f9b6549b3805514e6?pvs=4" rel="nofollow" title="uni-app ISO 打包详细步骤">uni-app ISO 打包详细步骤</a></p> 
<h4 id="3%E3%80%81uniapp%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%20%E2%AD%90"><strong>3、uniapp 小程序打包过程 ⭐</strong></h4> 
<ol><li>进入微信公众平台注册微信小程序获取 AppID</li><li>打开 manifest.json 配置文件，点击微信小程序配置，填写 AppID 和相关配置</li><li>点击 HbuilderX 的发行，选择小程序微信，填写小程序名称和 AppID 点击发布</li><li>HbuilderX 自动调开微信开发者工具，点击右上角上传按钮，填写版本号和备注，点击上传</li><li>登录微信公众平台，选择版本管理，点击提交审核</li></ol> 
<p><strong>详细步骤：</strong> <a href="https://www.notion.so/uni-app-8eabfe6a13b64d0dbfadcaaef85a294f?pvs=4" rel="nofollow" title="uniapp 小程序打包详细步骤">uniapp 小程序打包详细步骤</a></p> 
<h4 id="4%E3%80%81uniapp%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%9F"><strong>4、uniapp 的基本配置？</strong></h4> 
<ul><li>page.json：uni-app 全局配置，配置页面的文件路径、窗口样式、原生的导航栏、底部 tabbar</li><li>App.vue：页面入口文件（主组件）</li><li>main.js：项目入口文件</li><li>pages：页面管理部分</li><li>manifest.json：配置文件，配置应用名称，appid，logo，版本等打包信息</li><li>unpackage：打包目录</li><li>static：静态资源目录</li><li>components：uni-app 组件目录 (符合 vue 规范)</li><li>wxcomponents：存放小程序组件目录</li><li>uni.scss：全局样式</li><li>uni_modles：存放插件</li></ul> 
<h4 id="5%E3%80%81uniapp%20%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%20api%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%20%E6%A0%BC%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><strong>5、uniapp 上传文件时用到的 api 是什么？ 格式是什么？</strong></h4> 
<p><strong>api：</strong>uni.uploadFile。</p> 
<p><strong>格式：</strong>上传的地址 url，上传类型 fileType，图片路径 filePath，文件对应的key name，成功的回调</p> 
<pre><code class="language-javascript">uni.uploadFile({
    url: '要上传的地址',
    fileType:'image',
    filePath:'图片路径',
    name:'文件对应的key',
    success: function(res){
	    console.log(res)
    }
})</code></pre> 
<h4 id="6%E3%80%81uniapp%20%E8%8E%B7%E5%8F%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E7%9A%84API%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><strong>6、uniapp 获取地理位置的API 是什么？</strong></h4> 
<p>uni.getLocation</p> 
<h4 id="7%E3%80%81rpx%E3%80%81px%E3%80%81em%E3%80%81rem%E3%80%81%25%E3%80%81vh%E3%80%81vw%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90">7、rpx、px、em、rem、%、vh、vw 的区别是什么？⭐</h4> 
<ul><li>rpx：相当于把屏幕宽度分为750份，1份就是1rpx。</li><li>px：绝对单位，页面按精确像素展示。</li><li>em：相对单位，相对于它的父节点字体进行计算。</li><li>rem：相对单位，相对根节点html的字体大小来计算。</li><li>%：一般来说就是相对于父元素。</li><li>vh：视窗高度，1vh等于视窗高度的1%。</li><li>vw：视窗宽度，1vw等于视窗宽度的1%。</li></ul> 
<h4 id="8%E3%80%81uniapp%20%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%EF%BC%9F">8、uniapp 如何监听页面滚动？</h4> 
<p>使用 onPageScroll 监听</p> 
<h4 id="9%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E5%9B%BE%E7%89%87%E5%AE%BD%E5%BA%A6%E4%B8%8D%E5%8F%98%EF%BC%8C%E9%AB%98%E5%BA%A6%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%EF%BC%8C%E4%BF%9D%E6%8C%81%E5%8E%9F%E5%9B%BE%E5%AE%BD%E9%AB%98%E6%AF%94%E4%B8%8D%E5%8F%98%EF%BC%9F">9、如何让图片宽度不变，高度自动变化，保持原图宽高比不变？</h4> 
<p>给 image 标签添加 mode=‘widthFix’</p> 
<h4 id="10%E3%80%81uni-app%20%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F">10、uni-app 的优缺点？</h4> 
<p>优点：</p> 
<ol><li>一套代码可以生成多端。</li><li>学习成本低，语法是vue的，组件是小程序的。</li><li>拓展能力强。</li><li>使用HBuilderX开发，支持vue语法。</li><li>突破了系统对H5条用原生能力的限制。</li></ol> 
<p>缺点： </p> 
<ol><li>问世时间短，很多地方不完善。</li><li>社区不大。</li><li>官方对问题的反馈不及时。</li><li>在Android平台上比微信小程序和iOS差。</li><li>文件命名受限。</li></ol> 
<h4 id="11%E3%80%81%E5%88%86%E5%88%AB%E5%86%99%E5%87%BA%20jQuery%E3%80%81vue%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%81uni-app%20%E4%B8%AD%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%C2%A0">11、分别写出 jQuery、vue、小程序、uni-app 中的本地存储 </h4> 
<p><strong>jQuery：</strong></p> 
<ul><li>存：cookie(’key’，’value’)</li><li>取：cookei(’key’)</li></ul> 
<p><strong>vue：</strong></p> 
<ul><li>存：localstorage.setItem（‘key’，‘value’）</li><li>取：localstorage.getItem（‘key’）</li></ul> 
<p><strong>微信小程序：</strong></p> 
<ul><li>存：wx.setStorage/wx.setStorageSync</li><li>取：wx.getStorage/wx.getStorageSync</li></ul> 
<p><strong>uni-app：</strong></p> 
<ul><li>存：uni.setStorage({key:“属性名”，data:“值”})</li><li>取：uni.getStorage({key:“属性名”,success(e){e.data//这就是你想要取的token}})</li></ul> 
<h4 id="12%E3%80%81jq%E3%80%81vue%E3%80%81uni-app%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%3F%20%E2%AD%90">12、JQ、VUE、uni-app、小程序的页面传参方式? ⭐</h4> 
<p>JQ传参：通过url拼接参数进行传参。</p> 
<p>VUE传参：</p> 
<ol><li>可以通过标签 router-link 跳转传参，通过 path+ 路径，query+ 参数。</li><li>可以通过事件里的 this.$router.push 跳转传参。</li></ol> 
<p>uni-app，小程序传参 ：通过跳转路径后面拼接参数来进行跳转传参。</p> 
<h4 id="13%E3%80%81vue%20%2C%20%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%2C%20uni-app%20%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7%E5%8C%BA%E5%88%AB%EF%BC%9F">13、vue、微信小程序、uni-app 绑定变量属性区别？</h4> 
<p>vue 和 uni-app 动态绑定一个变量的值为元素的某个属性的时候，会在属性前面加上冒号 ":"。小程序绑定某个变量的值为元素属性时，会用两个大括号 {<!-- -->{}} 括起来，如果不加括号，为被认为是字符串。</p> 
<h4 id="14%E3%80%81uni-app%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%C2%A0">14、uni-app 的生命周期？ </h4> 
<blockquote> 
 <p>uniapp 生命周期是以小程序生命周期为基础实现的，分为应用生命周期、页面生命周期、组件生命周期。 其中组件生命周期就是 vue 生命周期。</p> 
</blockquote> 
<p><span style="color:#ff9900;">应用生命周期：</span></p> 
<ul><li><strong>onLaunch：</strong>当 uniapp 初始化完成时调用 (只触发一次)。</li><li><strong>onShow：</strong>当 uniapp 启动或从后台进入前台时发生调用 （监听用户进入小程序）。</li><li><strong>onHide：</strong>当 uniapp 从前台进入后台时发生调用 （监听用户离开小程序）。</li><li><strong>onError：</strong>当 uniapp 报错时被触发。</li><li><strong>onUniNViewMessage: </strong>对 nvue 页面的数据进行监听。</li><li><strong>onUnhandledRejection：</strong>对未处理的 Promise 拒绝事件进行监听。</li><li><strong>onPageNotFound：</strong>页面不存在监听函数。</li><li><strong>onThemeChange：</strong>监听系统主题的变化。</li></ul> 
<p><span style="color:#ff9900;">页面生命周期： </span></p> 
<ul><li><strong><code>onLoad</code>: </strong>监听页面加载。</li><li><strong><code>onShow</code>：</strong>监听页面显示 (每次页面显示都触发)。</li><li><strong><code>onReady</code>: </strong>监听页面初次渲染完成。</li><li><strong><code>onHide</code>: </strong>监听页面隐藏。</li><li><strong><code>onUnload</code>:</strong> 监听页面卸载。</li><li><strong><code>onResize</code>: </strong>监听窗口尺寸的变化。</li><li><strong><code>onPullDownRefresh</code>: </strong>监听用户下拉动作。</li><li><strong><code>onReachBottom</code>: </strong>监听页面上拉触底事件。</li><li><strong><code>onTabItemTab</code>: </strong>点击 TabBar 时触发。</li><li><strong><code>onShareAppMessage</code>: </strong>点击右上角分析时触发。</li><li><strong><code>onShareTimeline</code>: </strong>点击右上角转发到朋友圈时触发。</li><li><strong><code>onAddToFavorites</code>: </strong>点击右上角收藏时触发。</li><li><strong><code>onPageScroll</code>: </strong>监听页面滚动。</li><li><strong><code>onNavigationBarButtonTap</code>:</strong> 监听标题栏按钮点击事件。</li><li><strong><code>onNavigationBarSearchInputChanged</code>: </strong>监听标题栏搜索输入框输入内容变化事件。</li><li><strong><code>onNavigationBarSearchInputClicked</code>:</strong> 监听标题栏搜索输入框点击事件。</li><li><strong><code>onBackPress</code>: </strong>监听用户点击右上角收藏。</li></ul> 
<p><span style="color:#ff9900;">组件生命周期： </span></p> 
<p>uniapp 的组件生命周期和 Vue 标准组件生命周期相同。在当前版本的 uniapp中，你既可以选择使用 vue2 进行开发，也可以使用 vue3 进行开发，可以参考 vue2 和 vue3 的生命周期。</p> 
<h4 id="15%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">15、小程序组件传参有哪些方式</h4> 
<p>全局数据、Storage存储、eventBus。</p> 
<h2 id="%E4%B8%83%E3%80%81HTTP%20%E8%AF%B7%E6%B1%82%E7%AF%87"><span style="color:#1a439c;">七、HTTP 请求篇</span></h2> 
<h4 id="1%E3%80%81%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F">1、浏览器输入url后都经历了什么？⭐⭐⭐</h4> 
<ol><li>查看缓存(浏览器缓存\系统缓存\路由器缓存)，如果缓存中有则直接显示页面内容。</li><li>域名解析（DNS解析）获取相应的 IP 地址。</li><li>浏览器向服务器发起 TCP 连接，建立 TCP 三次握手。</li><li>浏览器向服务器发起 HTTP 请求，请求数据包。</li><li>服务器处理请求，返回响应数据至浏览器。</li><li>关闭 TCP 连接（四次挥手）。</li><li>浏览器解析 HTML 代码并请求资源（js、css、图片等）。</li><li>浏览器进行页面布局渲染。</li></ol> 
<h4>2、浏览器地址栏的完整URL都包含哪些内容都各代表什么？</h4> 
<blockquote> 
 <p><strong>例如：</strong>http://www.baidu.com/index.html?name=mo&amp;age=25#dowell</p> 
</blockquote> 
<p> 这个URL 包括：协议部分、域名、端口、路径(虚拟路径)、携带的参数、哈希值。</p> 
<ul><li><strong>协议部分：</strong>http，https。（传输协议是用来完成客户端和服务器端之间数据传输的）</li><li><strong>域名：</strong>www.baidu.com。baidu.com 为一级域名，www 为服务器。（用于解析对应的IP地址，也可以使用IP地址作为域名使用）</li><li><strong>端口：</strong> http：默认端口号 80。https：默认端口号 443。ftp：默认端口号 21。(一般都是隐藏)</li><li><strong>路径（虚拟路径）：</strong>index.html 虚拟目录。</li><li><strong>携带的参数：</strong>？后面拼接携带的参数， 多个参数用 &amp; 连接。（可有可无）</li><li><strong>哈希值：</strong>#dowell。可做页面中的锚点定位。（可有可无）</li></ul> 
<h4 id="2%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%20HashRouter%20%E5%92%8C%20HistoryRouter%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">2、HashRouter 和 HistoryRouter 的区别？⭐⭐⭐</h4> 
<p><strong>实现原理：</strong></p> 
<ul><li><strong>hash：</strong>hash是通过监听hashChange事件来实现前端路由。hash通过window.onhashchange 方法获取新 URL 中 hash 值，如果 hash 值有变化就会自动调用 hashChange 的监听事件，在这个回调事件中，相应的执行无刷新页面跳转。</li><li><strong>history：</strong>history 是利用浏览历史记录栈的 API 来实现前端路由。history 通过 pushState 和 replaceState 方法更新浏览器 URL 地址而不重新发起请求(替换URL页面跳转且不刷新页面)，并且将地址记录到历史记录中。通过 onpopstate 监听浏览器的前进和后退。<span style="color:#fe2c24;">注意：URL发生了变化，但是不会立即向后端服务器发送请求，但是如果点击刷新，就会重新向后端服务器发送请求</span></li></ul> 
<p><strong>区别： </strong></p> 
<ol><li>hash 模式的 url 中有 # 号，不太优雅。history 模式的 url 中没有 # 号，更美观。</li><li>hash 模式不需要在服务器层面上处理，但不利于 SEO。history 模式依赖 H5 API 和后台配置，没有后台配置的话，页面刷新时会出现 404，需要和后端人员配合配置一下 url 重定向，如果 URL 匹配不到任何静态资源，则重定向到首页路由。由于依赖 H5 所以 history 有浏览器兼容问题。</li><li>hash 模式 url 发生变化时，变化的是 url 的#号后面的 hash 值，hash 虽然包含在 url 中，但是没有被包含在 http 请求中，对后端没影响，所以不会向后端发送请求，所以 hash 改变也不会重新加载页面。history 模式的 URL 改变会向服务器发出请求，同时也会在浏览器历史记录中添加一条记录，可能会重新加载页面。</li><li>相同的 url，history 会触发添加到浏览器历史记录栈中，hash 不会触发。</li><li>因为 vue 是一个单页面应用，所以默认只有 hash 模式，没有 history 模式，需要手动设置。使用 history 模式，需要适当的服务器配置，将页面请求全部重定向到 index.html。</li></ol> 
<h4 id="3%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%20cookie%20sessionStorage%20localStorage%20%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">3、cookie、sessionStorage、localStorage的区别？⭐⭐⭐</h4> 
<p><strong>共同点：</strong>都是存储在浏览器本地的、相对不安全。</p> 
<p><strong>不同点：</strong></p> 
<ol><li><strong>写入方式：</strong>cookie 是由服务端写入的，需要服务器支持。而 localStorage 和 sessionStorage 都是由前端写入的。</li><li><strong>生命周期：</strong>如果没有设置过期时间，cookie 默认关闭浏览器立即消失。而 localStorage 默认是永久储存，除非手动清除。sessionStorage 是页面关闭的时候就会自动清除。</li><li><strong>存储大小：</strong>cookie 的存储大小大概4kb，存储条数为 20 条，超过20条后面的数据会替代前面的数据。localStorage 和 sessionStorage 存储大小大概5M，存储条数不限制。</li><li><strong>兼容性：</strong>cookie 可以兼容低版本浏览器。localStroage 和 sessionStorage 是 H5 新特性，无法兼容 ie8 及以下的浏览器。</li><li><strong>多Tab：</strong>LocalStorage 可以在多个 Tab(窗口) 打开，SessionStorage 限制必须在同一个页面，多 tab(窗口) 的时候不可以共享数据。</li><li><strong>应用场景：</strong>前端向后端发起请求时会自动携带 cookie 里面的数据，但是 SessionStorage 和 localStorage 不会，所以他们的应用场景也不同。Cookie 一般用于存储登录验证信息 SessionID 或者 token。localStorage 常用于存储不易变动的数据，减轻服务器的压力。SessionStorage 可以用来检测用户是否刷新进入页面，如音乐播放器恢复播放进度条的功能。</li></ol> 
<h4 id="4%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%BF%87%E6%9C%9F%E7%9A%84%20localstorage%20%E6%95%B0%E6%8D%AE%EF%BC%9F">4、如何实现可过期的 localstorage 数据？</h4> 
<ol><li>localStorage 只能用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。所以要实现可过期的 localStorage 缓存的中重点就是：如何清理过期的缓存。 目前有两种方法，一种是惰性删除，另一种是定时删除。</li><li><strong>惰性删除：</strong>指某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。实现方法是，存储的数据类型是个对象，该对象有两个key，一个是要存储的 value 值，另一个是当前时间。获取数据的时候，拿到存储的时间和当前时间做对比，如果超过过期时间就清除 Cookie。</li><li><strong>定时删除：</strong>每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对 CPU 的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage 空间的浪费。实现过程，获取所有设置过期时间的 key 判断是否过期，过期就存储到数组中，遍历数组，每隔1S（固定时间）删除5个（固定个数），直到把数组中的 key从 localstorage 中全部删除。</li></ol> 
<h4>5、请求行、请求头、请求体、响应行、响应头、响应体？</h4> 
<p><span style="color:#ff9900;"><strong>请求行 </strong></span></p> 
<ul><li>Request URL：请求地址。</li><li>Request Method：请求方法。</li><li>Status Code：状态码。</li><li>Remote Address：请求的远程地址。</li><li>Referrer Policy：策略。</li></ul> 
<p><span style="color:#ff9900;"><strong>请求头 </strong></span></p> 
<ul><li>Accept：指定客户端接收的内容类型。</li><li>Accept-Charset：浏览器可以接受的字符编码。</li><li>Accept-Encoding：指定浏览器支持的压缩格式。</li><li>Accept-Language：浏览器可接受的语言。</li><li>Cache-Control：指定请求和响应遵循的缓存机制。</li><li>Connection ： 表示是否需要持久连接。(HTTP 1.1默认进行持久连接)</li><li>Cookie：客户端暂存的服务端的信息。</li><li>Content-Length：请求的内容长度。</li><li>Content-Type：请求的与实体对应的MIME信息。</li><li>Date：请求发送的日期和时间。</li><li>From：发出请求的用户的Email。</li><li>User-Agent：客户端信息。</li><li>Host：指定请求的服务器的域名和端口号。</li><li>Origin：指定当前请求资源所在页面的协议和域名，用来说明请求从哪里发起的。</li><li>Referer：告诉服务器，是从哪个资源(url)来访问服务器的。</li><li>Authorization：HTTP授权的授权证书。</li></ul> 
<p><span style="color:#ff9900;"><strong>请求体 </strong></span></p> 
<ul><li>一般用来存储 post 的参数和参数数据。常见请求体的格式有纯文本、JSON、XML等。</li></ul> 
<p><span style="color:#4da8ee;"><strong>响应行 </strong></span></p> 
<ul><li>报文协议及版本。</li><li>Status Code：状态码及状态描述。</li></ul> 
<p><span style="color:#4da8ee;"><strong>响应头</strong></span></p> 
<ul><li>Allow：服务器支持哪些请求方法 (GET、POST等)。</li><li>Cache-Control：告诉所有的缓存机制是否可以缓存及哪种类型。</li><li>Connection：表示是否需要持久连接。(HTTP 1.1默认进行持久连接)</li><li>Content-Encoding：响应资源所使用的压缩编码类型。</li><li>Content-Length：响应体的长度。 </li><li>Content-Type：返回内容的MIME类型。</li><li>Date：原始服务器消息发出的时间。</li><li>Expires：响应过期的日期和时间。</li><li>Server：服务器的名称。</li><li>Set-Cookie：设置Http Cookie。</li><li>Last-Modified：请求资源的最后修改时间。</li><li>Access-Control-Allow-Origin：指定哪些网站可以跨域资源共享。</li><li>ETag：请求变量的实体标签的当前值。</li><li>Location：页面重定向<strong>redirect</strong>的时候，设置Location的属性值（地址）跳转到该地址。</li></ul> 
<p><span style="color:#4da8ee;"><strong>响应体 </strong></span></p> 
<ul><li>服务器返回给客户端的文本信息。</li></ul> 
<h4>6、 get 和 post 的区别？ </h4> 
<ol><li>get 参数写在 url 上，即 HTTP 协议头上。post 参数放在 HTTP 的请求体内。get 以 ? 分割url 和传输数据，参数之间以 &amp; 相连。</li><li> <p>get 提交的数据最大是2k，post 理论上没有限制。其中，get 发送的数据在原则上 url 长度无限制，实际上取决于浏览器，浏览器会限制 url 的长度。</p> </li><li> <p>get 在浏览器回退时不产生影响，post 会再次提交请求。(get请求中的回退操作实际上浏览器会从之前的缓存中拿结果)</p> </li><li> <p>get 请求参数会被完整保留在浏览器历史记录里，而 post 中的参数不会被保留。</p> </li><li> <p>get 请求只能进行 url 编码，post 支持多种编码方式。</p> </li><li> <p>get 比 post 更不安全，因为参数直接暴露在 url 上，所以不能用来传递敏感信息。</p> </li><li> <p>get 产生一个 TCP 数据包，浏览器会把 http header 和 data 一并发送出去，服务器响应200(返回数据)。post 产生两个 TCP 数据包，浏览器先发送 header，服务器响应100 continue，浏览器再发送 data，服务器响应 200 ok(返回数据)。<span style="color:#a5a5a5;">【在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。并不是所有浏览器都会在 POST 中发送两次包，Firefox就只发送一次】</span></p> </li></ol> 
<h4 id="16%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F">8、常见的HTTP状态码？</h4> 
<p><strong>1开头（收到请求，正在处理）</strong></p> 
<p><strong>2开头（请求成功）</strong></p> 
<p>200   （成功）  201   （已创建）  202   （已接受） 203   （非授权信息）</p> 
<p>204   （无内容）  205   （重置内容） 206   （部分内容）</p> 
<p><strong>3开头 （请求被重定向）</strong></p> 
<p>300   （多种选择）  301   （永久移动）  302   （临时重定向）  303   （查看其他位置）</p> 
<p>304   （未修改） 305   （使用代理） 307   （临时重定向）</p> 
<p><strong>4开头 （请求错误）</strong></p> 
<p>400（错误请求） 401（未授权） 403（禁止） 404（未找到） 405（方法禁用）</p> 
<p>406（不接受） 407（需要代理授权） 408（请求超时）  409（冲突）  410（已删除）</p> 
<p>411（需要有效长度） 412（未满足前提条件） 413 （请求实体过大）</p> 
<p>414（请求的 URI 过长） 415 （不支持的媒体类型） 416 （请求范围不符合要求）</p> 
<p>417（未满足期望值）</p> 
<p><strong>5开头（服务器错误）</strong></p> 
<p>500   （服务器内部错误）  501   （尚未实施） 502   （错误网关）</p> 
<p>503   （服务不可用） 504   （网关超时） 505 （HTTP 版本不受支持）</p> 
<h4 id="6%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8Btoken%20%E8%83%BD%E6%94%BE%E5%9C%A8cookie%E4%B8%AD%E5%90%97%EF%BC%9F">6、Token 能放在 cookie 中吗？</h4> 
<p>token 一般是用来判断用户是否登录的，它内部包含的信息有 uid(用户唯一的身份标识)、time(当前时间戳)、sign(签名)。token 可以存放在 Cookie 中，token 是否过期，应该由后端来判断，不该前端来判断，所以 token 存储在 cookie 中只要不设置 cookie 的过期时间就可以了，如果 token 失效，就让后端在接口中返回固定的状态表示 token 失效，需要重新登录，再重新登录的时候，重新设置 cookie 中的 token 就行。</p> 
<h4 id="7%E3%80%81Token%C2%A0%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%EF%BC%9F">7、Token 认证流程？</h4> 
<ol><li>客户端使用用户名跟密码请求登录。</li><li>服务端收到请求，去验证用户名与密码。</li><li>验证成功后，服务端签发一个 token ，并把它发送给客户端。</li><li>客户端接收 token 以后会把它存储起来，比如放在 cookie 里或者 localStorage 里。</li><li>客户端每次发送请求时都需要带着服务端签发的 token (把 token 放到 HTTP 的 Header 里)</li><li>服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据。</li></ol> 
<h4 id="7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F%E2%AD%90%E2%AD%90">8、什么是同源策略？为什么要有同源策略？⭐⭐</h4> 
<ul><li><strong>同源策略：</strong>域名、协议、端口号都相同才能互相访问。</li><li><strong>目的：</strong>防止黑客攻击，xss、csrf 攻击 （ 导致了前后端无法访问 ，也就是跨域问题）</li></ul> 
<h4 id="8%E3%80%81XSS%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">9、XSS攻击是什么？</h4> 
<ul><li>XSS是跨站脚本攻击、向目标网站插入恶意代码、大量用户访问网站时运行恶意脚本获取信息</li><li><strong>原理：</strong>通过向 Web 页面里面插入 script 代码，当用户浏览这个页面时，就会运行被插入的script 代码，达到攻击者的目的。XSS 的危害一般是泄露用户的登录信息 cookie，攻击者可以通过 cookie 绕过登录步骤直接进入站点。</li><li><strong>XSS类型：</strong>XSS 的分类分为反射型和存储型。反射型就是临时通过 url 访问网站，网站服务端将恶意代码从 url 中取出，拼接在 HTML 中返回给浏览器，用户就会执行恶意代码。存储型就是将恶意代码以留言的形式保存在服务器数据库，任何访问网站的人都会受到攻击。</li></ul> 
<h4 id="9%E3%80%81CSRF%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">10、CSRF攻击是什么？</h4> 
<ul><li>CSRF跨站点请求伪造，攻击者盗用了用户的身份，以用户的身份发送恶意请求，但是对服务器来说这个请求是合理的，这样就完成了攻击者的目标。</li><li><strong>原理：</strong>用户打开浏览器，访问目标网站A，输入用户名和密码请求登录，用户信息在通过认证后，网站A产生一个 cookie 信息返回给浏览器，这个时候用户以可正常发送请求到网站A。用户在没有退出网站A之前在同一个浏览器打开了另一个新网站B，新网站B收到用户请求之后返回一些攻击代码，并发出一个请求要求访问返回cookie的网站A，浏览器收到这些攻击性代码之后根据新网站B的请求在用户不知道的情况下以用户的权限操作了cookie 并向网站A服务器发起了合法的请求。</li></ul> 
<h4 id="10%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">11、什么是跨域？为什么有跨域问题？⭐⭐⭐</h4> 
<ul><li>跨域是由于浏览器的同源策略，当一个页面中某个请求的地址的 “协议”，“域名“，”端口“ 三者之间任意一个与当前页面的地址不同，在前后端分离的情况下导致无法直接通讯和访问，这种就是跨域。</li><li>出现跨域的话主要是因为浏览器的同源策略导致的，浏览器同源策略主要是为了防止黑客攻击，像 xss、csrf 攻击，但也导致了域名、协议、端口其中一个不同的话前后端无法访问，也就是跨域问题。其实跨域就是不允许跨域请求资源，是浏览器的安全限制。</li></ul> 
<h4 id="11%E3%80%81%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">12、跨域的解决方案有哪几种？⭐⭐⭐</h4> 
<ol><li><strong>cors 跨域资源共享：</strong>目前最常用的一种解决办法，通过设置后端允许跨域实现，类似后端给前端开了个后门一样，允许所有请求通过。通过 setHeader 设置 'Access-Control-Allow-Origin' 为通配符，允许所有请求通过。<span style="color:#4da8ee;">res.setHeader('Access-Control-Allow-Origin', '*');</span></li><li><strong>nodejs 中间件代理跨域：</strong>原理是让请求发给代理服务器，静态页面和代理服务器是同源的，然后代理服务器向后端服务器发请求，服务器和服务器之间不存在同源限制。具体实现：在vue.config.js 文件下配置，首先开启本地服务器 devServer，更改端口号 port，设置代理 proxy，设置代理目标（baseURL），是否允许跨域，设置反向代理路径，在接口地址前添加反向代理路径。</li><li><strong>jsonp：</strong>只能发送 get 请求。 原理是 script 标签可以跨域请求资源，将回调函数作为参数通过 ”?“ 拼接在 url 中，后端收到请求，调用该回调函数，并将数据作为参数返回去，前端通过回调函数获取响应数据。注意设置响应头返回文档类型，应该设置成 javascript。</li></ol> 
<h4>13、什么是 options 请求？</h4> 
<p>options 请求就是预检请求。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 options 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。</p> 
<h4 id="12%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B%EF%BC%9F">13、什么是浏览器内核？有什么用？有哪一些？</h4> 
<p><span style="color:#ff9900;">什么是浏览器内核？</span></p> 
<p>浏览器最核心部分， Rendering Engine 渲染引擎，一般叫浏览器内核。负责对网页语法的解释并渲染网页，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</p> 
<p><span style="color:#ff9900;">有什么用？</span></p> 
<p>浏览器内核对于浏览器而言，是基础，是依托，决定了网页的呈现的内容、格式以及效果。</p> 
<p><span style="color:#ff9900;">有哪一些？</span></p> 
<ul><li>Trident内核：IE内核</li><li>Gecko内核： Firefox内核（火狐浏览器）</li><li>WebKit内核：Safari</li><li>Blink内核：    Chrome(基于webkit，Google与Opera Software共同开发)</li><li>presto内核：  Opera（已改用Google Chrome的Blink内核）</li></ul> 
<h4 id="13%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%3F">14、什么是浏览器兼容问题?</h4> 
<p>因为不同浏览器的浏览器内核不一样，所以对同一段代码有不同的解析，造成页面显示效果不统一的情况。在大多数情况下，我们的需求是，无论用户用什么浏览器来查看我们的网站或者登陆我们的系统，都应该是统一的显示效果。</p> 
<h4 id="14%E3%80%81%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA(%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98)">15、优雅降级和渐进增强(浏览器兼容问题)</h4> 
<ul><li><strong>渐进增强：</strong>一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</li><li><strong>优雅降级：</strong>一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性<span style="color:#4d4d4d;">构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</span></li><li>其实渐进增强和优雅降级并非什么新概念，只是旧的概念换了一个新的说法。在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容。</li></ul> 
<h4 id="15%E3%80%81http%20%E5%92%8C%20https%20%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8%EF%BC%9F">16、http 和 https 有何区别？</h4> 
<ul><li><strong>http：</strong>HTTP 协议运行在 TCP 之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</li><li><strong>https：</strong>HTTP 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。</li></ul> 
<h4 id="17%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90">18、说一说前端性能优化手段？⭐⭐⭐</h4> 
<blockquote> 
 <p>前端性能优化分为两类，一类是文件加载更快，另一类是文件渲染更快。</p> 
</blockquote> 
<p><span style="color:#ff9900;">加载更快的方法：</span></p> 
<ol><li>让传输的数据包更小：图片压缩和文件压缩。</li><li>减少网络请求的次数：雪碧图/精灵图、节流防抖。</li><li>减少渲染的次数：缓存（HTTP缓存、本地缓存、Vue 的 keep-alive 缓存等）。</li></ol> 
<p><span style="color:#ff9900;"> 渲染更快的方法：</span></p> 
<ol><li>提前渲染：ssr 服务器端渲染。</li><li>避免渲染阻塞：CSS 放在 HTML 的 head 中，JS 放在 HTML 的 body 底部。</li><li>避免无用渲染：懒加载。</li><li>减少渲染次数：对 dom 查询进行缓存、将 dom 操作合并、使用减少重排的标签。</li></ol> 
<h4 id="18%E3%80%81%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F">19、网站性能优化的好处？怎么优化？</h4> 
<p><span style="color:#ff9900;">好处：</span></p> 
<ul><li><strong>用户角度：</strong>优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</li><li><strong>服务商角度：</strong>优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</li></ul> 
<p><span style="color:#ff9900;">怎么优化？</span></p> 
<p>页面级别的优化：HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等</p> 
<p>代码级别的优化：js 中的 DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等。</p> 
<p><strong>页面级优化：</strong></p> 
<ol><li>JavaScript 压缩和模块打包</li><li>按需加载资源</li><li>在使用 DOM 操作库时用上 array-ids</li><li>缓存</li><li>启用 HTTP/2</li><li>应用性能分析</li><li>使用负载均衡方案</li><li>为了更快的启动时间考虑一下同构</li><li>使用索引加速数据库查询</li><li>使用更快的转译方案</li><li>避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染</li><li>用于未来的一个建议：使用 service workers + 流</li><li>图片编码优化</li></ol> 
<h4 id="20%E3%80%81axios%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%EF%BC%9F">20、axios的拦截器原理及应用？</h4> 
<p><strong>应用场景：</strong>axios 为开发者提供了这样一个 API：拦截器。拦截器分为请求拦截器和响应拦截器。请求拦截器：在接口请求之前做的处理，比如为每个请求带上相应的参数，像 token、时间戳等。 返回拦截器：在接口返回之后做的处理，像对返回的状态进行判断，例如判断 token 是否过期。</p> 
<h4 id="21%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%88%9B%E5%BB%BA%20ajax%20%E8%BF%87%E7%A8%8B%EF%BC%9F">21、创建 ajax 过程？</h4> 
<ol><li>创建XHR对象：new XMLHttpRequest()。</li><li>设置请求参数：request.open(Method, 服务器接口地址)。</li><li>发送请求：request.send()，如果是 get 请求不需要参数，post 请求需要参数request.send(data)。</li><li>监听请求成功后的状态变化：根据状态码进行相应的处理。 <pre><code class="language-javascript">XHR.onreadystatechange = function(){ 
    if(XHR.readyState == 4 &amp;&amp; XHR.status == 200){ 
        console.log(XHR.responseText);
    }
}</code></pre> </li></ol> 
<h4 id="22%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20fetch%20%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F">22、说一下 fetch 请求方式？</h4> 
<p>fetch 是一种 HTTP 数据请求的方式，是 XMLHttpRequest 的一种替代方案。Fetch 函数就是原生js，没有使用 XMLHttpRequest 对象。fetch() 方法返回一个 Promise 解析 Response 来自 Request显 示状态（成功与否）的方法。</p> 
<h4 id="23%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%EF%BC%9F">23、说一下浏览器如何渲染页面的？</h4> 
<p>浏览器拿到 HTML，先将 HTML 转换成 dom 树，再将 CSS 样式转换成 stylesheet，根据 dom 树和 stylesheet 创建布局树，对布局树进行分层，为每个图层生成绘制列表，再将图层分成图块，紧接着光栅化将图块转换成位图，最后合成绘制生成页面。 </p> 
<h4 id="24%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E4%BF%9D%E6%8C%81%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%EF%BC%9F">24、说一下有什么方法可以保持前后端实时通信？</h4> 
<ul><li><strong>轮询：</strong>是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。其缺点明显：连接数会很多，一个接受，一个发送。而且每次发送请求都会有 Http 的 Header，会很耗流量，也会消耗CPU 的利用率。<span style="color:#4da8ee;"><strong>优点</strong></span>就是实现简单，无需做过多的更改。<span style="color:#fe2c24;"><strong>缺点</strong></span>是轮询的间隔过长，会导致用户不能及时接收到更新的数据。轮询的间隔过短，会导致查询请求过多，增加服务器端的负担。</li><li><strong>长轮询：</strong>对轮询的改进版，客户端发送 HTTP 给服务器之后，如果没有新消息，就一直等待。有新消息，才会返回给客户端。在某种程度上减小了网络带宽和CPU利用率等问题。</li><li><strong>iframe流方式：</strong>在页面中插入一个隐藏的 iframe，利用其 src 属性在服务器和客户端之间创建一条长连接，服务器向 iframe 传输数据，来实时更新页面。<span style="color:#4da8ee;"><strong>优点</strong></span>是消息能够实时到达，浏览器兼容好。<span style="color:#fe2c24;"><strong>缺点</strong></span>是服务器维护一个长连接会增加开销，IE、chrome、Firefox 会显示加载没有完成，图标会不停旋转。</li><li><strong>WebSocket：</strong>类似 Socket 的 TCP 长连接的通讯模式，一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。在客户端断开 WebSocket 连接或 Server 端断掉连接前，不需要客户端和服务端重新发起连接请求。<strong><span style="color:#4da8ee;">优点</span></strong>是在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。<span style="color:#fe2c24;"><strong>缺点</strong></span>是浏览器支持程度不一致，不支持断开重连。</li><li><strong>SSE：</strong>建立在浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。SSE 是单向通道，只能服务器向浏览器发送，因为 streaming 本质上就是下载。 <span style="color:#4da8ee;"><strong>优点</strong></span>是 SSE 使用 HTTP 协议，现有的服务器软件都支持。SSE 属于轻量级，使用简单，SSE 默认支持断线重连。</li><li>轮询适用于小型应用，实时性不高。长轮询适用于一些早期的对及时性有一些要求的应用像web IM 聊天。iframe 适用于客服通信等。 WebSocket 适用于微信、网络互动游戏等。SSE适用于金融股票数据、看板等。</li></ul> 
<h2 id="%E5%85%AB%E3%80%81git%20%E7%AF%87"><span style="color:#1a439c;">八、git 篇</span></h2> 
<h4 id="1%E3%80%81git%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">1、git 是什么？⭐</h4> 
<ol><li>Git是一个免费的、开源的分布式版本控制系统，git 支持分布式部署，可以有效、高速的处理从很小到非常大的项目版本管理。</li><li>分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的 Git 仓库。</li><li>我们可以在本地建一个版本库，每当我们需要修改时，就可以把之前的版本提交并标明此版的特点。这样文件夹里就只有一个编程文档了。当你需要哪个版本时，只要在版本库中恢复一下就可以了。</li></ol> 
<h4 id="2%E3%80%81git%20%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%9F">2、git 常用的命令？⭐</h4> 
<ul><li><strong>git clone 地址</strong> ：克隆</li><li><strong>git status</strong>：检查文件所处的状态</li><li><strong>git add .</strong> ：提交到暂存区</li><li><strong>git commit -m "描述"</strong>：提交到本地仓库</li><li><strong>git push</strong>：推送到远程仓库</li><li><strong>git pull</strong>：拉取远程仓库</li><li><strong>git reset --hard 哈希值(前6位)：</strong> 版本回退</li><li><strong>git log</strong>：打印日志</li><li><strong>git branch 分支名</strong>：创建分支</li><li><strong>git branch -a</strong>：查看所有分支</li><li><strong>git checkout 分支名 （检出）</strong>：切换分支</li><li><strong>git checkout -b</strong>：创建分支的同时切换到新分支</li><li><strong>git branch</strong> ：删除分支</li><li><strong>git remote -v</strong>：查看当前路径</li><li><strong>rm -r 文件名</strong>：删除文件夹</li></ul> 
<h4 id="3%E3%80%81git%20%E5%92%8C%20svn%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">3、git 和 svn 的区别？⭐⭐</h4> 
<ol><li>Git是分布式版本控制工具，SVN是集中式版本控制工具。</li><li>Git没有一个全局的版本号，而SVN有。</li><li>Git和SVN的分支不同。</li><li>Git把内容按元数据方式存储，而SVN是按文件。</li><li>Git内容的完整性要优于SVN。</li><li>Git无需联网就可使用（无需下载服务端），而SVN必须要联网（须下载服务端）。因为Git的版本区就在自己电脑上，而 svn 在远程服务器上。</li></ol> 
<h4 id="4%E3%80%81Git%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub%3F">4、Git项目如何配置，如何上传至GitHub?</h4> 
<ol><li>注册登录 github</li><li>创建 github 仓库</li><li>安装 git 客户端</li><li>绑定用户信息</li><li>设置 ssh key</li><li>创建本地项目以及仓库</li><li>关联 github 仓库</li><li>推送项目到 github 仓库</li></ol> 
<h4 id="5%E3%80%81%E4%BD%A0%E4%BB%AC%E5%85%AC%E5%8F%B8%20git%20%E5%88%86%E6%94%AF%E6%98%AF%E6%80%8E%E4%B9%88%E7%AE%A1%E7%90%86%E7%9A%84%EF%BC%9F">5、你们公司git分支是怎么管理的？⭐⭐</h4> 
<p>git 在开发中用来进行项目托管，项目中一般有三个分支，主分支master 只有项目负责人有操作权限，平时开发功能是在 develop 开发分支下创建的子分支也就是 feature 功能分支下开发的，功能开发完测试没问题了，切换到 develop 分支并拉取最新的 develop 分支，然后合并自己的任务分支并推送 develop 分支，再由项目负责人合并到 master 分支上。</p> 
<h4 id="6%E3%80%81git%20%E5%B7%A5%E4%BD%9C%E6%B5%81">6、git 工作流⭐</h4> 
<ul><li>master：主分支(上线发布的稳定版)</li><li>dev(develop)：开发分支</li><li>feature：功能分支(从 develop 拉取出来做新功能的分支)</li><li>fix：普通补丁分支(从 develop 拉取出来做修复bug的分支)</li><li>hotfix：维护分支(从 master 拉取出来的用于做紧急修复的分支，修复完后应马上合并回master 和 develop 分支)</li><li>release：预发布分支(从 develop 拉取出来的用于做测试的分支，检测完后合并到 master 分支发布，release 上做的 bug 修改要合并回 develop 分支)</li></ul> 
<h4 id="6%E3%80%81git%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">6、git版本冲突是什么？⭐</h4> 
<p>所谓冲突指的就是，两个开发者对同一个文件同一个位置做出了不同的内容修改，然后在进行分支合并时或者是从远程仓库拉取代码到本地库时，就会产出冲突报错；两个不同的版本，导致 git 不知道要接受那个。</p> 
<h4 id="7%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3git%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%EF%BC%9F">7、如何解决git版本冲突？⭐</h4> 
<ol><li> <p id="1.%E5%AF%BB%E6%89%BE%E5%86%B2%E7%AA%81"><strong>寻找冲突：</strong>首先要找到出现冲突的位置，通过<span style="color:#fe2c24;"> <span style="background-color:#fef2f0;">git merge 分支名</span></span> 如果有冲突的话会提示那些文件有冲突。</p> </li><li> <p><strong>修改冲突：</strong>找到冲突文件对比差异，然后手动修改为正确的。如果使用命令的话，使用 <span style="color:#fe2c24;"><span style="background-color:#fef2f0;">cat 冲突文件</span></span> 查看不同分支代码的差异，然后 <span style="color:#fe2c24;"><span style="background-color:#fef2f0;">vim</span></span><strong> </strong>进入冲突文件进行删除修改正确代码。</p> </li><li> <p id="3.%E6%8F%90%E4%BA%A4%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E5%86%B2%E7%AA%81%E6%96%87%E4%BB%B6"><strong>提交修改后的冲突文件：</strong>分别执行命令 <span style="color:#fe2c24;"><span style="background-color:#fef2f0;">git add</span></span><strong> </strong>添加到暂存区、<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">git commit -m</span></span> 提交到本地库、最后 <span style="color:#fe2c24;"><span style="background-color:#fef2f0;">git push</span></span><strong> </strong>推送到远程库就可以了。</p> </li></ol> 
<h2 id="%E4%B9%9D%E3%80%81%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span style="color:#1a439c;">九、功能的实现</span></h2> 
<h4 id="1%E3%80%81vuex%20%E5%AE%9E%E7%8E%B0%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD">1、vuex 实现购物车功能</h4> 
<p><span style="color:#ff9900;"><strong>原理：</strong></span>比如购物车商品数量，在商品列表页面添加商品会更改这个值，在详情页增减商品数量会更改这个值，进入购物车删除商品也会更改这个值，通过提交 mutation 来更改这个值就很简单明了。当然也可以每次都调用获取购物车数量的接口，也可以实现，但每一次的 HTTP 请求都是对浏览器性能的消耗。</p> 
<p><span style="color:#ff9900;"><strong>具体实现：</strong></span></p> 
<ol><li>给加入购物车一个点击事件，并把当前点击商品的所有内容，即 item 作为参数，用来传参。</li><li>通过点击事件获取到商品参数，通过 vuex 的 this.$store.dispatch(’触发的函数’，‘参数’) 把商品参数传给 vuex 的 action 函数。</li><li>在 vuex 的 state 中初始化购物车</li><li>编写 action 里面的异步方法，获取传过来的商品参数 item，通过 context.commit 提交 mutation</li><li>编写 mutation 里面的逻辑，获取到传过来的商品参数后做一个判断去重，因为同一个商品，第一次点击是添加，第二次点击是商品数量的增加。遍历在 state 中定义保存到本地的数组，判断 state 中保存到本地的 id 和传过来的 id 是否一样，如果一样，当前的商品的数量加加。如果 id 不一样则是第一次点击添加商品，通过 push 将商品参数 item 和 复选框状态以及商品数量添加到本地数组，计算总价，遍历保存到本地的商品，如果选中的状态就计算总价，保存到本地。</li><li>从本地拿数据并渲染页面，从 vuex 中取值，获取到加购的商品参数和单价和总价，通过 computed 保存到本地，然后渲染购物车页面</li><li>点击单件商品上的复选框并同步底部的全选复选框，点击底部全选复选框并同步上面商品的复选框，并加加减减计算价钱，不管是选择单件商品还是全选还是减商品、加商品、删除商品都是通过 this.$store.dispatch 去调用 vuex 中的 action 里面的异步方法，通过 context.commit 触发 mutation 里面的相应逻辑。</li><li>点击商品前面的复选框：触发 mutation 里面的相应同步方法，首先先改变复选框的状态，false 改为 true ，true 改为 false。通过 every( ) 方法检测购物车商品数组里面的元素的复选框是否都选中(true)，是的话返回 true 否则返回 false ， 把值赋给全选按钮，同步全选按钮。然后遍历购物车商品数据，判断商品复选框是否选中，选中就计算商品总价，然后保存到本地。</li><li>点击底部全选按钮：触发 mutation 里面的相应同步方法，更改全选复选框状态，遍历购物车数据，把全选复选框状态赋值给每个商品的复选框状，让他们同步，遍历购物车所有数据，判断如果商品的复选框为 true，则计算总价，然后保存到本地。</li><li>减商品：触发 mutation 里面的相应同步方法，判断当前商品的件数是否大于1，大于1的话商品件数减一，然后遍历商品数据重新计算总价。保存商品数据到本地。</li><li>加商品：触发 mutation 里面的相应同步方法，商品件数加一，遍历商品数据，重新计算商品总价，然后保存商品数据到本地。</li><li>删除数据：触发 mutation 里面的相应同步方法，通过 splice 删除当前数据，遍历商品数据，重新计算商品总价，然后保存商品数据到本地</li></ol> 
<h2 id="%E5%8D%81%E3%80%81%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81"><span style="color:#1a439c;">十、手撕代码</span></h2> 
<p><a href="https://blog.csdn.net/Monsters___/article/details/133470366" title="常见前端手写代码总汇（持续更新中...）-CSDN博客">常见前端手写代码总汇（持续更新中...）-CSDN博客</a></p> 
<h2 id="%E5%8D%81%E4%B8%80%E3%80%81%E6%9C%BA%E8%AF%95"><span style="color:#1a439c;">十一、机试</span></h2> 
<h2 id="%E4%B9%9D%E3%80%81%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97"><span style="color:#1a439c;">十二、其他</span></h2> 
<h4 id="1%E3%80%81%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D">1、自我介绍</h4> 
<h4 id="2%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E7%9A%84">2、说一下你是怎么样优化代码的</h4> 
<h4 id="3%E3%80%81%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%9A%84">3、你是如何优化项目的</h4> 
<h4 id="4%E3%80%81%E5%BC%80%E5%8F%91%E4%B8%AD%E9%83%BD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B7%A5%E5%85%B7">4、开发中都使用了哪些工具</h4> 
<h4 id="5%E3%80%81%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E8%BF%87%E4%BB%80%E4%B9%88bug">5、开发中遇到过什么bug</h4> 
<h4 id="6%E3%80%81%E4%BD%A0%E5%AF%B9%E5%8A%A0%E7%8F%AD%E7%9A%84%E7%9C%8B%E6%B3%95">6、你对加班的看法</h4> 
<h4 id="7%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E5%BC%80%E4%B8%8A%E4%B8%80%E5%AE%B6%E5%85%AC%E5%8F%B8">7、为什么离开上一家公司</h4> 
<h4 id="8%E3%80%81%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%9A%84">8、你是如何学习的</h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a31dfc3cf5e452abbbecf1a4d808600/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux使用spi读取icm20608传感器数值一直显示0</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30f051c782057403084163b6dbb3096b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C# WinForm窗体大小变化后页面切换控件闪烁的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>