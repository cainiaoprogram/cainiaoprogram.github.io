<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网络如何通讯：tcp详解以及网络通信做了什么 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="网络如何通讯：tcp详解以及网络通信做了什么" />
<meta property="og:description" content="网络 人与人之间要有语言才可以进行通讯，语言就是一种可以共享数据信息的规则，那么计算机与计算机之间也要有统一的连接标准才能够完成相互通信，这个标准被称为互联网协议，而网络是就是物理连接介质(电平信号) &#43; 互联网协议。
互联网协议 TCP/IP 五层 互联网协议是有很多的，TCP/IP 五层模型的出现目的就是将众多的互联网协议根据功能以及解决的问题分成几个模块，这样更容易发现问题并且去针对性的处理问题。
每层运行的常见设备如下所示：
物理层 物理层主要解决的是数据如何通过介质从一台机器传送给另外一台机器的问题。物理层通过基于电器特性发送高低电平信号传输数据，从一个基站传送到另一个基站。点平即是 “电压平台”，指的是电路中某一点电压的高低状态，在网络信号中高电平用数字 “1” 标识，低电平用数字 “0” 表示。电平的高低是个相对概念，3v 对于 7v是低电平，但对于 1v 就是高电平。
在这一层的工作的基建主要有中继器、中继塔、集线器、双绞线、光缆等。
数据链路层 由于单纯的电平信号是没有任何意义的，所以我们需要一套协议以及设备来将这些电平信号进行处理，处理成为互联网中可以传输的内容，比如电平信号多少位一组，每组表示什么含义。数据链路层的功能就是定义电平信号的分组方式。
1. 以太网协议 数据链路层基于以太网协议进行数据传输，通过mac地址寻址的广播方式进行数据传输，只能在局域网内传播。
Ethernet 以太网规定：一组电平信号构成一个数据包，叫做“帧”，每一数据帧由报头 Head 和数 data 两部分组成。
Head：固定18字节，其中发送者 / 源地址6字节，接受者 / 目标地址6字节，数据类型6字节。
Data：最短46字节，最长1500字节。
数据链路层的数据最短为64字节，最长为1518字节，超过的部分分片发送。
2. MAC 地址 数据链路层中的数据包中Head部分有发送者与接受者的地址，这个地址便是网卡的mac地址，Ethernet 规定接入 Internet 的设备必须配有网卡，Mac地址就是网卡的地址。所以数据包寻址的时候，会根据网卡的地址来决定数据会被谁所接受，这也是网卡所起的作用。
Mac地址，每块网卡在出厂的时候都会刻上一个全世界唯一的Mac地址，这个地址是不允许重复的，长度为48位的二进制数，通常用12位的十六进制数表示，前6位是厂商编号，后六位是流水线号。
3. 数据链路层的通讯，广播 Ethernet 以太网通讯的协议非常粗暴，直接以广播的形式在局域网中传输数据，所以一个局域网中的所有电脑都会受到广播信号，但因为有MAC地址的缘故，会根据数据包中的目标地址来匹配自己的MAC地址决定是否响应这个数据，如果匹配则相应，如果不匹配则丢弃掉这条消息。
所以数据链路层会带着MAC地址将数据通过传输层广播到局域网中，一个局域网中是有很多的PC机器的，每台PC机器的MAC地址唯一。
网络层 有了传输层、数据链路层的协议，计算机之间已经可以通信了，但是数据链路层的协议作用范围只能在局域网中进行数据传输，如果是广域网中，仍然采用广播的方式，那么整个广域网中的所有计算机都会收到这个广播，那么这份传输量是很巨大的，如果有几亿台机器，这份性能以及效率都是个灾难，所以广域网之间传输肯定不能用广播的方式。
广域网是由一个一个的局域网组成的，以太网包只能在一个局域网中发送，要想在广域网中发送，只能通过路由转发。所以就需要一种协议可以区分是广域网还是局域网。
网络层解决的就是这种问题，规定通过一个网络地址来区分不同广播域，不同广播域之间通过路由通信，这就是网络地址。
1. IP IP 协议是用来规定网络地址的协议，它规定的地址叫做IP地址。一般采用IPV4或者IPV6，IPV4规定网络地址由32位二进制数表示，通常斜撑4段十进制数，比如 172.16.10.1，取值范围为：0.0.0.0 ~ 255.255.255.255。
IP 地址由两部分组成：网络部分(用来标识子网) 和主机部分 (用来标示主机)。
2. 子网以及子网掩码 Internet组织机构定义了五种IP地址，有A、B、C三类地址。A类网络有126个，每个A类网络可能有16777214台主机，它们处于同一广播域。而在同一广播域中有这么多节点是不可能的，网络会因为广播通信而饱和，结果造成16777214个地址大部分没有分配出去。所以Internet组织机构把基于每类的IP网络进一步分成更小的网络，每个子网由路由器界定并分配一个新的子网网络地址,子网地址是借用基于每类的网络地址的主机部分创建的。划分子网后，通过使用掩码，把子网隐藏起来，使得从外部看网络没有变化，这就是子网掩码。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d1603c8be96c81cf4f6f73aa735b387e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-20T02:00:40+08:00" />
<meta property="article:modified_time" content="2020-10-20T02:00:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网络如何通讯：tcp详解以及网络通信做了什么</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>网络</h2> 
<p>人与人之间要有语言才可以进行通讯，语言就是一种可以共享数据信息的规则，那么计算机与计算机之间也要有统一的连接标准才能够完成相互通信，这个标准被称为互联网协议，而网络是就是物理连接介质(电平信号) + 互联网协议。</p> 
<h2><a id="_2"></a>互联网协议</h2> 
<h3><a id="TCPIP__3"></a>TCP/IP 五层</h3> 
<p>互联网协议是有很多的，TCP/IP 五层模型的出现目的就是将众多的互联网协议根据功能以及解决的问题分成几个模块，这样更容易发现问题并且去针对性的处理问题。<br> <img src="https://images2.imgbox.com/7e/f0/PeRn70Di_o.png" alt="在这里插入图片描述"><br> 每层运行的常见设备如下所示：<br> <img src="https://images2.imgbox.com/54/94/wLi7bnez_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_8"></a>物理层</h5> 
<p>物理层主要解决的是数据如何通过介质从一台机器传送给另外一台机器的问题。物理层通过基于电器特性发送高低电平信号传输数据，从一个基站传送到另一个基站。点平即是 “电压平台”，指的是电路中某一点电压的高低状态，在网络信号中高电平用数字 “1” 标识，低电平用数字 “0” 表示。电平的高低是个相对概念，3v 对于 7v是低电平，但对于 1v 就是高电平。<br> 在这一层的工作的基建主要有中继器、中继塔、集线器、双绞线、光缆等。</p> 
<h5><a id="_11"></a>数据链路层</h5> 
<p>由于单纯的电平信号是没有任何意义的，所以我们需要一套协议以及设备来将这些电平信号进行处理，处理成为互联网中可以传输的内容，比如电平信号多少位一组，每组表示什么含义。数据链路层的功能就是定义电平信号的分组方式。</p> 
<h6><a id="1__13"></a>1. 以太网协议</h6> 
<p>数据链路层基于以太网协议进行数据传输，通过mac地址寻址的广播方式进行数据传输，只能在局域网内传播。<br> Ethernet 以太网规定：一组电平信号构成一个数据包，叫做“帧”，每一数据帧由报头 Head 和数 data 两部分组成。<br> <img src="https://images2.imgbox.com/39/b2/SmSDHNbG_o.png" alt="在这里插入图片描述"><br> Head：固定18字节，其中发送者 / 源地址6字节，接受者 / 目标地址6字节，数据类型6字节。<br> Data：最短46字节，最长1500字节。</p> 
<blockquote> 
 <p>数据链路层的数据最短为64字节，最长为1518字节，超过的部分分片发送。</p> 
</blockquote> 
<h6><a id="2_MAC__21"></a>2. MAC 地址</h6> 
<p>数据链路层中的数据包中Head部分有发送者与接受者的地址，这个地址便是网卡的mac地址，Ethernet 规定接入 Internet 的设备必须配有网卡，Mac地址就是网卡的地址。所以数据包寻址的时候，会根据网卡的地址来决定数据会被谁所接受，这也是网卡所起的作用。<br> Mac地址，每块网卡在出厂的时候都会刻上一个全世界唯一的Mac地址，这个地址是不允许重复的，长度为48位的二进制数，通常用12位的十六进制数表示，前6位是厂商编号，后六位是流水线号。</p> 
<h6><a id="3__24"></a>3. 数据链路层的通讯，广播</h6> 
<p>Ethernet 以太网通讯的协议非常粗暴，直接以广播的形式在局域网中传输数据，所以一个局域网中的所有电脑都会受到广播信号，但因为有MAC地址的缘故，会根据数据包中的目标地址来匹配自己的MAC地址决定是否响应这个数据，如果匹配则相应，如果不匹配则丢弃掉这条消息。<br> <img src="https://images2.imgbox.com/5f/5e/uUBxMLw0_o.png" alt="在这里插入图片描述"></p> 
<p>所以数据链路层会带着MAC地址将数据通过传输层广播到局域网中，一个局域网中是有很多的PC机器的，每台PC机器的MAC地址唯一。</p> 
<h5><a id="_29"></a>网络层</h5> 
<p>有了传输层、数据链路层的协议，计算机之间已经可以通信了，但是数据链路层的协议作用范围只能在局域网中进行数据传输，如果是广域网中，仍然采用广播的方式，那么整个广域网中的所有计算机都会收到这个广播，那么这份传输量是很巨大的，如果有几亿台机器，这份性能以及效率都是个灾难，所以广域网之间传输肯定不能用广播的方式。<br> <img src="https://images2.imgbox.com/ef/ec/KQpr3Auh_o.png" alt="在这里插入图片描述"><br> 广域网是由一个一个的局域网组成的，以太网包只能在一个局域网中发送，要想在广域网中发送，只能通过路由转发。所以就需要一种协议可以区分是广域网还是局域网。<br> 网络层解决的就是这种问题，规定通过一个网络地址来区分不同广播域，不同广播域之间通过路由通信，这就是网络地址。</p> 
<h6><a id="1_IP_34"></a>1. IP</h6> 
<p>IP 协议是用来规定网络地址的协议，它规定的地址叫做IP地址。一般采用IPV4或者IPV6，IPV4规定网络地址由32位二进制数表示，通常斜撑4段十进制数，比如 172.16.10.1，取值范围为：0.0.0.0 ~ 255.255.255.255。</p> 
<blockquote> 
 <p>IP 地址由两部分组成：网络部分(用来标识子网) 和主机部分 (用来标示主机)。</p> 
</blockquote> 
<h6><a id="2__37"></a>2. 子网以及子网掩码</h6> 
<p>Internet组织机构定义了五种IP地址，有A、B、C三类地址。A类网络有126个，每个A类网络可能有16777214台主机，它们处于同一广播域。而在同一广播域中有这么多节点是不可能的，网络会因为广播通信而饱和，结果造成16777214个地址大部分没有分配出去。所以Internet组织机构把基于每类的IP网络进一步分成更小的网络，每个子网由路由器界定并分配一个新的子网网络地址,子网地址是借用基于每类的网络地址的主机部分创建的。划分子网后，通过使用掩码，把子网隐藏起来，使得从外部看网络没有变化，这就是子网掩码。</p> 
<p>RFC 950定义了子网掩码的使用，子网掩码是一个32位的2进制数，其对应网络地址的所有位置都为1，对应于主机地址的所有位置都为0。例如：IP地址为 172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网掩码就是 11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p> 
<p>规定，A类网络的默认子网掩码是255.0.0.0，B类网络的默认子网掩码是255.255.0.0，C类网络的默认子网掩码是255.255.255.0。我们根据子网掩码就可以判断两个任意IP是否在同一个子网中，将子网掩码和IP地址按位进行逻辑“与”运算，得到IP地址的网络地址，根据网络地址去判断两个IP是否在同一个子网中。<br> <img src="https://images2.imgbox.com/e7/e3/d5IYr5O9_o.png" alt="在这里插入图片描述"><br> 比如这个，c类地址前三段为网络部分，相同证明为一个网络地址。</p> 
<h6><a id="3IP_45"></a>3.IP数据包</h6> 
<p>IP数据包也分Head和Data两部分，IP数据包在网络传输中，直接放在以太网包的Data部分。<br> <img src="https://images2.imgbox.com/53/ca/dCSlubZ3_o.png" alt="在这里插入图片描述"></p> 
<ul><li>Head (IP头部)：长度为20~60字节。</li><li>Data（IP 数据）：最长为65515字节，但是一般达不到这个长度，因为以太网的长度限制，不能超过1500，超过要分包发送。</li></ul> 
<h6><a id="5_ARP_51"></a>5. ARP</h6> 
<p>ARP(Address Resolution Protocol)，地址解析协议，是用来解析从IP地址到MAC地址的映射。<br> 虽然有了网络层的IP地址我们可以在广域网中传输数据，但是在数据链路层，传输数据我们还得知道目标主机的MAC地址，知道自己主机的MAC地址是很容易，但是想要知道目标主机的MAC地址，就需要通过ARP协议来实现。<br> 下面介绍一个ARP的和具体过程：</p> 
<ul><li>主机 A 的IP地址为 10.1.20.64</li><li>主机 B 的IP地址为 10.1.20.109</li></ul> 
<p>当主机A要与主机B通信，ARP需要将主机B的IP地址解析成为主机B的MAC地址。</p> 
<p>第一步：网络层通过IP地址和子网掩码计算出自己所处的子网。</p> 
<p>第二步：为数据链路层寻找目标MAC地址，首先分析主机A与主机B是否为同一个网络，如果不是，那么目标MAC地址为路由器网关的MAC地址，如果是，则为主机B的MAC地址。</p> 
<p>第三步：根据主机A上的路由表内容，确定用于访问主机B的IP地址，然后主机A检查本地ARP缓存中是否有主机B的地址。</p> 
<p>第四步：如果主机A没有在本地ARP缓存中找到匹配的MAC地址，那么会将ARP广播出去。</p> 
<p>第五步：如果主机B发现ARP广播的地址就是自己，那么将自己的MAC地址相应发送回去，并且在自己的ARP中缓存主机A的MAC地址映射。</p> 
<p>第六步：主机A收到ARP回复，先更新缓存，然后就可以进行通讯了，本地ARP缓存是有生命周期的，如果失效则重复。</p> 
<blockquote> 
 <p>如果不在一个网络，发送给路由器之后，路由器会将数据转发并且执行同样的流程，直到找到真正的目标主机。</p> 
</blockquote> 
<h5><a id="_73"></a>传输层</h5> 
<p>经过网络层、数据链路层、网络层，我们已经可以将一份数据在局域网或者广域网中进行传输了。<br> 但是我们在一台主机上是运行着很多应用进程的，这些不同的应用进程之间如何能够精确的发送到另一台主机上同样的应用进程中，就是传输层需要解决的问题。<br> 传输层就是用来建立端口到端口的通信机制，每台应用进程启动都会占用一个端口，那么通过端口，就可以精确传输数据了。</p> 
<blockquote> 
 <p>主机端口的取值范围为0~65535，其中0-1023为系统保留端口的取值范围。<br> 为什么是65535呢，因为TCP头部留给存储端口的空间只有2字节，最大值就是65535.</p> 
</blockquote> 
<h6><a id="1_TCP_80"></a>1. TCP</h6> 
<p>tcp(Transmission Control Protocol),传输控制协议，是一种可靠传输协议，TCP的数据包是没有长度限制的，理论上可以无限长，但是为了保证网络的效率，一把不要超过IP数据包的长度，不然会被分包传送。<br> <img src="https://images2.imgbox.com/07/ce/S8DNutrr_o.png" alt="在这里插入图片描述"><br> TCP的数据直接放在了IP数据包内。</p> 
<h6><a id="2_UDP_84"></a>2. UDP</h6> 
<p>UDP(User Datagram Protocol),用户数据包协议，是一种不可靠传输协议，“报头”部分总有8字节，总长度不超过65535字节，正好放进一个IP数据包。<br> <img src="https://images2.imgbox.com/00/ef/mk3My9H3_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="3_TCP_87"></a>3. TCP报文结构</h6> 
<p>TCP 报文是 TCP 层传输的数据单元，也叫做报文段。TCP 报文结构如下图所示。<br> <img src="https://images2.imgbox.com/95/04/brTjiYGE_o.png" alt="在这里插入图片描述"></p> 
<ul><li>源端口：源端口和IP地址的作用是标识报文的返回地址。</li><li>目的端口：目的端口指明接收方计算机上的应用程序接口。</li><li>序号和确认号：TCP 可靠传输的保证，序号是本报文段发送的数据组的第一个字节的序号，在TCP流中，每一个字节都有一个序号。比如，第一个报文的序号为300，共有100字节，那么下一个报文的序号为400。确认号则是表名下一个希望收到序号。</li><li>数据偏移/头部长度：4位</li><li>保留：预留空间</li><li>标志位：URG、ACK、PSH、RST、SYN、FIN，标明本次报文的操作类型。</li><li>窗口：滑动窗口的大小，用来告知发送端接收端的缓存大小，以此控制发送端发送数据的速率。窗口大小是一个16位属性，因而窗口大小最大为65535.</li><li>校验和：奇偶校验，此校验是针对整个TCP报文段，包括TCP头部和TCP数据，一16位属性进行计算所得。有发送端计算和存储，由接收端进行验证。</li><li>紧急指针：只有当URG标志为1时才有效。</li><li>选项和填充：选项的可选属性最常见的是选择最长报文的大小，然后填充位是保证报文的长度不够的时间，加入额外的0。</li><li>数据部分：可选择的，可以有数据也可以没有数据，一般是消息正文。</li></ul> 
<p>传输层会将应用进程数据封装成报文，但是大小是受IP包的大小限制的，所以如果出超过这个大小，则会将TCP报文分片发送。</p> 
<h5><a id="_104"></a>应用层</h5> 
<p>经过传输层之后，应用进程之间就可以通信了，但是不同的应用程序，数据多种多样，那么应该如何去传输接受处理这些数据，这就是应用层解决的问题。</p> 
<h6><a id="1_DNS_106"></a>1. DNS协议</h6> 
<p>域名系统（Domain Name System，缩写：DNS）是用来把机器名转为IP地址的，也就是将域名与IP地址之间做一个映射，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p> 
<h6><a id="2_HTTP_108"></a>2. HTTP</h6> 
<p>HTTP，超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是面向事务的应用层协议，是万维网的数据通信的基础。HTTP使用面向连接的TCP作为传输层协议，保证了数据的可靠传输。</p> 
<h6><a id="3_FTP_110"></a>3. FTP</h6> 
<p>FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。FTP一般用来传输文件。</p> 
<h6><a id="4_SMTP_112"></a>4. SMTP</h6> 
<p>SMTP(Simple Mail Transfer Protocol,简单邮件传输协议)是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。</p> 
<h6><a id="5_Telnet__114"></a>5. Telnet 协议</h6> 
<p>Telnet 协议是一个简单的远程终端协议，也是互联网的正式标准，又称为终端仿真协议。</p> 
<p>应用层主要针对应用数据的传输格式，比如我们常见的HTTP协议，就是规定了数据应该如何在CS架构中传输定义解析。</p> 
<h2><a id="_118"></a>网络通信</h2> 
<h3><a id="_119"></a>主机地址分配实现原理</h3> 
<p>经过五层模型的分析，我们发现要想实现网络通信，每台主机需具备四要素：本机的IP地址、子网掩码、网关的IP地址、DNS的IP地址(域名)。<br> 获取这四要素有两种方式：一种是手动配置静态获取，另外一种是动态获取，即通过DHCP(Dynamic Host Configuration Protocol) 动态主机配置协议获取。<br> <img src="https://images2.imgbox.com/11/fa/555Ulk0d_o.png" alt="在这里插入图片描述"><br> 这是一个DHCP的网络包。</p> 
<ul><li>以太网头部，设置本地的MAC地址和接收方DHCP服务器服务器的MAC地址，后者可能还不知道，默认为广播地址：FF-FF-FF-FF-FF-FF.</li><li>IP 头部，设置本机的IP地址与目标IP地址，这个时候两个地址都不知道，于是默认发出方为0.0.0.0,目标为 255.255.255.255。</li><li>UDP头部，设置发出方与接收方的端口，DHCP规定，发出方为68，接收方为67.</li></ul> 
<p>一台机器要想在网络中通信，必须要有上边四个要素。再将以太网数据包封好之后，首先广播出去，因为MAC地址为 FF-FF-FF-FF-FF-FF，所有机器都不知道这是谁，就通过ARP去解析IP，然后发现发送发IP为 0.0.0.0，接收方IP为255.255.255.255，DHCP服务器就知道这是它的，于是解析以太网包。<br> DHCP服务器解析好之后，分配好IP地址，然后发送一个响应包回去，这个时候双方的MAC地址都是知道的，所以可以通信了，那么本机收到响应包就知道了自己分配好的IP地址、子网掩码、网关地址、DNS服务器参数。</p> 
<h3><a id="_130"></a>一个网络请求经过的过程</h3> 
<p>前边通过DHCP已经可以联网通信，那么在浏览器中输入一个URL到底经过了什么过程呢？</p> 
<p>第一步：通过DHCP获取到了本机的配置，这是前提。</p> 
<p>第二步：打开浏览器，输入域名访问，比如百度官网 www.baidu.com</p> 
<p>第三步：通过域名寻找到目标机器的IP地址，这一步是在应用层的DNS协议去处理的，会到DNS服务器上去解析拿到目标IP地址。<img src="https://images2.imgbox.com/3c/27/OwO9Bufd_o.png" alt="加粗样式"><br> (偷的图，大致意思就是，先去本地Dns去找，如果没有，就去跟服务器去找.com解析服务器的地址，然后.com解析服务器也没有会去找baidu.com主区域服务器，这里找到了则返回本地dns服务器，缓存下来，然后返回。)</p> 
<p>第四步：发起HTTP请求，这一步也还在应用层，封装HTTP数据报文.</p> 
<p>第五步：到传输层，通过TCP协议封装报文段，封装应用的端口，目标机器的端口。</p> 
<p>第六步：网络层封装IP数据包，需要封装双方的IP地址，这一步的IP地址在第三步中已经知道了。</p> 
<p>第七步：封装以太网数据包，会根据ARP去寻找对方的MAC地址，找到MAC地址之后，封到数据包中，然后广播发送出去。假设这里的数据报文长度为5000字节，但是以太网数据包最大为1500字节，那么这里就会拆包，分成四次分别发送。<br> <img src="https://images2.imgbox.com/d1/71/Crmm7lM6_o.png" alt="在这里插入图片描述"></p> 
<p>第八步：经过多个路由网关的处理，请求到了百度的服务器上，然后百度等待完成的TCP报文过来，解析，做出响应，完成一次通信。</p> 
<h2><a id="TCP__151"></a>TCP 三次握手四次挥手</h2> 
<p>TCP的传输连接包括三个阶段：建立连接、数据传送和连接释放。</p> 
<h3><a id="_153"></a>建立连接</h3> 
<p><img src="https://images2.imgbox.com/65/2c/dISDR4Je_o.png" alt=""></p> 
<p>TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。</p> 
<p>TCP三次握手的过程如下：</p> 
<ul><li>客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。</li><li>服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK（ACK=x+1）报文，进入SYN_RECV状态。</li><li>客户端收到服务器端的SYN报文，回应一个ACK（ACK=y+1）报文，进入Established状态。</li></ul> 
<h3><a id="_162"></a>数据传输</h3> 
<p>三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。</p> 
<h3><a id="_164"></a>连接终止</h3> 
<p><img src="https://images2.imgbox.com/e9/e3/qZ5ACoIM_o.png" alt="在这里插入图片描述"></p> 
<p>建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。具体过程如下图所示。</p> 
<ul><li>某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。</li><li>接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。<br> 注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</li><li>一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。</li><li>接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。</li></ul> 
<blockquote> 
 <p>既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。<br> 注意：<br> （1） “通常”是指，某些情况下，步骤1的FIN随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。<br> （2） 在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的，这称为“半关闭”（half-close）。<br> （3） 当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。<br> 无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a50a39613e384387cf369268c8f3bbc4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2020-10-19 Nvidia与vGPU</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3fc0ff9044d2e65efd8d6dfc8243edb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">怎么彻底删除电脑上的软件_1个神器彻底删除流氓软件，瞬间清出十几个G，你的电脑有救了！...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>