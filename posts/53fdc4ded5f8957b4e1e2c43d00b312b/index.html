<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>每日coding - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="每日coding" />
<meta property="og:description" content="今天无意点进一个回文串的题目，对于回文串我第一印象就用双指针，但是确实没写出来，看了评论区题解，绝大多数都是用dp来做的，但是找到一个用双指针做的，刚好延续思路，先把题目贴出来。
5、最长回文子串 给你一个字符串 s，找到 s 中最长的回文子串。
如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。
示例 1：
输入：s = &#34;babad&#34; 输出：&#34;bab&#34; 解释：&#34;aba&#34; 同样是符合题意的答案。 示例 2：
输入：s = &#34;cbbd&#34; 输出：&#34;bb&#34; 提示：
1 &lt;= s.length &lt;= 1000s 仅由数字和英文字母组成 这道题目之前一直做不对的原因是，我一直想的是回文串的中心点只能从给的字符串中心点取，这就思想有问题了。okok，看看这道题目双指针的解法，先说复杂度，时间复杂度o（n^2），空间复杂度o（1）。核心思想其实是，回文串就两种可能，一种是中间一个数值，一种是中间两个数值，因此就一个一个试，然后找到最长的，但是需要记录下来最长的start和end，这个公式反正有点迷糊，但是一写还真是这样。
class Solution { public: string longestPalindrome(string s) { int len = s.size(); if(len == 0 || len == 1) return s; int start = 0; int end = 0; int mlen = 0; for(int i = 0;i &lt; len;&#43;&#43;i){ int len1 = expendaroundcenter(s, i, i); int len2 = expendaroundcenter(s, i, i&#43;1); mlen = max(max(len1, len2), mlen); if(mlen &gt; end - start &#43; 1){ start = i - (mlen-1) / 2; end = i &#43; mlen / 2; } } return s." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/53fdc4ded5f8957b4e1e2c43d00b312b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T21:30:27+08:00" />
<meta property="article:modified_time" content="2024-01-04T21:30:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">每日coding</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>今天无意点进一个回文串的题目，对于回文串我第一印象就用双指针，但是确实没写出来，看了评论区题解，绝大多数都是用dp来做的，但是找到一个用双指针做的，刚好延续思路，先把题目贴出来。</p> 
<h2>5、最长回文子串</h2> 
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p> 
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p> 
<p></p> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入：</strong>s = "babad"
<strong>输出：</strong>"bab"
<strong>解释：</strong>"aba" 同样是符合题意的答案。
</pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入：</strong>s = "cbbd"
<strong>输出：</strong>"bb"
</pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul> 
<p></p> 
<p>这道题目之前一直做不对的原因是，我一直想的是回文串的中心点只能从给的字符串中心点取，这就思想有问题了。okok，看看这道题目双指针的解法，先说复杂度，时间复杂度o（n^2），空间复杂度o（1）。核心思想其实是，回文串就两种可能，一种是中间一个数值，一种是中间两个数值，因此就一个一个试，然后找到最长的，但是需要记录下来最长的start和end，这个公式反正有点迷糊，但是一写还真是这样。</p> 
<pre><code>class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.size();
        if(len == 0 || len == 1)
            return s;
        int start = 0;
        int end = 0;
        int mlen = 0;
        for(int i = 0;i &lt; len;++i){
            int len1 = expendaroundcenter(s, i, i);
            int len2 = expendaroundcenter(s, i, i+1);
            mlen = max(max(len1, len2), mlen);
            if(mlen &gt; end - start + 1){
                start = i - (mlen-1) / 2;
                end = i + mlen / 2;
            }
        }
        return s.substr(start, mlen);
    }
private:
    int expendaroundcenter(string s, int left, int right){
        int L = left;
        int R = right;
        while(L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s[R] == s[L]){
            L--;
            R++;
        }
        return R - L - 1;
    }
};</code></pre> 
<p>今天的每日一题目，题没看懂，等状态好了再看看。</p> 
<p></p> 
<p></p> 
<p>前几天看的背包问题，今天看到一道纯种的背包，太纯了</p> 
<h2>279、完全平方数</h2> 
<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p> 
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入：</strong>n = <code>12</code>
<strong>输出：</strong>3 
<strong>解释：</strong><code>12 = 4 + 4 + 4</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入：</strong>n = <code>13</code>
<strong>输出：</strong>2
<strong>解释：</strong><code>13 = 4 + 9</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= n &lt;= 104</code></li></ul> 
<p></p> 
<pre><code>class Solution {
public:
    int numSquares(int n) {
        vector&lt;int&gt; dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i &lt;= n; i++) { 
            for (int j = 1; j * j &lt;= i; j++) {
                dp[i] = min(dp[i - j * j] + 1, dp[i]);
            }
        }
        return dp[n];
    }
};</code></pre> 
<p>  </p> 
<h2>75、颜色分类</h2> 
<p>给定一个包含红色、白色和蓝色、共 <code>n</code><em> </em>个元素的数组 <code>nums</code> ，<strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" rel="nofollow" title="原地">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p> 
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p> 
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入：</strong>nums = [2,0,2,1,1,0]
<strong>输出：</strong>[0,0,1,1,2,2]
</pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入：</strong>nums = [2,0,1]
<strong>输出：</strong>[0,1,2]
</pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul> 
<p><strong>进阶：</strong></p> 
<ul><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul> 
<p></p> 
<p>这道题目看到评论区有很巧妙的写法，但是呢，我选择直接冒泡，前几天总结了点冒泡排序和快排，这里就用上了，巧妙的做法就不贴了。</p> 
<pre><code class="hljs">class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; nums) {
        for(int i = 0;i &lt; nums.size() - 1;++i){
            for(int j = 0;j &lt; nums.size() - i -1;++j){
                if(nums[j] &gt; nums[j + 1]){
                    int tmp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = tmp;
                }
            }
        }
    }
};</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04cd6032c8c4d5412d156ad7e26cf10a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL之基于代价的慢查询优化建议</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf9bc15514b7da4dd3ee0d254affae71/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度学习-模型转换_所需算力相关</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>