<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【嵌入式环境下linux内核及驱动学习笔记-（18）LCD驱动框架1-LCD控制原理】 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【嵌入式环境下linux内核及驱动学习笔记-（18）LCD驱动框架1-LCD控制原理】" />
<meta property="og:description" content="目录 1、LCD显示系统介绍1.1 LCD显示基本原理1.1.1 颜色的显示原理：1.1.2 图像的构成 1.2 LCD接口介绍1.2.1 驱动接口 - MCU接口1.2.2 驱动接口 - RGB接口1.2.3 驱动接口 - LVDS接口1.2.4 驱动接口 - MIPI接口1.2.5 RGB / MIPI / LVDS三种接口方式的区别： 2、RGB控制原理2.1 LCD显示系统结构2.2 基本显示过程2.3 LCD时钟控制2.3.1 像素时钟2.3.2 水平同步时钟 HSYNC2.3.3 显示一帧 - 垂直同步时钟VSYNC 2.4 控制时序2.5 LCD时序与显示的映射关系2.6 linux对LCD时序的抽象2.6.1 struct fb_videomode 显示参数结构体2.6.2 判断 HSYNC,VSYNC,VCLK, VDEN信号是否需要反转 3、实验环境介绍4、 exynos4412的LCD控制器相关知识点介绍4.1 显示控制器介绍4.2 时钟4.3 RGB接口4.3.1 RGB接口控制器4.3.2 RGB接口规范4.3.3 信号4.3.4 LCD RGB接口时序 4.4 寄存器4.4.1 寄存器概况4.4.2 寄存器使用详述4.4.2.2 时钟寄存器CLK_SRC_LCD0 （P505）CLK_SRC_MASK_LCDCLK_DIV_LCD （P530）CLK_GATE_IP_LCD (P556) 4.4.2.3 系统寄存器LCDBLK_CFG (P884)LCDBLK_CFG2 （P886） 4.4.2.4 LCD控制寄存器VIDCON0 （P1838）VIDCON1 (P1839)VIDTCON0 (P1842)VIDTCON1VIDTCON2 (P1843)VIDTCON3 (P1843)WINCON0 (P1844)SHADOWCON (P1859)WINCHMAP2VIDOSD0A VIDOSD0B VIDOSD0C（P1863） 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1dba616247ec115a1d709a04e9f741c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-07T21:27:01+08:00" />
<meta property="article:modified_time" content="2023-08-07T21:27:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【嵌入式环境下linux内核及驱动学习笔记-（18）LCD驱动框架1-LCD控制原理】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1LCD_5" rel="nofollow">1、LCD显示系统介绍</a></li><li><ul><li><a href="#11_LCD_7" rel="nofollow">1.1 LCD显示基本原理</a></li><li><ul><li><a href="#111__13" rel="nofollow">1.1.1 颜色的显示原理：</a></li><li><a href="#112__24" rel="nofollow">1.1.2 图像的构成</a></li></ul> 
   </li><li><a href="#12_LCD_38" rel="nofollow">1.2 LCD接口介绍</a></li><li><ul><li><a href="#121___MCU_54" rel="nofollow">1.2.1 驱动接口 - MCU接口</a></li><li><a href="#122___RGB_69" rel="nofollow">1.2.2 驱动接口 - RGB接口</a></li><li><a href="#123___LVDS_86" rel="nofollow">1.2.3 驱动接口 - LVDS接口</a></li><li><a href="#124___MIPI_97" rel="nofollow">1.2.4 驱动接口 - MIPI接口</a></li><li><a href="#125_RGB__MIPI__LVDS_107" rel="nofollow">1.2.5 RGB / MIPI / LVDS三种接口方式的区别：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#2RGB_115" rel="nofollow">2、RGB控制原理</a></li><li><ul><li><a href="#21_LCD_122" rel="nofollow">2.1 LCD显示系统结构</a></li><li><a href="#22__137" rel="nofollow">2.2 基本显示过程</a></li><li><a href="#23_LCD_144" rel="nofollow">2.3 LCD时钟控制</a></li><li><ul><li><a href="#231__148" rel="nofollow">2.3.1 像素时钟</a></li><li><a href="#232__HSYNC_154" rel="nofollow">2.3.2 水平同步时钟 HSYNC</a></li><li><a href="#233___VSYNC_162" rel="nofollow">2.3.3 显示一帧 - 垂直同步时钟VSYNC</a></li></ul> 
   </li><li><a href="#24__170" rel="nofollow">2.4 控制时序</a></li><li><a href="#25__LCD_191" rel="nofollow">2.5 LCD时序与显示的映射关系</a></li><li><a href="#26_linuxLCD_239" rel="nofollow">2.6 linux对LCD时序的抽象</a></li><li><ul><li><a href="#261__struct_fb_videomode___244" rel="nofollow">2.6.1 struct fb_videomode 显示参数结构体</a></li><li><a href="#262__HSYNCVSYNCVCLK_VDEN_288" rel="nofollow">2.6.2 判断 HSYNC,VSYNC,VCLK, VDEN信号是否需要反转</a></li></ul> 
  </li></ul> 
  </li><li><a href="#3_329" rel="nofollow">3、实验环境介绍</a></li><li><a href="#4_exynos4412LCD_356" rel="nofollow">4、 exynos4412的LCD控制器相关知识点介绍</a></li><li><ul><li><a href="#41__359" rel="nofollow">4.1 显示控制器介绍</a></li><li><a href="#42__373" rel="nofollow">4.2 时钟</a></li><li><a href="#43__RGB_383" rel="nofollow">4.3 RGB接口</a></li><li><ul><li><a href="#431__RGB_384" rel="nofollow">4.3.1 RGB接口控制器</a></li><li><a href="#432_RGB_421" rel="nofollow">4.3.2 RGB接口规范</a></li><li><a href="#433__431" rel="nofollow">4.3.3 信号</a></li><li><a href="#434_LCD_RGB_436" rel="nofollow">4.3.4 LCD RGB接口时序</a></li></ul> 
   </li><li><a href="#44__440" rel="nofollow">4.4 寄存器</a></li><li><ul><li><a href="#441__443" rel="nofollow">4.4.1 寄存器概况</a></li><li><a href="#442__472" rel="nofollow">4.4.2 寄存器使用详述</a></li><li><ul><li><a href="#4422__475" rel="nofollow">4.4.2.2 时钟寄存器</a></li><li><ul><li><a href="#CLK_SRC_LCD0______P505_480" rel="nofollow">CLK_SRC_LCD0 （P505）</a></li><li><a href="#CLK_SRC_MASK_LCD_492" rel="nofollow">CLK_SRC_MASK_LCD</a></li><li><a href="#CLK_DIV_LCD__P530_497" rel="nofollow">CLK_DIV_LCD （P530）</a></li><li><a href="#CLK_GATE_IP_LCD__P556_503" rel="nofollow">CLK_GATE_IP_LCD (P556)</a></li></ul> 
     </li><li><a href="#4423__510" rel="nofollow">4.4.2.3 系统寄存器</a></li><li><ul><li><a href="#LCDBLK_CFG__P884_511" rel="nofollow">LCDBLK_CFG (P884)</a></li><li><a href="#LCDBLK_CFG2_P886_522" rel="nofollow">LCDBLK_CFG2 （P886）</a></li></ul> 
     </li><li><a href="#4424_LCD_529" rel="nofollow">4.4.2.4 LCD控制寄存器</a></li><li><ul><li><a href="#VIDCON0__P1838_531" rel="nofollow">VIDCON0 （P1838）</a></li><li><a href="#VIDCON1__P1839_537" rel="nofollow">VIDCON1 (P1839)</a></li><li><a href="#VIDTCON0___P1842_544" rel="nofollow">VIDTCON0 (P1842)</a></li><li><a href="#VIDTCON1_551" rel="nofollow">VIDTCON1</a></li><li><a href="#VIDTCON2__P1843_557" rel="nofollow">VIDTCON2 (P1843)</a></li><li><a href="#VIDTCON3_P1843_564" rel="nofollow">VIDTCON3 (P1843)</a></li><li><a href="#WINCON0__P1844_571" rel="nofollow">WINCON0 (P1844)</a></li><li><a href="#SHADOWCON____P1859_582" rel="nofollow">SHADOWCON (P1859)</a></li><li><a href="#WINCHMAP2_588" rel="nofollow">WINCHMAP2</a></li><li><a href="#VIDOSD0A____VIDOSD0B___VIDOSD0CP1863_597" rel="nofollow">VIDOSD0A VIDOSD0B VIDOSD0C（P1863）</a></li></ul> 
     </li><li><a href="#4425___609" rel="nofollow">4.4.2.5 电源管理寄存器</a></li><li><ul><li><a href="#9_LCD0_CONFIGURATION_611" rel="nofollow">9 LCD0_CONFIGURATION</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#5_618" rel="nofollow">5、结语</a></li></ul> 
</div> 
<p></p> 
<p>本篇是LINUX3.14环境中的LCD驱动框架的第一篇，主要讲解LCD显示的基本原理，RGB控制器的运行原理，LCD硬件编程的准备知识，包括大量的需要使用到的寄存器详述。由于涉及到大量的细节，因此写的过程中难免有错误与遗漏，因此，如有发现错漏，请及时留言指出。哪些地方不好理解，或没说明白，也请指出，我们一起讨论完善。</p> 
<h2><a id="1LCD_5"></a>1、LCD显示系统介绍</h2> 
<h3><a id="11_LCD_7"></a>1.1 LCD显示基本原理</h3> 
<p><img src="https://images2.imgbox.com/53/3c/DWL3uBI4_o.png" alt="在这里插入图片描述"><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>从这张图就可以看出。白光经过楄光和液晶层后通过每一个像素的RGB的三个子像素后，就能呈现出彩色图像。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>因此，LCD的电路主要任务就是控制如图中的电极板，从而控制液晶形态而达到控制每个红兰绿子像素的秀光量。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>当前主流的LCD是TFT，特点是超薄、清晰。</p> 
<h4><a id="111__13"></a>1.1.1 颜色的显示原理：</h4> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>显示器的颜色一般采用RGB标准，通过对红(RED)、绿(GREEN)，蓝(BLUE)三个颜色相互叠加得到各种不同的颜色。</p> 
<ul><li>通过对颜色的编码来对颜色进行量化（即转换成数字量，RGB是一种编码方式）；</li><li>每种颜色根据RGB格式不同，每种颜色的量化位不相同；</li><li>常见的RGB格式有RGB565/RGB888，即:<br> RGB565: red :5 green : 6 blue:5（16BPP）<br> RGB888: red :8 green : 8 blue:8（24BPP）</li><li>有的还会有个alpha参数，用于实现图形渐变效果，以及半透明效果，0xFFF=全透明，0x0=不透明；</li></ul> 
<h4><a id="112__24"></a>1.1.2 图像的构成</h4> 
<p><strong>像素：</strong></p> 
<ul><li>像素pix，显示的最小单位；</li><li>在计算机只常用若干位数据来表示一个像素，比如使用R8、G8、B8共24位来表示一个像素，这个也称为像素深度，单位为BPP 常见的有16BPP/24BPP；</li><li>像素深度越大，则一个像素点所显示的颜色就越多，所显示的颜色更广；</li></ul> 
<p><strong>帧：</strong></p> 
<ul><li>一屏图像被称为一帧，每帧里面由行列排列的像素组成；</li></ul> 
<p><strong>调色板：</strong><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>画油画的时候，通常先在调色板里配好想要的颜色，再用画笔沾到画布上作画。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>LCD控制器里也借用了这个概念，从FrameBuffer获得数据，这个数据作为索引从调色板获得对应数据，再发给电子枪显示出来。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>假如是16BPP的数据，LCD控制器从FB取出16bit数据，显示到LCD上。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>当如果想节约内存，对颜色要求也没那么高，就可以采用调色板的方式，调色板里存放了256个16bit的数据，FB只存放每个像素的索引，根据索引去调色板找到对应的数据传给LCD控制器，再通过电子枪显示出来。</p> 
<h3><a id="12_LCD_38"></a>1.2 LCD接口介绍</h3> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>不同的组件之间的连接，需要做好很多约定，这些软硬件的约定构成了接口。在LCD的屏与控制器之间的接口是开发者重点要关注的。接口有不同层次的分别，使用时注意区分：</p> 
<p><strong>LCD驱动接口：</strong><br> 用于连接LCD驱动器与LCD控制器这间的软硬件规范。是芯片级的接口。</p> 
<ul><li>在单片机上：MCU接口</li><li>在嵌入式中：RGB接口、LVDS接口、MIPI-DSI接口</li></ul> 
<p><strong>LCD传输接口：</strong><br> 当LCD与SOC有一定的距离，就需要用到传输技术来为控制器和驱动器传递信号，传输线缆与控制器之前的连接也涉及到相应的软硬件规范。</p> 
<ul><li>HDMI</li><li>DP</li><li>USB</li></ul> 
<h4><a id="121___MCU_54"></a>1.2.1 驱动接口 - MCU接口</h4> 
<ul><li>应用领域：小尺寸手机屏，单片机应用，一般4寸以下。</li><li>优势：价格便宜。</li><li>劣势：指令逐点写入，速度慢</li><li>接口执行标准：Intel 8080总线标准（I80标准）</li><li> 
  <ul><li>8080模式 、6800模式</li></ul> </li><li> 
  <ul><li>并行8位、16位、18位、24位传输</li></ul> </li><li> 
  <ul><li>无需时钟和同步信号</li></ul> </li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            L 
           
          
            C 
           
          
            D 
           
          
            驱动器要内置 
           
          
            G 
           
          
            R 
           
          
            A 
           
          
            M 
           
          
         
        
       
         \color{red}{LCD驱动器要内置GRAM} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord" style="color: red;"><span class="mord mathnormal" style="color: red;">L</span><span class="mord mathnormal" style="margin-right: 0.0715em; color: red;">C</span><span class="mord mathnormal" style="margin-right: 0.0278em; color: red;">D</span><span class="mord cjk_fallback" style="color: red;">驱动器要内置</span><span class="mord mathnormal" style="margin-right: 0.0077em; color: red;">GR</span><span class="mord mathnormal" style="color: red;">A</span><span class="mord mathnormal" style="margin-right: 0.109em; color: red;">M</span></span></span></span></span></span>，直接一对一投射每个象素。</li><li>显示过程<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           不需要点、行、帧时钟 
          
         
        
       
         \color{red}{不需要点、行、帧时钟} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord" style="color: red;"><span class="mord cjk_fallback" style="color: red;">不需要点、行、帧时钟</span></span></span></span></span></span>。</li></ul> 
<h4><a id="122___RGB_69"></a>1.2.2 驱动接口 - RGB接口</h4> 
<ul><li>应用领域：嵌入式应用，一般7寸以上。</li><li>优势：直接写屏，显示速度快</li><li>劣势：价格高，功耗大，抗EMI电磁干扰弱</li><li>接口执行标准：TTL</li><li> 
  <ul><li>颜色编码方式RGB24 / RGB888 / RGB555 / RGB565 / RGB666</li></ul> </li><li> 
  <ul><li>并行24位传输</li></ul> </li><li> 
  <ul><li>显示过程要有<font color="red">时钟和行、帧同步信号等（HSYNC, , VSYNC , ENABLE , CS , RESET , RS）</font></li></ul> </li><li>显存是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           内存映射 
          
         
        
       
         \color{red}{内存映射} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord" style="color: red;"><span class="mord cjk_fallback" style="color: red;">内存映射</span></span></span></span></span></span>，LCD驱动中没有GRAM。</li></ul> 
<p><img src="https://images2.imgbox.com/c7/4a/UoUPfu4D_o.png" alt="在这里插入图片描述" width="300"></p> 
<h4><a id="123___LVDS_86"></a>1.2.3 驱动接口 - LVDS接口</h4> 
<p>LVDS：Low Voltage Differential Signaling 是一种<code>低压差分信号</code>技术接口。</p> 
<ul><li>应用领域：嵌入式应用，一般7寸以上。</li><li>优势：直接写屏，显示速度快，功耗小，EMI电磁干扰小</li><li>劣势：价格高</li><li>接口执行标准：LVDS</li><li> 
  <ul><li>信号内容：RGB</li></ul> </li><li> 
  <ul><li>常见的lvds接口分为四通道、五通道、十通道。</li></ul> </li><li>速度快，常见的有几百Mbit/s<br> <img src="https://images2.imgbox.com/ad/16/Wi0OdAgO_o.png" alt="在这里插入图片描述" width="300"></li></ul> 
<h4><a id="124___MIPI_97"></a>1.2.4 驱动接口 - MIPI接口</h4> 
<p>MIPI：Mobile Industry Processor Interface 移动行业处理器接口</p> 
<ul><li>应用领域：移动嵌入式领域</li><li>应用的接口标准：DSI(Display Serial Interface Specification）和 CSI（摄像头接口）</li><li>优势：高速，功耗小，干扰小</li><li>劣势：价格高</li><li>接口执行标准：</li><li> 
  <ul><li>信号内容：视频流数据和控制指令</li></ul> </li></ul> 
<h4><a id="125_RGB__MIPI__LVDS_107"></a>1.2.5 RGB / MIPI / LVDS三种接口方式的区别：</h4> 
<p><img src="https://images2.imgbox.com/ec/8d/YZUsWJcl_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2RGB_115"></a>2、RGB控制原理</h2> 
<p>由于手上是一块RGB的7寸电容屏，因此，本文重点介绍RGB接口的驱动方法。</p> 
<p>下面这些内容会涉及到比较多的细节，这是因为在具体编写驱动时，会设置LCD控制器和LCD屏的很多参数，这些个参数的具体与硬件的对应关系就在本章节列述。</p> 
<h3><a id="21_LCD_122"></a>2.1 LCD显示系统结构</h3> 
<p>在嵌入式领域，RGB接口的LCD驱动结构一般如下图所示：</p> 
<p>图2.1<br> <img src="https://images2.imgbox.com/5a/30/KnWD3awX_o.png" alt="在这里插入图片描述" width="600"></p> 
<table><thead><tr><th align="center">组件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">SoC</td><td align="left">负责发送显示数据及控制指令等给LCD。</td></tr><tr><td align="center">显 存</td><td align="left">SoC在内存中选一段内存，用来存放颜色数据（应用程序通过往显存中写数据），然后通过配置将LCD控制器和这一段内存连接起来，构成一个映射关系，一旦这个关系建立以后，LCD控制器就会自动从显存中读取像素数据传给LCD驱动器，LCD驱动器会自动的控制每个像素点的液晶分子，以形成最终的图像，建立这个映射以后就不需要SoC再来参与任何行为了。</td></tr><tr><td align="center">LCD控制器</td><td align="left">在SoC内部会集成有LCD控制器，它负责通过数字接口向外部的LCD驱动器提供要显示的像素数字信号。它必须按照一定的时序和LCD驱动器通信，LCD控制器受SoC控制，SoC会从内存中拿出像素数据给LCD控制器并最终传给LCD驱动器。</td></tr><tr><td align="center">LCD驱动器</td><td align="left">LCD驱动器一般与LCD面板集成在一起，面板需要一定的模拟电信号来控制液晶分子，LCD驱动器芯片负责给面板提供控制液晶分子的模拟电信号，驱动器的控制信号（数字信号）来自于LCD控制器的提供的接口。</td></tr></tbody></table> 
<h3><a id="22__137"></a>2.2 基本显示过程</h3> 
<p>LCD显示一张图片，其实是每一个像素点的填充，只是速度很快我们人眼没有察觉而已。<br> <img src="https://images2.imgbox.com/72/ed/TsLIhcvy_o.png" alt="在这里插入图片描述" width="500"></p> 
<ul><li>我们将LCD屏幕分为水平方向和垂直方向</li><li>LCD每一行的像素点被逐一填充，填充完一行继续填充下一行，填充顺序可以为左-&gt;右 或者 右-&gt;左</li><li>每一帧图像，就从第一行的第一个像素点一直填充到最后一行的最后一个像素点。</li><li>例如上图就现实一帧的图像(从左到右，从上到下)。</li></ul> 
<h3><a id="23_LCD_144"></a>2.3 LCD时钟控制</h3> 
<p>时钟是LCD正确工作的核心因素。上面所描述的每个像素的逐一发送，每一行，每一帧的正确发送，都依靠各个时钟的有序运作。其中最基础的是像素时钟。</p> 
<h4><a id="231__148"></a>2.3.1 像素时钟</h4> 
<p><img src="https://images2.imgbox.com/f0/ff/NOtw6yH2_o.png" alt=""></p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>如上图，展示的是一个800*480的RGB LCD屏幕。 24bpp 显示模式（即红绿蓝三色，每色由8bit数位表示）。 显示一行，LCD需要填充800个像素点。每一个像素由RGB三元素组成，每个元素(R、G、B)由8bit位数组成，也就是说一个像素我们需要通过信号线传输24bit的数据。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>如图所示，每一个clk的脉冲，发送一个像素数据。一行共发送800个像素数据。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>像素时钟clk是一个持续的信号，在实际工作中必须还要解决，哪一个CLK代表一行的开始？哪一个CLK代表第一个有效的像素数据？这就需要有水平同步时钟HSYNC。</p> 
<h4><a id="232__HSYNC_154"></a>2.3.2 水平同步时钟 HSYNC</h4> 
<p>HSYNC水平同步信号，表示一行数据的开始。具体如下图<br> <img src="https://images2.imgbox.com/41/f8/cxLIflSZ_o.png" alt="在这里插入图片描述"></p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>其中CLK没有任何变化，只是多了HSYNC和DEN（上图中的ENB）两个信号。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>如图中的红色箭头，当HSYNC产生了如图所示的变化表示新的一行数据传送马上开始，当ENB信号线为高电平期间传输的数据视为有效数据。这样一来，一行800个像素的数据才能正确的传送完成。</p> 
<h4><a id="233___VSYNC_162"></a>2.3.3 显示一帧 - 垂直同步时钟VSYNC</h4> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>按照我们之前假设的800*480LCD。从第一行一直到最后一行，整个LCD屏幕所有像素填充完毕，这一过程也就是写了一帧数据，我们如果要LCD能够实时显示画面，很显然一帧数据肯定不够，所以要给LCD不断的提供新的帧数据，这无非也就是重复上述显示一帧的过程。<br> <img src="https://images2.imgbox.com/40/c3/xQbcsxdU_o.png" alt="在这里插入图片描述"><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>上图中VSYNC垂直同步信号，当产生如图所示的变化，就代表新的一帧数据马上开始传送。那么这里怎么没有有效数据信号DEN呢？？<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>其实很简单，因为新的一帧数据不就是从LCD第一行的第一个像素开始填充嘛，那么前面我们已经说明了每一行都自己的同步信号，而每一行也有对应的数据有效信号线。所以垂直同步信号只用关心从一帧数据的同步，而不同关心每一行的同步。</p> 
<p>于是，我们将上面分析的时钟放在一起，就变成了LCD RGB模式的典型时序图 。</p> 
<h3><a id="24__170"></a>2.4 控制时序</h3> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>时序图完整的描述了几个不同的控制信号之间如何相互协作。以及各个信号之间的工作间隔时间等。对于LCD控制器的寄存器设置的相关参数，也在这个时序图中描述。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>下面这个是一个典型的完整的时序图。</p> 
<p>图2.2<br> <img src="https://images2.imgbox.com/56/bd/Zp15rpFl_o.png" alt="在这里插入图片描述"><br> <strong>控制信号释义：</strong></p> 
<table><thead><tr><th align="left">信号</th><th align="center">名称</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">VD（Video Data)</td><td align="center">数据信号</td><td align="left">用于传输图像的像素数据。每个像素的颜色信息通过VD信号传输。</td></tr><tr><td align="left">HSYNC（Horizontal Sync）</td><td align="center">水平同步信号</td><td align="left">用于同步每行图像数据的传输。每发出一个HSYNC脉冲，表示新的一行图像数据开始发送。</td></tr><tr><td align="left">VSYNC（Vertical Sync）</td><td align="center">垂直同步信号</td><td align="left">用于同步每帧图像数据的传输。每发出一个VSYNC脉冲，表示新的一帧图像数据开始发送。</td></tr><tr><td align="left">VDEN（Video Data Enable）</td><td align="center">数据有效标志</td><td align="left">与HSYNC和VSYNC信号结合使用。VDEN信号表示VD数据的有效性，只有在VDEN为高电平时，VD数据才是有效的。</td></tr><tr><td align="left">LEND（Line End）</td><td align="center">行结束标志</td><td align="left">是一种时序信号，用于表示一行图像数据的结束。不是所有接口都需要使用LEND信号，例如210接口就没有。</td></tr><tr><td align="left">VCLK（Video Clock）</td><td align="center">时钟信号</td><td align="left">用于同步图像数据的传输。VCLK信号的频率决定了图像数据的传输速度。</td></tr></tbody></table> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>想象每个像素点是由电子枪发射出来的，电子枪依次扫描整个LCD界面，就显示了一副完整的图像。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>当发出一个HSYNC信号后，电子枪就会从行末花费HBP时长移动到行首；然后在VCLK时钟下，在下图中阴影区域显示像素；等到了行末后，再等待HFP时长待HSYNC信号到来，再移动到行首，如此往复。因此，HBP和HFP分别决定了左边和右边的黑框。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>同理，当发出一个VSYNC信号后，电子枪就会从列末花费VBP时长移动到列首；然后在VCLK时钟下，在图中阴影区域显示像素；等到了列末后，再等待VFP时长待VSYNC信号到来，再移动到列首，如此往复。因此，VBP和VFP分别决定了上边和下边的黑框。</p> 
<h3><a id="25__LCD_191"></a>2.5 LCD时序与显示的映射关系</h3> 
<p>下图是从LCD控制器的角度理解的显示映射关系：<br> <img src="https://images2.imgbox.com/90/e0/ZHKFaFZf_o.png" alt="在这里插入图片描述"><br> <strong>显示步骤</strong></p> 
<p>为了更好的理解上图，总结成以下几个过程：</p> 
<ul><li>1、产生垂直信号，表示一帧数据将要开始</li><li>2、经过VBP个行后才开始有效数据的第一行 （类似上边距）</li><li>3、经过HBP（具体的数值在后面会解释）个CLK后才开始传输每行的有效数据。（类似调整了A4纸张的左边距）</li><li>4、每行有效数据传输完毕，经过HFP个CLK后才开始下一行。（类似右边距）</li><li>5、重复3和4两个步骤一直到有效行显示完。</li><li>6、有效行显示完毕后，经过VFP个行后再开始下一帧数据 （类似下边距）</li></ul> 
<p>时序参数的含义如下，参照上图理解：</p> 
<table><thead><tr><th align="left">英文缩写</th><th align="center">名称</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">HSPW(Horizontal Sync Pulse Width)</td><td align="center">行同步信号的脉宽</td><td align="left">单位为1VCLK的时间。</td></tr><tr><td align="left">HBP(Horizontal Back Porch)</td><td align="center">水平后肩</td><td align="left">水平同步信号HSYNC的下降沿到VDEN的上升沿的间隔称为HBP。单位为1VCLK的时间。在图中为HBPD+1。</td></tr><tr><td align="left">HFP(Horizontal Front Porch)</td><td align="center">水平前肩</td><td align="left">把VDEN的下降沿到水平同步信号HSYNC的上升沿的间隔称为HFP，单位为1VCLK的时间。在图中为HFPD+1。</td></tr><tr><td align="left">HOZVAL</td><td align="center">行显示尺寸-1，即屏列宽-1</td><td align="left">对于800*480分配率的LCD屏，那么HOZVAL=800-1=799，请记住，是屏列宽，也就是LCD屏显示一行数据所需要的像素(pixel)的数目。</td></tr><tr><td align="left">VSPW(Vertical Sync Pluse Width)</td><td align="center">帧同步信号的脉宽</td><td align="left">单位为1行（Line）的时间。</td></tr><tr><td align="left">VBP(Vertical Back Porch)</td><td align="center">垂直后肩</td><td align="left">垂直同步信号VSYNC下降沿到VDEN信号产生之前的一个行同步信号VHSYNC的上升沿之间隔。单位为1行（Line）的时间。在图中为VBPD+1。</td></tr><tr><td align="left">VFP(Vertical Front Porch)</td><td align="center">垂直前肩</td><td align="left">VDEN数据信号的下降沿到垂直同步信号VSYNC产生的上升沿之间隔。单位为1行（Line）的时间。在图中为VFPD+1。</td></tr><tr><td align="left">LINEVAL</td><td align="center">帧显示尺寸-1，即屏行宽-1</td><td align="left">对于800*480分配率的LCD屏，那么LINEVAL=480-1=479，请记住，是屏行宽，也就是LCD屏显示一帧数据所需要的行的数目。</td></tr></tbody></table> 
<p>VSPW、HSPW这两个值其实很简单，其中的W代表width也就是宽度的意思。所以这两个值分别描述的是垂直信号和水平信号的宽度，如下图所示。<br> <img src="https://images2.imgbox.com/7a/27/yYO1LCf9_o.png" alt="在这里插入图片描述"></p> 
<p><strong>时间计算：</strong><br> 由图2.2可知：</p> 
<ul><li>扫描一帧所需的时间： T = ( ( VSPW+1 ) + ( VBPD + 1 ) + ( LINEVAL + 1) + ( VFPD + 1 ) ) 个行时间。</li><li>扫描一行所所需的时间： = ( ( HSPW + 1 ) + ( HSPD + 1 ) + ( HFPD + 1 ) + ( HOZVAL + 1 ) ) 个VCLK时间。</li></ul> 
<p>而一个VCLK时间由LCD寄存器VIDCON0内的CLKVAL决定:</p> 
<ul><li>VCLK = HCLK / ( CLKVAL + 1 ) ------&gt;这个公式是exynos4412的LCD控制器的，其他CPU的不一定一样</li></ul> 
<p>因此扫描一帧所需的时间：</p> 
<ul><li>T = [(VSPW+1)+(VBPD+1)+(LINEVAL+1)+(VFPD+1)] * [(HSPW+1)+(HSPD+1)+(HFPD+1)+ (HOZVAL+1)] * HCLK/ (CLKVAL+1)</li></ul> 
<p>即帧频率为:1/T</p> 
<h3><a id="26_linuxLCD_239"></a>2.6 linux对LCD时序的抽象</h3> 
<p>下图为从linux角度对lcd时序的理解，这与前面从LCD控制器的角度对lcd时序的理解差别在于hsync_len和vsync_len。这实际是没有区别的，只是理解的角度不同。因要写的是linux的驱动，因此要清楚从linux的角度是如何映射的。<br> <img src="https://images2.imgbox.com/b7/02/7TCmQotr_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>对应如下这个数据结构体：</p> 
<h4><a id="261__struct_fb_videomode___244"></a>2.6.1 struct fb_videomode 显示参数结构体</h4> 
<pre><code class="prism language-c"><span class="token comment">/* include/linux/fb.h */</span>  
<span class="token keyword">struct</span> <span class="token class-name">fb_videomode</span> <span class="token punctuation">{<!-- --></span>  
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>      可选的视频模式名称。这个成员用于存储视频模式的名称，可以是一个字符串。
u32 refresh<span class="token punctuation">;</span>     可选的刷新率。这个成员用于指定视频模式的刷新率，以每秒刷新次数表示。
u32 xres<span class="token punctuation">;</span>  显示的水平分辨率。这个成员表示图像在屏幕上的水平像素数。
u32 yres<span class="token punctuation">;</span>  显示的垂直分辨率。这个成员表示图像在屏幕上的垂直像素数。
u32 pixclock<span class="token punctuation">;</span>  像素时钟频率。这个成员表示像素时钟的频率，用于计算图像的时序。
u32 left_margin<span class="token punctuation">;</span>      <span class="token comment">/*HBP*/</span>  <span class="token string">"  在每行象素数据开始输出前，需要要插入的空闲象素时钟周期数"</span>
u32 right_margin<span class="token punctuation">;</span>     <span class="token comment">/*HFP*/</span>  <span class="token string">"  在每行象素数据结束到LCD行同步时钟脉冲之间，插入的空闲象素时钟数"</span>
u32 upper_margin<span class="token punctuation">;</span>     <span class="token comment">/*VBP*/</span>  <span class="token string">"  在垂直同步脉冲之后，每帧开头前的无效行数"</span>
u32 lower_margin<span class="token punctuation">;</span>     <span class="token comment">/*VFP*/</span>  <span class="token string">"  每帧数据输出结束到下一帧垂直同步时钟周期开始前的无效行数"</span>
u32 hsync_len<span class="token punctuation">;</span>        <span class="token comment">/*HSYNC 或 HPW 或 HWH*/</span> <span class="token string">"  行同步脉宽，水平同步时钟的脉冲宽度"</span>
u32 vsync_len<span class="token punctuation">;</span>        <span class="token comment">/*VSYNC 或 VPW 或 VWH */</span> <span class="token string">"  帧同步脉宽，垂直同步时钟的脉冲宽度"</span>
u32 sync<span class="token punctuation">;</span>                "同步极性设置<span class="token punctuation">,</span>可根据需要设置<span class="token function">FB_SYNC_HOR_HIGH_ACT</span><span class="token punctuation">(</span>水平同步高电平有效<span class="token punctuation">)</span>和
					<span class="token function">FB_SYNC_VERT_HIGH_ACT</span><span class="token punctuation">(</span>垂直同步高电平有效<span class="token punctuation">)</span>"
u32 vmode<span class="token punctuation">;</span>         显示模式。这个成员指定了显示器的模式，例如非隔行模式或隔行模式。
u32 flag<span class="token punctuation">;</span>          标志位。这个成员用于指示视频模式的一些特性和选项，例如是否支持透明度等
<span class="token punctuation">}</span><span class="token punctuation">;</span>  

</code></pre> 
<p><strong>重要参数详解：</strong></p> 
<ul><li>pixclock 像素时钟频率，在时序图上有时称DCLK 、VCLK 、CLK等，都 是一个意思。如：65MHZ的频率，这里要填写pixclock = 65000000。</li><li>sync成员用于指定同步信号的类型，可以是水平同步、垂直同步或两者的组合。</li><li> 
  <ul><li>FB_SYNC_HOR_HIGH_ACT：表示水平同步信号在高电平时激活。在某些视频模式中，需要在高电平时发送水平同步信号。</li></ul> </li><li> 
  <ul><li>FB_SYNC_VERT_HIGH_ACT：表示垂直同步信号在高电平时激活。在某些视频模式中，需要在高电平时发送垂直同步信号。</li></ul> </li><li> 
  <ul><li>FB_SYNC_EXT：表示使用外部同步信号。某些设备可能支持使用外部同步信号而不是内部的同步信号。</li></ul> </li><li> 
  <ul><li>FB_SYNC_COMP_HIGH_ACT：表示复合同步信号在高电平时激活。复合同步信号是基于水平和垂直同步信号组合而成的同步信号。</li></ul> </li><li> 
  <ul><li>FB_SYNC_BROADCAST：表示广播视频时所使用的视频定时信息。在PAL制式下，垂直总行数为144行（渐进扫描）或288行（隔行扫描）；在NTSC制式下，垂直总行数为121行（渐进扫描）或242行（隔行扫描）。</li></ul> </li><li> 
  <ul><li>FB_SYNC_ON_GREEN：表示同步信号发送在绿色通道上。某些视频模式可能需要使用绿色通道来传输同步信号。</li></ul> </li><li>vmode成员用于指定视频模式的类型，可以是以下几种常见的填写方式：</li><li> 
  <ul><li>FB_VMODE_NONINTERLACED：表示非隔行模式，也即渐进扫描模式。在这种模式下，视频图像的每一帧都是通过逐行扫描显示的。<br> - - FB_VMODE_INTERLACED：表示隔行模式，也即隔行扫描模式。在这种模式下，视频图像的每一帧由两个交替的场组成，每个场只显示图像的一半行数，通过交替显示两个场来达到全帧显示的效果。</li></ul> </li><li> 
  <ul><li>FB_VMODE_DOUBLE：表示双帧缓冲模式。在这种模式下，使用两个帧缓冲器来交替渲染显示图像的每一帧，可以减少视频闪烁的效果。</li></ul> </li><li> 
  <ul><li>FB_VMODE_ODD_FLD_FIRST：表示隔行模式下，先显示奇数场。在某些设备上，隔行扫描模式下，可以选择先显示奇数场还是偶数场。</li></ul> </li><li> 
  <ul><li>FB_VMODE_MASK：用于屏蔽其他标志位，只保留视频模式的相关信息。</li></ul> </li><li> 
  <ul><li>FB_VMODE_YWRAP：表示使用y轴环绕而不是滚动。在某些设备上，可以选择使用y轴环绕来显示图像而不是滚动显示。</li></ul> </li><li> 
  <ul><li>FB_VMODE_SMOOTH_XPAN：表示支持平滑的水平滚动。在某些设备上，可以平滑地滚动图像而不是简单地按照整数像素进行滚动。</li></ul> </li><li> 
  <ul><li>FB_VMODE_CONUPDATE：表示不要更新x和y偏移量。在某些设备上，可能希望固定x和y偏移量而不更新它们。</li></ul> </li></ul> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>在使用struct fb_videomode时，可以参考设备文档或相关的驱动程序来确定正确的填写方式。</p> 
<h4><a id="262__HSYNCVSYNCVCLK_VDEN_288"></a>2.6.2 判断 HSYNC,VSYNC,VCLK, VDEN信号是否需要反转</h4> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>在图2.1中可以看到，Soc上的LCD控制器与LCD屏上的LCD驱动器在对信号的理解不一定一样。比如，LCD驱动器会认为某个信号是低电平有效，这可能与LCD控制器发出的信号含义相反。因此，在LINUX驱动程序编写前，必须确定某个LCD控制器发出的信号是否要反转。并对需要反转的信号，要到相应的控制寄存器中去设置。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>要如何判断某个信号是否反转，这就需要对比SOC数据手册中LCD控制的时序图与LCD屏的数据手册的时序图，以此来判断：</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>先看LCD控制器默认情况下送出来的TFT LCD屏的时序图：</p> 
<p>图2.3-exynos4412 lcd控制器输出时序</p> 
<p><img src="https://images2.imgbox.com/64/23/GPA7ZUrC_o.png" alt="在这里插入图片描述"></p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>再来看屏厂的时序图：</p> 
<p>图2.4：LCD屏时序图</p> 
<p><img src="https://images2.imgbox.com/a2/be/coNaTnOa_o.png" alt="在这里插入图片描述"></p> 
<p>从上两图对比，可以看出实验用屏的VSYNC与HSYNC需要反转。</p> 
<p>另外，从屏厂还提供的信号周期表，用来填写驱动的相应结构体和寄存器：</p> 
<p><img src="https://images2.imgbox.com/cd/1d/5xcS4M6Y_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/34/e4/6W0StGX4_o.png" alt="在这里插入图片描述"><br> 以上这两张图，在后面具体讲lcd屏驱动时，需要用到。</p> 
<p>bpp（bits per pixel 像素深度）：表示一个像素的颜色状态需要用几位来表示</p> 
<blockquote> 
 <p>1位：单色显示，只有亮灭之分，常见的如小店招牌<br> 8位：灰度显示，此时能表示256种颜色，这时候显示不了色彩，但是有了黑白明暗的区别<br> 16位：一般是RGB565的颜色分布，即16位色<br> 24位：RGB888的颜色分布，称之为24位真彩<br> 32位：还是RGB888的颜色分布，剩下的8位代表透明度，故称之为ARGB，是目前主流</p> 
</blockquote> 
<h2><a id="3_329"></a>3、实验环境介绍</h2> 
<ul><li>开发板：华清fs4412</li><li>SoC : samsung exynos4412 arm-A9框架</li><li>LCD：7寸电容触摸tft-lcd屏，分辨率1024 x 600</li><li>驱动接口：并行24位RGB接口， 触摸屏I2C接口</li><li>物理接口：40P 间距0.5mm FPC连接器</li><li>linux内核 ： 3.14</li><li>交叉编译环境：arm-linux-gnueabi-</li><li>FPC连接器定义：</li></ul> 
<p><img src="https://images2.imgbox.com/03/8b/MFJRuOJc_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ef/3d/YhxEnFX6_o.png" alt="在这里插入图片描述"></p> 
<ul><li>SoC侧gpio接口定义</li></ul> 
<p><img src="https://images2.imgbox.com/66/15/tjl6o0wG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a5/a3/MP7yXbV1_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1f/da/OItIlbn2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/83/69/AkgEDZi7_o.png" alt="在这里插入图片描述"></p> 
<p>这样，所有的LCD屏与开发板相连接的引脚，都能一一对应到SoC上的GPIO脚上了。</p> 
<ul><li>驱动框架：FrameBuffer帧缓冲驱动框架</li></ul> 
<h2><a id="4_exynos4412LCD_356"></a>4、 exynos4412的LCD控制器相关知识点介绍</h2> 
<p>由于在linux3.14环境中，在实际编写LCD驱动程序中，不仅涉及到上面所介绍的相关lcd的控制原理，也涉及到如何设置LCD控制寄存器的相关。以下是对exynos4412的数据手册《（4412手册完整版）SEC_Exynos 4412 SCP_Users Manual_Ver.0.10.00_Preliminary》摘录与翻译：</p> 
<h3><a id="41__359"></a>4.1 显示控制器介绍</h3> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>exynos4412的LCD驱动程序接口支持三种接口。它们是RGB接口、间接i80接口和用于写回的YUV接口。显示控制器使用多达五个覆盖图像窗口，这些窗口支持各种颜色格式、256级alpha混合、颜色键、x-y位置控制、软滚动和可变窗口大小等。显示控制器支持各种颜色格式，如RGB（1到24BPP）和YCbCr 4:4:4（仅本地总线）。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>您可以对显示控制器进行编程，以支持屏幕上与水平和垂直像素数、数据接口的数据线宽、接口定时和刷新率相关的不同要求。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>显示控制器传输视频数据并生成必要的控制信号，例如RGB_VSYNC、RGB_HSYNC、RGB VCLK、RGB_VDEN、SYS_CS0、SYS_CS1和SYS_WE。除了生成控制信号外，显示控制器还包含视频数据的数据端口（RGB_VD[23:0]和SYS_VD）</p> 
<p><img src="https://images2.imgbox.com/2f/e9/2niyAaRx_o.png" alt="在这里插入图片描述"><br> exynos4412可以支持红框中的三种接口形式。</p> 
<p><strong>控制器的相关特性：</strong><br> Maximum VCLK in RGB Interface 80MHz<br> Video Clock Source: SCLK_FIMD0 for display controller (from CMU module)</p> 
<h3><a id="42__373"></a>4.2 时钟</h3> 
<p><img src="https://images2.imgbox.com/fc/39/pBDQNNbX_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Exynos 4412 SCP时钟生成电路（特殊时钟）- lcd模块时钟：</strong></p> 
<p><img src="https://images2.imgbox.com/3f/f9/OXhfUfrT_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="43__RGB_383"></a>4.3 RGB接口</h3> 
<h4><a id="431__RGB_384"></a>4.3.1 RGB接口控制器</h4> 
<p>显示控制器由VSFR、VDMA、VPRCS、VTIME和视频时钟发生器组成。<br> 要配置显示控制器，VSFR具有</p> 
<ul><li>121个可编程寄存器组</li><li>一个伽玛LUT寄存器组（64个寄存器）</li><li>一个i80命令寄存器组（12个寄存器）</li><li>五个 256 x 32个调色板存储器</li></ul> 
<p>VDMA是一种专用的显示DMA，用于将帧存储器中的视频数据传输到VPRCS。通过使用这种特殊的DMA，您可以在屏幕上显示视频数据，而无需CPU干预。</p> 
<p>VPRCS从VDMA接收视频数据，并通过数据端口（RGB_VD或SYS_VD）将其发送到显示设备（LCD），在将视频数据更改为合适的数据格式后，例如，每像素8位模式（8BPP模式）或每像素16位模式（16BPP模式）。</p> 
<p>VTIME由可编程逻辑组成，以支持不同LCD驱动器中常见的接口时序和速率的可变要求。TIME块生成RGB_VSYNC、RGB_HSYNC、RGB_VCLK、RGB_VDEN、VEN_VSYNC、VEN_HSYNC、VEN_FIELD、VEN_HREF、SYS_CS0、SYS_CS1、SYS_WE等。</p> 
<p>使用显示控制器数据，可以通过设置LCDBLK_CFG寄存器（0x1001_0210）来选择上述数据路径之一。有关更多信息，请参阅“Chapter 12, System Register Controller, for more information.P884”手册。</p> 
<p>VTIME生成用于RGB接口的控制信号，例如RGB_VSYNC、RGB_HSYNC、RGB VDEN和RGB_VCLK信号。在VSFR寄存器中配置VIDTCON0/1/2寄存器时，可以使用这些控制信号。<br> 您可以在VSFR中对显示控制寄存器的配置进行编程。然后，VTIME模块生成支持不同类型显示设备的可编程控制信号。</p> 
<p>RGB_VSYNC信号使LCD行指针从显示器顶部开始。HOZVAL字段和LINEVAL寄存器的配置控制RGB_VSYNC和RGB_HSYNC的脉冲生成。基于这些方程，LCD面板的尺寸决定了HOZVAL和LINEVAL：</p> 
<p><img src="https://images2.imgbox.com/67/03/BbcbChcp_o.png" alt="在这里插入图片描述" width="400"></p> 
<p>VIDCON0寄存器中的CLKVAL字段控制RGB_VCLK信号的速率。</p> 
<p>CLKVAL的最小值为1。有公式：</p> 
<p><img src="https://images2.imgbox.com/95/64/Ilhwsth5_o.png" alt="在这里插入图片描述" width="400"></p> 
<p>其中，SCLK_FIMDx（x=0，1）</p> 
<p>计算帧速率的方程式为：<br> <img src="https://images2.imgbox.com/aa/22/N3egUirE_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="432_RGB_421"></a>4.3.2 RGB接口规范</h4> 
<p>RGB接口规范包括：</p> 
<ul><li>信号</li><li>LCD RGB接口时序</li><li>并行输出</li><li>串行8位输出</li><li>输出配置结构</li></ul> 
<h4><a id="433__431"></a>4.3.3 信号</h4> 
<p><img src="https://images2.imgbox.com/2a/91/OSWiTep5_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="434_LCD_RGB_436"></a>4.3.4 LCD RGB接口时序</h4> 
<p><img src="https://images2.imgbox.com/ac/23/JuxSNieh_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="44__440"></a>4.4 寄存器</h3> 
<p>LCD控制器的使用，全部依赖对其提供的寄存器的设置。因此，在开发lcd驱动程序时，必须根据情况去设置寄存器才能使LCD正常工作。因此，以下对LCD所使用的寄存器进行一一的介绍。</p> 
<h4><a id="441__443"></a>4.4.1 寄存器概况</h4> 
<p>LCD控制器直接操作的寄存器很多，但主要有以下这些。其中的x指代0,1,2…等数值，在使用时要注意区分。</p> 
<p>可用于配置显示控制器的寄存器有：<br> 1.VIDCON0：配置视频输出格式并显示启用/禁用。<br> 2.VIDCON1：指定RGB I/F控制信号。<br> 3.VIDCON2：指定输出数据格式控制。<br> 4.VIDCON3：指定图像增强控制。<br> 5.I80IFCONx：指定CPU接口控制信号。<br> 6.VIDTCONx：配置视频输出时序并确定显示器的大小。<br> 7.WINCONx：指定每个窗口功能设置。<br> 8.VIDOSDxA，VIDOSDxDB：指定窗口位置设置。<br> 9.VIDOSDxC，D：指定屏幕显示（OSD）大小设置。<br> 10.VIDWxALPHA0/1：指定alpha值设置。<br> 11.BLENDEQx：指定混合方程式设置。<br> 12.VIDWxxADDx：指定源映像地址设置。<br> 13.WxKEYCONx：指定颜色键设置寄存器。<br> 14.WxKEYALPHA：指定颜色键alpha值设置。<br> 15.WINxMAP：指定窗口颜色控制。<br> 16.GAMMALUT_xx：指定伽玛值设置。<br> 17.COLORGAINCON：指定颜色增益值设置。<br> 18.HUExxx：指定色调系数和偏移值设置。<br> 19.WPALCON：指定调色板控制寄存器。<br> 20.WxRTQOSCON：指定RTQoS控制寄存器。<br> 21.WxPDATAxx：指定每个索引的窗口选项板数据。<br> 22.SHDOWCON：指定卷影控制寄存器。<br> 23.WxRTQOSCON：指定QoS控制寄存器。</p> 
<h4><a id="442__472"></a>4.4.2 寄存器使用详述</h4> 
<p>这些详细说明的寄存器，都是在LCD驱动中要用到的。</p> 
<h5><a id="4422__475"></a>4.4.2.2 时钟寄存器</h5> 
<p>时钟寄存器是属于系统的时钟的部分，其中涉及到LCD的部分时钟寄存器如下表，基地址为0x1003_C000:<br> <img src="https://images2.imgbox.com/f2/3e/e4toYBfa_o.png" alt="在这里插入图片描述"><br> 以下为必须要用到的寄存器的详细用法。</p> 
<h6><a id="CLK_SRC_LCD0______P505_480"></a>CLK_SRC_LCD0 （P505）</h6> 
<p>Base Address: 0x1003_0000<br> Address = Base Address + 0xC234, Reset Value = 0x0000_1111<br> 作用：为LCD_BLK选择时钟源</p> 
<p><img src="https://images2.imgbox.com/65/08/ij1Qb3mh_o.png" alt="在这里插入图片描述"></p> 
<p>这些设置值，即设置时钟源，时钟源对应的连接图如下：<br> <img src="https://images2.imgbox.com/7e/85/kAbdKiXw_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="CLK_SRC_MASK_LCD_492"></a>CLK_SRC_MASK_LCD</h6> 
<p>Base Address: 0x1003_0000<br> Address = Base Address + 0xC334, Reset Value = 0x0000_1111<br> 作用：LCD BLK的时钟源掩码。如果希望使用外部时钟源来驱动LCD控制器，可以设置CLK_SRC_MASK_LCD寄存器的相应位为1，将其它位设置为0<br> <img src="https://images2.imgbox.com/99/40/ddHtjoN8_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="CLK_DIV_LCD__P530_497"></a>CLK_DIV_LCD （P530）</h6> 
<p>Base Address: 0x1003_0000<br> Address = Base Address + 0xC534, Reset Value = 0x0070_0000<br> 作用：设置LCD BLK的时钟分频比<br> <img src="https://images2.imgbox.com/2c/19/LqzOcY1b_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="CLK_GATE_IP_LCD__P556_503"></a>CLK_GATE_IP_LCD (P556)</h6> 
<p>Base Address: 0x1003_0000<br> Address = Base Address + 0xC934, Reset Value = 0xFFFF_FFFF<br> 作用：控制LCD BLK的IP时钟门控。设置为1时，表示使能LCD控制器的时钟；设置为0时，表示关闭LCD控制器的时钟。<br> <img src="https://images2.imgbox.com/0f/be/BdhPq5n5_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4423__510"></a>4.4.2.3 系统寄存器</h5> 
<h6><a id="LCDBLK_CFG__P884_511"></a>LCDBLK_CFG (P884)</h6> 
<p>Base Address: 0x1001_0000<br> Address = Base Address + 0x0210, Reset Value = 0x00F8_0000</p> 
<p><img src="https://images2.imgbox.com/00/3b/zhhOiuRD_o.png" alt="在这里插入图片描述"><br> 寄存器lcdblk_cfg是Exynos4412芯片中与LCD控制器背光控制相关的寄存器。该寄存器用于配置和控制LCD控制器背光的工作方式和参数。</p> 
<ul><li>fimdbypass_lblk0: 用于配置背光控制是否绕过FIMD（Framebuffer Interface Module Display）模块。设置为1时，表示绕过FIMD模块，背光控制由外部电路或外部控制器进行；设置为0时，表示背光控制由FIMD模块进行。</li></ul> 
<h6><a id="LCDBLK_CFG2_P886_522"></a>LCDBLK_CFG2 （P886）</h6> 
<p>Base Address: 0x1001_0000<br> Address Base Address + 0x0214, Reset Value = 0x0000_0001</p> 
<p><img src="https://images2.imgbox.com/d6/0b/Y0au1Apc_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4424_LCD_529"></a>4.4.2.4 LCD控制寄存器</h5> 
<h6><a id="VIDCON0__P1838_531"></a>VIDCON0 （P1838）</h6> 
<p>Base Address = 0x11C0_0000<br> Address = Base Address + 0x0000, Reset Value = 0x0000_0000</p> 
<p><img src="https://images2.imgbox.com/ad/55/6ZGLBNoC_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="VIDCON1__P1839_537"></a>VIDCON1 (P1839)</h6> 
<p>Base Address = 0x11C0_0000<br> Address = Base Address + 0x0004, Reset Value = 0x0000_0000</p> 
<p><img src="https://images2.imgbox.com/6e/7a/DkX9hR1P_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="VIDTCON0___P1842_544"></a>VIDTCON0 (P1842)</h6> 
<p>Base Address = 0x11C0_0000<br> Address = Base Address + 0x0010, Reset Value = 0x0000_0000</p> 
<p><img src="https://images2.imgbox.com/4f/88/QLmlCPh4_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="VIDTCON1_551"></a>VIDTCON1</h6> 
<p>Base Address = 0x11C0_0000<br> Address = Base Address + 0x0014, Reset Value = 0x0000_0000</p> 
<p><img src="https://images2.imgbox.com/b9/e0/4ksE7fk8_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="VIDTCON2__P1843_557"></a>VIDTCON2 (P1843)</h6> 
<p>Base Address = 0x11C0_0000<br> Address = Base Address + 0x0018, Reset Value = 0x0000_0000</p> 
<p><img src="https://images2.imgbox.com/e1/f7/e5WQsf4O_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="VIDTCON3_P1843_564"></a>VIDTCON3 (P1843)</h6> 
<p>Base Address = 0x11C0_0000<br> Address = Base Address + 0x001C, Reset Value = 0x0000_0000</p> 
<p><img src="https://images2.imgbox.com/2d/f9/G7sCGTd2_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="WINCON0__P1844_571"></a>WINCON0 (P1844)</h6> 
<p>Base Address = 0x11C0_0000<br> Address = Base Address + 0x0020, Reset Value = 0x0000_0000</p> 
<p><img src="https://images2.imgbox.com/5b/cf/y4PmQZAW_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/82/a2/9KH0vxG0_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c4/cc/BenBfeaG_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="SHADOWCON____P1859_582"></a>SHADOWCON (P1859)</h6> 
<p>Base Address = 0x11C0_0000<br> Address = Base Address + 0x0034, Reset Value = 0x0000_0000<br> <img src="https://images2.imgbox.com/90/9b/4jzZCJw3_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="WINCHMAP2_588"></a>WINCHMAP2</h6> 
<p>Base Address = 0x11C0_0000<br> Address = Base Address + 0x003C, Reset Value = 0x7D51_7D51</p> 
<p><img src="https://images2.imgbox.com/e0/e5/3PWQA1gw_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e5/b5/KRsRou3b_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="VIDOSD0A____VIDOSD0B___VIDOSD0CP1863_597"></a>VIDOSD0A VIDOSD0B VIDOSD0C（P1863）</h6> 
<pre><code>VIDOSD0A：用于配置视频显示层0的位置和大小。通过设置该寄存器的位字段，可以指定视频显示层0在屏幕上的位置和大小。 •	
VIDOSD0B：用于配置视频显示层0的颜色控制。通过设置该寄存器的位字段，可以调整视频显示层0的颜色属性，例如亮度、对比度、饱和度等。 •	
VIDOSD0C：用于配置视频显示层0的混合模式和透明度。通过设置该寄存器的位字段，可以指定视频显示层0的混合模式（例如覆盖、叠加等）以及透明度。 这些寄存器的区别在于它们分别用于配置视频显示层的不同方面。VIDOSD0A用于配置位置和大小，VIDOSD0B用于配置颜色控制，VIDOSD0C用于配置混合模式和透明度。
</code></pre> 
<p><img src="https://images2.imgbox.com/8e/f7/Ks6YHnVm_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4425___609"></a>4.4.2.5 电源管理寄存器</h5> 
<h6><a id="9_LCD0_CONFIGURATION_611"></a>9 LCD0_CONFIGURATION</h6> 
<p>Base Address: 0x1002_0000<br> Address = Base Address + 0x3C80, Reset Value = 0x0000_0007<br> 作用：配置LCD0的电源模式</p> 
<p><img src="https://images2.imgbox.com/b4/f7/4sPEl2hG_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="5_618"></a>5、结语</h2> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
       
      
        \qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>到此，有了以上的知识准备，接下来就可以开始进行LCD驱动程序的开发了。在下一篇中，我们将讲述linux3.14中的LCD驱动的FrameBuffer框架相关内容。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed703be9f9cf16a06414ce5cc7a192b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微服务间消息传递</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/51d3860a9c7867afd4e6b1655c5c7aa8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Focal and Global Knowledge Distillation for Detectors（CVPR 2022）原理与代码解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>