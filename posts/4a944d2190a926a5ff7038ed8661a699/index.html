<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【游戏开发教程】Unity Cinemachine快速上手，详细案例讲解（虚拟相机系统 | 新发出品 | 良心教程） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【游戏开发教程】Unity Cinemachine快速上手，详细案例讲解（虚拟相机系统 | 新发出品 | 良心教程）" />
<meta property="og:description" content="文章目录 一、前言二、插件下载三、案例1：第三人称自由视角，Free Look character场景1、场景演示2、组件参数2.1、CinemachineBrain：核心2.2、CinemachineFreeLook：第三人称自由视角相机2.2.1、设置Follow：跟随2.2.2、设置LookAt：朝向2.2.3、三个圆环轨道：环绕约束2.2.4、圆环轨道之间的连接曲线：Spline Curvature2.2.5、相机移动策略，移动阻尼：Body Y/Z Damping2.2.6、相机旋转策略，瞄准：Aim2.2.7、瞄准偏移：Tracked Object Offset2.2.8、预测：Lookahead2.2.8、瞄准阻尼：Horizontal/Vertical Damping2.2.9、画面构图（重要） 2.3、小结 3、用代码控制相机移动（绕圆环旋转） 四、案例2：相机避障不穿墙，Free Look collider场景1、场景演示2、组件参数2.1、CinemachineCollider：相机碰撞2.1.1、Add Extension拓展2.1.2、Collide Against：被认定为障碍物的Layer2.1.3、Ignore Tag：忽略碰撞检测的Tag2.1.4、Transparent Layers：透明层2.1.5、Minimum Distance From Target：与目标的最小距离2.1.6、Avoid Obstacles：是否避开障碍物2.1.7、Distance Limit：碰撞检测的射线长度2.1.8、Camera Radius：相机半径2.1.9、Strategy：避障策略2.1.10、Maximum Effort：一次可处理的最多的障碍物数量2.1.11、Smoothing Time：相机移动的平滑时间2.1.12、Damping：避障后相机恢复位置的阻尼2.1.12、Damping When Occluded：避障时的相机阻尼 五、案例3：简单追踪，FollowCam Simple Follow场景1、场景演示2、组件参数2.1、CinemachineVirtualCamera：虚拟相机2.1.1、Follow与LookAt：追踪目标2.1.2、Binding Mode：Body绑定模式1、Lock To Target On Assign 模式（常用）2、Lock To Target With World Up 模式3、Lock To Target No Roll 模式4、Lock To Target 模式5、World Space 模式6、Simple Follow With World Up 模式 六、案例4：动画状态驱动自由视角，StateDrivenCamera场景1、场景演示2、组件参数2.1、CinemachineStateDrivenCamera：状态驱动虚拟相机2.1.1、父节点：CinemachineStateDrivenCamera2.1.2、子节点：多个虚拟相机2.1.3、设置Animated Target2.1.4、设置State 七、案例5：分镜/切镜，ClearShot场景1、场景演示1.1、ClearShot场景1.2、ClearShot closest场景1.2、ClearShot character场景 2、组件参数2.1、CinemachineClearShot：自动选择/切换最适合的摄像头2.2、CinemachineBlendListCamera：虚拟相机过渡/混合器2.3、CinemachineTriggerAction：虚拟相机触发器2.3.1、碰撞体勾选Is Trigger2.3.2、设置过滤2.3.3、设置Skip First2.3.4、设置On Object Enter响应 八、案例6：多目标追踪，Dolly Group场景1、场景演示2、组件参数 九、其他案例1、打BOSS视角：BossCam场景2、双重目标：DualTarget场景3、近物透明，FadeOutNearbyObjects场景4、第三人称瞄准，3rdPersonWithAimMode场景5、镜头震动，Impulse场景 十、完毕 一、前言 嗨，大家好，我是新发。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4a944d2190a926a5ff7038ed8661a699/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-04T09:13:20+08:00" />
<meta property="article:modified_time" content="2022-05-04T09:13:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【游戏开发教程】Unity Cinemachine快速上手，详细案例讲解（虚拟相机系统 | 新发出品 | 良心教程）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/c2/ff/sPu2oAgC_o.gif" alt="请添加图片描述" width="800"></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#_4" rel="nofollow">一、前言</a></li><li><a href="#_17" rel="nofollow">二、插件下载</a></li><li><a href="#1Free_Look_character_27" rel="nofollow">三、案例1：第三人称自由视角，Free Look character场景</a></li><li><ul><li><a href="#1_28" rel="nofollow">1、场景演示</a></li><li><a href="#2_37" rel="nofollow">2、组件参数</a></li><li><ul><li><a href="#21CinemachineBrain_38" rel="nofollow">2.1、CinemachineBrain：核心</a></li><li><a href="#22CinemachineFreeLook_41" rel="nofollow">2.2、CinemachineFreeLook：第三人称自由视角相机</a></li><li><ul><li><a href="#221Follow_45" rel="nofollow">2.2.1、设置Follow：跟随</a></li><li><a href="#222LookAt_54" rel="nofollow">2.2.2、设置LookAt：朝向</a></li><li><a href="#223_61" rel="nofollow">2.2.3、三个圆环轨道：环绕约束</a></li><li><a href="#224Spline_Curvature_71" rel="nofollow">2.2.4、圆环轨道之间的连接曲线：Spline Curvature</a></li><li><a href="#225Body_YZ_Damping_78" rel="nofollow">2.2.5、相机移动策略，移动阻尼：Body Y/Z Damping</a></li><li><a href="#226Aim_94" rel="nofollow">2.2.6、相机旋转策略，瞄准：Aim</a></li><li><a href="#227Tracked_Object_Offset_115" rel="nofollow">2.2.7、瞄准偏移：Tracked Object Offset</a></li><li><a href="#228Lookahead_122" rel="nofollow">2.2.8、预测：Lookahead</a></li><li><a href="#228HorizontalVertical_Damping_145" rel="nofollow">2.2.8、瞄准阻尼：Horizontal/Vertical Damping</a></li><li><a href="#229_155" rel="nofollow">2.2.9、画面构图（重要）</a></li></ul> 
      </li><li><a href="#23_183" rel="nofollow">2.3、小结</a></li></ul> 
     </li><li><a href="#3_185" rel="nofollow">3、用代码控制相机移动（绕圆环旋转）</a></li></ul> 
    </li><li><a href="#2Free_Look_collider_222" rel="nofollow">四、案例2：相机避障不穿墙，Free Look collider场景</a></li><li><ul><li><a href="#1_223" rel="nofollow">1、场景演示</a></li><li><a href="#2_232" rel="nofollow">2、组件参数</a></li><li><ul><li><a href="#21CinemachineCollider_233" rel="nofollow">2.1、CinemachineCollider：相机碰撞</a></li><li><ul><li><a href="#211Add_Extension_236" rel="nofollow">2.1.1、Add Extension拓展</a></li><li><a href="#212Collide_AgainstLayer_244" rel="nofollow">2.1.2、Collide Against：被认定为障碍物的Layer</a></li><li><a href="#213Ignore_TagTag_247" rel="nofollow">2.1.3、Ignore Tag：忽略碰撞检测的Tag</a></li><li><a href="#214Transparent_Layers_250" rel="nofollow">2.1.4、Transparent Layers：透明层</a></li><li><a href="#215Minimum_Distance_From_Target_266" rel="nofollow">2.1.5、Minimum Distance From Target：与目标的最小距离</a></li><li><a href="#216Avoid_Obstacles_268" rel="nofollow">2.1.6、Avoid Obstacles：是否避开障碍物</a></li><li><a href="#217Distance_Limit_270" rel="nofollow">2.1.7、Distance Limit：碰撞检测的射线长度</a></li><li><a href="#218Camera_Radius_272" rel="nofollow">2.1.8、Camera Radius：相机半径</a></li><li><a href="#219Strategy_274" rel="nofollow">2.1.9、Strategy：避障策略</a></li><li><a href="#2110Maximum_Effort_291" rel="nofollow">2.1.10、Maximum Effort：一次可处理的最多的障碍物数量</a></li><li><a href="#2111Smoothing_Time_294" rel="nofollow">2.1.11、Smoothing Time：相机移动的平滑时间</a></li><li><a href="#2112Damping_307" rel="nofollow">2.1.12、Damping：避障后相机恢复位置的阻尼</a></li><li><a href="#2112Damping_When_Occluded_311" rel="nofollow">2.1.12、Damping When Occluded：避障时的相机阻尼</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#3FollowCam_Simple_Follow_315" rel="nofollow">五、案例3：简单追踪，FollowCam Simple Follow场景</a></li><li><ul><li><a href="#1_316" rel="nofollow">1、场景演示</a></li><li><a href="#2_324" rel="nofollow">2、组件参数</a></li><li><a href="#21CinemachineVirtualCamera_325" rel="nofollow">2.1、CinemachineVirtualCamera：虚拟相机</a></li><li><ul><li><a href="#211FollowLookAt_328" rel="nofollow">2.1.1、Follow与LookAt：追踪目标</a></li><li><a href="#212Binding_ModeBody_331" rel="nofollow">2.1.2、Binding Mode：Body绑定模式</a></li><li><ul><li><a href="#1Lock_To_Target_On_Assign__340" rel="nofollow">1、Lock To Target On Assign 模式（常用）</a></li><li><a href="#2Lock_To_Target_With_World_Up__359" rel="nofollow">2、Lock To Target With World Up 模式</a></li><li><a href="#3Lock_To_Target_No_Roll__375" rel="nofollow">3、Lock To Target No Roll 模式</a></li><li><a href="#4Lock_To_Target__388" rel="nofollow">4、Lock To Target 模式</a></li><li><a href="#5World_Space__403" rel="nofollow">5、World Space 模式</a></li><li><a href="#6Simple_Follow_With_World_Up__416" rel="nofollow">6、Simple Follow With World Up 模式</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#4StateDrivenCamera_436" rel="nofollow">六、案例4：动画状态驱动自由视角，StateDrivenCamera场景</a></li><li><ul><li><a href="#1_437" rel="nofollow">1、场景演示</a></li><li><a href="#2_447" rel="nofollow">2、组件参数</a></li><li><ul><li><a href="#21CinemachineStateDrivenCamera_450" rel="nofollow">2.1、CinemachineStateDrivenCamera：状态驱动虚拟相机</a></li><li><a href="#211CinemachineStateDrivenCamera_451" rel="nofollow">2.1.1、父节点：CinemachineStateDrivenCamera</a></li><li><a href="#212_454" rel="nofollow">2.1.2、子节点：多个虚拟相机</a></li><li><a href="#213Animated_Target_457" rel="nofollow">2.1.3、设置Animated Target</a></li><li><a href="#214State_461" rel="nofollow">2.1.4、设置State</a></li></ul> 
    </li></ul> 
    </li><li><a href="#5ClearShot_466" rel="nofollow">七、案例5：分镜/切镜，ClearShot场景</a></li><li><ul><li><a href="#1_480" rel="nofollow">1、场景演示</a></li><li><ul><li><a href="#11ClearShot_481" rel="nofollow">1.1、ClearShot场景</a></li><li><a href="#12ClearShot_closest_498" rel="nofollow">1.2、ClearShot closest场景</a></li><li><a href="#12ClearShot_character_510" rel="nofollow">1.2、ClearShot character场景</a></li></ul> 
     </li><li><a href="#2_520" rel="nofollow">2、组件参数</a></li><li><ul><li><a href="#21CinemachineClearShot_521" rel="nofollow">2.1、CinemachineClearShot：自动选择/切换最适合的摄像头</a></li><li><a href="#22CinemachineBlendListCamera_535" rel="nofollow">2.2、CinemachineBlendListCamera：虚拟相机过渡/混合器</a></li><li><a href="#23CinemachineTriggerAction_558" rel="nofollow">2.3、CinemachineTriggerAction：虚拟相机触发器</a></li><li><ul><li><a href="#231Is_Trigger_574" rel="nofollow">2.3.1、碰撞体勾选Is Trigger</a></li><li><a href="#232_580" rel="nofollow">2.3.2、设置过滤</a></li><li><a href="#233Skip_First_585" rel="nofollow">2.3.3、设置Skip First</a></li><li><a href="#234On_Object_Enter_590" rel="nofollow">2.3.4、设置On Object Enter响应</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#6Dolly_Group_610" rel="nofollow">八、案例6：多目标追踪，Dolly Group场景</a></li><li><ul><li><a href="#1_611" rel="nofollow">1、场景演示</a></li><li><a href="#2_617" rel="nofollow">2、组件参数</a></li></ul> 
    </li><li><a href="#_624" rel="nofollow">九、其他案例</a></li><li><ul><li><ul><li><a href="#1BOSSBossCam_626" rel="nofollow">1、打BOSS视角：BossCam场景</a></li><li><a href="#2DualTarget_628" rel="nofollow">2、双重目标：DualTarget场景</a></li><li><a href="#3FadeOutNearbyObjects_630" rel="nofollow">3、近物透明，FadeOutNearbyObjects场景</a></li><li><a href="#43rdPersonWithAimMode_632" rel="nofollow">4、第三人称瞄准，3rdPersonWithAimMode场景</a></li><li><a href="#5Impulse_637" rel="nofollow">5、镜头震动，Impulse场景</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_641" rel="nofollow">十、完毕</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="_4"></a>一、前言</h4> 
<p>嗨，大家好，我是新发。<br> 相信很多同学都用过<code>Unity</code>的<code>Cinemachine</code>插件，使用它可以很方便地实现一些摄像机效果，比如摄像机追踪、推拉镜头、分镜等效果。<br> 插件提供了很多场景案例，大家可以看下插件的官方文档：<br> <a href="https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineUsing.html" rel="nofollow">https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineUsing.html</a></p> 
<p>趁五一假期有时间，我准备对插件里的案例场景进行讲解，方便大家快速上手，希望大家学以致用。</p> 
<p>提示：本文内容较长，建议收藏后使用电脑观看。</p> 
<blockquote> 
 <p>注：本文使用的<code>Unity</code>版本为<code>2021.3.1f1c1</code>，<code>Cinemachine</code>版本为<code>2.8.4</code></p> 
</blockquote> 
<h4><a id="_17"></a>二、插件下载</h4> 
<p>在<code>PackageManager</code>中搜索<code>Cinemachine</code>，点击<code>Install</code>安装即可，<br> <img src="https://images2.imgbox.com/e9/e3/5AHKJvPI_o.png" alt="在这里插入图片描述"><br> 本文我要讲解插件的案例，所以需要把<code>Samples</code>也引入到工程中，点击<code>Samples</code>的<code>Import</code>按钮，<br> <img src="https://images2.imgbox.com/d9/95/mQNU5Im1_o.png" alt="在这里插入图片描述"><br> 完成后我们就可以在工程中看到<code>Cinemachine</code>的插件包和案例包了，如下<br> <img src="https://images2.imgbox.com/ad/99/rY7OnAqK_o.png" alt="在这里插入图片描述"><br> 现在我们开始吧~</p> 
<blockquote> 
 <p>注：本文讲解的案例顺序不是按照目录顺序，而是根据常用程度进行排序</p> 
</blockquote> 
<h4><a id="1Free_Look_character_27"></a>三、案例1：第三人称自由视角，Free Look character场景</h4> 
<h5><a id="1_28"></a>1、场景演示</h5> 
<p>双击打开<code>Free Look character</code>场景，<br> <img src="https://images2.imgbox.com/80/51/RqQQngFK_o.png" alt="在这里插入图片描述"><br> 这是第三人称自由视角的摄像机效果，如下<br> <img src="https://images2.imgbox.com/62/d3/lKkFY2PS_o.gif" alt="请添加图片描述" width="800"><br> 画个图</p> 
<p><img src="https://images2.imgbox.com/5d/17/m6UoRaOQ_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_37"></a>2、组件参数</h5> 
<h6><a id="21CinemachineBrain_38"></a>2.1、CinemachineBrain：核心</h6> 
<p>主摄像机上挂<code>CinemachineBrain</code>组件，参数默认即可，它是整个虚拟相机系统的核心，<br> <img src="https://images2.imgbox.com/87/82/dX7YWffH_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="22CinemachineFreeLook_41"></a>2.2、CinemachineFreeLook：第三人称自由视角相机</h6> 
<p><code>CM FreeLook1</code>节点上挂了<code>CinemachineFreeLook</code>组件，它实现了第三人称自由视角的相机逻辑，是非常常用的一个相机功能，<br> <img src="https://images2.imgbox.com/7c/83/rUx6ahoG_o.png" alt="在这里插入图片描述"><br> 下面我介绍一下这个组件的参数设置。</p> 
<h6><a id="221Follow_45"></a>2.2.1、设置Follow：跟随</h6> 
<p>我们需要设置追踪的目标物体，这里设置追踪的目标是主角的<code>Root</code>节点，<br> <img src="https://images2.imgbox.com/0a/b2/aghEby98_o.png" alt="在这里插入图片描述"><br> 如下<br> <img src="https://images2.imgbox.com/9b/63/6z2I7vmI_o.png" alt="在这里插入图片描述"><br> 设置了<code>Follow</code>对象，摄像机就会跟着追踪的对象移动了。<br> <img src="https://images2.imgbox.com/fa/22/2oc18NL0_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="222LookAt_54"></a>2.2.2、设置LookAt：朝向</h6> 
<p>设置<code>LookAt</code>，可以让相机角度始终朝着目标的方向，这里设置的是看向主角的头，<br> <img src="https://images2.imgbox.com/13/e4/NIdsv6pD_o.png" alt="在这里插入图片描述"><br> 如下<br> <img src="https://images2.imgbox.com/b3/6f/k5kVarcg_o.png" alt="在这里插入图片描述"><br> 我们可以看到相机的<code>Z</code>轴（蓝色的那根轴）始终朝着主角的头，<br> <img src="https://images2.imgbox.com/1c/fe/mO4vYJS1_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="223_61"></a>2.2.3、三个圆环轨道：环绕约束</h6> 
<p>摄像机围绕主角环绕的范围是由三个圆环轨道决定的，如下<br> <img src="https://images2.imgbox.com/99/f6/0JQLjihV_o.png" alt="在这里插入图片描述"><br> 我们可以调整这三个圆环轨道的高度和半径，如下<br> <img src="https://images2.imgbox.com/6b/0d/Sqh0XOvm_o.png" alt="在这里插入图片描述"><br> 如下<br> <img src="https://images2.imgbox.com/a0/e3/XqutGSHP_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="224Spline_Curvature_71"></a>2.2.4、圆环轨道之间的连接曲线：Spline Curvature</h6> 
<p>三个圆环之间有一根连接的曲线，它是摄像机在竖直方向上移动的约束，你可以把它想象成就是一根弯曲的杆子，在它对面有一根形状与它一样的隐形的杆子，相机只能在这根隐形的杆子上移动，<br> <img src="https://images2.imgbox.com/d2/8c/JqBgV8Qb_o.png" alt="在这里插入图片描述"><br> 我们可以调节<code>Spline Curvature</code>来调整这根连接杆的弯曲程度，<br> <img src="https://images2.imgbox.com/74/3a/UYEsi1TH_o.png" alt="在这里插入图片描述"><br> 如下<br> <img src="https://images2.imgbox.com/d8/7d/97JwMmDx_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="225Body_YZ_Damping_78"></a>2.2.5、相机移动策略，移动阻尼：Body Y/Z Damping</h6> 
<p>我们有三个圆环轨道，分别对应三个机位视角：顶部机位、中部机位、底部机位，<br> <img src="https://images2.imgbox.com/95/78/xPsb0dCL_o.png" alt="在这里插入图片描述"><br> 我们可以调整每个机位的相机移动阻尼、画面构图等，以<code>Middle Rig</code>中部机位为例，<br> 我们可以调整相机跟随的移动阻尼，阻尼越大，跟随速度越慢，<br> <img src="https://images2.imgbox.com/a3/5a/KobwD4qi_o.png" alt="在这里插入图片描述"><br> <code>Y Damping</code>用于控制相机在竖直方向上的跟随阻尼，比如角色跳跃的时候，相机也会跟着在竖直方向上 “跳”，相机的 “跳” 会受到这个<code>Y Damping</code>阻尼影响。<br> 同理，<code>Z Damping</code>控制垂直于屏幕方向移动的阻尼，比如角色往垂直于屏幕的方向走，相机也跟着往前，相机在这个方向上的跟随受到<code>Z Damping</code>阻尼的影响。</p> 
<blockquote> 
 <p>注：阻尼可以减少由于相机速度过快而出现画面抖动的效果。<br> 阻尼为 0 会显得跟随很僵硬，可能出现画面抖动；阻尼过大则会导致相机跟随太慢，跟不上主角。</p> 
</blockquote> 
<p>我调整<code>Z Damping</code>给大家演示一下，首先看下<code>Z Damping</code>为<code>1</code>时的效果，<br> <img src="https://images2.imgbox.com/c2/68/KfP5Znci_o.gif" alt="请添加图片描述" width="800"></p> 
<p>接着我把<code>Z Damping</code>阻尼调大到<code>20</code>，可以看到相机跟随已经跟不上主角的移动了，特别是主角跑起来的时候，建议保持默认的<code>1</code>即可，<br> <img src="https://images2.imgbox.com/fa/86/tHOrDllh_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="226Aim_94"></a>2.2.6、相机旋转策略，瞄准：Aim</h6> 
<p>展开<code>Aim</code>下拉按钮，<br> <img src="https://images2.imgbox.com/57/db/PGwMYxIG_o.png" alt="在这里插入图片描述"></p> 
<p>我们可以在<code>Game</code>试图中看到出现了一些线和一些区域块，如下，它是通过约束相机的<mark>旋转</mark>来达到让瞄准的物体显示在画面区域内的，<br> <img src="https://images2.imgbox.com/23/08/a85Vmba0_o.png" alt="在这里插入图片描述"><br> 如果你没有显示上面的线和区域，检查一下<code>Game Window Guides</code>是否是勾选状态，<br> <img src="https://images2.imgbox.com/53/b7/ZDsWXCUa_o.png" alt="在这里插入图片描述"><br> 我们可以切换瞄准的策略，默认是<code>Composer</code>，<br> <img src="https://images2.imgbox.com/91/a1/FdgueP8I_o.png" alt="在这里插入图片描述"><br> 每种瞄准策略含义如下</p> 
<table><thead><tr><th align="left">瞄准策略</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Composer</td><td align="left">将目标保持在相机镜头内，可以设置多种约束</td></tr><tr><td align="left">Group Composer</td><td align="left">将多个目标保持在相机镜头内</td></tr><tr><td align="left">Hard Look At</td><td align="left">将Look At目标固定在镜头中心的位置</td></tr><tr><td align="left">POV</td><td align="left">根据用户的输入旋转相机</td></tr><tr><td align="left">Same As Follow Target</td><td align="left">将相机的旋转和跟随目标的旋转同步</td></tr></tbody></table> 
<p>下面以<code>Composer </code>策略为例，介绍一下各个参数的用途。</p> 
<h6><a id="227Tracked_Object_Offset_115"></a>2.2.7、瞄准偏移：Tracked Object Offset</h6> 
<p><code>Tracked Object Offset相</code>参数控制对于跟踪目标的偏移，比如我们<code>Look At</code>的目标是<code>Head</code>节点，但是这个节点与主角的真实头部偏了一些，我们就可以通过调整<code>Tracked Object Offset</code>来校准瞄准的位置，</p> 
<p><img src="https://images2.imgbox.com/81/78/OaRs8aoi_o.png" alt="在这里插入图片描述"><br> 如下<br> <img src="https://images2.imgbox.com/32/27/oyH2KPez_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="228Lookahead_122"></a>2.2.8、预测：Lookahead</h6> 
<p><img src="https://images2.imgbox.com/77/af/clD7pPf0_o.png" alt="在这里插入图片描述"></p> 
<table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Lookahead Time</td><td align="left">预测提前的秒数，默认为0，如果大于0，会预测目标的位置，如果主角移动速度很快，可以适当进行预测，如果主角移动速度不快，但开启了预测，可能会导致相机抖动</td></tr><tr><td align="left">Lookahead Smoothing</td><td align="left">预测算法的平滑度，提高平滑度可以减少预测抖动，但会导致预测滞后</td></tr><tr><td align="left">Lookahead ignore Y</td><td align="left">预测算法会忽略Y轴的移动</td></tr></tbody></table> 
<p>我们把<code>Lookahead Time</code>调大到<code>1</code>，<br> <img src="https://images2.imgbox.com/47/0a/ADyWe1d6_o.png" alt="在这里插入图片描述"><br> 效果如下，可以看到，过度预测导致了相机的抖动，<br> <img src="https://images2.imgbox.com/21/b4/QOglyBgU_o.gif" alt="请添加图片描述" width="800"><br> 我们保持<code>1</code>秒<code>Lookahead Time</code>，此时我们把<code>Lookahead Smoothing</code>调大到<code>8</code>，<br> <img src="https://images2.imgbox.com/76/2b/kpIbGcZA_o.png" alt="在这里插入图片描述"><br> 效果如下，可以看到，相机提前预测了目标位置，抖动平滑了一些，但是由于我们的主角移动速度并不快，预测导致相机超前，最后还得折返回来，所以这里我们没有必要开启预测。<br> 如果你的项目的主角是飞机，飞行速度快，则可以考虑开启预测。<br> <img src="https://images2.imgbox.com/ac/3c/xF2FXjIz_o.gif" alt="请添加图片描述" width="800"></p> 
<p><code>Lookahead Ignore Y</code>就是忽略<code>Y</code>轴方向上的预测，比如跳跃动作，我们不想让相机做<code>Y</code>轴上的预测，就可以勾选它，<br> <img src="https://images2.imgbox.com/28/2c/ObrrtJZt_o.png" alt="在这里插入图片描述"><br> 一般情况下，我们都不需要开启预测，保持为<code>0</code>即可，<br> <img src="https://images2.imgbox.com/d6/81/FZ7FMbDG_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="228HorizontalVertical_Damping_145"></a>2.2.8、瞄准阻尼：Horizontal/Vertical Damping</h6> 
<p><img src="https://images2.imgbox.com/de/3f/C2Wxj6AX_o.png" alt="在这里插入图片描述"><br> 注意，这个和<code>2.2.5</code>小节讲的<code>Body Y/Z Damping</code>阻尼是不同的，<code>Body Y/Z Damping</code>是移动阻尼，而<code>Horizontal/Vertical Damping</code>是旋转阻尼，<br> 为了方便观察，我先把<code>Follow</code>设为<code>None</code>，让相机固定位置不动，<br> <img src="https://images2.imgbox.com/8c/fc/lMCB2GOW_o.png" alt="在这里插入图片描述"><br> 现在我们先看<code>Horizontal Damping</code>为<code>0.5</code>时的效果，此时水平旋转阻尼比较小，相机的旋转是可以跟上主角的移动的，<br> <img src="https://images2.imgbox.com/64/fc/UXdFwdac_o.gif" alt="请添加图片描述" width="800"><br> 现在我们把<code>Horizontal Damping</code>调整到<code>3</code>，效果如下，可以看到，相机的水平旋转由于阻尼的作用而出现了滞后，适当的阻尼可以减少抖动，过大的阻尼会带来滞后，我们保持默认的<code>0.5</code>就好了，<br> <img src="https://images2.imgbox.com/84/1f/OZ086dio_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="229_155"></a>2.2.9、画面构图（重要）</h6> 
<p>喜欢摄影的同学应该都听说过构图，比如三分法、中央对称法、对角线三角形、留白、黄金比例等等。在<code>Cinemachine</code>中，提供了<code>Dead Zone</code>、<code>Soft Zone</code>来约束主角在画面中的位置，我们可以调整对应的参数来实现自己的画面构图，<br> <img src="https://images2.imgbox.com/a3/12/QTXWDwwA_o.png" alt="在这里插入图片描述"><br> <code>Dead Zone</code>和<code>Soft Zone</code>区域如下，<br> <img src="https://images2.imgbox.com/20/b9/eL8XpGq2_o.png" alt="在这里插入图片描述"><br> <code>Dead Zoon</code>范围内，主角的移动不会触发相机的旋转，为了演示，我把<code>Dead Zone</code>调大一点点，我们可以通过<code>Dead Zone Width</code>和<code>Dead Zone Height</code>来调整<code>Dead Zoon</code>的区域大小，<br> <img src="https://images2.imgbox.com/94/95/AoumSHmM_o.png" alt="在这里插入图片描述"><br> 可以看到，<code>Dead Zoon</code>范围内，主角的移动不会触发相机的旋转，只有当主角的位置超出了<code>Dead Zone</code>的区域，才会触发相机的旋转，<br> <img src="https://images2.imgbox.com/ee/a5/lkZD4WvO_o.gif" alt="请添加图片描述" width="800"><br> 我们可以把<code>Dead Zone</code>区域调为``0```，这样主角只要发生移动，就会触发相机的旋转，<br> <img src="https://images2.imgbox.com/a6/26/mv0HOwI2_o.png" alt="在这里插入图片描述"></p> 
<p>同理，<code>Soft Zone</code>的区域是一个缓冲区域，在这个区域内，相机会插值旋转（慢慢旋转），直至把主角 “推” 回到 <code>Dead Zone</code>内，如果主角的位置超过了<code>Soft Zone</code>的区域，相机就会立刻旋转确保主角留在<code>Soft Zone</code>区域内。</p> 
<p>比如我现在把<code>Soft Zone</code>区域调小，<br> <img src="https://images2.imgbox.com/1f/a4/QAtBZHU5_o.png" alt="在这里插入图片描述"><br> 测试效果如下，可以看到，当主角尝试超过<code>Soft Zone</code>区域时，相机的旋转速度会立刻跟上，确保主角在<code>Soft Zone</code>区域内，<br> <img src="https://images2.imgbox.com/02/48/EaECaCCe_o.gif" alt="请添加图片描述" width="800"><br> <code>Screen X</code>和<code>Screen Y</code>是用来调整整个<code>Zone</code>的屏幕位置的，<br> <img src="https://images2.imgbox.com/16/5c/MDdUc1Kv_o.png" alt="在这里插入图片描述"><br> 比如把整个<code>Zone</code>调整到屏幕左下角，这样主角在画面中的位置就是左下角了，<br> <img src="https://images2.imgbox.com/b9/d6/p3KP3oS7_o.gif" alt="请添加图片描述" width="800"></p> 
<p><code>Bias X</code>和<code>Bias Y</code>用来调整<code>Soft Zoon</code>相对于整个<code>Zoon</code>的位置偏移，</p> 
<p><img src="https://images2.imgbox.com/8a/2d/3NxaMqUL_o.png" alt="在这里插入图片描述"><br> 效果如下，<br> <img src="https://images2.imgbox.com/0e/b2/xmYnqUdl_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="23_183"></a>2.3、小结</h6> 
<p>这个案例中，我们主要设置<code>CinemachineFreeLook</code>组件的<code>Follow</code>、<code>LookAt</code>对象，调整移动阻尼：<code>Body Y/Z Damping</code>，调整一下<code>Aim</code>的<code>Dead Zone</code>、<code>Soft Zone</code>就差不多了，可以快速应用到自己的实际项目中。</p> 
<h5><a id="3_185"></a>3、用代码控制相机移动（绕圆环旋转）</h5> 
<p>等我们移动鼠标的时候，相机会围绕圆环轨道移动，如下<br> <img src="https://images2.imgbox.com/0e/5f/sorS6PLg_o.gif" alt="请添加图片描述" width="800"><br> 这是因为<code>CinemachineFreeLook</code>组件监听了<code>Mouse Y</code>、<code>Mouse X</code>输入，它根据鼠标的移动去控制相机的移动，<br> <img src="https://images2.imgbox.com/dc/2e/7LrDoX5v_o.png" alt="在这里插入图片描述"><br> 如果我们先禁用它自身的这个控制，可以把这两个<code>Input Axis Name</code>设置为空，<br> <img src="https://images2.imgbox.com/cd/08/Kcto3IvC_o.png" alt="在这里插入图片描述"><br> 接着，我们在代码中去设置<code>CinemachineFreeLook</code>组件的<code>m_XAxis</code>和<code>m_YAxis</code>成员的<code>m_InputAxisValue </code>即可，例：</p> 
<pre><code class="prism language-csharp"><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">Cinemachine</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">CinemachineFreeLook</span> vcam<span class="token punctuation">;</span>

    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        vcam <span class="token operator">=</span> <span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>CinemachineFreeLook<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 自己通过代码获取 x、y分量，比如通过摇杆获取，这里我就仍然使用 Mouse X 和 Mouse Y吧</span>
        <span class="token class-name"><span class="token keyword">var</span></span> x <span class="token operator">=</span> Input<span class="token punctuation">.</span><span class="token function">GetAxis</span><span class="token punctuation">(</span><span class="token string">"Mouse X"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">var</span></span> y <span class="token operator">=</span> Input<span class="token punctuation">.</span><span class="token function">GetAxis</span><span class="token punctuation">(</span><span class="token string">"Mouse Y"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 相机移动</span>
        vcam<span class="token punctuation">.</span>m_XAxis<span class="token punctuation">.</span>m_InputAxisValue <span class="token operator">=</span> x<span class="token punctuation">;</span>
        vcam<span class="token punctuation">.</span>m_YAxis<span class="token punctuation">.</span>m_InputAxisValue <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>关于摇杆的实现，可以参见我之前写的这篇博客的第六节：<a href="https://blog.csdn.net/linxinfa/article/details/117536057">【游戏开发创新】用Unity等比例制作广州地铁，广州加油，早日战胜疫情（Unity | 地铁地图 | 第三人称视角）</a></p> 
<p><img src="https://images2.imgbox.com/f3/41/It9DdisZ_o.gif" alt="" width="800"><br> <img src="https://images2.imgbox.com/d6/c0/fFUozNrH_o.gif" alt="" width="800"></p> 
<h4><a id="2Free_Look_collider_222"></a>四、案例2：相机避障不穿墙，Free Look collider场景</h4> 
<h5><a id="1_223"></a>1、场景演示</h5> 
<p>双击打开<code>Free Look collider</code>场景，<br> <img src="https://images2.imgbox.com/5a/ce/h2LBlgx4_o.png" alt="在这里插入图片描述"><br> 这也是第三人称自由视角的摄像机效果，在此基础上加了<code>CinemachineCollider</code>，避免相机穿墙的问题，效果如下<br> <img src="https://images2.imgbox.com/15/a3/af0sv2vM_o.gif" alt="请添加图片描述" width="800"><br> 画个图</p> 
<p><img src="https://images2.imgbox.com/ca/a6/7n9OmW2h_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_232"></a>2、组件参数</h5> 
<h6><a id="21CinemachineCollider_233"></a>2.1、CinemachineCollider：相机碰撞</h6> 
<p>在上面<mark>案例1</mark>的基础上，加多了一个<code>CinemachineCollider</code>组件，<br> <img src="https://images2.imgbox.com/97/1b/59027v9H_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="211Add_Extension_236"></a>2.1.1、Add Extension拓展</h6> 
<p>如果你点击<code>AddComponent</code>按钮，你是找不到这个<code>CinemachineCollider</code>组件的；<br> <img src="https://images2.imgbox.com/54/ea/cX6n9naH_o.png" alt="在这里插入图片描述"></p> 
<p>正确的姿势是点击<code>CinemachineFreeLook</code>的<code>Add Extension</code>下拉选项，添加<code>CinemachineCollider</code>拓展，</p> 
<p><img src="https://images2.imgbox.com/95/ef/eP0zQFSq_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="212Collide_AgainstLayer_244"></a>2.1.2、Collide Against：被认定为障碍物的Layer</h6> 
<p>虚拟相机的碰撞是通过射线检测来实现的，射线检测的时候可以传一个<code>LayerMask</code>参数过滤要检测的层，这里<code>Collide Against</code>参数就是设置被认为障碍物的<code>Layer</code>，只有被勾选的<code>Layer</code>才会参与射线碰撞检测，<br> <img src="https://images2.imgbox.com/74/a6/cuI4wJPZ_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="213Ignore_TagTag_247"></a>2.1.3、Ignore Tag：忽略碰撞检测的Tag</h6> 
<p>如果我们想要剔除掉某个<code>Tag</code>的物体，不对特定<code>Tag</code>的物体进行碰撞检测，可以设置<code>Ignore Tag</code>参数，这里设置的是<code>Player</code>，也就是不与主角做碰撞检测（也就是说摄像机有可能从主角身上穿过去）<br> <img src="https://images2.imgbox.com/a8/7c/43KYDoAa_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="214Transparent_Layers_250"></a>2.1.4、Transparent Layers：透明层</h6> 
<p>透明层的物体被认为是透明的，不作为障碍物处理。<br> 可能有同学要问了，上面不是已经有个<code>Tag</code>来剔除碰撞检测对象了吗，这个透明层是不是有点功能重复了？非也，请往下看，<br> <img src="https://images2.imgbox.com/75/ae/1T3mLzyg_o.png" alt="在这里插入图片描述"><br> 首先要清楚这个<code>CinemachineCollider</code>的功能不仅仅是确保相机不穿墙，还要确保主角不被 障碍物 挡住。</p> 
<p>比如下面这种情况（我把<code>Transparent Layers</code>设置为<code>Default</code>，这样墙壁被认为是透明层），相机并没有在墙里面，但是视线被墙挡住了，看不见主角，<br> <img src="https://images2.imgbox.com/93/df/jAgzQVN8_o.png" alt="在这里插入图片描述"><br> 我们把<code>Transparent Layers</code>改回<code>Nothing</code>，<br> <img src="https://images2.imgbox.com/a6/4b/UIpB8tVR_o.png" alt="在这里插入图片描述"><br> 此时可以看到，主角画面没有被墙挡住了，现在你知道<code>Transparent Layers</code>是干嘛的了吗~<br> <img src="https://images2.imgbox.com/6d/f8/42m9LF4k_o.png" alt="在这里插入图片描述"><br> 如果这里的墙确实是半透明的，那么我们就可以把它的层加入到<code>Transparent Layers</code>，比如这里我特意把墙改为半透明，添加了一个<code>Wall</code>层，<br> <img src="https://images2.imgbox.com/c4/be/nu3jXb6H_o.png" alt="在这里插入图片描述"><br> 效果如下<br> <img src="https://images2.imgbox.com/41/e5/5rBKlRfq_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="215Minimum_Distance_From_Target_266"></a>2.1.5、Minimum Distance From Target：与目标的最小距离</h6> 
<p>与目标的最小距离 ，只有大于最小距离，<code>Cinemachine</code>才会进行规避障碍物的操作。</p> 
<h6><a id="216Avoid_Obstacles_268"></a>2.1.6、Avoid Obstacles：是否避开障碍物</h6> 
<p>勾选了才会执行避障逻辑。</p> 
<h6><a id="217Distance_Limit_270"></a>2.1.7、Distance Limit：碰撞检测的射线长度</h6> 
<p>上面我们说到碰撞检测这里用的是射线来检测的，<code>Distance Limit</code>就是射线的长度，为<code>0</code>的时候则以<code>Cinemachine</code>与<code>Follow</code>目标的距离为射线长度，</p> 
<h6><a id="218Camera_Radius_272"></a>2.1.8、Camera Radius：相机半径</h6> 
<p>相机将尝试与任何障碍物保持此距离。 尽量保持这个值很小。</p> 
<h6><a id="219Strategy_274"></a>2.1.9、Strategy：避障策略</h6> 
<p><img src="https://images2.imgbox.com/db/da/LQMV7BzD_o.png" alt="在这里插入图片描述"></p> 
<table><thead><tr><th align="left">避障策略</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Pull Camera Forward</td><td align="left">直接让相机往前走，移动到障碍物之前</td></tr><tr><td align="left">Preserve Camera Height</td><td align="left">相机高度不变，通过向左或向右移动来避开障碍物</td></tr><tr><td align="left">Preserve Camera Distance</td><td align="left">保持相机和目标的距离不变，避开障碍物</td></tr></tbody></table> 
<p><strong>Pull Camera Forward</strong> 这种策略摄像机会出现瞬移的问题，如下<br> <img src="https://images2.imgbox.com/f6/74/7H5CBjUH_o.gif" alt="请添加图片描述" width="800"></p> 
<p><strong>Preserve Camera Height</strong> 这种策略摄像机会在水平方向上移动来过渡，而不是像上面那样瞬移，<mark>推荐使用这种策略</mark>，如下</p> 
<p><img src="https://images2.imgbox.com/4d/7a/Q6tZqS61_o.gif" alt="请添加图片描述" width="800"><br> <strong>Preserve Camera Distance</strong> 这种策略由于为了保持距离，摄像机会出现向上蹿或像下蹿的问题，如下</p> 
<p><img src="https://images2.imgbox.com/dc/e5/I6TVHFqn_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="2110Maximum_Effort_291"></a>2.1.10、Maximum Effort：一次可处理的最多的障碍物数量</h6> 
<p>一般<code>4</code>个就可以了，太高影响性能。</p> 
<h6><a id="2111Smoothing_Time_294"></a>2.1.11、Smoothing Time：相机移动的平滑时间</h6> 
<p>在距离目标最近的点保持相机的最小秒数。如果场景中障碍物很多，会导致摄像机频繁避障而出现相机跳动，比如我在主角周围摆了那么多障碍物，<br> <img src="https://images2.imgbox.com/c8/9e/AsUDVE8i_o.png" alt="在这里插入图片描述"><br> 此时，就可以适当调大<code>Smoothing Time</code>，减少多余的摄像机避障移动。<br> 我们先看下<code>Smoothing Time</code>为<code>0</code>时的效果，可以看到摄像机很跳，<br> <img src="https://images2.imgbox.com/0b/4b/xsQzdRbP_o.gif" alt="请添加图片描述" width="800"><br> 现在我们把<code>Smoothing Time</code>调大到<code>2</code>，效果如下，可以看到，摄像机平滑了很多，不会那么跳了，</p> 
<p><img src="https://images2.imgbox.com/3c/63/nu8lU7JW_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="2112Damping_307"></a>2.1.12、Damping：避障后相机恢复位置的阻尼</h6> 
<p>遮挡消失后，相机恢复到正常位置的阻尼。<br> 比如我们使用<code>Pull Camera Forward</code>避障策略，然后把<code>Damping</code>调大，可以看到在遮挡消失后，相机位置有一个平滑的过渡恢复效果，<br> <img src="https://images2.imgbox.com/f8/5b/xdh8JL0v_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="2112Damping_When_Occluded_311"></a>2.1.12、Damping When Occluded：避障时的相机阻尼</h6> 
<p>上面的<code>Damping</code>是避障后恢复的阻尼，这个<code>Damping When Occluded</code>则是避障时的相机阻尼，我们同样使用<code>Pull Camera Forward</code>避障策略进行测试，把<code>Damping When Occluded</code>调大，效果如下，可以看到，当出现遮挡时，摄像机不是瞬移了，而是有个阻尼过渡移动过去，看起来貌似与<code>Preserve Camera Height</code>避障策略差不多，但<code>Preserve Camera Height</code>避障会确保摄像机不穿墙，而这种<code>Pull Camera Forward</code>配合<code>Damping When Occluded</code>的方式是会存在摄像机穿墙的问题的。<br> <img src="https://images2.imgbox.com/25/05/YvTlTXU0_o.gif" alt="请添加图片描述" width="800"></p> 
<h4><a id="3FollowCam_Simple_Follow_315"></a>五、案例3：简单追踪，FollowCam Simple Follow场景</h4> 
<h5><a id="1_316"></a>1、场景演示</h5> 
<p>双击打开<code>FollowCam Simple Follow</code>场景，<br> <img src="https://images2.imgbox.com/0e/46/Eozjezbq_o.png" alt="在这里插入图片描述"><br> 这是一个追踪一架飞机飞行的摄像机效果，效果如下<br> <img src="https://images2.imgbox.com/42/fe/paE5Ln3j_o.gif" alt="请添加图片描述" width="800"><br> 画个图</p> 
<p><img src="https://images2.imgbox.com/9d/9b/cz3BKSyt_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_324"></a>2、组件参数</h5> 
<h5><a id="21CinemachineVirtualCamera_325"></a>2.1、CinemachineVirtualCamera：虚拟相机</h5> 
<p>与<code>CinemachineFreeLook</code>一样，<code>CinemachineVirtualCamera</code>也是继承<code>CinemachineVirtualCameraBase</code>，相对来说，<code>CinemachineVirtualCamera</code>功能更简单一些。<br> <img src="https://images2.imgbox.com/a3/7f/z1sVZ9Gk_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="211FollowLookAt_328"></a>2.1.1、Follow与LookAt：追踪目标</h6> 
<p>同样也是设置<code>Follow</code>和<code>LookAt</code>参数，设置追踪的目标和朝向的目标。<br> <img src="https://images2.imgbox.com/86/d2/O64wCDmw_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="212Binding_ModeBody_331"></a>2.1.2、Binding Mode：Body绑定模式</h6> 
<p>需要重点讲一下<code>Body</code>的绑定模式，<br> <img src="https://images2.imgbox.com/f4/e3/UpFv7hbs_o.png" alt="在这里插入图片描述"><br> 大家可以打开<code>Transposer</code>场景，<br> <img src="https://images2.imgbox.com/09/0b/y933shAA_o.png" alt="在这里插入图片描述"><br> 这个场景里帮我们创建了多个<code>Binding Mode</code>的虚拟相机，方便我们进行测试，<br> <img src="https://images2.imgbox.com/a4/5d/X6jwPMl1_o.png" alt="在这里插入图片描述"><br> 下文，我将使用一个更直观的案例进行演示~</p> 
<h6><a id="1Lock_To_Target_On_Assign__340"></a>1、Lock To Target On Assign 模式（常用）</h6> 
<p>当相机跟踪目标被设置的时候，把相机设置到目标物体的局部坐标系中，但不跟随目标物体的旋转而移动。</p> 
<p><mark>简单讲就是：你动我动，你转我不动</mark></p> 
<p><img src="https://images2.imgbox.com/7a/e1/qFDmf3if_o.gif" alt="请添加图片描述" width="800"></p> 
<p>这种适用于视角固定的追踪，为了方便演示应用效果，我导入另外一个<code>Package</code>资源包，该资源包可以在<code>AssetStore</code>免费下载使用，地址：<a href="https://assetstore.unity.com/packages/3d/characters/humanoids/character-pack-free-sample-79870" rel="nofollow">https://assetstore.unity.com/packages/3d/characters/humanoids/character-pack-free-sample-79870</a><br> <img src="https://images2.imgbox.com/21/4b/ASCjM2ez_o.png" alt="在这里插入图片描述"><br> 稍微整一下场景，如下<br> <img src="https://images2.imgbox.com/ca/13/Jgm1Wovy_o.png" alt="在这里插入图片描述"><br> 虚拟相机参数设置如下，<br> <img src="https://images2.imgbox.com/da/04/LxclXWrq_o.png" alt="在这里插入图片描述"></p> 
<p>我们运行，效果如下<br> <img src="https://images2.imgbox.com/11/5e/rixktzwT_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="2Lock_To_Target_With_World_Up__359"></a>2、Lock To Target With World Up 模式</h6> 
<p>相机被设置到目标物体的局部坐标系中，但不会跟随目标物体在<code>z</code>轴旋转, 也不会跟随目标物体在<code>x</code>轴倾斜。</p> 
<p><mark>简单讲就是：你动我动，你x/z轴转我不动，你y轴转我动。</mark></p> 
<p><img src="https://images2.imgbox.com/05/47/yS5ZGQVD_o.gif" alt="请添加图片描述" width="800"><br> 同样，我们使用小男孩演示下镜头效果，注意主角身上的<code>SimpleSampleCharacterControl</code>组件的移动模式切换成<code>Tank</code>模式，<br> <img src="https://images2.imgbox.com/db/9f/ETHdzPYj_o.png" alt="在这里插入图片描述"><br> 运行效果如下，适合这种视角始终朝着角色背后的情景，<br> <img src="https://images2.imgbox.com/fd/b1/AeIPqeAj_o.gif" alt="请添加图片描述" width="800"><br> 并且主角<code>x</code>轴旋转时，相机不会因为主角的旋转而移动，</p> 
<p><img src="https://images2.imgbox.com/d1/6f/CqwtjN5V_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="3Lock_To_Target_No_Roll__375"></a>3、Lock To Target No Roll 模式</h6> 
<p>相机被设置到目标物体的局部坐标系中，但不会跟随目标物体在```z``轴的旋转。</p> 
<p><mark>简单讲就是：你动我动，你x/y旋转我动，你z轴转我不动。</mark></p> 
<p><img src="https://images2.imgbox.com/b3/eb/GyaCgqQS_o.gif" alt="请添加图片描述" width="800"><br> 小男孩效果如下，<br> <img src="https://images2.imgbox.com/1e/4a/7ndgkABe_o.gif" alt="请添加图片描述" width="800"><br> 这个情景看起来效果与<code>Lock To Target With World Up</code>一样，但如果主角在绕着<code>x</code>轴旋转，相机会跟着移动，如下</p> 
<p><img src="https://images2.imgbox.com/98/cd/IVxMhbmE_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="4Lock_To_Target__388"></a>4、Lock To Target 模式</h6> 
<p>这是最容易理解的类型，相机被设置到目标物体的局部坐标系中，将一直跟随目标物体旋转和移动。</p> 
<p><mark>简单讲就是：你动我动，你转我动。</mark></p> 
<p><img src="https://images2.imgbox.com/ca/dc/hyMxkmlA_o.gif" alt="请添加图片描述" width="800"><br> 小男孩效果如下，<br> <img src="https://images2.imgbox.com/f6/2e/N8lJkqyI_o.gif" alt="请添加图片描述" width="800"><br> 跟上面的<code>Lock To Target No Roll </code>和<code>Lock To Target With World Up </code>运行效果一样，但如果主角在沿着<code>x</code>、<code>y</code>轴旋转，摄像机会跟着移动，<br> <img src="https://images2.imgbox.com/24/6c/w0iwyiwv_o.gif" alt="请添加图片描述" width="800"></p> 
<p>其实对于小男孩的这个情景，你使用<code>Lock To Target</code>、<code>Lock To Target No Roll </code>、<code>Lock To Target With World Up </code>的运行效果一样，因为这个情景下，小男孩并不会发生<code>x</code>、<code>y</code>轴的旋转。</p> 
<h6><a id="5World_Space__403"></a>5、World Space 模式</h6> 
<p>相机跟目标的偏移以世界坐标来进行计算，并始终保持在初始设置的状态。</p> 
<p><mark>简单讲就是：你动我动，你转我不动</mark><br> 诶，听起来跟 <strong>Lock To Target On Assign</strong> 模式一样，其实不一样，区别就在于<code>Follow Offset</code>参数，<strong>Lock To Target On Assign</strong> 模式是把 <code>Follow Offset</code>当做目标物体的局部坐标系来计算偏移的，而 <strong>World Space</strong> 模式，则是以世界坐标系来计算偏移的，</p> 
<p><img src="https://images2.imgbox.com/aa/ce/iAm0gDDp_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ab/0f/OmmgTgWs_o.gif" alt="请添加图片描述" width="800"><br> 小男孩运行效果如下，<br> <img src="https://images2.imgbox.com/c9/aa/M5ofRRm5_o.gif" alt="请添加图片描述" width="800"><br> 表现效果与<code>Lock To Target On Assign</code>一样，如果在这种应用情景下，我建议使用<code>World Space</code>，因为少了一步转局部坐标的过程。</p> 
<h6><a id="6Simple_Follow_With_World_Up__416"></a>6、Simple Follow With World Up 模式</h6> 
<p>使用相机坐标系来计算与目标物体的偏移，不会跟随物体旋转而改变朝向，相机方向始终向上。<br> 比如这个时候的相机坐标系是这样的，<br> <img src="https://images2.imgbox.com/b4/9c/wtakmAy1_o.png" alt="在这里插入图片描述"><br> 把这个坐标系移动到目标物体的中心位置，然后基于这个坐标系做一次<code>Follow Offset</code>偏移，即可得到相机的位置，</p> 
<p><img src="https://images2.imgbox.com/12/0d/NgtgJTZG_o.png" alt="在这里插入图片描述"><br> 效果如下<br> <img src="https://images2.imgbox.com/a3/ef/vQxkXnfK_o.gif" alt="请添加图片描述" width="800"></p> 
<p>小男孩运行效果如下，<br> <img src="https://images2.imgbox.com/f6/84/5QhqUJ7z_o.gif" alt="请添加图片描述" width="800"></p> 
<p>这一看好像与<code>World Space</code>模式的表现是一样的，其实不一样，我们换个视角观察，我让小男孩一直往左走，先看下<code>World Space</code>的效果，<br> <img src="https://images2.imgbox.com/d9/c8/H0zQQf0r_o.gif" alt="请添加图片描述" width="800"><br> 现在我们看下<code>Simple Follow With World Up </code>模式下，小男孩一直往左跑是什么效果，如下，小男孩是绕着圈圈走的。之前就有一个策划拿着某款游戏过来问我，为什么主角一直往右跑的时候看起来好像是在转圈圈，我猜那款游戏用的就是<code>Simple Follow With World Up</code>模式，</p> 
<p><img src="https://images2.imgbox.com/9c/2a/Mtq3MMU3_o.gif" alt="请添加图片描述" width="800"></p> 
<h4><a id="4StateDrivenCamera_436"></a>六、案例4：动画状态驱动自由视角，StateDrivenCamera场景</h4> 
<h5><a id="1_437"></a>1、场景演示</h5> 
<p>双击打开<code>StateDrivenCamera</code>场景，<br> <img src="https://images2.imgbox.com/4b/bc/vq8UOjJn_o.png" alt="在这里插入图片描述"><br> 这是一个根据主角动画状态切换摄像机机位效果，默认情况下是一个第三人称自由视角，当主角跑起来的时候，会切换到一个固定视角的虚拟相机机位，我们运行，在<code>Scene</code>窗口看下这个切换过程，<br> <img src="https://images2.imgbox.com/40/af/1vDAAAIG_o.gif" alt="请添加图片描述" width="800"><br> 画个图</p> 
<p><img src="https://images2.imgbox.com/19/40/oMZvA4DK_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_447"></a>2、组件参数</h5> 
<p>这个案例我们只需要讲一下<code>CinemachineStateDrivenCamera</code>组件，其它的上文已经讲过了。</p> 
<h6><a id="21CinemachineStateDrivenCamera_450"></a>2.1、CinemachineStateDrivenCamera：状态驱动虚拟相机</h6> 
<h6><a id="211CinemachineStateDrivenCamera_451"></a>2.1.1、父节点：CinemachineStateDrivenCamera</h6> 
<p>在父节点上挂<code>CinemachineStateDrivenCamera</code>组件，<br> <img src="https://images2.imgbox.com/ec/e6/CmmMlTCA_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="212_454"></a>2.1.2、子节点：多个虚拟相机</h6> 
<p>子节点可以放多个虚拟相机，<br> <img src="https://images2.imgbox.com/0d/f6/hoFINoQe_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="213Animated_Target_457"></a>2.1.3、设置Animated Target</h6> 
<p>因为我们需要根据动画状态来切换不同的虚拟相机，所以需要给<code>CinemachineStateDrivenCamera</code>组件指定<code>Animated Target</code>，把主角的<code>Animator</code>对象赋值给它，<br> <img src="https://images2.imgbox.com/a0/19/wzhceBWY_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="214State_461"></a>2.1.4、设置State</h6> 
<p>我们先看下主角的动画状态机，很简单，只有<code>Locomotion</code>和<code>Sprint</code>两个动画状态，<br> <img src="https://images2.imgbox.com/b3/8b/a4psr8A9_o.png" alt="在这里插入图片描述"><br> 我们在<code>CinemachineStateDrivenCamera</code>组件上分别给这两个动画状态添加要激活的虚拟相机，如下<br> <img src="https://images2.imgbox.com/0d/f6/Ke1hXFAW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5ClearShot_466"></a>七、案例5：分镜/切镜，ClearShot场景</h4> 
<p><code>ClearShot</code>翻译过来是清晰的镜头的意思，就是从多个相机镜头中选择一个画面质量最好的镜头，切换过去，表现上就像分镜的效果。</p> 
<p>啥是分镜呢？首先看下百科的概念，</p> 
<blockquote> 
 <p>分镜(Storyboard) 又叫故事板。是指电影、动画、电视剧、广告、音乐录像带等各种影像媒体，在实际拍摄或绘制之前，以图表的方式来说明影像的构成，将连续画面以一次运镜为单位作分解，并且标注运镜方式、时间长度、对白、特效等。根据媒体不同划分成不同分镜。常见的有影片分镜，漫画分镜。影片分镜用以解说一个场景将如何构成，人物以多大的比例收入镜头成为构图、做出什么动作，摄影机要从哪个角度切入或带出、摄影机本身怎么移动、录映多少时间等。</p> 
</blockquote> 
<p>喜欢看漫画的同学应该不陌生，一个场景中我们架设多个虚拟相机机位，为了做出最好的画面表现，我们需要进行镜头切换，比如下面的漫画，一个格子就像是一个机位拍摄的画面，镜头角度、位置等，什么时候去切换镜头，这些对应到<code>Cinemachine</code>中，就是<code>ClearShot</code>要做的事情，</p> 
<p><img src="https://images2.imgbox.com/bd/5a/9NHRYOLO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bd/4e/6xmqWB1d_o.png" alt="在这里插入图片描述"><br> <code>Cinemachine</code>给我们做了三个场景，我们先运行看下效果。<br> <img src="https://images2.imgbox.com/19/77/8ZrUFNnx_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1_480"></a>1、场景演示</h5> 
<h6><a id="11ClearShot_481"></a>1.1、ClearShot场景</h6> 
<p>先双击打开<code>ClearShot</code>场景，运行效果如下<br> <img src="https://images2.imgbox.com/9b/67/YiprpQLS_o.gif" alt="请添加图片描述" width="800"><br> 场景中架了三个虚拟相机，如下，根据主角是否被遮挡进行最优切换，</p> 
<p><img src="https://images2.imgbox.com/0a/7f/SlHYGaoV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b6/80/wi4nnKa9_o.png" alt="在这里插入图片描述"></p> 
<p>虚拟相机父节点是一个<code>CinemachineClearShot</code>，下文会介绍这个组件的参数，<br> <img src="https://images2.imgbox.com/b7/d7/wTm7RczY_o.png" alt="在这里插入图片描述"><br> 画个图<br> <img src="https://images2.imgbox.com/75/20/75OOLdyL_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="12ClearShot_closest_498"></a>1.2、ClearShot closest场景</h6> 
<p>先双击打开<code>ClearShot closest</code>场景，运行效果如下<br> <img src="https://images2.imgbox.com/20/b5/cN0WdvsS_o.gif" alt="请添加图片描述" width="800"><br> 场景中架了六个虚拟相机，如下，根据与主角的距离进行最优切换，<br> <img src="https://images2.imgbox.com/7c/0a/8EHiNslE_o.png" alt="在这里插入图片描述"></p> 
<p>其中<code>CinemachineClearShot</code>子节点虚拟相机中嵌了一个<code>CinemachineBlendListCamera</code>，下文会介绍这个组件的参数，<br> <img src="https://images2.imgbox.com/58/61/CvyQJ4Y9_o.png" alt="在这里插入图片描述"><br> 按照惯例画个图<br> <img src="https://images2.imgbox.com/63/31/RDCO0QW9_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="12ClearShot_character_510"></a>1.2、ClearShot character场景</h6> 
<p>双击打开<code>ClearShot character</code>场景，运行效果如下</p> 
<p><img src="https://images2.imgbox.com/d1/6a/QQ15mlG0_o.gif" alt="请添加图片描述" width="800"><br> 场景中架设了<code>5</code>个虚拟相机<br> <img src="https://images2.imgbox.com/bf/a7/lkcNlZ73_o.png" alt="在这里插入图片描述"><br> 其中用到了虚拟相机触发器：<code>CinemachineTriggerAction</code>，用于检测主角是否进入触发器区域，然后进行虚拟相机的切换，下文会介绍这个组件的参数，<br> <img src="https://images2.imgbox.com/d9/1a/pWASj8A9_o.png" alt="在这里插入图片描述"><br> 画个图<br> <img src="https://images2.imgbox.com/a9/68/BrAVaAkx_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_520"></a>2、组件参数</h5> 
<h6><a id="21CinemachineClearShot_521"></a>2.1、CinemachineClearShot：自动选择/切换最适合的摄像头</h6> 
<p><code>CinemachineClearShot</code>会根据被观察目标的最好画面质量，从子节点中选择一个最合适的虚拟相机。<br> 至于它是根据什么做出最优选择的，大家可以查看<code>CinemachineClearShot.cs</code>源码的<code>ChooseCurrentCamera</code>方法，<br> <img src="https://images2.imgbox.com/80/69/olyWV7HS_o.png" alt="在这里插入图片描述"><br> 主要是根据虚拟相机的<code>ShowQuality</code>和<code>Priority</code>两个参数进行评估的，<br> <img src="https://images2.imgbox.com/3e/87/ZSsEVPx7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/55/e9/1ByhMzsh_o.png" alt="在这里插入图片描述"><br> 而<code>ShowQuality</code>又是根据相机是否被遮挡、与目标的距离等参数进行评估的。<br> 如果我们想手动触发虚拟相机的切换，可以通过代码设置虚拟相机的<code>Priority</code>参数提高优先级。<br> 这里我们主要讲一下如何设置<code>CinemachineClearShot</code>组件的参数。<br> 我们只需要在子节点中添加虚拟相机，就会自动在下面的列表中显示出来，我们设置一下<code>Priority</code>优先级参数即可，<br> <img src="https://images2.imgbox.com/c7/c3/KR6M3SQC_o.png" alt="在这里插入图片描述"><br> 另外，<code>CinemachineClearShot</code>本身也有<code>Follow</code>和<code>LookAt</code>参数，如果子节点的虚拟相机没有设置<code>Follow</code>和<code>LookAt</code>，则会以<code>CinemachineClearShot</code>的为准，否则以子节点虚拟相机的<code>Follow</code>和<code>LookAt</code>为准，<br> <img src="https://images2.imgbox.com/0c/0e/H4y5pCt5_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="22CinemachineBlendListCamera_535"></a>2.2、CinemachineBlendListCamera：虚拟相机过渡/混合器</h6> 
<p>在<code>ClearShot closest</code>场景中用到了<code>CinemachineBlendListCamera</code>，我使用另一个专门的场景来讲解，<br> 双击打开<code>BlendListCamera</code>，<br> <img src="https://images2.imgbox.com/46/62/ZEa0q70w_o.png" alt="在这里插入图片描述"><br> 场景中放了两个<code>CinemachineBlendListCamera</code>，<br> <img src="https://images2.imgbox.com/19/4a/UmgCpdwP_o.png" alt="在这里插入图片描述"><br> 我们把默认的虚拟相机禁用，把第一个<code>CinemachineBlendListCamera</code>激活，可以看到它底下有两个虚拟相机，<br> <img src="https://images2.imgbox.com/05/92/8I32VH3Q_o.png" alt="在这里插入图片描述"><br> <code>CinemachineBlendListCamera</code>做的事情就是按照我们设定的顺序进行虚拟相机的过渡，注意，这里会按照我们排的顺序进行过渡，而不会进行像<code>ClearShot</code>那样进行画面质量评估，下面这个设置的意思就是先在<code>CM vcam A</code>虚拟相机状态停留<code>0.5</code>秒，然后用<code>2</code>秒时间过渡到<code>CM vcam B</code>，过渡的缓动曲线使用<code>Ease In Out</code>，<br> <img src="https://images2.imgbox.com/4b/7a/zma8fm8x_o.png" alt="在这里插入图片描述"><br> 常用的缓动曲线如下<br> <img src="https://images2.imgbox.com/fd/26/6AB7SvAv_o.png" alt="在这里插入图片描述"></p> 
<p>我们调整一下两个虚拟相机的位置，如下<br> <img src="https://images2.imgbox.com/01/72/QXOoZFfX_o.png" alt="在这里插入图片描述"><br> 现在我们运行看看效果，可以看到相机从<code>CM vcam A</code>过渡到了<code>CM vcam B</code>，<br> <img src="https://images2.imgbox.com/52/6e/k35D9vPE_o.gif" alt="请添加图片描述" width="800"><br> 我们还可以让它从<code>CM vcam B</code>回到<code>CM vcam A</code>，我们添加过渡设置，如下<br> <img src="https://images2.imgbox.com/0d/19/SGNViDqz_o.png" alt="在这里插入图片描述"><br> 重新运行，效果如下，可以看到，相机最后又过渡回到了<code>CM vcam A</code>，<br> <img src="https://images2.imgbox.com/a7/61/Qn7wlDwz_o.gif" alt="请添加图片描述" width="800"><br> 如果我们想要让这个顺序循环执行，可以勾选<code>Loop</code><br> <img src="https://images2.imgbox.com/0d/e0/cHS48hY9_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="23CinemachineTriggerAction_558"></a>2.3、CinemachineTriggerAction：虚拟相机触发器</h6> 
<p>插件中的<code>Trigger volumes</code>场景可以针对触发器进行测试，<br> <img src="https://images2.imgbox.com/2f/75/QIvK3Hiz_o.png" alt="在这里插入图片描述"><br> 可以用它来实现虚拟相机的镜头切换，<br> <img src="https://images2.imgbox.com/d5/a0/FuAikQae_o.gif" alt="请添加图片描述" width="800"><br> 也可以用来实现机关触发（比如执行<code>TimeLine</code>）</p> 
<p><img src="https://images2.imgbox.com/a6/00/lW3bb0NT_o.gif" alt="请添加图片描述" width="800"><br> 插件中还有一个<code>Anywhere Door</code>（任意门）场景，用的就是<code>CinemachineTriggerAction</code>触发器来实现两个<code>世界</code>的无缝穿越的，挺有意思的，效果如下</p> 
<p><img src="https://images2.imgbox.com/65/9b/9r1tGz8f_o.gif" alt="请添加图片描述" width="800"></p> 
<p>下面讲一下<code>CinemachineTriggerAction</code>组件的参数设置。</p> 
<h6><a id="231Is_Trigger_574"></a>2.3.1、碰撞体勾选Is Trigger</h6> 
<p>我们可以打开<code>CinemachineTriggerAction.cs</code>查看源码，里面其实就是使用<code>OnTriggerXXX</code>来检测碰撞，然后执行对应的响应方法，</p> 
<p><img src="https://images2.imgbox.com/1a/dc/D5tmxZNe_o.png" alt="在这里插入图片描述"><br> 注意使用<code>CinemachineTriggerAction</code>的物体上，需要带<code>Collider</code>，并且勾选<code>Is Trigger</code>，如下<br> <img src="https://images2.imgbox.com/41/6c/RNP5240r_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="232_580"></a>2.3.2、设置过滤</h6> 
<p>我们可以设定<code>Layer Mask</code>、<code>With Tag</code>和<code>Without Tag</code>进行过滤，<br> <img src="https://images2.imgbox.com/81/46/BkUiVLio_o.png" alt="在这里插入图片描述"><br> 只有通过过滤器的检测才能触发逻辑，<br> <img src="https://images2.imgbox.com/73/bd/v4x1amt5_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="233Skip_First_585"></a>2.3.3、设置Skip First</h6> 
<p><code>Skip First</code>可以用来跳过前面<code>N</code>此的触发，比如第一次进入时不想触发逻辑，则可以把<code>Skip First</code>设置为<code>1</code>，如果想要每次都触发，则把<code>Skip First</code>设置为<code>0</code>，并勾选<code>Repeating</code>，<br> <img src="https://images2.imgbox.com/b6/35/6eqVjIM9_o.png" alt="在这里插入图片描述"><br> <code>Skip First</code>逻辑如下<br> <img src="https://images2.imgbox.com/7d/f4/EVFDyJs5_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="234On_Object_Enter_590"></a>2.3.4、设置On Object Enter响应</h6> 
<p>进入触发器，触发响应逻辑，我们可以设置要执行的行为，<br> <img src="https://images2.imgbox.com/fe/41/Ffy42mXC_o.png" alt="在这里插入图片描述"><br> 支持的行为如下<br> <img src="https://images2.imgbox.com/bd/46/zTrpYpka_o.png" alt="在这里插入图片描述"></p> 
<table><thead><tr><th align="left">响应行为</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Custom</td><td align="left">自定义，使用组件里的<code>Event()</code>自定义触发函数</td></tr><tr><td align="left">Priority Boost</td><td align="left">增加目标虚拟相机的优先级，并把虚拟相机推入优先队列顶部</td></tr><tr><td align="left">Activate</td><td align="left">激活虚拟相机，并把虚拟相机推入优先队列顶部</td></tr><tr><td align="left">Deactive</td><td align="left">禁用目标物体，即执行SetActive(false)</td></tr><tr><td align="left">Enable</td><td align="left">激活目标组件，即设置组件的 enabled 为 true</td></tr><tr><td align="left">Disable</td><td align="left">禁用目标组件，即设置组件的 enabled 为 false</td></tr><tr><td align="left">Play</td><td align="left">播放Timeline</td></tr><tr><td align="left">Stop</td><td align="left">停止Timeline</td></tr></tbody></table> 
<p>同理，物体离开触发器会触发<code>On Object Exit</code>，我们也可以设置对应的响应行为，<br> <img src="https://images2.imgbox.com/01/3f/uRzqh4gl_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="6Dolly_Group_610"></a>八、案例6：多目标追踪，Dolly Group场景</h4> 
<h5><a id="1_611"></a>1、场景演示</h5> 
<p>双击打开<code>Dolly Group</code>场景，<br> <img src="https://images2.imgbox.com/d7/a5/pIlSSVM3_o.png" alt="在这里插入图片描述"><br> 运行效果如下</p> 
<p><img src="https://images2.imgbox.com/c4/9b/aTnrahbe_o.gif" alt="请添加图片描述" width="800"></p> 
<h5><a id="2_617"></a>2、组件参数</h5> 
<p>这个场景使用了一个<code>Timeline</code>来控制虚拟相机的移动，虚拟相机<code>LookAt</code>的目标是一个<code>TargetGroup</code>物体，<br> <img src="https://images2.imgbox.com/58/13/N9uY2H2f_o.png" alt="在这里插入图片描述"></p> 
<p>这个<code>TargetGroup</code>物体上挂着<code>CinemachineTargetGrouop</code>组件，通过它可以实现虚拟相机同时追踪多个物体的效果（原理是动态调整相机的<code>Field Of View</code>来确保多个物体都在画面以内），参数比较简单，主要是设置多个对象物体到列表中即可，<br> <img src="https://images2.imgbox.com/4e/0e/YaahYmoX_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_624"></a>九、其他案例</h4> 
<p>我感觉我写得太详细了，不知不觉本文内容已经非常长了，再写下去感觉没有同学能耐心看完了，其他场景案例我这里就不挨个讲解了，大家可以自己玩玩看。</p> 
<h6><a id="1BOSSBossCam_626"></a>1、打BOSS视角：BossCam场景</h6> 
<p><img src="https://images2.imgbox.com/f6/98/JGTpCY2h_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="2DualTarget_628"></a>2、双重目标：DualTarget场景</h6> 
<p><img src="https://images2.imgbox.com/dc/e7/MndsZTTD_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="3FadeOutNearbyObjects_630"></a>3、近物透明，FadeOutNearbyObjects场景</h6> 
<p><img src="https://images2.imgbox.com/8a/88/wzEYF2o5_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="43rdPersonWithAimMode_632"></a>4、第三人称瞄准，3rdPersonWithAimMode场景</h6> 
<p><img src="https://images2.imgbox.com/d9/b7/7jrJK8GQ_o.gif" alt="请添加图片描述" width="800"></p> 
<h6><a id="5Impulse_637"></a>5、镜头震动，Impulse场景</h6> 
<p><img src="https://images2.imgbox.com/4c/e2/YIR9IwlX_o.gif" alt="请添加图片描述" width="800"></p> 
<h4><a id="_641"></a>十、完毕</h4> 
<p>好了，不写了不写了，先到这里吧~<br> 我是林新发，<a href="https://blog.csdn.net/linxinfa">https://blog.csdn.net/linxinfa</a><br> 一个在小公司默默奋斗的<code>Unity</code>开发者，希望可以帮助更多想学<code>Unity</code>的人，共勉~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5dceb1f932345cf02517dbb9661c786/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql知识合集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d063ff971ca49bacd5e76ce2e659b639/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux初探——linux怎么将一个文件移动到另一个目录下</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>