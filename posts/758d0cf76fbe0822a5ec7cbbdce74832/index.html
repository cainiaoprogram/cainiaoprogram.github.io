<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java的字节流InputStream（字节输入流），OutputStream（字节输出流） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java的字节流InputStream（字节输入流），OutputStream（字节输出流）" />
<meta property="og:description" content="IO 流简介 IO 即 Input/Output，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。
Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。
InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 字节流 InputStream（字节输入流） InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。 InputStream 常用方法：
read()：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 -1 ，表示文件结束。read(byte b[ ]) : 从输入流中读取一些字节存储到数组 b 中。如果数组 b 的长度为零，则不读取。如果没有可用字节读取，返回 -1。如果有可用字节读取，则最多读取的字节数最多等于 b.length ， 返回读取的字节数。这个方法等价于 read(b, 0, b.length)。read(byte b[], int off, int len)：在read(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。skip(long n)：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。available()：返回输入流中可以读取的字节数。close()：关闭输入流释放相关的系统资源。 从 Java 9 开始，InputStream 新增加了多个实用的方法：
readAllBytes()：读取输入流中的所有字节，返回字节数组。readNBytes(byte[] b, int off, int len)：阻塞直到读取 len 个字节。transferTo(OutputStream out)：将所有字节从一个输入流传递到一个输出流。 FileInputStream 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/758d0cf76fbe0822a5ec7cbbdce74832/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-02T17:40:40+08:00" />
<meta property="article:modified_time" content="2023-11-02T17:40:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java的字节流InputStream（字节输入流），OutputStream（字节输出流）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="io-流简介">IO 流简介</h2> 
<p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p> 
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p> 
<ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul> 
<h2 id="字节流">字节流</h2> 
<h3 id="inputstream-字节输入流">InputStream（字节输入流）</h3> 
<h4><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</h4> 
<p><code>InputStream</code> 常用方法：</p> 
<ul><li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li><li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li><li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li><li><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li><li><code>available()</code>：返回输入流中可以读取的字节数。</li><li><code>close()</code>：关闭输入流释放相关的系统资源。</li></ul> 
<p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p> 
<ul><li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li><li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code>len</code> 个字节。</li><li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li></ul> 
<p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p> 
<p><code>FileInputStream</code> 代码示例：</p> 
<pre><code class="language-java">try (InputStream fis = new FileInputStream("input.txt")) {
    System.out.println("Number of remaining bytes:"
            + fis.available());
    int content;
    long skip = fis.skip(2);
    System.out.println("The actual number of bytes skipped:" + skip);
    System.out.print("The content read from file:");
    while ((content = fis.read()) != -1) {
        System.out.print((char) content);
    }
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre> 
<p><img alt="" height="540" src="https://images2.imgbox.com/ea/8d/y67KTfii_o.png" width="1015">输出：</p> 
<pre><code class="language-java">Number of remaining bytes:11
The actual number of bytes skipped:2
The content read from file:JavaGuide
</code></pre> 
<p>不过，一般我们是不会直接单独使用 <code>FileInputStream</code> ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流，后文会讲到）来使用。</p> 
<p>像下面这段代码在我们的项目中就比较常见，我们通过 <code>readAllBytes()</code> 读取输入流所有字节并将其直接赋值给一个 <code>String</code> 对象。</p> 
<pre><code class="language-java">// 新建一个 BufferedInputStream 对象
BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("input.txt"));
// 读取文件的内容并复制到 String 对象中
String result = new String(bufferedInputStream.readAllBytes());
System.out.println(result);
</code></pre> 
<p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code> 。</p> 
<pre><code class="language-java">FileInputStream fileInputStream = new FileInputStream("input.txt");
//必须将fileInputStream作为构造参数才能使用
DataInputStream dataInputStream = new DataInputStream(fileInputStream);
//可以读取任意具体的类型数据
dataInputStream.readBoolean();
dataInputStream.readInt();
dataInputStream.readUTF();
</code></pre> 
<h3 id="outputstream-字节输出流">OutputStream（字节输出流）</h3> 
<p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p> 
<p><code>OutputStream</code> 常用方法：</p> 
<ul><li><code>write(int b)</code>：将特定字节写入输出流。</li><li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li><li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li><li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li><li><code>close()</code>：关闭输出流释放相关的系统资源。</li></ul> 
<p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p> 
<p><code>FileOutputStream</code> 代码示例：</p> 
<pre><code class="language-java">try (FileOutputStream output = new FileOutputStream("output.txt")) {
    byte[] array = "JavaGuide".getBytes();
    output.write(array);
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre> 
<p><img alt="" height="458" src="https://images2.imgbox.com/b2/04/ZeqgDLa2_o.png" width="976">类似于 <code>FileInputStream</code>，<code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code>（字节缓冲输出流，后文会讲到）来使用。</p> 
<pre><code class="language-java">FileOutputStream fileOutputStream = new FileOutputStream("output.txt");
BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream)
</code></pre> 
<p><strong><code>DataOutputStream</code></strong> 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileOutputStream</code> 。</p> 
<pre><code class="language-java">// 输出流
FileOutputStream fileOutputStream = new FileOutputStream("out.txt");
DataOutputStream dataOutputStream = new DataOutputStream(fileOutputStream);
// 输出任意数据类型
dataOutputStream.writeBoolean(true);
dataOutputStream.writeByte(1);
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4aa77a5a50a9356d1052123077f42561/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小猫爪：S32K3学习笔记02-S32K3之FlexCAN</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6bad4e4f80eaf89eea2efcd127391b1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux内核SPI子系统驱动框架详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>