<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python方法：@staticmethod和@classmethod - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python方法：@staticmethod和@classmethod" />
<meta property="og:description" content="目录
一、@staticmethod和@classmethod的基本概念
二、@staticmethod和@classmethod的区别
三、@classmethod的应用场景
四、@staticmethod的应用场景
五、代码实现和对比
5.1 不使用@staticmethod和@classmethod
5.2 使用@classmethod
5.3 使用staticmethod
5.4 @classmethod与@staticmethod对比
小结
一、@staticmethod和@classmethod的基本概念 在常用的Python方法中，我们调用类的方法，每次都需要进行实例化，然后用实例化.方法进行调用。Python方法@staticmethod和@classmethod，可以被类直接调用，也可以被所有实例化对象共享。只要在某个方法前面加上@staticmethod或@classmethod就可以了，该方法通过调用staticmethod并且这样子还有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁。
二、@staticmethod和@classmethod的区别 两种方法的区别
既然@staticmethod和@classmethod都可以直接类名.方法名()来调用，那他们之间又有什么区别呢？别急，看下面
首先 staticmethod（静态方法），需要一个装饰器语法(@staticmethod)将一个普通方法转换为静态方法classmethod（类方法），需要一个装饰器语法（@classmethod）将一个普通方法转换为类方法然后 @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。最后 @staticmethod没有表示自身对象的self参数和自身类的cls参数，所以如果在@staticmethod中要调用到这个类的一些属性方法，如果我们使用实例化对象.方法名的时候，实例被忽略而类被使用，所以实际上还是类调用。而@classmethod因为有cls参数，当然是可以实例化对象.方法名，来避免硬编码。 三、@classmethod的应用场景 @classmethod 是 Python 中的一个装饰器（decorator），用于定义类方法。类方法是与类相关联的方法，而不是与类的实例相关联的方法。类方法在调用时，第一个参数是类本身，通常将其命名为 cls。使用 @classmethod 装饰器可以让 Python 解释器知道这是一个类方法，从而正确地处理它。
类方法可以通过类名调用，也可以通过类的实例调用。当使用类名调用类方法时，会自动将类作为第一个参数传递给方法。当使用类的实例调用类方法时，同样会自动将类作为第一个参数传递给方法。
四、@staticmethod的应用场景 @staticmethod也是一个Python中的装饰器（decorator），用于标记一个静态方法。
静态方法是一种在类中定义的方法，它与实例无关，因此可以在不创建类实例的情况下调用。与普通方法不同，静态方法没有self参数，因此它不能访问实例属性和方法。
在Python中，使用@staticmethod装饰器可以将一个方法转换为静态方法，即使该方法定义在类中。使用静态方法的主要优点是可以在不创建类实例的情况下调用该方法，从而提高代码的灵活性和可重用性。
五、代码实现和对比 5.1 不使用@staticmethod和@classmethod class Cat: def __init__(self,i): print(&#39;__init__: %d&#39;%i) @staticmethod def eat(): print(&#39;@staticmethod不需要self参数，实例调用函数实例不传入做参数&#39;) c = Cat(1) Cat.eat() 输出结果：
__init__: 1 @staticmethod不需要self参数，实例调用函数实例不传入做参数 5.2 使用@classmethod class Cat: def __init__(self,i): print(&#39;__init__: %d&#39;%i) @classmethod def eat(cls): print(&#39;@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数&#39;) c = Cat(1) Cat." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c4d1f17a4911bae97d174a34b8bc23a9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-29T10:19:58+08:00" />
<meta property="article:modified_time" content="2023-03-29T10:19:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python方法：@staticmethod和@classmethod</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%40staticmethod%E5%92%8C%40classmethod%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%40staticmethod%E5%92%8C%40classmethod%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">一、@staticmethod和@classmethod的基本概念</a></p> 
<p id="%E4%BA%8C%E3%80%81%40staticmethod%E5%92%8C%40classmethod%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%40staticmethod%E5%92%8C%40classmethod%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">二、@staticmethod和@classmethod的区别</a></p> 
<p id="%E4%B8%89%E3%80%81%40classmethod%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%40classmethod%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">三、@classmethod的应用场景</a></p> 
<p id="%E5%9B%9B%E3%80%81%40staticmethod%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%40staticmethod%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">四、@staticmethod的应用场景</a></p> 
<p id="%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94" rel="nofollow">五、代码实现和对比</a></p> 
<p id="5.1%20%E4%B8%8D%E4%BD%BF%E7%94%A8%40staticmethod%E5%92%8C%40classmethod-toc" style="margin-left:40px;"><a href="#5.1%20%E4%B8%8D%E4%BD%BF%E7%94%A8%40staticmethod%E5%92%8C%40classmethod" rel="nofollow">5.1 不使用@staticmethod和@classmethod</a></p> 
<p id="5.2%20%E4%BD%BF%E7%94%A8%40classmethod-toc" style="margin-left:40px;"><a href="#5.2%20%E4%BD%BF%E7%94%A8%40classmethod" rel="nofollow">5.2 使用@classmethod</a></p> 
<p id="5.3%20%E4%BD%BF%E7%94%A8staticmethod-toc" style="margin-left:40px;"><a href="#5.3%20%E4%BD%BF%E7%94%A8staticmethod" rel="nofollow">5.3 使用staticmethod</a></p> 
<p id="5.4%20%40classmethod%E4%B8%8E%40staticmethod%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#5.4%20%40classmethod%E4%B8%8E%40staticmethod%E5%AF%B9%E6%AF%94" rel="nofollow">5.4 @classmethod与@staticmethod对比</a></p> 
<p id="%E5%B0%8F%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%B0%8F%E7%BB%93" rel="nofollow">小结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%40staticmethod%E5%92%8C%40classmethod%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">一、@staticmethod和@classmethod的基本概念</h2> 
<p>在常用的Python方法中，我们调用类的方法，每次都需要进行实例化，然后用实例化.方法进行调用。Python方法@staticmethod和@classmethod，可以被类直接调用，也可以被所有实例化对象共享。只要在某个方法前面加上@staticmethod或@classmethod就可以了，该方法通过调用staticmethod并且这样子还<strong>有利于组织代码</strong>，把某些应该属于某个类的函数给放到那个类里去，同时<strong>有利于命名空间的整洁</strong>。</p> 
<h2 id="%E4%BA%8C%E3%80%81%40staticmethod%E5%92%8C%40classmethod%E7%9A%84%E5%8C%BA%E5%88%AB">二、@staticmethod和@classmethod的区别</h2> 
<p>两种方法的区别</p> 
<p>既然<code>@staticmethod</code>和<code>@classmethod</code>都可以直接类名.方法名()来调用，那他们之间又有什么区别呢？别急，看下面</p> 
<ul><li><strong>首先</strong> 
  <ul><li><code>staticmethod</code><strong>（静态方法）</strong>，需要一个装饰器语法(<code>@staticmethod</code>)将一个普通方法转换为静态方法</li><li><code>classmethod</code><strong>（类方法）</strong>，需要一个装饰器语法（<code>@classmethod</code>）将一个普通方法转换为类方法</li></ul></li><li><strong>然后</strong> 
  <ul><li><code>@staticmethod</code>不需要表示自身对象的<code>self</code>和自身类的<code>cls</code>参数，就跟使用函数一样。</li><li><code>@classmethod</code>也不需要<code>self</code>参数，但第一个参数需要是表示自身类的<code>cls</code>参数。</li></ul></li><li><strong>最后</strong> 
  <ul><li><code>@staticmethod</code>没有表示自身对象的<code>self</code>参数和自身类的<code>cls</code>参数，所以如果在<code>@staticmethod</code>中要调用到这个类的一些属性方法，如果我们使用实例化对象.方法名的时候，实例被忽略而类被使用，所以实际上还是类调用。</li><li>而<code>@classmethod</code>因为有<code>cls</code>参数，当然是可以实例化对象.方法名，来避免硬编码。</li></ul></li></ul> 
<h2 id="%E4%B8%89%E3%80%81%40classmethod%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">三、@classmethod的应用场景</h2> 
<p>@classmethod 是 Python 中的一个装饰器（decorator），用于定义类方法。类方法是与类相关联的方法，而不是与类的实例相关联的方法。类方法在调用时，第一个参数是类本身，通常将其命名为 cls。使用 @classmethod 装饰器可以让 Python 解释器知道这是一个类方法，从而正确地处理它。</p> 
<p>类方法可以通过类名调用，也可以通过类的实例调用。当使用类名调用类方法时，会自动将类作为第一个参数传递给方法。当使用类的实例调用类方法时，同样会自动将类作为第一个参数传递给方法。</p> 
<h2 id="%E5%9B%9B%E3%80%81%40staticmethod%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">四、@staticmethod的应用场景</h2> 
<p>@staticmethod也是一个Python中的<a href="https://so.csdn.net/so/search?q=%E8%A3%85%E9%A5%B0%E5%99%A8&amp;spm=1001.2101.3001.7020" title="装饰器">装饰器</a>（decorator），用于标记一个静态方法。</p> 
<p>静态方法是一种在类中定义的方法，它与实例无关，因此可以在不创建类实例的情况下调用。与普通方法不同，静态方法没有self参数，因此它<strong>不能访问实例属性和方法</strong>。</p> 
<p>在Python中，使用@staticmethod装饰器可以将一个方法转换为静态方法，即使该方法定义在类中。使用静态方法的主要优点是可以在不创建类实例的情况下调用该方法，从而提高代码的灵活性和可重用性。</p> 
<h2 id="%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94">五、代码实现和对比</h2> 
<h3 id="5.1%20%E4%B8%8D%E4%BD%BF%E7%94%A8%40staticmethod%E5%92%8C%40classmethod">5.1 不使用@staticmethod和@classmethod</h3> 
<pre><code class="language-python">class Cat:
    def __init__(self,i):
        print('__init__: %d'%i)
    @staticmethod
    def eat():
        print('@staticmethod不需要self参数，实例调用函数实例不传入做参数')
        
c = Cat(1)
Cat.eat()</code></pre> 
<p> 输出结果：</p> 
<pre><code class="language-python">__init__: 1
@staticmethod不需要self参数，实例调用函数实例不传入做参数</code></pre> 
<h3 id="5.2%20%E4%BD%BF%E7%94%A8%40classmethod">5.2 使用@classmethod</h3> 
<pre><code class="language-python">class Cat:
    def __init__(self,i):
        print('__init__: %d'%i)
    @classmethod
    def eat(cls):
        print('@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数')
        
c = Cat(1)
Cat.eat()</code></pre> 
<p>输出结果：</p> 
<pre><code class="language-python">__init__: 1
@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数</code></pre> 
<h3 id="5.3%20%E4%BD%BF%E7%94%A8staticmethod">5.3 使用staticmethod</h3> 
<pre><code class="language-python">class Cat:
    def __init__(self,i):
        print('__init__: %d'%i)
    @classmethod
    def eat(cls):
        print('@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数')
        
c = Cat(1)
Cat.eat()</code></pre> 
<p>输出结果：</p> 
<pre><code class="language-python">__init__: 1
@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数</code></pre> 
<h3 id="5.4%20%40classmethod%E4%B8%8E%40staticmethod%E5%AF%B9%E6%AF%94">5.4 @classmethod与@staticmethod对比</h3> 
<p>@classmethod方法</p> 
<pre><code class="language-python">class Cat:
    def __init__(self,i):
        print('__init__: %d'%i)
    @classmethod
    def eat(cls,name):
        print(name,'@classmethod因为有cls参数，当然是可以实例化对象.方法名，来避免硬编码')
        print('@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数')
        
c = Cat(1).eat('fish')
Cat.eat('fish')   # 因为被@classmethod装饰的函数，可以直接被类本身调用</code></pre> 
<p>输出结果：</p> 
<pre><code class="language-python">__init__: 1
fish @classmethod因为有cls参数，当然是可以实例化对象.方法名，来避免硬编码
@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数
fish @classmethod因为有cls参数，当然是可以实例化对象.方法名，来避免硬编码
@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数</code></pre> 
<p> @staticmethod方法</p> 
<pre><code class="language-python">class Cat:
    def __init__(self,i):
        print('__init__: %d'%i)
    @staticmethod
    def eat(name):
        print(name,'@staticmethod没有表示自身对象的self参数和自身类的cls参数，实例化对象.方法名，实例被忽略而类被使用，所以实际上还是类调用')
        print('@staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样')
        
c = Cat(1).eat('fish')
Cat.eat('fish')  # 静态方法无需实例化,也可以实例化后调用</code></pre> 
<p>输出结果：</p> 
<pre><code class="language-python">__init__: 1
fish @classmethod因为有cls参数，当然是可以实例化对象.方法名，来避免硬编码
@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数
fish @classmethod因为有cls参数，当然是可以实例化对象.方法名，来避免硬编码
@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数</code></pre> 
<h2 id="%E5%B0%8F%E7%BB%93">小结</h2> 
<ul><li> <p><code>classmethod</code>尤其适合用在当我们需要在创建真正的类实例之前做一些预设置的情况，因为实例建立之前显然你是不能使用实例方法的，你只能使用<code>classmethod，</code>这样做的另一个好处就是你以后重构类的时候不必要修改构造函数，只需要额外添加你要处理的函数，然后使用装饰符<code>@classmethod</code>就可以了。相当于我们拥有了多样化的构造函数。</p> </li><li> <p>Python使用类时，通常需要为对象初始化绑定方法，绑定方法同样是对象，但是创建他们需要成本，而<code>staticmethod</code>就可以避免这些。</p> </li><li> <p><code>classmethod</code>因为有<code>cls</code>参数，可以调用类的属性，类的方法等，避免了使用类名硬编码。<code>classmethod</code>既具有普通实例方法访问类名称空间的能力，又具有静态方法随意使用的灵活性。</p> </li><li> <p>实例属性由实例更改，不会影响类属性。而类属性则可以由类方法 <code>(classmethod)</code>来更改。</p> </li></ul> 
<p></p> 
<p></p> 
<p></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0de683d23c440a4f9350304fea8bae7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">记录@ConfigurationProperties注解注入集合配置的报错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb5808dfc08f60f86420b6e739e311f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何本地部署基于stable-diffusion的AI绘画（jupyter，python实现，详细，附代码）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>