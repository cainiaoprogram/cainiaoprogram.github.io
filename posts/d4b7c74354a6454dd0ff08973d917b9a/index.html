<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ContentProvider call实现跨进程通信 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ContentProvider call实现跨进程通信" />
<meta property="og:description" content="github.com/wengeoo/PEvent.git 1、ContentProvider query 作为 Android 四大基础组件之一的 ContentProvider 本来它的作用只是提供内容性质的跨进程访问。APP-A通过APP-B的ContentProvider相关实现，可以获取B的向外暴露的SQL或者SP数据，但是A如何通知B去更新ContentProvider的相关内容？
传统方式有1：广播；2：AIDL，弊端是使用流程相对繁琐 2、ContentProvider call 在 API 11 (Android 3.0) 中，ContentProvider 加入了一个新的方法，可以用来进行跨进程的方法调用，ContentProvider 中这个方法的定义如下：
Bundle call(String method, String arg, Bundle extras)
看看具体实现
A中实现
private void update(String status) { getContext().getContentResolver().call(ACCOUNT_URI, &#34;STATUS&#34;, status, new Bundle()); } B中实现
@Override public Bundle call(String method, String arg, Bundle extras) { if (&#34;STATUS&#34;.equals(method)) { //dosomething } return null; } A中就能触发B的具体逻辑操作，类似复写，B也可以触发A的操作
3、继续扩展 我们实现一个基础库，通过ContentProvider&#43;反射实现A调用B接口，B调用A接口，简化使用流程
3.1、实现一个基础IContentProvider，A/B中都继承
@Nullable @Override public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle in) { if (in == null) { return null; } long start = SystemClock." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d4b7c74354a6454dd0ff08973d917b9a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-07T11:02:41+08:00" />
<meta property="article:modified_time" content="2023-11-07T11:02:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ContentProvider call实现跨进程通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><a href="https://github.com/wengeoo/PEvent.git" title="github.com/wengeoo/PEvent.git">github.com/wengeoo/PEvent.git</a></h3> 
<h3>1、ContentProvider query</h3> 
<p> 作为 Android 四大基础组件之一的 ContentProvider 本来它的作用只是提供内容性质的跨进程访问。APP-A通过APP-B的ContentProvider相关实现，可以获取B的向外暴露的SQL或者SP数据，但是A如何通知B去更新ContentProvider的相关内容？</p> 
<p> 传统方式有1：广播；2：AIDL，弊端是使用流程相对繁琐   </p> 
<p></p> 
<h3>2、ContentProvider call</h3> 
<p>在 API 11 (Android 3.0) 中，ContentProvider 加入了一个新的方法，可以用来进行跨进程的方法调用，ContentProvider 中这个方法的定义如下：</p> 
<p>Bundle call(String method, String arg, Bundle extras)</p> 
<p>看看具体实现</p> 
<p>A中实现</p> 
<pre><code> private void update(String status) {
        getContext().getContentResolver().call(ACCOUNT_URI, "STATUS", status, new Bundle());
    }
</code></pre> 
<p>B中实现</p> 
<pre><code>    @Override
    public Bundle call(String method, String arg, Bundle extras) {
      if ("STATUS".equals(method)) {
            //dosomething
        }
        return null;
    }
</code></pre> 
<p>A中就能触发B的具体逻辑操作，类似复写，B也可以触发A的操作</p> 
<p></p> 
<h3>3、继续扩展</h3> 
<p>我们实现一个基础库，通过ContentProvider+反射实现A调用B接口，B调用A接口，简化使用流程</p> 
<p>3.1、实现一个基础IContentProvider，A/B中都继承</p> 
<pre><code>@Nullable
    @Override
    public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle in) {
        if (in == null) {
            return null;
        }
        long start = SystemClock.elapsedRealtime();
        Bundle response = new Bundle();
        in.setClassLoader(Par.class.getClassLoader());
        Parcelable returnResponse = in.getParcelable(PEVENT_KEY_RESPONSE);
        response.putParcelable(PEVENT_KEY_RESPONSE, returnResponse);
        try {
            String calling = getCallingPackage();
            long callingTime = SystemClock.elapsedRealtime();
            PEventLog.e(TAG, "used time calling:" + (callingTime - start));
            if (!TextUtils.isEmpty(calling)) {
                in.putString(PEVENT_KEY_CALLING_PACKAGE, calling);
            }
            String route = in.getString(PEVENT_KEY_ROUTE);
            int flags = in.getInt(PEVENT_KEY_FLAGS);
            if (TextUtils.isEmpty(route)) {
                throw new NotFoundRouteException(route + " was not found");
            }
            ArrayDeque&lt;MethodInvoker&gt; callers = PServiceManager.getInstance().lookupMethods(route);
            if (callers == null || callers.isEmpty()) {
                throw new NotFoundRouteException(route + " was not found");
            }
            Iterator&lt;MethodInvoker&gt; iterators = callers.iterator();
            while (iterators.hasNext()) {
                MethodInvoker methodInvoker = iterators.next();
                methodInvoker.invoke(in, response);
            }
            response.putInt(PEVENT_KEY_RESPONSE_CODE, PEVENT_RESPONSE_RESULE_SUCCESS);
        } catch (NoSuchMethodException | InvocationTargetException e) {
            e.printStackTrace();
            response.putInt(PEVENT_KEY_RESPONSE_CODE, PEVENT_RESPONSE_RESULE_NO_SUCH_METHOD);
        } catch (NotFoundRouteException e) {
            response.putInt(PEVENT_KEY_RESPONSE_CODE, PEVENT_RESPONSE_RESULE_NOT_FOUND_ROUTE);
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
            response.putInt(PEVENT_KEY_RESPONSE_CODE, PEVENT_RESPONSE_RESULE_ILLEGALACCESS);
        } catch (Throwable e) {
            e.printStackTrace();
            response.putInt(PEVENT_KEY_RESPONSE_CODE, PEVENT_RESPONSE_RESULE_REMOTE_EXCEPTION);
        }
        return response;
    }</code></pre> 
<p>A中</p> 
<pre><code>PEvent pEvent = PEvent.newBuilder(MainActivity.this).setAuthority("com.pevent.example").build();
Bundle bundle = pEvent.route("/show/age").withString("age", "20").post();</code></pre> 
<pre><code>    Bundle post(@NonNull Bundle in) {
        ContentResolver contentResolver = mContext.getContentResolver();
        Bundle out = null;
        try {
            out = contentResolver.call(base, "", null, in);
            parseReponse(in, out);
        } catch (Throwable e) {
            e.printStackTrace();
        }
        return out;
    }</code></pre> 
<p>B中</p> 
<pre><code>    @MainThread
    @Route("/show/age")
    public void showAge(final Bundle in, Bundle out) {
        out.putString("age", "10");
        String name = in.getString("age");
        tv.setText(name);
    }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8dd920f7668492f48f84ca2966b6f6c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【深度学习】Python爬取豆瓣实现影评分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38cd7f314e0c083ed1417302f8f4099f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">node.js连接mysql出现错误：ER_NOT_SUPPORTED_AUTH_MODE Client does not support authentication protocol..</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>