<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM笔记 —— 垃圾回收（GC）详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM笔记 —— 垃圾回收（GC）详解" />
<meta property="og:description" content="一、垃圾回收的分类 针对HotSpot JVM的实现，它里面的GC其实准确分类只有两大种:
Partial GC：部分收集模式
Young GC：只收集年轻代的GCOld GC：只收集老年代的GC。只有CMS中有这个模式。Mixed GC：收集整个年轻代以及部分老年代的GC。只有G1有这个模式 Full GC：收集整个堆和方法区。
堆是垃圾回收的主要区域，方法区很少会被回收。
本文所讨论的均指HotSpot JVM
二、死亡对象判断方法 堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。
1. 引用计数法 给每个对象中添加一个引用计数器：
每当有一个地方引用它，计数器就加 1；每当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。 但是引用计数法很难解决对象之间循环引用的问题，因此目前主流的虚拟机中并没有选择这个算法。
2. 根可达性分析算法 这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。
下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。
哪些对象可以作为 GC Roots 呢？ 虚拟机栈(栈帧中的本地变量表)中引用的对象本地方法栈(Native 方法)中引用的对象类静态常量引用的对象常量池中被引用的对象所有被同步锁持有的对象 对象被回收前如果该对象重写了finaize()方法则需先执行此方法后才能被回收。Object 类中的 finalize 方法一直被认为是一个糟糕的设计，影响了 Java 语言的安全和 GC 的性能，JDK9 版本及后续版本中各个类中的 finalize 方法会被逐渐弃用移除。
参考：Java基础知识点之finalize方法详解
三、引用类型分类 无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。
Java中将引用分为了强引用、软引用、弱引用、虚引用四种。非强引用通常用来指向某些只需要暂时缓存的数据。
1. 强引用 引用变量默认就是强引用，以下其它三种将引用通过特殊包装的才能形成其它引用。
强引用的对象在GC Roots可达时不会被回收。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/498e6d295df6c8f870318ac73e3264ce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-07T22:11:58+08:00" />
<meta property="article:modified_time" content="2023-10-07T22:11:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM笔记 —— 垃圾回收（GC）详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、垃圾回收的分类</h3> 
<p>针对HotSpot JVM的实现，它里面的GC其实准确分类只有两大种:</p> 
<ul><li> <p><strong>Partial GC</strong>：部分收集模式</p> 
  <ul><li>Young GC：只收集年轻代的GC</li><li>Old GC：只收集老年代的GC。只有CMS中有这个模式。</li><li>Mixed GC：收集整个年轻代以及部分老年代的GC。只有G1有这个模式</li></ul> </li><li> <p><strong>Full GC</strong>：收集整个堆和方法区。</p> </li></ul> 
<blockquote> 
 <p>堆是垃圾回收的主要区域，方法区很少会被回收。<br> 本文所讨论的均指HotSpot JVM</p> 
</blockquote> 
<h3><a id="_11"></a>二、死亡对象判断方法</h3> 
<p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p> 
<h4><a id="1__13"></a>1. 引用计数法</h4> 
<p>给每个对象中添加一个引用计数器：</p> 
<ul><li>每当有一个地方引用它，计数器就加 1；</li><li>每当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul> 
<p><strong>但是引用计数法很难解决对象之间循环引用的问题，因此目前主流的虚拟机中并没有选择这个算法。</strong></p> 
<p><img src="https://images2.imgbox.com/e5/98/L8PCYHat_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2__24"></a>2. 根可达性分析算法</h4> 
<p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p> 
<p>下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。<br> <img src="https://images2.imgbox.com/31/b2/IlRIPuM3_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_GC_Roots__29"></a>哪些对象可以作为 GC Roots 呢？</h5> 
<ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>类静态常量引用的对象</li><li>常量池中被引用的对象</li><li>所有被同步锁持有的对象</li></ul> 
<blockquote> 
 <p>对象被回收前如果该对象重写了finaize()方法则需先执行此方法后才能被回收。Object 类中的 finalize 方法一直被认为是一个糟糕的设计，影响了 Java 语言的安全和 GC 的性能，JDK9 版本及后续版本中各个类中的 finalize 方法会被逐渐弃用移除。<br> 参考：<a href="https://www.cnblogs.com/xiaoxihahaha/articles/finalize.html" rel="nofollow">Java基础知识点之finalize方法详解</a></p> 
</blockquote> 
<h3><a id="_39"></a>三、引用类型分类</h3> 
<p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p> 
<p>Java中将引用分为了强引用、软引用、弱引用、虚引用四种。非强引用通常用来指向某些只需要暂时缓存的数据。</p> 
<h4><a id="1__43"></a>1. 强引用</h4> 
<p>引用变量默认就是强引用，以下其它三种将引用通过特殊包装的才能形成其它引用。<br> 强引用的对象在GC Roots可达时不会被回收。</p> 
<h4><a id="2__SoftReference_46"></a>2. 软引用 SoftReference</h4> 
<p>软引用是一种相对强引用弱化了一些的引用，用java.lang.ref.SoftReference实现，可以让对象豁免一些垃圾收集。在可达时，当系统内存充足的时不会被回收，系统内存不足时则会被回收。</p> 
<blockquote> 
 <p>注意：SoftReference引用本身是强引用，它内部的（T reference）才是真正的软引用字段，SoftReference就是一个装软引用的容器而已。下面的WeakReference和PhantomReference也是一样的。</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SoftReferenceDemo</span> <span class="token punctuation">{<!-- --></span> 
     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
         <span class="token class-name">Object</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
         <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> softReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取a指向对象的一个软引用，放在SoftReference对象中</span>
         <span class="token comment">//a和软引用指向同一个对象</span>
         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//java.lang.Object@4554617c</span>
         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>softReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//java.lang.Object@4554617c 10 </span>
         <span class="token comment">//内存够用，软引用不会被回收</span>
         a<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
         <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//内存够用不会自动gc，手动唤醒gc</span>
         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>softReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//java.lang.Object@4554617c 16 </span>
         <span class="token comment">//内存不够用时</span>
         <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>            <span class="token comment">//配置Xms和Xmx为5MB</span>
             <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//设置30MB超内存</span>
         <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
           <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>softReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//null，被回收</span>
 		 <span class="token punctuation">}</span> 
 	 <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>软引用的一个应用场景：一个应用需要读取大量的本地图片，如果每次读取都从硬盘读取会严重影响性能，如果一次性全部加载到内存，内存可能会溢出。可以使用软引用解决这个问题，使用一个HashMap来保存图片路径和图片对象管理的软引用之间的映射关系，内存不足时，JVM会自动回收缓存图片对象的占用空间，有效地避免了OOM问题。</p> 
<pre><code class="prism language-java"><span class="token comment">//Map&lt;图片路径，图片对象软引用&gt;，在系统内存不足时value所指向的对象会被回收</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SoftReference</span><span class="token punctuation">&lt;</span><span class="token class-name">Bitmap</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> imageCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SoftReference</span><span class="token punctuation">&lt;</span><span class="token class-name">Bitmap</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h4><a id="3__WeakReference_76"></a>3. 弱引用 WeakReference</h4> 
<p>弱引用需要用java.lang.ref.WeakReference实现，它比软引用的生存期更短，对于弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否够，都会回收该对象的占用内存。</p> 
<pre><code class="prism language-java"><span class="token class-name">Object</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> softReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取a指向对象的一个弱引用</span>
</code></pre> 
<p>Map中还有一个WeakHashMap，WeakHashMap就是一种弱引用的map，内部的key为弱引用，在GC时如果key指向的对象不存在其它强引用的情况下会被回收掉，而对于value的回收会在下一次操作map时回收掉，所以WeakHashMap适合缓存处理。</p> 
<h4><a id="4__PhantomReference_84"></a>4. 虚引用 PhantomReference</h4> 
<p>虚引用要通过java.lang.ref.PhantomReference类来实现，虚引用不会决定对象的生命周期，如果一个对象只有虚引用，就相当于没有引用，在任何时候都可能会被垃圾回收器回收。它不能单独使用也不能访问对象，虚引用必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态，仅仅是提供一种确保对象被finalize以后，做某些事情的机制。</p> 
<hr> 
<p><strong>因此总结如下</strong>，在一次GC中，用于可达性分析的GC Roots本身不会被回收，GC Roots引用链不可达对象的必然会被回收，而在引用链可达的情况中：</p> 
<ul><li>强引用的对象不会被回收</li><li>仅有软引用的对象在内存不足时会被回收</li><li>仅有弱引用或虚引用的对象必然会被回收</li></ul> 
<p><img src="https://images2.imgbox.com/e1/b7/Niph9aPV_o.png" alt="在这里插入图片描述"></p> 
<p>参考：<a href="https://zhuanlan.zhihu.com/p/145097711" rel="nofollow">JVM中如何理解强引用、软引用、弱引用、虚引用？</a><br> <a href="https://zhuanlan.zhihu.com/p/358015444" rel="nofollow">阿里面试：说说强引用、软引用、弱引用、虚引用吧</a></p> 
<h3><a id="_97"></a>四、什么是内存泄漏</h3> 
<p>严格来说，如果某些对象在程序中不会再被用到了，但是这些对象又无法被垃圾收集器回收（GC Roots以及其引用链可达的强引用对象），那么这些对象所占用的内存就处于平白浪费的状态了，这就的内存泄漏。如果这种情况可以累积，随着内存泄漏的增多，就会导致严重的性能问题甚至OOM。</p> 
<p>宽泛地说，实际情况中很多时候一些不太好的实践会导致对象的生命周期变得过长，比如不合理地进入了老年代，在老年代中堆积，等到Full GC时才能被回收，这种情况也可以叫“内存泄漏”。</p> 
<p>在实际场景中可大概分为以下几种情况：</p> 
<h4><a id="1__103"></a>1. 类变量中引用短期对象</h4> 
<p>类变量在垃圾回收时被作为GC Roots，而类变量的生命周期一般和JVM程序一致，只有方法区中的对应类被回收才有可能被回收。如果在类变量对象中引用很多短期内使用的对象，那么由于在GC Roots下被强引用，这些短期对象都得不到回收，就造成了内存泄漏。如下一个静态list的例子：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> test <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果object只是短期内需要使用的对象，那么如果这个方法一直被调用，就会造成内存泄漏</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">oomTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Object</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="2__116"></a>2. 各类连接泄漏</h4> 
<p>例如数据库连接。如果在获取数据库连接后没有正确的归还或关闭，导致每次访问都创建一个未关闭的连接，就导致了内存泄漏。</p> 
<p>案例：<a href="https://www.iteye.com/blog/syc-1506395">多线程访问数据库导致内存泄露的优化过程</a><br> <a href="https://blog.51cto.com/u_15659694/5755141" rel="nofollow">数据库连接池内存泄漏问题的分析和解决方案</a></p> 
<h4><a id="3_ThreadLocalremove_122"></a>3. ThreadLocal用完没有remove</h4> 
<h4><a id="4__123"></a>4. 内部类持有外部类</h4> 
<p>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p> 
<h4><a id="5_NIO_125"></a>5. 堆外内存泄漏（NIO）</h4> 
<h4><a id="6_hash_126"></a>6. 改变哈希集合关键字的hash值</h4> 
<p>当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p> 
<p>因为String是不可变类型，我们可以放心地把String 存入HashSet，或者把String当做HashMap的key值。</p> 
<h4><a id="7__131"></a>7. 缓存泄漏</h4> 
<p>内存泄漏的一个常见来源是缓存，一旦你把对象引用放入到缓存中，就很容易遗忘。比如:之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存(内存)中，测试环境只有几百条数据，但是生产环境有几百万的数据。<br> 对于这个问题，可以使用WeakHashMap（弱引用）代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p> 
<p>参考：<a href="https://blog.csdn.net/weixin_43899792/article/details/124304136">https://blog.csdn.net/weixin_43899792/article/details/124304136</a></p> 
<h3><a id="_137"></a>五、垃圾收集算法</h3> 
<h4><a id="_138"></a>分代收集理论</h4> 
<p>现代虚拟机的垃圾收集器大多都遵循了分代收集理论，这个理论建立在三个经验假说之上：</p> 
<ul><li>弱分代假说：绝大多数对象都是朝生夕灭的。</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li><li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</li></ul> 
<p>以下简单讲解下三种垃圾回收方法论</p> 
<h4><a id="1____145"></a>1. 标记 - 清除算法</h4> 
<p>最早出现也是最基础的垃圾收集算法是标记 - 清除算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收清除掉所有被标记的对象。也可以反过来。</p> 
<p>缺点：<br> 执行效率不稳定，如果堆中有大量对象需要回收就必须进行大量的标记与清除动作。<br> 会导致内存空间碎片化，创建对象时需要耗费资源寻找合适的空闲空间，并且创建较大对象时可能找不到足够的连续内存。</p> 
<blockquote> 
 <p>如果JVM采用的垃圾收集器采用的是<strong>标记清除算法</strong>，则堆内存是不规整的，已使用的内存和未使用的内存相互交错，那么虚拟机采用的是<strong>空闲列表法</strong>来为对象分配内存。意思是虚拟机维护了一个列表，记录哪些内存块是可用的，分配内存时在列表中找到一块足够大的空间分配给对象，再更新列表。</p> 
</blockquote> 
<h4><a id="2____153"></a>2. 标记 - 复制算法</h4> 
<p>标记 - 复制算法将要回收的空间分为几个区域，注意不要被标记复制的名字忽悠了，标记清除算法中分为标记和清除两个阶段，但是标记复制算法并没有标记阶段，为什么呢？首先要明确判断对象是否存活的核心思想是用根可达算法找出存活对象，由于标记清除算法需要回收垃圾对象，所以需要对存活对象进行标记，然后再清除不可用对象。而复制算法是要复制存活对象到另一块区域，所以在根可达算法发现存活对象后是直接复制到另一块区域，即在根可达分析过程中就已经完成了筛选（复制），待复制完成后，直接清理掉另一块区域即可，所以不需要挨个标记然后去清除。</p> 
<p>优点：执行效率较高，且不会产生内存碎片<br> 缺点：内存空间不能充分利用，需要保留一块区域用于下一次垃圾回收时复制存活对象。</p> 
<p>Hotspot JVM的堆空间中年轻代的垃圾回收就是基于这种算法，年轻代划分为一个Eden区和两个Survivor区，内存比例默认为8:1:1，一个Survivor区保留，其余可使用，垃圾回收时只需要将通过根可达分析确认存活的对象复制到保留的Survivor区。但是不是每次都只有10%的对象存活，因此需要老年代做分配担保，如果Survivor区空间不足，则将一部分对象直接晋升老年代。</p> 
<h4><a id="3____161"></a>3. 标记 - 整理算法</h4> 
<p>标记 - 复制算法除了不能充分利用空间，且对象存活率高时需要进行较多的复制操作，因此在存活率较高的老年代就不能采用这种算法。<br> 针对老年代存活率高的特性，有人提出了标记 - 整理算法，标记过程与标记 - 清除算法一样，但是标记完成后不是清除，而是将剩余存活对象向一端移动进行整理。</p> 
<p>优点：解决了垃圾回收后空间碎片化的问题，且相比标记 - 复制算法无需保留区域，更充分使用空间<br> 缺点：如果每次回收后都有大量对象依然存活需要移动（例如在存活率高的老年代），则需要更新所有用到这些对象的引用，这将会是一种负担很重的操作，并且这种移动对象的操作要暂停所有用户线程才能进行（这种暂停也被称为STW，stop the world）</p> 
<blockquote> 
 <p>如果JVM采用的垃圾收集器采用的是<strong>标记整理算法</strong>，即回收后会将剩余对象整理到连续的内存空间，使得堆内存规整，则JVM中给对象分配内存的方式是<strong>指针碰撞</strong>，即在已使用的空间后连续分配内存，以继续保持内存规整。</p> 
</blockquote> 
<h3><a id="_169"></a>六、经典垃圾收集器</h3> 
<p>如果说收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。《Java虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器都可能会有很大差别，不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。</p> 
<h4><a id="1_Serial__Serial_Old__ParNew__172"></a>1. Serial / Serial Old / ParNew 收集器</h4> 
<p>Serial收集器：<strong>单线程收集器</strong>，并且在进行垃圾收集工作时必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。采用标记复制算法。<br> Serial Old 收集器：Serial收集器的老年代版本，采用标记整理算法。<br> <img src="https://images2.imgbox.com/9f/e2/pPmhKhs8_o.png" alt="在这里插入图片描述"><br> ParNew收集器：Serial收集器的多线程版本，除了使用多线程进行垃圾回收外其他与Serial一样<br> <img src="https://images2.imgbox.com/09/4e/fpI1GJle_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_Parallel_Scavenge__Parallel_Old__178"></a>2. Parallel Scavenge / Parallel Old 收集器</h4> 
<blockquote> 
 <p>Java8的默认垃圾收集器组合</p> 
</blockquote> 
<p>Parallel Scavenge收集器：也是使用标记-复制算法的多线程收集器，关注点是吞吐量（高效率的利用 CPU），提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。<br> Parallel Old 收集器：Parallel Scavenge的老年代版本。使用多线程和“标记-整理”算法</p> 
<p><img src="https://images2.imgbox.com/b5/f8/Mu2ZWvlC_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_CMS_185"></a>3. CMS收集器</h4> 
<p>CMS（Concurrent Mark Sweep）收集器：<strong>基于标记清除算法</strong>，<strong>当内存碎片过多时再采用标记整理算法以获得规整的内存空间</strong>。是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器。它非常符合在注重用户体验的应用上使用。并且是 HotSpot 虚拟机<strong>第一款真正意义上的并发收集器</strong>，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。它在GC过程中使用三色标记法来标记对象，黑色表示当前对象及其直接引用到的对象完成了标记，灰色表示当前对象完成了标记，但是其引用到的对象还没完成标记，白色表示未标记的对象。其垃圾收集步骤如下：</p> 
<ul><li>1）初始标记：STW，标记GC Roots直接关联的对象，将GC roots标记为黑色，将GC roots直接引用的对象标记为灰色。耗时短。</li><li>2）并发标记：根据GC Roots遍历整个对象图进行标记，首先为灰色，引用到的对象都标记为灰色后就升级为黑色。耗时长但可与用户线程并发进行</li><li>3）重新标记：STW，并发标记期间用户线程可能会对引用进行变动，例如将一个垃圾对象又引用起来。因此需对并发标记期间产生的变动进行增量更新标记，耗时短</li><li>4）并发清除：对所有未被标记到的白色对象进行垃圾回收，可并发进行</li></ul> 
<p>可以看到只有在耗时较短的初始标记和重新标记这两个阶段需要STW，因此能够获得较短的停顿时间<br> <img src="https://images2.imgbox.com/aa/07/XeT07f1L_o.png" alt="在这里插入图片描述"><br> 参考<br> https://zhuanlan.zhihu.com/p/451245000<br> https://blog.csdn.net/m0_67788957/article/details/123737277</p> 
<h4><a id="4_G1__197"></a>4. G1 收集器</h4> 
<blockquote> 
 <p><strong>Java9后的默认垃圾收集器</strong></p> 
</blockquote> 
<p>作为CMS收集器的替代与继承者，G1 收集器是一款“停顿时间模型”的收集器，可以在延迟可控的情况下获得尽可能高的吞吐量。它将堆内存划分为多个大小相等的独立区域（Region），每个区域都可以根据需要动态扮演新/老年代中的空间，G1 收集器会跟踪每个区域垃圾回收的“价值”，并在后台维护了一个优先列表，每次可根据允许的收集时间，优先选择回收价值最大的 一些Region(这也就是它的名字 Garbage-First 的由来) 。</p> 
<p><img src="https://images2.imgbox.com/5a/33/oabvCGuZ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/de/b3/DPmZN5Vr_o.png" alt="在这里插入图片描述"></p> 
<p>参考：<a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html" rel="nofollow">JavaGuide</a></p> 
<h4><a id="5_ZGC_211"></a>5. ZGC收集器</h4> 
<p>https://www.bilibili.com/video/BV1xF411B7vZ<br> https://blog.csdn.net/lovewangyihui/article/details/122442440</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5adde05081b3d70d9963fcf26f532d3d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【深入浅出C#】章节5：高级面向对象编程：委托和事件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1546d2eeb909a1c0d0cfdfe6bc4148f5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于RK3588平台的机器学习模型部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>