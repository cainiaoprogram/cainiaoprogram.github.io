<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>bios uefi 区别_UEFI vs BIOS：有何区别？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="bios uefi 区别_UEFI vs BIOS：有何区别？" />
<meta property="og:description" content="bios uefi 区别
So you might have heard the acronyms BIOS and UEFI thrown around, especially when trying to switch Operating Systems or messing around with overclocking. 因此，您可能听说过BIOS和UEFI的首字母缩写词，尤其是在尝试切换操作系统或搞乱超频时。 And you might know what these acronyms stand for (Unified Extensible Firmware Interface and Basic Input/Output System, respectively). But have you ever wondered how they&#39;re used in a computer system? 您可能知道这些首字母缩写的含义(分别是统一可扩展固件接口和基本输入/输出系统)。 但是您是否想知道它们如何在计算机系统中使用？ Let&#39;s demystify these terms and their meanings now.
让我们现在揭开这些术语及其含义的神秘面纱。 开机程序 (Boot Procedure) First things first – I know we&#39;re deviating from the topic, but I promise this will help you with some concepts later on." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0c5580159b3ac01ace51fecc99a7c049/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-21T17:01:09+08:00" />
<meta property="article:modified_time" content="2020-08-21T17:01:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">bios uefi 区别_UEFI vs BIOS：有何区别？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size: 16px;"> 
 <p>bios uefi 区别</p> 
 <p>So you might have heard the acronyms BIOS and UEFI thrown around, especially when trying to switch Operating Systems or messing around with overclocking. </p> 
 <p> 因此，您可能听说过BIOS和UEFI的首字母缩写词，尤其是在尝试切换操作系统或搞乱超频时。 </p> 
 <p>And you might know what these acronyms stand for (Unified Extensible Firmware Interface and Basic Input/Output System, respectively). But have you ever wondered how they're used in a computer system? </p> 
 <p> 您可能知道这些首字母缩写的含义(分别是统一可扩展固件接口和基本输入/输出系统)。 但是您是否想知道它们如何在计算机系统中使用？ </p> 
 <p>Let's demystify these terms and their meanings now.</p> 
 <p> 让我们现在揭开这些术语及其含义的神秘面纱。 </p> 
 <h3 id="boot-procedure"> 开机程序 <span style="font-weight: bold;">(</span>Boot Procedure<span style="font-weight: bold;">)</span></h3> 
 <p>First things first – I know we're deviating from the topic, but I promise this will help you with some concepts later on.</p> 
 <p> 首先是第一件事-我知道我们会偏离主题，但是我保证这会在以后的一些概念中为您提供帮助。 </p> 
 <p>So, how does a computer boot? Let's go step by step:</p> 
 <p> 那么，计算机如何启动？ 让我们一步一步走： </p> 
 <ol><li>You press the power button on your laptop/desktop.<p class="nodelete"></p> 您在笔记本电脑/台式机上按电源按钮。 </li><li>The CPU starts up, but needs some instructions to work on (remember, the CPU always needs to do something). Since the main memory is empty at this stage, CPU defers to load instructions from the firmware chip on the motherboard and begins executing instructions.<p class="nodelete"></p> CPU启动，但是需要一些说明才能进行操作(请记住，CPU始终需要执行某些操作)。 由于在此阶段主存储器为空，因此CPU推迟从主板上的固件芯片加载指令，并开始执行指令。 </li><li>The firmware code does a Power On Self Test (POST), initializes the remaining hardware, detects the connected peripherals (mouse, keyboard, pendrive etc.) and checks if all connected devices are healthy. You might remember it as a 'beep' that desktops used to make after POST is successful.<p class="nodelete"></p> 固件代码执行开机自检(POST)，初始化其余硬件，检测连接的外围设备(鼠标，键盘，笔式驱动器等)，并检查所有连接的设备是否正常。 您可能还记得它是台式机在POST成功后发出的“哔哔声”。 </li><li>Finally, the firmware code cycles through all storage devices and looks for a boot-loader (usually located in first sector of a disk). If the boot-loader is found, then the firmware hands over control of the computer to it.<p class="nodelete"></p> 最后，固件代码循环遍历所有存储设备，并寻找引导加载程序(通常位于磁盘的第一扇区)。 如果找到引导加载程序，则固件会将计算机的控制权移交给它。 </li></ol> 
 <p>We don't need to know more about this topic for the purposes of this article. But if you're interested, then read on (otherwise, you can skip to next section).</p> 
 <p> 就本文而言，我们不需要更多地了解此主题。 但是，如果您有兴趣，请继续阅读(否则，您可以跳到下一部分)。 </p> 
 <ol><li><p>So now that the boot-loader is loaded, its job is to load the rest of the operating system. GRUB is one such boot-loader that is capable of loading unix-like operating systems and is also able to chain-load Windows OS. Boot-loader is only available in the first sector of a disk, which is 512 bytes. Given the complexity of modern operating systems, some of these boot-loaders tend to do multi-stage loading, where the main boot-loader loads the second-stage-boot-loader in an environment which is not restricted to 512 bytes.</p> <p> 因此，既然已经加载了引导加载程序，它的工作就是加载其余的操作系统。 GRUB是一种这样的引导加载程序，它能够加载类Unix的操作系统，并且还可以链式加载Windows OS。 引导加载程序仅在磁盘的第一个扇区(512字节)中可用。 考虑到现代操作系统的复杂性，这些引导加载程序中的一些倾向于进行多阶段加载，其中主引导加载程序在不限于512字节的环境中加载第二阶段引导加载程序。 </p> </li><li><p>The boot-loader then loads the <a href="https://en.wikipedia.org/wiki/Kernel_%28operating_system%29" rel="nofollow">kernel</a> into memory. Unix-like operating systems then run the <code>init</code> process (the master process, from which other processes are forked/executed) and finally initialize the <a href="https://en.wikipedia.org/wiki/Runlevel" rel="nofollow">run-levels</a>.</p> <p> 然后，引导加载程序将<a href="https://en.wikipedia.org/wiki/Kernel_%28operating_system%29" rel="nofollow">内核</a>加载到内存中。 然后，类似Unix的操作系统运行<code>init</code>进程(主进程，从该主进程派生/执行其他进程)，最后初始化<a href="https://en.wikipedia.org/wiki/Runlevel" rel="nofollow">运行级别</a> 。 </p> </li><li><p>In Windows, <code>wininit.exe</code> is loaded along with some other processes like <code>services.exe</code> for service control, <code>lsass.exe</code> for local security and authority (similar to run-levels) and <code>lsm.exe</code> for local session management.</p> <p> 在Windows中， <code>wininit.exe</code>与其他一些进程一起加载，例如用于服务控制的<code>services.exe</code> ，用于本地安全性和权限(类似于运行级别)的<code>lsass.exe</code>和用于本地会话管理的<code>lsm.exe</code> 。 </p> </li><li><p>After all this, and after some other drivers are initialized, the Graphical User Inferface (GUI) is loaded and you are presented with the login screen.</p> <p> 在完成所有这些操作以及初始化其他一些驱动程序之后，将加载图形用户界面(GUI)，并显示登录屏幕。 </p> </li></ol> 
 <p>This was a very high-level overview of the boot process. If you're interested in Operating Systems, I would recommend that you read more on <a href="https://wiki.osdev.org/Expanded_Main_Page" rel="nofollow">osdev.net</a>. </p> 
 <p> 这是引导过程的非常高级的概述。 如果您对操作系统感兴趣，建议您在<a href="https://wiki.osdev.org/Expanded_Main_Page" rel="nofollow">osdev.net</a>上阅读更多<a href="https://wiki.osdev.org/Expanded_Main_Page" rel="nofollow">内容</a> 。 </p> 
 <p>Now let's get back to our original topic.</p> 
 <p> 现在，让我们回到原始主题。 </p> 
 <h3 id="bios-"> BIOS： <span style="font-weight: bold;">(</span>BIOS:<span style="font-weight: bold;">)</span></h3> 
 <p>BIOS stands for Basic Input/Output System, the firmware we talked about in the above boot procedure. </p> 
 <p> BIOS代表基本输入/输出系统，即我们在上述引导过程中讨论的固件。 </p> 
 <p>It is stored on an EPROM (Erasable Programmable Read-Only Memory), allowing the manufacturer to push out updates easily. </p> 
 <p> 它存储在EPROM(可擦可编程只读存储器)中，使制造商可以轻松推出更新。 </p> 
 <p>It provides many helper functions that allow reading boot sectors of attached storage and printing things on screen. You can access BIOS during the initial phases of the boot procedure by pressing <code>del</code>, <code>F2</code> or <code>F10</code>.</p> 
 <p> 它提供了许多帮助程序功能，允许您读取附加存储的引导扇区并在屏幕上打印内容。 您可以在引导过程的初始阶段按<code>del</code> ， <code>F2</code>或<code>F10</code>来访问BIOS。 </p> 
 <h3 id="uefi-"> UEFI： <span style="font-weight: bold;">(</span>UEFI:<span style="font-weight: bold;">)</span></h3> 
 <p>UEFI stands for Unified Extensible Firmware Interface. It does the same job as a BIOS, but with one basic difference: it stores all data about initialization and startup in an .efi file, instead of storing it on the firmware. </p> 
 <p> UEFI代表统一可扩展固件接口。 它执行与BIOS相同的工作，但有一个基本区别：它将有关初始化和启动的所有数据存储在.efi文件中，而不是将其存储在固件中。 </p> 
 <p>This .efi file is stored on a special partition called EFI System Partition (ESP) on the hard disk. This ESP partition also contains the bootloader.</p> 
 <p> 该.efi文件存储在硬盘上称为EFI系统分区(ESP)的特殊分区上。 该ESP分区还包含引导加载程序。 </p> 
 <p>UEFI was designed to overcome many limitations of the old BIOS, including:</p> 
 <p> UEFI旨在克服旧BIOS的许多限制，包括： </p> 
 <ol><li>UEFI supports drive sizes upto 9 zettabytes, whereas BIOS only supports 2.2 terabytes.<p class="nodelete"></p> UEFI支持的驱动器大小最大为9 ZB，而BIOS仅支持2.2 TB。 </li><li>UEFI provides faster boot time.<p class="nodelete"></p> UEFI提供了更快的启动时间。 </li><li>UEFI has discrete driver support, while BIOS has drive support stored in its ROM, so updating BIOS firmware is a bit difficult.<p class="nodelete"></p> UEFI具有离散驱动程序支持，而BIOS具有存储在其ROM中的驱动器支持，因此更新BIOS固件有点困难。 </li><li>UEFI offers security like "Secure Boot", which prevents the computer from booting from unauthorized/unsigned applications. This helps in preventing rootkits, but also hampers dual-booting, as it treats other OS as unsigned applications. Currently, only Windows and Ubuntu are signed OS (let me know if I am wrong).<p class="nodelete"></p> UEFI提供“安全启动”之类的安全性，可防止计算机从未经授权/未签名的应用程序启动。 这有助于防止rootkit的出现，但同时也会阻止双重引导，因为它将其他操作系统视为未签名的应用程序。 目前，只有Windows和Ubuntu是经过签名的操作系统(如果我错了，请告诉我)。 </li><li>UEFI runs in 32bit or 64bit mode, whereas BIOS runs in 16bit mode. So UEFI  is able to provide a GUI (navigation with mouse) as opposed to BIOS which allows navigation only using the keyboard.<p class="nodelete"></p> UEFI以32位或64位模式运行，而BIOS以16位模式运行。 因此，UEFI能够提供GUI(使用鼠标导航)，而BIOS只允许使用键盘进行导航。 </li></ol> 
 <h3 id="you-might-not-need-uefi"> 您可能不需要UEFI <span style="font-weight: bold;">(</span>You might not need UEFI<span style="font-weight: bold;">)</span></h3> 
 <p>Though all modern computers come equipped with UEFI by default, some reasons why you might choose BIOS over UEFI are:</p> 
 <p> 尽管默认情况下所有现代计算机都默认配备UEFI，但您选择BIOS而不是UEFI的一些原因是： </p> 
 <ol><li>If you're beginner and don't care about messing with any type of firmware, BIOS is for you.<p class="nodelete"></p> 如果您是新手，并且不介意使用任何类型的固件，BIOS就是您的最佳选择。 </li><li>If you have &lt; 2 TB per hard disk or partition, you can go with BIOS.<p class="nodelete"></p> 如果每个硬盘或分区的&lt;2 TB，则可以使用BIOS。 </li><li>BIOS allows running multiple operating systems without changing any settings This can be a security issue from a modern standpoint, but hey, no hassles for the user.<p class="nodelete"></p> BIOS允许在不更改任何设置的情况下运行多个操作系统。从现代的角度来看，这可能是一个安全问题，但是，对于用户而言，没有任何麻烦。 </li><li>BIOS provides system information to the operating system. So if your OS runs in 16 bit mode, it does not require writing code for interacting with hardware. It can directly use methods provided by BIOS. Else if the OS switches over to 32bit or 64bit mode, then it needs to provide its own subroutines for interacting with hardware.<p class="nodelete"></p> BIOS向操作系统提供系统信息。 因此，如果您的操作系统以16位模式运行，则无需编写代码即可与硬件进行交互。 它可以直接使用BIOS提供的方法。 否则，如果操作系统切换到32位或64位模式，则它需要提供自己的子例程来与硬件进行交互。 </li><li>If you are someone who prefers a keyboard and text based UI over navigation with a mouse and GUI, then BIOS is for you.<p class="nodelete"></p> 如果您是喜欢基于键盘和文本的UI而不是使用鼠标和GUI进行导航的人，那么BIOS适合您。 </li></ol> 
 <p>UEFI takes these limitations into account and provides a Legacy mode. In it you can run everything as if you had a BIOS firmware. But keep in mind that Intel has announced that it won't support traditional BIOS from 2020.</p> 
 <p> UEFI考虑了这些限制并提供了传统模式。 在其中，您可以像运行BIOS固件一样运行所有程序。 但请记住，英特尔已宣布从2020年起将不再支持传统的BIOS。 </p> 
 <h3 id="conclusion"> 结论 <span style="font-weight: bold;">(</span>Conclusion<span style="font-weight: bold;">)</span></h3> 
 <p>This post gave you an overview of the differences between BIOS and UEFI. It also advises you when to choose either one of them and how they are different from each other. </p> 
 <p> 这篇文章概述了BIOS和UEFI之间的区别。 它还会建议您何时选择它们之一，以及它们之间的区别。 </p> 
 <p>If you have any questions, I will always be available on Twitter. Thank you for your time.</p> 
 <p> 如果您有任何疑问，我将始终在Twitter上提供。 感谢您的时间。 </p> 
 <blockquote> 
  <p>翻译自: <a href="https://www.freecodecamp.org/news/uefi-vs-bios/" rel="nofollow">https://www.freecodecamp.org/news/uefi-vs-bios/</a></p> 
 </blockquote> 
 <p>bios uefi 区别</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cc36f561710241d543e758f0806bfd86/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">kbengine移动同步分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e75bd503d16f25238fd23a9a1ef34d01/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kbengine属性同步分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>