<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FreeRTOS学习笔记（4、事件组、任务通知） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FreeRTOS学习笔记（4、事件组、任务通知）" />
<meta property="og:description" content="FreeRTOS学习笔记（4、事件组、任务通知） 前言往期学习笔记链接学习工程事件组 event groupkeil里面的代码标准事件组的基本使用1、创建事件组2、设置事件3、等待事件 事件组的使用-同步点1、创建事件组2、等待同步 任务通知 task notification任务通知的基础知识任务通知状态的取值任务通知的两类函数任务通知的优缺点 任务通知的使用-轻量级信号量信号量和使用任务通知实现信号量的辨析信号量任务通知实现信号量 1/通知其他任务2/等待任务通知两者区别 任务通知的使用-轻量级队列队列和任务通知实现队列的区别1、队列2、任务通知3、区别 队列实现任务通知实现1、通知值不覆盖2、通知值覆盖 任务通知的使用-轻量级事件组事件组和任务通知实现事件组事件组任务通知实现事件组 事件组实现任务通知实现事件组 前言 这是第四弹，由于CSDN长度的限制，所以把FreeRTOS学习分为几部分来发，这是第四部分
主要包括事件组、任务通知等
往期学习笔记链接 第一弹：FreeRTOS学习笔记（1、FreeRTOS初识、任务的创建以及任务状态理论、调度算法等）
第二弹: FreeRTOS学习笔记（2、同步与互斥通信、队列、队列集的使用）
第三弹: FreeRTOS学习笔记（3、信号量、互斥量的使用）
第四弹: FreeRTOS学习笔记（4、事件组、任务通知）
第五弹: FreeRTOS学习笔记（5、定时器、中断管理、调试与优化）
学习工程 所有学习工程
oufen / FreeRTOS学习
都在我的Gitee工程当中，大家可以参考学习
事件组 event group 可以通过队列传送数据
可以通过信号量，来传递状态信息
还可以使用互斥量来实现临界资源的互斥访问(独占)
但是上述都没办法解决事件组，事件组包含多个事件
事件组，右边可以等
若干个事件中的某个事件某个事件若干个事件中的所有事件 从学习此知识点开始，使用Source Ingsight编辑代码，不再使用VScode
事件组的创建函数
事件组的结构体
EventBits_t 代表一个整数，每一位bit代表一件事件
当生产者，生产完后就可以设置这个EventGroup的某一位，表示这个事件我做完了
生产者1和生产者2所做的事情不一样，所设置的位也不一样
如果事件组里没有东西，那么消费者任务就会等待
这些任务存放在List_t xTasksWaitingForBits;链表中
使用事件组
创建事件组 左边生产者set bits 设置事件的某个位 能够设置哪个事件，就去设置哪个位
右边消费者 wait bits 等待事件的某个位 同步点 假如有taskA、taskB、taskC
taskA做完某些事情后，设置bit0，等待三个任务的bit都设置为1后才可以做下一步
taskB同
taskC同
这三个task都可以调用这个函数表示完成了某件事情" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/53895f2d720124d199bed5698e95f9b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-28T15:30:38+08:00" />
<meta property="article:modified_time" content="2023-08-28T15:30:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FreeRTOS学习笔记（4、事件组、任务通知）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>FreeRTOS学习笔记（4、事件组、任务通知）</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#_6" rel="nofollow">往期学习笔记链接</a></li><li><a href="#_14" rel="nofollow">学习工程</a></li><li><a href="#_event_group_18" rel="nofollow">事件组 event group</a></li><li><ul><li><a href="#keil_93" rel="nofollow">keil里面的代码标准</a></li><li><a href="#_102" rel="nofollow">事件组的基本使用</a></li><li><ul><li><a href="#1_104" rel="nofollow">1、创建事件组</a></li><li><a href="#2_115" rel="nofollow">2、设置事件</a></li><li><a href="#3_121" rel="nofollow">3、等待事件</a></li></ul> 
    </li><li><a href="#_130" rel="nofollow">事件组的使用-同步点</a></li><li><ul><li><a href="#1_146" rel="nofollow">1、创建事件组</a></li><li><a href="#2_150" rel="nofollow">2、等待同步</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_task_notification_158" rel="nofollow">任务通知 task notification</a></li><li><ul><li><a href="#_160" rel="nofollow">任务通知的基础知识</a></li><li><ul><li><a href="#_192" rel="nofollow">任务通知状态的取值</a></li><li><a href="#_208" rel="nofollow">任务通知的两类函数</a></li><li><a href="#_224" rel="nofollow">任务通知的优缺点</a></li></ul> 
    </li><li><a href="#_236" rel="nofollow">任务通知的使用-轻量级信号量</a></li><li><ul><li><a href="#_257" rel="nofollow">信号量和使用任务通知实现信号量的辨析</a></li><li><ul><li><a href="#_259" rel="nofollow">信号量</a></li><li><a href="#_268" rel="nofollow">任务通知实现信号量</a></li></ul> 
     </li><li><a href="#1_285" rel="nofollow">1/通知其他任务</a></li><li><a href="#2_290" rel="nofollow">2/等待任务通知</a></li><li><a href="#_296" rel="nofollow">两者区别</a></li></ul> 
    </li><li><a href="#_304" rel="nofollow">任务通知的使用-轻量级队列</a></li><li><ul><li><a href="#_306" rel="nofollow">队列和任务通知实现队列的区别</a></li><li><ul><li><a href="#1_308" rel="nofollow">1、队列</a></li><li><a href="#2_315" rel="nofollow">2、任务通知</a></li><li><a href="#3_331" rel="nofollow">3、区别</a></li></ul> 
     </li><li><a href="#_369" rel="nofollow">队列实现</a></li><li><a href="#_376" rel="nofollow">任务通知实现</a></li><li><ul><li><a href="#1_378" rel="nofollow">1、通知值不覆盖</a></li><li><a href="#2_385" rel="nofollow">2、通知值覆盖</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_394" rel="nofollow">任务通知的使用-轻量级事件组</a></li><li><ul><li><a href="#_398" rel="nofollow">事件组和任务通知实现事件组</a></li><li><ul><li><a href="#_400" rel="nofollow">事件组</a></li><li><a href="#_415" rel="nofollow">任务通知实现事件组</a></li></ul> 
     </li><li><a href="#_432" rel="nofollow">事件组实现</a></li><li><a href="#_440" rel="nofollow">任务通知实现事件组</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>前言</h3> 
<blockquote> 
 <p>这是第四弹，由于CSDN长度的限制，所以把FreeRTOS学习分为几部分来发，这是第四部分<br> <br><br> 主要包括<code>事件组、任务通知</code>等</p> 
</blockquote> 
<h3><a id="_6"></a>往期学习笔记链接</h3> 
<blockquote> 
 <p><code>第一弹</code>：<a href="https://blog.csdn.net/cyaya6/article/details/132482017?spm=1001.2014.3001.5501">FreeRTOS学习笔记（1、FreeRTOS初识、任务的创建以及任务状态理论、调度算法等）</a><br> <code>第二弹</code>: <a href="https://blog.csdn.net/cyaya6/article/details/132507836?spm=1001.2014.3001.5501">FreeRTOS学习笔记（2、同步与互斥通信、队列、队列集的使用）</a><br> <code>第三弹</code>: <a href="https://blog.csdn.net/cyaya6/article/details/132507946?spm=1001.2014.3001.5501">FreeRTOS学习笔记（3、信号量、互斥量的使用）</a><br> <code>第四弹</code>: <a href="https://blog.csdn.net/cyaya6/article/details/132515584?spm=1001.2014.3001.5501">FreeRTOS学习笔记（4、事件组、任务通知）</a><br> <code>第五弹</code>: <a href="https://blog.csdn.net/cyaya6/article/details/132539520?spm=1001.2014.3001.5501">FreeRTOS学习笔记（5、定时器、中断管理、调试与优化）</a></p> 
</blockquote> 
<h3><a id="_14"></a>学习工程</h3> 
<blockquote> 
 <p><code>所有学习工程</code><br> <a href="https://gitee.com/cyaya6/free-rtos-learning" rel="nofollow">oufen / FreeRTOS学习</a><br> <code>都在我的Gitee工程当中，大家可以参考学习</code></p> 
</blockquote> 
<h3><a id="_event_group_18"></a>事件组 event group</h3> 
<p><strong>可以通过队列传送数据</strong></p> 
<p><strong>可以通过信号量，来传递状态信息</strong></p> 
<p><strong>还可以使用互斥量来实现临界资源的互斥访问(独占)</strong></p> 
<p>但是上述都没办法解决事件组，事件组包含多个事件<br> <img src="https://images2.imgbox.com/fc/5f/UxPSKAv1_o.png" alt="image.png"><br> 事件组，右边可以等</p> 
<ul><li>若干个事件中的某个事件</li><li>某个事件</li><li>若干个事件中的所有事件</li></ul> 
<p><img src="https://images2.imgbox.com/6c/ca/bEqIFpTQ_o.png" alt="image.png"></p> 
<blockquote> 
 <p><strong>从学习此知识点开始，使用Source Ingsight编辑代码，不再使用VScode</strong></p> 
</blockquote> 
<p>事件组的创建函数<br> <img src="https://images2.imgbox.com/f5/65/TpugWc8H_o.png" alt="image.png"></p> 
<p>事件组的结构体<br> <img src="https://images2.imgbox.com/e4/8c/yKjnui4g_o.png" alt="image.png"></p> 
<p>EventBits_t 代表一个整数，每一位bit代表一件事件<br> 当生产者，生产完后就可以设置这个EventGroup的某一位，表示这个事件我做完了<br> 生产者1和生产者2所做的事情不一样，所设置的位也不一样</p> 
<p>如果事件组里没有东西，那么消费者任务就会等待<br> 这些任务存放在<code>List_t xTasksWaitingForBits</code>;链表中</p> 
<p>使用事件组</p> 
<ol><li>创建事件组</li></ol> 
<p><img src="https://images2.imgbox.com/52/13/uXNaBIxO_o.png" alt="image.png"></p> 
<ol start="2"><li>左边生产者set bits 设置事件的某个位</li></ol> 
<p>能够设置哪个事件，就去设置哪个位<br> <img src="https://images2.imgbox.com/a2/f9/8qs4zTzs_o.png" alt="image.png"></p> 
<ol start="3"><li>右边消费者 wait bits 等待事件的某个位</li></ol> 
<p><img src="https://images2.imgbox.com/7b/36/bxejW6PY_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/c0/b3/NZ9OZ8eV_o.png" alt="image.png"></p> 
<p><img src="https://images2.imgbox.com/15/91/XMJLh2L2_o.png" alt="image.png"></p> 
<ol start="4"><li>同步点</li></ol> 
<p><img src="https://images2.imgbox.com/37/99/0an0KjDI_o.png" alt="image.png"><br> 假如有taskA、taskB、taskC</p> 
<p>taskA做完某些事情后，设置bit0，等待三个任务的bit都设置为1后才可以做下一步<br> taskB同<br> taskC同<br> 这三个task都可以调用这个函数表示完成了某件事情<br> 三个bit位都被设置完后，这三个task都可以从这个函数里退出来</p> 
<p>这就是同步点，可以使用这个函数来实现多个task,函数退出之后将会设置三个bit，清零</p> 
<p><img src="https://images2.imgbox.com/10/d4/SYstEfCc_o.png" alt="image.png"></p> 
<p>注意</p> 
<blockquote> 
 <p>事件组只起通知作用，要想把数据保存起来，就要另外使用其他方法保存数据</p> 
</blockquote> 
<p>比如队列保存数据</p> 
<h4><a id="keil_93"></a>keil里面的代码标准</h4> 
<p>keil默认使用的C语言标准是C89,必须这样子做<br> 使用C99,变量的定义可以定义在任何地方<br> 可以在Keil里使用C99标准</p> 
<blockquote> 
 <p>图片写错辽 是–c99</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/fb/d5/jlf12yqu_o.png" alt="image.png"></p> 
<h4><a id="_102"></a>事件组的基本使用</h4> 
<h5><a id="1_104"></a>1、创建事件组</h5> 
<p>事件组只能起通知作用，保存数据要采用其他的方法，这里采用队列<br> <img src="https://images2.imgbox.com/3a/42/o5ffTvaB_o.png" alt="image.png"><br> 注意，使用事件组时，需要定义宏后，才能使用<br> <img src="https://images2.imgbox.com/f8/db/UDng9blk_o.png" alt="image.png"></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">configSUPPORT_DYNAMIC_ALLOCATION</span> <span class="token expression"><span class="token number">1</span> </span><span class="token comment">/* 使用事件组头文件*/</span></span>
</code></pre> 
<h5><a id="2_115"></a>2、设置事件</h5> 
<p>计算完成后，向队列中写入数据，并且设置事件组的bit0位<br> <img src="https://images2.imgbox.com/20/bc/t3ZMHDpY_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/70/85/XFkuFzaM_o.png" alt="image.png"></p> 
<h5><a id="3_121"></a>3、等待事件</h5> 
<p>等待事件组的bit0位|bit1位后，将数据从队列中读取出来<br> <img src="https://images2.imgbox.com/90/8b/z4OHYqc0_o.png" alt="image.png"></p> 
<p>可以看到，计算结束后，设置事件组的bit0|bit1位，等待事件组的两位设置位1后，然后就从队列中将数据读取出来<br> <img src="https://images2.imgbox.com/19/ae/R4DGH6Qn_o.png" alt="image.png"></p> 
<h4><a id="_130"></a>事件组的使用-同步点</h4> 
<p><img src="https://images2.imgbox.com/b7/ec/T2MtsCbS_o.png" alt="image.png"><br> 同步函数，有三个功能</p> 
<ul><li>设置事件，表示自己完成了某个或者某些事件</li><li>等待事件，和别的task同步</li><li>成功返回后，清除等待的事件</li></ul> 
<p>同步函数退出后</p> 
<ul><li>成功退出的话，会清除事件</li><li>成功退出的话，等待哪些事件，就会清除哪些事件</li></ul> 
<p><img src="https://images2.imgbox.com/5d/d7/IsJuLREf_o.png" alt="image.png"></p> 
<h5><a id="1_146"></a>1、创建事件组</h5> 
<p><img src="https://images2.imgbox.com/95/fa/sjjDbI0Y_o.png" alt="image.png"></p> 
<h5><a id="2_150"></a>2、等待同步</h5> 
<p><img src="https://images2.imgbox.com/57/dc/hHm9Lg1g_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/56/87/q3bzKNRc_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/ad/5d/1dfBxRyz_o.png" alt="image.png"><br> 当三个bit都被设置为1之后，就可以同步继续，打印等待同步之后的内容<br> <img src="https://images2.imgbox.com/5e/f6/jrQ0Urvo_o.png" alt="image.png"></p> 
<h3><a id="_task_notification_158"></a>任务通知 task notification</h3> 
<h4><a id="_160"></a>任务通知的基础知识</h4> 
<p>使用队列、信号量、事件组等，我们都需要事先创建对应的结构体，对方通过中间的结构体进行通信</p> 
<p>而使用任务通知，任务结构体TCB，中就包含了内部对象，可以直接接收别人发送过来的通知</p> 
<p><strong>使用任务通知时，只能通知指定的task,所以是多对1的关系</strong></p> 
<p><img src="https://images2.imgbox.com/04/45/nAGqxlFe_o.png" alt="image.png"></p> 
<p>TCB结构体中包含了内部对象</p> 
<blockquote> 
 <p>一个是uint8_t 类型的，表示通知的状态<br> 一个是uint32_t类型的，表示通知的值</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b5/69/QcxhcVLr_o.png" alt="image.png"></p> 
<p>一个TCB结构体代表一个task，别的task可以去通知它，可以往TCB结构体中放入值，通知它，进而放一个通知值</p> 
<p>发送task往TCB结构体中放入值的时候，要么成功，要么失败，都不会进入到阻塞状态</p> 
<p>目标task可以等待，无数据时，可以阻塞等待<br> 有数据时，即刻返回</p> 
<p>在TCB结构体中只有一个通知状态，并没有List列表存放阻塞的task<br> 并不像队列一样让其存放在链表中，从而阻塞等待</p> 
<p>当发送task将通知值放入TCB结构体中时，将会改变任务通知的状态，并且将目标task唤醒</p> 
<p>所以是多对1的关系<br> <img src="https://images2.imgbox.com/ef/ed/F6LEQbfU_o.png" alt="image.png"></p> 
<h5><a id="_192"></a>任务通知状态的取值</h5> 
<p><img src="https://images2.imgbox.com/72/83/fli2NO4H_o.png" alt="image.png"><br> ucNotifyState 通知状态的取值为</p> 
<ul><li><code>taskNOT_WAITING_NOTIFICATION</code>：任务没有在等待通知</li><li><code>taskWAITING_NOTIFICATION</code>：任务在等待通知</li><li><code>taskNOTIFICATION_RECEIVED</code>：任务接收到了通知，也被称为pending(有数据了，待处理)</li></ul> 
<ol><li>一开始创建taskA时，任务通知的状态的初始值为<code>taskNOT_WAITING_NOTIFICATION</code>，taskA没有在等待通知</li><li><strong>taskA</strong>想要<code>等待通知</code>的话，<strong>taskB</strong>可以调用<code>ulTaskNotifyTake</code>函数或<code> xTaskNotifyWait</code>函数，将会进入<code>taskWAITING_NOTIFICATION状态</code>，taskA在等待通知</li><li>taskB可以调用<code>xTaskNotify或xTaskNotifyGive函数</code>来通知taskA</li></ol> 
<p>此时taskA的任务状态为<code>taskNOTIFICATION_RECEIVED</code>，表示接收到了数据，待处理<br> 同时还会将taskA，从阻塞状态变为就绪状态，taskA开始运行</p> 
<h5><a id="_208"></a>任务通知的两类函数</h5> 
<p><img src="https://images2.imgbox.com/77/5e/mS0jNqfu_o.png" alt="image.png"></p> 
<pre><code class="prism language-c">BaseType_t <span class="token function">xTaskNotifyGive</span><span class="token punctuation">(</span> TaskHandle_t xTaskToNotify <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">uint32_t</span> <span class="token function">ulTaskNotifyTake</span><span class="token punctuation">(</span> BaseType_t xClearCountOnExit<span class="token punctuation">,</span> TickType_t xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span>

BaseType_t <span class="token function">xTaskNotify</span><span class="token punctuation">(</span> TaskHandle_t xTaskToNotify<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> ulValue<span class="token punctuation">,</span> eNotifyAction eAction <span class="token punctuation">)</span><span class="token punctuation">;</span>
BaseType_t <span class="token function">xTaskNotifyWait</span><span class="token punctuation">(</span> <span class="token class-name">uint32_t</span> ulBitsToClearOnEntry<span class="token punctuation">,</span> 
                            <span class="token class-name">uint32_t</span> ulBitsToClearOnExit<span class="token punctuation">,</span> 
                            <span class="token class-name">uint32_t</span> <span class="token operator">*</span>pulNotificationValue<span class="token punctuation">,</span> 
                            TickType_t xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="_224"></a>任务通知的优缺点</h5> 
<ol><li>传递数据/发送事件时,更快</li><li>更节省内存,因为无需创建通信对象</li><li>不能使用任务通知给ISR发送数据/发送事件,ISR不属于任务</li><li>接收方只有一个任务</li><li>无法缓冲多个数据,任务通知只能保存1个数据</li><li>无法向多个任务进行广播</li><li>发送方无法阻塞</li></ol> 
<h4><a id="_236"></a>任务通知的使用-轻量级信号量</h4> 
<p><img src="https://images2.imgbox.com/81/a0/Yq0HjIzc_o.png" alt="image.png"></p> 
<pre><code class="prism language-c"><span class="token class-name">uint32_t</span> <span class="token function">ulTaskNotifyTake</span><span class="token punctuation">(</span> BaseType_t xClearCountOnExit<span class="token punctuation">,</span> TickType_t xTicksToWait<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/56/27/0Wc43aIa_o.png" alt="image.png"></p> 
<p>xClearCountOnExit,函数返回前是否清零</p> 
<ul><li>pdTRUE,将通知值清零</li><li>pdFALSE,如果通知之大于0,就把通知值减1</li></ul> 
<p>ulTaskNotifyTake()函数的返回值有两种情况</p> 
<ul><li>大于0,在超时之前,通知值被增加了,返回的是通知值</li><li>等于0,一直没有其他task增加通知量,超时返回</li></ul> 
<h5><a id="_257"></a>信号量和使用任务通知实现信号量的辨析</h5> 
<h6><a id="_259"></a>信号量</h6> 
<ol><li>创建信号量</li><li>taskA完成事件后,give信号量,让信号量计数值+1</li><li>taskB等待信号量,take信号量,让信号量计数值-1</li><li>taskA可以give N 次,taskB可以take N次</li></ol> 
<p><img src="https://images2.imgbox.com/41/85/CZ0DP5HD_o.png" alt="image.png"></p> 
<h6><a id="_268"></a>任务通知实现信号量</h6> 
<ol><li>taskA发送任务通知给taskB</li><li>taskB任务通知值++</li><li>taskA类似于give操作,taskB类似于take操作</li><li>taskB take几次,取决于xClearCountOnExit 
  <ol><li>pdTRUE,退出时将通知值清零</li><li>pdFALSE,退出时如果通知之大于0,就把通知值减1</li></ol> </li></ol> 
<blockquote> 
 <p>xClearCountOnExit采用pdFALSE,时,和一般的信号量是一样的</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/5c/72/Xzh4jxGJ_o.png" alt="image.png"></p> 
<p>如果采用pdTRUE,只能take一次,因为在take后就将任务通知值-1了<br> <img src="https://images2.imgbox.com/e1/3e/cLfV9rZH_o.png" alt="image.png"></p> 
<h5><a id="1_285"></a>1/通知其他任务</h5> 
<p>使用<code>xTaskNotifyGive</code>函数通知其他任务,使其他任务,通知值+1<br> <img src="https://images2.imgbox.com/d2/90/EEpZeEqK_o.png" alt="image.png"></p> 
<h5><a id="2_290"></a>2/等待任务通知</h5> 
<p><img src="https://images2.imgbox.com/19/cc/1FuzCKKL_o.png" alt="image.png"></p> 
<p><img src="https://images2.imgbox.com/25/19/Jltc8qDn_o.png" alt="image.png"></p> 
<h5><a id="_296"></a>两者区别</h5> 
<p>任务通知不需要创建结构体,直接使用TCB结构体中的任务通知值和任务状态即可</p> 
<p>如果任务通知想向信号量一样使用</p> 
<p>那么<code>xClearCountOnExit</code>参数的选择需要选择pdFALASE，否则选择pdTRUE的话，任务通知，give++，任务接收时只能接收一次</p> 
<h4><a id="_304"></a>任务通知的使用-轻量级队列</h4> 
<h5><a id="_306"></a>队列和任务通知实现队列的区别</h5> 
<h6><a id="1_308"></a>1、队列</h6> 
<p>task可以向队列中写入数据，也可以向队列中接收数据，在写入数据时可以等待，在接收数据时也要可以等待</p> 
<blockquote> 
 <p>并且在队列的创建时，可以指定队列的长度和大小(字符串、结构体、整数等)</p> 
</blockquote> 
<h6><a id="2_315"></a>2、任务通知</h6> 
<p>而对于任务通知<br> <strong>TCB结构体中的任务通知值和任务状态，</strong></p> 
<blockquote> 
 <p>任务通知值只能够存放一个数据，且是32位的</p> 
</blockquote> 
<blockquote> 
 <p>发送通知task，有两种情况，要么覆盖，要么不覆盖数据</p> 
</blockquote> 
<p>覆盖指的是，发送第一个数据，存放至通知值中，发送第二个数据时，覆盖第一次的数据，此时，通知值中是第二次的数据<br> 不覆盖的话，存入数据时将会不成功</p> 
<blockquote> 
 <p>接收任务通知，可以读取任务通知值</p> 
</blockquote> 
<h6><a id="3_331"></a>3、区别</h6> 
<p>任务通知不需要创建结构体<br> <img src="https://images2.imgbox.com/56/17/aQUNE8r1_o.png" alt="image.png"></p> 
<p>同时</p> 
<blockquote> 
 <p>发送数据</p> 
</blockquote> 
<pre><code class="prism language-c">BaseType_t <span class="token function">xTaskNotify</span><span class="token punctuation">(</span>TaskHandle_t xTaskToNotify<span class="token punctuation">,</span><span class="token class-name">uint32_t</span> ulValue<span class="token punctuation">,</span>eNotifyAction eAction<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>第一个参数是任务句柄</p> 
 <p>第二个参数就是存入到任务通知值的值</p> 
 <p>第三个参数是选择实现 覆盖Or 不覆盖</p> 
 <p><img src="https://images2.imgbox.com/a8/1e/2pxPni3X_o.png" alt="image.png"></p> 
</blockquote> 
<blockquote> 
 <p>接收数据</p> 
</blockquote> 
<pre><code class="prism language-c">BaseType_t <span class="token function">xTaskNotifyWait</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> ulBitsToClearOnEntry<span class="token punctuation">,</span><span class="token class-name">uint32_t</span> ulBitsToClearOnExit<span class="token punctuation">,</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span>pulNotificationValue<span class="token punctuation">,</span>TickType_t xTicksToWait<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>队列的长度和大小可以指定</li><li>任务通知只有1个数据，通知值，数据是32位的</li><li>队列，向队列写数据或者读数据时，可以阻塞</li><li>任务通知，写队列时不可以阻塞</li><li>队列，如果队列的长度是1，可以选择覆盖队列</li><li>任务通知，可以覆盖也可以不覆盖</li></ul> 
<p>这个轻量级的队列的长度只有1</p> 
<h5><a id="_369"></a>队列实现</h5> 
<p>task1向队列中写入了十个数据，task2就可以从队列中取出这十个数据<br> <img src="https://images2.imgbox.com/a3/ed/P4z81LvP_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/a1/71/xtNOAjRm_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/d8/bb/qtqYlki5_o.png" alt="image.png"></p> 
<h5><a id="_376"></a>任务通知实现</h5> 
<h6><a id="1_378"></a>1、通知值不覆盖</h6> 
<p><img src="https://images2.imgbox.com/23/d6/xOOTciO5_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/75/88/PWzwxBIG_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/30/69/hUzQCYO4_o.png" alt="image.png"></p> 
<h6><a id="2_385"></a>2、通知值覆盖</h6> 
<p><img src="https://images2.imgbox.com/18/6d/yAlgEKTS_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/f3/15/mB5f5Hg0_o.png" alt="image.png"></p> 
<p>这里注意了，任务通知，任务通知写入多次，但是等待任务通知只能读一次<br> 但是邮箱，一旦邮箱中有数据，可以多次读，都会成功</p> 
<h4><a id="_394"></a>任务通知的使用-轻量级事件组</h4> 
<p>可以通过设置<code>xTaskNotify()</code>函数的<code>eNotifyAction</code>参数，设置为<code>eSetBits</code>时，即可实现轻量级事件组</p> 
<h5><a id="_398"></a>事件组和任务通知实现事件组</h5> 
<h6><a id="_400"></a>事件组</h6> 
<p>任务完成后，可以设置事件组中的某一位<br> 等待事件组的某一位或某几位或者所有位</p> 
<p>假如，taskA，完成事件后，设置bit0,taskB完成事件后，设置bit1<br> 这是等待事件时，有两种情况</p> 
<ul><li>等待bit0或bit1</li><li>等待bit0和bit1</li></ul> 
<p>当等待的事件为或的时候，每设置一位，就会被唤醒一次，比如设置了bit0，将会被唤醒一次，设置了bit1，将会被唤醒第二次<br> 当等待的事件为和的时候，只有当两个事件位都被设置，才会被唤醒<br> <img src="https://images2.imgbox.com/75/92/eki8bFFw_o.png" alt="image.png"></p> 
<h6><a id="_415"></a>任务通知实现事件组</h6> 
<p>通过设置<code>xTaskNotify()</code>函数的<code>eNotifyAction</code>参数，设置为<code>eSetBits</code>时，即可实现轻量级事件组</p> 
<p>此时ulvalue将会等于<code>val = val | ulValue</code></p> 
<blockquote> 
 <p><strong>此时一旦taskA,调用</strong><code>**xTaskNotify()**</code><strong>函数，就会唤醒目标任务taskB</strong></p> 
 <hr> 
 <p><strong>但是事件组，设置了某些位后，要等待这些位满足条件才能被唤醒</strong></p> 
</blockquote> 
<p><strong>发送方可以设置事件，但是接收方并不能等待指定的事件，不能等待若干个事件中的任意一个或多个</strong><br> <strong>一旦有事件，总会唤醒task</strong></p> 
<h5><a id="_432"></a>事件组实现</h5> 
<p><img src="https://images2.imgbox.com/33/f2/l60nuX9x_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/03/34/I9BrcAvK_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/c2/13/23koQw7U_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/46/b0/oZRAlMmb_o.png" alt="image.png"><br> 可以看到事件组，task3在等待两位都被设置为1之后，才被唤醒，进入运行状态</p> 
<h5><a id="_440"></a>任务通知实现事件组</h5> 
<p>任务通知实现事件组并不能实现，等待某些事件或者某个事件</p> 
<p>每被通知一次，将会被唤醒一次</p> 
<p><img src="https://images2.imgbox.com/5d/3b/pZ6dQDMb_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/c0/44/ZlrgheFu_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/11/ec/SceDzS0R_o.png" alt="image.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/69dd2d3b9d774e3d534b830ecccef627/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FreeRTOS学习笔记（5、定时器、中断管理、调试与优化）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/48d798cc40d2363cc7cc998b36ea8504/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">FreeRTOS学习笔记（3、信号量、互斥量的使用）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>