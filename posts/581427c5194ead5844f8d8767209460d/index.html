<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 时区与时间time - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux 时区与时间time" />
<meta property="og:description" content="UTC时间：这是一个与时区相关的时间，目前将世界时区分为24个：
UTC跟GMT（Greenwich Mean Time，格林威治时间）一致，因为格林威治位于0时区，UTC时间即是0时区的时间。中国位于东八区，所以对应的时间是UTC时间加8小时，即UTC&#43;8，也称为CST（China Standard Time）。UTC倾向于跟标准相关的时间。UTC的查看可以通过date命令(命令需要加上-u，否则看到的是本地时间，即UTC&#43;8的时间)；
RTC：Real Time Clock，实时时钟。RTC和UTC不是一个概念上的时间，RTC通常指的是系统上一个计时的芯片，它将时间保存在CMOS中，而CMOS通过电池可以保持数据不丢失，因此在系统没有上电的情况下也还会正常运行。操作系统启动时会查看这个时间，也可以同步这个时间。RTC倾向于跟硬件相关的时间。查看RTC的命令如下(当前最好在root用户下)
Calendar Time：日历时间，指的是从当前时间到某个标准时间经历的秒数。这里的某个时间通常是指1970年1月1日0时0分0秒，这个时间点也被称为Epoch。日历时间是一个相对的时间值，倾向于跟软件相关。
与时间相关的常用函数：
/* Return the current time and put it in *TIMER if TIMER is not NULL. */ extern time_t time (time_t *__timer) __THROW; 它的入参和返回值都是time_t，它实际上就是一个长整型，表示的就是从Epoch到函数调用之时经历的秒数，也就是前面提到的日历时间。为了得到这个时间，通常传入一个NULL作为参数，返回值就是我们需要的。
#include &lt;stdio.h&gt; #include &lt;time.h&gt; time_t time_test(void) { time_t t = time(NULL); return t; } int main(int argc, char *argv[]) { time_t t = time_test(); printf(&#34;time_test:%ld\n&#34;, t); return 0; } 执行结果：
gmtime()函数会利用time_t的值，并将其转换为一个真正的时间，从函数名称就可以看出来是格林威治时间，也就是UTC的时间。与gmtime对应的就是转化为本地时间的函数localtime()。它们的函数原型如下：
# ifdef __USE_POSIX /* Return the `struct tm&#39; representation of *TIMER in UTC, using *TP to store the result." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/581427c5194ead5844f8d8767209460d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-26T21:44:08+08:00" />
<meta property="article:modified_time" content="2022-06-26T21:44:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 时区与时间time</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>UTC时间：这是一个与时区相关的时间，目前将世界时区分为24个：</p> 
<p>UTC跟GMT（Greenwich Mean Time，格林威治时间）一致，因为格林威治位于0时区，UTC时间即是0时区的时间。中国位于东八区，所以对应的时间是UTC时间加8小时，即UTC+8，也称为CST（China Standard Time）。UTC倾向于跟标准相关的时间。UTC的查看可以通过date命令(命令需要加上-u，否则看到的是本地时间，即UTC+8的时间)；</p> 
<p><img alt="" height="88" src="https://images2.imgbox.com/5a/ac/0yr1lLCf_o.png" width="511"></p> 
<p>RTC：Real Time Clock，实时时钟。RTC和UTC不是一个概念上的时间，RTC通常指的是系统上一个计时的芯片，它将时间保存在CMOS中，而CMOS通过电池可以保持数据不丢失，因此在系统没有上电的情况下也还会正常运行。操作系统启动时会查看这个时间，也可以同步这个时间。RTC倾向于跟硬件相关的时间。查看RTC的命令如下(当前最好在root用户下)</p> 
<p><img alt="" height="63" src="https://images2.imgbox.com/24/1f/9vnjLo8G_o.png" width="436"></p> 
<p> <strong>Calendar Time</strong>：日历时间，指的是从当前时间到某个标准时间经历的秒数。这里的某个时间通常是指1970年1月1日0时0分0秒，这个时间点也被称为Epoch。日历时间是一个相对的时间值，倾向于跟软件相关。</p> 
<p>与时间相关的常用函数：</p> 
<pre><code class="language-cpp">/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
extern time_t time (time_t *__timer) __THROW;</code></pre> 
<p>它的入参和返回值都是time_t，它实际上就是一个长整型，表示的就是从Epoch到函数调用之时经历的秒数，也就是前面提到的日历时间。为了得到这个时间，通常传入一个NULL作为参数，返回值就是我们需要的。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

time_t time_test(void)
{
    time_t t = time(NULL);
    return t;
} 

int main(int argc, char *argv[])
{
    time_t t = time_test();
    printf("time_test:%ld\n", t);
    return 0;
}</code></pre> 
<p>执行结果：</p> 
<p><img alt="" height="81" src="https://images2.imgbox.com/ac/49/vS8zniNn_o.png" width="331"></p> 
<p>gmtime()函数会利用time_t的值，并将其转换为一个真正的时间，从函数名称就可以看出来是格林威治时间，也就是UTC的时间。与gmtime对应的就是转化为本地时间的函数localtime()。它们的函数原型如下：</p> 
<pre><code class="language-cpp"># ifdef __USE_POSIX
/* Return the `struct tm' representation of *TIMER in UTC,
   using *TP to store the result.  */
extern struct tm *gmtime_r (const time_t *__restrict __timer,
			    struct tm *__restrict __tp) __THROW;

/* Return the `struct tm' representation of *TIMER in local time,
   using *TP to store the result.  */
extern struct tm *localtime_r (const time_t *__restrict __timer,
			       struct tm *__restrict __tp) __THROW;
# endif	/* POSIX */
</code></pre> 
<p>这两个函数的返回值就是前面提到的结构体strum tm，接收的参数就是time()函数的返回值time_t；</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

time_t time_test(void)
{
    time_t t = time(NULL);
    return t;
} 

struct tm *gmttime_test(time_t *t)
{
    struct tm *tm;
    tm = gmtime(t);
    return tm;
}

struct tm *localtime_test(time_t *t)
{
    struct tm *tm;
    tm = localtime(t);
    return tm;
}

int main(int argc, char *argv[])
{
    time_t t = time_test();
    printf("time_test:%ld\n", t);
    struct tm *tm = gmttime_test(&amp;t);
    printf("%4d-%02d-%02d %02d:%02d:%02d %s\n", tm-&gt;tm_year + 1900, tm-&gt;tm_mon + 1,tm-&gt;tm_mday, tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec, tm-&gt;tm_zone);
    tm = NULL;
    tm = localtime_test(&amp;t);
    printf("%4d-%02d-%02d %02d:%02d:%02d %s\n", tm-&gt;tm_year + 1900, tm-&gt;tm_mon + 1,tm-&gt;tm_mday, tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec, tm-&gt;tm_zone);
    return 0;
}</code></pre> 
<p>执行结果：</p> 
<p><img alt="" height="135" src="https://images2.imgbox.com/4a/3c/opTdSlZ2_o.png" width="305"></p> 
<p> 注意：struct tm里 年和月两个值的参考值，所以需要增加特定的偏移之后才是真实值。从测试程序可看出本地时间和UTC时间之间的差异刚好是8小时。</p> 
<p>ctime()和asctime()： 可自己实现显示时间的字符串</p> 
<pre><code class="language-cpp">__BEGIN_NAMESPACE_STD
/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime (const struct tm *__tp) __THROW;

/* Equivalent to `asctime (localtime (timer))'.  */
extern char *ctime (const time_t *__timer) __THROW;
__END_NAMESPACE_STD</code></pre> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

time_t time_test(void)
{
    time_t t = 0;
    t = time(NULL);
    return t;
} 

struct tm *gmttime_test(time_t *t)
{
    struct tm *tm = NULL;
    tm = gmtime(t);
    return tm;
}

struct tm *localtime_test(time_t *t)
{
    struct tm *tm = NULL;
    tm = localtime(t);
    return tm;
}

char *asctime_test(struct tm *tm)
{
    char *char_time = {0};
    char_time = asctime(tm);
    return char_time;
}

char *ctime_test(time_t *t)
{
    char *char_time = {0};
    char_time = ctime(t);
    return char_time;
}

int main(int argc, char *argv[])
{
    time_t t = time_test();
    printf("time_test:%ld\n", t);
    struct tm *tm = gmttime_test(&amp;t);
    //printf("%4d-%02d-%02d 02d:%02d:%02d %s\n", tm-&gt;tm_year + 1900, tm-&gt;tm_mon + 1,tm-&gt;tm_mday, tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec, tm-&gt;tm_zone);
    printf("asctime %s", asctime_test(tm));
    tm = NULL;
    tm = localtime_test(&amp;t);
    //printf("%4d-%02d-%02d %02d:%02d:%02d %s\n", tm-&gt;tm_year + 1900, tm-&gt;tm_mon + 1,tm-&gt;tm_mday, tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec, tm-&gt;tm_zone);
    printf("ctime %s", ctime_test(&amp;t));
    return 0;
}</code></pre> 
<p>执行结果：</p> 
<p><img alt="" height="132" src="https://images2.imgbox.com/24/95/byFkyTwe_o.png" width="422"></p> 
<p> 从执行结果可以看出：ctime()显示的是本地时间。两个函数返回的时间字符串还自带换行，所以不需要我们添加。</p> 
<pre><code class="language-cpp">/* Return the `time_t' representation of TP and normalize TP.  */
extern time_t mktime (struct tm *__tp) __THROW;
</code></pre> 
<p>该函数mktime()的功能与gmtime()和localtime()函数的功能刚好相反，是将struct tm转换为time_t；</p> 
<p>RTC与时间函数</p> 
<p>RTC时间是存放在CMOS中的时间，其中CMOS是一段非易失的介质，里面的内容是固定的，而这里的值会通过一个芯片按固定的时间修改，以保持时间的同步。time()函数的一个实现方式即为通过读取CMOS里的值，然后与Epoch时间做减法，得到的时间间隔再转化为秒数，即可作为返回值。</p> 
<p><img alt="" height="526" src="https://images2.imgbox.com/02/46/Cz8SILUn_o.png" width="689"></p> 
<p>关于时区Linux中有很多种方式来查看，例如：</p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/1b/cd/F2Y0bAe6_o.png" width="1200"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/05ba5a4c633cb3fa96b4142a0cd48ea9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">写给信息学竞赛选手的趣味编程 基于DevC&#43;&#43;的SDL2图形程序设计（五） 三层汉诺塔的简单游戏实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d93f3ad7f53cf99745c85bfff8229a3d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">FinalShell工具下载安装教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>