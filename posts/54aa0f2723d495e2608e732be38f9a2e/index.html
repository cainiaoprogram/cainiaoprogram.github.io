<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机基础（笔记）——计算机网络（链路层） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机基础（笔记）——计算机网络（链路层）" />
<meta property="og:description" content="链路层 在链路层中，会讨论到两种截然不同类型的链路层信道。第一种类型是广播信道,这种信道用于连接有线局域网、卫星网和混合光纤同轴电缆( Hybrid Fiber Coaxialcable,HFC)接入网中的多台主机。因为许多主机与相同的广播信道连接,需要所谓的媒体访问协议来协调帧传输。在某些场合中,可以使用中心控制器来协调传输。第二种类型的链路层信道是点对点通信链路,这在诸如长距离链路连接的两台路由器之间,或用户办公室计算机与它们所连接的邻近以太网交换机之间等场合经常能够发现。点到点协议( Point-toPoint Protocol,PPP),该协议的适用范围从经电话线的拨号服务到经光纤链路的高速点到点帧传输。
链路层概述 将运行链路层协议(即第2层)协议的任何设备均称为 结点(node)。结点包括主机、路由器、交换机和WiFi接入点。我们也把沿着通信路径连接相邻结点的通信信道称为 链路(link)。为了将一个数据报从源主机传输到目的主机,数据报必须通过沿端到端路径上的各段链路传输。
链路层提供的服务 尽管任一链路层的基本服务都是将数据报通过单一通信链路从一个结点移动到相邻结点,但所提供的服务细节能够随着链路层协议的不同而变化。链路层协议能够提供的可能服务包括:
成帧( framing)。在每个网络层数据报经链路传送之前,几乎所有的链路层协议都要将其用链路层帧封装起来。一个帧由一个数据字段和若干首部字段组成,其中网络层数据报就插在数据字段中。帧的结构由链路层协议规定。链路接入。媒体访问控制( Medium Access Control,MAC)协议规定了帧在链路上传输的规则。对于在链路的一端仅有一个发送方、链路的另一端仅有一个接收方的点对点链路,MAC协议比较简单(或者不存在),即无论何时链路空闲,发送方都能够发送帧。更有趣的情况是当多个结点共享单个广播链路时,即所谓多路访问问题。这里,MAC协议用于协调多个结点的帧传输。可靠交付。当链路层协议提供可靠交付服务时,它保证无差错地经链路层移动每个网络层数据报。前面讲过,某些运输层协议(例如TCP)也提供可靠交付服务。与运输层可靠交付服务类似,链路层的可靠交付服务通常是通过确认和重传取得的链路层可靠交付服务通常用于易于产生高差错率的链路,其目的是本地(也就是在差错发生的链路上)纠正一个差错,而不是通过运输层或应用层协议迫使进行端到端的数据重传。然而,对于低比特差错的链路,包括光纤、同轴电缆和许多双绞铜线链路,链路层可靠交付可能会被认为是一种不必要的开销。由于这个原因,许多有线的链路层协议不提供可靠交付服务。差错检测和纠正。当帧中的一个比特作为1传输时,接收方结点中的链路层硬件可能不正确地将其判断为0,反之亦然。这种比特差错是由信号衰减和电磁噪声导致的。因为没有必要转发一个有差错的数据报,所以许多链路层协议提供一种机制来检测这样的比特差错。通过让发送结点在帧中包括差错检測比特,让接收结点进行差错检查,以此来完成这项工作。运输层和网络层也提供了有限形式的差错检测,即因特网检验和。链路层的差错检测通常更复杂,并且用硬件实现。差错纠正类似于差错检测,区别在于接收方不仅能检测帧中出现的比特差错,而且能够准确地确定帧中的差错出现的位置(并因此纠正这些差错)。 链路层在何处实现 链路层的主体部分是在网络适配器( network adapter)中实现的,网络适配器有时也称为网络接口卡( Network Interface Card,NC)。位于网络适配器核心的是链路层控制器,该控制器通常是一个实现了许多链路层服务(成帧、链路接入、差错检测等)的专用芯片。因此,链路层控制器的许多功能是用硬件实现的。例如, Intel I的8254x控制器[ Intel2012]实现了以太网协议。
在发送端,控制器取得了由协议较高层生成并存储在主机内存中的数据报,在链路层帧中封装该数据报(填写该帧的各个字段),然后遵循链路接入协议将该帧传进通信链路中。在接收端,控制器接收了整个帧,抽取出网络层数据报。如果链路层执行差错检测,则需要发送控制器在该帧的首部设置差错检测比特,由接收控制器执行差错检测。
尽管大部分链路层是在硬件中实现的,但部分链路层是在运行于主机CPU上的软件中实现的。链路层的软件组件实现了高层链路层功能,如组装链路层寻址信息和激活控制器硬件。在接收端,链路层软件响应控制器中断(例如,由于一个或多个帧的到达),处理差错条件和将数据报向上传递给网络层。所以,链路层是硬件和软件的结合体,即此处是协议钱中软件与硬件交接的地方。
差错检测和纠正技术 比特级差错检测和纠正(bit- level error detection and correotion),即对从一个结点发送到另一个物理上连接的邻近结点的链路层帧中的比特损伤进行检测和纠正,它们通常是链路层提供的两种服务。
在发送结点,为了保护比特免受差错,使用差错检测和纠正比特(Eror- Detection and- Correction,EDC)来增强数据D。通常,要保护的数据不仅包括从网络层传递下来需要通过链路传输的数据报,而且包括链路首部中的链路级的寻址信息、序号和其他字段。
差错检测和纠正技术使接收方有时但并总是检测出已经出现的比特差错。即使采用差错检测比特,也还是可能有未检出比特差错( undetected bit error);这就是说,接收方可能无法知道接收的信息中包含着比特差错。因此,接收方可能向网路层交付一个损伤的数据报,或者不知道该帧首部的某个其他字段的内容已经损伤。因此要选择一个差错检测方案,使得这种事件发生的概率很小。一般而言,差错检测和纠错技术越复杂(即那些具有未检测出比特差错概率较小的技术),导致的开销就越大,这就是意味着需要更多的计算量及更多的差错检测和纠错比特。
在传输数据中检测差错的3种技术:奇偶校验(它用来描述差错检测和纠正背后隐含的基本思想)、检验和方法(它通常更多地应用于运输层)和循环冗余检测(它通常更多地应用在适配器中的链路层)。
奇偶校验 奇偶校验(Parity Check)是一种校验代码传输正确性的方法。根据被传输的一组二进制代码的数位中“1”的个数是奇数或偶数来进行校验。采用奇数的称为奇校验，反之，称为偶校验。采用何种校验是事先规定好的。通常专门设置一个奇偶校验位，用它使这组代码中“1”的个数为奇数或偶数。若用奇校验，则当接收端收到这组代码时，校验“1”的个数是否为奇数，从而确定传输代码的正确性。
采用单个奇偶校验位方式,接收方的操作也很简单。接收方只需要数一数接收的d&#43;1比特中1的数目即可。如果在采用偶校验方案中发现了奇数个值为1的比特,接收方知道至少出现了一个比特差错。更精确的说法是,出现了 奇数个比特差错。其他多维奇偶校验维基百科：Multidimensional parity-check code
工作方式
为了能检测和纠正内存软错误，首先出现的是内存“奇偶校验”。内存中最小的单位是比特，也称为“位”，位只有两种状态分别以1和0来标示，每8个连续的比特叫做一个字节（byte）。不带奇偶校验的内存每个字节只有8位，如果其某一位存储了错误的值，就会导致其存储的相应数据发生变化，进而导致应用程序发生错误。而奇偶校验就是在每一字节（8位）之外又增加了一位作为错误检测位。在某字节中存储数据之后，在其8个位上存储的数据是固定的，因为位只能有两种状态1或0，假设存储的数据用位标示为1、1、1、0、0、1、0、1，那么把每个位相加（1&#43;1&#43;1&#43;0&#43;0&#43;1&#43;0&#43;1=5），结果是奇数。对于偶校验，校验位就定义为1，反之则为0；对于奇校验，则相反。当CPU读取存储的数据时，它会再次把前8位中存储的数据相加，计算结果是否与校验位相一致。从而一定程度上能检测出内存错误，奇偶校验只能检测出错误而无法对其进行修正，同时虽然双位同时发生错误的概率相当低，但奇偶校验却无法检测出双位错误。优缺点
奇偶校验有两种类型：奇校验和偶校验。奇偶校验位是一个表示给定位数的二进制数中1的个数是奇数或者偶数的二进制数，奇偶校验位是最简单的错误检测码。如果传输过程中包括校验位在内的奇数个数据位发生改变，那么奇偶校验位将出错表示传输过程有错误发生。因此，奇偶校验位是一种错误检测码，但是由于没有办法确定哪一位出错，所以它不能进行错误校正。发生错误时必须扔掉全部的数据，然后从头开始传输数据。在噪声很多的媒介上成功传输数据可能要花费很长的时间，甚至根本无法实现。但是奇偶校验位也有它的优点，它是使用一位数据能够达到的最好的校验码，并且它仅仅需要一些异或门就能够生成。奇偶校验被广泛应用。 检验和方法 检验和(checksum)，在数据处理和数据通信领域中，用于校验目的地一组数据项的和。它通常是以十六进制为数制表示的形式。如果校验和的数值超过十六进制的FF，也就是255. 就要求其补码作为校验和。通常用来在通信中，尤其是远距离通信中保证数据的完整性和准确性。
步骤
发送方生成检验和
将发送的进行检验和运算的数据分成若干个16位的位串，每个位串看成一个二进制数，这里并不管字符串代表什么，是整数、浮点数还是位图都无所谓。将IP、UDP或TCP的PDU首部中的检验和字段置为0，该字段也参与检验和运算。对这些16位的二进制数进行1的补码和(one’s complement sum)运算，累加的结果再取反码即生成了检验码。将检验码放入检验和字段中。其中1的补码和运算，即带循环进位(end round carry)的加法，最高位有进位应循环进到最低位。反码即二进制各位取反，如0111的反码为1000。 接收方校验检验和
接收方将接收的数据(包括检验和字段)按发送方的同样的方法进行1的补码和运算，累加的结果再取反码。校验，如果上步的结果为0，表示传输正确；否则，说明传输有差错。 检验和算法示例" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/54aa0f2723d495e2608e732be38f9a2e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-16T16:32:06+08:00" />
<meta property="article:modified_time" content="2019-01-16T16:32:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机基础（笔记）——计算机网络（链路层）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>链路层</h2> 
<p>在链路层中，会讨论到两种截然不同类型的链路层信道。第一种类型是广播信道,这种信道用于连接有线局域网、卫星网和混合光纤同轴电缆( Hybrid Fiber Coaxialcable,HFC)接入网中的多台主机。因为许多主机与相同的广播信道连接,需要所谓的媒体访问协议来协调帧传输。在某些场合中,可以使用中心控制器来协调传输。第二种类型的链路层信道是点对点通信链路,这在诸如长距离链路连接的两台路由器之间,或用户办公室计算机与它们所连接的邻近以太网交换机之间等场合经常能够发现。<strong>点到点协议</strong>( Point-toPoint Protocol,PPP),该协议的适用范围从经电话线的拨号服务到经光纤链路的高速点到点帧传输。</p> 
<h3><a id="_2"></a>链路层概述</h3> 
<p>将运行链路层协议(即第2层)协议的任何设备均称为 <strong>结点</strong>(node)。结点包括主机、路由器、交换机和WiFi接入点。我们也把沿着通信路径连接相邻结点的通信信道称为 <strong>链路</strong>(link)。为了将一个数据报从源主机传输到目的主机,数据报必须通过沿端到端路径上的各段链路传输。</p> 
<h4><a id="_4"></a>链路层提供的服务</h4> 
<p>尽管任一链路层的基本服务都是将数据报通过单一通信链路从一个结点移动到相邻结点,但所提供的服务细节能够随着链路层协议的不同而变化。链路层协议能够提供的可能服务包括:</p> 
<ul><li>成帧( framing)。在每个网络层数据报经链路传送之前,几乎所有的链路层协议都要将其用链路层帧封装起来。一个帧由一个数据字段和若干首部字段组成,其中网络层数据报就插在数据字段中。帧的结构由链路层协议规定。</li><li>链路接入。媒体访问控制( Medium Access Control,MAC)协议规定了帧在链路上传输的规则。对于在链路的一端仅有一个发送方、链路的另一端仅有一个接收方的点对点链路,MAC协议比较简单(或者不存在),即无论何时链路空闲,发送方都能够发送帧。更有趣的情况是当多个结点共享单个广播链路时,即所谓多路访问问题。这里,MAC协议用于协调多个结点的帧传输。</li><li>可靠交付。当链路层协议提供可靠交付服务时,它保证无差错地经链路层移动每个网络层数据报。前面讲过,某些运输层协议(例如TCP)也提供可靠交付服务。与运输层可靠交付服务类似,链路层的可靠交付服务通常是通过确认和重传取得的链路层可靠交付服务通常用于易于产生高差错率的链路,其目的是本地(也就是在差错发生的链路上)纠正一个差错,而不是通过运输层或应用层协议迫使进行端到端的数据重传。然而,对于低比特差错的链路,包括光纤、同轴电缆和许多双绞铜线链路,链路层可靠交付可能会被认为是一种不必要的开销。由于这个原因,许多有线的链路层协议不提供可靠交付服务。</li><li>差错检测和纠正。当帧中的一个比特作为1传输时,接收方结点中的链路层硬件可能不正确地将其判断为0,反之亦然。这种比特差错是由信号衰减和电磁噪声导致的。因为没有必要转发一个有差错的数据报,所以许多链路层协议提供一种机制来检测这样的比特差错。通过让发送结点在帧中包括差错检測比特,让接收结点进行差错检查,以此来完成这项工作。运输层和网络层也提供了有限形式的差错检测,即因特网检验和。链路层的差错检测通常更复杂,并且用硬件实现。差错纠正类似于差错检测,区别在于接收方不仅能检测帧中出现的比特差错,而且能够准确地确定帧中的差错出现的位置(并因此纠正这些差错)。</li></ul> 
<h4><a id="_11"></a>链路层在何处实现</h4> 
<p>链路层的主体部分是在网络适配器( network adapter)中实现的,网络适配器有时也称为网络接口卡( Network Interface Card,NC)。位于网络适配器核心的是链路层控制器,该控制器通常是一个实现了许多链路层服务(成帧、链路接入、差错检测等)的专用芯片。因此,链路层控制器的许多功能是用硬件实现的。例如, Intel I的8254x控制器[ Intel2012]实现了以太网协议。<br> 在发送端,控制器取得了由协议较高层生成并存储在主机内存中的数据报,在链路层帧中封装该数据报(填写该帧的各个字段),然后遵循链路接入协议将该帧传进通信链路中。在接收端,控制器接收了整个帧,抽取出网络层数据报。如果链路层执行差错检测,则需要发送控制器在该帧的首部设置差错检测比特,由接收控制器执行差错检测。<br> 尽管大部分链路层是在硬件中实现的,但部分链路层是在运行于主机CPU上的软件中实现的。链路层的软件组件实现了高层链路层功能,如组装链路层寻址信息和激活控制器硬件。在接收端,链路层软件响应控制器中断(例如,由于一个或多个帧的到达),处理差错条件和将数据报向上传递给网络层。所以,链路层是硬件和软件的结合体,即此处是协议钱中软件与硬件交接的地方。</p> 
<h3><a id="_15"></a>差错检测和纠正技术</h3> 
<p><strong>比特级差错检测和纠正</strong>(bit- level error detection and correotion),即对从一个结点发送到另一个物理上连接的邻近结点的链路层帧中的比特损伤进行检测和纠正,它们通常是链路层提供的两种服务。<br> 在发送结点,为了保护比特免受差错,使用差错检测和纠正比特(Eror- Detection and- Correction,EDC)来增强数据D。通常,要保护的数据不仅包括从网络层传递下来需要通过链路传输的数据报,而且包括链路首部中的链路级的寻址信息、序号和其他字段。<br> 差错检测和纠正技术使接收方有时但并总是检测出已经出现的比特差错。即使采用差错检测比特,也还是可能有未检出比特差错( undetected bit error);这就是说,接收方可能无法知道接收的信息中包含着比特差错。因此,接收方可能向网路层交付一个损伤的数据报,或者不知道该帧首部的某个其他字段的内容已经损伤。因此要选择一个差错检测方案,使得这种事件发生的概率很小。一般而言,差错检测和纠错技术越复杂(即那些具有未检测出比特差错概率较小的技术),导致的开销就越大,这就是意味着需要更多的计算量及更多的差错检测和纠错比特。<br> 在传输数据中检测差错的3种技术:奇偶校验(它用来描述差错检测和纠正背后隐含的基本思想)、检验和方法(它通常更多地应用于运输层)和循环冗余检测(它通常更多地应用在适配器中的链路层)。</p> 
<h4><a id="_20"></a>奇偶校验</h4> 
<p>奇偶校验(Parity Check)是一种校验代码传输正确性的方法。根据被传输的一组二进制代码的数位中“1”的个数是奇数或偶数来进行校验。采用奇数的称为奇校验，反之，称为偶校验。采用何种校验是事先规定好的。通常专门设置一个奇偶校验位，用它使这组代码中“1”的个数为奇数或偶数。若用奇校验，则当接收端收到这组代码时，校验“1”的个数是否为奇数，从而确定传输代码的正确性。<br> 采用单个奇偶校验位方式,接收方的操作也很简单。接收方只需要数一数接收的d+1比特中1的数目即可。如果在采用偶校验方案中发现了奇数个值为1的比特,接收方知道至少出现了一个比特差错。更精确的说法是,出现了 <em>奇数个比特差错</em>。其他多维奇偶校验<a href="https://en.wikipedia.org/wiki/Multidimensional_parity-check_code" rel="nofollow">维基百科：Multidimensional parity-check code</a></p> 
<ol><li>工作方式<br> 为了能检测和纠正内存软错误，首先出现的是内存“奇偶校验”。内存中最小的单位是比特，也称为“位”，位只有两种状态分别以1和0来标示，每8个连续的比特叫做一个字节（byte）。不带奇偶校验的内存每个字节只有8位，如果其某一位存储了错误的值，就会导致其存储的相应数据发生变化，进而导致应用程序发生错误。而奇偶校验就是在每一字节（8位）之外又增加了一位作为错误检测位。在某字节中存储数据之后，在其8个位上存储的数据是固定的，因为位只能有两种状态1或0，假设存储的数据用位标示为1、1、1、0、0、1、0、1，那么把每个位相加（1+1+1+0+0+1+0+1=5），结果是奇数。对于偶校验，校验位就定义为1，反之则为0；对于奇校验，则相反。当CPU读取存储的数据时，它会再次把前8位中存储的数据相加，计算结果是否与校验位相一致。从而一定程度上能检测出内存错误，奇偶校验只能检测出错误而无法对其进行修正，同时虽然双位同时发生错误的概率相当低，但奇偶校验却无法检测出双位错误。</li><li>优缺点<br> 奇偶校验有两种类型：奇校验和偶校验。奇偶校验位是一个表示给定位数的二进制数中1的个数是奇数或者偶数的二进制数，奇偶校验位是最简单的错误检测码。如果传输过程中包括校验位在内的奇数个数据位发生改变，那么奇偶校验位将出错表示传输过程有错误发生。因此，奇偶校验位是一种错误检测码，但是由于没有办法确定哪一位出错，所以它不能进行错误校正。发生错误时必须扔掉全部的数据，然后从头开始传输数据。在噪声很多的媒介上成功传输数据可能要花费很长的时间，甚至根本无法实现。但是奇偶校验位也有它的优点，它是使用一位数据能够达到的最好的校验码，并且它仅仅需要一些异或门就能够生成。奇偶校验被广泛应用。</li></ol> 
<h4><a id="_28"></a>检验和方法</h4> 
<p><strong>检验和</strong>(checksum)，在数据处理和数据通信领域中，用于校验目的地一组数据项的和。它通常是以十六进制为数制表示的形式。如果校验和的数值超过十六进制的FF，也就是255. 就要求其补码作为校验和。通常用来在通信中，尤其是远距离通信中保证数据的完整性和准确性。</p> 
<ul><li> <p>步骤<br> 发送方生成检验和</p> 
  <ol><li>将发送的进行检验和运算的数据分成若干个16位的位串，每个位串看成一个二进制数，这里并不管字符串代表什么，是整数、浮点数还是位图都无所谓。</li><li>将IP、UDP或TCP的PDU首部中的检验和字段置为0，该字段也参与检验和运算。</li><li>对这些16位的二进制数进行1的补码和(one’s complement sum)运算，累加的结果再取反码即生成了检验码。将检验码放入检验和字段中。其中1的补码和运算，即带循环进位(end round carry)的加法，最高位有进位应循环进到最低位。反码即二进制各位取反，如0111的反码为1000。</li></ol> <p>接收方校验检验和</p> 
  <ol><li>接收方将接收的数据(包括检验和字段)按发送方的同样的方法进行1的补码和运算，累加的结果再取反码。</li><li>校验，如果上步的结果为0，表示传输正确；否则，说明传输有差错。</li></ol> </li></ul> 
<p>检验和算法示例<br> <img src="https://images2.imgbox.com/1d/d6/QnXhtO5J_o.png" alt="在这里插入图片描述"></p> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int a[8]={0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08};
    int i,sum=0;
    for (i=0;i&lt;8;i++)
    sum+=a[i];//将每个数相加
    if(sum&gt;0xff)
    {
        sum=~sum;
              
        sum+=1;
    }
    sum=sum&amp;0xff; 
    printf("0x%x\n",sum);
</code></pre> 
<p>}</p> 
<p>一个简单检验和方法就是将这k比特整数加起来,并且用得到的和作为差错检测比特。 <strong>因特网检验和</strong>( Internet checksum)就基于这种方法,即数据的字节作为16比特的整数对待并求和。这个和的反码形成了携带在报文段首部的因特网检验和。接收方通过对接收的数据(包括检验和)的和取反码,并且检测其结果是否为全1比特来检测检验和。如果这些比特中有任何比特是0,就可以指示出差错。RFC1071详细地讨论因<br> 特网检验和算法和它的实现。在TCP和UDP协议中,对所有字段(包括首部和数据字段)都计算因特网检验和。<br> 检验和方法需要相对小的分组开销。例如,TCP和UDP中的检验和只用了16比特。然而,与后面要讨论的常用于链路层的CRC相比,它们提供相对弱的差错保护。运输层通常是在主机中作为用户操作系统的一部分用软件实现的。因为运输层差错检測用软件实现,采用简单而快速如检验和这样的差错检测方案是重要的。在另一方面,链路层的差错检测在适配器中用专用的硬件实现,它能够快速执行更复杂的CRC操作。</p> 
<h4><a id="_65"></a>循环冗余检测</h4> 
<p>现今的计算机网络中广泛应用的差错检测技术基于 <strong>循环冗余检测</strong>( Cyelie RedundaCheck,CRC)编码。CRC编码也称为多项式编码( polynomial code),因为该编码能够将要发送的比特串看作为系数是0和1一个多项式,对比特串的操作被解释为多项式算术。</p> 
<p>循环冗余校验（Cyclic redundancy check，通称“CRC”）是一种根据网上数据包或计算机文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。一般来说，循环冗余校验的值都是32位的整数。由于本函数易于用二进制的计算机硬件使用、容易进行数学分析并且尤其善于检测传输通道干扰引起的错误，因此获得广泛应用。<br> CRC为校验和的一种，是两个字节数据流采用二进制除法（没有进位，使用XOR来代替减法）相除所得到的余数。其中被除数是需要计算校验和的信息数据流的二进制表示；除数是一个长度为（n+1）的预定义（短）的二进制数，通常用多项式的系数来表示。在做除法之前，要在信息数据之后先加上n个0.<br> CRC是基于有限域GF(2)（即除以2的同余）的多项式环。简单的来说，就是所有系数都为0或1（又叫做二进制）的多项式系数的集合，并且集合对于所有的代数操作都是封闭的。例如：<br> （x<sup>3</sup>+x）+（x+1）=x<sup>3</sup>+2x+x=x<sup>3</sup>+x<br> 2会变成0，因为对系数的加法运算都会再取2的模数。乘法也是类似的：<br> (x<sup>2</sup>+x)(x+1)=x<sup>3</sup>+2x<sup>2</sup>+x=x<sup>3</sup>+x<br> 我们同样可以对多项式作除法并且得到商和余数。例如，如果我们用x+x+x除以x+ 1。我们会得到：<br> (x<sup>3</sup>+x<sup>2</sup>+x)/(x+1)=(x<sup>2</sup>+1)-1/(x+1)<br> 也就是说：<br> (x<sup>3</sup>+x<sup>2</sup>+x)=(x<sup>2</sup>+1)(x+1)-1<br> 等价于：<br> (x<sup>2</sup>+x+1)x=(x<sup>2</sup>+1)(x+1)-1<br> 这里除法得到了商x+ 1和余数-1，因为是奇数所以最后一位是1。<br> 字符串中的每一位其实就对应了这样类型的多项式的系数。为了得到CRC，我们首先将其乘以 ，这里n是一个固定多项式的阶数，然后再将其除以这个固定的多项式，余数的系数就是CRC。<br> 在上面的等式中，x<sup>2</sup>+x+x1表示了本来的信息位是111, 是所谓的钥匙，而余数1（也就是x<sup>0</sup>）就是CRC. key的最高次为1,所以我们将原来的信息乘上x<sup>1</sup>来得到x<sup>3</sup>+x<sup>2</sup>+x，也可视为原来的信息位补1个零成为1110。<br> 一般来说，其形式为：<br> M(x)·x<sup>n</sup>=Q(x)K·(x)-R(x)<br> 这里M(x)是原始的信息多项式。K(x)是n阶的“钥匙”多项式。M(x)·x<sup>n</sup>表示了将原始信息后面加上n个0。R(x)是余数多项式，即是CRC“校验和”。在通信中，发送者在原始的信息数据M后附加上n位的R（替换本来附加的0）再发送。接收者收到M和R后，检查M(x)·x<sup>n</sup>+R(x)是否能被K(x)整除。如果是，那么接收者认为该信息是正确的。值得注意的是M(x)·x<sup>n</sup>+R(x)就是发送者所想要发送的数据。这个串又叫做codeword.<br> CRCs经常被叫做“校验和”，但是这样的说法严格来说并不是准确的，因为技术上来说，校验“和”是通过加法来计算的，而不是CRC这里的除法。<br> “错误纠正编码”（Error–Correcting Codes，简称ECC）常常和CRCs紧密相关，其语序纠正在传输过程中所产生的错误。这些编码方式常常和数学原理紧密相关。例如常见于通信或信息传递上BCH码、前向错误更正、Error detection and correction等</p> 
<h3><a id="_88"></a>多路访问链路和协议</h3> 
<p>在本章概述中,我们提到了有两种类型的网络链路:点对点链路和广播链路。点对点<br> 链路( point-toe- point link)由链路一端的单个发送方和链路另一端的单个接收方组成。许<br> 多链路层协议都是为点对点链路设计的,如点对点协议( point-- point protocol,PP)和高级数据链路控制(high- level datalink control,HDLC)就是两种这样的协议。第二种类型的链路是广播链路( broadcast ink),它能够让多个发送和接收结点都连接到相同的、单一的、共享的广播信道上。这里使用术语“广播”是因为当任何一个结点传输一个帧时,信道广播该帧,每个其他结点都收到一个副本。以太网和无线局域网是广播链路层技术的例子。:如何协调多个发送和接收结点对一个共享广播信道的访问,这就是多路访问问题( multiple aceessproblem)。广播信道通常用于局域网中,局域网是一个地理上集中在一座建筑物中(或者在一个公司,或者在大学校园)的网络。因此我<br> 们还将在本节后面考察一下多路访问信道是如何在局域网中使用的。<br> 我们都很熟悉广播的概念,因为自电视发明以来就使用了这种通信方式。但是传统的电視是一种一个方向的广播(即一个固定的结点向许多接收结点传输),而计算机网络广播信道上的结点既能够发送也能够接收。多路访问协议( multiple access protocol),即结点通过这些协议来规范它们在共享的广播信道上的传输行为。在各种各样的网络环境下需要多路访问协议,包括有线和无线接入网,以及卫星网络。尽管从技术上讲每个结点通过它的适配器访问广播信道,把结点作为发送和接收设备。在实践中,数以百计或者甚至数以千计个结点能够通过一个广播信道直接通信。<br> 因为所有的结点都能够传输,所以多个结点可能会同时传输帧。当发生这种情况时,所有结点同时接到多个帧;这就是说,传输的帧在所有的接收方处碰撞( collide)了。通常,当碰撞发生时,没有一个接收结点能够有效地获得任何传输的帧;在某种意义下,碰撞帧的信号纠缠在一起。因此,涉及此次碰撞的所有帧都丢失了,在碰撞时间间隔中的广播信道被浪费了。显然,如果许多结点要频繁地传输帧,许多传输将导致碰撞,广播信道的大量带宽将被浪费掉。<br> 当多个结点处于活跃状态时,为了确保广播信道执行有用的工作,以某种方式协调活跃结点的传输是必要的。这种协调工作由多路访问协议负责。<br> 将任何多路访问协议划分为3种类型之一:信道划分协议( channel partitioning protocol)、随机接入协议( random access protocol)和轮流协议( taking- turns protocol)。<br> 给出下列条件。在理想情况下,对于速率为Rbps的广播信道,多路访问协议应该具有以下所希望的特性:</p> 
<ol><li>当仅有一个结点有数据发送时,该结点具有Rbps的吞吐量</li><li>当有M个结点要发送数据时,每个结点春吐量为R/Mbps。这不必要求M结点中的每一个结点总是有RM的瞬间速率,而是每个结点在一些适当定义的时间间隔内应该有R/M的平均传输速率。</li><li>协议是分散的;这就是说不会因某主结点故障而使整个系统崩溃。</li><li>协议是简单的,使实现不昂费</li></ol> 
<h4><a id="_103"></a>信道划分协议</h4> 
<p>时分多路复用(TDM)和频分多路复用(FDM)是两种能够用于在所有共享信道结点之间划分广播信道带宽的技术。举例来说,假设一个支持N个结点的信道且信道的传输速率为Rbps。TDM将时间划分为时间帧( time frame),并进步划分每个时间帧为N个时隙(slo)。(不应当把TDM时间帧与在发送和接收适配器之间交换的链路层数据单元相混淆,后者也被称为帧。为了减少混乱,在本小节中我们将链路层交换的数据单元称为分组。)然后把每个时隙分配给N个结点中的一个。无论何时某个结点在有分组要发送的时候,它在循环的TDM帧中指派给它的时隙内传输分组比特。通常,选择的时隙长度应使一个时隙内能够传输单个分组。<br> TDM是有吸引力的,因为它消除了碰撞而且非常公平:每个结点在每个帧时间内得到了专用的传输速率 R/N bps。然而它有两个主要缺陷。首先,结点被限制于R/Nbps的平均速率,即使当它是唯一有分组要发送的结点时。其次,结点必须总是等待它在传输序列中的轮次,即我们再次看到,即使它是唯一一个有帧要发送的结点。<br> TDM在时间上共享广播信道,而FDM将Rbps信道划分为不同的频段(每个频段具有B/N带宽),并把每个频率分配给N个结点中的一个。因此FDM在单个较大的Rbps信道中创建了N个较小的R/Nbps信道。FDM也有TDM同样的优点和缺点。它避免了碰撞,在N个结点之间公平地划分了带宽。然而,FDM也有TDM所具有的主要缺点,也就是限制一个结点只能使用R/N的带宽,即使当它是唯一一个有分组要发送的结点时。第三种信道划分协议是码分多址( Code Division Multiple Access,CDMA)。TDM和FDM分别为结点分配时隙和频率,而CDMA对每个结点分配一种不同的编码。然后每个结点用它唯一的编码来对它发送的数据进行编码。如果精心选择这些编码,CDMA网络具有一种奇妙的特性,即不同的结点能够同时传输,并且它们各自相应的接收方仍能正确接收发送方编码的数据比特(假设接收方知道发送方的编码),而不在乎其他结点的干扰传输。CDMA已经在军用系统中使用了一段时间(由于它的抗干扰特性)。</p> 
<h4><a id="_107"></a>随机接入协议</h4> 
<p>第二大类多访问协议是随机接入协议。在随机接入协议中,一个传输结点总是以信道的全部速率(即Rbps)进行发送。当有碰撞时,涉及碰撞的每个结点反复地重发它的帧(也就是分组),到该帧无碰撞地通过为止。但是当一个结点经历一次碰撞时,它不必立刻重发该帧。相反,它在重发该之前等待一个随机时延。涉及碰撞的每个结点独立地选择随机时延。因为该随机时延是独立地选择的,所以下述现象是有可能的:这些结点之一所选择的时延充分小于其他碰撞结点的时延,并因此能够无碰撞地将它的帧在信道中发出。</p> 
<h5><a id="_ALOHA_109"></a>时隙 ALOHA</h5> 
<p>在对时隙 ALOHA的描述中,我们做下列假设</p> 
<ul><li>所有帧由L比特组成。</li><li>时间被划分成长度为L/R秒的时隙(这就是说,一个时隙等于传输一帧的时间)。</li><li>结点只在时隙起点开始传输帧。</li><li>结点是同步的,每个结点都知道时隙何时开始。</li><li>如果在一个时隙中有两个或者更多个帧碰撞,则所有结点在该时隙结束之前检测到该碰撞事件。</li></ul> 
<p>令P是一个概率,即一个在0和1之间的数。在每个结点中,时隙 ALOHA的操作是简单的。<br> 当结点有一个新帧要发送时,它等到下一个时隙开始并在该时隙传输整个帧。如果没有碰撞,该结点成功地传输它的帧,从而不需要考虑重传该帧。(如果该结点有新帧,它能够为传输准备一个新帧。如果有碰撞,该结点在时隙结束之前检測到这次碰撞。该结点以概率P在后续的每个时隙中重传它的帧,直到该帧被无碰撞地传输出去。<br> 时隙ALOHA看起来有很多优点。与信道划分不同,当某结点是唯一活跃的结点时(一个结点如果有帧要发送就认为它是活跃的),时隙 ALOHA允许该结点以全速R连续传输。时隙 ALOHA也是高度分散的,因为每个结点检测碰撞井独立地决定什么时候重传(然而,时隙 ALOHA的确需要在结点中对时隙同步;时隙 ALOHA也是个极为简单的协议。</p> 
<h5><a id="ALOHA_122"></a>ALOHA</h5> 
<p>时隙 ALOHA协议要求所有的结点同步它们的传输,以在每个时隙开始时开始传输。第一个 ALOHA协议实际上是一个非时隙、完全分散的协议。在纯 ALOHA中,当一帧首次到达(即一个网络层数据报在发送结点从网络层传递下来),结点立刻将该帧完整地传输进广播信道。如果一个传输的帧与一个或多个传输经历了碰撞,这个结点将立即(在完全传输完它的碰撞帧之后)以概率p重传该帧。否则,该结点等待一个帧传输时间。<br> 在此等待之后,它则以概率P传输该帧,或者以概率1-p在另一个时间等待(保持空闲)。</p> 
<h5><a id="CSMA_125"></a>载波侦听多路访问（CSMA）</h5> 
<p>在时隙和纯 ALOHA中,一个结点传输的决定独立于连接到这个广播信道上的其他结点的活动。特别是,一个结点不关心在它开始传输时是否有其他结点碰巧在传输,而且即使有另一个结点开始干扰它的传输也不会停止传输。,即当一个传输结点在传输时一直在侦听此信道。如果它检测到另<br> 个结点正在传输干扰帧,它就停止传输,在重复“侦听-当空闲时传输”循环之前等待一段随机时间。<br> 这两个规则包含在载波侦听多路访问( Carrier Sense Multiple Access,CSMA)和具有碰撞检测的CSMA( CSMA with Collision Detection, CSMA/CD)协议族中。</p> 
<h5><a id="_129"></a>具有碰撞检测的载波侦听多路访问</h5> 
<p>在分析 CSMA/CD协议之前,从与广播信道相连的适配器(在结点中)的角<br> 度总结它的运行:</p> 
<ol><li>适配器从网络层一条获得数据报,准备链路层帧,并将其放入帧适配器缓存中。</li><li>如果适配器侦听到信道空闲(即无信号能量从信道进入适配器),它开始传输帧,在另一方面,如果适配器侦听到信道正在忙,它将等待,直到侦听到没有信号能量时才开始传输帧。</li><li>在传输过程中,适配器监视来自其他使用该广播信道的适配器的信号能量的存在。</li><li>如果适配器传输整个帧而未检測到来自其他适配器的信号能量,该适配器就完成了该帧。在另一方面,如果适配器在传输时检测到来自其他适配器的信号能量,它中止传输(即它停止了传输帧)。</li><li>中止传输后,适配器等待一个随机时间量,然后返回步骤2。</li></ol> 
<p>等待一个随机(而不是固定)的时间量的需求是明确的一一如果两个结点同时传输帧,然后这两个结点等待相同固定的时间量,它们将持续碰撞下去。但选择随机回退时间的时间间隔多大为好呢?如果时间间隔大而碰撞结点数量小,在重复“侦听一当空闲时传输”的步骤前,结点很可能等待较长的时间(使信道保持空闲)。在另一方面,如果时间间隔小而碰撞结点数量大,很可能选择的随机值将几乎相同,传输结点将再次碰撞。我们希望时间间隔应该这样:当碰撞结点数量较少时,时间间隔较短;当碰撞结点数量较大时,时间间隔较长。<br> 用于以太网以及 DOCSIS电缆网络多路访问协议中的二进制指数后退( binary exponential backoff)算法,简练地解决了这个问题。特别是,当传输一个给定帧时,在该帧经历了一连串的n次碰撞后,结点随机地从[0,1,2,…,2<sup>n</sup>-1]中选择一个K值。因此,一个帧经历的碰撞越多、,K选择的间隔越大。对于以太网,一个结点等待的实际时间量是K・512比特时间(即发送512比特进入以太网所需时间量的K倍),n能够取的最大值在10以内。</p> 
<h5><a id="CSMACD_141"></a>CSMA/CD效率</h5> 
<p>CSMA/CD效率( efficiency of CSMA/CD)定义为:当有大量的活跃结点且每个结点有大量的帧要发送时,帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额。为了给出效率的一个闭式的近似表示,令d<sub>prop</sub>表示信号能量在任意两个适配器之间传播所需的最大时间。令d<sub>trans</sub>表示传输一个最大长度的以太网帧的时间(对于10Mbps的以太网,该时间近似为1.2毫秒)。<br> 效率=1/(1+5d<sub>prop</sub>/d<sub>trans</sub>)</p> 
<h4><a id="_144"></a>轮流协议</h4> 
<p>多路访问协议的两个理想特性是:①当只有一个结点活跃时,该活跃结点具有Rbps的吞吐量;②当有M个结点活跃时,每个活跃结点的吞吐量接近R/Mbps。 ALOHA和CSMA协议具备第一个特性,但不具备第二个特性。这激发研究人员创造另一类协议,也就是 <strong>轮流协议</strong>( taking- turns protoeol)。和随机接入协议一样,有几十种轮流协议,其中每个协议又都有很多变种。这里我们要讨论两种比较重要的协议。<br> 第一种是 <strong>轮询协议</strong>( polling protocol)。轮询协议要求这些结点之一要被指定为主结点。主结点以循环的方式轮询(pl)每个结点。特别是,主结点首先向结点1发送一个报文,告诉它(结点1)能够传输的帧的最多数量。在结点1传输了某些帧后,主结点告诉结点2它(结点2)能够传输的帧的最多数量。上述过程以这种方式继续进行,主结点以循环的方式轮询了每个结点轮询协议消除了困扰随机接入协议的碰撞和空时隙,这使得轮询取得高得多的效率。<br> 但是它也有一些缺点。第一个缺点是该协议引入了轮询时延,即通知一个结点“它可以传输”所需的时间。例如,如果只有一个结点是活跃的,那么这个结点将以小于Rbps的速率传输,因为每次活跃结点发送了它最多数量的帧时,主结点必须依次轮询每一个非活跃的结点。第二个缺点可能更为严重,就是如果主结点有故障,整个信道都变得不可操作。<br> 第二种轮流协议是 <strong>令牌传递协议</strong>(oken- passing protocol)。在这种协议中没有主结点。一个称为 <strong>令牌</strong>( token)的小的特殊帧在结点之间以某种固定的次序进行交换。例如,结点1可能总是把令牌发送给结点2,结点2可能总是把今牌发送给结点3,而结点N可能总是把令牌发送给结点1。当一个结点收到令牌时,仅当它有一些帧要发送时,它才持有这个令牌;否则,它立即向下一个结点转发该令牌。当一个结点收到令牌时,如果它确实有顿要传输,它发送最大数目的帧数,然后把令牌转发给下一个结点。令牌传递是分散的,并有很高的效率。但是它也有自己的一些问题。例如,一个结点的故障可能会使整个信道崩溃。或者如果一个结点偶然忘记了释放令牌,则必须调用某些恢复步骤使令牌返回到循环中来。</p> 
<h4><a id="DOCSIS_149"></a>DOCSIS:用于电缆因特网接入的链路层协议</h4> 
<p>一个电缆接入网通常在电缆网头端将几千个住宅电缆调制解调器与一个 <strong>电缆调制解调器端接系统</strong>( Cable Modem Termination System,CMTS)连接。<strong>数据经电缆服务接口</strong>(Data-Over- Cable Service Interface,CMTS)规范( DOCSIS) DOCSIS2012]定义了电缆数据网络体系结构及其协议。 DOCSIS使用FDM将下行(CMTS到调制解调器)和上行(调制解调器到CMTS)网络段划分为多个频率信道。每个下行信道宽6MHz,每个信道具有大约40Mhps吞吐量;每个上行信道具有6.4MHz的最大信道带宽,并且最大的上行吞吐量约为30Mbps。每个上行和下行信道均为广播信道。CMTS在下行信道中传输的帧被所有在信道上做接收的电缆调制解调器接收到;然而因为仅有单一的CMTS在下行信道上传输,不存在多路访问问题。但在上行方向,存在着多个有趣的技术挑战,因为多个电缆调制解调器共享到CMTS的相同上行信道(频率),因此能够潜在地出现碰撞。<br> 每条上行信道被划分为时间间隔(类似于TDM),每个时间间隔包含序列微时隙,电缆调制解调器可在该微时隙中向CMTS传输。CMTS显式地准许各个电缆调制解调器在特定的微时隙中进行传输。CMIS在下行信道上通过发送称为MAP报文的控制报文,指定哪个电缆调制解调器(带有要发送的数据)能够在微时隙中传输由控制报文指定的时间间隔。由于微时隙明确分配给电缆调制解调器,故CMTS能够确保在微时隙中没有碰撞传输。<br> 但是CMTS一开始是如何知道哪个电缆调制解调器有数据要发送呢?通过让电缆调制解调器在专用于此目的的一组特殊的微时隙间隔内向CMIS发送微时隙请求帧来完成该任务。这些微时隙请求帧以随机接入方式传输,故可能相互碰撞。电缆调制解调器既不能侦听上行信道是否忙,也不能检测碰撞。相反,该电缆调制解调器如果没有在下一个下行控制报文中收到对请求分配的响应的话,就推断出它的微时隙请求帧经历了一次碰撞。当推断出一次碰撞,电缆调制解调器使用二进制指数回退将其微时隙请求帧延缓到以后的时隙重新发送。当在上行信道上有很少的流量,电缆调制解调器可能在名义上分配给微时隙请求帧的时隙内实际传输数据帧(因此避免不得不等待微时隙分配)因此,电缆接人网可作为应用多路访问协议(即FDM、TDM、随机接入和集中分配时隙都用于一个网络中)的一个极好例子。</p> 
<h3><a id="_153"></a>交换局域网</h3> 
<h4><a id="ARP_154"></a>链路层寻址和ARP</h4> 
<ol><li>MAC地址<br> 事实上,并不是主机或路由器具有链路层地址,而是它们的适配器(即网络接口)具有链路层地址。因此,具有多个网络接口的主机或路由器将具有与之相关联的多个链路层地址,就像它也具有与之相关联的多个IP地址一样。然而,重要的是注意到链路层交换机并不具有与它们的接口(这些接口是与主机和路由器相连的)相关联的链路层地址。这是因为链路层交换机的任务是在主机与路由器之间承载数据报;交换机透明地执行该项任务,这就是说,主机或路由器不必明确地将帧寻址到其间的交换机。链路层地址有各种不同的称呼:LAN地址( LAN address))、物理地址( physicaldres)或MAC地址( MAC address)。因为MAC地址似乎是最为流行的术语,所以我们此后就将链路层地址称为MAC地址。对于大多数局域网(包括以太网和802.11无线局域网)而言,MAC地址长度为6字节,共有2<sup>48</sup>个可能的MAC地址。这些6个字节地址通常用十六进制表示法,地址的每个字节被表示为一对十六进制数。尽管MAC地址被设计为水久的,但用软件改变一块适配器的MAC地址现在是可能的。<br> MAC地址的一个有趣性质是没有两块适配器具有相同的地址。考虑到适配器是由许多不同国家和地区的不同公司生产的,这看起来似乎是件神奇之事。中国台湾生产适配器的公司如何能够保证与比利时生产适配器的公司使用不同的地址呢?答案是IEEE在管理着该MAC地址空间。特别是,当个公司要生产适配器时,它支付象征性的费用购买组成2<sup>48</sup>个地址的一块地址空间。IEEE分配这块2<sup>48</sup>个地址的方式是:固定一个MAC地址的前24比特,让公司自己为每个适配器生成后24比特的唯一组合。<br> 适配器的MAC地址具有扁平结构(这与层次结构相反),而且不论适配器到哪里用都不会变化。带有以太网接口的便携机总具有同样的MAC地址,无论该计算机位于何方。具有802.11接口的一台智能手机总是具有相同的MAC地址,无论该智能手机到哪里。与之形成对照的是,前面说过的IP地址具有层次结构(即一个网络部分和一个主机部分),而且当主机移动时,主机的IP地址需要改变,即改变它所连接到的网络。适配器的MAC地址与人的社会保险号相似,后者也具有扁平寻址结构,而且无论人到哪里该号码都不会变化。IP地址则与一个人的邮政地址相似,它是有层次的,无论何时当人搬家时,该地址都必须改变。就像一个人可能发现邮政地址和社会保险号都有用那样,一台主机具有一个网络层地址和一个MAC地址是有用的。<br> 当某适配器要向某些目的适配器发送一个帧时,发送适配器将目的适配器的MAC地址插入到该帧中,并将该帧发送到局域网上。如我们马上要看到的那样,一台交换机偶尔将一个人帧广播到它的所有接口。我们将在第6章中看到802.11也广播帧。因此一块适配器可以接收一个并非向它寻址的帧。这样,当适配器接收到一个帧时,将检查该帧中的目的MAC地址是否与它自己的MAC地址匹配。如果匹配,该适配器提取出封装的数据报,并将该数据报沿协议栈向上传递。如果不匹配,该适配器丢弃该帧,而不会向上传递该网络层数据报。所以,仅当收到该帧时,才会中断目的地。<br> 然而,有时某发送适配器的确要让局域网上所有其他适配器来接收并处理它打算发送的帧。在这种情况下,发送适配器在该帧的目的地址字段中插入一个特殊的MAC广播地址( broadcast address)。对于使用6字节地址的局域网(例如以太网和802.11)来说,广播地址是48个连续的1组成的字符串(即以十六进制表示法表示的F-FF-FF-FF-FF-FF)。</li><li>地址解析协议<br> 因为存在网络层地址(例如,因特网的IP地址)和链路层地址(即MAC地址),所以需要在它们之间进行转换。对于因特网而言,这是地址解析协议( Address ResolutionProtocol,ARP)<a href="https://tools.ietf.org/html/rfc826" rel="nofollow">RFC 826</a>的任务。<br> 每台主机或路由器在其内存中具有一个ARP表( ARP table),这张表包含IP地址到MAC地址的映射关系。<br> 关于ARP协议有两件有趣的事情需要注意。首先,查询ARP报文是在广播帧中发送的,而响应ARP报文在一个标准帧中发送。在继续阅读之前,你应该思考一下为什么这样。其次,ARP是即插即用的,这就是说,一个ARP表是自动建立的,即它不需要系统管理员来配置。并且如果某主机与子网断开连接,它的表项最终会从留在子网中的结点的表中删除掉。<br> 一个ARP分组封装在链路层帧中,因而在体系结构上位于链路层之上。然而,一个ARP分组具有包含链路层地址的字段,因而可认为是链路层协议,但它也包含网络层地址,因而也可认为是为网络层协议。所以,可能最好把ARP看成是跨越链路层和网络层边界两边的协议。</li><li>发送数据报到子网以外<br> 一旦发送适配器有了这个MAC地址,它创建一个帧,并把该帧发送到子网中。在子网上的路由器适配器看到该链路层帧是向它寻址的,因此把这个顿传递给路由器的网络层。该IP数据报终于被成功地从源主机移动到这台路由器了!要将该数据报从路由器移动到目的地。路由器现在必须决定该数据报要被转发的正确接口。这是通过查询路由器中的转发表来完成的。转发表告诉这台路由器该数据报要通过路由器接口转发。然后该接口把这个数据报传递给它的适配器,适配器把该数据报封装到一个新的帧中,并且将帧发送进子网中。这时,该帧的目的MAC地址确实是最终目的地MAC地址。路由器又是怎样获得这个目的地MAC地址的呢?当然是用ARP获得的。</li></ol> 
<h4><a id="_168"></a>以太网</h4> 
<p>首先,以太网是第一个广泛部署的高速局域网。因为它部署得早,网络管理员非常熟悉以太网(它的奇迹和它的奇思妙想),并当其他局域网技术问世时,他们不愿意转而用之。其次,令牌环、FDDI和ATM比以太网更加复杂、更加昂贵,这就进一步阻碍了网络管理员改用其他技术。第三,改用其他局域网技术(例如FDDI和ATM)的最引人注目的原因通常是这些新技术具有更高数据速率;然而以太网总是奋起抗争,产生了运行在相同或更高数据速率下的版本。20世纪90年代初期还引入了交换以太网,这就进一步増加了它的有效数据速率。最后,由于以太网已经很流行了,所以以太网硬件(尤其是适配器和交换机)成为了一个普通商品,而且极为便宜。<br> 初始的以太局域网使用同轴电缆总线来互联结点。以太网的总线拓扑实际上从20世纪80年代到90年代中期一直保持不变。使用总线拓扑的以太网是一种广播局域网,即所有传输的顿传送到与该总线连接的所有适配器并被其处理。<br> 到了20世纪90年代后期,大多数公司和大学使用一种基于集线器的星形拓扑以太网安装替代了它们的局域网。在这种安装中,主机(和路由器)直接用双绞对铜线与一台集线器相连。 <strong>集线器</strong>(hub)是一种物理层设备,它作用于各个比特而不是作用于顿。当表示一个0或一个1的比特到达一个接口时,集线器只是重新生成这个比特,将其能量强度放大,并将该比特向其他所有接口传输出去。因此,采用基于集线器的星形拓扑的以太网也是一个广播局域网,即无论何时集线器从它的一个接口接收到一个比特,它向其所有其他接口发送该比特的副本。特别是,如果某集线器同时从两个不同的接口接收到帧,将出现一次碰撞,生成该帧的结点必须重新传输该帧。<br> 在21世纪早期,以太网又经历了一次重要的革命性変化。以太网安装继续使用星形拓扑,但是位于中心的集线器被 <strong>交换机</strong>( switch)所替代。仅知道交换机不仅是“无碰撞的”,而且也是名副其实的存储转发分组交换机就可以了;但是与运行在高至第3层的路由器不同,交换机仅运行在第2层。</p> 
<ul><li>以太网帧结构<br> 为了将对以太网帧的讨论放到切实的环境中,考虑从一台主机向另一台主机发送一个IP数据报,且这两台主机在相同的以太局域网上 (尽管以太网帧的负载是一个P数据报,但我们注意到以太网帧也能够承载其他网络层分组。)设发送适配器(即适配器A)的MAC地址是A-AA-AA-AA-AA-AA,接收适配器(即适配器B)的MAC地址是BB-BB-B-BB-BB-B。发送适配器在一个以太网顿中封装了一个P数据报,并把该帧传递到物理层。接收适配器从物理层收到这个顿,提取出IP数据报,并将该P数据报传递给网络层。我们现在在这种情况下考察如表所示的以太网帧的6个字段：</li></ul> 
<table><thead><tr><th>前同步码</th><th>目的地址</th><th>源地址</th><th>类型</th><th>数据</th><th>CRC</th></tr></thead><tbody></tbody></table> 
<ul><li>数据字段(46~1500字节)。这个字段承载了P数据报。以太网的最大 **传输单元(MTU)**是1500字节。这意味着如果P数据报超过了1500字节,则主机必须将该数据报分片。数据字段的最小长度是46字节。这意味如果IP数据报小于46字节,数据报必须被填充到46字节。当采用填充时,传递到网络层的数据包括P数据报和填充部分。网络层使用IP数据报首部中的长度字段来去除填充部分。</li><li>目的地址(6字节)。这个字段包含目的适配器的MAC地址,即BB-BB-BB-BB-BB-BB。当适配器B收到一个以太网帧,帧的目的地址无论是BB-BB-BB-BB-BB-BB,还是MAC广播地址,它都将该帧的数据字段的内容传递给网络层;如果它收到了具有任何其他MAC地址的帧,则丢弃之.</li><li>源地址(6字节)。这个字段包含了传输该帧到局域网上的适配器的MAC地址.</li><li>类型字段(2字节)。类型字段允许以太网复用多种网络层协议。主机能够使用除了IP以外的其他网络层协议。事实上,一台给定的主机可以支持多种网络层协议,以对不同的应用采用不同的协议。因此,当以太网帧到达适配器,适配器需要知道它应该将数据字段的内容传递给哪个网络层协议(即分解)。IP和其他链路层协议(例如, Novell IPX或 Apple Talk)都有它们各自的、标准化的类型编号。此外,ARP协议(在上一节讨论过)有自己的类型编号,并且如果到达的帧包含ARP分组(即类型字段的值为十六进制的0806),则该ARP分组将被多路分解给ARP协议。注意到该类型字段和网络层数据报中的协议字段、运输层报文段的端口号字段相类似;所有这些字段都是为了把一层中的某协议与上一层的某协议结合起来。</li><li>CRC(4字节)。CRC(循环冗余检测)字段的目的是使得接收适配器(适配器B)检测測帧中是否引入了差错。</li><li>前同步码(8字节)。以太网顿以一个8字节的前同步码( Preamble)字段开始。该前同步码的前7字节的值都是10101010;最后一个字节是10101011。前同步码字段的前7字节用于“唤醒”接收适配器,并且将它们的时钟和发送方的时钟同步。记住适配器的目的是根据以太局域网类型的不同,分别以10Mbps、100Mbps或者1Cbps的速率传输帧。然而,没有什么是完美无缺的,因此适配器A不会以精确的额定速率传输帧;相对于额定速率总有些漂移,局域网上的其他适配器不会预先知道这种漂移的。接收适配器只需通过锁定前同步码的前7字节的比特,就能够锁定适配器A的时钟。前同步码的第8个字节的最后两个比特(第一个出现的两个连续的1)警告其他适配器,“重要的内容”就要到来了。</li></ul> 
<p>所有的以太网技术都向网络层提供无连接服务。这就是说,当适配器A要向适配器B发送一个数据报时,适配器A在一个以太网帧中封装该数据报,并且把该帧发送到局域网上,没有先与适配器B握手。这种第二层的无连接服务类似于P的第三层数据报服务和UDP的第4层无连接服务。<br> 以太网技术都向网络层提供不可靠服务( unreliable service)。特别是,当适配器B收到一个来自适配器A的帧,它对该帧执行CRC校验,但是当该帧通过CRC校验时它既不发送确认帧;而当该帧没有通过CRC校验时它也不发送否定确认帧。当某帧没有通过CRC校验,适配器B只是丢弃该帧。因此,适配器A根本不知道它传输的帧是否到达了B并通过了CRC校验。(在链路层)缺乏可靠的传输有助于使得以太网简单和便宜。但是它也意味着传递到网络层的数据报流能够有间隙。<br> 如果由于丢弃了以太网帧而存在间隙,主机B上的应用也会看见这个间隙吗?这只取决于该应用是使用UDP还是使用TCP。如果应用使用的是UDP,则主机B中的应用的确会看到数据中的间隙。另一方面,如果应用使用的是TCP,则主机B中的TCP将不会确认包含在丢弃帧中的数据,从而引起主机A的TCP重传。注意到当TCP重传数据时,数据最终将回到曾经丢弃它的以太网适配器。因此,从这种意义上来说,以太网的确重传了数据,尽管以太网并不知道它是正在传输一个具有全新数据的全新数据报,还是一个包含已经被传输过至少一次的数据的数据报。</p> 
<ul><li>以太网技术<br> 从历史上讲,以太网最初被构想为一段同轴电缆。早期的10BASE-2和10BASE-5标准规定了在两种类型的同轴电缆之上的10Mbps以太网,每种标准都限制在500米长度之内。通过使用 <strong>转发器</strong>( repeater)能够得到更长的运行距离,而转发器是一种物理层设备它能在输入端接收信号并在输出端再生该信号。同轴电缆很好地对应于我们将作为一种广播媒体的以太网视图,即由一个接口传输的所有帧可在其他接口收到,并且以太网的CSMA/CD协议很好地解决了多路访问问题。结点直接附着在电缆上。多年来以太网已经经历了一系列演化步骤,今天的以太网非常不同于使用同轴电缆的初始总线拓扑的设计。在今天大多数的安装中,结点经点对点的由双绞铜线或光纤线缆构<br> 成的线段与一台交换机相连。<br> 在20世纪90年代中期,以太网被标准化为100Mbps,比10Mbps以太网快10倍。初始的以太网MAC协议和帧格式保留了下来,但更高速率的物理层被定义为用铜线(100BASE-T)和用光纤(100BASE-FX、100BASE-SX、100BASE-BX)。100Mbps以太网用双绞线距离限制为100米,用光纤距离限制为几千米,允许把不同建筑物中的以太网交换机连接起来。初始总线拓扑的设计。在今天大多数的安装中,结点经点对点的由双绞铜线或光纤线缆构成的线段与一台交换机相连。<br> 吉比特以太网是对极为成功的10Mbps和100Mbps以太网标准的扩展。吉比特以太网提供1000Mbps的总数据速率,与大量已经安装的以太网设备基础保持完全兼容。吉比特以太网的标准称为IEE802.3z,它完成以下工作：<br> 使用标准以太网帧格式,并且后向兼容10BASE-T与100BASE-T技术。这使得吉比特以太网和现已安装的以太网设备基础很容易集成。允许点对点链路以及共享的广播信道。如前所述,点对点链路使用交换机,而广播信道使用集线器。在吉比特以太网术语中,集线器被称为“带缓存的分配器”。使用 CSMA/CD来共享广播信道。为了得到可接受的效率,结点之间的最大距离必须严格限制。<br> 对于点对点信道,允许在两个方向上都以1000bps全双工操作。吉比特以太网最初工作于光纤之上,现在能够工作在5类UTP线缆上。10Cbps以太网(10 CBASE-T)于2007年已被标准化了,可提供更高的以太局域网能力。<br> 在总线拓扑和基于集线器的星形拓扑技术时代,以太网很显然是一种广播链路,其中多个结点同时传输时会出现帧碰撞。为了处理这些碰撞,以太网标准包括了 CSMA/CD协议,该协议对于跨越一个小的地理半径的有线广播局域网特别有效。但是对于今天广为使用的以太网是基于交换机的星形拓扑,采用的是存储转发分组交换,是否还真正需要一种以太网MAC协议呢?如我们很快所见,交换机协调其传输,在任何时候决不会向相同的接口转发超过一个帧。此外,现代交换机是全双工的,这使得一台交换机和一个结点能够在同时向对方发送帧而没有干扰。换句话说,在基于交换机的以太局域网中,不会有碰撞,因此没有必要使用MAC协议了。<br> 今天的以太网与 Metcalfe和Bogs在30多年前构想的初始以太网有非常大的不同,即速度已经增加了3个数量级,以太网帧承载在各种各样的媒体之上,交换以太网已经成为主流,此时甚至连MAC协议也经常是不必要的了!所有这些还真正是以太网吗?答案当然是:“是的,根据定义如此。”然而,注意到下列事实是有趣的:通过所有这些改变,的确还有一个历经30年保持未变的持久不变量,即以太网帧格式。也许这オ是以太网标准的一个真正重要的特征。</li></ul> 
<h4><a id="_203"></a>链路层交机</h4> 
<p>交换机的任务是接收入链路层帧并将它们转发到出链路。交换机自身对子网中的主机和路由器是 <strong>透明的</strong>(transparent);这就是说,某主机/路由器向另一个主机/路由器寻址一个帧(而不是向交换机寻址该帧),顺利地将该帧发送进局域网,并不知道某交换机将会接收该帧并将它转发到另一个结点。这些帧到达该交换机的任何输出接口之一的速率可能暂时会超过该接口的链路容量。为了解决这个问题,交换机输出接口设有缓存,这非常类似于路由器接口为数据报设有缓存。</p> 
<ul><li>交换机转发和过滤<br> <strong>过滤</strong>( filtering)是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。<br> <strong>转发</strong>( forwarding)是决定一个帧应该被导向哪个接口,并把该帧移动到那些接口的交换机功能。<br> 交换机的过滤和转发借助于 <strong>交换机表</strong>( switch table)完成。该交换机表包含某局域网上某些主机和路由器的但不必是全部的表项。交换机表中的一个表项包含:①一个MAC地址;②通向该MAC地址的交换机接口;③表项放置在表中的时间。</li><li>自学习<br> 交换机具有令人惊奇的特性(特别是对于早已超负荷工作的网络管理员),那就是它的表是自动、动态和自治地建立的,即没有来自网络管理员或来自配置协议的任何于预。换句话说,交换机是 <strong>自学习</strong>( self-leaming)的。这种能力是以如下方式实现的： 
  <ol><li>交换机表初始为空。</li><li>对于在每个接口接收到的每个入帧,该交换机在其表中存储:①在该帧源地址字段中的MAC地址;②该幀到达的接口;③当前时间。交换机以这种方式在它的表中记录了发送结点所在的局域网网段。如果在局域网上的每个结点最终都发送了一个帧,则每个结点最终将在这张表中留有记录。</li><li>如果在一段时间(称为老化期( aging time)后,交换机没有接收到以该地址作为源地址的帧,就在表中删除这个地址。以这种方式,如果一台PC被另一台PC(具有不同的适配器)代替,原来PC的MAC地址将最终从该交换机表中被清除掉。</li></ol> </li></ul> 
<p>交换机是 <strong>即插即用设备</strong>(plug-and- play device),因为它们不需要网络管理员或用户的干预。要安装交换机的网络管理员除了将局域网网段与交换机的接口相连外,不需要做其他任何事。管理员在安装交换机或者当某主机从局域网网段之一被去除时,他没有必要配置交换机表。交换机也是双工的,这意味着任何交换机接口能够同时发送和接收。</p> 
<ul><li> <p>链路层交换机的性质<br> 指出使用交换机的几个优点,它们不同于如总线或基于集线器的星形拓扑那样的广播链路：</p> 
  <ul><li>消除碰撞。在使用交换机(不使用集线器)构建的局域网中,没有因碰撞而浪费的带宽!交换机缓存帧并且决不会在网段上同时传输多于一个帧。就像使用路由器一样,交换机的最大聚合带宽是该交换机所有接口速率之和。因此,交换机提供了比使用广播链路的局域网高得多的性能改善。</li><li>异质的链路。交换机将链路彼此隔离,因此局域网中的不同链路能够以不同的速率运行并且能够在不同的媒体上运行。因此,对于原有的设备与新设备混用,交换机是理想的管理。除了提供强化的安全性(参见插入材料“关注安全性”),交换机也易于进行网络管理。交换机也收集带宽使用的统计数据、碰撞率和流量类型,并使这些信息为网络管理者使用。这些信息能够用于调试和解决问题,并规划该局域网在未来应当演化的方式。</li></ul> </li><li> <p>路由器与交换机的比较<br> 路由器是使用网络层地址转发分组的存储转发分组交换机。尽管交换机也是一个存储转发分组交换机,但它和路由器是根本不同的,因为它用MAC地址转发分组。交换机是第二层的分组交换机,而路由器是第三层的分组交换机。即使交换机和路由器从根本上是不同的,网络管理员在安装互联设备时也经常必须在它们之间进行选择。路由器的确使得各系之间通信而不产生碰撞。既然交换机和路由器都是候选的互联设备,那么这两种方式<br> 的优点和缺点各是什么呢?<br> 首先考虑交换机的优点和缺点。如上面提到的那样,交换机是即插即用的,这是世界上所有超负荷工作的网络管理员都喜爱的特性。交换机还能够具有相对高的分组过滤和转发速率,交换机必须处理高至第二层的帧,而路由器必须处理高至第三层的数据报。在另一方面,为了防止广播帧的循环,交换网络的活跃拓扑限制为一棵生成树。另外,一个大型交换网络将要求在主机和路由器中有大的ARP表,这将生成可观的ARP流量和处理量。而且,交换机对于广播风暴并不提供任何保护措施,即如果某主机出了故障并传输出没完没了的以太网广播帧流,该交换机将转发所有这些帧,使得整个以太网的崩溃。<br> 现在考虑路由器的优点和缺点。因为网络寻址通常是分层次的(不像MAC寻址那样是扁平的),即使当网络中存在冗余路径时,分组通常也不会通过路由器循环。(然而,当路由器表被误配置时,分组可能循环,IP用一个特殊的报文首部字段来限制循环。)所以,分组就不会被限制到一棵生成树上,并可以使用源和目的地之间的最佳路径。因为路由器没有生成树限制,所以它们允许以丰富的拓扑结构构建因特网。路由器的另一个特色是它们对第二层的广播风暴提供了防火墙保护。尽管也许路由器最重要的缺点就是它们不是即插即用的,即路由器和连接到它们的主机都需要人为地配置IP地址。而且路由器对每个分组的处理时间通常比交换机更长,因为它们必须处理高达第三层的字段。<br> 通常,由几百台主机组成的小网络通常有几个局域网网段。对于这些小网络,交换机就足够了,因为它们不要求IP地址的任何配置就能使流量局部化并增加总计吞吐量。但是在由几千台主机组成的更大网络中,通常在网络中(除了交换机之外)还包括路由器。路由器提供了更健壮的流量隔离方式和对广播风暴的控制,并在网络的主机之间使用更“智能的”路由。</p> </li></ul> 
<p><strong>流行的互联网设备的典型特色比较</strong></p> 
<table><thead><tr><th></th><th>集线器</th><th>路由器</th><th>交换机</th></tr></thead><tbody><tr><td>流量隔离</td><td>无</td><td>有</td><td>有</td></tr><tr><td>即插即用</td><td>有</td><td>无</td><td>有</td></tr><tr><td>优化路由</td><td>无</td><td>有</td><td>无</td></tr></tbody></table> 
<h4><a id="_237"></a>虚拟局域网</h4> 
<p>现代机构的局域网常常是配置为等级结构的,每个工作组(部门)有自己的交换局域网,经过一个交换机等级结构与其他工作组的交换局城网互联。虽然这样的配置在理想世界中能够很好地工作,但在现实世界常常不尽如人意。发现3个缺点:</p> 
<ul><li>缺乏流量隔离。尽管该等级结构把组流量局域化到一个单一交换机中,但广播流量(例如携带ARP和DHCP报文或那些目的地还没有被自学习交换机学习到的帧)仍然必须跨越整个机构网络。限制这些广播流量的范围将改善局城网的性能。也许更为重要的是,为了安全/隐私的目的也可能希望限制局域网广播流量。</li><li>交換机的无效使用。如果该机构不止有3个组,而是有10个组,则将要求有10个第一级交换机。如果每个组都较小、比如说少于10个人,则单台96端口的交换机将足以容纳每个人,但这台单一的交换机将不能提供流量隔离。</li><li>管理用户。如果一个雇员在不同组间移动,必须改变物理布线,以将该雇员连接到不同的交换机上。</li></ul> 
<p>幸运的是,这些难题中的每个都能够通过 <strong>支持虚拟局域网</strong>( Virtua Local Network VLAN)的交换机来处理。顾名思义,支持VLAN的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网。在一个VLAN内的主机彼此通信,仿佛它们(并且没有其他主机)与交换机连接。在一个基于端口的VLAN中,交换机的端口(接口)由网络管理员划分为组。每个组构成一个VLAN,在每个VLAN中的端口形成一个广播域(即来自一个端口的广播流量仅能到达该组中的其他端口)。这个VLAN解决了上面提到的所有困难即 EE VLAN帧和 CS VLAN帧彼此隔离。人们容易想象到VLAN交换机配置和操作的方法,即网络管理员使用交换机管理软件声明一个端口属于某个给定的VLAN(其中未声明的端口属于一个默认的VLAN),在交换机中维护一张端口到VLAN的映射表;交换机软件仅在属于相同VLAN的端口之间交付帧。<br> 一种更具扩展性互联VLAN交换机的方法称为 <strong>VLAN干线连接</strong>( VLAN trunking)。每台交换机上的一个特殊端口被配置为干线端口,以互联这两台VLAN交换机。该干线端口属于所有VLAN,发送到任何VLAN的帧经过干线链路转发到其他交换机。但这会引起另外的问题:一个交换机怎样知道到达干线端口的帧属于某个特定的VLAN呢?IEE定义了一种扩展的以太网帧格式802.1Q,用于跨越VLAN干线的帧。802.1Q帧由标准以太网帧与加进首部的4字节 <strong>VLAN标签</strong>( VLAN tag)组成,而VLAN标签承载着该帧所属的VLAN标识符。VLAN标签由在VLAN干线发送侧的交换机加进帧中,解析后并由在VLAN干线接收侧的交换机删除。VLAN标签自身由一个2字节的 <strong>标签协议标识符</strong>( Tag Protocol Identifier,TPID)字段(具有固定的十六进制81-00)、一个2字节的标签控制信息字段(包含一个12比特的VLAN标识符字段)和一个3比特优先权字段(具有类似于IP数据报T0S字段的目的)组成。</p> 
<h3><a id="_246"></a>链路虚拟化:网络作为链路层</h3> 
<p>将链路视为连接两台通信主机的物理线路。在学习多路访问协议时,我们看到了多台主机能够通过一条共享的线路连接起来,并且连接主机的这种“线路”能够是无线电频谱或其他媒体。这使我们将该链路更多地抽象为一条信道,而不是作为一条线路。互联媒体实际上能够是一种相当复杂的交换基础设施。然而,经过这种演化,主机本身维持着这样的视图,即互联媒体只是连接两台或多台主机的链路层信道。<br> 在两台主机之间由拨号调制解调器连接的场合,连接这两台主机的锥路实际上是电话网,这是一个逻辑上分离的、全球性的电信网络,它有自己的用于数据传输和信令的交换机、链路和协议栈。然而,从因特网链路层的观点看,通过电话网的拨号连接被看做一根简单的“线路”。在这个意义上,因特网虚拟化了电话网,将电话网看成为两台因特网主机之间提供链路层连接的链路层技术。<br> 多协议标签交换(MPLS)网络。与电路交换的电话网不同MPLS客观上讲是一种分组交换的虚电路网络。它们有自己的分组格式和转发行为。因此,从教学法的观点看,有关MPLS的讨论既适合放在网络层的学习中,也适合放在链路层的学习中。然而,从因特网的观点看,我们能够认为MPLS像电话网和交换以太网一样,作为为IP设备提供互联服务的链路层技术。因此,我们将在链路层讨论中考虑 MPLS。帧中继和ATM网络也能用于互联IP设备,虽然这些技术看上去有些过时(但仍在部署)。</p> 
<p><strong>多协议标签交换</strong><br> 通过采用虚电路网络领域的一个关键概念一一固定长度标签,多协议标签交换(Mulprotocol Label Switching,MPLS)自20世纪90年代中后期在一些产业界的努力下进行演化,以改善IP路由器的转发速度。其目标是:对于基于固定长度标签和虚电路的技术,在不放弃基于目的地IP数据报转发的基础设施的前提下,当可能时通过选择性地标识数据报并允许路由器基于固定长度的标签(而不是目的地IP地址)转发数据报来增强其功能重要的是,这些技术与IP协同工作,使用P寻址和路由选择。IETF在MPIS协议中统一了,这些努力有效地将虛电路技术综合进了路由选择的数据报网络。<a href="https://tools.ietf.org/html/rfc3031" rel="nofollow">RFC3031</a>,<a href="https://tools.ietf.org/html/rfc3032" rel="nofollow">RFC3032</a><br> 首先考虑由MPLS使能的路由器处理的链路层帧格式,以此开始学习MPLS。<br> 在MPLS使能的路由器之间传输的一个链路层帧,该帧具有一个小的MPLS首部该首部増加到第二层(如以太网)首部和第三层(即IP)首部之间。<a href="https://tools.ietf.org/html/rfc3032" rel="nofollow">RFC3032</a>定义了用于这种链路的MPLS首部的格式;用于ATM和帧中继网络的首部也定义在其他的RFC文档中。包括在MPIS首部中的字段是:标签，它起着虚电路标识符的作用;3比特的实验字段(保留用于实验);单比特S字段用于指示一系列“成栈”的 MPIS首部的结東;以及寿命字段。<br> 一个MPHS加强的帧仅能在两个均为MPLS使能的路由器之间发送。一个MPIS使能的路由器常被称为 <strong>标签交换路由器</strong>( label-switched router),因为它通过在其转发表中查找MPIS标签,然后立即将数据报传递给适当的输出接口来转发MPLS帧。因此,MPLS使能的路由器不需要提取目的IP地址和在转发表中执行最长前级匹配的查找。</p> 
<h3><a id="_256"></a>数据中心网络</h3> 
<p>近年来,因特网公司如谷歌、微软已经构建了大量的数据中心。每个数据中心都容纳了数万至数十万台主机,并且同时支持着很多不同的云应用(例如搜索和电子商务)。每个数据中心都有自己的 <strong>数据中心网络</strong>( data center network),这些数据中心网络将其内部主机彼此互联并与因特网中的数据中心互联。<br> 数据中心中的主机称为 <strong>刀片</strong>( blade),与比萨饼盒类似,一般是包括CPU、内存和磁盘存储的商用主机。主机被堆叠在机架上,每个机架一般堆放20-40台刀片。在每一个机架顶部有台交换机,这台交换机被形象地称为 <strong>机架顶部交换机</strong>( Top of Rack,TOR),它们与机架上的主机互联,并与数据中心中的其他交换机互联。具体来说,机架上的每台主机都有块与TOR交换机连接的网卡,每台TOR交换机有额外的端口能够与其他TOR交换机连接。尽管目前主机通常有1Gbps的以太网与其TOR交换机连接,但10Cbp5的连接也许成为标准。每台主机也会分配一个自己的数据中心内部的IP地址。<br> 数据中心网络支持两种类型的流量:在外部客户与内部主机之间流动的流量,以及内部主机之间流动的流量。为了处理外部客户与内部主机之间流动的流量,数据中心网络包括了台或者多台 <strong>边界路由器</strong>( border router),它们将数据中心网络与公共因特网相连。数据中心网络因此需要将所有机架彼此互联,并将机架与边界路由器连接。 <strong>数据中心网络设计</strong>( data center network design)是互联网络和协议设计的艺术，该艺术专注于机架彼此连接和边界路由器连接。</p> 
<h4><a id="_261"></a>负载均衡</h4> 
<p>一个云数据中心,如一个谷歌或者微软的数据中心,能够同时提供诸如搜索、电子邮件和视频应用等许多应用。为了支持来自外部客户的请求,每一个应用都与一个公开可见的IP地址关联,外部用户向该地址发送其请求并从该地址接收响应。在数据中心内部,外部请求首先被定向到一个 <strong>负载均衡器</strong>( load balancer)。负载均衡器的任务是向主机分发请求,以主机当前的负载作为函数来在主机之间均衡负载。一个大型的数据中心通常会有几台负载均衡器,每台服务于一组特定的云应用。由于负载均衡器基于分组的目的端口号以及目的IP地址做决策。一旦接收到一个对于特定应用程序的请求,负载均衡器将该请求分发到处理该应用的某一台主机上(该主机可能再调用其他主机的服务来协助处理该请求)。当主机处理完该请求后,向负载均衡器回送响应,再由负载均衡器将其中继发回给外部客户。负载均衡器不仅平衡主机间的工作负载,而且还提供类似NAT的功能,将外部IP地址转换为内部适当主机的IP地址然后将反方向流向客户的分组按照相反的转换进行处理。这防止客户直接接触主机,从而具有隐藏网络内部结构和防止客户直接与主机交互等安全性益处。</p> 
<h4><a id="_263"></a>等圾体系结构</h4> 
<p>对于仅有数千台主机的小型数据中心,一个简单的网络也许就足够了。这种简单网络由一台边界路由器、一台负载均衡器和几十个机架组成,这些机架由单一以太网交换机进行互联。但是当主机规模扩展到几万至几十万的时候,数据中心通常应用 <strong>路由器和交换机等级结构</strong>( hierarchy of router and switch)。在该等级结构的顶端,边界路由器与接入路由器相连(在图5-30中仅仅显示了两台,但是能够有更多)。在每台接入路由器下面、有3层交换机。每台接入路由器与一台顶层交换机相连,每台顶层交换机与多台二层交换机以及一台负载均衡器相连。每台二层交换机又通过机架的TOR交换机(第三层交换机)与多个机架相连。所有链路通常使用以太网作为链路层和物理层协议,并混合使用铜缆和光缆。通过这种等级式设计,可以将数据中心扩展到几十万台主机的规模。因为云应用提供商持续地提供高可用性的应用是至关重要的,所以数据中心在它们的设计中也包含了冗余网络设备和冗余链路。<br> 因为数据中心的一个关键需求是放置计算和服务的灵活性,所以支持主机到主机的高带宽通信十分重要。例如,一个大规模的因特网搜索引擎可能运行在跨越多个机架的上千台主机上,在所有主机对之间具有极高的带宽要求。类似地,像EC2这样的云计算服务可能希望将构成用户服务的多台虚拟机运行在具有最大容量的物理主机上,而无需考虑它们在数据中心的位置。如果这些物理主机跨越了多个机架,前面描述的网络瓶颈可能会导致性能不佳。</p> 
<h4><a id="_266"></a>数据中心网络的发展趋勢</h4> 
<p>为了降低数据中心的费用,同时提高其在时延和吞吐量上的性能,因特网云服务巨头都在不断地部署新的数据中心网络设计方案。尽管这些设计方案都是专有的,但是许多重要的趋势是一样的。<br> 其中的一个趋势是部署能够克服传统等级设计缺陷的新型互联体系结构和网络协议。一种方法是采用 <strong>全连接拓扑</strong>( fully connected topology)来替代交换机和路由器的等级结构。在这种设计中,每台第一层交换机都与所有第二层交换机相连,因此:①主机到主机的流量绝不会超过该交换机层次;②对于n台第一层交换机,在任意两台二层交换机间有a条不相交的路径。这种设计可以显著地改善主机到主机的容量。这种设计不仅减轻了主机到主机的容量限制,同时创建了一种更加灵活的计算和服务环境。在这种环境中,任何未连接到同一台交换机的两个机架之间的通信在逻辑上是等价的,而不论其在数据中心的位置如何。<br> 另外一个主要的趋势就是采用基于船运集装箱的 <strong>模块化数据中心</strong>( Modular Data CentMDC)。在MDC中,在一个标准的12米船运集装箱工厂构建一个“迷你数据中心”并将该集装箱运送到数据中心的位置。每一个集装箱都有多达数千台主机,堆放在数十台机架上,并且紧密地排列在一起。在数据中心位置,多个集装箱彼此互联,同时也和因特网连接。一且预制的集装箱部署在数据中心,通常难以检修。因此,每一个集装箱都得体地设计为性能下降:当组件(服务器和交换机)随着时间的推移出现故障时,集装箱继续运行但是性能下降。当许多组件出现故障并且性能已经下降到低于某个國值时,整个集装箱将会被移除,并用新的来替换。创建由集装箱构成的数据中心提出了新的联网挑战。对于MDC,有两种类型的网络:每一个集装箱中的内部网络和互联每个集装箱的核心网络。在每个集装箱内部,在规模上升到数千台主机的时候,通过廉价的商用吉比特以太网交换机创建全连接的网络(如前面所描述)是可行的。然而,核心网络的设计仍然是一个带有挑战性的问题,这需要能互联成百上千的集装箱,同时能够为典型工作负载提供跨多个集装箱的主机到主机间的高带宽。Farrington2010中提出了一种互联集装箱的混合电/光交换机体系结构，当采用高度互联拓扑的时候,一个主要的问题是设计交换机之间的路由选择算法。种可能是采用随机路由选择方式。另一种可能是在每台主机中部署多块网络接口卡,将每台主机连接到多台低成本的商用交换机上,并且允许主机自己在交换机间智能地为流量选路。这些方案的变种和扩展正被部署在当前的数据中心中。</p> 
<h3><a id="Web_270"></a>Web页面请求的历程</h3> 
<ol><li>Bob便携机上的操作系统生成一个DHCP请求报文,并将这个报文放入具有日的地端口67(DHCP服务器)和源端口68(DHCP客户)的UDP报文段该UDP报文段则被放置在一个具有广播P目的地地址(25.255.255.255)和源IP地址0.0.0.0的P数据报中,因为Bob的便携机还不具有一个IP地址。</li><li>包含DHCP请求报文的P数据报则被放置在以太网帧中。该以太网帧具有目的MAC地址F:FF:F:F:F:F,使该帧将广播到与交换机连接的所有设备如果顺利的话也包括DHCP服务器);该帧的源MAC.地址是Bohb便携机的MAC地址<br> 00:16:D3:23:68:8A。</li><li>包含DHCP请求的广播以太网顿是第一个由Bob便携机发送到以太网交换机的帧。该交换机在所有的出端口广播入帧,包括连接到路由器的端口</li><li>路由器在它的具有MAC地址00:22:6B:45:1F的接口接收到该广播以太网帧,该帧中包含DHCP请求,并且从该以太网帧中抽取出IP数据报。该数据报的广播IP目的地址指示了这个IP数据报应当由在该结点的高层协议处理,因此该数据报的载荷(一个UDP报文段)被分解向上到达UDP,DHCP请求报文从此UDP报文段中抽取出来。此时DHCP服务器有了DHCP请求报文。</li><li>我们假设运行在路由器中的DHCP服务器能够以CIDR块68.85.2.0/24<br> 分配IP地址。所以本例中,在学校内使用的所有IP地址都在 Comcast的地址块中。我们假设DHCP服务器分配地址68.85.2.101给Bob的便携机。DHCP服务器生成包含这个IP地址以及DNS服务器的IP地址(68.87.71.226)、默认网关路由器的IP地址(68.85.2.1)和子网块(68.85.2.0/24)(等价为“网络掩码”)的一个 DHCP ACK报文。该DHCP报文被放入一个UDP报文段中,UDP报文段被放入一个IP数据报中,IP数据报再被放入一个以太网帧中。这个以太网帧的源MAC地址是路由器连到归属网络时接口的MAC地址(00:22:6B:45:1F:1B),目的MAC地址是Bob便携机的MAC地址(00:16:D3<br> 23:68:8A)。</li><li>包含 DHCP ACK的以太网帧由路由器发送给交换机。因为交换机是自学习的,并且先前从Bohb便携机收到(包含DHCP请求的)以太网帧,所以该交换机知道寻址到00:16:D3:23:68:8A的帧仅从通向Bob便携机的输出端口转发。</li><li>Bob便携机接收到包含 DHCP ACK的以太网帧,从该以太网帧中抽取P数据报,从IP数据报中抽取UDP报文段,从UDP报文段抽取 DHCP ACK报文。Bob的DHCP客户则记录下它的IP地址和它的DNS服务器的IP地址。它还在其IP转发表中安装默认网关的地址。Bob便携机将向该默认网关发送目的地址为其子网68.85.2.0/24以外的所有数据报。此时,Bob便携机已经初始化好它的网络组件,并准备开始处理Web网页获取。当Bob将www.google.com的URL键入其Weh测览器时,他开启了一长串事件,这将导致谷歌主页最终显示在其Web测览器上。Bob的Web测览器通过生成一个TCP套接字开始了该过程,套接字用于向ww.google.com发送HTTP请求。为了生成该套接字,Bob便携机将需要知道www.google,com的IP地址。使用DNS协议提供这种名字到IP地址的转换服务。</li><li>Bob便携机上的操作系统因此生成一个DNS查询报文,将字符串www.google.com放入DNS报文的问题段中。该DNS报文则放置在一个具有53号(DNS服务器)目的端口的UDP报文段中。该UDP报文段则被放入具有IP目的地址68.87.71.226(在第5步中 DHCP ACK返回的DNS服务器地址)和源IP地址68.85.2.101的P数据报中。</li><li>Bob便携机则将包含DNS请求报文的数据报放入一个以太网帧中。该帧将发送(在链路层寻址)到Bob学校网络中的网关路由器。然而,即使Boh便携机经过上述第5步中的 DHCP ACK报文知道了学校网关路由器的IP地址(68.85.2.1),但仍不知道该网关路由器的MAC地址。为了获得该网关路由器的MAC地址,Bob便携机将需要使用ARP协议。</li><li>Bob便携机生成一个具有目的IP地址68.85.2.1(默认网关)的ARP查询报文,将该ARP报文放置在一个具有广播目的地址(F:F:F:F:EF:F)的以太网帧中,并向交换机发送该以太网帧,交换机将该帧交付给所有连接的设备,包括网关路由器。</li><li>网关路由器在通往学校网络的接口上接收到包含该ARP查询报文的帧,发现在ARP报文中目标IP地址68.85.2,1匹配其接口的IP地址。网关路由器因此准备一个ARP回答,指示它的MAC地址00:22:6B:45:1F:1B对应IP地址68.85.2.1。它将ARP回答放在一个以太网帧中,其目的地址为00:16:D3:23:68:8A(Bob便携机),并向交换机发送该帧,再由交换机将帧交付给Bob便携机。</li><li>Bob便携机接收包含ARP回答报文的帧,并从ARP回答报文中抽取网关路由器的MAC地址(00:22:6B:45:1F:1B)。</li><li>Bob便携机现在能够使包含DNS查询的以太网帧寻址到网关路由器的MAC地址。注意到在该帧中的P数据报具有P目的地址68.87.71.226(DNS服务器),而该帧具有目的地址00:22:6B:45:1F:1B(网关路由器)。Bob便携机向交换机发送该帧,交换机将该帧交付给网关路由器。</li><li>网关路由器接收该帧并抽取包含DNS查询的P数据报。路由器查找该数据报的目的地址(68.87.71.226),并根据其转发表决定该数据报应当发送到路由器。IP数据报放置在链路层帧中,该链路适合将学校路由器连接到路由器,并且该帧经这条链路发送。</li><li>在 Comcast I网络中最左边的路由器接收到该帧,抽取IP数据报,检查该数据报的目的地址(68.87.71.226),并根据其转发表确定出接口,经过该接口朝着DNS服务器转发数据报,而转发表已根据 Comcast的域内协议(如RIP、OSPF或IS-IS,4.6节)以及因特网的域间协议BGP所填写。</li><li>最终包含DNS查询的P数据报到达了DNS服务器。DNS服务器抽取出DNS查询报文,在它的DNS数据库中查找名字ww. google. com,找到包含对应www. google. com的IP地址(64.23.169.105)的DNS源记录。这种缓存数据源于google.com的权威DNS服务器。该DNS服务器形成了一个包含这种主机名到IP地址映射的DNS回答报文,将该DNS回答报文放入UDP报文段中,该报文段放入寻址到Bob便携机(68.85.2.101)的IP数据报中。该数据报将通过网络反向转发到学校的路由器,并从这里经过以太网交换机到Bob便携机。</li><li>Bob便携机从DNS报文抽取出服务器www.googlecom的IP地址。最终,在大量工作后,Bob便携机此时准备接触www.google.com服务器!</li><li>既然Bob便携机有了www. google. com的IP地址,它能够生成TCP套接字,该套接字将用于向ww.google.com发送HTTPGET报文。当Bob生成<br> TCP套接字时,在Bob便携机中的TCP必须首先与www.google.com中的TCP执行三次握手。Bob便携机因此首先生成一个具有目的端口80(针对HTTP的)的 TCP SYN报文段,将该TCP报文段放置在具有目的P地64.233.169.105(<a href="http://www.google.com" rel="nofollow">www.google.com</a>)的IP数据报中,将该数据报放置在MAC地址为00:22:6B:45:1F:1B(网关路由器)的帧中,并向交换机发送该帧。</li><li>在学校网络、 Comcast网络和谷歌网络中的路由器朝着www.google. com转发包含TCP SYN的数据报,使用每台路由器中的转发表。支配分组经 Comeas和谷歌网络之间域间链路转发的路由器转发表项,是由BGP协议决定的。</li><li>最终,<a href="http://xn--TCPSYNwww-bz4o66e26ey68dnkcj4kv17e4v3e.googole.com" rel="nofollow">包含TCPSYN的数据报到达www.googole.com</a>。从数据报抽取出ICPSYN报文并分解到与端口80相联系的欢迎套接字。对于谷歌HTTP服务器和Bob便携机之间的TCP连接生成一个连接套接字。产生一个 ICP SYNACK报文段,将其放入向Bob便携机寻址的一个数据报中,最后放入链路层帧中,该链路适合将www.google.com连接到其第一跳路由器。</li><li>包含 TCP SYNACK报文段的数据报通过谷歌、 Comcast和学校网络,最终到达Bob便携机的以太网卡。数据报在操作系统中分解到步骤18生成的TCP套接字,从而进入连接状态。</li><li>借助于Bob便携机上的套接字,现在准备向ww. google. com发送字节了,Bob的测览器生成包含要获取的URL的HTTP GET报文。HTTP GET报文<br> 则写入套接字,其中GET报文成为一个TCP报文段的载荷。该TCP报文段放置进一个数据报中,并交付到www.google,com。</li><li>在ww.google.com的HTP服务器从TCP套接字读取HTTP GET报文,生成一个HTTP响应报文,将请求的Web页内容放人HTP响应体中,并将报文发送<br> 进TCP套接字中。</li><li>包含HTTP回答报文的数据报通过谷歌、Comcast和学校网络转发,到达Bob便携机。Bob的Web浏览器程序从套接字读取HTTP响应,从HTTP响应体中抽取Web网页的html,显示了Web网页。</li></ol> 
<h3><a id="_302"></a>小结</h3> 
<p>链路层的基本服务是将网络层的数据报从一个结点(主机、交换机、路由器,WiFi接人点)移动到一个相邻的结点。在通过链路向相邻结点传输之前<br> 所有链路层协议都是通过将网络层数据报封装在链路层帧中来操作的。然而,除了这个共同的成帧功能之外,不同的链路层协议提供截然不同的链路接入、交付和传输服务。造成这些差异的部分原因是链路层协议必须工作在很多种链路类型上。一个简单的点对点链路具有单个发送方和接收方,并通过单一“线路”通信。一个多路访问链路在许多发送方和接收方之间共享;因此,对多路访问信道的链路层协议有一个协调链路接入的协议(它的多路访问协议)。在MPIS的情况下,连接两个相邻结点的“链路”,其本身可能实际上就是一个网络。<br> 在链路层通信所依据的原理中,我们研究了差错检测和纠正技术、多路访问协议、链路层寻址、虚拟化(VLAN)以及扩展的交换局域网和数据中心网络的构造方法。今天对链路层的许多关注在于这些交换网络。在差错检测/纠正场景中,为了对帧通过链路传输时可能发生的比特翻转进行检测并在某些情况下进行纠正,在帧的首部增加附加比特的方法。简单的奇偶校验和检验和方案,以及更健壮的循环冗余检测。<br> 协调访问广播信道的3大类方法:信道划分方法(TDM、FDM)、随机接入方法( ALOHA协议和CSMA协议)和轮流方法(轮询和令牌传递)。电缆接入网,发现它使用了多种这些多路访问方法。让多个结点共享单个广播信道的结果,是需要在链路层提供结点地址。物理地址和网络层地址是非常不同的,而且在因特网场景中,一个专门的协议(ARP,即地址解析协议)用于在这两种寻址形式之间进行转换,并且详细学习了极为成功的以太网协议。然后研究了共享一个广播信道的结点是怎样形成一个局域网的,以及多个局域网怎样能够互联形成一个更大的局域网,即互联这些本地结点完全不需要网络层路由选择的干预。多个虚拟局域网是怎样能够产生一个单一的物理局域网体系结构的。<br> 通过关注当MPLS网络互联P路由器时是如何提供链路层服务的和展望今天用于大型数据中心的网络设计。<br> 通过识别在获取一个简单的Web网页时所需要的许多协议，联通了应用层，运输层、网络层、链路层。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c7403185e23b1f590458d2e6c964dcce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">javascript 生成器和promise总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/355af63b1f354b95996f7495f212781d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">oracle与mysql操作上的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>