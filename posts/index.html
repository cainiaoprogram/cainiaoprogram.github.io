<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df14b9d621f11a11a10c778b6cb07494/" rel="bookmark">
			基于JAVA的数据可视化的智慧河南大屏 开源项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块三、系统展示四、核心代码4.1 数据模块 A4.2 数据模块 B4.3 数据模块 C4.4 数据模块 D4.5 数据模块 E 五、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的数据可视化的智慧河南大屏，包含了GDP、人口、土地面积、企业数、人均收入数据排行、地图展示等模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，数据可视化的智慧河南大屏基于角色的访问控制，给数据管理员、普通用户使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 数据可视化大屏中央是河南省3D地形地图，标注一些具有代表性的信息，如河南省的历史背景，河南省土地面积，河南省的气候条件，河南省GDP总数占全国的比例，河南省人口数占全国人口数的比例，河南省的农业总产值占全国农业总产值的情况等将城市简介标注在地图上，将具有代表性的旅游景区标注在地图上，如：少林寺、龙门石窟、清明上河园、太行山大峡谷、殷墟博物馆、白马寺云台山、尧山等。将河南省代表性名人故里标注在地图上，如：岳飞、白居易、商鞅、杜甫、老子、张仲景、杨靖宇、刘禹锡、范蠡、李商隐等。两侧有重要城市的近一周的天气。两侧用柱状图呈现河南省各城市的GDP排名。两侧有柱状图呈现河南省各城市的人口数排名。两侧有饼状图呈现河南省地理地貌，如平原67%、盆地12%、山地15%等等两侧有折线图呈现河南省近几年GDP的变化趋势。 三、系统展示 四、核心代码 4.1 数据模块 A &lt;div class="plefttoday" style="margin-top: 10px"&gt; &lt;h2 class="tith2 white"&gt;关键指标总览&lt;/h2&gt; &lt;div class="lefttoday_tit" style="height: 8%"&gt;&lt;/div&gt; &lt;div class="lefttoday_number"&gt; &lt;div class="widget-inline-box text-center fl"&gt; &lt;p style="font-size: 22px"&gt;GDP&lt;/p&gt; &lt;h3 class="ceeb1fd" style="font-size: 28px"&gt;{{count1}}&lt;/h3&gt; &lt;/div&gt; &lt;div class="widget-inline-box text-center fl"&gt; &lt;p style="font-size: 22px"&gt;人口&lt;/p&gt; &lt;h3 class="c24c9ff" style="font-size: 28px"&gt;{{count2}}&lt;/h3&gt; &lt;/div&gt; &lt;div class="widget-inline-box text-center fl"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df14b9d621f11a11a10c778b6cb07494/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2abb081fc14aaadbb6af5fddc37b83/" rel="bookmark">
			如何在网页中嵌入3D模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在3D建模软件中设计的模型，经常需要嵌入到网页中展示给用户查看，可如何将模型嵌入到网页中呢？
可以使用NSDT 3Dconvert工具进行免费的3D模型网页内嵌。
模型文件上传 打开网站以后，因为我们只是为了获取内嵌代码，所以这里可以选择任意一种目标格式。
将3D模型文件上传，等待网站处理完成后，会出现【模型内嵌】功能入口。可以先点击【预览】，查看模型的在线展示效果。
获取内嵌代码 点击【模型内嵌】，出现内嵌设置页面。可以选择隐藏原始网站的顶部和底部工具类。设置完成后，生成最终的内嵌代码。
获取模型内嵌代码以后，将代码嵌入到网页中里就可以了，模型嵌入支持WEB网页、小程序和APP等。模型嵌入功能是免费的，无限访问次数。
模型内嵌示例代码：
&lt;iframe src="https://3dconvert.nsdt.cloud/conv/share?uid=frame-06f8bbea32-1705039166291&amp;hideTitle=1&amp;hideFooter=1" width="600" height="400" frameborder="0"&gt;&lt;/iframe&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07948f0e065c0cb49ec1e8e35a512272/" rel="bookmark">
			Edge扩展插件安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开 Edge 浏览器：首先，启动您的 Microsoft Edge 浏览器。打开扩展页面: 点击浏览器右上角的三个水平点（更多选项）。在弹出的菜单中选择“扩展”。 进入 Microsoft Edge 扩展商店： 在扩展页面底部，点击“获取更多扩展”以进入 Microsoft Edge 扩展商店。您也可以直接访问 Microsoft Edge Addons 网站。 选择并安装扩展： 浏览或搜索您想要的扩展。点击您选择的扩展，然后点击“获取”按钮进行安装。 管理已安装的扩展： 安装完扩展后，您可以在扩展页面管理它们，例如启用或禁用、删除或调整设置。 注意: 有些扩展可能需要特定的权限或设置来正常工作，因此在安装后请仔细阅读每个扩展的说明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a17f34c0223f41521bd4d03b2eccfe3d/" rel="bookmark">
			IC设计入门——异步FIFO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在异步FIFO中，数据读取和写入操作使用不同的时钟频率。由于写入和读取时钟不同步，因此称为异步FIFO。通常，这些用于数据需要从一个时钟域传递到另一个时钟域的系统中，这通常称为“时钟域交叉”。因此，异步FIFO有助于在两个工作于不同时钟的系统之间同步数据流。
异步FIFO框图 信号：
wr_en：写使能
wr_data：写入数据
full：FIFO 已满
empty：FIFO 为空
rd_en：读取启用
rd_data：读取数据
b_wptr：二进制写入指针
g_wptr：格雷码写入指针
b_wptr_next：二进制写入指针 下一页
g_wptr_next： 下一个格雷码写指针
b_rptr：二进制读取指针
g_rptr：格雷码读取指针
b_rptr_next： 下一个二进制读取指针
g_rptr_next：下一个格雷码读取指针
b_rptr_sync：二进制读取指针同步
b_wptr_sync：二进制写入指针同步
异步FIFO操作 在同步FIFO的情况下，写入和读取指针在同一时钟上生成。但是，在异步FIFO的情况下，写入指针与写入时钟域对齐，而读取指针与读取时钟域对齐。因此，它需要域交叉来计算FIFO的满条件和空条件。这会导致实际设计中的亚稳态。为了解决这种亚稳态问题，可以使用2个触发器或3个触发器同步器来传递写入和读取指针。为了解释，我们将使用 2 个触发器同步器。请注意，单个“两拍同步器”只能解析一位的亚稳态。因此，根据写入和读取指针的不同，需要多个 两拍 同步器。
module synchronizer #(parameter WIDTH=3) (input clk, rst_n, [WIDTH:0] d_in, output reg [WIDTH:0] d_out ); reg [WIDTH:0] q1; always@(posedge clk) begin if(!rst_n) begin q1 &lt;= 0; d_out &lt;= 0; end else begin q1 &lt;= d_in; d_out &lt;= q1; end end endmodule 在异步FIFO中使用二进制到格雷码转换器，反之亦然 到目前为止，我们讨论了如何在各自的时钟域中获取异步写入和读取指针。但是，我们不应该传递二进制格式的写入和读取指针值。由于亚稳态，整体写入或读取指针值可能不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a17f34c0223f41521bd4d03b2eccfe3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9daef8672a559c9547d3f85eeb9933fd/" rel="bookmark">
			如何使用SVN查看旧版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和目录
第一步：打开SVN客户端
第二步：浏览历史版本
第三步：还原历史版本
结论
Subversion (缩写为SVN)是一种常用的版本控制系统，它可以帮助团队协作开发软件项目。除了基本的版本控制功能外，SVN还提供了许多其他功能，其中一个重要的功能就是可以查看历史版本，以便更好地追踪代码变化和回滚错误修改。
在本文中，我将详细介绍如何使用SVN查看历史版本的方法。
第一步：打开SVN客户端 首先，你需要打开SVN客户端，例如TortoiseSVN或者命令行工具。如果你使用的是TortoiseSVN，可以右键单击你想要查看历史版本的文件或文件夹，并选择“Show log”选项来打开日志信息窗口。
第二步：浏览历史版本 在日志信息窗口中，你会看到该文件或文件夹的每个提交记录，每个记录都包含了提交者、提交时间、提交注释等信息。通过单击某个记录，你可以查看该版本的详细信息。如果你想比较该版本与当前版本之间的差异，可以双击按钮。如果你想查看完整的历史记录，可以点击“Show All”按钮。
双击这里
查看不同，这是29版和30版的对比，黄色部分是不同的地方。
这里可以快速找到不同
第三步：还原历史版本 如果你想还原历史版本，可以在日志信息窗口中&lt;右键&gt;选择该版本，然后单击“Revert to this revision”按钮。这将使你的工作副本恢复到所选版本，并将修改提交到服务器上。
注意："revert to this revision"与"revert changes from this revision"的区别 "revert to this revision" 意味着将内容回滚到指定的版本，并且丢弃所有在该版本之后所做的更改。也就是回到该版本，并且该版本后面的版本被删除。
"revert changes from this revision" 意味着只取消指定版本之后所做的更改，而不会回滚到该版本本身。也就是不恢复你的本地文件，并且该版本后面的版本被删除。
结论 使用Subversion查看历史版本非常简单，只需几个步骤就可以轻松完成。在团队协作中，经常需要查看历史版本以便更好地了解代码变化和进行错误修复。希望本文能够帮助你更好地使用SVN进行版本控制，提高团队协作效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08f7f15d994be36500c9851153e217c/" rel="bookmark">
			基于JAVA的民宿预定管理系统 开源项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 用例设计2.2 功能设计2.2.1 租客角色2.2.2 房主角色2.2.3 系统管理员角色 三、系统展示四、核心代码4.1 查询民宿4.2 新增民宿4.3 新增民宿评价4.4 查询留言4.5 新增民宿订单 五、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的民宿预定管理系统，包含了民宿档案模块、民宿订单模块、民宿评价模块、民宿留言模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，民宿预定管理系统基于角色的访问控制，给民宿管理员、旅客使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 2.1 用例设计 民宿预订管理系统，使用Spring Boot、Vue.js 框架进行开发，后台服务器使用了Tomcat，数据库使用MySQL。
该系统实现了登录注册、上传房源、预订民宿、我的留言、评价功能、订单生成等模块功能。
本系统分为以下三种用户类型。
租客：指那些在平台上注册的想要租民宿的消费者。
房主：指上传房源的当前民宿经营者。
系统管理员：指管理房源、用户与评论，帮助租客和房主解决问题的系统管理者。
2.2 功能设计 民宿预订管理系统本系统分为使用用户类型分为租客、房主、系统管理员三种，具体功能结构如下。
2.2.1 租客角色 注册、登录功能搜索功能：根据某些特定项模糊匹配民宿。预订功能：在线预订民宿房间。留言和评论功能：可以跟其他角色留言、评论民宿房间。订单功能：查看生成的订单详情，进行退订操作。 2.2.2 房主角色 注册、登录功能搜索功能：根据某些特定项模糊匹配民宿。民宿房源管理功能：修改房源状态与信息、上传房源照片、新增房源、搜索房源。留言和评论功能：可以跟其他角色留言、评论民宿房间。订单功能：可以查看生成的订单信息。 2.2.3 系统管理员角色 注册、登录功能搜索功能：根据某些特定项模糊匹配民宿。用户管理：按条件查询所有类型的用户，删除用户，修改自己的信息。房源管理：修改房源上下线状态。留言和评论管理：可以回复租客和房主的问题且可以删除评论。 三、系统展示 四、核心代码 4.1 查询民宿 @RequestMapping(value = "/getByPage", method = RequestMethod.GET) @ApiOperation(value = "查询民宿") public Result&lt;IPage&lt;Homestay&gt;&gt; getByPage(@ModelAttribute Homestay homestay ,@ModelAttribute PageVo page){ QueryWrapper&lt;Homestay&gt; qw = new QueryWrapper&lt;&gt;(); User currUser = securityUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f08f7f15d994be36500c9851153e217c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a73e75f12e9069786308d06795e1ec48/" rel="bookmark">
			stable diffusion代码学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文没有太多公式推理，只有一些简单的公式，以及公式和代码的对应关系。本文仅做个人学习笔记，如有理解错误的地方，请指出。 本文包含stable diffusion入门文献和不同版本的代码。 文献资源 本文学习的代码；相关文献： Denoising Diffusion Probabilistic Models : DDPM，这个是必看的，推推公式Denoising Diffusion Implicit Models ：DDIM，对 DDPM 的改进Pseudo Numerical Methods for Diffusion Models on Manifolds ：PNMD/PLMS，对 DDPM 的改进High-Resolution Image Synthesis with Latent Diffusion Models ：Latent-Diffusion，必看Neural Discrete Representation Learning ： VQVAE，简单翻了翻，示意图非常形象，很容易了解其做法 代码资源 stable diffusion v1.1-v1.4， https://github.com/CompVis/stable-diffusionstable diffusion v1.5，https://github.com/runwayml/stable-diffusionstable diffusion v2，https://github.com/Stability-AI/stablediffusionstable diffusion XL，https://github.com/Stability-AI/generative-models 前向过程（训练） 输入一张图片+随机噪声，训练unet，网络预测图片加上的噪声 反向过程（推理） 给个随机噪声，不断迭代去噪，输出一张图片 总体流程 输入的prompt经过clip encoder编码成(3+3,77,768)特征，正负prompt各3个，默认negative prompt为空‘’，解码时正的和负的latent图片用公式计算一下才是最终结果；time step通过linear层得到(3+3,1280)特征；把prompt和time ebedding和随机生成的图片放入unet，得到的就是我们要的图片。 采样流程 text2img 该函数在PLMSSampler中，输入x(噪声，(3,4,64,64))-----c（输入的prompt，(3,77,768)----t （输入的time step，第几次去噪(3,)。把这三个东西输入unet，得到预测的噪声e_t。 def p_sample_plms(self, x, c, t, index, repeat_noise=False, use_original_steps=False, quantize_denoised=False, temperature=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a73e75f12e9069786308d06795e1ec48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a19cb88b13e03c41e04861fa116a3632/" rel="bookmark">
			Vue3 中使用 Vuex 和 Pinia 对比之 Vuex的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于 Vue3 的 composition API 来展开 Vuex 和 Pinia 的用法比较
Pinia传送门
Vuex传送门
Vuex 状态管理的核心概念 状态- 驱动应用的数据源；视图 - 以声明方式将状态映射到视图；操作 - 响应在视图上的用户输入导致的状态变化 下面是源自Vuex 官网提供的，“单向数据流”的简单示意：
但是，我们的应用中遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：
多个视图依赖于同一个状态；来自不同的视图的行为需要变更同一个状态。 为了解决上述两个问题，Vuex 做了如下的优化，也是Vuex 的状态管理机制：
Vuex 把组件的共享状态抽取出来，以一个全局单例模式管理，在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在数的哪个位置，任何组件都能获取状态或者触发行为；Vuex 通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态之间的独立性。使我们的代码变得更结构化且更易维护。
Vuex 和单纯的全局对象的区别 Vuex 的核心就是 store（仓库），可以把它看成是一个容器，存储应用中大部分的状态（state），Vuex 和单纯的全局对象存在如下区别：
Vuex 的状态存储是响应式的。当Vue 组件从 store 中读取状态时，store 发生变化，那么相应的组件也会得到更新；你不能直接修改 store 中的状态，改变store 中的状态的唯一途径是调用 commit 触发 mutation，也就是说你的 Vue 组件中只写 commit ，不要直接调用 mutation 中的方法，这样的好处是可以方便的跟踪每一个状态的变化，有利于vuedevtool 调试 Vuex 的适用场景 适用于中大型的单页应用，如果你的应用足够简单，那么不建议使用 Vuex，一个简单的 store 模式就足够用了。
Vuex 的使用-最简单的实例 步骤一：安装 Vuex npm install vuex@next --save 或者使用 yarn: yarn add vuex@next --save 步骤二：创建一个 store 引用 Vuex 的官方demo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a19cb88b13e03c41e04861fa116a3632/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3241fea36929f84107227287009316d2/" rel="bookmark">
			每日 python 面试10题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python中的列表和元组有什么区别？
列表是可变的（Mutable），而元组是不可变的（Immutable）。列表使用方括号 [ ]，元组使用圆括号 ( )。列表支持各种操作，如增加、删除和修改元素，而元组是不可变的，不能修改。 解释Python中的深拷贝和浅拷贝。
浅拷贝创建一个新对象，但是内部的对象（例如列表）仍然是原始对象的引用。深拷贝创建一个完全独立的新对象，包括内部的对象。 Python中的装饰器是什么？
装饰器是Python的一种特殊的语法，用于修改函数或类的行为。它们允许在不修改原始代码的情况下添加功能。 什么是Pandas库？
Pandas是一个强大的数据分析库，提供了数据结构和数据分析工具，特别适用于处理和分析大型数据集。 Python中的GIL是什么？
GIL（全局解释器锁）是Python解释器中的一个机制，它确保任何时候只有一个线程在解释器中运行。这意味着Python的多线程程序并不能利用多核处理器的优势。 解释Python中的异常处理。
异常处理是一种处理程序在运行时出现错误的方法。使用try块来包裹可能引发异常的代码，然后使用except块来处理特定类型的异常。 Python中的生成器是什么？
生成器是一种特殊的迭代器，它允许逐个生成值，而不是一次性生成所有值。生成器可以通过函数中使用yield关键字来创建。 Python中的面向对象编程是什么？
面向对象编程（OOP）是一种程序设计范式，它使用类和对象来组织代码。类定义了对象的属性和方法，对象是类的实例。 Python中的模块和包有什么区别？
模块是一个包含Python代码的文件，包是包含模块的目录。包可以包含多个模块和子包。 Python中的虚拟环境是什么？
虚拟环境是一个独立于系统Python环境的Python解释器副本。它允许您在同一台机器上的不同项目中使用不同的包依赖，避免版本冲突问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3256a90a6806854d924b2a30d22d2d3/" rel="bookmark">
			使用Arduino的触摸传感器模块接口库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		触摸传感器模块接口库与I2C和Arduino兼容。它是一个基本函数库，可用于处理与传感器模块的通信。该库包含一个示例程序，可帮助学习。
0 Arduino的接口库 用于与 Neonode 触摸传感器模块光学触摸传感器通信的 Arduino 库。处理通过 I2C 通信的基本 BER 编码 ASN.1 消息。
1 使用案例 如果您想轻松地开始使用原型，了解如何使用I2C与传感器模块通信，或者如果您想了解该库是如何实现通信的，则此库非常有用
2 简介 该库提供了一种与触摸传感器模块进行通信的简单方式，以及ASN.1串行消息的一些原始解析。这使得最终用户可以轻松地从触摸通知中获取x和y坐标，或者设置不同的设置，例如正确的触摸活动区域。该库不支持ASN.1协议中的所有可用消息，但是I2C读写功能是公共的，如果需要从传感器模块发送/读取库不支持的任何设置或请求，则可以使用该功能。
3 开源 这个库是在GNU LGPL v2.1开源许可证下分发的，可以在GitHub上获得，还有其他文档和完整的示例程序。
4 如何使用库 主循环
该库是围绕使用 zforce.GetMessage() 作为从传感器读取消息的主要方法而构建的。 GetMessage() 方法检查数据就绪引脚是否为高电平，如果是，则从传感器读取等待消息。然后解析接收到的消息并返回指向消息的指针。
成功调用 GetMessage() 将为新消息动态分配内存。当不再需要消息信息时，最终用户可以通过调用 zforce.DestroyMessage() 来销毁消息。请检查提供的示例代码以获取使用示例。
Message* Zforce::GetMessage() { Message* msg = nullptr; if(GetDataReady() == HIGH) { if(!Read(buffer)) { msg = VirtualParse(buffer); ClearBuffer(buffer); } } return msg; } 发送和读取消息
该库支持在传感器中设置一些基本配置参数，例如zforce。SetTouchActiveArea（）。当向传感器写入任何消息时，最终用户必须在写入之前确保数据就绪信号为LOW（低）（即，必须没有等待从传感器读取的消息）。如果数据就绪信号为HIGH，则需要调用GetMessage（）方法，直到接收到nullptr作为响应，这表明传感器中不再有消息等待。
发送消息后，传感器始终会创建一个必须由主机读取的响应。传感器可能需要一些时间才能创建响应并将其放入 I2C 缓冲区，因此建议在发送请求后在 do-while 循环中调用 GetMessage() 方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3256a90a6806854d924b2a30d22d2d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4b4dad1c4d86703001f69a42e0795f/" rel="bookmark">
			信息系统中的需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件需求是指用户对新系统在功能、行为、性能、设计约束等方面的期望。根据IEEE的软件工程标准词汇表，软件需求是指用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明。
目录
1、需求的层次 2、需求过程 2.1 需求获取 2.2 需求分析
2.3 需求规格说明书编制
2.4 需求验证与确认
3、UML
1) UML中的事物
2) UML中的关系
3) UML 2.0中包括14种图
4) UML视图
1、需求的层次 简单地说，软件需求就是系统必须完成的事以及必须具备的品质。需求是多层次的，包括业务需求、用户需求和系统需求，这三个不同层次从目标到具体，从整体到局部，从概念到细节。
质量功能部署(Quality Function Deployment，QFD)是一种将用户要求转化成软件需求的技术，其目的是最大限度地提升软件工程过程中用户的满意度。为了达到这个目标，OFD 将软件需求分为三类，分别是常规需求、期望需求和意外需求。 2、需求过程 需求过程主要包括需求获取、需求分析、需求规格说明书编制、需求验证与确认等。
2.1 需求获取 需求获取是一个确定和理解不同的项目干系人的需求和约束的过程。需求获取是一件看上去很简单，做起来却很难的事情。需求获取是否科学、准备充分，对获取出来的结果影响很大，这是因为大部分用户无法完整地描述需求，而且也不可能看到系统的全貌（真实，深有同感😶）。因此，需求获取只有与用户的有效合作才能成功。常见的需求获取方法包括用户访谈、问卷调查、采样、情节串联板、联合需求计划等。 2.2 需求分析 在需求获取阶段获得的需求是杂乱的，是用户对新系统的期望和要求，这些要求有重复的地方，也有矛盾的地方，这样的要求是不能作为软件设计基础的。
一个好的需求应该具有无二义性、完整性、一致性、可测试性、确定性、可跟踪性、正确性、必要性等特性，因此，需要分析人员把杂乱无章的用户要求和期望转化为用户需求，这就是需求分析的工作。
需求分析对已经获取到的需求进行提炼、分析和审查，以确保所有的项目于系人都明白其含义并找出其中的错误、遗漏或其他不足的地方。需求分析的关键在于对问题域的研究与理解。 为了便于理解问题域，现代软件工程方法所推荐的做法是对问题域进行抽象，将其分解为若干个基本元素，然后对元素之间的关系进行建模。
使用结构化分析(Structured Analysis，SA)方法进行需求分析，其建立的模型的核心是数据字典。围绕这个核心，有三个层次的模型，分别是数据模型、功能模型和行为模型(也称为状态模型)。在实际工作中，一般使用实体关系图 (E-R 图)表示数据模型，用数据流图 (DataFlow Diagram，DFD)表示功能模型，用状态转换图(State Transform Diagram，STD)表示行为模型。E-R 图主要描述实体、属性，以及实体之间的关系；DFD 从数据传递和加工的角度，利用图形符号通过逐层细分描述系统内各个部件的功能和数据在它们之间传递的情况，来说明系统所完成的功能；STD 通过描述系统的状态和引起系统状态转换的事件，来表示系统的行为,指出作为特定事件的结果将执行哪些动作(例如，处理数据等)。
面向对象的分析(Object-Oriented Analysis，OOA)的基本任务是运用面向对象的(ObjectOriented，OO)方法，对问题域进行分析和理解，正确认识其中的事物及它们之间的关系，找出描述问题域和系统功能所需的类和对象，定义它们的属性和职责，以及它们之间所形成的各种联系。最终产生一个符合用户需求，并能直接反映问题域和系统功能的 OOA 模型及其详细说明。OOA模型包括用例模型和分析模型，用例是一种描述系统需求的方法，使用用例的方法来描述系统需求的过程就是用例建模:分析模型描述系统的基本逻辑结构，展示对象和类如何组成系统(静态模型)，以及它们如何保持通信，实现系统行为(动态模型)。 2.3 需求规格说明书编制 软件需求规格说明书(Software Requirement Specification，SRS)是需求开发活动的产物,编制该文档的目的是使项目干系人与开发团队对系统的初始规定有一个共同的理解，使之成为整个开发工作的基础。SRS 是软件开发过程中最重要的文档之一，对于任何规模和性质的软件项目都不应该缺少。
在国家标准GB/T 8567《计算机软件文档编制规范》中，提供了一个SRS的文档模板和编写指南，其中规定SRS 应该包括范围、引用文件、需求、合格性规定、需求可追踪性、尚未解决的问题、注解和附录。
另外，国家标准GB/T9385《计算机软件需求说明编制指南》也给出了一个详细的SRS写作大纲，由于该标准年代久远，一些情况已经与现实不符，可以考虑作为SRS 写作的参考之用。 2.4 需求验证与确认 资深软件工程师都知道，当以SRS 为基础进行后续开发工作，如果在开发后期或在交付系统之后才发现需求存在问题，这时修补需求错误就需要做大量的工作。相对而言，在系统分析阶段，检测SRS 中的错误所采取的任何措施都将节省相当多的时间和资金。因此，有必要对于SRS的正确性进行验证，以确保需求符合良好特征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e4b4dad1c4d86703001f69a42e0795f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7989149e2c56fe356b492b0ced77d2/" rel="bookmark">
			zForce SDK的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、根据具体的操作系统参考以下SDK指导手册 Windows
Linux
1、下载zForce SDK zForce SDK 2.8.0
2、准备系统以安装和运行SDK程序 安装Visual Studio 2017及以上版本并选择用于构建C程序（而不仅仅是C++）的选项。
将zForceSDK-x.x.x.zip提取到任何文件夹
3、构建并运行示例程序 该示例程序包含在 SDK 中的原因有两个，一是允许您开始与触摸传感器模块进行通信，二是作为创建自己的应用程序的起点。
4、构建程序 ①打开解决方案文件 zForceSDK-Example.sln，执行以下任一操作：
a. 打开Visual Studio 2017 。
b. 从文件资源管理器打开它。
②确保配置设置为“x64”。
③选择构建类型：Release或Debug
④在菜单中选择生成（build） » 构建解决方案（ Build Solution）。
结果：创建了 zForceSDK 目录。
5、第一次运行程序 ①将手势条通过USB与PC机进行连接
②从文件资源管理器中，打开文件夹 zForceSDK\Windows\x86-64。
③复制 zForce.dll。
④打开文件夹 zForceSDK\x64 将 zForce.dll 粘贴到子文件夹 Release 或子文件夹 Debug 中（根据所选配置，两者都会出现）
⑤ 选择“调试（Debug ）”»“开始调试（Start Debugging）”，或“调试”（Debug ）»“开始调试（不执行）（Start without Debugging）”
运行结果如下：
运行结果分析如下：
根据运行结果分析如下： 1. 首先，创建了一个连接并成功连接到设备。 2. 发现了2个设备，其中一个设备名称为"Air"。 3. 接收到了一个消息，消息序列号为1，消息类型为OperationModesMessageType，表示接收到了操作模式消息。 - 操作模式报告显示检测模式打开，信号模式关闭，LED亮度模式关闭，检测HID模式关闭。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac7989149e2c56fe356b492b0ced77d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e33091b028574e58b33df8207f2e0df8/" rel="bookmark">
			软件系统培训方案（Word）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 培训概述
2. 培训目的
3. 培训对象及要求
3.1. 培训对象
3.2. 培训人员基本要求
4. 培训方式
5. 培训内容
6. 培训讲师
7. 培训教材
8. 培训质量保证
8.1. 用户培训确认报告
8.2. 培训疑问解答
软件开发全文档下载：软件项目开发全套文档下载_软件项目文档-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e5bae2903a7a4ec062dabfaca2941ed/" rel="bookmark">
			2023 年最值得推荐的11个视频转换器（免费和付费）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拥有一个视频转换器供您使用意味着您可以轻松地在任何设备上播放所有视频。我们展示了适用于 Windows 的最佳视频转换器，这样您就不必浪费时间使用不合格的工具。
录制、编辑和分享视频是人生最大的消遣之一。有如此多的设备能够捕捉视频——而且共享它们的途径也很丰富——发现视频文件与您使用的其他设备或平台不兼容可能会令人沮丧。因此，您可能正在寻找转换视频的方法。
在本指南中，我们确定了适用于 Windows 10 和 Windows 11 PC 的最佳视频转换器。这些程序可让您通过将大量视频文件转换为替代视频格式来克服兼容性问题。这对于观看、编辑、传输和存储视频以及共享甚至出售视频非常有用。
使用我们的摘要了解每个视频转换器的优势，并找出最适合您特定需求的视频转换器。
适用于 Windows 的最佳视频转换器 这是我们的 Windows 最佳视频转换器列表：
1.奇客视频/音频转换 奇客视频/音频转换是我们挑选的最佳 Windows 视频转换器。这是一款付费软件，但您可以免费试用，看看是否合适。付费服务的好处之一是您不必担心侵入性广告或烦人的追加销售。输出视频质量出色，通过 GPU 硬件加速功能可实现快速转换速度。
奇客视频转换器—专业高效的视频转换器专业高效的视频转换器（支持转换MP3、MP4、aac、flac、amr、wma等1000+格式）https://www.geekersoft.cn/video-converter.html试用版为您提供完整软件的所有功能，包括录制功能，但它会将您可以转换的视频长度限制为五分钟。这与许多其他付费视频转换器的试用形成对比，后者在转换速度或某些工具的可用性等其他方面限制您。如果您决定购买完整版，一旦付款，您将获得一个许可证代码，可以减轻时间限制。
奇客视频/音频转换界面非常易于浏览，转换格式分为多种类型。选择一个工具并单击相应的齿轮图标将拉出一个单独的屏幕供您使用该工具。它也非常适合初学者尝试。
奇客视频/音频转换支持 70 多种格式，包括 AVI、MOV、MKV、MP3 和 MP4。它有大量直观分类的预配置配置文件。4K 转换对奇客视频/音频转换来说没有问题，它甚至支持 8K 分辨率。
2. Geekersoft免费视频转换 Geekersoft免费视频转换主要设计为下载器， 但它也可用作视频转换器。如果您要从特定平台下载视频并需要转换它们以便在您想要的设备上播放，这将特别方便。
该转换器可以处理大量格式，包括 MKV、WMV、MP4、MOV 和 AVI。它还充当视频到音频转换器，并为此功能提供多个预设。它支持高达 4K 分辨率。Geekersoft免费视频转换的免费版本允许您转换视频。
奇客（Geekersoft）免费在线视频转换奇客（Geekersoft）免费在线视频转换允许您将视频转换为流行的视频和音频格式，如MP4、WMV、MOV、MKV、MP3等。https://zh.geekersoft.com/free-video-converter-online.html其他功能包括用于创建您自己的视频文件的屏幕录像机和允许回放和预览的内置播放器。这个客户端没有包含的项目是一套编辑工具，一些用户可能会错过。
3.万兴优转 Wondershare Video Converter Ultimate（以前称为 Wondershare Video Converter Ultimate）是适用于 Windows 的最佳视频转换器之一。它绝对不是最便宜的软件，但如果您正在寻找质量和速度，那么它可能是一个不错的选择。由于它是一款付费软件，因此无需处理广告或追加销售。
Wondershare 提供免费试用，但有很多限制。您只能转换整个视频长度的三分之一，速度比付费版本慢，不能刻录到光盘，下载和录制视频受到严格限制。
但是，一旦付款，您就可以无限制地进行高速转换，并且可以无限制地使用屏幕录像机、下载器和光盘刻录机。
Wondershare UniConverter 非常易于使用，但在直接视频转换之外还有很多其他选项，例如一些高级编辑工具。因此，它是初学者和更高级用户的理想选择。还有六个附加功能，包括水印编辑器、智能修剪器和字幕编辑器，但这些功能每月额外收费 5.99 美元。
该软件可以处理 35 种视频格式，包括 MKV、MP4、MOV、MP3 和 MPEG。预先配置了 150 多个设备配置文件，如果您不确定需要什么格式，这非常有用。Wondershare 可以毫无问题地处理 4K 视频转换。该软件也适用于 MacOS。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e5bae2903a7a4ec062dabfaca2941ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495f20a62939a9d7c076eb8951bbb586/" rel="bookmark">
			SQL-修改表操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉欢迎您来到我的MySQL基础复习专栏
☆* o(≧▽≦)o *☆哈喽~我是小小恶斯法克🍹
✨博客主页：小小恶斯法克的博客
🎈该系列文章专栏：重拾MySQL
🍹文章作者技术和水平很有限，如果文中出现错误，希望大家能指正🙏
📜 感谢大家的关注！ ❤️
目录
DDL-表操作-修改
添加字段 （方括号内容可选）
修改字段
修改指定字段的数据类型 修改字段名和字段类型
删除字段
修改表名
删除表
删除指定表，并重新创建该表
总结
DDL-表操作-修改 添加字段 （方括号内容可选）
ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ]; 案例：为emp表增加一个新的字段”昵称”为blogname，类型为varchar(20)
ALTER TABLE emp ADD blogname varchar(20) COMMENT ' 小小恶斯法克 '; 修改字段 修改指定字段的数据类型 ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度); 修改字段名和字段类型
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ]; 案例:将emp表的blogname字段修改为username，类型为varchar(30)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495f20a62939a9d7c076eb8951bbb586/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498f6acf7ec1250f5d1c5ccbf5f7ae14/" rel="bookmark">
			10种免费恢复删除Word文档文件的方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为作家、博主、学生或任何使用计算机的人，都可能不小心删除对您很重要的 Word 文档文件。这可能是一次令人沮丧和压力重重的经历，并且会让您想知道自己是否永远失去了工作。如果您丢失了 Word 文档文件，请不要紧张，因为有许多免费方法可以恢复已删除的 Word 文档文件。在本文中，我们将介绍10 种免费的方法来恢复已删除的 Word 文档文件。
10种免费恢复删除Word文档文件的方法 在我们深入研究之前，请务必注意恢复已删除的 Word 文档文件的机会取决于许多因素。这些包括文件被删除后的时间长度、文件被删除后计算机上的活动量、保存文件的存储设备以及文件碎片化的程度。话虽如此，让我们看看恢复已删除 Word 文档文件的 10 种免费方法。
方法1：检查回收站 如果您不小心删除了 Word 文档文件，首先要查看的是回收站。回收站是 Windows 用来存储已从您的计算机中删除的文件的保留文件夹。要检查回收站，请双击桌面上的回收站图标。找到要恢复的已删除 Word 文档文件，右键单击它，然后选择“恢复”。该文件将恢复到其原始位置。
方法 2：使用数据恢复程序 如果上述方法不起作用，通常可以使用数据恢复程序恢复已删除的 Word 文档文件。许多数据恢复程序可以找到已删除的文件并恢复它们，即使它们已从回收站中删除或回收站已被清空。一些流行的数据恢复程序包括 奇客数据恢复 。需要注意的是，这些程序很有效，奇客数据恢甚至可以恢复已被覆盖或碎片化的文件。
奇客数据恢复: 支持1000+数据格式恢复免费下载软件扫描数据，支持文件、照片、视频、邮件、音频等1000+种文件的格式恢复更有电脑/笔记本、回收站、U盘、硬盘等各类存储设备数据丢失恢复https://www.geekersoft.cn/geekersoft-data-recovery.html
方法 3：使用 Windows 文件历史记录 如果回收站没有您要查找的文件，您可以尝试使用 Windows 文件历史记录。此功能在 Windows 8 中引入，并存在于所有后续版本中。它允许您通过查看每小时创建的文件系统快照来恢复已删除的文件。快照存储在外部硬盘驱动器或网络位置上。要使用 Windows 文件历史记录，请转到控制面板，然后是系统和安全，然后是文件历史记录。从那里，您可以选择“恢复个人文件”并搜索要恢复的已删除 Word 文档文件。
方法4：检查并恢复未保存的Word文档 恢复已删除的 Word 文档文件的另一种方法是查找未保存的文件。如果您正在处理文档并且计算机崩溃或 Word 意外关闭，则可能会发生这种情况。Word 有一个称为自动恢复的功能，它每隔几分钟自动保存文档的临时副本。如果 Word 崩溃或您的计算机意外关闭，您可以使用自动恢复来恢复未保存的文档。要查找和恢复未保存的 Word 文档，请转到 Word 并选择“文件”。然后，选择“信息”并单击“管理版本”。从那里，选择“恢复未保存的文档”。查找要恢复的已删除 Word 文档文件，然后选择“打开”。
方法 5：从备份中恢复 如果您定期备份计算机，则可以使用备份来恢复已删除的 Word 文档文件。备份可以存储在外部硬盘、云服务或网络位置。要从备份中恢复，请找到包含要恢复的已删除 Word 文档文件的文件夹，然后按照所选备份方法的说明进行操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/498f6acf7ec1250f5d1c5ccbf5f7ae14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ad60f2b144d3c232786dfa1c78198f/" rel="bookmark">
			SQL-DCL-如何用户管理，如何给用户权限？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉欢迎您来到我的MySQL基础复习专栏
☆* o(≧▽≦)o *☆哈喽~我是小小恶斯法克🍹
✨博客主页：小小恶斯法克的博客
🎈该系列文章专栏：重拾MySQL
🍹文章作者技术和水平很有限，如果文中出现错误，希望大家能指正🙏
📜 感谢大家的关注！ ❤️
目录
DCL-介绍
DCL-管理用户
DCL - 权限控制
DCL-介绍 DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。
DCL-管理用户 1.查询用户
在mysql数据库中，用户的信息，用户所具有的权限的信息，都是存放在系统数据库mysql的user表中，所以我们可以直接访问mysql数据库，然后查询use表就行
打开表之后有4个用户，前三个没有用过，我们只用过一个root，在这张表中，第一个字段叫host，指的是主机，在mysql中要创建一个用户或者去删除一个用户，需要通过用户名，和host主机地址同时定位，用户名和主机地址才能够完整的定位一个mysql的用户，这个主机地址指的是当前这个用户只能在哪个主机上访问当前mysql服务器，那么localhost代表只能够在本机访问，能不能远程访问呢？不能
use mysql ; select * from user ; select * from mysql.user ; --这里为什么是mysql.user,你要么用上面的组合，要么用下面的语句才能访问到user，因为user表是在mysql这个数据库中的，你要先切换到那个数据库中，或者用这个语句 执行如下：
2.创建用户
主机名指的就是在哪一个主机上，这个用户可以访问当前mysql，后面identified指定密码，就是当前用户的访问密码
CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 3.修改用户密码
ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码' ; 4.删除用户
DROP USER '用户名'@'主机名' ; 注意事项:
1.在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。
2.主机名可以使用 % 通配。
3.这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库管理员）使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06ad60f2b144d3c232786dfa1c78198f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307ddbbfc53490b128924c630b0fc2a5/" rel="bookmark">
			扩散模型的机器学习应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://medium.com/@jmkernes
来源：从 StableDiffusion 生成……。 一、说明 这篇文章旨在帮助您推导和理解扩散模型。如果您读完本文后的第一个想法是：“为什么我没有想到这个？！？” 那么酷，我成功了。我们不会重建 StableDiffusion，但我们将在最后构建一些玩具模型来演示一切是如何工作的。
除了这篇文章之外，我还创建了一个配套的Github 存储库来收集与扩散相关的所有内容。在某些时候，我将参考该存储库以获取更多详细信息。截至 2022 年底，您需要检查两件事：
在玩具数据集上从头开始实现扩散模型的简单代码（请参阅DDPM类和此玩具脚本）。完整的教程，包括数学。填补了这篇文章所掩盖的任何空白，并且还有一些有趣的物理知识。如果您觉得这篇文章有趣，我建议您阅读笔记！ 二、强制性非技术介绍 我不会撒谎。我出于尴尬而开始写这篇文章。
上辈子我曾在统计物理学领域工作，感觉就像是这样，这几乎可以用这样的想法来概括：“是的，一个粒子很酷，但你知道什么更酷吗？其中 10²³。” 统计物理学是一个广阔的领域，但毫不夸张地说，非平衡物理学的研究在其中占有突出的地位。非平衡物理学是现代物理学中令人兴奋的领域之一，我们仍然没有真正理解它，但仍然包含大量有意义的发现的机会。
然而，如果你让我准确描述什么是非平衡物理，老实说我无法告诉你。如果你随机选择任何物理问题并问我“这是非平衡吗？” 我可能会回答：“不，这是帕特里克……”然后，继续以尴尬的沉默坐着，决定是笑还是畏缩。但是，有一种现象我可以说确实属于非平衡物理，因此应该属于我的“专业”领域：扩散。
如果您完全跟上 2022 年的 ML 流行文化，那么“扩散”这个词应该会引起您的生成式 AI 流行语警报 ⏰。当我第一次注意到人们开始随意地讨论非平衡物理术语时，我感到胃部一阵剧痛。我的思绪充斥着漫长的夜晚，艰难地研读范·坎彭的《物理和化学中的随机过程》。但是，如果有一个足够强大的动力来克服数学引起的恶心，那就是尴尬。由于担心有人会问我扩散模型是如何工作的，我开始尽快研究它们。这篇文章并不是关于我试图自我证明我的教育的合理性，也不是抱怨我慢慢地（哈哈，好吧，很快）忘记了我在研究生院学到的一切。不，这是关于分享我来之不易的一些关于扩散模型如何在基础层面上运作的知识。值得庆幸的是，事实证明这些东西非常酷！
三、什么和为什么 3.1 什么是扩散模型？ 旨在有效地从分布 p(x) 中抽取样本的模型。生成模型。他们学习一些数据的概率分布 p(x)。自然不受监督（与整个生成部分齐头并进），尽管您可以调节它们或学习监督目标。实际上不是模型。扩散模型松散地指的是调度程序、先验分布和转换内核（通常由神经网络参数化）的集合。组合起来，这些部分可以从 p(x) 生成样本。 3.2 为什么扩散模型很酷？ 扩散模型并不是人们发明的第一个生成模型，公平地说我们为什么特别关心这些模型。为了说明原因，让我们回顾一下历史。
您可能会自然而然地想到，在深度学习时代学习概率分布 P(x) 是微不足道的：加载您最喜欢的神经网络，创建参数化函数 E_𝝑(x) 并通过最小化 |P(x) 来学习值 𝝑 ) — E_(x)|。然而，这行不通。原因在于常态化。P(x) 不是我们想要学习的任意函数。它必须遵守 ∫ P(x) dx = 1 的约束，这意味着如果我们想要学习一个无约束函数 E_(x)，我们实际上需要优化 |P(x) — E_(x) / ∫ E_𝝑(x) ) dx|，现在由于集成而完全搞砸了。归一化常数 Z(𝝑) = ∫ E_𝝑(x) dx，也称为配分函数，通常用大写字母 Z 表示。遵循学习无约束函数 E_𝝑(x) 的方法的模型称为基于能量的模型（EBM）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/307ddbbfc53490b128924c630b0fc2a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d2671cad5e9e41b21c72a459ef27afe/" rel="bookmark">
			多路转接技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注博主 Mindtechnist 或加入【智能科技社区】一起学习和分享Linux、C、C++、Python、Matlab，机器人运动控制、多机器人协作，智能优化算法，滤波估计、多传感器信息融合，机器学习，人工智能等相关领域的知识和技术。关注公粽号 《机器和智能》 回复关键词 “python项目实战” 即可获取美哆商城视频资源！
博主介绍：
CSDN博客专家，CSDN优质创作者，CSDN实力新星，CSDN内容合伙人；
阿里云社区专家博主；
华为云社区云享专家；
51CTO社区入驻博主，掘金社区入驻博主，支付宝社区入驻博主，博客园博主。
IO多路转接技术 —— select详解 1. 什么是IO多路转接2. IO多路转接技术——select详解（1）select()函数详解（2）文件描述符操作函数（3）使用select函的优缺点（4）select工作过程分析（5）select多路转接代码实现 图书推荐 -《精通嵌入式Linux编程》 专栏：《Linux从小白到大神》《网络编程》
1. 什么是IO多路转接 IO操作方式有两种
阻塞等待
优点：不占用CPU时间片
缺点：同一时刻只能处理一个操作，效率低下
非阻塞(忙轮询)
优点是提高了程序的执行效率，缺点是需要占用更多的CPU和系统资源
只有一个任务时
多个任务
对于非阻塞方式多任务的场景，也就是上图中的情况，解决方法是使用IO多路转接技术，常用的IO多路转接技术包括select/poll/epoll。
select/poll —— 实现方式为线性表遍历
在通信的时候，委托内核去检测连接到server的client，有哪些client是在通信的，比如说有10个client连接，但是只有6个发送了数据，要把这6个client找出来，这个工作由内核去做。但是内核只能给出发送数据的client的个数6，至于是哪6个client，需要进程自己去遍历。 在这两种方式下，可以这么理解，select 代收员比较懒， 她只会告诉你有几个快递到了，但是具体是哪个快递，你需要挨个遍历一遍。实际上，多路转接就是进程委托内核去做一些事情，在进程中只要调用select/poll/epoll就可以了，这样就实现了多任务的处理。 epoll —— 通过红黑树实现
epoll代收快递员很勤快，她不仅会告诉你有几个快递到了，还会告诉你是哪个快递公司的快递。 通过上面介绍已经大体了解了多路转接是什么，那么多路转接技术是怎么工作的呢？
先构造一张有关文件描述符的列表，将要监听的文件描述符添加到该表中。（类似于阻塞信号集）
然后调用一个函数，监听该表中的文件描述符，直到这些描述符表中的一个进行I/O操作时，该函数才返回。（select/poll/epoll）
该函数为阻塞函数函数对文件描述符的检测操作是由内核完成的 在返回时，它告诉进程有多少(哪些)描述符要进行I/O操作。
文件描述符对应的是内核缓冲区，监听文件描述符，实际上就是监听内核缓冲区的read区，因为read区有数据就说明有进程给我发送数据。select/poll会返回发生IO操作的进程个数；epoll返回发生IO操作的进程个数，以及是哪些进程。 2. IO多路转接技术——select详解 （1）select()函数详解 函数原型
int select( int nfds, fd_set *readfds, /*传入传出参数 | 传入传出参数：传入函数之前，指针指向的内存就已经有值了，函数执行完毕后，这个内存的值可能发生变化，并通过指针传递出来。*/ fd_set *writefds, fd_set *exceptfds, struct timeval *timeout ); 函数参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d2671cad5e9e41b21c72a459ef27afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5be8481826532942e21383bfb8493d3/" rel="bookmark">
			将Github Copilot转换为免费使用GPT-4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型参数支持 GPT-4 和 GPT-3.5-turbo ，实测使用其他模型均会以默认的 3.5 处理（对比 OpenAI API 的返回结果，猜测应该是最早的版本 GPT-4-0314 和 GPT-3.5-turbo-0301 ）
获取 Copilot Token
首先，你的账号需要开通 Github Copilot 服务
获取 Github Copilot Plugin Token 的方式目前有两种方式：
通过安装 Github Copilot CLI 授权获取（推荐）。通过第三方接口授权获取，不推荐，因为不安全。 如何使用
安装并启动 copilot-gpt4-service 服务，如本地启动后，API默认地址为：http://127.0.0.1:8080;获取你的 GitHub 账号 Github Copilot Plugin Token（详见下文）；安装第三方客户端，如：ChatGPT-Next-Web，在设置中填入 copilot-gpt4-service 的 API 地址和 Github Copilot Plugin Token，即可使用 GPT-4 模型进行对话。 最佳实践方式
经社区验证和讨论，最佳实践方式为:
本地部署，仅个人使用（推荐）；自用服务器集成 ChatGPT-Next-Web 部署, 服务不公开；服务器部署, 公开但个人使用 (例如多客户端使用场景 Chatbox, OpenCat APP, ChatX APP)。 不建议方式
以公共服务的方式提供接口多个 Token 在同一个 IP 地址进行请求, 容易被判定为异常行为同客户端 Web(例如 ChatGPT-Next-Web) 以默认 API 以及 API Key 的方式提供公共服务同一个 Token 请求频率过高, 容易被判定为异常行为Serverless 类型的提供商进行部署服务生命周期短, 更换 IP 地址频繁, 容易被判定为异常行为其他滥用行为或牟利等行为。 客户端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5be8481826532942e21383bfb8493d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66dc24e4507bbac494e60bbba10d2f6f/" rel="bookmark">
			YOLOv8改进 | 检测头篇 | 利用DySnakeConv改进检测头专用于分割的检测头（全网独家首发，Seg）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、本文改进 本文给大家带来的改进机制是一种我进行优化的专用于分割的检测头，在分割的过程中，最困难的无非就是边缘的检测，动态蛇形卷积（Dynamic Snake Convolution）通过自适应地聚焦于细长和迂回的局部结构，准确地捕捉管状结构的特征。这种卷积方法的核心思想是，通过动态形状的卷积核来增强感知能力，针对管状结构的特征提取进行优化，所以将这个卷积针对于YOLOv8的分割头进行融合是非常合适的，当然本文的检测头也支持用于目标检测，但是我将其设计出来是主要为了分割的读者使用的。
欢迎大家订阅我的专栏一起学习YOLO！ 专栏回顾：YOLOv8改进系列专栏——本专栏持续复习各种顶会内容——科研必备 目录
一、本文改进
二、DySnakeConv的框架原理
三、DySnakerConv的核心代码 四、分割检测头修改教程 4.1 修改一
4.2 修改二 4.3 修改三 4.4 修改四 4.5 修改五
4.6 修改六 4.7 修改七 4.8 修改八 4.9 修改九 4.10 修改10 五、 分割和目标检测的yaml文件
5.1 分割的yaml文件
5.2 目标检测的yaml文件 六、本文总结
二、DySnakeConv的框架原理 论文代码地址：动态蛇形卷积官方代码下载地址
论文地址：【免费】动态蛇形卷积(DynamicSnakeConvolution)资源-CSDN文库
背景-&gt;动态蛇形卷积(Dynamic Snake Convolution)来源于临床医学，清晰勾画血管是计算流体力学研究的关键前提，并能协助放射科医师进行诊断和定位病变。在遥感应用中，完整的道路分割为路径规划提供了坚实的基础。无论是哪个领域，这些结构都具有细长和曲折的共同特征，使得它们很难在图像中捕捉到，因为它们在图像中的比例很小。因此，迫切需要提升对细长管状结构的感知能力，所以在这一背景下作者提出了动态蛇形卷积(Dynamic Snake Convolution)。
原理-&gt;上图展示了一个三维心脏血管数据集和一个二维远程道路数据集。这两个数据集旨在提取管状结构，但由于脆弱的局部结构和复杂的整体形态，这个任务面临着挑战。标准的卷积核旨在提取局部特征。基于此，设计了可变形卷积核以丰富它们的应用，并适应不同目标的几何变形。然而，由于前面提到的挑战，有效地聚焦于细小的管状结构是困难的。
由于以下困难，这仍然是一个具有挑战性的任务：
细小而脆弱的局部结构：如上面的图所示，细小的结构仅占整体图像的一小部分，并且由于像素组成有限，这些结构容易受到复杂背景的干扰，使模型难以精确地区分目标的细微变化。因此，模型可能难以区分这些结构，导致分割结果出现断裂。
复杂而多变的整体形态：上面的图片展示了细小管状结构的复杂和多变形态，即使在同一图像中也如此。不同区域中的目标呈现出形态上的变化，包括分支数量、分叉位置和路径长度等。当数据呈现出前所未见的形态结构时，模型可能会过度拟合已经见过的特征，导致在新的形态结构下泛化能力较弱。
为了应对上述障碍，提出了如下解决方案，其中包括管状感知卷积核、多视角特征融合策略和拓扑连续性约束损失函数。具体如下：
1. 针对细小且脆弱的局部结构所占比例小且难以聚焦的挑战，提出了动态蛇形卷积，通过自适应地聚焦于管状结构的细长曲线局部特征，增强对几何结构的感知。与可变形卷积不同，DSConv考虑到管状结构的蛇形形态，并通过约束补充自由学习过程，有针对性地增强对管状结构的感知。
2. 针对复杂和多变的整体形态的挑战，提出了一种多视角特征融合策略。在该方法中，基于DSConv生成多个形态学卷积核模板，从不同角度观察目标的结构特征，并通过总结典型的重要特征实现高效的特征融合。
3. 针对管状结构分割容易出现断裂的问题，提出了基于持久同调（Persistent Homology，PH）的拓扑连续性约束损失函数（TCLoss）。PH是一种从出现到消失的拓扑特征响应过程，能够从嘈杂的高维数据中获取足够的拓扑信息。相关的贝蒂数是描述拓扑空间连通性的一种方式。与其他方法不同，TCLoss将PH与点集相似性相结合，引导网络关注具有异常像素/体素分布的断裂区域，从拓扑角度实现连续性约束。
总结:为了克服挑战，提出了DSCNet框架，包括管状感知卷积核、多视角特征融合策略和拓扑连续性约束损失函数。DSConv增强了对细长曲线特征的感知，多视角特征融合策略提高了对复杂整体形态的处理能力，而TCLoss基于持久同调实现了从拓扑角度的连续性约束。
三、DySnakerConv的核心代码 下面的检测头可以用于分割和目标检测，但是其修改教程有差别。目标检测的检测头我就不讲了，大家看我之前的检测头如何添加的就可以，都是一样的只是换一个名字，本文主要针对于分割的读者。
import torch import torch.nn as nn import math from ultralytics.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66dc24e4507bbac494e60bbba10d2f6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2015154cd13031bb16f0f71c927975f5/" rel="bookmark">
			【RT-DETR有效改进】带你分析如何确定改进的基础模型，解决模型无法收敛精度很差的问题(ResNet官方一比一复现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、本文介绍 Hello，各位读者，距离第一天发RT-DETR的博客已经过去了接近两个月，这段时间里我深入的研究了一下RT-DETR在ultralytics仓库的使用，旨在为大家解决为什么用v8的仓库训练的时候模型不收敛，精度差的离谱的问题，我也是成功的找到了解决方案，对于ultralytics仓库进行多处改进从而让其还原RT-DETR官方的实验环境从而达到一比一的效果。
其次我也将RT-DER的官方版本ResNet18、ResNet34、ResNet50、ResNet101集成在ultralytics仓库（不同于现在仓库里更新的R50和R101我是根据RT-DETR官方的代码一比一移植过来的参数量基本保持一致，网上发的都是ResNet的本身，但这和RT-DETR官方实验的版本其实是有很大的出入的）所以从今天开始正式开始更新RT-DETR的改进了，下面来教大家选取自己的baseline也就是你改进的基础模型，后面会说到如何解决模型为何不收敛的问题，以及我用我复现模型训练的结果。 本专栏旨在打造全网最好的RT-DETR专栏！
目录
一、本文介绍
二、RT-DETR发表论文的方向 三、Baseline的选择 四、模型无法收敛的问题 五、专栏链接
二、RT-DETR发表论文的方向 开始之前先来给大家聊一下RT-DETR发论文的方向，我们发论文的两个大方向一个就是轻量化另一个就是提高mAP精度，针对于RT-DETR这个模型我认为其无论选取这两个方向的任意一个都是非常好的选择，但总有一个更容易，我下面分别来讲一下。
选择轻量化的理由(十分推荐)：RT-DETR的模型都是非常大的，其最小的版本RT-DETR-R18都有2kw的参数量GFLOPs达到了60，这是一个非常大的参数了，我们如果想在其基础上做一个轻量化的操作，我们拿市面上的任意一个主干基本上都可以减少其参数量，所以我认为如果大家想在RT-DETR领域发一遍论文轻量化是一个非常好的选择，尤其是在一些实时检测领域上。
提高mAP精度的理由(推荐)：从RT-DETR的实验对比上来看，其精度其实是不如YOLO系列的，所以我们就有很多的借鉴模块来使用，来提高mAP，不过提高mAP肯定不如轻量化的方向毕竟其打的旗号就是在实时检测领域超越YOLO的存在。
其它方向就不介绍了，我觉得都不如这两个好发。
三、Baseline的选择 下面来给大家说一下如何选取你的baseline
第一考虑的肯定是大家的算力，RT-DETR的模型非常大，我移植到ultralytics仓库的R18版本RT-DETR参数量基本和官方一致为2kw但GFLOps稍微有点差别为58.6和官方差了1.4(为YOLO版本自带的误差）。
（ 此版本大家在网上任意一个地方都找不到为我本人按照官方的内容一比一移植过来的）
上面说到了算力，我自己的电脑是3070-8G的显卡跑R18只能跑到4batch_size，如果更高的版本我的batch_size就需要往下降低。
然后先讲解我们选择Baseline的两个大的方向一个是ResNet版本，另一个是PPHGNetV2版本的，这里我建议大家选择的是ResNet版本，我来说一下理由
ResNet好像是2015年提出的，其效果早已被如今的各种网络模型超越，所以其改进空间非常大，无论是从轻量化的角度还是提高精度的角度出发都更容易一些。
PP-HGNetV2是百度今年新提出来的网络模型，其无论是精度还是成熟度上都已经很完美了，如果大家选择这个可能就会陷入像YOLOv8一样提高精度和轻量化都不好做，所以我推荐的是ResNet系列的版本(个人见解)。
我们再来说一下ResNet的多个版本。
其中首先pass掉的就是R101了模型太大改进成本太高了。
其次是R18、R34、R50。
一开始我想推荐R50了但是觉得其不如R18首先R18作为最基础版本的模型，其精度远不如哪几个，然后其参数量也是一个绝大多数人可以接受的范围内2kw和计算量60GFLOPs，所以我个人推荐的就是最基础的R18版本，其可以被绝大多数人接受的同时也更能容易改进，同时现在ultralytics仓库里面还没有集成ResNet18(这也是因素之一)，如果大家和我学习改进的话就相当于快人一步了，下面给大家看一下完整网络结构的打印。
四、模型无法收敛的问题 这里再给大家说一下大家训练模型不拟合的问题是因为有些参数没有按照官方版本的进行设置，因为 ultralytics首先是要为了YOLO系列服务的，而RT-DETR对于参数是非常的敏感的其有一些代码设置的也和YOLO系列相不符合，所以现在的ultralytics仓库的RT-DETR只能说有了RT-DETR的外壳内部确是不符的，所以这些问题导致大家训练模型不能够拟合，无论怎么换数据集效果都一样。
所以想要学习RT-DETR的您可以关注本专栏(我会教大家如何调参数，然后修改模型中的代码适配RT-DETR还原RT-DETR的环境)，相信本专栏一定会让您有所收获，本专栏本次旨在打造全网最好的RT-DETR专栏，订阅专栏之后您也可以像我的YOLOv8用户一样获得官方的交流群和完整的项目文件(包含我所有的改进机制，均可完美运行)，以及我的视频讲解教大家一些发论文过程种我本人的各种经验。
下面是按照我修改完以后RT-DETR模型的拟合图片，这还仅仅是R18的版本，所以想要和我学习RT-DETR发论文的读者可以关注一下本专栏的动态。
以下为训练完成的结果图。
下面介绍一下我以后的博客必备的内容就是实验对比图，该图会给大家放在最前侧展示改进机制的效果，可能是轻量化的也可能是提点的。
五、本文总结 从今天开始正式开始更新RT-DETR剑指论文专栏，本专栏的内容会迅速铺开，在短期呢大量更新，价格也会乘阶梯性上涨，所以想要和我一起学习RT-DETR改进，可以在前期直接关注，本文专栏旨在打造全网最好的RT-DETR专栏为想要发论文的家进行服务。
官方链接：RT-DETR剑指论文专栏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527b7be409e3c8f68148fa347f3f5b87/" rel="bookmark">
			微信小程序：手机授权getPhoneNumber拒绝授权返回错误信息提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 其中 IOS：getPhoneNumber:fail user deny；Android：getPhoneNumber:fail:user deny &lt;button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber"&gt; &lt;view&gt;手机号一键登录&lt;/view&gt; &lt;/button&gt; getPhoneNumber: function(e){ if(e.detail.errMsg === 'getPhoneNumber:ok'){ wx.login({ success(res) { // 登录授权 } }); }else if(e.detail.errMsg === 'getPhoneNumber:fail user deny' || e.detail.errMsg === 'getPhoneNumber:fail:user deny'){ // 拒绝授权 Dialog.alert({ message: '授权失败，游客模式登录', }) } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5146a6bbb0ac3da11d7561306ef2bb5/" rel="bookmark">
			自旋锁和互斥锁的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自旋锁和互斥锁的区别_自旋锁和互斥锁有什么区别?-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b117bccb4ab3e5b6ba43eb296437676/" rel="bookmark">
			【ASP.NET Core 基础知识】--MVC框架--Models和数据绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Models和数据绑定在ASP.NET Core MVC中扮演着关键的角色，对于构建强大、灵活和可维护的Web应用程序至关重要。这一节我们就来讲一下。
一、Models 1.1 Models的定义和作用 在ASP.NET Core MVC中，Model是应用程序中用于表示数据结构和业务逻辑的一种抽象。Models充当了MVC（Model-View-Controller）模式中的“M”（Model）部分，负责管理应用程序的数据、状态和业务规则。以下是Models的定义和作用：
定义： 数据结构： Models定义了应用程序中的数据结构，包括实体、对象和数据字段。业务逻辑： Models包含与数据相关的业务规则，例如验证规则、计算逻辑和数据转换。 作用： 数据表示： Models是数据在应用程序中的逻辑表示。它们定义了数据的组织方式，使其更易于理解和处理。业务规则： Models中包含的业务逻辑规则确保数据的有效性、完整性和一致性。状态管理： Models可以跟踪应用程序中的状态变化，使得能够更好地管理数据的生命周期。数据验证： Models中定义的验证规则用于验证用户输入，确保输入的数据符合应用程序的期望。模型绑定： Models通过模型绑定将用户提交的数据映射到控制器中，实现了用户请求和应用程序数据的解耦。 通过定义和使用Models，开发人员能够更清晰地组织和管理应用程序的数据，提高代码的可维护性和可测试性。 Models的作用不仅仅是存储数据，还包括在应用程序中对数据进行操作和管理的一系列任务。
1.2 创建Models类 在ASP.NET Core MVC中创建Models类通常是通过定义C#类来表示应用程序中的数据结构。下面是一个简单的示例，展示如何创建一个名为 Product 的Models类：
using System.ComponentModel.DataAnnotations; public class Product { public int Id { get; set; } public string Name { get; set; } public decimal Price { get; set; } public string Description { get; set; } } 在这个示例中，Product 类有四个属性：Id、Name、Price 和 Description。这个 Product 类可以被用作控制器的参数，也可以在视图中通过模型绑定进行处理。在ASP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b117bccb4ab3e5b6ba43eb296437676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec09a8ebb31caa69627a8e943b8f609/" rel="bookmark">
			git 中的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git 中的概念 在使用 Git 版本控制的过程中，有些概念我们必须有所了解，这样才能更有效率也更有意义的学下去。
有清楚且正确的概念认知，不但有助于我们学习如何操作 Git 命令，更重要的是，学习 Git 的相关知识也会更加容易上手。
本文的一些概念都是使用英文为主，这是因为在不同文章里可能会存在一些翻译问题，会导致大家有一些理解误差。
repository 我们更多的将其翻译为「仓库」， 我们要使用 Git 进行版本控制，很自然的，我们需要一个「仓库」来储存这些版本信息，这个仓库其实就是用来储存所有版本的一个空间或一个文件夹与一堆文件。
如果有了解过 Git 的人，应该很清楚，建立仓库有很多方法，如果我们要在任意一个文件夹里建立一个 Git 仓库，只要输入以下命令就可以建立完成：
git init 从上图可以看到，我们在执行了 git init 命令后在 demo 目录下创建了 .git 目录，这个文件夹就是一个 Git 仓库，未来所有版本的变更，都会自动储存在这个文件夹里面。
working directory 「工作目录」
在上面我们执行了 git init 命令后，这个 demo 文件夹就会自动成为我们的「工作目录」。
所谓「工作目录」的意思，就是我们正在准备开发的项目文件，未来都会在这个目录下进行编辑，无论是新增文件、修改文件、删除文件、文件更名以及所有其他 Git 相关的操作，都会在这个目录下完成，所以才称为「工作目录」。
由于在使用 Git 版本控制时，会遭遇到很多分支的状況，所以「工作目录」很有可能会在不同的分支之间进行切换，有些 Git 命令在执行的时候，会一并更新「工作目录」下的文件。例如当我们使用 git checkout 切换到不同分支时，由于目前分支与想要切换过去的分支的目录结构不太一样，所以很有可能会将我们目前「工作目录」下的文件进行更新，好让目前的「工作目录」下的这些目录与文件，都与另一个要切换过去的分支下的目录与文件一样。
所以，适时的保持「工作目录」的干净，是版本控制过程中的一个基本原则，更尤其是日后要进行合并的时候，这点尤其重要。
staging area 「暂存区」，由于在 git 仓库中「暂存区」其实是一个名为 index 的文件（ .git/index ），所以也会被叫做「索引」。
「工作目录」下的每一个文件都只有一种状态：已跟踪 或 未跟踪。
已跟踪的文件是指那些被纳入了版本控制的文件，「工作目录」中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入「暂存区」。简而言之，已跟踪的文件就是 Git 已经知道的文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cec09a8ebb31caa69627a8e943b8f609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f9a463163b5e96226dcc1c166f1714d/" rel="bookmark">
			【排序算法】四、堆排序（C/C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「前言」文章内容是排序算法之堆排序的讲解。（所有文章已经分类好，放心食用）
「归属专栏」排序算法
「主页链接」个人主页
「笔者」枫叶先生(fy)
目录 堆排序1.1 原理1.2 堆的向下调整1.3 堆排序代码实现1.3 性质总结 堆排序 1.1 原理 概念介绍
堆是一种特殊的树形数据结构，它满足以下两个性质：
堆是一棵完全二叉树堆中每个节点的值都必须大于等于（或小于等于）其子节点的值，这样的堆称为大根堆（或小根堆） 堆排序是一种基于二叉堆数据结构的排序算法，堆排序一般都是使用数组（顺序表）的结构进行排序（顺序存储）
堆排序算法的核心就是利用堆的性质来实现排序，堆这里就不详细介绍了（在数据结构——堆中已经详细介绍）
堆排序采用的是堆的向下调整算法（为什么选这个，在数据结构——堆中已经详细介绍）
堆排序想要对排序的数进行升序排序：建小根堆（小堆）想要对排序的数进行降序排序：建大根堆（大堆）小根堆：在小根堆中，任意节点的值都小于或等于其子节点的值（最小值在根节点）大根堆：在大根堆中，任意节点的值都大于或等于其子节点的值（最大值在根节点） 堆排序的构建步骤
先构建堆：将待排序的序列构建成一个大堆（或小堆）再调整堆：将堆顶元素与堆的最后一个元素交换，并重新调整堆，使得剩余元素仍然满足堆的性质重复步骤2，直到所有元素都排好序 注意：需要注意的是排升序要建大堆，排降序建小堆
下面介绍堆的向下调整
1.2 堆的向下调整 堆向下调整算法的基本思想是将堆中的某个节点按照堆的性质向下调整，使得以该节点为根的子树重新成为一个堆。具体步骤如下：
首先确定需要调整的节点的左右子节点中的较大值（或较小值，根据堆的性质而定）将该节点与其左右子节点中的较大值（或较小值）进行比较，如果该节点的值不符合堆的性质（小堆或大堆），则交换两者的位置继续对交换后的节点进行向下调整，直到该节点的值符合堆的性质或者已经没有子节点可以进行比较为止 通过这样的向下调整操作，可以保持堆的性质不变，并且在插入或删除节点之后，可以快速地恢复堆的性质
例如（以小堆为例）
从根结点处开始，选出左右孩子中值较小的孩子让小的孩子与其父亲进行比较若小的孩子比父亲还小，则该孩子与其父亲的位置进行交换并将原来小的孩子的位置当成父亲继续向下进行调整，直到调整到叶子结点为止若小的孩子比父亲大，则不需处理了，调整完成，整个树已经是小堆 注意：向下调整算法有一个前提：左右子树必须是一个堆，才能调整
假设向下调整27，如图所示：
堆的向下调整算法代码：
降序：小堆
void Swap(int* p1, int* p2) { int tmp = *p1; *p1 = *p2; *p2 = tmp; } // 堆的向下调整（下面是小堆：降序） void AdjustDown(int* arr, int n, int parent) // n:arr数组的大小; parent:父节点的数组下标 { // 左子节点下标为parent * 2 + 1; 右子节点的下标为parent * 2 + 2 int child = parent * 2 + 1; // 假设左孩子较大 // while (child &lt; n) { // 选出左右孩子中小的那个 if ((child + 1 &lt; n) &amp;&amp; arr[child] &gt; arr[child + 1]) // child + 1:右孩子的下标；-- 右孩子存在，并且左孩子比右孩子大 { ++child; } // 孩子跟父亲比较 if (arr[child] &lt; arr[parent]) { Swap(&amp;arr[child], &amp;arr[parent]); // 交换数据 //迭代 parent = child; child = parent * 2 + 1; } else { break; } } } 注：若父节点下标为parent，左子节点下标为parent * 2 + 1，右子节点的下标为parent * 2 + 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f9a463163b5e96226dcc1c166f1714d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1b6dc81c203f3385d874bdcf5a9099/" rel="bookmark">
			科研学习|论文解读——信息世界映射方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：信息世界映射的下一步是什么？在情境中理解信息行为/实践的国际化和多学科方法（What is next for information world mapping? International and multidisciplinary approaches to understanding information behaviors/ practices in context）
1.引言 信息世界映射（IWM）是一种以艺术为基础的参与式方法。参与者在自己的信息世界中绘制人、地点和事物的视觉地图。IWM 的优势包括其可访问性、灵活性和可扩展性。研究人员已在国际范围内应用了 IWM。台湾（Tsai，2021 年）、加拿大（Greyson &amp; Bettinger，2017 年；Mabi，2020 年）、苏格兰（Martzoukou &amp; Burnett，2018 年）和美国（Kitzie、Wagner &amp; Vera，2021 年）的研究人员都应用该方法发表了研究报告。研究的主题各不相同，包括家庭护理（Dalmer，2017 年）、LGBTQIA + 健康信息获取(Kitzie 等人，2021 年）、难民安置（Martzoukou &amp; Burnett, 2018）和学生学习轨迹（Greyson, Tsai, Kitzie, Martzoukou, &amp; Mabi, 2021; Tsai, Chen, Tai, &amp; Chen, 2019）。这些研究涉及公共卫生、教育、老龄化研究和信息科学等多个领域。虽然 IWM 可追溯到已有的方法和理论，包括信息视野information horizons （Sonnenwald，1999 年）、相片传声Photovoice （Wang &amp; Burris，1997 年）、关系图谱relational mapping （Radford，2022 年）和信息世界information worlds （Jaeger &amp; Burnett，2010 年），但它相对较新，由 Greyson（2013 年、2015 年）在不到十年内提出。本文描述的一组国际学者探讨了如何将这一技术应用于多种情境，探索了信息世界映射在信息科学研究中的挑战和新用途，并提出了运用信息世界映射进行研究的未来方向。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b1b6dc81c203f3385d874bdcf5a9099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4113eb4130e7cc201c770f5307af3685/" rel="bookmark">
			Vue入门五（Vue-CLI项目搭建｜vue项目目录介绍｜vue项目开发规范｜es6导入导出语法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Vue-CLI 项目搭建介绍node环境搭建1) 下载与安装2）测试是否安装成功 安装vue-cli安装vue脚手架 创建Vue项目1）使用命令创建项目2）使用图形化界面创建项目 二、vue项目目录介绍1.命令行运行vue项目2.Pycharm中运行项目3.目录结构 三、vue项目开发规范四、es6导入导出语法1）默认导入导出2）命名导入导出 一、Vue-CLI 项目搭建 介绍 Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统.
前端项目，使用工具(vue-cli)创建vue项目，单页面应用spa,组件化开发把xx.vue,ts,saas,less------编译后在浏览器中执行
vue-cli 创建项目开发–项目开发----编译(纯的html/js/css)—上线–&gt;浏览器只能识别html/js/css
vue-cli工具，使用nodejs写，要运行需要安装node环境----需要下载node解释器
注意：可以在项目添加文件防篡改校验，先把文件生成md5值，以后被下载下来，再生成md5值做比对，结果不一致证明文件被篡改了
CLI
CLI (@vue/cli) 是一个全局安装的 npm 包，提供了终端里的 vue 命令。它可以通过vue create快速搭建一个新项目，或者直接通过vue serve构建新想法的原型。你也可以通过 vue ui 通过一套图形化界面管理你的所有项目。
vue
vue2.x和vue3.x的区别？
vue2.x,使用使用vue-cli ：https://cli.vuejs.org/zh/vue3.x使用vue-cli,vite只能创建vue3，效率非常高 Vue-CLT项目搭建，vue相当于脚手架，可以创建vue项目。vue脚手架必须要按照node js解释型语言。
node环境搭建 1.nodejs是一门后端语言 2.JavaScript只能运行在浏览器中，因为浏览器中有他的解释器环境 3.基于谷歌浏览器的v8引擎(js解释器)，使它能够运行在操作系统上 文件操作、网络操作、数据库操作--模块 1) 下载与安装 官网下载相应的解释器版本(window系统64位)，一路安装—设置安装的路径，安装完成会有两个可执行问题，类似于python解释器的安装包pipi。官网地址：https://nodejs.org/en。然后一路傻瓜式安装即可
2）测试是否安装成功 命令端打开node操作测试是否安装成功
1. node 进入node环境 2.npm install 装模块 -node---相当于python的python命令 -npm----相当于python的pip命令 A、node -v 查看 node 版本 B、npm -v 查看 npm 版本 由于npm下载模块是去国外的仓库，下载的时候会很慢，所以我们安装cnpm，它是国内源，这样以后都用cnpm来安装模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4113eb4130e7cc201c770f5307af3685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8adb0bdc3b108bb7874e4fbab988be/" rel="bookmark">
			K8S---kubectl top
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 该命令类似于linux–top命令，用于显示node和pod的CPU和内存使用情况
二、命令行 /opt/kubernetes/bin/kubectl --kubeconfig /opt/kubernetes/conf/default-admin.kubeconfig top pod --help /opt/kubernetes/bin/kubectl --kubeconfig /opt/kubernetes/conf/default-admin.kubeconfig top node --help 1、kubectl top podname kubectl top pod podname
kubectl top pod -l name=mylabel
–sort-by=‘’: If non-empty, sort nodes list using specified field. The field can be either ‘cpu’ or ‘memory’
使用指定的属性排序，可以指定cpu或者memory
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3d19dec23c78b56cc5be16a9bf6b4f2/" rel="bookmark">
			11 双向链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单链表的局限： 单链表的缺点：逆序访问单链表中的元素耗时大。（时间复杂度：O²）
双向链表的定义 第0个节点【a1】的pre指针为NULL，要注意
插入操作： 删除操作： 初步实现双链表 代码： 插入代码中要注意： 注意：第0个元素的pre指针为NULL
插入的是空双链表中的 第一个元素,示意图： 插入的为最后一个元素： main.c
//双链表 #include "DLinkList.h" struct Value { DLinkListNode header; int v; }; int main() { int i; DLinkList* list = DLinkList_Create(); struct Value v1; struct Value v2; struct Value v3; struct Value v4; struct Value v5; v1.v = 1; v2.v = 2; v3.v = 3; v4.v = 4; v5.v = 5; DLinkList_Insert(list, &amp;v1, DLinkList_Length(list)); DLinkList_Insert(list, &amp;v2, DLinkList_Length(list)); DLinkList_Insert(list, &amp;v3, DLinkList_Length(list)); DLinkList_Insert(list, &amp;v4, DLinkList_Length(list)); DLinkList_Insert(list, &amp;v5, DLinkList_Length(list)); for ( i = 0; i &lt; DLinkList_Length(list); i++) { struct Value* pv = (struct Value*)DLinkList_Get(list, i); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3d19dec23c78b56cc5be16a9bf6b4f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cfccbb01e2d521671e43c8b56dacbdf/" rel="bookmark">
			【C&#43;&#43;】STL 算法 ⑪ ( 函数适配器嵌套用法 | modulus 函数对象 - 取模运算 | std::count_if 函数原型 | std::not1 函数原型 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、函数适配器示例 - 函数适配器正常用法1、modulus 函数对象 - 取模运算2、std::count_if 函数原型3、代码示例 - 使用 函数适配器 绑定函数对象参数 二、函数适配器示例 - 函数适配器嵌套用法1、std::not1 函数原型2、代码示例 - 函数适配器嵌套用法 一、函数适配器示例 - 函数适配器正常用法 1、modulus 函数对象 - 取模运算 在 &lt;functional&gt; 头文件 中 , 预定义了 modulus 函数对象 , 这是一个 二元函数对象 , 在该函数对象类中 , 重写了 函数调用操作符 函数 operator() , 该 预定义函数对象 代码如下 :
// STRUCT TEMPLATE modulus template &lt;class _Ty = void&gt; struct modulus { _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty first_argument_type; _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty second_argument_type; _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty result_type; constexpr _Ty operator()(const _Ty&amp; _Left, const _Ty&amp; _Right) const { return _Left % _Right; } }; 该函数对象 定义了 模板参数 template &lt;class _Ty = void&gt; , _Ty 泛型的默认参数是 void , 即 如果 不指定 模板参数 , _Ty 泛型就是 void 类型 , 一般情况下使用 int 类型 进行取模运算 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cfccbb01e2d521671e43c8b56dacbdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4da12ce5ba6240b72aa8b52ec10f39c0/" rel="bookmark">
			Cesium 模型开挖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和模型压平类似，此处开挖也是采用修改了模型的顶点，通过判断定的位置来判断改顶点是否加载。
缺点：会有毛边。
后续我会再上个修改源码无毛边的版本。
// 三维模型裁剪 class TilesetCut { constructor(tileset, opt) { if (!tileset) { console.log("缺少模型"); return; } this.tileset = tileset; this.opt = opt || {}; /** * @property {Boolean} iscutOutter 是否为外部裁剪，默认为内部裁剪 */ this._iscutOutter = this.opt.iscutOutter; // 是否为外部裁剪 默认为内部裁剪 this.cutRegions = []; // 当前裁剪面数组对象 /* this.modelMatrix = new Cesium.Matrix4(); // 世界坐标系--》模型坐标系 Cesium.Matrix4.inverseTransformation(this.tileset.root.computedTransform, this.modelMatrix) */ // 建立模型中心点坐标系 const center = this.tileset.boundingSphere.center; const enuMtx4 = Cesium.Transforms.eastNorthUpToFixedFrame(center); this.modelMatrix = Cesium.Matrix4.inverse(enuMtx4, new Cesium.Matrix4()); this.canvas = undefined; } get iscutOutter() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4da12ce5ba6240b72aa8b52ec10f39c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18800c613a54726c87165d7e2588da25/" rel="bookmark">
			Cesium 模型压平
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近整理了下手上的代码，以下是对模型压平的说明。
原理是使用了customShader来重新设置了模型的着色器，通过修改模型顶点的坐标来实现了压平。
废话不多说，下面上代码：
/** * @class * @description 3dtiles模型压平 */ class Flat { /** * * @param {Cesium.Cesium3DTileset} tileset 三维模型 * @param {Object} opt * @param {Number} opt.flatHeight 压平高度 */ constructor(tileset, opt) { if (!tileset) return; this.tileset = tileset; this.opt = opt || {}; this.flatHeight = this.opt.flatHeight || 0; this.center = tileset.boundingSphere.center.clone(); this.matrix = Cesium.Transforms.eastNorthUpToFixedFrame(this.center.clone()); this.localMatrix = Cesium.Matrix4.inverse(this.matrix, new Cesium.Matrix4()); // 多面的坐标数组 this.regionList = []; // 多个面坐标转为局部模型坐标 this.localPositionsArr = []; } /** * 添加压平面 * @param {Object} attr 参数 * @param {Cesium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18800c613a54726c87165d7e2588da25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a636ef6f3aeadc26bb02e85dcbed42/" rel="bookmark">
			DB2除法的小数位问题（四舍五入问题）以及其他常用的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DB2除法的小数位问题（四舍五入问题）以及其他常用的函数 1. DB2取第一条数据2. DB2 中指定值排序2.1 使用case when2.2 使用decode函数 3. 拼接函数4. 强制转换类型——cast函数5. DB2除法的小数位问题（四舍五入问题）5.1 关于round函数5.1.1 round()函数的简单理解5.1.2 round() + cast()函数 实现四舍五入 5.2 dec() + cast()函数 实现四舍五入 6. 其他常用函数6.1 关于 COALESCE 函数——空字段处理6.2 trim()函数6.3 字符串截取函数6.3.1 substr()函数6.3.2 left() 与 right() 函数 7. 更多关于DB2的基本操作 1. DB2取第一条数据 语法如下：SELECT * FROM SYS_COMPANY_DEPT t FETCH FIRST 1 ROWS only; 2. DB2 中指定值排序 2.1 使用case when 先看没有任何排序的数据：
使用case when排序，如下：--要求排序顺序：2，3，0，1 SELECT * FROM SYS_COMPANY_DEPT t ORDER BY (CASE t.DEPT_LEVEL WHEN '2' THEN 1 WHEN '3' THEN 2 WHEN '0' THEN 3 WHEN '1' THEN 4 ELSE t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0a636ef6f3aeadc26bb02e85dcbed42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d9f5807ac92c6bf1a6837f7e591cae/" rel="bookmark">
			uniapp、vue、小程序常用的一些验证规则校验方法（例如：手机号。身份证、金额等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如： 检查是否为空数组 、是否是空 不为空false 为空true、校验密码、校验手机号格式、校验邮箱格式、校验身份证号格式、校验值长度 不少于6位数、 电话号码加密 15288889999 转化为 152****9999、身份证号码加密、验证输入重量、金额等类型 例如 0.11 2.23 100.123等等 、验证输入的钱 单纯验证金额类型 、验证是否是纯数值 、处理数据 ：可把制定相同的key值得对象存储到下级得children中、生成唯一ID、数字转中文 运行结果 ： 1 转为 一、图片转为base64、获取随机字符串、授权微信小程序消息推送。
新建utils.js文件 /** * 通用的数据处理和验证类 1、在main.js中配置下列代码 import Utils from '@/utils/utils.js'; Vue.prototype.$Utils = Utils; 2、使用方式 let str = "0"; if(this.$Utils.isNull(str)){ console.log("str 是空") } */ export default class Utils { /** * 检查是否为空数组 空数组返回 true * @param {Array} arr 数组 * @return Boolean */ static isEmptyArr(arr) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6d9f5807ac92c6bf1a6837f7e591cae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e81d4639c8e0b36d2da72bc52e7868/" rel="bookmark">
			基于Flask的高并发部署方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Flask方案简介服务端代码客户端代码 Gevent +Flask方案简介安装示例 gunicorn+Flask 部署服务简介安装示例 在AI部署方案中，Flask是最常用的方案！本文列举几种最常用基于Flask的部署方案。 Flask方案 简介 Flask 是一个轻量级的 Python Web 框架，它非常适合构建小型到中型的应用程序。下面是对 Flask 的详细解释和简单示例：
Flask 的特点：
轻量级：相比于 Django，Flask 更轻量级，更适合小型项目或微服务。简单：Flask 的 API 非常简洁，易于学习和使用。灵活：Flask 提供了基础功能，但并不限制开发者如何实现这些功能。扩展性强：有许多针对 Flask 的扩展，可以轻松地添加新功能。 基本组件：
路由：定义了 URL 和处理它们的函数之间的映射关系。模板引擎：用于渲染 HTML 页面。URL 构建：用于构建 URL。请求和响应对象：处理 HTTP 请求和响应。会话和 Cookie：用于跟踪用户会话。错误处理：捕获和处理异常。上下文：管理执行环境。 简单示例：
安装 Flask：首先需要安装 Flask。可以使用 pip 进行安装。 pip install flask 服务端代码 新建server.py
from flask import request, Flask import base64 import cv2 import numpy as np app = Flask(__name__) @app.route("/get_frame", methods=['POST','GET']) def get_frame(): #解析图片数据 img_card = base64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e81d4639c8e0b36d2da72bc52e7868/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7feeda5341e824f9ac9e354223eafdf9/" rel="bookmark">
			32_Win32 共享内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win32 共享内存 内存映射文件 很多文本编辑软件都提供了一个剪裁行尾空格的功能，例如EditPlus软件的编辑菜单项→格式→剪裁行尾空格。在调用ReadFile()函数读取文件时，每次读取一定大小的字节数例如64字节，这涉及一个缓冲区边界的问题。如果缓冲区的未尾有一个或多个空格，那么如何判断这些空格是单词之间的空格还是行尾的空格呢.因为缓冲区的末尾不一定正好是换行"\r\n"，所以类似这样的问题并不能很好解决。我们可以一次读入整个文件，但是在Win32程序中可以使用的内存空间只有2GB大小(实际上无法申请这么大的内存)，如果文件大小超过2GB怎么办呢?
内存映射文件提供了一组独立的函数，通过内存映射文件函数可以将磁盘上一个文件的全部或部分映射到进程虚拟地址空间的某个位置，完成映射后，程序就能够通过内存指针像访问内存一样对磁盘上的文件进行读写操作。
具体机制是，对磁盘文件所映射的内存的读写操作会通过系统底层自动实现对磁盘文件的读写。实际上还是需要把相关数据读入物理内存，类似于虚拟内存管理函数，内存映射文件会预订一块地址空间区域并在需要的时候提交页面。不同之处在于，内存映射文件的物理存储器来自磁盘上已有的文件，而不是系统的页面交换文件，实质上并没有省略什么环节，但是程序的结构将会从中受益，缓冲区边界等问题将不复存在。另外，内存映射文件会将硬盘上的文件不做修改地装载到内存中，内存中的文件和硬盘上的文件一样按字节顺序排列。但是，硬盘上的文件不一定按文件内容排列在一起，因为文件存储以簇为单位，整个文件内容可能会存储在不相邻的各个簇中;而通过内存映射文件读取到内存中的文件按线性排列，访问相对简单,访问速度得到了提升。
除此之外，以下两方面也用到了内存映射文件技术。
Windows操作系统加载、执行.exe和.dIl等可执行文件时也用到了内存映射文件技术，运行一个可执行文件时系统并不会把整个文件全部载入虚拟内存（页面交换文件和物理内存)中，这就节省了页面交换文件的空间以及应用程序后动所需的时间。使用内存映射文件还可以在同一台计算机上运行的多个进程之间共享数据,当一个进程改变了共享数据页的内容时，通过分页映射机制，其他进程的共享数据区的内容就会同时改变，因为它们实际上存储在同一个地方。许多进程间通信、同步机制在底层都是通过内存映射文件技术实现的。 使用内存映射文件的步骤通常如下。
调用CreateFile函数创建或打开一个文件内核对象，返回一个文件对象句柄hFile，该对象标识了我们想要用作内存映射文件的磁盘文件。调用CreateFileMapping函数为hFile文件对象创建或打开一个文件映射内核对象，返回一个文件映射对象句柄hFileMap调用MapViewOfFile函数把文件映射对象hFileMap的部分或全部映射到进程的虚拟地址空间中，返回一个内存指针lpMemory，即可通过该指针来读写文件，这一步操作是映射文件映射对象的一个视图到虚拟地址空间中。 当不再需要内存映射文件时，应该执行以下清理工作。
调用UnmapViewOfFile酗数取消对文件映射内核对象的映射，传入参数为lpMemory调用CloseHandle函数关闭文件映射内核对象，传入参数为hFileMap调用CloseHandle函数关闭文件内核对象，传入参数为hFile 内存映射文件相关函数 使用内存映射文件的第一步是调用CreateFile函数创建或打开一个文件内核对象，返回一个文件对象句柄hFile，该对象标识了我们想要用作内存映射文件的磁盘文件。然后，调用CreateFileMapping函数为hFile文件对象创建或打开一个文件映射内核对象，返回一个文件映射对象句柄hFileMap CreateFileMapping函数原型如下∶
HANDLE WINAPI CreateFileMapping ( _ln_ HANDLE hFile,	//文件对象句柄 _ln_opt_ LPSECURITY_ATTRIBUTES lpAttributes,//含义同其他内核对象的安全属性结构 _ln_ DWORD flProtect,//文件映射对象的页面保护属性 _ln_ DWORD dwMaximumSizeHigh, //文件映射对象大小的高32位，以字节为单位 _ln_ DWORD dwMaximumSizeLow,//文件映射对象大小的低32位，以字节为单位 _ln_opt_ LPCTSTR lpName //文件映射对象的名称,可为NULL ); flProtect参数指定文件映射对象的页面保护属性，可以是下表所示的值之一，以下页面保护属性都包含一个写时复制属性,后面会介绍写时复制。
页面保护属性值页面保护属性含义PAGE_READONLY Ox02完成对文件映射对象的映射时，文件具有可读和写时复制属性，必须使用GENERIC_READ访问权限创建hFile参数指定的文件PAGE_READWRITE Ox04完成对文件映射对象的映射时，文件具有可读可写和写时复制属性，必须使用GENERIC_READ|GENERIC_WRITE访问权限创建hFile参数指定的文件PAGE_EXECUTE_READ Ox20完成对文件映射对象的映射时，文件具有可读、可执行和写时复制属性,必须使用GENERIC_READ|GENERIC_EXECUTE访问权限创建hFile参数指定的文件PAGE_EXECUTE_READWRITE Ox40完成对文件映射对象的映射时，文件具有可读可写、可执行和写时复制属性，必须使用GENERIC_READ|GENERIC_WRITE|GENERIC_EXECUTE访问权限创建hFile参数指定的文件PAGE_WRITECOPY Ox08等效于PAGE_READONLYPAGE_EXECUTE_WRITECOPYO×80等效于 PAGE_EXECUTE_READ 接下来实现一个示例程序MemoryMappingFile，单击“打开文件"按钮，程序创建一个内存映射文件并将文件内容显示到多行编辑控件中;单击“追加数据"按钮，程序把单行编辑控件中的内容追加到文件中，并把新文件内容显示到多行编辑控件中，如图3.15所示。特别注意memcpy() 追加的时候，利用了内存地址的偏移来拷贝到文件的末尾处，这里需要注意一下，其他理解难度不大。
MemoryMappingFile.rc resource.h //{{NO_DEPENDENCIES}} // Microsoft Visual C++ 生成的包含文件。 // 供 MemoryMappingFile.rc 使用 // #define IDD_MAIN 101 #define IDC_EDIT_PATH 1001 #define IDC_EDIT_APPEND 1002 #define IDC_BTN_OPEN 1003 #define IDC_BTN_APPEND 1004 #define IDC_EDIT_TEXT 1005 // Next default values for new objects // #ifdef APSTUDIO_INVOKED #ifndef APSTUDIO_READONLY_SYMBOLS #define _APS_NEXT_RESOURCE_VALUE 103 #define _APS_NEXT_COMMAND_VALUE 40001 #define _APS_NEXT_CONTROL_VALUE 1006 #define _APS_NEXT_SYMED_VALUE 101 #endif #endif MemoryMappingFile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7feeda5341e824f9ac9e354223eafdf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f487e6c7a22b157f7cad05f3668f062f/" rel="bookmark">
			STM32——电容触摸按键充电时间测量实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1电容触摸按键 无手指触摸：上电时，电阻作用下，电容Cs进行充电，直到电容充满，这时候会有一个充电时间Tcs。
有手指触摸：上电时，电阻作用下，电容Cs和Cx进行充电，电容充满时间会变长，得到充电时间Tcx。
注意：充电过程可以看成是一个信号从低电平变为高电平的过程。STM32认为高电平的最低电压值(1.8V)、
2检测电容触摸按键实验过程 没有按下的时候，充电时间为T1(default)。按下TPAD，电容变大，所以充电时间为T2。
我们可以通过检测充电时间来判断是否按下。如果T2-T1大于某个值，就可以判断触摸按键按下。
3.重点函数及调用过程 tpad_reset函数：复位TPAD（放电且开始充电，并清空定时器计数器CNT值）
tpad_get_val函数：获取一次捕获值（复位TPAD，等待捕获上升沿得到充电时间）
tpad_get_maxval函数：多次调用tpad_get_val函数获取充电时间，获取最大的值
tpad_init函数：初始化TPAD，调用tpad_get_val获取电容触摸按键没有按下的默认充电时间值
tpad_scan函数：扫描TPAD，调用tpad_get_maxval获取多次充电中最大充电时间进行判断
tpad_timx_cap_init函数：输入捕获通道初始化
4.电容触摸按键充电时间测量实验实战 4.1 tpad.c #include "./BSP/TPAD/tpad.h" #include "./SYSTEM/delay/delay.h" #include "./SYSTEM/usart/usart.h" /* 空载的时候(没有手按下),计数器需要的时间 * 这个值应该在每次开机的时候被初始化一次 */ //1.空载时计数器时间 volatile uint16_t g_tpad_default_val = 0; /* 空载的时候(没有手按下),计数器需要的时间 */ /*定时器输入边沿捕获*/ static TIM_HandleTypeDef g_timx_cap_chy_handler; /* 定时器x句柄 */ static TIM_IC_InitTypeDef g_timx_ic_cap_chy_handler; /** * @brief 初始化触摸按键 * @param psc : 分频系数(值越小, 越灵敏, 最小值为: 1) * @retval 0, 初始化成功; 1, 初始化失败; */ uint8_t tpad_init(uint16_t psc) { //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f487e6c7a22b157f7cad05f3668f062f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1dc6aef509cfeccfefc99dad27682d5/" rel="bookmark">
			力扣_数组28—子集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
输入： n u m s = [ 1 , 2 , 3 ] nums = [1,2,3] nums=[1,2,3]
输出： [ [ ] , [ 1 ] , [ 2 ] , [ 1 , 2 ] , [ 3 ] , [ 1 , 3 ] , [ 2 , 3 ] , [ 1 , 2 , 3 ] ] [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1dc6aef509cfeccfefc99dad27682d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f30a5e54cba68d34456f0bb2941ff8ae/" rel="bookmark">
			基于昇腾910B搭建多节点K8s集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从 2013 年 Docker 诞生以来，容器一跃成为 IT 界最热门的话题。而 Kubernetes 趁着容器的东风，击败众多竞争对手，成为了“容器编排”领域的King。可以说，现在 Kubernetes 已经没有了实际意义上的竞争对手，它的地位就如同 Linux 一样，成为了事实上的云原生操作系统，是构建现代应用的基石。
一、创建多节点K8s集群 Kubernetes 是很多模块构成的，实现核心功能的组件像 apiserver、etcd、scheduler 等本质上都是可执行文件，所以也可以采用和其他系统差不多的方式，使用 Shell 脚本或者 Ansible 等工具打包发布到服务器上。
不过 Kubernetes 里的这些组件的配置和相互关系实在是太复杂了，用 Shell、Ansible 来部署的难度很高，需要具有相当专业的运维管理知识才能配置、搭建好集群，而且即使这样，搭建的过程也非常麻烦。为了简化 Kubernetes 的部署工作，社区里的人整了一个专门用来在集群中安装 Kubernetes 的工具，名字就叫“kubeadm”，意思就是“Kubernetes 管理员”。
kubeadm，原理和 minikube 类似，也是用容器和镜像来封装 Kubernetes 的各种组件，但它的目标不是单机部署，而是要能够轻松地在集群环境里部署 Kubernetes，并且让这个集群接近甚至达到生产级质量。而在保持这个高水准的同时，kubeadm 还具有了和 minikube 一样的易用性，只要很少的几条命令，如 init、join、upgrade、reset 就能够完成 Kubernetes 集群的管理维护工作，这让它不仅适用于集群管理员，也适用于开发、测试人员。
多节点集群，要求服务器应该有两台或者更多，我部署的 Kubernetes 集群就只有两台910B主机，一台是 Master 节点，另一台是 Worker 节点。当然，后续可以在这个集群里添加更多的节点。Master 节点需要运行 apiserver、etcd、scheduler、controller-manager 等组件，管理整个集群。
Worker 节点没有管理工作，只运行业务应用，所以配置可以低一些。
基于模拟生产环境的考虑，在 Kubernetes 集群之外还需要有一台起辅助作用的服务器。它就是 Console，要在上面安装命令行工具 kubectl，所有对 Kubernetes 集群的管理命令都是从这台主机发出去的。这也比较符合实际情况，因为安全的原因，集群里的主机部署好之后应该尽量少直接登录上去操作。
Console 这台主机只是逻辑上的概念，不一定要是独立，你在实际安装部署的时候完全可以复用 minikube 的虚拟机，或者直接使用 Master/Worker 节点作为控制台。这 3 台主机共同组成了我们的实验环境，所以在配置的时候要注意它们的网络选项，必须是在同一个网段，保证它们使用的是同一个“Host-Only”（VirtualBox）或者“自定”（VMWare Fusion）网络。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f30a5e54cba68d34456f0bb2941ff8ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2b373f794332dd527c87ce9bdf9e55/" rel="bookmark">
			Word·VBA实现邮件合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 制作邮件合并模板VBA实现邮件合并举例 之前写过的一篇使用《python实现word邮件合并》，本文为vba实现方法
制作邮件合并模板 域名可以使用中文，最终完成的word模板，wps操作步骤类似
VBA实现邮件合并 在Excel启用宏的工作表运行以下代码，读取当前工作表数据，对模板word文档，按工作表表头名称对同一域名写入值，生成新文档
Sub word邮件合并_按域名写入() '读取当前工作表数据，按arr二维数组第1行表头名称，对word文档中同一域名写入值，生成新文档 Dim fso As Object, wd As Object, docx$, save_path$, arr, i&amp;, j&amp;, k, v, f, fs '--------------------参数填写：docx、arr、save_path docx = "E:\测试\docx\证明-模板word.docx" '模板文件路径 arr = ActiveSheet.[a1].CurrentRegion.Value '合并数据，当前工作表 save_path = ActiveWorkbook.path &amp; "\结果\" '文件保存路径 Set fso = CreateObject("Scripting.FileSystemObject"): tm = Timer If Not fso.FolderExists(save_path) Then fso.CreateFolder (save_path) '创建文件夹 Set wd = CreateObject("word.application") ': wd.Visible = True '默认不可见 Set tmpl = wd.Documents.Open(docx) For i = 2 To UBound(arr) With tmpl For j = 1 To UBound(arr, 2) k = arr(1, j): v = arr(i, j) 'k表头/域名，v值 Set fs = .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf2b373f794332dd527c87ce9bdf9e55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/779f63331971c55b8e46fb924669666d/" rel="bookmark">
			【深入理解计算机系统 第三版 导读】第二章 信息的表示和处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第二章 信息的表示和处理 文章目录 第二章 信息的表示和处理2.1. 信息存储2.1.1. 十六进制表示法2.1.2. 字数据大小2.1.3. 寻址和字节顺序2.1.4. 表示字符串2.1.5. 表示代码2.1.6. 布尔代数简介2.1.7. C语言中的位级运算2.1.8. C语言中的逻辑运算2.1.9. C语言中的移位运算 2.2. 整数表示2.2.1. 无符号位向量到整数映射：2.2.2. 有符号位向量到整数映射：2.2.3. 有符号数与无符号数的转化：2.2.4. 无符号数转化位更大数据类型2.2.5. 有符号数转化为更大数据类型2.2.6. 截断无符号数2.2.7. 截断有符号数 2.3. 整数的运算2.3.1. 无符号数加法溢出2.3.2. 有符号数加法溢出2.3.3. 减法2.3.4. 无符号数乘法2.3.5. 补码乘法2.3.6. 有符号和无符号除2的幂 2.4. 浮点数2.4.1. 浮点数的表示与转换2.4.2. IEEE表示2.4.3. 规格化2.4.4. 非规格化2.4.5. 特殊值2.4.6. IEEE例题2.4.7. 整型转浮点2.4.8. 舍入2.4.9. 浮点数加法和乘法2.4.10. 转化 本章节为《深入理解计算机系统》第三版的个人导读，参考B站up主-九曲阑干 【深入理解计算机系统 第三版 导读】第一章 计算机系统漫游
2.1. 信息存储 1字=1字节(1 word=2 byte)，1字节=8位(1 byte=8 bit)，字节是机器最小可寻址的内存单位，不是内存中单独的位。
2.1.1. 十六进制表示法 一个字节由8位组成。在二进制表示法中，它的值域为00000000~11111111，如果看成十进制整数，它的值域就是0~255，如果用十六进制书写的话，它的值域就是00~FF。其中A~F大小写都没有问题。在二进制转化为十六进制上，首先将二进制分为4位一组，如果不够四位的话补零，例如：0011.1011 1000，转化的结果就是3.B8。转化回去就是一个逆过程。十进制转化为十六进制可以采用先转化为二进制或者除以16取余操作。
2.1.2. 字数据大小 大多数64位机器可以运行32位机器编译的程序，这是一种向后兼容。编译指令为：linux&gt; gcc -m32 prog.c或gcc -m64 prog.c
2.1.3. 寻址和字节顺序 这一节是大端法和小端法。假设变量x的类型为int，位于地址0x100处它的十六进制为0x01234567。地址范围为0x100~0x103的字节顺序依赖于机器类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/779f63331971c55b8e46fb924669666d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ceb355c8ad1f6636e692b6a7c81c5d/" rel="bookmark">
			Python: Spire.PDF-for-Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# encoding: utf-8 # 版权所有 2024 ©涂聚文有限公司 # 许可信息查看： # 描述： # Author : geovindu,Geovin Du 涂聚文. # IDE : PyCharm 2023.1 python 3.11 # Datetime : 2024/1/11 10:32 # User : geovindu # Product : PyCharm # Project : EssentialAlgorithms # File : SimpleTable.py # explain : 学习 from spire.pdf.common import * from spire.pdf import * class SimpleTable(object): def createtable(self): """ 生成表格示例 :return: """ outputFile = "CreateTwoColumnPDF.pdf" # Creates a pdf document doc = PdfDocument() # Creates a new page page = doc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8ceb355c8ad1f6636e692b6a7c81c5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aa6e1a50882c1b39095d666a68c83cd/" rel="bookmark">
			专业130&#43;总400&#43;哈尔滨工业大学803信号与系统和数字逻辑电路考研经验哈工大，电子信息，信息与通信工程，信通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年专业课803信号与系统和数字逻辑130+总分400+如愿考上哈尔滨工业大学电子信息（信息与通信工程-信通），总结了一些各门课程复习心得，希望对大家复习有帮助。
数学一
资料选择：
①高数：张宇强化班
②线性代数：李永乐强化
③概率论：王式安强化+张宇强化
上面说的都是视频，下面说纸质资料。李永乐复习全书强化版、李永乐660题；张宇高数18讲、概率论9讲、1000题；历年真题；模拟题资料，推荐李林6+4，张宇的8套卷？（好像是8套吧），因为我时间比较赶，虽然买了很多，但是最后只做完了李林的10套和张宇的一两套，所以其余的不做推荐。这里强烈推荐李林的卷子。
复习规划：
4-6月：在准备期末考试之前完成第一遍的复习，主要是看李永乐全书，视频课程，660题做完。视频习惯了语速之后，在能跟上的情况下可以倍速，毕竟老师们的语速太慢。第一遍重点在于理解，数学这个学科很吃理解的，如果死记题型的话，一旦稍微难一点、或者题不顺手一点，就会出大问题。特别偏难怪的题可以先放一放，基础阶段不要死磕偏题怪题。
7-9月：完成数学的第二遍强化学习，完成1000题，查缺补漏，遇到不会的问题立刻回去翻书，或者在视频里找，一定不能放过任何一个不会的概念。1000还是有一定难度的，边做边总结思路和方法，尤其是不会的题、做错的题。（期末考试完成以后，暑假期间，8月份在家呆了一整月，每天学习时间不超过2小时，直接废了，希望大家引以为鉴，我身边的考研的同学，比如我舍友和他的同学，暑假只回家一周就又回到学校投入到学习当中了。家里真不适合学习，不要过分信任自己的自制力。）
10月：“真题月” 但是因为我8月份在家荒废了一个月，拖到了11月才开始，导致后面的时间非常紧迫，大家千万不要这样做！，基本上就是一天一套，做完立刻对答案，整理。
11月：开始做模拟题，也是一天一套，做完对答案，整理。
12月：隔一天做一套模拟题保持手感，间隔的一天看过去的错题，这里插一嘴，最好在整个的复习过程中准备一个错题本，记录错题，这样可以在后面省去很多时间。
时间安排：每天的上午学习数学，起码要3个小时吧。具体时间自己安排
英语一
暑假前每天抽空背单词，不要间断，时间不必固定。暑假我开始做真题，先是每天两篇阅读或者完形，做的是张剑的黄皮书。完形只做一遍，做完所有阅读后（留了5份后期用），开始二刷，重做所有阅读。九月以后开始着手翻译和新型题。英语我基本上没看视频课（除了翻译和写作），完形和阅读都是自己做看答案和解析摸索，做到后期就技巧什么的基本就会了。当然看看老师的阅读技巧课也会很有帮助。翻译看的是唐静，写作看了点王江涛后来就没看了，隔了段时间又看的石雷鹏。新型题认真研究，找到方法，一定重视。作文模版大概背了石雷鹏的，以及王江涛那本作文书里的一些模板。作文一定要练习，我后期用王江涛和何凯文的作文书练手。单词别忘了还是要过一过。英语用真题就够了，虽然考前我也买了张剑的模拟卷做了两三套。考前一段时间用留下的真题模拟检测。真题的阅读一定要精读，尝试自己将每一篇文章翻译。完型性价比较低，可以少花点时间。新型题也很重要，可以做两遍找找规律，熟练之后容易做全对。翻译平时练习的时候一定要完整写下来，哪怕不会也要猜上去。英语单词我用的是墨墨背单词软件。考场上我的做题顺序是阅读→新型题→完型→翻译→作文。
政治
政治的确不必太早开始，我应该是八月开始看的。暑假开始每天抽一个小时看徐涛的视频，对着肖秀荣的精讲精练。看完视频后开始做肖秀荣的1000题。然后又看了遍精讲精练，二刷1000题（买了本新的），再看一遍精讲精练。然后买了腿姐的冲刺背诵手册，背了大概有七八遍，选择题必备，也可以选择徐涛的背诵手册。背手册同时在刷模拟题，肖8，徐涛8套卷，腿姐4套卷，肖4。肖四肖八一定认认真真对待，肖八大题看熟，不用背诵。考前二十多天一定要给政治留好时间，肖四一出版立马开始背诵大题，每天背，四份卷子的大题一定要背会。我用的是小白考研整理的肖四背诵版。至于时政，把每份模拟卷的时政记牢，也可以看看肖老师的时政书或者一些公众号整合的时政。
专业课：
哈工大初试考的是803信号与系统和数电两门，专业是通信工程或者电子信息的同学应该都学会这两门专业基础课。但是到考研时候已经离本科学习时太久，基本又是需要从头开始，深入，细则的学习两门专业课。
我是从5月开始学的专业课，复习前也找了研一学长咨询了很多专业课备考，学长很推荐信息通信Jenny老师，我也先b站看了很多Jenny老师分享的专业课视频，专业课讲解透彻，清晰，听课收获很大，而且老师信号和数电都教，免去很多麻烦，准备开始专业课的时候就果断参加博睿泽信息通信Jenny老师的哈工大辅导。资料什么一应俱全，试卷和答案，讲义等等都是打印版，没有任何手写内容，质量很好，也节省了很多收集资料的时间，一步到位什么都有了。
信号与系统相对复习轻松一点，理论强，有严密的思路和过程，直接更Jenny老师课程感觉很快就是上手真题，Jenny老师课程安排非常合理，每次课从知识点引入到数学模型推导证明，到物理意义的深入讲解，再到考研怎么去解题，运用整合在一起，非常高效，有条件建议直接跟Jenny老师课程复习，事半功倍，边学边做，现学现用，每次课后再做辅导班精选针对本次课后测评题，非常高效，发现问题及时打磨不足。跟着老师课程到暑期，参考模考测评，总结第一遍复习得失和差距，九月做完辅导课测评题目。后刷真题。真题刷三遍，两本课本要深入细致看结合老师课程会有更深里领悟。就是重复真题和辅导课精选题目直到考试为止。 考完专业课我感觉信号这块内容应该是可以全对，老师课程要求要高于考研，感觉还是有余地。
数字逻辑电路是应该是要比信号与系统考的难一些的，里面有挺多设计题问题，所以他考的知识要比我们本科学的东西要难，也要更灵活，而且设计题丢分会非常容易，一个小错误可能导致一分不得。数电复习也不像信号理论性强，做题对错心里基本都有数，设计题设计方法没有唯一性，最终设计对错不容易判断。数电的复习大家要尤为上心。能否130+数电是关键。数电复习时候先过了一下书，感觉没有什么头绪，还是直接跟Jenny老师数电课程，老师知识点，设计综合题，分析题等都整理的很好，知识点结合题目实战，对于数电复习更有效率。还是啰嗦一句，Jenny老师的课程还是很推荐。
这一年的复习感觉时间过得很快，也许就是天天都有明确的目标，都有要做的事情，考研虽然辛苦，但是在解决了自己以前没有解决的问题时，还是有一点点成就感，积少成多，自然就不会太焦虑了。希望大家也可以好好备战，顺利上岸。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd1ffbee40518819b5948902f0e342e/" rel="bookmark">
			跳跃游戏，经典算法实战。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆作者简介，普修罗双战士，一直追求不断学习和成长，在技术的道路上持续探索和实践。
🏆多年互联网行业从业经验，历任核心研发工程师，项目技术负责人。
🎉欢迎 👍点赞✍评论⭐收藏
🔎 算法领域知识 🔎
链接专栏分发糖果算法专栏买卖股票的最佳时机算法专栏跳跃游戏算法专栏 经典算法题 之 买卖股票的最佳时机
题目如下：
给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
示例 1：
输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2：
输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示：
1 &lt;= nums.length &lt;= 1040 &lt;= nums[i] &lt;= 105 解答这道题，可以使用 贪心算法 进行解决。
为了判断是否能够到达最后一个下标，我们可以使用贪心算法的思想来实现。贪心算法的基本思想是每一步都选择当前能够跳跃最远的位置。
具体实现逻辑如下：
初始化一个变量 maxPosition 为 0，表示当前能够跳跃的最远位置。遍历数组 nums，对于当前位置 i，判断是否超过了当前能够跳跃的最远位置 maxPosition，如果超过了，则说明无法到达最后一个下标，返回 false。更新 maxPosition 为当前位置 i 和当前位置能够跳跃的最大长度之和中的较大值。如果最后 maxPosition 大于等于数组的最后一个下标（即 nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dd1ffbee40518819b5948902f0e342e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2bfad6cc2f8efce27654051b55761c1/" rel="bookmark">
			MongoDB之Change Stream实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 Chang Streams Change Stream 指数据的变化事件流，MongoDB 从 3.6 版本开始提供订阅数据变更的功能。
Change Stream 是 MongoDB 用于实现变更追踪的解决方案，类似于关系数据库的触发器，但原理不完全相同：
Change Stream触发器触发方式异步同步（事务保证）触发位置应用回调事件数据库触发器触发次数每个订阅事件的客户端1次（触发器)故障恢复从上次断点重新触发事务回滚 Change Stream 的实现原理 Change Stream 是基于 oplog 实现的，提供推送实时增量的推送功能。它在 oplog 上开启一个 tailable cursor 来追踪所有复制集上的变更操作，最终调用应用中定义的回调函数。
被追踪的变更事件主要包括：
insert/update/delete：插入、更新、删除；drop：集合被删除；rename：集合被重命名；dropDatabase：数据库被删除；invalidate：drop/rename/dropDatabase 将导致 invalidate 被触发， 并关闭 change stream； 如果只对某些类型的变更事件感兴趣，可以使用使用聚合管道的过滤步骤过滤事件：
var cs = db.user.watch([{ $match:{operationType:{$in:["insert","delete"]}} }]) Change Stream会采用 "readConcern：majority"这样的一致性级别，保证写入的变更不会被回滚。
因此：
未开启 majority readConcern 的集群无法使用 Change Stream；当集群无法满足 {w: “majority”} 时，不会触发 Change Stream（例如 PSA 架构 中的 S 因故障宕）。 MongoShell 测试
窗口 1：
db.user.watch([],{maxAwaitTimeMS:1000000}).pretty() 窗口 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2bfad6cc2f8efce27654051b55761c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bb724be11e14abe0e6be17777258476/" rel="bookmark">
			模型评估：A/B测试的陷阱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 互联网公司中，A/B测试是验证新模块、新功能、新产品是否有效；新算法、新模型的效果是否有提升；新设计是否受到用户欢迎；新更改是否影响用户体验的主要测试方法。在机器学习领域中，A/B测试是验证模型最终效果的主要手段。
1. 在对模型进行过充分的离线评估之后，为什么还要进行在线A/B测试？
离线评估无法完全消除模型过拟合的影响，因此，得出的离线评估结果无法完全替代线上评估结果。离线评估结果无法完全还原线上的工程环境。一般来讲，离线评估往往不会考虑线上环境的延迟、数据丢失、标签数据缺失等情况。因此，离线评估的结果是理想工程环境下的结果。线上系统的某些商业指标在离线评估中无法计算。离线评估一般是针对模型本身进行评估，而与模型相关的其他指标，特别是商业指标，往往无法直接获得。比如，上线了新的推荐算法，离线评估往往关注的是ROC曲线，P-R曲线等的改进，而线上评估可以全面了解该推荐算法带来的用户点击率、留存时长、PV访问量等的变化。这些都要由A/B测试来进行全面的评估。 2. 如何进行线上A/B测试？
进行A/B测试的主要手段是进行用户分桶，即将用户分成实验组和对照组，对实验组的用户施以新模型，对对照组的用户施以旧模型。在分桶的过程中，要注意样本的独立性和采样方式的无偏性，确保同一个用户每次只能分到同一个桶中。在分桶过程中所选取的user_id需要是一个随机数，这样才能保证桶中的样本是无偏的。 3. 如何划分实验组和对照组？
H公司的算法工程师们最近针对系统中的“美国用户”研发了一套全新的视频推荐模型A，而目前正在使用的针对全体用户的推荐模型是B。在正式上线之前，工程师们希望通过A/B测试来验证新推荐模型的效果。下面有三种实验组和对照组的划分方法，请指出哪种划分方法是正确的？
根据user_id（user_id完全随机生成）个位数的奇偶性将用户划分为实验组和对照组，对实验组施以推荐模型A，对照组施以推荐模型B；将user_id个位数为奇数且为美国用户的作为实验组，其余用户为对照组；将user_id个位数为奇数且为美国用户的作为实验组，user_id个位数为偶数的用户作为对照组。 上述三种A/B测试的划分方法都不正确。我们用包含关系图来说明三种划分方法，如图2.4所示。
方法1（见图2.4(a））没有区分是否为美国用户，实验组和对照组的实验结果均有稀释；方法2（见图2.4(b））的实验组选取无误，并将其余所有用户划分为对照组，导致对照组的结果被稀释；方法3（见图2.4(c））的对照组存在偏差。正确做法（见图2.4(d））是将所有美国用户根据user_id个位数划分为实验组和对照组，分别施以模型A和B，才能够验证模型A的效果。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3aeb784dc8e1689351ba12184eea6a/" rel="bookmark">
			Uncaught ReferenceError: videojs is not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 项目背景：
开发 vue 项目时，调试时浏览器前端控制台 出现红色 报错信息：
Uncaught ReferenceError: videojs is not defined 问题描述 遇到的问题：
开发 vue 项目时， 浏览器控制台出现如下所示的 报错信息：
EasyPlayer-component.min.js?7987:18 Uncaught ReferenceError: videojs is not defined at Object.UTjk (EasyPlayer-component.min.js?7987:18) at M (EasyPlayer-component.min.js?7987:1) at Object.ytBe (EasyPlayer-component.min.js?7987:27) at M (EasyPlayer-component.min.js?7987:1) at Object.1wJc (EasyPlayer-component.min.js?7987:1) at M (EasyPlayer-component.min.js?7987:1) at Object.0 (EasyPlayer-component.min.js?7987:1) at M (EasyPlayer-component.min.js?7987:1) at +8RM (EasyPlayer-component.min.js?7987:1) at eval (EasyPlayer-component.min.js?7987:1) 原因分析及解决方法： 分析：
在 Vue 项目中出现 “Uncaught ReferenceError: videojs is not defined” 错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3aeb784dc8e1689351ba12184eea6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c2890a532b4cb4690a13e762d79e58/" rel="bookmark">
			行为型设计模式——责任链模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		责任链模式 在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的击鼓传花游戏等。
定义：
又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。 用大白话讲，就是一个任务，有多个处理类可以进行处理，但是多个处理类只有一个处理类可以处理它，这需要根据这个任务类的本身情况决定，因此需要将这个任务按照处理类的顺序进行处理，我们只需要将这个任务丢给第一个处理类即可返回结果，因为它如果无法处理会自动转交给下一个更强的处理类，一直找到合适的处理类为止，否则返回null。这就是责任链模式。
职责链模式主要包含以下角色:
抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。 案例实现 现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。
类图如下：
代码 首先定义请假条类，包括请假人、请假天数、请假内容：
public class LeaveRequest { private String name; // 姓名 private int num; // 请假天数 private String content; // 请假内容 public LeaveRequest(String name, int num, String content) { this.name = name; this.num = num; this.content = content; } public String getName() { return name; } public int getNum() { return num; } public String getContent() { return content; } } 接着定义处理者类，小组长、部门经理、总经理都是继承处理者类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c2890a532b4cb4690a13e762d79e58/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<span class="pagination__item pagination__item--current">1/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/2/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>