<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库之三大范式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库之三大范式" />
<meta property="og:description" content="1.1 第一范式(1st NF) 第一范式主要是确保数据表中每个字段的值必须具有原子性,也就是说数据表中每个字段的值不可再次拆分的最小数据单元
举例1：
假设一家公司要存储员工的姓名和联系方式。它创建一个如下表：
该表不符合 1NF ，因为规则说“表的每个属性必须具有原子（单个）值”，lisi和zhaoliu员工的
emp_mobile 值违反了该规则。为了使表符合 1NF ，我们应该有如下表数据：
举例2：
user 表的设计不符合第一范式
其中，user_info字段为用户信息，可以进一步拆分成更小粒度的字段，不符合数据库设计对第一范式的 要求。将user_info拆分后如下：
举例3：
属性的原子性是 主观的 。例如，Employees关系中雇员姓名应当使用1个（fullname）、2个（firstname和lastname）还是3个（firstname、middlename和lastname）属性表示呢？答案取决于应用程序。如果应用程序需要分别处理雇员的姓名部分（如：用于搜索目的），则有必要把它们分开。否则，不需要。
表1：
表2：
1.2 第二范式(2st NF) 第二范式要求,在满足第一范式的基础上,还要&#34;满足数据表中的每一条数据记录,都是可唯一标识的(主键),而且所有非主键字段,都必须完全依赖主键,不能只依赖主键的一部分&#34;,如果知道主键的所有属性的值,就可以检索到任何元组(行)的任何属性的值,(要求中的主键,其实可以拓展为候选键).
举例1：
成绩表 （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以“（学号，课程号）→成绩”就是 完全依赖关系 。
举例2：
比赛表 player_game ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这
里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：
(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)
但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：
(球员编号) → (姓名，年龄)
(比赛编号) → (比赛时间, 比赛场地)
对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？
数据冗余 ：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛
也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。插入异常 ：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没
法插入。删除异常 ：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删
除掉。更新异常 ：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b43a07f8a807f22de12bcb2c72bc081d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-30T15:40:09+08:00" />
<meta property="article:modified_time" content="2022-08-30T15:40:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库之三大范式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="11_1st_NF_0"></a>1.1 第一范式(1st NF)</h3> 
<p>第一范式主要是确保数据表中每个字段的值必须具有原子性,也就是说数据表中每个字段的值不可再次拆分的最小数据单元</p> 
<p><strong>举例1：</strong><br> 假设一家公司要存储员工的姓名和联系方式。它创建一个如下表：<br> <img src="https://images2.imgbox.com/6e/3b/Wo7ptbUr_o.png" alt="在这里插入图片描述"><br> 该表不符合 1NF ，因为规则说“表的每个属性必须具有原子（单个）值”，lisi和zhaoliu员工的<br> emp_mobile 值违反了该规则。为了使表符合 1NF ，我们应该有如下表数据：<br> <img src="https://images2.imgbox.com/ce/02/MthLO0ON_o.png" alt="在这里插入图片描述"></p> 
<p><strong>举例2：</strong><br> user 表的设计不符合第一范式<br> <img src="https://images2.imgbox.com/b4/ce/rspt97F5_o.png" alt="在这里插入图片描述"></p> 
<p>其中，user_info字段为用户信息，可以进一步拆分成更小粒度的字段，不符合数据库设计对第一范式的 要求。将user_info拆分后如下：<br> <img src="https://images2.imgbox.com/54/19/hLxEnRL5_o.png" alt="在这里插入图片描述"></p> 
<p><strong>举例3：</strong><br> 属性的原子性是 主观的 。例如，Employees关系中雇员姓名应当使用1个（fullname）、2个（firstname和lastname）还是3个（firstname、middlename和lastname）属性表示呢？答案取决于应用程序。如果应用程序需要分别处理雇员的姓名部分（如：用于搜索目的），则有必要把它们分开。否则，不需要。<br> 表1：<br> <img src="https://images2.imgbox.com/32/a9/UEH1xBwV_o.png" alt="在这里插入图片描述"><br> 表2：<br> <img src="https://images2.imgbox.com/fc/ba/2y39AIWP_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="12_2st_NF_25"></a>1.2 第二范式(2st NF)</h3> 
<p>第二范式要求,在满足第一范式的基础上,还要"满足数据表中的每一条数据记录,都是可唯一标识的(主键),而且所有非主键字段,都必须完全依赖主键,不能只依赖主键的一部分",如果知道主键的所有属性的值,就可以检索到任何元组(行)的任何属性的值,(要求中的主键,其实可以拓展为候选键).</p> 
<p><strong>举例1：</strong><br> 成绩表 （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以“<em><strong>（学号，课程号）→成绩</strong></em>”就是 完全依赖关系 。</p> 
<p><strong>举例2：</strong><br> 比赛表 player_game ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这<br> 里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：<br> <em><strong>(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</strong></em><br> 但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：<br> <em><strong>(球员编号) → (姓名，年龄)<br> (比赛编号) → (比赛时间, 比赛场地)</strong></em></p> 
<p>对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？</p> 
<ol><li>数据冗余 ：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛<br> 也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。</li><li>插入异常 ：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没<br> 法插入。</li><li>删除异常 ：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删<br> 除掉。</li><li>更新异常 ：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调<br> 整，否则就会出现一场比赛时间不同的情况。</li></ol> 
<p>为了避免出现上述的情况，我们可以把球员比赛表设计为下面的三张表。<br> <img src="https://images2.imgbox.com/03/bd/v7pof88n_o.png" alt="在这里插入图片描述"><br> 这样的话，每张数据表都符合第二范式，也就避免了异常情况的发生。<br> <img src="https://images2.imgbox.com/31/63/VYoxta0u_o.png" alt="在这里插入图片描述"><br> <strong>举例2：</strong><br> 定义了一个名为 Orders 的关系，表示订单和订单行的信息：<br> <img src="https://images2.imgbox.com/c2/fd/m12VY0WC_o.png" alt="在这里插入图片描述"></p> 
<p>违反了第二范式，因为有非主键属性仅依赖于候选键（或主键）的一部分。例如，可以仅通过orderid找到订单的 orderdate，以及 customerid 和 companyname，而没有必要再去使用productid。<br> 修改： Orders表和OrderDetails表如下，此时符合第二范式。<br> <img src="https://images2.imgbox.com/92/ee/46xNIavl_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>小结</strong>:第二范式(2NF）要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是一对多的关系。</p> 
</blockquote> 
<h3><a id="13_3st_NF_66"></a>1.3 第三范式(3st NF)</h3> 
<p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键 字段不能依赖于其他非主键字段。(即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键c的情况，即存 在"A→B→C"”"的决定关系）通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。<br> 这里的主键可以拓展为候选键。</p> 
<p><strong>举例1：</strong><br> 部门信息表 ：每个部门有部门编号（dept_id）、部门名称、部门简介等信息。<br> 员工信息表 ：每个员工有员工编号、姓名、部门编号。列出部门编号后就不能再将部门名称、部门简介<br> 等与部门有关的信息再加入员工信息表中。<br> 如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p> 
<p><strong>举例2：</strong><br> 商品类别名称依赖于商品类别编号，不符合第三范式。<br> <img src="https://images2.imgbox.com/f1/f8/f8fdYNsa_o.png" alt="在这里插入图片描述"></p> 
<p>商品类别名称依赖于商品类别编号，不符合第三范式。<br> 修改：<br> 表1：符合第三范式的 商品类别表 的设计<br> <img src="https://images2.imgbox.com/59/90/9g9amMEz_o.png" alt="在这里插入图片描述"><br> 表2：符合第三范式的 商品表 的设计<br> <img src="https://images2.imgbox.com/ec/6e/dsSITSjP_o.png" alt="在这里插入图片描述"><br> 举例3：<br> 球员player表 ：球员编号、姓名、球队名称和球队主教练。现在，我们把属性之间的依赖关系画出<br> 来，如下图所示：<br> <img src="https://images2.imgbox.com/0f/89/k1s54cME_o.png" alt="在这里插入图片描述"><br> 你能看到球员编号决定了球队名称，同时球队名称决定了球队主教练，非主属性球队主教练就会传递依<br> 赖于球员编号，因此不符合 3NF 的要求。<br> 如果要达到 3NF 的要求，需要把数据表拆成下面这样：<br> <img src="https://images2.imgbox.com/d8/40/GGtiXv8N_o.png" alt="在这里插入图片描述"><br> <strong>举例4：</strong><br> 修改第二范式中的举例3。<br> 此时的Orders关系包含 orderid、orderdate、customerid 和 companyname 属性，主键定义为 orderid。<br> customerid 和companyname均依赖于主键——orderid。例如，你需要通过orderid主键来查找代表订单中客户的customerid，同样，你需要通过 orderid 主键查找订单中客户的公司名称（companyname）。<br> 然 而， customerid和companyname也是互相依靠的。为满足第三范式，可以改写如下：<br> <img src="https://images2.imgbox.com/c4/b8/2fmmu4Ow_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9f/41/b5odqe37_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/117a1e69a2056763ed5e0e798729b3c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">k8s(4)-Service三种类型以及内外网络访问Pod</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b698fd9c344bd7ed8f0a7f7ab2ccd3f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NMOS和PMOS管 电流方向和应用电路</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>