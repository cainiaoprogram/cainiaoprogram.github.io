<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java   checked 异常 和 RuntimeException(运行时异常) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java   checked 异常 和 RuntimeException(运行时异常)" />
<meta property="og:description" content="目录
一、运行时异常 1、什么是RuntimeExceptioin 2、运行时异常的特点 3、如何运用运行时异常 二、运行时异常和ckecked异常的区别 1、机制上 2、逻辑上 一、运行时异常
1、什么是运行时异常
程序在运行过程中出现的异常，RumtimeException 是 Exception 的一个子类
我们可以查看Java API 文档
贴张示意图
2、运行异常的特点
一般来说，我们在方法体内出现异常，我们用throw 关键字 将 异常对象或 异常对象的引用抛出，如果当前方法无法处理异常，那么必须在方法的参数列表后方法体前 必须 用 throws 声明异常所属类，交给调用者去处理。但是RuntimeException是非常特殊的子类，你可以不用throw和throws，哪怕你throw了，也没必要thtows，即使你throws了，调用者也没必要try-catch
1&gt; 如果在函数内容中抛出该类异常或其子类异常，函数上可以不用声明，编译一样通过
2&gt; 如果在函数上声明该异常，调用者可以不同处理(try-catch)，编译一样通过
为什么不用声明 ？
之所以不用在函数上声明，是因为不需要让调用者处理，当该异常发生，希望程序停止，因为在运行时，出现了无法继续运算的情况，希望程序停止后由程序员对代码进行修正。
3、如何运用运行时异常
自定义异常时，如果该异常的发生，无法继续进行运行，就让自定义异常类继承RuntimeException
再贴一张简单示意图 Object 中的 wait（long timeout）方法，继续查看Java API 文档 对该方法的描述
二、运行时异常和ckecked异常的区别
对于异常分两种：检查异常和非检查异常(运行时异常)
检查异常 : 编译时被检测的异常 （throw后，方法有能力处理就try-catch处理，没能力处理就必须throws）。编译不通过，检查语法(其实就是throw和throws的配套使用)。
运行时异常 : 编译时不被检查的异常(运行时异常。RuntimeException及其子类)。编译通过。
1、机制上
主要表现在以下两个方面 :
（1）如何定义方法
（2）如何处理抛出的异常
运行时异常，不需要用throws 声明抛出 异常对象所属类，也可以不用throw 抛出异常对象或异常引用。对于调用该方法，也不需要放于 try-catch 代码块中。（为什么 ？ 如果你捕获它，就会冒这么一个风险：程序代码错误被掩盖在运行中无法察觉)
而检查异常 : 一旦 用throw 抛出异常，如果当前方法 可处理异常，那么直接在该方法内用try-catch 去处理。如果当前方法不具备处理该异常的能力，那么就必须在 参数列表后方法体前用 throws 声明 异常 所属类，交给调用该方法的 调用者(方法) 去处理 。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/09f7439ed8e5640acf2108176999f0b1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-04T23:34:22+08:00" />
<meta property="article:modified_time" content="2017-08-04T23:34:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java   checked 异常 和 RuntimeException(运行时异常)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>目录</p> 
<pre><code>   一、运行时异常
   
     1、什么是RuntimeExceptioin
     2、运行时异常的特点
     3、如何运用运行时异常
     
   二、运行时异常和ckecked异常的区别
   
     1、机制上
     2、逻辑上  
      
</code></pre> 
<p>一、运行时异常</p> 
<p>1、什么是运行时异常</p> 
<p>程序在运行过程中出现的异常，RumtimeException 是 Exception 的一个子类<br> 我们可以查看<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" rel="nofollow">Java API 文档</a></p> 
<p>贴张示意图<br> <img src="https://images2.imgbox.com/62/23/X3dhNut4_o.png" alt="这里写图片描述"></p> 
<p>2、运行异常的特点</p> 
<p>一般来说，我们在方法体内出现异常，我们用throw 关键字 将 异常对象或 异常对象的引用抛出，如果当前方法无法处理异常，那么必须在方法的参数列表后方法体前 必须 用 throws 声明异常所属类，交给调用者去处理。但是RuntimeException是非常特殊的子类，你可以不用throw和throws，哪怕你throw了，也没必要thtows，即使你throws了，调用者也没必要try-catch</p> 
<p>1&gt; 如果在函数内容中抛出该类异常或其子类异常，函数上可以不用声明，编译一样通过</p> 
<p>2&gt; 如果在函数上声明该异常，调用者可以不同处理(try-catch)，编译一样通过</p> 
<p><strong>为什么不用声明 ？</strong></p> 
<p><strong>之所以不用在函数上声明，是因为不需要让调用者处理，当该异常发生，希望程序停止，因为在运行时，出现了无法继续运算的情况，希望程序停止后由程序员对代码进行修正。</strong></p> 
<p>3、如何运用运行时异常</p> 
<p>自定义异常时，如果该异常的发生，无法继续进行运行，就让自定义异常类继承RuntimeException</p> 
<p>再贴一张简单示意图 Object 中的 wait（long timeout）方法，继续查看<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" rel="nofollow">Java API 文档</a> 对该方法的描述<br> <img src="https://images2.imgbox.com/63/26/Tl5TMYBJ_o.png" alt="这里写图片描述"></p> 
<p>二、运行时异常和ckecked异常的区别</p> 
<p>对于异常分两种：检查异常和非检查异常(运行时异常)</p> 
<p><strong>检查异常</strong> : 编译时被检测的异常 （throw后，方法有能力处理就try-catch处理，没能力处理就必须throws）。编译不通过，检查语法(其实就是throw和throws的配套使用)。</p> 
<p><strong>运行时异常</strong> : 编译时不被检查的异常(运行时异常。RuntimeException及其子类)。编译通过。</p> 
<p>1、机制上</p> 
<p>主要表现在以下两个方面 :<br> （1）如何定义方法<br> （2）如何处理抛出的异常</p> 
<p>运行时异常，不需要用throws 声明抛出 异常对象所属类，也可以不用throw 抛出异常对象或异常引用。对于调用该方法，也不需要放于 try-catch 代码块中。（为什么 ？ 如果你捕获它，就会冒这么一个风险：程序代码错误被掩盖在运行中无法察觉)</p> 
<p>而检查异常 : 一旦 用throw 抛出异常，如果当前方法 可处理异常，那么直接在该方法内用try-catch 去处理。如果当前方法不具备处理该异常的能力，那么就必须在 参数列表后方法体前用 throws 声明 异常 所属类，交给调用该方法的 调用者(方法) 去处理 。</p> 
<p>2、逻辑上</p> 
<p>从逻辑的角度来看， checked 异常 和 RuntimeException 有着不同的使用目的，检查性异常 用来指示 一种调用方能够直接处理的异常情况(例如: 用户输入错误，程序可以直接捕获并处理，提示用户输入错误), 而RuntimeException 是用来指 调用方 本身无法 处理或回复 的程序错误（例如，你封装个库给别人用，当别人调用你库中某个方法是，需要传入某些参数，如果用户传入的参数不合法，你自己没办法处理，那么刺客你抛出的就应该是运行时异常）。</p> 
<p><strong>我个人感觉，RuntimeException 跟OC 中的 断言(NSAlert) 有点像哦</strong>。</p> 
<p><strong>进一步思考</strong> ： 前面的知识点有降到，携带参数的构造方法既可以为对象赋初始值，还可以为对象 赋一个合理的值。例如，初始化一个长方形对象，用构造方法给定 width 和 length ，我们可以在构造方法里面判断 长 宽 值的合理性，但是如果此时你初始化这个对象成功后，你调用 求面积的方法，返回一个 值，那么这个值 是异常值。按照所学的知识，我们一般会在求面积的方法，判断值的合理性，如果不合理抛出异常。但是，反过来想，如果我一开始让你传入 的 width 和 length 就抛出异常呢，这个直接让你初始化对象不成功 是不是好点。因为你有可能不知道 我 求面积的方法是怎么实现的，就算我给你抛出异常，你也不知道如何处理。(通过这点，我们也了解到一个小知识点，构造方法也是可以抛出异常的，而且，抛出异常的类型通常是运行时异常)</p> 
<p><img src="https://images2.imgbox.com/4e/b8/zV7uYrIb_o.jpg" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca9b4047e0fb4b53eb57297329428a24/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在linux设置回收站 - 防止失误操作造成数据清空,并定期清理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/83c60a48159b9e968aa5a787dc980869/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一个移植十分方便的malloc函数族的实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>