<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络(二)---物理层与数据链路层 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机网络(二)---物理层与数据链路层" />
<meta property="og:description" content="文章目录 物理层概述物理层的作用传输介质信道的基本概念分用-复用技术 数据链路层概述封装成帧透明传输差错检测奇偶校验码循环冗余校验码（CRC） 最大传送单元MTU以太网协议详解MAC地址以太网协议 物理层概述 物理层的作用 如果是OSI七层模型的话，物理层是处于最底层的位置。对于TCP/IP四层模型，它是属于最底层的网络接口层。物理层的作用是
连接不同的物理设备（比如路由器到计算机通过网线进行连接）传输比特流（比特流就是0、1这样的高低电平，或者说是数字信号） 传输介质 连接不同物理设备的介质，包括有线介质和无线介质，其中有线介质包括
双绞线、同轴电缆、光纤、比特流
信道的基本概念 信道是往一个方向传递信息的媒体一条通信电路往往包含一个接收信道和一个发送信道因为发送信息和接收信息的方向不一样，所有这里有两个信道 一条通信线路，既发送又接收，如果引起了冲突会怎么办？
这个问题，其实物理层已经解决了。根据信道的不同，通信电路可以分成
单工通信信道半双工通信信道全双工通信信道 单工通信信道
只能一个方向通信，没有反方向反馈的信道有限电视、无线电收音机等等，都属于单工通信信道（一方发送，另外一方只能接收） 半双工通信信道
双方都可以发送和接收信息不能双方同时发送，也不能同时接收 全双工通信信道
双方都可以同时发送和接收消息网线这些都是全双工通信信道 分用-复用技术 前边介绍到，如果两个计算机进行通信，那么在他们之间就会有一条通信线路，在这条通信电路中，可能用发送信道和接收信道。考虑一种情况，如果有很多的计算机，他们都需要连接，这个时候就有很多的发送信道和接收信道，并且在很多时候，他们也并不是处于活跃的状态。这就会导致信道的利用率不高。因此就提出了分用-复用的技术，用来提升信道的利用率
分用-复用技术是如何提高信道的利用率？
多个计算机连接复用器，另一侧的计算机连接分用器。通过复用器和分用器这两个设备就可以共享一条发送信道以及接收信道，这样就可以大大提升信道的利用率。
注意：如果有很多的计算机，很频繁的通过信道收发信息，会导致信道拥塞
数据链路层概述 对于物理层，主要是进行不同设备的连接，以及传输比特流。下边是对数据链路层进行介绍，首先数据链路层是位于OSI七层模型的倒数第二层，也就是物理层的上边一层，位于TCP/IP四层模型的网络接口层
数据链路层主要是解决了以下三个问题
封装成帧透明传输差错检测 封装成帧 “帧”是数据链路层数据的基本单位（就好比比特位是物理层数据的单位）发送端在网络层的一段数据前后添加特定标记形成“帧”接收端根据前后特定标记识别出“帧” 下边是通过图示来理解封装成帧的过程
首先在网络层会将一些“IP数据报”传输到数据链路层数据链路层在接收到这个数据的时候，把它看做是数据帧的数据，然后在数据的前后加上特定的标记，表示这是数据帧的头部和尾部从帧首部到帧尾部就是数据帧的长度 而数据帧在物理层表现的就是很多的0和1组成的比特流。上边的提到的帧首部和帧尾部，都是特定的控制字符（特定比特流）
帧首部的比特流是：SOH：00000001（SOH是控制字符）
帧尾部的比特流是：EOT：00000100
如果帧数据中也恰好有帧首部或帧尾部一样的比特流该怎么办
这个就需要透明传输
透明传输 通过透明传输就可以解决上边提到的问题。在介绍透明传输之前，先了解一下什么是“透明”。“透明”在计算机领域是非常重要的一个术语。
比如我们平时在设计一个API的时候，我们会常说，你这个API设计的足够良好的话，那么底层的这个API的操作，对API的调用方是透明的。再比如说，数据链路层和物理层，对于数据链路层来说，物理层它所做的工作都是透明的，物理层只需要提供一些API给数据链路层去使用就可以了。说白了就是：一种实际存在的事务，却又看起来不存在一样。把透明这个概念使用在数据链路层就是，控制字符在帧数据中，但是要当做不存在的去处理
那么数据链路层是怎样做到，即使控制字符位于帧数据中，它还是可以装作不知道的去处理的呢？
假设此时帧数据中有一个帧尾部的控制字符，如果数据链路层没有使用透明传输，那么接收端很可能就把位于帧数据中的控制字符，看做是数据帧的尾部，从而识别出错误的帧。因此数据链路层就会对帧数据中的控制字符进行特殊处理
处理的方法就是在控制字符前边加转义字符，下边的ESC就是转义字符。这样的话，接收端在接收到数据帧之后，它就会先判断帧数据中的控制字符前边是否存在转义字符，如果存在，就不会把这个控制字符当做一个控制字符。那如果帧数据中也出现了转义字符怎么办？把转义字符重新转义一次即可
其实我们在平时的编程当中，“\”一般看做是转义字符。假设此时要输出“\”，那么在这两个反斜杠前边都加上转义字符即可，表示这两个都不是转义字符&#34;\&#34;
差错检测 物理层只管传输比特流，无法控制是否出错（如果物理层传输比特流的过程中受到了一些干扰，比如闪电。就会影响比特流的传输，物理层是察觉不到的）
数据链路层负责起“差错检测”的工作，主要包含两个部分：
奇偶校验码循环冗余校验码（CRC） 奇偶校验码 奇偶校验码是一种非常简单的检测比特流中是否有传输错误的方法。该方法是通过在比特流的尾部添加一位比特位来检测比特流是否有出错。假设测试要传输“00110010”这个8位的比特流
首先在这个比特流后边加“1”这个比特位当接收端接收到这个比特流之后，就会根据后边加的那个比特位来检测该比特流是否有出错这个1是通过前边的8位比特流相加得到3，因为3是奇数，所以就在这个8位的比特流后边加上1，来表示这是一个奇偶校验的位 如果我们要传输“00111010”这个比特流，那么后边添加的比特位就应是“0”，因为这8位相加的结果是4，是个偶数。下边就看一下，如何通过这个奇偶检验码来检测错误。假设此时要传输“00110010”这个比特流，那么需要在尾部添加“1”这个比特位。假设在传输的过程中发生了错误，接收端收到的是“00010010”，此时接收端会通过奇偶校验码来进行校验，接收端计算的奇偶校验码是“0”，不等于“1”，说明这个比特流在传输的过程中出现了差错
相信聪明的你已经看出来，这里边有一个局限性，假设现在还是要传输“00110010”，在尾部添加的比特位是“1”。假设此时接收端接收到的是“00000010”，接收端经过运算之后，发现后边的奇偶校验位应该是“1”，而恰好此时，最后一位校验位就是“1”，就会认为数据没问题，而实际上数据是有问题的。所以当比特流出现两位错误，奇偶校验码就检测不到错误。
循环冗余校验码（CRC） 循环冗余校验码是一种广泛使用的差错检测的算法
它是一种根据传输或保存的数据而产生固定位数校验码的方法（固定位数，可能是1位，也可能是多位）它可以检测数据传输或者保存后可能出现的错误它的过程和奇偶校验码有些类似它首先计算生成一些数字，并且附加到数据后边当接收端接收到数据之后，就会根据附加到后边的数字，来判断接收到的数据是否有出错 CRC主要有三个步骤
选定一个用于校验的多项式G(x)，并在数据尾部添加r个0将添加r个0后的数据，使用模“2”除法除以多项式的位串将得到的余数填充在原数据r个0的位置，得到可校验的位串 下边直接例子
使用CRC计算“101001”的可校验位串
下边就根据上边提到的计算CRC的三步来计算
（1）首先是选定一个用于校验的多项式G(x)，并在数据尾部添加r个0
什么是G(x)？
G(x)可能是下边这样的一个多项式
位串就是将多项式的常数项提取出来，得到了位串1101。在数据尾部添加r个0，其实就是在尾部添加最高阶个0。因此在“101001”后边添加3个0就得到了“101001000”
（2）将添加r个0后的数据，使用模“2”除法除以多项式的位串" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/931e1cebc75be183487139faccde7fa6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-17T22:39:03+08:00" />
<meta property="article:modified_time" content="2021-01-17T22:39:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络(二)---物理层与数据链路层</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_3" rel="nofollow">物理层概述</a></li><li><ul><li><ul><li><a href="#_4" rel="nofollow">物理层的作用</a></li><li><a href="#_12" rel="nofollow">传输介质</a></li><li><a href="#_18" rel="nofollow">信道的基本概念</a></li><li><a href="#_48" rel="nofollow">分用-复用技术</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_60" rel="nofollow">数据链路层概述</a></li><li><ul><li><ul><li><a href="#_72" rel="nofollow">封装成帧</a></li><li><a href="#_94" rel="nofollow">透明传输</a></li><li><a href="#_108" rel="nofollow">差错检测</a></li><li><ul><li><a href="#_116" rel="nofollow">奇偶校验码</a></li><li><a href="#CRC_128" rel="nofollow">循环冗余校验码（CRC）</a></li></ul> 
     </li><li><a href="#MTU_168" rel="nofollow">最大传送单元MTU</a></li><li><a href="#_182" rel="nofollow">以太网协议详解</a></li><li><ul><li><a href="#MAC_196" rel="nofollow">MAC地址</a></li><li><a href="#_203" rel="nofollow">以太网协议</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr size='1"' color="#000000"> 
<h3><a id="_3"></a>物理层概述</h3> 
<h5><a id="_4"></a>物理层的作用</h5> 
<p>如果是OSI七层模型的话，物理层是处于最底层的位置。对于TCP/IP四层模型，它是属于最底层的网络接口层。物理层的作用是</p> 
<ul><li>连接不同的物理设备（比如路由器到计算机通过网线进行连接）</li><li>传输比特流（比特流就是0、1这样的高低电平，或者说是数字信号）</li></ul> 
<h5><a id="_12"></a>传输介质</h5> 
<p>连接不同物理设备的介质，包括有线介质和无线介质，其中有线介质包括<br> 双绞线、同轴电缆、光纤、比特流</p> 
<h5><a id="_18"></a>信道的基本概念</h5> 
<ul><li>信道是往一个方向传递信息的媒体</li><li>一条通信电路往往包含一个接收信道和一个发送信道</li><li>因为发送信息和接收信息的方向不一样，所有这里有两个信道</li></ul> 
<p>一条通信线路，既发送又接收，如果引起了冲突会怎么办？<br> <img src="https://images2.imgbox.com/8b/1c/sIWIFrmo_o.png" alt="在这里插入图片描述"><br> 这个问题，其实物理层已经解决了。根据信道的不同，通信电路可以分成</p> 
<ul><li>单工通信信道</li><li>半双工通信信道</li><li>全双工通信信道</li></ul> 
<p><strong>单工通信信道</strong></p> 
<ul><li>只能一个方向通信，没有反方向反馈的信道</li><li>有限电视、无线电收音机等等，都属于单工通信信道（一方发送，另外一方只能接收）</li></ul> 
<p><strong>半双工通信信道</strong></p> 
<ul><li>双方都可以发送和接收信息</li><li>不能双方同时发送，也不能同时接收</li></ul> 
<p><strong>全双工通信信道</strong></p> 
<ul><li>双方都可以同时发送和接收消息</li><li>网线这些都是全双工通信信道</li></ul> 
<h5><a id="_48"></a>分用-复用技术</h5> 
<p>前边介绍到，如果两个计算机进行通信，那么在他们之间就会有一条通信线路，在这条通信电路中，可能用发送信道和接收信道。考虑一种情况，如果有很多的计算机，他们都需要连接，这个时候就有很多的发送信道和接收信道，并且在很多时候，他们也并不是处于活跃的状态。这就会导致信道的利用率不高。因此就提出了<strong>分用-复用的技术</strong>，用来提升信道的利用率</p> 
<p>分用-复用技术是如何提高信道的利用率？</p> 
<p>多个计算机连接<strong>复用器</strong>，另一侧的计算机连接<strong>分用器</strong>。通过复用器和分用器这两个设备就可以共享一条发送信道以及接收信道，这样就可以大大提升信道的利用率。</p> 
<p><img src="https://images2.imgbox.com/38/f5/YxKnPLCi_o.png" alt="在这里插入图片描述"></p> 
<p>注意：如果有很多的计算机，很频繁的通过信道收发信息，会导致信道拥塞</p> 
<h3><a id="_60"></a>数据链路层概述</h3> 
<p>对于物理层，主要是进行不同设备的连接，以及传输比特流。下边是对数据链路层进行介绍，首先数据链路层是位于OSI七层模型的倒数第二层，也就是物理层的上边一层，<strong>位于TCP/IP四层模型的网络接口层</strong></p> 
<p><img src="https://images2.imgbox.com/cf/b8/rHeKyjFt_o.png" alt="在这里插入图片描述"></p> 
<p>数据链路层主要是解决了以下三个问题</p> 
<ul><li>封装成帧</li><li>透明传输</li><li>差错检测</li></ul> 
<h5><a id="_72"></a>封装成帧</h5> 
<ul><li>“帧”是数据链路层数据的基本单位（就好比比特位是物理层数据的单位）</li><li>发送端在网络层的一段数据前后添加特定标记形成“帧”</li><li>接收端根据前后特定标记识别出“帧”</li></ul> 
<p>下边是通过图示来理解封装成帧的过程</p> 
<ul><li>首先在网络层会将一些“IP数据报”传输到数据链路层</li><li>数据链路层在接收到这个数据的时候，把它看做是数据帧的数据，然后在数据的前后加上特定的标记，表示这是数据帧的头部和尾部</li><li>从帧首部到帧尾部就是数据帧的长度</li></ul> 
<p>而数据帧在物理层表现的就是很多的0和1组成的比特流。上边的提到的帧首部和帧尾部，都是特定的控制字符（特定比特流）</p> 
<p><strong>帧首部</strong>的比特流是：SOH：00000001（SOH是控制字符）<br> <strong>帧尾部</strong>的比特流是：EOT：00000100</p> 
<p><img src="https://images2.imgbox.com/0c/95/mEoLCAsk_o.png" alt="在这里插入图片描述"><br> 如果帧数据中也恰好有帧首部或帧尾部一样的比特流该怎么办<br> 这个就需要透明传输</p> 
<h5><a id="_94"></a>透明传输</h5> 
<p>通过透明传输就可以解决上边提到的问题。在介绍透明传输之前，先了解一下什么是“透明”。“透明”在计算机领域是非常重要的一个术语。</p> 
<p>比如我们平时在设计一个API的时候，我们会常说，你这个API设计的足够良好的话，那么底层的这个API的操作，对API的调用方是透明的。再比如说，数据链路层和物理层，对于数据链路层来说，物理层它所做的工作都是透明的，物理层只需要提供一些API给数据链路层去使用就可以了。说白了就是：<strong>一种实际存在的事务，却又看起来不存在一样。把透明这个概念使用在数据链路层就是，控制字符在帧数据中，但是要当做不存在的去处理</strong></p> 
<p>那么数据链路层是怎样做到，即使控制字符位于帧数据中，它还是可以装作不知道的去处理的呢？</p> 
<p>假设此时帧数据中有一个帧尾部的控制字符，如果数据链路层没有使用透明传输，那么接收端很可能就把位于帧数据中的控制字符，看做是数据帧的尾部，从而识别出错误的帧。<strong>因此数据链路层就会对帧数据中的控制字符进行特殊处理</strong><br> <img src="https://images2.imgbox.com/fe/d0/ujVtIKhW_o.png" alt="在这里插入图片描述"></p> 
<p>处理的方法就是在控制字符前边加<strong>转义字符</strong>，下边的<strong>ESC就是转义字符</strong>。这样的话，接收端在接收到数据帧之后，它就会先判断帧数据中的控制字符前边是否存在转义字符，如果存在，就不会把这个控制字符当做一个控制字符。那如果帧数据中也出现了转义字符怎么办？把转义字符重新转义一次即可<br> <img src="https://images2.imgbox.com/5c/d5/I7GXmf7e_o.png" alt="在这里插入图片描述"><br> 其实我们在平时的编程当中，“\”一般看做是转义字符。假设此时要输出“\”，那么在这两个反斜杠前边都加上转义字符即可，表示这两个都不是转义字符"\"</p> 
<h5><a id="_108"></a>差错检测</h5> 
<p>物理层只管传输比特流，无法控制是否出错（如果物理层传输比特流的过程中受到了一些干扰，比如闪电。就会影响比特流的传输，物理层是察觉不到的）</p> 
<p>数据链路层负责起“差错检测”的工作，主要包含两个部分：</p> 
<ul><li>奇偶校验码</li><li>循环冗余校验码（CRC）</li></ul> 
<h6><a id="_116"></a>奇偶校验码</h6> 
<p>奇偶校验码是一种非常简单的检测比特流中是否有传输错误的方法。该方法是通过在比特流的尾部添加一位比特位来检测比特流是否有出错。假设测试要传输“00110010”这个8位的比特流</p> 
<ul><li>首先在这个比特流后边加“1”这个比特位</li><li>当接收端接收到这个比特流之后，就会根据后边加的那个比特位来检测该比特流是否有出错</li><li>这个1是通过前边的8位比特流相加得到3，因为3是奇数，所以就在这个8位的比特流后边加上1，来表示这是一个奇偶校验的位</li></ul> 
<p>如果我们要传输“00111010”这个比特流，那么后边添加的比特位就应是“0”，因为这8位相加的结果是4，是个偶数。下边就看一下，如何通过这个奇偶检验码来检测错误。假设此时要传输“00110010”这个比特流，那么需要在尾部添加“1”这个比特位。假设在传输的过程中发生了错误，接收端收到的是“00010010”，此时接收端会通过奇偶校验码来进行校验，接收端计算的奇偶校验码是“0”，不等于“1”，说明这个比特流在传输的过程中出现了差错<br> 相信聪明的你已经看出来，这里边有一个局限性，假设现在还是要传输“00110010”，在尾部添加的比特位是“1”。假设此时接收端接收到的是“00000010”，接收端经过运算之后，发现后边的奇偶校验位应该是“1”，而恰好此时，最后一位校验位就是“1”，就会认为数据没问题，而实际上数据是有问题的。<strong>所以当比特流出现两位错误，奇偶校验码就检测不到错误</strong>。</p> 
<h6><a id="CRC_128"></a>循环冗余校验码（CRC）</h6> 
<p>循环冗余校验码是一种广泛使用的差错检测的算法</p> 
<ul><li>它是一种根据传输或保存的数据而产生固定位数校验码的方法（固定位数，可能是1位，也可能是多位）</li><li>它可以检测数据传输或者保存后可能出现的错误它的过程和奇偶校验码有些类似</li><li>它首先计算生成一些数字，并且附加到数据后边</li><li>当接收端接收到数据之后，就会根据附加到后边的数字，来判断接收到的数据是否有出错</li></ul> 
<p>CRC主要有三个步骤</p> 
<ul><li>选定一个用于校验的多项式G(x)，并在数据尾部添加r个0</li><li>将添加r个0后的数据，使用模“2”除法除以多项式的位串</li><li>将得到的余数填充在原数据r个0的位置，得到可校验的位串</li></ul> 
<p>下边直接例子</p> 
<p>使用CRC计算“101001”的可校验位串</p> 
<p>下边就根据上边提到的计算CRC的三步来计算</p> 
<p>（1）首先是选定一个用于校验的多项式G(x)，并在数据尾部添加r个0</p> 
<p>什么是G(x)？</p> 
<p>G(x)可能是下边这样的一个多项式<br> <img src="https://images2.imgbox.com/55/44/AcIbblk9_o.png" alt="在这里插入图片描述">位串就是将多项式的常数项提取出来，得到了位串1101。在数据尾部添加r个0，其实就是在尾部添加最高阶个0。因此在“101001”后边添加3个0就得到了“101001000”</p> 
<p>（2）将添加r个0后的数据，使用模“2”除法除以多项式的位串<br> <img src="https://images2.imgbox.com/1c/35/9UxRTEuh_o.png" alt="在这里插入图片描述"><br> 经过上边的计算，得到余数为“001”，然后进行第三步</p> 
<p>（3）将得到的余数填充在原数据r个0的位置，得到可校验的位串<br> 也就是将原来的“101001000”填充为“101001001”，最后这个就是最终要发送的可校验位串，上边的过程都是在发送端完成的，发送端通过校验出可校验位串之后，它就可以将这个比特流发送给接收端。接收端在接收到这个比特流之后，它就可以进行校验。校验的过程也是一样，<strong>接收端将接收到的数据除以G(x)的位串，根据余数判断是否出错，如果没有出错，得到的余数应该是0，如果不是0，说明数据在传输过程中出错了</strong><br> <img src="https://images2.imgbox.com/e3/72/ay7Avawt_o.png" alt="在这里插入图片描述">上边就是循环冗余校验码算法（CRC）的整个过程</p> 
<ul><li>其实CRC的错误检测能力与位串的阶数r有关（位串中添加越多的0，检测能力就越强，比如，阶数如果是1的话，就是在传输数据后边加一个校验位，这样就退化成了前边介绍的奇偶校验码了）</li><li>数据链路层只进行数据的检测，不进行纠正（如果数据链路层发现错误的数据，它会直接的将其丢弃掉）</li></ul> 
<h5><a id="MTU_168"></a>最大传送单元MTU</h5> 
<p>数据链路层的数据帧不是无限大的（因此MTU描述的就是最大可传输的数据帧）</p> 
<p>设置MTU的好处：数据帧过大或者过小都会影响传输的效率（常用的以太网的MTU一般为1500字节）</p> 
<p>如果数据帧过大，总时延就会增大，这样就导致发送端和接收端处理信息的时间过长，如果过小的话也不行，假设每次发1个字节，那么1500个字节就需要发送1500次，虽然每个数据发送的总时延减少了，但是重复1500次，这个也会影响通信的效率，所以数据帧过大或过小都会影响数据传输效率</p> 
<p><strong>路径MTU</strong></p> 
<p>假设计算机A给计算机B传输数据，需要经过多个小型网络。假设计算机A给计算机B传输数据的话，那么路径的MTU由谁决定的呢？如下图<br> <img src="https://images2.imgbox.com/26/66/wqAGdhZA_o.png" alt="在这里插入图片描述"><br> 计算机和小型网络之间以及小型网络和小型网络之间的数字是MTU，那么整个路径的MTU就是受最小的MTU影响的，称之为<strong>木桶效应</strong>。所以整个路径的MTU就是1492</p> 
<h5><a id="_182"></a>以太网协议详解</h5> 
<p>上边介绍了数据链路层中的数据封装成帧、透明传输、差错检测以及MTU。了解完这些，还不能让我们知道数据链路层是如何进行数据传输的，<strong>以太网协议</strong>是数据链路层非常常用的一种协议。在学习具体某一层的协议时，我们是希望可以屏蔽其它层的一些细节，比如我们在学习数据链路层的协议时，就不需要关注物理层是如何进行比特流的传输的，我们甚至可以认为比特流是由某一台机器的数据链路层直接传输到另一台机器的数据链路层的，以此来简化理解</p> 
<p><img src="https://images2.imgbox.com/bf/11/1nd8ov6F_o.png" alt="在这里插入图片描述">假设有下边这么一个<strong>网络拓扑</strong>，图中有A、B、C三台计算机，这三个计算机通过一个路由器进行连接。假设此时A需要向C发送数据，数据是如何到达的C的？路由器怎么知道计算机A的数据要发送给谁？</p> 
<p><img src="https://images2.imgbox.com/81/9a/q39XCEm5_o.png" alt="在这里插入图片描述"><br> 两个主要内容</p> 
<ul><li>MAC地址</li><li>以太网协议</li></ul> 
<h6><a id="MAC_196"></a>MAC地址</h6> 
<ul><li>MAC地址（物理地址、硬件地址）</li><li>每一个设备都拥有唯一的一个MAC地址（可以理解成设备的身份证）</li><li>MAC地址共48位，通常用十六进制表示</li><li>可以通过ifconfig -a（windows使用 ipconfig /all）来查看本机所有硬件设备的地址</li></ul> 
<h6><a id="_203"></a>以太网协议</h6> 
<ul><li>以太网（Ethernet）是一种使用广泛的局域网技术</li><li>以太网是一种应用于数据链路层的协议</li><li>使用以太网可以完成相邻设备的数据帧传输</li></ul> 
<p><strong>以太网数据格式</strong></p> 
<p><img src="https://images2.imgbox.com/c8/64/rBkoGaVN_o.png" alt="在这里插入图片描述"></p> 
<p>主要由五个部分组成：</p> 
<ul><li>目的地址、源地址：前边两个部分就是前边提到的MAC地址，下边的6，表示占用6个字节（48位）</li><li>类型：类型表明的是帧数据是哪个协议的数据，如果是网络层的数据的话，类型就是0800；如果帧数据是ARP协议的请求或应答数据，它的类型就是0806；如果是RARP的协议数据，那类型就是8035</li><li>帧数据：就是具体发的数据</li><li>CRC：这个是前边介绍到的循环冗余校验码</li></ul> 
<p><strong>MAC地址表</strong></p> 
<p>MAC地址表是一个映射，会把MAC地址具体的映射到硬件接口。了解了MAC地址表，就可以解决最开始提到的那个问题了</p> 
<p><img src="https://images2.imgbox.com/53/09/wd4bEu5a_o.png" alt="在这里插入图片描述">当A要给C发送消息的时候，在路由器E中有一个MAC地址表，表中记录了每一个MAC地址映射到了哪一个接口。所以A给C发数据的整个过程就是：</p> 
<ul><li>A通过网卡发送数据帧</li><li>数据帧到达路由器，路由器取出前6个字节（目的地址）</li><li>路由器匹配MAC地址表，找到对应的网络接口</li><li>路由器通过目的地址匹配到的接口来发送数据帧<br> <img src="https://images2.imgbox.com/1f/8e/8mvoqeIY_o.png" alt="在这里插入图片描述"><br> 如果MAC地址表，不知道C的硬件接口具体是哪一个，该怎么办？</li></ul> 
<p><img src="https://images2.imgbox.com/aa/1c/Zmz6wgyw_o.png" alt="在这里插入图片描述"><br> 这个问题的过程就是：</p> 
<ul><li>路由器E检查MAC地址表，发现没有MAC地址C的信息</li><li>E将广播A的数据包到除A以外的接口</li><li>E将收到来自B、C的回应，并将MAC地址记录下来</li></ul> 
<p>对于比较复杂的网络拓扑，通过MAC地址表就不能解决跨设备的数据传输</p> 
<p><img src="https://images2.imgbox.com/6f/b3/S9AzNfW9_o.png" alt="在这里插入图片描述"><br> 因为通过MAC地址表只能进行相邻物理节点之前的数据传输，所以，如果A要给C发送数据，靠MAC地址表是完成不了的（E只能知道A、D、F的地址）。解决跨设备的数据传输就需要学习网络层的更多内容</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c83a1f42814dc18e96f08501d969c02c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL 基础</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3660cda6f732e6dfc65bf70e0a65ef4a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu中文件权限、及ls ll指令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>