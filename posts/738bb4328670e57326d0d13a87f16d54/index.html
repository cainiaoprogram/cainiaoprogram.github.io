<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>b MAIN 和 ldr pc,=MAIN 的区别（谈到代码位置无关性） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="b MAIN 和 ldr pc,=MAIN 的区别（谈到代码位置无关性）" />
<meta property="og:description" content="看bootloader的时候经常看到这两种写法，不太明白区别，网上查了查。其实看了之后还是一头雾水？ 其中，2和3 似乎是一个东西，但结果是相反的。晕。 //=============================================== 有几种说法： 第一种，说寻址范围不同。(http://bulo.mcuol.com/GaoKefang/view.htm?topicID=126) LDR指令可以全地址范围内跳转，而B指令只能在前后32MB范围内跳转；
第二种，(http://www.onlyblog.com/blog2/CANopen/4491.html ) 一般芯片具有Re-Map功能，当向量表被重新映射至内部RAM或外部存储器中时用B指令不能实现正确跳转。(原因呢？,by imjacob，难道讲的是下面 程序设计规范2的情况 ？？ )
第三种， B指令经汇编后会替换为当前PC值加上一个修正值(&#43;/-),所以这条指令是代码位置无关的,也就是不管这 条指令是在0地址还是在0x100000执行,都能跳转到指定的位置,而LDR PC,=???将向PC直接装载一个标号的值,请注意,标号在编译过后将被替换为一个与RO相对应的值,也就是说,这样的指令无论在哪里执行,都只会跳转 到一个指定的位置. （http://blog.cec.pandabuying.com/zhiy66/212528.aspx）
下面是它的详细解释：
以下假设：
芯片 FLASH起始于0x100000,共64kB,片上RAM起始于0x200000,共16kB. 芯片 复位之后,程序会从0开始执行,此时FLASH被映射到0地址,因此,芯片可以取得指令并执行.显然,此时还是驻留在0x100000地址.如果使用remap命令,将会把RAM映射到0地址,同样的这时0地址的内容也只是RAM的镜像. 假定有如下程序:
RESET
B INIT 或者 LDR PC,=INIT
…
INIT
…
其中RESET为起始时的代码,也就是这条代码的偏移为0,设INIT的偏移量为offset.如果将这段程序按照RO=0x100000编译, 那么B INIT可理解为ADD PC, PC, #offset,而LDR PC,=INIT可被理解为 MOV PC,#(RO&#43;offset) .显然当系统复位时,程序从0开始运行,而0地址有FLASH的副本,执行B INIT将把PC指向位于0地址处的镜像代码位置,也即INIT（应该是offset，by imjacob）;如果执行LDR PC,=INIT将会将PC直接指向位于FLASH中的原始代码.(应该是 0x100000 &#43; offset,by imjacob)因此以上两者都能正确运行.
下面将RO设置为0x200000,编译后生成代码,还是得 烧写到FLASH中,也就是还是0x100000,系统复位后从0地址执行,还是FLASH的副本,此时执行B INIT,将跳到副本中的INIT位置执行（ 此时是0x100000&#43;offset 还是 offset？，by imjacob） ,此处有对应的代码;但是如果执行LDR PC,=INIT,将向PC加载0x200000&#43;offset,这将使得PC跳到RAM中,而此时由于代码没有复制,RAM中的指定位置并没有代码,程 序无法运行 (应该是 0x200000 &#43; offset,by imjacob) . (我的理解：这就是位置无关代码的基本原理)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/738bb4328670e57326d0d13a87f16d54/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-04-30T03:23:45+08:00" />
<meta property="article:modified_time" content="2013-04-30T03:23:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">b MAIN 和 ldr pc,=MAIN 的区别（谈到代码位置无关性）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <span style="color:rgb(102,102,102)">看bootloader的时候经常看到这两种写法，不太明白区别，网上查了查。其实看了之后还是一头雾水？</span> 
<br style="color:rgb(102,102,102)"> 
<br style="color:rgb(102,102,102)"> 
<span style="color:rgb(102,102,102)">其中，2和3 似乎是一个东西，但结果是相反的。晕。</span> 
<br style="color:rgb(102,102,102)"> 
<br style="color:rgb(102,102,102)"> 
<span style="color:rgb(102,102,102)">//===============================================</span> 
<br style="color:rgb(102,102,102)"> 
<br style="color:rgb(102,102,102)"> 
<span style="color:rgb(102,102,102)">有几种说法：</span> 
<br style="color:rgb(102,102,102)"> 
<br style="color:rgb(102,102,102)"> 
<span style="color:rgb(102,102,102)">第一种，说寻址范围不同。(http://bulo.mcuol.com/GaoKefang/view.htm?topicID=126)</span> 
<br style="color:rgb(102,102,102)"> 
<span style="color:rgb(102,102,102)">       LDR指令可以全地址范围内跳转，而B指令只能在前后32MB范围内跳转；<br> <br> 第二种，(http://www.onlyblog.com/blog2/CANopen/4491.html )</span> 
<span style="color:rgb(102,102,102)"><br> 一般芯片具有Re-Map功能，当向量表被重新映射至内部RAM或外部存储器中时用B指令不能实现正确跳转。<span style="color:rgb(0,128,255)">(原因呢？,by imjacob，难道讲的是下面</span></span> 
<span style="color:rgb(0,128,255)">程序设计规范2的情况</span> 
<span style="color:rgb(102,102,102)"> ？？</span> 
<span style="color:rgb(102,102,102)"><span style="color:rgb(0,128,255)">)</span><br> <br> 第三种，</span> 
<span style="color:#ff0000">B指令经汇编后会替换为当前PC值加上一个修正值(+/-),所以这条指令是代码位置无关的,也就是不管这 条指令是在0地址还是在0x100000执行,都能跳转到指定的位置,而LDR PC,=???将向PC直接装载一个标号的值,请注意,标号在编译过后将被替换为一个与RO相对应的值,也就是说,这样的指令无论在哪里执行,都只会跳转 到一个指定的位置.</span> 
<span style="color:rgb(102,102,102)">（http://blog.cec.pandabuying.com/zhiy66/212528.aspx）<br> 下面是它的详细解释：<br> 以下假设：<br> </span> 
<span style="color:rgb(102,102,102)">芯片 FLASH起始于0x100000,共64kB,片上RAM起始于0x200000,共16kB.</span> 
<br style="color:rgb(102,102,102)"> 
<span style="color:rgb(102,102,102)">芯片 复位之后,程序会从0开始执行,此时FLASH被映射到0地址,因此,芯片可以取得指令并执行.显然,此时还是驻留在0x100000地址.如果使用remap命令,将会把RAM映射到0地址,同样的这时0地址的内容也只是RAM的镜像.</span> 
<br style="color:rgb(102,102,102)"> 
<span style="color:#ff0000">假定有如下程序:<br>        RESET<br>                    B       INIT        或者   LDR      PC,=INIT<br>                    …<br> <br>        INIT<br>                    …<br>       其中RESET为起始时的代码,也就是这条代码的偏移为0,设INIT的偏移量为offset.如果将这段程序按照RO=0x100000编译, 那么B INIT可理解为ADD   PC, PC, #offset,而LDR     PC,=INIT可被理解为 MOV PC,#(RO+offset) .显然当系统复位时,程序从0开始运行,而0地址有FLASH的副本,执行B     INIT将把PC指向位于0地址处的镜像代码位置,也即INIT<span style="color:rgb(0,128,255)">（应该是offset，by imjacob）</span>;如果执行LDR    PC,=INIT将会将PC直接指向位于FLASH中的原始代码.<span style="color:rgb(0,128,255)">(应该是 0x100000 + offset,by imjacob)</span>因此以上两者都能正确运行.<br> <br> 下面将RO设置为0x200000,编译后生成代码,还是得 烧写到FLASH中,也就是还是0x100000,系统复位后从0地址执行,还是FLASH的副本,此时执行B     INIT,将跳到副本中的INIT位置执行<span style="color:rgb(0,128,255)">（</span></span> 
<span style="color:#ff0000"><span style="color:rgb(0,128,255)">此时是0x100000+offset 还是 offset？，by imjacob）</span></span> 
<span style="color:#ff0000">,此处有对应的代码;但是如果执行LDR     PC,=INIT,将向PC加载0x200000+offset,这将使得PC跳到RAM中,而此时由于代码没有复制,RAM中的指定位置并没有代码,程 序无法运行</span> 
<span style="color:#ff0000"><span style="color:rgb(0,128,255)">(应该是 0x200000 + offset,by imjacob)</span></span> 
<span style="color:#ff0000">.</span> 
<p style="color:rgb(102,102,102)"><span style="color:#ff0000">(我的理解：这就是位置无关代码的基本原理)</span></p> 
<p style="color:rgb(0,1,2)">另外，找到一篇 讲位置无关性的文章，如下（http://www.embedu.org/Column/Column266.htm）。按此讲法，应该讲法三比较正确。</p> 
<p style="color:rgb(102,102,102)"><span style="color:#ff0000"><span style="color:rgb(0,1,2)">//===========================================</span></span></p> 
<p align="center" style="color:rgb(102,102,102)"><strong>ARM的位置无关程序设计</strong></p> 
<p style="color:rgb(102,102,102)"><strong>作者：李智敏,</strong><a href="http://www.embedu.org/" rel="nofollow noopener noreferrer" target="_blank" style="color:rgb(25,89,155)">华清远见嵌入式学院</a>上海中心讲师。</p> 
<p style="color:rgb(102,102,102)">ARM处理器支持位置无关的程序设计，<span style="color:rgb(255,1,2)">这种程序加载到存储器的任意地址空间都可以正常运 行</span>，其设计方法在嵌入式应用系统开发中具有重要的作用。尤其在裸机状态下开发Bootloader程序及进行内核初始化设计；利用位置无关的程序设计方法 还可以在具体应用中用于构建高效率动态链接库，因而了解位置无关的程序设计方法，有助于开发人员设计出结构简单、清晰的应用程序。</p> 
<p style="color:rgb(102,102,102)">应用程序必须经过编译、汇编和链接后才变成可执行文件，在链接时，要对所有目标文件进行重 定位(relocation)，建立符号引用规则，同时为变量、函数等分配运行地址。当程序执行时，系统必须把代码加载到链接时所指定的地址空间，以保证 程序在执行过程中对变量、函数等符号的正确引用，使程序正常运行。在具有操作系统的系统中，重定位过程由操作系统自动完成。</p> 
<p style="color:rgb(102,102,102)">在设计Bootloader程序时，必须在裸机环境中进行，这时Bootloader映像 文件的运行地址必须由程序员设定。通常情况下，将Bootloader程序下载到ROM的0x0地址进行启动，而在大多数应用系统中，为了快速启动，首先 将Bootloader程序拷贝到SDRAM中再运行。一般情况下，这两者的地址并不相同，程序在SDRAM中的地址重定位过程必须由程序员完成。实际 上，由于Bootloader是系统上电后要执行的第一段程序，Bootloader程序的拷贝和在这之前的所有工作都必须由其自身来完成，而这些指令都 是在ROM中执行的。也就是说，这些代码即使不在链接时所指定的运行时地址空间，也可以正确执行。这就是位置无关代码，它是一段加载到任意地址空间都能正 常执行的特殊代码。</p> 
<p style="color:rgb(255,1,2)">位置无关代码常用于以下场合：<br>         程序在运行期间动态加载到内存；<br>         程序在不同场合与不同程序组合后加载到内存(如共享的动态链接库)；<br>         在运行期间不同地址相互之间的映射（如Bootloader程序）。</p> 
<p style="color:rgb(102,102,102)">虽然在用GCC编译时，使用-fPIC选项可为C语言产生位置无关代码，但这并不能修正程序设计中固有的位置相关性缺陷。特别是汇编语言代码，必须由程序员遵循一定的程序设计准则，才能保证程序的位置无关性。</p> 
<p style="color:rgb(102,102,102)">ARM程序的位置无关可执行文件PIE（PositionIndependent Executable）包括位置无关代码PIC和位置无关数据PID（PositionIndependent Data）两部分。</p> 
<p style="color:rgb(102,102,102)">PID主要针对可读写数据段（.data段），其中保存已赋初值的全局变量。为实现其位置 无关性，通常使用寄存器R9作为静态基址寄存器，使其指向该可读写段的首地址，并使用相对于基址寄存器的偏移量来对该段的变量进行寻址。这种方法常用于为 可重入程序的多个实例产生多个独立的数据段。在程序设计中，一般不必考虑可读写段的位置无关性，这主要是因为可读写数据主要分配在SDRAM中。</p> 
<p style="color:rgb(102,102,102)">PIC包括程序中的代码和只读数据（.text段），为保证程序能在ROM和SDRAM空间都能正确运行（如裸机状态下的Bootloader程序），必须采用位置无关代码程序设计。</p> 
<p style="color:rgb(102,102,102)">PIC遵循只读段位置无关ROPI（ReadOnly Position Independence）的ATPCS（ARMThumb Procedure Call Standard）的程序设计规范：</p> 
<p style="color:rgb(102,102,102)">（1） 程序设计规范1　　</p> 
<p style="color:rgb(102,102,102)"><span style="color:rgb(255,1,2)">引用同一ROPI段或相对位置固定的另一ROPI段中的符号时，必须是基于PC的符号引用</span>，即使用相对于当前PC的偏移量来实现跳转或进行常量访问。　　</p> 
<p style="color:rgb(102,102,102)">① 位置无关的程序跳转。在ARM汇编程序中，使用相对跳转指令B/BL实现程序跳转。<span style="color:rgb(0,128,255)">指令中所跳转的目标地址用基于当前PC的偏移量来表示，与链接时分配给地址标号的绝对地址值无关</span>，因而代码可以在任何位置进行跳转，实现位置无关性。　　</p> 
<p style="color:rgb(102,102,102)">另外，还可使用ADR或ADRL伪指令将地址标号值读取到PC中实现程序跳转。<span style="color:rgb(0,128,255)">这是因为ADR或ADRL等伪指令会被编译器替换为对基于PC的地址值进行操作</span>，但这种方式所能读取的地址范围较小，并且会因地址值是否为字对齐而异。　　</p> 
<p style="color:rgb(102,102,102)"><span style="color:rgb(0,128,255)">但在ARM程序中，使用LDR等指令直接将地址标号值读取到PC中实现程序跳转不是位置无关的</span>。例如：　　LDR <span style="color:rgb(0,128,255)">PC</span>, =main　　</p> 
<p style="color:rgb(102,102,102)">上面的伪指令编译后的结果为：　　LDR PC, [PC, OFFSET_TO_LPOOL]<br> 　　                                                            LPOOL <br>                                                                                 DCD main　　</p> 
<p style="color:rgb(102,102,102)">可见，虽然LDR是把基于PC的一个存储单元LPOOL的内容加载到PC中，但该存储<span style="color:rgb(0,128,255)">单元中保存的却是链接时所决定的main函数入口的绝对地址</span>，所以main函数实际所在的段不是位置无关。　　</p> 
<p style="color:rgb(102,102,102)">② 位置无关的常量访问。在应用程序中，经常要读写相关寄存器以完成必要的硬件初始化。为增强程序的可读性，利用EQU伪指令对一些常量进行赋值，但在访问过程中，必须实现位置无关性。下面以PXA270的GPIO初始化介绍位置无关的常量访问方法。</p> 
<p style="color:rgb(102,102,102)">GPIO_BASE EQU 0x40e00000;　GPIO基址寄存器地址<br>         GPDR0 EQU 0x00c; 相对于GPIO基址寄存器的偏移量<br>         init_GPDR0 EQU 0xfffbfe00; 寄存器GPDR0初值<br>         LDR <span style="color:rgb(0,128,255)">R1</span>, =GPIO_BASE　　<br>         LDR R0, =init_GPDR0<br>         STR R0, [R1, #GPDR0]</p> 
<p style="color:rgb(102,102,102)">上述汇编代码段经编译后的结果为：</p> 
<p style="color:rgb(102,102,102)">LDR R1, [PC, OFFSET_TO_GPIO_BASE]<br>         LDR R0, [PC, OFFSET_TO_init_GPDR0]<br>         STR R0, [R1, #0xc]<br>         GPIO_BASE<br>         DCD 0x40e00000　<br>         GPDR0<br>         DCD 0x00c　<br>         init_GPDR0<br>         DCD 0xfffbfe00　　</p> 
<p style="color:rgb(102,102,102)">可见，LDR伪指令实际上使用基于PC的偏移量来对符号常量GPIO_BASE和 init_GPDR0进行引用，因而是位置无关的。由此可以得出如下结论：<span style="color:rgb(255,1,2)">使用LDR伪指令将一个<span style="color:rgb(0,128,255)">常量</span>读取到<span style="color:rgb(0,128,255)">非PC</span>的其他通用寄存器中可实现位置<span style="color:rgb(0,128,255)">无关</span>的常 量访问</span>；<span style="color:rgb(255,1,2)">但将一个<span style="color:rgb(0,128,255)">地址值</span>读取到<span style="color:rgb(0,128,255)">PC</span>中进行程序跳转时，跳转目标则是位置<span style="color:rgb(0,128,255)">相关</span>的。</span></p> 
<p style="color:rgb(102,102,102)">（2） 程序设计规范2　　</p> 
<p style="color:rgb(102,102,102)"><span style="color:rgb(255,1,2)">其他被ROPI段中的代码引用的必须是绝对地址</span>，或者是基于可读写位置无关(RWPI)段的静态基址寄存器的可写数据。　　</p> 
<span style="color:rgb(102,102,102)">使用绝对地址只能引用被重定位到特定位置的代码段中的符号，通过在位置无关代码中引入绝对 地址，可以让程序跳转到指定位置。例如，假设Bootloader的阶段1将其自身代码拷贝到链接时所指定的SDRAM地址空间后，当要跳转到阶段2的C 程序入口时，可以使用指令“LDR PC, =main”跳转到程序在SDRAM中的main函数入口地址开始执行。这是因为程序在编译链接时给main函数分派绝对地址，系统通过将main函数的 绝对地址直接赋给PC实现程序跳转。如果使用相对跳转指令“B main”，那么只会跳转到启动ROM内部的main函数入口（</span> 
<span style="color:rgb(0,128,255)">这种情况反而不能写 B main了，但要写之前是不是之前 写一句 ldr pc，= xx也可以？by imjacob</span> 
<span style="color:rgb(102,102,102)">）。</span>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4fc06c878230deabe017b073f1e5b097/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">移动设备管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c83ca7b385c10b2c3368aee7e5d5e407/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">内存和CPU匹配方法详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>