<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>简化本地Feign调用，老手教你这么玩 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="简化本地Feign调用，老手教你这么玩" />
<meta property="og:description" content="在平常的工作中，OpenFeign作为微服务间的调用组件使用的非常普遍，接口配合注解的调用方式突出一个简便，让我们能无需关注内部细节就能实现服务间的接口调用。
但是工作中用久了，发现Feign也有些使用起来麻烦的地方，下面先来看一个问题，再看看我们在工作中是如何解决，以达到简化Feign使用的目的。
先看问题 在一个项目开发的过程中，我们通常会区分开发环境、测试环境和生产环境，如果有的项目要求更高的话，可能还会有个预生产环境。
开发环境作为和前端开发联调的环境，一般使用起来都比较随意，而我们在进行本地开发的时候，有时候也会将本地启动的微服务注册到注册中心nacos上，方便进行调试。
这样，注册中心的一个微服务可能就会拥有多个服务实例，就像下面这样：
眼尖的小伙伴肯定发现了，这两个实例的ip地址有一点不同。
线上环境现在一般使用容器化部署，通常都是由流水线工具打成镜像然后扔到docker中运行，因此我们去看一下服务在docker容器内的ip：
可以看到，这就是注册到nacos上的服务地址之一，而列表中192开头的另一个ip，则是我们本地启动的服务的局域网地址。看一下下面这张图，就能对整个流程一目了然了。
总结一下：
两个service都是通过宿主机的ip和port，把自己的信息注册到nacos上
线上环境的service注册时使用docker内部ip地址
本地的service注册时使用本地局域网地址
那么这时候问题就来了，当我本地再启动一个serviceB，通过FeignClient来调用serviceA中的接口时，因为Feign本身的负载均衡，就可能把请求负载均衡到两个不同的serviceA实例。
如果这个调用请求被负载均衡到本地serviceA的话，那么没什么问题，两个服务都在同一个192.168网段内，可以正常访问。但是如果负载均衡请求到运行在docker内的serviceA的话，那么问题来了，因为网络不通，所以会请求失败：
说白了，就是本地的192.168和docker内的虚拟网段172.17属于纯二层的两个不同网段，不能互访，所以无法直接调用。
那么，如果想在调试时把请求稳定打到本地服务的话，有一个办法，就是指定在FeignClient中添加url参数，指定调用的地址：
@FeignClient(value = &#34;serviceA&#34;,url = &#34;http://127.0.0.1:8088/&#34;) public interface ClientA { @GetMapping(&#34;/test/get&#34;) String get(); } 但是这么一来也会带来点问题：
代码上线时需要再把注解中的url删掉，还要再次修改代码，如果忘了的话会引起线上问题
如果测试的FeignClient很多的话，每个都需要配置url，修改起来很麻烦
那么，有什么办法进行改进呢？为了解决这个问题，我们还是得从Feign的原理说起。
Feign原理 Feign的实现和工作原理，我以前写过一篇简单的源码分析，大家可以简单花个几分钟先铺垫一下，Feign核心源码解析。明白了原理，后面理解起来更方便一些。
简单来说，就是项目中加的@EnableFeignClients这个注解，实现时有一行很重要的代码：
@Import(FeignClientsRegistrar.class) 这个类实现了ImportBeanDefinitionRegistrar接口，在这个接口的registerBeanDefinitions方法中，可以手动创建BeanDefinition并注册，之后spring会根据BeanDefinition实例化生成bean，并放入容器中。
Feign就是通过这种方式，扫描添加了@FeignClient注解的接口，然后一步步生成代理对象，具体流程可以看一下下面这张图：
后续在请求时，通过代理对象的FeignInvocationHandler进行拦截，并根据对应方法进行处理器的分发，完成后续的http请求操作。
ImportBeanDefinitionRegistrar 上面提到的ImportBeanDefinitionRegistrar，在整个创建FeignClient的代理过程中非常重要， 所以我们先写一个简单的例子看一下它的用法。先定义一个实体类：
@Data @AllArgsConstructor public class User { Long id; String name; } 通过BeanDefinitionBuilder，向这个实体类的构造方法中传入具体值，最后生成一个BeanDefinition：
public class MyBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { BeanDefinitionBuilder builder = BeanDefinitionBuilder." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7f3225d5df25f0627bd6deb6a9eedddc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-21T14:17:36+08:00" />
<meta property="article:modified_time" content="2023-06-21T14:17:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">简化本地Feign调用，老手教你这么玩</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在平常的工作中，<code>OpenFeign</code>作为微服务间的调用组件使用的非常普遍，接口配合注解的调用方式突出一个简便，让我们能无需关注内部细节就能实现服务间的接口调用。</p> 
<p>但是工作中用久了，发现Feign也有些使用起来麻烦的地方，下面先来看一个问题，再看看我们在工作中是如何解决，以达到简化Feign使用的目的。</p> 
<h3>先看问题</h3> 
<p>在一个项目开发的过程中，我们通常会区分开发环境、测试环境和生产环境，如果有的项目要求更高的话，可能还会有个预生产环境。</p> 
<p>开发环境作为和前端开发联调的环境，一般使用起来都比较随意，而我们在进行本地开发的时候，有时候也会将本地启动的微服务注册到注册中心nacos上，方便进行调试。</p> 
<p>这样，注册中心的一个微服务可能就会拥有多个服务实例，就像下面这样：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2a/de/P8ooNdGz_o.png"></p> 
<p>眼尖的小伙伴肯定发现了，这两个实例的ip地址有一点不同。</p> 
<p>线上环境现在一般使用容器化部署，通常都是由流水线工具打成镜像然后扔到docker中运行，因此我们去看一下服务在docker容器内的ip：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/de/31/iKtHTOsq_o.png"></p> 
<p>可以看到，这就是注册到nacos上的服务地址之一，而列表中<code>192</code>开头的另一个ip，则是我们本地启动的服务的局域网地址。看一下下面这张图，就能对整个流程一目了然了。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/23/e4/x8bGhwlf_o.jpg"></p> 
<p>总结一下：</p> 
<ul><li> <p>两个service都是通过宿主机的ip和port，把自己的信息注册到nacos上</p> </li><li> <p>线上环境的service注册时使用docker内部ip地址</p> </li><li> <p>本地的service注册时使用本地局域网地址</p> </li></ul> 
<p>那么这时候问题就来了，当我本地再启动一个serviceB，通过<code>FeignClient</code>来调用serviceA中的接口时，因为Feign本身的负载均衡，就可能把请求负载均衡到两个不同的serviceA实例。</p> 
<p>如果这个调用请求被负载均衡到本地serviceA的话，那么没什么问题，两个服务都在同一个<code>192.168</code>网段内，可以正常访问。但是如果负载均衡请求到运行在docker内的serviceA的话，那么问题来了，因为网络不通，所以会请求失败：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/db/b4/npk526An_o.png"></p> 
<p>说白了，就是本地的<code>192.168</code>和docker内的虚拟网段<code>172.17</code>属于纯二层的两个不同网段，不能互访，所以无法直接调用。</p> 
<p>那么，如果想在调试时把请求稳定打到本地服务的话，有一个办法，就是指定在<code>FeignClient</code>中添加<code>url</code>参数，指定调用的地址：</p> 
<pre><code>@FeignClient(value = "serviceA",url = "http://127.0.0.1:8088/")
public interface ClientA {
    @GetMapping("/test/get")
    String get();
}
</code></pre> 
<p>但是这么一来也会带来点问题：</p> 
<ul><li> <p>代码上线时需要再把注解中的<code>url</code>删掉，还要再次修改代码，如果忘了的话会引起线上问题</p> </li><li> <p>如果测试的<code>FeignClient</code>很多的话，每个都需要配置<code>url</code>，修改起来很麻烦</p> </li></ul> 
<p>那么，有什么办法进行改进呢？为了解决这个问题，我们还是得从Feign的原理说起。</p> 
<h3>Feign原理</h3> 
<p>Feign的实现和工作原理，我以前写过一篇简单的源码分析，大家可以简单花个几分钟先铺垫一下，<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTgzOTQ0Ng==&amp;mid=2247484005&amp;idx=1&amp;sn=e040646aef675155c6fcc691e1663185&amp;scene=21#wechat_redirect" rel="nofollow" title="Feign核心源码解析">Feign核心源码解析</a>。明白了原理，后面理解起来更方便一些。</p> 
<p>简单来说，就是项目中加的<code>@EnableFeignClients</code>这个注解，实现时有一行很重要的代码：</p> 
<pre><code>@Import(FeignClientsRegistrar.class)
</code></pre> 
<p>这个类实现了<code>ImportBeanDefinitionRegistrar</code>接口，在这个接口的<code>registerBeanDefinitions</code>方法中，可以手动创建<code>BeanDefinition</code>并注册，之后spring会根据<code>BeanDefinition</code>实例化生成bean，并放入容器中。</p> 
<p>Feign就是通过这种方式，扫描添加了<code>@FeignClient</code>注解的接口，然后一步步生成代理对象，具体流程可以看一下下面这张图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2b/fa/UM91Lg98_o.jpg"></p> 
<p>后续在请求时，通过代理对象的<code>FeignInvocationHandler</code>进行拦截，并根据对应方法进行处理器的分发，完成后续的http请求操作。</p> 
<h3>ImportBeanDefinitionRegistrar</h3> 
<p>上面提到的<code>ImportBeanDefinitionRegistrar</code>，在整个创建<code>FeignClient</code>的代理过程中非常重要， 所以我们先写一个简单的例子看一下它的用法。先定义一个实体类：</p> 
<pre><code>@Data
@AllArgsConstructor
public class User {
    Long id;
    String name;
}
</code></pre> 
<p>通过<code>BeanDefinitionBuilder</code>，向这个实体类的构造方法中传入具体值，最后生成一个<code>BeanDefinition</code>：</p> 
<pre><code>public class MyBeanDefinitionRegistrar
        implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
                                        BeanDefinitionRegistry registry) {
        BeanDefinitionBuilder builder
                = BeanDefinitionBuilder.genericBeanDefinition(User.class);
        builder.addConstructorArgValue(1L);
        builder.addConstructorArgValue("Hydra");

        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();
        registry.registerBeanDefinition(User.class.getSimpleName(),beanDefinition);
    }
}
</code></pre> 
<p><code>registerBeanDefinitions</code>方法的具体调用时间是在之后的<code>ConfigurationClassPostProcessor</code>执行<code>postProcessBeanDefinitionRegistry</code>方法时，而<code>registerBeanDefinition</code>方法则会将<code>BeanDefinition</code>放进一个map中，后续根据它实例化bean。</p> 
<p>在配置类上通过<code>@Import</code>将其引入：</p> 
<pre><code>@Configuration
@Import(MyBeanDefinitionRegistrar.class)
public class MyConfiguration {
}
</code></pre> 
<p>注入这个<code>User</code>测试：</p> 
<pre><code>@Service
@RequiredArgsConstructor
public class UserService {
    private final User user;

    public void getUser(){
        System.out.println(user.toString());
    }
}
</code></pre> 
<p>结果打印，说明我们通过自定义<code>BeanDefinition</code>的方式成功手动创建了一个bean并放入了spring容器中：</p> 
<pre><code>User(id=1, name=Hydra)
</code></pre> 
<p>好了，准备工作铺垫到这结束，下面开始正式的改造工作。</p> 
<h3>改造</h3> 
<p>到这里先总结一下，我们纠结的点就是本地环境需要<code>FeignClient</code>中配置<code>url</code>，但线上环境不需要，并且我们又不想来回修改代码。</p> 
<p>除了像源码中那样生成动态代理以及拦截方法，官方文档中还给我们提供了一个手动创建FeignClient的方法。</p> 
<blockquote> 
 <p>https://docs.spring.io/spring-cloud-openfeign/docs/2.2.9.RELEASE/reference/html/#creating-feign-clients-manually</p> 
</blockquote> 
<p>简单来说，就是我们可以像下面这样，通过Feign的Builder API来手动创建一个Feign客户端。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f8/51/ukbzQMZg_o.png"></p> 
<p>简单看一下，这个过程中还需要配置<code>Client</code>、<code>Encoder</code>、<code>Decoder</code>、<code>Contract</code>、<code>RequestInterceptor</code>等内容。</p> 
<ul><li> <p><code>Client</code>：实际http请求的发起者，如果不涉及负载均衡可以使用简单的<code>Client.Default</code>，用到负载均衡则可以使用<code>LoadBalancerFeignClient</code>，前面也说了，<code>LoadBalancerFeignClient</code>中的<code>delegate</code>其实使用的也是<code>Client.Default</code></p> </li><li> <p><code>Encoder</code>和<code>Decoder</code>：Feign的编解码器，在spring项目中使用对应的<code>SpringEncoder</code>和<code>ResponseEntityDecoder</code>，这个过程中我们借用<code>GsonHttpMessageConverter</code>作为消息转换器来解析json</p> </li><li> <p><code>RequestInterceptor</code>：Feign的拦截器，一般业务用途比较多，比如添加修改header信息等，这里用不到可以不配</p> </li><li> <p><code>Contract</code>：字面意思是合约，它的作用是将我们传入的接口进行解析验证，看注解的使用是否符合规范，然后将关于http的元数据抽取成结果并返回。如果我们使用<code>RequestMapping</code>、<code>PostMapping</code>、<code>GetMapping</code>之类注解的话，那么对应使用的是<code>SpringMvcContract</code></p> </li></ul> 
<p>其实这里刚需的就只有<code>Contract</code>这一个，其他都是可选的配置项。我们写一个配置类，把这些需要的东西都注入进去：</p> 
<pre><code>@Slf4j
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties({LocalFeignProperties.class})
@Import({LocalFeignClientRegistrar.class})
@ConditionalOnProperty(value = "feign.local.enable", havingValue = "true")
public class FeignAutoConfiguration {
    static {
        log.info("feign local route started");
    }

    @Bean
    @Primary
    public Contract contract(){
        return new SpringMvcContract();
    }

    @Bean(name = "defaultClient")
    public Client defaultClient(){
        return new Client.Default(null,null);
    }

    @Bean(name = "ribbonClient")
    public Client ribbonClient(CachingSpringLoadBalancerFactory cachingFactory,
                               SpringClientFactory clientFactory){
        return new LoadBalancerFeignClient(defaultClient(), cachingFactory,
                clientFactory);
    }

    @Bean
    public Decoder decoder(){
        HttpMessageConverter httpMessageConverter=new GsonHttpMessageConverter();
        ObjectFactory&lt;HttpMessageConverters&gt; messageConverters= () -&gt; new HttpMessageConverters(httpMessageConverter);
        SpringDecoder springDecoder = new SpringDecoder(messageConverters);
        return new ResponseEntityDecoder(springDecoder);
    }

    @Bean
    public Encoder encoder(){
        HttpMessageConverter httpMessageConverter=new GsonHttpMessageConverter();
        ObjectFactory&lt;HttpMessageConverters&gt; messageConverters= () -&gt; new HttpMessageConverters(httpMessageConverter);
        return new SpringEncoder(messageConverters);
    }
}
</code></pre> 
<p>在这个配置类上，还有三行注解，我们一点点解释。</p> 
<p>首先是引入的配置类<code>LocalFeignProperties</code>，里面有三个属性，分别是是否开启本地路由的开关、扫描FeignClient接口的包名，以及我们要做的本地路由映射关系，<code>addressMapping</code>中存的是服务名和对应的url地址：</p> 
<pre><code>@Data
@Component
@ConfigurationProperties(prefix = "feign.local")
public class LocalFeignProperties {
    // 是否开启本地路由
    private String enable;

    //扫描FeignClient的包名
    private String basePackage;

    //路由地址映射
    private Map&lt;String,String&gt; addressMapping;
}
</code></pre> 
<p>下面这行注解则表示只有当配置文件中<code>feign.local.enable</code>这个属性为<code>true</code>时，才使当前配置文件生效：</p> 
<pre><code>@ConditionalOnProperty(value = "feign.local.enable", havingValue = "true")
</code></pre> 
<p>最后，就是我们重中之重的<code>LocalFeignClientRegistrar</code>了，我们还是按照官方通过<code>ImportBeanDefinitionRegistrar</code>接口构建<code>BeanDefinition</code>然后注册的思路来实现。</p> 
<p>并且，<code>FeignClientsRegistrar</code>的源码中已经实现好了很多基础的功能，比如扫扫描包、获取<code>FeignClient</code>的<code>name</code>、<code>contextId</code>、<code>url</code>等等，所以需要改动的地方非常少，可以放心的大抄特超它的代码。</p> 
<p>先创建<code>LocalFeignClientRegistrar</code>，并注入需要用到的<code>ResourceLoader</code>、<code>BeanFactory</code>、<code>Environment</code>。</p> 
<pre><code>@Slf4j
public class LocalFeignClientRegistrar implements
        ImportBeanDefinitionRegistrar, ResourceLoaderAware,
        EnvironmentAware, BeanFactoryAware{

    private ResourceLoader resourceLoader;
    private BeanFactory beanFactory;
    private Environment environment;

    @Override
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader=resourceLoader;
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }

    @Override
    public void setEnvironment(Environment environment) {
        this.environment=environment;
    }
 
 //先省略具体功能代码...
}
</code></pre> 
<p>然后看一下创建<code>BeanDefinition</code>前的工作，这一部分主要完成了包的扫描和检测<code>@FeignClient</code>注解是否被添加在接口上的测试。下面这段代码基本上是照搬源码，除了改动一下扫描包的路径，使用我们自己在配置文件中配置的包名。</p> 
<pre><code>@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    ClassPathScanningCandidateComponentProvider scanner = ComponentScanner.getScanner(environment);
    scanner.setResourceLoader(resourceLoader);
    AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter(FeignClient.class);
    scanner.addIncludeFilter(annotationTypeFilter);

    String basePackage =environment.getProperty("feign.local.basePackage");
    log.info("begin to scan {}",basePackage);

    Set&lt;BeanDefinition&gt; candidateComponents = scanner.findCandidateComponents(basePackage);

    for (BeanDefinition candidateComponent : candidateComponents) {
        if (candidateComponent instanceof AnnotatedBeanDefinition) {
            log.info(candidateComponent.getBeanClassName());

            // verify annotated class is an interface
            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;
            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();
            Assert.isTrue(annotationMetadata.isInterface(),
                    "@FeignClient can only be specified on an interface");

            Map&lt;String, Object&gt; attributes = annotationMetadata
                    .getAnnotationAttributes(FeignClient.class.getCanonicalName());

            String name = FeignCommonUtil.getClientName(attributes);
            registerFeignClient(registry, annotationMetadata, attributes);
        }
    }
}
</code></pre> 
<p>接下来创建<code>BeanDefinition</code>并注册，Feign的源码中是使用的<code>FeignClientFactoryBean</code>创建代理对象，这里我们就不需要了，直接替换成使用<code>Feign.builder</code>创建。</p> 
<pre><code>private void registerFeignClient(BeanDefinitionRegistry registry,
                                 AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) {
    String className = annotationMetadata.getClassName();
    Class clazz = ClassUtils.resolveClassName(className, null);
    ConfigurableBeanFactory beanFactory = registry instanceof ConfigurableBeanFactory
            ? (ConfigurableBeanFactory) registry : null;
    String contextId = FeignCommonUtil.getContextId(beanFactory, attributes,environment);
    String name = FeignCommonUtil.getName(attributes,environment);

    BeanDefinitionBuilder definition = BeanDefinitionBuilder
            .genericBeanDefinition(clazz, () -&gt; {
                Contract contract = beanFactory.getBean(Contract.class);
                Client defaultClient = (Client) beanFactory.getBean("defaultClient");
                Client ribbonClient = (Client) beanFactory.getBean("ribbonClient");
                Encoder encoder = beanFactory.getBean(Encoder.class);
                Decoder decoder = beanFactory.getBean(Decoder.class);

                LocalFeignProperties properties = beanFactory.getBean(LocalFeignProperties.class);
                Map&lt;String, String&gt; addressMapping = properties.getAddressMapping();

                Feign.Builder builder = Feign.builder()
                        .encoder(encoder)
                        .decoder(decoder)
                        .contract(contract);

                String serviceUrl = addressMapping.get(name);
                String originUrl = FeignCommonUtil.getUrl(beanFactory, attributes, environment);

                Object target;
                if (StringUtils.hasText(serviceUrl)){
                    target = builder.client(defaultClient)
                            .target(clazz, serviceUrl);
                }else if (StringUtils.hasText(originUrl)){
                    target = builder.client(defaultClient)
                            .target(clazz,originUrl);
                }else {
                    target = builder.client(ribbonClient)
                            .target(clazz,"http://"+name);
                }

                return target;
            });

    definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
    definition.setLazyInit(true);
    FeignCommonUtil.validate(attributes);

    AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();
    beanDefinition.setAttribute(FactoryBean.OBJECT_TYPE_ATTRIBUTE, className);

    // has a default, won't be null
    boolean primary = (Boolean) attributes.get("primary");
    beanDefinition.setPrimary(primary);

    String[] qualifiers = FeignCommonUtil.getQualifiers(attributes);
    if (ObjectUtils.isEmpty(qualifiers)) {
        qualifiers = new String[] { contextId + "FeignClient" };
    }

    BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className,
            qualifiers);
    BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);
}
</code></pre> 
<p>在这个过程中主要做了这么几件事：</p> 
<ul><li> <p>通过<code>beanFactory</code>拿到了我们在前面创建的<code>Client</code>、<code>Encoder</code>、<code>Decoder</code>、<code>Contract</code>，用来构建<code>Feign.Builder</code></p> </li><li> <p>通过注入配置类，通过<code>addressMapping</code>拿到配置文件中服务对应的调用<code>url</code></p> </li><li> <p>通过<code>target</code>方法替换要请求的<code>url</code>，如果配置文件中存在则优先使用配置文件中<code>url</code>，否则使用<code>@FeignClient</code>注解中配置的<code>url</code>，如果都没有则使用服务名通过<code>LoadBalancerFeignClient</code>访问</p> </li></ul> 
<p>在<code>resources/META-INF</code>目录下创建<code>spring.factories</code>文件，通过spi注册我们的自动配置类：</p> 
<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  com.feign.local.config.FeignAutoConfiguration
</code></pre> 
<p>最后，本地打包即可：</p> 
<pre><code>mvn clean install
</code></pre> 
<h3>测试</h3> 
<p>引入我们在上面打好的包，由于包中已经包含了<code>spring-cloud-starter-openfeign</code>，所以就不需要再额外引<code>feign</code>的包了：</p> 
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.cn.hydra&lt;/groupId&gt;
    &lt;artifactId&gt;feign-local-enhancer&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
<p>在配置文件中添加配置信息，启用组件：</p> 
<pre><code>feign:
  local:
    enable: true
    basePackage: com.service
    addressMapping:
      hydra-service: http://127.0.0.1:8088
      trunks-service: http://127.0.0.1:8099
</code></pre> 
<p>创建一个<code>FeignClient</code>接口，注解的<code>url</code>中我们可以随便写一个地址，可以用来测试之后是否会被配置文件中的服务地址覆盖：</p> 
<pre><code>@FeignClient(value = "hydra-service",
 contextId = "hydra-serviceA",
 url = "http://127.0.0.1:8099/")
public interface ClientA {
    @GetMapping("/test/get")
    String get();

    @GetMapping("/test/user")
    User getUser();
}
</code></pre> 
<p>启动服务，过程中可以看见了执行扫描包的操作：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3d/f7/skRzpltz_o.png"></p> 
<p>在替换<code>url</code>过程中添加一个断点，可以看到即使在注解中配置了<code>url</code>，也会优先被配置文件中的服务<code>url</code>覆盖：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/92/2f/WUzPVgkD_o.png"></p> 
<p>使用接口进行测试，可以看到使用上面的代理对象进行了访问并成功返回了结果：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/73/a6/udi4YJnS_o.png"></p> 
<p>如果项目需要发布正式环境，只需要将配置<code>feign.local.enable</code>改为<code>false</code>或删掉，并在项目中添加Feign原始的<code>@EnableFeignClients</code>即可。</p> 
<h3>总结</h3> 
<p>本文提供了一个在本地开发过程中简化Feign调用的思路，相比之前需要麻烦的修改<code>FeignClient</code>中的<code>url</code>而言，能够节省不少的无效劳动，并且通过这个过程，也可以帮助大家了解我们平常使用的这些组件是怎么与spring结合在一起的，熟悉spring的扩展点。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ada266f5ba7eee1e902cd41e09b86be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">从零开始，教你如何安装、配置Python开发环境，Python入门安装教程，超级详细！！！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/773d2a5335258ddaa64a72efd05c97e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vim高阶比较好用操作记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>