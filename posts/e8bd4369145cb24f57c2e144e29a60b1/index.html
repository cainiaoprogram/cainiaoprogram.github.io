<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GMP原理与调度 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GMP原理与调度" />
<meta property="og:description" content="GMP是Go语言运行时(runtime)层面的实现,是go语言自己实现的一套调度系统,区别于操作系统调度OS线程
Golang&#34;调度器&#34;的由来 单进程时代不需要调度器 我们知道,一切的软件都是跑在操作系统上,真正用来干活(计算)的是CPU,早期的操作系统每个程序就是一个进程,直到一个程序运行完,才能进行下一个进程,就是&#34;单进程时代&#34;
一切的程序只能串行发生.
早期的单进程操作系统,面临2个问题:
单一的执行流程,计算机只能一个任务一个任务处理进程阻塞所带来的CPU时间浪费 那么能不能有多个进程宏观一起来执行多个任务呢?
后来操作系统就具有了最早的并发能力:多进程并发,当一个进程阻塞的时候,切换到另外等待执行的进程,这样就能尽量把CPU利用起来,CPU就不浪费了.
多进程/线程有了调度器需求 在多进程/多线程的操作系统中,就解决了阻塞的问题,因为一个进程阻塞CPU可以立刻切换到其他进程中去执行,而且调度CPU的算法可以保证在运行的进程都可以被分配到CPU的运行时间片.这样从宏观来看,似乎多个进程是在同时被运行
但是新的问题就又出现了,进程拥有太多的资源,进程的创建,切换,销毁,都会占用很长时间,CPU虽然利用起来了,但如果进程太多,CPU有很大一部分都被用来进行进程调度了.
怎么才能提高CPU的利用率呢?
对于Linux操作系统来讲,CPU对进程的态度和线程的态度是一样的.
很明显,CPU调度切换的是进程和线程.尽管线程看起来很美好,但实际上多线程开发设计会变得更加复杂,要考虑很多同步竞争等问题,如锁,竞争冲突等.
协程来提高CPU利用率 多进程,多线程已经提高了系统的并发能力,但是在当今互联网高并发场景下,为每个任务都创建一个线程是不现实的,因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统],而线程也要大约4MB).
大量的进程/线程出现了新的问题:
高内存占用调度的高消耗CPU 好了,然后工程师们就发现,其实一个线程分为&#34;内核态&#34;线程和&#34;用户态&#34;线程.
一个&#34;用户态线程&#34;必须要绑定一个&#34;内核态线程&#34;,但是CPU并不知道有&#34;用户态线程的存在&#34;,它只知道它运行的是一个&#34;内核态线程&#34;(Linux的PCB进程控制块).
我们再去细化去分类一下,内核态线程依然叫&#34;线程(thread)“,用户态线程叫&#34;协程(co-routine)”
既然一个协程(co-routine)可以绑定一个线程(thread),那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢.
有三种协程和线程的映射关系:
N:1关系
N个协程绑定1个线程,优点是协程再用户态线程即完成切换,不会陷入到内核态,这种切换非常的轻量快速.但是也有很大的缺点,1个进程的所有协程都绑定再1个线程上
某个程序用不了硬件多核加速能力一旦某协程阻塞,造成线程阻塞,本进程的其他协程都无法执行了,根本就没有并发的能力了
1:1关系
1个协程绑定1个线程,这种最容易实现.协程的调度都有CPU完成了,不存在N:1的缺点,但是协程的创建,删除和切换的代价都有CPU完成,有点略显昂贵了
M:N关系
M个协程绑定N个线程(一般情况下M&gt;N),是N:1和1:1类型的结合,克服了以上2种模式的缺点,但实现起来最为复杂.
协程跟线程是有区别的,线程由CPU调度是抢占式的,协程由用户态线程调度是协作式的,一个协程让出CPU后,才执行下一个协程.
Go语言的协程goroutine Go为了提供更容易使用并发方法,使用了goroutine和channel.goroutine来自协程的概念,让一组可复用的函数运行在一组协程之上,即使有协程阻塞,该线程的其他协程也可以被runtime调度,转移到其他可运行的线程上.最关键的是,程序员看不到这些底层的细节,这就降低了编程的难度,提供了更容易的并发.
Go中,协程被称为goroutine,它非常轻量,一个goroutine只占几KB,并且这几KB就足够goroutine运行完,这就能在有限的内存空间内支持大量的goroutine,支持了更多的并发.虽然一个goroutine的栈只占几KB,但实际是可伸缩的,如果需要更多内容,runtime会自动为goroutine分配.
Goroutine特点
占用内存更小(几KB)调度更灵活(runtime调度) 2012年前的调度器(弃用) Go目前使用的调度器是2012年重新设计的,因为之前的调度器性能存在问题,所以使用4年就被废弃了,那么我们先来分析一下被废弃的调度器是如果运作的.
来看看被废弃的golang调度器是如何实现的?
M要想执行,放回G都必须访问全局G队列,并且M有多个,即多线程访问同一资源都需要加锁进行保证互斥/同步,所以全局G队列是有互斥锁进行保护的.
老调度器有几个缺点:
创建,销毁,调度G都需要每个M获取锁,这就形成了激烈的锁竞争.M转移G会造成延迟和额外的系统负载.比如当G中包含创建新协程的时候,M创建了G1,为了继续执行G,需要把G1交给M1执行,也造成了很差的局部性,因为G1和G是相关的,最好放在M上执行,而不是其他的M系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销 Goroutine调度器的GMP模型的设计思想 新的调度器中,除了M(thread)和G(goroutine),又引进了P(Processor)
Processor,它包含了运行goroutine的资源,如果线程想运行goroutine,必须先获取P,P中还包含了可运行的G队列
GMP模型 在Go中,线程是运行goroutine的实体,调度器的功能是把可运行的goroutine分配到工作线程上.
全局队列(Global Queue):存放等待运行的GP的本地队列:同全局队列类似,存放的也是等待运行的G,存的数量有限,不超过256个.新建G1时,G1优先加入到P的本地队列,如果队列满了,则会把本地队列中一半的G移动到全局队列P列表:所有的P都在程序启动时创建,并保存在数组中,最多有GOMAXPROCS(可配置)个M:线程想运行任务就得获取P,从P的本地队列获取G,P队列为空时,M也会尝试从全局队列拿一批G放到P的本地队列,或从其他P的本地队列偷一半放到自己P的本地队列.M运行G,G执行之后,M会从P获取下一个G,不断重复下去 Goroutine调度器和OS调度器是通过M结合起来的,每个M都代表了1个内核线程,OS调度器负责把内核线程分配到CPU的核上执行,
有关P和M的个数问题 P的数量 由启动时环境变量$GOMAXPROCS或者是由runtime的GOMAXPROCS函数决定.这意味着在程序执行时的任意时刻都只有$GOMAXPROCS个goroutine在同时运行 M的数量: go语言本身的限制:go程序启动时,会设置M的最大数量,默认10000.但是内核很难支持这么多的线程数,所以这个限制可以忽略runtime/debug中的SetMaxThreads函数,设置M的最大数量一个M阻塞了,会创建新的M M与P的数量没有绝对关系,一个M阻塞,P就会去创建或者切换另一个M,所以,即使P的默认数量是1,也有可能会创建很多个M出来.
P和M何时会被创建 P何时创建:再确定了P的最大数量n后,运行时系统会根据这个数量创建n个PM合适创建:没有足够的M来关联P并运行其中的可运行的G.比如所有的M此时都阻塞住了,而P中还有很多就绪任务,就会去寻找空闲的M,而没有空闲的,就会去创建新的M 调度器的设计策略 复用线程:避免频繁的创建,销毁线程,而是对线程的复用
work stealing机制:当本地线程无可运行的G时,尝试从其他线程绑定的P偷取G,而不是销毁线程hand off机制:当本线程因为G进行系统调用阻塞时,线程释放绑定的P,把P转移给其他空闲的线程执行 利用并行:GOMAXPROCS设置P的数量,最多由GOMAXPROCS个线程分布再多个CPU上同时运行.GOMAXPROCS也限制了并发的程度,比如:GOMAXPROCS=核数/2,则最多利用一半的CPU进行并行
抢占:再coroutine中要等待一个协程主动让出CPU才执行下一个协程,在Go中,一个goroutine最多占用CPU10ms,防止其他的goroutine被饿死,这就是goroutine不同于coroutine的一个地方.
全局G队列:在新的调度器中依然有全局G队列,但功能已经被弱化了,当M执行work stealing从其他P偷不到G时,它可以从全局G队列获取G
go func()调度流程 从上图我们可以分析出几个结论:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e8bd4369145cb24f57c2e144e29a60b1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-17T11:17:38+08:00" />
<meta property="article:modified_time" content="2023-12-17T11:17:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GMP原理与调度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>GMP是Go语言运行时(runtime)层面的实现,是go语言自己实现的一套调度系统,区别于操作系统调度OS线程</p> 
</blockquote> 
<h3><a id="Golang_3"></a>Golang"调度器"的由来</h3> 
<h4><a id="_5"></a>单进程时代不需要调度器</h4> 
<p>我们知道,一切的软件都是跑在操作系统上,真正用来干活(计算)的是CPU,早期的操作系统每个程序就是一个进程,直到一个程序运行完,才能进行下一个进程,就是"单进程时代"</p> 
<p>一切的程序只能串行发生.</p> 
<p><img src="https://images2.imgbox.com/0a/92/gAqv6fD2_o.png" alt="在这里插入图片描述"></p> 
<p>早期的单进程操作系统,面临2个问题:</p> 
<ol><li>单一的执行流程,计算机只能一个任务一个任务处理</li><li>进程阻塞所带来的CPU时间浪费</li></ol> 
<p>那么能不能有多个进程宏观一起来执行多个任务呢?</p> 
<p>后来操作系统就具有了最早的并发能力:多进程并发,当一个进程阻塞的时候,切换到另外等待执行的进程,这样就能尽量把CPU利用起来,CPU就不浪费了.</p> 
<h4><a id="_23"></a>多进程/线程有了调度器需求</h4> 
<p><img src="https://images2.imgbox.com/b8/0b/pa4vDQXU_o.png" alt="在这里插入图片描述"></p> 
<p>在多进程/多线程的操作系统中,就解决了阻塞的问题,因为一个进程阻塞CPU可以立刻切换到其他进程中去执行,而且调度CPU的算法可以保证在运行的进程都可以被分配到CPU的运行时间片.这样从宏观来看,似乎多个进程是在同时被运行</p> 
<p>但是新的问题就又出现了,进程拥有太多的资源,进程的创建,切换,销毁,都会占用很长时间,CPU虽然利用起来了,但如果进程太多,CPU有很大一部分都被用来进行进程调度了.</p> 
<p>怎么才能提高CPU的利用率呢?</p> 
<p>对于Linux操作系统来讲,CPU对进程的态度和线程的态度是一样的.<br> <img src="https://images2.imgbox.com/f9/fa/hsQ7q3zC_o.png" alt="在这里插入图片描述"></p> 
<p>很明显,CPU调度切换的是进程和线程.尽管线程看起来很美好,但实际上多线程开发设计会变得更加复杂,要考虑很多同步竞争等问题,如锁,竞争冲突等.</p> 
<h4><a id="CPU_38"></a>协程来提高CPU利用率</h4> 
<p>多进程,多线程已经提高了系统的并发能力,但是在当今互联网高并发场景下,为每个任务都创建一个线程是不现实的,因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统],而线程也要大约4MB).</p> 
<p>大量的进程/线程出现了新的问题:</p> 
<ul><li>高内存占用</li><li>调度的高消耗CPU</li></ul> 
<p>好了,然后工程师们就发现,其实一个线程分为"内核态"线程和"用户态"线程.</p> 
<p>一个"用户态线程"必须要绑定一个"内核态线程",但是CPU并不知道有"用户态线程的存在",它只知道它运行的是一个"内核态线程"(Linux的PCB进程控制块).</p> 
<p><img src="https://images2.imgbox.com/b6/93/1PNxaBty_o.png" alt="在这里插入图片描述"></p> 
<p>我们再去细化去分类一下,内核态线程依然叫"线程(thread)“,用户态线程叫"协程(co-routine)”<br> <img src="https://images2.imgbox.com/1b/a7/M0nsx0HF_o.png" alt="在这里插入图片描述"></p> 
<p>既然一个协程(co-routine)可以绑定一个线程(thread),那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢.</p> 
<p>有三种协程和线程的映射关系:</p> 
<ol><li> <p>N:1关系</p> <p>N个协程绑定1个线程,优点是协程再用户态线程即完成切换,不会陷入到内核态,这种切换非常的轻量快速.但是也有很大的缺点,1个进程的所有协程都绑定再1个线程上</p> 
  <ul><li>某个程序用不了硬件多核加速能力</li><li>一旦某协程阻塞,造成线程阻塞,本进程的其他协程都无法执行了,根本就没有并发的能力了<br> <img src="https://images2.imgbox.com/a4/64/glpEX0PG_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>1:1关系</p> <p>1个协程绑定1个线程,这种最容易实现.协程的调度都有CPU完成了,不存在N:1的缺点,但是协程的创建,删除和切换的代价都有CPU完成,有点略显昂贵了<br> <img src="https://images2.imgbox.com/00/c7/mVQBYVyu_o.png" alt="在这里插入图片描述"></p> </li><li> <p>M:N关系</p> <p>M个协程绑定N个线程(一般情况下M&gt;N),是N:1和1:1类型的结合,克服了以上2种模式的缺点,但实现起来最为复杂.<br> <img src="https://images2.imgbox.com/54/d1/5FkGXKwU_o.png" alt="在这里插入图片描述"></p> <p>协程跟线程是有区别的,线程由CPU调度是抢占式的,协程由用户态线程调度是协作式的,一个协程让出CPU后,才执行下一个协程.</p> </li></ol> 
<h3><a id="Gogoroutine_80"></a>Go语言的协程goroutine</h3> 
<p>Go为了提供更容易使用并发方法,使用了goroutine和channel.goroutine来自协程的概念,让一组可复用的函数运行在一组协程之上,即使有协程阻塞,该线程的其他协程也可以被runtime调度,转移到其他可运行的线程上.最关键的是,程序员看不到这些底层的细节,这就降低了编程的难度,提供了更容易的并发.</p> 
<p>Go中,协程被称为goroutine,它非常轻量,一个goroutine只占几KB,并且这几KB就足够goroutine运行完,这就能在有限的内存空间内支持大量的goroutine,支持了更多的并发.虽然一个goroutine的栈只占几KB,但实际是可伸缩的,如果需要更多内容,runtime会自动为goroutine分配.</p> 
<p>Goroutine特点</p> 
<ul><li>占用内存更小(几KB)</li><li>调度更灵活(runtime调度)</li></ul> 
<h4><a id="2012_91"></a>2012年前的调度器(弃用)</h4> 
<p>Go目前使用的调度器是2012年重新设计的,因为之前的调度器性能存在问题,所以使用4年就被废弃了,那么我们先来分析一下被废弃的调度器是如果运作的.</p> 
<p><img src="https://images2.imgbox.com/e6/3f/eRCPGDhv_o.png" alt="在这里插入图片描述"><br> 来看看被废弃的golang调度器是如何实现的?<br> <img src="https://images2.imgbox.com/de/45/XlL1Q9zQ_o.png" alt="在这里插入图片描述"></p> 
<p>M要想执行,放回G都必须访问全局G队列,并且M有多个,即多线程访问同一资源都需要加锁进行保证互斥/同步,所以全局G队列是有互斥锁进行保护的.</p> 
<p>老调度器有几个缺点:</p> 
<ul><li>创建,销毁,调度G都需要每个M获取锁,这就形成了激烈的锁竞争.</li><li>M转移G会造成延迟和额外的系统负载.比如当G中包含创建新协程的时候,M创建了G1,为了继续执行G,需要把G1交给M1执行,也造成了很差的局部性,因为G1和G是相关的,最好放在M上执行,而不是其他的M</li><li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销</li></ul> 
<h3><a id="GoroutineGMP_109"></a>Goroutine调度器的GMP模型的设计思想</h3> 
<p>新的调度器中,除了M(thread)和G(goroutine),又引进了P(Processor)<br> <img src="https://images2.imgbox.com/df/9c/D0HMdtZY_o.png" alt="在这里插入图片描述"></p> 
<p>Processor,它包含了运行goroutine的资源,如果线程想运行goroutine,必须先获取P,P中还包含了可运行的G队列</p> 
<h4><a id="GMP_117"></a>GMP模型</h4> 
<p>在Go中,线程是运行goroutine的实体,调度器的功能是把可运行的goroutine分配到工作线程上.</p> 
<p><img src="https://images2.imgbox.com/12/de/gSBi3K30_o.png" alt="在这里插入图片描述"></p> 
<ul><li>全局队列(Global Queue):存放等待运行的G</li><li>P的本地队列:同全局队列类似,存放的也是等待运行的G,存的数量有限,不超过256个.新建G1时,G1优先加入到P的本地队列,如果队列满了,则会把本地队列中一半的G移动到全局队列</li><li>P列表:所有的P都在程序启动时创建,并保存在数组中,最多有GOMAXPROCS(可配置)个</li><li>M:线程想运行任务就得获取P,从P的本地队列获取G,P队列为空时,M也会尝试从全局队列拿一批G放到P的本地队列,或从其他P的本地队列偷一半放到自己P的本地队列.M运行G,G执行之后,M会从P获取下一个G,不断重复下去</li></ul> 
<p>Goroutine调度器和OS调度器是通过M结合起来的,每个M都代表了1个内核线程,OS调度器负责把内核线程分配到CPU的核上执行,</p> 
<h4><a id="PM_131"></a>有关P和M的个数问题</h4> 
<ol><li>P的数量 
  <ul><li>由启动时环境变量<code>$GOMAXPROCS</code>或者是由runtime的GOMAXPROCS函数决定.这意味着在程序执行时的任意时刻都只有<code>$GOMAXPROCS</code>个goroutine在同时运行</li></ul> </li><li>M的数量: 
  <ul><li>go语言本身的限制:go程序启动时,会设置M的最大数量,默认10000.但是内核很难支持这么多的线程数,所以这个限制可以忽略</li><li>runtime/debug中的SetMaxThreads函数,设置M的最大数量</li><li>一个M阻塞了,会创建新的M</li></ul> </li></ol> 
<p>M与P的数量没有绝对关系,一个M阻塞,P就会去创建或者切换另一个M,所以,即使P的默认数量是1,也有可能会创建很多个M出来.</p> 
<h4><a id="PM_142"></a>P和M何时会被创建</h4> 
<ol><li>P何时创建:再确定了P的最大数量n后,运行时系统会根据这个数量创建n个P</li><li>M合适创建:没有足够的M来关联P并运行其中的可运行的G.比如所有的M此时都阻塞住了,而P中还有很多就绪任务,就会去寻找空闲的M,而没有空闲的,就会去创建新的M</li></ol> 
<h4><a id="_147"></a>调度器的设计策略</h4> 
<p>复用线程:避免频繁的创建,销毁线程,而是对线程的复用</p> 
<ul><li>work stealing机制:当本地线程无可运行的G时,尝试从其他线程绑定的P偷取G,而不是销毁线程</li><li>hand off机制:当本线程因为G进行系统调用阻塞时,线程释放绑定的P,把P转移给其他空闲的线程执行</li></ul> 
<p>利用并行:GOMAXPROCS设置P的数量,最多由GOMAXPROCS个线程分布再多个CPU上同时运行.GOMAXPROCS也限制了并发的程度,比如:GOMAXPROCS=核数/2,则最多利用一半的CPU进行并行</p> 
<p>抢占:再coroutine中要等待一个协程主动让出CPU才执行下一个协程,在Go中,一个goroutine最多占用CPU10ms,防止其他的goroutine被饿死,这就是goroutine不同于coroutine的一个地方.</p> 
<p>全局G队列:在新的调度器中依然有全局G队列,但功能已经被弱化了,当M执行work stealing从其他P偷不到G时,它可以从全局G队列获取G</p> 
<h4><a id="go_func_160"></a>go func()调度流程</h4> 
<p><img src="https://images2.imgbox.com/7f/9c/S7Oyu6Hr_o.png" alt="在这里插入图片描述"></p> 
<p>从上图我们可以分析出几个结论:</p> 
<ol><li>我们通过go func()来创建一个goroutine;</li><li>有两个存储G的队列,一个是局部调度器P的本地队列,一个是全局G队列.新创建的G会保存在P的本地队列中,如果P的本地队列已经满了就会保存在全局的队列中;</li><li>G只能运行在M中,一个M必须持有一个P,M与P是1:1的关系,M会从P的本地队列弹出一个可执行状态的G来执行,如果P的本地队列为空,就会想其他的MP组合偷取一个可执行的G来执行;</li><li>一个M调度G执行的过程是一个循环机制;</li><li>当M执行某一个G时候如果发生了syscall或则其余阻塞操作,M会阻塞,如果当前有一些G在执行,runtime会把这个线程M从P中摘除(detach),然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P;</li><li>当M系统调用结束后,这个G会尝试获取一个空闲的P执行,并放入到这个P的本地队列,如果获取不到P,那么这个线程M会变成休眠状态,放入到空闲线程中,然后这个G会被放入到全局队列中.</li></ol> 
<h4><a id="_172"></a>调度器的生命周期</h4> 
<p><img src="https://images2.imgbox.com/0b/96/3tdypdp4_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ba45516863859bd7c6297eeaa9db7f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">高云GW1NSR-4C开发板M3核串口通信</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a9629ba02d66dcbf98ed875e6fb9fbd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">价格操纵攻击的再次理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>