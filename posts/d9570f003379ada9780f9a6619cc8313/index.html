<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>redis底层数据结构之压缩列表(ziplist) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="redis底层数据结构之压缩列表(ziplist)" />
<meta property="og:description" content="目录
压缩列表(ziplist)
1 压缩列表结构
2 压缩列表节点结构
3 encoding编码类型
1) 字节数组类型
2) 整数类型
4 压缩列表示意图
5 连锁更新现象
压缩列表(ziplist) 压缩列表(ziplist)是redis 为了节约内存而开发的，由连续内存块组成的顺序型数据结构，适用于长度较小的值
存取的效率高，内存占用小，但由于内存是连续的，在修改的时候要重新分配内存
同时满足以下两个条件时，使用ziplist:
1) 元素长度都小于64Byte
2) 元素数量小于512个
1 压缩列表结构 struct ziplist&lt;T&gt; { int32 zlbytes; int32 zltail_offset; int16 zllength; T[] entries; int8 zlend; } 其中:
zlbytes：整个压缩列表占用的字节数，占4Byte
zltail_offset：最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个元素，占4Byte
zllength：压缩列表的元素个数，占2Byte
entries：压缩列表的元素，可以包含多个节点，每个节点可以保存一个字节数组或者一个整数值
zlend：压缩列表结束标志，值等于 0xFF，占1Byte
2 压缩列表节点结构 typedef struct zlentry { unsigned int prevrawlensize, prevrawlen; unsigned int lensize, len; unsigned int headersize; unsigned char encoding; unsigned char *p; } zlentry; 其中:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d9570f003379ada9780f9a6619cc8313/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-17T18:24:32+08:00" />
<meta property="article:modified_time" content="2022-12-17T18:24:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">redis底层数据结构之压缩列表(ziplist)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8(ziplist)-toc" style="margin-left:0px;"><a href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%28ziplist%29" rel="nofollow">压缩列表(ziplist)</a></p> 
<p id="1%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#1%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84" rel="nofollow">1 压缩列表结构</a></p> 
<p id="2%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#2%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84" rel="nofollow">2 压缩列表节点结构</a></p> 
<p id="3%20encoding%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#3%20encoding%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B" rel="nofollow">3 encoding编码类型</a></p> 
<p id="1)%20%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#1%29%20%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B" rel="nofollow">1) 字节数组类型</a></p> 
<p id="2)%20%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#2%29%20%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B" rel="nofollow">2) 整数类型</a></p> 
<p id="4%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE-toc" style="margin-left:40px;"><a href="#4%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE" rel="nofollow">4 压缩列表示意图</a></p> 
<p id="5%20%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E7%8E%B0%E8%B1%A1-toc" style="margin-left:40px;"><a href="#5%20%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E7%8E%B0%E8%B1%A1" rel="nofollow">5 连锁更新现象</a></p> 
<hr id="hr-toc"> 
<h2></h2> 
<h2>压缩列表(ziplist)</h2> 
<p>压缩列表(ziplist)是redis 为了节约内存而开发的，由连续内存块组成的顺序型数据结构，适用于长度较小的值</p> 
<p>存取的效率高，内存占用小，但由于内存是连续的，在修改的时候要重新分配内存</p> 
<p></p> 
<p><strong>同时满足以下两个条件时，使用ziplist:</strong></p> 
<p>　　1) 元素长度都小于64Byte</p> 
<p>　　2) 元素数量小于512个</p> 
<p></p> 
<h3 id="1%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84">1 压缩列表结构</h3> 
<pre><code class="language-cpp">struct ziplist&lt;T&gt; {
    int32 zlbytes;
    int32 zltail_offset;
    int16 zllength;
    T[] entries;
    int8 zlend;
}</code></pre> 
<p>其中:</p> 
<p>zlbytes：整个压缩列表占用的字节数，占4Byte</p> 
<p>zltail_offset：最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个元素，占4Byte</p> 
<p>zllength：压缩列表的元素个数，占2Byte</p> 
<p>entries：压缩列表的元素，可以包含多个节点，每个节点可以保存一个字节数组或者一个整数值</p> 
<p>zlend：压缩列表结束标志，值等于 0xFF，占1Byte</p> 
<p></p> 
<h3 id="2%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84">2 压缩列表节点结构</h3> 
<pre><code class="language-cpp">typedef struct zlentry { 
    unsigned int prevrawlensize, prevrawlen;
    unsigned int lensize, len;
    unsigned int headersize;
    unsigned char encoding;
    unsigned char *p;
} zlentry;</code></pre> 
<p>其中:</p> 
<p>prevrawlen：前一个节点的长度</p> 
<p>prevrawlensize：存储前一个节点长度(prevrawlen属性)所需的字节数</p> 
<p>len：当前节点长度</p> 
<p>lensize：储当前节点长度(len属性)所需的字节数</p> 
<p>headersize：当前节点的header大小</p> 
<p>encoding：节点的编码方式</p> 
<p>p：指向节点的指针</p> 
<p></p> 
<p>虽然redis定义了节点zlentry结构体，但是redis却没有用zlentry结构来存储节点，因为，这个结构存小整数或短字符串太浪费空间</p> 
<p>zlentry结构体在32位系统占用28Byte，在64位系统占用32Byte，这不符合压缩列表提高内存利用率的设计目的，因此，在redis中，并没有使用zlentry结构，而是定义了宏来表示压缩列表的节点</p> 
<p></p> 
<p>压缩列表的节点真正的结构如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/82/0f/DJDkZxuM_o.png"></p> 
<p> 其中:</p> 
<p> previous_entry_length：前一个节点的长度，占1Byte或5Byte</p> 
<p>　　如果前一个节点的长度小于254Byte，则需要1Byte来保存前一个节点的长度</p> 
<p>　　如果前一个节点的长度大于等于254Byte，则需要5Byte来保存前一个节点的长度，第一个Byte固定为0xfe(254)，后四个Byte表示前一个节点的长度</p> 
<p>encoding：编码类型(字节数组，整数)，保存了content的数据类型和长度，占用1Byte、2Byte或者5Byte</p> 
<p>content：节点数据，节点数据类型和长度由encoding决定</p> 
<p></p> 
<p><strong>当前entry的总字节数 = 下一个entry的previous_entry_length的值 = previous_entry_length字节数 + encoding字节数 + content字节数</strong></p> 
<p></p> 
<h3 id="3%20encoding%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B">3 encoding编码类型</h3> 
<h4 id="1)%20%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><strong>1) 字节数组类型</strong></h4> 
<table border="0"><tbody><tr><td>encoding</td><td>encoding长度</td><td>content字节数组长度</td><td>说明</td></tr><tr><td>00xxxxxx</td><td>1Byte</td><td>小于等于63(2^6-1)Byte</td><td>encoding的第一个字节最高两位是00，剩余的6位用来表示字节数组的长度</td></tr><tr><td>01xxxxxx|xxxxxxxx</td><td>2Byte</td><td>小于等于16383(2^14-1)Byte</td><td>encoding的第一个字节最高两位是01，剩余的14位用来表示字节数组的长度</td></tr><tr><td>10xxxxxx|xxxxxxxx|xxxxxxxx|xxxxxxxx|xxxxxxxx</td><td>5Byte</td><td>小于等于4294967295(2^32-1)Byte</td><td>encoding的第一个字节最高两位是10，剩余的4Byte共32位(第一个字节剩余的6位舍弃)用来表示字节数组的长度</td></tr></tbody></table> 
<p></p> 
<p><strong>保存"redis"和"ab"两个字符串的示意图</strong></p> 
<p>其中:</p> 
<p>字符串"redis"占7Byte = (previous_entry_length = 1Byte)  + (encoding = 1Byte) + (content = 5Byte)</p> 
<p>字符串"ab"占4Byte = (previous_entry_length = 1Byte) + (encoding = 1Byte) + (content = 2Byte)</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9e/80/ceMuVumi_o.png"></p> 
<p></p> 
<p></p> 
<h4 id="2)%20%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><strong>2) 整数类型</strong></h4> 
<table border="0"><tbody><tr><td>encoding</td><td>encoding长度</td><td>content整数类型</td><td>说明</td></tr><tr><td>11000000</td><td>1Byte</td><td>2Byte的int16_t类型, -2^15~2^15-1</td><td>encoding的值恒为0xC0</td></tr><tr><td>11010000</td><td>1Byte</td><td>4Byte的int32_t类型,-2^31~2^31-1</td><td>encoding的值恒为0xD0</td></tr><tr><td>11100000</td><td>1Byte</td><td>8Byte的int64_t类型,-2^63~2^63-1</td><td>encoding的值恒为0xE0</td></tr><tr><td>11110000</td><td>1Byte</td><td>3Byte的整数,-2^23~2^23-1</td><td>encoding的值恒为0xF0</td></tr><tr><td>11111110</td><td>1Byte</td><td>1Byte的整数,-2^6~2^6-1</td><td>encoding的值恒为0xFE</td></tr><tr><td>1111xxxx</td><td>1Byte</td><td> 无content字段</td><td>xxxx只能取0001~1101,表示0~12的整数,4位之和减去1表示真正的整数,此时不需要content</td></tr><tr><td>11111111</td><td>1Byte</td><td>  无content字段</td><td>ziplist结束标志</td></tr></tbody></table> 
<p></p> 
<p><strong>保存2,10,1024三个整数的示意图</strong></p> 
<p>2,10的content不占用空间,1024的content占2字节</p> 
<p>其中:</p> 
<p>整数2占2Byte = (previous_entry_length = 1Byte)  + (encoding = 1Byte) + (content = 0Byte)</p> 
<p>整数10占2Byte = (previous_entry_length = 1Byte)  + (encoding = 1Byte) + (content = 0Byte)</p> 
<p>整数1024占4Byte = (previous_entry_length = 1Byte)  + (encoding = 1Byte) + (content = 2Byte)</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4a/5e/l3JQTGCj_o.png"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="4%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE">4 压缩列表示意图</h3> 
<p>存有字符串"redis"和整数2共2个节点的ziplist示意图如下:</p> 
<p>type = REDIS_LIST 或 REDIS_ZSET</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/86/eb/bbLwsR3n_o.png"></p> 
<p></p> 
<p></p> 
<h3 id="5%20%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E7%8E%B0%E8%B1%A1">5 连锁更新现象</h3> 
<p>previous_entry_length 记录了上一个entry 的长度，极端情况下: 如果每个entry的长度都是250~253Byte，那么如果在头部插一个节点的长度大于254Byte的entry节点，那么后一个节点的previous_entry_length值就从1Byte变为 5Byte，那么后一个entry节点的长度就大于了254Byte，再后面一个entry节点的previous_entry_length值也需要更新，引发连锁反应，后面所有的entry节点变大，previous_entry_length也变大，此时会频繁的进行数据迁移，申请内存，销毁动作，使性能受到很大影响</p> 
<p>连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作，而每次空间重分配的最坏复杂度为 O(N)，所以连锁更新的最坏复杂度为 O(N^2) </p> 
<p>尽管连锁更新的复杂度较高，但它触发的概率很低</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1dc6b44ce6ec4de6554a0d36de3066f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NMS与Soft NMS算法解析以及numpy实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f84155c41d0043875d33a2941fa4c7ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">国产实时操作系统&#43;intel x86/龙芯平台超边缘计算机方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>