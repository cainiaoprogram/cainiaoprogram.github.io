<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>@Qualifier高级应用---按类别批量依赖注入（QualifierAnnotationAutowireCandidateResolver原理详解）【享学Spring】 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="@Qualifier高级应用---按类别批量依赖注入（QualifierAnnotationAutowireCandidateResolver原理详解）【享学Spring】" />
<meta property="og:description" content="每篇一句 罗斯：选秀状元可能有水货，但MVP绝对没有
前言 在上篇文章(讲解@LoadBalanced负载均衡)的末尾，我抛出了一个很重要的问题，建议小伙伴自己深入思考一番；本文主要针对此问题，作出一个统一的答复和讲解。
由于本人觉得这块知识点它属于Spring Framework的核心内容之一，非常的重要，因此单拎出来作专文讲述，希望对你有所帮助。
背景案例 说到@Qualifier这个注解大家并不陌生：它用于“精确匹配”Bean，一般用于同一类型的Bean有多个不同实例的case下，可通过此注解来做鉴别和匹配。
本以为@Qualifier注解使用在属性上、类上用于鉴别就够了，直到我看到LoadBalancerAutoConfiguration里有这么应用：
@LoadBalanced @Autowired(required = false) private List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();	它能把容器内所有RestTemplate类型并且标注有@LoadBalanced注解的Bean全注入进来。
这个用法让我非常的惊喜，它给我提供额外一条思路，让我的框架多了一种玩法。为了融汇贯通它，使用起来尽量避免不采坑，那就只能揭开它，从底层原理处理解它的用法了。
QualifierAnnotationAutowireCandidateResolver详解 它是依赖注入候选处理器接口AutowireCandidateResolver的实现类，继承自GenericTypeAwareAutowireCandidateResolver，所以此类是功能最全、最为强大的一个处理器（ContextAnnotationAutowireCandidateResolver除外~），Spring内默认使用它进行候选处理。
它几乎可以被称为@Qualifier注解的&#34;实现类&#34;，专门用于解析此注解。
带着上面的疑问进行原理分析如下：
// @since 2.5 public class QualifierAnnotationAutowireCandidateResolver extends GenericTypeAwareAutowireCandidateResolver { // 是个List，可以知道它不仅仅只支持org.springframework.beans.factory.annotation.Qualifier private final Set&lt;Class&lt;? extends Annotation&gt;&gt; qualifierTypes = new LinkedHashSet&lt;&gt;(2); private Class&lt;? extends Annotation&gt; valueAnnotationType = Value.class; // 空构造：默认支持的是@Qualifier以及JSR330标准的@Qualifier public QualifierAnnotationAutowireCandidateResolver() { this.qualifierTypes.add(Qualifier.class); try { this.qualifierTypes.add((Class&lt;? extends Annotation&gt;) ClassUtils.forName(&#34;javax.inject.Qualifier&#34;, QualifierAnnotationAutowireCandidateResolver.class.getClassLoader())); } catch (ClassNotFoundException ex) { // JSR-330 API not available - simply skip." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6e28209418f8e179e4d66e46cc2d270b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-17T00:36:09+08:00" />
<meta property="article:modified_time" content="2019-09-17T00:36:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">@Qualifier高级应用---按类别批量依赖注入（QualifierAnnotationAutowireCandidateResolver原理详解）【享学Spring】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h5><a id="_0"></a>每篇一句</h5> 
<blockquote> 
 <p>罗斯：选秀状元可能有水货，但MVP绝对没有</p> 
</blockquote> 
<h5><a id="_2"></a>前言</h5> 
<p>在<a href="https://fangshixiang.blog.csdn.net/article/details/100788040" rel="nofollow">上篇文章(讲解@LoadBalanced负载均衡)</a>的末尾，我抛出了一个很重要的问题，建议小伙伴自己深入思考一番；本文主要针对此问题，作出一个统一的答复和讲解。<br> 由于本人觉得这块知识点它属于<code>Spring Framework</code>的核心内容之一，非常的重要，因此单拎出来作专文讲述，希望对你有所帮助。</p> 
<h5><a id="_6"></a>背景案例</h5> 
<p>说到<code>@Qualifier</code>这个注解大家并不陌生：它用于“精确匹配”<code>Bean</code>，一般用于同一类型的Bean有多个不同实例的case下，可通过此注解来做鉴别和匹配。<br> 本以为<code>@Qualifier</code>注解使用在属性上、类上用于鉴别就够了，直到我看到<code>LoadBalancerAutoConfiguration</code>里有这么应用：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@LoadBalanced</span>
<span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> List<span class="token generics function"><span class="token punctuation">&lt;</span>RestTemplate<span class="token punctuation">&gt;</span></span> restTemplates <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
</code></pre> 
<p><strong>它能把容器内所有<code>RestTemplate</code>类型并且标注有<code>@LoadBalanced</code>注解的Bean全注入进来</strong>。<br> 这个用法让我非常的惊喜，它给我提供额外一条思路，让我的框架多了一种玩法。为了融汇贯通它，使用起来尽量避免不采坑，那就只能揭开它，从底层原理处理解它的用法了。</p> 
<hr> 
<h3><a id="QualifierAnnotationAutowireCandidateResolver_18"></a><code>QualifierAnnotationAutowireCandidateResolver</code>详解</h3> 
<p>它是依赖注入候选处理器接口<code>AutowireCandidateResolver</code>的实现类，继承自<code>GenericTypeAwareAutowireCandidateResolver</code>，所以此类是功能最全、最为强大的一个处理器（<code>ContextAnnotationAutowireCandidateResolver</code>除外~），<code>Spring</code>内默认使用它进行候选处理。</p> 
<p>它几乎可以被称为<code>@Qualifier</code>注解的"实现类"，专门用于解析此注解。<br> 带着上面的疑问进行原理分析如下：</p> 
<pre><code class="prism language-java"><span class="token comment">// @since 2.5</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QualifierAnnotationAutowireCandidateResolver</span> <span class="token keyword">extends</span> <span class="token class-name">GenericTypeAwareAutowireCandidateResolver</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 是个List，可以知道它不仅仅只支持org.springframework.beans.factory.annotation.Qualifier</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">&gt;&gt;</span> qualifierTypes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">&gt;</span> valueAnnotationType <span class="token operator">=</span> Value<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>


	<span class="token comment">// 空构造：默认支持的是@Qualifier以及JSR330标准的@Qualifier</span>
	<span class="token keyword">public</span> <span class="token function">QualifierAnnotationAutowireCandidateResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>qualifierTypes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Qualifier<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>qualifierTypes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> ClassUtils<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"javax.inject.Qualifier"</span><span class="token punctuation">,</span> QualifierAnnotationAutowireCandidateResolver<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// JSR-330 API not available - simply skip.</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">// 非空构造：可自己额外指定注解类型</span>
	<span class="token comment">// 注意：如果通过构造函数指定qualifierType，上面两种就不支持了，因此不建议使用</span>
	<span class="token comment">// 而建议使用它提供的addQualifierType() 来添加~~~</span>
	<span class="token keyword">public</span> <span class="token function">QualifierAnnotationAutowireCandidateResolver</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">&gt;</span> qualifierType<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 省略add/set方法	</span>

	<span class="token comment">// 这是个最重要的接口方法~~~  判断所提供的Bean--&gt;BeanDefinitionHolder 是否是候选的</span>
	<span class="token comment">// （返回true表示此Bean符合条件）</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAutowireCandidate</span><span class="token punctuation">(</span>BeanDefinitionHolder bdHolder<span class="token punctuation">,</span> DependencyDescriptor descriptor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 1、先看父类：ean定义是否允许依赖注入、泛型类型是否匹配</span>
		<span class="token keyword">boolean</span> match <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">isAutowireCandidate</span><span class="token punctuation">(</span>bdHolder<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 2、若都满足就继续判断@Qualifier注解~~~~</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>match<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 3、看看标注的@Qualifier注解和候选Bean是否匹配~~~（本处的核心逻辑）</span>
			<span class="token comment">// descriptor 一般封装的是属性写方法的参数，即方法参数上的注解</span>
			match <span class="token operator">=</span> <span class="token function">checkQualifiers</span><span class="token punctuation">(</span>bdHolder<span class="token punctuation">,</span> descriptor<span class="token punctuation">.</span><span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 4、若Field/方法参数匹配，会继续去看看参数所在的方法Method的情况</span>
			<span class="token comment">// 若是构造函数/返回void。 进一步校验标注在构造函数/方法上的@Qualifier限定符是否匹配</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>match<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				MethodParameter methodParam <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">getMethodParameter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">// 若是Field，methodParam就是null  所以这里是需要判空的</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>methodParam <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					Method method <span class="token operator">=</span> methodParam<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token comment">// method == null表示构造函数 void.class表示方法返回void</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">==</span> method<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						<span class="token comment">// 注意methodParam.getMethodAnnotations()方法是可能返回空的</span>
						<span class="token comment">// 毕竟构造方法/普通方法上不一定会标注@Qualifier等注解呀~~~~</span>
						<span class="token comment">// 同时警示我们：方法上的@Qualifier注解可不要乱标</span>
						match <span class="token operator">=</span> <span class="token function">checkQualifiers</span><span class="token punctuation">(</span>bdHolder<span class="token punctuation">,</span> methodParam<span class="token punctuation">.</span><span class="token function">getMethodAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> match<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在源码注释的地方，我按照步骤标出了它进行匹配的一个执行步骤逻辑。需要注意如下几点：</p> 
<ul><li><code>qualifierTypes</code>是支持调用者自己指定的（默认只支持<code>@Qualifier</code>类型）</li><li>只有类型匹配、Bean定义匹配、泛型匹配等全部Ok了，才会使用<code>@Qualifier</code>去更加精确的匹配</li><li><code>descriptor.getAnnotations()</code>的逻辑是：<br> - 如果<code>DependencyDescriptor</code>描述的是字段（<code>Field</code>），那就去字段里拿注解们<br> - 若描述的是方法参数（<code>MethodParameter</code>），那就返回的是方法参数的注解</li><li>步骤3的<code>match = true</code>表示<strong>Field/方法参数上</strong>的限定符是匹配的~</li></ul> 
<blockquote> 
 <p>说明：能走到<code>isAutowireCandidate()</code>方法里来，那它肯定是标注了<code>@Autowired</code>注解的（才能被<code>AutowiredAnnotationBeanPostProcessor</code>后置处理），所以<code>descriptor.getAnnotations()</code>返回的数组长度至少为1</p> 
</blockquote> 
<h6><a id="checkQualifiers_90"></a><code>checkQualifiers()</code>方法：</h6> 
<pre><code class="prism language-java">QualifierAnnotationAutowireCandidateResolver：

	<span class="token comment">// 将给定的限定符注释与候选bean定义匹配。命名中你发现：这里是负数形式，表示多个注解一起匹配</span>
	<span class="token comment">// 此处指的限定符，显然默认情况下只有@Qualifier注解</span>
	<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">checkQualifiers</span><span class="token punctuation">(</span>BeanDefinitionHolder bdHolder<span class="token punctuation">,</span> Annotation<span class="token punctuation">[</span><span class="token punctuation">]</span> annotationsToSearch<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 很多人疑问为何没标注注解返回的还是true？</span>
		<span class="token comment">// 请参照上面我的解释：methodParam.getMethodAnnotations()方法是可能返回空的，so...可以理解了吧</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ObjectUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>annotationsToSearch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		SimpleTypeConverter typeConverter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleTypeConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 遍历每个注解（一般有@Autowired+@Qualifier两个注解）</span>
		<span class="token comment">// 本文示例的两个注解：@Autowired+@LoadBalanced两个注解~~~（@LoadBalanced上标注有@Qualifier）</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>Annotation annotation <span class="token operator">:</span> annotationsToSearch<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">&gt;</span> type <span class="token operator">=</span> annotation<span class="token punctuation">.</span><span class="token function">annotationType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">boolean</span> checkMeta <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 是否去检查元注解</span>
			<span class="token keyword">boolean</span> fallbackToMeta <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

			<span class="token comment">// isQualifier方法逻辑见下面：是否是限定注解（默认的/开发自己指定的）</span>
			<span class="token comment">// 本文的org.springframework.cloud.client.loadbalancer.LoadBalanced是返回true的</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isQualifier</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// checkQualifier：检查当前的注解限定符是否匹配</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">checkQualifier</span><span class="token punctuation">(</span>bdHolder<span class="token punctuation">,</span> annotation<span class="token punctuation">,</span> typeConverter<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					fallbackToMeta <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 没匹配上。那就fallback到Meta去吧</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					checkMeta <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 匹配上了，就没必要校验元数据了喽~~~</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// 开始检查元数据（如果上面匹配上了，就不需要检查元数据了）</span>
			<span class="token comment">// 比如说@Autowired注解/其它自定义的注解（反正就是未匹配上的），就会进来一个个检查元数据</span>
			<span class="token comment">// 什么时候会到checkMeta里来：如@A上标注有@Qualifier。@B上标注有@A。这个时候限定符是@B的话会fallback过来</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>checkMeta<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">boolean</span> foundMeta <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				<span class="token comment">// type.getAnnotations()结果为元注解们：@Documented、@Retention、@Target等等</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>Annotation metaAnn <span class="token operator">:</span> type<span class="token punctuation">.</span><span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">&gt;</span> metaType <span class="token operator">=</span> metaAnn<span class="token punctuation">.</span><span class="token function">annotationType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isQualifier</span><span class="token punctuation">(</span>metaType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						foundMeta <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 只要进来了 就标注找到了，标记为true表示从元注解中找到了</span>
						<span class="token comment">// Only accept fallback match if @Qualifier annotation has a value...</span>
						<span class="token comment">// Otherwise it is just a marker for a custom qualifier annotation.</span>
						<span class="token comment">// fallback=true(是限定符但是没匹配上才为true)但没有valeu值</span>
						<span class="token comment">// 或者根本就没有匹配上，那不好意思，直接return false~</span>
						<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fallbackToMeta <span class="token operator">&amp;&amp;</span> StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>AnnotationUtils<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>metaAnn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">checkQualifier</span><span class="token punctuation">(</span>bdHolder<span class="token punctuation">,</span> metaAnn<span class="token punctuation">,</span> typeConverter<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
							<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
						<span class="token punctuation">}</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				<span class="token comment">// fallbackToMeta =true你都没有找到匹配的，就返回false的</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>fallbackToMeta <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>foundMeta<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 相当于：只有所有的注解都木有返回false，才会认为这个Bean是合法的~~~</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 判断一个类型是否是限定注解   qualifierTypes：表示我所有支持的限定符</span>
	<span class="token comment">// 本文的关键在于下面这个判断语句：类型就是限定符的类型 or @Qualifier标注在了此注解上（isAnnotationPresent）</span>
	<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isQualifier</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">&gt;</span> annotationType<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">&gt;</span> qualifierType <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>qualifierTypes<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 类型就是限定符的类型 or @Qualifier标注在了此注解上（isAnnotationPresent）</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>annotationType<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>qualifierType<span class="token punctuation">)</span> <span class="token operator">||</span> annotationType<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>qualifierType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p><code>checkQualifiers()</code>方法它会检查标注的所有的注解（循环遍历一个个检查），规则如下：</p> 
<ul><li>若是限定符注解（自己就是<code>@Qualifier</code>或者<code>isAnnotationPresent</code>），匹配上了，就继续看下一个注解<br> - 也就说<code>@Qualifier</code>所标注的注解也算是限定符(<code>isQualifier() = true</code>)</li><li>若是限定符注解但是没匹配上，那就fallback。继续看看标注在它身上的限定符注解（如果有）能否匹配上，若匹配上了也成</li><li>若不是限定符注解，也是走fallback逻辑</li><li><strong>总之：若不是限定符注解直接忽略。若有多个限定符注解都生效，必须全部匹配上了，才算做最终匹配上。</strong></li></ul> 
<blockquote> 
 <p>Tips：<strong>限定符不生效</strong>的效果不一定是注入失败，而是如果是单个的话还是注入成功的。只是若出现多个Bean它就无法起到区分的效果了，所以才会注入失败了~</p> 
</blockquote> 
<p><strong>它的<code>fallback</code>策略最多只能再向上再找一个层级(多了就不行了)</strong>。例如上例子中使用@B标注也是能起到<code>@Qualifier</code>效果的，但是若再加一个<code>@C</code>层级，限定符就不生效了。</p> 
<blockquote> 
 <p>注意：<code>Class.isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code>表示<code>annotationClass</code>是否标注在此类型上（此类型可以是任意Class类型）。<br> 此方法不具有传递性：比如注解A上标注有@Qualifier，注解B上标注有@A注解，那么你用此方法判断@B上是否有@Qualifier<code>它是返回false的</code>（即使都写了<code>@Inherited</code>注解，因为和它没关系）</p> 
</blockquote> 
<p>到这其实还是不能解释本文中为何<code>@LoadBalanced</code>参与了依赖注入，还得继续看精髓中的精髓<code>checkQualifier()</code>方法（方法名是单数，表示精确检查某一个单独的注解）：</p> 
<pre><code class="prism language-java">QualifierAnnotationAutowireCandidateResolver：

	<span class="token comment">// 检查某一个注解限定符，是否匹配当前的Bean</span>
	<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">checkQualifier</span><span class="token punctuation">(</span>BeanDefinitionHolder bdHolder<span class="token punctuation">,</span> Annotation annotation<span class="token punctuation">,</span> TypeConverter typeConverter<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// type：注解类型 bd：当前Bean的RootBeanDefinition </span>
		Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">&gt;</span> type <span class="token operator">=</span> annotation<span class="token punctuation">.</span><span class="token function">annotationType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		
		RootBeanDefinition bd <span class="token operator">=</span> <span class="token punctuation">(</span>RootBeanDefinition<span class="token punctuation">)</span> bdHolder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
		<span class="token comment">// ========下面是匹配的关键步骤=========</span>
		<span class="token comment">// 1、Bean定义信息的qualifiers字段一般都无值了（XML时代的配置除外）</span>
		<span class="token comment">// 长名称不行再拿短名称去试了一把。显然此处 qualifier还是为null的</span>
		AutowireCandidateQualifier qualifier <span class="token operator">=</span> bd<span class="token punctuation">.</span><span class="token function">getQualifier</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>qualifier <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			qualifier <span class="token operator">=</span> bd<span class="token punctuation">.</span><span class="token function">getQualifier</span><span class="token punctuation">(</span>ClassUtils<span class="token punctuation">.</span><span class="token function">getShortName</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">//这里才是真真有料的地方~~~请认真看步骤</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>qualifier <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// First, check annotation on qualified element, if any</span>
			<span class="token comment">// 1、词方法是从bd标签里拿这个类型的注解声明，非XML配置时代此处targetAnnotation 为null</span>
			Annotation targetAnnotation <span class="token operator">=</span> <span class="token function">getQualifiedElementAnnotation</span><span class="token punctuation">(</span>bd<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// Then, check annotation on factory method, if applicable</span>
			<span class="token comment">// 2、若为null。去工厂方法里拿这个类型的注解。这方法里标注了两个注解@Bean和@LoadBalanced，所以此时targetAnnotation就不再为null了~~</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>targetAnnotation <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				targetAnnotation <span class="token operator">=</span> <span class="token function">getFactoryMethodAnnotation</span><span class="token punctuation">(</span>bd<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// 若本类木有，还会去父类去找一趟</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>targetAnnotation <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				RootBeanDefinition dbd <span class="token operator">=</span> <span class="token function">getResolvedDecoratedDefinition</span><span class="token punctuation">(</span>bd<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>dbd <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					targetAnnotation <span class="token operator">=</span> <span class="token function">getFactoryMethodAnnotation</span><span class="token punctuation">(</span>dbd<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>


			<span class="token comment">// 若xml、工厂方法、父里都还没找到此方法。那好家伙，回退到还去类本身上去看</span>
			<span class="token comment">// 也就是说，如果@LoadBalanced标注在RestTemplate上，也是阔仪的</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>targetAnnotation <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// Look for matching annotation on the target class</span>
				<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
			<span class="token punctuation">}</span>
		
			<span class="token comment">// 找到了，并且当且仅当就是这个注解的时候，就return true了~</span>
			<span class="token comment">// Tips：这里使用的是equals，所以即使目标的和Bean都标注了@Qualifier属性，value值相同才行哟~~~~</span>
			<span class="token comment">// 简单的说：只有value值相同，才会被选中的。否则这个Bean就是不符合条件的</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>targetAnnotation <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> targetAnnotation<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>annotation<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 赞。若targetAnnotation还没找到，也就是还没匹配上。仍旧还不放弃，拿到当前这个注解的所有注解属性继续尝试匹配</span>
		Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> attributes <span class="token operator">=</span> AnnotationUtils<span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span>annotation<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>attributes<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> qualifier <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 详情不描述了。这就是为什么我们吧@Qualifier标注在某个类上面都能生效的原因 就是这里做了非常强大的兼容性~</span>
	<span class="token punctuation">}</span>

<span class="token comment">// =================它最重要的两个判断=================</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>targetAnnotation <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> targetAnnotation<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>annotation<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Fall back on bean name (or alias) match</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>actualValue <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> attributeName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>AutowireCandidateQualifier<span class="token punctuation">.</span>VALUE_KEY<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
					expectedValue <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token operator">&amp;&amp;</span> bdHolder<span class="token punctuation">.</span><span class="token function">matchesName</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> expectedValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> 
<p><code>checkQualifier()</code>方法的实现，足以看到<code>Spring</code>作为一个优秀框架它对case的全面性，兼容性、灵活性的考虑还是很到位的。正因为<code>Spring</code>提供的强大的支持和灵活扩展，才给与了<code>SpringBoot、SpringCloud</code>在框架层面设计上更多可能性~</p> 
<hr> 
<hr> 
<hr> 
<h3><a id="Qualifier_251"></a><code>@Qualifier</code>高级使用</h3> 
<p><code>@Autowired</code>是根据类型进行自动装配的，当Spring容器内同一类型的Bean不止一个的时候，就需要借助<code>@Qualifier</code>来一起使用了。</p> 
<h6><a id="_253"></a>示例一：</h6> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebMvcConfiguration</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"person1"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> Person person<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> Person <span class="token function">person1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"fsx01"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> Person <span class="token function">person2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"fsx02"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>单测代码如下（下同）：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>WebMvcConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    WebMvcConfiguration bean <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>WebMvcConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 打印字段的值</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>运行后打印<code>Person(name=fsx01, age=16)</code>，完全符合预期。这也是我们对<code>@Qualifier</code>注解最常规、最简单的使用。</p> 
<h6><a id="_283"></a>示例二：</h6> 
<p><strong>若你细心的话你可能注意到了<code>@Qualifier</code>注解它允许继承（<code>@Inherited</code>）、能标注在字段上、方法上、方法参数、类上、<code>注解上</code></strong>。<br> 因此它还能这么用：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebMvcConfiguration</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@MyAnno</span> <span class="token comment">// 会把所有标注有此注解的Bean都收入囊中，请List装（因为会有多个）</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> List<span class="token generics function"><span class="token punctuation">&lt;</span>Person<span class="token punctuation">&gt;</span></span> person<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@MyAnno</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> Person <span class="token function">person1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"fsx01"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@MyAnno</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> Person <span class="token function">person2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"fsx02"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token comment">// 自定义注解：上面标注有@Qualifier注解</span>
    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>FIELD<span class="token punctuation">,</span> METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Qualifier</span>
    @<span class="token keyword">interface</span> <span class="token class-name">MyAnno</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行单测，打印<code>[Person(name=fsx01, age=16), Person(name=fsx02, age=18)]</code>，符合预期。</p> 
<h6><a id="_314"></a>实例三：</h6> 
<p>若你不想自定义注解，直接使用<code>@Qualifier</code>注解分类注入也是可以的，如下案例：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebMvcConfiguration</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"person2"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> List<span class="token generics function"><span class="token punctuation">&lt;</span>Person<span class="token punctuation">&gt;</span></span> person<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"person2"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> Person <span class="token function">person1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"fsx01"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Qualifier</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> Person <span class="token function">person2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"fsx02"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Qualifier</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> Person <span class="token function">person3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"fsx03"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行的最终结果是：</p> 
<pre><code class="prism language-java"><span class="token punctuation">[</span><span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token operator">=</span>fsx01<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token operator">=</span>fsx02<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre> 
<p>它把<code>@Qualifier</code>指定的value值相同的 或者 beanName（或者别名）相同的都注入进来了。这部分匹配代码为：</p> 
<pre><code class="prism language-java">checkQualifier方法：

<span class="token number">1</span>、头上标注的注解完全equals（类型和value值都一样，算作匹配成功）
	targetAnnotation <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> targetAnnotation<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>annotation<span class="token punctuation">)</span>
	
<span class="token number">2</span>、Fall back on bean name <span class="token punctuation">(</span>or alias<span class="token punctuation">)</span> match。若<span class="token annotation punctuation">@Qualifier</span>没匹配上，回退到BeanName的匹配，规则为：
   取头上注解的`value`属性（必须有此属性），如果beanName<span class="token operator">/</span>alias能匹配上次名称，也算最终匹配成功了
   
	actualValue <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> attributeName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>AutowireCandidateQualifier<span class="token punctuation">.</span>VALUE_KEY<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
	expectedValue <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token operator">&amp;&amp;</span> bdHolder<span class="token punctuation">.</span><span class="token function">matchesName</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> expectedValue<span class="token punctuation">)</span>

</code></pre> 
<blockquote> 
 <p>备注：使用在类上、入参上的使用比较简单，此处就不做示范了。<br> 从<code>@Qualifier</code>设计的细节可以看到，注解的<code>value</code>属性并不是必须的，所以它可以很好的使用在联合注解的场景。</p> 
</blockquote> 
<p>关于依赖注入和<code>@Qualifier</code>的使用亦需注意如下细节：</p> 
<ol><li><code>@Autowired</code>可不要写在Object类型的字段上去注入，因为容器内可以找到N多个会报错的。但是<code>List&lt;Object&gt;</code>是可以的（相当于把所有Bean都拿过来~）</li><li>可以利用<code>@Qualifier</code>这个高级特性，实现按需、按类别（不是类型）进行依赖注入，这种能力非常赞，给了框架二次开发设计者提供了更多的可能性</li></ol> 
<p>如果说指定value是按照key进行限定/匹配，那么类似<code>@LoadBalanced</code>这种注解匹配可以理解成就是按照莫一类进行归类限定了，并且自由度也更高了。</p> 
<h5><a id="_369"></a>推荐阅读</h5> 
<p><a href="https://fangshixiang.blog.csdn.net/article/details/100788040" rel="nofollow">为何一个@LoadBalanced注解就能让RestTemplate拥有负载均衡的能力？【享学Spring Cloud】</a></p> 
<h5><a id="_371"></a>总结</h5> 
<p>本文介绍<code>@Qualifier</code>高级应用场景和案例，通过结合<code>@LoadBalanced</code>对此注解的使用，应该说是能给你打开了一个新的视角去看待<code>@Qualifier</code>，甚至看待<code>Spring</code>的依赖注入，这对后续的理解、自定义扩展/使用还是蛮有意义的。</p> 
<hr> 
<h2><a id="A_376"></a>关注A哥</h2> 
<table><thead><tr><th>Author</th><th><a href="https://www.yourbatman.cn/about" rel="nofollow">A哥(YourBatman)</a></th></tr></thead><tbody><tr><td>个人站点</td><td><a href="https://www.yourbatman.cn" rel="nofollow">www.yourbatman.cn</a></td></tr><tr><td>E-mail</td><td>yourbatman@qq.com</td></tr><tr><td><strong>微 信</strong></td><td><a href="https://www.yourbatman.cn/images/wechat.png" rel="nofollow">fsx641385712</a></td></tr><tr><td><strong><code>活跃平台</code></strong></td><td><a href="https://www.yourbatman.cn" rel="nofollow"><img src="https://images2.imgbox.com/1c/90/igt5gukO_o.png" alt=""></a> <a href="https://fangshixiang.blog.csdn.net/" rel="nofollow"><img src="https://images2.imgbox.com/aa/ae/A7AN269c_o.png" alt=""></a><a href="https://yourbatman.cnblogs.com" rel="nofollow"><img src="https://images2.imgbox.com/88/86/oXoQSg5l_o.png" alt=""></a><a href="https://juejin.im/user/5b44d178f265da0fa1220efe/posts" rel="nofollow"><img src="https://images2.imgbox.com/4a/72/MEHSXYDr_o.png" alt=""></a><a href="https://www.zhihu.com/people/fangshixiang/posts" rel="nofollow"><img src="https://images2.imgbox.com/0a/0a/Aycvadrf_o.png" alt=""></a><a href="https://www.jianshu.com/u/8740f1fdd684" rel="nofollow"><img src="https://images2.imgbox.com/1f/00/YmZjf0i3_o.png" alt=""></a><a href="https://segmentfault.com/u/yourbatman/articles" rel="nofollow"><img src="https://images2.imgbox.com/d4/a2/9Ck7s7Tw_o.png" alt=""></a><a href="https://github.com/yourbatman"><img src="https://images2.imgbox.com/f7/5a/XnY7h3rG_o.png" alt=""></a></td></tr><tr><td><strong>公众号</strong></td><td><a href="https://www.yourbatman.cn/images/wechat_channel.jpg" rel="nofollow">BAT的乌托邦（ID：BAT-utopia）</a></td></tr><tr><td>知识星球</td><td><a href="https://t.zsxq.com/nQBi66I" rel="nofollow">BAT的乌托邦</a></td></tr><tr><td>每日文章推荐</td><td><a href="https://github.com/yourbatman/reading/issues">每日文章推荐</a></td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/aa/c3/RwQ9KaLs_o.gif" alt="BAT的乌托邦"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f24d3e491490f56120324fe55e58752/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mac  android studio  &amp;&amp; Xcode 快捷键</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eaa3d1847b35dbfb5d9cb5a77349bab5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">05：screen会话用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>