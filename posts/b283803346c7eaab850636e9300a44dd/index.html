<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaScript职责链模式与开发实践（下） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaScript职责链模式与开发实践（下）" />
<meta property="og:description" content="前言 作为一个前端切图仔，少有和各类设计模式打交道。但这不影响我们学习设计模式的思维，来提升我们的代码水平。
本章通过讲解职责链模式，希望能够让你对设计模式更一步的学习。
本章学习内容👇
灵活可拆分的职责链模式 灵活可拆分的职责链模式 在上一章，《JavaScript职责链模式与开发实践（中）》
我们将大段的条件判断函数拆分为了三个小函数，并用职责链模式模式串联起来了这些模块。虽然解决了大量使用条件分支的语句，但这依然还存在一些问题：
function orderMember(seniorMember, price) { if (seniorMember) { return orderSeniorMember(price) } else { return price * 0.95 } } 可以看到，在职责链的传递上非常僵硬，链上的下一段函数直接被耦合在了业务函数之中。这是违反开放-封闭原则（OCP，Open Closed Principle）是所有面向对象原则的核心。如果以后我们的会员还要再分钻石会员以及大会员等等就意味着必须改动这些业务函数内部。这会扰乱我们之前所构建的链条，就像在已经创建好的数组我们去改变其中每一个元素的顺序而导致整个数组偏移的后果。
接下来， 我们通过对职责链节点进行一层工厂化包装来解决这个问题👇
首先，我们先解除之前三个函数节点的耦合。并在需要传递给下一层请求时，我们通过返回一个字符串nextSuccessor表示。
​ function orderNormal(userType, seniorMember, stock, price) { if (userType === 0) { if (stock &gt; 0) { console.log(price * 0.99) } else { console.log(false) } } else { return &#39;nextSuccessor&#39;; //向职责链后继节点传递请求 } } ​ function orderMember(userType, seniorMember, stock, price) { if (seniorMember == 0) { return &#39;nextSuccessor&#39;; //向职责链后继节点传递请求 } else { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b283803346c7eaab850636e9300a44dd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-11T16:38:18+08:00" />
<meta property="article:modified_time" content="2023-01-11T16:38:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript职责链模式与开发实践（下）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>作为一个<code>前端切图仔</code>，少有和各类设计模式打交道。但这不影响我们学习设计模式的思维，来提升我们的代码水平。</p> 
<p>本章通过讲解<code>职责链模式</code>，希望能够让你对设计模式更一步的学习。</p> 
<p>本章学习内容👇</p> 
<ul><li>灵活可拆分的职责链模式</li></ul> 
<h3><a id="_10"></a>灵活可拆分的职责链模式</h3> 
<blockquote> 
 <p>在上一章，<a href="https://juejin.cn/post/7135287380377862157" rel="nofollow">《JavaScript职责链模式与开发实践（中）》</a></p> 
</blockquote> 
<p>我们将大段的条件判断函数拆分为了三个小函数，并用<code>职责链模式</code>模式串联起来了这些模块。虽然解决了大量使用条件分支的语句，但这依然还存在一些问题：</p> 
<pre><code>function orderMember(seniorMember, price) {
    if (seniorMember) {
       return orderSeniorMember(price)
    } else {
        return price * 0.95
    }
}
</code></pre> 
<p>可以看到，在<code>职责链</code>的传递上非常僵硬，链上的下一段函数直接被耦合在了业务函数之中。这是违反<strong>开放-封闭原则</strong>（<code>OCP</code>，Open Closed Principle）是所有面向对象原则的核心。如果以后我们的会员还要再分<code>钻石会员</code>以及<code>大会员</code>等等就意味着必须改动这些业务函数内部。这会扰乱我们之前所构建的<code>链条</code>，就像在已经创建好的数组我们去改变其中每一个元素的顺序而导致整个数组偏移的后果。</p> 
<p><strong>接下来，</strong> 我们通过对<code>职责链</code>节点进行一层工厂化包装来解决这个问题👇</p> 
<p><strong>首先</strong>，我们先解除之前三个<code>函数节点</code>的耦合。并在需要传递给下一层请求时，我们通过返回一个字符串<code>nextSuccessor</code>表示。</p> 
<pre><code>​
function orderNormal(userType, seniorMember, stock, price) {
    if (userType === 0) {
        if (stock &gt; 0) {
            console.log(price * 0.99)
        } else {
            console.log(false)
        }
    } else {
        return 'nextSuccessor'; //向职责链后继节点传递请求
    }
}
​
function orderMember(userType, seniorMember, stock, price) {
    if (seniorMember == 0) {
        return 'nextSuccessor'; //向职责链后继节点传递请求
    } else {
        console.log(price * 0.95)
    }
}
​
function orderSeniorMember(userType, seniorMember, stock, price) {
    if (userType === 1 &amp;&amp; seniorMember == 1) {
         console.log(price * 0.91)
    }
}
​
</code></pre> 
<p><strong>接着，</strong> 我们定义一个构造函数<code>Chain</code>，使它接受一个函数作为该节点运行的函数，同时他还拥有俩个<strong>属性和方法</strong>:</p> 
<ul><li><code>fn</code>当前的运行节点函数</li><li><code>successor</code>下一个节点</li></ul> 
 
<ul><li><code>Chain.prototype.setNextSuccessor</code>指定在链中的下一个节点</li><li><code>Chain.prototype.passRequest</code>传递请求给某个节点</li></ul> 
<pre><code>let Chain = function (fn) {
    this.fn = fn;
    this.successor = null;
};
Chain.prototype.setNextSuccessor = function (successor) {
    return this.successor = successor;
};
Chain.prototype.passRequest = function () {
    var ret = this.fn.apply(this, arguments);
    if (ret === 'nextSuccessor') {
        return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments);
    }
    return ret;
};
</code></pre> 
<p><strong>然后，</strong> 我们通过这个工厂实例化包装下我们的节点，并测试运行。</p> 
<pre><code>var chainOrderSenior = new Chain(orderSeniorMember);
var chainOrderMember = new Chain(orderMember);
var chainOrderNormal = new Chain(orderNormal);
​
chainOrderMember.setNextSuccessor(chainOrderSenior);
chainOrderNormal.setNextSuccessor(chainOrderMember);
​
chainOrderNormal.passRequest(1, false, 1, 100)
</code></pre> 
<p><strong>控制台输出</strong></p> 
<pre><code>95
</code></pre> 
<p>完成🤩。这样下次我们需要追加新的会员等级或者其他条件时，只需要设置在对应节点设置后继节点即可。</p> 
<p>\</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a52233ec94a619a4de2df3134216fd76/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript职责链模式与开发实践（中）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e4d91d8aff3ee2bcdc37d44fb68709b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决“ImportError: Missing optional dependency ‘pytables‘. Use pip or conda to install pytables.”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>