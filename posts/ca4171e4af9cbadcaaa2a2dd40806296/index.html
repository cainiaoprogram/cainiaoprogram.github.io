<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>目标检测中NMS和mAP指标中的的IoU阈值和置信度阈值 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="目标检测中NMS和mAP指标中的的IoU阈值和置信度阈值" />
<meta property="og:description" content="有时候路走的太远，会忘了为什么要出发。
学习亦如是
在目标检测中，经常看到置信度阈值和IoU阈值这两个关键参数，且NMS计算和mAP计算中都会有这两个，那它们的区别是什么?本文就这个问题做一次总结。
NMS 模型预测会输出很多框，比如同一个目标会有很多框对应，NMS的作用是删除重复框，保留置信度分数最大的框。
在NMS算法中有一个置信度阈值c和IoU阈值u，简单回顾NMS算法如下：
对于一个预测框集合B（B中包含很多个预测框和它们对应的score）
找出B中score分数最高的M将M从B中删除将删除的M添加进最后的集合D将B中所有的box与M进行IoU计算，删除B中 IoU &gt; u的所有对应box
重复上面的步骤 最后D中的框就是保留下来的，留下的框中，删除掉低于score阈值的框，剩下的就是最终的预测框。
所以，这里的置信度阈值c是过滤掉预测框中置信度分数低于c的box；IoU阈值指的是拿出score分数最高框的其余框与score分数最高框的一个IoU比较。
注意到上面的NMS流程并没有对box的score做排序的过程。其实还有其它实现方式：
先对B中所有的box的score做排序，拿出score最高的box（这里当做M，从大到小排序就是首个box）放在别的list D，然后用B中其余的box分别与M计算IoU，去掉IoU &gt; u 的box重复上面步骤。 一样的，利用置信度阈值c对D中的box在做一次过滤，剩下的就是最后输出的。
对于利用置信度阈值c过滤，可以在没开始NMS前就做过滤，也可以在NMS后做过滤，这个不影响，看代码怎么实现。
Faster RCNN中的nms代码实现如下：
def py_cpu_nms(dets, thresh): #首先数据赋值和计算对应矩形框的面积 #dets的数据格式是dets[[xmin,ymin,xmax,ymax,scores]....] x1 = dets[:,0] y1 = dets[:,1] x2 = dets[:,2] y2 = dets[:,3] areas = (y2-y1&#43;1) * (x2-x1&#43;1) scores = dets[:,4] print(&#39;areas &#39;,areas) print(&#39;scores &#39;,scores) #这边的keep用于存放，NMS后剩余的方框 keep = [] #取出分数从大到小排列的索引。.argsort()是从小到大排列，[::-1]是列表头和尾颠倒一下。 index = scores.argsort()[::-1] print(index) #上面这两句比如分数[0.72 0.8 0.92 0.72 0.81 0.9 ] # 对应的索引index[ 2 5 4 1 3 0 ]记住是取出索引，scores列表没变。 #index会剔除遍历过的方框，和合并过的方框。 while index." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ca4171e4af9cbadcaaa2a2dd40806296/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-29T00:01:22+08:00" />
<meta property="article:modified_time" content="2023-06-29T00:01:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">目标检测中NMS和mAP指标中的的IoU阈值和置信度阈值</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>有时候路走的太远，会忘了为什么要出发。<br> 学习亦如是</p> 
<p>在目标检测中，经常看到置信度阈值和IoU阈值这两个关键参数，且NMS计算和mAP计算中都会有这两个，那它们的区别是什么?本文就这个问题做一次总结。</p> 
<h2><a id="NMS_6"></a>NMS</h2> 
<p>模型预测会输出很多框，比如同一个目标会有很多框对应，NMS的作用是删除重复框，保留置信度分数最大的框。<br> <img src="https://images2.imgbox.com/89/5e/rLFAZh5j_o.png" alt="在这里插入图片描述"><br> 在NMS算法中有一个<strong>置信度阈值c</strong>和<strong>IoU阈值u</strong>，简单回顾NMS算法如下：</p> 
<p>对于一个预测框集合<strong>B</strong>（B中包含很多个预测框和它们对应的score）</p> 
<ol><li>找出<strong>B</strong>中score分数最高的<strong>M</strong></li><li>将<strong>M</strong>从<strong>B</strong>中删除</li><li>将删除的<strong>M</strong>添加进最后的集合<strong>D</strong></li><li>将<strong>B</strong>中所有的box与<strong>M</strong>进行IoU计算，删除<strong>B</strong>中 IoU &gt; u的所有对应box<br> 重复上面的步骤</li></ol> 
<p>最后<strong>D</strong>中的框就是保留下来的，留下的框中，删除掉低于score阈值的框，剩下的就是最终的预测框。</p> 
<p><mark>所以，这里的置信度阈值c是过滤掉预测框中置信度分数低于c的box；IoU阈值指的是拿出score分数最高框的其余框与score分数最高框的一个IoU比较。</mark></p> 
<p>注意到上面的NMS流程并没有对box的score做排序的过程。其实还有其它实现方式：</p> 
<ol><li>先对<strong>B</strong>中所有的box的score做排序，</li><li>拿出score最高的box（这里当做<strong>M</strong>，从大到小排序就是首个box）放在别的list <strong>D</strong>，</li><li>然后用<strong>B</strong>中其余的box分别与<strong>M</strong>计算IoU，去掉IoU &gt; u 的box</li><li>重复上面步骤。</li></ol> 
<p>一样的，利用置信度阈值c对<strong>D</strong>中的box在做一次过滤，剩下的就是最后输出的。</p> 
<p><mark>对于利用置信度阈值c过滤，可以在没开始<strong>NMS</strong>前就做过滤，也可以在<strong>NMS</strong>后做过滤，这个不影响，看代码怎么实现。</mark></p> 
<p>Faster RCNN中的nms代码实现如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">py_cpu_nms</span><span class="token punctuation">(</span>dets<span class="token punctuation">,</span> thresh<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment">#首先数据赋值和计算对应矩形框的面积</span>
    <span class="token comment">#dets的数据格式是dets[[xmin,ymin,xmax,ymax,scores]....]</span>
 
    x1 <span class="token operator">=</span> dets<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
    y1 <span class="token operator">=</span> dets<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
    x2 <span class="token operator">=</span> dets<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
    y2 <span class="token operator">=</span> dets<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
    areas <span class="token operator">=</span> <span class="token punctuation">(</span>y2<span class="token operator">-</span>y1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x2<span class="token operator">-</span>x1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
    scores <span class="token operator">=</span> dets<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'areas  '</span><span class="token punctuation">,</span>areas<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'scores '</span><span class="token punctuation">,</span>scores<span class="token punctuation">)</span>
 
    <span class="token comment">#这边的keep用于存放，NMS后剩余的方框</span>
    keep <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    
    <span class="token comment">#取出分数从大到小排列的索引。.argsort()是从小到大排列，[::-1]是列表头和尾颠倒一下。</span>
    index <span class="token operator">=</span> scores<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> 
    <span class="token comment">#上面这两句比如分数[0.72 0.8  0.92 0.72 0.81 0.9 ]    </span>
    <span class="token comment">#  对应的索引index[  2   5    4     1    3   0  ]记住是取出索引，scores列表没变。</span>
    
    <span class="token comment">#index会剔除遍历过的方框，和合并过的方框。 </span>
    <span class="token keyword">while</span> index<span class="token punctuation">.</span>size <span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>index<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
        <span class="token comment">#取出第一个方框进行和其他方框比对，看有没有可以合并的</span>
        i <span class="token operator">=</span> index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>       <span class="token comment"># every time the first is the biggst, and add it directly</span>
        
        <span class="token comment">#因为我们这边分数已经按从大到小排列了。</span>
        <span class="token comment">#所以如果有合并存在，也是保留分数最高的这个，也就是我们现在那个这个</span>
        <span class="token comment">#keep保留的是索引值，不是具体的分数。     </span>
        keep<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>keep<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'x1'</span><span class="token punctuation">,</span>x1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>x1<span class="token punctuation">[</span>index<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
 
        <span class="token comment">#计算交集的左上角和右下角</span>
        <span class="token comment">#这里要注意，比如x1[i]这个方框的左上角x和所有其他的方框的左上角x的</span>
        x11 <span class="token operator">=</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>x1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> x1<span class="token punctuation">[</span>index<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># calculate the points of overlap </span>
        y11 <span class="token operator">=</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>y1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y1<span class="token punctuation">[</span>index<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        x22 <span class="token operator">=</span> np<span class="token punctuation">.</span>minimum<span class="token punctuation">(</span>x2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> x2<span class="token punctuation">[</span>index<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        y22 <span class="token operator">=</span> np<span class="token punctuation">.</span>minimum<span class="token punctuation">(</span>y2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y2<span class="token punctuation">[</span>index<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        
        <span class="token keyword">print</span><span class="token punctuation">(</span>x11<span class="token punctuation">,</span>y11<span class="token punctuation">,</span>x22<span class="token punctuation">,</span>y22<span class="token punctuation">)</span>
        <span class="token comment">#这边要注意，如果两个方框相交，X22-X11和Y22-Y11是正的。</span>
        <span class="token comment">#如果两个方框不相交，X22-X11和Y22-Y11是负的，我们把不相交的W和H设为0.</span>
        w <span class="token operator">=</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x22<span class="token operator">-</span>x11<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    
        h <span class="token operator">=</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> y22<span class="token operator">-</span>y11<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    
       
        <span class="token comment">#计算重叠面积就是上面说的交集面积。不相交因为W和H都是0，所以不相交面积为0</span>
        overlaps <span class="token operator">=</span> w<span class="token operator">*</span>h
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'overlaps is'</span><span class="token punctuation">,</span>overlaps<span class="token punctuation">)</span>
        
        <span class="token comment">#这个就是IOU公式（交并比）。</span>
        <span class="token comment">#得出来的ious是一个列表，里面拥有当前方框和其他所有方框的IOU结果。</span>
        ious <span class="token operator">=</span> overlaps <span class="token operator">/</span> <span class="token punctuation">(</span>areas<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>areas<span class="token punctuation">[</span>index<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> overlaps<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'ious is'</span><span class="token punctuation">,</span>ious<span class="token punctuation">)</span>
        
        <span class="token comment">#接下来是合并重叠度最大的方框，也就是合并ious中值大于thresh的方框</span>
        <span class="token comment">#我们合并的操作就是把他们剔除，因为我们合并这些方框只保留下分数最高的。</span>
        <span class="token comment">#我们经过排序当前我们操作的方框就是分数最高的，所以我们剔除其他和当前重叠度最高的方框</span>
        <span class="token comment">#这里np.where(ious&lt;=thresh)[0]是一个固定写法。</span>
        idx <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>ious<span class="token operator">&lt;=</span>thresh<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span>
 
        <span class="token comment">#把留下来框在进行NMS操作</span>
        <span class="token comment">#这边留下的框是去除当前操作的框，和当前操作的框重叠度大于thresh的框</span>
        <span class="token comment">#每一次都会先去除当前操作框，所以索引的列表就会向前移动移位，要还原就+1，向后移动一位</span>
        index <span class="token operator">=</span> index<span class="token punctuation">[</span>idx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>   <span class="token comment"># because index start from 1</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>
    <span class="token keyword">return</span> keep
</code></pre> 
<h2><a id="mAP_109"></a>mAP</h2> 
<p>mAP就是平均的平均精度，首先计算每一个类别的AP（平均精度），然后所有类别的AP相加除以类别数目m，就得到mAP。</p> 
<p><mark>对于PASCAL VOC数据集，固定IoU阈值（0.5），移动置信度阈值</mark><br> 对于每一个类别的AP计算，简要过程如下：<br> 设定一个置信度阈值c和IoU阈值u。对于经过NMS的最终预测结果，我们对结果按照它们的score分数做降序排列，然后以置信度阈值c为标准，将score&gt;c的预测框定义为正样本，然后对这些正样本进行计算Precision和Recall，这样就得到一个pr曲线上的点（横坐标是reall，纵坐标是Precision）。<br> 固定住IoU阈值u不动，改变置信度阈值c，那么就会计算得到其它不同的pr点。<br> 将所有点连接起来，就得到pr曲线了，求pr曲线下的面积就是该类别的AP。</p> 
<p><mark>对于COCO数据集，是固定住置信度阈值，移动IoU阈值</mark></p> 
<p><a href="https://blog.csdn.net/u010712012/article/details/85108738">https://blog.csdn.net/u010712012/article/details/85108738</a><br> <a href="https://blog.csdn.net/qq_16540387/article/details/81912289?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase">https://blog.csdn.net/qq_16540387/article/details/81912289?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41b34c1579980b303da5284d983bca82/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">tensorRt部署原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/929fbec8ac6360338493c158b9a77fea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux中配置sudo用户访问权限</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>