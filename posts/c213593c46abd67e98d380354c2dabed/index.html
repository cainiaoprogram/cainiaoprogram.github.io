<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 8系列之Stream的强大工具Collector - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 8系列之Stream的强大工具Collector" />
<meta property="og:description" content="Stream系列：
Java 8系列之Stream的基本语法详解Java 8系列之Stream的强大工具CollectorJava 8系列之重构和定制收集器Java 8系列之Stream中万能的reduce 概述 前面我们使用过collect(toList())，在流中生成列表。实际开发过程中，List又是我们经常用到的数据结构，但是有时候我们也希望Stream能够转换生成其他的值，比如Map或者set，甚至希望定制生成想要的数据结构。
collect也就是收集器，是Stream一种通用的、从流生成复杂值的结构。只要将它传给collect方法，也就是所谓的转换方法，其就会生成想要的数据结构。这里不得不提下，Collectors这个工具库，在该库中封装了相应的转换方法。当然，Collectors工具库仅仅封装了常用的一些情景，如果有特殊需求，那就要自定义了。
显然，List是能想到的从流中生成的最自然的数据结构， 但是有时人们还希望从流生成其他值， 比如 Map 或 Set， 或者你希望定制一个类将你想要的东西抽象出来。
前面已经讲过，仅凭流上方法的签名，就能判断出这是否是一个及早求值的操作。 reduce操作就是一个很好的例子， 但有时人们希望能做得更多。 这就是收集器，一种通用的、从流生成复杂值的结构。只要将它传给collect 方法，所有的流就都可以使用它了。
&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);
&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);
辅助接口 Supplier Supplier&lt;T&gt;接口是一个函数接口，该接口声明了一个get方法，主要用来创建返回一个指定数据类型的对象。
T：指定的数据类型
@FunctionalInterface public interface Supplier { T get(); }
BiConsumer BiConsumer&lt;T, U&gt;接口是一个函数接口，该接口声明了accept方法，并无返回值，该函数接口主要用来声明一些预期操作。
同时，该接口定义了一个默认方法andThen，该方法接受一个BiConsumer，并返回一个组合的BiConsumer，其会按照顺序执行操作。如果执行任一操作抛出异常，则将其传递给组合操作的调用者。 如果执行此操作抛出异常，将不执行后操作(after)。
@FunctionalInterface public interface BiConsumer&lt;T, U&gt; { void accept(T t, U u); default BiConsumer&lt;T, U&gt; andThen(BiConsumer&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c213593c46abd67e98d380354c2dabed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-02-10T16:18:15+08:00" />
<meta property="article:modified_time" content="2017-02-10T16:18:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 8系列之Stream的强大工具Collector</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Stream系列：</p> 
<p><font size="4"></font></p> 
<ul><li><a href="http://blog.csdn.net/IO_Field/article/details/54971761">Java 8系列之Stream的基本语法详解</a></li><li><a href="http://blog.csdn.net/IO_Field/article/details/54971608">Java 8系列之Stream的强大工具Collector</a></li><li><a href="http://blog.csdn.net/io_field/article/details/54971555">Java 8系列之重构和定制收集器</a></li><li><a href="http://blog.csdn.net/IO_Field/article/details/54971679">Java 8系列之Stream中万能的reduce</a> <br> </li></ul> 
<h2 id="概述">概述</h2> 
<p>前面我们使用过collect(toList())，在流中生成列表。实际开发过程中，List又是我们经常用到的数据结构，但是有时候我们也希望Stream能够转换生成其他的值，比如Map或者set，甚至希望定制生成想要的数据结构。</p> 
<p>collect也就是收集器，是Stream一种通用的、从流生成复杂值的结构。只要将它传给collect方法，也就是所谓的转换方法，其就会生成想要的数据结构。这里不得不提下，Collectors这个工具库，在该库中封装了相应的转换方法。当然，Collectors工具库仅仅封装了常用的一些情景，如果有特殊需求，那就要自定义了。</p> 
<p>显然，List是能想到的从流中生成的最自然的数据结构， 但是有时人们还希望从流生成其他值， 比如 Map 或 Set， 或者你希望定制一个类将你想要的东西抽象出来。</p> 
<p>前面已经讲过，仅凭流上方法的签名，就能判断出这是否是一个及早求值的操作。 reduce操作就是一个很好的例子， 但有时人们希望能做得更多。 <br> 这就是收集器，一种通用的、从流生成复杂值的结构。只要将它传给collect 方法，所有的流就都可以使用它了。</p> 
<p>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</p> 
<p>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, <br> BiConsumer&lt;R, ? super T&gt; accumulator, <br> BiConsumer&lt;R, R&gt; combiner);</p> 
<h2 id="辅助接口">辅助接口</h2> 
<h3 id="supplier">Supplier</h3> 
<p>Supplier&lt;T&gt;接口是一个函数接口，该接口声明了一个get方法，主要用来创建返回一个指定数据类型的对象。</p> 
<ul><li><p>T：指定的数据类型</p> <p>@FunctionalInterface <br> public interface Supplier { <br> T get(); <br> }</p></li></ul> 
<h3 id="biconsumer">BiConsumer</h3> 
<p>BiConsumer&lt;T, U&gt;接口是一个函数接口，该接口声明了accept方法，并无返回值，该函数接口主要用来声明一些预期操作。</p> 
<p>同时，该接口定义了一个默认方法andThen，该方法接受一个BiConsumer，并返回一个组合的BiConsumer，其会按照顺序执行操作。如果执行任一操作抛出异常，则将其传递给组合操作的调用者。 如果执行此操作抛出异常，将不执行后操作(after)。</p> 
<pre><code>@FunctionalInterface
public interface BiConsumer&lt;T, U&gt; {

    void accept(T t, U u);

    default BiConsumer&lt;T, U&gt; andThen(BiConsumer&lt;? super T, ? super U&gt; after) {
        Objects.requireNonNull(after);

        return (l, r) -&gt; {
            accept(l, r);
            after.accept(l, r);
        };
    }
}
</code></pre> 
<h3 id="binaryoperator">BinaryOperator</h3> 
<p>BinaryOperator接口继承于BiFunction接口，该接口指定了apply方法执行的参数类型及返回值类型均为T。</p> 
<pre><code>@FunctionalInterface
public interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; {

    public static &lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator) {
        Objects.requireNonNull(comparator);
        return (a, b) -&gt; comparator.compare(a, b) &lt;= 0 ? a : b;
    }

    public static &lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator) {
        Objects.requireNonNull(comparator);
        return (a, b) -&gt; comparator.compare(a, b) &gt;= 0 ? a : b;
    }
}

@FunctionalInterface
public interface BiFunction&lt;T, U, R&gt; {


    R apply(T t, U u);

    default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
        Objects.requireNonNull(after);
        return (T t, U u) -&gt; after.apply(apply(t, u));
    }
}
</code></pre> 
<h3 id="function">Function</h3> 
<p>Funtion是一个函数接口，其内定义了一个转换函数，将T转换为R。比如Stream中的map方法便是接受该函数参数，将T转换为R。</p> 
<pre><code>@FunctionalInterface
public interface Function&lt;T, R&gt; {

    /**
     * 转换函数，将T转换为R
     */
    R apply(T t);

    /**
     * 返回一个组合函数Function，首先执行before,然后再执行该Function
     *
     * 如果两个函数的求值都抛出异常，它将被中继到组合函数的调用者。
     * 如果before为null，将会抛出NullPointerException
     */
    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {
        Objects.requireNonNull(before);
        return (V v) -&gt; apply(before.apply(v));
    }

     /**
     * 返回一个组合函数Function，首先执行Function,然后再执行after
     *
     * 如果两个函数的求值都抛出异常，它将被中继到组合函数的调用者。
     * 如果after为null，将会抛出NullPointerException
     */
    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&gt; after.apply(apply(t));
    }

    /**
     * 将输入参数返回的函数
     */
    static &lt;T&gt; Function&lt;T, T&gt; identity() {
        return t -&gt; t;
    }
}
</code></pre> 
<h2 id="collector">Collector</h2> 
<p>Collector是Stream的可变减少操作接口，可变减少操作包括：将元素累积到集合中，使用StringBuilder连接字符串;计算元素相关的统计信息，例如sum，min，max或average等。Collectors(类收集器)提供了许多常见的可变减少操作的实现。</p> 
<p>Collector&lt;T, A, R&gt;接受三个泛型参数，对可变减少操作的数据类型作相应限制：</p> 
<ul><li>T：输入元素类型</li><li>A：缩减操作的可变累积类型（通常隐藏为实现细节）</li><li>R：可变减少操作的结果类型</li></ul> 
<p>Collector接口声明了4个函数，这四个函数一起协调执行以将元素目累积到可变结果容器中，并且可以选择地对结果进行最终的变换.</p> 
<ul><li>Supplier&lt;A&gt; supplier(): 创建新的结果结</li><li>BiConsumer&lt;A, T&gt; accumulator(): 将元素添加到结果容器</li><li>BinaryOperator&lt;A&gt; combiner(): 将两个结果容器合并为一个结果容器</li><li>Function&lt;A, R&gt; finisher(): 对结果容器作相应的变换</li></ul> 
<p>在Collector接口的characteristics方法内，可以对Collector声明相关约束</p> 
<ul><li>Set&lt;Characteristics&gt; characteristics():</li></ul> 
<p>而Characteristics是Collector内的一个枚举类，声明了CONCURRENT、UNORDERED、IDENTITY_FINISH等三个属性，用来约束Collector的属性。</p> 
<ul><li>CONCURRENT：表示此收集器支持并发，意味着允许在多个线程中，累加器可以调用结果容器</li><li>UNORDERED：表示收集器并不按照Stream中的元素输入顺序执行</li><li><p>IDENTITY_FINISH：表示finisher实现的是识别功能，可忽略。 <br> 注：</p> 
  <ol><li>如果一个容器仅声明CONCURRENT属性，而不是UNORDERED属性，那么该容器仅仅支持无序的Stream在多线程中执行。</li></ol></li></ul> 
<h2 id="身份约束和相关性约束">身份约束和相关性约束</h2> 
<p>Stream可以顺序执行，或者并发执行，或者顺序并发执行，为了保证Stream可以产生相同的结果，收集器函数必须满足身份约束和相关项约束。</p> 
<p>身份约束说，对于任何部分累积的结果，将其与空结果容器组合必须产生等效结果。也就是说，对于作为任何系列的累加器和组合器调用的结果的部分累加结果a，a必须等于combiner.apply（a，supplier.get（））。</p> 
<p>相关性约束说，分裂计算必须产生等效的结果。也就是说，对于任何输入元素t1和t2，以下计算中的结果r1和r2必须是等效的：</p> 
<pre><code>A a1 = supplier.get（）;
accumulator.accept（a1，t1）;
accumulator.accept（a1，t2）;
R r1 = finisher.apply（a1）; // result without splitting

A a2 = supplier.get（）;
accumulator.accept（a2，t1）;
A a3 = supplier.get（）;
accumulator.accept（a3，t2）;
R r2 = finisher.apply（combiner.apply（a2，a3））; 
</code></pre> 
<h2 id="创建collector">创建Collector</h2> 
<h3 id="自定义collector">自定义Collector</h3> 
<p><a href="http://blog.csdn.net/io_field/article/details/54971555">Java 8系列之重构和定制收集器</a></p> 
<h3 id="基于collector工具库">基于Collector工具库</h3> 
<p>在Collector工具库中，声明了许多常用的收集器,以供我们快速创建一个收集器。前面我们已经了解到，收集器函数必须满足身份约束和相关项约束。而基于Collector实现简化的库（如Stream.collect（Collector））创建收集器时，必须遵守以下约束：</p> 
<ol><li>第一个参数传递给accumulator()函数，两个参数都传递给combiner()函数，传递给finisher()函数的参数必须是上一次调用supplier()，accumulator()或combiner()函数的结果。</li><li>实现不应该对任何accumulator()，combiner()或finisher()函数的结果做任何事情，除非收集器将返回的结果返回给调用者</li><li>如果结果传递到combiner()或finisher()函数，而且返回对象与传入的不相同，则不会再将对象传递给accumulator()函数调用。</li><li>一旦结果传递到combiner()或finisher()函数，它就不会再次传递到accumulator()函数。</li><li>对于串行收集器，supplier()，accumulator()或combiner()函数返回的任何结果必须是限制串行的。这使得收集器可以并行进行，而收集器不需要执行任何额外的同步。reduce操作实现必须管理Stream的元素被正确区别并分别处理，并且仅在累积完成之后，对累加器中的数据合并。</li><li>对于并发收集器，实现可以自由地（但不是必须）同时实现reduce操作。accumulator()可以在多个线程同时调用，而不是在累积期间保持结果的独立性。仅当收集器具有Collector.Characteristics.UNORDERED特性或者原始数据是无序的时才应用并发还原。</li></ol> 
<h2 id="转换成其他集合">转换成其他集合</h2> 
<p>对于前面提到了很多Stream的链式操作，但是，我们总是要将Strea生成一个集合，比如：</p> 
<ul><li>已有代码是为集合编写的， 因此需要将流转换成集合传入；</li><li>在集合上进行一系列链式操作后， 最终希望生成一个值；</li><li>写单元测试时， 需要对某个具体的集合做断言。</li></ul> 
<p>有些Stream可以转成集合，比如前面提到toList,生成了java.util.List 类的实例。当然了，还有还有toSet和toCollection，分别生成 Set和Collection 类的实例。</p> 
<h3 id="tolist">toList</h3> 
<p>示例：</p> 
<pre><code>List&lt;Integer&gt; collectList = Stream.of(1, 2, 3, 4)
        .collect(Collectors.toList());
System.out.println("collectList: " + collectList);
// 打印结果
// collectList: [1, 2, 3, 4]
</code></pre> 
<h3 id="toset">toSet</h3> 
<p>示例：</p> 
<pre><code>Set&lt;Integer&gt; collectSet = Stream.of(1, 2, 3, 4)
        .collect(Collectors.toSet());
System.out.println("collectSet: " + collectSet);
// 打印结果
// collectSet: [1, 2, 3, 4]
</code></pre> 
<h3 id="tocollection">toCollection</h3> 
<p>通常情况下，创建集合时需要调用适当的构造函数指明集合的具体类型：</p> 
<pre><code>List&lt;Artist&gt; artists = new ArrayList&lt;&gt;();
</code></pre> 
<p>但是调用toList或者toSet方法时，不需要指定具体的类型，Stream类库会自动推断并生成合适的类型。当然，有时候我们对转换生成的集合有特定要求，比如，希望生成一个TreeSet,而不是由Stream类库自动指定的一种类型。此时使用toCollection，它接受一个函数作为参数， 来创建集合。</p> 
<p>值得我们注意的是，看Collectors的源码，因为其接受的函数参数必须继承于Collection，也就是意味着Collection并不能转换所有的继承类，最明显的就是不能通过toCollection转换成Map</p> 
<h3 id="tomap">toMap</h3> 
<p>如果生成一个Map,我们需要调用toMap方法。由于Map中有Key和Value这两个值，故该方法与toSet、toList等的处理方式是不一样的。toMap最少应接受两个参数，一个用来生成key，另外一个用来生成value。toMap方法有三种变形：</p> 
<ul><li><p>toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper)</p> 
  <ol><li>keyMapper: 该Funtion用来生成Key</li><li>valueMapper：该Funtion用来生成value</li></ol></li></ul> 
<p><font color="#ff0000">注：若Stream中有重复的值,导致Map中key重复，在运行时会报异常java.lang.IllegalStateException: Duplicate key **</font></p> 
<ul><li><p>toMap(Function</p></li></ul> 
<h2 id="转成值">转成值</h2> 
<p>使用collect可以将Stream转换成值。maxBy和minBy允许用户按照某个特定的顺序生成一个值。</p> 
<ul><li>averagingDouble:求平均值，Stream的元素类型为double</li><li>averagingInt:求平均值，Stream的元素类型为int</li><li>averagingLong:求平均值，Stream的元素类型为long</li><li>counting:Stream的元素个数</li><li>maxBy:在指定条件下的，Stream的最大元素</li><li>minBy:在指定条件下的，Stream的最小元素</li><li>reducing: reduce操作</li><li>summarizingDouble:统计Stream的数据(double)状态，其中包括count，min，max，sum和平均。</li><li>summarizingInt:统计Stream的数据(int)状态，其中包括count，min，max，sum和平均。</li><li>summarizingLong:统计Stream的数据(long)状态，其中包括count，min，max，sum和平均。</li><li>summingDouble:求和，Stream的元素类型为double</li><li>summingInt:求和，Stream的元素类型为int</li><li>summingLong:求和，Stream的元素类型为long</li></ul> 
<p>示例：</p> 
<pre><code>Optional&lt;Integer&gt; collectMaxBy = Stream.of(1, 2, 3, 4)
            .collect(Collectors.maxBy(Comparator.comparingInt(o -&gt; o)));
System.out.println("collectMaxBy:" + collectMaxBy.get());
// 打印结果
// collectMaxBy:4
</code></pre> 
<h2 id="分割数据块">分割数据块</h2> 
<p>collect的一个常用操作将Stream分解成两个集合。假如一个数字的Stream，我们可能希望将其分割成两个集合，一个是偶数集合，另外一个是奇数集合。我们首先想到的就是过滤操作，通过两次过滤操作，很简单的就完成了我们的需求。</p> 
<p>但是这样操作起来有问题。首先，为了执行两次过滤操作，需要有两个流。其次，如果过滤操作复杂，每个流上都要执行这样的操作， 代码也会变得冗余。</p> 
<p>这里我们就不得不说Collectors库中的partitioningBy方法，它接受一个流，并将其分成两部分：使用Predicate对象，指定条件并判断一个元素应该属于哪个部分，并根据布尔值返回一个Map到列表。因此对于key为true所对应的List中的元素，满足Predicate对象中指定的条件；同样，key为false所对应的List中的元素,不满足Predicate对象中指定的条件</p> 
<p><img src="https://images2.imgbox.com/06/69/VGxa2rlc_o.png" alt="这里写图片描述" title=""></p> 
<p>这样，使用partitioningBy，我们就可以将数字的Stream分解成奇数集合和偶数集合了。</p> 
<pre><code> Map&lt;Boolean, List&lt;Integer&gt;&gt; collectParti = Stream.of(1, 2, 3, 4)
            .collect(Collectors.partitioningBy(it -&gt; it % 2 == 0));
System.out.println("collectParti : " + collectParti);
// 打印结果
// collectParti : {false=[1, 3], true=[2, 4]}
</code></pre> 
<h2 id="数据分组">数据分组</h2> 
<p>数据分组是一种更自然的分割数据操作， 与将数据分成true和false两部分不同，可以使用任意值对数据分组。</p> 
<p>调用Stream的collect方法，传入一个收集器,groupingBy接受一个分类函数，用来对数据分组，就像partitioningBy一样，接受一个 <br> Predicate对象将数据分成true和false两部分。我们使用的分类器是一个Function对象，和map操作用到的一样。</p> 
<p><img src="https://images2.imgbox.com/6b/86/rjBDElix_o.png" alt="这里写图片描述" title=""></p> 
<p>示例：</p> 
<pre><code>Map&lt;Boolean, List&lt;Integer&gt;&gt; collectGroup= Stream.of(1, 2, 3, 4)
            .collect(Collectors.groupingBy(it -&gt; it &gt; 3));
System.out.println("collectGroup : " + collectGroup);
// 打印结果
// collectGroup : {false=[1, 2, 3], true=[4]}
</code></pre> 
<p><font color="#ff0000"> <br> 注：</font></p> 
<p>看groupingBy和partitioningBy的例子，他们的效果都是一样的，都是将Stream的数据进行了分割处理并返回一个Map。可能举的例子给你带来了误区，实际上他们两个完全是不一样的。</p> 
<ol><li>partitioningBy是根据指定条件，将Stream分割，返回的Map为Map</li></ol> 
<h2 id="字符串">字符串</h2> 
<p>有时候，我们将Stream的元素(String类型)最后生成一组字符串。比如在Stream.of(“1”, “2”, “3”, “4”)中，将Stream格式化成“1，2，3，4”。</p> 
<p>如果不使用Stream，我们可以通过for循环迭代实现。</p> 
<pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
list.add(3);
list.add(4);

StringBuilder sb = new StringBuilder();

for (Integer it : list) {
    if (sb.length() &gt; 0) {
        sb.append(",");
    }
    sb.append(it);

}
System.out.println(sb.toString());
// 打印结果
// 1,2,3,4
</code></pre> 
<p>在Java 1.8中，我们可以使用Stream来实现。这里我们将使用 Collectors.joining 收集Stream中的值，该方法可以方便地将Stream得到一个字符串。joining函数接受三个参数，分别表示允（用以分隔元素）、前缀和后缀。</p> 
<p>示例：</p> 
<pre><code>String strJoin = Stream.of("1", "2", "3", "4")
        .collect(Collectors.joining(",", "[", "]"));
System.out.println("strJoin: " + strJoin);
// 打印结果
// strJoin: [1,2,3,4]
</code></pre> 
<h2 id="组合collector">组合Collector</h2> 
<p>前面，我们已经了解到Collector的强大，而且非常的使用。如果将他们组合起来，是不是更厉害呢？看前面举过的例子，在数据分组时，我们是得到的分组后的数据列表 collectGroup : {false=[1, 2, 3], true=[4]}。如果我们的要求更高点，我们不需要分组后的列表，只要得到分组后列表的个数就好了。</p> 
<p>这时候，很多人下意识的都会想到，便利Map就好了，然后使用list.size（）,就可以轻松的得到各个分组的列表个数。</p> 
<pre><code>// 分割数据块
Map&lt;Boolean, List&lt;Integer&gt;&gt; collectParti = Stream.of(1, 2, 3, 4)
        .collect(Collectors.partitioningBy(it -&gt; it % 2 == 0));

Map&lt;Boolean, Integer&gt; mapSize = new HashMap&lt;&gt;();
collectParti.entrySet()
        .forEach(entry -&gt; mapSize.put(entry.getKey(), entry.getValue().size()));

System.out.println("mapSize : " + mapSize);
// 打印结果
// mapSize : {false=2, true=2}
</code></pre> 
<p>在partitioningBy方法中，有这么一个变形：</p> 
<pre><code>Map&lt;Boolean, Long&gt; partiCount = Stream.of(1, 2, 3, 4)
        .collect(Collectors.partitioningBy(it -&gt; it.intValue() % 2 == 0,
                Collectors.counting()));
System.out.println("partiCount: " + partiCount);
// 打印结果
// partiCount: {false=2, true=2}
</code></pre> 
<p>在partitioningBy方法中，我们不仅传递了条件函数，同时传入了第二个收集器，用以收集最终结果的一个子集，这些收集器叫作下游收集器。收集器是生成最终结果的一剂配方，下游收集器则是生成部分结果的配方，主收集器中会用到下游收集器。这种组合使用收集器的方式， 使得它们在 Stream 类库中的作用更加强大。</p> 
<p>那些为基本类型特殊定制的函数，如averagingInt、summarizingLong等，事实上和调用特殊Stream上的方法是等价的，加上它们是为了将它们当作下游收集器来使用的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa654ec85d684e77f780df883a061c4f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">css属性选择器和通配符选择器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b10239dc9db5803446387b9a8cc2ba9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java 8系列之Stream中万能的reduce</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>