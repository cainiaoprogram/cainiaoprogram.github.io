<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>最长单调子序列 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="最长单调子序列" />
<meta property="og:description" content="最长单调子序列
1. 问题描述（HDU 1160）
给出一些老鼠的质量和速度， 求一串数据证明老鼠的质量和速度成反比例关系？
2. 算法介绍
首先排序（由小到大）， 第一关键字“质量”， 第二关键字“速度“ 最长单调子序列方法：
Len（i）表示使证明成立的某串数据最后一只老鼠是第 i 只老鼠的该串长度。
对于第i &#43; 1 只老鼠， Len（i &#43; 1）= max (Len （j） &#43; 1， Len（i &#43; 1）) 且 满足速度和质量成反比例关系。
对于 HDU 1160 ， 还需求出具体是哪些老鼠， 用一个数组记录上一个老鼠， 递归输出即可。
3. 简单应用
HDU 1421 搬寝室
按重量排序，相邻的两个物品所产生的疲劳度最小。dp[i][j] 表示i个物品中取j对物品的最低疲劳度如果j对物品中包含i物品，dp[i][j] = dp[i - 2][j - 1] &#43; i物品 与 i - 1 物品的差的平方；如果不包含， dp[i][j] = dp[i - 1][j]; HDU 1069 monkey and banana" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a778a09ce75b33e5099ee34fc25e0b97/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-10-04T10:48:57+08:00" />
<meta property="article:modified_time" content="2012-10-04T10:48:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">最长单调子序列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px">最长单调子序列</span></p> 
<p><span style="font-size:18px">1. 问题描述（HDU 1160）</span></p> 
<p><span style="font-size:18px">    给出一些老鼠的质量和速度， 求一串数据证明老鼠的质量和速度成反比例关系？</span></p> 
<p><span style="font-size:18px">2. 算法介绍</span></p> 
<p><span style="font-size:18px">    首先排序（由小到大）， 第一关键字“质量”， 第二关键字“速度“ </span></p> 
<p><span style="font-size:18px">    最长单调子序列方法：</span></p> 
<p><span style="font-size:18px">        Len（i）表示使证明成立的某串数据最后一只老鼠是第 i 只老鼠的该串长度。</span></p> 
<p><span style="font-size:18px">        对于第i + 1 只老鼠， Len（i + 1）= max (Len （j） + 1， Len（i + 1）) 且 满足速度和质量成反比例关系。</span></p> 
<p><span style="font-size:18px">        对于 HDU 1160 ， 还需求出具体是哪些老鼠， 用一个数组记录上一个老鼠， 递归输出即可。</span></p> 
<p><span style="font-size:18px">3. 简单应用</span></p> 
<p><span style="font-size:18px">    HDU 1421 搬寝室</span></p> 
<pre dir="ltr" style="margin-right:0px">      <span style="font-size:18px">按重量排序，相邻的两个物品所产生的疲劳度最小。</span><span style="font-size:18px">
    dp[i][j] 表示i个物品中取j对物品的最低疲劳度
    如果j对物品中包含i物品，dp[i][j] = dp[i - 2][j - 1] + i物品 与 i - 1 物品的差的平方；
    如果不包含， dp[i][j] = dp[i - 1][j];</span></pre> 
<p><span style="font-size:18px">   HDU 1069 monkey and banana</span></p> 
<p><span style="font-size:18px">      本题与普通的字符串的最大区别在于字符串中的字符位置是不变的，而方块是可以任意选取的，<br>       因此我们只需要确定每一个方块的位置（方块即字符串中的一个字符）就行了。<br>       本题有多重确定方块位置的方法，可以按面积排序，或者按边长排序都行，其本质都是确保<br>       前面的方块都能放在其后的某个方块的下面，然后按照求最长单调子序列的方法求解即可。<br>       本题的另一个注意点就是，x, y的选取， 一个立方体有三个面可以作为底面，而一个面的长或宽有两种选择<br>       所以本题的底面有6种情况。</span></p> 
<p><span style="font-size:18px">   HDU 2059 龟兔赛跑</span></p> 
<p><span style="font-size:18px">      记录从起点开始到其他各点的最短时间。 <br>       最短时间是从点i开始，从起点到i的最短时间 + 开车时间 + 加油时间 + 脚踩到点j所花去的时间（如果需要）总和<br>       即为起点到J的最短时间。 （好好理解这个方程， 想想最长单调子序列的方法， 两个循环）<br>       为什么这个方程是对的？<br>       因为，最短时间的来就是选取在哪个站加油，每个站都有可能。而上面的DP，则在每个站点都加一次油，然后一直开，就考虑了<br>      所有的可能加油的站点。</span></p> 
<p><span style="font-size:18px">4. 源代码</span></p> 
<p><span style="font-size:18px">HDU 1160</span></p> 
<span style="font-size:18px"></span> 
<pre><code class="language-cpp"><span style="font-size:14px;">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
struct Mouse
{
	int weight;
	int speed;
	int index;
	int pre;   
}M[1000];
int num[1000];  
int cmp (const void *a, const void *b);
void print (int max);
int main()
{
	int i, j;
	int n, max;
	i = 0;
	while (scanf ("%d%d", &amp;M[i].weight, &amp;M[i].speed) == 2)
	{
		M[i].index = i + 1;
		i ++;
	}
	n = i;
	qsort (M, n, sizeof (struct Mouse), cmp);
	for (i = 0; i &lt; n; i ++)
	{
		num[i] = 1;
		M[i].pre = i;
	}
	for (i = 0; i &lt; n; i ++)
	{
		for (j = 0; j &lt; i; j ++)
		{
			if (M[i].weight &gt; M[j].weight &amp;&amp; M[i].speed &lt; M[j].speed &amp;&amp; num[i] &lt; num[j] + 1)
			{
				num[i] = num[j] + 1;
				M[i].pre = j;
			}
		}
	}
	max = 0;
	for (i = 0; i &lt; n; i ++)
	{
		if (num[i] &gt; num[max])
		{
			max = i;
		}
	}
	printf ("%d\n", num[max]);
	print (max);
	return 0;
}
int cmp (const void *a, const void *b)
{
	struct Mouse *v1 = (struct Mouse *)a;
	struct Mouse *v2 = (struct Mouse *)b;
	if (v1-&gt;weight != v2-&gt;weight)
	{
		return v1-&gt;weight - v2-&gt;weight;
	}
	else
	{
		return v2-&gt;speed -v1-&gt;speed;
	}
}
void print (int max)
{
	int i = max;
	if (M[i].pre != i)
	{
		print (M[i].pre);
		printf ("%d\n", M[i].index);
	}
	else
	{
		printf ("%d\n", M[i].index);
	}
}</span></code></pre> 
<p> </p> 
<p><span style="font-size:18px">HDU 1421</span></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define MAX 100000000
int weight[2001];
int dp[2001][1001];
int cmp (const void *a, const void *b);
int main()
{
	int i, j;
	int n, k;
	while (scanf ("%d%d",&amp;n, &amp;k) == 2)
	{
		for (i = 1; i &lt;= n; i ++)
		{
			scanf ("%d", &amp;weight[i]);
		}
		qsort (weight + 1, n, sizeof (int), cmp);  // 从weight[1]开始排序
		for (i = 0; i &lt;= n; i ++)
		{
			for (j = 1; j &lt;= k; j ++)
			{
				dp[i][j] = MAX;
			}
		}
		for (i = 2; i &lt;= n; i ++)
		{
			for (j = 1; j &lt;= k &amp;&amp; 2 * j &lt;= i; j ++)
			{
				dp[i][j] = dp[i - 2][j - 1] + (weight[i] - weight[i - 1]) * (weight[i] - weight[i - 1]);
				if (dp[i - 1][j] &lt; dp[i][j])
				{
					dp[i][j] = dp[i - 1][j];
				}
			}
		}
		printf ("%d\n", dp[n][k]);
	}
	return 0;
}
int cmp (const void *a, const void *b)
{
	return *((int *)a) - *((int *)b);
}</code></pre> 
<p><br>  </p> 
<p><span style="font-size:18px">HDU 1069</span></p> 
<span style="font-size:18px"></span> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
struct Shape
{
	int x;
	int y;
	int z;
}s[541];
int cmp (const void *a, const void *b);
int height[540];
int main()
{
	int n;
	int i, j;
	int x, y, z;
	int count, max;
	count = 1;
	while (scanf ("%d", &amp;n) == 1 &amp;&amp; n)
	{
		j = 0;
		for (i = 0; i &lt; n; i ++)
		{
			scanf ("%d%d%d", &amp;x, &amp;y, &amp;z);
			s[j].x = x;
			s[j].y = y;
			s[j ++].z = z;
			s[j].x = y;
			s[j].y = z;
			s[j ++].z = x;
			s[j].x = x;
			s[j].y = z;
			s[j ++].z = y;

			s[j].x = y;
			s[j].y = x;
			s[j ++].z = z;
			s[j].x = z;
			s[j].y = y;
			s[j ++].z = x;
			s[j].x = z;
			s[j].y = x;
			s[j ++].z = y;
		}
		qsort (s, 6 * n, sizeof (struct Shape), cmp);
		memset (height, 0, sizeof (height));
		max = 0;
		for (i = 0; i &lt; 6 * n; i ++)
		{
			for (j = 0; j &lt; i; j ++)
			{
				if (s[j].x &gt; s[i].x &amp;&amp; s[j].y &gt; s[i].y)
				{
					if (height[i] &lt; height[j])
					{
						height[i] = height[j];
					}
				}
			}
			height[i] += s[i].z;
			if (max &lt; height[i])
			{
				max = height[i];
			}
		}
		printf ("Case %d:", count ++);
		printf (" maximum height = %d\n", max);
	}
	return 0;
}
int cmp (const void *a, const void *b)  // 边长排序
{
	struct Shape *v1 = (struct Shape *)a;
	struct Shape *v2 = (struct Shape *)b;
	if (v1-&gt;x != v2-&gt;x)
	{
		return v2-&gt;x - v1-&gt;x;
	}
	else if(v1-&gt;y != v2-&gt;y)
	{
		return v2-&gt;y - v1-&gt;y;
	}
	else
	{
		return v2-&gt;z - v1-&gt;z;
	}
}
/*int cmp (const void *a, const void *b)  // 面积排序
{
	struct Shape *v1 = (struct Shape *)a;
	struct Shape *v2 = (struct Shape *)b;
	int area1, area2;
	area1 = v1-&gt;x * v1-&gt;y;
	area2 = v2-&gt;x * v2-&gt;y;
	if (area1 != area2)
	{
		return area2 - area1;
	}
	else 
	{
		return v2-&gt;z - v1-&gt;z;
	}
}*/</code></pre> 
<p> </p> 
<p><span style="font-size:18px">HDU 2059</span></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
	int len;
	int i, j;
	int N, D, T;
	double t1, t2;
	int vr, vt1, vt2;
	int station[102];
	double dp[102];
	while (scanf ("%d", &amp;len) == 1)
	{
		scanf ("%d%d%d", &amp;N, &amp;D, &amp;T);
		scanf ("%d%d%d", &amp;vr, &amp;vt1, &amp;vt2);
		for (i = 1; i &lt;= N; i ++)
		{
			scanf ("%d", &amp;station[i]);
		}
		t1 = (double)len / vr;
		for (i = 1; i &lt; N + 2; i ++)
		{
			dp[i] = 1000000;
		}
		dp[0] = 0;
		station[0] = 0;
		station[N + 1] = len;  // 加入起点和终点
		for (i = 1; i &lt; N + 2; i ++)
		{
			for (j = 0; j &lt; i; j ++)
			{
				if (station[i] - station[j] &lt;= D)
				{
					t2 = (station[i] - station[j]) / (double)vt1;
				}
				else
				{
					t2 = D / (double)vt1 + (station[i] - station[j] - D) / (double)vt2;
				}
				if (j != 0)
				{
					t2 += T;   // 起点油已经加满，其他各点均需要加油，花费时间T
				}
				if (dp[i] &gt; t2 + dp[j])  
				{
					dp[i] = t2 + dp[j];
				}
			}
		}
		if (t1 &lt; dp[N + 1])
		{
			printf ("Good job,rabbit!\n");
		}
		else
		{
			printf ("What a pity rabbit!\n");
		}
	}
	return 0;
}
</code></pre> 
<p><br> <span style="font-size:18px"></span> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f08f593469f75961ecfbf1aff99aa1bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DP --  最大连续子段和</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c318a8f8e4ba0e5baaa876027a81ea62/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《flex与bison》读书笔记--ch01 flex和bison简介（上）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>