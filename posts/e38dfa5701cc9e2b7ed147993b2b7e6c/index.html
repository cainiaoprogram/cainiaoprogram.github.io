<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【读点论文】A review of convolutional neural network architectures and their optimizations - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【读点论文】A review of convolutional neural network architectures and their optimizations" />
<meta property="og:description" content="A review of convolutional neural network architectures and their optimizations Abstract 本文详细分析和阐述了卷积神经网络（CNN）的典型架构及其优化的研究进展。本文提出了一种基于模块对 CNN 架构进行分类的典型方法，以适应更多具有多种特征的新网络架构，这些架构很难依赖于原始的分类方法。通过对各种网络架构的优缺点分析及其性能比较，对六种典型的 CNN 架构进行了详细的分析和解释。还探讨了 CNN 架构的内在特征。而且，本文根据各种优化算法的数学原理，对网络压缩和加速网络架构优化算法进行了全面的分类。最后，本文分析了 NAS 算法的策略，讨论了 CNN 的应用，并揭示了当前 CNN 架构及其优化的挑战和前景。解释了优化不同网络架构类型所带来的优势，为在具体设计和应用中建设性地选择合适的 CNN 提供了基础。本文将帮助读者在具体设计和应用中建设性地选择合适的 CNN。基于模块的分类方法：这种分类方法通过将网络架构划分为不同模块，并分析各个模块的功能和交互方式，从而能够更好地理解不同网络架构的特性。不同分类方法的优缺点及适用范围：分类方法的选择取决于具体的应用需求和数据集特性。网络压缩算法：通过减少模型参数的数量或降低参数的精度来减小模型大小，提高计算效率。常见的算法有量化、剪枝和知识蒸馏等。加速网络架构优化算法：通过改进训练过程或使用特定硬件来提高模型训练速度。常见的算法有分布式训练、硬件加速和混合精度训练等。网络压缩和加速优化算法的优缺点及适用范围：需要根据具体应用需求选择合适的算法，并权衡压缩和加速带来的影响。NAS算法介绍：通过自动化方式搜索和优化神经网络结构，以获得更好的性能。常见的算法包括基于搜索空间的NAS算法和基于神经网络的NAS算法等。NAS算法的应用范围及挑战：在具体应用中需要考虑搜索空间的大小、搜索时间和模型性能之间的关系以及如何评估和比较不同结构的模型等问题。 Introduction 机器学习（ML）最早于 1952 年加拿大达特茅斯会议上提出，是计算机科学中应用极为广泛的跨学科前沿分支。经过60多年的发展，机器学习已经衍生出深度学习、计算机视觉、语音识别等众多子领域。
深度学习被认为是机器学习中的一个新颖的研究领域，其概念发表在 Hinton 和 Salakhutdinov (2006) 的研讨会论文中。论文提出了一种基于深度置信网络（DBN）的高效无监督贪婪逐层训练算法。随后，包括神经网络（NN）在内的大量深度学习网络开始引起广泛关注。典型的深度学习模型包括DBN、堆叠式自动编码器网络和卷积神经网络（CNN）等。理论研究表明，当更深层次网络架构所代表的功能通过浅层网络架构来表达时，其计算单元呈指数级增长（Håstad和戈德曼 1991）。这种函数表达的潜力充分表明了深度学习网络的广阔前景。
因此，针对计算机视觉任务的需求，出现了一种特殊类型的神经网络架构，即CNN。 CNN 被认为是学习图像内容的最佳技术之一，在图像识别、图像分割、目标检测等相关领域取得了显着的效率。该网络最初受到视觉系统神经机制的启发，其架构受到 Hubel 和 Wiesel 于 1962 年在猫视觉皮层细胞上进行的神经生物学实验的启发。
1989 年，LeCun 等人。基于其前身 Neocognitron 提出了第一个名为 ConvNet 的多层 CNN。它定义了CNN最基本的框架，即卷积层、池化层和全连接（FC）层，成功解决了手写数字和邮政编码识别的相关问题。后来在 1998 年，LeCun 等人通过将卷积层与下采样层相结合，改进了 ConvNet 的架构，并将其命名为 LeNet-5，这就是现代 CNN 的雏形。
然而，从 20 世纪 90 年代末到 2000 年代初，由于计算机性能的限制，人们对深度学习兴趣不大。特别是，尽管仍然有研究人员优化 CNN 架构，但支持向量机 (SVM) 受到的关注远多于 CNN。 Simard 等人于 2003 年修改了 CNN 架构，该架构在手写基准混合国家标准与技术研究所 (MNIST) 数据库上表现出比 SVM 更好的效率。 2010年，李在斯坦福大学的团队构建了一个名为ImageNet的大型图像数据库，其中包含数百万张标记图像。基于该数据库，每年举办一次ImageNet大规模视觉识别挑战赛（ILSVRC），对各种模型进行性能评估和评分。在经历了10多年的停滞之后，AlexNet崛起并赢得了2012年-ILSVRC冠军，这标志着CNN性能的重大转折。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e38dfa5701cc9e2b7ed147993b2b7e6c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-07T21:14:13+08:00" />
<meta property="article:modified_time" content="2023-12-07T21:14:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【读点论文】A review of convolutional neural network architectures and their optimizations</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="A_review_of_convolutional_neural_network_architectures_and_their_optimizations_0"></a>A review of convolutional neural network architectures and their optimizations</h2> 
<h3><a id="Abstract_2"></a>Abstract</h3> 
<ul><li>本文详细分析和阐述了卷积神经网络（CNN）的典型架构及其优化的研究进展。本文提出了一种基于模块对 CNN 架构进行分类的典型方法，以适应更多具有多种特征的新网络架构，这些架构很难依赖于原始的分类方法。通过对各种网络架构的优缺点分析及其性能比较，<strong>对六种典型的 CNN 架构进行了详细的分析和解释</strong>。还探讨了 CNN 架构的内在特征。而且，本文根据各种优化算法的数学原理，对网络压缩和加速网络架构优化算法进行了全面的分类。最后，本文分析了 NAS 算法的策略，讨论了 CNN 的应用，并揭示了当前 CNN 架构及其优化的挑战和前景。解释了优化不同网络架构类型所带来的优势，为在具体设计和应用中建设性地选择合适的 CNN 提供了基础。本文将帮助读者在具体设计和应用中建设性地选择合适的 CNN。</li><li>基于模块的分类方法：这种分类方法通过将网络架构划分为不同模块，并分析各个模块的功能和交互方式，从而能够更好地理解不同网络架构的特性。不同分类方法的优缺点及适用范围：分类方法的选择<strong>取决于具体的应用需求和数据集特性</strong>。</li><li>网络压缩算法：通过减少模型参数的数量或降低参数的精度来减小模型大小，<strong>提高计算效率</strong>。常见的算法有量化、剪枝和知识蒸馏等。加速网络架构优化算法：通过改进训练过程或使用特定硬件来提高模型训练速度。常见的算法有<strong>分布式训练、硬件加速和混合精度训练等</strong>。网络压缩和加速优化算法的优缺点及适用范围：需要根据具体应用需求选择合适的算法，并权衡压缩和加速带来的影响。</li><li>NAS算法介绍：通过自动化方式搜索和优化神经网络结构，以获得更好的性能。常见的算法包括<strong>基于搜索空间的NAS算法和基于神经网络的NAS算法等</strong>。NAS算法的应用范围及挑战：在具体应用中需要考虑<strong>搜索空间的大小、搜索时间和模型性能</strong>之间的关系以及如何评估和比较不同结构的模型等问题。</li></ul> 
<h3><a id="Introduction_9"></a>Introduction</h3> 
<ul><li> <p>机器学习（ML）最早于 1952 年加拿大达特茅斯会议上提出，是计算机科学中应用极为广泛的跨学科前沿分支。经过60多年的发展，机器学习已经衍生出深度学习、计算机视觉、语音识别等众多子领域。</p> </li><li> <p>深度学习被认为是机器学习中的一个新颖的研究领域，其概念发表在 Hinton 和 Salakhutdinov (2006) 的研讨会论文中。论文提出了一种基于深度置信网络（DBN）的高效无监督贪婪逐层训练算法。随后，包括神经网络（NN）在内的大量深度学习网络开始引起广泛关注。典型的深度学习模型包括DBN、堆叠式自动编码器网络和卷积神经网络（CNN）等。理论研究表明，当更深层次网络架构所代表的功能通过浅层网络架构来表达时，其计算单元呈指数级增长（Håstad和戈德曼 1991）。这种函数表达的潜力充分表明了深度学习网络的广阔前景。</p> </li><li> <p>因此，针对计算机视觉任务的需求，出现了一种特殊类型的神经网络架构，即CNN。 CNN 被认为是学习图像内容的最佳技术之一，在图像识别、图像分割、目标检测等相关领域取得了显着的效率。该网络最初受到视觉系统神经机制的启发，其架构受到 Hubel 和 Wiesel 于 1962 年在猫视觉皮层细胞上进行的神经生物学实验的启发。</p> </li><li> <p>1989 年，LeCun 等人。基于其前身 Neocognitron 提出了第一个名为 ConvNet 的多层 CNN。它定义了CNN最基本的框架，即卷积层、池化层和全连接（FC）层，成功解决了手写数字和邮政编码识别的相关问题。后来在 1998 年，LeCun 等人通过将卷积层与下采样层相结合，改进了 ConvNet 的架构，并将其命名为 LeNet-5，这就是现代 CNN 的雏形。</p> </li><li> <p>然而，从 20 世纪 90 年代末到 2000 年代初，由于计算机性能的限制，人们对深度学习兴趣不大。特别是，尽管仍然有研究人员优化 CNN 架构，但支持向量机 (SVM) 受到的关注远多于 CNN。 Simard 等人于 2003 年修改了 CNN 架构，该架构在手写基准混合国家标准与技术研究所 (MNIST) 数据库上表现出比 SVM 更好的效率。 2010年，李在斯坦福大学的团队构建了一个名为ImageNet的大型图像数据库，其中包含数百万张标记图像。基于该数据库，每年举办一次ImageNet大规模视觉识别挑战赛（ILSVRC），对各种模型进行性能评估和评分。在经历了10多年的停滞之后，AlexNet崛起并赢得了2012年-ILSVRC冠军，这标志着CNN性能的重大转折。</p> </li><li> <p>目前，人类对 CNN 架构的改进不再局限于通过提高识别率来获得更好的效率。更先进的架构和模块将使CNN具有更好的适应性和移植能力。早在 20 世纪 90 年代，就已经提出了优化神经网络架构的研究协议。不过，由于当时的神经网络大多是浅层的，所以对架构优化的需求并不高。而且，由于当时计算机能力不足，CNN的架构优化几乎没有取得突破。随着机器学习应用向移动和嵌入式设备的转移，CNN架构优化的研究变得越来越流行。具有更高运行效率和更低内存占用的网络架构受到普遍关注。例如，现代智能手机越来越多地通过图像识别操作、机器人和自我识别来实时执行对象识别、医疗设备采集和患者数据分析。驾驶车辆。与 GPU 或计算机集群相比，这些设备的设计目标是低功耗和便携性，并且通常具有相当小的 RAM。</p> </li><li> <p>在过去的几年里，研究人员对 CNN 的典型架构及其优化方案进行了研究。顾等人。回顾了 2012 年至 2015 年出现的典型 CNN 模型及其基本组件。同样，也有一些著名的研究讨论了不同的 CNN 算法及其应用。可汗等人根据处理单元的设计模式对各种最新的 CNN 架构进行了分类。张等人 (2019) 和 Choudhary 等人 (2020) 的评论讨论了基于加速技术的 CNN 分类。目前仍需要对各种CNN架构和优化方法进行全面总结。同时，ML研究方向趋于拓展，需要不断整合、更新、比较和探索。值得注意的是，基于CNN基本特征的分类逻辑很难通过之前的CNN架构分类方法应用于更多新提出的网络架构。目前，更加成熟和先进的CNN架构通常是多功能的，网络优化的趋势更加多样化，不再局限于基本网络特征。不同评论的比较和分析总结于下表。</p> </li><li> <p>本文的贡献在于通过性能比较和详细阐述，对近年来CNN架构及其优化的研究成果进行了分析和总结。提出了一种基于模块对 CNN 架构进行分类的典型方法。<strong>概述了网络压缩和加速网络架构优化算法。讨论了 NAS 算法的策略和 CNN 的应用。提供了 CNN 架构及其优化的挑战和前景。提出的六种典型 CNN 架构是：基本网络架构、卷积分裂、跨层连接思想、深度可分离卷积、目标检测 CNN 和 Transformer 编码器。通过对各种网络架构的优缺点分析及其性能比较，对六种典型的 CNN 架构进行了详细的分析和解释</strong>。深入探讨了各自架构和特征的异同。网络架构的优化技术分为四种类型：<mark>网络剪枝、张量分解、网络量化和知识转移</mark>。其中，网络剪枝技术包括细粒度剪枝、向量级剪枝、内核级剪枝、组级剪枝和过滤器级剪枝。张量分解技术包括奇异值分解、Tucker分解、CP分解、块项分解和张量序列分解。网络量化技术包括二值量化、三值量化、多比特量化和哈希量化。另外，从搜索空间、搜索策略和性能评估策略三个方向分析了NAS的各种算法及其差异，并在此基础上总结了一些最新的NAS算法。本文基于各种优化算法的数学原理，提供了全面分类的网络压缩和加速网络架构优化算法。最后，本文分析了 NAS 算法的策略，回顾了 CNN 在视频对象分割、医学成像和人脸识别领域应用的最新发展，并阐述了 CNN 架构及其优化的挑战和前景。</p> </li></ul> 
<h3><a id="CNNs_architectures_27"></a>CNNs architectures</h3> 
<ul><li> <p>典型的 CNN 架构通常包括卷积层和池化层之间的交替。在下图所示的基本 LeNet-5 架构中，CNN 架构由四部分组成：输入层、卷积层、池化层、FC 层和输出层。 CNN的架构在神经网络架构的设计中起着重要的作用，因为更合理的网络架构可以增强层间的拟合效果或减少网络中的冗余计算，这通常意味着它可以带来更优越的性能。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/e2/3b/zA7RrHLB_o.png" alt="在这里插入图片描述"></p> 
    <ul><li>Basic architecture of LeNet-5</li></ul> </li></ul> </li></ul> 
<h4><a id="Convolution_layer_36"></a>Convolution layer</h4> 
<ul><li> <p>卷积层由一组卷积核组成，其工作原理图如下图所示。该过程的目的是在特征图上滑动预定义的固定大小的窗口，逐步提取各个位置的相邻特征块，<strong>并进行张量每个特征块与学习到的权重矩阵卷积核的乘积，然后重组获得的向量空间以获得新的张量</strong>。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/a5/7a/dOiPIVaL_o.png" alt="在这里插入图片描述"></p> </li><li> <p>Working diagram of convolution layer</p> </li></ul> </li><li> <p>卷积运算的输入与输出之间的数学公式为：</p> 
  <ul><li> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
          
           
            
             
             
               x 
              
             
               j 
              
             
               l 
              
             
            
              = 
             
             
             
               f 
              
             
               l 
              
             
            
              ( 
             
             
             
               u 
              
             
               j 
              
             
               l 
              
             
            
              ) 
             
            
              , 
             
             
             
               u 
              
             
               j 
              
             
               l 
              
             
            
              = 
             
             
             
               ∑ 
              
              
              
                i 
               
              
                ∈ 
               
               
               
                 M 
                
               
                 j 
                
               
              
             
             
             
               x 
              
             
               i 
              
              
              
                l 
               
              
                − 
               
              
                1 
               
              
             
            
              ∗ 
             
             
             
               k 
              
              
              
                i 
               
              
                j 
               
              
             
               l 
              
             
            
              + 
             
             
             
               b 
              
             
               j 
              
             
               l 
              
             
            
           
             x^l_j=f^l(u^l_j),u^l_j=\sum_{i\in M_j}x^{l-1}_i*k^l_{ij}+b^l_j 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2822em; vertical-align: -0.3831em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.2822em; vertical-align: -0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.5417em; vertical-align: -1.4917em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05em;"><span class="" style="top: -1.8557em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.109em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3281em;"><span class="" style="top: -2.357em; margin-left: -0.109em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2819em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.4917em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.433em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.267em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.2822em; vertical-align: -0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">ij</span></span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.2822em; vertical-align: -0.3831em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></p> </li><li> <p>其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
            
            
              x 
             
            
              j 
             
            
              l 
             
            
           
          
            x^l_j 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2439em; vertical-align: -0.3948em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8491em;"><span class="" style="top: -2.4413em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3948em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 表示卷积层l中第 j 个通道的输出l，f(.)表示卷积层的激活函数，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
            
            
              u 
             
            
              j 
             
            
              l 
             
            
           
          
            u^l_j 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2439em; vertical-align: -0.3948em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8491em;"><span class="" style="top: -2.4413em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3948em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 表示卷积层 l 中第j个通道的净激活，Mj表示采样的特征图子集通过在特征图中滑动窗口，kijl、bl j分别表示卷积层l的卷积核矩阵和特征图的偏差。</p> </li></ul> </li></ul> 
<h4><a id="Pooling_layer_53"></a>Pooling layer</h4> 
<ul><li> <p>池化层又称为下采样层，一般包括maxpooling、mean-pooling和stochastic pooling。最大池化取邻域内特征点的最大值，均值池化取邻域内特征点的平均值，而随机池化则取邻域内随机特征点的值。池化操作的输入和输出之间的数学公式为：</p> 
  <ul><li> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
          
           
            
             
             
               x 
              
             
               j 
              
             
               l 
              
             
            
              = 
             
             
             
               f 
              
             
               l 
              
             
            
              ( 
             
             
             
               u 
              
             
               j 
              
             
               l 
              
             
            
              ) 
             
            
              , 
             
             
             
               u 
              
             
               j 
              
             
               l 
              
             
            
              = 
             
             
             
               α 
              
             
               j 
              
             
               l 
              
             
            
              ⋅ 
             
             
             
               f 
              
              
              
                p 
               
              
                o 
               
              
                o 
               
              
                l 
               
              
                i 
               
              
                n 
               
              
                g 
               
              
             
               l 
              
             
            
              ( 
             
             
             
               x 
              
             
               j 
              
              
              
                l 
               
              
                − 
               
              
                1 
               
              
             
            
              ) 
             
            
              + 
             
             
             
               b 
              
             
               j 
              
             
               l 
              
             
            
           
             x^l_j=f^l(u^l_j),u^l_j=\alpha^l_j·f^l_{pooling}(x^{l-1}_j)+b^l_j 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2822em; vertical-align: -0.3831em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.2822em; vertical-align: -0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.3022em; vertical-align: -0.4031em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: -0.0037em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">oo</span><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span></span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.433em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4031em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.2822em; vertical-align: -0.3831em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></p> </li><li> <p>其中 xl j 和 ul j 分别表示池化层 l 中第 j 个通道的输出和净激活，f(⋅) 表示连接到池化层 l 的激活函数，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
            
            
              α 
             
            
              j 
             
            
              l 
             
            
           
          
            \alpha ^l_j 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2439em; vertical-align: -0.3948em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8491em;"><span class="" style="top: -2.4413em; margin-left: -0.0037em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3948em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 表示池化层 l 的权重系数， fl pooling表示池化层l的池化函数。池化层（第一张图中的块S1和S2）通过下采样减少特征图中处理的元素数量，并通过逐渐增加连续卷积层的窗口引入分层空间滤波器结构。池化层可以显着减少网络参数，<strong>防止网络过拟合</strong>。</p> </li></ul> </li></ul> 
<h4><a id="Activation_function_63"></a>Activation function</h4> 
<ul><li> <p>激活函数在CNN中起着决策作用，有利于学习非线性复杂模式。它们主要用于将非线性因素引入神经网络以增强其拟合能力。下表详细介绍了 CNN 中的典型激活函数类型，包括 sigmoid、tanh、修正线性单元 (ReLU)及其变体 Leakly ReLU、Parametric ReLU 、随机 ReLU 、指数线性单元 ，swish和maxout。显然，与 sigmoid 和 tanh 这样的函数相比，过大和过小的输入并不会让 ReLU 趋于饱和。因此，ReLU 及其变体在克服梯度消失问题方面优于传统的激活函数，如 sigmoid 和 tanh 。对于Maxout激活函数来说，它在保留ReLU函数的线性和不饱和度优势的基础上避免了神经元死亡等问题。</p> 
  <ul><li><img src="https://images2.imgbox.com/e7/d1/1yIG2nJ6_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h4><a id="Fully_connected_layer_70"></a>Fully connected layer</h4> 
<ul><li> <p>全连接（FC）层通常位于CNN的最后部分，用于将前一层输出的二维（2D）特征信息转换为一维（1D）分类信息。<strong>它类似于多层感知器（MLP）的隐藏层，其中的输出是通过前一层的FC神经元的加权组合获得的</strong>。每个神经元的输入和输出操作之间的数学公式为：</p> 
  <ul><li> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
          
           
            
             
             
               x 
              
             
               j 
              
             
               l 
              
             
            
              = 
             
             
             
               f 
              
             
               l 
              
             
            
              ( 
             
             
             
               u 
              
             
               j 
              
             
               l 
              
             
            
              ) 
             
            
              , 
             
             
             
               u 
              
             
               j 
              
             
               l 
              
             
            
              = 
             
            
              m 
             
            
              a 
             
            
              x 
             
            
              ( 
             
            
              0 
             
            
              , 
             
             
             
               ∑ 
              
             
               i 
              
             
             
             
               y 
              
             
               j 
              
             
               l 
              
             
            
              ⋅ 
             
             
             
               w 
              
              
              
                i 
               
              
                j 
               
              
             
               l 
              
             
            
              + 
             
             
             
               b 
              
             
               j 
              
             
               l 
              
             
            
              ) 
             
            
           
             x^l_j=f^l(u^l_j),u^l_j=max(0,\sum_i y^l_j·w_{ij}^l+b^l_j) 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2822em; vertical-align: -0.3831em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.2822em; vertical-align: -0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.3277em; vertical-align: -1.2777em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05em;"><span class="" style="top: -1.8723em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.2777em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">ij</span></span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.2822em; vertical-align: -0.3831em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p> </li><li> <p>其中xl j和ul j分别表示FC层l中第j个通道的输出和网络激活，f(⋅)表示池化层 l 连接的激活函数，wl ij和bj分别是权重系数和偏置FC层l的个数，max(⋅)表示所选数组范围内的最大数。</p> </li></ul> </li></ul> 
<h3><a id="Typical_CNNs_network_structure_development_80"></a>Typical CNNs network structure development</h3> 
<ul><li> <p>CNN 的架构经历了 30 多年的研究和不断发展。其性能提升的主要动力来自于先进模块的设计和广泛的识别能力。<strong>先进的CNNs模块专注于改进、重新设计和模块化CNNs架构，从而可以在深度、宽度和空间利用率方面优化网络</strong>。同时，更广泛的识别能力有助于在图像和视频识别等衍生应用中获得更好的网络效率。下图显示了各种CNN架构、分类和改进过程的时间顺序总结，这是基于各种网络提出的想法及其各自的架构特征。在本研究中，<strong>通过将现有 CNN 分类为基本网络架构、卷积分裂、跨层连接思想、深度可分离卷积、目标检测 CNN 和 Transformer 编码器，探讨了典型 CNN 架构的发展历史</strong>。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/64/c4/2LLjZ3CK_o.png" alt="在这里插入图片描述"></p> </li><li> <p>卷积神经网络发展图</p> </li></ul> </li></ul> 
<h4><a id="Basic_network_architecture_89"></a>Basic network architecture</h4> 
<ul><li> <p><strong>CNN 的核心思想是共享局部感受野和权重</strong>。 LeNet 是 LeCun 等人于 1998 年提出的第一个 CNN 架构，被认为是 CNN 的原型。它采用五个卷积层直接连接到池化层的架构。 LeNet最初是为了识别手写和印刷字符而设计的，取得了出色的效率。目前常见的LeNet在原有模型的基础上进行了修改。具体来说，非线性变换从下采样层转移到卷积层，输出层的激活函数从径向基函数改为softmax函数。</p> </li><li> <p>尽管深度学习的兴起被普遍认为以Hinton等人在2006年提出这一概念为标志，但自从2012年AlexNet的成功开发以来，深度学习受到了学术界和工业界的广泛关注。 Krizhevesky 等人在图像处理领域。下图展示了 AlexNet 的架构图。该网络由五个卷积层和三个FC层组成。每个卷积层包含激活函数ReLU，以及局部响应归一化（LRN）和池化（下采样）处理。</p> </li><li> <p><img src="https://images2.imgbox.com/0a/9f/wr7KFsCA_o.png" alt="在这里插入图片描述"></p> </li><li> <p>Simonyan等人首先提出了类似于卷积分裂的CNN架构设计原理，并将其命名为VGG（。在2014-ILSVRC比赛中获得第二名。 VGG可以看作是AlexNet的加深版本，它使用多个连续的3×3卷积核来替换网络中较大的核（11×11、7×7、5×5）。 VGGNet将网络分为五段，每段将多个3×3卷积核连接在一起。每段卷积后面都有一个最大池化层，最后添加三个FC层和一个softmax层。</p> </li><li> <p>Lin等人于2013年提出了一种非线性架构Mlpconv，并将Mlpconv层堆叠起来构成网络中的网络（NiN）。下图展示了 Mlpconv 架构，其中在卷积核后面添加了 MLP。由于MLP强大的拟合能力，与传统的CNN卷积过程相比，Mlpconv架构增强了网络的非线性表达能力和局部感知场的特征识别能力。同时，NiN 还用全局平均池化层取代了传统的 CNN FC 层。</p> 
  <ul><li><img src="https://images2.imgbox.com/94/54/92f99sUB_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>受到用 Mlpconv 架构替换每个 NiN 层的想法的启发，Szegedy 等人在 2015 年提出用小块卷积替换传统的卷积层，提出了一种名为 Inception-v1 的模块架构，其网络名称为 GoogLeNet。 GoogLeNet获得2014-ILSVRC冠军。下图a 显示了 Inceptionv1 模块的原始架构，其中多个 1 × 1、3 × 3 和 5 × 5 卷积与 3 × 3 大小的池化操作堆叠在一起，以增加网络宽度，以及提取特征的能力不同的尺寸。下图b 展示了更新后的 Inceptionv1 架构。由于原始模块显着增加了计算负担，更新后的Inceptionv1模块在3×3、5×5卷积之前和池化层之后添加了1×1卷积层，分别用于压缩输入和输出图像通道数。 GoogLeNet 在 CNN 中引入了 Inception 块的新概念，它通过分裂、变换和合并方法集成了多尺度卷积和变换。这使得 CNN 能够获得高精度，同时降低计算成本。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/d4/42/1hpMrtPL_o.png" alt="在这里插入图片描述"></p> </li><li> <p>Inceptionv1架构：a原始Inceptionv1架构，b更新的Inceptionv1架构</p> </li></ul> </li><li> <p>同年，Ioffe 等人。通过对Inceptionv1进行改进，提出了Inceptionv2（也称为BN-Inception）架构。如下图a所示，Inceptionv2分割了大卷积核（5×5）在原来的Inceptionv1模块中分成两个小卷积核（3×3）。与Inceptionv1相比，它最大的贡献是引入了批量归一化（BN）概念。通过BN，对某个网络节点的输出进行处理，使其近似均值为0、方差为11的正态分布，从而缓解反向传播中的梯度消失和梯度爆炸问题。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/16/ad/mCDkpFGR_o.png" alt="在这里插入图片描述"></p> </li><li> <p>卷积核分解：一个大卷积核（5×5）分裂成两个小卷积核（3×3），b非对称卷积核分裂</p> </li></ul> </li><li> <p>Szegedy等人借用VGGNet的卷积核分解思想在2016年提出了Inceptionv3架构，旨在在不影响泛化的情况下降低更深网络的计算成本。 Inceptionv3引入了非对称卷积核，上图b描述了其卷积核分解的策略。<strong>它将n×n卷积核分解为n×1和1×n。这样的操作进一步减少了网络参数的数量</strong>。根据计算，使用1×3、3×1非对称堆叠卷积比将3×3卷积核分解为两个2×2卷积核可减少28%的参数数量。与Inceptionv2相比，Inceptionv3还将7×7和5×5大型滤波器替换为1×7、7×1和1×5、5×1滤波器堆栈。此外，Inceptionv3应用辅助分类器来加速CNN训练的收敛，实现了04% top-1准确率的性能提升。</p> </li><li> <p>同年，Szegedy 等人。提出了一系列本地网络架构，包括 Stem、Inception-A、Inception-B、Inception-C、Reduction-A 和 Reduction-B，并集成到 Inceptionv4 模块中。此外，他们通过将残差学习融入GoogLeNet中，提出了Inception-ResNet。实验表明，带有残差连接的 Inception-ResNet 具有与普通 Inceptionv4 相同的泛化能力，尽管深度和宽度有所增加。而且，<strong>Inception-ResNet比Inceptionv4收敛得更快，这更直接地证明了使用残差连接可以显着加速Inception网络的训练</strong>。 Inceptionv4 和 Inception-ResNet 实现了更快的训练和更好的性能。其中Inceptionv4有70层，其在ImageNet上的错误率为4.01。此外，Inception-ResNet有572层，在ImageNet上的错误率为3.52%。</p> </li></ul> 
<h4><a id="Crosslayer_connection_idea_124"></a>Cross‑layer connection idea</h4> 
<ul><li> <p>通常，传统的 CNN 由卷积层、池化层和 FC 层之间的连接构成，其中层间信息仅传输到相邻层。这种架构不仅限制了CNN的拟合能力，而且随着网络深度的增加，拟合效果也会变差。<strong>随着网络架构的深入，梯度消失、爆炸或退化问题变得越来越严重</strong>。跨层连接的思想是现有问题的有效解决方案，众所周知，它允许网络在非相邻层之间传递信息。</p> </li><li> <p>Srivastava 等人在 2015 年提出了一种名为 Highway Networks 的深度 CNN，它<strong>通过引入新的跨层连接并在层中分配两个门控单元来实现各个层之间畅通无阻的信息流</strong>。门控机制受到基于长短期记忆 (LSTM) 的循环神经网络 (RNN) 的启发。通过结合第l层及其前l-k层的信息，完成信息聚合，产生正则化效果，从而有利于深度网络的基于梯度的训练。这样，随机梯度下降（SGD）算法就可以用来训练超过100层甚至高达900层的网络。</p> </li><li> <p>有些网络在训练过程中还会遇到退化问题，导致准确率快速饱和，并且随着级别的加深，错误率不断增加。这种问题产生的错误率仅仅归因于网络层数的增加，而不是过度拟合。 2016年，He等人通过利用highway网络中应用的旁路路径提出了ResNet，并引入了残差学习的概念来解决退化问题。下图 显示了 ResNet 残差块的架构。 ResNet继承了Highway Networks的跨层连接思想。不同之处在于，它的门控机制是始终畅通无阻的，而不是可学习的，这有助于大大降低网络复杂度。通过快捷连接，ResNet跨层传输输入并将其添加到卷积结果中，从而使底层网络得到充分训练，从而显着提高准确性。在 Microsoft Common Objects in Context (MS COCO) 数据集上，ResNet 显示了 28% 的改进。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/39/67/YKV2ITH2_o.png" alt="在这里插入图片描述"></p> </li><li> <p>残差模块架构：a 跨两层连接，b 跨三层连接</p> </li></ul> </li><li> <p>尽管残差模块提高了网络表达能力，但它仍然存在一些缺点，例如训练时间密集、许多特征图失活（特征重用问题）以及梯度消失和爆炸问题。因此，一些研究人员认为，<strong>加宽网络层数可能比加深网络提供更有效的性能改进</strong>。为了解决上述问题，Zagoruyko、Komodakis 等人于 2016 年提出了 Wide ResNet，它利用残差块的功能，使 ResNet 变得更宽而不是更深。此外，还引入了一个附加因子k来控制网络宽度。实证研究表明，Wide ResNet 可以实现更好的深度网络训练，尽管其参数数量是 ResNet 的两倍。</p> </li><li> <p>韩等人。 2017 年开发了 Pyramidal Net，它逐渐增加每个残差单元的宽度，这与 ResNet 中深度增加导致空间宽度急剧减小相反。这种策略使金字塔网络能够覆盖所有可能的位置，而不是在下采样之前在每个残差块内保持相同的空间大小。在金字塔网络中，特征图的深度调整因子l，并根据以下公式计算：</p> 
  <ul><li> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              f 
             
            
              ( 
             
            
              x 
             
            
              ) 
             
            
              = 
             
             
             
               { 
              
              
               
                
                 
                  
                 
                
                
                 
                  
                   
                  
                    6 
                   
                  
                      
                   
                  
                    i 
                   
                  
                    f 
                   
                  
                      
                   
                  
                    l 
                   
                  
                    = 
                   
                  
                    1 
                   
                  
                 
                
               
               
                
                 
                  
                 
                
                
                 
                  
                   
                  
                    ⌊ 
                   
                   
                   
                     d 
                    
                    
                    
                      l 
                     
                    
                      − 
                     
                    
                      1 
                     
                    
                   
                  
                    + 
                   
                  
                    λ 
                   
                  
                    / 
                   
                  
                    n 
                   
                  
                    ⌋ 
                   
                  
                      
                   
                  
                    i 
                   
                  
                    f 
                   
                  
                      
                   
                  
                    2 
                   
                  
                    ≤ 
                   
                  
                    l 
                   
                  
                    ≤ 
                   
                  
                    n 
                   
                  
                    + 
                   
                  
                    1 
                   
                  
                 
                
               
              
             
            
           
             f(x)=\left\{ \begin{aligned} &amp;6 ~if ~l=1\\ &amp;\lfloor d_{l-1}+\lambda/n\rfloor ~if~2\leq l\leq n+1\\ \end{aligned} \right. 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 3em; vertical-align: -1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size4">{<!-- --></span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.75em;"><span class="" style="top: -3.75em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.25em;"><span class=""></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.75em;"><span class="" style="top: -3.91em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mord">6</span><span class="mspace nobreak"> </span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord">1</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal">λ</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">⌋</span><span class="mspace nobreak"> </span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mspace nobreak"> </span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.25em;"><span class=""></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> </li><li> <p>其中dl表示第l个残差单元的维数，n表示残差单元的总数，휆是步长因子。此外，λ∕n 调节深度的增加。显然，<strong>金字塔网络的主要问题在于随着宽度的增加，空间和时间都呈二次方增加</strong>。</p> </li></ul> </li><li> <p>2017年，谢等人。指出，通过传统的加宽和加深方法提高模型精度会显着增加网络复杂性，特别是当存在许多设计因素和超参数时。因此，Xie等人借鉴了Inception模块和残差网络的思想。将基数的概念引入了新的网络架构 ResNeXt 。作为附加维度，基数指的是变换集的大小。 Xie等人通过实验发现，增加基数可以在保持复杂性的同时提高分类精度。而且，与增加深度和宽度相比，增加基数值可以实现更好的精度提升。下图展示了 ResNet 块和基数 = 32 的 ResNeXt 块的架构。ResNeXt 进一步拓宽了网络架构，在不增加网络复杂性的情况下提高了识别精度，并减少了超参数的数量。根据实验结果，101层ResNeXt（ResNeXt-101）可以比ResNet-200获得更好的精度，但复杂度仅为ResNet-200的50%。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/ca/ba/wlqdaD0T_o.png" alt="在这里插入图片描述"></p> </li><li> <p>ResNet块的架构：a块ResNeXt，b块ResNeXt，基数= 32</p> </li></ul> </li><li> <p>DenseNet 是一种具有密集连接的 CNN 架构，它借鉴了 ResNet 中跨层连接的精髓思想。如下图示，DenseNet中的每一层都以前馈的方式与其他每一层连接，从而更彻底地强化跨层深度卷积的效果。DenseNet 中的 Hl(⋅) 块是一个复合函数 BN-ReLU-Conv，它由三个连续操作组成，即 BN、ReLU 和 3 × 3 卷积（Conv）。DenseNet的基本模块称为Dense Blocks，每个模块都以之前所有Dense Blocks的特征图作为输入。与应用直接求和的 ResNet 不同，密集块以串联方式合并多个先前的输入。这种连接方法允许网络之间更有效的信息和梯度流动，从而显着减少DenseNet参数的数量。Gau等人修改了DenseNet，提出了一种<strong>轻量级网络CondenseNet，它集成了学习组卷积、密集连接和剪枝等方法</strong>。作者添加了新的索引层用于实现后续卷积层的分组卷积，并将网络卷积层的输入通道数修改为指数增长。此外，CondenseNet将DenseNet在密集块中采用的密集连接模式的应用扩展到网络的每一层。实验表明，CondenseNet 的性能优于前沿的轻量级网络 MobileNet 和 ShuffleNet。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/95/71/q6t3Jq4z_o.png" alt="在这里插入图片描述"></p> </li><li> <p>DenseNet architecture</p> </li></ul> </li><li> <p>2019年，Wang等人认为DenseNet的网络有大量的梯度信息被重复使用来更新不同Dense块的权重，这意味着Dense块重复学习相同的信息 。考虑到这一点，他们提出了一种称为 CSPNet 的网络结构，通过添加部分过渡层来最大化梯度组合的差异。下图展示了CSPNet结构结合多个CNN结构的网络模型。 2021 年，高桥等人。引入了一种密集连接的多重（D3Net）网络架构来处理高分辨率密集预测的任务（Takahashi and Mitsufuji 2021），它将多层卷积与 DenseNet 架构相结合，以获得每层指数增长的感知场。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/45/c1/bhhHSNZw_o.png" alt="在这里插入图片描述"></p> </li><li> <p>模块对比</p> </li></ul> </li></ul> 
<h4><a id="Depthwise_separable_convolution_173"></a>Depthwise separable convolution</h4> 
<ul><li> <p>一些高性能的 CNN 方法不可避免地带来巨大的计算成本，这通常需要高性能 GPU 或高度优化的分布式 CPU 架构 的支持。尽管CNN的应用向移动终端扩展，但大多数移动设备不具备强大的计算能力或巨大的存储空间。因此，需要对轻量级网络架构进行研究，以帮助妥善处理上述问题。轻量级CNN一般是指经过压缩和加速后得到的更小的CNN架构，其特点如下：</p> 
  <ul><li> <p>与服务器的通信要求小；</p> </li><li> <p>网络参数少，模型数据量低；</p> </li><li> <p>适合部署在内存受限的设备上。</p> </li></ul> </li><li> <p>为了使CNN在保持性能的同时满足需求，提出了深度可分离卷积的架构。此外，深度可分离卷积的性能比较和分析总结在表6中。</p> </li><li> <p>2017年，Howard等人提出的MobileNetv1将<strong>传统的卷积过程分解为两步，即Depthwise卷积和Pointwise卷积</strong>，在模型大小和计算负担上都实现了大幅压缩。由此构建的轻量级网络可以在嵌入式移动设备上运行。通过结合可分离卷积，Sandler 等人。提出了具有线性瓶颈的逆残差，并在此基础上构建了MobileNetv2，速度和精度均优于MobileNet。 Andrew 等人提出了 MobileNetv3，展示了网络架构和算法方面的改进。他们将平台感知 NAS 和用于网络架构搜索的 NetAdapt 结合起来。同时，提出了一种改进的激活函数h-swish，在保留swish激活函数高精度的同时，大大减轻了计算负担。与MobileNetv2相比，MobileNetv3在ImageNet分类中的准确率提高了3.2%，延迟降低了15%。此外，在几乎相同的精度下，MobileNetv3 在 MS COCO 数据集和 Cityscapes 语义分割任务上的运行速度分别提高了 25% 和 30%。</p> </li><li> <p>Xception 可以被认为是一种极端的 Inception 架构，它借鉴了 AlexNet 中引入的深度可分离卷积的思想。下图描绘了Xception模块，它拓宽了原始的Inception，并使用紧跟在1×1后面的一层3×3卷积核来替换不同的空间维度（1×1、3×3、3×3），从而调整计算复杂度。最初，输入特征图由 1 × 1 卷积核处理。然后，<strong>使用3×3卷积核对输出特征图的每个通道进行卷积运算。最后，将所有输出拼接在一起以获得新的特征图</strong>。尽管训练参数比 Inceptionv3 少，但 Xception 网络具有与 Inceptionv3 相同的识别精度和训练速度，并且在更大的数据集上也有更好的性能。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/87/be/6QQcLbXc_o.png" alt="在这里插入图片描述"></p> </li><li> <p>Xnception module</p> </li></ul> </li><li> <p>张等人开发了两种新颖的操作方法，即逐点组卷积和通道洗牌，并将它们命名为 ShuffleNet 。根据 ImageNet 分类和 MS COCO 目标检测的实验，在 40 MB 的计算预算下，ShuffleNet 在 ImageNet 分类任务上的 top-1 错误比 MobileNet 低 7.8%，从而允许 CNN 在极其有限的数量上运行。移动设备。 2018 年，Ma 等人提出了一种名为 ShuffleNetv2 的新架构。 Ma等人认为：（1）ShuffleNetv1大量使用1×1组卷积来增加内存访问成本（MAC）。 （2）ShuffleNetv1使用类似于ResNet的瓶颈层，其中输入和输出通道数不同，相同的通道大小最大限度地减少了内存访问。瓶颈层与ResNet类似，输入和输出通道数不同，相同的通道大小最大限度地减少了内存访问。 (3)ShuffleNetv1中的复用结构导致网络碎片，降低了模型的并行度。 (4)短路连接中存在大量ReLU、Add等逐元素算子。因此，马等人。引入了一个新的操作：通道shuffle。两个分支的输出不是添加元素，而是连接在一起，然后对结果进行通道混洗。与ShuffleNetv2相比，在相同复杂度下比ShuffleNetv1和MobileNetv2更准确。</p> </li></ul> 
<h4><a id="Object_detection_CNNs_196"></a>Object detection CNNs</h4> 
<ul><li> <p>由于CNN在图像分类问题上的出色表现，其在目标检测方向的应用受到期待。与图像分类问题不同，对象检测问题需要从图像中检测和定位多个特定对象。大多数传统的物体检测方法都是基于图像识别。在过去的十年中，传统的机器视觉领域经常使用特征描述符来处理物体识别任务。这些特征描述符中最常见的包括尺度不变特征变换 (SIFT) 和定向梯度直方图 (HOG) 。同时，AlexNet的出现使得CNN成为目标检测的主流方法。目前，基于 CNN 的目标检测的基本思想是在使用 CNN 进行分类之前提出候选区域。本节主要描述目标检测 CNN 的形成和发展。</p> </li><li> <p>受到 AlexNet、Girshick 等人的启发。试图将 AlexNet 在 ImageNet 对象识别方面的能力推广到 2014 年的 PASCAL 视觉对象类挑战赛 (VOC)，同时提出了区域 CNN (R-CNN) 模型。下图说明了 R-CNN 的对象检测过程。为了实现目标检测，输入图像经过三个模块，分别是区域提议、特征提取和区域分类。相关想法有：</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/04/89/AlXZ04zo_o.png" alt="在这里插入图片描述"></p> </li><li> <p>R-CNN-based object detection process</p> </li><li> <p>在区域提案中，采用选择性搜索（SS算法）来提取区域提案（大约2000），并与CNN结合。</p> </li><li> <p>特征提取负责从每个regionproposal中提取固定长度4096的特征向量，并基于CNN计算每个region proposal的特征。</p> </li><li> <p>在区域分类中，通过边界框回归和支持向量机对每个框进行分类和回归。</p> </li></ul> </li><li> <p>这种方法不仅提高了目标检测的效率，而且提高了检测精度。在 VOC2007 上，DPM HSD 获得的平均精度 (mAP) 从 34.3% 增加到 66%。</p> </li><li> <p>尽管目标区域检测的准确率很高，但 R-CNN 仍然存在明显的缺点。<strong>大多数 CNN（包括 R-CNN）仅限于接受固定大小的输入。然而事实上，CNN 的卷积层可以生成任意大小的特征表面。这种限制取决于 FC 层对固定长度输入的要求</strong>。此外，R-CNN的训练是一个复杂且冗余的过程。 SVM和边界框回归学习都需要提取每个候选区域的特征并将其存储在硬盘中，这计算量巨大并且消耗存储空间。 2015年，He等人提出了一种SPPNet模型，其架构如下图所示。<strong>该模型在CNN的最后一个卷积层和第一个FC层之间添加了一个空间金字塔池（SPP）层</strong>。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/9d/4b/dvKc3HtD_o.png" alt="在这里插入图片描述"></p> </li><li> <p>Spatial pyramid pooling architecture</p> </li></ul> </li><li> <p>SPP总共由三层组成。根据输入特征图划分的空间块的分辨率，可以将其分为低分辨率层、中分辨率层和高分辨率层。这三个层分别将输入特征图划分为 1、4 和 16 个空间块。对于不同尺寸的特征图，最终输出的空间块总数保持不变。因此，<strong>在连接到最后一个卷积层之后，SPP层输出固定长度的张量并将它们发送到FC层以对每个区域提案进行分类</strong>。与R-CNN相比，SPPNet的测试时间可以加速10×–100×。显然，现有的SPP层允许不同大小的CNN输入产生相同大小的输出，这打破了CNN模型的输入都具有固定大小的限制。</p> </li><li> <p>尽管如此，SPPNet仍然存在训练和硬盘读写过程复杂的特点。此外，SPPNet在目标检测过程中无法更新SPP层之前的卷积层，限制了其识别精度。针对这些问题，Girshick等人在2015年开发了Fast R-CNN，它引入了一种特殊的单层SPP，称为RoI池化，而不限制特征图的输入大小，从而统一了输入到FC层的特征图的大小（吉尔希克 2015）。下图 显示了 Fast R-CNN 的架构，其中图像及其区域建议一起作为输入进行卷积和最大池化操作，从而获得包含区域建议的共享特征图。</p> 
  <ul><li><img src="https://images2.imgbox.com/0d/21/5jsb5TZc_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>RoI池化将特征图中的区域建议提取为固定长度的特征向量。经过FC层处理后，这些特征向量被发送到两个输出层，这两个输出层分别负责输出softmax概率估计（K个对象类别和1个背景类别）和边界框位置（K个对象类别）。<strong>与 R-CNN 和 SPPNet 采用线性 SVM 等回归模型进行边界框回归不同，Fast R-CNN 采用 softmax 和边界框回归</strong>。除了解决SPPNet中SPP层之前的卷积层无法更新网络参数的问题之外，Fast R-CNN还表现出明显比SPPNet更快的训练和测试速度。</p> </li><li> <p>鉴于 Fast R-CNN 由于依赖候选区域选择而消耗大量计算资源，Ren 等人 在 2017 年开发了一种用于实时目标检测的区域提议网络 (RPN)，以取代选择性搜索方法。作为一个全卷积网络（FCN），RPN 可以从任意大小的图像中获得一系列客观性分数。 Ren等人<strong>将RPN与Fast R-CNN结合起来构成Faster R-CNN，这是一个共享卷积层特征的网络</strong>。下图 说明了使用 Faster R-CNN 的对象检测过程。<strong>它的网络由两部分组成：生成区域提议的 RPN 和使用提议区域的检测器</strong>。Faster R-CNN在PASCAL VOC2007、2012和MS COCO数据集上取得了最好的检测结果，计算过程几乎是实时的。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/bc/b6/poWXgKCs_o.png" alt="在这里插入图片描述"></p> </li><li> <p>基于 R-CNN 的更快的目标检测过程</p> </li></ul> </li><li> <p>2016年，Redmon等人针对目标检测问题提出了一种新的检测策略。与以前的做法不同，大多数检测网络基于分类来定位对象，而 You Only Look Once (YOLO) 被认为是一种新的检测方法 。它将目标检测问题转化为多个边界框和相关类别的概率回归问题。基于GoogLeNet，YOLO使用单个神经网络和单个评估来直接预测整个输入图像的边界框和类别。下图说明了YOLO的目标检测思想。最初，<strong>网络将输入图像分割成S*S网格，每个网格负责检测中心点落在该网格内的目标对象，并预测B个边界框并标记相应的分数</strong>。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/cf/6e/uCpBGoMW_o.png" alt="在这里插入图片描述"></p> </li><li> <p>YOLO-based object detection process</p> </li></ul> </li><li> <p>高置信度分数表示对象包含在边界框中的可能性很高。预测边界框和实际边界框的 IoU 值被视为置信度分数，其共同取决于边界框包含对象的概率 Pr(object) 和边界框的几何精度 IoU truth pred。相关计算公式为：</p> 
  <ul><li> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
          
           
            
             
             
               P 
              
             
               r 
              
             
            
              ( 
             
            
              C 
             
            
              l 
             
            
              a 
             
            
              s 
             
             
             
               s 
              
             
               i 
              
             
            
              ∣ 
             
            
              O 
             
            
              b 
             
            
              j 
             
            
              e 
             
            
              c 
             
            
              t 
             
            
              ) 
             
            
              ∗ 
             
             
             
               P 
              
             
               r 
              
             
            
              ( 
             
            
              O 
             
            
              b 
             
            
              j 
             
            
              e 
             
            
              c 
             
            
              t 
             
            
              ) 
             
            
              ∗ 
             
            
              I 
             
            
              o 
             
             
             
               U 
              
              
              
                p 
               
              
                r 
               
              
                e 
               
              
                d 
               
              
              
              
                t 
               
              
                r 
               
              
                u 
               
              
                s 
               
              
                t 
               
              
             
            
              = 
             
             
             
               P 
              
             
               r 
              
             
            
              ( 
             
            
              C 
             
            
              l 
             
            
              a 
             
            
              s 
             
             
             
               s 
              
             
               i 
              
             
            
              ) 
             
            
              ∗ 
             
            
              I 
             
            
              o 
             
             
             
               U 
              
              
              
                p 
               
              
                r 
               
              
                e 
               
              
                d 
               
              
              
              
                t 
               
              
                r 
               
              
                u 
               
              
                t 
               
              
                h 
               
              
             
            
           
             P_r(Class_i|Object)*P_r(Object)*IoU^{trust}_{pred}=P_r(Class_i)*IoU^{truth}_{pred} 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">Cl</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mord mathnormal" style="margin-right: 0.0572em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mord mathnormal" style="margin-right: 0.0572em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.2267em; vertical-align: -0.3831em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8436em;"><span class="" style="top: -2.453em; margin-left: -0.109em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">d</span></span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">Cl</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.2822em; vertical-align: -0.3831em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -2.453em; margin-left: -0.109em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">d</span></span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></p> </li><li> <p>其中Pr(object)表示对象的概率，IoUtruth pred是几何精度，Pr(Classi|Object)表示条件类别概率。 YOLO的每个边界框包含五个预测值：x、y、w、h和confidence，其中(x,y)表示边界框中心相对于网格边界的坐标位置，w和h表示相对于整个图像的预测宽度和高度。这四个值都是0到1之间的比例系数。此外，confidence表示置信度得分。</p> </li><li> <p>单次检测器（SSD）放弃了当前使用边界框假设对像素或特征进行重采样的做法，<strong>通过消除边界框提议和随后的像素或特征重组阶段来实现加速目标</strong>。此外，SSD使用小卷积核来预测边界框位置处对象的类别和偏移，并采用独立的预测器来检测不同的纵横比。借助上述过滤器，它还在后期网络阶段在多个特征图中执行多尺度检测。在VOC 2007测试集上，SSD的检测速度为59 FPS，而Faster R-CNN的检测速度仅为7 FPS，YOLOv1的检测速度为45 FPS。</p> </li></ul> </li><li> <p>尽管识别速度比 Faster R-CNN 更快，但 YOLOv1 的目标定位能力比 Faster R-CNN 弱，原因是只选择了几个边界框进行预测，并且目标长宽比的泛化率较低。 YOLOv2作为一种改进方法，采用多种策略来增强定位精度，例如（1）BN：YOLOv2在每个卷积层之后添加BN层，并删除dropout，从而增强其mAP 2.4%。 （2）Anchor Boxes：YOLOv2借鉴了Faster R-CNN中的anchor free策略来促进网络收敛。 (3)YOLOv2利用了名为Darknet-19的特征网络，有助于降低约33%的计算负担。</p> </li><li> <p>YOLOv3通过引入残差网络和特征的多尺度融合，进一步提高了网络识别率。它通过在暗网中引入残差网络构建来加深网络深度。由于改进后的网络有53个卷积层，因此也被命名为Darknet-53。在 ImageNet 上，Darknet-53 的识别率与 ResNet-101 和 ResNet-152 相似，尽管其识别速度要快得多。</p> </li><li> <p>YOLOv4 于 2020 年提出，还将近年来开发的各种 CNN 优化策略引入到网络架构中。 YOLOv4应用了能力更强的CSPNet作为骨干。通过Mosaic数据增强，YOLOv4将四张训练图像合并为一张进行训练，从而提高了模型的鲁棒性。此外，YOLOv4引入了自对抗训练来增强网络对对抗攻击的抵抗力。在 MS COCO 数据集上，YOLOv4 利用 Tesla V100 GPU 实现了 43.5% 的 AP 网络精度，推理速度接近 65 FPS。同年，Glenn 将 YOLOv5 上传到 Github。与之前的系列相比，<strong>YOLOv5增加了自适应anchor计算的功能，并且还采用anchor的长宽比作为反向传播和迭代的参数来适应groundtruth</strong>。除此之外，与YOLOv4相比，YOLOv5用于修改CSPnet结构，然后应用于检测器的颈部。结合这些优化策略，YOLOv5取得了更高效的训练结果。</p> </li><li> <p>2021年，Ge等人提出了YOLOX的网络架构，他们认为耦合的探测器头可能会损害网络性能，并采用解耦头的方法，与端到端的方法相比，AP提高了4.2%。此外，Ge等人<strong>提出了SimOTA（简化最优传输分配）的示例匹配方案，基于网络自身的预测来计算anchor box与groundtruth之间的匹配关系，而不是使用anchor作为先验帧</strong>。与现有模型相比，YOLOX 在 coco 数据集上获得了更快、更高的准确性。表7详细介绍了R-CNN、SPPNet、Fast R-CNN、Faster R-CNN、YOLOv1-v5、YOLOX和SSD在每一步的算法差异比较。</p> </li><li> <p>特别是，已经产生了许多巧妙的网络结构来应对目标检测网络中的多尺度目标问题。 Lin 等人提出了一种称为特征金字塔网络（FPN）的架构，它通过上采样层生成一系列自下而上的特征图，并将它们与先前相同大小的特征图连接起来。 Wang等人给出的PANet结构采用FPN上采样后的特征图，然后将其通过一系列自上而下的下采样。此外，PANet 还为自上而下和自下而上的模块添加了跨多个层的快捷方式，用于连接特征图。除此之外，Qin等人设计的ThunderNet使用全局融合模型（GFM）来融合每个尺寸的特征并执行二次下采样过程。进一步研究了跨尺度连通性。简单高效的加权双向特征金字塔网络（BiFPN）进一步实现了基于PANet的跨尺度连接优化。换句话说，在原始下采样层中提供了到附加下采样层的附加连接，以融合更多特征，而不会显着增加计算成本。这种设计使得ThunderNet在轻量级网络中表现更好。此外，Wang 等人提出的精确融合模型（EFM）根据锚点的大小选择融合特征。下图直观地展示了 FPN、PANet、BiFPN、GFM 和 EFM 架构之间的差异。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/77/a4/b2kxW1CU_o.png" alt="在这里插入图片描述"></p> </li><li> <p>PANet架构</p> </li></ul> </li></ul> 
<h4><a id="Transformer_encoder_270"></a>Transformer encoder</h4> 
<ul><li> <p>Vaswani 等人提出的注意力机制最初被广泛用作自然语言处理 (NLP) 领域的骨干网。 2020年，Dosovitskiy等人将注意力机制的思想应用到计算机视觉领域，还提出了Vision Transformer（ViT）模块。在大规模数据集的支持下，ViT模型可以达到与CNN模型相当的精度。下图 显示了 ViT 模块中 Transformer 编码器的架构。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/92/f1/BQEvFKeC_o.png" alt="在这里插入图片描述"></p> </li><li> <p>Transformer encoder architecture</p> </li></ul> </li><li> <p>Transformer 编码器的输入是 1D 令牌嵌入，并且在输入之前应将 3D 特征图展平为 2D 块。 Transformer 编码器由多层、多头自注意力 (MHSA) 和 MLP 块组成。此外，在每个块之前应用Layer Norm层，并且在每个块之后采用残差连接。除此之外，MLP 块包含 GELU 和两个 Layer Norm 层。表 8 总结了带有 Transformer 的卷积的性能比较和分析。</p> </li><li> <p>然而，一些研究表明，ViT 模型与 CNN 相比缺乏可优化性，这是由于 ViT 缺乏空间归纳偏差 。因此，在ViT模型中使用卷积策略来削弱这种偏差可以提高其稳定性和性能。 2021 年，Graham 等人将 Transformer 和 CNN 结合起来，提出了一个名为 LeViT 的网络。 Graham 等人提出了在 ViT 中组合位置信息的注意偏差的想法。 Wang等人提出的金字塔视觉变换器（PVT）。将 Transformer 合并到 CNN 中，以克服 Transformer 编码器在密集预测任务中的缺点。 PVT 可以在图像的密集分区上进行训练，以实现高输出分辨率。 Yuan 等人提出了一种名为 TokensTo-Token Vision Transformer (T2T-ViT) 的网络架构。通过递归地将相邻的Token聚合成一个Token，最终将图像一步步结构化为Token。此外，实验表明，<strong>T2T-ViT 架构在 CNN 架构下提供了一个具有更深、更窄主干的高效主干</strong>。 Mehta 等人将 Vit 连接到 MobileNet v2 中，并提出了 MobileViT，这是一种用于移动设备的轻量级网络。结果显示，MobileViT 对于不同的任务和数据集明显优于其他轻量级网络。</p> </li><li> <p>Zhang 等人和 Zhu 等人将 ViT 模块和 yolo 结合起来，用于识别无人机（UAV）捕获的图像。值得注意的是，这些数据集存在目标尺度差异极大、背景复杂、密度高、大量物体遮挡等问题。实验结果表明，<strong>注意力机制可以在一定程度上弥补卷积的全局信息的不足，并且他们的模型获得的结果非常出色</strong>。</p> </li><li> <p>Wu等人提出的视觉Transformer（VTs）不是直接使用特征图作为ViT中Transformer编码器的输入，而是通过Tokenizer将特征图转换为一系列视觉标记，然后将处理后的视觉标记进行投影通过投影仪投影到原始地图和原始图像上。然后，实验表明，VT 在使用更少的 FLOP 和参数的情况下将 ImageNet top-1 的 ResNet 精度提高了 4.6 到 7 个点。</p> </li><li> <p>Peng 等人提出了一种名为 Conformer的混合网络结构，它是第一个将 CNN 和 Transformer 模块并行结合起来的网络，通过特征耦合单元 (FCU) 在每个阶段与局部和全局特征进行交互），从而兼具了 CNN 和 Transformer 的优点。</p> </li><li> <p>此外，在 ImageNet 上，Conformer 的性能比 VT (DeiT-B) 好 2.3%，而在 MSCOCO 上，它在目标检测和实例分割的 mAP 上分别比 ResNet-101 好 3.7% 和 3.6%。 Srinivas 等人提出了一种名为 BoTNet 的架构，通过在 ResNet 的最后三个瓶颈块中用全局自注意力替换空间卷积来显着改善基线。 Dai等人提出了一种名为CoAtNets网络结构，并提出CNN的深层结构和注意力机制可以通过简单的相对注意力关联起来。此外，他们发现堆叠卷积层和 Transformer 编码器原则上可以产生良好的结果。 CoAtNets 在 ImageNet-21K 上实现了 88.56% 的准确率，在 JFT-3B 的扩展上实现了 90.88% 的准确率。刘等人。引入了一种名为 Swin Transformer 的分层 Transformer，通过移动窗口将自注意力计算限制在非重叠的本地窗口，同时允许跨窗口连接，在 Imagenet-1K 上实现了 87.3% 的准确率。</p> </li></ul> 
<h3><a id="Network_architecture_compression_291"></a>Network architecture compression</h3> 
<ul><li> <p>自20世纪90年代以来，CNN架构的创新不断被探索，CNN的复杂性及其训练所需的资源也不断增加。同时，在保证网络精度的前提下，模型训练和识别的压缩和加速成为CNN架构优化领域的必要条件。 CNN 从卷积层到 FC 层有大量冗余参数。<strong>大多数激活的神经元的输出值接近于0。即使消除这些神经元，模型特征也能表达。这种现象称为过度参数化。通过减少网络架构中的冗余，可以加速训练和识别，并减少内存</strong>。</p> </li><li> <p>下图 说明了用于 CNN 架构优化的不同类型的分类方法。其中，<strong>网络剪枝技术包括权值连接剪枝和神经元剪枝。张量分解技术包括奇异值分解、Tucker分解、正则多元(CP)分解、块项分解和张量序列分解。网络量化技术包括二值量化、三值量化和哈希量化</strong>。我们从网络剪枝、张量分解、网络量化和知识迁移四个方面详细阐述了CNN架构的优化思路。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/11/03/jTSRTBGt_o.png" alt="在这里插入图片描述"></p> </li><li> <p>CNN 架构优化的四种分类方法</p> </li></ul> </li></ul> 
<h4><a id="Network_pruning_302"></a>Network pruning</h4> 
<ul><li> <p>此前，网络剪枝已被证明是降低网络复杂性和过度拟合的有效方法。目前，剪枝是压缩网络模型最常用的方法。值得注意的是，<strong>剪枝的概念并不局限于 CNN。 Dropout和DropConnect代表了两种非常典型的模型剪枝技术</strong>。 Dropout的思想是随机将几个神经元的输出设置为0，而DropConnect的思想是随机将一些神经元之间的连接设置为0。与这两种思想一致的是，有两种方法，称为神经元剪枝和权值连接剪枝。下面的下图描述了突触和神经元的修剪。一般来说，权值连接剪枝是采用稀疏矩阵存储权值矩阵，不重要的权值连接设置为0。而神经元剪枝则直接去除重要性较低的神经元。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/79/f7/6lBWyYFf_o.png" alt="在这里插入图片描述"></p> </li><li> <p>突触和神经元的修剪</p> </li></ul> </li><li> <p>实际上，CNNs模型的剪枝方法并不限于上述。目前常见的剪枝做法一般<strong>可以描述为训练网络、剪枝、重新训练权重、再次剪枝、重新训练，直到形成满足设定条件的步骤</strong>。下图显示了根据修剪粒度分类的网络修剪方法。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/ec/97/Nvbupvsd_o.png" alt="在这里插入图片描述"></p> </li><li> <p>按剪枝粒度分类的剪枝方法</p> </li></ul> </li><li> <p>从细到粗分别是细粒度剪枝、向量级剪枝、内核级剪枝、组级剪枝和过滤器级剪枝。它们改变了固有的网络拓扑，需要设计特定的算法来支持剪枝操作，属于非结构化剪枝。</p> </li></ul> 
<h5><a id="Finegrained_pruning_320"></a>Fine‑grained pruning</h5> 
<ul><li> <p>细粒度剪枝是指剪枝网络中神经元之间的连接或神经元本身。<strong>卷积核中任何不重要的参数都可以被修剪</strong>。这个概念在深度神经网络（DNN）提出之前就已经被应用。 LeCun等人于1989年提出了最优脑损伤（OBD），将实际神经网络中的参数减少了四倍。通过OBD，网络自动删除参数，从而使网络训练速度显着提高，识别精度略有提高。 Hanson 等人在误差函数中引入了权重衰减项，以使网络稀疏。换句话说，他们<strong>通过减少隐藏节点的数量来降低网络复杂性</strong>。</p> </li><li> <p>早在1993年，Hassibi等人就提出了最佳脑外科医生（OBS），然后将其性能与OBD进行了比较。他们的结果表明：（1）<strong>基于损失函数 Hessian 矩阵的网络剪枝比基于权重衰减的剪枝更准确</strong>。 (2)OBS中抛弃了Hessian矩阵的约束，因此其泛化能力比OBD更强大。然而，在大型网络架构的情况下，OBS 和 OBD 损失函数的二阶导数需要相当大的计算负担。 2015 年，斯里尼瓦斯等人。对 FC 层中的神经元而不是网络连接进行修剪操作。他们对 FC 层的修剪技术与 OBS 非常相似。通过大量的导数近似，他们的方法消除了对训练数据的依赖。同年，韩等人提出了一种深度压缩框架，<strong>他们分别通过剪枝、量化和霍夫曼编码三个步骤来压缩 DNN</strong>。 Han等人同年提出的深度压缩进一步优化了网络架构，综合应用了剪枝、量化和编码等技术。</p> </li><li> <p>Guo等人在2016年指出，参数的重要性会随着网络训练的开始而不断变化，<strong>因此恢复重要的剪枝连接对于提高网络性能将起到至关重要的作用。他们在修剪过程中添加了恢复操作</strong>。因此，被修剪的网络连接可以在变得重要时重新激活。每次训练后这两个操作交替进行，极大地提高了在线学习效率。同年，Zhou等人<strong>采用前向-后向分裂方法处理稀疏约束的损失函数，显着减少了网络中的神经元数量</strong>。为了解决无法直接结合和应用 Winograd 的最小过滤算法和网络剪枝技术的问题，Liu 等人于 2017 年提出，在剪枝 Winograd 变换权重之前，将 ReLU 激活函数转移到 Winograd 域。这种方法在 CIFAR-10、CIFAR-100 和 ImageNet 数据集上分别减少了 10.4、6.8 和 10.8 倍的乘法操作数数量。 2019 年，陈等人提出了称为通道门控的细粒度动态方法来修剪 CNN 推理。通道网关识别每个 CNN 层的特征图区域，这些区域对分类结果的贡献较小，并且还关闭通道子集以计算此类不重要区域的激活。 2021 年，Zhang 等人提出了 ClickTrain，通过细粒度的架构保留剪枝提供更高的模型精度和压缩。同年，孙等人。提出了一种称为 DominoSearch 的细粒度修剪方法。他们认为，现有的N:M细粒度稀疏神经网络算法仅适用于每层具有相同N:M稀疏度的情况，<strong>并且在稀疏度&gt;80%时精度急剧下降</strong>。 DominoSearch可以从预训练的网络中找到混合的N:M稀疏方案，在相同复杂度约束下比传统方案获得更高的精度。</p> </li></ul> 
<h5><a id="Vectorlevel_and_kernellevel_pruning_328"></a>Vector‑level and kernel‑level pruning</h5> 
<ul><li> <p>与细粒度剪枝相比，向量级和核级剪枝处理的粒度更粗。向量级剪枝修剪卷积核内的向量，而核级剪枝则去除滤波器中的2D卷积核。 2017年，Mao等人<strong>探索了不同级别的剪枝粒度，发现向量级剪枝比细粒度剪枝占用更少的内存空间，因为它需要更少的索引来指示剪枝参数</strong>。一般来说，结构化剪枝比非结构化剪枝对内存访问更友好。因此，<strong>实际上，向量、卷积核和滤波器剪枝技术对于硬件实现来说更有效</strong>。</p> </li><li> <p>Anwar 等人于 2017 年首次提出内核级剪枝的想法，其中引入了内核内跨步稀疏性的概念。该方法使用对应于N个卷积层的N个粒子滤波器执行剪枝操作。<strong>通过将细粒度剪枝转化为结构化剪枝，以固定步长对子向量进行剪枝</strong>。 2020年，Ma等人和Niu等人将细粒度剪枝模式引入到粗粒度结构中以进行内核级剪枝。 PCONV 包含两种稀疏性。<strong>一是通过卷积核剪枝生成的稀疏卷积模式（SCP），由于其独特的视觉特征而提高了准确率。另一个是指卷积核剪枝产生的连通性稀疏性，它保持滤波器计算工作量的平衡</strong>。 2021年，受神经生物学的启发，Ding等人提出了一种名为ResRep的内核级无损剪枝方法。与传统剪枝方法不同，<strong>它将CNN分为用于保持性能的记忆部分和用于学习的遗忘部分修剪。记忆部分使用SGD进行训练，后者使用惩罚梯度规则进行剪枝</strong>。</p> </li></ul> 
<h5><a id="Grouplevel_pruning_334"></a>Group‑level pruning</h5> 
<ul><li> <p>传统的组级剪枝是指根据滤波器上相同的稀疏性模式来修剪参数，要求滤波器具有相同的稀疏性模式。如下图所示，当每个卷积核中存在相同的稀疏模式时，卷积滤波器可以表示为更薄的稠密矩阵。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/61/52/yy7CUqEE_o.png" alt="在这里插入图片描述"></p> </li><li> <p>Group-level pruning</p> </li></ul> </li><li> <p>2016年，Lebedev和Lempitsky采用分组脑损伤来修剪卷积核输入，以数据驱动的方式获得最佳感受野。同年，Wen等人提出了一种标准化DNN架构的结构化稀疏学习（SSL）方法，该方法能够对具有较高非结构化稀疏度的DNN进行有效加速（在低稀疏度下，可能会出现负加速）。</p> </li><li> <p>传统方法在组大小对齐的位置修剪权重组。 2020 年，李等人提出了未对齐的组级剪枝，这可以提高压缩模型的准确性。他们的方法能够通过动态规划寻求未对齐群体选择问题的最优解决方案。乔等人提出分组动态稀疏训练（DST）。 DST可以通过训练过程中每一步的重复剪枝和恢复来提升模型的稀疏程度。该方法将DST应用于组级剪枝，从而学习每个过滤器的标准并判断权重组的重要性。 2021 年，刘等人提出了一种层分组算法来修剪复杂的网络架构，例如残差连接和组/深度卷积。除此之外，他们采用基于Fisher信息的统一度量来评估单通道和耦合通道的重要性，并自动发现复杂架构的耦合通道。实验证明该剪枝算法可以有效地部署在各种复杂结构中，例如ResNeXt、MobileNetV2和RegNet。</p> </li></ul> 
<h5><a id="Filterlevel_pruning_347"></a>Filter‑level pruning</h5> 
<ul><li> <p><strong>滤波器级剪枝用于卷积滤波器或通道，比其他方法更有效，因为修剪一层后，下一层的通道数相应减少</strong>。 2016年，Li等人提出整体全局剪枝。通过滤波器剪枝，这个想法弥补了基于幅度的方法在剪枝 FC 层方面的不足。此外，他们直接删除了对输出精度影响较小的卷积核，以及通过非稀疏连接对应的特征图。在 CIFAR10 上，VGG-16 的推理成本最多可降低 34%，ResNet-110 的推理成本最多可降低 38%，同时通过网络重新训练恢复接近原始精度。</p> </li><li> <p>2017年，Luo等人提出了一种名为ThiNet的过滤器级剪枝技术，其中使用下一个卷积层的概率信息而不是当前层的概率信息来指导当前层中的滤波器级剪枝。同年，He等人通过基于LASSO正则化和线性最小二乘的通道剪枝去除了冗余的卷积核及其相应的特征图，然后重建了残差网络。根据VGG16上的测试，他们的方法在相同加速度下比大多数现有优化算法表现出更低的精度损失。刘等人。建议应用 BN 层的缩放因子来评估滤波器的重要性。通过以接近于零的缩放因子修剪通道，可以在不向网络引入开销的情况下修剪滤波器。</p> </li><li> <p>2019年，Wang等人认为网络重要性应该独立评估。因此，没有考虑滤波器之间的冗余，参数的减少并不一定意味着计算成本的减少。为了解决现有问题，他们进一步提出了基于cop的剪枝算法。<strong>该算法能够根据用户自己的喜好，通过将参数数量和计算成本添加到重要性来检测冗余滤波器</strong>。 Li 等人使用谱聚类算法将代表预训练 CNN 模型的无向 FC 图划分为多个子图，最终为一组保留一个滤波器并重新训练剪枝后的模型。 2020年，Xu等人提出了滤波器级剪枝方法，即PNFM，该方法可以根据后一层特征图像输出的变化率来确定剪枝滤波器的重要性。此外，<strong>基于聚类算法的方法能够生成用于剪枝的微小数据集，以提高剪枝效率</strong>。</p> </li><li> <p>2021 年，Tang 等人<strong>通过将所有实例的流形信息嵌入到修剪后的网络空间中，动态删除了冗余过滤器</strong>。实例和修剪子网络之间的流形信息通过训练集中图像的识别复杂性和特征相似性进行对齐，从而最大限度地利用给定网络结构中的冗余。</p> </li></ul> 
<h4><a id="Tensor_decomposition_357"></a>Tensor decomposition</h4> 
<ul><li>显然，<mark>剪枝过程通常需要大量的预训练操作</mark>。尽管所构建的网络的运行性能得到了极大的提高，但它们在训练过程中往往会消耗更多的时间。因此，应用张量分解的思想来压缩网络规模并提高网络速度，通常通过奇异值分解、Tucker分解、CP分解和块项分解来完成。张量分解可以描述为将原始高秩张量分解为多个低秩张量的过程。对于计算机来说，这意味着减少卷积的计算负担，可以有效去除网络中的冗余信息。</li></ul> 
<h5><a id="Singular_value_decomposition_361"></a>Singular value decomposition</h5> 
<ul><li> <p>作为机器学习领域的经典算法，奇异值分解（SVD）通常用于低秩矩阵的特征分解。通过SVD，权重张量（作为卷积核）被分为两部分。即用两个连续的层代替原来的卷积层。 SVD的数学表达式为：</p> 
  <ul><li> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              W 
             
            
              ≈ 
             
            
              U 
             
            
              S 
             
             
             
               V 
              
             
               T 
              
             
            
           
             W ≈ USV^T 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8913em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">U</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8913em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.1389em;">T</span></span></span></span></span></span></span></span></span></span></span></span></span></p> </li><li> <p>其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             W 
            
           
             ε 
            
            
            
              R 
             
             
             
               m 
              
             
               × 
              
             
               n 
              
             
            
           
          
            W ε ℝ^{m×n} 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7713em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="mord mathnormal">ε</span><span class="mord"><span class="mord amsrm">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7713em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span>表示分解张量，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             U 
            
           
             ε 
            
            
            
              R 
             
             
             
               m 
              
             
               × 
              
             
               m 
              
             
            
           
          
            U ε ℝ^{m×m} 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7713em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">U</span><span class="mord mathnormal">ε</span><span class="mord"><span class="mord amsrm">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7713em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             V 
            
           
             ε 
            
            
            
              R 
             
             
             
               n 
              
             
               × 
              
             
               n 
              
             
            
           
          
            V ε ℝ^{n×n} 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7713em;"></span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mord mathnormal">ε</span><span class="mord"><span class="mord amsrm">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7713em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span>表示正交矩阵，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             S 
            
           
             ε 
            
            
            
              R 
             
             
             
               m 
              
             
               × 
              
             
               n 
              
             
            
           
          
            S ε ℝ^{m×n} 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7713em;"></span><span class="mord mathnormal">Sε</span><span class="mord"><span class="mord amsrm">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7713em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span> 是对角矩阵。</p> </li></ul> </li><li> <p>下图 说明了全卷积和 SVD 卷积过程，其中 CNN 中的卷积核 K 是四维（4D）张量，K ∈ ℝd×d×S×T 是 4D 张量，其中 S、d 和 T 分别表示输入通道、卷积核大小和输出通道。张量 P ε ℝT×K 和 W‘ ε ℝK×d×d×S 由张量 K 分解，即：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           K 
          
         
           ≈ 
          
         
           P 
          
          
          
            W 
           
          
            ′ 
           
          
         
        
          K ≈ PW' 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7519em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7519em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>。当原始张量的复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
          
          
            d 
           
          
            2 
           
          
         
           S 
          
         
           T 
          
         
           ) 
          
         
        
          O(d^2ST) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right: 0.1389em;">ST</span><span class="mclose">)</span></span></span></span></span>时，分解张量 P 和 W′ 的复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           T 
          
         
           K 
          
         
           ) 
          
         
           + 
          
         
           O 
          
         
           ( 
          
          
          
            d 
           
          
            2 
           
          
         
           K 
          
         
           S 
          
         
           ) 
          
         
        
          O(TK) + O(d^2KS) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mclose">)</span></span></span></span></span>。而且K值越小，压缩效果越强。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/d6/e2/5V43I6Cd_o.png" alt="在这里插入图片描述"></p> </li><li> <p>全卷积和SVD卷积过程：a全卷积，b SVD</p> </li></ul> </li><li> <p>2013 年，Denil 等人利用张量分解的思想来提高 CNN 的性能。 Denil 表示，与 OBD 相比，他们的工作可以在网络训练之前而不是之后进行预测，从而限制了参数的数量。在 MNIST 数据集上，该方法可以预测超过 95% 的网络权重，而不会影响网络精度。借用Jaderberg等人使用的张量分解思想。 Denton 等人通过张量低阶扩展技术加速 CNN。贾德伯格等人提出了在场景字符分类数据集上训练的 4 层 CNN，<strong>它将 k × k 滤波器分解为不对称的 k × 1 和 1 × k 滤波器</strong>。在不损失精度的情况下实现 2.5 倍加速，在精度下降不到 1% 的情况下实现 4.5 倍加速。丹顿等人 通过利用神经网络的线性架构发现了适当的低秩参数近似。它实现了CPU和GPU的2倍加速，同时保证精度在原始精度的1%以内。 2015年，Zhang等人借用了Jaderberg使用的<strong>非对称张量分解来加速整体网络运行</strong>，在VGG-16模型上实现了3.8倍的加速。 Liu等人在SVD的基础上加入稀疏性（代表滤波器权重），通过卷积核的稀疏分解来减少网络参数的冗余度。这种方法在 AlexNet 中实现了超过 90% 的卷积层稀疏性，并且在 ILSVRC2012 数据集上实现了不到 1% 的精度损失。</p> </li><li> <p>2020年，Li等人通过用SVD补充过滤器剪枝，解决了在具有快捷连接的网络结构（例如ResNet）中无法完成剪枝操作的问题。他们建议使用稀疏诱导矩阵将剪枝和分解结合起来，并提出了统一的表示。此外，他们还引入了各种算法，例如二分搜索、基于梯度的学习率调整层平衡和退火方法。</p> </li></ul> 
<h5><a id="Tucker_decomposition_382"></a>Tucker decomposition</h5> 
<ul><li> <p>下图 描述了 Tucker 分解过程，其目的是将卷积核 K ∈ ℝd×d×S×T 分解为一个核张量和几个因子矩阵。其数学表达式为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           K 
          
         
           = 
          
          
          
            ∑ 
           
           
            
            
              r 
             
            
              3 
             
            
           
             = 
            
           
             1 
            
           
           
           
             R 
            
           
             3 
            
           
          
          
          
            ∑ 
           
           
            
            
              r 
             
            
              4 
             
            
           
             = 
            
           
             1 
            
           
           
           
             R 
            
           
             4 
            
           
          
          
          
            C 
           
           
            
            
              r 
             
            
              3 
             
            
           
             , 
            
            
            
              r 
             
            
              4 
             
            
           
          
          
          
            U 
           
           
           
             s 
            
           
             , 
            
            
            
              r 
             
            
              3 
             
            
           
           
           
             ( 
            
           
             3 
            
           
             ) 
            
           
          
          
          
            U 
           
           
           
             t 
            
           
             , 
            
            
            
              r 
             
            
              4 
             
            
           
           
           
             ( 
            
           
             4 
            
           
             ) 
            
           
          
         
        
          K=\sum^{R_3}_{r_3=1}\sum^{R_4}_{r_4=1}C_{r_3,r_4}U_{s,r_3}^{(3)}U_{t,r_4}^{(4)} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.4446em; vertical-align: -0.3998em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9812em;"><span class="" style="top: -2.4003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.0278em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0077em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.0077em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3998em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9812em;"><span class="" style="top: -2.4003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.0278em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0077em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.0077em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3998em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0715em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.0278em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.0278em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.0448em;"><span class="" style="top: -2.5834em; margin-left: -0.109em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.0278em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.2198em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">3</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2527em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.0448em;"><span class="" style="top: -2.4542em; margin-left: -0.109em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.0278em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.2198em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">4</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3819em;"><span class=""></span></span></span></span></span></span></span></span></span></span>.其中 C ε ℝd×d×R3×R4 ，U(3) ε ℝS×R4 ，U(4) ε ℝT×R4 。</p> 
  <ul><li><img src="https://images2.imgbox.com/ca/4e/LG0BKn8t_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>2015年，Kim等人提出了一种基于变分贝叶斯低秩选择和Tucker张量分解的整体压缩方法。由于大大减少了模型大小、运行时间和能耗，使用这种方法压缩的网络可以移植到移动设备上运行。 2020 年，林等人。提出了一种广义的高阶 Tucker Articulated Kernels (HOT-CAKE) 方法。该方法执行输入通道分解，指导 Tucker 等级选择、高阶 Tucker 分解以及每个 CONV 层的微调。实验表明，HOTCAKE 可以压缩预压缩模型并生成最新的轻量级网络。科济斯基等人。提出了一种将塔克分解与权重和激活量化相结合的新方法。该方法包括用于多线性等级选择任务的贪婪单步和多步算法，以及应用 Tucker 分解和量化的质量恢复。</p> </li></ul> 
<h5><a id="CP_decomposition_391"></a>CP decomposition</h5> 
<ul><li> <p>下图显示了CP分解的过程，<strong>可以将其视为Tucker分解的特例</strong>。显然，在Tucker分解中，算法根据张量本身的秩进行分解，而在CP分解中，需要预先设定秩值进行迭代，而分解矩阵的秩选择是一个NP难题。选择合适的rank后，其算法可以用数学表达为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           K 
          
         
           = 
          
         
           ∑ 
          
          
          
            K 
           
          
            x 
           
          
         
           × 
          
          
          
            K 
           
          
            y 
           
          
         
           × 
          
          
          
            K 
           
          
            s 
           
          
         
           × 
          
          
          
            K 
           
          
            t 
           
          
         
        
          K = ∑ K^x × K^y × K^s × K^t 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6644em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6644em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">y</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6644em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7936em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7936em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span>.其中 Kx ε ℝd×R ，Ky ε ℝd×R ，Ks ε ℝS×R ，Kt ε ℝS×R 。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/a6/25/CfdVsZQT_o.png" alt="在这里插入图片描述"></p> </li><li> <p>CP decomposition process</p> </li></ul> </li><li> <p>Lebedev等人提出了一种基于CP分解的核张量分解方法，通过非线性最小二乘技术将卷积核分解为四个一阶核张量。对于36类ILSVRC分类实验，该方法可以在CPU上获得8.5倍的加速。实验结果还表明张量分解发挥了正则化作用。此外，Lebedev 等人在他们的研究中还指出，<strong>良好的 SGD 学习率很难达到，这意味着优化 ImageNet 模型中的单层分解并不是一件容易的事</strong>。 2018年，Astrid和Lee提出了一种基于优化所有卷积层CP分解的网络压缩方法。每个单层网络分解后，对整个网络进行微调，以克服CP分解不稳定导致的网络精度下降。 2019 年，Zhou 等人提出了两种根据噪声测量估计 CP 张量秩的方法。一种是直接使用 CNN 进行 CP 排名估计。另一种是在特征获取中引入预分解，可以将Rank-1分量输入到CNN中。</p> </li></ul> 
<h5><a id="Block_term_decomposition_402"></a>Block term decomposition</h5> 
<ul><li> <p>Wang 和 Cheng在 2016 年提出了一种称为块项分解 (BTD) 的 CNN 加速技术。下图说明了张量 BTD 过程。假设卷积核是一个 3D 张量 T ∈ ℝS×T×P ，其中 P 表示空间维度。该算法的数学表达式为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           T 
          
         
           = 
          
          
          
            Σ 
           
           
           
             r 
            
           
             = 
            
           
             1 
            
           
          
            R 
           
          
          
          
            G 
           
          
            r 
           
          
         
           × 
          
          
          
            A 
           
          
            r 
           
          
         
           × 
          
          
          
            B 
           
          
            r 
           
          
         
           × 
          
          
          
            C 
           
          
            r 
           
          
         
        
          T = Σ^R_{r=1} G_r × A_r × B_r × C_r 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.0894em; vertical-align: -0.2481em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8413em;"><span class="" style="top: -2.4519em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0077em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2481em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0502em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0502em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0715em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>.其中 Gr ε ℝs×t×p 表示第 r 次分解的核心张量，Ar ε ℝS×s ，Br ε ℝT×t ，Cr ε ℝP×p 表示沿每个维度的因子矩阵。小写字母 s、t 和 p 表示每个维度的等级。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/95/70/yipMe7uF_o.png" alt="在这里插入图片描述"></p> </li><li> <p>BTD process</p> </li></ul> </li><li> <p>根据ILSVRC-12的综合实验，该算法显着降低了计算复杂度，但精度损失可以忽略不计。对于广泛应用的VGG-16模型，该方法在整个PC网络上获得了6.6倍的加速，在移动设备上获得了5.91倍的加速，保持top-5误差的增加小于1%。</p> </li><li> <p>2020年，Ye等人探索了权重矩阵的相关性，并采用低秩块项张量来近似权重矩阵。使用这种低秩权重矩阵的层结构称为块项张量层（BT 层），它非常适合 CNN。从实验结果可以看出，BT层给网络带来了很大的压缩，BT层的输入和输出被重塑为低维高阶张量。在这种情况下，CNN 获得了更好的表示能力。</p> </li></ul> 
<h5><a id="Tensortrain_decomposition_415"></a>Tensor‑train decomposition</h5> 
<ul><li> <p>2015年，Novikov等人使用张量训练分解（TTD）<strong>将FC层的稠密权重矩阵转换为张量训练</strong>（TT）格式。该方法将VGG的FC层的稠密权重矩阵压缩了高达200000倍，从而导致整个网络的压缩因子高达7倍。下图说明了 TTD 的处理过程。假设滤波器是一个 4D 张量 K = l1 × 12 × C × S ，其中 l1&amp;12 表示内核的大小，C = c1…cd 和 S = s1…sd 表示输入和输出通道的数量分别。数学表达式为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           K 
          
         
           = 
          
         
           G 
          
         
           0 
          
         
           ° 
          
         
           G 
          
         
           1 
          
         
           ° 
          
         
           G 
          
         
           2 
          
         
           ° 
          
         
           . 
          
         
           . 
          
         
           . 
          
         
           ° 
          
         
           G 
          
         
           d 
          
         
           − 
          
         
           1 
          
         
           ° 
          
         
           G 
          
         
           d 
          
         
        
          K = G0°G1°G2°...°Gd−1°Gd 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">G</span><span class="mord">0°</span><span class="mord mathnormal">G</span><span class="mord">1°</span><span class="mord mathnormal">G</span><span class="mord">2°...°</span><span class="mord mathnormal">G</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord">1°</span><span class="mord mathnormal">G</span><span class="mord mathnormal">d</span></span></span></span></span>;其中 Gd ∈ ℝri×cisi×ri+1 表示 0 &lt; i &lt; d 的第 i 次分解的张量序列格式。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/38/0d/mp365qyN_o.png" alt="在这里插入图片描述"></p> </li><li> <p>TTD process</p> </li></ul> </li><li> <p>2021 年，Sharma 等人将 TTD 应用于卷积自动编码器 (CAE) 。通过调整张量级别，他们成功地使用模型来调整学习参数的数量，而无需改变网络结构。同年，Lee 等人结合 TTD 和数据量化方法构建了一个名为 QTTNet 的模型。他们的方法能够同时降低数据的位宽和更少的可训练参数。 Wang 等人认为张量分解会带来严重的精度损失，因此他们提出了一种新的非线性张量训练（NTT）格式。 <strong>NTT 包含额外的非线性激活函数，以补偿普通 TT 无法提供的精度损失</strong>。</p> </li></ul> 
<h4><a id="Network_quantitative_426"></a>Network quantitative</h4> 
<ul><li>与<strong>通过删除权重和张量分解来减小模型大小以及通过分解卷积核来降低复杂性的剪枝相比，量化的目的是减少存储权重所需的位数</strong>。通过量化可以显着减少内存，即通过减少每个参数所需的位数来压缩原始网络。根据量化结果的不同，网络量化方法可以分为标量量化和矢量量化、二值量化、三值量化、多比特量化和哈希量化。其中二值量化、三值量化、多比特量化和散列量化都属于定点量化。</li></ul> 
<h5><a id="Scalar_and_vector_quantization_430"></a>Scalar and vector quantization</h5> 
<ul><li> <p>用标量或向量量化CNN的思想借鉴了早期的有损压缩技术，采用码本和量化码来恢复原始数据。矢量量化定义了量化器，即将维度向量转换为码本中的向量的映射函数。</p> </li><li> <p>为了优化量化器，必须满足劳埃德最优性条件。因此，K均值聚类算法可以应用于求解最优量化器。 2011年，Jegou等人开发了FC层的乘积量化（PQ）算法。 PQ量化器将原始向量空间分解为多个低维向量空间的笛卡尔积，并对分解后的低维向量空间进行K-means计算码本。量化器转换过程可以用数学表达为：</p> 
  <ul><li> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              x 
             
             
             
               → 
              
             
               q 
              
             
            
              q 
             
            
              ( 
             
            
              x 
             
            
              ) 
             
             
            
              x 
             
            
              ∈ 
             
             
             
               R 
              
             
               D 
              
             
            
              , 
             
            
              q 
             
            
              ( 
             
            
              x 
             
            
              ) 
             
            
              ∈ 
             
            
              C 
             
            
              = 
             
             
             
               c 
              
             
               i 
              
             
             
            
              i 
             
            
              ∈ 
             
            
              I 
             
            
              , 
             
            
              I 
             
            
              = 
             
            
              0 
             
            
              , 
             
            
              … 
             
            
              , 
             
            
              k 
             
            
              − 
             
            
              1 
             
            
           
             x\rightarrow^qq(x)\\ x \in R^D, q(x) \in C = c_i\\ i\in I, I = 0, … , k − 1 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7144em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel"><span class="mrel">→</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7144em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">q</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.1413em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8913em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">D</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.6986em; vertical-align: -0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span></span></p> </li><li> <p>其中q(.)表示映射函数，ci表示中心粒，I表示预定义索引集，k表示码本的大小。</p> </li></ul> </li><li> <p>在构建PQ量化器后，作者提出了两种方法，即对称距离计算（SDC）和非对称距离计算（ADC）来解决相似性搜索问题。两种计算方法对应的数学公式为：</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/0a/d1/om9BRsCB_o.png" alt="在这里插入图片描述"></p> </li><li> <p>其中x表示查询向量，y表示数据集中的某个向量，d(.),→d(.)分别表示向量之间的实际距离和近似距离。</p> </li></ul> </li><li> <p>直观地可以看出，两种算法的主要区别在于查询向量是否被量化。此外，作者提出了IVFADC算法，将ADC算法修改为两层量化。第一层是粗量化器，其中 k’ = √n 个簇是基于原始向量空间中的 K 均值获得的。第二层对每个数据的残差数据集及其对应的量化中心进行PQ量化，进一步减少计算负担。</p> </li><li> <p>2014年，Gong等人通过K-means方法量化了权重。聚类后​​，使用相同的索引和该索引对应的平均中心来表示相同簇的权重。同时，存储簇索引号和码本。实验结果表明，对于1000个ImageNet分类任务，该方法实现了16-24倍的压缩比，且准确率下降小于1%。 Wu等人指出，虽然许多现有算法可以达到良好的压缩效果，但它们主要针对FC层而不是整个网络。作者使用 PQ 算法同时加速和压缩 CNN。该方法几乎可以在不损失精度的情况下实现4<sub>6×的加速和15</sub>20×的压缩比，精度损失小于1%。 2017年，Cheng等人使用类似的方法进行了测试，得到了相同的加速度和压缩比。 2019 年，Lee 等人。提出了一种基于矢量量化模型压缩技术的 DNN 加速器。该算法很好地压缩了 FC 层和卷积层的 NN 模型。实验证明，与最先进的技术相比，它可以实现 10-20 倍的压缩率、4.2 倍的内存访问减少和 2.05 倍的批次一推理每个周期吞吐量。</p> </li></ul> 
<h5><a id="Binary_quantization_455"></a>Binary quantization</h5> 
<ul><li> <p>二进制量化是指在DNN的正向和反向训练中用二进制权重代替浮点权重。库巴里奥等人。 2015 年推出了 Binary Connect，这是一种在前向和后向传播过程中使用二进制权重训练 DNN 的方法 。它保留了作为梯度累积的存储权重的准确性。根据实验，在具有相同安排的 MNIST、CIFAR-10 和 SVHN 上使用 Binary Connect 获得了近乎最新的结果。 Courbariaux 等人的另一项工作表明，量化权重和激活可以导致网络存储的更大压缩。 Courbariaux等人提出的二值化神经网络（BNN）可以在CIFAR-10数据集上达到与全精度基线相当的精度。为了扩展 ImageNet 分类任务所需的 BNN，Tang 等人优化了 BNN 的训练策略，并增强了策略的准确性。 2016年，Rastegari等人提出了XNOR-Net，它将滤波器和卷积层的输入都量化为二进制。与BinaryConnect和BNN相比，该方法在ImageNet上表现出优势，准确率领先16%。</p> </li><li> <p>2019年，Ding等人建议将分布损失应用于激活流的显式正则化，并提出了系统地制定损失的框架。王等人。提出了基于通道交互的二值卷积神经网络学习方法（CI-BCNN）。他们的工作降低了 CIFAR10 和 MNIST 上的计算和存储成本。同年，Nguyen等人认为频繁访问片外存储器导致网络处理速度缓慢。他们提出了一种针对二进制 YOLO 网络的 Tera-OPS 流硬件加速器。二进制权重将整个网络模型存储在具有现场可编程门阵列 (FPGA) 的块 RAM 中，这大大减少了片外访问，从而显着提高了性能。 2020年，林等人认为 Xnor-net 等二进制网络存在严重的精度下降问题。一些最好的二值网络在使用 ImageNet等大型数据集时仍然会遇到严重的精度下降问题。他们提出了一个名为 ReActNet 的二元网络。 ReActNet 引入了 React-Sign 和 ReactPrelu，从而以几乎零成本实现了分布重塑和转移的显式学习。 2021 年，J.Redfern 等人提出了一种二进制 CNN (BCNN)，所有矩阵运算都量化为 1 位精度。图像识别和物体检测的大量实验证明，与最新的解决方案相比，他们的算法更加有效。</p> </li></ul> 
<h5><a id="Ternary_quantization_461"></a>Ternary quantization</h5> 
<ul><li> <p>二值化将浮点数直接量化为1bit，而三进制则将权重量化为2bit。虽然 2bit 可以表示四个数字，但通常需要 {−1, 0, 1} 。 2016年，Li等人提出了三元权重网络（TWN），它与BWN类似，但将所有权重限制为三元值。 Zhu等人提出了训练三元量化（TTQ），它可以将神经网络的权重精度降低到三元值。该方法可以提高 CIFAR-10 上的 ResNet-32、44 和 56 模型以及 ImageNet 上的 AlexNet 模型的精度。 2017年，Wen等人提出了一种名为TernGrad的分布式深度学习方法，证明了其收敛性。该方法使用三元梯度来加速数据并行性。实验表明，TernGrad在AlexNet上的应用不会造成精度损失，而在GoogLeNet上的平均精度损失小于2%。同年，王等人提出了一种用于预训练模型的新型定点分解网络（FFN），以降低计算复杂性和存储要求。权重显着消除了消耗最多资源的乘法累加 (MAC) 运算。对大型 ImageNet 分类任务的大量实验表明，所提出的 FFN 只需千分之一的乘法运算即可达到相当的精度。 2018年，Wang等人开发了两步量化（TSQ）框架，<strong>将网络量化问题分解为以下两步：第一步是保持权重为全精度，并对激活值进行稀疏量化。第二步是通过逐层迭代来量化各个层中的元素</strong>。分层量化能够纠正量化误差。</p> </li><li> <p>2020 年，李等人。提出了三元残差量化（TRQ），为三元量化引入了干残差框架。对于 ResNet-18，TRQ 在 CIFAR-100 上仅实现 0.3% 的性能下降。对于 VGG-Small，TRQ 在 CIFAR-10 和 CIFAR-100 上始终分别超出基线 2.1% 和 3.5%。拉扎尼等人。提出了混合量化模型，即智能量化（SQ）。 <strong>SQ可以实现二值和三值量化的自适应组合。量化深度可以直接使用正则化函数进行修改，因此模型只需要训练一次</strong>。实验表明，该方法能够成功适应量化深度，并在 MNIST 和 CIFAR10 基准上保持较高的模型精度。 Liu 等人开发了剪枝三元量化（PTQ），将剪枝和量化统一起来，以提供一定范围的尺寸精度权衡。 <strong>PTQ 基于简单剪枝和 L2 投影将常规权重转换为三元正交权重。 PTQ在ResNet-18上可以提供不超过46倍的压缩比，相应的精度达到65.36%</strong>。此外，PTQ 将 ResNet-18 模型压缩 48 倍，将 ResNet-50 模型压缩 30 倍，而 ImageNet 上的 top-1 准确率分别略有下降 4.4% 和 1.68%。</p> </li></ul> 
<h5><a id="Multibit_quantization_467"></a>Multi‑bit quantization</h5> 
<ul><li> <p>浮点权重不一定需要量化为 1 位或 2 位。低阶量化操作通常还可以为网络带来良好的性能，而不会造成较大的精度损失。 2016 年，林等人提出了一种用于深度卷积网络（DCN）定点量化器的位宽分配算法。该方法使用信号量化噪声比（SQNR）作为性能分类的指标，并从最优量化器设计理论推导出量化器步长。 Zhou等人开发了DoReFa-Net，用于训练具有低位宽权重的CNN，并实现了低位宽参数梯度的激活。特别是，在向后传递中，参数梯度也将在传播到卷积层之前通过随机量化减少到低位宽数。</p> </li><li> <p>为了解决二值网络带来的精度损失问题，Lin等人在2017年采用了多个二值权重基的线性组合来逼近全精度权重，并利用多个二值激活来减少信息损失。 2018年，Leng等人采用交替方向乘子法（ADMM）的思想将网络的离散约束与连续参数解耦，从而将原始问题转化为多个子问题。 2020年，Wu等人研究了人脸识别（FR）中的低比特量化问题，并提出了高效低比特FR量化所需的新的旋转一致边缘（RCM）损失函数。压缩到3位和4位后的结果揭示了该方法的优越性。 Yang等人认为传统的网络量化方法给网络学习低阶权重增加了困难。因此，在神经网络中采用微分法来搜索离散权值，以避免量化函数的不可微问题。</p> </li><li> <p>2021 年，Yamamoto 等人提出了一种可学习的压扩量化（LCQ），其中网络将灵活且非均匀地控制权重和激活量化为 2、3 和 4 位。此外，他们还提出了一种称为有限权重归一化（LWN）的权重归一化技术，用于提高量化训练的稳定性。 Wang等人认为，<strong>传统的量化方法需要确保数据集的一致性才能执行按位搜索，这使得在实际应用中大规模数据集的搜索成本高昂</strong>。考虑到这一点，<strong>他们提出了一种通过容量感知归因模拟的通用混合精度量化（GMPQ）方法，以保持量化模型和全精度模型之间的归因等级一致性，从而使模型能够推广到大规模数据集只有少量数据</strong>。</p> </li></ul> 
<h5><a id="Hashing_quantization_475"></a>Hashing quantization</h5> 
<ul><li> <p>2015 年，陈等人。提出了一种称为 HashNet 的新颖网络架构。该网络采用随机权重共享策略来减少内存使用，并通过减少固有的网络冗余来实现模型大小的大幅减小。下图 展示了压缩因子为 1/4 时具有随机权重共享的 Hashnet。该网络包括一个隐藏层、四个输入单元和两个输出单元，网络中的连接被随机分为三组，其中V1和V1代表两个虚拟权重矩阵。如下图所示，<strong>相同的权重值由相同的颜色表示</strong>。 Chen等人用哈希码对权重进行编码，并应用低成本哈希函数将连接权重随机分组到哈希桶中。同一哈希桶中的所有连接共享一个参数值。实验结果表明，<strong>HashNet极大地降低了神经网络的存储需求，同时从根本上保持了泛化性能</strong>。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/27/3f/eEo4xbSH_o.png" alt="在这里插入图片描述"></p> </li><li> <p>压缩因子为 1/4 且随机权重共享的哈希网图示</p> </li></ul> </li><li> <p>Hu等人在2018年指出，Chen等人的方法优化后的权重仍然是浮点数。为了解决现有问题，他们提出了一种称为 BWNH 的方法，通过哈希来训练二进制权重网络。根据他们的观点，训练二值权重网络本质上可以被视为哈希问题。他们提出了一种替代的优化方法来学习哈希码。在CIFAR10、CIFAR100和ImageNet上，BWNH的性能远远优于当前的技术水平。 2020年，Yuan等人提出了一种新颖的中心相似度度量，即中心相似度量化（CSQ）。 CSQ 可以模拟相似对和不相似对的关系，以提高生成的哈希码的可区分性。</p> </li></ul> 
<h4><a id="Knowledge_transfer_486"></a>Knowledge transfer</h4> 
<ul><li> <p>知识转移的概念可以描述为利用从大型、复杂、集成的神经网络中获取的信息来形成紧凑的神经网络。下图描述了知识转移的方法，其中信息流从复杂的教师网络转移到更简单的学生网络。也就是说，前一个网络是通过训练后一个网络的数据来标记的。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/78/6f/fxtbIGai_o.png" alt="在这里插入图片描述"></p> </li><li> <p>Illustration of knowledge transfer</p> </li></ul> </li><li> <p>利用复杂网络生成的合成数据训练紧凑模型可以很好地逼近函数并降低过拟合的可能性。更重要的是，它产生了比原始模型更精简的网络，从而为模型压缩和复杂网络加速提供了新的视角。 Bucilu等人于2006年<strong>首次将二次学习的思想应用于深度网络，提出了基于知识转移的模型压缩技术</strong>。该方法通过使学生模型的标签尽可能接近教师模型的标签来拟合教师模型的功能映射。使用三种实验方法生成伪数据，即随机、朴素贝叶斯估计和MUNGE。实验结果表明，学生网络的规模缩小了1000倍，而运行速度提高了1000倍。</p> </li><li> <p>与Bucilu等人的工作不同，Ba等人提出使用Softmax层的Logit输入作为监督信息而不是标签。他们的模型允许学生模型输出的 Logits 适合教师模型的 Logit 值。此外，他们认为不需要更深的网络架构，因此设计了一个比教师模型更浅的学生模型。学生模型的每一层都比教师模型更宽，目的是保证两个模型的网络参数相同。 Ba和Caruana利用从教师网络获得的数据集的logit标签作为知识来指导学生网络的训练，在TIMIT和CIFAR-10数据库上都可以达到与深度网络相当的识别精度。<strong><u>实验结果表明可以训练 shallower but wider 的学生网络来模仿教师网络，其效果几乎与教师网络一样好</u></strong>。</p> </li><li> <p>2014年，Hinton等人对上述工作做了进一步的改进。他们提出的知识蒸馏（KD）使用适当的T值来生成软概率标签，揭示数据结构之间的相似性。通过这种方式，学生网络可以用更少的推理时间在 MNIST 数据集上实现超高精度。该框架可以概括如下：假设T是一个教师网络，输出softmax PT = softmax(aT)，其中aT表示教师预softmax激活的向量。 1）如果教师模型是单网络，aT表示输出层的加权和。 2）如果教师模型是综合结果，则PT和aT都是通过不同网络的输出平均值（分别是算术平均值和几何平均值）获得的。假设 S 是学生网络，参数为 WS ，输出概率为 PS = softmax(aS ) ，其中 aS 表示学生的 pre-softmax 输出。学生网络经过训练，使其输出 PS 与教师输出 PT 以及真实标签 ytrue 相似。由于 PT 可能相当接近样本真实标签的热代码表示，因此引入松弛 t &gt; 1 来软化教师网络输出生成的信号，从而在训练过程中提供更多信息。学生网络的输出（Pt S ）与教师的软化输出（Pt T ）具有相同的松弛效果。它们各自的数学公式为：</p> 
  <ul><li><img src="https://images2.imgbox.com/21/cc/fKq9cv8q_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>然后优化器根据以下损失函数训练学生网络：</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/79/5c/gthjKbI8_o.png" alt="在这里插入图片描述"></p> </li><li> <p>其中H指交叉熵， <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             λ 
            
           
          
            \lambda 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span></span> 表示平衡两个交叉熵的可调参数。实验证明，以这种方式训练的学生比直接使用训练数据训练的学生表现更好。</p> </li></ul> </li><li> <p>Romero 等人表示，即使学生网络的架构稍深，KD 框架也能取得令人鼓舞的结果。然而，随着学生网络深度的增加，KD训练仍然面临着优化深度网络的困难。在现有问题中，Romero 等人。提出了一种名为 FitNet 的网络架构，它使用 Hints 来训练网络的前半部分，然后应用 KD 来完成网络训练。基于Hints的学生模型训练过程可以描述如下：如下图a所示，网络训练从经过训练的教师网络以及随机初始化的FitNet开始。如图b所示，<strong>通过采用Hints将Wr参数化的回归器添加到FitNet引导层的顶部</strong>。同时，FitNet参数W被引入引导层以最小化WGuided值。如图 c 所示，KD 框架用于训练整个 FitNet 的 WS，以最小化 W*S 值。与 Ba 等人的结论不同，Romero 等人。认为使用更精细、更深的网络（即学生网络）来模拟更宽、更浅的教师网络可以带来更高的分类精度。学生网络的深度保证了其性能，而其稀疏性则降低了计算复杂度。为了解决学生和教师模型中间层输出之间的维度不一致问题，FitNet 中添加了回归器。最初，FitNet 的前半部分是使用 Hints 进行训练的。然后，通过传统的网络蒸馏来训练整个FitNet。实验结果表明，FitNet 增加了网络深度并减少了网络参数，同时相对于教师模型提高了准确性。</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/8e/66/I0iKb6LH_o.png" alt="在这里插入图片描述"></p> </li><li> <p>基于提示的学生模型训练：a 师生网络，b 基于提示的训练，c KD 框架</p> </li></ul> </li><li> <p>2015年，Chen等人通过提出一种基于功能保留变换的网络增长方法获得了学生模型的网络架构，并将其命名为Net2Net。下图将 Net2Net 工作流程与传统方法进行了比较。它由 Net2WiderNet 和 Net2DeeperNet 组成，分别是网络宽度和深度增长的两种策略。然后，<strong>它使用蒸馏来训练学生模型，从而可以将有用信息从教师网络快速传输到更深（或更广泛）的学生网络。显然，Net2Net的核心思想是通过复制的方式复用训练好的网络参数，然后在此基础上生成网络</strong>。</p> </li><li> <p>与之前用软标签概率表示知识的做法不同，Luo 等人。使用教师网络的高级神经元的输出来表示2016年需要迁移的领域知识。他们根据学习到的人脸表征的基本特征，选择了与人脸识别最相关的神经元。所提出的方法不会导致任何信息丢失。经过训练的学生网络在 LFW 上获得比教师网络更高的压缩率和更高的准确率。 2017 年，Zagoruyko 等人。利用教师网络中能够提供视觉相关位置信息的注意力特征图来监督学生网络的学习，并进行低、中、高三个层次的注意力转移，大大提高了残差网络等深度CNN的性能。 2018年，Lucas等人开发了一种结合Fisher剪枝和知识转移的优化方法。最初，使用预训练的高性能网络来生成大量显着图作为领域知识。随后，使用显着性图对网络进行训练，并通过Fisher剪枝去除冗余特征图，从而在图像显着性预测过程中将网络运行速度提高10倍。</p> </li><li> <p>2019年，Wang等人开发了在线集成蒸馏（OED）方法，该方法支持通过按照端到端模式从教师网络传输知识来自动修剪目标网络上的块/层。OED方法可以采用快速迭代收缩阈值算法来快速、严格地去除多余块，并且相应的软掩模等于0。实验表明，OED 方法可以压缩和加速多个 CNN 架构，同时增强剪枝网络的鲁棒性。同年，丁等人将师生学习与 Tucker 分解相结合，在光学字符识别 (OCR) 任务中压缩和加速基于 CNN-DBLSTM（双向长短期记忆）的卷积层，这大大降低了占用空间和计算成本，而没有或略有下降识别准确度。 2020 年，Touvron 等人引入了一种专门针对基于蒸馏的 Transformer 的师生策略，其动机是在 Transformer 中引入卷积偏差。通过应用数据增强、不同的优化器和随机深度，参考视觉 Transformer 在 ImageNet 上无需外部数据即可实现 83.1% 的 top-1 准确率。 2021年，Aghli等人认为剪枝方法在VGG或AlexNet等简单网络上表现出优异的性能，但无法应用于ResNets等复杂网络结构，因为剪枝方法可能会导致网络结构被破坏 。他们将剪枝和蒸馏方法结合起来，基于仅针对ResNet架构内特定层数的值剪枝方法，旨在防止对网络结构的破坏。其次，引入知识蒸馏结构和损失函数来压缩未修剪层。这种压缩方法极大地减小了模型的大小，同时保持非常接近基线模型的精度。</p> </li><li> <p>2021 年，姚等人提出了一种针对同质和异质师生对的 KD 策略，该策略利用检测 KD 管道来提取同质和异质检测器对。除此之外，他们认为传统的特征模仿范式通过模仿掩模关注信息丰富的前景区域，从而在 FPN 中丢失了语义信息。因此，<strong>引入对比蒸馏的目的是捕获编码关联信息之间的不同特征区域，并自动在FPN中的特征对之间进行软匹配，从而为学生网络提供有用的信息</strong>。 Zhou等人认为，现有的KD方法忽视了个体知识与关系知识之间的内在相关性。因此，他们决定通过在实例之间构建的归因图来提炼整体知识。整体知识被表示为通过聚合相关邻域样本的个体知识来学习的统一的基于图的嵌入，而学生网络是通过以对比方式细化整体知识来学习的。</p> </li><li> <p>Zhu等人提出了互补关系对比蒸馏（CRCD）方法来提取样本之间的信息。该方法以基于锚的方式估计由两个互补元素建模的相互关系，并且在其相应的锚-教师关系的监督下提取锚-学生关系。郭等人认为，<strong>在学生网络的目标检测任务中，在不包括对象的区域中获得的特征信息通常被忽略。此外，他们认为应该重视特征区域的信息，并提出了包含颈部解耦特征和解耦特征（DeFeat）建议的分类头解耦建议的算法来细化网络信息。为了降低训练大型教师模型所需的高计算成本，Ji 等人提出通过自知识蒸馏（FRSKD）进行特征精炼（FRSKD）来训练学生网络来精炼知识，而无需预先训练教师网络（FRSKD），该方法利用辅助自教师网络为分类器网络传输精炼知识，并使用软标签和特征图蒸馏进行自知识蒸馏</strong>。</p> </li></ul> 
<h3><a id="Neural_architecture_search_528"></a>Neural architecture search</h3> 
<ul><li> <p>CNN 在目标任务中的性能由架构决定。其中，网络架构越好，效率和性能就越好。 CNN架构的设计通常需要专门的知识，这严重阻碍了深度学习的发展和应用。神经架构搜索（NAS）旨在通过寻找最佳网络结构来减少对设计人员经验的需求。2016年，Zoph等人提出了一种基于强化学习的NAS算法，并取得了超越人工网络架构的性能。</p> </li><li> <p>现有的NAS算法主要包括搜索空间、搜索策略和性能评估策略。其中，搜索空间常见的形式有整体形式、模块化形式和层次形式三种。更详细地说，整体形式包括直接连接和多分支。对于搜索空间，整体形式可以获得更适合相应任务的网络架构，但需要更多的计算成本。多个分支具有更复杂的网络架构和更强的网络表达能力。相比之下，模块化形式的一般范围和单元结构更小，从而提高了神经网络结构的搜索效率和可转移性。在层次形式中，允许搜索网络整体的连接以及连接层内的操作方式，这可以显着减少人为干预。此外，高级搜索策略将在很大程度上决定搜索到的 CNN 架构的性能。<strong>主流算法中，常用的搜索策略主要可分为进化算法、强化学习、基于梯度下降的方法和基于顺序模型的优化算法</strong>。</p> </li><li> <p>获得成功的 NAS 方法通常意味着训练和评估数千个模型，这不可避免地需要长达数千个 GPU 天。巨大的搜索预算使得NAS的广泛应用变得困难。 Guo 等人采用了<strong>基于权重共享技术的一次性方法</strong>来降低计算成本。<strong>通过超网训练、子网搜索和子网再训练三个阶段，搜索成本从数千GPU天降低到数十GPU天</strong>。 Chen 等人提出的 NAS with Batch Normalization (BN-NAS) ，加速了评估和训练过程。在训练的初始阶段，预测子网的性能。在超网训练中，仅训练BN参数，进一步提高了训练效率。</p> </li><li> <p>Li等人提出的一种名为动态可瘦网络（DS-Net）的架构可以针对不同的输入动态调整网络的滤波器数量。 DS-Net 包含受 NAS 启发的分叉两阶段训练方案。通过In-place Ensemble Bootstrapping和Sandwich Gate Sparsification，分别提高了超网训练效率和门辅助训练。 Yang等人提出的沙漏启发方法（HourNAS）可以实现高速NAS算法。在他们看来，CNN 架构中保证路径中类似于沙漏颈部的重要块限制了信息流，而其他类似于沙漏球体的块则决定了整个网络的复杂性。由于HourNAS优先搜索更重要的块，因此可以在0.1 GPU天内获得77.0%的具有Top-1精度的架构。 Xu 等人提出的相对论架构性能预测器可用于对不同架构进行排名。更详细地说，<strong>基于单元的搜索空间为所有架构提供了统一的超网，并将它们编码为张量。通过对损失函数进行成对排序，可以获得更好的架构</strong>。</p> </li><li> <p>此外，带有 Transformer 的 CNN 的架构设计也值得考虑。对于添加 ViT 模块的 CNN 架构，通常需要考虑 ViT 嵌入深度、嵌入维度和头数。现有的具有 Transformer 架构的 CNN 通常基于人性化设计，这高度依赖于设计者在应用注意力机制方面的工程经验。陈等人。首先提出了一种新颖的 ViT 模型架构搜索算法，名为 AutoFormer可用于Transformer 超网的高效训练。经过训练的超级网络能够通过直接继承权重来生成更高质量的 Transformer，而无需额外的微调或重新训练。 Wang 等人提出的 AttentiveNAS 策略改进了现有的两阶段 NAS 。除了BestUp和WorstUp等采样策略的比较之外，在训练过程中有效地将采样引导到最好或最差的Pareto前沿。</p> </li></ul> 
<h3><a id="CNNs_applications_540"></a>CNNs applications</h3> 
<ul><li>CNN 能力强大，应用领域广泛，在各种任务中都有良好的表现。在视频对象分割、医学成像、人脸识别等领域，基于卷积的衍生网络架构已经达到了接近甚至超越人类的精度和效率。本节将简要探讨 CNN 在三个领域的应用。</li></ul> 
<h4><a id="Video_object_segmentation_544"></a>Video object segmentation</h4> 
<ul><li> <p>随着短视频平台的大规模发展，视频对象分割的任务变得越来越重要。如今，对这些视频进行智能分析已成为一项极具挑战性的任务。作为解决此类问题的基本技术，视频对象分割算法提供了良好的性能。 Ji等人提出的全双工策略网络（FSNet）。提供强大的视频对象分割 。关系交叉注意模块（RCAM）是 FSNet 中包含的双向交互模块，其功能是提取外观和运动分支的判别特征并确保相互约束。此外，还引入了双向净化模块（BPM）来更新不一致的特征。</p> </li><li> <p>在视频对象分割任务中，由于快速移动，特定信息可能会急剧失真，这增加了挑战。现有的工作主要集中在如何充分利用有限的信息进行精确分割。通过新颖的双分支架构，Mao 等人在归纳推理中融合了离线学习和在线学习的优势。此外，半监督视频对象分割（VOS）任务首次结合了 Transformer 架构。</p> </li></ul> 
<h4><a id="Medical_imaging_550"></a>Medical imaging</h4> 
<ul><li> <p>CNN在医学图像分析中的应用取得了巨大成功。 CNN 常用于疾病诊断、疾病定位、治疗计划和治疗实施等临床应用。随着CNN网络的发展，基于计算机程序的医学图像分析设备在许多任务中已经达到了接近甚至超过人类的准确性。</p> </li><li> <p>医学图像分析的良好性能建立在大型人工注释训练集的基础上，这需要专业知识和临床经验。 Tang等人提出的上下文关系编码器（CRE）通过前景和背景之间的相关性来增强对象边界周围的特征关系，在少量医学图像数据集上取得了良好的效果。基于生成对抗方法，Dey等人构建了可变形模板，其中生成的模板对于年龄和疾病等属性的特异性显着提高。 Ye 等人提出了一种无监督 CNN 框架，用于心脏标记磁共振成像 (t-MRI) 图像中的运动跟踪。运动场的估计是通过双向生成微分同胚配准神经网络和可微成分层来执行的。赵等人提出了一种分割网格分类网络（SMCN），它结合了几何和位置信息进行信息诊断。此外，SMCN通过完成胰腺和肿块分割的学习任务，构建了权威的解剖对应感知器官网格模型。</p> </li></ul> 
<h4><a id="Face_recognition_556"></a>Face recognition</h4> 
<ul><li> <p>人脸识别是一种基于人脸特征信息进行身份识别的生物识别技术，现已成为普遍存在的生物识别认证方式。尽管经过30多年的研发，传统人脸识别技术仍然存在一些难以克服的问题。例如，人脸识别模型在某些安全保护任务中容易受到欺骗攻击。此外，大多数防御算法对于无法预防的攻击无效。 George 等人提出了一种帧级 RGB-D 人脸呈现攻击检测（PAD）方法。其中，称为跨模态焦点损失（CMFL）的损失函数可用于监督多流结构中的单个通道。赵等人提出了一种结合注意力机制的伪造检测网络，利用注意力机来关注网络中不同的局部信息。此外，低级纹理特征和高级语义特征在注意力图的指导下聚合。</p> </li><li> <p>由于人脸特征随着年龄的变化而变化，大多数算法必须采用减少特征相关性或多年龄特征融合的方法来保证网络识别的准确性。在这方面，Huang 等人提出了一个名为 MTLFace 的框架，用于学习年龄不变的身份相关表示。基于注意力机制，面部特征分为年龄相关特征和身份相关特征。为了提高人脸识别性能，建立了一个带有年龄和性别注释的跨年龄人脸的大规模公共数据集。</p> </li></ul> 
<h3><a id="Summarizations_and_prospects_562"></a>Summarizations and prospects</h3> 
<ul><li> <p>鉴于硬件性能的快速发展，深度 CNN 将成为计算机视觉相关任务的主流算法。<strong>更强的计算能力将支持更深网络的计算和更多样本数据的处理，从而增强模型的非线性拟合和泛化能力</strong>。毫无疑问，CNN的架构设计是一个很有前景的研究领域，可能成为未来应用最广泛的人工智能技术之一。对于CNN在移动平台上的迁移问题，追求更轻的网络架构是一个主要的发展方向。网络架构设计、剪枝、稀疏化、张量分解等策略都可以在一定程度上实现网络压缩。本文对近年来的研究成果进行了总结。 CNN发展面临的挑战和未来前景如下：</p> 
  <ul><li> <p>许多神经网络架构（包括 CNN）<strong>缺乏可解释性</strong>。 Zeiler等人于2013年提出的DeconvNet取代了卷积层和池化层来监控模型训练期间的学习方案，并已在AlexNet上得到验证。根据实验结果，AlexNet中的大部分神经元都处于非活动状态，这种现象可以通过选择较小的滤波器和卷积步长来优化。</p> </li><li> <p>超参数的选择仍然依赖于人工比较和经验，尽管超参数值的细微变化都会对网络性能产生巨大影响。超参数选择策略需要标准化的设计理念，以及调整超参数值的合理优化方法。<strong>神经架构搜索 (NAS) 算法对于设计自动搜索正确网络架构的网络也是必要的</strong>。</p> </li><li> <p>CNN 的有效训练需要强大的硬件资源，例如 GPU。然而，<strong>仍有必要探索如何在嵌入式和移动设备中有效利用 CNN</strong>。设计硬件友好的深度模型有利于深度学习的工程实现，也是网络架构优化的重点研究方向。</p> </li><li> <p>金字塔架构中自下而上和自上而下的特征图拼接为目标检测任务中的多尺寸特征提取提供了更丰富的语义信息。然而，快捷连接缺乏更多的理论依据。 MHSA思想的引入可以为CNN提供更多的全局信息，但是MHSA模块中大量的FC结构大大增加了网络的计算量。<strong>需要更先进的注意力提取算法</strong>。</p> </li><li> <p>关于网络剪枝算法，现有方法大多数删除网络中的冗余连接或神经元。这种低水平的修剪具有非结构性风险。在计算机运行过程中，不规则的内存访问方式反而阻碍了网络的进一步加速。此外，卷积核的评估系统及其权重重要性仍然相当简单。因此，<strong>提出一种更有效的方法来衡量剪枝对象对模型的影响是至关重要的</strong>。</p> </li><li> <p><strong>张量分解可以极大地加速模型运算过程，分解过程中应用的数学原理更有利于直观地解释网络架构的优化机制</strong>。但张量分解对于卷积核较小的网络模型加速效果较差，一般无法压缩网络模型的尺寸。</p> </li><li> <p>网络量化可以显着减小模型大小。然而，它增加了操作的复杂性。在量化过程中，需要进行一些特殊的处理。否则精度损失会更严重。此外，量化本身通常会损失一些精度。适当的量化策略将能够降低模型的复杂性，同时最大限度地减少准确性的损失。此外，<strong>可以使用混合精度量化策略，根据贡献将参数的大小降低到合理的程度</strong>。</p> </li><li> <p><strong>知识迁移可以通过教师网络指导学生网络的训练，在小样本环境下具有很强的应用价值</strong>。然而，不同的学生网络架构的训练难度有所不同。此外，最终的效果也各不相同。因此，要在教师网络架构的基础上构建学生网络架构，需要设计者具有更丰富的理论基础和工程经验。而且，知识转移的调试周期比其他方法更长。</p> </li><li> <p>大多数模型加速方法实现了图像识别任务的优化，而很少有致力于加速计算机视觉其他领域的任务，例如目标检测。另外，网络压缩算法的评价体系比较薄弱，一般侧重于网络参数和运行时间的比较。作为未来的研究方向，<strong>可以平衡网络的规模和速度，并提供多场景下的网络性能评估体系</strong>。</p> </li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6a9076dd621d20f9ce52936c6e77a39e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 将模糊图像清晰化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de6cd2258861400d16e2da9d80d7f51a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">YOLOv6 学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>