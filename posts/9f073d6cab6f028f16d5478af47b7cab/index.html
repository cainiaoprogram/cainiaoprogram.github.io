<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>dynamic_cast使用以及原理探究 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="dynamic_cast使用以及原理探究" />
<meta property="og:description" content="dynamic_cast与原理 dynamic_cast运算符能够将基类的指针或引用安全的转换为派生类的指针或者引用。转换失败，返回空地址。
RTTI是运行阶段类型识别（Runtime Type Identification）的简称。是指程序在运行阶段确定对象的类型。
C&#43;&#43;中可以进行运行时识别出变量等类型信息的还有typeid。
编译环境 Visual Studio 2022 / v143 / C&#43;&#43;20
dynamic_cast用法 转换成功 如下B继承自A
struct A { virtual ~A(){} }; struct B: A{}; A* a = new B; // 将指向子类的指针，转换为子类指针。 if (b = dynamic_cast&lt;B*&gt;(a)) { // do something... } 转换失败 A* a = new A; // 转换失败，b为空指针。 if (b = dynamic_cast&lt;B*&gt;(a)) { // do something... } ‍‍‍``` 原理探究 使用dynamic_cast转换的前提是A必须有虚函数，即虚函数表。dynamic_cast的关键就是虚函数表，因为B类有自己的虚函数表，A类也有自己的虚函数表，根据虚函数表的不同可以判断到底是属于哪个类。我们简单仿写一下。当然，我们只是尝试一下，不能用于实际，毕竟开销大且有局限性。
template&lt;class T&gt; int64_t* get_vptr_64(T* t) { int64_t* pvptr = reinterpret_cast&lt;int64_t*&gt;(t); // 对象的首地址，即虚函数表指针。 return reinterpret_cast&lt;int64_t*&gt;(*pvptr); // 对象的首地址存的内容就是虚表地址 } // 不支持 子类转父类 template&lt;class T, class U&gt; T* my_cast(U u) { // 如何不实例化对象的情况下获取类的虚函数表 ？ T* t = new T(); if (get_vptr_64(u) == get_vptr_64(t)) { return reinterpret_cast&lt;T*&gt;(u); } return nullptr; } int main() { // 创建一个多态指针 A* b1 = new B; // 转换 // B* b2 = dynamic_cast&lt;B*&gt;(b1); if(B* b = my_cast&lt;B&gt;(b1)) { std::cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9f073d6cab6f028f16d5478af47b7cab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-27T09:06:48+08:00" />
<meta property="article:modified_time" content="2022-09-27T09:06:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">dynamic_cast使用以及原理探究</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="dynamic_cast_1"></a>dynamic_cast与原理</h2> 
<p><code>dynamic_cast</code>运算符能够将基类的指针或引用安全的转换为派生类的指针或者引用。转换失败，返回空地址。</p> 
<p>RTTI是运行阶段类型识别（Runtime Type Identification）的简称。是指<strong>程序在运行阶段确定对象的类型。</strong></p> 
<p>C++中可以进行运行时识别出变量等类型信息的还有<code>typeid</code>。</p> 
<h3><a id="_9"></a>编译环境</h3> 
<p>Visual Studio 2022 / v143 / C++20</p> 
<h3><a id="dynamic_cast_13"></a>dynamic_cast用法</h3> 
<h4><a id="_15"></a>转换成功</h4> 
<p>如下B继承自A</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

A<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>
<span class="token comment">// 将指向子类的指针，转换为子类指针。</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 <span class="token comment">// do something...</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_33"></a>转换失败</h4> 
<pre><code class="prism language-cpp">A<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span>
<span class="token comment">// 转换失败，b为空指针。</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 <span class="token comment">// do something...</span>
<span class="token punctuation">}</span>
‍‍‍```
</code></pre> 
<h4><a id="_44"></a>原理探究</h4> 
<p>使用dynamic_cast转换的前提是A必须有虚函数，即虚函数表。<code>dynamic_cast</code>的关键就是虚函数表，因为B类有自己的虚函数表，A类也有自己的虚函数表，根据虚函数表的不同可以判断到底是属于哪个类。我们简单仿写一下。当然，我们只是尝试一下，不能用于实际，毕竟开销大且有局限性。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">int64_t</span><span class="token operator">*</span> <span class="token function">get_vptr_64</span><span class="token punctuation">(</span>T<span class="token operator">*</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int64_t</span><span class="token operator">*</span> pvptr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int64_t</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对象的首地址，即虚函数表指针。</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int64_t</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">*</span>pvptr<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 对象的首地址存的内容就是虚表地址</span>
<span class="token punctuation">}</span>
<span class="token comment">// 不支持 子类转父类</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
T<span class="token operator">*</span> <span class="token function">my_cast</span><span class="token punctuation">(</span>U u<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 如何不实例化对象的情况下获取类的虚函数表 ？</span>
    T<span class="token operator">*</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_vptr_64</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">get_vptr_64</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 创建一个多态指针</span>
    A<span class="token operator">*</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>
  
    <span class="token comment">// 转换</span>
    <span class="token comment">// B* b2 = dynamic_cast&lt;B*&gt;(b1);</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>B<span class="token operator">*</span> b <span class="token operator">=</span> <span class="token generic-function"><span class="token function">my_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cast success!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cast failed!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>输出</strong></p> 
<pre><code class="prism language-cpp">cast success<span class="token operator">!</span>
</code></pre> 
<h3><a id="_87"></a>虚函数</h3> 
<p>每个子类对象都会有构造一个父类的区域，这个区域在子类自身成员的前面，于是用父类指针去指向子类对象时，会从子类对象的起始地址也就是父类区域索引。<br> <strong>虚函数</strong></p> 
<ol><li>如果A中存在虚函数，则A中存在虚函数表，每一个A的实例a都各自存在一个虚函数表指针指向同一个A的虚函数表</li><li>如果B继承A，则B中会复制一份A的虚函数表，但是和A不是同一个，虚函数表跟类相关，每个类只有一份。</li><li>所以如果A类型的指针b指向B类型的实例实际上，b的内存空间中的虚函数表指针指向的是B的虚函数表。所以当我们访问虚函数的时候就会从B的虚函数表索引，就会访问到B的虚函数，进而实现了多态。</li></ol> 
<p><strong>非虚函数</strong></p> 
<ol><li>B继承A，如果存在(A* a = new B), 对于非虚函数，那么就是直接访问b空间中的A区的函数也就是父类的函数。实际上如果不发生重写，非虚函数A、B的是共享的。重写了的话就不共享A的了。可以调试看一下。</li><li>如果像访问B自己的内存，需要转化a为B*类型。</li></ol> 
<h3><a id="_101"></a>和强转的安全性对比</h3> 
<p>可以更安全的进行转换如下面例子</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> _v<span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_v</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> _v <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">noneVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">using</span> A<span class="token double-colon punctuation">::</span>A<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span>
    <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> _v <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">C</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    B <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>B <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    a<span class="token operator">-&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这里如果是强转则会出现不正常的结果。</span>
    C <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token punctuation">(</span>C <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token operator">-&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="static_cast_145"></a>和static_cast的区别</h3> 
<p><code>static_cast</code>也是一个c++运算符，功能是把一个表达式转换为某种类型，但没有运行时类型检查来保证转换的安全性。例如上面的强制转换替换为<em>static_cast</em>也能编译通过，但是不安全。</p> 
<pre><code class="prism language-cpp">    C <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>C<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token operator">-&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_154"></a>补充</h3> 
<p>虚函数表指针。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 调用的A的</span>
    a<span class="token operator">-&gt;</span><span class="token function">noneVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 调用B的</span>
    a<span class="token operator">-&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当父类指针<code>A* a = new B</code>指向子类实例时，这时候a指向的内存是继承自A的，所以调用非虚函数<code>noneVirtual</code>调用的是父类的，调用虚函数<code>print</code>的时候，虚函数表指针指向子类的虚函数表，但是此时子类的虚表中已将父类的虚函数覆盖了，所以调用的是子类的虚函数。这就实现了 父类指针指向子类对象仍旧可以调用子类虚函数。</p> 
<h4><a id="dynamic_casthttpswwwbilibilicomvideoBV1L8411472U_175"></a><a href="https://www.bilibili.com/video/BV1L8411472U" rel="nofollow">dynamic_cast使用以及原理探究</a></h4> 
<p>视频讲解：<a href="https://www.bilibili.com/video/BV1L8411472U" rel="nofollow">https://www.bilibili.com/video/BV1L8411472U</a></p> 
<p>笔记：https://mp.weixin.qq.com/s/z48TVU6dADqr6eOWSqOPbQ</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2238ab3ea6a38306996f0ae02e1abcc3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux 下使用 C&#43;&#43; 实现的 Web 文件服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/629cb339f5efab44724675a08da8d618/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">异常的几种处理方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>