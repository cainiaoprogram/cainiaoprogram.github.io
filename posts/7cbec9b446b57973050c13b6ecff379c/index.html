<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>power mock 入门介绍及使用示例 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="power mock 入门介绍及使用示例" />
<meta property="og:description" content="相关框架
JUnit4、Mockit、PowerMock
相关maven依赖
&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt; &lt;version&gt;1.6.5&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-api-mockito&lt;/artifactId&gt; &lt;version&gt;1.6.5&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 代码base 后面的测试代码均是针对下面class的
import org.springframework.beans.factory.annotation.Autowired; public class UserController { @Autowired private UserService userService; public boolean addUser(UserDto userDto) { int added = userService.addUser(userDto); if (added &lt;= 0) { return false; } else { return true; } } public boolean delUser(int id) { try { userService.delUser(id); return true; } catch (Exception e) { return false; } } public void saveUser(UserDto userDto) { userService." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7cbec9b446b57973050c13b6ecff379c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-06-29T15:20:51+08:00" />
<meta property="article:modified_time" content="2016-06-29T15:20:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">power mock 入门介绍及使用示例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>相关框架</p> 
</blockquote> 
<p>JUnit4、Mockit、PowerMock</p> 
<blockquote> 
 <p>相关maven依赖</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-title">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>powermock-module-junit4<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>1.6.5<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-title">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>powermock-api-mockito<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>1.6.5<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-title">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span></code></pre> 
<blockquote> 
 <p>代码base <br> 后面的测试代码均是针对下面class的</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> {<!-- --></span>
    <span class="hljs-annotation">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addUser</span>(UserDto userDto) {
        <span class="hljs-keyword">int</span> added = userService.addUser(userDto);
        <span class="hljs-keyword">if</span> (added &lt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">delUser</span>(<span class="hljs-keyword">int</span> id) {
        <span class="hljs-keyword">try</span> {
            userService.delUser(id);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span>(UserDto userDto) {
        userService.saveUser(userDto);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countUser</span>() {
        UserDto ud = <span class="hljs-keyword">new</span> UserDto();

        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (ud.getId() &gt; <span class="hljs-number">0</span>) {
            count += <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> count;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">modUser</span>(UserDto userDto) {
        <span class="hljs-keyword">int</span> moded = userService.modUser(userDto);
        <span class="hljs-keyword">return</span> verifyMod(moded);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyMod</span>(<span class="hljs-keyword">int</span> moded) {
        <span class="hljs-keyword">if</span> (moded &lt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
    }
}</code></pre> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> {<!-- --></span>
    <span class="hljs-keyword">int</span> addUser(UserDto userDto);

    <span class="hljs-keyword">int</span> delUser(<span class="hljs-keyword">int</span> id) <span class="hljs-keyword">throws</span> Exception;

    <span class="hljs-keyword">int</span> modUser(UserDto userDto);

    <span class="hljs-keyword">void</span> saveUser(UserDto userDto);
}</code></pre> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDto</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span>() {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span>(<span class="hljs-keyword">int</span> id) {
        <span class="hljs-keyword">this</span>.id = id;
    }
}</code></pre> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileHelper</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getName</span>(String name) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"A_"</span> + name;
    }
}
</code></pre> 
<blockquote> 
 <p>相关注解：所有测试类均须加上以下注解</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-annotation">@RunWith</span>(PowerMockRunner.class)
<span class="hljs-annotation">@PrepareForTest</span>({UserController.class, FileHelper.class})
<span class="hljs-annotation">@PowerMockIgnore</span>(<span class="hljs-string">"javax.management.*"</span>)</code></pre> 
<p>其中:</p> 
<ul><li><strong>@RunWith(PowerMockRunner.class)</strong> ：表明用 PowerMockerRunner来运行测试用例，否则无法使用PowerMock</li><li><strong>PrepareForTest({UserController.class})</strong>：所有需要测试的类，列在此处，以逗号分隔</li><li><strong>@PowerMockIgnore(“javax.management.*”)</strong>:为了解决使用powermock后，提示classloader错误</li></ul> 
<pre class="prettyprint"><code class="language-java hljs ">java.lang.NoClassDefFoundError: com.ibm.mq.jms.MQQueueConnectionFactory$$EnhancerByCGLIB$$<span class="hljs-number">7</span>cb492ab (initialization failure)
    at java.lang.J9VMInternals.initialize(J9VMInternals.java:<span class="hljs-number">140</span>)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="hljs-number">60</span>)
    ……</code></pre> 
<blockquote> 
 <p>@Autowired 属性的注入方式</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserControllerTest</span> {<!-- --></span>
    <span class="hljs-annotation">@Mock</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-annotation">@InjectMocks</span>
    <span class="hljs-keyword">private</span> UserController uc = <span class="hljs-keyword">new</span> UserController();
}</code></pre> 
<p>几点需要注意一下：</p> 
<ul><li>上面的方式，将会mock出来一个 user service对象，将将其注入到 UserController 的实例 <strong>uc</strong> 中去。</li><li><strong>uc</strong>后面的那个 <strong>new UserController()</strong> 也可以不需要的。</li></ul> 
<blockquote> 
 <p>mock普通方法</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAddUser</span>() <span class="hljs-keyword">throws</span> Exception {
        UserDto ud = <span class="hljs-keyword">new</span> UserDto();
        PowerMockito.when(userService.addUser(ud)).thenReturn(<span class="hljs-number">1</span>);
        <span class="hljs-comment">// can not stub like this</span>
        <span class="hljs-comment">// PowerMockito.doReturn(1).when(userService.addUser(ud));</span>
        <span class="hljs-keyword">boolean</span> result = uc.addUser(ud);
        Assert.assertEquals(result, <span class="hljs-keyword">true</span>);
    }</code></pre> 
<p>上面的代码中，有两点需要注意一下:</p> 
<ul><li>userService.addUser() 和 uc.addUser() 所使用的参数值须保持一致，这样才能让powermock在运行的时候进行参数匹配。(<strong>本篇最后会讲到，如何进行模糊匹配参数。</strong>)</li><li>thenReturn() 返回的值需要与 userService.addUser() 方法声明的返回值的类型保持一致，否则编译将会出错。</li><li>mock语句不能写成下面这样的：</li></ul> 
<pre class="prettyprint"><code class="language-java hljs ">PowerMockito.doReturn(<span class="hljs-number">1</span>).when(userService.addUser(ud));</code></pre> 
<p>否则将报异常：</p> 
<pre class="prettyprint"><code class="language-java hljs ">org.mockito.exceptions.misusing.UnfinishedStubbingException: 
Unfinished stubbing detected here:
……</code></pre> 
<blockquote> 
 <p>mock抛异常</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelUser</span>() <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">int</span> toDelete = <span class="hljs-number">1</span>;
        PowerMockito.when(userService.delUser(toDelete)).thenThrow(<span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"mock exception"</span>));
        <span class="hljs-keyword">boolean</span> result = uc.delUser(toDelete);
        Assert.assertEquals(result, <span class="hljs-keyword">false</span>);
    }</code></pre> 
<p>有几点需要注意一下：</p> 
<ul><li>如果 user service 中的 delUser() 方法抛出的是 checked exception，那么，thenThrow() 里需要抛出 <strong>new Exception()</strong>或者其子类</li><li>如果delUser() 方法抛出的是 unchecked exception，那么，thenThrow() 里需要抛出 <strong>new RuntimeException()</strong>或其子类</li></ul> 
<blockquote> 
 <p>mock静态方法</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mockFileHelper</span>() {
        PowerMockito.mockStatic(FileHelper.class);
        PowerMockito.when(FileHelper.getName(<span class="hljs-string">"lucy"</span>)).thenReturn(<span class="hljs-string">"lily"</span>);
        Assert.assertEquals(FileHelper.getName(<span class="hljs-string">"lucy"</span>), <span class="hljs-string">"lily"</span>);
    }</code></pre> 
<p>有几点需要注意一下：</p> 
<ul><li>需要在<strong>@PrepareForTest</strong>注解中加上 <strong>FileHelper.class</strong></li><li>调用 <strong>PowerMockito.mockStatic()</strong>，参数为 <strong>FileHelper.class</strong></li></ul> 
<blockquote> 
 <p>mock 返回值为 <strong>void</strong> 的方法</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSaveUser</span>() <span class="hljs-keyword">throws</span> Exception {
        UserDto userDto = <span class="hljs-keyword">new</span> UserDto();

        <span class="hljs-comment">// way one:</span>
        PowerMockito.doNothing().when(userService, <span class="hljs-string">"saveUser"</span>, userDto);

        <span class="hljs-comment">// way two:</span>
        PowerMockito.doNothing().when(userService).saveUser(userDto);

        uc.saveUser(userDto);
    }</code></pre> 
<blockquote> 
 <p>mock私有方法</p> 
</blockquote> 
<ul><li>方法一 <br> PS：该方法中，还介绍了 mock私有字段的值 的方法。</li></ul> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testModUser</span>() <span class="hljs-keyword">throws</span> Exception {
        UserDto ud = <span class="hljs-keyword">new</span> UserDto();
        <span class="hljs-keyword">int</span> moded = <span class="hljs-number">1</span>;

        PowerMockito.when(userService.modUser(ud)).thenReturn(moded);

        UserController uc2 = PowerMockito.mock(UserController.class);

        <span class="hljs-comment">// 给没有 setter 方法的 私有字段 赋值。</span>
        Whitebox.setInternalState(uc2, <span class="hljs-string">"userService"</span>, userService);

        <span class="hljs-comment">// 因为要测试的是 modUser() 方法，</span>
        <span class="hljs-comment">// 所以，当调用这个方法时，应该让它调用真实的方法，而非被mock掉的方法</span>
        PowerMockito.when(uc2.modUser(ud)).thenCallRealMethod();

        <span class="hljs-comment">// 在modUser()方法中会调用verifyMod()这个私有方法，所以，需要将mock掉</span>
        PowerMockito.when(uc2, <span class="hljs-string">"verifyMod"</span>, moded).thenReturn(<span class="hljs-keyword">true</span>);

        <span class="hljs-keyword">boolean</span> result = uc2.modUser(ud);

        Assert.assertEquals(result, <span class="hljs-keyword">true</span>);
    }</code></pre> 
<p>需要注意的是：此处的uc2是<strong>mock</strong>出来的，不是 <strong>UserControllerTest</strong> 类中的成员变量 <strong>uc</strong></p> 
<ul><li>方法二</li></ul> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testModUser2</span>() <span class="hljs-keyword">throws</span> Exception {
        UserDto ud = <span class="hljs-keyword">new</span> UserDto();
        <span class="hljs-keyword">int</span> moded = <span class="hljs-number">1</span>;

        PowerMockito.when(userService.modUser(ud)).thenReturn(moded);

        <span class="hljs-comment">// 对uc进行监视</span>
        uc = PowerMockito.spy(uc);
        <span class="hljs-comment">// 当uc的verifyMod被执行时，将被mock掉</span>
        PowerMockito.when(uc, <span class="hljs-string">"verifyMod"</span>, moded).thenReturn(<span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">boolean</span> result = uc.modUser(ud);

        Assert.assertEquals(result, <span class="hljs-keyword">true</span>);
    }</code></pre> 
<p>使用spy方法可以避免执行被测类中的成员函数，即mock掉不想被执行的私有方法。</p> 
<blockquote> 
 <p>测试私有方法(注意： <strong>是测试，不是mock</strong>)</p> 
</blockquote> 
<ul><li>方法一</li></ul> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testVerifyMod</span>() <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 获取Method对象，</span>
        Method method = PowerMockito.method(UserController.class, <span class="hljs-string">"verifyMod"</span>, <span class="hljs-keyword">int</span>.class);
        <span class="hljs-comment">// 调用Method的invoke方法来执行</span>
        <span class="hljs-keyword">boolean</span> result = (<span class="hljs-keyword">boolean</span>) method.invoke(uc, <span class="hljs-number">1</span>);
        Assert.assertEquals(result, <span class="hljs-keyword">true</span>);
    }</code></pre> 
<ul><li>方法二</li></ul> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testVerifyMod2</span>() <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 通过 Whitebox 来执行</span>
        <span class="hljs-keyword">boolean</span> result = Whitebox.invokeMethod(uc, <span class="hljs-string">"verifyMod"</span>, <span class="hljs-number">1</span>);
        Assert.assertEquals(result, <span class="hljs-keyword">true</span>);
    }</code></pre> 
<blockquote> 
 <p>mock新建对象</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCountUser</span>() <span class="hljs-keyword">throws</span> Exception {
        UserDto ud = <span class="hljs-keyword">new</span> UserDto();
        ud.setId(<span class="hljs-number">1</span>);

        PowerMockito.whenNew(UserDto.class).withNoArguments().thenReturn(ud);

        <span class="hljs-keyword">int</span> count = uc.countUser();

        Assert.assertEquals(count, <span class="hljs-number">1</span>);
    }</code></pre> 
<blockquote> 
 <p>mock返回值为 <strong>void</strong> 的 <strong>static</strong> 方法 (<strong>此为后期补充，所以没有提供相关完整代码</strong>)</p> 
</blockquote> 
<ul><li>方法一 </li></ul> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// "xxxUtil" 是类名</span>
<span class="hljs-comment">// "xxxStaticMethod" 是 static 方法的方法名</span>
<span class="hljs-comment">// 这里假设 "xxxStaticMethod" 需要两个参数，一个是 int 型，一个是 String 型</span>
PowerMockito.doNothing().when(xxxUtil.class, <span class="hljs-string">"xxxStaticMethod"</span>, <span class="hljs-number">1</span>，<span class="hljs-string">"mysql"</span>);</code></pre> 
<ul><li>方法二</li></ul> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 这种方式下，可以把所有需要模拟的 "static void" 方法，都列出来</span>
PowerMockito.doNothing().when(xxxUtil.class);
xxxUtil.xxxStaticMethod(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</code></pre> 
<blockquote> 
 <p>mock 同一方法，返回不同的值 (<strong>此为后期补充，所以没有提供相关完整代码</strong>)</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 待测试代码</span>
DatabaseMetaData dbMetaData = connection.getMetaData();
ResultSet schemaSet = dbMetaData.getSchemas();
<span class="hljs-keyword">while</span> (schemaSet.next()) {
    schemaList.add(schemaSet.getString(<span class="hljs-string">"TABLE_SCHEM"</span>));
}</code></pre> 
<p>上面这个代码，我们是想让<strong>schemaSet</strong>返回<strong>true</strong>，好让测试代码能进入<strong>while</strong>循环。但是我们又不能让它一直返回 <strong>true</strong>，否则，<strong>while</strong>将陷入死循环。针对这种需求，应该怎么来处理呢？请看：</p> 
<pre class="prettyprint"><code class="language-java hljs ">Connection connection = PowerMockito.mock(Connection.class);
DatabaseMetaData databaseMetaData = PowerMockito.mock(DatabaseMetaData.class);
ResultSet resultSet = PowerMockito.mock(ResultSet.class);

PowerMockito.when(connection.getMetaData()).thenReturn(databaseMetaData);
PowerMockito.when(databaseMetaData.getSchemas()).thenReturn(resultSet);

<span class="hljs-comment">// 关键步骤</span>
PowerMockito.when(resultSet.next()).thenReturn(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);

PowerMockito.when(resultSet.getString(<span class="hljs-string">"TABLE_SCHEM"</span>)).thenReturn(<span class="hljs-string">"mock schema"</span>);</code></pre> 
<p>上面的关键步骤中，<strong>thenReturn()</strong>方法返回了两个值，一个是true，一个是false。它的意思是，当<strong>next()</strong>第一次被调用时，将会返回 true，第二次及第二次以后的调用将会返回false。这就满足了我们的需求啦。</p> 
<blockquote> 
 <p>mock 泛型 (<strong>此为后期补充，所以没有提供相关完整代码</strong>)</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 待测试代码</span>
List&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-comment">// getAllChildren() 是一个递归方法,且返回值为 void</span>
nodeService.getAllChildren(nodeId, nodes);</code></pre> 
<p>上面的代码，我们在进行Test时，一般都会把<strong>nodeService</strong>中的<strong>getAllChildren()</strong>方法给mock掉，但是这样会导致<strong>nodes</strong>这个List的内容一直为空(因为它的的返回值为<strong>void</strong>)。为了满足在<strong>getAllChildren()</strong>被mock掉的情况下，nodes的内容又不能为空这一需求，我们可以将 <strong>ArrayList</strong> 的 <strong>构造函数</strong>给mock掉。但是，<strong>ArrayList</strong>是一个泛型类，那么在mock它的构造函数时，要如何指定泛型的类型呢？</p> 
<ul><li>方法一 <br> 在构造ArrayList时，不指定泛型类型。 <br> PS：此种方法中，<strong>nodes</strong>变量的类型<strong>必须</strong>是 ArrayList，不能是 List。</li></ul> 
<pre class="prettyprint"><code class="language-java hljs ">ArrayList nodes = <span class="hljs-keyword">new</span> ArrayList() {<!-- -->{
    Node n = <span class="hljs-keyword">new</span> Node();
    n.setId(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">this</span>.add(n);
}};
PowerMockito.whenNew(ArrayList.class).withNoArguments().thenReturn(nodes);</code></pre> 
<ul><li>方法二 <br> 通过使用PowerMock的 <strong>Answer</strong> 机制。</li></ul> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">final</span> List&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayList&lt;Node&gt;() {<!-- -->{
    Node n = <span class="hljs-keyword">new</span> Node();
    n.setId(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">this</span>.add(n);
}};

PowerMockito.whenNew(ArrayList.class).withNoArguments().thenAnswer(<span class="hljs-keyword">new</span> Answer&lt;List&lt;Node&gt;&gt;() {
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title">answer</span>(InvocationOnMock invocation) <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-keyword">return</span> nodes;
    }
});</code></pre> 
<blockquote> 
 <p>mock可变参数</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 待mock方法</span>
<span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title">getFlowByPrjId</span>(<span class="hljs-keyword">int</span> prjId, Integer ...status) {
    <span class="hljs-comment">// do something</span>
}</code></pre> 
<p>像上面这种方法，它有一个被称为<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html#varargs" rel="nofollow">varargs</a>的参数，像这种参数应该如何来模拟呢？ <br> 其实很简单，因为<strong>varargs</strong>参数实际上是被当成数组来处理的，所以，我们只需要像下面这样来处理即可：</p> 
<pre class="prettyprint"><code class="language-java hljs ">when(xxxClass.getFlowByPrjId(Matchers.anyInt(), (Integer[])Matchers.anyVararg())).thenReturn(nodeList);</code></pre> 
<blockquote> 
 <p>mock final方法</p> 
</blockquote> 
<p><strong>final</strong> 与普通方法一样mock，但是需要将其所在<strong>class</strong>添加到<strong>@PrepareForTest</strong>注解中，即</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-annotation">@PrepareForTest</span>({XXXClassWithFinalMethod.class})

XXXClassWithFinalMethod obj = mock(XXXClassWithFinalMethod.class);
when(obj.xxxFinalMethod()).thenReturn(xxxxxxx);</code></pre> 
<p>不然，会报类似下面的异常，让人很迷惑(因为我们明显就是在 <strong>mock</strong> 出来的对象上调用的方法):</p> 
<pre class="prettyprint"><code class="language-java hljs ">when() requires an argument which has to be <span class="hljs-string">'a method call on a mock'</span></code></pre> 
<blockquote> 
 <p>mock 私有内部静态类对象</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassA</span> {<!-- --></span>
        <span class="hljs-keyword">private</span> <span class="hljs-title">InnerClassA</span>(String name) {
            <span class="hljs-keyword">this</span>.name = name;
        }

        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
            <span class="hljs-comment">// do something</span>
        }
    }
}</code></pre> 
<p>对于上面这个类，如果我们想去测试<strong>InnerClassA</strong>类的<strong>run</strong>方法，该怎么做呢？ <br> 首先，因为<strong>InnerClassA</strong>是一个<strong>private</strong>的内部类，所以我们是无法像下面这样来<strong>mock</strong>它的(编译就会报错，这个内部类是不可见的)：</p> 
<pre class="prettyprint"><code class="language-java hljs ">ClassA.InnerClassA aaa = mock(ClassA.InnerClassA.class);</code></pre> 
<p>这种情况下，能想到的办法就是通过反射获取到<strong>InnerClassA</strong>的构造函数，然后生成一个对象。 <br> 那么如何来做呢？<strong>Whitebox</strong>可以帮你实现这一点：</p> 
<pre class="prettyprint"><code class="language-java hljs ">Class clazz = Whitebox.getInnerClassType(ClassA.class, <span class="hljs-string">"InnerClassA"</span>);
Constructor constructor = Whitebox.getConstructor(clazz, String.class);
<span class="hljs-comment">// the constructor needs a string parameter</span>
Object object = constructor.newInstance(<span class="hljs-string">"mock name"</span>);
<span class="hljs-comment">// run the 'run' method</span>
Whitebox.invokeMethod(object, <span class="hljs-string">"run"</span>);</code></pre> 
<blockquote> 
 <p>mock super关键字</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatcherServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> {<!-- --></span>

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>(ServletConfig config) <span class="hljs-keyword">throws</span> ServletException {
        <span class="hljs-keyword">super</span>.init(config);

        <span class="hljs-comment">// do some thing</span>
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span>() {
        <span class="hljs-comment">// do something</span>
    }
}</code></pre> 
<p>对于上面这个类的<strong>init</strong>方法，我们在测试时，一个难点就是，如何把父类中的<strong>init</strong>给mock掉。因为它不像我们其他情况下的方法调用，所以不好通过<strong>when().xxx()</strong>这种方式来mock。这种情况下，就轮到<strong>suppress</strong>方法出面了，下面直接给出mock方式：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-annotation">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInit</span>() <span class="hljs-keyword">throws</span> Exception {
    DispatcherServlet ds = spy(<span class="hljs-keyword">new</span> DispatcherServlet());

    <span class="hljs-comment">// use "method()" to get the "init" method which is defined in "GenericServlet"</span>
    <span class="hljs-comment">// use "suppress()" to suppress the "init" method</span>
    suppress(method(GenericServlet.class, <span class="hljs-string">"init"</span>, ServletConfig.class));

    ds.init(mock(ServletConfig.class))
    <span class="hljs-comment">// other to do ...</span>
}</code></pre> 
<p>这里为什么是<strong>GenericServlet.class</strong>而不是<strong>HttpServlet.class</strong>，因为<strong>init(ServletConfig config)</strong>这个方法是定义在<strong>GenericServlet</strong>中而非<strong>HttpServlet</strong>中。</p> 
<blockquote> 
 <p>spy 使用的注意点</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 待测试代码</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAllChildren</span>(<span class="hljs-keyword">int</span> parentNodeId, List&lt;Node&gt; allChildren) {
    List&lt;Node&gt; children = getChildren(parentNodeId);
    <span class="hljs-comment">// some other logic</span>
    allChildren.addAll(children);
}

<span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title">getChildren</span>(<span class="hljs-keyword">int</span> nodeId) {
    List&lt;Node&gt; children = nodeMapper.getChildren(nodeId);
    <span class="hljs-keyword">return</span> children;
}</code></pre> 
<p>我本意是要测试<strong>getAllChildren()</strong>这个方法，在这个方法中，它调用了<strong>getChildren()</strong>方法，自然而然地，我准备将<strong>getChildren()</strong> mock掉，所以我写了下面的mock语句：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">private</span> XXXService ns = <span class="hljs-keyword">new</span> XXXService();

ns = spy(ns);
<span class="hljs-comment">// nodes 是包含了2个 Node 的 List</span>
when(ns.getChildren(Matchers.anyInt())).thenReturn(nodes);

List&lt;Node&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
ns.getAllChildren(<span class="hljs-number">1</span>, result);

assertEquals(result.size(), <span class="hljs-number">2</span>);</code></pre> 
<p>本以为这样写，测试肯定可以通过的。 <br> 但是事实总是残酷的，运行之后，一直报错，说<strong>result.size()</strong>的值是<strong>0</strong>不是<strong>2</strong>。 <br> 这我就很纳闷了啊，明明返回的是长度为2的list啊，为什么却一直是0呢？ <br> 就是这么一个不起眼的问题，花了我<strong>5</strong>个小时来检查。 <br> 最终在网上一个贴子的点醒下，发现了问题所在。 <br> 问题出就出在下面这句看似理所当然的mock语句上：</p> 
<pre class="prettyprint"><code class="language-java hljs ">when(ns.getChildren(Matchers.anyInt())).thenReturn(nodes);</code></pre> 
<p>它的目的是当<strong>ns</strong>的<strong>getChildren()</strong>被调用且参数是任意<strong>int</strong>类型的值时，都返回<strong>nodes</strong>这个list。但是这样写的话，它相当于只是mock了当参数为<strong>0</strong>的场合下才返回<strong>nodes</strong>这个list。具体原因如下(摘自<strong>org.powermock.api.mockito.PowerMockito.doReturn()</strong>方法的javadoc) <br> <img src="https://images2.imgbox.com/6b/0d/PPXdxWAE_o.png" alt="java doc for 'doReturn' method" title=""> <br> 从这里的说明，我们知道我们的问题是什么了，上面的那种mock写法，其实就是相当于：</p> 
<pre class="prettyprint"><code class="language-java hljs ">when(ns.getChildren(<span class="hljs-number">0</span>)).thenReturn(nodes);</code></pre> 
<p>因为<strong>Matchers.anyInt()</strong>的返回值就是<strong>0</strong>. <br> 所以，只有当参数值为<strong>0</strong>的时候，它才会返回<strong>nodes</strong>这个list。 <br> 然后，根据Javadoc，我们只需要按照如下来修改一下mock语句即可：</p> 
<pre class="prettyprint"><code class="language-java hljs ">doReturn(nodes).when(ns).getChildren(Matchers.anyInt());</code></pre> 
<blockquote> 
 <p>参数的模糊匹配</p> 
</blockquote> 
<p>上面的测试用例中，在mock一个方法时，这个方法的参数都是事先准备好的。那么，有没有什么方式，使用在mock方法时，可以无视方法所需要的参数值呢？答案肯定有的，它就是<strong>org.mockito.Matchers</strong>。在这个类中，提供了很多 <strong>any*</strong>的方法，如：</p> 
<ul><li>anyObject()</li><li>anyString</li><li>anyList()</li><li>……</li></ul> 
<p>我们可以使用这些方法去避免构建那些难以模拟的输入参数，如：</p> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mockFileHelper2</span>() {
        PowerMockito.mockStatic(FileHelper.class);
        PowerMockito.when(FileHelper.getName(Matchers.anyString())).thenReturn(<span class="hljs-string">"lily"</span>);
        Assert.assertEquals(FileHelper.getName(<span class="hljs-string">"lucy"</span>), <span class="hljs-string">"lily"</span>);
        Assert.assertEquals(FileHelper.getName(<span class="hljs-string">"hanmeimei"</span>), <span class="hljs-string">"lily"</span>);
    }</code></pre> 
<p><strong>Matchers</strong>的方便之处，各位可以自己尝试，包你用得爽~ <br> 不过，有一点需要注意一下：如果对某一个参数使用了Matcher，那么，这个方法的所有其他参数也必须使用Matcher，否则将会报错。</p> 
<blockquote> 
 <p>Power Mock 实现原理(转)</p> 
</blockquote> 
<ul><li>当某个测试方法被注解@PrepareForTest标注以后，在运行测试用例时，会创建一个新的org.powermock.core.classloader.MockClassLoader实例，然后加载该测试用例使用到的类（系统类除外）。</li><li>PowerMock会根据你的mock要求，去修改写在注解@PrepareForTest里的class文件（当前测试类会自动加入注解中），以满足特殊的mock需求。例如：去除final方法的final标识，在静态方法的最前面加入自己的虚拟实现等。</li><li>如果需要mock的是系统类的final方法和静态方法，PowerMock不会直接修改系统类的class文件，而是修改调用系统类的class文件，以满足mock需求。</li></ul> 
<p>参考文档：</p> 
<ul><li>官方文档：<a href="https://github.com/jayway/powermock">https://github.com/jayway/powermock</a></li><li>WhiteBox 介绍：<a href="https://github.com/jayway/powermock/wiki/BypassEncapsulation">https://github.com/jayway/powermock/wiki/BypassEncapsulation</a></li><li>官方spring sample: <a href="https://github.com/jayway/powermock/tree/master/examples/spring-mockito">https://github.com/jayway/powermock/tree/master/examples/spring-mockito</a></li><li>关于 @Autowired 的注入问题：<a href="http://stackoverflow.com/questions/36799240/mock-final-class-and-inject-it-to-autowired-data-member-and-overcome-postconstru" rel="nofollow">http://stackoverflow.com/questions/36799240/mock-final-class-and-inject-it-to-autowired-data-member-and-overcome-postconstru</a></li><li><a href="http://agiledon.github.io/blog/2013/11/21/play-trick-with-powermock/" rel="nofollow">http://agiledon.github.io/blog/2013/11/21/play-trick-with-powermock/</a></li><li><a href="http://blog.csdn.net/jackiehff/article/details/14000779">http://blog.csdn.net/jackiehff/article/details/14000779</a></li><li><a href="http://www.cnblogs.com/jiyuqi/p/3564621.html" rel="nofollow">http://www.cnblogs.com/jiyuqi/p/3564621.html</a></li><li><a href="http://blog.csdn.net/dfqin/article/details/6604610">http://blog.csdn.net/dfqin/article/details/6604610</a></li><li><a href="http://blog.csdn.net/booboo2006/article/details/7495863">http://blog.csdn.net/booboo2006/article/details/7495863</a></li></ul> 
<blockquote> 
 <p>最后附上测试类完整代码</p> 
</blockquote> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">import</span> org.junit.Assert;
<span class="hljs-keyword">import</span> org.junit.Test;
<span class="hljs-keyword">import</span> org.junit.runner.RunWith;
<span class="hljs-keyword">import</span> org.mockito.InjectMocks;
<span class="hljs-keyword">import</span> org.mockito.Matchers;
<span class="hljs-keyword">import</span> org.mockito.Mock;
<span class="hljs-keyword">import</span> org.powermock.api.mockito.PowerMockito;
<span class="hljs-keyword">import</span> org.powermock.core.classloader.annotations.PowerMockIgnore;
<span class="hljs-keyword">import</span> org.powermock.core.classloader.annotations.PrepareForTest;
<span class="hljs-keyword">import</span> org.powermock.modules.junit4.PowerMockRunner;
<span class="hljs-keyword">import</span> org.powermock.reflect.Whitebox;

<span class="hljs-keyword">import</span> java.lang.reflect.Method;

<span class="hljs-comment">// 相关注解</span>
<span class="hljs-annotation">@RunWith</span>(PowerMockRunner.class)
<span class="hljs-annotation">@PrepareForTest</span>({UserController.class, FileHelper.class})
<span class="hljs-annotation">@PowerMockIgnore</span>(<span class="hljs-string">"javax.management.*"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserControllerTest</span> {<!-- --></span>

    <span class="hljs-comment">// @Autowired 属性的注入方式: 联合使用 @Mock 和 @InjectMocks</span>
    <span class="hljs-comment">// 下面的方式，将会mock出来一个 user service对象，将将其注入到 UserController 的实例 uc 中去。</span>
    <span class="hljs-annotation">@Mock</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-annotation">@InjectMocks</span>
    <span class="hljs-keyword">private</span> UserController uc;

    <span class="hljs-javadoc">/**
     * mock普通方法
     *
     *<span class="hljs-javadoctag"> @throws</span> Exception
     */</span>
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAddUser</span>() <span class="hljs-keyword">throws</span> Exception {
        UserDto ud = <span class="hljs-keyword">new</span> UserDto();
        PowerMockito.when(userService.addUser(ud)).thenReturn(<span class="hljs-number">1</span>);
        <span class="hljs-comment">// can not stub like this</span>
        <span class="hljs-comment">// PowerMockito.doReturn(1).when(userService.addUser(ud));</span>
        <span class="hljs-keyword">boolean</span> result = uc.addUser(ud);
        Assert.assertEquals(result, <span class="hljs-keyword">true</span>);
    }

    <span class="hljs-javadoc">/**
     * mock抛异常
     *
     *<span class="hljs-javadoctag"> @throws</span> Exception
     */</span>
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelUser</span>() <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">int</span> toDelete = <span class="hljs-number">1</span>;
        <span class="hljs-comment">// 如果 user service 中的 delUser() 方法抛出的是 checked exception，那么，thenThrow() 里需要抛出 Exception()或者其子类；</span>
        <span class="hljs-comment">// 如果delUser() 方法抛出的是 unchecked exception，那么，thenThrow() 里需要抛出 RuntimeException()或其子类</span>
        PowerMockito.when(userService.delUser(toDelete)).thenThrow(<span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"mock exception"</span>));
        <span class="hljs-keyword">boolean</span> result = uc.delUser(toDelete);
        Assert.assertEquals(result, <span class="hljs-keyword">false</span>);
    }

    <span class="hljs-javadoc">/**
     * mock静态方法
     */</span>
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mockFileHelper</span>() {
        PowerMockito.mockStatic(FileHelper.class);
        PowerMockito.when(FileHelper.getName(<span class="hljs-string">"lucy"</span>)).thenReturn(<span class="hljs-string">"lily"</span>);
        Assert.assertEquals(FileHelper.getName(<span class="hljs-string">"lucy"</span>), <span class="hljs-string">"lily"</span>);
    }

    <span class="hljs-javadoc">/**
     * mock 返回值为 void 的方法
     *
     *<span class="hljs-javadoctag"> @throws</span> Exception
     */</span>
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSaveUser</span>() <span class="hljs-keyword">throws</span> Exception {
        UserDto userDto = <span class="hljs-keyword">new</span> UserDto();

        <span class="hljs-comment">// way one:</span>
        PowerMockito.doNothing().when(userService, <span class="hljs-string">"saveUser"</span>, userDto);

        <span class="hljs-comment">// way two:</span>
        PowerMockito.doNothing().when(userService).saveUser(userDto);

        uc.saveUser(userDto);
    }

    <span class="hljs-javadoc">/**
     * mock私有方法&lt;br /&gt;
     * 方法一&lt;br /&gt;
     * PS:该方法中，还介绍了 mock私有字段的值 的方法。
     *
     *<span class="hljs-javadoctag"> @throws</span> Exception
     */</span>
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testModUser</span>() <span class="hljs-keyword">throws</span> Exception {
        UserDto ud = <span class="hljs-keyword">new</span> UserDto();
        <span class="hljs-keyword">int</span> moded = <span class="hljs-number">1</span>;

        PowerMockito.when(userService.modUser(ud)).thenReturn(moded);

        UserController uc2 = PowerMockito.mock(UserController.class);

        <span class="hljs-comment">// 给没有 setter 方法的 私有字段 赋值。</span>
        Whitebox.setInternalState(uc2, <span class="hljs-string">"userService"</span>, userService);

        <span class="hljs-comment">// 因为要测试的是 modUser() 方法，</span>
        <span class="hljs-comment">// 所以，当调用这个方法时，应该让它调用真实的方法，而非被mock掉的方法</span>
        PowerMockito.when(uc2.modUser(ud)).thenCallRealMethod();

        <span class="hljs-comment">// 在modUser()方法中会调用verifyMod()这个私有方法，所以，需要将mock掉</span>
        PowerMockito.when(uc2, <span class="hljs-string">"verifyMod"</span>, moded).thenReturn(<span class="hljs-keyword">true</span>);

        <span class="hljs-keyword">boolean</span> result = uc2.modUser(ud);

        Assert.assertEquals(result, <span class="hljs-keyword">true</span>);
    }

    <span class="hljs-javadoc">/**
     * mock私有方法&lt;br /&gt;
     * 方法二
     *
     *<span class="hljs-javadoctag"> @throws</span> Exception
     */</span>
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testModUser2</span>() <span class="hljs-keyword">throws</span> Exception {
        UserDto ud = <span class="hljs-keyword">new</span> UserDto();
        <span class="hljs-keyword">int</span> moded = <span class="hljs-number">1</span>;

        PowerMockito.when(userService.modUser(ud)).thenReturn(moded);

        <span class="hljs-comment">// 对uc进行监视</span>
        uc = PowerMockito.spy(uc);
        <span class="hljs-comment">// 当uc的verifyMod被执行时，将被mock掉</span>
        PowerMockito.when(uc, <span class="hljs-string">"verifyMod"</span>, moded).thenReturn(<span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">boolean</span> result = uc.modUser(ud);

        Assert.assertEquals(result, <span class="hljs-keyword">true</span>);
    }

    <span class="hljs-javadoc">/**
     * 测试私有方法(注意： 是测试，不是mock)&lt;br /&gt;
     * 方法一
     *
     *<span class="hljs-javadoctag"> @throws</span> Exception
     */</span>
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testVerifyMod</span>() <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 获取Method对象，</span>
        Method method = PowerMockito.method(UserController.class, <span class="hljs-string">"verifyMod"</span>, <span class="hljs-keyword">int</span>.class);
        <span class="hljs-comment">// 调用Method的invoke方法来执行</span>
        <span class="hljs-keyword">boolean</span> result = (<span class="hljs-keyword">boolean</span>) method.invoke(uc, <span class="hljs-number">1</span>);
        Assert.assertEquals(result, <span class="hljs-keyword">true</span>);
    }

    <span class="hljs-javadoc">/**
     * 测试私有方法(注意： 是测试，不是mock)&lt;br /&gt;
     * 方法二
     *
     *<span class="hljs-javadoctag"> @throws</span> Exception
     */</span>
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testVerifyMod2</span>() <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 通过 Whitebox 来执行</span>
        <span class="hljs-keyword">boolean</span> result = Whitebox.invokeMethod(uc, <span class="hljs-string">"verifyMod"</span>, <span class="hljs-number">1</span>);
        Assert.assertEquals(result, <span class="hljs-keyword">true</span>);
    }

    <span class="hljs-javadoc">/**
     * mock新建对象
     *
     *<span class="hljs-javadoctag"> @throws</span> Exception
     */</span>
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCountUser</span>() <span class="hljs-keyword">throws</span> Exception {
        UserDto ud = <span class="hljs-keyword">new</span> UserDto();
        ud.setId(<span class="hljs-number">1</span>);

        PowerMockito.whenNew(UserDto.class).withNoArguments().thenReturn(ud);

        <span class="hljs-keyword">int</span> count = uc.countUser();

        Assert.assertEquals(count, <span class="hljs-number">1</span>);
    }

    <span class="hljs-javadoc">/**
     * 参数的模糊匹配
     */</span>
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mockFileHelper2</span>() {
        PowerMockito.mockStatic(FileHelper.class);
        PowerMockito.when(FileHelper.getName(Matchers.anyString())).thenReturn(<span class="hljs-string">"lily"</span>);
        Assert.assertEquals(FileHelper.getName(<span class="hljs-string">"lucy"</span>), <span class="hljs-string">"lily"</span>);
        Assert.assertEquals(FileHelper.getName(<span class="hljs-string">"hanmeimei"</span>), <span class="hljs-string">"lily"</span>);
    }
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7fc616f920ccab7c73a51c075e214d41/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">交叉编译找不到头文件问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ad9bf96d5e33097163a6d5962c095b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">手把手教你AndroidStudio多渠道打包</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>