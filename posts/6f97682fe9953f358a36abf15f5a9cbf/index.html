<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue @input带参数_重读 VUE 官方文档 &amp;lt;2&amp;gt; - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue @input带参数_重读 VUE 官方文档 &amp;lt;2&amp;gt;" />
<meta property="og:description" content="当在一个自定义组件上使用 class 属性时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。
当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。
v-if vs v-show
v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。
你也可以提供第二个的参数为 property 名称 (也就是键名)：
&lt;div v-for=&#34;(value, name) in object&#34;&gt; {{ name }}: {{ value }} &lt;/div&gt;
Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：
push()pop()shift()unshift()splice()sort()reverse()例如filter()、concat()和slice()。它们不会改变原始数组，而总是返回一个新数组。当使用非变异方法时，也可以触发试图更新。 Vue.set(object, propertyName, value)方法向嵌套对象添加响应式属性
v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。
&lt;div&gt; &lt;span v-for=&#34;n in 10&#34;&gt;{{ n }} &lt;/span&gt; &lt;/div&gt;
当它们处于同一节点，v-for的优先级比v-if更高，这意味着v-if将分别重复运行于每个v-for循环中
需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6f97682fe9953f358a36abf15f5a9cbf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-20T05:21:33+08:00" />
<meta property="article:modified_time" content="2020-11-20T05:21:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue @input带参数_重读 VUE 官方文档 &amp;lt;2&amp;gt;</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/86/3d/RlfxXf8E_o.png" alt="71574171c7c5ed2607d0cb7a9b5dd765.png"> 
 </div> 
 <p>当在一个自定义组件上使用 class 属性时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。<br>当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。<br>v-if vs v-show<br>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-if 也是<b>惰性的</b>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。<br>你也可以提供第二个的参数为 property 名称 (也就是键名)：<br>&lt;div v-for="(value, name) in object"&gt; {<!-- -->{ name }}: {<!-- -->{ value }} &lt;/div&gt;<br>Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p> 
 <ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li><li>例如filter()、concat()和slice()。它们不会改变原始数组，而<b>总是返回一个新数组</b>。当使用非变异方法时，也可以触发试图更新。</li></ul> 
 <p><br>Vue.set(object, propertyName, value)方法向嵌套对象添加响应式属性<br>v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。<br>&lt;div&gt; &lt;span v-for="n in 10"&gt;{<!-- -->{ n }} &lt;/span&gt; &lt;/div&gt;<br>当它们处于同一节点，v-for的优先级比v-if更高，这意味着v-if将分别重复运行于每个v-for循环中<br>需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：<br>&lt;button v-on:click="warn('Form cannot be submitted yet.', $event)"&gt; Submit &lt;/button&gt;<br>// ... methods: { warn: function (message, event) { // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) } }<br>.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。<br>&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt; &lt;button @click.ctrl="onClick"&gt;A&lt;/button&gt; &lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt; &lt;button @click.ctrl.exact="onCtrlClick"&gt;A&lt;/button&gt; &lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt; &lt;button @click.exact="onClick"&gt;A&lt;/button&gt;<br>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。</p> 
 <p><code>v-model</code>指令在表单<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>及<code>&lt;select&gt;</code>元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</p> 
 <p><code>v-model</code>会忽略所有表单元素的<code>value</code>、<code>checked</code>、<code>selected</code>特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的<code>data</code>选项中声明初始值。</p> 
 <ul><li>text 和 textarea 元素使用 <code>value</code> 属性和 <code>input</code> 事件；</li><li>checkbox 和 radio 使用 <code>checked</code> 属性和 <code>change</code> 事件；</li><li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件；</li></ul> 
 <h4><code>.lazy</code></h4> 
 <p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 <code>lazy</code> 修饰符，从而转变为使用 <code>change</code> 事件进行同步：</p> 
 <div class="has"> 
  <pre class="has"><code>&lt;!-- 在“change”时而非“input”时更新 --&gt;
&lt;input v-model.lazy="msg" &gt;</code></pre> 
 </div> 
 <h4><code>.number</code></h4> 
 <p>如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p> 
 <div class="has"> 
  <pre class="has"><code>&lt;input v-model.number="age" type="number"&gt;</code></pre> 
 </div> 
 <p>这通常很有用，因为即使在 <code>type="number"</code> 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。</p> 
 <h4><code>.trim</code></h4> 
 <p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p> 
 <div class="has"> 
  <pre class="has"><code>&lt;input v-model.trim="msg"&gt;</code></pre> 
 </div> 
 <p>父级组件可以像处理 native DOM 事件一样通过 <code>v-on</code> 监听子组件实例的任意事件：</p> 
 <div class="has"> 
  <pre class="has"><code>&lt;blog-post
  ...
  v-on:enlarge-text="postFontSize += 0.1"
&gt;&lt;/blog-post&gt;</code></pre> 
 </div> 
 <p>同时子组件可以通过调用内建的 <code>$emit</code> 方法 并传入事件名称来触发一个事件：</p> 
 <div class="has"> 
  <pre class="has"><code>&lt;button v-on:click="$emit('enlarge-text')"&gt;
  Enlarge text
&lt;/button&gt;</code></pre> 
 </div> 
 <p>有了这个 <code>v-on:enlarge-text="postFontSize += 0.1"</code>监听器，父级组件就会接收该事件并更新 <code>postFontSize</code>的值。</p> 
 <p>有的时候用一个事件来抛出一个特定的值是非常有用的。例如我们可能想让 <code>&lt;blog-post&gt;</code> 组件决定它的文本要放大多少。这时可以使用 <code>$emit</code> 的第二个参数来提供这个值：</p> 
 <div class="has"> 
  <pre class="has"><code>&lt;button v-on:click="$emit('enlarge-text', 0.1)"&gt;
  Enlarge text
&lt;/button&gt;</code></pre> 
 </div> 
 <p>然后当在父级组件监听这个事件的时候，我们可以通过 <code>$event</code> 访问到被抛出的这个值：</p> 
 <div class="has"> 
  <pre class="has"><code>&lt;blog-post
  ...
  v-on:enlarge-text="postFontSize += $event"
&gt;&lt;/blog-post&gt;</code></pre> 
 </div> 
 <p>或者，如果这个事件处理函数是一个方法：</p> 
 <div class="has"> 
  <pre class="has"><code>&lt;blog-post
  ...
  v-on:enlarge-text="onEnlargeText"
&gt;&lt;/blog-post&gt;</code></pre> 
 </div> 
 <p>那么这个值将会作为第一个参数传入这个方法：</p> 
 <div class="has"> 
  <pre class="has"><code>methods: {
  onEnlargeText: function (enlargeAmount) {
    this.postFontSize += enlargeAmount
  }
}</code></pre> 
 </div> 
 <p>所有的 prop 都使得其父子 prop 之间形成了一个<b>单向下行绑定</b>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p> 
 <p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<b>不</b>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p> 
 <div class="has"> 
  <pre class="has"><code>&lt;input v-model="searchText"&gt;</code></pre> 
 </div> 
 <p>等价于：</p> 
 <div class="has"> 
  <pre class="has"><code>&lt;input
  v-bind:value="searchText"
  v-on:input="searchText = $event.target.value"
&gt;</code></pre> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8237fca370da4a8251f5020d2d22025b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">cmd 顺序启动服务_springboot项目注册为windows系统服务并设置开机自启</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a226d929089b62903e5fe4160071c5dd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">统计24小时内每个小时最后一条数据_如你所愿，一篇文章搞定8种Excel多表统计...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>