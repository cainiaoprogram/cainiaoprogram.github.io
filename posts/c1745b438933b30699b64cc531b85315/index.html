<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统（二）内存管理——页式与段式存储 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统（二）内存管理——页式与段式存储" />
<meta property="og:description" content="操作系统（二）内存管理——页式与段式存储 内存管理的意义段式存储页式存储段页式管理 今天没有代码，因为我还没想明白怎么写！ 因为不知道今天的代码应该怎么写，所以决定先写一写内存分配的原理。
先忽略掉教材里面众多有关于内存管理的知识点，只简单介绍一下页式和段式存储两种内存管理方式。为之后引入保护模式和长模式进行一下铺垫。
内存管理的意义 在我个人的观念里，引入内存管理主要有一下两个原因：
随着CPU从开始的20位增加到32位再到现在的64位CPU，可以直接访问的内存从最初的只有1M增加到4G再到16EG（理论值，目前支持到128G）。为了管理如此大量的存储空间，要设计一些管理模式（算法）去管理这样基数的内存，使得内存的分配有程序可寻。现代程序对内存的需求逐渐加大，加之分时系统的内存中可能会有大量程序正在运行，如何合理给每个程序分配内存才能将计算机各部件的利用率提高成为了一个需要深入研究的问题。 孙子曰：凡治众如治寡，分数是也。
总而言之，内存管理就是通过设计一种合理的数据结构，来进行内存的管理，以降低系统的复杂度，并提高系统的效率。
今天暂且只介绍页式存储和段式存储。
段式存储 段式存储是为了解决以上两种问题所提出的一种算法。段式存储将内存分割为若干长度不同或相同的数据段；要求每个段内的内存连续，段间地址不必连续。
在学习的过程中发现，有两种分段机制，一种是在操作系统进行加载时的对内存进行的分段，另一种是用户进程中按自然段进行分段。具体还需要在以后学习中查阅资料理解。
每个段的描述信息，包括段基址、段长等信息将以下图的形式进行组成，形成一个段表项，由多个段表项组成组成一张段表，存储在内存中。
在对内存进行分段之后，需要通过以下的方式来访问内存地址。
31 … 1615 … 0段号S段内偏移量W 程序在访问内存地址时，分别给出段号S和段内偏移量W，再根据段号S查找段表获得段基址，然后计算得到要访问的实际地址。
页式存储 在这里仅提及基础页式存储的原理，并不涉及有关虚拟内存的内容。
和段式存储不同，页式存储的每个页面的大小是固定的。因此当给进程分配内存时，若有进程内存不足一页时，将分配一整页。分页存储的逻辑地址结构如下：
31 … 1615 … 0页号P段内偏移量W 和段式存储的逻辑地址结构基本相同。因此，也同样需要引入一张页表进行地址的映射。由于每一页的长度L固定，所以可以根据逻辑地址A计算得到页号P和段内偏移量W。
P = A / L P = A / L P=A/L
W = A m o d &amp;ThinSpace;&amp;ThinSpace; L W = A \mod L W=AmodL
再根据P查找页表，获得页的起始地址F，即可以求得实际地址。
随着页表项的增加，为了提高查找速度，以及降低内存占用，可以引入多级页表，在此不再深入，有兴趣可以自行查阅教材。
需要注意的是，在页式存储中，每个进程都有自己的页表。
尽管页式存储和段式存储原理上相近，但是这两种存储方式有一些差异：
一般来说页式存储的每个基本单元（页）的大小要小于段式存储中的段。页式存储在分配内存时可能会产生内部碎片，而段式不会。还有好多。。。 段页式管理 在页式和段式存储方式出现以后，又有牛人将其进行了结合，形成了段页式管理方式。目前还用不到，所以懒得写了，可以自行查阅教材。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c1745b438933b30699b64cc531b85315/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-23T00:46:07+08:00" />
<meta property="article:modified_time" content="2019-02-23T00:46:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统（二）内存管理——页式与段式存储</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>操作系统（二）内存管理——页式与段式存储</h4> 
 <ul><li><a href="#_9" rel="nofollow">内存管理的意义</a></li><li><a href="#_18" rel="nofollow">段式存储</a></li><li><a href="#_32" rel="nofollow">页式存储</a></li><li><a href="#_51" rel="nofollow">段页式管理</a></li></ul> 
</div> 
<br> 今天没有代码，因为我还没想明白怎么写！ 
<p></p> 
<p><img src="https://images2.imgbox.com/94/99/WmqZeR3p_o.jpg" alt="在这里插入图片描述"></p> 
<p>因为不知道今天的代码应该怎么写，所以决定先写一写内存分配的原理。</p> 
<p>先忽略掉教材里面众多有关于内存管理的知识点，只简单介绍一下页式和段式存储两种内存管理方式。为之后引入保护模式和长模式进行一下铺垫。</p> 
<h2><a id="_9"></a>内存管理的意义</h2> 
<p>在我个人的观念里，引入内存管理主要有一下两个原因：</p> 
<ol><li>随着CPU从开始的20位增加到32位再到现在的64位CPU，可以直接访问的内存从最初的只有1M增加到4G再到16EG（理论值，目前支持到128G）。为了管理如此大量的存储空间，要设计一些管理模式（算法）去管理这样基数的内存，使得内存的分配有程序可寻。</li><li>现代程序对内存的需求逐渐加大，加之分时系统的内存中可能会有大量程序正在运行，如何合理给每个程序分配内存才能将计算机各部件的利用率提高成为了一个需要深入研究的问题。</li></ol> 
<blockquote> 
 <p>孙子曰：凡治众如治寡，分数是也。</p> 
</blockquote> 
<p>总而言之，内存管理就是通过设计一种合理的数据结构，来进行内存的管理，以降低系统的复杂度，并提高系统的效率。</p> 
<p>今天暂且只介绍页式存储和段式存储。</p> 
<h2><a id="_18"></a>段式存储</h2> 
<p>段式存储是为了解决以上两种问题所提出的一种算法。段式存储将内存分割为若干长度不同或相同的数据段；要求每个段内的内存连续，段间地址不必连续。</p> 
<p>在学习的过程中发现，有两种分段机制，一种是在操作系统进行加载时的对内存进行的分段，另一种是用户进程中按自然段进行分段。具体还需要在以后学习中查阅资料理解。</p> 
<p>每个段的描述信息，包括段基址、段长等信息将以下图的形式进行组成，形成一个段表项，由多个段表项组成组成一张段表，存储在内存中。<br> <img src="https://images2.imgbox.com/88/66/qKRNcQEM_o.png" alt="段表项的组成"></p> 
<p>在对内存进行分段之后，需要通过以下的方式来访问内存地址。</p> 
<table><thead><tr><th>31 … 16</th><th>15 … 0</th></tr></thead><tbody><tr><td>段号S</td><td>段内偏移量W</td></tr></tbody></table> 
<p>程序在访问内存地址时，分别给出段号S和段内偏移量W，再根据段号S查找段表获得段基址，然后计算得到要访问的实际地址。</p> 
<h2><a id="_32"></a>页式存储</h2> 
<p>在这里仅提及基础页式存储的原理，并不涉及有关虚拟内存的内容。</p> 
<p>和段式存储不同，页式存储的每个页面的大小是固定的。因此当给进程分配内存时，若有进程内存不足一页时，将分配一整页。分页存储的逻辑地址结构如下：</p> 
<table><thead><tr><th>31 … 16</th><th>15 … 0</th></tr></thead><tbody><tr><td>页号P</td><td>段内偏移量W</td></tr></tbody></table> 
<p>和段式存储的逻辑地址结构基本相同。因此，也同样需要引入一张页表进行地址的映射。由于每一页的长度L固定，所以可以根据逻辑地址A计算得到页号P和段内偏移量W。<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          P 
         
        
          = 
         
        
          A 
         
        
          / 
         
        
          L 
         
        
       
         P = A / L 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.13889em;">P</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">A</span><span class="mord">/</span><span class="mord mathit">L</span></span></span></span></span></span><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          W 
         
        
          = 
         
        
          A 
         
         
         
         
         
           m 
          
         
           o 
          
         
           d 
          
        &amp;ThinSpace;&amp;ThinSpace; 
        
          L 
         
        
       
         W = A \mod L 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.13889em;">W</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit">A</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right: 1em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathit">L</span></span></span></span></span></span><br> 再根据P查找页表，获得页的起始地址F，即可以求得实际地址。<br> 随着页表项的增加，为了提高查找速度，以及降低内存占用，可以引入多级页表，在此不再深入，有兴趣可以自行查阅教材。<br> 需要注意的是，在页式存储中，每个进程都有自己的页表。</p> 
<p>尽管页式存储和段式存储原理上相近，但是这两种存储方式有一些差异：</p> 
<ul><li>一般来说页式存储的每个基本单元（页）的大小要小于段式存储中的段。</li><li>页式存储在分配内存时可能会产生内部碎片，而段式不会。</li><li>还有好多。。。</li></ul> 
<h2><a id="_51"></a>段页式管理</h2> 
<p>在页式和段式存储方式出现以后，又有牛人将其进行了结合，形成了段页式管理方式。目前还用不到，所以懒得写了，可以自行查阅教材。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/999f17a72fdf4ca3aa0fc887c2a42595/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">分布式消息中间件Kafka</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4ef1e9b621209e53b1bcfcb3b252348f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">有道云笔记快捷键用法（加自己的补充）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>