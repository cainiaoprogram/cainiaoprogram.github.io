<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Collection集合总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Collection集合总结" />
<meta property="og:description" content="ArrayList: 底层数组，可重复，有序，可存多个null,查快。快速随机访问标志--实现RandomAccess接口，序列化，克隆，初始空数组，容量10，grow方法 每次1.5倍。
浅拷贝：基本数据类型值传递；引用类型，只存地址，在改动原始对象时会同时改变克隆对象的值 需要实现 Cloneable 接口，并覆写 clone() 方法。
深拷贝：基本数据类型值传递；引用类型，创建新对象，并把内容复制过去。
LinkedList：底层双向链表，可重复，有序，可存多个null，插入，删除。
HashMap：实现Map接口， 1.8之前数组&#43;链表。1.8后数组&#43;链表&#43;红黑树，当链表长度阙值达到8时，将转化为红黑树，（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组 扩容，而不是转换为红黑树），红黑树降低时间复杂度到logN
key只可以有一个null，value多个null。put时可以put多个key为null的，不报错，以最后一个为准，存value。
扩容：初始16；扩容为原来的2倍；如果给定初始容量，会扩容到2的幂次方大小
使用Key计算hashcode
多线程时，会造成数据丢失。
ConcurrentHashMap: 线程安全，底层实现:
1.7之前采用分段segment数组&#43;HashEntry数组&#43;链表实现， 分段锁每一段一个锁，一段下包含一个Segment数组，一个segment包含一个HashEntry数组。每个HashEntry是一个链表结构的元素。将要对HashEntry数组修改时，必须首先获得对应的Segment的锁。
1.8开始 node数组&#43;链表/红黑树。取消了分段锁，采用CAS算法和synchronized来保证并发安全。
synchronized只锁定当前链表或红黑树的首节点。
HashTable：线程安全（synchronized修饰的方法），效率低，
扩容：初始11，扩容2n&#43;1；如果给定初始容量，会按照初始容量。
不能有 NULLKey NULL VALUE，会报java.lang.NullPointerException。
TreeMap：红黑树，有序。要实现Comparator接口。
Vector：list古老实现类，线程安全， 底层数组
HashSet：实现Set接口，底层是HashMap实现，add()添加元素，使用对象计算hashcode。不可重复。
在添加对象时，先用hashcode比较，如果存在相同用equals()比较。
两个对象可能hashcode相同，但是也不一定相等。
只可以存一个NULL，不可重复。add相同的也会只存一个。
LinkedHashSet：是HashSet的子类，可以按照添加顺序遍历。通过LinkedHashMap实现。
TreeSet：底层也是红黑树，可以按照添加顺序遍历，并可以自然排序和定制排序。有序，唯一。重写new Comparator(){ public int compare(Object o1,Object o2){ return o1.compareTo(o2); }} 进行排序。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7639372b0e93fdaac75311918cc0f864/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-27T17:47:09+08:00" />
<meta property="article:modified_time" content="2021-05-27T17:47:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Collection集合总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#f33b45;">ArrayList:</span> 底层数组，<span style="color:#3399ea;">可重复，有序，可存多个null</span>,查快。快速随机访问标志--实现RandomAccess接口，序列化，克隆，初始空数组，容量10，grow方法 每次1.5倍。</p> 
<p>浅拷贝：基本数据类型值传递；引用类型，只存地址，在改动原始对象时会同时改变克隆对象的值 需要实现 <code>Cloneable</code> 接口，并覆写 <code>clone()</code> 方法。</p> 
<p>深拷贝：基本数据类型值传递；引用类型，创建新对象，并把内容复制过去。</p> 
<p><span style="color:#f33b45;">LinkedList：</span>底层双向链表，<span style="color:#3399ea;">可重复，有序，可存多个null</span>，插入，删除。</p> 
<p><span style="color:#f33b45;">HashMap：实现Map接口， </span>1.8之前数组+链表。1.8后数组+链表+红黑树，当链表长度阙值达到8时，将转化为红黑树，（<span style="color:#3b454e;">将链表转换成红黑树前会判断，如果当前数组的长度小于 64</span><span style="color:#3b454e;">，那么会选择先进行数组 扩容，而不是转换为红黑树</span>），红黑树降低时间复杂度到logN</p> 
<p>        <span style="color:#3399ea;">key只可以有一个null，value多个null</span>。put时可以put多个key为null的，不报错，以最后一个为准，存value。</p> 
<p>       扩容：初始16；扩容为原来的2倍；如果给定初始容量，会扩容到2的幂次方大小</p> 
<p>       使用Key计算hashcode</p> 
<p>       多线程时，会造成数据丢失。</p> 
<p><span style="color:#f33b45;">ConcurrentHashMap:   线程安全，</span>底层实现:</p> 
<p>          1.7之前采用分段segment数组+HashEntry数组+链表实现， 分段锁每一段一个锁，一段下包含一个Segment数组，一个segment包含一个HashEntry数组。每个HashEntry是一个链表结构的元素。将要对HashEntry数组修改时，必须首先获得对应的Segment的锁。</p> 
<p>          1.8开始 node数组+链表/红黑树。取消了分段锁，采用CAS算法和synchronized来保证并发安全。</p> 
<p>          synchronized只锁定当前链表或红黑树的首节点。</p> 
<p><span style="color:#f33b45;">HashTable：线程安全（synchronized修饰的方法），</span>效率低<span style="color:#f33b45;">，</span></p> 
<p>                  扩容：初始11，扩容2n+1；如果给定初始容量，会按照初始容量。</p> 
<p>                  不能有 <span style="color:#f33b45;">NULLKey NULL VALUE</span>，会报java.lang.NullPointerException。</p> 
<p><span style="color:#f33b45;">TreeMap：</span>红黑树，有序。要实现Comparator接口。</p> 
<p><span style="color:#f33b45;">Vector：</span>list古老实现类，<span style="color:#f33b45;">线程安全，</span> 底层数组</p> 
<p><span style="color:#f33b45;">HashSet：</span>实现Set接口，底层是HashMap实现，add()添加元素，使用对象计算hashcode。不可重复。</p> 
<p>                 在添加对象时，先用hashcode比较，如果存在相同用equals()比较。</p> 
<p>                 两个对象可能hashcode相同，但是也不一定相等。</p> 
<p>                <span style="color:#7c79e5;">只可以存一个NULL，不可重复。</span>add相同的也会只存一个。</p> 
<p><span style="color:#f33b45;">LinkedHashSet</span>：是HashSet的子类，可以按照添加顺序遍历。通过LinkedHashMap实现。</p> 
<p><span style="color:#f33b45;">TreeSet</span>：底层也是<span style="color:#f33b45;">红黑树</span>，可以按照添加顺序遍历，并可以自然排序和定制排序。有序，唯一。重写new Comparator(){ public int compare(Object o1,Object o2){  return o1.compareTo(o2);  }}     进行排序。</p> 
<p style="text-align:center;"><img alt="" height="187" src="https://images2.imgbox.com/b5/93/5X39y6V3_o.png" width="643"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad567bd0900e84a90ea62ec755dcdc4c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">甲骨文提供非常良心的永久免费云主机空间</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/39a3c0e6772c0d9e0398cae4ec36bcbd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三星s8 android9.0官方rom,三星S8&#43;港版安卓9官方固件rom刷机包：TGY-G9550ZHU3DSD3</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>