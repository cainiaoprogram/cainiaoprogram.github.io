<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VC利用GDI&#43;技术制作基于CWnd类的Spalsh启动画面 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VC利用GDI&#43;技术制作基于CWnd类的Spalsh启动画面" />
<meta property="og:description" content="最近想做个程序的启动画面，原因当然就是为了使程序更加美观、好看一些。原来记得VC5中有个Splash Screen组件，可以直接做启动画面的，结果在VC .Net中，这个组件已经找不到了。是不是取消了这个功能，本人不太清楚。于是网上搜了一些关于Splash启动画面的资料，研究了一番，结果都不太满意。有一篇流传比较广的，是基于Dialog做的，效果一样，但是如果为了做一个启动画面，就得加一个Dialog资源，感觉比较“原始”一点。另外有几篇是基于CWnd类做的，这才是制作Spalsh本来的技术嘛，不过这几篇，要么是在项目内加一个BMP资源，要么用CPicture类从文件加载图像资源，现在不是有GDI&#43;技术嘛，于是研究了一下，完成了这个利用GDI&#43;技术制作基于CWnd类的Splash启动画面的程序。
一、在程序中增加GDI&#43;支持
1、在APP的头文件或者stdafx.h中引用Gdiplus头文件，并使用GDI名空间。
#include &#34;gdiplus.h&#34; // 使用GDI&#43;技术
// 使用GDI&#43;名空间
using namespace Gdiplus;
#pragma comment(lib,&#34;gdiplus.lib&#34;) // 添加GDI&#43;库文件
2、启动GDI系统资源初始化和注销，这个可以在APP类中实现，也可以在启动画面类CSplashWnd类中实现，根据具体情况来定。但要在类中添加一个protected型的变量m_gdiplusToken，代码如下：
protected:
// GDI&#43;程序启动的标识
ULONG_PTR m_gdiplusToken;
// GDI&#43;系统资源初始化
Gdiplus::GdiplusStartupInput gdiplusStartupInput;
Gdiplus::GdiplusStartup(&amp;m_gdiplusToken, &amp;gdiplusStartupInput,NULL); // 启动GDI&#43;资源
// 销毁GDI&#43;系统资源
Gdiplus::GdiplusShutdown(m_gdiplusToken); // 关闭GDI&#43;资源
二、项目上添加启动画面的CSplashWnd类
1、程序中添加基于CWnd类的CSplashWnd类，并把CSplash类的构造函数修改，增加文件名的参数。
CSplashWnd::CSplashWnd(LPCWSTR lpszFileName)
并在类中增加一些private型变量：
private:
LPCWSTR m_sImageName; Image * m_pImage;
UINT nWidth;
UINT nHeight;
然后添加WM_CREATE和WM_PAINT消息的响应函数
afx_msg void OnPaint();
afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
2、编写构造函数和析构函数
CSplashWnd::CSplashWnd(LPCWSTR lpszFileName)
{
m_sImageName = lpszFileName;
nWidth = 0;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8001c70a511252871fffcd69031b0085/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2009-05-12T08:51:00+08:00" />
<meta property="article:modified_time" content="2009-05-12T08:51:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VC利用GDI&#43;技术制作基于CWnd类的Spalsh启动画面</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最近想做个程序的启动画面，原因当然就是为了使程序更加美观、好看一些。原来记得VC5中有个Splash Screen组件，可以直接做启动画面的，结果在VC .Net中，这个组件已经找不到了。是不是取消了这个功能，本人不太清楚。于是网上搜了一些关于Splash启动画面的资料，研究了一番，结果都不太满意。有一篇流传比较广的，是基于Dialog做的，效果一样，但是如果为了做一个启动画面，就得加一个Dialog资源，感觉比较“原始”一点。另外有几篇是基于CWnd类做的，这才是制作Spalsh本来的技术嘛，不过这几篇，要么是在项目内加一个BMP资源，要么用CPicture类从文件加载图像资源，现在不是有GDI+技术嘛，于是研究了一下，完成了这个利用GDI+技术制作基于CWnd类的Splash启动画面的程序。</p> 
<p> </p> 
<p><span style="font-size: medium;"><strong>一、在程序中增加GDI+支持</strong></span></p> 
<p>1、在APP的头文件或者stdafx.h中引用Gdiplus头文件，并使用GDI名空间。</p> 
<p style="PADDING-LEFT: 60px">#include "gdiplus.h" // 使用GDI+技术<br>// 使用GDI+名空间<br>using namespace Gdiplus;<br>#pragma comment(lib,"gdiplus.lib") // 添加GDI+库文件</p> 
<p> 2、启动GDI系统资源初始化和注销，这个可以在APP类中实现，也可以在启动画面类CSplashWnd类中实现，根据具体情况来定。但要在类中添加一个protected型的变量m_gdiplusToken，代码如下：</p> 
<p style="PADDING-LEFT: 60px">protected:</p> 
<p style="PADDING-LEFT: 90px"> // GDI+程序启动的标识<br> ULONG_PTR m_gdiplusToken;</p> 
<p style="PADDING-LEFT: 60px"> </p> 
<p style="PADDING-LEFT: 60px"> // GDI+系统资源初始化<br> Gdiplus::GdiplusStartupInput gdiplusStartupInput;<br> Gdiplus::GdiplusStartup(&amp;m_gdiplusToken, &amp;gdiplusStartupInput,NULL); // 启动GDI+资源</p> 
<p style="PADDING-LEFT: 60px"> </p> 
<p style="PADDING-LEFT: 60px"> // 销毁GDI+系统资源<br> Gdiplus::GdiplusShutdown(m_gdiplusToken); // 关闭GDI+资源</p> 
<p> </p> 
<p><span style="font-size: medium;"><strong>二、项目上添加启动画面的CSplashWnd类</strong></span></p> 
<p>1、程序中添加基于CWnd类的CSplashWnd类，并把CSplash类的构造函数修改，增加文件名的参数。</p> 
<p style="padding-left: 60px;">CSplashWnd::CSplashWnd(LPCWSTR lpszFileName)</p> 
<p>并在类中增加一些private型变量：</p> 
<p style="padding-left: 60px;">private:<br> LPCWSTR m_sImageName;  <br> Image * m_pImage;<br> UINT nWidth;<br> UINT nHeight;</p> 
<p> 然后添加WM_CREATE和WM_PAINT消息的响应函数</p> 
<p style="padding-left: 60px;"> afx_msg void OnPaint();<br> afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);</p> 
<p> </p> 
<p> </p> 
<p>2、编写构造函数和析构函数</p> 
<p>CSplashWnd::CSplashWnd(LPCWSTR lpszFileName)<br>{<!-- --><br> m_sImageName = lpszFileName;<br> nWidth = 0;<br> nHeight = 0;<br> m_pImage = NULL;<br>} </p> 
<p> </p> 
<p>CSplashWnd::~CSplashWnd(void)<br>{<!-- --><br> if(m_pImage) delete m_pImage;<br> m_pImage = NULL;<br>}</p> 
<p> </p> 
<p>3、从文件加载图像并弹出启动画面</p> 
<p>在类中添加一个CreateWnd(CWnd* pParentWnd = NULL)函数，设为public型。<br>声明： BOOL CreateWnd(CWnd* pParentWnd = NULL);</p> 
<p>定义：// 建立启动画面的弹出式窗口<br>BOOL CSplashWnd::CreateWnd(CWnd* pParentWnd /*= NULL*/)<br>{<!-- --><br> m_pImage = new Image(m_sImageName);<br> if (!m_pImage) <br> {<!-- --><br>  TRACE0(_T("图像文件不存在"));<br>  return FALSE;<br> }</p> 
<p> nWidth = m_pImage-&gt;GetWidth();<br> nHeight = m_pImage-&gt;GetHeight();</p> 
<p> LPCTSTR strSplashWndClass;</p> 
<p>strSplashWndClass = AfxRegisterWndClass(CS_VREDRAW | CS_HREDRAW | CS_PARENTDC, AfxGetApp()-&gt;LoadStandardCursor(IDC_ARROW),<br>  0,AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME));</p> 
<p> return CreateEx(0,strSplashWndClass,NULL, WS_POPUP|WS_VISIBLE, 0, 0, nWidth, nHeight, pParentWnd-&gt;GetSafeHwnd(), NULL);<br>}</p> 
<p> </p> 
<p>4、编写OnPaint()和OnCreate()函数</p> 
<p>void CSplashWnd::OnPaint()<br>{<!-- --><br> CPaintDC pDC(this); // device context for painting<br> // TODO: 在此处添加消息处理程序代码<br> // 不为绘图消息调用 CWnd::OnPaint()<br> Graphics p_Graphics(pDC.m_hDC);<br> p_Graphics.DrawImage(m_pImage,0,0,nWidth,nHeight);<br>}</p> 
<p> </p> 
<p>int CSplashWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)<br>{<!-- --><br> if (CWnd::OnCreate(lpCreateStruct) == -1)<br>  return -1;</p> 
<p> // TODO:  在此添加您专用的创建代码<br> CenterWindow();//使弹出窗口居中</p> 
<p> return 0;<br>}</p> 
<p> </p> 
<p>5、为防止内存溢出，窗口销毁后要释放CSplashWnd对象，为此，我们重载虚拟函数PostNcDestroy，此函数在窗口销毁后调用。</p> 
<p>void CSplashWnd::PostNcDestroy()<br>{<!-- --><br> // TODO: 在此添加专用代码和/或调用基类<br> delete this;<br> CWnd::PostNcDestroy();<br>}</p> 
<p> </p> 
<p>6、在CSplashWnd的.Cpp文件中，添加Resource.h文件的引用</p> 
<p style="PADDING-LEFT: 30px">#include "Resource.h"</p> 
<p> </p> 
<p><span style="font-size: medium;"><strong>三、Splash画面的启动方法</strong></span></p> 
<p>Splash画面可以有2种启动方式，一种是用Sleep()阻断进程，启动画面，另一种是用定时器开设新线程，来启动画面，2种方式各有各的益处。于是本人设计通过一个参数，来实现不同的启动方式。</p> 
<p> </p> 
<p>1、增加显示时间变量</p> 
<p>在CSplashWnd类中添加一个整形变量，表示画面显示的时间，同样设为private型变量</p> 
<p style="PADDING-LEFT: 30px">private:</p> 
<p style="PADDING-LEFT: 60px">UINT nSplashTime;</p> 
<p> </p> 
<p> 2、添加WM_TIMER定时器消息的响应函数OnTimer()，代码如下：</p> 
<p>void CSplashWnd::OnTimer(UINT nIDEvent)<br>{<!-- --><br> // TODO: 在此添加消息处理程序代码和/或调用默认值<br> if(IsWindowVisible())<br> { <br>  SetActiveWindow(); //把启动画面设置为当前活动窗口 <br>  UpdateWindow(); <br>  ::Sleep(nSplashTime); //修改此处可更改画面显示时间 <br>  SendMessage(WM_CLOSE); //关闭对话框 <br> } <br> else<br> { <br>  AfxGetMainWnd()-&gt;SetActiveWindow(); // 激动主框架窗口<br>  KillTimer(nIDEvent) ;  //清除WM_TIMER事件 <br> }<br> //CWnd::OnTimer(nIDEvent);<br>}</p> 
<p> </p> 
<p>3、增加显示画面的函数ShowSplashScreen()，这个函数应该是public型的，代码如下：</p> 
<p>// 显示启动画面 nSeconds表示显示的毫秒，nMode表示显示的方法，0-阻断显示，1-定时器显示<br>void CSplashWnd::ShowSplashScreen(UINT nSeconds,UINT nMode)<br>{<!-- --><br> // 显示启动画面<br> if (!CreateWnd(AfxGetMainWnd())) {<!-- --><br>  delete this;<br>  return; }</p> 
<p> nSplashTime = nSeconds;<br> </p> 
<p> if(nMode == 0)<br> { <br>  UpdateWindow();<br>  ::Sleep(nSeconds);<br>  DestroyWindow();<br> }<br> if(nMode == 1) SetTimer(1,100,NULL); //启动ID为1的定时器<br>}</p> 
<p> </p> 
<p><span style="font-size: medium;"><strong>四、在CMainFrame框架类中，启动CSplashWnd类</strong></span></p> 
<p>在OnCreate()函数的最后面，添加如下代码：</p> 
<p> CSplashWnd * pSplashWnd;<br> pSplashWnd = new CSplashWnd(L"splash1.jpg");<br> pSplashWnd-&gt;ShowSplashScreen(2000,0); // 显示时间为2秒，方式为阻断模式</p> 
<p> </p> 
<p>最后一个完美的Splash启动画面就完成了。如果想使用定时器模式，只需要将最后一句代码修改成下面。</p> 
<p> pSplashWnd-&gt;ShowSplashScreen(2000,1); // 显示时间为2秒，方式为定时器模式</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a6bf6190c6d7500d8619eb6f2235ca2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">maxint的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba7c465332a9e7cf13064861af753888/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CMD命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>