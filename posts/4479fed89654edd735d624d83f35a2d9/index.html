<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>为什么引入@FeignClient注解接口的同时引入其实现类 通过@Autowired会注入FeignClient实现的代理类？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="为什么引入@FeignClient注解接口的同时引入其实现类 通过@Autowired会注入FeignClient实现的代理类？" />
<meta property="og:description" content="前言 最近公司在进行项目的微服务升级采用的是Spring Cloud，每个拆分的服务大概分为两个模块 xxx-api 模块用于提供此服务对外的调用接口，接口上都标注了@FeignClient注解其他项目直接引用即可使用，xxx-service 模块是针对 xxx-api 的实现除了实现Service层的接口外还需要提供对应的Controller作为真正对外响应的HTTP服务。
编写的Controller非常简单，通过@AutoWired自动注入对应的Service层接口即可，但是在实际开发中我们发现一个奇怪的问题，编写的Controller自动注入的居然是FeignClient生成的代理接口而不是我们实现的Service层接口。这到底是为什么了？而且同时存在两个相同类型的Bean在Spring容器中在注入时却没有报错这又是为什么？
分析 针对这个问题实际来说是有两个疑问的，1）为什么会优先注入 FeignClient 的接口代理类 2）为什么两个同类型的Bean 在自动注入时不会报错
这个要从起点说起，我们引入Feign的功能，首先要在启动类上注解 @EnableFeignClients，表示启动FeignClient功能
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented @Import(FeignClientsRegistrar.class) public @interface EnableFeignClients{ ... } 根据注解的源码，我们可以知道当启动Spring应用之后，在初始的过程中会调用 FeignClientsRegistrar 的逻辑
class FeignClientsRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware, EnvironmentAware { ... @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { registerDefaultConfiguration(metadata, registry); //1) registerFeignClients(metadata, registry); //2) } ... } 实际在初始化时会执行 ImportBeanDefinitionRegistrar#registerBeanDefinitions 方法
1）注册 @EnableFeignClients#defaultConfiguration 配置的配置类到 Spring 容器中
2）根据 @EnableFeignClients 注册的包路径，扫描所有注解了 @FeignClient 的接口，调用 ImportBeanDefinitionRegistrar#registerFeignClient 将其注册到 Spring 容器中" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4479fed89654edd735d624d83f35a2d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-01T11:54:44+08:00" />
<meta property="article:modified_time" content="2020-04-01T11:54:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">为什么引入@FeignClient注解接口的同时引入其实现类 通过@Autowired会注入FeignClient实现的代理类？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>最近公司在进行项目的微服务升级采用的是Spring Cloud，每个拆分的服务大概分为两个模块 xxx-api 模块用于提供此服务对外的调用接口，接口上都标注了@FeignClient注解其他项目直接引用即可使用，xxx-service 模块是针对 xxx-api 的实现除了实现Service层的接口外还需要提供对应的Controller作为真正对外响应的HTTP服务。</p> 
<p>编写的Controller非常简单，通过@AutoWired自动注入对应的Service层接口即可，但是在实际开发中我们发现一个奇怪的问题，编写的Controller自动注入的居然是FeignClient生成的代理接口而不是我们实现的Service层接口。这到底是为什么了？而且同时存在两个相同类型的Bean在Spring容器中在注入时却没有报错这又是为什么？</p> 
<h3>分析</h3> 
<p>针对这个问题实际来说是有两个疑问的，1）为什么会优先注入 FeignClient 的接口代理类 2）为什么两个同类型的Bean 在自动注入时不会报错</p> 
<p>这个要从起点说起，我们引入Feign的功能，首先要在启动类上注解 @EnableFeignClients，表示启动FeignClient功能</p> 
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(FeignClientsRegistrar.class)
public @interface EnableFeignClients{
    ...
}
</code></pre> 
<p>根据注解的源码，我们可以知道当启动Spring应用之后，在初始的过程中会调用 FeignClientsRegistrar 的逻辑</p> 
<pre><code>class FeignClientsRegistrar implements ImportBeanDefinitionRegistrar,
        ResourceLoaderAware, EnvironmentAware {
    
    ...

    @Override
    public void registerBeanDefinitions(AnnotationMetadata metadata,
            BeanDefinitionRegistry registry) {
        registerDefaultConfiguration(metadata, registry); //1)
        registerFeignClients(metadata, registry); //2)
    }

    ...
}
</code></pre> 
<p>实际在初始化时会执行 ImportBeanDefinitionRegistrar#registerBeanDefinitions 方法<br> 1）注册 @EnableFeignClients#defaultConfiguration 配置的配置类到 Spring 容器中<br> 2）根据 @EnableFeignClients 注册的包路径，扫描所有注解了 @FeignClient 的接口，调用 ImportBeanDefinitionRegistrar#registerFeignClient 将其注册到 Spring 容器中</p> 
<pre><code>private void registerFeignClient(BeanDefinitionRegistry registry,                          
        AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) {           
    String className = annotationMetadata.getClassName();                                  
    BeanDefinitionBuilder definition = BeanDefinitionBuilder                               
            .genericBeanDefinition(FeignClientFactoryBean.class); //1)                          
    validate(attributes);                                                                  
    definition.addPropertyValue("url", getUrl(attributes));                                
    definition.addPropertyValue("path", getPath(attributes));                              
    String name = getName(attributes);                                                     
    definition.addPropertyValue("name", name);                                             
    definition.addPropertyValue("type", className);                                        
    definition.addPropertyValue("decode404", attributes.get("decode404"));                 
    definition.addPropertyValue("fallback", attributes.get("fallback"));                   
    definition.addPropertyValue("fallbackFactory", attributes.get("fallbackFactory"));     
    definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);                   
                                                                                           
    String alias = name + "FeignClient";                                                   
    AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();                
                                                                                           
    boolean primary = (Boolean)attributes.get("primary"); // has a default, won't be null  
                                                                                           
    beanDefinition.setPrimary(primary);//2)                                                    
                                                                                           
    String qualifier = getQualifier(attributes);                                           
    if (StringUtils.hasText(qualifier)) {                                                  
        alias = qualifier;                                                                 
    }                                                                                      
                                                                                           
    BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className,      
            new String[] { alias });                                                       
    BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);                    
} 
</code></pre> 
<p>很明确的，我们可以知道FeignClient接口代理类实际是通过 FeignClientFactoryBean 生成的。<br> 1）FeignClientFactoryBean 作为生成代理类的Bean工厂<br> 2）是否将该 BeanDefinition 作为自动装配的第一候选者，@FeignClient#primary 默认为 true</p> 
<p>至此我们的两个疑问就都解答了，我们来看下 BeanDefinition#setPrimary 的注释</p> 
<pre><code>/**                                                                     
* Set whether this bean is a primary autowire candidate.               
* &lt;p&gt;If this value is {@code true} for exactly one bean among multiple
* matching candidates, it will serve as a tie-breaker.                 
*/                                                                     
@Override                                                               
public void setPrimary(boolean primary) {                               
    this.primary = primary;                                             
}                                                                       
</code></pre> 
<p>简单翻译下：是否将此Bean设置为自动注入的第一候选，如果多个匹配候选中仅有一个的primary为true则它会胜出。</p> 
<p>对源码有兴趣的可以查看此方法 DefaultListableBeanFactory#resolveNamedBean 里面定义了通过Class获取Bean的完整过程。</p> 
<h3>总结</h3> 
<p>针对问题一，它是唯一将primary设置为true的候选者，所以会将其优先注入<br> 针对问题二，有多个候选者Spring会不知道该选择谁，所以他会报错，但是将primary设置为true后，将只有一个候选者</p> 
<p>所以我们在实际开发时想解决这个问题有两个方案</p> 
<ol><li>名称注入 @Resource("xxx") 或者 @Autowired + @Qualifier("xxx")</li><li>通过设置优先级解决 @FeignClient(primary = false) 然后在接口实现类上加入 @Primary</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e11357cf2f14bd7b84cb756f0cd4e91/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">memcpy函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0fffc71a62ac97867f19feb69c58334b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL Server连接不到服务器的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>