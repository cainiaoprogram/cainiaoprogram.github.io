<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>机器学习笔记：第2章 模型评估与选择 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="机器学习笔记：第2章 模型评估与选择" />
<meta property="og:description" content=" 一、经验误差与过拟合
经验误差/训练误差：学习器在训练集上的误差。
泛化误差：学习器在新样本上的误差。
过拟合：经验误差小但是泛化误差大，则发生过拟合现象。
二、评估方法
模型的选择通常选择泛化误差小的模型，但是泛化误差无法直接获取，因此用测试误差近似泛化误差进行模型评估。 1 划分数据集为训练集和测试集的方法 （进行模型泛化误差的近似估计）
（1）留出法 留出法：将数据集D划分为两个互斥的数据集S和T，分别为训练集和测试集 。满足分层采样，多次划分取平均。一般取数据集的2/3--4/5作为训练集。
（2）交叉验证法
将D划分为k个互斥的子集，每次使用k-1个子集的并集作为训练集S，剩余1个为测试集，从而获得k组训练集/测试集，进行k次训练和验证，最终返回k次的平均值 。
（3）自助法 基于自助采样法，每次从m个样本的数据集D中，进行有放回的随机采样 1个样本拷贝到d中，进行m次操作后得到含有m个样本的d作为训练集，d中未出现的D中的样本作为测试集，评估模型的泛化误差。初始数据量较少，难以划分训练集和测试集时该方法较好。
三、性能度量 性能度量：衡量模型泛化能力的评价标准。
回归任务常用性能度量：均方误差。
分类任务：错误率、精度、查准率、查全率
1 错误率与精度
错误率：E=a/m;a为m个样本中分错的个数
精度：1-错误率
2 查准率和查全率
查准率：亦称召回率。模型预测正例正确的样本数TP（真正例），占模型预测为正例的样本数（TP&#43;FP）的比例：P=TP/(TP&#43;FP)
查全率：模型预测正例真确的样本数TP，占模型总体样本中正例（TP&#43;FN）的比例：P=TP/(TP&#43;FN)
查准率和查全率是一对矛盾的量，一般来说，一个高则另一个低。
PR曲线：查准率和查全率构成的曲线，若一个学习器A的PR曲线包住学习器B的PR曲线，则可断言学习器A的性能优于B。
F1度量：F1是查准率和查全率的调和平均：F1=2×P×R/(P&#43;R)=2×TP/(样例总数&#43;TP-TN）
3 ROC 与AUC
很多学习器为测试样本产生一个实值或概率预测，然后将预测值与分类阈值进行比较，大于阈值为正例，小于该阈值为反例。可以根据预测值将测试样例排序，排在最前面的为最可能是正例的样本，分类过程就相当于在这个排序中以某个截断点将样本分为正反两部分。
ROC曲线：纵轴为真正例率，横轴为假正例率
真正例率：TPR =TP/(TP&#43;FN) 假正例率：FPR=FP/(TN&#43;FP)
AUC=1-Lrank;ROC曲线与轴围成的面积；Lrank为正反例排序损失
4 代价敏感错误率与代价曲线
为权衡不同错误造成的不同损失，可为错误赋予非均等代价。
代价曲线：横轴取值[0-1]的正例概率代价，纵轴为取值[0-1]的归一化代价。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a4b9056511e1d8f64f533a44b9df6441/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-10T17:21:07+08:00" />
<meta property="article:modified_time" content="2022-12-10T17:21:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">机器学习笔记：第2章 模型评估与选择</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、经验误差与过拟合</p> 
<p>经验误差/训练误差：学习器在训练集上的误差。</p> 
<p>泛化误差：学习器在新样本上的误差。</p> 
<p>过拟合：经验误差小但是泛化误差大，则发生过拟合现象。</p> 
<p>二、评估方法</p> 
<p>模型的选择通常选择泛化误差小的模型，但是泛化误差无法直接获取，因此用测试误差近似泛化误差进行模型评估。 </p> 
<p>1 划分数据集为训练集和测试集的方法 （进行模型泛化误差的近似估计）</p> 
<p>（1）留出法 </p> 
<p>留出法：将数据集D划分为两个互斥的数据集S和T，分别为训练集和测试集 。满足分层采样，多次划分取平均。一般取数据集的2/3--4/5作为训练集。</p> 
<p>（2）交叉验证法</p> 
<p>将D划分为k个互斥的子集，每次使用k-1个子集的并集作为训练集S，剩余1个为测试集，从而获得k组训练集/测试集，进行k次训练和验证，最终返回k次的平均值 。</p> 
<p>（3）自助法 </p> 
<p>基于自助采样法，每次从m个样本的数据集D中，进行有放回的随机采样 1个样本拷贝到d中，进行m次操作后得到含有m个样本的d作为训练集，d中未出现的D中的样本作为测试集，评估模型的泛化误差。初始数据量较少，难以划分训练集和测试集时该方法较好。</p> 
<p>三、性能度量 </p> 
<p> 性能度量：衡量模型泛化能力的评价标准。</p> 
<p>回归任务常用性能度量：均方误差。</p> 
<p>分类任务：错误率、精度、查准率、查全率</p> 
<p>1 错误率与精度</p> 
<p> 错误率：E=a/m;a为m个样本中分错的个数</p> 
<p>精度：1-错误率</p> 
<p>2 查准率和查全率</p> 
<p>查准率：亦称召回率。模型预测正例正确的样本数TP（真正例），占模型预测为正例的样本数（TP+FP）的比例：P=TP/(TP+FP)</p> 
<p>查全率：模型预测正例真确的样本数TP，占模型总体样本中正例（TP+FN）的比例：P=TP/(TP+FN)</p> 
<p>查准率和查全率是一对矛盾的量，一般来说，一个高则另一个低。</p> 
<p>PR曲线：查准率和查全率构成的曲线，若一个学习器A的PR曲线包住学习器B的PR曲线，则可断言学习器A的性能优于B。</p> 
<p>F1度量：F1是查准率和查全率的调和平均：F1=2×P×R/(P+R)=2×TP/(样例总数+TP-TN）</p> 
<p>3 ROC 与AUC</p> 
<p>很多学习器为测试样本产生一个实值或概率预测，然后将预测值与分类阈值进行比较，大于阈值为正例，小于该阈值为反例。可以根据预测值将测试样例排序，排在最前面的为最可能是正例的样本，分类过程就相当于在这个排序中以某个截断点将样本分为正反两部分。</p> 
<p>ROC曲线：纵轴为真正例率，横轴为假正例率</p> 
<p>真正例率：TPR =TP/(TP+FN)        假正例率：FPR=FP/(TN+FP)</p> 
<p>AUC=1-Lrank;ROC曲线与轴围成的面积；Lrank为正反例排序损失</p> 
<p>4 代价敏感错误率与代价曲线</p> 
<p>为权衡不同错误造成的不同损失，可为错误赋予非均等代价。</p> 
<p>代价曲线：横轴取值[0-1]的正例概率代价，纵轴为取值[0-1]的归一化代价。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a2711838b8f0f7bd063bfdf337685f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vits官方gituhb项目--模型构建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3c1a03f71c9e8e65eb35d01b5d74947e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nacos注册中心和配置中心</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>