<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python 面试题第一弹 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python 面试题第一弹" />
<meta property="og:description" content="1. 如何理解Python中的深浅拷贝 浅拷贝（Shallow Copy）创建一个新的对象，该对象的内容是原始对象的引用。这意味着新对象与原始对象共享相同的内存地址，因此对于可变对象来说，如果修改了其中一个对象，另一个对象也会受到影响。浅拷贝通常使用copy模块的copy()函数或者对象的copy()方法来完成。
下面是一个浅拷贝的示例：
import copy original_list = [1, 2, [3, 4]] copied_list = copy.copy(original_list) print(original_list) # [1, 2, [3, 4]] print(copied_list) # [1, 2, [3, 4]] # 修改原始列表中的元素 original_list[0] = 10 original_list[2][0] = 30 print(original_list) # [10, 2, [30, 4]] print(copied_list) # [1, 2, [30, 4]] 在上面的示例中，copy.copy()函数创建了original_list的浅拷贝copied_list。当我们修改original_list时，copied_list中的嵌套列表也会受到影响。
深拷贝（Deep Copy）创建一个新的对象，该对象的内容是原始对象及其所有嵌套对象的副本。这意味着新对象在内存中是完全独立的，对其中一个对象的修改不会影响另一个对象。深拷贝通常使用copy模块的deepcopy()函数或者对象的deepcopy()方法来完成。
下面是一个深拷贝的示例：
import copy original_list = [1, 2, [3, 4]] deep_copied_list = copy.deepcopy(original_list) print(original_list) # [1, 2, [3, 4]] print(deep_copied_list) # [1, 2, [3, 4]] # 修改原始列表中的元素 original_list[0] = 10 original_list[2][0] = 30 print(original_list) # [10, 2, [30, 4]] print(deep_copied_list) # [1, 2, [3, 4]] 在上面的示例中，copy." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7ff2caf302a5c5792fd4c51e9fa82ed2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T20:00:00+08:00" />
<meta property="article:modified_time" content="2023-12-25T20:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python 面试题第一弹</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><img alt="" src="https://images2.imgbox.com/fc/b6/uAEl94Kr_o.jpg"></h4> 
<h4>1. 如何理解Python中的深浅拷贝</h4> 
<p>浅拷贝（Shallow Copy）创建一个新的对象，该对象的内容是原始对象的引用。这意味着<strong>新对象与原始对象共享相同的内存地址</strong>，因此对于可变对象来说，如果修改了其中一个对象，另一个对象也会受到影响。浅拷贝通常使用<code>copy</code>模块的<code>copy()</code>函数或者对象的<code>copy()</code>方法来完成。</p> 
<p>下面是一个浅拷贝的示例：</p> 
<pre>import copy

original_list = [1, 2, [3, 4]]
copied_list = copy.copy(original_list)

print(original_list)  # [1, 2, [3, 4]]
print(copied_list)  # [1, 2, [3, 4]]

# 修改原始列表中的元素
original_list[0] = 10
original_list[2][0] = 30

print(original_list)  # [10, 2, [30, 4]]
print(copied_list)  # [1, 2, [30, 4]]
</pre> 
<p>在上面的示例中，<code>copy.copy()</code>函数创建了<code>original_list</code>的浅拷贝<code>copied_list</code>。当我们修改<code>original_list</code>时，<code>copied_list</code>中的嵌套列表也会受到影响。</p> 
<p>深拷贝（Deep Copy）创建一个新的对象，该对象的内容是原始对象及其所有嵌套对象的<strong>副本</strong>。这意味着新对象在<strong>内存中是完全独立的</strong>，对其中一个对象的修改不会影响另一个对象。深拷贝通常使用<code>copy</code>模块的<code>deepcopy()</code>函数或者对象的<code>deepcopy()</code>方法来完成。</p> 
<p>下面是一个深拷贝的示例：</p> 
<pre>import copy

original_list = [1, 2, [3, 4]]
deep_copied_list = copy.deepcopy(original_list)

print(original_list)  # [1, 2, [3, 4]]
print(deep_copied_list)  # [1, 2, [3, 4]]

# 修改原始列表中的元素
original_list[0] = 10
original_list[2][0] = 30

print(original_list)  # [10, 2, [30, 4]]
print(deep_copied_list)  # [1, 2, [3, 4]]
</pre> 
<p>在上面的示例中，<code>copy.deepcopy()</code>函数创建了<code>original_list</code>的深拷贝<code>deep_copied_list</code>。即使我们修改<code>original_list</code>，<code>deep_copied_list</code>中的嵌套列表也不会受到影响。</p> 
<p>需要注意的是，深拷贝可能会比浅拷贝更耗费时间和内存，因为它需要递归地复制所有嵌套对象。因此，在处理大型对象或嵌套层级很深的对象时，需要谨慎使用深拷贝。</p> 
<p>总结起来，浅拷贝创建一个新对象，该对象与原始对象共享部分内存，而深拷贝创建一个完全独立的新对象，它复制了原始对象及其所有嵌套对象的内容。根据需求选择适当的拷贝方式可以帮助我们正确地处理对象并避免意外的副作用。</p> 
<h4>2.  谈谈 is 和 == 的区别：</h4> 
<p>在Python中，<code>is</code>和<code>==</code>是用于比较对象的运算符，它们具有不同的功能和用途。</p> 
<p><code>is</code>运算符用于比较两个对象的身份标识，即它们是否指向同一个内存地址。如果两个对象具有相同的身份标识，即它们是同一个对象，那么<code>is</code>运算符返回<code>True</code>；否则，返回<code>False</code>。</p> 
<p><code>==</code>运算符用于比较两个对象的值是否相等。它会比较两个对象的内容，而不关心它们是否指向同一个内存地址。如果两个对象的值相等，<code>==</code>运算符返回<code>True</code>；否则，返回<code>False</code>。</p> 
<p>下面是一个示例，展示了<code>is</code>和<code>==</code>运算符的区别：</p> 
<pre>list1 = [1, 2, 3]
list2 = [1, 2, 3]
list3 = list1

print(list1 is list2)  # False，list1和list2不是同一个对象
print(list1 is list3)  # True，list1和list3是同一个对象

print(list1 == list2)  # True，list1和list2的值相等
</pre> 
<p>在上面的示例中，<code>list1</code>和<code>list2</code>虽然具有相同的值，但它们是不同的对象，因此<code>list1 is list2</code>返回<code>False</code>。另一方面，<code>list1</code>和<code>list3</code>指向同一个对象，因此<code>list1 is list3</code>返回<code>True</code>。而<code>list1 == list2</code>返回<code>True</code>，因为它们的值相等。</p> 
<p>需要注意的是，对于简单的值类型（如整数、字符串等），<code>is</code>和<code>==</code>的结果通常是一致的。但对于可变对象（如列表、字典等），<code>is</code>和<code>==</code>的结果可能不同，因为可变对象的身份标识可能相同，但值不同。</p> 
<p>总结起来，<code>is</code>运算符用于比较两个对象的身份标识，即它们是否指向同一个内存地址；而<code>==</code>运算符用于比较两个对象的值是否相等。在编写代码时，需要根据具体的需求选择适当的运算符。如果要比较对象的值，应使用<code>==</code>运算符；如果要比较对象的身份标识，应使用<code>is</code>运算符。</p> 
<h4>3. 说说闭包和装饰器的概念：</h4> 
<p>**闭包（Closure）**是指在一个函数内部定义的函数，并且内部函数可以访问外部函数的变量。闭包可以捕获和保持外部函数的状态，即使外部函数已经执行完毕，内部函数仍然可以使用那些被捕获的变量。闭包在需要保持某些状态或者提供数据隐藏时非常有用。</p> 
<p>下面是一个闭包的例子：</p> 
<pre>def outer_function(x):
    def inner_function(y):
        return x + y
    return inner_function

closure = outer_function(10)
result = closure(5)
print(result)  # 输出 15
</pre> 
<p>在上面的例子中，<code>outer_function</code>是外部函数，它接受一个参数<code>x</code>并返回一个内部函数<code>inner_function</code>。内部函数<code>inner_function</code>可以访问外部函数<code>outer_function</code>的参数<code>x</code>，即使在<code>outer_function</code>执行完毕后仍然有效。</p> 
<p>**装饰器（Decorator）**是一种特殊的闭包，用于修改或增强函数的功能而不修改函数本身的定义。装饰器通常用于添加额外的代码，例如日志记录、性能分析、输入验证等。装饰器可以在不修改原函数代码的情况下，对函数进行包装和扩展。</p> 
<p>下面是一个简单的装饰器的例子：</p> 
<pre>def logger(func):
    def wrapper(*args, **kwargs):
        print(f"Calling function: {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Function {func.__name__} executed.")
        return result
    return wrapper

@logger
def add(a, b):
    return a + b

result = add(2, 3)
print(result)  # 输出 5
</pre> 
<p>在上面的例子中，<code>logger</code>是一个装饰器函数，它接受一个函数作为参数，并返回一个新的函数<code>wrapper</code>。<code>wrapper</code>函数在调用被装饰的函数之前和之后打印日志信息。</p> 
<p>通过使用<code>@logger</code>语法，我们将装饰器应用到<code>add</code>函数上。当调用<code>add</code>函数时，实际上是调用了被装饰后的<code>wrapper</code>函数，从而实现了日志记录的功能增强。</p> 
<p>实际应用中，闭包和装饰器有许多用例。以下是一些示例：</p> 
<ol><li>计时器：使用装饰器记录函数的执行时间。</li><li>认证和权限控制：使用装饰器验证用户身份和控制访问权限。</li><li>缓存：使用闭包实现函数的结果缓存，以避免重复计算。</li><li>日志记录：使用装饰器将函数的调用和返回值记录到日志文件中。</li><li>输入验证：使用装饰器对函数的输入参数进行验证和过滤。</li></ol> 
<h4>4. 用装饰器实现一个日志记录的例子：</h4> 
<pre>def logger(func):
    def wrapper(*args, **kwargs):
        print(f"Calling function: {func.__name__}")
        print(f"Arguments: {args}, {kwargs}")
        result = func(*args, **kwargs)
        print(f"Function {func.__name__} executed.")
        print(f"Result: {result}")
        return result
    return wrapper

@logger
def add(a, b):
    return a + b

result = add(2, 3)
</pre> 
<h4>5. 可变对象和不可变对象有哪些：</h4> 
<p>**不可变对象（Immutable objects）**是指创建后不能被修改的对象。当对不可变对象进行操作时，会创建一个新的对象。以下是一些常见的不可变对象：</p> 
<ol><li>**数字（Numbers）**：包括整数（int）、浮点数（float）、复数（complex）等。</li><li>**布尔值（Booleans）**：True和False。</li><li>**字符串（Strings）**：一旦创建，字符串的值就不能被修改。</li><li>**元组（Tuples）**：元组是一种有序且不可变的集合。</li></ol> 
<p>以下是不可变对象的一些特点：</p> 
<ul><li>不可变对象的值在创建后不能被修改，对其进行操作会创建一个新的对象。</li><li>不可变对象在多线程环境下是线程安全的，因为其状态不可变。</li><li>不可变对象可以作为字典的键或集合的元素，因为它们的哈希值不会变化。</li></ul> 
<p>**可变对象（Mutable objects）**是可以修改的对象，即可以改变对象的值或状态。以下是一些常见的可变对象：</p> 
<ol><li>**列表（Lists）**：列表是有序且可变的集合，可以通过索引进行修改。</li><li>**字典（Dictionaries）**：字典是无序的键值对集合，可以通过键进行修改。</li><li>**集合（Sets）**：集合是无序且唯一的元素集合，可以进行添加、删除等操作。</li></ol> 
<p>以下是可变对象的一些特点：</p> 
<ul><li>可变对象的值可以在创建后被修改，对其进行操作会直接修改原始对象。</li><li>可变对象在多线程环境下需要进行同步操作，以避免并发修改导致的问题。</li><li>可变对象不能作为字典的键或集合的元素，因为其值的变化可能导致哈希值的变化。</li></ul> 
<h4>6. 什么是值传递和引用传递：</h4> 
<p>**值传递（Pass-by-Value）**是指将实际参数的值复制一份，传递给函数或赋值给新变量。在这种情况下，函数或新变量操作的是复制后的值，对原始变量的修改不会影响到原始值。</p> 
<p>**引用传递（Pass-by-Reference）**是指将实际参数的引用或地址传递给函数或赋值给新变量。在这种情况下，函数或新变量操作的是原始变量所在的内存地址，对变量的修改会直接影响到原始值。</p> 
<p>在Python中，参数传递是通过引用传递的方式进行的。也就是说，函数或方法的参数传递的是对象的引用，而不是对象本身的副本。这意味着，如果在函数内部对引用的对象进行修改，会影响到原始对象。</p> 
<p>下面是一个示例：</p> 
<pre>def modify_list(lst):
    lst.append(4)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list)  # 输出 [1, 2, 3, 4]</pre> 
<p>在上面的例子中，我们定义了一个<code>modify_list</code>函数，它接受一个列表作为参数并向列表中添加一个元素。当我们调用<code>modify_list(my_list)</code>时，实际上是将<code>my_list</code>的引用传递给<code>modify_list</code>函数。在函数内部，我们通过引用对列表进行修改，添加了一个新元素。这导致原始列表<code>my_list</code>也被修改，输出结果为<code>[1, 2, 3, 4]</code>。</p> 
<p>在实际使用中，我们需要根据需求选择值传递还是引用传递。一般来说，如果希望在函数内部修改原始对象，可以使用引用传递。如果希望保持原始对象不变，可以使用值传递或传递对象的副本。</p> 
<p>需要注意的是，在Python中，虽然参数传递是通过引用传递的方式，但对于不可变对象（如整数、字符串、元组），因为其值无法修改，所以表现类似于值传递。而对于可变对象（如列表、字典、集合），因为其值可以修改，所以表现类似于引用传递。</p> 
<p>值传递例子：</p> 
<pre>def modify_value(value):
    value = value + 1

x = 10
modify_value(x)
print(x)  # 输出 10</pre> 
<p>在上面的例子中，我们定义了一个<code>modify_value</code>函数，它接受一个整数参数<code>value</code>。在函数内部，我们对<code>value</code>进行加1操作。然而，即使在函数内部对<code>value</code>进行了修改，原始变量<code>x</code>的值并没有改变。这是因为整数是不可变对象，函数调用时发生的是值传递，传递的是<code>x</code>的值的副本，而不是<code>x</code>本身</p> 
<p><strong>最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：</strong></p> 
<p>行动吧，在路上总比一直观望的要好，未来的你肯定会感谢现在拼搏的自己！如果想学习提升找不到资料，没人答疑解惑时，<strong>请及时加入群： 731789136</strong>，里面有各种测试开发资料和技术可以一起交流哦。</p> 
<h4><img alt="" height="707" src="https://images2.imgbox.com/56/fe/JdDnh6oz_o.png" width="929"></h4> 
<p>这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！</p> 
<p class="img-center"><img alt="" height="126" src="https://images2.imgbox.com/66/0c/y3iCMwis_o.png" width="634"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1d23df5e19669dec5d5854235571e4bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Git：git clone报错The project you were looking for could not be found or you don‘t have ...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46ae07c68f57d7f61eb4396ba913d759/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PAT乙级 1011 A&#43;B 和 C</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>