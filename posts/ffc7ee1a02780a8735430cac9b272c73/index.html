<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python&#43;Opencv实现无参数、全自动的Canny算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python&#43;Opencv实现无参数、全自动的Canny算法" />
<meta property="og:description" content="目录 一、什么是Canny边缘检测算法？二、最优边缘准则是什么？三、Canny算法实现步骤四、Canny算法在使用中的问题？五、无参数、自动化Canny算法代码实现六、改进算法效果展示七、问题探讨参考资料注意事项 一、什么是Canny边缘检测算法？ Canny边缘检测算子是John F. Canny于 1986 年开发出来的一个多级边缘检测算法。更为重要的是 Canny 创立了边缘检测计算理论（Computational theory of edge detection）解释这项技术如何工作。
通常情况下边缘检测的目的是在保留原有图像属性的情况下，显著减少图像的数据规模。目前有多种算法可以进行边缘检测，虽然Canny算法年代久远，但可以说它是边缘检测的一种标准算法，而且仍在研究中广泛使用。其效果如下图所示：
二、最优边缘准则是什么？ 最优检测：算法能够尽可能多地标识出图像中的实际边缘，漏检真实边缘的概率和误检非边缘的概率都尽可能小；最优定位准则：检测到的边缘点的位置距离实际边缘点的位置最近，或者是由于噪声影响引起检测出的边缘偏离物体的真实边缘的程度最小；检测点与边缘点一一对应：算子检测的边缘点与实际边缘点应该是一一对应。为了满足这些要求 Canny 使用了变分法（calculus of variations），这是一种寻找优化特定功能的函数的方法。最优检测使用四个指数函数项表示，但是它非常近似于高斯函数的一阶导数 三、Canny算法实现步骤 应用高斯滤波来平滑图像，目的是去除噪声；计算图像的强度梯度（intensity gradients）；应用非最大抑制（non-maximum suppression）技术来消除边误检（本来不是但检测出来是）；应用双阈值的方法来决定可能的（潜在的）边界；利用滞后技术来跟踪边界。 具体的实现细节可以查看该链接。
四、Canny算法在使用中的问题？ Canny算法的检测效果很好，得到了广泛的应用。它经常出现在一些算法的预处理阶段，除此之外，很多计算机视觉库中都集成了Canny算，代表性的包括Opencv，cv2.canny(image, lower, upper)是Opencv中的Canny算法的调用接口。**但是大家在调用的过程中都会遇到一个难题-lower和upper参数如何来设置呢？**很多人采取的方法是减少范围不断的去尝试直到找到一个合适的阈值，但是这种方法费时费力，而且鲁棒性较差。**你经常会发现，这个参数适用于这张图片但是当你输入另外一张图片时效果就不好啦！**本文的主要目的就是来解决这个问题的!
五、无参数、自动化Canny算法代码实现 # -*- coding: utf-8 -*- # 导入一些python包 import numpy as np import argparse import glob import cv2 import os # 定义auto_canny函数 def auto_canny(image, sigma=0.33): # 计算单通道像素强度的中位数 v = np.median(image) # 选择合适的lower和upper值，然后应用它们 lower = int(max(0, (1.0 - sigma) * v)) upper = int(min(255, (1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ffc7ee1a02780a8735430cac9b272c73/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T22:01:03+08:00" />
<meta property="article:modified_time" content="2023-03-15T22:01:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python&#43;Opencv实现无参数、全自动的Canny算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#Canny_1" rel="nofollow">一、什么是Canny边缘检测算法？</a></li><li><a href="#_6" rel="nofollow">二、最优边缘准则是什么？</a></li><li><a href="#Canny_11" rel="nofollow">三、Canny算法实现步骤</a></li><li><a href="#Canny_20" rel="nofollow">四、Canny算法在使用中的问题？</a></li><li><a href="#Canny_23" rel="nofollow">五、无参数、自动化Canny算法代码实现</a></li><li><a href="#_82" rel="nofollow">六、改进算法效果展示</a></li><li><a href="#_86" rel="nofollow">七、问题探讨</a></li><li><a href="#_101" rel="nofollow">参考资料</a></li><li><a href="#_105" rel="nofollow">注意事项</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="Canny_1"></a>一、什么是Canny边缘检测算法？</h3> 
<p>  Canny边缘检测算子是John F. Canny于 1986 年开发出来的一个多级边缘检测算法。更为重要的是 Canny 创立了边缘检测计算理论（Computational theory of edge detection）解释这项技术如何工作。<br>   通常情况下边缘检测的目的是在保留原有图像属性的情况下，显著减少图像的数据规模。目前有多种算法可以进行边缘检测，虽然Canny算法年代久远，但可以说它是边缘检测的一种标准算法，而且仍在研究中广泛使用。其效果如下图所示：<br> <img src="https://images2.imgbox.com/93/fe/48bcHad0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_6"></a>二、最优边缘准则是什么？</h3> 
<ol><li><strong>最优检测</strong>：算法能够尽可能多地标识出图像中的实际边缘，漏检真实边缘的概率和误检非边缘的概率都尽可能小；</li><li><strong>最优定位准则</strong>：检测到的边缘点的位置距离实际边缘点的位置最近，或者是由于噪声影响引起检测出的边缘偏离物体的真实边缘的程度最小；</li><li><strong>检测点与边缘点一一对应</strong>：算子检测的边缘点与实际边缘点应该是一一对应。为了满足这些要求 Canny 使用了变分法（calculus of variations），这是一种寻找优化特定功能的函数的方法。最优检测使用四个指数函数项表示，但是它非常近似于高斯函数的一阶导数</li></ol> 
<h3><a id="Canny_11"></a>三、Canny算法实现步骤</h3> 
<ol><li>应用<strong>高斯滤波</strong>来平滑图像，目的是去除噪声；</li><li>计算图像的<strong>强度梯度</strong>（intensity gradients）；</li><li>应用<strong>非最大抑制（non-maximum suppression）技术</strong>来消除边误检（本来不是但检测出来是）；</li><li>应用<strong>双阈值</strong>的方法来决定可能的（潜在的）边界；</li><li>利用<strong>滞后技术</strong>来跟踪边界。</li></ol> 
<p>具体的实现细节可以查看<a href="https://baike.baidu.com/item/canny%E7%AE%97%E6%B3%95" rel="nofollow">该链接</a>。</p> 
<h3><a id="Canny_20"></a>四、Canny算法在使用中的问题？</h3> 
<p>  Canny算法的检测效果很好，得到了广泛的应用。它经常出现在一些算法的预处理阶段，除此之外，很多计算机视觉库中都集成了Canny算，代表性的包括Opencv，cv2.canny(image, lower, upper)是Opencv中的Canny算法的调用接口。**但是大家在调用的过程中都会遇到一个难题-lower和upper参数如何来设置呢？**很多人采取的方法是减少范围不断的去尝试直到找到一个合适的阈值，但是这种方法费时费力，而且鲁棒性较差。**你经常会发现，这个参数适用于这张图片但是当你输入另外一张图片时效果就不好啦！**本文的主要目的就是来解决这个问题的!</p> 
<h3><a id="Canny_23"></a>五、无参数、自动化Canny算法代码实现</h3> 
<pre><code># -*- coding: utf-8 -*-
# 导入一些python包
import numpy as np
import argparse
import glob
import cv2
import os

# 定义auto_canny函数
def auto_canny(image, sigma=0.33):
	# 计算单通道像素强度的中位数
	v = np.median(image)

	# 选择合适的lower和upper值，然后应用它们
	lower = int(max(0, (1.0 - sigma) * v))
	upper = int(min(255, (1.0 + sigma) * v))
	edged = cv2.Canny(image, lower, upper)

	return edged

# 设置一些需要修改的参数
ap = argparse.ArgumentParser()
ap.add_argument("-i", "--images", required=True, help="path to input dataset of images")
args = vars(ap.parse_args())

# 创建可视化文件夹
file_dir = "vis/"
if not os.path.isdir(file_dir):
    os.makedirs(file_dir)

# 遍历文件夹中的每一张图片
i = 0
img_names = glob.glob(args["images"] + "/*.jpg")
for imagePath in img_names:
   # 读取图片
   image = cv2.imread(imagePath)
   # 灰度化处理
   gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
   # 进行高斯模糊去噪
   blurred = cv2.GaussianBlur(gray, (3, 3), 0)
   
   # 分别使用宽阈值、窄阈值和自动确定的阈值进行测试
   wide = cv2.Canny(blurred, 10, 200)
   tight = cv2.Canny(blurred, 225, 250)
   auto = auto_canny(blurred)
   result = np.hstack([wide, tight, auto])
   i += 1
   
   save_name = "vis/" + str(i) + ".png"
   # 显示并保存结果
   cv2.imshow("Original", image)
   cv2.imshow("Edges", result)
   cv2.imwrite(save_name, result)
   cv2.waitKey(0)
</code></pre> 
<p><strong>运行方法- python auto_canny.py --image 测试文件夹名称</strong></p> 
<h3><a id="_82"></a>六、改进算法效果展示</h3> 
<p><img src="https://images2.imgbox.com/6c/3a/7zLC1L4L_o.png" alt="在这里插入图片描述"><br>   上图展示了该算法在多个测试图片上面的检测效果，第1列表示的是原始的输入图片；第2列表示使用宽阈值后的检测效果；第3列表示使用窄阈值后的检测效果；第4列表示使用自适用阈值后的检测效果。我们可以发现，自动阈值的检测效果在宽阈值和窄阈值之间，整体的效果基本满足我们的要求，但是它带来的好处是我们不在需要进行调参工作，哈哈哈。</p> 
<h3><a id="_86"></a>七、问题探讨</h3> 
<p>  其实本文的思路很简单，主要是应用图片中的统计信息，使用这些统计数据来消除手动调整阈值以进行Canny边缘检测。这个技巧可以节省你的时间参数调整-而且在应用这个功能之后你仍然可以得到一个很好的canny边缘图。具体的实现如下所示：</p> 
<pre><code>def auto_canny(image, sigma=0.33):
	# 计算单通道像素强度的中位数
	v = np.median(image)

	# 选择合适的lower和upper值，然后应用它们
	lower = int(max(0, (1.0 - sigma) * v))
	upper = int(min(255, (1.0 + sigma) * v))
	edged = cv2.Canny(image, lower, upper)

	return edged
</code></pre> 
<h3><a id="_101"></a>参考资料</h3> 
<p>1、<a href="https://www.pyimagesearch.com/2015/04/06/zero-parameter-automatic-canny-edge-detection-with-python-and-opencv/" rel="nofollow">参考链接1</a><br> 2、<a href="https://baike.baidu.com/item/canny%E7%AE%97%E6%B3%95" rel="nofollow">参考链接2</a></p> 
<h3><a id="_105"></a>注意事项</h3> 
<p>[1] 如果您对AI、自动驾驶、AR、ChatGPT等技术感兴趣，欢迎关注我的微信公众号“<strong>AI产品汇</strong>”，有问题可以在公众号中私聊我！<br> [2] 该博客是本人原创博客，如果您对该博客感兴趣，想要转载该博客，请与我联系（qq邮箱：1575262785@qq.com）,我会在第一时间回复大家，谢谢大家的关注。<br> [3] 由于个人能力有限，该博客可能存在很多的问题，希望大家能够提出改进意见。<br> [4] 如果您在阅读本博客时遇到不理解的地方，希望您可以联系我，我会及时的回复您，和您交流想法和意见，谢谢。<br> [5] 本文测试的图片可以通过关注微信公众号<strong>AI产品</strong>汇之后找我索取！<br> <strong>[6] 本人业余时间承接各种本科毕设设计和各种小项目，包括图像处理（数据挖掘、机器学习、深度学习等）、matlab仿真、python算法及仿真等，有需要的请加QQ：1575262785详聊！！！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fce98ecdcbbc3b797e6ed452197a18e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows查询计算机设备序列号、MAC地址和硬盘序列号</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e4db822cd11bc0c5695125a6bd4564f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言程序设计经典例题100道（二）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>