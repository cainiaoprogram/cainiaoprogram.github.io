<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java 注解的几大作用及使用方法详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java 注解的几大作用及使用方法详解" />
<meta property="og:description" content="http://www.tmser.com/?post=34&amp;page=1
java 注解，从名字上看是注释，解释。但功能却不仅仅是注释那么简单。注解（Annotation） 为我们在代码中添加信息提供了一种形式化的方法，是我们可以在稍后某个时刻方便地使用这些数据（通过 解析注解 来使用这些数据），常见的作用有以下几种：
生成文档。这是最常见的，也是java 最早提供的注解。常用的有@see @param @return 等跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量。也是在编译时进行格式检查。如@Override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。 包 java.lang.annotation 中包含所有定义自定义注解所需用到的原注解和接口。如接口 java.lang.annotation.Annotation 是所有注解继承的接口,并且是自动继承，不需要定义时指定，类似于所有类都自动继承Object。
该包同时定义了四个元注解，Documented,Inherited,Target(作用范围，方法，属性，构造方法等),Retention(生命范围，源代码，class,runtime)。下面将在实例中逐个讲解他们的作用，及使用方法。
Inherited : 在您定义注解后并使用于程序代码上时，预设上父类别中的注解并不会被继承至子类别中，您可以在定义注解时加上java.lang.annotation.Inherited 限定的Annotation，这让您定义的Annotation型别被继承下来。注意注解继承只针对class 级别注解有效（这段建议看完全文后在来回顾）。 多说无益，下面就一步步从零开始建一个我们自己的注解。
建第一个注解
package com.tmser.annotation; /** *@interface 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。 *方法的名称就是参数的名称，返回值类型就是参数的类型。 *可以通过default来声明参数的默认值。 *在这里可以看到@Retention和@Target这样的元注解，用来声明注解本身的行为。 *@Retention 用来声明注解的保留策略，有CLASS、RUNTIME和SOURCE这三种， *分别表示注解保存在类文件、JVM运行时刻和源代码中。 *只有当声明为RUNTIME的时候，才能够在运行时刻通过反射API来获取到注解的信息。 *@Target 用来声明注解可以被添加在哪些类型的元素上，如类型、方法和域等。 *就可以定义一个注解了，它将自动继承Annotation */ public @interface TestA { //这里定义了一个空的注解，它能干什么呢。我也不知道，但他能用。 } 在下面这个程序中使用它
package com.tmser.annotation; import java.util.HashMap; import java.util.Map; /** * 这个类专门用来测试注解使用 * @author tmser */ @TestA //使用了类注解 public class UserAnnotation { @TestA //使用了类成员注解 private Integer age; @TestA //使用了构造方法注解 public UserAnnotation(){ } @TestA //使用了类方法注解 public void a(){ @TestA //使用了局部变量注解 Map m = new HashMap(0); } public void b(@TestA Integer a){ //使用了方法参数注解 } } 编译没有报错，ok，一个注解实验完成。这个注解也太简单了吧，好像什么信息也不能传递。别急下面就来一步步完善它，也该四位元注解依次开始上场了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fbbc93a164850bbda0f35c7bff7786bc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-12-03T09:55:50+08:00" />
<meta property="article:modified_time" content="2015-12-03T09:55:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java 注解的几大作用及使用方法详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a target="_blank" href="http://www.tmser.com/?post=34&amp;page=1" rel="nofollow noopener noreferrer" style="color:rgb(51,102,153); text-decoration:none; line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">http://www.tmser.com/?post=34&amp;page=1</span></a></p> 
<p></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">java 注解，从名字上看是注释，解释。但功能却不仅仅是注释那么简单。注解（Annotation） 为我们在代码中添加信息提供了一种形式化的方法，是我们可以在稍后某个时刻方便地使用这些数据（通过 解析注解 来使用这些数据），常见的作用有以下几种：</span></p> 
<ul style="color:rgb(51,51,51); line-height:26px"><li><span style="font-family:Microsoft YaHei; font-size:14px">生成文档。这是最常见的，也是java 最早提供的注解。常用的有@see @param @return 等</span></li><li><span style="font-family:Microsoft YaHei; font-size:14px">跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量。也是</span></li><li><span style="font-family:Microsoft YaHei; font-size:14px">在编译时进行格式检查。如@Override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</span></li></ul> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">包 <strong>java.lang.annotation </strong>中包含所有定义自定义注解所需用到的原注解和接口。如接口 java.lang.annotation.<strong><span style="color:rgb(229,51,51)">Annotation</span></strong> 是所有注解继承的接口,并且是自动继承，不需要定义时指定，类似于所有类都自动继承Object。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">该包同时定义了四个元注解，<strong>Documented</strong>,<strong>Inherited</strong>,<strong>Target</strong>(作用范围，方法，属性，构造方法等),<strong>Retention</strong>(生命范围，源代码，class,runtime)。下面将在实例中逐个讲解他们的作用，及使用方法。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px"><strong>Inherited :</strong> 在您定义注解后并使用于程序代码上时，预设上父类别中的注解并不会被继承至子类别中，您可以在定义注解时加上java.lang.annotation.Inherited 限定的Annotation，这让您定义的Annotation型别被继承下来。<strong>注意注解继承只针对class 级别注解有效</strong>（这段建议看完全文后在来回顾）。 多说无益，下面就一步步从零开始建一个我们自己的注解。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">   <strong>建第一个注解</strong></span></p> 
<p style="color:rgb(51,51,51); line-height:26px"></p> 
<pre><code class="language-java">package com.tmser.annotation;
/**
 *@interface  用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。
 *方法的名称就是参数的名称，返回值类型就是参数的类型。
 *可以通过default来声明参数的默认值。
 *在这里可以看到@Retention和@Target这样的元注解，用来声明注解本身的行为。
 *@Retention  用来声明注解的保留策略，有CLASS、RUNTIME和SOURCE这三种，
 *分别表示注解保存在类文件、JVM运行时刻和源代码中。
 *只有当声明为RUNTIME的时候，才能够在运行时刻通过反射API来获取到注解的信息。
 *@Target  用来声明注解可以被添加在哪些类型的元素上，如类型、方法和域等。
 *就可以定义一个注解了，它将自动继承Annotation
 */
public @interface TestA {
//这里定义了一个空的注解，它能干什么呢。我也不知道，但他能用。
}</code></pre> 
<p></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">在下面这个程序中使用它</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"></p> 
<pre><code class="language-java">package com.tmser.annotation;
 
import java.util.HashMap;
import java.util.Map;
 
/**
 * 这个类专门用来测试注解使用
 * @author tmser
 */
@TestA    //使用了类注解
public class UserAnnotation {
    
    @TestA //使用了类成员注解
    private Integer age;
    
    @TestA //使用了构造方法注解
    public UserAnnotation(){
        
    }

    @TestA //使用了类方法注解
    public void a(){
        @TestA //使用了局部变量注解
        Map m = new HashMap(0);
    }
    
    public void b(@TestA Integer a){ //使用了方法参数注解
    }
}</code></pre> 
<p><br> </p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">编译没有报错，ok，一个注解实验完成。这个注解也太简单了吧，好像什么信息也不能传递。别急下面就来一步步完善它，也该四位元注解依次开始上场了。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">四个元注解分别是：<strong>@Target</strong>,<strong>@Retention</strong>,<strong>@Documented</strong>,<strong>@Inherited</strong> ，再次强调下元注解是java API提供，是专门用来定义注解的注解，其作用分别如下。<br>         @Target 表示该注解用于什么地方，可能的值在枚举类 ElemenetType 中，包括： <br>           ElemenetType.CONSTRUCTOR 构造器声明 <br>           ElemenetType.FIELD 域声明（包括 enum 实例） <br> </span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">          ElemenetType.LOCAL_VARIABLE 局部变量声明</span></p> 
<div style="color:rgb(51,51,51); line-height:26px"> 
 <span style="font-family:Microsoft YaHei; font-size:14px">         <span style="color:rgb(51,127,229)"> </span><span style="color:rgb(51,127,229)">ElemenetT</span><span style="color:rgb(51,127,229)">ype.</span><span style="color:rgb(51,127,229)">ANNOTATION_TYPE 作用于注解</span><span style="color:rgb(51,127,229)">量声明</span><span style="color:rgb(51,127,229)"></span><br> </span> 
</div> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">          ElemenetType.METHOD 方法声明</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">          ElemenetType.PACKAGE 包声明 <br>           ElemenetType.PARAMETER 参数声明 <br>           ElemenetType.TYPE 类，接口（包括注解类型）或enum声明 <br>            <br>      @Retention 表示在什么级别保存该注解信息。可选的参数值在枚举类型 RetentionPolicy 中，包括： <br>           RetentionPolicy.SOURCE 注解将被编译器丢弃 <br>           RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃 <br>           RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。 <br>            <br>       @Documented 将此注解包含在 javadoc 中 ，<span lang="EN-US"><span lang="EN-US"><span lang="EN-US">它代表着此注解会被</span></span><span style="color:windowtext">javadoc</span><span lang="EN-US"><span lang="EN-US">工具提取成文档。在</span></span><span style="color:windowtext">doc</span></span>文档中的内容会因为此注解的信息内容不同而不同。相当与@see,@param 等。<br>        <br>       @Inherited 允许子类继承父类中的注解，例子中补充。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">学习最忌好高骛远，我们就一个一个来实验。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px"><strong>第一个</strong>：@Target，动手在前面我们编写的注解上加上元注解。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"></p> 
<pre><code class="language-java">package com.tmser.annotation;
 
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
/* 
 * 定义注解 Test 
 * 首先使用ElementType.TYPE
 */ 
@Target(ElementType.PACKAGE)  
public @interface TestA {
 
}</code></pre> 
<span style="font-family:Microsoft YaHei; font-size:14px"><br> </span> 
<p></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">ctrl+ s 保存，测试类那边立马出现了一堆错误，除了类注解。我想到这，聪明的你立刻明白了这个元注解的意义了。是不是想当然的偷起懒来了。？难道还有意外？细心的朋友应该发现了，我们的测试类少了一个属性没用，就是ElemenetType.PACKAGE。在我们的注解加上这个属性的元注解后，我们测试程序的元注解全部阵亡，不对，还有一个没加呢，好加上。package 包，想当然是加载 package 前面。即</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"></p> 
<pre><code class="language-java">@TestA package com.tmser.annotation;</code></pre> 
<p></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">什么也报错。这就搞不明白了，不加在这加哪去呢。我也不知道了，不过这是编译错误，我们的eclipse 将错误给我们指出了，就是</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">  Package annotations must be in file package-info.java ，e 文虽然不好，但这个简单的还是难不倒几个人的，package 注解必须定义在 package-info.java 中。package-info 又是什么东西，你百度好了。到此 target 元注解就全部完成了。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">第二个元注解： @Retention 参数 RetentionPolicy。有了前面的经验这个注解理解起来就简单多了，并且幸运的是这个注解还没有特殊的属性值。 简单演示下如何使用：</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"></p> 
<pre><code class="language-java">package com.tmser.annotation;
 
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
/* 
 * 定义注解 Test 
 * 首先使用ElementType.TYPE
 * 运行级别定为 运行时，以便后面测试解析
 */ 
@Target(ElementType.PACKAGE)
@Retention(RetentionPolicy.RUNTIME)
public @interface TestA {
}</code></pre> 
<span style="font-family:Microsoft YaHei; font-size:14px"><br> </span> 
<p></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">第三和第四个元注解就不再举例了。比较简单，也没有值，相信看过上面的解释也就清楚了。下面我们还是继续来深入的探讨下注解的使用。上面的例子都非常简单，注解连属性都没有。ok，下面我们就来定义一个有属性的注解，并在例子程序中获取都注解中定义的值。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">开始之前将下定义属性的规则：</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><strong><span style="font-family:Microsoft YaHei; font-size:14px">        <span style="color:rgb(229,51,51)">@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</span></span></strong></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">代码：</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"></p> 
<pre><code class="language-java">/* 
 * 定义注解 Test 
 * 为方便测试：注解目标为类 方法，属性及构造方法 
 * 注解中含有三个元素 id ,name和 gid; 
 * id 元素 有默认值 0
 */ 
@Target({TYPE,METHOD,FIELD,CONSTRUCTOR})
@Retention(RetentionPolicy.RUNTIME)
public @interface TestA {
    String name();
    int id() default 0;
    Class&lt;Long&gt; gid();
}</code></pre> 
<p></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">下面改下我们的测试类：</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"></p> 
<pre><code class="language-java">package com.tmser.annotation;
 
import java.util.HashMap;
import java.util.Map;
 
/**
 * 这个类专门用来测试注解使用
 * @author tmser
 */
 
@TestA(name="type",gid=Long.class) //类成员注解
public class UserAnnotation {
	
	@TestA(name="param",id=1,gid=Long.class) //类成员注解
	private Integer age;
	
	@TestA (name="construct",id=2,gid=Long.class)//构造方法注解
	public UserAnnotation(){
		
	}
	@TestA(name="public method",id=3,gid=Long.class) //类方法注解
	public void a(){
		Map&lt;String,String&gt; m = new HashMap&lt;String,String&gt;(0);
	}
	
	@TestA(name="protected method",id=4,gid=Long.class) //类方法注解
	protected void b(){
		Map&lt;String,String&gt; m = new HashMap&lt;String,String&gt;(0);
	}
	
	@TestA(name="private method",id=5,gid=Long.class) //类方法注解
	private void c(){
		Map&lt;String,String&gt; m = new HashMap&lt;String,String&gt;(0);
	}
	
	public void b(Integer a){ 
		
	}
}
</code></pre> 
<p></p> 
<pre></pre> 
<span style="font-family:Microsoft YaHei; font-size:14px"></span> 
<p></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">下面到了最重要的一步了，就是如何读取我们在类中定义的注解。只要读取出来了使用的话就简单了。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">jdk1.5 既然增加了注解，肯定就增加了相关读取的api</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">在java.lang.reflect包中新增了AnnotatedElement接口，JDK源码如下：</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"></p> 
<pre><code class="language-java">public interface AnnotatedElement {
	    boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass);
	    &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass);
	    Annotation[] getAnnotations();
	    Annotation[] getDeclaredAnnotations();
}</code></pre> 
<p></p> 
<ul style="color:rgb(51,51,51); line-height:26px"><li><span style="font-family:Microsoft YaHei; font-size:14px">isAnnotationPresent：判断是否标注了指定注解</span></li><li><span style="font-family:Microsoft YaHei; font-size:14px">getAnnotation：获取指定注解，没有则返回null</span></li><li><span style="font-family:Microsoft YaHei; font-size:14px">getAnnotations：获取所有注解，包括继承自基类的，没有则返回长度为0的数组</span></li><li><span style="font-family:Microsoft YaHei; font-size:14px">getDeclaredAnnotations：获取自身显式标明的所有注解，没有则返回长度为0的数组</span></li></ul> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="color:rgb(102,102,0)"><span style="font-family:Microsoft YaHei; font-size:14px"></span></span></p> 
<pre><code class="language-java">package com.tmser.annotation;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
public class ParseAnnotation {
	/**
	 * 简单打印出UserAnnotation 类中所使用到的类注解
	 * 该方法只打印了 Type 类型的注解
	 * @throws ClassNotFoundException
	 */
	public static void parseTypeAnnotation() throws ClassNotFoundException {  
        Class clazz = Class.forName("com.tmser.annotation.UserAnnotation"); 
        
        Annotation[] annotations = clazz.getAnnotations();  
        for (Annotation annotation : annotations) {  
        	TestA testA = (TestA)annotation;
            System.out.println("id= \""+testA.id()+"\"; name= \""+testA.name()+"\"; gid = "+testA.gid());  
        }  
    } 
	/**
	 * 简单打印出UserAnnotation 类中所使用到的方法注解
	 * 该方法只打印了 Method 类型的注解
	 * @throws ClassNotFoundException
	 */
	public static void parseMethodAnnotation(){
		Method[] methods = UserAnnotation.class.getDeclaredMethods();  
        for (Method method : methods) {  
            /* 
             * 判断方法中是否有指定注解类型的注解 
             */  
            boolean hasAnnotation = method.isAnnotationPresent(TestA.class);  
            if (hasAnnotation) {  
                /* 
                 * 根据注解类型返回方法的指定类型注解 
                 */  
            	TestA annotation = method.getAnnotation(TestA.class);  
                System.out.println("method = " + method.getName()  
                        + " ; id = " + annotation.id() + " ; description = "  
                        + annotation.name() + "; gid= "+annotation.gid());  
            }  
        }  
	}
	/**
	 * 简单打印出UserAnnotation 类中所使用到的方法注解
	 * 该方法只打印了 Method 类型的注解
	 * @throws ClassNotFoundException
	 */
	public static void parseConstructAnnotation(){
		Constructor[] constructors = UserAnnotation.class.getConstructors();  
        for (Constructor constructor : constructors) { 
        	/* 
             * 判断构造方法中是否有指定注解类型的注解 
             */  
            boolean hasAnnotation = constructor.isAnnotationPresent(TestA.class);  
            if (hasAnnotation) {  
                /* 
                 * 根据注解类型返回方法的指定类型注解 
                 */  
            	TestA annotation =(TestA) constructor.getAnnotation(TestA.class);  
                System.out.println("constructor = " + constructor.getName()  
                        + " ; id = " + annotation.id() + " ; description = "  
                        + annotation.name() + "; gid= "+annotation.gid());  
            }  
        }  
	}
	
	public static void main(String[] args) throws ClassNotFoundException {
		parseTypeAnnotation();
		parseMethodAnnotation();
		parseConstructAnnotation();
	}
}</code></pre> 
<br> 
<p></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">先别说话，运行：</span></p> 
<pre><code class="language-java">id= "0"; name= "type"; gid = class java.lang.Long
method = c ; id = 5 ; description = private method; gid= class java.lang.Long
method = a ; id = 3 ; description = public method; gid= class java.lang.Long
method = b ; id = 4 ; description = protected method; gid= class java.lang.Long
constructor = com.tmser.annotation.UserAnnotation ; id = 2 ; description = construct; gid= class java.lang.Long</code></pre> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">看到了吧，我们定义的注解都完整的输出了，你要使用哪个，直接拿去用就好了。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">为了不让这篇文章打开太慢，我省略了类属性注解，及参数注解的解析。其实都大同小异。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">另外，我也没有举使用例子。因为我认为好的教程是讲的详细的同时，还会留有扩展。如果我全部写出来，而你只是学习的话，那基本不会自己去动脑了，而是复制粘贴运行一遍完事。</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-family:Microsoft YaHei; font-size:14px">   <strong>最后提醒下</strong>：</span></p> 
<p style="color:rgb(51,51,51); line-height:26px"><strong><span style="font-family:Microsoft YaHei; font-size:14px"><span style="color:rgb(229,51,51)">     </span><span style="color:rgb(229,51,51)">1. 要用好注解，必须熟悉java 的反射机制，从上面的例子可以看出，注解的解析完全依赖于反射。</span></span></strong></p> 
<p style="color:rgb(51,51,51); line-height:26px"><strong><span style="color:rgb(229,51,51)"><span style="font-family:Microsoft YaHei; font-size:14px">     2. 不要滥用注解。平常我们编程过程很少接触和使用注解，只有做设计，且不想让设计有过多的配置时。</span></span></strong></p> 
<p style="color:rgb(51,51,51); line-height:26px"><strong><span style="font-family:Microsoft YaHei; font-size:14px"> 疑问：</span></strong></p> 
<p style="color:rgb(51,51,51); line-height:26px"><span style="font-weight:bold"><span style="font-family:Microsoft YaHei; font-size:14px">      即 <span style="font-weight:normal">ElementType</span>. <span style="font-weight:normal">ANNOTATION_TYPE：注解类型，到底什么作用，我发现即使不使用这个类型，我们自定义的注解也可以用来注释其他注解（eclipse 报错，但仍可以编译，也仍可以在测试类中读取出报错的注解，使用TYPE编译器都不报错），难道只是标示注解是个元注解，<strong><span style="font-weight:normal"><span id="__kindeditor_bookmark_start_4__"></span></span></strong>知道的麻烦告知一下。</span></span></span></p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f92f518c37ad8357423e10586929880f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">获取CheckedListBox选中的项</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/42820955f35e4ffe5d8e94d332b6135e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;11的enum class &amp; enum struct和enum</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>