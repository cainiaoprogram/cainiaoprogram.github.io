<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#基础入门教程-方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#基础入门教程-方法" />
<meta property="og:description" content="目录
C#方法
C# 中定义方法
实例练习
C# 中调用方法
实例练习
实例练习
递归方法调用
实例练习
参数传递
按值传递参数
实例练习
按引用传递参数
实例练习
按输出传递参数
实例练习
实例练习
C#方法 一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个 C# 程序至少有一个带有 Main 方法的类。
要使用一个方法，您需要：
定义方法调用方法 C# 中定义方法 当定义一个方法时，从根本上说是在声明它的结构的元素。在 C# 中，定义方法的语法如下：
&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)
{
Method Body
}
下面是方法的各个元素：
Access Specifier：访问修饰符，这个决定了变量或方法对于另一个类的可见性。Return type：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 void。Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。Parameter list：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。Method body：方法主体，包含了完成任务所需的指令集。 下面的代码片段显示一个函数 FindMax，它接受两个整数值，并返回两个中的较大值。它有 public 访问修饰符，所以它可以使用类的实例从类的外部进行访问。
实例练习 class NumberManipulator { public int FindMax(int num1, int num2) { /* 局部变量声明 */ int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/13e987ae0bd808d8b9154f86e285d668/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-20T12:39:26+08:00" />
<meta property="article:modified_time" content="2022-09-20T12:39:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#基础入门教程-方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="C%23%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#C%23%E6%96%B9%E6%B3%95" rel="nofollow">C#方法</a></p> 
<p id="C%23%20%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#C%23%20%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95" rel="nofollow">C# 中定义方法</a></p> 
<p id="%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0" rel="nofollow">实例练习</a></p> 
<p id="C%23%20%E4%B8%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#C%23%20%E4%B8%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">C# 中调用方法</a></p> 
<p id="%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0" rel="nofollow">实例练习</a></p> 
<p id="%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0" rel="nofollow">实例练习</a></p> 
<p id="%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8" rel="nofollow">递归方法调用</a></p> 
<p id="%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0" rel="nofollow">实例练习</a></p> 
<p id="%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-toc" style="margin-left:40px;"><a href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92" rel="nofollow">参数传递</a></p> 
<p id="%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" rel="nofollow">按值传递参数</a></p> 
<p id="%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0" rel="nofollow">实例练习</a></p> 
<p id="%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" rel="nofollow">按引用传递参数</a></p> 
<p id="%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0" rel="nofollow">实例练习</a></p> 
<p id="%E6%8C%89%E8%BE%93%E5%87%BA%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E6%8C%89%E8%BE%93%E5%87%BA%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" rel="nofollow">按输出传递参数</a></p> 
<p id="%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0" rel="nofollow">实例练习</a></p> 
<p id="%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0" rel="nofollow">实例练习</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="C%23%E6%96%B9%E6%B3%95">C#方法</h2> 
<p><span style="background-color:#ffffff;"><span style="color:#333333;">一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个 C# 程序至少有一个带有 Main 方法的类。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">要使用一个方法，您需要：</span></p> 
<ul><li style="text-align:left;"><span style="color:#0d0016;">定义方法</span></li><li style="text-align:left;"><span style="color:#0d0016;">调用方法</span></li></ul> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h3 id="C%23%20%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95" style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;"><strong><strong>C# 中定义方法</strong></strong></span></h3> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">当定义一个方法时，从根本上说是在声明它的结构的元素。在 C# 中，定义方法的语法如下：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        &lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        {<!-- --></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">                   Method Body</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        }</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">下面是方法的各个元素：</span></p> 
<ul><li style="text-align:left;"><span style="color:#0d0016;"><strong><strong>Access Specifier</strong></strong>：访问修饰符，这个决定了变量或方法对于另一个类的可见性。</span></li><li style="text-align:left;"><span style="color:#0d0016;"><strong><strong>Return type</strong></strong>：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 <strong><strong>void</strong></strong>。</span></li><li style="text-align:left;"><span style="color:#0d0016;"><strong><strong>Method name</strong></strong>：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。</span></li><li style="text-align:left;"><span style="color:#0d0016;"><strong><strong>Parameter list</strong></strong>：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</span></li><li style="text-align:left;"><span style="color:#0d0016;"><strong><strong>Method body</strong></strong>：方法主体，包含了完成任务所需的指令集。</span></li></ul> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">下面的代码片段显示一个函数 <em><em>FindMax</em></em>，它接受两个整数值，并返回两个中的较大值。它有 public 访问修饰符，所以它可以使用类的实例从类的外部进行访问。</span></p> 
<p></p> 
<h4 id="%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0">实例练习</h4> 
<pre><code class="language-cs">class NumberManipulator
{
   public int FindMax(int num1, int num2)
   {
      /* 局部变量声明 */
      int result;

      if (num1 &gt; num2)
         result = num1;
      else
         result = num2;

      return result;
   }
   ...
}</code></pre> 
<h3 style="margin-left:.0001pt;text-align:left;"></h3> 
<h3 id="C%23%20%E4%B8%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95" style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;"><strong><strong>C# 中调用方法</strong></strong></span></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">您可以使用方法名调用方法。下面的实例演示了这点：</span></p> 
<p></p> 
<h4>实例练习</h4> 
<pre><code class="language-cs">using System;

namespace CalculatorApplication
{
   class NumberManipulator
   {
      public int FindMax(int num1, int num2)
      {
         /* 局部变量声明 */
         int result;

         if (num1 &gt; num2)
            result = num1;
         else
            result = num2;

         return result;
      }
      static void Main(string[] args)
      {
         /* 局部变量定义 */
         int a = 100;
         int b = 200;
         int ret;
         NumberManipulator n = new NumberManipulator();

         //调用 FindMax 方法
         ret = n.FindMax(a, b);
         Console.WriteLine("最大值是： {0}", ret );
         Console.ReadLine();
      }
   }
}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">当上面的代码被编译和执行时，它会产生下列结果：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        最大值是： 200</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">您也可以使用类的实例从另一个类中调用其他类的公有方法。例如，方法 <em><em>FindMax</em></em> 属于 <em><em>NumberManipulator</em></em> 类，您可以从另一个类 <em><em>Test</em></em> 中调用它。</span></p> 
<p></p> 
<h4>实例练习</h4> 
<pre><code class="language-cs">using System;

namespace CalculatorApplication
{
    class NumberManipulator
    {
        public int FindMax(int num1, int num2)
        {
            /* 局部变量声明 */
            int result;

            if (num1 &gt; num2)
                result = num1;
            else
                result = num2;

            return result;
        }
    }
    class Test
    {
        static void Main(string[] args)
        {
            /* 局部变量定义 */
            int a = 100;
            int b = 200;
            int ret;
            NumberManipulator n = new NumberManipulator();
            //调用 FindMax 方法
            ret = n.FindMax(a, b);
            Console.WriteLine("最大值是： {0}", ret );
            Console.ReadLine();

        }
    }
}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">当上面的代码被编译和执行时，它会产生下列结果：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        最大值是： 200</span></p> 
<p></p> 
<h3 id="%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">递归方法调用</h3> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">一个方法可以自我调用。这就是所谓的 </span><strong><span style="color:#333333;"><strong>递归</strong></span></strong><span style="color:#333333;">。下面的实例使用递归函数计算一个数的阶乘：</span></span></p> 
<h4 style="margin-left:.0001pt;text-align:left;">实例练习</h4> 
<pre><code class="language-cs">using System;

namespace CalculatorApplication
{
    class NumberManipulator
    {
        public int factorial(int num)
        {
            /* 局部变量定义 */
            int result;

            if (num == 1)
            {
                return 1;
            }
            else
            {
                result = factorial(num - 1) * num;
                return result;
            }
        }
    
        static void Main(string[] args)
        {
            NumberManipulator n = new NumberManipulator();
            //调用 factorial 方法
            Console.WriteLine("6 的阶乘是： {0}", n.factorial(6));
            Console.WriteLine("7 的阶乘是： {0}", n.factorial(7));
            Console.WriteLine("8 的阶乘是： {0}", n.factorial(8));
            Console.ReadLine();

        }
    }
}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">当上面的代码被编译和执行时，它会产生下列结果：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        6 的阶乘是： 720</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        7 的阶乘是： 5040</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">        8 的阶乘是： 40320</span></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h3 id="%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92" style="margin-left:.0001pt;text-align:left;">参数传递</h3> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">当调用带有参数的方法时，您需要向方法传递参数。在 C# 中，有三种向方法传递参数的方式：</span></span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:637px;"><thead><tr><th style="width:128px;">方式</th><th style="width:508px;">描述</th></tr></thead><tbody><tr><td style="width:128px;">值参数</td><td style="width:508px;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#333333;">这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。</span></p> </td></tr><tr><td style="width:128px;">引用参数</td><td style="width:508px;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#333333;">这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。</span></p> </td></tr><tr><td style="width:128px;">输出参数</td><td style="width:508px;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#333333;">这种方式可以返回多个值。</span></p> </td></tr></tbody></table> 
<h4 id="%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" style="margin-left:.0001pt;text-align:left;">按值传递参数</h4> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">这是参数传递的默认方式。在这种方式下，当调用一个方法时，会为每个值参数创建一个新的存储位置。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">实际参数的值会复制给形参，实参和形参使用的是两个不同内存中的值。所以，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。下面的实例演示了这个概念：</span></span></p> 
<h4 style="margin-left:.0001pt;text-align:left;">实例练习</h4> 
<pre><code class="language-cs">using System;
namespace CalculatorApplication
{
   class NumberManipulator
   {
      public void swap(int x, int y)
      {
         int temp;
         
         temp = x; /* 保存 x 的值 */
         x = y;    /* 把 y 赋值给 x */
         y = temp; /* 把 temp 赋值给 y */
      }
      
      static void Main(string[] args)
      {
         NumberManipulator n = new NumberManipulator();
         /* 局部变量定义 */
         int a = 100;
         int b = 200;
         
         Console.WriteLine("在交换之前，a 的值： {0}", a);
         Console.WriteLine("在交换之前，b 的值： {0}", b);
         
         /* 调用函数来交换值 */
         n.swap(a, b);
         
         Console.WriteLine("在交换之后，a 的值： {0}", a);
         Console.WriteLine("在交换之后，b 的值： {0}", b);
         
         Console.ReadLine();
      }
   }
}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">当上面的代码被编译和执行时，它会产生下列结果：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在交换之前，a 的值：100</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在交换之前，b 的值：200</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在交换之后，a 的值：100</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在交换之后，b 的值：200</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">结果表明，即使在函数内改变了值，值也没有发生任何的变化。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h4 id="%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="color:#333333;"><strong>按引用传递参数</strong></span></strong></span></h4> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">引用参数是一个对变量的</span><strong><span style="color:#333333;"><strong>内存位置的引用</strong></span></strong><span style="color:#333333;">。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">在 C# 中，使用 </span><strong><span style="color:#333333;"><strong>ref</strong></span></strong><span style="color:#333333;"> 关键字声明引用参数。下面的实例演示了这点：</span></span></p> 
<h4 style="margin-left:.0001pt;text-align:left;">实例练习</h4> 
<pre><code class="language-cs">using System;
namespace CalculatorApplication
{
   class NumberManipulator
   {
      public void swap(ref int x, ref int y)
      {
         int temp;

         temp = x; /* 保存 x 的值 */
         x = y;    /* 把 y 赋值给 x */
         y = temp; /* 把 temp 赋值给 y */
       }
   
      static void Main(string[] args)
      {
         NumberManipulator n = new NumberManipulator();
         /* 局部变量定义 */
         int a = 100;
         int b = 200;

         Console.WriteLine("在交换之前，a 的值： {0}", a);
         Console.WriteLine("在交换之前，b 的值： {0}", b);

         /* 调用函数来交换值 */
         n.swap(ref a, ref b);

         Console.WriteLine("在交换之后，a 的值： {0}", a);
         Console.WriteLine("在交换之后，b 的值： {0}", b);
 
         Console.ReadLine();

      }
   }
}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">当上面的代码被编译和执行时，它会产生下列结果：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在交换之前，a 的值：100</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在交换之前，b 的值：200</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在交换之后，a 的值：200</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在交换之后，b 的值：100</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">结果表明，<em><em>swap</em></em> 函数内的值改变了，且这个改变可以在 <em><em>Main</em></em> 函数中反映出来。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4 id="%E6%8C%89%E8%BE%93%E5%87%BA%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="color:#333333;"><strong>按输出传递参数</strong></span></strong></span></h4> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">return 语句可用于只从函数中返回一个值。但是，可以使用 </span><strong><span style="color:#333333;"><strong>输出参数</strong></span></strong><span style="color:#333333;"> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">下面的实例演示了这点：</span></span></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">实例练习</span></h4> 
<pre><code class="language-cs">using System;

namespace CalculatorApplication
{
   class NumberManipulator
   {
      public void getValue(out int x )
      {
         int temp = 5;
         x = temp;
      }
   
      static void Main(string[] args)
      {
         NumberManipulator n = new NumberManipulator();
         /* 局部变量定义 */
         int a = 100;
         
         Console.WriteLine("在方法调用之前，a 的值： {0}", a);
         
         /* 调用函数来获取值 */
         n.getValue(out a);

         Console.WriteLine("在方法调用之后，a 的值： {0}", a);
         Console.ReadLine();

      }
   }
}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">当上面的代码被编译和执行时，它会产生下列结果：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在方法调用之前，a 的值： 100</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在方法调用之后，a 的值： 5</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">提供给输出参数的变量不需要赋值。当需要从一个参数没有指定初始值的方法中返回值时，输出参数特别有用。请看下面的实例，来理解这一点：</span></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">实例练习</span></h4> 
<pre><code class="language-cs">using System;

namespace CalculatorApplication
{
   class NumberManipulator
   {
      public void getValues(out int x, out int y )
      {
          Console.WriteLine("请输入第一个值： ");
          x = Convert.ToInt32(Console.ReadLine());
          Console.WriteLine("请输入第二个值： ");
          y = Convert.ToInt32(Console.ReadLine());
      }
   
      static void Main(string[] args)
      {
         NumberManipulator n = new NumberManipulator();
         /* 局部变量定义 */
         int a , b;
         
         /* 调用函数来获取值 */
         n.getValues(out a, out b);

         Console.WriteLine("在方法调用之后，a 的值： {0}", a);
         Console.WriteLine("在方法调用之后，b 的值： {0}", b);
         Console.ReadLine();
      }
   }
}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">当上面的代码被编译和执行时，它会产生下列结果（取决于用户输入）：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        请输入第一个值：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        7</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        请输入第二个值：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        8</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在方法调用之后，a 的值： 7</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#0d0016;">        在方法调用之后，b 的值： 8</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b3e134cf6ede04c0870b8f66e9085cb1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Gstreamer基础讲解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b5374f2637abe6199814089c68703b4b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在 Windows 10 中如何查看系统的激活状态？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>