<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Netty4实现HTTP请求、响应 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Netty4实现HTTP请求、响应" />
<meta property="og:description" content="前言：
我们所编写的项目多以BS为主，用户通过浏览器访问我们的服务器
发送的请求以HTTP请求为主，本例就以Netty4来实现一个接收HTTP请求的服务器，并根据用户请求返回响应
1.Netty中HTTP请求和响应类 请求（FullHttpRequest） /** * Combine the {@link HttpRequest} and {@link FullHttpMessage}, so the request is a &lt;i&gt;complete&lt;/i&gt; HTTP * request. */ public interface FullHttpRequest extends HttpRequest, FullHttpMessage { 可以看到，它结合了HttpRequest、FullHttpMessag，作为一个完整的HTTP请求体。
默认实现为DefaultFullHttpRequest
响应（FullHttpResponse） /** * Combination of a {@link HttpResponse} and {@link FullHttpMessage}. * So it represent a &lt;i&gt;complete&lt;/i&gt; http response. */ public interface FullHttpResponse extends HttpResponse, FullHttpMessage { 同样，它结合了HttpResponse、FullHttpMessage
默认实现为DefaultFullHttpResponse
*
2.Netty中客户端、服务端的编解码器 作为服务端而言：
主要工作就是接收客户端请求，将客户端的请求内容解码；发送响应给客户端，并将发送内容编码
所以，服务端需要两个编解码器
* HttpRequestDecoder(将请求内容解码)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a1ee492f5f74fbe9de5e1d4851557104/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-19T11:25:56+08:00" />
<meta property="article:modified_time" content="2018-11-19T11:25:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Netty4实现HTTP请求、响应</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>前言：<br> 我们所编写的项目多以BS为主，用户通过浏览器访问我们的服务器<br> 发送的请求以HTTP请求为主，本例就以Netty4来实现一个接收HTTP请求的服务器，并根据用户请求返回响应</p> 
<h3><a id="1NettyHTTP_5"></a><strong>1.Netty中HTTP请求和响应类</strong></h3> 
<ul><li>请求（FullHttpRequest）</li></ul> 
<pre><code>/**
 * Combine the {@link HttpRequest} and {@link FullHttpMessage}, so the request is a &lt;i&gt;complete&lt;/i&gt; HTTP
 * request.
 */
public interface FullHttpRequest extends HttpRequest, FullHttpMessage {
</code></pre> 
<p>可以看到，它结合了HttpRequest、FullHttpMessag，作为一个完整的HTTP请求体。<br> 默认实现为DefaultFullHttpRequest</p> 
<ul><li>响应（FullHttpResponse）</li></ul> 
<pre><code>/**
 * Combination of a {@link HttpResponse} and {@link FullHttpMessage}.
 * So it represent a &lt;i&gt;complete&lt;/i&gt; http response.
 */
public interface FullHttpResponse extends HttpResponse, FullHttpMessage {
</code></pre> 
<p>同样，它结合了HttpResponse、FullHttpMessage<br> 默认实现为DefaultFullHttpResponse<br> *</p> 
<h3><a id="2Netty_35"></a><strong>2.Netty中客户端、服务端的编解码器</strong></h3> 
<p><strong>作为服务端而言：</strong><br> 主要工作就是接收客户端请求，将客户端的请求内容解码；发送响应给客户端，并将发送内容编码<br> 所以，服务端需要两个编解码器<br> * HttpRequestDecoder(将请求内容解码)<br> * HttpResponseEncoder(将响应内容编码)</p> 
<p><strong>作为客户端而言：</strong><br> 主要工作就是发送请求给服务端，并将发送内容编码；接收服务端响应，并将接收内容解码；<br> 所以，客户端需要两个编解码器<br> * HttpResponseDecoder（将响应内容解码）<br> * HttpRequestEncoder（将请求内容编码）</p> 
<ul><li></ul> 
<h3><a id="3ServerHandler_50"></a><strong>3.Server端编写Handler类处理客户请求</strong></h3> 
<pre><code>创建Handler，命名为HttpHandler，具体内容如下：
</code></pre> 
<pre><code>import com.alibaba.fastjson.JSONObject;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpVersion;
import io.netty.util.CharsetUtil;
import lombok.Data;

/**
 * 处理HTTP请求
 * @author Administrator
 *
 */
public class HttpHandler extends ChannelInboundHandlerAdapter {

	@Override
	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
	
		if(msg instanceof FullHttpRequest){
			
			FullHttpRequest req = (FullHttpRequest)msg;
			
			try {
				
				// 1.获取URI
				String uri = req.uri();
				
				// 2.获取请求体
				ByteBuf buf = req.content();
				String content = buf.toString(CharsetUtil.UTF_8);
				
				// 3.获取请求方法
				HttpMethod method = req.method();
				
				// 4.获取请求头
				HttpHeaders headers = req.headers();
				
				// 5.根据method，确定不同的逻辑
				if(method.equals(HttpMethod.GET)){
					
					// TODO 
				}
				
				if(method.equals(HttpMethod.POST)){
					// 接收用户输入，并将输入返回给用户
					Content c = new Content();
					c.setUri(uri);
					c.setContent(content);
					
					response(ctx, c);
				}
				
				if(method.equals(HttpMethod.PUT)){
					// TODO 
				}
				
				if(method.equals(HttpMethod.DELETE)){
					// TODO 
				}
			} finally {
				req.release();
			}
		}
	}

	private void response(ChannelHandlerContext ctx, Content c) {

		// 1.设置响应
		FullHttpResponse resp = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,
				HttpResponseStatus.OK, 
				Unpooled.copiedBuffer(JSONObject.toJSONString(c), CharsetUtil.UTF_8));
		
		resp.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/html; charset=UTF-8");
		
		// 2.发送
		// 注意必须在使用完之后，close channel
		ctx.writeAndFlush(resp).addListener(ChannelFutureListener.CLOSE);
	}
}

@Data
class Content{
	String uri;
	String content;
}

</code></pre> 
<p><strong>注意：</strong><br> 在处理过程中，把msg转换为FullHttpRequest，可以获取关于请求的所有内容；<br> 在发送响应时必须要监听CLOSE<br> *</p> 
<h3><a id="4_156"></a><strong>4.测试</strong></h3> 
<ol><li>启动Server类</li><li>使用客户端发送请求<br> 在这里，笔者不单独编写Netty客户端代码，直接使用PostMan来充当客户端发送请求，具体如下：<br> <img src="https://images2.imgbox.com/e0/8a/CMLDRm8x_o.png" alt="在这里插入图片描述"><br> 发送一个post请求，并填写body，点击send，可以看到响应如下所示：<br> <img src="https://images2.imgbox.com/f8/ba/9yxGSq16_o.png" alt="在这里插入图片描述"></li></ol> 
<p><strong>参考：Netty in Action</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/594a46e3b2c7613f5fb2540662b09fe4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Windows 中配置Oracle ODBC驱动（不需要安装客户端）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac0004debefebd8dca00a52ea75ba700/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">xml转json的两种方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>