<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>机器学习笔记：时间序列异常检测 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="机器学习笔记：时间序列异常检测" />
<meta property="og:description" content="1 异常类型 1.1 异常值outlier 给定输入时间序列，异常值是时间戳值其中观测值与该时间序列的期望值不同。
1.2 波动点（Change Point） 给定输入时间序列，波动点是指在某个时间t，其状态在这个时间序列上表现出与t前后的值不同的特性。
1.3 断层异常（Breakout） 时序系统中某一时刻的值比前一时刻的值陡增或者陡降很多，之后形态也发生了改变。
2 常见异常检测方法 2.1 基于统计 首先建立一个数据模型。异常是那些同模型不能完美拟合的对象 eg，数据分布模型可以通过估计概率分布的参数来创建。如果一个对象不能很好地同该模型拟合，即如果它很可能不服从该分布，则它是一个异常 2.1.1 3σ法则 假如分布满足正态分布，那么 (μ−3σ,μ&#43;3σ)区间内的概率为99.74。所以可以认为，当数据分布区间超过这个区间时，即可认为是异常数据。 2.1.2 分位数异常检测 IQR是第三四分位数减去第一四分位数，大于Q3&#43;1.5*IQR之外的数和小于Q1-1.5*IQR的值被认为是异常值。 2.1.3 Grubbs测试 不断从样本中找出outlier的方法 这里的outlier，是指样本中偏离平均值过远的数据 算法流程
样本从小到大排序
求样本的mean和std
计算此时样本的min/max与mean的差距，距离更远的那个为可疑值
求可疑值的z-score (standard score)，如果大于预先设定的Grubbs临界值，那么就是outlier；
对剩余序列不断做1~4步（每次检测一个异常点）
局限性：
它的判断机制是“逐一剔除”，所以每个异常值都要单独计算整个步骤，数据量大吃不消；
需假定数据服从正态分布或近正态分布。
2.2 基于预测 对于单条时序数据，根据其预测出来的时序曲线和真实的数据相比，求出每个点的残差对残差序列建模，利用KSigma或者分位数等方法便可以进行异常检测 2.3 基于距离 2.3.1 k-最近邻 数据对象与最近的k个点的距离之和。很明显，与k个最近点的距离之和越小，异常分越低；与k个最近点的距离之和越大，异常分越大。设定一个距离的阈值，异常分高于这个阈值，对应的数据对象就是异常点。 2.4 基于密度的方法 2.4.1 Local Outlier Factor (LOF) 给每个数据点都分配一个依赖于邻域密度的离群因子 LOF，进而判断该数据点是否为离群点 好处在于可以量化每个数据点的异常程度（outlierness）数据点p的局部相对密度（局部异常因子）为点p邻域内点的平均局部可达密度跟数据 点p的局部可达密度的比值（密度越小，越可能是异常点） 数据点P的局部可达密度=P最近邻的平均可达距离的倒数。距离越大，密度越小。 点O的k近邻距离=第k个最近的点跟点O之间的距离。 整体来说，LOF算法流程如下：
对于每个数据点，计算它与其他所有点的距离，并按从近到远排序；
对于每个数据点，找到它的K-Nearest-Neighbor，计算LOF得分。
2.5 基于聚类的方法 小于某个最小尺寸的所有簇视为异常 2.6 基于树的方法 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2164f6c1ac9634513addf39d6b8a8752/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T17:39:02+08:00" />
<meta property="article:modified_time" content="2024-01-09T17:39:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">机器学习笔记：时间序列异常检测</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1 异常类型</h2> 
<h3>1.1 异常值outlier</h3> 
<p>给定输入时间序列<img alt="\{x_1,\cdots,x_t\}" class="mathcode" src="https://images2.imgbox.com/65/d6/3NpA2WGa_o.png">，异常值是时间戳值其中观测值<img alt="x_t" class="mathcode" src="https://images2.imgbox.com/6d/67/yLcE5fVX_o.png">与该时间序列的期望值<img alt="E(x_t)" class="mathcode" src="https://images2.imgbox.com/a4/1e/FOFZC7IT_o.png">不同。</p> 
<p><img alt="" height="97" src="https://images2.imgbox.com/da/6f/0wN0s7x2_o.png" width="349"></p> 
<h3>1.2 <strong>波动点（Change Point）</strong></h3> 
<p>给定输入时间序列<img alt="\{x_1,\cdots,x_t\}" class="mathcode" src="https://images2.imgbox.com/65/8c/8DB18sfp_o.png">，波动点是指在某个时间t，其状态在这个时间序列上表现出与t前后的值不同的特性。</p> 
<p><img alt="" height="95" src="https://images2.imgbox.com/6d/81/1pZ90i3G_o.png" width="367"></p> 
<h3>1.3 <strong>断层异常（Breakout）</strong> </h3> 
<p>时序系统中某一时刻的值比前一时刻的值陡增或者陡降很多，之后形态也发生了改变。</p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/24/c1/YF3z2eNm_o.png" width="362"></p> 
<h2>2 常见异常检测方法</h2> 
<h3>2.1 基于统计</h3> 
<ul><li>首先建立一个数据模型。异常是那些<span style="color:#fe2c24;"><strong>同模型不能完美拟合的对象</strong></span> 
  <ul><li>eg，数据分布模型可以通过估计概率分布的参数来创建。如果一个对象不能很好地同该模型拟合，即如果它很可能不服从该分布，则它是一个异常</li></ul></li></ul> 
<h4>2.1.1 3σ法则</h4> 
<ul><li>假如分布满足正态分布，那么  (μ−3σ,μ+3σ)区间内的概率为99.74。</li><li>所以可以认为，当数据分布区间超过这个区间时，即可认为是异常数据。</li></ul> 
<p><img alt="" height="397" src="https://images2.imgbox.com/d6/85/p9Osc1xq_o.png" width="511"></p> 
<h4>2.1.2 分位数异常检测</h4> 
<p><img alt="" height="362" src="https://images2.imgbox.com/a0/af/ToL5jJK2_o.png" width="666"></p> 
<ul><li>IQR是第三四分位数减去第一四分位数，大于Q3+1.5*IQR之外的数和小于Q1-1.5*IQR的值被认为是异常值。</li></ul> 
<h4>2.1.3  Grubbs测试</h4> 
<ul><li><span style="color:#fefcd8;"><span style="background-color:#38d8f0;">不断</span></span>从样本中找出outlier的方法 
  <ul><li>这里的outlier，是指样本中偏离平均值过远的数据</li></ul></li><li> <p><strong>算法流程</strong></p> 
  <ol><li> <p>样本从小到大排序</p> </li><li> <p>求样本的mean和std</p> </li><li> <p>计算此时样本的min/max与mean的差距，距离更远的那个为可疑值</p> </li><li> <p>求可疑值的z-score (standard score)，如果大于预先设定的Grubbs临界值，那么就是outlier；</p> </li><li> <p>对剩余序列不断做1~4步（每次检测一个异常点）</p> </li></ol></li><li> <p>局限性：</p> 
  <ol><li> <p>它的判断机制是“逐一剔除”，所以每个异常值都要单独计算整个步骤，数据量大吃不消；</p> </li><li> <p>需假定数据服从正态分布或近正态分布。</p> </li></ol></li></ul> 
<h3>2.2 基于预测</h3> 
<ul><li>对于单条时序数据，根据其预测出来的时序曲线和真实的数据相比，求出每个点的残差</li><li>对残差序列建模，利用KSigma或者分位数等方法便可以进行异常检测</li></ul> 
<p><img alt="" height="441" src="https://images2.imgbox.com/5c/04/QkrKwfXf_o.png" width="420"></p> 
<h3 style="background-color:transparent;">2.3 基于距离</h3> 
<h4>2.3.1 <strong>k-最近邻</strong></h4> 
<ul><li>数据对象与最近的k个点的距离之和。</li><li>很明显，与k个最近点的距离之和越小，异常分越低；与k个最近点的距离之和越大，异常分越大。</li><li>设定一个距离的阈值，异常分高于这个阈值，对应的数据对象就是异常点。</li></ul> 
<h3>2.4 基于密度的方法</h3> 
<p><img alt="" height="427" src="https://images2.imgbox.com/68/7a/kvRpJMLD_o.png" width="517"></p> 
<h4>2.4.1 <strong>Local Outlier Factor (LOF)</strong></h4> 
<ul><li>给每个数据点都分配一个依赖于邻域密度的离群因子 LOF，进而判断该数据点是否为离群点 
  <ul><li>好处在于可以量化每个数据点的异常程度（outlierness）</li></ul></li><li>数据点p的局部相对密度（局部异常因子）为点p邻域内点的平均局部可达密度跟数据 点p的局部可达密度的比值（密度越小，越可能是异常点） 
  <ul><li><img alt="" height="120" src="https://images2.imgbox.com/2f/5d/dwHLiOaR_o.png" width="606"> 
    <ul><li>数据点P的<strong>局部可达密度</strong>=P最近邻的平均可达距离的倒数。距离越大，密度越小。 
      <ul><li><img alt="" height="117" src="https://images2.imgbox.com/87/f1/bMeD20hB_o.png" width="351"></li><li><img alt="" height="462" src="https://images2.imgbox.com/5b/66/mt3Ixqrv_o.png" width="710"></li><li>点O的k近邻距离=第k个最近的点跟点O之间的距离。</li></ul></li></ul></li></ul></li><li> <p>整体来说，LOF算法流程如下：</p> 
  <ul><li> <p>对于每个数据点，计算它与其他所有点的距离，并按从近到远排序；</p> </li><li> <p>对于每个数据点，找到它的K-Nearest-Neighbor，计算LOF得分。</p> </li></ul></li></ul> 
<h3>2.5 基于聚类的方法</h3> 
<ul><li>小于某个最小尺寸的所有簇视为异常</li></ul> 
<h3>2.6 基于树的方法</h3> 
<h4>2.6.1 孤立森林</h4> 
<ul><li> “孤立” (isolation) 指的是 “把异常点从所有样本中孤立出来”</li></ul> 
<p><img alt="" height="337" src="https://images2.imgbox.com/7c/7d/opLCar0n_o.png" width="590"></p> 
<ul><li>用一个随机超平面对一个数据空间进行切割，切一次可以生成两个子空间</li><li>接下来再继续随机选取超平面，来切割第一步得到的两个子空间</li><li>以此循环下去，直到每子空间里面只包含一个数据点为止</li><li>——&gt;可以发现，那些密度很高的簇要被切很多次才会停止切割（每个点都单独存在于一个子空间内，才会停止切割）；但那些分布稀疏的点，大都很早就停到一个子空间内了</li></ul> 
<p></p> 
<ul><li>孤立森林的<strong><span style="color:#fe2c24;">算法思想</span></strong>： 
  <ul><li>异常样本更容易快速落入叶子结点</li><li>或者说，异常样本在决策树上，距离根节点更近</li></ul></li></ul> 
<p></p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/77/9a/5Y3eWPVc_o.png" width="682"></p> 
<ul><li>随机选择m个特征，通过在所选特征的最大值和最小值之间随机选择一个值来分割数据点。</li><li>观察值的划分递归地重复，直到所有的观察值被孤立。</li><li>获得 t 个孤立树后，单棵树的训练就结束了。接下来就可以用生成的孤立树来评估测试数据了，即计算异常分数 s。 
  <ul><li>对于每个样本 x，需要对其综合计算每棵树的结果（异常得分）： 
    <ul><li><img alt="" height="90" src="https://images2.imgbox.com/33/8f/o9Qsvy2s_o.png" width="347"> 
      <ul><li>E(h(x))——样本在这t棵孤立树上路径长度的均值</li><li>c(n)——n个样本构建一个二叉搜索树BST中的末成功搜索平均路径长度 
        <ul><li><img alt="" height="160" src="https://images2.imgbox.com/ac/0c/H1LOLDKJ_o.png" width="635"></li></ul></li></ul></li></ul></li><li>异常得分越大，平均路径长度越小，越容易是孤立点</li></ul></li></ul> 
<p>参考内容：<a href="https://mp.weixin.qq.com/s/9TimTB_ccPsme2MNPuy6uA" rel="nofollow" title="【TS技术课堂】时间序列异常检测">【TS技术课堂】时间序列异常检测</a></p> 
<p><a href="https://mp.weixin.qq.com/s/GMT3SUB3BDRAgGA-C-oCtQ" rel="nofollow" title="时间序列异常检测综述">时间序列异常检测综述</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b580dbfe561a3c7a796677f6ff34e2cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 反射(一)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/aef45a842e0ab3f4b5fb3b8d9642ddb8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Apache ActiveMQ RCE CNVD-2023-69477  CVE-2023-46604</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>