<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s 架构图 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s 架构图" />
<meta property="og:description" content="K8S集群架构：
一个K8S集群是由两大部分组成：
Master节点和Node节点
一.Master节点主要包括API Server、Scheduler、Controller manager、etcd几大组件
1.API Server （提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接和etcd进行交互）
Kubernetes 集群中，API Server 扮演着通信枢纽的位置。API Server 不仅负责和 etcd 交互（其他组件不会直接操作 etcd，只有 API Server 这么做），并切对外提供统一的API调用入口, 所有的交互都是以 API Server 为核心的。API Server 提供了以下的功能：
1).整个集群管理的 API 接口：所有对集群进行的查询和管理都要通过 API 来进行。集群内部的组件(如kubelet)也是通过Apiserver更新和同步数据到etcd中。
2).集群内部各个模块之间通信的枢纽：所有模块之前并不会之间互相调用，而是通过和 API Server 打交道来完成自己那部分的工作。
3).集群安全控制：API Server 提供的验证和授权保证了整个集群的安全。
4).数据中心枢纽: API Server 负责和 Etcd 交互存放集群用到的运行数据。
2.Scheduler （负责对集群内部的资源进行调度，相当于“调度室”。）
Scheduler负责节点资源管理，接收来自kube-apiserver创建Pods的任务，收到任务后它会检索出所有符合该Pod要求的Node节点（通过预选策略和优选策略），开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。
3.Controller manager
controller-manager 作为 k8s 集群的管理控制中心，负责集群内 Node、Namespace、Service、Token、Replication 等资源对象的管理，使集群内的资源对象维持在预期的工作状态。
每一个 controller 通过 api-server 提供的 restful 接口实时监控集群内每个资源对象的状态，当发生故障，导致资源对象的工作状态发生变化，就进行干预，尝试将资源对象从当前状态恢复为预期的工作状态，常见的 controller 有 Namespace Controller、Node Controller、Service Controller、ServiceAccount Controller、Token Controller、ResourceQuote Controller、Replication Controller等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/26f9db5d125b1b79dee24601682793f4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-03T13:51:28+08:00" />
<meta property="article:modified_time" content="2022-01-03T13:51:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s 架构图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="See the source image" src="https://images2.imgbox.com/46/de/nOyMgh6q_o.png"></p> 
<p></p> 
<p>K8S集群架构：<br> 一个K8S集群是由两大部分组成：<br> Master节点和Node节点<br> 一.Master节点主要包括API Server、Scheduler、Controller manager、etcd几大组件</p> 
<p></p> 
<p></p> 
<p><strong>1.API Server</strong> （提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接和etcd进行交互）<br> Kubernetes 集群中，API Server 扮演着通信枢纽的位置。API Server 不仅负责和 etcd 交互（其他组件不会直接操作 etcd，只有 API Server 这么做），并切对外提供统一的API调用入口, 所有的交互都是以 API Server 为核心的。API Server 提供了以下的功能：</p> 
<blockquote> 
 <p>1).整个集群管理的 API 接口：所有对集群进行的查询和管理都要通过 API 来进行。集群内部的组件(如kubelet)也是通过Apiserver更新和同步数据到etcd中。<br> 2).集群内部各个模块之间通信的枢纽：所有模块之前并不会之间互相调用，而是通过和 API Server 打交道来完成自己那部分的工作。<br> 3).集群安全控制：API Server 提供的验证和授权保证了整个集群的安全。<br> 4).数据中心枢纽: API Server 负责和 Etcd 交互存放集群用到的运行数据。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/65/b6/SXPBttls_o.png"></p> 
<p><strong>2.Scheduler</strong> （负责对集群内部的资源进行调度，相当于“调度室”。）</p> 
<blockquote> 
 <p>Scheduler负责节点资源管理，接收来自kube-apiserver创建Pods的任务，收到任务后它会检索出所有符合该Pod要求的Node节点（通过预选策略和优选策略），开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。</p> 
</blockquote> 
<p><strong>3.Controller manager</strong></p> 
<blockquote> 
 <p>controller-manager 作为 k8s 集群的管理控制中心，负责集群内 Node、Namespace、Service、Token、Replication 等资源对象的管理，使集群内的资源对象维持在预期的工作状态。<br> 每一个 controller 通过 api-server 提供的 restful 接口实时监控集群内每个资源对象的状态，当发生故障，导致资源对象的工作状态发生变化，就进行干预，尝试将资源对象从当前状态恢复为预期的工作状态，常见的 controller 有 Namespace Controller、Node Controller、Service Controller、ServiceAccount Controller、Token Controller、ResourceQuote Controller、Replication Controller等。</p> 
</blockquote> 
<p><strong>4.Etcd</strong></p> 
<blockquote> 
 <p>etcd在kubernetes集群是用来存放数据并通知变动的。<br> Kubernetes中没有用到数据库，它把关键数据都存放在etcd中，这使kubernetes的整体结构变得非常简单。在kubernetes中，数据是随时发生变化的，比如说用户提交了新任务、增加了新的Node、Node宕机了、容器死掉了等等，都会触发状态数据的变更。状态数据变更之后呢，Master上的kube-scheduler和kube-controller-manager，就会重新安排工作，它们的工作安排结果也是数据。这些变化，都需要及时地通知给每一个组件。etcd有一个特别好用的特性，可以调用它的api监听其中的数据，一旦数据发生变化了，就会收到通知。有了这个特性之后，kubernetes中的每个组件只需要监听etcd中数据，就可以知道自己应该做什么。kube-scheduler和kube-controller-manager呢，也只需要把最新的工作安排写入到etcd中就可以了，不用自己费心去逐个通知了</p> 
</blockquote> 
<p>二．Node节点主要包括kubelet、kube-proxy模块和pod对象<br><strong>1.Pod</strong></p> 
<blockquote> 
 <p>Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。</p> 
</blockquote> 
<p><strong>2.Kubelet</strong></p> 
<blockquote> 
 <p>运行在每个计算节点上<br> 1).kubelet 组件通过 api-server 提供的接口监测到 kube-scheduler 产生的 pod 绑定事件，然后从 etcd 获取 pod 清单，下载镜像并启动容器。<br> 2).同时监视分配给该Node节点的 pods，周期性获取容器状态，再通过api-server通知各个组件。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/53/a8/PbVuf4Q4_o.png"></p> 
<p><strong>3.kube-proxy</strong></p> 
<blockquote> 
 <p>首先k8s 里所有资源都存在 etcd 中，各个组件通过 apiserver 的接口进行访问etcd来获取资源信息<br> kube-proxy 会作为 daemon（守护进程） 跑在每个节点上通过watch的方式监控着etcd中关于Pod的最新状态信息,它一旦检查到一个Pod资源被删除了或新建或ip变化了等一系列变动，它就立即将这些变动，反应在iptables 或 ipvs规则中，以便之后 再有请求发到service时，service可以通过ipvs最新的规则将请求的分发到pod上</p> 
</blockquote> 
<p>总结：kube-proxy和service的关系：<br> Kube-proxy负责制定数据包的转发策略，并以守护进程的模式对各个节点的pod信息实时监控并更新转发规则，service收到请求后会根据kube-proxy制定好的策略来进行请求的转发，从而实现负载均衡<br> 以上便是我在K8S学习过程中对其中各组件功能及作用的理解的总结，希望对大家有用，有问题的地方欢迎指出，如转载请标明出处。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e181fc0c0b99b37a7bfcf0fa0051f39/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">esp8266显示时间温湿度（WiFi配网）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c4dc69a1e9cdfe72f0a6b60be69b97c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">条件判断语句之if语句</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>