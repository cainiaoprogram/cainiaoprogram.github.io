<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mybatis基本原理与使用详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mybatis基本原理与使用详解" />
<meta property="og:description" content="1.JDBC的缺陷是什么？
1.代码冗余。加载驱动，创建连接对象，数据库操作对象，关闭对象等操作对应每个数据库操作都是一样的。
2.对应ResultSet结果集，我们要遍历他然后手工创建Java对象装入集合，比较麻烦。
3.数据库操作和业务代码混合。
2.Mybatis是什么？为什么要放弃JDBC而使用Mybatis？
Mybatis可以看做增强版jdbc，底层也是用jdbc操作数据库但Mybatis帮我们减轻了开发的复旦。不需要我们重复编写创建Connection，Statement，PreparedStatement，ResultSet对象的代码。不需我们关注这些对象的关闭，自动帮我们关闭。还有自动将ResultSet中的记录封装成java对象的集合返回给我们。让开发者专注于SQL语句的编写。
3.传统Dao方式使用Mybatis操作数据库的基本步骤（未使用动态代理为我们创建Dao接口实现类对象）
1.加入依赖：mybatis依赖，数据库驱动。
2.创建Dao接口，定义操作数据库的方法。
3.创建Dao接口的同名Sql映射文件（Mapper文件）。
4.创建Dao接口实现类：方法中获得SqlSession对象操作数据库。
5.创建主配置文件：配置数据库数据源，mapper文件的位置等。
public interface StudentDao { List&lt;Student&gt; findAll(); } &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; ?&gt; &lt;!DOCTYPE mapper PUBLIC &#34;-//mybatis.org//DTD Mapper 3.0//EN&#34; &#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&#34;&gt; &lt;mapper namespace=&#34;com.zhaojisu.dao.StudentDao&#34;&gt; &lt;select id=&#34;findAll&#34; resultType=&#34;com.zhaojisu.entity.Student&#34;&gt; select name,age from student; &lt;/select&gt; &lt;/mapper&gt; public class StudentDaoImpl implements StudentDao { @Override public List&lt;Student&gt; findAll() { String path=&#34;mybatis.xml&#34;; InputStream stream = Thread.currentThread().getContextClassLoader().getResourceAsStream(path); SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(stream); SqlSession sqlSession = factory.openSession(); List&lt;Student&gt; list = sqlSession." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7817b032679fbf4aae34cc96e9b0d62f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-21T19:35:41+08:00" />
<meta property="article:modified_time" content="2022-03-21T19:35:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mybatis基本原理与使用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.JDBC的缺陷是什么？</p> 
<blockquote> 
 <p>1.代码冗余。加载驱动，创建连接对象，数据库操作对象，关闭对象等操作对应每个数据库操作都是一样的。</p> 
 <p>2.对应ResultSet结果集，我们要遍历他然后手工创建Java对象装入集合，比较麻烦。</p> 
 <p>3.数据库操作和业务代码混合。</p> 
</blockquote> 
<p><span style="color:#fe2c24;">2.Mybatis是什么？为什么要放弃JDBC而使用Mybatis？</span></p> 
<blockquote> 
 <p>Mybatis可以看做增强版jdbc，底层也是用jdbc操作数据库但Mybatis帮我们减轻了开发的复旦。不需要我们重复编写创建Connection，Statement，PreparedStatement，ResultSet对象的代码。不需我们关注这些对象的关闭，自动帮我们关闭。还有自动将ResultSet中的记录封装成java对象的集合返回给我们。让开发者专注于SQL语句的编写。</p> 
</blockquote> 
<p>3.传统Dao方式使用Mybatis操作数据库的基本步骤（未使用动态代理为我们创建Dao接口实现类对象）</p> 
<blockquote> 
 <p>1.加入依赖：mybatis依赖，数据库驱动。</p> 
 <p>2.创建Dao接口，定义操作数据库的方法。</p> 
 <p>3.创建Dao接口的同名Sql映射文件（Mapper文件）。</p> 
 <p>4.创建Dao接口实现类：方法中获得SqlSession对象操作数据库。</p> 
 <p>5.创建主配置文件：配置数据库数据源，mapper文件的位置等。</p> 
</blockquote> 
<pre><code class="language-java">public interface StudentDao {
    List&lt;Student&gt; findAll();
}</code></pre> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.zhaojisu.dao.StudentDao"&gt;
    &lt;select id="findAll" resultType="com.zhaojisu.entity.Student"&gt;
        select name,age from student;
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre> 
<pre><code class="language-java">public class StudentDaoImpl implements StudentDao {
    @Override
    public List&lt;Student&gt; findAll() {
        String path="mybatis.xml";
        InputStream stream = Thread.currentThread().getContextClassLoader().getResourceAsStream(path);
        SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(stream);
        SqlSession sqlSession = factory.openSession();
        List&lt;Student&gt; list = sqlSession.selectList("com.zhaojisu.dao.StudentDao.findAll");
        sqlSession.close();
        return list;
    }
}
</code></pre> 
<pre><code class="language-java">public class test {
    @Test
    public void testSelectAsList(){
        StudentDao studentDao=new StudentDaoImpl();
        List&lt;Student&gt; all = studentDao.findAll();
        all.forEach(a-&gt;{
            System.out.println(a);
        });
    }
}</code></pre> 
<p>4.SqlSessionFactoryBuilder类 SqlSessionFactory 接口 SqlSession 接口  </p> 
<blockquote> 
 <p>SqlSessionFactoryBuilder类 ：SqlSessionFactory 的 创 建 ， 需 要 使 用 SqlSessionFactoryBuilder 对 象 的 build() 方 法 。 由 于 SqlSessionFactoryBuilder 对象在创建完工厂对象后，就完成了其历史使命，即可被销毁。所以，一般会将 该 SqlSessionFactoryBuilder 对象创建为一个方法内的局部对象，方法结束，对象销毁。</p> 
 <p>SqlSessionFactory 接口：SqlSessionFactory 接口对象是一个<span style="color:#fe2c24;">重量级对象</span>（系统开销大的对象），是线程安全的，<span style="color:#fe2c24;">所以一个应用 只需要一个该对象即可</span>。创建 SqlSession 需要使用 SqlSessionFactory 接口的的 openSession()方法。</p> 
 <p>➢ openSession(true)：创建一个有自动提交功能的 SqlSession</p> 
 <p>➢ openSession(false)：创建一个<span style="color:#fe2c24;">非自动提交功能的 SqlSession</span>，需手动提交</p> 
 <p>➢ openSession()：同 openSession(false）</p> 
 <p>SqlSession 接口：SqlSession接口对象用于对数据库进行操作。一个SqlSession对应一次数据库会话，一次会话以SqlSession的创建开始，以SqlSession的关闭结束。SqlSession不是线程安全的，每次使用完都需要关闭它。</p> 
</blockquote> 
<p>5. 传统 Dao 开发方式的分析</p> 
<blockquote> 
 <p>从上面我们自己写的Dao接口实现类中发现，实现类其实没有干什么实质性的工作，核心就通过SqlSession接口的API，根据mapper文件中的namespace和id定位某条sql语句操作数据库。若Dao接口中有多个方法，实现类方法中大部分代码都是冗余的，处理SqlSession调用的API不同。所以可以使用Myabtis动态代理方式为我们创建Dao接口的实现类对象，省略了Dao接口实现类的编写过程，让开发人员关注Mapper文件中Sql语句的编写。</p> 
</blockquote> 
<p>6. SqlSession.getMapper(Class&lt;T&gt; type)</p> 
<pre><code class="language-java">public class AppTest {
    @Test
    public void t() {
        InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream("mybatis.xml");
        SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(in);
        SqlSession sqlSession = factory.openSession();
        StudentDao mapper = sqlSession.getMapper(StudentDao.class);
        System.out.println(mapper);
        List&lt;Student&gt; all = mapper.findAll();
        all.forEach(a-&gt;{
            System.out.println(a);
        });
    }
}</code></pre> 
<blockquote> 
 <p> 方法返回Dao接口实现类的对象。类型为org.apache.ibatis.binding.MapperProxy。采用的是jdk动态代理的方式。mybatis根据传入的Dao接口的字节码，匹配所以mapper文件中的namespace。然后根据mapper文件中的sql语句创建Dao接口的实现类对象。</p> 
</blockquote> 
<p> 7.myabtis为我们创建Dao接口实现类的要求</p> 
<blockquote> 
 <p>1.Mapper文件中&lt;mapper&gt;标签中的namespace为Dao接口的全限定类名。</p> 
 <p>2.Mapper文件中&lt;select&gt;&lt;update&gt;&lt;insert&gt;&lt;delete&gt;标签中id为Dao接口的方法名。</p> 
 <p>3.Dao接口中不能有重载方法的定义。</p> 
 <p>4.Dao接口名和Mapper文件名最好一致，方便我们自己对应。</p> 
</blockquote> 
<p> 8.mybatis传参</p> 
<blockquote> 
 <p>1.<span style="color:#fe2c24;">一个普通类型的参数</span>：#{任意名}</p> 
 <p>         接口中的方法：Student findOne(String name);</p> 
 <p>         sql：&lt;select id="findOne" resultType="com.zhaojisu.entity.Student"&gt;</p> 
 <p>                   select * from student where name=#{aaaa}</p> 
 <p>                 &lt;/select&gt;</p> 
 <p>2.<span style="color:#fe2c24;">多个参数：使用@Param注解</span></p> 
 <p>          接口中的方法：Student findOne2(@Param("name") String name, @Param("age") Integer age);</p> 
 <p>           sql：&lt;select id="findOne2" resultType="com.zhaojisu.entity.Student"&gt;</p> 
 <p>                     select * from student where name=#{name} and age=#{age}</p> 
 <p>                    &lt;/select&gt;</p> 
 <p>3.<span style="color:#fe2c24;">多个参数：使用Java对象传参  #{对象的属性名}</span></p> 
 <p>            接口中的方法：Student findOne3(Student student);</p> 
 <p>            sql：&lt;select id="findOne3" resultType="com.zhaojisu.entity.Student"&gt;</p> 
 <p>                    select * from student where name=#{name} and age=#{age}</p> 
 <p>                    &lt;/select&gt;</p> 
 <p>4.<span style="color:#fe2c24;">多个参数，且参数有java对象，普通类型等：使用@Param注解</span></p> 
 <p><span style="color:#fe2c24;">           </span><span style="color:#0d0016;">接口中的方法：</span>List&lt;Student&gt; selectOne(@Param("age") Integer age, @Param("stu") Student student);</p> 
 <p>           sql：&lt;select id="selectOne" resultType="com.zhaojisu.entity.Student"&gt;</p> 
 <p>                    select * from t_student where age&gt;#{age} or name=#{stu.name};</p> 
 <p>                   &lt;/select&gt;</p> 
 <p>5.按位传参：#{arg0}  #{arg1}.....</p> 
 <p>6.Map&lt;String,Object&gt;集合传参： #{key}</p> 
</blockquote> 
<p>9. ${}</p> 
<blockquote> 
 <p>${}表示字符串替换。使用的是Statement对象。有sql注入的风险。通常用来替换表名或者列名。</p> 
</blockquote> 
<p>10.<span style="color:#fe2c24;"> #与$的区别 面试题</span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">1.#是站位符，底层采用的是PreparedStatement。#{}编译之后变成？。效率高。</span></p> 
 <p><span style="color:#fe2c24;">2.使用#避免了sql注入，比较安全。</span></p> 
 <p><span style="color:#fe2c24;">3.$表示字符串替换，底层采用的是Statement。先将${}表示的字符串拼接然后执行sql。效率低。</span></p> 
 <p><span style="color:#fe2c24;">4.使用$有sql注入的风险，在保证安全的情况下，有时需要进行sql注入。</span></p> 
 <p><span style="color:#fe2c24;">5.$经常用来替换表名，列名。</span></p> 
</blockquote> 
<p>11.resultType </p> 
<blockquote> 
 <p>返回的java对象类型。mybatis在封装结果时，先调用类的无参构造然后将查出的字段的值赋给同名属性。没有则不赋值。</p> 
</blockquote> 
<p>12. resultMap</p> 
<blockquote> 
 <p> 用于当表中字段与类的属性名不一致时，手动将字段对应属性。</p> 
 <pre>&lt;resultMap id="stu" type="com.zhaojisu.entity.Student"&gt;
    &lt;id column="name1" property="name"/&gt;
    &lt;result column="age1" property="age"/&gt;
&lt;/resultMap&gt;</pre> 
 <p>主键字段用id标签，其他用result标签</p> 
</blockquote> 
<p>13 动态Sql:使用动态Sql时，传入的参数要用java对象</p> 
<blockquote> 
 <p>&lt;if test=""&gt; &lt;/if&gt;</p> 
 <p>&lt;select id="selectStudentIf" resultType="com.bjpowernode.domain.Student"&gt;<br>            select id,name,email,age from student where 1=1<br>     &lt;if test="name != null and name !='' "&gt;<br>            and name = #{name}<br>     &lt;/if&gt;<br>     &lt;if test="age &gt; 0 "&gt;<br>             and age &amp;gt; #{age}<br>      &lt;/if&gt;<br> &lt;/select&gt;</p> 
 <p>if容易造成语法错误，所以在后面加一个不影响查询结果且恒成立的条件。</p> 
</blockquote> 
<blockquote> 
 <p> &lt;where&gt;&lt;if&gt;&lt;/if&gt;....&lt;/where&gt;</p> 
 <p>&lt;select id="selectStudentWhere" resultType="com.bjpowernode.domain.Student"&gt;<br>            select id,name,email,age from student<br>  &lt;where&gt;<br>  &lt;if test="name != null and name !='' "&gt;<br>             and name = #{name}<br>  &lt;/if&gt;<br>  &lt;if test="age &gt; 0 "&gt;<br>             and age &amp;gt; #{age}<br>  &lt;/if&gt;<br>  &lt;/where&gt;<br> &lt;/select&gt;</p> 
 <p>使用where标签，在有查询条件时，可以自动添加上 where 子句；没有查询条件时，不会添加 where 子句。需要注意的是，第一个if标签中的 SQL 片断，可以不包含 and。不过，写上 and 也不错， 系统会将多出的 and 去掉。但其它中 SQL 片断的 and，必须要求写上。否则 SQL 语句将拼接出错。</p> 
</blockquote> 
<blockquote> 
 <p>&lt;foreach collection="" item="" open="" close="" spearator=""&gt;</p> 
 <p>&lt;/foreach&gt;</p> 
 <p>&lt;select id="selectStudentForList" <br> resultType="com.bjpowernode.domain.Student"&gt;<br>              select id,name,email,age from student<br>  &lt;if test="list !=null and list.size &gt; 0 "&gt;<br>              where id in<br>  &lt;foreach collection="list" open="(" close=")" <br> item="stuid" separator=","&gt;<br>              #{stuid}<br>  &lt;/foreach&gt;<br>  &lt;/if&gt;<br> &lt;/select&gt;</p> 
 <p>foreach标签一般用于in子句。</p> 
 <p>collection表示参数中的数组或List集合。</p> 
 <p>item表示数组或集合中的一个元素。</p> 
 <p>open表示循环开始前的字符</p> 
 <p>close表示循环结束后的字符</p> 
 <p>spearator表示元素之间的字符。</p> 
</blockquote> 
<blockquote> 
 <p> &lt;sql&gt;&lt;/sql&gt;用于sql语句的复用</p> 
</blockquote> 
<p>14.PageHelper</p> 
<blockquote> 
 <p>PageHelper.startPage(PageNum,PageSize);分页效果只对该方法执行后的第一条查询产生影响。</p> 
 <p>PageHelper分页过程：</p> 
 <p>先count(*)计算查询出来的全部记录数，然后在sql语句后面加入limit ?,?进行分页。</p> 
</blockquote> 
<p>15.mybatis缓存</p> 
<p>一级缓存</p> 
<blockquote> 
 <p>一级缓存是SqlSession级别的，称为本地缓存。默认开启。在同一次会话中使用mybatis会缓存一条查询语句的结果。如果在会话内使用相同的查询语句会直接到缓存里面得到结果。通常，一个事务可视为一个会话。</p> 
</blockquote> 
<p> 二级缓存</p> 
<blockquote> 
 <p>在mapper文件中使用&lt;cache type=""/&gt;标签。type 属性指定的类必须实现 org.apache.ibatis.cache.Cache 接口，且提供一个接受 String 参数作为 id 的构造器。</p> 
 <pre>public interface Cache {
  String getId();
  int getSize();
  void putObject(Object key, Object value);
  Object getObject(Object key);
  boolean hasKey(Object key);
  Object removeObject(Object key);
  void clear();
}</pre> 
</blockquote> 
<p><img alt="" height="315" src="https://images2.imgbox.com/f1/42/Zh8rBGQM_o.png" width="1200"></p> 
<blockquote> 
 <p> select语句自动加入缓存调用Cache接口的putObject方法，inset update delete自动删除缓存调用Cache接口的Clear方法。</p> 
</blockquote> 
<p> 16.cache-ref</p> 
<blockquote> 
 <p>对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新。 但你可能会想要在多个命名空间中共享相同的缓存配置和实例。要实现这种需求，你可以使用 cache-ref 元素来引用另一个缓存。</p> 
 <pre>如&lt;cache-ref namespace="com.someone.application.data.SomeMapper"/&gt;</pre> 
</blockquote> 
<p>17.insert update返回自增主键的值</p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/d7/6e/63vAuXY6_o.png" width="1200"></p> 
<blockquote> 
 <p>insert update标签中有userGeneratedKeys keyProperty keyColum属性</p> 
 <p>userGeneratedKeys表示是否取出数据库内部自增生成的主键。</p> 
 <p>keyProperty指定将取出的主键值赋给传入对象的哪个属性。</p> 
 <p>keyColumn指定哪个字段是主键。</p> 
 <p>insert，update操作的参数必须是java对象。</p> 
</blockquote> 
<p>插入一行 </p> 
<pre><code class="language-XML">&lt;insert id="insertAuthor" useGeneratedKeys="true"
    keyProperty="id"&gt;
  insert into Author (username,password,email,bio)
  values (#{username},#{password},#{email},#{bio})
&lt;/insert&gt;</code></pre> 
<p>插入多行 传入一个 <code>Author</code> 数组或集合，并返回自动生成的主键。</p> 
<pre><code class="language-XML">&lt;insert id="insertAuthor" useGeneratedKeys="true"
    keyProperty="id"&gt;
  insert into Author (username, password, email, bio) values
  &lt;foreach item="item" collection="list" separator=","&gt;
    (#{item.username}, #{item.password}, #{item.email}, #{item.bio})
  &lt;/foreach&gt;
&lt;/insert&gt;</code></pre> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/30ef58fd04c99eff081e03afdb3827db/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">shell脚本-批量gbk转utf-8</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bb403087ec8b5e4e510b27c7cac5cfa5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32CubeMX使用(三)之DMA使用SPI</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>