<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spring cloud stream  RabbitMQ 特性介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spring cloud stream  RabbitMQ 特性介绍" />
<meta property="og:description" content="1. 前言
1.1 概述 “Spring Cloud Stream is a framework for building message-driven microservice applications.”这是来自官方文档对spring cloud sream的介绍，大致可以理解为Spring Cloud Stream 是一个构建消息驱动微服务的框架。
本文档是基于spring-cloud-stream（消息代理）对消息中间件rabbitMQ的支持。
2.使用指南
2.1 前期准备 RabbitMQ的搭建，具体参考http://www.rabbitmq.com/install-windows.html
应用程序通过pom.xml引用核心jar包
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-stream&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
2.2 Spring Cloud Stream 相关概念 Application Model 从上图我们知道spring cloud stream 通过input channels和output channels跟Binder交互，特定Binder在与对应的外部broker节点交互。
Binder Binder 是 Spring Cloud Stream 的一个抽象概念，是应用与消息中间件之间的粘合剂。目前 Spring Cloud Stream 实现了 Kafka 和 Rabbit MQ 的binder。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8fb1eba4ce989332f20eb1764f7024ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-18T12:45:38+08:00" />
<meta property="article:modified_time" content="2018-11-18T12:45:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spring cloud stream  RabbitMQ 特性介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><a name="_Toc530127577"><strong>1. 前言</strong></a></strong></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc530127578"><strong>1.1 </strong></a><strong>概述</strong></strong></h3> 
<p style="margin-left:0cm;">“Spring Cloud Stream is a framework for building message-driven microservice applications.”这是来自官方文档对spring cloud sream的介绍，大致可以理解为Spring Cloud Stream 是一个构建消息驱动微服务的框架。</p> 
<p style="margin-left:0cm;">       本文档是基于spring-cloud-stream（消息代理）对消息中间件rabbitMQ的支持。</p> 
<p><strong><a name="_Toc530127579"><strong>2.使用指南</strong></a></strong></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc530127580"><strong>2.1 </strong></a><strong>前期准备</strong></strong></h3> 
<p style="margin-left:0cm;">         RabbitMQ的搭建，具体参考<a href="http://www.rabbitmq.com/install-windows.html" rel="nofollow">http://www.rabbitmq.com/install-windows.html</a></p> 
<p style="margin-left:0cm;">       应用程序通过pom.xml引用核心jar包</p> 
<p style="margin-left:0cm;">       &lt;dependency&gt;</p> 
<p style="margin-left:0cm;">              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</p> 
<p style="margin-left:0cm;">              &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</p> 
<p style="margin-left:0cm;">       &lt;/dependency&gt;</p> 
<p style="margin-left:0cm;">       &lt;dependency&gt;</p> 
<p style="margin-left:0cm;">              &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</p> 
<p style="margin-left:0cm;">              &lt;artifactId&gt;spring-cloud-stream&lt;/artifactId&gt;</p> 
<p style="margin-left:0cm;">       &lt;/dependency&gt;</p> 
<p style="margin-left:0cm;">       &lt;dependency&gt;</p> 
<p style="margin-left:0cm;">              &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</p> 
<p style="margin-left:0cm;">              &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;</p> 
<p style="margin-left:0cm;">       &lt;/dependency&gt;</p> 
<p style="margin-left:0cm;">       &lt;dependency&gt;</p> 
<p style="margin-left:0cm;">              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</p> 
<p style="margin-left:0cm;">              &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</p> 
<p style="margin-left:0cm;">              &lt;scope&gt;runtime&lt;/scope&gt;</p> 
<p style="margin-left:0cm;">       &lt;/dependency&gt;</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc530127581"><strong>2.2 Spring Cloud Stream </strong></a><strong>相关概念</strong></strong></h3> 
<h4 style="margin-left:0cm;"><strong>Application Model</strong></h4> 
<p><img alt="" class="has" height="310" src="https://images2.imgbox.com/a6/9d/1zEb9cFI_o.png" width="373"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">从上图我们知道spring cloud stream 通过input channels和output channels跟Binder交互，特定Binder在与对应的外部broker节点交互。</p> 
<h4 style="margin-left:0cm;"><strong>Binder</strong></h4> 
<p style="margin-left:0cm;">Binder 是 Spring Cloud Stream 的一个抽象概念，是应用与消息中间件之间的粘合剂。目前 Spring Cloud Stream 实现了 Kafka 和 Rabbit MQ 的binder。</p> 
<p style="margin-left:0cm;">通过 binder ，可以很方便的连接中间件，可以动态的改变消息的<br> destinations（对应于 Kafka 的topic，Rabbit MQ 的 exchanges），这些都可以通过外部配置项来做到。</p> 
<p style="margin-left:0cm;">甚至可以任意的改变中间件的类型而不需要修改一行代码。</p> 
<h4 style="margin-left:0cm;"><strong>Publish-Subscribe</strong></h4> 
<p style="margin-left:0cm;">消息的发布（Publish）和订阅（Subscribe）是事件驱动的经典模式。Spring Cloud Stream 的数据交互也是基于这个思想。生产者把消息通过某个 topic 广播出去（Spring Cloud Stream 中的 destinations）。其他的微服务，通过订阅特定 topic 来获取广播出来的消息来触发业务的进行。</p> 
<p style="margin-left:0cm;">这种模式，极大的降低了生产者与消费者之间的耦合。即使有新的应用的引入，也不需要破坏当前系统的整体结构。</p> 
<h4 style="margin-left:0cm;"><strong>Consumer Groups</strong></h4> 
<p style="margin-left:0cm;">Spring Cloud Stream 的这个分组概念的意思基本和 Kafka 一致。</p> 
<p style="margin-left:0cm;">微服务中通过对同一个应用创建多个实例来达到更高的处理能力是非常必须的。对于这种情况，同一个事件防止被重复消费，只要把这些应用放置于同一个 “group” 中，就能够保证消息只会被其中一个应用消费一次。</p> 
<p style="margin-left:0cm;">通过<span style="color:#6d180b;">spring.cloud.stream.bindings.&lt;channelName&gt;.group=demo</span><span style="color:#6d180b;">这种方式在配置文件中配置。</span></p> 
<h4 style="margin-left:0cm;"><strong>Durability</strong></h4> 
<p style="margin-left:0cm;">消息事件的持久化是必不可少的。Spring Cloud Stream 可以动态的选择一个消息队列是持久化，还是非持久化。</p> 
<h4 style="margin-left:0cm;"><strong>Bindings</strong></h4> 
<p style="margin-left:0cm;">bindings 是我们通过配置把应用和spring cloud stream 的 binder 绑定在一起，之后我们只需要修改 binding 的配置来达到动态修改topic、exchange、type等一系列信息而不需要修改一行代码。</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc530127582"><strong>2.3 </strong></a><strong>基于 </strong><strong>RabbitMQ</strong><strong> </strong><strong>使用</strong></strong></h3> 
<h4 style="margin-left:0cm;"><strong>内置消息发送接收</strong></h4> 
<p style="margin-left:0cm;"><strong>消息接收</strong></p> 
<p style="margin-left:0cm;">Spring Cloud Stream 基本用法，需要定义一个接口，如下是内置的一个接口。</p> 
<pre style="margin-left:0cm;"><span style="color:#000000;">public interface Sink {
     String INPUT = "input";
     @Input("input")
    SubscribableChannel input();
}</span>
<strong>消息接收</strong>
消息的发送同消息的接受，都需要定义一个接口，不同的是接口方法的返回对象是 <strong>MessageChannel</strong>，下面是 Spring Cloud Stream 内置的接口：</pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">public interface Source {<!-- --></span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">    String OUTPUT = "output";</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">    @Output("output")</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">    MessageChannel output();</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">}</span></pre> 
<h4 style="margin-left:0cm;"><strong>自定义消息发送接收</strong></h4> 
<p style="margin-left:0cm;">Spring Cloud Stream 内置了两种接口，分别定义了 binding 为 “input” 的输入流，和 “output” 的输出流，而在我们实际使用中，往往是需要定义各种输入输出流。使用方法也很简单。</p> 
<pre style="margin-left:0cm;"><span style="color:#000000;">public interface ErrorHandlingAppLevel {      </span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">        public static final String ERROR_HANDLING_INPUT = "ErrorHandling-input-appLevel";</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">        public static final String ERROR_HANDLING_OUTPUT = "ErrorHandling-output-appLevel"</span><span style="color:#000000;">；</span>  </pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">        @Input(ERROR_HANDLING_INPUT)</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">        SubscribableChannel input();</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">        @Output(ERROR_HANDLING_OUTPUT)</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">        MessageChannel send();</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">}</span></pre> 
<p style="margin-left:0cm;">一个接口中，可以定义无数个输入输出流，可以根据实际业务情况划分。上述的接口，定义了一个异常输入，和异常输出两个 binding。</p> 
<p style="margin-left:0cm;">使用时，需要在 <strong>@EnableBinding</strong> 注解中，添加自定义的接口<span style="color:#000000;">ErrorHandlingAppLevel</span>。使用 <strong>@StreamListener</strong> 做监听的时候，需要指定 <span style="color:#000000;">ErrorHandlingAppLevel</span><strong>.</strong><span style="color:#000000;"> ERROR_HANDLING_INPUT</span><span style="color:#000000;">，相关配置如下：</span></p> 
<pre style="margin-left:0cm;"><span style="color:#000000;">#--------rabbitMQ</span><span style="color:#000000;">连接配置</span><span style="color:#000000;">---------</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">spring.rabbitmq.host=localhost</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">spring.rabbitmq.port=5672</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">spring.rabbitmq.username=admin</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">spring.rabbitmq.password=admin</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">spring.rabbitmq.virtual-host=/</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">#------------rabbitMQ</span><span style="color:#000000;">分组</span><span style="color:#000000;">-----------------</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">spring.cloud.stream.bindings.ErrorHandling-output-appLevel.destination=ErrorHandling-input-appLevel</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">spring.cloud.stream.bindings.ErrorHandling-input-appLevel.group=demo1 </span></pre> 
<h4 style="margin-left:0cm;"><strong>Message ttl（Time to Live）消息过期</strong></h4> 
<pre style="margin-left:0cm;"><span style="color:#000000;">#</span><span style="color:#000000;">配置文件中加上如下配置，设置队列中消息的过期时间为一分钟</span><span style="color:#000000;">spring.cloud.stream.rabbit.bindings.ErrorHandling-input-appLevel.consumer.ttl=60000</span></pre> 
<p style="margin-left:0cm;">可以设置ErrorHandling-input-appLevel为这个队列中的消息过期时间为1分钟，当超过1分钟还没消费，则自动丢弃。如下图，设置了过期的队列会加上ttl.如下图所示。</p> 
<p style="margin-left:0cm;"></p> 
<h4 style="margin-left:0cm;"><strong>Consumer<span style="color:#000000;"> Groups(</span><span style="color:#000000;">广播防重复消费</span><span style="color:#000000;">)</span></strong></h4> 
<pre style="margin-left:0cm;"><span style="color:#000000;">通过在配置文件加上如下配置，可以指订队列的分组</span><span style="color:#000000;">spring.cloud.stream.bindings.ErrorHandling-input-appLevel.group=demo</span></pre> 
<p style="margin-left:0cm;">不同应用订阅统一组（group）消息，只会发给组里的一个应用。针对集群，一个应用多个实例，可以把多个实例放到一个组里，这样保证广播一个应用重复消费。</p> 
<h4 style="margin-left:0cm;"><strong>concurrency并发收消息</strong></h4> 
<p style="margin-left:0cm;">这些属性通过org.springframework.cloud.stream.binder.ConsumerProperties声明，默认是1</p> 
<pre style="margin-left:0cm;"><span style="color:#000000;">#</span><span style="color:#000000;">配置文件配置如下</span></pre> 
<pre style="margin-left:0cm;"><span style="color:#000000;">spring.cloud.stream.bindings.input.consumer.concurrency=3</span></pre> 
<h4 style="margin-left:0cm;"><strong>transacted事务通道</strong></h4> 
<p style="margin-left:0cm;">当需要使用事务通道的时候，通过如下配置,默认情况下为false</p> 
<pre style="margin-left:0cm;"><span style="color:#000000;">spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer. transacted =true</span></pre> 
<h4 style="margin-left:0cm;"><strong>Error Handling（异常处理）</strong></h4> 
<p><strong><span style="color:#000000;">异常消息重试消费</span></strong></p> 
<p style="margin-left:0cm;">异常尝试机制，通过ConsumerProperties类中声明，默认3次</p> 
<pre style="margin-left:0cm;"><span style="color:#000000;">#</span><span style="color:#000000;">配置文件如下</span><span style="color:#000000;">spring.cloud.stream.bindings.ErrorHandling-input-appLevel.consumer.max-attempts=2</span></pre> 
<p><strong><span style="color:#000000;">Drop Failed Messages</span><span style="color:#000000;">（丢弃失败消息）</span></strong></p> 
<p style="margin-left:0cm;">默认情况下，系统错误，消息被丢弃。</p> 
<p><strong><span style="color:#000000;">DLQ - Dead Letter Queue</span><span style="color:#000000;">（死信队列）</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">DLQ</span><span style="color:#333333;">允许失败消息被发送到指定目的地</span><span style="color:#333333;">---</span><em> Dead Letter Queue.</em></p> 
<pre style="margin-left:0cm;">#通过在配置文件中设置，<span style="color:#000000;">spring.cloud.stream.rabbit.bindings.input.consumer.auto-bind-dlq=true</span></pre> 
<pre style="margin-left:0cm;">备注：input对应input chanel名</pre> 
<p style="margin-left:0cm;"><span style="color:#000000;">#死信队列</span> <span style="color:#000000;">消息存放时间</span> <span style="color:#000000;">，最好不要设置不然消息将会丢弃</span></p> 
<pre style="margin-left:0cm;"><span style="color:#000000;">#spring.cloud.stream.rabbit.bindings.ErrorHandling-input-appLevel.consumer.dlqTtl=60000</span></pre> 
<pre style="margin-left:0cm;">#如下配置，该值为false如果设置了死信队列，消息对原封不动的发送到死信队列，如果为true，则消息对带上错误信息发送至死信队列</pre> 
<pre style="margin-left:0cm;">spring.cloud.stream.rabbit.bindings.ErrorHandling-input-appLevel.consumer.republishToDlq=true </pre> 
<pre style="margin-left:0cm;">#默认false，只能抛AmqpRejectAndDontRequeueException消息才能到死信队列，如果为true，所有错误消息都会抛到死信队列</pre> 
<pre style="margin-left:0cm;">#spring.cloud.stream.rabbit.bindings.ErrorHandling-input-appLevel.consumer.requeueRejected=true
</pre> 
<p><strong><a name="_Toc530127583"><strong>3. 参考资料</strong></a></strong></p> 
<p>Spring-cloud-stream官网：http://cloud.spring.io/spring-cloud-static/spring-cloud-stream/Fishtown.RC1/single/spring-cloud-stream.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c6a0e9a37318ccf96b8d9126813f08a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">图像处理之FAST特征点检测算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7cc00a5b996bbe9cd567d9601836e5c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据学习笔记之spark及spark streaming----快速通用计算引擎</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>