<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java使用bouncycastle加解密 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java使用bouncycastle加解密" />
<meta property="og:description" content="jdk默认带了一些常见的加解密方式，当我们常见的加解密不能满足时，就需要用到一些第三方的库了，bouncycastle就是其中一种。
但是bouncycastle文档比较少。简单介绍一下写法
1.导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.69&lt;/version&gt; &lt;/dependency&gt; 2.写代码 常见的有两种方式，一种使用BouncyCastleProvider，另一种使用BlockCipherEngine
BouncyCastleProvider使用方式跟原生jdk类似，多数getInstance的地方指定一下provider就行
BouncyCastleProvider方式DES加解密代码如下
package com.vvvtimes.demo.util.endecrypt; import lombok.extern.slf4j.Slf4j; import org.bouncycastle.jce.provider.BouncyCastleProvider; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.DESKeySpec; import javax.crypto.spec.IvParameterSpec; import java.security.Key; import java.security.NoSuchAlgorithmException; @Slf4j public class BcDesUtil { private static final BouncyCastleProvider provider; //BouncyCastle与JDK加解密类区别 //KeyFactory.getInstance(&#34;RSA&#34;); &#43;provider--&gt;KeyFactory.getInstance(&#34;RSA&#34;, provider) //Cipher.getInstance(&#34;RSA&#34;); &#43;provider--&gt;Cipher.getInstance(&#34;RSA&#34;, provider) //Signature.getInstance(&#34;SHA1withRSA&#34;); &#43;provider--&gt;Signature.getInstance(&#34;SHA1withRSA&#34;, provider); //KeyGenerator.getInstance(&#34;DES&#34;) ; &#43;provider--&gt;KeyGenerator.getInstance(&#34;DES&#34;, provider); 或者KeyGenerator.getInstance(&#34;DES&#34;,&#34;BC&#34;) /** * 偏移变量，固定占8位字节 */ private final static String IV_PARAMETER = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d96263cd47f400c0107caa669c448c55/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-06T22:20:02+08:00" />
<meta property="article:modified_time" content="2023-11-06T22:20:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java使用bouncycastle加解密</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>jdk默认带了一些常见的加解密方式，当我们常见的加解密不能满足时，就需要用到一些第三方的库了，bouncycastle就是其中一种。</p> 
<p>但是bouncycastle文档比较少。简单介绍一下写法</p> 
<h2>1.导入依赖</h2> 
<pre><code>   &lt;dependency&gt;
            &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
            &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;
            &lt;version&gt;1.69&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<h2>2.写代码</h2> 
<p>常见的有两种方式，一种使用BouncyCastleProvider，另一种使用BlockCipherEngine</p> 
<p>BouncyCastleProvider使用方式跟原生jdk类似，多数getInstance的地方指定一下provider就行</p> 
<p>BouncyCastleProvider方式DES加解密代码如下</p> 
<pre><code>package com.vvvtimes.demo.util.endecrypt;

import lombok.extern.slf4j.Slf4j;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import javax.crypto.spec.IvParameterSpec;
import java.security.Key;
import java.security.NoSuchAlgorithmException;

@Slf4j
public class BcDesUtil {

    private static final BouncyCastleProvider provider;

    //BouncyCastle与JDK加解密类区别
    //KeyFactory.getInstance("RSA"); +provider--&gt;KeyFactory.getInstance("RSA", provider)
    //Cipher.getInstance("RSA");  +provider--&gt;Cipher.getInstance("RSA", provider)
    //Signature.getInstance("SHA1withRSA"); +provider--&gt;Signature.getInstance("SHA1withRSA", provider);
    //KeyGenerator.getInstance("DES") ; +provider--&gt;KeyGenerator.getInstance("DES", provider); 或者KeyGenerator.getInstance("DES","BC")

    /**
     * 偏移变量，固定占8位字节
     */
    private final static String IV_PARAMETER = "12345678";

    /*
     * 生成key
     */
    public byte[] generateKey() {
        KeyGenerator keyGenerator = null;
        try {
            keyGenerator = KeyGenerator.getInstance("DES",provider);
            keyGenerator.init(56);
            SecretKey secretKey = keyGenerator.generateKey();
            byte[] encoded = secretKey.getEncoded();
            return encoded;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return null;
    }


    /**
     * 生成key
     *
     * @param password 密钥字符串
     * @return 密钥对象
     * @throws Exception
     */
    private static Key convertKey(byte[] password) throws Exception {
        DESKeySpec dks = new DESKeySpec(password);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES",provider);
        return keyFactory.generateSecret(dks);
    }

    /**
     * DES加密
     */
    public static byte[] encrypt(byte[] data, byte[] password) {
        if (password == null || password.length &lt; 8) {
            throw new RuntimeException("加密失败，key不能小于8位");
        }
        if (data == null)
            return null;
        try {
            Key secretKey = convertKey(password);
            Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding",provider);
            IvParameterSpec iv = new IvParameterSpec(IV_PARAMETER.getBytes("utf-8"));
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);
            byte[] bytes = cipher.doFinal(data);
            return bytes;
        } catch (Exception e) {
            e.printStackTrace();
            return data;
        }
    }

    /**
     * DES解密解密字符串
     */
    public static byte[] decrypt(byte[] data, byte[] password) {
        if (password == null || password.length &lt; 8) {
            throw new RuntimeException("加密失败，key不能小于8位");
        }
        if (data == null)
            return null;
        try {
            Key secretKey = convertKey(password);
            Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding",provider);
            IvParameterSpec iv = new IvParameterSpec(IV_PARAMETER.getBytes("utf-8"));
            cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);
            byte[] bytes = cipher.doFinal(data);
            return bytes;
        } catch (Exception e) {
            e.printStackTrace();
            return data;
        }
    }

    /**
     * byte数组转十六进制
     *
     * @param bytes
     * @return
     */
    public static String byte2HexString(byte[] bytes) {
        StringBuilder hex = new StringBuilder();
        if (bytes != null) {
            for (Byte b : bytes) {
                hex.append(String.format("%02X", b.intValue() &amp; 0xFF));
            }
        }
        return hex.toString();
    }

    //测试
    public static void main(String[] args) throws Exception {
        String source = "admin测试信息1234!@#$%^&amp;*()_+";
        System.out.println("原  文: " + source);
        String password = "lw112190@2023";
        byte[] encryptDataBytes = encrypt(source.getBytes("utf-8"), password.getBytes("utf-8"));
        String encryptData = byte2HexString(encryptDataBytes);
        System.out.println("加密后: " + encryptData);
        byte[] decryptDataBytes = decrypt(encryptDataBytes, password.getBytes("utf-8"));
        String decryptData = new String(decryptDataBytes, "utf-8");
        ;
        System.out.println("解密后: " + decryptData);
    }

    static {
        provider = new BouncyCastleProvider();
    }
}
</code></pre> 
<p>BlockCipherEngine方式的DES加解密代码如下</p> 
<pre><code>package com.vvvtimes.demo.util.endecrypt;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.BufferedBlockCipher;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.engines.DESEngine;
import org.bouncycastle.crypto.modes.CBCBlockCipher;
import org.bouncycastle.crypto.paddings.PKCS7Padding;
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
import org.bouncycastle.crypto.params.DESParameters;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;

public class BcDesEngineUtil {

    private final static BlockCipher engine;
    private static final BouncyCastleProvider provider;

    /**
     * 偏移变量，固定占8位字节
     */
    private final static String IV_PARAMETER = "12345678";

    /**
     * 生成key
     *
     * @param password 密钥字符串
     * @return 密钥对象
     * @throws Exception
     */
    private static byte[] convertKeyEncoded(byte[] password) {
        byte[] result = null;
        try {
            DESKeySpec dks  = new DESKeySpec(password);
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES",provider);
            SecretKey secretKey = keyFactory.generateSecret(dks);
            return secretKey.getEncoded();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return result;

    }

    private static byte[] encrypt( byte[] ptBytes,byte[] key) throws InvalidCipherTextException, UnsupportedEncodingException {
        BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(engine), new PKCS7Padding());
        cipher.init(true, new ParametersWithIV(new DESParameters(key), IV_PARAMETER.getBytes("utf-8")));
        byte[] rv = new byte[cipher.getOutputSize(ptBytes.length)];
        int tam = cipher.processBytes(ptBytes, 0, ptBytes.length, rv, 0);

        cipher.doFinal(rv, tam);
        return rv;
    }


    private static byte[] decrypt( byte[] cipherText,byte[] key) throws InvalidCipherTextException, UnsupportedEncodingException {
        BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(engine), new PKCS7Padding());
        cipher.init(false, new ParametersWithIV(new DESParameters( key),IV_PARAMETER.getBytes("utf-8")));
        byte[] rv = new byte[cipher.getOutputSize(cipherText.length)];
        int tam = cipher.processBytes(cipherText, 0, cipherText.length, rv, 0);
        cipher.doFinal(rv, tam);
        return rv;
    }

    /**
     * byte数组转十六进制
     *
     * @param bytes
     * @return
     */
    public static String byte2HexString(byte[] bytes) {
        StringBuilder hex = new StringBuilder();
        if (bytes != null) {
            for (Byte b : bytes) {
                hex.append(String.format("%02X", b.intValue() &amp; 0xFF));
            }
        }
        return hex.toString();
    }

    //测试
    public static void main(String[] args) throws Exception {
        String source = "admin测试信息1234!@#$%^&amp;*()_+";
        System.out.println("原  文: " + source);
        String password = "lw112190@2023";
        //String password ="geffzhan";
        //String password ="lw112190";
        byte[] keyEncoded = convertKeyEncoded(password.getBytes("utf-8"));

        byte[] encryptDataBytes = encrypt(source.getBytes("utf-8"), keyEncoded);
        String encryptData = byte2HexString(encryptDataBytes);
        System.out.println("加密后: " + encryptData);
        byte[] decryptDataBytes = decrypt(encryptDataBytes, keyEncoded);
        String decryptData = new String(decryptDataBytes, "utf-8");
        ;
        System.out.println("解密后: " + decryptData);
        /*
         *原  文: admin测试信息1234!@#$%^&amp;*()_+
        加密后: 1D5C21B694A9085A69BE7EA37C197D1632239545298613B944C3AC272750A519F66FB43EFEC55C89
        解密后: admin测试信息1234!@#$%^&amp;*()_+
         */
    }

    static {
        engine = new DESEngine();
        provider = new BouncyCastleProvider();
    }

}
</code></pre> 
<h2>3.其他示例</h2> 
<p>AES加解密</p> 
<pre><code>package com.vvvtimes.demo.util.endecrypt;

import lombok.extern.slf4j.Slf4j;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.AlgorithmParameters;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidParameterSpecException;

@Slf4j
public class BcAesUtil {

    private static final BouncyCastleProvider provider;

    /**
     * 偏移变量，固定占8位字节
     */
    private final static String IV_PARAMETER = "1234567890123456";

    /**
     * AES加密
     */
    public static byte[] encrypt(byte[] data, byte[] password, byte[] iv) {
        if (data == null)
            return null;
        try {
            Key secretKey = new SecretKeySpec(password,"AES");
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding",provider);
            AlgorithmParameters generateIV = generateIV(iv);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, generateIV);
            byte[] bytes = cipher.doFinal(data);
            return bytes;
        } catch (Exception e) {
            e.printStackTrace();
            return data;
        }
    }

    /**
     * AES解密解密字符串
     */
    public static byte[] decrypt(byte[] data, byte[] password, byte[] iv) {
        if (data == null)
            return null;
        try {
            Key secretKey = new SecretKeySpec(password,"AES");
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding",provider);
            AlgorithmParameters generateIV = generateIV(iv);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, generateIV);
            byte[] bytes = cipher.doFinal(data);
            return bytes;
        } catch (Exception e) {
            e.printStackTrace();
            return data;
        }
    }

   public static AlgorithmParameters generateIV(byte[] iv){
       AlgorithmParameters params = null;
       try {
           params = AlgorithmParameters.getInstance("AES");
           params.init(new IvParameterSpec(iv));
       } catch (NoSuchAlgorithmException | InvalidParameterSpecException e) {
           e.printStackTrace();
       }
       return params;

    }

    /**
     * byte数组转十六进制
     *
     * @param bytes
     * @return
     */
    public static String byte2HexString(byte[] bytes) {
        StringBuilder hex = new StringBuilder();
        if (bytes != null) {
            for (Byte b : bytes) {
                hex.append(String.format("%02X", b.intValue() &amp; 0xFF));
            }
        }
        return hex.toString();
    }

    //测试
    public static void main(String[] args) throws Exception {
        String source = "admin测试信息1234!@#$%^&amp;*()_+";
        System.out.println("原  文: " + source);
        String password = "passwordpassword";
        byte[] encryptDataBytes = encrypt(source.getBytes("utf-8"), password.getBytes("utf-8"),IV_PARAMETER.getBytes("utf-8"));
        String encryptData = byte2HexString(encryptDataBytes);
        System.out.println("加密后: " + encryptData);
        byte[] decryptDataBytes = decrypt(encryptDataBytes, password.getBytes("utf-8"),IV_PARAMETER.getBytes("utf-8"));
        String decryptData = new String(decryptDataBytes, "utf-8");
        System.out.println("解密后: " + decryptData);
    }

    static {
        provider = new BouncyCastleProvider();
    }
}
</code></pre> 
<p>RSA私钥解密 签名</p> 
<pre><code>package com.vvvtimes.demo.util.endecrypt;

import cn.hutool.core.codec.Base64;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.nio.charset.Charset;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;

public class BcRsaUtil {
    private static final BouncyCastleProvider provider;




    private static PrivateKey getPrivateKey(String pkcs8Key) {

        byte[] pkcs8Keybytes = Base64.decode(pkcs8Key.getBytes(Charset.forName("UTF-8")));
        final PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(pkcs8Keybytes);
        try {
            return KeyFactory.getInstance("RSA", provider).generatePrivate(pkcs8EncodedKeySpec);
        } catch (Exception ex) {
            ex.printStackTrace();
            return null;
        }
    }

    /**
     * RSA私钥解密
     *
     * @param inputByte 待解密字节数组
     * @param pkcs8Key  私钥
     * @return 明文
     */
    public static byte[] decrypt(byte[] inputByte, String pkcs8Key) {
        byte[] outputeByte = null;
        try {
            PrivateKey privateKey = getPrivateKey(pkcs8Key);
            //RSA解密
            Cipher cipher = Cipher.getInstance("RSA", provider);
            cipher.init(Cipher.DECRYPT_MODE, privateKey);
            outputeByte = cipher.doFinal(inputByte);

        } catch (NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException | NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return outputeByte;
    }

    public static byte[] sign(final byte[] array, String pkcs8Key) {
        try {
            PrivateKey privateKey = getPrivateKey(pkcs8Key);
            final Signature instance = Signature.getInstance("SHA1withRSA", provider);
            instance.initSign(privateKey);
            instance.update(array);
            return instance.sign();
        } catch (GeneralSecurityException ex) {
            throw new RuntimeException("License Server installation error 0000000F2", ex);
        }
    }

    static {
        provider = new BouncyCastleProvider();
    }
}
</code></pre> 
<p>实际上bouncycastle还支持部分国密算法，这一部分不用自己写实现了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ff97677af12ef9d7ba8c6b0a549b0438/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows操作系统TIME_WAIT状态的TCP连接快速回收时间（性能测试时端口不够用）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/332c0ceea372e07c7c98765cce528b1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于单片机的全自动洗衣机模拟系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>