<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android中的View的事件分发机制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android中的View的事件分发机制" />
<meta property="og:description" content="一.事件分发的基础概念：
1.事件分发的本质：
将点击事件（MotionEvent）传递到某个具体的View或者ViewGroup处理的过程。
2.事件的类型：
这里的事件指的就是点击事件（MotionEvent），主要分为以下几个类型：
（1）ACTION_DOWN:手指刚碰到屏幕的时候；
（2）ACTION_UP:手指离开屏幕的时候；
（3）ACTION_CANCEL：结束事件的时候（子View处理事件的过程中，父View拦截事件，收回处理权，此时的子View会收到这个事件）；
（4）ACTION_MOVE:手指在屏幕上进行滑动的时候；
3.事件分发的方法：
（1）dispatchTouchEvent（）：分发点击事件；
（2）onTouchEvent（）：处理点击事件；
（3）onInterceptTouchEvent（）：拦截某个事件；
4.事件分发方法的调用：
（1）dispatchTouchEvent（）：当点击事件能够传递给当前的View的时候调用；
（2）onTouchEvent（）：在dispatchTouchEvent（）方法的内部调用；
（3）onInterceptTouchEvent（）：在ViewGroup的diapatchTouchEvent（）方法的内部调用；
5.事件分发方法的图解：
6.事件分发的流程：
Activity-&gt;ViewGroup-&gt;View
二.事件分发的具体分析：
1.Activity的事件分发机制：
（1）源码分析：
/** *Activity的dispatchTouchEvent */ public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } /** *Activity的onUserInteraction *为一个空方法 */ public void onUserInteraction() { } /** *Window的superDispatchTouchEvent *为一个抽象方法 */ public abstract boolean superDispatchTouchEvent(MotionEvent event); /** *PhoneWindow的superDispatchTouchEvent *PhoneWindow为Window的实现类 */ @Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2ea3079224c79de3e71bb6509f6b5fc7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-23T15:00:27+08:00" />
<meta property="article:modified_time" content="2023-09-23T15:00:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android中的View的事件分发机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一.事件分发的基础概念：</p> 
<p>1.事件分发的本质：</p> 
<p>将点击事件（MotionEvent）传递到某个具体的View或者ViewGroup处理的过程。</p> 
<p>2.事件的类型：</p> 
<p>这里的事件指的就是点击事件（MotionEvent），主要分为以下几个类型：</p> 
<p>（1）ACTION_DOWN:手指刚碰到屏幕的时候；</p> 
<p>（2）ACTION_UP:手指离开屏幕的时候；</p> 
<p>（3）ACTION_CANCEL：结束事件的时候（子View处理事件的过程中，父View拦截事件，收回处理权，此时的子View会收到这个事件）；</p> 
<p>（4）ACTION_MOVE:手指在屏幕上进行滑动的时候；</p> 
<p>3.事件分发的方法：</p> 
<p>（1）dispatchTouchEvent（）：分发点击事件；</p> 
<p>（2）onTouchEvent（）：处理点击事件；</p> 
<p>（3）onInterceptTouchEvent（）：拦截某个事件；</p> 
<p>4.事件分发方法的调用：</p> 
<p>（1）dispatchTouchEvent（）：当点击事件能够传递给当前的View的时候调用；</p> 
<p>（2）onTouchEvent（）：在dispatchTouchEvent（）方法的内部调用；</p> 
<p>（3）onInterceptTouchEvent（）：在ViewGroup的diapatchTouchEvent（）方法的内部调用；</p> 
<p>5.事件分发方法的图解：</p> 
<p><img alt="" height="407" src="https://images2.imgbox.com/e3/f8/4AQXBSUs_o.png" width="1200"></p> 
<p></p> 
<p>6.事件分发的流程：</p> 
<p>Activity-&gt;ViewGroup-&gt;View</p> 
<p>二.事件分发的具体分析：</p> 
<p>1.Activity的事件分发机制：</p> 
<p>（1）源码分析：</p> 
<pre><code class="language-java">/**
*Activity的dispatchTouchEvent
*/
public boolean dispatchTouchEvent(MotionEvent ev) {
       if (ev.getAction() == MotionEvent.ACTION_DOWN) {
           onUserInteraction();
       }
       if (getWindow().superDispatchTouchEvent(ev)) {
           return true;
       }
       return onTouchEvent(ev);
}

/**
*Activity的onUserInteraction
*为一个空方法
*/
public void onUserInteraction() {

}

/**
*Window的superDispatchTouchEvent
*为一个抽象方法
*/
public abstract boolean superDispatchTouchEvent(MotionEvent event);

/**
*PhoneWindow的superDispatchTouchEvent
*PhoneWindow为Window的实现类
*/
@Override
 public boolean superDispatchTouchEvent(MotionEvent event) {
    return mDecor.superDispatchTouchEvent(event);
}

/**
*DecorView的superDispatchTouchEvent
*DecorView为FrameLayout的子类
*FrameLayout为ViewGroup的子类
*这里会直接调用父类（ViewGroup）的dispatchTouchEvent方法
*/
public boolean superDispatchTouchEvent(MotionEvent event) {
    return super.dispatchTouchEvent(event);
}

/**
*Activity的onTouchEvent
*
*/
public boolean onTouchEvent(MotionEvent event) {
    if (mWindow.shouldCloseOnTouch(this, event)) {
        finish();
        return true;
    }

    return false;
}

/**
*Window的shouldCloseOnTouch
*判断点击区域是否在边界的内部
*/
public boolean shouldCloseOnTouch(Context context, MotionEvent event) {
    //是否在边界外面
    final boolean isOutside =event.getAction() == MotionEvent.ACTION_UP &amp;&amp; isOutOfBounds(context, event)|| event.getAction() == MotionEvent.ACTION_OUTSIDE;
    if (mCloseOnTouchOutside &amp;&amp; peekDecorView() != null &amp;&amp; isOutside) {
        return true;
    }
    return false;
}</code></pre> 
<p>（2）图示：</p> 
<p><img alt="" height="865" src="https://images2.imgbox.com/74/8f/3GVQCzYl_o.png" width="1200"></p> 
<p></p> 
<p>2.ViewGroup的事件分发机制：</p> 
<p>（1）源码分析：</p> 
<pre><code class="language-java">/**
*ViewGroup中的dispatchTouchEvent()
*/
    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
        }

        // If the event targets the accessibility focused view and this is it, start
        // normal event dispatch. Maybe a descendant is what will handle the click.
        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) {
            ev.setTargetAccessibilityFocus(false);
        }

        boolean handled = false;
        if (onFilterTouchEventForSecurity(ev)) {
            final int action = ev.getAction();
            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;

            // Handle an initial down.
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            }

            // Check for interception.
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            // If intercepted, start normal event dispatch. Also if there is already
            // a view that is handling the gesture, do normal event dispatch.
            if (intercepted || mFirstTouchTarget != null) {
                ev.setTargetAccessibilityFocus(false);
            }

            // Check for cancelation.
            final boolean canceled = resetCancelNextUpFlag(this)
                    || actionMasked == MotionEvent.ACTION_CANCEL;

            // Update list of touch targets for pointer down, if needed.
            final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;
            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0
                    &amp;&amp; !isMouseEvent;
            TouchTarget newTouchTarget = null;
            boolean alreadyDispatchedToNewTouchTarget = false;
            if (!canceled &amp;&amp; !intercepted) {
                // If the event is targeting accessibility focus we give it to the
                // view that has accessibility focus and if it does not handle it
                // we clear the flag and dispatch the event to all children as usual.
                // We are looking up the accessibility focused host to avoid keeping
                // state since these events are very rare.
                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                        ? findChildWithAccessibilityFocus() : null;

                if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                    final int actionIndex = ev.getActionIndex(); // always 0 for down
                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                            : TouchTarget.ALL_POINTER_IDS;

                    // Clean up earlier touch targets for this pointer id in case they
                    // have become out of sync.
                    removePointersFromTouchTargets(idBitsToAssign);

                    final int childrenCount = mChildrenCount;
                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) {
                        final float x =
                                isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);
                        final float y =
                                isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);
                        // Find a child that can receive the event.
                        // Scan children from front to back.
                        final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();
                        final boolean customOrder = preorderedList == null
                                &amp;&amp; isChildrenDrawingOrderEnabled();
                        final View[] children = mChildren;
                        for (int i = childrenCount - 1; i &gt;= 0; i--) {
                            final int childIndex = getAndVerifyPreorderedIndex(
                                    childrenCount, i, customOrder);
                            final View child = getAndVerifyPreorderedView(
                                    preorderedList, children, childIndex);

                            // If there is a view that has accessibility focus we want it
                            // to get the event first and if not handled we will perform a
                            // normal dispatch. We may do a double iteration but this is
                            // safer given the timeframe.
                            if (childWithAccessibilityFocus != null) {
                                if (childWithAccessibilityFocus != child) {
                                    continue;
                                }
                                childWithAccessibilityFocus = null;
                                i = childrenCount - 1;
                            }

                            if (!child.canReceivePointerEvents()
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                ev.setTargetAccessibilityFocus(false);
                                continue;
                            }

                            newTouchTarget = getTouchTarget(child);
                            if (newTouchTarget != null) {
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;
                            }

                            resetCancelNextUpFlag(child);
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }

                            // The accessibility focus didn't handle the event, so clear
                            // the flag and do a normal dispatch to all children.
                            ev.setTargetAccessibilityFocus(false);
                        }
                        if (preorderedList != null) preorderedList.clear();
                    }

                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
                        // Did not find a child to receive the event.
                        // Assign the pointer to the least recently added target.
                        newTouchTarget = mFirstTouchTarget;
                        while (newTouchTarget.next != null) {
                            newTouchTarget = newTouchTarget.next;
                        }
                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                    }
                }
            }

            // Dispatch to touch targets.
            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            } else {
                // Dispatch to touch targets, excluding the new touch target if we already
                // dispatched to it.  Cancel touch targets if necessary.
                TouchTarget predecessor = null;
                TouchTarget target = mFirstTouchTarget;
                while (target != null) {
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
                        handled = true;
                    } else {
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
                        if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }

            // Update list of touch targets for pointer up or cancel, if needed.
            if (canceled
                    || actionMasked == MotionEvent.ACTION_UP
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                resetTouchState();
            } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
                final int actionIndex = ev.getActionIndex();
                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);
                removePointersFromTouchTargets(idBitsToRemove);
            }
        }

        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
        }
        return handled;
    }

/**
*ViewGroup中的onInterceptTouchEvent()
*/
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN
                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) {
            return true;
        }
        return false;
    }</code></pre> 
<p>（2）图示：</p> 
<p><img alt="" height="685" src="https://images2.imgbox.com/44/61/4zSrE9KZ_o.png" width="1191"></p> 
<p>3.View的事件分发机制</p> 
<p>（1）源码分析：</p> 
<p>（2）图示：</p> 
<p><img alt="" height="691" src="https://images2.imgbox.com/05/aa/x6JcBAud_o.png" width="1188"></p> 
<p>参考：<a href="https://www.jianshu.com/p/38015afcdb58" rel="nofollow" title="Android事件分发机制详解：史上最全面、最易懂 - 简书">Android事件分发机制详解：史上最全面、最易懂 - 简书</a></p> 
<p>三.滑动冲突的相关知识：</p> 
<p>1.常见的滑动冲突场景：</p> 
<p>（1）场景一：外部滑动方向和内部滑动方向不一致；</p> 
<p>（2）场景二：外部滑动方向和内部滑动方向一致；</p> 
<p>（3）场景三：以上两种场景的嵌套；</p> 
<p>2.滑动冲突的解决方式：</p> 
<p>（1）外部拦截法：所谓的外部拦截法是指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题，这种比较符合点击事件的分发机制。</p> 
<p><span style="color:#ff9900;">说明：</span></p> 
<p>[1] 外部拦截法需要重写父容器的onInterceptTouchEvent()方法，在内部做相应的拦截即可。</p> 
<p>[2] 在onInterceptTouchEvent()方法中，对于ACTION_DOWN这个事件，父容器必须返回false，即不拦截ACTION_DOWN事件，这是由于如果父容器拦截了这个事件，后续的ACTION_MOVE和ACTION_UP事件都会由父容器进行处理，就没法传递给子元素了。</p> 
<p>[3] 在onInterceptTouchEvent()方法中，对于ACTION_MOVE这个事件，这个根据具体的需求来决定要不要拦截，如果父容器需要拦截就返回true，不需要拦截就返回false。</p> 
<p>[4] 在onInterceptTouchEvent()方法中，对于ACTION_UP这个事件，必须要返回false，因为这个事件本身没有太大的意义。</p> 
<p>（2）内部拦截法：内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，如果子元素不需要此事件就交由父容器进行处理，这种方法和点击事件的分发机制不一致，需要配合requestDisallowInterceptTourchEvent方法才能正常工作。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/773807c027fba29ec7b51abba347b127/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#线程详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0bb738ec5c89106e63eb2339a338722c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">eCognition易康操作教程（一）：如何利用eCognition易康软件进行影像分割之棋盘分割、四叉树分割、光谱差异分割</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>