<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二进制搭建Kubernetes集群（三）——部署多master - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二进制搭建Kubernetes集群（三）——部署多master" />
<meta property="og:description" content="本文将完成多master集群的部署，即部署master02，以及nginx负载均衡、keepalived高可用
多master集群架构图： 架构说明：
node节点的kubelet只能对接一个master节点的apiserver，不可能同时对接多个master节点的apiserver。简而言之，node节只能有一个master来领导。
kubelet和kube-proxy是通过kubelet.kubeconfig和kube-proxy.kubeconfig文件中的server参数进行对接 master节点的。
所以在多master节点的环境下，需要有nginx负载均衡器来进行调度，而且需要进行keepalived高可用的构建(主从两个节点) ，防止主节点宕机导致整个k8s集群的不可用。
部署两台或者三台master都可以：
三台：多层保障、负载均衡（减轻每台master的压力）、选举机制选出leader。两台：也可实现负载均衡，负载压力没那么大的情况下可选两台，同时考虑到成本。 六、部署master02 节点 master02：192.168.126.21
##------------ 1、 master01节点，拷贝文件到master02 ------------------------------- #从 master01 节点上拷贝证书文件、各master组件的配置文件和服务管理文件到 master02 节点 scp -r /opt/etcd/ root@192.168.126.21:/opt/ scp -r /opt/kubernetes/ root@192.168.126.21:/opt scp /usr/lib/systemd/system/kube-* root@192.168.126.21:/usr/lib/systemd/system// [root@master01 opt]# cd [root@master01 ~]# scp -r .kube/ 192.168.126.21:/root ​ ##----------- 2、 master02节点，修改配置文件并启动相关服务------------------------- #修改配置文件kube-apiserver中的IP vim /opt/kubernetes/cfg/kube-apiserver KUBE_APISERVER_OPTS=&#34;--logtostderr=true \ #输出日志，false表示标准错误不输出到屏幕，而是输出到日志中。true表示标准错误会输出到屏幕。 --v=4 \ #日志级别 --etcd-servers=https://192.168.126.27:2379,https://192.168.126.28:2379,https://192.168.126.29:2379 \ #etcd节点的IP通信地址 --bind-address=192.168.126.21 \ #修改，当前绑定的内网IP监听的地址 --secure-port=6443 \ #基于HPPTS开放端口 --advertise-address=192.168.126.21 \ #修改，内网通告地址，让其他node节点地址通信 ...... ​ #在 master02 节点上启动各服务并设置开机自启 systemctl enable --now kube-apiserver." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8cf1e85ccbfc72153c8992d3e0dd10ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-28T10:57:19+08:00" />
<meta property="article:modified_time" content="2023-06-28T10:57:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二进制搭建Kubernetes集群（三）——部署多master</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文将完成多master集群的部署，即部署master02，以及nginx负载均衡、keepalived高可用</p> 
<h3>多master集群架构图：</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/45/7b/NykVUxKJ_o.png"></p> 
<p><strong>架构说明：</strong></p> 
<ul><li> <p>node节点的kubelet只能对接一个master节点的apiserver，不可能同时对接多个master节点的apiserver。简而言之，node节只能有一个master来领导。</p> </li><li> <p>kubelet和kube-proxy是通过kubelet.kubeconfig和kube-proxy.kubeconfig文件中的server参数进行对接 master节点的。</p> </li><li> <p>所以在多master节点的环境下，需要有nginx负载均衡器来进行调度，而且需要进行keepalived高可用的构建(主从两个节点) ，防止主节点宕机导致整个k8s集群的不可用。</p> </li></ul> 
<p><strong>部署两台或者三台master都可以：</strong></p> 
<ul><li>三台：多层保障、负载均衡（减轻每台master的压力）、选举机制选出leader。</li><li>两台：也可实现负载均衡，负载压力没那么大的情况下可选两台，同时考虑到成本。</li></ul> 
<p></p> 
<h2>六、部署master02 节点</h2> 
<p>master02：192.168.126.21</p> 
<pre><code class="hljs"> ##------------ 1、 master01节点，拷贝文件到master02 -------------------------------
 #从 master01 节点上拷贝证书文件、各master组件的配置文件和服务管理文件到 master02 节点
scp -r /opt/etcd/ root@192.168.126.21:/opt/
scp -r /opt/kubernetes/ root@192.168.126.21:/opt
scp /usr/lib/systemd/system/kube-* root@192.168.126.21:/usr/lib/systemd/system//
[root@master01 opt]# cd
[root@master01 ~]# scp -r .kube/ 192.168.126.21:/root
 ​
 ##----------- 2、 master02节点，修改配置文件并启动相关服务-------------------------
 
 #修改配置文件kube-apiserver中的IP
 vim /opt/kubernetes/cfg/kube-apiserver
 KUBE_APISERVER_OPTS="--logtostderr=true \        #输出日志，false表示标准错误不输出到屏幕，而是输出到日志中。true表示标准错误会输出到屏幕。
 --v=4 \                                          #日志级别
 --etcd-servers=https://192.168.126.27:2379,https://192.168.126.28:2379,https://192.168.126.29:2379 \      #etcd节点的IP通信地址
 --bind-address=192.168.126.21 \              #修改，当前绑定的内网IP监听的地址
 --secure-port=6443 \                                                                #基于HPPTS开放端口
 --advertise-address=192.168.126.21 \         #修改，内网通告地址，让其他node节点地址通信
 ......
 ​
 #在 master02 节点上启动各服务并设置开机自启
 systemctl enable --now kube-apiserver.service
 systemctl enable --now kube-controller-manager.service
 systemctl enable --now kube-scheduler.service

 #查看服务状态是否开启
 systemctl status kube-apiserver kube-controller-manager kube-scheduler
 ​
 #将可执行文件，创建软链接
 ln -s /opt/kubernetes/bin/* /usr/local/bin/
 ​
 #查看node节点状态
 kubectl get nodes
 kubectl get nodes -o wide           #-o=wide：输出额外信息；对于Pod，将输出Pod所在的Node名
 #此时在master02节点查到的node节点状态仅是从etcd查询到的信息，而此时node节点实际上并未与master02节点建立通信连接，因此需要使用一个VIP把node节点与master节点都关联起来
</code></pre> 
<h2>七、部署负载均衡</h2> 
<p>配置load balancer集群双机热备负载均衡（nginx实现负载均衡，keepalived实现双机热备）。</p> 
<p>load balancer01：192.168.126.22</p> 
<p>load balancer01：192.168.126.23</p> 
<p>VIP：192.168.126.88</p> 
<h3>7.1 在lb01、lb02节点上配置nginx和keepalived</h3> 
<pre><code class="hljs"> #配置load balancer集群双机热备负载均衡（nginx实现负载均衡，keepalived实现双机热备）
 ​
 #----------------- 1、两台负载均衡器配置nginx -------------------------------------
 ​
 systemctl disable --now firewalld
 setenforce 0
 vim /etc/selinux/config
 SELINUX=disabled
 
 #配置nginx的官方在线yum源，配置本地nginx的yum源
 cat &gt; /etc/yum.repos.d/nginx.repo &lt;&lt; 'EOF'
 [nginx]
 name=nginx repo
 baseurl=http://nginx.org/packages/centos/7/$basearch/
 gpgcheck=0
 EOF
 ​
 yum install nginx -y
 ​
 #修改nginx配置文件，配置四层反向代理负载均衡，指定k8s群集2台master的节点ip和6443端口
 cd /etc/nginx/
 vim /etc/nginx/nginx.conf
 events {
     worker_connections  1024;
 }
 ​
 #添加
 stream {
     upstream k8s-apiserver {
         server 192.168.126.21:6443;    #master01
         server 192.168.126.27:6443;    #master02
     }
     server {
         listen 6443;
         proxy_pass k8s-apiserver;
     }
 }
 ​
 http {
 ......
 ​
 ​
 #检查配置文件语法
 nginx -t   
 ​
 #启动nginx服务，查看已监听6443端口
 systemctl start nginx
 systemctl enable nginx
 netstat -natp | grep nginx 
[root@lb01 nginx]# netstat -lntp | grep nginx
tcp        0      0 0.0.0.0:6443            0.0.0.0:*               LISTEN      43439/nginx: master 
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      43439/nginx: master
 ​
[root@lb01 nginx]# scp nginx.conf 192.168.126.23:`pwd`
[root@lb02 ~]# systemctl enable --now nginx
[root@lb02 ~]# netstat -lntp | grep nginx
 ​
 #------------------ 2、两台负载均衡器配置keepalived ------------------------------
 ​
 #部署keepalived服务
 yum install keepalived -y
 ​
 //创建nginx状态检查脚本
cd /etc/keepalived
vim check_nginx.sh
#!/bin/bash
if ! killall -0 nginx &amp;&gt; /dev/null
then
    systemctl stop keepalived
fi

chmod +x check_nginx.sh 

#或者
vim /etc/keepalived/check_nginx.sh
#!/bin/bash
#egrep -cv "grep|$$" 用于过滤掉包含grep 或者 $$ 表示的当前Shell进程ID
count=$(ps -ef | grep nginx | egrep -cv "grep|$$")

if [ "$count" -eq 0 ];then
    systemctl stop keepalived
fi

chmod +x /etc/keepalived/check_nginx.sh

#修改keepalived配置文件
 vim /etc/keepalived/keepalived.conf
 ! Configuration File for keepalived
 ​
 global_defs {
    # 接收邮件地址
    notification_email {
      acassen@firewall.loc
      failover@firewall.loc
      sysadmin@firewall.loc
    }
    # 邮件发送地址
    notification_email_from Alexandre.Cassen@firewall.loc
    smtp_server 127.0.0.1    #修改为本机回环地址
    smtp_connect_timeout 30
    router_id NGINX_01	#lb01节点的为 NGINX_01，lb02节点的为 NGINX_02
 }
 ​
 #添加一个周期性执行的脚本
 vrrp_script check_nginx {
     script "/etc/keepalived/check_nginx.sh"  #指定检查nginx存活的脚本路径
     interval 2                          #指定每两秒检测一次，默认1秒
 }
 ​
 vrrp_instance VI_1 {
     state MASTER            #lb01节点的为 MASTER，lb02节点的为 BACKUP
     interface ens33         #指定网卡名称 ens33
     virtual_router_id 51    #指定vrid，两个节点要一致
     priority 100            #设置优先级，lb01节点的为 100，lb02节点的为 90
     advert_int 1
     authentication {
         auth_type PASS
         auth_pass 1111
     }
     virtual_ipaddress {
         192.168.126.88   #指定 VIP，需要与之前证书中认证的地址一致
     }
     track_script {          #追踪脚本
         check_nginx         #指定vrrp_script配置的脚本
     }
 }
 ​
 ​#启动keepalived服务（一定要先启动了nginx服务，再启动keepalived服务）
 systemctl start keepalived
 systemctl enable keepalived
 ip addr             #查看主节点的VIP是否生成

 [root@lb01 keepalived]# scp keepalived.conf check_nginx.sh 192.168.126.23:`pwd`    #配置文件和脚本复制到另一台上  
vim keepalived.conf 
router_id NGINX_02          #修改
state BACKUP                #修改
priority 90                 #修改

systemctl enable --now keepalived.service

 
 #---------------- 3、关闭主节点的nginx服务，模拟故障，测试keepalived-----------------------
 ​
 #关闭主节点lb01的Nginx服务，模拟宕机，观察VIP是否漂移到备节点
 systemctl stop nginx
 ip addr
 systemctl status keepalived   #此时keepalived被脚本杀掉了   
 ​
 #备节点查看是否生成了VIP
 ip addr    #此时VIP漂移到备节点lb02
 ​
 #恢复主节点
 systemctl start nginx         #先启动nginx
 systemctl start keepalived    #再启动keepalived
 ip addr</code></pre> 
<h3>7.2 所有node节点修改配置文件</h3> 
<pre><code class="hljs"> #修改node1和node2节点上的bootstrap.kubeconfig,kubelet.kubeconfig配置文件为VIP
 cd /opt/kubernetes/cfg/
 vim bootstrap.kubeconfig 
 server: https://192.168.126.88:6443
                       
 vim kubelet.kubeconfig
 server: https://192.168.126.88:6443
                         
 vim kube-proxy.kubeconfig
 server: https://192.168.126.88:6443
 ​
 #重启node1和node2的kubelet和kube-proxy服务
 systemctl restart kubelet.service 
 systemctl restart kube-proxy.service
 ​
 #在lb01查看nginx的k8s日志
 tail /var/log/nginx/k8s-access.log
 ​
 #在 lb01 上查看 nginx 和 node 、 master 节点的连接状态
netstat -natp | grep nginx
tcp        0      0 0.0.0.0:6443            0.0.0.0:*               LISTEN      45691/nginx: master 
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      45691/nginx: master 
tcp        0      0 192.168.126.22:39598    192.168.126.21:6443     ESTABLISHED 45693/nginx: worker 
tcp        0      0 192.168.126.22:37884    192.168.126.27:6443     ESTABLISHED 45693/nginx: worker 
tcp        0      0 192.168.126.88:6443     192.168.126.28:44564    ESTABLISHED 45693/nginx: worker 
tcp        0      0 192.168.126.88:6443     192.168.126.28:44558    ESTABLISHED 45693/nginx: worker 
tcp        0      0 192.168.126.88:6443     192.168.126.29:45366    ESTABLISHED 45693/nginx: worker 
tcp        0      0 192.168.126.22:37880    192.168.126.27:6443     ESTABLISHED 45693/nginx: worker 
tcp        0      0 192.168.126.22:39606    192.168.126.21:6443     ESTABLISHED 45693/nginx: worker 
tcp        0      0 192.168.126.22:37888    192.168.126.27:6443     ESTABLISHED 45693/nginx: worker 
</code></pre> 
<h3>7.3 在 master01 节点测试创建pod</h3> 
<pre><code class="hljs">#测试创建pod
 kubectl run nginx --image=nginx
 ​
 #查看Pod的状态信息
 kubectl get pods
NAMESPACE      NAME                    READY   STATUS              RESTARTS   AGE
default        nginx                   0/1     ContainerCreating   0          22s          #正在创建中
 ​
 kubectl get pods
NAMESPACE      NAME                    READY   STATUS             RESTARTS   AGE
default        nginx                   1/1     Running            0          6m21s  			#创建完成，运行中
 ​
 kubectl get pods -o wide
NAMESPACE      NAME                    READY   STATUS    RESTARTS   AGE     IP               NODE             NOMINATED NODE   READINESS GATES
default        nginx                   1/1     Running   0          7m23s   10.244.0.2       192.168.126.28   &lt;none&gt;           &lt;none&gt;

 #READY为1/1，表示这个Pod中有1个容器

#在对应node节点上操作，可以直接使用浏览器或者curl命令访问
[root@node01 cfg]# curl 10.244.1.2
Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;

 ​#这时在master01节点上查看nginx日志，发现没有权限查看
 kubectl logs nginx   #并没有Pod的访问记录


此时多master集群以及nginx负载均衡、keepalived高可用部署完毕</code></pre> 
<p></p> 
<h2>八、部署Dashboard</h2> 
<p><strong>Dashboard 介绍：</strong></p> 
<p>仪表板是基于Web的Kubernetes用户界面。您可以使用仪表板将容器化应用程序部署到Kubernetes集群，对容器化应用程序进行故障排除，并管理集群本身及其伴随资源。您可以使用仪表板来概述群集上运行的应用程序，以及创建或修改单个Kubernetes资源（例如部署，作业，守护进程等）。例如，您可以使用部署向导扩展部署，启动滚动更新，重新启动Pod或部署新应用程序。仪表板还提供有关群集中Kubernetes资源状态以及可能发生的任何错误的信息。</p> 
<pre><code class="hljs"> #在 master01 节点上操作
 #上传 recommended.yaml 文件到 /opt/k8s 目录中
 cd /opt/k8s
 vim recommended.yaml
 #默认Dashboard只能集群内部访问，修改Service为NodePort类型，暴露到外部
 kind: Service
 apiVersion: v1
 metadata:
   labels:
     k8s-app: kubernetes-dashboard
   name: kubernetes-dashboard
   namespace: kubernetes-dashboard
 spec:
   ports:
     - port: 443
       targetPort: 8443
       nodePort: 30001     #添加
   type: NodePort          #添加
   selector:
     k8s-app: kubernetes-dashboard
 ​
 #通过recommended.yaml资源配置清单，使用kubectl apply创建资源，-f指定资源配置清单文件
 kubectl apply -f recommended.yaml
 ​
 #创建service account并绑定默认cluster-admin管理员集群角色
 kubectl create serviceaccount dashboard-admin -n kube-system
 kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin
 ​
 #获取token值
 kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk '/dashboard-admin/{print $1}')
 ​
 #使用输出的token登录Dashboard
 #如果web页面提示不安全，敲thisisunsafe即可进入下一页面，之后将token值输入
 https://192.168.126.29:30001
</code></pre> 
<p></p> 
<h2>总结：</h2> 
<h4>多master部署步骤：</h4> 
<ol><li>先部署master02等其它master节点</li><li>搭建Nginx/Haproxy + keepalived 高可用 负载均衡对接</li><li>master节点群集</li><li>修改node 节点上的kubelet kube-proxy 的kubeconfig 配置文件对接vip</li><li>kubectl的配置文件也要对接VIP或者当前节点的IP</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be6f63c8d93b2d371087dfc44871ac9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在宝塔（bt）下搭建 wordpress 网站 &#43; 免费 waf 防火墙</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f5947c2f42bc9b70108b11dd6e2be9e2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux 下 telnet 的替代方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>