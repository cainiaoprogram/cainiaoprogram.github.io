<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java异常问题_10个关于Java异常的常见问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java异常问题_10个关于Java异常的常见问题" />
<meta property="og:description" content="这篇文章总结了十个经常被问到的JAVA异常问题；
1.检查型异常VS非检查型异常
简单的说，检查型异常是指需要在方法中自己捕获异常处理或者声明抛出异常由调用者去捕获处理；
非检查型异常指那些不能解决的异常，如除0，空指针等；
检查型异常非常重要，因为你希望使用你API接口的人知道如何处理这些异常；
举个例子，IOException是非常常见的检查型异常，RuntimeException是非检查型异常；
Java的异常层级关系图如下：
2.异常管理最佳实践
如果一个异常当前能够被恰当的处理，那么应该捕获处理它，否则应该显示的抛出异常；
3.为什么在try代码块里定义的变量，在catch或finally代码块里不能被访问
如下代码，在try代码块中声明字符串s变量，但是不能在catch代码块中使用，代码不能编译通过；
try{
File file= new File(&#34;path&#34;);
FileInputStream fis= newFileInputStream(file);
String s= &#34;inside&#34;;
}catch(FileNotFoundException e) {
e.printStackTrace();
System.out.println(s);
}
原因是因为你不知道在try代码块中的哪一句会抛出异常，很有可能这个异常在变量声明之前就抛出了；
这正是以上这个例子的情况；
注：强烈怀疑是因为作用域的关系导致s变量不可见；
4.为什么Integer.parseInt(null)和Double.parseDouble(null)会抛出不同的异常
这是JDK的问题，因为这两个方法是不同的开发人员写的，所以没必要深究；
Integer.parseInt(null);//throws java.lang.NumberFormatException: null
Double.parseDouble(null);//throws java.lang.NullPointerException
注：其实我目前的JDK7已经没有该问题了，两个都是抛出NumberFormatException
5.多用运行时异常
几个常见的运行时异常，如IllegalArgumentException、ArrayIndexOutOfBoundsException；
当判断条件不满足时，可以抛出这些异常，如下代码：
if (obj == null) {throw new IllegalArgumentException(&#34;obj can not be null&#34;);
6.是否可以在一个catch代码块里捕获多个异常
答案是可以的。因为JAVA的异常可以追溯到同一个父类Exception，我们可以使用父类捕获多个异常；
try{
}catch(Exception e) {//TODO: handle exception
}
补充：
在JAVA7中，增加了新语法，可以这样捕获多个异常：
try{
...
}catch( IOException |SQLException ex ) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ce193ff9ff52991063d796f68770067f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-16T03:35:30+08:00" />
<meta property="article:modified_time" content="2021-02-16T03:35:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java异常问题_10个关于Java异常的常见问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>这篇文章总结了十个经常被问到的JAVA异常问题；</p> 
 <p>1.检查型异常VS非检查型异常</p> 
 <p>简单的说，检查型异常是指需要在方法中自己捕获异常处理或者声明抛出异常由调用者去捕获处理；</p> 
 <p>非检查型异常指那些不能解决的异常，如除0，空指针等；</p> 
 <p>检查型异常非常重要，因为你希望使用你API接口的人知道如何处理这些异常；</p> 
 <p>举个例子，IOException是非常常见的检查型异常，RuntimeException是非检查型异常；</p> 
 <p>Java的异常层级关系图如下：</p> 
 <p align="center"><img src="https://images2.imgbox.com/83/0c/bSiSd4Ck_o.png" alt="2bd8cfeb768bfddf1cfc1ca038760c24.png"></p> 
 <p>2.异常管理最佳实践</p> 
 <p>如果一个异常当前能够被恰当的处理，那么应该捕获处理它，否则应该显示的抛出异常；</p> 
 <p>3.为什么在try代码块里定义的变量，在catch或finally代码块里不能被访问</p> 
 <p>如下代码，在try代码块中声明字符串s变量，但是不能在catch代码块中使用，代码不能编译通过；</p> 
 <p>try{<!-- --></p> 
 <p>File file= new File("path");</p> 
 <p>FileInputStream fis= newFileInputStream(file);</p> 
 <p>String s= "inside";</p> 
 <p>}catch(FileNotFoundException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>System.out.println(s);</p> 
 <p>}</p> 
 <p>原因是因为你不知道在try代码块中的哪一句会抛出异常，很有可能这个异常在变量声明之前就抛出了；</p> 
 <p>这正是以上这个例子的情况；</p> 
 <p>注：强烈怀疑是因为作用域的关系导致s变量不可见；</p> 
 <p>4.为什么Integer.parseInt(null)和Double.parseDouble(null)会抛出不同的异常</p> 
 <p>这是JDK的问题，因为这两个方法是不同的开发人员写的，所以没必要深究；</p> 
 <p>Integer.parseInt(null);//throws java.lang.NumberFormatException: null</p> 
 <p>Double.parseDouble(null);//throws java.lang.NullPointerException</p> 
 <p>注：其实我目前的JDK7已经没有该问题了，两个都是抛出NumberFormatException</p> 
 <p>5.多用运行时异常</p> 
 <p>几个常见的运行时异常，如IllegalArgumentException、ArrayIndexOutOfBoundsException；</p> 
 <p>当判断条件不满足时，可以抛出这些异常，如下代码：</p> 
 <p>if (obj == null) {throw new IllegalArgumentException("obj can not be null");</p> 
 <p>6.是否可以在一个catch代码块里捕获多个异常</p> 
 <p>答案是可以的。因为JAVA的异常可以追溯到同一个父类Exception，我们可以使用父类捕获多个异常；</p> 
 <p>try{<!-- --></p> 
 <p>}catch(Exception e) {//TODO: handle exception</p> 
 <p>}</p> 
 <p>补充：</p> 
 <p>在JAVA7中，增加了新语法，可以这样捕获多个异常：</p> 
 <p>try{<!-- --></p> 
 <p>...</p> 
 <p>}catch( IOException |SQLException ex ) {<!-- --></p> 
 <p>...</p> 
 <p>}</p> 
 <p>在JAVA7之前可以这样写：</p> 
 <p>try{//.....</p> 
 <p>} catch(Exception exc) {if (exc instanceof IllegalArgumentException || exc instanceof SecurityException ||excinstanceof IllegalAccessException || exc instanceofNoSuchFieldException ) {<!-- --></p> 
 <p>someCode();</p> 
 <p>}else if (exc instanceofRuntimeException) {throw(RuntimeException) exc;</p> 
 <p>}else{throw newRuntimeException(exc);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>7.构造方法是否可以抛出异常</p> 
 <p>答案是可以的，构造方法是一个特殊的方法，同样可以抛出异常；</p> 
 <p>注意，如果构造方法抛出异常，对象是没有生成的；</p> 
 <p>8.finally语句块同样可以抛出和捕获异常</p> 
 <p>以下代码是合法的：</p> 
 <p>public static voidmain(String[] args) {<!-- --></p> 
 <p>File file1= new File("path1");</p> 
 <p>File file2= new File("path2");try{<!-- --></p> 
 <p>FileInputStream fis= newFileInputStream(file1);</p> 
 <p>}catch(FileNotFoundException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}finally{try{<!-- --></p> 
 <p>FileInputStream fis= newFileInputStream(file2);</p> 
 <p>}catch(FileNotFoundException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>但是出于可读性考虑，最好把finally里的异常处理代码封装到一个方法里，然后调用该方法，如下代码:</p> 
 <p>public static voidmain(String[] args) {<!-- --></p> 
 <p>File file1= new File("path1");</p> 
 <p>File file2= new File("path2");try{<!-- --></p> 
 <p>FileInputStream fis= newFileInputStream(file1);</p> 
 <p>}catch(FileNotFoundException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}finally{<!-- --></p> 
 <p>methodThrowException();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>9.finally代码块里是否可以写return语句</p> 
 <p>是的，可以</p> 
 <p>10.为什么JAVA程序员经常悄悄地忽略异常的处理</p> 
 <p>以下代码片段会经常出现在程序中，如果异常处理那么重要，为什么还会有这么多开发人员一直这样做呢？</p> 
 <p>try{<!-- --></p> 
 <p>...</p> 
 <p>}catch(Exception e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>经常出现的代码并不代表是对的；</p> 
 <p>可能很多开发人员都使用eclipse的快速修复，自动生成异常处理代码，如上所示，其实除了记录下log，并没有做什么处理；</p> 
 <p>正如条目2所描述的，如果不能正确处理该异常的话，最好抛出异常，以便异常尽早被发现；</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3887015cbb2add6061ea705a9499e0e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java empty string_java.lang.NumberFormatException: empty String</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff5024664df107bb9c6070147ee4ffb5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java long scala_scala和java哪个运行速度快</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>