<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>字典树详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="字典树详解" />
<meta property="og:description" content="目录
1.什么是字典树?
2.字典树有什么用?
1.以最节约空间的方式存储大量字符串.且存好后是有序的
2.快速查询某字符串s在字典树中是否已存在,甚至出现过几次
3.字典树实现思路
4.模版代码
(1).以数组模拟动态分配的只带增查的字典树模版
(2).以动态分配为实现的带增删改查的字典树模版.
1.什么是字典树? 首先字典树是一种数据结构,用于处理大量字符串.,优点在于利用字符串的公共前缀,在存储时节约存储空间,并在查询时最大限度的减少无谓的字符串比较.
2.字典树有什么用? 1.以最节约空间的方式存储大量字符串.且存好后是有序的 因为是有序的,故而字典树不仅可用于大量字符串的存储,还可用于大量字符串的排序.
2.快速查询某字符串s在字典树中是否已存在,甚至出现过几次 因为当字典树预处理好之后,查询字符串s在当前的出现情况的效率为strlen(s),异常高效,故而常用于搜索引擎等.
3.字典树实现思路 首先我们已经知道了字典树是一种数据结构,而一个数据结构的重点就在于:
1.怎么有规则的把数据存储下来
2.怎么有规则的去高效的得到自己需要的数据
我们最终的目标就是用程序实现一个如下图的树:
颜色为黑色的表示只是字符串中间的字符,为蓝色的表示是字符串末尾的那个字符,空白那个是树根节点.每个节点的意义实际上就是根节点到这个结点所经过的每个字符组成的字符串.故而图中这个树实际上意味着已存在字符串&#34;&#34;,&#34;to&#34;,&#34;tea&#34;,&#34;ted&#34;,&#34;ten&#34;,&#34;a&#34;,&#34;i&#34;,&#34;in&#34;,&#34;inn&#34;
4.模版代码 (1).以数组模拟动态分配的只带增查的字典树模版 //一个只带添加字符串与查找字符串的字典树（为了效率以数组实现） #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int charmapping[256]; //字符映射数组,charmapping[i]=x表示ascii码为i的字符对应于treenode中的next[x] void init_charmapping(){ for(int i=&#39;a&#39;;i&lt;=&#39;z&#39;;i&#43;&#43;){ //我的这个字典树现在只允许输入小写字符组成的字符串,然而由于有charmapping的存在,增加新字符添加映射并且增大maxn就好,很方便. charmapping[i]=i-&#39;a&#39;; } } const int maxn=26; //这里假设字符串中只出现26个小写字母 const int maxm=100000; struct treenode{ bool end; //标志此节点是否是某字符串的结尾 treenode* next[maxn]; }head; treenode memory[maxm]; //字典树所用到的数组空间 int mallocp=0; //模拟内存分配 void init(){ head.end=1; for(int i=0;i&lt;maxn;i&#43;&#43;) head.next[i]=NULL; } treenode* createnew(){ treenode* newnode; newnode=&amp;memory[mallocp&#43;&#43;]; newnode-&gt;end=0; for(int i=0;i&lt;maxn;i&#43;&#43;) newnode-&gt;next[i]=NULL; return newnode; } void update(char* s){ int k=0,temp; treenode* t=&amp;head; while(s[k]){ temp=charmapping[s[k]]; if(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b3fae77155dc69b043d3c5837e6eab42/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-17T19:08:23+08:00" />
<meta property="article:modified_time" content="2018-07-17T19:08:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">字典树详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E5%85%B8%E6%A0%91%3F-toc" style="margin-left:0px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E5%85%B8%E6%A0%91%3F" rel="nofollow">1.什么是字典树?</a></p> 
<p id="2.%E5%AD%97%E5%85%B8%E6%A0%91%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%3F-toc" style="margin-left:0px;"><a href="#2.%E5%AD%97%E5%85%B8%E6%A0%91%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%3F" rel="nofollow">2.字典树有什么用?</a></p> 
<p id="%C2%A0%20%C2%A0%201.%E4%BB%A5%E6%9C%80%E8%8A%82%E7%BA%A6%E7%A9%BA%E9%97%B4%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%98%E5%82%A8%E5%A4%A7%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2.%E4%B8%94%E5%AD%98%E5%A5%BD%E5%90%8E%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%201.%E4%BB%A5%E6%9C%80%E8%8A%82%E7%BA%A6%E7%A9%BA%E9%97%B4%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%98%E5%82%A8%E5%A4%A7%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2.%E4%B8%94%E5%AD%98%E5%A5%BD%E5%90%8E%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84" rel="nofollow">    1.以最节约空间的方式存储大量字符串.且存好后是有序的</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A02.%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%AD%97%E7%AC%A6%E4%B8%B2s%E5%9C%A8%E5%AD%97%E5%85%B8%E6%A0%91%E4%B8%AD%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AD%98%E5%9C%A8%2C%E7%94%9A%E8%87%B3%E5%87%BA%E7%8E%B0%E8%BF%87%E5%87%A0%E6%AC%A1-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A02.%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%AD%97%E7%AC%A6%E4%B8%B2s%E5%9C%A8%E5%AD%97%E5%85%B8%E6%A0%91%E4%B8%AD%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AD%98%E5%9C%A8%2C%E7%94%9A%E8%87%B3%E5%87%BA%E7%8E%B0%E8%BF%87%E5%87%A0%E6%AC%A1" rel="nofollow">    2.快速查询某字符串s在字典树中是否已存在,甚至出现过几次</a></p> 
<p id="3.%E5%AD%97%E5%85%B8%E6%A0%91%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-toc" style="margin-left:0px;"><a href="#3.%E5%AD%97%E5%85%B8%E6%A0%91%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF" rel="nofollow">3.字典树实现思路</a></p> 
<p id="5.%E6%A8%A1%E7%89%88%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#5.%E6%A8%A1%E7%89%88%E4%BB%A3%E7%A0%81" rel="nofollow">4.模版代码</a></p> 
<p id="(1).%E4%BB%A5%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E5%8F%AA%E5%B8%A6%E5%A2%9E%E6%9F%A5%E7%9A%84%E5%AD%97%E5%85%B8%E6%A0%91%E6%A8%A1%E7%89%88-toc" style="margin-left:40px;"><a href="#%281%29.%E4%BB%A5%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E5%8F%AA%E5%B8%A6%E5%A2%9E%E6%9F%A5%E7%9A%84%E5%AD%97%E5%85%B8%E6%A0%91%E6%A8%A1%E7%89%88" rel="nofollow">(1).以数组模拟动态分配的只带增查的字典树模版</a></p> 
<p id="(2).%E4%BB%A5%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E4%B8%BA%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%B8%A6%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9A%84%E5%AD%97%E5%85%B8%E6%A0%91%E6%A8%A1%E7%89%88.-toc" style="margin-left:40px;"><a href="#%282%29.%E4%BB%A5%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E4%B8%BA%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%B8%A6%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9A%84%E5%AD%97%E5%85%B8%E6%A0%91%E6%A8%A1%E7%89%88." rel="nofollow">(2).以动态分配为实现的带增删改查的字典树模版.</a></p> 
<hr id="hr-toc"> 
<h2> </h2> 
<h2 id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E5%85%B8%E6%A0%91%3F">1.什么是字典树?</h2> 
<p>    首先字典树是一种<strong>数据结构</strong>,用于处理大量字符串.,优点在于利用字符串的公共前缀,在存储时节约存储空间,并在查询时最大限度的减少无谓的字符串比较.</p> 
<h2 id="2.%E5%AD%97%E5%85%B8%E6%A0%91%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%3F">2.字典树有什么用?</h2> 
<h3 id="%C2%A0%20%C2%A0%201.%E4%BB%A5%E6%9C%80%E8%8A%82%E7%BA%A6%E7%A9%BA%E9%97%B4%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%98%E5%82%A8%E5%A4%A7%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2.%E4%B8%94%E5%AD%98%E5%A5%BD%E5%90%8E%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84">    1.以最节约空间的方式存储大量字符串.且存好后是有序的</h3> 
<p>           因为是有序的,故而字典树不仅可用于大量字符串的存储,还可用于大量<strong>字符串的排序.</strong></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A02.%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%AD%97%E7%AC%A6%E4%B8%B2s%E5%9C%A8%E5%AD%97%E5%85%B8%E6%A0%91%E4%B8%AD%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AD%98%E5%9C%A8%2C%E7%94%9A%E8%87%B3%E5%87%BA%E7%8E%B0%E8%BF%87%E5%87%A0%E6%AC%A1">    2.快速查询某字符串s在字典树中是否已存在,甚至出现过几次</h3> 
<p>          因为当字典树预处理好之后,查询字符串s在当前的出现情况的效率为strlen(s),异常高效,故而常用于搜索引擎等.</p> 
<h2 id="3.%E5%AD%97%E5%85%B8%E6%A0%91%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">3.字典树实现思路</h2> 
<p>    首先我们已经知道了字典树是一种数据结构,而一个数据结构的重点就在于:</p> 
<p>        1.怎么有规则的把数据存储下来</p> 
<p>        2.怎么有规则的去高效的得到自己需要的数据</p> 
<p>      我们最终的目标就是用程序实现一个如下图的树:</p> 
<p> </p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/e6/22/M6iCrdoY_o.png"></p> 
<p>        颜色为黑色的表示只是字符串中间的字符,为蓝色的表示是字符串末尾的那个字符,空白那个是树根节点.每个节点的意义实际上就是根节点到这个结点所经过的每个字符组成的字符串.故而图中这个树实际上意味着已存在字符串"","to","tea","ted","ten","a","i","in","inn"</p> 
<h2 id="5.%E6%A8%A1%E7%89%88%E4%BB%A3%E7%A0%81">4.模版代码</h2> 
<h3 id="(1).%E4%BB%A5%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E5%8F%AA%E5%B8%A6%E5%A2%9E%E6%9F%A5%E7%9A%84%E5%AD%97%E5%85%B8%E6%A0%91%E6%A8%A1%E7%89%88">(1).以数组模拟动态分配的只带增查的字典树模版</h3> 
<pre class="has"><code class="language-cpp">//一个只带添加字符串与查找字符串的字典树（为了效率以数组实现） 
 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
 
int charmapping[256]; //字符映射数组,charmapping[i]=x表示ascii码为i的字符对应于treenode中的next[x] 
void init_charmapping(){
	for(int i='a';i&lt;='z';i++){ //我的这个字典树现在只允许输入小写字符组成的字符串,然而由于有charmapping的存在,增加新字符添加映射并且增大maxn就好,很方便. 
		charmapping[i]=i-'a';
	} 
} 
 
const int maxn=26; //这里假设字符串中只出现26个小写字母 
const int maxm=100000;
struct treenode{
	bool end; //标志此节点是否是某字符串的结尾 
	treenode* next[maxn]; 
}head;
 
treenode memory[maxm]; //字典树所用到的数组空间
int mallocp=0;  //模拟内存分配
 
void init(){
	head.end=1;
	for(int i=0;i&lt;maxn;i++) head.next[i]=NULL;
}
 
treenode* createnew(){
	treenode* newnode;
	newnode=&amp;memory[mallocp++];
	newnode-&gt;end=0;
	for(int i=0;i&lt;maxn;i++) newnode-&gt;next[i]=NULL;
	return newnode;
}
 
void update(char* s){
	int k=0,temp;
	treenode* t=&amp;head;
	while(s[k]){
		temp=charmapping[s[k]];
		if(!t-&gt;next[temp]) t-&gt;next[temp]=createnew(); 
		t=t-&gt;next[temp];
		k++;
	}
	t-&gt;end=1;
}
 
bool search(char* s){
	int k=0,temp;
	treenode* t=&amp;head;
	while(s[k]){
		temp=charmapping[s[k]];
		if(!t-&gt;next[temp]) return false;
		t=t-&gt;next[temp];
		k++;
	}
	if(t-&gt;end) return true;
	return false; 
}
 
int main(){
	init_charmapping();
	init();
	char x[1000];
	char t;
	while(1){
		fflush(stdin);
		scanf("%c",&amp;t);
		if(t=='q'){
			scanf("%s",&amp;x);
			if(search(x)) printf("匹配成功！\n");
			else printf("匹配失败！\n"); 
		}
		else if(t=='u'){
			scanf("%s",&amp;x);
			update(x);
			printf("更新完毕！\n");
		}
		else if(t=='e'){
			printf("退出ing....\n"); 
			break;
		}
		else printf("无效命令！,请重新输入！\n"); 
	} 
	return 0;
}</code></pre> 
<h3 id="(2).%E4%BB%A5%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E4%B8%BA%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%B8%A6%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9A%84%E5%AD%97%E5%85%B8%E6%A0%91%E6%A8%A1%E7%89%88.">(2).以动态分配为实现的带增删改查的字典树模版.</h3> 
<pre class="has"><code class="language-cpp">//一个以链表实现带删除功能允许重复字符串的字典树
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;


int charmapping[256]; //字符映射数组,charmapping[i]=x表示ascii码为i的字符对应于treenode中的next[x] 
void init_charmapping(){
	for(int i='a';i&lt;='z';i++){ //我的这个字典树现在只允许输入小写字符组成的字符串,然而由于有charmapping的存在,增加新字符添加映射并且增大maxn就好,很方便. 
		charmapping[i]=i-'a';
	} 
} 

const int maxn=26; //这里假设字符串中只出现26个小写字母 
const int maxm=100000;
struct treenode{
	int count; //标志此节点所表示字符串在所有字符串中以前缀形式出现的总次数 
	treenode* next[maxn]; 
}head;

void init_trie(){
	head.count=1; //初始化为1包括空串并且避免树头被删 
	for(int i=0;i&lt;maxn;i++) head.next[i]=NULL;
}

treenode* createnew(){ //申请一个新结点并初始化它
	treenode* newnode;
	newnode=(treenode*)malloc(sizeof(treenode));
	newnode-&gt;count=0;
	for(int i=0;i&lt;maxn;i++) newnode-&gt;next[i]=NULL;
	return newnode;
}

void update(char* s,int num){ //向字典树添加num个字符串s 
	int k=0,temp;
	treenode* t=&amp;head;
	while(s[k]){
		t-&gt;count+=num;
		temp=charmapping[s[k]];
		if(!t-&gt;next[temp]) t-&gt;next[temp]=createnew(); 
		t=t-&gt;next[temp];
		k++;
	}
	t-&gt;count+=num;
}

bool search(char* s,int num){  //查找字典树中是否已经存在num个字符串s
	int k=0,temp;
	treenode* t=&amp;head;
	while(s[k]){
		temp=charmapping[s[k]];
		if(!t-&gt;next[temp]||t-&gt;next[temp]-&gt;count&lt;num) return false; //根本不存在字符串s或者存在的数目小于num直接失败 
		t=t-&gt;next[temp];
		k++;
	}
	int snum=t-&gt;count;
	for(int i=0;i&lt;maxn;i++) if(t-&gt;next[i]) snum-=t-&gt;next[i]-&gt;count; //这里是核心!!!结点t代表的字符串出现的次数就是总次数减去所有子节点次数和 
	if(snum&gt;=num) return true; //如果字符串s的数目snum大于等于num 
	return false;
}

void erase(char* s,int num){  //删除字典树中的num个字符串s并释放无用结点,删除前一定要先search是否存在 
	int k=0,temp;
	treenode* t=&amp;head;
	treenode* t1; //t1后面的结点都是删除后需要被释放的 
	head.count-=num;
	while(s[k]){
		temp=charmapping[s[k]];
		t-&gt;next[temp]-&gt;count-=num;
		if(t-&gt;next[temp]-&gt;count==0){
			t1=t-&gt;next[temp];
			t-&gt;next[temp]=NULL;
			k++;
			break;
		}
		t=t-&gt;next[temp];
		k++;
	}
	while(s[k]){ //释放无用结点 
		temp=charmapping[s[k]];
		t=t1-&gt;next[temp];
		free(t1);
		t1=t;
		k++;
	}
	free(t1);
}

char temp[1000];
void printall(treenode* tnode,int pos){ //递归打印字典树咯,打出了就是字典序升序的 
	int count=tnode-&gt;count;
	for(int i=0;i&lt;maxn;i++) if(tnode-&gt;next[i]) count-=tnode-&gt;next[i]-&gt;count;
	for(int i=0;i&lt;count;i++) printf("\"%s\"\n",temp);
	for(int i='a';i&lt;='z';i++){
		if(tnode-&gt;next[charmapping[i]]){
			temp[pos]=i;
			temp[++pos]='\0';
			printall(tnode-&gt;next[charmapping[i]],pos);
			temp[--pos]='\0';
		}
	}
}

int main(){
	init_charmapping(); //初始化映射 
	init_trie();		//初始化字典树 
	char x[1000];
	char order; //命令 
	int num;    //数目 
	printf("q：查询\nu：插入\nd：删除\np：打印字典树\ne：退出\n");
	while(1){
		printf("请输入命令：");
		fflush(stdin);
		scanf("%c",&amp;order);
		if(order=='q'){
			printf("请输入要查找的字符串与数目：");
			scanf("%s%d",&amp;x,&amp;num);
			if(search(x,num)) printf("匹配成功。\n\n");
			else printf("匹配失败，不存在%d个\"%s\"\n\n",num,x); 
		}
		else if(order=='u'){
			printf("请输入要插入的字符串与数目：");
			scanf("%s%d",&amp;x,&amp;num);
			update(x,num);
			printf("%d个\"%s\"已加入字典树。\n\n",num,x);
		}
		else if(order=='d'){
			printf("请输入要删除的字符串与数目：");
			scanf("%s%d",&amp;x,&amp;num);
			if(!search(x,num)){
				printf("树中无%d个字符串\"%s\"请重新键入命令！\n\n",num,x);
				continue;
			}
			erase(x,num);
			printf("%d个\"%s\"已从字典树中删除。\n\n",num,x);
		}
		else if(order=='p'){
			printf("当前字典树内有如下字符串：\n");
			temp[0]='\0';
			printall(&amp;head,0);
		}
		else if(order=='e'){
			printf("退出ing....\n"); 
			break;
		}
		else printf("无效命令,请重新输入！\n命令q：查询是否存在字符串\n命令u：往字典树加入字符串\n命令d：删除某个字符串\n命令p：按字典序升序输出字典树\n命令e：退出程序\n\n"); 
	} 
	return 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/93391a4a7d72b4d4fc254d451f12f5c5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">yum update更新一半挂掉了，解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5fd0f2ca5a4b82ae6b0908ee8af67111/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">打印m行n列的星形矩形</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>