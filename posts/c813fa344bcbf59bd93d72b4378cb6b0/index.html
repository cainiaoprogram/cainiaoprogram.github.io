<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>轻松实现开放接口的签名和验签 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="轻松实现开放接口的签名和验签" />
<meta property="og:description" content="原创 一安 一安未来 2023-12-01 08:00 发表于北京
收录于合集#干货分享集191个
大家好，我是一安~
介绍 开放接口 开放接口是指不需要登录凭证就允许被第三方系统调用的接口，这个时候肯定要考虑接口数据的安全性问题，比如数据是否被篡改，数据是否已经过时，数据是否可以重复提交等问题，为了防止开放接口被恶意调用，开放接口一般都需要验签才能被调用。
验签 验签是指第三方系统在调用接口之前，需要按照接口提供方的规则根据所有请求参数生成一个签名（字符串），在调用接口时携带该签名。接口提供方会验证签名的有效性，只有签名验证有效才能正常调用接口，否则请求会被驳回。
大致流程 实战 这里只是演示，未真正区分开客户端和服务端
导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.15&lt;/version&gt; &lt;/dependency&gt; 自定义配置 私钥和公钥直接保存在文件中
spring: redis: host: localhost port: 6379 password: root database: 2 signature: enable: true key-pair: # 调用方ID test-1: # 算法 algorithm: SHA256withRSA # 私钥 private-key-path: classpath:signature/private # 公钥 public-key-path: classpath:signature/public # 生效时间(分钟) effective-time: 3 加载配置信息 @Data @ConditionalOnProperty(value = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c813fa344bcbf59bd93d72b4378cb6b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-01T10:06:11+08:00" />
<meta property="article:modified_time" content="2023-12-01T10:06:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">轻松实现开放接口的签名和验签</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>原创 一安 <a id="js_name">一安未来</a> <em id="publish_time">2023-12-01 08:00</em> <em id="js_ip_wording_wrp">发表于北京</em></p> 
<p>收录于合集#干货分享集191个</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="120" src="https://images2.imgbox.com/7c/a4/T3SXTDS9_o.gif" width="400"></p> 
<p>大家好，我是一安~</p> 
<h3>介绍</h3> 
<h4>开放接口</h4> 
<p>开放接口是指不需要登录凭证就允许被第三方系统调用的接口，这个时候肯定要考虑接口数据的安全性问题，比如数据是否被篡改，数据是否已经过时，数据是否可以重复提交等问题，为了防止开放接口被恶意调用，开放接口一般都需要验签才能被调用。</p> 
<h4>验签</h4> 
<p>验签是指第三方系统在调用接口之前，需要按照接口提供方的规则根据所有请求参数生成一个签名（字符串），在调用接口时携带该签名。接口提供方会验证签名的有效性，只有签名验证有效才能正常调用接口，否则请求会被驳回。</p> 
<h4>大致流程</h4> 
<p></p> 
<p class="img-center"><img alt="图片" height="578" src="https://images2.imgbox.com/33/0d/gv0dPUX7_o.png" width="615"></p> 
<h3>实战</h3> 
<blockquote> 
 <p>这里只是演示，未真正区分开客户端和服务端</p> 
</blockquote> 
<h4>导入依赖</h4> 
<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
        &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
        &lt;version&gt;5.7.13&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-codec&lt;/groupId&gt;
        &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
        &lt;version&gt;1.15&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre> 
<h4>自定义配置</h4> 
<blockquote> 
 <p>私钥和公钥直接保存在文件中</p> 
</blockquote> 
<pre><code>spring:
  redis:
    host: localhost
    port: 6379
    password: root
    database: 2

signature:
  enable: true
  key-pair:
    # 调用方ID
    test-1:
      # 算法
      algorithm: SHA256withRSA
      # 私钥
      private-key-path: classpath:signature/private
      # 公钥
      public-key-path: classpath:signature/public
      # 生效时间(分钟)
      effective-time: 3
</code></pre> 
<h4>加载配置信息</h4> 
<pre><code>@Data
@ConditionalOnProperty(value = "signature.enable", havingValue = "true")
@Component
@ConfigurationProperties("signature")
public class SignatureProps {

    private Boolean enable;
    private Map&lt;String, KeyPairProps&gt; keyPair;

    @Data
    public static class KeyPairProps {
        private SignAlgorithm algorithm;
        private String publicKeyPath;
        private String publicKey;
        private String privateKeyPath;
        private String privateKey;
        private Integer effectiveTime;
    }
}
</code></pre> 
<h4>签名管理类</h4> 
<pre><code>@ConditionalOnBean(SignatureProps.class)
@Component
public class SignatureManager {

    private final SignatureProps signatureProps;
    public SignatureManager(SignatureProps signatureProps) {
        this.signatureProps = signatureProps;
        loadKeyPairByPath();
    }
    
    public SignatureProps.KeyPairProps getKeyPairPropsByClientID(String clientID) {
        return signatureProps.getKeyPair().get(clientID);
    }   
    

    /**
     * 验签。验证不通过可能抛出运行时异常CryptoException
     *
     * @param clientID  调用方的唯一标识
     * @param rawData   原数据
     * @param signature 待验证的签名(十六进制字符串)
     * @return 验证是否通过
     */
    public boolean verifySignature(String clientID, String rawData, String signature) {
        Sign sign = getSignByClientID(clientID);
        if (ObjectUtils.isEmpty(sign)) {
            return false;
        }
        // 使用公钥验签
        return sign.verify(rawData.getBytes(StandardCharsets.UTF_8), HexUtil.decodeHex(signature));
    }

    /**
     * 生成签名
     *
     * @param clientID 调用方的唯一标识
     * @param rawData  原数据
     * @return 签名(十六进制字符串)
     */
    public String sign(String clientID, String rawData) {
        Sign sign = getSignByClientID(clientID);
        if (ObjectUtils.isEmpty(sign)) {
            return null;
        }
        return sign.signHex(rawData);
    }

    private Sign getSignByClientID(String clientID) {
        SignatureProps.KeyPairProps keyPairProps = signatureProps.getKeyPair().get(clientID);
        if (ObjectUtils.isEmpty(keyPairProps)) {
            return null; // 无效的、不受信任的调用方
        }
        return SecureUtil.sign(keyPairProps.getAlgorithm(), keyPairProps.getPrivateKey(), keyPairProps.getPublicKey());
    }

    /**
     * 加载非对称密钥对
     */
    private void loadKeyPairByPath() {
        // 支持类路径配置，形如：classpath:signature/public
        // 公钥和私钥都是base64编码后的字符串
        signatureProps.getKeyPair()
                .forEach((key, keyPairProps) -&gt; {
                    keyPairProps.setPublicKey(loadKeyByPath(keyPairProps.getPublicKeyPath()));
                    keyPairProps.setPrivateKey(loadKeyByPath(keyPairProps.getPrivateKeyPath()));
                    if (ObjectUtils.isEmpty(keyPairProps.getPublicKey()) ||
                            ObjectUtils.isEmpty(keyPairProps.getPrivateKey())) {
                        throw new RuntimeException("No public and private key files configured");
                    }
                });
    }

    private String loadKeyByPath(String path) {
        if (ObjectUtils.isEmpty(path)) {
            return null;
        }
        return IoUtil.readUtf8(ResourceUtil.getStream(path));
    }
}
</code></pre> 
<h4>自定义验签注解</h4> 
<blockquote> 
 <p>自定义验签注解，控制哪些接口需要验签</p> 
</blockquote> 
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface VerifySignature {
    boolean resubmit() default true;//允许重复请求
}
</code></pre> 
<h4>切面验签</h4> 
<pre><code>@ConditionalOnBean(SignatureProps.class)
@Component
@Slf4j
@Aspect
public class RequestSignatureAspect {

    @Resource
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    @Resource
    private SignatureManager signatureManager;

    @Pointcut("@annotation(org.example.sign.anno.VerifySignature)")
    public void signPointCut() {
    }

    @Before("signPointCut()")
    public void verifySignature(JoinPoint joinPoint) {
    
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();

        String clazz = joinPoint.getTarget().getClass().getName();
        String name = method.getName();

        VerifySignature verifySignature = method.getAnnotation(VerifySignature.class);
        if(!verifySignature.resubmit()&amp;&amp;!redisTemplate.opsForValue().setIfAbsent(clazz+":"+name,"1",10, TimeUnit.SECONDS)){
            throw new RuntimeException("不可重复提交");
        } 
    
        HttpServletRequest request = getHttpServletRequest();
        // 从请求头中提取调用法ID，不存在直接驳回
        String clientID = request.getHeader("clientID");
        if (ObjectUtils.isEmpty(clientID)) {
            throw new RuntimeException("不受信任的调用方");
        }

        // 从请求头中提取签名，不存在直接驳回
        String signature = request.getHeader("sign");
        if (ObjectUtils.isEmpty(signature)) {
            throw new RuntimeException("无效的签名");
        }
        
         // 从请求头中提取时间戳，不存在或者过期直接驳回
        String timestamp = request.getHeader("timestamp");
        if (ObjectUtils.isEmpty(timestamp) ||
                ChronoUnit.MINUTES.between(
                        LocalDateTime.ofInstant(Instant.ofEpochMilli(Long.parseLong(timestamp)), ZoneOffset.ofHours(8)),
                        LocalDateTime.now()
                ) &gt; signatureManager.getKeyPairPropsByClientID(clientID).getEffectiveTime()) {
            throw new RuntimeException("签名已过期");
        }


        // 提取请求参数
        String requestParamsStr = extractRequestParams(request);

        // 验签。验签不通过抛出业务异常
        verifySignature(clientID, requestParamsStr, signature);
    }

    /**
     * 由于body输入流只能读取一次，所以拦截器中不能直接读取body的输入流，否则会造成后续@RequestBody的参数解析器读取不到body，因此需要使用ContentCachingRequestWrapper包装请求，缓存body内容
     **/
    private String extractRequestParams(HttpServletRequest request) {
        // @RequestBody
        String body = null;
        if (request instanceof ContentCachingRequestWrapper) {
            ContentCachingRequestWrapper requestWrapper = (ContentCachingRequestWrapper) request;
            body = new String(requestWrapper.getContentAsByteArray(), StandardCharsets.UTF_8);
        }

        // @RequestParam
        Map&lt;String, String[]&gt; paramMap = request.getParameterMap();

        // @PathVariable
        ServletWebRequest webRequest = new ServletWebRequest(request, null);
        Map&lt;String, String&gt; uriTemplateVarNap = (Map&lt;String, String&gt;) webRequest.getAttribute(
                HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);

        return CommonUtils.extractRequestParams(body, paramMap, uriTemplateVarNap);
    }


    /**
     * 验证请求参数的签名
     */
    public void verifySignature(String clientID, String requestParamsStr, String signature) {
        try {
            boolean verified = signatureManager.verifySignature(clientID, requestParamsStr, signature);
            if (!verified) {
                throw new RuntimeException("The signature verification result is false.");
            }
        } catch (Exception ex) {
            log.error("Failed to verify signature", ex);
            throw new RuntimeException("业务异常");
        }
    }

    private HttpServletRequest getHttpServletRequest() {
        RequestAttributes ra = RequestContextHolder.getRequestAttributes();
        ServletRequestAttributes sra = (ServletRequestAttributes) ra;
        return sra.getRequest();
    }
}
</code></pre> 
<h4>工具类</h4> 
<pre><code>@Configuration
public class RedisConfig {
    @Autowired
    private RedisConnectionFactory factory;

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate() {
        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new StringRedisSerializer());
        redisTemplate.setConnectionFactory(factory);
        return redisTemplate;
    }

    @Bean
    public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForHash();
    }

    @Bean
    public ValueOperations&lt;String, String&gt; valueOperations(RedisTemplate&lt;String, String&gt; redisTemplate) {
        return redisTemplate.opsForValue();
    }

    @Bean
    public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForList();
    }

    @Bean
    public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForSet();
    }

    @Bean
    public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForZSet();
    }
}
</code></pre> 
<pre><code>public class CommonUtils {
    /**
     * 提取所有的请求参数，按照固定规则拼接成一个字符串
     *
     * @param body              post请求的请求体
     * @param paramMap          路径参数(QueryString)。形如：name=zhangsan&amp;age=18&amp;label=A&amp;label=B
     * @param uriTemplateVarNap 路径变量(PathVariable)。形如：/{name}/{age}
     * @return 所有的请求参数按照固定规则拼接成的一个字符串
     */
    public static String extractRequestParams(String body, Map&lt;String, String[]&gt; paramMap, Map&lt;String, String&gt; uriTemplateVarNap) {
        String paramStr = null;
        if (!ObjectUtils.isEmpty(paramMap)) {
            paramStr = paramMap.entrySet().stream()
                    .sorted(Map.Entry.comparingByKey())
                    .map(entry -&gt; {
                        // 拷贝一份按字典序升序排序
                        String[] sortedValue = Arrays.stream(entry.getValue()).sorted().toArray(String[]::new);
                        return entry.getKey() + "=" + joinStr(",", sortedValue);
                    })
                    .collect(Collectors.joining("&amp;"));
        }

        String uriVarStr = null;
        if (!ObjectUtils.isEmpty(uriTemplateVarNap)) {
            uriVarStr = joinStr(",", uriTemplateVarNap.values().stream().sorted().toArray(String[]::new));
        }

        // { userID: "xxx" }#name=zhangsan&amp;age=18&amp;label=A,B#zhangsan,18
        return joinStr("#", body, paramStr, uriVarStr);
    }

    /**
     * 使用指定分隔符，拼接字符串
     *
     * @param delimiter 分隔符
     * @param strs      需要拼接的多个字符串，可以为null
     * @return 拼接后的新字符串
     */
    public static String joinStr(String delimiter,String... strs) {
        if (ObjectUtils.isEmpty(strs)) {
            return StrUtil.EMPTY;
        }
        StringBuilder sbd = new StringBuilder();
        for (int i = 0; i &lt; strs.length; i++) {
            if (ObjectUtils.isEmpty(strs[i])) {
                continue;
            }
            sbd.append(strs[i].trim());
            if (!ObjectUtils.isEmpty(sbd) &amp;&amp; i &lt; strs.length - 1 &amp;&amp; !ObjectUtils.isEmpty(strs[i + 1])) {
                sbd.append(delimiter);
            }
        }
        return sbd.toString();
    }
}
</code></pre> 
<h4>request流只能获取一次</h4> 
<blockquote> 
 <p>如果接口是用<code>@RequestBody</code>来接受数据，在拦截器中需要使用读取<code>request</code>的输入流 ，但<code>ServletRequest</code>中<code>getReader()</code>和<code>getInputStream()</code>只能调用一次</p> 
</blockquote> 
<pre><code>@ConditionalOnBean(SignatureProps.class)
@Component
public class RequestCachingFilter extends OncePerRequestFilter {


    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        boolean isFirstRequest = !isAsyncDispatch(request);
        HttpServletRequest requestWrapper = request;
        if (isFirstRequest &amp;&amp; !(request instanceof ContentCachingRequestWrapper)) {
            requestWrapper = new ContentCachingRequestWrapper(request);
        }
        filterChain.doFilter(requestWrapper, response);
    }
}</code></pre> 
<h4>测试类</h4> 
<pre><code>@RestController
public class controller {

    @Resource
    private SignatureManager signatureManager;


    /**
     * 数据验签
    * 参数：{"name":"一安未来"}
    **/
    @VerifySignature(resubmit = false)
    @PostMapping("/sign1")
    public String sign1(@RequestBody Map&lt;String,String&gt; map){
        System.out.println(map);
        return "success";
    }

    /**
     *  数据签名
     * 参数：{"name":"一安未来"}
     **/
    @PostMapping("/sign2")
    public String sign2(@RequestBody Map&lt;String,String&gt; map, HttpServletRequest httpRequest){
        String clientID = httpRequest.getHeader("clientID");
        String mapToJsonString = String.format("{%s}", String.join(",", map.entrySet().stream()
                .map(e -&gt; String.format("\"%s\":\"%s\"", e.getKey(), e.getValue()))
                .collect(Collectors.toList())));
        return signatureManager.sign(clientID,mapToJsonString);
    }
}
</code></pre> 
<p></p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/f9/d4/ihtqLoZe_o.png" width="150"></p> 
<p><strong id="js_a11y_wx_profile_nickname">一安未来</strong></p> 
<p>致力于Java，大数据；心得交流，技术分享；</p> 
<p>122篇原创内容</p> 
<p>公众号</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/26531634abba08a16c39362e0d79224f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【开源】基于Vue.js的停车场收费系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8546a926bb05b67d74d0e6de0873f0ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL实现（免密登录）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>