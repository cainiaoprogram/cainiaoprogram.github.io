<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;多重继承中的内存模型 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;多重继承中的内存模型" />
<meta property="og:description" content="C&#43;&#43;多重继承中的内存模型 C&#43;&#43;语言通过引入虚函数表的形式来支持多态特性，并且为了解决多重继承中的冗余和二义性问题又引入了虚继承，这使得C&#43;&#43;类的内存模型呈现出一定的复杂性。
无虚函数时多重继承的内存模型 C&#43;&#43;要求所有实例化的对象都要有相应的内存地址，因此对一个不包含任何成员变量、成员函数的空类的实例会占用一个字节的内存空间。而非空类则按照以下规则安排其成员在内存中的排列顺序：
成员函数不占用内存空间
同一个类（不包括父类）中的成员变量在内存中按照在类中的声明次序依次排列，排列顺序与访问权限、变量名没有关系
继承自父类的成员变量排在当前类所有成员变量之前
继承自多个父类的成员变量按照类继承列表中的声明顺序依次排列每个父类中的成员变量
根据这些规则，定义下面这些类并限制他们间的继承关系，我们可以很容易的得出KTestClass类任一实例的内存模型：
class KTopClass { public: KTopClass() : m_iTopVar(0) { cout &lt;&lt; &#34;KTopClass constructed.&#34; &lt;&lt; endl; } private: int m_iTopVar; }; class KLBaseClass : public KTopClass { public: KLBaseClass() : m_iLVar(0) { cout &lt;&lt; &#34;KLBaseClass constructed.&#34; &lt;&lt; endl; } private: int m_iLVar; }; class KRBaseClass { public: KRBaseClass() : m_iRVar(0) { cout &lt;&lt; &#34;KRBaseClass constructed.&#34; &lt;&lt; endl; } private: int m_iRVar; }; class KTestClass : public KLBaseClass, public KRBaseClass { private: int m_iVar1; public: KTestClass() : m_iVar1(0), m_iVar2(0) { cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/69d633d4a87b8cce5ab1239db9ed8677/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-09-04T21:34:26+08:00" />
<meta property="article:modified_time" content="2016-09-04T21:34:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;多重继承中的内存模型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="c多重继承中的内存模型">C++多重继承中的内存模型</h2> 
<p>C++语言通过引入虚函数表的形式来支持多态特性，并且为了解决多重继承中的冗余和二义性问题又引入了虚继承，这使得C++类的内存模型呈现出一定的复杂性。</p> 
<hr> 
<h3 id="无虚函数时多重继承的内存模型"><strong>无虚函数时多重继承的内存模型</strong></h3> 
<p>C++要求所有实例化的对象都要有相应的内存地址，因此对一个不包含任何成员变量、成员函数的空类的实例会占用一个字节的内存空间。而非空类则按照以下规则安排其成员在内存中的排列顺序：</p> 
<ul><li><p>成员函数不占用内存空间</p></li><li><p>同一个类（不包括父类）中的成员变量在内存中按照在类中的声明次序依次排列，排列顺序与访问权限、变量名没有关系</p></li><li><p>继承自父类的成员变量排在当前类所有成员变量之前</p></li><li><p>继承自多个父类的成员变量按照类继承列表中的声明顺序依次排列每个父类中的成员变量</p></li></ul> 
<p>根据这些规则，定义下面这些类并限制他们间的继承关系，我们可以很容易的得出KTestClass类任一实例的内存模型：</p> 
<pre class="prettyprint"><code class="language-C++ hljs cs">class KTopClass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KTopClass</span>() : <span class="hljs-title">m_iTopVar</span>(0)
    {
        cout &lt;&lt; <span class="hljs-string">"KTopClass constructed."</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iTopVar;
};

class KLBaseClass : <span class="hljs-keyword">public</span> KTopClass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KLBaseClass</span>() : <span class="hljs-title">m_iLVar</span>(0)
    {
        cout &lt;&lt; <span class="hljs-string">"KLBaseClass constructed."</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iLVar;
};

class KRBaseClass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KRBaseClass</span>() : <span class="hljs-title">m_iRVar</span>(0)
    {
        cout &lt;&lt; <span class="hljs-string">"KRBaseClass constructed."</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iRVar;
};

class KTestClass : <span class="hljs-keyword">public</span> KLBaseClass, <span class="hljs-keyword">public</span> KRBaseClass
{
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iVar1;
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KTestClass</span>() : <span class="hljs-title">m_iVar1</span>(0), <span class="hljs-title">m_iVar2</span>(0) { cout &lt;&lt; <span class="hljs-string">"KTestClass constructed."</span> &lt;&lt; endl; }
    <span class="hljs-keyword">int</span> m_iVar2;
};</code></pre> 
<p><img src="https://images2.imgbox.com/3d/82/VOuYza0n_o.png" alt="KTestClass的实例内存模型" title=""></p> 
<h3 id="存在虚函数时多重继承的内存模型"><strong>存在虚函数时多重继承的内存模型</strong></h3> 
<p>为了支持多态特性，C++引用虚函数表，父类中的所有虚函数均列在虚函数表中（按照声明顺序，纯虚函数也不例外），子类首先继承父类的虚函数表（非虚继承），如果重写了某个虚函数，那么就用自己所重写的函数地址去覆盖继承下来的虚函数表中的对应虚函数的旧地址，这个旧地址可能是父类新定义的虚函数的地址，也可能是父类覆盖了父类的父类中的虚函数后的“新地址”，之后再将当前子类所新定义的虚函数依次加在父类虚函数表的后面。如果子类没有重写父类的虚函数，那么直接继承父类的虚函数表，并将当前子类所新定义的虚函数依次加在父类虚函数表的后面。处理完虚函数表后，然后再依次排列父类的成员变量。重复这个过程直到所有父类按照继承顺序依次处理完毕，然后再排列子类的成员变量，成员变量的排列规则同上一节所述。需要注意的是如果是多继承，那么子类的虚函数是接在第一个被继承的有虚函数的父类虚函数表后面的。</p> 
<p>举个较为复杂的例子来理解：</p> 
<pre class="prettyprint"><code class="language-C++ hljs cs">class KTopClass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KTopClass</span>() : <span class="hljs-title">m_iTopVar</span>(0)
    {
        cout &lt;&lt; <span class="hljs-string">"KTopClass constructed."</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> virtual_top_test(){ cout &lt;&lt; <span class="hljs-string">"KTopClass::virtual_top_test."</span> &lt;&lt; endl; }
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> pure_virtual_top_test() = <span class="hljs-number">0</span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iTopVar;
};

class KLBaseClass : <span class="hljs-keyword">public</span> KTopClass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KLBaseClass</span>() : <span class="hljs-title">m_iLVar</span>(0)
    {
        cout &lt;&lt; <span class="hljs-string">"KLBaseClass constructed."</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> virtual_lbase_test(){ cout &lt;&lt; <span class="hljs-string">"KLBaseClass::virtual_lbase_test."</span> &lt;&lt; endl; }
    <span class="hljs-keyword">void</span> pure_virtual_top_test()
    {
        cout &lt;&lt; <span class="hljs-string">"KLBaseClass::pure_virtual_top_test."</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iLVar;
};

class KRBaseClass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KRBaseClass</span>() : <span class="hljs-title">m_iRVar</span>(0)
    {
        cout &lt;&lt; <span class="hljs-string">"KRBaseClass constructed."</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> virtual_rbase_test(){ cout &lt;&lt; <span class="hljs-string">"KRBaseClass::virtual_rbase_test."</span> &lt;&lt; endl; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iRVar;
};

class KTestClass : <span class="hljs-keyword">public</span> KLBaseClass, <span class="hljs-keyword">public</span> KRBaseClass
{
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iVar1;
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KTestClass</span>() : <span class="hljs-title">m_iVar1</span>(0), <span class="hljs-title">m_iVar2</span>(0) { cout &lt;&lt; <span class="hljs-string">"KTestClass constructed."</span> &lt;&lt; endl; }
    <span class="hljs-keyword">void</span> virtual_lbase_test(){ cout &lt;&lt; <span class="hljs-string">"KTestClass::virtual_lbase_test."</span> &lt;&lt; endl; }
    <span class="hljs-keyword">int</span> m_iVar2;
};</code></pre> 
<p>内存模型如下：</p> 
<p><img src="https://images2.imgbox.com/ca/00/ITB0fzwU_o.png" alt="KTestClass的实例内存模型" title=""></p> 
<p>这个例子中一共有两张虚表，注意这里所说的虚表实际上是指向一个数组的指针，因此每一张虚表占用四个字节。</p> 
<h3 id="存在虚函数及虚继承时多重继承的内存模型"><strong>存在虚函数及虚继承时多重继承的内存模型</strong></h3> 
<p>存在虚继承的情况下，类实例的内存模型与没有虚继承的情况基本是相同的，但是要注意一个原则，即被虚继承的父类在子类中是共享的，而非虚继承的父类在每个子类中都有一份。如果要用一个例子来说明，我们可以先将上一节中的KRBaseClass类的声明修改一下，使其也继承自KTopClass类，其余部分保持不变，KRBaseClass 部分修改如下：</p> 
<pre class="prettyprint"><code class="language-C++ hljs cs">class KRBaseClass : <span class="hljs-keyword">public</span> KTopClass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KRBaseClass</span>() : <span class="hljs-title">m_iRVar</span>(0)
    {
        cout &lt;&lt; <span class="hljs-string">"KRBaseClass constructed."</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> virtual_rbase_test(){ cout &lt;&lt; <span class="hljs-string">"KRBaseClass::virtual_rbase_test."</span> &lt;&lt; endl; }
    <span class="hljs-keyword">void</span> pure_virtual_top_test()
    {
        cout &lt;&lt; <span class="hljs-string">"KRBaseClass::pure_virtual_top_test."</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iRVar;
};</code></pre> 
<p>这时的内存模型就变为：</p> 
<p><img src="https://images2.imgbox.com/0b/5f/Ys7iKUmU_o.png" alt="KTestClass的实例内存模型" title=""></p> 
<p>可见在KTestClass的实例中有两份KTopClass，这就是所谓的非虚继承的父类在每个子类中都有一份，这造成了一定的冗余和调用时的二义性，为了消除这种二义性，C++引入了虚继承，被虚继承的父类在子类中是共享的。可以设计如下的继承结构来说明这个问题：</p> 
<pre class="prettyprint"><code class="language-C++ hljs r">class B { /* <span class="hljs-keyword">...</span> */ };
class X : virtual public B { /* <span class="hljs-keyword">...</span> */ };
class Y : virtual public B { /* <span class="hljs-keyword">...</span> */ };
class Z : public B { /* <span class="hljs-keyword">...</span> */ };
class AA : public X, public Y, public Z { /* <span class="hljs-keyword">...</span> */ };</code></pre> 
<p><img src="https://images2.imgbox.com/93/00/gEnDgfCH_o.png" alt="继承示意图" title=""></p> 
<p>在实际的AA的实例中是有两份B的子对象的，其中一份由X、Y子对象共享，因为它们是虚继承自B类的，而另一份是来自于Z子对象的。</p> 
<p>我们还是回到最开始的例子中，我们将KLBaseClass类和KRBaseClass均改为虚继承自KTopClass类：</p> 
<pre class="prettyprint"><code class="language-C++ hljs cs">class KTopClass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KTopClass</span>() : <span class="hljs-title">m_iTopVar</span>(0)
    {
        cout &lt;&lt; <span class="hljs-string">"KTopClass constructed."</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> virtual_top_test(){ cout &lt;&lt; <span class="hljs-string">"KTopClass::virtual_top_test."</span> &lt;&lt; endl; }
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> pure_virtual_top_test() = <span class="hljs-number">0</span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iTopVar;
};

class KLBaseClass : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> KTopClass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KLBaseClass</span>() : <span class="hljs-title">m_iLVar</span>(0)
    {
        cout &lt;&lt; <span class="hljs-string">"KLBaseClass constructed."</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> virtual_lbase_test(){ cout &lt;&lt; <span class="hljs-string">"KLBaseClass::virtual_lbase_test."</span> &lt;&lt; endl; }
    <span class="hljs-keyword">void</span> virtual_top_test(){ cout &lt;&lt; <span class="hljs-string">"KLBaseClass::virtual_top_test."</span> &lt;&lt; endl; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iLVar;
};

class KRBaseClass : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> KTopClass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KRBaseClass</span>() : <span class="hljs-title">m_iRVar</span>(0)
    {
        cout &lt;&lt; <span class="hljs-string">"KRBaseClass constructed."</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> virtual_rbase_test(){ cout &lt;&lt; <span class="hljs-string">"KRBaseClass::virtual_rbase_test."</span> &lt;&lt; endl; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iRVar;
};

class KTestClass : <span class="hljs-keyword">public</span> KLBaseClass, <span class="hljs-keyword">public</span> KRBaseClass
{
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iVar1;
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">KTestClass</span>() : <span class="hljs-title">m_iVar1</span>(0), <span class="hljs-title">m_iVar2</span>(0) { cout &lt;&lt; <span class="hljs-string">"KTestClass constructed."</span> &lt;&lt; endl; }
    <span class="hljs-keyword">void</span> virtual_lbase_test(){ cout &lt;&lt; <span class="hljs-string">"KTestClass::virtual_lbase_test."</span> &lt;&lt; endl; }
    <span class="hljs-keyword">void</span> pure_virtual_top_test()
    {
        cout &lt;&lt; <span class="hljs-string">"KTestClass::pure_virtual_top_test."</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">int</span> m_iVar2;
};</code></pre> 
<p>此时KTestClass实例的内存模型变成了如下形式，即所有被虚继承的父类对应的子对象被统一放在了最后，实际上，不同编译器对放置位置的处理稍有不同，有的是将虚继承的子对象放在了子对象所有成员变量的最后面，有的则是放在了所有父类子对象之后，子类子对象之前。</p> 
<p><img src="https://images2.imgbox.com/ee/22/qfobrvCm_o.png" alt="KTestClass的实例内存模型" title=""></p> 
<p>到这里，很容易就会产生一个疑问，如果KLBaseClass和KRBaseClass中只有KRBaseClass是虚继承自KTopClass呢，实际上这种情况下，KRBaseClass所对应的那一份KTopClass子对象被放在最后，而KLBaseClass那一份仍按原来的规则存放。</p> 
<h3 id="总结"><strong>总结</strong></h3> 
<p>本文分别分析了有无虚函数以及虚继承情况下类对象的内存模型，从底层对C++的多态特性的实现进行了解释，但需要注意的是，实际中不同编译器下对内存模型的实现细节是稍有不同的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b1ed63c2804f84c52d915ae2419d063d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">view 生成 bitmap</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f8dc322913d96b1c340db30ef7b934e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android模拟器上网设置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>