<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>带你详细了解Vue中的v-for - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="带你详细了解Vue中的v-for" />
<meta property="og:description" content="v-for 作用： 列表渲染，所在标签结构，按照数据数量，循环生成。指令写在谁身上，就循环创建谁
语法：
v-for = &#34;(值变量，索引变量) in 目标结构&#34; ：key = 索引变量
v-for = &#34;值变量 in 目标结构 ：key = 索引变量&#34;
目标结构：可以是数组，对象，字符串
数组方法如果修改了原数据就会更新 页面，如果没有修改，则不会，但可以重新赋值给变量让你页面更新
v-for中的key作用：在更新的时候：
有key，按照key比较，key设置为index：等于没设，就地复用无key，就地更新 v-for中key
唯一不重复的字符串或者数值，数组中的id
key在使用过程中，有id用id，无id用索引
key的好处
可以提高更新的性能
v-set 作用：因为vue是数据驱动页面的，所以修改原数组中可以使用this.arr[0]=&#39;测试&#39;但是，由于官方vue2特有的bug，导致这样修改原数组失效，虽然数组确实改变了，但是页面直接没更新，如果需要这样修改数据，就需要$set方法来修改
方法：
this.$set(修改数组，索引，‘修改的内容’)
重绘和回流 重绘：元素的颜色/透明度发生变化回流：元素的几何信息（宽度/位置）发生变化回流是把结构重新画出来，重绘给你上色回流一定触发重绘，但重绘不一定会引起回流 虚拟DOM 含义：本质上是一个js对象，保存DOM关键信息
好处：提高DOM更新的性能，不频繁操作真实的DOM，在内存中找到变化部分，再更新真实DOM相应属性或内容（打补丁）
computed计算属性 语法:定义在computed中和data（）{}并齐
事例：
computed:{ totalPrice(){//计算属性名 set(val){ //在计算机属性被修改时执行 //val是计算属性赋的值 } get(){ //get在计算机属性被调用（访问）时执行 //必须return一个结果 } return this.count*this*this.price//返回运算结果 } } 缓存：计算属性，基于依赖项的值进行缓存，依赖的变量不变，都直接从缓存取结果（带缓存）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ef48e8d5eff1a8cf8439d994b0c3fdbf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-11T00:48:48+08:00" />
<meta property="article:modified_time" content="2022-04-11T00:48:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">带你详细了解Vue中的v-for</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="vfor_1"></a>v-for</h3> 
<ol start="0"><li> <p>作用： 列表渲染，所在标签结构，按照数据数量，循环生成。指令写在谁身上，就循环创建谁</p> </li><li> <p>语法：</p> <p><code>v-for = "(值变量，索引变量) in 目标结构" ：key = 索引变量</code></p> <p><code>v-for = "值变量 in 目标结构 ：key = 索引变量"</code></p> <p>目标结构：可以是数组，对象，字符串</p> </li><li> <p>数组方法如果修改了原数据就会更新 页面，如果没有修改，则不会，但可以重新赋值给变量让你页面更新</p> </li><li> <p>v-for中的key作用：在更新的时候：</p> 
  <ul><li>有key，按照key比较，key设置为index：等于没设，就地复用</li><li>无key，就地更新</li></ul> </li><li> <p>v-for中key</p> <p><em>唯一不重复的字符串或者数值，数组中的id</em></p> <p>key在使用过程中，有id用id，无id用索引</p> </li><li> <p>key的好处</p> <p>可以提高更新的性能</p> </li></ol> 
<h3><a id="vset_30"></a>v-set</h3> 
<ol start="0"><li> <p>作用：因为vue是数据驱动页面的，所以修改原数组中可以使用<code>this.arr[0]='测试'</code>但是，由于官方vue2特有的bug，导致这样修改原数组失效，虽然数组确实改变了，但是页面直接没更新，如果需要这样修改数据，就需要<code>$set</code>方法来修改</p> </li><li> <p>方法：</p> <p><code>this.$set(修改数组，索引，‘修改的内容’)</code></p> </li></ol> 
<h3><a id="_38"></a>重绘和回流</h3> 
<ul><li>重绘：元素的颜色/透明度发生变化</li><li>回流：元素的几何信息（宽度/位置）发生变化</li><li>回流是把结构重新画出来，重绘给你上色</li><li><em>回流一定触发重绘，但重绘不一定会引起回流</em></li></ul> 
<h3><a id="DOM_45"></a>虚拟DOM</h3> 
<p>含义：本质上是一个js对象，保存DOM关键信息</p> 
<p>好处：提高DOM更新的性能，不频繁操作真实的DOM，在内存中找到变化部分，再更新真实DOM相应属性或内容（打补丁）</p> 
<h3><a id="computed_50"></a>computed计算属性</h3> 
<ol start="0"><li> <p>语法:定义在computed中和data（）{}并齐</p> </li><li> <p>事例：</p> <pre><code>   computed:{
       totalPrice(){//计算属性名
         set(val){ //在计算机属性被修改时执行
             //val是计算属性赋的值
         }
         get(){  //get在计算机属性被调用（访问）时执行
         //必须return一个结果
         }
         return this.count*this*this.price//返回运算结果
       }
     }
</code></pre> </li><li> <p><em>缓存</em>：计算属性，基于依赖项的值进行缓存，依赖的变量不变，都<code>直接从缓存取结果</code>（带缓存）</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d069eda7213fade8be436f4809146d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用阿里云服务器安装宝塔面板搭建网站教程（图文全流程）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/28be5569d9fbca259681ba1898572c8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">学习记录05：一些常用的Latex符号,在csdn里也可以用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>