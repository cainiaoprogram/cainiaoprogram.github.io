<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>stm32mp157和imx6ull在设备树节点上设置ap3216c的主要区别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="stm32mp157和imx6ull在设备树节点上设置ap3216c的主要区别" />
<meta property="og:description" content="stm32mp157和imx6ull在设备树节点上设置ap3216c的主要区别是，它们使用的不同的硬件架构和不同的设备树格式。以下是两者之间的差异：
硬件架构：stm32mp157是基于ARM Cortex-M4内核的微控制器，而imx6ull则是基于ARM Cortex-A7内核的嵌入式处理器。
设备树格式：stm32mp157使用的设备树格式是Device Tree Compiler（DTC）格式，而imx6ull使用的是Flattened Device Tree（FDT）格式。
基于这些差异，设置ap3216c的设备树节点在两者之间有一些细微的差异。以下是一个示例：
stm32mp157设备树节点示例：
imx6ull设备树节点示例：
注意，在这两个示例中，ap3216c节点的名称和compatible属性都相同。
总体上来说，stm32mp157和imx6ull之间的差异在于它们所用的硬件架构和设备树格式，但在设置ap3216c设备树节点时，它们的区别不大。
备注：stm32mp157和imx6ull的ap3216c驱动是完全一样的，驱动代码如下：
ap3216creg.h：
#ifndef AP3216C_H
#define AP3216C_H
#define AP3216C_ADDR 0X1E /* AP3216C器件地址 */
/* AP3316C寄存器 /
#define AP3216C_SYSTEMCONG 0x00 / 配置寄存器 /
#define AP3216C_INTSTATUS 0X01 / 中断状态寄存器 /
#define AP3216C_INTCLEAR 0X02 / 中断清除寄存器 /
#define AP3216C_IRDATALOW 0x0A / IR数据低字节 /
#define AP3216C_IRDATAHIGH 0x0B / IR数据高字节 /
#define AP3216C_ALSDATALOW 0x0C / ALS数据低字节 /
#define AP3216C_ALSDATAHIGH 0X0D / ALS数据高字节 /" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5b9b270440ea334c82148abd03f4daec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-04T09:48:59+08:00" />
<meta property="article:modified_time" content="2023-12-04T09:48:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">stm32mp157和imx6ull在设备树节点上设置ap3216c的主要区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>stm32mp157和imx6ull在设备树节点上设置ap3216c的主要区别是，它们使用的不同的硬件架构和不同的设备树格式。以下是两者之间的差异：</p> 
<p>硬件架构：stm32mp157是基于ARM Cortex-M4内核的微控制器，而imx6ull则是基于ARM Cortex-A7内核的嵌入式处理器。</p> 
<p>设备树格式：stm32mp157使用的设备树格式是Device Tree Compiler（DTC）格式，而imx6ull使用的是Flattened Device Tree（FDT）格式。</p> 
<p>基于这些差异，设置ap3216c的设备树节点在两者之间有一些细微的差异。以下是一个示例：</p> 
<p>stm32mp157设备树节点示例：</p> 
<p><img src="https://images2.imgbox.com/45/58/qt2G5sSF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/19/c9/WaXGCuKp_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/92/45/5Q8X8q4S_o.png" alt="在这里插入图片描述"></p> 
<p>imx6ull设备树节点示例：</p> 
<p><img src="https://images2.imgbox.com/cb/47/clLbXqYY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7a/7d/PNGXL7rN_o.png" alt="在这里插入图片描述"></p> 
<p>注意，在这两个示例中，ap3216c节点的名称和compatible属性都相同。</p> 
<p>总体上来说，stm32mp157和imx6ull之间的差异在于它们所用的硬件架构和设备树格式，但在设置ap3216c设备树节点时，它们的区别不大。</p> 
<p>备注：stm32mp157和imx6ull的ap3216c驱动是完全一样的，驱动代码如下：<br> ap3216creg.h：<br> #ifndef AP3216C_H<br> #define AP3216C_H<br> #define AP3216C_ADDR 0X1E /* AP3216C器件地址 */</p> 
<p>/* AP3316C寄存器 <em>/<br> #define AP3216C_SYSTEMCONG 0x00 /</em> 配置寄存器 <em>/<br> #define AP3216C_INTSTATUS 0X01 /</em> 中断状态寄存器 <em>/<br> #define AP3216C_INTCLEAR 0X02 /</em> 中断清除寄存器 <em>/<br> #define AP3216C_IRDATALOW 0x0A /</em> IR数据低字节 <em>/<br> #define AP3216C_IRDATAHIGH 0x0B /</em> IR数据高字节 <em>/<br> #define AP3216C_ALSDATALOW 0x0C /</em> ALS数据低字节 <em>/<br> #define AP3216C_ALSDATAHIGH 0X0D /</em> ALS数据高字节 <em>/<br> #define AP3216C_PSDATALOW 0X0E /</em> PS数据低字节 <em>/<br> #define AP3216C_PSDATAHIGH 0X0F /</em> PS数据高字节 */</p> 
<p>#endif<br> ap3216c.c：<br> #include &lt;linux/types.h&gt;<br> #include &lt;linux/kernel.h&gt;<br> #include &lt;linux/delay.h&gt;<br> #include &lt;linux/ide.h&gt;<br> #include &lt;linux/init.h&gt;<br> #include &lt;linux/module.h&gt;<br> #include &lt;linux/errno.h&gt;<br> #include &lt;linux/gpio.h&gt;<br> #include &lt;linux/cdev.h&gt;<br> #include &lt;linux/device.h&gt;<br> #include &lt;linux/of_gpio.h&gt;<br> #include &lt;linux/semaphore.h&gt;<br> #include &lt;linux/timer.h&gt;<br> #include &lt;linux/i2c.h&gt;<br> #include &lt;asm/mach/map.h&gt;<br> #include &lt;asm/uaccess.h&gt;<br> #include &lt;asm/io.h&gt;<br> #include “ap3216creg.h”</p> 
<p>#define AP3216C_CNT 1<br> #define AP3216C_NAME “ap3216c”</p> 
<p>struct ap3216c_dev {<!-- --><br> struct i2c_client <em>client; /</em> i2c 设备 <em>/<br> dev_t devid; /</em> 设备号 <em>/<br> struct cdev cdev; /</em> cdev */<br> struct class <em>class; /</em> 类 */<br> struct device <em>device; /</em> 设备 */<br> struct device_node <em>nd; /</em> 设备节点 <em>/<br> unsigned short ir, als, ps; /</em> 三个光传感器数据 */<br> };</p> 
<p>/*</p> 
<ul><li> <p>@description : 从ap3216c读取多个寄存器数据</p> </li><li> <p>@param - dev: ap3216c设备</p> </li><li> <p>@param - reg: 要读取的寄存器首地址</p> </li><li> <p>@param - val: 读取到的数据</p> </li><li> <p>@param - len: 要读取的数据长度</p> </li><li> <p>@return : 操作结果<br> */<br> static int ap3216c_read_regs(struct ap3216c_dev *dev, u8 reg, void *val, int len)<br> {<!-- --><br> int ret;<br> struct i2c_msg msg[2];<br> struct i2c_client *client = (struct i2c_client *)dev-&gt;client;</p> <p>/* msg[0]为发送要读取的首地址 <em>/<br> msg[0].addr = client-&gt;addr; /</em> ap3216c地址 <em>/<br> msg[0].flags = 0; /</em> 标记为发送数据 <em>/<br> msg[0].buf = ® /</em> 读取的首地址 <em>/<br> msg[0].len = 1; /</em> reg长度*/</p> <p>/* msg[1]读取数据 <em>/<br> msg[1].addr = client-&gt;addr; /</em> ap3216c地址 <em>/<br> msg[1].flags = I2C_M_RD; /</em> 标记为读取数据*/<br> msg[1].buf = val; /* 读取数据缓冲区 <em>/<br> msg[1].len = len; /</em> 要读取的数据长度*/</p> <p>ret = i2c_transfer(client-&gt;adapter, msg, 2);<br> if(ret == 2) {<!-- --><br> ret = 0;<br> } else {<!-- --><br> printk(“i2c rd failed=%d reg=%06x len=%d\n”,ret, reg, len);<br> ret = -EREMOTEIO;<br> }<br> return ret;<br> }</p> </li></ul> 
<p>/*</p> 
<ul><li> <p>@description : 向ap3216c多个寄存器写入数据</p> </li><li> <p>@param - dev: ap3216c设备</p> </li><li> <p>@param - reg: 要写入的寄存器首地址</p> </li><li> <p>@param - val: 要写入的数据缓冲区</p> </li><li> <p>@param - len: 要写入的数据长度</p> </li><li> <p>@return : 操作结果<br> */<br> static s32 ap3216c_write_regs(struct ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)<br> {<!-- --><br> u8 b[256];<br> struct i2c_msg msg;<br> struct i2c_client *client = (struct i2c_client *)dev-&gt;client;</p> <p>b[0] = reg; /* 寄存器首地址 <em>/<br> memcpy(&amp;b[1],buf,len); /</em> 将要写入的数据拷贝到数组b里面 */</p> <p>msg.addr = client-&gt;addr; /* ap3216c地址 <em>/<br> msg.flags = 0; /</em> 标记为写数据 */</p> <p>msg.buf = b; /* 要写入的数据缓冲区 <em>/<br> msg.len = len + 1; /</em> 要写入的数据长度 */</p> <p>return i2c_transfer(client-&gt;adapter, &amp;msg, 1);<br> }</p> </li></ul> 
<p>/*</p> 
<ul><li> <p>@description : 读取ap3216c指定寄存器值，读取一个寄存器</p> </li><li> <p>@param - dev: ap3216c设备</p> </li><li> <p>@param - reg: 要读取的寄存器</p> </li><li> <p>@return : 读取到的寄存器值<br> */<br> static unsigned char ap3216c_read_reg(struct ap3216c_dev *dev, u8 reg)<br> {<!-- --><br> u8 data = 0;</p> <p>ap3216c_read_regs(dev, reg, &amp;data, 1);<br> return data;<br> }</p> </li></ul> 
<p>/*</p> 
<ul><li>@description : 向ap3216c指定寄存器写入指定的值，写一个寄存器</li><li>@param - dev: ap3216c设备</li><li>@param - reg: 要写的寄存器</li><li>@param - data: 要写入的值</li><li>@return : 无<br> */<br> static void ap3216c_write_reg(struct ap3216c_dev *dev, u8 reg, u8 data)<br> {<!-- --><br> u8 buf = 0;<br> buf = data;<br> ap3216c_write_regs(dev, reg, &amp;buf, 1);<br> }</li></ul> 
<p>/*</p> 
<ul><li> <p>@description : 读取AP3216C的数据，读取原始数据，包括ALS,PS和IR, 注意！</p> </li><li> <pre><code> 		: 如果同时打开ALS,IR+PS的话两次数据读取的时间间隔要大于112.5ms
</code></pre> </li><li> <p>@param - ir : ir数据</p> </li><li> <p>@param - ps : ps数据</p> </li><li> <p>@param - ps : als数据</p> </li><li> <p>@return : 无。<br> */<br> void ap3216c_readdata(struct ap3216c_dev *dev)<br> {<!-- --><br> unsigned char i =0;<br> unsigned char buf[6];</p> <p>/* 循环读取所有传感器数据 */<br> for(i = 0; i &lt; 6; i++) {<!-- --><br> buf[i] = ap3216c_read_reg(dev, AP3216C_IRDATALOW + i); <br> }</p> <p>if(buf[0] &amp; 0X80) /* IR_OF位为1,则数据无效 <em>/<br> dev-&gt;ir = 0; <br> else /</em> 读取IR传感器的数据 */<br> dev-&gt;ir = ((unsigned short)buf[1] &lt;&lt; 2) | (buf[0] &amp; 0X03);</p> <p>dev-&gt;als = ((unsigned short)buf[3] &lt;&lt; 8) | buf[2]; /* 读取ALS传感器的数据 */</p> <p>if(buf[4] &amp; 0x40) /* IR_OF位为1,则数据无效 <em>/<br> dev-&gt;ps = 0; <br> else /</em> 读取PS传感器的数据 */<br> dev-&gt;ps = ((unsigned short)(buf[5] &amp; 0X3F) &lt;&lt; 4) | (buf[4] &amp; 0X0F);<br> }</p> </li></ul> 
<p>/*</p> 
<ul><li> <p>@description : 打开设备</p> </li><li> <p>@param - inode : 传递给驱动的inode</p> </li><li> <p>@param - filp : 设备文件，file结构体有个叫做private_data的成员变量</p> </li><li> <pre><code> 			  一般在open的时候将private_data指向设备结构体。
</code></pre> </li><li> <p>@return : 0 成功;其他 失败<br> */<br> static int ap3216c_open(struct inode *inode, struct file <em>filp)<br> {<!-- --><br> /</em> 从file结构体获取cdev的指针，在根据cdev获取ap3216c_dev结构体的首地址 */<br> struct cdev *cdev = filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_cdev;<br> struct ap3216c_dev *ap3216cdev = container_of(cdev, struct ap3216c_dev, cdev);</p> <p>/* 初始化AP3216C <em>/<br> ap3216c_write_reg(ap3216cdev, AP3216C_SYSTEMCONG, 0x04); /</em> 复位AP3216C <em>/<br> mdelay(50); /</em> AP3216C复位最少10ms <em>/<br> ap3216c_write_reg(ap3216cdev, AP3216C_SYSTEMCONG, 0X03); /</em> 开启ALS、PS+IR */<br> return 0;<br> }</p> </li></ul> 
<p>/*</p> 
<ul><li> <p>@description : 从设备读取数据</p> </li><li> <p>@param - filp : 要打开的设备文件(文件描述符)</p> </li><li> <p>@param - buf : 返回给用户空间的数据缓冲区</p> </li><li> <p>@param - cnt : 要读取的数据长度</p> </li><li> <p>@param - offt : 相对于文件首地址的偏移</p> </li><li> <p>@return : 读取的字节数，如果为负值，表示读取失败<br> */<br> static ssize_t ap3216c_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)<br> {<!-- --><br> short data[3];<br> long err = 0;</p> <p>struct cdev *cdev = filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_cdev;<br> struct ap3216c_dev *dev = container_of(cdev, struct ap3216c_dev, cdev);</p> <p>ap3216c_readdata(dev);</p> <p>data[0] = dev-&gt;ir;<br> data[1] = dev-&gt;als;<br> data[2] = dev-&gt;ps;<br> err = copy_to_user(buf, data, sizeof(data));<br> return 0;<br> }</p> </li></ul> 
<p>/*</p> 
<ul><li>@description : 关闭/释放设备</li><li>@param - filp : 要关闭的设备文件(文件描述符)</li><li>@return : 0 成功;其他 失败<br> */<br> static int ap3216c_release(struct inode *inode, struct file *filp)<br> {<!-- --><br> return 0;<br> }</li></ul> 
<p>/* AP3216C操作函数 */<br> static const struct file_operations ap3216c_ops = {<!-- --><br> .owner = THIS_MODULE,<br> .open = ap3216c_open,<br> .read = ap3216c_read,<br> .release = ap3216c_release,<br> };</p> 
<p>/*</p> 
<ul><li> <p>@description : i2c驱动的probe函数，当驱动与</p> </li><li> <pre><code>               设备匹配以后此函数就会执行
</code></pre> </li><li> <p>@param - client : i2c设备</p> </li><li> <p>@param - id : i2c设备ID</p> </li><li> <p>@return : 0，成功;其他负值,失败<br> */<br> static int ap3216c_probe(struct i2c_client *client, const struct i2c_device_id *id)<br> {<!-- --><br> int ret;<br> struct ap3216c_dev *ap3216cdev;</p> <p>/* */<br> ap3216cdev = devm_kzalloc(&amp;client-&gt;dev, sizeof(*ap3216cdev), GFP_KERNEL);<br> if(!ap3216cdev)<br> return -ENOMEM;</p> <p>/* 注册字符设备驱动 <em>/<br> /</em> 1、创建设备号 */<br> ret = alloc_chrdev_region(&amp;ap3216cdev-&gt;devid, 0, AP3216C_CNT, AP3216C_NAME);<br> if(ret &lt; 0) {<!-- --><br> pr_err(“%s Couldn’t alloc_chrdev_region, ret=%d\r\n”, AP3216C_NAME, ret);<br> return -ENOMEM;<br> }</p> <p>/* 2、初始化cdev */<br> ap3216cdev-&gt;cdev.owner = THIS_MODULE;<br> cdev_init(&amp;ap3216cdev-&gt;cdev, &amp;ap3216c_ops);</p> <p>/* 3、添加一个cdev */<br> ret = cdev_add(&amp;ap3216cdev-&gt;cdev, ap3216cdev-&gt;devid, AP3216C_CNT);<br> if(ret &lt; 0) {<!-- --><br> goto del_unregister;<br> }</p> <p>/* 4、创建类 */<br> ap3216cdev-&gt;class = class_create(THIS_MODULE, AP3216C_NAME);<br> if (IS_ERR(ap3216cdev-&gt;class)) {<!-- --><br> goto del_cdev;<br> }</p> <p>/* 5、创建设备 <em>/<br> ap3216cdev-&gt;device = device_create(ap3216cdev-&gt;class, NULL, ap3216cdev-&gt;devid, NULL, AP3216C_NAME);<br> if (IS_ERR(ap3216cdev-&gt;device)) {<!-- --><br> goto destroy_class;<br> }<br> ap3216cdev-&gt;client = client;<br> /</em> 保存ap3216cdev结构体 */<br> i2c_set_clientdata(client,ap3216cdev);</p> <p>return 0;<br> destroy_class:<br> device_destroy(ap3216cdev-&gt;class, ap3216cdev-&gt;devid);<br> del_cdev:<br> cdev_del(&amp;ap3216cdev-&gt;cdev);<br> del_unregister:<br> unregister_chrdev_region(ap3216cdev-&gt;devid, AP3216C_CNT);<br> return -EIO;<br> }</p> </li></ul> 
<p>/*</p> 
<ul><li>@description : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</li><li>@param - client : i2c设备</li><li>@return : 0，成功;其他负值,失败<br> */<br> static int ap3216c_remove(struct i2c_client *client)<br> {<!-- --><br> struct ap3216c_dev <em>ap3216cdev = i2c_get_clientdata(client);<br> /</em> 注销字符设备驱动 <em>/<br> /</em> 1、删除cdev <em>/<br> cdev_del(&amp;ap3216cdev-&gt;cdev);<br> /</em> 2、注销设备号 <em>/<br> unregister_chrdev_region(ap3216cdev-&gt;devid, AP3216C_CNT);<br> /</em> 3、注销设备 <em>/<br> device_destroy(ap3216cdev-&gt;class, ap3216cdev-&gt;devid);<br> /</em> 4、注销类 */<br> class_destroy(ap3216cdev-&gt;class);<br> return 0;<br> }</li></ul> 
<p>/* 传统匹配方式ID列表 */<br> static const struct i2c_device_id ap3216c_id[] = {<!-- --><br> {“ap3216c”, 0},<br> {}<br> };</p> 
<p>/* 设备树匹配列表 <em>/<br> static const struct of_device_id ap3216c_of_match[] = {<!-- --><br> { .compatible = “alientek,ap3216c” },<br> { /</em> Sentinel */ }<br> };</p> 
<p>/* i2c驱动结构体 */ <br> static struct i2c_driver ap3216c_driver = {<!-- --><br> .probe = ap3216c_probe,<br> .remove = ap3216c_remove,<br> .driver = {<!-- --><br> .owner = THIS_MODULE,<br> .name = “ap3216c”,<br> .of_match_table = ap3216c_of_match,<br> },<br> .id_table = ap3216c_id,<br> };</p> 
<p>/*</p> 
<ul><li> <p>@description : 驱动入口函数</p> </li><li> <p>@param : 无</p> </li><li> <p>@return : 无<br> */<br> static int __init ap3216c_init(void)<br> {<!-- --><br> int ret = 0;</p> <p>ret = i2c_add_driver(&amp;ap3216c_driver);<br> return ret;<br> }</p> </li></ul> 
<p>/*</p> 
<ul><li>@description : 驱动出口函数</li><li>@param : 无</li><li>@return : 无<br> */<br> static void __exit ap3216c_exit(void)<br> {<!-- --><br> i2c_del_driver(&amp;ap3216c_driver);<br> }</li></ul> 
<p>/* module_i2c_driver(ap3216c_driver) */</p> 
<p>module_init(ap3216c_init);<br> module_exit(ap3216c_exit);<br> MODULE_LICENSE(“GPL”);<br> MODULE_AUTHOR(“ALIENTEK”);<br> MODULE_INFO(intree, “Y”);</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01b6269fee9ecc56e252abf1dd14c8f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RT-Thread 汇编分析启动流程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90a81d3dfa96abaebc4211e763a0c89d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">netcat瑞士军刀（正向shell和反向shell）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>