<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>综述：解决目标检测中的样本不均衡问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="综述：解决目标检测中的样本不均衡问题" />
<meta property="og:description" content="点击上方“小白学视觉”，选择加&#34;星标&#34;或“置顶”
重磅干货，第一时间送达 作者丨SFXiang
来源丨AI算法修炼营
编辑丨极市平台
极市导读
本文对目标检测中的样本不均衡问题类别进行了详细叙述，介绍了包括OHEM、S-OHEM、Focal loss、GHM等在内的几种主要方法，并梳理了它们的思路和优缺点。
前面的话
当前主流的物体检测算法，如Faster RCNN和SSD等，都是将目标检测当做分类问题来考虑，即先使用先验框或者RPN等生成感兴趣的区域，再对该区域进行分类与回归位置。这种基于分类思想的目标检测算法存在样本不平衡的问题，因而会降低模型的训练效率与检测精度。‍‍‍‍‍‍‍‍‍‍
‍‍‍‍‍‍‍‍‍‍
本文主要介绍如何解决样本不均衡问题。
解决样本不均衡问题
当前基于深度学习的目标检测主要包括：基于two-stage的目标检测和基于one-stage的目标检测。two-stage的目标检测框架一般检测精度相对较高，但检测速度慢；而one-stage的目标检测速度相对较快，但是检测精度相对较低。one-stage的精度不如two-stage的精度，一个主要的原因是训练过程中样本极度不均衡造成的。
定义
样本不均衡问题：指在训练的时候各个类别的样本数量不均衡，由于检测算法各不相同，以及数据集之间的差异，可能会存在正负样本、难易样本、类别间样本这3种不均衡问题。一般在目标检测任务框架中，保持正负样本的比例为1:3（经验值）。
样本不平衡实际上是一种非常常见的现象。比如：在欺诈交易检测，欺诈交易的订单应该是占总交易数量极少部分；工厂中产品质量检测问题，合格产品的数量应该是远大于不合格产品的；信用卡的征信问题中往往就是正样本居多。
目标检测任务中，样本包括哪些类别
正样本：标签区域内的图像区域，即目标图像块
负样本：标签区域以外的图像区域，即图像背景区域
易分正样本：容易正确分类的正样本，在实际训练过程中，该类占总体样本的比重非常高，单个样本的损失函数较小，但是累计的损失函数会主导损失函数
易分负样本：容易正确分类的负样本，在实际训练过程中，该类占的比重非常高，单个样本的损失函数较小，但是累计的损失函数会主导损失函数
难分正样本：错分成负样本的正样本，这部分样本在训练过程中单个样本的损失函数较高，但是该类占总体样本的比例较小
难分负样本：错分成正样本的负样本，这部分样本在训练过程中单个样本的损失函数教高，但是该类占总体样本的比例教小
1.正负样本不均衡
以Faster RCNN为例，在RPN部分会生成20000个左右的Anchor，由于一张图中通常有10个左右的物体，导致可能只有100个左右的Anchor会是正样本，正负样本比例约为1∶200，存在严重的不均衡。
对于目标检测算法，主要需要关注的是对应着真实物体的正样本，在训练时会根据其loss来调整网络参数。相比之下，负样本对应着图像的背景，如果有大量的负样本参与训练，则会淹没正样本的损失，从而降低网络收敛的效率与检测精度。
2.难易样本不均衡
难样本指的是分类不太明确的边框，处在前景与背景的过渡区域上，在网络训练中难样本损失会较大，也是我们希望模型去学习优化的样本，利用这部分训练可以提升检测的准确率。
然而，大量的样本并非处在前景与背景的过渡区，而是与真实物体没有重叠区域的负样本，或者与真实物体重叠程度很高的正样本，这部分被称为简单样本，单个损失会较小，对参数收敛的作用有限。
虽然简单样本单个损失小，但由于数量众多，因此如果全都计算损失的话，其损失也会比难样本大很多，这种难易样本的不均衡也会影响模型的收敛与精度。
值得注意的是，由于负样本中大量的是简单样本，导致难易样本与正负样本这两个不均衡问题有一定的重叠，解决方法往往能同时对这两个问题起作用。
3.类别间样本不均衡
在有些目标检测的数据集中，还会存在类别间的不均衡问题。举个例子，数据集中有100万个车辆、1000个行人的实例标签，样本比例为1000∶1，属于典型的类别不均衡。
这种情况下，如果不做任何处理，使用该数据集进行训练，由于行人这一类别可参考标签太少，会使得模型主要关注车这一类别的检测，网络中的参数主要根据车辆的损失进行优化，导致行人的检测精度大大下降。
目前，解决样本不均衡问题的一些思路：
机器学习中，解决样本不均衡问题主要有2种思路：数据角度和算法角度。从数据角度出发，有扩大数据集、数据类别均衡采样等方法。在算法层面，目标检测方法使用的方法主要有：
Faster RCNN、SSD等算法在正负样本的筛选时，根据样本与真实物体的IoU大小，设置了3∶1的正负样本比例，这一点缓解了正负样本的不均衡，同时也对难易样本不均衡起到了作用。
Faster RCNN在RPN模块中，通过前景得分排序筛选出了2000个左右的候选框，这也会将大量的负样本与简单样本过滤掉，缓解了前两个不均衡问题。
权重惩罚：对于难易样本与类别间的不均衡，可以增大难样本与少类别的损失权重，从而增大模型对这些样本的惩罚，缓解不均衡问题。
数据增强：从数据侧入手，可以在当前数据集上使用随机生成和添加扰动的方法，也可以利用网络爬虫数据等增加数据集的丰富性，从而缓解难易样本和类别间样本等不均衡问题，可以参考SSD的数据增强方法。
近年来，不少的研究者针对样本不均衡问题进行了深入研究，比较典型的有OHEM（在线困难样本挖掘）、S-OHEM、Focal Loss、GHM（梯度均衡化）。下面将详细介绍：
1 OHEM：在线难例挖掘
OHEM算法（online hard example miniing，发表于2016年的CVPR）主要是针对训练过程中的困难样本自动选择，其核心思想是根据输入样本的损失进行筛选，筛选出困难样本（即对分类和检测影响较大的样本），然后将筛选得到的这些样本应用在随机梯度下降中训练。
传统的Fast RCNN系列算法在正负样本选择的时候采用当前RoI与真实物体的IoU阈值比较的方法，这样容易忽略一些较为重要的难负样本，并且固定了正、负样本的比例与最大数量，显然不是最优的选择。以此为出发点，OHEM将交替训练与SGD优化方法进行了结合，在每张图片的RoI中选择了较难的样本，实现了在线的难样本挖掘。
OHEM实现在线难样本挖掘的网络如上图所示。图中包含了两个相同的RCNN网络，上半部的a部分是只可读的网络，只进行前向运算；下半部的b网络即可读也可写，需要完成前向计算与反向传播。
在一个batch的训练中，基于Fast RCNN的OHEM算法可以分为以下5步：
（1）按照原始Fast RCNN算法，经过卷积提取网络与RoI Pooling得到了每一张图像的RoI。
（2）上半部的a网络对所有的RoI进行前向计算，得到每一个RoI的损失。
（3）对RoI的损失进行排序，进行一步NMS操作，以去除掉重叠严重的RoI，并在筛选后的RoI中选择出固定数量损失较大的部分，作为难样本。
（4）将筛选出的难样本输入到可读写的b网络中，进行前向计算，得到损失。
（5）利用b网络得到的反向传播更新网络，并将更新后的参数与上半部的a网络同步，完成一次迭代。
当然，为了实现方便，OHEM的简单实现可以是：在原有的Fast-RCNN里的loss layer里面对所有的props计算其loss，根据loss对其进行排序，选出K个hard examples，反向传播时，只对这K个props的梯度/残差回传，而其他的props的梯度/残差设为0。
但是，由于其特殊的损失计算方式，把简单的样本都舍弃了，导致模型无法提升对于简单样本的检测精度，这也是OHEM方法的一个弊端。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f157fa172240c38adbcddc2c85b848ca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-12T10:05:00+08:00" />
<meta property="article:modified_time" content="2021-12-12T10:05:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">综述：解决目标检测中的样本不均衡问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:center;">点击上方“<strong><strong>小白学视觉</strong></strong>”，选择加"<strong>星标</strong>"或“<strong>置顶</strong>”</p> 
 <pre class="has"><code class="language-go">重磅干货，第一时间送达</code></pre> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/dc/ec/i83FUsRc_o.gif" alt="dbfd71e98d1570982aeeadaf11c72800.gif"><br></p> 
 <p style="text-align:left;">作者丨SFXiang</p> 
 <p style="text-align:left;">来源丨AI算法修炼营</p> 
 <p style="text-align:left;">编辑丨极市平台</p> 
 <p><span title=""></span></p> 
 <p><strong>极市导读</strong></p>  
 <p>本文对目标检测中的样本不均衡问题类别进行了详细叙述，介绍了包括OHEM、S-OHEM、Focal loss、GHM等在内的几种主要方法，并梳理了它们的思路和优缺点。</p> 
 <h2><br></h2> 
 <p><strong>前面的话</strong></p> 
 <p>当前主流的物体检测算法，如Faster RCNN和SSD等，都是将目标检测当做分类问题来考虑，即先使用先验框或者RPN等生成感兴趣的区域，再对该区域进行分类与回归位置。这种<strong>基于分类思想的目标检测算法存在样本不平衡的问题，因而会降低模型的训练效率与检测精度。</strong>‍‍‍‍‍‍‍‍‍‍<br>‍‍‍‍‍‍‍‍‍‍</p> 
 <p>本文主要介绍如何解决样本不均衡问题。</p> 
 <p><strong>解决样本不均衡问题</strong></p> 
 <h2></h2> 
 <p>当前基于深度学习的目标检测主要包括：基于two-stage的目标检测和基于one-stage的目标检测。two-stage的目标检测框架一般检测精度相对较高，但检测速度慢；而one-stage的目标检测速度相对较快，但是检测精度相对较低。<strong>one-stage的精度不如two-stage的精度，一个主要的原因是</strong><strong>训练过程中样本极度不均衡造成的。</strong></p> 
 <p><strong>定义</strong></p> 
 <p>样本不均衡问题：指在训练的时候各个类别的样本数量不均衡，由于检测算法各不相同，以及数据集之间的差异，可能会存在<strong>正负样本、难易样本、类别间样本</strong>这3种不均衡问题。一般在目标检测任务框架中，保持正负样本的比例为1:3（经验值）。</p> 
 <p>样本不平衡实际上是一种非常常见的现象。比如：在欺诈交易检测，欺诈交易的订单应该是占总交易数量极少部分；工厂中产品质量检测问题，合格产品的数量应该是远大于不合格产品的；信用卡的征信问题中往往就是正样本居多。</p> 
 <p>目标检测任务中，样本包括哪些类别</p> 
 <ul><li><p>正样本：<strong>标签区域内</strong>的图像区域，即目标图像块</p></li><li><p>负样本：<strong>标签区域以外</strong>的图像区域，即图像背景区域</p></li><li><p>易分正样本：容易正确分类的正样本，在实际训练过程中，<strong>该类占总体样本的比重非常高，单个样本的损失函数较小</strong>，但是累计的损失函数会主导损失函数</p></li><li><p>易分负样本：容易正确分类的负样本，在实际训练过程中，<strong>该类占的比重非常高</strong>，单个样本的损失函数较小，但是累计的损失函数会主导损失函数</p></li><li><p>难分正样本：错分成负样本的正样本，这部分样本在训练过程中单个样本的损失函数较高，但是<strong>该类占总体样本的比例较小</strong></p></li><li><p>难分负样本：错分成正样本的负样本，这部分样本在训练过程中单个样本的损失函数教高，但是该类占总体样本的比例教小</p></li></ul> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/89/7f/mY1K9hTG_o.png" alt="4747f29ffd713ee5866bb1295facfb0d.png"></p> 
 <p><strong>1.正负样本不均衡</strong></p> 
 <p>以Faster RCNN为例，在RPN部分会生成20000个左右的Anchor，由于一张图中通常有10个左右的物体，<strong>导致可能只有100个左右的Anchor会是正样本，正负样本比例约为1∶200，存在严重的不均衡。</strong></p> 
 <p>对于目标检测算法，主要需要关注的是对应着真实物体的<strong>正样本</strong>，在训练时会根据其loss来调整网络参数。相比之下，<strong>负样本对应着图像的背景，如果有大量的负样本参与训练，则会淹没正样本的损失，从而降低网络收敛的效率与检测精度。</strong></p> 
 <p><strong>2.难易样本不均衡</strong></p> 
 <p>难样本指的是<strong>分类不太明确的边框，处在前景与背景的过渡区域上</strong>，在网络训练中难样本损失会较大，也是我们希望模型去学习优化的样本，利<strong>用这部分训练可以提升检测的准确率。</strong></p> 
 <p>然而，大量的样本并非处在前景与背景的过渡区，而是<strong>与真实物体没有重叠区域的负样本，或者与真实物体重叠程度很高的正样本，</strong>这部分被称为<strong>简单样本，</strong>单个损失会较小，对参数收敛的作用有限。</p> 
 <p>虽然简单样本单个损失小，但由于数量众多，因此如果全都计算损失的话，其损失也会比难样本大很多，这种<strong>难易样本的不均衡也会影响模型的收敛与精度</strong>。</p> 
 <p>值得注意的是，由于负样本中大量的是简单样本，导致难易样本与正负样本这两个不均衡问题有一定的重叠，解决方法往往能同时对这两个问题起作用。</p> 
 <p><strong>3.类别间样本不均衡</strong></p> 
 <p>在有些目标检测的数据集中，还会存在类别间的不均衡问题。举个例子，数据集中有100万个车辆、1000个行人的实例标签，样本比例为1000∶1，属于典型的类别不均衡。</p> 
 <p>这种情况下，如果不做任何处理，使用该数据集进行训练，由于<strong>行人这一类别可参考标签太少，会使得模型主要关注车这一类别的检测，</strong>网络中的参数主要根据车辆的损失进行优化，导致行人的检测精度大大下降。</p> 
 <p>目前，解决样本不均衡问题的一些思路：</p> 
 <p>机器学习中，解决样本不均衡问题主要有2种思路：数据角度和算法角度。从<strong>数据角度</strong>出发，有<strong>扩大数据集、数据类别均衡采样</strong>等方法。在算法层面，目标检测方法使用的方法主要有：</p> 
 <ul><li><p>Faster RCNN、SSD等算法在正负样本的筛选时，根据样本与真实物体的IoU大小，设置了<strong>3∶1的正负样本比例</strong>，这一点缓解了正负样本的不均衡，同时也对难易样本不均衡起到了作用。</p></li></ul> 
 <ul><li><p>Faster RCNN在RPN模块中，<strong>通过前景得分排序筛选出了2000个左右的候选框，这也会将大量的负样本与简单样本过滤掉，</strong>缓解了前两个不均衡问题。</p></li></ul> 
 <ul><li><p><strong>权重惩罚</strong>：对于难易样本与类别间的不均衡，可以增大难样本与少类别的损失权重，从而增大模型对这些样本的惩罚，缓解不均衡问题。</p></li></ul> 
 <ul><li><p><strong>数据增强</strong>：从数据侧入手，可以在当前数据集上使用随机生成和添加扰动的方法，也可以利用网络爬虫数据等增加数据集的丰富性，从而缓解难易样本和类别间样本等不均衡问题，可以参考SSD的数据增强方法。</p></li></ul> 
 <p>近年来，不少的研究者针对样本不均衡问题进行了深入研究，比较典型的有OHEM（在线困难样本挖掘）、S-OHEM、Focal Loss、GHM（梯度均衡化）。下面将详细介绍：<br></p> 
 <p><strong>1 OHEM：在线难例挖掘</strong></p> 
 <h2></h2> 
 <p>OHEM算法（online hard example miniing，发表于2016年的CVPR）主要是<strong>针对训练过程中的困难样本自动选择</strong>，其核心思想是<strong>根据输入样本的损失进行筛选，筛选出困难样本（即对分类和检测影响较大的样本），然后将筛选得到的这些样本应用在随机梯度下降中训练。</strong></p> 
 <p>传统的Fast RCNN系列算法在正负样本选择的时候采用当前RoI与真实物体的IoU阈值比较的方法，这样容易忽略一些较为重要的难负样本，并且固定了正、负样本的比例与最大数量，显然不是最优的选择。以此为出发点，<strong>OHEM将交替训练与SGD优化方法进行了结合，在每张图片的RoI中选择了较难的样本，实现了在线的难样本挖掘。</strong></p> 
 <p style="text-align:center;"><img height="169" title="image.png" width="419" src="https://images2.imgbox.com/17/e4/w4pZN5qs_o.png" alt="ba3fb9f27a7bfe494035679fbab87513.png"> </p> 
 <p>OHEM实现在线难样本挖掘的网络如上图所示。图中包含了两个相同的RCNN网络，上半部的a部分是<strong>只可读的网络，只进行前向运算</strong>；下半部的b网络<strong>即可读也可写，需要完成前向计算与反向传播</strong>。</p> 
 <p>在一个batch的训练中，基于Fast RCNN的OHEM算法可以分为以下5步：</p> 
 <p>（1）按照原始Fast RCNN算法，经过卷积提取网络与RoI Pooling<strong>得到了每一张图像的RoI</strong>。</p> 
 <p>（2）上半部的a网络对所有的RoI进行<strong>前向计算</strong>，得到<strong>每一个RoI的损失</strong>。</p> 
 <p>（3）对RoI的损失进行<strong>排序</strong>，进行一步<strong>NMS操作，以去除掉重叠严重的RoI</strong>，并<strong>在筛选后的RoI中选择出固定数量损失较大的部分，作为难样本。</strong></p> 
 <p>（4）将筛选出的难样本<strong>输入到可读写的b网络中</strong>，进行前向计算，得到损失。</p> 
 <p>（5）利用b网络<strong>得到的反向传播更新网络</strong>，并将更新后的参数与上半部的a网络同步，完成一次迭代。</p> 
 <p>当然，为了实现方便，OHEM的简单实现可以是：在原有的Fast-RCNN里的loss layer里面对所有的props计算其loss，根据loss对其进行排序，选出K个hard examples，反向传播时，<strong>只对这K个props的梯度/残差回传，而其他的props的梯度/残差设为0。</strong></p> 
 <p>但是，<strong>由于其特殊的损失计算方式，把简单的样本都舍弃了，导致模型无法提升对于简单样本的检测精度，这也是OHEM方法的一个弊端。</strong></p> 
 <p><strong>优点</strong>：</p> 
 <p>1) 对于数据的类别不平衡问题不需要采用设置正负样本比例的方式来解决，这种<strong>在线选择方式针对性更强</strong>；</p> 
 <p>２) 随着<strong>数据集的增大</strong>，算法的提升更加明显；</p> 
 <p><strong>缺点</strong>：</p> 
 <p>只保留loss较高的样本，完全忽略简单的样本，这<strong>本质上是改变了训练时的输入分布（仅包含困难样本），这会导致模型在学习的时候失去对简单样本的判别能力</strong>。</p> 
 <p><strong>2. S-OHEM：基于loss分布采样的在线困难样本挖掘</strong></p> 
 <h2></h2> 
 <p>在OHEM中定义的多任务损失函数(包括分类损失 <img src="https://images2.imgbox.com/98/f1/ykZzf1St_o.png" alt="outside_default.png"> 和定位损失 <img src="https://images2.imgbox.com/c3/e0/MUcG2aKh_o.png" alt="outside_default.png"> )，在整个训练过程中各类损失具有相同的权重，这种方法<strong>忽略了训练过程中不同损失类型的影响</strong>，例如在训练期的后期，定位损失更为重要，因此OHEM<strong>缺乏对定位精度的足够关注</strong>。</p> 
 <p>S-OHEM算法采用了<strong>分层抽样</strong>的方法，<strong>根据loss的分布抽样训练样本</strong>。它的做法是：</p> 
 <p>首先将预设loss的<strong>四个分段</strong>： </p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/e9/77/0fLPR96E_o.png" alt="outside_default.png"></p> 
 <p>给定一个batch，先生成输入batch中<strong>所有图像的候选RoI</strong>，再将这些RoI送入到<strong>Read only RoI网络</strong>得到RoIs的损失，然后<strong>将每个RoI计算损失并划分到上面四个分段中</strong>，然后针对每个分段，通过排序筛选困难样本．再将经过筛选的RoIs送入反向传播，用于更新网络参数。</p> 
 <p>网络中损失是一个组合，具体公式为 <img src="https://images2.imgbox.com/2c/80/l2547nTU_o.png" alt="outside_default.png"> ， <img src="https://images2.imgbox.com/b1/d6/POsmvLdY_o.png" alt="outside_default.png"> 随着训练阶段变化而变化）之所以采用这个公式是因为<strong>在训练初期阶段，分类损失占主导作用；在训练后期阶段，边框回归损失函数占主导作用。</strong></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/53/ac/iuIBgYyV_o.png" alt="da16b2cae4b1902630ca1e0b8ae5a80e.png"></p> 
 <p>S-OHEM是基于OHEM的改进，如上图所示。网络分成两个部分：ConvNet和RoINet。RoINet又可看成两部分：<strong>Read-only RoI Network和Standard RoI Network。</strong>图中R表示向前传播的RoI的数量，B表示被馈送到反向传播的子采样的RoI的数量。S-OHEMiner<strong>根据当前训练阶段的采样分布对region proposals进行抽样</strong>。Read-only RoI Network只有forward操作，Standard RoI Network包括forward和backward操作，以hard example作为输入，计算损失并回传梯度。</p> 
 <p>RoINet的<strong>两部分共享权重，可实现高效地分配内存</strong>。在图中，蓝色箭头表示向前传播的过程，绿色箭头表示反向传播过程。<br></p> 
 <p><strong>优点</strong>：</p> 
 <p>相比原生OHEM，S-OHEM考虑了<strong>基于不同损失函数的分布来抽样选择困难样本，避免了仅使用高损失的样本来更新模型参数。</strong></p> 
 <p><strong>缺点</strong>：</p> 
 <p>因为不同阶段，分类损失和定位损失的贡献不同，所以选择损失中的两个参数 <img src="https://images2.imgbox.com/30/ec/2Kec8teo_o.png" alt="outside_default.png"><strong> 需要根据不同训练阶段进行改变</strong>，当应用与不同数据集时，参数的选取也是不一样的。即<strong>引入了额外的超参数</strong>。</p> 
 <h2><br></h2> 
 <p><strong>3 Focal loss：专注难样本</strong></p> 
 <h2></h2> 
 <p>当前一阶的物体检测算法，如SSD和YOLO等虽然实现了实时的速度，但精度始终无法与两阶的Faster RCNN相比。是什么阻碍了一阶算法的高精度呢？何凯明等人将其归咎于<strong>正、负样本的不均衡</strong>，并基于此提出了<strong>新的损失函数Focal Loss及网络结构RetinaNet</strong>，在与同期一阶网络速度相同的前提下，其检测精度比同期最优的二阶网络还要高。</p> 
 <p>对于SSD等一阶网络，由于其需要直接从所有的预选框中进行筛选，即使使用了固定正、负样本比例的方法，仍然效率低下，<strong>简单的负样本仍然占据主要地位</strong>，导致其精度不如两阶网络。为了解决一阶网络中样本的不均衡问题，何凯明等人<strong>首先改善了分类过程中的交叉熵函数，提出了可以动态调整权重的Focal Loss</strong>。</p> 
 <p><strong>1．标准交叉熵损失</strong></p> 
 <p>首先回顾一下标准的交叉熵（Cross Entropy, CE）函数，其形式如下式所示。</p> 
 <p style="text-align:center;"><img height="60" title="image.png" width="273" src="https://images2.imgbox.com/4d/65/61iRNXxY_o.png" alt="38a9ca263d9627ae56a5cc2471f8c8ff.png"></p> 
 <p>公式中，p代表样本在该类别的预测概率，y代表样本标签。可以看出，<strong>当标签为1时，p越接近1，则损失越小；</strong><strong>标签为0时p越接近0，则损失越小，符合优化的方向。</strong></p> 
 <p>为了方便表示，按照上式将p标记为pt：<br></p> 
 <p style="text-align:center;"><img height="77" title="image.png" width="201" src="https://images2.imgbox.com/6a/35/IOOrkrkC_o.png" alt="12311de9d9abb94835c6a83897634ade.png"></p> 
 <p>则交叉熵可以表示为下式的形式：</p> 
 <p style="text-align:center;"><img height="37" title="image.png" width="256" src="https://images2.imgbox.com/3d/13/QnD3K0J7_o.png" alt="ba07238b4ad08b885fa39e050c4484ce.png"></p> 
 <p>可以看出，<strong>标准的交叉熵中所有样本的权重都是相同的</strong>，因此如果正、负样本不均衡，<strong>大量简单的负样本会占据主导地位，少量的难样本与正样本会起不到作用，</strong>导致精度变差。</p> 
 <p><strong>2.平衡交叉熵损失</strong></p> 
 <p>为了改善样本的不平衡问题，平衡交叉熵<strong>在标准的基础上增加了一个系数αt来平衡正、负样本的权重</strong>，αt由超参α按照下式计算得来，α取值在[0,1]区间内。</p> 
 <p style="text-align:center;"><img height="79" title="image.png" width="205" src="https://images2.imgbox.com/82/22/24ECNwct_o.png" alt="0f31be76daf298e556ae2b85c44efaf6.png"></p> 
 <p>有了αt，平衡交叉熵损失公式如下式所示。</p> 
 <p style="text-align:center;"><img height="41" title="image.png" width="186" src="https://images2.imgbox.com/72/ab/eyTCDQb8_o.png" alt="31eb74e4ca5a4e2ec2f16d320eeef4e3.png"></p> 
 <p>尽管平衡交叉熵损失改善了正、负样本间的不平衡，但<strong>由于其缺乏对难易样本的区分，因此没有办法控制难易样本之间的不均衡。</strong></p> 
 <p><strong>3. 专注难样本Focal loss</strong></p> 
 <p>Focal Loss为了同时调节正、负样本与难易样本，提出了如下所示的损失函数。<br></p> 
 <p style="text-align:center;"><img height="44" title="image.png" width="253" src="https://images2.imgbox.com/a9/a8/HAIsIloS_o.png" alt="80f002b2d3c67b0157ded339a1b66bbf.png"></p> 
 <p>其中 <img src="https://images2.imgbox.com/d9/18/7Td1436S_o.png" alt="outside_default.png"> 用于<strong>控制正负样本的权重</strong>，当其取比较小的值来降低负样本（多的那类样本）的权重； <img src="https://images2.imgbox.com/4d/52/jBFggVK5_o.png" alt="outside_default.png"> 用于<strong>控制难易样本的权重</strong>，目的是<strong>通过减少易分样本的权重，从而使得模型在训练的时候更加专注难分样本的学习。</strong>文中通过批量实验统计得到当 <img src="https://images2.imgbox.com/cf/31/2JTQeLGP_o.png" alt="outside_default.png"> 时效果最好。</p> 
 <p>可以看出，对于Focal loss损失函数，有如下3个属性：</p> 
 <ul><li><p>与平衡交叉熵类似，<strong>引入了αt权重，为了改善正负样本的不均衡</strong>，可以提升一些精度。</p></li></ul> 
 <ul><li><p><img src="https://images2.imgbox.com/97/ce/05psaaMN_o.png" alt="outside_default.png">是为了调节难易样本的权重。当一个边框被误分类时，pt较小，则<img src="https://images2.imgbox.com/85/70/9u6jtHFy_o.png" alt="outside_default.png">接近于1，其损失几乎不受影响；当pt接近于1时，表明其分类预测较好，是简单样本，<img src="https://images2.imgbox.com/a1/3b/aoETMz2l_o.png" alt="outside_default.png">接近于0，因此其损失被调低了。</p></li></ul> 
 <ul><li><p>γ是一个调制因子，<strong>γ越大，简单样本损失的贡献会越低</strong>。</p></li></ul> 
 <p>为了验证Focal Loss的效果，何凯明等人还提出了一个一阶物体检测结构<strong>RetinaNet</strong>，其结构如下图所示。</p> 
 <p style="text-align:center;"><img title="image.png" src="https://images2.imgbox.com/12/fb/TYLJGDse_o.png" alt="941ae3c227d77878becbef2726210baf.png"></p> 
 <p>对于RetinaNet的网络结构，有以下5个细节：</p> 
 <p>（1）在Backbone部分，RetinaNet<strong>利用ResNet与FPN构建了一个多尺度特征的特征金字塔。</strong></p> 
 <p>（2）RetinaNet使用了类似于Anchor的预选框，<strong>在每一个金字塔层，使用了9个大小不同的预选框。</strong></p> 
 <p>（3）<strong>分类子网络</strong>：分类子网络为每一个预选框预测其类别，因此其输出特征大小为KA×W×H, A默认为9, K代表类别数。中间使用全卷积网络与ReLU激活函数，最后利用Sigmoid函数输出预测值。</p> 
 <p>（4）<strong>回归子网络</strong>：回归子网络与分类子网络平行，预测每一个预选框的偏移量，最终输出特征大小为4A×W×W。与当前主流工作不同的是，两个子网络没有权重的共享。</p> 
 <p>（5）<strong>Focal Loss</strong>：与OHEM等方法不同，Focal Loss在训练时作用到所有的预选框上。对于两个超参数，通常来讲，当γ增大时，α应当适当减小。实验中γ取2、α取0.25时效果最好。</p> 
 <h2><br></h2> 
 <p><strong>4 GHM：损失函数梯度均衡化机制</strong></p> 
 <p style="text-align:left;"><strong>论文地址</strong>：</p> 
 <p style="text-align:left;">https://arxiv.org/pdf/1811.05181.pdf</p> 
 <p style="text-align:left;"><strong>代码地址</strong>：</p> 
 <p style="text-align:left;">https://github.com/libuyu/GHM_Detection</p> 
 <p>前面讲到的OHEM算法和Focal loss各有利弊：</p> 
 <p>1、OHEM算法<strong>会丢弃loss比较低的样本</strong>，使得这些样本无法被学习到。</p> 
 <p>2、FocalLoss则是对正负样本进行加权，使得全部的样本可以得到学习，容易分类的负样本赋予低权值，hard examples赋予高权值。但是在所有的anchor examples中，出了大量的易分类的负样本外，<strong>还存在很多的outlier，FocalLoss对这些outlier并没有相关策略处理</strong>。并且FocalLoss存在<strong>两个超参</strong>，根据不同的数据集，调试两个超参需要大量的实验，一旦确定参数无法改变，不能根据数据的分布动态的调整。</p> 
 <p><strong>GHM主要思想</strong></p> 
 <p>GHM做法则是<strong>从样本的梯度范数出发</strong>，通过梯度范数所占的样本比例，对样本进行<strong>动态的加权</strong>，使得具有小梯度的容易分类的样本降权，具有中梯度的hard expamle升权，具有大梯度的outlier降权。</p> 
 <p><strong>损失函数的权重（梯度密度的倒数） </strong></p> 
 <p style="text-align:left;"><br>就是把梯度幅值范围(X轴)划分为M个区域，<strong>对于落在每个区域样本的权重采取相同的修正方式</strong>，<strong>类似于直方图</strong>。具体推导公式如下所示。<br></p> 
 <p style="text-align:left;">X轴的梯度分为M个区域，每个区域长度即为 ，第j个区域范围即为 <img src="https://images2.imgbox.com/81/7e/KoI1uf7W_o.png" alt="outside_default.png"> ，用 <img src="https://images2.imgbox.com/2c/ad/sM0U8a1l_o.png" alt="outside_default.png"> <strong>表示落在第j个区域内的样本数量</strong>。定义<strong>ind(g)表示梯度为g的样本所落区域的序号</strong>，那么即可得出新的参数 <img src="https://images2.imgbox.com/37/70/0LF5VjfX_o.png" alt="outside_default.png"> 。由于样本的梯度密度是训练时根据batch计算出来的，通常情况下batch较小，直接计算出来的梯度密度可能不稳定，所以采用<strong>滑动平均的方式处理梯度计算。</strong></p> 
 <p style="text-align:center;"> <br><img src="https://images2.imgbox.com/fa/9b/fWbNNtxY_o.png" alt="outside_default.png"><br><img src="https://images2.imgbox.com/e8/b2/7BpNwjR2_o.png" alt="outside_default.png"></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/f3/1e/waFKNRZM_o.png" alt="outside_default.png"><br><br></p> 
 <p>这里注意M的选取。当M太小的时候，不同梯度模上的密度不具备较好的方差；当然M也不能太大，因为M过大的时候，受限于GPU限制，batch size一般都比较小，此时如果M太大的话，会导致每次统计过于稀疏(分的太细了)，异常值对小区间的影响较大，导致训练不稳定。论文根据实验统计，M取30为最佳。</p> 
 <p><strong>GHM-C分类损失函数 </strong></p> 
 <p><br>对于分类损失函数，这里采用的是<strong>交叉熵函数</strong>，梯度密度中的梯度模长是基于交叉熵函数的导数进行计算的，GHM-C公式如下：</p> 
 <p>根据GHM-C的计算公式可以看出，<strong>候选样本的中的简单负样本和非常困难的异常样本(离群点)的权重都会被降低，即loss会被降低</strong>，对于模型训练的影响也会被大大减少，正常困难样本的权重得到提升，这样模型就会更加专注于那些更有效的正常困难样本，以提升模型的性能。</p> 
 <p><strong>GHM-R边框回归损失函数 </strong></p> 
 <p>对于回归损失函数，由于原生的Smooth L1损失函数的导数为１时，样本之间就没有难易区分度了，这样的统计明显不合理．<strong>论文修改了损失函数 <img src="https://images2.imgbox.com/bc/3f/a0iAGvOL_o.png" alt="outside_default.png"> ，梯度密度中的梯度模长是基于修改后的损失函数ASL1的导数进行计算的</strong>，GHM-R公式如下：</p> 
 <p>因为GHM-C和GHM-R是定义的损失函数，因此<strong>可以非常方便的嵌入到很多目标检测方法中</strong>，论文作者以focal loss（大概是以RetinaNet作为baseline），对交叉熵，focal loss和GHM-C做了对比，发现GHM-C在focal loss 的基础上在AP上提升了0.2个百分点。<br></p> 
 <p>具体细节可参考论文原文《Gradient Harmonized Single-stage Detector》。</p> 
 <p><strong>总结</strong></p> 
 <h2></h2> 
 <ul type="disc"><li><p>OHEM系列的困难样本挖掘方法在当前的目标检测框架上还是被大量地使用，在一些<strong>文本检测方法中</strong>还是被经常使用；</p></li><li><p>OHEM是针对现有样本并根据损失loss进行困难样本挖掘，Focal Loss和GHM则<strong>从损失函数本身</strong>进行困难样本挖掘；</p></li><li><p>相比Focal loss，GHM是一个<strong>动态的损失函数，即随着不同数据的分布进行变换，不需要额外的超参数调整</strong>（但是这里其实还是会涉及到一个参数，就是Unit region的数量）；此外GHM在降低易分样本权重的同时，<strong>对</strong><strong>outliner也会有一定程度的降权；</strong></p></li><li><p>无论是Focal Loss，还是基于GHM的损失函数都可以嵌入到现有的目标检测框架中；<strong>Focal Loss只针对分类损失，而GHM对分类损失和边框损失都可以；</strong></p></li><li><p>GHM方法在源码实现上，作者采用平均滑动的方式来计算梯度密度，不过与论文中有一个区别是在<strong>计算梯度密度的时候，没有乘以M，而是乘以有效的（也就是说有梯度信息的区间）bin个数</strong>；</p></li><li><p>之前尝试过Focal Loss用于多分类任务中，发现在精度并没有提升；但是我<strong>试过将训练数据按照训练数据的原始分布并将其引入到交叉熵函数中，准确率提升了</strong>；<strong>GHM方法的本质也是在改变训练数据的分布(将难易样本拉匀)，</strong>但是到底什么的数据分布是最优的，目前尚未定论。</p></li></ul> 
 <p><strong>下载1：OpenCV-Contrib扩展模块中文版教程</strong><br></p> 
 <p>在「<strong>小白学视觉</strong>」公众号后台回复：<strong>扩展模块中文教程</strong><strong>，</strong>即可下载全网第一份OpenCV扩展模块教程中文版，涵盖<strong>扩展模块安装、SFM算法、立体视觉、目标跟踪、生物视觉、超分辨率处理</strong>等二十多章内容。</p> 
 <p><strong>下载2：Python视觉实战项目52讲</strong></p> 
 <p>在「<strong>小白学视觉</strong>」公众号后台回复：<strong>Python视觉实战项目</strong><strong>，</strong>即可下载包括<strong>图像分割、口罩检测、车道线检测、车辆计数、添加眼线、车牌识别、字符识别、情绪检测、文本内容提取、面部识别</strong>等31个视觉实战项目，助力快速学校计算机视觉。</p> 
 <p><strong>下载3：OpenCV实战项目20讲</strong></p> 
 <p>在「<strong>小白学视觉</strong>」公众号后台回复：<strong>OpenCV实战项目20讲</strong><strong>，</strong>即可下载含有<strong>20</strong>个基于<strong>OpenCV</strong>实现20个<strong>实战项目</strong>，实现OpenCV学习进阶。</p> 
 <p style="text-align:center;">交流群<br></p> 
 <p>欢迎加入公众号读者群一起和同行交流，目前有SLAM、三维视觉、传感器、自动驾驶、计算摄影、检测、分割、识别、医学影像、GAN、算法竞赛等微信群（以后会逐渐细分），请扫描下面微信号加群，备注：”昵称+学校/公司+研究方向“，例如：”张三 + 上海交大 + 视觉SLAM“。请按照格式备注，否则不予通过。添加成功后会根据研究方向邀请进入相关微信群。<strong>请勿</strong>在群内发送广告，否则会请出群，谢谢理解~</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/b8/b3/eSWYuTGf_o.png" alt="8397ad1cb11b5e4a33d9f7bd246150ca.png"></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/be/50/kHeH3Pa0_o.png" alt="aec8e2c674beb63e0c08b53ccd9b9398.png"></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54533a92562f52426a8a8a4b75740b03/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【爬虫Practice5】爬取网易云音乐评论</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1ab63a349195c5a099e51fda941aa2a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pytorch实现U-net视网膜血管分割</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>