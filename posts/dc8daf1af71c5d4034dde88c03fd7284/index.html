<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android——一个简单的记账本APP - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android——一个简单的记账本APP" />
<meta property="og:description" content="一个简单的记账本APP 视频效果预览添加账目记录效果预览添加账目记录实现简述实现获取日期字符串时间戳转DateDate转星期 获取时间Switch控制显示和隐藏更改Switch样式事件监听 保存至SQLite数据库 标签选择实现效果预览实现状态改变事件监听状态监听 导航界面创建menu创建Fragment绑定Fragment 账单记录显示效果预览简述RecyclerView显示建立适配器获取数据源保留两位小数 概览效果预览简述分类显示创建适配器获取数据源 前三甲创建适配器获取数据源 单标签总价以及总金额 可视化概览效果预览简述折线图获取数据源 南丁格尔玫瑰图获取数据源 记录删除效果图释 尾言 视频效果预览 添加账目记录 效果预览 添加账目记录实现 简述 日期选择采用CalendarView控件，时间选择采用TimePicker控件，然后通过switch控件控制其VISIBLE和GONE属性，类型通过PopUpWindows弹窗显示，标签通过SharedPreferences进行传递。最后插入SQLite数据库中。
实现 获取日期 因为获取的日历控件的月份要比实际少一个月，故因此需要把月份加上一。
然后将获取的年月日字符串数据转为Date格式，最后将Date格式转为当时的星期
字符串时间戳转Date public static Date getStringToDate(String str){ mSimpleDateFormat = new SimpleDateFormat(&#34;yyyy-MM-dd&#34;, Locale.getDefault()); try { Date date = mSimpleDateFormat.parse(str); return date; } catch (ParseException e) { e.printStackTrace(); } return null; } Date转星期 public static String getWeekOfDate(Date date) { String[] weekDays = {&#34;星期日&#34;, &#34;星期一&#34;, &#34;星期二&#34;, &#34;星期三&#34;, &#34;星期四&#34;, &#34;星期五&#34;, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dc8daf1af71c5d4034dde88c03fd7284/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-17T14:34:55+08:00" />
<meta property="article:modified_time" content="2022-11-17T14:34:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android——一个简单的记账本APP</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>一个简单的记账本APP</h4> 
 <ul><li><a href="#_1" rel="nofollow">视频效果预览</a></li><li><a href="#_5" rel="nofollow">添加账目记录</a></li><li><ul><li><a href="#_6" rel="nofollow">效果预览</a></li><li><a href="#_10" rel="nofollow">添加账目记录实现</a></li><li><ul><li><a href="#_11" rel="nofollow">简述</a></li><li><a href="#_14" rel="nofollow">实现</a></li><li><ul><li><a href="#_15" rel="nofollow">获取日期</a></li><li><ul><li><a href="#Date_18" rel="nofollow">字符串时间戳转Date</a></li><li><a href="#Date_33" rel="nofollow">Date转星期</a></li></ul> 
     </li><li><a href="#_69" rel="nofollow">获取时间</a></li><li><a href="#Switch_83" rel="nofollow">Switch控制显示和隐藏</a></li><li><ul><li><a href="#Switch_84" rel="nofollow">更改Switch样式</a></li><li><a href="#_185" rel="nofollow">事件监听</a></li></ul> 
     </li><li><a href="#SQLite_210" rel="nofollow">保存至SQLite数据库</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_246" rel="nofollow">标签选择实现</a></li><li><ul><li><a href="#_247" rel="nofollow">效果预览</a></li><li><a href="#_251" rel="nofollow">实现</a></li><li><ul><li><a href="#_252" rel="nofollow">状态改变</a></li><li><ul><li><a href="#_255" rel="nofollow">事件监听</a></li><li><a href="#_299" rel="nofollow">状态监听</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_363" rel="nofollow">导航界面</a></li><li><ul><li><a href="#menu_365" rel="nofollow">创建menu</a></li><li><a href="#Fragment_382" rel="nofollow">创建Fragment</a></li><li><a href="#Fragment_385" rel="nofollow">绑定Fragment</a></li></ul> 
  </li><li><a href="#_444" rel="nofollow">账单记录显示</a></li><li><ul><li><a href="#_445" rel="nofollow">效果预览</a></li><li><a href="#_449" rel="nofollow">简述</a></li><li><a href="#RecyclerView_452" rel="nofollow">RecyclerView显示</a></li><li><ul><li><a href="#_453" rel="nofollow">建立适配器</a></li><li><a href="#_521" rel="nofollow">获取数据源</a></li><li><ul><li><a href="#_547" rel="nofollow">保留两位小数</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_562" rel="nofollow">概览</a></li><li><ul><li><a href="#_563" rel="nofollow">效果预览</a></li><li><a href="#_566" rel="nofollow">简述</a></li><li><a href="#_569" rel="nofollow">分类显示</a></li><li><ul><li><a href="#_573" rel="nofollow">创建适配器</a></li><li><a href="#_641" rel="nofollow">获取数据源</a></li></ul> 
   </li><li><a href="#_661" rel="nofollow">前三甲</a></li><li><ul><li><a href="#_663" rel="nofollow">创建适配器</a></li><li><a href="#_727" rel="nofollow">获取数据源</a></li></ul> 
   </li><li><a href="#_768" rel="nofollow">单标签总价以及总金额</a></li></ul> 
  </li><li><a href="#_787" rel="nofollow">可视化概览</a></li><li><ul><li><a href="#_788" rel="nofollow">效果预览</a></li><li><a href="#_791" rel="nofollow">简述</a></li><li><ul><li><a href="#_794" rel="nofollow">折线图</a></li><li><ul><li><a href="#_830" rel="nofollow">获取数据源</a></li></ul> 
    </li><li><a href="#_853" rel="nofollow">南丁格尔玫瑰图</a></li><li><ul><li><a href="#_879" rel="nofollow">获取数据源</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_897" rel="nofollow">记录删除</a></li><li><ul><li><a href="#_898" rel="nofollow">效果图</a></li><li><a href="#_901" rel="nofollow">释</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_915" rel="nofollow">尾言</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>视频效果预览</h2> 
<p></p> 
<div class="csdn-video-box"> 
 <iframe id="SbLWACl4-1654397535346" frameborder="0" src="https://live.csdn.net/v/embed/214043" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p></p> 
</div> 
<p></p> 
<h2><a id="_5"></a>添加账目记录</h2> 
<h3><a id="_6"></a>效果预览</h3> 
<img src="https://images2.imgbox.com/08/8c/GGS9iHXH_o.jpg" width="40%"> 
<img src="https://images2.imgbox.com/10/46/xAODJ5Po_o.jpg" width="40%"> 
<h3><a id="_10"></a>添加账目记录实现</h3> 
<h4><a id="_11"></a>简述</h4> 
<p>日期选择采用<code>CalendarView</code>控件，时间选择采用<code>TimePicker</code>控件，然后通过<code>switch</code>控件控制其<code>VISIBLE</code>和<code>GONE</code>属性，类型通过PopUpWindows弹窗显示，标签通过<code>SharedPreferences</code>进行传递。最后插入SQLite数据库中。</p> 
<h4><a id="_14"></a>实现</h4> 
<h5><a id="_15"></a>获取日期</h5> 
<p>因为获取的日历控件的月份要比实际少一个月，故因此需要把月份加上一。<br> 然后将获取的年月日字符串数据转为Date格式，最后将Date格式转为当时的星期</p> 
<h6><a id="Date_18"></a>字符串时间戳转Date</h6> 
<pre><code>  public static Date getStringToDate(String str){
        mSimpleDateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
        try {
            Date date = mSimpleDateFormat.parse(str);
            return date;
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return null;
    }
</code></pre> 
<h6><a id="Date_33"></a>Date转星期</h6> 
<pre><code>public static String getWeekOfDate(Date date) {
        String[] weekDays = {"星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"};
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);

        int w = cal.get(Calendar.DAY_OF_WEEK) - 1;
        if (w &lt; 0)
            w = 0;
        return weekDays[w];
    }
</code></pre> 
<p>最后将获取的日期、星期进行保存</p> 
<pre><code> /**
     * 显示选择的年月日，并将选择的年月日转为星期
     */
    private void getDate() {
        mCalendarView.setOnDateChangeListener(new CalendarView.OnDateChangeListener() {
            @Override
            public void onSelectedDayChange(@NonNull CalendarView view, int year, int month, int dayOfMonth) {
                month = month + 1;
                CNDate = year + "年" + month + "月" + dayOfMonth + "日";
                String date = year + "-" + month + "-" + dayOfMonth;
                Log.d(TAG, "date=" + date);
                Log.d(TAG, "CNdate=" + CNDate);
                //string日期转date日期，在转为星期
                String week = DateUtils.getWeekOfDate(DateUtils.getStringToDate(date));
                Log.d(TAG, "week=" + week);
                SelectDate.setText(CNDate + " " + week);
            }
        });
    }
</code></pre> 
<h5><a id="_69"></a>获取时间</h5> 
<p>直接对<code>TimePicker</code>控件进行事件监听，然后将获取的时间进行保存即可</p> 
<pre><code> private void getTime() {
        mTimePicker.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() {
            @Override
            public void onTimeChanged(TimePicker view, int hourOfDay, int minute) {
                String time = hourOfDay + ":" + minute;
                SelectTime.setText(time);
                Log.d(TAG, time);
            }
        });
    }
</code></pre> 
<h5><a id="Switch_83"></a>Switch控制显示和隐藏</h5> 
<h6><a id="Switch_84"></a>更改Switch样式</h6> 
<p>建立thumb.xml和track.xml两个选择器<br> thumb.xml如下</p> 
<pre><code>&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt;
&lt;item android:state_checked="true" android:drawable="@drawable/open_thumb"/&gt;
&lt;item android:drawable="@drawable/shut_thumb"/&gt;
&lt;/selector&gt;
</code></pre> 
<p>track.xml如下</p> 
<pre><code>&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;item android:state_checked="true" android:drawable="@drawable/open_track"/&gt;
    &lt;item android:drawable="@drawable/shut_track"/&gt;
&lt;/selector&gt;
</code></pre> 
<p>然后分别建立两个选择器的不同状态下的效果文件<br> open_thumb.xml</p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;shape xmlns:android="http://schemas.android.com/apk/res/android"
android:shape="rectangle" &gt;
&lt;!-- 高度40 --&gt;
&lt;size android:height="30dp" android:width="30dp"/&gt;
&lt;!-- 圆角弧度 20 --&gt;
&lt;corners android:radius="15dp"/&gt;
&lt;!-- 变化率 --&gt;

&lt;gradient
    android:endColor="#eeeeee"
    android:startColor="#eeeeee" /&gt;
&lt;!--&lt;stroke android:width="1dp"--&gt;
&lt;!--    android:color="#2196F3"/&gt;--&gt;
&lt;/shape&gt;
</code></pre> 
<p>shut_thumb.xml</p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle" &gt;
&lt;size android:height="30dp" android:width="30dp"/&gt;
&lt;!-- 圆角弧度 20 --&gt;
&lt;corners android:radius="15dp"/&gt;
&lt;!-- 变化率 --&gt;
&lt;gradient
    android:endColor="#eeeeee"
    android:startColor="#eeeeee" /&gt;
&lt;stroke android:width="1dp"
    android:color="#A8A7A7"/&gt;

&lt;/shape&gt;
</code></pre> 
<p>open_track.xml</p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"
android:shape="rectangle"&gt;

        &lt;!-- 高度30   此处设置宽度无效--&gt;
        &lt;size android:height="30dp"/&gt;
        &lt;!-- 圆角弧度 15 --&gt;
        &lt;corners android:radius="15dp"/&gt;
        &lt;!-- 变化率  定义从左到右的颜色不变 --&gt;
        &lt;solid android:color="#07ED7D"/&gt;

    &lt;/shape&gt;
</code></pre> 
<p>shut_track.xml</p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle"&gt;
    &lt;size android:height="30dp" android:width="30dp"/&gt;
    &lt;corners android:radius="15dp"/&gt;
    &lt;gradient android:startColor="#eeeeee"
        android:endColor="#eeeeee"/&gt;
    &lt;stroke android:width="1dp"
            android:color="#A8A7A7"/&gt;
&lt;/shape&gt;
</code></pre> 
<p>最后应用于switch效果如下</p> 
<pre><code> &lt;Switch
                        android:id="@+id/DateSwitch"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_gravity="center"
                        android:gravity="center"
                        android:thumb="@drawable/thumb"
                        android:track="@drawable/track" /&gt;
</code></pre> 
<h6><a id="_185"></a>事件监听</h6> 
<p>通过监听Switch事件，判断false和true两种状态，分别对应控件的隐藏和显示</p> 
<pre><code> class SwitchListener implements CompoundButton.OnCheckedChangeListener {

        @Override
        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
            switch (buttonView.getId()) {
                case R.id.DateSwitch:
                    if (isChecked)
                        DateLayout.setVisibility(View.VISIBLE);
                    else
                        DateLayout.setVisibility(View.GONE);
                    break;
                case R.id.TimeSwitch:
                    if (isChecked)
                        TimeLayout.setVisibility(View.VISIBLE);
                    else
                        TimeLayout.setVisibility(View.GONE);
                    break;
            }
        }
    }
</code></pre> 
<h5><a id="SQLite_210"></a>保存至SQLite数据库</h5> 
<pre><code> /**
     * 账单记录保存到SQLite中
     */
    public void SaveMessage(View view) {
        String date = SelectDate.getText().toString().trim();
        String time = SelectTime.getText().toString().trim();
        String type = TypeText.getText().toString();
        String label = TextLabel.getText().toString();
        String name = GoodsName.getText().toString();
        String price = GoodsPrice.getText().toString().trim();
        if (TextUtils.isEmpty(type) || type.equals("支出or收入")){
            toastUtils.ShowFail("类型错误！");
            return;
        }
        if (TextUtils.isEmpty(label) || label.equals("暂未选择")){
            toastUtils.ShowFail("标签错误!");
            return;
        }
        if (TextUtils.isEmpty(name) || TextUtils.isEmpty(price)){
            toastUtils.ShowFail("商品信息或者商品价格格式!");
            return;
        }
        int t = type.equals("支出") ? 1 : 0;
        Record record = new Record(date,time,t,label,name,price);
        int flag = dao.Insert(record);
        if (flag == 1){
            toastUtils.ShowSuccess("保存成功!");
        }else {
            toastUtils.ShowFail("保存失败!");
        }

    }
</code></pre> 
<h2><a id="_246"></a>标签选择实现</h2> 
<h3><a id="_247"></a>效果预览</h3> 
<img src="https://images2.imgbox.com/2f/ce/61d5nCh4_o.jpg" width="40%"> 
<img src="https://images2.imgbox.com/3b/98/coTScPaS_o.jpg" width="40%"> 
<h3><a id="_251"></a>实现</h3> 
<h4><a id="_252"></a>状态改变</h4> 
<p>每一个标签有两种状态，选择和不被选择状态，分别对应两种样式效果，一种呈灰色，另一种呈高亮，在进行选择时可以同时点亮多个标签，但最后进行保存时，只能选择一个标签，若条件不满足，系统给予错误提示。</p> 
<h5><a id="_255"></a>事件监听</h5> 
<pre><code> class TypeListener implements View.OnClickListener{

        @Override
        public void onClick(View v) {
            switch (v.getId()){
                case R.id.type_1:
                    setTag(type_1,getTag(type_1));
                    setBG(type_1,1);
                    break;
                case R.id.type_2:
                    setTag(type_2,getTag(type_2));
                    setBG(type_2,2);
                    break;
                case R.id.type_3:
                    setTag(type_3,getTag(type_3));
                    setBG(type_3,3);
                    break;
                case R.id.type_4:
                    setTag(type_4,getTag(type_4));
                    setBG(type_4,4);
                    break;
                case R.id.type_5:
                    setTag(type_5,getTag(type_5));
                    setBG(type_5,5);
                    break;
                case R.id.type_6:
                    setTag(type_6,getTag(type_6));
                    setBG(type_6,6);
                    break;
                case R.id.type_7:
                    setTag(type_7,getTag(type_7));
                    setBG(type_7,7);
                    break;
                case R.id.type_8:
                    setTag(type_8,getTag(type_8));
                    setBG(type_8,8);
                    break;
            }
        }
    }
</code></pre> 
<h5><a id="_299"></a>状态监听</h5> 
<p>每一个标签被点击，其tag自增一次，若未被点击，初始值为1</p> 
<pre><code>private void setTag(LinearLayout layout,int tag){
        tag++;
        layout.setTag(tag);
    }
</code></pre> 
<pre><code> private int getTag(LinearLayout layout){
        Object tag = layout.getTag();
        if (tag == null)return 1;
        return (int) tag;
    }
</code></pre> 
<p>然后通过tag值改变标签的样式，成偶数则高亮，奇数则灰色，并记录当前状态值，同时保存被选择的标签数量。</p> 
<pre><code>  private void setBG(LinearLayout layout,int index){
        int tag = (int)layout.getTag();
        if (tag % 2 == 0) {
            layout.setBackground(getResources().getDrawable(R.drawable.blue_radius_bg));
            TotalNum++;
            b_select[index-1] = true;
        }
        else {
            layout.setBackground(getResources().getDrawable(R.drawable.grey_radius_bg));
            TotalNum--;
            b_select[index-1] = false;
        }
    }
</code></pre> 
<p>然后通过监听保存按钮点击事件，取出状态值为true的标签值进行返回</p> 
<pre><code>private String selectTag(){
        for (int i = 0; i &lt; 8; i++) {
            if ( b_select[i]){
                return s_select[i];
            }
        }
    return null;
    }
</code></pre> 
<p>同时监听被选择的标签总数，若小于1，则未选择任何标签，给予提升；若大于1，则选择多个标签，同样给予提升。最后通过<code>SharedPreferences</code>进行数据传回；使用Intent传输应该会更安全，一开始设计使用EventBus，但最后不了了。</p> 
<pre><code>public void SaveMessage(View view){
        if (TotalNum &gt; 1){
            toastUtils.ShowFail("选择标签数量不能超过一");
        }else if (TotalNum &lt;= 0){
            toastUtils.ShowFail("选择标签数量不能少于一");
        }else {
            toastUtils.ShowSuccess("success");
            String tag = selectTag();
            Log.d(TAG,"TAG="+tag);
            SP sp = SP.getInstance();
            sp.PutData(LabelActivity.this,"Label",tag);
            //EventBus.getDefault().post(new TextClass(tag));
            KillProcess.POP(LabelActivity.this);
        }
    }
</code></pre> 
<h2><a id="_363"></a>导航界面</h2> 
<p>采用底部导航控件<code>BottomNavigationView</code>切换账单记录界面和账单概览界面，并通过<code>ViewPager</code>进行页面滑动，两个子页面采用两个不同的<code>Fragment</code>。</p> 
<h3><a id="menu_365"></a>创建menu</h3> 
<p>次menu即为底部导航的文字和图片效果，可以使用选择器，监听选择和不被选择两种状态，改变其效果。若不设置，系统模式使用样式颜色作为高亮显示。灰色呈不被选择状态。</p> 
<pre><code>&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt;

    &lt;item
        android:id="@+id/menu_navigation_record"
        android:icon="@drawable/ic_home_black_24dp"
        android:title="@string/title_record" /&gt;

    &lt;item
        android:id="@+id/menu_navigation_general"
        android:icon="@drawable/ic_dashboard_black_24dp"
        android:title="@string/title_general" /&gt;
&lt;/menu&gt;
</code></pre> 
<h3><a id="Fragment_382"></a>创建Fragment</h3> 
<p>由于本APP只需要两个节目，故只需要创建两个fragment，然后在与nav进行绑定即可，此处仅作为标记，详细介绍如下文所示</p> 
<h3><a id="Fragment_385"></a>绑定Fragment</h3> 
<pre><code>  /**
   * Set a listener that will be notified when a bottom navigation item is selected. This listener
   * will also be notified when the currently selected item is reselected, unless an {@link
   * OnNavigationItemReselectedListener} has also been set.
   *
   * @param listener The listener to notify
   * @see #setOnNavigationItemReselectedListener(OnNavigationItemReselectedListener)
   */
</code></pre> 
<p>设置底部导航栏当前页面显示</p> 
<pre><code> navView.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() {
            @Override
            public boolean onNavigationItemSelected(@NonNull MenuItem item) {
                switch (item.getItemId()) {
                    case R.id.menu_navigation_record:
                        mViewPager.setCurrentItem(0);
                        return true;
                    case R.id.menu_navigation_general:
                        mViewPager.setCurrentItem(1);
                        return true;
                }
                return false;
            }
        });
</code></pre> 
<p>将ViewPager和两个fragment进行绑定</p> 
<pre><code>private void setupViewPager(ViewPager viewPager) {
        BottomAdapter adapter = new BottomAdapter(getSupportFragmentManager());
        adapter.addFragment(new RecordFragment());
        adapter.addFragment(new GeneralFragment());
        viewPager.setAdapter(adapter);
    }
</code></pre> 
<p>并通过监听ViewPager事件，进行页面切换</p> 
<pre><code>mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
            @Override
            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {

            }

            @Override
            public void onPageSelected(int position) {
                navView.getMenu().getItem(position).setChecked(true);
            }

            @Override
            public void onPageScrollStateChanged(int state) {

            }
        });
    }
</code></pre> 
<h2><a id="_444"></a>账单记录显示</h2> 
<h3><a id="_445"></a>效果预览</h3> 
<img src="https://images2.imgbox.com/b9/2b/yiWB2GcU_o.png" width="40%"> 
<img src="https://images2.imgbox.com/9f/3d/Y27THusq_o.jpg" width="40%"> 
<h3><a id="_449"></a>简述</h3> 
<p>此界面就比较简单，从数据库中拿出所有数据并构建一个集合类对象，然后放入RecyclerView中进行显示，最后根据类型计算总支出和总收入金额</p> 
<h3><a id="RecyclerView_452"></a>RecyclerView显示</h3> 
<h4><a id="_453"></a>建立适配器</h4> 
<pre><code>public class OrderAdapter extends RecyclerView.Adapter&lt;OrderAdapter.ViewHolder&gt; {
    private String[] s_select = {"日用百货","文化休闲","交通出行","生活服务","服装装扮","餐饮美食","数码电器","其他标签"};
    private int[] img_select = {
            R.drawable.icon_type_one,
            R.drawable.icon_type_two,
            R.drawable.icon_type_three,
            R.drawable.icon_type_four,
            R.drawable.icon_type_five,
            R.drawable.icon_type_six,
            R.drawable.icon_type_seven,
            R.drawable.icon_type_eight};
    private List&lt;Record&gt; recordList;
    public OrderAdapter(List&lt;Record&gt; recordList){
        this.recordList = recordList;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.order_item,parent,false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        Record record = recordList.get(position);
        holder.item_date.setText(record.getDate());
        holder.item_time.setText("时间 "+record.getTime());
        holder.item_label.setText("["+record.getLabel()+"]");
        holder.item_name.setText(record.getGoodsName());
        if (record.getType() == 1){
            holder.item_price.setText("-"+record.getGoodsPrice());
        }else {
            holder.item_price.setText("+"+record.getGoodsPrice());
        }
        for (int i = 0; i &lt; 8; i++) {
            if (record.getLabel().equals(s_select[i])){
                holder.item_img.setImageResource(img_select[i]);
            }
        }

    }

    @Override
    public int getItemCount() {
        return recordList.size();
    }

    class ViewHolder extends RecyclerView.ViewHolder{
        private TextView item_date,item_time,item_label,item_name,item_price;
        private ImageView item_img;

        public ViewHolder(@NonNull View itemView) {
            super(itemView);
            item_date = itemView.findViewById(R.id.item_date);
            item_time = itemView.findViewById(R.id.item_time);
            item_label = itemView.findViewById(R.id.item_label);
            item_name = itemView.findViewById(R.id.item_name);
            item_price = itemView.findViewById(R.id.item_price);
            item_img = itemView.findViewById(R.id.item_img);
        }
    }
}
</code></pre> 
<h4><a id="_521"></a>获取数据源</h4> 
<p>从数据库中获取实体类集合对象，然后根据其收入和支出两种状态计算相对应的总金额</p> 
<pre><code>/**
     * 获取RecyclerView数据源*/
    private void getData(){
        recordList = dao.QueryAll();
        if (recordList.size() == 0 || recordList == null){
            IsEmpty(true);
            return;
        }
        for (int i = 0; i &lt; recordList.size(); i++) {
            /**
             * 1为支出
             * 0为收入*/
            if (recordList.get(i).getType() == 1){
                totalPay += Double.parseDouble(recordList.get(i).getGoodsPrice());
            }else {
                totalIncome += Double.parseDouble(recordList.get(i).getGoodsPrice());
            }
        }
        IsEmpty(TotalPay,totalPay,1);
        IsEmpty(TotalIncome,totalIncome,0);

    }
</code></pre> 
<h5><a id="_547"></a>保留两位小数</h5> 
<p>由于在转换格式的之后，进行加减运算精度会失衡，会产生很多位小数点，但由于美观以及界面设计，一般设计保留2位小数即可</p> 
<pre><code>以12.345678为例:
12.345678*100 = 1234.5678
然后将其转为整数，则变为 1234
最后除以100.0，此处标签，是100.0不是100，因为前面已经为整型数据，整型除整型依旧为整型，只有除100.0，int数据类型才会强制转换为float或者double类型
</code></pre> 
<pre><code>private double SaveDecimal(double n){
        return n = ((int)(n*100))/100.0;
    }
</code></pre> 
<h2><a id="_562"></a>概览</h2> 
<h3><a id="_563"></a>效果预览</h3> 
<img src="https://images2.imgbox.com/ab/be/SqlIAF8V_o.png" width="40%"> 
<h3><a id="_566"></a>简述</h3> 
<p>此界面显示的内容包括共计收入、支出多少笔和合计收入、支出多少金额，以及通过标签分类显示支出、收入占比，以及全部收入、支出记录中前三甲。</p> 
<h3><a id="_569"></a>分类显示</h3> 
<p>通过获取单个标签的所有金额除以全部标签的总金额，获取百分比占比，并通过view进行显示，条形bar通过获取屏幕宽度，例如：我的手机屏幕宽度为1080，就以数码电器为例：<code>11998.99/总金额 * 1080 = 条形bar的长度</code><br> 百分比占比同样以数码电器为例:<code>11998.99/总金额 * 100 = 数码电器百分比</code></p> 
<h4><a id="_573"></a>创建适配器</h4> 
<pre><code>public class BarAdapter extends RecyclerView.Adapter&lt;BarAdapter.ViewHolder&gt; {
    private String[] s_select = {"日用百货", "文化休闲", "交通出行", "生活服务", "服装装扮", "餐饮美食", "数码电器", "其他标签"};
    private int[] img_select = {
            R.drawable.icon_type_one,
            R.drawable.icon_type_two,
            R.drawable.icon_type_three,
            R.drawable.icon_type_four,
            R.drawable.icon_type_five,
            R.drawable.icon_type_six,
            R.drawable.icon_type_seven,
            R.drawable.icon_type_eight};
    private List&lt;ViewBar&gt; viewBarList;

    public BarAdapter(List&lt;ViewBar&gt; viewBarList) {
        this.viewBarList = viewBarList;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.pay_type_item, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        int w = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
        int h = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
        holder.item_bar.measure(w, h);
        ViewBar viewBar = viewBarList.get(position);
        holder.item_bar.setLayoutParams(new LinearLayout.LayoutParams(viewBar.getWidth(), viewBar.getHeight()));
        holder.item_label.setText(viewBar.getLabel());
        holder.item_num.setText(viewBar.getNum());
        holder.item_price.setText(viewBar.getPrice());
        Log.d("testLabel",viewBar.getLabel());
        for (int i = 0; i &lt; 8; i++) {
            if (viewBar.getLabel().trim().equals(s_select[i])){
                Log.d("testLabel",viewBar.getLabel());
                holder.item_img.setImageResource(img_select[i]);
            }
        }
    }

    @Override
    public int getItemCount() {
        return viewBarList.size();
    }

    class ViewHolder extends RecyclerView.ViewHolder {
        private TextView item_label, item_num, item_price;
        private ImageView item_img;
        private View item_bar;

        public ViewHolder(@NonNull View itemView) {
            super(itemView);
            item_label = itemView.findViewById(R.id.pay_type_label);
            item_num = itemView.findViewById(R.id.pay_type_num);
            item_price = itemView.findViewById(R.id.pay_type_price);
            item_img = itemView.findViewById(R.id.pay_type_img);
            item_bar = itemView.findViewById(R.id.pay_type_bar);
        }
    }
}
</code></pre> 
<h4><a id="_641"></a>获取数据源</h4> 
<p>获取屏幕宽度，以此作为基数</p> 
<pre><code>manager = requireActivity().getWindowManager();
 width = manager.getDefaultDisplay().getWidth();
</code></pre> 
<pre><code>private void getData(){
        if (TotalPrice &lt;= 0)return;
        for (int i = 0; i &lt; d_price.length; i++) {
            if (d_price[i] == 0)continue;
            int n = (int) (d_price[i] / TotalPrice * width);
            double t = SaveDecimal(d_price[i] / TotalPrice * 100);
            barList.add(new ViewBar(s_select[i]+"   ",t+"%","¥"+d_price[i],n,10));
        }
    }
</code></pre> 
<h3><a id="_661"></a>前三甲</h3> 
<p>通过比较所有账单记录，根据金额升序获取前三甲</p> 
<h4><a id="_663"></a>创建适配器</h4> 
<pre><code>public class RankAdapter extends RecyclerView.Adapter&lt;RankAdapter.ViewHolder&gt; {
    private int[] img_select = {
            R.drawable.gold,
            R.drawable.silver,
            R.drawable.tongpai,
           };
    private List&lt;RankList&gt; rankLists;
    public RankAdapter(List&lt;RankList&gt; rankLists){
        this.rankLists = rankLists;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.ranking_list_item,parent,false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        RankList rank = rankLists.get(position);
        holder.item_label.setText("["+rank.getLabel()+"]");
        holder.item_content.setText(rank.getContent());
        if (rank.getType() == 1){
            holder.item_price.setText("-"+rank.getPrice());
        }else {
            holder.item_price.setText("+"+rank.getPrice());
        }
        switch (rank.getPosition()){
            case 1:
                holder.item_img.setImageResource(img_select[0]);
                break;
            case 2:
                holder.item_img.setImageResource(img_select[1]);
                break;
            case 3:
                holder.item_img.setImageResource(img_select[2]);
                break;
        }
    }

    @Override
    public int getItemCount() {
        return rankLists.size();
    }

    class ViewHolder extends RecyclerView.ViewHolder{
        private TextView item_label,item_content,item_price;
        private ImageView item_img;

        public ViewHolder(@NonNull View itemView) {
            super(itemView);
            item_label = itemView.findViewById(R.id.Rank_label);
            item_content = itemView.findViewById(R.id.Rank_name);
            item_price = itemView.findViewById(R.id.Rank_price);
            item_img = itemView.findViewById(R.id.Rank_img);
        }
    }
}
</code></pre> 
<h4><a id="_727"></a>获取数据源</h4> 
<p>代码虽不比递归以及排序整洁，但是时间复杂度控制在0(n)，效率比冒泡排序、快速排序等要高一点</p> 
<pre><code> /**
     * 选出账单支出前三甲*/
    private void getRankings(){
        if (recordList.size() == 0 || recordList == null)return;
        double maxPrice = -32768,midPrice = -32768,lowPrice = -32768;
        int maxIndex = -1,midIndex = -1,lowIndex = -1;
        for (int i = 0; i &lt; recordList.size(); i++) {
            double price = Double.parseDouble(recordList.get(i).getGoodsPrice());
            if ( price &gt; maxPrice){
                lowPrice = midPrice;
                lowIndex = midIndex;

                midPrice = maxPrice;
                midIndex = maxIndex;

                maxPrice = price;
                maxIndex = i;
            }
            if (price &lt; maxPrice &amp;&amp; price &gt; midPrice){
                lowPrice = midPrice;
                lowIndex = midIndex;

                midPrice = price;
                midIndex = i;
            }
            if (price &lt; maxPrice &amp;&amp; price &lt; midPrice &amp;&amp; price &gt; lowPrice){
                lowPrice = price;
                lowIndex = i;
            }
        }
        int[] poi = {maxIndex,midIndex,lowIndex};
        for (int i = 0; i &lt; 3; i++) {
            if (poi[i] == -1)continue;
            rankListList.add(new RankList(i+1,recordList.get(poi[i]).getLabel(),recordList.get(poi[i]).getGoodsName(),recordList.get(poi[i]).getGoodsPrice(),recordList.get(poi[i]).getType()));
        }
    }
</code></pre> 
<h3><a id="_768"></a>单标签总价以及总金额</h3> 
<pre><code> /**
     * 获取单个标签总价以及所有商品总价*/
    private void getPrice(){
        if (recordList.size() == 0 || recordList == null)return;
        d_price = new double[s_select.length];
        for (int i = 0; i &lt; recordList.size(); i++) {
            for (int j = 0; j &lt; s_select.length; j++) {
                if (recordList.get(i).getLabel().equals(s_select[j])){
                    d_price[j] += Double.parseDouble(recordList.get(i).getGoodsPrice());
                    TotalPrice += Double.parseDouble(recordList.get(i).getGoodsPrice());
                    break;
                }
            }
        }
    }
</code></pre> 
<h2><a id="_787"></a>可视化概览</h2> 
<h3><a id="_788"></a>效果预览</h3> 
<img src="https://images2.imgbox.com/78/1c/1IL8nQol_o.jpg" width="40%"> 
<h3><a id="_791"></a>简述</h3> 
<p>本可视化图表工具采用的是AAChartView，此工具相对于老牌MPChartView和HelloChartView而言，使用更加简单，种类更加齐全，重点是粉粉嫩嫩，但他的导入方式与其他不同，不是通过导入闭包进行使用；而且通过复制它到一些文件到自己工程项目中，其样式使用的js写的，所有需要导入一些js文件以及一些其他java文件。这一点不比导入闭包方便。根据需要进行选择使用。</p> 
<h4><a id="_794"></a>折线图</h4> 
<p>通过<code>aa_drawChartWithChartModel()</code>方法获取<code>AAChartModel</code>对象即可，使用超级简单</p> 
<pre><code>lineChartView.aa_drawChartWithChartModel(InitLineChart());
</code></pre> 
<p>然后可通过配置一些参数,更加形象化图表</p> 
<pre><code>例如：categories 为 x轴数据源，类型为String[]
yAxisMin 为 y轴数据源最小值
yAxisMax 为 y轴数据源最大值
series 为 每个数据点的提示内容，其中name为标题；data为数据，类型为Object[]
</code></pre> 
<pre><code>private  AAChartModel InitLineChart() {
        return new AAChartModel()
                .chartType(AAChartType.Areaspline)
                .legendEnabled(false)
                .yAxisVisible(true)
                .markerRadius(6f)
                .markerSymbolStyle(AAChartSymbolStyleType.InnerBlank)
                .zoomType(AAChartZoomType.XY)
                .categories(s_select)
                .yAxisMin(2.0f)//Y轴数据最大值和最小值范围
                .yAxisMax(2000.0f)
                .xAxisTickInterval(2)
                .series(new AASeriesElement[]{
                        new AASeriesElement()
                                .name("合计")
                                .color("#2494F3")
                                .data( getPrice())
                });
    }
</code></pre> 
<h5><a id="_830"></a>获取数据源</h5> 
<p>由于需要的是Object[] 类型数据，所有需要将string类型数据转为double，然后将double转为Double类型，然后进行强制转换，最后变为Object类型</p> 
<pre><code>private Object[] getPrice(){
        if (recordList.size() == 0 || recordList == null)return null;
        double[] d_price = new double[s_select.length];
        Object[] o_price = new Object[s_select.length];
        for (int i = 0; i &lt; recordList.size(); i++) {
            for (int j = 0; j &lt; s_select.length; j++) {
                if (recordList.get(i).getLabel().equals(s_select[j])){
                    Log.d("DetailedActivity",Double.parseDouble(recordList.get(i).getGoodsPrice())+"");
                    d_price[j] += Double.parseDouble(recordList.get(i).getGoodsPrice());
                    break;
                }
            }
        }
        for (int i = 0; i &lt; s_select.length; i++) {
            o_price[i] = new Double(d_price[i]);
        }
        return o_price;
    }
</code></pre> 
<h4><a id="_853"></a>南丁格尔玫瑰图</h4> 
<p>同样适用<code>aa_drawChartWithChartModel</code>方法进行数据体现，同时无论什么类型的图表类型，都知使用<code>AAChartView</code>控件，并且只需要返回<code>AAChartModel</code>对象，这极大程度方便进行封装使用</p> 
<pre><code>mapChartView.aa_drawChartWithChartModel(InitRoseChart());
</code></pre> 
<pre><code> private AAChartModel InitRoseChart() {
        return new AAChartModel()
                .yAxisTitle("cm")
                .chartType(AAChartType.Column)
                .xAxisVisible(false)//是否显示最外一层圆环
                .yAxisVisible(true)//是否显示中间的多个圆环
                .yAxisAllowDecimals(true)
                .legendEnabled(false)//隐藏图例(底部可点按的小圆点)
                .categories(getTitles())
                .dataLabelsEnabled(true)
                .polar(true)//极地化图形
                .series(new AASeriesElement[]{
                                new AASeriesElement()
                                        .name("价格")
                                        .data(getRosePrice()),
                        }
                );
    }
</code></pre> 
<h5><a id="_879"></a>获取数据源</h5> 
<pre><code> /**
     * 南丁格尔玫瑰图数据源x*/
    private Object[] getRosePrice(){
        if (recordList.size() == 0 || recordList == null)return null;
        double[] d_price = new double[recordList.size()];
        Object[] o_price = new Object[recordList.size()];
        for (int i = 0; i &lt; recordList.size(); i++) {
            d_price[i] = Double.parseDouble(recordList.get(i).getGoodsPrice());
        }
        for (int i = 0; i &lt; recordList.size(); i++) {
            o_price[i] = new Double(d_price[i]);
        }
        return o_price;
    }
</code></pre> 
<h3><a id="_897"></a>记录删除</h3> 
<h4><a id="_898"></a>效果图</h4> 
<img src="https://images2.imgbox.com/7d/0c/PbhBOTan_o.jpg" width="50%"> 
<h4><a id="_901"></a>释</h4> 
<p>首先删除数据库中的对象，然后删除当前列表数据</p> 
<pre><code>    adapter.setDeleteListener(new OrderAdapter.onDeleteListener() {
            @Override
            public void onClickListener(int pos, Record bean) {
                dao.Delete(bean.getGoodsName());
                recordList.remove(pos);
                adapter.notifyDataSetChanged();
                EventBus.getDefault().postSticky(new UpdateBean(false));
            }
        });
</code></pre> 
<h2><a id="_915"></a>尾言</h2> 
<p>此代码为刚入门所敲，很多不足之处，最近有很多人找我要此项目代码，修复了一些Bug,增加删除功能，但由于之前技术不足，框架构建不是很好，无心去重构，再次感谢大家的厚爱</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9860322b2aa2c51e537b9841b407c3b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">php 操作sqlite</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d8fbbb46a4da67cb7892e526039d6f74/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">::在c&#43;&#43;中什么意思</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>