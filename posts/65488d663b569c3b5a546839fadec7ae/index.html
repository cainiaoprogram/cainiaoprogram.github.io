<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python爬虫学习第二章-3-使用requests模块实现破解百度翻译 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python爬虫学习第二章-3-使用requests模块实现破解百度翻译" />
<meta property="og:description" content="Python爬虫学习第二章-3-使用requests模块实现破解百度翻译 这一节是使用requests模块进行破解百度翻译
1、在这个案例中不是爬取整张页面，而是爬取部分内容，也就是翻译的结果，所以得需要解析（ajax请求可以进行页面局部的刷新，而在这个案例中，页面恰好是输入单词之后进行局部刷新，所以是ajax请求）， 此时对应的请求是一个post请求，并且此请求携带参数。-响应数据是一组json数据
2、步骤：
在这个案例中，我们需要抓取的是翻译后的结果，也就是一部分页面，所以不能对地址栏中的“https://fanyi.baidu.com/?aldtype=16047#auto/zh”发起请求。对于百度翻译这个页面，每输入一个字符页面都会自动进行部分刷新，这是依靠了ajax的请求，所以说需要通过抓包工具（inspect—&gt;network—&gt;XHR）查看Ajax发送的请求，也就是XHR。通过Request Method可以发现是post请求， 所以需要使用requests.post()方法。（也可以用数据解析方法获取局部数据，后边会介绍）
指定了url之后要紧跟着进行UA伪装，也就是
headers = {‘User-Agent’:‘Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36’}，确保发送请求能够成功。
UA伪装结束之后要进行参数处理，当然如果这个请求没有参数的话，可以不用进行处理，携带的参数可以在最下面的From Data中查看。
然后发送请求，定义一个resonance接收响应数据。
从response中获取数据，在这个案例中服务器响应的是json数据，json方法返回的就是一个字典对象，如果确认响应数据是json类型的，才可以使用json方法， 可以在抓包工具中查看Content-Type确定响应数据的类型。
进行持久化存储,因为响应数据是json对象，字典类型的，所以可以直接存放在json的文本文件当中，得先导入json模块。
3、实现的代码：
&#39;&#39;&#39; 步骤：指定url即指定网址进行UA伪装；对当前url发起请求，如get请求；获取服务器响应的数据，如显示的页面数据；将爬取到的响应数据进行持久化存储 -此时不是爬取整张页面，而是爬取部分内容，也就是翻译的结果，所以得需要解析（ajax请求可以进行页面局部的刷新） -此时对应的请求是一个post请求，并且此请求携带参数。 -响应数据是一组json数据 &#39;&#39;&#39; import requests import json if __name__==&#34;__main__&#34;: #1、指定url post_url = &#39;https://fanyi.baidu.com/sug&#39; #这个程序中的url需要从抓包工具中获取Ajax请求的url #2、进行UA伪装 headers = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36&#39; } #在url之后要紧接着进行UA伪装，也是定义一个headers #3、进行post请求的参数处理，同get请求的参数处理，。post方法的data参数所对应的数据是请求所携带的参数，相当于get请求中的params，也应该是一个字典，封装了url的参数 word = input(&#39;enter a word:&#39;) data = { &#39;kw&#39;:word } #4、请求发送，post请求发送成功之后也会返回一个响应数据，保存在response中 response=requests." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/65488d663b569c3b5a546839fadec7ae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-20T15:31:00+08:00" />
<meta property="article:modified_time" content="2020-10-20T15:31:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python爬虫学习第二章-3-使用requests模块实现破解百度翻译</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Python3requests_0"></a>Python爬虫学习第二章-3-使用requests模块实现破解百度翻译</h2> 
<p>  <strong>这一节是使用requests模块进行破解百度翻译</strong><br>   1、在这个案例中不是爬取整张页面，而是爬取部分内容，也就是翻译的结果，所以得需要解析（ajax请求可以进行页面局部的刷新，而在这个案例中，页面恰好是输入单词之后进行局部刷新，所以是ajax请求）， 此时对应的请求是一个post请求，并且此请求携带参数。-响应数据是一组json数据<br>   <strong>2、步骤：</strong></p> 
<ul><li> <p>在这个案例中，我们需要抓取的是翻译后的结果，也就是一部分页面，所以不能对地址栏中的“https://fanyi.baidu.com/?aldtype=16047#auto/zh”发起请求。对于百度翻译这个页面，每输入一个字符页面都会自动进行部分刷新，这是依靠了ajax的请求，所以说需要通过抓包工具（inspect—&gt;network—&gt;XHR）查看Ajax发送的请求，也就是XHR。通过Request Method可以发现是post请求， 所以需要使用requests.post()方法。（也可以用数据解析方法获取局部数据，后边会介绍）</p> </li><li> <p><mark>指定了url</mark>之后要紧跟着<mark>进行UA伪装</mark>，也就是<br> headers = {‘User-Agent’:‘Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36’}，确保发送请求能够成功。</p> </li><li> <p>UA伪装结束之后要<mark>进行参数处理</mark>，当然如果这个请求没有参数的话，可以不用进行处理，携带的参数可以在最下面的From Data中查看。</p> </li><li> <p>然后<mark>发送请求</mark>，定义一个resonance<mark>接收响应数据</mark>。</p> </li><li> <p>从response中获取数据，在这个案例中服务器响应的是json数据，json方法返回的就是一个<mark>字典对象</mark>，如果确认响应数据是json类型的，才可以使用json方法， 可以在抓包工具中查看Content-Type确定响应数据的类型。</p> </li><li> <p>进行<mark>持久化存储</mark>,因为响应数据是json对象，字典类型的，所以可以直接存放在json的文本文件当中，得先导入json模块。</p> </li></ul> 
<p>3、实现的代码：</p> 
<pre><code class="prism language-python"><span class="token triple-quoted-string string">'''
步骤：指定url即指定网址进行UA伪装；对当前url发起请求，如get请求；获取服务器响应的数据，如显示的页面数据；将爬取到的响应数据进行持久化存储
-此时不是爬取整张页面，而是爬取部分内容，也就是翻译的结果，所以得需要解析（ajax请求可以进行页面局部的刷新）
        -此时对应的请求是一个post请求，并且此请求携带参数。
            -响应数据是一组json数据
'''</span>
<span class="token keyword">import</span> requests
<span class="token keyword">import</span> json
<span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">"__main__"</span><span class="token punctuation">:</span>
    <span class="token comment">#1、指定url</span>
    post_url <span class="token operator">=</span> <span class="token string">'https://fanyi.baidu.com/sug'</span> <span class="token comment">#这个程序中的url需要从抓包工具中获取Ajax请求的url</span>

    <span class="token comment">#2、进行UA伪装</span>
    headers <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36'</span>
    <span class="token punctuation">}</span>    <span class="token comment">#在url之后要紧接着进行UA伪装，也是定义一个headers</span>

    <span class="token comment">#3、进行post请求的参数处理，同get请求的参数处理，。post方法的data参数所对应的数据是请求所携带的参数，相当于get请求中的params，也应该是一个字典，封装了url的参数</span>
    word <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'enter a word:'</span><span class="token punctuation">)</span>
    data <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">'kw'</span><span class="token punctuation">:</span>word
    <span class="token punctuation">}</span>
    <span class="token comment">#4、请求发送，post请求发送成功之后也会返回一个响应数据，保存在response中</span>
    response<span class="token operator">=</span>requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>post_url<span class="token punctuation">,</span>data <span class="token operator">=</span> data<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span>

    <span class="token comment">#5、获取响应数据,在这个案例中服务器响应的是json数据，json方法返回的就是一个字典对象（如果确认响应数据是json类型的，才可以使用json方法，可以在抓包工具中查看Content-Type确定响应数据的类型）</span>
    dic_obj <span class="token operator">=</span> response<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#返回的是一个字典对象</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>dic_obj<span class="token punctuation">)</span>

    <span class="token comment">#6、进行持久化存储,因为响应数据是json对象，字典类型的，所以可以直接存放在json的文本文件当中，得先导入json模块</span>
    filename <span class="token operator">=</span> word<span class="token operator">+</span><span class="token string">'.json'</span>
    fp <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>
    json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>dic_obj<span class="token punctuation">,</span>fp<span class="token operator">=</span>fp<span class="token punctuation">,</span>ensure_ascii<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment">#拿到的json串中有中文，而中文不能使用ASCII码进行编码，所以ensure_ascii应该是Fasle</span>
    fp<span class="token punctuation">,</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'over'</span><span class="token punctuation">)</span>

</code></pre> 
<p><strong>注意：</strong><br>   持久化存储中，响应数据是json对象，字典类型的，所以可以直接存放在json的文本文件当中，得先导入json模块；要注意使用的方法：</p> 
<pre><code class="prism language-python">filename <span class="token operator">=</span> word<span class="token operator">+</span><span class="token string">'.json'</span>
fp <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>
json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>dic_obj<span class="token punctuation">,</span>fp<span class="token operator">=</span>fp<span class="token punctuation">,</span>ensure_ascii<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment">#拿到的json串中有中文，而中文不能使用ASCII码进行编码，所以ensure_ascii应该是Fasle</span>
fp<span class="token punctuation">,</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>使用open方法，文件操作完毕之后必须手动关闭，否则长期保持对文件的连接状态，造成内存溢出的现象发生。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c57a9d47b342e697307ca1d5e65c57d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用js求最大值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e8befb9ba344850c5bf121369437e75/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【简单搜索】POJ 1321棋盘问题 详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>