<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>堆排序算法及其c语言泛型编程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="堆排序算法及其c语言泛型编程" />
<meta property="og:description" content="一:什么是堆? 1.堆: n个元素的序列{k 1,k 2,k 3,.....k n}当且仅当满足以下关系是,称为堆. {k i &lt;= k 2i 且 k i &lt;= k 2i&#43;1} 或 {k 2i &lt;= k i 且 k 2i&#43;1 &lt;= k i} (i = 1,2,...[n/2] ).这也是堆的一个性质. 2.堆结构是一种数组对象堆,它可以被视为一棵完全二叉树如下图, 书中每个节点与数组中存放该节点中值的那个元素 对应,除了最后一层,其余的每个节点都是满的.因为堆可看成是一棵完全二叉树,那它就满足一些树的性质, 对于有n个结点的完全二叉树,对任一结点i 有: 1) 如果 i = 1, 则结点i是二叉树的根,无双亲; 2)如果i &gt; 1,则其双亲Parent(i)是[ i / 2 ]; 3)如果2i &gt; n ,则结点i 无左孩子(结点i为 叶子结点);否 则,其 左孩子Lift_child(i) 是结点2i. 4)如果2i &#43; 1 &gt; n,则结点i无 右孩子;否则, 其右孩子right_child(i)是结点2i &#43; 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a9fd8bb859b91563e1c6b8161444d97d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-03-23T11:19:20+08:00" />
<meta property="article:modified_time" content="2014-03-23T11:19:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">堆排序算法及其c语言泛型编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    一:什么是堆? 
<br> 1.堆: n个元素的序列{k 
<sub>1,</sub>k 
<sub>2,</sub>k 
<sub>3,.....</sub>k 
<sub>n</sub>}当且仅当满足以下关系是,称为堆. {k 
<sub>i</sub> &lt;= k 
<sub>2i</sub> 且 k 
<sub>i</sub> &lt;= k 
<sub>2i+1</sub>} 或 
<br> {k 
<sub>2i</sub> &lt;= k 
<sub>i</sub> 且 k 
<sub>2i+1</sub> &lt;= k 
<sub>i</sub>} (i = 1,2,...[n/2] ).这也是堆的一个性质. 
<br> 
<br> 2.堆结构是一种数组对象堆,它可以被视为一棵完全二叉树如下图,  书中每个节点与数组中存放该节点中值的那个元素 
<br> 对应,除了最后一层,其余的每个节点都是满的.因为堆可看成是一棵完全二叉树,那它就满足一些树的性质, 
<br> 对于有n个结点的完全二叉树,对任一结点i 有:   
<br>   
<span style="color:rgb(0,153,0)">1)</span> 
<span style="color:rgb(0,153,0)">如果 i = 1,</span> 
<span style="color:rgb(0,153,0)">则结点i是二叉树的根,无双亲;</span> 
<br> 
<span style="color:rgb(0,153,0)">    2)如果i &gt; 1,则其双亲Parent(i)是[ i / 2</span> 
<span style="color:rgb(0,153,0)">];</span> 
<br> 
<span style="color:rgb(0,153,0)">    3)如果2i &gt; n</span> 
<span style="color:rgb(0,153,0)">,则结点i 无左孩子(结点i为</span> 
<span style="color:rgb(0,153,0)">叶子结点);否</span> 
<span style="color:rgb(0,153,0)">则,其</span> 
<span style="color:rgb(0,153,0)">左孩子Lift_child(i) 是结点2i.</span> 
<br> 
<span style="color:rgb(0,153,0)">    4)如果2i + 1 &gt; n,则结点i无</span> 
<span style="color:rgb(0,153,0)">右孩子;否则,</span> 
<span style="color:rgb(0,153,0)">其右孩子right_child(i)是结点2i + 1.<br>     5)其非终端结点是第[ n / 2]个元素,(非终端结点是指:完全二叉树中的最后一个带有叶子的结点).</span> 
<br>           
<span style="font-size:14px; line-height:21px">  </span> 
<img alt="" src="https://images2.imgbox.com/49/cf/Vfd8EvDJ_o.gif" width="110" height="77" style="line-height:1.5"> 
<blockquote style="padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 0px 40px; padding-right:0px; text-indent:2em"> 
 <span style="font-size:14px; line-height:21px"><br> 二:堆的分类<br> 堆包含: 1.大根堆. 2.小根堆.       <br>         1. 大根堆必须满足: {k<sub>i</sub> &lt;= k<sub>2i</sub> , k<sub>i</sub> &lt;= k<sub>2i+1</sub>}  (i = 1,2,...[n/2] ), 大根堆排序后元素是由小到大的顺序.<br>         2.小根堆必须满足:  {k<sub>2i</sub> &lt;= k<sub>i</sub> , k<sub>2i+1</sub> &lt;= k<sub>i</sub>} (i = 1,2,...[n/2] ).  小根堆排序后元素是由大到小的顺序.<br> <span style="line-height:20px">【例】关键字序列(10，15，56，25，30，70)和(70，56，30，25，15，10)分别满足堆性质(1)和(2)，</span><br style="line-height:20px"> <span style="line-height:20px">故它们均是堆，其对应的完全二叉树分别如小根堆示例和大根堆</span><span style="line-height:20px">示例所示</span><span style="line-height:20px">:</span><br> <img alt="" src="https://images2.imgbox.com/ec/2b/P7hTU2sM_o.png" width="518" height="339"><br> <br> <br> <span style="font-size:16px; color:rgb(229,51,51)">在下面所举的例子或代码中默认的是数组中元素是从下标1开始存储的.</span><br> <br> 三:如何实现堆排序?<br> 1.堆排序需要解决的两个问题就是:(1)如何由一个无序序列建成一个堆? (2)如何在输出堆顶元素之后,<br>    调整剩余元素成为一个新的堆?<br>       <br> 2. 让一个无序序列建成一个堆的最重要的步骤就是堆调整(牢记堆性质).<br>     堆调整的思想:<br>        1).把待调整的记录当成根,然后比较此根和其左,右孩子这三个数的大小,如果左,右孩子中还中有一个最大的,<br>             则把此最大值与根值交换(这是大根堆调整法,小根堆调整只需找到最小的值并与根交换就行),<br>        2).接着从最大值下标开始,并又以此结点为根重复1)中的步骤直到最大值下标循环的叶子结点.<br>         3)如果1)中比较后得到的最大值(/最小值)仍为根,则表示以此根结点的子序列已满足堆性质,就已经是堆了,<br> <br> 下面就堆调整的伪代码:<br>     <span style="line-height:20px">array[]可知是我们将要调整的序列数组,index 则表示的是将要调整的记录的</span><span style="line-height:20px">下标.<span style="color:rgb(51,127,229)">wait_adjust_length</span>是待调整堆的长度.  </span><br> </span> 
 <div> 
  <div> 
   <p>点击(<span style="color:red">此处</span>)折叠或打开</p> 
  </div> 
  <div> 
   <ol style="padding-left:40px; margin:0px 1px 0px 0px"><li>heap_adjust<span style="color:rgb(0,0,204)">(</span>NumType <span style="color:rgb(255,0,0)"> array</span><span style="color:rgb(0,0,204)">[</span><span style="color:rgb(0,0,204)">]</span><span style="color:rgb(0,0,204)">,</span> <span style="color:rgb(255,0,0)">int</span> index ,<span style="color:rgb(229,51,51)">int</span> wait_adust_length<span style="color:rgb(0,0,204)">)</span><br> </li><li><br> </li><li>    lift_index = 2 * index ;//记录待调整记录的左孩子的下标<br> </li><li>    right_index = 2 * index + 1;//记录待调整记录的右孩子的下标<br> </li><li>   <br> </li><li>  <span style="color:rgb(0,0,255)">if</span> lift_index <span style="color:rgb(0,0,204)"> &lt;&lt;/SPAN&gt;= <span style="color:rgb(0,0,0)">wait_adjust_</span><span style="color:rgb(0,0,0)">lenght</span> <span style="color:rgb(0,0,255)">and</span> <span style="color:rgb(255,0,0)">array</span>[<span style="color:rgb(0,0,0)">lift_index</span>] &gt; <span style="color:rgb(255,0,0)">array</span>[<span style="color:rgb(0,0,0)">right_index</span>]<br> </span></li><li>          <span style="color:rgb(0,0,255)">then</span> max_num_index = lift_index<span style="color:rgb(0,0,204)">;</span><br> </li><li>          <span style="color:rgb(0,0,255)">else</span> max_num_index = right_index;<br> </li><li>  <span style="color:rgb(0,0,255)">if</span> right_index <span style="color:rgb(0,0,204)"> &lt;&lt;/SPAN&gt;=<span style="color:rgb(0,0,0)"> wait_adjust</span><span style="color:rgb(0,0,0)">_length</span> <span style="color:rgb(0,0,255)">and</span> <span style="color:rgb(255,0,0)">array</span>[<span style="color:rgb(0,0,0)">right_index</span>] &gt; <span style="color:rgb(255,0,0)">array</span>[<span style="color:rgb(0,0,0)">max_num_index</span>]<br> </span></li><li>   <span style="color:rgb(0,0,255)">then</span> max_num_index = right_index;<br> </li><li>   <span style="color:rgb(0,0,255)">if</span> max_num_index != index<br> </li><li>        <span style="color:rgb(0,0,255)">then</span> <span style="color:rgb(0,51,153)"> exchange</span> <span style="color:rgb(255,0,0)">array</span><span style="color:rgb(0,0,204)">[</span>index<span style="color:rgb(0,0,204)">]</span> <span style="color:rgb(0,0,204)">&lt;&lt;/SPAN&gt;---&gt; <span style="color:rgb(255,0,0)">array</span>[<span style="color:rgb(0,0,0)">max_num_index</span>]<br> </span></li><li>          heap_adjust<span style="color:rgb(0,0,204)">(</span><span style="color:rgb(255,0,0)">array</span><span style="color:rgb(0,0,204)">,</span> max_num_index<span style="color:rgb(0,0,204)">)</span><span style="color:rgb(0,0,204)">;</span></li></ol> 
  </div> 
 </div>  heap_adjust的作用过程如下图:  此处wait_adjust_length = 10; 
 <br>         图a) 改堆的初始构造,在节点i =2处array[2]违反了堆的性质,因为它不大于它的两个子女(此处是以 大根堆 举例).   
 <br> 在图b)中通过交换array[2]与array[4],因此在结点2处恢复的堆的性质,但又在结点4处违反了堆的性质现在递归调用heap_adjust(array, 4)就置index=4. 
 <br> 图(c)中在交换了array[4]与array[9]后,结点,结点4处堆性质得到恢复,递归调用heap_adjust(array, 9)对该数据结构不再引起任何变化.         
 <br>     在算法的每一步里,从元素array[i],array[lift_index]和array[right_index]中找到最大的,并将其下标存在max_num_index中.如果array[index]是最大的,则以index为根的子树已是堆,算法结束.否则, 
 <br> index的某个子结点中有最大元素，则换array[index]和array[max_num_index]，从而使i及其子女 
 <br> 满足堆的性质，交换后的结点max_num_index中原先的array[index]，以该结点为根的子树又有可能 
 <br>  违反堆性质，因而，要对该子树递归调用heap_adjust. 
 <br> 
 <img alt="" src="https://images2.imgbox.com/e7/83/vt89gdK8_o.png" width="354" height="244"> 
 <img alt="" src="https://images2.imgbox.com/4d/69/8vXF8H79_o.png" width="349" height="239">   
 <img alt="" src="https://images2.imgbox.com/43/e3/MEtnNvjE_o.png" width="335" height="231"> 
 <br> 此堆调整算法的时间复杂度: 
 <br>         heap_adjust(..)作用在一棵以结点index为根的大小为n的子树上运行运行时间是O(1),在这个时间内完成调整元素array[index], array[lift_child(index)],array[right_child(index)]的关系,并对一index的某个子节点为根的子树递归调用heap_adjust(..). index的 
 <span style="color:rgb(229,51,51)">子节点</span> 
 <span style="color:rgb(229,51,51)">的子树大小</span>约为2n/3.最坏的情况发生在树的最底一层恰好为半满的时候,这时heap_adjust的运算时间可由下式描述: 
 <br>         T(n) &lt;= T(2n/3) +O(1) 
 <br>     可得:T(n) = O(lg n); 
 <br> 
 <br> 3.建堆。 
 <br>     可以自底向上地用heap_adjust来将一个数组array[1..n] (n = length[array])变成一个堆，因为， 
 <br> 子数组array[(n/2+1)  ....n ]中的元素都是树上中的叶子，每个叶子都可以看成是一个元素的堆, 
 <span style="font-size:14px; line-height:20px">根据堆的性质知，根是</span> 
 <span style="font-size:14px; line-height:20px">一个最值，</span>而自底向上调整数组，就是子根与子根或是子根与叶 再和父根比较 进而可保证越往上值越大(越小）。    
 <br>     以下使建堆的伪代码： 
 <br>     
 <br> 
 <div> 
  <div> 
   <p>点击(<span style="color:red">此处</span>)折叠或打开<br> <span style="font-family:Consolas,monospace; letter-spacing:0px; line-height:1.3">build_heap<span style="font-family:Consolas"><span style="color:rgb(0,0,204)">(</span> <span style="color:rgb(255,0,0)">array</span><span style="color:rgb(0,0,204)">[</span><span style="color:rgb(0,0,204)">]</span> <span style="color:rgb(0,0,204)">)</span></span></span><span style="font-family:Consolas,monospace; letter-spacing:0px; line-height:1.3"> </span></p> 
  </div> 
  <div> 
   <ol style="padding-left:40px; margin:0px 1px 0px 0px"><li><span style="color:rgb(0,0,255); letter-spacing:0px; line-height:1.3">    </span></li><li><span style="color:rgb(0,0,255); letter-spacing:0px; line-height:1.3">f</span><span style="color:rgb(0,0,255); letter-spacing:0px; line-height:1.3">or</span> <span style="color:rgb(92,92,92); letter-spacing:0px; line-height:1.3">i</span> <span style="color:rgb(0,0,204); letter-spacing:0px; line-height:1.3"> =</span> <span style="color:rgb(92,92,92); letter-spacing:0px; line-height:1.3">array_length</span> <span style="color:rgb(0,0,204); letter-spacing:0px; line-height:1.3">/</span> <span style="color:rgb(92,92,92); letter-spacing:0px; line-height:1.3"> 2</span><span style="color:rgb(0,0,204); letter-spacing:0px; line-height:1.3">;</span> <span style="color:rgb(92,92,92); letter-spacing:0px; line-height:1.3">i</span> <span style="color:rgb(0,0,204); letter-spacing:0px; line-height:1.3"> &gt;</span> <span style="color:rgb(92,92,92); letter-spacing:0px; line-height:1.3">0</span><span style="color:rgb(0,0,204); letter-spacing:0px; line-height:1.3">;</span> <span style="color:rgb(92,92,92); letter-spacing:0px; line-height:1.3">i</span><span style="color:rgb(0,0,204); letter-spacing:0px; line-height:1.3">-</span><span style="color:rgb(0,0,204); letter-spacing:0px; line-height:1.3">-</span></li><li>  <span style="color:rgb(76,51,229)"> heap_adjust</span><span style="color:rgb(0,0,204)">(</span><span style="color:rgb(255,0,0)">array</span><span style="color:rgb(0,0,204)">,</span>i <span style="color:rgb(0,0,204)">)</span><span style="color:rgb(0,0,204)">;</span></li></ol> 
  </div> 
 </div> 下面是一个建堆的过程:  如图(a),这是当i = 2 ,也就是以array[2] = 4为根的子树调整,因为i是从i = 4开始调整堆的,然后i--,所以我们可以看到i = 4, i =3,时,其子树已构成 
 <br> 了一个堆,所以当i =2 ,调用heap_adjust(array,i),先让 index = 2 和2index = 4的结点比较,可得2i结点值大,然后将max_num_index=2index, 然后,用max_num_index和2index+1 = 5的结点比较,可知max_num_index没变,到此已知待调整结点和其子结点中的最大结点下标,然后判断max_num_index 是否等于 index(待排序结点,值为i ),可知max_num_index != index,则将 max_num_index 结点和 index结点进行交换如图(b); 因为,值交换后index = 4的结点破坏了堆的性质,所以,又要堆i = 4结点进行调整,所以在heap_adjust中开始递归调整最后得到(c)图,此时以i= 2为根的子树以满足堆的性质;然后,在build_heap中,i--, i =1,再调用heap_adjust(array,i),然后就重复i = 2是结点调整的步骤,最后就可得一个完整的堆. 
 <br> 
 <br> 
 <img alt="" src="https://images2.imgbox.com/23/c8/SktFVZGa_o.png" width="581" height="543"> 
 <br> 
 <br> 此建堆函数的时间复杂度: 
 <br>         T(n) = O(n); 
 <br> 
 <br> 4.堆排序. 
 <br>         堆排序,首先应该是一个堆,即先让一个无序序列调整成一个堆,然后再进行排序. 
 <br> 
 <br> 排序的思想: 
 <br>     1)首先要清楚堆的一个性质,那就是 
 <span style="color:rgb(229,51,51)">根为最值. </span>因为数组中最大(或最小)元素是在根array[1]上,因此通过访问根就可以到达排序的效果.  
 <br>     2)可通过把它与叶子结点array[n]进行交换来达到最终的正确位置.因为叶子都在array[n/2+1 ..n]上,让第一最值根和最后一个叶子交换,然后,再进行堆调整. 
 <br>     3)第2)中的交换产生两种效果: 
 <br>             其一,将第一最值保存到array的最后一个元素空间中(此时已进开始进行数组就地排序了!!) 
 <br>             其二,叶子结点到根后就会破坏堆性质,那就会引起堆调整反应(但,此时的调整有点变化的就是待调整堆的长度,还是原来的数组长度吗? 那肯定不是,如果还是数组长度的话,就会把叶子上的最值又调到了根上,那就会重复访问根了,所以每次交换后, 
 <span style="color:rgb(229,51,51)">待排序的长度就要减一(待排序的堆大小)</span>,使得堆调整到达交换的叶子结点.),进而将第二最值调到了根array[1]的位置. 
 <br>         然后就是将次最值和倒数第二个叶子交换(将此最值保存到第一最值的前一位置),就这样重复1)步骤,直到最后一个元素. 
 <br> 
 <br> 下面是排序的伪代码: 
 <br> heap_length表示数组的长度, wait_adjust_length是待调整堆的长度. 
 <br> 
 <div> 
  <div> 
   <p>点击(<span style="color:red">此处</span>)折叠或打开</p> 
  </div> 
  <div> 
   <ol style="padding-left:40px; margin:0px 1px 0px 0px"><li>heap_sort<span style="color:rgb(0,0,204)">(</span> <span style="color:rgb(255,0,0)"> array</span><span style="color:rgb(0,0,204)">[</span><span style="color:rgb(0,0,204)">]</span> <span style="color:rgb(0,0,204)">)</span><br> </li><li>   <br> </li><li>   build_heap<span style="color:rgb(0,0,204)">(</span> <span style="color:rgb(255,0,0)"> array</span><span style="color:rgb(0,0,204)">)</span><span style="color:rgb(0,0,204)">;</span><br> </li><li>   <span style="color:rgb(0,0,255)">for</span> i <span style="color:rgb(0,0,204)"> =</span> heap_length<span style="color:rgb(0,0,204)">;</span> i <span style="color:rgb(0,0,204)"> &gt;</span> 1<span style="color:rgb(0,0,204)">;</span> i<span style="color:rgb(0,0,204)">-</span><span style="color:rgb(0,0,204)">-</span><br> </li><li>        <span style="color:rgb(0,0,255)">do</span> exchange <span style="color:rgb(255,0,0)"> array</span><span style="color:rgb(0,0,204)">[</span>1<span style="color:rgb(0,0,204)">]</span> <span style="color:rgb(0,0,204)">&lt;&lt;/SPAN&gt;---&gt;<span style="color:rgb(255,0,0)">array</span>[i];<br> </span></li><li>             wait_adjust_length <span style="color:rgb(0,0,204)">=</span> i <span style="color:rgb(0,0,204)"> -</span> 1<span style="color:rgb(0,0,204)">;</span><br> </li><li>              heap_adjust<span style="color:rgb(0,0,204)">(</span><span style="color:rgb(255,0,0)">array</span><span style="color:rgb(0,0,204)">,</span> 1 ,wait_adjust_length<span style="color:rgb(0,0,204)">)</span><span style="color:rgb(0,0,204)">;</span></li></ol> 
  </div> 
 </div> 
 <br> 
 <img alt="" src="https://images2.imgbox.com/ec/87/KgHb3Xz8_o.png" width="590" height="537"> 
 <br> 
 <br> 
 <img alt="" src="https://images2.imgbox.com/dd/2c/Kf1W51y3_o.png" width="618" height="555"> 
 <br> 
 <br> 
 <img alt="" src="https://images2.imgbox.com/f2/2e/jSZ5nnP2_o.png" width="551" height="251"> 
 <br> 
 <br> 此排序函数的时间复杂度: 
 <br>     T(n) = O(nlgn); 
 <br> 
 <br> 由于前面内容较长,再在此处列出程序,会感到很杂乱.所以我把它上传到github上了,如有需要,可点击查看. 
 <br> 
 <span style="font-size:16px; color:rgb(51,127,229)">c语言的堆排序的泛型程序详见:</span> 
 <span style="font-size:16px; color:rgb(51,127,229)"><a target="_blank" href="http://blog.chinaunix.net/git@github.com:zbqyexingkong/c_array_sort.git" rel="nofollow noopener noreferrer">git@github.com:zbqyexingkong/c_array_sort.git</a></span> 
 <br> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf2257b0dbda6ee322d0836f4a180edf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android -- 读写文件到内部ROM，SD卡，SharedPreferences，文件读写权限</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8171e5f748fc17c7d013eb642c9a7e1f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Hadoop基础】hadoop fs 命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>