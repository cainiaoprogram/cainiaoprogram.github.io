<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MMCV注册机制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MMCV注册机制" />
<meta property="og:description" content="目录
引言
1. Introduction
2. MMCV核心组件——Config &amp; Registry 2.1 Config类
2.2 从配置文件中生成Config类
2.3预定义变量解析
2.4 配置文件的继承
2.5 Registry
2.6 示例 2.7 自定义构建函数（Build Function）
2.8 层次注册
引言 MMCV学习 最近在学习mmcv这个基础库，所以写一个博客记录一下。一来是作为学习笔记，方便日后查阅，二来是和大家分享交流一下我得学习心得。mmcv是由OpenMMLab开源的一个计算机视觉的基础库，支持了OpenMMLab众多开源的优秀仓库(比如，MMDetection、MMSegmentation、MMSelfSup等等)。
1. Introduction mmcv作为一个基础库，主要提供了以下的功能模块：
统一可扩展的 io api支持非常丰富的图像/视频处理算子图片/视频的标注文件可视化常用的工具类例如 timer 和 progress bar 等等上层框架需要的 hook 机制以及可以直接使用的 runner高度灵活的 cfg 模式和注册器机制高效高质量的 cuda op 2. MMCV核心组件——Config &amp; Registry 2.1 Config类 官网解释：
Config class is used for manipulating config and config files. It supports loading configs from multiple file formats including python, json and yaml." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cc26684b9f5a8600f133cfc1fede81f2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-20T17:25:31+08:00" />
<meta property="article:modified_time" content="2023-05-20T17:25:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MMCV注册机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%BC%95%E8%A8%80-toc" style="margin-left:40px;"><a href="#%E5%BC%95%E8%A8%80" rel="nofollow">引言</a></p> 
<p id="devmenu3-toc" style="margin-left:40px;"><a href="#devmenu3" rel="nofollow">1. Introduction</a></p> 
<p id="2.%20MMCV%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Config%20%26%20Registry%C2%A0-toc" style="margin-left:40px;"><a href="#2.%20MMCV%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Config%20%26%20Registry%C2%A0" rel="nofollow">2. MMCV核心组件——Config &amp; Registry </a></p> 
<p id="devmenu7-toc" style="margin-left:80px;"><a href="#devmenu7" rel="nofollow">2.1 Config类</a></p> 
<p id="2.2%20%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%94%9F%E6%88%90Config%E7%B1%BB-toc" style="margin-left:80px;"><a href="#2.2%20%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%94%9F%E6%88%90Config%E7%B1%BB" rel="nofollow">2.2 从配置文件中生成Config类</a></p> 
<p id="2.3%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.3%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90" rel="nofollow">2.3预定义变量解析</a></p> 
<p id="2.4%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%A7%E6%89%BF-toc" style="margin-left:80px;"><a href="#2.4%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%A7%E6%89%BF" rel="nofollow">2.4 配置文件的继承</a></p> 
<p id="devmenu8-toc" style="margin-left:80px;"><a href="#devmenu8" rel="nofollow">2.5 Registry</a></p> 
<p id="2.6%20%E7%A4%BA%E4%BE%8B%C2%A0-toc" style="margin-left:80px;"><a href="#2.6%20%E7%A4%BA%E4%BE%8B%C2%A0" rel="nofollow">2.6 示例 </a></p> 
<p id="2.7%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA%E5%87%BD%E6%95%B0%EF%BC%88Build%20Function%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.7%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA%E5%87%BD%E6%95%B0%EF%BC%88Build%20Function%EF%BC%89" rel="nofollow">2.7 自定义构建函数（Build Function）</a></p> 
<p id="2.8%20%E5%B1%82%E6%AC%A1%E6%B3%A8%E5%86%8C-toc" style="margin-left:80px;"><a href="#2.8%20%E5%B1%82%E6%AC%A1%E6%B3%A8%E5%86%8C" rel="nofollow">2.8 层次注册</a></p> 
<hr> 
<h3 id="%E5%BC%95%E8%A8%80">引言</h3> 
<p>      MMCV学习 最近在学习mmcv这个基础库，所以写一个博客记录一下。一来是作为学习笔记，方便日后查阅，二来是和大家分享交流一下我得学习心得。mmcv是由OpenMMLab开源的一个计算机视觉的基础库，支持了OpenMMLab众多开源的优秀仓库(比如，MMDetection、MMSegmentation、MMSelfSup等等)。</p> 
<h3 id="devmenu3">1. Introduction</h3> 
<p>  mmcv作为一个基础库，主要提供了以下的功能模块：</p> 
<ul><li>统一可扩展的 io api</li><li>支持非常丰富的图像/视频处理算子</li><li>图片/视频的标注文件可视化</li><li>常用的工具类例如 timer 和 progress bar 等等</li><li>上层框架需要的 hook 机制以及可以直接使用的 runner</li><li>高度灵活的 cfg 模式和注册器机制</li><li>高效高质量的 cuda op</li></ul> 
<h3 id="2.%20MMCV%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Config%20%26%20Registry%C2%A0">2. MMCV核心组件——Config &amp; Registry </h3> 
<h4 id="devmenu7">2.1 Config类</h4> 
<p><strong>官网解释：</strong></p> 
<p>  <code>Config</code> class is used for manipulating config and config files. It supports loading configs from multiple file formats including <strong>python</strong>, <strong>json</strong> and <strong>yaml</strong>. It provides <strong>dict-like apis</strong> to <strong>get</strong> and <strong>set</strong> values.</p> 
<h4 id="2.2%20%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%94%9F%E6%88%90Config%E7%B1%BB">2.2 从配置文件中生成Config类</h4> 
<p>假设我们这里有一个config.py文件定义如下：</p> 
<pre><code class="language-python">a = 1
b = dict(b1=[0, 1, 2], b2=None)
c = (1, 2)
d = 'string'
</code></pre> 
<p>我们直接读取这个python文件，然后打印出来：</p> 
<pre><code class="language-python">config = Config.fromfile("config.py")
print(config)
print(type(config))
# Output
# Config (path: config.py): {'a': 1, 'b': {'b1': [0, 1, 2], 'b2': None}, 'c': (1, 2), 'd': 'string'}
# &lt;class 'mmcv.utils.config.Config'&gt;
</code></pre> 
<h4 id="2.3%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90">2.3预定义变量解析</h4> 
<p>      除了直接定义配置变量之外，Config还支持解析预定义变量，其格式如下 { { v a r } } \{\{ var \}\} {<!-- -->{var}}。目前，Config支持解析四种预定义的变量，可以方便地获取被打开的配置文件所在绝对路径的各个部分：</p> 
<ul><li>{ { f i l e D i r n a m e } } \{\{ \mathrm{fileDirname} \}\} {<!-- -->{fileDirname}} - 当前被打开的配置文件所在目录。</li><li>{ { f i l e B a s e n a m e } } \{\{ \mathrm{fileBasename} \}\} {<!-- -->{fileBasename}} - 当前被打开的配置文件名字，附带后缀。</li><li>{ { f i l e B a s e n a m e N o E x t e n s i o n } } \{\{ \mathrm{fileBasenameNoExtension} \}\} {<!-- -->{fileBasenameNoExtension}} - 当前被打开的配置文件名字，不带后缀。</li><li>{ { f i l e E x t n a m e } } \{\{ \mathrm{fileExtname } \}\} {<!-- -->{fileExtname}} - 当前被打开的配置文件名后缀。</li></ul> 
<p> 不过，其实从之前打印Config的示例对象时可以看出来现在的mmcv给Config示例提供了对象属性<strong>path</strong>，我们可以直接使用path这个属性获取被打开配置的绝对路径。</p> 
<h4 id="2.4%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%A7%E6%89%BF">2.4 配置文件的继承</h4> 
<p> mmcv考虑到了提供配置文件的可复用性，提供了一系列的配置文件继承的操作，并让用户可以灵活选定被继承的部分。</p> 
<p> 想要让一个配置文件继承另一个配置文件，只需要在子配置文件之中指定_base_变量为父配置文件的 <strong>相对路径（相对于config_b）</strong> 即可。例如，我们有一个config_a.py配置文件如下：</p> 
<pre><code class="language-python"># config_a.py
a = 1
b = dict(b1=[0, 1, 2], b2=None)
</code></pre> 
<p> 为了继承config_a，我们可以在config_b文件中指定_base_变量：</p> 
<pre><code class="language-python"># config_b.py
_base_ = './config_a.py'
b = dict(b2=1)
c = (1, 2)
</code></pre> 
<pre><code class="language-python">config = Config.fromfile("./config_b.py")
print(config)
# Output
# Config (path: ./config_b.py): {'a': 1, 'b': {'b1': [0, 1, 2], 'b2': 1}, 'c': (1, 2)}
</code></pre> 
<p>        从上面的输出可以看出来，当子配置文件和父配置文件存在key冲突的时候（b.b2），会以子配置文件为主。这一行为和面向对象之中的继承过程十分相似，所以这里也被叫做配置文件的继承而不是配置文件的合成。<strong>PS：</strong> Config支持从多个文件之中继承，只需要把_base_定义为[‘config1.py’, ‘config2.py’, …]这样一个列表即可，<strong>但是base配置之中不能存在相同的key</strong>，否则Config就不知道该以哪个base为准了。</p> 
<p> 下面我们来看一个Config继承之中<strong>比较有用的语法</strong>，可以让我们直接在子配置文件中使用父配置文件中定义的变量。例如，我们要在子配置文件config_c.py中使用父配置文件config_a.py中的变量：</p> 
<pre><code class="language-python"># config_c.py
_base_ = ['./config_a.py']
item = dict(a = {<!-- -->{ _base_.a}}, b = {<!-- -->{_base_.b.b1}})
</code></pre> 
<pre><code class="language-python">config = Config.fromfile("./config_c.py")
print(config)
# Output:
# Config (path: ./config_c.py): {'a': 1, 'b': {'b1': [0, 1, 2], 'b2': None}, 'item': {'a': 1, 'b': [0, 1, 2]}}
</code></pre> 
<h4 id="devmenu8">2.5 Registry</h4> 
<p>官方解释：</p> 
<p>MMCV implements <code>registry</code> to manage different modules that share <strong>similar functionalities</strong>, e.g., backbones, head, and necks, in detectors.</p> 
<p>在MMCV之中可以将registry看做是字符串到class之间的映射，这些同一个registry之下的class有着相似的功能，有点类似于面向对象的多态。有了registry之后，用户可以之间使用字符串调用和实例化那些class。Registry的使用流程主要分为一下三步骤：</p> 
<ul><li>创建构造方法（optional）</li><li>创建registry</li><li>使用了registry去管理这些modules</li></ul> 
<h4 id="2.6%20%E7%A4%BA%E4%BE%8B%C2%A0">2.6 示例 </h4> 
<p>      下面来一个简单的例子，看看怎么用Registry去管理一个包下面的的module。假设我们有一个converter的包，理由有我们实现的不同功能的converter类。<br>  首先，我们要现在创建converter/builder.py文件去为converter创建registry：</p> 
<pre><code class="language-python"># converter/builder.py
from mmcv.utils import Registry
CONVERTERS = Registry("converter")
</code></pre> 
<p> 然后通过CONVERTERS去注册我们要管理的Converter1这个类：</p> 
<pre><code class="language-python"># converter/conerter1.py
from .builder import CONVERTERS

# 这里需要说明一下, 由于python的装饰器机制是在类定义被加载时触发，所以一般需要在converter/__init__.py里面去import这个类。
@CONVERTERS.register_module()
class Converter1(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b
</code></pre> 
<p>假设在外部有主文件要是用Converter1这个类，那么我们的写法就可以变得更加优雅而不是到处去import：</p> 
<pre><code class="language-python"># main.py
from converter import CONVERTERS

if __name__ == "__main__":
    converter_cfg = dict(type='Converter1', a=1, b=2)
    converter = CONVERTERS.build(converter_cfg)  # 这里的build是mmcv帮我们默认实现了
    print(converter)
</code></pre> 
<h4 id="2.7%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA%E5%87%BD%E6%95%B0%EF%BC%88Build%20Function%EF%BC%89">2.7 自定义构建函数（Build Function）</h4> 
<p> 上面那个入门例子只是讲解了如何去利用Registry去实例化被管理的类，默认情况下使用mmcv默认实现的build函数读取配置文件并实例化已经足够了。这样的管理方式实现了直接由配置文件到实例化类的过程，这样以后要修改一些参数可以只用改配置文件就行了，十分方便。<br>  如果我们需要自定义构建函数，那么可以按照以下的方法自定义：</p> 
<pre><code class="language-python"># converter/builder.py
from mmcv.utils import Registry


def build_converter(cfg, registry, *args, **kwargs):
    # print(args)
    # print(kwargs)
    cfg_ = cfg.copy()
    converter_type = cfg_.pop("type")
    if converter_type not in registry:
        raise KeyError(f"Unrecognized converter type {converter_type}")
    else:
        converter_cls = registry.get(converter_type)
    converter = converter_cls(*args, **kwargs, **cfg_)
    return converter


CONVERTERS = Registry("converter", build_func=build_converter)
</code></pre> 
<h4 id="2.8%20%E5%B1%82%E6%AC%A1%E6%B3%A8%E5%86%8C">2.8 层次注册</h4> 
<p> MMCV下游的所有代码库model的registry都是mmcv的<code>MODELS</code>的子注册，这里一般有两种方式从姊妹的registry和父类的registry中实例化model：</p> 
<p>（1）从姊妹的registry实例化：</p> 
<pre><code class="language-python"># 假设我们有一个classfication的代码库叫mmcls.py
from mmcv.utils import Registry
from mmcv.cnn import MODELS as MMCV_MODELS
from torch import nn

# Create a register
MODELS = Registry("model", parent=MMCV_MODELS)

# classification net
@MODELS.register_module()
class ClsNet(nn.Module):

    def __init__(self) -&gt; None:
        super().__init__()
</code></pre> 
<pre><code class="language-python"># detection的代码库叫mmdet.py
from mmcv.utils import Registry
from mmcv.cnn import MODELS as MMCV_MODELS
import mmcls
from torch import nn

# Create a register
MODELS = Registry("model", parent=MMCV_MODELS)

# Detection net
@MODELS.register_module()
class DetNet(nn.Module):

    def __init__(self) -&gt; None:
        super().__init__()

# 这里我们使用mmdet的registry去实例化cls_net和det_net, 所以det_net不加模块名而cls_net要加
if __name__ == "__main__":
    det_net = MODELS.build({"type": "DetNet"})
    cls_net = MODELS.build({"type": "mmcls.ClsNet"})
    print(det_net)
    print(cls_net)
</code></pre> 
<p>（2）从父类的registry实例化：</p> 
<pre><code class="language-python"># 外部父类的文件hierarchy_reg.py实例化
from mmcv.cnn import MODELS as MMCV_MODELS
import mmcls
import mmdet


if __name__ == "__main__":
    det_net = MMCV_MODELS.build({"type": "mmdet.DetNet"})
    cls_net = MMCV_MODELS.build({"type": "mmcls.ClsNet"})
    print(det_net)
    print(cls_net)
</code></pre> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0db263db42ff428e6311cb48a7fa7b4a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;游戏开发——坦克大战</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/64e803e8140f24db9046ac9132b62031/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">哨兵二号（Sentinel-2）数据下载方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>