<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>山东大学操作系统实验问题解决 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="山东大学操作系统实验问题解决" />
<meta property="og:description" content="本文以记录完成2020学年上期操作系统实验过程中的学习和参考资料 基础pv基础 Makefilefork()函数实验四：进程同步实验基础示例变量函数 吸烟者问题(Smoker Problem) 实验五：进程互斥实验 基础 vim详解将vim的内容复制到系统剪切板上将字符串转换为整数类型处理warning：implicit declaration of function XXX，是因为函数没有在头文件定义，因此导致编译的时候没法儿正确生成.o文件。我出现了下图的状况：
添加&lt;unistd.h&gt;头文件，这是Linux/Unix内置系统的头文件，包含很多系统服务的函数原型。C、C&#43;&#43;中union用法总结Linux目录文件权限，还真是啥都忘了吼fgets函数 pv基础 信号量S：
若大于等于0，则表示可供并发进程使用的资源的实体数；
若小于0，则表示正在等待使用临界区的进程的个数
所以初值应该设为大于0原语：不可中断的程序段P：S-1
若结果仍然大于等于0，则进程继续执行；
若结果小于0，则进程阻塞，进入与该信号相对应的队列当中，然后转进程调度。
V：S&#43;1
若结果仍然大于0，则进程继续执行；
若结果小于等于0（注意0的情况在第二种），则从该信号的等待队列中唤醒一个等待进程，然后再返回原来的进程继续执行或转进程调度。临界资源：每次仅允许一个进程访问的资源，例如打印机，消息缓冲队列，变量，缓冲区等等。大多数情况下同步已经实现了互斥，同步是在互斥的基础上通过其他机制实现访问者对资源的有序访问（互斥是无序的)。 Makefile 跟我一起写Makefile（一）
跟我一起写Makefile（二）
（系列文章都在评论中有指路）
初次尝试离开IDE编程，对工程的编译有了更深的认识。
这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。
make会在当前目录下找名字叫“Makefile”或“makefile”的文件。如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。
————————————————
版权声明：本文为CSDN博主「haoel」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/haoel/article/details/2886
每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。
更为稳健的做法是：
.PHONY : clean
clean :
-rm edit *.o
前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。
———————————————— 版权声明：本文为CSDN博主「haoel」的原创文章，遵循 CC 4.0 BY-SA
版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/haoel/article/details/2887
fork() fork()父子进程共享
fork()父子进程运行优先顺序
在实验中遇到了一点问题，如下代码：
#include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; main () { pid_t pid; pid=fork(); if (pid &lt; 0) printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e8ff883c221e355dfe3a3625d7bbe07f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-07T21:18:23+08:00" />
<meta property="article:modified_time" content="2020-04-07T21:18:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">山东大学操作系统实验问题解决</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>本文以记录完成2020学年上期操作系统实验过程中的学习和参考资料</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">基础</a></li><li><ul><li><a href="#pv_12" rel="nofollow">pv基础</a></li></ul> 
   </li><li><a href="#Makefile_27" rel="nofollow">Makefile</a></li><li><a href="#fork_53" rel="nofollow">fork()</a></li><li><a href="#_80" rel="nofollow">函数</a></li><li><ul><li><a href="#_115" rel="nofollow">实验四：进程同步实验</a></li><li><ul><li><a href="#_116" rel="nofollow">基础</a></li><li><a href="#_126" rel="nofollow">示例</a></li><li><ul><li><a href="#_127" rel="nofollow">变量</a></li><li><a href="#_133" rel="nofollow">函数</a></li></ul> 
     </li><li><a href="#Smoker_Problem_153" rel="nofollow">吸烟者问题(Smoker Problem)</a></li></ul> 
    </li><li><a href="#_163" rel="nofollow">实验五：进程互斥实验</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>基础</h3> 
<ul><li><a href="https://www.runoob.com/linux/linux-vim.html" rel="nofollow">vim详解</a></li><li><a href="https://blog.csdn.net/I_AM_jm/article/details/86295701">将vim的内容复制到系统剪切板上</a></li><li><a href="https://www.cnblogs.com/piaomiaohongchen/p/6416463.html" rel="nofollow">将字符串转换为整数类型</a></li><li>处理warning：implicit declaration of function XXX，是因为函数没有在头文件定义，因此导致编译的时候没法儿正确生成.o文件。我出现了下图的状况：<br> <img src="https://images2.imgbox.com/50/88/PnA2w070_o.png" alt="在这里插入图片描述">添加&lt;unistd.h&gt;头文件，这是Linux/Unix内置系统的头文件，包含很多系统服务的函数原型。</li><li><a href="https://blog.csdn.net/yuyanggo/article/details/49819667">C、C++中union用法总结</a></li><li><a href="https://www.cnblogs.com/sxdcgaq8080/p/7498906.html" rel="nofollow">Linux目录文件权限</a>，还真是啥都忘了吼</li><li><a href="https://www.runoob.com/cprogramming/c-function-fgets.html" rel="nofollow">fgets函数</a></li></ul> 
<h4><a id="pv_12"></a>pv基础</h4> 
<ul><li>信号量S：<br> 若大于等于0，则表示可供并发进程使用的资源的实体数；<br> 若小于0，则表示正在等待使用临界区的进程的个数<br> 所以初值应该设为大于0</li><li>原语：不可中断的程序段</li><li>P：S-1<br> 若结果仍然大于等于0，则进程继续执行；<br> 若结果小于0，则进程阻塞，进入与该信号相对应的队列当中，然后转进程调度。<br> V：S+1<br> 若结果仍然大于0，则进程继续执行；<br> 若结果小于等于0（注意0的情况在第二种），则从该信号的等待队列中唤醒一个等待进程，然后再返回原来的进程继续执行或转进程调度。</li><li>临界资源：每次仅允许一个进程访问的资源，例如打印机，消息缓冲队列，变量，缓冲区等等。</li><li>大多数情况下同步已经实现了互斥，同步是在互斥的基础上通过其他机制实现访问者对资源的有序访问（互斥是无序的)。</li></ul> 
<h3><a id="Makefile_27"></a>Makefile</h3> 
<p><a href="https://blog.csdn.net/haoel/article/details/2886">跟我一起写Makefile（一）</a><br> <a href="https://blog.csdn.net/haoel/article/details/2887">跟我一起写Makefile（二）</a><br> （系列文章都在评论中有指路）<br> 初次尝试离开IDE编程，对工程的编译有了更深的认识。</p> 
<blockquote> 
 <p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。<br> make会在当前目录下找名字叫“Makefile”或“makefile”的文件。如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。<br> ————————————————<br> 版权声明：本文为CSDN博主「haoel」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/haoel/article/details/2886</p> 
</blockquote> 
<blockquote> 
 <p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。<br> 更为稳健的做法是：<br> .PHONY : clean<br> clean :<br> -rm edit *.o</p> 
 <p>前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。<br> ———————————————— 版权声明：本文为CSDN博主「haoel」的原创文章，遵循 CC 4.0 BY-SA<br> 版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/haoel/article/details/2887</p> 
</blockquote> 
<h3><a id="fork_53"></a>fork()</h3> 
<p><a href="https://blog.csdn.net/shenwansangz/article/details/39184789">fork()父子进程共享</a><br> <a href="https://blog.csdn.net/tong_xin2010/article/details/38469471">fork()父子进程运行优先顺序</a><br> 在实验中遇到了一点问题，如下代码：</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span> </span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span> </span>

main <span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span> 
        pid_t pid<span class="token punctuation">;</span> 
        pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error in fork!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am the child process, my process id is %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">else</span> 
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am the parent process, my process id is %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>在很多文章中，都先输出child process，再输出parent process，而我运行之后结果相反。查找资料<a href="http://chenzhenianqing.com/articles/350.html" rel="nofollow">fork()父子进程运行先后顺序</a>了解到可能与linux系统版本有关，也有可能原因可能是：</p> 
<blockquote> 
 <p>·在多处理系统中，它们可能会同时访问一个cpu；<br> ·在单处理系统中，fork(）之后很可能总是先调度父进程（优化性能），但如果恰好父进程的cpu时间片到期了，则执行子进程。</p> 
</blockquote> 
<p>（还发现先输出子进程的资料时间都是比较老的了，估计与版本有关系）</p> 
<h3><a id="_80"></a>函数</h3> 
<ul><li><a href="https://blog.csdn.net/yockie/article/details/51729774">Signal ()函数详细介绍</a></li><li>read(), write():</li></ul> 
<blockquote> 
 <p><strong>read()</strong><br> 用于文件描述符对应的文件中读取数据，原型：<br> ssize_t read(int fd,void*buf,size_t count)<br> #参数说明：<br> fd: 是文件描述符, 从command line获取数据时，为0<br> buf: 为读出数据的缓冲区；<br> count: 为每次读取的字节数（是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移）<br> #返回值：<br> 成功：返回读出的字节数<br> 失败：返回-1，并设置errno，如果在调用read之前到达文件末尾，则这次read返回0</p> 
</blockquote> 
<blockquote> 
 <p><strong>write()</strong><br> 用于将数据写入到文件描述符对应的文件，原型：<br> ssize_t write(int fd,const void*buf,size_t count);<br> #参数说明：<br> fd:是文件描述符（输出到command line，就是1）<br> buf:通常是一个字符串，需要写入的字符串 count：是每次写入的字节数<br> #返回值：<br> 成功：返回写入的字节数<br> 失败：返回-1并设置errno</p> 
</blockquote> 
<p>read()/write()函数的第二个参数是保存在缓冲区的数据/需要写入的数据，在“进程的通信”实验中，用到管道，那么buf参数所代表的就是保存在管道中的数据/要写入管道的数据。</p> 
<ul><li> <p><a href="https://blog.csdn.net/snake_hand/article/details/83811246">struct sched_param结构体结构</a></p> </li><li> <p>int atoi(const char *str)，将参数 str 所指向的字符串转换为的长整数并返回，如果没有执行有效的转换，则返回零。</p> </li><li> <p>学到现在连C的main函数里的参数都没搞明白，实在有些惭愧555，<a href="https://blog.csdn.net/yukiooy/article/details/4682989">c语言中命令行参数argc,argv[ ]</a>因为argv[0]指向输入的程序路径及名称，因此实际上是argv[1]来指向参数para_1字符串。</p> </li><li> <p><a href="https://blog.csdn.net/Thanksgining/article/details/41824475">信号signal处理机制</a></p> </li><li> <p><a href="https://blog.csdn.net/sweetfather/article/details/80035967">共享内存理解：shmget()函数、shmat()、IPC_CREAT | IPC_EXCL</a></p> </li></ul> 
<h4><a id="_115"></a>实验四：进程同步实验</h4> 
<h5><a id="_116"></a>基础</h5> 
<ul><li> <p>在Linux的proc文件系统中有3个虚拟文件动态记录了ipcs命令（包括ipcs -m共享内存情况，ipcs -s信号灯数组，ipcs -q消息队列）显示的当前IPC对象的信息：<br> /proc/sysvipc/shm 共享内存 （sharing memory)<br> /proc/sysvipc/sem 信号量 (semaphore)<br> /proc/sysvipc/msg 消息队列 (message)<br> 可以利用它们在程序执行时获取有关IPC对象的当前信息。</p> </li><li> <p><a href="https://blog.csdn.net/tiramisu_L/article/details/80232059">BUFSIZ的值</a>，BUFSIZ为系统默认的缓冲区大小。也可以自己定义<code>#define BUFSIZ 256</code>*。</p> </li><li> <p><a href="https://blog.csdn.net/u014630623/article/details/89020140">key_t的本质</a>，System V IPC使用key_t值作为它们的名字，在Redhat linux(后续验证默认都在该平台下)下key_t被定义为int类型。</p> </li><li> <p><a href="https://blog.csdn.net/chapterzj/article/details/8205207">IPC结构的键(key)与标识符(ID)</a></p> </li></ul> 
<h5><a id="_126"></a>示例</h5> 
<h6><a id="_127"></a>变量</h6> 
<p>生产者消费者共享缓冲区的变量：buff_key， buff_num， buff_ptr(ptr是共享指针啦…）<br> 生产者放产品位置的共享指针：pput_key， pput_num， pput_ptr<br> 消费者取产品位置的共享指针：cget_key， cget_num， cget_ptr<br> 生产者有关的信号量：cons_key， cmtx_key， cons_sem， cmtx_sem， sem_val， sem_flg， shm_flg</p> 
<h6><a id="_133"></a>函数</h6> 
<ol><li><strong>int shmget(key_t key,int size,int flags)</strong><br> 参数：<br> shm_key 共享内存的键值，可以为IPC_PRIVATE(<a href="https://blog.csdn.net/xhu_eternalcc/article/details/16801825">linux进程通信IPC之IPC_PRIVATE与ftok比较</a>)，也可以指定一个整数值。<br> shm_size 共享内存字节长度<br> shm_flags 共享内存权限位<br> 返回值：调用成功后，若key是用新整数指定并且flags中设置了IPC_CREATE，系统将此值与其他共享内存区的 key 进行比较，如果存在相同的 key ，说明共享内存区已存在，此时返回该共享内存区的标识符，否则新建一个共享内存区并返回其标识符。不成功则返回-1。<br> semget，msgget返回值相似，参数略有不同。</li><li><strong><strong><em>int get_ipc_id(char</em> proc_file,key_t key)</strong></strong>*<br> 从/proc/sysvipc/文件系统中获取IPC的id号<br> 参数中proc_file对应/proc/sysvipc/目录中的IPC文件；key对应要获取的IPC的id号的键值</li><li><strong>int set_sem(key_t sem_key,int sem_val,int sem_flg)</strong><br> 建立一个具有n个信号灯的信号量，返回一个信号灯数组的标识符sem_id<br> 参数：信号灯数组的键值，信号灯的个数，数组的存取权限</li><li><strong><strong>char * set_shm(key_t shm_key,int shm_num,int shm_flg)</strong></strong><br> 建立一个具有n个字节的共享内存区，返回指向该内存区的首地址的指针shm_buf</li><li><strong>int set_msq(key_t msq_key,int msq_flg)</strong><br> 返回一个消息队列的标识符msq_id</li><li><strong>down(int sem_id)</strong><br> 当sem_id的值是0的时候，不能再减了，阻塞；如果是1如果更高的话，则可以继续。</li></ol> 
<h5><a id="Smoker_Problem_153"></a>吸烟者问题(Smoker Problem)</h5> 
<p>桌子上有容量为1的缓冲区，只能有一种组合在里面。相当于一共有4种同步关系：</p> 
<ol><li>桌子上有组合1，则smoker1取走材料，开始吸烟</li><li>桌子上有组合2，则smoker2取走材料，开始吸烟</li><li>桌子上有组合3，则smoker3取走材料，开始吸烟</li><li>桌子上没有组合，那么吸烟完成之后，供应者将下一个组合放到桌子上<br> 并且三个吸烟者的吸烟行为互斥，即只能有一个吸烟者吸烟。</li></ol> 
<p>思路：将缓冲区的大小设置为1，all_sem（表示缓冲区中的状况），prod_sem（表示生产者同步信号），ab_sem，bc_sem，ac_sem分别表示各个吸烟者的信号。生产者的操作：down(all_sem) down(prod_sem)，表示缓冲区被占用了，然后将材料组合放入缓冲区中，再up(producer)，并提醒对应的吸烟者。而吸烟者的操作：down(ab_sem)，从缓冲区中读取到材料后，down(all_sem)，则又回到初始的状态，并且已经变成下一个组合。</p> 
<h4><a id="_163"></a>实验五：进程互斥实验</h4> 
<p><a href="https://blog.csdn.net/qq_41453285/article/details/90575054">IPC之消息队列(struct msqid_ds)</a></p> 
<p>理发店问题思路：理发室有3个理发椅子和3个理发师，有一个容纳4位顾客的沙发，和一间可容纳13位顾客的等候室。情况分为：</p> 
<ol><li>当沙发和等候室都没有人的时候，理发师正在睡觉或者顾客小于3人，正在被理发；</li><li>当沙发上的有人且人数小于4人时，代表等候室中没有人，且有3人正在理发，沙发上的顾客都在等候；</li><li>当沙发上的人数为4人，等候室的人数等于0时，同情况3；</li><li>当等候室的人数大于0时，表示有3位顾客正在理发，沙发上坐着4位顾客，以及等候室中还有顾客在等待；</li><li>当等候室的人数等于13时，表示理发店中的顾客已经满员，不允许有其他顾客进入了。</li></ol> 
<p>再补充…*</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/97f7e3f6973e838ef0627d40a9728d1d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Element el-date-picker datetimerange使用及限制时间范围</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b0225cd4b20d8f9bceaa47ee1523561/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何下载vue-resource.js</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>