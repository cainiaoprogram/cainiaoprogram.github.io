<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java的requestmapping_@RequestMapping与@GetMapping和@PostMapping等新注释 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java的requestmapping_@RequestMapping与@GetMapping和@PostMapping等新注释" />
<meta property="og:description" content="@RequestMapping与@GetMapping和@PostMapping等新注释
Spring的复杂性不是来自于它处理的对象，而是来自于自身，不断演进发展的Spring会带来时间维度上复杂性，比如SpringMVC以前版本的@RequestMapping，到了新版本被下面新注释替代，相当于增加的选项：
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping
从命名约定我们可以看到每个注释都是为了处理各自的传入请求方法类型，即@GetMapping用于处理请求方法的GET类型，@ PostMapping用于处理请求方法的POST类型等。
如果我们想使用传统的@RequestMapping注释实现URL处理程序，那么它应该是这样的：
@RequestMapping(value = &#34;/get/{id}&#34;, method = RequestMethod.GET)
新方法可以简化为：
@GetMapping(&#34;/get/{id}&#34;)
如何工作？
所有上述注释都已在内部注释了@RequestMapping以及方法元素中的相应值。
例如，如果我们查看@GetMapping注释的源代码，我们可以看到它已经通过以下方式使用RequestMethod.GET进行了注释：
@Target({ java.lang.annotation.ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@RequestMapping(method = { RequestMethod.GET })
public @interface GetMapping {
// abstract codes
}
所有其他注释都以相同的方式创建，即@PostMapping使用RequestMethod.POST进行注释，@ PutMapping使用RequestMethod.PUT进行注释等。
使用方式
下面是结合RestController的简单使用：
@RestController
@RequestMapping(&#34;users&#34;)
public class UserController {
@Autowired
UserService userService;
@GetMapping(&#34;/status/check&#34;)
public String status()
{
return &#34;working&#34;;
}
@GetMapping(&#34;/{id}&#34;)
public String getUser(@PathVariable String id)
{
return &#34;HTTP Get was called&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c69aa0e84509b832294611add07265d4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-16T00:11:50+08:00" />
<meta property="article:modified_time" content="2021-02-16T00:11:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java的requestmapping_@RequestMapping与@GetMapping和@PostMapping等新注释</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>@RequestMapping与@GetMapping和@PostMapping等新注释</p> 
 <p>Spring的复杂性不是来自于它处理的对象，而是来自于自身，不断演进发展的Spring会带来时间维度上复杂性，比如SpringMVC以前版本的@RequestMapping，到了新版本被下面新注释替代，相当于增加的选项：</p> 
 <p>@GetMapping</p> 
 <p>@PostMapping</p> 
 <p>@PutMapping</p> 
 <p>@DeleteMapping</p> 
 <p>@PatchMapping</p> 
 <p>从命名约定我们可以看到每个注释都是为了处理各自的传入请求方法类型，即@GetMapping用于处理请求方法的GET类型，@ PostMapping用于处理请求方法的POST类型等。</p> 
 <p>如果我们想使用传统的@RequestMapping注释实现URL处理程序，那么它应该是这样的：</p> 
 <p>@RequestMapping(value = "/get/{id}", method = RequestMethod.GET)</p> 
 <p>新方法可以简化为：</p> 
 <p>@GetMapping("/get/{id}")</p> 
 <p>如何工作？</p> 
 <p>所有上述注释都已在内部注释了@RequestMapping以及方法元素中的相应值。</p> 
 <p>例如，如果我们查看@GetMapping注释的源代码，我们可以看到它已经通过以下方式使用RequestMethod.GET进行了注释：</p> 
 <p>@Target({ java.lang.annotation.ElementType.METHOD })</p> 
 <p>@Retention(RetentionPolicy.RUNTIME)</p> 
 <p>@Documented</p> 
 <p>@RequestMapping(method = { RequestMethod.GET })</p> 
 <p>public @interface GetMapping {<!-- --></p> 
 <p>// abstract codes</p> 
 <p>}</p> 
 <p>所有其他注释都以相同的方式创建，即@PostMapping使用RequestMethod.POST进行注释，@ PutMapping使用RequestMethod.PUT进行注释等。</p> 
 <p>使用方式</p> 
 <p>下面是结合RestController的简单使用：</p> 
 <p>@RestController</p> 
 <p>@RequestMapping("users")</p> 
 <p>public class UserController {<!-- --></p> 
 <p>@Autowired</p> 
 <p>UserService userService;</p> 
 <p>@GetMapping("/status/check")</p> 
 <p>public String status()</p> 
 <p>{<!-- --></p> 
 <p>return "working";</p> 
 <p>}</p> 
 <p>@GetMapping("/{id}")</p> 
 <p>public String getUser(@PathVariable String id)</p> 
 <p>{<!-- --></p> 
 <p>return "HTTP Get was called";</p> 
 <p>}</p> 
 <p>@PostMapping</p> 
 <p>public String createUser(@RequestBody UserDetailsRequestModel requestUserDetails)</p> 
 <p>{<!-- --></p> 
 <p>return "HTTP POST was called";</p> 
 <p>}</p> 
 <p>@DeleteMapping("/{userId}")</p> 
 <p>public String deleteUser(@PathVariable String userId)</p> 
 <p>{<!-- --></p> 
 <p>return "HTTP DELETE was called";</p> 
 <p>}</p> 
 <p>@PutMapping("/{userId}")</p> 
 <p>public String updateUser(@PathVariable String userId, @RequestBody UserDetailsRequestModel requestUserDetails)</p> 
 <p>{<!-- --></p> 
 <p>return "HTTP PUT was called";</p> 
 <p>}</p> 
 <p>}</p> 
 <p>下面是使用@Controller的代码：</p> 
 <p>@Controller</p> 
 <p>public class HomeController</p> 
 <p>{<!-- --></p> 
 <p>@GetMapping("/")</p> 
 <p>public String homeInit(Model model) {<!-- --></p> 
 <p>return "home";</p> 
 <p>}</p> 
 <p>}</p> 
 <p>在上面的代码中，HomeController类充当请求控制器。它的homeInit()方法将处理所有传入的URI请求"/"。它接受a Model并返回视图名称home。使用配置的视图解析器解析视图名称”home“的页面。</p> 
 <p>写法对比</p> 
 <p>@RequestMapping:</p> 
 <p>@RequestMapping(value = "/workflow",</p> 
 <p>produces = {"application/json"},</p> 
 <p>consumes = {"application/json"},</p> 
 <p>method = RequestMethod.POST)</p> 
 <p>@PostMapping如下：</p> 
 <p>@PostMapping(path = "/members", consumes = "application/json", produces = "application/json")</p> 
 <p>public void addMember(@RequestBody Member member) {<!-- --></p> 
 <p>//code</p> 
 <p>}</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d3adf2af6fbf87dd17434a8501ef66ca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue element menu侧边导航栏</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/86e59ee7011d14ab55ae0b7558ace7dd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java bison_antlr与bison的一些比较</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>