<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OBS视频数据输出流程（模块加载，编码，推流）详细说明 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OBS视频数据输出流程（模块加载，编码，推流）详细说明" />
<meta property="og:description" content="1、视频输出初始化
程序运行时,初始化OBS,视频相关的初始化是再mainWindow中进行的
OBSApp::OBSInit() -&gt; mainWindow-&gt;OBSInit()
InitBasicConfig()读取appdata目录下配置文件中Video相关的参数,没有设置的参数使用接口
InitBasicConfigDefaults()接口中加载的默认参数
OBSBasic::RetsetVideo(),重置视频设置
obs_video_info ovi;获取视频设置的参数,包括：帧率,颜色格式,YUV颜色空间,YUV颜色范围,背景及
输出分辨率等
调用 AttemptToResetVideo() -&gt; obs_reset_video(),将当前参数尝试重置给Video
停止当前的video,使用新参数ovi重新初始化video,obs_init_video(ovi)
obs_init_video(struct obs_video_info *ovi)
通过make_video_info函数,将ovi参数设置给video_out_info vi;
调用video_output_open函数启动视频数据输出线程
int video_output_open(video_t **video, struct video_output_info *info)
创建video_output *out对象,拷贝info中的数据到out-&gt;info,设置out-&gt;frame_time每一帧的时间差
启动线程函数 video_thread,并将out作为参数传入
初始化out-&gt;cache,调用video_frame_init将cache中每一帧的内容按照视频格式初始化
完成后,将out对象赋值给obs-&gt;video-&gt;video
其中线程执行函数video_thread就是视频输出线程,等待信号量video-&gt;update_semaphore 被唤醒
执行video_output_cur_frame函数,获取视频缓存中第一帧,从video-&gt;inputs中获取输出类型
调用编码器绑定的回调函数input-&gt;callback,receive_video(),进行视频数据编码.
而video-&gt;update_semaphore 信号量是在所有画面合成完成后被唤醒,后面将介绍是如何唤醒的
video-&gt;inputs中保存的是输出类型,包括推流和录像,后面将会说到是如何添加的
启动画面合成线程函数 obs_graphics_thread(),后面单独介绍画面合成线程的流程
至此视频输出的初始化完成,输出线程和画面合成线程已启动
2、obs-x264、obs-qsv11、obs-ffmpeg、rtmp模块加载
obs-x264是软编,obs-qsv11是intel硬编,obs-ffmpeg中包含ffmpeg_aac、ffmpeg_opus、以及nvenc编码
rtmp是推流模块
在OBSInit()函数初始化视频后,将执行加载模块的操作,这里将介绍obs-x264模块是怎么加载并且被调用的,
其他几个模块的加载是类似的；
OBSInit() -&gt; AddExtraModulePaths(),添加加载模块的路径 -&gt; obs_load_all_modules()加载所有模块
void obs_load_all_modules(void)
obs_find_modules()遍历所有模块目录,load_all_callback是对找到的模块执行的回调函数,
find_modules_in_path()在每个目录中查找dll文件,并执行函数process_found_module() -&gt; 执行回调
也就是load_all_callback函数
load_all_callback() -&gt; obs_open_module() -&gt; os_dlopen()获取打开模块的句柄,接着执行的
load_module_exports函数获取模块中的接口地址绑定给obs_module各个函数指针,obs-x264模块只有
一个接口地址obs_module_load,被绑定至mod-&gt;load；将模块的一些信息填充,包括模块的名称,路径等
执行obs_init_module(module),该函数的作用就是为了调用刚才绑定的module-&gt;load()接口,也就是" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/44032175852ca6e03e577b7302164a29/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-31T10:28:46+08:00" />
<meta property="article:modified_time" content="2020-07-31T10:28:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OBS视频数据输出流程（模块加载，编码，推流）详细说明</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、视频输出初始化</p> 
<p>程序运行时,初始化OBS,视频相关的初始化是再mainWindow中进行的</p> 
<p>OBSApp::OBSInit() -&gt; mainWindow-&gt;OBSInit()</p> 
<p>InitBasicConfig()读取appdata目录下配置文件中Video相关的参数,没有设置的参数使用接口</p> 
<p>InitBasicConfigDefaults()接口中加载的默认参数</p> 
<p>OBSBasic::RetsetVideo(),重置视频设置</p> 
<p>obs_video_info ovi;获取视频设置的参数,包括：帧率,颜色格式,YUV颜色空间,YUV颜色范围,背景及</p> 
<p>输出分辨率等</p> 
<p>调用 AttemptToResetVideo() -&gt; obs_reset_video(),将当前参数尝试重置给Video</p> 
<p>停止当前的video,使用新参数ovi重新初始化video,obs_init_video(ovi)</p> 
<p>obs_init_video(struct obs_video_info *ovi)</p> 
<p>通过make_video_info函数,将ovi参数设置给video_out_info vi;</p> 
<p>调用video_output_open函数启动视频数据输出线程</p> 
<p>int video_output_open(video_t **video, struct video_output_info *info)</p> 
<p>创建video_output *out对象,拷贝info中的数据到out-&gt;info,设置out-&gt;frame_time每一帧的时间差</p> 
<p>启动线程函数 video_thread,并将out作为参数传入</p> 
<p>初始化out-&gt;cache,调用video_frame_init将cache中每一帧的内容按照视频格式初始化</p> 
<p>完成后,将out对象赋值给obs-&gt;video-&gt;video</p> 
<p>其中线程执行函数video_thread就是视频输出线程,等待信号量video-&gt;update_semaphore 被唤醒</p> 
<p>执行video_output_cur_frame函数,获取视频缓存中第一帧,从video-&gt;inputs中获取输出类型</p> 
<p>调用编码器绑定的回调函数input-&gt;callback,receive_video(),进行视频数据编码.</p> 
<p>而video-&gt;update_semaphore 信号量是在所有画面合成完成后被唤醒,后面将介绍是如何唤醒的</p> 
<p>video-&gt;inputs中保存的是输出类型,包括推流和录像,后面将会说到是如何添加的</p> 
<p>启动画面合成线程函数 obs_graphics_thread(),后面单独介绍画面合成线程的流程</p> 
<p>至此视频输出的初始化完成,输出线程和画面合成线程已启动</p> 
<p>2、obs-x264、obs-qsv11、obs-ffmpeg、rtmp模块加载</p> 
<p>obs-x264是软编,obs-qsv11是intel硬编,obs-ffmpeg中包含ffmpeg_aac、ffmpeg_opus、以及nvenc编码</p> 
<p>rtmp是推流模块</p> 
<p>在OBSInit()函数初始化视频后,将执行加载模块的操作,这里将介绍obs-x264模块是怎么加载并且被调用的,</p> 
<p>其他几个模块的加载是类似的；</p> 
<p>OBSInit() -&gt; AddExtraModulePaths(),添加加载模块的路径 -&gt; obs_load_all_modules()加载所有模块</p> 
<p>void obs_load_all_modules(void)</p> 
<p>obs_find_modules()遍历所有模块目录,load_all_callback是对找到的模块执行的回调函数,</p> 
<p>find_modules_in_path()在每个目录中查找dll文件,并执行函数process_found_module() -&gt; 执行回调</p> 
<p>也就是load_all_callback函数</p> 
<p>load_all_callback() -&gt; obs_open_module() -&gt; os_dlopen()获取打开模块的句柄,接着执行的</p> 
<p>load_module_exports函数获取模块中的接口地址绑定给obs_module各个函数指针,obs-x264模块只有</p> 
<p>一个接口地址obs_module_load,被绑定至mod-&gt;load；将模块的一些信息填充,包括模块的名称,路径等</p> 
<p>执行obs_init_module(module),该函数的作用就是为了调用刚才绑定的module-&gt;load()接口,也就是</p> 
<p>obs-x264模块中的obs_module_load函数</p> 
<p>obs_module_load() -&gt; 宏obs_register_encoder(&amp;obs_x264_encoder),其中obs_x264_encoder是个全局变量,</p> 
<p>再obs-x264.c文件中完成了obs_x264_encoder的初始化,绑定函数接口,id,编码类型,编码方式；</p> 
<p>-&gt; obs_register_encoder_s()做一系列的检查 -&gt; 宏REGISTER_OBS_DEF 将obs_x264_encoder添加到</p> 
<p>obs-&gt;encoder_types</p> 
<p>至此obs-x264模块的加载已完成,后面会介绍如何使用x264编码器</p> 
<p>3、输出设置（简单模式）</p> 
<p>模块加载完成后,将会对输出进行设置,以下是对视频输出设置的说明</p> 
<p>OBSInit() -&gt; ResetOutputs() 从配置文件中读取当前的视频设置是否是简单模式,重置outputHandler,并创建</p> 
<p>简单输出模式的指针赋值给outputHandler -&gt; CreateSimpleOutputHandler() -&gt; new SimpleOutput -&gt; 构造函数</p> 
<p>SimpleOutput::SimpleOutput</p> 
<p>获取当前编码类型：软编、硬编(QSV)、硬编(nvenc),调用LoadStreamingPreset_h264根据不同的编码类型</p> 
<p>创建不同的编码器,赋值给成员变量h264Streaming指针,该指针后面将会添加到视频输出的编码器中</p> 
<p>obs_video_encoder_create,根据编码器id创建编码器 -&gt; 调用create_encoder()函数,根据编码器id和</p> 
<p>编码器类型创建,在create_encoder函数中构造obs_encoder *encoder,根据id调用find_encoder()函数,从</p> 
<p>obs-&gt;encoder_types找到指定的编码器,赋值给encoder-&gt;info,构造完成后,h264Streaming指针就是当前选</p> 
<p>择的编码器</p> 
<p>4、开启推流</p> 
<p>OBSBasic::StartStreaming() -&gt; outputHandler-&gt;StartStreaming()</p> 
<p>SimpleOutput::StartStreaming(obs_service_t *service)</p> 
<p>Active()是判断推流、录像、回放缓存是否激活；正常状态下返回false,也就需要执行SetupOututs()函数</p> 
<p>SetupOutputs中调用了Update()函数,在Update中如果视频格式不是NV12或者I420,将编码器的首要格式设置</p> 
<p>为NV12；更新编码器h264Streaming中的设置参数,如果编码器注册了update接口(软编和qsv有nvenc没有)</p> 
<p>将新的参数更新到编码器中,回到SetupOutputs,调用obs_encoer_set_video,设置h264Streaming-&gt;media为</p> 
<p>obs-&gt;video.video,设置timebase_num = fps_den;timebase_den = fps_num;注意这里是把帧率的分子分母反</p> 
<p>着赋值给编码器,完成后回到StartStreaming创建推流的对象</p> 
<p>调用obs_output_create()函数,根据输出id创建推流对象,与创建编码对象类似,推流对象在加载模块时已</p> 
<p>添加到obs-&gt;output_types中,获取到的推流输出对象赋值给streamOutput指针</p> 
<p>调用obs_output_set_video_encoder()函数,将推流输出streamOutput-&gt;video_encoder设置为编码器</p> 
<p>创建好的h264Streaming</p> 
<p>调用obs_output_start() -&gt; obs_output_actual_start() 回调推流对象output-&gt;info.start()回调函数开启</p> 
<p>推流,其中start绑定至rtmp_stream_start</p> 
<p>static bool rtmp_stream_start(void *data)</p> 
<p>创建线程,执行connect_thread()函数,</p> 
<p>static void *connect_thread(void *data)</p> 
<p>init_connect()初始化推流；调用free_packets清空stream-&gt;packets,获取推流设置,赋值到stream</p> 
<p>try_connect()连接rtmp服务器,RTMP_Init(&amp;stream-&gt;rtmp)初始化rtmp客户端,设置推流服务器地址、</p> 
<p>用户名、密码、流地址、音频编码名称(为何没有添加视频编码名称,母鸡)</p> 
<p>RTMP_Connect()连接rtmp服务器,RTMP_ConnectStream()连接rtmp流地址</p> 
<p>init_send()启动发送函数,reset_semaphore()重置发送信号量,创建推流执行线程send_thread,发送</p> 
<p>视频关键数据send_meta_data(),开启推流数据捕获obs_output_begin_data_capture()</p> 
<p>其中 send_thread()线程函数:循环等待信号量stream-&gt;send_sem 被唤醒,唤醒后 get_next_packet()</p> 
<p>取出队列中的第一个已编码数据包,执行 send_packet 函数,调用flv_packet_mux进行flv数据封包,</p> 
<p>再调用RTMP_Write()发送数据包,完成视频数据推流.</p> 
<p>bool obs_output_begin_data_capture(obs_output_t *output, uint32_t flags)</p> 
<p>获取output-&gt;info也就是rtmp对象设置的flags,是否包含编码,音视频数据,绑定服务器；开启捕获,</p> 
<p>hook_data_capture(),这里是绑定编码完成后的音视频数据到rtmp推流的回调函数,音视频编码完成的</p> 
<p>数据回调都是interleave_packets(),start_audio_encoders()添加音频已编码数据捕获,</p> 
<p>obs_encoder_start()添加视频已编码数据捕获,调用obs_encoder_start_internal(),将回调函数</p> 
<p>interleave_packets,参数param也就是推流输出对象output构造成结构体encoder_callback cb；</p> 
<p>static void interleave_packets (void *data, struct encoder_packet *packet)</p> 
<p>调用obs_encoder_packet_create_instance(&amp;out, packet);拷贝packet中的数据到局部变量out</p> 
<p>中,其中进行malloc的时候,多申请了一个long类型长度的内存,这个pref是这个数据包的引用</p> 
<p>计数器；如果音视频数据都收到时,调用apply_interleaved_packet_offset,这个函数是调整</p> 
<p>时间补偿或者时间修复的吗？否则调用check_received接口将当前的音频或视频已收到标识设置</p> 
<p>为true</p> 
<p>was_started = output-&gt;received_audio &amp;&amp; output-&gt;received_video;</p> 
<p>......</p> 
<p>if (was_started)</p> 
<p>apply_interleaved_packet_offset(output, &amp;out);</p> 
<p>else</p> 
<p>check_received(output, packet);</p> 
<p>根据编码时间戳,将当前数据包插入到输出队列中,并将output-&gt;highest_audio_ts设置为当前</p> 
<p>数据包的编码时间戳</p> 
<p>insert_interleaved_packet(output, &amp;out);</p> 
<p>set_higher_ts(output, &amp;out);</p> 
<p>如果当前是否第一次收到了音频以及视频数据包,调用prune_interleaved_packets(output)对数</p> 
<p>据包中的内容进行修剪,修剪规则如下：</p> 
<p>先找出第一帧音频和第一帧视频的数据包,以第一帧视频数据包的index为基准,对比两个数据包</p> 
<p>的时间戳的差值：</p> 
<p>如果音频数据包的时间戳减去视频数据包的时间戳的数值大于每帧视频间隔的时间差,那么需</p> 
<p>要删除这个音频数据包时间戳之前的所有音视频数据包</p> 
<p>如果没有找到这样的音频数据包,那么就需要找出音视频数据包的时间戳差距最小的那个数</p> 
<p>据包的index,如果这个index的值比第一帧视频数据包的index小,那么需要删除这个index</p> 
<p>之前的所有数据包,如果比第一帧视频数据包的index大,那么需要删除第一帧视频数据包</p> 
<p>之前的所有数据包</p> 
<p>通过对第一次发送的音视频数据包的裁剪后,当前的待发送数据包中第一帧音视频数据包的时间戳</p> 
<p>的差距最小,以达到首次发送的音视频数据是同步的,调整修正完成后的待发送数据包相关的时间</p> 
<p>戳,再次确保发送的第一帧音视频数据包的准确性,并且重新调整待发送数据包的index,调用发送</p> 
<p>数据包函数 send_interleaved</p> 
<p>如果是后续收到的音视频数据包,则直接调用发送函数 send_interleaved</p> 
<p>if (output-&gt;received_audio &amp;&amp; output-&gt;received_video) {<!-- --></p> 
<p>if (!was_started) {<!-- --></p> 
<p>if (prune_interleaved_packets(output)) {<!-- --></p> 
<p>if (initialize_interleaved_packets(output)) {<!-- --></p> 
<p>resort_interleaved_packets(output);</p> 
<p>send_interleaved(output);</p> 
<p>}</p> 
<p>}</p> 
<p>} else {<!-- --></p> 
<p>send_interleaved(output);</p> 
<p>}</p> 
<p>}</p> 
<p>static inline void send_interleaved (struct obs_output *output)</p> 
<p>确认待发送数据包中的第一个数据包时间戳是合法的</p> 
<p>if (!has_higher_opposing_ts(output, &amp;out))</p> 
<p>return;</p> 
<p>把第一个数据包从队列中移除</p> 
<p>da_erase(output-&gt;interleaved_packets, 0);</p> 
<p>如果是视频数据包的话,在这里统计总的发送帧数</p> 
<p>if (out.type == OBS_ENCODER_VIDEO) {<!-- --></p> 
<p>output-&gt;total_frames++;</p> 
<p>调用output-&gt;info.encoded_packet回调函数 rtmp_stream_data,进入rtmp准备发送</p> 
<p>static void rtmp_stream_data (void *data, struct encoder_packet *packet)</p> 
<p>将数据包的数据拷贝至局部变量new_packet，数据包的引用技术+1,将new_packet添</p> 
<p>加到待推流数据块中，视频数据包：add_video_packet,其中视频数据包在添加之前</p> 
<p>检查是否有需要丢弃的帧，检查完成后调用add_packet,将数据包追加到</p> 
<p>stream-&gt;packets队列中,添加成功后，唤醒信号量stream-&gt;send_sem,通知线程</p> 
<p>send_thread(),执行发送</p> 
<p>将cb添加到视频编码器encoder-&gt;callbacks队列中,如果添加的是第一个已编码数据推流回调,调用</p> 
<p>add_connection(),启动音频数据输出捕获start_raw_video(),video-&gt;raw_active的值增加,说明下</p> 
<p>raw_active的值,是控制视频数据是否输出的开关,后面在输出视频数据时要用到；调用</p> 
<p>video_output_connect()函数,关联视频数据到编码的回调,创建video_input input结构体,将数据编</p> 
<p>码的回调函数 receive_video,编码器对象encoder,视频数据信息,填充到input中,并将input添加到</p> 
<p>video-&gt;inputs队列里,这个队列后面将会用到,其作用是合成后的视频数据调用这个队列中的回调</p> 
<p>进行视频数据输出(音频数据添加编码回调跟视频类似,在add_connection时调用audio_output_connect</p> 
<p>,构造audio_input input；将其加入到指定混音器mix-&gt;inputs中</p> 
<p>static void receive_video(void *param, struct video_data *frame)</p> 
<p>拷贝视频数据到encoder_frame enc_frame,调用do_encode()执行编码,在do_encode函数中,</p> 
<p>初始化待完成的数据包encoder_packet pkt；调用编码器绑定的编码函数,此处举例x264编码</p> 
<p>回调obs_x264_encode(),编码完成后调用send_packet,如果当前时视频帧的第一帧,需要单独</p> 
<p>调用send_first_video_packet函数,将视频的SEI信息添加到视频数据中,调用之前绑定的推流</p> 
<p>回调函数 interleave_packets(),进行视频数据发送</p> 
<p>5、视频画面生成</p> 
<p>在初始化视频时,启动了一个线程函数obs_graphics_thread(),所有画面源的合成,画面显示以及视频输出都在</p> 
<p>这个函数里触发,说白了这里就时画面生成和输出的源头</p> 
<p>void *obs_graphics_thread(void *param)</p> 
<p>循环处理画面,会根据设置的视频帧数,每隔固定时间处理一次画面</p> 
<p>tick_sources(),没有深入研究具体是什么内容</p> 
<p>output_frame():输出当前视频帧</p> 
<p>static inline void output_frame(bool raw_active)</p> 
<p>调用render_video(),渲染视频数据,在开启推流和录像功能时,调用render_output_texture(),渲染输</p> 
<p>出帧,并保存在video-&gt;convert_textures和video-&gt;output_textures中,再调用stage_output_texture</p> 
<p>将画面保存到video-&gt;copy_surfaces</p> 
<p>调用download_frme,从video-&gt;copy_surfaces中拷贝出当前视频帧数据到video_data *frame,这样就</p> 
<p>拿到了需要输出的视频画面；</p> 
<p>将frame传入output_video_data(),在该函数中,调用video_output_lock_frame()函数,拷贝</p> 
<p>input-&gt;cache[last_add]给output_frame,需要注意的是,这个拷贝是将cache[]中的指针地址拷贝</p> 
<p>过来了,通过格式转换函数例如copy_rgb_frame,将input_frame中的数据内容拷贝到output_frame,</p> 
<p>实际上也就是将视频内容拷贝到了input-&gt;cache[last_add]中,再调用video_output_unlock_frame()函</p> 
<p>数,唤醒信号量video-&gt;update_semaphore,通知线程video_thread视频输出数据已就绪,执行数据输出</p> 
<p>、编码、rtmp推流</p> 
<p>调用render_displays()将当前视频画面显示在窗口中,</p> 
<p>sleep直到下一帧视频数据时间戳</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3abb6d4d64ecc7f145b9c9cef88b38bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">wget 递归下载大部分网站目录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7eb4d9d8f02bd8c34153d99b8172343a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">php 命令行调试方法  php配合phpstrom 给php脚本进行额外传参后 触发断点调试配置教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>