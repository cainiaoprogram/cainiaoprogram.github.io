<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第六章 树与二叉树 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第六章 树与二叉树" />
<meta property="og:description" content="文章目录 树与二叉树1.树的基本概念和术语1.1树的定义：树是（n≥0）个结点的有限集合T。1.2术语1.3树的两个特点1.4树的抽象数据类型 2.二叉树的定义和基本操作3.二叉树的5个性质 （重点）4.二叉树的存储结构4.1 顺序存储 一维数组bt[1..n]4.2链式存储 二叉链表三叉链表 5.二叉树的遍历 （重点）5.1遍历：分为先序、中序、后序5.1.1先序遍历算法5.1.2中序遍历算法5.1.3后序遍历算法 6.由遍历序列确定二叉树 （重点）7.二叉树遍历算法的应用7.1输出二叉树中的结点7.2输出二叉树中的叶子结点7.3统计叶子结点数目方法1:（采用全局变量)方法2:采用递归算法 7.4求二叉树的高度7.5按树状打印二叉树7.6建立二叉链表方式存储的二叉树7.7基于栈的递归消除 8.线索二叉树8.1基本概念8.2建立线索链表8.2.1中序线索化算法8.2.2在线索二叉树中找前驱、后继结点 9.树、森林和二叉树的关系9.1树的存储结构9.1.1双亲表示法9.1.2孩子表示法9.1.3孩子兄弟表示法 9.2树、森林与二叉树的相互转换9.2.1树转换为二叉树1.树转换为二叉树的方法2.结论： 9.2.2森林转换为二叉树方法9.2.3二叉树还原为树或森林 9.3树与森林的遍历9.3.1树的遍历方法主要有以下两种：（1）先根遍历（2）后跟遍历 9.3.2森林的遍历森林的遍历方法有三种：（1）先序遍历（2）中序遍历（3）后序遍历 9.3.3树、二叉树、森林遍历关系对应表： 10.哈夫曼树及其应用 （重点）10.1基本概念10.1.1最优二叉树10.1.2哈夫曼树 10.2构建哈夫曼树（重点）10.2.1哈夫曼树的特点 10.3哈夫曼树的类型定义10.4哈夫曼树的算法实现（难点）10.5哈夫曼树及其应用10.5.1哈夫曼树编码10.5.2如何进行哈夫曼编码？10.5.3结论 10.5.4哈夫曼编码的算法实现 树与二叉树 1.树的基本概念和术语 1.1树的定义：树是（n≥0）个结点的有限集合T。 当n=0时称为空树；当n＞0时，该集合满足如下条件：（1）其中必有一个称为根（root）的特定结点，它没有直接前驱，但有0个或多个直接后继。（2）其余n-1个结点可以划分成m(m≥0)个互不相交的有限集T1，T2，T3，…Tm，其中Ti又是一棵树，称为根root的子树。每棵子树的根结点有且仅有一个直接前驱，但有0个或多个直接后继。 1.2术语 根：即根结点（没有前驱）除根结点外的分支结点统称为内部结点。
结点：包括一个数据元素及若干指向其他结点的分支信息
结点的度：一个结点的子树个数（即分支的个数）
叶子结点：度为0的结点，即无后继结点，也称为终端结点
分支结点：度不为0的结点，也称为非终端结点
结点的层次：从根到该结点的层数（根结点为第一层）
结点的层序编号：将树中的结点按从上到下、从左到右的次序排成一个线性序列，依次给它们编以连续的自然数
树的度：树中所有结点的度的最大值
树的高度（深度）：树中所有结点的层次的最大值
有序树：结点各子树从左至右有序，不能互换（左为第一）
森林：指m（m≥0）棵不相交的树的集合，反之，给森林增加一个统一的根结点，森林就变成一棵树
同构：对两棵树，通过对结点适当地重命名，可以使两棵树完全相等（结点对应相等，对应结点的相关关系也相等），则称这两棵树同构。
孩子结点：一个结点的直接后继
双亲结点：一个结点的直接前驱
兄弟结点：同一双亲结点的孩子结点之前互称
堂兄弟：即双亲位于同一层的结点（但并非同一双亲）
祖先结点：即从根到该结点所经分支的所有结点
子孙结点：一个结点的直接后继和间接后继称为该结点的子孙结点，即该结点下层子树中的任一结点
1.3树的两个特点 1.树的跟结点没有前驱结点，除根结点之外有且只有一个前驱结点2.树中所有结点可以有0个或多个后继结点 1.4树的抽象数据类型 2.二叉树的定义和基本操作 特点：（1）每个结点的度都不大于2； （2）每个结点的孩子结点次序不能任意颠倒（有序树）。 满足以上两个条件的树型结构为二叉树（Binary Tree）二叉树或为空树，或由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。
2.1二叉树与树（普通树、多叉树）的区别：
1.树中结点的最大度数没有限制，而二叉树结点的最大度数为2 2.树的结点无左右之分，而二叉树的结点有左右之分 3.二叉树和树都属于树形结构 4.所有树都能转化为唯一对应的二叉树 2.2二叉树的定义及基本操作
形态：5种
基本操作：
①Initiate(bt);//初始一棵空二叉树 ②Destory (bt);//销毁一棵二叉树 Creat (bt)://创建一棵非空二叉树 ④Empty(bt);//树为空返回TRUE ⑤Root(bt);//求根结点 ⑥Parent(bt,x);//求双亲结点 ⑦LeftChild(bt,x);//求左孩子 ⑧RithtChild(bt,x);//求右孩子 ⑨Traverse(bt);//遍历操作 ⑩Clear(bt);/l将二叉树置为空树 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0ae2ef09cc6fc9fffff5794355db5115/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-05T17:51:24+08:00" />
<meta property="article:modified_time" content="2022-11-05T17:51:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第六章 树与二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">树与二叉树</a></li><li><ul><li><a href="#1_3" rel="nofollow">1.树的基本概念和术语</a></li><li><ul><li><a href="#11n0T_5" rel="nofollow">1.1树的定义：树是（n≥0）个结点的有限集合T。</a></li><li><a href="#12_9" rel="nofollow">1.2术语</a></li><li><a href="#13_32" rel="nofollow">1.3树的两个特点</a></li><li><a href="#14_37" rel="nofollow">1.4树的抽象数据类型</a></li></ul> 
   </li><li><a href="#2_42" rel="nofollow">2.二叉树的定义和基本操作</a></li><li><a href="#35____83" rel="nofollow">3.二叉树的5个性质 （重点）</a></li><li><a href="#4_109" rel="nofollow">4.二叉树的存储结构</a></li><li><ul><li><a href="#41_____bt1n_111" rel="nofollow">4.1 顺序存储 一维数组bt[1..n]</a></li><li><a href="#42____120" rel="nofollow">4.2链式存储 二叉链表</a></li><li><ul><li><ul><li><a href="#_139" rel="nofollow">三叉链表</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#5___153" rel="nofollow">5.二叉树的遍历 （重点）</a></li><li><ul><li><a href="#51_155" rel="nofollow">5.1遍历：分为先序、中序、后序</a></li><li><ul><li><ul><li><a href="#511_160" rel="nofollow">5.1.1先序遍历算法</a></li><li><a href="#512_165" rel="nofollow">5.1.2中序遍历算法</a></li><li><a href="#513_170" rel="nofollow">5.1.3后序遍历算法</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#6__180" rel="nofollow">6.由遍历序列确定二叉树 （重点）</a></li><li><a href="#7_185" rel="nofollow">7.二叉树遍历算法的应用</a></li><li><ul><li><ul><li><a href="#71_187" rel="nofollow">7.1输出二叉树中的结点</a></li><li><a href="#72_202" rel="nofollow">7.2输出二叉树中的叶子结点</a></li><li><a href="#73_223" rel="nofollow">7.3统计叶子结点数目</a></li><li><ul><li><ul><li><a href="#1_225" rel="nofollow">方法1:（采用全局变量)</a></li><li><a href="#2_241" rel="nofollow">方法2:采用递归算法</a></li></ul> 
     </li></ul> 
     </li><li><a href="#74_258" rel="nofollow">7.4求二叉树的高度</a></li><li><a href="#75_283" rel="nofollow">7.5按树状打印二叉树</a></li><li><a href="#76_302" rel="nofollow">7.6建立二叉链表方式存储的二叉树</a></li><li><a href="#77_327" rel="nofollow">7.7基于栈的递归消除</a></li></ul> 
   </li></ul> 
   </li><li><a href="#8_341" rel="nofollow">8.线索二叉树</a></li><li><ul><li><ul><li><ul><li><a href="#81_343" rel="nofollow">8.1基本概念</a></li><li><a href="#82_363" rel="nofollow">8.2建立线索链表</a></li><li><ul><li><a href="#821_369" rel="nofollow">8.2.1中序线索化算法</a></li><li><a href="#822_384" rel="nofollow">8.2.2在线索二叉树中找前驱、后继结点</a></li></ul> 
     </li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#9_395" rel="nofollow">9.树、森林和二叉树的关系</a></li><li><ul><li><ul><li><a href="#91_397" rel="nofollow">9.1树的存储结构</a></li><li><ul><li><ul><li><a href="#911_399" rel="nofollow">9.1.1双亲表示法</a></li><li><a href="#912_404" rel="nofollow">9.1.2孩子表示法</a></li><li><a href="#913_409" rel="nofollow">9.1.3孩子兄弟表示法</a></li></ul> 
     </li></ul> 
     </li><li><a href="#92_414" rel="nofollow">9.2树、森林与二叉树的相互转换</a></li><li><ul><li><a href="#921_416" rel="nofollow">9.2.1树转换为二叉树</a></li><li><ul><li><a href="#1_420" rel="nofollow">1.树转换为二叉树的方法</a></li><li><a href="#2_431" rel="nofollow">2.结论：</a></li></ul> 
      </li><li><a href="#922_439" rel="nofollow">9.2.2森林转换为二叉树方法</a></li><li><a href="#923_454" rel="nofollow">9.2.3二叉树还原为树或森林</a></li></ul> 
     </li><li><a href="#93_464" rel="nofollow">9.3树与森林的遍历</a></li><li><a href="#931_468" rel="nofollow">9.3.1树的遍历方法主要有以下两种：</a></li><li><ul><li><a href="#1_470" rel="nofollow">（1）先根遍历</a></li><li><a href="#2_480" rel="nofollow">（2）后跟遍历</a></li></ul> 
     </li><li><a href="#932_496" rel="nofollow">9.3.2森林的遍历</a></li><li><ul><li><a href="#_500" rel="nofollow">森林的遍历方法有三种：</a></li><li><ul><li><a href="#1_502" rel="nofollow">（1）先序遍历</a></li><li><a href="#2_511" rel="nofollow">（2）中序遍历</a></li><li><a href="#3_520" rel="nofollow">（3）后序遍历</a></li></ul> 
      </li><li><a href="#933_537" rel="nofollow">9.3.3树、二叉树、森林遍历关系对应表：</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#10___545" rel="nofollow">10.哈夫曼树及其应用 （重点）</a></li><li><ul><li><ul><li><a href="#101_547" rel="nofollow">10.1基本概念</a></li><li><ul><li><a href="#1011_564" rel="nofollow">10.1.1最优二叉树</a></li><li><a href="#1012_570" rel="nofollow">10.1.2哈夫曼树</a></li></ul> 
     </li><li><a href="#102_574" rel="nofollow">10.2构建哈夫曼树（重点）</a></li><li><ul><li><a href="#1021_587" rel="nofollow">10.2.1哈夫曼树的特点</a></li></ul> 
     </li><li><a href="#103_595" rel="nofollow">10.3哈夫曼树的类型定义</a></li><li><a href="#104_610" rel="nofollow">10.4哈夫曼树的算法实现（难点）</a></li><li><a href="#105_619" rel="nofollow">10.5哈夫曼树及其应用</a></li><li><ul><li><a href="#1051_621" rel="nofollow">10.5.1哈夫曼树编码</a></li><li><ul><li><a href="#1052_635" rel="nofollow">10.5.2如何进行哈夫曼编码？</a></li><li><a href="#1053_652" rel="nofollow">10.5.3结论</a></li></ul> 
      </li><li><a href="#1054_657" rel="nofollow">10.5.4哈夫曼编码的算法实现</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>树与二叉树</h2> 
<h3><a id="1_3"></a>1.树的基本概念和术语</h3> 
<h4><a id="11n0T_5"></a>1.1树的定义：树是（n≥0）个结点的有限集合T。</h4> 
<ul><li>当n=0时称为空树；当n＞0时，该集合满足如下条件：（1）其中必有一个称为根（root）的特定结点，它没有直接前驱，但有0个或多个直接后继。（2）其余n-1个结点可以划分成m(m≥0)个互不相交的有限集T1，T2，T3，…Tm，其中Ti又是一棵树，称为根root的子树。每棵子树的根结点有且仅有一个直接前驱，但有0个或多个直接后继。</li></ul> 
<h4><a id="12_9"></a>1.2术语</h4> 
<ul><li> <p>根：即根结点（没有前驱）除根结点外的分支结点统称为内部结点。</p> </li><li> <p>结点：包括一个数据元素及若干指向其他结点的分支信息</p> </li><li> <p>结点的度：一个结点的子树个数（即分支的个数）</p> </li><li> <p>叶子结点：度为0的结点，即无后继结点，也称为终端结点</p> </li><li> <p>分支结点：度不为0的结点，也称为非终端结点</p> </li><li> <p>结点的层次：从根到该结点的层数（根结点为第一层）</p> </li><li> <p>结点的层序编号：将树中的结点按从上到下、从左到右的次序排成一个线性序列，依次给它们编以连续的自然数</p> </li><li> <p>树的度：树中所有结点的度的最大值</p> </li><li> <p>树的高度（深度）：树中所有结点的层次的最大值</p> </li><li> <p>有序树：结点各子树从左至右有序，不能互换（左为第一）</p> </li><li> <p>森林：指m（m≥0）棵不相交的树的集合，反之，给森林增加一个统一的根结点，森林就变成一棵树</p> <p>同构：对两棵树，通过对结点适当地重命名，可以使两棵树完全相等（结点对应相等，对应结点的相关关系也相等），则称这两棵树同构。</p> </li><li> <p>孩子结点：一个结点的直接后继</p> </li><li> <p>双亲结点：一个结点的直接前驱</p> </li><li> <p>兄弟结点：同一双亲结点的孩子结点之前互称</p> </li><li> <p>堂兄弟：即双亲位于同一层的结点（但并非同一双亲）</p> </li><li> <p>祖先结点：即从根到该结点所经分支的所有结点</p> </li><li> <p>子孙结点：一个结点的直接后继和间接后继称为该结点的子孙结点，即该结点下层子树中的任一结点</p> </li></ul> 
<h4><a id="13_32"></a>1.3树的两个特点</h4> 
<ul><li>1.树的跟结点没有前驱结点，除根结点之外有且只有一个前驱结点</li><li>2.树中所有结点可以有0个或多个后继结点</li></ul> 
<h4><a id="14_37"></a>1.4树的抽象数据类型</h4> 
<p><img src="https://images2.imgbox.com/b2/bb/iVIlliQ8_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_42"></a>2.二叉树的定义和基本操作</h3> 
<pre><code>特点：（1）每个结点的度都不大于2；

     （2）每个结点的孩子结点次序不能任意颠倒（有序树）。
</code></pre> 
<p>满足以上两个条件的树型结构为二叉树（Binary Tree）二叉树或为空树，或由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。</p> 
<p>2.1二叉树与树（普通树、多叉树）的区别：</p> 
<pre><code>1.树中结点的最大度数没有限制，而二叉树结点的最大度数为2
2.树的结点无左右之分，而二叉树的结点有左右之分
3.二叉树和树都属于树形结构
4.所有树都能转化为唯一对应的二叉树
</code></pre> 
<p>2.2二叉树的定义及基本操作</p> 
<p>形态：5种</p> 
<p><img src="https://images2.imgbox.com/c0/40/tZkUmcwz_o.png" alt="在这里插入图片描述"></p> 
<p>基本操作：</p> 
<pre><code>①Initiate(bt);//初始一棵空二叉树
②Destory (bt);//销毁一棵二叉树
Creat (bt)://创建一棵非空二叉树
④Empty(bt);//树为空返回TRUE
⑤Root(bt);//求根结点
⑥Parent(bt,x);//求双亲结点
⑦LeftChild(bt,x);//求左孩子
⑧RithtChild(bt,x);//求右孩子
⑨Traverse(bt);//遍历操作
⑩Clear(bt);/l将二叉树置为空树
</code></pre> 
<h3><a id="35____83"></a>3.二叉树的5个性质 （重点）</h3> 
<pre><code>（1）在二叉树的第i层上至多有2的（i-1）个结点。
（2）深度为k的二叉树上至多含2的（k-1）个结点（k≥1）。
（3）对任何一棵二叉树，若它含有n0和叶子结点、n2个度为2的结点，则必存在关系式：n0=n2+1.
（4）具有n个结点的完全二叉树的深度为log2 n+1向下取整
（5）若对含n个结点的完全二叉树从上到下且从左至右进行1至n的编号，则对完全二叉树中  任意一个编号为i的结点:
    &lt;1&gt;若i=1，则序号为i的结点是根结点，无双亲结点，若i≥&gt;1，则序号为i的结点的双亲结点的序号为Li/2]:
    &lt;2&gt;若2i&gt;n，则序号为i的结点无左孩子，若2i ≤n，则序号为i的结点的左孩子结点的序号为2i ;
    &lt;3&gt;若2i+1&gt;n，则序号为i的结点无右孩子，若2i +1 ≤n ,则序号为i的结点的右孩子结点的序号为2i+1。
</code></pre> 
<p>两种特殊的二叉树</p> 
<p><img src="https://images2.imgbox.com/1b/4d/O3NrrclK_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/82/fb/194gEYQs_o.png" alt="在这里插入图片描述"></p> 
<p>区别：</p> 
<p><img src="https://images2.imgbox.com/4b/3f/HV7t8tnZ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_109"></a>4.二叉树的存储结构</h3> 
<h4><a id="41_____bt1n_111"></a>4.1 顺序存储 一维数组bt[1…n]</h4> 
<blockquote> 
 <p>是用一组连续的存储单元来存放二叉树的数据元素。</p> 
 <p>对于完全二叉树来说，可以将其数据元素逐层存放到一组连续的存储单元中，例如将编号为i的结点存放在数组的第i个分量中，则i的左孩子为2i,i的右孩子为2i+1。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/0b/8b/oe0xPfdb_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="42____120"></a>4.2链式存储 二叉链表</h4> 
<p><img src="https://images2.imgbox.com/5a/9f/04a9YGMA_o.png" alt="在这里插入图片描述"></p> 
<pre><code>用C语言定义二叉树的二叉链表结点结构：
typedef struct Node{
  DataType data;
  struct Node * lchild;/*左右孩子指针*/
  struct Node * rchild;
}BiTNode,*BiTree;
</code></pre> 
<blockquote> 
 <p>在n个结点的二叉链表中，有n+1个空指针域。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/3c/66/OWXWEduK_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="_139"></a>三叉链表</h6> 
<p>有时，为了便于找到双亲结点，可以增加一个parent域，以指向该结点的双亲结点，采用这种结点结构的存放方式称为三叉链表存储结构。</p> 
<p><img src="https://images2.imgbox.com/3e/9f/ngmPKE6p_o.png" alt="在这里插入图片描述"></p> 
<pre><code>typedef struct TriTNode
{ TelemType data;
  struct TriTNode *lchild, *parent,*rchild;
} TriTNode,*TriTree;
</code></pre> 
<h3><a id="5___153"></a>5.二叉树的遍历 （重点）</h3> 
<h4><a id="51_155"></a>5.1遍历：分为先序、中序、后序</h4> 
<p><img src="https://images2.imgbox.com/f4/0b/2MC1PwX4_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="511_160"></a>5.1.1先序遍历算法</h6> 
<p><img src="https://images2.imgbox.com/1a/f0/QdqZFE4K_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="512_165"></a>5.1.2中序遍历算法</h6> 
<p><img src="https://images2.imgbox.com/56/34/wqstSpl7_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="513_170"></a>5.1.3后序遍历算法</h6> 
<p><img src="https://images2.imgbox.com/e3/01/kMlWKCCr_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>遍历的算法分析：</p> 
 <p>时间效率:○(n)//每个结点只访问一次<br> 空间效率:○(n)//栈占用的最大辅助空间</p> 
</blockquote> 
<h3><a id="6__180"></a>6.由遍历序列确定二叉树 （重点）</h3> 
<p><img src="https://images2.imgbox.com/e1/a6/YHMAWixq_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="7_185"></a>7.二叉树遍历算法的应用</h3> 
<h5><a id="71_187"></a>7.1输出二叉树中的结点</h5> 
<pre><code class="prism language-c">遍历算法将走遍二叉树中的每一个结点，故输出二叉树中结点并无次序要求，因此可用任一种算法来完成。
<span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
     <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>root <span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*输出根结点*/</span>
     <span class="token function">PreOrder</span><span class="token punctuation">(</span>root <span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*先序遍历左子树*/</span>
     <span class="token function">PreOrder</span><span class="token punctuation">(</span>root <span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*先序遍历右子树*/</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="72_202"></a>7.2输出二叉树中的叶子结点</h5> 
<pre><code class="prism language-c">判断结点既没有左孩子，又没有右孩子时，则输出该结点。
  <span class="token keyword">void</span> <span class="token function">PreOrderLeaf</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> 
   <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token operator">==</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-&gt;</span>RChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token operator">%</span>c "<span class="token punctuation">,</span>root <span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*输出叶子结点*/</span>
     <span class="token function">PreOrderLeaf</span><span class="token punctuation">(</span>root <span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*先序遍历左子树*/</span>
     <span class="token function">PreOrderLeaf</span><span class="token punctuation">(</span>root <span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*先序遍历右子树*/</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><em>输出二叉树中的度为2的结点的条件</em></p> 
<p><img src="https://images2.imgbox.com/b1/88/PKZ6mxSS_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="73_223"></a>7.3统计叶子结点数目</h5> 
<h6><a id="1_225"></a>方法1:（采用全局变量)</h6> 
<pre><code class="prism language-c"><span class="token comment">/*LeafCount保存叶子结点数目的全局变量,调用之前初始化值为0*/</span>
<span class="token keyword">void</span> <span class="token function">leaf</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
       <span class="token function">leaf</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">leaf</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">-&gt;</span>LChild<span class="token operator">==</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> root <span class="token operator">-&gt;</span>RChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
       LeafCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h6><a id="2_241"></a>方法2:采用递归算法</h6> 
<pre><code class="prism language-c"><span class="token comment">/*如果是空树，返回0;如果只有一个结点，返回1;否则为左右子树的叶子结点数之和*/</span>
<span class="token keyword">int</span> <span class="token function">leaf</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">int</span> LeafCount<span class="token punctuation">;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
      leafCount <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>RChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            LeafCount <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
         <span class="token keyword">else</span>
            LeafCount <span class="token operator">=</span><span class="token function">leaf</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">leaf</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> LeafCount<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="74_258"></a>7.4求二叉树的高度</h5> 
<blockquote> 
 <p>设函数表示二叉树bt的高度，则递归定义如下:</p> 
 <p>若bt为空，则高度为0<br> 若bt非空，其高度应为其左右子树高度的最大值加1</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/da/6c/rL1Xzywq_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">PostTreeDepth</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> hl<span class="token punctuation">,</span>hr<span class="token punctuation">,</span>max<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>bt<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        hl<span class="token operator">=</span><span class="token function">PostTreeDepth</span><span class="token punctuation">(</span>bt<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        hr<span class="token operator">=</span><span class="token function">PostTreeDepth</span><span class="token punctuation">(</span>bt<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        max<span class="token operator">=</span>hl<span class="token operator">&gt;</span>hr<span class="token operator">?</span>hl<span class="token operator">:</span>hr<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">(</span>max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   <span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="75_283"></a>7.5按树状打印二叉树</h5> 
<blockquote> 
 <p>算法思想:<br> 1)二叉树的横向显示是竖向显示的90度旋转;<br> 2)打印结点的顺序恰为二叉树中序顺序的逆序，所以横向显示算法RDL结构，为称为逆中序。<br> 3)在访问根结点的语句中加入FOR循环语句，以控制输出结点的左、右位置，设置了一个层深参数nLayer，每当递归进层时层深参数加1;若没有这个for循环，打印出来的则是对齐的一列，不会有错位显示。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">PrintTree</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">,</span><span class="token keyword">int</span> nLayer<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>bt <span class="token operator">=</span> <span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
   <span class="token function">PrintTree</span><span class="token punctuation">(</span>bt <span class="token operator">-&gt;</span>Rchild<span class="token punctuation">,</span>nLayer<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nLayer<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> bt <span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">PrintTree</span><span class="token punctuation">(</span>bt <span class="token operator">-&gt;</span> Lchild<span class="token punctuation">,</span>nLayer<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="76_302"></a>7.6建立二叉链表方式存储的二叉树</h5> 
<p><img src="https://images2.imgbox.com/5e/af/xrMbFoMT_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>算法思想:<br> 采用类似先序遍历的递归算法，首先读入当前根结点数据，如果是“.”则将当前树根置为空，否则申请一个新结点，存入当前根结点的数据，分别用当前根点点的左孩子域和右孩子域进行递归调用，创建左子树和右子树。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>BiTree <span class="token operator">*</span>bt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>
    ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token char">'.'</span><span class="token punctuation">)</span><span class="token operator">*</span>bt<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
      <span class="token punctuation">{<!-- --></span>
        <span class="token operator">*</span>bt<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*生成一个新结点，完成双亲结点和子结点的相连*/</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>bt<span class="token punctuation">)</span><span class="token operator">-&gt;</span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span>
        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>bt<span class="token punctuation">)</span><span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*创建左子树*/</span>
        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>bt<span class="token punctuation">)</span><span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*创建右子树*/</span>
       <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="77_327"></a>7.7基于栈的递归消除</h5> 
<pre><code>递归转换到非递归的原因:
递归的执行效率低;
运行环境没有递归机制
</code></pre> 
<p><img src="https://images2.imgbox.com/c1/9d/tLgVfrel_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/2b/b2/vC8HdOao_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="8_341"></a>8.线索二叉树</h3> 
<h6><a id="81_343"></a>8.1基本概念</h6> 
<p><img src="https://images2.imgbox.com/a6/91/I9QhFav0_o.png" alt="在这里插入图片描述"></p> 
<pre><code>在这种存储结构中，指向前驱和后继结点的指针叫做线索。

以这种结构组成的二叉链表作为二叉树的存储结构，叫做线索链表。

对二叉树以某种次序进行遍历并且加上线索的过程叫做线索化

线索化了的二叉树称为线索二叉树。

线索化实质上是将二叉链表中的空指针域填上相应结点的遍历前驱或后继结点的地址，而前驱和后继的地址只能在动态的遍历过程中才能得到。因此线索化的过程是在遍历过程中修改空指针域的过程。对二叉树按照不同的遍历次序进行线索化，可以得到不同的线索二叉树（先序线索二叉树、中序线索二叉树和后序线索二叉树)。
</code></pre> 
<p><img src="https://images2.imgbox.com/6d/bd/NcQVDGTy_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="82_363"></a>8.2建立线索链表</h6> 
<pre><code>在中序遍历过程中修改结点的左、右指针域，以保存当前访问结点的“前驱”和“后继”信息。遍历过程中，附设指针pre，并始终保持指针pre指向当前访问的、指针root所指结点的前驱。
</code></pre> 
<h6><a id="821_369"></a>8.2.1中序线索化算法</h6> 
<pre><code>算法思想:
1中序线索化采用中序递归遍历算法框架。
2加线索操作就是访问结点操作。
3加线索操作需要利用刚访问过的结点与当前结点的关系，因此设置一个指针pre,始终记录刚访问过的结点，其操作如下:
  a如果当前遍历结点root的左子域为空，则让左子域指向pre;
  b如果前驱右子域为空，则让右子域指向当前遍历结点root;
  c为下次做准备，当前访问结点root作为下一个访问结点的前驱pre;
</code></pre> 
<p><img src="https://images2.imgbox.com/6e/92/tfmZIdbZ_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="822_384"></a>8.2.2在线索二叉树中找前驱、后继结点</h6> 
<p><img src="https://images2.imgbox.com/d5/dc/m2ZABsvB_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/81/4d/5c1X0j7s_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c4/65/1vd1F616_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="9_395"></a>9.树、森林和二叉树的关系</h3> 
<h5><a id="91_397"></a>9.1树的存储结构</h5> 
<h6><a id="911_399"></a>9.1.1双亲表示法</h6> 
<p><img src="https://images2.imgbox.com/a2/e6/xVjcT71G_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="912_404"></a>9.1.2孩子表示法</h6> 
<p><img src="https://images2.imgbox.com/5e/d8/XHJFD5o3_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="913_409"></a>9.1.3孩子兄弟表示法</h6> 
<p><img src="https://images2.imgbox.com/ba/c8/yTFJBE5v_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="92_414"></a>9.2树、森林与二叉树的相互转换</h5> 
<h6><a id="921_416"></a>9.2.1树转换为二叉树</h6> 
<blockquote> 
 <p>树中结点的各孩子的次序是无关紧要的，而二叉树中结点的左、右孩子是有区别的。我们约定树中每一个结点的孩子结点按从左到右的次序顺序编号，也就是说，把树作为有序树看待。</p> 
</blockquote> 
<h6><a id="1_420"></a>1.树转换为二叉树的方法</h6> 
<blockquote> 
 <p>(1)树中所有相邻兄弟之间加一条连线。</p> 
 <p>(2)对树中的每个结点，只保留其与第一个孩子结点之间的连线，删去其与其它孩子结点之间的连线。</p> 
 <p>(3)以树的根结点为轴心，将整棵树顺时针旋转一定的角度,使之结构层次分明。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8b/fc/epGSguGR_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2_431"></a>2.结论：</h6> 
<pre><code>从转换过程可看出:树中的任意一个结点都对应于二叉树中的一个结点。
树中某结点的第一个孩子在二叉树中是相应结点的左孩子，树中某结点的右兄弟结点在二叉树中是相应结点的右孩子。
也就是说，在二叉树中，左分支上的各结点在原来的树中是父子关系，而右分支上的各结点在原来的树中是兄弟关系。由于树的根结点没有兄弟，所以变换后的二叉树的根结点的右孩子必然为空。
</code></pre> 
<h6><a id="922_439"></a>9.2.2森林转换为二叉树方法</h6> 
<blockquote> 
 <p>(1）将森林中的每棵树转换成相应的二叉树。</p> 
 <p>(2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有二叉树连在一起后，所得到的二及树就是由森林转换得到的二叉树。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/0f/08/UNY5qtQw_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>森林和树都可以转换为二叉树，两者的区别：</p> 
 <p>由树转换成二叉树，其根结点必然无右孩子；</p> 
 <p>由森林转换而得的二叉树，其根结点有右孩子。</p> 
</blockquote> 
<h6><a id="923_454"></a>9.2.3二叉树还原为树或森林</h6> 
<blockquote> 
 <p>一棵二叉树还原为树或森林，具体方法为:<br> (1）若某结点是其双亲的左孩子，则把该结点的右孩子、右孩子的右孩子、…都与该结点的双亲结点用线连起来。<br> (2)删掉原二叉树中所有双亲结点与右孩子结点的连线。<br> (3）整理由（1）、(2）两步所得到的树或森林使之结构层次分明。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/95/a8/nnFZsH1Q_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="93_464"></a>9.3树与森林的遍历</h5> 
<blockquote> 
 <p>树的遍历（树的结构特点：树根、树的子树森林）</p> 
</blockquote> 
<h5><a id="931_468"></a>9.3.1树的遍历方法主要有以下两种：</h5> 
<h6><a id="1_470"></a>（1）先根遍历</h6> 
<pre><code>若树非空，则遍历方法为：

（1）访问根结点。

（2）从左到右，依次先根遍历根结点的每一棵子树。
</code></pre> 
<h6><a id="2_480"></a>（2）后跟遍历</h6> 
<pre><code>若树非空，则遍历方法为：

（1）从左到右，依次先根遍历根结点的每一棵子树。

（2）访问根结点。
</code></pre> 
<blockquote> 
 <p>注：</p> 
 <p>树的先根遍历等同于对转换所得的二叉树进行先序遍历；</p> 
 <p>树的后跟遍历等同于对转换所得的二叉树进行中序遍历。</p> 
</blockquote> 
<h5><a id="932_496"></a>9.3.2森林的遍历</h5> 
<blockquote> 
 <p>森林的结构特点：第一棵树、其余的树</p> 
</blockquote> 
<h6><a id="_500"></a>森林的遍历方法有三种：</h6> 
<h6><a id="1_502"></a>（1）先序遍历</h6> 
<pre><code>若森林非空，则遍历方法为
(1)访问森林中第一棵树的根结点。
(2)先序遍历第一棵树的根结点的子树森林。
(3)先序遍历除去第一棵树之后剩余的树构成的森林。
</code></pre> 
<h6><a id="2_511"></a>（2）中序遍历</h6> 
<pre><code>若森林非空，则遍历方法为:
(1)中序遍历森林中第一棵树的根结点的子树森林。
(2)访问第一棵树的根结点。
(3)中序遍历除去第一棵树之后剩余的树构成的森林。
</code></pre> 
<h6><a id="3_520"></a>（3）后序遍历</h6> 
<pre><code>若森林非空，则遍历方法为:
(1)后序遍历森林中第一棵树的根结点的子树森林。
(2)后序遍历除去第一棵树之后剩余的树构成的森林。
(3)访问第一棵树的根结点。
</code></pre> 
<blockquote> 
 <p>注：</p> 
 <p>森林的先序遍历等同于对转换所得的二叉树进行先序遍历；</p> 
 <p>森林的中序遍历等同于对转换所得的二叉树进行中序遍历；</p> 
 <p>森林的后序遍历等同于对转换所得的二叉树进行后序遍历；</p> 
</blockquote> 
<h6><a id="933_537"></a>9.3.3树、二叉树、森林遍历关系对应表：</h6> 
<table><thead><tr><th>树</th><th>二叉树</th><th>森林</th></tr></thead><tbody><tr><td>先根遍历</td><td>先序遍历</td><td>先序遍历</td></tr><tr><td>后跟遍历</td><td>中序遍历</td><td>中序遍历</td></tr><tr><td></td><td>后序遍历</td><td>后序遍历</td></tr></tbody></table> 
<h3><a id="10___545"></a>10.哈夫曼树及其应用 （重点）</h3> 
<h5><a id="101_547"></a>10.1基本概念</h5> 
<pre><code>路径:从一个结点到另一个结点之间的分支序列。

路径长度:从一个结点到另一个结点所经过的分支数目。

结点的权值:树中每个结点所赋予的具有某种实际意义的实数。

结点的带权路径长度:从树根到某一结点的路径长度与该结点的权值的乘积。

树的带权路径长度:树中从根到所有叶子结点的各个带权路径长度之和。
</code></pre> 
<p><img src="https://images2.imgbox.com/3b/8a/5rrVfc2t_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="1011_564"></a>10.1.1最优二叉树</h6> 
<blockquote> 
 <p>在叶子个数n以及各叶子权值Wi确定的条件下，树的带权路径长度WPL值最小的二叉树。</p> 
 <p>哈夫曼依据最优二叉树的特点:权值越大，离根越近,给出了构造的方法，因此最优二叉树又称哈夫曼树。</p> 
</blockquote> 
<h6><a id="1012_570"></a>10.1.2哈夫曼树</h6> 
<blockquote> 
 <p>哈夫曼树是由n个带权叶子结点所构成的所有二义树中带权路径长度最短的二叉树，这种树最早是由哈夫曼（Huffman）研究，所以称为哈夫曼树，又称最优二义树。</p> 
</blockquote> 
<h5><a id="102_574"></a>10.2构建哈夫曼树（重点）</h5> 
<blockquote> 
 <p>(1)根据给定的n个权值{w1，W2，…，W}，构造n棵二叉树的集合F={T1，T2，…，Tn}，其中每棵二叉树中均只含一个带权值为w的根结点，其左、右子树为空树;</p> 
 <p>(2)在F中选取其根结点的权值为最小的两棵二叉树，分别作为左、右子树构造一棵新的二叉树，并置这棵新的二叉树根结点的权值为其左、右子树根结点的权值之和;</p> 
 <p>(3)从F中删去这两棵树，同时加入刚生成的新树;</p> 
 <p>(4)重复(2)和(3)两步，直至F中只含一棵树为止。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/86/b5/aHUQhEwg_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="1021_587"></a>10.2.1哈夫曼树的特点</h6> 
<ol><li>没有度为1的结点;</li><li>n个叶子结点的哈夫曼树共有2n-1个结点;<br> (n个结点在构造过程中，生成n-1个非叶子结点)</li><li>哈夫曼树的任意非叶子结点的左右子树交换后仍是哈夫曼树;</li><li>对同一组权值{w1, w2,… … ., wn}，存在不同构的两棵哈夫曼树，但它们的带权路径长度(WPL)一定是一样的；</li></ol> 
<h5><a id="103_595"></a>10.3哈夫曼树的类型定义</h5> 
<pre><code>n个叶子结点的哈夫曼树共有2n-1个结点,因此可用有2n-1个元素的一维数组来存储哈夫曼树的各个结点，结点间的父子关系用下标来指示;在使用哈夫曼树进行编码和译码时，既要用结点的双亲信息，又要用结点的孩 信息，所以采用静态三叉链表来存储哈夫曼树。
</code></pre> 
<p><img src="https://images2.imgbox.com/5d/ac/HC6XNrtV_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/66/fe/VpzhZEDf_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/65/97/vv9mSQBC_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="104_610"></a>10.4哈夫曼树的算法实现（难点）</h5> 
<blockquote> 
 <p>初始化:先将n个元素都视为根结点,即孩子和双亲指针全置0。</p> 
 <p>建哈夫曼树的过程是:反复在数组中选双亲为0(表示它们当前是树根)且权值最小的两结点，将它们作为左右孩子挂在新的结点之下，新结点权值为左右孩仔权值之和。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a8/d0/layUxh3f_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="105_619"></a>10.5哈夫曼树及其应用</h5> 
<h6><a id="1051_621"></a>10.5.1哈夫曼树编码</h6> 
<blockquote> 
 <p>在编码的设计中，通常遵守两个原则:</p> 
 <p>(1)编码能够唯一地被译码。<br> (2)编码长度要尽可能的短。</p> 
</blockquote> 
<pre><code>如何避免编码的二义性?
如果任何字符的编码都不是另一个字符编码的前缀，则可以无二义的解码。

前缀编码:任何一个字符的编码都不是另一个字符的编码的前缀,这种编码方式称为前缀编码。
</code></pre> 
<h6><a id="1052_635"></a>10.5.2如何进行哈夫曼编码？</h6> 
<blockquote> 
 <p>对哈夫曼树中每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的值构成该叶子结点的哈夫曼编码。</p> 
</blockquote> 
<pre><code>哈夫曼树是树的带权路径长度值为最小的二叉树，其特点就是:叶子结点权值越大，离根越近。

为保证信息编码长度最短，先统计各字符出现的次数，然后以此作为权值，构建哈夫曼树。

构造不等长编码的原则是:字符使用频率越高，编码越短。

用哈夫曼树设计编码的设想是:
每个待编码的字符对应一个叶子结点;
每个字符的使用频率对应叶子的权值;
每个字符的编码对应根到叶子的路径;
</code></pre> 
<h6><a id="1053_652"></a>10.5.3结论</h6> 
<p><img src="https://images2.imgbox.com/d5/ae/fLyT0gZu_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="1054_657"></a>10.5.4哈夫曼编码的算法实现</h6> 
<p><img src="https://images2.imgbox.com/4d/11/Q49CVBEq_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/9c/50/31UIEH9T_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3117c27d22dab56f2c1ce527737b99d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">My Publications</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e2db28435f3033e8ef6e488836cb1d26/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">开始使用AspectJ-实现步骤@Aspect，@Before,还有其中的JoinPoint参数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>