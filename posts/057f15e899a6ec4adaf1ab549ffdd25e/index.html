<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux】socket 编程基础 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux】socket 编程基础" />
<meta property="og:description" content="文章目录 📕 网络间的通信📕 socket 是什么1. socket 套接字2. 套接字描述符3. 基本的 socket 接口函数3.1 头文件3.2 socket() 函数3.3 bind() 函数struct sockaddr主机序列与网络序列 3.4 listen() 函数3.5 connect() 函数3.6 accept() 函数IP 地址风格转换区分两种套接字 3.7 read() 、write() 等函数3.8 close() 函数 📕 UDPudp_socket.hpp （封装 UdpSocket）udp_server.hpp （UDP 通用服务器）udp_client.hpp （UDP通用客户端） 📕 网络间的通信 前面的管道、共享内存等等进程间通信，都是仅限于用在本机进程之间通信。网络间进程通信要解决的是不同主机进程间的相互通信问题（可把同机进程通信看作是其中的特例）。
为此，首先要解决的是网络间进程标识问题。同一主机上，不同进程可用进程号（process ID）唯一标识。但在网络环境下，各主机独立分配的进程号不能唯一标识该进程。例如，主机A赋于某进程号5，在B机中也可以存在5号进程，因此，“5号进程” 这句话就没有意义了。 其次，操作系统支持的网络协议众多，不同协议的工作方式不同，地址格式也不同。因此，网间进程通信还要解决多重协议的识别问题。
TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议&#43;端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。
使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是为什么说“一切皆socket”。
📕 socket 是什么 1. socket 套接字 socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用 “打开open –&gt; 读写write/read –&gt; 关闭close” 模式来操作。Socket就是该模式的一个实现， socket 即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）.
说白了Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。
2. 套接字描述符 有关文件描述符，如果不了解，可以查看这篇文章： 文件描述符 。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/057f15e899a6ec4adaf1ab549ffdd25e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-30T10:43:43+08:00" />
<meta property="article:modified_time" content="2023-08-30T10:43:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux】socket 编程基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#__2" rel="nofollow">📕 网络间的通信</a></li><li><a href="#_socket__10" rel="nofollow">📕 socket 是什么</a></li><li><ul><li><a href="#1_socket__11" rel="nofollow">1. socket 套接字</a></li><li><a href="#2__16" rel="nofollow">2. 套接字描述符</a></li><li><a href="#3__socket__23" rel="nofollow">3. 基本的 socket 接口函数</a></li><li><ul><li><a href="#31__44" rel="nofollow">3.1 头文件</a></li><li><a href="#32__socket__51" rel="nofollow">3.2 socket() 函数</a></li><li><a href="#33_bind__68" rel="nofollow">3.3 bind() 函数</a></li><li><ul><li><a href="#struct_sockaddr_95" rel="nofollow">struct sockaddr</a></li><li><a href="#_105" rel="nofollow">主机序列与网络序列</a></li></ul> 
    </li><li><a href="#34_listen__141" rel="nofollow">3.4 listen() 函数</a></li><li><a href="#35_connect__151" rel="nofollow">3.5 connect() 函数</a></li><li><a href="#36_accept__159" rel="nofollow">3.6 accept() 函数</a></li><li><ul><li><a href="#IP__171" rel="nofollow">IP 地址风格转换</a></li><li><a href="#_188" rel="nofollow">区分两种套接字</a></li></ul> 
    </li><li><a href="#37_read_write__218" rel="nofollow">3.7 read() 、write() 等函数</a></li><li><a href="#38_close__242" rel="nofollow">3.8 close() 函数</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_UDP_249" rel="nofollow">📕 UDP</a></li><li><ul><li><a href="#udp_sockethpp__UdpSocket_252" rel="nofollow">udp_socket.hpp （封装 UdpSocket）</a></li><li><a href="#udp_serverhpp_UDP__339" rel="nofollow">udp_server.hpp （UDP 通用服务器）</a></li><li><a href="#udp_clienthpp_UDP_390" rel="nofollow">udp_client.hpp （UDP通用客户端）</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="__2"></a>📕 网络间的通信</h2> 
<p>前面的管道、共享内存等等进程间通信，都是仅限于用在本机进程之间通信。网络间进程通信要解决的是不同主机进程间的相互通信问题（可把同机进程通信看作是其中的特例）。<br> 为此，首先要解决的是<strong>网络间进程标识问题</strong>。同一主机上，不同进程可用进程号（process ID）唯一标识。但在网络环境下，各主机独立分配的进程号不能唯一标识该进程。例如，主机A赋于某进程号5，在B机中也可以存在5号进程，因此，“5号进程” 这句话就没有意义了。 其次，操作系统支持的网络协议众多，不同协议的工作方式不同，地址格式也不同。因此，网间进程通信还要解决多重协议的识别问题。</p> 
<p><strong>TCP/IP协议族</strong>已经帮我们解决了这个问题，网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机，而传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p> 
<p>使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是为什么说“一切皆socket”。</p> 
<h2><a id="_socket__10"></a>📕 socket 是什么</h2> 
<h3><a id="1_socket__11"></a>1. socket 套接字</h3> 
<p>socket起源于Unix，而Unix/Linux基本哲学之一就是“<strong>一切皆文件</strong>”，都可以用 “<strong>打开open –&gt; 读写write/read –&gt; 关闭close</strong>” 模式来操作。Socket就是该模式的一个实现， <strong>socket 即是一种特殊的文件</strong>，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）.<br> 说白了Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，<strong>对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议</strong>。</p> 
<h3><a id="2__16"></a>2. 套接字描述符</h3> 
<p>有关文件描述符，如果不了解，可以查看这篇文章： <a href="https://blog.csdn.net/m0_65679465/article/details/130053863">文件描述符</a> 。<br> 文件描述符其实就是一个整数，我们最熟悉的句柄是0、1、2三个，0是标准输入，1是标准输出，2是标准错误输出。0、1、2是整数表示的，对应的FILE *结构的表示就是stdin、stdout、stderr。</p> 
<p>上文说到，socket 是一种特殊的文件，那么必然有文件描述符，</p> 
<h3><a id="3__socket__23"></a>3. 基本的 socket 接口函数</h3> 
<pre><code class="prism language-cpp"><span class="token comment">// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器)</span>
<span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 绑定端口号 (TCP/UDP, 服务器)</span>
<span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> socket<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>address<span class="token punctuation">,</span>socklen_t address_len<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 开始监听socket (TCP, 服务器)</span>
<span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> socket<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 接收请求 (TCP, 服务器)</span>
<span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> socket<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> address<span class="token punctuation">,</span>socklen_t<span class="token operator">*</span> address_len<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 建立连接 (TCP, 客户端)</span>
<span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span>socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在生活中，A要电话给B，A拨号，B听到电话铃声后提起电话，这时A和B就建立起了连接，A和B就可以讲话了。等交流结束，挂断电话结束此次交谈。 打电话很简单解释了这工作原理：“open—write/read—close”模式。<br> <img src="https://images2.imgbox.com/8a/0b/DFFR3sF1_o.png" alt="在这里插入图片描述" width="500"><br> 如上图，服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，这个过程可以理解为开机，服务器已经做好了事前准备。然后调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p> 
<h4><a id="31__44"></a>3.1 头文件</h4> 
<blockquote> 
 <p>#include &lt;sys/types.h&gt;<br> #include &lt;sys/socket.h&gt;</p> 
</blockquote> 
<h4><a id="32__socket__51"></a>3.2 socket() 函数</h4> 
<blockquote> 
 <p>int socket(int domain, int type, int protocol); // 返回一个文件描述符</p> 
</blockquote> 
<p><strong>socket函数 <mark>对应于</mark> 普通文件的打开操作</strong>。普通文件的打开操作返回一个文件描述字，而socket() 用于<strong>创建一个socket描述符（即它的返回值），它唯一标识一个 socket</strong>。这个socket 描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p> 
<p>socket函数的三个参数分别为：</p> 
<ul><li>protofamily：即协议域，又称为协议族（family）。常用的协议族有，AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li><li>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</li></ul> 
<p>注意：<strong>并不是上面的type和protocol可以随意组合的</strong>，如SOCK_STREAM不可以跟IPPROTO_UDP组合。<strong>当protocol为0时，会自动选择type类型对应的默认协议</strong>。</p> 
<p>例如，我想要使用UDP协议进行通信，此时可以 int sock = socket(AF_INET,SOCK_DGRAM,0); 得到的 sock 在后续操作中一直要使用。</p> 
<h4><a id="33_bind__68"></a>3.3 bind() 函数</h4> 
<blockquote> 
 <p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 成功返回0，失败返回 -1</p> 
</blockquote> 
<p>正如上面所说，bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p> 
<p>函数的三个参数分别为：</p> 
<ul><li>sockfd：即socket描述字，它是通过socket()函数创建了（返回值），唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li><li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd 的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token punctuation">{<!-- --></span>
    sa_family_t    sin_family<span class="token punctuation">;</span> <span class="token comment">/* address family: AF_INET */</span>
    in_port_t      sin_port<span class="token punctuation">;</span>   <span class="token comment">/* port in network byte order */</span>
    <span class="token keyword">struct</span> <span class="token class-name">in_addr</span> sin_addr<span class="token punctuation">;</span>   <span class="token comment">/* internet address */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token comment">/* Internet address. */</span>
<span class="token keyword">struct</span> <span class="token class-name">in_addr</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">uint32_t</span>       s_addr<span class="token punctuation">;</span>     <span class="token comment">/* address in network byte order */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>addrlen：对应的是地址的长度。</li></ul> 
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p> 
<h5><a id="struct_sockaddr_95"></a>struct sockaddr</h5> 
<p>关于 struct sockaddr。</p> 
<p>socket API是一层抽象的网络编程接口,适用于各种底层网络协议,如IPv4、 IPv6,以及其他的协议等等。然而, 各种网络协议的地址格式并不相同，如下图：<br> <img src="https://images2.imgbox.com/88/7d/ns2r2SoH_o.png" alt="在这里插入图片描述" width="700"><br> 由于每一个协议的结构体都不同，那么为了适应这些协议，就必须开发出多个 bind() 接口，这些 bind 接口的区别，仅仅是第二个参数的不同，这样未免过于繁琐，所以有了 struct sockaddr 的诞生。</p> 
<p>例如，IPv4、 IPv6 <strong>地址类型</strong> 分别定义为常数AF_INET、 AF_INET6。这样, 只要取得某种协议格式的结构体的首地址, 不需要知道具体是哪种类型的 sockaddr 结构体,就可以<strong>根据地址类型字段确定结构体中的内容</strong>。比如，使用 socket 创建套接字的时候，第一个参数树 AF_INET ，表示的是 ipv4 ，那么在 bind 的时候，首先要创建一个 struct sockaddr_in local 结构体，然后往 loacl 中填入数据，接着调用 bind 接口，该接口的第二个参数传入 (struct sockaddr*)&amp;local ，传入 lock 的地址并强转成 struct sockaddr* 类型。（可以查看下面的示例帮助理解）</p> 
<h5><a id="_105"></a>主机序列与网络序列</h5> 
<p>关于网络字节序与主机字节序。</p> 
<blockquote> 
 <p><strong>主机字节序</strong>就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：<br> 　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br> 　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br> <strong>网络字节序</strong>：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p> 
</blockquote> 
<p>所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian，务必将其转化为网络字节序再赋给socket。</p> 
<p>实际上，我们并不需要过于关心主机序列、网络序列是怎么组织的，因为有对应的接口帮我们实现这两种序列之间的转化，下面是一些网络字节序转为主机字节序、主机字节序转为网络字节序的函数。</p> 
<blockquote> 
 <p>#include &lt;arpa/inet.h&gt;<br> uint32_t htonl(uint32_t hostlong); // 主机转网络，32位数据<br> uint16_t htons(uint16_t hostshort); // 主机转网络，16位数据<br> uint32_t ntohl(uint32_t netlong); // 网络转主机，32位数据<br> uint16_t ntohs(uint16_t netshort); // 网络转主机，16位数据</p> 
</blockquote> 
<p>如下，是一个使用 bind 的例子。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 1.创建socket</span>
listensock_ <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2. bind</span>
<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> local<span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
local<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
local<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
local<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// INADDR_ANY 表示本机的所有地址</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>listensock_<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"bind error "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="34_listen__141"></a>3.4 listen() 函数</h4> 
<blockquote> 
 <p>int listen(int sockfd, int backlog); // 成功返回0，失败返回 -1</p> 
</blockquote> 
<p>listen()函数只能在服务器进程中使用，让服务器进程进入监听状态，等待客户端的连接请求，listen()函数在一般在 bind()函数之后调用，在 accept()函数之前调用。</p> 
<p>listen函数的第一个参数即为要监听的socket描述字，第二个参数表示本服务器中，<strong>全连接队列</strong>中数据的个数 = backlog + 1。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p> 
<p>参数 backlog 用来描述 sockfd 的等待连接队列能够达到的最大值。在服务器进程正处理客户端连接请求的时候，可能还存在其它的客户端请求建立连接，因为 TCP 连接是一个过程，由于同时尝试连接的用户过多，使得服务器进程无法快速地完成所有的连接请求，那怎么办呢？直接丢掉其他客户端的连接肯定不是一个很好的解决方法。因此内核会在自己的进程空间里维护一个队列，这些连接请求就会被放入一个队列中，服务器进程会按照先来后到的顺序去处理这些连接请求，这样的一个队列内核不可能让其任意大，所以必须有一个大小的上限，这个 backlog 参数告诉内核使用这个数值作为队列的上限。而当一个客户端的连接请求到达并且该队列为满时，客户端可能会收到一个表示连接失败的错误，本次请求会被丢弃不作处理。</p> 
<h4><a id="35_connect__151"></a>3.5 connect() 函数</h4> 
<blockquote> 
 <p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 成功则返回 0，失败返回-1</p> 
</blockquote> 
<p>该函数用于客户端应用程序中，客户端调用 connect()函数将套接字 sockfd 与远程服务器进行连接，参数 addr 指定了待连接的服务器的 IP 地址以及端口号等信息，参数 addrlen 指定了 addr 指向的 struct sockaddr对象的字节大小。</p> 
<p>客户端通过 connect()函数请求与服务器建立连接，对于 TCP 连接来说，调用该函数将发生 TCP 连接的握手过程，并最终建立一个 TCP 连接，而对于 UDP 协议来说，调用这个函数只是在 sockfd 中记录服务器IP 地址与端口号，而不发送任何数据。</p> 
<h4><a id="36_accept__159"></a>3.6 accept() 函数</h4> 
<blockquote> 
 <p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); // 成功返回一个文件描述符，失败返回-1。</p> 
</blockquote> 
<p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p> 
<ul><li>sockfd：参数sockfd就是上面解释中的监听套接字，这个套接字用来监听一个端口，当有一个客户与服务器连接时，它使用这个一个端口号，而此时这个端口号正与这个套接字关联。当然客户不知道套接字这些细节，它只知道一个地址和一个端口号。</li><li>addr：这是一个<strong>输出型参数</strong>，它用来接受一个返回值，这返回值里面<strong>包含了客户端的地址</strong>，当然这个地址是通过某个地址结构来描述的，用户应该知道这一个什么样的地址结构。如果对客户的地址不感兴趣，那么可以把这个值设置为NULL。</li><li>它也是<strong>输出型参数</strong>，用来<strong>接受上述addr 的结构的大小</strong>，它指明addr结构所占有的字节个数。同样的，它也可以被设置为NULL。</li></ul> 
<p>如果accept成功返回，则服务器与客户已经正确建立连接了，此时服务器通过accept返回的套接字来完成与客户的通信。服务器要给客户端发消息，那么必须使用 accept 成功返回的套接字，而不是使用 socket() 函数创建出来的套接字。</p> 
<h5><a id="IP__171"></a>IP 地址风格转换</h5> 
<p>在调用 accept 成功之后，它的第二个参数就包含了客户端主机的信息，但是，addr 结构体中，主机的IP地址是用 32 位整型变量来表示的，和常用的字符串风格不符合，所以，需要将IP地址 进行从整形到字符串风格的转换。此外，服务器端在调用 bind() 接口的时候，如果 struct sockaddr 中的数据是自己指定 IP 地址（例如 “192.168.1.1”），而不是 INADDR_ANY （所有的IP地址，这是整形的风格），那么也需要进行从字符串风格，转换为整形，因为 struct sockaddr 结构体中，IP地址的类型就是整形。</p> 
<blockquote> 
 <p>#include &lt;sys/socket.h&gt;<br> #include &lt;netinet/in.h&gt;<br> #include &lt;arpa/inet.h&gt;<br> int inet_aton(const char *cp, struct in_addr *inp);<br> in_addr_t inet_addr(const char *cp);<br> in_addr_t inet_network(const char *cp);<br> char *inet_ntoa(struct in_addr in);<br> struct in_addr inet_makeaddr(int net, int host);<br> in_addr_t inet_lnaof(struct in_addr in);<br> in_addr_t inet_netof(struct in_addr in);</p> 
</blockquote> 
<p>常用的有两个：</p> 
<ul><li>inet_ntoa() ：将一个<strong>网络字节序</strong>的IP地址（也就是结构体in_addr类型变量）转化为<strong>点分十进制</strong>的IP地址（字符串）。</li><li>inet_aton() ：将一个字符串表示的<strong>点分十进制IP地址，转换为网络字节序</strong>存储在addr中，并且返回该网络字节序表示的无符号整数。</li></ul> 
<h5><a id="_188"></a>区分两种套接字</h5> 
<p>注意：<br> accept默认会阻塞进程，直到有一个客户连接建立后返回，它返回的是一个新可用的套接字，这个套接字是连接套接字。</p> 
<p>此时我们需要区分两种套接字：</p> 
<ul><li>监听套接字: 监听套接字正如accept的第一个参数sockfd，它是监听套接字，是服务器一开始调用socket()函数生成的，称为监听socket描述字(监听套接字)。</li><li>连接套接字：一个套接字会从主动连接的套接字变身为一个监听套接字；而accept函数返回的是已连接socket描述字(一个连接套接字)，它代表着一个网络已经存在的连接。</li></ul> 
<p><strong>一个服务器通常通常仅仅只创建一个监听socket描述字</strong>，它在该服务器的生命周期内一直存在。此外，内核为每个由服务器进程接受的客户连接创建了一个已<strong>连接socket 描述字</strong>，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。可以形象地比喻为，一个饭店，门口有一位负责招待客人进入店里的员工，店内有多个给客人提供服务的员工，门口的员工只负责揽客，店内的员工只负责招待客人，对应为：监听套接字只负责建立连接，连接套接字只负责进程之间的通信。</p> 
<p>如果使用一个描述字的话，那么它的功能太多，使得使用很不直观，同时在内核确实产生了一个这样的新的描述字。连接套接字socketfd_new 并没有占用新的端口与客户端通信，依然使用的是与监听套接字socketfd一样的端口号。</p> 
<p>如下是是用 accept 的一个例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client<span class="token punctuation">;</span>
socklen_t len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sock <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listensock_<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>sock <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"accept error "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

string clientip <span class="token operator">=</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">uint16_t</span> clientport <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="37_read_write__218"></a>3.7 read() 、write() 等函数</h4> 
<p>至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p> 
<ul><li>recvfrom()/sendto()</li><li>read()/write()</li><li>recv()/send()</li><li>………………</li></ul> 
<blockquote> 
 <p>以 read、write 两个函数为例<br> ssize_t read(int fd, void *buf, size_t count);<br> ssize_t write(int fd, const void *buf, size_t count);</p> 
</blockquote> 
<p>read函数是负责从fd中读取内容。当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由<strong>中断</strong>引起的，如果是ECONNREST表示<strong>网络连接出了问题</strong>。</p> 
<p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能：</p> 
<ul><li>1)write的返回值大于0，表示写了部分或者是全部的数据。</li><li>2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。 
  <ul><li>如果错误为EINTR表示在写的时候出现了中断错误。</li><li>如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</li></ul> </li></ul> 
<p>其它的便不仔细介绍这几对I/O函数了，主要就是分清返回值为 -1 的时候，errno 的情况，因为写程序的时候可以根据这个来区分不同的处理情况，具体参见man文档或者baidu、Google。</p> 
<h4><a id="38_close__242"></a>3.8 close() 函数</h4> 
<blockquote> 
 <p>#include &lt;unistd.h&gt;<br> int close(int fd);</p> 
</blockquote> 
<p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p> 
<h2><a id="_UDP_249"></a>📕 UDP</h2> 
<p>这里写一个 UDP 通用的客户端和服务器的程序。</p> 
<h3><a id="udp_sockethpp__UdpSocket_252"></a>udp_socket.hpp （封装 UdpSocket）</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> sockaddr<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> sockaddr_in<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">UdpSocket</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">UdpSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">fd_</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		fd_ <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fd_ <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">close</span><span class="token punctuation">(</span>fd_<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">Bind</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> ip<span class="token punctuation">,</span> <span class="token keyword">uint16_t</span> port<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		sockaddr_in addr<span class="token punctuation">;</span>
		addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
		addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>ip<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>fd_<span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"bind"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">RecvFrom</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> buf<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> ip <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token keyword">uint16_t</span><span class="token operator">*</span> port <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">char</span> tmp<span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
		sockaddr_in peer<span class="token punctuation">;</span>
		socklen_t len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ssize_t read_size <span class="token operator">=</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span>fd_<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span>
		                             <span class="token keyword">sizeof</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>peer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>read_size <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"recvfrom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 将读到的缓冲区内容放到输出参数中</span>
		buf<span class="token operator">-&gt;</span><span class="token function">assign</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> read_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ip <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span>peer<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token operator">*</span>port <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>peer<span class="token punctuation">.</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">SendTo</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> buf<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> ip<span class="token punctuation">,</span> <span class="token keyword">uint16_t</span> port<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		sockaddr_in addr<span class="token punctuation">;</span>
		addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>

		addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>ip<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ssize_t write_size <span class="token operator">=</span> <span class="token function">sendto</span><span class="token punctuation">(</span>fd_<span class="token punctuation">,</span> buf<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> buf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>write_size <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sendto"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> fd_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="udp_serverhpp_UDP__339"></a>udp_server.hpp （UDP 通用服务器）</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"udp_socket.hpp"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> resp<span class="token punctuation">)</span><span class="token operator">&gt;</span> Handler<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">UdpServer</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">UdpServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>sock_<span class="token punctuation">.</span><span class="token function">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">UdpServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		sock_<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> ip<span class="token punctuation">,</span> <span class="token keyword">uint16_t</span> port<span class="token punctuation">,</span> Handler handler<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 1. 创建 socket</span>
		<span class="token comment">// 2. 绑定端口号</span>
		<span class="token keyword">bool</span> ret <span class="token operator">=</span> sock_<span class="token punctuation">.</span><span class="token function">Bind</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 3. 进入事件循环</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 4. 尝试读取请求</span>
			std<span class="token double-colon punctuation">::</span>string req<span class="token punctuation">;</span>
			std<span class="token double-colon punctuation">::</span>string remote_ip<span class="token punctuation">;</span>
			<span class="token keyword">uint16_t</span> remote_port <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">bool</span> ret <span class="token operator">=</span> sock_<span class="token punctuation">.</span><span class="token function">RecvFrom</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>req<span class="token punctuation">,</span> <span class="token operator">&amp;</span>remote_ip<span class="token punctuation">,</span> <span class="token operator">&amp;</span>remote_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			std<span class="token double-colon punctuation">::</span>string resp<span class="token punctuation">;</span>
			<span class="token comment">// 5. 根据请求计算响应</span>
			<span class="token function">handler</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> <span class="token operator">&amp;</span>resp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 6. 返回响应给客户端</span>
			sock_<span class="token punctuation">.</span><span class="token function">SendTo</span><span class="token punctuation">(</span>resp<span class="token punctuation">,</span> remote_ip<span class="token punctuation">,</span> remote_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%s:%d] req: %s, resp: %s\n"</span><span class="token punctuation">,</span> remote_ip<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> remote_port<span class="token punctuation">,</span>
			       req<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> resp<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		sock_<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	UdpSocket sock_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="udp_clienthpp_UDP_390"></a>udp_client.hpp （UDP通用客户端）</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"udp_socket.hpp"</span></span>
<span class="token keyword">class</span> <span class="token class-name">UdpClient</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">UdpClient</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> ip<span class="token punctuation">,</span> <span class="token keyword">uint16_t</span> port<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ip_</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">port_</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>sock_<span class="token punctuation">.</span><span class="token function">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">UdpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		sock_<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">RecvFrom</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> buf<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> sock_<span class="token punctuation">.</span><span class="token function">RecvFrom</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">SendTo</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> buf<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> sock_<span class="token punctuation">.</span><span class="token function">SendTo</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> ip_<span class="token punctuation">,</span> port_<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	UdpSocket sock_<span class="token punctuation">;</span>
<span class="token comment">// 服务器端的 IP 和 端口号</span>
	std<span class="token double-colon punctuation">::</span>string ip_<span class="token punctuation">;</span>
	<span class="token keyword">uint16_t</span> port_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c20ef7a1981f99c2f8a07112fffffba2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VScode 中 Python 代码不高亮显示怎么办？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/03838d352be58e1505e7523b4e405569/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【LeetCode每日一题】——274.H指数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>