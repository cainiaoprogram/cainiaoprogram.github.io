<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android Binder机制 - interface_cast和asBinder源码分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android Binder机制 - interface_cast和asBinder源码分析" />
<meta property="og:description" content="研究Android底层代码时，尤其是Binder跨进程通信时，经常会发现interface_cast和asBinder，很容易被这两个函数绕晕，下面通过分析源码来讲解一下：
interface_cast 下面根据下述ICameraClient例子进行分析一下：
//伪代码 sp&lt;ICameraClient&gt; cameraClient = interface_cast&lt;ICameraClient&gt;(BpBinder(handle)); 看下interface_cast的实现，其代码在IInterface.h中
template&lt;typename INTERFACE&gt; inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj) { return INTERFACE::asInterface(obj); } //这是一个模板函数，展开即为： inline sp&lt;ICameraClient &gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj) { return ICameraClient ::asInterface(obj); } 那ICameraClient的asInterface在哪实现的呢？发现找了ICameraClient.h和ICameraClient.cpp只有下面两个定义：
//frameworks/av/include/camera/android/hardware/ICameraClient.h DECLARE_META_INTERFACE(CameraClient); //frameworks/av/camera/ICameraClient.cpp IMPLEMENT_META_INTERFACE(CameraClient, &#34;android.hardware.ICameraClient&#34;); DECLARE_META_INTERFACE和IMPLEMENT_META_INTERFACE函数是其父类IInterface（frameworks\native\include\binder\IInterace.h）的宏定义：
//声明asInterface函数 #define DECLARE_META_INTERFACE(INTERFACE) static const android::String16 descriptor; //声明asInterface函数 static android::sp&lt;I##INTERFACE&gt; asInterface( const android::sp&lt;android::IBinder&gt;&amp; obj); virtual const android::String16&amp; getInterfaceDescriptor() const; I##INTERFACE(); virtual ~I##INTERFACE(); 展开为： #define DECLARE_META_INTERFACE(CameraClient) //增加一个描述符 static const android::String16 descriptor; //声明asInterface函数 static android::sp&lt;ICameraClient&gt; asInterface( const android::sp&lt;android::IBinder&gt;&amp; obj); //获取描述符函数 virtual const android::String16&amp; getInterfaceDescriptor() const; //构造函数以及折构函数 ICameraClient(); virtual ~ICameraClient(); //实现asInterface函数 #define IMPLEMENT_META_INTERFACE(INTERFACE, NAME) const android::String16 I##INTERFACE::descriptor(NAME); const android::String16&amp; I##INTERFACE::getInterfaceDescriptor() const { return I##INTERFACE::descriptor; } android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface( const android::sp&lt;android::IBinder&gt;&amp; obj) { android::sp&lt;I##INTERFACE&gt; intr; if (obj !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3bd04a0ceaed8781f157a36a82af2541/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-29T15:45:27+08:00" />
<meta property="article:modified_time" content="2017-10-29T15:45:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android Binder机制 - interface_cast和asBinder源码分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>研究Android底层代码时，尤其是Binder跨进程通信时，经常会发现interface_cast和asBinder，很容易被这两个函数绕晕，下面通过分析源码来讲解一下：</p> 
<h3 id="interfacecast">interface_cast</h3> 
<p>下面根据下述ICameraClient例子进行分析一下：</p> 
<pre class="prettyprint"><code class=" hljs xml">//伪代码
sp<span class="hljs-tag">&lt;<span class="hljs-title">ICameraClient</span>&gt;</span> cameraClient = interface_cast<span class="hljs-tag">&lt;<span class="hljs-title">ICameraClient</span>&gt;</span>(BpBinder(handle));</code></pre> 
<p>看下interface_cast的实现，其代码在IInterface.h中</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;
<span class="hljs-keyword">inline</span> sp&lt;INTERFACE&gt; interface_cast(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; obj)
{
    <span class="hljs-keyword">return</span> INTERFACE::asInterface(obj);
}
<span class="hljs-comment">//这是一个模板函数，展开即为：</span>
<span class="hljs-keyword">inline</span> sp&lt;ICameraClient &gt; interface_cast(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; obj)
{
    <span class="hljs-keyword">return</span> ICameraClient ::asInterface(obj);
}</code></pre> 
<p>那ICameraClient的asInterface在哪实现的呢？发现找了ICameraClient.h和ICameraClient.cpp只有下面两个定义：</p> 
<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-comment">//frameworks/av/include/camera/android/hardware/ICameraClient.h</span>
<span class="hljs-function">DECLARE_META_INTERFACE(CameraClient)</span>;

<span class="hljs-comment">//frameworks/av/camera/ICameraClient.cpp</span>
<span class="hljs-function">IMPLEMENT_META_INTERFACE(CameraClient, <span class="hljs-string">"android.hardware.ICameraClient"</span>)</span>;</code></pre> 
<p>DECLARE_META_INTERFACE和IMPLEMENT_META_INTERFACE函数是其父类IInterface（frameworks\native\include\binder\IInterace.h）的宏定义：</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//声明asInterface函数</span>
<span class="hljs-preprocessor">#define DECLARE_META_INTERFACE(INTERFACE)</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> android::String16 descriptor;
    <span class="hljs-comment">//声明asInterface函数</span>
    <span class="hljs-keyword">static</span> android::sp&lt;I<span class="hljs-preprocessor">##INTERFACE&gt; asInterface( </span>
            <span class="hljs-keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj);
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> android::String16&amp; getInterfaceDescriptor() <span class="hljs-keyword">const</span>;
    I<span class="hljs-preprocessor">##INTERFACE();</span>
    <span class="hljs-keyword">virtual</span> ~I<span class="hljs-preprocessor">##INTERFACE();</span>

展开为：
<span class="hljs-preprocessor">#define DECLARE_META_INTERFACE(CameraClient)</span>
    <span class="hljs-comment">//增加一个描述符</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> android::String16 descriptor;
    <span class="hljs-comment">//声明asInterface函数</span>
    <span class="hljs-keyword">static</span> android::sp&lt;ICameraClient&gt; asInterface( 
            <span class="hljs-keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj);
    <span class="hljs-comment">//获取描述符函数</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> android::String16&amp; getInterfaceDescriptor() <span class="hljs-keyword">const</span>;
    <span class="hljs-comment">//构造函数以及折构函数</span>
    ICameraClient();
    <span class="hljs-keyword">virtual</span> ~ICameraClient();

<span class="hljs-comment">//实现asInterface函数</span>
<span class="hljs-preprocessor">#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)</span>
    <span class="hljs-keyword">const</span> android::String16 I<span class="hljs-preprocessor">##INTERFACE::descriptor(NAME); </span>
    <span class="hljs-keyword">const</span> android::String16&amp; 
            I<span class="hljs-preprocessor">##INTERFACE::getInterfaceDescriptor() const { </span>
        <span class="hljs-keyword">return</span> I<span class="hljs-preprocessor">##INTERFACE::descriptor; </span>
    }                                               
    android::sp&lt;I<span class="hljs-preprocessor">##INTERFACE&gt; I##INTERFACE::asInterface(</span>
            <span class="hljs-keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)
    {
        android::sp&lt;I<span class="hljs-preprocessor">##INTERFACE&gt; intr; </span>
        <span class="hljs-keyword">if</span> (obj != NULL) {
            intr = <span class="hljs-keyword">static_cast</span>&lt;I<span class="hljs-preprocessor">##INTERFACE*&gt;(</span>
                obj-&gt;queryLocalInterface( 
                        I<span class="hljs-preprocessor">##INTERFACE::descriptor).get()); </span>
            <span class="hljs-keyword">if</span> (intr == NULL) {
                intr = <span class="hljs-keyword">new</span> Bp<span class="hljs-preprocessor">##INTERFACE(obj); <span class="hljs-comment">//展开即为intr = new BpServiceManager(obj);</span></span>
            }
        }
        <span class="hljs-keyword">return</span> intr;
    }
    I<span class="hljs-preprocessor">##INTERFACE::I##INTERFACE() { }</span>
    I<span class="hljs-preprocessor">##INTERFACE::~I##INTERFACE() { }</span>

展开为：
<span class="hljs-preprocessor">#define IMPLEMENT_META_INTERFACE(CameraClient, "android.hardware.ICameraClient")</span>
    <span class="hljs-comment">//定义ICameraClient的描述符为"android.hardware.ICameraClient"</span>
    <span class="hljs-keyword">const</span> android::String16 ICameraClient ::descriptor(<span class="hljs-string">"android.hardware.ICameraClient"</span>); 
    <span class="hljs-comment">//获取描述符"android.hardware.ICameraClient"</span>
    <span class="hljs-keyword">const</span> android::String16&amp; 
            ICameraClient ::getInterfaceDescriptor() <span class="hljs-keyword">const</span> { 
        <span class="hljs-keyword">return</span> ICameraClient ::descriptor; 
    }                        
    <span class="hljs-comment">//实现asInterface函数</span>
    android::sp&lt;ICameraClient&gt; ICameraClient::asInterface(
            <span class="hljs-keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)
    {
        android::sp&lt;ICameraClient&gt; intr; 
        <span class="hljs-keyword">if</span> (obj != NULL) {
            intr = <span class="hljs-keyword">static_cast</span>&lt;ICameraClient*&gt;(
                <span class="hljs-comment">//queryLocalInterface是在IBinder中定义的，默认返回NULL，但在BBinder的子类BnInterface中，重载了该方法，返回this，而BpBinder没有重载，使用IBinder的默认实现，返回NULL</span>
                obj-&gt;queryLocalInterface( 
                        ICameraClient::descriptor).get()); 
            <span class="hljs-keyword">if</span> (intr == NULL) {
                <span class="hljs-comment">//构建INTERFACE的Bp端代理对象</span>
                intr = <span class="hljs-keyword">new</span> BpCameraClient(obj);
            }
        }
        <span class="hljs-keyword">return</span> intr;
    }
    ICameraClient::ICameraClient() { }
    ICameraClient::~ICameraClient() { }</code></pre> 
<p>总结一下， 如果interface_cast的参数obj是BnInterface，则返回其自身，如果参数obj是BpInterface，则new一个Bp代理对象并返回。这里我们用的是ICameraClient例子来讲解的，则返回BpCameraClient，别的接口也是同样分析的，比如IServiceManager，也会有类似声明如下，则返回BpServiceManager。</p> 
<pre class="prettyprint"><code class=" hljs tex">//frameworks<span class="hljs-command">\native</span><span class="hljs-command">\include</span><span class="hljs-command">\binder</span><span class="hljs-command">\IServiceManager</span>.h
DECLARE_META_INTERFACE(ServiceManager);

//frameworks<span class="hljs-command">\native</span><span class="hljs-command">\libs</span><span class="hljs-command">\binder</span><span class="hljs-command">\IServiceManager</span>.cpp
IMPLEMENT_META_INTERFACE(ServiceManager, "android.os.IServiceManager");</code></pre> 
<h3 id="asbinder">asBinder</h3> 
<p>接着使用上面ICameraClient例子进行分析一下：</p> 
<pre class="prettyprint"><code class=" hljs haskell">//伪代码，根据interface_cast的分析，知道cameraClient即为<span class="hljs-type">BpCameraClient</span>(<span class="hljs-type">BpBinder</span>(handle))
<span class="hljs-title">sp</span>&lt;<span class="hljs-type">ICameraClient</span>&gt; cameraClient = interface_cast&lt;<span class="hljs-type">ICameraClient</span>&gt;(<span class="hljs-typedef"><span class="hljs-keyword">data</span>.readStrongBinder<span class="hljs-container">()</span>);</span>
<span class="hljs-type">IInterface</span>::asBinder(cameraClient);</code></pre> 
<p>看下asBinder的方法，在IInterface.cpp中</p> 
<pre class="prettyprint"><code class=" hljs cpp">sp&lt;IBinder&gt; IInterface::asBinder(<span class="hljs-keyword">const</span> IInterface* iface)
{
    <span class="hljs-keyword">if</span> (iface == NULL) <span class="hljs-keyword">return</span> NULL;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const_cast</span>&lt;IInterface*&gt;(iface)-&gt;onAsBinder();
}

sp&lt;IBinder&gt; IInterface::asBinder(<span class="hljs-keyword">const</span> sp&lt;IInterface&gt;&amp; iface)
{
    <span class="hljs-keyword">if</span> (iface == NULL) <span class="hljs-keyword">return</span> NULL;
    <span class="hljs-keyword">return</span> iface-&gt;onAsBinder();
}</code></pre> 
<p>都会走到onAsBinder方法</p> 
<h5 id="bninterface">BnInterface</h5> 
<p>BnInterface的onAsBinder方法，直接返回自身，因为BnInterface继承自BBinder，而BBinder又继承自IBinder</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;
IBinder* BnInterface&lt;INTERFACE&gt;::onAsBinder()
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

根据例子展开为：
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ICameraClient&gt;
IBinder* BnInterface&lt;ICameraClient&gt;::onAsBinder()
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}</code></pre> 
<h5 id="bpinterface">BpInterface</h5> 
<p>BpInterface的onAsBinder方法，调用remote()方法并返回</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;
<span class="hljs-keyword">inline</span> IBinder* BpInterface&lt;INTERFACE&gt;::onAsBinder()
{
    <span class="hljs-keyword">return</span> remote();
}

根据例子展开为：
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ICameraClient &gt;
<span class="hljs-keyword">inline</span> IBinder* BpInterface&lt;ICameraClient&gt;::onAsBinder()
{
    <span class="hljs-keyword">return</span> remote();
}</code></pre> 
<p>remote()方法在其父类BpRefBase中实现，就是返回mRemote变量</p> 
<pre class="prettyprint"><code class=" hljs fsharp"><span class="hljs-keyword">inline</span>  IBinder*        remote()                { <span class="hljs-keyword">return</span> mRemote; }</code></pre> 
<p>而mRemote变量是在创建BpInterface对象时，将remote变量传给了其父类BpRefBase，我们这个例子里面remote就是BpBinder(handle)</p> 
<p>template <br> inline BpInterface::BpInterface(const sp&amp; remote) <br> : BpRefBase(remote) <br> { <br> }</p> 
<p>BpRefBase::BpRefBase(const sp&amp; o) <br> : mRemote(o.get()), mRefs(NULL), mState(0) <br> { <br> extendObjectLifetime(OBJECT_LIFETIME_WEAK);</p> 
<pre><code>if (mRemote) {
    mRemote-&gt;incStrong(this);           // Removed on first IncStrong().
    mRefs = mRemote-&gt;createWeak(this);  // Held for our entire lifetime.
}
</code></pre> 
<p>} <br> “`</p> 
<p>总结一下， 如果asBinder的参数iface是BnInterface类型，则返回其自身，如果参数iface是BpInterface类型，则返回其mRemote远程代理对象BpBinder(handle) 。</p> 
<p>作者：lb377463323 <br> 出处：<a href="http://blog.csdn.net/lb377463323" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/lb377463323</a> <br> 原文链接：<a href="http://blog.csdn.net/lb377463323/article/details/78385845" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/lb377463323/article/details/78385845</a> <br> 转载请注明出处！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5e77f323a3cf32ca5bf06514fdd14472/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">异步处理rest服务-多线程提升rest性能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/29fc283912a5efa67f7fb3bcd6af0881/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">十月工作总结：勿忘初心，继续前行</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>