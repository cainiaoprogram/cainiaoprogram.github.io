<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>系统级性能分析工具 — Perf - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="系统级性能分析工具 — Perf" />
<meta property="og:description" content="从2.6.31内核开始，linux内核自带了一个性能分析工具perf，能够进行函数级与指令级的热点查找。
perf Performance analysis tools for Linux.
Performance counters for Linux are a new kernel-based subsystem that provide a framework for all things
performance analysis. It covers hardware level (CPU/PMU, Performance Monitoring Unit) features and
software features (software counters, tracepoints) as well.
Perf是内置于Linux内核源码树中的性能剖析(profiling)工具。
它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。
常用于性能瓶颈的查找与热点代码的定位。
CPU周期(cpu-cycles)是默认的性能事件，所谓的CPU周期是指CPU所能识别的最小时间单元，通常为亿分之几秒，
是CPU执行最简单的指令时所需要的时间，例如读取寄存器中的内容，也叫做clock tick。
Perf是一个包含22种子工具的工具集，以下是最常用的5种：
perf-list
perf-stat
perf-top
perf-record
perf-report
perf-list Perf-list用来查看perf所支持的性能事件，有软件的也有硬件的。
List all symbolic event types.
perf list [hw | sw | cache | tracepoint | event_glob]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f590d9126ed65cf75dda5957b3970a3c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-10-23T11:44:05+08:00" />
<meta property="article:modified_time" content="2014-10-23T11:44:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">系统级性能分析工具 — Perf</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>从2.6.31内核开始，linux内核自带了一个性能分析工具perf，能够进行函数级与指令级的热点查找。</p> 
<p> </p> 
<h3>perf</h3> 
<p> </p> 
<p>Performance analysis tools for Linux.</p> 
<p>Performance counters for Linux are a new kernel-based subsystem that provide a framework for all things</p> 
<p>performance analysis. It covers hardware level (CPU/PMU, Performance Monitoring Unit) features and</p> 
<p>software features (software counters, tracepoints) as well.</p> 
<p> </p> 
<p>Perf是内置于Linux内核源码树中的性能剖析(profiling)工具。</p> 
<p>它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。</p> 
<p>常用于性能瓶颈的查找与热点代码的定位。</p> 
<p> </p> 
<p>CPU周期(cpu-cycles)是默认的性能事件，所谓的CPU周期是指CPU所能识别的最小时间单元，通常为亿分之几秒，</p> 
<p>是CPU执行最简单的指令时所需要的时间，例如读取寄存器中的内容，也叫做clock tick。</p> 
<p> </p> 
<p>Perf是一个包含22种子工具的工具集，以下是最常用的5种：</p> 
<p>perf-list</p> 
<p>perf-stat</p> 
<p>perf-top</p> 
<p>perf-record</p> 
<p>perf-report</p> 
<p> </p> 
<h3>perf-list</h3> 
<p> </p> 
<p>Perf-list用来查看perf所支持的性能事件，有软件的也有硬件的。</p> 
<p> </p> 
<p>List all symbolic event types.</p> 
<p>perf list [hw | sw | cache | tracepoint | event_glob]</p> 
<p> </p> 
<p><strong>(1) 性能事件的分布</strong></p> 
<p>hw：Hardware event，9个</p> 
<p>sw：Software event，9个</p> 
<p>cache：Hardware cache event，26个</p> 
<p>tracepoint：Tracepoint event，775个</p> 
<p> </p> 
<p>sw实际上是内核的计数器，与硬件无关。</p> 
<p>hw和cache是CPU架构相关的，依赖于具体硬件。</p> 
<p>tracepoint是基于内核的ftrace，主线2.6.3x以上的内核版本才支持。</p> 
<p> </p> 
<p><strong>(2) 指定性能事件(以它的属性)</strong></p> 
<p>-e &lt;event&gt; : u // userspace</p> 
<p>-e &lt;event&gt; : k // kernel</p> 
<p>-e &lt;event&gt; : h // hypervisor </p> 
<p>-e &lt;event&gt; : G // guest counting (in KVM guests)</p> 
<p>-e &lt;event&gt; : H // host counting (not in KVM guests)</p> 
<p> </p> 
<p><strong>(3) 使用例子</strong></p> 
<p>显示内核和模块中，消耗最多CPU周期的函数：</p> 
<p># perf top -e cycles:k</p> 
<p>显示分配高速缓存最多的函数：</p> 
<p># perf top -e kmem:kmem_cache_alloc</p> 
<p> </p> 
<h3>perf-top</h3> 
<p> </p> 
<p>对于一个指定的性能事件(默认是CPU周期)，显示消耗最多的函数或指令。</p> 
<p> </p> 
<p>System profiling tool.</p> 
<p>Generates and displays a performance counter profile in real time.</p> 
<p>perf top [-e &lt;EVENT&gt; | --event=EVENT] [&lt;options&gt;]</p> 
<p> </p> 
<p>perf top主要用于实时分析各个函数在某个性能事件上的热度，能够快速的定位热点函数，包括应用程序函数、</p> 
<p>模块函数与内核函数，甚至能够定位到热点指令。默认的性能事件为cpu cycles。</p> 
<p> </p> 
<p><strong>(1) 输出格式</strong></p> 
<p># perf top</p> 
<pre><code class="language-plain">Samples: 1M of event 'cycles', Event count (approx.): 73891391490
     5.44%  perf              [.] 0x0000000000023256      
     4.86%  [kernel]          [k] _spin_lock              
     2.43%  [kernel]          [k] _spin_lock_bh           
     2.29%  [kernel]          [k] _spin_lock_irqsave      
     1.77%  [kernel]          [k] __d_lookup              
     1.55%  libc-2.12.so      [.] __strcmp_sse42          
     1.43%  nginx             [.] ngx_vslprintf           
     1.37%  [kernel]          [k] tcp_poll          
</code></pre> 
<p class="plain" name="code">第一列：符号引发的性能事件的比例，默认指占用的cpu周期比例。</p> 
<p>第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。</p> 
<p>第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库)。[k]表述此符号属于内核或模块。</p> 
<p>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p> 
<p> </p> 
<p><strong>(2) 常用交互命令</strong></p> 
<p>h：显示帮助</p> 
<p>UP/DOWN/PGUP/PGDN/SPACE：上下和翻页。</p> 
<p>a：annotate current symbol，注解当前符号。能够给出汇编语言的注解，给出各条指令的采样率。</p> 
<p>d：过滤掉所有不属于此DSO的符号。非常方便查看同一类别的符号。</p> 
<p>P：将当前信息保存到perf.hist.N中。</p> 
<p> </p> 
<p><strong>(3) 常用命令行参数</strong></p> 
<p>-e &lt;event&gt;：指明要分析的性能事件。</p> 
<p>-p &lt;pid&gt;：Profile events on existing Process ID (comma sperated list). 仅分析目标进程及其创建的线程。</p> 
<p>-k &lt;path&gt;：Path to vmlinux. Required for annotation functionality. 带符号表的内核映像所在的路径。</p> 
<p>-K：不显示属于内核或模块的符号。</p> 
<p>-U：不显示属于用户态程序的符号。</p> 
<p>-d &lt;n&gt;：界面的刷新周期，默认为2s，因为perf top默认每2s从mmap的内存区域读取一次性能数据。</p> 
<p>-G：得到函数的调用关系图。</p> 
<p>perf top -G [fractal]，路径概率为相对值，加起来为100%，调用顺序为从下往上。</p> 
<p>perf top -G graph，路径概率为绝对值，加起来为该函数的热度。</p> 
<p> </p> 
<p><strong>(4) 使用例子</strong></p> 
<p># perf top // 默认配置</p> 
<p># perf top -G // 得到调用关系图</p> 
<p># perf top -e cycles // 指定性能事件</p> 
<p># perf top -p 23015,32476 // 查看这两个进程的cpu cycles使用情况</p> 
<p># perf top -s comm,pid,symbol // 显示调用symbol的进程名和进程号</p> 
<p># perf top --comms nginx,top // 仅显示属于指定进程的符号</p> 
<p># perf top --symbols kfree // 仅显示指定的符号</p> 
<p> </p> 
<h3>perf-stat</h3> 
<p> </p> 
<p>用于分析指定程序的性能概况。</p> 
<p> </p> 
<p>Run a command and gather performance counter statistics.</p> 
<p>perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] &lt;command&gt;</p> 
<p>perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] - &lt;command&gt; [&lt;options&gt;]</p> 
<p> </p> 
<p><strong>(1) 输出格式</strong></p> 
<p># perf stat ls</p> 
<pre><code class="language-plain"> Performance counter stats for 'ls':

          0.653782 task-clock                #    0.691 CPUs utilized          
                 0 context-switches          #    0.000 K/sec                  
                 0 CPU-migrations            #    0.000 K/sec                  
               247 page-faults               #    0.378 M/sec                  
         1,625,426 cycles                    #    2.486 GHz                    
         1,050,293 stalled-cycles-frontend   #   64.62% frontend cycles idle   
           838,781 stalled-cycles-backend    #   51.60% backend  cycles idle   
         1,055,735 instructions              #    0.65  insns per cycle        
                                             #    0.99  stalled cycles per insn
           210,587 branches                  #  322.106 M/sec                  
            10,809 branch-misses             #    5.13% of all branches        

       0.000945883 seconds time elapsed</code></pre> 
<p> </p> 
<p>输出包括ls的执行时间，以及10个性能事件的统计。</p> 
<p>task-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized = task-clock / time elapsed，CPU的占用率。</p> 
<p>context-switches：上下文的切换次数。</p> 
<p>CPU-migrations：处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU</p> 
<p>迁移到另一个CPU。</p> 
<p>page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内</p> 
<p>存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配</p> 
<p>等情况也会触发缺页异常。</p> 
<p>cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。</p> 
<p>可以用cycles / task-clock算出。</p> 
<p>stalled-cycles-frontend：略过。</p> 
<p>stalled-cycles-backend：略过。</p> 
<p>instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。</p> 
<p>branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p> 
<p> </p> 
<p><strong>(2) 常用参数</strong></p> 
<p>-p：stat events on existing process id (comma separated list). 仅分析目标进程及其创建的线程。</p> 
<p>-a：system-wide collection from all CPUs. 从所有CPU上收集性能数据。</p> 
<p>-r：repeat command and print average + stddev (max: 100). 重复执行命令求平均。</p> 
<p>-C：Count only on the list of CPUs provided (comma separated list), 从指定CPU上收集性能数据。</p> 
<p>-v：be more verbose (show counter open errors, etc), 显示更多性能数据。</p> 
<p>-n：null run - don't start any counters，只显示任务的执行时间 。</p> 
<p>-x SEP：指定输出列的分隔符。</p> 
<p>-o file：指定输出文件，--append指定追加模式。</p> 
<p>--pre &lt;cmd&gt;：执行目标程序前先执行的程序。</p> 
<p>--post &lt;cmd&gt;：执行目标程序后再执行的程序。</p> 
<p> </p> 
<p><strong>(3) 使用例子</strong></p> 
<p>执行10次程序，给出标准偏差与期望的比值：</p> 
<p># perf stat -r 10 ls &gt; /dev/null</p> 
<p>显示更详细的信息：</p> 
<p># perf stat -v ls &gt; /dev/null</p> 
<p>只显示任务执行时间，不显示性能计数器：</p> 
<p># perf stat -n ls &gt; /dev/null</p> 
<p>单独给出每个CPU上的信息：</p> 
<p># perf stat -a -A ls &gt; /dev/null</p> 
<p>ls命令执行了多少次系统调用：</p> 
<p># perf stat -e syscalls:sys_enter ls </p> 
<p> </p> 
<h3>perf-record</h3> 
<p> </p> 
<p>收集采样信息，并将其记录在数据文件中。</p> 
<p>随后可以通过其它工具(perf-report)对数据文件进行分析，结果类似于perf-top的。</p> 
<p> </p> 
<p>Run a command and record its profile into perf.data.</p> 
<p>This command runs a command and gathers a performance counter profile from it, into perf.data,</p> 
<p>without displaying anything. This file can then be inspected later on, using perf report.</p> 
<p> </p> 
<p><strong>(1) 常用参数</strong></p> 
<p>-e：Select the PMU event.</p> 
<p>-a：System-wide collection from all CPUs.</p> 
<p>-p：Record events on existing process ID (comma separated list).</p> 
<p>-A：Append to the output file to do incremental profiling.</p> 
<p> -f：Overwrite existing data file.</p> 
<p>-o：Output file name.</p> 
<p>-g：Do call-graph (stack chain/backtrace) recording.</p> 
<p>-C：Collect samples only on the list of CPUs provided.</p> 
<p> </p> 
<p><strong>(2) 使用例子</strong></p> 
<p>记录nginx进程的性能数据：</p> 
<p># perf record -p `pgrep -d ',' nginx`</p> 
<p>记录执行ls时的性能数据：</p> 
<p># perf record ls -g</p> 
<p>记录执行ls时的系统调用，可以知道哪些系统调用最频繁：</p> 
<p># perf record -e syscalls:sys_enter ls</p> 
<p> </p> 
<h3>perf-report</h3> 
<p> </p> 
<p>读取perf record创建的数据文件，并给出热点分析结果。</p> 
<p> </p> 
<p>Read perf.data (created by perf record) and display the profile.</p> 
<p>This command displays the performance counter profile information recorded via perf record.</p> 
<p> </p> 
<p><strong>(1) 常用参数</strong></p> 
<p>-i：Input file name. (default: perf.data)</p> 
<p> </p> 
<p><strong>(2) 使用例子</strong></p> 
<p># perf report -i perf.data.2</p> 
<p> </p> 
<h3>More</h3> 
<p> </p> 
<p>除了以上5个常用工具外，还有一些适用于较特殊场景的工具， 比如内核锁、slab分配器、调度器，</p> 
<p>也支持自定义探测点。</p> 
<p> </p> 
<h3>perf-lock</h3> 
<p> </p> 
<p>内核锁的性能分析。</p> 
<p>Analyze lock events.</p> 
<p>perf lock {record | report | script | info}</p> 
<p> </p> 
<p>需要编译选项的支持：CONFIG_LOCKDEP、CONFIG_LOCK_STAT。</p> 
<p>CONFIG_LOCKDEP defines acquired and release events.</p> 
<p>CONFIG_LOCK_STAT defines contended and acquired lock events.</p> 
<p> </p> 
<p><strong>(1) 常用选项</strong></p> 
<p>-i &lt;file&gt;：输入文件</p> 
<p>-k &lt;value&gt;：sorting key，默认为acquired，还可以按contended、wait_total、wait_max和wait_min来排序。</p> 
<p> </p> 
<p><strong>(2) 使用例子</strong></p> 
<p># perf lock record ls // 记录</p> 
<p># perf lock report // 报告</p> 
<p> </p> 
<p><strong>(3) 输出格式</strong></p> 
<pre><code class="language-plain">                Name   acquired  contended total wait (ns)   max wait (ns)   min wait (ns) 

 &amp;mm-&gt;page_table_...        382          0               0               0               0 
 &amp;mm-&gt;page_table_...         72          0               0               0               0 
           &amp;fs-&gt;lock         64          0               0               0               0 
         dcache_lock         62          0               0               0               0 
       vfsmount_lock         43          0               0               0               0 
 &amp;newf-&gt;file_lock...         41          0               0               0               0 
</code></pre> 
<p> </p> 
<p>Name：内核锁的名字。</p> 
<p>aquired：该锁被直接获得的次数，因为没有其它内核路径占用该锁，此时不用等待。</p> 
<p>contended：该锁等待后获得的次数，此时被其它内核路径占用，需要等待。</p> 
<p>total wait：为了获得该锁，总共的等待时间。</p> 
<p>max wait：为了获得该锁，最大的等待时间。</p> 
<p>min wait：为了获得该锁，最小的等待时间。</p> 
<p>最后还有一个Summary：</p> 
<pre><code class="language-plain">=== output for debug===

bad: 10, total: 246
bad rate: 4.065041 %
histogram of events caused bad sequence
    acquire: 0
   acquired: 0
  contended: 0
    release: 10</code></pre> 
<p> </p> 
<h3>perf-kmem</h3> 
<p> </p> 
<p>slab分配器的性能分析。</p> 
<p>Tool to trace/measure kernel memory(slab) properties.</p> 
<p>perf kmem {record | stat} [&lt;options&gt;]</p> 
<p> </p> 
<p><strong>(1) 常用选项</strong></p> 
<p>--i &lt;file&gt;：输入文件</p> 
<p>--caller：show per-callsite statistics，显示内核中调用kmalloc和kfree的地方。</p> 
<p>--alloc：show per-allocation statistics，显示分配的内存地址。</p> 
<p>-l &lt;num&gt;：print n lines only，只显示num行。</p> 
<p>-s &lt;key[,key2...]&gt;：sort the output (default: frag,hit,bytes)</p> 
<p> </p> 
<p><strong>(2) 使用例子</strong></p> 
<p># perf kmem record ls // 记录</p> 
<p># perf kmem stat --caller --alloc -l 20 // 报告</p> 
<p> </p> 
<p><strong>(3) 输出格式</strong></p> 
<pre><code class="language-plain">------------------------------------------------------------------------------------------------------
 Callsite                           | Total_alloc/Per | Total_req/Per   | Hit      | Ping-pong | Frag
------------------------------------------------------------------------------------------------------
 perf_event_mmap+ec                 |    311296/8192  |    155952/4104  |       38 |        0 | 49.902%
 proc_reg_open+41                   |        64/64    |        40/40    |        1 |        0 | 37.500%
 __kmalloc_node+4d                  |      1024/1024  |       664/664   |        1 |        0 | 35.156%
 ext3_readdir+5bd                   |        64/64    |        48/48    |        1 |        0 | 25.000%
 load_elf_binary+8ec                |       512/512   |       392/392   |        1 |        0 | 23.438%
</code></pre> 
<p><br> Callsite：内核代码中调用kmalloc和kfree的地方。</p> 
<p>Total_alloc/Per：总共分配的内存大小，平均每次分配的内存大小。</p> 
<p>Total_req/Per：总共请求的内存大小，平均每次请求的内存大小。</p> 
<p>Hit：调用的次数。</p> 
<p>Ping-pong：kmalloc和kfree不被同一个CPU执行时的次数，这会导致cache效率降低。</p> 
<p>Frag：碎片所占的百分比，碎片 = 分配的内存 - 请求的内存，这部分是浪费的。</p> 
<p>有使用--alloc选项，还会看到Alloc Ptr，即所分配内存的地址。</p> 
<p>最后还有一个Summary：</p> 
<pre><code class="language-plain">SUMMARY
=======
Total bytes requested: 290544
Total bytes allocated: 447016
Total bytes wasted on internal fragmentation: 156472
Internal fragmentation: 35.003669%
Cross CPU allocations: 2/509</code></pre> 
<p> </p> 
<h3>probe-sched</h3> 
<p> </p> 
<p>调度模块分析。</p> 
<p>trace/measure scheduler properties (latencies)</p> 
<p>perf sched {record | latency | map | replay | script}</p> 
<p> </p> 
<p><strong>(1) 使用例子</strong> </p> 
<p># perf sched record sleep 10 // perf sched record &lt;command&gt;</p> 
<p># perf report latency --sort max</p> 
<p> </p> 
<p><strong>(2) 输出格式</strong></p> 
<pre><code class="language-plain"> ---------------------------------------------------------------------------------------------------------------
  Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at     |
 ---------------------------------------------------------------------------------------------------------------
  events/10:61          |      0.655 ms |       10 | avg:    0.045 ms | max:    0.161 ms | max at: 9804.958730 s
  sleep:11156           |      2.263 ms |        4 | avg:    0.052 ms | max:    0.118 ms | max at: 9804.865552 s
  edac-poller:1125      |      0.598 ms |       10 | avg:    0.042 ms | max:    0.113 ms | max at: 9804.958698 s
  events/2:53           |      0.676 ms |       10 | avg:    0.037 ms | max:    0.102 ms | max at: 9814.751605 s
  perf:11155            |      2.109 ms |        1 | avg:    0.068 ms | max:    0.068 ms | max at: 9814.867918 s
</code></pre> 
<p><br> TASK：进程名和pid。</p> 
<p>Runtime：实际的运行时间。</p> 
<p>Switches：进程切换的次数。</p> 
<p>Average delay：平均的调度延迟。</p> 
<p>Maximum delay：最大的调度延迟。</p> 
<p>Maximum delay at：最大调度延迟发生的时刻。</p> 
<p> </p> 
<h3>perf-probe</h3> 
<p> </p> 
<p>可以自定义探测点。</p> 
<p>Define new dynamic tracepoints.</p> 
<p> </p> 
<p>使用例子</p> 
<p>(1) Display which lines in schedule() can be probed</p> 
<p># perf probe --line schedule</p> 
<p>前面有行号的可以探测，没有行号的就不行了。</p> 
<p> </p> 
<p>(2) Add a probe on schedule() function 12th line.</p> 
<p># perf probe -a schedule:12</p> 
<p>在schedule函数的12处增加一个探测点。</p> 
<p> </p> 
<h3>Reference</h3> 
<p> </p> 
<p>[1]. Linux的系统级性能剖析工具系列，by 承刚</p> 
<p>[2]. <a target="_blank" href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/" rel="nofollow noopener noreferrer"> http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/</a></p> 
<p>[3]. <a target="_blank" href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/" rel="nofollow noopener noreferrer"> http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/</a></p> 
<p>[4]. <a target="_blank" href="https://perf.wiki.kernel.org/index.php/Tutorial" rel="nofollow noopener noreferrer"> https://perf.wiki.kernel.org/index.php/Tutorial</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/225bfc2ed70c9db07c2572149cae02a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">codevs 2190 有理逼近  题解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/241e0d8530cfc93f412c66aa68507602/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">oracle 数据库关闭的的几种方式总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>