<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java得到上下文环境,获取Spring的上下文环境ApplicationContext的方式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java得到上下文环境,获取Spring的上下文环境ApplicationContext的方式" />
<meta property="og:description" content="Web项目中发现有人如此获得Spring的上下环境：
public class SpringUtil {
public static ApplicationContext context = new ClassPathXmlApplicationContext(&#34;applicationContext.xml&#34;);
public static Object getBean(String serviceName){
return context.getBean(serviceName);
}
}
在web项目中这种方式非常不可取！！！
分析：
首先，主要意图就是获得Spring上下文；
其次，有了Spring上下文，希望通过getBean()方法获得Spring管理的Bean的对象；
最后，为了方便调用，把上下文定义为static变量或者getBean方法定义为static方法；
但是，在web项目中，系统一旦启动，web服务器会初始化Spring的上下文的，我们可以很优雅的获得Spring的ApplicationContext对象。
如果使用
new ClassPathXmlApplicationContext(&#34;applicationContext.xml&#34;);
相当于重新初始化一遍！！！！
也就是说，重复做启动时候的初始化工作，第一次执行该类的时候会非常耗时！！！！！
正确的做法是：
@Component
public class SpringContextUtil implements ApplicationContextAware {
private static ApplicationContext applicationContext; // Spring应用上下文环境
/*
* 实现了ApplicationContextAware接口，必须实现该方法；
*通过传递applicationContext参数初始化成员变量applicationContext
*/
public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
SpringContextUtil.applicationContext = applicationContext;
}
public static ApplicationContext getApplicationContext() {
return applicationContext;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/57f7c096664117950a7ebaa408ae02fd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-13T06:45:29+08:00" />
<meta property="article:modified_time" content="2021-03-13T06:45:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java得到上下文环境,获取Spring的上下文环境ApplicationContext的方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>Web项目中发现有人如此获得Spring的上下环境：</p> 
 <p>public class SpringUtil {<!-- --></p> 
 <p>public static ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");</p> 
 <p>public static Object getBean(String serviceName){<!-- --></p> 
 <p>return context.getBean(serviceName);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>在web项目中这种方式非常不可取！！！</p> 
 <p>分析：</p> 
 <p>首先，主要意图就是获得Spring上下文；</p> 
 <p>其次，有了Spring上下文，希望通过getBean()方法获得Spring管理的Bean的对象；</p> 
 <p>最后，为了方便调用，把上下文定义为static变量或者getBean方法定义为static方法；</p> 
 <p>但是，在web项目中，系统一旦启动，web服务器会初始化Spring的上下文的，我们可以很优雅的获得Spring的ApplicationContext对象。</p> 
 <p>如果使用</p> 
 <p>new ClassPathXmlApplicationContext("applicationContext.xml");</p> 
 <p>相当于重新初始化一遍！！！！</p> 
 <p>也就是说，重复做启动时候的初始化工作，第一次执行该类的时候会非常耗时！！！！！</p> 
 <p>正确的做法是：</p> 
 <p>@Component</p> 
 <p>public class SpringContextUtil implements ApplicationContextAware {<!-- --></p> 
 <p>private static ApplicationContext applicationContext; // Spring应用上下文环境</p> 
 <p>/*</p> 
 <p>* 实现了ApplicationContextAware接口，必须实现该方法；</p> 
 <p>*通过传递applicationContext参数初始化成员变量applicationContext</p> 
 <p>*/</p> 
 <p>public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {<!-- --></p> 
 <p>SpringContextUtil.applicationContext = applicationContext;</p> 
 <p>}</p> 
 <p>public static ApplicationContext getApplicationContext() {<!-- --></p> 
 <p>return applicationContext;</p> 
 <p>}</p> 
 <p>@SuppressWarnings("unchecked")</p> 
 <p>public static  T getBean(String name) throws BeansException {<!-- --></p> 
 <p>return (T) applicationContext.getBean(name);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>注意：这个地方使用了Spring的注解@Component，如果不是使用annotation的方式，而是使用xml的方式管理Bean，记得写入配置文件</p> 
 <p>其实</p> 
 <p>ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");</p> 
 <p>这种方式获取Sping上下文环境，最主要是在测试环境中使用，比如写一个测试类，系统不启动的情况下手动初始化Spring上下文再获取对象！</p> 
 <p>-----------------------------------------------------------------</p> 
 <p>1、思路：</p> 
 <p>应用程序启动时使用ApplicationContextAware让Spring容器传递自己生成的ApplicationContext给我们， 然后我们把这个ApplicationContext设置成一个类的静态变量， 这样我们就随时都可以在老的代码里得到Application的对象了。</p> 
 <p>2、编写工具类：ApplicationContextHelper</p> 
 <p>/**</p> 
 <p>* 版权所有：华信软件</p> 
 <p>* 项目名称:ACWS框架</p> 
 <p>* 创建者: Wangdf</p> 
 <p>* 创建日期: 2014-4-2</p> 
 <p>* 文件说明: Spring工具栏</p> 
 <p>*/</p> 
 <p>packagecom.huaxin.framework.core.util;</p> 
 <p>importorg.springframework.beans.BeansException;</p> 
 <p>importorg.springframework.context.ApplicationContext;</p> 
 <p>importorg.springframework.context.ApplicationContextAware;</p> 
 <p>/**</p> 
 <p>* Spring工具栏</p> 
 <p>* @author wangdf</p> 
 <p>*/</p> 
 <p>publicclassApplicationContextHelperimplementsApplicationContextAware {<!-- --></p> 
 <p>privatestaticApplicationContext appCtx;</p> 
 <p>/**</p> 
 <p>* 此方法可以把ApplicationContext对象inject到当前类中作为一个静态成员变量。</p> 
 <p>* @param applicationContext ApplicationContext 对象.</p> 
 <p>* @throws BeansException</p> 
 <p>* @author wangdf</p> 
 <p>*/</p> 
 <p>@Override</p> 
 <p>publicvoidsetApplicationContext( ApplicationContext applicationContext )throwsBeansException {<!-- --></p> 
 <p>appCtx = applicationContext;</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* 获取ApplicationContext</p> 
 <p>* @return</p> 
 <p>* @author wangdf</p> 
 <p>*/</p> 
 <p>publicstaticApplicationContext getApplicationContext(){<!-- --></p> 
 <p>returnappCtx;</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* 这是一个便利的方法，帮助我们快速得到一个BEAN</p> 
 <p>* @param beanName bean的名字</p> 
 <p>* @return 返回一个bean对象</p> 
 <p>* @author wangdf</p> 
 <p>*/</p> 
 <p>publicstaticObject getBean( String beanName ) {<!-- --></p> 
 <p>returnappCtx.getBean( beanName );</p> 
 <p>}</p> 
 <p>}/**</p> 
 <p>* 版权所有：华信软件</p> 
 <p>* 项目名称:ACWS框架</p> 
 <p>* 创建者: Wangdf</p> 
 <p>* 创建日期: 2014-4-2</p> 
 <p>* 文件说明: Spring工具栏</p> 
 <p>*/</p> 
 <p>package com.huaxin.framework.core.util;</p> 
 <p>import org.springframework.beans.BeansException;</p> 
 <p>import org.springframework.context.ApplicationContext;</p> 
 <p>import org.springframework.context.ApplicationContextAware;</p> 
 <p>/**</p> 
 <p>* Spring工具栏</p> 
 <p>* @author wangdf</p> 
 <p>*/</p> 
 <p>public class ApplicationContextHelper implements ApplicationContextAware {<!-- --></p> 
 <p>private static ApplicationContext appCtx;</p> 
 <p>/**</p> 
 <p>* 此方法可以把ApplicationContext对象inject到当前类中作为一个静态成员变量。</p> 
 <p>* @param applicationContext ApplicationContext 对象.</p> 
 <p>* @throws BeansException</p> 
 <p>* @author wangdf</p> 
 <p>*/</p> 
 <p>@Override</p> 
 <p>public void setApplicationContext( ApplicationContext applicationContext ) throws BeansException {<!-- --></p> 
 <p>appCtx = applicationContext;</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* 获取ApplicationContext</p> 
 <p>* @return</p> 
 <p>* @author wangdf</p> 
 <p>*/</p> 
 <p>public static ApplicationContext getApplicationContext(){<!-- --></p> 
 <p>return appCtx;</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* 这是一个便利的方法，帮助我们快速得到一个BEAN</p> 
 <p>* @param beanName bean的名字</p> 
 <p>* @return 返回一个bean对象</p> 
 <p>* @author wangdf</p> 
 <p>*/</p> 
 <p>public static Object getBean( String beanName ) {<!-- --></p> 
 <p>return appCtx.getBean( beanName );</p> 
 <p>}</p> 
 <p>}</p> 
 <p>3、在Spring的配置文件中配置上述类后、应用程序启动时会使用ApplicationContextAware让Spring容器传递自己生成的ApplicationContext给我们， 然后我们把这个ApplicationContext设置成一个类的静态变量， 这样我们就随时都可以在老的代码里得到Application的对象了。</p> 
 <p>4、获得bean的方法、获取数据库连接的方法、获取ApplicationContext</p> 
 <p>4.1、取得通过Spring配置文件注入的任意Bean(以取得DataSource为例)</p> 
 <p></p> 
 <p>init-method='init'destroy-method="close"&gt;</p> 
 <p></p> 
 <p>init-method='init'destroy-method="close"&gt;</p> 
 <p>//取得数据源</p> 
 <p>DruidDataSource dataSource = (DruidDataSource)ApplicationContextHelper.getBean("dataSource");</p> 
 <p>Connection connection = DataSourceUtils.getConnection(dataSource);</p> 
 <p>//取得ApplicationContext</p> 
 <p>ApplicationContext ctx = ApplicationContextHelper.getApplicationContext();//取得数据源</p> 
 <p>DruidDataSource dataSource = (DruidDataSource)ApplicationContextHelper.getBean("dataSource");</p> 
 <p>Connection connection = DataSourceUtils.getConnection(dataSource);</p> 
 <p>//取得ApplicationContext</p> 
 <p>ApplicationContext ctx = ApplicationContextHelper.getApplicationContext();</p> 
 <p>4.2、取得通过注解方式注入的Bean(以在取得Service为例)</p> 
 <p>通过@Service("userTestService")定义bean</p> 
 <p>@Service("userTestService")</p> 
 <p>publicclassUserTestServiceImplimplementsUserTestService  {<!-- --></p> 
 <p>@Autowired</p> 
 <p>privateUserTestDao userDao;</p> 
 <p>@Transactional(propagation=Propagation.NOT_SUPPORTED)</p> 
 <p>@Override</p> 
 <p>publicMap doGetRecordById() {<!-- --></p> 
 <p>returnuserDao.getRecordById("1");</p> 
 <p>}</p> 
 <p>。。。略。。。</p> 
 <p>}@Service("userTestService")</p> 
 <p>public class UserTestServiceImpl implements UserTestService {<!-- --></p> 
 <p>@Autowired</p> 
 <p>private UserTestDao userDao;</p> 
 <p>@Transactional(propagation=Propagation.NOT_SUPPORTED)</p> 
 <p>@Override</p> 
 <p>public Map doGetRecordById() {<!-- --></p> 
 <p>return userDao.getRecordById("1");</p> 
 <p>}</p> 
 <p>。。。略。。。</p> 
 <p>}</p> 
 <p>通过以下代码获取Bean</p> 
 <p>/**</p> 
 <p>* 测试Bean获取</p> 
 <p>* @throws Exception</p> 
 <p>*/</p> 
 <p>@Test</p> 
 <p>publicvoidtestGetBean()throwsException{<!-- --></p> 
 <p>//通过注解方式</p> 
 <p>UserTestService userTestService = (UserTestService)ApplicationContextHelper.getBean("userTestService");</p> 
 <p>System.out.println(userTestService);</p> 
 <p>}</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/218f2fd85ebe1a86c6bb4f38a5a22327/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ArcGIS道路网拓扑检查</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f5c823bf22292967341fc3db7b7c81a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第一讲：基本输入输出函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>