<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QObject类介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="QObject类介绍" />
<meta property="og:description" content="QObject特性 QObject是Qt库中最重要的类之一。作为所有Qt类的基类，QObject提供了信号槽机制、对象树、动态属性、元对象系统、事件处理机制、线程安全、国际化等许多重要特性，这些特性可以帮助开发者轻松实现模块间通信、组件化、程序设计以及事件处理等方面的功能。
在Qt框架下编程，不管用不用到Qt的特性，都推荐自定义类继承QObject类，这样在需要的时候，就可以随时使用Qt基于QObject类提供的各种特性和机制，而且可以让自定义的类很好地融入到Qt的框架之中。
具体来讲，QObject主要实现了以下特性：
1.信号槽机制：QObject通过定义信号（signal）和槽（slot）来实现对象间的通信。当信号被触发时，与该信号相对应注册的槽函数将会被自动调用。一个信号可以连接到多个槽函数上，也可以将多个信号连接到同一个槽函数。信号/槽机制是Qt中最强大和最独特的功能之一，可以帮助开发者在不同的对象之间进行通信，处理事件等。
2.对象树：QObject支持管理对象树结构的方式。它允许对象包含一个父对象和零个或多个子对象。当父对象被删除时，其所有子对象也会被自动销毁。这个特性使得我们在Qt程序中组织和管理QObject及其子类之间的依赖关系变得更容易。
3.动态属性：QObject支持添加动态属性。这意味着，除了一组已经存在的静态属性之外，每个对象实例还可以动态地创建和设置新的属性，这些属性不需要在编译器层面进行定义和声明。这种灵活性使得QObject能够适应各种场景的需求。
4.元对象系统：元对象系统（Meta-Object System）是QObject的另一个重要特性。它为每个QObject和其子类提供运行时类型信息，包括对象的类名、属性、方法和信号等信息，这些信息都可以在运行时被访问或者修改。元对象系统赋予了Qt框架独特的能力，例如能够自动序列化和反序列化对象以及其成员等，同时也是实现Qt信号槽机制的关键技术。
5.事件处理机制：QObject支持通过发送和接收事件来实现对象间的通信。Qt中的事件是指某种对象发生的一些动作或状态变化，通常包含一个事件类型和一些参数。QObject可以捕获并处理各种类型的事件，也可以派发（dispatch）事件给其他对象进行处理。
6.线程安全：QObject被设计为线程安全的基础构建单元。这意味着QObject默认可以在多线程环境下直接使用，而无需考虑同步问题。但是，如果需要在不同线程之间交互对象，还是需要小心地设计和管理线程模型。
7.国际化：QObject提供国际化（Internationalization / i18n）函数，帮助开发人员使应用程序能够方便地本地化，支持多语言切换。i18n函数提供消息翻译，日期和时间格式化以及数字格式转换等功能。
QObject 类接口 QObject 类是 Qt 里的基础类，其接口非常丰富。下面是其中一些重要的接口及其作用：
objectName() 和 setObjectName(): 分别用于获取和设置对象名称，在使用 Qt 的 GUI 编程时非常常用。因为 QObject 实例可以被组织成一个树形结构，有了名称，就能方便地在整个对象树中查找和通信。
parent() 和 setParent(): 分别用于获取和设置父对象。当子对象的父对象被删除时，子对象也会自动地被删除，这是通过 Qt 手工管理的内存分配方式实现的。
signals: 槽函数用于连接到信号(即事件)，并且能够传递参数。这样，当发生某个信号时，与之相连的槽函数就会被执行。
slots: 响应事件的函数，与 signal 配对使用。它们的作用是接受来自信号所触发的数据，并采取相应的操作。
event()：主要是消息处理函数，用于处理事件。每个 QObject 有一个事件队列(Event Queue), 所有从活动线程(postEvent)或当前线程(sendEvent)发送的事件都会加入此队列，而所有的来自应用程序或窗口系统的事件最终都通过此函数进行分发处理。
startTimer() 和 killTimer(): 利用定时器(Timer)实现定期执行一些操作。startTimer()的返回值是一个计时器 ID，可以通过 killTimer() 取消某个定时器。
moveToThread(): 使用移动机制在其他线程中执行某段代码。简单来说就是将 QObject 对象转移到新的线程中，并与新线程事件循环相关联。
metaObject()：获取QObject类的元对象，即QMetaObject类型的对象，用于获取该类的信号、槽、属性等元信息。
deleteLater()：延迟删除 QObject，它大多数情况下会被应用于子对象。此函数会在当前调用栈上添加到事件队列中。
blockSignals(bool block):控制所发布信号的阻塞和非阻塞状态。当参数为true时，意味着所有接收对象(期望使用该信号作为输入)将不再收到这个信号。
dumpObjectInfo()/dumpObjectTree(): 输出列表格式，对象及其父级或子级名称、地址等，便于debug。
QObject头文件 由于QObject类过于重要，因此将其头文件列于此，方便隔三差五地复习一下。QObject用得好，可以做很多需要运行时动态处理的工作，大大地提高程序的灵活性。
class Q_CORE_EXPORT QObject { Q_OBJECT Q_PROPERTY(QString objectName READ objectName WRITE setObjectName NOTIFY objectNameChanged) Q_DECLARE_PRIVATE(QObject) public: Q_INVOKABLE explicit QObject(QObject *parent=nullptr); virtual ~QObject(); virtual bool event(QEvent *event); virtual bool eventFilter(QObject *watched, QEvent *event); #if defined(QT_NO_TRANSLATION) || defined(Q_CLANG_QDOC) static QString tr(const char *sourceText, const char * = nullptr, int = -1) { return QString::fromUtf8(sourceText); } #if QT_DEPRECATED_SINCE(5, 0) QT_DEPRECATED static QString trUtf8(const char *sourceText, const char * = nullptr, int = -1) { return QString::fromUtf8(sourceText); } #endif #endif //QT_NO_TRANSLATION QString objectName() const; void setObjectName(const QString &amp;name); inline bool isWidgetType() const { return d_ptr-&gt;isWidget; } inline bool isWindowType() const { return d_ptr-&gt;isWindow; } inline bool signalsBlocked() const noexcept { return d_ptr-&gt;blockSig; } bool blockSignals(bool b) noexcept; QThread *thread() const; void moveToThread(QThread *thread); int startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer); #if __has_include(&lt;chrono&gt;) Q_ALWAYS_INLINE int startTimer(std::chrono::milliseconds time, Qt::TimerType timerType = Qt::CoarseTimer) { return startTimer(int(time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7ff16c971f2f3397dd30123dee9d6d1e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-30T08:30:00+08:00" />
<meta property="article:modified_time" content="2023-05-30T08:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QObject类介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>QObject特性</h3> 
<p>QObject是Qt库中最重要的类之一。作为所有Qt类的基类，QObject提供了信号槽机制、对象树、动态属性、元对象系统、事件处理机制、线程安全、国际化等许多重要特性，这些特性可以帮助开发者轻松实现模块间通信、组件化、程序设计以及事件处理等方面的功能。</p> 
<p>在Qt框架下编程，不管用不用到Qt的特性，都推荐自定义类继承QObject类，这样在需要的时候，就可以随时使用Qt基于QObject类提供的各种特性和机制，而且可以让自定义的类很好地融入到Qt的框架之中。</p> 
<p>具体来讲，QObject主要实现了以下特性：</p> 
<p>1.信号槽机制：QObject通过定义信号（signal）和槽（slot）来实现对象间的通信。当信号被触发时，与该信号相对应注册的槽函数将会被自动调用。一个信号可以连接到多个槽函数上，也可以将多个信号连接到同一个槽函数。信号/槽机制是Qt中最强大和最独特的功能之一，可以帮助开发者在不同的对象之间进行通信，处理事件等。</p> 
<p>2.对象树：QObject支持管理对象树结构的方式。它允许对象包含一个父对象和零个或多个子对象。当父对象被删除时，其所有子对象也会被自动销毁。这个特性使得我们在Qt程序中组织和管理QObject及其子类之间的依赖关系变得更容易。</p> 
<p>3.动态属性：QObject支持添加动态属性。这意味着，除了一组已经存在的静态属性之外，每个对象实例还可以动态地创建和设置新的属性，这些属性不需要在编译器层面进行定义和声明。这种灵活性使得QObject能够适应各种场景的需求。</p> 
<p>4.元对象系统：元对象系统（Meta-Object System）是QObject的另一个重要特性。它为每个QObject和其子类提供运行时类型信息，包括对象的类名、属性、方法和信号等信息，这些信息都可以在运行时被访问或者修改。元对象系统赋予了Qt框架独特的能力，例如能够自动序列化和反序列化对象以及其成员等，同时也是实现Qt信号槽机制的关键技术。</p> 
<p>5.事件处理机制：QObject支持通过发送和接收事件来实现对象间的通信。Qt中的事件是指某种对象发生的一些动作或状态变化，通常包含一个事件类型和一些参数。QObject可以捕获并处理各种类型的事件，也可以派发（dispatch）事件给其他对象进行处理。</p> 
<p>6.线程安全：QObject被设计为线程安全的基础构建单元。这意味着QObject默认可以在多线程环境下直接使用，而无需考虑同步问题。但是，如果需要在不同线程之间交互对象，还是需要小心地设计和管理线程模型。</p> 
<p>7.国际化：QObject提供国际化（Internationalization / i18n）函数，帮助开发人员使应用程序能够方便地本地化，支持多语言切换。i18n函数提供消息翻译，日期和时间格式化以及数字格式转换等功能。</p> 
<h3>QObject 类接口</h3> 
<p>QObject 类是 Qt 里的基础类，其接口非常丰富。下面是其中一些重要的接口及其作用：</p> 
<ol><li> <p>objectName() 和 setObjectName(): 分别用于获取和设置对象名称，在使用 Qt 的 GUI 编程时非常常用。因为 QObject 实例可以被组织成一个树形结构，有了名称，就能方便地在整个对象树中查找和通信。</p> </li><li> <p>parent() 和 setParent(): 分别用于获取和设置父对象。当子对象的父对象被删除时，子对象也会自动地被删除，这是通过 Qt 手工管理的内存分配方式实现的。</p> </li><li> <p>signals: 槽函数用于连接到信号(即事件)，并且能够传递参数。这样，当发生某个信号时，与之相连的槽函数就会被执行。</p> </li><li> <p>slots: 响应事件的函数，与 signal 配对使用。它们的作用是接受来自信号所触发的数据，并采取相应的操作。</p> </li><li> <p>event()：主要是消息处理函数，用于处理事件。每个 QObject 有一个事件队列(Event Queue), 所有从活动线程(postEvent)或当前线程(sendEvent)发送的事件都会加入此队列，而所有的来自应用程序或窗口系统的事件最终都通过此函数进行分发处理。</p> </li><li> <p>startTimer() 和 killTimer(): 利用定时器(Timer)实现定期执行一些操作。startTimer()的返回值是一个计时器 ID，可以通过 killTimer() 取消某个定时器。</p> </li><li> <p>moveToThread(): 使用移动机制在其他线程中执行某段代码。简单来说就是将 QObject 对象转移到新的线程中，并与新线程事件循环相关联。</p> </li><li> <p>metaObject()：获取QObject类的元对象，即QMetaObject类型的对象，用于获取该类的信号、槽、属性等元信息。</p> </li><li> <p>deleteLater()：延迟删除 QObject，它大多数情况下会被应用于子对象。此函数会在当前调用栈上添加到事件队列中。</p> </li><li> <p>blockSignals(bool block):控制所发布信号的阻塞和非阻塞状态。当参数为true时，意味着所有接收对象(期望使用该信号作为输入)将不再收到这个信号。</p> </li><li> <p>dumpObjectInfo()/dumpObjectTree(): 输出列表格式，对象及其父级或子级名称、地址等，便于debug。</p> </li></ol> 
<h3>QObject头文件</h3> 
<p>由于QObject类过于重要，因此将其头文件列于此，方便隔三差五地复习一下。QObject用得好，可以做很多需要运行时动态处理的工作，大大地提高程序的灵活性。</p> 
<pre><code class="language-cpp">class Q_CORE_EXPORT QObject
{
    Q_OBJECT
    Q_PROPERTY(QString objectName READ objectName WRITE setObjectName NOTIFY objectNameChanged)
    Q_DECLARE_PRIVATE(QObject)
public:
    Q_INVOKABLE explicit QObject(QObject *parent=nullptr);
    virtual ~QObject();
    virtual bool event(QEvent *event);
    virtual bool eventFilter(QObject *watched, QEvent *event);
#if defined(QT_NO_TRANSLATION) || defined(Q_CLANG_QDOC)
    static QString tr(const char *sourceText, const char * = nullptr, int = -1)
        { return QString::fromUtf8(sourceText); }
#if QT_DEPRECATED_SINCE(5, 0)
    QT_DEPRECATED static QString trUtf8(const char *sourceText, const char * = nullptr, int = -1)
        { return QString::fromUtf8(sourceText); }
#endif
#endif //QT_NO_TRANSLATION
    QString objectName() const;
    void setObjectName(const QString &amp;name);
    inline bool isWidgetType() const { return d_ptr-&gt;isWidget; }
    inline bool isWindowType() const { return d_ptr-&gt;isWindow; }
    inline bool signalsBlocked() const noexcept { return d_ptr-&gt;blockSig; }
    bool blockSignals(bool b) noexcept;
    QThread *thread() const;
    void moveToThread(QThread *thread);
    int startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer);
#if __has_include(&lt;chrono&gt;)
    Q_ALWAYS_INLINE
    int startTimer(std::chrono::milliseconds time, Qt::TimerType timerType = Qt::CoarseTimer)
    {
        return startTimer(int(time.count()), timerType);
    }
#endif
    void killTimer(int id);
    template&lt;typename T&gt;
    inline T findChild(const QString &amp;aName = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
    {
        typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type ObjType;
        return static_cast&lt;T&gt;(qt_qFindChild_helper(this, aName, ObjType::staticMetaObject, options));
    }
    template&lt;typename T&gt;
    inline QList&lt;T&gt; findChildren(const QString &amp;aName = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
    {
        typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type ObjType;
        QList&lt;T&gt; list;
        qt_qFindChildren_helper(this, aName, ObjType::staticMetaObject,
                                reinterpret_cast&lt;QList&lt;void *&gt; *&gt;(&amp;list), options);
        return list;
    }
#ifndef QT_NO_REGEXP
#if QT_DEPRECATED_SINCE(5, 13)
    template&lt;typename T&gt;
    QT_DEPRECATED_X("Use findChildren(const QRegularExpression &amp;, ...) instead.")
    inline QList&lt;T&gt; findChildren(const QRegExp &amp;re, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
    {
        typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type ObjType;
        QList&lt;T&gt; list;
        qt_qFindChildren_helper(this, re, ObjType::staticMetaObject,
                                reinterpret_cast&lt;QList&lt;void *&gt; *&gt;(&amp;list), options);
        return list;
    }
#endif
#endif
#if QT_CONFIG(regularexpression)
    template&lt;typename T&gt;
    inline QList&lt;T&gt; findChildren(const QRegularExpression &amp;re, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
    {
        typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type ObjType;
        QList&lt;T&gt; list;
        qt_qFindChildren_helper(this, re, ObjType::staticMetaObject,
                                reinterpret_cast&lt;QList&lt;void *&gt; *&gt;(&amp;list), options);
        return list;
    }
#endif // QT_CONFIG(regularexpression)
    inline const QObjectList &amp;children() const { return d_ptr-&gt;children; }
    void setParent(QObject *parent);
    void installEventFilter(QObject *filterObj);
    void removeEventFilter(QObject *obj);
    static QMetaObject::Connection connect(const QObject *sender, const char *signal,
                        const QObject *receiver, const char *member, Qt::ConnectionType = Qt::AutoConnection);
    static QMetaObject::Connection connect(const QObject *sender, const QMetaMethod &amp;signal,
                        const QObject *receiver, const QMetaMethod &amp;method,
                        Qt::ConnectionType type = Qt::AutoConnection);
    inline QMetaObject::Connection connect(const QObject *sender, const char *signal,
                        const char *member, Qt::ConnectionType type = Qt::AutoConnection) const;
#ifdef Q_CLANG_QDOC
    template&lt;typename PointerToMemberFunction&gt;
    static QMetaObject::Connection connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type = Qt::AutoConnection);
    template&lt;typename PointerToMemberFunction, typename Functor&gt;
    static QMetaObject::Connection connect(const QObject *sender, PointerToMemberFunction signal, Functor functor);
    template&lt;typename PointerToMemberFunction, typename Functor&gt;
    static QMetaObject::Connection connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type = Qt::AutoConnection);
#else
    //Connect a signal to a pointer to qobject member function
    template &lt;typename Func1, typename Func2&gt;
    static inline QMetaObject::Connection connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal,
                                     const typename QtPrivate::FunctionPointer&lt;Func2&gt;::Object *receiver, Func2 slot,
                                     Qt::ConnectionType type = Qt::AutoConnection)
    {
        typedef QtPrivate::FunctionPointer&lt;Func1&gt; SignalType;
        typedef QtPrivate::FunctionPointer&lt;Func2&gt; SlotType;
        Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro&lt;typename SignalType::Object&gt;::Value,
                          "No Q_OBJECT in the class with the signal");
        //compilation error if the arguments does not match.
        Q_STATIC_ASSERT_X(int(SignalType::ArgumentCount) &gt;= int(SlotType::ArgumentCount),
                          "The slot requires more arguments than the signal provides.");
        Q_STATIC_ASSERT_X((QtPrivate::CheckCompatibleArguments&lt;typename SignalType::Arguments, typename SlotType::Arguments&gt;::value),
                          "Signal and slot arguments are not compatible.");
        Q_STATIC_ASSERT_X((QtPrivate::AreArgumentsCompatible&lt;typename SlotType::ReturnType, typename SignalType::ReturnType&gt;::value),
                          "Return type of the slot is not compatible with the return type of the signal.");
        const int *types = nullptr;
        if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
            types = QtPrivate::ConnectionTypes&lt;typename SignalType::Arguments&gt;::types();
        return connectImpl(sender, reinterpret_cast&lt;void **&gt;(&amp;signal),
                           receiver, reinterpret_cast&lt;void **&gt;(&amp;slot),
                           new QtPrivate::QSlotObject&lt;Func2, typename QtPrivate::List_Left&lt;typename SignalType::Arguments, SlotType::ArgumentCount&gt;::Value,
                                           typename SignalType::ReturnType&gt;(slot),
                            type, types, &amp;SignalType::Object::staticMetaObject);
    }
    //connect to a function pointer  (not a member)
    template &lt;typename Func1, typename Func2&gt;
    static inline typename std::enable_if&lt;int(QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount) &gt;= 0, QMetaObject::Connection&gt;::type
            connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, Func2 slot)
    {
        return connect(sender, signal, sender, slot, Qt::DirectConnection);
    }
    //connect to a function pointer  (not a member)
    template &lt;typename Func1, typename Func2&gt;
    static inline typename std::enable_if&lt;int(QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount) &gt;= 0 &amp;&amp;
                                          !QtPrivate::FunctionPointer&lt;Func2&gt;::IsPointerToMemberFunction, QMetaObject::Connection&gt;::type
            connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, const QObject *context, Func2 slot,
                    Qt::ConnectionType type = Qt::AutoConnection)
    {
        typedef QtPrivate::FunctionPointer&lt;Func1&gt; SignalType;
        typedef QtPrivate::FunctionPointer&lt;Func2&gt; SlotType;
        Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro&lt;typename SignalType::Object&gt;::Value,
                          "No Q_OBJECT in the class with the signal");
        //compilation error if the arguments does not match.
        Q_STATIC_ASSERT_X(int(SignalType::ArgumentCount) &gt;= int(SlotType::ArgumentCount),
                          "The slot requires more arguments than the signal provides.");
        Q_STATIC_ASSERT_X((QtPrivate::CheckCompatibleArguments&lt;typename SignalType::Arguments, typename SlotType::Arguments&gt;::value),
                          "Signal and slot arguments are not compatible.");
        Q_STATIC_ASSERT_X((QtPrivate::AreArgumentsCompatible&lt;typename SlotType::ReturnType, typename SignalType::ReturnType&gt;::value),
                          "Return type of the slot is not compatible with the return type of the signal.");
        const int *types = nullptr;
        if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
            types = QtPrivate::ConnectionTypes&lt;typename SignalType::Arguments&gt;::types();
        return connectImpl(sender, reinterpret_cast&lt;void **&gt;(&amp;signal), context, nullptr,
                           new QtPrivate::QStaticSlotObject&lt;Func2,
                                                 typename QtPrivate::List_Left&lt;typename SignalType::Arguments, SlotType::ArgumentCount&gt;::Value,
                                                 typename SignalType::ReturnType&gt;(slot),
                           type, types, &amp;SignalType::Object::staticMetaObject);
    }
    //connect to a functor
    template &lt;typename Func1, typename Func2&gt;
    static inline typename std::enable_if&lt;QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount == -1, QMetaObject::Connection&gt;::type
            connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, Func2 slot)
    {
        return connect(sender, signal, sender, std::move(slot), Qt::DirectConnection);
    }
    //connect to a functor, with a "context" object defining in which event loop is going to be executed
    template &lt;typename Func1, typename Func2&gt;
    static inline typename std::enable_if&lt;QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount == -1, QMetaObject::Connection&gt;::type
            connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, const QObject *context, Func2 slot,
                    Qt::ConnectionType type = Qt::AutoConnection)
    {
        typedef QtPrivate::FunctionPointer&lt;Func1&gt; SignalType;
        const int FunctorArgumentCount = QtPrivate::ComputeFunctorArgumentCount&lt;Func2 , typename SignalType::Arguments&gt;::Value;
        Q_STATIC_ASSERT_X((FunctorArgumentCount &gt;= 0),
                          "Signal and slot arguments are not compatible.");
        const int SlotArgumentCount = (FunctorArgumentCount &gt;= 0) ? FunctorArgumentCount : 0;
        typedef typename QtPrivate::FunctorReturnType&lt;Func2, typename QtPrivate::List_Left&lt;typename SignalType::Arguments, SlotArgumentCount&gt;::Value&gt;::Value SlotReturnType;
        Q_STATIC_ASSERT_X((QtPrivate::AreArgumentsCompatible&lt;SlotReturnType, typename SignalType::ReturnType&gt;::value),
                          "Return type of the slot is not compatible with the return type of the signal.");
        Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro&lt;typename SignalType::Object&gt;::Value,
                          "No Q_OBJECT in the class with the signal");
        const int *types = nullptr;
        if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
            types = QtPrivate::ConnectionTypes&lt;typename SignalType::Arguments&gt;::types();
        return connectImpl(sender, reinterpret_cast&lt;void **&gt;(&amp;signal), context, nullptr,
                           new QtPrivate::QFunctorSlotObject&lt;Func2, SlotArgumentCount,
                                typename QtPrivate::List_Left&lt;typename SignalType::Arguments, SlotArgumentCount&gt;::Value,
                                typename SignalType::ReturnType&gt;(std::move(slot)),
                           type, types, &amp;SignalType::Object::staticMetaObject);
    }
#endif //Q_CLANG_QDOC
    static bool disconnect(const QObject *sender, const char *signal,
                           const QObject *receiver, const char *member);
    static bool disconnect(const QObject *sender, const QMetaMethod &amp;signal,
                           const QObject *receiver, const QMetaMethod &amp;member);
    inline bool disconnect(const char *signal = nullptr,
                           const QObject *receiver = nullptr, const char *member = nullptr) const
        { return disconnect(this, signal, receiver, member); }
    inline bool disconnect(const QObject *receiver, const char *member = nullptr) const
        { return disconnect(this, nullptr, receiver, member); }
    static bool disconnect(const QMetaObject::Connection &amp;);
#ifdef Q_CLANG_QDOC
    template&lt;typename PointerToMemberFunction&gt;
    static bool disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method);
#else
    template &lt;typename Func1, typename Func2&gt;
    static inline bool disconnect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal,
                                  const typename QtPrivate::FunctionPointer&lt;Func2&gt;::Object *receiver, Func2 slot)
    {
        typedef QtPrivate::FunctionPointer&lt;Func1&gt; SignalType;
        typedef QtPrivate::FunctionPointer&lt;Func2&gt; SlotType;
        Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro&lt;typename SignalType::Object&gt;::Value,
                          "No Q_OBJECT in the class with the signal");
        //compilation error if the arguments does not match.
        Q_STATIC_ASSERT_X((QtPrivate::CheckCompatibleArguments&lt;typename SignalType::Arguments, typename SlotType::Arguments&gt;::value),
                          "Signal and slot arguments are not compatible.");
        return disconnectImpl(sender, reinterpret_cast&lt;void **&gt;(&amp;signal), receiver, reinterpret_cast&lt;void **&gt;(&amp;slot),
                              &amp;SignalType::Object::staticMetaObject);
    }
    template &lt;typename Func1&gt;
    static inline bool disconnect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal,
                                  const QObject *receiver, void **zero)
    {
        // This is the overload for when one wish to disconnect a signal from any slot. (slot=nullptr)
        // Since the function template parameter cannot be deduced from '0', we use a
        // dummy void ** parameter that must be equal to 0
        Q_ASSERT(!zero);
        typedef QtPrivate::FunctionPointer&lt;Func1&gt; SignalType;
        return disconnectImpl(sender, reinterpret_cast&lt;void **&gt;(&amp;signal), receiver, zero,
                              &amp;SignalType::Object::staticMetaObject);
    }
#endif //Q_CLANG_QDOC
#if QT_VERSION &lt; QT_VERSION_CHECK(6, 0, 0)
    void dumpObjectTree(); // ### Qt 6: remove
    void dumpObjectInfo(); // ### Qt 6: remove
#endif
    void dumpObjectTree() const;
    void dumpObjectInfo() const;
#ifndef QT_NO_PROPERTIES
    bool setProperty(const char *name, const QVariant &amp;value);
    QVariant property(const char *name) const;
    QList&lt;QByteArray&gt; dynamicPropertyNames() const;
#endif // QT_NO_PROPERTIES
#ifndef QT_NO_USERDATA
    QT_DEPRECATED_VERSION_5_14
    static uint registerUserData();
    QT_DEPRECATED_VERSION_X_5_14("Use setProperty()")
    void setUserData(uint id, QObjectUserData* data);
    QT_DEPRECATED_VERSION_X_5_14("Use property()")
    QObjectUserData* userData(uint id) const;
#endif // QT_NO_USERDATA
Q_SIGNALS:
    void destroyed(QObject * = nullptr);
    void objectNameChanged(const QString &amp;objectName, QPrivateSignal);
public:
    inline QObject *parent() const { return d_ptr-&gt;parent; }
    inline bool inherits(const char *classname) const
        { return const_cast&lt;QObject *&gt;(this)-&gt;qt_metacast(classname) != nullptr; }
public Q_SLOTS:
    void deleteLater();
protected:
    QObject *sender() const;
    int senderSignalIndex() const;
    int receivers(const char* signal) const;
    bool isSignalConnected(const QMetaMethod &amp;signal) const;
    virtual void timerEvent(QTimerEvent *event);
    virtual void childEvent(QChildEvent *event);
    virtual void customEvent(QEvent *event);
    virtual void connectNotify(const QMetaMethod &amp;signal);
    virtual void disconnectNotify(const QMetaMethod &amp;signal);
protected:
    QObject(QObjectPrivate &amp;dd, QObject *parent = nullptr);
protected:
    QScopedPointer&lt;QObjectData&gt; d_ptr;
    static const QMetaObject staticQtMetaObject;
    friend inline const QMetaObject *qt_getQtMetaObject() noexcept;
    friend struct QMetaObject;
    friend struct QMetaObjectPrivate;
    friend class QMetaCallEvent;
    friend class QApplication;
    friend class QApplicationPrivate;
    friend class QCoreApplication;
    friend class QCoreApplicationPrivate;
    friend class QWidget;
    friend class QAccessibleWidget;
    friend class QThreadData;
private:
    Q_DISABLE_COPY(QObject)
    Q_PRIVATE_SLOT(d_func(), void _q_reregisterTimers(void *))
private:
    static QMetaObject::Connection connectImpl(const QObject *sender, void **signal,
                                               const QObject *receiver, void **slotPtr,
                                               QtPrivate::QSlotObjectBase *slot, Qt::ConnectionType type,
                                               const int *types, const QMetaObject *senderMetaObject);
    static bool disconnectImpl(const QObject *sender, void **signal, const QObject *receiver, void **slot,
                               const QMetaObject *senderMetaObject);
};</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/beff866e1f930d20180fb926b3834584/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">chatgpt赋能python：Python中的取除数函数：divmod()</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/77629190b0741c048a703ea5f4e0745e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">svg教程-初识svg</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>