<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言实现多项式加减法(两种方法) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言实现多项式加减法(两种方法)" />
<meta property="og:description" content="多项式的每一项用一个结构体存储 在这里主要介绍两种方法实现加减法 (有什么建议想法 评论哦)
第一种方法是将f2多项式中的每一项分别和f1中的每一项比对 如果f1中有和f2当前一项指数相同的项 将系数相加 如果没有 将这一项插入到f1的最前面 继续判断f2的下一项
void addPolyn(Test *f1,Test *f2) { //f1 f2为两个多项式链表 含头结点 head = f1;p = f1-&gt;next; q = f2-&gt;next; while (q!=NULL) { p = f1-&gt;next;	//每次都将指针指向A的第一项 int flag = 0;	//B多项式每后移一项都赋flag为0 while (p!=NULL){ if (p-&gt;expn==q-&gt;expn) { flag = 1;	//做为后面是插入还是系数相加的判断条件 s = p;	//多项式A里面要是有与当前多项是B中的一个指数相同的话 用s保存下来 } p = p-&gt;next; } if (flag == 1) {	//如果A中存在与B中当前一项系数相同的项 s-&gt;coef = s-&gt;coef &#43; q-&gt;coef;	//将相同系数的项指数相加 } else {	//如果不存在 r = (Test *)malloc(length);	//将当前项复制到一块新的结构体中 r-&gt;coef = q-&gt;coef; r-&gt;expn = q-&gt;expn; r-&gt;next = head-&gt;next;	//将B当前项插入A中 head-&gt;next = r; } q = q-&gt;next;	//进行B的下一项的判断	} ListSort(f1);//输入随机 有序无序都可以 } 第二种方法是先将两个多项式合并 然后排序 将指数相同的项的系数相加至它的前一项 然后跳过该节点 （本来想将无序链表直接实现删除多余项 但是出了点bug 暂时不好解决^-^）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a9bf0d73843e99bbc149ac41dab0bcd1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-17T21:26:11+08:00" />
<meta property="article:modified_time" content="2018-11-17T21:26:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言实现多项式加减法(两种方法)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>多项式的每一项用一个结构体存储    在这里主要介绍两种方法实现加减法  (<span style="color:#f33b45;">有什么建议想法 评论哦</span>)</p> 
</blockquote> 
<blockquote> 
 <p> 第一种方法是将f2多项式中的每一项分别和f1中的每一项比对      如果f1中有和f2当前一项指数相同的项    将系数相加    如果没有    将这一项插入到f1的最前面     继续判断f2的下一项</p> 
</blockquote> 
<pre class="has"><code>void addPolyn(Test *f1,Test *f2) {        //f1 f2为两个多项式链表  含头结点
	head = f1;p = f1-&gt;next; q = f2-&gt;next;
	while (q!=NULL) {
		p = f1-&gt;next;		//每次都将指针指向A的第一项
		int flag = 0;		//B多项式每后移一项都赋flag为0
		while (p!=NULL){
			if (p-&gt;expn==q-&gt;expn) {
				flag = 1;		//做为后面是插入还是系数相加的判断条件
				s = p;		//多项式A里面要是有与当前多项是B中的一个指数相同的话  用s保存下来
			}
			p = p-&gt;next;
		}
		if (flag == 1) {		//如果A中存在与B中当前一项系数相同的项
			s-&gt;coef = s-&gt;coef + q-&gt;coef;		//将相同系数的项指数相加
		}
		else {		//如果不存在
			r = (Test *)malloc(length);		//将当前项复制到一块新的结构体中
			r-&gt;coef = q-&gt;coef;
			r-&gt;expn = q-&gt;expn;

			r-&gt;next = head-&gt;next;		//将B当前项插入A中
			head-&gt;next = r;
		}
		q = q-&gt;next;		//进行B的下一项的判断	
	}

	ListSort(f1);//输入随机  有序无序都可以
}</code></pre> 
<blockquote> 
 <p>第二种方法是先将两个多项式合并      然后排序    将指数相同的项的系数相加至它的前一项    然后跳过该节点    （本来想将无序链表直接实现删除多余项   但是出了点bug   暂时不好解决^-^）</p> 
</blockquote> 
<pre class="has"><code>void addPolyn1(Test *f1, Test *f2) {
	head = mergeList(f1, f2);		//连接链表
	ListSort(head);		//从小到大排序
	p = head-&gt;next;		//从头结点后的项开始
	q = p;
	while (p-&gt;next!=NULL) {
		q = p;		//每一次都是两个挨着的项进行判断
		if (p-&gt;expn==q-&gt;next-&gt;expn) {		//如果该项和后一项指数值相等
			p-&gt;coef = p-&gt;coef + q-&gt;next-&gt;coef;		//系数相加

			r = q-&gt;next;		//用一个指针指向后面的一项 
			p-&gt;next = r-&gt;next;		//跨过后面的一项
		}
		else {
			p = p-&gt;next;	//如果该项和后面一项指数不相等  将指针后移一位  继续判断
		}
	}
}</code></pre> 
<blockquote> 
 <p>减法和加法的思路一样    先将后一个链表的系数全变为负的   在进行相加 </p> 
</blockquote> 
<pre class="has"><code>void subPolyn(Test *f1,Test *f2) {
	p = f1-&gt;next; q = f2-&gt;next;
	while (q!= NULL) {		//将B中的每一项的系数变为负的
		q-&gt;coef=-q-&gt;coef;
		q = q-&gt;next;
	}
	addPolyn(f1, f2);		//再进行相加
}

void subPolyn1(Test *f1,Test *f2) {
	p = f1-&gt;next; q = f2-&gt;next;
	while (q != NULL) {		//将B中的每一项的系数变为负的
		q-&gt;coef = -q-&gt;coef;
		q = q-&gt;next;
	}

	addPolyn1(f1, f2);
}</code></pre> 
<blockquote> 
 <p> 最后附上整段代码</p> 
</blockquote> 
<pre class="has"><code>// 稀疏多项式加减.cpp: 定义控制台应用程序的入口点。

#include "stdafx.h"
#include&lt;stdlib.h&gt;
#define length sizeof(struct node)

typedef struct node
{
	float coef;		//系数
	int expn;	//指数
	struct node *next;
} Test;

Test *head, *p, *q, *r,*s;//定义遍历指针

					   //带有头结点的链表
Test *Create()//这是一个具有头结点的链表
{
	int List_Size;
	head = (Test *)malloc(length);	//首先创建一个头结点
	p = head;	//用遍历指针先指向头结点
	p-&gt;next = (Test *)malloc(length);
	p = p-&gt;next;
	printf("请输入多项式的长度:");
	scanf("%d", &amp;List_Size);

	if (List_Size&gt;0)
	{
		for (int i = 1; i&lt;List_Size; i++)
		{
			p-&gt;next = (Test *)malloc(length);
			p = p-&gt;next;
		}
		p-&gt;next = NULL;
		return head;
	}
	else
	{
		printf("链表的长度必须大于0\n");
	}
	return head;
}

void InitList(Test *List_Head)//初始化链表
{
	if (List_Head-&gt;next != NULL)
	{
		p = List_Head-&gt;next;
		while (p != NULL)
		{
			printf("请输入系数,指数:");
			scanf("%f,%d", &amp;p-&gt;coef,&amp;p-&gt;expn);		
			p = p-&gt;next;
		}
	}
	else
	{
		printf("链表为空,无法初始化\n");
	}
}

int ListLength(Test *List_Head)
{
	int List_Length = 0;
	if (List_Head-&gt;next != NULL)
	{
		p = List_Head-&gt;next;
		while (p != NULL)
		{
			if (p-&gt;coef != 0) {
				List_Length++;
			}		//系数不等于0   长度+1
			p = p-&gt;next;
		}
	}
	else
	{
		printf("链表为空,长度为0");
	}
	return List_Length;
}

void ListSort(Test *List_Head)//排序  由小到大  
{
	if (List_Head-&gt;next != NULL)
	{
		q = p = List_Head-&gt;next;//指向头结点后的第一个结点
		int temp; float temp1;
		while (q-&gt;next != NULL)
		{
			while (p-&gt;next != NULL)
			{
				p = p-&gt;next;
				if (q-&gt;expn &gt; p-&gt;expn)
				{
					temp = q-&gt;expn;
					q-&gt;expn = p-&gt;expn;
					p-&gt;expn = temp;		//交换系数

					temp1 = q-&gt;coef;
					q-&gt;coef = p-&gt;coef;
					p-&gt;coef = temp1;		//交换指数
				}
			}//循环一次  最小的被交换到前面
			q = q-&gt;next;//指针向后推一个   继续排后面的
			p = q;
		}
	}
	else
	{
		printf("链表为空,无法排序");
	}
}
void Display(Test *List_Head)
{
	if (List_Head-&gt;next != NULL)
	{

		int List_Length;
		List_Length = ListLength(List_Head);//得到多项式的长度

		printf("F=");
		p = List_Head-&gt;next;
		
		
		while (p != NULL)
		{
			if (List_Length == 0) {		//如果多项式长度为零  输出0  跳出循环
				printf("0");
				break;
			}
			if (p-&gt;coef == 0) {
				p = p-&gt;next;
				continue;
			}		//如果系数为0不输出  跳到下一个
			if (p-&gt;coef&lt;0) {
				printf("(%2.2fX^%d)", p-&gt;coef, p-&gt;expn);
			}
			else {
				printf("%2.2fX^%d", p-&gt;coef, p-&gt;expn);
			}
			if (p-&gt;next != NULL) {
				printf("+");
			}		//是最后一个的话就不输出+
			p = p-&gt;next;
		}
		printf("\n");
	}
	else
	{
		printf("链表为空,无法展示\n");
	}

	printf("\n");
}

Test *mergeList(Test *f1, Test *f2) {
	p = f1-&gt;next; q = f2-&gt;next;
	while (p-&gt;next!= NULL) {
		p = p-&gt;next;
	}
	p-&gt;next = q;
	head = f1;
	return head;
}

void addPolyn(Test *f1,Test *f2) {
	head = f1;p = f1-&gt;next; q = f2-&gt;next;
	while (q!=NULL) {
		p = f1-&gt;next;		//每次都将指针指向A的第一项
		int flag = 0;		//B多项式每后移一项都赋flag为0
		while (p!=NULL){
			if (p-&gt;expn==q-&gt;expn) {
				flag = 1;		//做为后面是插入还是系数相加的判断条件
				s = p;		//多项式A里面要是有与当前多项是B中的一个指数相同的话  用s保存下来
			}
			p = p-&gt;next;
		}
		if (flag == 1) {		//如果A中存在与B中当前一项系数相同的项
			s-&gt;coef = s-&gt;coef + q-&gt;coef;		//将相同系数的项指数相加
		}
		else {		//如果不存在
			r = (Test *)malloc(length);		//将当前项复制到一块新的结构体中
			r-&gt;coef = q-&gt;coef;
			r-&gt;expn = q-&gt;expn;

			r-&gt;next = head-&gt;next;		//将B当前项插入A中
			head-&gt;next = r;
		}
		q = q-&gt;next;		//进行B的下一项的判断	
	}

	ListSort(f1);//输入随机  有序无序都可以
}

void addPolyn1(Test *f1, Test *f2) {
	head = mergeList(f1, f2);		//连接链表
	ListSort(head);		//从小到大排序
	p = head-&gt;next;		//从头结点后的项开始
	q = p;
	while (p-&gt;next!=NULL) {
		q = p;		//每一次都是两个挨着的项进行判断
		if (p-&gt;expn==q-&gt;next-&gt;expn) {		//如果该项和后一项指数值相等
			p-&gt;coef = p-&gt;coef + q-&gt;next-&gt;coef;		//系数相加

			r = q-&gt;next;		//用一个指针指向后面的一项 
			p-&gt;next = r-&gt;next;		//跨过后面的一项
		}
		else {
			p = p-&gt;next;	//如果该项和后面一项指数不相等  将指针后移一位  继续判断
		}
	}
}

void subPolyn(Test *f1,Test *f2) {
	p = f1-&gt;next; q = f2-&gt;next;
	while (q!= NULL) {		//将B中的每一项的系数变为负的
		q-&gt;coef=-q-&gt;coef;
		q = q-&gt;next;
	}
	addPolyn(f1, f2);		//再进行相加
}

void subPolyn1(Test *f1,Test *f2) {
	p = f1-&gt;next; q = f2-&gt;next;
	while (q != NULL) {		//将B中的每一项的系数变为负的
		q-&gt;coef = -q-&gt;coef;
		q = q-&gt;next;
	}

	addPolyn1(f1, f2);
}

int main()
{
	Test *List_A, *List_B;
	List_A = Create();
	InitList(List_A);
	Display(List_A);
	
	List_B = Create();
	InitList(List_B);
	Display(List_B);
	
	addPolyn(List_A,List_B);
	//addPolyn1(List_A, List_B);
	//subPolyn(List_A, List_B);
	//subPolyn1(List_A, List_B);
	Display(List_A);
}

</code></pre> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56d2065766edd7f62a806981c6f46067/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL实战 -- 一条SQL更新语句是如何执行的？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f7cdd7663c9a5631e403011b9fd950c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图像处理之特征提取-ORP特征匹配</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>