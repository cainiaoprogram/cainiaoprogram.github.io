<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ESP32系列--第九篇 ADC的使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ESP32系列--第九篇 ADC的使用" />
<meta property="og:description" content="一、目的 本篇主要介绍ESP32的ADC功能，ESP32有两个ADC模块，分别为ADC1/ADC2，每个ESP32系列具有的通道数不一样，详情请看下表。
在WiFi在使用时，ADC2的使用受到一些限制，实际应用场景中一般只使用ADC1即可。
二、介绍 ADC的IO引脚分配 ESP32系列 （下表来自ESP-IDF开发文档）
GPIO
Analog Function
RTC GPIO
Comments
GPIO0
ADC2_CH1
RTC_GPIO11
Strapping pin
GPIO1
TXD
GPIO2
ADC2_CH2
RTC_GPIO12
Strapping pin
GPIO3
RXD
GPIO4
ADC2_CH0
RTC_GPIO10
GPIO5
Strapping pin
GPIO6
SPI0/1
GPIO7
SPI0/1
GPIO8
SPI0/1
GPIO9
SPI0/1
GPIO10
SPI0/1
GPIO11
SPI0/1
GPIO12
ADC2_CH5
RTC_GPIO15
Strapping pin; JTAG
GPIO13
ADC2_CH4
RTC_GPIO14
JTAG
GPIO14
ADC2_CH6
RTC_GPIO16
JTAG
GPIO15
ADC2_CH3
RTC_GPIO13
Strapping pin; JTAG
GPIO16
SPI0/1
GPIO17
SPI0/1" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3d4c20b45ac514e58995ba02c12ca68d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-05T10:07:48+08:00" />
<meta property="article:modified_time" content="2022-07-05T10:07:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ESP32系列--第九篇 ADC的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、目的</h2> 
<p>        本篇主要介绍ESP32的ADC功能，ESP32有两个ADC模块，分别为ADC1/ADC2，每个ESP32系列具有的通道数不一样，详情请看下表。</p> 
<p>        在WiFi在使用时，ADC2的使用受到一些限制，实际应用场景中一般只使用ADC1即可。</p> 
<h2>二、介绍</h2> 
<h4>ADC的IO引脚分配</h4> 
<p>ESP32系列 （下表来自<a class="link-info" href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/gpio.html" rel="nofollow" title="ESP-IDF">ESP-IDF</a>开发文档）</p> 
<table><thead><tr><th> <p>GPIO</p> </th><th> <p>Analog Function</p> </th><th> <p>RTC GPIO</p> </th><th> <p>Comments</p> </th></tr></thead><tbody><tr><td> <p>GPIO0</p> </td><td> <p>ADC2_CH1</p> </td><td> <p>RTC_GPIO11</p> </td><td> <p>Strapping pin</p> </td></tr><tr><td> <p>GPIO1</p> </td><td></td><td></td><td> <p>TXD</p> </td></tr><tr><td> <p>GPIO2</p> </td><td> <p>ADC2_CH2</p> </td><td> <p>RTC_GPIO12</p> </td><td> <p>Strapping pin</p> </td></tr><tr><td> <p>GPIO3</p> </td><td></td><td></td><td> <p>RXD</p> </td></tr><tr><td> <p>GPIO4</p> </td><td> <p>ADC2_CH0</p> </td><td> <p>RTC_GPIO10</p> </td><td></td></tr><tr><td> <p>GPIO5</p> </td><td></td><td></td><td> <p>Strapping pin</p> </td></tr><tr><td> <p>GPIO6</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO7</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO8</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO9</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO10</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO11</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO12</p> </td><td> <p>ADC2_CH5</p> </td><td> <p>RTC_GPIO15</p> </td><td> <p>Strapping pin; JTAG</p> </td></tr><tr><td> <p>GPIO13</p> </td><td> <p>ADC2_CH4</p> </td><td> <p>RTC_GPIO14</p> </td><td> <p>JTAG</p> </td></tr><tr><td> <p>GPIO14</p> </td><td> <p>ADC2_CH6</p> </td><td> <p>RTC_GPIO16</p> </td><td> <p>JTAG</p> </td></tr><tr><td> <p>GPIO15</p> </td><td> <p>ADC2_CH3</p> </td><td> <p>RTC_GPIO13</p> </td><td> <p>Strapping pin; JTAG</p> </td></tr><tr><td> <p>GPIO16</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO17</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO18</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO19</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO21</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO22</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO23</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO25</p> </td><td> <p>ADC2_CH8</p> </td><td> <p>RTC_GPIO6</p> </td><td></td></tr><tr><td> <p>GPIO26</p> </td><td> <p>ADC2_CH9</p> </td><td> <p>RTC_GPIO7</p> </td><td></td></tr><tr><td> <p>GPIO27</p> </td><td> <p>ADC2_CH7</p> </td><td> <p>RTC_GPIO17</p> </td><td></td></tr><tr><td> <p>GPIO32</p> </td><td> <p>ADC1_CH4</p> </td><td> <p>RTC_GPIO9</p> </td><td></td></tr><tr><td> <p>GPIO33</p> </td><td> <p>ADC1_CH5</p> </td><td> <p>RTC_GPIO8</p> </td><td></td></tr><tr><td> <p>GPIO34</p> </td><td> <p>ADC1_CH6</p> </td><td> <p>RTC_GPIO4</p> </td><td> <p>GPI</p> </td></tr><tr><td> <p>GPIO35</p> </td><td> <p>ADC1_CH7</p> </td><td> <p>RTC_GPIO5</p> </td><td> <p>GPI</p> </td></tr><tr><td> <p>GPIO36</p> </td><td> <p>ADC1_CH0</p> </td><td> <p>RTC_GPIO0</p> </td><td> <p>GPI</p> </td></tr><tr><td> <p>GPIO37</p> </td><td> <p>ADC1_CH1</p> </td><td> <p>RTC_GPIO1</p> </td><td> <p>GPI</p> </td></tr><tr><td> <p>GPIO38</p> </td><td> <p>ADC1_CH2</p> </td><td> <p>RTC_GPIO2</p> </td><td> <p>GPI</p> </td></tr><tr><td> <p>GPIO39</p> </td><td> <p>ADC1_CH3</p> </td><td> <p>RTC_GPIO3</p> </td><td> <p>GPI</p> </td></tr></tbody></table> 
<p>        从上表我们可以看到ADC1可以使用的IO引脚为GPIO32-GPIO39总共8个通道。</p> 
<p>ESP32S2系列 （下表来自<a class="link-info" href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32s2/api-reference/peripherals/adc.html" rel="nofollow" title="ESP-IDF">ESP-IDF</a>开发文档）</p> 
<table><thead><tr><th> <p>GPIO</p> </th><th> <p>Analog Function</p> </th><th> <p>RTC GPIO</p> </th><th> <p>Comment</p> </th></tr></thead><tbody><tr><td> <p>GPIO0</p> </td><td></td><td> <p>RTC_GPIO0</p> </td><td> <p>Strapping pin</p> </td></tr><tr><td> <p>GPIO1</p> </td><td> <p>ADC1_CH0</p> </td><td> <p>RTC_GPIO1</p> </td><td></td></tr><tr><td> <p>GPIO2</p> </td><td> <p>ADC1_CH1</p> </td><td> <p>RTC_GPIO2</p> </td><td></td></tr><tr><td> <p>GPIO3</p> </td><td> <p>ADC1_CH2</p> </td><td> <p>RTC_GPIO3</p> </td><td></td></tr><tr><td> <p>GPIO4</p> </td><td> <p>ADC1_CH3</p> </td><td> <p>RTC_GPIO4</p> </td><td></td></tr><tr><td> <p>GPIO5</p> </td><td> <p>ADC1_CH4</p> </td><td> <p>RTC_GPIO5</p> </td><td></td></tr><tr><td> <p>GPIO6</p> </td><td> <p>ADC1_CH5</p> </td><td> <p>RTC_GPIO6</p> </td><td></td></tr><tr><td> <p>GPIO7</p> </td><td> <p>ADC1_CH6</p> </td><td> <p>RTC_GPIO7</p> </td><td></td></tr><tr><td> <p>GPIO8</p> </td><td> <p>ADC1_CH7</p> </td><td> <p>RTC_GPIO8</p> </td><td></td></tr><tr><td> <p>GPIO9</p> </td><td> <p>ADC1_CH8</p> </td><td> <p>RTC_GPIO9</p> </td><td></td></tr><tr><td> <p>GPIO10</p> </td><td> <p>ADC1_CH9</p> </td><td> <p>RTC_GPIO10</p> </td><td></td></tr><tr><td> <p>GPIO11</p> </td><td> <p>ADC2_CH0</p> </td><td> <p>RTC_GPIO11</p> </td><td></td></tr><tr><td> <p>GPIO12</p> </td><td> <p>ADC2_CH1</p> </td><td> <p>RTC_GPIO12</p> </td><td></td></tr><tr><td> <p>GPIO13</p> </td><td> <p>ADC2_CH2</p> </td><td> <p>RTC_GPIO13</p> </td><td></td></tr><tr><td> <p>GPIO14</p> </td><td> <p>ADC2_CH3</p> </td><td> <p>RTC_GPIO14</p> </td><td></td></tr><tr><td> <p>GPIO15</p> </td><td> <p>ADC2_CH4</p> </td><td> <p>RTC_GPIO15</p> </td><td></td></tr><tr><td> <p>GPIO16</p> </td><td> <p>ADC2_CH5</p> </td><td> <p>RTC_GPIO16</p> </td><td></td></tr><tr><td> <p>GPIO17</p> </td><td> <p>ADC2_CH6</p> </td><td> <p>RTC_GPIO17</p> </td><td></td></tr><tr><td> <p>GPIO18</p> </td><td> <p>ADC2_CH7</p> </td><td> <p>RTC_GPIO18</p> </td><td></td></tr><tr><td> <p>GPIO19</p> </td><td> <p>ADC2_CH8</p> </td><td> <p>RTC_GPIO19</p> </td><td></td></tr><tr><td> <p>GPIO20</p> </td><td> <p>ADC2_CH9</p> </td><td> <p>RTC_GPIO20</p> </td><td></td></tr><tr><td> <p>GPIO21</p> </td><td></td><td> <p>RTC_GPIO21</p> </td><td></td></tr><tr><td> <p>GPIO26</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO27</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO28</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO29</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO30</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO31</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO32</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO33</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO34</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO35</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO36</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO37</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO38</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO39</p> </td><td></td><td></td><td> <p>JTAG</p> </td></tr><tr><td> <p>GPIO40</p> </td><td></td><td></td><td> <p>JTAG</p> </td></tr><tr><td> <p>GPIO41</p> </td><td></td><td></td><td> <p>JTAG</p> </td></tr><tr><td> <p>GPIO42</p> </td><td></td><td></td><td> <p>JTAG</p> </td></tr><tr><td> <p>GPIO43</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO44</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO45</p> </td><td></td><td></td><td> <p>Strapping pin</p> </td></tr><tr><td> <p>GPIO46</p> </td><td></td><td></td><td> <p>GPI；Strapping pin</p> </td></tr></tbody></table> 
<p>        从上表我们可以看到ADC1可以使用的IO引脚为GPIO1-GPIO10总共10个通道。</p> 
<p>ESP32S3系列 （下表来自<a class="link-info" href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/api-reference/peripherals/gpio.html" rel="nofollow" title="ESP-IDF">ESP-IDF</a>​​​​​​​开发文档）</p> 
<table><thead><tr><th> <p>GPIO</p> </th><th> <p>Analog Function</p> </th><th> <p>RTC GPIO</p> </th><th> <p>Comment</p> </th></tr></thead><tbody><tr><td> <p>GPIO0</p> </td><td></td><td> <p>RTC_GPIO0</p> </td><td> <p>Strapping pin</p> </td></tr><tr><td> <p>GPIO1</p> </td><td> <p>ADC1_CH0</p> </td><td> <p>RTC_GPIO1</p> </td><td></td></tr><tr><td> <p>GPIO2</p> </td><td> <p>ADC1_CH1</p> </td><td> <p>RTC_GPIO2</p> </td><td></td></tr><tr><td> <p>GPIO3</p> </td><td> <p>ADC1_CH2</p> </td><td> <p>RTC_GPIO3</p> </td><td> <p>Strapping pin</p> </td></tr><tr><td> <p>GPIO4</p> </td><td> <p>ADC1_CH3</p> </td><td> <p>RTC_GPIO4</p> </td><td></td></tr><tr><td> <p>GPIO5</p> </td><td> <p>ADC1_CH4</p> </td><td> <p>RTC_GPIO5</p> </td><td></td></tr><tr><td> <p>GPIO6</p> </td><td> <p>ADC1_CH5</p> </td><td> <p>RTC_GPIO6</p> </td><td></td></tr><tr><td> <p>GPIO7</p> </td><td> <p>ADC1_CH6</p> </td><td> <p>RTC_GPIO7</p> </td><td></td></tr><tr><td> <p>GPIO8</p> </td><td> <p>ADC1_CH7</p> </td><td> <p>RTC_GPIO8</p> </td><td></td></tr><tr><td> <p>GPIO9</p> </td><td> <p>ADC1_CH8</p> </td><td> <p>RTC_GPIO9</p> </td><td></td></tr><tr><td> <p>GPIO10</p> </td><td> <p>ADC1_CH9</p> </td><td> <p>RTC_GPIO10</p> </td><td></td></tr><tr><td> <p>GPIO11</p> </td><td> <p>ADC2_CH0</p> </td><td> <p>RTC_GPIO11</p> </td><td></td></tr><tr><td> <p>GPIO12</p> </td><td> <p>ADC2_CH1</p> </td><td> <p>RTC_GPIO12</p> </td><td></td></tr><tr><td> <p>GPIO13</p> </td><td> <p>ADC2_CH2</p> </td><td> <p>RTC_GPIO13</p> </td><td></td></tr><tr><td> <p>GPIO14</p> </td><td> <p>ADC2_CH3</p> </td><td> <p>RTC_GPIO14</p> </td><td></td></tr><tr><td> <p>GPIO15</p> </td><td> <p>ADC2_CH4</p> </td><td> <p>RTC_GPIO15</p> </td><td></td></tr><tr><td> <p>GPIO16</p> </td><td> <p>ADC2_CH5</p> </td><td> <p>RTC_GPIO16</p> </td><td></td></tr><tr><td> <p>GPIO17</p> </td><td> <p>ADC2_CH6</p> </td><td> <p>RTC_GPIO17</p> </td><td></td></tr><tr><td> <p>GPIO18</p> </td><td> <p>ADC2_CH7</p> </td><td> <p>RTC_GPIO18</p> </td><td></td></tr><tr><td> <p>GPIO19</p> </td><td> <p>ADC2_CH8</p> </td><td> <p>RTC_GPIO19</p> </td><td> <p>USB-JTAG</p> </td></tr><tr><td> <p>GPIO20</p> </td><td> <p>ADC2_CH9</p> </td><td> <p>RTC_GPIO20</p> </td><td> <p>USB-JTAG</p> </td></tr><tr><td> <p>GPIO21</p> </td><td></td><td> <p>RTC_GPIO21</p> </td><td></td></tr><tr><td> <p>GPIO26</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO27</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO28</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO29</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO30</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO31</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO32</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO33</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO34</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO35</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO36</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO37</p> </td><td></td><td></td><td> <p>SPI0/1</p> </td></tr><tr><td> <p>GPIO38</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO39</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO40</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO41</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO42</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO43</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO44</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO45</p> </td><td></td><td></td><td> <p>Strapping pin</p> </td></tr><tr><td> <p>GPIO46</p> </td><td></td><td></td><td> <p>Strapping pin</p> </td></tr><tr><td> <p>GPIO47</p> </td><td></td><td></td><td></td></tr><tr><td> <p>GPIO48</p> </td><td></td><td></td></tr></tbody></table> 
<p>        从上表我们可以看到ADC1可以使用的IO引脚为GPIO1-GPIO10总共10个通道。</p> 
<h4>ADC的参考电压</h4> 
<p>        ESP32默认的参考电压是1.1V（每个芯片间有差异，非精准），所以只能测量0-1.1V的电压；</p> 
<h4>ADC的量程设置</h4> 
<p>        为了能够测量更大量程的电压，需要使用其衰减配置；每个通道都可以单独配置</p> 
<pre><code class="language-cpp">/**
 * @brief ADC attenuation parameter. Different parameters determine the range of the ADC. See ``adc1_config_channel_atten``.
 */
typedef enum {
    ADC_ATTEN_DB_0   = 0,  ///&lt;No input attenumation, ADC can measure up to approx. 800 mV
    ADC_ATTEN_DB_2_5 = 1,  ///&lt;The input voltage of ADC will be attenuated extending the range of measurement by about 2.5 dB (1.33 x)
    ADC_ATTEN_DB_6   = 2,  ///&lt;The input voltage of ADC will be attenuated extending the range of measurement by about 6 dB (2 x)
    ADC_ATTEN_DB_11  = 3,  ///&lt;The input voltage of ADC will be attenuated extending the range of measurement by about 11 dB (3.55 x)
} adc_atten_t;</code></pre> 
<p>        每个配置推荐的输入范围</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5f/0c/RGZ68B46_o.png">​​​​​​​</p> 
<p> </p> 
<h4>ADC最小化噪声</h4> 
<p>        1.在输入引脚接一个100nF的陶瓷电容</p> 
<p>        2.多次采样取平均</p> 
<h4>ADC的校准方式</h4> 
<p>        不同芯片的参考电压不一样（1000mV - 1200mV），所以建议进行硬件校准</p> 
<pre><code class="language-cpp">/**
 * @brief Type of calibration value used in characterization
 */
typedef enum {
    ESP_ADC_CAL_VAL_EFUSE_VREF = 0,         /**&lt; Characterization based on reference voltage stored in eFuse*/
    ESP_ADC_CAL_VAL_EFUSE_TP = 1,           /**&lt; Characterization based on Two Point values stored in eFuse*/
    ESP_ADC_CAL_VAL_DEFAULT_VREF = 2,       /**&lt; Characterization based on default reference voltage*/
    ESP_ADC_CAL_VAL_EFUSE_TP_FIT = 3,       /**&lt; Characterization based on Two Point values and fitting curve coefficients stored in eFuse */
    ESP_ADC_CAL_VAL_MAX,
    ESP_ADC_CAL_VAL_NOT_SUPPORTED = ESP_ADC_CAL_VAL_MAX,
} esp_adc_cal_value_t;</code></pre> 
<p>        ESP32支持ESP_ADC_CAL_VAL_EFUSE_TP/ESP_ADC_CAL_VAL_EFUSE_VREF</p> 
<p>        ESP32S2支持ESP_ADC_CAL_VAL_EFUSE_TP</p> 
<p>        ESP32S3支持ESP_ADC_CAL_VAL_EFUSE_TP_FIT</p> 
<p></p> 
<p>        ESP_ADC_CAL_VAL_EFUSE_TP根据EFUSE里面两个采样值进行校准（150mV/850mV）</p> 
<p>        ESP_ADC_CAL_VAL_EFUSE_VREF根据EFUSE里面的参考电压校准</p> 
<p>        ESP_ADC_CAL_VAL_EFUSE_TP_FIT根据EFUSE里面两个采样点和特性曲线校准</p> 
<p>        有些ESP32模组出厂时已经做了校准，我们可以通过工具查看</p> 
<h4>ADC相关的efuse设置        </h4> 
<pre><code class="language-bash">$espefuse.py -p /dev/cu.SLAB_USBtoUART adc_info
Connecting......
Detecting chip type... Unsupported detection protocol, switching and trying again...
Connecting......
Detecting chip type... ESP32
espefuse.py v4.1

=== Run "adc_info" command ===
ADC VRef calibration: 1128mV</code></pre> 
<p>        通过espefuse.py adc_info命令我们可以看到我的ESP32模组默认支持VRef校验。</p> 
<p>        如果不支持VRef校准输出如下</p> 
<pre><code class="language-bash">ADC VRef calibration: None (1100 mV nominal)</code></pre> 
<p>         如果支持两点校准，输出如下</p> 
<pre><code class="language-bash">ADC VRef calibration: 1149 mV
ADC readings stored in efuse BLK3:
    ADC1 Low reading  (150 mV): 306
    ADC1 High reading (850 mV): 3153
    ADC2 Low reading  (150 mV): 389
    ADC2 High reading (850 mV): 3206</code></pre> 
<h2>三、实战</h2> 
<h4>        接口说明</h4> 
<p>        1.检查是否支持指定的校准方式</p> 
<p>        esp_err_t esp_adc_cal_check_efuse(esp_adc_cal_value_t value_type);</p> 
<p>        2.设置采样量化位数</p> 
<p>        esp_err_t adc1_config_width(adc_bits_width_t width_bit);</p> 
<p>        3.设置指定通道的衰减</p> 
<p>        esp_err_t adc1_config_channel_atten(adc1_channel_t channel, adc_atten_t atten);</p> 
<p>        4.获取指定通道校准特征值</p> 
<p>        esp_adc_cal_value_t esp_adc_cal_characterize(adc_unit_t adc_num,<br>                                              adc_atten_t atten,<br>                                              adc_bits_width_t bit_width,<br>                                              uint32_t default_vref,<br>                                              esp_adc_cal_characteristics_t *chars);</p> 
<p>        5.获取指定通道的采样值</p> 
<p>        int adc1_get_raw(adc1_channel_t channel);</p> 
<p>        6.根据校准特征值获取实际电压值</p> 
<p>        uint32_t esp_adc_cal_raw_to_voltage(uint32_t adc_reading, const esp_adc_cal_characteristics_t *chars);</p> 
<p></p> 
<h4>        参考代码</h4> 
<pre><code class="language-cpp">/* ADC1 Example

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "driver/adc.h"
#include "esp_adc_cal.h"

#define DEFAULT_VREF    1100        //Use adc2_vref_to_gpio() to obtain a better estimate
#define NO_OF_SAMPLES   64          //Multisampling

static esp_adc_cal_characteristics_t *adc_chars;
#if CONFIG_IDF_TARGET_ESP32
static const adc_channel_t channel = ADC_CHANNEL_6;     //GPIO34 if ADC1, GPIO14 if ADC2
static const adc_bits_width_t width = ADC_WIDTH_BIT_12;
#elif CONFIG_IDF_TARGET_ESP32S2
static const adc_channel_t channel = ADC_CHANNEL_6;     // GPIO7 if ADC1, GPIO17 if ADC2
static const adc_bits_width_t width = ADC_WIDTH_BIT_13;
#endif
static const adc_atten_t atten = ADC_ATTEN_DB_0;
static const adc_unit_t unit = ADC_UNIT_1;


static void check_efuse(void)
{
#if CONFIG_IDF_TARGET_ESP32
    //Check if TP is burned into eFuse
    if (esp_adc_cal_check_efuse(ESP_ADC_CAL_VAL_EFUSE_TP) == ESP_OK) {
        printf("eFuse Two Point: Supported\n");
    } else {
        printf("eFuse Two Point: NOT supported\n");
    }
    //Check Vref is burned into eFuse
    if (esp_adc_cal_check_efuse(ESP_ADC_CAL_VAL_EFUSE_VREF) == ESP_OK) {
        printf("eFuse Vref: Supported\n");
    } else {
        printf("eFuse Vref: NOT supported\n");
    }
#elif CONFIG_IDF_TARGET_ESP32S2
    if (esp_adc_cal_check_efuse(ESP_ADC_CAL_VAL_EFUSE_TP) == ESP_OK) {
        printf("eFuse Two Point: Supported\n");
    } else {
        printf("Cannot retrieve eFuse Two Point calibration values. Default calibration values will be used.\n");
    }
#else
#error "This example is configured for ESP32/ESP32S2."
#endif
}


static void print_char_val_type(esp_adc_cal_value_t val_type)
{
    if (val_type == ESP_ADC_CAL_VAL_EFUSE_TP) {
        printf("Characterized using Two Point Value\n");
    } else if (val_type == ESP_ADC_CAL_VAL_EFUSE_VREF) {
        printf("Characterized using eFuse Vref\n");
    } else {
        printf("Characterized using Default Vref\n");
    }
}


void app_main(void)
{
    //Check if Two Point or Vref are burned into eFuse
    check_efuse();

    //Configure ADC
    if (unit == ADC_UNIT_1) {
        adc1_config_width(width);
        adc1_config_channel_atten(channel, atten);
    } else {
        adc2_config_channel_atten((adc2_channel_t)channel, atten);
    }

    //Characterize ADC
    adc_chars = calloc(1, sizeof(esp_adc_cal_characteristics_t));
    esp_adc_cal_value_t val_type = esp_adc_cal_characterize(unit, atten, width, DEFAULT_VREF, adc_chars);
    print_char_val_type(val_type);

    //Continuously sample ADC1
    while (1) {
        uint32_t adc_reading = 0;
        //Multisampling
        for (int i = 0; i &lt; NO_OF_SAMPLES; i++) {
            if (unit == ADC_UNIT_1) {
                adc_reading += adc1_get_raw((adc1_channel_t)channel);
            } else {
                int raw;
                adc2_get_raw((adc2_channel_t)channel, width, &amp;raw);
                adc_reading += raw;
            }
        }
        adc_reading /= NO_OF_SAMPLES;
        //Convert adc_reading to voltage in mV
        uint32_t voltage = esp_adc_cal_raw_to_voltage(adc_reading, adc_chars);
        printf("Raw: %d\tVoltage: %dmV\n", adc_reading, voltage);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}</code></pre> 
<p>以上，基本就讲完了ADC1的使用，点赞收藏不可少</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/257bd00fa3a7436c732d17c70a23a476/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">技术干货 | MindSpore AI科学计算系列（四）：AlphaFold2分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/946932b8efd68b10cda0508727ff8de7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">keras对MNIST数据集分类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>