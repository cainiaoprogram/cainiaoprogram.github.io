<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Boosting &amp; AdaBoost算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Boosting &amp; AdaBoost算法" />
<meta property="og:description" content=" 提升和自适应提升方法
Boosting &amp; AdaBoost
1 算法起源
在机器学习领域中，关键问题就是如何利用观测数据通过学习得到精确估计。但是，在实际应用领域中，构造一个高精度的估计几乎是不可能的。Boosting就给出了一个解决上述问很好的思路。Boosting是一种提高任意给定学习算法准确度的方法。它的思想起源于 valiant在1984年提出的 PAC ( Probably Approximately Correct)学习模型。Valiant和 Kearns提出了弱学习和强学习的概念 ，识别错误率略小于1/2，也即准确率仅比随机猜测略高的学习算法称为弱学习算法；识别准确率很高并能在多项式时间内完成的学习算法称为强学习算法。同时，Valiant和 Kearns首次提出了 PAC学习模型中弱学习算法和强学习算法的等价性问题，即任意给定仅比随机猜测略好的弱学习算法 ，是否可以将其提升为强学习算法？如果二者等价，那么只需找到一个比随机猜测略好的弱学习算法就可以将其提升为强学习算法，而不必寻找很难获得的强学习算法。
1990年, Schapire最先构造出一种多项式级的算法 ,对该问题做了肯定的证明，这就是最初的 Boosting算法。
一年后，Freund提出了一种效率更高的Boosting算法。但是,这两种算法存在共同的实践上的缺陷 ,那就是都要求事先知道弱学习算法学习正确的下限。1995年，Freund和Schapire改进了Boosting算法，提出了 AdaBoost (Adaptive Boosting)算法，该算法效率和 Freund于 1991年提出的 Boosting算法几乎相同，但不需要任何关于弱学习器的先验知识，因而更容易应用到实际问题当中。之后，Freund和 Schapire进一步提出了改变 Boosting投票权重的 AdaBoost . M1，AdaBoost . M2等算法 ,在机器学习领域受到了极大的关注。其实，Boosting是一种把若干个分类器整合为一个分类器的方法，在Boosting算法之前，还出现过两种比较重要的将多个分类器整合为一个分类器的方法，即boostrapping方法和bagging方法。
2 Boosting方法的基本思路
提升方法基于这样一个思想：对于一个复杂任务来说，将多个专家的判断进行适当综合所得出的判断，要比其中任何一个专家单独的判断要好。实际上，就是“三个臭皮匠顶个诸葛亮”的道理。提升方法的问题在于，在学习中，如果已经发现了弱学习算法，能否将它提升为强学习算法。因为在应用中，发现弱学习算法要比强学习算法容易得多。关于提升的策略，最具代表性是AdaBoost算法。对于分类问题，在给定的训练样本上获得一个粗糙规则（弱分类器）要比获得一个精确规则（强分类器）容易的多。提升方法就是在弱学习算法上反复学习，得到一系列的弱分类器（也叫做基本分类器），然后组合这些弱分类器，构造一个能够更加准确分类的强分类器。此时会有两个问题： 1、如何进行弱分类器的学习？
2、如何将弱分类器组合构成强分类器？ 关于第一个问题大多是的提升方法都是通过改变训练样本的概率分布（权值分布）来实现的。AdaBoost的做法是提高那些被前一轮弱分类器分类错误的样本权重，降低正确分类的样本权重。也就是说，没有正确分类的样本在下一轮的弱分类器中将会得到更大的关注。至于第二个问题Adaboost则采用的加权投票，少数服从多数的策略，也就是要增大分类错误率小的弱分类器的权值，使其在决策中起到较大作用，减小分类错误率大的弱分类器的权重，使其表决权也相对减小。 3 AdaBoost方法
3.1AdaBoost算法（二分类）
基本分类器的选择方法 在确定基本分类器时，AdaBoost通常采取的方法是遍历所有的弱分类器（或是所有的特征），求所有的弱分类器在正负样本上的错误率，将最小错误率对应的弱分类器作为本轮迭代的基本分类器。在遍历的过程要注意，弱分类器是有两个方向的，不同的方向判为正例和负例所导致的错误率也是不相同的，所以对一个弱分类器在训练样本上需要计算两次错误率，取最小值作为该弱分类器在训练集上的训练错误率。具体过程如下： 在实际的应用中由于训练的样本量巨大，如果一一比较所有样本的特征值是否过该弱分类器所设定的阈值，需要大量的计算时间，导致训练速度很慢。实际上我们采取的是这样的方法：
训练样本事先分成两类：正样本和负样本，并按照特征值从小到大进行排序。人脸检测的弱分类器（特征）的阈值选取的方法通常定义为两个样本特征值的平均数，选取最优的阈值（错误率最小的阈值）时要遍历所有的样本，由于事先已经排序，只需要计算该样前面或后面的样本个数即可。
例如，下图中为某一个特征10000正样本和1000负样本对应的特征值：
3.2AdaBoost算例
E.X.1 一个虚拟的例子
现在，在一个平面方格中10个样本，被分为两类，非别被标有“＋”和“－”，定义分类器为竖直或水平的直线。例如，一个弱分类器被定义为一条竖直的直线，该直线数据点分为左右两部分，直线左半部分判断为正样本，右半部分的样本点被判断为负样本。这10个样本点中有5个“＋”和5个“－”，如图所示
从图中不难看出，选用任何一条直线对这些点进行划分，错误都要高于30%。对于AdaBoost来说，每次循环t，假设基学习都是找到在权重 Dt下加权错误最小的基假设，从下面的计算结果可以发现AdaBoost只需要通过3步迭代（T＝3）就可以获得对样本点的完美分类。为方便记录直线分类器的符号方向，给定记号P，并且规定若P&gt;0，则直线左侧或是下侧为“&#43;”，若P&lt;0，则直线左侧或是下侧为“—”。为方便观察和计算将10个样本标记在9×9的棋盘网格中，不难理解假设空间为图中20条先构成的分类器。
则分类器分类的结果（Y表示正确分类，N表示错误分类）：
上表中计算的数值为整体四舍五入到小数点后两位。
每一次迭代获得基本分类器如下：
E.X.2一种选择弱分类器的方法
解：
在这里我们定义弱分类器由 产生，其中 是两个样本的平均数（实验中常用的一种弱分类器确定的方法）。
初始化权重分布 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f988aca93db7c600cbe55b513afe4de2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-12-29T09:06:59+08:00" />
<meta property="article:modified_time" content="2015-12-29T09:06:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Boosting &amp; AdaBoost算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p align="center"></p> 
<p align="center"></p> 
<p align="center"></p> 
<p align="center"><span style="font-family:FangSong_GB2312; font-size:18px"><strong>提升和自适应提升方法</strong></span></p> 
<p align="center"><span style="font-family:FangSong_GB2312; font-size:18px"><strong>Boosting &amp; AdaBoost</strong></span></p> 
<p align="center" style="text-align:left"><span style="font-weight:bold"><span style="font-family:FangSong_GB2312; font-size:18px">1 算法起源</span></span></p> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px">   在机器学习领域中，关键问题就是如何利用观测数据通过学习得到精确估计。但是，在实际应用领域中，构造一个高精度的估计几乎是不可能的。Boosting就给出了一个解决上述问很好的思路。Boosting是一种提高任意给定学习算法准确度的方法。它的思想起源于 valiant在1984年提出的 <strong>PAC ( Probably Approximately Correct)</strong>学习模型。Valiant和 Kearns提出了<strong>弱学习和强学习</strong>的概念 ，识别错误率略小于1/2，也即准确率仅比随机猜测略高的学习算法称为弱学习算法；识别准确率很高并能在多项式时间内完成的学习算法称为强学习算法。同时，Valiant和 Kearns首次提出了 PAC学习模型中弱学习算法和强学习算法的等价性问题，即任意给定仅比随机猜测略好的弱学习算法 ，是否可以将其提升为强学习算法？如果二者等价，那么只需找到一个比随机猜测略好的弱学习算法就可以将其提升为强学习算法，而不必寻找很难获得的强学习算法。<br>    1990年, Schapire最先构造出一种多项式级的算法 ,对该问题做了肯定的证明，这就是最初的 Boosting算法。<br> 一年后，Freund提出了一种效率更高的Boosting算法。但是,这两种算法存在共同的实践上的缺陷 ,那就是都要求事先知道弱学习算法学习正确的下限。1995年，Freund和Schapire改进了Boosting算法，提出了 AdaBoost (Adaptive Boosting)算法，该算法效率和 Freund于 1991年提出的 Boosting算法几乎相同，但不需要任何关于弱学习器的先验知识，因而更容易应用到实际问题当中。之后，Freund和 Schapire进一步提出了改变 Boosting投票权重的 AdaBoost . M1，AdaBoost . M2等算法 ,在机器学习领域受到了极大的关注。其实，Boosting是一种把若干个分类器整合为一个分类器的方法，在Boosting算法之前，还出现过两种比较重要的将多个分类器整合为一个分类器的方法，即boostrapping方法和bagging方法。<br> </span> 
</div> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"></span> 
 <p align="left"><strong>2 Boosting方法的基本思路</strong></p>    提升方法基于这样一个思想：对于一个复杂任务来说，将多个专家的判断进行适当综合所得出的判断，要比其中任何一个专家单独的判断要好。实际上，就是“三个臭皮匠顶个诸葛亮”的道理。提升方法的问题在于，在学习中，如果已经发现了弱学习算法，能否将它提升为强学习算法。因为在应用中，发现弱学习算法要比强学习算法容易得多。关于提升的策略，最具代表性是AdaBoost算法。对于分类问题，在给定的训练样本上获得一个粗糙规则（弱分类器）要比获得一个精确规则（强分类器）容易的多。提升方法就是在弱学习算法上反复学习，得到一系列的弱分类器（也叫做基本分类器），然后组合这些弱分类器，构造一个能够更加准确分类的强分类器。此时会有两个问题： 
 <br> 
 <strong>1、如何进行弱分类器的学习？<br> 2、如何将弱分类器组合构成强分类器？</strong> 
 <br>    关于第一个问题大多是的提升方法都是通过改变训练样本的概率分布（权值分布）来实现的。AdaBoost的做法是提高那些被前一轮弱分类器分类错误的样本权重，降低正确分类的样本权重。也就是说，没有正确分类的样本在下一轮的弱分类器中将会得到更大的关注。至于第二个问题Adaboost则采用的加权投票，少数服从多数的策略，也就是要增大分类错误率小的弱分类器的权值，使其在决策中起到较大作用，减小分类错误率大的弱分类器的权重，使其表决权也相对减小。 
 <br> 
</div> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"></span> 
 <p align="left"><strong>3 AdaBoost方法</strong></p> 
 <p><strong>3.1AdaBoost算法（二分类）</strong></p> 
 <p><strong></strong></p> 
 <p style="text-align:center"><img src="https://images2.imgbox.com/fa/97/CtOBVXfZ_o.jpg" alt=""><br> </p> 
 <p style="text-align:center"><img src="https://images2.imgbox.com/03/a2/ij5vXV29_o.jpg" alt=""><br> </p> 
 <p style="text-align:left"><br> </p> 
 <br> 
 <strong>基本分类器的选择方法</strong> 
 <br>    在确定基本分类器时，AdaBoost通常采取的方法是遍历所有的弱分类器（或是所有的特征），求所有的弱分类器在正负样本上的错误率，将最小错误率对应的弱分类器作为本轮迭代的基本分类器。在遍历的过程要注意，弱分类器是有两个方向的，不同的方向判为正例和负例所导致的错误率也是不相同的，所以对一个弱分类器在训练样本上需要计算两次错误率，取最小值作为该弱分类器在训练集上的训练错误率。具体过程如下： 
 <br> 
</div> 
<div style="text-align:center"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><img src="https://images2.imgbox.com/0f/6c/Bq8nN4ht_o.jpg" alt=""><br> </span> 
</div> 
<div style="text-align:center"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><br> </span> 
</div> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px">   在实际的应用中由于训练的样本量巨大，如果一一比较所有样本的特征值是否过该弱分类器所设定的阈值，需要大量的计算时间，导致训练速度很慢。实际上我们采取的是这样的方法：<br> 训练样本事先分成两类：正样本和负样本，并按照特征值从小到大进行排序。人脸检测的弱分类器（特征）的阈值选取的方法通常定义为两个样本特征值的平均数，选取最优的阈值（错误率最小的阈值）时要遍历所有的样本，由于事先已经排序，只需要计算该样前面或后面的样本个数即可。<br> 例如，下图中为某一个特征10000正样本和1000负样本对应的特征值：<br> <img src="" alt=""><br> <br> <img src="https://images2.imgbox.com/5c/69/vJgz5Jo6_o.jpg" align="middle" alt=""><br> </span> 
</div> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><br> </span> 
</div> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><strong>3.2AdaBoost算例<br> E.X.1 一个虚拟的例子</strong><br>    现在，在一个平面方格中10个样本，被分为两类，非别被标有“＋”和“－”，定义分类器为竖直或水平的直线。例如，一个弱分类器被定义为一条竖直的直线，该直线数据点分为左右两部分，直线左半部分判断为正样本，右半部分的样本点被判断为负样本。这10个样本点中有5个“＋”和5个“－”，如图所示<br> </span> 
</div> 
<div style="text-align:center"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><img src="https://images2.imgbox.com/88/b7/ePeSCtww_o.jpg" alt=""><br> </span> 
</div> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px">   从图中不难看出，选用任何一条直线对这些点进行划分，错误都要高于30%。对于AdaBoost来说，每次循环t，假设基学习都是找到在权重 Dt下加权错误最小的基假设，从下面的计算结果可以发现AdaBoost只需要通过3步迭代（T＝3）就可以获得对样本点的完美分类。为方便记录直线分类器的符号方向，给定记号P，并且规定若P&gt;0，则直线左侧或是下侧为“+”，若P&lt;0，则直线左侧或是下侧为“—”。为方便观察和计算将10个样本标记在9×9的棋盘网格中，不难理解假设空间为图中20条先构成的分类器。<br> </span> 
</div> 
<div style="text-align:center"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><img src="https://images2.imgbox.com/c2/1c/nfVQx3pn_o.jpg" alt=""><br> </span> 
</div> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><br> </span> 
</div> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px">则分类器分类的结果（Y表示正确分类，N表示错误分类）：<br> </span> 
</div> 
<div style="text-align:center"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><img src="https://images2.imgbox.com/a7/8f/TspQi1SK_o.jpg" alt=""><br> </span> 
</div> 
<div style="text-align:center"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><img src="https://images2.imgbox.com/d1/6f/wgW3u7K3_o.jpg" alt=""><br> </span> 
</div> 
<div style="text-align:center"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><img src="https://images2.imgbox.com/6e/98/aK2V4BTv_o.jpg" alt=""><br> </span> 
</div> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"></span> 
 <p align="left">上表中计算的数值为整体四舍五入到小数点后两位。</p> 
 <p align="left">每一次迭代获得基本分类器如下：</p> 
 <div style="text-align:center"> 
  <img src="https://images2.imgbox.com/22/dd/UIYxySmf_o.jpg" alt=""> 
 </div> 
</div> 
<div style="text-align:center"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><img src="https://images2.imgbox.com/7e/9c/nAnKU5IV_o.jpg" alt=""><br> </span> 
</div> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"></span> 
 <p><img src="https://images2.imgbox.com/dc/09/cNGmCkrL_o.jpg" alt=""><br> </p> 
 <div style="text-align:center"> 
  <img src="https://images2.imgbox.com/c5/f1/o82WuUYJ_o.jpg" alt=""> 
 </div> 
</div> 
<div style="text-align:left"> 
 <span style="font-family:FangSong_GB2312; font-size:18px"></span> 
 <p><img src="https://images2.imgbox.com/60/23/5DSJSNib_o.jpg" alt=""><br> </p> 
 <p></p> 
 <p><strong>E.X.2一种选择弱分类器的方法</strong></p> 
 <p><strong><img src="https://images2.imgbox.com/43/8e/0u33sJqr_o.jpg" alt=""><br> </strong></p> 
 <p><strong></strong></p> 
 <p>解：</p> 
 <p>在这里我们定义弱分类器由 产生，其中 是两个样本的平均数（实验中常用的一种弱分类器确定的方法）。</p> 
 <p>初始化权重分布 </p> 
 <img src="https://images2.imgbox.com/0c/58/R8WZcHDc_o.jpg" alt=""> 
 <br> 
 <p><strong><img src="https://images2.imgbox.com/9c/98/lTaqYeoR_o.jpg" alt=""><br> </strong></p> 
 <p><strong><img src="https://images2.imgbox.com/12/a0/iCVGf2pz_o.jpg" alt=""><br> </strong></p> 
 <p><strong><img src="https://images2.imgbox.com/d6/83/RxyAQlHJ_o.jpg" alt=""><br> </strong></p> 
 <p><strong><img src="https://images2.imgbox.com/30/17/cwtzDQVi_o.jpg" alt=""><br> </strong></p> 
 <p><strong><img src="https://images2.imgbox.com/11/f6/pPpSjsaA_o.jpg" alt=""><br> </strong></p> 
 <p><strong><img src="https://images2.imgbox.com/0f/8d/qzHLx3oU_o.jpg" alt=""><br> </strong></p> 
 <p><strong><img src="https://images2.imgbox.com/d7/1f/ysfRIvNA_o.jpg" alt=""><br> </strong></p> 
</div> 
<p align="center"></p> 
<p align="center"></p> 
<p align="center"></p> 
<div style="text-align:left"> 
 <p></p> 
 <p style="text-align:center"><span style="font-family:FangSong_GB2312; font-size:18px"> <img src="https://images2.imgbox.com/fb/a6/nuuE7PYl_o.jpg" alt=""></span></p> 
 <p style="text-align:center"><span style="font-family:FangSong_GB2312; font-size:18px"><img src="https://images2.imgbox.com/37/70/lqkPFDxa_o.jpg" alt=""><br> </span></p> 
 <span style="font-family:FangSong_GB2312; font-size:18px"><br> </span> 
</div> 
<p></p> 
<p><span style="font-family:FangSong_GB2312; font-size:18px"><em></em></span></p> 
<br> 
<div style="text-align:left"></div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/90e7ae35d653cdf3a3ff78ccec817e0b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode 1. Two Sum 解题报告</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c249b82999ee7517756cef52047c341/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">时间转换报java.lang.NumberFormatException: multiple points问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>