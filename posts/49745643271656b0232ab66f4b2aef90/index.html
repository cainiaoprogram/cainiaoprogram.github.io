<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>经典回顾Class.forName() - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="经典回顾Class.forName()" />
<meta property="og:description" content="String userName = &#34;testuser&#34;;String password = &#34;testpass&#34;;String url = &#34;jdbc:mysql://localhost/test?user=&#34;&#43; userName&#43; &#34;&amp;password=&#34;&#43; password;Class.forName (&#34;com.mysql.jdbc.Driver&#34;).newInstance ();conn = DriverManager.getConnection (url);Class.forName(xxx.xx.xx) 返回的是一个类[Class], .newInstance() 后才创建一个对象[Object] Class.forName(xxx.xx.xx);的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段
Class aClass = Class.forName(xxx.xx.xx);
Object anInstance = aClass.newInstance();
Class.forName(&#34;&#34;).newInstance()返回的是object
but there is some limit for this method to create instance
that is your class constructor should no contain parameters, and you should cast the instance manually.
Class Driver{
protected static Driver current;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/49745643271656b0232ab66f4b2aef90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2009-08-31T09:14:00+08:00" />
<meta property="article:modified_time" content="2009-08-31T09:14:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">经典回顾Class.forName()</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><textarea name="code" class="java">   String userName = "testuser";
   String password = "testpass";
   String url = "jdbc:mysql://localhost/test?user="
                   + userName
                   + "&amp;password="
                   + password;
   Class.forName ("com.mysql.jdbc.Driver").newInstance ();
   conn = DriverManager.getConnection (url);
</textarea> </p> 
<p> </p> 
<div class="con_sample"> 
 <p><span style="font-size: small;">Class.forName(xxx.xx.xx) 返回的是一个类[Class], .newInstance() 后才创建一个对象[Object] Class.forName(xxx.xx.xx);的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段</span></p> 
</div> 
<div class="con_all"> 
 <p> </p> 
 <p><span style="font-size: small;">Class aClass = Class.forName(xxx.xx.xx);<br>Object anInstance = aClass.newInstance();<br><br><br>Class.forName("").newInstance()返回的是object<br>but there is some limit for this method to create instance<br>that is your class constructor should no contain parameters, and you should cast the instance manually.<br><br>Class Driver{<!-- --><br>protected static Driver current;<br>public static Driver getDriver(){<!-- --><br>return current;<br>}<br>}<br><br>Class MyDriver extends Driver{<!-- --><br>static{<!-- --><br>Driver.current=new MyDriver();<br>}<br>MyDriver(){}<br>}<br><br>用时:<br>Class.forName("MyDriver");<br>Driver d=Driver.getDriver();<br><br>有的jdbc连接数据库的写法里是Class.forName(xxx.xx.xx);而有一些：Class.forName(xxx.xx.xx).newInstance()，为什么会有这两种写法呢？<br><br>Class.forName(xxx.xx.xx) 返回的是一个类,<br>.newInstance() 后才创建一个对象<br><br>Class.forName(xxx.xx.xx);的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段<br><br>在JDBC规范中明确要求这个Driver类必须向DriverManager注册自己，即任何一个JDBC Driver的Driver类的代码都必须类似如下：<br>public class MyJDBCDriver implements Driver {<!-- --><br>static {<!-- --><br>DriverManager.registerDriver(new MyJDBCDriver());<br>}<br>}<br><br>所以我们在使用JDBC时只需要Class.forName(XXX.XXX);就可以了<br><br>we just want to load the driver to jvm only, but not need to user the instance of driver, so call Class.forName(xxx.xx.xx) is enough, if you call Class.forName(xxx.xx.xx).newInstance(), the result will same as calling Class.forName(xxx.xx.xx), because Class.forName(xxx.xx.xx).newInstance() will load driver first, and then create instance, but the instacne you will never use in usual, so you need not to create it.<br><br>在JDBC驱动中，有一块静态代码，也叫静态初始化块，它执行的时间是当class调入到内存中就执行（你可以想像成，当类调用到内存后就执行一个方法）。所以很多人把jdbc driver调入到内存中，再实例化对象是没有意义的。</span></p> 
 <p> </p> 
 <p><span style="font-family: 黑体; font-size: small;">Class clazz = Class.forName("XXX.XXX");<br>与<br>ClassLoader cl = Thread.currentThread().getContextClassLoader();<br>Class clazz = cl.loadClass("XXX.XXX");<br>都可以装载一个类那么他们的区别是什么呢？<br>进一步研究Class.forName()是调用<br>Class.forName(name, initialize, loader);也就是Class.forName("XXX.XXX"); 等同与Class.forName("XXX.XXX", true, CALLCLASS.class.getClassLoader());<br><br>第二次参数表示装载类的时候是否初始化该类， 即调用类的静态块的语句及初始化静态成员变量。<br><br>Class clazz = cl.loadClass("XXX.XXX");没有指定是否初始化的选项。只有执行clazz.newInstance()；时才能够初始化类。可以说Class.forName("XXX.XXX", false, cl)执行过程是一致的。只是ClassLoader.loadClass()是更底层的操作。<br><br>看一下JDBC驱动的装载。<br>Class.forName("com.mysql.jdbc.Driver");<br>Connection conn = DriverManager.getConnection("jdbcurl");<br>当调用Class.forName("com.mysql.jdbc.Driver");是Driver已经被初始化并注册到DriverManager中。MySQL Driver的代码<br>public class Driver extends NonRegisteringDriver<br>     implements java.sql.Driver<br>{<!-- --><br><br>     public Driver()<br>         throws SQLException<br>     {<!-- --><br>     }<br><br>     static <br>     {<!-- --><br>         try<br>         {<!-- --><br>             DriverManager.registerDriver(new Driver());<br>         }<br>         catch(SQLException E)<br>         {<!-- --><br>             throw new RuntimeException("Can't register driver!");<br>         }<br>     }<br>}<br>改修JDBC驱动的装载<br>ClassLoader cl = Thread.currentThread().getContextClassLoader();<br>Class clazz = cl.loadClass("com.mysql.jdbc.Driver");<br>clazz.newInstance();<br>Connection conn = DriverManager.getConnection("jdbcurl");<br>同样可以执行。但是这样就多构造了一个com.mysql.jdbc.Driver实例。同Class.forName("com.mysql.jdbc.Driver").newInstance()是一样的。是没有任何意义的。</span></p> 
 <p> </p> 
 <p><span style="font-size: small;">类名.class是Class对象的句柄，每个被加载的类，在jvm中都会有一个Class对象与之相对应，如果要创建新的对象，直接使用Class对象的局部class.forName就可以了，不需要用new       类名。</span></p> 
 <p><br><span style="font-size: small;">在java中，每个class都有一个相应的Class对象，当编写好一个类，编译完成后，在生成的.class文件中，就产生一个class对象，用来表示这个类的类型信息。获得Class实例的三中方式：<br>1.利用对象调用getClass()方法获取该对象的Class实例<br>2.使用Class的静态方法forName()，用类的名字获取一个Class实例<br>3.运用.calss的方式获取Class实例，对基本数据类型的封装类，还可以采用.TYPE来获取对应的基本数据类型的Class实例</span></p> 
 <p><span style="font-size: small;">calss ClassTest<br>{<!-- --><br>                public static void main(String[] args)<br>                {<!-- --><br>                        /*<br>                        //利用对象调用getClass()方法获取该对象的Class实例<br>                        Point pt=new Point();                <br>                        Class c1=pt.getClass();<br>                        System.out.println(c1.getName());                        //结果:Point<br>                <br>                        //使用Class的静态方法forName()，用类的名字获取一个Class实例<br>                        try<br>                        {<!-- --><br>                                Class c2=Class.forName("Point");<br>                                System.out.println(c2.getName());                //结果:Point<br>                        }<br>                        catch(Exception e)<br>                        {<!-- --><br>                                e.printStackTrace();<br>                        }</span></p> 
 <p><span style="font-size: small;">                        //运用.calss的方式获取Class实例(类)<br>                        Class c3=Point.calss;<br>                        System.out.println(c3.getName());                        //结果:Point</span></p> 
 <p><span style="font-size: small;">                        //运用.calss的方式获取Class实例(基本类型)<br>                        Class c4=int.calss;<br>                        System.out.println(c4.getName());                        //结果:int</span></p> 
 <p><span style="font-size: small;">                        //运用.calss的方式获取Class实例(基本数据类型的封装类)<br>                        Class c5=Integer.TYPE;<br>                        System.out.println(c5.getName());                        //结果:int<br>                <br>                        Class c6=Integer.class;<br>                        System.out.println(c6.getName());                        //结果:java.lang.Integer<br>                        */<br>                <br>                        //以下结果是：          before new Point()<br>                                        loading point<br>                                        after new Point()<br>                                        loading Line        <br>                        //当new Point()的时候加载这个类，用forName构造实例的时候也加载该类。<br>                        System.out.println("before new Point()");<br>                        new Point();<br>                        System.out.println("after new Point()");</span></p> 
 <p><span style="font-size: small;">                        try<br>                        {<!-- --><br>                                Class.forName("Line");<br>                        }catch(Exception e)<br>                        {<!-- --><br>                                e.printStackTrace();<br>                        }<br>                <br>                }<br>}<br>class Point()<br>{<!-- --><br>                static<br>                {<!-- --><br>                        System.out.println("loading point");<br>                }<br>                int x,y;<br>}<br>class Line<br>{<!-- --><br>                static<br>                {<!-- --><br>                        System.out.println("loading Line");<br>                }<br>}</span></p> 
 <p><span style="font-size: small;">在运行期间，如果我们要产生某个类的对象，java虚拟机会检测该类型的Class对象是否已被加载。如果没有加载，java虚拟机会根据类的名称找到.class文件并加载它。一旦某个类型的Class对象已经被加载到内存，就可以用它来产生该类型的所有对象。<br>newInstance()调用内中缺省的构造方法。</span></p> 
 <p><span style="font-size: small;">newInstance()调用类中缺省的构造方法，如果要实例的对象中有了自己定义的构造方法（除重写的和默认构造方法相同的构造方法外）<br><br><br></span></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25817faab03a568e6bb6c8cc499beaac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java编程琐事（3）——转义字符的应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac0ebe5f61da4023cfc92b9a0da62ada/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">relation of kconfig Makeifle</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>