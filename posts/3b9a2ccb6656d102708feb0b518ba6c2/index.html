<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ResNet 原论文及原作者讲解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ResNet 原论文及原作者讲解" />
<meta property="og:description" content="ResNet 论文摘要1. 引入2. 相关工作残差表示快捷连接 3. 深度残差学习3.1. 残差学习3.2. 快捷恒等映射3.3. 网络体系结构普通网络 plain network残差网络 residual network 3.4. 实施 4. 实验4.1. ImageNet分类普通的网络 plain network残差网络 residual network恒等vs.快捷连接更深的瓶颈架构与 SOTA 比较 4.2. CIFAR-10和分析层响应分析探索超过1000层 何凯明大佬现场讲解 ResNet大佬的 PPT ResNet 论文 论文地址：Deep Residual Learning for Image Recognition 摘要 更深的神经网络更难训练。我们提出了一个 残差学习框架，以 简化 比以前使用的网络深度大得多的网络的训练。我们明确地将 ResNet 的层 重新表述为 学习残差函数，也就是 与层输入有关的函数，而 不是学习无关的函数。
残差函数是与层输入有关的函数，是因为 它是用来表示输入和输出之间的差异的。也就是说，残差函数是用来 学习输入到输出的映射的变化量，而不是直接学习输入到输出的映射。
ResNet 的 每个残差块 都试图 学习输入和输出之间的差异，而 不是直接学习输入到输出的映射。这样做的好处是可以让网络更容易优化，也可以 增加网络的深度 而 不会导致退化 问题。
我们提供了 全面的实验证据，表明这些残差网络更 容易优化，并且可以从相当大的深度中获得 精度。在 ImageNet 数据集上，我们评估了深度高达152层的残差网络，比 VGG 网络深8倍，但仍然具有较低的复杂性。这些残差网络的集合在 ImageNet 测试集上的误差达到3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3b9a2ccb6656d102708feb0b518ba6c2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-19T09:54:42+08:00" />
<meta property="article:modified_time" content="2023-12-19T09:54:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ResNet 原论文及原作者讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4> </h4> 
 <ul><li><ul><li><a href="#ResNet__2" rel="nofollow">ResNet 论文</a></li><li><ul><li><a href="#_6" rel="nofollow">摘要</a></li><li><a href="#1__17" rel="nofollow">1. 引入</a></li><li><a href="#2__99" rel="nofollow">2. 相关工作</a></li><li><ul><li><a href="#_101" rel="nofollow">残差表示</a></li><li><a href="#_116" rel="nofollow">快捷连接</a></li></ul> 
    </li><li><a href="#3__132" rel="nofollow">3. 深度残差学习</a></li><li><ul><li><a href="#31__134" rel="nofollow">3.1. 残差学习</a></li><li><a href="#32__147" rel="nofollow">3.2. 快捷恒等映射</a></li><li><a href="#33__171" rel="nofollow">3.3. 网络体系结构</a></li><li><ul><li><a href="#_plain_network_177" rel="nofollow">普通网络 plain network</a></li><li><a href="#_residual_network_190" rel="nofollow">残差网络 residual network</a></li></ul> 
     </li><li><a href="#34__199" rel="nofollow">3.4. 实施</a></li></ul> 
    </li><li><a href="#4__215" rel="nofollow">4. 实验</a></li><li><ul><li><a href="#41_ImageNet_217" rel="nofollow">4.1. ImageNet分类</a></li><li><ul><li><a href="#_plain_network_223" rel="nofollow">普通的网络 plain network</a></li><li><a href="#_residual_network_238" rel="nofollow">残差网络 residual network</a></li><li><a href="#vs_251" rel="nofollow">恒等vs.快捷连接</a></li><li><a href="#_264" rel="nofollow">更深的瓶颈架构</a></li><li><a href="#_SOTA__279" rel="nofollow">与 SOTA 比较</a></li></ul> 
     </li><li><a href="#42_CIFAR10_289" rel="nofollow">4.2. CIFAR-10和分析</a></li><li><ul><li><a href="#_309" rel="nofollow">层响应分析</a></li><li><a href="#1000_323" rel="nofollow">探索超过1000层</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#_ResNet_329" rel="nofollow">何凯明大佬现场讲解 ResNet</a></li><li><ul><li><a href="#_PPT_333" rel="nofollow">大佬的 PPT</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="ResNet__2"></a>ResNet 论文</h3> 
<ul><li>论文地址：<a href="https://arxiv.org/abs/1512.03385" rel="nofollow">Deep Residual Learning for Image Recognition</a></li></ul> 
<h4><a id="_6"></a>摘要</h4> 
<p><strong>更深的神经网络更难训练</strong>。我们提出了一个 <strong>残差学习框架</strong>，以 <strong>简化</strong> 比以前使用的网络深度大得多的网络的训练。我们明确地将 <strong><code>ResNet</code> 的层</strong> 重新表述为 <strong>学习残差函数</strong>，也就是 <strong>与层输入有关的函数</strong>，而 <strong>不是学习无关的函数</strong>。</p> 
<blockquote> 
 <p>  残差函数是与层输入有关的函数，是因为 <strong>它是用来表示输入和输出之间的差异的</strong>。也就是说，残差函数是用来 <strong>学习输入到输出的映射的变化量</strong>，而不是直接学习输入到输出的映射。<br>   ResNet 的 <strong>每个残差块</strong> 都试图 <strong>学习输入和输出之间的差异</strong>，而 <strong>不是直接学习输入到输出的映射</strong>。这样做的好处是可以让网络更容易优化，也可以 <strong>增加网络的深度</strong> 而 <strong>不会导致退化</strong> 问题。</p> 
</blockquote> 
<p>我们提供了 <strong>全面的实验证据</strong>，表明这些残差网络更 <strong>容易优化</strong>，并且可以从相当大的深度中获得 <strong>精度</strong>。在 <code>ImageNet</code> 数据集上，我们评估了深度高达152层的残差网络，比 <code>VGG</code> 网络深8倍，但仍然具有较低的复杂性。这些残差网络的集合在 <code>ImageNet</code> 测试集上的误差达到3.57%。该结果在 <code>ILSVRC</code> 2015分类任务中获得第一名。我们还介绍了100层和1000层的 <code>CIFAR-10</code>分析。</p> 
<p>表征的深度对于许多视觉识别任务至关重要。仅由于我们的极深表示，我们在 COCO 对象检测数据集上获得了28%的相对改进。深度残差网络是我们参加 ILSVRC &amp; COCO 2015竞赛的基础，我们还在 ImageNet 检测、ImageNet 定位、COCO 检测和 COCO 分割的任务中获得了第一名。</p> 
<h4><a id="1__17"></a>1. 引入</h4> 
<p>深度卷积神经网络[22,21]在图像分类方面取得了一系列突破[21,50,40]。深度网络 <strong>以端到端的多层方式自然地集成低/中/高级特征[50]和分类器</strong>，并且 <strong>特征的“级别”可以通过堆叠层的数量(深度)来丰富</strong>。</p> 
<blockquote> 
 <p>这句话的意思是，深度网络可以用多个层次的神经元来处理数据，从而提取不同层次的特征。</p> 
 <ul><li>特征是数据的一些有用的属性，比如图像的边缘、形状、颜色等。</li></ul> 
 <blockquote> 
  <ul><li>低级特征是比较简单的特征，比如像素值；</li><li>中级特征是比较复杂的特征，比如线条、角度、纹理等；</li><li>高级特征是比较抽象的特征，比如物体、场景、情感等。</li></ul> 
 </blockquote> 
 <ul><li>深度网络可以通过增加层数来提取更高级的特征，从而更好地完成分类任务。</li><li>分类器是一种算法，它可以根据特征来判断数据属于哪个类别，比如猫、狗、人等。</li></ul> 
</blockquote> 
<p>最近的证据[41,44]表明网络深度是至关重要的，在具有挑战性的 ImageNet 数据集[36]上的领先结果[41,44,13,16]都利用了“非常深”[41]模型，深度为16[41]到30[16]。许多其他重要的视觉识别任务[8,12,7,32,27]也极大地受益于非常深的模型。</p> 
<p>在深度的重要性的驱使下，一个问题出现了：学习更好的网络就像堆叠更多的层一样简单吗？</p> 
<p>回答这个问题的一个障碍是臭名昭著的 <strong>梯度消失/爆炸问题</strong>[1,9]，它从一开始就 <strong>阻碍了收敛</strong>。然而，这个问题已经通过规范化初始化[23,9,37,13]和中间规范化层[16]得到了很大程度的解决，这使得具有数十层的网络能够开始收敛随机梯度下降(SGD)与反向传播[22]。</p> 
<blockquote> 
 <p><strong>梯度消失</strong> 是指在深度神经网络中，由于 <strong>反向传播算法</strong> 的限制，导致 <strong>网络的梯度在传递过程中逐渐变小，最终趋近于零，从而使得网络无法更新参数，导致训练失败</strong> 的现象。梯度消失的原因可能有以下几种：</p> 
 <ul><li>网络层数过多，导致链式法则中的连乘效应；</li><li>激活函数的导数小于1，导致梯度衰减；</li><li>权重初始化不合适，导致梯度变化不稳定；</li></ul> 
</blockquote> 
<p>当更深的网络能够开始收敛时，一个退化问题就暴露出来了：<strong>随着网络深度的增加，精度趋于饱和(这可能不足为奇)，然后迅速退化</strong>。</p> 
<p>出乎意料的是，这种退化并 <strong>不是由过拟合引起</strong> 的，在 <strong>适当深度的模型上增加更多的层会导致更高的训练误差</strong>，这一点在[11,42]中有提到，我们的实验也充分验证了这一点。</p> 
<blockquote> 
 <p>过拟合是指模型在 <strong>训练集上表现很好</strong>，但 <strong>在测试集或新数据上表现很差</strong> 的现象。</p> 
 <ul><li>比如在训练集上 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           e 
          
         
           r 
          
         
           r 
          
         
           o 
          
         
           r 
          
         
        
          error 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">error</span></span></span></span></span> 在下降，但是在测试集上 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           e 
          
         
           r 
          
         
           r 
          
         
           o 
          
         
           r 
          
         
        
          error 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">error</span></span></span></span></span> 却上升了。</li><li>而下图中在测试集上 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           e 
          
         
           r 
          
         
           r 
          
         
           o 
          
         
           r 
          
         
        
          error 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">error</span></span></span></span></span> 是随着训练集 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           e 
          
         
           r 
          
         
           r 
          
         
           o 
          
         
           r 
          
         
        
          error 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">error</span></span></span></span></span> 的下降而下降，所以这不是过拟合。</li></ul> 
</blockquote> 
<p>下图是一个典型的例子。</p> 
<p><img src="https://images2.imgbox.com/af/b6/x5ejMrvy_o.png" alt="在这里插入图片描述"><br> CIFAR-10 在20层和56层“普通”网络上的训练误差(左)和测试误差(右)。网络越深，训练误差越大，测试误差也越大。</p> 
<p>ImageNet 上的类似现象如下图所示：</p> 
<p><img src="https://images2.imgbox.com/fa/f4/cCn0XhlS_o.png" alt="在这里插入图片描述"></p> 
<p>ImageNet 的训练。细曲线表示训练误差，粗曲线表示中间产物的验证误差。左图：18层和34层的普通网络（简单地堆叠）。右图：18层和34层的 ResNets。在该图中，与普通网络相比，残差网络没有额外的参数。</p> 
<p>(训练精度的)退化表明，并非所有系统都同样容易优化。让我们考虑一个较浅的体系结构和它的更深的对应物，它在上面添加了更多的层。通过 <strong>构造更深的模型存在一个解决方案</strong>：<strong>添加的层是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          i 
         
        
          d 
         
        
          e 
         
        
          n 
         
        
          t 
         
        
          i 
         
        
          t 
         
        
          y 
         
        
            
         
        
          m 
         
        
          a 
         
        
          p 
         
        
          p 
         
        
          i 
         
        
          n 
         
        
          g 
         
        
       
         identity\ mapping 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace"> </span><span class="mord mathnormal">ma</span><span class="mord mathnormal">pp</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span></span></span></span></span>（恒等映射），其他的层则从之前学习到的浅层模型复制得到。</strong></p> 
<blockquote> 
 <p>这句话的意思是，当网络层数增加时，为了避免退化问题，作者采用了一种方法，就是将增加的层作为恒等映射（对任意 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          x 
         
        
       
         x 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          ( 
         
        
          x 
         
        
          ) 
         
        
          = 
         
        
          x 
         
        
       
         f(x) = x 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 都成立），也就是不改变输入的输出，而其他的层则复制自之前学习到的浅层模型。这样做的目的是为了让网络更容易优化，也可以作为一个 <strong>基线</strong> 来 <strong>比较残差连接的效果</strong>。</p> 
</blockquote> 
<p><strong>这种构造解的存在表明</strong>，<strong>较深的模型不会比较浅的模型产生更高的训练误差</strong>。<strong>但实验表明</strong>，我们现有的解算器 <strong>无法找到比构建的解决方案更好的解决方案</strong>(或无法在可行的时间内做到这一点)。</p> 
<blockquote> 
 <p>我的理解是，假如我有一个5层的网络，我想构建更深的9层网络，那么我拿来5层网络作为前5层，后4层网络只需要完成恒等映射的任务，</p> 
 <ul><li><strong>按理来说</strong>，就可以保证更深的9层网络不会比5层的网络效果差，</li><li>但 <strong>实验效果</strong> 却是9层网络效果更差，这说明后4层网络不太能完成恒等映射。</li></ul> 
 <p>所以作者团队后面就 <strong>不用网络来拟合恒等映射</strong>了，而是直接“曲线救国”，<strong>加了一个跨层连接</strong> 恒等映射。</p> 
</blockquote> 
<p>在本文中，我们通过 <strong>引入深度残差学习框架</strong> 来解决 <strong>退化问题</strong>。我们不是希望每几层堆叠的层直接拟合一个期望的底层映射，而是明确地 <strong>让这些层拟合一个残差映射</strong>。形式上，假设期望的底层映射为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        \mathcal H(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0097em;">H</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>，我们让堆叠的非线性层拟合另一个映射：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         : 
        
       
         = 
        
       
         H 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         − 
        
       
         x 
        
       
      
        \mathcal F(x) := \mathcal H(x) - x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0097em;">H</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>。原始映射被重构为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         + 
        
       
         x 
        
       
      
        \mathcal F(x)+x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>。我们假 <strong>设优化残差映射比优化原始的、无参照的映射更容易</strong>。<strong>在极端情况下，如果一个恒等映射是最优的，将残差推至零要比用一堆非线性层拟合一个恒等映射容易得多。</strong></p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         + 
        
       
         x 
        
       
      
        \mathcal F(x)+x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 的表达式可以 <strong>通过具有“快捷连接”的前馈神经网络来实现</strong>(图2)。</p> 
<p><img src="https://images2.imgbox.com/8c/27/lN67COYR_o.png" alt="在这里插入图片描述"><br> 残差学习：一个构建模块。</p> 
<p><strong>快捷连接</strong> [2,34,49]是那些 <strong>跳过一个或多个层的连接</strong>。在我们的例子中，快捷连接只是执行恒等映射，它们的输出被添加到堆叠层的输出中(图2)。<strong>恒等快捷连接既不增加额外的参数，也不增加计算复杂度。</strong> 整个网络仍然可以通过反向传播的 SGD 进行端到端训练，并且可以使用通用库(例如 Caffe[19])轻松实现，而无需修改求解器。</p> 
<p>我们在 ImageNet 上进行了全面的实验[36]，以显示退化问题并评估我们的方法。我们发现：</p> 
<ul><li>我们的极深残差网络很容易优化，但对应的 <strong>“普通”网络</strong> (简单地堆叠层)在深度增加时表现出更高的训练误差；</li><li>我们的深度残差网络可以很容易地从深度大大增加中获得精度增益，产生的结果比以前的网络好得多。</li></ul> 
<p>类似的现象也出现在 CIFAR-10集上[20]，这表明我们的方法的优化困难和效果并不仅仅是某个特定数据集的特性。</p> 
<blockquote> 
 <p>也就是说，作者认为他们的方法是具有普遍性和有效性的，不会受到数据集的影响。</p> 
</blockquote> 
<p>我们在超过100层的数据集上展示了成功训练的模型，并探索了超过1000层的模型。在 ImageNet 分类数据集[36]上，我们使用极深残差网获得了很好的结果。我们的152层残差网络是迄今为止在 ImageNet 上呈现的最深的网络，但其复杂度仍低于 VGG 网络[41]。我们的集合在 ImageNet 测试集上的前5名错误率为3.57%，并在 ILSVRC 2015分类大赛中获得第一名。</p> 
<p>极深表征在其他识别任务上也有出色的泛化性能，并使我们在 ILSVRC &amp; COCO 2015竞赛中，在 ImageNet 检测、ImageNet 定位、COCO 检测和 COCO 分割方面进一步获得第一名。这有力地证明了残差学习原理是通用的，我们期望它能适用于其他视觉和非视觉问题。</p> 
<h4><a id="2__99"></a>2. 相关工作</h4> 
<h5><a id="_101"></a>残差表示</h5> 
<p>残差表示是一种在图像识别中常用的表示方法，它是 <strong>通过对一个字典的残差向量进行编码来得到的</strong>，VLAD 是一种残差表示的方法，而 Fisher Vector 可以看作是 VLAD 的概率版本。这两种方法都是用于图像检索和分类的强大的浅层表示方法。</p> 
<blockquote> 
 <p>字典和残差向量是在图像识别中常用的表示方法的一部分，它们可以用来 <strong>描述图像的特征</strong>。</p> 
 <ul><li><strong>字典</strong> 是一个由一些基本向量组成的集合，它们可以用来近似表示 <strong>图像的局部区域</strong>。</li><li><strong>残差向量</strong> 是指图像的局部区域与字典中最近的基本向量之间的差异，它们可以用来 <strong>捕捉图像的细节和变化</strong>。</li></ul> 
</blockquote> 
<blockquote> 
 <p>为什么想到使用残差？</p> 
 <ul><li>对于 VLAD 和 Fisher Vector 来说，对残差向量编码比对原始向量编码效率更高；</li><li>用 Multigrid 解偏微分方程（Partial Differential Equations，PDE）时，使用残差向量对于优化更好，收敛速度更快。</li></ul> 
</blockquote> 
<h5><a id="_116"></a>快捷连接</h5> 
<p>与我们的工作同时进行的是，“高速公路网”[42,43]与门控功能[15]提供了快捷连接。这些门是数据依赖的，有参数，而我们的恒等快捷方式是无参数的。</p> 
<p>当一条门控捷径“关闭”(接近零)时，公路网中的层表示非残差函数。相反，我们的公式总是学习残差函数；我们的 <strong>恒等快捷键永远不会关闭，所有的信息总是通过，还有额外的残差函数需要学习。</strong></p> 
<p>此外，高速公路网络在深度极大增加(例如，超过100层)的情况下，并没有显示出准确性的提高。</p> 
<blockquote> 
 <p>为什么想到使用跨层连接（快捷连接）？</p> 
 <ul><li>在多层感知机（multi-layer perceptrons，<code>MLP</code>）中加一层从输入到输出的线性层</li><li><code>GoogLeNet</code> 中使用辅助分类器防止梯度爆炸 / 消失</li><li>在此之前已有研究者使用跨层连接对响应和梯度中心化（center）处理</li><li><code>inception</code> 结构本质也是跨层连接</li><li><code>high-way</code> 网络也使用到了跨层连接</li></ul> 
</blockquote> 
<h4><a id="3__132"></a>3. 深度残差学习</h4> 
<h5><a id="31__134"></a>3.1. 残差学习</h5> 
<p>让我们把 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        \mathcal H(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0097em;">H</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span> 看作是 <strong>由几个堆叠层(不一定是整个网络)拟合的底层映射</strong>，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 表示 <strong>这些层的第一层的输入</strong>。如果 <strong>假设多个非线性层可以渐近逼近复杂函数，则等价于假设它们可以渐近逼近残差函数</strong>，即 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         − 
        
       
         x 
        
       
      
        \mathcal H(x)−x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0097em;">H</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> (假设输入和输出具有相同的维数)。因此，我们不是期望堆叠层近似于 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        \mathcal H(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0097em;">H</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>，而是明确地让这些层近似于残差函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         : 
        
       
         = 
        
       
         H 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         − 
        
       
         x 
        
       
      
        \mathcal F(x):= \mathcal H(x) - x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0097em;">H</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>。因此，原始函数变为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
         + 
        
       
         x 
        
       
      
        \mathcal F(x)+x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>。<strong>尽管这两种形式都应该能够渐进地逼近所需的函数(如假设的那样)，但学习的难易程度可能有所不同。</strong></p> 
<p>这种重新表述的动机是 <strong>关于退化问题的反直觉现象</strong>(图1，左)。正如我们在介绍中所讨论的，<strong>如果添加的层可以构造为恒等映射，那么较深的模型的训练误差应该不大于较浅的模型</strong>。<strong>退化问题表明，求解器在逼近多非线性层的恒等映射时可能存在困难。</strong> 通过残差学习的重新表述，<strong>如果恒等映射是最优的，求解器可以简单地将多个非线性层的权值向零驱动，从而逼近恒等映射</strong>。</p> 
<blockquote> 
 <p><strong>非线性层</strong> 是指神经网络中使用了非线性变换的层，比如激活函数、卷积或池化。</p> 
 <ul><li>激活函数是一种函数，它可以给神经元的输出增加非线性，比如<code>sigmoid</code>、<code>tanh</code> 或 <code>relu</code> 函数。</li><li><strong>非线性层可以让神经网络拟合更复杂的函数，提高网络的表达能力和优化效率。</strong></li></ul> 
</blockquote> 
<p>在实际情况下，恒等映射不太可能是最优的，但我们的重新表述可能有助于预先解决问题。如果最优函数更接近于恒等映射而不是零映射，那么求解器应该更容易找到与恒等映射相关的扰动，而不是将该函数作为一个新函数来学习。我们通过实验(图7)表明，<strong>学习到的残差函数通常具有较小的响应，这表明恒等映射提供了合理的预处理</strong>。</p> 
<h5><a id="32__147"></a>3.2. 快捷恒等映射</h5> 
<p>我们对每几个堆叠层采用残差学习。构建块如图2所示。形式上，在本文中，我们认为构建块定义为：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
           
           
             y 
            
           
             = 
            
           
             F 
            
           
             ( 
            
           
             x 
            
           
             , 
            
            
            
              W 
             
            
              i 
             
            
           
             ) 
            
           
             + 
            
           
             x 
            
           
             . 
            
           
          
          
          
          
            (1) 
           
          
         
        
       
         \mathbf y = \mathcal F(\mathbf x, {W_i}) + \mathbf x. \tag1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6389em; vertical-align: -0.1944em;"></span><span class="mord mathbf" style="margin-right: 0.016em;">y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4444em;"></span><span class="mord mathbf">x</span><span class="mord">.</span></span><span class="tag"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></span><br> 这里的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
      
        y 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span> 是被考虑的层的输入和输出向量。函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         ( 
        
       
         x 
        
       
         , 
        
        
        
          W 
         
        
          i 
         
        
       
         ) 
        
       
      
        \mathcal F(\mathbf x, {W_i}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 表示待学习的残差映射。对于图2中有两层的例子，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         = 
        
        
        
          W 
         
        
          2 
         
        
       
         σ 
        
       
         ( 
        
        
        
          W 
         
        
          1 
         
        
       
         x 
        
       
         ) 
        
       
      
        \mathcal F = W_2σ(W_1x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         σ 
        
       
      
        σ 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span></span></span></span></span> 表示 <code>ReLU</code>[29]，为了简化符号，省略了偏差。操作 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         + 
        
       
         x 
        
       
      
        \mathcal F + x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 是通过一个快捷连接和元素加法来执行的。我们采用加后的第二个非线性(即 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         σ 
        
       
         ( 
        
       
         y 
        
       
         ) 
        
       
      
        σ(y) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">σ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span></span></span></span></span>，见图2)。</p> 
<p>方程(1)中的快捷连接既不引入额外的参数，也不增加计算复杂度。这不仅在实践中很有吸引力，而且在我们比较普通网络和残差网络时也很重要。我们可以比较同时具有相同数量的参数、深度、宽度和计算成本(除了可以忽略不计的元素加法)的普通/残余网络。</p> 
<p><strong><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          x 
         
        
       
         x 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          F 
         
        
       
         \mathcal F 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span></span></span></span></span> 的维数在 Eqn(1)中必须相等。</strong></p> 
<p>如果不是这种情况(例如，当 <strong>改变输入/输出通道</strong> 时)，我们可以 <strong>通过快捷连接执行线性投影 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          w 
         
        
       
         w 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span></span></span></span></span> 来匹配维度</strong>：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
           
           
             y 
            
           
             = 
            
           
             F 
            
           
             ( 
            
           
             x 
            
           
             , 
            
            
            
              W 
             
            
              i 
             
            
           
             ) 
            
           
             + 
            
            
            
              W 
             
            
              s 
             
            
           
             x 
            
           
             . 
            
           
          
          
          
          
            (2) 
           
          
         
        
       
         \mathbf y = \mathcal F(\mathbf x, {W_i}) + W_s \mathbf x. \tag2 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6389em; vertical-align: -0.1944em;"></span><span class="mord mathbf" style="margin-right: 0.016em;">y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathbf">x</span><span class="mord">.</span></span><span class="tag"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></span></p> 
<p>我们也可以使用 Eqn(1)中的方阵 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
      
        w 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span></span></span></span></span>。但我们将通过实验证明，恒等映射足以解决退化问题，并且节省资源，因此 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          W 
         
        
          s 
         
        
       
      
        W_s 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 仅在匹配维度时使用。</p> 
<blockquote> 
 <p>匹配维度是指让两个向量或矩阵的维度相同，以便进行加法或乘法等运算。例如，如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          x 
         
        
       
         x 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 是一个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
          × 
         
        
          m 
         
        
       
         n×m 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> 的矩阵，而 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          F 
         
        
          ( 
         
        
          x 
         
        
          ; 
         
         
         
           W 
          
         
           i 
          
         
        
          ) 
         
        
       
         \mathcal F(x; {W_i}) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">;</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 是一个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
          × 
         
        
          k 
         
        
       
         n×k 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 的矩阵，那么要使 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          y 
         
        
          = 
         
        
          F 
         
        
          ( 
         
        
          x 
         
        
          ; 
         
         
         
           W 
          
         
           i 
          
         
        
          ) 
         
        
          + 
         
        
          x 
         
        
       
         y = \mathcal F(x; {W_i}) + x 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">;</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> 成立，就需要用一个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          m 
         
        
          × 
         
        
          k 
         
        
       
         m×k 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 的矩阵 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           W 
          
         
           s 
          
         
        
       
         W_s 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 来乘以 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          x 
         
        
       
         x 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>，使得 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           W 
          
         
           s 
          
         
        
          x 
         
        
       
         W_s x 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal">x</span></span></span></span></span> 是一个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
          × 
         
        
          k 
         
        
       
         n×k 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span> 的矩阵，然后再与 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          F 
         
        
          ( 
         
        
          x 
         
        
          ; 
         
         
         
           W 
          
         
           i 
          
         
        
          ) 
         
        
       
         \mathcal F(x; {W_i}) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">;</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 相加。</p> 
</blockquote> 
<p>残差函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
      
        \mathcal F 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span></span></span></span></span> 的形式是灵活的。本文中的实验涉及到一个函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
      
        \mathcal F 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span></span></span></span></span>，它有两层或三层(图5)，而更多的层是可能的。但如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
      
        \mathcal F 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span></span></span></span></span> 只有单层，则 Eqn.(1)类似于线性层：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
         = 
        
        
        
          W 
         
        
          1 
         
        
       
         x 
        
       
         + 
        
       
         x 
        
       
      
        \mathbf y = W_1 \mathbf x + \mathbf x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6389em; vertical-align: -0.1944em;"></span><span class="mord mathbf" style="margin-right: 0.016em;">y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4444em;"></span><span class="mord mathbf">x</span></span></span></span></span>，我们没有观察到其优势。</p> 
<p>我们还注意到，尽管为了简单起见，上面的符号是关于全连接层的，但它们适用于卷积层。函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         ( 
        
       
         x 
        
       
         ， 
        
        
        
          W 
         
        
          i 
         
        
       
         ) 
        
       
      
        \mathcal F(\mathbf x， {W_i}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 可以表示多个卷积层。逐个通道地在两个特征映射上执行元素加法。</p> 
<blockquote> 
 <ul><li><code>Identity Mapping by Shortcuts</code> 是一种深度残差网络中的技术，它可以使网络中的信号在前向和反向传播时直接从一个残差块传到另一个残差块，不会产生信号中断或梯度消失的问题。</li><li>它的基本思想是在每个残差块的输入和输出之间加上一个恒等映射（identity mapping），即 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           y 
          
         
           = 
          
         
           F 
          
         
           ( 
          
         
           x 
          
         
           , 
          
          
          
            W 
           
          
            i 
           
          
         
           ) 
          
         
           + 
          
         
           x 
          
         
           . 
          
         
        
          \mathbf y = \mathcal F(\mathbf x, {W_i}) + \mathbf x. 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6389em; vertical-align: -0.1944em;"></span><span class="mord mathbf" style="margin-right: 0.016em;">y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4444em;"></span><span class="mord mathbf">x</span><span class="mord">.</span></span></span></span></span>，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           y 
          
         
        
          \mathbf y 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6389em; vertical-align: -0.1944em;"></span><span class="mord mathbf" style="margin-right: 0.016em;">y</span></span></span></span></span> 是输出，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           x 
          
         
        
          \mathbf x 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4444em;"></span><span class="mord mathbf">x</span></span></span></span></span> 是输入，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           F 
          
         
        
          \mathcal F 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span></span></span></span></span> 是残差函数，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            W 
           
          
            i 
           
          
         
        
          W_i 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是权重。这样做的好处是可以增加网络的深度和性能，而不影响网络的收敛速度和稳定性。</li></ul> 
</blockquote> 
<h5><a id="33__171"></a>3.3. 网络体系结构</h5> 
<p>我们已经测试了各种普通/残差网，并观察到一致的现象。为了提供讨论的实例，我们如下描述 ImageNet 的两个模型。</p> 
<blockquote> 
 <p><code>plain network</code> 指的就是 <strong>简单堆叠层的网络</strong>。</p> 
</blockquote> 
<h6><a id="_plain_network_177"></a>普通网络 plain network</h6> 
<p>我们的普通基线(图3，中间)主要受到 VGG 网原理的启发[41] (图3，左)。卷积层大多具有 <code>3×3</code> 滤波器，并遵循两个简单的设计规则：</p> 
<p>(i) 对于 <strong>相同的输出特征图大小</strong>，各层具有 <strong>相同数量的滤波器</strong>；<br> (ii) 如果 <strong>特征图大小减半</strong>，则 <strong>滤波器的数量增加一倍</strong>，以保持每层的时间复杂度。</p> 
<p>我们通过步长为2的卷积层直接执行下采样。网络以一个全局平均池化层和一个带有 <code>softmax</code> 的1000路全连接层结束。图3(中)加权层总数为34层。</p> 
<p>值得注意的是，我们的模型比 VGG 网络具有更少的过滤器和更低的复杂性[41] (图3，左)。我们的34层基线有36亿 <code>FLOPs</code>(乘加)，仅为 VGG-19(196亿<code>FLOPs</code>)的18%。</p> 
<p><img src="https://images2.imgbox.com/95/8f/g05Javi0_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="_residual_network_190"></a>残差网络 residual network</h6> 
<p><strong>在上述普通网络的基础上，我们插入快捷连接</strong>(图3，右)，将网络转换为对应的 <strong>残差版本</strong>。当输入和输出维度相同时(图3中的实线快捷方式)，可以直接使用标识快捷方式(Eqn.(1))。当维度增加时(图3中的虚线快捷方式)，我们考虑两种选择：</p> 
<ul><li>(A)快捷方式仍然执行标识映射，增加维度时填充额外的零项。这个选项不引入额外的参数；</li><li>(B) Eqn.(2)中的投影快捷方式用于匹配维度(通过1×1卷积完成)。</li></ul> 
<p>对于这两个选项，当快捷键跨越两个大小的特征映射时，它们的步幅为2。</p> 
<h5><a id="34__199"></a>3.4. 实施</h5> 
<p>我们对 ImageNet 的实现遵循[21,41]中的实践。在[256,480]中随机采样图像的短边以进行缩放[41]。</p> 
<p>从图像或其水平翻转中随机采样 <code>224×224</code> 裁剪，并减去每像素平均值[21]。使用[21]中的标准颜色增强。</p> 
<p><strong>我们在每次卷积之后和激活之前采用批归一化</strong>(BN)[16]。</p> 
<p>我们像[13]中那样初始化权重，并从头开始训练所有的 plain/residual 网络。我们使用 SGD 的小批量大小为256。</p> 
<p>学习率从0.1开始，当误差趋于平稳时除以10，模型的训练次数可达 <code>60 × 104</code> 次。我们使用0.0001的权重衰减和0.9的动量。遵循文献[16]的做法，我们没有使用 dropout[14]。</p> 
<p>在测试中，我们采用标准的10种作物测试进行比较研究[21]。为了获得最佳结果，我们采用了[41,13]中的全卷积形式，并在多个尺度上平均得分(图像被调整大小，使较短的一面在<code>{224,256,384,480,640}</code>中)。</p> 
<blockquote> 
 <p>在这一段中，他们基本上详细介绍了所有训练过程和他们使用的所有技巧。（这解释得很好，这太酷了，这个段落有 20 行，顺便说了使用的 50个其他论文的技巧）。你需要做所有的技巧才能真正达到最高准确度，但事后看来，这不是技巧帮助他们，实际上是他们的想法。</p> 
</blockquote> 
<h4><a id="4__215"></a>4. 实验</h4> 
<h5><a id="41_ImageNet_217"></a>4.1. ImageNet分类</h5> 
<p>我们在包含1000个类的 ImageNet 2012分类数据集[36]上评估我们的方法。模型在128万张训练图像上进行训练，并在5万张验证图像上进行评估。我们还获得了由测试服务器报告的100k测试映像的最终结果。</p> 
<p>我们评估前1和前5的错误率。</p> 
<h6><a id="_plain_network_223"></a>普通的网络 plain network</h6> 
<blockquote> 
 <p><code>plain network</code> 指的就是 <strong>简单堆叠层的网络</strong>。</p> 
</blockquote> 
<p>我们首先评估了18层和34层的普通网。34层平面网如图3(中)所示。18层的平面网也是类似的形式。请参见表1了解详细的体系结构。</p> 
<p><img src="https://images2.imgbox.com/92/09/bUri3uXY_o.png" alt="在这里插入图片描述"><br> ImageNet 的架构。方括号中显示了构建块(参见图5)，并显示了堆叠块的数量。下采样由 conv3_1、conv4_1和 conv5_1进行，步长为2。</p> 
<p>表2的结果表明，较深的34层平原网比较浅的18层平原网具有更高的验证误差。为了揭示原因，在图4(左)中，我们比较了它们在训练过程中的训练/验证误差。我们已经观察到退化问题：尽管18层平面网络的解空间是34层平面网络解空间的子空间，但34层平面网络在整个训练过程中的训练误差更高。</p> 
<p>我们认为这种 <strong>优化困难不太可能是由梯度消失引起的</strong>。这些普通网络使用 <strong><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          B 
         
        
          N 
         
        
       
         BN 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">BN</span></span></span></span></span></strong> [16]进行训练，这 <strong>确保了前向传播的信号具有非零方差</strong>。我们还验证了反向传播梯度与 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         N 
        
       
      
        BN 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">BN</span></span></span></span></span> 表现出健康范数。所以向前和向后的信号都不会消失。</p> 
<p>事实上，34层的普通网络仍然能够达到有竞争力的准确率（表3），表明求解器在一定程度上是有效的。我们推测，<strong>深层普通网络可能有指数低的收敛速率</strong>，这影响了训练误差的减少。造成这种优化困难的原因将在未来进行研究。</p> 
<h6><a id="_residual_network_238"></a>残差网络 residual network</h6> 
<p>接下来我们评估18层和34层残余网(ResNets)。基线架构与上面的普通网络相同，除了向每对3×3过滤器添加一个快捷连接外，如图3(右)所示。在第一个比较中(表2和图4右)，我们对所有快捷键使用标识映射，对增加维度使用零填充(选项A)。因此，与普通对应项相比，它们没有额外的参数。</p> 
<p>我们从表2和图4中得到了三个主要观察结果。首先，残差学习的情况正好相反——34层的 ResNet 比18层的 ResNet 好2.8%。更重要的是，34层的 ResNet 显示出相当低的训练误差，并且可以推广到验证数据。这表明在这种情况下，退化问题得到了很好的解决，我们设法从增加的深度中获得精度增益。</p> 
<p>其次，与普通的同类相比，34层的 ResNet 将top-1的误差减少了3.5%(表2)，这是由于成功地减少了训练误差(图4右vs左)。这一对比验证了残差学习在极深度系统上的有效性。</p> 
<p><img src="https://images2.imgbox.com/03/f3/PIFoXRD2_o.png" alt="在这里插入图片描述"><br> 最后，我们还注意到，18层的普通/残余网络相对准确(表2)，但18层的 ResNet 收敛得更快(图4右vs左)。当网络“不太深”(这里是18层)时，当前的 SGD 求解器仍然能够找到普通网络的良好解。在这种情况下，ResNet 通过在早期阶段提供更快的收敛速度来简化优化。</p> 
<p><img src="https://images2.imgbox.com/d6/75/lphXmnUK_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="vs_251"></a>恒等vs.快捷连接</h6> 
<p>我们已经证明了无参数、恒等快捷方式有助于训练。接下来我们研究投影捷径(Eqn.(2))。在表3中，我们比较了三种选项：<br> <code>(A)</code> 零填充快捷方式用于增加维度，并且所有快捷方式都是无参数的(与表2和图4右相同)；<br> <code>(B)</code> 投影快捷键用于增加维数，其他快捷键为恒等；<br> <code>(C)</code> 所有的捷径都是投影。</p> 
<p><img src="https://images2.imgbox.com/62/a0/dSOETQru_o.png" alt="在这里插入图片描述"></p> 
<p>表3显示这三个选项都比普通选项好得多。B略好于A，我们认为这是因为A中的零填充维度确实没有残差学习。C略好于B，我们将其归因于许多(13个)投影捷径引入的额外参数。但 <strong>A/B/C之间的微小差异表明</strong>，<strong>投影捷径对于解决退化问题并非必不可少</strong>。因此，我们在本文的其余部分 <strong>不使用选项C，以减少内存/时间复杂性和模型大小</strong>。恒等快捷方式对于避免增加下面介绍的瓶颈体系结构的复杂性尤为重要。</p> 
<p><img src="https://images2.imgbox.com/fa/43/zzzWCm23_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="_264"></a>更深的瓶颈架构</h6> 
<p>接下来我们描述 ImageNet 的更深网络。由于考虑到我们所能负担的培训时间，我们将构建块修改为 <strong>瓶颈设计</strong>。对于每个残差函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
      
        \mathcal F 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span></span></span></span></span>，我们使用3层而不是2层的堆栈(图5)。<strong>这三层是 <code>1×1</code>, <code>3×3</code> 和 <code>1×1</code> 卷积，其中 <code>1×1</code> 层负责减少然后增加(恢复)维度，使 <code>3×3</code> 层成为输入/输出维度较小的瓶颈。</strong> 图5给出了一个例子，其中两种设计具有相似的时间复杂度。</p> 
<p><img src="https://images2.imgbox.com/4c/27/c1o9xQbG_o.png" alt="在这里插入图片描述"><br> ImageNet 的更深的残差函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
      
        \mathcal F 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathcal" style="margin-right: 0.0993em;">F</span></span></span></span></span>。左：ResNet34的构建块(在56×56特征映射上)，如图3所示。右：ResNet-50/101/152的“瓶颈”构建块。</p> 
<p><strong>无参数恒等快捷方式对于瓶颈体系结构尤其重要</strong>。如果将图5(右)中的恒等快捷方式替换为投影，可以看出，由于快捷方式连接到两个高维端点，时间复杂度和模型尺寸都增加了一倍。因此，恒等快捷为瓶颈设计提供了更有效的模型。</p> 
<p>50层 ResNet：我们用这个3层瓶颈块替换34层网络中的每个2层块，从而得到一个50层 ResNet(表1)。我们使用选项B来增加维度。这个模型有38亿次浮点运算。</p> 
<p>101层和152层ResNet:我们通过使用更多的3层块来构建101层和152层ResNet(表1)。值得注意的是，虽然深度显著增加，但152层ResNet(113亿FLOPs)仍然比VGG-16/19网络(153 / 196亿FLOPs)具有更低的复杂性。</p> 
<p>50/101/152层的resnet比34层的resnet更准确(表3和4)。我们没有观察到退化问题，因此从相当大的深度中获得了显着的精度增益。深度的好处体现在所有评估指标上(表3和表4)。</p> 
<h6><a id="_SOTA__279"></a>与 SOTA 比较</h6> 
<p>与最先进方法的比较。在表4中，我们与之前的最佳单模型结果进行了比较。</p> 
<p>我们的基准34层 ResNets 已经达到了非常有竞争力的精度。我们的152层 ResNet 的单模型前5验证误差为4.49%。这个单一模型的结果优于之前所有的集成结果(表5)。</p> 
<p>我们 <strong>将六个不同深度的模型组合成一个集成</strong> (在提交时只有两个152层的模型)。这导致测试集的top-5误差为3.57%(表5)。该作品在2015年 ILSVRC 上获得了第一名。</p> 
<p><img src="https://images2.imgbox.com/f6/6a/oXilRIjT_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="42_CIFAR10_289"></a>4.2. CIFAR-10和分析</h5> 
<p>我们对CIFAR-10数据集[20]进行了更多的研究，该数据集由10个类的50k训练图像和10k测试图像组成。我们提出了在训练集上进行训练并在测试集上进行评估的实验。我们的 <strong>重点是极深网络的行为</strong>，而不是推动最先进的结果，所以我们 <strong>有意使用简单的架构</strong> 如下。</p> 
<p>普通/残差架构遵循图3(中/右)中的形式。网络输入是32×32图像，每像素的平均值被减去。第一层是3×3卷积。然后我们使用一个6n层的堆栈，分别对大小为{32,16,8}的特征映射进行3×3卷积，每个特征映射大小为2n层。过滤器的个数分别为{16、32、64}。子采样是通过步长为2的卷积来完成的。网络以全局平均池、10路全连接层和softmax结束。总共有6n+2个堆叠的加权层。下表总结了该架构：</p> 
<p><img src="https://images2.imgbox.com/69/4f/XuGNwgep_o.png" alt="在这里插入图片描述"><br> 当使用快捷方式连接时，它们连接到3×3层对(总共3n个快捷方式)。在这个数据集上，我们在所有情况下都使用恒等快捷方式(即选项A)，因此我们的残差模型与普通模型具有完全相同的深度、宽度和参数数量。</p> 
<p>我们使用0.0001的权重衰减和0.9的动量，并采用[13]和BN[16]中的权重初始化，但没有dropout。这些模型在两个gpu上以128的小批量大小进行训练。我们以0.1的学习率开始，在32k和48k迭代时将其除以10，并在64k迭代时终止训练，这是在45k/5k训练/val分割上确定的。我们按照[24]中的简单数据增强方法进行训练：每边填充4个像素，从填充的图像或其水平翻转中随机采样32×32裁剪。为了进行测试，我们只评估原始32×32图像的单个视图。</p> 
<p>我们比较n ={3,5,7,9}，得出20层、32层、44层和56层网络。图6(左)显示了平面网的性能。深平面网深度增加，深度越深，训练误差越大。这种现象与 ImageNet (图4，左)和 MNIST(见[42])上的情况类似，表明这种优化难度是一个基本问题。</p> 
<p><img src="https://images2.imgbox.com/6b/b7/NMQwOzN6_o.png" alt="在这里插入图片描述"><br> 图6。CIFAR-10上的训练。虚线表示训练错误，粗线表示测试错误。左:普通网络。plain-110错误大于60%。没有显示。中间:ResNets。右:110层和1202层的resnet。</p> 
<p>图6(中)为 ResNets 的行为。同样类似于 ImageNet 案例(图4，右)，我们的ResNets 设法克服了优化困难，并在深度增加时展示了精度的提高。</p> 
<p>我们进一步探索n = 18，从而得到110层的ResNet。在这种情况下，我们发现0.1的初始学习率略大，无法开始收敛5。所以我们用0.01来预热训练，直到训练误差低于80%(大约400次迭代)，然后再回到0.1继续训练。学习计划的其余部分和前面一样。这个110层的网络具有很好的收敛性(图6中)。它具有比其他深和薄更少的参数如FitNet[35]和Highway[42]等网络(表6)，但其结果却是最先进的(6.43%，表6)。</p> 
<h6><a id="_309"></a>层响应分析</h6> 
<p><img src="https://images2.imgbox.com/2d/2a/pM393wOb_o.png" alt="在这里插入图片描述"></p> 
<p>CIFAR10上层响应的标准差(std)。响应是每个3×3层的输出，在BN之后和非线性之前。上图:图层按原始顺序显示。底部:响应按降序排列。</p> 
<p>图7显示了各层响应的标准差(std)。响应是每个3×3层的输出，在BN之后和在其他非线性(ReLU/加法)之前。对于 ResNets，该分析揭示了残差函数的响应强度。</p> 
<p>图7显示，ResNet 的响应通常比 plain 的响应小。这些结果支持我们的基本动机(第3.1节)，即残差函数通常比非残差函数更接近于零。</p> 
<p>我们还注意到更深的 ResNet 具有较小的响应幅度，如图7中 ResNet-20, 56和110的比较所证明。当有更多的层时，单个层的 ResNets 倾向于较少地修改信号。</p> 
<h6><a id="1000_323"></a>探索超过1000层</h6> 
<p>我们探索了一个超过1000层的深度模型。我们设置 n = 200，得到一个1202层的网络，按照上面的描述进行训练。我们的方法没有优化难度，这个103层的网络能够实现训练误差&lt;0.1%(图6，右)。它的测试误差仍然相当好(7.93%，表6)。</p> 
<p>但在如此激进的深度模型上，仍存在有待解决的问题。这个1202层网络的测试结果比我们的110层网络的测试结果差，虽然两者都是有类似的训练误差。我们认为这是因为过度拟合。对于这个小数据集来说，1202层的网络可能太大了(19.4M)。采用 maxout[10]或 dropout[14]等强正则化方法在该数据集上获得最佳结果([10,25,24,35])。在本文中，我们没有使用 maxout/dropout，只是通过设计简单地通过深度和薄架构强加正则化，而不会分散对优化难点的关注。但结合更强的正则化可能会改善结果，我们将在未来研究。</p> 
<h3><a id="_ResNet_329"></a>何凯明大佬现场讲解 ResNet</h3> 
<ul><li>何凯明现场讲解 ResNet：<a href="https://zhuanlan.zhihu.com/p/54072011" rel="nofollow">【AI Talking】CVPR2016 最佳论文， ResNet 现场演讲</a></li></ul> 
<h4><a id="_PPT_333"></a>大佬的 PPT</h4> 
<p>截了一些图，不得不说，大佬的答辩 PPT 做得也很棒，完全可以大创答辩的时候参考这个格式！</p> 
<p><img src="https://images2.imgbox.com/0f/0a/wkZPKD0i_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3b/d1/eqNQ1g8z_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ad/5f/FPHI81q0_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6c/ec/Ix2dHJlS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/30/5c/irsbU44M_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ac/14/edBCIfRU_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6f/22/1OcKv9Gi_o.png" alt="在这里插入图片描述"></p> 
<p>VGG 的设计经验：</p> 
<p><img src="https://images2.imgbox.com/c9/6a/GWZTfjrl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6e/d1/TtV1veJb_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/25/f7/5gKtdBf6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/df/bf/BrYRgoEx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3d/58/YxsFu1c7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0c/22/1Fj8i0cM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/59/c1/yskxpnri_o.png" alt="在这里插入图片描述"></p> 
<p>提问：</p> 
<p><img src="https://images2.imgbox.com/81/42/9EBQNO8W_o.png" alt="在这里插入图片描述"></p> 
<p>大佬的回答：</p> 
<p><img src="https://images2.imgbox.com/28/bd/ShGlOx7C_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/52/f4/hKdqunDK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f2/ae/VNTiqKFm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/13/17/OUyAQpUA_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a828f1abac0d8f7e7806041d3aea8ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计组中各种透明性总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6f8075c0896ec41de96a57c986b414a2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux ubuntu 修改ssh端口号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>