<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java.lang.string源码_JDK1.8源码——java.lang.String 类 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java.lang.string源码_JDK1.8源码——java.lang.String 类" />
<meta property="og:description" content="String 类也是java.lang 包下的一个类，算是日常编码中最常用的一个类了，那么本篇博客就来详细的介绍 String 类。
1、String 类的定义
public final class String
implements java.io.Serializable, Comparable, CharSequence {}
和上一篇博客所讲的 Integer 类一样，这也是一个用 final 声明的常量类，不能被任何类所继承,而且一旦一个String对象被创建, 包含在这个对象中的字符序列是不可改变的, 包括该类后续的所有方法都是不能修改该对象的，直至该对象被销毁，这是我们需要特别注意的(该类的一些方法看似改变了字符串，其实内部都是创建一个新的字符串，下面讲解方法时会介绍)。接着实现了 Serializable接口，这是一个序列化标志接口，还实现了 Comparable 接口，用于比较两个字符串的大小(按顺序比较单个字符的ASCII码)，后面会有具体方法实现；最后实现了 CharSequence 接口，表示是一个有序字符的集合，相应的方法后面也会介绍。
2、字段属性
/**The value is used for character storage.*/
private final charvalue[];/**Cache the hash code for the string*/
private int hash; //Default to 0
/**use serialVersionUID from JDK 1.0.2 for interoperability*/
private static final long serialVersionUID = -6849794470754667710L;
一个 String 字符串实际上是一个 char 数组。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bcd6ae58cb7e7c69f94f1395a3a73e3a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-25T05:04:03+08:00" />
<meta property="article:modified_time" content="2021-02-25T05:04:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java.lang.string源码_JDK1.8源码——java.lang.String 类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>String 类也是java.lang 包下的一个类，算是日常编码中最常用的一个类了，那么本篇博客就来详细的介绍 String 类。</p> 
 <p>1、String 类的定义</p> 
 <p>public final class String</p> 
 <p>implements java.io.Serializable, Comparable, CharSequence {}</p> 
 <p>和上一篇博客所讲的 Integer 类一样，这也是一个用 final 声明的常量类，不能被任何类所继承,而且一旦一个String对象被创建, 包含在这个对象中的字符序列是不可改变的, 包括该类后续的所有方法都是不能修改该对象的，直至该对象被销毁，这是我们需要特别注意的(该类的一些方法看似改变了字符串，其实内部都是创建一个新的字符串，下面讲解方法时会介绍)。接着实现了 Serializable接口，这是一个序列化标志接口，还实现了 Comparable 接口，用于比较两个字符串的大小(按顺序比较单个字符的ASCII码)，后面会有具体方法实现；最后实现了 CharSequence 接口，表示是一个有序字符的集合，相应的方法后面也会介绍。</p> 
 <p>2、字段属性</p> 
 <p>/**The value is used for character storage.*/</p> 
 <p>private final charvalue[];/**Cache the hash code for the string*/</p> 
 <p>private int hash; //Default to 0</p> 
 <p>/**use serialVersionUID from JDK 1.0.2 for interoperability*/</p> 
 <p>private static final long serialVersionUID = -6849794470754667710L;</p> 
 <p>一个 String 字符串实际上是一个 char 数组。</p> 
 <p>3、构造方法</p> 
 <p>String 类的构造方法很多。可以通过初始化一个字符串，或者字符数组，或者字节数组等等来创建一个 String 对象。</p> 
 <p align="center"><img src="https://images2.imgbox.com/cd/31/UFuC1JEz_o.png" alt="080f0d22ccdb3bb9fd2bb2d92501e0c0.png"></p> 
 <p>String str1 = "abc";//注意这种字面量声明的区别，文末会详细介绍</p> 
 <p>String str2 = new String("abc");</p> 
 <p>String str3= new String(new char[]{'a','b','c'})</p> 
 <p>4、equals(Object anObject) 方法</p> 
 <p>instanceof运算符 用于：判断 该运算符前面引用类型变量指向的对象是否是后面类，或者其子类、接口实现类创建的对象。如果是则返回true，否则返回false，</p> 
 <p>其使用格式如下： 引用类型变量instanceof (类、抽象类或接口)</p> 
 <p>1 /**</p> 
 <p>2 * Compares this string to the specified object. The result is {@code</p> 
 <p>3 * true} if and only if the argument is not {@codenull} and is a {@code</p> 
 <p>4 * String} object that represents the same sequence of characters as this5 * object.6 *7 *@paramanObject8 * The object to compare this {@codeString} against9 *10 *@return{@codetrue} if the given object represents a {@codeString}11 * equivalent to this string, {@codefalse} otherwise12 *13 *@see#compareTo(String)14 *@see#equalsIgnoreCase(String)15 */</p> 
 <p>16 public booleanequals(Object anObject) {17 if (this ==anObject) {18 return true;19 }20 if (anObject instanceofString) {21 String anotherString =(String)anObject;22 int n =value.length;23 if (n ==anotherString.value.length) {24 char v1[] =value;25 char v2[] =anotherString.value;26 int i = 0;27 //比较每一个字符的值</p> 
 <p>28 while (n-- != 0) {29 if (v1[i] !=v2[i])30 return false;31 i++;32 }33 return true;34 }35 }36 return false;37 }</p> 
 <p>String 类重写了 equals 方法，比较的是组成字符串的每一个字符是否相同，如果都相同则返回true，否则返回false。</p> 
 <p>5、hashCode() 方法</p> 
 <p>1 /**</p> 
 <p>2 * Compares this string to the specified object. The result is {@code</p> 
 <p>3 * true} if and only if the argument is not {@codenull} and is a {@code</p> 
 <p>4 * String} object that represents the same sequence of characters as this5 * object.6 *7 *@paramanObject8 * The object to compare this {@codeString} against9 *10 *@return{@codetrue} if the given object represents a {@codeString}11 * equivalent to this string, {@codefalse} otherwise12 *13 *@see#compareTo(String)14 *@see#equalsIgnoreCase(String)15 */</p> 
 <p>16 public booleanequals(Object anObject) {17 if (this ==anObject) {18 return true;19 }20 if (anObject instanceofString) {21 String anotherString =(String)anObject;22 int n =value.length;23 if (n ==anotherString.value.length) {24 char v1[] =value;25 char v2[] =anotherString.value;26 int i = 0;27 while (n-- != 0) {28 if (v1[i] !=v2[i])29 return false;30 i++;31 }32 return true;33 }34 }35 return false;36 }</p> 
 <p>String 类的 hashCode 算法很简单，主要就是中间的 for 循环，计算公式如下：</p> 
 <p>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</p> 
 <p>s 数组即源码中的 val 数组，也就是构成字符串的字符数组。这里有个数字 31 ，为什么选择31作为乘积因子，而且没有用一个常量来声明？主要原因有两个：</p> 
 <p>①、31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。</p> 
 <p>②、31可以被 JVM 优化，31 * i = (i &lt;&lt; 5) - i。因为移位运算比乘法运行更快更省性能。</p> 
 <p>6.split(String regex) 和 split(String regex, int limit) 方法</p> 
 <p>split(String regex) 将该字符串拆分为给定正则表达式的匹配。split(String regex , int limit) 也是一样，不过对于 limit 的取值有三种情况：</p> 
 <p>①、limit &gt; 0 ，则pattern(模式)应用n - 1 次</p> 
 <p>1 String str = "a,b,c";</p> 
 <p>2 String[] c1 = str.split(",", 2);</p> 
 <p>3 System.out.println(c1.length);//2</p> 
 <p>4 System.out.println(Arrays.toString(c1));//{"a","b,c"}</p> 
 <p>②、limit = 0 ，则pattern(模式)应用无限次并且省略末尾的空字串</p> 
 <p>1 String str2 = "a,b,c,,";</p> 
 <p>2 String[] c2 = str2.split(",", 0);</p> 
 <p>3 System.out.println(c2.length);//3</p> 
 <p>4 System.out.println(Arrays.toString(c2));//{"a","b","c"}</p> 
 <p>③、limit &lt; 0 ，则pattern(模式)应用无限次</p> 
 <p>1 String str2 = "a,b,c,,";</p> 
 <p>2 String[] c2 = str2.split(",", -1);</p> 
 <p>3 System.out.println(c2.length);//5</p> 
 <p>4 System.out.println(Arrays.toString(c2));//{"a","b","c","",""}</p> 
 <p>下面我们看看底层的源码实现。对于 split(String regex) 没什么好说的，内部调用  split(regex, 0) 方法：</p> 
 <p>1 publicString[] split(String regex) {2 return split(regex, 0);3 }</p> 
 <p>重点看 split(String regex, int limit) 的方法实现：</p> 
 <p>1 public String[] split(String regex, intlimit) {2 /*1、单个字符，且不是".$|()[{^?*+\\"其中一个3 * 2、两个字符，第一个是"\"，第二个大小写字母或者数字4 */</p> 
 <p>5 char ch = 0;6 if (((regex.value.length == 1 &amp;&amp;</p> 
 <p>7 ".$|()[{^?*+\\".indexOf(ch = regex.charAt(0)) == -1) ||</p> 
 <p>8 (regex.length() == 2 &amp;&amp;</p> 
 <p>9 regex.charAt(0) == '\\' &amp;&amp;</p> 
 <p>10 (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp;</p> 
 <p>11 ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp;</p> 
 <p>12 ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp;</p> 
 <p>13 (ch &lt; Character.MIN_HIGH_SURROGATE ||</p> 
 <p>14 ch &gt;Character.MAX_LOW_SURROGATE))15 {16 int off = 0;17 int next = 0;18 boolean limited = limit &gt; 0;//大于0，limited==true,反之limited==false</p> 
 <p>19 ArrayList list = new ArrayList&lt;&gt;();20 while ((next = indexOf(ch, off)) != -1) {21 //当参数limit&lt;=0 或者 集合list的长度小于 limit-1</p> 
 <p>22 if (!limited || list.size() &lt; limit - 1) {23 list.add(substring(off, next));24 off = next + 1;25 } else {//判断最后一个list.size() == limit - 1</p> 
 <p>26 list.add(substring(off, value.length));27 off =value.length;28 break;29 }30 }31 //如果没有一个能匹配的，返回一个新的字符串，内容和原来的一样</p> 
 <p>32 if (off == 0)33 return new String[]{this};34</p> 
 <p>35 //当 limit&lt;=0 时，limited==false,或者集合的长度 小于 limit是，截取添加剩下的字符串</p> 
 <p>36 if (!limited || list.size() </p> 
 <p>39 //当 limit == 0 时，如果末尾添加的元素为空(长度为0)，则集合长度不断减1，直到末尾不为空</p> 
 <p>40 int resultSize =list.size();41 if (limit == 0) {42 while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) {43 resultSize--;44 }45 }46 String[] result = newString[resultSize];47 return list.subList(0, resultSize).toArray(result);48 }49 return Pattern.compile(regex).split(this, limit);50 }</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a87c073a3e22b5a37362d2437d94a281/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mac中使用LaTeX的中文字体出现Package fontspec Error: The font “宋体“ cannot be found.解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9daf0969fa15d34206482bf33ce7b4b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ResNet-50模型图像分类示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>