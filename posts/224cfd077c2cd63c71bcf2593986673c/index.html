<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux cpu、memory 、io、网络、文件系统多种类型负荷模拟调测方法工具 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux cpu、memory 、io、网络、文件系统多种类型负荷模拟调测方法工具" />
<meta property="og:description" content="目录
一、概述
二、stress介绍和使用
2.1 介绍
2.2 使用
三、stress-ng介绍和使用
3.1 介绍
3.2 使用
3.3 实例
四、sysbench
4.1 介绍
4.2 使用
五、lmbench
5.1 介绍
5.2 使用
一、概述 今天介绍两款cpu负荷调试工具，用来模拟多种类型的负载。主要用来模拟CPU 资源、内存资源、 I/O资源、网络资源、文件系统操作等资源负荷占比。
二、stress介绍和使用 2.1 介绍 是一个用于测试系统稳定性和性能的工具。它可以模拟系统在高负载下的运行情况，帮助评估系统的表现，调试和排查问题。
2.2 使用 使用 stress 工具时，可以根据需要选择不同的选项和参数来配置其行为。以下是 stress 工具的基本使用方法：
安装 stress 工具：
在 Linux 系统上，可以使用包管理器进行安装。例如，在 Ubuntu 上可以使用以下命令进行安装；在嵌入式yocto环境中可以用bitbake stress来编译，然后传输到设备中运行：
sudo apt-get install stress 运行 stress 命令：使用以下命令来运行 stress 工具：
stress [选项] [参数] 选项：可以使用不同的选项来配置 stress 的行为。一些常用的选项包括：
-c &lt;N&gt;：创建 N 个 worker 进程来占用 CPU 资源。-m &lt;N&gt;：创建 N 个 worker 进程来占用内存资源。-i &lt;N&gt;：创建 N 个 worker 进程来占用 I/O 资源。-d &lt;N&gt;：创建 N 个 worker 进程来占用硬盘 I/O 资源。-t &lt;时间&gt;：运行 stress 的时间长度，单位可以是秒（s）、分钟（m）、小时（h）等。-v：显示详细的输出信息。其他选项可以通过 man stress 命令查看相关文档。 参数：根据选项的不同，可以提供相应的参数。例如，对于 -c 选项，可以指定要创建的 worker 进程数量。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/224cfd077c2cd63c71bcf2593986673c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T13:13:08+08:00" />
<meta property="article:modified_time" content="2024-01-08T13:13:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux cpu、memory 、io、网络、文件系统多种类型负荷模拟调测方法工具</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0" rel="nofollow">一、概述</a></p> 
<p style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81stress%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8" rel="nofollow">二、stress介绍和使用</a></p> 
<p style="margin-left:40px;"><a href="#2.1%20%E4%BB%8B%E7%BB%8D" rel="nofollow">2.1 介绍</a></p> 
<p style="margin-left:40px;"><a href="#2.2%20%E4%BD%BF%E7%94%A8" rel="nofollow">2.2 使用</a></p> 
<p style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81stress-ng%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8" rel="nofollow">三、stress-ng介绍和使用</a></p> 
<p style="margin-left:40px;"><a href="#3.1%20%E4%BB%8B%E7%BB%8D" rel="nofollow">3.1 介绍</a></p> 
<p style="margin-left:40px;"><a href="#3.2%20%E4%BD%BF%E7%94%A8" rel="nofollow">3.2 使用</a></p> 
<p style="margin-left:40px;"><a href="#3.3%20%E5%AE%9E%E4%BE%8B" rel="nofollow">3.3 实例</a></p> 
<p style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81sysbench" rel="nofollow">四、sysbench</a></p> 
<p style="margin-left:40px;"><a href="#4.1%20%E4%BB%8B%E7%BB%8D" rel="nofollow">4.1 介绍</a></p> 
<p style="margin-left:40px;"><a href="#4.2%20%E4%BD%BF%E7%94%A8" rel="nofollow">4.2 使用</a></p> 
<p style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81lmbench" rel="nofollow">五、lmbench</a></p> 
<p style="margin-left:40px;"><a href="#5.1%20%E4%BB%8B%E7%BB%8D" rel="nofollow">5.1 介绍</a></p> 
<p style="margin-left:40px;"><a href="#5.2%20%E4%BD%BF%E7%94%A8" rel="nofollow">5.2 使用</a></p> 
<hr> 
<p> </p> 
<h2>一、概述</h2> 
<p>         今天介绍两款cpu负荷调试工具，用来模拟多种类型的负载。主要用来模拟CPU 资源、内存资源、 I/O资源、网络资源、文件系统操作等资源负荷占比。</p> 
<h2>二、stress介绍和使用</h2> 
<h3>2.1 介绍</h3> 
<p>     是一个用于测试系统稳定性和性能的工具。它可以模拟系统在高负载下的运行情况，帮助评估系统的表现，调试和排查问题。</p> 
<h3>2.2 使用</h3> 
<blockquote> 
 <p>使用 stress 工具时，可以根据需要选择不同的选项和参数来配置其行为。以下是 stress 工具的基本使用方法：</p> 
 <p>安装 stress 工具：</p> 
 <p>在 Linux 系统上，可以使用包管理器进行安装。例如，在 Ubuntu 上可以使用以下命令进行安装；在嵌入式yocto环境中可以用bitbake stress来编译，然后传输到设备中运行：</p> 
 <ul><li> <pre><code>sudo apt-get install stress
</code></pre> </li><li> <p>运行 stress 命令：使用以下命令来运行 stress 工具：</p> <pre><code>stress [选项] [参数]
</code></pre> 
   <ul><li> <p>选项：可以使用不同的选项来配置 stress 的行为。一些常用的选项包括：</p> 
     <ul><li><code>-c &lt;N&gt;</code>：创建 N 个 worker 进程来占用 CPU 资源。</li><li><code>-m &lt;N&gt;</code>：创建 N 个 worker 进程来占用内存资源。</li><li><code>-i &lt;N&gt;</code>：创建 N 个 worker 进程来占用 I/O 资源。</li><li><code>-d &lt;N&gt;</code>：创建 N 个 worker 进程来占用硬盘 I/O 资源。</li><li><code>-t &lt;时间&gt;</code>：运行 stress 的时间长度，单位可以是秒（s）、分钟（m）、小时（h）等。</li><li><code>-v</code>：显示详细的输出信息。</li><li>其他选项可以通过 <code>man stress</code> 命令查看相关文档。</li></ul></li><li> <p>参数：根据选项的不同，可以提供相应的参数。例如，对于 <code>-c</code> 选项，可以指定要创建的 worker 进程数量。</p> </li></ul></li><li> <p>示例使用，以下是一些示例使用 stress 的命令：</p> 创建 4 个 worker 进程来占用 CPU 资源，并运行 10 秒钟： 
   <ul><li> <pre><code>stress -c 4 -t 10s
</code></pre> </li><li> <p>创建 2 个 worker 进程来占用内存资源，每个进程占用 1GB 内存，并运行 5 分钟：</p> <pre><code>stress -m 2 --vm-bytes 1G -t 5m
</code></pre> </li><li> <p>创建 4 个 worker 进程来占用 I/O 资源，并运行 1 小时：</p> <pre><code>stress -i 4 -t 1h
</code></pre> </li></ul></li></ul> 
 <p> </p> 
</blockquote> 
<blockquote> 
 <p>./stress --help</p> 
 <p>-?, --help         show this help statement<br>      --version      show version statement<br>  -v, --verbose      be verbose<br>  -q, --quiet        be quiet<br>  -n, --dry-run      show what would have been done<br>  -t, --timeout N    timeout after N seconds<br>      --backoff N    wait factor of N microseconds before work starts<br>  -c, --cpu N        spawn N workers spinning on sqrt()<br>  -i, --io N         spawn N workers spinning on sync()<br>  -m, --vm N         spawn N workers spinning on malloc()/free()<br>      --vm-bytes B   malloc B bytes per vm worker (default is 256MB)<br>      --vm-stride B  touch a byte every B bytes (default is 4096)<br>      --vm-hang N    sleep N secs before free (default none, 0 is inf)<br>      --vm-keep      redirty memory instead of freeing and reallocating<br>  -d, --hdd N        spawn N workers spinning on write()/unlink()<br>      --hdd-bytes B  write B bytes per hdd worker (default is 1GB)</p> 
 <p>Example: stress --cpu 8 --io 4 --vm 2 --vm-bytes 128M --timeout 10s</p> 
 <p>Note: Numbers may be suffixed with s,m,h,d,y (time) or B,K,M,G (size)</p> 
</blockquote> 
<h2>三、stress-ng介绍和使用</h2> 
<h3>3.1 介绍</h3> 
<p>      stress-ng 是一个功能强大的压力测试工具，它可以用于评估系统的稳定性、资源分配、性能和硬件稳定性。它提供了多种测试模式和选项，可以模拟 CPU、内存、磁盘、网络等各种负载，并且支持自定义测试参数。</p> 
<p><img src="https://images2.imgbox.com/3f/4a/nmNPy0IR_o.png" alt="34cd6aa7090a4f9dabfa0b7e77a0a300.png"></p> 
<h3>3.2 使用</h3> 
<blockquote> 
 <p><strong>安装 stress-ng</strong>：<br> 使用适合你的操作系统的软件包管理器来安装 stress-ng。例如，在 Ubuntu 上可以使用以下命令进行安装:<br> sudo apt-get install stress-ng</p> 
 <p>或者在在嵌入式yocto环境中可以用bitbake stress-ng来编译安装（需要库文件libaio.so.1），然后传输到设备中运行；<br> 基本用法：<br> 要运行 stress-ng，你可以使用以下命令：<br> stress-ng [选项]<br> 常用选项：<br><strong>--cpu &lt;N&gt;：指定要创建的 CPU worker 进程数量。<br> --cpu-load &lt;P&gt;：指定每个 CPU worker 进程占用 CPU 资源的百分比。<br> --vm &lt;N&gt;：指定要创建的虚拟内存 worker 进程数量。<br> --vm-bytes &lt;B&gt;：指定每个虚拟内存 worker 进程使用的内存大小。<br> --io &lt;N&gt;：指定要创建的磁盘 I/O worker 进程数量。<br> --hdd &lt;N&gt;：指定要创建的磁盘访问 worker 进程数量。<br> --timeout &lt;T&gt;：指定测试运行的时间长度。<br> --metrics-brief：以简洁的格式输出测试结果指标。</strong><br> 示例用法：<br> 以下是一些示例用法来演示 stress-ng 的不同测试模式：<br> 模拟 CPU 负载：</p> 
 <p>创建 4 个 CPU worker 进程，每个进程占用 CPU 资源的 50%。<br> stress-ng --cpu 4 --cpu-load 50</p> 
 <p><br> 模拟内存负载：</p> 
 <p>创建 2 个虚拟内存 worker 进程，每个进程使用 1GB 的内存。<br> stress-ng --vm 2 --vm-bytes 1G</p> 
 <p><br> 模拟磁盘 I/O 负载：</p> 
 <p>创建 4 个磁盘 I/O worker 进程。<br> stress-ng --io 4</p> 
 <p> </p> 
 <p>模拟网络负载：<br> 创建 10 个 TCP 连接并保持连接：<br> stress-ng --tcp 10<br> 创建 5 个 UDP 流量生成器：<br> stress-ng --udp 5<br> 创建 2 个网络带宽测试器：<br> stress-ng --net 2<br> 在网络延迟测试中引入 100 毫秒的延迟：<br> stress-ng --net-delay 100ms<br> 在网络丢包测试中引入 5% 的丢包：<br> stress-ng --net-burst 5</p> 
 <p> </p> 
 <p>文件系统操作：</p> 
 <p>文件创建和删除测试：<br> --fs-create &lt;N&gt;：创建 N 个文件并保持打开状态。<br> --fs-delete &lt;N&gt;：删除 N 个已存在的文件。<br> 文件读取和写入测试：<br> --fs-read &lt;N&gt;：从已存在的文件中进行 N 次读取操作。<br> --fs-write &lt;N&gt;：向已存在的文件中进行 N 次写入操作。<br> 文件元数据操作测试：<br> --fs-lookup &lt;N&gt;：进行 N 次文件查找操作。<br> --fs-attribute &lt;N&gt;：进行 N 次文件属性操作。<br> 文件系统缓存刷新测试：</p> 
 <p>--fs-sync &lt;N&gt;：进行 N 次文件系统缓存刷新操作。<br> 示例用法：<br> 以下是一些示例用法来演示 stress-ng 的文件系统操作模拟：</p> 
 <p>创建 100 个文件并保持打开状态：<br> stress-ng --fs-create 100</p> 
 <p>删除 50 个已存在的文件：<br> stress-ng --fs-delete 50</p> 
 <p>从已存在的文件中进行 1000 次读取操作：<br> stress-ng --fs-read 1000</p> 
 <p>向已存在的文件中进行 500 次写入操作：<br> stress-ng --fs-write 500</p> 
 <p>进行 200 次文件查找操作：<br> stress-ng --fs-lookup 200</p> 
 <p>进行 100 次文件属性操作：<br> stress-ng --fs-attribute 100</p> 
 <p>进行 50 次文件系统缓存刷新操作：<br> stress-ng --fs-sync 50</p> 
 <p> </p> 
 <p>使用 stress-ng --help 命令查看更多详细的说明。<br>  </p> 
</blockquote> 
<h3>3.3 实例</h3> 
<pre><code> ./ress-ng --cpu 4 --cpu-load 20
stress-ng: info:  [468] defaulting to a 86400 second (1 day, 0.00 secs) run per stressor
stress-ng: info:  [468] dispatching hogs: 4 cpu
stress-ng: info:  [468] cache allocate: using built-in defaults as unable to determine cache details</code></pre> 
<pre><code>
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  469 root      20   0   13388   6620   1964 R  40.0   1.0   0:02.97 stress-ng+
  470 root      20   0   13388   6616   1964 R  39.0   1.0   0:03.02 stress-ng+
  472 root      20   0   13388   6604   1948 R  37.1   1.0   0:03.20 stress-ng+
  471 root      20   0   13388   6620   1964 R  36.2   1.0   0:02.89 stress-ng+</code></pre> 
<h2>四、sysbench</h2> 
<h3>4.1 介绍</h3> 
<p>     是一个多功能的基准测试工具，可用于测试 CPU、内存、文件 I/O、数据库性能等。</p> 
<h3>4.2 使用</h3> 
<blockquote> 
 <p>以下是 Sysbench 的一些常见用法：</p> 
 <p>CPU 压力测试：</p> 
 <p>sysbench cpu --threads=&lt;线程数&gt; run<br> 这将使用指定数量的线程对 CPU 进行压力测试。</p> 
 <p>内存压力测试：</p> 
 <p>sysbench memory --threads=&lt;线程数&gt; --memory-block-size=&lt;块大小&gt; --memory-total-size=&lt;总大小&gt; run<br> 这将模拟指定大小的内存块在指定数量的线程间进行读写操作。</p> 
 <p>文件 I/O 压力测试：</p> 
 <p>sysbench fileio --file-total-size=&lt;总大小&gt; --file-test-mode=&lt;测试模式&gt; prepare<br> sysbench fileio --file-total-size=&lt;总大小&gt; --file-test-mode=&lt;测试模式&gt; --file-num=&lt;文件数&gt; --threads=&lt;线程数&gt; run<br> 这将在准备阶段创建指定大小的文件，并在运行阶段模拟指定数量的线程对文件进行读写操作。</p> 
 <p>数据库性能测试：</p> 
 <p>sysbench oltp_&lt;数据库引擎&gt; --db-driver=&lt;数据库驱动&gt; --mysql-host=&lt;主机&gt; --mysql-port=&lt;端口&gt; --mysql-user=&lt;用户名&gt; --mysql-password=&lt;密码&gt; --mysql-db=&lt;数据库名&gt; --tables=&lt;表数量&gt; --table-size=&lt;表大小&gt; prepare<br> sysbench oltp_&lt;数据库引擎&gt; --db-driver=&lt;数据库驱动&gt; --mysql-host=&lt;主机&gt; --mysql-port=&lt;端口&gt; --mysql-user=&lt;用户名&gt; --mysql-password=&lt;密码&gt; --mysql-db=&lt;数据库名&gt; --tables=&lt;表数量&gt; --table-size=&lt;表大小&gt; --threads=&lt;线程数&gt; --time=&lt;持续时间&gt; run<br> 这将在准备阶段创建指定数量和大小的数据库表，并在运行阶段模拟指定数量的线程对数据库进行读写操作</p> 
</blockquote> 
<h2>五、lmbench</h2> 
<h3>5.1 介绍</h3> 
<p>      Lmbench 是一个用于测量系统性能和硬件特性的工具集，它包含多个小型的基准测试程序。</p> 
<h3>5.2 使用</h3> 
<blockquote> 
 <p>以下是 Lmbench 的一些常见用法：</p> 
 <p>测量内存访问延迟：</p> 
 <p>lmbench_lat_mem_rd<br> 这将测量内存读取的延迟。</p> 
 <p>测量缓存访问延迟：</p> 
 <p>lmbench_lat_ctx<br> 这将测量缓存访问的延迟。</p> 
 <p>测量进程创建和上下文切换时间：</p> 
 <p>lmbench_lat_proc<br> 这将测量进程创建和上下文切换的时间。</p> 
 <p>测量文件 I/O 延迟和带宽：</p> 
 <p>lmbench_lat_fs<br> 这将测量文件 I/O 的延迟和带宽。</p> 
 <p>测量网络延迟和带宽：</p> 
 <p>lmbench_lat_net<br> 这将测量网络延迟和带宽。</p> 
</blockquote> 
<p>更多调试方法工具，待收集和分享。...</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5beb814d386014394145ecd645dea97d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java常见的设计模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cda03b70a15b32792316e51fcaaabc8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">借助 ControlNet 生成艺术二维码 – 基于 Stable Diffusion 的 AI 绘画方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>