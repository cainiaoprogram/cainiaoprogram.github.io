<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>多个事务并发执行（交叉并发方式、同时并发方式）、并发操作带来数据不一致性主要包括（丢失修改，不可重复读，读“脏”数据）、封锁（概念、类型）、活锁和死锁（概念、预防／解决方法） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="多个事务并发执行（交叉并发方式、同时并发方式）、并发操作带来数据不一致性主要包括（丢失修改，不可重复读，读“脏”数据）、封锁（概念、类型）、活锁和死锁（概念、预防／解决方法）" />
<meta property="og:description" content="并发（同时）控制学习内容主线 引言 1、多个事务串行执行。 执行方式:第一个事务做完——》第二个事务... 优点：调度简单（按一定次序执行），事务之间不会互相干扰，不会破坏事务的ACID特性。 缺点：不能充分利用资源 2、多个事务并发执行。 →交叉并发方式（单CPU）
→同时并发方式(多CPU)
本章讨论的数据库系统并发控制技术是以单处理机系统为基础的交叉并发方式。
事务并发执行可能带来的数据不一致问题 并发操作带来数据不一致性主要包括: →丢失修改： T１事务获取数据为16，T２事务获取数据为16，T１将数据－１为15，而T２的值仍为16，所以T２将获取的数据－１后仍为15 →不可重复读： T1事务没有处理完，T2事务将数据修改后，T1数据查询并使用了修改后的事务
→读“脏”数据： T1事务修改了数据的值：200，T2获取T１的值：200，此时T1出现故障，数据恢复为100，而此时，T2获取数据的值为200，与此时数据的值不符。
1、丢失修改。以飞机订票为例 T甲 售票点 T乙售票点时刻1：R(A)=16（即：有16张票）时刻2R(A)=16 时刻3：
A=A-1
W(A)=15 卖出一张票（将剩下的票写回去）
时刻4 A=A-1 W(A)=15 卖出一张票（将剩下的票写回去）
数据覆盖导致丢失修改甲事务的执行被乙事务干扰，破坏了事务的隔离性
2、不可重复读（不可重复获取数据） T1 事务（R为读） T2事务 时刻1：
R(A)=50 R(B)=100
求和=150
时刻2： R(B)=100
B=B*2
W(B)=200
时刻3：
R(A)=50 R(B)=200（重复了）
求和=250
(验算不对)
破坏了事务的隔离性 3、读“脏”数据 T1 事务（R为读） T2事务 时刻1：
R(C)=100 C=C*2 W(C)=200
时刻2：R(C)=200 时刻3：
出现故障，回滚数据
ROLLBACK C恢复为100
破坏了事务的隔离性 产生上述三类数据不一致性的主要原因是并发操作破坏了事务的隔离性。并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性。
解决办法:封锁
封锁 1、封锁概念 封锁就是事务T在对某个数据对象(例如表、记录等)操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。
2、基本的封锁类型有两种 排他锁(简称x锁): 排他锁又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。 （加锁事务可读可改，其它事务不可读不可改）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/df0db0ff837396727ca51d08d01454a6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-04T23:32:38+08:00" />
<meta property="article:modified_time" content="2022-06-04T23:32:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">多个事务并发执行（交叉并发方式、同时并发方式）、并发操作带来数据不一致性主要包括（丢失修改，不可重复读，读“脏”数据）、封锁（概念、类型）、活锁和死锁（概念、预防／解决方法）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>并发（同时）控制学习内容主线</h2> 
<p> <img alt="" height="389" src="https://images2.imgbox.com/90/af/WnbyZr66_o.png" width="766"></p> 
<h2><strong>引言</strong></h2> 
<h4><strong>1、多个事务串行执行。</strong></h4> 
<h4><strong>执行方式:第一个事务做完——》第二个事务...</strong></h4> 
<h4><strong>优点：调度简单（按一定次序执行），事务之间不会互相干扰，不会破坏事务的ACID特性。</strong></h4> 
<h4><strong>缺点：不能充分利用资源</strong></h4> 
<h4><strong>2、多个事务并发执行。</strong></h4> 
<p><strong>        →<span style="color:#fe2c24;">交叉并发方式</span>（单CPU）</strong></p> 
<p><strong>        →同时并发方式(多CPU)<br>         本章讨论的数据库系统并发控制技术是以<span style="color:#fe2c24;">单处理机</span>系统为基础的交叉并发方式。</strong></p> 
<h2><strong>事务并发执行可能带来的数据不一致问题</strong></h2> 
<h3><strong>        <span style="color:#fe2c24;">并发操作</span>带来数据不一致性主要包括:</strong></h3> 
<h4><strong>                →<span style="color:#fe2c24;">丢失修改：</span></strong></h4> 
<p><strong><span style="color:#fe2c24;">                      </span>T１事务获取数据为16，T２事务获取数据为16，T１将数据－１为15，而T２的值仍为16，所以T２将获取的数据－１后仍为15  </strong></p> 
<h4><strong>                →<span style="color:#fe2c24;">不可重复读：</span></strong></h4> 
<p><strong><span style="color:#fe2c24;">                        </span>T1事务没有处理完，T2事务将数据修改后，T1数据查询并使用了修改后的事务</strong></p> 
<h4><strong>              　→<span style="color:#fe2c24;">读“脏”数据：</span></strong></h4> 
<p>                        <strong>T1事务修改了数据的值：200，T2获取T１的值：200，此时T1出现故障，数据恢复为100，而此时，T2获取数据的值为200，与此时数据的值不符。</strong></p> 
<h4>                1、丢失修改。以飞机订票为例</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>T甲  售票点</strong></td><td><strong> T乙售票点</strong></td></tr><tr><td><strong>时刻1：R(A)=16（即：有16张票）</strong></td><td></td></tr><tr><td></td><td></td></tr><tr><td><strong>时刻2</strong></td><td><strong>R(A)=16</strong></td></tr><tr><td></td><td></td></tr><tr><td> <p><strong>时刻3：</strong></p> <p><strong>A=A-1</strong></p> <p><strong>W(A)=15 </strong></p> <p><strong>卖出一张票（将剩下的票写回去）</strong></p> </td><td></td></tr><tr><td></td><td></td></tr><tr><td><strong>时刻4</strong></td><td> <p><strong>A=A-1 W(A)=15 </strong></p> <p><strong>卖出一张票（将剩下的票写回去）</strong></p> </td></tr></tbody></table> 
<p>                  <strong> <span style="color:#fe2c24;">数据覆盖</span>导致丢失修改甲事务的执行被乙事务干扰，<span style="color:#fe2c24;">破坏了事务的隔离性</span></strong></p> 
<h4>     <strong>           2、不可重复读（不可重复获取数据）</strong></h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:239px;"><strong>T1 事务（R为读）</strong></td><td style="width:259px;"><strong> T2事务    </strong></td></tr><tr><td style="width:239px;"> <p><strong>时刻1：</strong></p> <p><strong>R(A)=50 </strong></p> <p><strong>R(B)=100</strong></p> <p><strong>求和=150</strong></p> </td><td style="width:259px;"></td></tr><tr><td style="width:239px;"><strong>时刻2：</strong></td><td style="width:259px;"> <p><strong>R(B)=100</strong></p> <p><strong>B=B*2</strong></p> <p><strong>W(B)=200</strong></p> </td></tr><tr><td style="width:239px;"> <p><strong>时刻3：</strong></p> <p><strong>R(A)=50 </strong></p> <p><strong>R(B)=200（重复了）</strong></p> <p><strong>求和=250</strong></p> <p><strong>(验算不对)</strong></p> </td><td style="width:259px;"></td></tr></tbody></table> 
<p>               <span style="color:#fe2c24;">   <strong> 破坏了事务的隔离性    </strong></span></p> 
<h4>                 <strong>3、读“脏”数据</strong></h4> 
<p></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:267px;"><strong>T1 事务（R为读）</strong></td><td style="width:231px;"><strong> T2事务    </strong></td></tr><tr><td style="width:267px;"> <p><strong>时刻1：</strong></p> <p><strong>R(C)=100 </strong></p> <p><strong>C=C*2 </strong></p> <p><strong>W(C)=200</strong></p> </td><td style="width:231px;"></td></tr><tr><td style="width:267px;"><strong>时刻2：</strong></td><td style="width:231px;"><strong>R(C)=200 </strong></td></tr><tr><td style="width:267px;"> <p><strong>时刻3：</strong></p> <p><strong>出现故障，回滚数据</strong></p> <p><strong>ROLLBACK </strong></p> <p><strong>C恢复为100</strong></p> </td><td style="width:231px;"></td></tr></tbody></table> 
<p><strong>                 <span style="color:#fe2c24;">破坏了事务的隔离性  </span> </strong></p> 
<p><strong>        产生上述三类数据不一致性的主要原因是并发操作<span style="color:#fe2c24;">破坏了事务的隔离性</span>。并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性。</strong></p> 
<p><strong>        解决办法:<span style="color:#fe2c24;">封锁</span></strong></p> 
<h2><strong>封锁</strong></h2> 
<h3><strong>        1、封锁概念</strong></h3> 
<p><strong>        <span style="color:#fe2c24;">封锁</span>就是事务T在对某个数据对象(例如表、记录等)<span style="color:#ff9900;">操作</span><span style="color:#956fe7;">之前</span>，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，<span style="color:#fe2c24;">在事务T</span><span style="color:#956fe7;">释放</span><span style="color:#fe2c24;">它的</span><span style="color:#956fe7;">锁之前</span><span style="color:#fe2c24;">，其它的事务不能更新此数据对象</span>。</strong></p> 
<h3><strong>        2、基本的封锁类型有两种</strong></h3> 
<h4><strong><span style="color:#fe2c24;">        排他锁(简称x锁)</span>:</strong></h4> 
<p><strong>        排他锁又称为<span style="color:#fe2c24;">写锁</span>，若<span style="color:#ff9900;">事务T</span>对数据<span style="color:#ff9900;">对象A</span><span style="color:#fe2c24;">加上X锁</span>，则<span style="color:#fe2c24;">只允许</span><span style="color:#ff9900;">T读取</span>和<span style="color:#ff9900;">修改A</span>，<span style="color:#fe2c24;">其它事务</span>都<span style="color:#ff9900;">不能再对A</span><span style="color:#956fe7;">加任何类型的锁</span>，直到T释放A上的锁。这就保证了其他事务在T<span style="color:#ff9900;">释放</span>A上的<span style="color:#ff9900;">锁之前</span><span style="color:#fe2c24;">不能再读取和修改A</span>。</strong> <span style="color:#1c7331;"><strong>（加锁事务可读可改，其它事务不可读不可改）</strong></span></p> 
<h4>        <strong><span style="color:#fe2c24;">共享锁(简称S锁):</span></strong></h4> 
<p><strong>        共享锁又称为读锁，若事务T对数据对象A<span style="color:#fe2c24;">加上S锁</span>，则<span style="color:#fe2c24;">其它事务</span><span style="color:#956fe7;">只能</span><span style="color:#fe2c24;">再对A加s锁</span>，而<span style="color:#ff9900;">不能加X锁</span>，直到T释放A上的S锁。这就保证了<span style="color:#fe2c24;">其他事务可以读A</span>，但在T释放A上的s锁之前<span style="color:#956fe7;">不能</span><span style="color:#fe2c24;">对A作</span><span style="color:#956fe7;">任何修改</span>。<span style="color:#1c7331;">（加锁事务可读可改，其它事务可读不可改）</span></strong></p> 
<h4><strong>        封锁协议：</strong></h4> 
<p><strong>        在运用x锁和S锁这两种基本封锁对数据对象加锁时，还需要约定一些规则。如，申请什么样的锁，持锁时间，何时释放等。这些规则称为封锁协议（协议为规则的集合）。</strong></p> 
<h4><strong>        →一级封锁协议：</strong></h4> 
<p><strong>        事务T在<span style="color:#fe2c24;">修改数据</span>R之<span style="color:#fe2c24;">前必须</span>先对其<span style="color:#fe2c24;">加X锁</span>，直到<span style="color:#fe2c24;">事务结束才释放</span>。(解决丢失修改问题)</strong></p> 
<h4><strong>         →二级封锁协议：</strong></h4> 
<p><strong>        在<span style="color:#fe2c24;">一级封锁协议</span><span style="color:#ff9900;">基础上</span>增加事务T在<span style="color:#fe2c24;">读取数据</span>R之<span style="color:#fe2c24;">前必须</span>先对其<span style="color:#fe2c24;">加s锁</span>，<span style="color:#956fe7;">读完后</span><span style="color:#fe2c24;">即释放s锁</span>。(解决读脏数据问题)</strong></p> 
<h4><strong>        →三级封锁协议：</strong></h4> 
<p><strong>        在<span style="color:#fe2c24;">一级封锁协议的</span><span style="color:#ff9900;">基础上</span>增加事务T在<span style="color:#fe2c24;">读取数据</span>R之前<span style="color:#fe2c24;">必须先</span>对其<span style="color:#fe2c24;">加S锁</span>，<span style="color:#fe2c24;">直到</span><span style="color:#956fe7;">事务结束</span><span style="color:#fe2c24;">才释放</span>。(解决不可重复读问题)</strong></p> 
<h3><strong>        3、用封锁机制解决丢失修改、不可重复读和读“脏”数据问题    </strong></h3> 
<h4><strong>                (1)解决丢失修改问题    </strong></h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong> T1</strong></td><td><strong>T2 </strong></td></tr><tr><td> <p><strong>①Xlock A  </strong></p> <p><strong>（事务T1获得对数据A的排他锁）</strong></p> </td><td></td></tr><tr><td><strong>② R(A)=16  （读取A数据）</strong></td><td></td></tr><tr><td><strong>③</strong></td><td> <p><strong>Xlock A</strong></p> <p><strong>（事务T2对数据A申请加排他锁，</strong></p> <p><strong>此时事务T1正在使用排他锁，</strong></p> <p><strong>所以T2事务只能等待）</strong></p> </td></tr><tr><td> <p><strong>④A←A-1 </strong></p> <p><strong>W(A)=15 （写入数据）</strong></p> <p><strong>事务T1对数据A进行修改</strong></p> </td><td><strong>等待   </strong></td></tr><tr><td> <p><strong>Commit </strong></p> <p><strong>（提交事务）</strong></p> </td><td><strong>等待 </strong></td></tr><tr><td> <p><strong>Unlock A</strong></p> <p><strong>（事务T1释放排他锁）</strong></p> </td><td><strong>等待 </strong></td></tr><tr><td><strong>⑤</strong></td><td> <p><strong>获得Xlock A </strong></p> <p><strong>（T2事务获得A的排他锁）</strong></p> </td></tr><tr><td></td><td> <p><strong>R(A)=15</strong></p> <p><strong>（T2事务读取得A的值为15）</strong></p> </td></tr><tr><td><strong>⑥</strong></td><td> <p><strong>A←A-1  </strong></p> <p><strong>对A进行操作</strong></p> <p><strong>W(A)=14</strong></p> <p><strong>将数据写入A</strong></p> </td></tr><tr><td></td><td> <p><strong>Commit </strong></p> <p><strong>（提交事务T2）</strong></p> </td></tr><tr><td></td><td> <p><strong>Unlock A </strong></p> <p><strong>（释放排他锁）</strong></p> </td></tr></tbody></table> 
<h4><strong>              (2)解决不可重复读问题 </strong></h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong> T1事务（只读取数据）</strong></td><td> <p><strong>T2事务（读／写数据）</strong></p> </td></tr><tr><td> <p><strong>①Slock A </strong></p> <p><strong>   Slock B  </strong></p> <p><strong>（申请对A和B加共享锁）</strong></p> </td><td></td></tr><tr><td> <p><strong>R(A)=50</strong></p> <p><strong>R(B)=100</strong></p> <p><strong>求和=150   </strong></p> </td><td></td></tr><tr><td><strong>②    </strong></td><td> <p><strong>Xlock B</strong></p> <p><strong>（T2申请排他锁）</strong></p> </td></tr><tr><td> <p><strong>③R(A)=50</strong></p> <p><strong>R(B)=100</strong></p> <p><strong>求和=150         </strong></p> </td><td> <p><strong>等待</strong></p> <p><strong>（数据B，已经被T1加了共享锁）</strong></p> </td></tr><tr><td> <p><strong>Commit</strong></p> <p><strong>（提交T1事务）</strong></p> </td><td><strong>等待</strong></td></tr><tr><td> <p><strong>Unlock A</strong></p> <p><strong>Unlock B</strong></p> <p><strong>（释放A和B数据上的共享锁）</strong></p> </td><td><strong>等待</strong></td></tr><tr><td><strong>④</strong></td><td><strong>获得XlockB</strong></td></tr><tr><td></td><td><strong>R(B)=100</strong></td></tr><tr><td></td><td><strong>B←B*2</strong></td></tr><tr><td>⑤</td><td> <p><strong>W(B)=200</strong></p> <p><strong>（将修改后的B数据写入）</strong></p> </td></tr><tr><td></td><td><strong>Commit</strong></td></tr><tr><td></td><td> <p><strong>Unlock B</strong></p> <p><strong>（释放B上的排他锁）</strong></p> </td></tr></tbody></table> 
<h4><strong>             （3）解决读“脏”数据问题</strong></h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>T1 （读写数据C）</strong></td><td><strong>T2(只读取数据C)</strong></td></tr><tr><td> <p><strong>①Xlock C</strong></p> <p><strong>（T1事务申请为数据C加排他锁（x锁））</strong></p> </td><td><strong>  </strong></td></tr><tr><td> <p><strong>R(C)=100 </strong></p> <p><strong>(T1获取C的值)</strong></p> </td><td></td></tr><tr><td> <p><strong>C←C*2</strong></p> <p><strong>W(C)=200 </strong></p> <p><strong>（T1事务写入C的值）</strong></p> </td><td></td></tr><tr><td><strong>②</strong></td><td> <p><strong> Slock C</strong></p> <p><strong>（申请共享锁（s锁））</strong></p> </td></tr><tr><td></td><td> <p><strong>等待</strong></p> <p><strong>（数据C已经加入排他锁）</strong></p> </td></tr><tr><td> <p><strong>③ROLLBACK </strong></p> <p><strong>(事务T1出现故障，数据回滚)   </strong></p> </td><td><strong>等待</strong></td></tr><tr><td><strong> 回滚结果：c恢复为100   </strong></td><td><strong>等待</strong></td></tr><tr><td> <p><strong>Unlock C    </strong></p> <p><strong>（释放排他锁）</strong></p> </td><td><strong>等待</strong></td></tr><tr><td><strong>④    </strong></td><td> <p><strong>获得SlockC</strong></p> <p><strong>（获得共享锁）</strong></p> </td></tr><tr><td>⑤</td><td> <p><strong>R(C)=100</strong></p> <p><strong>（事务T2获取共享锁）</strong></p> </td></tr><tr><td></td><td> <p><strong>Commit </strong></p> <p><strong>Unlock C</strong></p> </td></tr></tbody></table> 
<h2><strong>活锁和死锁 </strong></h2> 
<h3><strong>        1、活锁（永远等待）</strong></h3> 
<p><strong>        如果事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R。当T3释放了R上的封锁之后，系统又批准了T4的请求……，T2有可能永远等待，这就是活锁。</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:109px;"><strong>T1               </strong></td><td style="width:119px;"><strong>T2</strong></td><td style="width:132px;"><strong>T3</strong></td><td style="width:139px;"><strong>T4 </strong></td></tr><tr><td style="width:109px;"><strong>Lock R</strong></td><td style="width:119px;"></td><td style="width:132px;"></td><td style="width:139px;"></td></tr><tr><td style="width:109px;"></td><td style="width:119px;"><strong>Lock R </strong></td><td style="width:132px;"></td><td style="width:139px;"></td></tr><tr><td style="width:109px;"></td><td style="width:119px;"><strong>等待   </strong></td><td style="width:132px;"><strong>Lock R </strong></td><td style="width:139px;"></td></tr><tr><td style="width:109px;"><strong> Unlock </strong></td><td style="width:119px;"><strong>等待</strong></td><td style="width:132px;"><strong>等待</strong></td><td style="width:139px;"><strong>Lock R</strong></td></tr><tr><td style="width:109px;"></td><td style="width:119px;"><strong>等待</strong></td><td style="width:132px;"><strong>Lock R</strong></td><td style="width:139px;"><strong>等待</strong></td></tr><tr><td style="width:109px;"></td><td style="width:119px;"><strong>等待 </strong></td><td style="width:132px;"><strong>Unlock  </strong></td><td style="width:139px;"><strong>等待</strong></td></tr><tr><td style="width:109px;"></td><td style="width:119px;"><strong>等待</strong></td><td style="width:132px;"></td><td style="width:139px;"><strong>Lock R</strong></td></tr><tr><td style="width:109px;"></td><td style="width:119px;"><strong>等待 </strong></td><td style="width:132px;"></td><td style="width:139px;"></td></tr></tbody></table> 
<h4><br><strong>          避免活锁采用的策略:   <span style="color:#fe2c24;">先来先服务的策略</span></strong></h4> 
<h3><strong>        2、死锁</strong></h3> 
<h4><strong>        如果事务T1封锁了数据R1，T2封锁了数据R2，然后T1又请求封锁R2，大T2已封锁了R2，于是T1等待T2释放R2上的锁。接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1上的锁。这要出现了T1在等 T2，而T2又在等待T1的局面，T1和 T2两个事务永远不能结束，形成死锁。</strong></h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong> T1    </strong></td><td><strong>T2</strong></td></tr><tr><td><strong>Lock　R1 </strong></td><td></td></tr><tr><td></td><td><strong>Lock　R2</strong></td></tr><tr><td><strong>Lock　R2</strong></td><td></td></tr><tr><td><strong>等待</strong></td><td></td></tr><tr><td><strong>等待</strong></td><td><strong>Lock R1</strong></td></tr><tr><td><strong>等待</strong></td><td><strong>等待</strong></td></tr><tr><td><strong>等待</strong></td><td><strong>等待</strong></td></tr></tbody></table> 
<h4><br><strong>       　解决死锁问题的方法:</strong></h4> 
<h4><strong>                <span style="color:#fe2c24;">死锁的预防</span></strong></h4> 
<h4><strong>                <span style="color:#fe2c24;">死锁的诊断与解除</span></strong></h4> 
<h4><strong>        (1)死锁的预防（弊端较大，不宜采用）</strong></h4> 
<p><strong>               ① 一次封锁法（每个事务一次将要使用的数据全部加锁：封锁范围大，并发范围小，难以确定对象）</strong></p> 
<p><strong>               ② 顺序封锁法（预先对数据对象规定一个封锁顺序：封锁数据对象多，且变化多，维护成本高，难以确定封锁的对象和顺序）</strong></p> 
<h4><strong>        死锁的预防总结:</strong></h4> 
<p><strong>        　　预防死锁的策略并不很适合数据库的特点，因此DBMS在解决死锁的问题上<span style="color:#fe2c24;">普遍采用的是诊断并解除死锁的方法</span>。</strong></p> 
<h4><strong>        (2)死锁的诊断与解除</strong></h4> 
<p><strong>                →超时法：</strong></p> 
<p><strong>                如果一个事务的<span style="color:#fe2c24;">等待时间超过了</span><span style="color:#956fe7;">规定的时限</span>，就认为发生了死锁。</strong></p> 
<p><strong>                优点:实现简单。</strong></p> 
<p><strong>                缺点;</strong></p> 
<p><strong>                        ①有可能误判死锁。</strong></p> 
<p><strong>                        事务因为其他原因使等待时间超过时限，系统会误认为发生了死锁。</strong></p> 
<p><strong>                        ②<span style="color:#fe2c24;">时限</span>若设置得<span style="color:#fe2c24;">太长</span>，死锁发生后<span style="color:#fe2c24;">不能及时发现</span>。</strong></p> 
<h4><strong>              <span style="color:#fe2c24;">等待图法（大部分使用）</span></strong></h4> 
<p><strong>                事务等待图是一个<span style="color:#fe2c24;">有向图</span>G=(T，U)。</strong></p> 
<p><strong>                <span style="color:#fe2c24;">T</span>为结点的<span style="color:#fe2c24;">集合</span>，每个结点表示<span style="color:#fe2c24;">正运行的事务</span>: </strong></p> 
<p><strong>                U为边的集合，每条边表示事务等待的情况。</strong><strong><span style="color:#fe2c24;">若T1等待T2，则T1，T2之间</span><span style="color:#956fe7;">划一条有向边</span><span style="color:#fe2c24;">，从T1指向T2。</span></strong></p> 
<p><strong>                事务等待图<span style="color:#fe2c24;">动态地反映了所有事务的等待情况</span>。并发控制子系统周期性地(比如每隔数秒)生成事务等待图，并进行检测。如果发现图中<span style="color:#ff9900;">存在回路</span>，则<span style="color:#ff9900;">表示系统中</span><span style="color:#fe2c24;">出现了死锁</span>。</strong></p> 
<p><strong>                DBMS的并发控制子系统一旦检测到系统中存在死锁，就要设法解除。通常采用的方法是选择一个<span style="color:#fe2c24;">处理死锁</span><span style="color:#956fe7;">代价最小的事务</span><span style="color:#fe2c24;">，将其</span><span style="color:#956fe7;">撤消</span>，释放此事务持有的所有的锁，使其它事务得以继续运行下去。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/649f3c5a178d22630b7750115a38317b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS之BFC</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe462d62398c099924ab2eb7cc2faf15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">软考高级，信息系统项目管理师（高项）经验分享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>