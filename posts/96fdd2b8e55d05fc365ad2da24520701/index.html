<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ElasticSearch：处理数据的关联关系 nested 父子文档 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ElasticSearch：处理数据的关联关系 nested 父子文档" />
<meta property="og:description" content="传统关系型数据库对关联关系的处理 对于传统关系型数据库而言，处理数据的关联关系时比较正规的设计是范式化设计与非范式化设计。
范式化 (Normalization) 范式化设计的主要⽬标是“减少不必要的更新”，一般有三段范式，其实就是本着将两个关联数据模型之间通过主键的处理去划分属性字段，减少不必要的更新处理。
关于范式化的概念可以自行去学习。
反范式化 (Denormalization) 范式化设计带来的一个弊端就是读操作可能会涉及很多表的处理，性能受影响，所以如果我们本来只需要关联对象的一个字段却还得去查询关联表一次，很不方便，于是便有了范式化设计，就是不使⽤关联关系，⽽是直接保存冗余的数据，减少join操作。
关于反范式化的概念可以自行去学习。
ElasticSearch 对关联关系的处理 在 ElasticSearch 中，对数据的关联关系的处理，其实也有参考范式化与反范式化的设计，并且针对这两中设计理念都有对应的实现方式。
嵌套对象(Nested Object) nested 是 ElasticSearch 处理关联关系时的一种范式化设计的数据模型，在索引时他们被存放到两个不同Lucene文档中，在查询的时候 join出来，将根父文档带出来。
允许嵌套对象中的数据被独⽴索引分成两个文档去存储，类似数据库的分表存放关键词 “type”: “nested” 指定 nested 数据类型 要想使用 nested，需要我们在设置mapping的时候将这个对象的数据类型设置成为 nested。
PUT blog { &#34;mappings&#34;: { &#34;properties&#34;: { &#34;actors&#34;: { &#34;type&#34;: &#34;nested&#34;, &#34;properties&#34;: { &#34;name&#34;: { &#34;type&#34;: &#34;keyword&#34; }, &#34;sex&#34;: { &#34;type&#34;: &#34;keyword&#34; }, &#34;another&#34;: { &#34;type&#34;: &#34;nested&#34;, &#34;properties&#34;: { &#34;name&#34;: { &#34;type&#34;: &#34;keyword&#34; } } } } } } } } 如上这个mapping的设置语义，就是将actors作者定义成为nested存储类型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/96fdd2b8e55d05fc365ad2da24520701/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-05T16:59:12+08:00" />
<meta property="article:modified_time" content="2020-10-05T16:59:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ElasticSearch：处理数据的关联关系 nested 父子文档</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>传统关系型数据库对关联关系的处理</h2> 
<p>对于传统关系型数据库而言，处理数据的关联关系时比较正规的设计是范式化设计与非范式化设计。</p> 
<h3><a id="_Normalization_2"></a>范式化 (Normalization)</h3> 
<p>范式化设计的主要⽬标是“减少不必要的更新”，一般有三段范式，其实就是本着将两个关联数据模型之间通过主键的处理去划分属性字段，减少不必要的更新处理。</p> 
<blockquote> 
 <p>关于范式化的概念可以自行去学习。</p> 
</blockquote> 
<h3><a id="_Denormalization_5"></a>反范式化 (Denormalization)</h3> 
<p>范式化设计带来的一个弊端就是读操作可能会涉及很多表的处理，性能受影响，所以如果我们本来只需要关联对象的一个字段却还得去查询关联表一次，很不方便，于是便有了范式化设计，就是不使⽤关联关系，⽽是直接保存冗余的数据，减少join操作。</p> 
<blockquote> 
 <p>关于反范式化的概念可以自行去学习。</p> 
</blockquote> 
<h2><a id="ElasticSearch__8"></a>ElasticSearch 对关联关系的处理</h2> 
<p>在 ElasticSearch 中，对数据的关联关系的处理，其实也有参考范式化与反范式化的设计，并且针对这两中设计理念都有对应的实现方式。</p> 
<h3><a id="Nested_Object_10"></a>嵌套对象(Nested Object)</h3> 
<p>nested 是 ElasticSearch 处理关联关系时的一种范式化设计的数据模型，在索引时他们被存放到两个不同Lucene文档中，在查询的时候 join出来，将根父文档带出来。</p> 
<ul><li>允许嵌套对象中的数据被独⽴索引</li><li>分成两个文档去存储，类似数据库的分表存放</li><li>关键词 “type”: “nested”</li></ul> 
<h5><a id="_nested__17"></a>指定 nested 数据类型</h5> 
<p>要想使用 nested，需要我们在设置mapping的时候将这个对象的数据类型设置成为 nested。</p> 
<pre><code class="prism language-bash">PUT blog
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"mappings"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"properties"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"actors"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"nested"</span>,
        <span class="token string">"properties"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"name"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"keyword"</span>
          <span class="token punctuation">}</span>,
          <span class="token string">"sex"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"keyword"</span>
          <span class="token punctuation">}</span>,
          <span class="token string">"another"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"nested"</span>,
            <span class="token string">"properties"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
              <span class="token string">"name"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"keyword"</span>
              <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如上这个mapping的设置语义，就是将actors作者定义成为nested存储类型。</p> 
<h5><a id="nested_API_49"></a>nested 查询API</h5> 
<p>针对 nested 数据结构的查询，需要使用 ElasticSearch 提供的 nested 查询API。</p> 
<p><strong>语法：POST 索引名/_search + 请求体(关键词：nested )</strong></p> 
<ul><li>path 要查询字段路径，以根路径开始，比如上方的actors只有一层，那么path 就是 actors，如果是another，那么path 就是 actors.another,加上父路径</li><li>query 查询语法</li></ul> 
<pre><code class="prism language-bash">POST blog/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"nested"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"path"</span><span class="token keyword">:</span> <span class="token string">"actors"</span>,
      <span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">"bool"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"must"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">{<!-- --></span>
              <span class="token string">"match"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"actors.name"</span><span class="token keyword">:</span> <span class="token string">"Keanu"</span>
              <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>,
            <span class="token punctuation">{<!-- --></span>
              <span class="token string">"match"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"actors.sex"</span><span class="token keyword">:</span> <span class="token string">"boy"</span>
              <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/72/bf/so3Fyp2K_o.png" alt="在这里插入图片描述"><br> 如上的查询语义是，查询actors 的那么等于Keanu以及sex等于boy的文档出来，可以看到结果是正常查询的。</p> 
<pre><code class="prism language-bash">POST blog/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"nested"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"path"</span><span class="token keyword">:</span> <span class="token string">"actors.another"</span>,
      <span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">"bool"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"must"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">{<!-- --></span>
              <span class="token string">"match"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"actors.another.name"</span><span class="token keyword">:</span> <span class="token string">"mrs"</span>
              <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/aa/c9/lp9rL4Oj_o.png" alt="在这里插入图片描述"><br> 如上的查询语义是查询another的name为mrs的，可以看到结果也可以正常展示。<br> 这里需要注意的是match中的内容，要写全路径名称。</p> 
<h5><a id="_110"></a>更新文档</h5> 
<p>nested 有个不好用的缺点就是，我们对嵌套文档进行操作的时候，本来是打算想要更新其中一个字段的数据，但是他会进行覆盖处理，对整个文档进行更新。<br> <img src="https://images2.imgbox.com/5c/8c/xfabpCAt_o.png" alt="在这里插入图片描述"><br> 可以看到，我们的更新语句只是想更新title，结果将 actors直接覆盖掉了。</p> 
<h3><a id="_114"></a>父子文档关系</h3> 
<p>因为 nested 更新的缺点，导致ElasticSearch 无法像传统关系型数据库那样保证各个表之间的数据互不干扰，所以 ElasticSearch 又提供了一种新的数据结构，就是父子文档。<br> 父子文档的父文档与子文档的更新并不会干扰到对方，这与数据库的多表join已经很相似了，父子文档之间通过父文档的id关联，这有些类似数据库的外键。</p> 
<ul><li>分成两个文档去存储，类似数据库的分表存放</li><li>关键词 “type”: “join”</li></ul> 
<h5><a id="mapping_119"></a>指定父子文档的mapping</h5> 
<p>要想使用父子文档，需要我们在设置mapping的时候将数据类型设置成为 join。</p> 
<ul><li>“type” 类型为 “join”</li><li>relations 指定区分父子文档的唯一标识，比如"parent": “child”，那么 parent 就是父文档的唯一标识，child 就是子文档的唯一标识，在文档索引的时候需要带在文档中。</li></ul> 
<pre><code class="prism language-bash">PUT blogs
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"mappings"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"properties"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"child_relation"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"join"</span>,
        <span class="token string">"relations"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"parent"</span><span class="token keyword">:</span> <span class="token string">"child"</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>,
      <span class="token string">"content"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"text"</span>
      <span class="token punctuation">}</span>,
      <span class="token string">"title"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"keyword"</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个文档mapping，语义是child_relation为父子文档类型的，并且如果 child_relation 的值为 parent，那么为父文档，如果 child_relation 的值为 child，那么为子文档，这个值是随你自己自定义的。</p> 
<h5><a id="_146"></a>索引文档，分别索引父文档与子文档</h5> 
<p>父子文档是两个独立的文档，之间互不干扰，可以单独的去查询，并且需要单独的去索引。</p> 
<h6><a id="_148"></a>索引父文档</h6> 
<p>在索引父子文档的时候，都需要显示的指定文档id，因为ElasticSearch需要根据这个id去建立关系，它自己无法知道，需要用户去告诉他。</p> 
<ul><li>指定父文档id</li><li>关联关系唯一标识设置为mapping 中父文档的标识</li></ul> 
<pre><code class="prism language-bash"><span class="token comment">#索引父文档</span>
PUT blogs/_doc/blog2
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"title"</span><span class="token keyword">:</span><span class="token string">"Learning Hadoop"</span>,
  <span class="token string">"content"</span><span class="token keyword">:</span><span class="token string">"learning Hadoop is so easy"</span>,
    <span class="token string">"child_relation"</span>:<span class="token punctuation">{<!-- --></span>
    <span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"parent"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里的 child_relation 是我们在之前mapping中定义的父子文档之间的关联唯一标识字段，这里因为是父文档，所以这里需要将 child_relation 的 name 字段设置成为parent。</p> 
<h6><a id="_166"></a>索引子文档</h6> 
<p>在索引子文档的时候，需要显示的指定子文档id，并且还需要指定父文档的id，告诉ElasticSearch 你这个文档的父文档是谁。</p> 
<ul><li>指定子文档id</li><li>指定父文档id，通过关键字 routing</li><li>关联关系唯一标识设置为mapping 中子文档的标识</li></ul> 
<pre><code class="prism language-bash"><span class="token comment">#索引子文档</span>
PUT blogs/_doc/comment2?routing<span class="token operator">=</span>blog2
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"comment"</span><span class="token keyword">:</span><span class="token string">"I like Hadoop!!!!!"</span>,
  <span class="token string">"username"</span><span class="token keyword">:</span><span class="token string">"Jack"</span>,
  <span class="token string">"child_relation"</span>:<span class="token punctuation">{<!-- --></span>
    <span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"child"</span>,
    <span class="token string">"parent"</span><span class="token keyword">:</span><span class="token string">"blog2"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>首先指定子文档的id，然后通过 routing 指定父文档的id，最后需要在 child_relation 中指定子文档的唯一标识并且指定parent 关键字段的值为父文档的id。</p> 
<h3><a id="_API_185"></a>查询 API</h3> 
<p>ElasticSearch 对于父子文档的查询提供了如下几种查询方式</p> 
<ul><li>基本查询</li><li>Parent Id 查询</li><li>Has Child 查询</li><li>Has Parent 查询</li></ul> 
<h5><a id="_191"></a>基本查询</h5> 
<p>父子文档也支持常用的查询语法。</p> 
<h6><a id="_193"></a>查询所有文档</h6> 
<pre><code class="prism language-bash"><span class="token comment"># 查询所有文档</span>
POST blogs/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"match_all"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="id_203"></a>根据文档id访问文档</h6> 
<p>根据文档id去访问，只会访问到当前文档</p> 
<pre><code class="prism language-bash"><span class="token comment">#根据父文档ID查看</span>
GET blogs/_doc/blog2
</code></pre> 
<pre><code class="prism language-bash"><span class="token comment">#根据子文档ID查看</span>
GET blogs/_doc/comment3
</code></pre> 
<h5><a id="Parent_Id__214"></a>Parent Id 查询</h5> 
<p>Parent Id 查询是ElasticSearch 提供的一种专门查询父子文档的API，这种查询是为了满足类似将一个父文档下的所有的子文档全部查询出来的场景。</p> 
<p><strong>语法：POST 索引名/_search + 查询体(关键词:“parent_id”)</strong></p> 
<ul><li>type 子文档的唯一标识</li><li>id 父文档的id</li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># Parent Id 查询</span>
POST blogs/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"parent_id"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"child"</span>,
      <span class="token string">"id"</span><span class="token keyword">:</span> <span class="token string">"blog2"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/fc/54/awG7mn7T_o.png" alt="在这里插入图片描述"><br> 这个语法就是查询 blog2 下的所有子文档，可以看到结果，都是符合条件的，注意这里不会将父文档带出来。</p> 
<h5><a id="Has_Child__236"></a>Has Child 查询</h5> 
<p>Has Child 查询是根据查询条件将符合条件的子文档查询出来然后再根据父文档id将所有的父文档查询出来。</p> 
<p><strong>语法：POST 索引名/_search + 查询体(关键词:“has_child”)</strong></p> 
<ul><li>type 子文档的唯一标识</li><li>query 查询语法，这里的查询条件是针对子文档的字段的。</li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># Has Child 查询,返回父文档</span>
POST blogs/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"has_child"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"child"</span>,
      <span class="token string">"query"</span> <span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"match"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token string">"username"</span> <span class="token keyword">:</span> <span class="token string">"Jack"</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c5/2b/OE3F5iHr_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Has_Parent__260"></a>Has Parent 查询</h5> 
<p>Has Parent 查询正好与子查询相反，会将父文档的查询条件找出父文档并且再去找出所有的子文档。</p> 
<p><strong>语法：POST 索引名/_search + 查询体(关键词:“has_parent”)</strong></p> 
<ul><li>parent_type 子文档的唯一标识</li><li>query 查询语法，这里的查询条件是针对父文档的字段的。</li><li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># Has Parent 查询，返回相关的子文档</span>
POST blogs/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"has_parent"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"parent_type"</span><span class="token keyword">:</span> <span class="token string">"parent"</span>,
      <span class="token string">"query"</span> <span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
                <span class="token string">"match"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token string">"title"</span> <span class="token keyword">:</span> <span class="token string">"Learning Hadoop"</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d5/e4/MnGLX5QQ_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0cff629e5d055af472c9f121b898917c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Microsoft Windows Server 2008 R2安装.net framework 3.5 sp1失败的解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76973b43a2c04cda9793830e17f54062/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">详解卡尔曼滤波原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>