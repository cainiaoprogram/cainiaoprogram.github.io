<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java之hashMap遍历方式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java之hashMap遍历方式" />
<meta property="og:description" content="在java开发中，hashMap是非常重要的容器类，存储的是键值对(key，value)。
HashMap继承AbstractMap，实现了Map、Cloneable、Serializable接口，非线程安全类，但是效率高。HashMap允许null健和null值，允许value重复，但不允许key重复。HashMap有两个参数影响其性能，初始容量和加载因子，当哈希表中的条目数超出加载因子与当前容量的乘积时，要对哈希表进行refresh操作，重建内部数据结构，容量扩大为之前的两倍，加载因子默认值为0.75。
HashMap的遍历方式
第一种，遍历HashMap的entrySet键值对集合，通过HashMap.entrySet()得到键值对集合，通过迭代器Iterator遍历集合得到key和value。
public static void main(String[] args) { Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&#34;caocao&#34;,&#34;11&#34;); map.put(&#34;liubei&#34;,&#34;22&#34;); map.put(&#34;sunquan&#34;,&#34;33&#34;); first(map); } private static void first(Map&lt;Object, Object&gt; map) { Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry&lt;Object, Object&gt; entry = iterator.next(); System.out.println(&#34;key:&#34; &#43; entry.getKey() &#43; &#34;,vaule:&#34; &#43; entry.getValue()); } } 第二种，遍历HashMap的keySet集合，通过HashMap.keySet()得到key集合，通过迭代器Iterator遍历集合得到key和value。
private static void second(Map&lt;Object, Object&gt; map) { Iterator&lt;Object&gt; iterator = map.keySet().iterator(); while (iterator.hasNext()) { Object key = iterator.next(); System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bcf7da98be51410e61c3dc9a705c8dd7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-19T21:29:38+08:00" />
<meta property="article:modified_time" content="2022-02-19T21:29:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java之hashMap遍历方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在java开发中，hashMap是非常重要的容器类，存储的是键值对(key，value)。<br> HashMap继承AbstractMap，实现了Map、Cloneable、Serializable接口，非线程安全类，但是效率高。HashMap允许null健和null值，允许value重复，但不允许key重复。HashMap有两个参数影响其性能，初始容量和加载因子，当哈希表中的条目数超出加载因子与当前容量的乘积时，要对哈希表进行refresh操作，重建内部数据结构，容量扩大为之前的两倍，加载因子默认值为0.75。</p> 
<p><strong>HashMap的遍历方式</strong><br> 第一种，遍历HashMap的entrySet键值对集合，通过HashMap.entrySet()得到键值对集合，通过迭代器Iterator遍历集合得到key和value。</p> 
<pre><code>public static void main(String[] args) {
        Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;();
        map.put("caocao","11");
        map.put("liubei","22");
        map.put("sunquan","33");
        first(map);

    }

    private static void first(Map&lt;Object, Object&gt; map) {
        Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry&lt;Object, Object&gt; entry = iterator.next();
            System.out.println("key:" + entry.getKey() + ",vaule:" + entry.getValue());
        }
    }
</code></pre> 
<p>第二种，遍历HashMap的keySet集合，通过HashMap.keySet()得到key集合，通过迭代器Iterator遍历集合得到key和value。</p> 
<pre><code>private static void second(Map&lt;Object, Object&gt; map) {
        Iterator&lt;Object&gt; iterator = map.keySet().iterator();
        while (iterator.hasNext()) {
            Object key = iterator.next();
            System.out.println("key:" + key + ",vaule:" + map.get(key));
        }
    }
</code></pre> 
<p>第三种，遍历HashMap的values集合，通过HashMap.valus()得到value集合，通过迭代器Iterator遍历集合得到key和value。</p> 
<pre><code>private static void third(Map&lt;Object, Object&gt; map) {
        Iterator&lt;Object&gt; iterator = map.values().iterator();
        while (iterator.hasNext()) {
            Object value = iterator.next();
            System.out.println("vaule:" + value);
        }
    }
</code></pre> 
<p>第四种，遍历HashMap的entrySet键值对集合，通过HashMap.entrySet()得到键值对集合，通过for循环遍历集合得到key和value。</p> 
<pre><code>private static void fourth(Map&lt;Object, Object&gt; map) {
        for (Map.Entry&lt;Object,Object&gt; entry: map.entrySet()) {
            System.out.println("key:" + entry.getKey() + ",vaule:" + entry.getValue());
        }
    }
</code></pre> 
<p>第五种，遍历HashMap的keySet集合，通过HashMap.keySet()得到key集合，通过for循环遍历集合得到key和value。</p> 
<pre><code>private static void fifth(Map&lt;Object, Object&gt; map) {
        for(Object key : map.keySet()) {
            System.out.println("key:" + key + ",vaule:" + map.get(key));
        }
    }
</code></pre> 
<p>第六种，遍历HashMap的values集合，通过HashMap.valus()得到value集合，通过for循环遍历集合得到key和value。</p> 
<pre><code>private static void sixth(Map&lt;Object, Object&gt; map) {
        for (Object value : map.values()) {
            System.out.println("vaule:" + value);
        }
    }
</code></pre> 
<p>第七种，通过Lambda遍历HashMap得到key和value</p> 
<pre><code>private static void seventh(Map&lt;Object, Object&gt; map) {
        map.forEach((key,value) -&gt; {
            System.out.println("key:" + key + ",vaule:" + value);
        });
    }
</code></pre> 
<p>第八种，通过Lambda遍历HashMap.entrySet()得到键值对集合得到key和value</p> 
<pre><code>private static void eighth(Map&lt;Object, Object&gt; map) {
        map.entrySet().forEach(item -&gt; {
            System.out.println("key:" + item.getKey() + ",vaule:" + item.getValue());
        });
    }
</code></pre> 
<p>第九种，通过Lambda遍历HashMap.keySet()得到key集合得到key和value</p> 
<pre><code>private static void ninth(Map&lt;Object, Object&gt; map) {
        map.keySet().forEach(item -&gt; {
            System.out.println("key:" + item + ",vaule:" + map.get(item));
        });
    }
</code></pre> 
<p>以上遍历主要Iterator遍历集合方式、for循环遍历集合方式，Lambda遍历集合方式，根据具体需求选用不同的方式，通过Iterator方式循环删除数据是安全的，for方式循环删除数据非安全，Lambda方式循环删除数据非安全，通过Iterator方式的效率也很高。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5232978ca75f8b4bb7019976d0b6c348/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">移动互联网寒冬，Android 程序员的出路在哪里？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74253fd101f03b4b6cf8dcf911e62ea7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">实现 App 自动检测更新（Vue3 &#43; Ionic &#43; Cordova &#43; Capacitor）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>