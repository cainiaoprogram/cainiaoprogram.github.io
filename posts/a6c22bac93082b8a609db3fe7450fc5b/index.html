<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详解TCP报文格式以及TCP相关特性 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="详解TCP报文格式以及TCP相关特性" />
<meta property="og:description" content="✏️✏️✏️今天给大家分享的是TCP报文格式的解释以及TCP协议的一些重要特性。
清风的CSDN博客
🛩️🛩️🛩️希望我的文章能对你有所帮助，有不足的地方还请各位看官多多指教，大家一起学习交流！
✈️✈️✈️动动你们发财的小手，点点关注点点赞！在此谢过啦！哈哈哈！😛😛😛
目录
一、 TCP协议段格式
1.1 TCP协议格式 二、TCP原理 (基本机制/特性)
2.1 确认应答机制 2.2 超时重传机制 (安全机制)
2.3 连接管理机制（安全机制） 2.4 滑动窗口(效率机制) 2.5 流量控制(安全机制) 2.6 拥塞控制(安全机制)
2.7 延时应答(效率机制)
2.8 捎带应答(效率机制) 三、粘包问题 四、TCP异常情况 五、TCP小结
TCP是传输层的重点协议，对于我们了解网络原理有着至关重要的作用。 一、 TCP协议段格式 TCP 协议 TCP ，即 Transmission Control Protocol ，传输控制协议。人如其名，要对数据的传输进行一个详细的控制。 1.1 TCP协议格式 源/目的端口号：表示数据是从哪个进程来，到哪个进程去32位序号/32位确认号：后面详细给大家介绍4位首部长度：表示该TCP头部有多少个32位bit（有多少个4字节）,所以TCP头部最大长度是 15 * 4 = 60 6位标志位: URG：紧急指针是否有效 ACK：确认号是否有效 PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走 RST：对方要求重新建立连接；我们把携带RST标识的称为复位报文段 SYN：请求建立连接；我们把携带SYN标识的称为同步报文段FIN：通知对方，本端要关闭了，我们称携带FIN标识的为结束报文段 16位窗口大小：流量控制(下面我会详细介绍)16位校验和：发送端填充，CRC校验。接收端校验不通过，则认为数据有问题。此处的检验和不光包含TCP首部，也包含TCP数据部分16位紧急指针：标识哪部分数据是紧急数据40字节头部选项：暂时忽略 二、TCP原理 (基本机制/特性) TCP 对数据传输提供的管控机制，主要体现在两个方面：安全和效率。这些机制和多线程的设计原则类似：保证数据传输安全的前提下，尽可能的提高传输效率。 2.1 确认应答机制 TCP将每个字节的数据都进行了编号，即为序列号，但是并不会真正的存储每个字节的序列号，只需要保存起始序号，通过TCP的报文长度来＋ 起始序号得到最后一个字节的编号。
每一个 ACK 都带有对应的确认序列号，意思是告诉发送者，我已经收到了哪些数据，下一次你从哪里开始发。 2.2 超时重传机制 (安全机制) 主机A发送数据给B之后，可能因为网络拥堵等原因，数据无法到达主机B如果主机A在一个特定时间间隔内没有收到B发来的确认应答，就会进行重发 但是，主机 A 未收到 B 发来的确认应答，也可能是因为 ACK 丢失了: 此时也会触发主机A重发， 因此主机 B 会收到很多重复数据。那么 TCP 协议需要能够识别出那些包是重复的包，并且把重复的丢弃 掉。 这时候我们可以利用前面提到的序列号，就可以很容易做到去重的效果。 那么，如果超时，这个时间如何确定？ 最理想的情况下，找到一个最小的时间，保证 &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a6c22bac93082b8a609db3fe7450fc5b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T09:43:47+08:00" />
<meta property="article:modified_time" content="2024-01-05T09:43:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详解TCP报文格式以及TCP相关特性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="701" src="https://images2.imgbox.com/b1/5f/BdZAvbaT_o.png" width="1200"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">✏️✏️✏️今天给大家分享的是TCP报文格式的解释以及TCP协议的一些重要特性。</span></p> 
 <p style="text-align:center;"><a class="link-info" href="https://blog.csdn.net/m0_73920844?type=blog" title="清风的CSDN博客">清风的CSDN博客</a></p> 
 <p><span style="color:#1c7331;">🛩️🛩️🛩️希望我的文章能对你有所帮助，有不足的地方还请各位看官多多指教，大家一起学习交流！</span></p> 
 <p><span style="color:#1c7331;">✈️✈️✈️动动你们发财的小手，点点关注点点赞！在此谢过啦！哈哈哈！😛😛😛</span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/c1/db/x3aMfhWo_o.gif" width="300"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%20TCP%E5%8D%8F%E8%AE%AE%E6%AE%B5%E6%A0%BC%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%20TCP%E5%8D%8F%E8%AE%AE%E6%AE%B5%E6%A0%BC%E5%BC%8F" rel="nofollow">一、 TCP协议段格式</a></p> 
<p id="1.1%20TCP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%C2%A0-toc" style="margin-left:40px;"><a href="#1.1%20TCP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%C2%A0" rel="nofollow">1.1 TCP协议格式 </a></p> 
<p id="%E4%BA%8C%E3%80%81TCP%E5%8E%9F%E7%90%86%20(%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6%2F%E7%89%B9%E6%80%A7)-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81TCP%E5%8E%9F%E7%90%86%20%28%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6%2F%E7%89%B9%E6%80%A7%29" rel="nofollow">二、TCP原理 (基本机制/特性)</a></p> 
<p id="2.1%20%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6%C2%A0-toc" style="margin-left:40px;"><a href="#2.1%20%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6%C2%A0" rel="nofollow">2.1 确认应答机制 </a></p> 
<p id="2.2%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%20(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)-toc" style="margin-left:40px;"><a href="#2.2%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%20%28%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%29" rel="nofollow">2.2 超时重传机制 (安全机制)</a></p> 
<p id="2.3%C2%A0%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%EF%BC%89%C2%A0" rel="nofollow">2.3 连接管理机制（安全机制） </a></p> 
<p id="2.4%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6)%C2%A0-toc" style="margin-left:40px;"><a href="#2.4%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%28%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6%29%C2%A0" rel="nofollow">2.4 滑动窗口(效率机制) </a></p> 
<p id="2.5%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)%C2%A0-toc" style="margin-left:40px;"><a href="#2.5%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%28%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%29%C2%A0" rel="nofollow">2.5 流量控制(安全机制) </a></p> 
<p id="%C2%A02.6%20%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)-toc" style="margin-left:40px;"><a href="#%C2%A02.6%20%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%28%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%29" rel="nofollow"> 2.6 拥塞控制(安全机制)</a></p> 
<p id="%C2%A02.7%20%E5%BB%B6%E6%97%B6%E5%BA%94%E7%AD%94(%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6)-toc" style="margin-left:40px;"><a href="#%C2%A02.7%20%E5%BB%B6%E6%97%B6%E5%BA%94%E7%AD%94%28%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6%29" rel="nofollow"> 2.7 延时应答(效率机制)</a></p> 
<p id="2.8%20%E6%8D%8E%E5%B8%A6%E5%BA%94%E7%AD%94(%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6)%C2%A0-toc" style="margin-left:40px;"><a href="#2.8%20%E6%8D%8E%E5%B8%A6%E5%BA%94%E7%AD%94%28%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6%29%C2%A0" rel="nofollow">2.8 捎带应答(效率机制) </a></p> 
<p id="%E4%B8%89%E3%80%81%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">三、粘包问题 </a></p> 
<p id="%E5%9B%9B%E3%80%81TCP%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81TCP%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%C2%A0" rel="nofollow">四、TCP异常情况 </a></p> 
<p id="%E4%BA%94%E3%80%81TCP%E5%B0%8F%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81TCP%E5%B0%8F%E7%BB%93" rel="nofollow">五、TCP小结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<p>TCP是传输层的重点协议，对于我们了解网络原理有着至关重要的作用。 </p> 
<h2 id="%E4%B8%80%E3%80%81%20TCP%E5%8D%8F%E8%AE%AE%E6%AE%B5%E6%A0%BC%E5%BC%8F">一、 TCP协议段格式</h2> 
<div> 
 <span style="color:#333333;"><strong>TCP</strong></span> 
 <span style="color:#333333;"><strong>协议 </strong></span> 
</div> 
<div> 
 <span style="color:#333333;">TCP</span> 
 <span style="color:#333333;">，即</span> 
 <span style="color:#333333;">Transmission Control Protocol</span> 
 <span style="color:#333333;">，传输控制协议。人如其名，要对数据的传输进行一个详细的控制。</span> 
</div> 
<h3 id="1.1%20TCP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%C2%A0">1.1 TCP协议格式 </h3> 
<p class="img-center"><img alt="" height="318" src="https://images2.imgbox.com/d1/aa/lEvb5KI0_o.png" width="489"></p> 
<ul><li><span style="color:#333333;">源</span><span style="color:#333333;">/</span><span style="color:#333333;">目的端口号：表示数据是从哪个进程来，到哪个进程去</span></li><li><span style="color:#333333;">32</span><span style="color:#333333;">位序号</span><span style="color:#333333;">/32</span><span style="color:#333333;">位确认号：后面详细给大家介绍</span></li><li><span style="color:#333333;">4</span><span style="color:#333333;">位首部</span><span style="color:#333333;">长度：表示该</span><span style="color:#333333;">TCP</span><span style="color:#333333;">头部有多少个</span><span style="color:#333333;">32</span><span style="color:#333333;">位</span><span style="color:#333333;">bit</span><span style="color:#333333;">（有多少个</span><span style="color:#333333;">4</span><span style="color:#333333;">字节）,所以</span><span style="color:#333333;">TCP</span><span style="color:#333333;">头部最大长度是 </span><span style="color:#333333;">15 * 4 = 60 </span></li><li> <span style="color:#333333;">6位标志位</span><span style="color:#333333;">: </span></li></ul> 
<blockquote> 
 <ul><li><span style="color:#333333;">URG</span><span style="color:#333333;">：紧急指针是否有效 </span></li><li><span style="color:#333333;">ACK</span><span style="color:#333333;">：确认号是否有效 </span></li><li><span style="color:#333333;">PSH</span><span style="color:#333333;">：提示接收端应用程序立刻从</span><span style="color:#333333;">TCP</span><span style="color:#333333;">缓冲区把数据读走 </span></li><li><span style="color:#333333;">RST</span><span style="color:#333333;">：对方要求重新建立连接；我们把携带</span><span style="color:#333333;">RST</span><span style="color:#333333;">标识的称为</span><span style="color:#333333;"><strong>复位报文段 </strong></span></li><li><span style="color:#333333;">SYN</span><span style="color:#333333;">：请求建立连接；我们把携带</span><span style="color:#333333;">SYN</span><span style="color:#333333;">标识的称为</span><span style="color:#333333;"><strong>同步报文段</strong></span><span style="color:#333333;">FIN</span><span style="color:#333333;">：通知对方，本端要关闭了，我们称携带</span><span style="color:#333333;">FIN</span><span style="color:#333333;">标识的为</span><span style="color:#333333;"><strong>结束报文段</strong></span></li></ul> 
</blockquote> 
<ul><li><span style="color:#333333;">16</span><span style="color:#333333;">位窗口大小：流量控制(下面我会详细介绍)</span></li><li><span style="color:#333333;">16</span><span style="color:#333333;">位校验和：发送端填充，</span><span style="color:#333333;">CRC</span><span style="color:#333333;">校验。接收端校验不通过，则认为数据有问题。此处的检验和不光</span><span style="color:#333333;">包含</span><span style="color:#333333;">TCP</span><span style="color:#333333;">首部，也包含</span><span style="color:#333333;">TCP</span><span style="color:#333333;">数据部分</span></li><li><span style="color:#333333;">16</span><span style="color:#333333;">位紧急指针：标识哪部分数据是紧急数据</span></li><li><span style="color:#333333;">40</span><span style="color:#333333;">字节头部选项：暂时忽略</span></li></ul> 
<h2 id="%E4%BA%8C%E3%80%81TCP%E5%8E%9F%E7%90%86%20(%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6%2F%E7%89%B9%E6%80%A7)">二、TCP原理 (基本机制/特性)</h2> 
<div> 
 <span style="color:#333333;">TCP</span> 
 <span style="color:#333333;">对数据传输提供的管控机制，主要体现在两个方面：安全和效率。这些机制和多线程的设计原则类似：保证数据传输安全的前提下，尽可能的提高传输效率。 </span> 
</div> 
<h3 id="2.1%20%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6%C2%A0">2.1 确认应答机制 </h3> 
<p class="img-center"><img alt="" height="395" src="https://images2.imgbox.com/12/4e/rVoGYOoN_o.png" width="628"></p> 
<p> <span style="color:#333333;">TCP</span><span style="color:#333333;">将每个字节的数据都进行了编号，即为序列号，但是并不会真正的存储每个字节的序列号，只需要保存起始序号，通过TCP的报文长度来＋ 起始序号得到最后一个字节的编号。</span></p> 
<p class="img-center"><img alt="" height="204" src="https://images2.imgbox.com/90/6b/zQAW6tw0_o.png" width="717"></p> 
<div> 
 <span style="color:#333333;">每一个</span> 
 <span style="color:#333333;">ACK</span> 
 <span style="color:#333333;">都带有对应的确认序列号，意思是告诉发送者，我已经收到了哪些数据，下一次你从哪里开始发。 </span> 
</div> 
<h3 id="2.2%20%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%20(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)">2.2 超时重传机制 (安全机制)</h3> 
<p class="img-center"><img alt="" height="403" src="https://images2.imgbox.com/59/7e/fwII8swt_o.png" width="636"></p> 
<blockquote> 
 <ul><li><strong><span style="color:#fe2c24;">主机A发送数据给B之后，可能因为网络拥堵等原因，数据无法到达主机B</span></strong></li><li><strong><span style="color:#fe2c24;">如果主机A在一个特定时间间隔内没有收到B发来的确认应答，就会进行重发</span></strong></li></ul> 
</blockquote> 
<div> 
 <span style="color:#333333;">但是，主机</span> 
 <span style="color:#333333;">A</span> 
 <span style="color:#333333;">未收到</span> 
 <span style="color:#333333;">B</span> 
 <span style="color:#333333;">发来的确认应答，也可能是因为</span> 
 <span style="color:#333333;">ACK</span> 
 <span style="color:#333333;">丢失了:</span> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="407" src="https://images2.imgbox.com/e6/33/7rKtDmE4_o.png" width="676"></p> 此时也会触发主机A重发， 
 <span style="color:#333333;">因此主机</span> 
 <span style="color:#333333;">B</span> 
 <span style="color:#333333;">会收到很多重复数据。那么</span> 
 <span style="color:#333333;">TCP</span> 
 <span style="color:#333333;">协议需要能够识别出那些包是重复的包，并且把重复的丢弃</span> 
 <span style="color:#333333;">掉。</span> 
 <span style="color:#333333;">这时候我们可以利用前面提到的序列号，就可以很容易做到去重的效果。</span> 
 <span style="color:#4d4d4d;"> </span> 
</div> 
<p><span style="color:#38d8f0;"><strong>那么，如果超时，这个时间如何确定？ </strong></span></p> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;"><strong> 最理想的情况下，找到一个最小的时间，保证 "确认应答一定能在这个时间内返回"</strong></span></li><li><span style="color:#fe2c24;"><strong>但是这个时间的长短，随着网络环境的不同，是有差异的</strong></span></li><li><span style="color:#fe2c24;"><strong>如果超时时间设的太长，会影响整体的重传效率</strong></span></li><li><span style="color:#fe2c24;"><strong>如果超时时间设的太短，有可能会频繁发送重复的包</strong></span></li></ul> 
</blockquote> 
<p><span style="color:#0d0016;">TCP为了保证无论在任何环境下都能比较高性能的通信，因此会动态计算这个最大超时时间。</span> </p> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;"><strong>Linux中（BSD Unix和Windows也是如此），超时以500ms为一个单位进行控制，每次判定</strong></span><span style="color:#fe2c24;"><strong>超时重发的超时时间都是500ms的整数倍。 </strong></span></li><li><span style="color:#fe2c24;"><strong>如果重发一次之后，仍然得不到应答，等待 2*500ms 后再进行重传。</strong></span></li></ul> 
 <div> 
  <ul><li><span style="color:#fe2c24;"><strong>如果仍然得不到应答，等待 4*500ms 进行重传。依次类推，以指数形式递增。 </strong></span></li><li><span style="color:#fe2c24;"><strong>累计到一定的重传次数，TCP认为网络或者对端主机出现异常，强制关闭连接。</strong></span></li></ul> 
 </div> 
</blockquote> 
<h3 id="2.3%C2%A0%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%EF%BC%89%C2%A0">2.3 <span style="color:#333333;"><strong>连接管理机制（安全机制）</strong></span> </h3> 
<div> 
 <span style="color:#333333;">在正常情况下，</span> 
 <span style="color:#333333;">TCP</span> 
 <span style="color:#333333;">要经过三次握手建立连接，四次挥手断开连接。</span> 
</div> 
<div> 
 <span style="color:#fe2c24;"><strong>三次握手：</strong></span> 
</div> 
<div style="text-align:center;"> 
 <span style="color:#333333;"><img alt="" src="https://images2.imgbox.com/da/3e/J3k2ZRYx_o.png"></span> 
</div> 
<p><span style="color:#fe2c24;"><strong>四次挥手：</strong></span></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/dc/e6/3SPH5Kzg_o.png"></p> 
<p><span style="color:#a2e043;"><strong>服务端状态转化：  </strong></span></p> 
<blockquote> 
 <ul><li><strong><span style="color:#b95514;">[CLOSED -&gt; LISTEN] 服务器端调用listen后进入LISTEN状态，等待客户端连接</span></strong></li><li><strong><span style="color:#b95514;">[LISTEN -&gt; SYN_RCVD] 一旦监听到连接请求（同步报文段），就将该连接放入内核等待队列中，并向客户端发送SYN确认报文</span></strong></li><li><strong><span style="color:#b95514;">[SYN_RCVD -&gt; ESTABLISHED] 服务端一旦收到客户端的确认报文，就进入ESTABLISHED状态，可以进行读写数据了</span></strong></li><li><strong><span style="color:#b95514;">[ESTABLISHED -&gt; CLOSE_WAIT] 当客户端主动关闭连接（调用close），服务器会收到结束报文段，服务器返回确认报文段并进入CLOSE_WAIT</span></strong></li><li><strong><span style="color:#b95514;">[CLOSE_WAIT -&gt; LAST_ACK] 进入CLOSE_WAIT后说明服务器准备关闭连接（需要处理完之前的数据），当服务器真正调用close关闭连接时，会向客户端发送FIN，此时服务器进入LAST_ACK状态，等待最后一个ACK到来（这个ACK是客户端确认收到FIN） </span></strong></li><li><strong><span style="color:#b95514;">[LAST_ACK -&gt; CLOSED] 服务器收到了对FIN的ACK，彻底关闭连接。</span></strong></li></ul> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>客户端状态转化： </strong></span></p> 
<blockquote> 
 <p></p> 
 <ul><li><span style="color:#be191c;"><strong>[CLOSED -&gt; SYN_SENT] 客户端调用connect，发送同步报文段</strong></span></li><li><span style="color:#be191c;"><strong>[SYN_SENT -&gt; ESTABLISHED] connect调用成功，则进入ESTABLISHED状态，开始读写数据</strong></span></li><li><span style="color:#be191c;"><strong>[ESTABLISHED -&gt; FIN_WAIT_1] 客户端主动调用close时，向服务器发送结束报文段，同时进入FIN_WAIT_1</strong></span></li><li><span style="color:#be191c;"><strong>[FIN_WAIT_1 -&gt; FIN_WAIT_2] 客户端收到服务器对结束报文段的确认,则进FIN_WAIT_2，</strong></span><span style="color:#be191c;"><strong>开始等待服务器的结束报文段</strong></span></li><li> 
   <div> 
    <span style="color:#be191c;"><strong>[FIN_WAIT_2 -&gt; TIME_WAIT] 客户端收到服务器发来的结束报文段，进入TIME_WAIT，并发出LAST_ACK</strong></span> 
   </div> </li><li> 
   <div> 
    <span style="color:#be191c;"><strong>[TIME_WAIT -&gt; CLOSED] 客户端要等待一个2MSL（Max Segment Life，报文最大生存时间）的时间，才会进入CLOSED状态。 </strong></span> 
   </div> </li></ul> 
</blockquote> 
<p><span style="color:#956fe7;">为什么是TIME_WAIT的时间是2MSL？ </span></p> 
<blockquote> 
 <ul><li><span style="color:#38d8f0;">MSL是TCP报文的最大生存时间，因此TIME_WAIT持续存在2MSL的话，就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失（否则服务器立刻重启，可能会收到来自上一个进程的迟到的数据，但是这种数据很可能是错误的），同时也是在理论上保证最后一个报文可靠到达（假设最后一个ACK丢失，那么服务器会再重发一个FIN。这时虽然客户端的进程不在了，但是TCP连接还在，仍然可以重LAST_ACK）。</span></li></ul> 
</blockquote> 
<p><span style="color:#956fe7;">关于CLOSE_WAIT  </span></p> 
<blockquote> 
 <div> 
  <span style="color:#38d8f0;">        一般而言，对于服务器上出现大量的 CLOSE_WAIT 状态，原因就是服务器没有正确的关闭 socket，导致四次挥手没有正确完成。这是一个 BUG。只需要加上对应的 close 即可解决问题。</span> 
 </div> 
</blockquote> 
<h3 id="2.4%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6)%C2%A0">2.4 滑动窗口(效率机制) </h3> 
<div> 
 <span style="color:#333333;">刚才给大家介绍了确认应答策略，对每一个发送的数据段，都要给一个</span> 
 <span style="color:#333333;">ACK</span> 
 <span style="color:#333333;">确认应答。收到</span> 
 <span style="color:#333333;">ACK</span> 
 <span style="color:#333333;">后再发送下一个数据段。这样做有一个比较大的缺点，就是性能较差。尤其是数据往返的时间较长的时候。 </span> 
</div> 
<p class="img-center"><img alt="" height="456" src="https://images2.imgbox.com/50/9a/nxwpG1nr_o.png" width="676"></p> 
<div> 
 <span style="color:#333333;">既然这样一发一收的方式性能较低，那么我们一次发送多条数据，就可以大大的提高性能（其实是将多个段的等待时间重叠在一起了）。</span> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="332" src="https://images2.imgbox.com/24/c6/a93eRhyl_o.png" width="677"></p> 
 <blockquote> 
  <ul><li><span style="color:#be191c;"><strong>窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。上图的窗口大小就是4000</strong></span><span style="color:#be191c;"><strong>个字节（四个段）</strong></span></li><li><span style="color:#be191c;"><strong>发送前四个段的时候，不需要等待任何ACK，直接发送</strong></span></li><li><span style="color:#be191c;"><strong>收到第一个ACK后，滑动窗口向后移动，继续发送第五个段的数据，依次类推</strong></span></li><li><span style="color:#be191c;"><strong>操作系统内核为了维护这个滑动窗口，需要开辟发送缓冲区来记录当前还有哪些数据没有应</strong></span><span style="color:#be191c;"><strong>答，只有确认应答过的数据，才能从缓冲区删掉</strong></span></li><li><span style="color:#be191c;"><strong>窗口越大，则网络的吞吐率就越高</strong></span></li></ul> 
 </blockquote> 
</div> 
<p class="img-center"><img alt="" height="466" src="https://images2.imgbox.com/d5/1d/o4jRoFPi_o.png" width="789"></p> 
<p> <span style="color:#333333;">那么如果出现了丢包，如何进行重传？这里分两种情况讨论：</span></p> 
<p><span style="color:#fe2c24;"><strong>情况一：数据包已经抵达，ACK被丢了。</strong></span></p> 
<p class="img-center"><img alt="" height="416" src="https://images2.imgbox.com/16/69/grQEOhUv_o.png" width="769"></p> 
<p><span style="color:#333333;">这种情况下，部分</span><span style="color:#333333;">ACK</span><span style="color:#333333;">丢了并不要紧，因为可以通过后续的</span><span style="color:#333333;">ACK</span><span style="color:#333333;">进行确认。</span></p> 
<p><strong><span style="color:#fe2c24;">情况二：数据包丢失</span></strong></p> 
<p class="img-center"><img alt="" height="467" src="https://images2.imgbox.com/9b/c8/2hpO1KIl_o.png" width="806"></p> 
<blockquote> 
 <ul><li><span style="color:#be191c;"><strong> 当某一段报文段丢失之后，发送端会一直收到 1001 这样的ACK，就像是在提醒发送端 "我想要的是 1001" 一样</strong></span></li><li><span style="color:#be191c;"><strong>如果发送端主机连续三次收到了同样一个 "1001" 这样的应答，就会将对应的数据 1001 -</strong></span><span style="color:#be191c;"><strong>2000 重新发送</strong></span></li><li><span style="color:#be191c;"><strong>这个时候接收端收到了 1001 之后，再次返回的ACK就是7001了（因为2001 - 7000）接收端</strong></span><span style="color:#be191c;"><strong>其实之前就已经收到了，被放到了接收端操作系统内核的接收缓冲区中</strong></span></li></ul> 
</blockquote> 
<p><span style="color:#333333;">这种机制被称为</span><span style="color:#333333;"> "</span><span style="color:#333333;">高速重发控制</span><span style="color:#333333;">"</span><span style="color:#333333;">（也叫</span><span style="color:#333333;"> "</span><span style="color:#333333;">快重传</span><span style="color:#333333;">"</span><span style="color:#333333;">）。</span></p> 
<h3 id="2.5%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)%C2%A0"><span style="color:#333333;">2.5 流量控制(安全机制)</span> </h3> 
<div> 
 <span style="color:#333333;">接收端处理数据的速度是有限的。如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送，就会造成丢包，继而引起丢包重传等等一系列连锁反应。 </span> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;">因此</span> 
  <span style="color:#333333;">TCP</span> 
  <span style="color:#333333;">支持根据接收端的处理能力，来决定发送端的发送速度。这个机制就叫做</span> 
  <span style="color:#333333;"><strong>流量控制。</strong></span> 
 </div> 
 <blockquote> 
  <div> 
   <ul><li><span style="color:#be191c;"><strong>接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 "窗口大小" 字段，通过ACK端通知发送端，窗口大小字段越大，说明网络的吞吐量越高</strong></span></li><li><span style="color:#be191c;"><strong>接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端，</strong></span><span style="color:#be191c;"><strong>发送端接受到这个窗口之后，就会减慢自己的发送速度</strong></span></li><li><span style="color:#be191c;"><strong>如果接收端缓冲区满了，就会将窗口置为0，这时发送方不再发送数据，但是需要定期发送一</strong></span><span style="color:#be191c;"><strong>个窗口探测数据段，使接收端把窗口大小告诉发送端</strong></span></li></ul> 
  </div> 
 </blockquote> 
</div> 
<p class="img-center"><img alt="" height="569" src="https://images2.imgbox.com/52/1e/pKO452Lz_o.png" width="755"></p> 
<div> 
 <span style="color:#333333;">接收端如何把窗口大小告诉发送端呢？在上面的</span> 
 <span style="color:#333333;">TCP</span> 
 <span style="color:#333333;">首部(报头)中，有一个</span> 
 <span style="color:#333333;">16位窗口字段，就是存放了窗口大小信息。那么问题来了，</span> 
 <span style="color:#333333;">16</span> 
 <span style="color:#333333;">位数字最大表示</span> 
 <span style="color:#333333;">65535</span> 
 <span style="color:#333333;">，那么</span> 
 <span style="color:#333333;">TCP</span> 
 <span style="color:#333333;">窗口最大就是</span> 
 <span style="color:#333333;">65535</span> 
 <span style="color:#333333;">字节么？</span> 
</div> 
<blockquote> 
 <div> 
  <div> 
   <strong><span style="color:#be191c;">实际上，TCP首部40字节选项中还包含了一个窗口扩大因子M，实际窗口大小是窗口字段的值左移 M 位。</span></strong> 
  </div> 
 </div> 
</blockquote> 
<h3 id="%C2%A02.6%20%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)"> 2.6 拥塞控制(安全机制)</h3> 
<div> 
 <span style="color:#333333;">        虽然</span> 
 <span style="color:#333333;">TCP有了滑动窗口这个大杀器，能够高效可靠的发送大量的数据。但是如果在刚开始阶段就发送大量的数据，仍然可能引发问题。</span> 
 <span style="color:#333333;">因为网络上有很多的计算机，可能当前的网络状态就已经比较拥堵。在不清楚当前网络状态下，贸然发</span> 
 <span style="color:#333333;">送大量的数据，是很有可能引起雪上加霜的。</span> 
 <span style="color:#333333;">因此TCP</span> 
 <span style="color:#333333;">引入</span> 
 <span style="color:#333333;"><strong>慢启动 </strong></span> 
 <span style="color:#333333;">机制，先发少量的数据，探探路，摸清当前的网络拥堵状态，再决定按照多大的速度传输数据。</span> 
</div> 
<p></p> 
<p class="img-center"><img alt="" height="549" src="https://images2.imgbox.com/5f/f9/KKwIOhM7_o.png" width="743"></p> 
<blockquote> 
 <ul><li><span style="color:#be191c;"><strong>此处引入一个概念程为</strong></span><span style="color:#ff9900;"><strong>拥塞窗口 </strong></span></li><li><span style="color:#be191c;"><strong>发送开始的时候，定义拥塞窗口大小为1</strong></span></li><li><span style="color:#be191c;"><strong>每次收到一个ACK应答，拥塞窗口大小乘2</strong></span></li><li><span style="color:#be191c;"><strong>每次发送数据包的时候，将拥塞窗口和接收端主机反馈的窗口大小做比较，取较小的值作为实际发送的窗口</strong></span></li></ul> 
</blockquote> 
<p><span style="color:#0d0016;">        像上面这样的拥塞窗口增长速度，是指数级别的。"慢启动" 只是指初始时慢，但是增长速度非常快。 为了不增长的那么快，因此不能使拥塞窗口单纯的加倍。此处引入一个叫做慢启动的阈值 ，当拥塞窗口超过这个阈值的时候，不再按照指数方式增长，而是按照线性方式增长。</span></p> 
<p class="img-center"><img alt="" height="499" src="https://images2.imgbox.com/1e/3f/Qoe9J24E_o.png" width="1106"></p> 
<blockquote> 
 <ul><li><span style="color:#333333;">当</span><span style="color:#333333;">TCP</span><span style="color:#333333;">开始启动的时候，慢启动阈值等于窗口最大值</span></li><li><span style="color:#333333;">在每次超时重发的时候，慢启动阈值会变成原来的一半，同时拥塞窗口置回</span><span style="color:#333333;">1</span></li></ul> 
</blockquote> 
<div> 
 <span style="color:#333333;">        少量的丢包，我们仅仅是触发超时重传，大量的丢包，我们就认为网络拥塞。当TCP通信开始后，网络吞吐量会逐渐上升，随着网络发生拥堵，吞吐量会立刻下降。</span> 
 <span style="color:#333333;">拥塞控制，归根结底是</span> 
 <span style="color:#333333;">TCP</span> 
 <span style="color:#333333;">协议想尽可能快的把数据传输给对方，但是又要避免给网络造成太大压力的</span> 
 <span style="color:#333333;">折中方案。</span> 
</div> 
<h3 id="%C2%A02.7%20%E5%BB%B6%E6%97%B6%E5%BA%94%E7%AD%94(%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6)"> 2.7 延时应答(效率机制)</h3> 
<div> 
 <span style="color:#333333;">如果接收数据的主机立刻返回</span> 
 <span style="color:#333333;">ACK</span> 
 <span style="color:#333333;">应答，这时候返回的窗口可能比较小。</span> 
</div> 
<blockquote> 
 <div> 
  <div> 
   <span style="color:#0d0016;">        假设接收端缓冲区为1M。一次收到了500K的数据，如果立刻应答，返回的窗口就是500K，但实际上可能处理端处理的速度很快，10ms之内就把500K数据从缓冲区消费掉了。在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理过 </span> 
  </div> 
  <div> 
   <span style="color:#0d0016;">来，如果接收端稍微等一会再应答，比如等待200ms再应答，那么这个时候返回的窗口大小就是1M。</span> 
  </div> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;">窗口越大，网络吞吐量就越大，传输效率就越高。我们的目标是在保证网络不拥塞的情况下尽量提高传输效率。</span> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;">那么所有的包都可以延迟应答么？肯定也不是：</span> 
 </div> 
 <blockquote> 
  <div> 
   <ul><li><span style="color:#0d0016;">数量限制：每隔N个包就应答一次</span></li><li><span style="color:#0d0016;">时间限制：超过最大延迟时间就应答一次</span></li></ul> 
  </div> 
 </blockquote> 
</div> 
<p> <span style="color:#333333;">具体的数量和超时时间，依操作系统不同也有差异，一般</span><span style="color:#333333;">N</span><span style="color:#333333;">取</span><span style="color:#333333;">2</span><span style="color:#333333;">，超时时间取</span><span style="color:#333333;">200ms。</span></p> 
<p class="img-center"><img alt="" height="385" src="https://images2.imgbox.com/82/09/FHko1wEe_o.png" width="676"></p> 
<h3 id="2.8%20%E6%8D%8E%E5%B8%A6%E5%BA%94%E7%AD%94(%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6)%C2%A0">2.8 捎带应答(效率机制) </h3> 
<div> 
 <span style="color:#333333;">        在延迟应答的基础上，我们发现很多情况下，客户端服务器在应用层也是</span> 
 <span style="color:#333333;"> "</span> 
 <span style="color:#333333;">一发一收</span> 
 <span style="color:#333333;">" </span> 
 <span style="color:#333333;">的。意味着客户端给服务器说了 "How are you"（请求）</span> 
 <span style="color:#333333;">，服务器也会给客户端回一个</span> 
 <span style="color:#333333;"> "Fine, thank you"(响应)，那么这个时候ACK</span> 
 <span style="color:#333333;">就可以搭顺风车，和服务器回应的</span> 
 <span style="color:#333333;"> "Fine</span> 
 <span style="color:#333333;">，</span> 
 <span style="color:#333333;">thank you" </span> 
 <span style="color:#333333;">一起回给客户端</span> 
</div> 
<p class="img-center"><img alt="" height="508" src="https://images2.imgbox.com/1b/a5/2yXYXuBW_o.png" width="802"></p> 
<h2 id="%E4%B8%89%E3%80%81%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%C2%A0">三、粘包问题 </h2> 
<blockquote> 
 <ul><li><span style="color:#0d0016;">首先要明确，粘包问题中的 "包" ，是指的应用层的数据包。 </span></li><li><span style="color:#0d0016;">在TCP的协议头中，没有如同UDP一样的 "报文长度" 这样的字段，但是有一个序号这样的字段。 </span></li><li><span style="color:#0d0016;">站在传输层的角度，TCP是一个一个报文过来的，按照序号排好序放在缓冲区中。 </span></li><li><span style="color:#0d0016;">站在应用层的角度，看到的只是一串连续的字节数据。 </span></li><li><span style="color:#0d0016;">那么应用程序看到了这么一连串的字节数据，就不知道从哪个部分开始到哪个部分，是一个完整的应用层数据包。</span></li></ul> 
</blockquote> 
<p><span style="color:#333333;">那么如何避免粘包问题呢？归根结底就是一句话，</span><span style="color:#333333;"><strong>明确两个包之间的边界</strong></span><span style="color:#333333;">。</span></p> 
<blockquote> 
 <p></p> 
 <ul><li><span style="color:#0d0016;">对于定长的包，保证每次都按固定大小读取即可。</span></li><li><span style="color:#0d0016;">对于变长的包，可以在包头的位置，约定一个包总长度的字段，从而就知道了包的结束位置。</span></li><li><span style="color:#0d0016;">对于变长的包，还可以在包和包之间使用明确的分隔符（应用层协议，是程序猿自己来定的，只要保证分隔符不和正文冲突即可）。</span></li></ul> 
</blockquote> 
<p> <span style="color:#333333;"><strong>思考</strong></span><span style="color:#333333;">：对于</span><span style="color:#333333;">UDP</span><span style="color:#333333;">协议来说，是否也存在</span><span style="color:#333333;"> "</span><span style="color:#333333;">粘包问题</span><span style="color:#333333;">" </span><span style="color:#333333;">呢？</span></p> 
<blockquote> 
 <ul><li><span style="color:#0d0016;">对于UDP，如果还没有上层交付数据，UDP的报文长度仍然在。同时，UDP是一个一个把数据交付给应用层，有很明确的数据边界。 </span></li><li><span style="color:#0d0016;">站在应用层的角度，使用UDP的时候，要么收到完整的UDP报文，要么不收，不会出现"半个"的情况。</span></li></ul> 
</blockquote> 
<h2 id="%E5%9B%9B%E3%80%81TCP%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%C2%A0">四、TCP异常情况 </h2> 
<ul><li><span style="color:#333333;">进程终止：进程终止会释放文件描述符，仍然可以发送</span><span style="color:#333333;">FIN</span><span style="color:#333333;">。和正常关闭没有什么区别。</span></li><li><span style="color:#333333;">机器重启：和进程终止的情况相同。</span></li></ul> 
<div> 
 <ul><li><span style="color:#333333;">机器掉电</span><span style="color:#333333;">/</span><span style="color:#333333;">网线断开：接收端认为连接还在，一旦接收端无写入操作，就可以发现连接已经不在了，就会进行reset</span><span style="color:#333333;">。即使没有写入操作，</span><span style="color:#333333;">TCP</span><span style="color:#333333;">自己也内置了一个保活定时器(心跳包)，会定期询问对方是否还在。如果对方不在，也会把连接释放。 </span></li></ul> 
 <h2 id="%E4%BA%94%E3%80%81TCP%E5%B0%8F%E7%BB%93"><span style="color:#333333;">五、TCP小结</span></h2> 
 <div> 
  <span style="color:#333333;">为什么</span> 
  <span style="color:#333333;">TCP</span> 
  <span style="color:#333333;">这么复杂？因为要保证可靠性，同时又尽可能的提高性能。</span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#fe2c24;"><strong>可靠性：</strong></span> 
  </div> 
  <div> 
   <ul><li><span style="color:#0d0016;">校验和 </span></li><li><span style="color:#0d0016;">序列号（按序到达） </span></li><li><span style="color:#0d0016;">确认应答 </span></li><li><span style="color:#0d0016;">超时重发 </span></li><li><span style="color:#0d0016;">连接管理 </span></li><li><span style="color:#0d0016;">流量控制 </span></li><li><span style="color:#0d0016;">拥塞控制 </span></li></ul> 
  </div> 
 </div> 
</div> 
<p><span style="color:#fe2c24;"><strong>提高性能： </strong></span></p> 
<ul><li><span style="color:#0d0016;">滑动窗口 </span></li><li><span style="color:#0d0016;">快速重传 </span></li><li><span style="color:#0d0016;">延迟应答 </span></li><li><span style="color:#0d0016;">捎带应答 </span></li></ul> 
<p><span style="color:#fe2c24;"><strong>其他：</strong></span><span style="color:#333333;"> </span></p> 
<ul><li><span style="color:#0d0016;">定时器（超时重传定时器，保活定时器，TIME_WAIT定时器等） </span></li></ul> 
<hr> 
<blockquote> 
 <p><span style="color:#fe2c24;">🛩️🛩️🛩️今天分享的有点多了，但是确实是干货满满，好啦，今天的分享就到这里。</span></p> 
 <p><span style="color:#1c7331;">🌈🌈🌈希望各位看官读完文章后，能够有所提升！</span></p> 
 <p><span style="color:#1c7331;">🎉🎉🎉创作不易，还希望各位大佬支持一下！</span></p> 
 <p><span style="color:#1c7331;">✈️✈️✈️点赞，你的认可是我创作的动力！</span></p> 
 <p><span style="color:#1c7331;">⭐⭐⭐收藏，你的青睐是我努力的方向！</span></p> 
 <p><span style="color:#1c7331;">✏️✏️✏️评论：你的意见是我进步的财富！</span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/85/4d/8yjavSpW_o.gif" width="300"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba4f5d499ac815fca94420148057d9d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;完成使用map Update数据 二进制数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac163fb8583cff14472ef6232fa6ce4e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">oracle增量恢复解决备库GAP问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>