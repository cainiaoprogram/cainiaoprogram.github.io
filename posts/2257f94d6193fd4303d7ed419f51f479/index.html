<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>shmget函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="shmget函数" />
<meta property="og:description" content="shmget int shmget(key_t key, size_t size, int flag);
key: 标识符的规则
size:共享存储段的字节数
flag:读写的权限
返回值：成功返回共享存储的id，失败返回-1
key_t key
-----------------------------------------------
key标识共享内存的键值: 0/IPC_PRIVATE。 当key的取值为IPC_PRIVATE，则函数shmget()将创建一块新的共享内存；如果key的取值为0，而参数shmflg中设置了IPC_PRIVATE这个标志，则同样将创建一块新的共享内存。
在IPC的通信模式下，不管是使用消息队列还是共享内存，甚至是信号量，每个IPC的对象(object)都有唯一的名字，称为“键”(key)。通过“键”，进程能够识别所用的对象。“键”与IPC对象的关系就如同文件名称之于文件，通过文件名，进程能够读写文件内的数据，甚至多个进程能够共用一个文件。而在IPC的通讯模式下，通过“键”的使用也使得一个IPC对象能为多个进程所共用。
Linux系统中的所有表示System V中IPC对象的数据结构都包括一个ipc_perm结构，其中包含有IPC对象的键值，该键用于查找System V中IPC对象的引用标识符。如果不使用“键”，进程将无法存取IPC对象，因为IPC对象并不存在于进程本身使用的内存中。
通常，都希望自己的程序能和其他的程序预先约定一个唯一的键值，但实际上并不是总可能的成行的，因为自己的程序无法为一块共享内存选择一个键值。因此，在此把key设为IPC_PRIVATE，这样，操作系统将忽略键，建立一个新的共享内存，指定一个键值，然后返回这块共享内存IPC标识符ID。而将这个新的共享内存的标识符ID告诉其他进程可以在建立共享内存后通过派生子进程，或写入文件或管道来实现。
int size(单位字节Byte)
-----------------------------------------------
size是要建立共享内存的长度。所有的内存分配操作都是以页为单位的。所以如果一段进程只申请一块只有一个字节的内存，内存也会分配整整一页(在i386机器中一页的缺省大小PACE_SIZE=4096字节)这样，新创建的共享内存的大小实际上是从size这个参数调整而来的页面大小。即如果size为1至4096，则实际申请到的共享内存大小为4K(一页)；4097到8192，则实际申请到的共享内存大小为8K(两页)，依此类推。
int shmflg
-----------------------------------------------
shmflg主要和一些标志有关。其中有效的包括IPC_CREAT和IPC_EXCL，它们的功能与open()的O_CREAT和O_EXCL相当。
IPC_CREAT 如果共享内存不存在，则创建一个共享内存，否则打开操作。
IPC_EXCL 只有在共享内存不存在的时候，新的共享内存才建立，否则就产生错误。
如果单独使用IPC_CREAT，shmget()函数要么返回一个已经存在的共享内存的操作符，要么返回一个新建的共享内存的标识符。如果将IPC_CREAT和IPC_EXCL标志一起使用，shmget()将返回一个新建的共享内存的标识符；如果该共享内存已存在，或者返回-1。IPC_EXEL标志本身并没有太大的意义，但是和IPC_CREAT标志一起使用可以用来保证所得的对象是新建的，而不是打开已有的对象。对于用户的读取和写入许可指定SHM_R和SHM_W,(SHM_R&gt;3)和(SHM_W&gt;3)是一组读取和写入许可，而(SHM_R&gt;6)和(SHM_W&gt;6)是全局读取和写入许可。
返回值
-----------------------------------------------
成功返回共享内存的标识符；不成功返回-1，errno储存错误原因。
EINVAL 参数size小于SHMMIN或大于SHMMAX。
EEXIST 预建立key所致的共享内存，但已经存在。
EIDRM 参数key所致的共享内存已经删除。
ENOSPC 超过了系统允许建立的共享内存的最大值(SHMALL )。
ENOENT 参数key所指的共享内存不存在，参数shmflg也未设IPC_CREAT位。
EACCES 没有权限。
ENOMEM 核心内存不足。
struct shmid_ds
-----------------------------------------------
shmid_ds数据结构表示每个新建的共享内存。当shmget()创建了一块新的共享内存后，返回一个可以用于引用该共享内存的shmid_ds数据结构的标识符。
include/linux/shm.h
struct shmid_ds { struct ipc_perm shm_perm; /* operation perms */ int shm_segsz; /* size of segment (bytes) */ __kernel_time_t shm_atime; /* last attach time */ __kernel_time_t shm_dtime; /* last detach time */ __kernel_time_t shm_ctime; /* last change time */ __kernel_ipc_pid_t shm_cpid; /* pid of creator */ __kernel_ipc_pid_t shm_lpid; /* pid of last operator */ unsigned short shm_nattch; /* no." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2257f94d6193fd4303d7ed419f51f479/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-28T14:29:16+08:00" />
<meta property="article:modified_time" content="2021-01-28T14:29:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">shmget函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="articleContentId">shmget</h2> 
<p>int shmget(key_t   key, size_t   size, int   flag);</p> 
<p>key: 标识符的规则</p> 
<p>size:共享存储段的字节数</p> 
<p>flag:读写的权限</p> 
<p>返回值：成功返回共享存储的id，失败返回-1</p> 
<p> </p> 
<p><strong>key_t key</strong><br> -----------------------------------------------<br>     key标识共享内存的键值: <strong>0/IPC_PRIVATE</strong>。 当key的取值为IPC_PRIVATE，则函数shmget()将创建一块新的共享内存；如果key的取值为0，而参数shmflg中设置了IPC_PRIVATE这个标志，则同样将创建一块新的共享内存。<br>     在IPC的通信模式下，不管是使用消息队列还是共享内存，甚至是信号量，每个IPC的对象(object)都有唯一的名字，称为“键”(key)。通过“键”，进程能够识别所用的对象。“键”与IPC对象的关系就如同文件名称之于文件，通过文件名，进程能够读写文件内的数据，甚至多个进程能够共用一个文件。而在IPC的通讯模式下，通过“键”的使用也使得一个IPC对象能为多个进程所共用。<br>     Linux系统中的所有表示System V中IPC对象的数据结构都包括一个ipc_perm结构，其中包含有IPC对象的键值，该键用于查找System V中IPC对象的引用标识符。如果不使用“键”，进程将无法存取IPC对象，因为IPC对象并不存在于进程本身使用的内存中。<br>     通常，都希望自己的程序能和其他的程序预先约定一个唯一的键值，但实际上并不是总可能的成行的，因为自己的程序无法为一块共享内存选择一个键值。因此，在此把key设为IPC_PRIVATE，这样，操作系统将忽略键，建立一个新的共享内存，指定一个键值，然后返回这块共享内存IPC标识符ID。而将这个新的共享内存的标识符ID告诉其他进程可以在建立共享内存后通过派生子进程，或写入文件或管道来实现。</p> 
<p><strong>int size(单位字节Byte)</strong><br> -----------------------------------------------<br>     size是要建立共享内存的长度。所有的内存分配操作都是以页为单位的。所以如果一段进程只申请一块只有一个字节的内存，内存也会分配整整一页(在i386机器中一页的缺省大小PACE_SIZE=4096字节)这样，新创建的共享内存的大小实际上是从size这个参数调整而来的页面大小。即如果size为1至4096，则实际申请到的共享内存大小为4K(一页)；4097到8192，则实际申请到的共享内存大小为8K(两页)，依此类推。<br><br><br><strong>int shmflg</strong><br> -----------------------------------------------<br>     shmflg主要和一些标志有关。其中有效的包括IPC_CREAT和IPC_EXCL，它们的功能与open()的O_CREAT和O_EXCL相当。<br>     IPC_CREAT   如果共享内存不存在，则创建一个共享内存，否则打开操作。<br>     IPC_EXCL    只有在共享内存不存在的时候，新的共享内存才建立，否则就产生错误。<br><br>     如果单独使用IPC_CREAT，shmget()函数要么返回一个已经存在的共享内存的操作符，要么返回一个新建的共享内存的标识符。如果将IPC_CREAT和IPC_EXCL标志一起使用，shmget()将返回一个新建的共享内存的标识符；如果该共享内存已存在，或者返回-1。IPC_EXEL标志本身并没有太大的意义，但是和IPC_CREAT标志一起使用可以用来保证所得的对象是新建的，而不是打开已有的对象。对于用户的读取和写入许可指定<strong>SHM_R</strong>和<strong>SHM_W</strong>,(SHM_R&gt;3)和(SHM_W&gt;3)是一组读取和写入许可，而(SHM_R&gt;6)和(SHM_W&gt;6)是全局读取和写入许可。<br><br><br><strong>返回值</strong><br> -----------------------------------------------<br> 成功返回共享内存的标识符；不成功返回-1，errno储存错误原因。<br>     EINVAL        参数size小于SHMMIN或大于SHMMAX。<br>     EEXIST        预建立key所致的共享内存，但已经存在。<br>     EIDRM         参数key所致的共享内存已经删除。<br>     ENOSPC        超过了系统允许建立的共享内存的最大值(SHMALL )。<br>     ENOENT        参数key所指的共享内存不存在，参数shmflg也未设IPC_CREAT位。<br>     EACCES        没有权限。<br>     ENOMEM        核心内存不足。<br><br><br><strong>struct shmid_ds</strong><br> -----------------------------------------------<br>     shmid_ds数据结构表示每个新建的共享内存。当shmget()创建了一块新的共享内存后，返回一个可以用于引用该共享内存的shmid_ds数据结构的标识符。<br><br> include/linux/shm.h<br><br>     struct shmid_ds { <br>         struct ipc_perm    shm_perm;      /* operation perms */ <br>         int                shm_segsz;     /* size of segment (bytes) */ <br>         __kernel_time_t    shm_atime;     /* last attach time */ <br>         __kernel_time_t    shm_dtime;     /* last detach time */ <br>         __kernel_time_t    shm_ctime;     /* last change time */ <br>         __kernel_ipc_pid_t shm_cpid;      /* pid of creator */ <br>         __kernel_ipc_pid_t shm_lpid;      /* pid of last operator */ <br>         unsigned short     shm_nattch;    /* no. of current attaches */ <br>         unsigned short     shm_unused;    /* compatibility */ <br>         void               *shm_unused2; /* ditto - used by DIPC */ <br>         void               *shm_unused3; /* unused */ <br>     };<br><br><br><strong>struct ipc_perm</strong><br> -----------------------------------------------<br>     对于每个IPC对象，系统共用一个struct ipc_perm的数据结构来存放权限信息，以确定一个ipc操作是否可以访问该IPC对象。<br><br>     struct ipc_perm { <br>         __kernel_key_t   key; <br>         __kernel_uid_t   uid; <br>         __kernel_gid_t   gid; <br>         __kernel_uid_t   cuid; <br>         __kernel_gid_t   cgid; <br>         __kernel_mode_t mode; <br>         unsigned short   seq; <br> };</p> 
<p>//----------------------------------------</p> 
<p> </p> 
<p>shmat</p> 
<p>void *shmat(int   shmid, const void * addr, int   flag);</p> 
<p>shmid：共享存储的id</p> 
<p>addr：一般为0，表示连接到由内核选择的第一个可用地址上，否则，如果flag没有指定SHM_RND，则连接到addr所指定的地址上，如果flag为SHM_RND，则地址取整</p> 
<p>flag：如前所述，一般为0</p> 
<p>返回值：如果成功，返回共享存储段地址，出错返回-1</p> 
<p>shmdt</p> 
<p>int shmdt(void *addr);</p> 
<p>addr:共享存储段的地址，以前调用shmat时的返回值</p> 
<p>shmdt将使相关shmid_ds结构中的shm_nattch计数器值减1</p> 
<p>shmctl</p> 
<p>int shmctl(int shmid,int cmd,struct shmid_ds *buf)</p> 
<p>shmid:共享存储段的id</p> 
<p>cmd：一些命令，有：IPC_STAT,IPC_RMID,SHM_LOCK,SHM_UNLOCK</p> 
<p> </p> 
<p> </p> 
<p>请注意，共享内存不会随着程序结束而自动消除，要么调用shmctl删除，要么自己用手敲命令去删除，否则永远留在系统中。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0827a954a771b97ba8caa5e1ee3d61be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">登陆服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d8b43fd78f213604f9305fa452b639b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IDL编程：利用shp文件批量裁剪</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>