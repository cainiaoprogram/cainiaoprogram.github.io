<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>App开放接口api安全性—Token签名sign的设计与实现 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="App开放接口api安全性—Token签名sign的设计与实现" />
<meta property="og:description" content="前言 在app开放接口api的设计中，避免不了的就是安全性问题，因为大多数接口涉及到用户的个人信息以及一些敏感的数据，所以对这些接口需要进行身份的认证，那么这就需要用户提供一些信息，比如用户名密码等，但是为了安全起见让用户暴露的明文密码次数越少越好，我们一般在web项目中，大多数采用保存的session中，然后在存一份到cookie中，来保持用户的回话有效性。但是在app提供的开放接口中，后端服务器在用户登录后如何去验证和维护用户的登陆有效性呢，以下是参考项目中设计的解决方案，其原理和大多数开放接口安全验证一样，如淘宝的开放接口token验证，微信开发平台token验证都是同理。
签名设计 对于敏感的api接口，需使用https协议 https是在http超文本传输协议加入SSL层，它在网络间通信是加密的，所以需要加密证书。
https协议需要ca证书，一般需要交费。
签名的设计 原理：用户登录后向服务器提供用户认证信息（如账户和密码），服务器认证完后给客户端返回一个Token令牌，用户再次获取信息时，带上此令牌，如果令牌正取，则返回数据。对于获取Token信息后，访问用户相关接口，客户端请求的url需要带上如下参数：
时间戳：timestamp
Token令牌：token
然后将所有用户请求的参数按照字母排序（包括timestamp，token），然后更具MD5加密（可以加点盐），全部大写，生成sign签名，这就是所说的url签名算法。然后登陆后每次调用用户信息时，带上sign，timestamp，token参数。
例如：原请求https://www.andy.cn/api/user/update/info.shtml?city=北京 （post和get都一样，对所有参数排序加密）
加上时间戳和token
https://www.andy.cn/api/user/update/info.shtml?city=北京&amp;timestamp=12445323134&amp;token=wefkfjdskfjewfjkjfdfnc
然后更具url参数生成sign
最终的请求如
https://www.andy.cn/api/user/update/info.shtml?city=北京&amp;timestamp=12445323134&amp;token=wefkfjdskfjewfjkjfdfnc&amp;sign=FDK2434JKJFD334FDF2
其最终的原理是减小明文的暴露次数；保证数据安全的访问。
具体实现如下：
1. api请求客户端想服务器端一次发送用用户认证信息（用户名和密码），服务器端请求到改请求后，验证用户信息是否正确。
如果正确：则返回一个唯一不重复的字符串（一般为UUID），然后在Redis（任意缓存服务器）中维护Token----Uid的用户信息关系，以便其他api对token的校验。
如果错误：则返回错误码。
2.服务器设计一个url请求拦截规则
（1）判断是否包含timestamp，token，sign参数，如果不含有返回错误码。
（2）判断服务器接到请求的时间和参数中的时间戳是否相差很长一段时间（时间自定义如半个小时），如果超过则说明该 url已经过期（如果url被盗，他改变了时间戳，但是会导致sign签名不相等）。
（3）判断token是否有效，根据请求过来的token，查询redis缓存中的uid，如果获取不到这说明该token已过期。
（4）根据用户请求的url参数，服务器端按照同样的规则生成sign签名，对比签名看是否相等，相等则放行。（自然url签名 也无法100%保证其安全，也可以通过公钥AES对数据和url加密，但这样如果无法确保公钥丢失，所以签名只是很大程 度上保证安全）。
（5）此url拦截只需对获取身份认证的url放行（如登陆url），剩余所有的url都需拦截。
3.Token和Uid关系维护
对于用户登录我们需要创建token--uid的关系，用户退出时需要需删除token--uid的关系。
签名实现 获取全部请求参数
String sign = request.getParameter(&#34;sign&#34;); Enumeration&lt;?&gt; pNames = request.getParameterNames(); Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); while (pNames.hasMoreElements()) { String pName = (String) pNames.nextElement(); if(&#34;sign&#34;.equals(pName))continue; Object pValue = request.getParameter(pName); params.put(pName, pValue); } 生成签名" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/874913242ef96250b12fff9cd80d7924/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-09-27T17:44:55+08:00" />
<meta property="article:modified_time" content="2015-09-27T17:44:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">App开放接口api安全性—Token签名sign的设计与实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="font-size:18px">前言</span></h2> 
<p><span style="font-size:14px">       在app开放接口api的设计中，避免不了的就是安全性问题，因为大多数接口涉及到用户的个人信息以及一些敏感的数据，所以对这些接口需要进行身份的认证，那么这就需要用户提供一些信息，比如用户名密码等，但是为了安全起见让用户暴露的明文密码次数越少越好，我们一般在web项目中，大多数采用保存的session中，然后在存一份到cookie中，来保持用户的回话有效性。但是在app提供的开放接口中，后端服务器在用户登录后如何去验证和维护用户的登陆有效性呢，以下是参考项目中设计的解决方案，其原理和大多数开放接口安全验证一样，如淘宝的开放接口token验证，微信开发平台token验证都是同理。</span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<h2><span style="font-size:18px">签名设计</span></h2> 
<h3><span style="font-size:14px">     对于敏感的api接口，需使用https协议</span></h3> 
<p><span style="font-size:14px">           https是在http超文本传输协议加入SSL层，它在网络间通信是加密的，所以需要加密证书。</span></p> 
<p><span style="font-size:14px">           https协议需要ca证书，一般需要交费。</span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<h3><span style="font-size:14px">     签名的设计</span></h3> 
<p><span style="font-size:14px">           原理：用户登录后向服务器提供用户认证信息（如账户和密码），服务器认证完后给客户端返回一个Token令牌，用户再次获取信息时，带上此令牌，如果令牌正取，则返回数据。对于获取Token信息后，访问用户相关接口，客户端请求的url需要带上如下参数：</span></p> 
<p><span style="font-size:14px">         时间戳：timestamp</span></p> 
<p><span style="font-size:14px">         Token令牌：token</span></p> 
<p><span style="font-size:14px">         然后将所有用户请求的参数按照字母排序（包括timestamp，token），然后更具MD5加密（可以加点盐），全部大写，生成sign签名，这就是所说的url签名算法。然后登陆后每次调用用户信息时，带上sign，timestamp，token参数。</span></p> 
<p><span style="font-size:14px">例如：原请求https://www.andy.cn/api/user/update/info.shtml?city=北京 （post和get都一样，对所有参数排序加密）</span></p> 
<p><span style="font-size:14px"> 加上时间戳和token</span></p> 
<p><span style="font-size:14px">       <span style="font-size:14px">https://www.andy.cn/api/user/update/info.shtml?city=北京&amp;timestamp=12445323134&amp;token=wefkfjdskfjewfjkjfdfnc</span></span></p> 
<p><span style="font-size:14px">      然后更具url参数生成sign</span></p> 
<p><span style="font-size:14px">      最终的请求如</span></p> 
<p><span style="font-size:14px">         <span style="font-size:14px">https://www.andy.cn/api/user/update/info.shtml?city=北京&amp;timestamp=12445323134&amp;token=wefkfjdskfjewfjkjfdfnc&amp;sign=FDK2434JKJFD334FDF2</span></span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px">其最终的原理是减小明文的暴露次数；保证数据安全的访问。</span></p> 
<p><span style="font-size:14px">具体实现如下：</span></p> 
<p><span style="font-size:14px">           1. api请求客户端想服务器端一次发送用用户认证信息（用户名和密码），服务器端请求到改请求后，验证用户信息是否正确。</span></p> 
<p><span style="font-size:14px">        如果正确：则返回一个唯一不重复的字符串（一般为UUID），然后在Redis（任意缓存服务器）中维护Token----Uid的用户信息关系，以便其他api对token的校验。</span></p> 
<p><span style="font-size:14px">        如果错误：则返回错误码。</span></p> 
<p><span style="font-size:14px">          </span></p> 
<p><span style="font-size:14px">            2.服务器设计一个url请求拦截规则</span></p> 
<p><span style="font-size:14px">               （1）判断是否包含timestamp，token，sign参数，如果不含有返回错误码。</span></p> 
<p><span style="font-size:14px">               （2）判断服务器接到请求的时间和参数中的时间戳是否相差很长一段时间（时间自定义如半个小时），如果超过则说明该                         url已经过期（如果url被盗，他改变了时间戳，但是会导致sign签名不相等）。</span></p> 
<p><span style="font-size:14px">               （3）判断token是否有效，根据请求过来的token，查询redis缓存中的uid，如果获取不到这说明该token已过期。</span></p> 
<p><span style="font-size:14px">               （4）根据用户请求的url参数，服务器端按照同样的规则生成sign签名，对比签名看是否相等，相等则放行。（自然url签名                       也无法100%保证其安全，也可以通过公钥AES对数据和url加密，但这样如果无法确保公钥丢失，所以签名只是很大程                       度上保证安全）。</span></p> 
<p><span style="font-size:14px">                （5）此url拦截只需对获取身份认证的url放行（如登陆url），剩余所有的url都需拦截。</span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px">            3.Token和Uid关系维护</span></p> 
<p><span style="font-size:14px">               对于用户登录我们需要创建token--uid的关系，用户退出时需要需删除token--uid的关系。</span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<h2><span style="font-size:18px">签名实现</span></h2> 
<p><span style="font-size:14px">          获取全部请求参数</span></p> 
<p><span style="font-size:14px">              </span></p> 
<pre><code class="language-java">               String sign = request.getParameter("sign");
		Enumeration&lt;?&gt; pNames =  request.getParameterNames();
		Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();
		while (pNames.hasMoreElements()) {
			String pName = (String) pNames.nextElement();
			if("sign".equals(pName))continue;
			Object pValue = request.getParameter(pName);
			params.put(pName, pValue);
		}</code></pre>    
<p></p> 
<p><span style="font-size:14px">           生成签名</span></p> 
<p><span style="font-size:14px">           </span></p> 
<pre><code class="language-java">        public static String createSign(Map&lt;String, String&gt; params, boolean encode)
			throws UnsupportedEncodingException {
		Set&lt;String&gt; keysSet = params.keySet();
		Object[] keys = keysSet.toArray();
		Arrays.sort(keys);
		StringBuffer temp = new StringBuffer();
		boolean first = true;
		for (Object key : keys) {
			if (first) {
				first = false;
			} else {
				temp.append("&amp;");
			}
			temp.append(key).append("=");
			Object value = params.get(key);
			String valueString = "";
			if (null != value) {
				valueString = String.valueOf(value);
			}
			if (encode) {
				temp.append(URLEncoder.encode(valueString, "UTF-8"));
			} else {
				temp.append(valueString);
			}
		}

		return MD5Utils.getMD5(temp.toString()).toUpperCase();
	}</code></pre> 
<br> 
<p></p> 
<p><span style="font-size:14px">               </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ffe150206d03285c608f0974051d004/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">修改tomcat中的字符集问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d808cf07cbf2e6186f5db14ddc64d73d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Matlab - jacobian函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>