<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>idea 枚举快速_快速可枚举的枚举 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="idea 枚举快速_快速可枚举的枚举" />
<meta property="og:description" content="idea 枚举快速
I had a very basic knowledge of Codable which was limited to how to convert JSON data into primitive types such as String, Int, Bool, etc. or how to work with nested JSON objects and Arrays. I have been using it for quite a long time and it was sufficient for the project code to work. But Codable is more powerful than this.
我对Codable有非常基础的知识，其知识仅限于如何将JSON数据转换为基本类型(例如String ， Int ， Bool等)或如何使用嵌套的JSON对象和数组。 我已经使用了很长时间了，足以使项目代码正常工作。 但是Codable比这更强大。 In this article, we will discuss a scenario where the JSON we receive has an enum type." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/688f89bcddbb570265826d4389823339/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-14T15:08:38+08:00" />
<meta property="article:modified_time" content="2020-08-14T15:08:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">idea 枚举快速_快速可枚举的枚举</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <article style="font-size: 16px;"> 
 <p>idea 枚举快速</p> 
 <div> 
  <section> 
   <div> 
    <div> 
     <p>I had a very basic knowledge of <em>Codable </em>which was limited to how to convert JSON data into primitive types such as <em>String</em>, <em>Int</em>, <em>Bool, </em>etc. or how to work with nested JSON objects and <em>Arrays. </em>I have been using it for quite a long time and it was sufficient for the project code to work. But <em>Codable</em> is more powerful than this.</p> 
     <p> 我对<em>Codable</em>有非常基础的知识，其知识仅限于如何将JSON数据转换为基本类型(例如<em>String</em> ， <em>Int</em> ， <em>Bool</em>等)或如何使用嵌套的JSON对象和<em>数组。</em> 我已经使用了很长时间了，足以使项目代码正常工作。 但是<em>Codable</em>比这更强大。 </p> 
     <p>In this article, we will discuss a scenario where the JSON we receive has an <em>enum</em> type. Earlier if I had received an <em>enum</em>(which means the value for this key would be within a set of values) in response, I would have converted it to primitive type first, and later in the presenter or view-model layer, I would have converted it to an <em>enum</em>. I am sure most of you would have done the same.</p> 
     <p> 在本文中，我们将讨论一个场景，其中我们收到的JSON具有<em>枚举</em>类型。 早些时候，如果我收到一个<em>枚举</em> (这意味着此键的值将在一组值之内)作为响应，我将首先将其转换为原始类型，然后在presenter或view-model层中，将其转换为<em>枚举</em> 。 我相信你们大多数人都会做同样的事情。 </p> 
     <p>Now, let’s learn how to convert data to <em>enum</em> in the network layer itself.</p> 
     <p> 现在，让我们学习如何将数据转换为网络层本身中的<em>枚举</em> 。 </p> 
     <blockquote> 
      <p>Let’s make our network layer more powerful.</p> 
      <p> 让我们使网络层更强大。 </p> 
     </blockquote> 
     <h3> 具枚举的枚举 <span style="font-weight: bold;">(</span>Enums With Decodable<span style="font-weight: bold;">)</span></h3> 
     <p>Let’s consider the following JSON for example:</p> 
     <p> 让我们以下面的JSON为例： </p> 
     <pre><code class="has">{<!-- --><br>   "order": {<!-- --><br>          "id": 12678,<br>          "status": "Shipped",<br>          "item": {<!-- --><br>                "id": 1209,<br>                "handleWithCare": false<br>           }<br>    }<br>}</code></pre> 
     <p>Here, <em>status</em> can hold a pre-defined set of values like <em>Pending</em>, <em>Shipped, Approved,</em> etc. Generally, I would have kept the type for <em>status</em> as <em>String</em> while parsing and later on I would have converted it into an <em>enum</em>. So my JSON model would look something like this:</p> 
     <p> 在这里， <em>status</em>可以包含一组预定义的值，例如<em>Pending</em> ， <em>Shipped，Approved</em>等。通常，在解析时，我会将<em>status</em>的类型保留为<em>String</em> ，以后再将其转换为<em>enum</em> 。 因此，我的JSON模型如下所示： </p> 
     <pre><code class="has"><strong>struct</strong> OrderResponse : Decodable {<!-- --><strong>var</strong> order: Order?<br>}<strong>struct</strong> Order: Decodable {<!-- --><strong>var</strong> id: Int?<strong>var</strong> status: String?<strong>var</strong> item: Item?<br>}<strong>struct</strong> Item: Decodable {<!-- --><strong>var</strong> id: Int?<strong>var</strong> handleWithCare: Bool?<br>}</code></pre> 
     <p><em>status </em>can easily be converted into an Enum type as shown below:</p> 
     <p> <em>状态</em>可以轻松地转换为Enum类型，如下所示： </p> 
     <pre><code class="has"><strong>struct</strong> OrderResponse: Decodable {<!-- --><strong>var</strong> order: Order?<br>}<strong>struct</strong> Order: Decodable {<!-- --><strong>var</strong> id: Int?<strong>var</strong> status: OrderStatus?<strong>var</strong> item: Item?<br>}<strong>struct</strong> Item: Decodable {<!-- --><strong>var</strong> id: Int?<strong>var</strong> handleWithCare: Bool?<br>}<strong>enum</strong> OrderStatus: String, Decodable {<!-- --><strong>case</strong> pending = "Pending"<strong>case</strong> approved = "Approved"<strong>case</strong> shipped = "Shipped"<strong>case</strong> delivered = "Delivered"<strong>case</strong> cancelled = "Cancelled"<br>}</code></pre> 
     <p>You might be thinking, so what’s a big deal in that? How you have created a <em>struct</em> for <em>Item, </em>you could have created an <em>enum </em>with raw values for<em> status. </em>This is what I have done in the example as well.</p> 
     <p> 您可能在想，那有什么大不了的？ 如何为<em>Item</em>创建<em>结构</em> <em>，</em>您可能已经创建了带有原始<em>状态</em>值的<em>枚举</em> <em>。</em> 这也是我在示例中所做的。 </p> 
     <p>This would work perfectly in an ideal situation where the value of <em>status </em>is<em> </em>anything from this pre-defined set only. Now consider a case where this code is in the production environment and what if backend has decided to add a new value, <em>InProcess </em>to this set. You would handle the new value in the existing code. But what will happen to the production app? In this scenario, the JSON data will not be parsed and hence will error out with <strong>Swift.DecodingError.dataCorrupted</strong>.</p> 
     <p> 这在<em>状态</em>价值为 <em> </em> 仅来自此预定义集中的任何内容。 现在考虑这种代码在生产环境中的情况，以及如果后端决定向此集合添加新值<em>InProcess</em>的情况。 您将在现有代码中处理新值。 但是生产应用程序会发生什么？ 在这种情况下，将不会解析JSON数据，因此会因<strong>Swift.DecodingError.dataCorrupted</strong>错误而<strong>出错</strong> 。 </p> 
     <h2> 如何解决这个问题？ <span style="font-weight: bold;">(</span>How to resolve this problem?<span style="font-weight: bold;">)</span></h2> 
     <p>To solve this, we have to make changes to the <em>enum </em>which we have just created. Add an <em>unknown</em> case with an associated type. As associated values cannot have raw values, you have to remove all the raw values. Now your enum would look something like this:</p> 
     <p> 为了解决这个问题，我们必须对刚刚创建的<em>枚举</em>进行更改。 添加具有关联类型的<em>未知</em>案例。 由于关联值不能具有原始值，因此必须删除所有原始值。 现在，您的枚举将如下所示： </p> 
     <pre><code class="has"><strong>enum</strong> OrderStatus: Decodable {<!-- --><strong>case</strong> pending, approved, shipped, delivered, cancelled<strong>case</strong> unknown(value: String)<br>}</code></pre> 
     <p>Now, there is an issue here. Since your parser doesn’t know which JSON key should be mapped to which case, Xcode will throw <strong>Type ‘OrderStatus’ does not conform to protocol ‘Decodable’ </strong>error<strong> </strong>when you try to compile the code. Let’s go ahead and add the stub:</p> 
     <p> 现在，这里有一个问题。 由于您的解析器不知道哪个JSON密钥应映射到哪种情况，因此Xcode会抛出<strong>类型“ OrderStatus”不符合协议“可解码”</strong>错误 <strong> </strong> 当您尝试编译代码时。 让我们继续并添加存根： </p> 
     <pre><code class="has"><strong>enum</strong> OrderStatus: Decodable {<!-- --><strong>case</strong> pending, approved, shipped, delivered, cancelled<strong>case</strong> unknown(value: String)<strong>init</strong>(from decoder: Decoder) <strong>throws</strong> {<!-- --><br>    }<br>}</code></pre> 
     <p>You have to add the mapping inside the initializer. But how to do that? You have to use a container for that. <em>Codable</em> provides two containers: <em>KeyedDecodingContainer </em>and<em> SingleValueDecodingContainer</em>. <em>KeyedDecodingContainer </em>is used when you are working with keys. You need to pass the keys to the container and it will return the value for the respective keys. As the name suggests <em>SingleValueDecodingContainer</em> can be used when you are not working with key-value pairs, which is the current scenario.</p> 
     <p> 您必须在初始化器中添加映射。 但是该怎么做呢？ 您必须为此使用一个容器。 <em>Codable</em>提供了两个容器： <em>KeyedDecodingContainer</em>和<em>SingleValueDecodingContainer</em> 。 使用键时使用<em>KeyedDecodingContainer</em> 。 您需要将密钥传递给容器，容器将返回各个密钥的值。 顾名思义，当您不使用键值对时(当前情况)，可以使用<em>SingleValueDecodingContainer</em> 。 </p> 
     <p>We will create a <em>SingleValueDecodingContainer </em>and<em> </em>retrieve the <em>String </em>data. Now, this data could be mapped to different <em>enum</em> cases as shown below:</p> 
     <p> 我们将创建一个<em>SingleValueDecodingContainer</em>和 <em> </em> 检索<em>字符串</em>数据。 现在，可以将这些数据映射到不同的<em>枚举</em>实例，如下所示： </p> 
     <pre><code class="has"><strong>enum</strong> OrderStatus: Decodable {<!-- --><strong>case</strong> pending, approved, shipped, delivered, cancelled<strong>case</strong> unknown(value: String)<strong>init</strong>(from decoder: Decoder) <strong>throws</strong> {<!-- --><strong>let</strong> container = <strong>try</strong> decoder.singleValueContainer()<strong>let</strong> status = <strong>try</strong>? container.decode(String.<strong>self</strong>)<strong>switch</strong> status {<!-- --><strong>case</strong> "Pending": <strong>self</strong> = .pending<strong>case</strong> "Approved": <strong>self</strong> = .approved<strong>case</strong> "Shipped": <strong>self</strong> = .shipped<strong>case</strong> "Delivered": <strong>self</strong> = .delivered<strong>case</strong> "Cancelled": <strong>self</strong> = .cancelled<strong>default</strong>:<strong>self</strong> = .unknown(value: status ?? "unknown")<br>          }<br>      }<br>}</code></pre> 
     <p>Now build and run the code. You can see that the errors are gone and the <em>status </em>is parsed into <em>OrderStatus</em> type. Now go ahead and change the value of <em>status</em> in JSON to <em>InProcess</em>. Now status is mapped correctly to the <em>unknown </em>case with value <em>InProcess</em>: <strong>unknown(value: “InProcess”). </strong>With this even if new values are sent in <em>status, y</em>our production code will not break and work just fine. You just need to handle generic <em>unknown(value) </em>case in the app.</p> 
     <p> 现在构建并运行代码。 您可以看到错误消失了，并且<em>状态</em>被解析为<em>OrderStatus</em>类型。 现在，将JSON <em>中</em>的<em>status</em>值更改为<em>InProcess</em> 。 现在，状态已正确映射到值为<em>InProcess</em>的<em>未知</em>案例： <strong>unknown(值：“ InProcess”)。</strong> 这样，即使<em>状态</em>中发送了新值<em>，您</em>的生产代码也不会中断并且可以正常工作。 您只需要在应用程序中处理一般的<em>unknown(value)</em>大小写。 </p> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <p>The entire code would look like this:</p> 
     <p> 整个代码如下所示： </p> 
     <pre><code class="has"><strong>let</strong> testJson = """<br>{<!-- --><br> "order": {<!-- --><br> "id": 12678,<br> "status": "InProcess",<br> "item": {<!-- --><br>       "id": 1209,<br>       "handleWithCare": false<br>       }<br>  }<br>}<br>""".data(using: .utf8)<strong>struct</strong> OrderResponse : Decodable {<!-- --><strong>var</strong> order: Order?<br>}<strong>struct</strong> Order: Decodable {<!-- --><strong>var</strong> id: Int?<strong>var</strong> status: OrderStatus?<strong>var</strong> item: Item?<br>}<strong>struct</strong> Item: Decodable {<!-- --><strong>var</strong> id: Int?<strong>var</strong> handleWithCare: Bool?<br>}<strong>enum</strong> OrderStatus: Decodable {<!-- --><strong>case</strong> pending, approved, shipped, delivered, cancelled<strong>case</strong> unknown(value: String)<strong>init</strong>(from decoder: Decoder) <strong>throws</strong> {<!-- --><strong>let</strong> container = <strong>try</strong> decoder.singleValueContainer()<strong>let</strong> status = <strong>try</strong>? container.decode(String.<strong>self</strong>)<strong>switch</strong> status {<!-- --><strong>case</strong> "Pending": <strong>self</strong> = .pending<strong>case</strong> "Approved": <strong>self</strong> = .approved<strong>case</strong> "Shipped": <strong>self</strong> = .shipped<strong>case</strong> "Delivered": <strong>self</strong> = .delivered<strong>case</strong> "Cancelled": <strong>self</strong> = .cancelled<strong>default</strong>:<strong>self</strong> = .unknown(value: status ?? "unknown")<br>         }<br>     }<br>}<strong>if</strong> <strong>let</strong> orderResponse = <strong>try</strong>? JSONDecoder().decode(OrderResponse.<strong>self</strong>, from: testJson!) {<!-- --><br>       print(orderResponse)<br>}</code></pre> 
     <p>Go ahead, paste this code in the playground, and try it yourself. You can try different values for the <em>status</em> and check if it is working fine or not.</p> 
     <p> 继续，将此代码粘贴到操场上，然后自己尝试。 您可以为<em>状态</em>尝试不同的值，并检查其是否工作正常。 </p> 
     <p>I hope this was helpful. Thank you!</p> 
     <p> 我希望这可以帮到你。 谢谢！ </p> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <p>[1] <a target="_blank" rel="nofollow noopener noreferrer" href="https://medium.com/swiftly-swift/swift-4-decodable-beyond-the-basics-990cc48b7375">https://medium.com/swiftly-swift/swift-4-decodable-beyond-the-basics-990cc48b7375</a></p> 
     <p> [1] <a target="_blank" rel="nofollow noopener noreferrer" href="https://medium.com/swiftly-swift/swift-4-decodable-beyond-the-basics-990cc48b7375">https://medium.com/swiftly-swift/swift-4-decodable-beyond-the-basics-990cc48b7375</a> </p> 
     <p>[2] <a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types" rel="noopener nofollow noopener noreferrer" target="_blank">https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types</a></p> 
     <p> [2] <a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types" rel="noopener nofollow noopener noreferrer" target="_blank">https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types</a> </p> 
    </div> 
   </div> 
  </section> 
 </div> 
 <blockquote> 
  <p>翻译自: <a href="https://medium.com/swlh/enums-with-decodable-in-swift-2bbc2ddddd6f" rel="nofollow">https://medium.com/swlh/enums-with-decodable-in-swift-2bbc2ddddd6f</a></p> 
 </blockquote> 
 <p>idea 枚举快速</p> 
</article>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5aae87de55ac343f57e49d5aad925e2a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">神经网络骨架network backbones</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b015733c91251383e93caf1e77b4808d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QT-GraphicScene大于GraphicView时，场景居中问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>