<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VRF - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VRF" />
<meta property="og:description" content="VRF简介及创建 1.VRF理解 VRF相当于一个个独立路由表，STATIC是路由表里的一个(条目)策略，添加vrf相当于隔离建立多个独立的路由器。
2.VRF应用需求 假设PC1与R2这一侧的网络属于一个独立的业务；PC2与R3这一侧的网络属于另一个独立的业务，由于设备资源有限或者其他方面的原因，这两个独立的业务的相关节点连接在R1上，也就是同一台设备上。那么在完成相关配置后，R1的路由表如上图所示。
现在如果PC1要发一个数据包到2.2.2.2，那么这个数据包在到达R1后，R1就会去查看自己的路由表，发现有一条2.2.2.0/24的路由匹配，因此将这个IP包从GE0/0/2口转发给192.168.100.2。这是没有问题的，然而如果PC1要访问3.3.3.0/24网络呢？也是无压力的，因为数据包到达R1后，她照样查找路由表结果发现有匹配的路由，因此将数据包转给R3。但是实际上，从业务的角度考虑，我们禁止PC1访问3.3.3.0/24网络。
那么怎么办？
现在，我们在R1上创建两个VRF：VRF1及VRF2，创建完成后，我们可以理解为，拥有了两台虚拟路由器。当然，现在这两台虚拟路由器上啥也没有。
接下去我们将GE0/0/1口及GE0/0/2口绑定到VRF1；将GE0/0/3及GE0/0/4口绑定到VRF2。如此一来这两台虚拟路由器就各自拥有了两个物理接口。值得注意的是，这两台虚拟路由器是虽然都在同一台物理设备上，但是却是隔离的，他们将有自己的接口，自己的路由表，自己的ARP表等等相关的内容。我们的环境就变成有点像这样：
我们看到，VRF1及VRF2有了自己的接口，也有了自己的路由表。并且相互之间是隔离的。
现在PC1要发送一个数据包到2.2.2.2，R1从接口GE0/0/1收到了这个数据包，由于此时GE0/0/1已经绑定到了VRF1，因此在执行目的IP的路由查找的时候，查的是VRF1的路由表，查找到匹配的路由条目后，间个数据包从其指示的GE0/0/1口转发给下一跳192.168.100.2。
那么如果PC1要访问3.3.3.3呢？数据包发到了R1，R1从接口GE0/0/1收到了这个数据包，于是它在做路由查找的时候，查的仍然是VRF1的路由表。经过查表后，它发现并无匹配的条目，因此将数据包丢弃。
3. 不同环境的VRF创建 Linux Kernel中VRF的使用(iproute的namespace) 1
2
3
4
#创建命令空间
ip netns add vrf1
#命名空间中执行ifconfig
ip netns exec vrf1 ifconfig
Linux Kernel中轻量级VRF的使用(高版本iproute的vrf) 具体可参考文章https://turbock79.cn/?p=299
1
2
#创建vrf red
ip link add red type vrf table 1
VPP 中的VRF的使用 1
2
3
4
vpp # ip table add 100 //创建ip4 vrf 100
vpp # show ip fib //查看
vpp # ip6 table add 200 //创建IP6 vrf 200" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4c019bf3d6681dc00ae8cfee57ffff65/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-03T19:27:35+08:00" />
<meta property="article:modified_time" content="2020-12-03T19:27:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VRF</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>VRF简介及创建</h2> 
<h3>1.VRF理解</h3> 
<blockquote> 
 <p>VRF相当于一个个独立路由表，STATIC是路由表里的一个(条目)策略，添加vrf相当于隔离建立多个独立的路由器。</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/c1/56/5RDNWDPj_o.png"></p> 
<h3>2.VRF应用需求</h3> 
<p><img alt="" src="https://images2.imgbox.com/89/c5/senTyPjG_o.png"></p> 
<p>  假设PC1与R2这一侧的网络属于一个独立的业务；PC2与R3这一侧的网络属于另一个独立的业务，由于设备资源有限或者其他方面的原因，这两个独立的业务的相关节点连接在R1上，也就是同一台设备上。那么在完成相关配置后，R1的路由表如上图所示。<br>   现在如果PC1要发一个数据包到2.2.2.2，那么这个数据包在到达R1后，R1就会去查看自己的路由表，发现有一条2.2.2.0/24的路由匹配，因此将这个IP包从GE0/0/2口转发给192.168.100.2。这是没有问题的，然而如果PC1要访问3.3.3.0/24网络呢？也是无压力的，因为数据包到达R1后，她照样查找路由表结果发现有匹配的路由，因此将数据包转给R3。但是实际上，从业务的角度考虑，我们禁止PC1访问3.3.3.0/24网络。<br>   那么怎么办？<br><img alt="" src="https://images2.imgbox.com/7d/4b/okNYOWfs_o.png"><br><img alt="" src="https://images2.imgbox.com/b9/44/84Jtq8M9_o.png"><br>   现在，我们在R1上创建两个VRF：VRF1及VRF2，创建完成后，我们可以理解为，拥有了两台虚拟路由器。当然，现在这两台虚拟路由器上啥也没有。<br> 接下去我们将GE0/0/1口及GE0/0/2口绑定到VRF1；将GE0/0/3及GE0/0/4口绑定到VRF2。如此一来这两台虚拟路由器就各自拥有了两个物理接口。值得注意的是，这两台虚拟路由器是虽然都在同一台物理设备上，但是却是隔离的，他们将有自己的接口，自己的路由表，自己的ARP表等等相关的内容。我们的环境就变成有点像这样：<br><img alt="" src="https://images2.imgbox.com/b7/ff/Mn2Jczy5_o.png"><br>   我们看到，VRF1及VRF2有了自己的接口，也有了自己的路由表。并且相互之间是隔离的。<br> 现在PC1要发送一个数据包到2.2.2.2，R1从接口GE0/0/1收到了这个数据包，由于此时GE0/0/1已经绑定到了VRF1，因此在执行目的IP的路由查找的时候，查的是VRF1的路由表，查找到匹配的路由条目后，间个数据包从其指示的GE0/0/1口转发给下一跳192.168.100.2。</p> 
<p>  那么如果PC1要访问3.3.3.3呢？数据包发到了R1，R1从接口GE0/0/1收到了这个数据包，于是它在做路由查找的时候，查的仍然是VRF1的路由表。经过查表后，它发现并无匹配的条目，因此将数据包丢弃。<br><img alt="" src="https://images2.imgbox.com/e0/f7/Nv9AxXAU_o.png"></p> 
<h3>3. 不同环境的VRF创建</h3> 
<ul><li>Linux Kernel中VRF的使用(iproute的namespace)</li></ul> 
<p> </p> 
<p> </p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p>#创建命令空间</p> <p>ip netns add vrf1</p> <p>#命名空间中执行ifconfig</p> <p>ip netns exec vrf1 ifconfig</p> </td></tr></tbody></table> 
<p> </p> 
<ul><li>Linux Kernel中轻量级VRF的使用(高版本iproute的vrf)</li></ul> 
<p>具体可参考文章https://turbock79.cn/?p=299</p> 
<p> </p> 
<p> </p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p>#创建vrf red</p> <p>ip link add red type vrf table 1</p> </td></tr></tbody></table> 
<p> </p> 
<ul><li>VPP 中的VRF的使用</li></ul> 
<p> </p> 
<p> </p> 
<table><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p>vpp # ip table add 100  //创建ip4  vrf 100</p> <p>vpp # show ip fib   //查看</p> <p>vpp # ip6 table add 200 //创建IP6 vrf 200</p> <p>vpp # show ip6 fib  //查看</p> </td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af960ab5c25f105a7c1f4270ffb85bc9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[转载] java语言程序设计-基础篇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/531cd2ea858bc6b7ff7dcf70aba99b8b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">matlab的 switch case语句</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>