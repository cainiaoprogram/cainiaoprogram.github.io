<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅析JAVA集合框架之HashMap - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅析JAVA集合框架之HashMap" />
<meta property="og:description" content="文章目录 注：本文基于jdk1.8Capacity和Size的区别 数据结构什么是hash冲突什么是链表单向链表Node实体 什么是红黑树TreeNode实体 源码阅读继承与实现接口类的属性重要方法解析构造方法tableSizeFor() hash算法异或运算 ^逻辑右移 &gt;&gt;&gt;取模运算 %计算桶的位置 putgetresize 参考博客： 注： 本文基于jdk1.8 XiuQiang:~ XiuQiang$ java -version java version &#34;1.8.0_191&#34; Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) Capacity和Size的区别 Capacity:容量，哈希桶数组的长度，即table.length。
Size：哈希桶数组内节点的总数。
数据结构 HashMap底层的数据结构是数组&#43;链表&#43;红黑树（jdk1.7是数组&#43;链表）。
在下文中，我们将哈希桶数组里可以存储元素的位置称为桶（bucket）。同时，将桶中链表或者红黑树的节点称之为bin。（bin是依据是源码中的注释，不是我一拍脑袋随便想出来的哈）
图来自郑加威的博客：传送门
当桶中的结构为链表时，HashMap采用Node数组来存储key-value对，每一个键值对组成了一个Node实体，即bin。Node类具有Next指针，可以连接下一个Node实体，依此来解决hash冲突的问题。
什么是hash冲突 HashMap是按照Key的hash值来计算bin在HashMap中存储的位置的，即桶的位置。如果hash值相同，而key内容不相等，它们就会被放入同一个桶内。此时就要用链表来解决这种hash冲突。当桶内链表长度大于8时，链表会转化为红黑树，这种转换是有条件的，若桶的数量太少，则会直接进行扩容。欲知后事如何，请听下回分解，哈哈哈哈。
什么是链表 链表是由一系列非连续的节点组成的存储结构，简单分下类的话，链表又分为单向链表和双向链表，而单向/双向链表又可以分为循环链表和非循环链表。因为HashMap中的链表就是单向链表，下面简单就单向链表进行图解说明。其他几种链表感兴趣的同学可以自行查阅资料。
单向链表 单向链表就是通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null。
Node实体 /** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8fb62d2a418670911d5956658267bf1a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-06T00:43:47+08:00" />
<meta property="article:modified_time" content="2022-09-06T00:43:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅析JAVA集合框架之HashMap</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">注：</a></li><li><ul><li><a href="#jdk18_2" rel="nofollow">本文基于jdk1.8</a></li><li><a href="#CapacitySize_9" rel="nofollow">Capacity和Size的区别</a></li></ul> 
  </li><li><a href="#_12" rel="nofollow">数据结构</a></li><li><ul><li><a href="#hash_18" rel="nofollow">什么是hash冲突</a></li><li><a href="#_20" rel="nofollow">什么是链表</a></li><li><ul><li><a href="#_22" rel="nofollow">单向链表</a></li><li><a href="#Node_26" rel="nofollow">Node实体</a></li></ul> 
   </li><li><a href="#_76" rel="nofollow">什么是红黑树</a></li><li><ul><li><a href="#TreeNode_86" rel="nofollow">TreeNode实体</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_105" rel="nofollow">源码阅读</a></li><li><ul><li><a href="#_106" rel="nofollow">继承与实现接口</a></li><li><a href="#_113" rel="nofollow">类的属性</a></li><li><a href="#_136" rel="nofollow">重要方法解析</a></li><li><ul><li><a href="#_137" rel="nofollow">构造方法</a></li><li><ul><li><a href="#tableSizeFor_175" rel="nofollow">tableSizeFor()</a></li></ul> 
    </li><li><a href="#hash_189" rel="nofollow">hash算法</a></li><li><ul><li><a href="#__191" rel="nofollow">异或运算 ^</a></li><li><a href="#__199" rel="nofollow">逻辑右移 &gt;&gt;&gt;</a></li><li><a href="#__204" rel="nofollow">取模运算 %</a></li><li><a href="#_210" rel="nofollow">计算桶的位置</a></li></ul> 
    </li><li><a href="#put_276" rel="nofollow">put</a></li><li><a href="#get_342" rel="nofollow">get</a></li><li><a href="#resize_384" rel="nofollow">resize</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_481" rel="nofollow">参考博客：</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>注：</h2> 
<h3><a id="jdk18_2"></a>本文基于jdk1.8</h3> 
<pre><code>XiuQiang:~ XiuQiang$ java -version
java version "1.8.0_191"
Java(TM) SE Runtime Environment (build 1.8.0_191-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)
</code></pre> 
<h3><a id="CapacitySize_9"></a>Capacity和Size的区别</h3> 
<p>Capacity:容量，哈希桶数组的长度，即table.length。<br> Size：哈希桶数组内节点的总数。</p> 
<h2><a id="_12"></a>数据结构</h2> 
<p>  HashMap底层的数据结构是数组+链表+红黑树（jdk1.7是数组+链表）。<br>   在下文中，我们将哈希桶数组里可以存储元素的位置称为桶（bucket）。同时，将桶中链表或者红黑树的节点称之为bin。（bin是依据是源码中的注释，不是我一拍脑袋随便想出来的哈）<br> <img src="https://images2.imgbox.com/49/d8/Dfonvmet_o.png" alt="在这里插入图片描述"><br> 图来自郑加威的博客：<a href="https://my.oschina.net/90888/blog/1626045#h1_23" rel="nofollow">传送门</a><br>   当桶中的结构为链表时，HashMap采用Node数组来存储key-value对，每一个键值对组成了一个Node实体，即bin。Node类具有Next指针，可以连接下一个Node实体，依此来解决hash冲突的问题。</p> 
<h3><a id="hash_18"></a>什么是hash冲突</h3> 
<p>HashMap是按照Key的hash值来计算bin在HashMap中存储的位置的，即桶的位置。如果hash值相同，而key内容不相等，它们就会被放入同一个桶内。此时就要用链表来解决这种hash冲突。当桶内链表长度大于8时，链表会转化为红黑树，这种转换是有条件的，若桶的数量太少，则会直接进行扩容。欲知后事如何，请听下回分解，哈哈哈哈。</p> 
<h3><a id="_20"></a>什么是链表</h3> 
<p>  链表是由一系列非连续的节点组成的存储结构，简单分下类的话，链表又分为单向链表和双向链表，而单向/双向链表又可以分为循环链表和非循环链表。<strong>因为HashMap中的链表就是单向链表，下面简单就单向链表进行图解说明</strong>。其他几种链表感兴趣的同学可以自行查阅资料。</p> 
<h4><a id="_22"></a>单向链表</h4> 
<p>  单向链表就是通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null。<br> <img src="https://images2.imgbox.com/75/16/pnr6yrIg_o.png" alt="单向链表"></p> 
<h4><a id="Node_26"></a>Node实体</h4> 
<pre><code> /**
     * Basic hash bin node, used for most entries.  (See below for
     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
     */
    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next;

        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;&amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
</code></pre> 
<h3><a id="_76"></a>什么是红黑树</h3> 
<p> 红黑树是一种自平衡的二叉查找树，在原有的二叉查找树基础上增加了如下几个要求：</p> 
<ol><li>Every node is either red or black.（节点是红色或黑色）</li><li>The root is black.（根节点是黑色）</li><li>Every leaf (NIL) is black.（每个叶子节点都是黑色的空节点（NIL节点））</li><li>If a node is red, then both its children are black.（每个红色节点的两个子节点都是黑色）</li><li>For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.（从任意节点到其每个叶子的所有路径都包含相同树木的黑色节点）<br> <img src="https://images2.imgbox.com/72/7d/KBXfo0tj_o.jpg" alt="在这里插入图片描述"><br> 感兴趣的同学可以看下下面这篇文章，此处就不再赘述了。<br> <a href="https://mp.weixin.qq.com/s/jz1ajDUygZ7sXLQFHyfjWA" rel="nofollow">漫画算法：什么是红黑树？</a></li></ol> 
<h4><a id="TreeNode_86"></a>TreeNode实体</h4> 
<pre><code>    /**
     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn
     * extends Node) so can be used as extension of either regular or
     * linked node.
     */
    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
        TreeNode&lt;K,V&gt; parent;  // red-black tree links
        TreeNode&lt;K,V&gt; left;
        TreeNode&lt;K,V&gt; right;
        TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
        boolean red;
        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {
            super(hash, key, val, next);
        }
        //此处省略一万字...
</code></pre> 
<h2><a id="_105"></a>源码阅读</h2> 
<h3><a id="_106"></a>继承与实现接口</h3> 
<pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable
</code></pre> 
<p><img src="https://images2.imgbox.com/e7/ac/IgwV7FXK_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_113"></a>类的属性</h3> 
<pre><code>// 默认初始容量
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; 
//最大容量
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 
//默认负载因子0.75
static final float DEFAULT_LOAD_FACTOR = 0.75f; 
//当链表长度大于8时转化为红黑树
static final int TREEIFY_THRESHOLD = 8; 
//当红黑树的长度小于6时转为链表
static final int UNTREEIFY_THRESHOLD = 6; 
//当链表要被树化时，最少桶数，否则直接扩容resize()
static final int MIN_TREEIFY_CAPACITY = 64; 
// 第一次使用时，才进行初始化操作
transient Node&lt;K,V&gt;[] table;
//阈（yu）值，由负载因子和容量决定：CAPACITY * LOAD_FACTOR，默认为16*0.75=12
//当哈希桶数组内的节点数大于该值时，则扩容
int threshold;
</code></pre> 
<p>思考：<br> 如果确定只装载100个元素，new HashMap(?)多少是最佳的（加载因子默认0.75），为什么？</p> 
<h3><a id="_136"></a>重要方法解析</h3> 
<h4><a id="_137"></a>构造方法</h4> 
<pre><code>//无参构造
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}
//指定初始容量
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
//指定集合转化为Map
public HashMap(Map&lt;? extends K, ? extends V&gt; m) 
//指定初始容量和加载因子
public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);                                       
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        //
        this.threshold = tableSizeFor(initialCapacity);
}
//返回一个比给定值cap大且最接近的二次幂，比如cap=100，则返回128。
static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
</code></pre> 
<h5><a id="tableSizeFor_175"></a>tableSizeFor()</h5> 
<p>这里简单介绍下tableSizeFor()这个方法。这个算法非常巧妙，通过五次&gt;&gt;&gt;和|操作，将最高位的1后面的位数都变为1，最后返还n+1。比如:<br> cap=100 转化为二进制以后就是01100100(前面的0都省略了）<br> int n = cap - 1 = 01100011<br> n |= n &gt;&gt;&gt; 1;<br>     0110 0011<br> |   0011 0001<br>  _________<br>     0111  0011<br> 同理n |= n &gt;&gt;&gt; 2;n |= n &gt;&gt;&gt; 3;……<br> 最后可得 n = 01111111 = 127<br> n + 1 = 128 = <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          2 
         
        
          7 
         
        
       
      
        2^7 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></p> 
<hr> 
<p>通过上面几个构造方法可以发现，HashMap的构造方法中没有对table进行初始化操作。table的初始化操作是在putVal（）方法进行的。</p> 
<h4><a id="hash_189"></a>hash算法</h4> 
<p>  我们在前面介绍过hash冲突。好的hash算法可以使元素分布地更加均匀，从而减小hash冲突。在介绍hash算法之前，先跟大家一起复习下异或运算（^）逻辑右移(&gt;&gt;&gt;)和取模运算 。</p> 
<h5><a id="__191"></a>异或运算 ^</h5> 
<p>规则：不同为1<br> 举个栗子：<br> 3^4=7:<br>      0011<br>      0100<br> ^ ______<br>      0111</p> 
<h5><a id="__199"></a>逻辑右移 &gt;&gt;&gt;</h5> 
<p>规则：低位溢出，高位补0<br> 举个栗子：<br> 10 &gt;&gt;&gt; 1 = 5:<br> 1010 &gt;&gt;&gt; 1 = 0101</p> 
<h5><a id="__204"></a>取模运算 %</h5> 
<p>规则：取模运算就是我们小学的时候的求余数（这里只讨论都为正整数的情况）<br> 举个栗子：<br> 5%3=2<br> 5除以3等于1余2</p> 
<hr> 
<h5><a id="_210"></a>计算桶的位置</h5> 
<p>准备工作都做好了，现在来一起看下HashMap中是如何通过hash算法减小冲突，并确定桶的位置，冲鸭！</p> 
<pre><code>public native int hashCode();
//hash算法求得key的hash值
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }
//通过hash值和(tab.length-1)做取模运算来确定桶的位置
int n = tab.length;
int index = (n - 1) &amp; hash; 
</code></pre> 
<p>此处我们将该过程拆分为两步：</p> 
<ol><li>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</li><li>(n - 1) &amp; hash</li></ol> 
<p>  很多同学看到这里可能会有个疑问?️，为什么要将key的hashcode右移16位以后再于原hashcode做异或运算的结果再和数组的长度-1做与运算&amp;，而不是取模运算%。<br>   讲道理，在得到hash值和table.length后，直接通过hash%table.length就可以确定桶的位置，就像下面这样。</p> 
<pre><code>int length = table.length();
int hash = key.hashCode()；
int index = hash%length;
</code></pre> 
<p><strong>先说要什么要用&amp;来代替%操作</strong>:</p> 
<ol><li>计算机中 &amp; 的效率比 % 高很多。</li><li>HashMap中桶的数量必为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           2 
          
         
           n 
          
         
        
       
         2^n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6644em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>。（构造方法解析中可得）</li><li>当 lenth = <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           2 
          
         
           n 
          
         
        
       
         2^n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6644em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 时，X % length = X &amp; (length - 1) （这个结论有兴趣的同学可以自己推导下，此处就不再赘述了，别问我为什么，因为我也不会?）</li></ol> 
<p>根据这三个结论，我们很轻易就可以推导出为什么要用与来代替求模。<br> <strong>然后说为什么要右移 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</strong>:<br>   简单来说就是将hash值的高16位参与到求桶位置的运算中去。这样说可能不是很好理解，举个栗子,先不进行右移操作：<br> 假设int n = table.length=<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          2 
         
        
          4 
         
        
       
      
        2^4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> =16<br>             h:1111  1111  1111  1111  1111 0000 1110 1010<br>          n-1:0000 0000 0000 0000 0000 0000 0000 1111</p> 
<hr> 
<p>  h&amp;(n-1):0000 0000 0000 0000 0000 0000 0000 1010<br>              <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⇓ 
        
       
      
        \Downarrow 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mrel">⇓</span></span></span></span></span><br>             1010 = 10<br> 现在我们将h缩小到10,再进行一次运算：<br>             h:0000 0000 0000 0000 0000 0000 0000 1010<br>          n-1:0000 0000 0000 0000 0000 0000 0000 1111</p> 
<hr> 
<p>  h&amp;(n-1):0000 0000 0000 0000 0000 0000 0000 1010</p> 
<p>             <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⇓ 
        
       
      
        \Downarrow 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mrel">⇓</span></span></span></span></span><br>             1010 = 10</p> 
<p>哈哈哈哈，有没有发现！只要是低四位相同的hash值，最后算出来的桶都是10。<br> 现在我们加上右移操作：<br> int hash = h ^ (h &gt;&gt;&gt; 16);<br>                    h:1111  1111  1111  1111  1111 0000 1110 1010<br>        h &gt;&gt;&gt; 16:0000 0000 0000 0000  1111 1111  1111 1111</p> 
<hr> 
<p>              hash:1111 1111  1111  1111  0000 1111  0001 0101<br>                  n-1:0000 0000 0000 0000 0000 0000 0000 1111</p> 
<hr> 
<p>  hash &amp; (n-1):0000 0000 0000 0000 0000 0000 0000 0101<br>              <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⇓ 
        
       
      
        \Downarrow 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mrel">⇓</span></span></span></span></span><br>             0101 = 5</p> 
<p>   综上，当数组的长度比较小时，也能使高16位参与到hash值的计算中，同时不会有太大的开销。</p> 
<h4><a id="put_276"></a>put</h4> 
<p><img src="https://images2.imgbox.com/48/0c/IGcDYvX0_o.png" alt="在这里插入图片描述"><br> 图来自夜香的博客：<a href="https://www.cnblogs.com/zhangchunxi/p/7785546.html" rel="nofollow">传送门</a></p> 
<pre><code>public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        //进行hash表的初始化操作
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //i = (n - 1) &amp; hash 计算桶的位置
        //将该桶内的头节点赋值给p
        if ((p = tab[i = (n - 1) &amp; hash]) == null) 
            //桶内还没有节点，新增一个
            tab[i] = newNode(hash, key, value, null);
        else {
            //桶中已经有节点了
            Node&lt;K,V&gt; e; K k;
            //判断p的key和hash值是否和传参中的key值和hash值相同
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                //若相同，把p赋给e
                e = p;
            //判断p节点是否是红黑树节点
            else if (p instanceof TreeNode)
                //Tree version of putVal
                //调用树版本的putVal
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {//桶内是链表
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        //新增一个节点插入链表尾部
                        p.next = newNode(hash, key, value, null);
                        //判断节点数量
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            //桶内节点数量大于8个，将链表转化为红黑树
                            treeifyBin(tab, hash);
                        break;
                    }
                    //e节点的hash值和key值与传参中的相等, 则e即为目标节点,跳出循环
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
            //替换e的Value，并返回旧value
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        //扩容
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
}
</code></pre> 
<h4><a id="get_342"></a>get</h4> 
<p>思路与put方法大致相同。</p> 
<pre><code>public V get(Object key) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

    /**
     * Implements Map.get and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @return the node, or null if none
     */
    final Node&lt;K,V&gt; getNode(int hash, Object key) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
        //判断哈希桶数组内是否有值
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (first = tab[(n - 1) &amp; hash]) != null) {
            //判断桶内头节点是否是要查找的节点
            if (first.hash == hash &amp;&amp;                 // always check first node
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                //若是，则直接返回头节点
                return first;
            if ((e = first.next) != null) {
                //判断桶内结构是否是红黑树
                if (first instanceof TreeNode)
                	//若是红黑树，则调用红黑树的方法
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
                do {
                    //遍历链表，查找目标节点
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        //找不到节点，返回null
        return null;
    }
</code></pre> 
<h4><a id="resize_384"></a>resize</h4> 
<p><img src="https://images2.imgbox.com/cf/37/8QbAZJCv_o.png" alt="在这里插入图片描述"><br> 图来自夜香的博客：<a href="https://www.cnblogs.com/zhangchunxi/p/7785546.html" rel="nofollow">传送门</a></p> 
<pre><code>    /**
     * Initializes or doubles table size.  If null, allocates in
     * accord with initial capacity target held in field threshold.
     * Otherwise, because we are using power-of-two expansion, the
     * elements from each bin must either stay at same index, or move
     * with a power of two offset in the new table.
     *
     * @return the table
     */
final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) {
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            // oldCap &lt;&lt; 1 左移一位,相当于oldCap * 2
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                //当前表容量&gt;=默认容量并且乘以2以后还是小于最大容量
                //将新阈值设置为当前阈值的两倍
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            //阈值是在两个参数的构造方法里设置的this.threshold = tableSizeFor(initialCapacity);
            //将新表的容量设为当前表的阈值
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            //当前表的容量和阈值都为空，新表使用默认值
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        //敲黑板！前方高能！！
        //定义新表，resize就是把节点从当前表搬到新表的过程
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                	 //释放引用以便垃圾回收
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
</code></pre> 
<h2><a id="_481"></a>参考博客：</h2> 
<p>夜香：https://www.cnblogs.com/zhangchunxi/p/7785546.html<br> 郑加威：https://my.oschina.net/90888/blog/1626045</p> 
<p>未完待续…</p> 
<blockquote> 
 <p>作者：秀强<br> 出处：https://blog.csdn.net/AlphaBr<br> 版权所有，欢迎保留原文链接进行转载：)</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6cd6ef46508d2bb25780057bcab0204f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Anaconda安装及配置（详细版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/56e1dcb9f3dc0259826446a06ebd5d52/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Qt自定义信号数据类型实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>