<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>精品教程，用Pandas解析json格式的数据，建议收藏 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="精品教程，用Pandas解析json格式的数据，建议收藏" />
<meta property="og:description" content="在实际工作中，尤其是网页端数据的传输，我们经常会遇到json数据，看上去和Python当中的字典类型的数据很像，本文呢小编就通过pandas当中的内置方法json_normalize()来处理json格式的数据，最终生成DataFrame数据集方便我们进行后续的操作。本文主要想通过json_normalize()这个方法解析复杂格式的json形式的数据
在开始之前，我们先导入相应的依赖库，
import pandas as pd 01
解析基本的json格式的数据
我们先来看一个简单的例子
a_dict = { &#39;学校&#39;: &#39;北京大学&#39;, &#39;地理位置&#39;: &#39;北京&#39;, &#39;排名&#39;: 2 } 代码如下
pd.json_normalize(a_dict) 输出的结果如下
下面我们来看一个稍微有点复杂的例子，在列表中带有多个json格式的数据
json_list = [ {&#39;学校&#39;: &#39;清华大学&#39;, &#39;地理位置&#39;: &#39;北京&#39;, &#39;排名&#39;: 1}, {&#39;学校&#39;: &#39;北京大学&#39;, &#39;地理位置&#39;: &#39;北京&#39;, &#39;排名&#39;: 2}, ] pd.json_normalize(json_list) 输出的结果为
02
解析带有多层数据的json数据
下面我们来看一个带有多层json格式数据的对象，在“联系方式”这一层中还有“邮件”和“电话号码”，在“信息”这一层中有“学生”和“联系方式”两层，层层相套
json_obj = { &#39;学校&#39;: &#39;清华大学&#39;, &#39;地理位置&#39;: &#39;北京&#39;, &#39;排名&#39;: 1, &#39;信息&#39;: { &#39;学生&#39;: &#39;张三&#39;, &#39;联系方式&#39;: { &#39;邮件&#39;: { &#39;qq邮箱&#39;: &#39;zhangsan@qq.com&#39;, &#39;163邮箱&#39;: &#39;zhangsan@.com&#39; }, &#39;电话号码&#39;: &#39;123456789&#39;, } } } 我们尝试用json_normalize()方法来解析一下" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5cac54e4912795dd5bc9807b993a48a6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-30T21:45:46+08:00" />
<meta property="article:modified_time" content="2021-08-30T21:45:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">精品教程，用Pandas解析json格式的数据，建议收藏</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:justify;">在实际工作中，尤其是网页端数据的传输，我们经常会遇到json数据，看上去和Python当中的字典类型的数据很像，本文呢小编就通过pandas当中的内置方法json_normalize()来处理json格式的数据，最终生成DataFrame数据集方便我们进行后续的操作。本文主要想通过json_normalize()这个方法解析复杂格式的json形式的数据</p> 
 <p>在开始之前，我们先导入相应的依赖库，</p> 
 <pre class="has"><code class="language-swift">import pandas as pd</code></pre> 
 <p>0<span title="">1</span></p> 
 <p>解析基本的json格式的数据</p> 
 <p>我们先来看一个简单的例子</p> 
 <pre class="has"><code class="language-javascript">a_dict = {
    '学校': '北京大学',
    '地理位置': '北京',
    '排名': 2
}</code></pre> 
 <p>代码如下</p> 
 <pre class="has"><code class="language-css">pd.json_normalize(a_dict)</code></pre> 
 <p>输出的结果如下</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/6c/c5/WRo43xNB_o.png" alt="4bfb2ec0c9cee3d02f37115463ce0bbc.png"></p> 
 <p>下面我们来看一个稍微有点复杂的例子，在列表中带有多个json格式的数据</p> 
 <pre class="has"><code class="language-javascript">json_list = [
    {'学校': '清华大学', '地理位置': '北京', '排名': 1},
    {'学校': '北京大学', '地理位置': '北京', '排名': 2},
]
pd.json_normalize(json_list)</code></pre> 
 <p>输出的结果为</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/ef/e1/PxA18y7c_o.png" alt="c68db7eff0037c58680cfd189b097a78.png"></p> 
 <p>0<span title="">2</span></p> 
 <p>解析带有多层数据的json数据</p> 
 <p>下面我们来看一个带有多层json格式数据的对象，在<strong>“联系方式”</strong>这一层中还有<strong>“邮件”</strong>和<strong>“电话号码”</strong>，在<strong>“信息”</strong>这一层中有<strong>“学生”</strong>和<strong>“联系方式”</strong>两层，层层相套<br></p> 
 <pre class="has"><code class="language-javascript">json_obj = {
    '学校': '清华大学',
    '地理位置': '北京',
    '排名': 1,
    '信息': {
        '学生': '张三',
        '联系方式': {
            '邮件': {
                'qq邮箱': 'zhangsan@qq.com',
                '163邮箱': 'zhangsan@.com'
            },
            '电话号码': '123456789',
        }
    }
}</code></pre> 
 <p>我们尝试用json_normalize()方法来解析一下<br></p> 
 <pre class="has"><code class="language-css">pd.json_normalize(json_obj)</code></pre> 
 <p>输出的结果如下</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/a2/41/IRvLAtrk_o.png" alt="15e72630b158c989c672a7c94a93c308.png"></p> 
 <p>上面的数据是有3层的嵌套，也可以通过用pd.json_normalize(json_obj, max_level=3)来解析3层嵌套的数据，这边就要提到函数中<strong>max_level参数</strong>，<strong>max_level参数代表着解析json对象的最大层级数</strong>，适用于有多层嵌套的json对象。要是我们将max_level设置为1，则输出的结果，邮件中的联系方式是没有被拆开来的</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/81/d0/qI0ok21Z_o.png" alt="6036fdbe7ea9dd787c101a1b275818b4.png"></p> 
 <p>要是我们将max_level设置为2，则输出的结果，联系方式中的邮件内容是没有被拆开来的</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/8c/4b/Y90KQcel_o.png" alt="5291d2da54d6f2b34aa2edb8d83b1436.png"></p> 
 <p>下面我们来解析一个列表中带有多个json格式，并且一个json格式的数据下还带有多层嵌套的数据，</p> 
 <pre class="has"><code class="language-javascript">json_list = [
    {
        '姓名': '张三',
        '学号': 1,
        '年龄': 18,
        '联系方式': {
            '邮箱': {
                'QQ邮箱': 'zhangsan@qq.com',
                '163邮箱': 'zhangsan@163.com'
            }
        }
    },
    {
        '姓名': '李四',
        '学号': 2,
        '年龄': 20,
        '联系方式': {
            '邮箱': {
                'QQ邮箱': 'lisi@qq.com',
                '163邮箱': 'lisi@163.com'
            }
        }
    }
]


pd.json_normalize(json_list)</code></pre> 
 <p>输出的结果为</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/1f/31/tWSBfH2h_o.png" alt="2f074987d8bfd7c5d983eae8847df8ac.png"></p> 
 <p>读者朋友要是有空可以自己另外将max_level设置为2和3，看看输出的结果有什么不同</p> 
 <p>0<span title="">3</span></p> 
 <p>解析带有嵌套列表的json格式数据</p> 
 <p>我们先来解析一个带有多层嵌套列表的json格式的数据</p> 
 <pre class="has"><code class="language-javascript">json_obj = {
    '学校': '清华大学',
    '地理位置': '北京',
    '排名': 1,
    '信息': {
        '学生': '张三',
        '联系方式': {
            '邮件': {
                'qq邮箱': 'zhangsan@qq.com',
                '163邮箱': 'zhangsan@.com'
            },
            '电话号码': '123456789',
        }
    },
    '老师': [
        {"名字": "王五"}, 
        {"名字": "王六"},
        {"名字": "王七"}
    ]
    
}</code></pre> 
 <p>代码如下</p> 
 <pre class="has"><code class="language-css">pd.json_normalize(json_obj)</code></pre> 
 <p>输出的结果如下</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/0c/22/wXBbyZIV_o.png" alt="004d2750ed2872c546921dd0e4d6624d.png"></p> 
 <p>可以从输出的结果中看到，“老师”这一列中的值并没有被拆开来，是用一个[]括起来的列表，这里我们就可以使用参数“<strong>record_path</strong>”，<strong>其功能是将json对象中的嵌套列表单独展示出来</strong>，</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/50/d3/2OSitQTK_o.png" alt="44014e33407a9bd55b82081816e1acf9.png"></p> 
 <p>我们还可以通过“meta”为该结果添加其他的内容，</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/9b/24/jSFZZyyg_o.png" alt="b1c2a8abfc8ee9a3a6c6f4b4d329a66f.png"></p> 
 <p>0<span title="">4</span></p> 
 <p>为嵌套层级的json格式数据添加分隔符</p> 
 <p>对于存在嵌套层级的json格式的数据，在添加了<strong>分隔符</strong>之后将会更加容易阅读，例如类似下面的数据，我们加了分隔符之后</p> 
 <pre class="has"><code class="language-javascript">json_obj = {
    '学校': '清华大学',
    '地理位置': '北京',
    '排名': 1,
    '信息': {
        '学生': '张三',
        '联系方式': {
            '邮件': {
                'qq邮箱': 'zhangsan@qq.com',
                '163邮箱': 'zhangsan@.com'
            },
            '电话号码': '123456789',
        }
    }
}


df = pd.json_normalize(json_obj, sep = "--&gt;")</code></pre> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/43/9b/NoZwfa67_o.png" alt="901a34f09761c49bd95f76019796312d.png"></p> 
 <p>总体上说结果更加容易阅读与理解，尤其是理解该列在json格式的数据集中处于哪个位置</p> 
 <p>0<span title="">5</span></p> 
 <p>为json格式的数据添加前缀</p> 
 <p>添加<strong>前缀</strong>能够更加直观的展示出来数据是数据哪个层级范围的，我们通过<strong>record_prefix</strong>和<strong>meta_prefix</strong>这两个参数分别来赋值，为输出结果添加相应的前缀</p> 
 <pre class="has"><code class="language-javascript">json_obj = {
    '学校': '清华大学',
    '地理位置': '北京',
    '排名': 1,
    '信息': {
        '学生': '张三',
        '联系方式': {
            '邮件': {
                'qq邮箱': 'zhangsan@qq.com',
                '163邮箱': 'zhangsan@.com'
            },
            '电话号码': '123456789',
        }
    },
    '老师': [
        {"名字": "王五"}, 
        {"名字": "王六"},
        {"名字": "王七"}
    ]
}</code></pre> 
 <pre class="has"><code class="language-javascript">pd.json_normalize(json_obj, record_path='老师',
                  meta=['学校', '地理位置', '排名'],
                  record_prefix='老师--&gt;',
                  meta_prefix = '第一层级--&gt;')</code></pre> 
 <p>输出的结果如下</p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/0d/28/T8tLSVJx_o.png" alt="2b9347395e0a3e7ca8e227ba7764646c.png"></p> 
 <p>我们可以直观的看出“名字”这一列的上级目录是“老师”，而“学校”、“地理位置”等是处于第一层级，因为也没有上级目录</p> 
 <p>0<span title="">6</span></p> 
 <p>to_json()函数保存成json文件</p> 
 <p>to_json()方法顾名思义就是将DataFrame数据集保存成json格式的文件，加上force_ascii=False的选项之后，保存好的文件内容会以<strong>中文的格式</strong>显示出来</p> 
 <pre class="has"><code class="language-php">df.to_json("学生信息.json", force_ascii=False)</code></pre> 
 <p>0<span title="">7</span></p> 
 <p>读取本地的json文件</p> 
 <p>在将数据存到本地之后，我们要是想读取本地以".json"结尾的文件，我们可以先通过json模块将数据导入，然后再用json_normalize()方法整理成DataFrame的格式</p> 
 <pre class="has"><code class="language-swift">import json
with open("example.json", "r") as f:
    data =  json.loads(f.read())
    
 pd.json_normalize(data)</code></pre> 
 <p>哦，对了，之后的文章，文末添加了<strong>留言</strong>的功能，要是觉得该篇文章有哪里写的不好，有哪里值得改进的地方，小编也是鼓励读者朋友们可以积极的提出来（写的不好的也希望大家<strong>轻喷</strong>，毕竟小编也是一个菜鸟），大家一起交流、一起进步</p> 
 <p>历史文章</p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=Mzk0NzI3ODMyMA==&amp;mid=2247489165&amp;idx=1&amp;sn=629634d557a1b566d26ed92e6d18490a&amp;chksm=c3780e12f40f87047d8e683eb9ca5ea75832e5ef4a41a7ec5b8cd159746c47fe85f2b2ae7860&amp;scene=21#wechat_redirect" rel="nofollow">流量至上的时代背景 明星赚个盆满钵满，来看看网友们的态度</a><br></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=Mzk0NzI3ODMyMA==&amp;mid=2247489161&amp;idx=1&amp;sn=db0f09569dceacf8477ce1cce73e7757&amp;chksm=c3780e16f40f870007ad25cfe172f201407b6a6ea0802b6f657bfc12e6ea2b7d60f0138d8732&amp;scene=21#wechat_redirect" rel="nofollow">分享14条非常实用的Pandas函数方法，建议珍藏！！</a><br></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=Mzk0NzI3ODMyMA==&amp;mid=2247489159&amp;idx=1&amp;sn=c694f509519e9457a8b580c20025df2b&amp;chksm=c3780e18f40f870e9ce61fe041b47a67d9a62efa23e57b8a35e9fa2ef1230e10db2d9dd5e9f7&amp;scene=21#wechat_redirect" rel="nofollow">可视化图表告诉你，这部让网友直呼过瘾的国产剧究竟火在哪里</a><br></p> 
 <p><a href="https://blog.csdn.net/weixin_43373042/article/details/119814303">世界500强最新一轮排名出炉，最赚钱的行业竟然是它！？</a><br></p> 
 <p>分享、收藏、点赞、在看安排一下？</p> 
 <p><img src="https://images2.imgbox.com/5c/f1/qA13yl4a_o.gif" alt="06be45be618f7798a80b5974148c3bc5.gif"></p> 
 <p><img src="https://images2.imgbox.com/bf/5f/htEgnZfb_o.gif" alt="9436ebfe065a5e5adae2970941f6cfe6.gif"></p> 
 <p><img src="https://images2.imgbox.com/4a/3b/eKcRGDqK_o.gif" alt="46ecb277ae235f658f455a9d34ee428f.gif"></p> 
 <p><img src="https://images2.imgbox.com/ee/bc/3FEArquc_o.gif" alt="21d32cd21b05b5d3f663dcc6cda850d6.gif"></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad0c6fcee9de86b24b2751280574e8d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">node-red查询oracle</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b8c90464363a017d1049909ba66f2a2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Unity里如何停掉Coroutine, Invoke的函数的执行，以及脚本的Start()和Update()</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>