<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java面试题复习(1） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java面试题复习(1）" />
<meta property="og:description" content="目录
1.mysql使用innodb引擎，请简述mysql索引的最左前缀，如何优化order by语句
2.在JVM内存模型中，为什么要区分新生去和老年代，对于新生代为什么要区分eden区和survial区？
3.常见的远程调用有几种
4.对于外部衔接的方法需要注意那些问题？
5.关于@Transactional注解范围理解
6.SpringBoot如何管理版本依赖?什么是自动配置，起步依赖？
7.数据库索引原理
8.Integer和int的区别
9.数据库的三大范式
10.什么是Spring的依赖注入？有那些方法进行依赖注入
11.理解JVM
12.浅谈ReentrantLock的设计
13.说一下mysql中事务的实现原理
14.编写一个基于线程安全的懒加载单例模式
15.值传递和引用传递问题
16.异常中的return问题
17.Spring的AOP的时评场景有那些
18.列举Linux的常用命令
19.列举知道并使用过其他前沿技术
20.JVM运行时数据区域包含那几个部分
21.多线程中的start()方法和run()方法的区别时什么
22.简单写一个会导致死锁的程序
23.对于高并发问题的处理方式
24.高可用问题的常用处理方式
26.数据连接池的工作机制是什么
27.那一个List实现最快插入
28.存在i&#43;1的数么&lt;&gt;
33.null问题
34.共享变量多线程可见性问题
35.synchronize锁对象竞争问题
36.高级回答方式 多线程有几种实现方式
37.高级同步有几种实现方式
38.Thread类的常用方法
39.Exception父类问题
40.String值对比问题
43.gc守护线程和volatile问题
1.mysql使用innodb引擎，请简述mysql索引的最左前缀，如何优化order by语句 解:
理解：索引建立和查询是在内存当中，当索引不存在则会在磁盘进行io，如果更新一个字段，会在所有的有关索引进行更新，浪费时间
关键字：
1.如果排序字段不在索引列上会有firesort两种算法，单路排序和双路排序
(单路排序：快速排序，是一种分支思想的排序算法。双路排序：快排优化。单路排序会比双路排序快一点)
2.无过滤不索引（where。limit属于限制条件不是锅炉条件）
3.order by 最左firesort（最好完全匹配，比如3个字段，没有使用第一个字段，后面两个字段使用了，虽然也可以走索引，但是从explain中的extra中会查看也会使用Using firesort。可以去掉后面，不能去掉中间和前面的）
4.顺序错了（where,group by）
5.方向反了firesort（在order by中统一顺序排序,顺序变化会导致firesort）
6.熟练使用explain,必要使用使用optimizer_trance
答案：
1.首先要对sql进行分析检查，过滤字段、排序字段是否按照顺序创建索引
2.如果查询字段不在索引中会导致回表，降低性能
3.一定要有多虑字段
4.多个字段排序字段方向不一致也会导致firesort,降低性能
5.排序字段和索引顺序不一致也会导致firesort，降低性能
6.使用explain关键字段和索引情况
7.尽可能减少没必要的firesort
2.在JVM内存模型中，为什么要区分新生去和老年代，对于新生代为什么要区分eden区和survial区？ 关键点：
1.分清jvm标准与实现
2.分清收集算法在g1是逻辑上的划分之前的垃圾回收器可以理解是在物理上
3.标记算法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b38d3b24c2bf3a4905c48366b7595e55/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-06T17:26:57+08:00" />
<meta property="article:modified_time" content="2023-05-06T17:26:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java面试题复习(1）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.mysql%E4%BD%BF%E7%94%A8innodb%E5%BC%95%E6%93%8E%EF%BC%8C%E8%AF%B7%E7%AE%80%E8%BF%B0mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96order%20by%E8%AF%AD%E5%8F%A5-toc" style="margin-left:0px;"><a href="#1.mysql%E4%BD%BF%E7%94%A8innodb%E5%BC%95%E6%93%8E%EF%BC%8C%E8%AF%B7%E7%AE%80%E8%BF%B0mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96order%20by%E8%AF%AD%E5%8F%A5" rel="nofollow">1.mysql使用innodb引擎，请简述mysql索引的最左前缀，如何优化order by语句</a></p> 
<p id="2.%E5%9C%A8JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86%E6%96%B0%E7%94%9F%E5%8E%BB%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86eden%E5%8C%BA%E5%92%8Csurvial%E5%8C%BA%EF%BC%9F-toc" style="margin-left:0px;"><a href="#2.%E5%9C%A8JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86%E6%96%B0%E7%94%9F%E5%8E%BB%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86eden%E5%8C%BA%E5%92%8Csurvial%E5%8C%BA%EF%BC%9F" rel="nofollow">2.在JVM内存模型中，为什么要区分新生去和老年代，对于新生代为什么要区分eden区和survial区？</a></p> 
<p id="3.%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%89%E5%87%A0%E7%A7%8D-toc" style="margin-left:0px;"><a href="#3.%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%89%E5%87%A0%E7%A7%8D" rel="nofollow">3.常见的远程调用有几种</a></p> 
<p id="4.%E5%AF%B9%E4%BA%8E%E5%A4%96%E9%83%A8%E8%A1%94%E6%8E%A5%E7%9A%84%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E9%82%A3%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F-toc" style="margin-left:0px;"><a href="#4.%E5%AF%B9%E4%BA%8E%E5%A4%96%E9%83%A8%E8%A1%94%E6%8E%A5%E7%9A%84%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E9%82%A3%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F" rel="nofollow">4.对于外部衔接的方法需要注意那些问题？</a></p> 
<p id="5.%E5%85%B3%E4%BA%8E%40Transactional%E6%B3%A8%E8%A7%A3%E8%8C%83%E5%9B%B4%E7%90%86%E8%A7%A3-toc" style="margin-left:0px;"><a href="#5.%E5%85%B3%E4%BA%8E%40Transactional%E6%B3%A8%E8%A7%A3%E8%8C%83%E5%9B%B4%E7%90%86%E8%A7%A3" rel="nofollow">5.关于@Transactional注解范围理解</a></p> 
<p id="6.SpringBoot%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%89%88%E6%9C%AC%E4%BE%9D%E8%B5%96%3F%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96%EF%BC%9F-toc" style="margin-left:0px;"><a href="#6.SpringBoot%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%89%88%E6%9C%AC%E4%BE%9D%E8%B5%96%3F%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96%EF%BC%9F" rel="nofollow">6.SpringBoot如何管理版本依赖?什么是自动配置，起步依赖？</a></p> 
<p id="7.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#7.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86" rel="nofollow">7.数据库索引原理</a></p> 
<p id="8.Integer%E5%92%8Cint%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#8.Integer%E5%92%8Cint%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">8.Integer和int的区别</a></p> 
<p id="9.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F-toc" style="margin-left:0px;"><a href="#9.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F" rel="nofollow">9.数据库的三大范式</a></p> 
<p id="10.%E4%BB%80%E4%B9%88%E6%98%AFSpring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F%E6%9C%89%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-toc" style="margin-left:0px;"><a href="#10.%E4%BB%80%E4%B9%88%E6%98%AFSpring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F%E6%9C%89%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" rel="nofollow">10.什么是Spring的依赖注入？有那些方法进行依赖注入</a></p> 
<p id="11.%E7%90%86%E8%A7%A3JVM-toc" style="margin-left:0px;"><a href="#11.%E7%90%86%E8%A7%A3JVM" rel="nofollow">11.理解JVM</a></p> 
<p id="12.%E6%B5%85%E8%B0%88ReentrantLock%E7%9A%84%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#12.%E6%B5%85%E8%B0%88ReentrantLock%E7%9A%84%E8%AE%BE%E8%AE%A1" rel="nofollow">12.浅谈ReentrantLock的设计</a></p> 
<p id="13.%E8%AF%B4%E4%B8%80%E4%B8%8Bmysql%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#13.%E8%AF%B4%E4%B8%80%E4%B8%8Bmysql%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow">13.说一下mysql中事务的实现原理</a></p> 
<p id="14.%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-toc" style="margin-left:0px;"><a href="#14.%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" rel="nofollow">14.编写一个基于线程安全的懒加载单例模式</a></p> 
<p id="15.%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#15.%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98" rel="nofollow">15.值传递和引用传递问题</a></p> 
<p id="16.%E5%BC%82%E5%B8%B8%E4%B8%AD%E7%9A%84return%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#16.%E5%BC%82%E5%B8%B8%E4%B8%AD%E7%9A%84return%E9%97%AE%E9%A2%98" rel="nofollow">16.异常中的return问题</a></p> 
<p id="17.Spring%E7%9A%84AOP%E7%9A%84%E6%97%B6%E8%AF%84%E5%9C%BA%E6%99%AF%E6%9C%89%E9%82%A3%E4%BA%9B-toc" style="margin-left:0px;"><a href="#17.Spring%E7%9A%84AOP%E7%9A%84%E6%97%B6%E8%AF%84%E5%9C%BA%E6%99%AF%E6%9C%89%E9%82%A3%E4%BA%9B" rel="nofollow">17.Spring的AOP的时评场景有那些</a></p> 
<p id="18.%E5%88%97%E4%B8%BELinux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-toc" style="margin-left:0px;"><a href="#18.%E5%88%97%E4%B8%BELinux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" rel="nofollow">18.列举Linux的常用命令</a></p> 
<p id="19.%E5%88%97%E4%B8%BE%E7%9F%A5%E9%81%93%E5%B9%B6%E4%BD%BF%E7%94%A8%E8%BF%87%E5%85%B6%E4%BB%96%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF-toc" style="margin-left:0px;"><a href="#19.%E5%88%97%E4%B8%BE%E7%9F%A5%E9%81%93%E5%B9%B6%E4%BD%BF%E7%94%A8%E8%BF%87%E5%85%B6%E4%BB%96%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF" rel="nofollow">19.列举知道并使用过其他前沿技术</a></p> 
<p id="20.JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%8C%85%E5%90%AB%E9%82%A3%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86-toc" style="margin-left:0px;"><a href="#20.JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%8C%85%E5%90%AB%E9%82%A3%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86" rel="nofollow">20.JVM运行时数据区域包含那几个部分</a></p> 
<p id="21.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84start()%E6%96%B9%E6%B3%95%E5%92%8Crun()%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%97%B6%E4%BB%80%E4%B9%88-toc" style="margin-left:0px;"><a href="#21.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84start%28%29%E6%96%B9%E6%B3%95%E5%92%8Crun%28%29%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%97%B6%E4%BB%80%E4%B9%88" rel="nofollow">21.多线程中的start()方法和run()方法的区别时什么</a></p> 
<p id="22.%E7%AE%80%E5%8D%95%E5%86%99%E4%B8%80%E4%B8%AA%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E7%9A%84%E7%A8%8B%E5%BA%8F-toc" style="margin-left:0px;"><a href="#22.%E7%AE%80%E5%8D%95%E5%86%99%E4%B8%80%E4%B8%AA%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E7%9A%84%E7%A8%8B%E5%BA%8F" rel="nofollow">22.简单写一个会导致死锁的程序</a></p> 
<p id="23.%E5%AF%B9%E4%BA%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#23.%E5%AF%B9%E4%BA%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F" rel="nofollow">23.对于高并发问题的处理方式</a></p> 
<p id="24.%E9%AB%98%E5%8F%AF%E7%94%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%B8%B8%E7%94%A8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#24.%E9%AB%98%E5%8F%AF%E7%94%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%B8%B8%E7%94%A8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F" rel="nofollow">24.高可用问题的常用处理方式</a></p> 
<p id="26.%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:0px;"><a href="#26.%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">26.数据连接池的工作机制是什么</a></p> 
<p id="27.%E9%82%A3%E4%B8%80%E4%B8%AAList%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%BF%AB%E6%8F%92%E5%85%A5-toc" style="margin-left:0px;"><a href="#27.%E9%82%A3%E4%B8%80%E4%B8%AAList%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%BF%AB%E6%8F%92%E5%85%A5" rel="nofollow">27.那一个List实现最快插入</a></p> 
<p id="28.%E5%AD%98%E5%9C%A8i%2B1%3Ci%E7%9A%84%E6%95%B0%E4%B9%88-toc" style="margin-left:0px;"><a href="#28.%E5%AD%98%E5%9C%A8i%2B1%3Ci%E7%9A%84%E6%95%B0%E4%B9%88" rel="nofollow">28.存在i+1<i></i>的数么&lt;&gt;</a></p> 
<p id="33.null%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#33.null%E9%97%AE%E9%A2%98" rel="nofollow">33.null问题</a></p> 
<p id="34.%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#34.%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98" rel="nofollow">34.共享变量多线程可见性问题</a></p> 
<p id="35.synchronize%E9%94%81%E5%AF%B9%E8%B1%A1%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#35.synchronize%E9%94%81%E5%AF%B9%E8%B1%A1%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98" rel="nofollow">35.synchronize锁对象竞争问题</a></p> 
<p id="36.%E9%AB%98%E7%BA%A7%E5%9B%9E%E7%AD%94%E6%96%B9%E5%BC%8F%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#36.%E9%AB%98%E7%BA%A7%E5%9B%9E%E7%AD%94%E6%96%B9%E5%BC%8F%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" rel="nofollow">36.高级回答方式 多线程有几种实现方式</a></p> 
<p id="37.%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#37.%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" rel="nofollow">37.高级同步有几种实现方式</a></p> 
<p id="38.Thread%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#38.Thread%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">38.Thread类的常用方法</a></p> 
<p id="39.Exception%E7%88%B6%E7%B1%BB%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#39.Exception%E7%88%B6%E7%B1%BB%E9%97%AE%E9%A2%98" rel="nofollow">39.Exception父类问题</a></p> 
<p id="40.String%E5%80%BC%E5%AF%B9%E6%AF%94%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#40.String%E5%80%BC%E5%AF%B9%E6%AF%94%E9%97%AE%E9%A2%98" rel="nofollow">40.String值对比问题</a></p> 
<p id="43.gc%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8Cvolatile%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#43.gc%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8Cvolatile%E9%97%AE%E9%A2%98" rel="nofollow">43.gc守护线程和volatile问题</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.mysql%E4%BD%BF%E7%94%A8innodb%E5%BC%95%E6%93%8E%EF%BC%8C%E8%AF%B7%E7%AE%80%E8%BF%B0mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96order%20by%E8%AF%AD%E5%8F%A5"><strong>1.mysql使用innodb引擎，请简述mysql索引的最左前缀，如何优化order by语句</strong></h2> 
<p>解:</p> 
<p><span style="color:#956fe7;">理解：</span>索引建立和查询是在内存当中，当索引不存在则会在磁盘进行io，如果更新一个字段，会在所有的有关索引进行更新，浪费时间</p> 
<p><span style="color:#956fe7;">关键字：</span></p> 
<p>1.如果排序字段不在索引列上会有firesort两种算法，单路排序和双路排序</p> 
<p>(单路排序：快速排序，是一种分支思想的排序算法。双路排序：快排优化。单路排序会比双路排序快一点)</p> 
<p>2.无过滤不索引（where。limit属于限制条件不是锅炉条件）</p> 
<p>3.order by 最左firesort（最好完全匹配，比如3个字段，没有使用第一个字段，后面两个字段使用了，虽然也可以走索引，但是从explain中的extra中会查看也会使用Using firesort。可以去掉后面，不能去掉中间和前面的）</p> 
<p>4.顺序错了（where,group by）</p> 
<p>5.方向反了firesort（在order by中统一顺序排序,顺序变化会导致firesort）</p> 
<p>6.熟练使用explain,必要使用使用optimizer_trance</p> 
<p><span style="color:#956fe7;">答案：</span></p> 
<p>1.首先要对sql进行分析检查，过滤字段、排序字段是否按照顺序创建索引</p> 
<p>2.如果查询字段不在索引中会导致回表，降低性能</p> 
<p>3.一定要有多虑字段</p> 
<p>4.多个字段排序字段方向不一致也会导致firesort,降低性能</p> 
<p>5.排序字段和索引顺序不一致也会导致firesort，降低性能</p> 
<p>6.使用explain关键字段和索引情况</p> 
<p>7.尽可能减少没必要的firesort</p> 
<h2 id="2.%E5%9C%A8JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86%E6%96%B0%E7%94%9F%E5%8E%BB%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86eden%E5%8C%BA%E5%92%8Csurvial%E5%8C%BA%EF%BC%9F"><strong>2.在JVM内存模型中，为什么要区分新生去和老年代，对于新生代为什么要区分eden区和survial区？</strong></h2> 
<p><img alt="" height="159" src="https://images2.imgbox.com/34/cc/rjEWeAdO_o.png" width="739"></p> 
<p><span style="color:#956fe7;">关键点：</span></p> 
<p><span style="color:#0d0016;">1.分清jvm标准与实现</span></p> 
<p><span style="color:#0d0016;">2.分清收集算法在g1是逻辑上的划分之前的垃圾回收器可以理解是在物理上</span></p> 
<p><span style="color:#0d0016;">3.标记算法</span></p> 
<p><span style="color:#0d0016;">4.清楚算法</span></p> 
<p><span style="color:#0d0016;">5.<strong>内存连续空间</strong></span></p> 
<p><span style="color:#956fe7;">答案：</span></p> 
<p><span style="color:#0d0016;">1.主流垃圾回收器cms g1都使用分代手机算法</span></p> 
<p><span style="color:#0d0016;">2.正常系统运行时候都会产生海量的临时对象，这些对象短时间会大量实现，我们把这个对象产生的区域叫新生代</span></p> 
<p><span style="color:#0d0016;">3.新生代满了之后需要清理垃圾对象，把有用的对象存放到老年代，方法后续的使用</span></p> 
<p><span style="color:#0d0016;">4.为了区分那些对象应该复制到老年代中，所以新生代划分出edun区s0,s1区域</span></p> 
<p><span style="color:#0d0016;">5.细化后新生代的内容再次划分保障高速读写同时内存连续</span></p> 
<p><span style="color:#0d0016;">          1.新对象会被保存到eden区(开始是空的所以内存连续，eden区满了后会把有效休想复制到s0区（s0也是空的所以连续）)</span></p> 
<p><span style="color:#0d0016;">           2.清楚eden区（再次写入连续空间）</span></p> 
<p><span style="color:#0d0016;">           3.s0和s1在命名上呼唤，远在的s1等待写入（空的）</span></p> 
<p><span style="color:#0d0016;">            4.eden区再次满了重复操作（15次后，进入老年代）</span></p> 
<p><span style="color:#0d0016;">6. eden区通过</span><span style="color:#fe2c24;">复制/清楚</span><span style="color:#0d0016;">算法保障了读写连续性</span></p> 
<h2 id="3.%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%89%E5%87%A0%E7%A7%8D"><strong><span style="color:#0d0016;">3.常见的远程调用有几种</span></strong></h2> 
<p><span style="color:#956fe7;"><strong>关键点：</strong></span></p> 
<p><span style="color:#0d0016;">1.网络协议与封装所有的网络请求是基于Tcp和Udp协议的</span></p> 
<p><span style="color:#0d0016;">2.常用框架(netty，restTemplate)</span></p> 
<p><span style="color:#0d0016;">3.长连接（复用）</span></p> 
<p><span style="color:#956fe7;"><strong>答案：</strong></span></p> 
<p><span style="color:#0d0016;">1.自定以协议实现c/s RPC调用（实现复杂，需解决问题多，serversocket,BIO,通过FileInputStream、FileOutPutStream,进行读写）</span></p> 
<p><span style="color:#0d0016;">2.UDP广播类型（查用于通讯、速度快、但要二次确认）</span></p> 
<p><span style="color:#0d0016;">3.基于http协议调用基于restful风格的api,springcloud就是使用http</span></p> 
<p><span style="color:#0d0016;">4.dubbo协议（阿里出品，长连接，二进制传输数据，性能比较高）</span></p> 
<p>5.soap协议（古老的webservice框架，基于xml实现数据封装，http请求）</p> 
<p>6.异步响应式（webFlux,SpringBoot Data Reactive）</p> 
<p>7.服务器堆（不主动调用，常见系统通知类，单工和双工通知，聊天室）</p> 
<h2 id="4.%E5%AF%B9%E4%BA%8E%E5%A4%96%E9%83%A8%E8%A1%94%E6%8E%A5%E7%9A%84%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E9%82%A3%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F">4.对于外部衔接的方法需要注意那些问题？</h2> 
<p>1.写好接口文档，方法系统维护和团队写作</p> 
<p>2.统一报文结构</p> 
<p>3.标准化的服务状态码 status_code=200//请求成功</p> 
<p>4.统一化请求日志以及异常记录</p> 
<p>5.GlobalExceptionHandler logger.error("服务器异常"，exception)</p> 
<p>6.请求延迟过高，可以快速失败</p> 
<p>7.重试机制</p> 
<p>8.事务问题可回滚(Seata类似框架实现）</p> 
<p>9.数据一致性问题（加锁）</p> 
<h2 id="5.%E5%85%B3%E4%BA%8E%40Transactional%E6%B3%A8%E8%A7%A3%E8%8C%83%E5%9B%B4%E7%90%86%E8%A7%A3">5.关于@Transactional注解范围理解</h2> 
<p>关键字：</p> 
<p>1.数据库事务</p> 
<p>2.编程式事务:beginTransaction,commit.rollback</p> 
<p>3.声明式事务@Transaction</p> 
<p>答：不能再类上声明事务，虽然可以开启但是效率慢，在单独的方法上添加@Transaction，</p> 
<h2 id="6.SpringBoot%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%89%88%E6%9C%AC%E4%BE%9D%E8%B5%96%3F%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96%EF%BC%9F">6.SpringBoot如何管理版本依赖?什么是自动配置，起步依赖？</h2> 
<p><span style="color:#956fe7;"><strong>关键点：</strong></span></p> 
<p>1.maven</p> 
<p>2.springboot父子关系</p> 
<p>3.spring-boot-starter</p> 
<p>答案：</p> 
<p>1.springboot底层使用maven管理依赖，通过控制pom.xml父子关系完成细节配置，在父pom中定义具体框架和版本号</p> 
<p>2.提供很多场景的spring-boot-starter,来标准化引入依赖避免环境冲突</p> 
<p><strong>什么是自动配置</strong></p> 
<p><span style="color:#956fe7;"><strong>关键点：</strong></span></p> 
<p><span style="color:#0d0016;">1.看springboot的源码</span></p> 
<p><span style="color:#0d0016;">2.@SpringBootAutoConfiguration开启自动配置功能，包含@EnableAutoConfiguration,@SpringBootConfiguration,@ComponentScan注解</span></p> 
<p><span style="color:#0d0016;">3.@EnableAutoConiguration开启自动配置功能，包含@AutoConfigurationPackage,@import</span></p> 
<p>        1.@AutoConfigurationPackage中@import(AutoConfigurationPackages.class)引入Registart.class完成批量注册，默认扫描启动类的包@Bean或@Component注解</p> 
<p>        2.@import(AutoConfigurationImportSelector.class)</p> 
<p>4.@ComponentScan扫描被@Component@Service@Controller注解的bean加载到容器中</p> 
<p>5.@SpringBootConfiguration表示SpringBoot配置类</p> 
<p><strong><span style="color:#956fe7;">答案：</span></strong></p> 
<p>1.所加载使用的jar包比较常见的，spring默认默认配置</p> 
<p>2.springboot通过在启动类添加@SoringBootApplication完成自动配置类</p> 
<p>3.内部完成读取每个jar包下的MET-INF/Spring.factories和spring-boot-autoconfigure-版本.jar的默认配置</p> 
<p><img alt="" height="761" src="https://images2.imgbox.com/f8/13/rUJ2RMGM_o.png" width="1200"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/14/b2/u6CXU0VE_o.png" width="1200"></p> 
<p></p> 
<p><strong><span style="color:#956fe7;">起步依赖：</span></strong></p> 
<p>答案：各种start重点是在pom,xml,其中包含框架所需要的其他依赖不需要我们配置。</p> 
<h2 id="7.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><strong>7.数据库索引原理</strong></h2> 
<p><span style="color:#956fe7;"><strong>关键点：</strong></span></p> 
<p>1.那种数据库</p> 
<p>2.以mysql为例的b+树</p> 
<p>3.索引的好处和代价</p> 
<p>5.优化：<br>         1.硬件层面</p> 
<p>        2.软件层面</p> 
<p><span style="color:#0d0016;"><strong>数据库索引的原理？</strong></span></p> 
<p><span style="color:#0d0016;">1.以mysql为例，默认引擎InnoDB使用b+树实现索引，在索引查找时实现了log(n)的时间复杂度</span></p> 
<p>b+树中每一个结点时固定大小的，一页默认表示16k</p> 
<p>2.索引类型分为聚簇索引(记录完整数据)和非聚簇索引(索引字段+主键id)。</p> 
<p>聚簇索引的叶子结点记录完整的值，比如一个表有id,name,age,主键为id,那么聚簇索引会默认生成，他是以id为主键，包含数据name,age的索引。创建索引为id,但默认包含该id的一行数据</p> 
<p>非聚簇索引的叶子结点存放的是，当初创建索引的字段不包含其他字段。，比如一张表的字段为id(主键),name,age。我创建的索引为name,那么索引的<span style="color:#fe2c24;">只包含name和主键id</span>，如果我需要通过name查询响应的age,则需要回表操作。但是聚簇索引就不需要回标操作。</p> 
<p>3.索引的叶子结点以链表的形式存储，方便顺序查找和排序</p> 
<p><strong>索引的缺点是什么？</strong></p> 
<p>1.会占用空间（会建立各种复合索引，比如name一个索引，name和age索引）</p> 
<p>2.更新时会练级更新索引</p> 
<p>3.高并发影响性能（mvcc机制）</p> 
<p><strong>什么情况会导致索引失效？</strong></p> 
<p>1.select 使用函数</p> 
<p>2.否定语句，比如where中的is not null,is null，！=或者&lt;&gt;</p> 
<p>3.未使用最佳左匹配，比如索引三个字段，查询时未从第一个开始，先使用中间的</p> 
<p>4.使用左模糊查询，like以%开头导致索引失效（阿里手册严谨左模糊和有模糊，如果需要使用es解决）</p> 
<p>5.数据库优化器觉得不走索引比走索引快的时候，比如说数据量比较少的时候</p> 
<p>6.类型转化导致索引失效</p> 
<p><strong>数据库优化的方法有那些？</strong></p> 
<p>1.硬件上优，主要在存储进行优化,申请单独的磁盘存储数据库</p> 
<p>2.网络，优化网卡，现在比如千兆网卡，或者万兆网卡，提高带宽比如</p> 
<p>3.操作系统调优，tcp/ip协议超时的优化</p> 
<p>4.表结构的优化,1.比如表中添加冗余字段进行优化2.使用varchar(20)就不需要使用200，3.比较长的字段使用<span style="color:#fe2c24;">blob（能不再数据库上存就不要在数据库上存），</span><span style="color:#0d0016;">字段比较小的直接使用</span><span style="color:#fe2c24;">char</span><span style="color:#0d0016;">类型（最多存255）。4.存储时间优化datatime换成timestamp（timestamp比dattime存储少一半）。</span></p> 
<p>5.sql的优化，select *不要用，where的等职比对，范围比对（等值匹配放到前面，范围匹配放到后面），order by按照最左匹配法则建好</p> 
<p>6.减少函数的使用</p> 
<p>7.索引优化，借助explain工具，减少多表查询，子查询，临时的中间表</p> 
<p>8.大字段的以及全文检索优化,比如es,或者FastDFS</p> 
<p>9.连接池优化，</p> 
<p>10.事务优化，防止表锁或者行锁，少用select * ...for update,把事务的隔离级别调低</p> 
<p>11.数据库集群的优化，单节点的优化，读写分离（会指数级的提成）集群方案:主从复制，多主复制（mmm:master+master+master）</p> 
<p>12.加入缓存</p> 
<p>13.冷热存储，按照查询的时间，分冰冷数据和热乎的数据，把冷数据存到别的库中，需要调用另外的接口进行擦汗寻</p> 
<p>14.分库分表</p> 
<h2 id="8.Integer%E5%92%8Cint%E7%9A%84%E5%8C%BA%E5%88%AB">8.Integer和int的区别</h2> 
<p><strong><span style="color:#956fe7;">关键点：</span></strong></p> 
<p><span style="color:#0d0016;">1.堆栈存储基础数据类型与对象</span></p> 
<p><span style="color:#0d0016;">2.值比对的时候注意java的自动拆箱</span></p> 
<p><span style="color:#0d0016;">3.Integer值大小在-128到127之内，使用IntegerCache</span></p> 
<p><span style="color:#956fe7;"><strong>答：</strong></span></p> 
<p><span style="color:#0d0016;">1.Integer是int包装类，int则是一个基本数据类型</span></p> 
<p><span style="color:#0d0016;">2.Integer实际是对象的引用，当new一个integer,实际上胜场一个指针的对象，而int则直接存放数据</span></p> 
<p><span style="color:#0d0016;">3.integer的默认值是null,而int的默认值是0</span></p> 
<h2 id="9.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F">9.数据库的三大范式</h2> 
<p>第一范式：单表（字段），拆分到不可差分为止，，有主见有原子性，字段不再可拆分</p> 
<p>第二范式：每一行数据唯一性</p> 
<p>第三范式：表之间主键关联</p> 
<h2 id="10.%E4%BB%80%E4%B9%88%E6%98%AFSpring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F%E6%9C%89%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">10.什么是Spring的依赖注入？有那些方法进行依赖注入</h2> 
<p>关键字：</p> 
<p>1.IOC inversion of Control 控制翻转</p> 
<p>2.DI Dependency Injection 依赖注入（通过IOC来左DI这件事的）</p> 
<p>答案：依赖注入是指将依赖的对象实例交给Spring帮我们注入管理，从而释放兑现搞得管理</p> 
<p>1.set方法注入</p> 
<p>2.构造方法注入</p> 
<p>3.autowire自动注入</p> 
<h2 id="11.%E7%90%86%E8%A7%A3JVM">11.理解JVM</h2> 
<p>1.jvm标准与实现（各个厂商不一样）</p> 
<p>2.解决跨平台问题</p> 
<p>3.JMM内存模型</p> 
<p>4.JVM模型</p> 
<p>5.不同的垃圾回收器(g1,stw)</p> 
<p><img alt="" height="537" src="https://images2.imgbox.com/b5/5c/sBIsaKPC_o.png" width="625"></p> 
<p> 答案：jvm是java虚拟机，我们class文件运行在虚拟机上，通过虚拟机解决跨平台问题，jvm中有jmm来管理java内存访问问题，不同jvm实现性能关注有差异，现在主流是现实hotspot,垃圾回收器是G1,jvm运行时内存中分为方法去，堆，本地方法栈，执行代码时需要执行引引擎。</p> 
<h2 id="12.%E6%B5%85%E8%B0%88ReentrantLock%E7%9A%84%E8%AE%BE%E8%AE%A1">12.浅谈ReentrantLock的设计</h2> 
<p>答案：</p> 
<p>1.ReentrantLock是多线程竞争资源时使用的锁，他是一个独占锁（只有一个线程可以进入），可重入锁（当前线程获取锁后，当这个线程又需要这个锁的其他业务逻辑的时候不需要再重新获取这一把锁头），悲观锁</p> 
<p>2.ReentrantLock支持公平锁，对于公平和非公平锁又不同的实现逻辑</p> 
<p>3.ReentrantLock使用aqs（AbstractQueuedSynchronizer）来实现获取锁的锁的线程队列等待过程</p> 
<p>4.内部使用了原子类来操作cas（compareAndSetState(0,1),0表示没有上锁，1表示上锁了，判断当前是否获取锁，失败则会继续acpuire）比较线程与对应的锁关系</p> 
<p><img alt="" height="701" src="https://images2.imgbox.com/f2/41/mWCFZdRE_o.png" width="1200"></p> 
<p></p> 
<p>5.内部支持newCondition来灵活控制获取锁的线程的阻塞和释放</p> 
<p></p> 
<h2 id="13.%E8%AF%B4%E4%B8%80%E4%B8%8Bmysql%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><strong>13.说一下mysql中事务的实现原理</strong></h2> 
<p>依赖MVCC(Multi-version Concurrency Control)的版本控制。Mvcc实现依赖于<span style="color:#fe2c24;">隐藏字段</span>、<span style="color:#fe2c24;">Read</span> <span style="color:#fe2c24;">View</span><span style="color:#0d0016;">、</span><span style="color:#fe2c24;">Undo Log</span></p> 
<p><span style="color:#956fe7;">隐藏字段：</span></p> 
<p><span style="color:#fe2c24;">DB_TRX_ID：</span><span style="color:#0d0016;">用来表示最近一次对数据修改(insert，update)的事务的标识符，即最后一次修改本行记录的事务id,再innDB存储引擎内部也属于一次update,即更新行中的一个特殊为，如果进行删除并非真正的删除。</span></p> 
<p><span style="color:#fe2c24;">DB_ROLL_PTR</span><span style="color:#0d0016;">:回滚指针，该只想行的undo log,如果为被更新，则为空</span></p> 
<p><span style="color:#fe2c24;">DB_ROW_ID</span>:如果没有主键的时候，则InnoDB会使用该id生成聚簇索引</p> 
<p><span style="color:#956fe7;">Read View:</span></p> 
<p><span style="color:#0d0016;">不同的事务隔离级别，当有事务再执行过程中修改了数据（更新了版本号），在</span><span style="color:#be191c;">并发事务时</span><span style="color:#0d0016;">需要判断一下版本链中那个版本是当前事务可见。</span></p> 
<p><span style="color:#956fe7;">undo log:</span></p> 
<p><span style="color:#0d0016;">除了用来回滚出局，还可以读取可见版本数据，以此实现非锁定读</span></p> 
<p><strong><span style="color:#0d0016;">答案：</span></strong></p> 
<p><span style="color:#0d0016;">1.mysql是由mvcc实现事务控制</span></p> 
<p><span style="color:#0d0016;">2.MVCC的实现依赖于：隐藏字段、Read View ,undo log（mysql中写输入的时候是先写日志，再写数据）</span></p> 
<p><span style="color:#0d0016;">3.在不同的事务隔离级别下通过设置readview内容，控制了那些数据可见，那些不可见</span></p> 
<h2 id="14.%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><strong>14.编写一个基于线程安全的懒加载单例模式</strong></h2> 
<pre><code class="language-java">public class Test03 {
    private static Test03 instance=null;
    private Test03(){

    }
    public static Test03 getInstance(){
//        多线程中，重复new了多个对象
        if (instance==null){
//            第一次访问初始化的时候降低
            synchronized (Test03.class){
                if (instance==null){
                    return new Test03();
                }else {
                    return instance;
                }
            }
        }else {
            return instance;
        }
    }
}</code></pre> 
<h2 id="15.%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98"><strong>15.值传递和引用传递问题</strong></h2> 
<p><img alt="" height="602" src="https://images2.imgbox.com/27/3a/8adPsRuh_o.png" width="939"></p> 
<h2 id="16.%E5%BC%82%E5%B8%B8%E4%B8%AD%E7%9A%84return%E9%97%AE%E9%A2%98"><strong>16.异常中的return问题</strong></h2> 
<p>catch()捕捉异常的return没有用，最后一定会走finally</p> 
<h2 id="17.Spring%E7%9A%84AOP%E7%9A%84%E6%97%B6%E8%AF%84%E5%9C%BA%E6%99%AF%E6%9C%89%E9%82%A3%E4%BA%9B"><strong>17.Spring的AOP的时评场景有那些</strong></h2> 
<p><span style="color:#956fe7;"><strong>关键点：</strong></span></p> 
<p>1.aop面向切面编程使用非常广泛，几乎适用于一切需要统一化处理的场景</p> 
<p><span style="color:#956fe7;"><strong>答：</strong></span></p> 
<p>1.统一日志处理</p> 
<p>2.统一异常处理</p> 
<p>3.访问设置(权限、限流)sentinel组件</p> 
<p>4.事务处理@Transactional</p> 
<p>5.缓存管理等</p> 
<p>6.aop是面向切面编程，通过代理方式(jdk或cglib),为程序统一添加功能，解决公共问题</p> 
<h2 id="18.%E5%88%97%E4%B8%BELinux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><strong>18.列举Linux的常用命令</strong></h2> 
<p><strong>答：</strong></p> 
<p>1.find、rm、rmdir、mv、cp、cat、pwd、chmod、kill、ping、ifconfig</p> 
<p>2.tail、ps、grep、nestat、echo、ssh、scp、top、mpstat、free、df</p> 
<p></p> 
<h2 id="19.%E5%88%97%E4%B8%BE%E7%9F%A5%E9%81%93%E5%B9%B6%E4%BD%BF%E7%94%A8%E8%BF%87%E5%85%B6%E4%BB%96%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF"><strong>19.列举知道并使用过其他前沿技术</strong></h2> 
<p>1.go语言</p> 
<p>2.物联网LOT嵌入式开发，树莓派小车，摄像头</p> 
<p>3.地带吗数据中心</p> 
<p>4.jdk新特性，g1,zgc</p> 
<p>5.区块链</p> 
<p>6.容器化云原生与监控</p> 
<p>7.java高性能游戏开发,jdk11之后可以会使用到硬件了</p> 
<p>8.DDD</p> 
<p>9.响应式编程与异步网络编程</p> 
<p>10.推荐系统</p> 
<p>11.高并发系统框架nginx+lua</p> 
<p>12.chatgpt</p> 
<h2 id="20.JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%8C%85%E5%90%AB%E9%82%A3%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86"><strong>20.JVM运行时数据区域包含那几个部分</strong></h2> 
<p>答：</p> 
<p>运行时区域就是new出来的对象和执行方法</p> 
<p>1.堆：new出来的对象，会存储大量的对象，所以划分出新生区、老年代。共享数据区。对象的引用，</p> 
<p>2.栈：方法内部需要运行的数据，包括局部变量，传参变量、class文件。在栈中他会存储栈针，在栈帧中包含指向具体的类输入和输出的一些参数。同样也会用到程序计数器。随着线程的产生而产生，随着线程的销毁而销毁，不需要垃圾回收。</p> 
<p>3.本地方法栈：运行基础程序的也需要一些方法。网络驱动啊，一些输入输出的设备。</p> 
<p>4.方法区：通过classloader的load上面就到方法区，jdk1.7和1.8有些区别</p> 
<h2 id="21.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84start()%E6%96%B9%E6%B3%95%E5%92%8Crun()%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%97%B6%E4%BB%80%E4%B9%88"><strong>21.多线程中的start()方法和run()方法的区别时什么</strong></h2> 
<p>1.start的方法是启动线程，改变的是线程的状态，由就绪进入执行</p> 
<p>2.run方法中包含要执行的代码，在执行状态时运行里面的代码，方法返回的是void，无法得到结果，只能通过多线程返回访问共享变量获取结果。</p> 
<h2 id="22.%E7%AE%80%E5%8D%95%E5%86%99%E4%B8%80%E4%B8%AA%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E7%9A%84%E7%A8%8B%E5%BA%8F"><strong>22.简单写一个会导致死锁的程序</strong></h2> 
<p><strong>避免：1.不要使用嵌套锁。2.锁的顺序</strong></p> 
<p></p> 
<h2 id="23.%E5%AF%B9%E4%BA%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><strong>23.对于高并发问题的处理方式</strong></h2> 
<p>1.寻找平静</p> 
<p>2.分治的思想，业务差分、流程拆分</p> 
<p>3.限流</p> 
<p>4.分流、cdn缓存</p> 
<p>5.流量清洗。waf</p> 
<p>6.多级缓存设计，后端缓存，客户端缓存</p> 
<p>7.日志溯源</p> 
<p>8.资源隔离</p> 
<p>9.弹性扩缩容量</p> 
<p>10.降级处理前后端兜底数据</p> 
<h2 id="24.%E9%AB%98%E5%8F%AF%E7%94%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%B8%B8%E7%94%A8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><strong>24.高可用问题的常用处理方式</strong></h2> 
<p>1.容器化管理</p> 
<p>2.keepalived</p> 
<p><strong>25.简单描述一下JVM加载class文件的原理机制</strong></p> 
<p><img alt="" height="262" src="https://images2.imgbox.com/61/71/evQI1Up9_o.png" width="484"></p> 
<p><span style="color:#956fe7;"><strong>关键字：</strong></span></p> 
<p>1.类加载器</p> 
<p>2.魔数</p> 
<p>3.元空间</p> 
<p>负责加载class文件，class文件在口头由特定的文件表示，并且ClassLoader只负责class文件加载，至于是否能运行又Execution Engine决定</p> 
<p><span style="color:#956fe7;"><strong>魔数：</strong></span></p> 
<p><span style="color:#0d0016;">class文件开头的四个字节的无符号称为魔数</span></p> 
<p>魔数是Class文件标识。值是固定的为0xCAFEBABE</p> 
<p>如果一个class文件的投自己字节不是0xCAFEBABE就会报错</p> 
<p><span style="color:#956fe7;"><strong>双亲委派机制：</strong></span></p> 
<p></p> 
<p> <img alt="" height="418" src="https://images2.imgbox.com/d3/2e/4bpI4qvL_o.png" width="631"></p> 
<p> </p> 
<h2 id="26.%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88"><strong>26.数据连接池的工作机制是什么</strong></h2> 
<p><span style="color:#956fe7;"><strong>关键点：</strong></span>1.连接复用2.限制连接个数</p> 
<p>1.连接池与线程池实现原理一样</p> 
<p>2.限流与复用</p> 
<p>3.数据库建立一个连接的开销要比客户都安大</p> 
<p>4.数据库负责连接池分配、管理和释放数据连接，他允许应用床徐重复使用一个现有的数据库连接，而再不是重新建立一个</p> 
<p><span style="color:#956fe7;"><strong>答案：</strong></span></p> 
<p>1.预先创建好一些数据，放到连接池中</p> 
<p>2.连接池中设置最小连接数和最大连接数</p> 
<p>3.最小连接不断开和数据库的连接</p> 
<p>4.超过最小连接的那些线程，再长时间不使用会被回收，也就是断开数据库的连接</p> 
<p>5.所有向数据库发送请求的业务必须通过连接池获得数据库连接</p> 
<p>6.再连接使用，可以使用队列等待</p> 
<h2 id="27.%E9%82%A3%E4%B8%80%E4%B8%AAList%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%BF%AB%E6%8F%92%E5%85%A5"><strong>27.那一个List实现最快插入</strong></h2> 
<p>arrayList:十足实现，查询，修改比较快</p> 
<p>linkedList:链表实现，扎入、删除比较快，直接再最后插入数据即可</p> 
<p>vector:jdk1.0,线程安全但是效率比较低</p> 
<h2 id="28.%E5%AD%98%E5%9C%A8i%2B1%3Ci%E7%9A%84%E6%95%B0%E4%B9%88">28.存在i+1&lt;i的数么</h2> 
<p>1.基本数据类型至大至+1会变成负数</p> 
<p>Integer.Max_Value+1就会打印出附属</p> 
<p></p> 
<h2 id="33.null%E9%97%AE%E9%A2%98"><strong>33.null问题</strong></h2> 
<p>关键点：1.null可以被强转到任何类型的</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/db/44/VRZvQtfe_o.png" width="601"></p> 
<p>输出结果haha</p> 
<h2 id="34.%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><strong>34.共享变量多线程可见性问题</strong></h2> 
<p>运行无返回值,需要添加volatile，让线程共享变量。while代替if,否则会导致虚假唤醒。</p> 
<p><img alt="" height="906" src="https://images2.imgbox.com/cf/cc/XiqcIgZD_o.png" width="937"></p> 
<p> </p> 
<h2 id="35.synchronize%E9%94%81%E5%AF%B9%E8%B1%A1%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98"><strong>35.synchronize锁对象竞争问题</strong></h2> 
<p>synchronize修饰方法如果是静态默认的锁为class，如果非静态默认锁为当前对象</p> 
<h2 id="36.%E9%AB%98%E7%BA%A7%E5%9B%9E%E7%AD%94%E6%96%B9%E5%BC%8F%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><strong>36.高级回答方式 多线程有几种实现方式</strong></h2> 
<p>1.实现Runable接口void返回值，start,run</p> 
<p>2.实现Callable接口可以指定返回值</p> 
<p>FetureTask(new Callable())，start，get</p> 
<h2 id="37.%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><strong>37.高级同步有几种实现方式</strong></h2> 
<p><strong><span style="color:#956fe7;">非阻塞：</span></strong></p> 
<p>1.volatile(不能保障原子特性)</p> 
<p>2.cas以及atomic系列实现（保障同步和数据一致性）</p> 
<p><strong><span style="color:#956fe7;">阻塞：</span></strong></p> 
<p>1.wait()</p> 
<p>2.sleep</p> 
<p>3.synchronized</p> 
<p>4.Lock的实现        ReentrantLock、ReentrantReadWriteLock等、condition.await()</p> 
<p>5.CountDownLatch</p> 
<p>6.CylicBarrier</p> 
<p>7.Semaphore</p> 
<p>8.BlockingQueue</p> 
<h2 id="38.Thread%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><strong>38.Thread类的常用方法</strong></h2> 
<p>start,run,getPriority()获取优先级，interrupt()打断线程会抛出异常</p> 
<p>结束线程最好是讲简称执行完毕</p> 
<h2 id="39.Exception%E7%88%B6%E7%B1%BB%E9%97%AE%E9%A2%98"><strong>39.Exception父类问题</strong></h2> 
<p>继承Throwable和Serialable</p> 
<h2 id="40.String%E5%80%BC%E5%AF%B9%E6%AF%94%E9%97%AE%E9%A2%98"><strong>40.String值对比问题</strong></h2> 
<p>false，不允许 </p> 
<p><img alt="" height="101" src="https://images2.imgbox.com/9d/8f/4h6Ow2YE_o.png" width="612"></p> 
<h2 id="43.gc%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8Cvolatile%E9%97%AE%E9%A2%98"><strong>43.gc守护线程和volatile问题</strong></h2> 
<p>gc是守护线程，</p> 
<p>volatile无法保证线程安全</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3fdd2e662f38e1d55d5bf0cde403a12a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python爬虫学习 爬取京东商品</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2bdb7aca243be3bb6ba03cb580ca2715/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">A006 - 基础 - VRF/VPN-instance</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>