<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>我在 vue3 开发中踩的坑 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="我在 vue3 开发中踩的坑" />
<meta property="og:description" content="前期准备 由于 vite 在开发态是基于 ESM 进行模块化开发, 而 ESM 的浏览器兼容版本有限，如下图。
esm-兼容 所以，如果你打算使用 vite 作为构建工具去开发，你至少要有一个合适版本的浏览器。如果你和我一样，Chrome 版本的浏览器比较低，但是又不想升级，想留着偶尔方便自测和定位浏览器兼容问题，那我推荐你安装一个Chromium。这样你就可以一个电脑里面拥有两个 Chrome。_没有两个chrome的前端不是好前端[狗头]。_
chrome2 这时候，你可能又会有另外一个问题，_什么是 ESM？_ 关于这个问题，这里不展开说，有兴趣的可以看看这篇文章[1]。通俗易懂的理解，就是在开发态，我们加载的是模块化的 ts 或者 js，而且在打包后，我们加载的就是的 CommonJS,如下图。
esm noesm 除此之外，你要升级你的 node 环境到 node 14 以上版本。而如果你也是用的 windows 7, 这就有了第二个问题, 如何在 windows 7下安装 node 14？ 需要将下载的 node 包放在指定的 nvm 文件夹同时将系统变量 NODE_SKIP_PLATFORM_CHECK 设置为 1。
组件准备：因为希望组件风格和之前保持一致，为了更加灵活的修改组件，我们基于antdv[2]进行了简单封装，并发布到私有的 npm 仓库。
组件自动引入unplugin-vue-components
上面的封装也带来另外一个坑,就是会导致无法使用 unplugin-vue-components。我去提了issues 希望可以支持组件名动态设置[3] 和 PR[4], 应该下个版本 AntDesignVueResolver 就可以支持了。
你可能要习惯的和 vue2 的不同 在实际开发过程中，从 vue2 升级到 vue3 我觉得有几个地方或许是需要适用一下的，这里也提一下。
组合式 API 组合式 API 是一系列 API 的集合, 它是 Vue 3 和 Vue2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5ba695ed6f5854f382d208b0da28a7ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-09T08:40:58+08:00" />
<meta property="article:modified_time" content="2022-11-09T08:40:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">我在 vue3 开发中踩的坑</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <h4>前期准备</h4> 
 <p>由于 vite 在开发态是基于 ESM 进行模块化开发, 而 ESM 的浏览器兼容版本有限，如下图。</p> 
 <img src="https://images2.imgbox.com/9f/ed/lpMZKTtT_o.png" alt="outside_default.png"> 
 <figcaption>
   esm-兼容 
 </figcaption> 
 <p>所以，如果你打算使用 vite 作为构建工具去开发，你至少要有一个合适版本的浏览器。如果你和我一样，<code>Chrome</code> 版本的浏览器比较低，但是又不想升级，想留着偶尔方便自测和定位浏览器兼容问题，那我推荐你安装一个<code>Chromium</code>。这样你就可以一个电脑里面拥有两个 <code>Chrome</code>。_没有两个chrome的前端不是好前端[狗头]。_</p> 
 <img src="https://images2.imgbox.com/e8/b6/UC7iyKpM_o.png" alt="outside_default.png"> 
 <figcaption>
   chrome2 
 </figcaption> 
 <p>这时候，你可能又会有另外一个问题，_什么是 ESM？_ 关于这个问题，这里不展开说，有兴趣的可以看看这篇文章<sup>[1]</sup>。通俗易懂的理解，就是在开发态，我们加载的是模块化的 <code>ts</code> 或者 <code>js</code>，而且在打包后，我们加载的就是的 <code>CommonJS</code>,如下图。</p> 
 <img src="https://images2.imgbox.com/0b/61/TNgg9udP_o.png" alt="outside_default.png"> 
 <figcaption>
   esm 
 </figcaption> 
 <img src="https://images2.imgbox.com/28/3a/Jce3oTat_o.png" alt="outside_default.png"> 
 <figcaption>
   noesm 
 </figcaption> 
 <p>除此之外，你要升级你的 <code>node</code> 环境到 <code>node 14</code> 以上版本。而如果你也是用的 <code>windows 7</code>, 这就有了第二个问题, <em>如何在 <code>windows 7</code>下安装 <code>node 14</code>？</em> 需要将下载的 <code>node</code> 包放在指定的 <code>nvm</code> 文件夹同时将系统变量 <code>NODE_SKIP_PLATFORM_CHECK</code> 设置为 <code>1</code>。</p> 
 <p><strong>组件准备</strong>：因为希望组件风格和之前保持一致，为了更加灵活的修改组件，我们基于antdv<sup>[2]</sup>进行了简单封装，并发布到私有的 <code>npm</code> 仓库。</p> 
 <p><strong>组件自动引入unplugin-vue-components</strong></p> 
 <p>上面的封装也带来另外一个坑,就是会导致无法使用 <code>unplugin-vue-components</code>。我去提了issues 希望可以支持组件名动态设置<sup>[3]</sup> 和 PR<sup>[4]</sup>, 应该下个版本 <code>AntDesignVueResolver</code> 就可以支持了。</p> 
 <h4>你可能要习惯的和 vue2 的不同</h4> 
 <p>在实际开发过程中，从 <code>vue2</code> 升级到 <code>vue3</code> 我觉得有几个地方或许是需要适用一下的，这里也提一下。</p> 
 <h5>组合式 API</h5> 
 <p>组合式 API 是一系列 API 的集合, 它是 Vue 3 和 Vue2.7 的内置功能，而对于更老的 Vue 2 版本，则可以使用 <code>@vue/composition-api</code>包。组合式 API 包括：</p> 
 <img src="https://images2.imgbox.com/49/b5/9diCuRy6_o.png" alt="outside_default.png"> 
 <figcaption>
   组合式api 
 </figcaption> 
 <p><code>&lt;script setup&gt;</code> 是在单文件组件 (SFC) 中使用组合式 API 的编译时<strong>语法糖</strong>。个人感觉，不用这个语法糖写法上和 <code>Vue 2</code> 更加接近，而使用这个<strong>语法糖</strong>写起来则更丝滑些，写法对比如下图：</p> 
 <img src="https://images2.imgbox.com/27/0b/2dQR2kWZ_o.png" alt="outside_default.png"> 
 <figcaption>
   no-setup 
 </figcaption> 
 <img src="https://images2.imgbox.com/f4/15/TC8qFUje_o.png" alt="outside_default.png"> 
 <figcaption>
   setup 
 </figcaption> 
 <h5>响应式</h5> 
 <h6>数组</h6> 
 <p>有两种实现方式，如下图。我个人用下来，觉得<code>写法一</code>更丝滑些。</p> 
 <img src="https://images2.imgbox.com/3d/8f/nSKtdnsq_o.png" alt="outside_default.png"> 
 <figcaption>
   数组响应式 
 </figcaption> 
 <h6>响应式代理</h6> 
 <p>你可能也注意到，对整个数组的变更，我用的是 <code>Object.assign</code> 去实现的，因为只有这样，才能保持数据的响应式。这和 <code>Vue 2</code> 也是有区别的，官网也有做说明响应式代理 vs. 原始值<sup>[5]</sup>，原因和 <code>Vue 3</code> 的数据响应式原理有关。至于<code>Vue 3</code> 的数据响应式原理这里不展开说，可以参考我之前写的另一篇文章关于vue3的Proxy<sup>[6]</sup>。</p> 
 <img src="https://images2.imgbox.com/15/c8/Ks9cKG3G_o.png" alt="outside_default.png"> 
 <figcaption>
   reactive.png 
 </figcaption> 
 <h6>双向绑定实现</h6> 
 <p><strong>父组件</strong></p> 
 <pre class="has"><code class="language-go">&lt;template&gt;
  &lt;div class="hello"&gt;
    &lt;h1 @click="showModal"&gt;打开弹窗&lt;/h1&gt;
    &lt;Modal v-model="visible"&gt;&lt;/Modal&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
  import Modal from './modal-setup.vue'
  defineProps&lt;{ msg: string }&gt;()
  const visible = ref(false)
  const showModal = () =&gt; {
    visible.value = true
  }
&lt;/script&gt;

&lt;style scoped&gt;
.hello {
  position: relative;
  width: 100px;
}
&lt;/style&gt;
复制代码</code></pre> 
 <p><strong>子组件</strong></p> 
 <pre class="has"><code class="language-go">&lt;template&gt;
  &lt;teleport to="#app"&gt;
    &lt;div class="modal" @click="hideModal" v-show="visible"&gt;
      modal
    &lt;/div&gt;
  &lt;/teleport&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
  const props = defineProps&lt;{ modelValue: Boolean }&gt;()
  const emit = defineEmits(['update:modelValue'])
  const visible = computed({
    get: () =&gt; props.modelValue,
    set: val =&gt; {
      emit('update:modelValue', val)
    }
  })
  const hideModal = () =&gt; {
    visible.value = false
  }
&lt;/script&gt;
&lt;style scoped&gt;
.modal {
  position: absolute;
  top: 0;
  right: 0;
  background: #999;
  width: 300px;
  height: 100vh;
}
&lt;/style&gt;
复制代码</code></pre> 
 <h6>echarts 使用</h6> 
 <pre class="has"><code class="language-go">&lt;template&gt;
  &lt;div v-for="(card, index) in cardList" :key="`${card.id}-${index}`"&gt;
    &lt;div class="card"&gt;
      &lt;!-- 当你放置echart的元素是动态渲染时, 需要动态挂载元素--&gt;
      &lt;template v-if="card.type === 1"&gt;
        &lt;div :ref="(el) =&gt; setEchartRef(el, index)" class="chart"&gt;&lt;/div&gt;
      &lt;/template&gt;
      &lt;div v-else&gt;empty-box&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
  import * as echarts from 'echarts/core';
  import { PieChart } from 'echarts/charts';
  import { CanvasRenderer } from 'echarts/renderers';
  import { GridComponent, TooltipComponent } from 'echarts/components';
  echarts.use([GridComponent, PieChart, CanvasRenderer, TooltipComponent]);
  const cardList = ref([]);
  const echartsRef = ref&lt;HTMLElement[]&gt;([]);

  function setEchartRef = (el: HTMLElement, index: number) =&gt; {
    echartsRef.value[index] = el;
  }
  function drawEchart(index) {
    cardList.value[index].echart = echarts.init(echartsRef?.value?.[index] as unknown as HTMLElement);
    cardList.value[index].echart.setOption({
      //  ...
    })
  }
  function setEchartData() {
    cardList.value[index].type = 1;
    await nextTick();
    drawEchart(index);
  }
&lt;/script&gt;
复制代码</code></pre> 
 <h4>关于构建部署踩的坑</h4> 
 <ol><li><p>混用 <code>require</code> 和 <code>import</code></p></li></ol> 
 <p>如果项目中存在混用 commonJS 和 ES6 模块的情况，需要使用 <code>@originjs/vite-plugin-commonjs</code> 这个插件的 <code>transformMixedEsModules</code> 配置进行 hotfix。不然会报错<code>Uncaught ReferenceError: require is not defined</code>。_不过，尽量不要混用，因为尤大大说了这么干不好....Vite will likely never support such dependencies.<sup>[7]</sup>_</p> 
 <pre class="has"><code class="language-go">import { defineConfig } from 'vite'
import { viteCommonjs } from '@originjs/vite-plugin-commonjs';
export default defineConfig({
  // ...
  plugins: [
    viteCommonjs({
      transformMixedEsModules: true,
    }),
  ]
})
复制代码</code></pre> 
 <p>个人理解，这个配置类似于 <code>babel</code> 的 sourceType<sup>[8]</sup>配置项。因为之前在<code>babel</code>也踩过类似的坑，这里贴出对应 issues4039<sup>[9]</sup>。其实简单概括就是出现了<strong>import和module.exports的混用</strong>。</p> 
 <p>所以，原来项目中用 <code>h</code> 函数渲染图片的写法也要改为es引入，如下：</p> 
 <pre class="has"><code class="language-go">import exampleImg from './assets/example.png'
import { h } from 'vue';
function renderModal() {
   Modal.confirm({
    title: '操作确认',
    icon: null,
    content: () =&gt;
      h('div', { style: 'text-align: center;padding-bottom: 32px;' }, [
        // 原来vue2的写法 h('img', {attrs: {src: require('./assets/example.png')}})
        h('img', { src: exampleImg })]),
  });
}
复制代码</code></pre> 
 <ol><li><p>关于浏览器兼容问题</p></li></ol> 
 <p><code>vite</code> 的 build.target<sup>[10]</sup> 配置项可以配置希望兼容的浏览器版本或者 ES 版本，cssTarget<sup>[11]</sup>可以对 CSS 的压缩设置一个<code>target</code>，该配置应针对非主流浏览器使用。例如，安卓微信中的 webview，并不支持 CSS 中的十六进制颜色符号, 此时将 <code>build.cssTarget</code> 设置为 <code>chrome61</code>，可以防止 <code>vite</code> 将 <code>rgba()</code> 颜色转化为 <code>#RGBA</code> 十六进制符号的形式。</p> 
 <img src="https://images2.imgbox.com/fe/08/8XEw0Noy_o.png" alt="outside_default.png"> 
 <figcaption>
   globalthis 
 </figcaption> 
 <p>除此之外, 还可以使用插件 <code>@vitejs/plugin-legacy</code> 进行更多的浏览器兼容问题处理。例如，在内核 <code>chrome 69</code> 版本的360浏览器中，遇到过<code>Uncaught ReferenceError: globalThis is not defined</code>这样的报错。网上搜到可以通过解决浏览器端 globalThis is not defined 报错<sup>[12]</sup>简单快速的 <code>hotfix</code> 可以解决这个问题，但是我始终觉得不够优雅。</p> 
 <p>后来翻了下文档，实际可以通过 <code>@vitejs/plugin-legacy</code> 的<code>modernPolyfills</code>配置去解决这个问题，解决配置如下代码。同理,你也可以 <code>Polyfills</code> 你需要的es<sup>[13]</sup>。</p> 
 <pre class="has"><code class="language-go">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import legacy from '@vitejs/plugin-legacy'

export default defineConfig({
  server: {
    port: 8080
  },
  build: {
    target: 'es2015', // js兼容处理
    cssTarget: 'chrome49', // css兼容处理
  }
  plugins: [
    vue(),
    legacy({
      targets: ['chrome 49'],
      modernPolyfills: ['es.global-this'], // 解决浏览器端 globalThis is not defined 报错
    }),
  ]
})
复制代码</code></pre> 
 <p>说完这么多坑，最后附上一张比较有意思的图2021年前端框架开发：满意度-感兴趣程度-使用度-熟知度<sup>[14]</sup>：</p> 
 <img src="https://images2.imgbox.com/c5/33/l3GjaNql_o.png" alt="outside_default.png"> 
 <figcaption>
   有意思的图 
 </figcaption> 
 <p><em>踩了这么多坑，你可能会问，后悔在新项目里面用 <code>vue3</code>了吗？我的答案是没有。对于一个不太重的新项目，你又想尝试卷卷 vue3，我个人觉得或许是个不错的选择。</em></p> 
 <p>关于本文<br></p> 
 <h2>作者：Luin</h2> 
 <p>https://juejin.cn/post/7137967499202527239</p> 
 <h3>最后</h3> 
 <p style="text-align:left;">欢迎关注【前端瓶子君】✿✿ヽ(°▽°)ノ✿<br></p> 
 <p style="text-align:left;">回复「算法」，加入前端编程源码算法群，每日一道面试题（工作日），第二天瓶子君都会很认真的解答哟！<br></p> 
 <p style="text-align:left;">回复「交流」，吹吹水、聊聊技术、吐吐槽！</p> 
 <p style="text-align:left;">回复「阅读」，每日刷刷高质量好文！</p> 
 <p style="text-align:left;">如果这篇文章对你有帮助，「在看」是最大的支持</p> 
 <p style="text-align:center;"> 》》面试官也在看的算法资料《《<br></p> 
 <p style="text-align:right;">“在看和转发”就是最大的支持</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d4811340506d0908cd50d451dfc2b22/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器学习样本不平衡处理方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/afe996ca6c9ce5bc511ddadeb5940699/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">电脑在开机时出现了bootmenu</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>