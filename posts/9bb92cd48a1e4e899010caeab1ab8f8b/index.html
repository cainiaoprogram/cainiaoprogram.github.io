<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kafka学习之旅(六): Kafka生产者通信 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kafka学习之旅(六): Kafka生产者通信" />
<meta property="og:description" content="一 简介
由官网可以了解到Kafka 所有组件（生产者，消费者，broker）之间的通信协议使用的是TCP，而不是使用的是HTTP 或者其他的通讯协议。那为什么他要去选择TCP而不使用HTTP呢？其实这里面的原因有很多，个人觉得最主要的原因在于 TCP 和 HTTP 之间的区别。
从社区的角度来看，在开发客户端时，人们能够利用 TCP本身提供的一些高级功能，比如多路复用请求以及同时轮询多个连接的能力。
什么是多路复用呢简单的介绍一下就是两个或者多个数据流合并到底层单一的物理连接中TCP 的多路复用请求会在一条物理连接上创建若干个虚拟连接，每
个虚拟连接负责流转各自对应的数据流。其实严格来说，TCP 并不能多路复用，它只是提供可靠的消息交付语义保证，比如自动重传丢失的报文。更严谨地说，作为一个基于报文的协议，TCP 能够被用于多路复用连接场景的前提是，上层的应用协议（比如 HTTP）允许发送多条消息。
二 Kafka是如何打开TCP 通信的
在创建 KafkaProducer 实例时，生产者应用会在后台创建并启动一个名为 Sender 的线程，该 Sender 线程开始运行时首先会创建与 Broker 的连接
下面可以给出一个测试例子来证明一下：
public static void main(String[] args) { Map map=new HashMap&lt;String,String&gt;(); map.put(&#34;bootstrap.servers&#34;,&#34;localhost:9092&#34;); map.put(&#34;key.serializer&#34;, &#34;org.apache.kafka.common.serialization.StringSerializer&#34;); map.put(&#34;value.serializer&#34;, &#34;org.apache.kafka.common.serialization.StringSerializer&#34;); KafkaProducer kafkaProducer=new KafkaProducer(map); // ProducerRecord producerRecord=new ProducerRecord(&#34;test-topic&#34;,&#34;id&#34;,&#34;1&#34;); //kafkaProducer.send(producerRecord); //kafkaProducer.close(); } 下面给出一段日志:
[12:55:31:581] [DEBUG] - org.apache.kafka.clients.Metadata.update(Metadata.java:290) - Updated cluster metadata version 1 to Cluster(id = null, nodes = [localhost:9092 (id: -1 rack: null)], partitions = [], controller = null) [12:55:31:885] [DEBUG] - org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9bb92cd48a1e4e899010caeab1ab8f8b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-28T13:27:43+08:00" />
<meta property="article:modified_time" content="2019-07-28T13:27:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kafka学习之旅(六): Kafka生产者通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>一 简介</strong><br> 由官网可以了解到Kafka 所有组件（生产者，消费者，broker）之间的通信协议使用的是TCP，而不是使用的是HTTP 或者其他的通讯协议。那为什么他要去选择TCP而不使用HTTP呢？其实这里面的原因有很多，个人觉得最主要的原因在于 TCP 和 HTTP 之间的区别。<br> 从社区的角度来看，在开发客户端时，人们能够利用 TCP本身提供的一些高级功能，比如多路复用请求以及同时轮询多个连接的能力。<br> 什么是多路复用呢简单的介绍一下就是两个或者多个数据流合并到底层单一的物理连接中TCP 的多路复用请求会在一条物理连接上创建若干个虚拟连接，每<br> 个虚拟连接负责流转各自对应的数据流。其实严格来说，TCP 并不能多路复用，它只是提供可靠的消息交付语义保证，比如自动重传丢失的报文。更严谨地说，作为一个基于报文的协议，TCP 能够被用于多路复用连接场景的前提是，上层的应用协议（比如 HTTP）允许发送多条消息。</p> 
<p><strong>二 Kafka是如何打开TCP 通信的</strong><br> 在创建 KafkaProducer 实例时，生产者应用会在后台创建并启动一个名为 Sender 的线程，该 Sender 线程开始运行时首先会创建与 Broker 的连接<br> 下面可以给出一个测试例子来证明一下：</p> 
<pre><code>public static void main(String[] args) {
        Map map=new HashMap&lt;String,String&gt;();
        map.put("bootstrap.servers","localhost:9092");
        map.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
        map.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");
        KafkaProducer kafkaProducer=new KafkaProducer(map);
       // ProducerRecord producerRecord=new ProducerRecord("test-topic","id","1");
        //kafkaProducer.send(producerRecord);
        //kafkaProducer.close();
    }
</code></pre> 
<p>下面给出一段日志:</p> 
<pre><code>[12:55:31:581] [DEBUG] - org.apache.kafka.clients.Metadata.update(Metadata.java:290) - Updated cluster metadata version 1 to Cluster(id = null, nodes = [localhost:9092 (id: -1 rack: null)], partitions = [], controller = null)
[12:55:31:885] [DEBUG] - org.apache.kafka.clients.producer.KafkaProducer.&lt;init&gt;(KafkaProducer.java:426) - [Producer clientId=producer-1] Kafka producer started
</code></pre> 
<p>在日志中好像发现了一个问题在没有指定那个指定topic 情况下 生产者好像去连接了kafka 集群。如果不调用 send 方法，这个 Producer 都不知道给哪个主题发消息，它又怎么能知道连接哪个 Broker 呢？难不成它会连接 bootstrap.servers参数指定的所有 Broker 吗？嗯，是的，Java Producer 目前还真是这样设计的。<br> 我在这里稍微解释一下 bootstrap.servers 参数。它是Producer 的核心参数之一，指定了这个 Producer 启动时要连接的 Broker 地址。请注意，这里的“启动时”，代表的是 Producer 启动时会发起与这些 Broker 的连接。因此，如果你为这个参数指定了 1000 个 Broker 连接信息，那么很遗憾，你的 Producer 启动时会首先创建与这 1000个 Broker 的 TCP 连接。在实际使用过程中，我并不建议把集群中所有的 Broker 信息都配置到 bootstrap.servers 中，通常你指定 3～4 台就足以了。因为 Producer 一旦连接到集群中的任一台Broker，就能拿到整个集群的 Broker 信息，故没必要为bootstrap.servers 指定所有的 Broker。<br> TCP 连接是在创建KafkaProducer 实例时建立的。但！TCP 连接还可能在两个地方被创建：一个是在更新元数据后，另一个是在消息发送时。为什么说是可能？因为这两个地方并非总是创建 TCP 连接。当 Producer 更新了集群的元数据信息之后，如果发现与某些 Broker 当前没有连接，那么它就会创建一个 TCP 连接。同样地，当要发送消息时，Producer 发现尚不存在与目标 Broker 的连接，也会创建一个。</p> 
<p><strong>二 Kafka是如何关闭TCP 通信的</strong><br> 关闭的方式由两种一种是主动的关闭，一种是自动断开连接。<br> 第一种比较简单比如用户主动kill 或者调用close 方法。<br> 第二种是 Kafka 帮你关闭，这与 Producer <a href="http://xn--connections-x12sw25pf58c.max.idle.ms" rel="nofollow">端参数connections.max.idle.ms</a> 的值有关。默认情况下该参数值是 9 分钟，即如果在 9 分钟内没有任何请求通过某个TCP 连接，那么 Kafka 会主动帮你把该 TCP 连接关闭。用户可以在 Producer 端设置 connections.max.idle.ms=-1禁掉这种机制。一旦被设置成 -1，TCP 连接将成为永久长连接。当然这只是软件层面的“长连接”机制，由于 Kafka创建的这些 Socket 连接都开启了 keepalive，因此keepalive 探活机制还是会遵守的。</p> 
<p><strong>下面总结一下本篇</strong></p> 
<ol><li>KafkaProducer 实例创建时启动 Sender 线程，从而创建与 bootstrap.servers 中所有 Broker 的 TCP 连接。</li><li>KafkaProducer 实例首次更新元数据信息之后，还会再次创建与集群中所有 Broker 的 TCP 连接。</li><li>如果 Producer 端发送消息到某台 Broker 时发现没有与该 Broker 的 TCP 连接，那么也会立即创建连接。</li><li>如果设置 Producer 端 <a href="http://connections.max.idle.ms" rel="nofollow">connections.max.idle.ms</a> 参数大于 0，则步骤 1 中创建的 TCP 连接会被自动关闭；如果设置该参数 =-1，那么步骤 1 中创建的TCP 连接将无法被关闭，从而成为“僵尸”连接。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5890759fd09d1ada726fbf2df438da33/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">负载均衡种类及优缺点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/15183ad0baebe0eed8761f968515dd8b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CPU-IO-网络-内核参数调优</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>