<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue3 中使用 Vuex 和 Pinia 对比之 Vuex的用法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue3 中使用 Vuex 和 Pinia 对比之 Vuex的用法" />
<meta property="og:description" content="本文基于 Vue3 的 composition API 来展开 Vuex 和 Pinia 的用法比较
Pinia传送门
Vuex传送门
Vuex 状态管理的核心概念 状态- 驱动应用的数据源；视图 - 以声明方式将状态映射到视图；操作 - 响应在视图上的用户输入导致的状态变化 下面是源自Vuex 官网提供的，“单向数据流”的简单示意：
但是，我们的应用中遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：
多个视图依赖于同一个状态；来自不同的视图的行为需要变更同一个状态。 为了解决上述两个问题，Vuex 做了如下的优化，也是Vuex 的状态管理机制：
Vuex 把组件的共享状态抽取出来，以一个全局单例模式管理，在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在数的哪个位置，任何组件都能获取状态或者触发行为；Vuex 通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态之间的独立性。使我们的代码变得更结构化且更易维护。
Vuex 和单纯的全局对象的区别 Vuex 的核心就是 store（仓库），可以把它看成是一个容器，存储应用中大部分的状态（state），Vuex 和单纯的全局对象存在如下区别：
Vuex 的状态存储是响应式的。当Vue 组件从 store 中读取状态时，store 发生变化，那么相应的组件也会得到更新；你不能直接修改 store 中的状态，改变store 中的状态的唯一途径是调用 commit 触发 mutation，也就是说你的 Vue 组件中只写 commit ，不要直接调用 mutation 中的方法，这样的好处是可以方便的跟踪每一个状态的变化，有利于vuedevtool 调试 Vuex 的适用场景 适用于中大型的单页应用，如果你的应用足够简单，那么不建议使用 Vuex，一个简单的 store 模式就足够用了。
Vuex 的使用-最简单的实例 步骤一：安装 Vuex npm install vuex@next --save 或者使用 yarn: yarn add vuex@next --save 步骤二：创建一个 store 引用 Vuex 的官方demo" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a19cb88b13e03c41e04861fa116a3632/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T11:25:06+08:00" />
<meta property="article:modified_time" content="2024-01-12T11:25:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue3 中使用 Vuex 和 Pinia 对比之 Vuex的用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>本文基于 Vue3 的 composition API 来展开 Vuex 和 Pinia 的用法比较</p> 
</blockquote> 
<p><a href="https://pinia.web3doc.top/introduction.html" rel="nofollow">Pinia传送门</a><br> <a href="https://vuex.vuejs.org/zh/" rel="nofollow">Vuex传送门</a></p> 
<h2><a id="Vuex_5"></a>Vuex</h2> 
<h3><a id="_6"></a>状态管理的核心概念</h3> 
<ul><li>状态- 驱动应用的数据源；</li><li>视图 - 以声明方式将状态映射到视图；</li><li>操作 - 响应在视图上的用户输入导致的状态变化</li></ul> 
<p>下面是源自Vuex 官网提供的，“单向数据流”的简单示意：<br> <img src="https://images2.imgbox.com/9f/04/y9GsqL3M_o.png" alt="在这里插入图片描述"><br> 但是，我们的应用中遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p> 
<ol><li>多个视图依赖于同一个状态；</li><li>来自不同的视图的行为需要变更同一个状态。</li></ol> 
<p>为了解决上述两个问题，Vuex 做了如下的优化，也是Vuex 的状态管理机制：<br> <img src="https://images2.imgbox.com/04/2b/80NoWEsN_o.png" alt="在这里插入图片描述"><br> Vuex 把组件的共享状态抽取出来，以一个全局单例模式管理，在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在数的哪个位置，任何组件都能获取状态或者触发行为；Vuex 通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态之间的独立性。使我们的代码变得更结构化且更易维护。</p> 
<h3><a id="Vuex__20"></a>Vuex 和单纯的全局对象的区别</h3> 
<p>Vuex 的核心就是 store（仓库），可以把它看成是一个容器，存储应用中大部分的状态（state），Vuex 和单纯的全局对象存在如下区别：</p> 
<ol><li>Vuex 的状态存储是响应式的。当Vue 组件从 store 中读取状态时，store 发生变化，那么相应的组件也会得到更新；</li><li>你不能直接修改 store 中的状态，改变store 中的状态的唯一途径是调用 commit 触发 mutation，也就是说你的 Vue 组件中只写 commit ，不要直接调用 mutation 中的方法，这样的好处是可以方便的跟踪每一个状态的变化，有利于vuedevtool 调试</li></ol> 
<h3><a id="Vuex__24"></a>Vuex 的适用场景</h3> 
<p>适用于中大型的单页应用，如果你的应用足够简单，那么不建议使用 Vuex，一个简单的 store 模式就足够用了。</p> 
<h3><a id="Vuex__26"></a>Vuex 的使用-最简单的实例</h3> 
<h4><a id="_Vuex_27"></a>步骤一：安装 Vuex</h4> 
<pre><code class="prism language-shell"><span class="token function">npm</span> <span class="token function">install</span> vuex@next <span class="token parameter variable">--save</span>
或者使用 yarn:
<span class="token function">yarn</span> <span class="token function">add</span> vuex@next <span class="token parameter variable">--save</span>
</code></pre> 
<h4><a id="_store_33"></a>步骤二：创建一个 store</h4> 
<p>引用 Vuex 的官方demo</p> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> createStore <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>

<span class="token comment">// 创建一个新的 store 实例</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
  <span class="token function">state</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
      <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token comment">/* 根组件 */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 将 store 实例作为插件安装</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="Vue___state_58"></a>步骤三：在Vue 组件中的使用- 顺便了解一下 state</h4> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> useStore<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vuex"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">useStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//改变store 中某个状态的值,只需要</span>
store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token comment">//通过 commit 触发状态变更，入参传入 mutation 中的函数名称即可</span>

<span class="token comment">//获取store 中的某个状态的值</span>
<span class="token comment">//一般情况下我们使用计算属性来实现</span>
<span class="token keyword">const</span> myCount <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//需要先 import {computed} from vue </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接通过 store.state.某个状态名称 即可</span>
</code></pre> 
<p>注意：一定要使用 commit(‘mutation中的方法名’) 来改变 state 中的数据，不要通过store.state.count = 9 这种方式</p> 
<h3><a id="Getter_71"></a>Getter</h3> 
<p>关于state 想必通过上面的简单例子已经了解了。我们引出 getters 的概念：有时候我们需要从 store 中的 state 中的数据派生出一些状态，例如对列表进行过滤并计数功能，多个组件都要使用这个功能，如果在每个组件里都写一遍，肯定是冗余的，getters 则为我们解决了这个问题，它等效于 computed 可以任务是 store 的计算属性。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">todos</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">getters</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">doneTodos</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">todo</span> <span class="token operator">=&gt;</span> todo<span class="token punctuation">.</span>done<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//在组件中调用的方式跟 state 一样,可以通过访问属性的形式访问这些值：</span>
store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>doneTodos

</code></pre> 
<h3><a id="Mutation_91"></a>Mutation</h3> 
<p>上文反复提到，修改 Vuex 的 store 中的状态的唯一方法是 提交（commit）mutation。是因为Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型（type）和一个回调函数（handler）。这个回调函数就是我们实际进行状态更改的地方，并且它接受 state 作为第一个参数，第二个参数可以传入自己需要传入的数据。<br> 我们再来回顾一下上文 <strong>步骤二</strong>中的这个片段：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 变更状态</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="Action_107"></a>Action</h3> 
<p>上面的 Mutation 和 State 看上去已经能够满足我们对 store 的使用了啊，为什么会有 Action 这个东西呢？原因在于 Vuex 把 Mutation 中的函数设计为了 同步函数，主要是出于 devtools 的考虑。那这样的话，你可以理解 Mutation 中是不能做接口请求回调了。于是Action 就来了，它的出现主要是帮助我们处理异步操作，根据异步回调的结果然后再通过 commit 来调用 mutation 去修改想要修改的状态。<br> 注意：<strong>Action提交的是mutation，而不是直接更改状态</strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters</p> 
<h4><a id="Action__Mutation__128"></a>总结Action 和 Mutation 的区别：</h4> 
<ul><li>Action 提交的是 mutation，而不是直接更改状态；</li><li>Action 可以包含任意异步操作</li></ul> 
<p>关于 Pinia 见下一篇文章：<a href="https://blog.csdn.net/u012764358/article/details/135544427?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22135544427%22,%22source%22:%22u012764358%22%7D">Vue3 中使用 Vuex 和 Pinia 对比之 Pinia的用法</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3241fea36929f84107227287009316d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">每日 python 面试10题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a73e75f12e9069786308d06795e1ec48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">stable diffusion代码学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>