<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>BMC通过PECI接口获取CPU温度实现方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="BMC通过PECI接口获取CPU温度实现方法" />
<meta property="og:description" content="本文转载于网络，侵权删。
PECI是用于监测CPU及芯片组温度的一线总线(one-wirebus)，全称是Platform Environment Control Interface。它最主要的应用是监测CPU温度，最新版本的PECI接口还包括一些其他的功能。
1 Intel Processor的温控机制 在CPU中，通常每个CPU核心都有一个数字温度传感器。在PC平台下，处理器可以通过MSR(Mode specific registers)获得处理器自身的温度、调节风扇转速度，从而实现温度控制。在服务器平台下，温度控制通常是由BMC来做的，业务CPU本身没有办法控制机框的风扇转速度。BMC直接或间接通过PECI总线获取到CPU核心温度，再根据所有温度值调整风扇转速。
MSR方式读取CPU温度读取到的是即时温度，PECI方式读取到的是256ms时间窗内的平均温度。MSR方式是需要CPU处理C0状态才能读取。PECI方式在C0~C6均可以使用。
图表1 PECI接中的连接方式
Intel Pentium M 开始在处理器中引入DTS（数字温度传感器）。温度传感器通常是每个CPU核心一个。
图表2 Intel温控组件
1.1 TM1 为了保护CPU不会在过热时被烧坏，从Pentium4开始，处理器中又加入了一个温度监示器Thermal Monitor 1，简称TM1。TM1会监示数字温度传感器的读数，当读数高于阈值Tjmax时，TM1会调节处理器时钟的占空比，以降低功耗，降低温度。这里所谓的调节时钟占空比与传统意义上的时钟占空比不同，这里调节的是时钟信号的开闭时间比例，比如说，它会在某一段时间内，37.5%的时间打开CPU时钟，让CPU工作，另62.5%的时间关闭CPU时钟，让CPU停止工作以降低功耗和温度。
Figure 1 TM1调整CPU时钟占空比
1.2 TM2 TM2是Pentium M时引入的，它提供了另一种降低CPU温度的办法。在CPU某个核心的温度超过Tjmax时，它会尝试降低时钟频率和供电电压来降低功耗和温度。TM1和TM2是两个单独的机制，或以分别启用和禁用。Intel推荐两个机制同时使用。它们的启用和禁用是通过BIOS设置IA32_MISC_ENABLE这个模式寄存器的第3、13位来实现的。BIOS打开这两个机制后，OS和用户程序不可关闭。
1.3 温度阈值 Tjmax是我们所知的第一个阈值，当CPU上任意一个核心的温度达到这个阈值时，CPU会产生一个PROCHOT#信号（processor hot）。该信号可触发TM1和TM2。处理器时会通过调节时钟占空比、降低时钟频率和供电电压的方式来降低功耗和温度。产生PROCHOT#信号的同时，温度监示器还会产生一个中断给CPU，其中断向量号通过LAPIC和LVT来设置。模式寄存器IA32_THERM_INTERRUPT有两个位用于高温中断使能（温度超过Tjmax时产生中断）和低温中断使能（温度回到低于Tjmax的范围时产生中断）。
PROCHOT#通过CPU的一个引脚拉出，并且可以连接在外设上，由外设来发生这个信号。比如说一个系统中有另一个设备的温度超过阈值，它可以拉低使能这个信号，从而使CPU也一起降温，从而降低机箱内的温度，制造一个更好的散热环境。
如果TM1和TM2启动后温度没能降低下来，并且继续升高到可能造成CPU物理损坏的温度时，核心会触发THERMTRIP#信号，并且关闭CPU电源。
CPU硬件实现的温度控制机制是用于CPU自我保存的温控机制，当这些机制不足以降温时，CPU会断电，从而造成系统突然掉电，造成数据损失。因而一般要求BMC在要以一定的周期读取CPU核心温度，根据温度调整风扇转速，并且当温度超过Tjmax-10时，让风扇全速转动。
2 相关MSR 2.1 IA32_THERM_INTERRUPT IA32_THERM_INTERRUPT寄存的地址为0x19B。BIOS通过IA32_THERM_INTERRUPT模式寄存器使能温度相关的中断，其各字段定义如下：
表格 1 IA32_THERM_INTERRUPT 0x19B
位
描述
0
High temperature interrupt enable
1
Low temperature interrupt enable
2
PROCHOT# interrupt enable
3
FORCEPR# interrupt enable
4" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1b537606a6359d5d28a86cf5a0e3393b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-20T10:47:02+08:00" />
<meta property="article:modified_time" content="2019-03-20T10:47:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">BMC通过PECI接口获取CPU温度实现方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文转载于网络，侵权删。</p> 
<p>PECI是用于监测CPU及芯片组温度的一线总线(one-wirebus)，全称是Platform Environment Control Interface。它最主要的应用是监测CPU温度，最新版本的PECI接口还包括一些其他的功能。</p> 
<h2><a name="t0"></a>1 Intel Processor的温控机制</h2> 
<p>在CPU中，通常每个CPU核心都有一个数字温度传感器。在PC平台下，处理器可以通过MSR(Mode specific registers)获得处理器自身的温度、调节风扇转速度，从而实现温度控制。在<a href="https://www.baidu.com/s?wd=%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" rel="nofollow">服务器</a>平台下，温度控制通常是由BMC来做的，业务CPU本身没有办法控制机框的风扇转速度。BMC直接或间接通过PECI总线获取到CPU核心温度，再根据所有温度值调整风扇转速。</p> 
<p>MSR方式读取CPU温度读取到的是即时温度，PECI方式读取到的是256ms时间窗内的平均温度。MSR方式是需要CPU处理C0状态才能读取。PECI方式在C0~C6均可以使用。</p> 
<p> <img alt="" class="has" src="https://images2.imgbox.com/15/a5/qbP92Qyq_o.png"></p> 
<p> </p> 
<p>图表1 PECI接中的连接方式</p> 
<p>Intel Pentium M 开始在处理器中引入DTS（数字温度传感器）。温度传感器通常是每个CPU核心一个。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/dd/fe/P5yr0yAt_o.png"></p> 
<p> </p> 
<p>图表2 Intel温控组件</p> 
<h3><a name="t1"></a>1.1 TM1</h3> 
<p>为了保护CPU不会在过热时被烧坏，从Pentium4开始，处理器中又加入了一个温度监示器Thermal Monitor 1，简称TM1。TM1会监示数字温度传感器的读数，当读数高于阈值Tjmax时，TM1会调节处理器时钟的占空比，以降低功耗，降低温度。这里所谓的调节<strong>时钟占空比</strong>与传统意义上的时钟占空比不同，这里调节的是时钟信号的开闭时间比例，比如说，它会在某一段时间内，37.5%的时间打开CPU时钟，让CPU工作，另62.5%的时间关闭CPU时钟，让CPU停止工作以降低功耗和温度。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/05/1d/v1kWN872_o.png"></p> 
<p> </p> 
<p>Figure 1 TM1调整CPU时钟占空比</p> 
<h3><a name="t2"></a>1.2 TM2</h3> 
<p>TM2是Pentium M时引入的，它提供了另一种降低CPU温度的办法。在CPU某个核心的温度超过Tjmax时，它会尝试降低时钟频率和供电电压来降低功耗和温度。TM1和TM2是两个单独的机制，或以分别启用和禁用。Intel推荐两个机制同时使用。它们的启用和禁用是通过BIOS设置IA32_MISC_ENABLE这个模式寄存器的第3、13位来实现的。BIOS打开这两个机制后，OS和用户程序不可关闭。</p> 
<p> </p> 
<h3><a name="t3"></a>1.3 温度阈值</h3> 
<p>Tjmax是我们所知的第一个阈值，当CPU上任意一个核心的温度达到这个阈值时，CPU会产生一个PROCHOT#信号（processor hot）。该信号可触发TM1和TM2。处理器时会通过调节时钟占空比、降低时钟频率和供电电压的方式来降低功耗和温度。产生PROCHOT#信号的同时，温度监示器还会产生一个中断给CPU，其中断向量号通过LAPIC和LVT来设置。模式寄存器IA32_THERM_INTERRUPT有两个位用于高温中断使能（温度超过Tjmax时产生中断）和低温中断使能（温度回到低于Tjmax的范围时产生中断）。</p> 
<p>PROCHOT#通过CPU的一个引脚拉出，并且可以连接在外设上，由外设来发生这个信号。比如说一个系统中有另一个设备的温度超过阈值，它可以拉低使能这个信号，从而使CPU也一起降温，从而降低机箱内的温度，制造一个更好的散热环境。</p> 
<p>如果TM1和TM2启动后温度没能降低下来，并且继续升高到可能造成CPU物理损坏的温度时，核心会触发THERMTRIP#信号，并且关闭CPU电源。</p> 
<p>CPU硬件实现的温度控制机制是用于CPU自我保存的温控机制，当这些机制不足以降温时，CPU会断电，从而造成系统突然掉电，造成数据损失。因而一般要求BMC在要以一定的周期读取CPU核心温度，根据温度调整风扇转速，并且当温度超过Tjmax-10时，让风扇全速转动。</p> 
<h2><a name="t4"></a>2 相关MSR</h2> 
<h3><a name="t5"></a>2.1  IA32_THERM_INTERRUPT</h3> 
<p>IA32_THERM_INTERRUPT寄存的地址为0x19B。BIOS通过IA32_THERM_INTERRUPT模式寄存器使能温度相关的中断，其各字段定义如下：</p> 
<p>表格 1 IA32_THERM_INTERRUPT 0x19B</p> 
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;"> <p>位</p> </td><td style="vertical-align:top;"> <p>描述</p> </td></tr><tr><td style="vertical-align:top;"> <p>0</p> </td><td style="vertical-align:top;"> <p>High temperature interrupt enable</p> </td></tr><tr><td style="vertical-align:top;"> <p>1</p> </td><td style="vertical-align:top;"> <p>Low temperature interrupt enable</p> </td></tr><tr><td style="vertical-align:top;"> <p>2</p> </td><td style="vertical-align:top;"> <p>PROCHOT# interrupt enable</p> </td></tr><tr><td style="vertical-align:top;"> <p>3</p> </td><td style="vertical-align:top;"> <p>FORCEPR# interrupt enable</p> </td></tr><tr><td style="vertical-align:top;"> <p>4</p> </td><td style="vertical-align:top;"> <p>Critical Temperature interrupt enable</p> </td></tr><tr><td style="vertical-align:top;"> <p>7:5</p> </td><td style="vertical-align:top;"> <p>reserved</p> </td></tr><tr><td style="vertical-align:top;"> <p>14:8</p> </td><td style="vertical-align:top;"> <p>Threshold 1 value</p> </td></tr><tr><td style="vertical-align:top;"> <p>15</p> </td><td style="vertical-align:top;"> <p>Threshold 1 int enable</p> </td></tr><tr><td style="vertical-align:top;"> <p>22:16</p> </td><td style="vertical-align:top;"> <p>Threshold 2 value</p> </td></tr><tr><td style="vertical-align:top;"> <p>23</p> </td><td style="vertical-align:top;"> <p>Threshold 2 int enable</p> </td></tr><tr><td style="vertical-align:top;"> <p>63:24</p> </td><td style="vertical-align:top;"> <p>reserved</p> </td></tr></tbody></table> 
<p> </p> 
<p>在一个实际系统读到的该寄存器的值为：</p> 
<p>sudo modprobe msr</p> 
<p>sudo rdmsr –p 0 0x19B</p> 
<p>3</p> 
<p> </p> 
<h3><a name="t6"></a>2.2  IA32_TEMPERATURE_TARGET</h3> 
<p>IA32_TEMPERATURE_TARGET模式寄存器的地址为0x1A2。该模式寄存器是只读的。</p> 
<p>表格 2 IA32_TEMPERATURE_TARGET模式寄存器</p> 
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;"> <p>位</p> </td><td style="vertical-align:top;"> <p>描述</p> </td></tr><tr><td style="vertical-align:top;"> <p>23:16</p> </td><td style="vertical-align:top;"> <p>温度目标，单为是<a href="https://www.baidu.com/s?wd=%E6%91%84%E6%B0%8F%E5%BA%A6&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" rel="nofollow">摄氏度</a>，当达到这个温度时触发TM1和TM2，产生PROCHOT#信号。</p> </td></tr></tbody></table> 
<p>在一个实际系统读到的该寄存器的值为：</p> 
<p>sudo modprobe msr</p> 
<p>sudo rdmsr –p 0 0x1A2</p> 
<p>0x5B08</p> 
<p>0x5B=91摄氏度</p> 
<p> </p> 
<p>嵌入汇编方式读取MSR：</p> 
<p>__asm____volatile__(“movl $0x1A2, %%ecx\n\trdmsr\n\t”)</p> 
<h2><a name="t7"></a>3 PECI接口</h2> 
<p>BMC获取CPU核心温度有两种途径：（1）通过PECI总线直接从CPU上获取温度数据，（2）通过IPMI协议从南桥上的ME上获取CPU核心温度。在途径（2）的情况下，ME需要通过PECI接口从CPU上获取温度。由于PECI的一线总线是intel的私有总线协议，很多BMC厂商并没有办法集成支持PECI接口协议的硬件，因而途径（2）是获取CPU核心温度的主流途径。</p> 
<h3><a name="t8"></a>3.1 PECI规范</h3> 
<p>PECI是一个私有的协议，不得到Intel授权无从得知协议的细节。PECI规范到现在有三个主要版本：1.1、2.0和3.0。PECI 1.1支持最简单的温度监示，PECI2.0则支持更多的如读取MSR等特性，PECI 3.0进一步支持PCIe总线配置空间的读取。</p> 
<p>表格 3 PECI 1.1和2.0比较</p> 
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;"> <p>版本</p> </td><td style="vertical-align:top;"> <p>1.1</p> </td><td style="vertical-align:top;"> <p>2.0</p> </td></tr><tr><td rowspan="2" style="vertical-align:top;"> <p>特性</p> </td><td style="vertical-align:top;"> <p>温度监示</p> <p>Ping()</p> <p>GetTemp()</p> <p>GetDib()</p> </td><td style="vertical-align:top;"> <p>温度监示</p> <p>Ping()</p> <p>GetTemp()</p> <p>GetDib()</p> </td></tr><tr><td style="vertical-align:top;"> <p> </p> </td><td style="vertical-align:top;"> <p>访问CPU内存</p> <p>BIST</p> <p>Memory throttling相关</p> </td></tr></tbody></table> 
<p>下图是PECI 3.0支持的命令列表：</p> 
<p>表格 4 PECI 3.0支持的命令列表</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/b8/a1/qjgznmU3_o.png"></p> 
<p> </p> 
<p>现代服务器系统中，BMC通常不直接使用PECI接口，而是通过南桥上的ManagementEngine来间接使用PECI接口。Management Engine是南桥上的一个<a href="http://lib.csdn.net/base/embeddeddevelopment" rel="nofollow">嵌入式</a>微控制器，它可以通过南桥上的PECI主控器访问CPU上的PECI从设备。同时，ME还实现了一些IPMI命令，可以让BMC通过SMLink间接使用这个PECI主控制器。这样的系统<a href="http://lib.csdn.net/base/architecture" rel="nofollow">架构</a>如下图所</p> 
<p>示：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/53/df/dZXdmd3I_o.png"></p> 
<p>图表 5 南桥做PECI Proxy</p> 
<p> </p> 
<p> </p> 
<p>所有的IPMI命令可以参考《IntelIntelligent Power Node Manager 2.0 External Interface Specification》的2.9节： IPMI OEMPECI Proxy Commands。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/89451a2748cd645f6174eeb5271a6657/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux各文件夹的结构说明及用途介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f48eacdb1cf8062bad8b7c26de2f6f32/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图像傅里叶变换的幅度谱、相位谱以及双谱重构原图像</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>