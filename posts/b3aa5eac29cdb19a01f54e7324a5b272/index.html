<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>NAT详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="NAT详解" />
<meta property="og:description" content="文章目录 为什么出现了NATNAT定义三种NAT技术静态NAT动态NATPAT(port address Translation） SNAT和DNATNetfilter报文流向内核中数据包的传输过程SNATDNAT 为什么出现了NAT IP地址只有32位，最多只有42.9亿个地址，还要去掉保留地址、组播地址，能用的地址只有36亿左右，但是当下有数以万亿的主机，没有这么多IP地址怎么办，后面有了IPv6，但是当下IPv4还是主流，利用IPv4怎么满足这么多主机的IP地址呢？答案就是NAT，NAT技术使公司、机构以及个人产生以及局域网，然后在各个局域网的边界WAN端口使用一个或多个公网的IPv4进行一对多转换
NAT使用基于session的转换规则
TCP/UDP ：私有Host的Ipv4 &#43; port &lt;======&gt; NAT公网的Ipv4 &#43; port
ICMP ：私有Host的Ipv4 &#43; sessionID &lt;======&gt; NAT公网的Ipv4 &#43; sessionID
NAT定义 NAT是 Network Address Translation 网络地址转换的缩写。
NAT是将私有IP地址通过边界路由转换成外网IP地址，在边界路由的NAT地址转换表记录下这个转换映射记录，当外部数据返回时，路由使用NAT技术查询NAT转换表，再将目标地址替换成内网用户IP地址。
RFC1918规定了三块专有的地址，作为私有的内部组网使用：
A类：10.0.0.0—10.255.255.255 10.0.0.0/8
B类：172.16.0.0—172.31.255.255 172.16.0.0/12
C类：192.168.0.0—192.168.255.255 192.168.0.0/16
这三块私有地址本身是可路由的，只是公网上的路由器不会转发这三块私有地址的流量；当一个公司内部配置了这些私有地址后，内部的计算机在和外网通信时，公司的边界路由会通过NAT或者PAT技术，将内部的私有地址转换成外网IP，外部看到的源地址是公司边界路由转换过的公网IP地址，这在某种意义上也增加了内部网络的安全性。
三种NAT技术 假设一种场景，公司对外的有两个公网IP地址是 191.4.4.1/191.4.4.2，有两台主机A和B，局域网地址分别是192.168.1.2和192.168.1.3
静态NAT 静态NAT就是一对一映射，内部有多少私有地址需要和外部通信，就要配置多少外网IP地址与其对应，并不节省外网IP，所以一般不用
NAT静态映射表
动态NAT 动态NAT是在路由器上配置一个外网IP地址池，当内部有计算机需要和外部通信时，就从地址池里动态的取出一个外网IP，并将他们的对应关系绑定到NAT表中，通信结束后，这个外网IP才被释放，可供其他内部IP地址转换使用，这个DHCP租约IP有相似之处。
NAT动态映射表
PAT(port address Translation） 端口地址转换，也叫端口地址复用)
这是最常用的NAT技术，也是IPv4能够维持到今天的最重要的原因之一，它提供了一种多对一的方式，对多个内网IP地址，边界路由可以给他们分配一个外网IP，利用这个外网IP的不同端口和外部进行通信。
PAT映射表
SNAT和DNAT Netfilter 在linux操作系统中，Netfilter组件是集成在linux内核中扩展各种网络服务的结构化底层框架，在内核级提供防火墙功能。内核中选取五个位置放了五个hook(勾子) function(INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING)，而这五个hook function向用户开放，用户可以通过一个命令工具（iptables）向其写入规则。
报文流向 流入本机：PREROUTING --&gt; INPUT–&gt;用户空间进程
流出本机：用户空间进程–&gt;OUTPUT–&gt; POSTROUTING
转发：PREROUTING --&gt; FORWARD --&gt; POSTROUTING" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b3aa5eac29cdb19a01f54e7324a5b272/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-19T08:56:51+08:00" />
<meta property="article:modified_time" content="2023-12-19T08:56:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">NAT详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#NAT_1" rel="nofollow">为什么出现了NAT</a></li><li><a href="#NAT_11" rel="nofollow">NAT定义</a></li><li><a href="#NAT_23" rel="nofollow">三种NAT技术</a></li><li><ul><li><a href="#NAT_25" rel="nofollow">静态NAT</a></li><li><a href="#NAT_32" rel="nofollow">动态NAT</a></li><li><a href="#PATport_address_Translation_39" rel="nofollow">PAT(port address Translation）</a></li></ul> 
  </li><li><a href="#SNATDNAT_48" rel="nofollow">SNAT和DNAT</a></li><li><ul><li><a href="#Netfilter_49" rel="nofollow">Netfilter</a></li><li><a href="#_52" rel="nofollow">报文流向</a></li><li><a href="#_56" rel="nofollow">内核中数据包的传输过程</a></li><li><a href="#SNAT_67" rel="nofollow">SNAT</a></li><li><a href="#DNAT_75" rel="nofollow">DNAT</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="NAT_1"></a>为什么出现了NAT</h2> 
<p>IP地址只有32位，最多只有42.9亿个地址，还要去掉保留地址、组播地址，能用的地址只有36亿左右，但是当下有数以万亿的主机，没有这么多IP地址怎么办，后面有了IPv6，但是当下IPv4还是主流，利用IPv4怎么满足这么多主机的IP地址呢？答案就是NAT，NAT技术使公司、机构以及个人产生以及局域网，然后在各个局域网的边界WAN端口使用一个或多个公网的IPv4进行一对多转换</p> 
<p>NAT使用基于session的转换规则</p> 
<p>TCP/UDP ：私有Host的Ipv4 + port &lt;======&gt; NAT公网的Ipv4 + port</p> 
<p>ICMP ：私有Host的Ipv4 + sessionID &lt;======&gt; NAT公网的Ipv4 + sessionID</p> 
<h2><a id="NAT_11"></a>NAT定义</h2> 
<p>NAT是 Network Address Translation 网络地址转换的缩写。<br> NAT是将私有IP地址通过边界路由转换成外网IP地址，在边界路由的NAT地址转换表记录下这个转换映射记录，当外部数据返回时，路由使用NAT技术查询NAT转换表，再将目标地址替换成内网用户IP地址。</p> 
<p>RFC1918规定了三块专有的地址，作为私有的内部组网使用：</p> 
<p>A类：10.0.0.0—10.255.255.255 10.0.0.0/8<br> B类：172.16.0.0—172.31.255.255 172.16.0.0/12<br> C类：192.168.0.0—192.168.255.255 192.168.0.0/16<br> 这三块私有地址本身是可路由的，只是公网上的路由器不会转发这三块私有地址的流量；当一个公司内部配置了这些私有地址后，内部的计算机在和外网通信时，公司的边界路由会通过NAT或者PAT技术，将内部的私有地址转换成外网IP，外部看到的源地址是公司边界路由转换过的公网IP地址，这在某种意义上也增加了内部网络的安全性。</p> 
<h2><a id="NAT_23"></a>三种NAT技术</h2> 
<p>假设一种场景，公司对外的有两个公网IP地址是 191.4.4.1/191.4.4.2，有两台主机A和B，局域网地址分别是192.168.1.2和192.168.1.3</p> 
<h3><a id="NAT_25"></a>静态NAT</h3> 
<p>静态NAT就是一对一映射，内部有多少私有地址需要和外部通信，就要配置多少外网IP地址与其对应，并不节省外网IP，所以一般不用</p> 
<p>NAT静态映射表<br> <img src="https://images2.imgbox.com/69/a9/90nLYWqp_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="NAT_32"></a>动态NAT</h3> 
<p>动态NAT是在路由器上配置一个外网IP地址池，当内部有计算机需要和外部通信时，就从地址池里动态的取出一个外网IP，并将他们的对应关系绑定到NAT表中，通信结束后，这个外网IP才被释放，可供其他内部IP地址转换使用，这个DHCP租约IP有相似之处。</p> 
<p>NAT动态映射表<br> <img src="https://images2.imgbox.com/04/19/gJv9bCAj_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="PATport_address_Translation_39"></a>PAT(port address Translation）</h3> 
<p>端口地址转换，也叫端口地址复用)</p> 
<p>这是最常用的NAT技术，也是IPv4能够维持到今天的最重要的原因之一，它提供了一种多对一的方式，对多个内网IP地址，边界路由可以给他们分配一个外网IP，利用这个外网IP的不同端口和外部进行通信。</p> 
<p>PAT映射表<br> <img src="https://images2.imgbox.com/7d/30/0vcmTrcY_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="SNATDNAT_48"></a>SNAT和DNAT</h2> 
<h3><a id="Netfilter_49"></a>Netfilter</h3> 
<p>在linux操作系统中，Netfilter组件是集成在linux内核中扩展各种网络服务的结构化底层框架，在内核级提供防火墙功能。内核中选取五个位置放了五个hook(勾子) function(INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING)，而这五个hook function向用户开放，用户可以通过一个命令工具（iptables）向其写入规则。<br> <img src="https://images2.imgbox.com/54/33/J4SVdx91_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_52"></a>报文流向</h3> 
<p>流入本机：PREROUTING --&gt; INPUT–&gt;用户空间进程<br> 流出本机：用户空间进程–&gt;OUTPUT–&gt; POSTROUTING<br> 转发：PREROUTING --&gt; FORWARD --&gt; POSTROUTING</p> 
<h3><a id="_56"></a>内核中数据包的传输过程</h3> 
<p>（1）当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去<br> （2）如果数据包就是进入本机的，数据包就会到达INPUT链。经INPUT链检查后，数据包被发往本地进程。本地进程进行相应处理后发送响应数据包，数据包经过OUTPUT链，然后到达POSTROUTING链输出；如果数据包是要转发出去的，且内核允许转发，数据包就会向右移动，经过FORWARD链，然后到达POSTROUTING链输出。</p> 
<p>SNAT，DNAT，MASQUERADE都是NAT<br> MASQUERADE是SNAT的一个特例<br> SNAT是指在数据包从网卡发送出去的时候，把数据包中的源地址部分替换为指定的IP，这样，接收方就认为数据包的来源是被替换的那个IP的主机<br> MASQUERADE是用发送数据的网卡上的IP来替换源IP，因此，对于那些IP不固定的场合，比如拨号网络或者通过dhcp分配IP的情况下，就得用MASQUERADE<br> DNAT，就是指数据包从网卡发送出去的时候，修改数据包中的目的IP，表现为如果你想访问A，可是因为网关做了DNAT，把所有访问A的数据包的目的IP全部修改为B，那么，你实际上访问的是B</p> 
<p>因为，路由是按照目的地址来选择的，因此，DNAT是在PREROUTING链上来进行的，而SNAT是在数据包发送出去的时候才进行，因此是在POSTROUTING链上进行的</p> 
<h3><a id="SNAT_67"></a>SNAT</h3> 
<p>企业内部的主机A想访问互联网上的主机C，首先将请求数据包（源：ipA，目标：ipC）发送到防火墙所在主机B，B收到后将数据包源地址改为本机公网网卡的ip（源：ipB，目标：ipC），然后经互联网发送给C；C收到后将回应包（源：ipC，目标：ipB）转发给C的路由器，经互联网将回应包转发给B，B收到回应包后修改其目的地址，即回应包改为（源：ipB，目标：ipA）然后将数据包转发给A。 在这个过程中，修改了请求报文的源地址，叫做SNAT（source NAT POSTROUTING），用于局域网访问互联网。 不能在防火墙B的prerouting链上设置转换源地址的防火墙策略，因为若在B的prerouting链上设置转换源地址的防火墙策略，此时还未检查路由表，还不知道要到达数据包中目标主机需经过本机的哪个网卡接口，即还不知道需将源地址替换为哪个公网网卡的ip，需在postrouting设置转换源地址的防火墙策略。<br> 在C看来，是B在访问C，而不是A，但是实际上是A在访问C，数据包是从A发往C的，只是经过B时将源地址改为B，但实际上是A发过来的数据包<br> 若企业内部有A、C、D等主机都要访问互联网，<br> A 请求数据包源地址 ip1端口12345 替换为 B公网ip端口12345<br> C请求数据包源地址 ip2端口23456 替换为 B公网ip端口23456<br> D 请求数据包源地址 ip3端口23456 替换为 B公网ip端口24414<br> SNAT中，将请求数据包的源地址替换时，端口一般不替换，即A用什么端口B就用什么端口，但若产生冲突，即C、D使用同一随机端口，B可以将端口替换为其他空闲端口，否则当C或D的响应包到达时，B就不知道替换为C还是D了，端口和IP都进行修改，称为PNAT。</p> 
<h3><a id="DNAT_75"></a>DNAT</h3> 
<p>互联网主机C想访问企业内部的web服务器A，但A的地址是私有地址，无法直接访问。此时，C可以访问防火墙的公网地址，C的请求数据包（源：ipC，目标：ipB）到达防火墙B后，在B的prerouting上将请求数据包的目标地址进行修改，并将数据包（源：ipC，目标：ipA）发送给A。A收到后进行回复发送响应包（源：ipA，目的ipC）到防火墙，防火墙收到后对数据包源地址进行修改，并将响应包（源：ipB，目标：ipC）给C。利用这种机制可以将企业内部的服务发布到互联网。<br> 在这个过程中，修改了请求报文的目标地址，叫做DNAT（destination NAT POSTROUTING），用于互联网访问局域网。 必须在防火墙的prerouting上设置修改目标地址的防火墙策略，因为若不在此处修改，请求数据包通过prerouting和路由表后，由于目标主机是本机，就会将数据包发往input，进而被发往本地进程</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/48425b45e826fb244a5a74832f7e2284/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安装python虚拟环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27584a7e225bc33f363699472731f32a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pycharm</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>