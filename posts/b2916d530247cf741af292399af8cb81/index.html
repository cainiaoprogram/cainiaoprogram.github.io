<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【图论】图的深度优先遍历与广度优先遍历（图文讲解） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【图论】图的深度优先遍历与广度优先遍历（图文讲解）" />
<meta property="og:description" content="一、前言 看懂这篇博客你需要提前知道这些知识点
1.C&#43;&#43;链式前向星存图；
2.dfs和bfs是什么以及基本概念；
3.C&#43;&#43;STL中的queue，队列数据结构的简单知识点；
4.有关图的一些简单的概念；
图论是一个很重要的知识块，在学习如何遍历图之前，我们首先当然得知道要怎样去建图。在下面的内容里，我们将使用链式前向星来建图，如果对建图有什么问题的话可以移步这篇博客来学习。
链式前向星
在了解建图的方法后，我们当然要开始考虑如何遍历图中的每一个点，在这里，我们将使用两种最基础的遍历方式-----深度优先搜索（DFS）与广度优先搜索（BFS）
首先，我们假设已经把一个有向图建好了，其实无向图就是特殊的有向图，就不单独说明了。
二、深度优先搜索遍历（DFS） 概念： 如果在之前已经学习了深度优先搜索的话其实就不用多解释可以直接看例题和代码了，但在这里还是要简单讲解一下。所谓DFS，就是从起点开始，找准一个方向直到走不了为止，然后再原路返回，再找到一个能走的地方继续走的思路。如图
点的遍历顺序为：1，2，4，7，8，5，3，6；
这就是深度优先搜索的思路与在树中的实现。
例题与代码实现：Acwing 树的重心
给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。 请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。 重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。 输入格式 第一行包含整数 n，表示树的结点数。 接下来 n−1 行，每行包含两个整数 a 和 b，表示点 a 和点 b 之间存在一条边。 输出格式 输出一个整数 m，表示将重心删除后，剩余各个连通块中点数的最大值。 数据范围 1≤n≤1e5 输入样例 9 1 2 1 7 1 4 2 8 2 5 4 3 3 9 4 6 输出样例： 4 其实这道题对于刚刚学图论的人而言好像有一点难了，因为这一题不但考到了图的遍历，还需要知道树形dp的处理与状态的计算，如果这道题能懂，那么就表示完全搞定了dfs遍历图的知识点了。先附上ac代码吧，代码里会有解释。
#include&lt;iostream&gt; #include&lt;iomanip&gt; #include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;bitset&gt; #include&lt;ctime&gt; #include&lt;cstring&gt; #include&lt;list&gt; #define ll long long #define ull unsigned long long #define INF 0x3f3f3f3f #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 1e6 &#43; 7; int n; int ne[N], h[N], e[N], id = 1; //链式前向星 bool ch[N]; int ans=INF; void add(int a, int b) { e[id] = b; ne[id] = h[a]; h[a] = id&#43;&#43;; } int dfs(int x) //x是根节点的编号 { ch[x] = true; //标记这个点被遍历过了，避免死循环 int sum = 1; //以x为根的树的节点数量 int res = 0; //所有子树最长的子树的长度 int te = 0; for (int i = h[x]; i !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b2916d530247cf741af292399af8cb81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-24T15:14:46+08:00" />
<meta property="article:modified_time" content="2021-07-24T15:14:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【图论】图的深度优先遍历与广度优先遍历（图文讲解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、前言</h3> 
<p>看懂这篇博客你需要提前知道这些知识点<br> 1.C++链式前向星存图；<br> 2.dfs和bfs是什么以及基本概念；<br> 3.C++STL中的queue，队列数据结构的简单知识点；<br> 4.有关图的一些简单的概念；</p> 
<p>图论是一个很重要的知识块，在学习如何遍历图之前，我们首先当然得知道要怎样去建图。在下面的内容里，我们将使用链式前向星来建图，如果对建图有什么问题的话可以移步这篇博客来学习。<br> <a href="https://blog.csdn.net/qq_49688477/article/details/114799347?spm=1001.2014.3001.5501">链式前向星</a><br> 在了解建图的方法后，我们当然要开始考虑如何遍历图中的每一个点，在这里，我们将使用两种最基础的遍历方式-----深度优先搜索（DFS）与广度优先搜索（BFS）</p> 
<p>首先，我们假设已经把一个有向图建好了，其实无向图就是特殊的有向图，就不单独说明了。<br> <img src="https://images2.imgbox.com/39/5b/HjgyOoWR_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="DFS_13"></a>二、深度优先搜索遍历（DFS）</h3> 
<p><strong>概念：</strong> 如果在之前已经学习了深度优先搜索的话其实就不用多解释可以直接看例题和代码了，但在这里还是要简单讲解一下。所谓DFS，就是从起点开始，找准一个方向直到走不了为止，然后再原路返回，再找到一个能走的地方继续走的思路。如图<br> <img src="https://images2.imgbox.com/f1/a6/ApQgD0jH_o.png" alt="在这里插入图片描述"><br> 点的遍历顺序为：1，2，4，7，8，5，3，6；<br> 这就是深度优先搜索的思路与在树中的实现。<br> <strong>例题与代码实现：</strong><a href="https://www.acwing.com/problem/content/848/" rel="nofollow">Acwing 树的重心</a></p> 
<pre><code>给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。

请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。

重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。

输入格式
第一行包含整数 n，表示树的结点数。

接下来 n−1 行，每行包含两个整数 a 和 b，表示点 a 和点 b 之间存在一条边。

输出格式
输出一个整数 m，表示将重心删除后，剩余各个连通块中点数的最大值。

数据范围
1≤n≤1e5
输入样例
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
输出样例：
4
</code></pre> 
<p>其实这道题对于刚刚学图论的人而言好像有一点难了，因为这一题不但考到了图的遍历，还需要知道树形dp的处理与状态的计算，如果这道题能懂，那么就表示完全搞定了dfs遍历图的知识点了。先附上ac代码吧，代码里会有解释。</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;bitset&gt;
#include&lt;ctime&gt;
#include&lt;cstring&gt;
#include&lt;list&gt;
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
#define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef  pair&lt;int, int&gt; PII;
const int N = 1e6 + 7;

int n;
int ne[N], h[N], e[N], id = 1;  //链式前向星
bool ch[N];
int ans=INF;
void add(int a, int b)  
{
    e[id] = b;
    ne[id] = h[a];
    h[a] = id++;
}

int dfs(int x)  //x是根节点的编号
{
    ch[x] = true;  //标记这个点被遍历过了，避免死循环
    int sum = 1;  //以x为根的树的节点数量
    int res = 0;  //所有子树最长的子树的长度
    int te = 0;
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!ch[j])
        {
        	//这里的递归实现是dfs实现的精髓
            te=dfs(j), sum +=te ;
            res = max(res, te);
        }
    }
    res = max(res, n - sum);
    ans = min(ans, res);
    return sum;
}

void solve()
{
    mem(h, -1);  //h数组的初始化
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n - 1; i++)
    {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        //无向图的边就是两条有向边
        add(x, y);
        add(y, x);
    }
    dfs(1);
    cout &lt;&lt; ans &lt;&lt; endl;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    solve();
    return 0;
}
</code></pre> 
<h3><a id="BFS_132"></a>三、广度优先搜索遍历（BFS）</h3> 
<p><strong>概念：</strong> BFS广度优先搜索，与DFS不同，BFS在搜索到一个点后，会先搜索他周围的与它相连所有点，然后再搜索所有有与它相连的的点的相连的的点。这么说是不是很绕？让我们看图理解一下吧。<br> <img src="https://images2.imgbox.com/9b/55/oxbkVwis_o.png" alt="在这里插入图片描述"><br> 遍历顺序：1，2，3，4，5，6，7，8；<br> 队列q的元素情况为<br> 1.{1}；<br> 2.{2，3}；<br> 3.{4，5，6}；<br> 4.{7，8}；<br> 看不懂上面4行的意思就去看看bfs入门博客以及数据结构：队列的知识点。<br> <strong>例题与代码实现:</strong> <a href="https://www.acwing.com/problem/content/849/" rel="nofollow">Acwing 图中点的层次</a></p> 
<pre><code>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环。

所有边的长度都是 1，点的编号为 1∼n。

请你求出 1 号点到 n 号点的最短距离，如果从 1 号点无法走到 n 号点，输出 −1。

输入格式
第一行包含两个整数 n 和 m。

接下来 m 行，每行包含两个整数 a 和 b，表示存在一条从 a 走到 b 的长度为 1 的边。

输出格式
输出一个整数，表示 1 号点到 n 号点的最短距离。

数据范围
1≤n,m≤1e5
</code></pre> 
<p>这题就是纯BFS遍历图的题了，应该要简单一些。想搞懂bfs遍历就必须要看懂这道题。我们从起点开始遍历，如果我们发现终点被放进队列中了，就停止BFS，否则就清空队列，把子节点放进队列。</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;bitset&gt;
#include&lt;ctime&gt;
#include&lt;cstring&gt;
#include&lt;list&gt;
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
#define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef  pair&lt;int, int&gt; PII;
const int N = 1e6 + 7;

int n, m;
int h[N], e[N], ne[N], id = 1;
bool ch[N];
void add(int a, int b)
{
	e[id] = b, ne[id] = h[a], h[a] = id++;
}

int ans = 0;  //这是答案
void bfs(int u)  //u是起点
{
	ch[u] = 1;   //防止死循环
	queue&lt;int&gt;q;  //主队列
	q.push(u);  //把起点放进去
	while (!q.empty())
	{
		queue&lt;int&gt;t;  //临时队列
		while (!q.empty())  //清空主队列，把数据全部放进临时队列中
		{
			if (q.front() == n)return;   //终点被放进去了就结束bfs函数
			t.push(q.front());
			q.pop();
		}
		while (!t.empty())  //把当前所有点的子节点放进主队列中去
		{
			int te = t.front();  //拿出队首
			for (int i = h[te]; i != -1; i = ne[i])  //找出所有子节点
			{
				if (ch[e[i]])  //防止死循环
					continue;
				else
				{
					ch[e[i]] = 1;
					q.push(e[i]);
				}
			}
			t.pop();
		}
		ans++;  //每bfs一层，路径长度加一
	}
	ans = -1;  //遍历了整张图都每找到中点，就返回-1；
}


void solve()
{
	mem(h, -1);
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; m; i++)
	{
		int a, b;
		cin &gt;&gt; a &gt;&gt; b;
		add(a, b);
	}
	bfs(1);
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main()
{
	//std::ios::sync_with_stdio(false);
	//cin.tie(0), cout.tie(0);
	solve();
	return 0;
}
</code></pre> 
<p>作者：Avalon Demerzel，喜欢我的博客就点个赞吧，更多图论与数据结构知识点请见作者专栏《图论与数据结构》</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6ca967361626f7034eb0379d6be20a90/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jeecgboot打包后 登录页面 验证码不出来</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1c026aca57f169c466e04f7eaab0d096/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机公式与函数乘法,excel常用函数乘法公式的使用方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>