<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入探讨Java字符串的拼接 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入探讨Java字符串的拼接" />
<meta property="og:description" content="前言：国庆最近跟着小男友在图书馆学习，偶然被他带着看开了Java源码，因而有兴趣想看看String这个是怎么回事。 String中的equals public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i&#43;&#43;; } return true; } } return false; } 这是String复写的equals的源码，在Object中equals方法返回的是两者地址值，即：
public boolean equals(Object obj) { return (this == obj); } 也就是说，如果这两个地址相同则返回true，不进行内容的比较。例如，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5129680721dc6b6d7f475b7edb89ea42/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-03T09:46:32+08:00" />
<meta property="article:modified_time" content="2017-10-03T09:46:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入探讨Java字符串的拼接</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <pre><code>前言：国庆最近跟着小男友在图书馆学习，偶然被他带着看开了Java源码，因而有兴趣想看看String这个是怎么回事。
</code></pre> 
<h2 id="string中的equals">String中的equals</h2> 
<pre><code>public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
</code></pre> 
<p>这是String复写的equals的源码，在Object中equals方法返回的是两者地址值，即：</p> 
<pre><code>public boolean equals(Object obj) {
    return (this == obj);
}
</code></pre> 
<p>也就是说，如果这两个地址相同则返回true，不进行内容的比较。例如，</p> 
<pre><code>String s1 = "abc";
String s2 = "abc";
</code></pre> 
<p>由于这两个变量都在常量池，所以地址会一致，所以返回true。之后的判断也一目了然，首先判断是否属于String类，然后判断内容是否一致。</p> 
<h2 id="string中的hashcode">String中的HashCode</h2> 
<pre><code>hashcode是何许物种？我们可以查到一种解释，hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值，在Object中也可以看到对HashCode生成的方法，是一个native类，但好在有注释，Whenever it is invoked on the same object more than once during an execution of a Java application, the method must consistently return the same integer.底层是C++的实现，但总而言之，是可以用它确定对象地址是否相同的。
</code></pre> 
<p>在String类中，复写了hashCode的生成方法，显得简单了很多，这里的hashcode将String字符串经过计算得到了一个数字，计算方法如下：</p> 
<pre><code>public int hashCode() {
    int h = hash;
    if (h == 0 &amp;&amp; value.length &gt; 0) {
        char val[] = value;

        for (int i = 0; i &lt; value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
</code></pre> 
<p>也就是将每个字符转成ASCII码，通过公式算得。例如：</p> 
<pre><code>String str = "abc";
System.out.println(str.hashCode());
System.out.println(31*((31*97)+98)+99);
即为：96354
同时我们可以看出字符串a的hashcode为97
System.out.println("a".hashCode()); ==&gt; 97
</code></pre> 
<p>其实有很多类都复写了hashcode方法，例如Integer，直接返回了Integer的值。</p> 
<pre><code>public int hashCode() {
    return Integer.hashCode(value);
}
</code></pre> 
<h2 id="string中的-拼接">String中的 + 拼接</h2> 
<p>终于引出来我们最需要了解的一个方法了。</p> 
<pre><code>引出今天探索的原因是String是一个被final修饰的类
    public final class String
所以，我就在想，通过 + 的字符拼接是怎么进行的，== 是判断地址的，那么由于String是一个不可变的类，也就是说，+ 拼接完后的String还是不是它本身。
如代码：
    String s = "hello";
    String str = "hello";
    System.out.println(s==str);
    s+="world";
    System.out.println(s==str);
假设s的地址没有发生改变的话，那么两个判断都应该是true，然而结果是第一个是true，第二个是false，我们也就可以这样猜想，是不是这个拼接后的s，已经不是之前的s。

之后我们又进行了如下测试，返回值是false，也就是说，str1与str2地址不同，这个很好理解，因为是new操作，所以hello就存放在了两个堆区，同时str1和str2的地址值存放到了栈中。
    String str1 = new String("hello");
    String str2 = new String("hello");
    System.out.println(str1 == str2);
</code></pre> 
<p><img src="https://images2.imgbox.com/ae/84/8RlTlfDT_o.png" alt="" title=""> <br> 通过反编译代码，可以发现String中 + 进行拼接，实际上是创建了一个StringBuilder，事实上这个我还真没反编译出来，网上找到的参考资料如下：</p> 
<pre><code>String str0 = "a";
StringBuilder sb = new StringBuilder();
sb.append(str0).append("b");
String str1 = sb.toString();

来自：http://www.jianshu.com/p/849f1d443b3a
</code></pre> 
<p>所以，String引用对象在拼接时，建立了临时缓存的StringBuilder，因此地址发生了变化。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d8238df355dc84637dfa9d2c9d8cd00f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">curl命令测试网络请求中DNS解析、响应时间</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdda2c9004cefb731e02c1aad9b85c54/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">try catch 执行原理及顺序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>