<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>URLConnection（）和openStream（）两个方法产生SSRF的原理和修复方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="URLConnection（）和openStream（）两个方法产生SSRF的原理和修复方法" />
<meta property="og:description" content="今年是自主研发的第三个年份，也是重视安全的年份。
转一篇小文章：
0x00 前言 SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定 URL 地址获取网页文本内容，加载指定地址的图片，下载等等。这里主要介绍java中URLConnection（）和openStream（）两个方法产生SSRF的原理和修复方法
0x01 URLConnection @RequestMapping(value = &#34;/urlConnection/vuln&#34;, method = {RequestMethod.POST, RequestMethod.GET}) public String URLConnectionVuln(String url) { return HttpUtils.URLConnection(url); } 这里调用的是HttpUtils.URLConnection(url)
public static String URLConnection(String url) { try { URL u = new URL(url); URLConnection urlConnection = u.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); //send request // BufferedReader in = new BufferedReader(new InputStreamReader(u.openConnection().getInputStream())); String inputLine; StringBuilder html = new StringBuilder(); while ((inputLine = in.readLine()) !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bd833865d988ee4ce5fd1076ecee37bb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T17:30:24+08:00" />
<meta property="article:modified_time" content="2024-01-04T17:30:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">URLConnection（）和openStream（）两个方法产生SSRF的原理和修复方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>今年是自主研发的第三个年份，也是重视安全的年份。</p> 
<p>转一篇小文章：</p> 
<h2>0x00 前言</h2> 
<p>SS<a href="https://bbs.elecfans.com/group_65" rel="nofollow" title="RF">RF</a> 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定 URL 地址获取网页文本内容，加载指定地址的图片，<a href="https://www.elecfans.com/soft/special/" rel="nofollow" title="下载">下载</a>等等。这里主要介绍<a href="https://www.elecfans.com/v/tag/852/" rel="nofollow" title="java">java</a>中<code>URLConnec<a href="https://bbs.elecfans.com/group_715" rel="nofollow" title="ti">ti</a>on（）</code>和<code>openStream（）</code>两个方法产生SSRF的原理和修复方法</p> 
<h2>0x01 URLConnection</h2> 
<pre><code>    @RequestMap<a href="https://www.elecfans.com/tags/pi/" rel="nofollow" title="pi">pi</a>ng(value = "/urlConnection/vuln", method = {RequestMethod.POST, RequestMethod.GET})
    publ<a href="https://m.hqchip.com/app/1726" rel="nofollow" title="ic">ic</a> String URLConnectionVuln(String url) {
        return HttpUtils.URLConnection(url);
    }

</code></pre> 
<p>这里调用的是<code>HttpUtils.URLConnection(url)</code></p> 
<p></p> 
<pre><code>    public static String URLConnection(String url) {
        try {
            URL u = new URL(url);
            URLConnection urlConnection = u.openConnection();
            BufferedRe<a href="https://bbs.elecfans.com/zhuti_1472_1.html" rel="nofollow" title="ad">ad</a>er in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); //send request
            // BufferedReader in = new BufferedReader(new InputStreamReader(u.openConnection().getInputStream()));
            String inputLine;
            StringBuilder html = new StringBuilder();

            while ((inputLine = in.readLine()) != null) {
                html.append(inputLine);
            }
            in.close();
            return html.toString();
        } catch (Exception e) {
            logger.error(e.getMessage());
            return e.getMessage();
        }
    }

</code></pre> 
<p>跟进<code>URLConnection</code>方法，而<code>URLConnection</code>里又调用了<code>URL.openConnection()</code>来发起请求, 这个请求可以直接执行url协议（伪协议）<br><strong>漏洞利用:</strong><br> 使用file协议读文件</p> 
<p><img alt="" height="234" src="https://images2.imgbox.com/88/51/jxgxA9X0_o.png" width="1080"><br> 使用http协议访问百度</p> 
<p><img alt="" height="377" src="https://images2.imgbox.com/1e/72/RwHnUibp_o.png" width="1080"><br><strong>修复方法:</strong><br> 这里先是对url调用了<code>SecurityUtil.isHttp()</code>来进行检查</p> 
<pre><code>    @GetMapping("/urlConnection/sec")
    public String URLConnectionSec(String url) {

        // Decline not http/https protocol
        if (!SecurityUtil.isHttp(url)) {
            return "[-] SSRF check fai<a href="https://www.hqchip.com/app/1721" rel="nofollow" title="led">led</a>";
        }

        try {
            SecurityUtil.star<a href="https://www.hqchip.com/app/1593" rel="nofollow" title="tSS">tSS</a>RFHook();
            return HttpUtils.URLConnection(url);
        } catch (SSRFException | IOException e) {
            return e.getMessage();
        } finally {
            SecurityUtil.stopSSRFHook();
        }

    }
</code></pre> 
<p>SecurityUtil.isHttp()比较简单，就是判断url是否是以http://或https://开头</p> 
<pre><code>    public static boolean isHttp(String url) {
        return url.startsWith("http://") || url.startsWith("https://");
    }
</code></pre> 
<p>单纯的ban掉其他协议显然是不够的，还不能够防止对内网进行探测，于是在获取url内容之前，开启了一个hook来对用户行为进行监听，<code>SecurityUtil.startSSRFHook()</code>，就有效防止了ssrf攻击</p> 
<h2>0x02 openStream</h2> 
<p><code>openStream（）</code>方法的实现也是调用了<code>openConnection</code>生成一个<code>URLConnection</code>对象，然后再通过这个对象调用的<code>getInputStream（）</code>方法的</p> 
<pre><code>    @GetMapping("/openStream")
    public void openStream(@RequestPa<a href="https://www.elecfans.com/tags/ram/" rel="nofollow" title="ram">ram</a> String url, HttpServletResponse response) throws IOException {
        InputStream inputStream = null;
        OutputStream outputStream = null;
        try {
            String downLo<a href="https://bbs.elecfans.com/group_907" rel="nofollow" title="adI">adI</a>mgFileName = WebUtils.getNameWithou<a href="https://www.elecfans.com/tags/te/" rel="nofollow" title="tE">tE</a>xtension(url) + "." + WebUtils.getFileExtension(url);
            // download
            response.setHeader("content-disposition", "att<a href="https://www.hqchip.com/app/1703" rel="nofollow" title="ac">ac</a>hment;fileName=" + downLoadImgFileName);

            URL u = new URL(url);
            int length;
            byte[] bytes = new byte[1024];
            inputStream = u.openStream(); // send request
            outputStream = response.getOutputStream();
            while ((length = inputStream.read(bytes)) &gt; 0) {
                outputStream.write(bytes, 0, length);
            }

        } catch (Exception e) {
            logger.error(e.toString());
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
            if (outputStream != null) {
                outputStream.close();
            }
        }
    }
</code></pre> 
<p>通过<code>WebUtils.getNameWithoutExtension(url) + "." + WebUtils.getFileExtension(url)</code>来获取下载文件名,然后执行<code>inputStream = u.openStream();</code>来看一下openStream()，也是调用了<code>openConnection()</code>，也会根据传入的协议的不同来进行处理</p> 
<pre><code>    public final InputStream openStream() throws java.io.IOException {
        return openConnection().getInputStream();
    }
</code></pre> 
<p>由此可以得知，<code>openStream（）</code>方法同样也可以进行ssrf来探测内网以及文件下载，修复方案同上</p> 
<h2>0x03 总结</h2> 
<p><strong>关键词：</strong><br><code>URLConnection、openConnection、openStream</code><br><strong>漏洞利用：</strong><br> 关于SSRF漏洞利用相关可以看这篇文章，总结的很详细！<br> 从一文中了解SSRF的各种绕过姿势及攻击思路</p> 
<p>原：<a href="https://www.elecfans.com/d/2070887.html" rel="nofollow" title="URLConnection（）和openStream（）两个方法产生SSRF的原理和修复方法-电子发烧友网">URLConnection（）和openStream（）两个方法产生SSRF的原理和修复方法-电子发烧友网</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a96ec414218d9024d5cfc8f1bcd4bb29/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【QT demo】基于QT6.2.4实现简易的QT_Snake贪吃蛇小游戏</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c3a2cc2e597e28b6e4c3115e6f96b482/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">threejs在透视相机模式下，绘制像素大小固定的元素</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>