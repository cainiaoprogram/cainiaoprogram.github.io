<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android MVVM 模式介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android MVVM 模式介绍" />
<meta property="og:description" content="目录
1.MVVM模式分为Model，View，ViewModel 注意点
2.MVVM模式图
3.Android MVVM架构
4.Databinding框架
Note：
5.双向绑定使用到的注解
1）@InverseBindingAdapter
2)@InverseBindingMethod与@InverseBindingMethods
3)@InverseMethod
4)@Bindable
6.ViewModel 的生命周期
7.MVVM的优势和劣势
7.1优势
7.2劣势
1.MVVM模式分为Model，View，ViewModel (1).Model:数据层，包含数据实体和对数据实体的操作
(2).View:界面层，对应于Activity，XML,View，负责数据显示以及用户交互。
(3).ViewModel：关联层，将Model和View进行绑定，Model或者View更改时，实时刷新对方。
注意点 1.View只做和UI相关的工作，不涉及任何业务逻辑，不涉及操作数据，不处理数据。UI和数据严格的分开
2.ViewModel只做和业务逻辑相关的工作，不涉及任何和UI相关的操作，不持有控件引用，不更新UI。
2.MVVM模式图 3.Android MVVM架构 View
显而易见Activity/Fragment便是MVVM中的View，当收到ViewModel传递过来的数据时，Activity/Fragment负责将数据以你喜欢的方式显示出来。View还包括ViewDataBinding，上面中并没有体现。
ViewModel
ViewModel作为Activity/Fragment与其他组件的连接器。负责转换和聚合Model中返回的数据，使这些数据易于展示，并把这些数据改变即时通知给Actvity/Fragment。
ViewModel是具有生命周期意识的，当Activity/Fragment销毁时ViewModel的onClear方法会被回调，你可以在这里做一些清理工作。LiveData是具有生命周期意识的一个可观察的数据持有者，ViewModel中的数据有LiveData持有，并且只有当Activity/Fragment处于活动时才会通知UI数据的改变，避免无用的刷新UI。
Model
Repository及其下方就是model了。Repository负责提取和处理数据。数据来源可以是本地数据库，也可以来自网络，这些数据统一有Repository处理，对应隐藏数据来源以及获取方式。
Binder绑定器
Android中的数据绑定技术由DataBinding和LiveData共同实现。当Activity/Fragment接收到来自ViewModel中的新数据时（由LiveData自动通知数据的改变），将这些数据通过DataBinding绑定到ViewDataBinding中，UI将会自动刷新。
4.Databinding框架 Databinding和MVVM的关系
MVVM是一种架构模式，DataBinding是一个实现数据和UI绑定的框架，是实现MVVM模式的工具。
引入DataBinding
引入DataBinding的方式很简单，我们只需要在App的build.gradle添加如下代码即可
android{ ..... dataBinding { enabled = true } } Databinding常用方法
1).BindingAdapter注解设置自定义属性
public class TripleRadioRecyclerView extends RecyclerView { ... @BindingAdapter(&#34;scrollListener&#34;) public static void addOnScrollListener(TripleRadioRecyclerView recyclerView, IScrollListener listener) { recyclerView." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/04d73d10d674e850dd93075b1db7b42c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-25T10:08:26+08:00" />
<meta property="article:modified_time" content="2021-03-25T10:08:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android MVVM 模式介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.MVVM%E6%A8%A1%E5%BC%8F%E5%88%86%E4%B8%BAModel%EF%BC%8CView%EF%BC%8CViewModel%C2%A0-toc" style="margin-left:0px;"><a href="#1.MVVM%E6%A8%A1%E5%BC%8F%E5%88%86%E4%B8%BAModel%EF%BC%8CView%EF%BC%8CViewModel%C2%A0" rel="nofollow">1.MVVM模式分为Model，View，ViewModel </a></p> 
<p id="%E6%B3%A8%E6%84%8F%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E6%B3%A8%E6%84%8F%E7%82%B9" rel="nofollow">注意点</a></p> 
<p id="2.MVVM%E6%A8%A1%E5%BC%8F%E5%9B%BE-toc" style="margin-left:0px;"><a href="#2.MVVM%E6%A8%A1%E5%BC%8F%E5%9B%BE" rel="nofollow">2.MVVM模式图</a></p> 
<p id="3.Android%20MVVM%E6%9E%B6%E6%9E%84-toc" style="margin-left:0px;"><a href="#3.Android%20MVVM%E6%9E%B6%E6%9E%84" rel="nofollow">3.Android MVVM架构</a></p> 
<p id="4.Databinding%E6%A1%86%E6%9E%B6-toc" style="margin-left:0px;"><a href="#4.Databinding%E6%A1%86%E6%9E%B6" rel="nofollow">4.Databinding框架</a></p> 
<p id="%E4%B8%8A%E9%9D%A2%E6%9C%89%E4%B8%AA%E5%9C%B0%E6%96%B9%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%8B%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%8A%E9%9D%A2%E6%9C%89%E4%B8%AA%E5%9C%B0%E6%96%B9%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%8B%EF%BC%9A" rel="nofollow">Note：</a></p> 
<p id="%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E6%B3%A8%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E6%B3%A8%E8%A7%A3" rel="nofollow">5.双向绑定使用到的注解</a></p> 
<p id="1%EF%BC%89%40InverseBindingAdapter-toc" style="margin-left:40px;"><a href="#1%EF%BC%89%40InverseBindingAdapter" rel="nofollow">1）@InverseBindingAdapter</a></p> 
<p id="2)%40InverseBindingMethod%E4%B8%8E%40InverseBindingMethods-toc" style="margin-left:40px;"><a href="#2%29%40InverseBindingMethod%E4%B8%8E%40InverseBindingMethods" rel="nofollow">2)@InverseBindingMethod与@InverseBindingMethods</a></p> 
<p id="3)%40InverseMethod-toc" style="margin-left:40px;"><a href="#3%29%40InverseMethod" rel="nofollow">3)@InverseMethod</a></p> 
<p id="4)%40Bindable-toc" style="margin-left:40px;"><a href="#4%29%40Bindable" rel="nofollow">4)@Bindable</a></p> 
<p id="lifecycle-toc" style="margin-left:0px;"><a href="#lifecycle" rel="nofollow">6.ViewModel 的生命周期</a></p> 
<p id="6.MVVM%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF-toc" style="margin-left:0px;"><a href="#6.MVVM%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF" rel="nofollow">7.MVVM的优势和劣势</a></p> 
<p id="7.1%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#7.1%E4%BC%98%E5%8A%BF" rel="nofollow">7.1优势</a></p> 
<p id="MVVM%E7%9A%84%E5%8A%A3%E5%8A%BF-toc" style="margin-left:40px;"><a href="#MVVM%E7%9A%84%E5%8A%A3%E5%8A%BF" rel="nofollow">7.2劣势</a></p> 
<hr id="hr-toc"> 
<h2 id="1.MVVM%E6%A8%A1%E5%BC%8F%E5%88%86%E4%B8%BAModel%EF%BC%8CView%EF%BC%8CViewModel%C2%A0">1.MVVM模式分为Model，View，ViewModel </h2> 
<p>(1).Model:数据层，包含数据实体和对数据实体的操作<br> (2).View:界面层，对应于Activity，XML,View，负责数据显示以及用户交互。<br> (3).ViewModel：关联层，将Model和View进行绑定，Model或者View更改时，实时刷新对方。</p> 
<h2 id="%E6%B3%A8%E6%84%8F%E7%82%B9">注意点</h2> 
<p>1.View只做和UI相关的工作，不涉及任何业务逻辑，不涉及操作数据，不处理数据。UI和数据严格的分开<br> 2.ViewModel只做和业务逻辑相关的工作，不涉及任何和UI相关的操作，不持有控件引用，不更新UI。</p> 
<h2 id="2.MVVM%E6%A8%A1%E5%BC%8F%E5%9B%BE">2.MVVM模式图</h2> 
<p><img alt="" height="229" src="https://images2.imgbox.com/62/da/qakvQfYc_o.png" width="717"></p> 
<h2 id="3.Android%20MVVM%E6%9E%B6%E6%9E%84">3.Android MVVM架构</h2> 
<p><img alt="" height="638" src="https://images2.imgbox.com/1b/10/DhHzMzDY_o.png" width="721"></p> 
<p><strong>View</strong><br> 显而易见Activity/Fragment便是MVVM中的View，当收到ViewModel传递过来的数据时，Activity/Fragment负责将数据以你喜欢的方式显示出来。View还包括ViewDataBinding，上面中并没有体现。</p> 
<p><strong>ViewModel</strong><br> ViewModel作为Activity/Fragment与其他组件的连接器。负责转换和聚合Model中返回的数据，使这些数据易于展示，并把这些数据改变即时通知给Actvity/Fragment。<br> ViewModel是具有生命周期意识的，当Activity/Fragment销毁时ViewModel的onClear方法会被回调，你可以在这里做一些清理工作。LiveData是具有生命周期意识的一个可观察的数据持有者，ViewModel中的数据有LiveData持有，并且只有当Activity/Fragment处于活动时才会通知UI数据的改变，避免无用的刷新UI。</p> 
<p><strong>Model</strong><br> Repository及其下方就是model了。Repository负责提取和处理数据。数据来源可以是本地数据库，也可以来自网络，这些数据统一有Repository处理，对应隐藏数据来源以及获取方式。</p> 
<p><strong>Binder绑定器</strong><br> Android中的数据绑定技术由DataBinding和LiveData共同实现。当Activity/Fragment接收到来自ViewModel中的新数据时（由LiveData自动通知数据的改变），将这些数据通过DataBinding绑定到ViewDataBinding中，UI将会自动刷新。</p> 
<h2 id="4.Databinding%E6%A1%86%E6%9E%B6">4.Databinding框架</h2> 
<p><strong>Databinding和MVVM的关系</strong></p> 
<p>MVVM是一种架构模式，DataBinding是一个实现数据和UI绑定的框架，是实现MVVM模式的工具。</p> 
<p><strong>引入DataBinding</strong><br> 引入DataBinding的方式很简单，我们只需要在App的build.gradle添加如下代码即可</p> 
<pre><code class="language-css">android{
.....
dataBinding {
        enabled = true
    }
}</code></pre> 
<p><strong>Databinding常用方法</strong></p> 
<p>1).BindingAdapter注解设置自定义属性</p> 
<pre><code class="language-java">public class TripleRadioRecyclerView extends RecyclerView {
...
@BindingAdapter("scrollListener")
public static void addOnScrollListener(TripleRadioRecyclerView recyclerView, IScrollListener listener) {
        recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
            private boolean scrollByDragging;

            @Override
            public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
                int position = ((TripleRadioRecyclerView) recyclerView).getSelection();
                if (RecyclerView.SCROLL_STATE_DRAGGING == newState) {
                    listener.onStartScroll(position);
                    scrollByDragging = true;
                } else if (RecyclerView.SCROLL_STATE_IDLE == newState) {
                    listener.onStopScroll(position);
                    scrollByDragging = false;
                }
            }

            @Override
            public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
                int position = ((TripleRadioRecyclerView) recyclerView).getSelection();
                listener.onScroll(position, scrollByDragging);
            }
        });
    }
...
}</code></pre> 
<pre><code class="language-java">public class TemperatureScrollViewModel {
...
    public IScrollListener scrollListener = new IScrollListener() {
        @Override
        public void onStartScroll(int position) {
            temperatureViewModel.setAdjusting(true, true);
            dragging = true;
            updateEnable();
        }

        @Override
        public void onScroll(int position, boolean fromUser) {
            Log.i(TAG, "onScroll: position=" + position + ", fromUser=" + fromUser);
            if (fromUser) {
                if (position != TemperatureScrollViewModel.this.position.get()) {
                    String temperature = transformer.getModelValue(position);
                    temperatureViewModel.setData(temperature);
                    Log.i(TAG, "onScroll: position=" + position + ", temperature=" + temperature);
                }
            }
        }
...
}</code></pre> 
<p>xml中使用自定义属性</p> 
<pre><code class="language-html">&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"&gt;

    &lt;data&gt;
        &lt;import type="com.databindingdemo.bean.HvacViewModel" /&gt;
        &lt;variable
            name="hvac"
            type="HvacViewModel" /&gt;
    &lt;/data&gt;



        &lt;com.gwm.demo.hvac.widget.TripleRadioRecyclerView
            android:id="@+id/recycler_passenger_temperature"
            android:layout_width="wrap_content"
            android:layout_height="96dp"
            android:layout_below="@id/btn_passenger_tmp_inc"
            android:layout_margin="@dimen/button_margin"
            android:layout_toEndOf="@id/seek_bar_passenger_tmp"
            android:enabled="@{hvac.passengerTemperatureScrollViewModel.enable}"
            app:selection="@{hvac.passengerTemperatureScrollViewModel.position}"
            app:scrollListener="@{hvac.passengerTemperatureScrollViewModel.scrollListener}" /&gt;
&lt;/layout&gt;   </code></pre> 
<p>自定义实现RecyclerView，scrollListener执行自定义@BindingAdapter("scrollListener")过程，在ViewMode中回调操作。</p> 
<p><span style="color:#f33b45;"><strong>NOTE：没有类似方法，添加对应的方法</strong></span><br> 比如 app:xxx 属性 </p> 
<ul><li>如果方法签名就是 app:xxx 属性里设定的值得话，直接定义 setXxx 方法即可。 </li><li>如果方法签名像上面的 setPaddingLeft 一样，还需要把 View 自己也传入的话，那么除了要定义 setXxx 方法，还需要添加 @BindingAdapter(“android:xxx”)</li></ul> 
<p> </p> 
<pre><code class="language-java">public class MainActivity extends AppCompatActivity  {
    //用户头像
    private static final String URL_USER_PIC = "http://xxx/xx.jpg";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);

        UserBean userBean = new UserBean(URL_USER_PIC, "张三", 24);
        binding.setUser(userBean);
    }
}</code></pre> 
<p><strong>DataBinding动态更新数据的两种方式</strong></p> 
<p><strong>1).BaseObservable</strong><br> 这个类也实现了字段变动的通知，在变量的getter上使用Bindable注解，并通过notifyPropertyChanged通知更新即可。</p> 
<pre><code class="language-java">public class DoubleBindBean extends BaseObservable {

// 用 @Bindable 标记过 getxxx() 方法会在 BR 中生成一个 entry。 当数据发生变化时需要调用 //notifyPropertyChanged(BR.content) 通知系统 BR.content这个 entry 的数据
//已经发生变化以更新UI。

    private String content; //内容

    public DoubleBindBean(String content) {
        this.content = content;
    }

    @Bindable
    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
        notifyPropertyChanged(BR.content); //通知系统数据源发生变化，刷新UI界面
    }
}
</code></pre> 
<p><strong>2).ObservableFiled</strong><br> 如果想要省时或者数据类的字段很少的话，可以使用ObservableFiled以及它的派生ObservableBoolean,ObservableByte,ObservableChar,ObservableShort,ObservableInt,ObservableLong,ObservableFloat,ObservableDouble,ObservableParcelable等。</p> 
<pre><code class="language-java">public class DoubleBindBean2 {
    //变量需要为public
    public final ObservableField&lt;String&gt; username = new ObservableField&lt;&gt;();
}</code></pre> 
<p><strong>Observable Collections</strong><br> 除了支持ObservableField,ObservableBoolean，ObservableInt等基础变量类型以外，当然也支持集合框架拉，比如：ObservableArrayMap,ObservableArrayList。使用和普通的Map、List基本相同.</p> 
<p><strong>3).双向绑定</strong><br> 以上两个说的都是单向绑定，数据的流向是单向的，下面我们说说双向绑定。<br> 幸运的是，Android原生控件中，绝大多数的双向绑定使用场景，DataBinding都已经帮我们实现好了：可以参考包名androidx.databinding.adapters下实现了系统基本所有原生控件双向绑定的Adapter类</p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/65/9e/SAI0qTYH_o.png" width="820"></p> 
<p>这意味着我们并不需要手动去实现复杂的双向绑定，以EditText为例，我们只需要通过<strong>@=(表达式)</strong>进行双向绑定：</p> 
<pre><code class="language-html">&lt;EditText
    android:id="@+id/etPassword"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="@={ viewModel.password }" /&gt;
</code></pre> 
<p>相比单向绑定，只需要多一个=符号，就能保住View层和ViewModel层的状态同步了。</p> 
<p id="%E9%9A%BE%E7%82%B9%E5%9C%A8%E5%93%AA%EF%BC%9F"><strong>难点在哪？</strong></p> 
<p>双向绑定定义好之后，使用起来很简单，但是定义却稍微比单向绑定麻烦一些，即使原生控件的DataBinding已经帮助我们实现好了，对于三方的控件或者自定义控件，还需要我们自己实现。<br> 我们已SwipeRefreshLayout为列，让我们来看看其双向绑定实现的方式：</p> 
<pre><code class="language-java">package com.geespace.doublebinding

import android.util.Log
import androidx.databinding.BindingAdapter
import androidx.databinding.InverseBindingAdapter
import androidx.databinding.InverseBindingListener
import androidx.swiperefreshlayout.widget.SwipeRefreshLayout

/**
 * 
Description:
 */

object SwipeRefreshLayoutBinding {

  //先实现单向绑定
    @JvmStatic
    @BindingAdapter("swipeRefreshLayout_refreshing")
    fun setSwipeRefreshLayoutRefreshing(
        swipeRefreshLayout: SwipeRefreshLayout,
        newValue: Boolean) {
        Log.e("swipeBinding", "setSwipeRefreshLayoutRefreshing:$newValue")
        if (swipeRefreshLayout.isRefreshing != newValue) //不要忘了防止死循环！
      //保证，只有View状态发生了变更，才会去更新UI
            swipeRefreshLayout.isRefreshing = newValue
    }

    @JvmStatic
    @InverseBindingAdapter(
        attribute = "swipeRefreshLayout_refreshing",
        event = "swipeRefreshLayout_refreshingAttrChanged" //2 .匹配 1
    )
    fun isSwipeRefreshLayoutRefreshing(swipeRefreshLayout: SwipeRefreshLayout): Boolean =
        swipeRefreshLayout.isRefreshing

    @JvmStatic
    @BindingAdapter(
        "swipeRefreshLayout_refreshingAttrChanged",  //1.注意默认是AttrChanged结尾
        requireAll = false)
    fun setOnRefreshListener(
        swipeRefreshLayout: SwipeRefreshLayout,
        bindingListener: InverseBindingListener?) {
        Log.e("swipeBinding","setOnRefreshingListener")

        if (bindingListener != null)
            swipeRefreshLayout.setOnRefreshListener {
                bindingListener.onChange()   //每当swipeRefreshLayout刷新状态被用户的      
                              //操作改变，我们都能够在这里监听到，
                              //并交给InverseBindingListener这个 信使 去通知DataBinding：

   
            }
    }
}</code></pre> 
<p>xml文件如下:</p> 
<pre><code class="language-html">&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"&gt;

    &lt;data&gt;
        &lt;variable
        name="viewModel"
        type="com.geespace.doublebinding.BaseViewModel" /&gt;
    &lt;/data&gt;

    &lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/swipe"
        app:swipeRefreshLayout_refreshing="@={viewModel.refreshing }"&gt;

        &lt;TextView
            android:layout_width="100dp"
            android:text="消失掉吧"
            android:id="@+id/txt_hide"
            android:padding="20dp"
            android:layout_height="100dp" /&gt;

    &lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout&gt;
&lt;/layout&gt;</code></pre> 
<p>refreshing参数如下：</p> 
<pre><code class="language-java">class BaseViewModel :ViewModel(){
        var refreshing:MutableLiveData&lt;Boolean&gt; = MutableLiveData()
}</code></pre> 
<p>Activity的代码</p> 
<pre><code class="language-Kotlin">class MainActivity2 :AppCompatActivity(){
    lateinit var swipeBinding:SwipeBinding
    lateinit var viewModel:BaseViewModel
    var handler:Handler=Handler()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        swipeBinding=DataBindingUtil.setContentView(this,R.layout.swipe)

        viewModel=ViewModelProvider(this).get(BaseViewModel::class.java)

        swipeBinding.viewModel=viewModel
        swipeBinding.setLifecycleOwner=this //一定要设置lifeCycleOwner 否则LiveData双向绑定不起作用

      viewModel.refreshing.observe(this, Observer {
            Log.e("mainActivity2,","isRefreshing:${it}")
        })

        txt_hide.setOnClickListener {
           viewModel.refreshing.postValue(false)
        }

    }
}</code></pre> 
<h2 id="%E4%B8%8A%E9%9D%A2%E6%9C%89%E4%B8%AA%E5%9C%B0%E6%96%B9%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%8B%EF%BC%9A">Note：</h2> 
<p><strong>上面有个地方需要注意下：</strong></p> 
<p id="%E5%BD%93%E4%BD%BF%E7%94%A8LiveData%E8%BF%9B%E8%A1%8C%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E6%97%B6%E5%80%99%20%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%B0%E5%BE%97%E8%B0%83%E7%94%A8binding.setLifeCycleOwner%E6%96%B9%E6%B3%95%2C%E5%90%A6%E5%88%99LiveData%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8CView%E6%B2%A1%E6%B3%95%E6%94%B6%E5%88%B0%E9%80%9A%E7%9F%A5%EF%BC%8C%E5%88%87%E8%AE%B0%EF%BC%81%EF%BC%81%E5%8F%AF%E4%BB%A5%E6%83%B3%E8%B1%A1%E5%88%B0binding%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AALifecycleOwner%E7%BB%99liveData%E8%AE%BE%E7%BD%AE%E4%BA%86%E7%9B%91%E5%90%AC%E3%80%82"><strong>当使用LiveData进行双向绑定的时候 一定要记得调用binding.setLifeCycleOwner方法,否则LiveData数据改变的时候，View没法收到通知，切记！！可以想象到binding内部使用这个LifecycleOwner给liveData设置了监听。</strong></p> 
<p>下面就是这个方法的详细说明:</p> 
<pre><code class="language-java">/**
     * Sets the {@link LifecycleOwner} that should be used for observing changes of
     * LiveData in this binding. If a {@link LiveData} is in one of the binding expressions
     * and no LifecycleOwner is set, the LiveData will not be observed and updates to it
     * will not be propagated to the UI.
     *
     * @param lifecycleOwner The LifecycleOwner that should be used for observing changes of
     *                       LiveData in this binding.
     */
    @MainThread
    public void setLifecycleOwner(@Nullable LifecycleOwner lifecycleOwner) {
        if (mLifecycleOwner == lifecycleOwner) {
            return;
        }
        if (mLifecycleOwner != null) {
            mLifecycleOwner.getLifecycle().removeObserver(mOnStartListener);
        }
        mLifecycleOwner = lifecycleOwner;
        if (lifecycleOwner != null) {
            if (mOnStartListener == null) {
                mOnStartListener = new OnStartListener(this);
            }
            lifecycleOwner.getLifecycle().addObserver(mOnStartListener);
        }
        for (WeakListener&lt;?&gt; weakListener : mLocalFieldObservers) {
            if (weakListener != null) {
                weakListener.setLifecycleOwner(lifecycleOwner);
            }
        }
    }
</code></pre> 
<h2 id="%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E6%B3%A8%E8%A7%A3">5.双向绑定使用到的注解</h2> 
<h3 id="1%EF%BC%89%40InverseBindingAdapter">1）@InverseBindingAdapter</h3> 
<p>1.作用于方法，方法须为公共静态方法。<br> 2.方法的第一个参数必须为View类型，如TextView等<br> 3.需要与@BindingAdapter配合使用</p> 
<pre><code class="language-java">@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
public @interface InverseBindingAdapter {

    String attribute();

    String event() default "";
}</code></pre> 
<p>attribute：String类型，必填，表示当值发生变化时，要从哪个属性中检索这个变化的值，示例："android:text"<br> event： String类型，非必填；如果填写，则使用填写的内容作为event的值；如果不填，在编译时会根据attribute的属性名再加上后缀“AttrChanged”生成一个新的属性作为event的值，举个例子：attribute属性的值为”android:text”，那么默认会在”android:text”后面追加”AttrChanged”字符串，生成”android:textAttrChanged”字符串作为event的值.<br> event属性的作用： 当View的值发生改变时用来通知dataBinding值已经发生改变了。开发者一般需要使用@BindingAdapter创建对应属性来响应这种改变</p> 
<h3 id="2)%40InverseBindingMethod%E4%B8%8E%40InverseBindingMethods">2)@InverseBindingMethod与@InverseBindingMethods</h3> 
<p>1.@InverseBindingMethods注解用于标记类<br> 2.@InverseBindingMethod注解需要与@InverseBindingMethods注解结合使用才能发挥其功效<br> 3.@InverseBindingMethods需要与@BindingAdapter配合使用才能发挥功效<br> 用法与示列:</p> 
<pre><code class="language-java">@InverseBindingMethods({
        @InverseBindingMethod(type = SeekBar.class, attribute = "android:progress"),
})
public class SeekBarBindingAdapter {}
</code></pre> 
<p>@InverseBindingMethod</p> 
<pre><code class="language-java">@Target(ElementType.ANNOTATION_TYPE)
public @interface InverseBindingMethod {

    Class type();

    String attribute();

    String event() default "";

    String method() default "";
}</code></pre> 
<p>type:Class类型，必填，如：SeekBar.class<br> attribute：String类型，必填，如：android:progress<br> event：String类型，非必填，属性值的生成规则以及作用和@InverseBindingAdapter中的event一样。<br> method：String类型，非必填，对于什么时候填什么时候不填，这里举个例子说明：比如SeekBar，它有android:progress属性，也有getProgress方法【你没看错，就是getProgress，不是setProgress】，所以对于SeekBar的android:progress属性，不需要明确指定method，因为不指定method时，默认的生成规则就是前缀“get”加上属性名，组合起来就是getProgress，而刚才也说了，getProgress方法在seekBar中是存在的，所以不用指定method也可以，但是如果默认生成的方法getXxx在SeekBar中不存在，而是其他方法比如getRealXxx,那么我们就需要通过method属性，指明android:xxx对应的get方法是getRealXxx,这样dataBinding在生成代码时，就使用getRealXxx生成代码了；从宏观上来看，@InverseBindingMethod的method属性的生成规则与@BindingMethod的method属性的生成规则其实是类似的</p> 
<h3 id="3)%40InverseMethod">3)@InverseMethod</h3> 
<p>作用于方法,<br> 用于双向绑定<br> @InverseMethod 注解是一个相对独立的注解，不需要其他注解的配合就可以发挥它强大的作用，它的作用就是为某个方法指定一个相反的方法。它有一个String类型的必填属性：value，用来存放与当前方法对应的相反方法<br> 正方法与反方法的要求：</p> 
<ul><li>正方法与反方法的参数数量必须相同</li><li>正方法的最终参数的类型与反方法的返回值必须相同</li><li>正方法的返回值类型必须与反方法的最终参数类型相同。<br> 用列如下:</li></ul> 
<pre><code class="language-java">@InverseMethod("convertIntToString")
public static int convertStringToInt(String value) {
    try {
        return Integer.parseInt(value);
    } catch (NumberFormatException e) {
        return -1;
    }
}
public static String convertIntToString(int value) {
    return String.valueOf(value);
}</code></pre> 
<h3 id="4)%40Bindable">4)@Bindable</h3> 
<p>该注解用于双向绑定，需要与 notifyPropertyChanged()方法结合使用<br> 该注解用于标记实体类中的get方法或“is”开头的方法,且实体类必须继承BaseObserable.<br> 示例用法</p> 
<pre><code class="language-java">public class User extends BaseObservable {

    private String name;
    private int age;
    private String sex;
    private boolean isStudent;

    @Bindable
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        notifyPropertyChanged(com.qiangxi.databindingdemo.BR.name);
    }

    @Bindable
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
        notifyPropertyChanged(com.qiangxi.databindingdemo.BR.age);
    }

    @Bindable
    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
        notifyPropertyChanged(com.qiangxi.databindingdemo.BR.sex);
    }

    @Bindable
    public boolean isStudent() {
        return isStudent;
    }

    public void setStudent(boolean student) {
        isStudent = student;
        notifyPropertyChanged(com.qiangxi.databindingdemo.BR.student);
    }

    @Bindable({"name", "age", "sex", "isStudent"})
    public String getAll() {
        return "姓名:" + name + ",年龄=" + age + "，性别：" + sex + "，是不是学生=" + isStudent;
    }
}</code></pre> 
<p>@Bindable注解是用来干什么的？<br> 使用@Bindable注解标记的get方法，在编译时，会在BR类中生成对应的字段，然后与notifyPropertyChanged()方法配合使用，当该字段中的数据被修改时，dataBinding会自动刷新对应view的数据，而不用我们在拿到新数据后重新把数据在setText()一遍，就凭这一点，dataBinding就可以简化大量的代码</p> 
<h2 id="lifecycle">6.ViewModel 的生命周期</h2> 
<p><a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" rel="nofollow"><code>ViewModel</code></a> 对象存在的时间范围是获取 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" rel="nofollow"><code>ViewModel</code></a> 时传递给 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModelProvider" rel="nofollow"><code>ViewModelProvider</code></a> 的 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle" rel="nofollow"><code>Lifecycle</code></a>。<a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" rel="nofollow"><code>ViewModel</code></a> 将一直留在内存中，直到限定其存在时间范围的 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle" rel="nofollow"><code>Lifecycle</code></a> 永久消失：对于 Activity，是在 Activity 完成时；而对于 Fragment，是在 Fragment 分离时。</p> 
<p>下图说明了 Activity 经历屏幕旋转而后结束时所处的各种生命周期状态。该图还在关联的 Activity 生命周期的旁边显示了 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" rel="nofollow"><code>ViewModel</code></a> 的生命周期。此图表说明了 Activity 的各种状态。这些基本状态同样适用于 Fragment 的生命周期。</p> 
<p><img alt="" height="642" src="https://images2.imgbox.com/07/3e/yexjX2cU_o.png" width="616"></p> 
<p>通常在系统首次调用 Activity 对象的 <code><a href="https://developer.android.google.cn/reference/android/app/Activity#onCreate%28android.os.Bundle%29" rel="nofollow">onCreate()</a></code> 方法时请求 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" rel="nofollow"><code>ViewModel</code></a>。系统可能会在 Activity 的整个生命周期内多次调用 <code><a href="https://developer.android.google.cn/reference/android/app/Activity#onCreate%28android.os.Bundle%29" rel="nofollow">onCreate()</a></code>，如在旋转设备屏幕时。<a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" rel="nofollow"><code>ViewModel</code></a> 存在的时间范围是从您首次请求 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" rel="nofollow"><code>ViewModel</code></a> 直到 Activity 完成并销毁。</p> 
<h2 id="6.MVVM%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF">7.MVVM的优势和劣势</h2> 
<h3 id="7.1%E4%BC%98%E5%8A%BF">7.1优势</h3> 
<p>1),使得M,V,VM的解耦更加彻底，在mvp模式中，p需要持有V的引用，才能去刷新UI，在MVVM模式中，View和Model使用databingding进行双向绑定，一方改变会直接通知另外一方，使得viewModel能专注于业务逻辑的处理，而不需要去关心UI刷新。<br> 2),不会像MVC一样导致Activity中代码量巨大，也不会像MVP一样出现大量的View接口(Presente与View是通过接口进行交互的)。项目结构更加低耦合。</p> 
<h3 id="MVVM%E7%9A%84%E5%8A%A3%E5%8A%BF">7.2劣势</h3> 
<p>1),数据绑定使得Bug很难被调试。<br> 2),一个大的模块中，model也会很大，虽然使用方便了也很容易保证了数据的一致性，但是长期持有，不释放内存，就造成了花费更多的内存。<br> 3),数据双向绑定不利于代码重用。客户端开发最常用的重用时View，但是数据双向绑定技术，让你在一个View都绑定了一个model，不同模块的model都不同，那就不能简单重用View了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d5970f62a813722780dd86756389a93c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">友元、运算符的重载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cc6fc744f3309b51025e28407a675e04/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML学习总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>