<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图像与文字的合成 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图像与文字的合成" />
<meta property="og:description" content="概述 前几天要做一段程序，把文字和位图图像合成并保存为位图文件。但问了好久都没人给一个满意的答复，只好在黑暗中摸索，费了一番功夫,实现了图像与文字的合成，并且可用鼠标拖动文字。现在我把代码贴出，希望能给需要的朋友以帮助。
关键函数 i nt SetDIBits( HDC hdc, // 兼容DC的句柄 HBITMAP hbmp, // 兼容位图的句柄 UINT uStartScan, // 扫描起始行的编号 UINT cScanLines, // 扫描的行的数目 CONST VOID *lpvBits, // 位图缓冲区的指针，要求已经分配空间 CONST BITMAPINFO *lpbmi, // 位图信息 UINT fuColorUse // 颜色格式 ); 这个函数把位图数据一个像素一个像素的贴到一个兼容位图上，hdc是选择了兼容位图的兼容DC。
int GetDIBits( HDC hdc, // 兼容DC的句柄 HBITMAP hbmp, // 兼容位图的句柄 UINT uStartScan, // 扫描起始行的编号 UINT cScanLines, // 扫描的行的数目 LPVOID lpvBits, // 位图缓冲区的指针，要求已经分配空间 LPBITMAPINFO lpbi, // 位图信息 UINT uUsage // 颜色格式 ); 这个函数的作用和SetDIBits刚好相反，它把兼容位图内已存在的数据一个像素一个像素的拷贝到数据缓冲区(lpvBits)中。这样程序的实现就比 较明朗了，首先根据位图的尺寸，创建一个兼容位图，然后把图片绘制到兼容位图，接着把文字也写到兼容位图上，然后再从兼容位图得到合成的数据。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7fb718e261efba4728d443d71ca20de9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-05T01:46:54+08:00" />
<meta property="article:modified_time" content="2019-07-05T01:46:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图像与文字的合成</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <h3>概述</h3> 
 <p>前几天要做一段程序，把文字和位图图像合成并保存为位图文件。但问了好久都没人给一个满意的答复，只好在黑暗中摸索，费了一番功夫,实现了图像与文字的合成，并且可用鼠标拖动文字。现在我把代码贴出，希望能给需要的朋友以帮助。</p> 
 <h3>关键函数</h3> 
 <pre>i</pre> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-cpp">nt SetDIBits(
        HDC hdc,                  // 兼容DC的句柄
        HBITMAP hbmp,             // 兼容位图的句柄
        UINT uStartScan,          // 扫描起始行的编号
        UINT cScanLines,          // 扫描的行的数目
        CONST VOID *lpvBits,      // 位图缓冲区的指针，要求已经分配空间
        CONST BITMAPINFO *lpbmi,  // 位图信息
        UINT fuColorUse           // 颜色格式
       );
</code></pre> 
 </div> 
 <p>这个函数把位图数据一个像素一个像素的贴到一个兼容位图上，hdc是选择了兼容位图的兼容DC。</p> 
 <pre></pre> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-cpp">int GetDIBits(
          HDC hdc,           // 兼容DC的句柄
          HBITMAP hbmp,      // 兼容位图的句柄
          UINT uStartScan,   // 扫描起始行的编号
          UINT cScanLines,   // 扫描的行的数目
          LPVOID lpvBits,    // 位图缓冲区的指针，要求已经分配空间
          LPBITMAPINFO lpbi, // 位图信息
          UINT uUsage        // 颜色格式
         );
</code></pre> 
 </div> 
 <br> 
 <p>这个函数的作用和SetDIBits刚好相反，它把兼容位图内已存在的数据一个像素一个像素的拷贝到数据缓冲区(lpvBits)中。这样程序的实现就比 较明朗了，首先根据位图的尺寸，创建一个兼容位图，然后把图片绘制到兼容位图，接着把文字也写到兼容位图上，然后再从兼容位图得到合成的数据。</p> 
 <h3>关键程序段</h3> 
 <pre></pre> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-cpp">CreateMemObject(CDC *pDC, BITMAPINFO *lpbmi, int* pnLineChar)
{	
	if (NULL == m_pMemDC)
	{
		m_pMemDC = new CDC();
		m_pMemDC-&gt;CreateCompatibleDC(pDC);
	}

	if (m_pMemBmp != NULL)
	{
		m_pMemDC-&gt;SelectObject(m_pOldBmp);		
		delete m_pMemBmp;
		m_pMemBmp = NULL;
	}



	m_pMemBmp = new CBitmap();       //根据图片的大小创建一个兼容位图
	m_pMemBmp-&gt;CreateCompatibleBitmap(pDC, m_lpBMPHdr-&gt;biWidth, m_lpBMPHdr-&gt;biHeight);
	m_pOldBmp = m_pMemDC-&gt;SelectObject(m_pMemBmp);
	m_pMemDC-&gt;FillSolidRect(0, 0, m_lpBMPHdr-&gt;biWidth, m_lpBMPHdr-&gt;biHeight, RGB(255, 255, 255)); 
        
		//把图像的数据绘制到兼容位图上
		
    SetDIBits(m_pMemDC-&gt;GetSafeHdc(), (HBITMAP)m_pMemBmp-&gt;m_hObject, 
		0, m_lpBMPHdr-&gt;biHeight, (LPVOID)m_lpDIBits, (BITMAPINFO*)m_lpBMPHdr, DIB_RGB_COLORS);
}

SetBmpText(const CString &amp;strText, BOOL bRepaint)
{
	//本函数在位图上添加文本

	m_strBmpText = strText;
	
	SetDIBits(m_pMemDC-&gt;GetSafeHdc(), (HBITMAP)m_pMemBmp-&gt;m_hObject, 
		0, m_lpBMPHdr-&gt;biHeight, (LPVOID)m_lpDIBits, (BITMAPINFO*)m_lpBMPHdr, DIB_RGB_COLORS);


	if (m_strBmpText.GetLength() &gt; 0)
	{
		//制造透明和重影效果

		m_pMemDC-&gt;SetBkMode(TRANSPARENT);
		m_pMemDC-&gt;SetTextColor(RGB(0, 0, 0));		
		m_pMemDC-&gt;TextOut(10, 10, m_strBmpText);
		m_pMemDC-&gt;SetTextColor(RGB(255, 255, 255));		
		m_pMemDC-&gt;TextOut(11, 11, m_strBmpText);
	}

	if (bRepaint)
	{
		Invalidate();
	}

}

SetSaveBmpPath(LPCTSTR pszPath)
{
	//从兼容位图中取出合成的数据

	BYTE *pTemp = new BYTE[m_dwImageSize];
	ZeroMemory(pTemp, m_dwImageSize);
	
	int nCount = GetDIBits(m_pMemDC-&gt;GetSafeHdc(), 
		(HBITMAP)m_pMemBmp-&gt;m_hObject, 0, m_lpBMPHdr-&gt;biHeight, 
		(LPVOID)pTemp, (BITMAPINFO*)m_lpBMPHdr, DIB_RGB_COLORS);	
}
</code></pre> 
 </div> 
 <br> 
</div> 
<p>转载于:https://www.cnblogs.com/rogee/archive/2011/03/31/2000491.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fc3d2a0397589af233e5307c2f6eadc8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">完整的学习C&#43;&#43;的读书路线图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/883581c96059ef40d2678f7c1a333f05/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">实现程序互斥运行的几种方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>