<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM相关概念入门 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM相关概念入门" />
<meta property="og:description" content="一、JVM位置：
二、JVM体系结构：
垃圾回收器在执行引擎中，JVM调优一般都是在方法区和堆中；
三、类加载器：
作用：加载class文件；
1、虚拟机自带的加载器；
2、启动类（根）加载器；
3、扩展类加载器；
4、应用程序加载器；
当我们要使用某个类的时候，顺序是这样的，首先先去启动类加载器bootstrap找，如果有就直接用，如果没有就去扩展类加载器找，如果扩展类加载器没有，就去应用程序加载器找，如果还是没有，就报ClassNotFoundException异常。
双亲委派机制：
1、如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行；
2、如果父类加载器还存在其父类加载器，则会进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。
3、如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式
优点：
1、避免类的重复加载
2、保护程序安全，防止核心API被随意篡改
沙箱安全机制：防止恶意代码污染java源代码
比如我定义了一个类名为String所在包为java.lang，因为这个类本来是属于jdk的，如果没有沙箱安全机制的话，这个类将会污染到我所有的String,但是由于沙箱安全机制，所以就委托顶层的bootstrap加载器查找这个类，如果没有的话就委托extsion,extsion没有就到aapclassloader，但是由于String就是jdk的源代码，所以在bootstrap那里就加载到了，先找到先使用，所以就使用bootstrap里面的String,后面的一概不能使用，这就保证了不被恶意代码污染。
四、方法区
静态变量，常量，类信息（构造方法、接口定义），运行时的常量池，即static、final、Class、常量池存在方法区中，但是实例变量存在堆内存中与方法区无关。
五、堆和栈
1、堆区：
存储的全部都是对象，每个对象包含了一个与之对应的 class 类的信息。
一个JVM只有一个堆内存，它会被所有线程共享，堆中不存放基本数据类型和对象引用，它只存放对象本身，堆内存的大小是可以调节的。
类加载器读取了类文件后，一般会把类、变量、方法、常量放到堆中，保存所有引用类型的真实对象。
堆内存细分为三个区域：
新生区（伊甸园区 Eden Area）； 养老区； 永久区； GC垃圾回收主要是在伊甸园区和养老区；
假设内存满了，报OOM（OutOfMemory）异常，堆内存不够！
新生区：
类诞生、成长、死亡的地方；
伊甸园区：所有的对象都是从伊甸园区new出来的；
幸存者区（0，1）
永久区：
这个区域是常驻内存的，用来存放JDK自身携带的class对象，Interface元数据，存储的是Java运行时的一些环境或类信息，这个区域不存在垃圾回收，关闭VM虚拟就会释放这个区域的内存。
当一个启动类加载了大量的第三方jar包，TomCat部署了太多的应用，大量动态生成的反射类，不断的被加载，直到内存满就会出现OOM。
在JDK1.6之前：有永久代，常量池在方法区中；
JDK1.7：有永久代，但是慢慢退化了，形成了“去永久代”，常量池在堆中；
在JDK1.8之后：无永久代，常量池在元空间；
2、栈内存，主管程序的运行，生命周期和线程同步；线程结束，栈内存也就释放，对于栈来说不存在垃圾回收问题 ，一旦线程结束，栈就自动销毁。
栈中存放：8大基本类型&#43;对象的引用&#43;实例方法
3、栈和堆的区别：
栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。
JAVA对象在内存中实例化的过程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4ecb6a1fbcd04ea63f15ae7fd8adfd61/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-13T11:41:12+08:00" />
<meta property="article:modified_time" content="2020-10-13T11:41:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM相关概念入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>一、JVM位置：<img src="https://images2.imgbox.com/07/63/4SqlNVb2_o.png" alt="在这里插入图片描述"><br> 二、JVM体系结构：<br> <img src="https://images2.imgbox.com/7e/1a/ZJoIS9IR_o.png" alt="在这里插入图片描述"><br> 垃圾回收器在执行引擎中，JVM调优一般都是在方法区和堆中；</p> 
<p>三、类加载器：<br> 作用：加载class文件；<br> <img src="https://images2.imgbox.com/42/40/NtEhX2dd_o.png" alt="在这里插入图片描述"><br> 1、虚拟机自带的加载器；<br> 2、启动类（根）加载器；<br> 3、扩展类加载器；<br> 4、应用程序加载器；</p> 
<p>当我们要使用某个类的时候，顺序是这样的，首先先去启动类加载器bootstrap找，如果有就直接用，如果没有就去扩展类加载器找，如果扩展类加载器没有，就去应用程序加载器找，如果还是没有，就报ClassNotFoundException异常。<br> <img src="https://images2.imgbox.com/a7/16/eHERsDri_o.png" alt="在这里插入图片描述"></p> 
<p>双亲委派机制：<br> 1、如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行；<br> 2、如果父类加载器还存在其父类加载器，则会进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。<br> 3、如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式<br> 优点：<br> 1、避免类的重复加载<br> 2、保护程序安全，防止核心API被随意篡改</p> 
<p>沙箱安全机制：防止恶意代码污染java源代码</p> 
<p>比如我定义了一个类名为String所在包为java.lang，因为这个类本来是属于jdk的，如果没有沙箱安全机制的话，这个类将会污染到我所有的String,但是由于沙箱安全机制，所以就委托顶层的bootstrap加载器查找这个类，如果没有的话就委托extsion,extsion没有就到aapclassloader，但是由于String就是jdk的源代码，所以在bootstrap那里就加载到了，先找到先使用，所以就使用bootstrap里面的String,后面的一概不能使用，这就保证了不被恶意代码污染。</p> 
<p>四、方法区<br> 静态变量，常量，类信息（构造方法、接口定义），运行时的常量池，即static、final、Class、常量池存在方法区中，但是实例变量存在堆内存中与方法区无关。</p> 
<p>五、堆和栈<br> 1、堆区：<br> 存储的全部都是对象，每个对象包含了一个与之对应的 class 类的信息。</p> 
<p>一个JVM只有一个堆内存，它会被所有线程共享，堆中不存放基本数据类型和对象引用，它只存放对象本身，堆内存的大小是可以调节的。</p> 
<p>类加载器读取了类文件后，一般会把<strong>类、变量、方法、常量</strong>放到堆中，保存所有引用类型的真实对象。</p> 
<p>堆内存细分为三个区域：</p> 
<pre><code>新生区（伊甸园区 Eden Area）；
养老区；
永久区；
</code></pre> 
<p><img src="https://images2.imgbox.com/78/52/lJjUinHh_o.png" alt="在这里插入图片描述"><br> GC垃圾回收主要是在伊甸园区和养老区；<br> 假设内存满了，报OOM（OutOfMemory）异常，堆内存不够！</p> 
<p><strong>新生区：</strong></p> 
<p>类诞生、成长、死亡的地方；<br> 伊甸园区：所有的对象都是从伊甸园区new出来的；<br> 幸存者区（0，1）</p> 
<p><strong>永久区：</strong><br> 这个区域是常驻内存的，用来存放JDK自身携带的class对象，Interface元数据，存储的是Java运行时的一些环境或类信息，这个区域不存在垃圾回收，关闭VM虚拟就会释放这个区域的内存。</p> 
<p>当一个启动类加载了大量的第三方jar包，TomCat部署了太多的应用，大量动态生成的反射类，不断的被加载，直到内存满就会出现OOM。</p> 
<p>在JDK1.6之前：有永久代，常量池在方法区中；<br> JDK1.7：有永久代，但是慢慢退化了，形成了“去永久代”，常量池在堆中；<br> 在JDK1.8之后：无永久代，常量池在元空间；</p> 
<p>2、栈内存，主管程序的运行，生命周期和线程同步；线程结束，栈内存也就释放，<strong>对于栈来说不存在垃圾回收问题</strong> ，一旦线程结束，栈就自动销毁。<br> 栈中存放：8大基本类型+对象的引用+实例方法<br> 3、栈和堆的区别：<br> 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p> 
<p><a href="https://www.freesion.com/article/17321077838/" rel="nofollow">JAVA对象在内存中实例化的过程</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c568fc25608810da285f3a919ab04918/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">079-mxd-冒险岛-自主学习搭建-单机联机都可以，详细教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3253d1d76b5861ac74d70477746feaef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【ros学习】12.ros启动gazebo时摄像头的发布进程被杀死，导致rqt_image_view无法显示画面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>