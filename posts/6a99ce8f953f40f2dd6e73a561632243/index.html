<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>最长单调子序列例题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="最长单调子序列例题" />
<meta property="og:description" content="1. HDU 1025 Constructing Roads In JGShining&#39;s Kingdom Problem Description
JGShining&#39;s kingdom consists of 2n(n is no more than 500,000) small cities which are located in two parallel lines.
Half of these cities are rich in resource (we call them rich cities) while the others are short of resource (we call them poor cities). Each poor city is short of exactly one kind of resource and also each rich city is rich in exactly one kind of resource." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6a99ce8f953f40f2dd6e73a561632243/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-11T15:18:00+08:00" />
<meta property="article:modified_time" content="2019-04-11T15:18:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">最长单调子序列例题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1. HDU 1025  Constructing Roads In JGShining's Kingdom</h3> 
<p>Problem Description</p> 
<p>JGShining's kingdom consists of 2n(n is no more than 500,000) small cities which are located in two parallel lines.<br><br> Half of these cities are rich in resource (we call them rich cities) while the others are short of resource (we call them poor cities). Each poor city is short of exactly one kind of resource and also each rich city is rich in exactly one kind of resource. You may assume no two poor cities are short of one same kind of resource and no two rich cities are rich in one same kind of resource.<br><br> With the development of industry, poor cities wanna import resource from rich ones. The roads existed are so small that they're unable to ensure the heavy trucks, so new roads should be built. The poor cities strongly BS each other, so are the rich ones. Poor cities don't wanna build a road with other poor ones, and rich ones also can't abide sharing an end of road with other rich ones. Because of economic benefit, any rich city will be willing to export resource to any poor one.<br><br> Rich citis marked from 1 to n are located in Line I and poor ones marked from 1 to n are located in Line II.<br><br> The location of Rich City 1 is on the left of all other cities, Rich City 2 is on the left of all other cities excluding Rich City 1, Rich City 3 is on the right of Rich City 1 and Rich City 2 but on the left of all other cities ... And so as the poor ones.<br><br> But as you know, two crossed roads may cause a lot of traffic accident so JGShining has established a law to forbid constructing crossed roads.<br><br> For example, the roads in Figure I are forbidden.<br>  </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/08/ad/sK5gLxrs_o.png"></p> 
<p><br><br> In order to build as many roads as possible, the young and handsome king of the kingdom - JGShining needs your help, please help him. ^_^</p> 
<p> </p> 
<p> </p> 
<p>Input</p> 
<p>Each test case will begin with a line containing an integer n(1 ≤ n ≤ 500,000). Then n lines follow. Each line contains two integers p and r which represents that Poor City p needs to import resources from Rich City r. Process to the end of file.</p> 
<p> </p> 
<p> </p> 
<p>Output</p> 
<p>For each test case, output the result in the form of sample.<br> You should tell JGShining what's the maximal number of road(s) can be built.</p> 
<p> </p> 
<p> </p> 
<p>Sample Input</p> 
<pre class="has"><code class="language-html"> </code></pre> 
<p>2</p> 
<p>1 2</p> 
<p>2 1</p> 
<p>3</p> 
<p>1 2</p> 
<p>2 3</p> 
<p>3 1</p> 
<p>Sample Output</p> 
<p>Case 1: My king, at most 1 road can be built.</p> 
<p>Case 2: My king, at most 2 roads can be built.</p> 
<h4>代码如下：</h4> 
<pre class="has"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int maxn=5*1e5+5;
int n;
int a[maxn];
int dp[maxn];
int cnt;
int main()
{
    int Case=0;
    while(scanf("%d",&amp;n)!=EOF)
    {
        Case++;
        cnt=0;
        for (int i=0;i&lt;n;i++)
        {
            int x,y;
            scanf("%d%d",&amp;x,&amp;y);
            a[x]=y;
        }
        for (int i=1;i&lt;=n;i++)
        {
            int loc=lower_bound(dp,dp+cnt,a[i])-dp;
            if(loc==cnt) dp[cnt++]=a[i];
            else dp[loc]=a[i];
        }
        if(cnt==1)
            printf("Case %d:\nMy king, at most %d road can be built.\n\n",Case,cnt);
        else
            printf("Case %d:\nMy king, at most %d roads can be built.\n\n",Case,cnt);
    }
    return 0;
}
</code></pre> 
<h3>2. POJ 3903 Stock Exchange</h3> 
<p>题目链接：</p> 
<p><a href="http://poj.org/problem?id=3903" rel="nofollow">http://poj.org/problem?id=3903</a></p> 
<h4>代码如下：</h4> 
<pre class="has"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int maxn=1e5+5;
int n;
int cnt;
int a[maxn];
int dp[maxn];
int main()
{
    while(scanf("%d",&amp;n)!=EOF)
    {
        cnt=0;
        for (int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]);
        for (int i=1;i&lt;=n;i++)
        {
            int loc=lower_bound(dp,dp+cnt,a[i])-dp;
            if(loc==cnt) dp[cnt++]=a[i];
            else dp[loc]=a[i];
        }
        printf("%d\n",cnt);
    }
    return 0;
}
</code></pre> 
<h3>3. <a href="https://vjudge.net/problem/16477/origin" rel="nofollow">POJ - 1065 </a>Wooden Sticks</h3> 
<h4>题目链接：</h4> 
<p><a href="https://vjudge.net/problem/POJ-1065" rel="nofollow">https://vjudge.net/problem/POJ-1065</a></p> 
<h3>思路：</h3> 
<p>先排序，然后找最长单调子序列。</p> 
<h4>代码如下：</h4> 
<pre class="has"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int maxn=5*1e3+5;
int t;
int n;
int cnt;
struct node
{
    int x,y;
};
node dp[maxn];
node a[maxn];
int vis[maxn];
int no[maxn];
int cur;
int compare (node a,node b)
{
    if(a.x!=b.x) return a.x&lt;b.x;
    return a.y&lt;b.y;
}
int main()
{
    scanf("%d",&amp;t);
    while(t--)
    {
        memset (vis,0,sizeof(vis));
        scanf("%d",&amp;n);
        for (int i=1;i&lt;=n;i++)
        {
            scanf("%d%d",&amp;a[i].x,&amp;a[i].y);
        }
        int ans=0;
        sort(a+1,a+n+1,compare);
        int num=n;
        while(num)
        {
            ans++;
            cur=0;
            cnt=0;
            for (int i=1;i&lt;=n;i++)
            {
                if(vis[i]) continue;
                if(cur&lt;=a[i].y)
                {
                    cnt++;
                    vis[i]=1;
                    cur=a[i].y;
                }
            }
            num-=cnt;
        }
        printf("%d\n",ans);
    }
    return 0;
}
</code></pre> 
<h3>4.POJ 1631 Bridging signals</h3> 
<h4>题目链接：</h4> 
<p><a href="http://poj.org/problem?id=1631" rel="nofollow">http://poj.org/problem?id=1631</a></p> 
<h4>代码如下：</h4> 
<pre class="has"><code>//include &lt;bits/stdc++.h&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;time.h&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const ll MOD = 1000000007;
const int maxn = 4*1e4+5;
const int INF = 0x3f3f3f3f;
const ll LINF = 0x3f3f3f3f3f3f3f3f;
template &lt;class T&gt;
inline bool scan_d(T &amp;ret) {
	char c; int sgn;
	if (c = getchar(), c == EOF) return 0;
	while (c != '-' &amp;&amp; (c&lt;'0' || c&gt;'9')) c = getchar();
	sgn = (c == '-') ? -1 : 1;
	ret = (c == '-') ? 0 : (c - '0');
	while (c = getchar(), c &gt;= '0'&amp;&amp;c &lt;= '9') ret = ret * 10 + (c - '0');
	ret *= sgn;
	return 1;
}
int t,n;
int a[maxn];
int L[maxn];
int main()
{
    scanf("%d",&amp;t);
    while(t--)
    {
        scanf("%d",&amp;n);
        for (int i=0;i&lt;n;i++)
        {
            scanf("%d",&amp;a[i]);
        }
        int num=0;
        for (int i=0;i&lt;n;i++)
        {
            int loc=lower_bound(L,L+num,a[i])-L;
            if(loc==num)
            {
                L[num++]=a[i];
            }
            L[loc]=a[i];
        }
        printf("%d\n",num);
    }
	return 0;
}
</code></pre> 
<h3>5. POJ 1952 BUY LOW, BUY LOWER</h3> 
<h4>题目链接：</h4> 
<p><a href="http://poj.org/problem?id=1952" rel="nofollow">http://poj.org/problem?id=1952</a></p> 
<p>此题在求最长递减子序列的同时还需要求出方案数。</p> 
<p>我们可以通过建立一个cnt数组表示以其为子序列结尾的数目， 这样只要满足dp[j]+1==dp[i]&amp;&amp;a[j]&gt;a[i]就可以为cnt[i]加上cnt[j],</p> 
<p>但是如果序列中有相同的数字的话，则在遍历序列的时候将前面相同的数字的cnt 置为0，这样就不会出现重复加的情况了。</p> 
<h4>代码如下：</h4> 
<pre class="has"><code>//include &lt;bits/stdc++.h&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;time.h&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const ll MOD = 1000000007;
const int maxn = 5*1e3+5;
const int INF = 0x3f3f3f3f;
const ll LINF = 0x3f3f3f3f3f3f3f3f;
template &lt;class T&gt;
inline bool scan_d(T &amp;ret) {
	char c; int sgn;
	if (c = getchar(), c == EOF) return 0;
	while (c != '-' &amp;&amp; (c&lt;'0' || c&gt;'9')) c = getchar();
	sgn = (c == '-') ? -1 : 1;
	ret = (c == '-') ? 0 : (c - '0');
	while (c = getchar(), c &gt;= '0'&amp;&amp;c &lt;= '9') ret = ret * 10 + (c - '0');
	ret *= sgn;
	return 1;
}
int n;
int a[maxn];
int L[maxn];
int dp[maxn];
int cnt[maxn];
int main()
{
    while(scanf("%d",&amp;n)!=EOF)
    {
        for (int i=0;i&lt;n;i++)
        {
            scanf("%d",&amp;a[i]);
        }
        memset (cnt,0,sizeof(cnt));
        int num=0;
        int ans=1;
        for (int i=0;i&lt;n;i++) dp[i]=1;
        for (int i=0;i&lt;n;i++)
        {
            for (int j=i+1;j&lt;n;j++)
            {
                if(a[i]&gt;a[j])
                {
                    dp[j]=max(dp[j],dp[i]+1);
                }
                ans=max(dp[j],ans);
            }
        }
        for (int i=0;i&lt;n;i++)
        {
            for (int j=0;j&lt;i;j++)
            {
                if(a[j]==a[i])
                {
                    cnt[j]=0;
                }
            }
            if(dp[i]==1)
            {
                cnt[i]=1;
            }
            else
            {
                for (int j=0;j&lt;i;j++)
                {
                    if(a[i]&lt;a[j]&amp;&amp;dp[j]+1==dp[i])
                    {
                        cnt[i]+=cnt[j];
                    }
                }
            }
        }
        for (int i=0;i&lt;n;i++)
        {
            if(ans==dp[i])
            {
                num+=cnt[i];
            }
        }
        printf("%d %d\n",ans,num);
    }
	return 0;
}
</code></pre> 
<h3>6. HDU 2881 Jack's struggle</h3> 
<h4>题目链接：</h4> 
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2881" rel="nofollow">http://acm.hdu.edu.cn/showproblem.php?pid=2881</a></p> 
<p>将两点能否在规定的时间到达进行dp。</p> 
<h4>代码如下：</h4> 
<pre class="has"><code>//include &lt;bits/stdc++.h&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;time.h&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const ll MOD = 1000000007;
const int maxn = 1e4+5;
const int INF = 0x3f3f3f3f;
const ll LINF = 0x3f3f3f3f3f3f3f3f;
template &lt;class T&gt;
inline bool scan_d(T &amp;ret) {
	char c; int sgn;
	if (c = getchar(), c == EOF) return 0;
	while (c != '-' &amp;&amp; (c&lt;'0' || c&gt;'9')) c = getchar();
	sgn = (c == '-') ? -1 : 1;
	ret = (c == '-') ? 0 : (c - '0');
	while (c = getchar(), c &gt;= '0'&amp;&amp;c &lt;= '9') ret = ret * 10 + (c - '0');
	ret *= sgn;
	return 1;
}
int n,m;
struct node
{
    int x,y,t;
};
int compare (node a,node b)
{
    return a.t&lt;b.t;
}
bool judge (node a,node b)
{
    int dis=abs(a.x-b.x)+abs(a.y-b.y);
    if(abs(a.t-b.t)&lt;dis) return false;
    return true;
}
node a[maxn];
int dp[maxn];
int main()
{
    while(scanf("%d%d",&amp;n,&amp;m)!=EOF)
    {
        if(n==0&amp;&amp;m==0) break;
        for (int i=0;i&lt;m;i++)
        {
            scanf("%d%d%d",&amp;a[i].t,&amp;a[i].x,&amp;a[i].y);
        }
        int ans=0;
        sort(a,a+m,compare);
        memset (dp,0,sizeof(dp));
        for (int i=0;i&lt;m;i++)
        {
            dp[i]=1;
            for (int j=0;j&lt;i;j++)
            {
                if(judge(a[i],a[j]))
                {
                    dp[i]=max(dp[i],dp[j]+1);
                }
            }
            ans=max(ans,dp[i]);
        }
        printf("%d\n",ans);
    }
	return 0;
}
</code></pre> 
<h3>7.  POJ Crossed Matchings</h3> 
<h4>题目链接：</h4> 
<p><a href="http://poj.org/problem?id=1692" rel="nofollow">http://poj.org/problem?id=1692</a></p> 
<h4>题解参考：</h4> 
<p><a href="https://www.cnblogs.com/zjutlitao/p/3572187.html" rel="nofollow">https://www.cnblogs.com/zjutlitao/p/3572187.html</a></p> 
<h4>代码如下：</h4> 
<pre class="has"><code>//include &lt;bits/stdc++.h&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;time.h&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const ll MOD = 1000000007;
const int maxn = 1e2+5;
const int INF = 0x3f3f3f3f;
const ll LINF = 0x3f3f3f3f3f3f3f3f;
template &lt;class T&gt;
inline bool scan_d(T &amp;ret) {
	char c; int sgn;
	if (c = getchar(), c == EOF) return 0;
	while (c != '-' &amp;&amp; (c&lt;'0' || c&gt;'9')) c = getchar();
	sgn = (c == '-') ? -1 : 1;
	ret = (c == '-') ? 0 : (c - '0');
	while (c = getchar(), c &gt;= '0'&amp;&amp;c &lt;= '9') ret = ret * 10 + (c - '0');
	ret *= sgn;
	return 1;
}
int m;
int n1,n2;
int a[maxn],b[maxn];
int dp[maxn][maxn];
int main()
{
    scanf("%d",&amp;m);
    while(m--)
    {
        scanf("%d%d",&amp;n1,&amp;n2);
        for (int i=1;i&lt;=n1;i++)
        {
            scanf("%d",&amp;a[i]);
        }
        for (int i=1;i&lt;=n2;i++)
        {
            scanf("%d",&amp;b[i]);
        }
        int ans=0;
        memset (dp,0,sizeof(dp));
        for (int i=1;i&lt;=n1;i++)
        {
            for (int j=1;j&lt;=n2;j++)
            {
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                if(a[i]==b[j]) continue;
                for (int k=1;k&lt;i;k++)
                {
                    for (int l=1;l&lt;j;l++)
                    {
                        if(a[k]==b[j]&amp;&amp;b[l]==a[i])
                        {
                            dp[i][j]=max(dp[i][j],dp[k-1][l-1]+2);
                        }
                    }
                }
                ans=max(ans,dp[i][j]);
            }
        }
        printf("%d\n",ans);
    }
	return 0;
}
</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d6ba46d68a240fcb1e122bf48d722e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习之softmax函数（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e5d39c1e4ae2bbd4b892f1e79d33575/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法 | 单链表的五个常见操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>