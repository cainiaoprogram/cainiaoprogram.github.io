<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IMX6ULL学习笔记（14）——GPIO接口使用（C语言方式） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="IMX6ULL学习笔记（14）——GPIO接口使用（C语言方式）" />
<meta property="og:description" content="一、GPIO简介 i.MX6ULL 芯片的 GPIO 被分成 5 组,并且每组 GPIO 的数量不尽相同，例如 GPIO1 拥有 32 个引脚， GPIO2 拥有 22 个引脚， 其他 GPIO 分组的数量以及每个 GPIO 的功能请参考 《i.MX 6UltraLite Applications Processor Reference Manual》 第26章General Purpose Input/Output (GPIO)（P1133）。
通过 GPIO 硬件结构框图，就可以从整体上深入了解 GPIO 外设及它的各种应用模式。
1.1 IO命名 打开 i.MX6ULL 参考手册的第 32 章“Chapter 32: IOMUX Controller(IOMUXC)”
i.MX6ULL 的 IO 分为两类：SNVS 域的和通用的，这两类 IO 本质上都是一样的。
“IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00”的就是 GPIO 命名，命名形式就是“IOMUXC_SW_MUC_CTL_PAD_XX_XX”，后面的“XX_XX”就是 GPIO 命名，比如：GPIO1_IO01、UART1_TX_DATA、JTAG_MOD 等等。他是 根据某个 IO 所拥有的功能来命名的。比如我们一看到 GPIO1_IO01 就知道这个肯定能做 GPIO，看到 UART1_TX_DATA 肯定就知道这个 IO 肯定能做为 UART1 的发送引脚。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1a1ffd9eb39f21f98b8988a7dcabc751/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-31T18:22:48+08:00" />
<meta property="article:modified_time" content="2022-12-31T18:22:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">IMX6ULL学习笔记（14）——GPIO接口使用（C语言方式）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="GPIO_0"></a>一、GPIO简介</h2> 
<blockquote> 
 <p>i.MX6ULL 芯片的 GPIO 被分成 5 组,并且每组 GPIO 的数量不尽相同，例如 GPIO1 拥有 32 个引脚， GPIO2 拥有 22 个引脚， 其他 GPIO 分组的数量以及每个 GPIO 的功能请参考 <strong>《i.MX 6UltraLite Applications Processor Reference Manual》 第26章General Purpose Input/Output (GPIO)（P1133）</strong>。<br> <img src="https://images2.imgbox.com/11/e5/1km7wYr2_o.png" alt=""><br> 通过 GPIO 硬件结构框图，就可以从整体上深入了解 GPIO 外设及它的各种应用模式。</p> 
</blockquote> 
<h3><a id="11_IO_5"></a>1.1 IO命名</h3> 
<p>打开 <strong>i.MX6ULL 参考手册的第 32 章“Chapter 32: IOMUX Controller(IOMUXC)”</strong><br> <img src="https://images2.imgbox.com/f4/63/WksQ2xaY_o.png" alt=""><br> i.MX6ULL 的 IO 分为两类：<strong>SNVS 域的和通用的</strong>，这两类 IO 本质上都是一样的。</p> 
<p>“IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00”的就是 GPIO 命名，命名形式就是“IOMUXC_SW_MUC_CTL_PAD_<code>XX_XX</code>”，后面的“<code>XX_XX</code>”就是 GPIO 命名，比如：GPIO1_IO01、UART1_TX_DATA、JTAG_MOD 等等。他是 <strong>根据某个 IO 所拥有的功能来命名的</strong>。比如我们一看到 GPIO1_IO01 就知道这个肯定能做 GPIO，看到 UART1_TX_DATA 肯定就知道这个 IO 肯定能做为 UART1 的发送引脚。</p> 
<p><strong>IO 复用功能。</strong> i.MX6ULL 除了 GPIO1_IO00~GPIO1_IO09 引脚外，其它 IO 也是可以复用为 GPIO 功能。同样的，GPIO1_IO00~GPIO_IO09 也是可以复用为其它外设引脚。</p> 
<h3><a id="12_IO_14"></a>1.2 IO复用</h3> 
<blockquote> 
 <p><strong>IOMUX 译为 IO 复用选择器</strong>。i.MX6ULL 的芯片每个 GPIO 都通过 IOMUX 支持多种功能， 例如一个 IO 可用于网络外设 ENET 的数据接收引脚，也可以被配置成 PWM 外设的输出引脚， 这样的设计大大增加了芯片的适用性，这样可选的功能就是由 IOMUX 实现的。IOMUX 相当于增加了多根内部信号线与 IO 引脚相连，<code>最多有 8 根，也就是说一个 IO 最多可支持 8 种可选的功能</code>。</p> 
</blockquote> 
<p>以“IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00”这个 IO 为例，打开参考手册的 1568 页。<br> <img src="https://images2.imgbox.com/95/c4/kW0grFLk_o.png" alt=""><br> 可以看到有个名为：IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00 的寄存器，寄存器地址为 0X020E005C，这个寄存器是 32 位的，但是只用到了最低 5 位，其中 bit0~bit3(MUX_MODE) 就是设置 GPIO1_IO00 的复用功能的。GPIO1_IO00 一共可以复用为 9 种功能 IO，分别对应 ALT0~ALT8，其中 ALT5 就是作为 GPIO1_IO00。GPIO1_IO00 还可以作为 I2C2_SCL、GPT1_CAPTURE1、ANATOP_OTG1_ID 等。</p> 
<h3><a id="13_IO_21"></a>1.3 IO配置</h3> 
<blockquote> 
 <p>IOMUX 由其左侧的 IOMUXC 控制（C表示Controler），IOMUXC 提供寄存器给用户进行配置， 它又分成 <strong>MUX Mode（IO模式控制）</strong> 以及 <strong>Pad Settings（Pad配置）</strong> 两个部分：<br> <img src="https://images2.imgbox.com/ac/e9/e3Evcka4_o.png" alt=""></p> 
</blockquote> 
<p>在 IOMUXC 外设中关于 MUX Mode 和 Pad Settings 寄存器命名格式如下：</p> 
<table><thead><tr><th>IOMUXC控制类型</th><th>寄存器名称</th></tr></thead><tbody><tr><td>MUX Mode</td><td>IOMUXC_SW_MUX_CTL_PAD_XXXX</td></tr><tr><td>Pad Settings</td><td>IOMUXC_SW_PAD_CTL_PAD_XXXX</td></tr></tbody></table> 
<blockquote> 
 <p>每个引脚都包含这两个寄存器，表中的XXXX表示引脚的名字</p> 
</blockquote> 
<h4><a id="131_MUX_Mode_33"></a>1.3.1 MUX Mode配置</h4> 
<blockquote> 
 <p><strong>MUX Mode</strong> 就是用来<code>配置引脚的复用功能</code>，即选择引脚具体是用于网络外设 ENET 的数据接收， 还是用于 PWM 外设的输出引脚，当然，也可以配置成普通的 IO 口，仅用于控制输出高低电平。</p> 
</blockquote> 
<p>以 GPIO1_IO04 引脚为例对 MUX 寄存器进行说明，该引脚相应的 MUX 寄存器在参考手册中的描述如下：</p> 
<p>该寄存器主要有两个配置域，分别是 <strong>SION</strong> 和 <strong>MUX_MODE</strong>。</p> 
<ul><li><strong>SION：</strong> 用于设置引脚在输出模式下同时开启输入通道。</li><li><strong>MUX_MODE：</strong> 使用 4 个寄存器位表示可选的 ALT0~ALT7 这 8 个模式。 
  <ul><li>如 ALT2 模式就是用于 USB 外设的 USB_OTG1_PWR 信号；</li><li>若配置为 ALT5 则引脚会用作普通的 GPIO 功能， 用于输出高、低电平。</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/eb/61/SqTc6XsF_o.png" alt=""></p> 
<h4><a id="132_Pad_Settings_47"></a>1.3.2 Pad Settings配置</h4> 
<blockquote> 
 <p><strong>Pad Settings</strong> 用于<code>配置引脚的属性</code>，例如驱动能力，是否使用上下拉电阻， 是否使用保持器，是否使用开漏模式以及使用施密特模式还是CMOS模式等。</p> 
</blockquote> 
<p>以 GPIO1_IO04 引脚中 PAD 寄存器在参考手册中的描述如下：</p> 
<p>相对来说 PAD 寄存器的配置项就更丰富了，而且图中仅是该寄存器的部分说明，如 HYS 设置使用施密特模式的滞后功能，PUS 配置上下拉电阻的阻值， 其它的还包含PUE、PKE、ODE、SPEED、DSE 及 SRE 的配置。</p> 
<p><img src="https://images2.imgbox.com/82/11/Q4SsYUcW_o.png" alt=""></p> 
<h4><a id="133_PAD_56"></a>1.3.3 PAD（可跳过不看）</h4> 
<p>PAD 代表了一个 i.MX6ULL 的 GPIO 引脚。在它的左侧是一系列信号通道及控制线，如 input_on 控制输入开关，Dir 控制引脚的输入输出方向，Data_out 控制引脚输出高低电平，Data_in 作为信号输入，这些信号都经过一个 IOMUX 的器件连接到左侧的寄存器。</p> 
<p><img src="https://images2.imgbox.com/16/54/tWNqEfeL_o.png" alt=""></p> 
<p><strong>①PAD引脚</strong><br> 代表一个i.MX6ULL的引脚。<br> <strong>②输出缓冲区</strong><br> 当输出缓冲区使能时，引脚被配置为输出模式。在输出缓冲区中，又包含了如下的属性配置：</p> 
<ul><li> <p>DSE驱动能力<br> <code>当IO用作输出的时候用来设置IO的驱动能力。</code>DSE可以调整芯片内部与引脚串联电阻R0的大小，从而改变引脚的驱动能力。例如，R0的初始值为260欧姆，在3.3V电压下其电流驱动能力为12.69mA，通过DSE可以把R0的值配置为原值的1/2、1/3…1/7等。</p> 
  <table><thead><tr><th>位设置</th><th>速度</th></tr></thead><tbody><tr><td>000</td><td>输出驱动关闭</td></tr><tr><td>001</td><td>R0(3.3V 下 R0 是 260Ω，1.8V 下 R0 是 150Ω，接 DDR 的时候是 240Ω)</td></tr><tr><td>010</td><td>R0/2</td></tr><tr><td>011</td><td>R0/3</td></tr><tr><td>100</td><td>R0/4</td></tr><tr><td>101</td><td>R0/5</td></tr><tr><td>110</td><td>R0/6</td></tr><tr><td>111</td><td>R0/7</td></tr></tbody></table></li><li> <p>SRE压摆率配置<br> <code>设置压摆率。</code>压摆率是指电压转换速率，可理解为电压由波谷升到波峰的时间。增大压摆率可减少输出电压的上升时间。i.MX6ULL的引脚通过SRE支持低速和高速压摆率这两种配置。当此位为0的时候是低压摆率，当为1的时候是高压摆率。压摆率是大信号特性，下面的带宽是小信号特性。</p> </li><li> <p>SPEED带宽配置<br> <code>设置IO的带宽。</code>分别可设置为50MHz、100MHz以及200MHz。带宽的意思是能通过这个IO口最高的信号频率，通俗点讲就是方波不失真，如果超过这个频率方波就变正弦波。但是这个带宽要区别于IO的翻转速率，IO的翻转速率的信号来自于GPIO这个外设，而IO的带宽只是限制了IO口引脚的物理特性，IO口的信号可以来自于内部定时器输出的PWM信号，也可以来自于GPIO翻转输出的信号，两者相比之下，PWM信号的频率是远远高于GPIO翻转输出的信号频率。</p> 
  <table><thead><tr><th>位设置</th><th>速度</th></tr></thead><tbody><tr><td>00</td><td>低速 50M</td></tr><tr><td>01</td><td>中速 100M</td></tr><tr><td>10</td><td>中速 100M</td></tr><tr><td>11</td><td>最大速度 200M</td></tr></tbody></table></li><li> <p>ODE开漏输出配置<br> <code>设置引脚是否工作在开漏输出模式。</code>在该模式时引脚可以输出高阻态和低电平，此位为0的时候禁止开路输出，当此位为1的时候就使能开路输出功能。输出高阻态时可由外部上拉电阻拉至高电平。开漏输出模式常用在一些通讯总线中，如I2C。</p> </li></ul> 
<p><strong>③输入缓冲区</strong><br> 当输入缓冲区使能时，引脚被配置为输入模式。在输入缓冲区中，又包含了如下的属性配置：</p> 
<ul><li>HYS滞后使能<br> <code>用来使能迟滞比较器。</code>i.MX6ULL的输入检测可以使用普通的CMOS检测或施密特触发器模式（滞后模式）。施密特触发器具有滞后效应，对正向和负向变化的输入信有不同的阈值电压。如果需要对输入波形进行整形的话可以使能此位。此位为0的时候禁止迟滞比较器，为1的时候使能迟滞比较器。常被用于电子开关、波形变换等场合，其转换特性和对比如下，如检测按键时，使用施密特模式即可起到消抖的功能。<br> <img src="https://images2.imgbox.com/c9/e9/eidr8y8n_o.png" alt=""><br> <img src="https://images2.imgbox.com/02/5d/8BTPVjFq_o.png" alt=""></li></ul> 
<p><strong>④Pull/Keeper上下拉、保持器</strong><br> 引脚的控制逻辑中还包含了上下拉、保持器的功能。芯片内部的上拉和下拉电阻可以将不确定的信号钳位在高、低电平，或小幅提高的电流输出能力，上拉提供输出电流，下拉提供输入电流。注意这些上下拉配置只是弱拉，对于类似I2C之类的总线，还是必须使用外部上拉电阻。i.MX6ULL芯片的电源模块中包含转换器，当转换器停止工作时，保持器会保持输入输出电压。</p> 
<p>上下拉、保持器可以通过如下属性配置：</p> 
<ul><li>PUS上下拉配置<br> <code>设置上下拉电阻。</code>PUS可配置项可选为100K欧下拉以及22K欧、47K欧及100K欧上拉。 
  <table><thead><tr><th>位设置</th><th>含义</th></tr></thead><tbody><tr><td>00</td><td>100K 下拉</td></tr><tr><td>01</td><td>47K 上拉</td></tr><tr><td>10</td><td>100K 上拉</td></tr><tr><td>11</td><td>22K 上拉</td></tr></tbody></table> </li><li>PUE上下拉、保持器选择<br> <code>上下拉功能和保持器功能是二选一的，可以通过PUE来选择。</code>当IO作为输入的时候，这个位用来设置 IO 使用上下拉还是状态保持器。当为0的时候使用状态保持器，当为1的时候使用上下拉。状态保持器在IO作为输入的时候才有用，顾名思义，就是当外部电路断电以后此IO口可以保持住以前的状态。</li><li>PKE上下拉、保持器配置<br> <code>用来使能或者禁止上下拉/状态保持器功能。</code>为0时禁止上下拉/状态保持器，为1时使能上下拉和状态保持器。</li></ul> 
<blockquote> 
 <p>注意，当引脚被配置为输出模式时，不管上下拉、保持器是什么配置，它们都会被关闭。</p> 
</blockquote> 
<h3><a id="14_GPIO_117"></a>1.4 GPIO配置</h3> 
<blockquote> 
 <p>GPIO 模块是每个 IO 都具有的外设，它具有 IO 控制最基本的功能，如输出高低电平、检测电平输入等。 它也占用 IOMUX 分配的复用信号，也就是说使用 GPIO 模块功能时同样需要使用 IOMUX 选中 GPIO 外设，对其 GPIO 的功能进行配置。<br> <img src="https://images2.imgbox.com/df/c5/m0p3kYDw_o.png" alt=""></p> 
</blockquote> 
<h4><a id="141_GDIR_121"></a>1.4.1 GDIR方向寄存器</h4> 
<p><code>设置某个 IO 的工作方向。</code>控制一个 GPIO 引脚时，要先用 GDIR 方向寄存器配置该引脚用于输出电平信号还是用作输入检测。 典型的例子是使用输出模式可以控制LED灯的亮灭，输入模式时可以用来检测按键是否按下。</p> 
<p>GDIR 寄存器的每一个数据位代表一个引脚的方向，对应的位被设置为0时该引脚为输入模式，被设置为1时该引脚为输出模式。</p> 
<blockquote> 
 <p>例如，对 GPIO1 的 GDIR 寄存器的 bit3 位被写入为 1，那么 GPIO1.3 引脚的模式即为输出。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f3/ff/jyeaeHfz_o.png" alt=""></p> 
<h4><a id="142_DR_130"></a>1.4.2 DR数据寄存器</h4> 
<p>DR 数据寄存器直接<code>代表了引脚的电平状态</code>，它也使用 1 个数据位表示 1 个引脚的电平，每位用 1 表示高电平，用 0 表示低电平。</p> 
<p>当 GDIR 方向寄存器设置引脚为输出模式时，写入 DR 数据寄存器对应的位即可控制该引脚输出的电平状态， 如这时 GPIO1 的 DR 寄存器的 bit4 被写入为 1，则引脚为输出高电平。</p> 
<p>当 GDIR 方向寄存器设置引脚为输入模式时，读取 DR 数据寄存器对应的位即可获取该引脚当前的输入电平状态，例如这里读取 GPIO1 的DR寄存器的 bit4，得到该位的值为 0，表示当前引脚的输入状态为低电平。<br> <img src="https://images2.imgbox.com/33/98/FovOUYpN_o.png" alt=""></p> 
<h4><a id="143_PSR_138"></a>1.4.3 PSR引脚状态寄存器</h4> 
<p><code>读取相应的位即可获取对应的 GPIO 的状态</code>，也就是 GPIO 的高低电平值。PSR 引脚状态寄存器相当于 DR 寄存器的简化版，它仅在 GDIR 方向寄存器设置为输入模式时有效，它的每个位表示一个引脚当前的输入电平状态。PSR 寄存器的权限是只读的，对它进行写操作是无效的。</p> 
<p>特别地，当引脚被配置成输出模式时，若 IOMUXC 中的 MUX 寄存器使能了 SION 功能（输出通道回环至输入）， 可以通过 PSR 寄存器读取回引脚的状态值。</p> 
<p><img src="https://images2.imgbox.com/e6/07/BuSGZrdu_o.png" alt=""></p> 
<h2><a id="_145"></a>二、引脚确定</h2> 
<p>我使用的是 <code>野火_EBF6ULL S1 Pro</code> 开发板<br> <img src="https://images2.imgbox.com/d8/96/HuI2DrXh_o.png" alt=""><br> 从原理图可看到 RGB 灯的三个阴极 R、G、B 连接分别连接至标号 <code>GPIO_4</code>、<code>CSI_HSYNC</code>、<code>CSI_VSYNC</code>， 这些标号实际上与配套核心板上 i.MX6ULL 芯片的引脚相连。由于引脚功能众多， 绘制原理图时不可避免地无法完全表示引脚信息的所有信息。而无论是具体的引脚名还是复用功能， 我们都无法直接得知这些具体是 i.MX6ULL 芯片的哪个引脚。我们需要知道这些引脚是对应的具体 GPIO，这样我们才能编写程序进行控制。</p> 
<p>由于还不清楚标号 <code>GPIO_4</code>、<code>CSI_HSYNC</code>、<code>CSI_VSYNC</code> 的具体引脚名，我们首先要在核心板原理图中查看它与 i.MX6ULL 芯片的关系。打开 <strong>《野火_EBF6ULL S1 邮票孔核心板_V1.0_原理图》</strong>，在PDF阅读器的搜索框输入前面的 <code>GPIO_4</code>、<code>CSI_HSYNC</code>、<code>CSI_VSYNC</code> 标号。</p> 
<p><img src="https://images2.imgbox.com/1b/b5/2yAsrbXV_o.png" alt=""><br> <img src="https://images2.imgbox.com/62/99/dov480fH_o.png" alt=""></p> 
<blockquote> 
 <p>查找到了 <code>GPIO_4</code> 信号的具体引脚名为 <code>GPIO1_IO04</code>。 但是当我们使用同样的方法查找时发现只能找到 <code>CSI_HSYNC</code>、<code>CSI_VSYNC</code>， 并没有我们熟悉的 GPIOx_IOx 标注的引脚名。这两个引脚默认情况下不用作 GPIO，而是用作摄像头的某一功能引脚，但是它可以复用为 GPIO，我们怎么找到对应的 GPIO 呢？</p> 
</blockquote> 
<ul><li> <p><strong>方法一：</strong><br> 在**《i.MX 6UltraLite Applications Processor Reference Manual》的第4章 External Signals and Pin Multiplexing** 搜索引脚名<br> <img src="https://images2.imgbox.com/7c/a7/EYD5PJu4_o.png" alt=""></p> </li><li> <p><strong>方法二：</strong><br> 在官方写好的文件 <strong>fsl_iomuxc.h（路径:SDK文件夹/devices/MCIMX6Y2/drivers/fsl_iomuxc.h）</strong> 中搜索引脚名<br> <img src="https://images2.imgbox.com/40/01/aw2ujKM7_o.png" alt=""></p> </li></ul> 
<p><strong>经查阅，我们把以上连接 LED 灯的各个 i.MX6ULL 芯片引脚总结出如表：</strong></p> 
<table><thead><tr><th>LED灯</th><th>原理图的标号</th><th>具体引脚名</th><th>GPIO端口及引脚编号</th></tr></thead><tbody><tr><td>R灯</td><td>GPIO_4</td><td>GPIO1_IO04</td><td>GPIO1_IO04</td></tr><tr><td>G灯</td><td>CSI_HSYNC</td><td>CSI_HSYNC</td><td>GPIO4_IO20</td></tr><tr><td>B灯</td><td>CSI_VSYNC</td><td>CSI_VSYNC</td><td>GPIO4_IO19</td></tr></tbody></table> 
<h2><a id="_173"></a>三、编写启动文件</h2> 
<p>在 Ubuntu 下创建 <code>start.S</code> 文件用于编写启动文件。<br> 在汇编文件中设置<code>“栈地址”</code>并执行跳转命令跳转到<code>main函数</code>执行C代码。</p> 
<h3><a id="31__176"></a>3.1 完整代码</h3> 
<pre><code class="prism language-cpp"><span class="token comment">/***********************第一部分*********************/</span>
  <span class="token punctuation">.</span>text            <span class="token comment">//代码段</span>
  <span class="token punctuation">.</span>align <span class="token number">2</span>         <span class="token comment">//设置2字节对齐</span>
  <span class="token punctuation">.</span>global _start   <span class="token comment">//定义一个全局标号</span>

<span class="token comment">/*************************第二部分*************************/</span>
  _start<span class="token operator">:</span>          <span class="token comment">//程序的开始</span>
    b reset      <span class="token comment">//跳转到reset标号处</span>

<span class="token comment">/*************************第三部分*************************/</span>
reset<span class="token operator">:</span>
   mrc     p15<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> r0<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c0<span class="token punctuation">,</span> <span class="token number">0</span>     <span class="token comment">/*  将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中   */</span>
   bic     r0<span class="token punctuation">,</span>  r0<span class="token punctuation">,</span> #<span class="token punctuation">(</span><span class="token number">0x1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>     <span class="token comment">/*  清除第12位（I位）禁用 I Cache  */</span>
   bic     r0<span class="token punctuation">,</span>  r0<span class="token punctuation">,</span> #<span class="token punctuation">(</span><span class="token number">0x1</span> <span class="token operator">&lt;&lt;</span>  <span class="token number">2</span><span class="token punctuation">)</span>     <span class="token comment">/*  清除第 2位（C位）禁用 D Cache  */</span>
   bic     r0<span class="token punctuation">,</span>  r0<span class="token punctuation">,</span> #<span class="token number">0x2</span>             <span class="token comment">/*  清除第 1位（A位）禁止严格对齐   */</span>
   bic     r0<span class="token punctuation">,</span>  r0<span class="token punctuation">,</span> #<span class="token punctuation">(</span><span class="token number">0x1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">11</span><span class="token punctuation">)</span>     <span class="token comment">/*  清除第11位（Z位）分支预测   */</span>
   bic     r0<span class="token punctuation">,</span>  r0<span class="token punctuation">,</span> #<span class="token number">0x1</span>             <span class="token comment">/*  清除第 0位（M位）禁用 MMU   */</span>
   mcr     p15<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> r0<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c0<span class="token punctuation">,</span> <span class="token number">0</span>     <span class="token comment">/*  将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中   */</span>

<span class="token comment">/***********************第四部分*********************/</span>
      ldr sp<span class="token punctuation">,</span> <span class="token operator">=</span><span class="token number">0x84000000</span>   <span class="token comment">//设置栈地址64M</span>
      b main                <span class="token comment">//跳转到main函数</span>

<span class="token comment">/***********************第五部分*******************/</span>
    <span class="token comment">/*进入死循环*/</span>
  loop<span class="token operator">:</span>
      b loop
</code></pre> 
<h3><a id="32__206"></a>3.2 分析代码</h3> 
<ul><li><strong>第一部分</strong><br> <code>.text</code> 定义代码段。<br> <code>.align 2</code> 设置字节对齐。<br> <code>.global _start</code> 生命全局标号_start。</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">/*************************第一部分*************************/</span>
<span class="token punctuation">.</span>text            <span class="token comment">//代码段</span>
<span class="token punctuation">.</span>align <span class="token number">2</span>         <span class="token comment">//设置2字节对齐</span>
<span class="token punctuation">.</span>global _start   <span class="token comment">//定义一个全局标号</span>
</code></pre> 
<ul><li><strong>第二部分</strong><br> <code>_start:</code> 定义标号_start: ，它位于汇编的最前面，说以会首先被执行。<br> <code>b reset</code> 使用b指令将程序跳转到reset标号处。</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">/*************************第二部分*************************/</span>
_start<span class="token operator">:</span>          <span class="token comment">//程序的开始</span>
   b reset      <span class="token comment">//跳转到reset标号处</span>
</code></pre> 
<ul><li><strong>第三部分</strong><br> 通过<code>修改CP15寄存器（系统控制寄存器）</code> <strong>关闭 I Cache 、D Cache、MMU</strong> 等等。<br> 我们暂时用不到的功能，如果开启可能会影响我们裸机运行，为避免不必要的麻烦暂时关闭这些功能。</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">/*************************第三部分*************************/</span>
reset<span class="token operator">:</span>
   mrc     p15<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> r0<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c0<span class="token punctuation">,</span> <span class="token number">0</span>     <span class="token comment">/*  将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中   */</span>
   bic     r0<span class="token punctuation">,</span>  r0<span class="token punctuation">,</span> #<span class="token punctuation">(</span><span class="token number">0x1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>     <span class="token comment">/*  清除第12位（I位）禁用 I Cache  */</span>
   bic     r0<span class="token punctuation">,</span>  r0<span class="token punctuation">,</span> #<span class="token punctuation">(</span><span class="token number">0x1</span> <span class="token operator">&lt;&lt;</span>  <span class="token number">2</span><span class="token punctuation">)</span>     <span class="token comment">/*  清除第 2位（C位）禁用 D Cache  */</span>
   bic     r0<span class="token punctuation">,</span>  r0<span class="token punctuation">,</span> #<span class="token number">0x2</span>             <span class="token comment">/*  清除第 1位（A位）禁止严格对齐   */</span>
   bic     r0<span class="token punctuation">,</span>  r0<span class="token punctuation">,</span> #<span class="token punctuation">(</span><span class="token number">0x1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">11</span><span class="token punctuation">)</span>     <span class="token comment">/*  清除第11位（Z位）分支预测   */</span>
   bic     r0<span class="token punctuation">,</span>  r0<span class="token punctuation">,</span> #<span class="token number">0x1</span>             <span class="token comment">/*  清除第 0位（M位）禁用 MMU   */</span>
   mcr     p15<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> r0<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c0<span class="token punctuation">,</span> <span class="token number">0</span>     <span class="token comment">/*  将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中   */</span>
</code></pre> 
<ul><li><strong>第四部分</strong><br> <code>ldr sp, =0x84000000</code> 用于设置栈指针。野火i.MX6ULL开发板标配512M的DDR内存，裸机开发用不了这么多。程序中我们将栈地址设置到DDR的64M地址处。 这个值也可以根据需要自行定义。<br> <code>b main </code> 只用跳转指令跳转到main函数中执行。</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">/***********************第四部分*********************/</span>
      ldr sp<span class="token punctuation">,</span> <span class="token operator">=</span><span class="token number">0x84000000</span>   <span class="token comment">//设置栈地址64M</span>
      b main                <span class="token comment">//跳转到main函数</span>
</code></pre> 
<ul><li><strong>第五部分</strong><br> <code>b loop</code> 是“无返回”的跳转指令。正常情况下，不会执行第五部分代码。</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">/***********************第五部分*******************/</span>
  <span class="token comment">/*进入死循环*/</span>
  loop<span class="token operator">:</span>
      b loop
</code></pre> 
<h2><a id="_256"></a>四、编程流程</h2> 
<p><strong>1. 开启GPIO时钟</strong><br> <strong>2. 设置引脚的复用功能以及引脚属性</strong><br> <strong>3. 设置引脚方向以及输出电平</strong></p> 
<h2><a id="C_261"></a>五、编写C语言代码</h2> 
<p>在 Ubuntu 下创建 <code>led.c</code> 文件用于驱动 LED 闪烁。</p> 
<h3><a id="51__263"></a>5.1 完整代码</h3> 
<pre><code class="prism language-cpp"><span class="token comment">//时钟控制寄存器</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CCM_CCGR1</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x20C406C</span></span></span>
<span class="token comment">//GPIO1_04复用功能选择寄存器</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x20E006C</span></span></span>
<span class="token comment">//PAD属性设置寄存器</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x20E02F8</span></span></span>
<span class="token comment">//GPIO方向设置寄存器</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GPIO1_GDIR</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x0209C004</span></span></span>
<span class="token comment">//GPIO输出状态寄存器</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GPIO1_DR</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x0209C000</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">uint32_t</span>  <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">int</span></span></span>

<span class="token comment">/*简单延时函数*/</span>
<span class="token keyword">void</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> count<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">volatile</span> <span class="token keyword">uint32_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
      <span class="token function">__asm</span><span class="token punctuation">(</span><span class="token string">"NOP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 调用nop空指令 */</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token operator">*</span><span class="token punctuation">(</span>CCM_CCGR1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">;</span>                     <span class="token comment">//开启GPIO1的时钟</span>
   <span class="token operator">*</span><span class="token punctuation">(</span>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x5</span><span class="token punctuation">;</span>     <span class="token comment">//设置PAD复用功能为GPIO</span>
   <span class="token operator">*</span><span class="token punctuation">(</span>IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x1F838</span><span class="token punctuation">;</span> <span class="token comment">//设置PAD属性</span>
   <span class="token operator">*</span><span class="token punctuation">(</span>GPIO1_GDIR<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">;</span>                          <span class="token comment">//设置GPIO为输出模式</span>
   <span class="token operator">*</span><span class="token punctuation">(</span>GPIO1_DR<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>                             <span class="token comment">//设置输出电平为低电平</span>

   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
      <span class="token operator">*</span><span class="token punctuation">(</span>GPIO1_DR<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>
      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">0xFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">*</span><span class="token punctuation">(</span>GPIO1_DR<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>
      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">0xFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="52__306"></a>5.2 分析代码</h3> 
<ul><li><strong>定义GPIO相关寄存器</strong><br> 这部分内容与“汇编点亮LED灯”中定义的寄存器相同， 只不过这里使用（<code>volatile unsigned long*</code>）<strong>将地址强制转化为指针</strong>。<br> <code>配置时钟使能寄存器地址</code> 设置时钟控制寄存器CCM_CCGR1的地址如下：<br> <img src="https://images2.imgbox.com/6c/95/hWQIb2Si_o.png" alt=""><br> <code>配置MUX Mode寄存器地址</code> MUX Mode用于设置GPIO1_IO04的复用功能。配置成普通的IO口，仅用于控制输出高低电平。寄存器地址如下：<br> <img src="https://images2.imgbox.com/9c/fb/JYGvm07h_o.png" alt=""><br> <code>配置Pad Settings寄存器地址</code> Pad Settings用于设置GPIO的PAD属性。例如驱动能力，是否使用上下拉电阻， 是否使用保持器，是否使用开漏模式以及使用施密特模式还是CMOS模式等。寄存器地址如下：<br> <img src="https://images2.imgbox.com/d7/af/tYlnmSmN_o.png" alt=""></li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">//时钟控制寄存器</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CCM_CCGR1</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x20C406C</span></span></span>
<span class="token comment">//GPIO1_04复用功能选择寄存器</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x20E006C</span></span></span>
<span class="token comment">//PAD属性设置寄存器</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x20E02F8</span></span></span>
<span class="token comment">//GPIO方向设置寄存器</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GPIO1_GDIR</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x0209C004</span></span></span>
<span class="token comment">//GPIO输出状态寄存器</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GPIO1_DR</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x0209C000</span></span></span>
</code></pre> 
<ul><li><strong>实现简单的软件延时函数</strong><br> 在函数体中调用 <code>__asm(“NOP”)</code> 嵌入汇编指令， 这条语句表示CPU什么都不做。</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">/*简单延时函数*/</span>
<span class="token keyword">void</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> count<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">volatile</span> <span class="token keyword">uint32_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
      <span class="token function">__asm</span><span class="token punctuation">(</span><span class="token string">"NOP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 调用nop空指令 */</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>向寄存器中写入值</strong><br> 在第一部分代码中我们<strong>将寄存器地址强制转换为指针</strong>，这里使用使用<code>“*”</code>号再次“寻址”。</li><li><strong>开启GPIO1的时钟</strong><br> “<code>*(CCM_CCGR1) = 0xFFFFFFFF;</code>” 代码表示将0xFFFFFFFF写入指针CCM_CCGR1所指定的地址中。<br> 设置的时钟控制寄存器 <code>CCM_CCGR1</code>。<br> <img src="https://images2.imgbox.com/a9/1e/zLgCLJIb_o.png" alt=""><br> 从上表中可以看出CCM_CCGR1[26:27]用于使能GPIO1的时钟，这里不仅仅设置时钟的开或者关， 还可以设置在芯片在不同工作模式下的时钟状态如下表：</li></ul> 
<table><thead><tr><th>CCM_CCGR1[26:27]的值</th><th>时钟状态描述</th></tr></thead><tbody><tr><td>00</td><td>时钟在所有模式下都是关闭的</td></tr><tr><td>01</td><td>时钟在运行模式下为开，但在等待和停止模式下为关</td></tr><tr><td>10</td><td>保留</td></tr><tr><td>11</td><td>除停止模式外，时钟一直开启</td></tr><tr><td>我们将CCM_CCGR1[26:27]设置为<code>11</code>（二进制）即可。仔细观察可以发现发现CCM_CCGR1寄存器默认全为1，即默认开启了时钟。 为了程序规范我们再次使用代码开启时钟。将CCM_CCGR1寄存器<code>设置全为1</code>。</td><td></td></tr></tbody></table> 
<ul><li><strong>设置引脚复用功能为GPIO</strong><br> 这里设置的是GPIO1_04的引脚复用寄存器，我们直接搜索 <code>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04</code> 可以找到如下所示的寄存器。<br> <img src="https://images2.imgbox.com/c7/ae/1UIIaZxR_o.png" alt=""></li></ul> 
<p>从上图可知IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04[MUX_MODE]=0101(二进制)时GPIO1_04复用功能是GPIO。所以在程序中我们将<code>0x5</code>写入该寄存即可。</p> 
<pre><code class="prism language-cpp"><span class="token operator">*</span><span class="token punctuation">(</span>CCM_CCGR1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">;</span>                     <span class="token comment">//开启GPIO1的时钟</span>
<span class="token operator">*</span><span class="token punctuation">(</span>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x5</span><span class="token punctuation">;</span>     <span class="token comment">//设置PAD复用功能为GPIO</span>
<span class="token operator">*</span><span class="token punctuation">(</span>IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x1F838</span><span class="token punctuation">;</span> <span class="token comment">//设置PAD属性</span>
<span class="token operator">*</span><span class="token punctuation">(</span>GPIO1_GDIR<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">;</span>                          <span class="token comment">//设置GPIO为输出模式</span>
<span class="token operator">*</span><span class="token punctuation">(</span>GPIO1_DR<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>                             <span class="token comment">//设置输出电平为低电平</span>
</code></pre> 
<ul><li><strong>不断改变RGB红灯所在引脚的高低电平</strong></li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token operator">*</span><span class="token punctuation">(</span>GPIO1_DR<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">0xFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">*</span><span class="token punctuation">(</span>GPIO1_DR<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">0xFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_380"></a>六、编写链接脚本</h2> 
<blockquote> 
 <p>写好的代码（无论是汇编还是C语言）都要经过编译、汇编、链接等步骤生成二进制文件或者可供下载的文件。在编译阶编译器会对每个源文件进行语法检查并生成对应的汇编语言，汇编是将汇编文件转化为机器码。</p> 
 <p>使用 <code>arm-none-eabi-gcc -g -c led.S -o led.o</code> 命令完成源码的编译、汇编工作，生成了 <code>.o</code>文件。编译和汇编是针对单个源文件，也就编译完成后一个源文件（<code>.c</code>，<code>.S</code> 或 <code>.s</code>）对应一个 <code>.o</code> 文件。程序链接阶段就会将这些 <code>.o</code> 链接成一个文件。</p> 
 <p><strong>链接脚本的作用就是告诉编译器怎么链接这些文件，比如那个文件放在最前面，程序的代码段、数据段、bss段分别放在什么位置等等。</strong></p> 
</blockquote> 
<p>在 Ubuntu 下创建 <code>led.lds</code> 链接脚本。</p> 
<h3><a id="61__389"></a>6.1 完整代码</h3> 
<pre><code class="prism language-cpp"> <span class="token function">ENTRY</span><span class="token punctuation">(</span>_start<span class="token punctuation">)</span>
 SECTIONS <span class="token punctuation">{<!-- --></span>
   <span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>

   <span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">.</span>text <span class="token operator">:</span>
   <span class="token punctuation">{<!-- --></span>
   start<span class="token punctuation">.</span><span class="token function">o</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span>
   <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">.</span>data <span class="token operator">:</span>
   <span class="token punctuation">{<!-- --></span>
   <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">.</span>bss <span class="token operator">:</span>
   <span class="token punctuation">{<!-- --></span>
   <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>bss<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="62__416"></a>6.2 分析代码</h3> 
<ul><li><strong>指定程序的入口</strong><br> <code>ENTRY(_start)</code> 用于指定程序的入口，<code>ENTRY()</code> 是设置入口地址的命令， <code>“_start”</code> 是程序的入口，led程序的入口地址位于 <code>start.S</code> 的 <code>“_start”</code> 标号处。</li></ul> 
<pre><code class="prism language-cpp"> <span class="token function">ENTRY</span><span class="token punctuation">(</span>_start<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>定义SECTIONS</strong><br> <code>SECTIONS</code> 可以理解为是一块区域，我们在这块区域排布我们的代码，链接时链接器就会按照这里的指示链接我们的代码。</li></ul> 
<pre><code class="prism language-cpp"> SECTIONS <span class="token punctuation">{<!-- --></span>
···
···
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>定义链接起始地址</strong><br> <code>“.”</code> 运算符代表当前位置。 我们在SECTION的最开始使用 <code>“.= 0x80000000”</code> 就是将链接起始地址设置为0x80000000。</li></ul> 
<pre><code class="prism language-cpp"><span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li> <p><strong>设置字节对齐</strong><br> <code>“. = ALIGN(4);”</code> 它表示从当前位置开始执行四字节对齐。假设当前位置为0x80000001，执行该命令后当前地址将会空出三个字节转到0x80000004地址处。</p> </li><li> <p><strong>设置代码段</strong><br> <code>“.text :”</code> 用于定义代码段，固定的语法要求，我们按照要求写即可。在“{}”中指定那些内容放在代码段。<br> 将 <code>start.o</code> 中的代码放到代码段的最前面。<code>start.S</code>是启动代码应当首先被执行，所以通常情况下要把它放到代码段的最前面，其他源文件的代码按照系统默认的排放顺序即可，通配符 <code>“*”</code> 在这里表示其他剩余所有的 <code>.o</code>文件。</p> </li></ul> 
<pre><code class="prism language-cpp">   <span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">.</span>text <span class="token operator">:</span>
   <span class="token punctuation">{<!-- --></span>
   start<span class="token punctuation">.</span><span class="token function">o</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span>
   <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>设置数据段</strong><br> 同设置代码段类似，首先设置字节对齐，然后定义代码段。在数据段里使用 <code>“*”</code> 通配符， 将所有源文件中的代码添加到这个数据段中。</li></ul> 
<pre><code class="prism language-cpp">   <span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">.</span>data <span class="token operator">:</span>
   <span class="token punctuation">{<!-- --></span>
   <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>设置BSS段</strong><br> 设置方法与设置数据段完全相同。</li></ul> 
<pre><code class="prism language-cpp"><span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">.</span>bss <span class="token operator">:</span>
   <span class="token punctuation">{<!-- --></span>
   <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>bss<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
</code></pre> 
<h2><a id="makefile_473"></a>七、编写makefile文件</h2> 
<blockquote> 
 <p>程序编写完成后需要依次输入编译、链接、格式转换命令才能最终生成二进制文件。这种编译方式效率低、容易出错。</p> 
 <p>使用<code>makefile</code>只需要在所在文件夹下执行<code>make</code>命令，makefile工具便会自动完成程序的编译、链接、格式转换等工作。正常情况下我们可以在当前目录看到生成的一些中间文件以及我们期待的<code>.bin</code>文件。</p> 
</blockquote> 
<p>在 Ubuntu 下创建 <code>makefile</code> 文件。</p> 
<h3><a id="71__480"></a>7.1 完整代码</h3> 
<pre><code class="prism language-cpp"> all<span class="token operator">:</span> start<span class="token punctuation">.</span>o led<span class="token punctuation">.</span>o
    arm<span class="token operator">-</span>none<span class="token operator">-</span>eabi<span class="token operator">-</span>ld <span class="token operator">-</span>Tled<span class="token punctuation">.</span>lds  $<span class="token operator">^</span> <span class="token operator">-</span>o led<span class="token punctuation">.</span>elf
    arm<span class="token operator">-</span>none<span class="token operator">-</span>eabi<span class="token operator">-</span>objcopy <span class="token operator">-</span>O binary <span class="token operator">-</span>S <span class="token operator">-</span>g led<span class="token punctuation">.</span>elf led<span class="token punctuation">.</span>bin

  <span class="token operator">%</span><span class="token punctuation">.</span>o <span class="token operator">:</span> <span class="token operator">%</span><span class="token punctuation">.</span>S
    arm<span class="token operator">-</span>none<span class="token operator">-</span>eabi<span class="token operator">-</span>gcc <span class="token operator">-</span>g <span class="token operator">-</span>c $<span class="token operator">^</span> <span class="token operator">-</span>o start<span class="token punctuation">.</span>o
  <span class="token operator">%</span><span class="token punctuation">.</span>o <span class="token operator">:</span> <span class="token operator">%</span><span class="token punctuation">.</span>c
    arm<span class="token operator">-</span>none<span class="token operator">-</span>eabi<span class="token operator">-</span>gcc <span class="token operator">-</span>g <span class="token operator">-</span>c $<span class="token operator">^</span> <span class="token operator">-</span>o led<span class="token punctuation">.</span>o


  <span class="token punctuation">.</span>PHONY<span class="token operator">:</span> clean
  clean<span class="token operator">:</span>
    rm <span class="token operator">*</span><span class="token punctuation">.</span>o <span class="token operator">*</span><span class="token punctuation">.</span>elf <span class="token operator">*</span><span class="token punctuation">.</span>bin
</code></pre> 
<h3><a id="72__496"></a>7.2 分析代码</h3> 
<ul><li><strong>添加最终目标以及依赖文件</strong></li></ul> 
<pre><code class="prism language-cpp"> all<span class="token operator">:</span> start<span class="token punctuation">.</span>o led<span class="token punctuation">.</span>o
</code></pre> 
<ul><li><strong>添加链接命令</strong><br> <code>“-Tled.lds”</code> 表示使用led.lds链接脚本链接程序。<br> <code>“$^”</code> 代表所有的依赖文件。<br> <code>“-o”</code> 指定输出文件名。</li></ul> 
<pre><code class="prism language-cpp">    arm<span class="token operator">-</span>none<span class="token operator">-</span>eabi<span class="token operator">-</span>ld <span class="token operator">-</span>Tled<span class="token punctuation">.</span>lds  $<span class="token operator">^</span> <span class="token operator">-</span>o led<span class="token punctuation">.</span>elf
</code></pre> 
<ul><li><strong>添加格式转换命令</strong><br> <code>“-O binary”</code> 指定输出二进制文件。<br> <code>“-S”</code> 不从源文件中复制重定位信息和符号信息。<br> <code>“-g”</code> 不从源文件中复制可调试信息。</li></ul> 
<pre><code class="prism language-cpp">    arm<span class="token operator">-</span>none<span class="token operator">-</span>eabi<span class="token operator">-</span>objcopy <span class="token operator">-</span>O binary <span class="token operator">-</span>S <span class="token operator">-</span>g led<span class="token punctuation">.</span>elf led<span class="token punctuation">.</span>bin
</code></pre> 
<ul><li><strong>添加汇编文件编译命令</strong><br> <code>“$^”</code> 替代要编译的源文件。</li></ul> 
<pre><code class="prism language-cpp">  <span class="token operator">%</span><span class="token punctuation">.</span>o <span class="token operator">:</span> <span class="token operator">%</span><span class="token punctuation">.</span>S
    arm<span class="token operator">-</span>none<span class="token operator">-</span>eabi<span class="token operator">-</span>gcc <span class="token operator">-</span>g <span class="token operator">-</span>c $<span class="token operator">^</span> <span class="token operator">-</span>o start<span class="token punctuation">.</span>o
</code></pre> 
<ul><li><strong>添加编译C文件的命令</strong><br> <code>“$^”</code> 替代要编译的源文件。</li></ul> 
<pre><code class="prism language-cpp">  <span class="token operator">%</span><span class="token punctuation">.</span>o <span class="token operator">:</span> <span class="token operator">%</span><span class="token punctuation">.</span>c
    arm<span class="token operator">-</span>none<span class="token operator">-</span>eabi<span class="token operator">-</span>gcc <span class="token operator">-</span>g <span class="token operator">-</span>c $<span class="token operator">^</span> <span class="token operator">-</span>o led<span class="token punctuation">.</span>o
</code></pre> 
<ul><li><strong>添加清理命令</strong><br> <code>“.PHONY”</code> 定义了伪目标“clean”。伪目标一般没有依赖，并且 <code>“clean”</code> 伪目标一般放在Makefile文件的末尾。<br> <code>“clean”</code> 为目标用于删除make生成的文件。</li></ul> 
<pre><code class="prism language-cpp">  <span class="token punctuation">.</span>PHONY<span class="token operator">:</span> clean
  clean<span class="token operator">:</span>
    rm <span class="token operator">*</span><span class="token punctuation">.</span>o <span class="token operator">*</span><span class="token punctuation">.</span>elf <span class="token operator">*</span><span class="token punctuation">.</span>bin
</code></pre> 
<h2><a id="_536"></a>八、编译下载验证</h2> 
<h3><a id="81__537"></a>8.1 编译代码</h3> 
<pre><code class="prism language-cpp">make
</code></pre> 
<p>执行make命令，生成led.bin文件。</p> 
<h3><a id="82__543"></a>8.2 代码烧写</h3> 
<p>编译成功后会在当前文件夹下生成.bin文件，这个.bin文件也不能直接放到开发板上运行， 这次是因为需要在.bin文件缺少启动相关信息。</p> 
<p>为二进制文件添加头部信息并烧写到SD卡。查看 <a href="https://leung-manwah.blog.csdn.net/article/details/127508651?spm=1001.2014.3001.5502" rel="nofollow">IMX6ULL学习笔记（12）——通过SD卡启动官方SDK程序</a></p> 
<p>进入烧写工具目录，执行 <code>./mkimage.sh &lt;烧写文件路径&gt;</code> 命令，例如要烧写的 led.bin 位于 home 目录下，则烧写命令为 <code>./mkimage.sh /home/led.bin</code>。</p> 
<blockquote> 
 <p>执行上一步后会列出linux下可烧写的磁盘，选择你插入的SD卡即可。这一步 非常危险！！！一定要确定选择的是你插入的SD卡！！，如果选错很可能破坏你电脑磁盘内容，造成数据损坏！！！ 确定磁盘后SD卡以“sd”开头，选择“sd”后面的字符即可。例如要烧写的sd卡是“sdb”则输入“b”即可。</p> 
</blockquote> 
<h3><a id="83__552"></a>8.3 实验现象</h3> 
<p>将开发板设置为SD卡启动，接入SD卡，开发板上电，可以看到开发板RGB红灯闪烁。</p> 
<p><img src="https://images2.imgbox.com/00/31/QyioBk1m_o.gif" alt=""></p> 
<hr> 
<p>• 由 <a href="https://blog.csdn.net/qq_36347513">Leung</a> 写于 2022 年 12 月 25 日</p> 
<p>• 参考：<a href="https://doc.embedfire.com/linux/imx6/driver/zh/latest/bare_metal/gcc_led.html" rel="nofollow">5. LED灯进阶——C语言实现</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c5ca15093144d1fca2095e58ebabc77b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言及算法设计课程实验二：数据类型、运算符和简单的输入输出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/855c46b9e8fbfe58b21e219e4dc9213b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Word 排版：插入题注</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>