<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序算法的归纳与比较，还有相关视频哦【for_wind】 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排序算法的归纳与比较，还有相关视频哦【for_wind】" />
<meta property="og:description" content="好久没有看算法相关的东西，把以前的笔记整理一下，当作复习。加油~~//for_wind
排序算法的归纳与比较 名称插入排序合并排序堆排序快速排序计数排序基数排序桶排序思路通过比较在已排序的数组A[1,...,j-1]中插入新数据A[j]，形成新的已排序数组A[1,...,j]（分解）分成2个子序列；
（解决）对子序列递归地进行排序
（合并）合并已经排序的子序列先建堆，交换根元素A[i]和A[n]，更新保持堆性质，重复以上，直到堆大小从n-1减为2（分解）划分
（解决）递归调用
（合并）无，因为就地排序假设元素均介于0到k的整数。
利用数组下标假设n个d位数，每个位数k种可能的值。
按位排序（从低到高）假设输入元素独立均匀地分布在区域[0,1)上，划分该区域为桶，分别排序策略增量法
原地排序
稳定分治
非原地排序
稳定
原地排序
不稳定分治
原地排序
不稳定特殊假设
非原地排序
稳定特殊假设
非原地排序
稳定特殊假设
非原地排序
稳定运行时间o(n^2)o(nlgn)o(nlgn)o(n^2)
o(nlgn)o(k&#43;n)o(d(k&#43;n))
o(b(r)*r(k&#43;2^r))o(n)要点 合并步骤最关键堆的操作随机化划分确定小于等于i的元素个数先按最低的有效位排序 应用情况基本已排序 优先级队列 参考思路中假设参考思路中假设参考思路中假设 其他： 前4种是比较排序，比较排序可视为决策树（一颗满二叉树）。排序算法的执行对应于遍历一条从树的根到页节点的路径。一个比较算法最坏情况比较次数与其决策树的高度相等，为lgn。为此，任意一个比较算法最坏的情况下都需要o(nlogn)次比较。此外，堆排序和合并排序是渐进最优的比较排序算法。而后三种算法，下界o(nlogn)对其不适用。 相关视频《6分钟演示15种排序算法》：点击打开链接 。值得一看，另外一笑。嘻嘻。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/52044dd4ff17020446c7c555f1a9404b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-08-20T22:17:20+08:00" />
<meta property="article:modified_time" content="2013-08-20T22:17:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序算法的归纳与比较，还有相关视频哦【for_wind】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#009900">好久没有看算法相关的东西，把以前的笔记整理一下，当作复习。加油~~//for_wind</span></p> 
<p> </p> 
<table border="1" width="700" cellspacing="0" cellpadding="1"><caption>
   排序算法的归纳与比较 
 </caption><tbody><tr><td><strong>名称</strong></td><td><strong>插入排序</strong></td><td><strong>合并排序</strong></td><td><strong>堆排序</strong></td><td><strong>快速排序</strong></td><td><strong>计数排序</strong></td><td width="100"><strong>基数排序</strong></td><td width="100"><strong>桶排序</strong></td></tr><tr><td>思路</td><td width="100">通过比较在已排序的数组A[1,...,j-1]中插入新数据A[j]，形成新的已排序数组A[1,...,j]</td><td width="100">（分解）分成2个子序列；<br> （解决）对子序列递归地进行排序<br> （合并）合并已经排序的子序列</td><td width="100">先建堆，交换根元素A[i]和A[n]，更新保持堆性质，重复以上，直到堆大小从n-1减为2</td><td width="80">（分解）划分<br> （解决）递归调用<br> （合并）无，因为就地排序</td><td width="80">假设元素均介于0到k的整数。<br> 利用数组下标</td><td width="100">假设n个d位数，每个位数k种可能的值。<br> 按位排序（从低到高）</td><td width="100">假设输入元素独立均匀地分布在区域[0,1)上，划分该区域为桶，分别排序</td></tr><tr><td>策略</td><td>增量法<br> 原地排序<br> 稳定</td><td>分治<br> 非原地排序<br> 稳定</td><td><br> 原地排序<br> 不稳定</td><td>分治<br> 原地排序<br> 不稳定</td><td>特殊假设<br> 非原地排序<br> 稳定</td><td>特殊假设<br> 非原地排序<br> 稳定</td><td>特殊假设<br> 非原地排序<br> 稳定</td></tr><tr><td>运行时间</td><td>o(n^2)</td><td>o(nlgn)</td><td>o(nlgn)</td><td>o(n^2)<br> o(nlgn)</td><td>o(k+n)</td><td>o(d(k+n))<br> o(b(r)*r(k+2^r))</td><td>o(n)</td></tr><tr><td>要点</td><td> </td><td>合并步骤最关键</td><td>堆的操作</td><td>随机化划分</td><td>确定小于等于i的元素个数</td><td>先按最低的有效位排序</td><td> </td></tr><tr><td>应用情况</td><td>基本已排序</td><td> </td><td>优先级队列</td><td> </td><td>参考思路中假设</td><td>参考思路中假设</td><td>参考思路中假设</td></tr></tbody></table> 
<strong>其他</strong>： 
<span style="color:#006600">前4种是比较排序，比较排序可视为决策树（一颗满二叉树）。排序算法的执行对应于遍历一条从树的根到页节点的路径。一个比较算法最坏情况比较次数与其决策树的高度相等，为lgn。为此，任意一个比较算法最坏的情况下都需要o(nlogn)次比较。此外，堆排序和合并排序是渐进最优的比较排序算法。而后三种算法，下界o(nlogn)对其不适用。</span> 
<p></p> 
<p><strong>相关视频</strong>《6分钟演示15种排序算法》：<a target="_blank" href="http://www.bilibili.tv/video/av685670/" rel="nofollow noopener noreferrer">点击打开链接</a> 。值得一看，另外一笑。嘻嘻。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7f2bb399c63bff49e74e81178662f920/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VBO的详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/834ac797f0a48ae0d8835afbf1b4e78d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cognos配置邮件自动发送功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>