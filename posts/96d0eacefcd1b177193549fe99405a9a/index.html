<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA集合类实现原理简述-Part1  Map - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA集合类实现原理简述-Part1  Map" />
<meta property="og:description" content=" 1 HashMap Hashmap的底层数据结构为散列表，底层实现结构为数组和链表，当一个key-val对要插入时，会根据key计算出hashcode，然后映射到数组的某个位置。如果数组的位置已经被占用且发生了冲突。则通过链表地址发来解决这个冲突。
插入过程
put（key,val）,对key进行HASH得到hashcode,通过hashcode得到位置如果未占用，直接将这个key-val存放。 如果发生了冲突，则通过链地址法来解决冲突，从这个位置关联一个链表，在链表的节点上（bucket）上讲key-val存放其中。 取值过程
get（key）,对key进行HASH得到hashcode,通过hashcode在数组上找到这个位置，如果这个 位置上只有一个entry对（即没有关联链表），则直接取出即可。 如果这个位置上有多个entry对，即有关联一个链表，则对这个链表进行遍历，如果entry对的 key等于要查询的key，则将entry对取出。 与HashTable的区别 Hashtable的所有方法都加了synchronized是线程安全的，HashMap是非线程安全的 Hashtable不可以设置Null的key,而HashMap是可以设置为Null的key 单线程时Hashtable速度较慢
通过HashMap达到线程安全目的 我们也可以让HashMap同步 Map m = Collections.synchronizeMap(hashMap); 这样是通过一个互斥的对象锁，来达到线程同步的目的 但这样的实现在并发场景上效率太低 后来concurrent包下的ConcurrentHashMap，通过在数据结构上真正的实现了对高并发的支持
2 TreeMap 线程不安全内部红黑树实现 3 LinkedHashMap 内部的entry&lt; k,v &gt;除了保存当前元素的引入，还保存前一个、后一个元素的引用是从HashMap继承对插入顺序是有序的可实现LRU算法线程不安全 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/96d0eacefcd1b177193549fe99405a9a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-11-28T23:56:38+08:00" />
<meta property="article:modified_time" content="2016-11-28T23:56:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA集合类实现原理简述-Part1  Map</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="1-hashmap">1 HashMap</h3> 
<p>Hashmap的底层数据结构为<strong>散列表，底层实现结构为数组和链表</strong>，当一个key-val对要插入时，会根据key计算出hashcode，然后映射到数组的某个位置。如果数组的位置已经被占用且发生了冲突。则通过链表地址发来解决这个冲突。</p> 
<p><strong>插入过程</strong></p> 
<pre class="prettyprint"><code class=" hljs vbnet">put（<span class="hljs-keyword">key</span>,val）,对<span class="hljs-keyword">key</span>进行HASH得到hashcode,通过hashcode得到位置如果未占用，直接将这个<span class="hljs-keyword">key</span>-val存放。

如果发生了冲突，则通过链地址法来解决冲突，从这个位置关联一个链表，在链表的节点上（bucket）上讲<span class="hljs-keyword">key</span>-val存放其中。</code></pre> 
<p><strong>取值过程</strong></p> 
<pre class="prettyprint"><code class=" hljs vbnet"><span class="hljs-keyword">get</span>（<span class="hljs-keyword">key</span>）,对<span class="hljs-keyword">key</span>进行HASH得到hashcode,通过hashcode在数组上找到这个位置，如果这个
位置上只有一个entry对（即没有关联链表），则直接取出即可。

如果这个位置上有多个entry对，即有关联一个链表，则对这个链表进行遍历，如果entry对的
<span class="hljs-keyword">key</span>等于要查询的<span class="hljs-keyword">key</span>，则将entry对取出。</code></pre> 
<h5 id="与hashtable的区别"><strong>与HashTable的区别</strong></h5> 
<p>Hashtable的所有方法都加了synchronized是线程安全的，HashMap是非线程安全的 <br> Hashtable不可以设置Null的key,而HashMap是可以设置为Null的key <br> 单线程时Hashtable速度较慢</p> 
<h5 id="通过hashmap达到线程安全目的"><strong>通过HashMap达到线程安全目的</strong></h5> 
<p>我们也可以让HashMap同步 <br> Map m = Collections.synchronizeMap(hashMap); <br> 这样是通过一个互斥的对象锁，来达到线程同步的目的 <br> 但这样的实现在并发场景上效率太低 <br> 后来concurrent包下的ConcurrentHashMap，通过在数据结构上真正的实现了对高并发的支持</p> 
<h3 id="2-treemap">2 TreeMap</h3> 
<ul><li>线程不安全</li><li>内部红黑树实现</li></ul> 
<h3 id="3-linkedhashmap">3 LinkedHashMap</h3> 
<ul><li>内部的entry&lt; k,v &gt;除了保存当前元素的引入，还保存前一个、后一个元素的引用</li><li>是从HashMap继承</li><li>对插入顺序是有序的</li><li>可实现LRU算法</li><li>线程不安全</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/441f6cfabb6ac7c6d96836c91bc27a15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java开发相关面试题-1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b7a0c08f615715249ae8bb31460ca77b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">获取手机的IMSI码,并判断是中国移动\中国联通\中国电信</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>