<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>odoo-ORM API - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="odoo-ORM API" />
<meta property="og:description" content="odoo ORM API 基于odoo 12.0
odoo中的模型，一个很重要的特点就是，它即是定义模型的类，又是数据记录的集合，这一特性可以很方便的在模型中直接定义数据记录集的操作。例如赋值、修改、删除、计算等等。这些特性都需要odoo提供的ORM API来实现，具体方式是在函数定义前加上API的装饰器。
常用装饰器 @api.one:表示确定只有一条记录，模型类函数中self代表一条数据集，可直接采用self.&lt;字段名&gt;进行增查改删的操作吗，但是官方不提倡使用api.one装饰器
@api.multi:表示多条记录，此时函数的self代表的是一个数据集，通常可采用 for record in self 来循环对数据集操作，也可以使用self.ensure_one()函数达到api.one的目的。
@api.model:类装饰器，这里的self就不再是数据集，而是类本身，相当于python中的@classmethod，@api.model装饰器不能用于按钮的点击操作逻辑函数，应使用api.multi
@api.depends：用于计算字段，形式为@api.depends(‘field1’，‘field2’…)，用于标示哪些字段参与了计算字段的计算，同时函数内计算字段必须被赋值，否则会报错
@api.constraints:用于评估和检查，使用形式同@api.depends,若记录修改时，检查不通过，则不会修改记录
@api.onchange：用于用户在交互时自动更新关联字段，self指的是一条记录，可返回一个报告修改信息字典{‘title’:‘message title’,‘message’:‘message body’}
ORM方法 orm操作数据集 基本方法 &lt;model&gt;.create(values) :增&lt;model&gt;.write(values) ：改&lt;model&gt;.unlink()：删
这三种模型写入数据的操作是models.Model自带的函数，用户可以根据需要重写该方法 shell命令
启动odoo的shell调试器（需要安装watchdog包），在终端输出以下命令进入shell：odoo-bin shell -d (数据库名) -c /etc/odoo/odoo.conf #ubuntu or debian系统 python odoo-bin shell -d (数据库名) #windows系统 进入shell后，输入命令：&gt;&gt;&gt;self res.users(1,) &gt;&gt;&gt;self._name &#39;res.users&#39; &gt;&gt;&gt;self.name &#39;Administrator&#39; shell中的self即为管理员账户，shell中可以通过env函数查询数据集：&gt;&gt;&gt;self.env[&#39;res.users&#39;].search([],limit=1)#通过模块名查找,如果不加limit=1，返回结果是一个列表 res.users(1,) &gt;&gt;&gt;self.env[&#39;sale.order&#39;].browse()#通过模块名查找 res.users(1,) &gt;&gt;&gt;self.env.ref(&#39;base.user_root&#39;)#通过外部ID查找 res.users(1,) self.env种包含了如下几个属性： env.cr 当前数据库光标env.user 当前会话用户的记录env.uid 当前会话用户的ID，相当于env.user.idenv.context 会话的上下文不可变字典env.sudo(user) 通过参数指定的用户返回用户所属的环境信息，如果不传参，默认返回管理员账户的环境env.with_context(dict) 可以使用参数中的字典中的值给上下文环境中的值替换env.with_context(key=value……) 同上 事务底层SQL 通过ORM API来执行数据库相关的操作：
self.env.cr.execute(sql) #直接执行sql语句 self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f8359981a7e0c844bc3970d3f4545119/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-09T14:51:59+08:00" />
<meta property="article:modified_time" content="2019-07-09T14:51:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">odoo-ORM API</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="odoo_ORM_API_0"></a>odoo ORM API</h2> 
<p>基于odoo 12.0<br> odoo中的模型，一个很重要的特点就是，它即是定义模型的类，又是数据记录的集合，这一特性可以很方便的在模型中直接定义数据记录集的操作。例如赋值、修改、删除、计算等等。这些特性都需要odoo提供的ORM API来实现，具体方式是在函数定义前加上API的装饰器。</p> 
<h3><a id="_3"></a>常用装饰器</h3> 
<ul><li> <p>@api.one:表示确定只有一条记录，模型类函数中self代表一条数据集，可直接采用self.&lt;字段名&gt;进行增查改删的操作吗，但是官方不提倡使用api.one装饰器</p> </li><li> <p>@api.multi:表示多条记录，此时函数的self代表的是一个数据集，通常可采用 for record in self 来循环对数据集操作，也可以使用self.ensure_one()函数达到api.one的目的。</p> </li><li> <p>@api.model:类装饰器，这里的self就不再是数据集，而是类本身，相当于python中的@classmethod，@api.model装饰器<strong>不能用于按钮的点击操作逻辑函数</strong>，应使用api.multi</p> </li><li> <p>@api.depends：用于计算字段，形式为@api.depends(‘field1’，‘field2’…)，用于标示哪些字段参与了计算字段的计算，同时函数内计算字段必须被赋值，否则会报错</p> </li><li> <p>@api.constraints:用于评估和检查，使用形式同@api.depends,若记录修改时，检查不通过，则不会修改记录</p> </li><li> <p>@api.onchange：用于<strong>用户在交互时</strong>自动更新关联字段，self指的是一条记录，可返回一个报告修改信息字典{‘title’:‘message title’,‘message’:‘message body’}</p> </li></ul> 
<h3><a id="ORM_15"></a>ORM方法</h3> 
<h4><a id="orm_16"></a>orm操作数据集</h4> 
<ul><li>基本方法 
  <ul><li>&lt;model&gt;.create(values) :增</li><li>&lt;model&gt;.write(values) ：改</li><li>&lt;model&gt;.unlink()：删<br> 这三种模型写入数据的操作是models.Model自带的函数，用户可以根据需要重写该方法</li></ul> </li><li>shell命令<br> 启动odoo的shell调试器（需要安装watchdog包），在终端输出以下命令进入shell：<pre><code class="prism language-shell">odoo-bin shell -d <span class="token punctuation">(</span>数据库名<span class="token punctuation">)</span> -c /etc/odoo/odoo.conf <span class="token comment">#ubuntu or debian系统</span>
python odoo-bin shell -d <span class="token punctuation">(</span>数据库名<span class="token punctuation">)</span> <span class="token comment">#windows系统</span>
</code></pre> 进入shell后，输入命令：<pre><code class="prism language-shell"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>self
res.users<span class="token punctuation">(</span>1,<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>self._name
<span class="token string">'res.users'</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>self.name
<span class="token string">'Administrator'</span>
</code></pre> shell中的self即为管理员账户，shell中可以通过env函数查询数据集：<pre><code class="prism language-shell"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>self.env<span class="token punctuation">[</span><span class="token string">'res.users'</span><span class="token punctuation">]</span>.search<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>,limit<span class="token operator">=</span>1<span class="token punctuation">)</span><span class="token comment">#通过模块名查找,如果不加limit=1，返回结果是一个列表</span>
res.users<span class="token punctuation">(</span>1,<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>self.env<span class="token punctuation">[</span><span class="token string">'sale.order'</span><span class="token punctuation">]</span>.browse<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#通过模块名查找</span>
res.users<span class="token punctuation">(</span>1,<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>self.env.ref<span class="token punctuation">(</span><span class="token string">'base.user_root'</span><span class="token punctuation">)</span><span class="token comment">#通过外部ID查找</span>
res.users<span class="token punctuation">(</span>1,<span class="token punctuation">)</span>
</code></pre> self.env种包含了如下几个属性： 
  <ul><li><a href="http://env.cr" rel="nofollow">env.cr</a> 当前数据库光标</li><li>env.user 当前会话用户的记录</li><li>env.uid 当前会话用户的ID，<a href="http://xn--env-xi9dq08ewn6a.user.id" rel="nofollow">相当于env.user.id</a></li><li>env.context 会话的上下文不可变字典</li><li>env.sudo(user) 通过参数指定的用户返回用户所属的环境信息，如果不传参，默认返回管理员账户的环境</li><li>env.with_context(dict) 可以使用参数中的字典中的值给上下文环境中的值替换</li><li>env.with_context(key=value……) 同上</li></ul> </li></ul> 
<h3><a id="SQL_54"></a>事务底层SQL</h3> 
<p>通过ORM API来执行数据库相关的操作：</p> 
<pre><code class="prism language-python">self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>cr<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>sql<span class="token punctuation">)</span>  <span class="token comment">#直接执行sql语句</span>
self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>cr<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">#用于提交本次事物</span>
self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>cr<span class="token punctuation">.</span>savepoint<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">#设置一个保存点用于回滚（rollback）</span>
self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>cr<span class="token punctuation">.</span>rollback<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#取消当前操作，回滚到上次提交的点或者上一个保存点</span>
</code></pre> 
<p>示例：</p> 
<pre><code class="prism language-shell"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>self.env.cr.execute<span class="token punctuation">(</span><span class="token string">'select id,login from res_users where login=%s or id=%s'</span>.format<span class="token punctuation">(</span><span class="token string">'demo'</span>,1<span class="token punctuation">))</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>self.env.cr.fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span>1,<span class="token string">'admin'</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span>5,<span class="token string">'demo'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre> 
<p>使用方法与其他的数据库orm api（pymysql,pyodbc等）类似。<br> 此外，还可以运行数据库操作命令（DML），但odoo保存的是数据缓存，与数据库中的数据可能会不一致，因此在使用原是DML时，应该在完成后使用self.env.invalidate_all()清空这些缓存。</p> 
<h3><a id="_70"></a>记录集的使用</h3> 
<ul><li>context<br> context是用字典储存的会话数据，在前端和服务器端都可以使用<br> 前端中，context可以叫信息从一个视图传递给另外一个视图，比如上一个窗体记录的ID，在俺就点击动作完成后传递给下一个窗体。</li></ul> 
<pre><code class="prism language-python"><span class="token punctuation">{<!-- --></span><span class="token string">'lan'</span><span class="token punctuation">:</span><span class="token string">'en_US'</span><span class="token punctuation">,</span><span class="token string">'tz'</span><span class="token punctuation">:</span><span class="token string">'Europe/Brussels'</span><span class="token punctuation">,</span><span class="token string">'uid'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span>
</code></pre> 
<p>服务器端，记录集可的字段值可以依赖context提供的本地设置，为服务器端提供一些信号信息。</p> 
<p>当从一个窗体通过点击一个俺就打开另一个窗体时，关键字active_id（active_ids）将会加载到context中，记录了上一个窗体定位的记录id。active_model则记录的视图模型的技术名称。这在业务向导中经常用到。<br> 例如在向导中要获取上一个记录的记录集，在对筛选的记录集在下一个窗体进行操作。实现过程为：在按钮的点击事件函数中，通过需要用到default_get()方法</p> 
<pre><code class="prism language-python">@api<span class="token punctuation">.</span>model
<span class="token keyword">def</span> <span class="token function">default_get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>feild_names<span class="token punctuation">)</span><span class="token punctuation">:</span>
	defaults <span class="token operator">=</span> <span class="token builtin">super</span><span class="token punctuation">(</span>ModelClass<span class="token punctuation">,</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>default_get<span class="token punctuation">(</span>feild_names<span class="token punctuation">)</span>
	defaults<span class="token punctuation">[</span><span class="token string">'ids'</span><span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>env<span class="token punctuation">.</span>context<span class="token punctuation">(</span><span class="token string">'active_ids'</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> defaults
</code></pre> 
<p>context在客户端可以用来设置目标视图的默认值或激活默认筛选器，使用default_或者default_search_开头的关键字来完成这种设置。</p> 
<pre><code class="prism language-python"><span class="token punctuation">{<!-- --></span>‘default_user_id’<span class="token punctuation">:</span>uid<span class="token punctuation">}</span>
<span class="token punctuation">{<!-- --></span>‘default_search_filter_res_users’<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span>
</code></pre> 
<ul><li>domain<br> domain用于筛选记录集，domain使用的为domain表达式，形式为一个条件列表，每个条件都是一个元祖，如：</li></ul> 
<pre><code class="prism language-python"><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'is_done'</span><span class="token punctuation">,</span><span class="token string">'='</span><span class="token punctuation">,</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">]</span>   <span class="token comment">#[(&lt;字段名&gt;,&lt;比较符&gt;,&lt;值&gt;)]   </span>
</code></pre> 
<p>使用时需注意：</p> 
<ol><li>客户端使用时，当前视图的字段时可用，但不能使用点(.)连接这些字段使用</li><li>服务器端使用时，可以通过点连接</li><li>通常的比较符：&lt;,&gt;,&lt;=,&gt;=,=,!=</li><li>=like：匹配模式，_表示任意字符，%表示任意字符串</li><li>like：匹配模式，%value%</li><li>child of：筛选子节点的值</li><li>in和not in：包含不包含</li><li>与或非：使用’&amp;’、’|’、’!‘一个或两个条件元祖构成，如[’&amp;’,A,B]代表A&amp;B，[’|’,A,B]代表A|B，多个与或非构成表达式，从后向前进行计算。</li></ol> 
<h3><a id="_108"></a>记录集的操作</h3> 
<h4><a id="_109"></a>查询模式</h4> 
<ul><li>search方法，可以传递domain表达式进行筛选查询，其他参数还有order、limit及offset，分表代表对应的sql语句</li><li>browse方法：返回记录集的IDs或单个ID的列表方法。</li><li>search_count方法：只返回计数</li><li>name_search(): many2one字段搜索时调用</li><li>search_read(): many2one点开搜索更多时调用</li><li>read_group(): 搜索视图分组时调用</li></ul> 
<h4><a id="_116"></a>单例模式</h4> 
<p>只有一个记录的记录集成为单例，空记录也是单例。<br> 对于单例模式，在开始时使用self.ensure_one()</p> 
<h4><a id="_119"></a>写记录集</h4> 
<ul><li>create方法：创建记录，传入字典参数</li><li>unlink方法：删除记录，不传入参数，直接用记录集调用</li><li>write方法：修改记录，传入字典参数</li></ul> 
<h4><a id="_124"></a>日期和时间</h4> 
<pre><code class="prism language-python"><span class="token keyword">from</span> odoo <span class="token keyword">import</span> fields
fields<span class="token punctuation">.</span>Datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">##时间</span>
fields<span class="token punctuation">.</span>Datetime<span class="token punctuation">.</span>from_string<span class="token punctuation">(</span><span class="token string">'2018-01-01 00:00:00'</span><span class="token punctuation">)</span>
fields<span class="token punctuation">.</span>Datet<span class="token punctuation">.</span>today<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">##日期</span>
</code></pre> 
<h4><a id="_131"></a>操作记录集</h4> 
<p>record是一个记录集，可以对其进行一下操作</p> 
<ul><li>x in record 遍历记录集</li><li>x not in record 遍历记录集的他集</li><li>record.ids 返回记录集的id李彪</li><li>record.ensure_one() 返回单例记录集</li><li>record.filtered(func) 返回经过筛选的记录集</li><li>record.mapped(func) 返回经过映射值得列表</li><li>record.sorted(func) 返回有序的记录集<br> 非单例的记录集为一个列表，在服务器端可通过列表的方式进行操作</li></ul> 
<h4><a id="_141"></a>关系字段</h4> 
<ul><li>多对一、多对多：one_record.many_ids</li><li>一对多: one_record.one_id</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/43e243eba4cd6e396e2dd94f11d3adbe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python爬虫的起点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5bc14367a088f6d3b2c8813e4dacad3a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">常用的Linux shell命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>