<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt 的TCP网络通信 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt 的TCP网络通信" />
<meta property="og:description" content="Qt网络通信： Socket 通信： Qt 中提供的所有的 Socket 类都是非阻塞的。
Qt 中常用的用于Socket 通信的套接字类
QTCPServer：用于TCP/IP 通信，作为服务器端套接字使用。
QTCPSocket：用于TCP/IP 通信，作为客户端套接字使用。
QUDPSocket：用于UDP通信，服务器，客户端均使用此套接字。
TCP/IP： 在Qt 中实现TCP/IP 服务器端通信的流程： （1）创建套接字；（2）将套接字设置为监听模式；（3）等待并接受客户的需求；[可以通过QTCPServer 提供的void newConnection() 信号来检测是否有连接请求，如果有可以在对应的槽函数中调用nextPendingconnection（）函数获取到客户端的Socket 信息（返回值为QTCPSocket*类型指针），通过此套接字与客户端之间进行通信。]；（3）接收或者向客户端发送数据 [① 接收数据：使用read() 或者readAll() 函数；② 发送数据：使用write()函数]
客户端通信流程： （1）创建套接字；（2）连接服务器 [可以使用QTCPSocket 类的connectionToHost() 函数来连接服务器]；（3）向服务器发送或者接收数据
在开始之前 ServerTCP.pro：(项目名称为ServerTCP) 添加如下代码： 服务器端： 添加Client 客户端的文件：
右键项目名称 -&gt; 添加新文件 -&gt; 客户端： 在服务器端和客户端的textEditRead 栏中将其设置为 “只读” 服务器端： 点击ui的Send 和Close的按钮：右键 -&gt; 转到槽； 客户端： 点击ui的Send 、Close和 connect的按钮：右键 -&gt; 转到槽； 代码段： 服务器： Serverwidget.h #ifndef SERVERWIDGET_H #define SERVERWIDGET_H #include &lt;QWidget&gt; #include &lt;QTcpServer&gt; //监听套接字 #include &lt;QTcpSocket&gt; //通信套接字 #include &lt;QMouseEvent&gt; namespace Ui { class ServerWidget; } class ServerWidget : public QWidget { Q_OBJECT public: explicit ServerWidget(QWidget *parent = 0); ~ServerWidget(); protected: void paintEvent(QPaintEvent *event); private slots: void on_send_clicked(); void on_close_clicked(); private: Ui::ServerWidget *ui; QTcpServer *tcpServer;//监听套接字 QTcpSocket *tcpSocket;//通信套接字 }; #endif // SERVERWIDGET_H Serverwidget." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a8c906464e2118ee18d502166b7dc32e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-17T21:40:28+08:00" />
<meta property="article:modified_time" content="2019-10-17T21:40:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt 的TCP网络通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<h2><span style="color:#f33b45;">Qt网络通信：</span></h2> 
<h3>Socket 通信：</h3> 
<p>Qt 中提供的所有的 Socket 类都是非阻塞的。</p> 
<p>Qt 中常用的用于Socket 通信的套接字类</p> 
<p>QTCPServer：用于TCP/IP 通信，作为服务器端套接字使用。</p> 
<p>QTCPSocket：用于TCP/IP 通信，作为客户端套接字使用。</p> 
<p>QUDPSocket：用于UDP通信，服务器，客户端均使用此套接字。</p> 
<p> </p> 
<h3>TCP/IP：</h3> 
<h4>在Qt 中实现TCP/IP 服务器端通信的流程：</h4> 
<p>（1）创建套接字；（2）将套接字设置为监听模式；（3）等待并接受客户的需求；[可以通过QTCPServer 提供的void newConnection() 信号来检测是否有连接请求，如果有可以在对应的槽函数中调用nextPendingconnection（）函数获取到客户端的Socket 信息（返回值为QTCPSocket*类型指针），通过此套接字与客户端之间进行通信。]；（3）接收或者向客户端发送数据 [① 接收数据：使用read() 或者readAll() 函数；② 发送数据：使用write()函数]</p> 
<h4>客户端通信流程：</h4> 
<p>（1）创建套接字；（2）连接服务器 [可以使用QTCPSocket 类的connectionToHost() 函数来连接服务器]；（3）向服务器发送或者接收数据</p> 
<h3>在开始之前 ServerTCP.pro：(项目名称为ServerTCP)</h3> 
<h3>添加如下代码：</h3> 
<p><img alt="" class="has" height="145" src="https://images2.imgbox.com/7a/6a/d89SzMd6_o.png" width="556"></p> 
<p><img alt="" class="has" height="212" src="https://images2.imgbox.com/6a/25/dbHc1lnC_o.png" width="351"></p> 
<h4><span style="color:#f33b45;">服务器端：</span></h4> 
<p><img alt="" class="has" height="506" src="https://images2.imgbox.com/19/b4/tMsWBe5h_o.png" width="894"></p> 
<p>添加Client 客户端的文件：</p> 
<p>右键项目名称 -&gt; 添加新文件 -&gt; </p> 
<p><img alt="" class="has" height="491" src="https://images2.imgbox.com/88/22/VWF63LxA_o.png" width="784"></p> 
<p><img alt="" class="has" height="577" src="https://images2.imgbox.com/8e/4c/Cx0w1IO5_o.png" width="785"></p> 
<p><img alt="" class="has" height="577" src="https://images2.imgbox.com/45/06/hRkMFq2Q_o.png" width="785"></p> 
<p><img alt="" class="has" height="577" src="https://images2.imgbox.com/38/5c/bZq06LkA_o.png" width="785"></p> 
<h4><span style="color:#f33b45;">客户端：</span></h4> 
<p><img alt="" class="has" height="539" src="https://images2.imgbox.com/ea/ce/QJdvyNM1_o.png" width="894"></p> 
<h4>在服务器端和客户端的textEditRead 栏中将其设置为 “只读”</h4> 
<p><img alt="" class="has" height="491" src="https://images2.imgbox.com/24/73/bXMwdgRv_o.png" width="687"></p> 
<p><img alt="" class="has" height="562" src="https://images2.imgbox.com/ed/fa/3x4DoJcs_o.png" width="690"></p> 
<h3>服务器端：</h3> 
<h4>点击ui的Send 和Close的按钮：右键 -&gt; 转到槽；</h4> 
<h3>客户端：</h3> 
<h4>点击ui的Send 、Close和 connect的按钮：右键 -&gt; 转到槽；</h4> 
<p> </p> 
<h2><span style="color:#f33b45;">代码段：</span></h2> 
<h2>服务器：</h2> 
<h3>Serverwidget.h</h3> 
<p><img alt="" class="has" height="543" src="https://images2.imgbox.com/66/f4/crOi2RRR_o.png" width="606"></p> 
<pre class="has"><code class="language-cpp">#ifndef SERVERWIDGET_H
#define SERVERWIDGET_H

#include &lt;QWidget&gt;
#include &lt;QTcpServer&gt; //监听套接字
#include &lt;QTcpSocket&gt; //通信套接字

#include &lt;QMouseEvent&gt;
namespace Ui {
class ServerWidget;
}

class ServerWidget : public QWidget
{
    Q_OBJECT

public:
    explicit ServerWidget(QWidget *parent = 0);
    ~ServerWidget();
protected:
    void paintEvent(QPaintEvent *event);

private slots:
    void on_send_clicked();

    void on_close_clicked();

private:
    Ui::ServerWidget *ui;

    QTcpServer *tcpServer;//监听套接字
    QTcpSocket *tcpSocket;//通信套接字

};

#endif // SERVERWIDGET_H
</code></pre> 
<p> </p> 
<h3>Serverwidget.cpp</h3> 
<pre class="has"><code class="language-cpp">#include "serverwidget.h"
#include "ui_serverwidget.h"
#include &lt;QPainter&gt;

ServerWidget::ServerWidget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ServerWidget)
{
    ui-&gt;setupUi(this);
    tcpServer = NULL;
    tcpSocket = NULL;

    setWindowTitle("服务器端");
    //监听套接字，指定父对象，让其自动回收空间
    tcpServer = new QTcpServer(this);
    tcpServer-&gt;listen(QHostAddress::Any,666);
    connect(tcpServer,&amp;QTcpServer::newConnection,
            [=]()
            {
                //取出建立好连接的套接字
                tcpSocket = tcpServer-&gt;nextPendingConnection();

                //获取对方的IP和端口
                QString ip = tcpSocket-&gt;peerAddress().toString();
                qint16 port = tcpSocket-&gt;peerPort();
                QString temp = QString("[%1:%2]:成功链接").arg(ip).arg(port);
                ui-&gt;textEditRead-&gt;setText(temp);

                connect(tcpSocket,&amp;QTcpSocket::readyRead,
                        [=]()
                        {
                            //从通信套接字中取出内容
                            QByteArray array = tcpSocket-&gt;readAll();
                            ui-&gt;textEditRead-&gt;append(array);
                        }
                        );
            }
            );

}

ServerWidget::~ServerWidget()
{
    delete ui;
}

void ServerWidget::on_send_clicked()
{
    //获取编辑区内容
    if(NULL == tcpSocket)
    {
        return;
    }
    QString str = ui-&gt;textEditWrite-&gt;toPlainText();
    //给对方发送数据，使用套接字是TCPSocket
    tcpSocket-&gt;write(str.toUtf8().data());
}


void ServerWidget::on_close_clicked()
{
    //主动和客户端断开连接
    if(NULL == tcpSocket)
    {
        return;
    }
    tcpSocket-&gt;disconnectFromHost();
    tcpSocket-&gt;close();
    tcpSocket = NULL;
}
void ServerWidget::paintEvent(QPaintEvent *event)
{
    QPainter p(this);
    p.drawPixmap(0,0,width(),height(),QPixmap(":/new/prefix1/Image/1.jpg"));
}
</code></pre> 
<h2>客户端：</h2> 
<h3>clientwidget.h</h3> 
<p><img alt="" class="has" height="520" src="https://images2.imgbox.com/34/f9/nEdNxSwW_o.png" width="640"></p> 
<pre class="has"><code class="language-cpp">#ifndef CLIENWIDGET_H
#define CLIENWIDGET_H

#include &lt;QWidget&gt;
#include &lt;QTcpSocket&gt;//通信套接字

namespace Ui {
class ClienWidget;
}

class ClienWidget : public QWidget
{
    Q_OBJECT

public:
    explicit ClienWidget(QWidget *parent = 0);
    ~ClienWidget();
protected:
    void paintEvent(QPaintEvent *event);

private slots:
    void on_pushButtonConnect_clicked();

    void on_pushButtonSend_clicked();

    void on_pushButtonClose_clicked();

private:
    Ui::ClienWidget *ui;
    QTcpSocket *tcpsocket;//通信套接字
};

#endif // CLIENWIDGET_H
</code></pre> 
<h3>clientwidget.cpp</h3> 
<pre class="has"><code class="language-cpp">#include "clienwidget.h"
#include "ui_clienwidget.h"
#include &lt;QHostAddress&gt;
#include &lt;QPainter&gt;
ClienWidget::ClienWidget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ClienWidget)
{
    ui-&gt;setupUi(this);

    ui-&gt;textEditRead-&gt;setStyleSheet("background-image:url(:/new/prefix1/Image/5C74F1D9198348410F91F4EA3EAD6FB2.jpg);");
    ui-&gt;textEditWrite-&gt;setStyleSheet("background-image:url(:/new/prefix1/Image/8A141585F1E8C5BD63F80D15DB9826E2.jpg)");

    tcpsocket = NULL;

    //分配空间，指定父对象
    tcpsocket = new QTcpSocket(this);
    setWindowTitle("客户端");

    connect(tcpsocket,&amp;QTcpSocket::connected,
            [=]()
            {
                ui-&gt;textEditRead-&gt;setText("成功和服务器建立好链接");

            }
            );
    connect(tcpsocket,&amp;QTcpSocket::readyRead,
            [=]()
            {
                //获取对方发送的内容
                QByteArray array = tcpsocket-&gt;readAll();
                //追加到编辑区中
                ui-&gt;textEditRead-&gt;append(array);
            }
            );

}

ClienWidget::~ClienWidget()
{
    delete ui;
}



void ClienWidget::on_pushButtonConnect_clicked()
{
    //获取服务器端口和IP
    QString ip = ui-&gt;lineEditIP-&gt;text();
    qint16 port = ui-&gt;lineEditPort-&gt;text().toInt();
    //主动和服务器建立连接
    tcpsocket-&gt;connectToHost(QHostAddress(ip),port);
}

void ClienWidget::on_pushButtonSend_clicked()
{
    //获取编辑框内容
    QString str = ui-&gt;textEditWrite-&gt;toPlainText();
    //发送数据
    tcpsocket-&gt;write(str.toUtf8().data());
}

void ClienWidget::on_pushButtonClose_clicked()
{
    //主动和对方断开连接
    tcpsocket-&gt;disconnectFromHost();
    tcpsocket-&gt;close();
}

void ClienWidget::paintEvent(QPaintEvent *event)
{
    QPainter p(this);
    p.drawPixmap(0,0,width(),height(),QPixmap(":/new/prefix1/Image/bk.jpg"));
}
</code></pre> 
<p> </p> 
<h2>添加资源：</h2> 
<h3>右击项目 -&gt; 添加新文件 -&gt; </h3> 
<p><img alt="" class="has" height="552" src="https://images2.imgbox.com/36/89/yLwbJjXA_o.png" width="971"></p> 
<p><img alt="" class="has" height="502" src="https://images2.imgbox.com/09/46/edlZjFTt_o.png" width="804"></p> 
<h4>项目会出现 Resources -&gt; image.qrc 右击 -&gt; open in Editor</h4> 
<p><img alt="" class="has" height="59" src="https://images2.imgbox.com/e6/3a/eYNgWAHa_o.png" width="466"></p> 
<p><img alt="" class="has" height="59" src="https://images2.imgbox.com/1b/63/jC82wfrO_o.png" width="454"></p> 
<h2>效果：</h2> 
<h3>点击连接后：</h3> 
<p><img alt="" class="has" height="377" src="https://images2.imgbox.com/c9/9d/j1s7ufRA_o.png" width="973"></p> 
<p><img alt="" class="has" height="376" src="https://images2.imgbox.com/5f/c2/JfQFLyQi_o.png" width="971"></p> 
<p>课外了解</p> 
<h3>Qt TCP 网络通信的结构：</h3> 
<p> </p> 
<p><img alt="" class="has" height="404" src="https://images2.imgbox.com/27/b9/2II7x2iH_o.png" width="554"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9703899956c58d2fde28016551aca588/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">页、页表、页表项</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/14a8215ea7559b2432e7a2e9f586c2ab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">单词接龙</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>