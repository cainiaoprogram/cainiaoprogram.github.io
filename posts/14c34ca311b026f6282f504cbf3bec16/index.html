<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>socket 错误码errno - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="socket 错误码errno" />
<meta property="og:description" content="EINTR： 4 阻塞的操作被取消阻塞的调用打断。如设置了发送接收超时，就会遇到这种错误。 只能针对阻塞模式的socket，非阻塞模式不会出现这个错误。读，写阻塞的socket时（recv，send），-1返回，错误号为EINTR，说明在数据传输前接收到一个信号（A signal occurred before any data was transmitted.）。出现这种情况，操作应该继续。如果recv的返回值为0，那表明连接已经断开，接收操作应该结束。
对于socket接口(指connect/send/recv/accept..等等，后面不重复，不包括不能设置非阻塞的如select)，在阻塞模式下有可能因为发生信号，返回EINTR错误，由用户做重试或终止。 但是，在非阻塞模式下，是否出现这种错误呢？ 对此，重温了系统调用、信号、socket相关知识，得出结论是：不会出现。 首先， 1.信号的处理是在用户态下进行的，也就是必须等待一个系统调用执行完了才会执行进程的信号函数，所以就有了信号队列保存未执行的信号 2.用户态下被信号中断时，内核会记录中断地址，信号处理完后，如果进程没有退出则重回这个地址继续执行 socket接口是一个系统调用，也就是即使发生了信号也不会中断，必须等socket接口返回了，进程才能处理信号。 也就是，EINTR错误是socket接口主动抛出来的，不是内核抛的。socket接口也可以选择不返回，自己内部重试之类的.. 那阻塞的时候socket接口是怎么处理发生信号的? 举例 socket接口，例如recv接口会做2件事情， 1.检查buffer是否有数据，有则复制清除返回 2.没有数据，则进入睡眠模式，当超时、数据到达、发生错误则唤醒进程处理 socket接口的实现都差不了太多，抽象说 1.资源是否立即可用，有则返回 2.没有，就等... 对于 1.这个时候不管有没信号，也不返回EINTR，只管执行自己的就可以了 2.采用睡眠来等待，发生信号的时候进程会被唤醒，socket接口唤醒后检查有无未处理的信号(signal_pending)会返回EINTR错误。 所以 socket接口并不是被信号中断，只是调用了睡眠，发生信号睡眠会被唤醒通知进程，然后socket接口选择主动退出，这样做可以避免一直阻塞在那里，有退出的机会。非阻塞时不会调用睡眠。 参考：http://willko.iteye.com/blog/1691741
EAGAIN 11：
从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返 回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。 又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。 1、非阻塞socket，send返回值小于要发送的数据数目，可能会返回EAGAIN或者EINTR。 2、非阻塞socket，如send返回EAGAIN错误，表示数据没有完全写入发送缓冲区，但是发送缓冲队列已满，可以做延时后再重试。 3、非阻塞socket，recv时，经常出现Resource temporarily unavailable，返回值-1，errno代码为11(EAGAIN)。表明在非阻塞模式下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏 socket的同步，不用管它，下次循环接着recv就可以（注意：对于普通socket和LT模式的epoll的非阻塞socket是继续recv和send）。对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。
在epoll的ET模式下，非阻塞socket，出现EGAIN就是读数据结束了，不能用循环抱住recv，即不能在出现EAGAIN时，马上接着循环recv，因为下一次还会是EAGAIN，这样会陷入死循环。这种情况下出现EAGAIN，表示读或者写已经完成。（已亲测）
4、使用epoll网络模型，单用户的情况下客户端和服务器通信正常。但是在多用户并发的情况下，客户端和服务端通信不正常。此时，客户端能正常的链接，发送数据，但是一直卡在接收数据部分？为什么？
因为在ET模式socket非阻塞的情况下，多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。因此，就出现了上面的问题。
解决办法是用while循环抱住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。
ETIMEOUT：110 1、操作超时。一般设置了发送接收超时，遇到网络繁忙的情况，就会遇到这种错误。 2、服务器做了读数据做了超时限制，读时发生了超时。 3、错误被描述为“connect time out”，即“连接超时”，这种情况一般发生在服务器主机崩溃。此时客户 TCP 将在一定时间内（依具体实现）持续重发数据分节，试图从服务 TCP 获得一个 ACK 分节。当最终放弃尝试后（此时服务器未重新启动），内核将会向客户进程返回 ETIMEDOUT 错误。如果某个中间路由器判定该服务器主机已经不可达，则一般会响应“destination unreachable”－“目的地不可达”的ICMP消息，相应的客户进程返回的错误是 EHOSTUNREACH 或ENETUNREACH。当服务器重新启动后，由于 TCP 状态丢失，之前所有的连接信息也不存在了，此时对于客户端发来请求将回应 RST。如果客户进程对检测服务器主机是否崩溃很有必要，要求即使客户进程不主动发送数据也能检测出来，那么需要使用其它技术，如配置 SO_KEEPALIVE Socket 选项，或实现某些心跳函数。 EPIPE： 1、Socket 关闭，但是socket号并没有置-1。继续在此socket上进行send和recv，就会返回这种错误。这个错误会引发SIGPIPE信号，系统会将 产生此EPIPE错误的进程杀死。所以，一般在网络程序中，首先屏蔽此消息，以免发生不及时设置socket进程被杀死的情况。 2、write(." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/14c34ca311b026f6282f504cbf3bec16/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-11-06T09:38:44+08:00" />
<meta property="article:modified_time" content="2014-11-06T09:38:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">socket 错误码errno</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EINTR： 4</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">阻塞的操作被取消阻塞的调用打断。如设置了发送接收超时，就会遇到这种错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>只能针对阻塞模式的socket，非阻塞模式不会出现这个错误。</strong>读，写阻塞的socket时（recv，send），-1返回，错误号为EINTR，说明在数据传输前接收到一个信号（A signal occurred before any data was transmitted.）。出现这种情况，操作应该继续。如果recv的返回值为0，那表明连接已经断开，接收操作应该结束。</span></p> 
<p><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">对于socket接口(指connect/send/recv/accept..等等，后面不重复，不包括不能设置非阻塞的如select)，在阻塞模式下有可能因为发生信号，返回EINTR错误，由用户做重试或终止。 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">但是，在非阻塞模式下，是否出现这种错误呢？ </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">对此，重温了系统调用、信号、socket相关知识，得出结论是：</span><strong><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">不会出现</span><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">。 </span></strong><br> </p> 
<p><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">首先， </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">1.信号的处理是在用户态下进行的，也就是必须等待一个系统调用执行完了才会执行进程的信号函数，所以就有了信号队列保存未执行的信号 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">2.用户态下被信号中断时，内核会记录中断地址，信号处理完后，如果进程没有退出则重回这个地址继续执行 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">socket接口是一个系统调用，也就是即使发生了信号也不会中断，必须等socket接口返回了，进程才能处理信号。</span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">也就是，EINTR错误是socket接口主动抛出来的，不是内核抛的。socket接口也可以选择不返回，自己内部重试之类的.. </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">那阻塞的时候socket接口是怎么处理发生信号的? </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">举例 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">socket接口，例如recv接口会做2件事情， </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">1.检查buffer是否有数据，有则复制清除返回 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">2.没有数据，则进入睡眠模式，当超时、数据到达、发生错误则唤醒进程处理 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">socket接口的实现都差不了太多，抽象说 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">1.资源是否立即可用，有则返回 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">2.没有，就等... </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">对于 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">1.这个时候不管有没信号，也不返回EINTR，只管执行自己的就可以了 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">2.采用睡眠来等待，发生信号的时候进程会被唤醒，socket接口唤醒后检查有无未处理的信号(signal_pending)会返回EINTR错误。 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">所以 </span><br style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px"> <span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">socket接口并不是被信号中断，只是调用了睡眠，发生信号睡眠会被唤醒通知进程，然后socket接口选择主动退出，这样做可以避免一直阻塞在那里，有退出的机会。非阻塞时不会调用睡眠。 </span></p> 
<p><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2000007629395px">参考：<a target="_blank" href="http://willko.iteye.com/blog/1691741" rel="nofollow noopener noreferrer">http://willko.iteye.com/blog/1691741</a><br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EAGAIN 11：</strong></span></p> 
<p><span style="font-size:14px"><span style="font-family:宋体,Arial; line-height:26px">从字面上来看，是提示再试一次。<strong>这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</strong>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返 回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。</span><br style="word-wrap:break-word; font-family:宋体,Arial; line-height:26px"> <span style="font-family:宋体,Arial; line-height:26px">又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</span><br style="word-wrap:break-word; font-family:宋体,Arial; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; line-height:26px">1、非阻塞socket，send返回值小于要发送的数据数目，可能会返回EAGAIN或者EINTR。</span><br style="color:rgb(51,51,51); font-family:Arial; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; line-height:26px">2、非阻塞socket，如send返回EAGAIN错误，表示数据没有完全写入发送缓冲区，但是发送缓冲队列已满，可以做延时后再重试。</span><br style="color:rgb(51,51,51); font-family:Arial; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; line-height:26px">3、</span><span style="font-family:Arial; line-height:26px">非阻塞socket，recv时，经常出现<span style="font-family:Arial; font-size:14px; line-height:26px">Resource temporarily unavailable，</span>返回值-1，errno代码为11(EAGAIN)。表明在非阻塞模式下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏 socket的同步，不用管它，下次循环接着recv就可以（<strong>注意：对于普通socket和LT模式的epoll的非阻塞socket是继续recv和send</strong>）。对非阻塞socket而言，EAGAIN不是一种错误。<span style="font-family:宋体,Arial">在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。</span></span></span></p> 
<p><span style="font-size:14px"><span style="font-family:Arial; line-height:26px"><span style="font-family:宋体,Arial"><span style="font-family:Arial; font-size:14px; line-height:26px"><strong>在epoll的ET模式下，非阻塞socket，出现EGAIN就是读数据结束了，不能用循环抱住recv，即不能在出现EAGAIN时，马上接着循环recv，因为下一次还会是EAGAIN，这样会陷入死循环。这种情况下出现EAGAIN，表示读或者写已经完成。（已亲测）</strong></span></span></span></span></p> 
<p><span style="font-size:14px"><span style="line-height:26px"></span><span style="font-family:宋体,Arial">4、<span style="line-height:22px">使用epoll网络模型，单用户的情况下客户端和服务器通信正常。<strong><span style="color:rgb(51,51,255)">但是在多用户并发的情况下，客户端和服务端通信不正常。此时，客户端能正常的链接，发送数据，但是一直卡在接收数据部分？为什么？</span></strong></span></span></span></p> 
<p style="margin-top:0px; margin-bottom:13px; padding-top:0px; padding-bottom:0px; line-height:22px"> <span style="font-size:14px">因为在ET模式socket非阻塞的情况下，多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。因此，就出现了上面的问题。</span></p> 
<p style="margin-top:0px; margin-bottom:13px; padding-top:0px; padding-bottom:0px; line-height:22px"> <span style="font-size:14px"><strong>解决办法是用while循环抱住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。</strong>如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。</span></p> 
<br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 
<span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ETIMEOUT：110</strong></span> 
<br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 
<span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">1、操作超时。一般设置了发送接收超时，遇到网络繁忙的情况，就会遇到这种错误。</span> 
<br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 
<span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">2、服务器做了读数据做了超时限制，读时发生了超时。</span> 
<br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 
<span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">3、错误被描述为“connect time out”，即“连接超时”，这种情况一般发生在服务器主机崩溃。此时客户 TCP 将在一定时间内（依具体实现）持续重发数据分节，试图从服务 TCP 获得一个 ACK 分节。当最终放弃尝试后（此时服务器未重新启动），内核将会向客户进程返回 ETIMEDOUT 错误。如果某个中间路由器判定该服务器主机已经不可达，则一般会响应“destination unreachable”－“目的地不可达”的ICMP消息，相应的客户进程返回的错误是 EHOSTUNREACH 或ENETUNREACH。当服务器重新启动后，由于 TCP 状态丢失，之前所有的连接信息也不存在了，此时对于客户端发来请求将回应 RST。如果客户进程对检测服务器主机是否崩溃很有必要，要求即使客户进程不主动发送数据也能检测出来，那么需要使用其它技术，如配置 SO_KEEPALIVE Socket 选项，或实现某些心跳函数。</span> 
<br> 
<p><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EPIPE：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">1、Socket 关闭，但是socket号并没有置-1。继续在此socket上进行send和recv，就会返回这种错误。这个错误会引发SIGPIPE信号，系统会将 产生此EPIPE错误的进程杀死。所以，一般在网络程序中，首先屏蔽此消息，以免发生不及时设置socket进程被杀死的情况。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">2、write(..) on a socket that has been closed at the other end will cause a SIGPIPE.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">3、错误被描述为“broken pipe”，即“管道破裂”，这种情况一般发生在客户进程不理会（或未及时处理）Socket 错误，继续向服务 TCP 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止（此时该前台进程未进行 core dump）。结合上边的 ECONNRESET 错误可知，向一个 FIN_WAIT2 状态的服务 TCP（已 ACK 响应 FIN 分节）写入数据不成问题，但是写一个已接收了 RST 的 Socket 则是一个错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EBADF：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">read(..) or write(..) on a locally closed socket will return EBADF</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EFAULT：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">地址错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EBUSY：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ECONNREFUSED：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">1、拒绝连接。一般发生在连接建立时。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">拔服务器端网线测试，客户端设置keep alive时，recv较快返回0， 先收到ECONNREFUSED (Connection refused)错误码，其后都是ETIMEOUT。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">2、an error returned from connect(), so it can only occur in a client (if a client is defined as the party that initiates the connection</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ECONNRESET：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">1、在客户端服务器程序中，客户端异常退出，并没有回收关闭相关的资源，服务器端会先收到ECONNRESET错误，然后收到EPIPE错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">2、连接被远程主机关闭。有以下几种原因：远程主机停止服务，重新启动;当在执行某些操作时遇到失败，因为设置了“keep alive”选项，连接被关闭，一般与ENETRESET一起出现。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">3、远程端执行了一个“hard”或者“abortive”的关闭。应用程序应该关闭socket，因为它不再可用。当执行在一个UDP socket上时，这个错误表明前一个send操作返回一个ICMP“port unreachable”信息。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">4、如果client关闭连接,server端的select并不出错(不返回-1,使用select对唯一一个socket进行non- blocking检测),但是写该socket就会出错,用的是send.错误号:ECONNRESET.读(recv)socket并没有返回错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">5、该错误被描述为“connection reset by peer”，即“对方复位连接”，这种情况一般发生在服务进程较客户进程提前终止。当服务进程终止时会向客户 TCP 发送 FIN 分节，客户 TCP 回应 ACK，服务 TCP 将转入 FIN_WAIT2 状态。此时如果客户进程没有处理该 FIN （如阻塞在其它调用上而没有关闭 Socket 时），则客户 TCP 将处于 CLOSE_WAIT 状态。当客户进程再次向 FIN_WAIT2 状态的服务 TCP 发送数据时，则服务 TCP 将立刻响应 RST。一般来说，这种情况还可以会引发另外的应用程序异常，客户进程在发送完数据后，往往会等待从网络IO接收数据，很典型的如 read 或 readline 调用，此时由于执行时序的原因，如果该调用发生在 RST 分节收到前执行的话，那么结果是客户进程会得到一个非预期的 EOF 错误。此时一般会输出“server terminated prematurely”－“服务器过早终止”错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> </span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EINVAL：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">无效参数。提供的参数非法。有时也会与socket的当前状态相关，如一个socket并没有进入listening状态，此时调用accept，就会产生EINVAL错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EMFILE：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">打开了太多的socket。对进程或者线程而言，每种实现方法都有一个最大的可用socket数目处理，或者是全局的，或者是局部的。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EWOULDBLOCK：EAGAIN</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">资源暂时不可用。这个错误是从对非阻塞socket进行的不能立即结束的操作返回的，如当没有数据在队列中可以读时，调用recv。并不是 fatal错误，稍后操作可以被重复。调用在一个非阻塞的SOCK_STREAM socket 上调用connect时会产生这个错误，因为有时连接建立必须消耗一定的时间。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> </span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ENOTCONN</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">在一个没有建立连接的socket上，进行read，write操作会返回这个错误。出错的原因是socket没有标识地址。Setsoc也可能会出错。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ECONNRESET</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> Connection reset by peer.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 连接被远程主机关闭。有以下几种原因：远程主机停止服务，重新启动;当在执行某些操作时遇到失败，因为设置了“keep alive”选项，连接被关闭，一般与ENETRESET一起出现。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> </span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ECONNABORTED</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">1、软件导致的连接取消。一个已经建立的连接被host方的软件取消，原因可能是数据传输超时或者是协议错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">2、该错误被描述为“software caused connection abort”，即“软件引起的连接中止”。原因在于当服务和客户进程在完成用于 TCP 连接的“三次握手”后，客户 TCP 却发送了一个 RST （复位）分节，在服务进程看来，就在该连接已由 TCP 排队，等着服务进程调用 accept 的时候 RST 却到达了。POSIX 规定此时的 errno 值必须 ECONNABORTED。源自 Berkeley 的实现完全在内核中处理中止的连接，服务进程将永远不知道该中止的发生。服务器进程一般可以忽略该错误，直接再次调用accept。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">   当TCP协议接收到RST数据段，表示连接出现了某种错误，函数read将以错误返回，错误类型为ECONNERESET。并且以后所有在这个套接字上的读操作均返回错误。错误返回时返回值小于0。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ENETUNREACH</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">网络不可达。Socket试图操作一个不可达的网络。这意味着local的软件知道没有路由到达远程的host。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ENETRESET</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">网络重置时丢失连接。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">由于设置了"keep-alive"选项，探测到一个错误，连接被中断。在一个已经失败的连接上试图使用setsockopt操作，也会返回这个错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EINPROGRESS：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">操作正在进行中。一个阻塞的操作正在执行。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 当我们以非阻塞的方式来进行连接的时候，返回的结果如果是 -1,这并不代表这次连接发生了错误，如果它的返回结果是 EINPROGRESS，那么就代表连接还在进行中。 后面可以通过poll或者select来判断socket是否可写，如果可以写，说明连接完成了。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ENOTSOCK：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">在非socket上执行socket操作。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EDESTADDRREQ：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">需要提供目的地址。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">在一个socket上的操作需要提供地址。如往一个ADDR_ANY 地址上进行sendto操作会返回这个错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EMSGSIZE：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">消息体太长。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">发送到socket上的一个数据包大小比内部的消息缓冲区大，或者超过别的网络限制，或是用来接收数据包的缓冲区比数据包本身小。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EPROTOTYPE</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">协议类型错误。标识了协议的Socket函数在不支持的socket上进行操作。如ARPA Internet</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">UDP协议不能被标识为SOCK_STREAM socket类型。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ENOPROTOOPT</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">该错误不是一个 Socket 连接相关的错误。errno 给出该值可能由于，通过 getsockopt 系统调用来获得一个套接字的当前选项状态时，如果发现了系统不支持的选项参数就会引发该错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EPROTONOSUPPORT</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">不支持的协议。系统中没有安装标识的协议，或者是没有实现。如函数需要SOCK_DGRAM socket，但是标识了stream protocol.。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ESOCKTNOSUPPORT</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">Socket类型不支持。指定的socket类型在其address family中不支持。如可选选中选项SOCK_RAW，但实现并不支持SOCK_RAW sockets。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EOPNOTSUPP</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> Operation not supported.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">  The attempted operation is not supported for the type of object referenced. Usually this occurs when a socket descriptor to a socket that cannot support this operation, for example, trying to accept a connection on a datagram socket.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EPFNOSUPPORT</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> Protocol family not supported.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> The protocol family has not been configured into the system or no implementation for it exists. Has a slightly different meaning to EAFNOSUPPORT, but is interchangeable in most cases, and all Windows Sockets functions that return one of these specify EAFNOSUPPORT.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EAFNOSUPPORT</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> Address family not supported by protocol family.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> An address incompatible with the requested protocol was used. All sockets are created with an associated "address family" (i.e. AF_INET for Internet Protocols) and a generic protocol type (i.e. SOCK_STREAM). This error will be returned if an incorrect protocol is explicitly requested in the socket call, or if an address of the wrong family is used for a socket, e.g. in sendto.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> </span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EADDRINUSE</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> Address already in use.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> Only one usage of each socket address (protocol/IP address/port) is normally permitted. This error occurs if an application attempts to bind a socket to an IP address/port that has already been used for an existing socket, or a socket that wasn't closed properly, or one that is still in the process of closing. For server applications that need to bind multiple sockets to the same port number, consider using setsockopt(SO_REUSEADDR). Client applications usually need not call bind at all - connect will choose an unused port automatically. When bind is called with a wild-card address (involving ADDR_ANY), a EADDRINUSE error could be delayed until the specific address is "committed." This could happen with a call to other function later, including connect, listen, Connect or JoinLeaf.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EADDRNOTAVAIL</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> Cannot assign requested address.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> The requested address is not valid in its context. Normally results from an attempt to bind to an address that is not valid for the local machine. This can also result from connect, sendto, Connect, JoinLeaf, or SendTo when the remote address or port is not valid for a remote machine (e.g. address or port 0).</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> </span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ENETDOWN</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> Network is down.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> A socket operation encountered a dead network. This could indicate a serious failure of the network system (i.e. the protocol stack that the WinSock DLL runs over), the network interface, or the local network itself.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> </span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>ENOBUFS</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> No buffer space available.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>EISCONN</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> Socket is already connected.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> A connect request was made on an already connected socket. Some implementations also return this error if sendto is called on a connected SOCK_DGRAM socket (For SOCK_STREAM sockets, the to parameter in sendto is ignored), although other implementations treat this as a legal occurrence.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><strong>连接过程可能出现的错误情况有：</strong></span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（1） 如果客户机TCP协议没有接收到对它的SYN数据段的确认，函数以错误返回，错误类型为ETIMEOUT。通常TCP协议在发送SYN数据段失败之后，会多次发送SYN数据段，在所有的发送都高中失败之后，函数以错误返回。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">注：SYN（synchronize）位：请求连接。TCP用这种数据段向对方TCP协议请求建立连接。在这个数据段中，TCP协议将它选择的初始 序列号通知对方，并且与对方协议协商最大数据段大小。SYN数据段的序列号为初始序列号，这个SYN数据段能够被确认。当协议接收到对这个数据段的确认之 后，建立TCP连接。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（2） 如果远程TCP协议返回一个RST数据段，函数立即以错误返回，错误类型为ECONNREFUSED。当远程机器在SYN数据段指定的目的端口号处没有服 务进程在等待连接时，远程机器的TCP协议将发送一个RST数据段，向客户机报告这个错误。客户机的TCP协议在接收到RST数据段后不再继续发送SYN 数据段，函数立即以错误返回。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">注：RST（reset）位：表示请求重置连接。当TCP协议接收到一个不能处理的数据段时，向对方TCP协议发送这种数据段，表示这个数据段所标 识的连接出现了某种错误，请求TCP协议将这个连接清除。有3种情况可能导致TCP协议发送RST数据段：（1）SYN数据段指定的目的端口处没有接收进 程在等待；（2）TCP协议想放弃一个已经存在的连接；（3）TCP接收到一个数据段，但是这个数据段所标识的连接不存在。接收到RST数据段的TCP协 议立即将这条连接非正常地断开，并向应用程序报告错误。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（3） 如果客户机的SYN数据段导致某个路由器产生“目的地不可到达”类型的ICMP消息，函数以错误返回，错误类型为EHOSTUNREACH或 ENETUNREACH。通常TCP协议在接收到这个ICMP消息之后，记录这个消息，然后继续几次发送SYN数据段，在所有的发送都告失败之后，TCP 协议检查这个ICMP消息，函数以错误返回。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">注：ICMP：Internet 消息控制协议。Internet的运行主要是由Internet的路由器来控制，路由器完成IP数据包的发送和接收，如果发送数据包时发生错误，路由器使 用 ICMP协议来报告这些错误。ICMP数据包是封装在IP数据包的数据部分中进行传输的，其格式如下：</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">类型码</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">校验和</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">数据</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">0 8 16 24 31</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">类型：指出ICMP数据包的类型。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">代码：提供ICMP数据包的进一步信息。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">校验和：提供了对整个ICMP数据包内容的校验和。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">ICMP数据包主要有以下类型：</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（1） 目的地不可到达：A、目的主机未运行；B、目的地址不存在；C、路由表中没有目的地址对应的条目，因而路由器无法找到去往目的主机的路由。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（2） 超时：路由器将接收到的IP数据包的生存时间（TTL）域减1，如果这个域的值变为0，路由器丢弃这个IP数据包，并且发送这种ICMP消息。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（3） 参数出错：当IP数据包中有无效域时发送。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（4） 重定向：将一条新的路径通知主机。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（5） ECHO请求、ECHO回答：这两条消息用语测试目的主机是否可以到达。请求者向目的主机发送ECHO请求ICMP数据包，目的主机在接收到这个ICMP数据包之后，返回ECHO回答ICMP数据包。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（6） 时戳请求、时戳回答：ICMP协议使用这两种消息从其他机器处获得其时钟的当前时间。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 调用函数connect的过程中，当客户机TCP协议发送了SYN数据段的确认之后，TCP状态由CLOSED状态转为SYN_SENT状态，在接 收到对 SYN数据段的确认之后，TCP状态转换成ESTABLISHED状态，函数成功返回。如果调用函数connect失败，应该用close关闭这个套接字 描述符，不能再次使用这个套接字描述符来调用函数connect。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">connect函数的出错处理：</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（1）ETIMEOUT－connection timed out 目的主机不存在，没有返回任何相应，例如主机关闭</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（2）ECONNREFUSED－connection refused（硬错）到达目的主机后，由于各种原因建立不了连接，主机返回RST（复位）响应，例如主机监听进程未启用，tcp取消连接等</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（3）EHOSTTUNREACH－no route to host（软错)路由上引发了一个目的地不可达的ICMP错误</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">  其中（1）（3），客户端会进行定时多次重试，一定次数后才返回错误。另外，当connect连接失败时，sockfd套接口不可用，必须关闭后重新socket分配才行。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">getsockopt 和 setsockopt 还可能引发以下错误：</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">getsockopt/setsockopt(2) man page 写道</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">ERRORS</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">The getsockopt() and setsockopt() system calls will succeed unless:</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">[EBADF] The argument socket is not a valid file descriptor.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">[EFAULT] The address pointed to by option_value is not in a valid part of the process dress space. For getsockopt(), this error may also be returned if option_len is not in a valid part of the process address space.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">[EINVAL] The option is invalid at the level indicated.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">[ENOBUFS]Insufficient memory buffers are available.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">[ENOPROTOOPT] The option is unknown at the level indicated.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">[ENOTSOCK] The argument socket is not a socket (e.g., a plain file).</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">The setsockopt() system call will succeed unless:</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">[EDOM] The argument option_value is out of bounds.</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">[EISCONN]socket is already connected and a specified option cannot be set while this is the case.</span><br> </p> 
<p><a target="_blank" href="http://blog.csdn.net/davintanger/article/details/7679567" rel="noopener noreferrer">http://blog.csdn.net/davintanger/article/details/7679567</a><br> </p> 
<p><a target="_blank" href="http://blog.csdn.net/saspss/article/details/8487678" rel="noopener noreferrer">http://blog.csdn.net/saspss/article/details/8487678</a><br> </p> 
<p><a target="_blank" href="http://blog.csdn.net/benbendy1984/article/details/5773137" rel="noopener noreferrer">http://blog.csdn.net/benbendy1984/article/details/5773137</a><br> </p> 
<p><a target="_blank" href="http://www.ccvita.com/515.html" rel="nofollow noopener noreferrer">http://www.ccvita.com/515.html</a><br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea571adccfd557b401042f5e767d668d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">labview 隐藏控件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8904c9852695a2f1889ee45480dc505d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">找回回收站已删除的文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>