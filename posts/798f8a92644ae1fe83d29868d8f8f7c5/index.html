<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;补充内容--EasyX-UI界面 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;补充内容--EasyX-UI界面" />
<meta property="og:description" content="esay x 其他 地图打印(利用二维数组) 双缓冲 当我们绘制一张图 然后另一张图盖住前一张图的某个部分的时候 由于while的存在 会导致 两张图不停的闪烁 所以加入双缓冲可以解决这个问题
开启双缓冲 之后等待Flush或者End 才会进行图片的绘制 不然不会进行图片的绘制,这样就可以保证每次while的执行 都是以一整套为单位进行的 执行到双缓冲状态结束或者flush 才将之前的内容同时绘制 也就是蓝色和白色同时绘制(这样虽然每次都在循环绘制 但是每一次绘制的效果一样 就不会出现闪烁) 而不是蓝色先绘制 之后白色再绘制
有以下两种方式
注意::
如果开启双缓冲状态之后 中途进行了函数的跳转 那么函数里要将双缓冲状态结束 不然一直没有结束双缓冲状态的话 函数里的绘图也不会进行绘制 而是等待双缓冲状态的结束
颜色和格式的设置 设置颜色和格式都是设置了一种状态 在这之后的填充都会采用这种状态 所以设置状态要在真正填充之前 所以每次填充之前最好都设置一次状态
键盘的输入 _kbhit() 以及_getch()都是控制台函数 会导致操作与界面割裂开 所以建议使用Get这个函数 该函数直接传入一个大写w即可包含小写w,因为他的参数是虚拟键
补充:VC虚拟值表 可放入GetAsyncKeyState的参数
https://blog.csdn.net/qq_42372031/article/details/105178789
界面的设计 按钮和鼠标 按钮 设置文本所占矩形的位置坐标 对于横轴 先将文本矩形的左边像素坐标移动到按钮的中间 之后 减去文本矩形像素的一半 就可以实现左边一半右边一半 就可以对齐了
纵轴同理
鼠标 先对鼠标的状态进行设置,采用枚举类型
同时定义全局变量 Message msg; 或者 ExMessage msg;
定义鼠标状态函数 获取在某一时刻 各个按钮内的鼠标状态
之后 获取到鼠标的位置 是否在按钮中间 并对鼠标是否点击进行判断 并返回枚举变量" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/798f8a92644ae1fe83d29868d8f8f7c5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T16:06:06+08:00" />
<meta property="article:modified_time" content="2024-01-06T16:06:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;补充内容--EasyX-UI界面</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="esay_x_0"></a>esay x</h2> 
<h3><a id="_1"></a>其他</h3> 
<p><img src="https://images2.imgbox.com/3d/dc/RowWLL5P_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_4"></a>地图打印(利用二维数组)</h3> 
<p><img src="https://images2.imgbox.com/5c/e5/1f8za2vs_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c7/04/t7RTQUpu_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_9"></a>双缓冲</h3> 
<p>当我们绘制一张图 然后另一张图盖住前一张图的某个部分的时候 由于while的存在 会导致 两张图不停的闪烁 所以加入双缓冲可以解决这个问题<br> <img src="https://images2.imgbox.com/84/8b/RDG4uiaN_o.png" alt="在这里插入图片描述"><br> 开启双缓冲 之后等待Flush或者End 才会进行图片的绘制 不然不会进行图片的绘制,这样就可以保证每次while的执行 都是以一整套为单位进行的 执行到双缓冲状态结束或者flush 才将之前的内容同时绘制 也就是蓝色和白色同时绘制(这样虽然每次都在循环绘制 但是每一次绘制的效果一样 就不会出现闪烁) 而不是蓝色先绘制 之后白色再绘制</p> 
<p>有以下两种方式<br> <img src="https://images2.imgbox.com/51/71/x4ebYCTE_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/58/fe/UvCFYCw7_o.png" alt="在这里插入图片描述"><br> 注意::<br> <img src="https://images2.imgbox.com/ce/be/s6flNoS4_o.png" alt="在这里插入图片描述"><br> 如果开启双缓冲状态之后 中途进行了函数的跳转 那么函数里要将双缓冲状态结束 不然一直没有结束双缓冲状态的话 函数里的绘图也不会进行绘制 而是等待双缓冲状态的结束</p> 
<h3><a id="_23"></a>颜色和格式的设置</h3> 
<p><img src="https://images2.imgbox.com/31/a8/hm196GYz_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/90/1e/l9ee6MCh_o.png" alt="在这里插入图片描述"><br> 设置颜色和格式都是设置了一种状态 在这之后的填充都会采用这种状态 所以设置状态要在真正填充之前 所以每次填充之前最好都设置一次状态</p> 
<h3><a id="_29"></a>键盘的输入</h3> 
<p><img src="https://images2.imgbox.com/f0/07/Py8DsUzh_o.png" alt="在这里插入图片描述"><br> _kbhit() 以及_getch()都是控制台函数 会导致操作与界面割裂开 所以建议使用Get这个函数 该函数直接传入一个大写w即可包含小写w,因为他的参数是虚拟键<br> <img src="https://images2.imgbox.com/c5/df/IqW51B4J_o.png" alt="在这里插入图片描述"></p> 
<p>补充:VC虚拟值表 可放入GetAsyncKeyState的参数</p> 
<p>https://blog.csdn.net/qq_42372031/article/details/105178789</p> 
<h3><a id="_37"></a>界面的设计</h3> 
<p><img src="https://images2.imgbox.com/b5/f7/jQylrYhF_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_39"></a>按钮和鼠标</h3> 
<h4><a id="_40"></a>按钮</h4> 
<p><img src="https://images2.imgbox.com/3f/6d/eldb0gTu_o.png" alt="在这里插入图片描述"><br> 设置文本所占矩形的位置坐标 对于横轴 先将文本矩形的左边像素坐标移动到按钮的中间 之后 减去文本矩形像素的一半 就可以实现左边一半右边一半 就可以对齐了<br> 纵轴同理<br> <img src="https://images2.imgbox.com/20/1f/r5FkEfgd_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_45"></a>鼠标</h4> 
<p><img src="https://images2.imgbox.com/68/4b/b8Nl2ert_o.png" alt="在这里插入图片描述"><br> 先对鼠标的状态进行设置,采用枚举类型</p> 
<p>同时定义全局变量 Message msg; 或者 ExMessage msg;</p> 
<p><img src="https://images2.imgbox.com/13/0d/PsdRGta4_o.png" alt="在这里插入图片描述"><br> 定义鼠标状态函数 获取在某一时刻 各个按钮内的鼠标状态</p> 
<p>之后 获取到鼠标的位置 是否在按钮中间 并对鼠标是否点击进行判断 并返回枚举变量</p> 
<p>鼠标状态判断函数的参数是按钮的结构体变量,也就是对每个按钮分别判断 以按钮为视角 看鼠标是否在该按钮内 一个按钮一个按钮的方式进行判断</p> 
<p><img src="https://images2.imgbox.com/0a/48/vTRoywQ9_o.png" alt="在这里插入图片描述"><br> 参数分别是三个按钮 返回值分别是在目前的时刻 鼠标在三个按钮的状态<br> 在绘图函数里调用判断鼠标状态<br> if(peekmessage(&amp;msg,EX_MOUSE))用来判断鼠标是否点击在当前程序 有可能鼠标在该程序以外的地方操作</p> 
<h4><a id="_64"></a>鼠标经过时变色</h4> 
<p><img src="https://images2.imgbox.com/f4/07/MBBTOj1F_o.png" alt="在这里插入图片描述"><br> 首先对按钮的绘制函数进行颜色的参数设置,方便后续更改 注意 颜色宏定义的类型是int类型</p> 
<p><img src="https://images2.imgbox.com/99/4d/wgRBT1tf_o.png" alt="在这里插入图片描述"><br> 注意画按钮的函数 参数先添加一个颜色变量</p> 
<p>之后 函数体里填充按钮颜色的参数也要改为buttoncolor 不可以再使用自己规定死的颜色了</p> 
<p><img src="https://images2.imgbox.com/87/95/59iXrTao_o.png" alt="在这里插入图片描述"><br> 之后 将状态整数放在while外面 使其作用域包含整个while</p> 
<p>注意点:只要画面要进行动态变化的 都要放入循环里 所以 按钮绘图也要放入循环<br> 然后用三目运算符进行传参数</p> 
<h3><a id="_80"></a>查阅帮助文档</h3> 
<p>(以textwidth为例)</p> 
<p><img src="https://images2.imgbox.com/8a/7b/KUCshoao_o.png" alt="在这里插入图片描述"><br> 注意 要严格按照文档参数类型的规定 去写代码<br> 如上图 规定参数是LPCTSTR类型的字符串 那么在程序中就要这样定义<br> <img src="https://images2.imgbox.com/2b/41/aXLrD4zL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_88"></a>将某段文字放在某个位置</h3> 
<p><img src="https://images2.imgbox.com/ff/15/1K0UDxrD_o.png" alt="在这里插入图片描述"><br> 用到outtextxy函数 其中参数分别为 第一个字母的x坐标 第一个字母的y坐标 文本</p> 
<p>如下图 注意 必须是LPCTSTR类型的字符串<br> <img src="https://images2.imgbox.com/37/0a/GDHhG0J6_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da458cf7e5f88d3a5ef79a9bb23fddeb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java、Javascript、Javaweb三者的区别及说明</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c341c4b0193714bf4b4702d734039d96/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;内容补充--面向对象篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>