<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java技术总结（基础篇） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java技术总结（基础篇）" />
<meta property="og:description" content="仅对部分java基础内容做了简单整理，若有笔误或错误出现，欢迎大家指教。
一、JavaSE 1.Java分为三个体系： JavaSE→java平台标准版JavaEE→java平台企业版JavaME→java平台微型版 2.Java编程语言主要特性： 面向对象分布式简单化多线程安全跨平台移植性 3.JVM、JRE、JDK JVM：Java虚拟机(主要用于与操作系统进行交互)JRE:Java运行时环境(包含了JVM，Java提供的核心类库)JDK:Java开发工具包(包含了JRE，Java开发工具集) 4.JDK包结构 ①为了便于使用和维护，JDK类库按照包结构划分，不同功能的类划分在不同的包中。②java.lang→Java程序的基础类，如字符串、多线程等该包中的类使用的比较频繁，不需要导包，可以直接使用。③java.util→常用的工具类，如集合、随机产生器、日历等。④java.io→文件操作，输入/输出操作。⑤java.math→数学运算相关的操作。⑥java.sql→数据库访问。 5.标识符命名规范： ①由26个英文字母大小写，0~9，_或$组成。②数字不能开头。③不能包含空格。④java严格区分大小写。⑤不能使用关键字，可以包含关键字。⑥尽量&#34;见名知意&#34;。 6.变量名命名规范： ①长度不能超过255个字符②※变量名在有效范围内必须是唯一的(声明变量)③多单词组成时，第一单词首字母小写，从第二个单词开始，每个单词首字母大写 7.运算符： ①算数运算符：&#43;, -, *, /, %, &#43;&#43;, –②关系运算符：&gt;, &lt;, ==, &lt;=, &gt;=, !=③逻辑运算符：&amp;, |, &amp;&amp;, ||, !, ^④赋值运算符：=, *=, /=, &#43;=, -=, %=⑤三元运算符：(条件表达式)?表达式1(true):表达式2(false);⑥位运算符 8.基本数据类型（4类/8种） ①整数类型：byte(8位), short(16位), int(位32/默认), long(64位)②浮点型：float(32位), double(64位/默认)③布尔型：boolean(true/false)④字符型：char(char c = ‘a’😉 9.类型转换（自动类型转换/强制类型转换） 1.自动类型转换：
byte/short/char→int→long→float→double
备注：其中byte、short、char三者之间不能直接相互转换
2.强制类型转换（是自动类型转换的逆过程）：
布尔型不能进行类型转换精度损失内存溢出 10.循环结构 ①while循环
while(条件表达式){
循环体；
}
②do_while循环
do{
循环体;
}while(条件表达式)；
③for循环
for(初始化;条件表达式;更新){
循环体
}
④嵌套循环
外层循环控制行数，内层循环控制每行的个数内层循环是外层循环的循环体 ⑤关键字break/continue
break:跳出，结束continue:跳过，越过 11." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c28ffb2a1d36ae397eefddc6c7591ca7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-05T16:48:04+08:00" />
<meta property="article:modified_time" content="2020-03-05T16:48:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java技术总结（基础篇）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>仅对部分java基础内容做了简单整理，若有笔误或错误出现，欢迎大家指教。</strong></p> 
<h4><a id="JavaSE_1"></a>一、JavaSE</h4> 
<h6><a id="1Java_2"></a>1.Java分为三个体系：</h6> 
<ul><li>JavaSE→java平台标准版</li><li>JavaEE→java平台企业版</li><li>JavaME→java平台微型版</li></ul> 
<h6><a id="2Java_7"></a>2.Java编程语言主要特性：</h6> 
<ul><li>面向对象</li><li>分布式</li><li>简单化</li><li>多线程</li><li>安全</li><li>跨平台移植性</li></ul> 
<h6><a id="3JVMJREJDK_15"></a>3.JVM、JRE、JDK</h6> 
<ul><li>JVM：Java虚拟机(主要用于与操作系统进行交互)</li><li>JRE:Java运行时环境(包含了JVM，Java提供的核心类库)</li><li>JDK:Java开发工具包(包含了JRE，Java开发工具集)</li></ul> 
<h6><a id="4JDK_20"></a>4.JDK包结构</h6> 
<ul><li>①为了便于使用和维护，JDK类库按照包结构划分，不同功能的类划分在不同的包中。</li><li>②java.lang→Java程序的基础类，如字符串、多线程等该包中的类使用的比较频繁，不需要导包，可以直接使用。</li><li>③java.util→常用的工具类，如集合、随机产生器、日历等。</li><li>④java.io→文件操作，输入/输出操作。</li><li>⑤java.math→数学运算相关的操作。</li><li>⑥java.sql→数据库访问。</li></ul> 
<h6><a id="5_28"></a>5.标识符命名规范：</h6> 
<ul><li>①由26个英文字母大小写，0~9，_或$组成。</li><li>②数字不能开头。</li><li>③不能包含空格。</li><li>④java严格区分大小写。</li><li>⑤不能使用关键字，可以包含关键字。</li><li>⑥尽量"见名知意"。</li></ul> 
<h6><a id="6_36"></a>6.变量名命名规范：</h6> 
<ul><li>①长度不能超过255个字符</li><li>②※变量名在有效范围内必须是唯一的(声明变量)</li><li>③多单词组成时，第一单词首字母小写，从第二个单词开始，每个单词首字母大写</li></ul> 
<h6><a id="7_41"></a>7.运算符：</h6> 
<ul><li>①算数运算符：+, -, *, /, %, ++, –</li><li>②关系运算符：&gt;, &lt;, ==, &lt;=, &gt;=, !=</li><li>③逻辑运算符：&amp;, |, &amp;&amp;, ||, !, ^</li><li>④赋值运算符：=, *=, /=, +=, -=, %=</li><li>⑤三元运算符：(条件表达式)?表达式1(true):表达式2(false);</li><li>⑥位运算符</li></ul> 
<h6><a id="848_49"></a>8.基本数据类型（4类/8种）</h6> 
<ul><li>①整数类型：byte(8位), short(16位), int(位32/默认), long(64位)</li><li>②浮点型：float(32位), double(64位/默认)</li><li>③布尔型：boolean(true/false)</li><li>④字符型：char(char c = ‘a’😉</li></ul> 
<h6><a id="9_55"></a>9.类型转换（自动类型转换/强制类型转换）</h6> 
<p>1.自动类型转换：<br> byte/short/char→int→long→float→double<br> 备注：其中byte、short、char三者之间不能直接相互转换</p> 
<p>2.强制类型转换（是自动类型转换的逆过程）：</p> 
<ul><li>布尔型不能进行类型转换</li><li>精度损失</li><li>内存溢出</li></ul> 
<h6><a id="10_65"></a>10.循环结构</h6> 
<p>①while循环<br> while(条件表达式){<!-- --><br> 循环体；<br> }</p> 
<p>②do_while循环<br> do{<!-- --><br> 循环体;<br> }while(条件表达式)；</p> 
<p>③for循环<br> for(初始化;条件表达式;更新){<!-- --><br> 循环体<br> }</p> 
<p>④嵌套循环</p> 
<ul><li>外层循环控制行数，内层循环控制每行的个数</li><li>内层循环是外层循环的循环体</li></ul> 
<p>⑤关键字break/continue</p> 
<ul><li>break:跳出，结束</li><li>continue:跳过，越过</li></ul> 
<h6><a id="11_89"></a>11.数组</h6> 
<p>（1）数组的作用：用于批量保存一类数据，数组是引用数据类型之一。</p> 
<p>（2）数组的注意：</p> 
<ul><li>无论是动态初始化还是静态初始化，必须为数组指明长度</li><li>数组为每个元素的位置提供了一个索引值(下标、下脚标)，索引值从0开始到数组的长度-1结束</li><li>获取数组长度的属性:length</li></ul> 
<p>（3）数组的初始化操作<br> ①动态初始化：数组的初始化和赋值操作分开进行</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
</code></pre> 
<p>②静态初始化：数组的初始化和赋值同时进行</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>③简单数组</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>（4）获取数组中元素<br> ①根据数组元素下脚标获取</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>②使用普通循环遍历数组中元素</p> 
<pre><code class="prism language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>③使用增强for循环遍历数组中元素</p> 
<pre><code class="prism language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>被遍历数组中元素的数据类型  变量名 <span class="token operator">:</span> 被遍历的数组名<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>变量名<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（5）数组常见算法：</p> 
<ul><li>求数组元素的最大值、最小值、平均值、总和</li><li>数组的复制和反转</li><li>数组元素的排序</li></ul> 
<p>（6）数组的复制<br> ①System.arrayCopy方法用于数组的复制</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">arrayCopy</span><span class="token punctuation">(</span>Object src<span class="token punctuation">,</span> <span class="token keyword">int</span> srcPos<span class="token punctuation">,</span> Object dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span> <span class="token keyword">int</span> legth<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">//arrayCopy方法中5个参数详解：</span>
	<span class="token comment">//①src→源数组</span>
	<span class="token comment">//②srcPos→源数组中的起始位置(索引值)</span>
	<span class="token comment">//③dest→目标数组</span>
	<span class="token comment">//④destPos→目标数组中的起始位置(索引值)</span>
	<span class="token comment">//⑤legth→要复制的数组中元素的数量</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>②Arrays.copyOf（数组的扩容）<br> ※数组的长度在创建后是不可以改变的，所谓扩容是指创建一个更大的新数组，并将原有数组的内容复制到新数组中，通过Arrays.copyOf方法实现。</p> 
<pre><code class="prism language-java">Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> newLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//original→源数组</span>
	<span class="token comment">//newLength→新数组长度</span>
	<span class="token comment">//注意：新长度大于原长度，用默认值补充；新长度小于原长度，进行截取</span>
</code></pre> 
<p>（7）二维数组<br> 二维数组中的元素是一维数组，如果想要获取二维数组中的数据，首先遍历二维数组，遍历出来的分别是二维数组中的每个一维数组，其次再分别遍历每个一维数组，获取想要的数据。</p> 
<p>※遍历二维数组方法：</p> 
<ul><li>普通for循环遍历二维数组</li><li>增强for循环遍历二维数组</li></ul> 
<h6><a id="12_177"></a>12.方法(函数、过程)</h6> 
<p>（1）含义：</p> 
<ul><li>①方法用于封装一段特定的逻辑功能。</li><li>②方法可以在程序中反复调用。</li><li>③方法可以减少代码的重复，便于程序维护。</li><li>④Java中方法不能独立存在，所有方法必须定义在类中。</li><li>⑤是一个类中最基本的功能单元。</li></ul> 
<p>（2）定义方法的五个要素：</p> 
<ul><li>修饰符</li><li>返回值</li><li>方法名</li><li>参数列表</li><li>方法体</li></ul> 
<p>（3）方法声明方式</p> 
<pre><code class="prism language-java">修饰符  返回值类型<span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span>无返回值<span class="token punctuation">)</span>  方法名<span class="token punctuation">(</span>参数类型  参数<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	执行代码<span class="token punctuation">;</span>
 	<span class="token keyword">return</span> 返回值<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">//返回类型为int的值</span>
	<span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">noResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"返回值为'void'类型，则无需‘return’关键字且无需返回任何值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（4）方法的参数列表</p> 
<ul><li>①方法的参数列表中，可以含0到多个参数，是局部变量。</li><li>②调用方法时，参数的类型与数量需要完全匹配。</li><li>③方法的参数，是指在调用时传递给方法的，需要被方法处理的数据。</li><li>④方法可以有参数，也可以没有参数，有参可使方法处理更加灵活。</li><li>⑤在定义方法时，需要声明该方法所需要的参数变量。</li></ul> 
<p>（5）方法的注意：</p> 
<ul><li>①※方法中可以调用其他方法，不可以在方法声明方法。</li><li>②"返回值类型"与"返回值"的数据类型必须保持一致。</li><li>③调用方法时，传递实际参数的数据类型必须与形式参数的数据类型保持一致。</li><li>④若声明了返回值类型，说明方法运行后有结果，若调用者需要用到该结果，可以声明一个变量接收该结果，声明变量的数据类型需要和返回值结果数据类型保持一致。</li><li>⑤若方法运行后不需要任何结果给调用者时，"返回值类型"处声明为void。</li><li>⑥若方法没有返回值，return可以省略不写。</li></ul> 
<p>（6）声明方法需要明确两点</p> 
<ul><li>明确方法运行结束后是否需要返回结果给调用者，如果调用者需要运行后的结果，则要明确返回值类型，且方法中必须有‘return’关键字；否则返回值类型为‘void’，且无需使用‘return’关键字。</li><li>明确是否有未知的数据参与运算。</li></ul> 
<p>（7）方法的重载<br> ①概念：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可。<br> ②注意：</p> 
<ul><li>※必须在同一个类中。</li><li>方法名称必须相同。</li><li>参数列表必须不同(参数类型、参数的数量、参数的顺序)。</li><li>与返回值无关。</li></ul> 
<h6><a id="13_237"></a>13.位与字节</h6> 
<ul><li>①计算机中任何的计算和存储都是以二进制方式实现的。</li><li>②位(bit)-是计算机中最小的存储单元。</li><li>③字节(byte)-计算机中基本的存储单元。</li><li>④1byte = 8bits。</li></ul> 
<h6><a id="14_243"></a>14.进制：</h6> 
<ul><li>①二进制：0,1，满2进1，以0b或0B开头。</li><li>②十进制：0~9，满10进1。</li><li>③八进制：0~7，满8进1，八进制数被冠以0来开头。</li><li>④十六进制：0 ~ 9和A ~ F,满16进1，十六进制数被冠以0x开头(A~F，字母大小写均可)。</li></ul> 
<h4><a id="OOPObject_Oriented_Programming_249"></a>二、面向对象(OOP：Object Oriented Programming)</h4> 
<h6><a id="1_250"></a>1.面向对象与面向过程</h6> 
<p>二者都是一种思想，面向对象是相对于面向过程而言的。</p> 
<ul><li>面向过程：强调的是功能行为</li><li>面向对象：将功能封装进对象，强调了具备功能的对象</li></ul> 
<h6><a id="2_255"></a>2.类和对象是面向对象的核心概念</h6> 
<ul><li>类：对一类事物的描述，具有相同属性或功能，是抽象的</li><li>对象：是实际存在的该类事物的每个个体，因而也称为实例</li></ul> 
<h6><a id="3_259"></a>3.面向对象三大特性：</h6> 
<ul><li>封装</li><li>继承</li><li>多态</li></ul> 
<h6><a id="4_264"></a>4.类是对现实世界事物的抽象定义</h6> 
<ul><li>属性：对应类中的成员变量</li><li>行为：对应类中的成员方法</li></ul> 
<h6><a id="5_268"></a>5.局部变量与成员变量</h6> 
<p>局部变量：声明在方法体中的变量<br> 成员变量：声明在类以内，方法以外的变量<br> ①成员变量：</p> 
<ul><li>定义在类以内，在整个类中都可以被访问</li><li>分为类成员变量和实例成员变量，实例成员变量存在于对象所在的堆内存中</li><li>由默认初始化值</li><li>权限修饰符可以根据需要，选择任意一个</li></ul> 
<p>②局部变量：</p> 
<ul><li>只定义在局部范围内，如方法内</li><li>存在于栈内存中</li><li>作用的范围结束，变量空间会自动释放</li><li>没有默认初始化值，每次必须显示初始化</li><li>声明时不指定权限修饰符</li></ul> 
<h6><a id="6_284"></a>6.参数值传递：</h6> 
<ul><li>基本数据类型：当基本数据类型作为参数传递给方法，方法运行后值不会发生改变。</li><li>引用数据类型：当引用数据类型作为参数传递给方法，方法运行后值会发生改变。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestOOP1</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>	
		TestOOP1 test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestOOP1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">/*int aa = 10;
		int bb = 20;
		test.add(aa, bb);
		System.out.println("main方法a="+aa+",b="+bb);*/</span>
		
		Number num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		num<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
		num<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main调用add前：a="</span><span class="token operator">+</span>num<span class="token punctuation">.</span>a<span class="token operator">+</span><span class="token string">",b="</span><span class="token operator">+</span>num<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10,20</span>
		test<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main调用add后：a="</span><span class="token operator">+</span>num<span class="token punctuation">.</span>a<span class="token operator">+</span><span class="token string">",b="</span><span class="token operator">+</span>num<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		Number num1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		num1<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
		num1<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1<span class="token punctuation">.</span>a<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>num1<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
	
	<span class="token comment">//基本数据类型值传递</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		a <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
		b <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"add方法a="</span><span class="token operator">+</span>a<span class="token operator">+</span><span class="token string">",b="</span><span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//变量的格式：数据类型  变量名</span>
	<span class="token comment">//Number n = new Number();</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Number n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"add执行前：a="</span><span class="token operator">+</span>n<span class="token punctuation">.</span>a<span class="token operator">+</span><span class="token string">",b="</span><span class="token operator">+</span>n<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10,20</span>
		n<span class="token punctuation">.</span>a <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		n<span class="token punctuation">.</span>b <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"add执行后：a="</span><span class="token operator">+</span>n<span class="token punctuation">.</span>a<span class="token operator">+</span><span class="token string">",b="</span><span class="token operator">+</span>n<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//11,22</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Number</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="7_334"></a>7.面向对象特性之一：封装</h6> 
<p>封装的理解：把该隐藏的隐藏起来，该暴露的暴露出来</p> 
<p>（1）访问权限修饰符：</p> 
<ul><li>public:共有的，用于修饰属性、方法、类，可以在任何地方访问。</li><li>private:私有的，可用于修饰属性、方法，只能在本类中访问</li></ul> 
<p>（2）封装的步骤：</p> 
<ul><li>属性私有化(private)</li><li>提供公共方法(public)的setXxx()和getXxx()</li></ul> 
<p>（3）封装的目的：<br> Java中通过将数据声明为私有的(private)，在提供公共的方法(public)，setXxx()和getXxx()实现对属性<br> 的初始化操作：</p> 
<ul><li>隐藏一个类中不需要对外提供的实现细节。</li><li>使用者只能通过实现定制好的方法来访问数据，可以方便的加入控制逻辑，限制对属性的不合理操作。</li><li>便于修改，增强代码的可维护性。</li></ul> 
<h6><a id="8_352"></a>8.构造器</h6> 
<p>（1）类的成员：</p> 
<ul><li>属性</li><li>方法</li><li>构造器</li></ul> 
<p>（2）构造器：也叫构造方法，是类的成员之一</p> 
<p>（3）构造器的格式：</p> 
<pre><code class="prism language-java">访问权限修饰符  类名<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	执行语句<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（4）构造器的作用：</p> 
<ul><li>创建对象。</li><li>为对象进行初始化。</li></ul> 
<p>（5）构造器的注意：</p> 
<ul><li>构造器的名称必须与类名保持一致。</li><li>若一个类中没有显示提供任何构造器时，系统会默认提供一个无参构造器：public Animal(){}。</li><li>若一个类中提供了任何构造器时，系统默认无参构造器将不再提供。</li><li>构造器之间可以构成重载。</li><li>构造器只能调用一次，并且是在创建对象时调用。</li></ul> 
<p>（6）构造器的重载：</p> 
<ul><li>构造的名称相同。</li><li>参数列表不同(参数类型、参数个数)。</li></ul> 
<p>（7）构造器的特征：</p> 
<ul><li>它具有与类相同的名称。</li><li>它不声明返回值类型。</li><li>不能有return返回值。</li></ul> 
<p>（8）构造器分类：</p> 
<ul><li>隐式无参构造器(系统默认提供)。</li><li>显示定义一个或多个构造器(无参、有参)。</li></ul> 
<h6><a id="9this_392"></a>9.this关键字</h6> 
<ul><li>this关键字：使用在本类中，代表当前对象，可用于调用属性、方法、**构造器。</li><li>this可用于区分成员变量和局部变量。</li><li>谁让拥有this关键字的方法运行，谁就是当前对象。</li><li>this调用本类构造器，必须写在构造器中可执行代码首行。</li><li>要避免递归构造器调用，一个类中至少有一个构造器不使用this调用其他构造器。</li></ul> 
<h6><a id="10_399"></a>10.面向对象特性之二：继承</h6> 
<p>（1）继承：使用关键字extends→"扩展"→子类是父类的扩展；<br> 通过继承，子类可以继承父类中所有的属性和方法(构造器除外)</p> 
<p>（2）为什么要有继承？</p> 
<ul><li>多个类存在形同属性和行为时，将这些内容提取到一个单独类中那么多个类无需在定义这些属性和方法，只要继承那个类即可，提高代码复用性。</li><li>便于维护。</li></ul> 
<p>（3）继承的注意：</p> 
<ul><li>不能为了简化代码、获取某个功能而继承，若要完成继承两个类之间要有一定的关系。</li><li>Java中只支持单继承，不支持多继承(一个父类可以有多个子类，一个子类只能有一个父类)。</li><li>Java支持多层继承。</li></ul> 
<p>（4）关于继承的规则：</p> 
<ul><li>父类中的成员，无论是共有还是私有的，均被子类继承。</li><li>子类不能对继承的私有成员直接进行访问，可以通过继承的公共方法来访问。</li></ul> 
<p>（5）属性的特点：</p> 
<ul><li>当子类继承父类后，若子类中出现了与父类同名的属性时，创建子类对象操作该属性时，实际上调用的是子类的属性值，若需要访问父类的属性时，使用super关键字。</li><li>当子类继承父类后，子类可以继承父类中所有的属性，包括私有的，但是因为private修饰符的作用，子类无法直接访问父类中属性值，若需要访问父类的私有属性，需要父类提供set/get方法。</li></ul> 
<p>（6）关键字：super</p> 
<ul><li>用法和this关键字一模一样。</li><li>this:使用在本类中，代表当前对象。</li><li>super:使用在子类中，代表父类对象。</li></ul> 
<p>（7）方法的特点：<br> ①方法的重写(方法覆盖OverRide):</p> 
<ul><li>若父类的方法对于子类来说不适用的情况下，子类可以对父类的方法进行重写。</li><li>当子类继承父类后，子类中出现了和父类中方法签名一模一样时，创建子类对象调用该方法时，实际运行的是子类的方法，如同将父类中的方法覆盖了一样。</li></ul> 
<p>②方法重写的规则：</p> 
<ul><li>前提：要有继承关系。</li><li>方法名称和参数类表必须相同。</li><li>返回值类型可以不同，但是有一定规则(子类重写方法的返回值类型可以是父类被重写方法返回值类型的子类)通常在应用时，方法签名一模一样。</li><li>子类重写方法的访问权限修饰符不能小于父类被重写方法的访问权限修饰符。</li></ul> 
<h6><a id="11_437"></a>11.面向对象的特性之三：多态</h6> 
<p>（1）多态的体现：</p> 
<ul><li>方法的重写和方法的重载。</li><li>对象的多态性：父类的引用指向子类的对象。</li></ul> 
<p>（2）多态的前提：</p> 
<ul><li>必须要有继承关系。</li><li>要有方法的重写(为了完成虚拟方法调用)。</li></ul> 
<p>（3）引用数据类型之间的转换：</p> 
<ul><li>前提：要有继承关系。</li><li>无继承关系的引用类型间的转换是非法的。</li><li>向上造型：子类转父类，系统自动完成。</li><li>向下造型：父类转子类，需要使用强转符，容易引发类型转换异常（ClassCastException）。</li></ul> 
<p>（4）多态数组：数组中可以存储父类本类类型的对象以及子类类型的对象。</p> 
<p>（5）intstanceof运算符：判断引用指向的对象是不是本类类型的对象，若是，则返回true，否则返回false。</p> 
<h6><a id="12_456"></a>12.访问权限修饰符：</h6> 
<ul><li>private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的属性以及方法只能被该类的对象 访问，其子类不能访问，更不能允许跨包访问。</li><li>protected: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。被其修饰的属性以及方法只能被类本 身的方法及子类访问，即使子类在不同的包中也可以访问。</li><li>default：即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。该模式下，只允许在同一个包中进行访问。</li><li>public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且 允许跨包访问。<br> <img src="https://images2.imgbox.com/1e/40/cd8V3PTJ_o.png" alt="在这里插入图片描述"></li></ul> 
<h6><a id="13static_462"></a>13.static关键字</h6> 
<p>（1）static修饰符：静态的，可用于修饰属性、方法、代码块、内部类</p> 
<p>（2）类属性、类方法的设计思想：</p> 
<ul><li>类属性：是作为该类各个对象之间共享的变量。在设计类时，分析哪些类属性不因对象的不同而改变，将这些设置为类属性。</li><li>类方法：如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</li></ul> 
<p>（3）static修饰的属性(类变量或静态变量)</p> 
<ul><li>静态变量随着类的加载而加载，随着类的消失而消失(生命周期最长)。</li><li>静态变量被所有该类对象所共享。</li><li>一旦某一对象对该属性值进行改变，其他对象的该属性值也会随之改变。</li><li>※静态变量的存在优先于对象。</li><li>我们可以通过"类名.类变量"的方式访问。</li></ul> 
<p>（4）static修饰的方法(类方法或静态方法)</p> 
<ul><li>静态方法随着类的加载而加载，随着类的消失而消失。</li><li>静态方法的存在优先于对象。</li><li>可以通过"类名.类方法"的方式调用。</li><li>静态方法不能使用非静态成员。</li><li>静态方法不能使用this和super关键字。</li></ul> 
<p>（5）静态代码块和非静态代码块<br> 1.非静态代码块</p> 
<ul><li>格式：类中的一对{}。</li><li>在每次创建对象时执行。</li><li>非静态代码块优先于构造器执行。</li><li>非静态代码块用于为对象进行初始化操作(通常用于为共性内容进行初始化)。</li><li>非静态代码块可以有多个，依次向下的顺序执行。</li></ul> 
<p>2.静态代码块</p> 
<ul><li>格式：static{}。</li><li>随着类的加载而加载，并且只加载一次。</li><li>静态代码块的执行优先于非静态代码块。</li><li>静态代码块不可以调用非静态成员。</li><li>静态代码块可以有多个，依次向下的顺序执行。</li></ul> 
<p>3.为属性赋初始值的方式<br> ①默认赋值。<br> ②直接显示赋值。<br> ③构造器。<br> ④非静态代码块。<br> 顺序：① ②④ ③<br> 注意：②和④顺序赋值</p> 
<h6><a id="14final_506"></a>14.final关键字</h6> 
<p>（1）最终的，可用于修饰 变量 、方法、类。</p> 
<ul><li>final修饰的类不能被继承。</li><li>final修饰的方法不能被重写。</li><li>final修饰的变量叫做常量，一旦被赋值，值不能改变。</li></ul> 
<p>（2）常量：</p> 
<ul><li>常量的命名规范：所有字母都大写，多单词组成时每个单词之间有"_"分隔。</li><li>常量没有默认值，在使用前必须赋初始值(直接显示赋值，构造器，代码块)若使用构造器为常量赋值，必须保证所有构造器都为该常量赋值。</li></ul> 
<h6><a id="15abstract_516"></a>15.抽象类（使用关键字：abstract）</h6> 
<p>（1）抽象类：</p> 
<ul><li>格式：abstract class 类名{}。</li><li>拥有一个或多个抽象方法的类 必须 是 抽象类。</li><li>抽象类中可以有抽象方法。</li><li>抽象类中也可以没有抽象方法。</li><li>※抽象类不可以创建实例。</li><li>抽象类中可以声明构造器，目的：当子类继承父类后，继承父类中所有属性和方法，因此子类需要知道父类是如何为对象初始化的。</li></ul> 
<p>（2）抽象方法：</p> 
<ul><li>格式：访问权限修饰符 abstract 返回值类型 方法名(参数列表);<br> 注意：抽象方法没有方法体，所以不需要后面那对{}。</li><li>子类继承父类后，若重写了父类中所有的抽象方法，该类为具体类。</li><li>子类继承父类后，若没有重写父类中所有的抽象方法，该类必须为抽象类。</li></ul> 
<p>（3）注意事项：</p> 
<ul><li>abstract和static不能同时使用。</li><li>abstract和final不能同时使用。</li><li>abstract和private不能同时使用。</li></ul> 
<h6><a id="16interface_537"></a>16.接口（使用关键字：interface）</h6> 
<p>（1）接口的特点：</p> 
<ul><li>接口与类是平级的，使用关键字：interface，例如：public interface Fly{}。</li><li>可以把接口理解为特殊的抽象类，因为接口中只能定义"全局静态常量"和"抽象方法"。</li><li>接口中不能有变量、构造器、代码块、一般方法。</li><li>※接口不能创建实例。</li><li>接口就是用来被实现的，使用关键字：implements，例如：class Bird implements Fly{}。</li><li>实现接口的类称为"实现类"，实现类的功能与继承一样，实现类可以"继承"接口中的所有成员。</li><li>实现类实现了接口中的所有抽象方法，该类为具体类，可以创建实例。</li><li>实现类若没有实现接口中所有的抽象方法，那么该类必须是抽象类，不可以创建实例。</li><li>接口支持多实现，解决了Java中单继承的局限性。</li><li>接口不能继承任何类，接口可以继承借口，并且可以多继承接口。</li><li>一个类可以继承另一个类，同时实现多个接口，注意：先继承，后实现。</li></ul> 
<h6><a id="17_551"></a>17.集合</h6> 
<p>（1）特点：就是一种容器，用于存储、获取、操作对象的容器。</p> 
<p>（2）集合与数组的区别：<br> ①数组：</p> 
<ul><li>长度不可变的。</li><li>数组中没有提供可以查看有效元素个数的办法。</li></ul> 
<p>②集合：</p> 
<ul><li>集合的长度是可以改变的。</li><li>集合中可以存储任意类型的对象。</li><li>集合中只能存储对象。</li></ul> 
<p>（3）集合框架：</p> 
<ul><li>java.util.Collection:集合层次的根接口<br> |- - java.util.List：有序的，并且允许重复的，List体系的集合具有索引值。<br> |- - java.util.Set：无序的，不允许重复的。</li></ul> 
<p>（4）集合常用方法：</p> 
<ul><li>add(Object obj) : 添加元素到集合中。 参数为 Object，意味着可以添加任意类型的对象 。</li><li>size() : 获取集合中元素的个数。</li><li>clear() : 清空集合中所有的元素。</li><li>isEmpty() : 判断集合是否为空。</li><li>addAll(Collection coll) : 将 coll 中所有的元素，添加到当前集合中。</li><li>contains(Object obj) : 判断集合中是否包含某元素。 判断元素是否存在的依据是使用 equals() 方法。</li><li>containsAll(Collection coll) : 判断 coll 中的所有元素是否包含在当前集合中。</li><li>remove(Object obj) : 移除集合中某元素。</li><li>removeAll(Collection coll) : 移除 coll 中所有的元素。</li><li>retainAll(Collection coll):取交集。</li><li>toArray() : 可以将集合转换成数组。</li></ul> 
<h6><a id="18IO_582"></a>18.IO流</h6> 
<p>（1）IO流特点：</p> 
<ul><li>I/O是Input/Output的缩写，IO技术是非常实用的技术，如读写操作、网络通讯等。</li><li>流：是指从源节点到目标节点的过程。</li><li>源节点和目标节点可以是文件、网络、键盘、显示器…</li><li>源节点的数据流称为输入流(用来读取数据)。</li><li>目标节点的数据流称为输出流(用来写入数据)。</li><li>文件 – 输入流 → 程序 – 输出流 → 文件。</li></ul> 
<p>（2）IO流的分类：</p> 
<ul><li>①按流向不同：输入流、输出流(以程序为主体)。</li><li>②按数据不同：字节流、字符流</li><li>-字节流：字节流用于操作非文本文件，.jpg/.png/.mp4/.avi，(以byte为传输单位，8bit)。</li><li>-字符流：字符流用于操作文本文件， .java/.txt，(以char为传输单位，16bit)。</li><li>③按角色不同：节点流、处理流。</li></ul> 
<p>（3）IO流的结构体系：<br> <img src="https://images2.imgbox.com/49/fb/zt48eafo_o.png" alt="在这里插入图片描述"><br> （4）对象流：ObjectInputStream和ObjectOutputStream</p> 
<ul><li>①作用：用于存储和读取基本数据类型数据或对象的处理流，它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li><li>②对象的序列化：对象的序列化机制，允许吧内存中的Java对象转换成与平台无关的二进制流，从而允许吧这种二进制流持久的保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获取了这种二进制流，就可以恢复成原来的对象。</li><li>③序列化：用ObjectOutputStream类保存基本数据类型或对象的机制。</li><li>④反序列化：用ObjectInputStream类读取基本数据类型或对象的机制。</li><li>⑤对象序列化步骤： 
  <ul><li>a.创建节点流；</li><li>b.创建缓冲流，并包装对应的节点流(可选，用于提高传输效率)；</li><li>c.创建对象流，同时包装缓冲流；</li><li>d.完成对象的序列化操作；</li><li>e.关闭流；</li><li>f.需要序列化对象的类必须实现java.lang.io.Serializable接口；</li><li>g.提供一个序列号 private static final long serialVersionUID = 123L;</li></ul> </li></ul> 
<h6><a id="19_615"></a>19.多线程</h6> 
<p>（1）含义区分：</p> 
<ul><li>程序：是为完成特定任务、用某种语言编写的一组指令的集合。即值一段静态的代码，静态对象。</li><li>进程：是程序的一次执行过程，或是正在运行的一个程序。</li><li>线程：进程可进一步划分为线程，是一个程序内部的一条执行路径。</li></ul> 
<p>（2）什么时候需要多线程？</p> 
<ul><li>①程序需要同时执行两个或多个任务。</li><li>②程序需要实现一些需要等待的任务时。</li><li>③需要一些后台运行的程序。</li></ul> 
<p>（3）使用多线程的优点：</p> 
<ul><li>①提高应用程序的相应，对图形化界面更有意义，可增强用户体验。</li><li>②提高计算机CPU的利用率。</li><li>③改善程序结构。将既长又复杂的进程分为多个线程独立运行，便于理解和修改。</li></ul> 
<p>（4）多线程的创建和使用：通过java.lang.Thread类来实现。<br> ※Thread类的特性：</p> 
<ul><li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，通常把run()方法的主体称为线程体。</li><li>通过该Thread对象的start()方法来调用该线程。</li><li>※抢占式策略系统：系统会为每个执行任务的线程分配一个很小的时间片段，当该时间片段用完之后，系统会剥夺其使用CPU的权限，交给其他线程执行任务。</li></ul> 
<p>（5）创建执行线程的方式之一：</p> 
<ul><li>①创建一个类继承Thread类。</li><li>②重写Thread类中的run()方法,同时编写线程体。</li><li>③创建该子类的实例。</li><li>④通过start()方法启动线程,默认执行run()方法。</li></ul> 
<p>（6）创建执行线程的方式之二：</p> 
<ul><li>①声明一个类实现Runnable接口。</li><li>②实现接口中的run()方法，同时编写线程执行体。</li><li>③创建该实现类的实例。</li><li>④创建Thread类的实例，将实现类的实例作为参数传递给Thread的构造器。</li><li>⑤调用Thread的start()方法，启动线程。</li></ul> 
<p>（7）线程的控制：</p> 
<ul><li>①sleep(long millis):是一个静态方法，使当前线程进入睡眠状态。</li><li>②join()/join(long millis):当某个线程执行中调用其他线程的join()方法时，调用线程将被阻塞，直到join()方法加入的线程执行完为止。</li><li>③interrupt():中断线程的阻塞状态。</li><li>④isAlive():判断当前线程是否处于存活状态。</li><li>⑤yield():暂停当前正在执行的线程，把执行机会让给优先级相同或者更高的线程若队列中没有同优先级的多线程，忽略此方法。</li></ul> 
<p>（8）线程的生命周期：</p> 
<ul><li>①新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态；</li><li>②就绪：处于新建状态的线程被start()之后，将进入线程队列等待CPU时间片段，此时它已经具备了运行的条件；</li><li>③运行：当就绪的线程被调度并获得处理器资源时，便进人运行状态，run()定义了线程的操作和功能；</li><li>④阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU资源并临时终止自己的执行，进入阻塞状态；</li><li>⑤死亡：线程完成了它的全部工作或线程被提前强制性的终止。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3cbb92b5dacf5057c8d3723b586c3b61/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">&#39;you-get&#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26112d9b95d34f27db60a4d47084e169/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">花了半个月，终于把Python库全部整理出来了，非常全面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>