<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深度学习算法之cifar10数据集训练和测试步骤以及相关代码Pytorch - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深度学习算法之cifar10数据集训练和测试步骤以及相关代码Pytorch" />
<meta property="og:description" content="今天忽然看到 CIFAR10的分类，自己就直接进行了相关备注，给初学者分享一下，如果代码跑不通，可以评论区反馈。一起进步。 整体步骤就是下面5部分。
使用torchvision加载并标准化 CIFAR10 训练和测试数据集定义卷积神经网络定义损失函数根据训练数据训练网络在测试数据上测试网络 1、首先导入包 torchvision.transforms用于进行图片变换（归一化等操作），torchvision含有一些数据集可以直接下载使用，matplotlib用于画图的包，torch.optim用于优化器部分。
import torch import torchvision import torchvision.transforms as transforms import matplotlib.pyplot as plt import numpy as np import torch.nn as nn import torch.nn.functional as F import torch.optim as optim 二、加载数据集 并查看数据集 transform = transforms.Compose( [transforms.ToTensor(),#模型只接受tensor格式 transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])#进行平均值，方差的标准化 trainset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=True, download=True, transform=transform)#如果为download=False则表示不需要下载，但是本地必须要有相应的文件 trainloader = torch.utils.data.DataLoader(trainset, batch_size=4, shuffle=True, num_workers=2) #shuffle=True是将数据集的图片打乱，这样有利于训练 testset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=False, download=True, transform=transform) testloader = torch." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/933e5db3020b95b3e19115e6eb2e4383/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-02T09:47:57+08:00" />
<meta property="article:modified_time" content="2022-03-02T09:47:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深度学习算法之cifar10数据集训练和测试步骤以及相关代码Pytorch</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>今天忽然看到 CIFAR10的分类，自己就直接进行了相关备注，给初学者分享一下，如果代码跑不通，可以评论区反馈。一起进步。</h3> 
<p>整体步骤就是下面5部分。</p> 
<ol><li>使用<code>torchvision</code>加载并标准化 CIFAR10 训练和测试数据集</li><li>定义卷积神经网络</li><li>定义损失函数</li><li>根据训练数据训练网络</li><li>在测试数据上测试网络</li></ol> 
<h3>1、首先导入包</h3> 
<p>torchvision.transforms用于进行图片变换（归一化等操作），torchvision含有一些数据集可以直接下载使用，matplotlib用于画图的包，torch.optim用于优化器部分。</p> 
<pre><code>import torch
import torchvision
import torchvision.transforms as transforms
import matplotlib.pyplot as plt
import numpy as np
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim</code></pre> 
<h3>二、加载数据集 并查看数据集</h3> 
<pre><code>transform = transforms.Compose(
    [transforms.ToTensor(),#模型只接受tensor格式
     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])#进行平均值，方差的标准化

trainset = torchvision.datasets.CIFAR10(root='./data', train=True,
                                        download=True, transform=transform)#如果为download=False则表示不需要下载，但是本地必须要有相应的文件
trainloader = torch.utils.data.DataLoader(trainset, batch_size=4,
                                          shuffle=True, num_workers=2)
#shuffle=True是将数据集的图片打乱，这样有利于训练
testset = torchvision.datasets.CIFAR10(root='./data', train=False,
                                       download=True, transform=transform)
testloader = torch.utils.data.DataLoader(testset, batch_size=4,
                                         shuffle=False, num_workers=2)

classes = ('plane', 'car', 'bird', 'cat',#这是该数据的类别
           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')
</code></pre> 
<pre><code>#展示图片
def imshow(img):
    img = img / 2 + 0.5     # unnormalize 归一化操作
    npimg = img.numpy()
    plt.imshow(np.transpose(npimg, (1, 2, 0)))
    plt.show()

# get some random training images
dataiter = iter(trainloader)
images, labels = dataiter.next()#这是一个迭代器。

# show images
imshow(torchvision.utils.make_grid(images))
# print labels
print(' '.join('%5s' % classes[labels[j]] for j in range(4)))
</code></pre> 
<h3>三、定义模型 </h3> 
<pre><code>#这个模型比较简单，大家可以更换复杂模型，只要维度对上就行
class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.conv1 = nn.Conv2d(3, 6, 5) #输入通道数3，输出通道数为6，卷积核为5x5大小
        self.pool = nn.MaxPool2d(2, 2)#最大池化层
        self.conv2 = nn.Conv2d(6, 16, 5)
        self.fc1 = nn.Linear(16 * 5 * 5, 120)#全连接层，必须将[16，5 ， 5]先view()成16 * 5 * 5才能使用全连接层
        self.fc2 = nn.Linear(120, 84)
        self.fc3 = nn.Linear(84, 10)

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = x.view(-1, 16 * 5 * 5)
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = self.fc3(x)
        return x

net = Net()#实例化网络模型
#损失函数为交叉熵损失函数
#采用的是优化器是随机梯度下降优化器（是包含动量部分的）
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)


</code></pre> 
<h3> 四、进行训练</h3> 
<pre><code>for epoch in range(2):  # 所需要训练的轮次

    running_loss = 0.0
    for i, data in enumerate(trainloader, 0):
        # get the inputs; data = [inputs, labels]
        inputs, labels = data
        #得到输入图片和标签
        # 梯度需要清零，否则会干扰模型
        optimizer.zero_grad()

        # forward + backward + optimize
        outputs = net(inputs)
        loss = criterion(outputs, labels)
        loss.backward()#反项传播
        optimizer.step()

        # print statistics
        running_loss += loss.item()#.item()这也属于迭代器，将每一步的损失取出来
        if i % 2000 == 1999:    # print every 2000 mini-batches
            print('[%d, %5d] loss: %.3f' %
                  (epoch + 1, i + 1, running_loss / 2000))
            running_loss = 0.0

print('Finished Training')
</code></pre> 
<h3> 五、保存模型并进行验证</h3> 
<pre><code>PATH = './cifar_net.pth'#权重路径
torch.save(net.state_dict(), PATH)#保存所有权重，也有保存部分权重的，大家可以去网上找找
</code></pre> 
<pre><code>dataiter = iter(testloader)
images, labels = dataiter.next()

# print images
imshow(torchvision.utils.make_grid(images))
print('GroundTruth: ', ' '.join('%5s' % classes[labels[j]] for j in range(4)))
</code></pre> 
<pre><code>net = Net()
net.load_state_dict(torch.load(PATH))#加载训练好的模型
outputs = net(images)
_, predicted = torch.max(outputs, 1)

print('Predicted: ', ' '.join('%5s' % classes[predicted[j]]
                              for j in range(4)))
correct = 0
total = 0
with torch.no_grad():
    for data in testloader:
        images, labels = data
        outputs = net(images)
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

print('Accuracy of the network on the 10000 test images: %d %%' % (
    100 * correct / total))
</code></pre> 
<p> 用于测试每一个类别所对应的概率</p> 
<pre><code>class_correct = list(0\. for i in range(10))
class_total = list(0\. for i in range(10))
with torch.no_grad():
    for data in testloader:
        images, labels = data
        outputs = net(images)
        _, predicted = torch.max(outputs, 1)
        c = (predicted == labels).squeeze()
        for i in range(4):
            label = labels[i]
            class_correct[label] += c[i].item()
            class_total[label] += 1

for i in range(10):
    print('Accuracy of %5s : %2d %%' % (
        classes[i], 100 * class_correct[i] / class_total[i]))
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ccd880d531630baa938cdb5de0c587db/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【已解决】Uncaught ReferenceError require is not defined</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/37dfc8996b2675065cf9ec694252f58b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（软考高级、高项）信息系统项目管理师（第三版)过关经验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>