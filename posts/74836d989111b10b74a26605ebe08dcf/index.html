<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Llvm的类型转换系统 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Llvm的类型转换系统" />
<meta property="og:description" content="Llvm内置了一个类型转换系统，并定义了类似于dynamic_cast这样的转换函数。Llvm底层的很大部分是由模板类构成的，这个转换系统对于模板类间的类型判断及转换至为重要。以下只是描述这个转换系统的一个框架，该系统的正确实现，还依赖于参与模板类正确实现某些函数（下面会提到）。
cast_retty类 cast_or_null是llvm所提供的类型转换系统的部分，这是一个有趣的模板实现。这个实现在llvm-3.1/include/llvm/support/Casting.h。
202 template &lt;class X, class Y&gt;
203 inline typename cast_retty&lt;X,Y*&gt;::ret_type_cast_or_null(Y *Val) {
204 if (Val == 0) return0;
205 assert(isa&lt;X&gt;(Val) &amp;&amp; &#34;cast_or_null&lt;Ty&gt;()argument of incompatible type!&#34;);
206 returncast&lt;X&gt;(Val);
207 }
首先，cast_or_null的返回类型是cast_retty中定义的ret_type类型。cast_retty只定义了ret_type（cast_retty顾名思义是cast return type的意思）。
156 template&lt;class To, classFrom&gt;
157 struct cast_retty{
158 typedef typename cast_retty_wrap&lt;To,From,
159 typenamesimplify_type&lt;From&gt;::SimpleType&gt;::ret_typeret_type;
160 };
这个ret_type则是typedef自cast_retty_wrap提供中定义的ret_type。
142 template&lt;class To, class From,class SimpleFrom&gt;
143 struct cast_retty_wrapp{
144 // When thesimplified type and the from type are not the same, use the type" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/74836d989111b10b74a26605ebe08dcf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-05-04T11:59:59+08:00" />
<meta property="article:modified_time" content="2014-05-04T11:59:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Llvm的类型转换系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Llvm内置了一个类型转换系统，并定义了类似于dynamic_cast这样的转换函数。Llvm底层的很大部分是由模板类构成的，这个转换系统对于模板类间的类型判断及转换至为重要。以下只是描述这个转换系统的一个框架，该系统的正确实现，还依赖于参与模板类正确实现某些函数（下面会提到）。</p> 
<h6>cast_retty类</h6> 
<p>cast_or_null是llvm所提供的类型转换系统的部分，这是一个有趣的模板实现。这个实现在llvm-3.1/include/llvm/support/Casting.h。</p> 
<p> </p> 
<p><em><span style="color:silver">202   </span></em><span style="color:blue">template</span> &lt;<span style="color:blue">class</span> X, <span style="color:blue">class</span> Y&gt;</p> 
<p><em><span style="color:silver">203   </span></em><span style="color:blue">inline</span> <span style="color:blue">typename</span> <a target="_blank" href="#cast_retty" rel="nofollow noopener noreferrer">cast_retty</a>&lt;X,Y*&gt;::ret_type_cast_or_null(Y *Val) {<!-- --></p> 
<p><em><span style="color:silver">204   </span></em>  if (Val == 0) <span style="color:blue"> return</span>0;</p> 
<p><em><span style="color:silver">205   </span></em>  <span style="color:blue">assert</span>(<a target="_blank" href="#isa" rel="nofollow noopener noreferrer">isa</a>&lt;X&gt;(Val) &amp;&amp; "cast_or_null&lt;Ty&gt;()argument of incompatible type!");</p> 
<p><em><span style="color:silver">206   </span></em>  <span style="color:blue">return</span>cast&lt;X&gt;(Val);</p> 
<p><em><span style="color:silver">207   </span></em>}</p> 
<p> </p> 
<p>首先，cast_or_null的返回类型是cast_retty中定义的ret_type类型。cast_retty只定义了ret_type（cast_retty顾名思义是cast return type的意思）。</p> 
<p> </p> 
<p><em><span style="color:silver">156   </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">class</span> To, <span style="color:blue">class</span>From&gt;</p> 
<p><em><span style="color:silver">157   </span></em><span style="color:blue">struct</span> cast_retty{<!-- --></p> 
<p><em><span style="color:silver">158   </span></em>  <span style="color:blue">typedef</span> <span style="color:blue">typename</span> <a target="_blank" href="#cast_retty_wrap" rel="nofollow noopener noreferrer"> cast_retty_wrap</a>&lt;To,From,</p> 
<p><em><span style="color:silver">159   </span></em>                   <span style="color:blue"> typename</span><a target="_blank" href="#simplify_type" rel="nofollow noopener noreferrer">simplify_type</a>&lt;From&gt;::SimpleType&gt;::ret_typeret_type;</p> 
<p><em><span style="color:silver">160   </span></em>};</p> 
<p> </p> 
<p>这个ret_type则是typedef自cast_retty_wrap提供中定义的ret_type。</p> 
<p> </p> 
<p><em><span style="color:silver">142   </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">class</span> To, <span style="color:blue">class</span> From,<span style="color:blue">class</span> SimpleFrom&gt;</p> 
<p><em><span style="color:silver">143   </span></em><span style="color:blue">struct</span> cast_retty_wrapp{<!-- --></p> 
<p><em><span style="color:silver">144   </span></em>  <span style="color:green">// When thesimplified type and the from type are not the same, use the type</span></p> 
<p><em><span style="color:silver">145   </span></em>  <span style="color:green">// simplifier toreduce the type, then reuse cast_retty_impl to get the</span></p> 
<p><em><span style="color:silver">146   </span></em>  <span style="color:green">// resultant type.</span></p> 
<p><em><span style="color:silver">147   </span></em>  <span style="color:blue">typedef</span> <span style="color:blue">typename</span> <a target="_blank" href="#cast_retty" rel="nofollow noopener noreferrer">cast_retty</a>&lt;To,SimpleFrom&gt;::ret_type ret_type;</p> 
<p><em><span style="color:silver">148   </span></em>};</p> 
<p><em><span style="color:silver">149   </span></em></p> 
<p><em><span style="color:silver">150   </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">class</span> To, <span style="color:blue">class</span>FromTy&gt;</p> 
<p><em><span style="color:silver">151   </span></em><span style="color:blue">struct</span>cast_retty_wrap&lt;To, FromTy, FromTy&gt; {<!-- --></p> 
<p><em><span style="color:silver">152   </span></em>  <span style="color:green">// When thesimplified type is equal to the from type, use it directly.</span></p> 
<p><em><span style="color:silver">153   </span></em>  <span style="color:blue">typedef</span> <span style="color:blue">typename</span> <a target="_blank" href="#cast_retty_impl" rel="nofollow noopener noreferrer"> cast_retty_impl</a>&lt;To,FromTy&gt;::ret_typeret_type;</p> 
<p><em><span style="color:silver">154   </span></em>};</p> 
<p> </p> 
<p>看到cast_retty_wrap非特化版本在147行又递归回了cast_retty。这是怎么回事？在cast_retty定义的159行，simplify_type的定义如下：</p> 
<p> </p> 
<p><em><span style="color:silver">30     </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">typename</span> From&gt; <span style="color:blue">struct simplify_type </span>{<!-- --></p> 
<p><em><span style="color:silver">31     </span></em>  <span style="color:blue">typedef</span>       From SimpleType;        <span style="color:green">// The realtype this represents...</span></p> 
<p><em><span style="color:silver">32     </span></em></p> 
<p><em><span style="color:silver">33     </span></em>  <span style="color:green"> // An accessor toget the real value...</span></p> 
<p><em><span style="color:silver">34     </span></em>  <span style="color:blue">static</span>SimpleType &amp;getSimplifiedValue(From &amp;Val) { <span style="color:blue">return</span>Val; }</p> 
<p><em><span style="color:silver">35     </span></em>};</p> 
<p><em><span style="color:silver">36     </span></em></p> 
<p><em><span style="color:silver">37     </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">typename</span> From&gt; <span style="color:blue">struct</span>simplify_type&lt;<span style="color:blue">const</span> From&gt; {<!-- --></p> 
<p><em><span style="color:silver">38     </span></em>  <span style="color:blue">typedef</span> <span style="color:blue">const</span> From SimpleType;</p> 
<p><em><span style="color:silver">39     </span></em>  <span style="color:blue">static</span>SimpleType &amp;getSimplifiedValue(<span style="color:blue">const</span> From&amp;Val) {<!-- --></p> 
<p><em><span style="color:silver">40     </span></em>    <span style="color:blue"> return</span>simplify_type&lt;From&gt;::getSimplifiedValue(<span style="color:blue">static_cast</span>&lt;From&amp;&gt;(Val));</p> 
<p><em><span style="color:silver">41     </span></em>  }</p> 
<p><em><span style="color:silver">42     </span></em>};</p> 
<p> </p> 
<p>类型SimpleType就是参数From。不过这只是Casting.h提供的默认实现，这个类的本义是提供类型简化，实际上在llvm及Clang的许多地方都另外提供了特化的simplify_type的定义，那么147行cast_retty的每次递归都将化简类型一次，直到无法化简（即调用上面的默认simplify_type实现），这时142行的类型From与SimpleFrom相同，因此使用cast_retty_wrap在150行的特化形式，进而由cast_retty_impl确定该类型。</p> 
<p> </p> 
<p><em><span style="color:silver">122   </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">class</span> To, <span style="color:blue">class</span>From&gt; <span style="color:blue">struct</span> cast_retty_impl {<!-- --></p> 
<p><em><span style="color:silver">123   </span></em>  <span style="color:blue">typedef</span>To&amp; ret_type;         <span style="color:green">// Normal case, return Ty&amp;</span></p> 
<p><em><span style="color:silver">124   </span></em>};</p> 
<p><em><span style="color:silver">125   </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">class</span> To, <span style="color:blue">class</span>From&gt; <span style="color:blue">struct</span> cast_retty_impl&lt;To, <span style="color:blue">const</span> From&gt; {<!-- --></p> 
<p><em><span style="color:silver">126   </span></em>  <span style="color:blue">typedef</span> <span style="color:blue">const</span> To &amp;ret_type;   <span style="color:green">// Normal case,return Ty&amp;</span></p> 
<p><em><span style="color:silver">127   </span></em>};</p> 
<p><em><span style="color:silver">128   </span></em></p> 
<p><em><span style="color:silver">129   </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">class</span> To, <span style="color:blue">class</span>From&gt; <span style="color:blue">struct</span> cast_retty_impl&lt;To,From*&gt; {<!-- --></p> 
<p><em><span style="color:silver">130   </span></em>  <span style="color:blue">typedef</span> To*ret_type;         <span style="color:green">// Pointer arg case, return Ty*</span></p> 
<p><em><span style="color:silver">131   </span></em>};</p> 
<p><em><span style="color:silver">132   </span></em></p> 
<p><em><span style="color:silver">133   </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">class</span> To, <span style="color:blue">class</span>From&gt; <span style="color:blue">struct</span> cast_retty_impl&lt;To, <span style="color:blue">const</span> From*&gt; {<!-- --></p> 
<p><em><span style="color:silver">134   </span></em>  <span style="color:blue">typedef</span> <span style="color:blue">const</span> To* ret_type;  <span style="color:green">// Constant pointer arg case, return const Ty*</span></p> 
<p><em><span style="color:silver">135   </span></em>};</p> 
<p><em><span style="color:silver">136   </span></em></p> 
<p><em><span style="color:silver">137   </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">class</span> To, <span style="color:blue">class</span>From&gt; <span style="color:blue">struct</span> cast_retty_impl&lt;To, <span style="color:blue">const</span> From*<span style="color:blue">const</span>&gt;{<!-- --></p> 
<p><em><span style="color:silver">138   </span></em>  <span style="color:blue">typedef</span> <span style="color:blue">const</span> To* ret_type;  <span style="color:green">// Constant pointer arg case, return const Ty*</span></p> 
<p><em><span style="color:silver">139   </span></em>};</p> 
<p> </p> 
<p>为什么要采用这么复杂的返回值类型声明呢？因为C++制订的类型转换规则仅允许调用用户定义的转换操作符一次，而这里则不限制转换的次数，只要给出simplify_type的特化实现，当然这样存在cast_retty陷入无限递归的情形（实际上无限递归是不存在的，因为C++限制了模板嵌套的层数，GCC好像是128）。</p> 
<h6><a target="_blank" name="_1.5.1.2.1.2._isa%E5%87%BD%E6%95%B0"></a>isa函数</h6> 
<p>Isa函数的作用是测试给定的变量是否具有指定的类型。</p> 
<p> </p> 
<p><em><span style="color:silver">108   </span></em><span style="color:blue">template</span> &lt;<span style="color:blue">class</span> X, <span style="color:blue">class</span> Y&gt;</p> 
<p><em><span style="color:silver">109   </span></em><span style="color:blue">inline</span> bool isa(<span style="color:blue">const</span> Y &amp;Val) {<!-- --></p> 
<p><em><span style="color:silver">110   </span></em>  <span style="color:blue">return</span> <a target="_blank" href="#isa_impl_wrap" rel="nofollow noopener noreferrer">isa_impl_wrap</a>&lt;X, Y, <span style="color:blue"> typename</span><a target="_blank" href="#simplify_type" rel="nofollow noopener noreferrer">simplify_type</a>&lt;Y&gt;::SimpleType&gt;::doit(Val);</p> 
<p><em><span style="color:silver">111   </span></em>}</p> 
<p> </p> 
<p>这里再次应用了simplify_type来简化类型Y，并作为模板参数SimpleFrom的实参调用下面的函数。</p> 
<p> </p> 
<p><em><span style="color:silver">84     </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">typename</span> To, <span style="color:blue">typename</span>From, <span style="color:blue">typename</span> SimpleFrom&gt;</p> 
<p><em><span style="color:silver">85     </span></em><span style="color:blue">struct</span> isa_impl_warp {<!-- --></p> 
<p><em><span style="color:silver">86     </span></em>  <span style="color:green"> // When From !=SimplifiedType, we can simplify the type some more by using</span></p> 
<p><em><span style="color:silver">87     </span></em>  <span style="color:green"> // thesimplify_type template.</span></p> 
<p><em><span style="color:silver">88     </span></em>  <span style="color:blue">static</span> booldoit(<span style="color:blue">const</span> From &amp;Val) {<!-- --></p> 
<p><em><span style="color:silver">89     </span></em>    <span style="color:blue"> return</span>isa_impl_wrap&lt;To, SimpleFrom,</p> 
<p><em><span style="color:silver">90     </span></em>      <span style="color:blue"> typename</span> <a target="_blank" href="#simplify_type" rel="nofollow noopener noreferrer">simplify_type</a>&lt;SimpleFrom&gt;::SimpleType&gt;::doit(</p> 
<p><em><span style="color:silver">91     </span></em>                         simplify_type&lt;From&gt;::getSimplifiedValue(Val));</p> 
<p><em><span style="color:silver">92     </span></em>  }</p> 
<p><em><span style="color:silver">93     </span></em>};</p> 
<p><em><span style="color:silver">94     </span></em></p> 
<p><em><span style="color:silver">95     </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">typename</span> To, <span style="color:blue">typename</span>FromTy&gt;</p> 
<p><em><span style="color:silver">96     </span></em><span style="color:blue">struct</span> isa_impl_wrap&lt;To,FromTy, FromTy&gt; {<!-- --></p> 
<p><em><span style="color:silver">97     </span></em>  <span style="color:green"> // When From ==SimpleType, we are as simple as we are going to get.</span></p> 
<p><em><span style="color:silver">98     </span></em>  <span style="color:blue">static</span> booldoit(<span style="color:blue">const</span> FromTy &amp;Val) {<!-- --></p> 
<p><em><span style="color:silver">99     </span></em>    <span style="color:blue"> return</span> <a target="_blank" href="#isa_impl_cl" rel="nofollow noopener noreferrer">isa_impl_cl</a>&lt;To,FromTy&gt;::doit(Val);</p> 
<p><em><span style="color:silver">100   </span></em>  }</p> 
<p><em><span style="color:silver">101   </span></em>};</p> 
<p> </p> 
<p>在89行对isa_impl_wrap的调用中，也再次使用simplify_type对Y的化简类型（SimpleFrom）进行类型化简。同时对给定的值进行转换（通过getSimplifiedValue，91行）。一旦From与SimpleFrom达成一致，isa_impl_wrap的doit方法（98行）调用isa_impl_cl的对应的方法。</p> 
<p> </p> 
<p><em><span style="color:silver">54     </span></em><span style="color:blue">template</span> &lt;<span style="color:blue">typename</span> To, <span style="color:blue">typename</span>From&gt; <span style="color:blue">struct</span> isa_impl_cl {<!-- --></p> 
<p><em><span style="color:silver">56     </span></em>  <span style="color:blue">static</span> <span style="color:blue">inline</span> bool doit(<span style="color:blue">const</span>From &amp;Val) {<!-- --></p> 
<p><em><span style="color:silver">57     </span></em>    <span style="color:blue"> return</span> <a target="_blank" href="#isa_impl" rel="nofollow noopener noreferrer">isa_impl</a>&lt;To, From&gt;::doit(Val);</p> 
<p><em><span style="color:silver">58     </span></em>  }</p> 
<p><em><span style="color:silver">59     </span></em>};</p> 
<p><em><span style="color:silver">60     </span></em></p> 
<p><em><span style="color:silver">61     </span></em><span style="color:blue">template</span> &lt;<span style="color:blue">typename</span> To, <span style="color:blue">typename</span>From&gt; <span style="color:blue">struct</span> isa_impl_cl&lt;To, <span style="color:blue">const</span> From&gt; {<!-- --></p> 
<p><em><span style="color:silver">62     </span></em>  <span style="color:blue">static</span> <span style="color:blue">inline</span> bool doit(<span style="color:blue">const</span>From &amp;Val) {<!-- --></p> 
<p><em><span style="color:silver">63     </span></em>    <span style="color:blue"> return</span> <a target="_blank" href="#isa_impl" rel="nofollow noopener noreferrer">isa_impl</a>&lt;To, From&gt;::doit(Val);</p> 
<p><em><span style="color:silver">64     </span></em>  }</p> 
<p><em><span style="color:silver">65     </span></em>};</p> 
<p><em><span style="color:silver">66     </span></em></p> 
<p><em><span style="color:silver">67     </span></em><span style="color:blue">template</span> &lt;<span style="color:blue">typename</span> To, <span style="color:blue">typename</span>From&gt; <span style="color:blue">struct</span> isa_impl_cl&lt;To, From*&gt; {<!-- --></p> 
<p><em><span style="color:silver">68     </span></em>  <span style="color:blue">static</span> <span style="color:blue">inline</span> bool doit(<span style="color:blue">const</span>From *Val) {<!-- --></p> 
<p><em><span style="color:silver">69     </span></em>    <span style="color:blue"> return</span> <a target="_blank" href="#isa_impl" rel="nofollow noopener noreferrer">isa_impl</a>&lt;To, From&gt;::doit(*Val);</p> 
<p><em><span style="color:silver">70     </span></em>  }</p> 
<p><em><span style="color:silver">71     </span></em>};</p> 
<p><em><span style="color:silver">72     </span></em></p> 
<p><em><span style="color:silver">73     </span></em><span style="color:blue">template</span> &lt;<span style="color:blue">typename</span> To, <span style="color:blue">typename</span>From&gt; <span style="color:blue">struct</span> isa_impl_cl&lt;To, <span style="color:blue">const</span> From*&gt; {<!-- --></p> 
<p><em><span style="color:silver">74     </span></em>  <span style="color:blue">static</span> <span style="color:blue">inline</span> bool doit(<span style="color:blue">const</span>From *Val) {<!-- --></p> 
<p><em><span style="color:silver">75     </span></em>    <span style="color:blue"> return</span> <a target="_blank" href="#isa_impl" rel="nofollow noopener noreferrer">isa_impl</a>&lt;To, From&gt;::doit(*Val);</p> 
<p><em><span style="color:silver">76     </span></em>  }</p> 
<p><em><span style="color:silver">77     </span></em>};</p> 
<p><em><span style="color:silver">78     </span></em></p> 
<p><em><span style="color:silver">79     </span></em><span style="color:blue">template</span> &lt;<span style="color:blue">typename</span> To, <span style="color:blue">typename</span>From&gt; <span style="color:blue">struct</span> isa_impl_cl&lt;To, <span style="color:blue">const</span> From*<span style="color:blue">const</span>&gt;{<!-- --></p> 
<p><em><span style="color:silver">80     </span></em>  <span style="color:blue">static</span> <span style="color:blue">inline</span> bool doit(<span style="color:blue">const</span>From *Val) {<!-- --></p> 
<p><em><span style="color:silver">81     </span></em>    <span style="color:blue"> return</span> <a target="_blank" href="#isa_impl" rel="nofollow noopener noreferrer">isa_impl</a>&lt;To, From&gt;::doit(*Val);</p> 
<p><em><span style="color:silver">82     </span></em>  }</p> 
<p><em><span style="color:silver">83     </span></em>};</p> 
<p> </p> 
<p>上面所有的定义都调用下面这个类的doit方法。</p> 
<p> </p> 
<p><em><span style="color:silver">47     </span></em><span style="color:blue">template</span> &lt;<span style="color:blue">typename</span> To, <span style="color:blue">typename</span>From&gt;</p> 
<p><em><span style="color:silver">48     </span></em><span style="color:blue">struct</span> isa_impl {<!-- --></p> 
<p><em><span style="color:silver">49     </span></em>  <span style="color:blue">static</span> <span style="color:blue">inline</span> bool doit(<span style="color:blue">const</span>From &amp;Val) {<!-- --></p> 
<p><em><span style="color:silver">50     </span></em>    <span style="color:blue"> return</span>To::classof(&amp;Val);</p> 
<p><em><span style="color:silver">51     </span></em>  }</p> 
<p><em><span style="color:silver">52     </span></em>};</p> 
<p> </p> 
<p>为了实现isa，涉及的类必须定义50行的classof静态成员函数。当然classof的语义由定义它的类来决定，这带来了很高的灵活性。比如，我们不仅可以声明派生类isa基类，甚至不相关的类也可以声明为isa关系。</p> 
<h6>cast函数</h6> 
<p>cast函数的定义也是类似的。</p> 
<p> </p> 
<p><em><span style="color:silver">192   </span></em><span style="color:blue">template</span> &lt;<span style="color:blue">class</span> X, <span style="color:blue">class</span> Y&gt;</p> 
<p><em><span style="color:silver">193   </span></em><span style="color:blue">inline</span> <span style="color:blue">typename</span> <a target="_blank" href="#cast_retty" rel="nofollow noopener noreferrer">cast_retty</a>&lt;X,Y&gt;::ret_type cast (<span style="color:blue">const</span> Y&amp;Val) {<!-- --></p> 
<p><em><span style="color:silver">194   </span></em>  <span style="color:blue">assert</span>(<a target="_blank" href="#isa" rel="nofollow noopener noreferrer">isa</a>&lt;X&gt;(Val) &amp;&amp; "cast&lt;Ty&gt;() argument ofincompatible type!");</p> 
<p><em><span style="color:silver">195   </span></em>  <span style="color:blue">return</span> <a target="_blank" href="#cast_convert_val" rel="nofollow noopener noreferrer">cast_convert_val</a>&lt;X, Y,</p> 
<p><em><span style="color:silver">196   </span></em>                         <span style="color:blue">typename</span> <a target="_blank" href="#simplify_type" rel="nofollow noopener noreferrer">simplify_type</a>&lt;Y&gt;::SimpleType&gt;::doit(Val);</p> 
<p><em><span style="color:silver">197   </span></em>}</p> 
<p> </p> 
<p>注意178行的const_cast。到这里我们可以明白，所谓的cast过程是依靠simplify_type的机制实现的。还有，const_cast之前是C形式的强制类型转换，不过前面cast_convert_val的递归调用能保证Val（注意通过getSimplifiedValue转换）与这个类型相容。</p> 
<p> </p> 
<p><em><span style="color:silver">165   </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">class</span> To, <span style="color:blue">class</span> From,<span style="color:blue">class</span> SimpleFrom&gt; <span style="color:blue">struct cast_convert_val </span>{<!-- --></p> 
<p><em><span style="color:silver">166   </span></em>  <span style="color:green">// This is not asimple type, use the template to simplify it...</span></p> 
<p><em><span style="color:silver">167   </span></em>  <span style="color:blue">static</span> <span style="color:blue">typename</span> <a target="_blank" href="#cast_retty" rel="nofollow noopener noreferrer">cast_retty</a>&lt;To,From&gt;::ret_type doit(<span style="color:blue">const</span> From &amp;Val) {<!-- --></p> 
<p><em><span style="color:silver">168   </span></em>    <span style="color:blue"> return</span>cast_convert_val&lt;To, SimpleFrom,</p> 
<p><em><span style="color:silver">169   </span></em>      <span style="color:blue"> typename</span>simplify_type&lt;SimpleFrom&gt;::SimpleType&gt;::doit(</p> 
<p><em><span style="color:silver">170   </span></em>                         simplify_type&lt;From&gt;::getSimplifiedValue(Val));</p> 
<p><em><span style="color:silver">171   </span></em>  }</p> 
<p><em><span style="color:silver">172   </span></em>};</p> 
<p><em><span style="color:silver">173   </span></em></p> 
<p><em><span style="color:silver">174   </span></em><span style="color:blue">template</span>&lt;<span style="color:blue">class </span>To, <span style="color:blue">class </span>FromTy&gt;<span style="color:blue">struct </span>cast_convert_val&lt;To,FromTy,FromTy&gt;{<!-- --></p> 
<p><em><span style="color:silver">175   </span></em>  <span style="color:green">// This _is_ asimple type, just cast it.</span></p> 
<p><em><span style="color:silver">176   </span></em>  <span style="color:blue">static typename</span><a target="_blank" href="#cast_retty" rel="nofollow noopener noreferrer">cast_retty</a>&lt;To, FromTy&gt;::ret_type doit(<span style="color:blue">const </span>FromTy &amp;Val) {<!-- --></p> 
<p><em><span style="color:silver">177   </span></em>    <span style="color:blue"> typename </span>cast_retty&lt;To,FromTy&gt;::ret_type Res2</p> 
<p><em><span style="color:silver">178   </span></em>     = (<span style="color:blue">typename </span>cast_retty&lt;To,FromTy&gt;::ret_type)<span style="color:blue">const_cast</span>&lt;FromTy&amp;&gt;(Val);</p> 
<p><em><span style="color:silver">179   </span></em>    <span style="color:blue"> return </span>Res2;</p> 
<p><em><span style="color:silver">180   </span></em>  }</p> 
<p><em><span style="color:silver">181   </span></em>};</p> 
<h6>dyn_cast函数</h6> 
<p>利用isa与cast，构建了另一个对应C++的dynamic_cast操作符的dyn_cast函数。</p> 
<p> </p> 
<p><em><span style="color:silver">218   </span></em><span style="color:blue">template</span> &lt;<span style="color:blue">class</span> X, <span style="color:blue">class</span> Y&gt;</p> 
<p><em><span style="color:silver">219   </span></em><span style="color:blue">inline</span> <span style="color:blue">typename</span> <a target="_blank" href="#cast_retty" rel="nofollow noopener noreferrer">cast_retty</a>&lt;X,Y&gt;::ret_type dyn_cast (<span style="color:blue">const</span>Y &amp;Val) {<!-- --></p> 
<p><em><span style="color:silver">220   </span></em>  <span style="color:blue">return</span> <a target="_blank" href="#isa" rel="nofollow noopener noreferrer">isa</a>&lt;X&gt;(Val) ? <a target="_blank" href="#cast" rel="nofollow noopener noreferrer"> cast</a>&lt;X, Y&gt;(Val) :0;</p> 
<p><em><span style="color:silver">221   </span></em>}</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4606c6fa83b536a3260c871463f2e960/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">cocos2d-x安装配置步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1288eb53cf549fd370aafeb736835197/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">“bash: fork: Resource temporarily unavailable”的解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>