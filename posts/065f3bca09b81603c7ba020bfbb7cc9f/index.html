<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AOP实例 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AOP实例" />
<meta property="og:description" content="AOP（Aspect Oriented Programming）面向切面编程
在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
总结：在AOP中切面就是与业务逻辑独立，但又垂直存在于业务逻辑的代码结构中的通用功能组合；切面与业务逻辑相交的点就是切点；连接点就是把业务逻辑离散化后的关键节点；切点属于连接点，是连接点的子集；Advice（增强）就是切面在切点上要执行的功能增加的具体操作；在切点上可以把要完成增强操作的目标对象（Target）连接到切面里，这个连接的方式就叫织入。
基本名词： Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。
Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。
Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。
Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。
Target（目标对象）：织入 Advice 的目标对象.。
Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程
设计模式 责任链模式：
一个请求的处理需要多个对象当中的一个或几个协作处理
角色：
抽象处理者(Handler)：定义出一个处理请求的接口。如果需要，接口可以定义出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。
具体处理者(ConcreteHandler)：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。
优点： 实现了请求者与处理者代码分离
适配器模式：
一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。
角色：
Target：目标抽象类
Adapter：适配器类
Adaptee：适配者类
Client：客户类
桥接模式：
角色：
Abstraction：抽象类
RefinedAbstraction：扩充抽象类
Implementor：实现类接口" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/065f3bca09b81603c7ba020bfbb7cc9f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-19T16:49:01+08:00" />
<meta property="article:modified_time" content="2020-12-19T16:49:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AOP实例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>AOP（Aspect Oriented Programming）面向切面编程<br> <strong>在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</strong><br> 总结：在AOP中切面就是与业务逻辑独立，但又垂直存在于业务逻辑的代码结构中的通用功能组合；切面与业务逻辑相交的点就是切点；连接点就是把业务逻辑离散化后的关键节点；切点属于连接点，是连接点的子集；Advice（增强）就是切面在切点上要执行的功能增加的具体操作；在切点上可以把要完成增强操作的目标对象（Target）连接到切面里，这个连接的方式就叫织入。</p> 
<h3><a id="_4"></a><strong>基本名词：</strong></h3> 
<p><strong>Aspect（切面）</strong>： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。<br> <strong>Joint point（连接点）</strong>：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。<br> <strong>Pointcut（切点）</strong>：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。<br> <strong>Advice（增强）</strong>：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。<br> <strong>Target（目标对象）</strong>：织入 Advice 的目标对象.。<br> <strong>Weaving（织入）</strong>：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</p> 
<h3><a id="_13"></a>设计模式</h3> 
<p><strong>责任链模式：</strong><br> 一个请求的处理需要多个对象当中的一个或几个协作处理<br> <strong>角色：</strong><br> 抽象处理者(Handler)：定义出一个处理请求的接口。如果需要，接口可以定义出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。<br> 具体处理者(ConcreteHandler)：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。<br> <strong>优点：</strong> 实现了请求者与处理者代码分离</p> 
<p><strong>适配器模式：</strong></p> 
<p>一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</p> 
<p><strong>角色：</strong><br> Target：目标抽象类<br> Adapter：适配器类<br> Adaptee：适配者类<br> Client：客户类</p> 
<p><strong>桥接模式：</strong><br> <strong>角色：</strong><br> Abstraction：抽象类<br> RefinedAbstraction：扩充抽象类<br> Implementor：实现类接口<br> ConcreteImplementor：具体实现类</p> 
<h3><a id="_40"></a>使用实例补充：</h3> 
<p>需求：将所有接口中包含身份证的入参都转为大写</p> 
<p>1、引入pom依赖</p> 
<pre><code>&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<p>2、写一个切面</p> 
<pre><code>@Aspect
@Component
public class RequestMappingAspect {
	private static final Logger logger = LoggerFactory.getLogger(RequestMappingAspect.class);

	/**
	 * 切点条件： 含有 @RequestMapping 注解 且 包含HttpServletResponse类型参数的public方法。
	 * 且类在com.gzhc365..子包中
	 */
	@Pointcut("execution(public * com.gzhc365.front.service..*.*(..))")
	private void adviceRequestMapping() {
		// Service层切点
	}

	@Around("adviceRequestMapping()")
	public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {

		logger.info("==========================进入切面==========================" );

		Object[] object = joinPoint.getArgs();
		for (Object obj : object){
			if(obj instanceof Map){
				Map&lt;String ,Object&gt; map = (Map&lt;String, Object&gt;) obj;
				logger.info("原始map==&gt;"+ map );
				if(map.containsKey("idNo")){
					logger.info("=进入idNo判断=====" );
					String idNo = String.valueOf(map.get("idNo"));
					map.put("idNo",idNo.toUpperCase());
				}
				if(map.containsKey("patIdNo")){
					logger.info("=进入patIdNo判断=====" );
					String patIdNo = String.valueOf(map.get("patIdNo"));
					map.put("patIdNo",patIdNo.toUpperCase());
				}
			}
		}
		return joinPoint.proceed(object);

	}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1973b3bb62222c7123974f83b5507c83/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java方法返回值类型归纳</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e14a1d72ad33f05746247bbdccbde1d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">米家的扫地机器人是灰色_米家扫地机器人怎么清理灰尘盒</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>