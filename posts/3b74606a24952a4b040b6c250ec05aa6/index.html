<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统--信号量经典同步问题之写者优先问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统--信号量经典同步问题之写者优先问题" />
<meta property="og:description" content="写者优先比读者优先要复杂一些，写者优先有以下两个内涵：
1. 当写者线程获得临界区的访问权限时， 其他写者线程不要需要要优先于读者线程获得临界区的访问权限，只有当所有的写者线程都执行后，读者线程才能获得权限。
2. 当读者线程获得临界区的访问权限时，写者线程可以实现抢占，即写者线程优先于其他等待的读者线程，只有当所有的写者线程都执行后，读者线程才能获得权限。
有的参考书中对写者优先的定义仅限于上述第一条。有的定义需满足上述两条。下面分别用伪代码实现这两种情况。
int WriteCount=0, ReadCount=0// 共享变量
semaphore WriteMutex=1, ReadMutex=1, x=1,y=1;
void reader()
{
while(1)
{
sem_wait( ReadMutex);
sem_wait(x); // 保证原子操作
&#43;&#43;ReadCount;
if(ReadCount ==1)
sem_wait(WriteMutex); //当有读者线程时应避免同时有写者线程进行写操作。
sem_post(x);
sem_post(ReadMutex);
read() //进行读操作
sem_wait( x) //保证原子操作
--ReadCount;
if(ReadCount==0)
sem_wait(WriteMutex);
sem_wait(x);
}
}
void writer()
{
while(1)
{
sem_wait(x) // 保证原子性，防止多个线程对WriteMutex进行操作。
&#43;&#43;WriteCount;
if(WriteCount == 1)
sem_wait(ReadMutex); //当有写者线程时，应该禁止读操作，使写者线程的优先于读者线程。
sem_post(x);
sem_wait(WriteMutex); //这里是防止多个写者线程同时进行写操作。
write() //对临界区资源进行写操作
sem_post(WriteMutex);
sem_wait(x); //同上
--WriteCount;
if(WriteCount == 0)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3b74606a24952a4b040b6c250ec05aa6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-19T13:55:00+08:00" />
<meta property="article:modified_time" content="2016-12-19T13:55:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统--信号量经典同步问题之写者优先问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>写者优先比读者优先要复杂一些，写者优先有以下两个内涵：</p> 
<p>1. 当写者线程获得临界区的访问权限时， 其他写者线程不要需要要优先于读者线程获得临界区的访问权限，只有当所有的写者线程都执行后，读者线程才能获得权限。</p> 
<p>2. 当读者线程获得临界区的访问权限时，写者线程可以实现抢占，即写者线程优先于其他等待的读者线程，只有当所有的写者线程都执行后，读者线程才能获得权限。</p> 
<p><br> </p> 
<p>有的参考书中对写者优先的定义仅限于上述第一条。有的定义需满足上述两条。下面分别用伪代码实现这两种情况。</p> 
<p><br> </p> 
<p>int WriteCount=0, ReadCount=0// 共享变量</p> 
<p>semaphore WriteMutex=1, ReadMutex=1, x=1,y=1;</p> 
<p>void reader()<br> {<!-- --></p> 
<p><span style="white-space:pre"></span>while(1)</p> 
<p><span style="white-space:pre"></span>{<!-- --></p> 
<p><span style="white-space:pre"></span>sem_wait( ReadMutex);</p> 
<p><span style="white-space:pre"></span>sem_wait(x); // 保证原子操作</p> 
<p><span style="white-space:pre"></span>++ReadCount;</p> 
<p><span style="white-space:pre"></span>if(ReadCount ==1)</p> 
<p><span style="white-space:pre"></span>sem_wait(WriteMutex); //当有读者线程时应避免同时有写者线程进行写操作。</p> 
<p><span style="white-space:pre"></span>sem_post(x);</p> 
<p><span style="white-space:pre"></span>sem_post(ReadMutex);</p> 
<p><span style="white-space:pre"></span></p> 
<p><span style="white-space:pre"></span>read() //进行读操作</p> 
<p><span style="white-space:pre"></span></p> 
<p><span style="white-space:pre"></span>sem_wait( x)  //保证原子操作</p> 
<p><span style="white-space:pre"></span>--ReadCount;</p> 
<p><span style="white-space:pre"></span>if(ReadCount==0)</p> 
<p><span style="white-space:pre"></span>sem_wait(WriteMutex);</p> 
<p><span style="white-space:pre"></span>sem_wait(x);</p> 
<p><span style="white-space:pre"></span>}<br> }</p> 
<p>void writer()<br> {<!-- --></p> 
<p><span style="white-space:pre"></span>while(1)</p> 
<p><span style="white-space:pre"></span>{<!-- --></p> 
<p><span style="white-space:pre"></span>sem_wait(x) // 保证原子性，防止多个线程对WriteMutex进行操作。</p> 
<p><span style="white-space:pre"></span>++WriteCount;</p> 
<p><span style="white-space:pre"></span>if(WriteCount == 1)</p> 
<p><span style="white-space:pre"></span>sem_wait(ReadMutex); //当有写者线程时，应该禁止读操作，使写者线程的优先于读者线程。</p> 
<p><span style="white-space:pre"></span>sem_post(x);</p> 
<p><span style="white-space:pre"></span>sem_wait(WriteMutex);  //这里是防止多个写者线程同时进行写操作。</p> 
<p><span style="white-space:pre"></span>write() //对临界区资源进行写操作</p> 
<p><span style="white-space:pre"></span>sem_post(WriteMutex);</p> 
<p><span style="white-space:pre"></span>sem_wait(x); //同上</p> 
<p><span style="white-space:pre"></span>--WriteCount;</p> 
<p><span style="white-space:pre"></span>if(WriteCount == 0)</p> 
<p><span style="white-space:pre"></span>sem_post(ReadMutex); //当所有写者线程都执行完毕后，应轮到读者线程访问临界区。</p> 
<p><span style="white-space:pre"></span>sem_wait(x);</p> 
<p><span style="white-space:pre"></span>}<br> }</p> 
<p><br> </p> 
<p>以上代码可以实现上述第一条，即当写者线程获得临界区资源时，其他写者线程可以优先于读者线程，直到所有写者线程都执行完毕才轮到读者线程。然而并不满足第二条，即当读者线程拥有临界区资源时，写者线程无法抢占。为了同时满足第二条，只需改动reader()部分。</p> 
<p></p> 
<p>void reader()<br> {<!-- --></p> 
<p><span style="white-space:pre"></span>while(1)</p> 
<p><span style="white-space:pre"></span>{<!-- --></p> 
<p><span style="white-space:pre"></span><span style="color:#ff0000">sem_wait(y) // 信号量y 使得只有一个读者线程可以进入，其他线程都堵塞在此处。而写者线程可以抢占，从而实现写者线程有高优先级。</span></p> 
<p><span style="white-space:pre"></span>sem_wait( ReadMutex);</p> 
<p><span style="white-space:pre"></span>sem_wait(x); // 保证原子操作</p> 
<p><span style="white-space:pre"></span>++ReadCount;</p> 
<p><span style="white-space:pre"></span>if(ReadCount ==1)</p> 
<p><span style="white-space:pre"></span>sem_wait(WriteMutex); //当有读者线程时应避免同时有写者线程进行写操作。</p> 
<p><span style="white-space:pre"></span>sem_post(x);</p> 
<p><span style="white-space:pre"></span>sem_post(ReadMutex);</p> 
<p><span style="white-space:pre"></span><span style="color:#ff0000">sem_post(y)</span></p> 
<p><span style="white-space:pre"></span>read() //进行读操作</p> 
<p><span style="white-space:pre"></span></p> 
<p><span style="white-space:pre"></span>sem_wait( x)  //保证原子操作</p> 
<p><span style="white-space:pre"></span>--ReadCount;</p> 
<p><span style="white-space:pre"></span>if(ReadCount==0)</p> 
<p><span style="white-space:pre"></span>sem_wait(WriteMutex);</p> 
<p><span style="white-space:pre"></span>sem_wait(x);</p> 
<p><span style="white-space:pre"></span>}<br> }</p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e12d143518878bda925781513af84e4b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 根据图片高度动态设置ViewPager高度</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0426b3175b4906e2fb7117f663b44874/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">The setup files are corrupted. Please obtain a new copy of the program. 报错解决。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>