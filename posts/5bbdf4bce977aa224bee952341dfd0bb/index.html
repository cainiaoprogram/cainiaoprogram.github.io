<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux多线程之线程同步（条件变量） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux多线程之线程同步（条件变量）" />
<meta property="og:description" content="什么是线程同步？
案例原型：A先扫5次地，A扫完地B再拖地，从而完成线程同步。
#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; pthread_t thread[2]; int number = 0;//共享资源 pthread_mutex_t mut; void studentA() { int i; for(i=0;i&lt;5;i&#43;&#43;) { pthread_mutex_lock(&amp;mut);//上锁 //扫1次地 number&#43;&#43;; if(number &gt;= 5) printf(&#34;student A has finish his work!\n&#34;); pthread_mutex_unlock(&amp;mut);//解锁 //休息1s钟 sleep(1); } //退出 pthread_exit(NULL); } void studentB() { while(1) {	pthread_mutex_lock(&amp;mut); if(number &gt;= 5)//判断A同学是否已经扫完5次地 { //拖地 number = 0; pthread_mutex_unlock(&amp;mut); printf(&#34;student B has finish his work!\n&#34;); break; } else { pthread_mutex_unlock(&amp;mut); //睡眠2s钟 sleep(2); }	} //退出 pthread_exit(NULL); } int main() { //初始化互斥锁 pthread_mutex_init(&amp;mut,NULL); //创建A同学线程 pthread_create(&amp;thread[0], NULL, studentA, NULL); //创建B同学线程 pthread_create(&amp;thread[1], NULL, studentB, NULL); //等待A同学线程结束 pthread_join(thread[0], NULL); //等待B同学线程结束 pthread_join(thread[1], NULL); } 运行结果：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5bbdf4bce977aa224bee952341dfd0bb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-28T10:45:10+08:00" />
<meta property="article:modified_time" content="2023-09-28T10:45:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux多线程之线程同步（条件变量）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>什么是线程同步？</p> 
<p><img src="https://images2.imgbox.com/10/fe/ODELPQ3G_o.png" alt="在这里插入图片描述"><br> 案例原型：A先扫5次地，A扫完地B再拖地，从而完成线程同步。</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;


pthread_t thread[2];

int number = 0;//共享资源

pthread_mutex_t mut;

void studentA()
{
	int i;
	for(i=0;i&lt;5;i++)
	{
		pthread_mutex_lock(&amp;mut);//上锁
		
		//扫1次地
		number++;
		
		if(number &gt;= 5)
			printf("student A has finish his work!\n");
		
		pthread_mutex_unlock(&amp;mut);//解锁
		
		//休息1s钟
		sleep(1);

	}
	
	//退出
	pthread_exit(NULL);

}

void studentB()
{
	while(1)
	{		
		pthread_mutex_lock(&amp;mut);
		
		if(number &gt;= 5)//判断A同学是否已经扫完5次地
		{
			//拖地
			number = 0;
			
			pthread_mutex_unlock(&amp;mut);
			
			printf("student B has finish his work!\n");
			
			break;
		}
		else
		{
			pthread_mutex_unlock(&amp;mut);
						
			//睡眠2s钟
			sleep(2);
		}					
		
	}
	
	//退出
	pthread_exit(NULL);
	
}

int main()
{
	//初始化互斥锁
	pthread_mutex_init(&amp;mut,NULL);
	
	//创建A同学线程
	pthread_create(&amp;thread[0], NULL, studentA,  NULL);
	
	//创建B同学线程
	pthread_create(&amp;thread[1], NULL, studentB,  NULL);

	
	//等待A同学线程结束
	pthread_join(thread[0], NULL);

	
	//等待B同学线程结束
	pthread_join(thread[1], NULL);

	
}
</code></pre> 
<p>运行结果：</p> 
<p><img src="https://images2.imgbox.com/2b/37/FnSxnxpe_o.png" alt="在这里插入图片描述"><br> 结果如我们所愿，A先完成工作，B再完成工，实现了线程之间的同步。但是有没有缺点那？明显有<u>缺点</u>，B同学需要每隔2s检查一次，判断number是否&gt;5，这个过程是非常浪费cpu、低效的！！！那么有没有更加高效的办法哪？</p> 
<p><strong>条件变量：</strong></p> 
<p><img src="https://images2.imgbox.com/33/1c/sA3sUmog_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/69/42/fnxPGtDD_o.png" alt="在这里插入图片描述"></p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;


pthread_t thread[2];

int number = 0;//共享资源

pthread_mutex_t mut;

pthread_cond_t cond_ready=PTHREAD_COND_INITIALIZER; //条件变量---初始化

void studentA()
{
	int i;
	for(i=0;i&lt;5;i++)
	{
		pthread_mutex_lock(&amp;mut);//上锁
		
		//扫1次地
		number++;
		
		if(number &gt;= 5)
		{
			printf("student A has finish his work!\n");
			
			//条件变量---通知B同学
			pthread_cond_signal(&amp;cond_ready);
		}
		
		pthread_mutex_unlock(&amp;mut);//解锁
		
		//休息1s钟
		sleep(1);

	}
	
	//退出
	pthread_exit(NULL);

}

void studentB()
{	
	pthread_mutex_lock(&amp;mut);//加锁
	
	if(number &lt; 5)
	{		
		//条件变量---等待
		pthread_cond_wait(&amp;cond_ready, &amp;mut);//条件变量一般和互斥锁mutex一起使用
										  //条件不满足时，会把mutex先unlock；
										  //等条件满足时，再重新lock
	}
	
	//拖地
	number=0;
	
	pthread_mutex_unlock(&amp;mut);//解锁
	printf("student B has finish his work\n");
				
	
	//退出
	pthread_exit(NULL);
	
}

int main()
{
	//初始化互斥锁
	pthread_mutex_init(&amp;mut,NULL);
	
	//创建A同学线程
	pthread_create(&amp;thread[0], NULL, studentA,  NULL);
	
	//创建B同学线程
	pthread_create(&amp;thread[1], NULL, studentB,  NULL);

	
	//等待A同学线程结束
	pthread_join(thread[0], NULL);

	
	//等待B同学线程结束
	pthread_join(thread[1], NULL);

	
}
</code></pre> 
<p>运行结果：</p> 
<p><img src="https://images2.imgbox.com/1e/2c/2CbGguP1_o.png" alt="在这里插入图片描述"></p> 
<p><strong>疑问？</strong></p> 
<p><strong>为什么pthread_cond_wait(&amp;cond_ready, &amp;mut);函数第二个参数需要互斥锁？</strong></p> 
<p>https://baike.baidu.com/item/pthread_cond_wait/3011997?fr=aladdin</p> 
<p>https://www.cnblogs.com/secondtonone1/p/5580203.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f26da68d23f0bddc930db641f04c3592/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【mysql 窗口函数row_number】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dfec5521a7c58a1a82637971efa2ebe6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">好的文章推荐</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>