<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#学习相关系列之数据类型类的三大特性（二） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#学习相关系列之数据类型类的三大特性（二）" />
<meta property="og:description" content="一、封装 封装：将类的某些信息隐藏在类的内部（用private修饰），不允许外部程序直接访问，需要访问也是访问该类为其提供的公共属性。
装属性的作用：防止类中的数据被恶意修改。
封装属性的好处：1.可以隐藏类的实现细节
2.外部只能通过访问规定的属性来访问数据，保护数据
3.方便加入控制语句，即对数据做约束
代码例子：
public class Person { // 私有字段 private string name; private int age; // 公共构造函数 public Person(string name, int age) { this.name = name; this.age = age; } // 特性可以保护数据安全 public int Age { get { return age; } set { age =value; } } // 公共方法，用于获取姓名 public string GetName() { return name; } // 公共方法，用于设置姓名 public void SetName(string newName) { name = newName; } // 公共方法，用于获取年龄 public int GetAge() { return age; } // 公共方法，用于设置年龄 public void SetAge(int newAge) { if (newAge &gt; 0 &amp;&amp; newAge &lt; 150) // 简单的年龄验证逻辑 { age = newAge; } else { throw new ArgumentOutOfRangeException(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/915a70f4c02298b46b4b90fc05628ae6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-15T22:28:18+08:00" />
<meta property="article:modified_time" content="2023-12-15T22:28:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#学习相关系列之数据类型类的三大特性（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、封装</h2> 
<blockquote> 
 <p>        封装：将类的某些信息隐藏在类的内部（用<a href="https://so.csdn.net/so/search?q=private&amp;spm=1001.2101.3001.7020" title="private">private</a>修饰），不允许外部程序直接访问，需要访问也是访问该类为其提供的公共属性。</p> 
</blockquote> 
<blockquote> 
 <p><strong>装属性的作用：</strong>防止类中的数据被恶意修改。</p> 
 <p><strong>封装属性的好处：</strong>1.可以隐藏类的实现细节</p> 
 <p>                             2.外部只能通过访问规定的属性来访问数据，保护数据</p> 
 <p>                             3.方便加入控制语句，即对数据做约束<br>  </p> 
 <p> </p> 
</blockquote> 
<p>代码例子：</p> 
<pre><code class="language-cs">public class Person  
{  
    // 私有字段  
    private string name;  
    private int age;  
  
    // 公共构造函数  
    public Person(string name, int age)  
    {  
        this.name = name;  
        this.age = age;  
    }  
    // 特性可以保护数据安全
    public int Age
    {
        get { return age; }
        set { age =value; }
    }  
    // 公共方法，用于获取姓名  
    public string GetName()  
    {  
        return name;  
    }  
  
    // 公共方法，用于设置姓名  
    public void SetName(string newName)  
    {  
        name = newName;  
    }  
  
    // 公共方法，用于获取年龄  
    public int GetAge()  
    {  
        return age;  
    }  
  
    // 公共方法，用于设置年龄  
    public void SetAge(int newAge)  
    {  
        if (newAge &gt; 0 &amp;&amp; newAge &lt; 150) // 简单的年龄验证逻辑  
        {  
            age = newAge;  
        }  
        else  
        {  
            throw new ArgumentOutOfRangeException("Invalid age.");  
        }  
    }  
}</code></pre> 
<p>        在上面的例子中，<code>Person</code>类封装了两个私有字段<code>name</code>和<code>age</code>。通过公共的构造函数和设置器方法（如<code>SetName</code>和<code>SetAge</code>），我们可以控制对内部状态的访问和修改。这样，外部代码只能通过这些公共方法来访问和修改<code>Person</code>对象的内部状态，而不能直接访问或修改私有字段。这提高了代码的可维护性和健壮性，因为我们可以控制对内部状态的访问和修改，并在必要时添加额外的验证逻辑。 </p> 
<h2> 二、继承</h2> 
<blockquote> 
 <ol><li><strong>代码重用</strong>：继承允许我们定义一个类，然后创建其他类从已有的类中派生出来。这样，我们可以重用基类中的方法和属性，减少代码的重复编写。</li><li><strong>扩展性</strong>：继承使得我们能够定义一个基类，然后根据需要创建派生类来扩展或修改基类的功能。这使得代码更加灵活，可以根据需求进行扩展和定制。</li><li><strong>层次结构</strong>：通过继承，我们可以建立类之间的层次结构，使得代码更加有组织性和层次性。这有助于理解代码的结构和功能，以及更好地进行代码维护和调试。</li><li><strong>多态性</strong>：继承是实现多态性的基础。通过继承，我们可以创建具有相同接口但具有不同实现的方法和属性，从而实现多态性。这使得代码更加灵活，可以根据实际需求选择不同的实现方式。</li></ol> 
</blockquote> 
<pre><code class="language-cs">// 基类  
public class Animal  
{  
    public string Name { get; set; }  
  
    public void Eat()  
    {  
        Console.WriteLine($"{Name} is eating.");  
    }  
}  
  
// 派生类  
public class Dog : Animal  
{  
    public void Bark()  
    {  
        Console.WriteLine($"{Name} is barking.");  
    }  
}  
  
// 使用继承  
public class Program  
{  
    public static void Main(string[] args)  
    {  
        Dog dog = new Dog();  
        dog.Name = "Tommy";  
        dog.Eat(); // 继承了Animal类的Eat方法  
        dog.Bark(); // Dog类自己的Bark方法  
    }  
}</code></pre> 
<blockquote> 
 <p><strong>继承的特征：</strong></p> 
 <p>1.子类继承了父类的非私有的属性与方法，构造方法除外</p> 
 <p>2.子类在创建构造方法时需要调用父类构造方法；</p> 
 <p>                格式：派生类名（总参数列表（父子类的参数））：base（父类参数）{}</p> 
 <p>3. 在创建子类对象时，系统会默认的先调用父类的构造方法，在调用子类的构造方法</p> 
 <p>4. 子类想使用父类的属性和方法时，需要用到base关键字（base.）   </p> 
 <p><strong>重写与重载的区别：</strong></p> 
 <p>1.作用范围不同，重写发生在具有父子关系的两个类中的同名方法，而重载是在同一个类中同名方法。</p> 
 <p>2.不同点不同，重写的两个方法的返回值与参数相同，方法的声明不同（也就是{ }中的内容不同），重载的方法只要参数列表不同</p> 
</blockquote> 
<h2> 三、多态</h2> 
<blockquote> 
 <p><strong>多态：</strong>是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p> 
</blockquote> 
<p>代码例子：</p> 
<pre><code class="language-cs">using System;  
  
// 基类  
class Animal  
{  
    public void Speak()  
    {  
        Console.WriteLine("Animal speaks.");  
    }  
}  
  
// 派生类1  
class Dog : Animal  
{  
    public override void Speak()  
    {  
        Console.WriteLine("Dog barks.");  
    }  
}  
  
// 派生类2  
class Cat : Animal  
{  
    public override void Speak()  
    {  
        Console.WriteLine("Cat meows.");  
    }  
}  
  
class Program  
{  
    static void Main()  
    {  
        // 创建一个Animal引用指向Dog对象  
        Animal myDog = new Dog();  
        // 调用基类Animal的Speak方法，实际上调用的是Dog的Speak方法，因为myDog是Animal类型，但实际上指向的是Dog对象。这就是多态性。  
        myDog.Speak(); // 输出 "Dog barks."  
  
        // 创建一个Animal引用指向Cat对象  
        Animal myCat = new Cat();  
        // 同样，调用基类Animal的Speak方法，实际上调用的是Cat的Speak方法。  
        myCat.Speak(); // 输出 "Cat meows."  
    }  
}</code></pre> 
<p>         在这个例子中，我们有一个基类<code>Animal</code>和两个派生类<code>Dog</code>和<code>Cat</code>。每个派生类都重写了基类的<code>Speak</code>方法。在主程序中，我们创建了一个<code>Animal</code>类型的引用，但实际上它指向了一个<code>Dog</code>对象或一个<code>Cat</code>对象。当我们调用这个引用的<code>Speak</code>方法时，会调用实际对象的<code>Speak</code>方法，这就是多态性的体现。</p> 
<blockquote> 
 <p>其实多态的作用就是把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。<br> 以上程序也体现了开放封闭原则，如果以后有人需要扩展这个程序，还想再添加一个牛（cow），很容易，只需要添加一个cow类，继承Animal，重写speak()方法，添加给父类对象就可以了。至此，该程序的扩展性得到了提升，而又不需要查看源代码是如何实现的就可以扩展新功能。这就是多态带来的好处。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ac2c9b88bdba8e9042fb1e7d21a5011/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VS Code使用教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d72426e752db1a7c2ac68cd4bfde215/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">「X」Embedding in NLP｜神经网络和语言模型 Embedding 向量入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>