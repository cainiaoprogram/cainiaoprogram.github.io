<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java之NIO简介 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java之NIO简介" />
<meta property="og:description" content="一、NIO基本简介 NIO (New lO)也有人称之为java non-blocking lO是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java lO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。NIO可以理解为非阻塞IO,传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，而NIO中可以配置socket为非阻塞模式。
NIO相关类都被放在java.nio包及子包下，并且对原java.io包中的很多类进行改写。NIO有三大核心部分:Channel(通道)，Buffer(缓冲区), Selector(选择器)Java NlO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。通俗理解:NIO是可以做到用一个线程来处理多个操作的。假设有1000个请求过来,根据实际情况，可以分配20或者80个线程来处理。不像之前的阻塞IO那样，非得分配1000个。 二、NIO 与 BIO的比较 BIO以流的方式处理数据,而NIO以块的方式处理数据,块I/O的效率比流IO高很多BIO是阻塞的，NIO则是非阻塞的BlO基于字节流和字符流进行操作，而NIO基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如:连接请求，数据到达等)，因此使用单个线程就可以监听多个客户端通道 NIO可以先将数据写入到缓冲区，然后再有缓冲区写入通道，因此可以做到同步非阻塞。
BIO则是面向的流，读写数据都是单向的。因此是同步阻塞。
三、NIO 三大核心原理示意图 NIO有三大核心部分: Channel(通道)，Buffer(缓冲区)，Selector(选择器)
Buffer(缓冲区)
缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。相比较直接对数组的操作，Buffer APl更加容易操作和管理。
Channel(通道)
Java NIO的通道类似流，但又有些不同:既可以从通道中读取数据，又可以写数据到通道。但流的(input或output)读写通常是单向的。通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓冲区，也支持异步地读写。
Selector(选择器)
Selector是一个ava NIO组件，可以能够检查一个或多个NIO通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率
每个channel都会对应一个 Buffer一个线程对应Selector ,一个Selector对应多个channel(连接)程序切换到哪个channel是由事件决定的Selector 会根据不同的事件，在各个通道上切换Buffer 就是一个内存块，底层是一个数组数据的读取写入是通过 Buffer完成的，BlO中要么是输入流，或者是输出流,不能双向，但是NIO的Buffer是可以读也可以写。Java NIO系统的核心在于:通道(Channel)和缓冲区(Buffer)。通道表示打开到lO设备(例如:文件、套接字)的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，Channel负责传输，Buffer负责存取数据 四、NIO核心一:缓存区 (Buffer) 缓冲区（Buffer）一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区 都是 Buffer 抽象类的子类.。Java NIO 中的 Buffer 主要用于与 NIO 通道进行 交互，数据是从通道读入缓冲区，从缓冲区写入通道中的
Buffer 类及其子类：
Buffer就像一个数组，可以保存多个相同类型的数据。根据 数据类型不同 ，有以下 Buffer 常用子类： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 上述 Buffer 类他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2a18db62b9581892c5830f3c288d2988/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-14T22:52:39+08:00" />
<meta property="article:modified_time" content="2022-03-14T22:52:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java之NIO简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、NIO基本简介</h2> 
<blockquote> 
 <p><strong>NIO</strong> (New lO)也有人称之为java non-blocking lO是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java lO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，<strong>NIO支持面向缓冲区的、基于通道的IO操作</strong>。NIO将以更加高效的方式进行文件的读写操作。<strong>NIO可以理解为非阻塞IO</strong>,传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，而NIO中可以配置socket为非阻塞模式。</p> 
 <ul><li>NIO相关类都被放在java.nio包及子包下，并且对原java.io包中的很多类进行改写。</li><li>NIO有三大核心部分:Channel(通道)，Buffer(缓冲区), Selector(选择器)</li><li>Java NlO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</li><li>通俗理解:NIO是可以做到用一个线程来处理多个操作的。假设有1000个请求过来,根据实际情况，可以分配20或者80个线程来处理。不像之前的阻塞IO那样，非得分配1000个。</li></ul> 
</blockquote> 
<h2>二、NIO 与 BIO的比较</h2> 
<blockquote> 
 <ul><li>BIO以流的方式处理数据,而NIO以块的方式处理数据,块I/O的效率比流IO高很多</li><li>BIO是阻塞的，NIO则是非阻塞的</li><li>BlO基于字节流和字符流进行操作，而NIO基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如:连接请求，数据到达等)，因此使用单个线程就可以监听多个客户端通道</li></ul> 
 <p><img alt="" height="199" src="https://images2.imgbox.com/78/98/e2XNVz5S_o.png" width="1199"></p> 
 <p><strong>NIO</strong>可以先将数据写入到缓冲区，然后再有缓冲区写入通道，因此可以做到<strong>同步非阻塞</strong>。</p> 
 <p><strong>BIO</strong>则是面向的流，读写数据都是单向的。因此是同步阻塞。</p> 
</blockquote> 
<h2> 三、NIO 三大核心原理示意图</h2> 
<blockquote> 
 <p>NIO有三大核心部分: <strong>Channel(通道)，Buffer(缓冲区)，Selector(选择器)</strong></p> 
 <p><strong>Buffer(缓冲区)</strong></p> 
 <p>        缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。相比较直接对数组的操作，Buffer APl更加容易操作和管理。</p> 
 <p><strong>Channel(通道)</strong></p> 
 <p>        Java NIO的通道类似流，但又有些不同:既可以从通道中读取数据，又可以写数据到通道。但流的(input或output)读写通常是单向的。通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓冲区，也支持异步地读写。</p> 
 <p><strong>Selector(选择器)</strong></p> 
 <p>        Selector是一个ava NIO组件，可以能够检查一个或多个NIO通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率</p> 
 <p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/48/97/Er5vNokA_o.png"></p> 
 <ul><li>每个channel都会对应一个 Buffer</li><li>一个线程对应Selector ,一个Selector对应多个channel(连接)程序</li><li>切换到哪个channel是由事件决定的</li><li>Selector 会根据不同的事件，在各个通道上切换</li><li>Buffer 就是一个内存块，底层是一个数组</li><li>数据的读取写入是通过 Buffer完成的，BlO中要么是输入流，或者是输出流,不能双向，但是NIO的Buffer是可以读也可以写。</li><li>Java NIO系统的核心在于:通道(Channel)和缓冲区(Buffer)。通道表示打开到lO设备(例如:文件、套接字)的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，Channel负责传输，Buffer负责存取数据</li></ul> 
</blockquote> 
<hr> 
<h2>四、NIO核心一:缓存区 (Buffer)</h2> 
<blockquote> 
 <p><strong>缓冲区（Buffer）</strong>一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区 都是 Buffer 抽象类的子类.。Java NIO 中的 <strong>Buffer 主要用于与 NIO 通道进行 交互</strong>，<strong>数据是从通道读入缓冲区，从缓冲区写入通道</strong>中的<br><img alt="" src="https://images2.imgbox.com/b4/d7/5xFn4qq9_o.png"></p> 
 <p><strong>Buffer 类及其子类：</strong></p> 
 <p>Buffer就像一个数组，可以保存多个相同类型的数据。根据 数据类型不同 ，有以下 Buffer 常用子类：  </p> 
 <ul><li>ByteBuffer </li><li>CharBuffer </li><li>ShortBuffer </li><li>IntBuffer </li><li>LongBuffer </li><li>FloatBuffer </li><li>DoubleBuffer </li></ul> 
 <p>上述 Buffer 类他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象：</p> 
 <p><strong>static XxxBuffer allocate(int capacity) : </strong>创建一个容量为capacity 的 XxxBuffer 对象<br>  </p> 
 <p>缓冲区的基本属性 Buffer 中的重要概念：</p> 
 <p><strong>容量 (capacity) ：</strong>作为一个内存块，Buffer具有一定的固定大小， 也称为"容量"，缓冲区容量不能为负，并且创建后不能更改。</p> 
 <p><strong>限制 (limit)：</strong>表示缓冲区中可以操作数据的大小 （limit 后数据不能进行读写）。缓冲区的限制不能 为负，并且不能大于其容量。 写入模式，限制等于 buffer的容量。读取模式下，limit等于写入的数据量。</p> 
 <p><strong>位置 (position)：</strong>下一个要读取或写入的数据的索引。 缓冲区的位置不能为 负，并且不能大于其限制</p> 
 <p><strong>标记 (mark)与重置 (reset)：</strong>标记是一个索引， 通过 Buffer 中的 mark() 方法 指定 Buffer 中一个 特定的 position，之后可以通过调用 reset() 方法恢 复到这 个 position.</p> 
 <p>标记、位置、限制、容量遵守以下不变式：<strong> 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</strong></p> 
 <p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/29/f0/6P8QqU5D_o.png"></p> 
 <p><span style="color:#fe2c24;"><strong> Buffer常见方法：</strong></span></p> 
 <ol><li><strong>Buffer clear() ：</strong>清空缓冲区并返回对缓冲区的引用</li><li><strong>Buffer flip() ：</strong>为 将缓冲区的界限设置为当前位置， 并将当前位置重置为 0</li><li><strong>int capacity() ：</strong>返回 Buffer 的 capacity 大小</li><li><strong>boolean hasRemaining()：</strong> 判断缓冲区中是否还有元素</li><li><strong>int limit() ：</strong>返回 Buffer 的界限(limit) 的位置</li><li><strong>Buffer limit(int n) </strong>将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象</li><li><strong>Buffer mark()：</strong> 对缓冲区设置标记</li><li><strong>int position() ：</strong>返回缓冲区的当前位置 position</li><li><strong>Buffer position(int n) ：</strong>将设置缓冲区的当前位置为 n， 并返回修改后的 Buffer 对象</li><li><strong>int remaining() ：</strong>返回 position 和 limit 之间的元素个数</li><li><strong>Buffer reset() ：</strong>将位置 position 转到以前设置的mark 所在的位置</li><li><strong>Buffer rewind() ：</strong>将位置设为为 0， 取消设置的 mark</li></ol> 
 <p><span style="color:#fe2c24;"><strong>缓冲区的数据操作 Buffer 所有子类提供了两个用于数据操作的方法：</strong></span></p> 
 <ol><li><strong>get() ：</strong>读取单个字节</li><li><strong>get(byte[] dst)：</strong>批量读取多个字节到 dst 中</li><li><strong>get(int index)：</strong>读取指定索引位置的字节(不会移动 position)放到入数据到Buffer中</li><li><strong>put(byte b)：</strong>将给定单个字节写入缓冲区的当前位置</li><li><strong>put(byte[] src)：</strong>将 src 中的字节写入缓冲区的当前位置</li><li><strong>put(int index, byte b)：</strong>将指定字节写入缓冲区的索引 位置(不会移动 position)</li></ol> 
 <p><span style="color:#fe2c24;"><strong>使用Buffer读写数据一般遵循以下四个步骤：</strong></span></p> 
 <ol><li>写入数据到Buffer</li><li>调用flip()方法，转换为读取模式</li><li>从Buffer中读取数据</li><li>调用buffer.clear()方法或者buffer.compact()方 法清除缓冲区</li></ol> 
 <pre><code class="language-java">package com.kgf.kgfjavalearning2021.io.nio;

import org.junit.Test;

import java.nio.ByteBuffer;

/***
 * Buffer测试类
 */
public class TestBuffer {

   @Test
   public void test1(){
      //1. 分配一个指定大小的缓冲区
      ByteBuffer buf = ByteBuffer.allocate(1024);
      System.out.println("-----------------allocate()----------------");
      System.out.println(buf.position());// 0: 表示当前的位置为0
      System.out.println(buf.limit());// 1024: 表示界限为1024，前1024个位置是允许我们读写的
      System.out.println(buf.capacity());//1024：表示容量大小为1024

      //2. 利用 put() 存入数据到缓冲区中
      System.out.println("-----------------put()----------------");
      String str = "itheima";
      buf.put(str.getBytes());
      System.out.println(buf.position());// 7表示下一个可以写入的位置是7,因为我们写入的字节是7个,从0开始已经写了7个，位置为8的position为7
      System.out.println(buf.limit());// 1024：表示界限为1024，前1024个位置是允许我们读写的
      System.out.println(buf.capacity());//1024：表示容量大小为1024

      //3. 切换读取数据模式
      System.out.println("-----------------flip()----------------");
      buf.flip();
      System.out.println(buf.position());// 0: 读取的起始位置为0
      System.out.println(buf.limit());// 7: 表示界限为7，前7个位置有数据可以读取
      System.out.println(buf.capacity());// 1024:表示容量大小为1024

      //4. 利用 get() 读取缓冲区中的数据
      System.out.println("-----------------get()----------------");
      byte[] dst = new byte[buf.limit()];//创建一个界限为limit大小的字节数组
      buf.get(dst);//批量将limit大小的字节写入到dst字节数组中
      System.out.println(new String(dst, 0, dst.length));//结果为itheima

      System.out.println(buf.position());//7: 读取的位置变为7,因为前面的7个字节数据已经全部读取出去,下一个可读取的位置为7，从0开始的
      System.out.println(buf.limit());//7: 可读取的界限大小为7
      System.out.println(buf.capacity());// 1024: 表示容量大小为1024

      //5. rewind() : 可重复读
      System.out.println("-----------------rewind()----------------");
      buf.rewind();// 将位置设为为 0,从头开始读取
      System.out.println(buf.position());// 0
      System.out.println(buf.limit());// 7
      System.out.println(buf.capacity());// 1024

      //6. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态
      System.out.println("-----------------clear()----------------");
      buf.clear();
      System.out.println(buf.position());// 0
      System.out.println(buf.limit());// 1024
      System.out.println(buf.capacity());// 1024
      System.out.println((char)buf.get());//i

   }

   @Test
   public void test2(){
      String str = "itheima";

      ByteBuffer buf = ByteBuffer.allocate(1024);

      buf.put(str.getBytes());// 将str写入到buf缓冲区中

      buf.flip();//转换为读模式

      byte[] dst = new byte[buf.limit()];//定义一个字节数组
      buf.get(dst, 0, 2);//将前2个字节批量写入到dst字节数组中
      System.out.println(new String(dst, 0, 2));//打印结果为it
      System.out.println(buf.position());//当前下一个读取的位置为2

      //mark() : 标记
      buf.mark();

      buf.get(dst, 2, 2);//从第3个位置开始将2个字节批量写入到dst字节数组中
      System.out.println(new String(dst, 2, 2));//打印结果为he
      System.out.println(buf.position());// 当前下一个读取的位置为4

      //reset() : 恢复到 mark 的位置
      buf.reset();
      System.out.println(buf.position());// 2

      //判断缓冲区中是否还有剩余数据
      if(buf.hasRemaining()){
         //获取缓冲区中可以操作的数量
         System.out.println(buf.remaining());// 5: 返回 position 和 limit 之间的元素个数
      }
   }

   @Test
   public void test3(){
      //分配直接缓冲区
      ByteBuffer buf = ByteBuffer.allocateDirect(1024);
      System.out.println(buf.isDirect());
   }

}
</code></pre> 
 <p>直接与非直接缓冲区：</p> 
 <p>byte byffer可以是两种类型，一种是基于<strong>直接内存（也就是非堆内存）</strong>；另一种是<strong>非直接内存（也就是堆内存）</strong>。对于<strong>直接内存来说，JVM将会在IO操作上具有更高的性能，因为它<br> 直接作用于本地系统的IO操作</strong>。而<strong>非直接内存，也就是堆内存中的数据，如果要作IO操作，会先从本进程内存复制到直接内存</strong>，再利用本地IO处理。</p> 
 <p>从数据流的角度，非直接内存是下面这样的作用链：</p> 
 <p><strong>本地IO--&gt;直接内存--&gt;非直接内存--&gt;直接内存--&gt;本地IO</strong></p> 
 <p>而直接内存是：</p> 
 <p><strong>本地IO--&gt;直接内存--&gt;本地IO</strong></p> 
 <p>很明显，在做IO处理时，<strong>比如网络发送大量数据时，直接内存会具有更高的效率</strong>。直<strong>接内存使用allocateDirect创建，但是它比申请普通的堆内存需要耗费更高的性能</strong>。不过，<strong>这部分的数据是在JVM之外的，因此它不会占用应用的内存</strong>。所以呢，<strong>当你有很大的数据要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存</strong>。只是一般来说，如果不是能带来很明显的性能提升，还是推荐直接使用堆内存。字<strong>节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect()  方法来</strong>确定。</p> 
 <p><strong>使用场景</strong></p> 
 <ol><li> 有很大的数据需要存储，它的生命周期又很长</li><li> 适合频繁的IO操作，比如网络并发场景</li></ol> 
</blockquote> 
<hr> 
<h2>五、NIO核心二：通道(Channel)</h2> 
<blockquote> 
 <h4> 1、通道Channe概述</h4> 
 <p>        通道（Channel）：由 java.nio.channels 包定义 的。Channel 表示 IO 源与目标打开的连接。 Channel 类似于传统的“流”。只不过 Channel <strong>本身不能直接访问数据</strong>，Channel 只能与 Buffer 进行交互。</p> 
 <h4>2、NIO 的通道类似于流，但有些<strong>区别</strong>如下：</h4> 
 <ul><li> <p>通道可以同时进行读写，而流只能读或者只能写</p> </li><li> <p>通道可以实现异步读写数据</p> </li><li> <p>通道可以从缓冲读数据，也可以写数据到缓冲:</p> </li></ul> 
 <h4>3、BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。</h4> 
 <h4>4、Channel 在 NIO 中是一个接口</h4> 
 <pre><code class="language-java">public interface Channel extends Closeable{}</code></pre> 
 <h4>5、常用的Channel实现类</h4> 
 <ul><li>FileChannel：用于读取、写入、映射和操作文件的通道。</li><li>DatagramChannel：通过 UDP 读写网络中的数据通道。</li><li>SocketChannel：通过 TCP 读写网络中的数据。</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</li></ul> 
 <h4>6、FileChannel 类</h4> 
 <p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下</p> 
 <ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li><li>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道</li></ul> 
 <h4>7、FileChannel常用方法</h4> 
 <ul><li><strong>int read(ByteBuffer dst) ：</strong>从Channel 到 中读取数据到  ByteBuffer</li><li><strong>long  read(ByteBuffer[] dsts) ：</strong> 将Channel中的数据“分散”到  ByteBuffer[]</li><li><strong>int  write(ByteBuffer src) ：</strong>将  ByteBuffer中的数据写入到  Channel</li><li><strong>long write(ByteBuffer[] srcs) ：</strong>将  ByteBuffer[] 到 中的数据“聚集”到  Channel</li><li><strong>long position() </strong>：返回此通道的文件位置</li><li><strong>FileChannel position(long p) ：</strong>设置此通道的文件位置</li><li><strong>long size() </strong>：返回此通道的文件的当前大小</li><li><strong>FileChannel truncate(long s) ：</strong>将此通道的文件截取为给定大小</li><li><strong>void force(boolean metaData) ：</strong>强制将所有对此通道的文件更新写入到存储设备中</li></ul> 
 <hr> 
 <h4>8、案例1-本地文件写数据</h4> 
 <pre><code class="language-java">package com.kgf.kgfjavalearning2021.io.nio;

import org.junit.Test;

import java.io.FileOutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

/***
 * 需求：使用前面学习后的 ByteBuffer(缓冲)和 FileChannel(通道)， 将数据写入到 data.txt 中.
 */
public class ChannelTest {

    @Test
    public void write(){
        try {
            // 1、字节输出流通向目标文件
            FileOutputStream fos = new FileOutputStream("E:\\test\\data01.txt");
            // 2、得到字节输出流对应的通道Channel
            FileChannel channel = fos.getChannel();
            // 3、分配缓冲区
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            for (int i = 0; i &lt; 10; i++) {
                buffer.clear();//清空缓冲区
                buffer.put(("hello,使用Buffer和channel实现写数据到文件中"+i+"\r\n").getBytes());
                // 4、把缓冲区切换成写出模式
                buffer.flip();
                channel.write(buffer);//将缓冲区的数据写入到文件通道
            }
            channel.close();
            System.out.println("写数据到文件中！");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
 <hr> 
 <h4>9、案例2-本地文件读数据</h4> 
 <pre><code class="language-java"> /***
     * 设置两个缓冲区，一大一小，大的缓冲区为每次读取的量，小的缓冲区存放每行的数据（确保大小可存放文本中最长的那行）。读取的时候判断是不是换行符13，是的话则返回一行数据，不是的话继续读取，直到读完文件。
     * @throws Exception
     */
    @Test
    public void read() throws Exception {
        // 1、定义一个文件字节输入流与源文件接通
        FileInputStream is = new FileInputStream("E:\\test\\data01.txt");
        // 2、需要得到文件字节输入流的文件通道
        FileChannel channel = is.getChannel();
        // 3、定义一个缓冲区
        int bufferSize = 1024 * 1024;  // 每一块的大小
        ByteBuffer buffer = ByteBuffer.allocate(bufferSize);

        ByteBuffer bb = ByteBuffer.allocate(1024);

        // 4、读取数据到缓冲区
        int bytesRead = channel.read(buffer);
        while (bytesRead != -1) {
            buffer.flip();// 切换模式，写-&gt;读
            while (buffer.hasRemaining()) {//返回 position 和 limit 之间的元素个数
                    byte b = buffer.get();
                    if (b == 10 || b == 13) { // 换行或回车
                        bb.flip();
                        // 这里就是一个行
                        final String line = Charset.forName("utf-8").decode(bb).toString();
                        System.out.println(line);// 解码已经读到的一行所对应的字节
                        bb.clear();
                    } else {
                        if (bb.hasRemaining())
                            bb.put(b);
                        else { // 空间不够扩容
                            bb = reAllocate(bb);
                            bb.put(b);
                        }
                    }
            }
            buffer.clear();// 清空,position位置为0，limit=capacity
            //  继续往buffer中写
            bytesRead = channel.read(buffer);
        }
        channel.close();
    }</code></pre> 
 <hr> 
 <h4>10、案例3-使用Buffer完成文件复制</h4> 
 <pre><code class="language-java">  /**
     * 使用 FileChannel(通道) ，完成文件的拷贝。
     * @throws Exception
     */
    @Test
    public void copy() throws Exception {
        // 源文件
        File srcFile = new File("E:\\test\\Aurora-4k.jpg");
        File destFile = new File("E:\\test\\Aurora-4k-new.jpg");
        // 得到一个字节字节输入流
        FileInputStream fis = new FileInputStream(srcFile);
        // 得到一个字节输出流
        FileOutputStream fos = new FileOutputStream(destFile);
        // 得到的是文件通道
        FileChannel isChannel = fis.getChannel();
        FileChannel osChannel = fos.getChannel();
        // 分配缓冲区
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        while(isChannel.read(buffer)&gt;0){
            // 已经读取了数据 ，把缓冲区的模式切换成可读模式
            buffer.flip();
            // 把数据写出到
            osChannel.write(buffer);//将buffer缓冲区中的数据写入到osChannel中
            // 必须先清空缓冲然后再写入数据到缓冲区
            buffer.clear();
        }
        isChannel.close();
        osChannel.close();
        System.out.println("复制完成！");
    }</code></pre> 
 <h4>11、案例4-transferFrom()</h4> 
 <p>从目标通道中去复制原通道数据</p> 
 <pre><code class="language-java"> @Test
    public void test02() throws Exception {
        // 1、字节输入管道
        FileInputStream is = new FileInputStream("E:\\test\\Aurora-4k.jpg");
        FileChannel isChannel = is.getChannel();
        // 2、字节输出流管道
        FileOutputStream fos = new FileOutputStream("E:\\test\\Aurora-4knew3.jpg");
        FileChannel osChannel = fos.getChannel();
        // 3、复制
        osChannel.transferFrom(isChannel,isChannel.position(),isChannel.size());
        isChannel.close();
        osChannel.close();
    }</code></pre> 
 <hr> 
 <h4>12、案例5-transferTo()</h4> 
 <p>把原通道数据复制到目标通道</p> 
 <pre><code class="language-java"> @Test
    public void test03() throws Exception {
        // 1、字节输入管道
        FileInputStream is = new FileInputStream("E:\\test\\Aurora-4k.jpg");
        FileChannel isChannel = is.getChannel();
        // 2、字节输出流管道
        FileOutputStream fos = new FileOutputStream("E:\\test\\Aurora-4knew4.jpg");
        FileChannel osChannel = fos.getChannel();
        // 3、复制
        isChannel.transferTo(isChannel.position() , isChannel.size() , osChannel);
        isChannel.close();
        osChannel.close();
    }</code></pre> 
 <h4>13、案例6-分散 (Scatter) 和聚集 (Gather)</h4> 
 <ul><li>分散读取（Scatter ）:是指把Channel通道的数据读入到 多个缓冲区中去</li><li>聚集写入（Gathering ）是指将多个 Buffer 中的数 据“聚集”到 Channel。</li></ul> 
 <pre><code class="language-java">//分散和聚集
@Test
public void test() throws IOException{
		RandomAccessFile raf1 = new RandomAccessFile("1.txt", "rw");
	//1. 获取通道
	FileChannel channel1 = raf1.getChannel();
	
	//2. 分配指定大小的缓冲区
	ByteBuffer buf1 = ByteBuffer.allocate(100);
	ByteBuffer buf2 = ByteBuffer.allocate(1024);
	
	//3. 分散读取
	ByteBuffer[] bufs = {buf1, buf2};
	channel1.read(bufs);
	
	for (ByteBuffer byteBuffer : bufs) {
		byteBuffer.flip();
	}
	
	System.out.println(new String(bufs[0].array(), 0, bufs[0].limit()));
	System.out.println("-----------------");
	System.out.println(new String(bufs[1].array(), 0, bufs[1].limit()));
	
	//4. 聚集写入
	RandomAccessFile raf2 = new RandomAccessFile("2.txt", "rw");
	FileChannel channel2 = raf2.getChannel();
	
	channel2.write(bufs);
}
</code></pre> 
</blockquote> 
<hr> 
<h2>六、NIO核心三：选择器(Selector)</h2> 
<blockquote> 
 <h4>1、选择器(Selector)概述</h4> 
 <p>        选择器（Selector)是<strong>SelectableChannle对象</strong>的<strong>多路复用器</strong>，Selector可以<strong>同时监控多个</strong>SelectableChannel的IO状况，也就是说，利用Selector可使<strong>一个单独的线程管理多个Channel</strong>。Selector是非阻塞IO的核心。</p> 
 <ul><li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 Selector(选择器)</li><li>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个 Channel 以事件的方式可以注册到同一个(Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管</li><li>理多个通道，也就是管理多个连接和请求。</li><li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li><li>避免了多线程之间的上下文切换导致的开销</li></ul> 
 <hr> 
 <h4>2、选择器的应用</h4> 
 <p>创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。</p> 
 <pre><code class="language-java">Selector selector = Selector.open();</code></pre> 
 <p>向选择器注册通道：SelectableChannel.register(Selector sel, int ops)</p> 
 <pre><code class="language-java">//1. 获取通道
ServerSocketChannel ssChannel = ServerSocketChannel.open();
//2. 切换非阻塞模式
ssChannel.configureBlocking(false);
//3. 绑定连接
ssChannel.bind(new InetSocketAddress(9898));
//4. 获取选择器
Selector selector = Selector.open();
//5. 将通道注册到选择器上, 并且指定“监听接收事件”
ssChannel.register(selector, SelectionKey.OP_ACCEPT);</code></pre> 
 <p>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。可以监听的事件类型（用 可使用 SelectionKey 的四个常量 表示）：</p> 
 <ul><li><strong>读 : SelectionKey.OP_READ （1）</strong></li><li><strong>写 : SelectionKey.OP_WRITE （4）</strong></li><li><strong>连接 : SelectionKey.OP_CONNECT （8）</strong></li><li><strong>接收 : SelectionKey.OP_ACCEPT （16）</strong></li></ul> 
 <p>若注册时不止监听一个事件，则可以使用“位或”操作符连接。<br><span style="color:#fe2c24;"><strong>int interestSet = SelectionKey.OP_READ|SelectionKey.OP_WRITE</strong></span></p> 
 <hr> 
 <h3>3、NIO非阻塞式网络通信原理分析</h3> 
 <h4>3.1、Selector 示意图和特点说明</h4> 
 <p>        <strong>Selector可以实现：</strong> 一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p> 
 <p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/42/a2/0GsIEEWd_o.png"></p> 
 <h4>3.2、服务端流程</h4> 
 <h4> <strong>1)、获取通道。当客户端连接服务端时，服务端会通过 ServerSocketChannel 得到 SocketChannel：</strong></h4> 
 <pre><code class="language-java"> ServerSocketChannel ssChannel = ServerSocketChannel.open();</code></pre> 
 <p><strong>2)、切换非阻塞模式</strong></p> 
 <pre><code class="language-java"> ssChannel.configureBlocking(false);</code></pre> 
 <p><strong>3)、绑定连接</strong></p> 
 <pre><code class="language-java"> ssChannel.bind(new InetSocketAddress(8888));</code></pre> 
 <p><strong>4)、获取选择器</strong></p> 
 <pre><code class="language-java">Selector selector = Selector.open();</code></pre> 
 <p><strong>5)、将通道注册到选择器上, 并且指定“监听接收事件”</strong></p> 
 <pre><code class="language-java">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</code></pre> 
 <p><strong>6)、轮询式的获取选择器上已经“准备就绪”的事件</strong></p> 
 <pre><code class="language-java">while (selector.select() &gt; 0){
    System.out.println("开启事件处理");
    //7.获取选择器中所有注册的通道中已准备好的事件
    Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();
    //8.开始遍历事件
    while (it.hasNext()){
        SelectionKey selectionKey = it.next();
        System.out.println("---&gt;"+selectionKey);
        //9.判断这个事件具体是啥
        if (selectionKey.isAcceptable()){
            //10.获取当前接入事件的客户端通道
            SocketChannel socketChannel = serverSocketChannel.accept();
            //11.切换成非阻塞模式
            socketChannel.configureBlocking(false);
            //12.将本客户端注册到选择器
            socketChannel.register(selector,SelectionKey.OP_READ);
        }else if (selectionKey.isReadable()){
            //13.获取当前选择器上的读
            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
            //14.读取
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int len;
            while ((len = socketChannel.read(buffer)) &gt; 0){
                buffer.flip();
                System.out.println(new String(buffer.array(),0,len));
                //清除之前的数据（覆盖写入）
                buffer.clear();
            }
        }
        //15.处理完毕后，移除当前事件
        it.remove();
    }
}
</code></pre> 
 <hr> 
 <h4>3.3、客户端流程</h4> 
 <p><strong>1)、获取通道</strong></p> 
 <pre><code class="language-java">SocketChannel sChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1", 8888));</code></pre> 
 <p><strong>2)、切换非阻塞模式</strong></p> 
 <pre><code class="language-java">sChannel.configureBlocking(false);</code></pre> 
 <p><strong>3)、分配指定大小的缓冲区</strong></p> 
 <pre><code class="language-java">ByteBuffer buffer = ByteBuffer.allocate(1024);</code></pre> 
 <p><strong>4)、发送数据给绑定的服务端</strong></p> 
 <pre><code class="language-java">Scanner scan = new Scanner(System.in);
while(scan.hasNext()){
	String str = scan.nextLine();
	buf.put((new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(System.currentTimeMillis())
			+ "\n" + str).getBytes());
	buf.flip();
	sChannel.write(buf);
	buf.clear();
}
//关闭通道
sChannel.close();</code></pre> 
 <hr> 
 <h3>4、NIO非阻塞式网络通信入门案例</h3> 
 <p>需求：服务端接收客户端的连接请求，并接收多个客户端发送过来的事件。</p> 
 <p><strong>Server端代码实现：</strong></p> 
 <pre><code class="language-java">package nio.ss;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;

public class Server {
    public static void main(String[] args) {
        try {
            //1.获取管道
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
            //2.设置非阻塞模式
            serverSocketChannel.configureBlocking(false);
            //3.绑定端口
            serverSocketChannel.bind(new InetSocketAddress(8888));
            //4.获取选择器
            Selector selector = Selector.open();
            //5.将通道注册到选择器上，并且开始指定监听的接收事件
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            //6.轮询已经就绪的事件
            while (selector.select() &gt; 0){
                System.out.println("开启事件处理");
                //7.获取选择器中所有注册的通道中已准备好的事件
                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();
                //8.开始遍历事件
                while (it.hasNext()){
                    SelectionKey selectionKey = it.next();
                    System.out.println("---&gt;"+selectionKey);
                    //9.判断这个事件具体是啥
                    if (selectionKey.isAcceptable()){
                        //10.获取当前接入事件的客户端通道
                        SocketChannel socketChannel = serverSocketChannel.accept();
                        //11.切换成非阻塞模式
                        socketChannel.configureBlocking(false);
                        //12.将本客户端注册到选择器
                        socketChannel.register(selector,SelectionKey.OP_READ);
                    }else if (selectionKey.isReadable()){
                        //13.获取当前选择器上的读
                        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
                        //14.读取
                        ByteBuffer buffer = ByteBuffer.allocate(1024);
                        int len;
                        while ((len = socketChannel.read(buffer)) &gt; 0){
                            buffer.flip();
                            System.out.println(new String(buffer.array(),0,len));
                            //清除之前的数据（覆盖写入）
                            buffer.clear();
                        }
                    }
                    //15.处理完毕后，移除当前事件
                    it.remove();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
 <p><strong>Client端代码实现：</strong></p> 
 <pre><code class="language-java">package nio.ss;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.Scanner;

public class Client {
    public static void main(String[] args) {
        try {
            SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1",8888));
            socketChannel.configureBlocking(false);
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            Scanner scanner = new Scanner(System.in);
            while (true){
                System.out.print("请输入:");
                String msg = scanner.nextLine();
                buffer.put(msg.getBytes());
                buffer.flip();
                socketChannel.write(buffer);
                buffer.clear();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
 <hr> 
 <h4>5、NIO <a href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B&amp;spm=1001.2101.3001.7020" title="网络编程">网络编程</a>应用实例-群聊系统</h4> 
 <p><strong>需求:进一步理解 NIO 非阻塞网络编程机制，实现多人群聊</strong></p> 
 <ul><li>编写一个 NIO 群聊系统，实现客户端与客户端的通信需求（非阻塞）</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 channel 可以无阻塞发送消息给其它所有客户端用户，同时可以接受其它客户端用户通过服务端转发来的消息</li></ul> 
 <p><strong>服务端代码：</strong></p> 
 <pre><code class="language-java">package nio.chat;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;

/**
 *
 */
public class Server {
    //定义属性
    private Selector selector;
    private ServerSocketChannel ssChannel;
    private static final int PORT = 9999;
    //构造器
    //初始化工作
    public Server() {
        try {
            // 1、获取通道
            ssChannel = ServerSocketChannel.open();
            // 2、切换为非阻塞模式
            ssChannel.configureBlocking(false);
            // 3、绑定连接的端口
            ssChannel.bind(new InetSocketAddress(PORT));
            // 4、获取选择器Selector
            selector = Selector.open();
            // 5、将通道都注册到选择器上去，并且开始指定监听接收事件
            ssChannel.register(selector , SelectionKey.OP_ACCEPT);
        }catch (IOException e) {
            e.printStackTrace();
        }
    }
    //监听
    public void listen() {
        System.out.println("监听线程:" + Thread.currentThread().getName());
        try {
            while (selector.select() &gt; 0){
                // 7、获取选择器中的所有注册的通道中已经就绪好的事件
                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();
                // 8、开始遍历这些准备好的事件
                while (it.hasNext()){
                    // 提取当前这个事件
                    SelectionKey sk = it.next();
                    // 9、判断这个事件具体是什么
                    if(sk.isAcceptable()){
                        // 10、直接获取当前接入的客户端通道
                        SocketChannel schannel = ssChannel.accept();
                        // 11 、切换成非阻塞模式
                        schannel.configureBlocking(false);
                        // 12、将本客户端通道注册到选择器
                        System.out.println(schannel.getRemoteAddress() + " 上线 ");
                        schannel.register(selector , SelectionKey.OP_READ);
                        //提示
                    }else if(sk.isReadable()){
                        //处理读 (专门写方法..)
                        readData(sk);
                    }

                    it.remove(); // 处理完毕之后需要移除当前事件
                }
            }
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            //发生异常处理....

        }
    }

    //读取客户端消息
    private void readData(SelectionKey key) {
        //获取关联的channel
        SocketChannel channel = null;
        try {
            //得到channel
            channel = (SocketChannel) key.channel();
            //创建buffer
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int count = channel.read(buffer);
            //根据count的值做处理
            if(count &gt; 0) {
                //把缓存区的数据转成字符串
                String msg = new String(buffer.array());
                //输出该消息
                System.out.println("来自客户端---&gt; " + msg);
                //向其它的客户端转发消息(去掉自己), 专门写一个方法来处理
                sendInfoToOtherClients(msg, channel);
            }
        }catch (IOException e) {
            try {
                System.out.println(channel.getRemoteAddress() + " 离线了..");
                e.printStackTrace();
                //取消注册
                key.cancel();
                //关闭通道
                channel.close();
            }catch (IOException e2) {
                e2.printStackTrace();;
            }
        }
    }

    //转发消息给其它客户(通道)
    private void sendInfoToOtherClients(String msg, SocketChannel self ) throws  IOException{
        System.out.println("服务器转发消息中...");
        System.out.println("服务器转发数据给客户端线程: " + Thread.currentThread().getName());
        //遍历 所有注册到selector 上的 SocketChannel,并排除 self
        for(SelectionKey key: selector.keys()) {
            //通过 key  取出对应的 SocketChannel
            Channel targetChannel = key.channel();
            //排除自己
            if(targetChannel instanceof  SocketChannel &amp;&amp; targetChannel != self) {
                //转型
                SocketChannel dest = (SocketChannel)targetChannel;
                //将msg 存储到buffer
                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());
                //将buffer 的数据写入 通道
                dest.write(buffer);
            }
        }
    }

    public static void main(String[] args) {
        //创建服务器对象
        Server groupChatServer = new Server();
        groupChatServer.listen();
    }
}
</code></pre> 
 <p><strong>客户端代码：</strong></p> 
 <pre><code class="language-java">package nio.chat;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Scanner;

public class Client {
    //定义相关的属性
    private final String HOST = "127.0.0.1"; // 服务器的ip
    private final int PORT = 9999; //服务器端口
    private Selector selector;
    private SocketChannel socketChannel;
    private String username;

    //构造器, 完成初始化工作
    public Client() throws IOException {
        selector = Selector.open();
        //连接服务器
        socketChannel = socketChannel.open(new InetSocketAddress("127.0.0.1", PORT));
        //设置非阻塞
        socketChannel.configureBlocking(false);
        //将channel 注册到selector
        socketChannel.register(selector, SelectionKey.OP_READ);
        //得到username
        username = socketChannel.getLocalAddress().toString().substring(1);
        System.out.println(username + " is ok...");
    }

    //向服务器发送消息
    public void sendInfo(String info) {
        info = username + " 说：" + info;
        try {
            socketChannel.write(ByteBuffer.wrap(info.getBytes()));
        }catch (IOException e) {
            e.printStackTrace();
        }
    }

    //读取从服务器端回复的消息
    public void readInfo() {
        try {
            int readChannels = selector.select();
            if(readChannels &gt; 0) {//有可以用的通道

                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();
                while (iterator.hasNext()) {

                    SelectionKey key = iterator.next();
                    if(key.isReadable()) {
                        //得到相关的通道
                        SocketChannel sc = (SocketChannel) key.channel();
                        //得到一个Buffer
                        ByteBuffer buffer = ByteBuffer.allocate(1024);
                        //读取
                        sc.read(buffer);
                        //把读到的缓冲区的数据转成字符串
                        String msg = new String(buffer.array());
                        System.out.println(msg.trim());
                    }
                }
                iterator.remove(); //删除当前的selectionKey, 防止重复操作
            } else {
                //System.out.println("没有可以用的通道...");
            }
        }catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception {
        //启动我们客户端
        Client chatClient = new Client();
        //启动一个线程, 每个3秒，读取从服务器发送数据
        new Thread() {
            public void run() {
                while (true) {
                    chatClient.readInfo();
                    try {
                        Thread.currentThread().sleep(3000);
                    }catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }.start();

        //发送数据给服务器端
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNextLine()) {
            String s = scanner.nextLine();
            chatClient.sendInfo(s);
        }
    }
}
</code></pre> 
 <p></p> 
</blockquote> 
<hr> 
<h2>七、AIO 深入剖析</h2> 
<blockquote> 
 <p><strong>Java AIO(NIO.2) ：</strong> 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p> 
 <pre><code class="language-java">AIO：异步非阻塞，基于NIO的，可以称之为NIO2.0

    BIO                   NIO                              AIO        
Socket                SocketChannel                    AsynchronousSocketChannel
ServerSocket          ServerSocketChannel	       AsynchronousServerSocketChannel
</code></pre> 
 <p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可, 这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区,对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序</p> 
 <p>即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称作NIO.2，主要在Java.nio.channels包下增加了下面四个异步通道：</p> 
 <ul><li>AsynchronousSocketChannel</li><li>​ AsynchronousServerSocketChannel</li><li>​ AsynchronousFileChannel</li><li>​ AsynchronousDatagramChannel</li></ul> 
</blockquote> 
<hr> 
<h2>八、总结</h2> 
<blockquote> 
 <p><strong>BIO、NIO、AIO：</strong></p> 
 <ul><li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li><li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</li><li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</li></ul> 
 <p><strong>BIO、NIO、AIO适用场景分析:</strong></p> 
 <ul><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。Netty!</li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/856c6864ae4648c69d97d79dc6969e97/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java乱码问题分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5f6c28709ceff6939891e66b6006bc56/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据表的设计原则</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>