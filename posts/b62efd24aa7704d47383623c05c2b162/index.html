<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue组件缓存之keep-alive正确使用姿势 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue组件缓存之keep-alive正确使用姿势" />
<meta property="og:description" content="先来看一个项目中的需求 作为苦逼的前端开发者，我们无时无刻都要面对产品经理提的各种需求, 比如下图这个场景
场景：
从首页的点击导航进入列表页,
列表页点击列表进入 该 数据详情页
从详情页返回，希望列表页缓存，不重新渲染数据，这样会提高用户体验。
分析一下 这样需求，如果是小程序的话，默认列表页就会缓存，因为小程序的运行环境是微信客户端，当我们打开一个页面会新建一个webview，
所有列表页和详情页是两个webview，当我们进入详情页，列表页webview，只是会在详情页webview下面，不会销毁。
以下是小程序运行环境：我们可以看到每个页面都有一个webview
但是但是，我们的项目是用vue开发的webapp,多个组件共用一个窗口，当我们切换路由时，切出路由组件会销毁，所有列表页进入详情页列表页会销毁，重新回到列表页，列表页组件会重新加载。
解决方案 睡服提需求的人，改个简单的需求 emm... ,看了看镜子中的自己，估计这辈子没办法从脸上得到任何的便利了,老老实实换个方案吧。
keep-alive keep-alive是Vue提供的一个抽象组件，主要用于保留组件状态或避免重新渲染。
&lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。
和&lt;transition&gt; 相似， &lt;keep-alive&gt; 是一个抽象组件，它自身不会渲染一个DOM元素，也不会出现在父组件链中。
但是 keep-alive 会把其包裹的所有组件都缓存起来。
em...怎么办呢，我们只是需要让列表页缓存啊.
分析一下 我们可以把需求拆分为2步
(1) 把需要缓存和不需要缓存的组件区分开，在组件的路由配置的元信息，meta中定义哪些需要缓存哪些不需要缓存
具体代码如下
1，定义两个出口 router-view
&lt;keep-alive&gt; &lt;!-- 需要缓存的视图组件 --&gt; &lt;router-view v-if=&#34;$route.meta.keepAlive&#34;&gt; &lt;/router-view&gt; &lt;/keep-alive&gt; ​ &lt;!-- 不需要缓存的视图组件 --&gt; &lt;router-view v-if=&#34;!$route.meta.keepAlive&#34;&gt; &lt;/router-view&gt; 2，在router配置中定义哪些需要缓存哪些不需要缓存
new Router({ routes: [ { path: &#39;/&#39;, name: &#39;index&#39;, component: () =&gt; import(&#39;./views/keep-alive/index.vue&#39;) }, { path: &#39;/list&#39;, name: &#39;list&#39;, component: () =&gt; import(&#39;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b62efd24aa7704d47383623c05c2b162/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-27T14:07:31+08:00" />
<meta property="article:modified_time" content="2023-07-27T14:07:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue组件缓存之keep-alive正确使用姿势</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><strong>先来看一个项目中的需求</strong></h4> 
<p>作为苦逼的前端开发者，我们无时无刻都要面对产品经理提的各种需求, 比如下图这个场景</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3c/c7/B4SqmtPJ_o.gif"></p> 
<p></p> 
<p><strong>场景：</strong></p> 
<p>从首页的点击导航进入列表页,</p> 
<p>列表页点击列表进入 该 数据详情页</p> 
<p>从详情页返回，希望列表页缓存，不重新渲染数据，这样会提高用户体验。</p> 
<h4><strong>分析一下</strong></h4> 
<p>这样需求，如果是小程序的话，默认列表页就会缓存，因为小程序的运行环境是微信客户端，当我们打开一个页面会新建一个webview，</p> 
<p>所有列表页和详情页是两个webview，当我们进入详情页，列表页webview，只是会在详情页webview下面，不会销毁。</p> 
<p>以下是小程序运行环境：我们可以看到每个页面都有一个webview</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/75/ac/k94aKPk0_o.png"></p> 
<p>但是但是，我们的项目是用vue开发的webapp,多个组件共用一个窗口，当我们切换路由时，切出路由组件会销毁，所有列表页进入详情页列表页会销毁，重新回到列表页，列表页组件会重新加载。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8b/33/s1WpdsXo_o.png"></p> 
<h4><strong>解决方案</strong></h4> 
<ol><li>睡服提需求的人，改个简单的需求</li></ol> 
<p>emm... ,看了看镜子中的自己，估计这辈子没办法从脸上得到任何的便利了,老老实实换个方案吧。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6e/fe/fNmNB0bx_o.png"></p> 
<ol><li><code>keep-alive</code></li></ol> 
<p><code>keep-alive</code>是Vue提供的一个抽象组件，主要用于保留组件状态或避免重新渲染。</p> 
<p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。</p> 
<p>和<code>&lt;transition&gt;</code> 相似，<code> &lt;keep-alive&gt;</code> 是一个抽象组件，它自身不会渲染一个DOM元素，也不会出现在父组件链中。</p> 
<p>但是 <code>keep-alive</code> 会把其包裹的所有组件都缓存起来。</p> 
<p>em...怎么办呢，我们只是需要让列表页缓存啊.</p> 
<h4><strong>分析一下</strong></h4> 
<p>我们可以把需求拆分为2步</p> 
<p>(1) 把需要缓存和不需要缓存的组件区分开，在组件的路由配置的元信息，meta中定义哪些需要缓存哪些不需要缓存</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/14/bf/2Tp1VwMA_o.png"></p> 
<p>具体代码如下</p> 
<p>1，定义两个出口 <code>router-view</code></p> 
<pre><code>&lt;keep-alive&gt;
    &lt;!-- 需要缓存的视图组件 --&gt;
  &lt;router-view v-if="$route.meta.keepAlive"&gt;
  &lt;/router-view&gt;
&lt;/keep-alive&gt;
​
&lt;!-- 不需要缓存的视图组件 --&gt;
&lt;router-view v-if="!$route.meta.keepAlive"&gt;
&lt;/router-view&gt;</code></pre> 
<p>2，在router配置中定义哪些需要缓存哪些不需要缓存</p> 
<pre><code>new Router({
    routes: [
        {
            path: '/',
            name: 'index',
            component: () =&gt; import('./views/keep-alive/index.vue')
        },
        {
            path: '/list',
            name: 'list',
            component: () =&gt; import('./views/keep-alive/list.vue'),
            meta: {
                keepAlive: true //需要被缓存
            }
        },
        {
            path: '/detail',
            name: 'detail',
            component: () =&gt; import('./views/keep-alive/detail.vue')
        }
    ]
})
</code></pre> 
<p>(2)，开始按需缓存组件</p> 
<p>我们从官方文档提供的 api 入手,</p> 
<p>keep-alive组件如果设置了 include ，就只有和 include 匹配的组件会被缓存，</p> 
<p>所以思路就是，动态修改 include 数组来实现按需缓存。</p> 
<pre><code>&lt;template&gt;
    &lt;keep-alive :include="include"&gt;
        &lt;!-- 需要缓存的视图组件 --&gt;
      &lt;router-view v-if="$route.meta.keepAlive"&gt;
      &lt;/router-view&gt;
    &lt;/keep-alive&gt;
​
    &lt;!-- 不需要缓存的视图组件 --&gt;
    &lt;router-view v-if="!$route.meta.keepAlive"&gt;
    &lt;/router-view&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
      name: "app",
      data: () =&gt; ({
        include: []
      }),
      watch: {
        $route(to, from) {
          //如果 要 to(进入) 的页面是需要 keepAlive 缓存的，把 name push 进 include数组
          if (to.meta.keepAlive) {
            !this.include.includes(to.name) &amp;&amp; this.include.push(to.name);
          }
        }
      }
    };
&lt;/script&gt;
​
</code></pre> 
<p>此时我们发现，从详情页返回列表页，列表页真的不再刷新了</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7d/24/V7bUlVVS_o.jpg"></p> 
<p>em...新的问题又出现了,由于 列表页被缓存了,这个时候我从首页,再点击进入某个列表，也不刷新了，完了，点击首页导航应该进入不同的列表页的. 也就是说，从首页进入列表组件不应该被缓存的。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/30/0a/hTnLjp95_o.png"></p> 
<p>解决一下，我们在定义路由是，在元信息中再加一个字段，这里是deepth字段，代表进入路由的层级,比如首页路由deepth是0.5,列表页是1,详情页是2</p> 
<pre><code>new Router({
    routes: [
        {
            path: '/',
            name: 'index',
            component: () =&gt; import('./views/keep-alive/index.vue'),
            meta: {
                deepth: 0.5 // 定义路由的层级
            }
        },
        {
            path: '/list',
            name: 'list',
            component: () =&gt; import('./views/keep-alive/list.vue'),
            meta: {
                deepth: 1
                keepAlive: true //需要被缓存
            }
        },
        {
            path: '/detail',
            name: 'detail',
            component: () =&gt; import('./views/keep-alive/detail.vue'),
            meta: {
                deepth: 2
           }
        }
    ]
})
</code></pre> 
<p>然后在 app.vue中增加监听器，监听 我们进入路由的 方向</p> 
<p>具体代码如下</p> 
<pre><code>&lt;template&gt;
    &lt;keep-alive :include="include"&gt;
    &lt;!-- 需要缓存的视图组件 --&gt;
      &lt;router-view v-if="$route.meta.keepAlive"&gt;
      &lt;/router-view&gt;
    &lt;/keep-alive&gt;
​
    &lt;!-- 不需要缓存的视图组件 --&gt;
    &lt;router-view v-if="!$route.meta.keepAlive"&gt;
    &lt;/router-view&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
      name: "app",
      data: () =&gt; ({
        include: []
      }),
      watch: {
        $route(to, from) {
          //如果 要 to(进入) 的页面是需要 keepAlive 缓存的，把 name push 进 include数组
          if (to.meta.keepAlive) {
            !this.include.includes(to.name) &amp;&amp; this.include.push(to.name);
          }
          //如果 要 form(离开) 的页面是 keepAlive缓存的，
          //再根据 deepth 来判断是前进还是后退
          //如果是后退
          if (from.meta.keepAlive &amp;&amp; to.meta.deepth &lt; from.meta.deepth) {
            var index = this.include.indexOf(from.name);
            index !== -1 &amp;&amp; this.include.splice(index, 1);
          }
        }
      }
    };
&lt;/script&gt;
</code></pre> 
<p>em...终于解决啦，完美!!!</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a6ccb92a19b5ab93dacbc53cd3f55280/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">@click.native和@click的区别？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/16c9ec81f8bdd61e6f226beb4642e847/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">flink oracle cdc实时同步（超详细）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>