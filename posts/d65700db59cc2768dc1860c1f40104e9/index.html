<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图像分类任务的可视化脚本，生成类别json字典文件 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图像分类任务的可视化脚本，生成类别json字典文件" />
<meta property="og:description" content="1. 前言 之前的图像分类任务可视化，都是在train脚本里， 用torch中dataloader将图片和类别加载，然后利用matplotlib库进行可视化。
如这篇文章中：CNN 卷积神经网络对染色血液细胞分类(blood-cells)
在分类任务中，必定经历过图像预处理，缩放啊、随即裁剪啊之类的，可视化效果不太明显
本章将从数据角度出发，直接根据数据目录将图像可视化，随机展示所有图片的四张图片，可视化后并且保存
目标检测的可视化可以参考：
关于目标检测任务中，YOLO(txt格式)标注文件的可视化 关于目标检测任务中，XML(voc格式)标注文件的可视化
2. 根据目录可视化 （无需类别的json文件） 目录如下：代码应该data同一路径
2.1 代码介绍 root 传入的是文件夹路径，也就是多个类别文件夹的上一级目录
将所有图像保存，为了知道图片的类别，需要把图片的父目录保存。为了方便，这里生成一个列表文件，key 是目录类别，value 是相应的图像路径
展示的代码很简单，生成随机数，将列表的文件提取出来，然后展示四张就行了
2.2 可视化结果 可视化结果
代码会在当前目录生成刚刚可视化展示的图片
2.3 完整代码 如下：
import os import matplotlib.pyplot as plt import random from PIL import Image def main(path): classes = [i for i in os.listdir(path)] # [&#39;cat&#39;, &#39;dog&#39;] # 将所有图片按照 类别:路径 字典形式保存 images_path = [] # [{&#39;cat&#39;: &#39;./data/train\\cat\\Baidu_0000.jpeg&#39;}, {&#39;cat&#39;: &#39;./data/train\\cat\\Baidu_0002.jpeg&#39;}] for cla in classes: for i in os." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d65700db59cc2768dc1860c1f40104e9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T18:29:45+08:00" />
<meta property="article:modified_time" content="2024-01-09T18:29:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图像分类任务的可视化脚本，生成类别json字典文件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1. 前言</h2> 
<p>之前的图像分类任务可视化，都是在train脚本里， 用torch中dataloader将图片和类别加载，然后利用matplotlib库进行可视化。</p> 
<p>如这篇文章中：<a class="link-info" href="https://blog.csdn.net/qq_44886601/article/details/129392065" title="CNN 卷积神经网络对染色血液细胞分类(blood-cells)">CNN 卷积神经网络对染色血液细胞分类(blood-cells)</a></p> 
<p><img alt="" height="761" src="https://images2.imgbox.com/c7/6c/8trgfuek_o.png" width="801"></p> 
<p></p> 
<p>在分类任务中，必定经历过图像预处理，缩放啊、随即裁剪啊之类的，可视化效果不太明显</p> 
<blockquote> 
 <p>本章将从数据角度出发，直接根据数据目录将图像可视化，随机展示所有图片的四张图片，可视化后并且保存</p> 
</blockquote> 
<p>目标检测的可视化可以参考：</p> 
<p><a class="link-info" href="https://blog.csdn.net/qq_44886601/article/details/135402215?spm=1001.2014.3001.5502" title="关于目标检测任务中，YOLO(txt格式)标注文件的可视化">关于目标检测任务中，YOLO(txt格式)标注文件的可视化</a> </p> 
<p><a class="link-info" href="https://blog.csdn.net/qq_44886601/article/details/135400117?spm=1001.2014.3001.5502" title="关于目标检测任务中，XML(voc格式)标注文件的可视化">关于目标检测任务中，XML(voc格式)标注文件的可视化</a></p> 
<p></p> 
<h2>2. 根据目录可视化 （无需类别的json文件）</h2> 
<p>目录如下：<strong>代码应该data同一路径</strong></p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/86/14/p8ws2i9m_o.png" width="800"></p> 
<p></p> 
<h3>2.1 代码介绍</h3> 
<p>root 传入的是文件夹路径，也就是多个类别文件夹的上一级目录</p> 
<p><img alt="" height="121" src="https://images2.imgbox.com/10/8c/xq6cYL75_o.png" width="1200"></p> 
<p></p> 
<p>将所有图像保存，为了知道图片的类别，需要把图片的父目录保存。为了方便，这里生成一个列表文件，key 是目录类别，value 是相应的图像路径</p> 
<p><img alt="" height="334" src="https://images2.imgbox.com/95/27/POYd29n6_o.png" width="1200"></p> 
<p></p> 
<p>展示的代码很简单，生成随机数，将列表的文件提取出来，然后展示四张就行了</p> 
<p><img alt="" height="467" src="https://images2.imgbox.com/cb/f0/GQMDWSkk_o.png" width="1200"></p> 
<p></p> 
<h3>2.2 可视化结果</h3> 
<p>可视化结果</p> 
<p><img alt="" height="899" src="https://images2.imgbox.com/f8/03/qQiUeSB4_o.png" width="1200"></p> 
<p></p> 
<p>代码会在当前目录生成刚刚可视化展示的图片</p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/b8/8d/hRuqzdA7_o.png" width="771"></p> 
<p></p> 
<h3>2.3 完整代码</h3> 
<p>如下：</p> 
<pre><code class="language-python">import os
import matplotlib.pyplot as plt
import random
from PIL import Image


def main(path):
    classes = [i for i in os.listdir(path)]         # ['cat', 'dog']

    # 将所有图片按照 类别:路径 字典形式保存
    images_path = []  # [{'cat': './data/train\\cat\\Baidu_0000.jpeg'}, {'cat': './data/train\\cat\\Baidu_0002.jpeg'}]
    for cla in classes:
        for i in os.listdir(os.path.join(path,cla)):
            dic = {}  # 类别:图像路径
            img_path = os.path.join(path,cla,i)
            dic[cla] = img_path             # {'cat': './data/train\\cat\\Baidu_0000.jpeg'}
            images_path.append(dic)

    # 随机展示4张图像
    plt.figure(figsize=(12,8))
    for i in range(4):
        r = random.randint(0,len(images_path)-1)      # 生成随机数
        label,im_path= list(images_path[r].keys())[0],list(images_path[r].values())[0]
        #  cat , ./data/train\cat\Baidu_0049.jpeg

        im = Image.open(im_path)
        plt.subplot(2,2,i+1)
        plt.title(label)
        plt.imshow(im)

    plt.savefig('show.png')     # 保存图片
    plt.show()


if __name__ == '__main__':
    root = './data/train'       # 传入目录
    main(path=root)
</code></pre> 
<p></p> 
<h2>3.生成类别json字典文件</h2> 
<p>图像分类任务，有的没有提供类别的字典文件，这里也记录一下如何生成json文件</p> 
<p><img alt="" height="206" src="https://images2.imgbox.com/83/34/d48e1HXj_o.png" width="807"></p> 
<p></p> 
<p>可以通过下面代码生成</p> 
<pre><code class="language-python">import os
import json


def main(path):
    classes = [i for i in os.listdir(path)]  # ['cat', 'dog']

    labels = {}         # 类别的字典文件
    for index,name in enumerate(classes):
        labels[index] = name
    labels = json.dumps(labels,indent=4)

    with open('./class_indices.json','w') as f:         # 保存成json文件
        f.write(labels)


if __name__ == '__main__':
    root = './data/train'  # 传入目录
    main(path=root)
</code></pre> 
<p></p> 
<p>结果如下：</p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/22/57/mDwr9EiZ_o.png" width="860"></p> 
<p></p> 
<hr> 
<p>或者直接新建json文件，然后对照目录按照上面的方式输入也行</p> 
<p></p> 
<h3></h3> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9fa4fd303daae6507da079b914b61555/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Go 如何处理死锁以提供哪些工具来检测或防死锁？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/845e7359736e46d4456459d4d77de108/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">免费用chatGPT</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>