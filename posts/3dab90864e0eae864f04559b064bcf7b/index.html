<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一个Java初学者写的博客（一） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一个Java初学者写的博客（一）" />
<meta property="og:description" content="Java简介 java 是一个面向对象（Object Oriented,OO）的编程语言，和其他大多数的 面向对象编程语言一样，都是单根结构，面向对象的最上级水平：万物皆对象。 瞎扯1： （即java 里所有的东西都有共同的‘祖先’ Object），父和子的说法来源于面向 对象三大特征之一的继承，说面向对象其实也就是面向 Object 这个‘祖先’，毕 竟java里所有的东西都是 Object 的后代，这个说法就有点 多态 的意思了，面 向（Object），这个参数 Object 可以是 Object 的任何一个后代，当然我们 自己创建的类也是 Object 的后代。 类和对象 类：（归）类 成员变量，类的属性、特征 成员方法，类的行为、动作 （构造方法，类变成实例时进行的行为/动作） 对象：类具体的例子，类的实例 （构造方法 new 出来的） 类与类之间的关系 泛化： 继承 实现（接口） 依赖： 临时性，很弱 类 A 作为参数在类 B 中使用 关联： 长期性，比依赖强 类 A 是类 B 的一个属性 聚合（弱聚合）： 类 A 是类 B 的一个属性，但是这个属性可有可无 组合（强聚合）： 类 A 是类 B 的一个属性，这个属性必须有，同生命周期 面向对象 封装： 用 private 修饰 成员变量 ，隐藏类内部细节 提供 public 修饰的 getter 和 setter 方法，作为外部访问类内 成员 变量 的入口 （工厂模式就是最好的应用，往下翻有工厂模式） 继承：（分）类 将一些类的 共同属性/行为/特征/动作 抽象出来产生一个父类，便于分类 （值得注意的是java特别符合现实中的伦理道德，每个类只允许有一个父亲， 也就是单继承 extend ） 多态：前提是继承，运行时才会发生（一个LOL战队一般都有有很多个队员，真正 要上场了才知道谁上场谁替补，faker 都替补了:) ） 可以说是有两种： 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3dab90864e0eae864f04559b064bcf7b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-31T19:39:06+08:00" />
<meta property="article:modified_time" content="2018-08-31T19:39:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一个Java初学者写的博客（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Java_2"></a>Java简介</h3> 
<pre><code>java 是一个面向对象（Object Oriented,OO）的编程语言，和其他大多数的
面向对象编程语言一样，都是单根结构，面向对象的最上级水平：万物皆对象。

瞎扯1：
（即java 里所有的东西都有共同的‘祖先’ Object），父和子的说法来源于面向
对象三大特征之一的继承，说面向对象其实也就是面向 Object 这个‘祖先’，毕
竟java里所有的东西都是 Object 的后代，这个说法就有点 多态 的意思了，面
向（Object），这个参数 Object 可以是 Object 的任何一个后代，当然我们
自己创建的类也是 Object 的后代。
</code></pre> 
<h3><a id="_15"></a>类和对象</h3> 
<pre><code>类：（归）类
	成员变量，类的属性、特征
	成员方法，类的行为、动作
	（构造方法，类变成实例时进行的行为/动作）

对象：类具体的例子，类的实例
	（构造方法 new 出来的）
</code></pre> 
<h3><a id="_25"></a>类与类之间的关系</h3> 
<pre><code>泛化：
	继承
	实现（接口）
	
依赖：
	临时性，很弱
	类 A 作为参数在类 B 中使用

关联：
	长期性，比依赖强
	类 A 是类 B 的一个属性

聚合（弱聚合）：
	类 A 是类 B 的一个属性，但是这个属性可有可无

组合（强聚合）：
	类 A 是类 B 的一个属性，这个属性必须有，同生命周期
</code></pre> 
<h3><a id="_45"></a>面向对象</h3> 
<pre><code>封装：

	用 private 修饰 成员变量 ，隐藏类内部细节
	提供 public 修饰的 getter 和 setter 方法，作为外部访问类内 成员
	变量 的入口

	（工厂模式就是最好的应用，往下翻有工厂模式）
		
继承：（分）类

	将一些类的 共同属性/行为/特征/动作 抽象出来产生一个父类，便于分类
	（值得注意的是java特别符合现实中的伦理道德，每个类只允许有一个父亲，
	也就是单继承 extend ）
	
多态：前提是继承，运行时才会发生（一个LOL战队一般都有有很多个队员，真正
	要上场了才知道谁上场谁替补，faker 都替补了:) ）

	可以说是有两种： 1.赋值多态     2.传参多态
	也可以说是就一种：赋值多态。    传参多态理解为 形式参数 被赋值。
	
	我是理解只有一种：赋值多态，待赋值的（形式参数/对象引用），在运行
		之前被告诉是 XX的孩子 ，但是 XX 有好多个孩子，在运行时才会
		被具体告诉是 XX的哪个孩子 。

抽象类：半成品，有的本领自己还没掌握，但是寄希望于自己的后代（现实中的
	父亲望子成龙）

重写/重载：

	重写：修改方法内在，外表不修改（修身养性）
	
	重载：修改方法外表 和 内在，（整容 + 修身养性）

接口：（老师，教 类 本领的，是本领的集合，而且有各种老师）

	类想学什么本领就继承 什么老师 ，不过学的有好有坏，学习后掌握的程度
	也都大不相同，所以每个本领都得具体到自己身上，也就是要重写那个本领
	（想到说每一次考历史都是改写历史的同学，还有表面上体育课---）。
</code></pre> 
<h3><a id="IO_86"></a>I/O</h3> 
<pre><code>Input：输入到java运行环境jvm里

Output:从java运行环境jvm输出
	
字节流和字符流的区别：

	字节流：直接操作文件
	字符流：通过缓冲区（内存）操作文件

序列化：将一个对象变成字节序列 ， 继承接口 Serializable 只是一个标识，
	表示可被序列化，（类似你拿了CET-4，就标识你这个人会一点点英语）
</code></pre> 
<h3><a id="_102"></a>集合框架</h3> 
<p><a href="http://www.runoob.com/java/java-collections.html" rel="nofollow">想仔细了解集合框架，点这里跳转到菜鸟教程 Java-集合框架： http://www.runoob.com/java/java-collections.html</a></p> 
<pre><code>那么多东西谁能记得住，到时候点上面的链接。

ArrayList：动态数组，内存空间里连续，所以查询快，增删要维护所有的，
	所以增删慢

LinkedList：链表，内存空间里不连续，所以查询慢，因为内存空间里是用 链 
	连起来的，增删只用维护 链 就可以了，所以增删快

HashSet：不能重复，不一定是你放进去的顺序

TreeSet：不能重复，可以排序

HashMap：key-value		
</code></pre> 
<p>List：一般用来存放数据<br> Set：做个排序（TreeSet），去个重（HashSet）<br> Map：做缓存比较好，因为 key-value 。</p> 
<h3><a id="_124"></a>包装类</h3> 
<pre><code>8个包装类，对应8种基本数据类型，便于进行对象操作。

基本数据类型-包装类-String 互相转换：
</code></pre> 
<p><img src="https://images2.imgbox.com/29/47/bqe3QMcx_o.png" alt="这里写图片描述"></p> 
<pre><code>缓存值范围：

	Boolean：    (全部缓存)
	Byte：       (全部缓存)
	Character：  (&lt;= 127 缓存)
	Short：      (-128 — 127 缓存)
	Long：       (-128 — 127缓存)
	Integer：    (-128 — 127缓存)
	Float：      (没有缓存)
	Doulbe：     (没有缓存)

缓存值范围作用：    判断该不该 new 一个对象。
	见下图：
</code></pre> 
<p><img src="https://images2.imgbox.com/07/9a/2gz777nE_o.png" alt="缓存值范围作用"></p> 
<h3><a id="_148"></a>设计模式</h3> 
<pre><code>工厂模式：隐藏生产细节， 想要什么找什么工厂生产

抽象工厂：将工厂抽象出父类，例如水果工厂，有苹果工厂子类，香蕉工厂子类等。

单例：单例类的对象只允许存在一个，所以就用 private 修饰构造方法，
	只允许自己 new 自己。
	
	饿汉：一上来就直接 new 了。
	懒汉：让一个 public static 的方法（通常是叫 getInstance ）来 new，
		先判断 实例对象 是否为 null ，是 null 的话就 new ，
		不是的话就不 new 并返回 实例对象 的引用。 

装饰者：套壳。（国产浏览器:)）

适配器：中间件。将两个不匹配的东西 匹配 一下（电源适配器。。）
	
	(摘抄自这个博客https://www.cnblogs.com/V1haoge/p/6479118.html)
	
	1、类适配器：
	　　原理：通过继承来实现适配器功能。
	　　
	　　简单的例子：
		　　两个接口： A ， B
		　　两个接口对应的实现类：A_Impl , B_Impl
		　　适配器：  Adapter 继承 B_Impl 实现 A 
				或者 Adapter 继承 A_Impl 实现 B
			测试类：new 一个 Adapter 类的 对象 adapter 就可以连接
					接口 A 和 B 。
		　　
	2、对象适配器：
		原理：通过组合（强聚合）来实现适配器功能。

		简单的例子：
		　　两个接口： A ， B
		　　两个接口对应的实现类：A_Impl , B_Impl
		　　适配器：  Adapter 实现 A ，并包含一个 B_impl 类型的成员变量
				或者 Adapter 实现 B ，并包含一个 A_impl 类型的成员变量
			测试类：new 一个 Adapter 类的 对象 adapter 就可以连接
					接口 A 和 B 。
	3、接口适配器：
		原理：通过抽象类来实现适配，这种适配稍别于上面所述的适配。

		简单的例子：
			接口 A 里面有很多方法 
			抽象的 Adapter 空实现 A 的所有方法 
			实现类 A_Impl 继承 Adapter ，需要什么方法就重写什么方法
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f13f5a329dd11fd16221ebc684ef877f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">我的JAVA面试经验(3年左右工作经验)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b49fa5093ee99ba191114458211070a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">统计学中常见的概率密度图像</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>