<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>volatile和synchronized的区别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="volatile和synchronized的区别" />
<meta property="og:description" content="volatile和synchronized特点 首先需要理解线程安全的两个方面：执行控制和内存可见。
执行控制的目的是控制代码执行（顺序）及是否可以并发执行。
内存可见控制的是线程执行结果在内存中对其它线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。
synchronized关键字解决的是执行控制的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被synchronized关键字保护的代码块无法被其它线程访问，也就无法并发执行。更重要的是，synchronized还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都happens-before于随后获得这个锁的线程的操作。
volatile关键字解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。
使用volatile关键字仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，但需要特别注意， volatile不能保证复合操作的原子性，即使只是i&#43;&#43;，实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i&#43;&#43;，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。
在Java 5提供了原子数据类型atomic wrapper classes，对它们的increase之类的操作都是原子操作，不需要使用sychronized关键字。
对于volatile关键字，当且仅当满足以下所有条件时可使用：
1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。 2. 该变量没有包含在具有其他变量的不变式中。 volatile和synchronized的区别 volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化 如果想更好地理解这两个关键字的作用，强烈建议看一下这篇文章：Java内存模型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b37ef27e56d46750c1de4681b5a5529e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-09-21T18:16:55+08:00" />
<meta property="article:modified_time" content="2016-09-21T18:16:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">volatile和synchronized的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="volatile和synchronized特点">volatile和synchronized特点</h3> 
<p>首先需要理解线程安全的两个方面：<strong>执行控制</strong>和<strong>内存可见</strong>。</p> 
<p><strong>执行控制</strong>的目的是控制代码执行（顺序）及是否可以并发执行。</p> 
<p><strong>内存可见</strong>控制的是线程执行结果在内存中对其它线程的可见性。根据<a href="http://blog.csdn.net/suifeng3051/article/details/52611310">Java内存模型</a>的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。</p> 
<p><code>synchronized</code>关键字解决的是执行控制的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被<code>synchronized</code>关键字保护的代码块无法被其它线程访问，也就无法并发执行。更重要的是，<code>synchronized</code>还会创建一个<strong>内存屏障</strong>，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都<strong>happens-before</strong>于随后获得这个锁的线程的操作。</p> 
<p><code>volatile</code>关键字解决的是内存可见性的问题，会使得所有对<code>volatile</code>变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。</p> 
<p>使用<code>volatile</code>关键字仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，但需要特别注意， <code>volatile</code>不能保证复合操作的原子性，即使只是<code>i++</code>，实际上也是由多个原子操作组成：<code>read i; inc; write i</code>，假如多个线程同时执行<code>i++</code>，<code>volatile</code>只能保证他们操作的<code>i</code>是同一块内存，但依然可能出现写入脏数据的情况。</p> 
<p>在Java 5提供了原子数据类型<code>atomic wrapper classes</code>，对它们的<code>increase</code>之类的操作都是原子操作，不需要使用<code>sychronized</code>关键字。</p> 
<p>对于<code>volatile</code>关键字，当且仅当满足以下所有条件时可使用：</p> 
<pre><code>1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
2. 该变量没有包含在具有其他变量的不变式中。
</code></pre> 
<h3 id="volatile和synchronized的区别">volatile和synchronized的区别</h3> 
<ol><li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</li><li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</li></ol> 
<p>如果想更好地理解这两个关键字的作用，强烈建议看一下这篇文章：<a href="http://blog.csdn.net/suifeng3051/article/details/52611310">Java内存模型</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f33ec6c99c0f2af7969c07cc5abcb99/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mockito&amp;PowerMockito实战</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f5f594cfc1ef6ce6d2dde0d1a2b9443/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信开发之access_token之坑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>