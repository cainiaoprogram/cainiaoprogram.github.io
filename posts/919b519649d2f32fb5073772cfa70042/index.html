<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>glReadPixels读取buffer并转换成BMP图片 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="glReadPixels读取buffer并转换成BMP图片" />
<meta property="og:description" content="1.glReadPixels
glReadPixels(GLint x,GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid*pixels)
glReadPixels 是将GPU渲染完数据，从GPU回传到host端的唯一方式，由入参（x,y,w,h）制定一个从一帧图像中读取内存的矩形，type和format指定格式，pixels是输出像素的buffer
注意：glReadPixels实际上是从缓冲区中读取数据，如果使用了双缓冲区，则默认是从正在显示的缓冲（即前缓冲）中读取，而绘制工作是默认绘制到后缓冲区的。因此，如果需要读取已经绘制好的像素，往往需要先交换前后缓冲
int *pixel = (int*)malloc(sizeof(int)*1440*2560);
memset(pixel,0,sizeof(int)*1440*2560);
//int pixel[1440][2560];
glPixelStorei(GL_PACK_ALIGNMENT,1);
printf(&#34;---------1-------\n&#34;);
glReadPixels(0, 0, 1440, 50,GL_RGBA, GL_UNSIGNED_BYTE,pixel );
dump_picture(&#34;simple-egl&#34;,pixel,1440,50);
2.dump buffer到本地
void dump_picture(char *name,const void *ptr,int w,inth)
{
int fd= -1;
staticint dumpcnt = 1000;
charfilename[1024];
intp_size = 0;
intret_w = 0;
sprintf(filename, &#34;/tmp/dumpfiles/cts-%s-%d_%dx%d-%d&#34;,name,getpid(), w, h, dumpcnt);
fd =open(filename, O_WRONLY|O_CREAT|O_APPEND, 0777);
printf(&#34;------%s:[%s] dumpidx=%d, fd=%d,w,h=(%d,%d)\n&#34;, name,__func__,dumpcnt, fd,w,h);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/919b519649d2f32fb5073772cfa70042/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-07-03T16:57:22+08:00" />
<meta property="article:modified_time" content="2017-07-03T16:57:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">glReadPixels读取buffer并转换成BMP图片</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3> </h3><p><strong>1.glReadPixels</strong></p> <p><span style="font-size:14px">glReadPixels(GLint x,GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid*pixels)</span></p> <p><span style="font-size:14px">glReadPixels 是将GPU渲染完数据，从GPU回传到host端的唯一方式，由入参（x,y,w,h）制定一个从一帧图像中读取内存的矩形，type和format指定格式，pixels是输出像素的buffer</span></p> <p><span style="font-size:14px">注意：<strong><span style="background-color:rgb(255,255,102)">glReadPixels</span></strong>实际上是从缓冲区中读取数据，如果使用了双缓冲区，则默认是从正在显示的缓冲（即前缓冲）中读取，而绘制工作是默认绘制到后缓冲区的。因此，如果需要读取已经绘制好的像素，往往需要先交换前后缓冲</span></p> <p>     <span style="color:#999999"> <span style="font-size:12px">int *pixel = (int*)malloc(sizeof(int)*1440*2560);<br>           memset(pixel,0,sizeof(int)*1440*2560);<br>           //int pixel[1440][2560];<br>           glPixelStorei(GL_PACK_ALIGNMENT,1);<br>           printf("---------1-------\n");<br>           glReadPixels(0, 0, 1440, 50,GL_RGBA, GL_UNSIGNED_BYTE,pixel );<br>           dump_picture("simple-egl",pixel,1440,50);</span></span></p> <p><strong>2.dump buffer到本地</strong></p> <p><span style="font-size:12px"><span style="color:#666666">void dump_picture(char *name,const void *ptr,int w,inth)<br> {<!-- --><br>          int fd= -1;<br>          staticint dumpcnt = 1000;<br>          charfilename[1024];<br>          intp_size = 0;<br>          intret_w = 0;<br>         sprintf(filename, "/tmp/dumpfiles/cts-%s-%d_%dx%d-%d",name,getpid(), w, h, dumpcnt);<br>          fd =open(filename, O_WRONLY|O_CREAT|O_APPEND, 0777);<br>         printf("------%s:[%s] dumpidx=%d, fd=%d,w,h=(%d,%d)\n", name,__func__,dumpcnt, fd,w,h);<br>          p_size= 4 * w * h;<br>          while(ret_w = write(fd,ptr , p_size))<br>          {<!-- --><br>                 if (ret_w == -1)<br>                 {<!-- --><br>                              printf("ret_w=-1,error\n");<br>                              break;<br>                 }<br>                 else if (ret_w == p_size)<br>                 {<!-- --><br>                              break;<br>                 }<br>                 else if (ret_w &gt; 0)<br>                 {<!-- --><br>                              ptr += ret_w;<br>                              p_size -= ret_w;<br>                 }<br>          }<br>         close(fd);<br>         dumpcnt++;<br> }</span><br> </span></p> <p>3.将原始数据转换成BMP图片</p> <p><span style="font-size:14px">BMP文件是一种像素文件，它保存了一幅图象中所有的像素。这种文件格式可以保存单色位图、16色或256色索引模式像素图、24位真彩色图象，每种模式种单一像素的大小分别为1/8字节，1/2字节，1字节和3字节。目前最常见的是256色BMP和24位色BMP。这种文件格式还定义了像素保存的几种方法，包括不压缩、RLE压缩等。常见的BMP文件大多是不压缩的。Windows所使用的BMP文件，在开始处有一个文件头，大小为54字节。保存了包括文件格式标识、颜色数、图象大小、压缩方式等信息。</span></p> <p><span style="font-size:12px"><span style="color:#999999">#include &lt;unistd.h&gt;<br> #include &lt;fcntl.h&gt;<br> #include &lt;stdio.h&gt;<br> #include &lt;stdlib.h&gt;<br> int bmp_write(unsigned char *image, int xsize, intysize, char *filename)<br> {<!-- --><br>     unsignedchar header[54] = {0x42, 0x4d, 0, 0, 0, 0, 0, 0, 0, 0,<br>                                 54, 0, 0, 0,40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 32, 0,<br>                                 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br>                                 0, 0, 0, 0<br>     };<br>     longfile_size = (long)xsize * (long)ysize * 4+ 54;<br>     header[2] =(unsigned char)(file_size &amp;0x000000ff);<br>     header[3] = (file_size &gt;&gt; 8) &amp;0x000000ff;<br>     header[4] =(file_size &gt;&gt; 16) &amp; 0x000000ff;<br>     header[5] =(file_size &gt;&gt; 24) &amp; 0x000000ff;<br>     long width =xsize;<br>     header[18] =width &amp; 0x000000ff;<br>     header[19] =(width &gt;&gt; 8) &amp;0x000000ff;<br>     header[20] =(width &gt;&gt; 16) &amp;0x000000ff;<br>     header[21] =(width &gt;&gt; 24) &amp;0x000000ff;<br>     long height= ysize;<br>     header[22] =height &amp;0x000000ff;<br>     header[23] =(height &gt;&gt; 8) &amp;0x000000ff;<br>     header[24] =(height &gt;&gt; 16) &amp;0x000000ff;<br>     header[25] =(height &gt;&gt; 24) &amp;0x000000ff;<br>     charfname_bmp[128];<br>    sprintf(fname_bmp, "%s.bmp", filename);<br>  <br>     FILE *fp;<br>     if (!(fp =fopen(fname_bmp, "wb")))<br>       return -1;<br>    fwrite(header, sizeof(unsigned char), 54, fp);<br>    fwrite(image, sizeof(unsigned char), (size_t)(long)xsize * ysize * 4,fp);<br>     fclose(fp);<br>     return 0;<br> }<br> int main(int argc, char** argv)<br> {<!-- --><br> printf("\nusage: source filename,width,height,picture name \n");<br>  <br>         intbReverse = 1;<br>         int width  = atoi(argv[2]);<br>         intheight = atoi(argv[3]);<br>        printf("width:%d height:%d\n",width,height);<br> #if 1<br>         FILE*fp;<br>     if (!(fp =fopen(argv[1], "rb")))<br>       return -1;<br>         unsignedchar * buff = (unsigned char *)malloc(width*height*4);<br>        memset(buff,0,width*height*4);<br>         size_tcount = fread(buff,width*height*4,1,fp);<br>        if(bReverse)<br>         {<!-- --><br>                unsigned char * tmp = (unsigned char *)malloc(width*height*4);<br>                memset(tmp,0,width*height*4);<br>                int i=0;<br>                for(;i&lt;height;++i)<br>                {<!-- --><br>                        memcpy(tmp+(height-1-i)*width*4,buff+width*i*4,width*4);<br>                }<br>                bmp_write(tmp,width,height,argv[4]);<br>                free(tmp);<br>         }<br>         else<br>                bmp_write(buff,width,height,argv[4]);<br>        fclose(fp);<br>        free(buff);<br> #endif<br> }</span><br> </span></p> <p><span style="font-size:12px">用法：../rawToBmp32bppclient-11217_250x250-1010 250 250 cl1</span></p> <br> 
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d67dd7950925fda8c34b3e82a2d88be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python  numpy  提取矩阵的某一行或某一列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/497b948f82d09a33c866861a009ac372/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux环境下生成文件，文件名称中文乱码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>