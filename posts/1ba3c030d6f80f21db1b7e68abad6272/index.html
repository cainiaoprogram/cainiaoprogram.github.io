<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>虚拟化&#43;docker概念基本介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="虚拟化&#43;docker概念基本介绍" />
<meta property="og:description" content="目录
容器技术产生的背景
虚拟化
虚拟化概述
总结（虚拟化的作用）：
cpu的时间分片（cpu虚拟化）
CPU虚拟化瓶颈
虚拟化工作原理
虚拟化类型
虚拟化的优缺点
优势
劣势
Docker
什么是docker
使用docker的意义
docker的使用场景
docker引擎（Docker Engine）
docker三要素
六大名称空间
资源控制——cgroups
容器特性
容器小的架构体系
Docker和虚拟化的区别
问：dovker 和VM 解决了虚拟机的什么问题？
Docker有哪些优势？和虚拟化比有什么优势？
总结
什么是docker？docker原理？
简述Docker主要使用的技术？
简述Docker体系架构
如何把多个目录挂载到同一个目录下？
前言：
Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。
容器技术产生的背景 以linux而言，linux操作系统会有一个主进程pid=1派生出其他进程来控制不同服务例如: pid=2 ——&gt; python pid=3——&gt;java pid4——&gt;php，三个服务可能会相互影响使用者期望将这三个不同的服务，跑在不同的运行时环境中实现相互不影响，同时不会增加服务器成本——&gt; 延伸出——&gt;能否将这三种服务分别封装起来——&gt;KVM虚拟化技术，实现了一个操作系统模拟多个操作系统/不同的运行时环境随着技术发展——&gt;虚拟化技术开销较大(例如:只 要运行一个py脚本，想要使用虚拟化方式实现，还需要安装一个操作系统，并不方便/合理)——&gt;延伸出容器技术 虚拟化层的抽象层(用户层)剥离，使用docker engine来替代(来宾操作系统去除)，只要通过引擎就可以直接连接到宿主机操作系统中，极大减小了开销
docker引擎对内核版本是有要求的(至少是3.8&#43;)
docker 需要cgroups(Linux内核态中资源管理的模块） 的资源管理功能
虚拟化 虚拟化概述 通过虚拟化技术将一台计算机虚拟为多台逻辑计算机，在一台计算机上同时运行多个逻辑计算机,同时每个逻辑计算机可运行不同的操作系统。应用程序都可以在相互独立的空间内运行而互相不影响，从而提高计算机的工作效率。
在一个操作系统中(win10)模拟多个操作系统(centos、win10、suse)，同时每个操作系统可以跑不同的服务(ngintx/tomcat)，从而实现一台宿主机搭建一个集群(从整体)通过软件/应用程序的方式,来实现物理硬件的功能（ensp） 以软件形式实现物理设备的功能(二层交换机、路由器、三层交换机等)
总结（虚拟化的作用）： 虚拟化将应用程序和系统内核资源进行解耦，以操作系统级别进行隔离，目的是提高资源利用率
cpu的时间分片（cpu虚拟化） 正常每个任务以轮询的方式去处理，这个时候一个CPU一个整体。以下是针对的CPU单位时间内的一个资源。按时间划分，1秒划分成10个0.1秒，每个0.1秒可以全力处理10单位的任务。在1秒内，都在全力工作。cpu 1s全力运转的性能——》逻辑分割成分成了10份，可以理解为在单位时间内可以处理10个任务，每一个0.1s cpu是满的。原先分片前100M以下的任务一次只可以处理1个，现在100M的任务一次可以处理10个。这就是时间分片的一个概念。虚拟化作用——》缓解/解决了资源利用率的问题（总结） CPU虚拟化瓶颈 cpu分片后每个任务处理性能会打对折
如果是50m及50m以下的任务的话，虚拟化后的，1s模拟10个cpu，可以处理10个。虚拟化后的性能更高。如果是50&#43;m的任务的话，物理硬件的性能就会比虚拟化的性能高了。虚拟化的cpu会卡顿。所以在极度吃资源的情况下，例如mysql高并发这种，就不适合用虚拟化。 虚拟化工作原理 虚拟机管理器功能：调用资源
两大核心组件：QEMU、KVM" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1ba3c030d6f80f21db1b7e68abad6272/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-28T10:22:04+08:00" />
<meta property="article:modified_time" content="2022-07-28T10:22:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">虚拟化&#43;docker概念基本介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E4%BA%A7%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E4%BA%A7%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF" rel="nofollow">容器技术产生的背景</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%99%9A%E6%8B%9F%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E8%99%9A%E6%8B%9F%E5%8C%96" rel="nofollow">虚拟化</a></p> 
<p id="2.1%C2%A0%C2%A0%E8%99%9A%E6%8B%9F%E5%8C%96%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#2.1%C2%A0%C2%A0%E8%99%9A%E6%8B%9F%E5%8C%96%E6%A6%82%E8%BF%B0" rel="nofollow">虚拟化概述</a></p> 
<p id="%E6%80%BB%E7%BB%93%EF%BC%88%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%80%BB%E7%BB%93%EF%BC%88%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%89%EF%BC%9A" rel="nofollow">总结（虚拟化的作用）：</a></p> 
<p id="2.2%C2%A0%C2%A0cpu%E7%9A%84%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87%EF%BC%88cpu%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%C2%A0cpu%E7%9A%84%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87%EF%BC%88cpu%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%89" rel="nofollow">  cpu的时间分片（cpu虚拟化）</a></p> 
<p id="2.3%C2%A0%C2%A0CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E7%93%B6%E9%A2%88-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%C2%A0CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E7%93%B6%E9%A2%88" rel="nofollow">  CPU虚拟化瓶颈</a></p> 
<p id="1.4.%E8%99%9A%E6%8B%9F%E5%8C%96%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#1.4.%E8%99%9A%E6%8B%9F%E5%8C%96%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">虚拟化工作原理</a></p> 
<p id="2.6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#2.6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%B1%BB%E5%9E%8B" rel="nofollow">虚拟化类型</a></p> 
<p id="2.7%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.7%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">虚拟化的优缺点</a></p> 
<p id="%E4%BC%98%E5%8A%BF-toc" style="margin-left:80px;"><a href="#%E4%BC%98%E5%8A%BF" rel="nofollow">优势</a></p> 
<p id="%E5%8A%A3%E5%8A%BF-toc" style="margin-left:80px;"><a href="#%E5%8A%A3%E5%8A%BF" rel="nofollow">劣势</a></p> 
<p id="%E4%B8%89%EF%BC%9ADocker-toc" style="margin-left:0px;"><a href="#%E4%B8%89%EF%BC%9ADocker" rel="nofollow">Docker</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AFdocker-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFdocker" rel="nofollow">什么是docker</a></p> 
<p id="3.2%E4%BD%BF%E7%94%A8docker%E7%9A%84%E6%84%8F%E4%B9%89-toc" style="margin-left:40px;"><a href="#3.2%E4%BD%BF%E7%94%A8docker%E7%9A%84%E6%84%8F%E4%B9%89" rel="nofollow">使用docker的意义</a></p> 
<p id="3.3docker%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#3.3docker%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">docker的使用场景</a></p> 
<p id="%C2%A03.4docker%E5%BC%95%E6%93%8E%EF%BC%88Docker%20Engine%EF%BC%89-toc" style="margin-left:40px;"><a href="#%C2%A03.4docker%E5%BC%95%E6%93%8E%EF%BC%88Docker%20Engine%EF%BC%89" rel="nofollow">docker引擎（Docker Engine）</a></p> 
<p id="3.5docker%E4%B8%89%E8%A6%81%E7%B4%A0-toc" style="margin-left:40px;"><a href="#3.5docker%E4%B8%89%E8%A6%81%E7%B4%A0" rel="nofollow">docker三要素</a></p> 
<p id="3.6%E5%85%AD%E5%A4%A7%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4-toc" style="margin-left:40px;"><a href="#3.6%E5%85%AD%E5%A4%A7%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4" rel="nofollow">六大名称空间</a></p> 
<p id="3.7%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94cgroups-toc" style="margin-left:40px;"><a href="#3.7%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94cgroups" rel="nofollow">资源控制——cgroups</a></p> 
<p id="3.8%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#3.8%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7" rel="nofollow">容器特性</a></p> 
<p id="3.9%E5%AE%B9%E5%99%A8%E5%B0%8F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB-toc" style="margin-left:40px;"><a href="#3.9%E5%AE%B9%E5%99%A8%E5%B0%8F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB" rel="nofollow">容器小的架构体系</a></p> 
<p id="%E5%9B%9B%EF%BC%9ADocker%E5%92%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%EF%BC%9ADocker%E5%92%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">Docker和虚拟化的区别</a></p> 
<p id="%E9%97%AE%EF%BC%9Adovker%20%E5%92%8CVM%20%E8%A7%A3%E5%86%B3%E4%BA%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E9%97%AE%EF%BC%9Adovker%20%E5%92%8CVM%20%E8%A7%A3%E5%86%B3%E4%BA%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F" rel="nofollow">问：dovker 和VM 解决了虚拟机的什么问题？</a></p> 
<p id="%E4%BA%94%EF%BC%9ADocker%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F%E5%92%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BA%94%EF%BC%9ADocker%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F%E5%92%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F" rel="nofollow">Docker有哪些优势？和虚拟化比有什么优势？</a></p> 
<p id="%E5%85%AD%EF%BC%9A%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%85%AD%EF%BC%9A%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<p id="6.1%E4%BB%80%E4%B9%88%E6%98%AFdocker%EF%BC%9Fdocker%E5%8E%9F%E7%90%86%EF%BC%9F-toc" style="margin-left:40px;"><a href="#6.1%E4%BB%80%E4%B9%88%E6%98%AFdocker%EF%BC%9Fdocker%E5%8E%9F%E7%90%86%EF%BC%9F" rel="nofollow">什么是docker？docker原理？</a></p> 
<p id="6.2%E7%AE%80%E8%BF%B0Docker%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%9F-toc" style="margin-left:40px;"><a href="#6.2%E7%AE%80%E8%BF%B0Docker%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%9F" rel="nofollow">简述Docker主要使用的技术？</a></p> 
<p id="6.3%E7%AE%80%E8%BF%B0Docker%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-toc" style="margin-left:40px;"><a href="#6.3%E7%AE%80%E8%BF%B0Docker%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84" rel="nofollow">简述Docker体系架构</a></p> 
<p id="%E5%A6%82%E4%BD%95%E6%8A%8A%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%A6%82%E4%BD%95%E6%8A%8A%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%9F" rel="nofollow">如何把多个目录挂载到同一个目录下？</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><img alt="" height="377" src="https://images2.imgbox.com/b1/46/ehrJGFKx_o.png" width="1050"></p> 
<p> 前言：</p> 
<p><a href="https://so.csdn.net/so/search?q=Docker&amp;spm=1001.2101.3001.7020" title="Docker">Docker</a> 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 <a href="https://so.csdn.net/so/search?from=pc_blog_highlight&amp;q=Linux" title="Linux">Linux</a>或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p> 
<h2 id="%E4%B8%80%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E4%BA%A7%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF">容器技术产生的背景</h2> 
<ul><li>以linux而言，linux操作系统会有一个主进程pid=1派生出其他进程来控制不同服务</li><li>例如: pid=2 ——&gt; python pid=3——&gt;java pid4——&gt;php，三个服务可能会相互影响</li><li>使用者期望将这三个不同的服务，跑在不同的运行时环境中实现相互不影响，同时不会增加服务器成本</li><li>——&gt; 延伸出——&gt;能否将这三种服务分别封装起来——&gt;KVM虚拟化技术，实现了一个操作系统模拟多个操作系统/不同的运行时环境</li><li>随着技术发展——&gt;虚拟化技术开销较大(例如:只 要运行一个py脚本，想要使用虚拟化方式实现，还需要安装一个操作系统，并不方便/合理)</li><li>——&gt;延伸出容器技术</li></ul> 
<blockquote> 
 <p>虚拟化层的抽象层(用户层)剥离，使用<span style="background-color:#a2e043;">docker engine</span>来替代(来宾操作系统去除)，只要<span style="background-color:#ffd900;">通过引擎</span>就可以直接连接到宿主机操作系统中，<span style="color:#fe2c24;">极大减小了开销</span></p> 
</blockquote> 
<p> <a href="https://so.csdn.net/so/search?q=docker&amp;spm=1001.2101.3001.7020" title="docker">docker</a>引擎对内核版本是有要求的(至少是3.8+)</p> 
<p>docker 需要cgroups(Linux内核态中资源管理的模块） 的资源管理功能</p> 
<h2 id="%E4%BA%8C%E3%80%81%E8%99%9A%E6%8B%9F%E5%8C%96">虚拟化</h2> 
<h3 id="2.1%C2%A0%C2%A0%E8%99%9A%E6%8B%9F%E5%8C%96%E6%A6%82%E8%BF%B0">虚拟化概述</h3> 
<p>通过虚拟化技术将一台计算机虚拟为多台逻辑计算机，在一台计算机上同时运行多个逻辑计算机,同时每个逻辑计算机可运行不同的操作系统。应用程序都可以在相互独立的空间内运行而互相不影响，从而提高计算机的工作效率。</p> 
<ul><li>在一个操作系统中(win10)模拟多个操作系统(centos、win10、suse)，同时每个操作系统可以跑不同的服务(ngintx/tomcat)，从而实现一台宿主机搭建一个集群(从整体)</li><li>通过软件/应用程序的方式,来实现物理硬件的功能（ensp）</li></ul> 
<p>       以软件形式实现物理设备的功能(二层交换机、路由器、三层交换机等)</p> 
<h4 id="%E6%80%BB%E7%BB%93%EF%BC%88%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%89%EF%BC%9A"><strong>总结（虚拟化的作用）：</strong></h4> 
<p><strong>虚拟化将应用程序和系统内核资源进行解耦，以操作系统级别进行隔离，目的是提高资源利用率</strong></p> 
<p></p> 
<h3 id="2.2%C2%A0%C2%A0cpu%E7%9A%84%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87%EF%BC%88cpu%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%89">  cpu的时间分片（cpu虚拟化）</h3> 
<p><img alt="" height="569" src="https://images2.imgbox.com/99/78/NUTsluqn_o.png" width="1200"></p> 
<ul><li>正常每个任务以轮询的方式去处理，这个时候一个CPU一个整体。</li><li>以下是针对的CPU单位时间内的一个资源。按时间划分，1秒划分成10个0.1秒，每个0.1秒可以全力处理10单位的任务。在1秒内，都在全力工作。</li><li>cpu 1s全力运转的性能——》逻辑分割成分成了10份，可以理解为在单位时间内可以处理10个任务，每一个0.1s cpu是满的。原先分片前100M以下的任务一次只可以处理1个，现在100M的任务一次可以处理10个。这就是时间分片的一个概念。</li><li><strong>虚拟化作用——》缓解/解决了资源利用率的问题（总结）</strong></li></ul> 
<h3 id="2.3%C2%A0%C2%A0CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E7%93%B6%E9%A2%88">  CPU虚拟化瓶颈</h3> 
<p><img alt="" height="639" src="https://images2.imgbox.com/1c/9f/GEnk6Oe7_o.png" width="1200"></p> 
<p>  <strong>cpu分片后每个任务处理性能会打对折</strong></p> 
<ul><li><strong>如果是50m及50m以下的任务的话</strong>，虚拟化后的，1s模拟10个cpu，可以处理10个。虚拟化后的性能更高。</li><li><strong>如果是50+m的任务的话</strong>，物理硬件的性能就会比虚拟化的性能高了。虚拟化的cpu会卡顿。<strong>所以在极度吃资源的情况下，例如mysql高并发这种，就不适合用虚拟化</strong>。</li></ul> 
<h3 id="1.4.%E8%99%9A%E6%8B%9F%E5%8C%96%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">虚拟化工作原理</h3> 
<p><img alt="" height="619" src="https://images2.imgbox.com/da/b1/DdOYAMBX_o.png" width="1200"></p> 
<p> <strong>虚拟机管理器功能：调用资源</strong></p> 
<p><strong>两大核心组件：QEMU、KVM</strong></p> 
<p><strong><span style="background-color:#ffd900;">QEMU：</span></strong></p> 
<p>1、可以理解为队列，核心目的是**调用资源内核中的资源**，需要把KVM逻辑分割出来的资源运输给QEMU，再给虚拟机。</p> 
<p>2、QEMU它并不是直接调用，而是用I/O方式调用，QEMU把资源调用来的过程借用ioctl，QEMU借助libvirt这个工具调用ioctl，再通过接口，给虚拟机应用程序。</p> 
<p><strong><span style="background-color:#ffd900;">KVM：</span></strong></p> 
<p>1、用来逻辑分割物理资源，抽象化为虚拟化资源，根据KVM里的配置，会逻辑分割出多少G，给应用程序，去进行虚拟化。</p> 
<p>2、只接受来自QEMU的请求指令。对于应用程序直接过来的敏感指令会拦截，然后通过接口发给QEMU，让QEMU判断是否需要执行，可以的话，再下来，不可以的话，打回去，不执行该敏感指令。</p> 
<p><strong>对于workstation而言——》硬件辅助虚拟化，</strong>表现形式在处理器里面有一个虚拟化引擎，可以勾取硬件辅助虚拟化，看到虚拟接口/dev/kvm，可以加强辅助调用，在应用程序需要频繁调用的时候，需要开启。比如openstack。</p> 
<h3 id="2.6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%B1%BB%E5%9E%8B">虚拟化类型</h3> 
<p><strong>全虚拟化：</strong>将物理硬件资源全部通过软件的方式抽象化，最后进行调用</p> 
<p><strong>半虚拟化：</strong>需要修改操作系统</p> 
<p><strong>直通：</strong>直接使用物理硬件资源</p> 
<p><img alt="" height="765" src="https://images2.imgbox.com/3c/90/wYNOevNm_o.png" width="1200"></p> 
<p></p> 
<p>全虚拟化：基于硬件为基础以软件的形式模拟硬件设备(在一定程度上解决了性能利用率的问题）</p> 
<p>半虚拟化：趋近于物理设备的性能 （在提高利用率的同时，尽可能的提高性能）</p> 
<p>全虚拟化：KVM——产品 vmware（资源损耗大）</p> 
<p>半虚拟化：EXSI——产品 workstation vsphere</p> 
<p><strong>虚拟化功能</strong></p> 
<p>①在一个操作系统内，模拟多个操作系统</p> 
<p>② 以软件的方式模拟物理设备的功能</p> 
<h3 id="2.7%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">虚拟化的优缺点</h3> 
<h4 id="%E4%BC%98%E5%8A%BF">优势</h4> 
<p>①集中化管理（远程管理、维护)</p> 
<p>②提高硬件利用率（物理资源利用率低-例如峰值，虚拟化解决了"空闲"容量)</p> 
<p>③动态调整机器/资源配置（虚拟化把系统的应用程序和服务硬件分离、提高了灵活性)</p> 
<p>④高可靠（可部署额外的功能和方案，可提高透明负载均衡、迁移、恢复复制等应用环境)</p> 
<h4 id="%E5%8A%A3%E5%8A%BF">劣势</h4> 
<p>①前期高额费用(初期的硬件支持)</p> 
<p>②降低硬件利用率（特定场景-例如极度吃资源的应用不一定适合虚拟化)</p> 
<p>③更大的错误影响面（本地物理机down机会导致虚拟机均不可用，同时可能虚拟机中文件全部损坏)</p> 
<p>④实施配置复杂、管理复杂（(管理人员运维、排障困难)</p> 
<p>⑤一定的限制性（虚拟化技术涉及各种限制，必须与支持/兼容虚拟化的服务器、应用程序及供应商结合使用)</p> 
<p>⑥安全性（虚拟化技术自身的安全隐患）<br>  </p> 
<h2 id="%E4%B8%89%EF%BC%9ADocker">Docker</h2> 
<p>容器基础概念—》六大名称空间      名称空间：<strong>以不同空间划分不同资源</strong></p> 
<p></p> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AFdocker">什么是docker</h3> 
<p>是<strong>一种轻量级的“虚拟机”</strong>，Docker是一个用于开发，交付和运行应用程序的开放平台。</p> 
<p>在Linux容器里运行应用的开源工具——》<strong>容器引擎</strong>，让开发者可以打包大门的应用及依赖包到一个可移植的镜像中，然后发布到任何流行的linux或者window机器中。</p> 
<p>Docker的Logo设计为蓝色鲸鱼，拖着许多集装箱。<br><strong>鲸鱼可看作为宿主机，集装箱可理解为相互隔离的容器，每个集装箱中都包含自己的应用程序。</strong></p> 
<p>Docker的设计宗旨：<strong>Build,Ship and Run Any App,Anywhere</strong><br> 即通过对应用组件的封装、发布、部署、运行等生命周期的管理，达到应用组件级别的“<strong>一次封装，到处运行</strong>”的目的。这里的组件，既可以是一个应用，也可以是一套服务，甚至是一个完整的操作系统。</p> 
<pre><code class="language-vbscript">沙箱(Sandbox)：在计算机安全领域，沙箱是一种程序的隔离运行机制
Docker在2013年一炮而红，直到现在，已经成为容器技术的代名词。
Docker从一开始就以提供标准化的运行时环境为目标，真正做到“build once, run anywhere即构建一次能在所有地方运行”，可以将同一个构建版本用于开发、测试、预发布、生产等任何环境，并且做到了与底层操作系统的解耦。在此基础上还进一步发展出了CaaS（容器即服务）技术。
</code></pre> 
<h3 id="3.2%E4%BD%BF%E7%94%A8docker%E7%9A%84%E6%84%8F%E4%B9%89">使用docker的意义</h3> 
<p><img alt="" height="677" src="https://images2.imgbox.com/55/38/MEzVM4GL_o.png" width="668"></p> 
<p>  <strong>把容器化技术做成了标准化平台</strong></p> 
<ol><li>docker引擎统一了<strong>基础设施环境——docker环境</strong></li><li>docker引擎统一了<strong>程序打包（装箱)方式——docker镜像</strong>（把引擎放在镜像中，带着镜像到处跑）</li><li>docker引擎统一了<strong>程序部署（运行）方式——docke容器</strong>（利用引擎把这个镜像再去运行为之前的相同的一模一样的容器了）</li></ol> 
<p><span style="color:#fe2c24;"><strong>镜像——》封装的一个时刻的服务/应用状态</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>容器——》应用跑起来的状态（正常提供服务的状态 - 运行时）</strong></span></p> 
<p></p> 
<h3 id="3.3docker%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">docker的使用场景</h3> 
<p>（1）打包应用程序部署简单</p> 
<p>（2）可脱离底层硬件任意迁移（实现了应用的隔离，将应用拆分并进行解耦）例如：需要把服务器从腾讯云迁移到阿里云，如果采用的是 Docker 容器技术，整个迁移的过程只需要在新的服务器上启动我们需要的容器就可以了。</p> 
<p>（3）适合做微服务的部署</p> 
<p>（4）适合持续集成和持续交付（CI/CD）:开发到测试发布</p> 
<pre><code>CI/CD流程：war jar —》github gitlab 私有仓库（代码仓库)—》
jenkins（测试(应用程序封装/构建镜像）—》运维下载，使用容器技术进行运行/发布</code></pre> 
<p>（5）提供PASS产品（平台即服务）</p> 
<p><img alt="" height="736" src="https://images2.imgbox.com/61/e6/5j4A7cAO_o.png" width="1200"></p> 
<p> <img alt="" height="477" src="https://images2.imgbox.com/80/cf/ckeEi3kf_o.png" width="1200"></p> 
<p></p> 
<h3 id="%C2%A03.4docker%E5%BC%95%E6%93%8E%EF%BC%88Docker%20Engine%EF%BC%89">docker引擎（Docker Engine）</h3> 
<p><img alt="" height="508" src="https://images2.imgbox.com/c5/26/n3XtRQ8F_o.png" width="681"></p> 
<p></p> 
<p>Docker Engine是具有以下主要组件的<strong><span style="background-color:#ffd900;">客户端-服务器（C/S架构）</span></strong>应用程序:</p> 
<p><strong>server端：</strong>服务器是一种长期运行的程序，称为守护程序进程( dockerd命令）。</p> 
<p><strong>client端：</strong>REST API，它指定程序可以用来与守护程序进行通信并指示其操作的接口。</p> 
<p>命令行界面(cLI）客户端（(docker命令）</p> 
<p>docker run</p> 
<p>docker start</p> 
<p>docker rm</p> 
<h3 id="3.5docker%E4%B8%89%E8%A6%81%E7%B4%A0">docker三要素</h3> 
<p><strong><span style="background-color:#fbd4d0;">Docker images:镜像</span></strong><span style="background-color:#fbd4d0;">：</span><strong><span style="background-color:#fef2f0;">统一的封装方式——》模板</span></strong></p> 
<p><strong><span style="background-color:#fbd4d0;">Docker container:容器：</span><span style="background-color:#fef2f0;">统一的运行时环境 ——》基于镜像，运行状态/运行时状态</span></strong></p> 
<p><strong><span style="background-color:#fbd4d0;">Docker registry:镜像仓库：</span><span style="background-color:#fef2f0;">放置镜像的仓库——》存放镜像模板</span></strong></p> 
<p>存储镜像的地方，默认在公共的 Docker Hub上查找，可以搞个人仓库。</p> 
<p></p> 
<p>仓库大类：<strong>①公共仓库—》docker hub ②私有仓库registry harbor</strong></p> 
<pre><code>docker三要素
镜像——》模板
容器——》基于镜像,运行状态/运行时状态
仓库——》存放镜像模板</code></pre> 
<p><img alt="" height="786" src="https://images2.imgbox.com/a2/d8/S7IFtgJV_o.png" width="1200"></p> 
<p></p> 
<p><strong>客户端</strong>发起各种各样的命令，给与<strong>主机</strong></p> 
<p>主机会<strong>调用镜像，</strong>如果有镜像直接用，运行为<strong>容器</strong></p> 
<p>如果镜像里没有会到公<span style="color:#fe2c24;">registry共仓库</span>去拉去镜像，<strong>拉到本地后再运行为容器</strong></p> 
<h3 id="3.6%E5%85%AD%E5%A4%A7%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4">六大名称空间</h3> 
<pre><code>namespace资源隔离——用容器技术封装 </code></pre> 
<p><img alt="" height="623" src="https://images2.imgbox.com/b1/67/ItLqg9H5_o.png" width="1171"></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>mount</td><td>文件系统，挂载点——&gt;一个文件系统内，不能重复挂载一个指定目录</td></tr><tr><td>user</td><td>操作进程的用户和用户组</td></tr><tr><td>pid</td><td>进程编号</td></tr><tr><td>uts</td><td>主机名和主机域 （同一个环境里不能又叫node1又叫node2）</td></tr><tr><td>ipc</td><td>信号量、消息队列、共享内存(不同的应用调用内存资源的时候应该使用不同的内存空间)</td></tr><tr><td>net（网络资源）</td><td> <p>网络设备、网络协议栈（在同一个网络名称空间中的网络规则）、端口等</p> </td></tr></tbody></table> 
<p>    </p> 
<h3 id="3.7%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94cgroups">资源控制——cgroups</h3> 
<p><strong><span style="background-color:#fbd4d0;">六种名称空间是由cgroups管理的</span></strong></p> 
<p>最后一种centos的cgroups管理版本是3.8版本，3.6和3.5用不了</p> 
<p>cgroups 管理linux内核态中资源管理的模块</p> 
<p>cgroups 管理一些系统资源</p> 
<p>不是docker原生的</p> 
<h3 id="3.8%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7">容器特性</h3> 
<p>特性——》性能损耗10-20%</p> 
<p><strong>灵活：</strong>即使是最复杂的应用也可以集装箱化。</p> 
<p><strong>轻量级</strong>：容器利用并共享主机内核。</p> 
<p><strong>可互换</strong>：可以即时部署更新和升级。</p> 
<p><strong>便携式</strong>：可以在本地构建，部署到云，并在任何地方运行。</p> 
<p><strong>可扩展</strong>：可以增加并自动分发容器副本。</p> 
<p><strong>可堆叠</strong>：可以垂直和即时堆叠服务。</p> 
<h3 id="3.9%E5%AE%B9%E5%99%A8%E5%B0%8F%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB">容器小的架构体系</h3> 
<p><img alt="" height="617" src="https://images2.imgbox.com/4a/ef/oW3d1klG_o.png" width="1200"></p> 
<h2 id="%E5%9B%9B%EF%BC%9ADocker%E5%92%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB">Docker和虚拟化的区别</h2> 
<p><img alt="" height="401" src="https://images2.imgbox.com/a0/6b/Bpf6NS84_o.png" width="677"></p> 
<p> </p> 
<pre><code>容器是依赖于内核来隔离，彼此的关系像共享一样，所以安全性较之虚拟机差一些，毕竟不是完全隔离。所以若一个容器被黑客攻破，宿主机基本也就没了。

这里也不是完全没有办法，那就是 cgroup 资源分配，其能提供一定的安全机制</code></pre> 
<h3 id="%E9%97%AE%EF%BC%9Adovker%20%E5%92%8CVM%20%E8%A7%A3%E5%86%B3%E4%BA%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><strong>问：dovker 和VM 解决了虚拟机的什么问题？</strong></h3> 
<p><strong>docker 解决了 vm 的 一个环境孤岛的问题</strong></p> 
<p><strong>docker 可以自定义传参（创建--创建镜像/容器、启动（基于镜像启动）之前</strong></p> 
<h2 id="%E4%BA%94%EF%BC%9ADocker%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F%E5%92%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F">Docker有哪些优势？和虚拟化比有什么优势？</h2> 
<p>docker把容器化技术做成了标准化平台，只要安装了docker引擎，就能使用docker。</p> 
<p><strong>使用docker有什么意义(实现了3个统一)</strong></p> 
<p>docker引擎统一了基础设施环境-docker环境——&gt;image——&gt;封装一一个简易的操作系统(3.0+G)</p> 
<p>docker引擎统一了 程序打包(装箱/封装-类比于集装箱)方式-docker镜像——&gt;images</p> 
<p>docker引擎统—了程序部署(运行)方式-docker容器——&gt;基于镜像——&gt;运行为容器(可运行的环境)</p> 
<p>实现了一次构建，多次、多处使用。</p> 
<h2 id="%E5%85%AD%EF%BC%9A%E6%80%BB%E7%BB%93"><strong>总结</strong></h2> 
<h3 id="6.1%E4%BB%80%E4%B9%88%E6%98%AFdocker%EF%BC%9Fdocker%E5%8E%9F%E7%90%86%EF%BC%9F">什么是docker？docker原理？<br>  </h3> 
<p>docker是一种封装和运行的开源平台，他统一了封装方式，统一了运行方式，开源平台指的是docker引擎，统一的封装方式指的是镜像，统一的运行方式指的是容器。</p> 
<p>cgroup资源控制与namespaces两者构成了docker底层原理</p> 
<p>docker是一种容器技术，把<strong>linux中的cgroups（资源管理）</strong>和<strong>namespace（名称空间</strong>）等容器底层技术进行完美封装，并抽象为用户创建和管理容器的便捷界面（命令行cli、api等），这种C/S架构</p> 
<h3 id="6.2%E7%AE%80%E8%BF%B0Docker%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%9F">简述Docker主要使用的技术？</h3> 
<p>Cgroups:资源控制，管理一些系统资源</p> 
<p><strong>Namespace：资源隔离（名称空间）</strong></p> 
<p>rootfs：文件系统隔离（使用内核提供的rootfs）</p> 
<p>容器引擎（用户态工具） :生命周期控制</p> 
<p>docker本质就是宿主机的一个进程, docker是通过namespace(命名空间)实现资源隔离，通过cgroup,实现资源限制，通过写时复制技术(copy-on-write)实现了高效的文件操作（类似虚拟机的磁盘比如分配500g并不是实际占用物理磁盘50og)<br>  </p> 
<p><strong>Namespace：资源隔离（名称空间）</strong></p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>mount</td><td>文件系统，挂载点——&gt;一个文件系统内，不能重复挂载一个指定目录</td></tr><tr><td>user</td><td>操作进程的用户和用户组</td></tr><tr><td>pid</td><td>进程编号</td></tr><tr><td>uts</td><td>主机名和主机域 （同一个环境里不能又叫node1又叫node2）</td></tr><tr><td>ipc</td><td>信号量、消息队列、共享内存(不同的应用调用内存资源的时候应该使用不同的内存空间)</td></tr><tr><td>net（网络资源）</td><td> <p>网络设备、网络协议栈（在同一个网络名称空间中的网络规则）、端口等</p> </td></tr></tbody></table> 
<h3 id="6.3%E7%AE%80%E8%BF%B0Docker%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84">简述Docker体系架构</h3> 
<p><strong>Docker客户端 - Docker</strong></p> 
<p>docker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。</p> 
<p><strong>Docker服务端-Docker Daemon资源限制</strong></p> 
<p>docker服务端是一个服务进程，管理着所有的容器。</p> 
<p><strong>Docker镜像一Imagefont&gt;</strong></p> 
<p>Docker的镜像是创建容器的基础，类似虚拟机的快照，可以理解为一个面向Docker容器引擎的只读模板。通过镜像启动一个容器，一个镜像是一个可执行的包,其中包括运行应用程序所需要的所有内容包含代码。运行时间，库，环境变量，和配置文件</p> 
<p><strong>Docker容器-Docker Container</strong></p> 
<p>Docker的容器是从镜像创建的运行实例，它可以被启动、停止和删除。所创建的每一个容器都是相互隔离、互不可见，以保证平台的安全性。</p> 
<p><strong>Docker镜像仓库-- Registryfont&gt;</strong></p> 
<p>Docker仓库是用来集中保存镜像的地方,当创建了自己的镜像之后，可以使用push命令将它上传到公有仓库(Public)或者私有仓库(Private、常用）。当下次要在另外一台机器上使用这个镜像时，只需从仓库获取。</p> 
<p>Docker的镜像、容器、日志等内容全部都默认存储在<span style="color:#fbd4d0;"><strong><span style="background-color:#fe2c24;">  /var/lib/docker</span></strong></span><span style="color:#ed7976;"> </span> 目录下。</p> 
<h3 id="%E5%A6%82%E4%BD%95%E6%8A%8A%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%9F">如何把多个目录挂载到同一个目录下？</h3> 
<p>（存储引擎)<strong>overlay2</strong>（现在使用） 和 （存储引擎) <strong>aufs</strong>（早期使用）<strong>叠加式文件系统</strong></p> 
<p><img alt="" height="387" src="https://images2.imgbox.com/ba/b7/G0xlt9go_o.png" width="1030"></p> 
<p> </p> 
<p>docker引擎统—了程序部署(运行)方式-docker容器——&gt;基于镜像——&gt;运行为容器(可运行的环境)</p> 
<p><strong>实现了一次构建，多次、多处使用。</strong></p> 
<p><strong><span style="background-color:#efedf6;">你是屌丝</span></strong></p> 
<p><strong>拜拜</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2e36a6fe2338d8bf6d7d56c8127dabd6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ansible中常用的模块(上）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/104e28bcdecb2fbeb308e98857959bad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【百战GAN】StyleGAN人脸属性（表情年龄性别）编辑代码实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>