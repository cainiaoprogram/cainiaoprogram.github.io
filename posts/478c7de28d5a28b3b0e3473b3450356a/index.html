<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java关键字synchronized - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java关键字synchronized" />
<meta property="og:description" content="提纲 定义 synchronized是同步块，实现了多线程间的互斥同步。它修饰的代码，确保任一时刻只有一个线程进入访问。
特性 因为在synchronized同步块内，只有一个线程能访问，因此确保了同步块内的原子性、可见性和有序性。
使用方式 总结：
Class tClass = T.class; // T.class其实就是该类的类对象
synchronized不管是修饰代码块还是修饰方法，本质都是作用于对象上。进入代码块时需要获取对象锁，退出同步块是释放对象锁。
synchronized底层实现原理 Java对象锁的信息存在Java对象头里的mark word中。
synchronized不管是修饰代码块还是修饰方法，都能确定一个对象与之关联监视器。
对象监视器(ObjectMonitor)是在jdk中使用c&#43;&#43;实现的，具体细节需阅读对应源码。
synchronized vs ReentrantLock 总结：
在 &gt;=JDK1.6后， jvm对 synchronized关键字的锁做了很多优化，其性能和 ReentrantLock的Api式锁相差无几；不过新的api的锁支持3个高级特性。 ReentrantLock的底层实现是基于 AQS的； synchronized是 jvm基于字节码 monitorenter和 monitorexit加上一些锁优化实现的。 提高锁性能 减少锁持有时间 减小锁粒度 在JDK1.7中ConcurrentHashMap实用了分段锁来减小锁粒度（缩小锁对象的范围），从而降低锁冲突的可能性，进而提高系统的并发能力。
读写分离替换独占锁 在读多写少的场合使用读写锁可以有效提升系统的并发能力。
锁分离 锁分离是读写锁的进一步延伸，读写锁是根据读写操作上的不同，对锁进行了有效的分离。 在其他角度的分离思想，也可以对独占锁进行分离。 比如LinkedBlockingQueue的实现，其中take()和put()分别实现了从队列中获取数据和往队列中增加数据的功能，将独占锁分离为头锁和尾锁能提升take()和put()的并发能力。 锁优化 在&lt;=JDK1.5时，synchronized直接就是重量级锁，所以性能不好。在JDK1.6版本中，平台对这部分的锁性能做了很多优化，例如锁消除、锁粗化、偏向锁、自适应自旋、轻量级锁等优化。
锁消除 低于JDK1.5版本，编译器会将&#43;号连接字符串的代码优化为StringBuffer的连续append()操作；然后即时编译器会对代码做“逃逸分析”发现sb不会超出方法外，因此会将append方法内的同步完全消除掉执行，提高效率。
锁粗化 虚拟机在遇到一连串连续地对同一个锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这个操作叫做锁粗化。
偏向锁 优化思想： 如果一个线程获得了锁（通过CAS将当前线程指针记录到mark word中），那么锁就进入偏向模式，当该线程再次请求锁时，不需要做任何同步操作。
适用场景： 对于没有任何锁竞争的场合，偏向锁优化效果好。 在锁竞争激烈的场景，如果每次来请求锁的线程都是不同线程，那么偏向模式会失效。
JVM配置参数： -XX:&#43;UseBiasedLocking 开启偏向锁优化。 -XX:BiasedLockingStartupDelay=4 偏向锁延迟启动，默认4秒 。
轻量级锁 如果偏向锁失败，虚拟机会尝试轻量级锁的优化手段。
优化思想： 对于绝大部分的锁，在整个同步周期内都是不存在竞争的。（这是一个经验数据）
如果没有竞争，轻量级锁使用CAS操作避免使用互斥量的重量级锁开销。 单如果有竞争，CAS和互斥量开销都有，因此在有竞争的情况下，轻量级锁比重量级锁更慢。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/478c7de28d5a28b3b0e3473b3450356a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-11T16:07:46+08:00" />
<meta property="article:modified_time" content="2023-01-11T16:07:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java关键字synchronized</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <section id="nice" style="font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;"> 
 <h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">提纲</span><span class="suffix"></span></h3> 
 <figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"> 
  <img src="https://images2.imgbox.com/b7/4d/STpAOOfo_o.png" alt="alt" style="display: block; margin: 0 auto; max-width: 100%;"> 
 </figure> 
 <h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">定义</span><span class="suffix"></span></h3> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">synchronized</code>是同步块，实现了多线程间的互斥同步。它修饰的代码，确保任一时刻只有一个线程进入访问。</p> 
 <h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">特性</span><span class="suffix"></span></h3> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">因为在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">synchronized</code>同步块内，只有一个线程能访问，因此确保了同步块内的原子性、可见性和有序性。</p> 
 <h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">使用方式</span><span class="suffix"></span></h3> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><img src="https://images2.imgbox.com/24/5f/cHRvGJWj_o.png" alt="alt" style="display: block; margin: 0 auto; max-width: 100%;"> 总结：</p> 
 <pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://files.mdnice.com/user/3441/876cad08-0422-409d-bb5a-08afec5da8ee.svg); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;">Class tClass = T.class; // T.class其实就是该类的类对象<br></code></pre> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><em style="font-style: italic; color: black;"><strong style="font-weight: bold; color: black;">synchronized不管是修饰代码块还是修饰方法，本质都是作用于对象上。进入代码块时需要获取对象锁，退出同步块是释放对象锁。</strong></em></p> 
 <h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">synchronized底层实现原理</span><span class="suffix"></span></h3> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><img src="https://images2.imgbox.com/9e/8e/OGU5otdh_o.png" alt="alt" style="display: block; margin: 0 auto; max-width: 100%;"> Java对象锁的信息存在Java对象头里的mark word中。<br> synchronized不管是修饰代码块还是修饰方法，都能确定一个对象与之关联监视器。<br> 对象监视器(ObjectMonitor)是在jdk中使用c++实现的，具体细节需阅读对应源码。</p> 
 <h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">synchronized vs ReentrantLock</span><span class="suffix"></span></h3> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><img src="https://images2.imgbox.com/58/24/tYwaBaZM_o.png" alt="alt" style="display: block; margin: 0 auto; max-width: 100%;"> 总结：</p> 
 <ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><li> 
   <section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">
     在 
    <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">&gt;=JDK1.6</code>后， 
    <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">jvm</code>对 
    <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">synchronized</code>关键字的锁做了很多优化，其性能和 
    <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">ReentrantLock</code>的Api式锁相差无几；不过新的api的锁支持3个高级特性。 
   </section></li><li> 
   <section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"> 
    <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">ReentrantLock</code>的底层实现是基于 
    <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">AQS</code>的； 
    <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">synchronized</code>是 
    <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">jvm</code>基于字节码 
    <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">monitorenter</code>和 
    <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">monitorexit</code>加上一些锁优化实现的。 
   </section></li></ol> 
 <h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">提高锁性能</span><span class="suffix"></span></h3> 
 <h4 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">减少锁持有时间</span><span class="suffix" style="display: none;"></span></h4> 
 <figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"> 
  <img src="https://images2.imgbox.com/19/d8/6Q7BNUS3_o.png" alt="alt" style="display: block; margin: 0 auto; max-width: 100%;"> 
 </figure> 
 <h4 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">减小锁粒度</span><span class="suffix" style="display: none;"></span></h4> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">JDK1.7</code>中<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">ConcurrentHashMap</code>实用了分段锁来减小锁粒度（缩小锁对象的范围），从而降低锁冲突的可能性，进而提高系统的并发能力。</p> 
 <h4 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">读写分离替换独占锁</span><span class="suffix" style="display: none;"></span></h4> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">在读多写少的场合使用读写锁可以有效提升系统的并发能力。</p> 
 <h4 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">锁分离</span><span class="suffix" style="display: none;"></span></h4> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">锁分离是读写锁的进一步延伸，读写锁是根据读写操作上的不同，对锁进行了有效的分离。 在其他角度的分离思想，也可以对独占锁进行分离。 比如<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">LinkedBlockingQueue</code>的实现，其中<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">take()</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">put()</code>分别实现了从队列中获取数据和往队列中增加数据的功能，将独占锁分离为头锁和尾锁能提升<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">take()</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">put()</code>的并发能力。 <img src="https://images2.imgbox.com/2d/9d/AK6Vfzao_o.png" alt="alt" style="display: block; margin: 0 auto; max-width: 100%;"></p> 
 <h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">锁优化</span><span class="suffix"></span></h3> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">&lt;=JDK1.5</code>时，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">synchronized</code>直接就是重量级锁，所以性能不好。在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">JDK1.6</code>版本中，平台对这部分的锁性能做了很多优化，例如锁消除、锁粗化、偏向锁、自适应自旋、轻量级锁等优化。</p> 
 <h4 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">锁消除</span><span class="suffix" style="display: none;"></span></h4> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><img src="https://images2.imgbox.com/e2/4d/JTmxAOTc_o.png" alt="alt" style="display: block; margin: 0 auto; max-width: 100%;"> 低于JDK1.5版本，编译器会将+号连接字符串的代码优化为StringBuffer的连续append()操作；然后即时编译器会对代码做“逃逸分析”发现sb不会超出方法外，因此会将append方法内的同步完全消除掉执行，提高效率。</p> 
 <h4 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">锁粗化</span><span class="suffix" style="display: none;"></span></h4> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><img src="https://images2.imgbox.com/7c/6d/lZSBKMlQ_o.png" alt="alt" style="display: block; margin: 0 auto; max-width: 100%;"> 虚拟机在遇到一连串连续地对同一个锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这个操作叫做锁粗化。</p> 
 <h4 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">偏向锁</span><span class="suffix" style="display: none;"></span></h4> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">优化思想： 如果一个线程获得了锁（通过CAS将当前线程指针记录到mark word中），那么锁就进入偏向模式，当该线程再次请求锁时，不需要做任何同步操作。</p> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">适用场景： 对于没有任何锁竞争的场合，偏向锁优化效果好。 <em style="font-style: italic; color: black;"><strong style="font-weight: bold; color: black;">在锁竞争激烈的场景，如果每次来请求锁的线程都是不同线程，那么偏向模式会失效。</strong></em></p> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">JVM配置参数： -XX:+UseBiasedLocking 开启偏向锁优化。 -XX:BiasedLockingStartupDelay=4 偏向锁延迟启动，默认4秒 。</p> 
 <h4 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">轻量级锁</span><span class="suffix" style="display: none;"></span></h4> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果偏向锁失败，虚拟机会尝试轻量级锁的优化手段。</p> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">优化思想： <em style="font-style: italic; color: black;"><strong style="font-weight: bold; color: black;">对于绝大部分的锁，在整个同步周期内都是不存在竞争的。（这是一个经验数据）</strong></em></p> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果没有竞争，轻量级锁使用CAS操作避免使用互斥量的重量级锁开销。 单如果有竞争，CAS和互斥量开销都有，因此在有竞争的情况下，轻量级锁比重量级锁更慢。</p> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">实现： 在同步对象没有被锁定（锁标志位为01状态），虚拟机会在当前线程的栈中建立锁记录（Lock Record）的空间，然后通过CAS将对象的Mark Word对应位存储为锁记录的指针。如果成功，则说明获取轻量级锁成功，并更新该对象的Mark Word的锁标志位为00。</p> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果有2条以上线程争用同一个锁，则轻量级锁失效，会执行锁升级过程。</p> 
 <h4 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">自旋&amp;自适应自旋</span><span class="suffix" style="display: none;"></span></h4> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果轻量级锁失败，虚拟机还会做最后的尝试（自旋的优化）。</p> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">优化思想： 当前线程暂时无法获得锁，也许在几个CPU时钟周期后就可以获得锁。因此先不挂起线程，而是让线程做几个空循环后，如果获取到锁则进入临界区（还是轻量级锁状态）；如果还是没有获取到锁，就膨胀为重量级锁。</p> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">JVM配置参数： -XX:+UseSpinning 开启自旋锁，JDK1.4.2已经引入，默认关闭。在JDK1.6之后默认开启。 -XX:PreBlockSpin=10 自旋次数，默认10次。后面加入自适应自旋后该参数无效。</p> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">自适应自旋： 手动设置自旋次数其实是不合理的，所以程序会根据前一次在同一个锁上的自旋时间及锁的拥有者状态来决定。</p> 
 <ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li> 
   <section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">
     如果上一次刚刚成功通过自旋获取过锁，且持有锁的线程正在运行中，虚拟机会认为这次自旋也很有可能成功，进而允许更长时间的自旋等待。 
   </section></li><li> 
   <section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">
     如果对于某个锁，自旋很少成功过，则虚拟机会省略自旋获取锁的过程，避免浪费处理器资源。 
   </section></li></ul> 
 <h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">锁升级</span><span class="suffix"></span></h3> 
 <figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"> 
  <img src="https://images2.imgbox.com/eb/91/tI4NxBj6_o.png" alt="alt" style="display: block; margin: 0 auto; max-width: 100%;"> 
 </figure> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">详细流程如下图： <img src="https://images2.imgbox.com/f5/d5/cKYMJJao_o.png" alt="alt" style="display: block; margin: 0 auto; max-width: 100%;"></p> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">例子：</p> 
 <pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://files.mdnice.com/user/3441/876cad08-0422-409d-bb5a-08afec5da8ee.svg); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;">/**<br> * 锁升级测试 jdk版本=1.8<br> * -XX:+UseBiasedLocking 默认1.6之后就开启了偏向锁<br> * -XX:BiasedLockingStartupDelay=5  偏向锁启动延迟，单位秒，系统默认值是4<br> *<br> * 结论：<br> *  当不开启偏向锁时，能得到 001（无锁） -&gt; 000（轻量级锁） -&gt; 010（重量级锁）<br> *  开启偏向锁时，并设置延时5秒，new之后sleep 6秒，<span class="hljs-keyword" style="color: #a626a4; line-height: 26px;">for</span>循环内1个线程，则能得到 001(无锁） -&gt; 000（轻量级锁） -&gt; 101（偏向锁）<br> *  开启偏向锁时，并设置延时5秒，new之后sleep 6秒，<span class="hljs-keyword" style="color: #a626a4; line-height: 26px;">for</span>循环内2个线程及以上，则能得到 001（无锁） -&gt; 000（轻量级锁） -&gt; 010（重量级锁）<br> */<br>public class LockUpTest {<!-- --><br>    // 锁对象<br>    private static Object lock = new Object();<br><br>    public static void main(String[] args) throws InterruptedException {<!-- --><br><br>        // new状态 -- 001<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string" style="color: #50a14f; line-height: 26px;">" -- "</span> + ClassLayout.parseInstance(lock).toPrintable());<br>        Thread.sleep(6000);<br><br>        synchronized (lock){<!-- --><br>            // 轻量级锁 -- 000<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string" style="color: #50a14f; line-height: 26px;">" -- "</span> + ClassLayout.parseInstance(lock).toPrintable());<br>        }<br><br>        // 偏向锁 -- 101<br>        Object newLock = new Object();<br>        new Thread(()-&gt;{<!-- --><br>            synchronized (newLock) {<!-- --><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string" style="color: #50a14f; line-height: 26px;">" -- "</span> + ClassLayout.parseInstance(newLock).toPrintable());<br>            }<br>        }).start();<br><br>        // 重量级锁 -- 010（当线程数大于1）<br>        <span class="hljs-keyword" style="color: #a626a4; line-height: 26px;">for</span>(int i=0;i&lt;2;i++){<!-- --><br>            new Thread(()-&gt;{<!-- --><br>                synchronized (lock) {<!-- --><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string" style="color: #50a14f; line-height: 26px;">" -- "</span> + ClassLayout.parseInstance(lock).toPrintable());<br>                }<br>            }).start();<br>        }<br>    }<br>}<br></code></pre> 
 <p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">输出： <img src="https://images2.imgbox.com/b1/6e/sSUoAeFj_o.png" alt="alt" style="display: block; margin: 0 auto; max-width: 100%;"></p> 
 <h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">参考资料</span><span class="suffix"></span></h3> 
 <ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li> 
   <section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">
     书籍 周志明 * 《深入理解Java虚拟机》 
   </section></li><li> 
   <section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">
     书籍 葛一鸣 * 《Java高并发程序设计》 
   </section></li><li> 
   <section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">
     网上文章 - https://www.cnblogs.com/Alei777/p/16223842.html 
   </section></li></ul> 
</section> 
<p>本文由<a href="https://mdnice.com/?platform=4" rel="nofollow"> mdnice </a>多平台发布</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e2fb1bf6c0fcdfdca38520651d8ea9a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PyTorch|Tensor基础操作：拼接、切分、索引和变换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4960db5dea82a9d1d313e2ba5b67de7b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java.lang.RuntimeException: javax.crypto.BadPaddingException: Given final block not properly padded....</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>