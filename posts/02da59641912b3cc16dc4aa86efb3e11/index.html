<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Security及若依安全实现，Java小白入门（九） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Security及若依安全实现，Java小白入门（九）" />
<meta property="og:description" content="背景 一个系统总会遇到安全，权限的问题，并且一坨坨的术语，让人恼火；更恼火的是官方一坨坨的代码实现，理不清剪不断；最最恼火的是你还得重新注入自己的一些实现，比如个性话的用户、个性化的权限，不得不重写一些接口和实现。最好的办法是，大概理清它们在哪里，然后，不至于想实现的时候找不到路径，那么一起看看spring security的基本原理和实现，以及若依又如何使用的，才会到以后该如何自己整一套。 Spring Security简介 Spring Security 最早叫 Acegi Security， 这个名称并不是说它和 Spring 就没有关系，它依然是为Spring 框架提供安全支持的。Acegi Security 基于 Spring，可以帮助我们为项目建立丰富的角色与权限管理系统。Acegi security 虽然好用，但是最为人诟病的则是它臃肿烦琐的配置这一问题最终也遗传给了 Spring Security。Acegi Security 最终被并入 Spring Security 项目中，并于 2008 年4月发布了改名后的第一个版本 Spring Security 2.0.0，到目前为止，Spring Security 的最新版本己经到了 5.6.1。和 Shiro 相比，Spring Security重量级并且配置烦琐，直至今天，依然有人以此为理由而拒绝了解 Spring Security。其实，自从 Spring Boot 推出后，就彻底颠覆了传统了 JavaEE 开发，自动化配置让许多事情变得非常容易，包括 Spring Security 的配置。在一个 Spring Boot 项目中，我们甚至只需要引入一个依赖，不需要任何额外配置，项目的所有接口就会被自动保护起来了。在 Spring Cloud中，很多涉及安全管理的问题，也是一个 Spring Security 依赖两行配置就能搞定，在和 Spring 家族的产品一起使用时，Spring Security 的优势就非常明显了。 整体架构 通过上一节，对于基本术语我们比较熟悉了，核心就是认证和授权，您是谁，您有什么权利，这两个看着有点相似的词一定区分好，Authentication （认证）,Authorization（授权）,AuthenticationManager 主要实现类为 ProviderManager，在 ProviderManager 中管理了众多 AuthenticationProvider 实例。很明显，可以有多个provider，允许有多种认证方式。SecurityContextHolder 用来获取登录之后用户信息。AccesDecisionVoter 和 AccessDecisionManager 都有众多的实现类，在 AccessDecisionManager 中会换个遍历 AccessDecisionVoter，进而决定是否允许用户访问，因而 AaccesDecisionVoter 和 AccessDecisionManager 两者的关系类似于 AuthenticationProvider 和 ProviderManager 的关系。 基本原理 在 Spring Security 中 认证、授权 等功能都是基于过滤器完成的。需要注意的是，默认过滤器并不是直接放在 Web 项目的原生过滤器链中，而是通过一个 FlterChainProxy 来统一管理。Spring Security 中的过滤器链通过 FilterChainProxy 嵌入到 Web项目的原生过滤器链中。FilterChainProxy 作为一个顶层的管理者，将统一管理 Security Filter。FilterChainProxy 本身是通过 Spring 框架提供的 DelegatingFilterProxy 整合到原生的过滤器链中。 Security Filters 可以看出，Spring Security 提供了 30 多个过滤器。默认情况下Spring Boot 在对 Spring Security 进入自动化配置时，会创建一个名为 SpringSecurityFilerChain 的过滤器，并注入到 Spring 容器中，这个过滤器将负责所有的安全管理，包括用户认证、授权、重定向到登录页面等。SpringBootWebSecurityConfiguration这个类是 spring boot 自动配置类，通过这个源码得知，默认情况下对所有请求进行权限控制: 中间省略一坨坨的逻辑分析，spring security 会到usreDetailService, 也就是及时没有持久化，也能看到登录 绕了很多，我们回到如何自定义的认证以及自定义的授权，划重点，WebSecurityConfigurerAdapter 扩展 Spring Security 所有默认配置 会用这个就可以，不能再看多了，越看越乱，不如我们看若依是如何实践这个内容的。 若依的安全 安全的配置 @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter 里面的细节都要挨着读一读的，看代码最有意思 若依登陆过程及过滤器拦截器的使用：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/02da59641912b3cc16dc4aa86efb3e11/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T18:23:03+08:00" />
<meta property="article:modified_time" content="2024-01-03T18:23:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Security及若依安全实现，Java小白入门（九）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="E8ps1">背景</h3> 
<ul><li id="u5b14d671">一个系统总会遇到安全，权限的问题，并且一坨坨的术语，让人恼火；更恼火的是官方一坨坨的代码实现，理不清剪不断；最最恼火的是你还得重新注入自己的一些实现，比如个性话的用户、个性化的权限，不得不重写一些接口和实现。</li><li id="u1c5c71b8">最好的办法是，大概理清它们在哪里，然后，不至于想实现的时候找不到路径，那么一起看看spring security的基本原理和实现，以及若依又如何使用的，才会到以后该如何自己整一套。</li></ul> 
<h3 id="TcdyJ">Spring Security简介</h3> 
<ul><li id="u0020f070">Spring Security 最早叫 Acegi Security， 这个名称并不是说它和 Spring 就没有关系，它依然是为Spring 框架提供安全支持的。Acegi Security 基于 Spring，可以帮助我们为项目建立丰富的角色与权限管理系统。Acegi security 虽然好用，但是最为人诟病的则是它臃肿烦琐的配置这一问题最终也遗传给了 Spring Security。</li><li id="uda237f49">Acegi Security 最终被并入 Spring Security 项目中，并于 2008 年4月发布了改名后的第一个版本 Spring Security 2.0.0，到目前为止，Spring Security 的最新版本己经到了 5.6.1。和 Shiro 相比，Spring Security重量级并且配置烦琐，直至今天，依然有人以此为理由而拒绝了解 Spring Security。其实，自从 Spring Boot 推出后，就彻底颠覆了传统了 JavaEE 开发，自动化配置让许多事情变得非常容易，包括 Spring Security 的配置。在一个 Spring Boot 项目中，我们甚至只需要引入一个依赖，不需要任何额外配置，项目的所有接口就会被自动保护起来了。在 Spring Cloud中，很多涉及安全管理的问题，也是一个 Spring Security 依赖两行配置就能搞定，在和 Spring 家族的产品一起使用时，Spring Security 的优势就非常明显了。</li></ul> 
<h4 id="Ti7UO">整体架构</h4> 
<h4 id="otdeN"></h4> 
<p class="img-center"><img alt="" height="373" id="u62c09377" src="https://images2.imgbox.com/75/11/ahKr7rj5_o.png" width="763"></p> 
<h4 id="xVi0X"></h4> 
<ul><li id="u5353505a">通过上一节，对于基本术语我们比较熟悉了，核心就是认证和授权，您是谁，您有什么权利，这两个看着有点相似的词一定区分好，Authentication （认证）,Authorization（授权）,AuthenticationManager 主要实现类为 ProviderManager，在 ProviderManager 中管理了众多 AuthenticationProvider 实例。很明显，可以有多个provider，允许有多种认证方式。SecurityContextHolder 用来获取登录之后用户信息。</li><li id="u0e120a96">AccesDecisionVoter 和 AccessDecisionManager 都有众多的实现类，在 AccessDecisionManager 中会换个遍历 AccessDecisionVoter，进而决定是否允许用户访问，因而 AaccesDecisionVoter 和 AccessDecisionManager 两者的关系类似于 AuthenticationProvider 和 ProviderManager 的关系。</li></ul> 
<h4 id="g31tW">基本原理</h4> 
<p id="uf0498bfa"></p> 
<p class="img-center"><img alt="" height="693" id="u16c16083" src="https://images2.imgbox.com/ec/0c/PLMhMzhM_o.png" width="935"></p> 
<ul><li id="u0fab20aa">在 Spring Security 中 认证、授权 等功能都是基于过滤器完成的。需要注意的是，默认过滤器并不是直接放在 Web 项目的原生过滤器链中，而是通过一个 FlterChainProxy 来统一管理。Spring Security 中的过滤器链通过 FilterChainProxy 嵌入到 Web项目的原生过滤器链中。FilterChainProxy 作为一个顶层的管理者，将统一管理 Security Filter。FilterChainProxy 本身是通过 Spring 框架提供的 DelegatingFilterProxy 整合到原生的过滤器链中。</li></ul> 
<h4 id="HPDbQ">Security Filters</h4> 
<h4 id="Q8Sgt"></h4> 
<p class="img-center"><img alt="" height="712" id="uf6d9e303" src="https://images2.imgbox.com/88/d0/auFANth3_o.png" width="870"></p> 
<ul><li id="u7e7a5755">可以看出，Spring Security 提供了 30 多个过滤器。默认情况下Spring Boot 在对 Spring Security 进入自动化配置时，会创建一个名为 SpringSecurityFilerChain 的过滤器，并注入到 Spring 容器中，这个过滤器将负责所有的安全管理，包括用户认证、授权、重定向到登录页面等。SpringBootWebSecurityConfiguration这个类是 spring boot 自动配置类，通过这个源码得知，默认情况下对所有请求进行权限控制:</li></ul> 
<p id="ubc7e5095"></p> 
<p class="img-center"><img alt="" height="300" id="u7e12263e" src="https://images2.imgbox.com/15/75/W9mzqzdS_o.png" width="760"></p> 
<ul><li id="u7f3d87d2">中间省略一坨坨的逻辑分析，spring security 会到usreDetailService, 也就是及时没有持久化，也能看到登录</li></ul> 
<p id="u3d379829"></p> 
<p class="img-center"><img alt="" height="182" id="u679f9dce" src="https://images2.imgbox.com/37/13/Z5wpb6o1_o.png" width="865"></p> 
<ul><li id="u59593f46">绕了很多，我们回到如何自定义的认证以及自定义的授权，划重点，<strong>WebSecurityConfigurerAdapter</strong> 扩展 Spring Security 所有默认配置</li></ul> 
<p id="ub29f00de"></p> 
<p class="img-center"><img alt="" height="480" id="u549249fb" src="https://images2.imgbox.com/46/95/oYlW0jvm_o.png" width="719"></p> 
<ul><li id="u82cff9d3">会用这个就可以，不能再看多了，越看越乱，不如我们看若依是如何实践这个内容的。</li></ul> 
<h3 id="uogSY">若依的安全</h3> 
<h4 id="o6Wrn">安全的配置</h4> 
<pre id="cuJVZ"><code>@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter</code></pre> 
<p id="u1491a0ef"></p> 
<p class="img-center"><img alt="" height="250" id="u7b95bd50" src="https://images2.imgbox.com/3f/75/PlALxrZI_o.png" width="535"></p> 
<ul><li id="u80a64f6c">里面的细节都要挨着读一读的，看代码最有意思</li></ul> 
<p id="ucbef8a45"></p> 
<p class="img-center"><img alt="" height="744" id="ue4a7744c" src="https://images2.imgbox.com/5b/7d/JM3HCdrH_o.png" width="719"></p> 
<p id="uf1b93e39"></p> 
<p class="img-center"><img alt="" height="769" id="u3dfbcf33" src="https://images2.imgbox.com/17/72/E0cgI1Ox_o.png" width="1136"></p> 
<p id="ubfd13b16"></p> 
<p class="img-center"><img alt="" height="216" id="u0b00b310" src="https://images2.imgbox.com/1d/21/w7PmmIC4_o.png" width="802"></p> 
<blockquote> 
 <p id="uf08fb1bf">若依登陆过程及过滤器拦截器的使用：</p> 
 <p id="u931a4824">用户登陆接口：1、把用户信息通过uuid即token作为key，存储在缓存中，并设置过期时间，2、通过jwt存储token，userId，userName在map中，设置过期时间，通过jwt创建一个编码后的access_token和expireTime，并返回token在前端</p> 
 <p id="u9331ef27">过滤器：用户前端传递的access_token通过Jwt解析，尝试获取userkey（即token），userid，username</p> 
 <p id="u6d95e301">并判断是否过期，为空等。如果异常即刻报错，否则将解析的userkey，userid，username纳入请求头中，请求接着交给拦截器。</p> 
 <p id="u3bc97657">拦截器：拦截器从请求头中获取userkey，userid，username，通过userkey从缓存中获取用户信息，并刷新缓存中用户信息的过期时间。并将用户信息加入到本地的TransmittableThreadLocal&lt;Map&lt;String, Object&gt;&gt;中，方便用户获取当前用户信息。</p> 
 <p id="u5f9e3b44"></p> 
 <p id="u4c618977">当然还有的很多内容，比如记住我，验证码， CSRF 漏洞保护，跨域，异常处理等等，都需要在这个基础上展开。</p> 
</blockquote> 
<p id="ud20b1372"></p> 
<h3 id="urli5">总结</h3> 
<blockquote> 
 <p id="u8f9fa18a">在 Spring Security 中 认证、授权 等功能都是基于过滤器完成的。</p> 
 <p id="ub60310da">如何自定义自己的一些安全策略， <strong>WebSecurityConfigurerAdapter</strong> 扩展 Spring Security 所有默认配置</p> 
</blockquote> 
<p id="ua06f5658"></p> 
<p id="u3ba0dd98"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/11594e222eda6cf75e9446561ad67f94/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">降维算法的简单介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/025aeeac858c20b48be1df5118f26ecc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">以STM32为例，实现按键的短按和长按</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>