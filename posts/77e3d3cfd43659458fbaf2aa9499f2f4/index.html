<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>go context用法详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="go context用法详解" />
<meta property="og:description" content="转发自 作者kingeasternsun https://studygolang.com/articles/10155?fr=sidebar
本文主要基于官方文档Go Concurrency Patterns: Context以及视频Advanced Go Concurrency Patterns的学习而得。
背景 在go服务器中，对于每个请求的request都是在单独的goroutine中进行的，处理一个request也可能设计多个goroutine之间的交互， 使用context可以使开发者方便的在这些goroutine里传递request相关的数据、取消goroutine的signal或截止日期。
Context结构 // A Context carries a deadline, cancelation signal, and request-scoped values // across API boundaries. Its methods are safe for simultaneous use by multiple // goroutines. type Context interface { // Done returns a channel that is closed when this Context is canceled // or times out. Done() &lt;-chan struct{} // Err indicates why this context was canceled, after the Done channel // is closed." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/77e3d3cfd43659458fbaf2aa9499f2f4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-20T17:59:28+08:00" />
<meta property="article:modified_time" content="2018-07-20T17:59:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">go context用法详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>转发自 作者kingeasternsun  <a href="https://studygolang.com/articles/10155?fr=sidebar" rel="nofollow">https://studygolang.com/articles/10155?fr=sidebar</a></p> 
<p>本文主要基于官方文档<a href="https://blog.golang.org/context" rel="nofollow">Go Concurrency Patterns: Context</a>以及视频<a href="https://www.youtube.com/watch?v=QDDwwePbDtw" rel="nofollow">Advanced Go Concurrency Patterns</a>的学习而得。</p> 
<h3>背景</h3> 
<p>在go服务器中，对于每个请求的request都是在单独的goroutine中进行的，处理一个request也可能设计多个goroutine之间的交互， 使用context可以使开发者方便的在这些goroutine里传递request相关的数据、取消goroutine的signal或截止日期。</p> 
<h3>Context结构</h3> 
<pre class="has"><code>// A Context carries a deadline, cancelation signal, and request-scoped values
// across API boundaries. Its methods are safe for simultaneous use by multiple
// goroutines.
type Context interface {
    // Done returns a channel that is closed when this Context is canceled
    // or times out.
    Done() &lt;-chan struct{}

    // Err indicates why this context was canceled, after the Done channel
    // is closed.
    Err() error

    // Deadline returns the time when this Context will be canceled, if any.
    Deadline() (deadline time.Time, ok bool)

    // Value returns the value associated with key or nil if none.
    Value(key interface{}) interface{}
}</code></pre> 
<p><strong>Done</strong> 方法在Context被取消或超时时返回一个close的channel,close的channel可以作为广播通知，告诉给context相关的函数要停止当前工作然后返回。</p> 
<p>当一个父operation启动一个goroutine用于子operation，这些子operation不能够取消父operation。下面描述的WithCancel函数提供一种方式可以取消新创建的Context.</p> 
<p>Context可以安全的被多个goroutine使用。开发者可以把一个Context传递给任意多个goroutine然后cancel这个context的时候就能够通知到所有的goroutine。</p> 
<p><strong>Err</strong>方法返回context为什么被取消。</p> 
<p><strong>Deadline</strong>返回context何时会超时。</p> 
<p><strong>Value</strong>返回context相关的数据。</p> 
<h3>继承的Context</h3> 
<h4>BackGround</h4> 
<pre class="has"><code>// Background returns an empty Context. It is never canceled, has no deadline,
// and has no values. Background is typically used in main, init, and tests,
// and as the top-level Context for incoming requests.
func Background() Context</code></pre> 
<p>BackGound是所有Context的root，不能够被cancel。</p> 
<h4>WithCancel</h4> 
<pre class="has"><code>// WithCancel returns a copy of parent whose Done channel is closed as soon as
// parent.Done is closed or cancel is called.
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></pre> 
<p>WithCancel返回一个继承的Context,这个Context在父Context的Done被关闭时关闭自己的Done通道，或者在自己被Cancel的时候关闭自己的Done。<br> WithCancel同时还返回一个取消函数cancel，这个cancel用于取消当前的Context。</p> 
<p>视频<a href="https://www.youtube.com/watch?v=QDDwwePbDtw" rel="nofollow">Advanced Go Concurrency Patterns</a>中的第一个关于WithCancel的样例代码，本人有所修改</p> 
<pre class="has"><code>package main

import (
    "context"
    "log"
    "os"
    "time"
)

var logg *log.Logger

func someHandler() {
    ctx, cancel := context.WithCancel(context.Background())
    go doStuff(ctx)

//10秒后取消doStuff
    time.Sleep(10 * time.Second)
    cancel()

}

//每1秒work一下，同时会判断ctx是否被取消了，如果是就退出
func doStuff(ctx context.Context) {
    for {
        time.Sleep(1 * time.Second)
        select {
        case &lt;-ctx.Done():
            logg.Printf("done")
            return
        default:
            logg.Printf("work")
        }
    }
}

func main() {
    logg = log.New(os.Stdout, "", log.Ltime)
    someHandler()
    logg.Printf("down")
}</code></pre> 
<p>结果</p> 
<pre class="has"><code>E:\wdy\goproject&gt;go run context_learn.go
15:06:44 work
15:06:45 work
15:06:46 work
15:06:47 work
15:06:48 work
15:06:49 work
15:06:50 work
15:06:51 work
15:06:52 work
15:06:53 down</code></pre> 
<h4>withDeadline withTimeout</h4> 
<pre class="has"><code>WithTimeout func(parent Context, timeout time.Duration) (Context, CancelFunc)
WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</code></pre> 
<p>WithTimeout 等价于 WithDeadline(parent, time.Now().Add(timeout)).</p> 
<p>对上面的样例代码进行修改</p> 
<pre class="has"><code>func timeoutHandler() {
    // ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(5*time.Second))
    // go doTimeOutStuff(ctx)
    go doStuff(ctx)

    time.Sleep(10 * time.Second)

    cancel()

}

func main() {
    logg = log.New(os.Stdout, "", log.Ltime)
    timeoutHandler()
    logg.Printf("end")
}</code></pre> 
<p>输出</p> 
<pre class="has"><code>15:59:22 work
15:59:24 work
15:59:25 work
15:59:26 work
15:59:27 done
15:59:31 end</code></pre> 
<p>可以看到doStuff在context超时的时候被取消了，ctx.Done()被关闭。<br> 将context.WithDeadline替换为context.WithTimeout</p> 
<pre class="has"><code>func timeoutHandler() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    // ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(5*time.Second))
    // go doTimeOutStuff(ctx)
    go doStuff(ctx)

    time.Sleep(10 * time.Second)

    cancel()

}</code></pre> 
<p>输出</p> 
<pre class="has"><code>16:02:47 work
16:02:49 work
16:02:50 work
16:02:51 work
16:02:52 done
16:02:56 end</code></pre> 
<p>根据视频<a href="https://www.youtube.com/watch?v=QDDwwePbDtw" rel="nofollow">Advanced Go Concurrency Patterns</a>5分48秒处的代码编写doTimeOutStuff替换doStuff</p> 
<pre class="has"><code>func doTimeOutStuff(ctx context.Context) {
    for {
        time.Sleep(1 * time.Second)

        if deadline, ok := ctx.Deadline(); ok { //设置了deadl
            logg.Printf("deadline set")
            if time.Now().After(deadline) {
                logg.Printf(ctx.Err().Error())
                return
            }

        }

        select {
        case &lt;-ctx.Done():
            logg.Printf("done")
            return
        default:
            logg.Printf("work")
        }
    }
}

func timeoutHandler() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    // ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(5*time.Second))
    go doTimeOutStuff(ctx)
    // go doStuff(ctx)

    time.Sleep(10 * time.Second)

    cancel()

}</code></pre> 
<p>输出：</p> 
<pre class="has"><code>16:03:55 deadline set
16:03:55 work
16:03:56 deadline set
16:03:56 work
16:03:57 deadline set
16:03:57 work
16:03:58 deadline set
16:03:58 work
16:03:59 deadline set
16:03:59 context deadline exceeded
16:04:04 end</code></pre> 
<p><strong>context deadline exceeded</strong>就是ctx超时的时候ctx.Err的错误消息。</p> 
<h4>搜索测试程序</h4> 
<p>完整代码参见官方文档<a href="https://blog.golang.org/context" rel="nofollow">Go Concurrency Patterns: Context</a>，其中关键的地方在于函数httpDo</p> 
<pre class="has"><code>func httpDo(ctx context.Context, req *http.Request, f func(*http.Response, error) error) error {
    // Run the HTTP request in a goroutine and pass the response to f.
    tr := &amp;http.Transport{}
    client := &amp;http.Client{Transport: tr}
    c := make(chan error, 1)
    go func() { c &lt;- f(client.Do(req)) }()
    select {
    case &lt;-ctx.Done():
        tr.CancelRequest(req)
        &lt;-c // Wait for f to return.
        return ctx.Err()
    case err := &lt;-c:
        return err
    }
}</code></pre> 
<p>httpDo关键的地方在于</p> 
<pre class="has"><code>    select {
    case &lt;-ctx.Done():
        tr.CancelRequest(req)
        &lt;-c // Wait for f to return.
        return ctx.Err()
    case err := &lt;-c:
        return err
    }</code></pre> 
<p>要么ctx被取消，要么request请求出错。</p> 
<h4>WithValue</h4> 
<pre class="has"><code>func WithValue(parent Context, key interface{}, val interface{}) Context</code></pre> 
<p>参见搜索程序<a href="https://blog.golang.org/context/userip/userip.go" rel="nofollow">userip</a>中的代码<br> 关键的代码如下：</p> 
<pre class="has"><code>// NewContext returns a new Context carrying userIP.
func NewContext(ctx context.Context, userIP net.IP) context.Context {
    return context.WithValue(ctx, userIPKey, userIP)
}

// FromContext extracts the user IP address from ctx, if present.
func FromContext(ctx context.Context) (net.IP, bool) {
    // ctx.Value returns nil if ctx has no value for the key;
    // the net.IP type assertion returns ok=false for nil.
    userIP, ok := ctx.Value(userIPKey).(net.IP)
    return userIP, ok
}</code></pre> 
<h3>go doc中的信息</h3> 
<pre class="has"><code>The WithCancel, WithDeadline, and WithTimeout functions take a Context (the
parent) and return a derived Context (the child) and a CancelFunc. Calling
the CancelFunc cancels the child and its children, removes the parent's
reference to the child, and stops any associated timers.</code></pre> 
<p>里面需要注意的就是 调用CancelFunc会取消child以及child生成的context，取出父context对这个child的引用，停止相关的计数器。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2024b1ad4e5c89e6c04af6eed31fb6ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Linux】Linux的内核空间（低端内存、高端内存）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/afcc406632840a1fcdb57c714b5c513a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">编写程序，对输入的年、月、日，给出该天是该年的第多少天？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>