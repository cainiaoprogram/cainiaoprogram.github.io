<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OAuth2.0 实现单点登录 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OAuth2.0 实现单点登录" />
<meta property="og:description" content="文章目录 OAuth2.0 实现单点登录一、四种授权模式二、搭建验证服务器三、接口工具测试🍀3.1 客户端模式 (Client Credentials)🍀3.2 密码模式 (Resource Owner Password Credentials)🍀3.3 隐式授权模式 (Implicit Grant)🍀3.4 授权码模式 (Authrization Code)🍀3.5 令牌刷新 四、基于 @EnableOAuth2Sso 实现🍇4.1 微服务实现单点登录🍇4.2 SESSION 不同步问题 五、基于 @EnableResourceServer 实现 🚩🍬5.1 资源服务器🍬5.2 客户端访问🍬5.3 解决远程调用 六、使用 JWT 存储 Token🍒6.1 验证服务器🍒6.2 资源服务器🍒6.3 令牌中继 (远程调用) 总结 提示：以下是本篇文章正文内容，SpringCloud 系列学习将会持续更新 OAuth2.0 实现单点登录 注意： 第一次接触可能会比较难，不太好理解，需要多实践和观察。
前面我们虽然使用了统一存储来解决 Session 共享问题，但是我们发现就算实现了 Session 共享，依然存在一些问题，由于我们每个服务都有自己的验证模块，实际上整个系统是存在冗余功能的、同时还有我们上面出现的问题，那么能否实现只在一个服务进行登录，就可以访问其他的服务呢？
实际上之前的登录模式称为多点登录，而我们希望的是实现单点登陆，因此，我们得找一个更好的解决方案。
这里我们首先需要了解一种全新的登录方式：OAuth 2.0。我们经常看到一些网站支持第三方登录，比如淘宝、咸鱼我们就可以使用支付宝进行登录，腾讯游戏可以用QQ或是微信登陆，以及微信小程序都可以直接使用微信进行登录。我们知道它们并不是属于同一个系统，比如淘宝和咸鱼都不属于支付宝这个应用，但是由于需要获取支付宝的用户信息，这时我们就需要使用 OAuth2.0 来实现第三方授权，基于第三方应用访问用户信息的权限（本质上就是给别人调用自己服务接口的权限），那么它是如何实现的呢？
一、四种授权模式 我们还是从理论开始讲解，OAuth 2.0一共有四种授权模式：
客户端模式（Client Credentials）
这是最简单的一种模式，我们可以直接向验证服务器请求一个 Token（这里可能有些小伙伴对Token的概念不是很熟悉，Token 相当于是一个令牌，我们需要在验证服务器 （User Account And Authentication） 服务拿到令牌之后，才能去访问资源，比如用户信息、借阅信息等，这样资源服务器才能知道我们是谁以及是否成功登录了）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/64f73411ac8a6e6fa3489a044b9d2931/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-26T00:10:23+08:00" />
<meta property="article:modified_time" content="2023-11-26T00:10:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OAuth2.0 实现单点登录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="mulu"> </h3> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#OAuth20__8" rel="nofollow">OAuth2.0 实现单点登录</a></li><li><ul><li><a href="#_17" rel="nofollow">一、四种授权模式</a></li><li><a href="#_47" rel="nofollow">二、搭建验证服务器</a></li><li><a href="#_179" rel="nofollow">三、接口工具测试</a></li><li><ul><li><a href="#31__Client_Credentials_183" rel="nofollow">🍀3.1 客户端模式 (Client Credentials)</a></li><li><a href="#32__Resource_Owner_Password_Credentials_214" rel="nofollow">🍀3.2 密码模式 (Resource Owner Password Credentials)</a></li><li><a href="#33__Implicit_Grant_251" rel="nofollow">🍀3.3 隐式授权模式 (Implicit Grant)</a></li><li><a href="#34__Authrization_Code_297" rel="nofollow">🍀3.4 授权码模式 (Authrization Code)</a></li><li><a href="#35__320" rel="nofollow">🍀3.5 令牌刷新</a></li></ul> 
   </li><li><a href="#_EnableOAuth2Sso__367" rel="nofollow">四、基于 @EnableOAuth2Sso 实现</a></li><li><ul><li><a href="#41__372" rel="nofollow">🍇4.1 微服务实现单点登录</a></li><li><a href="#42_SESSION__454" rel="nofollow">🍇4.2 SESSION 不同步问题</a></li></ul> 
   </li><li><a href="#_EnableResourceServer___470" rel="nofollow">五、基于 @EnableResourceServer 实现 🚩</a></li><li><ul><li><a href="#51__475" rel="nofollow">🍬5.1 资源服务器</a></li><li><a href="#52__512" rel="nofollow">🍬5.2 客户端访问</a></li><li><a href="#53__568" rel="nofollow">🍬5.3 解决远程调用</a></li></ul> 
   </li><li><a href="#_JWT__Token_633" rel="nofollow">六、使用 JWT 存储 Token</a></li><li><ul><li><a href="#61__667" rel="nofollow">🍒6.1 验证服务器</a></li><li><a href="#62__723" rel="nofollow">🍒6.2 资源服务器</a></li><li><a href="#63___737" rel="nofollow">🍒6.3 令牌中继 (远程调用)</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_779" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<font color="#999AAA">提示：以下是本篇文章正文内容，SpringCloud 系列学习将会持续更新 </font> 
<p></p> 
<h2><a id="OAuth20__8"></a>OAuth2.0 实现单点登录</h2> 
<p><strong>注意：</strong> 第一次接触可能会比较难，不太好理解，需要多实践和观察。</p> 
<p>前面我们虽然使用了统一存储来解决 Session 共享问题，但是我们发现就算实现了 Session 共享，依然存在一些问题，由于我们每个服务都有自己的验证模块，实际上整个系统是存在冗余功能的、同时还有我们上面出现的问题，那么能否实现只在一个服务进行登录，就可以访问其他的服务呢？<br> <img src="https://images2.imgbox.com/5a/e8/xfrlXgv5_o.png" alt="在这里插入图片描述"><br> 实际上之前的登录模式称为多点登录，而我们希望的是实现单点登陆，因此，我们得找一个更好的解决方案。</p> 
<p>这里我们首先需要了解一种全新的登录方式：<strong>OAuth 2.0</strong>。我们经常看到一些网站支持第三方登录，比如淘宝、咸鱼我们就可以使用支付宝进行登录，腾讯游戏可以用QQ或是微信登陆，以及微信小程序都可以直接使用微信进行登录。我们知道它们并不是属于同一个系统，比如淘宝和咸鱼都不属于支付宝这个应用，但是由于需要获取支付宝的用户信息，这时我们就需要使用 OAuth2.0 来实现第三方授权，基于第三方应用访问用户信息的权限（本质上就是给别人调用自己服务接口的权限），那么它是如何实现的呢？</p> 
<h3><a id="_17"></a>一、四种授权模式</h3> 
<p>我们还是从理论开始讲解，OAuth 2.0一共有四种授权模式：</p> 
<ol><li> <p><strong>客户端模式（Client Credentials）</strong><br>  这是最简单的一种模式，我们可以直接向验证服务器请求一个 Token（这里可能有些小伙伴对Token的概念不是很熟悉，Token 相当于是一个令牌，我们需要在验证服务器 <strong>（User Account And Authentication）</strong> 服务拿到令牌之后，才能去访问资源，比如用户信息、借阅信息等，这样资源服务器才能知道我们是谁以及是否成功登录了）<br><br>  当然，这里的前端页面只是一个例子，它还可以是其他任何类型的客户端，比如 App、小程序甚至是第三方应用的服务。<br> <img src="https://images2.imgbox.com/0d/d3/RJfZRWgt_o.png" alt="在这里插入图片描述"><br>  虽然这种模式比较简便，但是已经失去了用户验证的意义，压根就不是给用户校验准备的，而是更适用于服务内部调用的场景。</p> </li><li> <p><strong>密码模式（Resource Owner Password Credentials）</strong><br>  密码模式相比客户端模式，就多了用户名和密码的信息，用户需要提供对应账号的用户名和密码，才能获取到 Token。<br> <img src="https://images2.imgbox.com/42/21/jTggQw09_o.png" alt="在这里插入图片描述"><br>  虽然这样看起来比较合理，但是会直接将账号和密码泄露给客户端，需要后台完全信任客户端不会拿账号密码去干其他坏事，所以这也不是我们常见的。</p> </li><li> <p><strong>隐式授权模式（Implicit Grant）</strong><br>  首先用户访问页面时，会重定向到认证服务器，接着认证服务器给用户一个认证页面，等待用户授权，用户填写信息完成授权后，认证服务器返回 Token。<br> <img src="https://images2.imgbox.com/44/c9/27F58npr_o.png" alt="在这里插入图片描述"><br>  它适用于没有服务端的第三方应用页面，并且相比前面一种形式，验证都是在验证服务器进行的，敏感信息不会轻易泄露，但是 Token 依然存在泄露的风险。</p> </li><li> <p><strong>授权码模式（Authrization Code）</strong><br>  这种模式是最安全的一种模式，也是推荐使用的一种，比如我们手机上的很多 App 都是使用的这种模式。<br><br>  相比隐式授权模式，它并不会直接返回 Token，而是返回授权码，真正的 Token 是通过应用服务器访问验证服务器获得的。在一开始的时候，应用服务器（客户端通过访问自己的应用服务器来进而访问其他服务）和验证服务器之间会共享一个 <code>secret</code>，这个东西没有其他人知道，而验证服务器在用户验证完成之后，会返回一个授权码，应用服务器最后将授权码和 <code>secret</code> 一起交给验证服务器进行验证，并且 Token 也是在服务端之间传递，不会直接给到客户端。<br> <img src="https://images2.imgbox.com/c2/5a/RnbeBvm4_o.png" alt="在这里插入图片描述"><br>  这样就算有人中途窃取了授权码，也毫无意义，因为，Token 的获取必须同时携带授权码和 secret ，但是 secret 第三方是无法得知的，并且 Token 不会直接丢给客户端，大大减少了泄露的风险。</p> </li></ol> 
<p><font color="deeppink">但是乍一看，OAuth 2.0 不应该是那种第三方应用为了请求我们的服务而使用的吗，而我们这里需要的只是实现同一个应用内部服务之间的认证，其实我也可以利用 OAuth2.0 来实现单点登录，只是少了资源服务器这一角色，客户端就是我们的整个系统，接下来就让我们来实现一下。</font></p> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h3><a id="_47"></a>二、搭建验证服务器</h3> 
<p>第一步就是最重要的，我们需要搭建一个验证服务器，<strong>它是我们进行权限校验的核心</strong>，验证服务器有很多的第三方实现也有 Spring 官方提供的实现，这里我们使用 Spring 官方提供的验证服务器。</p> 
<blockquote> 
 <p><strong>这里提供了项目的码云地址</strong>：</p> 
 <ul><li><a href="https://gitee.com/WangShaoyu01/library-study" rel="nofollow">项目一(脚手架)</a>：基础项目，没有使用 SpringCloud 组件，使用 RestTemplate 实现远程调用，可以直接运行，跟着文章一起做</li><li><a href="https://gitee.com/WangShaoyu01/library-cloud-study" rel="nofollow">项目二(脚手架)</a>：基础项目，使用了 Nacos 注册中心，需要本地安装 Nacos 才能运行，跟着文章一起做 (推荐使用该项目)</li><li><a href="https://gitee.com/WangShaoyu01/oauth-two-login" rel="nofollow">项目三(实现版)</a>：实现了文章中的单点登录，安装 Nacos 后可以运行，可以直接看效果<br> <br></li></ul> 
 <p><strong>注意</strong>：以上项目都没有实现前端，所以过程中需要 Postman 或 Apifox 等接口工具验证</p> 
</blockquote> 
<p>如果我们使用了<strong>项目一</strong>，则需要在父项目的 pom 中添加 <code>SpringCloud</code> 依赖版本管理：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2021.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>①接着创建一个新的项目模块 <code>auth-service</code>，添加依赖：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--  OAuth2.0依赖，不再内置了，所以得我们自己指定一下版本  --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-oauth2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 引入security给我们提供登录功能 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-security<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>②设置 yml 配置文件</p> 
<pre><code class="prism language-yml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8500</span>
  <span class="token key atrule">servlet</span><span class="token punctuation">:</span>
  	<span class="token comment">#为了防止一会在服务之间跳转导致Cookie打架（因为所有服务地址都是localhost，都会存JSESSIONID）</span>
  	<span class="token comment">#这里修改一下context-path，这样保存的Cookie会使用指定的路径，就不会和其他服务打架了</span>
  	<span class="token comment">#但是注意之后的请求都得在最前面加上这个路径</span>
    <span class="token key atrule">context-path</span><span class="token punctuation">:</span> /sso
</code></pre> 
<p>③接着我们需要编写一个 SpringSecurity 的配置类 <code>SecurityConfiguration.java</code>：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecurityConfiguration</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">HttpSecurity</span> http<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        http
                <span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用表单登录</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">AuthenticationManagerBuilder</span> auth<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">BCryptPasswordEncoder</span> encoder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BCryptPasswordEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        auth
                <span class="token punctuation">.</span><span class="token function">inMemoryAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// 直接创建一个用户，懒得搞数据库了</span>
                <span class="token punctuation">.</span><span class="token function">passwordEncoder</span><span class="token punctuation">(</span>encoder<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">withUser</span><span class="token punctuation">(</span><span class="token string">"wsy"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">password</span><span class="token punctuation">(</span>encoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">roles</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>   <span class="token comment">// 这里需要将AuthenticationManager注册为Bean，在OAuth配置中使用</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">AuthenticationManager</span> <span class="token function">authenticationManagerBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">authenticationManagerBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>④再编写一个 OAuth2 的配置类 <code>OAuth2Configuration.java</code>：配置客户端</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@EnableAuthorizationServer</span>   <span class="token comment">//开启验证服务器</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OAuth2Configuration</span> <span class="token keyword">extends</span> <span class="token class-name">AuthorizationServerConfigurerAdapter</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">AuthenticationManager</span> manager<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BCryptPasswordEncoder</span> encoder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BCryptPasswordEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 这个方法是对客户端进行配置，一个验证服务器可以预设很多个客户端，
     * 之后这些指定的客户端就可以按照下面指定的方式进行验证
     * @param clients 客户端配置工具
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">ClientDetailsServiceConfigurer</span> clients<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        clients
                <span class="token punctuation">.</span><span class="token function">inMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// 这里我们直接硬编码创建，当然也可以像Security那样自定义或是使用JDBC从数据库读取</span>
                <span class="token punctuation">.</span><span class="token function">withClient</span><span class="token punctuation">(</span><span class="token string">"web"</span><span class="token punctuation">)</span>   <span class="token comment">// 客户端ID，随便起就行</span>
                <span class="token punctuation">.</span><span class="token function">secret</span><span class="token punctuation">(</span>encoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"654321"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">// 只与客户端分享的secret，随便写，但是注意要加密</span>
                <span class="token punctuation">.</span><span class="token function">autoApprove</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token comment">// 自动审批，这里关闭，要的就是一会体验那种感觉</span>
                <span class="token punctuation">.</span><span class="token function">scopes</span><span class="token punctuation">(</span><span class="token string">"book"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"borrow"</span><span class="token punctuation">)</span>     <span class="token comment">// 授权范围，这里我们使用全部all</span>
                <span class="token punctuation">.</span><span class="token function">authorizedGrantTypes</span><span class="token punctuation">(</span><span class="token string">"client_credentials"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">,</span> <span class="token string">"implicit"</span><span class="token punctuation">,</span> <span class="token string">"authorization_code"</span><span class="token punctuation">,</span> <span class="token string">"refresh_token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//授权模式，一共支持5种，除了之前我们介绍的四种之外，还有一个刷新Token的模式</span>
                <span class="token comment">//这里我们直接把五种都写上，方便一会实验，当然各位也可以单独只写一种一个一个进行测试</span>
                <span class="token comment">//现在我们指定的客户端就支持这五种类型的授权方式了</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">AuthorizationServerSecurityConfigurer</span> security<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        security
                <span class="token punctuation">.</span><span class="token function">passwordEncoder</span><span class="token punctuation">(</span>encoder<span class="token punctuation">)</span>    <span class="token comment">// 编码器设定为BCryptPasswordEncoder</span>
                <span class="token punctuation">.</span><span class="token function">allowFormAuthenticationForClients</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 允许客户端使用表单验证，一会我们POST请求中会携带表单信息</span>
                <span class="token punctuation">.</span><span class="token function">checkTokenAccess</span><span class="token punctuation">(</span><span class="token string">"permitAll()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 允许所有的Token查询请求</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">AuthorizationServerEndpointsConfigurer</span> endpoints<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        endpoints
                <span class="token punctuation">.</span><span class="token function">authenticationManager</span><span class="token punctuation">(</span>manager<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 由于SpringSecurity新版本的一些底层改动，这里需要配置一下authenticationManager，才能正常使用password模式</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>⑤启动服务器<br> <img src="https://images2.imgbox.com/b7/25/LDaHiao0_o.png" alt="在这里插入图片描述"></p> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h3><a id="_179"></a>三、接口工具测试</h3> 
<p>接下来我们使用 Postman 或 Apifox 等工具将4种模式逐一测试：</p> 
<h4><a id="31__Client_Credentials_183"></a>🍀3.1 客户端模式 (Client Credentials)</h4> 
<p>客户端模式只需要提供 <code>id</code> 和 <code>secret</code> 即可直接拿到 Token，默认请求路径为 <code>http://localhost:8500/sso/oauth/token</code><br> <img src="https://images2.imgbox.com/e4/9b/4ZhDAZOf_o.png" alt="在这里插入图片描述"><br> 发起请求后，可以看到我们得到了 Token，它是以 <code>JSON</code> 格式给到我们的：</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"access_token"</span><span class="token operator">:</span> <span class="token string">"10f6a9ea-62fc-4cf1-b48f-a0cf1ae75250"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"token_type"</span><span class="token operator">:</span> <span class="token string">"bearer"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"expires_in"</span><span class="token operator">:</span> <span class="token number">42852</span><span class="token punctuation">,</span>
    <span class="token string-property property">"scope"</span><span class="token operator">:</span> <span class="token string">"book user borrow"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>然后我们可以检验 Token 是否有效： <code>http://localhost:8500/sso/oauth/check_token?token=token值</code><br> <img src="https://images2.imgbox.com/4f/5b/8sxAdrNU_o.png" alt="在这里插入图片描述"><br> 可以看到 active 为 true 时，表示我们刚刚申请到的 Token 是有效的。</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"scope"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token string">"book"</span><span class="token punctuation">,</span>
        <span class="token string">"user"</span><span class="token punctuation">,</span>
        <span class="token string">"borrow"</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string-property property">"active"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token string-property property">"exp"</span><span class="token operator">:</span> <span class="token number">1700880810</span><span class="token punctuation">,</span>
    <span class="token string-property property">"client_id"</span><span class="token operator">:</span> <span class="token string">"web"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h4><a id="32__Resource_Owner_Password_Credentials_214"></a>🍀3.2 密码模式 (Resource Owner Password Credentials)</h4> 
<p>接着我们来测试密码模式，我们在请求体 Body 中提供具体的用户名和密码：<br> <img src="https://images2.imgbox.com/c2/cc/bZyOSCQ5_o.png" alt="在这里插入图片描述"><br> 同时还要在请求头 Authorization 中添加 <code>Basic Auth</code> 验证信息，参数是客户端的 id 和 secret：<br> <img src="https://images2.imgbox.com/d7/b0/NtCzKWRI_o.png" alt="在这里插入图片描述"><br> 当我们发起请求时会自动生成 Basic 验证相关内容，实际上请求头中携带的参数如下示例：<br> <img src="https://images2.imgbox.com/c6/3f/VkL9aSwc_o.png" alt="在这里插入图片描述"><br> 响应成功，得到 Token 信息，并且这里还多出了一个 <code>refresh_token</code>，这是用于刷新 Token 的，我们之后会进行讲解。</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"access_token"</span><span class="token operator">:</span> <span class="token string">"8f87d827-6ae9-4709-8ba5-d300f4db3b8a"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"token_type"</span><span class="token operator">:</span> <span class="token string">"bearer"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"refresh_token"</span><span class="token operator">:</span> <span class="token string">"58632c51-1e63-4f33-a696-81bd76bf520c"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"expires_in"</span><span class="token operator">:</span> <span class="token number">43199</span><span class="token punctuation">,</span>
    <span class="token string-property property">"scope"</span><span class="token operator">:</span> <span class="token string">"book user borrow"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当我们查询 Token 信息时，还可以看到登录的具体用户以及角色权限等。</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"active"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token string-property property">"exp"</span><span class="token operator">:</span> <span class="token number">1700882988</span><span class="token punctuation">,</span>
    <span class="token string-property property">"user_name"</span><span class="token operator">:</span> <span class="token string">"wsy"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"authorities"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token string">"ROLE_admin"</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string-property property">"client_id"</span><span class="token operator">:</span> <span class="token string">"web"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"scope"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token string">"book"</span><span class="token punctuation">,</span>
        <span class="token string">"user"</span><span class="token punctuation">,</span>
        <span class="token string">"borrow"</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h4><a id="33__Implicit_Grant_251"></a>🍀3.3 隐式授权模式 (Implicit Grant)</h4> 
<p>接着我们来看隐式授权模式，这种模式我们需要在验证服务器上进行登录操作，而不是直接请求Token。<strong>我们可以直接在网页中访问</strong>：<code>http://localhost:8500/sso/oauth/authorize?client_id=web&amp;response_type=token</code></p> 
<p><strong>注意 response_type 一定要是 token 类型，这样才会直接返回 Token</strong>。当浏览器发起请求后，可以看到熟悉而又陌生的界面，没错，这就是我们在 auth-service 模块中引入的 security 帮我们实现了登录功能：<br> <img src="https://images2.imgbox.com/77/6b/NGjyiJ3M_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>但是登录之后我们发现返回了一个错误</strong>：<font color="red">“必须至少向客户端注册一个redirect_uri”</font><br> <img src="https://images2.imgbox.com/fb/ca/Pnb3f6TZ_o.png" alt="在这里插入图片描述"><br> <strong>原因</strong>：这是因为登录成功之后，验证服务器需要将结果返回给客户端，所以需要在配置文件中设置客户端的回调地址。这样浏览器就会被重定向到指定的回调地址，并且请求中会携带 Token 信息。</p> 
</blockquote> 
<p>现在我们在 <code>OAuth2Configuration</code> 配置类中设置回调地址 <code>redirectUris</code>:</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">ClientDetailsServiceConfigurer</span> clients<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
    clients
            <span class="token punctuation">.</span><span class="token function">inMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">withClient</span><span class="token punctuation">(</span><span class="token string">"web"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">secret</span><span class="token punctuation">(</span>encoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"654321"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">autoApprove</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">scopes</span><span class="token punctuation">(</span><span class="token string">"book"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"borrow"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">redirectUris</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8081/book/1"</span><span class="token punctuation">)</span> <span class="token comment">// 可以写多个，当有多个时需要在验证请求中指定使用哪个地址进行回调</span>
            <span class="token punctuation">.</span><span class="token function">authorizedGrantTypes</span><span class="token punctuation">(</span><span class="token string">"client_credentials"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">,</span> <span class="token string">"implicit"</span><span class="token punctuation">,</span> <span class="token string">"authorization_code"</span><span class="token punctuation">,</span> <span class="token string">"refresh_token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>接着重启验证服务器，再次访问可以看到这里会让我们选择哪些范围进行授权：<br> <img src="https://images2.imgbox.com/bd/fa/2GDoYQwV_o.png" alt="在这里插入图片描述"><br> 当我们点击授权后，会跳转到我们指定的客户端回调地址，并且在url中携带了 token 信息 (包括 Token值、Token类型、过期时间、作用域)。<br> <img src="https://images2.imgbox.com/ce/4d/EPFStGxp_o.png" alt="在这里插入图片描述"><br> 同样可以检验一下 Token 是否有效：</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"active"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token string-property property">"exp"</span><span class="token operator">:</span> <span class="token number">1700942201</span><span class="token punctuation">,</span>
    <span class="token string-property property">"user_name"</span><span class="token operator">:</span> <span class="token string">"wsy"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"authorities"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token string">"ROLE_admin"</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string-property property">"client_id"</span><span class="token operator">:</span> <span class="token string">"web"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"scope"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token string">"book"</span><span class="token punctuation">,</span>
        <span class="token string">"borrow"</span><span class="token punctuation">,</span>
        <span class="token string">"user"</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h4><a id="34__Authrization_Code_297"></a>🍀3.4 授权码模式 (Authrization Code)</h4> 
<p>最后我们来看看最安全的授权码模式，这种模式其实流程和上面是一样的，但是请求的是 code 类型：<code>http://localhost:8500/sso/oauth/authorize?client_id=web&amp;response_type=code</code></p> 
<p>当我们把上面隐式授权模式的登录流程走完后，我们回调后的地址如下，可以看到此时的 URL 中没有传递 Token，而是授权码 <code>code</code>，<strong>每次回调的 code 值并不一样</strong>。<br> <img src="https://images2.imgbox.com/2a/12/2lK7KOD5_o.png" alt="在这里插入图片描述"></p> 
<p>按照我们之前讲解的原理，我们需要携带授权码和 secret 一起请求，才能拿到 Token，正常情况下是由回调的服务器进行处理，这里我们就在 Postman 中进行，我们复制刚刚得到的授权码，接口依然是<code>http://localhost:8500/sso/oauth/token</code><br> <img src="https://images2.imgbox.com/9e/8c/sQni8t7O_o.png" alt="在这里插入图片描述"><br> 可以看到结果也是正常返回了 Token 信息：</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"access_token"</span><span class="token operator">:</span> <span class="token string">"950e9bdd-3525-4e78-acf7-f86e97d3ed01"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"token_type"</span><span class="token operator">:</span> <span class="token string">"bearer"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"refresh_token"</span><span class="token operator">:</span> <span class="token string">"4d8ee0cc-6bae-4c71-8666-0d86e78fc0ff"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"expires_in"</span><span class="token operator">:</span> <span class="token number">42331</span><span class="token punctuation">,</span>
    <span class="token string-property property">"scope"</span><span class="token operator">:</span> <span class="token string">"book borrow user"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样我们四种最基本的 Token 请求方式就实现了。</p> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h4><a id="35__320"></a>🍀3.5 令牌刷新</h4> 
<p>当我们的 Token 过期时，我们就可以使用这个 <code>refresh_token</code> 来申请一个新的 Token：<br> <img src="https://images2.imgbox.com/ec/cd/Jxl92ujx_o.png" alt="在这里插入图片描述"><br> 但是执行之后我们发现会直接出现一个内部错误：</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
	<span class="token string-property property">"error"</span><span class="token operator">:</span> <span class="token string">"server_error"</span><span class="token punctuation">,</span>
	<span class="token string-property property">"error_description"</span><span class="token operator">:</span> <span class="token string">"Internal Server Error"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/9f/9f/YD80iu4F_o.png" alt="在这里插入图片描述"><br> 我们需要在 SecurityConfiguration 配置类中添加一个 <code>UserDetailsService</code> 配置，并注册为 Bean：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">UserDetailsService</span> <span class="token function">userDetailsServiceBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">userDetailsServiceBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 上面已经配置好了</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>然后在 OAuth2Configuration 配置类的 <code>Endpoint</code> 中添加一条：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Resource</span>
<span class="token class-name">UserDetailsService</span> service<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">AuthorizationServerEndpointsConfigurer</span> endpoints<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    endpoints
            <span class="token punctuation">.</span><span class="token function">userDetailsService</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span> <span class="token comment">// 新增的配置</span>
            <span class="token punctuation">.</span><span class="token function">authenticationManager</span><span class="token punctuation">(</span>manager<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>最后再次尝试刷新 Token：</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"access_token"</span><span class="token operator">:</span> <span class="token string">"857f57b5-34a6-47c9-9971-203b75885bec"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"token_type"</span><span class="token operator">:</span> <span class="token string">"bearer"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"refresh_token"</span><span class="token operator">:</span> <span class="token string">"4d8ee0cc-6bae-4c71-8666-0d86e78fc0ff"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"expires_in"</span><span class="token operator">:</span> <span class="token number">43200</span><span class="token punctuation">,</span>
    <span class="token string-property property">"scope"</span><span class="token operator">:</span> <span class="token string">"book borrow user"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>OK，成功刷新 Token，返回了一个新的。</p> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h3><a id="_EnableOAuth2Sso__367"></a>四、基于 @EnableOAuth2Sso 实现</h3> 
<p>前面我们将验证服务器已经搭建完成了，现在我们<strong>将我们的服务作为单点登录应用</strong>直接实现单点登录，SpringCloud 为我们提供了<strong>客户端</strong>的直接实现，我们只需要添加一个注解和少量配置即可将我们的服务作为一个单点登陆应用，使用的是第四种<strong>授权码模式</strong>。</p> 
<p><font color="red">一句话来说就是，这种模式只是将验证方式由原本的默认登录形式改变为了统一在授权服务器登录的形式。</font></p> 
<h4><a id="41__372"></a>🍇4.1 微服务实现单点登录</h4> 
<p>①首先 bookService、userService、borrowService 三个客户端添加依赖：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-security<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-oauth2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>②在客户端的启动类上添加 <code>@EnableOAuth2Sso</code> 注解：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@EnableOAuth2Sso</span>
<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookApplication</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">BookApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>③客户端的配置文件：</p> 
<pre><code class="prism language-yml"><span class="token key atrule">security</span><span class="token punctuation">:</span>
  <span class="token key atrule">oauth2</span><span class="token punctuation">:</span>
    <span class="token key atrule">client</span><span class="token punctuation">:</span>
      <span class="token comment">#不多说了</span>
      <span class="token key atrule">client-id</span><span class="token punctuation">:</span> web
      <span class="token key atrule">client-secret</span><span class="token punctuation">:</span> <span class="token number">654321</span>
      <span class="token comment">#Token获取地址</span>
      <span class="token key atrule">access-token-uri</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8500/sso/oauth/token
      <span class="token comment">#验证页面地址</span>
      <span class="token key atrule">user-authorization-uri</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8500/sso/oauth/authorize
    <span class="token key atrule">resource</span><span class="token punctuation">:</span>
      <span class="token comment">#Token信息获取和校验地址</span>
      <span class="token key atrule">token-info-uri</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8500/sso/oauth/check_token
</code></pre> 
<p>④此时我们还要修改 <code>OAuth2Configuration</code> 配置类中的回调地址 <code>redirectUris</code>: <font color="#999999">改为 Security 帮我们实现的 /login</font></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">ClientDetailsServiceConfigurer</span> clients<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
    clients
            <span class="token punctuation">.</span><span class="token function">inMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">withClient</span><span class="token punctuation">(</span><span class="token string">"web"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">secret</span><span class="token punctuation">(</span>encoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"654321"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">autoApprove</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">scopes</span><span class="token punctuation">(</span><span class="token string">"book"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"borrow"</span><span class="token punctuation">)</span>
            <span class="token comment">// 因为3个服务都添加 Security，而 Security 的默认登录地址为 /login</span>
            <span class="token punctuation">.</span><span class="token function">redirectUris</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8081/login"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost:8082/login"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost:8083/login"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">authorizedGrantTypes</span><span class="token punctuation">(</span><span class="token string">"client_credentials"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">,</span> <span class="token string">"implicit"</span><span class="token punctuation">,</span> <span class="token string">"authorization_code"</span><span class="token punctuation">,</span> <span class="token string">"refresh_token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="red">如果不修改回调地址，则通过验证服务器后会产生如下报错：<font color="#999999">不知为何 OAuth 会自动回调到 /login 地址</font><br> <img src="https://images2.imgbox.com/b0/24/ntx9uQg5_o.png" alt="在这里插入图片描述"></font></p> 
<p>⑤重启所有服务后，我们可以尝试访问图书服务接口：<code>http://localhost:8081/book/5</code>，它会给我们重定向到验证服务器让我们登录 <code>http://localhost:8500/sso/login</code><br> <img src="https://images2.imgbox.com/55/75/Y2tLg1ML_o.png" alt="在这里插入图片描述"><br> 登录后，它又将我们重定向到该页面，我们可以给访问页面进行授权：<br> <img src="https://images2.imgbox.com/29/09/8drKfMpc_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到在发现没有登录验证时，会直接跳转到授权页面，进行授权登录，之后才可以继续访问图书服务：<br> <img src="https://images2.imgbox.com/6b/3f/Bien41on_o.png" alt="在这里插入图片描述"></p> 
<p>那么用户信息呢？是否也一并保存过来了？我们这里直接获取一下 <code>SpringSecurity</code> 的 Context 查看用户信息：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/book/{bid}"</span><span class="token punctuation">)</span>
<span class="token class-name">Book</span> <span class="token function">findBookById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"bid"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> bid<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  	<span class="token comment">//通过SecurityContextHolder将用户信息取出</span>
    <span class="token class-name">SecurityContext</span> context <span class="token operator">=</span> <span class="token class-name">SecurityContextHolder</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> service<span class="token punctuation">.</span><span class="token function">getBookById</span><span class="token punctuation">(</span>bid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到信息：<br> <img src="https://images2.imgbox.com/39/d9/JGJbVSU1_o.png" alt="在这里插入图片描述"><br> 这里使用的不是之前的<code>UsernamePasswordAuthenticationToken</code>也不是<code>RememberMeAuthenticationToken</code>，而是新的<code>OAuth2Authentication</code>，它保存了验证服务器的一些信息，以及经过我们之前的登陆流程之后，验证服务器发放给客户端的 Token 信息，并通过 Token 信息在验证服务器进行验证获取用户信息，最后保存到 Session 中，表示用户已验证，所以本质上还是要依赖浏览器存 Cookie 的。</p> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h4><a id="42_SESSION__454"></a>🍇4.2 SESSION 不同步问题</h4> 
<p><font color="orange">但是我们发现一个问题，就是由于SESSION不同步，每次切换不同的服务进行访问都会重新导验证服务器去验证一次：</font></p> 
<p><img src="https://images2.imgbox.com/8e/77/urnFPbYa_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9b/fa/EOpmu6lh_o.png" alt="在这里插入图片描述"></p> 
<p><strong>解决方案：</strong><br>  <strong>方案一</strong>：像之前一样做 SESSION 统一存储<br>  <strong>方案二</strong>：设置 <code>context-path</code> 路径，每个服务单独设置，就不会打架了</p> 
<p><font color="blue">但是这样依然没法解决服务间调用的问题，所以仅仅依靠单点登录的模式不太行。</font> 我们下面将会使用 @EnableResourceServer 解决远程调用的问题。<br> <img src="https://images2.imgbox.com/d2/ab/CPEDLRx7_o.png" alt="在这里插入图片描述"></p> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h3><a id="_EnableResourceServer___470"></a>五、基于 @EnableResourceServer 实现 🚩</h3> 
<p>前面我们讲解了将我们的服务作为单点登录应用直接实现单点登录，那么现在我们如果是<strong>以第三方应用进行访问</strong>呢？这时我们就需要<strong>将我们的服务作为资源服务</strong>了，作为资源服务就不会再提供验证的过程，而是直接要求请求时携带 Token，而验证过程我们这里就继续用 Apifox 来完成，这才是我们常见的模式。</p> 
<p><font color="red">一句话来说，跟上面相比，我们只需要携带 Token 就能访问这些资源服务器了，客户端被独立了出来，用于携带 Token 去访问这些服务。</font></p> 
<h4><a id="51__475"></a>🍬5.1 资源服务器</h4> 
<p>①首先还是给3个客户端添加依赖 (之前已经添加了)：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-security<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-oauth2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>②在客户端的启动类上添加 <code>@EnableResourceServer</code> 注解：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@EnableResourceServer</span>
<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookApplication</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">BookApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>③客户端的配置文件：</p> 
<pre><code class="prism language-yml"><span class="token key atrule">security</span><span class="token punctuation">:</span>
  <span class="token key atrule">oauth2</span><span class="token punctuation">:</span>
    <span class="token key atrule">client</span><span class="token punctuation">:</span>
      <span class="token key atrule">client-id</span><span class="token punctuation">:</span> web
      <span class="token key atrule">client-secret</span><span class="token punctuation">:</span> <span class="token number">654321</span>
    <span class="token key atrule">resource</span><span class="token punctuation">:</span>
    	<span class="token comment"># 因为资源服务器得验证你的Token是否有访问此资源的权限以及用户信息，所以只需要一个验证地址</span>
      <span class="token key atrule">token-info-uri</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8500/sso/oauth/check_token
</code></pre> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h4><a id="52__512"></a>🍬5.2 客户端访问</h4> 
<p>①配置完成后，我们启动服务器，直接访问会发现：<br> <img src="https://images2.imgbox.com/47/3b/ZUpDI2yu_o.png" alt="在这里插入图片描述"></p> 
<p>②这是由于我们的请求头中<strong>没有携带 Token 信息</strong> (可以采用 <a href="#password" rel="nofollow">密码模式</a> 或 <a href="#client" rel="nofollow">客户端模式</a> 获取 Token)。然后再访问资源：</p> 
<ul><li> <p><strong>方案一</strong>：直接在 URL 后面携带 Token <code>http://localhost:8081/book/1?access_token=287d5e9c-7e8c-4d4d-b8b0-c45530f0641a</code>。<br> <img src="https://images2.imgbox.com/ab/45/XKu31w76_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>方案二</strong>：在请求头中添加 <code>Authorization</code>，值为 <code>Bearer + Token</code> 值<br> <img src="https://images2.imgbox.com/60/b6/Qnztuq9v_o.png" alt="在这里插入图片描述"><br> 访问成功：<br> <img src="https://images2.imgbox.com/6c/82/Vhze5w9H_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<p>③我们还可以<strong>对资源服务器进行深度自定义</strong>，例如我们在 bookService 服务中添加一个配置类 <code>ResourceConfiguration.java</code>，希望用户授权了某个 <code>Scope</code> 权限才可以访问此服务：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResourceConfiguration</span> <span class="token keyword">extends</span> <span class="token class-name">ResourceServerConfigurerAdapter</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//继承此类进行高度自定义</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">HttpSecurity</span> http<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">//这里也有HttpSecurity对象，方便我们配置SpringSecurity</span>
        http
                <span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">access</span><span class="token punctuation">(</span><span class="token string">"#oauth2.hasScope('book')"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//添加自定义规则</span>
      					<span class="token comment">//Token必须要有我们自定义scope授权才可以访问此资源</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>配置文件中的权限一定要对应在 client 中设置的权限：<br> <img src="https://images2.imgbox.com/f7/2d/eR2Ot5Ud_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到当没有对应的 scope 授权时，那么会直接返回 <code>insufficient_scope</code> 错误：<br> <img src="https://images2.imgbox.com/71/91/4dFUGFq8_o.png" alt="在这里插入图片描述"></p> 
<p>④尝试获取 Session 中的 Security 信息：<strong>运行访问会报错</strong></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/book/{bid}"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Book</span> <span class="token function">findBookById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"bid"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> bid<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 通过SecurityContextHolder将用户信息取出</span>
    <span class="token class-name">SecurityContext</span> context <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SecurityContext</span><span class="token punctuation">)</span> session<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"SPRING_SECURITY_CONTEXT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> bookService<span class="token punctuation">.</span><span class="token function">getBookById</span><span class="token punctuation">(</span>bid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="deeppink">可以发现，实际上资源服务器完全没有必要将 Security 的信息保存在 Session 中了，因为现在只需要将 Token 告诉资源服务器，那么资源服务器就可以联系验证服务器，得到用户信息，就不需要使用之前的 Session 存储机制了，所以你会发现 HttpSession 中没有 <code>SPRING_SECURITY_CONTEXT</code>，现在 Security 信息都是通过连接资源服务器获取。</font></p> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h4><a id="53__568"></a>🍬5.3 解决远程调用</h4> 
<p><font color="orang"><strong>方案一</strong>：使用 <code>OAuth2RestTemplate</code> 远程调用</font></p> 
<p>如果我们没有将服务注册到 Nacos 中，而是采用传统的 <code>RestTemplate</code> 实现的远程调用。则此时我们可以直接改用 <code>OAuth2RestTemplate</code>，它继承自 <code>RestTemplate</code>，会在请求其他服务时携带当前请求的 Token 信息。</p> 
<p>①先搞个配置文件注册 Bean</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RestTemplateConfig</span> <span class="token punctuation">{<!-- --></span>
    
    <span class="token annotation punctuation">@Resource</span>
    <span class="token class-name">OAuth2ClientContext</span> context<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@LoadBalanced</span>  <span class="token comment">// 负载均衡</span>
    <span class="token keyword">public</span> <span class="token class-name">OAuth2RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OAuth2RestTemplate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClientCredentialsResourceDetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>②远程调用时替换掉 <code>RestTemplate</code> 即可：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BorrowServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BorrowService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">BorrowMapper</span> borrowMapper<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">OAuth2RestTemplate</span> restTemplate<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">UserBorrowView</span> <span class="token function">getBorrowViewByUid</span><span class="token punctuation">(</span><span class="token keyword">int</span> uid<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Borrow</span><span class="token punctuation">&gt;</span></span> borrowList <span class="token operator">=</span> borrowMapper<span class="token punctuation">.</span><span class="token function">getBorrowsByUid</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token string">"http://userservice/user/"</span> <span class="token operator">+</span> uid<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> bookList <span class="token operator">=</span> borrowList
                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>b <span class="token operator">-&gt;</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token string">"http://bookservice/book/"</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">getBid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Book</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserBorrowView</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> bookList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到服务成功调用了：<strong>同样，请求头中必须携带 Token 信息</strong><br> <img src="https://images2.imgbox.com/a9/b6/s4LfGcqT_o.png" alt="在这里插入图片描述"></p> 
<p><font color="orang"><strong>方案二</strong>：通过 <code>Feign</code> 实现远程调用</font></p> 
<p>如果我们都为服务注册到 Nacos 中，并且采用 Feign 实现了远程调用。则我们可以直接开启 Feign 对 OAuth 的支持，<strong>官方教程</strong>：<a href="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#oauth2-support" rel="nofollow">https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#oauth2-support</a>，只需要在 borrowService 服务中添加如下配置即可：</p> 
<pre><code class="prism language-yml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>
  <span class="token key atrule">oauth2</span><span class="token punctuation">:</span>
  	<span class="token comment"># 开启Oauth支持，这样就会在请求头中携带Token了</span>
    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token comment"># 同时开启负载均衡支持</span>
    <span class="token key atrule">load-balanced</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre> 
<p>重启服务器，可以看到结果OK了：<br> <img src="https://images2.imgbox.com/df/3c/EQvxWblc_o.png" alt="在这里插入图片描述"></p> 
<p>这样我们就成功将之前的三个服务作为资源服务器了，然后让 <font color="#999AAA">(浏览器、小程序、App、第三方服务等)</font> 作为客户端来访问，并且也是需要先去验证服务器进行验证然后再通过携带 Token 进行访问，<strong>这种模式是我们比较常见的模式</strong>。</p> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h3><a id="_JWT__Token_633"></a>六、使用 JWT 存储 Token</h3> 
<p><font color="red"><strong>官网</strong>：<a href="https://jwt.io" rel="nofollow">https://jwt.io</a></font></p> 
<p>JSON Web Token 令牌（<code>JWT</code>）是一个开放标准（RFC 7519），它定义了一种紧凑和自成一体的方式，用于在各方之间作为 JSON 对象安全地传输信息。这些信息可以被验证和信任，因为它是数字签名的。JWT 可以使用密钥（使用 HMAC 算法）或使用 RSA 或 ECDSA 进行公钥/私钥对进行签名。</p> 
<p>实际上，我们之前都是携带 Token 向资源服务器发起请求后，资源服务器由于不知道我们 Token 的用户信息，所以需要向验证服务器询问此 Token 的认证信息，这样才能得到 Token 代表的用户信息，但是各位是否考虑过，如果每次用户请求都去查询用户信息，那么在大量请求下，验证服务器的压力可能会非常的大。而使用 JWT 之后，Token 中会直接保存用户信息，这样资源服务器就不再需要询问验证服务器，自行就可以完成解析，我们的目标是不联系验证服务器就能直接完成验证。</p> 
<p><font color="red"><strong>JWT 令牌的格式如下：</strong></font><br> <img src="https://images2.imgbox.com/76/54/PinA1JC2_o.png" alt="在这里插入图片描述"></p> 
<p><font color="red">一个 JWT 令牌由<strong>三部分组成</strong>：标头(<code>Header</code>)、有效载荷(<code>Payload</code>) 和 签名(<code>Signature</code>)。</font>在传输的时候，会将 JWT 的3部分分别进行 Base64 编码后进行连接形成最终需要传输的字符串。</p> 
<ul><li><strong>标头</strong>：包含一些元数据信息，比如 JWT 签名所使用的加密算法，还有类型，这里统一都是 JWT。</li><li><strong>有效载荷</strong>：包括用户名称、令牌发布时间、过期时间、JWT ID 等，当然我们也可以自定义添加字段，我们的用户信息一般都在这里存放。</li><li><strong>签名</strong>：首先需要指定一个密钥，该密钥仅仅保存在服务器中，保证不能让其他用户知道。然后使用 Header 中指定的算法对 Header 和 Payload 进行 base64 加密之后的结果通过密钥计算哈希值，然后就得出一个签名哈希。这个会用于之后验证内容是否被篡改。</li></ul> 
<blockquote> 
 <p><font color="red"><strong>知识补充</strong>：</font></p> 
 <ol><li><strong>Base64</strong>：就是包括<code>小写字母a-z</code>、<code>大写字母A-Z</code>、<code>数字0-9</code>、<code>符号"+"</code>、<code>"/"</code> 一共 64 个字符的字符集（末尾还有1个或多个 <code>=</code> 用来凑够字节数），任何的符号都可以转换成这个字符集中的字符，这个转换过程就叫做 <code>Base64编码</code>，编码之后会生成只包含上述 64 个字符的字符串。相反，如果需要原本的内容，我们也可以进行 <code>Base64解码</code>，回到原有的样子。<br> <img src="https://images2.imgbox.com/7c/44/d8lc69nl_o.png" alt="在这里插入图片描述"><br> 注意：Base64 不是加密算法，只是一种信息的编码方式而已。<br> <br></li><li><strong>加密算法</strong>：加密算法分为对称加密和非对称加密，其中对称加密（Symmetric Cryptography）比较好理解，就像一把锁配了两把钥匙一样，这两把钥匙你和别人都有一把，然后你们直接传递数据，都会把数据用锁给锁上，就算传递的途中有人把数据窃取了，也没办法解密，因为钥匙只有你和对方有，没有钥匙无法进行解密，但是这样有个问题，既然解密的关键在于钥匙本身，那么如果有人不仅窃取了数据，而且对方那边的治安也不好，于是顺手就偷走了钥匙，那你们之间发的数据不就凉凉了吗。<br><br> 因此，<strong>非对称加密（Asymmetric Cryptography）</strong> 算法出现了，它并不是直接生成一把钥匙，而是生成一个公钥和一个私钥，私钥只能由你保管，而公钥交给对方或是你要发送的任何人都行，现在你需要把数据传给对方，那么就需要使用私钥进行加密，但是，这个数据只能使用对应的公钥进行解密，相反，如果对方需要给你发送数据，那么就需要用公钥进行加密，而数据只能使用私钥进行解密，这样的话就算对方的公钥被窃取，那么别人发给你的数据也没办法解密出来，因为需要私钥才能解密，而只有你才有私钥。<br><br> 因此，非对称加密的安全性会更高一些，包括HTTPS的隐私信息正是使用非对称加密来保障传输数据的安全（当然HTTPS并不是单纯地使用非对称加密完成的，感兴趣的可以去了解一下）<br><br> 对称加密和非对称加密都有很多的算法，比如对称加密，就有：DES、IDEA、RC2，非对称加密有：RSA、DAS、ECC<br> <br></li><li><strong>不可逆加密算法</strong>：常见的不可逆加密算法有MD5, HMAC, SHA-1, SHA-224, SHA-256, SHA-384, 和SHA-512, 其中SHA-224、SHA-256、SHA-384，和SHA-512我们可以统称为SHA2加密算法，SHA加密算法的安全性要比MD5更高，而SHA2加密算法比SHA1的要高，其中SHA后面的数字表示的是加密后的字符串长度，SHA1默认会产生一个160位的信息摘要。经过不可逆加密算法得到的加密结果，是无法解密回去的，也就是说加密出来是什么就是什么了。本质上，其就是一种哈希函数，用于对一段信息产生摘要，以防止被篡改。<br><br> 实际上这种算法就常常被用作信息摘要计算，同样的数据通过同样的算法计算得到的结果肯定也一样，而如果数据被修改，那么计算的结果肯定就不一样了。</li></ol> 
</blockquote> 
<p>这里我们就可以利用 jwt，将我们的 Token 采用新的方式进行存储：<br> <img src="https://images2.imgbox.com/3c/35/UWVv6xta_o.png" alt="在这里插入图片描述"></p> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h4><a id="61__667"></a>🍒6.1 验证服务器</h4> 
<p>这里我们使用最简单的一种方式，对称密钥，我们需要对验证服务器的配置进行修改：</p> 
<p>①向 <code>SecurityConfiguration.java</code> 配置类添加两个 <code>Bean</code>：<font color="#999999">(这里设置的密钥待会儿要和资源服务器对应)</font></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"tokenConverter"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">JwtAccessTokenConverter</span> <span class="token function">tokenConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">// Token转换器，将其转换为JWT</span>
    <span class="token class-name">JwtAccessTokenConverter</span> converter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JwtAccessTokenConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    converter<span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span><span class="token string">"wsyKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 这个是对称密钥，一会资源服务器那边也要指定为这个</span>
    <span class="token keyword">return</span> converter<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">TokenStore</span> <span class="token function">tokenStore</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"tokenConverter"</span><span class="token punctuation">)</span> <span class="token class-name">JwtAccessTokenConverter</span> converter<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">// Token存储方式现在改为JWT存储</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JwtTokenStore</span><span class="token punctuation">(</span>converter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 传入刚刚定义好的转换器</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>②向 <code>OAuth2Configuration.java</code> 配置类修改和添加配置方法：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Resource</span>
<span class="token class-name">TokenStore</span> store<span class="token punctuation">;</span>
<span class="token annotation punctuation">@Resource</span>
<span class="token class-name">JwtAccessTokenConverter</span> converter<span class="token punctuation">;</span>

<span class="token comment">// 添加新的配置方法</span>
<span class="token keyword">private</span> <span class="token class-name">AuthorizationServerTokenServices</span> <span class="token function">serverTokenServices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">// 这里对AuthorizationServerTokenServices进行一下配置</span>
    <span class="token class-name">DefaultTokenServices</span> services <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultTokenServices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    services<span class="token punctuation">.</span><span class="token function">setSupportRefreshToken</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 允许Token刷新</span>
    services<span class="token punctuation">.</span><span class="token function">setTokenStore</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 添加刚刚的TokenStore</span>
    services<span class="token punctuation">.</span><span class="token function">setTokenEnhancer</span><span class="token punctuation">(</span>converter<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 添加Token增强，其实就是JwtAccessTokenConverter，增强是添加一些自定义的数据到JWT中</span>
    <span class="token keyword">return</span> services<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 修改原来的配置方法</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">AuthorizationServerEndpointsConfigurer</span> endpoints<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    endpoints
            <span class="token punctuation">.</span><span class="token function">tokenServices</span><span class="token punctuation">(</span><span class="token function">serverTokenServices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//设定为刚刚配置好的AuthorizationServerTokenServices</span>
            <span class="token punctuation">.</span><span class="token function">userDetailsService</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">authenticationManager</span><span class="token punctuation">(</span>manager<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>然后我们就可以重启验证服务器，并采用 <a href="#password" rel="nofollow">密码模式</a> 或 <a href="#client" rel="nofollow">客户端模式</a> 获取 Token：<code>http://localhost:8500/sso/oauth/token</code></p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"access_token"</span><span class="token operator">:</span> <span class="token string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzY29wZSI6WyJib29rIiwidXNlciIsImJvcnJvdyJdLCJleHAiOjE3MDA5NTIzMTUsImp0aSI6IjZlMjFhM2YzLWIyZDYtNDMyYy1hYTUwLTdkOWMwMWFjYWM3MCIsImNsaWVudF9pZCI6IndlYiJ9.pGGyJ6t38IfGku9E8MMw8AcNvrAb3Tq249-4Ke5brIo"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"token_type"</span><span class="token operator">:</span> <span class="token string">"bearer"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"expires_in"</span><span class="token operator">:</span> <span class="token number">43199</span><span class="token punctuation">,</span>
    <span class="token string-property property">"scope"</span><span class="token operator">:</span> <span class="token string">"book user borrow"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"jti"</span><span class="token operator">:</span> <span class="token string">"6e21a3f3-b2d6-432c-aa50-7d9c01acac70"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到成功获取了 AccessToken，但是这里的格式跟我们之前的格式就大不相同了，因为现在它是 <code>JWT</code> 令牌，我们可以对其进行一下 Base64解码：<br> <img src="https://images2.imgbox.com/b9/24/3Zmg9IYL_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="62__723"></a>🍒6.2 资源服务器</h4> 
<p><strong>现在我们对三个资源服务器进行配置</strong>：将之前的 security 配置更换如下</p> 
<pre><code class="prism language-yml"><span class="token key atrule">security</span><span class="token punctuation">:</span>
  <span class="token key atrule">oauth2</span><span class="token punctuation">:</span>
    <span class="token key atrule">resource</span><span class="token punctuation">:</span>
      <span class="token key atrule">jwt</span><span class="token punctuation">:</span>
        <span class="token key atrule">key-value</span><span class="token punctuation">:</span> wsyKey <span class="token comment"># 注意这里要跟验证服务器的密钥一致，这样算出来的签名才会一致</span>
</code></pre> 
<p>重启资源服务器，调用接口发现：访问成功！<br> <img src="https://images2.imgbox.com/57/93/pUWqkUen_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bb/65/uy1JoFS2_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="63___737"></a>🍒6.3 令牌中继 (远程调用)</h4> 
<p>如果我们直接用 <code>JWT</code> 进行远程调用时，就会发现如下报错：<font color="red">访问此资源需要完全身份验证</font></p> 
<pre><code class="prism language-java"><span class="token class-name"><span class="token namespace">feign<span class="token punctuation">.</span></span>FeignException</span>$<span class="token class-name">Unauthorized</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">401</span><span class="token punctuation">]</span> during <span class="token punctuation">[</span><span class="token constant">GET</span><span class="token punctuation">]</span> <span class="token keyword">to</span> <span class="token punctuation">[</span>http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>userservice<span class="token operator">/</span>user<span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token class-name">UserClient</span>#<span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token string">"error"</span><span class="token operator">:</span><span class="token string">"unauthorized"</span><span class="token punctuation">,</span><span class="token string">"error_description"</span><span class="token operator">:</span><span class="token string">"Full authentication is required to access this resource"</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
</code></pre> 
<p>所以我们需要在 borrowservice 模块添加一个拦截器 <code>RequestInterceptorConfig.java</code>，实现<strong>令牌中继</strong>。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestInterceptorConfig</span> <span class="token keyword">implements</span> <span class="token class-name">RequestInterceptor</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">RequestTemplate</span> requestTemplate<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">OAuth2AuthenticationDetails</span> details <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">OAuth2AuthenticationDetails</span><span class="token punctuation">)</span>
                <span class="token class-name">SecurityContextHolder</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        requestTemplate<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Authorization"</span><span class="token punctuation">,</span><span class="token string">"Bearer"</span> <span class="token operator">+</span> details<span class="token punctuation">.</span><span class="token function">getTokenValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>request Headers 标准的请求头</strong></p> 
 <ul><li><strong>Authorization</strong>：在HTTP中，服务器可以对一些资源进行认证保护，如果你要访问这些资源，就要提供用户名和密码，这个用户名和密码就是在 Authorization 头中附带的，格式是 <code>Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9......</code><br> <br></li></ul> 
 <p><strong>JWT 授权为啥要在 Authorization 标头里加个 Bearer 呢?</strong></p> 
 <ul><li>设计 API 授权，或者调用第三方 API 时，经常会接触到：<code>Authorization : Bearer Token</code></li><li>这是因为 W3C 的 HTTP 1.0 规范格式是：<code>Authorization: &lt;type&gt; &lt;authorization-parameters&gt;</code><br> <br></li></ul> 
 <p><strong>所以 <code>Bearer</code> 是授权的类型，常见的授权类型还有：</strong></p> 
 <ul><li>Basic 用于 http-basic 认证；</li><li>Bearer 常见于 OAuth 和 JWT 授权；</li><li>Digest MD5 哈希的 http-basic 认证 (已弃用)</li><li>AWS4-HMAC-SHA256 AWS 授权<br> <br></li></ul> 
 <p><strong>JWT官方推荐格式</strong>：<a href="https://jwt.io/introduction/" rel="nofollow">https://jwt.io/introduction</a></p> 
</blockquote> 
<p>再次重启，访问资源：远程调用成功！<br> <img src="https://images2.imgbox.com/dc/bd/Lz95JkCS_o.png" alt="在这里插入图片描述"></p> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<h2><a id="_779"></a>总结</h2> 
<p><strong>简单地说，cookie、session、token (JWT)之间的关系？</strong></p> 
<ol><li>当用户在浏览器登录一个网站后，服务器会生成一个 session，并将 Session ID 发给浏览器。</li><li>浏览器 (客户端) 下次访问该网站的任何页面时，会把 Session ID 放入 cookie 中，发给服务器。</li><li>服务器收到后，会查看内存中是否有该 session。如果有，则可以浏览，反之重新登录。<font color="red">但是这种模式只适合单服务器，多服务器就没法查了。如果做Session服务器又怕单点失效，集群效率又低。</font></li><li><strong>此时，token 就可以解决这个问题。</strong> 当用户登录后，服务器直接提供给浏览器一个 token。下次浏览器访问任何一个服务时，只需要提供这个 token 就可以了。</li><li>token 是经过服务器签名的，任何服务器都可以识别出这个签名。</li></ol> 
<br> 
<p><strong>OAuth2.0 如何实现第三方登录授权？</strong></p> 
<ol><li>假如现在你想登录小红书，但又不想注册，你可以选择<strong>使用微信登录</strong>，此时就发起了 OAuth2.0 的授权流程。</li><li>此时，小红书会带着相关证明向微信申请获取该用户的资料许可。</li><li>微信审核通过后，会发给小红书一个 token 令牌。</li><li>小红书就可以拿着这个 token 向微信的数据服务器发送请求获取用户的昵称等资料，然后显示到页面中。</li></ol> 
<p><a href="#mulu" rel="nofollow">回到目录…</a></p> 
<hr> 
<p><strong>总结</strong>:<br> <font color="#999AAA">提示：这里对文章进行总结：<br> 本文是对OAuth2.0的学习，了解了它的4种授权方式，学会了如何搭建验证服务器，使用 postman对四种模式作了接口测试。并且学会了资源服务器实现单点登录的两种方式，也成功解决了远程调用时没有携带 token 的问题。最后也学会了使用 JWT 存储 Token，大大提高了安全性。</font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3edba8ff2ed8f94d85bc0f725c1e65f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pandas根据列正逆序排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d805d8a8a18e10767a85704a5bfb13c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">rk3588 repo 更新代码是报错：ModuleNotFoundError: No module named ‘formatter‘</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>