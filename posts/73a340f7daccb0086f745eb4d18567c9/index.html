<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>go 进阶 go-zero相关: 一. go-zero 基础 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="go 进阶 go-zero相关: 一. go-zero 基础" />
<meta property="og:description" content="目录 一. go-zero 基础解释二. 搭建一个基础的go-zero服务1. 安装 goctl2. 使用goctl命令创建一个go-zero服务api目录结构介绍main函数介绍介绍etc下的配置文件与intenal/config下的Config结构体介绍rest.MustNewServer(c.RestConf) 创建Server1. engine2. patRouter3. svc.NewServiceContext(c)创建ServiceContext handler.RegisterHandlers(server, ctx) 注册业务Handler1. 编写业务结构体,实现业务方法示例2. 编写将业务module并封装为Handler的函数示例3. 将Handler封装为Route调用server.AddRoutes()注册到Server示例 基于.api文件使用goctl命令构建服务或生成代码示例1. api文件介绍 一. go-zero 基础解释 教程文档地址: 添加链接描述添加链接描述w3cschool教程地址go-zero作者go-zero 入门级demo参考博客 二. 搭建一个基础的go-zero服务 new–&gt;Project–&gt;Go modules (Environment 下输入代理地址&#34;GOPROXY=https://goproxy.cn,direct&#34;) 注意新版本的Goland开发工具默认的go选项,就是以前的&#34;Go modules&#34;直接创建项目就可以了,并且GOPATH 的项目重命名为 Go (GOPATH)
如果创建的Project没有基于go mod,执行&#34;go mod init 项目名称&#34; 在当前目录中初始化和创建一个新的go.mod文件执行go get命令下载go-zero go get -u github.com/zeromicro/go-zero 1. 安装 goctl goctl的优点
执行命令
# Go 1.15 及之前版本 GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/zeromicro/go-zero/tools/goctl@latest # Go 1.16 及以后版本 GOPROXY=https://goproxy.cn/,direct go install github." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/73a340f7daccb0086f745eb4d18567c9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-27T09:42:54+08:00" />
<meta property="article:modified_time" content="2023-06-27T09:42:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">go 进阶 go-zero相关: 一. go-zero 基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_gozero__1" rel="nofollow">一. go-zero 基础解释</a></li><li><a href="#_gozero_9" rel="nofollow">二. 搭建一个基础的go-zero服务</a></li><li><ul><li><a href="#1__goctl_18" rel="nofollow">1. 安装 goctl</a></li><li><a href="#2_goctlgozero_35" rel="nofollow">2. 使用goctl命令创建一个go-zero服务</a></li><li><ul><li><a href="#api_43" rel="nofollow">api目录结构介绍</a></li><li><a href="#main_65" rel="nofollow">main函数介绍</a></li><li><a href="#etcintenalconfigConfig_113" rel="nofollow">介绍etc下的配置文件与intenal/config下的Config结构体</a></li><li><a href="#restMustNewServercRestConf_Server_181" rel="nofollow">介绍rest.MustNewServer(c.RestConf) 创建Server</a></li><li><ul><li><a href="#1_engine_212" rel="nofollow">1. engine</a></li><li><a href="#2_patRouter_226" rel="nofollow">2. patRouter</a></li><li><a href="#3_svcNewServiceContextcServiceContext_235" rel="nofollow">3. svc.NewServiceContext(c)创建ServiceContext</a></li></ul> 
    </li><li><a href="#handlerRegisterHandlersserver_ctx_Handler_253" rel="nofollow">handler.RegisterHandlers(server, ctx) 注册业务Handler</a></li><li><ul><li><a href="#1__260" rel="nofollow">1. 编写业务结构体,实现业务方法示例</a></li><li><a href="#2_moduleHandler_301" rel="nofollow">2. 编写将业务module并封装为Handler的函数示例</a></li><li><a href="#3_HandlerRouteserverAddRoutesServer_337" rel="nofollow">3. 将Handler封装为Route调用server.AddRoutes()注册到Server示例</a></li></ul> 
    </li><li><a href="#apigoctl_403" rel="nofollow">基于.api文件使用goctl命令构建服务或生成代码示例</a></li><li><ul><li><a href="#1_api_449" rel="nofollow">1. api文件介绍</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_gozero__1"></a>一. go-zero 基础解释</h2> 
<ol><li>教程文档地址:</li></ol> 
<blockquote> 
 <ol><li><a href="https://go-zero.dev/cn/docs/introduction" rel="nofollow">添加链接描述</a></li><li><a href="https://legacy.go-zero.dev/cn/" rel="nofollow">添加链接描述</a></li><li><a href="https://www.w3cschool.cn/gozero/" rel="nofollow">w3cschool教程地址</a></li><li><a href="https://www.cnblogs.com/kevinwan/category/2002486.html" rel="nofollow">go-zero作者</a></li><li><a href="https://juejin.cn/post/7036011410265997348" rel="nofollow">go-zero 入门级demo</a></li><li><a href="https://www.bookstack.cn/read/go-zero-1.3-zh/breaker-algorithms.md" rel="nofollow">参考博客</a></li></ol> 
</blockquote> 
<h2><a id="_gozero_9"></a>二. 搭建一个基础的go-zero服务</h2> 
<ol><li>new–&gt;Project–&gt;Go modules (Environment 下输入代理地址"GOPROXY=https://goproxy.cn,direct")</li></ol> 
<blockquote> 
 <p>注意新版本的Goland开发工具默认的go选项,就是以前的"Go modules"直接创建项目就可以了,并且GOPATH 的项目重命名为 Go (GOPATH)<br> <img src="https://images2.imgbox.com/7f/fb/m085Lf0w_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ol start="2"><li>如果创建的Project没有基于go mod,执行"go mod init 项目名称" 在当前目录中初始化和创建一个新的go.mod文件</li><li>执行go get命令下载go-zero</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">go</span> get <span class="token operator">-</span>u github<span class="token punctuation">.</span>com<span class="token operator">/</span>zeromicro<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>zero
</code></pre> 
<h3><a id="1__goctl_18"></a>1. 安装 goctl</h3> 
<ol><li> <p>goctl的优点<br> <img src="https://images2.imgbox.com/8d/6b/7eiaOnhj_o.png" alt="在这里插入图片描述"></p> </li><li> <p>执行命令</p> </li></ol> 
<pre><code class="prism language-go"># Go <span class="token number">1.15</span> 及之前版本
GO111MODULE<span class="token operator">=</span>on GOPROXY<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>goproxy<span class="token punctuation">.</span>cn<span class="token operator">/</span><span class="token punctuation">,</span>direct <span class="token keyword">go</span> get <span class="token operator">-</span>u github<span class="token punctuation">.</span>com<span class="token operator">/</span>zeromicro<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>zero<span class="token operator">/</span>tools<span class="token operator">/</span>goctl@latest

# Go <span class="token number">1.16</span> 及以后版本
GOPROXY<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>goproxy<span class="token punctuation">.</span>cn<span class="token operator">/</span><span class="token punctuation">,</span>direct <span class="token keyword">go</span> install github<span class="token punctuation">.</span>com<span class="token operator">/</span>zeromicro<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>zero<span class="token operator">/</span>tools<span class="token operator">/</span>goctl@latest
</code></pre> 
<ol start="2"><li>执行"goctl -v" 查看版本校验是否安装成功<br> <img src="https://images2.imgbox.com/02/35/QrXtQdTG_o.png" alt="在这里插入图片描述"></li><li><a href="https://legacy.go-zero.dev/cn/goctl.html" rel="nofollow">goctl使用说明</a></li><li>goland安装Goctl插件<br> <img src="https://images2.imgbox.com/03/ba/vOVcOfDw_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="2_goctlgozero_35"></a>2. 使用goctl命令创建一个go-zero服务</h3> 
<ol><li>切换到上面创建的Project根目录,执行Goctl创建命令</li></ol> 
<pre><code class="prism language-go"><span class="token comment">//"core"是一个包名,可以自定义</span>
goctl api <span class="token builtin">new</span> core
</code></pre> 
<ol start="2"><li>执行完毕后生成以下文件<br> <img src="https://images2.imgbox.com/0f/5f/ikqNScAl_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="api_43"></a>api目录结构介绍</h4> 
<pre><code class="prism language-test">├── etc
│   └── core-api.yaml              // 配置文件
├── go.mod                          // mod文件
├── greet.api                       // api描述文件
├── core.go                        // main函数入口
└── internal                        
    ├── config  
    │   └── config.go               // 配置声明type
    ├── handler                     // 路由及handler转发
    │   ├── greethandler.go
    │   └── routes.go
    ├── logic                       // 业务逻辑
    │   └── greetlogic.go
    ├── middleware                  // 中间件文件
    │   └── coremiddleware.go
    ├── svc                         // logic所依赖的资源池
    │   └── servicecontext.go
    └── types                       // request、response的struct，根据api自动生成，不建议编辑
        └── types.go
</code></pre> 
<h4><a id="main_65"></a>main函数介绍</h4> 
<ol><li>其中"core.go"文件是main函数入口</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"flag"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"github.com/zeromicro/go-zero/core/conf"</span>
	<span class="token string">"github.com/zeromicro/go-zero/rest"</span>
	<span class="token string">"go_cloud_demo/core/internal/config"</span>
	<span class="token string">"go_cloud_demo/core/internal/handler"</span>
	<span class="token string">"go_cloud_demo/core/internal/svc"</span>
<span class="token punctuation">)</span>

<span class="token comment">// 1.命令行参数,设置项目运行读取配置文件地址</span>
<span class="token comment">//手动调用main方法启动服务时路径修改为"core/etc/core-api.yaml"</span>
<span class="token keyword">var</span> configFile <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">,</span> <span class="token string">"etc/core-api.yaml"</span><span class="token punctuation">,</span> <span class="token string">"the config file"</span><span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//1.解析命令行参数</span>
	flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">//读取配置文件信息到config.Config结构体上</span>
	<span class="token keyword">var</span> c config<span class="token punctuation">.</span>Config
	conf<span class="token punctuation">.</span><span class="token function">MustLoad</span><span class="token punctuation">(</span><span class="token operator">*</span>configFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>

	<span class="token comment">//2.创建server</span>
	server <span class="token operator">:=</span> rest<span class="token punctuation">.</span><span class="token function">MustNewServer</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>RestConf<span class="token punctuation">)</span>
	<span class="token keyword">defer</span> server<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">//3.创建ServiceContext</span>
	ctx <span class="token operator">:=</span> svc<span class="token punctuation">.</span><span class="token function">NewServiceContext</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

	<span class="token comment">//4.注册Handler逻辑</span>
	handler<span class="token punctuation">.</span><span class="token function">RegisterHandlers</span><span class="token punctuation">(</span>server<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Starting server at %s:%d...\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>Host<span class="token punctuation">,</span> c<span class="token punctuation">.</span>Port<span class="token punctuation">)</span>

	<span class="token comment">//5.启动服务</span>
	server<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>可以通过命令或直接运行main方法启动服务(注意启通过命令行启动时要切换到goctl创建的core文件夹下,执行main方法启动时要修改读取配置文件的路径否则可能会报找不到文件)</li></ol> 
<pre><code class="prism language-go"> <span class="token keyword">go</span> run core<span class="token punctuation">.</span><span class="token keyword">go</span> <span class="token operator">-</span>f etc<span class="token operator">/</span>core<span class="token operator">-</span>api<span class="token punctuation">.</span>yaml
</code></pre> 
<ol start="3"><li>查看etc/core-api.yaml配置文件中设置的ip端口号,发起访问</li></ol> 
<h4><a id="etcintenalconfigConfig_113"></a>介绍etc下的配置文件与intenal/config下的Config结构体</h4> 
<ol><li>查看core.go文件,该文件中定义了main方法, 在启动服务时会基于命令行的方式读取etc文件夹下的core-api.yaml配置文件,将读取到的配置信息解析设置到intenal/config下的Config结构体上, 然后通过该结构体传递数据,设置创建Server</li></ol> 
<pre><code class="prism language-go"><span class="token comment">//当前这个Config是自动生成的</span>
<span class="token comment">//后续如果有其它读取配置文件信息的需求,</span>
<span class="token comment">//根据需求可以给这个结构体增加相关的属性字段</span>
<span class="token keyword">type</span> Config <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	rest<span class="token punctuation">.</span>RestConf
<span class="token punctuation">}</span>

RestConf <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
		service<span class="token punctuation">.</span>ServiceConf
		Host     <span class="token builtin">string</span> <span class="token string">`json:",default=0.0.0.0"`</span> <span class="token comment">//ip</span>
		Port     <span class="token builtin">int</span>	<span class="token comment">//端口号</span>
		CertFile <span class="token builtin">string</span> <span class="token string">`json:",optional"`</span>
		KeyFile  <span class="token builtin">string</span> <span class="token string">`json:",optional"`</span>
		Verbose  <span class="token builtin">bool</span>   <span class="token string">`json:",optional"`</span>
		MaxConns <span class="token builtin">int</span>    <span class="token string">`json:",default=10000"`</span> <span class="token comment">//最大连接数</span>
		MaxBytes <span class="token builtin">int64</span>  <span class="token string">`json:",default=1048576"`</span>
		<span class="token comment">// milliseconds</span>
		Timeout      <span class="token builtin">int64</span>         <span class="token string">`json:",default=3000"`</span> <span class="token comment">//超时时间</span>
		CpuThreshold <span class="token builtin">int64</span>         <span class="token string">`json:",default=900,range=[0:1000]"`</span>
		Signature    SignatureConf <span class="token string">`json:",optional"`</span>
	<span class="token punctuation">}</span>
	
SignatureConf <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
		Strict      <span class="token builtin">bool</span>          <span class="token string">`json:",default=false"`</span>
		Expiry      time<span class="token punctuation">.</span>Duration <span class="token string">`json:",default=1h"`</span>
		PrivateKeys <span class="token punctuation">[</span><span class="token punctuation">]</span>PrivateKeyConf
	<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>查看提供的配置文件core-api.yaml</li></ol> 
<pre><code class="prism language-yaml"><span class="token key atrule">Name</span><span class="token punctuation">:</span> core<span class="token punctuation">-</span>api
<span class="token key atrule">Host</span><span class="token punctuation">:</span> 0.0.0.0
<span class="token key atrule">Port</span><span class="token punctuation">:</span> <span class="token number">8888</span>
</code></pre> 
<ol start="3"><li>这个Config是基于goctl命令创建服务时默认生成的,后续根据需求可以给这个Config增加其它配置属性,例如要增加连接mysql的配置</li></ol> 
<pre><code class="prism language-yaml"><span class="token key atrule">Name</span><span class="token punctuation">:</span> core<span class="token punctuation">-</span>api
<span class="token key atrule">Host</span><span class="token punctuation">:</span> 0.0.0.0
<span class="token key atrule">Port</span><span class="token punctuation">:</span> <span class="token number">8888</span>

<span class="token key atrule">mySqlConfig</span><span class="token punctuation">:</span>
  <span class="token key atrule">dataBase</span><span class="token punctuation">:</span> demo
  <span class="token key atrule">Url</span><span class="token punctuation">:</span> localhost
  <span class="token key atrule">userName</span><span class="token punctuation">:</span> root
  <span class="token key atrule">password</span><span class="token punctuation">:</span> root
</code></pre> 
<ol start="4"><li>改写Config</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">type</span> Config <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	rest<span class="token punctuation">.</span>RestConf
	MySqlConfig MySqlConfig <span class="token string">`json:"mySqlConfig"`</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> MySqlConfig <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	DataBase <span class="token builtin">string</span> <span class="token string">`json:"dataBase"`</span>
	Url      <span class="token builtin">string</span> <span class="token string">`json:"url"`</span>
	UserName <span class="token builtin">string</span> <span class="token string">`json:"userName"`</span>
	Password <span class="token builtin">string</span> <span class="token string">`json:"password"`</span>
<span class="token punctuation">}</span>

<span class="token comment">//此时如果执行下方代码读取yaml配置文件时,</span>
<span class="token comment">//就会吧mysql相关的配置设置到Config的响应属性上</span>
<span class="token keyword">var</span> c Config
conf<span class="token punctuation">.</span><span class="token function">MustLoad</span><span class="token punctuation">(</span><span class="token string">"文件路径/文件名.yaml"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="restMustNewServercRestConf_Server_181"></a>介绍rest.MustNewServer(c.RestConf) 创建Server</h4> 
<ol><li>在上一步读取到了配置参数,获取配置参数,传递给rest下的MustNewServer()方法用来创建Server, 在MustNewServer()函数中会调用NewServer()</li><li>在NewServer()中会创建一个Server结构体对象,在创建这个Server结构体对象时会:</li></ol> 
<blockquote> 
 <ol><li>调用 newEngine©创建 engine</li><li>调用 NewRouter() 初始化 patRouter</li><li>最终返回创建的Server</li></ol> 
</blockquote> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">MustNewServer</span><span class="token punctuation">(</span>c RestConf<span class="token punctuation">,</span> opts <span class="token operator">...</span>RunOption<span class="token punctuation">)</span> <span class="token operator">*</span>Server <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//调用NewServer()</span>
	server<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">NewServer</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> server
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">NewServer</span><span class="token punctuation">(</span>c RestConf<span class="token punctuation">,</span> opts <span class="token operator">...</span>RunOption<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Server<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">SetUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	server <span class="token operator">:=</span> <span class="token operator">&amp;</span>Server<span class="token punctuation">{<!-- --></span>
		ngin<span class="token punctuation">:</span>   <span class="token function">newEngine</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span>
		router<span class="token punctuation">:</span> router<span class="token punctuation">.</span><span class="token function">NewRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	opts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>RunOption<span class="token punctuation">{<!-- --></span><span class="token function">WithNotFoundHandler</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> opt <span class="token operator">:=</span> <span class="token keyword">range</span> opts <span class="token punctuation">{<!-- --></span>
		<span class="token function">opt</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> server<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="1_engine_212"></a>1. engine</h5> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">newEngine</span><span class="token punctuation">(</span>c RestConf<span class="token punctuation">)</span> <span class="token operator">*</span>engine <span class="token punctuation">{<!-- --></span>
	svr <span class="token operator">:=</span> <span class="token operator">&amp;</span>engine<span class="token punctuation">{<!-- --></span>
		conf<span class="token punctuation">:</span> c<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>CpuThreshold <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		svr<span class="token punctuation">.</span>shedder <span class="token operator">=</span> load<span class="token punctuation">.</span><span class="token function">NewAdaptiveShedder</span><span class="token punctuation">(</span>load<span class="token punctuation">.</span><span class="token function">WithCpuThreshold</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>CpuThreshold<span class="token punctuation">)</span><span class="token punctuation">)</span>
		svr<span class="token punctuation">.</span>priorityShedder <span class="token operator">=</span> load<span class="token punctuation">.</span><span class="token function">NewAdaptiveShedder</span><span class="token punctuation">(</span>load<span class="token punctuation">.</span><span class="token function">WithCpuThreshold</span><span class="token punctuation">(</span>
			<span class="token punctuation">(</span>c<span class="token punctuation">.</span>CpuThreshold <span class="token operator">+</span> topCpuUsage<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> svr
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2_patRouter_226"></a>2. patRouter</h5> 
<pre><code class="prism language-go"><span class="token comment">// NewRouter returns a httpx.Router.</span>
<span class="token keyword">func</span> <span class="token function">NewRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> httpx<span class="token punctuation">.</span>Router <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>patRouter<span class="token punctuation">{<!-- --></span>
		trees<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>search<span class="token punctuation">.</span>Tree<span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="3_svcNewServiceContextcServiceContext_235"></a>3. svc.NewServiceContext©创建ServiceContext</h5> 
<ol><li>读取配置文件后将配置数据解析到Config结果体上,查看这一步骤执行的svc下的NewServiceContext()源码,内部只是将Config结果转换成了ServiceContext结构,供后续使用</li><li>查看ServiceContext ,内部持有一个Config,后续可以根据需求向该结构体添加需要的属性字段</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">type</span> ServiceContext <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Config config<span class="token punctuation">.</span>Config
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">NewServiceContext</span><span class="token punctuation">(</span>c config<span class="token punctuation">.</span>Config<span class="token punctuation">)</span> <span class="token operator">*</span>ServiceContext <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>ServiceContext<span class="token punctuation">{<!-- --></span>
		Config<span class="token punctuation">:</span> c<span class="token punctuation">,</span>
		<span class="token comment">//后续可以根据需求添加需要的属性字段</span>
		<span class="token comment">//例如添加mysql连接句柄属性,创建ServiceContext时拿到config配置信息,</span>
		<span class="token comment">//获取myql相关配置,调用初始化mysql连接方法获取连接设置到该属性上</span>
		<span class="token comment">//......</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="handlerRegisterHandlersserver_ctx_Handler_253"></a>handler.RegisterHandlers(server, ctx) 注册业务Handler</h4> 
<ol><li>内部涉及到的相关流程如下:</li></ol> 
<blockquote> 
 <ol><li>首先不需要创建业务结构体, 业务结构体上实现业务方法</li><li>针对指定业务,获取业务结构体,业务结构等相关信息封装为Handler</li><li>拿到Handler后,设置请求路径,请求方法,封装Route</li><li>调用server.AddRoutes()将路由注册到server中</li></ol> 
</blockquote> 
<ol start="2"><li>查看生成的示例</li></ol> 
<h5><a id="1__260"></a>1. 编写业务结构体,实现业务方法示例</h5> 
<ol><li>业务逻辑需要编写在internal/logic/xxx.go下,查看当前生成的core_logic.go文件:</li></ol> 
<blockquote> 
 <ol><li>内部提供了一个CoreLogic结构体,可以将这个结构体看为业务结构体,默认情况下有一个对外的业务接口就会有一个这样的业务结构体</li><li>这个CoreLogic业务结构体上实现了一个Core(req *types.Request) (resp *types.Response, err error)方法,这个方法就是对应的业务方法</li><li>针对这个业务结构体提供了一个NewCoreLogic()初始化函数,在执行业务时首先要调用该函数进行初始化</li></ol> 
</blockquote> 
<pre><code class="prism language-go"><span class="token keyword">package</span> logic

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"github.com/zeromicro/go-zero/core/logx"</span>
	<span class="token string">"go_cloud_demo/core/internal/svc"</span>
	<span class="token string">"go_cloud_demo/core/internal/types"</span>
<span class="token punctuation">)</span>

<span class="token comment">// 1.业务结构体</span>
<span class="token keyword">type</span> CoreLogic <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	logx<span class="token punctuation">.</span>Logger
	ctx    context<span class="token punctuation">.</span>Context
	svcCtx <span class="token operator">*</span>svc<span class="token punctuation">.</span>ServiceContext
<span class="token punctuation">}</span>

<span class="token comment">// 2.业务结构体初始化方法</span>
<span class="token keyword">func</span> <span class="token function">NewCoreLogic</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> svcCtx <span class="token operator">*</span>svc<span class="token punctuation">.</span>ServiceContext<span class="token punctuation">)</span> <span class="token operator">*</span>CoreLogic <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>CoreLogic<span class="token punctuation">{<!-- --></span>
		Logger<span class="token punctuation">:</span> logx<span class="token punctuation">.</span><span class="token function">WithContext</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">,</span>
		ctx<span class="token punctuation">:</span>    ctx<span class="token punctuation">,</span>
		svcCtx<span class="token punctuation">:</span> svcCtx<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 3.业务方法</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>CoreLogic<span class="token punctuation">)</span> <span class="token function">Core</span><span class="token punctuation">(</span>req <span class="token operator">*</span>types<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">(</span>resp <span class="token operator">*</span>types<span class="token punctuation">.</span>Response<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>Name<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> types<span class="token punctuation">.</span><span class="token function">NewError</span><span class="token punctuation">(</span><span class="token string">"未接收到请求参数"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>types<span class="token punctuation">.</span>Response<span class="token punctuation">{<!-- --></span>
		Message<span class="token punctuation">:</span> <span class="token string">"接收到请求参数:"</span> <span class="token operator">+</span> req<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2_moduleHandler_301"></a>2. 编写将业务module并封装为Handler的函数示例</h5> 
<ol><li>上面编写了业务结构体,并在这个业务结构体上实现了业务方法Core(),针对这个业务,提供了初始化方法NewCoreLogic()</li><li>在internal/handler下针对每一个业务都会生成一个xxx_handler.go文件,该文件中编写将业务接口封装为Handler的函数,例如当前的CoreHandler()</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">package</span> handler

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"net/http"</span>

	<span class="token string">"github.com/zeromicro/go-zero/rest/httpx"</span>
	<span class="token string">"go_cloud_demo/core/internal/logic"</span>
	<span class="token string">"go_cloud_demo/core/internal/svc"</span>
	<span class="token string">"go_cloud_demo/core/internal/types"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">CoreHandler</span><span class="token punctuation">(</span>svcCtx <span class="token operator">*</span>svc<span class="token punctuation">.</span>ServiceContext<span class="token punctuation">)</span> http<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//1.解析请求参数</span>
		<span class="token keyword">var</span> req types<span class="token punctuation">.</span>Request
		<span class="token keyword">if</span> err <span class="token operator">:=</span> httpx<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token operator">&amp;</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			httpx<span class="token punctuation">.</span><span class="token function">ErrorCtx</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//2.创建CoreLogic结构体(基于modules)</span>
		l <span class="token operator">:=</span> logic<span class="token punctuation">.</span><span class="token function">NewCoreLogic</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> svcCtx<span class="token punctuation">)</span>
		<span class="token comment">//3.执行CoreLogic上实现的业务方法并拿到返回结果</span>
		resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">Core</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>req<span class="token punctuation">)</span>
		<span class="token comment">//4.响应</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			httpx<span class="token punctuation">.</span><span class="token function">ErrorCtx</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			httpx<span class="token punctuation">.</span><span class="token function">OkJsonCtx</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> resp<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="3_HandlerRouteserverAddRoutesServer_337"></a>3. 将Handler封装为Route调用server.AddRoutes()注册到Server示例</h5> 
<ol><li>上方针对业务结构体,业务方法core(),提供了NewCoreLogic()初始化函数,并且在xxx_handler.go文件中生成了将这个业务封装为Handler的函数CoreHandler()</li><li>查看生成的"/handler/routes.go"文件,会调用XXXHandler()函数,针对这个业务Handler设置对应的接口路径,请求方法,封装为Route路由,并且调用server.AddRoutes()将这个路由注册到server中</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">package</span> handler

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"net/http"</span>
	<span class="token string">"go_cloud_demo/core/internal/svc"</span>
	<span class="token string">"github.com/zeromicro/go-zero/rest"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">RegisterHandlers</span><span class="token punctuation">(</span>server <span class="token operator">*</span>rest<span class="token punctuation">.</span>Server<span class="token punctuation">,</span> serverCtx <span class="token operator">*</span>svc<span class="token punctuation">.</span>ServiceContext<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">// 使用use方法添加一个自定义的中间件(这里是手动加的只是做个示例)</span>
	server<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>next http<span class="token punctuation">.</span>HandlerFunc<span class="token punctuation">)</span> http<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 在请求处理前执行一些逻辑</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"before request"</span><span class="token punctuation">)</span>
			<span class="token comment">// 调用下一个处理函数</span>
			<span class="token function">next</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
			<span class="token comment">// 在请求处理后执行一些逻辑</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"after request"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>

	<span class="token comment">//2.调用server.AddRoutes()将Route注册到Server</span>
	server<span class="token punctuation">.</span><span class="token function">AddRoutes</span><span class="token punctuation">(</span>
		<span class="token comment">//1.将Handler封装为Route</span>
		<span class="token punctuation">[</span><span class="token punctuation">]</span>rest<span class="token punctuation">.</span>Route<span class="token punctuation">{<!-- --></span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//请求方式</span>
				Method<span class="token punctuation">:</span> http<span class="token punctuation">.</span>MethodGet<span class="token punctuation">,</span>
				<span class="token comment">//接口路径</span>
				Path<span class="token punctuation">:</span> <span class="token string">"/from/:name"</span><span class="token punctuation">,</span>
				<span class="token comment">//业务handler函数</span>
				Handler<span class="token punctuation">:</span> <span class="token function">CoreHandler</span><span class="token punctuation">(</span>serverCtx<span class="token punctuation">)</span><span class="token punctuation">,</span>
			<span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>main函数中调用这个方法,启动服务</li><li>查看etc/core-api.yaml配置文件中设置的ip端口号,发起访问即可</li><li>rest下常用功能函数简介</li></ol> 
<pre><code class="prism language-go"><span class="token function">ToMiddleware</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于将一个接收和返回http<span class="token punctuation">.</span>Handler的函数转换为一个Middleware类型的函数，Middleware类型的函数是一个接收和返回http<span class="token punctuation">.</span>HandlerFunc的函数，可以用于实现拦截器或者中间件的逻辑
<span class="token function">WithMiddlewares</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一组路由添加一组中间件，中间件会在路由处理前后执行一些逻辑，比如验证、转换、缓存等
<span class="token function">WithChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一个Server添加一个拦截器链，拦截器链可以在请求处理前后执行一些逻辑，比如日志、监控、限流等
<span class="token function">WithCors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一个Server添加一个默认的跨域资源共享（CORS）处理器，可以指定允许的源域名列表，如果为空，则允许所有源
<span class="token function">WithCustomCors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一个Server添加一个自定义的跨域资源共享（CORS）处理器，可以指定自定义的响应头处理函数和不允许的请求方法处理函数
<span class="token function">WithPrefix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一组路由添加一个公共的前缀，比如<span class="token operator">/</span>api<span class="token operator">/</span>v1
<span class="token function">WithPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一组路由设置优先级标志，如果为<span class="token boolean">true</span>，则这组路由会使用优先级限流器进行限流，否则使用普通限流器
<span class="token function">WithRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一个Server指定一个自定义的路由器，路由器是用于匹配和分发请求的对象，默认使用patRouter
<span class="token function">WithJwt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一组路由开启jwt验证功能，并指定密钥
<span class="token function">WithJwtTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一组路由开启jwt验证功能，并指定当前密钥和上一个密钥，用于平滑过渡密钥变更
<span class="token function">WithMaxBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一组路由设置最大请求体大小限制，如果请求体超过这个大小，则返回错误
<span class="token function">WithNotFoundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一个Server指定一个自定义的未找到匹配路由处理器，如果为空，则使用默认的处理器
<span class="token function">WithNotAllowedHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一个Server指定一个自定义的不允许的请求方法处理器，如果为空，则使用默认的处理器
<span class="token function">WithSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一组路由开启签名验证功能，并指定签名配置信息
<span class="token function">WithTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一组路由设置超时时间限制，如果请求处理超过这个时间，则返回超时错误
<span class="token function">WithTLSConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一个Server指定TLS加密通信配置信息，比如证书、密钥等
<span class="token function">WithUnauthorizedCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一个Server指定一个自定义的未授权回调函数，用于处理未授权的请求，比如返回<span class="token number">401</span>状态码或者重定向到登录页面
<span class="token function">WithUnsignedCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>用于为一个Server指定一个自定义的未签名回调函数，用于处理未签名的请求，比如返回<span class="token number">403</span>状态码或者提示用户签名
</code></pre> 
<ol start="6"><li>Server上的use方法与rest下的WithMiddlewares()注册中间件的区别: use方法是用于为一个Server添加一个中间件，这个中间件会应用于所有的路由,use方法每次只能添加一个中间件，而WithMiddlewares或WithMiddleware()方法可以为指定一组路由添加中间件</li></ol> 
<h4><a id="apigoctl_403"></a>基于.api文件使用goctl命令构建服务或生成代码示例</h4> 
<ol start="8"><li>上方的示例代码都是通过"goctl api new 文件夹名称" 命令生成的,生成的文件中存在一个".api"结尾的文件,基于这个文件,可以执行goctl命令生成对应的handler,logic业务类,</li><li>例如当前要生成一个用户查询接口,在".api"文件中编写生成模板</li></ol> 
<blockquote> 
 <ol><li>定义接口需要的入参,反参</li><li>定义将业务接口封装为Handler的函数名</li><li>指定接口请求方式</li><li>指定接口url以及入参反参类型</li></ol> 
</blockquote> 
<pre><code class="prism language-go"><span class="token comment">//1.接口需要的入参</span>
<span class="token keyword">type</span> UserQuery <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//options是入参校验</span>
	Name <span class="token builtin">string</span> <span class="token string">`path:"name,options=you|me"`</span>
<span class="token punctuation">}</span>

<span class="token comment">//2.接口需要的反参</span>
<span class="token keyword">type</span> UserData <span class="token punctuation">{<!-- --></span>
	Message <span class="token builtin">string</span> <span class="token string">`json:"message"`</span>
<span class="token punctuation">}</span>

<span class="token comment">//3."xxx-api"中定义接口</span>
service core<span class="token operator">-</span>api <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//指定将当前业务接口封装为Handler的函数名</span>
	@handler UserQueryHandler
	<span class="token comment">//指定接口请求方式 请求路径 入参类型 反参类型</span>
	post <span class="token operator">/</span>user<span class="token operator">/</span><span class="token function">query</span><span class="token punctuation">(</span>UserQuery<span class="token punctuation">)</span> returns <span class="token punctuation">(</span>UserData<span class="token punctuation">)</span>

	<span class="token comment">//后续如果需要增加其它接口依次向下写即可</span>
	<span class="token comment">//@handler UserQueryHandler</span>
	<span class="token comment">//post /user/query(UserQuery) returns (UserData)</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>切换到".api"文件所在目录,执行生成命令</li></ol> 
<pre><code class="prism language-go"><span class="token comment">//通过"core.api"文件生成</span>
<span class="token comment">//goctl api go 表示生成go语言的服务</span>
<span class="token comment">//api *.api 指定api文件</span>
<span class="token comment">//dir ./ 指定生成的路径</span>
goctl api <span class="token keyword">go</span> <span class="token operator">-</span>api core<span class="token punctuation">.</span>api <span class="token operator">-</span>dir <span class="token punctuation">.</span> <span class="token operator">-</span>style go_zero
</code></pre> 
<ol start="4"><li>此时查看项目目录中多了几个文件</li></ol> 
<blockquote> 
 <ol><li>logic文件夹下生成了编写业务结构体及方法(但是方法内部是空的需要自己编写)</li><li>handler文件夹下生成了将该业务接口封装为Handler的方法</li><li>并且在handler文件夹中的routes.go文件中将该Handler封装为Router,注册到了Server中</li><li>types文件夹中的types下生成了接口执行需要的入参反参结构体<br> <img src="https://images2.imgbox.com/55/3c/582RcvPq_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h5><a id="1_api_449"></a>1. api文件介绍</h5> 
<ol><li><a href="https://zhuanlan.zhihu.com/p/570979109" rel="nofollow">参考博客</a></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/620cbc4062921d13d8c436c40dd2378a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python 如何用pandas合并相同数据？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e1a7a2081c53d7d584e1ce9e8b8fe5de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">libpcap的简单应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>