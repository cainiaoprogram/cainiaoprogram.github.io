<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s之Pod控制器 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s之Pod控制器" />
<meta property="og:description" content="目录 一、Pod控制器及其功用二、pod控制器的多种类型2.1 pod容器中的有状态和无状态的区别 三、Deployment 控制器四、SatefulSet 控制器4.1 StatefulSet由以下几个部分组成4.2 为什么要有headless？4.3 为什么要有volumeClaimTemplate？4.4 滚动更新4.5 扩容及缩容4.6 小结 五、DaemonSet 控制器六、Job 控制器七、CronJob 控制器八、总结8.1 Deployment8.2 StatefulSet8.3 DaemonSet8.4 Job8.5 CronJob 一、Pod控制器及其功用 Pod控制器，又称之为工作负载（workload），是用于实现管理pod的中间层，确保pod资源符合预期的状态，pod的资源出现故障时，会尝试进行重启，当根据重启策略无效，则会重新新建pod的资源。
二、pod控制器的多种类型 1、ReplicaSet: 代用户创建指定数量的pod副本，确保pod副本数量符合预期状态，并且支持滚动式自动扩容和缩容功能。
ReplicaSet主要三个组件组成：
（1）用户期望的pod副本数量
（2）标签选择器，判断哪个pod归自己管理
（3）当现存的pod数量不足，会根据pod资源模板进行新建
帮助用户管理无状态的pod资源，精确反应用户定义的目标数量，但是RelicaSet不是直接使用的控制器，而是使用Deployment。
2、Deployment：工作在ReplicaSet之上，用于管理无状态应用，目前来说最好的控制器。支持滚动更新和回滚功能，还提供声明式配置。
ReplicaSet 与Deployment 这两个资源对象逐步替换之前RC的作用。
3、DaemonSet：用于确保集群中的每一个节点只运行特定的pod副本，通常用于实现系统级后台任务。比如ELK服务
特性：服务是无状态的
服务必须是守护进程
4、StatefulSet：管理有状态应用
5、Job：只要完成就立即退出，不需要重启或重建
6、Cronjob：周期性任务控制，不需要持续后台运行
2.1 pod容器中的有状态和无状态的区别 有状态实例
实例之间有差别，每个实例都有自己的独特性，元数据不同，例如etcd，zookeeper
实例之间不对等的关系，以及依靠外部存储的应用无状态实例
deployment认为所有的pod都是一样的
不用考虑顺序的要求
不用考虑在哪个node节点上运行
可以随意扩容和缩容 三、Deployment 控制器 部署无状态应用
管理Pod和ReplicaSet
具有上线部署、副本设定、滚动升级、回滚等功能
提供声明式更新，例如只更新一个新的image
应用场景：web服务
vim nginx-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f023effea4cb0f40189fc92aca397d38/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-16T21:24:05+08:00" />
<meta property="article:modified_time" content="2023-08-16T21:24:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s之Pod控制器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#Pod_11" rel="nofollow">一、Pod控制器及其功用</a></li><li><a href="#pod_15" rel="nofollow">二、pod控制器的多种类型</a></li><li><ul><li><a href="#21_pod_37" rel="nofollow">2.1 pod容器中的有状态和无状态的区别</a></li></ul> 
  </li><li><a href="#Deployment__47" rel="nofollow">三、Deployment 控制器</a></li><li><a href="#SatefulSet__86" rel="nofollow">四、SatefulSet 控制器</a></li><li><ul><li><a href="#41_StatefulSet_178" rel="nofollow">4.1 StatefulSet由以下几个部分组成</a></li><li><a href="#42_headless_183" rel="nofollow">4.2 为什么要有headless？</a></li><li><a href="#43_volumeClaimTemplate_187" rel="nofollow">4.3 为什么要有volumeClaimTemplate？</a></li><li><a href="#44__256" rel="nofollow">4.4 滚动更新</a></li><li><a href="#45__263" rel="nofollow">4.5 扩容及缩容</a></li><li><a href="#46__298" rel="nofollow">4.6 小结</a></li></ul> 
  </li><li><a href="#DaemonSet__306" rel="nofollow">五、DaemonSet 控制器</a></li><li><a href="#Job__349" rel="nofollow">六、Job 控制器</a></li><li><a href="#CronJob__402" rel="nofollow">七、CronJob 控制器</a></li><li><a href="#_450" rel="nofollow">八、总结</a></li><li><ul><li><a href="#81_Deployment_451" rel="nofollow">8.1 Deployment</a></li><li><a href="#82_StatefulSet_456" rel="nofollow">8.2 StatefulSet</a></li><li><a href="#83_DaemonSet_470" rel="nofollow">8.3 DaemonSet</a></li><li><a href="#84_Job_476" rel="nofollow">8.4 Job</a></li><li><a href="#85_CronJob_481" rel="nofollow">8.5 CronJob</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="Pod_11"></a>一、Pod控制器及其功用</h2> 
<p>Pod控制器，又称之为工作负载（workload），是用于实现管理pod的中间层，确保pod资源符合预期的状态，pod的资源出现故障时，会尝试进行重启，当根据重启策略无效，则会重新新建pod的资源。</p> 
<h2><a id="pod_15"></a>二、pod控制器的多种类型</h2> 
<p>1、<strong>ReplicaSet</strong>: 代用户创建指定数量的pod副本，确保pod副本数量符合预期状态，并且支持滚动式自动扩容和缩容功能。<br> ReplicaSet主要三个组件组成：<br> （1）用户期望的pod副本数量<br> （2）标签选择器，判断哪个pod归自己管理<br> （3）当现存的pod数量不足，会根据pod资源模板进行新建<br> 帮助用户管理无状态的pod资源，精确反应用户定义的目标数量，但是RelicaSet不是直接使用的控制器，而是使用Deployment。</p> 
<p>2、<strong>Deployment</strong>：工作在ReplicaSet之上，用于<strong>管理无状态应用</strong>，<strong>目前来说最好的控制器。支持滚动更新和回滚功能，还提供声明式配置。</strong><br> ReplicaSet 与Deployment 这两个资源对象逐步替换之前RC的作用。</p> 
<p>3、<strong>DaemonSet</strong>：用于确保集群中的每一个节点只运行特定的pod副本，通常用于实现系统级后台任务。比如ELK服务<br> 特性：<strong>服务是无状态的</strong><br> 服务必须是守护进程</p> 
<p>4、<strong>StatefulSet</strong>：<strong>管理有状态应用</strong></p> 
<p>5、<strong>Job</strong>：只要完成就立即退出，不需要重启或重建</p> 
<p>6、<strong>Cronjob</strong>：周期性任务控制，不需要持续后台运行</p> 
<h3><a id="21_pod_37"></a>2.1 pod容器中的有状态和无状态的区别</h3> 
<ul><li><strong>有状态实例<br> 实例之间有差别，每个实例都有自己的独特性，元数据不同，例如etcd，zookeeper<br> 实例之间不对等的关系，以及依靠外部存储的应用</strong></li><li><strong>无状态实例<br> deployment认为所有的pod都是一样的<br> 不用考虑顺序的要求<br> 不用考虑在哪个node节点上运行<br> 可以随意扩容和缩容</strong></li></ul> 
<h2><a id="Deployment__47"></a>三、Deployment 控制器</h2> 
<p>部署无状态应用<br> 管理Pod和ReplicaSet<br> 具有上线部署、副本设定、滚动升级、回滚等功能<br> 提供声明式更新，例如只更新一个新的image<br> 应用场景：web服务</p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> nginx-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx    
spec:
  replicas: <span class="token number">3</span>
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.15.4
        ports:
        - containerPort: <span class="token number">80</span>

kubectl create <span class="token parameter variable">-f</span> nginx-deployment.yaml

kubectl get pods,deploy,rs
</code></pre> 
<h2><a id="SatefulSet__86"></a>四、SatefulSet 控制器</h2> 
<p>StatefulSet 是用来管理有状态应用的工作负载 API 对象。</p> 
<p>StatefulSet 用来管理某 Pod 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。</p> 
<p>和 Deployment 类似， StatefulSet 管理基于相同容器规约的一组 Pod。<strong>但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</strong></p> 
<p>如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 尽管 StatefulSet 中的单个 Pod 仍可能出现故障， 但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。</p> 
<p><strong>StatefulSet 对于需要满足以下一个或多个需求的应用程序很有价值：</strong></p> 
<ul><li><strong>稳定的、唯一的网络标识符。</strong></li><li><strong>稳定的、持久的存储。</strong></li><li><strong>有序的、优雅的部署和扩缩。</strong></li><li><strong>有序的、自动的滚动更新。</strong></li></ul> 
<p><strong>在上面描述中，“稳定的”意味着 Pod 调度或重调度的整个过程是有持久性的。 如果应用程序不需要任何稳定的标识符或有序的部署、删除或扩缩， 则应该使用由一组无状态的副本控制器提供的工作负载来部署应用程序，比如 Deployment 或者 ReplicaSet可能更适用于你的无状态应用部署需要。</strong></p> 
<pre><code class="prism language-bash">//名为 svc-demo 的 Headless Service 用来控制网络域名
kubectl create svc clusterip svc-demo <span class="token parameter variable">--tcp</span><span class="token operator">=</span><span class="token number">80</span>:80 --dry-run<span class="token operator">=</span>client <span class="token parameter variable">-oyaml</span> <span class="token operator">&gt;</span> svc-demo.yaml
<span class="token function">vim</span> svc-demo.yaml

apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    app: svc-demo
  name: svc-demo
spec:
  ports:
  - name: http
    port: <span class="token number">80</span>
    protocol: TCP
    targetPort: <span class="token number">80</span>
  selector:
    app: sts-demo    //拥有此标签的pod 都有此service
  type: ClusterIP
  clusterIP: None  //无头服务的clusterIp为None
</code></pre> 
<p><img src="https://images2.imgbox.com/dc/72/F2ZGcA2N_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/7e/31/tbAoRYY5_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">//名为 myapp-demo 的 StatefulSet 有一个 Spec，它表明将在独立的4个 Pod 副本中启动容器
<span class="token function">vim</span> stateful-demo.yaml 

apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: myapp-demo
  name: myapp-demo
spec:
  serviceName: svc-demo
  replicas: <span class="token number">4</span>
  selector:
    matchLabels:
      app: sts-demo
  template:
    metadata:
      labels:
        app: sts-demo
    spec:
      containers:
      - image: soscscs/myapp:v1
        name: myapp
        ports:
        - containerPort: <span class="token number">80</span>
  volumeClaimTemplates:
  - metadata:
      name: pvc-demo
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 2Gi
      storageClassName: nfs-client-storageclass

</code></pre> 
<p><img src="https://images2.imgbox.com/d3/61/aosWVf7x_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f9/31/ThGv87Wv_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="41_StatefulSet_178"></a>4.1 StatefulSet由以下几个部分组成</h3> 
<p><strong>●Headless Service（无头服务）：用于为Pod资源标识符生成可解析的DNS记录。<br> ●volumeClaimTemplates（存储卷申请模板）：基于静态或动态PV供给方式为Pod资源提供专有的固定存储。<br> ●StatefulSet：用于管控Pod资源。</strong></p> 
<h3><a id="42_headless_183"></a>4.2 为什么要有headless？</h3> 
<p><strong>在deployment中，每一个pod是没有名称，是随机字符串，是无序的。而statefulset中是要求有序的，每一个pod的名称必须是固定的。当节点挂了，重建之后的标识符是不变的，每一个节点的节点名称是不能改变的。pod名称是作为pod识别的唯一标识符，必须保证其标识符的稳定并且唯一。<br> 为了实现标识符的稳定，这时候就需要一个headless service 解析直达到pod，还需要给pod配置一个唯一的名称。</strong></p> 
<h3><a id="43_volumeClaimTemplate_187"></a>4.3 为什么要有volumeClaimTemplate？</h3> 
<p><strong>大部分有状态副本集都会用到持久存储，比如分布式系统来说，由于数据是不一样的，每个节点都需要自己专用的存储节点。而在 deployment中pod模板中创建的存储卷是一个共享的存储卷，多个pod使用同一个存储卷，而statefulset定义中的每一个pod都不能使用同一个存储卷，由此基于pod模板创建pod是不适应的，这就需要引入volumeClaimTemplate，当在使用statefulset创建pod时，会自动生成一个PVC，从而请求绑定一个PV，从而有自己专用的存储卷。</strong></p> 
<p><strong>服务发现：就是应用服务之间相互定位的过程。<br> 应用场景：<br> ●动态性强：Pod会飘到别的node节点<br> ●更新发布频繁：互联网思维小步快跑，先实现再优化，老板永远是先上线再慢慢优化，先把idea变成产品挣到钱然后再慢慢一点一点优化<br> ●支持自动伸缩：一来大促，肯定是要扩容多个副本<br> K8S里服务发现的方式—DNS，使K8S集群能够自动关联Service资源的“名称”和“CLUSTER-IP”，从而达到服务被集群自动发现的目的。</strong></p> 
<pre><code class="prism language-bash">kubectl get pods <span class="token parameter variable">-A</span>
kubectl delete pods coredns-54d67798b7-rl5wc <span class="token parameter variable">-n</span> kube-system 
kubectl delete pods coredns-54d67798b7-qbvr5 <span class="token parameter variable">-n</span> kube-system 
</code></pre> 
<p><img src="https://images2.imgbox.com/6a/40/YqKOXLCL_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1e/85/DyHFlHnx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c4/be/Hjl29TIa_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl delete statefulsets.apps myapp-demo
<span class="token function">vim</span> stateful.yaml 

apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: myapp-demo
  name: myapp-demo
spec:
  serviceName: svc-demo
  replicas: <span class="token number">4</span>
  selector:
    matchLabels:
      app: sts-demo
  template:
    metadata:
      labels:
        app: sts-demo
    spec:
      containers:
      - image: soscscs/myapp:v1
        name: myapp
        ports:
        - containerPort: <span class="token number">80</span>
        volumeMounts:
        - name: pvc-demo
          mountPath: /data
  volumeClaimTemplates:
  - metadata:
      name: pvc-demo
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 2Gi
      storageClassName: nfs-client-storageclass
</code></pre> 
<p><img src="https://images2.imgbox.com/9f/4b/RfJnlidr_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/b8/5f/ULKuNXYT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2d/f6/X9CMfk8x_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e7/c1/9uikCxbu_o.png" alt="在这里插入图片描述"><br> <strong>解析上例：由于 StatefulSet 资源依赖于一个实现存在的 Headless 类型的 Service 资源，所以需要先定义一个名为 svc-demo 的 Headless Service 资源，用于为关联到每个 Pod 资源创建 DNS 资源记录。接着定义了一个名为 myapp 的 StatefulSet 资源，它通过 Pod 模板创建了 4 个 Pod 资源副本，并基于 volumeClaimTemplates 向前面创建的PV进行了请求大小为 2Gi 的专用存储卷。</strong></p> 
<h3><a id="44__256"></a>4.4 滚动更新</h3> 
<p><strong>StatefulSet 控制器将在 StatefulSet 中删除并重新创建每个 Pod。它将以与 Pod 终止相同的顺序进行（从最大的序数到最小的序数），每次更新一个 Pod。在更新其前身之前，它将等待正在更新的 Pod 状态变成正在运行并就绪。</strong></p> 
<pre><code class="prism language-bash"> kubectl edit statefulsets.apps myapp-demo 
 kubectl get pods <span class="token parameter variable">-w</span>   //查看滚动更新的过程
</code></pre> 
<p><img src="https://images2.imgbox.com/4e/b6/CUAdvTOB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="45__263"></a>4.5 扩容及缩容</h3> 
<pre><code class="prism language-bash">kubectl scale statefulset myapp-demo <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token number">6</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/4d/56/v78rzrgo_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl scale statefulset myapp-demo <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token number">3</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3f/e2/FjH2Io44_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">扩展伸缩
kubectl scale sts myapp <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token number">4</span>  //扩容副本增加到4个

kubectl get pods <span class="token parameter variable">-w</span>  //动态查看扩容

kubectl get <span class="token function">pv</span>  //查看pv绑定

kubectl patch sts myapp <span class="token parameter variable">-p</span> <span class="token string">'{"spec":{"replicas":2}}'</span>  //打补丁方式缩容

kubectl get pods <span class="token parameter variable">-w</span>  //动态查看缩容
</code></pre> 
<p><strong>当删除一个 StatefulSet 时，该 StatefulSet 不提供任何终止 Pod 的保证。为了实现 StatefulSet 中的 Pod 可以有序且体面地终止，可以在删除之前将 StatefulSet 缩容到 0。</strong></p> 
<pre><code class="prism language-bash">示例：
kubectl scale statefulset myappdata-myapp <span class="token parameter variable">--replicas</span><span class="token operator">=</span><span class="token number">0</span>
kubectl delete <span class="token parameter variable">-f</span> stateful-demo.yaml	
</code></pre> 
<h3><a id="46__298"></a>4.6 小结</h3> 
<p><strong>常规service和无头服务区别<br> service：一组Pod访问策略，提供cluster-IP群集之间通讯，还提供负载均衡和服务发现。<br> Headless service：无头服务，不需要cluster-IP，而是直接以DNS记录的方式解析出被代理Pod的IP地址。</strong></p> 
<p><strong>注意：使用普通的 service 也可以解析出被代理Pod的IP地址</strong></p> 
<h2><a id="DaemonSet__306"></a>五、DaemonSet 控制器</h2> 
<p><strong>DaemonSet 确保全部（或者一些）Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一个 Pod 。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</strong></p> 
<p>使用 DaemonSet 的一些典型用法：<br> ●<strong>运行集群存储 daemon，例如在每个 Node 上运行 glusterd、ceph。</strong><br> ●<strong>在每个 Node 上运行日志收集 daemon，例如fluentd、logstash。</strong><br> ●<strong>在每个 Node 上运行监控 daemon，例如 Prometheus Node Exporter、collectd、Datadog 代理、New Relic 代理，或 Ganglia gmond。</strong><br> 应用场景：Agent<br> 官方案例（监控）：<a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" rel="nofollow">https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/</a></p> 
<pre><code class="prism language-bash">示例：
<span class="token function">vim</span> daemon-demo.yaml

apiVersion: apps/v1
kind: DaemonSet
metadata:
  labels:
    app: myapp-ds
  name: myapp-ds
spec:
  selector:
    matchLabels:
      app: myapp-ds
  template:
    metadata:
      labels:
        app: myapp-ds
    spec:
      containers:
      - image: soscscs/myapp:v1
        name: myapp
        ports:
        - containerPort: <span class="token number">80</span>
      tolerations:
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
</code></pre> 
<p><img src="https://images2.imgbox.com/67/68/xKUv8QCl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a4/55/VLFXxFmb_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/29/af/vCOUwAK5_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Job__349"></a>六、Job 控制器</h2> 
<p>Job分为普通任务（Job）和定时任务（CronJob）<br> <strong>常用于运行那些仅需要执行一次的任务</strong><br> 应用场景：数据库迁移、批处理脚本、kube-bench扫描、离线数据处理，视频解码等业务<br> <a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" rel="nofollow">https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/</a></p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> job-demo.yaml

apiVersion: batch/v1
kind: Job
metadata:
  name: myapp-job
spec:
  template:
    spec:
      containers:
      - name: myapp
        image: soscscs/myapp:v1
        command: <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"echo zhangsan like singing ; sleep 10; date; exit 0"</span><span class="token punctuation">]</span>
      restartPolicy: Never
  backoffLimit: <span class="token number">4</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a9/dc/9siDAiAt_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl describe pods myapp-job-gnk6c
</code></pre> 
<p><img src="https://images2.imgbox.com/b5/4b/NYmNkgH0_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl logs myapp-job-gnk6c 
</code></pre> 
<p><img src="https://images2.imgbox.com/bb/23/VIu6bdku_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a4/1b/O3K49Yll_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/4a/18/3uagOxeD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fe/24/1VubJ8Nn_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/71/d4/eklat2pi_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/76/04/qSsMCKSV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e9/00/jY05PGwV_o.png" alt="在这里插入图片描述"></p> 
<p><strong>注意：job的重启策略要么 <code>Never</code> ， 要么 <code>OnFailure</code> ，绝对不能为 <code>Always</code></strong></p> 
<h2><a id="CronJob__402"></a>七、CronJob 控制器</h2> 
<p>周期性任务，像Linux的Crontab一样。<br> 周期性任务<br> 应用场景：通知，备份<br> <a href="https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs/" rel="nofollow">https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs/</a></p> 
<p><strong>cronjob其它可用参数的配置</strong><br> <strong>spec:</strong><br> <strong>concurrencyPolicy: Allow</strong> #声明了 CronJob 创建的任务执行时发生重叠如何处理（并发性规则仅适用于相同 CronJob 创建的任务）。spec仅能声明下列规则中的一种:<br> ●<strong>Allow</strong> (默认)：CronJob 允许并发任务执行。<br> ●<strong>Forbid</strong>：CronJob 不允许并发任务执行；如果新任务的执行时间到了而老任务没有执行完，CronJob 会忽略新任务的执行。<br> ●<strong>Replace</strong>：如果新任务的执行时间到了而老任务没有执行完，CronJob 会用新任务替换当前正在运行的任务。<br> <strong>startingDeadlineSeconds</strong>: 15 #它表示任务如果由于某种原因错过了调度时间，开始该任务的截止时间的秒数。过了截止时间，CronJob 就不会开始任务，且标记失败.如果此字段未设置，那任务就没有最后期限。<br> <strong>successfulJobsHistoryLimit: 3</strong> #要保留的成功完成的任务数（默认为3）<br> <strong>failedJobsHistoryLimit：1</strong> #要保留多少已完成和失败的任务数（默认为1）<br> <strong>suspend：true</strong> #如果设置为 true ，后续发生的执行都会被挂起。 这个设置对已经开始的执行不起作用。默认是 false。<br> <strong><code>schedule: '*/1 * * * *'</code></strong> #必需字段，作业时间表。在此示例中，作业将每分钟运行一次<br> <strong>jobTemplate:</strong> #必需字段，作业模板。这类似于工作示例</p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> cronjob-demo.yaml

apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: hello
spec:
  schedule: <span class="token string">"*/1 * * * *"</span>
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox
            imagePullPolicy: IfNotPresent
            args:
            - /bin/sh
            - <span class="token parameter variable">-c</span>
            - <span class="token function">date</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> Hello from the Kubernetes cluster
          restartPolicy: OnFailure
</code></pre> 
<p><img src="https://images2.imgbox.com/40/f4/J78FSnzg_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_450"></a>八、总结</h2> 
<h3><a id="81_Deployment_451"></a>8.1 Deployment</h3> 
<p><strong>1）部署无状态应用<br> 2）创建和管理 ReplicaSet 和 Pod 资源，并维护Pod副本数量与期望值相同<br> 3）创建和删除Pod是并行执行的，升级策略默认为滚动更新的方式</strong></p> 
<h3><a id="82_StatefulSet_456"></a>8.2 StatefulSet</h3> 
<p><strong>1）部署有状态应用<br> 2）每个Pod的名称都是唯一且固定不变的<br> 3）每个Pod都可以有自己专属的持久化存储（基于PVC模板volumeClaimTemplates绑定PV实现的）<br> 4）需要提前创建并关联一个Headless Service资源（ClusterIP可以为None），在K8S集群内部的Pod应用可以通过 &lt;pod_name&gt;.&lt;svc_name&gt;.&lt;namespace_name&gt;.svc.cluster.local 格式解析出 PodIP（基于无头服务Headless Service和CoreDNS实现的）<br> 5）创建、滚动升级、扩容、缩容Pod都是有序进行的（默认为串行执行的，podManagementPolicy: OrderedReady(默认)|Parallel）<br> 创建、扩容是升序执行的（顺序为Pod标识号从0到n-1）<br> 滚动升级、缩容是倒序执行的（顺序为Pod标识号从n-1到0）</strong></p> 
<p><strong>Service资源的类型 4+1<br> ClusterIP NodePort LoadBalancer ExternalName + Headless Service</strong></p> 
<h3><a id="83_DaemonSet_470"></a>8.3 DaemonSet</h3> 
<p><strong>1）理论上可以在K8S所有Node节点上创建相同的Pod资源（无论Node节点什么时候加入到K8S集群）<br> 2）调度时会受到Node节点上的污点或者节点设置了cordon不可调度的影响，而不会在上述的Node节点中创建Pod<br> 设置容忍 <code>kubectl node xxx uncordon</code><br> 3）资源清单配置中不需要设置副本数 replicas</strong></p> 
<h3><a id="84_Job_476"></a>8.4 Job</h3> 
<p><strong>1）部署一次性短期任务的资源，Pod不会持久运行<br> 2）任务正常完成后Pod容器会正常退出并不会再重启（restartPolicy通常设置为Nerver或OnFailure），且也不会重建Pod<br> 3）如果任务执行异常导致Pod容器异常退出，会重建Pod重试任务，重试次数受 backoffLimit 配置影响（默认为任务失败后重试 6 次）</strong></p> 
<h3><a id="85_CronJob_481"></a>8.5 CronJob</h3> 
<p><strong>1）部署周期性短期任务的资源，Pod不会持久运行<br> 2）任务正常完成后Pod容器会正常退出并不会再重启（restartPolicy通常设置为Nerver或OnFailure），且也不会重建Pod<br> 3）使用必配字段 schedule 设置任务执行的周期表，格式为</strong> <code>分 时 日 月 周</code></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81f9829c250fcf8ce0e9379f90578124/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是SpringMVC以及和 SpringBoot 的关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/254eae250a62a0f3b631cad93950d45b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">elasticsearch和kibana的安装和启动</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>