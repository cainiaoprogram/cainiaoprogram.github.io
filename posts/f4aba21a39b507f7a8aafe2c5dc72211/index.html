<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从源码角度深入理解Retrofit2 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从源码角度深入理解Retrofit2" />
<meta property="og:description" content="Retrofit2作为目前最火的网络请求框架之一，它是一个由Square 组织开发的可以在Android和java中使用的安全型HTTP客户端（官方文档描述“Type-safe HTTP client for Android and Java by Square”）。本文将从Retrofit2简单使用入手，在对其源码进行分析来深入理解Retrofit2（基于2.5.0版本）。
1.Retrofit2简单使用 1.1 下面，根据官方例子，简单使用一个get请求来演示Retrofit2简单使用。首先gradle中添加retrofit依赖，创建一个描述每一个请求的接口
/** * gradle中添加依赖 */ implementation &#39;com.squareup.retrofit2:retrofit:2.5.0&#39; public interface GitHub { public static final String API_URL = &#34;https://api.github.com&#34;; //使用Get 请求 @GET(&#34;/repos/{owner}/{repo}/contributors&#34;) Call&lt;List&lt;SimpleService.Contributor&gt;&gt; contributors( @Path(&#34;owner&#34;) String owner, @Path(&#34;repo&#34;) String repo); } 复制代码 1.2 创建网络请求数据bean对象
public class SimpleService { public static class Contributor { public final String login; public final int contributions; public Contributor(String login, int contributions) { this.login = login; this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f4aba21a39b507f7a8aafe2c5dc72211/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-11T14:24:48+08:00" />
<meta property="article:modified_time" content="2018-12-11T14:24:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从源码角度深入理解Retrofit2</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <blockquote> 
  <p>Retrofit2作为目前最火的网络请求框架之一，它是一个由Square 组织开发的可以在Android和java中使用的安全型HTTP客户端（官方文档描述“Type-safe HTTP client for Android and Java by Square”）。本文将从Retrofit2简单使用入手，在对其源码进行分析来深入理解<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fsquare%2Fretrofit" rel="nofollow">Retrofit2（基于2.5.0版本）</a>。</p> 
 </blockquote> 
 <ul><li> <h3 class="heading">1.Retrofit2简单使用</h3> 
   <ul><li> <p>1.1 下面，根据官方例子，简单使用一个get请求来演示Retrofit2简单使用。首先gradle中添加retrofit依赖，创建一个描述每一个请求的接口</p> <pre><code class="hljs bash copyable"> /**
  * gradle中添加依赖 
  */
 implementation <span class="hljs-string">'com.squareup.retrofit2:retrofit:2.5.0'</span>

public interface GitHub {

public static final String API_URL = <span class="hljs-string">"https://api.github.com"</span>;
//使用Get 请求
@GET(<span class="hljs-string">"/repos/{owner}/{repo}/contributors"</span>)
Call&lt;List&lt;SimpleService.Contributor&gt;&gt; contributors(
        @Path(<span class="hljs-string">"owner"</span>) String owner,
        @Path(<span class="hljs-string">"repo"</span>) String repo);
}
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>1.2 创建网络请求数据bean对象</p> <pre><code class="hljs bash copyable">public class SimpleService {
public static class Contributor {
    public final String login;
    public final int contributions;

    public Contributor(String login, int contributions) {
        this.login = login;
        this.contributions = contributions;
    }
  }
}
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>1.3 创建retrofit对象，传入网络请求的域名地址，传入刚刚创建的请求对象接口，而我们的网络请求默认返回JSON数据，而retrofit请求默认返回response.body()（异步请求），所以我们需要添加一个GsonConverterFactory转换器将JSON转化为我们的bean对象，需要在gradle中添加如下库的依赖</p> <pre><code class="hljs bash copyable">/**
 * gradle中添加依赖 
 */
implementation <span class="hljs-string">'com.squareup.retrofit2:converter-gson:2.5.0'</span>

 // Create a very simple REST adapter <span class="hljs-built_in">which</span> points the GitHub API.
   Retrofit retrofit=new Retrofit.Builder()
           .baseUrl(GitHub.API_URL)
           .addConverterFactory(GsonConverterFactory.create())
           .build();
   // Create an instance of our GitHub API interface.
   GitHub gitHub = retrofit.create(GitHub.class);
   // Create a call instance <span class="hljs-keyword">for</span> looking up Retrofit contributors.
   final retrofit2.Call&lt;List&lt;SimpleService.Contributor&gt;&gt; call = gitHub.contributors(<span class="hljs-string">"square"</span>, <span class="hljs-string">"retrofit"</span>);
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>1.4 根据上一步拿到的call对象执行同步网络请求获取数据，耗时操作开启子线程执行</p> <pre><code class="hljs bash copyable"> new <span class="hljs-function"><span class="hljs-title">Thread</span></span>(){
      @Override
      public void <span class="hljs-function"><span class="hljs-title">run</span></span>() {
          super.run();
          /**
           * 同步请求
          try {
              List&lt;SimpleService.Contributor&gt; contributors = call.execute().body();
              <span class="hljs-keyword">for</span> (SimpleService.Contributor contributor : contributors) {
               Log.e(<span class="hljs-string">"maoqitian"</span>,<span class="hljs-string">"Retrofit同步请求返回参数"</span>+contributor.login + <span class="hljs-string">" ("</span> + contributor.contributions + <span class="hljs-string">")"</span>);
              }
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }.start();

<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>1.5 根据上一步拿到的call对象执行异步网络请求获取数据</p> <pre><code class="hljs bash copyable">call.enqueue(new retrofit2.Callback&lt;List&lt;SimpleService.Contributor&gt;&gt;() {
      @Override
      public void onResponse(retrofit2.Call&lt;List&lt;SimpleService.Contributor&gt;&gt; call, retrofit2.Response&lt;List&lt;SimpleService.Contributor&gt;&gt; response) {
          List&lt;SimpleService.Contributor&gt; body = response.body();
          <span class="hljs-keyword">for</span> (SimpleService.Contributor contributor : body) {
              Log.e(<span class="hljs-string">"maoqitian"</span>,<span class="hljs-string">"Retrofit异步请求返回参数"</span>+contributor.login + <span class="hljs-string">" ("</span> + contributor.contributions + <span class="hljs-string">")"</span>);
          }
      }

      @Override
      public void onFailure(retrofit2.Call&lt;List&lt;SimpleService.Contributor&gt;&gt; call, Throwable t) {
          Log.e(<span class="hljs-string">"maoqitian"</span>,<span class="hljs-string">"Retrofit异步请求失败"</span>+t.getMessage());
      }
  });
<span class="copy-code-btn">复制代码</span></code></pre></li></ul></li><li> <h3 class="heading">2.源码分析</h3> 
   <ul><li> <h3 class="heading">2.1 retrofit2网络请求基本流程图</h3> </li><li> <p>根据上面的简单使用retrofit的例子，我们可以概括一下大致流程图</p> <p></p> 
     <figure> 
      <figcaption></figcaption> 
     </figure><p></p> </li><li> <h3 class="heading">2.2 retrofit对象创建</h3> </li><li> <p>我们先了解retrofit对象包含了哪些成员变量以及他们的含义和作用</p> <pre><code class="hljs bash copyable">//ServiceMethod 的缓存，从接口中解析出来，放在这个 map 里面。
private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();
//okhttp3.Call.Factory接口对象，接口声明了newCall方法
final okhttp3.Call.Factory callFactory;
//OKHttp3 的HttpUrl 对象，描述了一个 http 地址 
final HttpUrl baseUrl;
//保存ConverterFactory转换器的list，通过Retrofit.Builder的 addConverterFactory方法来添加
final List&lt;Converter.Factory&gt; converterFactories;
//保存CallAdapterFactory适配器的list，通过Retrofit.Builder的 addCallAdapterFactory方法来添加
final List&lt;CallAdapter.Factory&gt; callAdapterFactories;
//回调函数的执行器，也就是回调函数执行的线程，Android 中默认为 MainThreadExecutor
final @Nullable Executor callbackExecutor;
//创建动态代理对象之前，是否提前解析接口 Method，创建 ServiceMethod 并添加到 Cache 中。
final boolean validateEagerly;
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>接着就是创建Retrofit对象new Retrofit.Builder()，一看到Builder我们就可以想到<strong>构造者模式</strong>，通过外部对各个参数的配置来尽可能的达到各种业务请求场景的要求。先看看Builder()中的操作</p> <pre><code class="hljs bash copyable">/** Retrofit的 Builder方法*/
public <span class="hljs-function"><span class="hljs-title">Builder</span></span>() {
  this(Platform.get());
}
/**Platform类中的get方法*/
static Platform <span class="hljs-function"><span class="hljs-title">get</span></span>() {
<span class="hljs-built_in">return</span> PLATFORM;
}

private static final Platform PLATFORM = findPlatform();
/**Platform类中的findPlatform方法*/
private static Platform <span class="hljs-function"><span class="hljs-title">findPlatform</span></span>() {
try {
  Class.forName(<span class="hljs-string">"android.os.Build"</span>);
  <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT != 0) {
    <span class="hljs-built_in">return</span> new Android();
  }
} catch (ClassNotFoundException ignored) {
}
try {
  Class.forName(<span class="hljs-string">"java.util.Optional"</span>);
  <span class="hljs-built_in">return</span> new Java8();
} catch (ClassNotFoundException ignored) {
}
<span class="hljs-built_in">return</span> new Platform();
}
/**Platform类中的Android方法*/
static class Android extends Platform {
@IgnoreJRERequirement // Guarded by API check.
@Override boolean isDefaultMethod(Method method) {
  <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; 24) {
    <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-built_in">return</span> method.isDefault();
}

@Override public Executor <span class="hljs-function"><span class="hljs-title">defaultCallbackExecutor</span></span>() {
  <span class="hljs-built_in">return</span> new MainThreadExecutor();
}

@Override List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(
    @Nullable Executor callbackExecutor) {
  <span class="hljs-keyword">if</span> (callbackExecutor == null) throw new AssertionError();
  ExecutorCallAdapterFactory executorFactory = new ExecutorCallAdapterFactory(callbackExecutor);
  <span class="hljs-built_in">return</span> Build.VERSION.SDK_INT &gt;= 24
    ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)
    : singletonList(executorFactory);
}

@Override int <span class="hljs-function"><span class="hljs-title">defaultCallAdapterFactoriesSize</span></span>() {
  <span class="hljs-built_in">return</span> Build.VERSION.SDK_INT &gt;= 24 ? 2 : 1;
}

@Override List&lt;? extends Converter.Factory&gt; <span class="hljs-function"><span class="hljs-title">defaultConverterFactories</span></span>() {
  <span class="hljs-built_in">return</span> Build.VERSION.SDK_INT &gt;= 24
      ? singletonList(OptionalConverterFactory.INSTANCE)
      : Collections.&lt;Converter.Factory&gt;emptyList();
}

@Override int <span class="hljs-function"><span class="hljs-title">defaultConverterFactoriesSize</span></span>() {
  <span class="hljs-built_in">return</span> Build.VERSION.SDK_INT &gt;= 24 ? 1 : 0;
}

static class MainThreadExecutor implements Executor {
  private final Handler handler = new Handler(Looper.getMainLooper());

  @Override public void execute(Runnable r) {
    handler.post(r);
  }
 }
}
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>由上述源码可以看到，Retrofit的builder方法中调用了Platform.get()方法，最终调用的是findPlatform()，该方法使用反射判断当前的环境来得到不同的Platform对象，接着回到Retrofit的build方法</p> </li></ul><pre><code class="hljs bash copyable">/** Retrofit的 build方法*/
public Retrofit <span class="hljs-function"><span class="hljs-title">build</span></span>() {
  <span class="hljs-keyword">if</span> (baseUrl == null) {
    throw new IllegalStateException(<span class="hljs-string">"Base URL required."</span>);
  }

  okhttp3.Call.Factory callFactory = this.callFactory;
  <span class="hljs-keyword">if</span> (callFactory == null) {
    callFactory = new OkHttpClient();
  }

  Executor callbackExecutor = this.callbackExecutor;
  <span class="hljs-keyword">if</span> (callbackExecutor == null) {
    callbackExecutor = platform.defaultCallbackExecutor();
  }

  // Make a defensive copy of the adapters and add the default Call adapter.
  List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);
  callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));

  // Make a defensive copy of the converters.
  List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(
      1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());

  // Add the built-in converter factory first. This prevents overriding its behavior but also
  // ensures correct behavior when using converters that consume all types.
  converterFactories.add(new BuiltInConverters());
  converterFactories.addAll(this.converterFactories);
  converterFactories.addAll(platform.defaultConverterFactories());

  <span class="hljs-built_in">return</span> new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
      unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
  }
 }
<span class="copy-code-btn">复制代码</span></code></pre> 
   <ul><li> <p>可以看到build方法中callFactory就是OkHttpClient对象，也就是Retrofit的网络请求也是通过OKHttp来完成的；在Android环境中，build中platform调用的方法都是前面提到的Platform的继承类Android中实现的方法，callbackExecutor在主线程执行，默认加载的CallAdapter.Factory为ExecutorCallAdapterFactory，如果Build.VERSION.SDK_INT &gt;= 24(Android 7.0)，则Converter.Factory默认为OptionalConverterFactory，否则为空。最终新建retrofit对象并将设置和默认的参数传入。</p> </li><li> <h3 class="heading">2.3 retrofit.create(class)</h3> </li><li> <p>创建了retrofit对象之后，接着调用了retrofit的create方法，先看看该方法的实现</p> <pre><code class="hljs bash copyable">/**Retrofit类的create方法*/
public &lt;T&gt; T create(final Class&lt;T&gt; service) {
Utils.validateServiceInterface(service);
<span class="hljs-keyword">if</span> (validateEagerly) {
  eagerlyValidateMethods(service);
}
 <span class="hljs-built_in">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
    new <span class="hljs-function"><span class="hljs-title">InvocationHandler</span></span>() {
      private final Platform platform = Platform.get();
      private final Object[] emptyArgs = new Object[0];

      @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)
          throws Throwable {
        // If the method is a method from Object <span class="hljs-keyword">then</span> defer to normal invocation.
        <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) {
          <span class="hljs-built_in">return</span> method.invoke(this, args);
        }
        <span class="hljs-keyword">if</span> (platform.isDefaultMethod(method)) {
          <span class="hljs-built_in">return</span> platform.invokeDefaultMethod(method, service, proxy, args);
        }
        <span class="hljs-built_in">return</span> loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
      }
    });
 }
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>看到retrofit的create方法，代码很少，看到关键代码Proxy，我们就可以知道这里使用了Java的<strong>动态代理</strong>，为了方便下面代码的解读，我们先来简单了解什么是动态代理。</p> </li><li> <h3 class="heading">代理模式</h3> </li><li> <p><strong>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。而代理分为动态代理和静态代理，静态代理中每一个需要被代理的类都要创建一个代理类，这显然很麻烦，所以Java给我们提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy 的类来支持动态代理</strong></p> <pre><code class="hljs bash copyable">//Object proxy:被代理的对象  
//Method method:要调用的方法  
//Object[] args:方法调用时所需要参数  
public interface InvocationHandler {  
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;  
} 

//CLassLoader loader:类的加载器  
//Class&lt;?&gt; interfaces:得到全部的接口  
//InvocationHandler h:得到InvocationHandler接口的子类的实例  
public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException  
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p><a href="https://link.juejin.im?target=http%3A%2F%2Fa.codekk.com%2Fdetail%2FAndroid%2FCaij%2F%25E5%2585%25AC%25E5%2585%25B1%25E6%258A%2580%25E6%259C%25AF%25E7%2582%25B9%25E4%25B9%258B%2520Java%2520%25E5%258A%25A8%25E6%2580%2581%25E4%25BB%25A3%25E7%2590%2586" rel="nofollow">更详细动态代理知识可以自行了解</a></p> </li><li> <p>现在我们回过头看retrofit的create方法，Proxy.newProxyInstance方法加载了我们的网络请求描述接口类和其中定义的方法，并实现了InvocationHandler接口，也就是说create方法实现了动态代理，则调用create方法，也就会调用InvocationHandler接口实现的invoke方法。</p> </li><li> <p>在InvocationHandler接口实现的invoke方法中，如果是 Object对象本身方法（比如equals、toString、hashCode等）以及 Platform 默认的方法（java8默认方法，1.8的新特性），则在正常使用的时候调用返回，如果不满足，最后调用 loadServiceMethod(method)方法，也就是该方法来解析对应接口中我们定义的描述网络请求的方法。</p> </li><li> <h3 class="heading">2.4 解析描述网络请求接口</h3> </li><li> <p>上一小节我们说到loadServiceMethod(method)方法解析对应接口</p> <pre><code class="hljs bash copyable"> /**Retrofit类的loadServiceMethod方法 */
 ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {
  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);
  <span class="hljs-keyword">if</span> (result != null) <span class="hljs-built_in">return</span> result;

  synchronized (serviceMethodCache) {
  result = serviceMethodCache.get(method);
  <span class="hljs-keyword">if</span> (result == null) {
    result = ServiceMethod.parseAnnotations(this, method);
    serviceMethodCache.put(method, result);
   }
  }
 <span class="hljs-built_in">return</span> result;
 }
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>通过该方法，解析接口之后返回的对象是ServiceMethod，如果之前解析过，则直接从serviceMethodCache取出直接返回，否则调用ServiceMethod.parseAnnotations方法进行解析</p> <pre><code class="hljs bash copyable"> /**ServiceMethod&lt;T&gt; 抽象类的parseAnnotations方法**/
 static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) {
 RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);

  Type <span class="hljs-built_in">return</span>Type = method.getGenericReturnType();
  <span class="hljs-keyword">if</span> (Utils.hasUnresolvableType(<span class="hljs-built_in">return</span>Type)) {
  throw methodError(method,
      <span class="hljs-string">"Method return type must not include a type variable or wildcard: %s"</span>, <span class="hljs-built_in">return</span>Type);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">return</span>Type == void.class) {
  throw methodError(method, <span class="hljs-string">"Service methods cannot return void."</span>);
 }

  <span class="hljs-built_in">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
 }
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>如上源码，RequestFactory负责解析接口并且生成Request，继续看RequestFactory的 parseAnnotations方法</p> <pre><code class="hljs bash copyable"> /**RequestFactory 类的parseAnnotations方法**/
 static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
 <span class="hljs-built_in">return</span> new Builder(retrofit, method).build();
 }
 /**RequestFactory 类的build方法**/
 RequestFactory <span class="hljs-function"><span class="hljs-title">build</span></span>() {
  <span class="hljs-keyword">for</span> (Annotation annotation : methodAnnotations) {
  //解析网络请求方法注解
    parseMethodAnnotation(annotation);
  }
  //省略部分代码
  ......
  int parameterCount = parameterAnnotationsArray.length;
  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
  <span class="hljs-keyword">for</span> (int p = 0; p &lt; parameterCount; p++) {
    //方法参数注解的解析
    parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p]);
  }
  //省略部分代码
  .......
  <span class="hljs-built_in">return</span> new RequestFactory(this);
}
/**RequestFactory 类的parseMethodAnnotation方法**/
private void parseMethodAnnotation(Annotation annotation) {
  <span class="hljs-keyword">if</span> (annotation instanceof DELETE) {
    parseHttpMethodAndPath(<span class="hljs-string">"DELETE"</span>, ((DELETE) annotation).value(), <span class="hljs-literal">false</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (annotation instanceof GET) {
    parseHttpMethodAndPath(<span class="hljs-string">"GET"</span>, ((GET) annotation).value(), <span class="hljs-literal">false</span>);
    //剩余其他请求方法注解解析
    ......
    isFormEncoded = <span class="hljs-literal">true</span>;
  }
}
/**RequestFactory 类的parseHttpMethodAndPath方法**/
private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
  <span class="hljs-keyword">if</span> (this.httpMethod != null) {
    throw methodError(method, <span class="hljs-string">"Only one HTTP method is allowed. Found: %s and %s."</span>,
        this.httpMethod, httpMethod);
  }
  this.httpMethod = httpMethod;
  this.hasBody = hasBody;

  <span class="hljs-keyword">if</span> (value.isEmpty()) {
    <span class="hljs-built_in">return</span>;
  }
  // Get the relative URL path and existing query string, <span class="hljs-keyword">if</span> present.
  int question = value.indexOf(<span class="hljs-string">'?'</span>);
  <span class="hljs-keyword">if</span> (question != -1 &amp;&amp; question &lt; value.length() - 1) {
    // Ensure the query string does not have any named parameters.
    String queryParams = value.substring(question + 1);
    Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
    <span class="hljs-keyword">if</span> (queryParamMatcher.find()) {
      throw methodError(method, <span class="hljs-string">"URL query string \"%s\" must not have replace block. "</span>
          + <span class="hljs-string">"For dynamic query parameters use @Query."</span>, queryParams);
    }
  }
  this.relativeUrl = value;
  this.relativeUrlParamNames = parsePathParameters(value);
}
/**RequestFactory 类的parsePathParameters方法**/
static Set&lt;String&gt; parsePathParameters(String path) {
  Matcher m = PARAM_URL_REGEX.matcher(path);
  Set&lt;String&gt; patterns = new LinkedHashSet&lt;&gt;();
  <span class="hljs-keyword">while</span> (m.find()) {
    patterns.add(m.group(1));
  }
  <span class="hljs-built_in">return</span> patterns;
}
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>在解析网络请求注解的方法parseMethodAnnotation中，通过instanceof判断描述网络请求接口的注解中是否包含对应网络请求类型，如果包含则调用parseHttpMethodAndPath设置httpMethod网络请求方法（get），联系到上面的简单例子，相对url(对应/repos/{owner}/{repo}/contributors)，hasBody在get请求中没有，在post请求中为post的参数体，relativeUrlParamNames（对应owner、repo）为相对路径中需要外部传递参数占位符名称，通过正则表达式获取。</p> </li><li> <p>上面我们的分析中只是解析了网络请求注解，还需要解析接口方法参数的注解，看到RequestFactory的parseAnnotations方法中的parseParameter方法</p> <pre><code class="hljs bash copyable"> /**RequestFactory 类的parseParameter方法**/
 private ParameterHandler&lt;?&gt; parseParameter(
    int p, Type parameterType, @Nullable Annotation[] annotations) {
  ParameterHandler&lt;?&gt; result = null;
  <span class="hljs-keyword">if</span> (annotations != null) {
    <span class="hljs-keyword">for</span> (Annotation annotation : annotations) {
      ParameterHandler&lt;?&gt; annotationAction =
          parseParameterAnnotation(p, parameterType, annotations, annotation);
          //省略部分代码
          ....
      }    
   }
  <span class="hljs-built_in">return</span> result;
 }
  /**RequestFactory 类的parseParameterAnnotation方法**/
 @Nullable
 private ParameterHandler&lt;?&gt; parseParameterAnnotation(
    int p, Type <span class="hljs-built_in">type</span>, Annotation[] annotations, Annotation annotation) {
    //省略部分代码
  .......     
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (annotation instanceof Path) {
    validateResolvableType(p, <span class="hljs-built_in">type</span>);
    //各种检查判断
    .....
    gotPath = <span class="hljs-literal">true</span>;

    Path path = (Path) annotation;
    String name = path.value();
    validatePathName(p, name);

    Converter&lt;?, String&gt; converter = retrofit.stringConverter(<span class="hljs-built_in">type</span>, annotations);
    <span class="hljs-built_in">return</span> new ParameterHandler.Path&lt;&gt;(name, converter, path.encoded());
  }
  //省略代码
  ......
  }
  /**ParameterHandler 类的Path实现**/
  static final class Path&lt;T&gt; extends ParameterHandler&lt;T&gt; {
  //省略代码
  ......
  @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
  <span class="hljs-keyword">if</span> (value == null) {
    throw new IllegalArgumentException(
        <span class="hljs-string">"Path parameter \""</span> + name + <span class="hljs-string">"\" value must not be null."</span>);
  }
  builder.addPathParam(name, valueConverter.convert(value), encoded);
  }
 }
 /**RequestBuilder 类的addPathParam方法**/
 void addPathParam(String name, String value, boolean encoded) {
  <span class="hljs-keyword">if</span> (relativeUrl == null) {
  // The relative URL is cleared when the first query parameter is set.
  throw new AssertionError();
  }
 String replacement = canonicalizeForPath(value, encoded);
 String newRelativeUrl = relativeUrl.replace(<span class="hljs-string">"{"</span> + name + <span class="hljs-string">"}"</span>, replacement);
 <span class="hljs-keyword">if</span> (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {
  throw new IllegalArgumentException(
      <span class="hljs-string">"@Path parameters shouldn't perform path traversal ('.' or '..'): "</span> + value);
  }
  relativeUrl = newRelativeUrl;
 }
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>由上源码（源码较多，截取Path注解处理原理），RequestFactory 类的parseParameter方法通过遍历参数注解，调用parseParameterAnnotation方法获取了注解中定义的参数值（path.value()），最后返回了new ParameterHandler.Path&lt;&gt;对象，在ParameterHandler类的Path实现中调用RequestBuilder类（创建请求）的addPathParam方法最终将相对路径relativeUrl的占位符通过描述网络请求接口方法传递的参数替换掉得到正确的相对路径relativeUrl。而得到正确相对路径的RequestBuilder对象创建则在RequestFactory类的create方法中。</p> </li><li> <h3 class="heading">2.5 调用接口中的方法返回Call对象</h3> </li><li> <p>现在我们再次回到ServiceMethod的parseAnnotations方法，经过上面2.4小节的分析我们已经得到了解析到正确相对路径的RequestFactory对象，最终该方法调用了HttpServiceMethod.parseAnnotations()</p> <pre><code class="hljs bash copyable"> /**
  * Inspects the annotations on an interface method to construct a reusable service method that
  * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
  * method only once and reuse it.
  * HttpServiceMethod的parseAnnotations方法
  */
  static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(
  Retrofit retrofit, Method method, RequestFactory requestFactory) {
  //最终通过retrofit对象拿到默认CallAdapter.Factory对象（ExecutorCallAdapterFactory）
  CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method);
  Type responseType = callAdapter.responseType();
  <span class="hljs-keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) {
  throw methodError(method, <span class="hljs-string">"'"</span>
      + Utils.getRawType(responseType).getName()
      + <span class="hljs-string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);
   }
   <span class="hljs-keyword">if</span> (requestFactory.httpMethod.equals(<span class="hljs-string">"HEAD"</span>) &amp;&amp; !Void.class.equals(responseType)) {
   throw methodError(method, <span class="hljs-string">"HEAD method must use Void as response type."</span>);
   }
   //最终通过retrofit拿到设置的Converter.Factory对象（我们设置了GsonConverterFactory）
   Converter&lt;ResponseBody, ResponseT&gt; responseConverter =
    createResponseConverter(retrofit, method, responseType);

   okhttp3.Call.Factory callFactory = retrofit.callFactory;
   <span class="hljs-built_in">return</span> new HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);
 }
 
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>通过该方法源码，首先我们可以知道最刚开始我们分析retrofit的create方法中loadServiceMethod(method)方法实际上就是<strong>HttpServiceMethod对象</strong>，接着继续看parseAnnotations方法中的createCallAdapter方法</p> <pre><code class="hljs bash copyable">/**HttpServiceMethod 类的createCallAdapter方法**/
private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt; createCallAdapter(
  Retrofit retrofit, Method method) {
Type <span class="hljs-built_in">return</span>Type = method.getGenericReturnType();
Annotation[] annotations = method.getAnnotations();
 try {
  //noinspection unchecked
  <span class="hljs-built_in">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(<span class="hljs-built_in">return</span>Type, annotations);
  } catch (RuntimeException e) { // Wide exception range because factories are user code.
  throw methodError(method, e, <span class="hljs-string">"Unable to create call adapter for %s"</span>, <span class="hljs-built_in">return</span>Type);
  }
}
 /**Retrofit 类的callAdapter方法**/
 public CallAdapter&lt;?, ?&gt; callAdapter(Type <span class="hljs-built_in">return</span>Type, Annotation[] annotations) {
 <span class="hljs-built_in">return</span> nextCallAdapter(null, <span class="hljs-built_in">return</span>Type, annotations);
 }
 /**Retrofit 类的nextCallAdapter方法**/
 public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type <span class="hljs-built_in">return</span>Type,
  Annotation[] annotations) {
checkNotNull(<span class="hljs-built_in">return</span>Type, <span class="hljs-string">"returnType == null"</span>);
checkNotNull(annotations, <span class="hljs-string">"annotations == null"</span>);

int start = callAdapterFactories.indexOf(skipPast) + 1;
<span class="hljs-keyword">for</span> (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) {
  CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(<span class="hljs-built_in">return</span>Type, annotations, this);
  <span class="hljs-keyword">if</span> (adapter != null) {
    <span class="hljs-built_in">return</span> adapter;
  }
 }
 //省略部分代码
  ......
}
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>由上源码HttpServiceMethod通过自身createCallAdapter调用Retrofit 类的callAdapter方法，而Retrofit 类的callAdapter方法又调用 Retrofit 类的nextCallAdapter方法遍历callAdapterFactories来得到CallAdapter.Factory对象；前面我们分析retrofit对象创建时已经说过Platform对象中提供了默认的CallAdapter.Factory对象为ExecutorCallAdapterFactory，该对象也就是HttpServiceMethod的createCallAdapter方法得到的CallAdapter.Factory对象。同理，HttpServiceMethod的createResponseConverter最终通过retrofit的nextResponseBodyConverter方法得到了Converter（GsonRequestBodyConverter）对象（我们设置了GsonConverterFactory.responseBodyConverter的方法创建了该对象），这里就不贴代码了。</p> </li><li> <p>接着上面的分析，我们在代理的invoke方法中返回了loadServiceMethod(method).invoke(args != null ? args : emptyArgs)这一句代码，当retrofit.create生成的的接口对象调用其中的接口的方法，则会触发动态代理执行invoke方法，最终返回loadServiceMethod(method).invoke，也就是执行了HttpServiceMethod.ivnoke方法</p> <pre><code class="hljs bash copyable">  /**HttpServiceMethod 类的invoke方法**/
 @Override ReturnT invoke(Object[] args) {
 <span class="hljs-built_in">return</span> callAdapter.adapt(
    new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));
 }
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>可以看到HttpServiceMethod类的invoke方法中调用了callAdapter.adapt，而这个callAdapter经过我们前面的分析已经知道是默认添加的ExecutorCallAdapterFactory对象，继续看ExecutorCallAdapterFactory对象</p> <pre><code class="hljs bash copyable"> /**ExecutorCallAdapterFactory 类**/
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
 final Executor callbackExecutor;

 ExecutorCallAdapterFactory(Executor callbackExecutor) {
 this.callbackExecutor = callbackExecutor;
 }

  @Override public @Nullable CallAdapter&lt;?, ?&gt; get(
  Type <span class="hljs-built_in">return</span>Type, Annotation[] annotations, Retrofit retrofit) {
  <span class="hljs-keyword">if</span> (getRawType(<span class="hljs-built_in">return</span>Type) != Call.class) {
  <span class="hljs-built_in">return</span> null;
  }
  final Type responseType = Utils.getCallResponseType(<span class="hljs-built_in">return</span>Type);
  <span class="hljs-built_in">return</span> new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() {
  @Override public Type <span class="hljs-function"><span class="hljs-title">responseType</span></span>() {
    <span class="hljs-built_in">return</span> responseType;
  }

  @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) {
    <span class="hljs-built_in">return</span> new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);
   }
  };
 }
 /**ExecutorCallbackCall 类**/
 static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; {
 final Executor callbackExecutor;
 final Call&lt;T&gt; delegate;

 ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) {
  this.callbackExecutor = callbackExecutor;
  this.delegate = delegate;
  }
 @Override public void enqueue(final Callback&lt;T&gt; callback) {
  checkNotNull(callback, <span class="hljs-string">"callback == null"</span>);
  delegate.enqueue(new Callback&lt;T&gt;() {
    @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) {
      callbackExecutor.execute(new <span class="hljs-function"><span class="hljs-title">Runnable</span></span>() {
        @Override public void <span class="hljs-function"><span class="hljs-title">run</span></span>() {
          <span class="hljs-keyword">if</span> (delegate.isCanceled()) {
            // Emulate OkHttp<span class="hljs-string">'s behavior of throwing/delivering an IOException on cancellation.
            callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
          } else {
            callback.onResponse(ExecutorCallbackCall.this, response);
          }
        }
      });
    }
    @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) {
      callbackExecutor.execute(new Runnable() {
        @Override public void run() {
          callback.onFailure(ExecutorCallbackCall.this, t);
        }
      });
    }
  });
  }
//省略代码
......
@Override public Response&lt;T&gt; execute() throws IOException {
  return delegate.execute();
}
 //省略代码
......
}
</span><span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>通过ExecutorCallAdapterFactory的源码应该会有一种让你恍然大悟的感觉</p> 
     <ul><li>1.通过ExecutorCallAdapterFactory的adapt方法，我们我们已经得到了Call对象，它就是ExecutorCallbackCall</li><li>2.ExecutorCallbackCall的enqueue方法执行在主线程，callbackExecutor就是Platfrom默认添加的MainThreadExecutor（Android环境中），所以callback.onResponse中随意更新UI</li><li>3.delegate对象就是OkHttpCall对象，所以我们Call执行的enqueue和execute方法都是OkHttpCall对象对象的enqueue和execute方法。</li></ul></li><li> <h3 class="heading">Retrofit中的适配器模式和装饰模式</h3> 
     <ul><li> <p><strong>适配器模式做为两个不同的接口之间的桥梁</strong>，使得Retrofit2.Call接口可以使用OKHttp.Call的实现来执行网络请求，而适配器就是CallAdapter.Factory</p> </li><li> <p>装饰模式在不改变原有类的基础上进行扩展，也就是ExecutorCallbackCall，对OKHttp.Call进行装饰，本身它执行enqueue方法是在子线程中，而ExecutorCallbackCall对其装饰让其返回值执行在主线程中。</p> </li><li> <p>下面通过一张图来帮助理解</p> <p></p> 
       <figure> 
        <figcaption></figcaption> 
       </figure><p></p> </li></ul></li><li> <h3 class="heading">2.6 Call对象执行网络请求</h3> </li><li> <p>通过上一小节的分析，我们来看看OkHttpCall对象是如何执行网络请求的</p> <pre><code class="hljs bash copyable"> /*OkHttpCall类的enqueue方法*/
 @Override public void enqueue(final Callback&lt;T&gt; callback) {
 checkNotNull(callback, <span class="hljs-string">"callback == null"</span>);
 okhttp3.Call call;
 Throwable failure;
 synchronized (this) {
  <span class="hljs-keyword">if</span> (executed) throw new IllegalStateException(<span class="hljs-string">"Already executed."</span>);
  executed = <span class="hljs-literal">true</span>;

  call = rawCall;
  failure = creationFailure;
  <span class="hljs-keyword">if</span> (call == null &amp;&amp; failure == null) {
    try {
      call = rawCall = createRawCall();
    } catch (Throwable t) {
      throwIfFatal(t);
      failure = creationFailure = t;
    }
  }
}

 <span class="hljs-keyword">if</span> (failure != null) {
  callback.onFailure(this, failure);
  <span class="hljs-built_in">return</span>;
 }

 <span class="hljs-keyword">if</span> (canceled) {
  call.cancel();
 }

 call.enqueue(new okhttp3.<span class="hljs-function"><span class="hljs-title">Callback</span></span>() {
  @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
    Response&lt;T&gt; response;
    try {
      response = parseResponse(rawResponse);
    } catch (Throwable e) {
      throwIfFatal(e);
      callFailure(e);
      <span class="hljs-built_in">return</span>;
    }

    try {
      callback.onResponse(OkHttpCall.this, response);
    } catch (Throwable t) {
      t.printStackTrace();
    }
   }

  @Override public void onFailure(okhttp3.Call call, IOException e) {
    callFailure(e);
  }

  private void callFailure(Throwable e) {
    try {
      callback.onFailure(OkHttpCall.this, e);
    } catch (Throwable t) {
      t.printStackTrace();
    }
  }
  });
 }
/*OkHttpCall类的execute方法*/
@Override public Response&lt;T&gt; execute() throws IOException {
 okhttp3.Call call;
 synchronized (this) {
  <span class="hljs-keyword">if</span> (executed) throw new IllegalStateException(<span class="hljs-string">"Already executed."</span>);
  executed = <span class="hljs-literal">true</span>;
  //省略部分代码
  .......
  call = rawCall;
  <span class="hljs-keyword">if</span> (call == null) {
    try {
      call = rawCall = createRawCall();
    } catch (IOException | RuntimeException | Error e) {
     //省略部分代码
    .......
  }
  <span class="hljs-built_in">return</span> parseResponse(call.execute());
 }
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>通过以上源码，我们可以看到执行完全请求的是okhttp3.Call对象，也就是说retrofit的网络请求时由OKHttp3来完成的，继续看得到okhttp3.Call对象的createRawCall()方法</p> <pre><code class="hljs bash copyable"> /*OkHttpCall类的createRawCall方法*/
 private okhttp3.Call createRawCall() throws IOException {
 okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
 <span class="hljs-keyword">if</span> (call == null) {
  throw new NullPointerException(<span class="hljs-string">"Call.Factory returned null."</span>);
 }
 <span class="hljs-built_in">return</span> call;
 }
/*retrofit类的build方法*/
 public Retrofit <span class="hljs-function"><span class="hljs-title">build</span></span>() {
  okhttp3.Call.Factory callFactory = this.callFactory;
  //省略部分代码
    .......
  <span class="hljs-keyword">if</span> (callFactory == null) {
    callFactory = new OkHttpClient();
  }
  //省略部分代码
    .......
 }
 
<span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>通过OkHttpCall类的createRawCall方法和retrofit类的build方法，callFactory.newCall，也就是OkHttpClient.nawCall，而requestFactory.create()返回的就是OKHttp的 request 对象，经过前面的分析，RequestFactory解析好的请求数据传递给了OkHttpClient。</p> </li><li> <p>关于OkHttpClient是如何执行网络请求的可以看我之前的一篇文章</p> 
     <ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fcdbb11f2abe8" rel="nofollow">从源码角度深入理解OKHttp3</a></li></ul></li><li> <h3 class="heading">2.7 Converter对象转换网络请求成功返回数据</h3> </li><li> <p>通过上一小节，我们已经通过OkHttp进行了实际的网络请求，请求成功的数据根据之前新建Retrofit对象的时候我们指定了GsonConverterFactory，并在HttpServiceMethod通过createResponseConverter方法得到了GsonResponseBodyConverter对象（可以查看2.5小节分析）。</p> </li><li> <p>请求成功返回的数据会经过OkHttpCall类的parseResponse方法进行处理</p> <pre><code class="hljs bash copyable"> /*OkHttpCall类的parseResponse方法*/
 Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException {
 ResponseBody rawBody = rawResponse.body();

 // Remove the body<span class="hljs-string">'s source (the only stateful object) so we can pass the response along.
 rawResponse = rawResponse.newBuilder()
    .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
    .build();
//省略部分代码
    .......
 ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
 try {
  T body = responseConverter.convert(catchingBody);
  return Response.success(body, rawResponse);
 } catch (RuntimeException e) {
   //省略部分代码
    .......
 }
}
/* GsonResponseBodyConverter类*/
final class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; {
private final Gson gson;
private final TypeAdapter&lt;T&gt; adapter;

GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) {
this.gson = gson;
this.adapter = adapter;
 }
 @Override public T convert(ResponseBody value) throws IOException {
 JsonReader jsonReader = gson.newJsonReader(value.charStream());
 try {
  T result = adapter.read(jsonReader);
  if (jsonReader.peek() != JsonToken.END_DOCUMENT) {
    throw new JsonIOException("JSON document was not fully consumed.");
  }
  return result;
   } finally {
  value.close();
  }
 }
}
</span><span class="copy-code-btn">复制代码</span></code></pre></li><li> <p>通过以上源码可以看到通过Retrofit对象指定GsonConverterFactory后得到的GsonResponseBodyConverter的对象帮我们把Json数据通过Gson处理成我们指定的bean对象，很方便。到此，retrofit的源码分析就结束了。</p> </li><li> <p>最后通过一张类之间调用流程图来帮助更好理解retrofit源码</p> <p></p> 
     <figure> 
      <figcaption></figcaption> 
     </figure><p></p> </li></ul></li></ul> 
 <blockquote> 
  <p>Retrofit整个框架源码量其实不算太多，其中巧妙的运用设计模式来完成整个框架设计。静下心来阅读源码对自己的提升还是很有帮助的。由于本人水平有限，文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢和关注。</p> 
 </blockquote> 
 <ul><li> <p>参考链接</p> 
   <ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Ffb8d21978e38" rel="nofollow">Retrofit分析-经典设计模式案例</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fsquare.github.io%2Fretrofit%2F" rel="nofollow">官方文档</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F48205adc4857" rel="nofollow">简书同步地址</a></li></ul></li></ul> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38eb1a16eef2c0d84102df44f4dfe136/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu下用apt-get时一直报[正在等待报头]</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4581a3bc6ef3d2c36aef1436710f2175/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">React 封装的Form组件wrappedComponentRef引用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>