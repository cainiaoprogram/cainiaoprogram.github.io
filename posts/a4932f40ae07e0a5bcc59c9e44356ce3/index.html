<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>代码随想录30——回溯：332重新安排行程、51N皇后、37解数独 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="代码随想录30——回溯：332重新安排行程、51N皇后、37解数独" />
<meta property="og:description" content="文章目录 1.332重新安排行程1.1.题目1.2.解答1.2.1.思路1.2.2.代码 2.51N皇后2.1.题目2.2.解答 3.37解数独3.1.题目3.2.解答3.2.1.正确解法3.2.2.自己的写法，没有AC，待二刷看 1.332重新安排行程 参考：代码随想录，332重新安排行程
1.1.题目 1.2.解答 1.2.1.思路 1.题目理解
这道题目还是比较复杂的，但是只是题目的意思和最后代码稍微复杂一点，但是实际上并不难。这道题目其实就像是一个图，图中有很多节点，然后给了不同节点之前的连接箭头；给你一个起点，让你遍历整个图的所有节点，同时要使用完所有的箭头，不能多用也不能少用。只不过这道题把图的节点换成了机场，把箭头换成了机票，更加有实际意义。
解答的方法和回溯的穷举法是一样的，因为题目先给了所有的机票，也就是所有的箭头，即从哪里出发，可以飞往哪里。比如从机场A出发，可以飞往机场BCD，比如给了机票是[A, B], [A, B], [A, C], [A, D]，其实就是从A出发，A→B有两张机票（两个箭头，注意相同的起止点可以有多张机票）、A→C有一张机票，A→D有一张机票。
那么其实问题就变成，从某个点出发之后，他可以飞往多个下一个目的地；然后从新的下一个目的地出发，又可以飞往多个下下个目的地…依次类推，直到用完所有的机票飞往所有的目的地。但是这个过程中，可能会陷入胡同，比如下图（1）所示，如果一开始就从A飞往C，结果是无法用完所有机票遍历所有机场，而A→B→A→C满足最终要求。那么如何判断收集的一条飞行路径是遍历完了所有节点，并且用完了所有机票呢？如下图（2）所示，其实只需要统计我们飞行的路径中，机场的个数和机票的张数的关系，如果机场的的个数=机票的张数&#43;1，那么说明就用完了所有的机票（只要是用完了所有的机票，自然就遍历完了所有的节点，所以其实用完所有机票才是真正的要求）
2.遍历过程
其实理解了上面的题目要求之后，很容易发现这个和之前的排列问题是很相似的，其实就是每次选择当前的空的所有可能，然后调用递归选择下一个空的数的选择。本题以输入：[[&#34;JFK&#34;, &#34;KUL&#34;], [&#34;JFK&#34;, &#34;NRT&#34;], [&#34;NRT&#34;, &#34;JFK&#34;]为例，抽象为树形结构如下：
所以这里在代码实现上就有两点需要注意：
记录当前机场的目的机场，即当前机场可以飞往哪里记录当前机场飞往目的机场的剩余机票张数，比如A→B有两张机票，飞一次的话就少一张，至少有一张机票才能飞 所以这里使用的数据结构是map&lt;string, map&lt;string, int&gt;，表示&lt;起飞机场，&lt;目的地，剩余机票张数&gt;&gt;。但是这里还需要思考一下，是否可以优化数据结构提高效率，因为map有map和unordered_map的区别：unordered_map底层是哈希表，查询搜索是O(1)；而map底层是红黑树，可以增删，查询搜索是O(logn)，另外map的键是有序的。
由于查询出发机场需要快速查找，所以使用unordered_map更好。
那么达到机场使用哪个呢？注意到题目要求中是返回字典序号靠前的结果，所以我们要把目标机场的存储就按照键的值进行有序存储，这样遍历目标机场的时候自然就会遍历字典序号在前面的机场，自然就满足了题目的要求。所以到达机场使用map的数据结构更好。
此外注意，题目要求返回字典序号靠前的那个路线就可以了，而不是要求返回所有的路线，所以我们并不是要利用回溯的特性寻找所有可能的解，而是只需要找到其中的一个解。一旦找到了第一个解，那么整个递归函数就立马结束，不用再递归了。所以这里递归函数需要有返回值。
1.2.2.代码 上面就是给出了自己的讲解，具体更加详细的讲解可以去看代码随想录网站上的讲解。但是只要理解了上面的步骤，可以直接看下面的代码，有详细的注释，本题并不是特别难。
注意：这道题其实也是一道图论中深度优先搜索的题目，只不过在深度优先搜索中也涉及到回溯，所以这里按照回溯来理解也是没有问题的。
// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets // 注意为什么要用这种方式：因为我们要记录从当前机场出发，可以往哪些机场飞。比如出发机场是A，到达机场 // 可以是BCD等。还有一个问题是每张机票只能用一次，所以我们还要记录从出发机场飞往达到机场的剩余机票的张数， // 比如可能有三张从A飞往B的机票，那么每次遍历机场A的时候，如果向往机场B非，就要先判断是否还有A-&gt;B的机票 // 如果有就可以飞 unordered_map&lt;string, map&lt;string, int&gt;&gt; targets; // ticketNum是一共有多少张机票，result是最终的飞行路线结果 bool backtracking(int ticketNum, vector&lt;string&gt; &amp;result) { // 递归终止条件：如果飞行路线中机场个数 = 机票张数 &#43; 1，则说明把所有机票都用完了， // 即收集到了一个可能路线 if (result." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a4932f40ae07e0a5bcc59c9e44356ce3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-19T21:57:06+08:00" />
<meta property="article:modified_time" content="2022-10-19T21:57:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">代码随想录30——回溯：332重新安排行程、51N皇后、37解数独</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1332_2" rel="nofollow">1.332重新安排行程</a></li><li><ul><li><a href="#11_5" rel="nofollow">1.1.题目</a></li><li><a href="#12_11" rel="nofollow">1.2.解答</a></li><li><ul><li><a href="#121_13" rel="nofollow">1.2.1.思路</a></li><li><a href="#122_42" rel="nofollow">1.2.2.代码</a></li></ul> 
  </li></ul> 
  </li><li><a href="#251N_109" rel="nofollow">2.51N皇后</a></li><li><ul><li><a href="#21_112" rel="nofollow">2.1.题目</a></li><li><a href="#22_115" rel="nofollow">2.2.解答</a></li></ul> 
  </li><li><a href="#337_199" rel="nofollow">3.37解数独</a></li><li><ul><li><a href="#31_202" rel="nofollow">3.1.题目</a></li><li><a href="#32_206" rel="nofollow">3.2.解答</a></li><li><ul><li><a href="#321_208" rel="nofollow">3.2.1.正确解法</a></li><li><a href="#322AC_298" rel="nofollow">3.2.2.自己的写法，没有AC，待二刷看</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1332_2"></a>1.332重新安排行程</h2> 
<p>参考：<a href="https://www.programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html" rel="nofollow">代码随想录，332重新安排行程</a></p> 
<h3><a id="11_5"></a>1.1.题目</h3> 
<p><img src="https://images2.imgbox.com/8e/51/13nx3yLO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bb/23/viHViCU4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="12_11"></a>1.2.解答</h3> 
<h4><a id="121_13"></a>1.2.1.思路</h4> 
<p><strong>1.题目理解</strong></p> 
<p>这道题目还是比较复杂的，但是只是题目的意思和最后代码稍微复杂一点，但是实际上并不难。这道题目其实就像是一个图，图中有很多节点，然后给了不同节点之前的连接箭头；给你一个起点，让你遍历整个图的所有节点，同时要使用完所有的箭头，不能多用也不能少用。只不过这道题把图的节点换成了机场，把箭头换成了机票，更加有实际意义。</p> 
<p>解答的方法和回溯的穷举法是一样的，因为题目先给了所有的机票，也就是所有的箭头，即从哪里出发，可以飞往哪里。比如从机场A出发，可以飞往机场BCD，比如给了机票是<code>[A, B], [A, B], [A, C], [A, D]</code>，其实就是从A出发，A→B有两张机票（两个箭头，注意<strong>相同的起止点可以有多张机票</strong>）、A→C有一张机票，A→D有一张机票。</p> 
<p>那么其实问题就变成，从某个点出发之后，他可以飞往多个下一个目的地；然后从新的下一个目的地出发，又可以飞往多个下下个目的地…依次类推，直到用完所有的机票飞往所有的目的地。但是这个过程中，可能会陷入胡同，比如下图（1）所示，如果一开始就从A飞往C，结果是无法用完所有机票遍历所有机场，而A→B→A→C满足最终要求。那么如何判断收集的一条飞行路径是遍历完了所有节点，并且用完了所有机票呢？如下图（2）所示，其实只需要统计我们飞行的路径中，机场的个数和机票的张数的关系，如果机场的的个数=机票的张数+1，那么说明就用完了所有的机票（只要是用完了所有的机票，自然就遍历完了所有的节点，所以其实用完所有机票才是真正的要求）</p> 
<p><img src="https://images2.imgbox.com/4c/9d/KcXtHYfy_o.png" alt="在这里插入图片描述"></p> 
<p><strong>2.遍历过程</strong><br> 其实理解了上面的题目要求之后，很容易发现这个和之前的排列问题是很相似的，其实就是每次选择当前的空的所有可能，然后调用递归选择下一个空的数的选择。本题以输入：<code>[["JFK", "KUL"], ["JFK", "NRT"], ["NRT", "JFK"]</code>为例，抽象为树形结构如下：</p> 
<p><img src="https://images2.imgbox.com/63/6a/ghlToiON_o.png" alt="在这里插入图片描述"></p> 
<p>所以这里在<strong>代码实现上就有两点需要注意</strong>：</p> 
<ul><li>记录当前机场的目的机场，即当前机场可以飞往哪里</li><li>记录当前机场飞往目的机场的剩余机票张数，比如A→B有两张机票，飞一次的话就少一张，至少有一张机票才能飞</li></ul> 
<p>所以这里使用的数据结构是<code>map&lt;string, map&lt;string, int&gt;</code>，表示<code>&lt;起飞机场，&lt;目的地，剩余机票张数&gt;&gt;</code>。但是这里还需要思考一下，是否可以优化数据结构提高效率，因为<code>map</code>有<code>map</code>和<code>unordered_map</code>的区别：<code>unordered_map</code>底层是哈希表，查询搜索是<code>O(1)</code>；而<code>map</code>底层是红黑树，可以增删，查询搜索是<code>O(logn)</code>，另外<code>map</code>的键是有序的。</p> 
<p><img src="https://images2.imgbox.com/7d/93/o4ohuhx6_o.png" alt="在这里插入图片描述">由于查询出发机场需要快速查找，所以使用<code>unordered_map</code>更好。</p> 
<p>那么<strong>达到机场使用哪个呢</strong>？注意到题目要求中是返回字典序号靠前的结果，所以我们要把目标机场的存储就按照键的值进行有序存储，这样遍历目标机场的时候自然就会遍历字典序号在前面的机场，自然就满足了题目的要求。所以到达机场使用<code>map</code>的数据结构更好。</p> 
<p>此外注意，题目要求返回字典序号靠前的那个路线就可以了，而不是要求返回所有的路线，所以我们并不是要利用回溯的特性寻找所有可能的解，而是只需要找到其中的一个解。一旦找到了第一个解，那么整个递归函数就立马结束，不用再递归了。所以这里<strong>递归函数需要有返回值</strong>。</p> 
<h4><a id="122_42"></a>1.2.2.代码</h4> 
<p>上面就是给出了自己的讲解，具体更加详细的讲解可以去看代码随想录网站上的讲解。但是只要理解了上面的步骤，可以直接看下面的代码，有详细的注释，本题并不是特别难。</p> 
<p><mark>注意</mark>：这道题其实也是一道<strong>图论中深度优先搜索</strong>的题目，只不过在深度优先搜索中也涉及到回溯，所以这里按照回溯来理解也是没有问题的。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span>
<span class="token comment">// 注意为什么要用这种方式：因为我们要记录从当前机场出发，可以往哪些机场飞。比如出发机场是A，到达机场</span>
<span class="token comment">// 可以是BCD等。还有一个问题是每张机票只能用一次，所以我们还要记录从出发机场飞往达到机场的剩余机票的张数，</span>
<span class="token comment">// 比如可能有三张从A飞往B的机票，那么每次遍历机场A的时候，如果向往机场B非，就要先判断是否还有A-&gt;B的机票</span>
<span class="token comment">// 如果有就可以飞</span>
unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> targets<span class="token punctuation">;</span>

<span class="token comment">// ticketNum是一共有多少张机票，result是最终的飞行路线结果</span>
<span class="token keyword">bool</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> ticketNum<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>result<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 递归终止条件：如果飞行路线中机场个数 = 机票张数 + 1，则说明把所有机票都用完了，</span>
    <span class="token comment">//             即收集到了一个可能路线</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ticketNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 开始递归：从路线中最后一个机场出发（也就是上一次到达的机场，或者最初起飞的机场），遍历所有</span>
    <span class="token comment">//         它可能飞往的达到机场，寻找一条路径</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>target <span class="token operator">:</span> targets<span class="token punctuation">[</span>result<span class="token punctuation">[</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果从当前机场，飞往到达机场的机票还有剩余，那么就还能飞</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>second <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 飞往到达机场，加到路线中</span>
            target<span class="token punctuation">.</span>second<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token comment">// 当前机场-&gt;到达机场，所以机票张数-1</span>
            <span class="token comment">// 重要：递归调用，从下一个机场作为起飞点，再次寻找飞往的目的地</span>
            <span class="token comment">//     (1)如果调用下一个机场的结果是true，说明找到了一条路线，则直接返回</span>
            <span class="token comment">//     (2)如果调用下一个机场的结果是false，说明没有找到一条完整路线（即走到了死胡同里）</span>
            <span class="token comment">//        那么就到了下面回溯的过程：即把当前for循环选择的到达机场弹出，换另一个到达机场</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">backtracking</span><span class="token punctuation">(</span>ticketNum<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment">// 找到一条路线就返回</span>
            result<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span>
            <span class="token comment">// 注意：这里一定不要忘了机票数量++，因为上面--是因为当前位置的到达机场为当前for循环选择的值</span>
            <span class="token comment">//      （假设是B）的时候，后面调用递归安排后面的路线。一旦后面递归完成，说明当前位置选择</span>
            <span class="token comment">//      这个for循环的值B经过测试不能满足要求了，所以要把当前选择的到达机场B弹出，然后把</span>
            <span class="token comment">//      它的机票张数也复原，然后重新选择另一个达到机场C，此时B的机票张数应该还是原来的张数</span>
            <span class="token comment">//      所以这里回溯的时候一定要把机票张数也++，对机票张数进行复原</span>
            target<span class="token punctuation">.</span>second<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">findItinerary</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> <span class="token operator">&amp;</span>tickets<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    targets<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>vec <span class="token operator">:</span> tickets<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// vec[0]是触发机场的名称，targets[vec[0]]就是取出键对应的值，即&lt;到达机场，剩余机票次数&gt;</span>
        targets<span class="token punctuation">[</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 记录映射关系</span>
    <span class="token punctuation">}</span>
    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"JFK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 起始机场</span>
    <span class="token function">backtracking</span><span class="token punctuation">(</span>tickets<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="251N_109"></a>2.51N皇后</h2> 
<p>参考：<a href="https://www.programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E6%80%9D%E8%B7%AF" rel="nofollow">代码随想录，51N皇后</a></p> 
<h3><a id="21_112"></a>2.1.题目</h3> 
<p><img src="https://images2.imgbox.com/91/c8/ktAkh1lB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22_115"></a>2.2.解答</h3> 
<p>都知道n皇后问题是回溯算法解决的经典问题，但是用回溯解决多了组合、切割、子集、排列问题之后，遇到这种二维矩阵还会有点不知所措。</p> 
<p>首先来看一下皇后们的约束条件：</p> 
<ul><li>不能同行</li><li>不能同列</li><li>不能同对角线</li></ul> 
<p><mark>注意</mark>：上面的图中黄色和灰色不代表任何含义，只是为了让棋盘看起来更加有区分度，对于下棋没有任何约束。</p> 
<p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。下面用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p> 
<p><img src="https://images2.imgbox.com/29/97/BKWvTPug_o.png" alt="在这里插入图片描述"><br> 其实思路就很简单了，分两步：</p> 
<ul><li>递归的层数就是棋盘的行数，每一层就是在选择棋盘的每一行。</li><li>对于某一行，用<code>for</code>循环从头开始遍历所有它可能能够放置皇后的位置。如果能够放置皇后，那么就在这里放置一个皇后，然后继续遍历下一行，放置下一行的皇后。</li></ul> 
<p>而递归的终止条件就是如果当前遍历到了第<code>n</code>行（因为是从0行开始，所以就相当于此时遍历出了棋盘范围），<strong>则说明每一个行都放置了一个合法位置的皇后</strong>（如果这一行的所有位置都不能放置的话，相当于<code>for</code>循环什么都没干，所以无法进入内部的<code>if</code>，也就无法再次调用递归选择下一行的放置皇后的位置，相当于递归到这一行就提前结束了），说明此时的棋盘就是一种合法的放置方式。</p> 
<p>所以这里的代码写法和之前是一样的，之前用的都是<code>path</code>收集当前的路径，这里就是用一个<code>chess_board</code>收集当前的放置方法。直接给出代码如下，很简单：</p> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> result<span class="token punctuation">;</span>  <span class="token comment">// 最终收集的所有可能的放置方案</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> chess_board<span class="token punctuation">;</span>     <span class="token comment">// 当前放置的棋盘格，就是之前组合问题中的path</span>

<span class="token comment">// 传入棋盘格的大小，当前要放置皇后的行，当前要放置皇后的列，已经放置的棋盘格，</span>
<span class="token comment">//    判断是否能够在当前位置放置皇后</span>
<span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 判断列</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> row<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>chess_board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span>  <span class="token comment">// 每一行的当前列</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 注意：这里不用判断行是否在同一行，因为我们是逐行放置皇后，即遍历当前行的时候，之前一定是没有放置过的</span>

    <span class="token comment">// 判断左上角对角线</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> row<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> col<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&gt;=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>chess_board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 判断右上角对角线</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> row<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&gt;=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>chess_board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'Q'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 递归终止条件：遍历到第n行了（从0开始），说明棋盘已经放置满了，所以是一种合理的结果</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> row<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>chess_board<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 遍历当前行的每一个位置，判断是否可以放置皇后</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// 如果当前位置可以放置皇后</span>
        <span class="token punctuation">{<!-- --></span>
            chess_board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'Q'</span><span class="token punctuation">;</span>   <span class="token comment">// 放置皇后</span>
            <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 放置下一行的皇后</span>
            chess_board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'.'</span><span class="token punctuation">;</span>   <span class="token comment">// 回溯，删除当前位置放置的皇后</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 初始化nxn的棋盘格为空，没有放置任何皇后</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        chess_board<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    result<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从棋盘格第0行开始放置皇后</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="337_199"></a>3.37解数独</h2> 
<p>参考：<a href="https://www.programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html" rel="nofollow">代码随想录，37解数独</a></p> 
<h3><a id="31_202"></a>3.1.题目</h3> 
<p><img src="https://images2.imgbox.com/e8/87/VgsR45H5_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b9/cf/jPkdInWr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="32_206"></a>3.2.解答</h3> 
<h4><a id="321_208"></a>3.2.1.正确解法</h4> 
<p>这里具体的思路直接去看代码随想录的网站讲解吧，或者看下面代码的详细注释。根据注释仔细理清思路：</p> 
<ul><li>首先两个<code>for</code>循环和之前N皇后问题是不一样的，因为N皇后问题每次一行中只需要选择一个空放置皇后，然后遍历每一行。但是数独问题一行中有多个空，同样还要遍历所有的行。所以数独需要有两个<code>for</code>循环：一个<code>for(i)</code>遍历数独的所有行，这个是总体看数独；一个<code>for(j)</code>遍历某一行中所有列的空位。对于每一个空位，使用<code>for</code>循环是遍历它可以填写的数字的所有可能。</li><li>数独是存在唯一解的，所以其唯一的解在代码中对应就是每一个空位选择的数字都满足<code>isValid</code>的要求，从而调用递归函数继续填写整个数独。此时虽然代码是每次都从头遍历整个数独，但是真正要填的数字是从上一次填写的位置后面开始的。只有每一个空位都满足<code>isValid</code>的要求，这样不断的递归下去，直到把<code>for(j)</code>和<code>for(i)</code>的两个<code>for</code>循环都遍历完了，说明找到了最终的解。所以在<code>for(i)</code>外面会<code>return true</code>。</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">,</span> <span class="token keyword">char</span> num<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 同一行不能有相同的</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> num<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 同一列不能有相同的</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">==</span> num<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 同一个小的九宫格不能有相同的</span>
    <span class="token keyword">int</span> start_row <span class="token operator">=</span> row <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>
    start_row <span class="token operator">*=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> start_col <span class="token operator">=</span> col <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>
    start_col <span class="token operator">*=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>start_row <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">[</span>start_col <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">==</span> num<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 正确解法</span>
<span class="token keyword">bool</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 遍历数独的每一行</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> row <span class="token operator">&lt;</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> row<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 遍历数独的每一列</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 当前位置原来就有数字，或者之前填过数字了，就不用填了</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'.'</span><span class="token punctuation">)</span>  
                <span class="token keyword">continue</span><span class="token punctuation">;</span>

            <span class="token comment">// 否则遍历1-9，查找哪些数字可能填入当前的空中</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> num <span class="token operator">=</span> <span class="token char">'1'</span><span class="token punctuation">;</span> num <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">;</span> num<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>   <span class="token comment">// 修改棋盘格，当前位置填入num</span>
                    <span class="token comment">// 递归，再次填数独，这样下次递归的函数里面直接会走上面的continue，因为这个位置已经填了数了</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">backtracking</span><span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'.'</span><span class="token punctuation">;</span>  <span class="token comment">// 回溯</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 重要：这里才是递归的终止条件，或者说是提前结束的剪枝操作。能够执行到这里，说明在上面的for循环中，</span>
            <span class="token comment">//      选择1-9通过isValid判断都不合法，因为如果合法的话就会进去再次调用递归函数，然后继续递归。</span>
            <span class="token comment">//      而如果不合法的话，上面的for循环中if判断都不合法，即在这个空的上一个空选择的数是错的，导致</span>
            <span class="token comment">//      这次不管填什么数字都不满足数独要求了，所以才会出for循环运行到这里。那么此时就直接return</span>
            <span class="token comment">//      fasle，告诉上次的递归函数选择的数字是错误的。</span>
            <span class="token comment">// 其实这里也可以看出来，数独的唯一解就是每一次都选择正确的数字，所以每一次都满足isValid的条件</span>
            <span class="token comment">// 所以就不断递归，直到把所有的空都填满，也就是for(i)和for(j)都循环完毕，也就到了最下面的return</span>
            <span class="token comment">// true，再层层向上返回，得到唯一的解。</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 注意：这里没有return false。因为上面的for循环填每一行的空位，虽然上面说了唯一的解就是每一个空位</span>
        <span class="token comment">// 都满足isValid的条件，然后层层递归。但是也有可能这一行中没有空位，也就是都是走了continue的路线，</span>
        <span class="token comment">// 那么这一行就不会调用任何递归函数，所以for(i)正常执行遍历下一行，此时也是合法的。所以这里不能直接</span>
        <span class="token comment">// return fasle，也就是这里不需要做任何处理。</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 如果能够执行到这里，说明for(i)和for(j)都循环完毕了，也就是每一个空位都找到了合适的解，也就是</span>
    <span class="token comment">// 整个数独问题找到了唯一的答案。所以这里return true，然后true会层层返回给上一层的递归函数，</span>
    <span class="token comment">// 直到返回给最高层的递归函数</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">solveSudoku</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;&gt;</span> <span class="token operator">&amp;</span>board<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">backtracking</span><span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="322AC_298"></a>3.2.2.自己的写法，没有AC，待二刷看</h4> 
<p>下面是自己参考N皇后，想写的解法。但是这种方法会存在很多问题，要考虑到各个地方的细节，所以没有AC通过。所以感觉还是上面的解法更加通用，虽然说每次调用递归函数的时候，都又是从头开始遍历整个数独的每一个元素，但是方法更加简单，唯一争取的解就是每一次都满足<code>isValid</code>然后层层调用递归函数的那种选择。下面自己的写法就是想每次调用递归的函数的时候都只从上一次选择的数后面开始遍历数独，但是这样存在很多问题。<mark>二刷再看吧，今天已经花了很多时间了</mark>。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 自己写的错误解法，无法AC</span>
 <span class="token keyword">bool</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>row <span class="token operator">==</span> n<span class="token punctuation">)</span>
         <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

     <span class="token comment">// 遍历当前行的所有空位，每一个空位都需要填一个数</span>
     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> col<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
     <span class="token punctuation">{<!-- --></span>
         <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'.'</span><span class="token punctuation">)</span>
             <span class="token keyword">continue</span><span class="token punctuation">;</span>
         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> num <span class="token operator">=</span> <span class="token char">'1'</span><span class="token punctuation">;</span> num <span class="token operator">&lt;</span> <span class="token char">'9'</span><span class="token punctuation">;</span> num<span class="token operator">++</span><span class="token punctuation">)</span>
         <span class="token punctuation">{<!-- --></span>
             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> row<span class="token punctuation">,</span> j<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span>
             <span class="token punctuation">{<!-- --></span>
                 board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
                 <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> row<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> board<span class="token punctuation">)</span><span class="token punctuation">)</span>
                     <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                 board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'.'</span><span class="token punctuation">;</span>  <span class="token comment">// 回溯</span>
             <span class="token punctuation">}</span>
         <span class="token punctuation">}</span>

         <span class="token comment">// 执行到这里，说明上述是错的，即使止损</span>
         <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token comment">// 上面遍历完了这一行，然后从0开始继续遍历下一行</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">backtracking</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> board<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
     
     <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">solveSudoku</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;&gt;</span> <span class="token operator">&amp;</span>board<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
     <span class="token function">backtracking</span><span class="token punctuation">(</span>board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> board<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1859cbde9cb337a258aefa63b1a83eb8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python使用 pip 命令时提示“WARNING: Ignoring invalid distribution -ip”的解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92c0b4e7693b5adef36ea1c2ebe30955/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pandas的read_excel函数学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>