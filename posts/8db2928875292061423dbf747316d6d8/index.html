<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>跨链桥安全事件总结分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="跨链桥安全事件总结分析" />
<meta property="og:description" content="跨链桥事件总结分析 Poly Network 跨链桥事件 Relayer的不完整检验
源链上(Ontology)的relayer没有对上链的交易做语义校验，因此包含修改keeper恶意交易可以被打包到poly chain上
目标链上(以太坊)上的relayer虽然对交易做了校验，但是攻击者可以直接调用以太坊上的EthCrossChainManager合约最终调用EthCrossChainData合约完成签名修改
攻击者精心够着了能导致hash冲突的函数签名，从而调用putCurEpochConPubKeyBytes完成对签名的修改
见攻击步骤的具体分析
Poly Network事件分析
Polygon Plasma Bridge漏洞 外部验证&#43;乐观验证 该漏洞可以伪造铸币证明，导致双花攻击
完整的一次Withdraw交易过程如下：
用户在Polygon上发起Withdraw交易，该交易会burn掉用户在Polygon的代币；经过一个检查点间隔（大约30分钟），等待该withdraw交易被包含到检查点中；超过2/3的验证者签名后将其提交到以太坊，此时用户调用ERC20PredicateBurnOnly合约中的startExitWithBurntTokens()校验checkpoint是否包含burn交易；校验通过，则铸造一个NFT退款凭证发给用户用户等待7天挑战期调用WithdrawManager.processExits()销毁NFT，并退款给用户 Polygon为了防止交易重放（双花攻击），使用NFT作为退款凭证，来唯一标识一笔Withdraw交易。但是，由于NFT的ID生成缺陷，造成了攻击者可以构造参数利用同一笔有效的Withdraw交易，生成多个不同ID的NFT，再利用这些NFT进行退款交易，从而实现“双花攻击”。
addExitToQueue()会调用_addExitToQueue()铸造一个NFT,NFT的ID是由Plasma Bridge的age优先级生成WithdrawManager.verifyInclusion()函数对这样的withdraw交易进行校验，并生成对应的age交易的校验和age的生成过程，都依赖参数data解码出的branchMaskBytes交易的校验过程调用_getNibbleArray()对branceMaskBytes 进行了转码操作。
该函数将对应的HP编码，转成对应的Hex编码。
如果传入的HP编码后的值b的第一个十六进制位（半个字节）是1或3，就解析第二个十六进制位。否则，就直接忽略第一个字节。那么如果攻击者构造一个branchMaskBytes参数，使得其第一个十六进制位不等于1和3，则共有14*16 = 224种方式，能够获得相同的转码后的值 Hex转HP [6,3,6,1,7,4,10] Hex编码 [20,63,61,74] HP编码 HP转Hex [15,23,45,32,62] HP编码 [5,2,3,4,5,3,2,6,2]Hex编码 [20，45，76，34]HP编码 [23，...]HP编码 [4，5，7，6，3，4，10]Hex编码 Polygon事件分析CN
Polygon事件分析Eng
Meter.io 跨链桥事件 绕过源链上代币的锁定过程，却获得了代币的锁定证明，进而在目标链铸造资产
deposit()用于ERC20代币的存款，depositETH()用于WETH/WBNB代币的存款。Bridge合约提供了两种方法：deposit()和depositETH()用于上述两种代币的存款，但是deposit()并没有阻止WETH/WBNB的存款交易，并且存在有着缺陷的逻辑判断。 当tokenAddress不为_wtokenAddress地址时进行 ERC20 代币的销毁或锁定，若为_wtokenAddress则直接跳过该部分处理.
跨链桥合约中的depositETH函数会将链平台币转为wToken后转至depositHandler地址，所以在depositHandler执行deposit逻辑时，已处理过代币转移，故跳过代币处理逻辑
但跨链桥合约的deposit函数中并没有处理代币转移及校验，在转由deposiHandler执行deposit时，若data数据构造成满足tokenAddress == _wtokenAddress即可绕过处理
慢雾Meter.io跨链桥分析
Meter.io跨链桥分析
Wormhole Bridge跨链桥事件 利用虚假的签名，在目标链Solana链上mint了12万个WETH。
Wormhole中引入了Validator角色–即guardians
Wormhole中没有leader角色，所有的guardians都对其监听到的on-chain event执行相同的计算，同时对Validator Action Approval (VAA)签名。若有⅔&#43;的大多数guardian节点使用各自私钥对同一event签名，则在所有链上的Wormhole合约都将自动认为其是有效的，并触发相应的mint/burn操作。 攻击者在Ethereum上向Solana转入0.1ETH在Solana上铸造Wormhole ETH的交易触发了Wormhole函数complete_wrapped函数的参数之一是transfer message ,guardians 签名的消息，说明铸造的代币和数量transfer message 是通过触发post_vaa函数创建的，检查guardians的签名来检查消息是否有效实际上post_vaa并不检查签名，典型的Solana方式，智能合约通过调用verify_signatures函数创建verify_signatures 函数的输入之一是Solana内置的system程序，在verify_signatures中调用Secp256k1签名验证函数Wormhole合约使用函数load_instruction_at来检查Secp256k1函数是否被首先调用load_instruction_at 函数最近被弃用了，因为它不检查它是否针对实际系统地址执行攻击者创建自己的账户地址，存储与Instrcutions sysvar相同的数据。使用这个伪造的system程序，攻击者可以有效地谎报签名检查程序已被执行，但根本没有检查签名 Wormhole Bridge跨链桥事件" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8db2928875292061423dbf747316d6d8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-15T20:03:47+08:00" />
<meta property="article:modified_time" content="2023-01-15T20:03:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">跨链桥安全事件总结分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>跨链桥事件总结分析</h2> 
<h3><a id="Poly_Network__1"></a>Poly Network 跨链桥事件</h3> 
<p>Relayer的不完整检验</p> 
<ul><li> <p>源链上(Ontology)的relayer没有对上链的交易做语义校验，因此包含修改keeper恶意交易可以被打包到poly chain上</p> </li><li> <p>目标链上(以太坊)上的relayer虽然对交易做了校验，但是攻击者可以直接调用以太坊上的EthCrossChainManager合约最终调用EthCrossChainData合约完成签名修改</p> </li><li> <p>攻击者精心够着了能导致hash冲突的函数签名，从而调用<code>putCurEpochConPubKeyBytes</code>完成对签名的修改</p> </li></ul> 
<p>见攻击步骤的具体分析</p> 
<p><a href="https://zhuanlan.zhihu.com/p/398941126" rel="nofollow">Poly Network事件分析</a></p> 
<h3><a id="Polygon_Plasma_Bridge_15"></a>Polygon Plasma Bridge漏洞</h3> 
<p>外部验证+乐观验证 该漏洞可以伪造铸币证明，导致双花攻击</p> 
<p>完整的一次Withdraw交易过程如下：</p> 
<ul><li>用户在Polygon上发起Withdraw交易，该交易会burn掉用户在Polygon的代币；</li><li>经过一个检查点间隔（大约30分钟），等待该withdraw交易被包含到检查点中；</li><li>超过2/3的验证者签名后将其提交到以太坊，此时用户调用ERC20PredicateBurnOnly合约中的startExitWithBurntTokens()校验checkpoint是否包含burn交易；</li><li>校验通过，则铸造一个NFT退款凭证发给用户</li><li>用户等待7天挑战期</li><li>调用WithdrawManager.processExits()销毁NFT，并退款给用户</li></ul> 
<p>Polygon为了防止交易重放（双花攻击），使用NFT作为退款凭证，来唯一标识一笔Withdraw交易。但是，由于NFT的ID生成缺陷，造成了攻击者可以构造参数利用同一笔有效的Withdraw交易，生成多个不同ID的NFT，再利用这些NFT进行退款交易，从而实现“双花攻击”。</p> 
<ol><li>addExitToQueue()会调用_addExitToQueue()铸造一个NFT,NFT的ID是由Plasma Bridge的age优先级生成</li><li>WithdrawManager.verifyInclusion()函数对这样的withdraw交易进行校验，并生成对应的age</li><li>交易的校验和age的生成过程，都依赖参数data解码出的<strong>branchMaskBytes</strong></li><li>交易的校验过程调用_getNibbleArray()对<strong>branceMaskBytes</strong> 进行了转码操作。<br> <img src="https://images2.imgbox.com/e3/33/w9n0sEoM_o.png" alt="在这里插入图片描述"></li></ol> 
<p>该函数将对应的HP编码，转成对应的Hex编码。</p> 
<ol start="5"><li>如果传入的HP编码后的值b的第一个十六进制位（半个字节）是1或3，就解析第二个十六进制位。否则，就直接忽略第一个字节。</li><li>那么如果攻击者构造一个branchMaskBytes参数，使得其第一个十六进制位不等于1和3，则共有14*16 = 224种方式，能够获得相同的转码后的值</li></ol> 
<pre><code>Hex转HP
[6,3,6,1,7,4,10]   Hex编码
[20,63,61,74]  HP编码
HP转Hex
[15,23,45,32,62]  HP编码
[5,2,3,4,5,3,2,6,2]Hex编码
[20，45，76，34]HP编码   [23，...]HP编码
[4，5，7，6，3，4，10]Hex编码
</code></pre> 
<p><a href="https://zhuanlan.zhihu.com/p/565059008" rel="nofollow">Polygon事件分析CN</a></p> 
<p><a href="https://medium.com/immunefi/polygon-double-spend-bug-fix-postmortem-2m-bounty-5a1db09db7f1" rel="nofollow">Polygon事件分析Eng</a></p> 
<h3><a id="Meterio__56"></a>Meter.io 跨链桥事件</h3> 
<p>绕过源链上代币的锁定过程，却获得了代币的锁定证明，进而在目标链铸造资产</p> 
<ul><li>deposit()用于ERC20代币的存款，depositETH()用于WETH/WBNB代币的存款。</li><li>Bridge合约提供了两种方法：deposit()和depositETH()用于上述两种代币的存款，但是deposit()并没有阻止WETH/WBNB的存款交易，并且存在有着缺陷的逻辑判断。</li></ul> 
<p><img src="https://images2.imgbox.com/9f/df/f6CQqLs6_o.png" alt="在这里插入图片描述"></p> 
<p>当<code>tokenAddress</code>不为<code>_wtokenAddress</code>地址时进行 ERC20 代币的销毁或锁定，若为<code>_wtokenAddress</code>则直接跳过该部分处理.</p> 
<p>跨链桥合约中的<code>depositETH</code>函数会将链平台币转为<code>wToken</code>后转至<code>depositHandler</code>地址，所以在<code>depositHandler</code>执行<code>deposit</code>逻辑时，已处理过代币转移，故跳过代币处理逻辑</p> 
<p>但跨链桥合约的<code>deposit</code>函数中并没有处理代币转移及校验，在转由<code>deposiHandler</code>执行<code>deposit</code>时，若<code>data</code>数据构造成满足<code>tokenAddress == _wtokenAddress</code>即可绕过处理</p> 
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU5OTg4MTIxMw==&amp;mid=2247493859&amp;idx=1&amp;sn=49e5634b17d3025326c3ddbc8358d41a&amp;chksm=feac8c71c9db056700954938f2bf41511498faf9b94f169c9512ca22fea9155b019d3c4531b4&amp;scene=21#wechat_redirect" rel="nofollow">慢雾Meter.io跨链桥分析</a></p> 
<p><a href="https://blog.csdn.net/SierraW/article/details/122857171">Meter.io跨链桥分析</a></p> 
<h3><a id="Wormhole_Bridge_76"></a>Wormhole Bridge跨链桥事件</h3> 
<p>利用虚假的签名，在目标链Solana链上mint了12万个WETH。</p> 
<p>Wormhole中引入了Validator角色–即<code>guardians</code></p> 
<ul><li>Wormhole中没有leader角色，所有的guardians都对其监听到的<code>on-chain event</code>执行相同的计算，同时对<code>Validator Action Approval </code>(VAA)签名。</li><li>若有⅔+的大多数guardian节点使用各自私钥对同一event签名，则在所有链上的Wormhole合约都将自动认为其是有效的，并触发相应的mint/burn操作。</li></ul> 
<ol><li>攻击者在Ethereum上向Solana转入0.1ETH</li><li>在Solana上铸造Wormhole ETH的交易触发了Wormhole函数complete_wrapped</li><li>函数的参数之一是<code>transfer message</code> ,<code>guardians</code> 签名的消息，说明铸造的代币和数量</li><li><code>transfer message</code> 是通过触发<code>post_vaa</code>函数创建的，检查<code>guardians</code>的签名来检查消息是否有效</li><li>实际上<code>post_vaa</code>并不检查签名，典型的Solana方式，智能合约通过调用<code>verify_signatures</code>函数创建</li><li><code>verify_signatures</code> 函数的输入之一是Solana内置的<code>system</code>程序，</li><li>在<code>verify_signatures</code>中调用<code>Secp256k1</code>签名验证函数</li><li>Wormhole合约使用函数<code>load_instruction_at</code>来检查<code>Secp256k1</code>函数是否被首先调用</li><li><code>load_instruction_at </code>函数最近被弃用了，因为它不检查它是否针对实际系统地址执行</li><li>攻击者创建自己的账户地址，存储与<code>Instrcutions sysvar</code>相同的数据。</li><li>使用这个伪造的<code>system</code>程序，攻击者可以有效地谎报签名检查程序已被执行，但根本没有检查签名</li></ol> 
<p><a href="https://twitter.com/kelvinfichter/status/1489041221947375616" rel="nofollow">Wormhole Bridge跨链桥事件</a></p> 
<h3><a id="pNetwork_99"></a>pNetwork跨链协议事件</h3> 
<p>绕过锁定的过程，攻击者合约发出对应的<strong>lock event</strong> .错误地提取，处理了恶意的日志事件。</p> 
<ul><li>攻击者部署了一组专门设计的智能合约，来滥用pNetwork节点寻找的peg-out日志事件。</li><li>创建一系列的事件日志，包含合法的peg-out请求，和攻击者合约发出了非法peg-out请求。</li><li>负责提取这些日志事件的Rust代码存在错误，提取并错误地处理了合法和错误的日志。</li></ul> 
<p><a href="https://medium.com/pnetwork/pnetwork-post-mortem-pbtc-on-bsc-exploit-170890c58d5f" rel="nofollow">pNetwork官方报告</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/18eb20449ac762535c532a6554566079/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用ASM框架创建ClassVisitor时遇到IllegalArgumentException的一种可能解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76d5435f840833c3b124867783599611/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java学习（95）Java泛型——泛型作为方法参数和方法重载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>