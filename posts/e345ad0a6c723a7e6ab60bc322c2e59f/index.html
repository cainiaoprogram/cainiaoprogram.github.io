<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java 接口 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java 接口" />
<meta property="og:description" content="2.1.2 什么是接口
接口在JAVA编程语言中是一个抽象类型，通常以interface来声明。
从面向对象编程的角度，可以将接口理解为对不同类型的事物的共同的行为特征的抽象。例如，鹰和飞机属于不同类型的事物，但是都有飞行的行为特征。
2.1.3 接口和抽象类
抽象类和接口都属于抽象的概念，它们有一些区别，可以从同类别和跨类别的角度来考虑：
同一种类别的公共行为和属性可以抽取到抽象类中。抽象类用于表示一种具有共性的类，可以包含实现的方法和具体的属性。比如，对于喜鹊和老鹰这两种鸟类，它们都属于鸟类的范畴，可以将它们共同的行为和属性抽象到一个抽象类（如Bird）中，以实现代码的重用和扩展。不同种类的公共行为可以抽取到接口中。接口用于定义一组相关的方法，用于表示某种能力或行为。比如，喜鹊、老鹰和飞机都具有起飞和着陆的功能，但它们并不属于同一种类，此时可以将与飞行相关的共同行为抽取到一个接口（如Flyable）中，不同类别的对象可以通过实现该接口来具备飞行的能力。 根据以上原则，对于喜鹊来说，它可以继承自抽象类Bird，以获取鸟类的共性属性和行为，并且还可以实现接口Flyable，以具备飞行的能力。
抽象类和接口的设计原则：
将所有子类共有的方法抽象化到父类中，可以使用抽象类。将部分子类中的公共方法抽象化到接口中，适用于不同类别但具有相似行为的对象。 通过合理地使用抽象类和接口，可以实现代码的复用和扩展，并且更好地表示对象之间的关系和行为。选择使用抽象类还是接口取决于具体的设计需求和对象之间的关系。
2.2.1 接口的语法
使用interface定义接口：
1、接口中只能定义常量和方法
可以省略常量的修饰词 public static final可以省略抽象方法修饰词 public abstract 2、接口不能实例化创建对象,
3、接口只能被继承，作为父类型被子类型实现
比如，定义飞行接口：
包含常量ID包含 3 个抽象方法 一个类可以实现多个接口：实现的接口直接用逗号分隔。
定义接口 Flyable 和类 Bird，并类 Plane实现接口Flyable，以及类 Eagle 继承Bird并实现Flyable；编写代码测试接口的用法。
案例示意代码如下所示：
package oop_04.interface01;/*** 飞行接口*/public interface Flyable {int ID = 1;/*** 起飞*/void takeOff();/*** 飞行*/void fly();/*** 着陆*/void land();}package oop_04.interface01;public class Plane implements Flyable{@Overridepublic void takeOff() {System.out.println(&#34;Plane takeOff...&#34;);}@Overridepublic void fly() {System.out.println(&#34;Plane fly...&#34;);}@Overridepublic void land() {System.out.println(&#34;Plane land...&#34;);}}package oop_04." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e345ad0a6c723a7e6ab60bc322c2e59f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-28T09:26:46+08:00" />
<meta property="article:modified_time" content="2023-07-28T09:26:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java 接口</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>2.1.2 什么是接口</p> 
<p>接口在JAVA编程语言中是一个抽象类型，通常以interface来声明。</p> 
<p>从面向对象编程的角度，可以将接口理解为对不同类型的事物的共同的行为特征的抽象。例如，鹰和飞机属于不同类型的事物，但是都有飞行的行为特征。</p> 
<p>2.1.3 接口和抽象类</p> 
<p>抽象类和接口都属于抽象的概念，它们有一些区别，可以从同类别和跨类别的角度来考虑：</p> 
<ul><li>同一种类别的公共行为和属性可以抽取到抽象类中。抽象类用于表示一种具有共性的类，可以包含实现的方法和具体的属性。比如，对于喜鹊和老鹰这两种鸟类，它们都属于鸟类的范畴，可以将它们共同的行为和属性抽象到一个抽象类（如Bird）中，以实现代码的重用和扩展。</li><li>不同种类的公共行为可以抽取到接口中。接口用于定义一组相关的方法，用于表示某种能力或行为。比如，喜鹊、老鹰和飞机都具有起飞和着陆的功能，但它们并不属于同一种类，此时可以将与飞行相关的共同行为抽取到一个接口（如Flyable）中，不同类别的对象可以通过实现该接口来具备飞行的能力。</li></ul> 
<p>根据以上原则，对于喜鹊来说，它可以继承自抽象类Bird，以获取鸟类的共性属性和行为，并且还可以实现接口Flyable，以具备飞行的能力。</p> 
<p>抽象类和接口的设计原则：</p> 
<ul><li>将所有子类共有的方法抽象化到父类中，可以使用抽象类。</li><li>将部分子类中的公共方法抽象化到接口中，适用于不同类别但具有相似行为的对象。</li></ul> 
<p>通过合理地使用抽象类和接口，可以实现代码的复用和扩展，并且更好地表示对象之间的关系和行为。选择使用抽象类还是接口取决于具体的设计需求和对象之间的关系。</p> 
<p>2.2.1 接口的语法</p> 
<p>使用interface定义接口：</p> 
<p>1、接口中只能定义常量和方法</p> 
<ul><li>可以省略常量的修饰词 public static final</li><li>可以省略抽象方法修饰词 public abstract</li></ul> 
<p>2、接口不能实例化创建对象,</p> 
<p>3、接口只能被继承，作为父类型被子类型实现</p> 
<p>比如，定义飞行接口：</p> 
<ul><li>包含常量ID</li><li>包含 3 个抽象方法</li></ul> 
<p>一个类可以实现多个接口：实现的接口直接用逗号分隔。</p> 
<p>定义接口 Flyable 和类 Bird，并类 Plane实现接口Flyable，以及类 Eagle 继承Bird并实现Flyable；编写代码测试接口的用法。</p> 
<p>案例示意代码如下所示：</p> 
<pre></pre> 
<ol><li>package oop_04.interface01;</li><li>/**</li><li>* 飞行接口</li><li>*/</li><li>public interface Flyable {<!-- --></li><li>int ID = 1;</li><li>/**</li><li>* 起飞</li><li>*/</li><li>void takeOff();</li><li>/**</li><li>* 飞行</li><li>*/</li><li>void fly();</li><li>/**</li><li>* 着陆</li><li>*/</li><li>void land();</li><li>}</li><li><li>package oop_04.interface01;</li><li>public class Plane implements Flyable{<!-- --></li><li>@Override</li><li>public void takeOff() {<!-- --></li><li>System.out.println("Plane takeOff...");</li><li>}</li><li><li>@Override</li><li>public void fly() {<!-- --></li><li>System.out.println("Plane fly...");</li><li>}</li><li><li>@Override</li><li>public void land() {<!-- --></li><li>System.out.println("Plane land...");</li><li>}</li><li>}</li><li><li>package oop_04.interface01;</li><li>public class Bird {<!-- --></li><li>public void eat(){<!-- --></li><li>System.out.println("eat...");</li><li>}</li><li>public void sleep(){<!-- --></li><li>System.out.println("sleep...");</li><li>}</li><li>}</li><li><li>package oop_04.interface01;</li><li>public class Eagle</li><li>extends Bird implements Flyable{<!-- --></li><li><li>@Override</li><li>public void takeOff() {<!-- --></li><li>System.out.println("Eagle takeOff...");</li><li>}</li><li><li>@Override</li><li>public void fly() {<!-- --></li><li>System.out.println("Eagle fly...");</li><li>}</li><li><li>@Override</li><li>public void land() {<!-- --></li><li>System.out.println("Eagle land...");</li><li>}</li><li>}</li><li><li>package oop_04.interface01;</li><li>public class InterfaceDemo1 {<!-- --></li><li>public static void main(String[] args) {<!-- --></li><li>// Flyable flyable=new Flyable(); // 接口不可被实例化</li><li>System.out.println(Flyable.ID); // 接口中定义的是静态常量</li><li>Flyable eagle = new Eagle(); // 接口类型引用指向实现类的对象</li><li>eagle.fly(); // 实际执行实现类重写的方法逻辑</li><li>Flyable plane = new Plane(); // 接口类型引用指向实现类的对象</li><li>plane.fly(); // 实际执行实现类重写的方法逻辑</li><li><li>// eagle.eat(); // 无法访问实现类特有的方法</li><li>}</li><li>}</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d85d008779401eb49429dfea488c242c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL数据库笔记——进阶篇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cbac62e7c8644bb590a1703435c1fd99/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 接口的继承</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>