<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>POJ1321 棋盘问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="POJ1321 棋盘问题" />
<meta property="og:description" content="Time limit1000 msMemory limit10000 kB Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。
Input 输入含有多组测试数据。
每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n
当为-1 -1时表示输入结束。
随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。
Output
对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。
Sample Input
2 1 #. .# 4 4 ...# ..#. .#.. #... -1 -1 Sample Output
2 1 题目分析 首先看到这个题的时候我想到的是，从第一个可以放棋子的点开始先放一个棋子，然后去找可以放下一个棋子的地方（为了方便我们称为第二个棋子），相对于第二个棋子我需要去找这个棋子的下个棋子，也就是第三个棋子可以放的位置。那么对于第一个棋子，第一个棋子的下一个棋子有很多种方法，而对于第二个棋子的下个棋子也有很多的方法。
所以我想的是，选取第一个棋子的位置的不同，可能会造成不同的摆放方法，为了防止重复，假设我们现在第一个棋子的位置放在第一个可以放置的位置，那么我们就将所有包含这个点的可行方法全部找出来，然后这个点我们就不再使用它了，那么我们在后面的方法中就不能再用这个点了，所以我们就将第一个点的位置换到下一个点去，再将这个点的所有可行方法全部找出来。
对于第一个点是这样的，那么对于第二个点也是一样的，就像汉诺塔一样，对于第i的棋子，其任务是，先为自己找一个可以放置的位置，然后在将剩下的 k - i 个棋子让第i&#43;1个棋子去实现，这样的话对最后一个棋子的话就只需要找到一个放置自己的点就好了。
以上就讲下思路，具体看代码
代码区 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; void dfs(int tx, int r); char map[10][10],tag[10]; int n, k; int sum; int main() { while(~scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/be527e8521e4693de417231029b84669/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-14T18:59:31+08:00" />
<meta property="article:modified_time" content="2019-01-14T18:59:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">POJ1321 棋盘问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>Time limit</td><td>1000 ms</td></tr><tr><td>Memory limit</td><td>10000 kB</td></tr></tbody></table> 
<h3>Description</h3> 
<p>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。</p> 
<h3><strong>Input</strong></h3> 
<p>输入含有多组测试数据。<br> 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br> 当为-1 -1时表示输入结束。<br> 随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。</p> 
<p>Output</p> 
<p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。</p> 
<p>Sample Input</p> 
<pre>2 1
#.
.#
4 4
...#
..#.
.#..
#...
-1 -1
</pre> 
<p>Sample Output</p> 
<pre>2
1</pre> 
<h3>题目分析</h3> 
<p style="text-indent:50px;">首先看到这个题的时候我想到的是，从第一个可以放棋子的点开始先放一个棋子，然后去找可以放下一个棋子的地方（为了方便我们称为第二个棋子），相对于第二个棋子我需要去找这个棋子的下个棋子，也就是第三个棋子可以放的位置。那么对于第一个棋子，第一个棋子的下一个棋子有很多种方法，而对于第二个棋子的下个棋子也有很多的方法。</p> 
<p style="text-indent:50px;">所以我想的是，选取第一个棋子的位置的不同，可能会造成不同的摆放方法，为了防止重复，假设我们现在第一个棋子的位置放在第一个可以放置的位置，那么我们就将所有包含这个点的可行方法全部找出来，然后这个点我们就不再使用它了，那么我们在后面的方法中就不能再用这个点了，所以我们就将第一个点的位置换到下一个点去，再将这个点的所有可行方法全部找出来。</p> 
<p style="text-indent:50px;">对于第一个点是这样的，那么对于第二个点也是一样的，就像汉诺塔一样，对于第i的棋子，其任务是，先为自己找一个可以放置的位置，然后在将剩下的 k - i 个棋子让第i+1个棋子去实现，这样的话对最后一个棋子的话就只需要找到一个放置自己的点就好了。</p> 
<p style="text-indent:50px;">以上就讲下思路，具体看代码</p> 
<h3 style="text-indent:0px;">代码区</h3> 
<pre class="has"><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

void dfs(int tx, int r);

char map[10][10],tag[10];
int n, k;
int sum;

int main()
{
	
	while(~scanf("%d%d",&amp;n,&amp;k)&amp;&amp;n != -1 &amp;&amp; k != -1)
	{
		for(int i = 1 ; i &lt;= n ; i++)
		{
			for(int j = 1 ; j &lt;= n ; j++)
			{
				cin &gt;&gt; map[i][j];
			}
		}

		memset(tag, 0, sizeof(tag));			//初始化标记
		sum = 0;
		
		for(int i = 1 ; i &lt;=  n - k + 1; i ++)	//若剩余行数小于棋子数，说明不可能再有方法了
		{
			dfs(i, 1);							//表示从第i行开始放棋子
		}
		cout &lt;&lt; sum &lt;&lt; endl;
	}
	return 0;
}

//第一个参数表示目前处于的行数，now 表示已经放了多少个棋子需要放置
void dfs(int x , int now)	//查找的位置
{
	
	for(int i = 1 ; i &lt;= n ; i++)				//按列查找一个可以放棋子的位置，也就是这一行所有可以放
	{
		if(map[x][i] == '#' &amp;&amp; tag[i] == 0)		//代表这个点可以放，在这一列没有其他棋子的情况下
		{
			if(now == k)						//表示棋子已经放置完全，也就是找到了一种放置法
			{
				sum++;							//总数加一
				continue;						//继续查找这一行是否还有其他的点可以满足条件
			}
			tag[i] = 1;							//标记这一列已经有棋子了
			//k - now ，表示还需要放的棋子数，n-j+1 表示剩余行数，则需要剩下的棋子数小于剩余的行数才可以实现
			for(int j = x + 1 ;n-j + 1 &gt;= k - now ; j++)
			{
				dfs(j, now + 1);				//查找后面的行
			}
			tag[i] = 0;							//将这一列重新变成可走的，查找当前行其他的点是否可走,因为不能影响第now个棋子的下一个放置位置
		}
	}
}</code></pre> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/250be31daffd5fd1a6d5eef3035934ce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习mAP</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d25f36285ead077bb1a49dece5609880/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序——switchTab和navigateTo理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>