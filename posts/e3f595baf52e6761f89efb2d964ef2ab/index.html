<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>BART论文解读：BERT和GPT结合起来会发生什么？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="BART论文解读：BERT和GPT结合起来会发生什么？" />
<meta property="og:description" content="BART:Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension 主要工作 提出了BART (Bidirectional and Auto-Regressive Transformers)， 是一种用于自然语言生成、翻译和理解的序列到序列的预训练方法。它通过先用任意噪声函数损坏文本，然后学习一个模型来重构原始文本来进行训练。BART使用标准的基于Transformer的神经机器翻译架构，结合了BERT的双向编码器和GPT的从左到右解码器的特点。
研究发现，BART在文本生成任务中表现尤为出色，同时也适用于理解任务。它在GLUE和SQuAD任务中与RoBERTa表现相当，并在一系列抽象的对话、问答和摘要任务中取得了新的最先进结果，显示出高达6 ROUGE的增益。此外，BART还在机器翻译任务中表现出色，比只使用目标语言进行预训练的反向翻译系统提高了1.1 BLEU分。
图 1：BART 与 BERT和的示意性比较。
模型 BART 是一个去噪自编码器，它将受损的文档映射回其来源的原始文档。这个模型以序列到序列的形式实现，具有对受损文本的双向编码器和一个从左到右的自回归解码器。在预训练阶段，我们优化原始文档的负对数似然。
架构 BART 使用了标准的序列到序列变换器（Transformer）架构，但是有所改动。继承自GPT的一个修改是，它将ReLU激活函数替换为GeLUs（Hendrycks &amp; Gimpel, 2016），并且将参数初始化为N(0, 0.02)。在我们的基础模型中，编码器和解码器各使用了6层，而在我们的大型模型中，每个部分各使用了12层。这种架构与BERT使用的架构密切相关，但存在以下差异：（1）解码器的每一层还会对编码器的最后一个隐藏层进行交叉关注（如在Tansformer sequence-to-sequence模型中所做的那样）；以及（2）BERT在单词预测前使用了一个额外的前馈网络，而BART没有使用。总体而言，BART比同等大小的BERT模型包含大约多10%的参数。
预训练 BART 通过破坏文档然后优化重建损失来进行训练，重建损失是解码器输出和原始文档之间的交叉熵。不同于现有的针对特定噪声方案定制的去噪自编码器，BART 允许我们应用任何类型的文档破坏方式。在极端情况下，即源信息完全丢失时，BART 相当于一个语言模型。
我们试验了几种先前提出的和新颖的转换方法，但我们认为开发其他新的替代方案仍有重大潜力。我们使用的转换方法在下面进行了总结，示例显示在图2中。
图 2：我们实验的输入噪声的转换。这些变换可以组合起来。
Token Masking（令牌遮蔽）
遵循BERT（Devlin等人，2019年）的方法，随机采样令牌并将其替换为[MASK]元素。
Token Deletion（令牌删除）
从输入中随机删除令牌。与令牌遮蔽不同，模型必须决定哪些位置缺少输入。
Text Infilling（文本填充）
采样一定数量的文本跨度（span），这些跨度的长度根据泊松分布（λ=3）确定。每个跨度被单个[MASK]令牌替换。0长度的跨度对应于插入[MASK]令牌。文本填充的灵感来自SpanBERT（Joshi等人，2019年），但SpanBERT采样不同的分布来确定跨度长度，并用长度完全相同的一系列[MASK]令牌替换每个跨度。文本填充教会模型预测每个跨度中缺少多少个令牌。
Sentence Permutation（句子置换）
将文档分割为基于句号的句子，并将这些句子随机打乱顺序。
Document Rotation（文档旋转）
均匀随机选择一个令牌，并旋转文档，使其从该令牌开始。这项任务训练模型识别文档的开始部分。
微调 BART 生成的表示可以通过多种方式用于下游应用程序。
图 3：微调 BART 以进行分类和翻译。
序列分类任务
对于序列分类任务，相同的输入被送入编码器和解码器，最后一个解码器令牌的最终隐藏状态被送入一个新的多类别分类器。这种方法与BERT中的CLS令牌有关，但我们在末尾增加了一个额外的令牌，使得解码器可以关注完整输入的解码器状态（见图3a）。
Tokens分类任务
对于令牌分类任务，例如SQuAD的答案端点分类，我们将完整的文档送入编码器和解码器，并使用解码器顶层的隐藏状态作为每个词的表征。这个表征被用来对令牌进行分类。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e3f595baf52e6761f89efb2d964ef2ab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T10:45:08+08:00" />
<meta property="article:modified_time" content="2024-01-06T10:45:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">BART论文解读：BERT和GPT结合起来会发生什么？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="BARTDenoising_SequencetoSequence_Pretraining_for_Natural_Language_Generation_Translation_and_Comprehension_0"></a>BART:Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension</h2> 
<h2><a id="_2"></a>主要工作</h2> 
<ul><li> <p>提出了BART (Bidirectional and Auto-Regressive Transformers)， 是一种用于自然语言生成、翻译和理解的序列到序列的预训练方法。它通过先用任意噪声函数损坏文本，然后学习一个模型来重构原始文本来进行训练。BART使用标准的基于Transformer的神经机器翻译架构，结合了BERT的双向编码器和GPT的从左到右解码器的特点。</p> </li><li> <p>研究发现，BART在文本生成任务中表现尤为出色，同时也适用于理解任务。它在GLUE和SQuAD任务中与RoBERTa表现相当，并在一系列抽象的对话、问答和摘要任务中取得了新的最先进结果，显示出高达6 ROUGE的增益。此外，BART还在机器翻译任务中表现出色，比只使用目标语言进行预训练的反向翻译系统提高了1.1 BLEU分。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/d9/d0/HvRhWP7e_o.png" alt="image.png"><br> 图 1：BART 与 BERT和的示意性比较。</p> 
<h2><a id="_11"></a>模型</h2> 
<p>BART 是一个去噪自编码器，它将受损的文档映射回其来源的原始文档。这个模型以序列到序列的形式实现，具有对受损文本的双向编码器和一个从左到右的自回归解码器。在预训练阶段，我们优化原始文档的负对数似然。</p> 
<h3><a id="_15"></a>架构</h3> 
<p>BART 使用了标准的序列到序列变换器（Transformer）架构，但是有所改动。继承自GPT的一个修改是，它将ReLU激活函数替换为GeLUs（Hendrycks &amp; Gimpel, 2016），并且将参数初始化为N(0, 0.02)。在我们的基础模型中，编码器和解码器各使用了6层，而在我们的大型模型中，每个部分各使用了12层。这种架构与BERT使用的架构密切相关，但存在以下差异：（1）解码器的每一层还会对编码器的最后一个隐藏层进行交叉关注（如在Tansformer sequence-to-sequence模型中所做的那样）；以及（2）BERT在单词预测前使用了一个额外的前馈网络，而BART没有使用。总体而言，BART比同等大小的BERT模型包含大约多10%的参数。</p> 
<h3><a id="_19"></a>预训练</h3> 
<p>BART 通过破坏文档然后优化重建损失来进行训练，<strong>重建损失是解码器输出和原始文档之间的交叉熵</strong>。不同于现有的针对特定噪声方案定制的去噪自编码器，BART 允许我们应用任何类型的文档破坏方式。在极端情况下，即源信息完全丢失时，BART 相当于一个语言模型。</p> 
<p>我们试验了几种先前提出的和新颖的转换方法，但我们认为开发其他新的替代方案仍有重大潜力。我们使用的转换方法在下面进行了总结，示例显示在图2中。</p> 
<p><img src="https://images2.imgbox.com/2b/75/mDK5zxQf_o.png" alt="image.png"><br> 图 2：我们实验的输入噪声的转换。这些变换可以组合起来。</p> 
<p><strong>Token Masking（令牌遮蔽）</strong><br> 遵循BERT（Devlin等人，2019年）的方法，随机采样令牌并将其替换为[MASK]元素。</p> 
<p><strong>Token Deletion（令牌删除）</strong><br> 从输入中随机删除令牌。与令牌遮蔽不同，<strong>模型必须决定哪些位置缺少输入。</strong></p> 
<p><strong>Text Infilling（文本填充）</strong><br> 采样一定数量的文本跨度（span），这些跨度的长度根据泊松分布（λ=3）确定。每个跨度被单个[MASK]令牌替换。0长度的跨度对应于插入[MASK]令牌。文本填充的灵感来自SpanBERT（Joshi等人，2019年），但SpanBERT采样不同的分布来确定跨度长度，并用长度完全相同的一系列[MASK]令牌替换每个跨度。<strong>文本填充教会模型预测每个跨度中缺少多少个令牌。</strong></p> 
<p><strong>Sentence Permutation（句子置换）</strong><br> 将文档分割为基于句号的句子，并将这些句子随机打乱顺序。</p> 
<p><strong>Document Rotation（文档旋转）</strong><br> 均匀随机选择一个令牌，并旋转文档，使其从该令牌开始。<strong>这项任务训练模型识别文档的开始部分。</strong></p> 
<h3><a id="_43"></a>微调</h3> 
<p>BART 生成的表示可以通过多种方式用于下游应用程序。</p> 
<p><img src="https://images2.imgbox.com/14/36/fITQ8Rz4_o.png" alt="image.png"><br> 图 3：微调 BART 以进行分类和翻译。</p> 
<p><strong>序列分类任务</strong><br> 对于序列分类任务，相同的输入被送入编码器和解码器，最后一个解码器令牌的最终隐藏状态被送入一个新的多类别分类器。这种方法与BERT中的CLS令牌有关，但我们在末尾增加了一个额外的令牌，使得解码器可以关注完整输入的解码器状态（见图3a）。</p> 
<p><strong>Tokens分类任务</strong><br> 对于令牌分类任务，例如SQuAD的答案端点分类，我们将完整的文档送入编码器和解码器，并使用解码器顶层的隐藏状态作为每个词的表征。这个表征被用来对令牌进行分类。</p> 
<p><strong>序列生成任务</strong><br> 由于BART拥有一个自回归解码器，它可以直接进行微调以用于序列生成任务，如抽象的问答和总结。在这些任务中，信息是从输入中复制的，但进行了操纵，这与去噪预训练目标密切相关。在这里，编码器的输入是输入序列，解码器自回归地生成输出。</p> 
<p><strong>机器翻译</strong><br> 我们还探索使用BART来改进机器翻译解码器以翻译成英语。以前的工作Eduonov等人（2019年）表明，通过加入预训练的编码器可以改进模型，但从使用预训练的语言模型中的解码器中获得的收益有限。我们展示了使用整个BART模型（编码器和解码器）作为机器翻译的单一预训练解码器是可能的，通过添加一组从双语文本中学习到的新编码器参数（见图3b）。<br> 更准确地说，我们用一个新的随机初始化的编码器替换了BART的编码器嵌入层。模型进行端到端训练，这训练了新的编码器将外语词映射为BART可以将其去噪为英语的输入。新的编码器可以使用与原始BART模型不同的词汇表。<br> 我们分两步训练源编码器，在两种情况下都将交叉熵损失从BART模型的输出中反向传播。在第一步，我们冻结了大部分BART参数，只更新随机初始化的源编码器，BART的位置嵌入，以及自注意力输入投影矩阵的BART编码器的第一层。在第二步，我们为少量迭代训练所有模型参数。</p> 
<h2><a id="_64"></a>比较预训练目标</h2> 
<h3><a id="_66"></a>比较目标</h3> 
<p>尽管提出了许多预训练目标，但由于训练数据、训练资源、模型之间的架构差异以及微调程序的不同，对这些目标进行公平比较一直是困难的。我们重新实现了最近为判别和生成任务提出的强大预训练方法。我们的目标是尽可能地控制与预训练目标无关的差异。然而，为了提高性能，我们确实对学习率和层归一化的使用进行了微小的改变（分别针对每个目标进行调整）。作为参考，我们将我们的实现与BERT的公开数据进行了比较，BERT也是在结合了书籍和维基百科数据的基础上训练了100万个step。我们比较了以下方法：</p> 
<p><strong>语言模型</strong> 类似于GPT（Radford等人，2018年），我们训练了一个从左到右的Transformer语言模型。这个模型相当于BART解码器，但没有交叉注意力。</p> 
<p><strong>排列语言模型</strong> 基于XLNet（Yang等人，2019年），我们对1/6的token进行采样，并且自回归地以随机顺序生成它们。为了与其他模型保持一致，我们没有实现XLNet中的相对位置嵌入或跨段落的注意力。</p> 
<p><strong>掩蔽语言模型</strong> 跟随BERT（Devlin等人，2019年），我们用[MASK]符号替换了15%的token，并训练模型独立预测原始token。</p> 
<p><strong>多任务掩蔽语言模型</strong> 如UniLM（Dong等人，2019年）所示，我们训练了一个带有额外自注意力掩蔽的掩蔽语言模型。自注意力掩蔽是随机选择的，遵循以下比例：1/6从左到右，1/6从右到左，1/3未掩蔽，以及1/3前50%的token未掩蔽并对其余部分施加从左到右的掩蔽。</p> 
<p><strong>掩蔽序列到序列</strong> 受到MASS（Song等人，2019年）的启发，我们掩蔽了包含50%的token的跨度，并训练一个序列到序列模型来预测被掩蔽的token。</p> 
<p>对于排列LM、掩蔽LM和多任务掩蔽LM，我们使用双流注意力（Yang等人，2019年）来高效计算输出序列的可能性（使用对角线自注意力掩蔽在输出上预测从左到右的词）。</p> 
<p>我们进行了实验：（1）将任务视为标准的序列到序列问题，其中编码器的源输入和目标是解码器输出，或者（2）在解码器中将源作为前缀添加到目标中，仅在序列的目标部分上有损失。我们发现前者对于BART模型效果更好，而后者对其他模型效果更好。为了最直接地比较我们的模型在建模其微调目标（人类文本的对数似然）的能力上的表现，我们在表1中报告了困惑度。</p> 
<p><img src="https://images2.imgbox.com/64/ac/niIDN3ei_o.png" alt="image.png"><br> 表 1：预训练目标比较。所有模型的大小都相当，并且结合书籍和维基百科数据进行了 100 万步的训练。底部两个块中的条目使用相同的代码库对相同的数据进行训练，并使用相同的过程进行微调。第二块中的条目受到之前工作中提出的预训练目标的启发，但已被简化以专注于评估目标。不同任务的性能差异很大，但带有文本填充的 BART 模型表现出最一致的强大性能。</p> 
<h3><a id="_86"></a>任务</h3> 
<p><strong>SQuAD</strong>（Rajpurkar等，2016年）是一个在维基百科段落上进行的抽取式问答任务。答案是从给定文档内容中抽取的文本跨度。类似于BERT（Devlin等，2019年），我们使用连接的问题和上下文作为编码器的输入，同时也传递给解码器。该模型包括分类器来预测每个token的开始和结束索引。</p> 
<p><strong>MNLI</strong>（Williams等，2017年）是一个双文本分类任务，用于预测一句话是否蕴含另一句话。微调后的模型连接这两个句子，在EOS token后追加，然后将它们传递给BART的编码器和解码器。与BERT不同，EOS token的表示用于分类句子关系。</p> 
<p><strong>ELI5</strong>（Fan等，2019年），一个长篇抽象问答数据集。模型生成的答案基于问题和支持文档的连接。</p> 
<p><strong>XSum</strong>（Narayan等，2018年），一个具有高度概括性摘要的新闻摘要数据集。</p> 
<p><strong>ConvAI2</strong>（Dinan等，2019年），一个对话响应生成任务，以上下文和角色为条件。</p> 
<p><strong>CNN/DM</strong>（Hermann等，2015年），一个新闻摘要数据集。这里的摘要通常与源句子紧密相关。</p> 
<h3><a id="_100"></a>结果</h3> 
<p>结果显示在表1中。几个趋势很明显：</p> 
<p>预训练方法的性能在不同任务上有显著差异。预训练方法的有效性高度依赖于任务。例如，一个简单的语言模型在ELI5任务上表现最好，但在SQuAD任务上结果最差。</p> 
<p>掩码标记至关重要。基于文档旋转或句子置换的预训练目标在单独使用时表现不佳。成功的方法要么使用token删除或掩码，要么使用自注意力掩码。在生成任务上，删除似乎比掩码更有效。</p> 
<p>从左到右的预训练提高了生成性能。掩蔽语言模型和排列语言模型在生成上的表现不如其他模型，并且是我们考虑的唯一不包括从左到右自回归语言建模的预训练模型。</p> 
<p>双向编码器对于SQuAD至关重要。正如之前的工作（Devlin等，2019年）所指出的，仅从左到右的解码器在SQuAD上表现不佳，因为未来上下文在分类决策中至关重要。然而，BART在仅有一半双向层的情况下实现了类似的性能。</p> 
<p>预训练目标并非唯一重要因素。我们的排列语言模型表现不如XLNet（Yang等，2019年）。这种差异可能是由于没有包括其他的架构改进，比如相对位置嵌入或段落级递归。</p> 
<p>纯粹的语言模型在ELI5上表现最好。ELI5数据集是一个异常值，其困惑度远高于其他任务，并且是唯一其他模型超越BART的生成任务。一个纯粹的语言模型表现最好，这表明当输出只是松散受输入约束时，BART的效果不佳。</p> 
<p>BART实现了最一致的强大性能。除了ELI5之外，使用文本填充的BART模型在所有任务上都表现良好。</p> 
<p>这些论文段落的翻译如下：</p> 
<h2><a id="_120"></a>大规模预训练实验</h2> 
<p>最近的研究表明，当预训练扩大到大批量大小和语料库时，下游任务的性能可以得到显著提升（Yang等，2019年；Liu等，2019年）。为了测试BART在这种范围内的性能，并且为下游任务创建一个有用的模型，我们使用与RoBERTa模型相同的规模来训练BART。</p> 
<h3><a id="_124"></a>实验设置</h3> 
<p>我们预训练了一个大型模型，在编码器和解码器中各有12层，隐层大小为1024。跟随RoBERTa（Liu等，2019年）的做法，我们使用8000的批量大小，并训练模型500000步。文档被同GPT-2（Radford等，2019年）一样的字节对编码进行分词。基于第4节的结果，我们使用文本填充和句子排列的组合。我们在每个文档中掩蔽30%的token，并排列所有句子。尽管句子排列只在与其他方法结合时显示出显著的累积收益。</p> 
<p>在CNN/DM摘要数据集上，我们假设更大的预训练模型可能更能从这个任务中学习。为了帮助模型更好地适应数据，我们在训练的最后10%的步骤中禁用了dropout。我们使用与Liu等人（2019年）相同的预训练数据，包括160GB的新闻、书籍、故事和网络文本。</p> 
<h3><a id="_130"></a>区分性任务</h3> 
<p>表2比较了BART在众所周知的SQuAD和GLUE任务上与几种最近方法的性能（Warstadt等，2018年；Socher等，2013年；Dolan &amp; Brockett，2005年；Aguirre等，2007年；Williams等，2018年；Dagan等，2006年；Levesque等，2011年）。最直接可比的基线是RoBERTa，它是用相同的资源但不同目标进行预训练的。总的来说，BART的性能与其他模型相似，模型之间的差异很小，这表明BART在生成任务上的改进并不以牺牲分类性能为代价。</p> 
<p><img src="https://images2.imgbox.com/4d/21/SKFoRMXl_o.png" alt="image.png"><br> 表 2：大型模型在 SQuAD 和 GLUE 任务上的结果。 BART 的性能与 RoBERTa 和 XLNet 相当，这表明 BART 的单向解码器层不会降低判别任务的性能。</p> 
<h3><a id="_137"></a>生成任务</h3> 
<p>我们还尝试了几个文本生成任务。BART被微调为标准的序列到序列模型，从输入到输出文本。在微调期间，我们使用一个带标签平滑的交叉熵损失（Pereyra等，2017年），平滑参数设置为0.1。在生成时，我们将beam大小设置为5，移除beam搜索中的重复三元组，并调整了模型的最小长度、最大长度、长度惩罚，在验证集上（Fan等，2017年）。</p> 
<h4><a id="_141"></a>摘要</h4> 
<p>为了与当前摘要任务的最新技术进行比较，我们在两个具有不同特点的摘要数据集CNN/DailyMail和XSum上展示了结果。</p> 
<p>CNN/DailyMail中的摘要倾向于与源句子相似。抽取式模型在这里做得很好，甚至仅用前三个源句子作为基线的表现也非常有竞争力。尽管如此，BART在所有已有的工作中表现最好。</p> 
<p>相比之下，XSum高度概括，抽取式模型表现不佳。BART在所有ROUGE指标上大约比利用BERT的最佳前作提高了6.0分，这代表了在这一问题上性能的重大进步。在质量上，样本的质量很高（见第6节）。</p> 
<p><img src="https://images2.imgbox.com/25/0a/0RV6Wskk_o.png" alt="image.png"><br> 表 3：两个标准汇总数据集的结果。 BART 在两项任务和所有指标的总结方面优于之前的工作，在更抽象的数据集上获得了大约 6 个点的收益。</p> 
<h4><a id="_151"></a>对话</h4> 
<p>我们评估了在ConvAI2（Dinan等，2019年）上的对话响应生成，在该任务中，代理必须生成基于先前上下文和文本指定的人物的响应。BART在两个自动化指标上超越了先前的工作。</p> 
<p><img src="https://images2.imgbox.com/e5/bb/n5CvLLbP_o.png" alt="image.png"><br> 表 4：BART 优于之前在对话响应生成方面的工作。基于 ConvAI2 的官方分词器重新规范化困惑度。</p> 
<h4><a id="_156"></a>抽象式问答</h4> 
<p>我们使用最近提出的ELI5数据集来测试模型生成长篇自由形式回答的能力。我们发现BART在ROUGE-L上比之前最好的工作高出1.2分，但数据集仍然具有挑战性，因为答案仅由问题弱指定。</p> 
<p><img src="https://images2.imgbox.com/86/ec/BWr3coDY_o.png" alt="image.png"><br> 表 5：BART 在具有挑战性的 ELI5 抽象问答数据集上取得了最先进的结果。比较模型来自 Fan 等人。 （2019）。</p> 
<h3><a id="_161"></a>翻译</h3> 
<p>我们还评估了在WMT16罗马尼亚-英语翻译任务上的表现，并用Sennrich等人（2016年）的反向翻译数据增强。我们使用一个6层的transformer源编码器将罗马尼亚语映射到BART能够去噪成英语的表示，遵循第3.4节介绍的方法。实验结果呈现在表6中。我们将我们的结果与Vaswani等人（2017年）提出的基线Transformer架构进行了比较，使用了Transformer的大规模设置（基线行）。我们展示了我们模型两个步骤在固定BART和调整后的BART行的性能。对于每一行，我们在原始的WMT16罗马尼亚-英语数据上进行实验，并用反向翻译数据增强。我们使用了一个宽度为5的beam和一个长度惩罚α=1。初步结果表明，我们的方法在没有反向翻译数据的情况下效果不佳，并且容易过拟合——未来的工作应该探索额外的正则化技术。<br> <img src="https://images2.imgbox.com/5c/af/oiWz3HZ7_o.png" alt="image.png"><br> 表 6：WMT’16 RO-EN 上基线和 BART 的性能 (BLEU)，并用反向翻译数据增强。 BART 通过使用单语英语预训练，在强大的反向翻译 (BT) 基线上进行了改进。</p> 
<h2><a id="_166"></a>定性分析</h2> 
<p>BART在摘要指标上显示出大幅度的提升，相比之前的最先进技术高出多达6分。为了理解BART在自动化指标之外的表现，我们定性地分析了它的生成文本。</p> 
<p>表7展示了BART生成的摘要示例。示例取自WikiNews文章，这些文章在预训练语料库创建之后发布，以排除模型训练数据中描述的事件出现在模型训练数据中的可能性。跟随Narayan等人（2018年）的做法，我们在总结之前移除了文章的第一句话，所以不会有简单的抽取式摘要。</p> 
<p>不出所料，模型输出流畅且语法正确。然而，模型输出也高度概括，从输入中复制的短语很少。输出通常也是事实上准确的，并且结合了来自输入文档的支持证据和背景知识（例如，正确完成名称，或推断PG&amp;E在加利福尼亚州运营）。在第一个例子中，推断鱼类保护珊瑚礁免受全球变暖影响需要从文本中进行非平凡的推理。然而，声称该工作发表在《科学》杂志上的说法并未得到来源的支持。</p> 
<p>这些样本展示了BART预训练学习到了自然语言理解和生成的强大组合。<br> <img src="https://images2.imgbox.com/a8/9d/Cddt3K1D_o.png" alt="image.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a9c19692fbecfe4093a4d71b5fa81c8e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">提前终止 Lambda forEach 的两种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d203c2aabc3eaf6dfe8264405d5dded/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux 常见服务配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>