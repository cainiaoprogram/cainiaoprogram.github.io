<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux后台任务运行的方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux后台任务运行的方法" />
<meta property="og:description" content="Linux后台任务运行的方法 最近在远程服务器跑算法模型，远程服务器的工具我用的是MobaXterm，推荐推荐，很好用~
言归正传，跑算法模型要好久，因为服务器性能不是很好，我跑一次要好几天，那就难免远程连接服务器工具会断开，这时候跑了几天的这个模型进程就无了…，也差点把我气的送走~~
最后，自己知道了如何后台运行，恩，真香，自己也就调研学习了一下Linux后台运行任务的方法，在现在跑模型的时候也使用了其中的一种，余下几种自己玩了玩，来记录一下，方便下次看~，学到的方法写在总结里哦！！
1、原理知识剖析（问题引出） 问题：
为什么远程工具断了，进程就没了呢？为什么我们平时用ctrl&#43;c，那进程也就断了呢？ 为了来探究这两个问题，我们首先要了解一下Linux的一些信号，我们可以在终端输入以下命令来查看：
kill -l 可以看到总共有64个信号，我们一般称1 ~ 31的信号为不可靠信号，传统UNIX支持的非实时的信号；32 ~ 64为可靠信号，即后来扩充的可靠信号，两者的区别是不可靠信号不支持排队，从而可能会造成信号丢失，而可靠信号则不会。下面介绍几个终端常见到的几个（大家可以试试，看看都是什么效果）：
1) SIGHUP：本信号在用户终端连接(正常或非正常)结束时发出 2) SIGINT：程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。 3) SIGQUIT：与SIGINT类似, 但由QUIT字符(通常是Ctrl-\)来控制 9) SIGKILL：用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果某个进程终止不了，发送这个信号 20) SIGTSTP：停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号 而上面两个问题背后的主要原因会涉及到SIGHUP 、SIGINT信号，下面说明原因：
原因：在我们登录Linux服务器的时候，系统会分配给我们一个终端，也就是一个Session。在我们登录成功之后，我们运行的所有程序，无论是前台进程还是后台进程一般都属于这个Session，那如果我们关闭了终端或者用了ctrl&#43;c，shell默认会发送中断信号给该终端Session关联的进程，从而导致进程终止。
sighup: signal hang up，用户退出Linux登录时或者关闭终端时候，若有对终端输出的进程，其将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此该向终端输出的进程就会中止。不过可以对这个信号进行捕获，比如wget能捕获SIGHUP信号并忽略它，这就是为什么就算退出了Linux登录，wget也能继续下载的原因sigint： signal interrupt，ctrl&#43;c 会发送此信号，主动关闭程序 2、问题处理 在上面我们知道了：
远程工具断了，发送了sighup信号，进程没了Ctrl&#43;c发送 sigint ，那进程也没了 那首先想到的就是，我执行上面的操作，我不让其发送信号不就好了？或者说，你发送信号，我采取机制忽略你？这就对应有两个东西的出现：
2.1 忽略sigint信号（&amp; 符号） 第一种，我们让启动的程序忽略sigint信号，从而让导致进程关闭的sigint信号无效，那就用到了 &amp; 符号
例如：（是不是real简单，哈哈哈哈哈）
tail -f logs.log &amp; 2.2 忽略sigup信号（nohup） 介绍一种命令：nohup ，英文全称 no hang up（不挂起），我们可以用这个命令来使任务不挂断一直在系统后台运行
原理：nohup捕获了SIGHUP信号，对其进行了忽略，从而让发送能让进程关闭sigup信号的操作无效
nohup的命令语法：
nohup Command [ Arg … ] [　&amp; ] Command：要执行的命令。Arg：可选，一些参数，可以指定输出文件。&amp;：可选，让命令在后台执行 在默认情况下（没有指定输出文件的时候）会输出一个名叫 nohup." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a59595ae5525e55bcc52cb9f4fc1337b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-10T19:16:31+08:00" />
<meta property="article:modified_time" content="2022-01-10T19:16:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux后台任务运行的方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Linux_0"></a>Linux后台任务运行的方法</h2> 
<p>最近在远程服务器跑算法模型，远程服务器的工具我用的是<strong>MobaXterm</strong>，推荐推荐，很好用~</p> 
<p>言归正传，跑算法模型要好久，因为服务器性能不是很好，我跑一次要好几天，那就难免远程连接服务器工具会断开，这时候跑了几天的这个模型进程就无了…，也差点把我气的送走~~</p> 
<p>最后，自己知道了如何后台运行，恩，真香，自己也就调研学习了一下Linux后台运行任务的方法，在现在跑模型的时候也使用了其中的一种，余下几种自己玩了玩，来记录一下，方便下次看~，学到的方法写在总结里哦！！</p> 
<h3><a id="1_8"></a>1、原理知识剖析（问题引出）</h3> 
<p>问题：</p> 
<ul><li>为什么远程工具断了，进程就没了呢？</li><li>为什么我们平时用ctrl+c，那进程也就断了呢？</li></ul> 
<p>为了来探究这两个问题，我们首先要了解一下Linux的一些信号，我们可以在终端输入以下命令来查看：</p> 
<pre><code class="prism language-java">kill <span class="token operator">-</span>l
</code></pre> 
<p><img src="https://images2.imgbox.com/0b/9e/CR1Y1rJW_o.png" alt="请添加图片描述"></p> 
<p>可以看到总共有64个信号，我们一般称1 ~ 31的信号为不可靠信号，传统UNIX支持的非实时的信号；32 ~ 64为可靠信号，即后来扩充的可靠信号，两者的区别是不可靠信号不支持排队，从而可能会造成信号丢失，而可靠信号则不会。下面介绍几个终端常见到的几个（大家可以试试，看看都是什么效果）：</p> 
<pre><code class="prism language-bash"><span class="token number">1</span><span class="token punctuation">)</span> SIGHUP：本信号在用户终端连接<span class="token punctuation">(</span>正常或非正常<span class="token punctuation">)</span>结束时发出

<span class="token number">2</span><span class="token punctuation">)</span> SIGINT：程序终止<span class="token punctuation">(</span>interrupt<span class="token punctuation">)</span>信号, 在用户键入INTR字符<span class="token punctuation">(</span>通常是Ctrl-C<span class="token punctuation">)</span>时发出，用于通知前台进程组终止进程。
 
<span class="token number">3</span><span class="token punctuation">)</span> SIGQUIT：与SIGINT类似, 但由QUIT字符<span class="token punctuation">(</span>通常是Ctrl-<span class="token punctuation">\</span><span class="token punctuation">)</span>来控制

<span class="token number">9</span><span class="token punctuation">)</span> SIGKILL：用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果某个进程终止不了，发送这个信号

<span class="token number">20</span><span class="token punctuation">)</span> SIGTSTP：停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时<span class="token punctuation">(</span>通常是Ctrl-Z<span class="token punctuation">)</span>发出这个信号
</code></pre> 
<p>而上面两个问题背后的主要原因会涉及到<strong>SIGHUP 、SIGINT</strong>信号，下面说明原因：</p> 
<p><strong>原因</strong>：在我们登录Linux服务器的时候，系统会分配给我们一个终端，也就是一个<strong>Session</strong>。在我们登录成功之后，我们运行的所有程序，无论是前台进程还是后台进程一般都属于这个<strong>Session</strong>，那如果我们关闭了终端或者用了ctrl+c，shell默认会发送中断信号给该终端<strong>Session</strong>关联的进程，从而导致进程终止。</p> 
<ul><li><strong>sighup</strong>: signal hang up，用户退出Linux登录时或者关闭终端时候，若有对终端输出的进程，其将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此该向终端输出的进程就会中止。不过可以对这个信号进行捕获，比如<strong>wget</strong>能捕获SIGHUP信号并忽略它，这就是为什么就算退出了Linux登录，wget也能继续下载的原因</li><li><strong>sigint</strong>： signal interrupt，ctrl+c 会发送此信号，主动关闭程序</li></ul> 
<h3><a id="2_45"></a>2、问题处理</h3> 
<p>在上面我们知道了：</p> 
<ul><li>远程工具断了，发送了<strong>sighup</strong>信号，进程没了</li><li>Ctrl+c发送 <strong>sigint</strong> ，那进程也没了</li></ul> 
<p>那首先想到的就是，我执行上面的操作，我不让其发送信号不就好了？或者说，你发送信号，我采取机制忽略你？这就对应有两个东西的出现：</p> 
<h4><a id="21_sigint__54"></a>2.1 忽略sigint信号（&amp; 符号）</h4> 
<p>第一种，<strong>我们让启动的程序忽略sigint信号，从而让导致进程关闭的sigint信号无效</strong>，那就用到了 <strong>&amp; 符号</strong></p> 
<p>例如：<strong>（是不是real简单，哈哈哈哈哈）</strong></p> 
<pre><code class="prism language-bash"><span class="token function">tail</span> -f logs.log <span class="token operator">&amp;</span>
</code></pre> 
<h4><a id="22_sigupnohup_64"></a>2.2 忽略sigup信号（nohup）</h4> 
<p>介绍一种命令：<strong>nohup</strong> ，英文全称 no hang up（不挂起），我们可以用这个命令来使任务不挂断一直在系统后台运行</p> 
<p>原理：<strong>nohup捕获了SIGHUP信号，对其进行了忽略，从而让发送能让进程关闭sigup信号的操作无效</strong></p> 
<p>nohup的命令语法：</p> 
<pre><code class="prism language-bash"><span class="token function">nohup</span> Command <span class="token punctuation">[</span> Arg … <span class="token punctuation">]</span> <span class="token punctuation">[</span>　<span class="token operator">&amp;</span> <span class="token punctuation">]</span>
</code></pre> 
<ul><li><strong>Command</strong>：要执行的命令。</li><li><strong>Arg</strong>：可选，一些参数，可以指定输出文件。</li><li><strong>&amp;</strong>：可选，让命令在后台执行</li></ul> 
<p>在默认情况下（没有指定输出文件的时候）会输出一个名叫 <strong>nohup.out</strong> 的文件到<strong>当前目录下</strong>，如果当前目录的 nohup.out 文件不可写，输出重定向到 <strong>$HOME/nohup.out</strong> 文件中。</p> 
<p>使用：</p> 
<pre><code class="prism language-bash"><span class="token function">nohup</span> <span class="token function">tail</span> -f logs.log
</code></pre> 
<p>其他使用（指定输出文件）：</p> 
<pre><code class="prism language-bash"><span class="token function">nohup</span> ./example.sh <span class="token operator">&gt;</span> logs.log <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>err.log
</code></pre> 
<p>后台不中断执行./example.sh，正常stdout输出给logs.log，错误stderr输出给err.log日志中</p> 
<p>官网对这里的相关的数字含义解释如下：</p> 
<ul><li>0 – stdin (standard input，标准输入)</li><li>1 – stdout (standard output，标准输出)</li><li>2 – stderr (standard error，标准错误输出)</li></ul> 
<p>官网的一种举例，其含义是将标准错误 2 重定向到标准输出 &amp;1 ，标准输出 &amp;1 再被重定向输入到 runoob.log 文件中</p> 
<pre><code class="prism language-bash"><span class="token function">nohup</span> /root/runoob.sh <span class="token operator">&gt;</span> runoob.log <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span>
</code></pre> 
<p>也可以看到，一般我们<strong>将nohup命令与&amp;符合结合起来使用</strong>。那么这两个信号都没有作用了，very nice，我现在也是喜欢用这个方法来跑模型，把日志输出我自己的输出日志中，体验感不错~</p> 
<h4><a id="23_sigupsetsid_110"></a>2.3 不接受sigup信号（setsid命令）</h4> 
<p>介绍一种命令：<strong>setsid</strong> ，可以用这个命令重新创建一个session，让子进程继承父进程的SessionId，但可以脱离父进程，不受负进程控制</p> 
<p>原理：nohup 可以通过忽略 HUP 信号来使我们的进程避免中途被中断，但角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了，setsid 就是这样的</p> 
<p>setsid的命令语法：</p> 
<pre><code class="prism language-bash">setsid Command <span class="token punctuation">[</span> Arg … <span class="token punctuation">]</span>
</code></pre> 
<ul><li><strong>Command</strong>：要执行的命令。</li><li><strong>Arg</strong>：可选，一些参数</li></ul> 
<p>使用：</p> 
<pre><code class="prism language-bash">setsid <span class="token function">tail</span> -f logs.log
</code></pre> 
<p>我们来查看进程看看：</p> 
<p><img src="https://images2.imgbox.com/d5/49/8biKAVdd_o.png" alt="请添加图片描述"></p> 
<p>可以看到：</p> 
<ul><li>我们终端的进程ID是20953，框框上面的是上面的几种后台任务进行的方式产生的，可见各自的进程ID不同，但是父进程ID都是20953</li><li>而框框是执行setsid得到的，进程 ID(PID)为22161，而它的父 ID为1，并不是当前终端的进程 ID 20953</li></ul> 
<h3><a id="3_142"></a>3、其他的方法</h3> 
<p>下面介绍几种其他的方法：</p> 
<ul><li>.ctrl + z、jobs、fg、bg（任务调度的方式）</li><li>screen （多重视窗管理程序）</li><li>tmux （终端复用软件）</li></ul> 
<h4><a id="31__150"></a>3.1 任务调度的方式</h4> 
<p>在上面有一个信号 <strong>SIGTSTP</strong> 主要是 来使终端输出的进程停止，也就是挂起，我们可以使用 <strong>Ctrl+Z</strong>来发送这个信号</p> 
<p>例如：我们tail查看一个日志的时候，按下<strong>Ctrl+Z</strong>，会对应有一个 Stopped，【1】为其作业号，我们在将其重新运行的时候就用到这个作业号</p> 
<p><img src="https://images2.imgbox.com/c7/cc/PEOJTYtV_o.png" alt="请添加图片描述"></p> 
<p>所以针对这种情况，我们挂起，肯定有重新运行，所以这就涉及到了几个命令：</p> 
<ul><li>jobs：查看当前有多少在后台运行的命令</li><li>fg：将后台中的作业进程调至前台继续运行</li><li>bg：将后台中暂停（挂起）的作业进程继续运行</li></ul> 
<p>举例使用：</p> 
<pre><code class="prism language-bash"><span class="token operator">&gt;</span>jobs

<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped                 <span class="token function">tail</span> -f /home/hiudawn/mlpan/faster-rcnn/logs/res.log

<span class="token operator">&gt;</span>fg <span class="token number">1</span> <span class="token comment"># 重新运行作业号为1的作业</span>

<span class="token function">tail</span> -f /home/hiudawn/mlpan/faster-rcnn/logs/res.log

<span class="token operator">&gt;</span>bg <span class="token number">1</span> <span class="token comment"># # 重新运行挂起的作业号为1的作业（后台运行）</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+ <span class="token function">tail</span> -f /home/hiudawn/mlpan/faster-rcnn/logs/res.log <span class="token operator">&amp;</span>
</code></pre> 
<h4><a id="32_screen_180"></a>3.2 screen</h4> 
<p>官方解释：screen命令用于多重视窗管理程序。screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面（终端页面）。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。</p> 
<p>粗略解释：可以粗略地认为screen是一个虚拟终端软件，它直接在linux系统里面启动了另外一个后台程序接管（维持）了你的这个终端会话，当你直接连接的终端ssh断开时他仍然让程序认为你的ssh持续链接着，这样也就不会出现进程接收到中断信号而退出。</p> 
<p>语法：</p> 
<pre><code class="prism language-bash"><span class="token function">screen</span> <span class="token punctuation">[</span>-AmRvx -ls -wipe<span class="token punctuation">]</span><span class="token punctuation">[</span>-d <span class="token operator">&lt;</span>作业名称<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-h <span class="token operator">&lt;</span>行数<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-r <span class="token operator">&lt;</span>作业名称<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-s <span class="token operator">&lt;</span>shell<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-S <span class="token operator">&lt;</span>作业名称<span class="token operator">&gt;</span><span class="token punctuation">]</span>
</code></pre> 
<p>解释</p> 
<ul><li>[-AmRvx -ls -wipe] 
  <ul><li>-A 　将所有的视窗都调整为目前终端机的大小。</li><li>-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。</li><li>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。</li><li>-v 　显示版本信息。</li><li>-x 　恢复之前离线的screen作业。</li><li>-ls或–list 　显示目前所有的screen作业。</li><li>-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</li></ul> </li><li>-r &lt;作业名称&gt; 　恢复离线的screen作业。</li><li>-d &lt;作业名称&gt; 　将指定的screen作业离线。</li><li>-h &lt;行数&gt; 　指定视窗的缓冲区行数。</li><li>-s 　指定建立新视窗时，所要执行的shell。</li><li>-S &lt;作业名称&gt; 　指定screen作业的名称。</li></ul> 
<p>使用：</p> 
<p>（1）在使用前需要先安装：</p> 
<pre><code class="prism language-bash"><span class="token function">apt-get</span> <span class="token function">install</span>  <span class="token function">screen</span>

yum <span class="token function">install</span>  <span class="token function">screen</span>
</code></pre> 
<p>（2）常用选项：</p> 
<ul><li>用<code>screen -dmS name</code>来建立一个处于断开模式下的会话（并指定其会话名name）。</li><li>用<code>screen -list</code>来列出所有会话。</li><li>用<code>screen -r name</code>来重新连接指定会话（连接会话名为name的会话）</li><li>用快捷键<code>CTRL+d</code>来暂时断开当前会话</li></ul> 
<p>例如：（简单使用，创建几个会话）</p> 
<p><img src="https://images2.imgbox.com/48/91/nEc2Hl8m_o.png" alt="请添加图片描述"></p> 
<p>可以自己试试效果 screen -r u 连接u会话就可以干一些想干的事情了~~，下面我们看看进程的变化</p> 
<h6><a id="1__screen__232"></a>1. 未使用 screen 时新进程的进程树</h6> 
<pre><code>(base) hiudawn@1060:~$ ping www.google.com &amp;
[1] 9499
(base) hiudawn@1060:~$ pstree -H 9499
init─┬─Xvnc
├─acpid  
├─atd  
├─2*[sendmail]   
├─sshd─┬─sshd───bash───pstree   
│      └─sshd───bash───ping
</code></pre> 
<p>我们可以看出，未使用 screen 时我们所处的 <strong>bash</strong> 是 <strong>sshd</strong> 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 ping 进程）。</p> 
<h6><a id="2__screen__248"></a>2. 使用了 screen 后新进程的进程树</h6> 
<pre><code>(base) hiudawn@1060:~$ screen -r u
(base) hiudawn@1060:~$ ping www.ibm.com &amp;
[1] 9488
(base) hiudawn@1060:~$ pstree -H 9488
init─┬─Xvnc   
├─acpid
├─atd   
├─screen───bash───ping   
├─2*[sendmail]
</code></pre> 
<p>而使用了 screen 后就不同了，此时 <strong>bash</strong> 是 <strong>screen</strong> 的子进程，而 <strong>screen</strong> 是 **init（PID为1）**的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。</p> 
<h4><a id="33_tmux_264"></a>3.3 tmux</h4> 
<p>Tmux是一个优秀的终端复用软件，类似screen，我们通过一个终端登录远程主机然后并运行tmux后，可开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。其可以说是Screen的替代品。tmux的功能很多，很复杂，具体的可以查看 这篇文章 <a href="https://www.cnblogs.com/wangqiguo/p/8905081.html" rel="nofollow">tmux终端复用详解</a>，这里不再细说了 。</p> 
<p>语法：</p> 
<pre><code class="prism language-bash">tmux <span class="token punctuation">[</span>-2CluvV<span class="token punctuation">]</span> <span class="token punctuation">[</span>-c <span class="token operator">&lt;</span>shell<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-f file<span class="token punctuation">]</span> <span class="token punctuation">[</span>-L socket-name<span class="token punctuation">]</span> <span class="token punctuation">[</span>-S socket-path<span class="token punctuation">]</span> <span class="token punctuation">[</span>command <span class="token punctuation">[</span>flags<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<h2><a id="_274"></a>总结</h2> 
<ul><li>&amp; 符号：忽略sigint信号</li><li>nohup命令：忽略sigup信号</li><li>setsid命令：开启新session，不接受sigup信号</li><li>.ctrl + z、jobs、fg、bg：任务调度的方式</li><li>screen ：多重视窗管理程序</li><li>tmux ：终端复用软件</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca9ec776836cf91bd87e24a1ff318344/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GraphPad Prism的八种数据表格式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/202459f0b865919c6d138247156741bb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nodemon使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>