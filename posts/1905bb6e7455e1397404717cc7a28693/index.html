<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FatFs 之一 R0.13c版源码目录文件、函数、全配置项详解及移植说明 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FatFs 之一 R0.13c版源码目录文件、函数、全配置项详解及移植说明" />
<meta property="og:description" content="FatFs 是用于小型嵌入式系统的通用 FAT/exFAT 文件系统模块。FatFs 模块的编写符合 ANSI C（C89），并与磁盘 I/O 层完全分离，因此它独立于硬件平台。 它可以集成到资源有限的小型微控制器中，例如 8051，PIC，AVR，ARM，Z80，RX 等。此外，还提供用于微型微控制器的 Petit FatFs 模块。
看本文时需要有点 FAT 文件系统的基础，可以参考FatFs 之三 FAT文件系统基础、FAT 数据格式、引导、编码。
变更记录 具体参见源码文件中的 /source/00history.txt 即可！也可以去官网查看。从中我们可以看到修复的各问题，尤其是源码文件的变动。例如：在 R0.13c 中，原来独立文件 integer.h 中的内容被直接包含在了 ff.h 中，原来的 integer.h 被删除！对比如下图所示：
源码目录文件 目前，最新版本为 R0.13c。相比于之前的版本，源码有了一定的变化（参见上图）。FatFs 的源码包中，文件非常简单。其源码目录结构如下所示（对于简单的文件以注释的形式给出，核心源码下文会详细说明）：
FatFs R0.13c │ LICENSE.txt	// 版权说明 ├─documents	// 配套的说明文档 └─source 00history.txt	// 更新历史记录 00readme.txt	// 对于以下每个文件的功能简介 diskio.c	// FATFS 与硬件的接口实现文件模板 diskio.h	// FATFS 与硬件的接口实现文件模板 ff.c	// FATFS 核心源代码 ff.h	// FATFS 核心源代码 ffconf." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1905bb6e7455e1397404717cc7a28693/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-18T18:48:36+08:00" />
<meta property="article:modified_time" content="2019-07-18T18:48:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FatFs 之一 R0.13c版源码目录文件、函数、全配置项详解及移植说明</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>  FatFs 是用于小型嵌入式系统的通用 FAT/exFAT 文件系统模块。FatFs 模块的编写符合 ANSI C（C89），并与磁盘 I/O 层完全分离，因此它独立于硬件平台。 它可以集成到资源有限的小型微控制器中，例如 8051，PIC，AVR，ARM，Z80，RX 等。此外，还提供用于微型微控制器的 Petit FatFs 模块。<br>   看本文时需要有点 FAT 文件系统的基础，可以参考<a href="https://blog.csdn.net/ZCShouCSDN/article/details/97610903">FatFs 之三 FAT文件系统基础、FAT 数据格式、引导、编码</a>。</p> 
<h2><a id="_2"></a>变更记录</h2> 
<p>  具体参见源码文件中的 <code>/source/00history.txt</code> 即可！也可以去官网查看。从中我们可以看到修复的各问题，尤其是源码文件的变动。例如：在 R0.13c 中，原来独立文件 <code>integer.h</code> 中的内容被直接包含在了 <code>ff.h</code> 中，原来的 <code>integer.h</code> 被删除！对比如下图所示：<br> <img src="https://images2.imgbox.com/cb/4b/t0HwkW46_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_6"></a>源码目录文件</h2> 
<p>  目前，最新版本为 R0.13c。相比于之前的版本，源码有了一定的变化（参见上图）。FatFs 的源码包中，文件非常简单。其源码目录结构如下所示（<strong>对于简单的文件以注释的形式给出，核心源码下文会详细说明</strong>）：</p> 
<pre><code class="prism language-c">FatFs R0<span class="token punctuation">.</span><span class="token number">13</span>c
│  LICENSE<span class="token punctuation">.</span>txt					<span class="token comment">// 版权说明</span>
├─documents						<span class="token comment">// 配套的说明文档</span>
└─source
        <span class="token number">00</span>history<span class="token punctuation">.</span>txt			<span class="token comment">// 更新历史记录</span>
        <span class="token number">00</span>readme<span class="token punctuation">.</span>txt			<span class="token comment">// 对于以下每个文件的功能简介</span>
        diskio<span class="token punctuation">.</span>c				<span class="token comment">// FATFS 与硬件的接口实现文件模板</span>
        diskio<span class="token punctuation">.</span>h				<span class="token comment">// FATFS 与硬件的接口实现文件模板</span>
        ff<span class="token punctuation">.</span>c					<span class="token comment">// FATFS 核心源代码</span>
        ff<span class="token punctuation">.</span>h					<span class="token comment">// FATFS 核心源代码</span>
        ffconf<span class="token punctuation">.</span>h				<span class="token comment">// FATFS 的配置文件</span>
        ffsystem<span class="token punctuation">.</span>c				<span class="token comment">// 定义了：可选的与操作系统对接的各接口相关实现示例。</span>
        ffunicode<span class="token punctuation">.</span>c				<span class="token comment">// 提供了 Unicode 相关的转换函数</span>
</code></pre> 
<p>以下主要介绍 source 目录下的源代码部分！</p> 
<h3><a id="ffconfh_25"></a>ffconf.h</h3> 
<p>  该文件是 FatFs 的配置文件。<em><strong>用户需要根据自己的需求，来修改该文件中的各配置项</strong></em>。在 FatFs 默认的配置文件中，很多我们常用的函数都是被禁用的，必须修改下面的配置项来启用。这也就意味着，直接使用默认的配置文件一般是无法满足我们的需求的！接下来详细介绍一下每个配置项的具体含义及使用时需要注意的问题。以下为 FatFs 源码中默认的配置项说明。</p> 
<h4><a id="FatFs_Functional_Configurations_28"></a>FatFs Functional Configurations</h4> 
<h5><a id="FFCONF_DEF_29"></a>FFCONF_DEF</h5> 
<p>定义了 FatFs 的版本号，与实际功能无关。 主要是 FatFs 自身用来防止出错。具体在 <code>ff.h</code> 中，会检查该文件中的改宏值是否与 <code>ff.h</code> 中版本一致。在 <code>ff.h</code> 中，有如下语句:</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">if</span> FF_DEFINED != FFCONF_DEF</span>
<span class="token macro property">#<span class="token directive keyword">error</span> Wrong configuration file (ffconf.h).</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre> 
<h4><a id="Function_Configurations__37"></a>Function Configurations 功能配置</h4> 
<h5><a id="FF_FS_READONLY_38"></a>FF_FS_READONLY</h5> 
<p>定义 FatFs 是否工作在只读模式。</p> 
<ul><li>0：读/写。默认值。</li><li>1：只读。只读模式下，写相关的函数 f_write(), f_sync(), f_unlink(), f_mkdir(), f_chmod(), f_rename(), f_truncate(), f_getfree() 以及其他和写操作相关的函数都将被移除。</li></ul> 
<h5><a id="FF_FS_MINIMIZE_43"></a>FF_FS_MINIMIZE</h5> 
<p>用来极限精简 FatFs，此选项定义最小化级别，以删除一些基本 API 函数，如下所示</p> 
<ul><li>0：所有基本的 API 函数都可用。默认值。</li><li>1：f_stat，f_getfree，f_unlink，f_mkdir，f_chmod，f_utime，f_truncate和f_rename函数被删除。</li><li>2：除了移除 1 中的函数，还将移除 f_opendir, f_readdir and f_closedir</li><li>3：除了移除 2 中的函数，还将移除 f_lseek</li></ul> 
<h5><a id="FF_USE_STRFUNC_50"></a>FF_USE_STRFUNC</h5> 
<p>定义字符操作的相关函数 f_gets(), f_putc(), f_puts() 及 f_printf() 是否有效。</p> 
<ul><li>0：禁用所有的字符串相关操作函数。默认值。</li><li>1：启用，但是没有 LF-CRLF 转换。即：不会忽略回车符 \r</li><li>2：启用，且带有 LF-CRLF转换。即：忽略回车符 \r</li></ul> 
<h5><a id="FF_USE_FIND_56"></a>FF_USE_FIND</h5> 
<p>定义目录读取的相关函数（f_findfirst(), f_findnext()）是否有效</p> 
<ul><li>0： 禁用。默认值</li><li>1： 启用</li><li>2： 启用，且会检查是否匹配 altname[]。在 1 情况下，匹配条件只有文件名。此情况下，如果 altname[]匹配也认为是匹配的。FF_FS_MINIMIZE 必须为 0 或 1</li></ul> 
<h5><a id="FF_USE_MKFS_62"></a>FF_USE_MKFS</h5> 
<p>定义函数 f_mkfs() 是否有效</p> 
<ul><li>0： 禁用。默认值</li><li>1： 启用</li></ul> 
<h5><a id="FF_USE_FASTSEEK_67"></a>FF_USE_FASTSEEK</h5> 
<p>定义快速 seek 模式是否有效。</p> 
<ul><li>0： 禁用。默认值</li><li>1： 启用。会额外记录很多信息，以供在 f_lseek 中使用</li></ul> 
<h5><a id="FF_USE_EXPAND_72"></a>FF_USE_EXPAND</h5> 
<p>定义函数 f_expand() 是否有效</p> 
<ul><li>0： 禁用。默认值</li><li>1： 启用</li></ul> 
<h5><a id="FF_USE_CHMOD_77"></a>FF_USE_CHMOD</h5> 
<p>定义属性操作函数 f_chmod() 和 f_utime() 是否有效</p> 
<ul><li>0： 禁用。默认值</li><li>1： 启用。此外必须定义 FF_FS_READONLY 为 0。即：不能开启只读模式</li></ul> 
<h5><a id="FF_USE_LABEL_82"></a>FF_USE_LABEL</h5> 
<p>定义卷标函数 f_getlabel() 和 f_setlabel() 是否有效</p> 
<ul><li>0： 禁用。默认值</li><li>1： 启用</li></ul> 
<h5><a id="FF_USE_FORWARD_87"></a>FF_USE_FORWARD</h5> 
<p>定义函数 f_forward() 是否有效</p> 
<ul><li>0： 禁用。默认值</li><li>1： 启用</li></ul> 
<h4><a id="Locale_and_Namespace_Configurations___92"></a>Locale and Namespace Configurations 本地化和命名空间设置</h4> 
<h5><a id="FF_CODE_PAGE_93"></a>FF_CODE_PAGE</h5> 
<p>指定要在目标系统上使用的 OEM 代码页，错误的编码页设置将导致读写文件失败。支持的编码页如下：</p> 
<table><thead><tr><th>取值</th><th>编码页</th></tr></thead><tbody><tr><td>0</td><td>包括以下的所有代码页并由 f_setcp() 配置</td></tr><tr><td>437</td><td>U.S.</td></tr><tr><td>720</td><td>Arabic</td></tr><tr><td>737</td><td>Greek</td></tr><tr><td>771</td><td>KBL</td></tr><tr><td>775</td><td>Baltic</td></tr><tr><td>850</td><td>Latin 1</td></tr><tr><td>852</td><td>Latin 2</td></tr><tr><td>855</td><td>Cyrillic</td></tr><tr><td>857</td><td>Turkish</td></tr><tr><td>860</td><td>Portuguese</td></tr><tr><td>861</td><td>Icelandic</td></tr><tr><td>862</td><td>Hebrew</td></tr><tr><td>863</td><td>Canadian French</td></tr><tr><td>864</td><td>Arabic</td></tr><tr><td>865</td><td>Nordic</td></tr><tr><td>866</td><td>Russian</td></tr><tr><td>869</td><td>Greek 2</td></tr><tr><td>932</td><td>Japanese (DBCS)</td></tr><tr><td>936</td><td>Simplified Chinese (DBCS)</td></tr><tr><td>949</td><td>Korean (DBCS)</td></tr><tr><td>950</td><td>Traditional Chinese (DBCS)</td></tr></tbody></table> 
<p>如果路径名未使用任何非ASCII字符，则任何代码页设置之间都没有区别，将它设置为 437 即可。</p> 
<p>关于编码页，可以参考一下博文 <a href="https://blog.csdn.net/ZCShouCSDN/article/details/96475193">FatFs 之 路径规则、字符编码、编码页、卷管理详解</a>。</p> 
<h5><a id="FF_USE_LFN_123"></a>FF_USE_LFN</h5> 
<p>  此选项可切换对长文件名（LFN）的支持。 启用 LFN 时，需要将 Unicode 支持模块 <code>ffunicode.c</code> 添加到项目中。 当使用堆栈作为工作缓冲区时，请注意堆栈溢出。 当使用堆内存作为工作缓冲区时，需要将 <code>ffsystem.c</code> 添加到项目中，并实现其中的内存管理函数 ff_memalloc 和 ff_memfree。</p> 
<ul><li>0： 不启用。默认值。FF_MAX_LFN 无效</li><li>1： 启用。且 LFN 在代码段 BSS 上具有静态工作缓冲区。 始终不是线程安全的。</li><li>2： 启用。且在 STACK 上具有动态工作缓冲区的 LFN。需要注意栈溢出的问题。</li><li>3： 启用。且在 HEAP 上具有动态工作缓冲区的 LFN。此时，必须要启用 ffsystem.c 中的动态内存申请函数 ff_memalloc() 和 ff_memfree()</li></ul> 
<p>注意：长文件名与上面的编码页有关系！有些编码页就是 Unicode 字符集，也因此需要长文件名支持！</p> 
<p>关于长文件名，可以参考一下博文 <a href="https://blog.csdn.net/ZCShouCSDN/article/details/96475193">FatFs 之 路径规则、字符编码、编码页、卷管理详解</a>。</p> 
<h5><a id="FF_MAX_LFN_134"></a>FF_MAX_LFN</h5> 
<p>  启用 LFN ，会增加 (FF_MAX_LFN + 1) * 2 字节的固定缓冲区空间。具体使用方式见 ff.c 文件的开头部分的宏定义即可。如果是 exFAT 文件系统，则还需要再占用 (FF_MAX_LFN + 44) / 15 * 32 字节的缓冲区空间。且 exFAT 必须启用长文件名支持<br>   FF_MAX_LFN 以 UTF-16 代码单位定义工作缓冲区的大小，它可以在 12 到 255 的范围内。建议将 255 设置为完全支持LFN规范。长文件名是微软的专利，使用中与上面的编码有关系。</p> 
<h5><a id="FF_LFN_UNICODE_138"></a>FF_LFN_UNICODE</h5> 
<p>  此选项可在 API 上切换文件名的字符编码。选择 Unicode 时，FF_CODE_PAGE 实际上没有任何意义，除了与遗留系统的兼容性，例如 MS-DOS 和任何不支持 LFN 的系统。 FatFs 支持代码点达到 U + 10FFFF。</p> 
<ul><li>0： ANSI/OEM in current CP (TCHAR = char)。默认值</li><li>1： Unicode in UTF-16 (TCHAR = WCHAR)</li><li>2： Unicode in UTF-8 (TCHAR = char)</li><li>3： Unicode in UTF-32 (TCHAR = DWORD)</li></ul> 
<p>此外，字符串输入/输出函数的行为也会受到此选项的影响。如果关闭了长文件名支持，则该项无效！</p> 
<h5><a id="FF_LFN_BUF__FF_SFN_BUF_147"></a>FF_LFN_BUF 和 FF_SFN_BUF</h5> 
<p>  这组选项在 FILINFO 结构中定义了文件名成员 fname[] 和 altname[] 的大小，FILINFO 结构用于读取目录项。这些值应该足够读取文件名。读取文件名的最大可能长度取决于API上的字符编码，如下所示：</p> 
<table><thead><tr><th>Encoding</th><th>LFN length</th><th>SFN length</th></tr></thead><tbody><tr><td>ANSI/OEM at SBCS</td><td>255 items</td><td>12 items</td></tr><tr><td>ANSI/OEM at DBCS</td><td>510 items</td><td>12 items</td></tr><tr><td>Unicode in UTF-16/32</td><td>255 items</td><td>12 items</td></tr><tr><td>Unicode in UTF-8</td><td>765 items</td><td>34 items</td></tr></tbody></table> 
<p>如果名称成员的大小不足以用于LFN，则该项目将被视为没有LFN。 如果未启用LFN，则这些选项无效。</p> 
<h5><a id="FF_STRF_ENCODE_157"></a>FF_STRF_ENCODE</h5> 
<p>  当 API 上的字符编码为 Unicode（FF_LFN_UNICODE&gt; = 1）时，字符串 I/O 函数，f_gets，f_putc，f_puts和 f_printf 将转换其中的字符编码。 此选项定义了要通过这些函数读取/写入的文件的字符编码。 当LFN 未启用或 FF_LFN_UNICODE 为 0 时，字符串函数在没有任何编码转换的情况下工作，此选项无效。</p> 
<table><thead><tr><th>取值</th><th>文件字符编码</th></tr></thead><tbody><tr><td>0</td><td>ANSI/OEM in current code page</td></tr><tr><td>1</td><td>Unicode in UTF-16LE</td></tr><tr><td>2</td><td>Unicode in UTF-16BE</td></tr><tr><td>3</td><td>Unicode in UTF-8</td></tr></tbody></table> 
<h5><a id="FF_FS_RPATH_166"></a>FF_FS_RPATH</h5> 
<p>定义是否支持相对路径</p> 
<ul><li>0： 禁用。且相对路径相关的函数也被移除</li><li>1： 支持。f_chdir() 和 f_chdrive() 有效</li><li>2： 支持。除了提供 1 中的函数，还提供 f_getcwd()</li></ul> 
<h4><a id="VolumeDrive_Configurations__172"></a>Volume/Drive Configurations 驱动器/卷配置</h4> 
<h5><a id="FF_VOLUMES_173"></a>FF_VOLUMES</h5> 
<p>此选项配置要使用的卷数(逻辑驱动器最多10个)，最小值 1。</p> 
<h5><a id="FF_STR_VOLUME_ID_176"></a>FF_STR_VOLUME_ID</h5> 
<p>  此选项定义对字符串卷ID的支持。当为驱动器前缀启用任意卷ID字符串时，可以使用 FF_VOLUME_STRS 预定义的字符串或用户定义的字符串作为路径名称中的驱动器前缀。无论该选项是什么，数字驱动器号总是有效的，而且该选项还可以启用驱动器前缀的任何一种格式。</p> 
<table><thead><tr><th>取值</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>0</td><td>仅 DOS/Windows 风格的数字ID前缀可用</td><td>0:/filename</td></tr><tr><td>1</td><td>DOS/Windows 风格的字符串ID前缀也可用</td><td>flash:/filename</td></tr><tr><td>2</td><td>Unix 风格的字符串ID前缀也可用</td><td>/flash/filename</td></tr></tbody></table> 
<h5><a id="FF_VOLUME_STRS_185"></a>FF_VOLUME_STRS</h5> 
<p>  此选项定义每个逻辑驱动器的卷ID字符串。项目数不得少于FF_VOLUMES。 卷ID字符串的有效字符是A-Z，a-z和0-9，但是，它们在不区分大小写的情况下进行比较。<br>   如果 FF_STR_VOLUME_ID == 0，则此选项无效。 如果 FF_STR_VOLUME_ID &gt; = 1且未定义此选项，则需要定义用户定义的卷字符串表，如下所示。 该表不应动态修改。</p> 
<pre><code class="prism language-c"><span class="token comment">/* User defined volume ID strings for 0:    1:      2:    3:   ... */</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> VolumeStr<span class="token punctuation">[</span>FF_VOLUMES<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"ram"</span><span class="token punctuation">,</span><span class="token string">"flash"</span><span class="token punctuation">,</span><span class="token string">"sdc"</span><span class="token punctuation">,</span><span class="token string">"usb"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="FF_MULTI_PARTITION_193"></a>FF_MULTI_PARTITION</h5> 
<p>  禁用（0）或启用（1）。 此选项可切换多分区功能。 默认情况下（0），每个逻辑驱动器号绑定到相同的物理驱动器号，并且仅安装物理驱动器中的卷。 启用后，每个逻辑驱动器都绑定到用​​户定义的分区解析表 VolToPart [] 中列出的物理驱动器上的分区。 此外，还将提供 f_fdisk功能。</p> 
<h5><a id="FF_MIN_SS_FF_MAX_SS_196"></a>FF_MIN_SS, FF_MAX_SS</h5> 
<p>  这组选项定义了低级磁盘 I/O 接口，disk_read 和 disk_write函数使用的扇区大小范围。 有效值为 512、1024、2048 和 4096。FF_MIN_SS定义最小扇区大小，FF_MAX_SS 定义最大扇区大小。 始终为存储卡和硬盘设置 512。 但是，板载闪存和某些类型的光学介质可能需要更大的值。 当FF_MAX_SS &gt; FF_MIN_SS 时，启用对可变扇区大小的支持，并且需要对 disk_ioctl 函数实现 GET_SECTOR_SIZE 命令。</p> 
<h5><a id="FF_USE_TRIM_199"></a>FF_USE_TRIM</h5> 
<p>定义是否支持 ATA-TRIM</p> 
<ul><li>0： 禁止</li><li>1： 支持。此时，disk_ioctl() 函数需要实现 CTRL_TRIM 命令。</li></ul> 
<h5><a id="FF_FS_NOFSINFO_204"></a>FF_FS_NOFSINFO</h5> 
<p>  取值 0 到 3。如果您需要知道FAT32 卷上的正确可用空间，请设置此选项的第0位，并且在卷 mount 后第一时间执行 f_getfree函数，将强制进行完整的FAT扫描。 位1 控制最后分配的簇编号的使用。</p> 
<table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>bit0=0</td><td>Use free cluster count in the FSINFO if available.</td></tr><tr><td>bit0=1</td><td>Do not trust free cluster count in the FSINFO.</td></tr><tr><td>bit1=0</td><td>Use last allocated cluster number in the FSINFO to find a free cluster if available.</td></tr><tr><td>bit1=1</td><td>Do not trust last allocated cluster number in the FSINFO.</td></tr></tbody></table> 
<h4><a id="System_Configurations__213"></a>System Configurations （嵌入式）操作系统相关的配置</h4> 
<h5><a id="FF_FS_TINY_214"></a>FF_FS_TINY</h5> 
<p>  取值为 正常（0）或微小（1）。 在微小的配置中，文件对象 FIL 的大小减少了 FF_MAX_SS 字节。 不是从文件对象中消除私有数据缓冲区，而是将文件系统对象 FATFS 中的公共扇区缓冲区用于文件数据传输。</p> 
<h5><a id="FF_FS_EXFAT_217"></a>FF_FS_EXFAT</h5> 
<p>  此选项定义对 exFAT 文件系统的支持，Enabled（1）或 Disabled（0）。开启之后，将同时支持 exFAT、FAT/FAT32。要启用 exFAT，还必须启用LFN 并为全功能 exFAT 功能配置 FF_LFN_UNICODE&gt; = 1 和 FF_MAX_LFN == 255。 请注意，由于需要64位整数类型，启用 exFAT会丢弃ANSI C（C89）兼容性。</p> 
<h5><a id="FF_FS_NORTC_220"></a>FF_FS_NORTC</h5> 
<p>  此选项控制时间戳功能，0：使用RTC；1：不使用 RTC。 如果系统没有任何 RTC 功能或不需要有效时间戳，请将 FF_FS_NORTC 设置为1 以禁用时间戳功能。此时，FatFs 修改的每个对象都有一个由 FF_NORTC_MON，FF_NORTC_MDAY 和 FF_NORTC_YEAR 定义的固定时间戳。 要使用时间戳功能，请设置 FF_FS_NORTC == 0 并将 get_fattime 函数添加到项目中以从 RTC 获取当前时间。 此选项对只读配置无效。</p> 
<h5><a id="FF_NORTC_MON_FF_NORTC_MDAY_FF_NORTC_YEAR_223"></a>FF_NORTC_MON, FF_NORTC_MDAY, FF_NORTC_YEAR</h5> 
<p>这组选项定义了在无 RTC 系统中使用的时间。 此选项在只读配置或 FF_FS_NORTC == 0 时无效。</p> 
<h5><a id="FF_FS_LOCK_226"></a>FF_FS_LOCK</h5> 
<p>  选项切换文件锁定功能，以控制打开重复文件和打开对象的非法操作。 请注意，文件锁定功能独立于重入。 只读配置时，此选项必须为 0。</p> 
<table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>禁用文件锁定功能。 为避免文件操作错误导致文件崩溃，应用程序需要避免非法打开，删除和重命名为打开的对象。</td></tr><tr><td>&gt;0</td><td>启用文件锁定功能。 该值定义在文件锁定控制下可以同时打开多少文件/子目录。 使用FR_LOCKED将拒绝对打开对象的非法操作。</td></tr></tbody></table> 
<h5><a id="FF_FS_REENTRANT_234"></a>FF_FS_REENTRANT</h5> 
<p>  此选项可切换 FatFs 模块本身的重入（线程安全），取值为 禁用（0）或启用（1）。 请注意，对不同卷的文件/目录访问始终是可重入的，无论此选项如何，它都可以同时工作。但是，卷管理函数 f_mount，f_mkfs 和 f_fdisk 始终不可重入。<br>   只有文件/目录访问同一个卷，换句话说，独占使用每个文件系统对象，才能受此功能的控制。 要启用此功能，用户需要将 ffsystem.c 添加到自己的项目中，同时实现其中的同步处理程序 ff_req_grant，ff_rel_grant，ff_del_syncobj和ff_cre_syncobj。</p> 
<h5><a id="FF_FS_TIMEOUT_238"></a>FF_FS_TIMEOUT</h5> 
<p>  当等待时间太长时，使用 FF_FS_TIMEOUT中止文件功能的时间滴答数。 当 FF_FS_REENTRANT == 0 时，此选项无效。</p> 
<h5><a id="FF_SYNC_t_241"></a>FF_SYNC_t</h5> 
<p>  此选项定义 OS 相关的同步对象类型。 例如 HANDLE，ID，OS_EVENT *，SemaphoreHandle_t等。用于OS 定义的头文件需要包含在 ff.c范围内的某处。 当 FF_FS_REENTRANT == 0 时，此选项无效。</p> 
<h3><a id="ffch_244"></a>ff.c/h</h3> 
<p>  这两个文件是 FatFs 的核心源码文件。所有的 FatFs 的操作函数均位于这个了文件中。我们在使用时，使用的 API 也均是出自于这两个文件。<br>    其中各函数比较多，后续单独来介绍！</p> 
<h3><a id="ffsystemc_248"></a>ffsystem.c</h3> 
<p>  当使用了操作系统时，该文件必须要由用户来实现！源码包中的 <code>ffsystem.c</code> 给出了需要实现的各函数接口！用户需要根据自己使用的操作系统，修改其中的各接口的实现。<mark>注意：即使不使用系统，如果我们启用了长文件名，且长文件名的配置为 3，则也必须要实现以下两个动态内存申请函数！</mark> 下面我们看看该文件中的各个函数接口</p> 
<h4><a id="_251"></a>动态内存申请</h4> 
<p>  该文件中的第一部分函数就是动态内存申请接口。当然，其受制于在<code>ffconf.h</code>中的配置项<code>FF_USE_LFN</code>的限制。<em><strong>也就说，如果不使用长文件名，则 FatFs 不需要使用动态内存申请。</strong></em> 标准接口和标准C语言类似，就是名字稍有变化，有以下两个：</p> 
<ol><li><code>void* ff_memalloc (UINT msize);</code> 申请动态内存 
  <ol><li><code>msize：</code> 要申请的内存的大小</li><li><code>返回值：</code>成功，返回指向申请的内存的指针；失败返回空指针</li></ol> </li><li><code>void ff_memfree (void* mblock);</code> 释放之前申请的动态内存 
  <ol><li><code>mblock：</code> 之前申请的动态内存的指针</li><li><code>返回值：</code> 无</li></ol> </li></ol> 
<p>  为什么要自定义这两个函数？在使用了嵌入式操作系统之后，嵌入式操作系统一般都会提供对内存的管理功能。其一般也会重新定义动态内存的相关函数，而不是直接使用标准 C 语言定义的 <code>malloc</code> 和 <code>free</code> 函数。</p> 
<h4><a id="_262"></a>可重入性</h4> 
<p>  该文件中的第二部分函数是与系统紧密相关的相关的函数接口。这主要用来处理在多任务操作系统中，多线程操作相关的问题。在单线程进程（单任务）中，只存在一个控制流。因此，这些进程所执行的代码无需重入或着说是线程安全的。但是在多线程（多任务）程序中，相同的功能和资源可以通过多个控制流并发访问。<br>   FatFs 使用了同步对象（Synchronization Object）这个称呼，在实际系统中，通常为 信号量 或者 互斥量。当然，也不局限于这两种。<br>   以下为 FatFs 默认提供的示例代码。其中给出了常用的系统下的基本操作。如果使用其中的一种，则直接修改注释即可，否则，需要根据自己使用的系统来修改。</p> 
<h5><a id="_267"></a>创建同步对象</h5> 
<p>该函数在 <code>f_mount()</code> 函数中被调用，用来为指定的卷创建一个同步对象。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> ff_cre_syncobj <span class="token punctuation">(</span>	<span class="token comment">/* 1:成功, 0:失败 */</span>
	BYTE vol<span class="token punctuation">,</span>			<span class="token comment">/* 对应卷(逻辑驱动器号) */</span>
	FF_SYNC_t<span class="token operator">*</span> sobj		<span class="token comment">/* 返回创建的同步信号量的指针 */</span>
<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">/* Win32 */</span>
	<span class="token operator">*</span>sobj <span class="token operator">=</span> <span class="token function">CreateMutex</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> FALSE<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>sobj <span class="token operator">!=</span> INVALID_HANDLE_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* uITRON */</span>
<span class="token comment">//	T_CSEM csem = {TA_TPRI,1,1};</span>
<span class="token comment">//	*sobj = acre_sem(&amp;csem);</span>
<span class="token comment">//	return (int)(*sobj &gt; 0);</span>

	<span class="token comment">/* uC/OS-II */</span>
<span class="token comment">//	OS_ERR err;</span>
<span class="token comment">//	*sobj = OSMutexCreate(0, &amp;err);</span>
<span class="token comment">//	return (int)(err == OS_NO_ERR);</span>

	<span class="token comment">/* FreeRTOS */</span>
<span class="token comment">//	*sobj = xSemaphoreCreateMutex();</span>
<span class="token comment">//	return (int)(*sobj != NULL);</span>

	<span class="token comment">/* CMSIS-RTOS */</span>
<span class="token comment">//	*sobj = osMutexCreate(&amp;Mutex[vol]);</span>
<span class="token comment">//	return (int)(*sobj != NULL);</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_299"></a>删除同步对象</h5> 
<p>这个函数在<code>f mount()</code>函数中调用，以删除使用<code>ff_cre_syncobj ()</code>函数创建的同步对象。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> ff_del_syncobj <span class="token punctuation">(</span>	<span class="token comment">/* 返回值：1:成功, 0:删除失败 */</span>
	FF_SYNC_t sobj		<span class="token comment">/* 要删除的同步对象 */</span>
<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">/* Win32 */</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">CloseHandle</span><span class="token punctuation">(</span>sobj<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* uITRON */</span>
<span class="token comment">//	return (int)(del_sem(sobj) == E_OK);</span>

	<span class="token comment">/* uC/OS-II */</span>
<span class="token comment">//	OS_ERR err;</span>
<span class="token comment">//	OSMutexDel(sobj, OS_DEL_ALWAYS, &amp;err);</span>
<span class="token comment">//	return (int)(err == OS_NO_ERR);</span>

	<span class="token comment">/* FreeRTOS */</span>
<span class="token comment">//  vSemaphoreDelete(sobj);</span>
<span class="token comment">//	return 1;</span>

	<span class="token comment">/* CMSIS-RTOS */</span>
<span class="token comment">//	return (int)(osMutexDelete(sobj) == osOK);</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_326"></a>锁定卷</h5> 
<p>此函数在输入文件函数时调用，以锁定卷。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> ff_req_grant <span class="token punctuation">(</span>	<span class="token comment">/* 返回值：1:获取锁定许可, 0:失败 */</span>
	FF_SYNC_t sobj	<span class="token comment">/* Sync object to wait */</span>
<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">/* Win32 */</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">WaitForSingleObject</span><span class="token punctuation">(</span>sobj<span class="token punctuation">,</span> FF_FS_TIMEOUT<span class="token punctuation">)</span> <span class="token operator">==</span> WAIT_OBJECT_0<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* uITRON */</span>
<span class="token comment">//	return (int)(wai_sem(sobj) == E_OK);</span>

	<span class="token comment">/* uC/OS-II */</span>
<span class="token comment">//	OS_ERR err;</span>
<span class="token comment">//	OSMutexPend(sobj, FF_FS_TIMEOUT, &amp;err));</span>
<span class="token comment">//	return (int)(err == OS_NO_ERR);</span>

	<span class="token comment">/* FreeRTOS */</span>
<span class="token comment">//	return (int)(xSemaphoreTake(sobj, FF_FS_TIMEOUT) == pdTRUE);</span>

	<span class="token comment">/* CMSIS-RTOS */</span>
<span class="token comment">//	return (int)(osMutexWait(sobj, FF_FS_TIMEOUT) == osOK);</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_352"></a>释放卷</h5> 
<p>此函数在离开文件函数以解锁卷时调用。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> ff_rel_grant <span class="token punctuation">(</span>
	FF_SYNC_t sobj	<span class="token comment">/* Sync object to be signaled */</span>
<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">/* Win32 */</span>
	<span class="token function">ReleaseMutex</span><span class="token punctuation">(</span>sobj<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* uITRON */</span>
<span class="token comment">//	sig_sem(sobj);</span>

	<span class="token comment">/* uC/OS-II */</span>
<span class="token comment">//	OSMutexPost(sobj);</span>

	<span class="token comment">/* FreeRTOS */</span>
<span class="token comment">//	xSemaphoreGive(sobj);</span>

	<span class="token comment">/* CMSIS-RTOS */</span>
<span class="token comment">//	osMutexRelease(sobj);</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="ffunicodec_376"></a>ffunicode.c</h3> 
<p>  该文件很大，用来处理 Unicode 编码相关的功能。如果在以上配置中，启用了相关功能，则需要将该文件添加到自己的项目中。用户无需修改其中的任何内容。所有函数均由 FatFs 调用！<br>    FatFs 建议，如果系统中存在 Unicode 相关的处理函数，则应该以系统自带的为准，尽量减少对该文件的使用即可！</p> 
<h3><a id="diskioch_380"></a>diskio.c/h</h3> 
<p>  由于 FatFs 模块是独立于平台和存储介质的文件系统层，因此它与物理设备（例如存储卡，硬盘和任何类型的存储设备）完全分离。 低级设备控制模块不是 FatFs 模块的一部分，需要由使用者提供。<br>   <code>diskio.c/h</code> 这两个文件用于实现 FatFs 与硬件的交互。其中定义了 FatFs 与硬件交互使用的接口。FatFs 中的这两个文件仅仅是个模板，用户需要根据需要来实现其中的各接口，并不能直接使用！其中：</p> 
<ul><li><strong>diskio.h：</strong> 其中声明了各接口的形式以及一些 FatFs 使用的宏，用户不得更改！<code>ff.c</code> 直接包含该头文件，并使用该文件中定义的一些内容！</li><li><strong>diskio.c：</strong> 其中存放了需要用户实现的各接口！用户需要根据自己的硬件平台（RAM、MMC、USB等）以及 <code>ffcong.h</code>中的配置（例如，配置项 FF_USE_TRIM定义为 1，则需要在 disk_ioctl() 函数中实现对 CTRL_TRIM 命令的处理）</li></ul> 
<p>  一般的使用了 FatFs 的第三方库，都会提供该文件的实现！我们可以参考。例如，在 STM32 的USB 驱动库中，有个名为 <code>usbh_msc_fatfs.c</code> 的文件，它其实就是 <code>diskio.c</code> 改了个名字而已。里面的函数就是 <code>diskio.h</code> 所声明的那些函数！也因此在使用 STM32 的USB 驱动库 + FatFs 时，我们不再需要 <code>diskio.c</code>了，但是 <code>diskio.h</code> 仍然是必须的！<br> 下面我们来看看具体的各函数</p> 
<h4><a id="DSTATUS_disk_status_BYTE_pdrv_389"></a>DSTATUS disk_status (BYTE pdrv);</h4> 
<p>FatFs 调用此函数，查询当前驱动器状态</p> 
<ul><li>参数： 
  <ul><li>pdrv：用于标识目标设备的物理驱动器号。 单驱动系统始终为零。</li></ul> </li><li>返回值：当前驱动器状态以下面描述的状态标志的<strong>组合返回</strong>（状态宏值是按位定义并使用的，具体见 <code>diskio.h</code>）。 FatFs 仅使用了 STA_NOINIT 和 STA_PROTECT 这两个。 
  <ul><li>STA_NOINIT：表示设备尚未初始化且未准备好工作。 此标志在系统重置，介质删除或 disk_initialize 功能失败时设置。 在disk_initialize函数成功后清除它。 必须捕获异步发生的任何介质更改并将其反映到状态标志，否则自动安装功能将无法正常工作。 如果系统不支持介质更改检测，则应用程序需要在每次更改介质后使用 f_mount 函数显式重新装入卷。</li><li>STA_NODISK：表示驱动器中没有介质。 在固定磁盘驱动器上清除这项始终被清除。 请注意，FatFs 不会使用此标志。</li><li>STA_PROTECT：表示介质受写保护。 在没有写保护功能的驱动器上始终清除此值。 如果设置了STA_NODISK，则此项无效。</li></ul> </li></ul> 
<h4><a id="DSTATUS_disk_initialize_BYTE_pdrv_398"></a>DSTATUS disk_initialize (BYTE pdrv);</h4> 
<p>FatFs 调用此函数，以初始化存储设备</p> 
<ul><li>参数： 
  <ul><li>pdrv：用于标识目标设备的物理驱动器号。 单驱动系统始终为零。</li></ul> </li><li>返回值：与 disk_status 的返回值相同！</li></ul> 
<p>此函数初始化存储设备并使其准备好进行通用读/写。 当函数成功时，返回值中的STA_NOINIT标志被清除。此功能需要受FatFs模块的控制。 应用程序不得调用此函数，否则可能会破坏卷上的FAT结构。 要重新初始化文件系统，请改用f_mount函数。</p> 
<h4><a id="DRESULT_disk_read_BYTE_pdrv_BYTE_buff_DWORD_sector_UINT_count_406"></a>DRESULT disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);</h4> 
<p>FatFs 调用此函数，以从存储设备的扇区读取数据</p> 
<ul><li>参数： 
  <ul><li>pdrv：用于标识目标设备的物理驱动器号。</li><li>buff：指向存储读取数据的字节数组的第一项的指针。 读取数据的大小将是扇区大小*计数字节。</li><li>sector：32 位 LBA（Logical Block Address，逻辑区块地址） 的开始扇区号。</li><li>count：要读取的扇区数。</li></ul> </li><li>返回值： 
  <ul><li>RES_OK：成功</li><li>RES_ERROR：在读取操作期间发生了不可恢复的硬错误。</li><li>RES_PARERR：无效的参数</li><li>RES_NOTRDY：设备尚未初始化。</li></ul> </li></ul> 
<p>  对通用存储设备（例如存储卡，hadddisk和光盘）的读/写操作是以称为扇区的数据字节块为单位完成的。 FatFs支持512到4096字节范围内的扇区大小。 当FatF配置为固定扇区大小（FF_MIN_SS == FF_MAX_SS，这是大多数情况）时，读/写功能必须以该扇区大小工作。 当FatFs配置为可变扇区大小（FF_MIN_SS &lt;FF_MAX_SS）时，在disk_initialize函数成功后立即使用disk_ioctl函数查询media的扇区大小。<br>   buff 指定的内存地址并不总是与字边界对齐，因为参数定义为BYTE* 类型。 未对齐的读/写请求可以在直接传输时发生。 如果总线体系结构（尤其是DMA控制器）不允许未对齐的内存访问，则应在此函数中处理该问题。 下面介绍了一些解决方法以避免此问题。</p> 
<ul><li>在此函数中使用某些方法将字转换为字节来进行传输。</li><li>在 f_read() 调用中，避免包含整个扇区的长读取请求。 - 任何直接传输都不会发生。</li><li>在 f_read(fp, dat, btw, bw) 调用中，确保 (((UINT)dat &amp; 3) == (f_tell(fp) &amp; 3)) 为真。 - 保证了 buff 的字对齐。</li></ul> 
<p>此外，DMA 可能无法访问内存区域。如果内存区域位于通常用于堆栈的紧密耦合的内存中，情况就是这样。使用双缓冲传输，或者避免将任何文件 I/O 缓冲区、FATFS 和 FIL 结构定义为堆栈中的局部变量。<br> 通常，多扇区读请求不能被分割成对存储设备的单扇区事务，否则读吞吐量会变得更差。</p> 
<h4><a id="DRESULT_disk_write_BYTE_pdrv_BYTE_buff_DWORD_sector_UINT_count_428"></a>DRESULT disk_write (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);</h4> 
<p>FatFs 调用此函数，将数据写入存储设备的扇区</p> 
<ul><li>参数： 
  <ul><li>pdrv：用于标识目标设备的物理驱动器号。</li><li>buff：指向要写入的字节数组的第一项的指针。 要写入的数据大小是扇区大小*计数字节。</li><li>sector：32 位 LBA（Logical Block Address，逻辑区块地址） 的开始扇区号。</li><li>count：要写的扇区数。</li></ul> </li><li>返回值： 
  <ul><li>RES_OK：成功</li><li>RES_ERROR：在写入操作期间发生了不可恢复的硬错误。</li><li>RES_WRPRT：介质是写保护的</li><li>RES_PARERR：无效的参数</li><li>RES_NOTRDY：设备尚未初始化。</li></ul> </li></ul> 
<p>  指定的内存地址并不总是与字边界对齐，因为参数定义为 BYTE*。 有关更多信息，请参阅 disk_read 函数的说明。<br>   通常，多扇区写请求（计数&gt; 1）不得拆分为存储设备的单扇区事务，否则文件写吞吐量将大幅降低。<br>   FatFs期望磁盘控制层的写入功能延迟。 该函数返回后，写操作可能并没有完成，因为媒体介质可能正在执行写操作或者 仅仅是将数据放到了媒体介质的缓冲区中。但是从此函数返回后，buff 中的数据将无效。 写完成请求由 disk_ioctl 函数的 CTRL_SYNC 命令完成。 因此，如果实现延迟写入功能，则将改善文件系统的写入吞吐量。</p> 
<h4><a id="DRESULT_disk_ioctl_BYTE_pdrv_BYTE_cmd_void_buff_446"></a>DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);</h4> 
<p>FatFs 调用此函数，来控制设备特定的功能和除通用读/写之外的其他功能。</p> 
<ul><li>参数： 
  <ul><li>pdrv：用于标识目标设备的物理驱动器号。</li><li>cmd：命令代码，在 diskio.h 中有定义。</li><li>buff：指向参数的指针，是否有意义取决于命令代码。 如果命令代码不需要传递该参数，则忽略即可。</li></ul> </li><li>返回值： 
  <ul><li>RES_OK (0)：成功</li><li>RES_ERROR：出错</li><li>RES_PARERR：命令代码或参数无效。</li><li>RES_NOTRDY：设备尚未初始化。</li></ul> </li></ul> 
<p>FatFs模块仅需要五个与设备无关的命令，如下所述：</p> 
<table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>CTRL_SYNC</td><td>用来确保设备已完成了挂起的写入过程。 如果磁盘 I/O 模块或存储设备具有回写高速缓存，则必须立即将标记为脏的高速缓存数据写回介质。 如果在 disk_write 函数内完成对介质的每个写操作，此命令中无需任何处理。</td></tr><tr><td>GET_SECTOR_COUNT</td><td>将驱动器上的可用扇区数返回到 buff 指向的 DWORD 类型的变量中。 f_mkfs 和 f_fdisk 函数使用此命令来确定要创建的卷/分区大小。 在配置了 FF_USE_MKFS == 1 时，必须要实现对该名利的处理。</td></tr><tr><td>GET_SECTOR_SIZE</td><td>将设备的扇区大小返回到 buff 指向的 WORD 类型的变量中。 此命令的有效返回值为 512,1024,2048和4096. 仅当FF_MAX_SS &gt; FF_MIN_SS 时才需要此命令。 当 FF_MAX_SS == FF_MIN_SS 时，从不使用此命令，并且设备必须以该扇区大小工作。</td></tr><tr><td>GET_BLOCK_SIZE</td><td>将以扇区为单位将闪存介质的擦除块大小返回到 buff 指向的 DWORD 类型的变量中。 允许值为 1 到 32768的 2 次方。如果擦除块大小未知或非闪存介质，则返回1。 该命令仅由 f_mkfs 函数使用，它尝试对齐擦除块边界上的数据区域。 在FF_USE_MKFS == 1 时 必须实现对改命令的处理</td></tr><tr><td>CTRL_TRIM</td><td>通知设备不再需要扇区块上的数据，并且可以擦除它。 扇区块由 buff 指向的DWORD数组 {，} 指定。 这是一个与 ATA 设备修剪完全相同的命令。 如果不支持此功能或闪存设备不支持此命令，则无需执行此操作。 FatFs 不检查结果代码，即使扇区块没有被很好地擦除，文件功能也不会受到影响。 该命令在删除簇和 在 f_mkfs 函数中被调用。 在 FF_USE_TRIM == 1 时必须实现对改命令的处理</td></tr></tbody></table> 
<p>FatFs从不使用任何依赖于设备的命令或用户定义的命令。下表显示了一个可能对某些应用程序有用的非标准命令示例。</p> 
<table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>CTRL_FORMAT</td><td>在媒体上创建物理格式。 如果 buff 不为 null，则它是指向进度通知的回调函数的指针。</td></tr><tr><td>CTRL_POWER_IDLE</td><td>将设备置于空闲状态。 如果设备通过通用读/写功能进入活动状态，则可能不会设置当前状态标志中的STA_NOINIT。</td></tr><tr><td>CTRL_POWER_OFF</td><td>将设备置为关闭状态。 如果需要，关闭设备电源并取消初始化设备接口。 必须设置当前状态标志中的STA_NOINIT。 设备通过disk_initialize功能进入活动状态。</td></tr><tr><td>CTRL_LOCK</td><td>锁定介质弹出机制。</td></tr><tr><td>CTRL_UNLOCK</td><td>解锁媒体弹出机制。</td></tr><tr><td>CTRL_EJECT</td><td>弹出介质盒。 功能成功后，将设置状态标志中的STA_NOINIT和STA_NODISK。</td></tr><tr><td>CTRL_GET_SMART</td><td>阅读SMART信息。</td></tr><tr><td>MMC_GET_TYPE</td><td>获取卡类型。 类型标志bit0：MMCv3，bit1：SDv1，bit2：SDv2 +和bit3：LBA存储在buff指向的BYTE变量中。 （MMC / SDC特定命令）</td></tr><tr><td>MMC_GET_CSD</td><td>将CSD寄存器读入buff指向的16字节缓冲区。 （MMC / SDC特定命令）</td></tr><tr><td>MMC_GET_CID</td><td>将CID寄存器读入buff指向的16字节缓冲区。 （MMC / SDC特定命令）</td></tr><tr><td>MMC_GET_OCR</td><td>将OCR寄存器读入buff指向的4字节缓冲区。 （MMC / SDC特定命令）</td></tr><tr><td>MMC_GET_SDSTAT</td><td>将SDSTATUS寄存器读入buff指向的64字节缓冲区。 （SDC特定命令）</td></tr><tr><td>ATA_GET_REV</td><td>将修订字符串转换为buff指向的16字节缓冲区。 （ATA / CFC特定命令）</td></tr><tr><td>ATA_GET_MODEL</td><td>将模型字符串放入buff指向的40字节缓冲区中。 （ATA / CFC特定命令）</td></tr><tr><td>ATA_GET_SN</td><td>将序列号字符串放入buff指向的20字节缓冲区中。 （ATA / CFC特定命令）</td></tr><tr><td>ISDIO_READ</td><td>读取由buff指向的命令结构指定的iSDIO寄存器块。 （FlashAir特定命令）</td></tr><tr><td>ISDIO_WRITE</td><td>将数据块写入由buff指向的命令结构指定的iSDIO寄存器。 （FlashAir特定命令）</td></tr><tr><td>ISDIO_MRITE</td><td>更改由buff指向的命令结构指定的iSDIO寄存器中的位。 （FlashAir特定命令）</td></tr></tbody></table> 
<h2><a id="_489"></a>移植说明</h2> 
<h3><a id="_490"></a>第一步：源码文件整理</h3> 
<p>  根据上面的介绍，其中，<code>ff.c</code>、<code>ff.h</code>、<code>ffconf.h</code>、<code>diskio.c</code>、<code>diskio.h</code> 这六个文件是最基本的，必须要包含在我们的项目中！除此之外，根据自己的配置：</p> 
<ul><li>如果需要 FatFs 支持可重入， 则 必须要包含 <code>ffsystem.c</code>, 且必须实现 <code>ffsystem.c</code> 中的 ff_req_grant(), ff_rel_grant(), ff_del_syncobj() 和 ff_cre_syncobj() 这四个函数！</li><li>如果需要 FatFs 支持长文件名，则必须要包含 <code>ffunicode.c</code>，如果配置长文件名模式为 3 （FF_USE_LFN == 3），则必须同时包含 <code>ffsystem.c</code>, 且必须实现 <code>ffsystem.c</code> 中的 ff_memalloc() 和 ff_memfree() 这两个函数。</li></ul> 
<h3><a id="_495"></a>第二步：修改配置</h3> 
<p>  根据自己的需要修改 <code>ffconf.h</code> 中的各个配置项！</p> 
<h3><a id="_498"></a>第三步：实现必要的函数</h3> 
<p>  首先要实现 diskio.c/h 其中各接口！需要注意的是，一般的使用了 FatFs 的第三方库，都会提供该文件的实现！例如，在 STM32 的USB 驱动库中，有个名为 <code>usbh_msc_fatfs.c</code> 的文件，它其实就是 <code>diskio.c</code> 改了个名字而已。里面的函数就是 <code>diskio.h</code> 所声明的那些函数！也因此在使用 STM32 的USB 驱动库 + FatFs 时，我们不再需要 <code>diskio.c</code>了，但是 <code>diskio.h</code> 仍然是必须的！<br> 下表显示了需要实现的函数（部分需要看自己在<code>ffconf.h</code> 的配置）：<br> <img src="https://images2.imgbox.com/dc/75/TYDNpfk0_o.png" alt="在这里插入图片描述"><br> 在 FatFs 源码的 <code>diskio.c</code> 中给出的示例是以默认的配置来说的，在 <code>ffconf.h</code> 中，有如下配置：</p> 
<pre><code class="prism language-c"><span class="token comment">/*---------------------------------------------------------------------------/
/ Drive/Volume Configurations     驱动器/卷配置
/---------------------------------------------------------------------------*/</span>

<span class="token comment">/* 要使用的卷（逻辑驱动器）数。 取值 1 ~ 10
 */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> FF_VOLUMES		1</span>
<span class="token comment">/* Number of volumes (logical drives) to be used. (1-10) */</span>


<span class="token comment">/* 这两个宏值用来给每个卷定义一个名字
 *  0： 不启用卷名字，默认值
 *  1 或 2： 对应的卷名由 FF_VOLUME_STRS 给出。 FF_VOLUME_STRS 的个数必须小于 FF_VOLUMES。
 *  名字的规则为  A-Z, a-z and 0-9 组合，且字母开头。不区分大小写！
 *  如果定义为了 &gt;= 1 但是没有定义 FF_VOLUME_STRS，则 用户必须自己定义 const char* VolumeStr[FF_VOLUMES] = {"ram","flash","sd","usb",...
 *  
 *  在 ff.c 中，我们可以发现如下语句：
 *  #if FF_STR_VOLUME_ID
 *  #ifdef FF_VOLUME_STRS
 *  static const char* const VolumeStr[FF_VOLUMES] = {FF_VOLUME_STRS};
 *  #endif
 *  #endif
 */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> FF_STR_VOLUME_ID	0</span>
<span class="token macro property">#<span class="token directive keyword">define</span> FF_VOLUME_STRS		"RAM","NAND","CF","SD","SD2","USB","USB2","USB3"</span>
<span class="token comment">/* FF_STR_VOLUME_ID switches support for volume ID in arbitrary strings.
/  When FF_STR_VOLUME_ID is set to 1 or 2, arbitrary strings can be used as drive
/  number in the path name. FF_VOLUME_STRS defines the volume ID strings for each
/  logical drives. Number of items must not be less than FF_VOLUMES. Valid
/  characters for the volume ID strings are A-Z, a-z and 0-9, however, they are
/  compared in case-insensitive. If FF_STR_VOLUME_ID &gt;= 1 and FF_VOLUME_STRS is
/  not defined, a user defined volume string table needs to be defined as:
/
/  const char* VolumeStr[FF_VOLUMES] = {"ram","flash","sd","usb",...
*/</span>
</code></pre> 
<p>我们必须根据自己的需求来更改。结合上文对于这个文件中每个函数的说明来实现即可！</p> 
<h3><a id="_get_fattime_542"></a>第四步：实现 get_fattime</h3> 
<p>  如果在 <code>ffconf.h</code> 中配置了 FF_FS_NORTC == 0，则必须自己实现函数 <code>DWORD get_fattime (void);</code> 该函数返回一个 4 字节的时间戳！例如在上面的 STM32 的 USB 中，在 <code>usbh_msc_fatfs.c</code> 中 有 该函数的实现，但是默认为空（根据配置，用户需要修改该函数实现）！<br>   如果在 <code>ffconf.h</code> 中配置了 FF_FS_NORTC == 1，则可省略该函数的实现！具体见上文的说明即可！</p> 
<p>该函数的格式：<code>DWORD get_fattime (void);</code></p> 
<ul><li>参数： 
  <ul><li>无</li></ul> </li><li>返回值：当前本地时间应作为包含在DWORD值中的位字段返回。 位字段如下： 
  <ul><li>bit31:25：从 1980 年开始的年份 ，取值 0 ~ 127。例如 37 for 2017)</li><li>bit24:21：月份(1…12)</li><li>bit20:16：日期 (1…31)</li><li>bit15:11：小时(0…23)</li><li>bit10:5：分钟 (0…59)</li><li>bit4:0：秒 / 2 ( 0…29, e.g. 25 for 50)</li></ul> </li></ul> 
<h3><a id="_557"></a>第五步：应用层使用</h3> 
<p>  经过以上四步之后，就可以在项目中使用 FatFs了。可用的接口全部在于 <code>ff.h</code> 中，其与标准 C 语言中各函数用法基本一致！</p> 
<h3><a id="error__20_identifier_BYTE_is_undefined_560"></a>error: #20: identifier “BYTE” is undefined</h3> 
<p>  这个问题应该是是由于没有正确包含头文件导致的。在 R0.13c 的时候，作者更新： <code>Supported stdint.h for C99 and later. (integer.h was included in ff.h)</code>，然后删除了原来的 <code>integer.h</code>。这样，<code>diskio.h</code> 中也删除了对于该文件的包含。这样就导致了 <code>diskio.h</code> 中某些数据类型未定义！如下图：<br> <img src="https://images2.imgbox.com/47/e2/JZAfeDWH_o.png" alt="在这里插入图片描述"><br> 解决方法就是在 <code>diskio.h</code> 中包含数据类型的定义文件。根据 <code>00history.txt</code> 中的更新说明，现在的数据类型定义就在 <code>ff.h</code> 中。</p> 
<h2><a id="_565"></a>参考</h2> 
<ol><li>ST 官网</li><li>FatFs 官网</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54ed046096d01d5067f580cd461c1f1c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">内存图片二进制数据直接转为 OpenCV 数据格式的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/528aa82d3c4ba4ac50216f30b81cedcd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">论文投稿系列之Cover Letter写法（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>