<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>读懂Java中的各种锁，看这一篇就足够了 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="读懂Java中的各种锁，看这一篇就足够了" />
<meta property="og:description" content="源码版本：JDK 8
前言
Java 中提供了种类丰富的锁，每种锁因有不同的特性在不同的场景能够展现出较高的性能，本文在概念的基础上结合源码 &#43; 使用场景进行举例，让读者对 Java 中的锁有更加深刻的认识，Java 中按照是否包含某一特性来定义锁，下面是本文中介绍的锁的分类图：
乐观锁 &amp; 悲观锁
乐观锁和悲观锁是一种广义上的概念，体现了线程对互斥资源进行同步的两种不同的态度，在 Java 和数据中都有实际的运用。
概念
对一个互斥资源的同步操作，悲观锁认为自己访问时，一定有其它线程来修改，因此在访问互斥资源时悲观锁会先加锁；而乐观锁认为自己在访问时不会有其它线程来修改，访问时不加锁，而是在更新数据时去判断有无被其他线程修改，若没被修改则写入成功，若被其他线程修改则进行重试或报错。
适应场景
由上面我们可以看出，乐观锁适用于读操作多的场景，而悲观锁适用于写操作多的场景。
源码分析
我们常见的synchronized、ReentrantLock 都属于悲观锁，而AtomicInteger.incrementAndGet 则属于乐观锁。
// ----------------- 悲观锁 -------------------------
synchronized (MUTEX) {
// 同步代码块
}
ReentrantLock lock = new ReentrantLock();
lock.lock();
// 同步代码块
lock.unlock();
// ----------------- 乐观锁 -------------------------
AtomicInteger atomicInteger = new AtomicInteger(0);
atomicInteger.incrementAndGet();
悲观锁的实现方式很直观，先进行加锁，然后访问互斥资源，最后释放锁；那么乐观锁时如何实现的呢？我们通过介绍乐观锁主要的实现方式 CAS 来为大家解惑。
这里简单给大家回顾一下 CAS 。
CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的同步。
CAS算法涉及到三个操作数：当前内存值 V、原始值 A、要写入的新值 B。
当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较&#43;更新”整体是一个原子操作），否则不会执行任何操作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/631a3c1610c0209dcd069c9710f34301/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-03T07:55:51+08:00" />
<meta property="article:modified_time" content="2023-11-03T07:55:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">读懂Java中的各种锁，看这一篇就足够了</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>源码版本：JDK 8</p> 
<p><br> 前言</p> 
<p>Java 中提供了种类丰富的锁，每种锁因有不同的特性在不同的场景能够展现出较高的性能，本文在概念的基础上结合源码 + 使用场景进行举例，让读者对 Java 中的锁有更加深刻的认识，Java 中按照是否包含某一特性来定义锁，下面是本文中介绍的锁的分类图：</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/01/f1/Z8yaMani_o.png" alt="5fb1beaf0fef4ce2a5ef0508009bd105.png"> </p> 
<p>乐观锁 &amp; 悲观锁</p> 
<p>乐观锁和悲观锁是一种广义上的概念，体现了线程对互斥资源进行同步的两种不同的态度，在 Java 和数据中都有实际的运用。<br> 概念</p> 
<p>对一个互斥资源的同步操作，悲观锁认为自己访问时，一定有其它线程来修改，因此在访问互斥资源时悲观锁会先加锁；而乐观锁认为自己在访问时不会有其它线程来修改，访问时不加锁，而是在更新数据时去判断有无被其他线程修改，若没被修改则写入成功，若被其他线程修改则进行重试或报错。</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/7e/77/L54iqs2T_o.png" alt="e28d7e599cfc4222834138a945ea622a.png"> </p> 
<p>适应场景</p> 
<p>由上面我们可以看出，乐观锁适用于读操作多的场景，而悲观锁适用于写操作多的场景。<br> 源码分析</p> 
<p>我们常见的synchronized、ReentrantLock 都属于悲观锁，而AtomicInteger.incrementAndGet 则属于乐观锁。<br>  // ----------------- 悲观锁 -------------------------<br>         synchronized (MUTEX) {<!-- --><br>             // 同步代码块<br>         }</p> 
<p>        ReentrantLock lock = new ReentrantLock();<br>         lock.lock();<br>         // 同步代码块<br>         lock.unlock();</p> 
<p> // ----------------- 乐观锁 -------------------------</p> 
<p>        AtomicInteger atomicInteger = new AtomicInteger(0);<br>         atomicInteger.incrementAndGet();</p> 
<p>悲观锁的实现方式很直观，先进行加锁，然后访问互斥资源，最后释放锁；那么乐观锁时如何实现的呢？我们通过介绍乐观锁主要的实现方式 CAS 来为大家解惑。</p> 
<p>这里简单给大家回顾一下 CAS 。</p> 
<p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的同步。<br> CAS算法涉及到三个操作数：当前内存值 V、原始值 A、要写入的新值 B。<br> 当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。</p> 
<p>//  atomicInteger.incrementAndGet() 使用上述方式实现：</p> 
<p>    public final int getAndAddInt(Object o, long offset, int delta) {<!-- --><br>         int v;<br>         do {<!-- --><br>             // v 表示获取到的内存中的当前值<br>             v = getIntVolatile(o, offset);<br>         // compareAndSwapInt() 是一个原子操作、进行比较更新<br>         } while (!compareAndSwapInt(o, offset, v, v + delta));<br>         return v;<br>     }<br> 阻塞 &amp; 非阻塞</p> 
<p>了解阻塞和非阻塞前，大家需要知道唤醒和阻塞一个Java线程需要操作系统进行用户态到内核态的切换，这种切换是十分耗时处理器时间的，如果同步代码块的内容过于简单，状态转换消耗的时间可能比用户代码执行时间还长，这是十分不划算的，因此我们引入了非阻塞的概念。<br> 概念</p> 
<p>从上面的介绍中我们其实已经可以了解到阻塞和非阻塞的概念。++多线程访问互斥资源时，当互斥资源已被占用，阻塞线程，当互斥释放时，唤醒线程进行竞争称为阻塞式同步；而当互斥资源被占用时，不进行线程阻塞而通过自旋等待其它线程释放锁或直接返回错误的方式称为非阻塞式同步，自旋方式又可以分为普通自旋和自适应自旋++。</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/08/8e/FK6E91iI_o.png" alt="2c3558fd40bb45bc8c9ac41462d62ac7.png"> </p> 
<p>使用场景</p> 
<p>非阻塞自旋的方式本身是有缺点的，不能完全代替阻塞同步，非阻塞自旋虽然避免了线程切换的开销但是会占用处理器的时间，如果锁被占用的时间很短，那么自旋等待的效果很好，如果锁被占用时间很长那么只会白白浪费处理器时间。所以自旋一般会设置一定限制，比如Java中默认是10次（使用-XX:PreBlockSpin来修改）。<br> 自适应自旋意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。<br> 因此，阻塞式同步适用于同步代码块执行时间比较长，线程获取锁时间间隔比较长的场景，而非阻塞式同步适用于同步代码块执行比较短，线程获取锁时间间隔比较短的场景。<br> 源码分析</p> 
<p>ReentrantLock以及synchronized中的重量级锁都属于阻塞式同步，而 Java 中的原子操作类中的 CAS 则运用了非阻塞自旋的思想。<br> 公平锁 &amp; 非公平锁</p> 
<p>概念</p> 
<p>公平锁和非公平锁指的是获取线程获取锁时的顺序。公平锁指按照锁申请的顺序来获取锁，线程直接进入队列中，队列中的第一个线程才能获取锁。非公平锁指多个线程获取锁时，直接尝试获取锁，只有当线程未获取到锁时才放入队列中。</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/a7/c0/s0wee7eZ_o.png" alt="f5b39295a9ec46468199c578cdeec615.png"> </p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/4b/87/dl2RK2ZJ_o.png" alt="cfcfa793f3d245aeb128f61bf5676afc.png"> </p> 
<p>适应场景</p> 
<p>公平锁的优点是不会造成饥饿，但整体性能会比非公平锁低，因为除等待队列中的第一个线程，其它线程都需要进行阻塞和唤醒操作。而非公平锁有几率直接获得锁，减少了线程阻塞和唤醒的次数，但可能会造成饥饿。因此在饥饿无影响或不会产生饥饿的场景下优先考虑非公平锁。<br> 源码分析</p> 
<p>ReentrantLock 提供了公平锁和非公平锁两种实现，默认使用非公平锁。<br> 非公平锁</p> 
<p>    final void lock() {<!-- --><br>         // 多次尝试获取锁，避免将线程阻塞再唤醒<br>         if (compareAndSetState(0, 1))</p> 
<p>setExclusiveOwnerThread(Thread.currentThread());<br>          else<br>             acquire(1);<br>     }<br>     <br>     public final void acquire(int arg) {<!-- --><br>         // 尝试获取锁失败后再放入等待队列<br>         if (!tryAcquire(arg) &amp;&amp;<br>             acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>             selfInterrupt();<br>     }</p> 
<p>    protected final boolean tryAcquire(int acquires) {<!-- --><br>         return nonfairTryAcquire(acquires);<br>     }<br>     <br>     final boolean nonfairTryAcquire(int acquires) {<!-- --><br>         final Thread current = Thread.currentThread();<br>         int c = getState();<br>         if (c == 0) {<!-- --><br>         // 重点：不判断队列中是否有排队线程直接获取锁<br>         if (compareAndSetState(0, acquires)) {            <br>             setExclusiveOwnerThread(current);<br>             return true;<br>             }<br>         }<br>         else if (current == getExclusiveOwnerThread()) {<!-- --><br>             int nextc = c + acquires;<br>             if (nextc &lt; 0) // overflow<br>                 throw new Error("Maximum lock count exceeded");<br>             setState(nextc);<br>             return true;<br>             }<br>         return false;<br>     }<br> 我们可以注意到非公平锁实现中两次尝试使用compareAndSetState()来获取锁，其实这里就是类似自旋的作用，避免线程阻塞再唤醒的过程，从而提高性能。<br> 公平锁</p> 
<p>    final void lock() {<!-- --><br>         acquire(1);<br>     }<br>         <br>     public final void acquire(int arg) {<!-- --><br>         if (!tryAcquire(arg) &amp;&amp;<br>             acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>             selfInterrupt();<br>     }</p> 
<p>    protected final boolean tryAcquire(int acquires) {<!-- --><br>         final Thread current = Thread.currentThread();<br>         int c = getState();<br>         if (c == 0) {<!-- --><br>         // 重点：当互斥资源未被占用时，先判断队列中是否存在等待线程，若无尝试竞争锁，若有或竞争失败则将当前线程放入队列中<br>         if (!hasQueuedPredecessors() &amp;&amp;<br>             compareAndSetState(0, acquires)) {<!-- --><br>              setExclusiveOwnerThread(current);<br>              return true;<br>             }<br>         }else if (current == getExclusiveOwnerThread()) {<!-- --><br>             int nextc = c + acquires;<br>             if (nextc &lt; 0)<br>                 throw new Error("Maximum lock count exceeded");<br>             setState(nextc);<br>             return true;<br>             }<br>             return false;<br>         }<br>     }<br>     <br>     // 判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。<br>     public final boolean hasQueuedPredecessors() {<!-- --><br>         // The correctness of this depends on head being initialized<br>         // before tail and on head.next being accurate if the current<br>         // thread is first in queue.<br>         Node t = tail; // Read fields in reverse initialization order<br>         Node h = head;<br>         Node s;<br>         return h != t &amp;&amp;<br>             ((s = h.next) == null || s.thread != Thread.currentThread());<br>     }<br> 可重入锁 &amp; 不可重入锁</p> 
<p>概念</p> 
<p>可重入锁又称递归锁，是指同一线程在外层获取锁后，进入内层方法再次获取同一锁时会自动获取锁。可重入锁的好处是可以一定程度避免死锁。</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/6c/65/7aroBMWu_o.png" alt="1d3d35155b6749d084ed0028d6258df5.png"> </p> 
<p>源码分析</p> 
<p>Java 中 ReentrantLock 和 synchronized 都是可重入锁，我们以 ReentrantLock 为例进行分析：<br> // ReentrantLock FairSync<br> // 获取锁<br> protected final boolean tryAcquire(int acquires) {<!-- --><br>     final Thread current = Thread.currentThread();<br>     int c = getState();<br>     if (c == 0) {<!-- --><br>         if (!hasQueuedPredecessors() &amp;&amp;<br>             compareAndSetState(0, acquires)) {<!-- --><br>             setExclusiveOwnerThread(current);<br>             return true;<br>         }<br>     }<br>     // 重点：在已经获取锁的情况下，对比当前线程ID和占用锁线程ID是否一致，若一致锁计数器 +1<br>     // 不可重入的情况下，则无此判断<br>     else if (current == getExclusiveOwnerThread()) {<!-- --><br>         int nextc = c + acquires;<br>         if (nextc &lt; 0)<br>             throw new Error("Maximum lock count exceeded");<br>         setState(nextc);<br>         return true;<br>     }<br>     return false;<br> }</p> 
<p>// 释放锁<br> protected final boolean tryRelease(int releases) {<!-- --><br>     // 每次释放时进行-1<br>     int c = getState() - releases;<br>     if (Thread.currentThread() != getExclusiveOwnerThread())<br>         throw new IllegalMonitorStateException();<br>     boolean free = false;<br>     // 直到计数器为 0 代表锁释放<br>     if (c == 0) {<!-- --><br>         free = true;<br>         setExclusiveOwnerThread(null);<br>     }<br>     setState(c);<br>     return free;<br> }<br> 排它锁 &amp; 共享锁</p> 
<p>概念</p> 
<p>排它锁和共享锁的主要区别在于互斥资源锁是否能被多个线程同时持有。同时只能被一个线程持有称为排它锁；当能够被多个线程同时持有称为共享锁。<br> 作用</p> 
<p>进一步细化加锁粒度，提高并发性能。比如我们常见读写锁，实现读读不互斥，高效并发读，而读写、写读、写写的过程互斥。<br> 源码分析</p> 
<p>我们以 ReentrantReadWriteLock 读写锁为例，ReentrantReadWriteLock 中有两把锁 ReadLock 和 WriteLock ，一个是读锁为共享锁，一个是写锁为排它锁：<br> 当前线程已获取读锁无写锁，其它线程可以获取读锁；当前线程已获取写锁，仅当前线程可以获取读锁。<br>     ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock(true);<br>     // 读锁<br>     ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();<br>     // 写锁<br>     ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();</p> 
<p>    // 读锁 公平锁<br>     public void lock() {<!-- --><br>         sync.acquireShared(1);<br>     }</p> 
<p><br>     public final void acquireShared(int arg) {<!-- --><br>         if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);<br>     }</p> 
<p><br>     protected final int tryAcquireShared(int unused) {<!-- --><br>         /*<br>          * Walkthrough:<br>          * 1. If write lock held by another thread, fail.<br>          * 2. Otherwise, this thread is eligible for<br>          *    lock wrt state, so ask if it should block<br>          *    because of queue policy. If not, try<br>          *    to grant by CASing state and updating count.<br>          *    Note that step does not check for reentrant<br>          *    acquires, which is postponed to full version<br>          *    to avoid having to check hold count in<br>          *    the more typical non-reentrant case.<br>          * 3. If step 2 fails either because thread<br>          *    apparently not eligible or CAS fails or count<br>          *    saturated, chain to version with full retry loop.<br>          */<br>         Thread current = Thread.currentThread();<br>         int c = getState();<br>         // 存在写锁且不是当前线程<br>         if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1;<br>         // 当前线程持有写锁或仅有读锁或无锁<br>         int r = sharedCount(c);<br>         if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) {<!-- --><br>             // 如果是第一次获取 初始化 firstReader、firstReaderHoldCount 不是第一次获取 对 readHolds  对应线程计数+1<br>             if (r == 0) {<!-- --><br>                 firstReader = current;<br>                 firstReaderHoldCount = 1;<br>             } else if (firstReader == current) {<!-- --><br>                 firstReaderHoldCount++;<br>             } else {<!-- --><br>                 HoldCounter rh = cachedHoldCounter;<br>                 if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get();<br>                 else if (rh.count == 0) readHolds.set(rh);<br>                 rh.count++;<br>             }<br>             return 1;<br>         }<br>         return fullTryAcquireShared(current);<br>     }</p> 
<p><br>     final int fullTryAcquireShared(Thread current) {<!-- --><br>         /*<br>          * This code is in part redundant with that in<br>          * tryAcquireShared but is simpler overall by not<br>          * complicating tryAcquireShared with interactions between<br>          * retries and lazily reading hold counts.<br>          */<br>         HoldCounter rh = null;<br>         // 自旋 不挂起线程<br>         for (; ; ) {<!-- --><br>             int c = getState();<br>             if (exclusiveCount(c) != 0) {<!-- --><br>                 // 非当前线程获取到写锁获取失败<br>                 if (getExclusiveOwnerThread() != current)<br>                     return -1;<br>                 // else we hold the exclusive lock; blocking here<br>                 // would cause deadlock.<br>             } else if (readerShouldBlock()) { <br>                 // 走到这里说明没有写锁被占有 判断是否存在重入<br>                 // Make sure we're not acquiring read lock reentrantly<br>                 // 当前线程为 firstReader 走下面 CAS<br>                 if (firstReader == current) {<!-- --><br>                     // assert firstReaderHoldCount &gt; 0;<br>                 } else {<!-- --><br>                     if (rh == null) {<!-- --><br>                         rh = cachedHoldCounter;<br>                         // cachedHoldCounter 没有缓存或缓存的不是当前线程<br>                         if (rh == null || rh.tid != getThreadId(current)) {<!-- --><br>                             rh = readHolds.get();<br>                             // 说明上一行是初始化 移除上面产生的初始化<br>                             if (rh.count == 0)<br>                                 readHolds.remove();<br>                         }<br>                     }<br>                     if (rh.count == 0)<br>                         return -1;<br>                 }<br>             }<br>             // 是否已经达到读锁获取次数上限<br>             if (sharedCount(c) == MAX_COUNT)<br>                 throw new Error("Maximum lock count exceeded");<br>             // CAS 获取锁<br>             if (compareAndSetState(c, c + SHARED_UNIT)) {<!-- --><br>                 // 读锁初始化和计数<br>                 if (sharedCount(c) == 0) {<!-- --><br>                     // 第一次添加读锁<br>                     firstReader = current;<br>                     firstReaderHoldCount = 1;<br>                 } else if (firstReader == current) {<!-- --><br>                     // firstReader 为当前线程<br>                     firstReaderHoldCount++;<br>                 } else {<!-- --><br>                     // 否则更新 readHolds 对应线程读锁计数<br>                     if (rh == null)<br>                         rh = cachedHoldCounter;<br>                     if (rh == null || rh.tid != getThreadId(current))<br>                         rh = readHolds.get();<br>                     else if (rh.count == 0)<br>                         readHolds.set(rh);<br>                     rh.count++;<br>                     cachedHoldCounter = rh; // cache for release<br>                 }<br>                 return 1;<br>             }<br>         }<br>     }</p> 
<p>    // 无法获取读锁，将获取读锁线程放入等待队列中<br>     private void doAcquireShared(int arg) {<!-- --><br>         final Node node = addWaiter(Node.SHARED);<br>         boolean failed = true;<br>         try {<!-- --><br>             boolean interrupted = false;<br>             for (; ; ) {<!-- --><br>                 final Node p = node.predecessor();<br>                 if (p == head) {<!-- --><br>                     int r = tryAcquireShared(arg);<br>                     if (r &gt;= 0) {<!-- --><br>                         setHeadAndPropagate(node, r);<br>                         p.next = null; // help GC<br>                         if (interrupted) selfInterrupt();<br>                         failed = false;<br>                         return;<br>                     }<br>                 }<br>                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true;<br>             }<br>         } finally {<!-- --><br>             if (failed) cancelAcquire(node);<br>         }<br>     }</p> 
<p>    // 写锁 公平锁<br>     public void lock() {<!-- --><br>         sync.acquire(1);<br>     }</p> 
<p>    public final void acquire(int arg) {<!-- --><br>         if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();<br>     }</p> 
<p><br>     protected final boolean tryAcquire(int acquires) {<!-- --><br>         /*<br>          * Walkthrough:<br>          * 1. If read count nonzero or write count nonzero<br>          *    and owner is a different thread, fail.<br>          * 2. If count would saturate, fail. (This can only<br>          *    happen if count is already nonzero.)<br>          * 3. Otherwise, this thread is eligible for lock if<br>          *    it is either a reentrant acquire or<br>          *    queue policy allows it. If so, update state<br>          *    and set owner.<br>          */<br>         Thread current = Thread.currentThread();<br>         int c = getState();<br>         int w = exclusiveCount(c);<br>         // 存在读锁或写锁<br>         if (c != 0) {<!-- --><br>             // (Note: if c != 0 and w == 0 then shared count != 0)<br>             // 存在读锁或存在写锁但不是当前线程持有获取失败<br>             if (w == 0 || current != getExclusiveOwnerThread()) return false;<br>             // 获取锁是否超过上限<br>             if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error("Maximum lock count exceeded");<br>             // Reentrant acquire<br>             // 走到这里说明当前线程持有写锁 重入<br>             setState(c + acquires);<br>             return true;<br>         }<br>         // 不存在锁 判断队列阻塞策略 并进行 CAS 尝试获取锁<br>         if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false;<br>         setExclusiveOwnerThread(current);<br>         return true;<br>     }<br> ReentrantReadWriteLock 巧妙的将AQS中的state一分为二高16位为读计数，低16为为写计数，将两个原子性操作（读竞争和写竞争）合并为一个原子操作。</p> 
<p>synchronized 中的无锁、偏向锁、轻量级锁、重量级锁</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/2d/74/rDUqc3WL_o.png" alt="9d7a285254b74eca9532c947276b0ac3.png"> </p> 
<p>synchronized 中的无锁、偏向锁、轻量级锁、重量级锁是 synchronized 特有的概念，参考 volatile &amp; synchronized 章节。<br> 如果内容对您有帮助，请多多点赞关注支持，谢谢！</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d5a72ce4094085d0a72e1548e3464943/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GEE批量下载Sentinel2数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c3cdf8cfba7c72bf161bee62221f2af3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据库设计之ER图、三大范式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>