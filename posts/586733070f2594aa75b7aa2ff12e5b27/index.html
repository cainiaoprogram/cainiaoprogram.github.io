<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FileInputStream(文件字节输入流) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FileInputStream(文件字节输入流)" />
<meta property="og:description" content="首先我们先看一下文件字节输入流
1.构造方法： 构造方法说明FileInputStream(File file)通过打开与实际文件的连接创建一个 FileInputStream，该文件由文件系统中的 File对象 file命名。FileInputStream(FileDescriptor fdObj)创建 FileInputStream通过使用文件描述符 fdObj ，其表示在文件系统中的现有连接到一个实际的文件。FileInputStream(String name)通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 2.首先我们使用文件的路径名来看一下文件字节输入流 我们先创建一个文件，然后记住路径
D:\JAVATest\test
写一下代码来具体看一下
/* java.io.FileInputStream： 1.文件字节输入流，万能的，任何类型的文件都可以采用这个流来读 2.字节的方式，完成输入的操作，完成读的操作(硬盘---&gt;内存) */ public class FileInputStreamTest01 { public static void main(String[] args) { FileInputStream fis=null; //1.创建文件字节输入流对象 //文件路径:D:\JAVATest\test(因为一个\为转义，所以idea中会自动把\变成\\)，或者路径写/也行 //采用了绝对路径的方式 try { fis = new FileInputStream(&#34;D:\\JAVATest\\test&#34;); //开始读文件 //方法的返回值是读取到的read本身 // while循环 int readData=0; while((readData=fis.read()) != -1){ System.out.println(readData); } // while ((fis.read())!=-1){ // System.out.println(fis.read()); // } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/586733070f2594aa75b7aa2ff12e5b27/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-30T15:19:22+08:00" />
<meta property="article:modified_time" content="2023-11-30T15:19:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FileInputStream(文件字节输入流)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>首先我们先看一下文件字节输入流</p> 
<h4 id="1构造方法">1.构造方法：</h4> 
<table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>FileInputStream(File file)</td><td>通过打开与实际文件的连接创建一个 FileInputStream，该文件由文件系统中的 File对象 file命名。</td></tr><tr><td>FileInputStream(FileDescriptor fdObj)</td><td>创建 FileInputStream通过使用文件描述符 fdObj ，其表示在文件系统中的现有连接到一个实际的文件。</td></tr><tr><td>FileInputStream(String name)</td><td>通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</td></tr></tbody></table> 
<h4 id="2首先我们使用文件的路径名来看一下文件字节输入流">2.首先我们<strong>使用文件的路径名</strong>来看一下文件字节输入流</h4> 
<p>我们先创建一个文件，然后记住路径</p> 
<p>D:\JAVATest\test</p> 
<p><img alt="" height="89" src="https://images2.imgbox.com/fa/1b/DsKEDQb2_o.png" width="828"><img alt="" height="628" src="https://images2.imgbox.com/00/69/0XhObVN1_o.png" width="1046"></p> 
<p> 写一下代码来具体看一下</p> 
<pre><code>/*
java.io.FileInputStream：
        1.文件字节输入流，万能的，任何类型的文件都可以采用这个流来读
        2.字节的方式，完成输入的操作，完成读的操作(硬盘---&gt;内存)
 */
public class FileInputStreamTest01 {
    public static void main(String[] args) {
        FileInputStream fis=null;
        //1.创建文件字节输入流对象
        //文件路径:D:\JAVATest\test(因为一个\为转义，所以idea中会自动把\变成\\)，或者路径写/也行
        //采用了绝对路径的方式
        try {
            fis = new FileInputStream("D:\\JAVATest\\test");
         //开始读文件
         //方法的返回值是读取到的read本身
          // while循环
              int readData=0;
            while((readData=fis.read()) != -1){
                System.out.println(readData);
            }

//            while ((fis.read())!=-1){
//                System.out.println(fis.read());
//            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) //避免空指针异常{
                //如果流不为空，就关闭，流是null的时候没必要关闭
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        }
    }
</code></pre> 
<p>输出：可以看到打印的结果是字母对应的ANSI码，a的是65，A的是97，依此类推</p> 
<blockquote> 
 <p>65<br> 66<br> 67<br> 97<br> 98<br> 99</p> 
</blockquote> 
<p></p> 
<p>但是这种方法有点浪费计算机的资源，因为要频繁的读取数据，硬件与内存之间交换太过频繁。为此，我们可以采用一个方法，用来一次把数据读取完！</p> 
<p>int read(byte[] b)<br> 一次最多可读取b.length个文件，<br> 减少硬盘和内存之间的交互，提高程序的执行效率<br> 在byte[]数组当中读</p> 
<pre><code>import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FIleInputStreamTest03 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("D:/JAVATest/test");
            //准备一个byte数组
            //开始读，采用byte数组，一次读取多个字节，最多读取”b.length“个字符
            byte[] bytes = new byte[4];
            int readCount=0;
            while((readCount=fis.read(bytes))!=-1){
                System.out.print(new String(bytes,0,readCount));
            }
//如果上面的while循环不理解可以额看下面这个
//            while (true){
//                int readCount=fis.read(bytes);
//                if (readCount == -1) {
//                    break;
//                }
//                //把byte数组转换成字符串,读到多少个转化多少个
//                System.out.print(new String(bytes,0,readCount));
//            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre> 
<p>输出：</p> 
<blockquote> 
 <p>ABCabc</p> 
</blockquote> 
<h4 id="3fileinputstream类的其他常用方法">3.FileInputStream类的其他常用方法</h4> 
<ul><li> <p>int avialble() 返回流当中剩余的字节数量</p> </li><li> <p>skip(long n) 跳过几个字节不读</p> </li></ul> 
<p><strong>先看avialable的用法，</strong>既然可以返回流中剩余的字节数量，那么我们在读取之前调用就会返回总字节数量，利用总字节数可以定义一个刚好的数组长度：</p> 
<p>代码示例：</p> 
<pre><code>public class FileInputStreamTest04 {
    public static void main(String[] args) {
        FileInputStream fis=null;
        try {
            fis = new FileInputStream("D:/JAVATest/test");
            //一次只读取了一个字符
//            int readCount=fis.read();
//            我们可以用avlilable方法看一下剩余多少个字符
//            System.out.println("剩余的字符为"+fis.available());
            //创建一个指定长度为文件字节数的数组
            byte[] bytes = new byte[fis.available()];
            //这样就不用使用循环来遍历了
            int readCount=fis.read(bytes);
            System.out.println(new String(bytes));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis!=null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre> 
<p> 输出：</p> 
<blockquote> 
 <p>ABCabc</p> 
</blockquote> 
<p>但是这种方式不太适合太大的文件，因为byte数组不宜过大</p> 
<p>再看一下skip的用法，skip用来跳过几个字节不读取，这个方法也可能以后会用。</p> 
<p>里面参数跟要跳过的字节个数，代码就不演示了！</p> 
<p></p> 
<h4>4.我在Android 上的用处，读出来，再存上：</h4> 
<p>当然最终我用的是LinkedBlockingQueue取代了ArrayList实现了两个线程同时读写，下面只是以ArrayList记录下简单的思路。</p> 
<pre><code>ArrayList&lt;byte[]&gt; queue = new ArrayList&lt;&gt;();</code></pre> 
<p>读取：</p> 
<pre><code>        switch (position){
            case 0:
                filePath = Environment.getExternalStorageDirectory() + File.separator  +"0001.mp4";
                break;
            case 1:
                filePath = Environment.getExternalStorageDirectory() + File.separator  +"0002.mp4";
                break;
            case 2:
                filePath = Environment.getExternalStorageDirectory() + File.separator  +"0003.mp4";
                break;
        }
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = new FileInputStream(new File(filePath));
            byte[] bytes = new byte[1024*256];
            int len;
            while((len = fileInputStream.read(bytes)) != -1){
                byte[] newBytes = Arrays.copyOf(bytes,len);
                Log.i("读取文件", "bytes===============:" + newBytes.length);
                queue.add(newBytes);
                
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(fileInputStream != null){
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }</code></pre> 
<p></p> 
<p>用RandomAccessFile写数据：</p> 
<pre><code> String outPath = Environment.getExternalStorageDirectory() + File.separator  +"0009.mp4";
        RandomAccessFile outFileStream = null;
        try {
             outFileStream = new RandomAccessFile(outPath, "rwd");
            if(queue.size() != 0){
                while (true) {
                    try {
                        byte[] cByte = queue.get(0);
                        queue.remove(0);
                        outFileStream.write(cByte);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    if(queue.size() == 0){
                        break;
                    }
                }
             }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(outFileStream != null){
                try {
                    outFileStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b94a86f1e816f0bcea05cd7d139c9e37/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【js】SSH隧道远程连接mysql</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/599cde20c16dc532a328e4f98d466019/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CUDA和FFMPEG硬件解码视频流</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>