<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java byte与char互转原理-转 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java byte与char互转原理-转" />
<meta property="og:description" content="一、字节和unicode Java内核是unicode的，就连class文件也是，但是很多媒体，包括文件/流的保存方式是使用字节流的。因此Java要对这些字节流经行转化。 char是unicode的，而byte是字节。Java中 byte/char互转的函数在sun.io的包中间有。其中ByteToCharConverter类是中调度，可以用来告诉你，你用的 convertor。其中两个很常用的静态函数是： public static ByteToCharConverter getDefault(); public static ByteToCharConverter getConverter(String encoding); 如果你不指定converter，则系统会自动使用当前的encoding,gb平台上用gbk,en平台上用8859_1。 byte ——〉char： &#34;你&#34;的gb码是：0xc4e3 ,unicode是0x4f60 String encoding = &#34;gb2312&#34;; byte b[] = {(byte)&#39;\u00c4&#39;,(byte)&#39;\u00e3&#39;}; ByteToCharConverter converter = ByteToCharConverter.getConverter(encoding); char c[] = converter.convertAll(b); for (int i = 0; i &lt; c.length; i&#43;&#43;) { System.out.println(Integer.toHexString(c[i])); } 结果是什么？0x4f60 如果encoding =&#34;8859_1&#34;，结果又是什么？0x00c4,0x00e3 如果代码改为： byte b[] = {(byte)&#39;\u00c4&#39;,(byte)&#39;\u00e3&#39;}; ByteToCharConverter converter = ByteToCharConverter. getDefault(); char c[] = converter.convertAll(b); for (int i = 0; i &lt; c." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/728633f913e1db74ccfbdd18141d4f41/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2008-06-10T14:51:02+08:00" />
<meta property="article:modified_time" content="2008-06-10T14:51:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java byte与char互转原理-转</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    一、字节和unicode 
<br> 
<br>Java内核是unicode的，就连class文件也是，但是很多媒体，包括文件/流的保存方式是使用字节流的。因此Java要对这些字节流经行转化。 char是unicode的，而byte是字节。Java中 byte/char互转的函数在sun.io的包中间有。其中ByteToCharConverter类是中调度，可以用来告诉你，你用的 convertor。其中两个很常用的静态函数是： 
<br> 
<br>public static ByteToCharConverter getDefault(); 
<br>public static ByteToCharConverter getConverter(String encoding); 
<br> 
<br> 
<br>如果你不指定converter，则系统会自动使用当前的encoding,gb平台上用gbk,en平台上用8859_1。 
<br> 
<br>byte ——〉char： 
<br>"你"的gb码是：0xc4e3 ,unicode是0x4f60 
<br>String encoding = "gb2312"; 
<br>byte b[] = {(byte)'\u00c4',(byte)'\u00e3'}; 
<br>ByteToCharConverter converter = ByteToCharConverter.getConverter(encoding); 
<br>char c[] = converter.convertAll(b); 
<br>for (int i = 0; i &lt; c.length; i++) { 
<br>System.out.println(Integer.toHexString(c[i])); 
<br>} 
<br>结果是什么？0x4f60 
<br>如果encoding ="8859_1"，结果又是什么？0x00c4,0x00e3 
<br> 
<br> 
<br>如果代码改为： 
<br> 
<br>byte b[] = {(byte)'\u00c4',(byte)'\u00e3'}; 
<br>ByteToCharConverter converter = ByteToCharConverter. getDefault(); 
<br> char c[] = converter.convertAll(b); 
<br> for (int i = 0; i &lt; c.length; i++) { 
<br> System.out.println(Integer.toHexString(c[i])); 
<br> } 
<br> 
<br> 
<br>结果将又是什么？ 
<br> 
<br>这就要根据平台的编码而定。 
<br> 
<br>char ——〉byte： 
<br> String encoding = "gb2312"; 
<br> char c[] = {'\u4f60'}; 
<br> CharToByteConverter converter = CharToByteConverter.getConverter(encoding); 
<br> byte b[] = converter.convertAll(c); 
<br> for (int i = 0; i &lt; b.length; i++) { 
<br> System.out.println(Integer.toHexString(b[i])); 
<br> } 
<br>结果是什么？0x00c4,0x00e3 
<br>如果encoding ="8859_1"，结果又是什么？0x3f 
<br>如果代码改为 
<br>String encoding = "gb2312"; 
<br> char c[] = {'\u4f60'}; 
<br> CharToByteConverter converter = CharToByteConverter.getDefault(); 
<br> byte b[] = converter.convertAll(c); 
<br> for (int i = 0; i &lt; b.length; i++) { 
<br> System.out.println(Integer.toHexString(b[i])); 
<br> } 
<br> 
<br> 
<br>结果将又是什么？还是根据平台的编码而定。 
<br> 
<br>很多中文问题就是从这两个最简单的类派生出来的。而却有很多类不直接支持把encoding输入，这给我们带来诸多不便。很多程序难得用encoding了，直接用default的encoding，这就给我们移植带来了很多困难。 
<br> 
<br>二、utf-8 
<br> 
<br>utf-8是和unicode一一对应的，其实现很简单： 
<br> 
<br>7位的unicode: 0 _ _ _ _ _ _ _ 
<br>11位的unicode: 1 1 0 _ _ _ _ _ 1 0 _ _ _ _ _ _ 
<br>16位的unicode: 1 1 1 0 _ _ _ _ 1 0 _ _ _ _ _ _ 1 0 _ _ _ _ _ _ 
<br>21位的unicode: 1 1 1 1 0 _ _ _ 1 0 _ _ _ _ _ _ 1 0 _ _ _ _ _ _ 1 0 _ _ _ _ _ _ 
<br> 
<br> 
<br>大多数情况是只使用到16位以下的unicode: 
<br> 
<br>"你"的gb码是：0xc4e3 ,unicode是0x4f60 
<br> 0xc4e3的二进制： 
<br> 1100 ，0100 ，1110 ，0011 
<br> 
<br> 
<br>由于只有两位我们按照两位的编码来排，但是我们发现这行不通，因为第７位不是0因此，返回"?" 
<br> 
<br>0x4f60的二进制： 
<br> 0100 ，1111 ，0110 ，0000 
<br> 我们用utf-8补齐，变成： 
<br> 1110 ，0100 ，1011 ，1101 ，1010 ，0000 
<br> e4--bd-- a0 
<br> 于是返回：0xe4,0xbd,0xa0。 
<br> 
<br> 
<br>三、string和byte[] 
<br> 
<br>string其实核心是char[],然而要把byte转化成string，必须经过编码。string.length()其实就是char数组的长度，如果使用不同的编码，很可能会错分，造成散字和乱码。例如： 
<br> 
<br>String encoding = “”; 
<br>byte [] b={(byte)'\u00c4',(byte)'\u00e3'}; 
<br>String str=new String(b,encoding); 
<br> 
<br> 
<br>如果encoding=8859_1，会有两个字，但是encoding=gb2312只有一个字这个问题在处理分页是经常发生。 
<br> 
<br>四、Reader,Writer / InputStream,OutputStream 
<br> 
<br>Reader和Writer核心是char，InputStream和OutputStream核心是byte。但是Reader和Writer的主要目的是要把char读/写InputStream/OutputStream。例如： 
<br> 
<br>文件test.txt只有一个"你"字，0xc4,0xe3 
<br>String encoding = "gb2312"; 
<br> InputStreamReader reader = new InputStreamReader(new FileInputStream( 
<br> "text.txt"), encoding); 
<br> char c[] = new char[10]; 
<br> int length = reader.read(c); 
<br> for (int i = 0; i &lt; length; i++) { 
<br> System.out.println(c[i]); 
<br> } 
<br> 
<br> 
<br>结果是什么？是"你"。如果encoding ="8859_1"，结果是什么？"??"两个字符，表示不认识。反过来的例子自己做。 
<br>五、我们要对Java的编译器有所了解： 
<br> 
<br>Javac ?encoding 
<br> 
<br> 
<br>我们常常没有用到encoding这个参数。其实encoding这个参数对于跨平台的操作是很重要的。如果没有指定encoding，则按照系统的默认 encoding,gb平台上是gb2312，英文平台上是iso8859_1。Java的编译器实际上是调用sun.tools.Javac.main 的类，对文件进行编译，这个类有compile函数中间有一个encoding的变量,-encoding的参数其实直接传给encoding变量。编译器就是根据这个变量来读取Java文件的，然后把用utf-8形式编译成class文件。例子代码： 
<br> 
<br>String str = "你"; 
<br> FileWriter writer = new FileWriter("text.txt"); 
<br> write.write(str); 
<br> writer.close(); 
<br> 
<br>如果用gb2312编译，你会找到e4 bd a0的字段 ； 
<br>如果用8859_1编译， 00c4 00e3的二进制： 
<br>0000，0000 ，1100，0100 ，0000，0000 ，1110，0011 
<br>因为每个字符都大于7位，因此用11位编码： 
<br>1100，0001，1000，0100，1100，0011，1010，0011 
<br>c1-- 84--　c3--　 a3 
<br>你会找到c1 84 c3 a3 
<br> 
<br> 
<br>但是我们往往忽略掉这个参数，因此这样往往会有跨平台的问题： 
<br> 
<br>样例代码在中文平台上编译，生成zhclass 
<br> 
<br>样例代码在英文平台上编译，输出enclass 
<br> 
<br>(1) zhclass在中文平台上执行ok,但是在英文平台上不行 
<br> 
<br>(2) enclass在英文平台上执行ok,但是在中文平台上不行 
<br> 
<br>原因是： 
<br> 
<br>(1) 在中文平台上编译后，其实str在运行态的char[]是0x4f60,　在中文平台上运行，filewriter的缺省编码是gb2312,因此 chartobyteconverter会自动用调用gb2312的converter,把str转化成byte输入到fileoutputstream 中，于是0xc4,0xe3放进了文件。但是如果是在英文平台下，chartobyteconverter的缺省值是8859_1, filewriter会自动调用8859_1去转化str,但是他无法解释，因此他会输出"?" 
<br> 
<br>(2) 在英文平台上编译后，其实str在运行态的char[]是0x00c4 0x00e3, 在中文平台上运行，中文无法识别，因此会出现??；在英文平台上，0x00c4--&gt;0xc4,0x00e3-&gt;0xe3，因此 0xc4,0xe3被放进了文件。 
<br> 
<br>六、其它原因： 
<br> 
<br>&lt;%@ page contentType="text/html; charset=GBK" %&gt; 
<br> 
<br> 
<br>设置浏览器的显示编码，如果response的数据是utf8编码，显示将是乱码，但是乱码和上述原因还不一样。 
<br> 
<br>七、发生编码的地方： 
<br> 
<br>1. 从数据库到Java程序 byte——〉char 
<br> 
<br>2. 从Java程序到数据库 char——〉byte 
<br> 
<br>3. 从文件到Java程序 byte——〉char 
<br> 
<br>4. 从Java程序到文件 char——〉byte 
<br> 
<br>5. 从Java程序到页面显示 char——〉byte 
<br> 
<br>6. 从页面form提交数据到Java程序byte——〉char 
<br> 
<br>7. 从流到Java程序byte——〉char 
<br> 
<br>8. 从Java程序到流char——〉byte 
<br> 
<br>可以使用配置过滤器的方法解决中文乱码的： 
<br> 
<br>&lt;web-app&gt; 
<br> &lt;filter&gt; 
<br> &lt;filter-name&gt;RequestFilter&lt;/filter-name&gt; 
<br> &lt;filter-class&gt;net.golden.uirs.util.RequestFilter&lt;/filter-class&gt; 
<br> &lt;init-param&gt; 
<br> &lt;param-name&gt;charset&lt;/param-name&gt; 
<br> &lt;param-value&gt;gb2312&lt;/param-value&gt; 
<br> &lt;/init-param&gt; 
<br> &lt;/filter&gt; 
<br> &lt;filter-mapping&gt; 
<br> &lt;filter-name&gt;RequestFilter&lt;/filter-name&gt; 
<br> &lt;url-pattern&gt;*.Jsp&lt;/url-pattern&gt; 
<br> &lt;/filter-mapping&gt; 
<br>&lt;/web-app&gt; 
<br> 
<br> 
<br> public void doFilter(ServletRequest req, ServletResponse res, 
<br> FilterChain fChain) throws IOException, ServletException { 
<br> HttpServletRequest request = (HttpServletRequest) req; 
<br> HttpServletResponse response = (HttpServletResponse) res; 
<br> HttpSession session = request.getSession(); 
<br> String userId = (String) session.getAttribute("userid"); 
<br> req.setCharacterEncoding(this.filterConfig.getInitParameter("charset")); 
<br>// 设置字符集？ 
<br>//实际上是设置了byte ——〉char的encoding 
<br> try { 
<br> if (userId == null || userId.equals("")) { 
<br> if (!request.getRequestURL().toString().matches( 
<br> ".*/uirs/logon/logon(Controller){0,1}\\x2EJsp$")) { 
<br> session.invalidate(); 
<br> response.sendRedirect(request.getContextPath() + 
<br> "/uirs/logon/logon.Jsp"); 
<br> } 
<br> } 
<br> else { 
<br> // 看看是否具有信息上报系统的权限 
<br> if (!net.golden.uirs.util.UirsChecker.check(userId, "信息上报系统", 
<br> net.golden.uirs.util.UirsChecker.ACTION_DO)) { 
<br> if (!request.getRequestURL().toString().matches( 
<br> ".*/uirs/logon/logon(Controller){0,1}\\x2EJsp$")) { 
<br> response.sendRedirect(request.getContextPath() + 
<br> "/uirs/logon/logonController.Jsp"); 
<br> } 
<br> } 
<br> } 
<br> } 
<br> catch (Exception ex) { 
<br> response.sendRedirect(request.getContextPath() +"/uirs/logon/logon.Jsp"); 
<br> } 
<br> fChain.doFilter(req, res); 
<br> }
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea7ba79aae71757813a355533c1324fc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">try/catch的实现原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d1a707b921024caf5efa6ff004970cc4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">文件下载方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>