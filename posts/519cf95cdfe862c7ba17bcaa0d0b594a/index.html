<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js隐式转换 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js隐式转换" />
<meta property="og:description" content="js数据类型 基本类型（原始值）：Undefined Null String Number Boolean Symbol引用类型（对象值）：object (数组Array; 函数Function; 正则RegEXP; 日期Date) 来源 &#43;：运算符既可以是数字相加,也可以是字符串相加==：==不同于===有多不同情况的隐式转换（以前我看一本书书尽量还是多用==，多拥抱js的隐式转换少用===，但是当我用了===，我就回不去了）- * / ： 这一些运算符就比较友好了，他们只针对number类型，因而转化的结果只能转换成number类型 转化的方法 将值转为原始值，ToPrimitive() http://www.ecma-international.org/ecma-262/#sec-toprimitive 7.1.1 中有介绍
将值转为数字，ToNumber()将值转为字符串，ToString() 通过ToNumber将值转为数字 参数结果 undefined
NaN unll
&#43;0
Boolean
true转换为1; false转换为0
Number
无需转换
String
由js中的内置对象Number来处理
Object
1.先进行 ToPrimitive(obj, Number)转换得到原始值，
2.在进行ToNumber转换为数字 通过ToString将值转换为字符串 参数
结果
undefined
&#39;undefined&#39; // &#39;1&#39; &#43; undefined = &#34;1undefined&#34;
null
&#39;null&#39;
Boolean &#39;true&#39;或&#39;false&#39;
Number数字转字符串 // (123).toString() =&gt; &#39;123&#39;String字符串无需转换Object 1.先进行 ToPrimitive(obj, String)转换得到原始值，
2.在进行ToString转换为字符串
通过ToPrimitive将值转换为原始值 ToPrimitive(input, PreferredType?)
input：是要转换的值" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/519cf95cdfe862c7ba17bcaa0d0b594a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-25T19:10:13+08:00" />
<meta property="article:modified_time" content="2020-09-25T19:10:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js隐式转换</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>js数据类型</h3> 
<ol><li>基本类型（原始值）：Undefined Null String Number Boolean Symbol</li><li>引用类型（对象值）：object (数组Array; 函数Function; 正则RegEXP; 日期Date)</li></ol> 
<h3>来源</h3> 
<ol><li><strong>+</strong>：运算符既可以是数字相加,也可以是字符串相加</li><li><strong>==</strong>：==不同于===有多不同情况的隐式转换（以前我看一本书书尽量还是多用==，多拥抱js的隐式转换少用===，但是当我用了===，我就回不去了）</li><li><strong>- * / </strong>： 这一些运算符就比较友好了，他们只针对number类型，因而转化的结果只能转换成number类型</li></ol> 
<h3>转化的方法</h3> 
<ol><li>将值转为原始值，ToPrimitive()</li></ol> 
<blockquote> 
 <p><a href="http://www.ecma-international.org/ecma-262/#sec-toprimitive" rel="nofollow">http://www.ecma-international.org/ecma-262/#sec-toprimitive</a> 7.1.1 中有介绍</p> 
</blockquote> 
<ol><li>将值转为数字，ToNumber()</li><li>将值转为字符串，ToString()</li></ol> 
<h4>通过ToNumber将值转为数字</h4> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>参数</td><td style="width:699px;">结果</td></tr><tr><td> <p>undefined</p> </td><td style="width:699px;"> <p> NaN </p> </td></tr><tr><td> <p>unll</p> </td><td style="width:699px;"> <p>+0</p> </td></tr><tr><td> <p>Boolean</p> </td><td style="width:699px;"> <p>true转换为1; false转换为0</p> </td></tr><tr><td> <p>Number</p> </td><td style="width:699px;"> <p>无需转换</p> </td></tr><tr><td> <p>String</p> </td><td style="width:699px;"> <p>由js中的内置对象Number来处理</p> </td></tr><tr><td> <p><strong>Object</strong></p> </td><td style="width:699px;"> <p><strong>1.先进行 ToPrimitive(obj, Number)转换得到原始值，</strong></p> <p><strong>2.在进行ToNumber转换为数字 </strong></p> </td></tr></tbody></table> 
<h3> 通过ToString将值转换为字符串</h3> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td> <p>参数</p> </td><td style="width:689px;"> <p>结果</p> </td></tr><tr><td> <p>undefined</p> </td><td style="width:689px;"> <p>'undefined'   // '1' + undefined  = "1undefined"</p> </td></tr><tr><td> <p>null</p> </td><td style="width:689px;"> <p>'null'</p> </td></tr><tr><td>Boolean</td><td style="width:689px;"> <p>'true'或'false'</p> </td></tr><tr><td>Number</td><td style="width:689px;">数字转字符串 // (123).toString() =&gt; '123'</td></tr><tr><td>String</td><td style="width:689px;">字符串无需转换</td></tr><tr><td><strong>Object</strong></td><td style="width:689px;"> <p><strong>1.先进行 ToPrimitive(obj, String)转换得到原始值，</strong></p> <p><strong>2.在进行ToString转换为字符串</strong></p> </td></tr></tbody></table> 
<h4>通过ToPrimitive将值转换为原始值</h4> 
<p><strong>ToPrimitive(input, PreferredType?)</strong></p> 
<blockquote> 
 <p><strong>input：</strong>是要转换的值</p> 
 <p><strong>PreferredType</strong>：（默认值为Number）是可选参数，可以是Number或String类型。他只是一个转换标志，转化后的结果并不一定是这个参数所值的类型，但是转换结果一定是一个原始值（或者报错）。</p> 
</blockquote> 
<p><strong>当标志为Number的时候，ToPrimitive方法的操作流程为</strong></p> 
<ol><li>如果输入的值已经是一个原始值，则直接返回它</li><li>否则，如果输入的值是一个对象，则调用该对象的valueOf()方法，如果valueOf()方法的返回值是一个原始值，则返回这个原始值。 // valueOf 方法下面会说</li><li>否则，调用这个对象的toString()方法，如果toString()方法返回的是一个原始值，则返回这个原始值。</li><li>否则，抛出TypeError异常。</li></ol> 
<p><strong>当标志为String的时候，ToPrimitive方法的操作流程为</strong></p> 
<ol><li>如果输入的值已经是一个原始值，则直接返回它</li><li>否则，调用这个对象的toString()方法，如果toString()方法返回的是一个原始值，则返回这个原始值。</li><li>否则，如果输入的值是一个对象，则调用该对象的valueOf()方法，如果valueOf()方法的返回值是一个原始值，则返回这个原始值。</li><li>否则，抛出TypeError异常。</li></ol> 
<h4>valueOf方法和toSting方法解析</h4> 
<p><strong>valueOf</strong></p> 
<p>对转化Number，Boolear，String这三种构造函数生成的基础值的对象形式，通过valueOf转化后变成相应原始值</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:680px;"><tbody><tr><td style="width:241px;">运行</td><td style="width:438px;">结果</td></tr><tr><td style="width:241px;"> <p>var num = new Number('123')</p> <p>num.valueOf()</p> </td><td style="width:438px;"> <p>123</p> </td></tr><tr><td style="width:241px;"> <p>var str = new String('12df')</p> <p>str.valueOf()</p> </td><td style="width:438px;"> <p>'12df'</p> </td></tr><tr><td style="width:241px;"> <p>var bool = new Boolean('fd')</p> <p>bool.valueOf();</p> </td><td style="width:438px;"> <p>true</p> </td></tr><tr><td style="width:241px;"> <p>var a = new Date();</p> <p>a.valueOf(); </p> </td><td style="width:438px;"> <p>// 1515143895500</p> <p>也是除了 w Date().getTime(); 和 Date.parse( new Date()); 另一种获取时间戳的方法</p> </td></tr><tr><td style="width:241px;"> <p> var a = new Array();</p> <p> a.valueOf() === a;</p> </td><td style="width:438px;"> // true</td></tr><tr><td style="width:241px;"> <p>var b = new Object({});</p> <p> b.valueOf() === b; </p> </td><td style="width:438px;">// true</td></tr></tbody></table> 
<p><strong>toString</strong></p> 
<p>用Number，Boolean，String，Array，Date，RegExp，Function这几种构造函数生成的对象，通过toString转化后变成相应的字符串形式，因为这一些构造函数都封装了自己的toString方法</p> 
<pre><code>Number.prototype.hasOwnProperty('toString'); // true
Boolean.prototype.hasOwnProperty('toString'); // true
String.prototype.hasOwnProperty('toString'); // true
Array.prototype.hasOwnProperty('toString'); // true
Date.prototype.hasOwnProperty('toString'); // true
RegExp.prototype.hasOwnProperty('toString'); // true
Function.prototype.hasOwnProperty('toString'); // true</code></pre> 
<table border="1" cellpadding="1" cellspacing="1" style="width:616px;"><tbody><tr><td style="width:388px;"> <p>var num = new Number('123sd'); // Number {NaN}</p> <p>num.toString(); </p> </td><td style="width:227px;"> 'NaN'</td></tr><tr><td style="width:388px;"> <p>var str = new String('12df');</p> <p>str.toString(); </p> </td><td style="width:227px;">'12df'</td></tr><tr><td style="width:388px;"> <p>var bool = new Boolean('fd');</p> <p>bool.toString(); </p> </td><td style="width:227px;"> 'true'</td></tr><tr><td style="width:388px;"> <p>var arr = new Array(1,2);</p> <p>arr.toString();</p> </td><td style="width:227px;">'1,2'</td></tr><tr><td style="width:388px;"> <p>var d = new Date();</p> <p>d.toString();</p> </td><td style="width:227px;"> <p>"Wed Oct 11 2017 08:00:00 GMT+0800 (中国标准时间)"</p> </td></tr><tr><td style="width:388px;"> <p>var func = function () {}</p> <p>func.toString(); </p> </td><td style="width:227px;"> <p>"function () {}"</p> </td></tr></tbody></table> 
<p>除了以上的对象啊和实例化对象，其他的对象返回的都是改对象的类型，都是基础Object.prototype.toString方法</p> 
<pre><code>var obj = new Object({});

obj.toString(); // "[object Object]

Math.toString(); // "[object Math]"

</code></pre> 
<p><strong>判断数据类型</strong></p> 
<pre><code>export const getType = x =&gt; /^\[object (.*)\]$/.exec(Object.prototype.toString.call(x))[1]</code></pre> 
<p><strong>区别 </strong></p> 
<p>valueOf函数会将</p> 
<ul><li>Number，String，Boolean基本类型转换成相对于的类型，</li><li>Data类型转换为毫秒数，</li><li>其他返回对象本身</li></ul> 
<p>toString方法会将</p> 
<ul><li>所有对象转为字符串</li></ul> 
<p>ToPrimitive默认参数的原因</p> 
<p>因为valueOf函数会将Number、String、Boolean基础类型的对象类型值转换成 基础类型，Date类型转换为毫秒数，其它的返回对象本身，而toString方法会将所有对象转换为字符串。显然对于大部分对象转换，valueOf转换更合理些，因为并没有规定转换类型，应该尽可能保持原有值，而不应该想toString方法一样，一股脑将其转换为字符串。</p> 
<p><strong>例子</strong></p> 
<pre><code> ({} + {}) = ?</code></pre> 
<p>   两个对象的值进行+运算符，肯定要先进行隐式转换为原始类型才能进行计算。</p> 
<ol><li>  进行ToPrimitive转换，由于没有指定PreferredType类型，{}会使默认值为Number，进行ToPrimitive(input, Number)运算。</li><li>  所以会执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。</li><li>  继续执行toString方法，({}).toString(),返回"[object Object]"，是原始值。</li></ol> 
<p>   故得到最终的结果，"[object Object]" + "[object Object]" = "[object Object][object Object]"</p> 
<pre><code>2 * {} = ?</code></pre> 
<ol><li>  1、首先*运算符只能对number类型进行运算，故第一步就是对{}进行ToNumber类型转换。</li><li>  2、由于{}是对象类型，故先进行原始类型转换，ToPrimitive(input, Number)运算。</li><li>  3、所以会执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。</li><li>  4、继续执行toString方法，({}).toString(),返回"[object Object]"，是原始值。</li><li>  5、转换为原始值后再进行ToNumber运算，如上显示，字符串进行Number()所以得："[object Object]"就转换为NaN。</li></ol> 
<p>  故最终的结果为 2 * NaN = NaN</p> 
<pre><code> {} + [] // 0
 [] + {} // '[object Object]'</code></pre> 
<p>1.如果<code>{}</code>(空对象)在前面，而<code>[]</code>(空数组)在后面时，前面(左边)那个运算元会被认为是区块语句而不是对象字面量。所以<code>{} + []</code>相当于<code>+[]</code>语句，也就是相当于强制求出数字值的<code>Number([])</code>运算，相当于<code>Number("")</code>运算，最后得出的是<code>0</code>数字 进行<strong>ToNumber</strong>。</p> 
<ol><li>[].valueOf() // 返回数组自身，不是原始数据</li><li>调用 [].toString() // 返回空字符串</li><li>Number("") // 空字符串转型为数字，返回0</li></ol> 
<blockquote> 
 <p>大家肯定会注意为什么这里是用Number(''),由于JS中如果+运算符由<strong>二元运算符</strong>变成<strong>一元运算符</strong>就会将哪个操作符变成Number，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#delete" rel="nofollow">MDN</a></p> 
</blockquote> 
<p>2. [] + {} ===&gt; ToNumber('' + '[object Object]') === ''[object Object]''</p> 
<h4>注意</h4> 
<p>在 ES6 之后，还允许对象通过显式指定 <strong>@@toPrimitive Symbol </strong>来覆盖原有的行为。</p> 
<pre><code>var o = { 
    valueOf : () =&gt; {console.log("valueOf"); return {}}, 
    toString : () =&gt; {console.log("toString"); return {}} 
} 

o[Symbol.toPrimitive] = () =&gt; {console.log("toPrimitive"); return "hello"} 

console.log(o + "") // toPrimitive // hello</code></pre> 
<p>注意：</p> 
<p>就算以知 +号一边是字符串，那么就是字符串运算符，而不是说一定会进行ToString转换而还是进行默认ToNumber转换，只有使用字符串模板才是进行ToString转换</p> 
<pre><code>// An object without Symbol.toPrimitive property.
var obj1 = {};
console.log(+obj1);     // NaN
console.log(`${obj1}`); // "[object Object]"
console.log(obj1 + ''); // "[object Object]"

// An object with Symbol.toPrimitive property.
var obj2 = {
  [Symbol.toPrimitive](hint) {
    if (hint == 'number') {
      return 10;
    }
    if (hint == 'string') {
      return 'hello';
    }
    return true;
  }
};
console.log(+obj2);     // 10        -- hint is "number"
console.log(`${obj2}`); // "hello"   -- hint is "string"
console.log(obj2 + ''); // "true"    -- hint is "default"</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af47cbcf3a700411d50a4a2de6012358/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">请谈谈你对线程可见性及volatile关键字的理解？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4694a674b40b02fe2f7036c997d1261/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">老卫带你学---leetcode刷题(1096. 花括号展开 II)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>