<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>hu不变矩--python - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="hu不变矩--python" />
<meta property="og:description" content="由于网上关于Hu矩的定义的内容较多，代码实现部分又多为matlab、C&#43;&#43;或者opencv等，因此本文将主要介绍如何用python实现Hu矩的提取。后续可能会利用Hu矩进行图片分类以及平移、旋转不变性的实验，有时间做的话到时候会放上来结果。 本篇博客内容参考图像的七个不变矩 可用于图像的匹配中的matlab代码，在其基础上进行修改而成。
#-*-coding:utf-8-*- import cv2 from datetime import datetime import numpy as np np.set_printoptions(suppress=True) def humoments(img_gray): &#39;&#39;&#39; 由于7个不变矩的变化范围很大,为了便于比较,可利用取对数的方法进行数据压缩;同时考虑到不变矩有可能出现负值的情况,因此,在取对数之前先取绝对值 经修正后的不变矩特征具有平移 、旋转和比例不变性 &#39;&#39;&#39; # 标准矩定义为m_pq = sumsum(x^p * y^q * f(x, y)) row, col = img_gray.shape #计算图像的0阶几何矩 m00 = img_gray.sum() m10 = m01 = 0 #　计算图像的二阶、三阶几何矩 m11 = m20 = m02 = m12 = m21 = m30 = m03 = 0 for i in range(row): m10 &#43;= (i * img_gray[i])." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ef606ad9b5995ce461a50ace68624a39/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-08T16:12:08+08:00" />
<meta property="article:modified_time" content="2018-06-08T16:12:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">hu不变矩--python</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>由于网上关于Hu矩的定义的内容较多，代码实现部分又多为matlab、C++或者opencv等，因此本文将主要介绍如何用python实现Hu矩的提取。后续可能会利用Hu矩进行图片分类以及平移、旋转不变性的实验，有时间做的话到时候会放上来结果。 <br> 本篇博客内容参考<a href="https://blog.csdn.net/qq_18343569/article/details/46913501">图像的七个不变矩 可用于图像的匹配</a>中的matlab代码，在其基础上进行修改而成。</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment">#-*-coding:utf-8-*-</span>
<span class="hljs-keyword">import</span> cv2
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
np.set_printoptions(suppress=<span class="hljs-keyword">True</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">humoments</span><span class="hljs-params">(img_gray)</span>:</span>
    <span class="hljs-string">'''
    由于7个不变矩的变化范围很大,为了便于比较,可利用取对数的方法进行数据压缩;同时考虑到不变矩有可能出现负值的情况,因此,在取对数之前先取绝对值
    经修正后的不变矩特征具有平移 、旋转和比例不变性
    '''</span>
    <span class="hljs-comment"># 标准矩定义为m_pq = sumsum(x^p * y^q * f(x, y))</span>
    row, col = img_gray.shape
    <span class="hljs-comment">#计算图像的0阶几何矩</span>
    m00 = img_gray.sum()
    m10 = m01 = <span class="hljs-number">0</span>
    <span class="hljs-comment">#　计算图像的二阶、三阶几何矩</span>
    m11 = m20 = m02 = m12 = m21 = m30 = m03 = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(row):
        m10 += (i * img_gray[i]).sum()
        m20 += (i ** <span class="hljs-number">2</span> * img_gray[i]).sum()
        m30 += (i ** <span class="hljs-number">3</span> * img_gray[i]).sum()
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(col):
            m11 += i * j * img_gray[i][j]
            m12 += i * j ** <span class="hljs-number">2</span> * img_gray[i][j]
            m21 += i ** <span class="hljs-number">2</span> * j * img_gray[i][j]
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(col):
        m01 += (j * img_gray[:, j]).sum()
        m02 += (j ** <span class="hljs-number">2</span> * img_gray[:, j]).sum()
        m30 += (j ** <span class="hljs-number">3</span> * img_gray[:, j]).sum()
    <span class="hljs-comment"># 由标准矩我们可以得到图像的"重心"</span>
    u10 = m10 / m00
    u01 = m01 / m00
    <span class="hljs-comment"># 计算图像的二阶中心矩、三阶中心矩</span>
    y00 = m00
    y10 = y01 = <span class="hljs-number">0</span>
    y11 = m11 - u01 * m10
    y20 = m20 - u10 * m10
    y02 = m02 - u01 * m01
    y30 = m30 - <span class="hljs-number">3</span> * u10 * m20 + <span class="hljs-number">2</span> * u10 ** <span class="hljs-number">2</span> * m10
    y12 = m12 - <span class="hljs-number">2</span> * u01 * m11 - u10 * m02 + <span class="hljs-number">2</span> * u01 ** <span class="hljs-number">2</span> * m10
    y21 = m21 - <span class="hljs-number">2</span> * u10 * m11 - u01 * m20 + <span class="hljs-number">2</span> * u10 ** <span class="hljs-number">2</span> * m01
    y03 = m03 - <span class="hljs-number">3</span> * u01 * m02 + <span class="hljs-number">2</span> * u01 ** <span class="hljs-number">2</span> * m01
    <span class="hljs-comment"># 计算图像的归格化中心矩</span>
    n20 = y20 / m00 ** <span class="hljs-number">2</span>
    n02 = y02 / m00 ** <span class="hljs-number">2</span>
    n11 = y11 / m00 ** <span class="hljs-number">2</span>
    n30 = y30 / m00 ** <span class="hljs-number">2.5</span>
    n03 = y03 / m00 ** <span class="hljs-number">2.5</span>
    n12 = y12 / m00 ** <span class="hljs-number">2.5</span>
    n21 = y21 / m00 ** <span class="hljs-number">2.5</span>
    <span class="hljs-comment"># 计算图像的七个不变矩</span>
    h1 = n20 + n02
    h2 = (n20 - n02) ** <span class="hljs-number">2</span> + <span class="hljs-number">4</span> * n11 ** <span class="hljs-number">2</span>
    h3 = (n30 - <span class="hljs-number">3</span> * n12) ** <span class="hljs-number">2</span> + (<span class="hljs-number">3</span> * n21 - n03) ** <span class="hljs-number">2</span>
    h4 = (n30 + n12) ** <span class="hljs-number">2</span> + (n21 + n03) ** <span class="hljs-number">2</span>
    h5 = (n30 - <span class="hljs-number">3</span> * n12) * (n30 + n12) * ((n30 + n12) ** <span class="hljs-number">2</span> - <span class="hljs-number">3</span> * (n21 + n03) ** <span class="hljs-number">2</span>) + (<span class="hljs-number">3</span> * n21 - n03) * (n21 + n03) \
        * (<span class="hljs-number">3</span> * (n30 + n12) ** <span class="hljs-number">2</span> - (n21 + n03) ** <span class="hljs-number">2</span>)
    h6 = (n20 - n02) * ((n30 + n12) ** <span class="hljs-number">2</span> - (n21 + n03) ** <span class="hljs-number">2</span>) + <span class="hljs-number">4</span> * n11 * (n30 + n12) * (n21 + n03)
    h7 = (<span class="hljs-number">3</span> * n21 - n03) * (n30 + n12) * ((n30 + n12) ** <span class="hljs-number">2</span> - <span class="hljs-number">3</span> * (n21 + n03) ** <span class="hljs-number">2</span>) + (<span class="hljs-number">3</span> * n12 - n30) * (n21 + n03) \
        * (<span class="hljs-number">3</span> * (n30 + n12) ** <span class="hljs-number">2</span> - (n21 + n03) ** <span class="hljs-number">2</span>)
    inv_m7 = [h1, h2, h3, h4, h5, h6, h7]
    inv_m7 = np.log(np.abs(inv_m7))
    <span class="hljs-keyword">return</span> inv_m7

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    t1 = datetime.now()
    fp = <span class="hljs-string">'/home/mamq/images/3.jpg'</span>
    img = cv2.imread(fp)
    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    <span class="hljs-keyword">print</span> humoments(img_gray)
    <span class="hljs-keyword">print</span> datetime.now() - t1</code></pre> 
<p>结果：</p> 
<blockquote> 
 <p>[‘0.004757610794121051’, ‘1.0751006208352332e-05’, ‘5.069206342794947e-08’, ‘1.3770952298167658e-07’, ‘1.7004668315871364e-15’, ‘4.163184056113891e-10’, ‘1.1379424976439726e-14’]</p> 
</blockquote> 
<pre><code>这是之前为取对数时的结果，取对数后七个矩之间差距较小，便于后续计算。
</code></pre> 
<p>运行耗时：3.79秒，相比zernike矩耗时较长。 <br> <del>目前看来Hu矩提取出来的值都比较小，最小的甚至到了小数点后14位，看到网上也有人提出这个问题，不确定是否是代码的问题。</del></p> 
<hr> 
<p>写完这篇博客后，又尝试了下opencv自带的函数，代码与结果如下：</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment">#-*-coding:utf-8-*-</span>
<span class="hljs-keyword">import</span> cv2
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(img)</span>:</span>
    moments = cv2.moments(img)
    humoments = cv2.HuMoments(moments)
    <span class="hljs-comment"># humoments = no.log(np.abs(humoments)) # 同样建议取对数</span>
    print(humoments)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    t1 = datetime.now()    
    fp = <span class="hljs-string">'/home/mamq/images/3.jpg'</span>
    img = cv2.imread(fp)
    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    test(img_gray)
    <span class="hljs-keyword">print</span> datetime.now() - t1</code></pre> 
<p>结果：</p> 
<blockquote> 
 <p>[[1.58880283e-03] <br> [1.30795119e-07] <br> [6.01877793e-11] <br> [7.45476806e-11] <br> [4.34518625e-21] <br> [1.69631118e-14] <br> [2.46057599e-21]]</p> 
</blockquote> 
<p>运行耗时：0.13秒. <br> 对比：</p> 
<blockquote> 
 <p>可以看出，opencv自带函数效率更高，耗时非常短，但两段代码使用的都是同一张图片，但结果相差较大，还是相信opencv吧，毕竟更权威，第一段代码仅供学习参考。但从结果中可以看出来，Hu矩的值都比较小，进行不同图片的对比时如何进行距离的度量是个问题。</p> 
</blockquote> 
<p>由于最近比较忙，这篇博客写的不够严谨，故仅供参考。</p> 
<hr> 
<p>以上，欢迎交流，禁止转载。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81a20dbb879978b28361d8629418695a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java 获取对象属性的 名称、值、类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72f1302da3d6aebd42cee7c7309c7da4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">电路图的电阻值部分是DNP什么意思？？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>