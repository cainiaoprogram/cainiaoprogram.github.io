<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>elasticsearch数据库查询语句积累 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="elasticsearch数据库查询语句积累" />
<meta property="og:description" content="urisearch：uri传参查询 一、请求方式 ：
get post均可
二、用法 @ip:@port/_search?q=@text ---------不进行索引（index）查询，从所有内容中模糊查询@text @ip:@port/@index/_search?q=@text ---------在指定的索引(index)中进行查询@text
@ip:@port/@index/@type/_search?q=@text ---------在指定的索引(index)指定typ中进行查询@text 6.X版本后可以无视type
@ipes数据库的ip，若为集群任意一个节点便可@portes数据库的端口号@indexes的索引，可大致看为表名@typees 类名，6.x后可以无视_search查询固定关键字q=uri查询中的关键字@text 查询的内容，用两种用法
第一种：直接填写要查询的内容，如：test
第二种：在指定字段里查询指定内容，如：.
a:test 解释：查询a字段中内容为test的
注：当uri查询和body查询同事存在时有限执行uri的查询 request body search：请求body传传参查询 一、关键字query，查询的逻辑主体 post /_search { &#34;query&#34; : { &#34;term&#34; : { &#34;user&#34; : &#34;kimchy&#34; } } } 查询字段user内容为kimchy的数据
用法在query查询快中添加查询子句即可
与uri查询类似 url也是由ip，port，index组成，其中index也可看为一个筛选条件，指定了本次查询的查询范围
查询分为两个部分查询和筛选，查询子句的行为取决于它在查询中还是在筛选中 查询中的子句会对查询的内容进行评分，通过评分来得出所查出的内容是否匹配查询子句
筛选中的子句会对查询结果进行筛选，得出所查结果是不是需要的结果（频繁使用的过滤器会被es缓存）
GET /_search { &#34;query&#34;: { &#34;bool&#34;: { &#34;must&#34;: [ { &#34;match&#34;: { &#34;title&#34;: &#34;Search&#34; }}, { &#34;match&#34;: { &#34;content&#34;: &#34;Elasticsearch&#34; }} ], &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/017c15ce62dedb84512e121b4baf34b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-24T15:21:02+08:00" />
<meta property="article:modified_time" content="2020-11-24T15:21:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">elasticsearch数据库查询语句积累</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>urisearch：uri传参查询</h2> 
<p style="text-indent:33px;">一、请求方式 ：</p> 
<p>           get post均可</p> 
<p style="text-indent:33px;">二、用法 </p> 
<p style="text-indent:33px;">  @ip:@port/_search?q=@text      ---------不进行索引（index）查询，从所有内容中模糊查询@text   </p> 
<p style="text-indent:33px;">  @ip:@port/@index/_search?q=@text      ---------在指定的索引(index)中进行查询@text</p> 
<p> </p> 
<p style="text-indent:33px;">  @ip:@port/@index/@type/_search?q=@text      ---------在指定的索引(index)指定typ中进行查询@text 6.X版本后可以无视type</p> 
<p>     </p> 
<p style="text-indent:0;">     </p> 
<table align="left" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>@ip</td><td>es数据库的ip，若为集群任意一个节点便可</td></tr><tr><td>@port</td><td>es数据库的端口号</td></tr><tr><td>@index</td><td>es的索引，可大致看为表名</td></tr><tr><td>@type</td><td>es 类名，6.x后可以无视</td></tr><tr><td>_search</td><td>查询固定关键字</td></tr><tr><td>q=</td><td>uri查询中的关键字</td></tr><tr><td>@text</td><td> <p>查询的内容，用两种用法</p> <p>第一种：直接填写要查询的内容，如：test</p> <p>第二种：在指定字段里查询指定内容，如：.</p> <p>              a:test  解释：查询a字段中内容为test的</p> <p> </p> </td></tr></tbody></table> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<h2> </h2> 
<h2> </h2> 
<h2> </h2> 
<h2> </h2> 
<p> </p> 
<h4><span style="color:#f33b45;">注：当uri查询和body查询同事存在时有限执行uri的查询</span></h4> 
<h2>request body search：请求body传传参查询</h2> 
<h3>一、关键字query，查询的逻辑主体</h3> 
<pre><code>post /_search
{
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}</code></pre> 
<p style="text-indent:33px;">查询字段user内容为kimchy的数据</p> 
<p style="text-indent:33px;">用法在query查询快中添加查询子句即可</p> 
<p style="text-indent:33px;">与uri查询类似 url也是由ip，port，index组成，其中index也可看为一个筛选条件，指定了本次查询的查询范围</p> 
<p style="text-indent:33px;"> </p> 
<h4> </h4> 
<h4>查询分为两个部分查询和筛选，查询子句的行为取决于它在查询中还是在筛选中</h4> 
<p style="text-indent:33px;">查询中的子句会对查询的内容进行评分，通过评分来得出所查出的内容是否匹配查询子句</p> 
<p style="text-indent:33px;">筛选中的子句会对查询结果进行筛选，得出所查结果是不是需要的结果（频繁使用的过滤器会被es缓存）</p> 
<p> </p> 
<pre><code>GET /_search
{
  "query": { 
    "bool": { 
      "must": [
        { "match": { "title":   "Search"        }},
        { "match": { "content": "Elasticsearch" }}
      ],
      "filter": [ 
        { "term":  { "status": "published" }},
        { "range": { "publish_date": { "gte": "2015-01-01" }}}
      ]
    }
  }
}</code></pre> 
<p>语句解释：查询字段title是Search并且content字段是Elasticearch的数据，再数据进行筛选 status字段必须为published，publish_date时间字段大于等于2015-01-01</p> 
<p>bool对条件进行聚合：must答题相当于sql中where语句中的=，此外还有should和not must等</p> 
<p><span style="color:#f33b45;">match和term都是查询用的关键词，其中term是完全匹配，不会对参数使用分词器进行拆分，而match会对参数进行分词处理</span></p> 
<p>如      { "term":  { "a": "a b" }}  使用term只会查询a字段的分词中包含a b的内容</p> 
<p>          { "match": { "a":   "a b"}}使用match会对参数进行分词处理结果会查出 a字段分词中有a的，b的以及a b 的内容</p> 
<p>range用于时间查询的关键字</p> 
<pre><code>GET /_search
{
    "query": {
        "match_all": {}
    }
}</code></pre> 
<p>最简单的查询，查询并匹配所有的文档，并给他们添加_score为1.0</p> 
<pre><code>GET /_search
{
    "query": {
        "match_none": {}
    }
}</code></pre> 
<p>与match_all想反，查询所有但是不匹配任何文档</p> 
<h4>match查询：会对查询的参数进行分词之后查询</h4> 
<pre><code>GET /_search
{
    "query": {
        "match" : {
            "message" : {
                "query" : "this is a test",
                "analyzer" : "my_analyzer"
            }
        }
    }
}</code></pre> 
<pre><code class="language-html">analyzer：可以指定那个分词器来对参数进行分词</code></pre> 
<p>高级参数：operator</p> 
<pre><code>GET /_search
{
    "query": {
        "match" : {
            "message" : {
                "query" : "this is a test",
                "operator" : "and"
            }
        }
    }
}</code></pre> 
<p>operator默认为or，他可以控制match查询中各个分词在查询中的判断关系比如：默认情况下例子中的参数会被分词为 this，is，a，test，数据中message字段的索引中只要包含着四个分词中任意一个可以被查出，若改为and，则message索引中需要包含这个四个分词才会被查出</p> 
<pre><code>{
    "query":{
        "match":{
            "name":{
                "query":"hello world",
                "minmum_should_match":"50%"
            }
        }
    }
}</code></pre> 
<p>minmum_should_match：最小匹配度，如上图50%即一般匹配度，name字段的索引包含hello或者world都可以被查出，若改为100%则该字段与operator的and效果相同</p> 
<pre><code class="language-html">fuzziness：略</code></pre> 
<pre><code class="language-html">cutoff_frequency：略</code></pre> 
<p><span style="color:#f33b45;">Synonyms：略</span></p> 
<h4><span style="color:#f33b45;">match_phrase：分词后的查询必须即包含所有分词，分词必须相邻，且顺序需要正确，可以认为为输入参数的全匹配</span></h4> 
<h4><span style="color:#f33b45;">match_phrase_prefix：</span></h4> 
<pre><code>

GET /_search
{
    "query": {
        "match_phrase_prefix" : {
            "message" : {
                "query" : "quick brown f",
                "max_expansions" : 10
            }
        }
    }
}

</code></pre> 
<p>与<span style="color:#f33b45;">match_phrase相似，可对参数最后一位进行向后匹配比如例子中的参数 ‘quick brown f’就可以查出‘quick brown for’等</span></p> 
<p>max_expansions设置最大的匹配长度</p> 
<h4>multi_match与match相似，但是multi_match更适合于多字段查询</h4> 
<pre><code>GET /_search
{
  "query": {
    "multi_match" : {
      "query":    "hello world", 
      "fields": [ "subject", "message" ] 
    }
  }
}</code></pre> 
<p>对subject和message进行查询查询的参数是hello world，相当于match 的</p> 
<pre><code>{
    "query": {
        "bool": {
            "should": [
                {"match": {
                        "subject": "hello world"
                        
                    }},
                    {"match": {
                        "message": "hello world"
                    }}
            ]
        }
    }
}</code></pre> 
<p> </p> 
<p>multi_match查询的类型:编辑<br> multi_match查询内部执行的方式取决于类型参数，可以设置为:</p> 
<pre><code>GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "brown fox",
      "type":       "best_fields",
      "fields":     [ "subject", "message" ],
      "tie_breaker": 0.3
    }
  }
}</code></pre> 
<table border="0" cellpadding="4"><tbody><tr><td style="vertical-align:top;"> <p><code>best_fields</code></p> </td><td style="vertical-align:top;"> <p>multi默认使用此规则，对多个字段分别评分使用其中评分最高的最为本条数据的评分</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>most_fields</code></p> </td><td style="vertical-align:top;"> <p>对每个字段进行评分，合并所有字段的评分作为本条数据的评分</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>cross_fields</code></p> </td><td style="vertical-align:top;"><span style="color:#f33b45;">讲参数分为多个分词，将所查询的字段的索引页看做是一个字段的索引</span></td></tr><tr><td style="vertical-align:top;"> <p><code>phrase</code></p> </td><td style="vertical-align:top;"> <p>相当于对每个字段分别进行<code>match_phrase查询</code></p> </td></tr><tr><td style="vertical-align:top;"> <p><code>phrase_prefix</code></p> </td><td style="vertical-align:top;"> <p>相当于对每个字段进行一次<code>phrase_prefix查询</code></p> </td></tr></tbody></table> 
<h3>Query String Query:让你可以做用字符串来编写筛选逻辑</h3> 
<pre><code>GET /_search
{
    "query": {
        "query_string" : {
            "default_field" : "content",
            "query" : "hello AND world"
        }
    }
}</code></pre> 
<p style="text-indent:33px;">语句解释：查询content字段的索引中同事包含hello和world的</p> 
<p style="text-indent:33px;">query_string项目介绍</p> 
<p style="text-indent:33px;"><code>query：查询的参数可以使用空格分隔省略掉AND和OR 但是这样的话会默认使用默认连接OR</code></p> 
<p style="text-indent:33px;"><code>default_field</code>：查询的字段</p> 
<p style="text-indent:33px;">fields：查询多个字段时使用 用法：fields" : ["age", "name"]</p> 
<p style="text-indent:33px;">default_operator：默认连接符 若在query里使用空格使用空格分隔没有连接关键词的会默认使用此项</p> 
<p style="text-indent:33px;"><code>analyzer</code>：指定对参数进行分词时的分词器</p> 
<h3>Simple Query String Query：官方自称的比Query String Query更加方便的方法</h3> 
<p>与Query String Query项目逻辑语被替换</p> 
<p>+替换AND</p> 
<p>|替换OR</p> 
<p>-替换</p> 
<h3><code>term：会在倒排索引中查找到确切的参数，与match不同term的参数不会被分词器拆分</code></h3> 
<pre><code>POST _search
{
  "query": {
    "term" : { "user" : "hello world" } 
  }
}</code></pre> 
<p>解释：查询字段user，索引中有hello world 的数据</p> 
<h3>terms：term的附属匹配版</h3> 
<pre><code>GET /_search
{
    "query": {
        "terms" : { "user" : ["kimchy", "elasticsearch"]}
    }
}</code></pre> 
<p>解释：查询字段user中内容有kimchy或者elasticsearch的数据</p> 
<p> </p> 
<p><span style="color:#f33b45;">搞不明白：</span></p> 
<table border="0" cellpadding="4"><tbody><tr><td style="vertical-align:top;"> <p><code>index</code></p> </td><td style="vertical-align:top;"> <p>The index to fetch the term values from.</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>type</code></p> </td><td style="vertical-align:top;"> <p>The type to fetch the term values from.</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>id</code></p> </td><td style="vertical-align:top;"> <p>The id of the document to fetch the term values from.</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>path</code></p> </td><td style="vertical-align:top;"> <p>The field specified as path to fetch the actual values for the <code>terms</code> filter.</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>routing</code></p> </td><td style="vertical-align:top;"> <p>A custom routing value to be used when retrieving the external terms doc.</p> </td></tr></tbody></table> 
<h3>Range Query：对进行范围查询</h3> 
<pre><code>GET _search
{
    "query": {
        "range" : {
            "age" : {
                "gte" : 10,
                "lte" : 20,
                "boost" : 2.0
            }
        }
    }
}</code></pre> 
<p>解释：查询字段age在范围10到20直接的数据</p> 
<table border="0" cellpadding="4"><tbody><tr><td style="vertical-align:top;"> <p><code>gte</code></p> </td><td style="vertical-align:top;"> <p>大于等于</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>gt</code></p> </td><td style="vertical-align:top;"> <p>大于</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>lte</code></p> </td><td style="vertical-align:top;"> <p>小于等于</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>lt</code></p> </td><td style="vertical-align:top;"> <p>小于</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>boost</code></p> </td><td style="vertical-align:top;"> <p><code>查询的分值</code></p> </td></tr></tbody></table> 
<p> </p> 
<p><span style="color:#f33b45;">注：日期数学暂时省略</span></p> 
<h3>Exists Query：</h3> 
<h3>exists 根据字段是不是存在进行查询，实际可以认为是根据相关子弹内容是不是存在，因为若查询的字段内容是null或者<code>[]也不会查出</code></h3> 
<pre><code>GET /_search
{
    "query": {
        "exists": {
            "field": "user"
        }
    }
}</code></pre> 
<p>查询包含字段user（包含user字段且user字段不是null或者<code>[]</code>）的数据</p> 
<h3>Prefix Query：前缀查询指定字段的前缀进行查询</h3> 
<pre><code>GET /_search
{ "query": {
    "prefix" : { "user" : "ki" }
  }
}</code></pre> 
<p>解释：查询user字段前缀为ki的数据</p> 
<pre><code>GET /_search
{ "query": {
    "prefix" : { "user" :  { "value" : "ki", "boost" : 2.0 } }
  }
}</code></pre> 
<p>本查询同样可以设置分数</p> 
<h3>Wildcard Query：可以使用一个或者多个通配符进行查询</h3> 
<pre><code>GET /_search
{
    "query": {
        "wildcard": {
            "user": {
                "value": "ki*y",
                "boost": 1.0,
                "rewrite": "constant_score"
            }
        }
    }
}</code></pre> 
<p>查询user字段以ki开头并且以y结尾的数据</p> 
<p>通配符：</p> 
<p>?   单个字符的通配符</p> 
<p>*   零个到多个字符的通配符</p> 
<p>rewrite：指定es数据库对你的低效查询语句进行重写的方式   <span style="color:#f33b45;">暂时省略</span></p> 
<h3>Regexp Query：允许查询中使用正则表达式进行，规则参考正则表达式规则</h3> 
<pre><code>GET /_search
{
    "query": {
        "regexp":{
            "name.first": "s.*y",
            "max_determinized_states":2000
        }
    }
}</code></pre> 
<p>解释：查询name下的first字段以s开头y结尾的数据</p> 
<pre>max_determinized_states:允许正则字段的长度默认为1000，可以通过这个字段设置正则字段的长度</pre> 
<h3>Fuzzy Query：是一种非常模糊得查询方式</h3> 
<pre><code>GET /_search
{
    "query": {
        "fuzzy" : {
            "user" : {
                "value": "ki",
                "boost": 1.0,
                "fuzziness": 2,
                "prefix_length": 0,
                "max_expansions": 100
            }
        }
    }
}</code></pre> 
<p>fuzziness：允许被模糊得字符数</p> 
<p><code>prefix_length：不会被模糊的首字母数目</code></p> 
<p><code>max_expansions：模糊查询讲扩展到的最大的词语数</code></p> 
<h3>Type Query：类型查询（6.*版本type已经只能设置一个了，顾本项基本可以看为别名查询了）</h3> 
<pre><code>GET /_search
{
    "query": {
        "type" : {
            "value" : "_doc"
        }
    }
}</code></pre> 
<p>解释，查询类型是_doc的数据</p> 
<h3>Ids Query：根据数据的id进行查询，这个id并不是我们自己规定的id 而是es数据库中每条数据的_id字段</h3> 
<pre><code>GET /_search
{
    "query": {
        "ids" : {
            "type" : "_doc",
            "values" : ["1", "4", "100"]
        }
    }
}</code></pre> 
<p>解释：查询id 是1或者id是4或者id是100的数据</p> 
<h3>Constant Score Query：评分性查询，可以让里面的过滤也参与到评分中（<span style="color:#f33b45;">不确定</span>）</h3> 
<pre><code>GET /_search
{
    "query": {
        "constant_score" : {
            "filter" : {
                "term" : { "user" : "kimchy"}
            },
            "boost" : 1.2
        }
    }
}</code></pre> 
<p>创建一个筛选器筛选出user字段是kimchy的数据，并计入boost中设置的分数</p> 
<h3>Bool Query：一种聚合查询，一种与其他查询组成的组合查询</h3> 
<table border="1" cellpadding="4"><thead><tr><th>Occur</th><th>Description</th></tr></thead><tbody><tr><td style="vertical-align:top;"> <p><code>must</code></p> </td><td style="vertical-align:top;">查询子句中的条件比距出现在结果中，有点相当于sql中的=</td></tr><tr><td style="vertical-align:top;"> <p><code>filter</code></p> </td><td style="vertical-align:top;"> <p>过滤器，忽略插叙中的到的分数，过滤的执行在查询之后</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>should</code></p> </td><td style="vertical-align:top;"> <p>相当于sql中使用or连接但是又有区别</p> </td></tr><tr><td style="vertical-align:top;"> <p><code>must_not</code></p> </td><td style="vertical-align:top;"> <p>查询子句中不能出现在查询中 类似于sql中的！=</p> </td></tr></tbody></table> 
<pre><code>POST _search
{
  "query": {
    "bool" : {
      "must" : {
        "term" : { "user" : "kimchy" }
      },
      "filter": {
        "term" : { "tag" : "tech" }
      },
      "must_not" : {
        "range" : {
          "age" : { "gte" : 10, "lte" : 20 }
        }
      },
      "should" : [
        { "term" : { "tag" : "wow" } },
        { "term" : { "tag" : "elasticsearch" } }
      ],
      "minimum_should_match" : 1,
      "boost" : 1.0
    }
  }
}</code></pre> 
<p>查询user字段是kimchy，并且age不在10到20之间，并且tag是tech的，并且tag是wow或者tag是elasticsearch的数据</p> 
<p>minimum_should_match：should最小的匹配条数，默认是0，意味着若是不设置的话should字段形同虚设 </p> 
<p>filter若不指定分值的话不会影响数据的最后的评分</p> 
<h3>Dis Max Query<span style="color:#f33b45;">啥玩意没搞明白</span></h3> 
<h3>Function Score Query<span style="color:#f33b45;">啥玩意没搞明白</span></h3> 
<h3>Boosting Query降分查询，降低与not不同它只是降低了符合条件的数据的分数，并不会筛选掉数据</h3> 
<pre><code>GET /_search
{
    "query": {
        "boosting" : {
            "positive" : {
                "term" : {
                    "field1" : "value1"
                }
            },
            "negative" : {
                 "term" : {
                     "field2" : "value2"
                }
            },
            "negative_boost" : 0.2
        }
    }
}</code></pre> 
<p><span style="color:#f33b45;">解释：解释不出来我也没搞懂这个怎么用</span></p> 
<h3>Nested Query嵌套查询，子属性查询</h3> 
<pre><code>GET /my_index/_search
{
    "query": {
        "nested" : {
            "path" : "obj1",
            "query" : {
                "bool" : {
                    "must" : [
                        { "match" : {"obj1.name" : "blue"} },
                        { "range" : {"obj1.count" : {"gt" : 5}} }
                    ]
                }
            },
            "score_mode" : "avg"
        }
    }
}</code></pre> 
<p>查询obj1竖向下面name字段是blue且count大于5的的数据</p> 
<p>score_mode子类查询对根父类评分的影响策略</p> 
<p><code>avg</code> (Default)</p> 
<p>使用所有匹配子对象的平均分数</p> 
<p><code>max</code></p> 
<p>使用所有匹配子对象的最高分数</p> 
<p><code>min</code></p> 
<p>使用所有匹配子对象的最低分数</p> 
<p><code>none</code></p> 
<p>不适用子类的分数，父类复制分数为0</p> 
<p><code>sum</code></p> 
<p>所有匹配到的子类的分数相加</p> 
<h3>Has Child Q<span style="color:#f33b45;">uery：略</span></h3> 
<h3>Has Parent Query<span style="color:#f33b45;">：略</span></h3> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>二、关键字from、size，分页</p> 
<p>.........................未完待续且未验证</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e3f88ccd51de76e9572b2d7bd5661a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">XXX packages are looking for funding   run `npm fund` for details</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/afa2093bc9da9c47f3a49388cf65abcf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">servlet4.0.1与jsp2.3.3依赖包的导入</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>