<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java面试必懂知识点总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java面试必懂知识点总结" />
<meta property="og:description" content="1、介绍一下面向对象 面向对象是基于万物皆对象。
封装：隐藏方法的具体实现细节，提供出一个公共接口给API调用，提高了代码的可维护性，和安全性。
继承：继承就是在已知类上建立新类的技术，子类继承父类的方法，子类也可以有自己的属性和方法。但不能选择性地继承父类。通 过使用继承可以提高代码复用性。继承是多态的前提。
多态：父类后接口定义的引用变量可以指向子类或具体实现类的实例对象。Java实现多态有三个必要条件：继承、重写、向上转型。
编译时多态：方法的重载运行时多态：方法的重写 2、Java语言的反射机制 Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性的方法，对于任何一个对象，都能调用它的任意属性和方法，这种在动态的获取类信息和调用对象的方法和属性的功能，称为Java语言的反射机制。
实现反射机制的三种反射： 1.通过new对象实现反射机制
2.通过路径实现反射机制
3.通过类名实现反射机制
1 public class Student { 2 private int id; 3 String name; 4 protected boolean sex; 5 public float score; 6 } 1 public class Get { 2 //获取反射机制三种方式 3 public static void main(String[] args) throws ClassNotFoundException { 4 //方式一(通过建立对象) 5 Student stu = new Student(); 6 Class classobj1 = stu.getClass(); 7 System.out.println(classobj1.getName()); 8 //方式二（所在通过路径‐相对路径） 9 Class classobj2 = Class." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a649b170a5891be71d195917f7433545/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-12T11:48:47+08:00" />
<meta property="article:modified_time" content="2022-07-12T11:48:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java面试必懂知识点总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_0"></a>1、介绍一下面向对象</h3> 
<ul><li> <p>面向对象是基于万物皆对象。</p> </li><li> <p>封装：隐藏方法的具体实现细节，提供出一个公共接口给API调用，提高了代码的可维护性，和安全性。</p> </li><li> <p>继承：继承就是在已知类上建立新类的技术，子类继承父类的方法，子类也可以有自己的属性和方法。但不能选择性地继承父类。通 过使用继承可以提高代码复用性。继承是多态的前提。</p> </li><li> <p>多态：父类后接口定义的引用变量可以指向子类或具体实现类的实例对象。Java实现多态有三个必要条件：继承、重写、向上转型。</p> 
  <ul><li>编译时多态：方法的重载</li><li>运行时多态：方法的重写</li></ul> </li></ul> 
<h3><a id="2Java_13"></a>2、Java语言的反射机制</h3> 
<p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性的方法，对于任何一个对象，都能调用它的任意属性和方法，这种在动态的获取类信息和调用对象的方法和属性的功能，称为Java语言的反射机制。</p> 
<h4><a id="_17"></a>实现反射机制的三种反射：</h4> 
<p>1.通过new对象实现反射机制</p> 
<p>2.通过路径实现反射机制</p> 
<p>3.通过类名实现反射机制</p> 
<pre><code class="prism language-java"><span class="token number">1</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">2</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
<span class="token number">3</span>  <span class="token class-name">String</span> name<span class="token punctuation">;</span>
<span class="token number">4</span>  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> sex<span class="token punctuation">;</span>
<span class="token number">5</span>  <span class="token keyword">public</span> <span class="token keyword">float</span> score<span class="token punctuation">;</span>
<span class="token number">6</span>  <span class="token punctuation">}</span>
<span class="token number">1</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Get</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">2</span>   <span class="token comment">//获取反射机制三种方式</span>
<span class="token number">3</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">4</span>   <span class="token comment">//方式一(通过建立对象)</span>
<span class="token number">5</span>   <span class="token class-name">Student</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">6</span>   <span class="token class-name">Class</span> classobj1 <span class="token operator">=</span> stu<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">7</span>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classobj1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">8</span>   <span class="token comment">//方式二（所在通过路径‐相对路径）</span>
<span class="token number">9</span>   <span class="token class-name">Class</span> classobj2 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"fanshe.Student"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">10</span>  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classobj2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">11</span>  <span class="token comment">//方式三（通过类名）</span>
<span class="token number">12</span>  <span class="token class-name">Class</span> classobj3 <span class="token operator">=</span> <span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
<span class="token number">13</span>  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classobj3<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">14</span>  <span class="token punctuation">}</span>
<span class="token number">15</span>  <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3_49"></a>3、接口和抽象类的区别</h3> 
<table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>声明</td><td>抽象类使用abstract关键字声明</td><td>接口使用interface关键字声明</td></tr><tr><td>实现</td><td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td><td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>访问修饰符</td><td>抽象类中的方法可以是任意访问修饰符</td><td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td></tr><tr><td>多继承</td><td>一个类最多只能继承一个抽象类</td><td>一个类可以实现多个接口</td></tr><tr><td>字段声明</td><td>抽象类的字段声明可以是任意的</td><td>接口的字段默认都是 static 和 final 的</td></tr></tbody></table> 
<h3><a id="4List_62"></a>4、List去重的实现</h3> 
<p>1、使用两个for循环实现list 去重（有序）</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span> <span class="token function">removeDuplicationByFor</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>2、使用HashSet实现list去重（无序）</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span> <span class="token function">removeDuplicationByHashSet</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token class-name">HashSet</span> hashSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//把list所有元素清空</span>
    list<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token comment">//把hashSet对象添加到list集合</span>
    list<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>hashSet<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>3、使用List集合contains方法循环遍历</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span> <span class="token function">removeDuplicationByContains</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> newList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">boolean</span> isContains <span class="token operator">=</span> newList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isContains<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            newList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    list<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>newList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>4、使用TreeSet实现List去重（有序）</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span> <span class="token function">removeDuplicationByTreeSet</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token class-name">TreeSet</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//清空list 结合的所有元素</span>
    list<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token comment">//把HashSet对象添加到list集合</span>
    list<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>5、使用java8的新特性 实现list去重（有序）</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span> <span class="token function">removeDuplicationByStream</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> newlist1 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newlist1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="5_133"></a>5、线程的生命周期</h3> 
<p><img src="https://images2.imgbox.com/eb/bc/iWQ2KjLt_o.jpg" alt="img"></p> 
<h4><a id="_141"></a>线程的五个状态</h4> 
<p><strong>新建状态（New）</strong>：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p> 
<p><strong>就绪状态（Runnable）</strong>：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p> 
<p><strong>运行状态（Running）</strong>：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p> 
<p><strong>阻塞状态（Blocked）</strong>：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p> 
<p>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p> 
<p>2.同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p> 
<p>3.其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p> 
<p><strong>死亡状态（Dead）</strong>：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p> 
<h3><a id="6_wait__sleep__159"></a>6、线程里面 wait 和 sleep 方法的区别</h3> 
<p>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p> 
<p>sleep 是Thread 类的静态本地方法，wait 则是Object 类的本地方法。</p> 
<h3><a id="7Run_Start__165"></a>7、线程Run（） Start（） 的区别</h3> 
<p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的， run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。 start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。 start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待 run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</p> 
<p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接使用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法</p> 
<h3><a id="8_171"></a>8、创建线程的方法</h3> 
<p>创建线程有四种方式：</p> 
<ul><li>继承 Thread 类；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>使用 Executors 工具类创建线程池继承 Thread 类</li></ul> 
<p>步骤</p> 
<ol><li>定义一个Thread类的子类，重写run方法，将相关逻辑实现，run()方法</li></ol> 
<p>就是线程要执行的业务逻辑方法</p> 
<ol start="2"><li> <p>创建自定义的线程子类对象</p> </li><li> <p>调用子类实例的star()方法来启动线程</p> </li></ol> 
<pre><code>1 public class MyThread extends Thread {
2 
3	@Override
4	public void run() {
5	System.out.println(Thread.currentThread().getName() + " run()方法正在执行...");
6	}
7
8 }
</code></pre> 
<pre><code>1 public class TheadTest {
2
3	public static void main(String[] args) {
4	MyThread myThread = new MyThread();
5	myThread.start();
6	System.out.println(Thread.currentThread().getName() + " main()方法执行结束");
7	}
8
9 }
10
</code></pre> 
<p>运行结果</p> 
<pre><code>1 main main()方法执行结束 
2 Thread‐0 run()方法正在执行... 
</code></pre> 
<h4><a id="_Runnable__223"></a>实现 Runnable 接口</h4> 
<p>步骤</p> 
<ol><li> <p>定义Runnable接口实现类MyRunnable，并重写run()方法</p> </li><li> <p>创建MyRunnable实例myRunnable，以myRunnable作为target创建Thead对象，该Thread对象才是真正的线程对象</p> </li><li> <p>调用线程对象的start()方法</p> </li></ol> 
<pre><code>1 public class MyRunnable implements Runnable {
2
3	@Override
4	public void run() {
5	System.out.println(Thread.currentThread().getName() + " run()方法执行中...");
6	}
7
8 }
1 public class RunnableTest {
2
3	public static void main(String[] args) {
4	MyRunnable myRunnable = new MyRunnable();
5	Thread thread = new Thread(myRunnable);
6	thread.start();
7	System.out.println(Thread.currentThread().getName() + " main()方法执行完成");
8	}
9
10 }
</code></pre> 
<p>执行结果</p> 
<pre><code>1	main main()方法执行完成
2	Thread‐0 run()方法执行中...
</code></pre> 
<h4><a id="_Callable__261"></a>实现 Callable 接口</h4> 
<p>步骤</p> 
<ol><li> <p>创建实现Callable接口的类myCallable</p> </li><li> <p>以myCallable为参数创建FutureTask对象</p> </li><li> <p>将FutureTask作为参数创建Thread对象</p> </li><li> <p>调用线程对象的start()方法</p> </li></ol> 
<pre><code>1 public class MyCallable implements Callable&lt;Integer&gt; {
2
3	@Override
4	public Integer call() {
5	System.out.println(Thread.currentThread().getName() + " call()方法执行中...");
6	return 1;
7	}
8
9 }
</code></pre> 
<pre><code>1 public class CallableTest {
2
3	public static void main(String[] args) {
4	FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyCallable());
5	Thread thread = new Thread(futureTask);
6	thread.start();
7
8	try {
9	Thread.sleep(1000);
10	System.out.println("返回结果 " + futureTask.get());
11	} catch (InterruptedException e) {
12	e.printStackTrace();
13	} catch (ExecutionException e) {
14	e.printStackTrace();
15	}
16	System.out.println(Thread.currentThread().getName() + " main()方法执行完成");
17	}
18
19 }

</code></pre> 
<p>执行结果</p> 
<pre><code>1	Thread‐0 call()方法执行中...
2	返回结果 1
3	main main()方法执行完成
</code></pre> 
<h4><a id="_Executors__316"></a>使用 Executors 工具类创建线程池</h4> 
<p>Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。主要有newFixedThreadPool，newCachedThreadPool，newSingleThreadExecutor，newScheduledThreadPool，后续详细介绍这四种线程池</p> 
<pre><code>1 public class MyRunnable implements Runnable {
2
3	@Override
4	public void run() {
5	System.out.println(Thread.currentThread().getName() + " run()方法执行中...");
6	}
7
8 }
</code></pre> 
<pre><code>1 public class SingleThreadExecutorTest {
2 
3  public static void main(String[] args) { 
4  ExecutorService executorService = Executors.newSingleThreadExecutor(); 
5  MyRunnable runnableTest = new MyRunnable(); 
6	for (int i = 0; i &lt; 5; i++) {
7	executorService.execute(runnableTest);
8	}
9
10	System.out.println("线程任务开始执行");
11	executorService.shutdown();
12	}
13
14 }
</code></pre> 
<p>执行结果</p> 
<pre><code>1	线程任务开始执行
2	pool‐1‐thread‐1 is running...
3	pool‐1‐thread‐1 is running...
4	pool‐1‐thread‐1 is running...
5	pool‐1‐thread‐1 is running...
6	pool‐1‐thread‐1 is running...
</code></pre> 
<h3><a id="9JDBC_359"></a>9、原生JDBC的执行流程</h3> 
<p>1.注册驱动程序：Class.forName(“com.mysql.jdbc.Driver”);<br> 2.使用驱动管理类来获取连接conn = DriverManager.getConnection.<br> 3.创建Statement stmt = conn.getStatement;(sql会话对象)<br> 4.执行sql : stmt.executeQuery(sql);<br> 5.处理结果集：ResultSet，如果SQL前如果有参数值就设置参数值setXXX()<br> 7.关闭连接。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> JDBC <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/day16"</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> user <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> password <span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//1.注册驱动程序</span>
        <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//2.使用驱动管理类来获取连接</span>
        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//3.准备sql</span>
        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from student "</span><span class="token punctuation">;</span>
        <span class="token comment">//4.在连接的基础上，创建Statement</span>
        <span class="token class-name">Statement</span> stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//5.执行sql</span>
        <span class="token class-name">ResultSet</span> set <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//6.关闭资源</span>
        set<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="10_394"></a>10、事务的并发问题</h3> 
<p>多个事务访问同一个数据库的时候，会产生事务的并发问题。</p> 
<p>并发问题：</p> 
<blockquote> 
 <p>脏读：一个事务读取到了其他事务还没有提交的数据，读到了其他事务 “update”的数据</p> 
 <p>不可重复读：一个事务多次读取，结果不一样</p> 
 <p>幻读：一个事务读取到了其他事务还没有提交的数据，读到了其他事务 “insert”的数据</p> 
</blockquote> 
<p>如何解决并发问题？</p> 
<p>通过设置<strong>隔离级别</strong>来解决并发问题：</p> 
<table><thead><tr><th align="left"></th><th>脏读</th><th align="left">不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td align="left">read uncommitted: 读未提交</td><td>×</td><td align="left">×</td><td>√</td></tr><tr><td align="left">read committed：读已提交</td><td>√</td><td align="left">×</td><td>×</td></tr><tr><td align="left">repeatable read：可重复读</td><td>√</td><td align="left">√</td><td>×</td></tr><tr><td align="left">serializable：串行化</td><td>√</td><td align="left">√</td><td>√</td></tr></tbody></table> 
<h3><a id="11_417"></a>11、事务的三大范式</h3> 
<p>1、第一范式（列不可再分）：原子性的操作，所有字段值都是不可分解的原子值。</p> 
<p>2、第二范式（属性完全依赖于主键）：前提是满足第一范式的情况下，一个表中只能保存一种数据，不可以把多种数据保存在同一张表中。</p> 
<p>3、第三范式（属性直接依赖于主键）：前提是满足第一范式和第二范式的情况下，每一列数据都和主键直接相关，而不能间接相关。</p> 
<h3><a id="12_425"></a>12、事务的特性</h3> 
<p>Atomicity原子性：一组事务操作，要么成功，要么失败。</p> 
<p>Consistency一致性：两个事务做多次操作，最后的结果始终保持一致。</p> 
<p>Isolation隔离性：事务执行操作，不受其他事务的干扰</p> 
<p>Durability持久性：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。</p> 
<h3><a id="13_435"></a>13、左链接、右链接</h3> 
<p>数据库中的左连接和右连接的区别可以概括为一句话来表示即左连接where只影响右表，右连接where只影响到左表。</p> 
<p><strong>左连接（Left Join）</strong></p> 
<pre><code>select * from tbl1 Left Join tbl2 where tbl1.ID = tbl2.ID
</code></pre> 
<p>左连接后的检索结果是显示tbl1的所有数据和tbl2中满足where 条件的数据。<br> 简言之 Left Join影响到的是右边的表</p> 
<p><strong>右连接（Right Join）</strong></p> 
<pre><code>select * from tbl1 Right Join tbl2 where tbl1.ID = tbl2.ID
</code></pre> 
<p>检索结果是tbl2的所有数据和tbl1中满足where 条件的数据。<br> 简言之 Right Join影响到的是左边的表。</p> 
<p><strong>内连接（inner join）</strong></p> 
<pre><code>select * FROM tbl1 INNER JOIN tbl2 ON tbl1.ID = tbl2.ID
</code></pre> 
<p>它的功能和<code> select * from tbl1</code>,<code>tbl2 where tbl1.id=tbl2.id</code>相同。</p> 
<h3><a id="14MySQL_465"></a>14、MySQL中的最左匹配原则</h3> 
<p>最左匹配原则就是指在联合索引中，如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个<strong>联合索引</strong>去进行匹配。</p> 
<h3><a id="15mybatis__469"></a>15、mybatis 自增主键</h3> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insertAuthor<span class="token punctuation">"</span></span> <span class="token attr-name">useGeneratedKeys</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  insert into Author xxx
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>useGeneratedKeys=“true” 使用自增主键<br> keyProperty=“id” 自增主键返回到映射类的id属性</p> 
<h3><a id="16maven_install_package_480"></a>16、maven install package</h3> 
<p>Maven install 安装指令，其做了<strong>两件</strong>事情：</p> 
<p><strong>1.</strong> 将项目打包（jar/war），将打包结果放到项目下的 <strong>target</strong> 目录下</p> 
<p><strong>2.</strong> 同时将上述打包结果放到<strong>本地仓库</strong>的相应目录中，供其他项目或模块引用</p> 
<p>Maven package 打包指令，其就做了一件事：</p> 
<p><strong>1.</strong> 将项目打包（jar/war），将打包结果放到项目下的 <strong>target</strong> 目录下 （也要先clean）</p> 
<h3><a id="17_Spring_IOC_AOP_494"></a>17、说一说 Spring IOC AOP</h3> 
<p><strong>IOC</strong></p> 
<p>控制反转：原来对象是有使用者来进行控制的，有了Spring之后，可以把整个对象交给spring来帮我们进行管理。</p> 
<p>DI：依赖注入，把对象的属性的值注入到具体对象中，@Autowired，populateBean完成属性值的注入。</p> 
<p>容器：使用Map结构来存储，在spring中一般存在三级缓存，singletonObjects存放完整的对象，整个Bean的声明周期，从创建到销毁全部都是由容器来管理的。</p> 
<p><strong>AOP</strong></p> 
<p>aop是ioc的一个扩展功能，现有的ioc，再有的aop，aop只是在ioc整个流程中新增的一个扩展点而已–》BeanPostProcess</p> 
<h3><a id="18AOP_508"></a>18、AOP的实现方式，原理</h3> 
<p><strong>一种是采用声明的方式来实现（基于XML），一种是采用注解的方式来实现（基于AspectJ）</strong>。</p> 
<p>可以读一下：</p> 
<p>[Spring系列之AOP实现的两种方式 - 平凡希 - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaoxi/p/5981514.html#:~:text=AOP常用的实现方式有两种，,一种是采用声明的方式来实现（基于XML），一种是采用注解的方式来实现（基于AspectJ） 。)</p> 
<h3><a id="19AOP__516"></a>19、AOP的代理模式 原理</h3> 
<p>[AOP代理模式 - 眼泪，还是流了 - 博客园 (cnblogs.com)](https://www.cnblogs.com/yang82/p/8098982.html#:~:text=AOP代理模式 1 、静态代理：就是设计模式中的proxy模式 2,、动态代理：jdk1.5中提供，利用反射。 … 3 、利用cglib)</p> 
<h3><a id="20spring_522"></a>20、谈一下spring事务传播？</h3> 
<p>传播特性有几种？7种 Required,Requires_new,nested,Support,Not_Support,Never,Mandatory</p> 
<p>总：</p> 
<p>事务的传播特性指的是不同方法的嵌套调用过程中，事务应该如何进行处理，是用同一个事 务还是不同的事务，当出现异常的时候会回滚还是提交，两个方法之间的相关影响，在日常工作中，使 用比较多的是required，Requires_new,nested</p> 
<p>分：</p> 
<p>1、先说事务的不同分类，可以分为三类：支持当前事务，不支持当前事务，嵌套事务</p> 
<p>2、如果外层方法是required，内层方法是，required,requires_new,nested</p> 
<p>3、如果外层方法是requires_new，内层方法是，required,requires_new,nested</p> 
<p>4、如果外层方法是nested，内层方法是，required,requires_new,nested</p> 
<h3><a id="21SpringMVC_540"></a>21、SpringMVC的工作流程</h3> 
<p><a href="https://blog.csdn.net/weixin_53601359/article/details/114460179">(1条消息) SpringMVC工作流程 – 详解_布诺i的博客-CSDN博客_springmvc工作流程</a></p> 
<h3><a id="22SpringBoot_546"></a>22、SpringBoot的核心配置文件</h3> 
<p>Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。</p> 
<p>application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。</p> 
<p>bootstrap 配置文件有以下几个应用场景。</p> 
<ul><li>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；</li><li>一些固定的不能被覆盖的属性；</li><li>一些加密/解密的场景；</li></ul> 
<h3><a id="_560"></a>补充：深克隆、浅克隆</h3> 
<p><a href="https://blog.nowcoder.net/n/d13266d7862140eba381c989f2dbb53e" rel="nofollow">深浅克隆面试题汇总——附详细答案_牛客博客 (nowcoder.net)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e5ea7bff56ff052a51bfd95f6787c8d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度之眼（十一）——矩阵对角化及二次型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b57fc78eb100b49cfca225a31aa67fb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决vscode&#34;无法加载文件 ，因为在此系统上禁止运行脚本&#34;报错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>