<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;语法总结查询 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;语法总结查询" />
<meta property="og:description" content="How to Program in C&#43;&#43; You may copy this file for noncommercial use. The latest versionis located at cs.fit.edu/~mmahoney/cse2050/how2cpp.html updatedApr. 14, 2010. Please report errors to Matt Mahoney atmmahoney@cs.fit.edu.Seldom-used features have been deliberately omitted.
Language Summary Basic Concepts Statements if, for, while, return, break... Expressions arithmetic, comparison, assignment... The most important types areint, char, bool, double, and the containers string, vector,and map. Summary of common types:
Built-in Description int x; Fastest integer type (16-32 bits), also short, long, unsigned char x; 8-bit character, &#39;\0&#39; to &#39;\xFF&#39; or -128 to 127 double x; 64 bit real &#43; or - 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2480e3f6c72613cecb67dc531337867e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-01-04T20:39:55+08:00" />
<meta property="article:modified_time" content="2015-01-04T20:39:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;语法总结查询</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 align="center">How to Program in C++</h2> 
<p>You may copy this file for noncommercial use. The latest versionis located at <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html" rel="nofollow noopener noreferrer"> cs.fit.edu/~mmahoney/cse2050/how2cpp.html</a> updatedApr. 14, 2010. Please report errors to Matt Mahoney at<a target="_blank" href="mailto:mmahoney@cs.fit.edu" rel="nofollow noopener noreferrer">mmahoney@cs.fit.edu</a>.Seldom-used features have been deliberately omitted.<a target="_blank" name="languagesummary"></a></p> 
<h3><a target="_blank" name="languagesummary">Language Summary</a></h3> 
<a target="_blank" name="languagesummary"></a> 
<pre><a target="_blank" name="languagesummary"></a><p><a target="_blank" name="languagesummary"></a><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#basics" rel="nofollow noopener noreferrer">Basic Concepts</a>
</p><p><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#statements" rel="nofollow noopener noreferrer">Statements</a> if, for, while, return, break...
</p><p><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#expressions" rel="nofollow noopener noreferrer">Expressions</a> arithmetic, comparison, assignment...
</p></pre> 
<p>The most important types are<tt>int, char, bool, double</tt>, and the containers <tt>string, vector,</tt>and <tt>map</tt>. Summary of common types:</p> 
<pre><strong><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#builtin" rel="nofollow noopener noreferrer">Built-in</a>        Description</strong>
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#integer" rel="nofollow noopener noreferrer">int</a> x;          Fastest integer type (16-32 bits), also short, long, unsigned
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#char" rel="nofollow noopener noreferrer">char</a> x;         8-bit character, '\0' to '\xFF' or -128 to 127
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#floating" rel="nofollow noopener noreferrer">double</a> x;       64 bit real + or - 1.8e308, 14 significant digits, also float
bool x;         true or false                     
               
<strong><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#modifiers" rel="nofollow noopener noreferrer">Modifiers</a>       Description</strong>
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#const" rel="nofollow noopener noreferrer">const</a> T x;      Non-modifiable object
T&amp; y=x;         <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#references" rel="nofollow noopener noreferrer">Reference</a>, y is an alias for x, which both have type T
T f(...) {...}  Defines f as a <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#functions" rel="nofollow noopener noreferrer">function</a> returning T
T* p;           <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#pointers" rel="nofollow noopener noreferrer">Pointer</a> to T (*p is a T object)
T a[N];         <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#arrays" rel="nofollow noopener noreferrer">Array</a> of N elements of T, a[0] to a[N-1]
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#static" rel="nofollow noopener noreferrer">static</a> T x;     Place x in data segment
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#register" rel="nofollow noopener noreferrer">register</a> T x;   (rare) Hint to optimize for speed
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#volatile" rel="nofollow noopener noreferrer">volatile</a> T x;   (rare) x may be modified externally
</pre> The following standard library types and functions require at thebeginning of the program: 
<pre>  #include &lt;<em>header</em>&gt;
  using namespace std;
               
<strong><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#standardlibrarytypes" rel="nofollow noopener noreferrer">Library Type</a>    Description                             Header</strong>
istream         Standard input (cin)                    <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#iostream" rel="nofollow noopener noreferrer">iostream</a>
ostream         Output (cout, cerr, clog)               iostream
ifstream        Input file                              <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#fstream" rel="nofollow noopener noreferrer">fstream</a>
ofstream        Output file                             fstream
string          Sequence of char                        <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#string" rel="nofollow noopener noreferrer">string</a>
vector&lt;T&gt;       Expandable array/stack of T             <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#vector" rel="nofollow noopener noreferrer">vector</a>
deque&lt;T&gt;        Array/double ended queue                <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#deque" rel="nofollow noopener noreferrer">deque</a>
list&lt;T&gt;         List/stack/queue of T                   <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#list" rel="nofollow noopener noreferrer">list</a>
map&lt;T1,T2&gt;      Associative mapping of T1 to T2         <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#map" rel="nofollow noopener noreferrer">map</a>
set&lt;T1&gt;         A map with keys only                    <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#set" rel="nofollow noopener noreferrer">set</a>
pair&lt;T1,T2&gt;     Two objects of type T1 and T2           map or utility
priority_queue&lt;T&gt;  Sorted queue                         <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#queue" rel="nofollow noopener noreferrer">queue</a>
stack&lt;T&gt;        Stack                                   <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#stack" rel="nofollow noopener noreferrer">stack</a>
bitset&lt;N&gt;       Array of N bool with logical operations <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#bitset" rel="nofollow noopener noreferrer">bitset</a>
valarray&lt;T&gt;     Array with arithmetic operations        <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#valarray" rel="nofollow noopener noreferrer">valarray</a>
complex&lt;T&gt;      Complex number                          <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#complex" rel="nofollow noopener noreferrer">complex</a>
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#cpplibrary" rel="nofollow noopener noreferrer">iterator</a>        Pointer into a container                (Included with container)
const_iterator  Pointer not allowing element assignment (Included with container)
exception       Hierarchy of exception types            <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#stdexcept" rel="nofollow noopener noreferrer">stdexcept, exception</a>

<strong><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#cpplibrary" rel="nofollow noopener noreferrer">C++ Standard Library Functions</a>                          Header</strong>
min(), max(), swap(), sort(), copy(), equal()           <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#algorithm" rel="nofollow noopener noreferrer">algorithm</a>
accumulate(), inner_product()                           <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#numeric" rel="nofollow noopener noreferrer">numeric</a>
back_inserter()                                         <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#iterator" rel="nofollow noopener noreferrer">iterator</a>
equal_to(), less(), bind2nd()                           <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#functional" rel="nofollow noopener noreferrer">functional</a>
set_new_handler()                                       <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#new" rel="nofollow noopener noreferrer">new</a>

<strong><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#clibrary" rel="nofollow noopener noreferrer">C Library Functions</a>                                     Header</strong>
atoi(), atof(), abs(), rand(), system(), exit()         <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#cstdlib" rel="nofollow noopener noreferrer">cstdlib</a>
isalpha(), isdigit(), tolower(), toupper()              <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#cctype" rel="nofollow noopener noreferrer">cctype</a>
sqrt(), log(), exp(), pow(), sin(), cos(), atan()       <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#cmath" rel="nofollow noopener noreferrer">cmath</a>
clock(), time()                                         <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#ctime" rel="nofollow noopener noreferrer">ctime</a>
strlen(), memset(), memmove(), memcmp()                 <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#cstring" rel="nofollow noopener noreferrer">cstring</a>
printf(), fopen(), getc(), perror()                     <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#cstdio" rel="nofollow noopener noreferrer">cstdio</a>
assert()                                                <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#cassert" rel="nofollow noopener noreferrer">cassert</a>
</pre> 
<p>C++ allows you to create your own types and libraries. The mostimportant type is a <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#classes" rel="nofollow noopener noreferrer"> <tt>class</tt></a>, allowing object orientedprogramming. A class is an abstract data type with a hiddenrepresentation and a set of public member functions and types.Classes can be organized into a hierarchy (<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#inheritance" rel="nofollow noopener noreferrer">inheritance</a>), and youcan write code that accepts any type in this hierarchy (<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#polymorphism" rel="nofollow noopener noreferrer">polymorphism</a>).Functions and classes can be parameterized by type (templated).</p> 
<pre><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#classes" rel="nofollow noopener noreferrer">class</a> T {...};  Defines T as a collection of types, objects, and member functions
template &lt;class T&gt; ... Defines a set of <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#templatefunction" rel="nofollow noopener noreferrer">functions</a> or <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#templateclass" rel="nofollow noopener noreferrer">classes</a> over all T
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#typedef" rel="nofollow noopener noreferrer">typedef</a> T U;    Defines type U is a synonym for T
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#enum" rel="nofollow noopener noreferrer">enum</a> T {...};   Defines T as an int, and set of int constants
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#struct" rel="nofollow noopener noreferrer">struct</a> T {...}; Like a class, except default scope of members is public
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#union" rel="nofollow noopener noreferrer">union</a> T {...};  A struct with object members overlapping in memory
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#namespaces" rel="nofollow noopener noreferrer">namespace</a> N {...};  Defines a scope for a collection of types, objects, and functions

<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#programorganization" rel="nofollow noopener noreferrer">Program Organization</a> (compiling, linking, make)
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#history" rel="nofollow noopener noreferrer">History of C++</a>
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#furtherreading" rel="nofollow noopener noreferrer">Further Reading</a>
</pre> 
<hr> 
<a target="_blank" name="basics"></a> 
<h3>Basics</h3> 
<p>C++ is a compiled language, an upward compatible superset of Cand an (incompatible) predecessor to Java. C++ compiles C programs butadds object oriented (OO) features (classes, inheritance, polymorphism),templates (generic functions and classes), function and operatoroverloading, namespaces (packages), exception handling, a library ofstandard data structures (string, vector, map, etc.) and formatted text I/O(istream, ostream). Unlike Java, C++ lacks a standard graphical userinterface (GUI), network interface, garbage collection, and threads,and allows non-OO programming and unchecked low-level machine operationswith pointers. However, C++ executes faster than Java and requiresno run-time support.</p> 
<p>A C++ program is a collection of function, object, and type declarations.Every program must have a function <tt>int main() { ... }</tt>where the curly braces enclose a block, a sequence of declarationsand statements ending in semicolons which are executed in order.A statement is an expression, block,or control statement that alters the order of execution, such as<tt>if, while, for, break, return</tt>.Some types (<tt>std::string</tt>), objects (<tt>std::cout</tt>),and functions are defined in header files, requiring the line<tt>#include &lt;<em>header</em>&gt;</tt> before use. Itemsdefined in the standard headers are in the namespace <tt>std</tt>.The <tt>std::</tt> prefix may be dropped after the statement<tt>using namespace std;</tt>. For instance,</p> 
<pre>  // Comment: prints "Hello world!" and an OS-independent newline
  #include &lt;string&gt;    // Defines type std::string
  #include &lt;iostream&gt;  // Defines global object std::cout
  using namespace std; // Allow std:: to be dropped
  int main() {         // Execution starts here
    string s="Hello world!\n"; // Declares object s of type string
    cout &lt;&lt; s;         // An expression as a statement, &lt;&lt; is the output operator
    return 0;          // Execution ends here
  }
</pre> 
<p>The symbol <tt>//</tt> denotes a comment to the end of the line. You may alsouse <tt>/* ... */</tt> for multiline comments. Spacing and indentation isused for readability. C++ is mostly free-form, except thatthe end of line is significant after <tt># </tt>and <tt>//</tt>.C++ is case sensitive.</p> 
<p>C++ source code files should be created with a text editor andhave the extension <tt>.cpp</tt>. If the above is called <tt>hello.cpp</tt>,it may be compiled and run as follows in a UNIX shell window:</p> 
<pre>  g++ hello.cpp -o hello -Wall -O
  ./hello
</pre> The 
<tt>-o</tt> option renames the executable file, by default 
<tt>a.out</tt>. 
<tt> -Wall</tt> turns on all warnings (recommended). 
<tt>-O</tt> optimizes (compiles slower but runs faster). 
<p>In Windows, the GNU C++ compiler is called DJGPP. To compile andrun from an MS-DOS box:</p> 
<pre>  gxx hello.cpp -o hello.exe
  hello
</pre> The output file must have a .EXE extension (default is A.EXE). There isalso a .OBJ file which you can delete. 
<p>To use the network or GUI interface in UNIX, you must use the Xand socket libraries, which don't work in Windows. In Windows, youmust use the Windows API and a compiler that supports them, suchas from Microsoft, Borland, or Symantec. GUI/network programming isnonportable and outside the scope of this document.</p> 
<p><a target="_blank" name="basics">Links to free and commercial C++ compilers can be found at</a><a target="_blank" href="http://cplusplus.com/" rel="nofollow noopener noreferrer">cplusplus.com</a>.<a target="_blank" name="statements"></a></p> 
<h3><a target="_blank" name="statements">Statements</a></h3> 
<a target="_blank" name="statements"></a> 
<p>A program consists of a collection of functions (one of which mustbe <tt>int main() {...}</tt>) and type and objectdeclarations. A function may contain declarations and statements.Statements have the following forms, where<tt>s</tt> is a statement, and<tt>t</tt> is a true/false expression.</p> 
<pre><a target="_blank" name="statements">s;                             // </a><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#expressions" rel="nofollow noopener noreferrer">Expression</a> or <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#declarations" rel="nofollow noopener noreferrer">declaration</a>
;                              // Empty statement
{s; s;}                        // A <a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#statements" rel="nofollow noopener noreferrer">block</a> of 0 or more statements is a statement
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#if" rel="nofollow noopener noreferrer">if</a> (t) s;                      // If t is true then s
if (t) s; else s;              // else is optional
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#while" rel="nofollow noopener noreferrer">while</a> (t) s;                   // Loop 0 or more times
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#for" rel="nofollow noopener noreferrer">for</a> (s1; t; s2) s;             // s1; while (t) {s; s2;}
break;                         // Jump from while, for, do, switch
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#return" rel="nofollow noopener noreferrer">return</a> x;                      // Return x to calling function
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#try" rel="nofollow noopener noreferrer">try</a> {throw x;}                 // Throw exception, abort if not caught, x has any type
  catch (T y) {s;}               // if x has type T then y=x, jump to s
  catch (...) {s;}               // else jump here (optional)
do s; while (t);               // (uncommon) s; while (t) s;
continue;                      // (uncommon) Start next loop of while, for, do
switch (i) {                   // (uncommon) Test int expression i to const C
  case C: s; break;              // if (i==C) go here
  default: s;                    // optional, else go here
}
label: goto label;             // (rare) Jump to label within a function
</pre> 
<p>A statement may be a declaration or an expression. Objects andtypes declared in a block are local to that block.(Functions cannot be defined locally). It is normal (but not required) toshow statements on separate lines and to indentstatements enclosed in a block. If braces are optional, we indent anyway.For instance,</p> 
<pre>{                     // start of block
  int a[10], i=0, j;  // declaration
  a[i+2]=3;           // expression
}                     // end of block, a, i, and j are destroyed
</pre> declares the array of int 
<tt>a</tt> with elements 
<tt>a[0]</tt>through 
<tt>a[9]</tt> (whose values are initially undefined), 
<tt>i</tt> with initial value 0, and 
<tt>j</tt>with an undefined initial value. These names can only be used in scope,which is from the declaration to the closing brace. 
<p><a target="_blank" name="while"></a><a target="_blank" name="for">The <tt>for</tt> loop is normally used for iteration. For instance, the following both exit the loop with <tt>i</tt> set to the index ofthe first element of <tt>a</tt> such that <tt>a[i]</tt> is 0, or to 10 if not found.</a></p> 
<pre><a target="_blank" name="for">  for (i=0; i&lt;10; i=i+1) {    i=0;
    if (a[i]==0) {            while (i&lt;10) {
      break;                    if (a[i]==0)
    }                             break;
  }                             i=i+1;
                              }
</a></pre> 
<a target="_blank" name="for">The braces in the <tt>for</tt> loop are optional because they each enclosea single statement. In the <tt>while</tt> loop, the outer braces arerequired because they enclose 2 statements.All statements are optional: <tt>for (;;)</tt> loops forever.The first statement ina <tt>for</tt> loop may declare a variable local to the loop.</a> 
<pre>  for (int i=0; i&lt;10; i=i+1)
</pre> 
<p><a target="_blank" name="for">It is only possible to <tt>break</tt> from the innermost loopof a nested loop. <tt>continue</tt> in a <tt>for</tt> loopskips the rest of the block but executes the iteration (s2) andtest before starting the next loop.</a><a target="_blank" name="return"></a></p> 
<p><a target="_blank" name="return"><tt>return x;</tt> causes the current function to return tothe caller, evaluating to x. It is required except in functionsreturning void, in which case <tt>return;</tt> returns without avalue. The value returned by <tt>main()</tt> has no effect onprogram behavior and is normally discarded. However it is availableas the $status in a UNIX csh script or ERRORLEVEL in a Windows .BAT file.</a></p> 
<pre><a target="_blank" name="return">  int sum(int x, int y) {  // Function definition
    return x+y;
  }
  int main() {
    int a=sum(1,2);        // a=3;
    return 0;              // By convention, nonzero indicates an error
  }
</a></pre> 
<a target="_blank" name="return"></a> 
<a target="_blank" name="if"></a> 
<a target="_blank" name="switch"></a> 
<p>A test of several alternatives usually has the form <tt>if (t) s; else if (t) s; else if (t) s; ... else s;</tt>.A <tt>switch</tt> statement is an optimizationfor the special case where an int expression is tested against asmall range of constant values. The following are equivalent:</p> 
<pre>  switch (i) {                if (i==1)
    case 1: j=1; break;         j=1;
    case 2: // fall thru      else if (i==2 || i==3) // || means "or else"
    case 3: j=23; break;        j=23;
    default: j=0;             else
  }                             j=0;
</pre> 
<a target="_blank" name="try"></a> 
<p><tt>throw x</tt> jumps to the first <tt>catch</tt> statement of themost recently executed <tt>try</tt> block where the parameter declarationmatches the type of x, or a type that x can be converted to, or is<tt>...</tt>. At most one catch block is executed.If no matching <tt>catch</tt> block is found, the program aborts(Unexpected exception).<tt>throw;</tt> with no expression in a <tt>catch</tt> block throwsthe exception just caught. Exceptions are generallyused when it is inconvenient to detect and handle an error in thesame place.</p> 
<pre>  void f() {
    throw 3;
  }

  int main() {
    try {
      f();
    }
    catch(int i) {  // Execute this block with i = 3
      throw;        // throw 3 (not caught, so program aborts)
    }
    catch(...) {    // Catch any other type
    }
  }
</pre> 
<a target="_blank" name="expressions"></a> 
<h3>Expressions</h3> 
<p>There are 18 levels of operator precedence, listed highest to lowest.Operators at the same level are evaluated left to right unless indicted,Thus, a=b+c means a=(b+c) because + is higher than =, and a-b-c means(a-b)-c. Order of evaluation is undefined, e.g. for <tt>sin(x)+cos(x)</tt>we cannot say whether sin() or cos() is called first.</p> 
<p>The meaning of an expression depends on the types of the operands.<tt>(x,y)</tt> denotes a comma separated list of 0 or more objects,e.g. <tt>()</tt>, <tt>(x)</tt>, or <tt>(1,2,3,4)</tt>.</p> 
<pre><a target="_blank" name="expressions">1
X::m           Member m of namespace or class X
::m            Global name m when otherwise hidden by a local declaration

2
p[i]           i'th element of container p (array, vector, string)
x.m            Member m of object x
p-&gt;m           Member m of object pointed to by p
f(x,y)         Call function f with 0 or more arguments
i++            Add 1 to i, result is original value of i
i--            Subtract 1 from i, result is original value of i
</a><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#static_cast" rel="nofollow noopener noreferrer">static_cast&lt;T&gt;(x)</a>       Convert x to type T using defined conversions
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#const_cast" rel="nofollow noopener noreferrer">const_cast&lt;T&gt;(x)</a>        (rare) Convert x to equivalent but non-const T
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#reinterpret_cast" rel="nofollow noopener noreferrer">reinterpret_cast&lt;T&gt;(x)</a>  (rare, dangerous) Pretend x has type T
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#runtimetype" rel="nofollow noopener noreferrer">dynamic_cast&lt;T&gt;(x)</a>      (rare) Convert base pointer or reference to derived if possible
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#runtimetype" rel="nofollow noopener noreferrer">typeid(x)</a>      (rare) If x is type T, then typeid(x)==typeid(T) (in &lt;typeinfo&gt;)

3 (right to left)
*p             Contents of pointer p, or p[0].  If p is type T*, *p is T
&amp;x             Address of (pointer to) x.  If x is type T, &amp;x is T*
-a             Negative of numeric a
!i             Not i, true if i is false or 0
~i             Bitwise compliment of i, -1 - i
(T)x           Convert (cast) object x to type T (by static, const, or reinterpret)
T(x,y)         Convert, initializing with 0 or more arguments
new T          Create a T object on heap, return its address as T*
new T(x,y)     Create, initializing with 0 or more arguments
new(p) T       (rare) Initialize T at address p without allocating from heap
new(p) T(x,y)  (rare) Initialize T with 0 or more arguments at p
new T[i]       Create array of i objects of type T, return T* pointing to first element
delete p       Destroy object pointed to by p obtained with new T or new T()
delete[] p     Destroy array obtained with new T[]
++i            Add 1 to i, result is the new i
--i            Subtract 1 from i, result is the new i
sizeof x       Size of object x in bytes
sizeof(T)      Size of objects of type T in bytes

4
x.*p           (rare) Object in x pointed to by pointer to member p
q-&gt;*p          (rare) Object in *q pointed to by pointer to member p

5
a*b            Multiply numeric a and b
a/b            Divide numeric a and b, round toward 0 if both are integer
i%j            Integer remainder i-(i/j)*j

6
a+b            Addition, string concatenation
a-b            Subtraction

7
x&lt;&lt;y           Integer x shifted y bits to left, or output y to ostream x
x&gt;&gt;y           Integer x shifted y bits to right, or input y from istream x

8
x&lt;y            Less than
x&gt;y            Greater than
x&lt;=y           Less than or equal to
x&gt;=y           Greater than or equal to

9
x==y           Equals
x!=y           Not equals

10
i&amp;j            Bitwise AND of integers i and j

11
i^j            Bitwise XOR of integers i and j

12
i|j            Bitwise OR of integers i and j

13
i&amp;&amp;j           i and then j (evaluate j only if i is true/nonzero)

14
i||j           i or else j (evaluate j only if i is false/zero)

15 (right to left)
x=y            Assign y to x, result is new value of x
x+=y           x=x+y, also -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=

16
i?x:y          If i is true/nonzero then x else y

17
throw x        Throw exception x (any type)

18
x,y            Evaluate x and y (any types), result is y
</pre> Expressions that don't require creating a new object, such as 
<tt>a=b, ++a,p[i], p-&gt;m, x.m, a?b:c, a,b</tt> etc. are 
<em>lvalues</em>, meaning theymay appear on the left side of an assignment.Other expressions and conversions create temporary objects to hold theresult, which are 
<tt>const</tt> (constant). An expression used as astatement discards the final result. 
<pre>  int a, b, c;
  a+b;         // Legal, add a and b, discard the sum
  a=b=c;       // Legal, assign c to b, then assign the new b to a
  (a+=b)+=c;   // Legal, add b to a, then add c to a
  a+b=c;       // Error, a+b is const
  double(a)=b; // Error, double(a) is const
</pre> 
<p><a target="_blank" name="static_cast"><strong><tt>static_cast&lt;T&gt;(x)</tt></strong> converts x to type T if a conversionis defined. Usually the value of x is preserved if possible. Conversionsare defined between all numeric types (including char and bool), from0 to pointer, pointer to bool or void*, istream to bool, ostream to bool,char* to string, from a derived class to base class (includingpointers or references), and from type T to type U if class U has aconstructor taking T or class T hasa member <tt>operator U()</tt>.A conversion will be implicit (automatically applied) whenever anotherwise invalid expression, assignment, or function argument can bemade legal by applying one, except for T to U where U's constructortaking T is declared <tt>explicit</tt>, for example, the constructorfor <tt>vector</tt> taking <tt>int</tt>.</a></p> 
<pre><a target="_blank" name="static_cast">  double d; d=static_cast&lt;double&gt;(3);  // Explicit 3 to 3.0
  d=3;                                 // Implicit conversion
  d=sqrt(3);                           // Implicit 3.0, sqrt() expects double
  vector&lt;int&gt; v(5);                    // This constructor is explicit
  v=5;                                 // Error, no implicit conversion
  v=static_cast&lt;vector&lt;int&gt; &gt;(5);      // OK
</a></pre> 
<a target="_blank" name="static_cast"></a> 
<p><a target="_blank" name="static_cast"></a><a target="_blank" name="const_cast"><strong><tt>const_cast&lt;T&gt;(x)</tt></strong> allows an object to be modified througha const pointer or reference. It must always be explicit.</a></p> 
<pre><a target="_blank" name="const_cast">  int x=3;
  const int&amp; r=x; r=4;     // Error, r is const
  const_cast&lt;int&amp;&gt;(r)=4;   // OK, x=4
  const int* p=&amp;x; *p=5;   // Error, *p is const
  *const_cast&lt;int*&gt;(p)=5;  // OK, x=5
</a></pre> 
<a target="_blank" name="const_cast">If x were const, then this code would still be allowed but it isundefined whether x actually changes.</a> 
<p><a target="_blank" name="const_cast"></a><a target="_blank" name="reinterpret_cast"><strong><tt>reinterpret_cast&lt;T&gt;(x)</tt></strong> turns off normal type checking betweenint and different pointer types, which are normally incompatible. The onlysafe conversion is to convert a pointer back to its original type.Conversion is always explicit.</a></p> 
<pre><a target="_blank" name="reinterpret_cast">  int x=3, *p=&amp;x; *p=5;             // OK, x=5
  *reinterpret_cast&lt;double*&gt;(p)=5;  // Crash, writing 8 bytes into 4
</a></pre> 
<a target="_blank" name="reinterpret_cast">The expression <tt>(T)x</tt> applies whatever combinationof static, const, and reinterpret casts are needed to convert x totype T. <tt>T(x)</tt> is a static_cast.</a> 
<pre>  const char* s="hello";
  int(*s);                 // static_cast
  (char*)s;                // const_cast
  (const int*)s;           // reinterpret_cast
  (int*)s;                 // reinterpret_cast and const_cast
</pre> 
<a target="_blank" name="declarations"></a> 
<h3>Declarations</h3> 
<p>A declaration creates a type, object, or function and gives it a name.The syntax is a type name followed by a list of objects with possiblemodifiers and initializers applying to each object. A name consists ofupper or lowercase letters, digits, and underscores (_) with a leadingletter. (Leading underscores are allowed but may be reserved).An initializer appends the form <tt>=x</tt> where x is an expression,or (x,y) for a list of <em>one</em> or more expressions.For instance,</p> 
<pre>  string s1, s2="xxx", s3("xxx"), s4(3,'x'), *p, a[5], next_Word();
</pre> declares s1 to be a string with initial value "", s2, s3, and s4to be strings with initial value "xxx", p to be a pointer to string,a to be an array of 5 strings (a[0] to a[4] with initial values ""),and 
<tt>next_Word</tt> to be a function that takes no parameters andreturns a string. 
<a target="_blank" name="builtin"></a> 
<h3>Built-in Types</h3> All built-in types are numeric. They are not automatically initializedto 0 unless global or static. 
<pre>  int a, b=0;       // a's value is undefined
  static double x;  // 0.0
</pre> Types and their usual ranges are listed below. Actual ranges could be 
<a target="_blank" href="http://home.att.net/%7Ejackklein/c/inttypes.html" rel="nofollow noopener noreferrer">different</a>.The most important types are int,bool, char, and double. 
<pre>  <strong>Integer types           Bits   Range</strong>
  bool                     1     false (0) or true (1)
  signed char              8     '\x80' to '\x7f' (-128 to 127)
  unsigned char            8     '\x00' to '\XFF' (0 to 255)
  char                     8     Usually signed
  short                   16     -32768 to 32767
  unsigned short          16     0u to 65535U
  int                     32     Usually -2147483648 to 2147483647
  unsigned int            32     Usually 0 to 4294967295U
  long                    32-64  At least -2147483648l to 2147483647L
  unsigned long           32-64  0ul to at least 4294967295LU

  <strong>Floating point types    Bits   Range</strong>
  float                   32     -1.7e38f to 1.7E38F, 6 significant digits
  double                  64     -1.8e308 to 1.8E308, 14 significant digits
  long double             64-80  At least double
</pre> There are implicit conversions between all types. When types aremixed in an expression, both operands are converted to the typethat has the higher upper bound, but at least to int. This conversiononly loses representation when mixing signed and unsigned types. 
<pre>  7/4                     // 1, int division rounds toward 0
  7.0/4                   // 1.75, implicit double(4) = 4.0
  '\x05'+true             // 6, implicit int('\x05') = 5, int(true) = 1
  3U &gt; -1                 // false, implicit (unsigned int)(-1) = 2<sup>32</sup>-1
</pre> Conversion from a floating point type to an integer type drops thedecimal part and rounds toward 0. If the value is outside the rangeof the target, then the result is undefined. 
<pre>  int(-3.8)               // -3
</pre> Conversion of one integer type to another is performed modulo therange of the target. For a B-bit number (except bool), we add orsubtract 2 
<sup>B</sup> to bring the value within range. (In termsof a 2's complement number, we drop the most significant bits andreinterpret the sign bit without changing any bits). For bool,any nonzero value is true. 
<pre>  (unsigned char)(-1)     // '\xff' (255)
  bool(3)                 // true
  short a=x12345678;      // x5678 hex
</pre> 
<a target="_blank" name="integer"></a> 
<h4>Integer Types</h4> int is the most common integer type, normally the underlying word sizeof the computer or 32 bits, representing numbersfrom -2 
<sup>31</sup> to 2 
<sup>31</sup>-1 (-2147483648 to 2147483647).On some older systems such as real mode DOS, it may be 16 bits (-32768 to32767). You should use int unless you need the range of some other type. 
<p>An int value may be written in decimal (e.g. 255), hexadecimalwith a leading X (e.g. xff or XFF) or octal (base 8) with a leading 0(e.g. 0377). A trailing L denotes long (e.g. 255L or 255l), and U denotesunsigned. These may be combined (e.g. 255lu or 255UL is unsigned long).Most integer operations translate to a single machine instructionand are very fast.</p> 
<pre>  + - * / % -i      Add, subtract, multiply, divide, mod, unary negation
  =                 Assignment
  == != &lt; &lt;= &gt; &gt;=   Comparison, returns true or false
  ++i i++ --i i--   Pre/post increment and decrement
  &amp; | ^ ~i &lt;&lt; &gt;&gt;    Bitwise and, or, xor, not, left shift, right shift
  += -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=    Operate and assign, e.g. x+=y means x=x+y
  &amp;&amp; || !i          Logical and then, or else, not
</pre> Division rounds toward 0, e.g. 7/4 is 1, -7/4 is -1. x%y is the remainderwith the sign of x, e.g. -7%4 is -3. Division or mod by 0 is a run timeerror and should be avoided. Operations that yield results outsidethe range of an int are converted modulo 2 
<sup>32</sup>, or more generally,2 
<sup>B</sup> for a B bit number. For instance, 65535*65537 is -1, not2 
<sup>32</sup>-1. 
<p>Assignment returns the value assigned, e.g. x=y=0 assigns 0 to y andthe new y to x. The result is an lvalue, e.g. (x=y)=0 is also legal(but useless). It assigns y to x, then 0 to x.</p> 
<p>++i and i++ both add 1 to i. However, ++i returns the new value,and i++ returns the old value. Likewise for decrement, --i and i--, whichsubtracts 1. The <em>pre</em> forms, ++i, --i, are lvalues.</p> 
<p>Bitwise operators treat an int as a 2's compliment B-bit binarynumber (B=32) with weights -2<sup>B-1</sup>, 2<sup>B-2</sup>,2<sup>B-3</sup>, ...8, 4, 2, 1. The leftmost bit is negative, and serves as the signbit. Thus, 0 is all zero bits and -1 is all 1 bits. Bitwiseoperators x&amp;y x|y x^y and ~x perform B simultaneous logical operationson the bits of x and y. For instance, if y is a power of 2, thenx&amp;(y-1) has the effect x%y, but is usually faster, and the result is alwayspositive in the range 0 to y-1.</p> 
<p>x&lt;&lt;y returns x shifted left by y places, shifting in zeros.The result is x*2<sup>y</sup>. x&gt;&gt;y returns x shifted right by y places,shifting in copies of the sign bit (or zeros if unsigned).The result is x/2<sup>y</sup> butrounding negative instead of toward 0. For instance, -100&gt;&gt;3 is -13.y must be in the range 0 to B-1 (0 to 31). Shifting is usually fasterthan * and /.</p> 
<p>Any binary arithmetic or bitwise operator may be combined withassignment. The resultis an lvalue. e.g. <tt>(x+=2)*=3;</tt> has the effect x=x+2; x=x*3;</p> 
<p>Logical operators treat 0 as false and any other value as true.They return true (1) or false (0), as do comparisons. The &amp;&amp; and ||operators do not evaluate the right operand if the result is known fromthe left operand.</p> 
<pre>  if (i&gt;=0 &amp;&amp; i&lt;n &amp;&amp; a[i]==x)  // Do bounds check on i before indexing array a
  if (x=3)                     // Legal but probably wrong, assign 3 to x and test true
</pre> 
<a target="_blank" name="char"></a> 
<h4><tt>char</tt></h4> 
<p>A <tt>char</tt> is a one byte value. Unlike other numeric types,it prints as a character, although it can be used in arithmetic expressions.Character constants are enclosed in single quotes, as <tt>'a'</tt>.A backslash has special meaning. '\n' is a newline,'\\' is a single backslash, '\'' is a singlequote, '\"' is a double quote. A backslash may be followed by 3 octaldigits ('\377') or an X and 2 hex digits ('\xFF') (but not decimal).Most computers use ASCII conversion as follows:</p> 
<pre>  8-13:   \b\t\n\v\f\r  (bell, tab, newline, vertical tab, formfeed, return)
  32-47:   !\"#$%&amp;\'()*+,-./                 (32=space, \' and \" are one char)
  48-63:  0123456789:;&lt;=&gt;\?                  (\? is one char)
  64-95:  @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_  (\\ is one char)
  96-126: `abcdefghijklmnopqrstuvwxyz{|}~
</pre> 
<a target="_blank" name="floating"></a> 
<h4>Floating Point Types</h4> A number with a decimal point is double (e.g. 3.7) unless a trailingF is appended (e.g. 3.7f or 3.7F), in which case it is float. Doubleis preferred. A double may be written in the form xey meaningx*10 
<sup>y</sup>, e.g. 3.7E-2 (0.037) or 1e4 (10000.0). 
<p>A double is usually represented as a 64 bit number with a sign bit,an 11 bit exponent, and 52 bit mantissa. Therefore it can only representnumbers of the form M*2<sup>E</sup> exactly, where -2<sup>52</sup> &lt;M &lt; 2<sup>52</sup> and 2<sup>-10</sup> &lt; E &lt; 2<sup>10</sup>.This is about + or - 1.797e308 with about 15 decimal digits of precision.Therefore, numbers like 1e14 and 0.5 have exact representations, but 1e20and 0.1 do not.</p> 
<pre>  0.1 * 10 == 1    // false, they differ by about 10<sup>-15</sup>
</pre> There are no bitwise or logical operators, %, ++, or -- 
<pre>  + - * / -x        Add, subtract, multiply, divide, unary negation (no %)
  = += -= *= /=     Assignment, may be combined with operators
  == != &lt; &lt;= &gt; &gt;=   Comparison, however only &lt; and &gt; are meaningful
</pre> Operations may produce values outside the range of a double resultingin infinity, -infinity or NaN (not a number). These values cannotbe written in C++. 
<p><a target="_blank" name="floating">Additional mathematical functions (sqrt(), log(), pow(), etc.) canbe found in &lt;</a><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#cmath" rel="nofollow noopener noreferrer">cmath</a>&gt;.<a target="_blank" name="modifiers"></a></p> 
<h3><a target="_blank" name="modifiers">Modifiers</a></h3> 
<a target="_blank" name="modifiers"></a> 
<p>In a declaration, modifiers before the type name apply toall objects in the list. Otherwise they apply to single objects.</p> 
<pre>  int* p, q;           // p is a pointer, q is an int
  const int a=0, b=0;  // a and b are both const
</pre> 
<a target="_blank" name="const"></a> 
<h4>const</h4> 
<p><tt>const</tt> objects cannot be modified once created. They mustbe initialized in the declaration. By convention, const objects areUPPERCASE when used globally or as parameters.</p> 
<pre>  const double PI=3.14159265359;  // Assignment to PI not allowed
</pre> 
<a target="_blank" name="references"></a> 
<h4>References</h4> 
<p>A reference creates an alias for an object that already exists.It must be initialized. A reference to a const object must also be const.</p> 
<pre>  int i=3;
  int&amp; r=i;         // r is an alias for i
  r=4;              // i=4;
  double&amp; pi=PI;    // Error, would allow PI to be modified
  const double&amp; pi=PI;  // OK
</pre> 
<a target="_blank" name="functions"></a> 
<h4>Functions</h4> 
<p>A function has a list of parameter declarations, a return type,and a block of statements. Execution must end with a return statementreturning an expression that can be converted to the return type,unless void, in which case there is an implied <tt>return;</tt> atthe end. Arguments passed to a function must match the parametersor allow implicit conversion (such as int to double).Functions must be defined before use, orhave a matching declaration that replaces the block with a semicolonand may optionally omit parameter names.Functions are always global (not defined in other functions).</p> 
<pre>  void f(double x, double); // Declaration
  double g() {              // Definition
    return 3;               // Implied conversion to double (3.0)
  }
  int main() {              // Execution starts with function main
    f(g(), 5);              // Calls g, then f with implicit 5.0
    return 0;               // Return UNIX $status or Windows ERRORLEVEL
  }
  void f(double x, double y) { // Definition must match declaration
    cout &lt;&lt; x+y;
    return;                 // Optional
  }
</pre> 
<p>Command line arguments may be passed to<tt>main(int argc, char** argv)</tt> where <tt>argv</tt> isan array of <tt>argc</tt> elements of type char* ('\0' terminated arrayof char), one element for each word (separated by white spaces).In UNIX, the command line is expanded before being passed (* becomesa directory listing, etc). The following program prints the commandline.</p> 
<pre>  // echo.cpp
  #include &lt;iostream&gt;
  using namespace std;
  int main(int argc, char** argv) {
    for (int i=0; i&lt;argc; ++i)
      cout &lt;&lt; argv[i] &lt;&lt; endl;
    return 0;
  }

  <strong>g++ echo.cpp
  ./a.out hello world</strong>
  ./a.out
  hello
  world
</pre> 
<p>Function parameters have local scope. They are initialized bycopying the argument, which may be an expression. Reference parametersare not copied; they become references to the arguments passed, whichmust be objects that the function may modify. If the reference isconst, then the argument may be an expression. Const reference isthe most common for passing large objects because it avoids the runtime overhead of copying.</p> 
<pre>  void assign_if(bool cond, string&amp; to,  const string&amp; from) {
              // value      reference    const reference
    if (cond)
      to=from;
  }
  int main() {
    string s;
    assign_if(true, s, "a");   // OK, s="a"
    assign_if(false, "b", s);  // Error: to refers to a const
</pre> 
<p>Functions returning a reference must return an object whichcan be assigned to, and that object must exist after returning(global or static, but not local). The function may be calledon the left side of an assignment. Functions returning by valuemake a temporary copy which is const.</p> 
<pre>  int  a=1;                           // Global
  int  f() {return a;}                // OK, returns copy of a
  int&amp; g() {return a;}                // OK, g() is alias for a
  int&amp; h() {return a+1;}              // Error, reference to const
  int&amp; i() {int b; return b;}         // Error, b destroyed after return
  int&amp; j() {static int b; return b;}  // OK, static has global lifespan
  int main() {
    f()=2;    // Error, assignment to const
    g()=f();  // OK, a=1;
    return 0;
  }
</pre> 
<p>Functions with the same name may be overloaded by matching thearguments to the parameters.</p> 
<pre>  int abs(int);
  double abs(double);
  int main() {
    abs(3);    // int
    abs(3.0);  // double
    abs("3");  // Error, no match
    abs('a');  // Error, ambiguous, could convert char to int or double
    return 0;
  }
</pre> Most operators X can be overloaded by defining a function named 
<tt>operator X()</tt> taking the operands as arguments. At least oneargument has to be a class type. 
<pre>  string operator - (const string&amp; s, int i);  // Defines s-i
  string operator - (const string&amp; s);         // Defines -s
</pre> Operators 
<tt>. :: ?:</tt> and 
<tt>sizeof</tt> cannot be overloaded.Operators 
<tt> = [] -&gt;</tt> cannot be overloaded except as class members.Postfix 
<tt>++ --</tt>are overloaded as binary operators with a second dummy 
<tt>int</tt>parameter to distinguish from the prefix form. 
<pre>  string&amp; operator++(const string&amp; s);      // defines ++s
  string  operator++(const string&amp; s, int); // defines s++
</pre> 
<p>Functions may have default arguments by initializing the parameters.Defaults should be specified only once. Defaulted parameters mustappear after all non-default parameters.</p> 
<pre>  void f(int i, int j=0, int k=0);  // OK
  void g(int i=0, int j);           // Error
  int main() {
    f(1, 2);  // f(1, 2, 0);
    f(1);     // f(1, 0, 0);
    f();      // Error
    return 0;
  }
  void f(int i, int j, int k) {}    // Defaults not specified again
</pre> 
<a target="_blank" name="templatefunction">A <strong>template</strong> overloads a function for all types. The declaration<tt>template &lt;class T, class U&gt;</tt> before a function definitionallows T and U to be used in the code as types.The compiler will figure out appropriate substitutionsfrom the arguments. A non-templated overloaded function takesprecedence over a template.</a> 
<pre>  template &lt;class T&gt;
  void swap(T&amp; a, T&amp; b) {
    T tmp=a;
    a=b;
    b=tmp;
  }
  void swap(string&amp; a, string&amp; b);  // Overrides the case T=string
  int main() {
    int i=1, j=2;
    string a, b;
    swap(i, j);        // OK, T is int
    swap(a, b);        // OK, calls non-templated swap
    swap(i, a);        // Error, cannot resolve T
    swap(cout, cerr);  // Error, ostream does not allow =
</pre> 
<p><tt>inline</tt> is a hint to the compiler to optimize for speedby expanding the code where it is called, saving a call and returninstruction. Unlike a macro, semantics are preserved.Only short functions should be inlined.</p> 
<pre>  inline int min1(int a, int b) {return a&lt;b?a:b;}
  #define min2(a,b) ((a)&lt;(b)?(a):(b))
  int main() {
    min1(f(), 0);  // calls f() once
    min2(f(), 0);  // calls f() twice, expands to ((f())&lt;(0)?(f()):(0))
</pre> 
<a target="_blank" name="pointers"></a> 
<h4>Pointers</h4> 
<p>A pointer stores the address of another object, and unlike a reference,may be moved to point elsewhere. The expression <tt>&amp;x</tt> means "address ofx" and has type "pointer to x". If <tt>x</tt> has type <tt>T</tt>,then <tt>&amp;x</tt> has type <tt>T*</tt>.If <tt>p</tt> has type <tt>T*</tt>, then <tt>*p</tt> is the objectto which it points, which has type <tt>T</tt>.The * and &amp; operators are inverses, e.g. <tt>*&amp;x == x</tt>.</p> 
<p>Two pointers are equal if they point to the same object.All pointer types are distinct,and can only be assigned pointers of the same type or 0 (NULL).There are no run time checks against reading or writing the contentsof a pointer to invalid memory. This usually causes a segmentationfault or general protection fault.</p> 
<pre>  int i=3, *p=&amp;i;    // p points to i, *p == 3
  *p=5;              // i=5
  p=new int(6);      // OK, p points to an int with value 6
  p=new char('a');   // Error, even though char converts to int
  p=6;               // Error, no conversion from int to pointer
  p=0;               // OK
  p=i-5;             // Error, compiler can't know this is 0
  *p=7;              // Segmentation fault: writing to address 0
  int *q; *q;        // Segmentation fault: q is not initialized, reading random memory
</pre> 
<p>A pointer to a const object of type T must also be const, oftype <tt>const T*</tt>, meaning that the pointer may be assigned tobut its contents may not.</p> 
<pre>  const double PI=3.1415926535898;
  double* p=&amp;PI;              // Error, would allow *p=4 to change PI
  const double* p=&amp;PI;        // OK, can't assign to *p (but may assign to p)
  double* const p=&amp;PI;        // Error, may assign to *p (but not to p)
  const double* const p=&amp;PI;  // OK, both *p and p are const
</pre> 
<p>A function name used without parenthesis is a pointer to a function.Function pointers can be assigned values and called.</p> 
<pre>  int f(double);     // functions f and g take double and return int
  int g(double);
  int *h(double);    // function h takes double and returns pointer to int
  int (*p)(double);  // p is a pointer to a function that takes double and returns int
  int main() {
    p=f; p(3.0);     // calls f(3.0)
    p=g; p(3.0);     // calls g(3.0)
    p=h;             // Error, type mismatch
</pre> 
<p>Explicit pointer conversions are allowed but usually unsafe.</p> 
<pre>  int i, *p=&amp;i;
  i=int(3.0);        // OK, rounds 3.0
  *(double*)p = 3.0; // Crash, writes beyond end of i
  *(double*)&amp;PI = 4; // Overwrites a const
</pre> These may also be written (with the same results): 
<pre>  i=static_cast&lt;int&gt;(3.0);            // Apply standard conversions
  *reinterpret_cast&lt;double*&gt;p = 3.0;  // Pretend p has type double*
  *const_cast&lt;double*&gt;&amp;PI = 4;        // Same type except for const
</pre> 
<a target="_blank" name="arrays"></a> 
<h4>Arrays</h4> 
<p>The size of an array must be specified by a constant, and may be leftblank if the array is initialized from a list. Array boundsstart at 0. There are no run time checks on array bounds.Multi-dimensional arrays use a separate bracket for each dimension.An array name used without brackets is a pointer to the first element.</p> 
<pre>  int a[]={0,1,2,3,4};    // Array with elements a[0] to a[4]
  int b[5]={6,7};         // Implied ={6,7,0,0,0};
  int c[5];               // Not initialized, c[0] to c[4] could have any values
  int d[2][3]={<!-- -->{1,2,3},{4,5,6}};  // Initialized 2-D array
  int i=d[1][2];          // 6
  d[-1][7]=0;             // Not checked, program may crash
</pre> The bare name of an array is a const pointer to the first element. Ifp is a pointer to an array element, then p+i points i elements ahead,to p[i]. By definition, p[i] is *(p+i). 
<pre>  int a[5];               // a[0] through a[4]
  int* p=a+2;             // *p is a[2]
  p[1];                   // a[3]
  p-a;                    // 2
  p&gt;a;                    // true because p-a &gt; 0
  p-1 == a+1              // true, both are &amp;a[1]
  *a;                     // a[0] or p[-2]
  a=p;                    // Error, a is const (but not *a)
</pre> 
<p>A literal string enclosed in double quotes is an unnamed static array ofconst char with an implied '\0' as the last element. It may be used either toinitialize an array of char, or in an expression as a pointer to thefirst char. Special chars in literals may be escaped with a backslashas before. Literal strings are concatenated without a + operator(convenient to span lines).</p> 
<pre>  char s[]="abc";                       // char s[4]={'a','b','c','\0'};
  const char* p="a" "b\n";              // Points to the 'a' in the 4 element array "ab\n\0"
  const char* answers[2]={"no","yes"};  // Array of pointers to char
  cout &lt;&lt; answers[1];                   // prints yes (type const char*)
  cout &lt;&lt; answers[1][0];                // prints y (type const char)
  "abc"[1]                              // 'b'
</pre> Arrays do not support copying, assignment, or comparison. 
<pre>  int a[5], b[5]=a;       // Error: can't initialize b this way
  b=a;                    // Error: can't assign arrays
  b==a;                   // false, comparing pointers, not contents
  "abc"=="abc"            // false, comparing pointers to 2 different locations
</pre> The size of an array created with 
<tt>new[]</tt> may be an expression. Theelements cannot be initialized with a list. There is no run time checkagainst accessing deleted elements. 
<pre>  int n, *p;
  cin &gt;&gt; n;
  p=new int[n];  // Elements p[0] to p[n-1] with values initially undefined
  delete[] p;    // Use delete with new or new(), delete[] with new[]
  p[0] = 1;      // May crash
</pre> 
<a target="_blank" name="static"></a> 
<h4>static</h4> Normally, objects are placed on the stack. Memory is allocatedby growing the stack at the top; thus objects are destroyed inthe reverse order in which they are created. An object's life spanis the same as its scope. If an object comes into scope more than once,then it is reinitialized each time, and destroyed when leaving its scope. 
<pre>  +----------+
  |          |
  |   Heap   |  Allocated with <em>new</em> until deleted or program exits.
  |          |
  +^^^^^^^^^^+  
  |   Stack  |  Local objects, parameters, temporaries, function return addresses.
  +----------+     +---------+
  |   Data   | &lt;-- |  Data   |  Initial values for static and global objects.
  +----------+     +---------+
  |   Code   | &lt;-- |  Code   |  Executable machine instructions.
  +----------+     +---------+  (Cannot be read or written by program.)
  | Reserved |    a.out on disk
  | for OS   |
  | and other|  Cannot be read or written by program, will cause segmentation
  | programs |  fault or general protection fault.
  +----------+
     Memory
</pre> 
<tt>static</tt> objects are placed in the data segment. They areinitialized from values stored in the executable file, and thereforethese values must be known at compile time. Initialization occurs onlyonce. Values are maintained when the object is out of scope (e.g.between function calls), and it is safe to return a pointer or referenceto them. Numeric values not explicitly initialized are set to 0. 
<pre>  int&amp; f() {        // Return by reference, f() is an alias for s, not a temporary copy
    static int s=1; // Initialized only once
    ++s;
    return s;       // Safe to return by reference
  }
  int main() {
    cout &lt;&lt; f();    // 2
    cout &lt;&lt; f();    // 3
    f()=5;          // OK, s=5;
    s=6;            // Error, s is not in scope
</pre> 
<a target="_blank" name="register"></a> 
<h4><tt>register</tt></h4> (Rare) A hint to the compiler to optimize an int or pointer for speed.It is no longer used because most optimizers can do a better job. 
<pre>  register int x;
</pre> 
<a target="_blank" name="volatile"></a> 
<h4><tt>volatile</tt></h4> (Rare) Indicates that an object might be modified from outside theprogram (e.g. a hardware input port) and that the optimizer should notmake copies of it. Its use is machine dependent. 
<pre>  const volatile unsigned short&amp; port=*(const short*)0xfffe; // 16 bit port at address xfffe
</pre> 
<a target="_blank" name="standardlibrarytypes"></a> 
<h3>Standard Library Types</h3> 
<p>Standard library types (string, vector, map...) and objects(cin, cout...) require a<tt>#include &lt;<em>header</em>&gt;</tt> and must be extracted fromnamespace <tt>std</tt>, either with a <tt>using namespace std;</tt>statement or by using the fully qualified names preceded with <tt>std::</tt>,as in <tt>std::cout</tt>.</p> 
<pre>  #include &lt;iostream&gt;                    #include &lt;iostream&gt;
  int main() {                           using namespace std;
    std::cout &lt;&lt; "Hello\n";              int main() {
    return 0;                              cout &lt;&lt; "Hello\n";
  }                                        return 0;
                                        }
</pre> 
<a target="_blank" name="iostream"></a> 
<h4>&lt;iostream&gt;</h4> 
<p>The header &lt;iostream&gt; defines global object <tt>cin</tt> oftype <tt>istream</tt>, and global objects <tt>cout, cerr, clog</tt>of type <tt>ostream</tt>. <tt>cin</tt> represents standard input,normally the keyboard, unless redirected to a file or piped on thecommand line. <tt>cout</tt> represents standard output, which isnormally the screen unless redirected or piped. Writing to<tt>cerr</tt> or <tt>clog</tt> both write to the screen even if outputis redirected. The difference is that writing a newline ('\n') flushesany buffered output to <tt>cerr</tt> but not to <tt>cout</tt> or<tt>clog</tt>.</p> 
<p>In the following, <tt>in</tt> is an istream (cin),<tt>out</tt> is an ostream (cout, cerr, clog), i is int, c is char, and cp is char*.</p> 
<pre>  in &gt;&gt; x;               // Read 1 word to numeric, string, or char* x, return in
  in.get();              // Read 1 char (0-255) or EOF (-1) as an int
  in.get(c);             // Read 1 char into c, return in
  in.unget();            // Put back last char read, return in
  in.getline(cp, i);     // Read up to i chars into char cp[i] or until '\n', return in
  in.getline(cp, i, c);  // Read to c instead of '\n', return in
  getline(in, s);        // Read up to '\n' into string s, return in
  in.good();             // true if no error or EOF
  bool(in);              // in.good();
  in.bad();              // true if unexpected char in formatted input
  in.clear();            // Allow more input after bad, or throw an ios::failure
  in.eof();              // true if end of file
  in.fail();             // true if system input error

  out &lt;&lt; x;                // Formatted output, redirected with &gt;
  out &lt;&lt; endl;             // Print '\n' and flush
</pre> 
<p>Input with &gt;&gt; reads a contiguous sequence of non-whitespacecharacters. If x is numeric and the next word contains invalidcharacters (such as "1.5" or "foo" for an int), then the firstoffending character remains unread, in.bad() is set, and no furtherinput can occur until in.clear() is called. Input into a char*array is not bounds checked. Input returns the istream to allowchaining, and has a conversion to bool to test for success. Outputalso returns the ostream to allow chaining.</p> 
<pre>  // Read and print pairs of strings and ints until something goes wrong
  // Input:  hi 3 there 5 this is 1 test
  // Output: hi 3
             there 5

  string s; int i;
  while (cin &gt;&gt; s &gt;&gt; i)
    cout &lt;&lt; s &lt;&lt; " " &lt;&lt; i &lt;&lt; endl;
  cin.clear();
</pre> 
<p><a target="_blank" name="iostream">The get() methods read one characterincluding whitespace. The various getline() functions read up throughthe next newline character and discard the newline.The methods <tt>good(), bad(), eof(), fail(), clear()</tt>, andimplicit conversion to bool are available in <tt>ostream</tt>,just as in <tt>istream</tt>, but are seldom used.</a><a target="_blank" name="iomanip"></a></p> 
<h4><a target="_blank" name="iomanip">&lt;iomanip&gt;</a></h4> 
<a target="_blank" name="iomanip"></a> 
<p>Defines manipulators for formatted output of numeric types.They have no effect on strings. <tt>setw()</tt> applies only to thenext object printed, but the others remain in effect until changed.</p> 
<pre>  out &lt;&lt; setw(i);          // Pad next output to i chars, then back to 0
  out &lt;&lt; setfill(c);       // Pad with c (default ' ')
  out &lt;&lt; setprecision(i);  // Use i significant digits for all float, double

  cout &lt;&lt; setw(6) &lt;&lt; setprecision(3) &lt;&lt; setfill('0') &lt;&lt; 3.1; // print "003.10"
</pre> 
<a target="_blank" name="fstream"></a> 
<h4>&lt;fstream&gt;</h4> Defines types 
<tt>ifstream</tt> and 
<tt>ofstream</tt> representinginput and output files respectively. 
<tt>ifstream</tt> is derived from 
<tt>istream</tt>,inheriting all its operations (such as &gt;&gt;). In addition, 
<pre>  ifstream in(cp);          // Open file named cp for reading
  ifstream in(cp, ios::in | ios::binary);  // Open in binary mode
  bool(in);                 // true if open successful
</pre> 
<p><tt>cp</tt> is the file name. It must be a char*, not string (use<tt>s.c_str()</tt> to convert string <tt>s</tt>).Input is normally in text mode. In Windows, carriage returns ('\r') arediscarded, and an ASCII 26 ('\032') signals end of file. In binarymode and in UNIX, no such translation occurs. The file is closedwhen the ifstream is destroyed.</p> 
<pre>  {
    ifstream f("input.dat", ios::in | ios::binary);
    if (!f)
      cerr &lt;&lt; "File not found\n";
    else {
      int i=f.get();  // First byte or EOF if empty
    }
  } // f closed here
</pre> 
<p><tt>ofstream</tt> is derived from <tt>ostream</tt>,inheriting all its operations (such as &lt;&lt;). In addition,</p> 
<pre>  ofstream os(cp);          // Open file named cp for writing
  ofstream os(cp, ios::out | ios::binary);  // Open in binary mode
</pre> 
<p><a target="_blank" name="fstream">In text mode in Windows, writing '\n' actually writes "\r\n".The file named cp is overwritten if it exists, or created otherwise.The file is flushed and closed when the ofstream is destroyed.</a><a target="_blank" name="string"></a></p> 
<h4><a target="_blank" name="string">&lt;string&gt;</a></h4> 
<a target="_blank" name="string">A <tt>string</tt> is like an array of char, but it also supportscopying, assignment, and comparison, and its size may be set or changedat run time.'\0' has no special meaning. There is implicit conversion from char*to string in mixed type expressions.</a> 
<pre>  string()           // Empty string
  string(cp)         // Convert char* cp to string
  string(n, c)       // string of n copies of char c
  s=s2               // Assign char* or string s2 to string s
  s1&lt;s2              // Also ==, !=, &gt;, &lt;=, &gt;=, either s1 or s2 may be char*
  s.size()           // Length of string s
  string::size_type  // Type of s.size(), usually unsigned int
  s.empty()          // True if s.size() == 0
  s[i]               // i'th char, 0 &lt;= i &lt; s.size() (unchecked), may be assigned to
  s.at(i)            // s[i] with bounds check, throws out_of_range
  s1+s2              // Concatenate strings, either s1 or s2 may be char or char*
  s+=s2              // Append string, char, or char* s2 to string s
  s.c_str()          // string s as a const char* with trailing '\0'
  s.substr(i, j)     // Substring of string s of length j starting at s[i]
  s.substr(i)        // Substring from s[i] to the end
  s.find(s2)         // Index of char, char*, or string s2 in s, or string::npos if not found
  s.rfind(s2)        // Index of last occurrence of s2 in s
  s.find_first_of(s2)     // Index of first char in s that occurs in s2
  s.find_last_of(s2)      // Index of last char in s that occurs in s2
  s.find_first_not_of(s2) // Index of first char in s not found in s2
  s.find_last_not_of(s2)  // Index of last char in s not found in s2
  s.replace(i, j, s2)     // Replace s.substr(i, j) with s2
</pre> 
<tt>s.size()</tt> should be converted to 
<tt>int</tt>to avoid unsigned comparison. 
<pre>  string s(3,'a');   // "aaa"
  s += "b"+s;        // "aaabaaa"
  for (int i=0; i!=int(s.size()); ++i) {  // print s one char at a time
    cout &lt;&lt; s[i];
  s.size() &gt; -1;     // false!  -1 is converted to unsigned
</pre> 
<tt>string</tt> supports standard container operations with regard toiterators. 
<tt> string</tt> iterators are random, supporting all thepointer operators of 
<tt>char*</tt>. The notation 
<tt>[b,e)</tt> meansthe sequence such that pointer or iterator b points to the first elementand e points one past the last element. 
<pre>  s.begin()          // Iterator pointing to s[0]
  s.end()            // Iterator pointing 1 past last char
  string::iterator   // Iterator type, like char*
  string::const_iterator  // Type if s is const, like const char*
  string(b, e)       // string initialized from sequence [b,e)
  s.erase(b)         // Remove char in s pointed to by b
  s.erase(b, e)      // Remove substring [b,e) from s
  s.replace(b, e, s2)  // Replace substring [b,e) with string s2
</pre> Conversion from 
<tt>iterator</tt> to 
<tt>const_iterator</tt> isallowed, but not the other way. 
<tt>const_iterator</tt> should beused if the string is not going to be modified. 
<pre>  char* cp="ABCDE";
  string s(cp, cp+5); // "ABCDE"
  string s2(s.begin()+1, s.end()-1);  // "BCD"
  for (string::const_iterator p=s.begin(); p!=s.end(); ++p)  // Print s one char at a time
    cout &lt;&lt; *p;       // or p[0] 
</pre> As with arrays and pointers, indexing and iterator dereferencing arenot checked at run time. Creating a string with a negative or verylarge size is also trouble. 
<pre>  string s(-1, 'x');              // Crash, negative size
  string s2(s.end(), s.begin());  // Crash, negative size
  s[-1]='x';                      // Crash, out of bounds
  *s.end()='x';                   // Crash, out of bounds
  string::iterator p; *p='x';     // Crash, dereferencing uninitialized iterator
</pre> 
<a target="_blank" name="vector"></a> 
<h4>&lt;vector&gt;</h4> A 
<tt>vector&lt;T&gt;</tt> is like an array of T, but supports copying,assignment, and comparison. Its size can be set and changed at runtime, and it can efficiently implement a stack (O(1) time to push or pop).It has random iterators like 
<tt>string</tt>, which behave like type T*(or const T* if the vector is const). If T is numeric, elements areinitialized to 0. It is not possible to have an initialization listsuch as {1,2,3}. 
<pre>  vector&lt;T&gt;()            // Empty vector, elements of type T
  vector&lt;T&gt;(n)           // n elements, default initialized
  vector&lt;T&gt;(n, x)        // n elements each initialized to x
  vector&lt;T&gt; v2=v;        // Copy v to v2
  v2=v;                  // Assignment
  v2&lt;v                   // Also &gt;, ==, !=, &lt;=, &gt;= if defined for T
  vector&lt;T&gt;(b, e)        // Initialize to sequence [b, e)
  v.size()               // n
  vector&lt;T&gt;::size_type   // Type of v.size(), usually unsigned int
  v.empty()              // true if v.size() == 0
  v[i]                   // i'th element, 0 &lt;= i &lt; v.size() (unchecked), may be assigned to
  v.at(i)                // v[i] with bounds check, throws out_of_range
  v.begin(), v.end()     // Iterators [b, e)
  vector&lt;T&gt;::iterator    // Iterator type, also const_iterator
  v.back()               // v[v.size()-1] (unchecked if empty)
  v.push_back(x)         // Increase size by 1, copy x to last element
  v.pop_back()           // Decrease size by 1 (unchecked if empty)
  v.front()              // v[0] (unchecked)
  v.resize(n)            // Change size to n &gt;= 0 (unchecked)
  v.insert(d, x)         // Insert x in front of iterator d, shift, increase size by 1
  v.insert(d, n, x)      // Insert n copies of x in front of d
  v.insert(d, b, e)      // Insert copy of [b, e) in front of d
  v.erase(d)             // Remove *d, shift, decrease size by 1
  v.erase(d, e)          // Remove subsequence [d, e)
  v.clear()              // v.erase(v.begin(), v.end())
  v.reserve(n)           // Anticipate that v will grow to size n &gt;= v.size()
  v.capacity()           // Reserved size
</pre> For insert and erase, d and e must point into v (and d &lt;= e) orthe program may crash. Elements from *d to the end are shifted andthe size is changed as needed. Saved copies of iterators may become invalidafter any change of size or capacity (not checked). 
<p>To implement <tt>push_back()</tt> efficiently, a vector typicallydoubles the reserved space when it runs out in order to minimizememory reallocation and copying. <tt>reserve()</tt> allows thisstrategy to be optimized.</p> 
<pre>  // Read words from input into a stack, print in reverse order
  string s;
  vector&lt;string&gt; v;
  while (cin &gt;&gt; s)
    v.push_back(s);
  while (!v.empty()) {
    cout &lt;&lt; v.back() &lt;&lt; endl;
    v.pop_back();
  }
</pre> 
<a target="_blank" name="deque"></a> 
<h4>&lt;deque&gt;</h4> A 
<tt>deque</tt> (double ended queue) is just like a vector, butoptimized for adding and removing elements at either end in O(1) time.It lacks 
<tt>reserve()</tt> and 
<tt>capacity()</tt> and adds 
<pre>  v.push_front(x)        // v.insert(v.begin(), x)
  v.pop_front()          // v.erase(v.begin())
</pre> 
<a target="_blank" name="list"></a> 
<h4>&lt;list&gt;</h4> A 
<tt>list</tt> is like a deque but optimized for insert and erase atany point at the cost of random access. It lacks [] (indexing),and its iterators are 
<em>bidirectional</em>, not supporting [], +, -,&lt;, &gt;, &lt;=, or &gt;=. 
<tt>list</tt> adds 
<pre>  v.splice(d, v2, b);  // Move *b from list v2 to in front of d in v
  v.splice(d, v2);     // Move all elements of list v2 to in front of d in v
  v.splice(d, v2, b, e); // Move [b,e) in v2 to in front of d at v
  v.remove(x);         // Remove all elements equal to x
  v.remove_if(f);      // Remove elements x where f(x) is true
  v.sort();            // Sort list
  v.sort(f);           // Sort list using function bool f(x,y) instead of x &lt; y
  v.merge(v2);         // Merge sorted list v2 into sorted list v
  v.merge(v2, f);      // Merge using f(x,y) instead of x &lt; y to sort v
  v.unique();          // Remove duplicates from sorted list
  v.unique(f);         // Use f(x,y) instead of x == y
  v.reverse();         // Reverse order of elements
</pre> Iterators can only be moved one element at a time using ++ or --, andcompared using == or !=. 
<pre>  char* cp="ABCDE";
  list&lt;char&gt; v(cp, cp+5);  // v.size() is 5
  for (list&lt;char&gt;::const_iterator p=v.begin(); p!=v.end(); ++p)  // Print ABCDE
    cout &lt;&lt; *p;
</pre> 
<a target="_blank" name="map"></a> 
<h4>&lt;map&gt;</h4> A 
<tt>map&lt;K,V&gt; m</tt> is a set of key-value pairs with unique, sortedkeys of type K and values of type V. m[k] efficiently (O(log n) time)returns the value associated with k (as an lvalue), or creates a defaultvalue (0 if V is numeric) if k is used for the first time.A map iterator points to a 
<tt>pair&lt;const K, V&gt;</tt>, which hasmembers 
<tt>first</tt> of type const K and 
<tt>second</tt> of type V. 
<pre>  pair&lt;K,V&gt; x(k,v);    // Create a pair x containing copies of k and v
  x.first              // k
  x.second             // v
  x=make_pair(k,v)     // x.first=k; x.second=v;

  map&lt;K,V&gt; m;          // map sorted by &lt; on K
  map&lt;K,V,f&gt;()         // map sorted by f(x,y) instead of x&lt;y on K
  m[k]=v;              // Associate v (type V) with unique key k of type K
  m[k]                 // Retrieve v, or associate V() with k if new
  m.size()             // Number of unique keys
  m.empty()            // true if m.size() == 0
  map&lt;K,V&gt;::iterator   // bidirectional, points to a pair&lt;const K, V&gt;
  map&lt;K,V&gt;::const_iterator   // points to a pair&lt;const K, const V&gt;
  m.begin()            // Points to first pair (lowest k)
  m.end()              // Points 1 past last pair
  m.find(k)            // Points to pair containing k or m.end() if not found
  m.erase(k)           // Remove key K and its associated value
  m.erase(b)           // Remove pair pointed to by iterator b
  m.erase(b, e)        // Remove sequence [b, e)
  m.clear()            // Make empty: m.erase(m.begin(), m.end())
  m==m2                // Compare maps, also !=, &lt;, &lt;=, &gt;, &gt;=
</pre> We use 
<tt>m.find(k)</tt> rather than m[k] when we wish to look up kwithout increasing the size of m if k is not found. 
<pre>  // Read words, print an alphabetical index of words with their counts
  string s;
  map&lt;string, int&gt; m;
  while (cin &gt;&gt; s)
    ++m[s];
  for (map&lt;string, int&gt;::const_iterator p=m.begin(); p!=m.end(); ++p)
    cout &lt;&lt; p-&gt;first &lt;&lt; " " &lt;&lt; p-&gt;second &lt;&lt; endl;
</pre> A 
<tt>multimap</tt> is a 
<tt>map</tt> that allows duplicate keys.It support all 
<tt> map</tt> operations except []. Elements are addedby inserting a pair&lt;K,V&gt; and retrieved by 
<tt>m.equal_range(k)</tt> whichreturns a pair of iterators defining the sequence of pairs matching k. 
<pre>  multimap&lt;K,V,f&gt; m;   // f defaults to &lt; on K
  m.insert(make_pair(k,v))  // Insert a pair
  pair&lt;multimap&lt;K,V,f&gt;::iterator, multimap&lt;K,V,f&gt;::iterator&gt; p
    = m.equal_range(k) // Sequence with key k is [p-&gt;first, p-&gt;second)
</pre> 
<p>f (when used as a template argument) is a <em>functoid</em> (orfunction object), a classthat looks like a function by overloading (). For example:</p> 
<pre>  template &lt;class T&gt; class GreaterThan {
  public:
    bool operator()(const T&amp; a, const T&amp; b) const {return b &lt; a;}
  };

  map&lt;string, int, GreaterThan&lt;T&gt; &gt; m;  // keys sorted in reverse order
</pre> Some function objects can be found in 
<a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#functional" rel="nofollow noopener noreferrer"> &lt;functional&gt;</a>. 
<a target="_blank" name="set"></a> 
<h4>&lt;set&gt;</h4> A 
<tt>set&lt;K&gt;</tt> and 
<tt>multiset&lt;K&gt;</tt> are like a mapand multimap, but without values. Iterators point to a K ratherthan a pair. There is no [] operator. 
<pre>  set&lt;K&gt; m;            // Elements are sorted by &lt; on K
  m.insert(k)          // Add an element
  m.erase(k)           // Remove an element
  m.find(k)!=m.end()   // Test if k is in m
</pre> 
<a target="_blank" name="queue"></a> 
<h4>&lt;queue&gt;</h4> A 
<tt>queue</tt> is a container in which elements are inserted at theback and removed from the front. This could also be done with a 
<tt>deque</tt> or 
<tt>list</tt>, so no new capabilities are provided.A 
<tt>queue</tt> does not support iterators or indexing. 
<pre>  queue&lt;T&gt; q;          // Queue of type T
  q.size()             // Number of items in q
  q.empty()            // true if q.size() == 0
  q.push(x)            // Put x in the back
  x=q.back()           // The item last pushed, may be assigned to
  x=q.front()          // The next item to pop, may be assigned to
  q.pop()              // Remove the front item
</pre> A 
<tt>priority_queue</tt> is more useful. It sorts the items as theyare pushed so that the largest is on top and removed first. 
<pre>  priority_queue&lt;T&gt; q; // Element type is T
  priority_queue&lt;T, vector&lt;T&gt;, f&gt; q;  // Use functoid f(x,y) instead of x &lt; y to sort
  q.size(), q.empty()  // As before
  q.push(x)            // Insert x
  x=q.top()            // Largest item in q, cannot be assigned to
  q.pop()              // Remove top item
</pre> 
<a target="_blank" name="stack"></a> 
<h4>&lt;stack&gt;</h4> Items are popped from the top of a 
<tt>stack</tt> in the reverse orderin which they were pushed. It does not provide any new functionalitybeyond a vector, deque, or list, and does not support iterators or indexing. 
<pre>  stack&lt;T&gt; s;          // Stack with elements of type T
  s.size(), s.empty()  // As with queue
  s.push(x);           // Put x on top
  x=s.top();           // Last item pushed, may be assigned to
  s.pop();             // Remove the top item
</pre> 
<a target="_blank" name="bitset"></a> 
<h4>&lt;bitset&gt;</h4> A 
<tt>bitset&lt;N&gt;</tt> is like a 
<tt>vector&lt;bool&gt;</tt> with fixedsize N, but without iterators, and supporting logical operators likean N-bit 
<tt>int</tt>. Its elements have the values 0 or 1. It isimplemented efficiently, with 8 elements per byte. 
<pre>  bitset&lt;N&gt; b;         // N-bit bitset, N must be a compile time constant
  bitset&lt;N&gt; b=x;       // Initialize b[0]..b[31] from bits of long x
  b[i]                 // i'th bit, 0 &lt;= i &lt; N or throw out_of_range()
  b.size()             // N, cannot be changed
  b.set(i)             // b[i] = 1
  b.reset(i)           // b[i] = 0
  b.flip(i)            // b[i] = 1 - b[i]
  b.test(i)            // true if b[i] == 1
  b.set()              // Set all bits, also b.reset(), b.flip()
  b &amp; b2               // Bitwise AND, also | ^ ~ &lt;&lt; &gt;&gt; &amp;= |= ^= &lt;&lt;= &gt;&gt;= == !=
  b.count()            // Number of bits set to 1
  b.any()              // true if b.count() &gt; 0
  b.none()             // true if b.count() == 0
  cin &gt;&gt; b             // Read bits as '0' and '1' e.g. "10101"
  cout &lt;&lt; b            // Write bits as '0' and '1'
  bitset&lt;N&gt; b(s);      // Initialize from string s of '0' and '1' or throw invalid_argument()
  s=b.template to_string&lt;char&gt;()  // Convert to string
  x=b.to_ulong()       // Convert to unsigned long, throw overflow_error() if bits &gt; 31 set
</pre> 
<a target="_blank" name="valarray"></a> 
<h4>&lt;valarray&gt;</h4> A 
<tt>valarray</tt> is like a fixed sized array or vector that supportsarithmetic operations on all the elements at once. For instance, ifx and y are valarrays of the same size, then x+y is a valarray containingthe sums of the corresponding elements.Likewise, y=sqrt(x) assigns y[i]=sqrt(x[i]) to each element of y.In mixed type expressions,a scalar (element of type T) is promoted to a valarray of the same sizeby duplicating it, e.g. x+1 adds 1 to all elements of x. 
<pre><a target="_blank" name="valarray">  valarray&lt;T&gt; v(n);    // n elements of type T, initially T() or 0
  valarray&lt;T&gt; v(x, n); // n copies of x (note arguments are backwards)
  valarray&lt;T&gt; v(a, n); // Initialize from array a[0]..a[n-1]
  valarray&lt;T&gt; v;       // size is 0
  v.size()             // Number of elements, n
  v[i]                 // i'th element, 0 &lt;= i &lt; n, not checked
  v+=x, v+=v           // Add x or v[i] to all v[i], also = -= *= /= %= ^= &amp;= |= &lt;&lt;= &gt;&gt;=
  v+v, v+x, x+v        // Also - * / % ^ &amp; | &lt;&lt; &gt;&gt; and unary + - ~ !
  sqrt(v)              // Also all functions in </a><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#cmath" rel="nofollow noopener noreferrer">cmath</a>
  x=v.sum()            // Sum of all elements
  v.shift(n)           // Move all v[i] to v[i+n], shift in 0
  v.cshift(n)          // Move v[i] to v[(i+n) % v.size()]
  v.resize(n)          // Change size to n, but reset all elements to 0
  v.resize(n, x)       // Change size to n, set all elements to x
</pre> 
<a target="_blank" name="complex"></a> 
<h4>&lt;complex&gt;</h4> A 
<tt>complex</tt> supports complex arithmetic. It has real andimaginary parts of type T. Mixed type expressions promote realto complex (e.g. double to complex&lt;double&gt; and lower precisionto higher precision (e.g. complex&lt;int&gt; to complex&lt;double&gt;). 
<pre>  complex&lt;T&gt; x;        // (0,0), T is a numeric type
  complex&lt;T&gt; x=r;      // (r,0), convert real r to complex
  complex&lt;T&gt; x(r, i);  // (r,i)
  x=polar&lt;T&gt;(rho, theta); // Polar notation: radius, angle in radians
  x.real()             // r
  x.imag()             // i
  abs(x)               // rho = sqrt(r*r+i*i)
  arg(x)               // tan(theta) = i/r
  norm(x)              // abs(x)*abs(x)
  conj(x)              // (r,-i)
  x+y                  // Also - * / == != = += -= *= /= and unary + -
  sin(x)               // Also sinh, sqrt, tan, tanh, cos, cosh, exp, log, log10, pow(x,y)
  cout &lt;&lt; x            // Prints in format "(r,i)"
  cin &gt;&gt; x             // Expects "r", "(r)", or "(r,i)"
</pre> 
<a target="_blank" name="stdexcept"></a> 
<h4>&lt;stdexcept&gt;, &lt;exception&gt;</h4> 
<p>The standard library provides a hierarchy of exception types. Not allof them are used by the library, but any may be thrown.</p> 
<pre>  <strong>Type                   Header                   Thrown by</strong>
  exception              stdexcept, exception
    logic_error          stdexcept
      length_error       stdexcept
      domain_error       stdexcept
      out_of_range       stdexcept                .at(i) (vector/string/deque index out of bounds)
      invalid_argument   stdexcept, bitset        bitset("xxx") (not '0' or '1')
    runtime_error        stdexcept
      range_error        stdexcept    
      overflow_error     stdexcept
      underflow_error    stdexcept
    bad_alloc            new                      new, new[] (out of memory)
    bad_cast             typeinfo                 dynamic_cast&lt;T&amp;&gt; (can't convert to derived)
    bad_typeid           typeinfo                 typeid(*p) when p==0
    bad_exception        exception
    ios_base::failure    ios, iostream, fstream   istream::clear(), ostream::clear()
</pre> Catching a base class catches all derived classes, thus 
<tt>catch(exceptione)</tt> catches all of the above types. However, C++ allows throwingexceptions not derived from 
<tt>exception</tt>, so this may not catcheverything. All exceptions provide the following interface: 
<pre>  throw exception(msg)   // Throw exception with char* or string msg
  throw exception();     // Default msg
  catch(exception e) {e.what();}  // msg as a char*
</pre> 
<p><a target="_blank" name="stdexcept">New exceptions may be derived from existing types to maintain thisinterface (see </a><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#inheritance" rel="nofollow noopener noreferrer">inheritance</a>).</p> 
<pre>  class MyError: public exception {
  public:
    MyError(const string&amp; msg=""): exception(msg) {}
  }
</pre> 
<a target="_blank" name="cpplibrary"></a> 
<h3>C++ Standard Library Functions</h3> 
<p>Many C++ standard library functions operate on sequences denoted byiterators or pointers. <strong>Iterators</strong> are a family of types thatinclude pointers. They are classified by the operators they support.</p> 
<ul><li><strong>input:</strong> <tt>++p, p++, p=q, p==q, p!=q, *p</tt> (read-only)</li><li><strong>output:</strong> <tt>p=q, p==q, p!=q, *p++ = x</tt> (alternating write/increment)</li><li><strong>forward:</strong> input and output and <tt>p-&gt;m, *p</tt> (multiple read-write)</li><li><strong>bidirectional:</strong> forward and <tt>--p, p--</tt>, implemented bylist, map, multimap, set, multiset.</li><li><strong>random:</strong> bidirectional and <tt>p&lt;q, p&gt;q, p&lt;=q, p&gt;=q, p+i, i+p, p-i, p-q, p[i]</tt>,implemented by arrays (as pointers), string, vector, deque.</li></ul> 
<p>Some algorithms require certain iterator types, but will accept morepowerful types. For example, <tt>copy(b, e, d)</tt> require b and eto be at least input iterators and d to be at least an output iterator. Butit will accept forward, bidirectional, or random iterators because theseall support input and output operations. <tt>sort()</tt> requires randomiterators and will accept no other type.</p> 
<p><a target="_blank" name="cpplibrary">The notation [b,e) denotesthe sequence of e-b objects from b[0] to e[-1], i.e. b points to thebeginning of the sequence and e points one past the end. For mostcontainers, v, the sequence is [v.begin(), v.end()). For an array ofn elements, the sequence is [a, a+n).</a><a target="_blank" name="algorithm"></a></p> 
<h4><a target="_blank" name="algorithm">&lt;algorithm&gt;</a></h4> 
<a target="_blank" name="algorithm"></a> 
<p>In the following, b and e are input iterators, and d is an output iterator,unless otherwise specified. Parameters eq and lt are optional,and default to functions that take 2 arguments x and y and return x==yand x&lt;y respectively, e.g. <tt>bool eq(x,y) {return x==y;}</tt>.x and y are objects of the type pointed to by the iterators.p is a pair of iterators. f is a function or function object as noted.</p> 
<pre>  // Operations on ordinary objects
  swap(x1, x2);              // Swap values of 2 objects of the same type
  min(x1, x2);               // Smaller of x1 or x2, must be same type
  max(x1, x2);               // Larger of x1 or x2, must be same type

  // Properties of sequences (input iterators)
  equal(b, e, b2, eq);       // true if [b,e)==[b2,...)
  lexicographical_compare(b, e, b2, e2, lt);  // true if [b,e)&lt;[b2,e2)
  i=min_element(b, e);       // Points to smallest in [b,e)
  i=max_element(b, e);       // Points to largest
  n=count(b, e, x);          // Number of occurrences of x in [b,e)
  n=count_if(b, e, f);       // Number of f(x) true in [b,e)

  // Searching, i points to found item or end (e) if not found
  i=find(b, e, x);           // Find first x in [b,e)
  i=find_if(b, e, f);        // Find first x where f(x) is true
  i=search(b, e, b2, e2, eq);// Find first [b2,e2) in [b,e) (forward)
  i=find_end(b, e, b2, e2, eq); // Find last [b2,e2) in [b,e) (forward)
  i=search_n(b, e, n, x, eq);// Find n copies of x in [b,e) (forward)
  p=mismatch(b, e, b2, eq);  // Find first *p.first in [b,e) != *p.second in [b2,.) (forward)
  i=adjacent_find(b, e, eq); // Find first of 2 equal elements (forward)

  // Modifying elements
  i=copy(b, e, d);           // Copy [b,e) to [d,i)
  fill(d, i, x);             // Set all in [d,i) to x (forward)
  i=fill_n(d, n, x);         // Set n elements in [d,i) to x
  generate(d, i, f);         // Set [d,i) to f() (e.g. rand) (forward)
  i=generate_n(d, n, f);     // Set n elements in [d,i) to f()
  f=for_each(b, e, f);       // Call f(x) for each x in [b,e)
  i=transform(b, e, d, f);   // For x in [b,e), put f(x) in [d,i)
  i=transform(b, e, b2, d, f);  // For x in [b,e), y in [b2,.), put f(x,y) in [d,i)
  replace(b, e, x, y)        // Replace x with y in [b,e)
  replace_if(b, e, f, y);    // Replace with y in [b,e) where f(x) is true
  i=replace_copy(b, e, d, x, y);    // Copy [b,e) to [d,i) replacing x with y
  i=replace_copy_if(b, e, d, f, y); // Copy replacing with y where f(x) is true

  // Rearranging sequence elements
  sort(b, e, lt);            // Sort [b,e) by &lt; (random)
  stable_sort(b, e, lt);     // Sort slower, maintaining order of equal elements (random)
  partial_sort(b, m, e, lt); // Sort faster but leave [m,e) unsorted (random)
  nth_element(b, m, e, lt);  // Sort fastest but only *m in proper place (random)
  iter_swap(b, e);           // swap(*b, *e) (forward)
  i=swap_ranges(b, e, b2);   // swap [b,e) with [b2,i) (forward)
  i=partition(b, e, f);      // Moves f(x) true to front, [i,e) is f(x) false (bidirectional)
  i=stable_partition(b, e, f);  // Maintains order within each partition
  i=remove(b, e, x);         // Move all x to end in [i,e) (forward)
  i=remove_if(b, e, f);      // Move f(x) true to front in [b,i) (forward)
  i=remove_copy(b, e, d, x); // Copy elements matching x to [d,i)
  i=remove_copy_if(b, e, d, f);  // Copy elements x if f(x) is false to [d,i)
  replace(b, e, x1, x2);     // Replace x1 with x2 in [b,e)
  i=replace_copy(b, e, d, x1, x2);  // Copy [b,e) to [d,i) replacing x1 with x2
  reverse(b, e);             // Reverse element order in [b,e) (bidirectional)
  i=reverse_copy(b, e, d);   // Copy [b,e) to [d,i) reversing the order (b,e bidirectional)
  rotate(b, m, e);           // Move [b,m) behind [m,e) (forward)
  i=rotate_copy(b, m, e, d); // Rotate into [d,i)
  random_shuffle(b, e, f);   // Random permutation, f() defaults to rand()
  next_permutation(b, e, lt);// Next greater sequence, true if successful (bidirectional)
  prev_permutation(b, e, lt);// Previous permutation, true if successful (bidirectional)

  // Operations on sorted sequences
  i=unique(b, e, eq);            // Move unique list to [b,i), extras at end
  i=unique_copy(b, e, d, eq);    // Copy one of each in [b,d) to [d,i)
  i=binary_search(b, e, x, lt);  // Find i in [b,e) (forward)
  i=lower_bound(b, e, x, lt);    // Find first x in [b,e) or where to insert it (forward)
  i=upper_bound(b, e, x, lt);    // Find 1 past last x in [b,e) or where to insert it (forward)
  p=equal_range(b, e, x, lt);    // p.first = lower bound, p.second = upper bound (forward)
  includes(b, e, b2, e2, lt);    // true if [b,e) is a subset of [b2,e2)
  i=merge(b, e, b2, e2, d, lt);  // Merge [b,e) and [b2,e2) to [d,i)
  inplace_merge(b, m, e, lt);    // Merge [b,m) and [m,e) to [b,e) (bidirectional)
  i=set_union(b, e, b2, e2, d, lt);  // [d,i) = unique elements in either [b,e) or [b2,e2)
  i=set_intersection(b, e, b2, e2, d, lt);  // [d,i) = unique elements in both
  i=set_difference(b, e, b2, e2, d, lt);    // [d,i) = unique elements in [b,e) but not [b2,e2)
  i=set_symmetric_difference(b, e, b2, e2, d, lt);  // [d,i) = elements in one but not both
</pre> Algorithms never change the size of a container. When copying, thedestination must be large enough to hold the result. 
<pre>  int a[5]={3,1,4,1,6};
  vector b(5);
  copy(a, a+5, v.begin());   // Copy a to v
  remove(a, a+5, 1);         // {3,4,6,1,1}, returns a+3
  sort(a, a+4);              // {1,3,4,6,1}
</pre> 
<a target="_blank" name="numeric"></a> 
<h4>&lt;numeric&gt;</h4> In the following, 
<tt>plus, minus,</tt> and 
<tt>times</tt> areoptional functions taking 2 arguments x and y that return x+y, x-y,and x*y respectively, e.g. 
<tt>int plus(int x, int y) {return x+y;}</tt> 
<pre>  x=accumulate(b, e, x, plus);                // x + sum over [b,e)
  x=inner_product(b, e, b2, x, plus, times);  // x + sum [b,e)*[b2,e2)
  adjacent_difference(b, e, minus);           // for i in (b,e) *i -= i[-1]
  partial_sum(b, e, plus);                    // for i in [b,e) *i += sum [b,i)
</pre> 
<a target="_blank" name="iterator"></a> 
<h4>&lt;iterator&gt;</h4> 
<p>An inserter is an output iterator that expands the container itpoints to by calling push_back(), push_front(), or insert(). The containermust support this operation. A stream iteratorcan be used to do formatted input or output using &gt;&gt; or &lt;&lt;</p> 
<pre>  back_inserter(c);             // An iterator that appends to container c
  front_inserter(c);            // Inserts at front of c
  inserter(c, p);               // Inserts in front of p
  ostream_iterator&lt;T&gt;(out, cp); // Writes to ostream separated by char* cp (default " ")
  istream_iterator&lt;T&gt;(in);      // An input iterator that reads T objects from istream
</pre> The most common use is to copy to an empty vector, deque, or list. 
<pre>  vector&lt;int&gt; from(10), to;
  copy(from.begin(), from.end(), back_inserter(to));
</pre> 
<p><a target="_blank" name="iterator">This header also defines tag types to be used for creatingiterator types that work with algorithms. See</a><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#defining_iterators" rel="nofollow noopener noreferrer">defining iterators</a>.<a target="_blank" name="functional"></a></p> 
<h4><a target="_blank" name="functional">&lt;functional&gt;</a></h4> 
<a target="_blank" name="functional"></a> 
<p>Functions in &lt;functional&gt; create <em>function objects</em>, whichare objects that behave like functions by overloading <tt>operator()</tt>.These can be passed to algorithms that take function arguments, e.g.</p> 
<pre>  vector&lt;int&gt; v(10);
  sort(v.begin(), v.end(), greater&lt;int&gt;());  // Sort v in reverse order
  int x=accumulate(v.begin(), v.end(), 1, multiplies&lt;T&gt;);  // Product of elements  
</pre> The following create function objects that take one or two parametersx and y of type T and return the indicated expression, i.e., 
<tt>equal_to&lt;int&gt;()(3,4)</tt> returns false. 
<pre>   // Predicates (return bool)
   equal_to&lt;T&gt;()                 // x==y
   not_equal_to&lt;T&gt;()             // x!=y
   greater&lt;T&gt;()                  // x&gt;y
   less&lt;T&gt;()                     // x&lt;y
   greater_equal&lt;T&gt;()            // x&gt;=y
   less_equal&lt;T&gt;()               // x&lt;=y
   logical_and&lt;bool&gt;()           // x&amp;&amp;y
   logical_or&lt;bool&gt;()            // x||y
   logical_not&lt;bool&gt;()           // !x (unary)

   // Arithmetic operations (return T)
   plus&lt;T&gt;()                     // x+y
   minus&lt;T&gt;()                    // x-y
   multiplies&lt;T&gt;()               // x*y
   divides&lt;T&gt;()                  // x/y
   modulus&lt;T&gt;()                  // x%y
   negate&lt;T&gt;()                   // -x (unary)
</pre> A 
<em>binder</em> converts a 2-argument function object into a 1-argumentobject by binding a fixed value 
<tt>c</tt> to the other argument, e.g. 
<tt>bind2nd(less&lt;int&gt;(), 10) returns a function object that takes oneargument x and returns true if x&lt;10.</tt> 
<pre>  bind1st(f, c)                  // An object computing f(c,y)
  bind2nd(f, c)                  // An object computing f(x,c)

  i=find_if(v.begin(), v.end(), bind2nd(equal_to&lt;int&gt;(), 0));  // Find first 0
</pre> The following convert ordinary functions and member functions intofunction objects. All functions must be converted to be passed tobind1st and bind2nd. Member functions must also be converted to bepassed to algorithms. 
<pre>  ptr_fun(f)                     // Convert ordinary function f to object
  mem_fun(&amp;T::f)                 // Convert member function of class T
  mem_fun_ref(T::f)              // Same

  i=find_if(v.begin(), v.end(), mem_fun(&amp;string::empty));  // Find ""
  transform(v.begin(), v.end(), v.begin(), bind2nd(ptr_fun(pow), 2.0));  // Square elements
</pre> 
<tt>not1()</tt> and not2() negate a unary or binary function object. 
<pre>  not1(f)                        // Object computing !f(x)
  not2(f)                        // Object computing !f(x,y)

  i=find_if(v.begin(), v.end(), not1(bind2nd(equal_to&lt;int&gt;(), 0)));  // Find nonzero
</pre> 
<a target="_blank" name="new"></a> 
<h4>&lt;new&gt;</h4> 
<p>The default behavior of <tt>new</tt> is to throw an exception oftype <tt>bad_alloc</tt> ifout of memory. This can be changed by writing a function (takingno parameters and returning void) and passing it to<tt>set_new_handler()</tt>.</p> 
<pre>  void handler() {throw bad_alloc();} // The default
  set_new_handler(handler);
</pre> 
<tt>new(nothrow)</tt> may be used in place of 
<tt>new</tt>. Ifout of memory, it returns 0 rather than throw bad_alloc. 
<pre>  int* p = new(nothrow) int[1000000000];  // p may be 0
</pre> 
<a target="_blank" name="clibrary"></a> 
<h3>C Library Functions</h3> The C library is provided for backwards compatibility with the C language.Because C lacked namespaces, all types and functions were defined globally.For each C header, C++ provides an additional header by prefixing "c"and dropping the ".h" suffix, which places everything in namespace 
<tt>std</tt>.For instance, 
<tt>&lt;stdio.h&gt;</tt> becomes 
<tt> &lt;cstdio&gt;</tt>. 
<a target="_blank" name="cstdlib"></a> 
<h4>&lt;cstdlib&gt;</h4> 
<p>Miscellaneous functions. s is type char*, n is int</p> 
<pre>  atoi(s); atol(s); atof(s);// Convert char* s to int, long, double e.g. atof("3.5")
  abs(x); labs(x);          // Absolute value of numeric x as int, long
  rand();                   // Pseudo-random int from 0 to RAND_MAX (at least 32767)
  srand(n);                 // Initialize rand(), e.g. srand(time(0));
  system(s);                // Execute OS command s, e.g. system("ls");
  getenv(s);                // Environment variable or 0 as char*, e.g. getenv("PATH"); 
  exit(n);                  // Kill program, return status n, e.g. exit(0);
  void* p = malloc(n);      // Allocate n bytes or 0 if out of memory.  Obsolete, use new.
  p = calloc(n, 1);         // Allocate and set to 0 or return NULL.  Obsolete.
  p = realloc(p, n);        // Enlarge to n bytes or return NULL.  Obsolete.
  free(p);                  // Free memory.  Obsolete: use delete
</pre> 
<a target="_blank" name="cctype"></a> 
<h4>&lt;cctype&gt;</h4> 
<p>Character tests take a char c and return bool.</p> 
<pre>  isalnum(c);               // Is c a letter or digit?
  isalpha(c); isdigit(c);   // Is c a letter?  Digit?
  islower(c); isupper(c);   // Is c lower case?  Upper case?
  isgraph(c); isprint(c);   // Printing character except/including space?
  isspace(c); iscntrl(c);   // Is whitespace?  Is a control character?
  ispunct(c);               // Is printing except space, letter, or digit?
  isxdigit(c);              // Is hexadecimal digit?
  c=tolower(c); c=toupper(c);   // Convert c to lower/upper case
</pre> 
<a target="_blank" name="cmath"></a> 
<h4>&lt;cmath&gt;</h4> 
<p>Functions take double and return double.</p> 
<pre>  sin(x); cos(x); tan(x);   // Trig functions, x in radians
  asin(x); acos(x); atan(x);// Inverses
  atan2(y, x);              // atan(y/x)
  sinh(x); cosh(x); tanh(x);// Hyperbolic
  exp(x); log(x); log10(x); // e to the x, log base e, log base 10
  pow(x, y); sqrt(x);       // x to the y, square root
  ceil(x); floor(x);        // Round up or down (as a double)
  fabs(x); fmod(x, y);      // Absolute value, x mod y
</pre> 
<a target="_blank" name="ctime"></a> 
<h4>&lt;ctime&gt;</h4> 
<p>Functions for reading the system clock. <tt>time_t</tt> isan integer type (usually long). <tt>tm</tt> is a struct.</p> 
<pre>  clock()/CLOCKS_PER_SEC;   // Time in seconds since program started
  time_t t=time(0);         // Absolute time in seconds or -1 if unknown
  tm* p=gmtime(&amp;t);         // 0 if UCT unavailable, else p-&gt;tm_X where X is:
    sec, min, hour, mday, mon (0-11), year (-1900), wday, yday, isdst
  asctime(p);               // "Day Mon dd hh:mm:ss yyyy\n"
  asctime(localtime(&amp;t));   // Same format, local time
</pre> 
<a target="_blank" name="cstring"></a> 
<h4>&lt;cstring&gt;</h4> 
<p>Functions for performing string-like operations on arrays of charmarked with a terminating '\0' (such as <tt>"quoted literals"</tt>or as returned by <tt>string::c_str()</tt>. Mostly obsoleted bytype <tt>string</tt>.</p> 
<pre>  strcpy(dst, src);         // Copy src to dst. Not bounds checked
  strcat(dst, src);         // Concatenate to dst. Not bounds checked
  strcmp(s1, s2);           // Compare, &lt;0 if s1&lt;s2, 0 if s1==s2, &gt;0 if s1&gt;s2
  strncpy(dst, src, n);     // Copy up to n chars, also strncat(), strncmp()
  strlen(s);                // Length of s not counting \0
  strchr(s,c); strrchr(s,c);// Address of first/last char c in s or 0
  strstr(s, sub);           // Address of first substring in s or 0
    // mem... functions are for any pointer types (void*), length n bytes
  memcpy(dst, src, n);      // Copy n bytes from src to dst
  memmove(dst, src, n);     // Same, but works correctly if dst overlaps src
  memcmp(s1, s2, n);        // Compare n bytes as in strcmp
  memchr(s, c, n);          // Find first byte c in s, return address or 0
  memset(s, c, n);          // Set n bytes of s to c
</pre> 
<a target="_blank" name="cstdio"></a> 
<h4>&lt;cstdio&gt;</h4> 
<p>The <tt>stdio</tt> library is made mostly obsolete by the newer<tt>iostream</tt>library, but many programs still use it. There are facilities forrandom access files and greater control over output format,error handling, and temporary files. Mixing both I/O libraries isnot recommended. There are no facilities for string I/O.</p> 
<p>Global objects <tt>stdin, stdout, stderr</tt> of type <tt>FILE*</tt>correspond to <tt>cin, cout, cerr</tt>. s is type char*, c is char,n is int, f is FILE*.</p> 
<pre>  FILE* f=fopen("filename", "r");  // Open for reading, NULL (0) if error
    // Mode may also be "w" (write) "a" append, "a+" random access read/append,
    // "rb", "wb", "ab", "a+b" are binary
  fclose(f);                // Close file f
  fprintf(f, "x=%d", 3);    // Print "x=3"  Other conversions:
    "%5d %u %-8ld"            // int width 5, unsigned int, long left justified
    "%o %x %X %lx"            // octal, hex, HEX, long hex
    "%f %5.1f"                // double: 123.000000, 123.0
    "%e %g"                   // 1.23e2, use either f or g
    "%c %s"                   // char, char*
    "%%"                      // %
  sprintf(s, "x=%d", 3);    // Print to array of char s
  printf("x=%d", 3);        // Print to stdout (screen unless redirected)
  fprintf(stderr, ...       // Print to standard error (not redirected)
  getc(f);                  // Read one char (as an int, 0-255) or EOF (-1) from f
  ungetc(c, f);             // Put back one c to f
  getchar();                // getc(stdin);
  putc(c, f)                // fprintf(f, "%c", c);
  putchar(c);               // putc(c, stdout);
  fgets(s, n, f);           // Read line including '\n' into char s[n] from f.  NULL if EOF
  gets(s)                   // fgets(s, INT_MAX, f); no '\n' or bounds check
  fread(s, n, 1, f);        // Read n bytes from f to s, return number read
  fwrite(s, n, 1, f);       // Write n bytes of s to f, return number written
  fflush(f);                // Force buffered writes to f
  fseek(f, n, SEEK_SET);    // Position binary file f at n
    // or SEEK_CUR from current position, or SEEK_END from end
  ftell(f);                 // Position in f, -1L if error
  rewind(f);                // fseek(f, 0L, SEEK_SET); clearerr(f);
  feof(f);                  // Is f at end of file?
  ferror(f);                // Error in f?
  perror(s);                // Print char* s and last I/O error message to stderr
  clearerr(f);              // Clear error code for f
  remove("filename");       // Delete file, return 0 if OK
  rename("old", "new");     // Rename file, return 0 if OK
  f = tmpfile();            // Create temporary file in mode "wb+"
  tmpnam(s);                // Put a unique file name in char s[L_tmpnam]
</pre> 
<p>Example: input file name and print its size</p> 
<pre>  char filename[100];              // Cannot be a string
  printf("Enter filename\n");      // Prompt
  gets(filename, 100, stdin);      // Read line ending in "\n\0"
  filename[strlen(filename)-1]=0;  // Chop off '\n';
  FILE* f=fopen(filename, "rb");   // Open for reading in binary mode
  if (f) {                         // Open OK?
    fseek(f, 0, SEEK_END);         // Position at end
    long n=ftell(f);               // Get position
    printf("%s has %ld bytes\n", filename, n);
    fclose(f);                     // Or would close when program ends
  }
  else
    perror(filename);              // fprintf(stderr, "%s: not found\n", filename);
                                   // or permission denied, etc.
</pre> 
<tt>printf(), fprintf()</tt>, and 
<tt>sprintf()</tt> accept a variablenumber of arguments, one for each "%" in the format string, which mustbe the appropriate type. The compiler does not check for this. 
<pre>  printf("%d %f %s", 2, 2.0, "2");  // OK
  printf("%s", 5);  // Crash: expected a char* arg, read from address 5
  printf("%s");     // Crash
  printf("%s", string("hi"));  // Crash: use "hi" or string("hi").c_str()
</pre> 
<a target="_blank" name="cassert"></a> 
<h4>&lt;cassert&gt;</h4> 
<p>Provides a debugging function for testing conditions whereall instances can be turned on or off at once. <tt>assert(false);</tt>prints the asserted expression, source code file name, and line number,then aborts.Compiling with <strong><tt>g++ -DNDEBUG</tt></strong> effectively removesthese statements.</p> 
<pre>  assert(e);                // If e is false, print message and abort
  #define NDEBUG            // (before #include &lt;assert.h&gt;), turn off assert
</pre> 
<a target="_blank" name="classes"></a> 
<h3>Classes</h3> 
<p>Classes provide data abstraction, the ability to create new types and hidetheir implementation in order to improve maintainability.A <tt>class</tt> is a data structure and an associated set of<em>member functions</em> (methods) and related type declarationswhich can be associated with the class or instances (objects) of theclass. A class is divided into a <tt>public</tt> interface, visiblewherever the class or its instances are visible, and a <tt>private</tt>implementation visible only to member functions of the class.</p> 
<pre>  class T {          // Create a new type T
  private:           // Members are visible only to member functions of T (default)
  public:            // Members are visible wherever T is visible
    // Type, object, and function declarations
  };
  T::m;              // Member m of type T
  T x;               // Create object x of type T
  x.m;               // Member m of object x
  T* p=&amp;x; p-&gt;m;     // Member m of object pointed to by p
</pre> Typically the data structure is private, and functionality is providedby member functions. Member function definitions should be separated fromthe declaration and written outside the class definition, or else theyare assumed to be inline (which is appropriate for short functions).A member function should be declared const (before the opening brace)if it does not modify any data members. Only const member functions maybe called on const objects. 
<pre>  class Complex {    // Represents imaginary numbers
  private:
    double re, im;   // Data members, represents re + im * sqrt(-1)
  public:
    void set(double r, double i) {re=r; im=i;}  // Inlined member function definition
    double real() const {return re;}            // const - does not modify data members
    double imag() const;                        // Declaration for non-inlined function
  };
  double Complex::imag() const {return im;}     // Definition for imag()
  int main() {
    Complex a, b=a;                // Objects of type Complex
    a.set(3, 4);                   // Call a member function
    b=a;                           // Assign b.re=a.re; b.im=a.im
    b==a;                          // Error, == is not defined
    cout &lt;&lt; a.re;                  // Error, re is private
    cout &lt;&lt; a.real();              // OK, 3
    cout &lt;&lt; Complex().real();      // OK, prints an undefined value
    Complex().set(5, 6);           // Error, non-const member called on const object
</pre> 
<p>A class has two special member functions, a <em>constructor</em>, which is calledwhen the object is created, and a <em>destructor</em>, called when destroyed.The constructor is named <tt><em>class</em>::<em>class</em></tt>, has no returntype or value, may be overloaded and have default arguments, and isnever const. It is followed by an optional initialization listlisting each data member and its initial value. Initializationtakes place before the constructor code is executed. Initializationmight not be in the order listed. Members not listedare default-initialized by calling their constructors with defaultarguments. If no constructor is written, the compiler provides one whichdefault-initializes all members. The syntax is:</p> 
<pre>  <em>class</em>::<em>class</em>(<em>parameter list</em>): <em>member</em>(<em>value</em>), <em>member</em>(<em>value</em>) { <em>code...</em>}
</pre> 
<p>The destructor is named <tt><em>class</em>::~<em>class</em></tt>, has noreturn type or value, no parameters, and is never const. It is usuallynot needed except to return shared resources by closing files ordeleting memory. After the code executes, the data members aredestroyed using their respective destructors in the reverse orderin which they were constructed.</p> 
<pre>  class Complex {
  public:
    Complex(double r=0, double i=0): re(r), im(i) {}  // Constructor
    ~Complex() {}                                     // Destructor
    // Other members...
  };
  Complex a(1,2), b(3), c=4, d;  // (1,2) (3,0) (4,0) (0,0)
</pre> 
<p>A constructor defines a conversion function for creating temporaryobjects. A constructor that allows 1 argument allows implicit conversionwherever needed, such as in expressions, parameter passing, assignment,and initialization.</p> 
<pre>  Complex(3, 4).real();  // 3
  a = 5;                 // Implicit a = Complex(5) or a = Complex(5, 0)

  void assign_if(bool, Complex&amp;, const Complex&amp;);
  assign_if(true, a, 6); // Implicit Complex(6) passed to third parameter
  assign_if(true, 6, a); // Error, non-const reference to Complex(6), which is const
</pre> 
<p>Operators may be overloaded as members. The expression <tt>aXb</tt> foroperator X can match either <tt>operator X(a, b)</tt> (global)or <tt>a.operator X(b)</tt> (member function), but not both.Unary operators omit b.Operators =, [], and -&gt; can only be overloaded as member functions.</p> 
<pre>  class Complex {
  public:
    Complex operator + (const Complex&amp; b) const { // const because a+b doesn't change a
      return Complex(re+b.re, im+b.im);
    }
    // ...
  };

  Complex operator - (const Complex&amp; a, const Complex&amp; b) {
    return Complex(a.real()-b.real(), a.imag()-b.imag());
  }

  Complex a(1, 2), b(3, 4);
  a+b;                    // OK, a.operator+(b) == Complex(4, 6)
  a-b;                    // OK, operator-(a, b) == Complex(-2, -2)
  a+10;                   // OK, Complex(1, 12), implicit a+Complex(10, 0)
  10+a;                   // Error, 10 has no member operator+(Complex)
  a-10;                   // OK, Complex(1, -8)
  10-a;                   // OK, Complex(7, -4)
</pre> 
<p>The member function (+) has the advantage of private access (including toother objects of the same class), but can only doimplicit conversions on the right side. The global function (-) issymmetrical, but lacks private access. A <tt>friend</tt> declaration(in either the private or public section) allows private access toa global function.</p> 
<pre>  class Complex {
    friend Complex operator-(const Complex&amp;, const Complex&amp;);
    friend class T;       // All member functions of class T are friends
    // ...
  };
</pre> 
<p>A conversion operator allows implicit conversion to another type.It has the form of a member function named <tt>operator T() const</tt> withimplied return type T. It is generally a good idea to allow implicitconversions in only one direction, preferably with constructors, sothis member function is usually used to convert to pre-existing types.</p> 
<pre>  class Complex {
  public:
    operator double() const {return re;}
    // ...
  }

  Complex a(1, 2);
  a-10;                  // Error, double(a)-10 or a-Complex(10) ?
  a-Complex(10);         // Complex(-9, 2);
  double(a)-10;          // -9
</pre> 
<p>An <tt>explicit</tt> constructor does not allow implicit conversions.</p> 
<pre>  class Complex {
    explicit Complex(double r=0, double i=0);
    // ...
  };

  Complex a=1;           // Error
  Complex a(1);          // OK
  a-10;                  // OK, double(a)-10 = -9
  a-Complex(10);         // OK, Complex(-9, 0)
</pre> 
<a target="_blank" name="templateclass"></a> 
<p>A class or member function may be <strong>templated</strong>.The type parameter must be passed inthe declaration for objects of the class.</p> 
<pre>  template &lt;class T&gt;
  class Complex {
    T re, im;
  public:
    T real() const {return re;}
    T imag() const {return im;}
    Complex(T r=0, T i=0);
    friend Complex&lt;T&gt; operator - (const Complex&lt;T&gt;&amp;, const Complex&lt;T&gt;&amp;);
  };

  template &lt;class T&gt;
  Complex&lt;T&gt;::Complex(T r, T i): re(r), im(i) {}

  Complex&lt;int&gt; a(1, 2);               // Complex of int
  Complex&lt;double&gt; b(1.0, 2.0);        // Complex of double
  a=a-Complex&lt;int&gt;(3, 4);             // Complex&lt;int&gt;(-2, -2)
  Complex&lt;Complex&lt;double&gt; &gt; c(b, b);  // Note space, not &gt;&gt;
  c.real().imag();                    // 2.0
</pre> Templates can have default arguments and int parameters. The argumentto an int parameter must be a value known at compile time. 
<pre>  template &lt;class T, class U=T, int n=0&gt; class V {};
  V&lt;double, string, 3&gt; v1;
  V&lt;char&gt; v2;  // V&lt;char, char, 0&gt;
</pre> 
<p>Classes define default behavior for copying and assignment, which isto copy/assign each data member. This behavior can be overridden bywriting a <em>copy constructor</em> and <tt>operator=</tt> as members,both taking arguments of the same type, passed by const reference.They are usually required in classes that have destructors, such as the<tt>vector&lt;T&gt;</tt>-like class below. If we did not overload these,the default behavior would be to copy the data pointer, resulting intwo Vectors pointing into the same array. The assignment operatornormally returns itself (<tt>*this</tt>) by reference to allowexpressions of the form <tt>a=b=c;</tt>, but is not required to do so.<tt>this</tt> means the address of the current object; thus any member<tt>m</tt> may also be called <tt>this-&gt;m</tt> within a member function.</p> 
<pre>  template &lt;class T&gt;
  class Vector {
  private:
    T* data;  // Array of n elements
    int n;    // size()
  public:
    typedef T* iterator;                      // Vector::iterator means T*
    typedef const T* const_iterator;          // Iterators for const Vector
    int size() const {return n;}              // Number of elements
    T&amp; operator[](int i) {return data[i];}    // i'th element
    const T&amp; operator[](int i) const {return data[i];}  // i'th element of const Vector
    iterator begin() {return data;}           // First, last+1 elements
    iterator end() {return data+size();}
    const_iterator begin() const {return data;}  // Const versions
    const_iterator end() const {return data+size();}
    Vector(int i=0): data(new T[i]), n(i) {}  // Create with size i
    ~Vector() {delete[] data;}                // Return memory
    Vector(const Vector&lt;T&gt;&amp; v): data(new T[v.n]), n(v.n) {  // Copy constructor
      copy(v.begin(), v.end(), begin());
    }
    Vector&amp; operator=(const Vector&amp; v) {      // Assignment
      if (&amp;v != this) {                       // Assignment to self?
        delete[] data;                        // If not, resize and copy
        data=new T[n=v.n];
        copy(v.begin(), v.end(), begin());
      }
      return *this;                           // Allow a=b=c;
    }
    template &lt;class P&gt; Vector(P b, P e): data(new T[e-b]), n(e-b) {  // Templated member
      copy(b, e, data);                       // Initialize from sequence [b, e)
    }
  };
</pre> A type defined in a class is accessed through 
<tt><em>class</em>::type</tt> 
<pre>  Vector&lt;int&gt;::iterator p;        // Type is int*
  Vector&lt;int&gt;::const_iterator cp; // Type is const int*
</pre> Member functions may be overloaded on 
<tt>const</tt>.Overloaded member functions neednot have the same return types. 
<tt>const</tt> member functions should notreturn non-const references or pointers to data members. 
<pre>  Vector&lt;int&gt; v(10);              // Uses non-const [], begin(), end()
  const Vector&lt;int&gt; cv(10);       // Uses const [], begin(), end()
  cv=v;                           // Error, non-const operator= called on cv
  v[5]=cv[5];                     // OK. assigns to int&amp;
  cv[5]=v[5];                     // Error, assigns to const int&amp;
  p=cv.begin();                   // Error, would allow *p=x to write into cv
  cp=cv.begin();                  // OK because can't assign to *cp
</pre> 
<a target="_blank" name="defining_iterators"></a> 
<p><a target="_blank" name="defining_iterators"><strong>Defining Iterators</strong>.Sometimes a container's iterator types must be defined as nestedclasses overloading the usual pointer operations rather than typedef'edto pointers.In order to work properly with functions defined in</a><a target="_blank" href="http://cs.fit.edu/%7Emmahoney/cse2050/how2cpp.html#algorithm" rel="nofollow noopener noreferrer">&lt;algorithm&gt;</a>, iterators should define the following5 public typedefs:</p> 
<ul><li><tt>iterator_category</tt>: one of the following (defined in <tt>&lt;iterator&gt;</tt>): 
  <ul><li><tt>output_iterator_tag</tt> (if sequential writing is supported) </li><li><tt>input_iterator_tag</tt> (if sequential reading is supported) </li><li><tt>forward_iterator_tag</tt> (if both are supported) </li><li><tt>bidirectional_iterator_tag</tt> (if the iterator can be decremented) </li><li><tt>random_access_iterator_tag</tt> (if all pointer operations are supported) </li></ul> </li><li><tt>value_type</tt>: the type of the elements, for example, <tt>T</tt> </li><li><tt>difference_type</tt>: the result of iterator subtraction, usually <tt>ptrdiff_t</tt> (a signed int type) </li><li><tt>pointer</tt>: the type returned by <tt>operator-&gt;()</tt>, usually <tt>T*</tt> or <tt>const T*</tt> </li><li><tt>reference</tt>: the type returned by <tt>operator*()</tt>, usually <tt>T&amp;</tt> or <tt>const T&amp;</tt></li></ul> 
<p>Operator -&gt; should be overloaded as a unary function returning apointer to a class to which -&gt; will be applied, i.e. <tt>x-&gt;m</tt> isinterpreted as <tt>x.operator-&gt;()-&gt;m</tt>. Nested class membersare named Outer::Inner::member. Outer and inner classes cannot accesseach other's private members. Templated members defined outside theclass need their own template declarations.</p> 
<pre>  template &lt;class T&gt; class Vector {
  public:

    // Reverse iterator for Vector, i.e. ++p goes to the previous element.
    class reverse_iterator {
    private:
      T* p;                                // Points to current element
    public:

      // typedefs needed to work with &lt;algorithm&gt; functions
      typedef std::random_access_iterator_tag iterator_category;  // Defined in &lt;iterator&gt;
      typedef T value_type;                // Type of element
      typedef ptrdiff_t difference_type;   // Result of iterator subtraction, usually int
      typedef T* pointer;                  // Type returned by operator -&gt;
      typedef T&amp; reference;                // Type returned by operator *

      reverse_iterator(T* a=0): p(a) {}    // Implicit conversion from T* and iterator
      iterator base() const {return p;}    // Convert to normal iterator

      // Forward operators
      reverse_iterator&amp; operator++() {--p; return *this;} // prefix
      reverse_iterator  operator++(int);                  // postfix, we pretend it's binary
      reference operator*() const {return *p;}
      pointer operator-&gt;() const {return p;}              // We pretend it's unary
      bool operator==(Vector&lt;T&gt;::reverse_iterator b) const {return p==b.p;}
      bool operator!=(Vector&lt;T&gt;::reverse_iterator b) const {return p!=b.p;}
      // Also, bidirectional and random operators
    };
    reverse_iterator rbegin() {return end()-1;}
    reverse_iterator rend() {return begin()-1;}
    // Other members...
  };

  // Code for postfix ++
  template &lt;class T&gt;
  inline Vector&lt;T&gt;::reverse_iterator Vector::reverse_iterator::operator++(int dummy) {
    Vector&lt;T&gt;::reverse_iterator result = *this;
    ++*this;
    return result;
  };

  // Print a Vector in reverse order
  int main() {
    Vector&lt;int&gt; a(10);
    for (Vector&lt;int&gt;::reverse_iterator p=a.rbegin(); p!=a.rend(); ++p)
      cout &lt;&lt; *p &lt;&lt; endl;
</pre> 
<tt>vector&lt;T&gt;</tt> supplies random 
<tt>reverse_iterator</tt> and 
<tt>const_reverse_iterator</tt>as above. Const iterators would typedef 
<tt>pointer</tt> as 
<tt>const T*</tt>and 
<tt>reference</tt> as 
<tt>const T&amp;</tt>. 
<p>A <tt>static</tt> data member is shared by all instances of a class.It must be initialized in a separate declaration, not in the class definitionor in the constructor initialization list. A <tt>static</tt> member functioncannot refer to <tt>this</tt> or anynon-static members (and therefore it makes no sense to make them<tt>const</tt>). Static members may be referenced either as<tt><em>object.member</em></tt> or <tt><em>class</em>::<em>member</em></tt>.</p> 
<pre>  class Counter {
    static int count;  // Number of Counters that currently exist (private)
  public:
    static int get() {return count;}
    Counter() {++count;}
    ~Counter() {--count;}
    Counter(const Counter&amp; c) {++count;}  // Default would be wrong
    Counter&amp; operator=(const Counter&amp; c) {return *this;}  // Default would be OK
  };
  int Counter::count = 0;  // Initialize here, OK if private
  main() {
    Counter a, b, c;
    cout &lt;&lt; b.get();         // 3
    cout &lt;&lt; Counter::get();  // 3
  }
</pre> 
<a target="_blank" name="inheritance"></a> 
<h4>Inheritance</h4> Inheritance is used to write a specialized or enhanced version ofanother class. For example, an 
<tt>ofstream</tt> is a type of 
<tt>ostream</tt>. 
<tt>class <em>D</em>: public <em>B</em></tt> defines class D as 
<em>derived</em> from (subclass of) 
<em>base</em> class (superclass) B,meaning that D 
<em>inherits</em>all of B's members, except the constructors, destructor, and assignmentoperator. The default behavior of these special member functions is to treatthe base class as a data member. 
<pre>  class String: public Vector&lt;char&gt; {
  public:
    String(const char* s=""): Vector&lt;char&gt;(strlen(s)) {
      copy(s, s+strlen(s), begin());  // Inherits Vector&lt;char&gt;::begin()
    }
  };
  String a="hello"; // Calls Vector&lt;char&gt;::Vector(5);
  a.size();         // 5, inherits Vector&lt;char&gt;::size()
  a[0]='j';         // "jello", inherits Vector&lt;char&gt;::operator[]
  String b=a;       // Default copy constructor uses Vector's copy constructor on base part
  b=a;              // Default = calls Vector's assignment operator on base part
</pre> The default destructor 
<tt>String::~String() {}</tt> is correct,since in the process of destroying a String, the base is alsodestroyed, calling 
<tt>Vector&lt;char&gt;::~Vector() {delete data[];}</tt>.Since there is no need to write a destructor, there is no need toredefine copying or assignment either. 
<p>Although <tt>String</tt> inherits <tt>Vector&lt;char&gt;::data</tt>,it is privateand inaccessible. A <tt>protected</tt> member is accessible to derivedclasses but private elsewhere.</p> 
<pre>  class B {
  protected:
    int x;
  } b;                            // Declare class B and object b
  b.x=1;                          // Error, x is protected

  class D: public B {
    void f() {x=1;}               // OK
  };
</pre> By default, a base class is private, making all inherited membersprivate. Private base classes are rare and typically used asimplementations rather than specializations (A string is a vector,but a stack is not). 
<pre>  class Stack: Vector&lt;int&gt; {  // or class Stack: private Vector&lt;int&gt;
  public:
    bool empty() const {return size()==0;}  // OK
  } s;
  s.size();   // Error, private
  s.empty();  // OK, public
</pre> 
<p>A class may have more than one base class (called <em>multipleinheritance</em>). If both bases are inturn derived from a third base, then we derive from this root class using<tt>virtual</tt> to avoid inheriting its members twice further on.Any indirectly derived class treats the virtual root as a direct baseclass in the constructor initialization list.</p> 
<pre>  class ios {...};                                      // good(), binary, ...
  class fstreambase: public virtual ios {...};          // open(), close(), ...
  class istream: public virtual ios {...};              // get(), operator&gt;&gt;(), ...
  class ifstream: public fstreambase, public istream {  // Only 1 copy of ios
    ifstream(): fstreambase(), istream(), ios() {...}   // Normally ios() would be omitted
  };
</pre> 
<a target="_blank" name="polymorphism"></a> 
<h4>Polymorphism</h4> Polymorphism is the technique of defining a common interface for ahierarchy of classes. To support this, a derived object is allowedwherever a base object is expected. For example, 
<pre>  String s="Hello";
  Vector&lt;char&gt; v=s;    // Discards derived part of s to convert
  Vector&lt;char&gt;* p=&amp;s;  // p points to base part of s
  try {throw s;} catch(Vector&lt;char&gt; x) {}  // Caught with x set to base part of s
  s=Vector&lt;char&gt;(5);   // Error, can't convert base to derived

  // Allow output of Vector&lt;char&gt; using normal notation
  ostream&amp; operator &lt;&lt; (ostream&amp; out, const Vector&lt;char&gt;&amp; v) {
    copy(v.begin(), v.end(), ostream_iterator&lt;char&gt;(out, ""));  // Print v to out
    return out;        // To allow (cout &lt;&lt; a) &lt;&lt; b;
  }
  cout &lt;&lt; s;           // OK, v refers to base part of s
  ofstream f("file.txt");
  f &lt;&lt; s;              // OK, ofstream is derived from ostream
</pre> 
<p>A derived class may redefine inherited member functions, overriding anyfunctionwith the same name, parameters, return type, and const-ness (and hidingother functions with the same name, thus the overriding function shouldnot be overloaded).The function call is resolved at compile time. This is incorrect in caseof a base pointer or reference to a derived object. To allow run timeresolution, the base member function should be declared <tt>virtual</tt>. Sincethe default destructor is not virtual, a virtual destructor shouldbe added to the base class. If empty, no copy constructor or assignmentoperator is required. Constructors and = are never virtual.</p> 
<pre>  class Shape {
  public:
    virtual void draw() const;
    virtual ~Shape() {}
  };
  class Circle: public Shape {
  public:
    void draw() const;      // Must use same parameters, return type, and const
  };

  Shape s; s.draw();        // Shape::draw()
  Circle c; c.draw();       // Circle::draw()
  Shape&amp; r=c; r.draw();     // Circle::draw() if virtual
  Shape* p=&amp;c; p-&gt;draw();   // Circle::draw() if virtual
  p=new Circle; p-&gt;draw();  // Circle::draw() if virtual
  delete p;                 // Circle::~Circle() if virtual
</pre> 
<p>An <em>abstract</em> base class defines an interface for one ormore derived classes, which are allowed to instantiate objects.Abstractness can be enforced by using protected (not private) constructorsor using <em>pure virtual</em> member functions, which must be overridden inthe derived class or else that class is abstract too. A pure virtualmember function is declared <tt>=0;</tt> and has no code defined.</p> 
<pre>  class Shape {
  protected:
    Shape();                 // Optional, but default would be public
  public:
    virtual void draw() const = 0; // Pure virtual, no definition
    virtual ~Shape() {}
  };
  // Circle as before

  Shape s;                   // Error, protected constructor, no Shape::draw()
  Circle c;                  // OK
  Shape&amp; r=c; r.draw();      // OK, Circle::draw()
  Shape* p=new Circle();     // OK
</pre> 
<a target="_blank" name="runtimetype"></a> 
<h5>Run time type identification</h5> C++ provides for run time type identification, although this usuallyindicates a poor design. 
<tt>dynamic_cast&lt;T&gt;</tt>(x) checks at run time whether a base pointeror reference is to a derived object, and if so, does a conversion.The base class must have at least one virtual function to use run timetype checking. 
<pre>  #include &lt;typeinfo&gt;    // For typeid()
  typeid(*p)==typeid(T)  // true if p points to a T
  dynamic_cast&lt;T*&gt;(p)    // Convert base pointer to derived T* or 0.
  dynamic_cast&lt;T&amp;&gt;(r)    // Convert base reference to derived T&amp; or throw bad_cast()
</pre> For example, 
<pre>  class B {public: virtual void f(){}};
  class D: public B {public: int x;} d;  // Bad design, public member in D but not B
  B* p=&amp;d; p-&gt;x;                         // Error, no B::x
  D* q=p; q-&gt;x;                          // Error, can't convert B* to D*
  q=(D*)p;  q-&gt;x;                        // OK, but reinterpret_cast, no run time check
  q=dynamic_cast&lt;D*&gt;(p); if (q) q-&gt;x;    // OK
</pre> 
<a target="_blank" name="othertypes"></a> 
<h4>Other Types</h4> 
<a target="_blank" name="typedef"><tt><strong>typedef</strong></tt> defines a synonym for a type.</a> 
<pre>  typedef char* Str;  // Str is a synonym for char*
  Str a, b[5], *c;    // char* a; char* b[5]; char** c;
  char* d=a;          // OK, really the same type
</pre> 
<a target="_blank" name="enum"></a> 
<p><tt><strong>enum</strong></tt> defines a type and a set of symbolicvalues for it. There is an implicit conversion to int and explicitconversion from int to enum. You can specify the int equivalents ofthe symbolic names, or they default to successive values beginningwith 0. Enums may be anonymous,specifying the set of symbols and possibly objects without giving thetype a name.</p> 
<pre>  enum Weekday {MON,TUE=1,WED,THU,FRI};  // Type declaration
  enum Weekday today=WED;                // Object declaration, has value 2
  today==2                               // true, implicit int(today)
  today=Weekday(3);                      // THU, conversion must be explicit
  enum {N=10};                           // Anonymous enum, only defines N
  int a[N];                              // OK, N is known at compile time
  enum {SAT,SUN} weekend=SAT;            // Object of anonymous type
</pre> 
<a target="_blank" name="struct"></a> 
<p>A <tt><strong>struct</strong></tt> is a class where the default protection ispublic instead of private. A <tt>struct</tt> can be initialized like anarray.</p> 
<pre>  struct Complex {double re, im;};     // Declare type
  Complex a, b={1,2}, *p=&amp;b;           // Declare objects
  a.re = p-&gt;im;                        // Access members
</pre> 
<a target="_blank" name="union"></a> 
<p>A <tt><strong>union</strong></tt> is a struct whose fields overlap in memory.Unions can also be anonymous. They may be used to implement variant records.</p> 
<pre>  union U {int i; double d;};  // sizeof(U) is larger of int or double
  U u; u.i=3;                  // overwrites u.d

  // A variant record
  class Token {
    enum {INT, DOUBLE} type;   // which field is in use?
    union {int i; double d;} value;  // An anonymous union
  public:
    void print() const {
      if (type==INT) cout &lt;&lt; value.i;
      else cout &lt;&lt; value.d;
    }
  };
</pre> 
<p>An enum, struct, class, or union type and a list of objects maybe declared together in a single statement.</p> 
<pre>  class Complex {public: double re, im;} a, b={1,2}, *p=&amp;b;
</pre> 
<a target="_blank" name="programorganization"></a> 
<h3>Program Organization</h3> 
<p>For C++ programs that only use one source code file and thestandard library, the only rule is to declare things before using them:type declarations before object declarations, and function declarationsor definitions before calling them. However, implicitly inlined memberfunctionsmay use members not yet declared, and templates may use names as longas they are declared before instantiation.</p> 
<pre>  class Complex {
    double real() const {return re;}  // OK
    double re, im;
  };
</pre> 
<p>Global and member functions (unless inlined or templated) and globalor class static objects are separately compilable units, and may appearin separate source code (.cpp) files. If they are defined and usedin different files, then a declaration is needed. To insure thatthe declaration and definition are consistent, the declaration shouldbe in a shared header file. A shared header conventionally has a<tt>.h</tt> extension, and is inserted with a<tt>#include "<em>filename</em>.h"</tt>, using double quotes to indicatethat the file is in the current directory. Global variables aredeclared with <tt>extern</tt> without initialization. </p> 
<pre>// prog.h         // prog1.cpp        // prog2.cpp
extern int x;     #include "prog.h"   #include "prog.h"
int f();          int x=0;            int f() {
                  int main() {          return x;
                    f();              }
                    return 0;
                  }
</pre> To compile, 
<pre>  <strong>g++ prog1.cpp prog2.cpp -o prog</strong>
</pre> This produces two object files ( 
<tt>prog1.o, prog2.o</tt>), and then linksthem to produce the executable 
<tt>prog</tt>. g++ also accepts 
<tt>.o</tt>files, which are linked only, saving time if the 
<tt>.cpp</tt>file was not changed. To compile without linking, use 
<tt>-c</tt>.To optimize (compile slower but run faster), use 
<tt>-O</tt>. 
<p>The UNIX <tt>make</tt> command updates the executable as needed basedon the timestamps of source and <tt>.o</tt> files. It requires a filenamed <tt>Makefile</tt> containing a set of dependencies of the form:</p> 
<pre>  <em>file: files which should be older than file</em>
  (tab) <em>commands to update file</em>
</pre> Dependencies may be in any order. The Makefile is executed repeatedlyuntil all dependencies are satisfied. 
<pre>  # Makefile comment
  prog: prog1.o prog2.o
        g++ prog1.o prog2.o -o prog

  prog1.o: prog1.cpp prog.h
        g++ -c prog1.cpp

  prog2.o: prog2.cpp prog.h
        g++ -c prog2.cpp
</pre> Compiler options for g++. Other compilers may vary. 
<pre>  g++ file1.cpp              Compile, produce executable a.out in UNIX
  g++ file1.cpp file2.o      Compile .cpp and link .o to executable a.out
  g++ -Wall                  Turn on all warnings
  g++ -c file1.cpp           Compile to file1.o, do not link
  g++ -o file1               Rename a.out to file1
  g++ -O                     Optimize executable for speed
  g++ -v                     Verbose mode
  g++ -DX=Y                  Equivalent to #define X Y
  g++ --help                 Show all g++ options
  gxx file1.cpp              Compile in Windows MS-DOS box (DJGPP) to A.EXE
</pre> 
<p><a target="_blank" name="programorganization">Anything which is not a separately compilable unit may appear ina header file, such as class definitions (but not function code unlessinlined), templated classes (including function code), templatedfunctions, and other <tt>#include</tt> statements.</a><a target="_blank" name="namespaces"></a></p> 
<h4><a target="_blank" name="namespaces">Creating Libraries (namespaces)</a></h4> 
<a target="_blank" name="namespaces">Libraries usually come in the form of a header and an object (<tt>.o</tt>)file. To use them, <tt>#include "header.h"</tt> and link the <tt>.o</tt>file using g++. If the <tt>.o</tt> was compiled in C rather than C++,then indicate this with <tt>extern "C" {}</tt> to turn off name mangling.C++ encodes or "mangles" overloaded function names to allow them to be linked,but C does not since it doesn't allow overloading.</a> 
<pre>  extern "C" {          // Turn off name mangling
  #include "header.h"   // Written in C
  }
</pre> When writing your own library, use a unique namespace name to preventconflicts with other libraries. A namespace may span multiplefiles. Types, objects, and functions declared in a namespace N mustbe prefixed with N:: when used outside the namespace, or there mustbe a 
<tt>using namespace N;</tt> in the current scope. 
<p>Also, to guard against possible multipleinclusions of the header file, <tt>#define</tt> some symbol and testfor it with #ifndef ... #endif on the first and last lines.Don't have a <tt>usingnamespace std;</tt>, since the user may not want <tt>std</tt> visible.</p> 
<pre>  #ifndef MYLIB_H       // mylib.h, or use #if !defined(MYLIB_H)
  #define MYLIB_H
  #include &lt;string&gt;
  // No using statement
  namespace mylib {
    class B {
    public:
      std::string f();  // No code
    }
  }
  #endif

  // mylib.cpp, becomes mylib.o
  #include &lt;string&gt;
  #include "mylib.h"
  using namespace std;  // OK
  namespace mylib {
    string B::f() {return "hi";}
  }
</pre> 
<tt>#define</tt> could be used to create constants through text substitution,but it is better to use 
<tt>const</tt> to allow type checking. 
<tt>#define X Y</tt> has the effect of replacing symbol X witharbitrary text Y before compiling, equivalent to the g++ option 
<tt>-DX=Y</tt>.Each compiler usually defines a different set of symbols, whichcan be tested with 
<tt>#if, #ifdef, #ifndef, #elsif, #else</tt>,and 
<tt>#endif</tt>. 
<pre>  #ifdef unix  // Defined by most UNIX compilers
  // ...
  #else
  // ...
  #endif
</pre> Preprocessor statements are one line (no semicolon). They performtext substitutions in the source code prior to compiling. 
<pre>  #include &lt;header&gt;          // Standard header
  #include "header.h"        // Include header file from current directory
  #define X Y                // Replace X with Y in source code
  #define f(a,b) a##b        // Replace f(1,2) with 12
  #define X \                // Continue a # statement on next line
  #ifdef X                   // True if X is #defined
  #ifndef X                  // False if X is #defined
  #if !defined(X)            // Same
  #else                      // Optional after #if...
  #endif                     // Required
</pre> 
<a target="_blank" name="history"></a> 
<h3>History of C++</h3> 
<p>C++ evolved from C, which in turn evolved from B, written by KenThompson in 1970 as a variant of BCPL. C was developed in the 1970'sby Brian Kernighan and Dennis Ritchie as a "portable assembly language"to develop UNIX. C became widely available when they published "TheC Programming Language" in 1983. C lacked standard containers (string,vector, map), iostreams, bool, const, references, classes, exceptions,namespaces, new/delete, function and operator overloading, andobject-oriented capabilities.I/O was done using <tt>&lt;stdio.h&gt;</tt>. Strings were implemented asfixed sized char[] arrays requiring functions to assign or compare them(strcpy(), strcmp()). Structs could not be assigned, and had to becopied using memcpy(). Function arguments were not type checked.Functions could only modify arguments by passing their addresses.Memory allocation was done using malloc(), which requires the number ofbytes to allocate and returns an untyped pointer or NULL if it fails.The language allowed unsafe implicit conversions such as int to pointers.Variables had to be declared before the first statement. There wasno <tt>inline</tt>, so macros were often used in place of small functions.Hardware was slow and optimizers were not very good, so it was commonto declare <tt>register</tt> variables. There were no // style comments.For instance,</p> 
<pre>  /* Copy argv[1] to buf and print it */
  #include &lt;stdio.h&gt;         /* No cout, use printf()                             */
  #include &lt;string.h&gt;        /* No string type, use char*                         */
  #include &lt;stdlib.h&gt;        /* No new/delete, use malloc/free                    */
  main(argc, argv)           /* Return type defaults to int */
  int argc;                  /* Old style parameter declaration, no type checking */
  char** argv;
  {                          /* No namespace std                                  */
    char* buf;               /* All declarations before the first statement       */
    if (argc&gt;1) {
      buf=(char*)malloc((strlen(argv[1])+1)*sizeof(char));  /* Cast optional      */
      strcpy(buf, argv[1]);  /* Can't assign, no range check                      */
      printf("%s\n", buf);   /* Arguments not type checked                        */
      free(buf);             /* No delete */
    }
  }                          /* Return value is undefined (unchecked)             */
</pre> 
<p>The ANSI C standard was finished in 1988. It added <tt>const</tt>,new style function declaration with type checking, <tt>struct</tt> assignment,strict type checking of pointer assignments,and specified the standard C library, which until now was widely usedbut with minor, annoying variations. However, many compilers did notbecome ANSI compliant until the early 1990's.</p> 
<p>In the 1980's Bjarne Stroustrup at AT&amp;T developed "C with Classes", later C++.Early implementations were available for UNIX as <tt>cfront</tt> (cc), aC++ to C translator around 1990.It added object oriented programming withclasses, inheritance, and polymorphism, also references, the iostreamlibrary, and minor enhancements such as // style comments and the abilityto declare variables anywhere. Because there were no namespaces,the iostream header was named &lt;iostream.h&gt; and no <tt>using</tt>statement was required. Unlike C programs which always have a .c extension,C++ didn't say, so .cpp, .cc and .C were all common, and .hpp for headers.</p> 
<p>GNU gcc and g++, which compiled C and C++directly to machine code, were developed in the early 1990's. Templateswere added in 1993. Exceptions were added in 1994.The standardcontainer library (originally called the standard template libraryor STL) was developed by researchers at Hewlett-Packard and madeavailable free asa separate download in the mid 1990's and ported to several compilers.</p> 
<p>ANSI standard C++ compilers became available in 1998. This addedSTL to the standard library, added multiple inheritance, namespaces,type bool, and run time type checking (dynamic_cast, typeid). The<tt>.h</tt> extension on headers was dropped.</p> 
<p>C++ most likely succeeded where other early object oriented languagesfailed (Simula67, Actor, Eiffel, SmallTalk) because it was backwardscompatible with C, allowing old code to be used, and because C programmerscould use it immediately without learning the new features. However, thereare a few incompatibilities.</p> 
<ul><li>Old style function declarations are not allowed.</li><li>Conversion from <tt>void*</tt> (returned by <tt>malloc()</tt>) requiresa cast.</li><li>There are many new reserved words.</li></ul> 
<p>There are also some incompatibilities between old (before 1998)and new versions of C++.</p> 
<ul><li><tt>new</tt> was changed to throw type <tt>bad_alloc</tt> if outof memory, instead of returning 0.</li><li>The scope of a variable declared in a <tt>for</tt> loop was changedto be local to the loop and not beyond it (not yet implemented byMicrosoft Visual C++)</li></ul> 
<p>g++ does not yet implement all ANSI C++ features. For instance,</p> 
<ul><li>Type <tt>ostringstream</tt> allowing formatted writing to strings.</li><li>Run time bounds checking of vector indexes using v.at(i)</li></ul> 
<p>The largest integer type is 32 bits in most implementations, butas 64 bit machines become common it is possible that type <tt>long</tt>could become a 64 bit type (as in Java) in the future.g++ supports the nonstandard 64-bit integer type <tt>long long</tt>, e.g.</p> 
<pre>  unsigned long long bigzero=0LLU;
</pre> 
<p><a target="_blank" name="history">Most implementations of <tt>time()</tt> return the number of seconds sinceJan. 1, 1970 as a <tt>time_t</tt>, normally a signed 32-bit <tt>long</tt>.Programs that use this implementation will fail on Jan. 19,2038 at 3:14:08 AM as this value overflows and becomes negative.</a><a target="_blank" name="furtherreading"></a></p> 
<h3><a target="_blank" name="furtherreading">Further Reading</a></h3> 
<a target="_blank" name="furtherreading"></a> 
<p>Brian W. Kernighan, <em>The C Programming Language</em>, 2nd Ed.,Prentice Hall, 1988.</p> 
<p>Bjarne Stroustrup, <em>The C++ Programming Language</em>, 3rd Ed,,Addison Wesley, 1997.</p> 
<p>Andrew Koenig, Barbara E. Moo, <em>Accelerated C++</em>,Addison Wesley, 2000.</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd2f8b1844bd34a510bc8af7d6af8056/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MATLAB2012a下载、安装及破解方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7fd2fdf9abd45087e82bff04009710a0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网易云课堂程序设计入门—Java语言（第二周）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>