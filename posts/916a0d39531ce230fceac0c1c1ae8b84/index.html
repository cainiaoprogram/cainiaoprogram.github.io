<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排名赛A题解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排名赛A题解" />
<meta property="og:description" content="排名赛A题解 1.复读机 hello world题 #include&lt;stdio.h&gt; int main() { int i=1; int n; scanf(&#34;%d&#34;,&amp;n); for(i=1;i&lt;=n;i&#43;&#43;) { printf(&#34;SDUFE\n&#34;); } return 0; } 2.换钱的交易 这题刚好压在int能表达的数据的边缘了，2^31,建议开long long input n output 100000*n Sn(a1=1,q=2) #include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int i=0; long long n; long long sn; scanf(&#34;%lld&#34;,&amp;n); if(n==0) { printf(&#34;0\n&#34;); printf(&#34;0&#34;); } else { sn=(1*(1-pow(2,n)))/(1-2); //pow()s是math.h里的幂函数，sn是等比数列求和公式 printf(&#34;%lld\n&#34;,n*100000); printf(&#34;%lld&#34;,sn); } return 0; } 3.回文序列判定 #include&lt;stdio.h&gt; #include&lt;string.h&gt; char str[10000000]; //题目没说多少数据范围就开到最大，放到静态存储区(main函数外面)防止炸掉栈(main函数里面)内存 int main() { gets(str); int len; int i=0; int flag=1; len=strlen(str); for(i=0;i&lt;(len-1)/2;i&#43;&#43;) //len-1是减去# { if(str[i]==str[len-2-i]) //i是从0开始的，所以len再减一，len奇数偶数都行 { //如 abccba#， flag=1; //数组下标0123456,len为7, 7-2=5 } else { flag=0; break; } } if(flag) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/916a0d39531ce230fceac0c1c1ae8b84/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-05T23:13:34+08:00" />
<meta property="article:modified_time" content="2022-12-05T23:13:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排名赛A题解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="A_0"></a>排名赛A题解</h3> 
<h4><a id="1_1"></a>1.复读机</h4> 
<pre><code>hello world题

#include&lt;stdio.h&gt;
int main()
{
	int i=1;
	int n;
	scanf("%d",&amp;n);
	for(i=1;i&lt;=n;i++)
	{
		printf("SDUFE\n");
	}
	return 0;
}

</code></pre> 
<h4><a id="2_19"></a>2.换钱的交易</h4> 
<pre><code>这题刚好压在int能表达的数据的边缘了，2^31,建议开long long

input
n

output
100000*n
Sn(a1=1,q=2)

#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int main()
{
	int i=0;
	long long n;
	long long sn;
	scanf("%lld",&amp;n);
	if(n==0)
	{
		printf("0\n");
		printf("0");
	}
	else
	{
		sn=(1*(1-pow(2,n)))/(1-2);      //pow()s是math.h里的幂函数，sn是等比数列求和公式
		printf("%lld\n",n*100000);
		printf("%lld",sn);
	}
	return 0;
}

</code></pre> 
<h4><a id="3_53"></a>3.回文序列判定</h4> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
char str[10000000];     //题目没说多少数据范围就开到最大，放到静态存储区(main函数外面)防止炸掉栈(main函数里面)内存
int main()
{
	gets(str);
	int len;
	int i=0;
	int flag=1;
	len=strlen(str);
	for(i=0;i&lt;(len-1)/2;i++)        //len-1是减去#
	{
		if(str[i]==str[len-2-i])       //i是从0开始的，所以len再减一，len奇数偶数都行                               
		{                               //如  abccba#，
			flag=1;                  //数组下标0123456,len为7, 7-2=5
		}                              
		else
		{
			flag=0;
			break;
		}
	}
	if(flag)
	{
		printf("%d",len-1);
	}
	else
	{
		printf("no");
	}
	return 0;
}

</code></pre> 
<h4><a id="4_89"></a>4.数列特征</h4> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
	int i=0;
	int n;
	int num;
	int sum=0;
	int max=-100000,min=100000;     //注意一下这里就可以了
	scanf("%d",&amp;n);
	for(i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;num);
		sum+=num;
		if(num&gt;max)
		max=num;
		if(num&lt;min)
		min=num;
	}
	printf("%d\n%d\n%d",max,min,sum);
	
	return 0;
}
</code></pre> 
<h4><a id="5_114"></a>5.杨辉三角</h4> 
<p>本体需要作图找规律，建议自己查CSDN</p> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
	int i=0,j=0;
	int n;
	scanf("%d",&amp;n);
	int k=n+1;
	int t=0,temp=1;             //t存arr上一行的前数字，temp存arr上一行的后数字，满足arr[i]=t+temp
	int arr[1000]={0,1,0};      //记录每一行的数据
	for(i=1;i&lt;=n+1;i++,k--)
	{
		for(j=1;j&lt;=2*(k-1);j++)     //打印前置空格，2*(k-1)，需要找规律
		{
			printf(" ");
		}
		t=0;
		for(j=1;j&lt;=i;j++)       //这里要做图解释，查csdn吧
		{
			temp=arr[j];
			arr[j]=temp+t;
			printf("%4d",arr[j]);
			t=temp;
		}
		printf("\n");
	}
	return 0;
}
</code></pre> 
<h4><a id="6_145"></a>6.学生成绩排序</h4> 
<p>会写成绩管理系统这个就会,不会写的建议赶紧学，不然大作业怎么写</p> 
<pre><code>#include&lt;stdio.h&gt;
struct score
{
	int fen;
	char name[30];
};
struct score achi[60];
int main()
{
	int i=0,j=0;
	int n;
	struct score temp;      //结构体临时变量
	scanf("%d",&amp;n);
	for(i=0;i&lt;n;i++)
	{
		scanf("%s",achi[i].name);
		scanf("%d",&amp;achi[i].fen);
	}
	for(i=0;i&lt;n-1;i++)              //冒泡排序,对结构体进行排序
	{
		for(j=0;j&lt;n-1-i;j++)
		{
			if(achi[j].fen&lt;achi[j+1].fen)
			{
				temp=achi[j];
				achi[j]=achi[j+1];
				achi[j+1]=temp;
			}
		}
	}
	for(i=0;i&lt;n;i++)
	{
		printf("%15s%5d\n",achi[i].name,achi[i].fen);
	}
	return 0;
}
</code></pre> 
<h4><a id="7_185"></a>7.字符串删除</h4> 
<p>本题题解必备知识<br> ctype.h中函数</p> 
<ol><li>tolower()<br> 把大写字母转换为小写字母</li><li>isalpha()<br> 判断是否是字母<br> string.h中函数<br> 二、strcat连接字符串 string catenate<br> 四、strlen获取字符串长度(不包含空字符) string length<br> 一、strcpy复制字符串 string copy</li></ol> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;ctype.h&gt;
char final[300]={'\0'};         //最终输出字符串
char* strfind(char* sour,char* tar);    //内置了大小写转换的查找子串函数
void strgetout(char* sour,char* tar);   //去除子串函数
int main()
{
	char tar[30];
	char sour[300];
	gets(tar);
	gets(sour);
	strgetout(sour,tar);
	printf("%s",final);
	return 0;
}
char* strfind(char* sour,char* tar)
{
	int flag=0;
	char* find=sour;                //原字符串的指针
	int i=0,j=0;
	char copy_find[300];             //原字符串的全小写形式指针
	strcpy(copy_find,sour);
	while(copy_find[i]!='\0')                   //大小写转换，全换成小写
	{
		if(isalpha(copy_find[i]))
		{
			copy_find[i]=tolower(copy_find[i]);
		}
		i++;
	}
	char* temp=copy_find;
	i=0;
	while(tar[i]!='\0')                 //大小写转换
	{
		if(isalpha(tar[i]))
		{
			tar[i]=tolower(tar[i]);
		}
		i++;
	}
	i=0;
	int len=strlen(tar);
	int cnt=0;
	while(copy_find[i]!='\0')           //对改变大小写后的字符串查找子串
	{
		if(copy_find[i]==tar[0])
		{
			for(j=0,cnt=0;j&lt;len;j++)
			{
				if(*(copy_find+i+j)==tar[j])
				cnt++;
			}
			if(cnt==len)
			{
				flag=1;
				break;
			}
		}
		find++;             //两个指针都要递增，保证了查找改变大小写后的字符串中的子串时，也能确定出中对应出原字符串位置
		temp++;
		i++;
	}
	if(flag)
	return find;
	else
	return NULL;            //空指针
}
void strgetout(char* sour,char* tar)
{
	int len=strlen(tar);
	int i=0;
	char copy_find[300];
	strcpy(copy_find,sour);
	char* find;
	char temp[300];
	find=strfind(copy_find,tar);
	while(find!=NULL)       //空指针就是找不到子串了
	{
		*find='\0';
		strcat(final,copy_find);
		strcpy(temp,find+len);
		strcpy(copy_find,temp);
		find=strfind(copy_find,tar);
	}
	strcat(final,copy_find);
}
</code></pre> 
<h4><a id="8GAME_285"></a>8.GAME</h4> 
<p>很明显这题我不会<br> 代码复杂性太大，超时了，TLE<br> 请各位问lkx大佬吧 &gt;_&lt;<br> 我的思路是贪心<br> 定义AB个数和BB个数总和为cnt<br> 对于每清除一次AB或者BB，计算清除AB剩下多少的cnt，计算清除BB剩下多少的cnt，选择cnt大的清除，如果cnt相同，则重复一次计算<br> 终止条件是，情况1.清除AB序列的cnt与清除BB序列的cnt相等，结束。<br> 情况2，清除AB序列的cnt为0，但清除BB的不为0，如果此时清除AB序列的字符串长度小于清除BB的，终止，否则继续清除。<br> 情况3，和情况2相反。</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int strcnt(char* str);
char* strfindab(char* str);
char* strfindbb(char* str);
int main()
{
	int ablen=0,bblen=0;
	int cnt=1;
	int abcnt1=0,bbcnt1=0;
	int abcnt=0,bbcnt=0;
	char temp[200010];
	char tempab[200010];
	char tempbb[200010];
	char str[200010];
	scanf("%s",str);
	while(cnt!=0)
	{
		strcpy(tempab,str);
		strfindab(tempab);
		abcnt=strcnt(tempab);

		strcpy(tempbb,str);
		strfindbb(tempbb);
		bbcnt=strcnt(tempbb);
		if(abcnt==0&amp;bbcnt==0)
		{
			break;
		}
		if(abcnt==0)
		{
			ablen=strlen(tempab);
			bblen=strlen(tempbb);
			if(ablen&lt;bblen)
			{
				strcpy(str,tempab);
				break;
			}
		}
		if(bbcnt==0)
		{
			ablen=strlen(tempab);
			bblen=strlen(tempbb);
			if(ablen&gt;bblen)
			{
				strcpy(str,tempbb);
				break;
			}
		}
		if(abcnt&gt;bbcnt)
		{
			strcpy(str,tempab);
			cnt=abcnt;
		}
		else if(abcnt&lt;bbcnt)
		{
			strcpy(str,tempbb);
			cnt=bbcnt;
		}
		else
		{
			strcpy(temp,tempab);
			strfindab(temp);
			abcnt1=strcnt(temp);
			
			strcpy(temp,tempbb);
			strfindbb(temp);
			bbcnt1=strcnt(temp);
				if(abcnt1&gt;bbcnt1)
				{
					strcpy(str,tempab);
					cnt=abcnt;
				}
				else
				{
					strcpy(str,tempbb);
					cnt=bbcnt;
				}
		}
	}
	printf("%d",strlen(str));
	
	
	return 0;
}
int strcnt(char* str)
{
	int cnt;
	int cnt1=0;
	int cnt2=0;
	int i=0;
	while(str[i]!='\0')
	{
		if(str[i]=='A'&amp;&amp;str[i+1]=='B')
		{
			cnt1++;
		}
		if(str[i]=='B'&amp;&amp;str[i+1]=='B')
		{
			cnt2++;
		}
		i++;
	}
	cnt=cnt1+cnt2;
	return cnt;
}
char* strfindab(char* str)
{
	char* find=strstr(str,"AB");
	
	int i=0,j=0;
	char strnew[200010];
	while(str[i]!='\0')
	{
		if((str+i)==find)
		{
			i=i+2;
		}
		strnew[j]=str[i];
		i++;
		j++;
	}
	strnew[j]='\0';
	strcpy(str,strnew);
	return str;
}
char* strfindbb(char* str)
{
	char* find=strstr(str,"BB");
	int i=0,j=0;
	char strnew[200010];
	while(str[i]!='\0')
	{
		if((str+i)==find)
		{
			i=i+2;
		}
		strnew[j]=str[i];
		i++;
		j++;
	}
	strnew[j]='\0';
	strcpy(str,strnew);
	return str;
}


</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/234f2aa1bf0e43e31673a568b85a70a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">二维数组与字符串与结构体</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5892cdb627583cab2ac7c74b5e384c60/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">本地开发正常,打war包部署到Tomcat运行的时候提交中文内容乱码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>