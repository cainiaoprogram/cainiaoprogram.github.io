<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;输入文件流ifstream用法详解[转载] - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;输入文件流ifstream用法详解[转载]" />
<meta property="og:description" content="ios_base &lt;- ios &lt;- istream &lt;- ifstream &lt;- fstream &lt;- ostream &lt;- ofstream &lt;- fstream C&#43;&#43; 使用标准库类来处理面向流的输入和输出：
iostream 控制台读写
fstream 文件读写
stringstream 内存string 的读写
每个IO 对象都维护一组条件状态 flags (eofbit, failbit and badbit)，用来指出此对象上是否可以进行 IO 操作。如果遇到错误—例如输入流遇到了文件末尾，则对象的状态变为是失效，所有的后续输入操作都不能执行，直到错误纠正。
1 #include &lt;fstream&gt; 2 ofstream //文件写操作 3 ifstream //文件读操作 4 fstream //文件读写操作 成员函数
Public member functions
1， 构造函数
第一种不绑定文件，后续用open() 绑定。 即：ifstream in;
第二种绑定文件 filename ，读取模式默认参数为 ios::in可以省略。
//第1种 ifstream in; in.open(&#34;H:\\ProductCode\\FileText\\clientc.txt&#34;,ios::in); //第2种 ifstream in(&#34;H:\\ProductCode\\FileText\\clientc.txt&#34;，ios::in); //函数原型： explicit ifstream (const char* filename, ios_base::openmode mode = ios_base::in); explicit ifstream (const string&amp; filename, ios_base::openmode mode = ios_base::in); 2，ifstream::open" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b7745cbbbf07d78f47fd568c6a326a1d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-06T09:59:31+08:00" />
<meta property="article:modified_time" content="2019-10-06T09:59:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;输入文件流ifstream用法详解[转载]</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <pre><code>ios_base &lt;- ios &lt;- istream &lt;- ifstream &lt;- fstream
                &lt;- ostream &lt;- ofstream &lt;- fstream
</code></pre> 
<p><img src="https://images2.imgbox.com/5d/4b/qWLR3k9O_o.png" alt="在这里插入图片描述"></p> 
<p>C++ 使用标准库类来处理面向流的输入和输出：</p> 
<p>iostream 控制台读写<br> fstream 文件读写<br> stringstream 内存string 的读写</p> 
<p>每个IO 对象都维护一组条件状态 flags (eofbit, failbit and badbit)，用来指出此对象上是否可以进行 IO 操作。如果遇到错误—例如输入流遇到了文件末尾，则对象的状态变为是失效，所有的后续输入操作都不能执行，直到错误纠正。</p> 
<pre><code class="prism language-c"><span class="token number">1</span> #include <span class="token operator">&lt;</span>fstream<span class="token operator">&gt;</span>  
<span class="token number">2</span> ofstream         <span class="token comment">//文件写操作</span>
<span class="token number">3</span> ifstream         <span class="token comment">//文件读操作</span>
<span class="token number">4</span> fstream          <span class="token comment">//文件读写操作</span>
</code></pre> 
<p>成员函数</p> 
<p>Public member functions</p> 
<p>1， 构造函数<br> 第一种不绑定文件，后续用open() 绑定。 即：ifstream in;<br> 第二种绑定文件 filename ，读取模式默认参数为 ios::in可以省略。</p> 
<pre><code class="prism language-c"><span class="token comment">//第1种</span>
ifstream in<span class="token punctuation">;</span>
in<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"H:\\ProductCode\\FileText\\clientc.txt"</span><span class="token punctuation">,</span>ios<span class="token punctuation">:</span><span class="token punctuation">:</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//第2种</span>
ifstream <span class="token function">in</span><span class="token punctuation">(</span><span class="token string">"H:\\ProductCode\\FileText\\clientc.txt"</span>，ios<span class="token punctuation">:</span><span class="token punctuation">:</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//函数原型：</span>
explicit ifstream <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> ios_base<span class="token punctuation">:</span><span class="token punctuation">:</span>openmode mode <span class="token operator">=</span> ios_base<span class="token punctuation">:</span><span class="token punctuation">:</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>

explicit ifstream <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> filename<span class="token punctuation">,</span> ios_base<span class="token punctuation">:</span><span class="token punctuation">:</span>openmode mode <span class="token operator">=</span> ios_base<span class="token punctuation">:</span><span class="token punctuation">:</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>2，ifstream::open<br> 打开文件filename，模式默认 ios_base::in</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> open <span class="token punctuation">(</span><span class="token keyword">const</span>   <span class="token keyword">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span>  ios_base<span class="token punctuation">:</span><span class="token punctuation">:</span>openmode mode <span class="token operator">=</span> ios_base<span class="token punctuation">:</span><span class="token punctuation">:</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> open <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> filename<span class="token punctuation">,</span>  ios_base<span class="token punctuation">:</span><span class="token punctuation">:</span>openmode mode <span class="token operator">=</span> ios_base<span class="token punctuation">:</span><span class="token punctuation">:</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>函数参数：</p> 
<p>filename 要打开文件的文件名<br> mode 打开文件的方式<br> prot 打开文件的属性</p> 
<table><thead><tr><th>member constant</th><th>stands for</th><th>access</th></tr></thead><tbody><tr><td>in</td><td>input File</td><td>读的方式打开文件</td></tr><tr><td>out</td><td>output</td><td>写的方式打开文件</td></tr><tr><td>binary</td><td>binary</td><td>二进制方式打开</td></tr><tr><td>ate</td><td>at end</td><td>打开的时候定位到文件末尾</td></tr><tr><td>app</td><td>append</td><td>所有操作都定位到文件末尾</td></tr><tr><td>trunc</td><td>truncate</td><td>丢弃打开前文件存在的内容</td></tr></tbody></table> 
<p>表：文件打开模式标记</p> 
<table><thead><tr><th>模式标记</th><th>适用对象</th><th>作用</th></tr></thead><tbody><tr><td>ios::in</td><td>ifstream fstream</td><td>打开文件用于读取数据。如果文件不存在，则打开出错。</td></tr><tr><td>ios::out</td><td>ofstream fstream</td><td>打开文件用于写入数据。如果文件不存在，则新建该文件；如 果文件原来就存在，则打开时清除原来的内容。</td></tr><tr><td>ios::app</td><td>ofstream fstream</td><td>打开文件，用于在其尾部添加数据。如果文件不存在，则新建该文件。</td></tr><tr><td>ios::ate</td><td>ifstream</td><td>打开一个已有的文件，并将文件读指针指向文件末尾（读写指 的概念后面解释）。如果文件不存在，则打开出错。</td></tr><tr><td>ios:: trunc</td><td>ofstream</td><td>单独使用时与 ios:: out 相同。</td></tr><tr><td>ios::binary</td><td>ifstream ofstream fstream</td><td>以二进制方式打开文件。若不指定此模式，则以文本模式打开。</td></tr><tr><td>ios::in ios::out</td><td>fstream</td><td>打开已存在的文件，既可读取其内容，也可向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错。</td></tr><tr><td>ios::in ios::out</td><td>ofstream</td><td>打开已存在的文件，可以向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错。</td></tr><tr><td>ios::in ios::out ios::trunc</td><td>fstream</td><td>打开文件，既可读取其内容，也可向其写入数据。如果文件本来就存在，则打开时清除原来的内容；如果文件不存在，则新建该文件。</td></tr></tbody></table> 
<p>ios::binary 可以和其他模式标记组合使用，例如：<br> ios::in | ios::binary表示用二进制模式，以读取的方式打开文件。<br> ios::out | ios::binary表示用二进制模式，以写入的方式打开文件。</p> 
<p>打开文件的属性同样在ios类中也有定义：</p> 
<table><thead><tr><th>0</th><th>普通文件打开操作</th></tr></thead><tbody><tr><td>1</td><td>只读文件</td></tr><tr><td>2</td><td>隐含文件</td></tr><tr><td>4</td><td>系统文件</td></tr></tbody></table> 
<p>对于文件的属性也可以使用“或”运算和“+”进行组合使用，这里就不做说明了。</p> 
<p>很多程序中，可能会碰到ofstream out(“Hello.txt”), ifstream in("…"),fstream foi("…")这样的的使用，并没有显式的去调用open（）函数就进行文件的操作，直接调用了其默认的打开方式，因为在stream类的构造函数中调用了open()函数,并拥有同样的构造函数，所以在这里可以直接使用流对象进行文件的操作，默认方式如下：</p> 
<pre><code class="prism language-c">ofstream <span class="token function">out</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>  
ifstream <span class="token function">in</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>  
fstream <span class="token function">foi</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>in<span class="token operator">|</span>ios<span class="token punctuation">:</span><span class="token punctuation">:</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre> 
<p>当使用默认方式进行对文件的操作时，你可以使用成员函数is_open()对文件是否打开进行验证</p> 
<p>3，ifstream:: is_open</p> 
<pre><code class="prism language-c">bool <span class="token function">is_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
</code></pre> 
<p>文件流对象与文件绑定，返回 true ,否则 false 。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//关闭文件流</span>
</code></pre> 
<p>5，ifstream:: rdbuf</p> 
<pre><code class="prism language-c">filebuf<span class="token operator">*</span> <span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    
</code></pre> 
<p>返回一个 filebuf 对象指针，（The pointer to the internal filebuf object.）</p> 
<p>6，ifstream:: operator =</p> 
<pre><code class="prism language-c"><span class="token function">copy</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  ifstream<span class="token operator">&amp;</span> operator<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> ifstream<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>
<span class="token function">move</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  ifstream<span class="token operator">&amp;</span> operator<span class="token operator">=</span> <span class="token punctuation">(</span>ifstream<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>等号运算符禁止使用左值引用，可以使用右值引用。(即右边的值必须是一个即将销毁的临时对象)</p> 
<p>Public member functions inherited from istream</p> 
<p>7，std::istream::operator&gt;&gt;</p> 
<p>输入终端 cin 和 ifstream 都是 istream 的子类，所以输入操作符 &gt;&gt; 用法相同。对变量进入输入的时候重载了常用的数据类型。</p> 
<pre><code class="prism language-c">arithmetic types <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>bool<span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>

stream buffers <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>streambuf<span class="token operator">*</span> sb <span class="token punctuation">)</span><span class="token punctuation">;</span>

manipulators <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>istream<span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span>istream<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>ios<span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span>ios<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> operator<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>ios_base<span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span>ios_base<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>8，istream::gcount</p> 
<pre><code class="prism language-c">streamsize <span class="token function">gcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
</code></pre> 
<p>返回最后一个输入操作读取的字符数目。<br> 可以修改这个返回值的函数有：get,getline,ignore,peek,read, readsome,putback and unget. 其中函数peek, putback and unget 被调用后gcount()返回值为0。</p> 
<p>9，istream::get</p> 
<pre><code class="prism language-c">single character <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">//读取一个字符，遇到'\n',也从流中取出。</span>
<span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符按 int 返回</span>
istream<span class="token operator">&amp;</span> get <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">&amp;</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读到c中</span>

<span class="token comment">//读取n个 c 风格字符串到数组s中，遇到'\n'（或delim）停止读取，并把'\n'留在输入流中，若要读取多行，就要需要int get() 来取出'\n',才能读下一行。</span>
c<span class="token operator">-</span>string <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span> 
istream<span class="token operator">&amp;</span> get <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> streamsize n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//默认delim是换行字符'\n'</span>
istream<span class="token operator">&amp;</span> get <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> streamsize n<span class="token punctuation">,</span> <span class="token keyword">char</span> delim<span class="token punctuation">)</span> <span class="token comment">//指定读取停止字符 delim</span>

stream buffer <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">//内容读取到 streambuf 对象中。</span>
istream<span class="token operator">&amp;</span> get <span class="token punctuation">(</span>streambuf<span class="token operator">&amp;</span> sb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//默认delim是换行字符'\n'</span>
istream<span class="token operator">&amp;</span> get <span class="token punctuation">(</span>streambuf<span class="token operator">&amp;</span> sb<span class="token punctuation">,</span> <span class="token keyword">char</span> delim<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//指定读取停止字符 delim</span>
</code></pre> 
<p>下面的程序演示get()读取到streambuf 的用法。</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span>     </span><span class="token comment">// std::cout, std::streambuf, std::streamsize</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span>      </span><span class="token comment">// std::ifstream</span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">int</span> main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>ifstream ifs <span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>ofstream ofs <span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>streambuf <span class="token operator">*</span>pbuf <span class="token operator">=</span> ofs<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    ifs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">*</span>pbuf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//默认读取截止字符是'\n', 所以读取一行停止，且没有读取'\n'。</span>
    pbuf<span class="token operator">-&gt;</span><span class="token function">sputc</span><span class="token punctuation">(</span>ifs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '\n'并没有被读取到pbuf，所以需要get()来读取'\n',然后用函数sputc()加到 pbuf 中。</span>
    ifs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">*</span>pbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从流中取出了'\n' ，才能读取第二行</span>
    pbuf<span class="token operator">-&gt;</span><span class="token function">sputc</span><span class="token punctuation">(</span>ifs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*
    上面使用了函数 istream&amp; get (streambuf&amp; sb); 
    之后不能使用 istream&amp; get (char* s, streamsize n);
    */</span>
    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       
    ifs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//虽然输入流有第三行，但是没法读取。</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"get:"</span><span class="token operator">&lt;&lt;</span>s<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token comment">//内容为空</span>

    ofs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ifs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>读取一行到字符数组。</p> 
<pre><code class="prism language-c">istream<span class="token operator">&amp;</span> getline <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> streamsize n <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//默认delim是换行字符'\n'，遇到后丢弃，第二次读取从delim后开始读。</span>

istream<span class="token operator">&amp;</span> getline <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> streamsize n<span class="token punctuation">,</span> <span class="token keyword">char</span> delim <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//自己定义停止符delim</span>
</code></pre> 
<p> 字符串头文件也定义了从流中读取一行的函数 getline()<br> 因为它不是流的成员函数，所以不能通过点访问。</p> 
<p>std::getline (string)</p> 
<pre><code class="prism language-c"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 用户定义截止字符
istream<span class="token operator">&amp;</span> getline <span class="token punctuation">(</span>istream<span class="token operator">&amp;</span>  is<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> <span class="token keyword">char</span> delim<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> getline <span class="token punctuation">(</span>istream<span class="token operator">&amp;&amp;</span> is<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> <span class="token keyword">char</span> delim<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//c++11 标准</span>

<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> 截止字符默认<span class="token string">'\n'</span>
istream<span class="token operator">&amp;</span> getline <span class="token punctuation">(</span>istream<span class="token operator">&amp;</span>  is<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream<span class="token operator">&amp;</span> getline <span class="token punctuation">(</span>istream<span class="token operator">&amp;&amp;</span> is<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c++11 标准</span>

</code></pre> 
<p>用法：<br> 从流对象is中读取一行存到字符串str 直到遇到截止字符，如果遇到截止字符，则把它从流中取出来，然后丢弃（它不被存储，下一个操作的起点在它之后）函数调用前str 中的内容将被覆盖。<br> demo: 读取文件流的内容</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;fstream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    string str<span class="token punctuation">;</span>
    ifstream <span class="token function">ifs</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ifs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"open file fail!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token function">getline</span><span class="token punctuation">(</span>ifs<span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span>str<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>11，istream::ignore</p> 
<pre><code class="prism language-c">istream<span class="token operator">&amp;</span> ignore <span class="token punctuation">(</span>streamsize n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> delim <span class="token operator">=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>从输入流中读取n个字符并且丢弃，或者读到delim字符再停止读取。</p> 
<p>12，istream::peek</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>返回输入流下一个字符，并把它留在输入流中，作为下一次读取的起点。返回值是整形ascll码值，可以用 char© 转化为字符。</p> 
<p>13，istream::read</p> 
<pre><code class="prism language-c">istream<span class="token operator">&amp;</span> read <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> streamsize n<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>从输入流中提取n个字符，并把他们存数组s中，不检测内容，也不加字符串结尾符号‘\0’,实例：</p> 
<pre><code class="prism language-c"><span class="token comment">// read a file into memory</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span>     </span><span class="token comment">// std::cout</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span>      </span><span class="token comment">// std::ifstream</span>
<span class="token keyword">int</span> main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>ifstream is <span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ifstream<span class="token punctuation">:</span><span class="token punctuation">:</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// get length of file:</span>
    is<span class="token punctuation">.</span>seekg <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> is<span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> is<span class="token punctuation">.</span><span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    is<span class="token punctuation">.</span>seekg <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> is<span class="token punctuation">.</span>beg<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">char</span> <span class="token operator">*</span> buffer <span class="token operator">=</span> new <span class="token keyword">char</span> <span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>

    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Reading "</span> <span class="token operator">&lt;&lt;</span> length <span class="token operator">&lt;&lt;</span> <span class="token string">" characters... "</span><span class="token punctuation">;</span>
    <span class="token comment">// read data as a block:</span>
    is<span class="token punctuation">.</span>read <span class="token punctuation">(</span>buffer<span class="token punctuation">,</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">)</span>
      std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"all characters read successfully."</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
      std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"error: only "</span> <span class="token operator">&lt;&lt;</span> is<span class="token punctuation">.</span><span class="token function">gcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" could be read"</span><span class="token punctuation">;</span>
    is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ...buffer contains the entire file...</span>

    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> buffer<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>14，istream::putback</p> 
<pre><code class="prism language-c">istream<span class="token operator">&amp;</span> putback <span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 用法，从输入流读取一个字符，再把它返回。</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
std<span class="token punctuation">:</span><span class="token punctuation">:</span>cin<span class="token punctuation">.</span>putback <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>15，istream::unget</p> 
<pre><code class="prism language-c">istream<span class="token operator">&amp;</span> <span class="token function">unget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回最后一次读取的字符到输入流，类似putback()</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>cin<span class="token punctuation">.</span><span class="token function">unget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>16，istream::tellg</p> 
<p>读取输入流中文件指针的位置，返回值可转化为 int。</p> 
<pre><code class="prism language-c">streampos <span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// get length of file:</span>
is<span class="token punctuation">.</span>seekg <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> is<span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> length <span class="token operator">=</span> is<span class="token punctuation">.</span><span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
is<span class="token punctuation">.</span>seekg <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> is<span class="token punctuation">.</span>beg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>17，istream::seekg</p> 
<p>设定输入流中文件指针的位置。(1) 绝对位置 (2) 相对位置</p> 
<pre><code class="prism language-c"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>istream<span class="token operator">&amp;</span> seekg <span class="token punctuation">(</span>streampos pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>istream<span class="token operator">&amp;</span> seekg <span class="token punctuation">(</span>streamoff off<span class="token punctuation">,</span> ios_base<span class="token punctuation">:</span><span class="token punctuation">:</span>seekdir way<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>参数 pos 是流中的绝对位置可以转化为 int<br> 参数 off 是偏移量，与way相关，类型是 int<br> 参数 way 可以选下表中的任意一个常量。</p> 
<table><thead><tr><th>value</th><th>offset is relative to…</th></tr></thead><tbody><tr><td>ios_base::beg</td><td>beginning of the stream</td></tr><tr><td>ios_base::cur</td><td>current position in the stream</td></tr><tr><td>ios_base::end</td><td>end of the stream</td></tr></tbody></table> 
<p>————————————————</p> 
<p>18，ios::good</p> 
<pre><code class="prism language-c">bool <span class="token function">good</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
bool <span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
bool <span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
bool <span class="token function">bad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
</code></pre> 
<p>检测流的状态是否正常。当错误的状态flags (eofbit, failbit and badbit) 都没被设置的时候返回true<br> 特定的错误状态可以用下面的函数（eof, fail, and bad）来检测。</p> 
<table><thead><tr><th>iostate value (member constant)</th><th>indicates</th><th>good()</th><th>eof()</th><th>fail()</th><th>bad()</th><th>rdstate()</th></tr></thead><tbody><tr><td>goodbit</td><td>No errors (zero value iostate)</td><td>true</td><td>false</td><td>false</td><td>false</td><td>goodbit</td></tr><tr><td>eofbit</td><td>End-of-File reached on input operation</td><td>false</td><td>true</td><td>false</td><td>false</td><td>eofbit</td></tr><tr><td>failbit</td><td>Logical error on i/o operation</td><td>false</td><td>false</td><td>true</td><td>false</td><td>failbit</td></tr><tr><td>badbit</td><td>Read/writing error on i/o operation</td><td>false</td><td>false</td><td>true</td><td>true</td><td>badbit</td></tr></tbody></table> 
<p>19，ios::operator!</p> 
<pre><code class="prism language-c">bool operator<span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token comment">//Returns true if either failbit or badbit is set, and false otherwise.</span>
<span class="token comment">// 有错误状态返回 true</span>

<span class="token keyword">int</span> main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>ifstream is<span class="token punctuation">;</span>
  is<span class="token punctuation">.</span>open <span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is<span class="token punctuation">)</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Error opening 'test.txt'\n"</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>20，ios::operator bool</p> 
<p>布尔运算： 当流对象单独出现在条件语句中时，就间接调用布尔运算。<br> 如：if(ios), while(ios)<br> 函数原型：<br> c++98: operator void*() const;<br> c++11: explicit operator bool() const;<br> 返回值：failbit 或 badbit 都没被标记的时候返回真。<br> （对比good(): failbit 或 badbit 或 eofbit 都没被标记的时候返回真）<br> 布尔运算一个很方便的用法就是检测文件结束。读到文件末尾的时候， eofbit, failbit 同时被设置为1，所以可以使用bool()来判断流的状态。<br> 当文件打开失败的时候failbit 位被设置为1，所以也能检测打开是否成功。</p> 
<pre><code class="prism language-c"><span class="token comment">//按行读文件，简洁的模板</span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;fstream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">void</span> print_state <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ios<span class="token operator">&amp;</span> stream<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"good()="</span> <span class="token operator">&lt;&lt;</span> stream<span class="token punctuation">.</span><span class="token function">good</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">" eof()="</span> <span class="token operator">&lt;&lt;</span> stream<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">" fail()="</span> <span class="token operator">&lt;&lt;</span> stream<span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">" bad()="</span> <span class="token operator">&lt;&lt;</span> stream<span class="token punctuation">.</span><span class="token function">bad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    string str<span class="token punctuation">;</span>
    ifstream <span class="token function">ifs</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ifs<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//while( bool(getline(ifs,str)))// 等价</span>
        <span class="token comment">//while( getline(ifs,str).good())//等价</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token function">getline</span><span class="token punctuation">(</span>ifs<span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            cout<span class="token operator">&lt;&lt;</span><span class="token string">"line:"</span><span class="token operator">&lt;&lt;</span>str<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"open file fail!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">print_state</span><span class="token punctuation">(</span>ifs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>21，ios::rdstate</p> 
<pre><code class="prism language-c">iostate <span class="token function">rdstate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token comment">// Returns the current internal error state flags of the stream.</span>
<span class="token comment">// 返回当前流中的内部错误状态，iostate二进制数，需要做位运算来获取其相应位置上的值。</span>
<span class="token comment">//这个函数的功能可以被 good()，eof()，fail()，bad() 替换。</span>
<span class="token keyword">int</span> main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>ifstream is<span class="token punctuation">;</span>
  is<span class="token punctuation">.</span>open <span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">rdstate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ifstream<span class="token punctuation">:</span><span class="token punctuation">:</span>failbit <span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Error opening 'test.txt'\n"</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>状态标志符的验证(Verification of state flags)</strong></p> 
<p>除了eof()以外，还有一些验证流的状态的成员函数（所有都返回bool型返回值）：</p> 
<p>bad()<br> 如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。</p> 
<p>fail()<br> 除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。</p> 
<p>eof()<br> 如果读文件到达文件末尾，返回true。</p> 
<p>good()<br> 这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。</p> 
<p>要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。</p> 
<p>获得和设置流指针(get and put stream pointers)</p> 
<p>所有输入/输出流对象(i/o streams objects)都有至少一个流指针：</p> 
<p>ifstream， 类似istream, 有一个被称为get pointer的指针，指向下一个将被读取的元素。<br> ofstream, 类似 ostream, 有一个指针 put pointer ，指向写入下一个元素的位置。<br> fstream, 类似 iostream, 同时继承了get 和 put</p> 
<p><strong>我们可以通过使用以下成员函数来读出或配置这些指向流中读写位置的流指针：</strong></p> 
<p>tellg() 和 tellp()<br> 这两个成员函数不用传入参数，返回pos_type 类型的值(根据ANSI-C++ 标准) ，就是一个整数，代表当前get 流指针的位置 (用tellg) 或 put 流指针的位置(用tellp).</p> 
<p>seekg() 和seekp()<br> 这对函数分别用来改变流指针get 和put的位置。两个函数都被重载为两种不同的原型：</p> 
<p>seekg ( pos_type position ); seekp ( pos_type position );<br> 使用这个原型，流指针被改变为指向从文件开始计算的一个绝对位置。要求传入的参数类型与函数 tellg 和tellp 的返回值类型相同。</p> 
<p>seekg ( off_type offset, seekdir direction ); seekp ( off_type offset, seekdir direction );<br> 使用这个原型可以指定由参数direction决定的一个具体的指针开始计算的一个位移(offset)。它可以是：</p> 
<table><thead><tr><th>ios::beg</th><th>从流开始位置计算的位移</th></tr></thead><tbody><tr><td>ios::cur</td><td>从流指针当前位置开始计算的位移</td></tr><tr><td>ios::end</td><td>从流末尾处开始计算的位移</td></tr></tbody></table> 
<p>流指针 get 和 put 的值对文本文件(text file)和二进制文件(binary file)的计算方法都是不同的，因为文本模式的文件中某些特殊字符可能被修改。由于这个原因，建议对以文本文件模式打开的文件总是使用seekg 和 seekp的第一种原型，而且不要对tellg 或 tellp 的返回值进行修改。对二进制文件，你可以任意使用这些函数，应该不会有任何意外的行为产生。</p> 
<p>以下例子使用这些函数来获得一个二进制文件的大小：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// obtaining file size  </span>
   <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream.h&gt;</span>  </span>
   <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fstream.h&gt;</span>  </span>
     
   <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> filename <span class="token operator">=</span> <span class="token string">"test.txt"</span><span class="token punctuation">;</span>  
     
   <span class="token keyword">int</span> main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
       <span class="token keyword">long</span> l<span class="token punctuation">,</span>m<span class="token punctuation">;</span>  
       ifstream <span class="token function">in</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> ios<span class="token operator">::</span>in<span class="token operator">|</span>ios<span class="token operator">::</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>  
       l <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
       in<span class="token punctuation">.</span>seekg <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ios<span class="token operator">::</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>  
       m <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
       in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
       cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size of "</span> <span class="token operator">&lt;&lt;</span> filename<span class="token punctuation">;</span>  
       cout <span class="token operator">&lt;&lt;</span> <span class="token string">" is "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" bytes.\n"</span><span class="token punctuation">;</span>  
       <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
   <span class="token punctuation">}</span>  
    
  <span class="token comment">//结果:  </span>
  size of example<span class="token punctuation">.</span>txt is <span class="token number">40</span> bytes<span class="token punctuation">.</span>
</code></pre> 
<p><strong>4.二进制文件</strong></p> 
<p>在二进制文件中，使用&lt;&lt; 和&gt;&gt;，以及函数（如getline）来操作符输入和输出数据，没有什么实际意义，虽然它们是符合语法的。</p> 
<p>文件流包括两个为顺序读写数据特殊设计的成员函数：write 和 read。第一个函数 (write) 是ostream 的一个成员函数，都是被ofstream所继承。而read 是istream 的一个成员函数，被ifstream 所继承。类 fstream 的对象同时拥有这两个函数。它们的原型是：</p> 
<p>write ( char * buffer, streamsize size ); read ( char * buffer, streamsize size );<br> 这里 buffer 是一块内存的地址，用来存储或读出数据。参数size 是一个整数值，表示要从缓存（buffer）中读出或写入的字符数。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// reading binary file  </span>
    <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span>  </span>
    <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fstream.h&gt;</span>  </span>
     
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> filename <span class="token operator">=</span> <span class="token string">"test.txt"</span><span class="token punctuation">;</span>  
      
    <span class="token keyword">int</span> main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">char</span> <span class="token operator">*</span> buffer<span class="token punctuation">;</span>  
        <span class="token keyword">long</span> size<span class="token punctuation">;</span>  
        ifstream in <span class="token punctuation">(</span>filename<span class="token punctuation">,</span> ios<span class="token operator">::</span>in<span class="token operator">|</span>ios<span class="token operator">::</span>binary<span class="token operator">|</span>ios<span class="token operator">::</span>ate<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        size <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        in<span class="token punctuation">.</span>seekg <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ios<span class="token operator">::</span>beg<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span> <span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        in<span class="token punctuation">.</span>read <span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
          
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the complete file is in a buffer"</span><span class="token punctuation">;</span>  
          
        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer<span class="token punctuation">;</span>  
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token comment">//运行结果：  </span>
    The complete file is in a buffer
</code></pre> 
<p><strong>5.缓存和同步(Buffers and Synchronization)</strong></p> 
<p>当我们对文件流进行操作的时候，它们与一个streambuf 类型的缓存(buffer)联系在一起。这个缓存（buffer）实际是一块内存空间，作为流(stream)和物理文件的媒介。例如，对于一个输出流， 每次成员函数put (写一个单个字符)被调用，这个字符不是直接被写入该输出流所对应的物理文件中的，而是首先被插入到该流的缓存（buffer）中。</p> 
<p>当缓存被排放出来(flush)时，它里面的所有数据或者被写入物理媒质中（如果是一个输出流的话），或者简单的被抹掉(如果是一个输入流的话)。这个过程称为同步(synchronization)，它会在以下任一情况下发生：</p> 
<p>当文件被关闭时: 在文件被关闭之前，所有还没有被完全写出或读取的缓存都将被同步。<br> 当缓存buffer 满时:缓存Buffers 有一定的空间限制。当缓存满时，它会被自动同步。<br> 控制符明确指明:当遇到流中某些特定的控制符时，同步会发生。这些控制符包括：flush 和endl。<br> 明确调用函数sync(): 调用成员函数sync() (无参数)可以引发立即同步。这个函数返回一个int 值，等于-1 表示流没有联系的缓存或操作失败。</p> 
<p>注：<br> 转载自“https://blog.csdn.net/sinat_36219858/article/details/80369255#17istreamseekg”，感谢！<br> 转载自"https://www.cnblogs.com/zhengfa-af/p/8145443.html"，感谢！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa31445998543ee02324bbbf291d1e5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CDH5.16.1集群企业真正离线部署(三台阿里云主机按量付费)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a33e581efdbc2e3c250c8c38d31ce58e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kubenetes 1.16.0安装kubernetes-dashboard v2.0.0-beta4</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>