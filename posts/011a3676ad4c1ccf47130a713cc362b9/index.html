<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32CubeMX学习笔记（28）——FreeRTOS实时操作系统使用（任务管理） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32CubeMX学习笔记（28）——FreeRTOS实时操作系统使用（任务管理）" />
<meta property="og:description" content="一、FreeRTOS简介 FreeRTOS 是一个可裁剪、可剥夺型的多任务内核，而且没有任务数限制。FreeRTOS 提供了实时操作系统所需的所有功能，包括资源管理、同步、任务通信等。
FreeRTOS 是用 C 和汇编来写的，其中绝大部分都是用 C 语言编写的，只有极少数的与处理器密切相关的部分代码才是用汇编写的，FreeRTOS 结构简洁，可读性很强！最主要的是非常适合初次接触嵌入式实时操作系统学生、嵌入式系统开发人员和爱好者学习。
最新版本 V9.0.0（2016年），尽管现在 FreeRTOS 的版本已经更新到 V10.4.1 了，但是我们还是选择 V9.0.0，因为内核很稳定，并且网上资料很多，因为 V10.0.0 版本之后是亚马逊收购了FreeRTOS之后才出来的版本，主要添加了一些云端组件，一般采用 V9.0.0 版本足以。
FreeRTOS官网：http://www.freertos.org/代码托管网站：https://sourceforge.net/projects/freertos/files/FreeRTOS/ 二、新建工程 1. 打开 STM32CubeMX 软件，点击“新建工程”
2. 选择 MCU 和封装
3. 配置时钟
RCC 设置，选择 HSE(外部高速时钟) 为 Crystal/Ceramic Resonator(晶振/陶瓷谐振器)
选择 Clock Configuration，配置系统时钟 SYSCLK 为 72MHz
修改 HCLK 的值为 72 后，输入回车，软件会自动修改所有配置
4. 配置调试模式
非常重要的一步，否则会造成第一次烧录程序后续无法识别调试器
SYS 设置，选择 Debug 为 Serial Wire
三、SYS Timebase Source 在 System Core 中选择 SYS ，对 Timebase Source 进行设置，选择 TIM1 作为HAL库的时基（除了 SysTick 外都可以）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/011a3676ad4c1ccf47130a713cc362b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-31T09:52:10+08:00" />
<meta property="article:modified_time" content="2022-03-31T09:52:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32CubeMX学习笔记（28）——FreeRTOS实时操作系统使用（任务管理）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="FreeRTOS_0"></a>一、FreeRTOS简介</h2> 
<blockquote> 
 <p>FreeRTOS 是一个可裁剪、可剥夺型的多任务内核，而且没有任务数限制。FreeRTOS 提供了实时操作系统所需的所有功能，包括资源管理、同步、任务通信等。</p> 
 <p>FreeRTOS 是用 C 和汇编来写的，其中绝大部分都是用 C 语言编写的，只有极少数的与处理器密切相关的部分代码才是用汇编写的，FreeRTOS 结构简洁，可读性很强！最主要的是非常适合初次接触嵌入式实时操作系统学生、嵌入式系统开发人员和爱好者学习。</p> 
 <p>最新版本 V9.0.0（2016年），尽管现在 FreeRTOS 的版本已经更新到 V10.4.1 了，但是我们还是选择 V9.0.0，因为内核很稳定，并且网上资料很多，因为 V10.0.0 版本之后是亚马逊收购了FreeRTOS之后才出来的版本，主要添加了一些云端组件，一般采用 V9.0.0 版本足以。</p> 
</blockquote> 
<ul><li>FreeRTOS官网：<a href="http://www.freertos.org/" rel="nofollow">http://www.freertos.org/</a></li><li>代码托管网站：<a href="https://sourceforge.net/projects/freertos/files/FreeRTOS/" rel="nofollow">https://sourceforge.net/projects/freertos/files/FreeRTOS/</a></li></ul> 
<h2><a id="_10"></a>二、新建工程</h2> 
<p><strong>1. 打开 STM32CubeMX 软件，点击“新建工程”</strong><br> <img src="https://images2.imgbox.com/ed/ca/ziEwtcSS_o.png" alt=""></p> 
<p><strong>2. 选择 MCU 和封装</strong><br> <img src="https://images2.imgbox.com/78/75/dHCcvQPu_o.png" alt=""></p> 
<p><strong>3. 配置时钟</strong><br> RCC 设置，选择 HSE(外部高速时钟) 为 Crystal/Ceramic Resonator(晶振/陶瓷谐振器)<br> <img src="https://images2.imgbox.com/d1/10/qWg051d6_o.png" alt=""><br> 选择 Clock Configuration，配置系统时钟 SYSCLK 为 72MHz<br> 修改 HCLK 的值为 72 后，输入回车，软件会自动修改所有配置<br> <img src="https://images2.imgbox.com/93/bd/QNvQQX4X_o.png" alt=""></p> 
<p><strong>4. 配置调试模式</strong><br> <strong>非常重要的一步，否则会造成第一次烧录程序后续无法识别调试器</strong><br> SYS 设置，选择 Debug 为 Serial Wire<br> <img src="https://images2.imgbox.com/e4/34/0DTiknpr_o.png" alt=""></p> 
<h2><a id="SYS_Timebase_Source_30"></a>三、SYS Timebase Source</h2> 
<p>在 <code>System Core</code> 中选择 <code>SYS</code> ，对 <code>Timebase Source</code> 进行设置，选择 <code>TIM1</code> 作为HAL库的时基（除了 <code>SysTick</code> 外都可以）。<br> <img src="https://images2.imgbox.com/f6/28/gb5GHLMX_o.png" alt=""></p> 
<p>在基于STM32 HAL的项目中，一般需要维护的 “时基” 主要有2个：</p> 
<ol><li>HAL的时基，SYS Timebase Source</li><li>OS的时基（仅在使用OS的情况下才考虑）</li></ol> 
<p>而这些 “时基” 该去如何维护，主要分为两种情况考虑：</p> 
<ul><li> <p><strong>裸机运行</strong>：<br> 可以通过 <code>SysTick</code>（滴答定时器）或 （<code>TIMx</code>）定时器 的方式来维护 <code>SYS Timebase Source</code>，也就是HAL库中的 <code>uwTick</code>，这是HAL库中维护的一个全局变量。在裸机运行的情况下，我们一般选择默认的 <code>SysTick</code>（滴答定时器） 方式即可，也就是直接放在 <code>SysTick_Handler()</code> 中断服务函数中来维护。</p> </li><li> <p><strong>带OS运行</strong>：<br> 前面提到的 <code>SYS Timebase Source</code> 是STM32的HAL库中的新增部分，主要用于实现 <code>HAL_Delay()</code> 以及作为各种 timeout 的时钟基准。</p> <p>在使用了OS（操作系统）之后，OS的运行也需要一个时钟基准（简称“时基”），来对任务和时间等进行管理。而OS的这个 时基 一般也都是通过 <code>SysTick</code>（滴答定时器） 来维护的，这时就需要考虑 “HAL的时基” 和 “OS的时基” 是否要共用 <code>SysTick</code>（滴答定时器） 了。</p> <p>如果共用SysTick，当我们在CubeMX中选择启用FreeRTOS之后，在生成代码时，CubeMX一定会报如下提示：<br> <img src="https://images2.imgbox.com/1d/3d/axBRMSYL_o.png" alt=""></p> </li></ul> 
<blockquote> 
 <p>强烈建议用户在使用FreeRTOS的时候，不要使用 <code>SysTick</code>（滴答定时器）作为 “HAL的时基”，因为FreeRTOS要用，最好是要换一个！！！如果共用，潜在一定风险。</p> 
</blockquote> 
<h2><a id="FreeRTOS_52"></a>四、FreeRTOS</h2> 
<h3><a id="41__53"></a>4.1 参数配置</h3> 
<p>在 <code>Middleware</code> 中选择 <code>FREERTOS</code> 设置，并选择 <code>CMSIS_V1</code> 接口版本<br> <img src="https://images2.imgbox.com/a5/56/KYji6cKN_o.png" alt=""></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/75/4e/LEmcMOpy_o.png" alt=""><br> CMSIS是一种接口标准，目的是屏蔽软硬件差异以提高软件的兼容性。RTOS v1使得软件能够在不同的实时操作系统下运行（屏蔽不同RTOS提供的API的差别），而RTOS v2则是拓展了RTOS v1，兼容更多的CPU架构和实时操作系统。因此我们在使用时可以根据实际情况选择，如果学习过程中使用STM32F1、F4等单片机时没必要选择RTOS v2，更高的兼容性背后时更加冗余的代码，理解起来比较困难。</p> 
</blockquote> 
<p>在 <code>Config parameters</code> 进行具体参数配置。</p> 
<p><strong>Kernel settings：</strong></p> 
<ul><li><strong>USE_PREEMPTION：</strong> <code>Enabled</code>：RTOS使用抢占式调度器；Disabled：RTOS使用协作式调度器（时间片）。</li><li><strong>TICK_RATE_HZ：</strong> 值设置为<code>1000</code>，即周期就是1ms。RTOS系统节拍中断的频率，单位为HZ。</li><li><strong>MAX_PRIORITIES：</strong> 可使用的最大优先级数量。设置好以后任务就可以使用从0到（MAX_PRIORITIES - 1）的优先级，其中0位最低优先级，（MAX_PRIORITIES - 1）为最高优先级。</li><li><strong>MINIMAL_STACK_SIZE：</strong> 设置空闲任务的最小任务堆栈大小，以字为单位，而不是字节。如该值设置为<code>128</code> Words，那么真正的堆栈大小就是 128*4 = 512 Byte。</li><li><strong>MAX_TASK_NAME_LEN：</strong> 设置任务名最大长度。</li><li><strong>IDLE_SHOULD_YIELD：</strong> <code>Enabled</code> 空闲任务放弃CPU使用权给其他同优先级的用户任务。</li><li><strong>USE_MUTEXES：</strong> 为1时使用互斥信号量，相关的API函数会被编译。</li><li><strong>USE_RECURSIVE_MUTEXES：</strong> 为1时使用递归互斥信号量，相关的API函数会被编译。</li><li><strong>USE_COUNTING_SEMAPHORES：</strong> 为1时启用计数型信号量， 相关的API函数会被编译。</li><li><strong>QUEUE_REGISTRY_SIZE：</strong> 设置可以注册的队列和信号量的最大数量，在使用内核调试器查看信号量和队列的时候需要设置此宏，而且要先将消息队列和信号量进行注册，只有注册了的队列和信号量才会在内核调试器中看到，如果不使用内核调试器的话次宏设置为0即可。</li><li><strong>USE_APPLICATION_TASK_TAG：</strong> 为1时可以使用vTaskSetApplicationTaskTag函数。</li><li><strong>ENABLE_BACKWARD_COMPATIBILITY：</strong> 为1时可以使V8.0.0之前的FreeRTOS用户代码直接升级到V8.0.0之后，而不需要做任何修改。</li><li><strong>USE_PORT_OPTIMISED_TASK_SELECTION：</strong> FreeRTOS有两种方法来选择下一个要运行的任务，一个是通用的方法，另外一个是特殊的方法，也就是硬件方法，使用MCU自带的硬件指令来实现。STM32有计算前导零指令吗，所以这里强制置1。</li><li><strong>USE_TICKLESS_IDLE：</strong> 置1：使能低功耗tickless模式；置0：保持系统节拍（tick）中断一直运行。假设开启低功耗的话可能会导致下载出现问题，因为程序在睡眠中，可用ISP下载办法解决。</li><li><strong>USE_TASK_NOTIFICATIONS：</strong> 为1时使用任务通知功能，相关的API函数会被编译。开启了此功能，每个任务会多消耗8个字节。</li><li><strong>RECORD_STACK_HIGH_ADDRESS：</strong> 为1时栈开始地址会被保存到每个任务的TCB中（假如栈是向下生长的）。</li></ul> 
<p><strong>Memory management settings：</strong></p> 
<ul><li><strong>Memory Allocation：</strong> <code>Dynamic/Static</code> 支持动态/静态内存申请</li><li><strong>TOTAL_HEAP_SIZE：</strong> 设置堆大小，如果使用了动态内存管理，FreeRTOS在创建 task, queue, mutex, software timer or semaphore的时候就会使用heap_x.c(x为1~5)中的内存申请函数来申请内存。这些内存就是从堆ucHeap[configTOTAL_HEAP_SIZE]中申请的。</li><li><strong>Memory Management scheme：</strong> 内存管理策略 <code>heap_4</code>。</li></ul> 
<p><strong>Hook function related definitions：</strong></p> 
<ul><li><strong>USE_IDLE_HOOK：</strong> 置1：使用空闲钩子（Idle Hook类似于回调函数）；置0：忽略空闲钩子。</li><li><strong>USE_TICK_HOOK：</strong> 置1：使用时间片钩子（Tick Hook）；置0：忽略时间片钩子。</li><li><strong>USE_MALLOC_FAILED_HOOK：</strong> 使用内存申请失败钩子函数。</li><li><strong>CHECK_FOR_STACK_OVERFLOW：</strong> 大于0时启用堆栈溢出检测功能，如果使用此功能用户必须提供一个栈溢出钩子函数，如果使用的话此值可以为1或者2，因为有两种栈溢出检测方法。</li></ul> 
<p><strong>Run time and task stats gathering related definitions：</strong></p> 
<ul><li><strong>GENERATE_RUN_TIME_STATS：</strong> 启用运行时间统计功能。</li><li><strong>USE_TRACE_FACILITY：</strong> 启用可视化跟踪调试。</li><li><strong>USE_STATS_FORMATTING_FUNCTIONS：</strong> 与宏configUSE_TRACE_FACILITY同时为1时会编译下面3个函数prvWriteNameToBuffer()、vTaskList()、vTaskGetRunTimeStats()。</li></ul> 
<p><strong>Co-routine related definitions：</strong></p> 
<ul><li><strong>USE_CO_ROUTINES：</strong> 启用协程。</li><li><strong>MAX_CO_ROUTINE_PRIORITIES：</strong> 协程的有效优先级数目。</li></ul> 
<p><strong>Software timer definitions：</strong></p> 
<ul><li><strong>USE_TIMERS：</strong> 启用软件定时器。</li></ul> 
<p><strong>Interrupt nesting behaviour configuration：</strong></p> 
<ul><li><strong>LIBRARY_LOWEST_INTERRUPT_PRIORITY：</strong> 中断最低优先级。</li><li><strong>LIBRARY_LOWEST_INTERRUPT_PRIORITY：</strong> 系统可管理的最高中断优先级。</li></ul> 
<h3><a id="42_Task_107"></a>4.2 创建任务Task</h3> 
<p>在 <code>Tasks and Queues</code> 进行配置。</p> 
<p>默认空闲任务是在系统无其它任务执行时执行。<br> <img src="https://images2.imgbox.com/7d/a7/K9T0rBia_o.png" alt=""></p> 
<p>然后我们创建两个LED任务。<br> <img src="https://images2.imgbox.com/fc/11/ydwZaRAQ_o.png" alt=""><br> <img src="https://images2.imgbox.com/22/d5/VWC2IlhR_o.png" alt=""></p> 
<ul><li><strong>Task Name：</strong> 任务名称</li><li><strong>Priority：</strong> 优先级，在 FreeRTOS 中，数值越大优先级越高，0 代表最低优先级</li><li><strong>Stack Size (Words)：</strong> 堆栈大小，单位为字，在32位处理器（STM32），一个字等于4字节，如果传入512那么任务大小为512*4字节</li><li><strong>Entry Function：</strong> 入口函数</li><li><strong>Code Generation Option：</strong> 代码生成选项</li><li><strong>Parameter：</strong> 任务入口函数形参，不用的时候配置为0或NULL即可</li><li><strong>Allocation：</strong> 分配方式：<code>Dynamic</code> 动态内存创建</li><li><strong>Buffer Name：</strong> 缓冲区名称</li><li><strong>Conrol Block Name：</strong> 控制块名称</li></ul> 
<h2><a id="LED_126"></a>五、LED</h2> 
<h3><a id="51__127"></a>5.1 参数配置</h3> 
<p>在 <code>System Core</code> 中选择 <code>GPIO</code> 设置。<br> <img src="https://images2.imgbox.com/fc/da/MIYEwXtM_o.png" alt=""><br> 在右边图中找到 LED 灯对应引脚，选择 <code>GPIO_Output</code>。<br> <img src="https://images2.imgbox.com/a3/13/YEtD0NpO_o.png" alt=""><br> 在<code>GPIO output level</code> 中选择 <code>Low</code> 输出低电平点亮，可以添加自定义标签（这样生成代码也会根据标签设置引脚的宏定义）。<br> <img src="https://images2.imgbox.com/ef/59/bs73StLL_o.png" alt=""></p> 
<h2><a id="UART_134"></a>六、UART串口打印</h2> 
<p>查看 <a href="https://blog.csdn.net/qq_36347513/article/details/112654724">STM32CubeMX学习笔记（6）——USART串口使用</a></p> 
<h2><a id="_136"></a>七、生成代码</h2> 
<p>输入项目名和项目路径<br> <img src="https://images2.imgbox.com/eb/c9/jTiF6nnp_o.png" alt=""><br> 选择应用的 IDE 开发环境 MDK-ARM V5<br> <img src="https://images2.imgbox.com/a9/2d/7BcmNWJ5_o.png" alt=""><br> 每个外设生成独立的 <code>’.c/.h’</code> 文件<br> 不勾：所有初始化代码都生成在 main.c<br> 勾选：初始化代码生成在对应的外设文件。 如 GPIO 初始化代码生成在 gpio.c 中。<br> <img src="https://images2.imgbox.com/27/e2/8GKDKHhE_o.png" alt=""><br> 点击 GENERATE CODE 生成代码<br> <img src="https://images2.imgbox.com/40/6f/LENFRCv4_o.png" alt=""></p> 
<h2><a id="_148"></a>八、任务创建与启动</h2> 
<h3><a id="81_API_149"></a>8.1 相关API说明</h3> 
<h4><a id="811_osThreadId_150"></a>8.1.1 osThreadId</h4> 
<p>任务ID。例如，对<code>osThreadCreate</code>的调用返回。可用作参数到<code>osThreadTerminate</code>以删除任务。</p> 
<pre><code class="prism language-cpp"><span class="token comment">/// Thread ID identifies the thread (pointer to a thread control block).</span>
<span class="token comment">/// \note CAN BE CHANGED: \b os_thread_cb is implementation specific in every CMSIS-RTOS.</span>
<span class="token keyword">typedef</span> TaskHandle_t osThreadId<span class="token punctuation">;</span>
</code></pre> 
<h4><a id="812_osThreadCreate_157"></a>8.1.2 osThreadCreate</h4> 
<p><strong>使用动态/静态内存的方法创建一个任务。</strong></p> 
<table><thead><tr><th>函数</th><th>osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)</th></tr></thead><tbody><tr><td>参数</td><td><strong>thread_def：</strong> 引用由osThreadDef定义的任务<br><br> <strong>argument：</strong> 任务入口函数形参</td></tr><tr><td>返回值</td><td>成功返回任务ID，失败返回0</td></tr></tbody></table> 
<h4><a id="813_osThreadTerminate_163"></a>8.1.3 osThreadTerminate</h4> 
<p><strong>删除任务。任务被删除后就不复存在，也不会再进入运行态。</strong></p> 
<table><thead><tr><th>函数</th><th>osStatus osThreadTerminate (osThreadId thread_id)</th></tr></thead><tbody><tr><td>参数</td><td><strong>thread_id：</strong> 被删除任务的ID</td></tr><tr><td>返回值</td><td>错误码</td></tr></tbody></table> 
<p>要想使用该函数必须在 <code>Include parameters</code> 中把 <code>vTaskDelete</code> 选择 <code>Enabled</code> 来使能。<br> <img src="https://images2.imgbox.com/13/0e/psivGufH_o.png" alt=""></p> 
<h4><a id="814_osKernelStart_172"></a>8.1.4 osKernelStart</h4> 
<p><strong>在创建完任务的时候，我们需要开启调度器，因为创建仅仅是把任务添加到系统中，还没真正调度，并且空闲任务也没实现，定时器任务也没实现，这些都是在开启调度函数 osKernelStart() 中实现的。为什么要空闲任务？因为 FreeRTOS 一旦启动，就必须要保证系统中每时每刻都有一个任务处于运行态（Runing），并且空闲任务不可以被挂起与删除，空闲任务的优先级是最低的，以便系统中其他任务能随时抢占空闲任务的 CPU 使用权。</strong></p> 
<table><thead><tr><th>函数</th><th>osStatus osKernelStart (void)</th></tr></thead><tbody><tr><td>参数</td><td>无</td></tr><tr><td>返回值</td><td>错误码</td></tr></tbody></table> 
<h3><a id="82__179"></a>8.2 示例</h3> 
<pre><code class="prism language-cpp"><span class="token comment">/* USER CODE END Header */</span>
<span class="token comment">/* Includes ------------------------------------------------------------------*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"main.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"cmsis_os.h"</span></span>

<span class="token comment">/* Private includes ----------------------------------------------------------*/</span>
<span class="token comment">/* USER CODE BEGIN Includes */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token comment">/* USER CODE END Includes */</span>

<span class="token comment">/* Private typedef -----------------------------------------------------------*/</span>
<span class="token comment">/* USER CODE BEGIN PTD */</span>

<span class="token comment">/* USER CODE END PTD */</span>

<span class="token comment">/* Private define ------------------------------------------------------------*/</span>
<span class="token comment">/* USER CODE BEGIN PD */</span>

<span class="token comment">/* USER CODE END PD */</span>

<span class="token comment">/* Private macro -------------------------------------------------------------*/</span>
<span class="token comment">/* USER CODE BEGIN PM */</span>

<span class="token comment">/* USER CODE END PM */</span>

<span class="token comment">/* Private variables ---------------------------------------------------------*/</span>
UART_HandleTypeDef huart1<span class="token punctuation">;</span>
DMA_HandleTypeDef hdma_usart1_rx<span class="token punctuation">;</span>
DMA_HandleTypeDef hdma_usart1_tx<span class="token punctuation">;</span>

<span class="token comment">/****************** 任务句柄 ******************/</span>
<span class="token comment">/* 
 * 任务句柄是一个指针，用于指向一个任务，当任务创建好之后，它就具有了一个任务句柄
 * 以后我们要想操作这个任务都需要通过这个任务句柄，如果是自身的任务操作自己，那么
 * 这个句柄可以为NULL。
 */</span>
 <span class="token comment">/* 空闲任务句柄 */</span>
osThreadId defaultTaskHandle<span class="token punctuation">;</span>
<span class="token comment">/* LED1 任务句柄 */</span> 
osThreadId LED1Handle<span class="token punctuation">;</span>
<span class="token comment">/* LED2 任务句柄 */</span> 
osThreadId LED2Handle<span class="token punctuation">;</span>
<span class="token comment">/* USER CODE BEGIN PV */</span>

<span class="token comment">/* USER CODE END PV */</span>

<span class="token comment">/*
*************************************************************************
* 函数声明
*************************************************************************
*/</span>
<span class="token comment">/* Private function prototypes -----------------------------------------------*/</span>
<span class="token keyword">void</span> <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">MX_DMA_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">StartDefaultTask</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> argument<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">LED1_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> argument<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* LED1_Task 任务实现 */</span> 
<span class="token keyword">void</span> <span class="token function">LED2_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> argument<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* LED2_Task 任务实现 */</span>

<span class="token comment">/* USER CODE BEGIN PFP */</span>

<span class="token comment">/* USER CODE END PFP */</span>

<span class="token comment">/* Private user code ---------------------------------------------------------*/</span>
<span class="token comment">/* USER CODE BEGIN 0 */</span>

<span class="token comment">/* USER CODE END 0 */</span>

<span class="token comment">/**
  * @brief  The application entry point.
  * @retval int
  */</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN 1 */</span>

  <span class="token comment">/* USER CODE END 1 */</span>

  <span class="token comment">/* MCU Configuration--------------------------------------------------------*/</span>

  <span class="token comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN Init */</span>

  <span class="token comment">/* USER CODE END Init */</span>

  <span class="token comment">/* Configure the system clock */</span>
  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN SysInit */</span>

  <span class="token comment">/* USER CODE END SysInit */</span>

  <span class="token comment">/* Initialize all configured peripherals */</span>
  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_DMA_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN 2 */</span>

  <span class="token comment">/* USER CODE END 2 */</span>

  <span class="token comment">/* USER CODE BEGIN RTOS_MUTEX */</span>
  <span class="token comment">/* add mutexes, ... */</span>
  <span class="token comment">/* USER CODE END RTOS_MUTEX */</span>

  <span class="token comment">/* USER CODE BEGIN RTOS_SEMAPHORES */</span>
  <span class="token comment">/* add semaphores, ... */</span>
  <span class="token comment">/* USER CODE END RTOS_SEMAPHORES */</span>

  <span class="token comment">/* USER CODE BEGIN RTOS_TIMERS */</span>
  <span class="token comment">/* start timers, add new ones, ... */</span>
  <span class="token comment">/* USER CODE END RTOS_TIMERS */</span>

  <span class="token comment">/* USER CODE BEGIN RTOS_QUEUES */</span>
  <span class="token comment">/* add queues, ... */</span>
  <span class="token comment">/* USER CODE END RTOS_QUEUES */</span>

  <span class="token comment">/* 创建任务 */</span>
  <span class="token comment">/* Create the thread(s) */</span>
  <span class="token comment">/* definition and creation of defaultTask */</span>
  <span class="token function">osThreadDef</span><span class="token punctuation">(</span>defaultTask<span class="token punctuation">,</span> StartDefaultTask<span class="token punctuation">,</span> osPriorityNormal<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  defaultTaskHandle <span class="token operator">=</span> <span class="token function">osThreadCreate</span><span class="token punctuation">(</span><span class="token function">osThread</span><span class="token punctuation">(</span>defaultTask<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* definition and creation of LED1 */</span>
  <span class="token function">osThreadDef</span><span class="token punctuation">(</span>LED1<span class="token punctuation">,</span> LED1_Task<span class="token punctuation">,</span> osPriorityIdle<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  LED1Handle <span class="token operator">=</span> <span class="token function">osThreadCreate</span><span class="token punctuation">(</span><span class="token function">osThread</span><span class="token punctuation">(</span>LED1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* definition and creation of LED2 */</span>
  <span class="token function">osThreadDef</span><span class="token punctuation">(</span>LED2<span class="token punctuation">,</span> LED2_Task<span class="token punctuation">,</span> osPriorityIdle<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  LED2Handle <span class="token operator">=</span> <span class="token function">osThreadCreate</span><span class="token punctuation">(</span><span class="token function">osThread</span><span class="token punctuation">(</span>LED2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN RTOS_THREADS */</span>
  <span class="token comment">/* add threads, ... */</span>
  <span class="token comment">/* USER CODE END RTOS_THREADS */</span>

  <span class="token comment">/* 启动任务调度 */</span>
  <span class="token comment">/* Start scheduler */</span>
  <span class="token function">osKernelStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 启动任务，开启调度 */</span>

  <span class="token comment">/* We should never get here as control is now taken by the scheduler */</span>
  <span class="token comment">/* Infinite loop */</span>
  <span class="token comment">/* USER CODE BEGIN WHILE */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/* USER CODE END WHILE */</span>

    <span class="token comment">/* USER CODE BEGIN 3 */</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE END 3 */</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
  * @brief System Clock Configuration
  * @retval None
  */</span>
<span class="token keyword">void</span> <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  RCC_OscInitTypeDef RCC_OscInitStruct <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  RCC_ClkInitTypeDef RCC_ClkInitStruct <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">/** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */</span>
  RCC_OscInitStruct<span class="token punctuation">.</span>OscillatorType <span class="token operator">=</span> RCC_OSCILLATORTYPE_HSE<span class="token punctuation">;</span>
  RCC_OscInitStruct<span class="token punctuation">.</span>HSEState <span class="token operator">=</span> RCC_HSE_ON<span class="token punctuation">;</span>
  RCC_OscInitStruct<span class="token punctuation">.</span>HSEPredivValue <span class="token operator">=</span> RCC_HSE_PREDIV_DIV1<span class="token punctuation">;</span>
  RCC_OscInitStruct<span class="token punctuation">.</span>HSIState <span class="token operator">=</span> RCC_HSI_ON<span class="token punctuation">;</span>
  RCC_OscInitStruct<span class="token punctuation">.</span>PLL<span class="token punctuation">.</span>PLLState <span class="token operator">=</span> RCC_PLL_ON<span class="token punctuation">;</span>
  RCC_OscInitStruct<span class="token punctuation">.</span>PLL<span class="token punctuation">.</span>PLLSource <span class="token operator">=</span> RCC_PLLSOURCE_HSE<span class="token punctuation">;</span>
  RCC_OscInitStruct<span class="token punctuation">.</span>PLL<span class="token punctuation">.</span>PLLMUL <span class="token operator">=</span> RCC_PLL_MUL9<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">HAL_RCC_OscConfig</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>RCC_OscInitStruct<span class="token punctuation">)</span> <span class="token operator">!=</span> HAL_OK<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">Error_Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/** Initializes the CPU, AHB and APB buses clocks
  */</span>
  RCC_ClkInitStruct<span class="token punctuation">.</span>ClockType <span class="token operator">=</span> RCC_CLOCKTYPE_HCLK<span class="token operator">|</span>RCC_CLOCKTYPE_SYSCLK
                              <span class="token operator">|</span>RCC_CLOCKTYPE_PCLK1<span class="token operator">|</span>RCC_CLOCKTYPE_PCLK2<span class="token punctuation">;</span>
  RCC_ClkInitStruct<span class="token punctuation">.</span>SYSCLKSource <span class="token operator">=</span> RCC_SYSCLKSOURCE_PLLCLK<span class="token punctuation">;</span>
  RCC_ClkInitStruct<span class="token punctuation">.</span>AHBCLKDivider <span class="token operator">=</span> RCC_SYSCLK_DIV1<span class="token punctuation">;</span>
  RCC_ClkInitStruct<span class="token punctuation">.</span>APB1CLKDivider <span class="token operator">=</span> RCC_HCLK_DIV2<span class="token punctuation">;</span>
  RCC_ClkInitStruct<span class="token punctuation">.</span>APB2CLKDivider <span class="token operator">=</span> RCC_HCLK_DIV1<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">HAL_RCC_ClockConfig</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>RCC_ClkInitStruct<span class="token punctuation">,</span> FLASH_LATENCY_2<span class="token punctuation">)</span> <span class="token operator">!=</span> HAL_OK<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">Error_Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

  <span class="token comment">/* USER CODE BEGIN USART1_Init 0 */</span>

  <span class="token comment">/* USER CODE END USART1_Init 0 */</span>

  <span class="token comment">/* USER CODE BEGIN USART1_Init 1 */</span>

  <span class="token comment">/* USER CODE END USART1_Init 1 */</span>
  huart1<span class="token punctuation">.</span>Instance <span class="token operator">=</span> USART1<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>BaudRate <span class="token operator">=</span> <span class="token number">115200</span><span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>WordLength <span class="token operator">=</span> UART_WORDLENGTH_8B<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>StopBits <span class="token operator">=</span> UART_STOPBITS_1<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>Parity <span class="token operator">=</span> UART_PARITY_NONE<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>Mode <span class="token operator">=</span> UART_MODE_TX_RX<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>HwFlowCtl <span class="token operator">=</span> UART_HWCONTROL_NONE<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>OverSampling <span class="token operator">=</span> UART_OVERSAMPLING_16<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">HAL_UART_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">)</span> <span class="token operator">!=</span> HAL_OK<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">Error_Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE BEGIN USART1_Init 2 */</span>

  <span class="token comment">/* USER CODE END USART1_Init 2 */</span>

<span class="token punctuation">}</span>

<span class="token comment">/**
  * Enable DMA controller clock
  */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">MX_DMA_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

  <span class="token comment">/* DMA controller clock enable */</span>
  <span class="token function">__HAL_RCC_DMA1_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* DMA interrupt init */</span>
  <span class="token comment">/* DMA1_Channel4_IRQn interrupt configuration */</span>
  <span class="token function">HAL_NVIC_SetPriority</span><span class="token punctuation">(</span>DMA1_Channel4_IRQn<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">HAL_NVIC_EnableIRQ</span><span class="token punctuation">(</span>DMA1_Channel4_IRQn<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* DMA1_Channel5_IRQn interrupt configuration */</span>
  <span class="token function">HAL_NVIC_SetPriority</span><span class="token punctuation">(</span>DMA1_Channel5_IRQn<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">HAL_NVIC_EnableIRQ</span><span class="token punctuation">(</span>DMA1_Channel5_IRQn<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token comment">/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  GPIO_InitTypeDef GPIO_InitStruct <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">/* GPIO Ports Clock Enable */</span>
  <span class="token function">__HAL_RCC_GPIOB_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">__HAL_RCC_GPIOA_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/*Configure GPIO pin Output Level */</span>
  <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_G_Pin<span class="token operator">|</span>LED_B_Pin<span class="token operator">|</span>LED_R_Pin<span class="token punctuation">,</span> GPIO_PIN_SET<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/*Configure GPIO pins : LED_G_Pin LED_B_Pin LED_R_Pin */</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Pin <span class="token operator">=</span> LED_G_Pin<span class="token operator">|</span>LED_B_Pin<span class="token operator">|</span>LED_R_Pin<span class="token punctuation">;</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Mode <span class="token operator">=</span> GPIO_MODE_OUTPUT_PP<span class="token punctuation">;</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Pull <span class="token operator">=</span> GPIO_NOPULL<span class="token punctuation">;</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Speed <span class="token operator">=</span> GPIO_SPEED_FREQ_LOW<span class="token punctuation">;</span>
  <span class="token function">HAL_GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token comment">/* USER CODE BEGIN 4 */</span>
<span class="token comment">/**
  * @brief 重定向c库函数printf到USARTx
  * @retval None
  */</span>
<span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">,</span> FILE <span class="token operator">*</span>f<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ch<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">/**
  * @brief 重定向c库函数getchar,scanf到USARTx
  * @retval None
  */</span>
<span class="token keyword">int</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>f<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">uint8_t</span> ch <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">HAL_UART_Receive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ch<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 4 */</span>

<span class="token comment">/* USER CODE BEGIN Header_StartDefaultTask */</span>
<span class="token comment">/**
  * @brief  Function implementing the defaultTask thread.
  * @param  argument: Not used
  * @retval None
  */</span>
<span class="token comment">/* USER CODE END Header_StartDefaultTask */</span>
<span class="token keyword">void</span> <span class="token function">StartDefaultTask</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> argument<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN 5 */</span>
  <span class="token comment">/* Infinite loop */</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">osDelay</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE END 5 */</span>
<span class="token punctuation">}</span>

<span class="token comment">/* USER CODE BEGIN Header_LED1_Task */</span>
<span class="token comment">/**
* @brief Function implementing the LED1 thread.
* @param argument: Not used
* @retval None
*/</span>
<span class="token comment">/* USER CODE END Header_LED1_Task */</span>
<span class="token keyword">void</span> <span class="token function">LED1_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> argument<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN LED1_Task */</span>
  <span class="token comment">/* Infinite loop */</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">HAL_GPIO_TogglePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_G_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"LED1_Task\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">osDelay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 延时 1000 个 tick */</span> 
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE END LED1_Task */</span>
<span class="token punctuation">}</span>

<span class="token comment">/* USER CODE BEGIN Header_LED2_Task */</span>
<span class="token comment">/**
* @brief Function implementing the LED2 thread.
* @param argument: Not used
* @retval None
*/</span>
<span class="token comment">/* USER CODE END Header_LED2_Task */</span>
<span class="token keyword">void</span> <span class="token function">LED2_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> argument<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN LED2_Task */</span>
  <span class="token comment">/* Infinite loop */</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">HAL_GPIO_TogglePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_B_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"LED2_Task\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">osDelay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* 延时 500 个 tick */</span> 
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE END LED2_Task */</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
  * @brief  Period elapsed callback in non blocking mode
  * @note   This function is called  when TIM1 interrupt took place, inside
  * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */</span>
<span class="token keyword">void</span> <span class="token function">HAL_TIM_PeriodElapsedCallback</span><span class="token punctuation">(</span>TIM_HandleTypeDef <span class="token operator">*</span>htim<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN Callback 0 */</span>

  <span class="token comment">/* USER CODE END Callback 0 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>htim<span class="token operator">-&gt;</span>Instance <span class="token operator">==</span> TIM1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">HAL_IncTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE BEGIN Callback 1 */</span>

  <span class="token comment">/* USER CODE END Callback 1 */</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */</span>
<span class="token keyword">void</span> <span class="token function">Error_Handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN Error_Handler_Debug */</span>
  <span class="token comment">/* User can add his own implementation to report the HAL error return state */</span>

  <span class="token comment">/* USER CODE END Error_Handler_Debug */</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span>  <span class="token expression">USE_FULL_ASSERT</span></span>
<span class="token comment">/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */</span>
<span class="token keyword">void</span> <span class="token function">assert_failed</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> line<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN 6 */</span>
  <span class="token comment">/* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */</span>
  <span class="token comment">/* USER CODE END 6 */</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* USE_FULL_ASSERT */</span></span>
</code></pre> 
<h3><a id="83__581"></a>8.3 工程代码</h3> 
<p>链接：<a href="https://pan.baidu.com/s/1hcYRL-bKEKX8i_s0vnGW0g" rel="nofollow">https://pan.baidu.com/s/1hcYRL-bKEKX8i_s0vnGW0g</a> 提取码：ax4a</p> 
<h2><a id="_584"></a>九、任务延时</h2> 
<h3><a id="91_API_585"></a>9.1 相关API说明</h3> 
<h4><a id="911_osDelay_586"></a>9.1.1 osDelay</h4> 
<p><strong>相对延时函数。用于阻塞延时，调用该函数后，任务将进入阻塞状态，进入阻塞态的任务将让出 CPU 资源。</strong></p> 
<table><thead><tr><th>函数</th><th>osStatus osDelay (uint32_t millisec)</th></tr></thead><tbody><tr><td>参数</td><td><strong>millisec：</strong> 毫秒数</td></tr><tr><td>返回值</td><td>错误码</td></tr></tbody></table> 
<p>要想使用该函数必须在 <code>Include parameters</code> 中把 <code>vTaskDelay</code> 选择 <code>Enabled</code> 来使能。<br> <img src="https://images2.imgbox.com/16/0b/sFvtDg3i_o.png" alt=""></p> 
<h4><a id="912_osThreadTerminate_595"></a>9.1.2 osThreadTerminate</h4> 
<p><strong>绝对延时函数。常用于较精确的周期运行任务，比如我有一个任务，希望它以固定频率定期执行，而不受外部的影响，任务从上一次运行开始到下一次运行开始的时间间隔是绝对的，而不是相对的。</strong></p> 
<table><thead><tr><th>函数</th><th>osStatus osDelayUntil (uint32_t *PreviousWakeTime, uint32_t millisec)</th></tr></thead><tbody><tr><td>参数</td><td><strong>PreviousWakeTime：</strong> 任务上一次离开阻塞态(被唤醒)的时刻。这个时刻被用作一个参考点来计算该任务下一次离开阻塞态的时刻<br><br><strong>millisec：</strong> 毫秒数</td></tr><tr><td>返回值</td><td>错误码</td></tr></tbody></table> 
<p>要想使用该函数必须在 <code>Include parameters</code> 中把 <code>vTaskDelayUntil</code> 选择 <code>Enabled</code> 来使能。<br> <img src="https://images2.imgbox.com/d7/62/SR2OPN6G_o.png" alt=""></p> 
<h3><a id="92__603"></a>9.2 示例</h3> 
<h4><a id="921__604"></a>9.2.1 相对延时</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">vTaskA</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvParameters <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// ...</span>
        <span class="token comment">// 这里为任务主体代码</span>
        <span class="token comment">// ...</span>

        <span class="token comment">/* 调用相对延时函数,阻塞 1000 个 tick */</span> 
        <span class="token function">osDelay</span><span class="token punctuation">(</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="922__619"></a>9.2.2 绝对延时</h4> 
<p><strong>注意：在使用的时候要将延时时间转化为系统节拍，在任务主体之前要调用延时函数。</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">vTaskA</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvParameters <span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">/* 用于保存上次时间。调用后系统自动更新 */</span> 
    <span class="token keyword">static</span> portTickType PreviousWakeTime<span class="token punctuation">;</span> 
    <span class="token comment">/* 设置延时时间，将时间转为节拍数 */</span> 
    <span class="token keyword">const</span> portTickType TimeIncrement <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

    <span class="token comment">/* 获取当前系统时间 */</span> 
    PreviousWakeTime <span class="token operator">=</span> <span class="token function">osKernelSysTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">/* 调用绝对延时函数,任务时间间隔为 1000 个 tick */</span> 
        <span class="token function">osDelayUntil</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>PreviousWakeTime，TimeIncrement <span class="token punctuation">)</span><span class="token punctuation">;</span> 
 
        <span class="token comment">// ...</span>
        <span class="token comment">// 这里为任务主体代码 </span>
        <span class="token comment">// ...</span>
 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_644"></a>十、任务挂起与恢复</h2> 
<h3><a id="101_API_645"></a>10.1 相关API说明</h3> 
<h4><a id="1011_osThreadSuspend_646"></a>10.1.1 osThreadSuspend</h4> 
<p><strong>挂起指定任务。被挂起的任务绝不会得到 CPU 的使用权，不管该任务具有什么优先级。</strong></p> 
<table><thead><tr><th>函数</th><th>osStatus osThreadSuspend (osThreadId thread_id)</th></tr></thead><tbody><tr><td>参数</td><td><strong>thread_id：</strong> 挂起指定任务的任务ID</td></tr><tr><td>返回值</td><td>错误码</td></tr></tbody></table> 
<p>要想使用该函数必须在 <code>Include parameters</code> 中把 <code>vTaskSuspend</code> 选择 <code>Enabled</code> 来使能。<br> <img src="https://images2.imgbox.com/e0/cc/76D1u5Y3_o.png" alt=""></p> 
<h4><a id="1012_osThreadSuspendAll_654"></a>10.1.2 osThreadSuspendAll</h4> 
<p><strong>将所有的任务都挂起。</strong></p> 
<table><thead><tr><th>函数</th><th>osStatus osThreadSuspendAll (void)</th></tr></thead><tbody><tr><td>参数</td><td>无</td></tr><tr><td>返回值</td><td>错误码</td></tr></tbody></table> 
<h4><a id="1013_osThreadResume_660"></a>10.1.3 osThreadResume</h4> 
<p><strong>让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复的时候根据挂起时的状态继续运行。如果被恢复任务在所有就绪态任务中，处于最高优先级列表的第一位，那么系统将进行任务上下文的切换。</strong></p> 
<table><thead><tr><th>函数</th><th>osStatus osThreadResume (osThreadId thread_id)</th></tr></thead><tbody><tr><td>参数</td><td><strong>thread_id：</strong> 挂起指定任务的任务ID</td></tr><tr><td>返回值</td><td>错误码</td></tr></tbody></table> 
<h4><a id="1014_osThreadResume_666"></a>10.1.4 osThreadResume</h4> 
<p><strong>让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复的时候根据挂起时的状态继续运行。如果被恢复任务在所有就绪态任务中，处于最高优先级列表的第一位，那么系统将进行任务上下文的切换。可用在中断服务程序中。</strong></p> 
<table><thead><tr><th>函数</th><th>osStatus osThreadResume (osThreadId thread_id)</th></tr></thead><tbody><tr><td>参数</td><td><strong>thread_id：</strong> 挂起指定任务的任务ID</td></tr><tr><td>返回值</td><td>错误码</td></tr></tbody></table> 
<p>要想在中断服务程序中使用该函数必须在 <code>Include parameters</code> 中把 <code>vTaskResumeFromISR</code> 选择 <code>Enabled</code> 来使能。<br> <img src="https://images2.imgbox.com/bf/7d/OaaiEUoe_o.png" alt=""></p> 
<h4><a id="1015_osThreadResumeAll_674"></a>10.1.5 osThreadResumeAll</h4> 
<p><strong>将所有的任务都恢复。</strong></p> 
<table><thead><tr><th>函数</th><th>osStatus osThreadResumeAll (void)</th></tr></thead><tbody><tr><td>参数</td><td>无</td></tr><tr><td>返回值</td><td>错误码</td></tr></tbody></table> 
<h3><a id="102__680"></a>10.2 示例</h3> 
<h4><a id="1021__681"></a>10.2.1 挂起</h4> 
<pre><code class="prism language-cpp"><span class="token comment">/**************************** 任务句柄 ********************************/</span>
<span class="token comment">/*
* 任务句柄是一个指针，用于指向一个任务，当任务创建好之后，它就具有了一个任务句柄
* 以后我们要想操作这个任务都需要通过这个任务句柄，如果是自身的任务操作自己，那么
* 这个句柄可以为 NULL。
*/</span>
osThreadId LED1Handle<span class="token punctuation">;</span><span class="token comment">/* LED 任务句柄 */</span> 

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">KEY_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> parameter<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">Key_Scan</span><span class="token punctuation">(</span>KEY1_GPIO_PORT<span class="token punctuation">,</span>KEY1_GPIO_PIN<span class="token punctuation">)</span> <span class="token operator">==</span> KEY_ON <span class="token punctuation">)</span> 
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">/* K1 被按下 */</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"挂起 LED 任务！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">osThreadSuspend</span><span class="token punctuation">(</span>LED1Handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 挂起 LED 任务 */</span> 
        <span class="token punctuation">}</span>
        <span class="token function">osDelay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 延时 20 个 tick */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="1022__705"></a>10.2.2 恢复</h4> 
<pre><code class="prism language-cpp"><span class="token comment">/**************************** 任务句柄 ********************************/</span>
<span class="token comment">/*
* 任务句柄是一个指针，用于指向一个任务，当任务创建好之后，它就具有了一个任务句柄
* 以后我们要想操作这个任务都需要通过这个任务句柄，如果是自身的任务操作自己，那么
* 这个句柄可以为 NULL。
*/</span>
osThreadId LED1Handle<span class="token punctuation">;</span><span class="token comment">/* LED 任务句柄 */</span> 

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">KEY_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> parameter<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">Key_Scan</span><span class="token punctuation">(</span>KEY2_GPIO_PORT<span class="token punctuation">,</span>KEY2_GPIO_PIN<span class="token punctuation">)</span> <span class="token operator">==</span> KEY_ON <span class="token punctuation">)</span> 
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">/* K2 被按下 */</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"恢复 LED 任务！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">osThreadResume</span><span class="token punctuation">(</span>LED1Handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 恢复 LED 任务！ */</span> 
        <span class="token punctuation">}</span>
        <span class="token function">osDelay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 延时 20 个 tick */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="1023__729"></a>10.2.3 中断服务中恢复</h4> 
<p>使用 xTaskResumeFromISR()的时候有几个需要注意的地方：</p> 
<ol><li>当函数的返回值为 pdTRUE 时：恢复运行的任务的优先级等于或高于正在运行的任务，表明在中断服务函数退出后必 须进行一次上下文切换 ， 使用 portYIELD_FROM_ISR() 进行上下文切换。当函数的返回值为 pdFALSE 时：恢复运行的任务的优先级低于当前正在运行的任务，表明在中断服务函数退出后不需 要进行上下文切换。</li><li>xTaskResumeFromISR() 通常被认为是一个危险的函数，因为它的调用并非是固定的，中断可能随时来来临。所以 xTaskResumeFromISR()不能用于任务和中断间的同步，如果中断恰巧在任务被挂起之前到达，这就会导致一次中断丢失（任务还没有挂起，调用 xTaskResumeFromISR()函数是没有意义的，只能等下一次中断）。这种情况下，可以使用信号量或者任务通知来同步就可以避免这种情况。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">vAnExampleISR</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BaseType_t xYieldRequired<span class="token punctuation">;</span>

    <span class="token comment">/* 恢复被挂起的任务 */</span> 
    xYieldRequired <span class="token operator">=</span> <span class="token function">osThreadResume</span><span class="token punctuation">(</span> xHandle <span class="token punctuation">)</span><span class="token punctuation">;</span> 

    <span class="token keyword">if</span> <span class="token punctuation">(</span> xYieldRequired <span class="token operator">==</span> pdTRUE <span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span> 
        <span class="token comment">/* 执行上下文切换， ISR 返回的时候将运行另外一个任务 */</span> 
        <span class="token function">portYIELD_FROM_ISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="1024__749"></a>10.2.4 全部恢复</h4> 
<p>osThreadResumeAll 函数的使用方法很简单，但是要注意，调用了多少次 osThreadSuspendAll() 函数就必须同样调用多少次 osThreadResumeAll() 函数。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">vDemoFunction</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">osThreadSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 处理 xxx 代码 */</span>
    <span class="token function">osThreadSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 处理 xxx 代码 */</span>
    <span class="token function">osThreadSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 处理 xxx 代码 */</span>
 
    <span class="token function">osThreadResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">osThreadResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">osThreadResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_766"></a>十一、获取任务状态</h2> 
<h3><a id="111_API_767"></a>11.1 相关API说明</h3> 
<h4><a id="1111_osThreadGetState_768"></a>11.1.1 osThreadGetState</h4> 
<p><strong>获取任务当前状态。</strong></p> 
<table><thead><tr><th>函数</th><th>osThreadState osThreadGetState(osThreadId thread_id)</th></tr></thead><tbody><tr><td>参数</td><td><strong>thread_id：</strong> 任务ID</td></tr><tr><td>返回值</td><td>以下值</td></tr></tbody></table> 
<pre><code class="prism language-cpp"><span class="token comment">/* Thread state returned by osThreadGetState */</span>
<span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span>
	osThreadRunning   <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">,</span>	      <span class="token comment">/* A thread is querying the state of itself, so must be running. */</span>
	osThreadReady     <span class="token operator">=</span> <span class="token number">0x1</span> <span class="token punctuation">,</span>			        <span class="token comment">/* The thread being queried is in a read or pending ready list. */</span>
	osThreadBlocked   <span class="token operator">=</span> <span class="token number">0x2</span><span class="token punctuation">,</span>		        <span class="token comment">/* The thread being queried is in the Blocked state. */</span>
	osThreadSuspended <span class="token operator">=</span> <span class="token number">0x3</span><span class="token punctuation">,</span>	      <span class="token comment">/* The thread being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */</span>
	osThreadDeleted   <span class="token operator">=</span> <span class="token number">0x4</span><span class="token punctuation">,</span>		          <span class="token comment">/* The thread being queried has been deleted, but its TCB has not yet been freed. */</span>   
  osThreadError     <span class="token operator">=</span> <span class="token number">0x7FFFFFFF</span>
<span class="token punctuation">}</span> osThreadState<span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_786"></a>十二、注意事项</h2> 
<p><strong>用户代码要加在 <code>USER CODE BEGIN N</code> 和 <code>USER CODE END N</code> 之间，否则下次使用 STM32CubeMX 重新生成代码后，会被删除。</strong><br> <img src="https://images2.imgbox.com/7c/26/87L0cCSl_o.png" alt=""></p> 
<hr> 
<p>• 由 <a href="https://blog.csdn.net/qq_36347513">Leung</a> 写于 2021 年 12 月 20 日</p> 
<p>• 参考：<a href="https://blog.csdn.net/qq_42900996/article/details/117325419?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163964371416780255247816%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=163964371416780255247816&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-11-117325419.pc_v2_rank_blog_default&amp;utm_term=stm32cubemx+freertos&amp;spm=1018.2226.3001.4450">STM32CubeMX之FreeRTOS</a><br> 　　　　<a href="https://blog.csdn.net/zns12345/article/details/109456967?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163964371416780264079534%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163964371416780264079534&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~baidu_landing_v2~default-4-109456967.pc_v2_rank_blog_default&amp;utm_term=stm32cubemx+freertos&amp;spm=1018.2226.3001.4450">STM32CUBEMX的freertos一般使用方法笔记</a><br> 　　　　<a href="https://blog.csdn.net/weixin_43879311/article/details/109958651">STM32CubeIDE（十一）：FreeRTOS选项中Disable、CMSIS_V1和CMSIS_V2的区别</a><br> 　　　　<a href="https://blog.csdn.net/m0_38064214/article/details/84285587">HAL库中的 SYS Timebase Source 和 SysTick_Handler()</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7344389728232a646c67166c9ef6739/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">shardingsphere5.0.0整合分布式柔性事务seata1.4.2示例步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33392bb35403f4bbceb69f49c1d93700/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tomcat学习详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>