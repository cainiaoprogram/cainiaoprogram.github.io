<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ELK--- Elastic Stack文档存储机制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ELK--- Elastic Stack文档存储机制" />
<meta property="og:description" content="文章目录 数据路由增删改内部机制查询内部机制Bulk 存储的JSON格式传统的JSON数组：现有的特殊形式 数据路由 存储文档时应该存储到哪个分片上，ES通过数据路由来进行确定。
数据路由分为自动的路由算法或者手动指定。
路由算法 shard = hash(routing) % number_of_primary_shards 哈希值对主分片数取模
例如有三个主分片，当存储hash(id)=5的文档时，5%3=2，此时ES会将文档存储在shard2上，这就是路由算法。
手动指定
语法：PUT /index/type/id?routing=key 例如进行以下插入
PUT /stu/class1/1?routing=jerry { &#34;name&#34;:&#34;jack&#34;, &#34;age&#34;: 18 } 此时ES会将其分配到一个主分片中，当再次插入到其它文档的routing的值为jerry，会将其存入同一个主分片中。
但是缺点是当设计的不合理的时候，会造成数据倾斜，大量数据堆积在同一个主分片。
因此不同文档尽量放到不同的索引中，剩下的事情交给ES集群自己处理。
增删改内部机制 对于增删改，统一可以看成是UPDATE，都是对数据的改动。
一个改动请求发送到ES集群，经历以下步骤:
客户端选择一个node发送请求过去，此节点作为coordinating node(协调节点)。协调节点对document(文档)进行路由，将请求转发给对应的node。实际的node上的主分片处理请求，然后将数据同步到副本分片上。协调节点如果发现主分片和所有副本分片都完成后，就返回响应结果给客户端。 查询内部机制 一个查询请求发送到ES集群，经历以下步骤:
客户端发送请求到任意一个node，成为协调节点。协调节点对文档进行路由，将请求转发到对应的node， 此时会使用round-robin随机轮询算法，在主分片以及其所有副本分片中随机选择一个，保证读请求的负载均衡。收请求的node返回文档给协调节点。协调节点返回文档给客户端。 特殊情况：文档如果还在建立索引过程中，可能只存在主分片有数据，任何一个副本分片都没有，此时可能会导致无法读取到文档，但是当文档完成索引建立之后，此时主分片和副本分片就都有了。
Bulk 存储的JSON格式 传统的JSON数组： [ { &#34;action&#34;:{ &#34;method&#34;:&#34;create&#34; }, &#34;data&#34;:{ &#34;id&#34;:1, &#34;name&#34;:&#34;java&#34; } }, { &#34;action&#34;:{ &#34;method&#34;:&#34;create&#34; }, &#34;data&#34;:{ &#34;id&#34;:2, &#34;name&#34;:&#34;cpp&#34; } } ] 这种JSON的表示形式是我们平常所用的形式，看起来比较直观，可读性较好。
但是对于ES来说，未必友好。
ES对于标准格式的JSON，需要按照下述流程去进行处理：
将JSON数组解析为JSONArray对象，此时整个数据会在内存中出现一份一模一样的拷贝，一份数据是JSON文本，一份数据是 JSONArray对象。解析JSON数组里的每个JSON，对每个请求中的文档进行路由。为路由到同一个分片上的多个请求，创建一个请求数组。将这个请求数组序列化 。将序列化后的请求数组发送到对应的节点上去。 这些会加大内存和资源的消耗，同时增加JVM的GC开销。JVM的垃圾回收次数频繁，导致ES的JVM停止工作线程的时间更多，从而大大降低效率和性能。
现有的特殊形式 POST /_bulk { &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/54611b92afb29c6c62f884381511f947/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-08T15:40:22+08:00" />
<meta property="article:modified_time" content="2022-01-08T15:40:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ELK--- Elastic Stack文档存储机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">数据路由</a></li><li><a href="#_32" rel="nofollow">增删改内部机制</a></li><li><a href="#_41" rel="nofollow">查询内部机制</a></li><li><a href="#Bulk_JSON_50" rel="nofollow">Bulk 存储的JSON格式</a></li><li><ul><li><a href="#JSON_51" rel="nofollow">传统的JSON数组：</a></li><li><a href="#_87" rel="nofollow">现有的特殊形式</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>数据路由</h2> 
<p>存储文档时应该存储到哪个分片上，ES通过数据路由来进行确定。</p> 
<p>数据路由分为自动的路由算法或者手动指定。</p> 
<ul><li>路由算法</li></ul> 
<pre><code class="prism language-java">shard <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>routing<span class="token punctuation">)</span> <span class="token operator">%</span> number_of_primary_shards
</code></pre> 
<p>哈希值对主分片数取模</p> 
<p>例如有三个主分片，当存储<code>hash(id)=5</code>的文档时，<code>5%3=2</code>，此时ES会将文档存储在shard2上，这就是路由算法。</p> 
<ul><li>手动指定<br> 语法：<code>PUT /index/type/id?routing=key</code></li></ul> 
<p>例如进行以下插入</p> 
<pre><code>PUT /stu/class1/1?routing=jerry
{
"name":"jack",
"age": 18
}
</code></pre> 
<p>此时ES会将其分配到一个主分片中，当再次插入到其它文档的<code>routing</code>的值为<code>jerry</code>，会将其存入同一个主分片中。</p> 
<p>但是缺点是当设计的不合理的时候，会造成数据倾斜，大量数据堆积在同一个主分片。</p> 
<p>因此不同文档尽量放到不同的索引中，剩下的事情交给ES集群自己处理。</p> 
<h2><a id="_32"></a>增删改内部机制</h2> 
<p>对于增删改，统一可以看成是<code>UPDATE</code>，都是对数据的改动。</p> 
<p>一个改动请求发送到ES集群，经历以下步骤:</p> 
<ul><li>客户端选择一个node发送请求过去，此节点作为coordinating node(协调节点)。</li><li>协调节点对document(文档)进行路由，将请求转发给对应的node。</li><li>实际的node上的主分片处理请求，然后将数据同步到副本分片上。</li><li>协调节点如果发现主分片和所有副本分片都完成后，就返回响应结果给客户端。</li></ul> 
<h2><a id="_41"></a>查询内部机制</h2> 
<p>一个查询请求发送到ES集群，经历以下步骤:</p> 
<ul><li>客户端发送请求到任意一个node，成为协调节点。</li><li>协调节点对文档进行路由，将请求转发到对应的node， 此时会使用round-robin随机轮询算法，在主分片以及其所有副本分片中随机选择一个，保证读请求的负载均衡。</li><li>收请求的node返回文档给协调节点。</li><li>协调节点返回文档给客户端。</li></ul> 
<p>特殊情况：文档如果还在建立索引过程中，可能只存在主分片有数据，任何一个副本分片都没有，此时可能会导致无法读取到文档，但是当文档完成索引建立之后，此时主分片和副本分片就都有了。</p> 
<h2><a id="Bulk_JSON_50"></a>Bulk 存储的JSON格式</h2> 
<h3><a id="JSON_51"></a>传统的JSON数组：</h3> 
<pre><code class="prism language-java"><span class="token punctuation">[</span>
	<span class="token punctuation">{<!-- --></span>
  	  <span class="token string">"action"</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
      <span class="token string">"method"</span><span class="token operator">:</span><span class="token string">"create"</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span> 
	  <span class="token string">"data"</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
      <span class="token string">"id"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"java"</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{<!-- --></span>
  	  <span class="token string">"action"</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
      <span class="token string">"method"</span><span class="token operator">:</span><span class="token string">"create"</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span> 
	  <span class="token string">"data"</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
      <span class="token string">"id"</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>
      <span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"cpp"</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span>    
</code></pre> 
<p>这种JSON的表示形式是我们平常所用的形式，看起来比较直观，可读性较好。</p> 
<p>但是对于ES来说，未必友好。</p> 
<p>ES对于标准格式的JSON，需要按照下述流程去进行处理：</p> 
<ul><li>将JSON数组解析为JSONArray对象，此时整个数据会在内存中出现一份一模一样的拷贝，一份数据是JSON文本，一份数据是 JSONArray对象。</li><li>解析JSON数组里的每个JSON，对每个请求中的文档进行路由。</li><li>为路由到同一个分片上的多个请求，创建一个请求数组。</li><li>将这个请求数组序列化 。</li><li>将序列化后的请求数组发送到对应的节点上去。</li></ul> 
<p>这些会加大内存和资源的消耗，同时增加JVM的GC开销。JVM的垃圾回收次数频繁，导致ES的JVM停止工作线程的时间更多，从而大大降低效率和性能。</p> 
<h3><a id="_87"></a>现有的特殊形式</h3> 
<pre><code class="prism language-java">POST <span class="token operator">/</span>_bulk
<span class="token punctuation">{<!-- --></span> <span class="token string">"create"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"stu"</span><span class="token punctuation">,</span>  <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"1"</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>\n
<span class="token punctuation">{<!-- --></span> <span class="token string">"test_field"</span><span class="token operator">:</span> <span class="token string">"bulk yyds"</span> <span class="token punctuation">}</span>\n
<span class="token punctuation">{<!-- --></span> <span class="token string">"delete"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"stu"</span><span class="token punctuation">,</span>  <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"2"</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> 
</code></pre> 
<ul><li>不用将其转换为JSON对象，直接按照换行符切割JSON字符串。</li><li>对每两个一组的JSON，读取meta，进行文档路由。</li><li>直接将对应的JSON发送到node上去。</li></ul> 
<p>和传统的格式相比，最最最大的优势在于，不需要将JSON数组解析为一个JSONArray对象，形成一份大数据的拷贝，浪费内存空间，尽可能地保证性能。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/90a5cdad2f11b88d2f944dbcf79b5930/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一个小破网站，比Pandas官网还好用？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5906b3f4b6f9660a8bcdf8c562e4ffa3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Towards Open Vocabulary Object Detection without Human-provided Bounding Boxes(2021CVPR)----论文阅读笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>