<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>热部署 和 热加载 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="热部署 和 热加载" />
<meta property="og:description" content="本文主要讲热部署和热加载的区别、原理，以及常用的热部署的方式实践心得，其中包括HotSwap、Spring-loaded、Spring-boot-devtools、HotCode2和JRebel，诸多方式任你选择，希望能为你的开发进一步提效
1 热部署和热加载 开篇先说下热部署和热加载的区别：
热部署：在服务器运行时重新部署应用，也就是说在不停止容器的情况下实现整个应用的重新加载部署，这种方式会释放内存，多用于生成环境
热加载：在应用运行时重新加载class，主要依赖于Java的类加载机制，如果监控的类文件有改变，则重新载入，多用于应用开发阶段，又叫开发者模式，在开发过程中会经常性的进行修改文件或debug，频繁启动应用会花费很多时间成本，热加载机制可以极大的提升开发效率，这也是写这篇文章的主要原因，提高大家的开发效率。
但我们通常所说的热部署其实包括热加载的，可以理解为热加载是热部署的一种VIP情况
2 热加载的原理 2.1 类加载过程 在了解热加载之前，首先说下类加载的过程，类加载的过程简单来说就是JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程；类加载的过程主要分为三大部分：加载、连接、初始化，其中连接又分为：验证、准备、解析；示例图如下：
编译：把Java文件编译成.class字节码的过程加载：类加载过程的开始，把class字节码文件从各个源通过类加载器载入内存中连接 验证：确保类加载的正确性，保证加载进来的字节流符合JVM规范，不会造成安全问题准备：类变量（注意，不是实例变量，是static变量）分配内存，并且设置这些类变量的初始值解析：将常量池内的符号引用替换为直接引用的过程初始化：是类加载过程的最后一步，可以理解为是执行类构造器&lt;clinit&gt;（）方法的过程，真正开始执行类中定义的Java程序代码或者说字节码。 2.2 剖析原理 首先通过Java编译器把Java文件编译成class字节码，Java类加载器（classLoad）读取字节码到内存中，生成实例对象，一个类加载器中的Java全限定名是全局唯一的，也就是说一个类加载器只能加载一个同名类，classLoader内部会缓存已经加载过的class，重新加载的话，是直接读 取缓存的，如果是使用自定义的classLoader加载，不使用双亲委派模型，绕过判断，但是在JVM解析、验证class时也是会抛出异常的，所以实现__热部署的关键是在可更改已加载的class文件，用新的class文件替换同名的old class文件（或者更改class字节码），或者是重新创建一个classLoader进行加载，然后把老的classLoader卸载掉__；第二种方案可以理解成热部署，所以这种方案为开发提效有限；而第一种方案是更新或替换old class文件所以这种热加载的方式对开发提效非常明显。
2.3 发展历程 在JDK1.4时，Sun在JVM中引入了HotSwap的实验性技术，这一技术被合成到了Debugger API内部，其允许调试者使用同一个类标识来更新类的字节码，这就意味着在不重载容器的情况下，允许动态更新class文件，使应用程序在执行时可执行新的代码。
从JDK1.5开始，提出了“Instrumentation”特性，可通过Instrumentation API直接提供给Java应用使用，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义，但在 JDK1.5 中，需要要求在运行前利用命令行参数或者系统参数来设置代理类。
JDK1.6之后，对Instrumentation进行了加强，启动后的 instrument、本地代码（native code）instrument，以及动态改变 classpath 等等，“java.lang.instrument”包的具体实现，依赖于 JVMTI（Java Virtual Machine Tool Interface），JVMTI 提供了一套”代理”程序机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能，JVMTI 还在虚拟机内存管理，线程控制，方法和变量操作等等方面提供了大量有价值的函数，Instrumentation 的最大作用，就是类定义动态改变和操作。--参见IBM Developer
3 Hot Swap实现热部署 这种方式有两个弊端：
1 就是仅限于修改方法体，对比如新增方法、字段之类 就需要重新部署才可以了，这种方式有没有解决方案呐，答案是肯定的，收费的JRebel，或者免费的HotSwapAgent&#43;DCEVM
2 HotSwap需要依托于IDE集成，比如主流的IDE：IntlliJ IDEA、Eclipse、MyEclipse、NetBeans等
下面HotSwap以IDEA为例实现方法体内的热部署功能
3.1 IDEA基于HotSwap的热部署功能 使用IDEA自动编译部署功能，实现应用的热部署(Hot Swap)
3.1.1 检查是否开启HotSwap，默认是开启的 3.1.2 开启IDEA自动编译功能 弹出registry浮层面板，快捷键control&#43;shift&#43;a,然后找到compiler.automake.allow.when.app.runing勾选" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/05191d8e6f3c1651883f38bae2ea91f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-22T16:39:49+08:00" />
<meta property="article:modified_time" content="2023-12-22T16:39:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">热部署 和 热加载</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>本文主要讲热部署和热加载的区别、原理，以及常用的热部署的方式实践心得，其中包括HotSwap、Spring-loaded、Spring-boot-devtools、HotCode2和JRebel，诸多方式任你选择，希望能为你的开发进一步提效</p> 
</blockquote> 
<h2 id="0">1 热部署和热加载</h2> 
<p>开篇先说下热部署和热加载的区别：<br> 热部署：在服务器运行时重新部署应用，也就是说在不停止容器的情况下实现整个应用的重新加载部署，这种方式会释放内存，多用于生成环境<br> 热加载：在应用运行时重新加载class，主要依赖于Java的类加载机制，如果监控的类文件有改变，则重新载入，多用于应用开发阶段，又叫开发者模式，在开发过程中会经常性的进行修改文件或debug，频繁启动应用会花费很多时间成本，热加载机制可以极大的提升开发效率，这也是写这篇文章的主要原因，提高大家的开发效率。<br> 但我们通常所说的热部署其实包括热加载的，可以理解为热加载是热部署的一种VIP情况</p> 
<h2 id="1">2 热加载的原理</h2> 
<h3 id="2">2.1 类加载过程</h3> 
<p>在了解热加载之前，首先说下类加载的过程，类加载的过程简单来说就是JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程；类加载的过程主要分为三大部分：加载、连接、初始化，其中连接又分为：验证、准备、解析；示例图如下：</p> 
<p></p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552814151735-793264e6-4f11-4487-8db1-96a56b1ff479.png" rel="nofollow"><img alt="image.png | left | 747x210" height="490" src="https://images2.imgbox.com/e2/26/QC6bpv1c_o.png" width="1200"></a></p> 
<ul><li>编译：把Java文件编译成.class字节码的过程</li><li>加载：类加载过程的开始，把class字节码文件从各个源通过类加载器载入内存中</li><li>连接 
  <ul><li>验证：确保类加载的正确性，保证加载进来的字节流符合JVM规范，不会造成安全问题</li><li>准备：类变量（注意，不是实例变量，是static变量）分配内存，并且设置这些类变量的初始值</li><li>解析：将常量池内的符号引用替换为直接引用的过程</li></ul></li><li>初始化：是类加载过程的最后一步，可以理解为是执行类构造器&lt;clinit&gt;（）方法的过程，真正开始执行类中定义的Java程序代码或者说字节码。</li></ul> 
<h3 id="3">2.2 剖析原理</h3> 
<p>        首先通过Java编译器把Java文件编译成class字节码，Java类加载器（classLoad）读取字节码到内存中，生成实例对象，一个类加载器中的Java全限定名是全局唯一的，也就是说一个类加载器只能加载一个同名类，classLoader内部会缓存已经加载过的class，重新加载的话，是直接读  取缓存的，如果是使用自定义的classLoader加载，不使用双亲委派模型，绕过判断，但是在JVM解析、验证class时也是会抛出异常的，所以实现__热部署的关键是<strong>在</strong>可更改已加载的class文件，用新的class文件替换同名的old class文件（或者更改class字节码）<strong>，或者是</strong>重新创建一个classLoader进行加载，然后把老的classLoader卸载掉__；第二种方案可以理解成热部署，所以这种方案为开发提效有限；而第一种方案是更新或替换old class文件所以这种热加载的方式对开发提效非常明显。</p> 
<h3 id="4">2.3 发展历程</h3> 
<p>     在JDK1.4时，Sun在JVM中引入了HotSwap的实验性技术，这一技术被合成到了<code>Debugger API</code>内部，其允许调试者使用同一个类标识来更新类的字节码，这就意味着在不重载容器的情况下，允许动态更新class文件，使应用程序在执行时可执行新的代码。<br>     从JDK1.5开始，提出了“Instrumentation”特性，可通过<code>Instrumentation API</code>直接提供给Java应用使用，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义，但在 JDK1.5 中，需要要求在运行前利用命令行参数或者系统参数来设置代理类。<br>     JDK1.6之后，对Instrumentation进行了加强，启动后的 instrument、本地代码（native code）instrument，以及动态改变 classpath 等等，“java.lang.instrument”包的具体实现，依赖于 JVMTI（Java Virtual Machine Tool Interface），JVMTI 提供了一套”代理”程序机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能，JVMTI 还在虚拟机内存管理，线程控制，方法和变量操作等等方面提供了大量有价值的函数，Instrumentation 的最大作用，就是类定义动态改变和操作。--<a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" rel="nofollow" title="参见IBM Developer">参见IBM Developer</a></p> 
<h2 id="5">3 Hot Swap实现热部署</h2> 
<p><strong>这种方式有两个弊端：</strong><br>   1 就是仅限于修改方法体，对比如新增方法、字段之类 就需要重新部署才可以了，这种方式有没有解决方案呐，答案是肯定的，<strong>收费的JRebel，</strong><strong>或者免费的HotSwapAgent+DCEVM</strong></p> 
<p>2 HotSwap需要依托于IDE集成，比如主流的IDE：IntlliJ IDEA、Eclipse、MyEclipse、NetBeans等</p> 
<p>下面HotSwap以IDEA为例实现方法体内的热部署功能</p> 
<h3 id="6">3.1 IDEA基于HotSwap的热部署功能</h3> 
<blockquote> 
 <p>使用IDEA自动编译部署功能，实现应用的热部署(Hot Swap)</p> 
</blockquote> 
<h4 id="7">3.1.1 检查是否开启HotSwap，默认是开启的</h4> 
<p></p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552832104089-0f558fcb-a18f-4f61-bf5e-6d85bd2b714c.png" rel="nofollow"><img alt="image.png | left | 527x207" height="592" src="https://images2.imgbox.com/e1/0b/10PryDQV_o.png" width="1200"></a></p> 
<h4 id="8">3.1.2 开启IDEA自动编译功能</h4> 
<p>弹出registry浮层面板，快捷键control+shift+a,然后找到compiler.automake.allow.when.app.runing勾选</p> 
<p></p> 
<p class="img-center"><a href="https://cdn.nlark.com/lark/0/2018/png/76794/1543734986004-7bd7f6db-61f7-42ba-8cdd-eb7bb35efa87.png" rel="nofollow"><img alt="image.png | left | 554x439" height="1200" src="https://images2.imgbox.com/d6/62/eY8xUR44_o.png" width="1200"></a></p> 
<p>快捷键不对的可以在keymap面板中找下:</p> 
<p></p> 
<p class="img-center"><a href="https://cdn.nlark.com/lark/0/2018/png/76794/1543735640605-617d0a84-093b-4978-a6e8-9ba25bfbd0b2.png" rel="nofollow"><img alt="image.png | left | 551x145" height="544" src="https://images2.imgbox.com/cb/06/NFWgUZCd_o.png" width="1200"></a></p> 
<h4 id="9">3.1.3 设置IDEA自动编译</h4> 
<p></p> 
<p class="img-center"><a href="https://cdn.nlark.com/lark/0/2018/png/76794/1543735296856-0bf40ce4-a7a2-4974-ade4-fc4a66e483e4.png" rel="nofollow"><img alt="image.png | left | 655x2" height="786" src="https://images2.imgbox.com/4c/38/wWklhGrG_o.png" width="1200"></a></p> 
<h4 id="10">3.1.4 手工编译（注意类加载顺序）</h4> 
<p>修改某个类中的方法中的内容后，在菜单栏中Build菜单中Recompile或右键点击Recompile，编译完成之后，再次访问，可验证加的内容是否生效</p> 
<p></p> 
<p class="img-center"><a href="https://cdn.nlark.com/lark/0/2018/png/76794/1543736845827-9a4fb203-8aee-4e24-af6a-c57c572ed1d7.png" rel="nofollow"><img alt="image.png | left | 341x170" height="292" src="https://images2.imgbox.com/b4/93/EfSLaLiz_o.png" width="586"></a></p> 
<p>或：</p> 
<p></p> 
<p class="img-center"><a href="https://cdn.nlark.com/lark/0/2018/png/76794/1543736813446-febe28c1-7b17-4a41-92ce-c8e81c841e43.png" rel="nofollow"><img alt="image.png | left | 320x121" height="212" src="https://images2.imgbox.com/66/21/1oGXy36W_o.png" width="560"></a></p> 
<p>点击Recompile之后，第一次会弹出框让选择：是否重新加载classes，选择是</p> 
<p></p> 
<p class="img-center"><a href="https://cdn.nlark.com/lark/0/2018/png/76794/1543736972426-fec1fb48-de88-4771-a83e-a69ec0612a3e.png" rel="nofollow"><img alt="image.png | left | 296x109" height="152" src="https://images2.imgbox.com/91/a8/mbghr8tp_o.png" width="412"></a></p> 
<h4 id="11">3.1.5 验证结果</h4> 
<p></p> 
<p class="img-center"><a href="https://cdn.nlark.com/lark/0/2018/png/76794/1543735077197-b6afc5b0-a420-4353-a614-2e0581820bca.png" rel="nofollow"><img alt="热部署2.png | center | 687x184" height="580" src="https://images2.imgbox.com/ab/d1/vqBqftX0_o.png" width="1200"></a></p> 
<h2 id="12">4 Spring-loaded实现热部署</h2> 
<p>  spring-loaded是针对Springboot类的项目，springloaded热部署只可以<strong>修改已有方法与页面</strong>，如果是新加的方法或者类则无法实现热部署，并且需要配置启动参数-javaagent(-javaagent:.\lib\springloaded-1.2.8.RELEASE.jar -noverify)。这种方式需要指定springloaded jar包的位置，我不怎么用，就不多说，有兴趣的同学可以自己玩下。</p> 
<pre><code>&lt;dependency&gt;  
           &lt;groupId&gt;org.springframework&lt;/groupId&gt;  
           &lt;artifactId&gt;springloaded&lt;/artifactId&gt;
       &lt;/dependency&gt;  
</code></pre> 
<h2 id="13">5 Spring-boot-devtools实现热部署</h2> 
<blockquote> 
 <p>注意：PandoraBoot不支持devtools实现热部署<br>       Devtools是为springboot应用提供的一个开发者服务模块，其原理就是上面第二章节所说的先重新创建类加载器然后销毁old类加载器；devtools在监控到代码有更改之后，会快速重启应用，这里重启并不是整个应用重启，而是重新加载部分classLoader，因为其有两个classLoader,一个classLoader加载不会改变的类(如各种第三方jar包、二方包等)，另一个classLoader加载会更改的类可以理解成自己开发的类，被称为RestartClassLoader，这样有代码更新时，会重新创建一个RestartClassLoader，并销毁之前的RestartClassLoader，由于只加载部分类，所以<strong>相对整个应用重启 用时相对较少，但相较于JRebel和hotSwap速度还是大打折扣的，比hotSwap优势就是可以支持静态资源文件(页面、配置文件等，监控范围是classpath下的文件)、新增方法、字段之类的更新。</strong></p> 
</blockquote> 
<p>源码：</p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552838275253-b3dde679-95a8-424d-b9d2-a06649320450.png" rel="nofollow"><img alt="image.png | left | 693x183" height="368" src="https://images2.imgbox.com/f2/54/et9WhDfb_o.png" width="1200"></a></p> 
<p></p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552838745657-d6f3dce7-fc82-4ec1-b48d-653c6a26b5d8.png" rel="nofollow"><img alt="image.png | left | 636x279" height="456" src="https://images2.imgbox.com/3a/d8/DKapxUL1_o.png" width="1038"></a></p> 
<h3 id="14">5.1 常用配置项</h3> 
<ul><li> <p>默认情况下，以下文件夹下的文件修改不会使应用重启，但是会重新加载（devtools内嵌了一个LiveReload server，当资源发生改变时，浏览器刷新）。</p> <pre><code>META-INF/maven/&lt;strong&gt;,META-INF/resources/&lt;/strong&gt;,resources/&lt;strong&gt;,static/&lt;/strong&gt;,public/&lt;strong&gt;,templates/&lt;/strong&gt;,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties
</code></pre> </li><li> <p>如果想改变默认的设置，可以自己设置不重启的目录：spring.devtools.restart.exclude=static/**,public/**，这样的话，就只有这两个目录下的文件修改不会导致restart操作了。</p> </li><li> <p>如果要在保留默认设置的基础上还要添加其他的排除目录：spring.devtools.restart.additional-exclude</p> </li></ul> 
<p>源码：</p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552871907689-31d210a9-5dc8-466f-8c03-45f73c50fcde.png" rel="nofollow"><img alt="image.png | left | 747x109" height="210" src="https://images2.imgbox.com/19/0b/Q5gG3RzF_o.png" width="1200"></a></p> 
<ul><li>如果想要使得当非classpath下的文件发生变化时应用得以重启，使用：spring.devtools.restart.additional-paths，这样devtools就会将该目录列入了监听范围</li></ul> 
<p>源码：</p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552871981809-55517ad2-9961-4cb3-b9a6-a7ad5b4765a2.png" rel="nofollow"><img alt="image.png | left | 747x126" height="220" src="https://images2.imgbox.com/23/2d/1fanwRIM_o.png" width="1200"></a></p> 
<ul><li>如果你想关闭自动restart功能，通过spring.devtools.restart.enabled属性配置即可</li><li>如果想开启或关闭远程debug功能，通过spring.devtools.remote.debug.enabled属性配置，默认是true</li></ul> 
<p>源码：</p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552872239938-884bf519-c759-479e-9f55-cd9c45739809.png" rel="nofollow"><img alt="image.png | left | 736x134" height="252" src="https://images2.imgbox.com/cd/a0/IpM3g05M_o.png" width="1200"></a></p> 
<ul><li>实现页面热部署，通过spring.thymeleaf.cache属性配置为false即可,默认为true</li></ul> 
<p>还有远程相关的其他一些配置、代理配置、重启轮询时间等待时间等的配置可以查看源码中的spring-configuration-metadata.json文件</p> 
<h3 id="15">5.2 使用示例</h3> 
<p>1 添加依赖</p> 
<pre><code>&lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;

&lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;fork&gt;true&lt;/fork&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
</code></pre> 
<p>Eclipse: 下面是在eclipse中实现热部署的演示，项目启动后，新加类TestController,并新增getName()方法,保存后可以观察到后台已进行热部署了，在浏览器中访问如下RPC，可正常返回结果</p> 
<p></p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552878401248-bc1d03b2-dd91-488c-ae7c-e5746003e4fa.png" rel="nofollow"><img alt="image.png | left | 674x405" height="1002" src="https://images2.imgbox.com/d7/bb/tLhbjXAr_o.png" width="1200"></a></p> 
<h2 id="16"></h2> 
<h2 id="17">6 JRebel 实现热部署</h2> 
<p>强烈推荐，有商业版和个人免费版（个人版申请通道好像已关闭，但有试用版或<a href="https://blog.csdn.net/sanfye/article/details/88653612" title="其他解决方案">其他解决方案</a>(仅供学习使用，请支持正版)）<br> 它可以在无需动态类加载器的情况下更新类，且只做极少的限制(改变static静态字段值不支持)，它的工作原理就是监控磁盘上的已编译的class文件，并通过rebel.xml配置文件把归档的应用(zip、jar、war)和应用模块间建立一个对应关系，通过该文件JRebel可以直接找到归档应用对应的源文件，当某个类被更新时，该文件告诉JRebel在哪里可以找到源文件，使其被从工作区中而不是从归档文件中读取。也就是因为它的这一特性，使其可以对诸如Html、xml、.properties、.yml等资源类的文件也可以及时更新。</p> 
<h3 id="23">6.1 使用示例</h3> 
<h4 id="24">6.1.1 安装JRebel</h4> 
<p></p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552915750612-0fe6a1d1-a895-4db1-b529-bf6a47999104.png" rel="nofollow"><img alt="image.png | left | 672x104" height="344" src="https://images2.imgbox.com/0c/c8/Tyraebyq_o.png" width="1200"></a></p> 
<h4 id="25">6.1.2 使用JRebel启动项目</h4> 
<p>安装完成之后，会在工作栏中显示出JRebel图标</p> 
<p></p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552915620297-7847f4ee-8477-41d6-9fe1-c452d84d43bf.png" rel="nofollow"><img alt="image.png | left | 393x72" height="124" src="https://images2.imgbox.com/06/6b/3FvLcSY0_o.png" width="680"></a></p> 
<p><br> 或</p> 
<p></p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552915638905-334860bf-2867-4168-ab72-7213d9e53329.png" rel="nofollow"><img alt="image.png | left | 452x110" height="296" src="https://images2.imgbox.com/2f/65/2S1RdYLu_o.png" width="1200"></a></p> 
<h4 id="26">6.1.3 验证JRebel是否启动成功</h4> 
<p>项目启动时，控制台出现如下信息时表示JRebel配置正确可以正常使用</p> 
<p></p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552915713004-9be60de0-b0ec-42c9-82db-97d33690f466.png" rel="nofollow"><img alt="image.png | left | 571x283" height="760" src="https://images2.imgbox.com/b5/9a/e1SZ7LTz_o.png" width="1200"></a></p> 
<h4 id="27">6.1.4 设置热部署模块</h4> 
<p>在IDEA视图窗口中打开JRebel，选中jrcon复选框，JRebel会自动在对应模块下生成rebel.xml文件，该文件将被放置到项目的源代码树中，对于Maven项目，它将被放置到src/main/resources中，以便在构建期间自动获取。</p> 
<p></p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552888701801-57de3c98-ef8b-46cf-bc85-b8c690b4ddb4.png" rel="nofollow"><img alt="image.png | left | 400x229" height="394" src="https://images2.imgbox.com/50/5e/NOrO5ucm_o.png" width="688"></a></p> 
<p>注：每个模块下resources资源文件下会产生一个rebel.xml配置文件，文件的功能基本同HotCode2的workspace.xml，用于指定target/classes的dir路径，当文件有更新时JRebel会自动将其映射到工作区。</p> 
<h4 id="28">6.1.5 验证</h4> 
<p></p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552880886266-eac0ebd9-58a6-4eab-a47c-034b04f679e5.png" rel="nofollow"><img alt="image.png | left | 545x270" height="644" src="https://images2.imgbox.com/9b/1d/6r9ToQfV_o.png" width="1200"></a></p> 
<p>点击保存之后，可以在控制台看到JRebel打印的Reloading日志，说明新加的方法已经生效</p> 
<p></p> 
<p class="img-center"><a href="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/76794/1552880841438-21420ba6-62ac-42ae-905f-7fa7e0b6f234.png" rel="nofollow"><img alt="image.png | left | 553x144" height="304" src="https://images2.imgbox.com/99/2a/qABvzA8C_o.png" width="1168"></a></p> 
<h2 id="29">7 总结</h2> 
<p><strong>有了热部署不仅能大幅度节省重启项目的时间，而且能够在编程时避免中断思路，将更多的时间用于Coding和思考问题。</strong><br> 本文主要是基于本地开发的维度进行演示说明，具体使用哪一种各位可根据自己开发中实际情况进行自由选择，当然个人还是比较优先推荐JRebel，稳定好用省心，其次是HotCode2，如果原生的SpringBoot类(PandoraBoot不支持)的项目可以使用Spring-boot-devtools或者Spring-loaded尝尝鲜，最后支持工程热部署方式最少的但也是最方便的就是HotSwap，各个IDE工具基本都已集成开启即可使用。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/28807051eea3d9d8b2ef489fe5ae29ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js排序常用算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6bfb2fd7cce36e9c245cf3c3e8648964/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">自定义security的权限验实现 @EnableGlobalMethodSecurity(prePostEnabled = true)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>