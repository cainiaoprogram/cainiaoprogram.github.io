<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go 并发控制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go 并发控制" />
<meta property="og:description" content="前言 提到Go语言的并发，就不得不提goroutine，其作为Go语言的一大特色，在日常开发中使用很多。
在日常应用场景就会涉及一个goroutine启动或结束，启动一个goroutine很简单只需要在函数前面加关键词go即可，而由于每个goroutine都是独立运行的，其退出有自身决定的，除非main主程序结束或程序崩溃的情况发生。
那么，如何控制goroutine或者说通知goroutine结束运行呢？
解决的方式其实很简单，那就是想办法和goroutine通讯，通知goroutine什么时候结束，goroutine结束也可以通知其他goroutine或main主程序。
并发控制方法主要有： 全局变量
channel
WaitGroup
context
全局变量 这是并发控制最简单的实现方式
1、声明一个全局变量。
2、所有子goroutine共享这个变量，并不断轮询这个变量检查是否有更新；
3、在主进程中变更该全局变量；
4、子goroutine检测到全局变量更新，执行相应的逻辑。
示例
package main import ( &#34;fmt&#34; &#34;time&#34; ) func main() { open := true go func() { for open { println(&#34;goroutineA running&#34;) time.Sleep(1 * time.Second) } println(&#34;goroutineA exit&#34;) }() go func() { for open { println(&#34;goroutineB running&#34;) time.Sleep(1 * time.Second) } println(&#34;goroutineB exit&#34;) }() time.Sleep(2 * time.Second) open = false time.Sleep(2 * time.Second) fmt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5eae664e5b60f56b1a72b6113b54e90e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-19T23:33:55+08:00" />
<meta property="article:modified_time" content="2019-05-19T23:33:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go 并发控制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_1"></a>前言</h3> 
<p>提到Go语言的并发，就不得不提goroutine，其作为Go语言的一大特色，在日常开发中使用很多。</p> 
<p>在日常应用场景就会涉及一个goroutine启动或结束，启动一个goroutine很简单只需要在函数前面加关键词go即可，而由于每个goroutine都是独立运行的，其退出有自身决定的，除非main主程序结束或程序崩溃的情况发生。</p> 
<p>那么，如何控制goroutine或者说通知goroutine结束运行呢？</p> 
<p>解决的方式其实很简单，那就是想办法和goroutine通讯，通知goroutine什么时候结束，goroutine结束也可以通知其他goroutine或main主程序。</p> 
<h3><a id="_11"></a>并发控制方法主要有：</h3> 
<p>全局变量</p> 
<p>channel</p> 
<p>WaitGroup</p> 
<p>context</p> 
<h3><a id="_21"></a>全局变量</h3> 
<p>这是并发控制最简单的实现方式</p> 
<p>1、声明一个全局变量。</p> 
<p>2、所有子goroutine共享这个变量，并不断轮询这个变量检查是否有更新；</p> 
<p>3、在主进程中变更该全局变量；</p> 
<p>4、子goroutine检测到全局变量更新，执行相应的逻辑。</p> 
<p>示例</p> 
<pre><code>package main

import (
   "fmt"
   "time"
)

func main() {
   open := true
   go func() {
      for open {
         println("goroutineA running")
         time.Sleep(1 * time.Second)
      }
      println("goroutineA exit")
   }()
   go func() {
      for open {
         println("goroutineB running")
         time.Sleep(1 * time.Second)
      }
      println("goroutineB exit")
   }()
   time.Sleep(2 * time.Second)
   open = false
   time.Sleep(2 * time.Second)
   fmt.Println("main fun exit")
}
</code></pre> 
<p>输出</p> 
<p>goroutineA running<br> goroutineB running<br> goroutineA running<br> goroutineB running<br> goroutineB running<br> goroutineA exit<br> goroutineB exit<br> main fun exit</p> 
<p>这种实现方式</p> 
<p>优点：实现简单。</p> 
<p>缺点：适用一些逻辑简单的场景，全局变量的信息量比较少，为了防止不同goroutine同时修改变量需要用到加锁来解决。</p> 
<h3><a id="channel_83"></a>channel</h3> 
<p>channel是goroutine之间主要的通讯方式，一般会和select搭配使用。</p> 
<p>如想了解channel实现原理可参考</p> 
<p><a href="https://github.com/guyan0319/golang_development_notes/blob/master/zh/9.9.md">https://github.com/guyan0319/golang_development_notes/blob/master/zh/9.9.md</a></p> 
<p>1、声明一个<code>stop</code>的chan。</p> 
<p>2、在goroutine中，使用select判断<code>stop</code>是否可以接收到值，如果可以接收到，就表示可以退出停止了；如果没有接收到，就会执行<code>default</code>里逻辑。直到收到<code>stop</code>的通知。</p> 
<p>3、主程序发送了<code>stop&lt;- true</code>结束的指令后。</p> 
<p>4、子goroutine接到结束指令case &lt;-stop退出return。</p> 
<p>示例</p> 
<pre><code>package main

import (
   "fmt"
   "time"
)

func main() {
   stop := make(chan bool)
   go func() {
      for {
         select {
         case &lt;-stop:
            fmt.Println("goroutine exit")
            return
         default:
            fmt.Println("goroutine running")
            time.Sleep(1 * time.Second)
         }
      }
   }()
   time.Sleep(2 * time.Second)
   stop &lt;- true
   time.Sleep(2 * time.Second)
   fmt.Println("main fun exit")
}
</code></pre> 
<p>输出</p> 
<p>goroutine running<br> goroutine running<br> goroutine running<br> goroutine exit<br> main fun exit</p> 
<p>这种select+chan是一种比较优雅的并发控制方式，但也有局限性，如多个goroutine 需要结束，以及嵌套goroutine 的场景。</p> 
<h3><a id="WaitGroup_140"></a>WaitGroup</h3> 
<p>Go语言提供同步包（sync），源码（src/sync/waitgroup.go）。</p> 
<p>Sync包同步提供基本的同步原语，如互斥锁。除了Once和WaitGroup类型之外，大多数类型都是供低级库例程使用的。通过Channel和沟通可以更好地完成更高级别的同步。并且此包中的值在使用过后不要拷贝。</p> 
<p>Sync.WaitGroup是一种实现并发控制方式，<code>WaitGroup</code> 对象内部有一个计数器，最初从0开始，它有三个方法：<code>Add(), Done(), Wait()</code> 用来控制计数器的数量。</p> 
<ul><li><code>Add(n)</code> 把计数器设置为<code>n</code> 。</li><li><code>Done()</code> 每次把计数器<code>-1</code> 。</li><li><code>wait()</code> 会阻塞代码的运行，直到计数器地值减为0。</li></ul> 
<p>示例</p> 
<pre><code>package main

import (
   "fmt"
   "sync"
   "time"
)

func main() {
   //定义一个WaitGroup
   var wg sync.WaitGroup
   //计数器设置为2
   wg.Add(2)
   go func() {
      time.Sleep(2 * time.Second)
      fmt.Println("goroutineA finish")
      //计数器减1
      wg.Done()
   }()
   go func() {
      time.Sleep(2 * time.Second)
      fmt.Println("goroutineB finish")
      //计数器减1
      wg.Done()
   }()
   //会阻塞代码的运行，直到计数器地值减为0。
   wg.Wait()
   time.Sleep(2 * time.Second)
   fmt.Println("main fun exit")
}
</code></pre> 
<p>这种控制并发的方式适用于，好多个goroutine协同做一件事情的时候，因为每个goroutine做的都是这件事情的一部分，只有全部的goroutine都完成，这件事情才算是完成，这是等待的方式。WaitGroup相对于channel并发控制方式比较轻巧。</p> 
<p>注意：</p> 
<p>1、计数器不能为负值</p> 
<p>2、WaitGroup对象不是一个引用类型</p> 
<h3><a id="Context_194"></a>Context</h3> 
<p>应用场景：在 Go http 包的 Server 中，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine。所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的Context，称之为上下文。</p> 
<p>控制并发的实现方式：</p> 
<p>1、 context.Background():返回一个空的Context，这个空的Context一般用于整个Context树的根节点。</p> 
<p>2、context.WithCancel(context.Background())，创建一个可取消的子Context，然后当作参数传给goroutine使用，这样就可以使用这个子Context跟踪这个goroutine。</p> 
<p>3、在goroutine中，使用select调用<code>&lt;-ctx.Done()</code>判断是否要结束，如果接收到值的话，就可以返回结束goroutine了；如果接收不到，就会继续进行监控。</p> 
<p>4、cancel()，取消函数（context.WithCancel（）返回的第二个参数，名字和声明的名字一致）。作用是给goroutine发送结束指令。</p> 
<p>示例：</p> 
<pre><code>package main

import (
   "fmt"
   "time"
   "golang.org/x/net/context"
)

func main() {
   //创建一个可取消子context,context.Background():返回一个空的Context，这个空的Context一般用于整个Context树的根节点。
   ctx, cancel := context.WithCancel(context.Background())
   go func(ctx context.Context) {
      for {
         select {
         //使用select调用&lt;-ctx.Done()判断是否要结束
         case &lt;-ctx.Done():
            fmt.Println("goroutine exit")
            return
         default:
            fmt.Println("goroutine running.")
            time.Sleep(2 * time.Second)
         }
      }
   }(ctx)

   time.Sleep(10 * time.Second)
   fmt.Println("main fun exit")
   //取消context
   cancel()
   time.Sleep(5 * time.Second)

}
</code></pre> 
<p>输出：</p> 
<p>goroutine running.<br> goroutine running.<br> goroutine running.<br> goroutine running.<br> goroutine running.<br> main fun exit<br> goroutine exit</p> 
<p>如果想控制多个goroutine ，也很简单。</p> 
<p>示例</p> 
<pre><code>package main

import (
   "fmt"
   "time"
   "golang.org/x/net/context"
)

func main() {
   //创建一个可取消子context,context.Background():返回一个空的Context，这个空的Context一般用于整个Context树的根节点。
   ctx, cancel := context.WithCancel(context.Background())
   ctxTwo, cancelTwo := context.WithCancel(context.Background())
   go func(ctx context.Context) {
      for {
         select {
         //使用select调用&lt;-ctx.Done()判断是否要结束
         case &lt;-ctx.Done():
            fmt.Println("goroutineA exit")
            return
         default:
            fmt.Println("goroutineA running.")
            time.Sleep(2 * time.Second)
         }
      }
   }(ctx)
   go func(ctx context.Context) {
      for {
         select {
         //使用select调用&lt;-ctx.Done()判断是否要结束
         case &lt;-ctx.Done():
            fmt.Println("goroutineB exit")
            return
         default:
            fmt.Println("goroutineB running.")
            time.Sleep(2 * time.Second)
         }
      }
   }(ctx)
   go func(ctxTwo context.Context) {
      for {
         select {
         //使用select调用&lt;-ctx.Done()判断是否要结束
         case &lt;-ctxTwo.Done():
            fmt.Println("goroutineC exit")
            return
         default:
            fmt.Println("goroutineC running.")
            time.Sleep(2 * time.Second)
         }
      }
   }(ctxTwo)

   time.Sleep(4 * time.Second)
   fmt.Println("main fun exit")
   //取消context
   cancel()
   cancelTwo()
   time.Sleep(5 * time.Second)

}
</code></pre> 
<p>结果：</p> 
<p>goroutineA running.<br> goroutineB running.<br> goroutineC running.<br> goroutineB running.<br> goroutineC running.<br> goroutineA running.<br> goroutineC running.<br> goroutineA running.<br> goroutineB running.<br> main fun exit<br> goroutineC exit<br> goroutineA exit<br> goroutineB exit</p> 
<p>context还适用于更复杂的场景，如主动取消goroutine或goroutine定时取消等。context接口除了func WithCancel(parent Context) (ctx Context, cancel CancelFunc)，还有衍生以下方法</p> 
<ul><li> <p>func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)：<br> 此函数返回其父项的派生 context，当截止日期超过或取消函数被调用时，该 context 将被取消。例如，您可以创建一个将在以后的某个时间自动取消的 context，并在子函数中传递它。当因为截止日期耗尽而取消该 context 时，获此 context 的所有函数都会收到通知去停止运行并返回。</p> </li><li> <p>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)：</p> <p>此函数类似于 context.WithDeadline。不同之处在于它将持续时间作为参数输入而不是时间对象。此函数返回派生 context，如果调用取消函数或超出超时持续时间，则会取消该派生 context。</p> </li><li> <p>func WithValue(parent Context, key, val interface{}) Context：</p> <p>此函数接收 context 并返回派生 context，其中值 val 与 key 关联，并通过 context 树与 context 一起传递。这意味着一旦获得带有值的 context，从中派生的任何 context 都会获得此值。不建议使用 context 值传递关键参数，而是函数应接收签名中的那些值，使其显式化。</p> </li></ul> 
<p>有兴趣的同学请阅读：<a href="https://studygolang.com/pkgdoc" rel="nofollow">https://studygolang.com/pkgdoc</a></p> 
<h3><a id="_353"></a>参考：</h3> 
<p><a href="https://tutorialedge.net/golang/go-waitgroup-tutorial/" rel="nofollow">https://tutorialedge.net/golang/go-waitgroup-tutorial/</a></p> 
<p><a href="http://goinbigdata.com/golang-wait-for-all-goroutines-to-finish/" rel="nofollow">http://goinbigdata.com/golang-wait-for-all-goroutines-to-finish/</a></p> 
<p><a href="https://medium.com/code-zen/concurrency-in-go-5fcba11acb0f" rel="nofollow">https://medium.com/code-zen/concurrency-in-go-5fcba11acb0f</a></p> 
<p><a href="https://blog.csdn.net/u013029603/article/details/81232395">https://blog.csdn.net/u013029603/article/details/81232395</a></p> 
<h3><a id="links_364"></a>links</h3> 
<ul><li><a href="https://github.com/guyan0319/golang_development_notes/blob/master/zh/preface.md">目录</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/48f46fc09f8aced50ab564a9ebb9d3bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTML/CSS自制网页</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/55310e3d3d3dee5920e38ebc5f90e256/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python 列表推导式if或者多个if_else判断多种情况的列表推导式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>