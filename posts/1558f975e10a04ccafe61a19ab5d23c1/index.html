<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go语言使用protobuf快速入门 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go语言使用protobuf快速入门" />
<meta property="og:description" content="前言 protobuf 即 Protocol Buffers，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。
protobuf 性能和效率大幅度优于 JSON、XML 等其他的结构化数据格式。
protobuf 是以二进制方式存储的，占用空间小，但也带来了可读性差的缺点。protobuf 在通信协议和数据存储等领域应用广泛。
Protobuf 在 .proto 定义需要处理的结构化数据，可以通过 protoc 工具，将 .proto 文件转换为 C、C&#43;&#43;、Golang、Java、Python 等多种语言的代码，兼容性好，易于使用。
参考文献 本文文章持续更新于：https://github.com/mailjobblog/dev_go/tree/master/220115_protobuf
protobuf3 官方文档：https://link.jianshu.com/?t=https://developers.google.com/protocol-buffers/docs/proto3
Protocol Buffer 编码：https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-cn#packed
proto service grpc 生成插件：https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md
本文代码下载：https://github.com/mailjobblog/dev_go/tree/master/220115_protobuf
安装 安装 protoc
从 Protobuf Releases 下载最先版本的发布包安装。
brew intall protoc 安装 protoc-gen-go
我们需要在 Golang 中使用 protobuf，还需要安装 protoc-gen-go，这个工具用来将 .proto 文件转换为 Golang 代码。
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest Tips：
这儿有个小小的坑，github.com/golang/protobuf/protoc-gen-go 和 google.golang.org/protobuf/cmd/protoc-gen-go是不同的。
区别在于前者是旧版本，后者是google接管后的新版本，他们之间的API是不同的，也就是说用于生成的命令，以及生成的文件都是不一样的。
检查是否安装成功
$ protoc --version libprotoc 3.19.3 $ protoc-gen-go --version protoc-gen-go v1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1558f975e10a04ccafe61a19ab5d23c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-15T16:01:35+08:00" />
<meta property="article:modified_time" content="2022-01-15T16:01:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go语言使用protobuf快速入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>protobuf 即 Protocol Buffers，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。<br> protobuf 性能和效率大幅度优于 JSON、XML 等其他的结构化数据格式。<br> protobuf 是以二进制方式存储的，占用空间小，但也带来了可读性差的缺点。protobuf 在通信协议和数据存储等领域应用广泛。</p> 
<p>Protobuf 在 <code>.proto</code> 定义需要处理的结构化数据，可以通过 <code>protoc</code> 工具，将 <code>.proto</code> 文件转换为 C、C++、Golang、Java、Python 等多种语言的代码，兼容性好，易于使用。</p> 
<h3><a id="_8"></a>参考文献</h3> 
<blockquote> 
 <p>本文文章持续更新于：<a href="https://github.com/mailjobblog/dev_go/tree/master/220115_protobuf">https://github.com/mailjobblog/dev_go/tree/master/220115_protobuf</a><br> protobuf3 官方文档：https://link.jianshu.com/?t=https://developers.google.com/protocol-buffers/docs/proto3<br> Protocol Buffer 编码：https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-cn#packed<br> proto service grpc 生成插件：https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md<br> 本文代码下载：https://github.com/mailjobblog/dev_go/tree/master/220115_protobuf</p> 
</blockquote> 
<h3><a id="_15"></a>安装</h3> 
<p><strong>安装 protoc</strong><br> 从 <a href="https://github.com/protocolbuffers/protobuf/releases">Protobuf Releases</a> 下载最先版本的发布包安装。</p> 
<pre><code class="prism language-bash">brew intall protoc
</code></pre> 
<p><strong>安装 protoc-gen-go</strong><br> 我们需要在 Golang 中使用 protobuf，还需要安装 protoc-gen-go，这个工具用来将 .proto 文件转换为 Golang 代码。</p> 
<pre><code class="prism language-bash">go <span class="token function">install</span> google.golang.org/protobuf/cmd/protoc-gen-go@latest
</code></pre> 
<p>Tips：<br> 这儿有个小小的坑，<code>github.com/golang/protobuf/protoc-gen-go</code> 和 <code>google.golang.org/protobuf/cmd/protoc-gen-go</code>是不同的。<br> 区别在于前者是旧版本，后者是google接管后的新版本，他们之间的API是不同的，也就是说用于生成的命令，以及生成的文件都是不一样的。</p> 
<p><strong>检查是否安装成功</strong></p> 
<pre><code class="prism language-bash">$ protoc --version
libprotoc <span class="token number">3.19</span>.3

$ protoc-gen-go --version
protoc-gen-go v1.27.1
</code></pre> 
<h3><a id="protobuf_44"></a>protobuf生成代码</h3> 
<h4><a id="_46"></a>快速上手</h4> 
<p>接下来，我们创建一个非常简单的示例，<code>student.proto</code></p> 
<pre><code class="prism language-protobuf">syntax = "proto3";
package main;

// this is a comment
message Student {
  string name = 1;
  bool male = 2;
  repeated int32 scores = 3;
}
</code></pre> 
<p>在当前目录下执行代码生成命令</p> 
<pre><code class="prism language-bash">$ protoc --go_out<span class="token operator">=</span>. *.proto

$ <span class="token function">ls</span>
student.pb.go  student.proto
</code></pre> 
<p>执行此生成命令是将该目录下的所有的 .proto 文件转换为 Go 代码，我们可以看到该目录下多出了一个 Go 文件 <code>student.pb.go</code>。这个文件内部定义了一个结构体 Student，以及相关的方法：</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> Student <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	state         protoimpl<span class="token punctuation">.</span>MessageState
	sizeCache     protoimpl<span class="token punctuation">.</span>SizeCache
	unknownFields protoimpl<span class="token punctuation">.</span>UnknownFields

	Name   <span class="token builtin">string</span>  <span class="token string">`protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`</span>
	Male   <span class="token builtin">bool</span>    <span class="token string">`protobuf:"varint,2,opt,name=male,proto3" json:"male,omitempty"`</span>
	Scores <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int32</span> <span class="token string">`protobuf:"varint,3,rep,packed,name=scores,proto3" json:"scores,omitempty"`</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>得到生成的 <code>student.pb.go</code> 文件后，可以在项目代码中直接使用了。<br> 以下是一个例子，即证明被序列化的和反序列化后的实例，包含相同的数据。</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	test <span class="token operator">:=</span> <span class="token operator">&amp;</span>Student<span class="token punctuation">{<!-- --></span>
		Name<span class="token punctuation">:</span> <span class="token string">"geektutu"</span><span class="token punctuation">,</span>
		Male<span class="token punctuation">:</span>  <span class="token boolean">true</span><span class="token punctuation">,</span>
		Scores<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int32</span><span class="token punctuation">{<!-- --></span><span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	data<span class="token punctuation">,</span> err <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"marshaling error: "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	newTest <span class="token operator">:=</span> <span class="token operator">&amp;</span>Student<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	err <span class="token operator">=</span> proto<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> newTest<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"unmarshaling error: "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Now test and newTest contain the same data.</span>
	<span class="token keyword">if</span> test<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> newTest<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"data mismatch %q != %q"</span><span class="token punctuation">,</span> test<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newTest<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="Enumerations_104"></a>枚举(Enumerations)</h4> 
<p>枚举类型适用于提供一组预定义的值，选择其中一个。例如我们将性别(gender)定义为枚举类型。</p> 
<pre><code class="prism language-protobuf">message StudentEnum {
  string name = 1;
  enum Gender {
    FEMALE = 0;
    MALE = 1;
  }
  Gender gender = 2;
  repeated int32 scores = 3;
}
</code></pre> 
<p>生成的Go代码主要信息如下：</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> StudentEnum_Gender <span class="token builtin">int32</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
	StudentEnum_FEMALE StudentEnum_Gender <span class="token operator">=</span> <span class="token number">0</span>
	StudentEnum_MALE   StudentEnum_Gender <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> StudentEnum <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    state         protoimpl<span class="token punctuation">.</span>MessageState
    sizeCache     protoimpl<span class="token punctuation">.</span>SizeCache
    unknownFields protoimpl<span class="token punctuation">.</span>UnknownFields
    
    Name   <span class="token builtin">string</span>             <span class="token string">`protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`</span>
    Gender StudentEnum_Gender <span class="token string">`protobuf:"varint,2,opt,name=gender,proto3,enum=main.StudentEnum_Gender" json:"gender,omitempty"`</span>
    Scores <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int32</span>            <span class="token string">`protobuf:"varint,3,rep,packed,name=scores,proto3" json:"scores,omitempty"`</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>枚举类型的第一个选项的标识符<code>必须是0</code>，这也是枚举类型的默认值。</p> 
<h4><a id="Alias_138"></a>别名（Alias）</h4> 
<p>允许为不同的枚举值赋予相同的标识符，称之为别名，需要打开allow_alias选项。</p> 
<pre><code class="prism language-protobuf">message StudentAlias {
  enum Status {
    option allow_alias = true;
    UNKOWN = 0;
    STARTED = 1;
    RUNNING = 1;
  }
}
</code></pre> 
<p>生成的Go语言主要代码如下：</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> StudentAlias_Status <span class="token builtin">int32</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
	StudentAlias_UNKOWN  StudentAlias_Status <span class="token operator">=</span> <span class="token number">0</span>
	StudentAlias_STARTED StudentAlias_Status <span class="token operator">=</span> <span class="token number">1</span>
	StudentAlias_RUNNING StudentAlias_Status <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_161"></a>使用其他消息类型</h4> 
<p>Result是另一个消息类型，在 SearchReponse 作为一个消息字段类型使用。</p> 
<pre><code class="prism language-protobuf">message StudentResponse {
  repeated Result results = 1;
}

message Result {
  string url = 1;
  string title = 2;
  repeated string snippets = 3;
}
</code></pre> 
<p>嵌套写也是支持的：</p> 
<pre><code class="prism language-protobuf">message Student2Response {
  message Result2 {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
  }
  repeated Result2 results2 = 1;
}
</code></pre> 
<p>如果定义在其他文件中，可以导入其他消息类型来使用：</p> 
<pre><code class="prism language-protobuf">import "myproject/other_protos.proto";
</code></pre> 
<h4><a id="Any_190"></a>任意类型(Any)</h4> 
<p>在使用 GRPC 时，常规的操作是将 message 定义好后进行数据传输，但总会遇到某些数据结构进行组合的操作，采用默认的定义 message 方式，造成代码量的激增。<br> 为了解决这个问题 protobuf 提供类型 any 解决 GRPC 中泛型的处理方式</p> 
<pre><code class="prism language-protobuf">message StudentAny {
  string message = 1;
  repeated google.protobuf.Any details = 2;
}
</code></pre> 
<p>生成的Go语言主要代码如下：</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> StudentAny <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	state         protoimpl<span class="token punctuation">.</span>MessageState
	sizeCache     protoimpl<span class="token punctuation">.</span>SizeCache
	unknownFields protoimpl<span class="token punctuation">.</span>UnknownFields

	Message <span class="token builtin">string</span>       <span class="token string">`protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`</span>
	Details <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>anypb<span class="token punctuation">.</span>Any <span class="token string">`protobuf:"bytes,2,rep,name=details,proto3" json:"details,omitempty"`</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="oneof_211"></a>oneof</h4> 
<p>如果你的消息中有很多可选字段， 并且同时至多一个字段会被设置， 你可以加强这个行为，使用oneof特性节省内存。<br> Oneof字段就像可选字段， 除了它们会共享内存， 至多一个字段会被设置。 设置其中一个字段会清除其它字段。</p> 
<pre><code class="prism language-protobuf">message StudentOneOf {
  oneof test_oneof {
    string name = 4;
    SubMessage sub_message = 9;
  }
}
</code></pre> 
<p><strong>oneof的特性</strong></p> 
<ul><li>设置oneof会自动清楚其它oneof字段的值. 所以设置多次后，只有最后一次设置的字段有值</li><li>如果解析器遇到同一个oneof中有多个成员，只有最后一个会被解析成消息</li><li>oneof不支持repeated</li></ul> 
<h4><a id="map_227"></a>map</h4> 
<pre><code class="prism language-protobuf">message StudentMap {
  map&lt;string, int32&gt; points = 1;
}
</code></pre> 
<h4><a id="Services_234"></a>定义服务(Services)</h4> 
<p>如果消息类型是用来远程通信的(Remote Procedure Call, RPC)，可以在 .proto 文件中定义 RPC 服务接口。<br> 例如我们定义了一个名为 SearchService 的 RPC 服务，提供了 Search 接口，入参是 SearchRequest 类型，返回类型是 SearchResponse</p> 
<pre><code class="prism language-protobuf">service SearchService {
  rpc Search (SearchRequest) returns (SearchResponse);
}
</code></pre> 
<p>官方仓库也提供了一个 <a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">插件列表</a>，帮助开发基于 Protocol Buffer 的 RPC 服务。</p> 
<p><strong>生成go代码和grpc代码：</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># 由proto生成go代码</span>
protoc --go_out<span class="token operator">=</span>. *.proto

<span class="token comment"># 由proto生成go的grpc代码</span>
protoc --go-grpc_out<span class="token operator">=</span>. *.proto
</code></pre> 
<h4><a id="protoc__253"></a>protoc 命令参数</h4> 
<pre><code class="prism language-bash">protoc --proto_path<span class="token operator">=</span>IMPORT_PATH --<span class="token operator">&lt;</span>lang<span class="token operator">&gt;</span>_out<span class="token operator">=</span>DST_DIR path/to/file.proto
</code></pre> 
<p><strong>–proto_path=IMPORT_PATH：</strong> 可以在 .proto 文件中 import 其他的 .proto 文件，proto_path 即用来指定其他 .proto 文件的查找目录。如果没有引入其他的 .proto 文件，该参数可以省略。<br> <strong>–_out=DST_DIR：</strong> 指定生成代码的目标文件夹，例如 <code>–go_out=.</code> 即生成 GO 代码在当前文件夹，另外支持 cpp/java/python/ruby/objc/csharp/php 等语言</p> 
<h4><a id="_260"></a>推荐风格</h4> 
<h5><a id="Files_262"></a>文件(Files)</h5> 
<ul><li>文件名使用小写下划线的命名风格，例如 lower_snake_case.proto</li><li>每行不超过 80 字符</li><li>使用 2 个空格缩进</li></ul> 
<h5><a id="Packages_267"></a>包(Packages)</h5> 
<ul><li>包名应该和目录结构对应，例如文件在my/package/目录下，包名应为 my.package</li></ul> 
<h5><a id="Messages__Fields_270"></a>消息和字段(Messages &amp; Fields)</h5> 
<ul><li>消息名使用首字母大写驼峰风格(CamelCase)，例如message StudentRequest { … }</li><li>字段名使用小写下划线的风格，例如 string status_code = 1</li><li>枚举类型，枚举名使用首字母大写驼峰风格，例如 enum FooBar，枚举值使用全大写下划线隔开的风格(CAPITALS_WITH_UNDERSCORES )，例如 FOO_DEFAULT=1</li></ul> 
<h5><a id="Services_275"></a>服务(Services)</h5> 
<ul><li>RPC 服务名和方法名，均使用首字母大写驼峰风格，例如service FooService{ rpc GetSomething() }</li></ul> 
<h3><a id="protobuf_279"></a>protobuf文件规范</h3> 
<h4><a id="syntax_281"></a>syntax</h4> 
<p>protobuf 有2个版本，默认版本是 proto2，如果需要 proto3，则需要在非空非注释第一行使用 <code>syntax = "proto3"</code> 标明版本。</p> 
<h4><a id="package_284"></a>package</h4> 
<p>package，即包名声明符是可选的，用来防止不同的消息类型有命名冲突。</p> 
<h4><a id="option_go_package_287"></a>option go_package</h4> 
<pre><code class="prism language-protobuf">option go_package="./proto/pb;pb";
</code></pre> 
<p>这部分的内容是关于最后生成的go文件是处在哪个目录哪个包中，<code>./proto/pb</code> 代表在当前目录生成，<code>pb</code> 代表了生成的go文件的包名是 pb。</p> 
<h4><a id="message_293"></a>message</h4> 
<p>消息类型 使用 message 关键字定义，Student 是类型名，name, male, scores 是该类型的 3 个字段，类型分别为 string, bool 和 []int32。字段可以是标量类型，也可以是合成类型。<br> 相当于Go语言中的 struct 结构体。一个 .proto 文件中可以写多个消息类型，即对应多个结构体(struct)。</p> 
<h4><a id="_297"></a>修饰符</h4> 
<p>每个字段的修饰符默认是 <code>singular</code>，一般省略不写，<code>repeated</code> 表示字段可重复，即用来表示 Go 语言中的切片类型。</p> 
<h4><a id="_300"></a>标识符</h4> 
<p>每个字符 = 后面的数字称为标识符，每个字段都需要提供一个唯一的标识符。标识符用来在消息的二进制格式中识别各个字段，一旦使用就不能够再改变，标识符的取值范围为 [1, 2^29 - 1] 。</p> 
<h4><a id="_303"></a>文件注释</h4> 
<p>.proto 文件可以写注释，单行注释 //，多行注释 /* … */</p> 
<h4><a id="Scalar_306"></a>标量类型(Scalar)</h4> 
<table><thead><tr><th align="left">.proto Type</th><th align="left">Notes</th><th align="left">C++ Type</th><th align="left">Java Type</th><th align="left">Python Type[2]</th><th align="left">Go Type</th><th align="left">Ruby Type</th><th align="left">C# Type</th><th align="left">PHP Type</th></tr></thead><tbody><tr><td align="left">double</td><td align="left"></td><td align="left">double</td><td align="left">double</td><td align="left">float</td><td align="left">float64</td><td align="left">Float</td><td align="left">double</td><td align="left">float</td></tr><tr><td align="left">float</td><td align="left"></td><td align="left">float</td><td align="left">float</td><td align="left">float</td><td align="left">float32</td><td align="left">Float</td><td align="left">float</td><td align="left">float</td></tr><tr><td align="left">int32</td><td align="left">使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">Fixnum 或者 Bignum（根据需要）</td><td align="left">int</td><td align="left">integer</td></tr><tr><td align="left">uint32</td><td align="left">使用变长编码</td><td align="left">uint32</td><td align="left">int</td><td align="left">int/long</td><td align="left">uint32</td><td align="left">Fixnum 或者 Bignum（根据需要）</td><td align="left">uint</td><td align="left">integer</td></tr><tr><td align="left">uint64</td><td align="left">使用变长编码</td><td align="left">uint64</td><td align="left">long</td><td align="left">int/long</td><td align="left">uint64</td><td align="left">Bignum</td><td align="left">ulong</td><td align="left">integer/string</td></tr><tr><td align="left">sint32</td><td align="left">使用变长编码，这些编码在负值时比int32高效的多</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">Fixnum 或者 Bignum（根据需要）</td><td align="left">int</td><td align="left">integer</td></tr><tr><td align="left">sint64</td><td align="left">使用变长编码，有符号的整型值。编码时比通常的int64高效。</td><td align="left">int64</td><td align="left">long</td><td align="left">int/long</td><td align="left">int64</td><td align="left">Bignum</td><td align="left">long</td><td align="left">integer/string</td></tr><tr><td align="left">fixed32</td><td align="left">总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。</td><td align="left">uint32</td><td align="left">int</td><td align="left">int</td><td align="left">uint32</td><td align="left">Fixnum 或者 Bignum（根据需要）</td><td align="left">uint</td><td align="left">integer</td></tr><tr><td align="left">fixed64</td><td align="left">总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。</td><td align="left">uint64</td><td align="left">long</td><td align="left">int/long</td><td align="left">uint64</td><td align="left">Bignum</td><td align="left">ulong</td><td align="left">integer/string</td></tr><tr><td align="left">sfixed32</td><td align="left">总是4个字节</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">Fixnum 或者 Bignum（根据需要）</td><td align="left">int</td><td align="left">integer</td></tr><tr><td align="left">sfixed64</td><td align="left">总是8个字节</td><td align="left">int64</td><td align="left">long</td><td align="left">int/long</td><td align="left">int64</td><td align="left">Bignum</td><td align="left">long</td><td align="left">integer/string</td></tr><tr><td align="left">bool</td><td align="left"></td><td align="left">bool</td><td align="left">boolean</td><td align="left">bool</td><td align="left">bool</td><td align="left">TrueClass/FalseClass</td><td align="left">bool</td><td align="left">boolean</td></tr><tr><td align="left">string</td><td align="left">一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td><td align="left">string</td><td align="left">String</td><td align="left">str/unicode</td><td align="left">string</td><td align="left">String (UTF-8)</td><td align="left">string</td><td align="left">string</td></tr><tr><td align="left">bytes</td><td align="left">可能包含任意顺序的字节数据。</td><td align="left">string</td><td align="left">ByteString</td><td align="left">str</td><td align="left">[]byte</td><td align="left">String (ASCII-8BIT)</td><td align="left">ByteString</td><td align="left">string</td></tr></tbody></table> 
<p><strong>标量类型如果没有被赋值，则不会被序列化，解析时，会赋予默认值</strong></p> 
<ul><li>strings：空字符串</li><li>bytes：空序列</li><li>bools：false</li><li>数值类型：0</li></ul> 
<h3><a id="_332"></a>常见问题</h3> 
<h4><a id="go_package_334"></a>go_package报错</h4> 
<pre><code class="prism language-text">Please specify either:
• a "go_package" option in the .proto source file, or
• a "M" argument on the command line.
</code></pre> 
<p>在go的1.14版本以后，proto文件中不添加go_package 会报错。<br> 解决方法： option go_package = “./”<br> 或者填写自己的包路径也行如option go_package = “http://github.com/package/name”</p> 
<h4><a id="protocgengo_345"></a>安装protoc-gen-go报错</h4> 
<pre><code class="prism language-text">can't load package: package google.golang.org/protobuf/cmd/protoc-gen-go: cannot find package "google.golang.org/protobuf/cmd/protoc-gen-go" in any of:
        C:\Go\src\google.golang.org\protobuf\cmd\protoc-gen-go (from $GOROOT)
        C:\Users\peikai\go\src\google.golang.org\protobuf\cmd\protoc-gen-go (from $GOPATH)
</code></pre> 
<p>解决方法：<br> 先 <code>go get google.golang.org/protobuf/cmd/protoc-gen-go</code> 然后再 <code>install</code> 安装。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/80e35508a2401270684e661eccb8602b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决Spring boot : java.lang.ExceptionInInitializerError报错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce06cb4abc2251aac03f7c3da71f721f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SSL: CERTIFICATE_VERIFY_FAILED</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>