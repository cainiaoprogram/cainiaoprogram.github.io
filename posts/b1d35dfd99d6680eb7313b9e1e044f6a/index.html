<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>socket编程中的EINTR是什么? - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="socket编程中的EINTR是什么?" />
<meta property="og:description" content="socket编程中的EINTR是什么? 在socket编程中，我们时常在accept/read/write等接口调用的异常处理的部分看到对于EINTR的处理，例如下面这样的语句：
repeat: if(read(fd, buff, size) &lt; 0) { if(errno == EINTR) goto repeat; else printf(&#34;read failed&#34;); } 那么EINTR是什么呢？为什么要对它进行处理呢？ 本文将对EINTR做一些讨论。
慢系统调用 如果想要解释EINTR，首先得对慢系统调用有个了解。
慢系统调用(slow system call)指不会立即返回的系统调用, 可能永远阻塞而无法返回。 例如支持网络的调用, 包括read/write, connect, accept等, 都属于这一类。
慢系统调用, 主要分为以下类别:
读写&#34;慢&#34;设备。 包括pipe, fifo, 终端设备, 网络连接等. 读时, 数据不存在, 需要等待缓冲区有数据输入; 写时, 缓冲区满, 需要等待缓冲区有空闲位置。注意: 读写磁盘文件一般不会阻塞， 网络磁盘除外。打开某些特殊文件时, 需要等待某些条件才能打开。如打开终端设备, 需要等待连接设备的modern响应, 才能打开pause和wait系统调用。 pause阻塞进程, 直到收到信号唤醒;wait等待任意子进程终止; 某些ioctl操作某些IPC操作。如pipe, fifo, 没有指定NON_BLOCKING选项时的写操作, 如果管道缓冲区满, write阻塞;互斥锁, 条件变量, 信号量, 记录锁等等. 慢系统调用与EINTR 如果进程在一个慢系统调用(slow system call)中阻塞时，当捕获到某个信号且相应信号处理函数返回时，这个系统调用被中断，调用返回错误，设置errno为EINTR（相应的错误描述为&#34;Interrupted system call&#34;）。
因此EINTR错误的产生是慢系统调用和信号处理函数组合使用会产生的问题。
回过头来再看开头所提到的这一段的代码，其含义是当程序通过read读取数据，当目前fd对应的缓冲区没有数据可读时，进程将被阻塞。此时如果向该进程发送了信号，那么read函数将会返回-1，并且此时errno为EINTR，代表read方法被中断了。对于这样的情况，我们就需要人为的对read进行&#34;重启&#34;， 即重新的进行read。
repeat: if(read(fd, buff, size) &lt; 0) { if(errno == EINTR) goto repeat; else printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b1d35dfd99d6680eb7313b9e1e044f6a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-06T15:25:21+08:00" />
<meta property="article:modified_time" content="2023-11-06T15:25:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">socket编程中的EINTR是什么?</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="socketEINTR_0"></a>socket编程中的EINTR是什么?</h2> 
<p>在socket编程中，我们时常在accept/read/write等接口调用的异常处理的部分看到对于EINTR的处理，例如下面这样的语句：</p> 
<pre><code class="prism language-cpp">repeat<span class="token operator">:</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么EINTR是什么呢？为什么要对它进行处理呢？ 本文将对EINTR做一些讨论。</p> 
<h3><a id="_17"></a>慢系统调用</h3> 
<p>如果想要解释<strong>EINTR</strong>，首先得对<strong>慢系统调用</strong>有个了解。</p> 
<p><strong>慢系统调用</strong>(slow system call)指不会立即返回的系统调用, 可能<strong>永远阻塞</strong>而无法返回。 例如支持网络的调用, 包括read/write, connect, accept等, 都属于这一类。</p> 
<p>慢系统调用, 主要分为以下类别:</p> 
<ul><li>读写"慢"设备。 包括pipe, fifo, 终端设备, 网络连接等. 读时, 数据不存在, 需要等待缓冲区有数据输入; 写时, 缓冲区满, 需要等待缓冲区有空闲位置。注意: 读写磁盘文件一般不会阻塞， 网络磁盘除外。</li><li>打开某些特殊文件时, 需要等待某些条件才能打开。如打开终端设备, 需要等待连接设备的modern响应, 才能打开</li><li>pause和wait系统调用。 
  <ul><li>pause阻塞进程, 直到收到信号唤醒;</li><li>wait等待任意子进程终止;</li></ul> </li><li>某些ioctl操作</li><li>某些IPC操作。如pipe, fifo, 没有指定NON_BLOCKING选项时的写操作, 如果管道缓冲区满, write阻塞;互斥锁, 条件变量, 信号量, 记录锁等等.</li></ul> 
<h3><a id="EINTR_33"></a>慢系统调用与EINTR</h3> 
<p>如果进程在一个<strong>慢系统调用</strong>(slow system call)中阻塞时，当捕获到某个信号且相应信号处理函数返回时，这个系统调用被中断，调用返回错误，设置errno为EINTR（相应的错误描述为"Interrupted system call"）。</p> 
<p>因此EINTR错误的产生是<strong>慢系统调用</strong>和<strong>信号处理函数</strong>组合使用会产生的问题。</p> 
<p>回过头来再看开头所提到的这一段的代码，其含义是当程序通过read读取数据，当目前fd对应的缓冲区没有数据可读时，进程将被阻塞。此时如果向该进程发送了信号，那么read函数将会返回-1，并且此时errno为EINTR，代表read方法被中断了。对于这样的情况，我们就需要人为的对read进行"重启"， 即重新的进行read。</p> 
<pre><code class="prism language-cpp">repeat<span class="token operator">:</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>到此，我们了解到了EINTR的产生原因，下面将介绍如何处理EINTR，以避免一些不必要的系统问题。</p> 
<h3><a id="EINTR_54"></a>如何避免EINTR带来的问题。</h3> 
<p>既然系统调用会被中断，那么就需要处理被中断的系统调用。</p> 
<ul><li>人为重启被中断的系统调用</li><li>安装信号时设置 SA_RESTART属性（该方法对有的系统调用无效）</li></ul> 
<p>其实人为重启被中断的系统调用，上面已经提到过了</p> 
<pre><code class="prism language-cpp">repeat<span class="token operator">:</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里着重来看一下第二种方法，为信号处理函数设置<code>SA_RESTART</code>。</p> 
<p>下面是一个使用socket编程所建立的一个TCP server，进程在没有连接进入的时候将会卡在accept调用上。 同时，对于该进程，安装了SIGINT的信号处理函数，并且为该信号设置了SA_RESTART的属性。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//g++ main.cpp -o main</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PORT</span> <span class="token expression"><span class="token number">8080</span></span></span>
<span class="token keyword">void</span>  <span class="token function">handler_func</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> server_fd<span class="token punctuation">,</span> new_socket<span class="token punctuation">;</span>
    ssize_t valread<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
    <span class="token keyword">int</span> opt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    socklen_t addrlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> hello <span class="token operator">=</span> <span class="token string">"Hello from server"</span><span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> action<span class="token punctuation">;</span>

    action<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> handler_func<span class="token punctuation">;</span>
    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>action<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    action<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/* 设置SA_RESTART属性 */</span>
    action<span class="token punctuation">.</span>sa_flags <span class="token operator">|=</span> SA_RESTART<span class="token punctuation">;</span>
    <span class="token function">sigaction</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>action<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Creating socket file descriptor</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>server_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"socket failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Forcefully attaching socket to the port 8080</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span>
                            SO_REUSEADDR <span class="token operator">|</span> SO_REUSEPORT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>opt<span class="token punctuation">,</span>
                            <span class="token keyword">sizeof</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"setsockopt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    address<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> INADDR_ANY<span class="token punctuation">;</span>
    address<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Forcefully attaching socket to the port 8080</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span>
                    <span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"bind failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listen</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"listen"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>new_socket
            <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span>
                            <span class="token operator">&amp;</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"accept"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    valread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>new_socket<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span>
                            <span class="token number">1024</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// subtract 1 for the null</span>
                                                    <span class="token comment">// terminator at the end</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">send</span><span class="token punctuation">(</span>new_socket<span class="token punctuation">,</span> hello<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello message sent\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// closing the connected socket</span>
    <span class="token function">close</span><span class="token punctuation">(</span>new_socket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// closing the listening socket</span>
    <span class="token function">close</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>程序运行后，使用ctrl+c 向进程发送SIGINT信号，可以看到程序输出了test的打印，但是程序仍然阻塞在了accept的系统调用上，等待客户端连接。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@localhost test1<span class="token punctuation">]</span><span class="token comment"># ./main</span>
^Ctest
^Ctest
^Ctest
^Ctest
^Ctest
</code></pre> 
<p>如果没有添加SA_RESTART这样的flag， 那么发送SIGINT给进程的话，accept就会报这样的错误，就需要手动进行处理。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@localhost test1<span class="token punctuation">]</span><span class="token comment"># ./main</span>
^Ctest
accept: Interrupted system call
</code></pre> 
<p>但是要注意的是SA_RESTART并不能解决所有的问题。</p> 
<p>下面的这些场景当设置了SA_RESTART后，如果信号处理函数返回之后，系统调用可以自行恢复：</p> 
<ul><li>read/readv/write/writev/ioctl在"慢设备"上的调用。所谓慢设备，就是在该设备上执行I/O调用时可能会造成无限时间的阻塞的一类设备， 例如管道，socket,终端。 需要注意的是，本地磁盘不属于慢设备，但是网络磁盘属于慢设备。</li><li>open， 例如open一个FIFO。</li><li>wait系列的方法，例如：wait(2), wait3(2), wait4(2), waitid(2), and waitpid(2).</li><li>没有设置超时参数的socket的操作接口。 accept(2), connect(2), recv(2), recvfrom(2), recvmmsg(2), recvmsg(2), send(2), sendto(2), and sendmsg(2).</li><li>文件锁接口： flock(2)， fcntl(2)进行F_OFD_SETLKW F_SETLKW操作。</li><li>POSIX消息队列: mq_receive(3), mq_timedreceive(3), mq_send(3), mq_timedsend(3).</li><li>futex(2) FUTEX_WAIT。 2.6.22版本之前， 信号处理函数返回时，futex总是返回EINTR，SA_RESTART无效。</li><li>getrandom(2).</li><li>pthread_mutex_lock(3), pthread_cond_wait(3)</li><li>futex(2) FUTEX_WAIT_BITSET.</li><li>POSIX 信号量的接口 sem_wait(3) and sem_timedwait(3)。 2.6.22版本之前， 信号处理函数返回时，信号量的接口总是返回EINTR，SA_RESTART无效。</li><li>read(2) 方法操作由 inotify(7)方法返回的文件描述符 (3.8版本之前， 信号处理函数返回时，总是返回EINTR，SA_RESTART无效。).</li></ul> 
<p>下面这些场景，即使使用了SA_RESTART，当系统调用被信号处理函数中断后，仍然会返回EINTR：</p> 
<ul><li>设置了超过时间的socket的输入接口。使用setsockopt方法的SO_RCVTIMEO参数可以设置timeout时间。accept(2), recv(2), recvfrom(2)，recvmmsg(2) recvmsg(2).</li><li>设置了超过时间的socket的输出接口。使用setsockopt方法的SO_SNDTIMEO参数可以设置timeout时间。connect(2), send(2), sendto(2), sendmsg(2).</li><li>等待信号的接口，例如: pause(2), sigsuspend(2), sigtimedwait(2), and sigwaitinfo(2).</li><li>多路复用的接口，例如： epoll_wait(2), epoll_pwait(2), poll(2), ppoll(2), select(2), and pselect(2).</li><li>System V的IPC interface， 例如：msgrcv(2), msgsnd(2), semop(2), 和semtimedop(2).</li><li>sleep的接口， 例如: clock_nanosleep(2), nanosleep(2), and usleep(3).</li><li>io_getevents(2).</li></ul> 
<p>还有一个比较特殊的是sleep(3)方法，其被信号处理函数打断后并不会返回返回EINTR， 而是将剩下需要sleep的时间作为返回值返回。</p> 
<p>在整理资料时，我发现Linux man的界面还存在一个描述问题：</p> 
<p><img src="https://images2.imgbox.com/56/ba/zdwlUGh4_o.png" alt="EINTR"></p> 
<p>对于Output socket接口的描述中， <strong>when a timeout (SO_RCVTIMEO) has been set on the socket</strong> 描述并不正确。此时描述的是output相关的接口，因此应该是<strong>when a timeout (SO_SNDTIMEO) has been set on the socket</strong>。 下面的<strong>if a send timeout (SO_SNDTIMEO) has been set</strong>描述正确了，但是感觉又有点重复。</p> 
<p>从上面的描述中我们知道， <strong>SO_RESTART</strong>并不是万能的，对于一些接口而言，仍然需要添加对EINTR的处理。 因此对于EINTR的处理需要组合上面两种方法。</p> 
<h2><a id="_215"></a>总结</h2> 
<ul><li>EINTR错误的产生是<strong>慢系统调用</strong>和<strong>信号处理函数</strong>组合使用会产生的问题。</li><li>对于EINTR错误，安装信号处理函数时设置SA_RESTART可以解决很多系统调用被终端的问题。但是对于一些可以设置超时参数的API，即使设置SA_RESTART，仍然有可能收到EINTR错误。因此组合使用SA_RESTART和人为重启系统调用。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dc5d5f35c6b3ae56ada0684263983246/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PHP 导出 Excel</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dbaf80faa2a066950296dfa8d69b66cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端基于uniapp[uniPush]实现APP消息推送（安卓、IOS）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>