<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HashMap源码-Put详解（HashMap是如何添加元素的） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HashMap源码-Put详解（HashMap是如何添加元素的）" />
<meta property="og:description" content="HashMap是Java中很重要一个部分，内容较多，因此笔者在此将其拆成一个个小块，作为自己学习知识整理的同时，也和广大网友一起讨论。
也因此，在完成系列的学习之前，将以这种小节的形式进行学习分享，并在学习结束后进行整合，排序。
一、HashMap的实际结构 首先，我们必须了解一下HashMap的实际结构：
（图片来自：&#39;是一篇很好的博客，如有时间，希望大家也能花时间在这篇博客中学习一二）https://blog.csdn.net/weixin_39621427/article/details/112096553 如上图所示，HashMap本质是一个数组，其中数组中的每个元素可以指向一套红黑树/一个链表（一定是两种之一）。
在HashMap初始化中，存在一个参数：
树化阈值（TREEIFY_THRESHOLD）：
当数组的节点数超过树化阈（yu，四声）值后 ，会被转化为红黑树的储存结构，可以加快遍历速度。
在源码中，树化阈值被默认设定为8,如下所示：
pubic static final int TREEIFY_THRESHOLD = 8 二、HashMap元素的添加 序 在正常的使用中，我们会这样进行HashMap的初始化和元素的添加：
Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(&#34;a&#34;,1); 其中，.put方法就是HashMap中添加元素的方法，那么让我们看看其源码是如何实现的吧。
public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 在源码中，我们很容易发现，put方法的实现都在putVal方法中，因此，我们对put方法的重点就在putVal方法中。
putVal方法 查询源码，我们可以看到putVal的源码如下，乍看起来内容较多，在笔者的学习过程中，网络上大部分的资料均是直接开始介绍整套代码的作用，对于初学者来说，需要认知的事情太多，学习起来困难，复习起来更是无从下手，因此，笔者在这里就以初学者的角度开始，转换一下学习的方法。
首先，大致看上去，putVal中包含多个if-else结构，因此，如果我们能将每个if的条件判断弄清楚，那么整个putVal的运行逻辑就一清二楚啦。
final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5896034d1628638f2489f518a30213e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-01T22:41:05+08:00" />
<meta property="article:modified_time" content="2021-11-01T22:41:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HashMap源码-Put详解（HashMap是如何添加元素的）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>HashMap是Java中很重要一个部分，内容较多，因此笔者在此将其拆成一个个小块，作为自己学习知识整理的同时，也和广大网友一起讨论。</p> 
<p>也因此，在完成系列的学习之前，将以这种小节的形式进行学习分享，并在学习结束后进行整合，排序。</p> 
<h2>一、HashMap的实际结构</h2> 
<p>首先，我们必须了解一下HashMap的实际结构：</p> 
<p><img alt="bc1237a79ba21a22aa966c87a011a572.png" src="https://images2.imgbox.com/a1/e4/ukhmIh0s_o.png"></p> 
<p></p> 
<p><a class="has-card" href="https://blog.csdn.net/weixin_39621427/article/details/112096553" title="（图片来自：'是一篇很好的博客，如有时间，希望大家也能花时间在这篇博客中学习一二）"><span class="link-card-box"><span class="link-title">（图片来自：'是一篇很好的博客，如有时间，希望大家也能花时间在这篇博客中学习一二）</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/61/b5/NISarxuJ_o.png">https://blog.csdn.net/weixin_39621427/article/details/112096553</span></span></a> 如上图所示，HashMap本质是一个数组，其中数组中的每个元素可以指向一套红黑树/一个链表（一定是两种之一）。</p> 
<p>在HashMap初始化中，存在一个参数：</p> 
<p><strong>树化阈值（TREEIFY_THRESHOLD）：</strong></p> 
<p>        当数组的节点数超过树化阈（yu，四声）值后 ，会被转化为红黑树的储存结构，可以加快遍历速度。</p> 
<p>        在源码中，树化阈值被默认设定为8,如下所示：</p> 
<pre><code class="language-java">pubic static final int TREEIFY_THRESHOLD = 8</code></pre> 
<h2> 二、HashMap元素的添加</h2> 
<h3>序</h3> 
<p>在正常的使用中，我们会这样进行HashMap的初始化和元素的添加：</p> 
<pre><code class="language-java">        Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;();
        map.put("a",1);</code></pre> 
<p>其中，.put方法就是HashMap中添加元素的方法，那么让我们看看其源码是如何实现的吧。</p> 
<pre><code class="language-java">    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }</code></pre> 
<p>在源码中，我们很容易发现，put方法的实现都在putVal方法中，因此，我们对put方法的重点就在putVal方法中。</p> 
<h3>putVal方法</h3> 
<blockquote> 
 <p>查询源码，我们可以看到putVal的源码如下，乍看起来内容较多，在笔者的学习过程中，网络上大部分的资料均是直接开始介绍整套代码的作用，对于初学者来说，需要认知的事情太多，学习起来困难，复习起来更是无从下手，因此，笔者在这里就以初学者的角度开始，转换一下学习的方法。</p> 
</blockquote> 
<p>首先，大致看上去，putVal中包含多个if-else结构，因此，如果我们能将每个if的条件判断弄清楚，那么整个putVal的运行逻辑就一清二楚啦。</p> 
<pre><code class="language-java">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }</code></pre> 
<h3>1、方法的声明</h3> 
<p>从方法的头部往下看，首先，我们需要关注的是方法的声明。</p> 
<pre><code class="language-java">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict)</code></pre> 
<p>如图，我们发现putVal是存在返回值类型，有5个输入参数的函数，那么我们首先就需要对其中的5个输入参数进行分析。</p> 
<p>我们知道，自己在调用put的时候，往往只提供了两个输入参数key与value，那么剩下的参数put是如何传递下去的呢?</p> 
<p>在这里，我们就要看看put的源码：</p> 
<pre><code class="language-java">    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }</code></pre> 
<p>如上，put是分别将：</p> 
<ol><li>key的哈希值</li><li>key</li><li>value</li><li>false</li><li>true </li></ol> 
<p>传递下去的，因此，我们必须清楚除了key与value之外的其他三个值代表的意思。</p> 
<p>1）参数1：hash(key)</p> 
<p>        在这里，我们发现这里调用了方法hash，详细内容笔者将会在其他博客中详细讲解，在这里，我们只需要知道hash是一种数据处理方法，而hash(key)就是将key通过处理之后得到的一个数即可。</p> 
<p>        同时，我们还需要记住，hash是一种处理方法，那么就会有以下的情况，也因此，我们在后面需要针对处理：</p> 
<ol><li>相同的key，经过处理后得到的hash(key)相同</li><li>不同的key，通过处理后得到的hash(key)<strong>可能相同</strong></li></ol> 
<p>2）参数4：boolean onlyIfAbsent</p> 
<p>        表示只有当对应位置为空的时候替换元素。默认为false，即当对应位置不为空的时候，会将旧的value替换成新输入的value。</p> 
<p>        在jdk1.8中，新增了方法<span style="background-color:#fbd4d0;">public V putIfAbsent(K key, V value)</span>可以更改该参数。 </p> 
<p>3）参数5：boolean evict</p> 
<p>        默认为true，仅在初始化的时候，会传递为false。</p> 
<h3>2、If-else结构</h3> 
<h4>0）序：</h4> 
<pre><code class="language-java">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</code></pre> 
<p>        我们发现，在putVal初始，便定义了诸多参数，虽然其初始化内容和赋值在文后，但我们在最开始对其的作用进行了解后，更能方便我们后面对其进行理解。</p> 
<ol><li>Node&lt;K,V&gt;[] tab :        对应整个HashMap数组</li><li>Node&lt;K,V&gt; p      :        对应数组的下标（数组尾的下标）</li><li>int n                     :        对应HashMap数组的长度</li><li>int i                      :         对应数组的遍历参数</li></ol> 
<h4>1）第一个If</h4> 
<pre><code class="language-java">        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;</code></pre> 
<p> 在第一个if中，tab被赋值为HashMap数组。</p> 
<p>        其中，判断tab是否为空（HashMap数组是否为空）</p> 
<p>        <strong>或者</strong> 数组长度是否为零</p> 
<p>        如果是，则进行数组的初始化（通过调用resize()方法实现），默认长度为16。（会在其余博客中讲解）。</p> 
<h4>2）第二个if（无hash冲突）</h4> 
<p>        在第二个if中，出现了if-else结构，是整个方法中占比最大的部分。</p> 
<pre><code class="language-java">        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);</code></pre> 
<p>        如果当前的数组尾部为空（==null），则将当前输入的参数存入。</p> 
<h4>3）第二个if对应的else（hash冲突）</h4> 
<p>        在该代码块中，出现了两个新的参数，同样，也在此进行介绍，以方便后文的理解。</p> 
<pre><code class="language-java">Node&lt;K,V&gt; e; K k;</code></pre> 
<ol><li>Node&lt;K,V&gt; e ：用于记录该节点中是否存在与新元素key相同的标识，如e为Null则不存在。     （如存在则e不会指向 Null，而是指向key相同的元素的位置。)</li><li>K k                  ：用于存储key值</li></ol> 
<p>        如前文所述，if对应的是数组尾部为空，那么此处对应的就是数组尾部不为空（位置已存在其他元素）。那么这里，如上文中对于hash（key）的介绍，这里会出现两种情况分别对应内容中的第三个if-else结构：</p> 
<ol><li>相同的key导致发生冲突</li><li>不同的key的hash值相同，发生冲突</li></ol> 
<h4>3-1）第三个if（新元素与节点的key值相同）</h4> 
<pre><code class="language-java">            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;</code></pre> 
<p> 如上所示，判断内容为：</p> 
<p>        判断：当前数组尾的元素的key和输入参数的key是否相同</p> 
<p>        e：指向当前节点的位置</p> 
<p>        如判断相同，则用e来储存当前元素的信息，并最终将当前位置元素的Value值用新输入的Value替代。</p> 
<p>        替换代码在3-1）的下方，文中稍后讲解。</p> 
<h4>3-2）else if（节点的key值不相同，且p为treeNode）</h4> 
<p>        此处判断当前元素p是否为TreeNode，若是，则将红黑树直接插入键值对。</p> 
<h4>3-3）else（节点的key值不相同，且p不为treeNode）</h4> 
<p>        for循环-&gt;开始遍历该节点，以binCount作为计数器，用于计算当前节点的元素数量。</p> 
<p>        <strong>注意：此处for循环中，e的数值在一直更新。</strong></p> 
<p>3-3-1）for中的第一个if</p> 
<pre><code class="language-java">                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }</code></pre> 
<p>        遍历：直至节点的末尾(节点元素的.next指向null)，如直至末尾仍然无与新元素相同的key值，则将新元素存储在该节点的末尾。</p> 
<p>        其中的if：判断节点元素的数量是否超过<strong>树化阈值</strong>（详见本文第一节内容，默认为8），如超过阈值，则将目前的链表模式转换为红黑树模式。</p> 
<p>        e：最终为null。</p> 
<p>3-3-2）for中的第二个if</p> 
<pre><code class="language-java">                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;</code></pre> 
<p></p> 
<p>        看上去十分熟悉是吗，其实是与3-1中的判断语句一致。</p> 
<p>        判断：遍历当前节点元素的时候，存在与新元素相同的key，则最终实行Value的更新操作。</p> 
<p>        e：最终不为null，指向与新元素的key相同的元素位置。</p> 
<p>3-4）第四个if</p> 
<pre><code class="language-java">            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }</code></pre> 
<p>        第四个if是执行语句，如前文中存在与新元素相同的key值，则其对应的Value更新为新元素的Value。</p> 
<p>        在执行这种Value的更新的时候，会直接return退出函数，不会对HashMap的大小（参数size）进行增加。</p> 
<p>3-5）第五个if-最后的if</p> 
<pre><code class="language-java">if (++size &gt; threshold)
            resize();</code></pre> 
<p>        当不为Value值的更新的时候，即为新元素的插入。</p> 
<p>        此时，将HashMap的大小增加1，同时</p> 
<p>        判断：增加后的size是否超过<strong>扩容阈值</strong>，如超过，则进行扩容操作（会在其他博客中讲解）。</p> 
<p></p> 
<hr> 
<p> 至此，结束整个Put的分块式讲解，在这里，笔者将所有的判断整理成框图，相信大家在分块理解后，能很好地理解整个框图的逻辑啦。</p> 
<p><img alt="" src="https://images2.imgbox.com/60/9b/kfIhidP5_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f91fb3ddfcb644acdf232c23f66ab2f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">day2笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58d3d97695074cdeaac52093db24341b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">day2_homework</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>