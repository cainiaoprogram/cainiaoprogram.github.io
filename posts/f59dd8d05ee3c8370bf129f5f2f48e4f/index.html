<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中方法的重载与重写 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中方法的重载与重写" />
<meta property="og:description" content="方法的重载和重写在面试中经常会出现，所以我的学习笔记希望可以帮到你，有错误处烦请指正。 一、二者的定义和代码的一些细节 1.1方法的重载Overload 同一个类中可以存在同名的方法。那么如何区分他们呢，如我们所知方法的括号中是方法的参数（空括号时为空参方法）。由于形参列表的不同，当调用方法时括号内的参数列表不同，调用相对应的方法。这些不同形参列表的方法，就构成了方法的重载。
1.1.1重载的好处 方便方法有不同参数需求时的使用
1.1.2代码例子 public class test { public static void main(String[] args) { testOverride test = new testOverload(); //测试空参方法 test.testFuction(); //测试含参方法 test.testFuction(12); } } class testOverload{ //类的属性 private int id; //类的getter and setter public int getId() { return id; } public void setId(int id) { this.id = id; } //空参方法 public void testFuction() { System.out.println(&#34;这是空参方法&#34;); } //单参数方法 public void testFuction(int id) { setId(id); System.out.println(&#34;这是含参数的方法，传入参数为id: &#34; &#43; getId()); } } 运行结果" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f59dd8d05ee3c8370bf129f5f2f48e4f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-11T10:32:41+08:00" />
<meta property="article:modified_time" content="2021-03-11T10:32:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中方法的重载与重写</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>方法的重载和重写在面试中经常会出现，所以我的学习笔记希望可以帮到你，有错误处烦请指正。</h2> 
<h2>一、二者的定义和代码的一些细节</h2> 
<h3>1.1方法的重载Overload</h3> 
<p>同一个类中可以存在同名的方法。那么如何区分他们呢，如我们所知方法的括号中是方法的参数（空括号时为空参方法）。由于形参列表的不同，当调用方法时括号内的参数列表不同，调用相对应的方法。这些不同形参列表的方法，就构成了方法的重载。</p> 
<h4>1.1.1重载的好处</h4> 
<p>方便方法有不同参数需求时的使用</p> 
<h4>1.1.2代码例子</h4> 
<pre><code class="language-java">public class test {
    public static void main(String[] args) {
        testOverride test = new testOverload();
        //测试空参方法
        test.testFuction();
        //测试含参方法
        test.testFuction(12);
    }
}

class testOverload{
    //类的属性
    private int id;
    //类的getter and setter
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    //空参方法
    public void testFuction() {
        System.out.println("这是空参方法");
    }
    //单参数方法
    public void testFuction(int id) {
        setId(id);
        System.out.println("这是含参数的方法，传入参数为id: " + getId());
    }
}</code></pre> 
<p>运行结果</p> 
<p><img alt="" height="59" src="https://images2.imgbox.com/54/4e/63rfocCh_o.png" width="249"></p> 
<p>当然，类的构造器也可以重载，那么代码就可以写成下面这样</p> 
<pre><code class="language-java">public class test {
    public static void main(String[] args) {
        testOverride test = new testOverload();
        testOverride test1 = new testOverload(123);
    }
}

class testOverload{
    //类的属性
    private int id;

    //构造器
    //1空参构造器
    public testOverload() {
        System.out.println("创建对象成功");
    }
    //2含参构造器
    public testOverload(int id) {
        this.id = id;
        System.out.println("这是含参数的构造器，传入参数为id: " + id);
    }
}
</code></pre> 
<p>运行结果</p> 
<p><img alt="" height="56" src="https://images2.imgbox.com/dd/3a/I5FpfIQq_o.png" width="259"></p> 
<p><strong>注意：构造器里可以方法私有的属性的奥</strong></p> 
<h3>1.2方法的重写Override</h3> 
<p>方法的重写，又叫方法的覆盖，通常见于java的继承中，当子类的方法需要和从父类中继承来的方法区分开的时候，就要重写该方法。</p> 
<h3>1.2.1方法重写的好处</h3> 
<p>实现子类不同于父类的方法需求</p> 
<h3>1.2.2代码例子</h3> 
<p><img alt="" height="621" src="https://images2.imgbox.com/77/72/1U0aORtC_o.png" width="823"></p> 
<p><img alt="" height="82" src="https://images2.imgbox.com/82/6c/teG0vo0V_o.png" width="306"></p> 
<p>如果子类没有重写空参方法，后面那个含参的方法还能调用吗？</p> 
<p>Suer！当然！</p> 
<h2>二、从编译和运行的角度看</h2> 
<p><span style="color:#f33b45;">重载</span>，从编译器角度看，重载的方法为不同的多个方法。它们的<span style="color:#f33b45;">调用地址在编译时就已经绑定</span>了。而<span style="color:#3399ea;">重写在运行时才能确定具体的调用的方法</span>。</p> 
<p>所以说：</p> 
<p><span style="color:#f33b45;"><strong>重载 早绑定 静态绑定</strong></span></p> 
<p><span style="color:#f33b45;"><strong>重写 晚绑定 动态绑定</strong></span></p> 
<h3>2.1重写代码在运行时才能确定调用的证明</h3> 
<pre><code class="language-java">public class test {
    public static void main(String[] args) {
        int randInt = new Random().nextInt(3);
        func(getInstance(randInt));
    }
    //调用传入动物地方法叫声
    public static void func(Animal animal) {
        animal.shout();
    }
    //根据参数创建随机对象并返回
    public static Animal getInstance(int key) {
        switch (key) {
            case 0 : return new Dog();
            case 1 : return new Cat();
            case 2 : return new Sheep();
            default: return null;
        }
    }
}

class Animal {
    public void shout() {
        System.out.println("动物：叫声");
    }
}
class Dog extends Animal {
    public void shout() {
        System.out.println("汪！汪！汪！");
    }
}
class Cat extends Animal {
    public void shout() {
        System.out.println("喵！喵！喵！");
    }
}
class Sheep extends Animal {
    public void shout() {
        System.out.println("咩！咩!咩!");
    }
}</code></pre> 
<h4>这样一来，是不是不知道会调用哪个子类的方法了？这就是重写动态绑定的体现</h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88edeff4d2f6f67811f32d7456169445/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Qualcomm Snapdragon Profiler使用教程(4)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/348aa0cb48b839d297e667f3ac39d5a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">注册表方法删除WINDOWS右键多余扩展项</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>