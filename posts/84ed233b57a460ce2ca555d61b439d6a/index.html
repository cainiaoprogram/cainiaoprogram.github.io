<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【本人秃顶程序员】用Redis快速实现BloomFilter！ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【本人秃顶程序员】用Redis快速实现BloomFilter！" />
<meta property="og:description" content="←←←←←←←←←←←← 快！点关注
背景 最近工作上有个类似需求是： 现有约3亿条数据词典存在于一个csv文件A中，作为数据源。对于 用户输入的任意单词M，需要快速的在A中匹配M单词是否存在。（A文件约3G大小左右，总行数三亿）
拿到这个需求，你的第一想法怎么做呢？
正常思路可能是：
将csv文件A导入某关系型数据库。sql查询按M匹配。 上面的方式有个明显的缺点是：慢！
3亿多行的数据，即便是建好索引进行检索，匹配到也得话不少时间（笔者没亲自试过，感兴趣的朋友可以自行测试测试，理论上快不起来的）。
目前能 在时间复杂度和空间复杂度上达到最佳的方案，恐怕就是Bloom Filter了， 维基地址：Bloom Filter
此处给不太了解Bloom Filter的读者看，熟悉的朋友直接看下一节。
本文场景Bloom Filter 使用思路解释： 假设申请了一段bit位大数组（即数组中的元素只能是一个bit位，1或0，默认元素值都为0） 将csv文件A中的每个单词，经过多个hash函数进行hash运算之后得到在大数组中对应的多个下标位置 将步骤2中得到的多个下标位置的bit位都置为1. 对于用户输入的任意单词M，按照2的步骤得到多个下标位置，其对应大数组中的值全部为1则存在，否则不存在。
方案选型 实现Bloom Filter的方法很多，有各种语言版本的，这里为了真切感受一下算法的魅力，笔者这里决定用java 代码徒手撸了！
另一方面，考虑到分布式应用的需要，显然在单机内存上构建Bloom Filter存储是不太合适的。 这里选择redis。
redis有以下为操作，可以用于实现bloomfilter：
redis&gt; SETBIT bit 10086 1 (integer) 0 redis&gt; GETBIT bit 10086 (integer) 1 redis&gt; GETBIT bit 100 # bit 默认被初始化为 0 (integer) 0 复制代码 实现细节 实现bloom filter的关键是hash函数，一般为了降低误报率、减少hash碰撞的影响，会选择多个hash函数。
那么，怎么写一个hash函数呢？
不要方，我们要的hash是 input: String --&gt; output: int , jdk里面的String类不是恰好也有一个hashCode 方法吗？ 翻出来看一看！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/84ed233b57a460ce2ca555d61b439d6a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-22T08:57:10+08:00" />
<meta property="article:modified_time" content="2019-01-22T08:57:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【本人秃顶程序员】用Redis快速实现BloomFilter！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <p>←←←←←←←←←←←← 快！点关注</p> 
 <h3 class="heading">背景</h3> 
 <p>最近工作上有个类似需求是： 现有约3亿条数据词典存在于一个csv文件A中，作为数据源。对于 用户输入的任意单词M，需要快速的在A中匹配M单词是否存在。（A文件约3G大小左右，总行数三亿）</p> 
 <p>拿到这个需求，你的第一想法怎么做呢？</p> 
 <p>正常思路可能是：</p> 
 <ol><li>将csv文件A导入某关系型数据库。</li><li>sql查询按M匹配。</li></ol> 
 <p>上面的方式有个明显的缺点是：慢！</p> 
 <p>3亿多行的数据，即便是建好索引进行检索，匹配到也得话不少时间（笔者没亲自试过，感兴趣的朋友可以自行测试测试，理论上快不起来的）。</p> 
 <p>目前能 在时间复杂度和空间复杂度上达到最佳的方案，恐怕就是Bloom Filter了， 维基地址：Bloom Filter</p> 
 <blockquote> 
  <p>此处给不太了解Bloom Filter的读者看，熟悉的朋友直接看下一节。</p> 
 </blockquote> 
 <blockquote> 
  <p>本文场景Bloom Filter 使用思路解释： 假设申请了一段bit位大数组（即数组中的元素只能是一个bit位，1或0，默认元素值都为0） 将csv文件A中的每个单词，经过多个hash函数进行hash运算之后得到在大数组中对应的多个下标位置 将步骤2中得到的多个下标位置的bit位都置为1. 对于用户输入的任意单词M，按照2的步骤得到多个下标位置，其对应大数组中的值全部为1则存在，否则不存在。</p> 
 </blockquote> 
 <h3 class="heading">方案选型</h3> 
 <p>实现<code>Bloom Filter</code>的方法很多，有各种语言版本的，这里为了真切感受一下算法的魅力，笔者这里决定用java 代码徒手撸了！</p> 
 <p>另一方面，考虑到分布式应用的需要，显然在单机内存上构建<code>Bloom Filter</code>存储是不太合适的。 这里选择<code>redis</code>。</p> 
 <p>redis有以下为操作，可以用于实现bloomfilter：</p> 
 <pre><code class="hljs bash copyable">redis&gt; SETBIT bit 10086 1
(<span class="hljs-built_in">integer</span>) 0
redis&gt; GETBIT bit 10086
(<span class="hljs-built_in">integer</span>) 1
redis&gt; GETBIT bit 100   <span class="hljs-comment"># bit 默认被初始化为 0</span>
(<span class="hljs-built_in">integer</span>) 0
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">实现细节</h3> 
 <p>实现bloom filter的关键是hash函数，一般为了降低误报率、减少hash碰撞的影响，会选择多个hash函数。</p> 
 <p>那么，怎么写一个hash函数呢？</p> 
 <p>不要方，我们要的hash是 input: String --&gt; output: int , jdk里面的String类不是恰好也有一个hashCode 方法吗？ 翻出来看一看！</p> 
 <pre><code class="hljs bash copyable">/**
     * Returns a <span class="hljs-built_in">hash</span> code <span class="hljs-keyword">for</span> this string. The <span class="hljs-built_in">hash</span> code <span class="hljs-keyword">for</span> a
     * {@code String} object is computed as
     * &lt;blockquote&gt;&lt;pre&gt;
     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * using {@code int} arithmetic, <span class="hljs-built_in">where</span> {@code s[i]} is the
     * &lt;i&gt;i&lt;/i&gt;th character of the string, {@code n} is the length of
     * the string, and {@code ^} indicates exponentiation.
     * (The <span class="hljs-built_in">hash</span> value of the empty string is zero.)
     *
     * @<span class="hljs-built_in">return</span>  a <span class="hljs-built_in">hash</span> code value <span class="hljs-keyword">for</span> this object.
     */
    public int <span class="hljs-function"><span class="hljs-title">hashCode</span></span>() {
        int h = <span class="hljs-built_in">hash</span>;
        <span class="hljs-keyword">if</span> (h == 0 &amp;&amp; value.length &gt; 0) {
            char val[] = value;

            <span class="hljs-keyword">for</span> (int i = 0; i &lt; value.length; i++) {
                h = 31 * h + val[i];
            }
            <span class="hljs-built_in">hash</span> = h;
        }
        <span class="hljs-built_in">return</span> h;
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>看到这一行<code>h = 31 * h + val[i];</code>，貌似原理其实也很简单，每个字符对应的ascii码，经过一个公式计算依次加起来。这里有个系数<code>31</code>, 稍微变一下， 不就可以有多个hash函数了吗。</p> 
 <p>以下是稍加修改后的hash函数：</p> 
 <pre><code class="hljs bash copyable">    //总的bitmap大小  64M
    private static final int <span class="hljs-built_in">cap</span> = 1 &lt;&lt; 29;
    /*
     * 不同哈希函数的种子，一般取质数
     * seeds数组共有8个值，则代表采用8种不同的哈希函数
     */
    private int[] seeds = new int[]{3, 5, 7, 11, 13, 31, 37, 61};
    private int <span class="hljs-built_in">hash</span>(String value, int seed) {
        int result = 0;
        int length = value.length();
        <span class="hljs-keyword">for</span> (int i = 0; i &lt; length; i++) {
            result = seed * result + value.charAt(i);
        }
        <span class="hljs-built_in">return</span> (<span class="hljs-built_in">cap</span> - 1) &amp; result;
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>剩下的事情便很简单了，对每个词典A中的单词，依次调seeds 中对应的hash函数（这里一共是8个），用redis的setbit操作，将下标值置为1.</p> 
 <p>redis代码 (这里用pipeline 包装了下。)</p> 
 <pre><code class="hljs bash copyable">@Service
public class RedisService {
    @Autowired
    private StringRedisTemplate template;
    public void multiSetBit(String name, boolean value, long... offsets) {
        template.executePipelined((RedisCallback&lt;Object&gt;) connection -&gt; {
            <span class="hljs-keyword">for</span> (long offset : offsets) {
                connection.setBit(name.getBytes(), offset, value);
            }
            <span class="hljs-built_in">return</span> null;
        });
    }
    public List&lt;Boolean&gt; multiGetBit(String name, long... offsets) {
        List&lt;Object&gt; results = template.executePipelined((RedisCallback&lt;Object&gt;) connection -&gt; {
            <span class="hljs-keyword">for</span> (long offset : offsets) {
                connection.getBit(name.getBytes(), offset);
            }
            <span class="hljs-built_in">return</span> null;
        });
        List&lt;Boolean&gt; list = new ArrayList&lt;&gt;();
        results.forEach(obj -&gt; {
            list.add((Boolean) obj);
        });
        <span class="hljs-built_in">return</span> list;
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>最后，代码串起来大概长这个样子：</p> 
 <pre><code class="hljs bash copyable">        FileInputStream inputStream = new FileInputStream(<span class="hljs-string">"/XXXX.csv"</span>);
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        HashSet&lt;Long&gt; totalSet=new HashSet&lt;&gt;();
        String word=null;
        <span class="hljs-keyword">while</span>((word = bufferedReader.readLine()) != null){
            <span class="hljs-keyword">for</span> (int seed : seeds) {
                int <span class="hljs-built_in">hash</span> = <span class="hljs-built_in">hash</span>(word, seed);
                totalSet.add((long) <span class="hljs-built_in">hash</span>);
            }
            long[] offsets = new long[totalSet.size()];
            int i=0;
            <span class="hljs-keyword">for</span>(Long l:totalSet){
                offsets[i++]=l;
            }
            redisService.multiSetBit(<span class="hljs-string">"BLOOM_FILTER_WORDS_DICTIONARY"</span>, <span class="hljs-literal">true</span>, offsets);
        }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>查的时候也类似：</p> 
 <pre><code class="hljs bash copyable">        String word = <span class="hljs-string">"XXXX"</span>; //实际输入
        long[] offsets = new long[seeds.length];
        <span class="hljs-keyword">for</span> (int i = 0; i &lt; seeds.length; i++) {
            int <span class="hljs-built_in">hash</span> = <span class="hljs-built_in">hash</span>(mobile, seeds[i]);
            offsets[i] = <span class="hljs-built_in">hash</span>;
        }
        List&lt;Boolean&gt; results = redisService.multiGetBit(<span class="hljs-string">"BLOOM_FILTER_WORDS_DICTIONARY"</span>, offsets);
        //判断是否都为<span class="hljs-literal">true</span> （则存在)
        boolean isExisted=<span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span>(Boolean result:results){
            <span class="hljs-keyword">if</span>(!result){
                isExisted=<span class="hljs-literal">false</span>;
                <span class="hljs-built_in">break</span>;
            }
        }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">注意事项</h3> 
 <blockquote> 
  <p>setbit的offset是用大小限制的，在0到 232（最大使用512M内存）之间，即0~4294967296之前，超过这个数会自动将offset转化为0，因此使用的时候一定要注意。</p> 
 </blockquote> 
 <blockquote> 
  <p>欢迎大家加入粉丝群：963944895，群内免费分享Spring框架、Mybatis框架SpringBoot框架、SpringMVC框架、SpringCloud微服务、Dubbo框架、Redis缓存、RabbitMq消息、JVM调优、Tomcat容器、MySQL数据库教学视频及架构学习思维导图</p> 
 </blockquote> 
 <h3 class="heading">写在最后：</h3> 
 <p><strong>秃顶程序员的不易，看到这里，点了关注吧！ 点关注，不迷路，持续更新！！！</strong></p> 
</div> 
<p>转载于:https://juejin.im/post/5c46dab2f265da61736a95ae</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cf65135f2ab8b318602291a478035c7e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深入理解计算机系统-第三章-程序的机器级表示-3.5</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9da29332041cbf69f5113fc3398395f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python2 读txt文件，中文乱码问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>