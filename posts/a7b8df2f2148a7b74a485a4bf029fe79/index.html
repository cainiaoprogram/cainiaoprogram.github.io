<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hardware and Software Support for Virtualization读书笔记（一）：定义 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hardware and Software Support for Virtualization读书笔记（一）：定义" />
<meta property="og:description" content="出于兴趣，最近在看Hardware and Software Support for Virtualization这本书。为了加深对该书和虚拟化主要概念及流程的记忆和理解，计划写几篇文章来进行记录。因为个人职业方向和兴趣有限，文章只能对书中部分内容进行记录和阐释，只能做抛砖引玉和自我参考使用，如果有大佬看到这些文章且有不同意见，欢迎讨论指正。
1. VIRTUALIZATION Virtualization is the application of the layering principle through enforced modularity, whereby the exposed virtual resource is identical to the underlying physical resource being virtualized
以上引文为VIRTUALIZATION（虚拟化）的定义，它主要包括两个基本原则：1)分层，分层通过引入不同层级(layer)，使得部分层级不能直接(即indirection)使用计算机资源，而是一种对资源的抽象。2)强制模块化，某些被抽象出的层级不能直接使用物理资源或得知物理资源的具体使用情况。
1.1 Virtualization in Computer Architecture 虚拟化是计算机架构中的一个基本组成部分，其中一个最典型的例子就是虚拟存储器(virtual memory)。虚拟存储器的实现依赖于MMU（memory management units，内存管理单元），它使得应用程序不能直接使用存储器，而是将硬件的实际物理地址隐藏起来，使应用程序只能通过虚拟地址访问存储器。
1.2 Virtualization within Operating Systems 操作系统将计算机资源如CPU, IO, memory安全地提供给同时执行的多个应用程序，例如，操作系统通过控制MMU，将不同的存储器地址空间提供给多个不同的进程，保证它们可以复用有限的存储空间，但又不会访问其他进程的敏感数据
1.3 Virtualization in I/O subsystems 这一部分，原文中没有进行理论说明。举例来说，硬盘控制器可以通过虚拟化将多个硬盘区域抽象为多个虚拟硬盘供操作系统使用
1.4 Three basic implementations techniques of virtualization 下图给出了实现虚拟化的三种基本技术，这三种技术可以结合起来使用。几乎所有hypervisor都组合使用了multiplexing和emulation。
1.4.1 multiplexing multiplexing（复用）包括空间复用和时间复用两种。空间(space)复用是将某一物理资源切分并分给不同的虚拟化实体（virtual entities），例如，操作系统通过配置MMU来控制虚拟地址到物理地址的映射，将物理地址空间的不同区域划分到不同虚拟地址空间中。时间(time)复用是将同一物理资源在不同时间给不同的虚拟化实体（virtual entities）使用，例如操作系统可以让不同的线程复用CPU资源。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a7b8df2f2148a7b74a485a4bf029fe79/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-25T17:34:05+08:00" />
<meta property="article:modified_time" content="2022-09-25T17:34:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hardware and Software Support for Virtualization读书笔记（一）：定义</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>出于兴趣，最近在看Hardware and Software Support for Virtualization这本书。为了加深对该书和虚拟化主要概念及流程的记忆和理解，计划写几篇文章来进行记录。因为个人职业方向和兴趣有限，文章只能对书中部分内容进行记录和阐释，只能做抛砖引玉和自我参考使用，如果有大佬看到这些文章且有不同意见，欢迎讨论指正。</p> 
<h2><a id="1_VIRTUALIZATION_2"></a>1. VIRTUALIZATION</h2> 
<blockquote> 
 <p>Virtualization is the application of the layering principle through enforced modularity, whereby the exposed virtual resource is identical to the underlying physical resource being virtualized</p> 
</blockquote> 
<p>以上引文为VIRTUALIZATION（虚拟化）的定义，它主要包括两个基本原则：1)分层，分层通过引入不同层级(layer)，使得部分层级不能直接(即indirection)使用计算机资源，而是一种对资源的抽象。2)<strong>强制</strong>模块化，某些被抽象出的层级<strong>不能</strong>直接使用物理资源或得知物理资源的具体使用情况。</p> 
<h3><a id="11_Virtualization_in_Computer_Architecture_7"></a>1.1 Virtualization in Computer Architecture</h3> 
<p>虚拟化是计算机架构中的一个基本组成部分，其中一个最典型的例子就是虚拟存储器(virtual memory)。虚拟存储器的实现依赖于MMU（memory management units，内存管理单元），它使得应用程序不能直接使用存储器，而是将硬件的实际物理地址隐藏起来，使应用程序只能通过虚拟地址访问存储器。</p> 
<h3><a id="12_Virtualization_within_Operating_Systems_9"></a>1.2 Virtualization within Operating Systems</h3> 
<p>操作系统将计算机资源如CPU, IO, memory安全地提供给同时执行的多个应用程序，例如，操作系统通过控制MMU，将不同的存储器地址空间提供给多个不同的进程，保证它们可以复用有限的存储空间，但又不会访问其他进程的敏感数据</p> 
<h3><a id="13_Virtualization_in_IO_subsystems_11"></a>1.3 Virtualization in I/O subsystems</h3> 
<p>这一部分，原文中没有进行理论说明。举例来说，硬盘控制器可以通过虚拟化将多个硬盘区域抽象为多个虚拟硬盘供操作系统使用</p> 
<h3><a id="14_Three_basic_implementations_techniques_of_virtualization_13"></a>1.4 Three basic implementations techniques of virtualization</h3> 
<p>下图给出了实现虚拟化的三种基本技术，这三种技术可以结合起来使用。几乎所有hypervisor都组合使用了multiplexing和emulation。<br> <img src="https://images2.imgbox.com/56/80/i7CUqByC_o.png" alt="图1 实现虚拟化的三项主要技术(图中X表示物理或虚拟资源)"></p> 
<h4><a id="141_multiplexing_16"></a>1.4.1 multiplexing</h4> 
<p>multiplexing（复用）包括空间复用和时间复用两种。空间(space)复用是将某一物理资源切分并分给不同的虚拟化实体（virtual entities），例如，操作系统通过配置MMU来控制虚拟地址到物理地址的映射，将物理地址空间的不同区域划分到不同虚拟地址空间中。时间(time)复用是将同一物理资源在不同时间给不同的虚拟化实体（virtual entities）使用，例如操作系统可以让不同的线程复用CPU资源。</p> 
<h4><a id="142_aggregation_18"></a>1.4.2 aggregation</h4> 
<p>aggregation（聚合）与复用相反，是将多个物理资源结合在一起使用。例如，芯片外接了多个DIMM（可以理解为DRAM的channel），但是操作系统可以把它们映射到同一个地址空间中，视为同一块DRAM使用。</p> 
<h4><a id="143_emulation_20"></a>1.4.3 emulation</h4> 
<p>emulation（模拟）是指利用某种物理资源提供另外一种虚拟资源（即使这种虚拟资源并不真正存在于该计算机硬件中），例如，可以通过指令转换，用powerPC的计算机模拟x86计算机。</p> 
<h2><a id="2_VIRTUAL_MACHINES_23"></a>2. VIRTUAL MACHINES</h2> 
<blockquote> 
 <p>A virtual machine is a complete compute environment with its own isolated<br> processing capabilities, memory, and communication channels.</p> 
</blockquote> 
<p>虚拟机是一个具有独立处理能力、存储器和通信通道的运算环境。（这一点很好理解，我们平时用的VMware中的虚拟机在用户看来就是一台完整的计算机）</p> 
<p>下图是虚拟机的几种分类以及运行system-level virtual machine的平台分类，由于笔者是硬件出身，为了避免误导，system-level virtual machine之外的两种虚拟机定义就直接引用原文。<br> <img src="https://images2.imgbox.com/ec/ca/sFmqLW39_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="21_Languagebased_Virtual_MachineLightweight_Virtual_Machine_32"></a>2.1 Language-based Virtual Machine和Lightweight Virtual Machine</h3> 
<blockquote> 
 <ul><li>language-based virtual machines, such as the Java Virtual Machine, Microsoft Common Language Runtime, Javascript engines embedded in browsers, and in general the run-time environment of any managed language.</li><li>lightweight virtual machines, which rely on a combination of hardware and software isolation mechanisms to ensure that applications running directly on the processor (e.g., as native x86 code) are securely isolated from other sandboxes and the underlying operating system.</li></ul> 
</blockquote> 
<h3><a id="22_systemlevel_virtual_machines_38"></a>2.2 system-level virtual machines</h3> 
<p>system-level virtual machines是该书的主要讨论内容，这种虚拟机的计算机硬件资源是由完全隔离的计算环境组成的，从而可以运行独立的操作系统(称为guest operating system)及运行于其上的应用程序。每个虚拟机都有自己的底层硬件资源(当然有可能是和其他虚拟机共享，虚拟机本身无法感知到其他虚拟机的存在，即在它自己看来，硬件资源是独享的)</p> 
<p>system-level virtual machines有Machine Simulator和Hypervisor两种实现方式。</p> 
<h4><a id="221_hypervisor_43"></a>2.2.1 hypervisor</h4> 
<p>hypervisor基于direct execution（直接执行），即虚拟机的代码是直接运行在物理CPU上，从而获得最高的性能。在direct execution中，hypervisor建立、配置好硬件环境，并将物理CPU交给虚拟机，让其代码在CPU上直接运行。这些指令属于虚拟机这一抽象层次，不可能拥有所有权限，且它们的运行本身会产生异常或执行某些需要特定权限的操作，所以这些指令的运行会产生trap（陷阱），并由hypervisor执行(emulate)。这种trap-and-emulate机制是hypervisor工作的核心</p> 
<h4><a id="222_machine_simulator_45"></a>2.2.2 machine simulator</h4> 
<p>machine simulator通常是以用户应用程序的形式出现的，它会提供对目标虚拟机所依赖计算机架构的准确模拟，但这需要将被虚拟机的指令转换为物理CPU的实际指令，使得基于machine simulator的虚拟机性能只有物理计算机的1/1000到1/5。</p> 
<h2><a id="3_HYPERVISORS_48"></a>3. HYPERVISORS</h2> 
<p>hypervisor又被称为VMM（ virtual machine monitor）是一种以降低运行运行开销为目的，用于运行虚拟机的特殊系统软件。当某个计算机系统同时存在多个虚拟机时，hypervisor在多个虚拟机之间复用物理（硬件）资源。</p> 
<p>hypervisor有以下三个主要标准：<br> 1）Equivalence:如前所述，虚拟机所拥有的硬件资源/计算环境和实际的硬件系统是等价的，这是一项<strong>强</strong>需求<br> 2）Safety:虚拟机之间、虚拟机和hypervisor之间是完全隔离的，即模块化。整个系统的安全性完全由hypervisor保证<br> 3）Performance：虚拟机和物理计算机的性能之间，只允许有很小的性能损失</p> 
<p>根据获得对系统控制权的方式，hypervisor可以分为type-1和type-2两种类型。</p> 
<h3><a id="31_type1_57"></a>3.1 type-1</h3> 
<p>type-1 hypervisor运行在裸机(bare machine)上，可以直接控制系统的物理资源，这种类型必须直接负责系统调度和资源分配，执行这部分任务的代码就不是直接用于虚拟化相关任务，从而增大了hypervisor的开发难度。</p> 
<h3><a id="32_type2_59"></a>3.2 type-2</h3> 
<p>type-2 hypervisor是主操作系统的一部分或运行于主操作系统(host operating system，区别于由hypervisor控制的guest operating system)上，系统调度和资源分配都是由操作系统负责的，减小了hypervisor的开发难度。<br> 注：我们常用的VMware就是属于此类</p> 
<h2><a id="4_A_SKETCH_HYPERVISOR_MULTIPLEXING_AND_EMULATION_62"></a>4. A SKETCH HYPERVISOR: MULTIPLEXING AND EMULATION</h2> 
<p>这一节给出了一个简化的虚拟系统架构（见下图）。这一系统中有三个虚拟机，每个虚拟机都有属于自己的硬件资源(经过hypervisor分配、抽象后的，又称为virtual hardware)，guest OS和应用程序。hypervisor直接运行在真实的物理资源上，并对物理资源进行管理。图中的硬件(虚拟的或真实的)由一个或多个PE(processing element)组成，PE包括CPU及其MMU和存储器，PE又被连接到了硬盘(disk)及网络接口(NIC, network interface)。<br> 在这样的系统中，hypervisor主要用到复用(multiplexing)和模拟(emulation)两项虚拟化技术。复用<strong>主要</strong>是不同虚拟机之间对物理硬件资源进行空间上的复用，模拟主要是模拟一些I/O的设备及操作。<br> <img src="https://images2.imgbox.com/9b/0b/enPyf4Su_o.png" alt="在这里插入图片描述"><br> 对CPU的复用是一项调度性的任务，和操作系统对进程的调度类似。hypervisor配置好硬件环境(包括配置寄存器等)并让虚拟机以较少的权限（主要是为了安全）在硬件上运行。</p> 
<p>由于虚拟机直接在计算机硬件上运行，为了安全性，必须让它运行在较低的特权等级下，也就不能执行某些特权指令(privileged instructions)。然而，虚拟机的某些应用或场景可能需要执行特权指令，没有相应权限的虚拟机就只能通过trap(陷入)，让处理器进入更高的特权等级状态，由hypervisor指令特权指令(这被称为emulate)，再返回到虚拟机执行的guest-os，上述过程也被为trap-and-emulate。注：trap的定义可以参照：https://blog.csdn.net/zat111/article/details/36420903</p> 
<p>存储器也是在虚拟机之间复用的，在虚拟机，它拥有连续且固定大小的物理存储器，但这一存储空间是定义在虚拟地址空间内，实际的物理地址可能并不连续，且相同虚拟地址对应的物理地址有可能是动态变化的。软件访问存储器时，看到的地址都是虚拟地址，MMU完成虚拟地址到物理地址的转换得到物理地址后，再去根据物理地址访问相应的存储器。</p> 
<p>虚拟化的另一个重要部分是I/O的虚拟化，通常是指虚拟机运行在具有不同物理I/O资源的硬件平台(芯片)上时，所能使用的I/O资源都是相同的，这称为I/O的模拟(emulation)，需要硬件和hypervisor的共同支持。</p> 
<h2><a id="5virtual_memory_and_physical_memory_74"></a>5.virtual memory and physical memory</h2> 
<p>如前文所述，存储器可以分为虚拟存储器和物理存储器，它们之间的转换基于分段(segmentation)和分页(paging)</p> 
<h3><a id="51__77"></a>5.1 虚拟存储器</h3> 
<p>虚拟存储器(virtual memory)是实现操作系统的基础，也是对传统冯诺依曼架构的最大增强，处理器指令序列所使用的存储命名空间就是虚拟存储器。在基于分段的架构中，虚拟地址包括基地址和访问权限两部分(具体的转换方式尚不清楚？)。在基于分页的架构中，虚拟地址到物理地址的转换是以每一个页(page)为基础的，每一个page的映射关系一般是保存在页表(page table)中。在一些计算机架构中，分段和分页是一起使用的。</p> 
<h3><a id="52__79"></a>5.2 物理存储器</h3> 
<p>物理存储器即芯片的总线架构中，实际访问存储器所用的地址空间，物理地址与虚拟地址的映射关系、虚拟机可以使用哪些物理地址空间，都是由hypervisor决定的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0751e5cf909d767727aade859fe4a88c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">域策略（7）——禁用本地administrator登录计算机</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/908cd32b997052a550af8e581d164611/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python数据挖掘学习01：数据归一化与标准化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>