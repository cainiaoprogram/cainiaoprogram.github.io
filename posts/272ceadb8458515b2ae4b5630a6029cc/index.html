<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>cmake - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="cmake" />
<meta property="og:description" content="cmake的常用命令 cmake_minimum_required
message
project
set
add_executable
add_compile_options
add_subdirectory
add_library
target_link_libraries
include_directories
add_definitions
cmake常见变量 PROJECT_BINARY_DIR
PROJECT_SOURCE_DIR
LIBRARY_OUTPUT_PATH
EXECUTABLE_OUTPUT_PATH
见github
cmake中一些预定义变量
PROJECT_SOURCE_DIR 工程的根目录
PROJECT_BINARY_DIR 运行cmake命令的目录,通常是${PROJECT_SOURCE_DIR}/build
CMAKE_INCLUDE_PATH 环境变量,非cmake变量
CMAKE_LIBRARY_PATH 环境变量
CMAKE_CURRENT_SOURCE_DIR 当前处理的CMakeLists.txt所在的路径
CMAKE_CURRENT_BINARY_DIR target编译目录
使用ADD_SURDIRECTORY(src bin)可以更改此变量的值
SET(EXECUTABLE_OUTPUT_PATH )并不会对此变量有影响,只是改变了最终目标文件的存储路径
CMAKE_CURRENT_LIST_FILE 输出调用这个变量的CMakeLists.txt的完整路径
CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行
CMAKE_MODULE_PATH 定义自己的cmake模块所在的路径
SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake),然后可以用INCLUDE命令来调用自己的模块
EXECUTABLE_OUTPUT_PATH 重新定义目标二进制可执行文件的存放位置
LIBRARY_OUTPUT_PATH 重新定义目标链接库文件的存放位置
PROJECT_NAME 返回通过PROJECT指令定义的项目名称
CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS 用来控制IF ELSE语句的书写方式
系统信息
CMAKE_MAJOR_VERSION cmake主版本号,如2.8.6中的2
CMAKE_MINOR_VERSION cmake次版本号,如2.8.6中的8
CMAKE_PATCH_VERSION cmake补丁等级,如2.8.6中的6
CMAKE_SYSTEM 系统名称,例如Linux-2.6.22
CAMKE_SYSTEM_NAME 不包含版本的系统名,如Linux
CMAKE_SYSTEM_VERSION 系统版本,如2.6.22
CMAKE_SYSTEM_PROCESSOR 处理器名称,如i686
UNIX 在所有的类UNIX平台为TRUE,包括OS X和cygwin" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/272ceadb8458515b2ae4b5630a6029cc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-05T18:45:43+08:00" />
<meta property="article:modified_time" content="2019-07-05T18:45:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">cmake</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <h4 id="cmake的常用命令">cmake的常用命令</h4> 
 <p>cmake_minimum_required<br> message<br> project<br> set<br> add_executable<br> add_compile_options<br> add_subdirectory<br> add_library<br> target_link_libraries<br> include_directories<br> add_definitions</p> 
 <h4 id="cmake常见变量">cmake常见变量</h4> 
 <p>PROJECT_BINARY_DIR<br> PROJECT_SOURCE_DIR<br> LIBRARY_OUTPUT_PATH<br> EXECUTABLE_OUTPUT_PATH</p> 
 <hr> 
 <p>见github<br> cmake中一些预定义变量</p> 
 <p>PROJECT_SOURCE_DIR 工程的根目录<br> PROJECT_BINARY_DIR 运行cmake命令的目录,通常是${PROJECT_SOURCE_DIR}/build<br> CMAKE_INCLUDE_PATH 环境变量,非cmake变量<br> CMAKE_LIBRARY_PATH 环境变量<br> CMAKE_CURRENT_SOURCE_DIR 当前处理的CMakeLists.txt所在的路径<br> CMAKE_CURRENT_BINARY_DIR target编译目录<br> 使用ADD_SURDIRECTORY(src bin)可以更改此变量的值<br> SET(EXECUTABLE_OUTPUT_PATH )并不会对此变量有影响,只是改变了最终目标文件的存储路径<br> CMAKE_CURRENT_LIST_FILE 输出调用这个变量的CMakeLists.txt的完整路径<br> CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行<br> CMAKE_MODULE_PATH 定义自己的cmake模块所在的路径<br> SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake),然后可以用INCLUDE命令来调用自己的模块<br> EXECUTABLE_OUTPUT_PATH 重新定义目标二进制可执行文件的存放位置<br> LIBRARY_OUTPUT_PATH 重新定义目标链接库文件的存放位置<br> PROJECT_NAME 返回通过PROJECT指令定义的项目名称<br> CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS 用来控制IF ELSE语句的书写方式<br> 系统信息</p> 
 <p>CMAKE_MAJOR_VERSION cmake主版本号,如2.8.6中的2<br> CMAKE_MINOR_VERSION cmake次版本号,如2.8.6中的8<br> CMAKE_PATCH_VERSION cmake补丁等级,如2.8.6中的6<br> CMAKE_SYSTEM 系统名称,例如Linux-2.6.22<br> CAMKE_SYSTEM_NAME 不包含版本的系统名,如Linux<br> CMAKE_SYSTEM_VERSION 系统版本,如2.6.22<br> CMAKE_SYSTEM_PROCESSOR 处理器名称,如i686<br> UNIX 在所有的类UNIX平台为TRUE,包括OS X和cygwin<br> WIN32 在所有的win32平台为TRUE,包括cygwin<br> 开关选项</p> 
 <p>BUILD_SHARED_LIBS 控制默认的库编译方式。如果未进行设置,使用ADD_LIBRARY时又没有指定库类型,默认编译生成的库都是静态库 （可在t3中稍加修改进行验证）<br> CMAKE_C_FLAGS 设置C编译选项<br> CMAKE_CXX_FLAGS 设置C++编译选项<br> cmake常用命令</p> 
 <p>基本语法规则：</p> 
 <p>cmake变量使用${}方式取值,但是在IF控制语句中是直接使用变量名<br> 环境变量使用$ENV{}方式取值,使用SET(ENV{VAR} VALUE)赋值<br> 指令(参数1 参数2…)<br> 参数使用括弧括起,参数之间使用空格或分号分开。</p> 
 <p>以ADD_EXECUTABLE指令为例：<br> ADD_EXECUTABLE(hello main.c func.c)或者<br> ADD_EXECUTABLE(hello main.c;func.c)<br> 指令是大小写无关的,参数和变量是大小写相关的。推荐你全部使用大写指令。</p> 
 <p>部分常用命令列表：</p> 
 <p>PROJECT<br> PROJECT(projectname [CXX] [C] [Java])<br> 指定工程名称,并可指定工程支持的语言。支持语言列表可忽略,默认支持所有语言<br> SET<br> SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])<br> 定义变量(可以定义多个VALUE,如SET(SRC_LIST main.c util.c reactor.c))<br> MESSAGE<br> MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] “message to display” …)<br> 向终端输出用户定义的信息或变量的值<br> SEND_ERROR, 产生错误,生成过程被跳过<br> STATUS, 输出前缀为—的信息<br> FATAL_ERROR, 立即终止所有cmake过程<br> ADD_EXECUTABLE<br> ADD_EXECUTABLE(bin_file_name ${SRC_LIST})<br> 生成可执行文件<br> ADD_LIBRARY<br> ADD_LIBRARY(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] SRC_LIST)<br> 生成动态库或静态库<br> SHARED 动态库<br> STATIC 静态库<br> MODULE 在使用dyld的系统有效,若不支持dyld,等同于SHARED<br> EXCLUDE_FROM_ALL 表示该库不会被默认构建<br> SET_TARGET_PROPERTIES<br> 设置输出的名称,设置动态库的版本和API版本<br> CMAKE_MINIMUM_REQUIRED<br> CMAKE_MINIMUM_REQUIRED(VERSION version_number [FATAL_ERROR])<br> 声明CMake的版本要求<br> ADD_SUBDIRECTORY<br> ADD_SUBDIRECTORY(src_dir [binary_dir] [EXCLUDE_FROM_ALL])<br> 向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制的存放位置<br> EXCLUDE_FROM_ALL含义：将这个目录从编译过程中排除<br> SUBDIRS<br> deprecated,不再推荐使用<br> (hello sample)相当于分别写ADD_SUBDIRECTORY(hello),ADD_SUBDIRECTORY(sample)<br> INCLUDE_DIRECTORIES<br> INCLUDE_DIRECTORIES([AFTER | BEFORE] [SYSTEM] dir1 dir2 … )<br> 向工程添加多个特定的头文件搜索路径,路径之间用空格分隔,如果路径包含空格,可以使用双引号将它括起来,默认的行为为追加到当前头文件搜索路径的后面。有如下两种方式可以控制搜索路径添加的位置：<br> CMAKE_INCLUDE_DIRECTORIES_BEFORE,通过SET这个cmake变量为on,可以将添加的头文件搜索路径放在已有路径的前面<br> 通过AFTER或BEFORE参数,也可以控制是追加还是置前<br> LINK_DIRECTORIES<br> LINK_DIRECTORIES(dir1 dir2 …)<br> 添加非标准的共享库搜索路径<br> TARGET_LINK_LIBRARIES<br> TARGET_LINK_LIBRARIES(target lib1 lib2 …)<br> 为target添加需要链接的共享库<br> ADD_DEFINITIONS<br> 向C/C++编译器添加-D定义<br> ADD_DEFINITIONS(-DENABLE_DEBUG -DABC),参数之间用空格分隔<br> ADD_DEPENDENCIES<br> ADD_DEPENDENCIES(target-name depend-target1 depend-target2 …)<br> 定义target依赖的其他target,确保target在构建之前,其依赖的target已经构建完毕<br> AUX_SOURCE_DIRECTORY<br> AUX_SOURCE_DIRECTORY(dir VAR)<br> 发现一个目录下所有的源代码文件并将列表存储在一个变量中<br> 把当前目录下的所有源码文件名赋给变量DIR_HELLO_SRCS<br> EXEC_PROGRAM<br> EXEC_PROGRAM(Executable [dir where to run] [ARGS ][OUTPUT_VARIABLE <var>] [RETURN_VALUE ])<br> 用于在指定目录运行某个程序（默认为当前CMakeLists.txt所在目录）,通过ARGS添加参数,通过OUTPUT_VARIABLE和RETURN_VALUE获取输出和返回值,如下示例</var></p> 
 <h2 id="在src中运行ls命令在srccmakelists.txt添加">在src中运行ls命令,在src/CMakeLists.txt添加</h2> 
 <p>EXEC_PROGRAM(ls ARGS "*.c" OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE)<br> IF (not LS_RVALUE)<br> MESSAGE(STATUS "ls result: " ${LS_OUTPUT}) # 缩进仅为美观,语法无要求<br> ENDIF(not LS_RVALUE)<br> INCLUDE<br> INCLUDE(file [OPTIONAL]) 用来载入CMakeLists.txt文件<br> INCLUDE(module [OPTIONAL])用来载入预定义的cmake模块<br> OPTIONAL参数的左右是文件不存在也不会产生错误<br> 可以载入一个文件,也可以载入预定义模块（模块会在CMAKE_MODULE_PATH指定的路径进行搜索）<br> 载入的内容将在处理到INCLUDE语句时直接执行</p> 
 <p>FIND_</p> 
 <p>FIND_FILE(<var> name path1 path2 …)<br> VAR变量代表找到的文件全路径,包含文件名<br> FIND_LIBRARY(<var> name path1 path2 …)<br> VAR变量代表找到的库全路径,包含库文件名</var></var></p> 
 <p>FIND_LIBRARY(libX X11 /usr/lib)<br> IF (NOT libx)<br> MESSAGE(FATAL_ERROR "libX not found")<br> ENDIF(NOT libX)<br> FIND_PATH(<var> name path1 path2 …)<br> VAR变量代表包含这个文件的路径</var></p> 
 <p>FIND_PROGRAM(<var> name path1 path2 …)<br> VAR变量代表包含这个程序的全路径<br> FIND_PACKAGE( [major.minor] [QUIET] [NO_MODULE] [[REQUIRED | COMPONENTS] [componets …]])<br> 用来调用预定义在CMAKE_MODULE_PATH下的Find.cmake模块,你也可以自己定义Find<br> 模块,通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录供工程使用<br> IF<br> 语法：</var></p> 
 <p>IF (expression)<br> COMMAND1(ARGS ...)<br> COMMAND2(ARGS ...)<br> ...<br> ELSE (expression)<br> COMMAND1(ARGS ...)<br> COMMAND2(ARGS ...)<br> ...<br> ENDIF (expression) # 一定要有ENDIF与IF对应<br> IF (expression), expression不为：空,0,N,NO,OFF,FALSE,NOTFOUND或<var>_NOTFOUND,为真<br> IF (not exp), 与上面相反<br> IF (var1 AND var2)<br> IF (var1 OR var2)<br> IF (COMMAND cmd) 如果cmd确实是命令并可调用,为真<br> IF (EXISTS dir) IF (EXISTS file) 如果目录或文件存在,为真<br> IF (file1 IS_NEWER_THAN file2),当file1比file2新,或file1/file2中有一个不存在时为真,文件名需使用全路径<br> IF (IS_DIRECTORY dir) 当dir是目录时,为真<br> IF (DEFINED var) 如果变量被定义,为真<br> IF (var MATCHES regex) 此处var可以用var名,也可以用${var}<br> IF (string MATCHES regex)</var></p> 
 <p>当给定的变量或者字符串能够匹配正则表达式regex时为真。比如：<br> IF ("hello" MATCHES "ell")<br> MESSAGE("true")<br> ENDIF ("hello" MATCHES "ell")<br> 数字比较表达式<br> IF (variable LESS number)<br> IF (string LESS number)<br> IF (variable GREATER number)<br> IF (string GREATER number)<br> IF (variable EQUAL number)<br> IF (string EQUAL number)</p> 
 <p>按照字母表顺序进行比较<br> IF (variable STRLESS string)<br> IF (string STRLESS string)<br> IF (variable STRGREATER string)<br> IF (string STRGREATER string)<br> IF (variable STREQUAL string)<br> IF (string STREQUAL string)</p> 
 <p>一个小例子,用来判断平台差异：<br> IF (WIN32)<br> MESSAGE(STATUS “This is windows.”)<br> ELSE (WIN32)<br> MESSAGE(STATUS “This is not windows”)<br> ENDIF (WIN32)<br> 上述代码用来控制在不同的平台进行不同的控制,但是,阅读起来却并不是那么舒服,ELSE(WIN32)之类的语句很容易引起歧义。<br> 可以SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)<br> 这时候就可以写成:<br> IF (WIN32)<br> ELSE ()<br> ENDIF ()<br> 配合ELSEIF使用,可能的写法是这样:<br> IF (WIN32)<br> #do something related to WIN32<br> ELSEIF (UNIX)<br> #do something related to UNIX<br> ELSEIF(APPLE)<br> #do something related to APPLE<br> ENDIF (WIN32)<br> WHILE<br> 语法：</p> 
 <p>WHILE(condition)<br> COMMAND1(ARGS ...)<br> COMMAND2(ARGS ...)<br> ...<br> ENDWHILE(condition)<br> 其真假判断条件可以参考IF指令</p> 
 <p>FOREACH<br> FOREACH指令的使用方法有三种形式：<br> 列表<br> 语法：<br> FOREACH(loop_var arg1 arg2 ...)<br> COMMAND1(ARGS ...)<br> COMMAND2(ARGS ...)<br> ...<br> ENDFOREACH(loop_var)<br> 示例：<br> AUX_SOURCE_DIRECTORY(. SRC_LIST)<br> FOREACH(F ${SRC_LIST})<br> MESSAGE(${F})<br> ENDFOREACH(F)<br> 范围<br> 语法：<br> FOREACH(loop_var RANGE total)<br> COMMAND1(ARGS ...)<br> COMMAND2(ARGS ...)<br> ...<br> ENDFOREACH(loop_var)<br> 示例：<br> 从0到total以１为步进<br> FOREACH(VAR RANGE 10)<br> MESSAGE(${VAR})<br> ENDFOREACH(VAR)<br> 输出：<br> 012345678910<br> 范围和步进<br> 语法：<br> FOREACH(loop_var RANGE start stop [step])<br> COMMAND1(ARGS ...)<br> COMMAND2(ARGS ...)<br> ...<br> ENDFOREACH(loop_var)<br> 从start开始到stop结束,以step为步进,<br> 注意：直到遇到ENDFOREACH指令,整个语句块才会得到真正的执行。<br> FOREACH(A RANGE 5 15 3)<br> MESSAGE(${A})<br> ENDFOREACH(A)<br> 输出：<br> 581114<br> cmake中如何生成动态库和静态库</p> 
 <p>参考ADD_LIBRARY和SET_TARGET_PROPERTIES用法<br> t3示例</p> 
 <p>cmake中如何使用动态库和静态库（查找库的路径）</p> 
 <p>参考INCLUDE_DIRECTORIES, LINK_DIRECTORIES, TARGET_LINK_LIBRARIES用法<br> t4示例使用动态库或静态库<br> t5示例如何使用cmake预定义的cmake模块(以FindCURL.cmake为例演示)<br> t6示例如何使用自定义的cmake模块(编写了自定义的FindHELLO.cmake)<br> 注意读t5和t6的CMakeLists.txt和FindHELLO.cmake中的注释部分</p> 
 <p>cmake中如何指定生成文件的输出路径</p> 
 <p>如上ADD_SUBDIRECTORY的时候指定目标二进制文件输出路径（推荐使用下面这种）<br> 使用SET命令重新定义EXECUTABLE_OUTPUT_PATH和LIBRARY_OUTPUT_PATH变量来指定最终的二进制文件的位置<br> SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)<br> SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)<br> 上面的两条命令通常紧跟ADD_EXECUTABLE和ADD_LIBRARY,与其写在同一个CMakeLists.txt即可<br> cmake中如何增加编译选项</p> 
 <p>使用变量CMAKE_C_FLAGS添加C编译选项<br> 使用变量CMAKE_CXX_FLAGS添加C++编译选项<br> 使用ADD_DEFINITION添加</p> 
 <p>cmake中如何增加头文件路径</p> 
 <p>参考INCLUDE_DIRECTORIES命令用法</p> 
 <p>cmake中如何在屏幕上打印信息</p> 
 <p>参考MESSAGE用法</p> 
 <p>cmake中如何给变量赋值</p> 
 <p>参考SET和AUX_SOURCE_DIRECTORY用法</p> 
 <p>建议：在Project根目录先建立build,然后在build文件夹内运行cmake ..，这样就不会污染源代码, 如果不想要这些自动生成的文件了，只要简单的删除build文件夹就可以</p> 
</div> 
<p>转载于:https://www.cnblogs.com/daihanlong/p/5658991.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/09bdaeedc824c5c40d9c3dffb8467c2b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Emacs  之查看帮助</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81e14d07e9ab34d0d28f293e5d2e581e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于 js 一些基本的东西</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>