<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>(一)Spring Cloud 直击微服务作用、架构应用、hystrix降级 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="(一)Spring Cloud 直击微服务作用、架构应用、hystrix降级" />
<meta property="og:description" content="直击微服务作用 微服务架构: 遇到了什么问题?
将单体架构拆分成微服务架构后,如果保证多个服务(项目)正常运行?
哪个技术可以解决这个问题?
微服务技术
服务治理: 服务管理,维护服务与服务之间的关系
这个技术如何使用?
netflix/网飞:
SpringCloud: ★
Alibaba: ★ 软件架构 架构: 结构 软件架构: 软件的结构 淘宝架构演进过程： 100并发 -&gt; 千万并发，阿里淘宝的 14 次架构演进之路！
软件架构演进过程:
单体架构: All in one
优点: 架构简单 部署方便
缺点: 耦合度高,维护成本大
技术栈受限
使用场景: 用户量小,一般情况下开发学生管理系统
分布式架构:
将大项目拆分成多个小项目
微服务架构:
拆分原则:
单一职责: 一个服务只做一件事情(不允许出现冗余的功能或模块)
自治: 团队独立,技术独立,部署独立,数据库独立
面向服务: 微服务开发完毕后,需要对外提供统一的访问接口(对接规范)
隔离性强: 服务调用做好隔离、容错、降级，避免出现级联问题
微服务技术:
各个公司将自己的单体架构的项目拆分成微服务架构项目后,都有自己的解决方案.我们学习时,主要学习SpringCloud官方提供的微服务组件,SpringCloud官方使用的组件主要来自NetFlix和Alibaba
学习微服务其实就是学习相关的微服务组件,一个组件可以解决微服务拆分后的一类问题. 如何使用： 准备微服务环境
创建两个数据库,分别写一套对应的增删改查操作
依赖
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
&lt;version&gt;Hoxton.SR10&lt;/version&gt;
&lt;type&gt;pom&lt;/type&gt;
&lt;scope&gt;import&lt;/scope&gt;
&lt;/dependency&gt; Eureka组件 遇到了什么问题?
- order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？
- 有多个user-service实例地址，order-service调用时该如何选择？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e5964c6bfde153527cbd58df206aa8cd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T10:35:41+08:00" />
<meta property="article:modified_time" content="2024-01-06T10:35:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">(一)Spring Cloud 直击微服务作用、架构应用、hystrix降级</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4></h4> 
<h4>直击微服务作用</h4> 
<h2>  微服务架构:</h2> 
<h4>    遇到了什么问题?<br>         将单体架构拆分成微服务架构后,如果保证多个服务(项目)正常运行?<br>     哪个技术可以解决这个问题?<br>         微服务技术<br>         服务治理: 服务管理,维护服务与服务之间的关系<br>     这个技术如何使用?<br>         netflix/网飞:<br>         SpringCloud: ★<br>         Alibaba: ★ </h4> 
<p></p> 
<h2>软件架构</h2> 
<h4>架构: 结构</h4> 
<h4>软件架构: 软件的结构</h4> 
<h4>淘宝架构演进过程：</h4> 
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&amp;mid=2247485427&amp;idx=1&amp;sn=35a1d4d4bc8a96ecb5e841bea2cc1102&amp;chksm=fba6eff0ccd166e6c048741bec01d8979b2be277f6abd38996e0aed2e2f887559dd61f693c71&amp;mpshare=1&amp;scene=1&amp;srcid=0616Hpu6jcYpt7HaXeXHDhea&amp;sharer_sharetime=1596984524454&amp;sharer_shareid=5e222757dd91db135a3736679bc9eb56&amp;key=bbd9db2a3d7572cdbd226e0775c7ca7f0d70f724d8b03095eeecf112cc204c20fba4dff140e40327c794c36ff38352fba5da804015bb2ed758cfdec881b8600fc88cd85cc84fe8b87c901e1b1da583fb&amp;ascene=1&amp;uin=MTE5ODAyNDI3OA%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090529&amp;lang=zh_CN&amp;exportkey=A1PI8LOUY6TMNRWrt7504jQ%3D&amp;pass_ticket=U40ThnXGAl1WXUCF7y5mEpLjz19dLmkCkdYPHIB2MTvojIlJr2M57ToBVxtUzROh" rel="nofollow" title="100并发 -&gt; 千万并发，阿里淘宝的 14 次架构演进之路！">100并发 -&gt; 千万并发，阿里淘宝的 14 次架构演进之路！</a></p> 
<p></p> 
<h4>软件架构演进过程:<br>     单体架构: All in one<br>         优点: 架构简单 部署方便<br>         缺点: <br>             耦合度高,维护成本大<br>             技术栈受限<br>         使用场景: 用户量小,一般情况下开发学生管理系统<br>     分布式架构:<br>         将大项目拆分成多个小项目<br>     微服务架构:<br>         拆分原则:<br>             单一职责: 一个服务只做一件事情(不允许出现冗余的功能或模块)<br>             自治: 团队独立,技术独立,部署独立,数据库独立<br>             面向服务: 微服务开发完毕后,需要对外提供统一的访问接口(对接规范)<br>             隔离性强: 服务调用做好隔离、容错、降级，避免出现级联问题<br> 微服务技术:<br>     各个公司将自己的单体架构的项目拆分成微服务架构项目后,都有自己的解决方案.我们学习时,主要学习SpringCloud官方提供的微服务组件,SpringCloud官方使用的组件主要来自NetFlix和Alibaba<br>     学习微服务其实就是学习相关的微服务组件,一个组件可以解决微服务拆分后的一类问题.</h4> 
<h3>如何使用：</h3> 
<p>准备微服务环境<br> 创建两个数据库,分别写一套对应的增删改查操作</p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/0e/6b/WYqmZkHa_o.png" width="813"></p> 
<p>依赖</p> 
<h4>     &lt;dependency&gt;<br>         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>         &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;<br>         &lt;version&gt;Hoxton.SR10&lt;/version&gt;<br>         &lt;type&gt;pom&lt;/type&gt;<br>         &lt;scope&gt;import&lt;/scope&gt;<br>       &lt;/dependency&gt;</h4> 
<p></p> 
<h2>Eureka组件</h2> 
<h5>遇到了什么问题?<br>     - order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？<br>     - 有多个user-service实例地址，order-service调用时该如何选择？<br>     - order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？<br> 哪个技术可以解决这个问题?<br>     Eureka组件可以解决<br> 这个技术如何使用?<br>     1.搭建Eureka服务端<br>     2.在微服务中整合Eureka客户端<br>     3.在消费者方,通过服务名称获取提供者的地址,负载均衡进行访问</h5> 
<p><img alt="" height="453" src="https://images2.imgbox.com/d5/bb/Sq0uOwMZ_o.png" width="796"></p> 
<h2>RestTemplate对象</h2> 
<p>RestTemplate: 模拟浏览器的行为向服务器发送请求</p> 
<pre><code class="language-java">
/**
 * @Author: huahua
 * @name：RestTemplateTest
 * @Date：2023/7/18 10:41
 */
@SpringBootTest
public class RestTemplateTest {
    /**
     * RPC(Remote Procedure Call Protocol): 远程过程调用
     *      只要实现了两台机器之间的数据交互就可以称之为远程过程调用
     * RestTemplate: 封装了远程调用的客户端
     *
     */
    @Autowired
    private RestTemplate restTemplate;

    // get方式的请求
    @Test
    public void test01(){
        // 向目标服务器发送请求,并接收对应的结果
        //String resp = restTemplate.getForObject("http://user-service/user/1", String.class);
        //TbUser resp = restTemplate.getForObject("http://user-service/user/1", TbUser.class);
        // 携带参数
        //TbUser resp = restTemplate.getForObject("http://user-service/user/findByName/柳岩", TbUser.class);
        //System.out.println(resp);

        ResponseEntity&lt;TbUser&gt; resp = restTemplate.getForEntity("http://127.0.0.1:8081/user/1", TbUser.class);
        // 获取响应状态
        HttpStatus statusCode = resp.getStatusCode();
        // 获取响应数据
        TbUser tbUser = resp.getBody();
        // 获取响应头
        HttpHeaders headers = resp.getHeaders();
        // 获取响应头中的cookie头
        List&lt;String&gt; list = headers.get("Set-Cookie");
        System.out.println(statusCode);
        System.out.println(tbUser);
        System.out.println(headers);
        System.out.println(list);

    }
    /**
     * 请求头设置参数，访问指定接口
     */
    @Test
    public void test03(){
        String url="http://127.0.0.1:8081/user/2";
        //设置请求头参数
        HttpHeaders headers = new HttpHeaders();
        headers.add("token","damimi");
        //请求头填充到请求对象下
        HttpEntity&lt;Map&gt; entry = new HttpEntity&lt;&gt;(headers);
        //发送请求
        ResponseEntity&lt;TbUser&gt; responseEntity = restTemplate.exchange(url, HttpMethod.GET, entry, TbUser.class);
        TbUser result = responseEntity.getBody();
        System.out.println(result);
    }
    /**
     * post模拟form表单提交数据
     */
    @Test
    public void test04(){
        String url="http://localhost:8081/user/save";
        //设置请求头，指定请求数据方式
        HttpHeaders headers = new HttpHeaders();
        //告知被调用方，请求方式是form表单提交，这样对方解析数据时，就会按照form表单的方式解析处理
        headers.add("Content-type","application/x-www-form-urlencoded");
        //组装模拟form表单提交数据，内部元素相当于form表单的input框
        LinkedMultiValueMap&lt;String, Object&gt; map = new LinkedMultiValueMap&lt;&gt;();
        map.add("username","迪丽热巴");
        map.add("address","天津");
        HttpEntity&lt;LinkedMultiValueMap&lt;String, Object&gt;&gt; httpEntity = new HttpEntity&lt;&gt;(map, headers);
        /*
            参数1：请求url地址
            参数2：请求方式 POST
            参数3：请求体对象，携带了请求头和请求体相关的参数
            参数4：响应数据类型
         */
        ResponseEntity&lt;TbUser&gt; exchange = restTemplate.exchange(url, HttpMethod.POST, httpEntity, TbUser.class);
        TbUser body = exchange.getBody();
        System.out.println(body);
    }

    /**
     * post发送json数据
     */
    @Test
    public void test05() throws JsonProcessingException {
        String url="http://localhost:8081/user/save2";
        //设置请求头的请求参数类型
        HttpHeaders headers = new HttpHeaders();
        //告知被调用方，发送的数据格式的json格式，对方要以json的方式解析处理
        headers.add("Content-type","application/json; charset=utf-8");
        //组装json格式数据
        HashMap&lt;String, String&gt; reqMap = new HashMap&lt;&gt;();
        reqMap.put("username","zhangsan");
        reqMap.put("address","上海");
        ObjectMapper objectMapper = new ObjectMapper();
        String reqMapJson = objectMapper.writeValueAsString(reqMap);
        //构建请求对象
        HttpEntity&lt;String&gt; httpEntity = new HttpEntity&lt;&gt;(reqMapJson, headers);
          /*
            发送数据
            参数1：请求url地址
            参数2：请求方式
            参数3：请求体对象，携带了请求头和请求体相关的参数
            参数4：响应数据类型
         */
        ResponseEntity&lt;TbUser&gt; responseEntity = restTemplate.exchange(url, HttpMethod.POST, httpEntity, TbUser.class);
        //或者
        // Account account=restTemplate.postForObject(url,httpEntity,Account.class);
        TbUser body = responseEntity.getBody();
        System.out.println(body);
    }

    @Test
    public void test07(){
        ResponseEntity&lt;String&gt; resp = restTemplate.getForEntity("http://www.takungpao.com/news/index.html", String.class);
        String body = resp.getBody();
        System.out.println(body);
    }
}</code></pre> 
<h2>Ribbon</h2> 
<blockquote> 
 <p>当服务从Eureka中拉取多个服务地址时,Ribbon可以实现负载均衡(从多个地址中选择一个)<br> 在RestTemplate对象上添加注解 @LoadBalanced</p> 
</blockquote> 
<p></p> 
<h2>Hystrix组件</h2> 
<p>作用: 解决雪崩问题<br>       雪崩问题: 在一个业务链路中,由于下游服务的故障,导致整个链路关联的所以服务宕机.<br> 解决方案:<br>     服务降级: 换一种方式快速给上游服务一个响应.<br>     服务熔断: 当出错率到达一定的阈值时,直接熔断,不再访问下游服务,直接降级.</p> 
<h3>服务降级</h3> 
<p><img alt="" height="469" src="https://images2.imgbox.com/2c/26/fuxpgR8b_o.png" width="619"></p> 
<h4>1.导入启动器</h4> 
<p>在消费者/上游服务方导入</p> 
<blockquote> 
 <p> &lt;!-- Hystrix启动器 --&gt;<br> &lt;dependency&gt;<br>   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>   &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;<br> &lt;/dependency&gt;</p> 
</blockquote> 
<h4>2.在引导上开启Hystrix支持</h4> 
<blockquote> 
 <p>@EnableHystrix</p> 
</blockquote> 
<h4>3.编写降级逻辑</h4> 
<blockquote> 
 <p>a.在需要降级的方法上降级注解: @HystrixCommand(fallbackMethod="降级方法名")<br> b.编写降级的方法<br>   降级处理的方法,与原方法返回值,参数列表保持一致</p> 
</blockquote> 
<pre><code class="language-java">package com.bw.order.controller;

import com.bw.order.domain.TbOrder;
import com.bw.order.domain.TbUser;
import com.bw.order.service.TbOrderService;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author: huahaua
 * @name：OrderController
 * @Date：2023/8/14 18:48
 */
@RestController
@RequestMapping("/order")
public class OrderController {
    @Autowired
    private TbOrderService orderService;
    // 此方法执行超时后,调用对应降级的方法快速处理业务
    @RequestMapping("/findById/{id}")
    @HystrixCommand(fallbackMethod="findUserByIdForFail")
    public TbOrder findById(@PathVariable Integer id){
        TbOrder order = orderService.findById(id);
        return order;
    }

    // todo:降级处理的方法,与原方法返回值,参数列表保持一致
    public TbOrder findUserByIdForFail(Integer id){
        TbOrder order = new TbOrder();
        order.setName("你的小可爱走丢了....服务降级");
        return order;
    }
}</code></pre> 
<h4>4.注意事项和配置</h4> 
<blockquote> 
 <p>Hystrix默认降级时间为1秒钟<br> 配置降级时间:</p> 
 <p></p> 
</blockquote> 
<pre><code class="language-java">hystrix:
  command:
    default:
      execution.isolation.thread.timeoutInMilliseconds: 2000 # 单位毫秒</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8ab5db35f70dfd0e05582f425072fc56/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu20.04安装ROS2 Foxy</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b2b208c8b2b6dac8bbabd5c543952fa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是跨链桥？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>