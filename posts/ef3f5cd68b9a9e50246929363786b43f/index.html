<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MYSQL学习之buffer pool的理论学习 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MYSQL学习之buffer pool的理论学习" />
<meta property="og:description" content="MYSQL学习之buffer pool的理论学习 by 小乌龟
文章目录 MYSQL学习之buffer pool的理论学习一、buffer pool是什么？二、buffer pool 的内存结构三、buffer pool 的初始化和配置初始化配置 四、buffer pool 空间管理LRU淘汰法冷热数据分离的LRU算法 一、buffer pool是什么？ 我们都知道，MySQL的数据都是存储在磁盘空间中的，但是操作系统与磁盘的交互是比较耗时的，势必会影响MySQL的性能，如果要提高MySQL的性能，势必要解决交互的速度问题，为了解决这一问题，buffer pool 应运而生。buffer pool 是MySQL在内存中专门为自己开辟的内存空间，相当于数据缓存，主要目的是暂存一些使用频率较高的一些，以达到提高MySQL性能的。
二、buffer pool 的内存结构 buffer pool 中主要包含两部分：数据页和数据块，数据页主要存储MySQL的数据，数据块主要存储和数据也相关的信息，两者一一对应；
数据页：存储MySQL中的真实数据，每一页的默认大小为16KB。
数据块：存储数据页的页码，在buffer pool中的地址以及数据页所属的表空间等数据，大约为数据页大小的5%，816个字节左右。
三、buffer pool 的初始化和配置 初始化 1、MySQL 启动时，会根据参数 innodb_buffer_pool_size 的值来为 Buffer Pool 分配内存区域。
2、然后会按照缓存页的默认大小 16k 以及对应的描述数据块的 800个字节 左右大小，在 Buffer Pool 中划分中一个个的缓存页和一个个的描述数据库块。
此时的缓存页和描述数据块都是空的，毕竟才刚启动 MySQL 配置 ？
四、buffer pool 空间管理 缓冲池的大小是有限的，当数据页不断被复制到缓冲池中时，必然会出现溢出的情况，因此要存在相应的淘汰策略去不断淘汰到缓冲池中的数剧，同时还要保证常用的数据能够保存在缓冲池中。buffer pool采用LRU方法进行数据页的数据页的淘汰管理，（LRU，全称是 Least Recently Used，中文名字叫作「最近最少使用」）顾名思义，淘汰最近最少使用的数据页。
但是呢，如果基于此算法，当遇到全表扫描时，此时缓存池中会加载大量的新的数据页，从而将缓存池中的已存在的且被频繁访问的数据页替换出去，从而也影响了MySQL的性能，因此，基于冷热数据分离的LRU算法登场；
LRU淘汰法 首先，为了能够完成LRU算法，底层采用链表的形式存储数据的地址，链表中每一个节点存储的是该节点所指向数据页的地址（此节点也称为称为控制块），当有一个数据页被访问时，此节点会移动到表头，基于此算法，表尾的节点自然就成为了最少使用的节点，当要进行淘汰数据页操作时时，将表尾节点所指向的内存替换即可，同时删掉此链表的结尾结点。通常我们此链表称为LRU链表
1. 缓存页已在缓冲池中
这种情况下会将对应的缓存页放到 LRU 链表的头部，无需从磁盘再进行读取，也无需淘汰其它缓存页。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ef3f5cd68b9a9e50246929363786b43f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T16:50:20+08:00" />
<meta property="article:modified_time" content="2024-01-09T16:50:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MYSQL学习之buffer pool的理论学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="MYSQLbuffer_pool_0"></a>MYSQL学习之buffer pool的理论学习</h2> 
<blockquote> 
 <p>by 小乌龟</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#MYSQLbuffer_pool_0" rel="nofollow">MYSQL学习之buffer pool的理论学习</a></li><li><a href="#buffer_pool_6" rel="nofollow">一、buffer pool是什么？</a></li><li><a href="#buffer_pool__8" rel="nofollow">二、buffer pool 的内存结构</a></li><li><a href="#buffer_pool__15" rel="nofollow">三、buffer pool 的初始化和配置</a></li><li><ul><li><a href="#_16" rel="nofollow">初始化</a></li><li><a href="#_20" rel="nofollow">配置</a></li></ul> 
  </li><li><a href="#buffer_pool__22" rel="nofollow">四、buffer pool 空间管理</a></li><li><ul><li><a href="#LRU_25" rel="nofollow">LRU淘汰法</a></li><li><a href="#LRU_38" rel="nofollow">冷热数据分离的LRU算法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="buffer_pool_6"></a>一、buffer pool是什么？</h2> 
<p>我们都知道，MySQL的数据都是存储在磁盘空间中的，但是操作系统与磁盘的交互是比较耗时的，势必会影响MySQL的性能，如果要提高MySQL的性能，势必要解决交互的速度问题，为了解决这一问题，buffer pool 应运而生。buffer pool 是MySQL在内存中专门为自己开辟的内存空间，相当于数据缓存，主要目的是暂存一些使用频率较高的一些，以达到提高MySQL性能的。</p> 
<h2><a id="buffer_pool__8"></a>二、buffer pool 的内存结构</h2> 
<p>buffer pool 中主要包含两部分：数据页和数据块，数据页主要存储MySQL的数据，数据块主要存储和数据也相关的信息，两者一一对应；</p> 
<ul><li> <p>数据页：存储MySQL中的真实数据，每一页的默认大小为16KB。</p> </li><li> <p>数据块：存储数据页的页码，在buffer pool中的地址以及数据页所属的表空间等数据，大约为数据页大小的5%，816个字节左右。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/2c/14/YKaTxwUK_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="buffer_pool__15"></a>三、buffer pool 的初始化和配置</h2> 
<h3><a id="_16"></a>初始化</h3> 
<p>1、MySQL 启动时，会根据参数 <code>innodb_buffer_pool_size</code> 的值来为 Buffer Pool 分配内存区域。<br> 2、然后会按照缓存页的默认大小 16k 以及对应的描述数据块的 800个字节 左右大小，在 Buffer Pool 中划分中一个个的缓存页和一个个的描述数据库块。<br> <strong><code>此时的缓存页和描述数据块都是空的，毕竟才刚启动 MySQL </code></strong></p> 
<h3><a id="_20"></a>配置</h3> 
<p>？</p> 
<h2><a id="buffer_pool__22"></a>四、buffer pool 空间管理</h2> 
<p>缓冲池的大小是有限的，当数据页不断被复制到缓冲池中时，必然会出现溢出的情况，因此要存在相应的淘汰策略去不断淘汰到缓冲池中的数剧，同时还要保证常用的数据能够保存在缓冲池中。buffer pool采用LRU方法进行数据页的数据页的淘汰管理，（LRU，全称是 Least Recently Used，中文名字叫作「最近最少使用」）顾名思义，淘汰最近最少使用的数据页。<br> 但是呢，如果基于此算法，当遇到全表扫描时，此时缓存池中会加载大量的新的数据页，从而将缓存池中的已存在的且被频繁访问的数据页替换出去，从而也影响了MySQL的性能，因此，基于<code>冷热数据分离的LRU算法</code>登场；</p> 
<h3><a id="LRU_25"></a>LRU淘汰法</h3> 
<p>首先，为了能够完成LRU算法，底层采用链表的形式存储数据的地址，链表中每一个节点存储的是该节点所指向数据页的地址（此节点也称为称为控制块），当有一个数据页被访问时，此节点会移动到表头，基于此算法，表尾的节点自然就成为了最少使用的节点，当要进行淘汰数据页操作时时，将表尾节点所指向的内存替换即可，同时删掉此链表的结尾结点。通常我们此链表称为LRU链表</p> 
<p><strong>1. 缓存页已在缓冲池中</strong><br> 这种情况下会将对应的缓存页放到 LRU 链表的头部，无需从磁盘再进行读取，也无需淘汰其它缓存页。</p> 
<p>如下图所示，如果要访问的数据在 6 号页中，则将 6 号页放到链表头部即可，这种情况下没有缓存页被淘汰。<br> <img src="https://images2.imgbox.com/59/5f/9v2u7gVh_o.png" alt="在这里插入图片描述"><br> <strong>2. 缓存页不在缓冲池中</strong><br> 缓存页不在缓冲中，这时候就需要从磁盘中读入对应的数据页，将其放置在链表头部，同时淘汰掉末尾的缓存页</p> 
<p>如下图所示，如果要访问的数据在 60 号页中，60 号页不在缓冲池中，此时加载进来放到链表的头部，同时淘汰掉末尾的 17 号缓存页。<br> <img src="https://images2.imgbox.com/81/cc/mn1zEknN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="LRU_38"></a>冷热数据分离的LRU算法</h3> 
<p>冷人数据分离的LRU算法就是将 LRU 链表分为两部分，一部分为热数据区域，一部分为冷数据区域。<br> <img src="https://images2.imgbox.com/74/0f/02Zjcwa0_o.png" alt="在这里插入图片描述"><br> 当数据页第一次被加载到缓冲池中的时候，先将其放到冷数据区域的链表头部，1s（由 <code>innodb_old_blocks_time</code> 参数控制） 后该缓存页被访问了再将其移至热数据区域的链表头部。<br> <img src="https://images2.imgbox.com/2f/77/SwPUvO3Z_o.png" alt="在这里插入图片描述"><br> 基于此算法，当遇到全表扫描时，新数据只会在冷数据区进行频繁的淘汰替换，并不会全部占满缓冲池，因此有效的保证了其他真正频繁被使用的数据；那么为什么是大于1秒呢？要知道，缓冲区中冷数据替换是相对较快的，如果大于了1s后又被访问到，说明此数据有足够的的资格被列为频繁被访问的数据。就好像我们高中时后的尖子生班和中等班的流动名额，尖子升班最后几名的是替换的非常快的，如果最后几名中有一名同学在经过很多轮的考试后，依然挺拔且坚定的的矗立在尖子上里，即使是在最后的角落里，那么此同学是不是也是一名强者,有资格被认定为尖子生！！（为尖子生鼓掌）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d92ffed25265adaa6c50db711d692c84/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue中＜router-view＞使用详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a6b815cb02c5deb516fd06eb04ff7704/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MyBatis】#{}和${} | 数据库连接池</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>