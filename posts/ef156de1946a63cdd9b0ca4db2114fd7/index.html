<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之抽象工厂设计模式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式之抽象工厂设计模式" />
<meta property="og:description" content="1.介绍 抽象工厂模式是一种软件设计模式，它提供了一种创建一系列相关或依赖对象的方式，而无需指定具体类。它将抽象工厂和具体工厂的实现分离开来，使得客户端和工厂的实现分离开来。该模式使得系统更具有灵活性和可扩展性，能够从更高的层面来管理对象的创建。
在抽象工厂模式中，抽象工厂定义了创建一系列相关对象的接口，每个具体工厂则实现了这些接口并负责创建相应的具体对象。这些具体工厂类应该能够创建与其主题相关的对象，并且应该具有相同的接口以便于客户端调用。客户端只需要知道抽象工厂提供的接口，并且不需要知道具体的实现。
抽象工厂模式常用于需要创建一组相关对象的情况，比如需要创建一组具有相同主题的界面元素。相比于简单工厂模式，抽象工厂模式更加抽象化和灵活，也更加复杂。
2.解决问题 抽象工厂模式主要解决的问题是一个系统需要一些有关联的产品对象，这些对象之间有一定的约束关系，不仅需要创建这些对象，而且需要保证它们之间的约束关系正确。
在这种情况下，使用抽象工厂模式可以将这些对象的创建过程分离出来，使得客户端不需要直接面对对象创建的复杂性，也不需要了解这些对象之间的约束关系。客户端只需要向抽象工厂对象发出请求，抽象工厂再负责创建符合约束关系的对象。
同时，抽象工厂模式还可以让系统更加灵活。例如，如果需要添加一种新的产品对象或者更改产品对象的约束关系，只需要实现一个新的具体工厂即可，而不需要修改客户端的代码。
总之，抽象工厂模式可以有效地解决多个相关对象的创建问题，并且可以让系统更加灵活、可扩展，使得客户端使用起来更加方便。
废话不多说，开整~
1.创建一个水果类和产地接口
/** * @Author: mark * @Description: 水果接口 * @Date: 2023/06/08/10:06 * @Version: 1.0 */ public interface Fruit { void choice(); } /** * @Author: mark * @Description: 产地接口 * @Date: 2023/06/08/10:12 * @Version: 1.0 */ public interface Place { void placeIn(); } 2.并各自实现水果和产地接口
/** * @Author: mark * @Description: TODO * @Date: 2023/06/08/10:08 * @Version: 1.0 */ public class Apple implements Fruit { @Override public void choice() { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ef156de1946a63cdd9b0ca4db2114fd7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-12T17:17:44+08:00" />
<meta property="article:modified_time" content="2023-06-12T17:17:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之抽象工厂设计模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1.介绍</h4> 
<p>    抽象工厂模式是一种软件设计模式，它提供了一种创建一系列相关或依赖对象的方式，而无需指定具体类。它将抽象工厂和具体工厂的实现分离开来，使得客户端和工厂的实现分离开来。该模式使得系统更具有灵活性和可扩展性，能够从更高的层面来管理对象的创建。<br> 在抽象工厂模式中，抽象工厂定义了创建一系列相关对象的接口，每个具体工厂则实现了这些接口并负责创建相应的具体对象。这些具体工厂类应该能够创建与其主题相关的对象，并且应该具有相同的接口以便于客户端调用。客户端只需要知道抽象工厂提供的接口，并且不需要知道具体的实现。<br> 抽象工厂模式常用于需要创建一组相关对象的情况，比如需要创建一组具有相同主题的界面元素。相比于简单工厂模式，抽象工厂模式更加抽象化和灵活，也更加复杂。</p> 
<p></p> 
<p></p> 
<h4>2.解决问题</h4> 
<p>抽象工厂模式主要解决的问题是一个系统需要一些有关联的产品对象，这些对象之间有一定的约束关系，不仅需要创建这些对象，而且需要保证它们之间的约束关系正确。<br> 在这种情况下，使用抽象工厂模式可以将这些对象的创建过程分离出来，使得客户端不需要直接面对对象创建的复杂性，也不需要了解这些对象之间的约束关系。客户端只需要向抽象工厂对象发出请求，抽象工厂再负责创建符合约束关系的对象。<br> 同时，抽象工厂模式还可以让系统更加灵活。例如，如果需要添加一种新的产品对象或者更改产品对象的约束关系，只需要实现一个新的具体工厂即可，而不需要修改客户端的代码。<br> 总之，抽象工厂模式可以有效地解决多个相关对象的创建问题，并且可以让系统更加灵活、可扩展，使得客户端使用起来更加方便。</p> 
<p>废话不多说，开整~</p> 
<p>1.创建一个水果类和产地接口</p> 
<pre><code>/**
 * @Author: mark
 * @Description: 水果接口
 * @Date: 2023/06/08/10:06
 * @Version: 1.0
 */
public interface Fruit {

    void choice();

}</code></pre> 
<pre><code>/**
 * @Author: mark
 * @Description: 产地接口
 * @Date: 2023/06/08/10:12
 * @Version: 1.0
 */
public interface Place {

    void placeIn();

}</code></pre> 
<p>2.并各自实现水果和产地接口</p> 
<pre><code>/**
 * @Author: mark
 * @Description: TODO
 * @Date: 2023/06/08/10:08
 * @Version: 1.0
 */
public class Apple implements Fruit {
    @Override
    public void choice() {
        System.out.print("this is apple==========&gt;");
    }
}</code></pre> 
<pre><code>/**
 * @Author: mark
 * @Description: TODO
 * @Date: 2023/06/08/10:08
 * @Version: 1.0
 */
public class Banana implements Fruit {
    @Override
    public void choice() {
        System.out.print("this is banana==========&gt;");
    }
}</code></pre> 
<pre><code>/**
 * @Author: mark
 * @Description: TODO
 * @Date: 2023/06/08/10:08
 * @Version: 1.0
 */
public class Pear implements Fruit {
    @Override
    public void choice() {
        System.out.print("this is Pear==========&gt;");
    }
}</code></pre> 
<pre><code>/**
 * @Author: mark
 * @Description: TODO
 * @Date: 2023/06/08/10:13
 * @Version: 1.0
 */
public class China implements Place {
    @Override
    public void placeIn() {
        System.out.println("make in China");
    }
}
</code></pre> 
<pre><code>/**
 * @Author: mark
 * @Description: TODO
 * @Date: 2023/06/08/10:13
 * @Version: 1.0
 */
public class Japan implements Place {
    @Override
    public void placeIn() {
        System.out.println("make in japan");
    }
}</code></pre> 
<pre><code>/**
 * @Author: mark
 * @Description: TODO
 * @Date: 2023/06/08/10:13
 * @Version: 1.0
 */
public class Usa implements Place {
    @Override
    public void placeIn() {
        System.out.println("make in Usa");
    }
}</code></pre> 
<p>3. 为水果和产地创建抽象工厂类</p> 
<pre><code>/**
 * @Author: mark
 * @Description: 为水果和产地创建抽象工厂类
 * @Date: 2023/06/08/10:16
 * @Version: 1.0
 */
public abstract class AbstractFactory {

    public abstract Fruit getFruit(String fruit);
    public abstract Place getPlace(String fruit);

}</code></pre> 
<p>4.创建水果工厂 和产地并继承抽象工厂类</p> 
<pre><code class="hljs">/**
 * @Author: mark
 * @Description: 创建水果工厂 并继承抽象工厂类
 * @Date: 2023/06/08/10:18
 * @Version: 1.0
 */
public class FruitFactory extends AbstractFactory{
    @Override
    public Fruit getFruit(String fruit) {
        if (fruit.equals("apple")){
            return new Apple();
        }
        if (fruit.equals("pear")){
            return new Pear();
        }
        if (fruit.equals("banana")){
            return new Banana();
        }
        return null;
    }

    @Override
    public Place getPlace(String fruit) {
        return null;
    }
}
</code></pre> 
<pre><code class="hljs">/**
 * @Author: mark
 * @Description: 创建产地工厂
 * @Date: 2023/06/08/10:20
 * @Version: 1.0
 */
public class PlaceFactory extends AbstractFactory{
    @Override
    public Fruit getFruit(String fruit) {
        return null;
    }

    @Override
    public Place getPlace(String fruit) {
        if (fruit.equals("apple")){
            return new Japan();
        }
        if (fruit.equals("pear")){
            return new Usa();
        }
        if (fruit.equals("banana")){
            return new China();
        }
        return null;
    }
}</code></pre> 
<p>5.创建一个工厂的生成器 通过传参来选择需要的工厂</p> 
<pre><code class="hljs">/**
 * @Author: mark
 * @Description: 创建一个工厂的生成器 通过传参来选择需要的工厂
 * @Date: 2023/06/08/10:26
 * @Version: 1.0
 */
public class ProduceFactory {

    public static AbstractFactory getFactory(String param){
        if (param.equals("place")){
            return new PlaceFactory();
        }
        if (param.equals("fruit")){
            return new FruitFactory();
        }
        return null;
    }
</code></pre> 
<p>接下来小测一下</p> 
<p></p> 
<pre><code class="hljs">
    //使用ProduceFactory来获取AbstractFactory，通过传递类型信息获取实体类对象

    public static void main(String[] args) {
        //获取水果工厂
        AbstractFactory fruit = ProduceFactory.getFactory("fruit");
        //获取apple对象
        Fruit apple = fruit.getFruit("apple");
        apple.choice();
        //获取产地工厂
        AbstractFactory place= ProduceFactory.getFactory("place");
        place.getPlace("apple").placeIn();
        //===================example========================
        Fruit pear = fruit.getFruit("pear");
        pear.choice();
        place.getPlace("pear").placeIn();

        Fruit banana = fruit.getFruit("banana");
        banana.choice();
        place.getPlace("banana").placeIn();
    }</code></pre> 
<p><img alt="" height="142" src="https://images2.imgbox.com/35/d3/ea5Dgfet_o.png" width="552"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f093ca48ed16fbb282f43f234d5c0b2e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">正点原子IMX6ULL阿尔法开发板点亮LED</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74b1915fd4df55c23976031559450b9d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">COMSOL这几种常见的数据处理，你都会吗？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>