<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HTTP 协议 与 golang web 应用服务 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HTTP 协议 与 golang web 应用服务" />
<meta property="og:description" content="HTTP 协议 与 golang web 应用服务 本文仅是介绍 golang web 应用与服务的 hello world 的工作原理，开发工具等。
本文要点： 1. 分布式计算 “C/S架构”知识 2. HTTP 协议基础知识；协议分析工具 curl 3. Golang web 应用搭建、工作原理、源代码阅读、程序设计技巧 4. Web 应用框架，压力测试工具 ab
前提条件： 1. OO 思想在 Golang 应用 2. OS 并发基础知识 3. 了解 socket 通讯与 stream 4. 了解 python tornado 框架、Java web 应用服务器框架最好
本文档代码位置：https://github.com/pmlpml/golang-learning/tree/master/web
1、C/S 架构 在分布式计算中，计算机之间协作最基础、最简单的结构就是 C/S 架构 。一个 进程 扮演 Server 提供服务，一个或多个 进程 扮演 Client 发起服务请求。C/S架构（ Client–Server model ）应用及其广泛，从关系数据库服务、到web应用、电子邮局、FTP服务、以及我们现在见到的大多数 云服务 都是C/S架构应用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2a1b4c6ec1cfd3ced102cde351e2dcea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-31T16:25:25+08:00" />
<meta property="article:modified_time" content="2017-10-31T16:25:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTTP 协议 与 golang web 应用服务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="http-协议-与-golang-web-应用服务">HTTP 协议 与 golang web 应用服务</h3> 
<p>本文仅是介绍 golang web 应用与服务的 hello world 的工作原理，开发工具等。</p> 
<blockquote> 
 <p>本文要点： <br> 1. 分布式计算 “C/S架构”知识 <br> 2. HTTP 协议基础知识；协议分析工具 curl <br> 3. Golang web 应用搭建、工作原理、源代码阅读、程序设计技巧 <br> 4. Web 应用框架，压力测试工具 ab</p> 
 <p>前提条件： <br> 1. OO 思想在 Golang 应用 <br> 2. OS 并发基础知识 <br> 3. 了解 socket 通讯与 stream <br> 4. 了解 python tornado 框架、Java web 应用服务器框架最好</p> 
</blockquote> 
<p>本文档代码位置：<a href="https://github.com/pmlpml/golang-learning/tree/master/web">https://github.com/pmlpml/golang-learning/tree/master/web</a></p> 
<h4 id="1cs-架构">1、C/S 架构</h4> 
<p>在分布式计算中，计算机之间协作最基础、最简单的结构就是 C/S 架构 。一个 <strong>进程</strong> 扮演 Server 提供服务，一个或多个 <strong>进程</strong> 扮演 Client 发起服务请求。C/S架构（ <a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model" rel="nofollow">Client–Server model</a> ）应用及其广泛，从关系数据库服务、到web应用、电子邮局、FTP服务、以及我们现在见到的大多数 云服务 都是C/S架构应用。</p> 
<p>C/S架构通讯模型如图所示：</p> 
<pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-literal">+</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>           <span class="hljs-comment">Request</span> <span class="hljs-literal">-</span>&gt;             <span class="hljs-literal">+</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>
<span class="hljs-comment">|</span>          <span class="hljs-comment">|</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt;<span class="hljs-comment">|</span>          <span class="hljs-comment">|</span>
<span class="hljs-comment">|</span>  <span class="hljs-comment">Client</span>  <span class="hljs-comment">|</span>                                  <span class="hljs-comment">|</span>  <span class="hljs-comment">Server</span>  <span class="hljs-comment">|</span>
<span class="hljs-comment">|</span>          <span class="hljs-comment">|</span>&lt;<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">|</span>          <span class="hljs-comment">|</span>
<span class="hljs-literal">+</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>           &lt;<span class="hljs-literal">-</span> <span class="hljs-comment">Response</span>            <span class="hljs-literal">+</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span></code></pre> 
<p>这里，我们看出C/S架构通讯非常简单。如同 client 问“你吃过了吗？”，server 回答“吃了红烧肉”，但是，server 不能主动反问“你吃了吗？”。 问题是为什么要做这样的限制…… <br> 当然，在许多应用中也需要突破这样的限制，于是就有了一些辅助技术手段… 例如 <a href="https://en.wikipedia.org/wiki/WebSocket" rel="nofollow">websocket</a></p> 
<p>C/S架构编程手段很多，用socket直接编程不是很方便吗？如果仅编写一个没有任何工业用途的 “toy” 程序，可以这样做。 但是，一个好的服务程序，必须满足 <strong>高可靠</strong>、<strong>高可用（7*24）</strong> 、<strong>高性能</strong> 、<strong>可伸缩</strong> 、<strong>高开发效率</strong> 、<strong>安全</strong> 、<strong>可扩展</strong> 等特性。例如，做一个服务全球的订票服务系统开发，就必须支持这些特性。 基于 HTTP 协议的 web service，不仅开发简单，而且能满足产业界的要求，随着“云服务”技术的发展，近几年大规模普及。</p> 
<h4 id="2http-协议基础">2、HTTP 协议基础</h4> 
<blockquote> 
 <p>The <strong>Hypertext Transfer Protocol</strong> ( <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" rel="nofollow">HTTP</a> ) is an application protocol for distributed, collaborative, hypermedia information systems.</p> 
</blockquote> 
<p>HTTP 协议是一个复杂的协议， 支持虚拟主机、消息路由（负载均衡）、分段下载、缓存服务、安全认证等等。 HTTP 也是非常简单文本协议。 客户端与服务器建立 TCP 连接后，客户端发出 Request 文本， 服务器端返回 Response 文本。</p> 
<p>HTTP 是应用层协议，传输建立在传输层 TCP 协议基础之上。 例如：用户在浏览器中输入 <code>http://www.sysu.edu.cn/</code> 浏览器与服务器之间发生了什么呢？</p> 
<ol><li>浏览器：请求 DNS 解析 <code>www.sysu.edu.cn</code> 得到 <code>121.46.26.52</code></li><li>浏览器：用 socket 与 服务器 <code>121.46.26.52:80</code> 发起 <code>TCP</code> 连接请求</li><li>服务器：<code>Accept</code> 客户端请求，建立该连接</li><li>浏览器：向服务器写信息（<strong>字符流</strong>），Request</li><li>服务器：按浏览器的请求，返回客户端信息（<strong>字符流</strong>）Response</li><li>浏览器：断开连接，让双方释放资源</li></ol> 
<p>其中: Request 与 Response 的约定，就是 HTTP 协议。 HTTP/1.1 标准就是 <a href="https://tools.ietf.org/html/rfc2616" rel="nofollow">RFC 2616</a>。</p> 
<h5 id="21-http-协议基本格式">2.1 HTTP 协议基本格式</h5> 
<p><strong>Request 文本格式</strong></p> 
<p>它是三段式的文本（命令行、header、body）</p> 
<pre class="prettyprint"><code class=" hljs r">GET / HTTP/<span class="hljs-number">1.1</span>              <span class="hljs-comment">#第一行：第一个单词 - 方法；第二个单词 - uri； 协议与版本     </span>
Host: www.example.com       <span class="hljs-comment">#第2-n行，都是  key:value 格式，称为 headers</span>
<span class="hljs-keyword">...</span>
CRLF                        <span class="hljs-comment">#header 结束标识</span>
message-body                <span class="hljs-comment">#按heahder指令处理</span></code></pre> 
<p><strong>Request methods</strong></p> 
<p>Request第一行第一个单词（ <strong>大写</strong> ）， 例如 GET、HEAD、POST、PUT、DELETE等。</p> 
<ul><li>GET 读取 uri 指向的信息</li><li>HEAD 查询 uri 指向的信息</li><li>PUT 写入 uri 指向的信息</li><li>DELETE 写入 uri 指向的信息</li><li>POST 提交表单</li></ul> 
<p><strong>URI &amp; URL</strong></p> 
<p>统一资源标识（URI），即要访问对象（文件）的路径和参数</p> 
<p>统一资源定位符（URL）。例如：</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.baidu.com/s</span>?ie=utf-<span class="hljs-number">8</span>&amp;wd=toy

协议<span class="hljs-symbol">://</span>主机/文件路径<span class="hljs-comment">#标签?查询字符串</span></code></pre> 
<p><strong>Header</strong></p> 
<p>那就不是几句话能搞定的问题，HTTP的服务功能约定几乎全部由头的语义定义。例如：</p> 
<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">Host:</span> www<span class="hljs-preprocessor">.example</span><span class="hljs-preprocessor">.com</span></code></pre> 
<p>表示这台服务器上，叫 www.example.com 域名的 web 服务提供服务，这样实现了一台服务器，一个 IP 地址支持多个域名的 web 应用。当 Apache， Nginx 等服务器收到这个指令，应用把请求交给指定域的服务。</p> 
<p>更多Head的信息参考：<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" rel="nofollow">List of HTTP header fields</a></p> 
<p>又例如，服务器怎么知道的用的手机的型号、操作系统、浏览器类型？</p> 
<pre class="prettyprint"><code class=" hljs r">User-Agent: <span class="hljs-keyword">...</span></code></pre> 
<p>然后，你又问，如何多线程下载呢？ 那需要知道 Resopnse 的 headers</p> 
<p><strong>Response 文本格式</strong></p> 
<p>也是同样的三段式（状态行、headers、body），例如：</p> 
<pre class="prettyprint"><code class=" hljs http"><span class="hljs-status">HTTP/1.1 <span class="hljs-number">200</span> OK</span>
<span class="hljs-attribute">Date</span>: <span class="hljs-string">Mon, 23 May 2005 22:38:34 GMT</span>
<span class="hljs-attribute">Server</span>: <span class="hljs-string">Apache/1.3.3.7 (Unix) (Red-Hat/Linux)</span>
<span class="hljs-attribute">Last-Modified</span>: <span class="hljs-string">Wed, 08 Jan 2003 23:11:55 GMT</span>
<span class="hljs-attribute">ETag</span>: <span class="hljs-string">"3f80f-1b6-3e1cb03b"</span>
<span class="hljs-attribute">Content-Type</span>: <span class="hljs-string">text/html; charset=UTF-8</span>
<span class="hljs-attribute">Content-Length</span>: <span class="hljs-string">138</span>
<span class="hljs-attribute">Accept-Ranges</span>: <span class="hljs-string">bytes</span>
<span class="hljs-attribute">Connection</span>: <span class="hljs-string">close</span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>An Example Page<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
  Hello World, this is a very simple HTML document.
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></span></code></pre> 
<p><strong>返回状态</strong></p> 
<p>第一行：协议，状态编码，状态名称。</p> 
<ul><li>1xx Informational responses</li><li>2xx Success <br> 
  <ul><li>200 OK</li><li>204 No Content</li></ul></li><li>3xx Redirection <br> 
  <ul><li>301 Moved Permanently</li></ul></li><li>4xx Client errors <br> 
  <ul><li>403 Forbidden</li><li>404 Not Found</li></ul></li><li>5xx Server errors <br> 
  <ul><li>500 Internal Server Error</li><li>501 Not Implemented</li></ul></li></ul> 
<p>更多参见：<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" rel="nofollow">List of HTTP status codes</a></p> 
<p><strong>Header</strong></p> 
<p>更多Head的信息参考：<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" rel="nofollow">List of HTTP header fields</a></p> 
<p><strong>Query String</strong></p> 
<p>URL的查询字符串是“？”后面以“&amp;”分割的若干 K = V 对。或者 POST 请求正文部分内容。</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.baidu.com/s</span>?ie=utf-<span class="hljs-number">8</span>&amp;wd=toy

协议<span class="hljs-symbol">://</span>主机/文件路径<span class="hljs-comment">#标签?查询字符串</span></code></pre> 
<h5 id="22-http-协议工具">2.2 HTTP 协议工具</h5> 
<p><strong>浏览器</strong></p> 
<p>几乎所有现代浏览器都自带开发者工具，Network 标签就是！</p> 
<p><em>实验：</em> 访问 <code>http://www.sysu.edu.cn/</code> , 请问：</p> 
<ul><li>这个网页总共发出多少次请求？</li><li>访问 <code>/2012/cn/index.htm</code> 的 Request 和 response 的 Headers 是？</li><li>User-Agent 的内容是？</li></ul> 
<p><strong>curl</strong></p> 
<p>curl 才是 web 开发者最常用的利器。它是一个控制台程序，可以精确控制 HTTP 请求的每一个细节。实战中，配合 shell 程序，我们可以简单，重复给服务器发送不同的请求序列，调试程序或分析输出。curl 是 linux 系统自带的命令行工具。</p> 
<p><em>实验：</em> 用 curl 访问 <code>http://www.sysu.edu.cn/</code></p> 
<pre class="prettyprint"><code class=" hljs r">$curl -v http://www.sysu.edu.cn/
* About to connect() to www.sysu.edu.cn port <span class="hljs-number">80</span> (<span class="hljs-comment">#0)</span>
*   Trying <span class="hljs-number">121.46</span><span class="hljs-number">.26</span><span class="hljs-number">.52</span><span class="hljs-keyword">...</span>
* Connected to www.sysu.edu.cn (<span class="hljs-number">121.46</span><span class="hljs-number">.26</span><span class="hljs-number">.52</span>) port <span class="hljs-number">80</span> (<span class="hljs-comment">#0)</span>
&gt; GET / HTTP/<span class="hljs-number">1.1</span>
&gt; User-Agent: curl/<span class="hljs-number">7.29</span><span class="hljs-number">.0</span>
&gt; Host: www.sysu.edu.cn
&gt; Accept: */*
&gt;
&lt; HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
&lt; Vary: Accept-Encoding
&lt; Content-Type: text/html
&lt; Accept-Ranges: bytes
&lt; ETag: <span class="hljs-string">"974272193"</span>
&lt; Last-Modified: Thu, <span class="hljs-number">11</span> Apr <span class="hljs-number">2013</span> <span class="hljs-number">06</span>:<span class="hljs-number">43</span>:<span class="hljs-number">52</span> GMT
&lt; Content-Length: <span class="hljs-number">357</span>
&lt; Date: Sun, <span class="hljs-number">29</span> Oct <span class="hljs-number">2017</span> <span class="hljs-number">13</span>:<span class="hljs-number">53</span>:<span class="hljs-number">00</span> GMT
&lt; Server: lighttpd/<span class="hljs-number">1.4</span><span class="hljs-number">.35</span>
&lt;
&lt;!DOCTYPE html PUBLIC <span class="hljs-string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="hljs-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span>&gt;
&lt;html xmlns=<span class="hljs-string">"http://www.w3.org/1999/xhtml"</span>&gt;
&lt;head&gt;
&lt;meta http-equiv=<span class="hljs-string">"refresh"</span> content=<span class="hljs-string">"0;url=/2012"</span>&gt;
&lt;meta http-equiv=<span class="hljs-string">"Content-Type"</span> content=<span class="hljs-string">"text/html; charset=utf-8"</span> /&gt;
&lt;title&gt;中山大学 SUN YAT-SEN UNIVERSITY&lt;/title&gt;


&lt;/html&gt;
* Connection <span class="hljs-comment">#0 to host www.sysu.edu.cn left intact</span></code></pre> 
<p>curl 才是你未来的工具，浏览器工具是给前端大神玩的，系统工程师表示不屑任何复杂的玩意。这多简单：</p> 
<p>第一个符号</p> 
<ul><li><code>*</code> 表示 curl 任务；</li><li><code>&gt;</code> 发送的信息;</li><li><code>&lt;</code> 返回的信息</li></ul> 
<p>请问：</p> 
<ul><li>中大 web 服务器是什么软件</li><li>这是中大的首页吗？</li></ul> 
<h4 id="3编写简单的-web-应用">3、编写简单的 web 应用</h4> 
<p>本部分任务是通过 golang 的 http 包编写简单程序，了解 web 服务器处理 http 协议的过程。</p> 
<h5 id="31-搭建简单-web-服务器">3.1 搭建简单 web 服务器</h5> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"net/http"</span>
    <span class="hljs-string">"strings"</span>
    <span class="hljs-string">"log"</span>
)

<span class="hljs-keyword">func</span> sayhelloName(w http.ResponseWriter, r *http.Request) {
    r.ParseForm()  <span class="hljs-comment">//解析参数，默认是不会解析的</span>
    fmt.Println(r.Form)  <span class="hljs-comment">//这些信息是输出到服务器端的打印信息</span>
    fmt.Println(<span class="hljs-string">"path"</span>, r.URL.Path)
    fmt.Println(<span class="hljs-string">"scheme"</span>, r.URL.Scheme)
    fmt.Println(r.Form[<span class="hljs-string">"url_long"</span>])
    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form {
        fmt.Println(<span class="hljs-string">"key:"</span>, k)
        fmt.Println(<span class="hljs-string">"val:"</span>, strings.Join(v, <span class="hljs-string">""</span>))
    }
    fmt.Fprintf(w, <span class="hljs-string">"Hello astaxie!"</span>) <span class="hljs-comment">//这个写入到w的是输出到客户端的</span>
}

<span class="hljs-keyword">func</span> main() {
    http.HandleFunc(<span class="hljs-string">"/"</span>, sayhelloName)       <span class="hljs-comment">//设置访问的路由</span>
    err := http.ListenAndServe(<span class="hljs-string">":9090"</span>, <span class="hljs-constant">nil</span>) <span class="hljs-comment">//设置监听的端口</span>
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        log.Fatal(<span class="hljs-string">"ListenAndServe: "</span>, err)
    }
}</code></pre> 
<p>用 <code>go run</code> 运行它！ 这个时候其实已经在9090端口监听http链接请求了。</p> 
<p>打开另一个控制台，用 <code>curl -v http://localhost/</code> 看结果。</p> 
<pre class="prettyprint"><code class=" hljs markdown">$ curl -v http://localhost:9090/
<span class="hljs-bullet">* </span>About to connect() to localhost port 9090 (#0)
<span class="hljs-bullet">*   </span>Trying ::1...
<span class="hljs-bullet">* </span>Connected to localhost (::1) port 9090 (#0)
<span class="hljs-blockquote">&gt; GET / HTTP/1.1</span>
<span class="hljs-blockquote">&gt; User-Agent: curl/7.29.0</span>
<span class="hljs-blockquote">&gt; Host: localhost:9090</span>
<span class="hljs-blockquote">&gt; Accept: */*</span>
<span class="hljs-blockquote">&gt;
&lt; HTTP/1.1 200 OK</span>
<span class="xml"><span class="hljs-tag">&lt; <span class="hljs-attribute">Date:</span> <span class="hljs-attribute">Sun</span>, <span class="hljs-attribute">29</span> <span class="hljs-attribute">Oct</span> <span class="hljs-attribute">2017</span> <span class="hljs-attribute">23:39:11</span> <span class="hljs-attribute">GMT</span>
&lt; <span class="hljs-attribute">Content-Length:</span> <span class="hljs-attribute">14</span>
&lt; <span class="hljs-attribute">Content-Type:</span> <span class="hljs-attribute">text</span>/<span class="hljs-attribute">plain</span>; <span class="hljs-attribute">charset</span>=<span class="hljs-value">utf-8</span>
&lt;
* <span class="hljs-attribute">Connection</span> #<span class="hljs-attribute">0</span> <span class="hljs-attribute">to</span> <span class="hljs-attribute">host</span> <span class="hljs-attribute">localhost</span> <span class="hljs-attribute">left</span> <span class="hljs-attribute">intact</span></span></span></code></pre> 
<p>可以换一个地址试试：<code>http://localhost:9090/?url_long=111&amp;url_long=222</code></p> 
<p>上面的代码，要编写一个Web服务器很简单，只要调用http包的两个函数就可以了。</p> 
<blockquote> 
 <p>如果你以前是PHP程序员，那你也许就会问，我们的nginx、apache服务器不需要吗？Go就是不需要这些，因为他直接就监听tcp端口了，做了nginx做的事情，然后sayhelloName这个其实就是我们写的逻辑函数了，跟php里面的控制层（controller）函数类似。 <br> 如果你以前是Python程序员，那么你一定听说过tornado，这个代码和他是不是很像，对，没错，Go就是拥有类似Python这样动态语言的特性，写Web应用很方便。 <br> 如果你以前是Ruby程序员，会发现和ROR的/script/server启动有点类似。</p> 
</blockquote> 
<p>我们看到Go通过简单的几行代码就已经运行起来一个Web服务了，而且这个Web服务内部有支持高并发的特性。</p> 
<p>难道有了 go， Nginx、Apache，Lighttpd 就和我们 bye-bye 了？ <br> – “Too Young, too naive”</p> 
<h5 id="32-http-服务器运行机制">3.2 HTTP 服务器运行机制</h5> 
<p><strong>Web服务的工作模式的流程</strong> 图：</p> 
<p><img src="https://images2.imgbox.com/fc/d0/DLz5YSn6_o.png" alt="Web服务" title=""></p> 
<ol><li>创建一个 ServerSocket，绑定 地址和端口，侦听。等待客户端连接；</li><li>客户端创建 Socket， 连接</li><li>服务端 Accept，生成对应的 Socket <br> 
  <ul><li>如果你网络课编写过 Socket 通讯，认为简单那就错了！</li><li>服务器要服务 100K+ 的连接，可以吗？ 需要知道 <a href="https://en.wikipedia.org/wiki/Epoll" rel="nofollow">epoll</a> 或 iocp ，即 non-block 通讯！</li><li>当然，你现在可以忽视它们，因为几乎所有 web 服务器都使用了它们。</li></ul></li><li>与客户端通讯的 FD 有了，建立端对端通讯的方案有（以下名词可能让你迷惑）： <br> 
  <ul><li>进程服务客户（典型 FastCGI）</li><li>线程（典型 Java web 服务，如 Tomcat）</li><li>协程 + 异步回调（典型 nodejs）</li><li>或单进程阻塞应用（python tornado） + WSGI</li></ul></li><li>端对端处理一个 Request 与 Response</li></ol> 
<p><strong>web工作方式的几个概念</strong></p> 
<p>你暂时可以不用了解分布式技术的细节，以下是服务器端的几个重要概念：</p> 
<ul><li>Request：用户请求的信息，用来解析用户的请求信息，包括post、get、cookie、url等信息</li><li>Response：服务器需要反馈给客户端的信息</li><li>Conn：用户的每次请求链接</li><li>Handler：处理请求和生成返回信息的处理逻辑</li></ul> 
<h5 id="33-golang-处理-http-请求的过程">3.3 golang 处理 HTTP 请求的过程</h5> 
<p>本部分是学习 http 包的一些代码，同时学习面向对象的一些技巧。在应用中学习…</p> 
<p><strong>接口回调技术</strong></p> 
<p>按 <code>ctrl</code> 键点函数名<code>ListenAndServe</code>：</p> 
<p>这个函数和 Cobra 的 Execcute 类似，创建默认的 Server 数据，调用它的同名方法。 <br> 其中，<code>Handler</code> 是一个接口</p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-comment">// A Handler responds to an HTTP request.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// ServeHTTP should write reply headers and data to the ResponseWriter</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> {
    ServeHTTP(ResponseWriter, *Request)
}</code></pre> 
<p>为了解耦（分离） 调用者 Caller 和 执行者 Callee 之间的逻辑，最常用的手段就是面向接口的编程（OO 思想的核心之一）。 <br> 这样，用户可以自定义处理逻辑，而服务者只需要知道接口抽象的接口。</p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-comment">// ListenAndServe always returns a non-nil error.</span>
<span class="hljs-keyword">func</span> ListenAndServe(addr <span class="hljs-typename">string</span>, handler Handler) error {
    server := &amp;Server{Addr: addr, Handler: handler}
    <span class="hljs-keyword">return</span> server.ListenAndServe()
}</code></pre> 
<p>逻辑分离原理图：</p> 
<pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-literal">+</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>      <span class="hljs-comment">use</span> <span class="hljs-comment">interface</span>      <span class="hljs-literal">+</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>
<span class="hljs-comment">|</span>  <span class="hljs-comment">Caller</span>  <span class="hljs-comment">|</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt;<span class="hljs-comment">|</span> <span class="hljs-comment">Interface</span> <span class="hljs-comment">|</span>
<span class="hljs-literal">+</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>                         <span class="hljs-literal">+</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>
                                          <span class="hljs-comment">^</span>
                                          <span class="hljs-comment">|</span>
                                 <span class="hljs-literal">+</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>                                          
                                 <span class="hljs-comment">|</span>  <span class="hljs-comment">unknown</span> <span class="hljs-comment">Callee</span>  <span class="hljs-comment">|</span>
                                 <span class="hljs-literal">+</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>                                   </code></pre> 
<p>这里，由于 handler = nil 则会调用默认的处理逻辑 DefaultServeMux 的实现。</p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-comment">// serverHandler delegates to either the server's Handler or</span>
<span class="hljs-comment">// DefaultServeMux and also handles "OPTIONS *" requests.</span>
<span class="hljs-keyword">type</span> serverHandler <span class="hljs-keyword">struct</span> {
    srv *Server
}

<span class="hljs-keyword">func</span> (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
    handler := sh.srv.Handler
    <span class="hljs-keyword">if</span> handler == <span class="hljs-constant">nil</span> {
        handler = DefaultServeMux
    }
    <span class="hljs-keyword">if</span> req.RequestURI == <span class="hljs-string">"*"</span> &amp;&amp; req.Method == <span class="hljs-string">"OPTIONS"</span> {
        handler = globalOptionsHandler{}
    }
    handler.ServeHTTP(rw, req)
}</code></pre> 
<p>代码第一句， <code>http.HandleFunc</code> 函数则会构造一个 muxEntry 把对应 URL 处理程序注入 DefaultServeMux</p> 
<p><em>思考：</em> 函数回调 与 接口回调 有什么区别？ 使用场景？</p> 
<p><strong>golang 的 web 服务流程</strong></p> 
<pre class="prettyprint"><code class=" hljs r">ListenAndServe(addr string, handler Handler)
  + server.ListenAndServe()
    | net.Listen(<span class="hljs-string">"tcp"</span>, addr)
    + srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
      | srv.setupHTTP2_Serve()
      | baseCtx := context.Background()
      + <span class="hljs-keyword">for</span> {}
        | l.Accept()
        |  + select <span class="hljs-keyword">...</span> //为什么
        | c := srv.newConn(rw)
        | c.setState(c.rwc, StateNew) // before Serve can <span class="hljs-keyword">return</span>
        + go c.serve(ctx) // 新的链接 goroutine
          | <span class="hljs-keyword">...</span>  // 构建 w , r
          | serverHandler{c.server}.ServeHTTP(w, w.req)
          | <span class="hljs-keyword">...</span>  // after Serve</code></pre> 
<p>详细文字描述见：<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/03.4.md">Go的http包详解</a></p> 
<p>到 <code>serverHandler{c.server}.ServeHTTP(w, w.req)</code> 实现每个 conn 对应一个 serverHandler 的处理函数。（见前面）</p> 
<p><strong>拦截 DefaultServeMux</strong></p> 
<p>每个人都有一颗做框架的心，当然你可以重写库，这里研究如何拦截 DefaultServeMux 做一些身份认证工作。</p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"log"</span>
    <span class="hljs-string">"net/http"</span>
    <span class="hljs-string">"strings"</span>
)

<span class="hljs-keyword">type</span> MyMux <span class="hljs-keyword">struct</span> {
    defaultMux *http.ServeMux
}

<span class="hljs-keyword">func</span> (p *MyMux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fmt.Println(<span class="hljs-string">"do some extension here!"</span>)
    <span class="hljs-keyword">if</span> p.defaultMux == <span class="hljs-constant">nil</span> {
        p.defaultMux = http.DefaultServeMux
    }
    p.defaultMux.ServeHTTP(w, r)
    <span class="hljs-keyword">return</span>
}

<span class="hljs-keyword">func</span> sayhelloName(w http.ResponseWriter, r *http.Request) {
    r.ParseForm()       <span class="hljs-comment">//解析参数，默认是不会解析的</span>
    fmt.Println(r.Form) <span class="hljs-comment">//这些信息是输出到服务器端的打印信息</span>
    fmt.Println(<span class="hljs-string">"path"</span>, r.URL.Path)
    fmt.Println(<span class="hljs-string">"scheme"</span>, r.URL.Scheme)
    fmt.Println(r.Form[<span class="hljs-string">"url_long"</span>])
    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form {
        fmt.Println(<span class="hljs-string">"key:"</span>, k)
        fmt.Println(<span class="hljs-string">"val:"</span>, strings.Join(v, <span class="hljs-string">""</span>))
    }
    fmt.Fprintf(w, <span class="hljs-string">"Hello astaxie!"</span>) <span class="hljs-comment">//这个写入到w的是输出到客户端的</span>
}

<span class="hljs-keyword">func</span> main() {
    http.HandleFunc(<span class="hljs-string">"/"</span>, sayhelloName)            <span class="hljs-comment">//设置访问的路由</span>
    err := http.ListenAndServe(<span class="hljs-string">":9090"</span>, &amp;MyMux{}) <span class="hljs-comment">//设置监听的端口</span>
    <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
        log.Fatal(<span class="hljs-string">"ListenAndServe: "</span>, err)
    }
}</code></pre> 
<p>运行结果是什么？</p> 
<p>为什么要拦截，给一些理由 … …</p> 
<ol><li>DefaultServeMux 功能太有限 (why? 提示参见代码：<code>func pathMatch</code> 实现)</li><li>…</li></ol> 
<h4 id="4-golang-web-开发框架">4、 golang web 开发框架</h4> 
<p>由于 DefaultServeMux 仅是一个 demo ，当你需要使用正则表达式、或提取 path 中参数（如： /user/your-name）时，就搞不定了。 Go语言选择了让程序员自由发挥！ <br> （go 库设计原则 - 简单，简单，简单，可扩展！）</p> 
<h5 id="41-web-框架与选择综合症">4.1 web 框架与选择综合症</h5> 
<p>经过程序员多年自由发挥，你现在不得不面临海量的选择，有轻量级（做小部件，模仿 tonardo）、中重量（模仿 python Flask, 只提供 MVC 基础服务）、重量级（Java MVC,ORM 等等）。以下仅是建议:</p> 
<ul><li>简单应用：应选择自带库 <code>net/http</code></li><li>一般 web 应用与服务开发：建议选择轻量组件 <a href="http://www.gorillatoolkit.org/pkg/mux" rel="nofollow">gorilla/mux</a> + <a href="http://github.com/codegangsta/negroni">codegangsta/negroni</a> + …</li><li>web 开发: <a href="https://github.com/astaxie/beego">beego</a>、<a href="https://github.com/go-martini/martini">Martini</a>、<a href="http://revel.github.io/" rel="nofollow">revel</a> ……</li></ul> 
<p>如果你考虑高性能，请自己测试不同的框架。如何测试？</p> 
<h5 id="42-开发产品级-cloudgo-应用">4.2 开发产品级 cloudgo 应用</h5> 
<p>程序非常简单，它发布了一个 hello user 的 web 服务。请自己阅读代码，它用了哪些库：</p> 
<p>main.go</p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"os"</span>

    <span class="hljs-string">"github.com/pmlpml/golang-learning/web/cloudgo/service"</span>
    flag <span class="hljs-string">"github.com/spf13/pflag"</span>
)

<span class="hljs-keyword">const</span> (
    PORT <span class="hljs-typename">string</span> = <span class="hljs-string">"8080"</span>
)

<span class="hljs-keyword">func</span> main() {
    port := os.Getenv(<span class="hljs-string">"PORT"</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(port) ==<span class="hljs-number"> 0</span> {
        port = PORT
    }

    pPort := flag.StringP(<span class="hljs-string">"port"</span>, <span class="hljs-string">"p"</span>, PORT, <span class="hljs-string">"PORT for httpd listening"</span>)
    flag.Parse()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(*pPort) !=<span class="hljs-number"> 0</span> {
        port = *pPort
    }

    server := service.NewServer()
    server.Run(<span class="hljs-string">":"</span> + port)
}</code></pre> 
<p>service/server.go</p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">package</span> service

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"net/http"</span>

    <span class="hljs-string">"github.com/codegangsta/negroni"</span>
    <span class="hljs-string">"github.com/gorilla/mux"</span>
    <span class="hljs-string">"github.com/unrolled/render"</span>
)

<span class="hljs-comment">// NewServer configures and returns a Server.</span>
<span class="hljs-keyword">func</span> NewServer() *negroni.Negroni {

    formatter := render.New(render.Options{
        IndentJSON: <span class="hljs-constant">true</span>,
    })

    n := negroni.Classic()
    mx := mux.NewRouter()

    initRoutes(mx, formatter)

    n.UseHandler(mx)
    <span class="hljs-keyword">return</span> n
}

<span class="hljs-keyword">func</span> initRoutes(mx *mux.Router, formatter *render.Render) {
    mx.HandleFunc(<span class="hljs-string">"/hello/{id}"</span>, testHandler(formatter)).Methods(<span class="hljs-string">"GET"</span>)
}

<span class="hljs-keyword">func</span> testHandler(formatter *render.Render) http.HandlerFunc {

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">func</span>(w http.ResponseWriter, req *http.Request) {
        vars := mux.Vars(req)
        id := vars[<span class="hljs-string">"id"</span>]
        formatter.JSON(w, http.StatusOK, <span class="hljs-keyword">struct</span>{ Test <span class="hljs-typename">string</span> }{<!-- --><span class="hljs-string">"Hello "</span> + id})
    }
}</code></pre> 
<p>运行程序：</p> 
<pre class="prettyprint"><code class=" hljs applescript">$ go <span class="hljs-command">run</span> ./web/cloudgo/main.go -p9090
[negroni] listening <span class="hljs-function_start"><span class="hljs-keyword">on</span></span> :<span class="hljs-number">9090</span>
[negroni] <span class="hljs-number">2017</span>-<span class="hljs-number">10</span>-<span class="hljs-number">31</span>T14:<span class="hljs-number">37</span>:<span class="hljs-number">42</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> | <span class="hljs-number">200</span> |      <span class="hljs-number">277.524</span>µs | localhost:<span class="hljs-number">9090</span> | GET /hello/testuser</code></pre> 
<p>测试用命令：</p> 
<pre class="prettyprint"><code class=" hljs markdown">$ curl -v http://localhost:9090/hello/testuser
<span class="hljs-bullet">* </span>About to connect() to localhost port 9090 (#0)
<span class="hljs-bullet">*   </span>Trying ::1...
<span class="hljs-bullet">* </span>Connected to localhost (::1) port 9090 (#0)
<span class="hljs-blockquote">&gt; GET /hello/testuser HTTP/1.1</span>
<span class="hljs-blockquote">&gt; User-Agent: curl/7.29.0</span>
<span class="hljs-blockquote">&gt; Host: localhost:9090</span>
<span class="hljs-blockquote">&gt; Accept: */*</span>
<span class="hljs-blockquote">&gt;
&lt; HTTP/1.1 200 OK</span>
<span class="xml"><span class="hljs-tag">&lt; <span class="hljs-attribute">Content-Type:</span> <span class="hljs-attribute">application</span>/<span class="hljs-attribute">json</span>; <span class="hljs-attribute">charset</span>=<span class="hljs-value">UTF-8</span>
&lt; <span class="hljs-attribute">Date:</span> <span class="hljs-attribute">Tue</span>, <span class="hljs-attribute">31</span> <span class="hljs-attribute">Oct</span> <span class="hljs-attribute">2017</span> <span class="hljs-attribute">06:37:42</span> <span class="hljs-attribute">GMT</span>
&lt; <span class="hljs-attribute">Content-Length:</span> <span class="hljs-attribute">31</span>
&lt;
{
  "<span class="hljs-attribute">Test</span>"<span class="hljs-attribute">:</span> "<span class="hljs-attribute">Hello</span> <span class="hljs-attribute">testuser</span>"
}
* <span class="hljs-attribute">Connection</span> #<span class="hljs-attribute">0</span> <span class="hljs-attribute">to</span> <span class="hljs-attribute">host</span> <span class="hljs-attribute">localhost</span> <span class="hljs-attribute">left</span> <span class="hljs-attribute">intact</span></span></span></code></pre> 
<p>很酷的程序，程序扩展自然，几乎没有任何累赘。用户程序可读性也好，下一步就是处理输入、输出。</p> 
<p><strong>压力测试</strong></p> 
<p>安装 Apache web 压力测试程序（以 centos 为例）：</p> 
<pre class="prettyprint"><code class=" hljs lasso">yum <span class="hljs-attribute">-y</span> install httpd<span class="hljs-attribute">-tools</span></code></pre> 
<p>执行压力测试：</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver">$ ab -n <span class="hljs-number">1000</span> -c <span class="hljs-number">100</span> <span class="hljs-keyword">http</span>://localhost:<span class="hljs-number">9090</span>/hello/your
This is ApacheBench, Version <span class="hljs-number">2.3</span> &lt;$Revision: <span class="hljs-number">1430300</span> $&gt;
...
Server Software:        
Server Hostname:        localhost
Server Port:            <span class="hljs-number">9090</span>

Document Path:          /hello/your
Document Length:        <span class="hljs-number">27</span> <span class="hljs-keyword">bytes</span>

Concurrency Level:      <span class="hljs-number">100</span>
Time taken <span class="hljs-keyword">for</span> tests:   <span class="hljs-number">0.200</span> <span class="hljs-built_in">seconds</span>
Complete requests:      <span class="hljs-number">1000</span>
Failed requests:        <span class="hljs-number">0</span>
Write errors:           <span class="hljs-number">0</span>
Total transferred:      <span class="hljs-number">150000</span> <span class="hljs-keyword">bytes</span>
HTML transferred:       <span class="hljs-number">27000</span> <span class="hljs-keyword">bytes</span>
Requests per <span class="hljs-keyword">second</span>:    <span class="hljs-number">4996.33</span> [<span class="hljs-comment">#/sec] (mean)</span>
Time per request:       <span class="hljs-number">20.015</span> [ms] (mean)
Time per request:       <span class="hljs-number">0.200</span> [ms] (mean, across all concurrent requests)
Transfer rate:          <span class="hljs-number">731.88</span> [Kbytes/<span class="hljs-built_in">sec</span>] received

Connection Times (ms)
              <span class="hljs-built_in">min</span>  mean[+/-sd] <span class="hljs-built_in">median</span>   <span class="hljs-built_in">max</span>
Connect:        <span class="hljs-number">0</span>    <span class="hljs-number">4</span>   <span class="hljs-number">3.0</span>      <span class="hljs-number">3</span>      <span class="hljs-number">12</span>
Processing:     <span class="hljs-number">1</span>   <span class="hljs-number">15</span>   <span class="hljs-number">6.7</span>     <span class="hljs-number">14</span>      <span class="hljs-number">53</span>
Waiting:        <span class="hljs-number">1</span>   <span class="hljs-number">12</span>   <span class="hljs-number">6.5</span>     <span class="hljs-number">11</span>      <span class="hljs-number">51</span>
Total:          <span class="hljs-number">2</span>   <span class="hljs-number">19</span>   <span class="hljs-number">7.1</span>     <span class="hljs-number">18</span>      <span class="hljs-number">55</span>

Percentage <span class="hljs-operator">of</span> <span class="hljs-operator">the</span> requests served <span class="hljs-operator">within</span> <span class="hljs-operator">a</span> certain <span class="hljs-built_in">time</span> (ms)
  <span class="hljs-number">50</span>%     <span class="hljs-number">18</span>
  <span class="hljs-number">66</span>%     <span class="hljs-number">21</span>
  <span class="hljs-number">75</span>%     <span class="hljs-number">22</span>
  <span class="hljs-number">80</span>%     <span class="hljs-number">24</span>
  <span class="hljs-number">90</span>%     <span class="hljs-number">28</span>
  <span class="hljs-number">95</span>%     <span class="hljs-number">32</span>
  <span class="hljs-number">98</span>%     <span class="hljs-number">39</span>
  <span class="hljs-number">99</span>%     <span class="hljs-number">40</span>
 <span class="hljs-number">100</span>%     <span class="hljs-number">55</span> (longest request)
</code></pre> 
<p>具体安装、命令参数与结果解释参考：<a href="http://linux.it.net.cn/CentOS/fast/2015/0715/16393.html" rel="nofollow">CentOS服务器Http压力测试之ab</a></p> 
<h4 id="3小结">3、小结</h4> 
<p>通过对 <code>net/http</code> 包解析，你应该对 http 协议的工作原理和实现技术有初步了解，了解一些常用的 web 开发组件。也许你对 golang 的“简单、简单、简单”理念有了更好的理解！简单、高效是有代价的，需要你具备高超的程序设计技能，学习这些技能最好的老师就是 golang 的源代码与优秀框架的设计。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a5e5b085128458c994d287f2a42a8ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS实现html页面点击下载文件（共两种实现方法）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/41db1c9a8276cff8f72839262591055d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DPDK原理概述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>