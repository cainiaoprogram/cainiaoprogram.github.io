<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AFX_MANAGE_STATE(AfxGetStaticModuleState())讲解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AFX_MANAGE_STATE(AfxGetStaticModuleState())讲解" />
<meta property="og:description" content="以前写MFC的DLL的时候，总会在自动生成的代码框架里看到提示，需要在每一个输出的函数开始添加上AFX_MANAGE_STATE(AfxGetStaticModuleState())。一直不明白这样做的含义，也一直没有这样做，而且代码也工作得好好的，所以感觉这好像一句废话。
最近的项目中，需要在DLL里使用MFC生成界面，这才发现一旦资源放在不同的动态库里，而且还和多线程搅和在一起的时候，事情就变得异常的复杂，以前对MFC的一知半解已经不足与应付了。程序莫名的崩溃，莫名的ASSERT，资源怎样也装载不起来，为什么呢？每次，总是尝试着，在每一个线程的开始，把AFX_MANAGE_STATE(AfxGetStaticModuleState())添加上去，或者在某些地方用 AfxSetResourceHandler()一把，然后问题就解决了，但是不是很明白到底是怎么回事，总感觉这种解决办法让人很不安心，仿佛在下一秒问题又会突然冒出来。
前天，这个问题终于发挥到了极致，任我花费了好几个小时，怎样的尝试都不能成功，在项目的关键时候发生这种事情，让我暗暗发誓以后再也不用MFC了。正像很多的电影情节一样，事情最后还是得到了解决，这次我决定不能再这么算了，一定要把这个事情理解得明明白白。
在这里，我遇到的问题就是，如何让DLL里的界面代码使用该DLL的资源（Resource），如何在工作线程里加载有IE控件的对话框？
我问同事，他们是如何实现DLL资源切换的？AFX_MANAGE_STATE(AfxGetStaticModuleState())这就是他们的答案，一如微软的推荐，原来就是这么简单啊！让我们来看看，这句代码到底做了什么？
#define AFX_MANAGE_STATE(p) AFX_MAINTAIN_STATE2 _ctlState(p);
AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(AFX_MODULE_STATE* pNewState)
{
m_pThreadState = _afxThreadState;
m_pPrevModuleState =m_pThreadState-&gt;m_pModuleState;
m_pThreadState-&gt;m_pModuleState =pNewState;
}
_AFXWIN_INLINE AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2()
{ m_pThreadState-&gt;m_pModuleState = m_pPrevModuleState; }
原来，就是定义一个局部的对象，利用其构造和析构函数在函数的入口和函数的出口进行State状态的切换，我猜AfxGetStaticModuleState()一定是获取当前代码所在DLL的State。
果然，请看
static _AFX_DLL_MODULE_STATE afxModuleState;
AFX_MODULE_STATE* AFXAPI AfxGetStaticModuleState()
{
AFX_MODULE_STATE* pModuleState =&amp;afxModuleState;
return pModuleState;
}
class _AFX_DLL_MODULE_STATE : public AFX_MODULE_STATE
// AFX_MODULE_STATE (global data for a module)
class AFX_MODULE_STATE : public CNoTrackObject
{
...
CWinApp* m_pCurrentWinApp;
HINSTANCE m_hCurrentInstanceHandle;
HINSTANCE m_hCurrentResourceHandle;
LPCTSTR m_lpszCurrentAppName;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a66ff4e55a94542944f853e3fce51f24/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-03-07T07:59:11+08:00" />
<meta property="article:modified_time" content="2012-03-07T07:59:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AFX_MANAGE_STATE(AfxGetStaticModuleState())讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>以前写MFC的DLL的时候，总会在自动生成的代码框架里看到提示，需要在每一个输出的函数开始添加上AFX_MANAGE_STATE(AfxGetStaticModuleState())。一直不明白这样做的含义，也一直没有这样做，而且代码也工作得好好的，所以感觉这好像一句废话。<br> <br> 最近的项目中，需要在DLL里使用MFC生成界面，这才发现一旦资源放在不同的动态库里，而且还和多线程搅和在一起的时候，事情就变得异常的复杂，以前对MFC的一知半解已经不足与应付了。程序莫名的崩溃，莫名的ASSERT，资源怎样也装载不起来，为什么呢？每次，总是尝试着，在每一个线程的开始，把AFX_MANAGE_STATE(AfxGetStaticModuleState())添加上去，或者在某些地方用 AfxSetResourceHandler()一把，然后问题就解决了，但是不是很明白到底是怎么回事，总感觉这种解决办法让人很不安心，仿佛在下一秒问题又会突然冒出来。<br> <br> 前天，这个问题终于发挥到了极致，任我花费了好几个小时，怎样的尝试都不能成功，在项目的关键时候发生这种事情，让我暗暗发誓以后再也不用MFC了。正像很多的电影情节一样，事情最后还是得到了解决，这次我决定不能再这么算了，一定要把这个事情理解得明明白白。<br> <br> 在这里，我遇到的问题就是，如何让DLL里的界面代码使用该DLL的资源（Resource），如何在工作线程里加载有IE控件的对话框？<br> <br> 我问同事，他们是如何实现DLL资源切换的？AFX_MANAGE_STATE(AfxGetStaticModuleState())这就是他们的答案，一如微软的推荐，原来就是这么简单啊！让我们来看看，这句代码到底做了什么？<br> <br> #define AFX_MANAGE_STATE(p) AFX_MAINTAIN_STATE2 _ctlState(p);<br> <br> AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(AFX_MODULE_STATE* pNewState)<br> {<!-- --><br>    m_pThreadState = _afxThreadState;<br>    m_pPrevModuleState =m_pThreadState-&gt;m_pModuleState;<br>    m_pThreadState-&gt;m_pModuleState =pNewState;<br> }<br> <br> _AFXWIN_INLINE AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2()<br> { m_pThreadState-&gt;m_pModuleState = m_pPrevModuleState; }<br> <br> 原来，就是定义一个局部的对象，利用其构造和析构函数在函数的入口和函数的出口进行State状态的切换，我猜AfxGetStaticModuleState()一定是获取当前代码所在DLL的State。<br> <br> 果然，请看<br> <br> static _AFX_DLL_MODULE_STATE afxModuleState;<br> <br> AFX_MODULE_STATE* AFXAPI AfxGetStaticModuleState()<br> {<!-- --><br>    AFX_MODULE_STATE* pModuleState =&amp;afxModuleState;<br>    return pModuleState;<br> }<br> <br> <br> class _AFX_DLL_MODULE_STATE : public AFX_MODULE_STATE<br> <br> <br> // AFX_MODULE_STATE (global data for a module)<br> class AFX_MODULE_STATE : public CNoTrackObject<br> {<!-- --><br> ...<br>    CWinApp* m_pCurrentWinApp;<br>    HINSTANCE m_hCurrentInstanceHandle;<br>    HINSTANCE m_hCurrentResourceHandle;<br>    LPCTSTR m_lpszCurrentAppName;<br>    BYTE m_bDLL;    // TRUE if module is a DLL, FALSE if it isan EXE<br> <br> ...<br>    COccManager* m_pOccManager;<br> ...<br> <br> 这里不得不说，MFC把很多的数据都堆放在这里，搞得很复杂，结构性非常的差。<br> }<br> <br> afxModuleState是dll的静态成员，自然可以被同样的dll里的代码所访问，但是何时初始化的？<br> <br> <br> extern "C"<br> BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)<br> {<!-- --><br> ...<br> <br>        AfxWinInit(hInstance, NULL,_T(""), 0);<br> ...<br> }<br> <br> BOOL AFXAPI AfxWinInit(HINSTANCE hInstance, HINSTANCE hPrevInstance,<br>    LPTSTR lpCmdLine, int nCmdShow)<br> {<!-- --><br>    ASSERT(hPrevInstance == NULL);<br> <br>    // handle critical errors and avoidWindows message boxes<br>    SetErrorMode(SetErrorMode(0) |<br>        SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);<br> <br>    // set resource handles<br>    AFX_MODULE_STATE* pModuleState =AfxGetModuleState();<br>   pModuleState-&gt;m_hCurrentInstanceHandle = hInstance;<br>   pModuleState-&gt;m_hCurrentResourceHandle = hInstance;<br> <br> ...<br> <br> }<br> <br> 原来在DLL的入口函数，用该DLL的hInstance初始化了该结构。<br> <br> <br> 到这时候，我们还是不明白，为什么要进行资源切换？前面开始的_afxThreadState到底是什么？好像跟Thread有关系，到底是什么呢？<br> <br> THREAD_LOCAL(_AFX_THREAD_STATE, _afxThreadState)<br> <br> #define THREAD_LOCAL(class_name, ident_name) \<br>    AFX_DATADEFCThreadLocal&lt;class_name&gt; ident_name;<br> <br> template&lt;class TYPE&gt;<br> class CThreadLocal : public CThreadLocalObject<br> <br> 再 往下跟踪，发现其实代码越发生涩难懂，但是基本的功能就是访问当前此行代码的线程的私有数据。所谓线程的私有数据，就是说，不同的线程执行同样的一段代码，得到的数据可能是不同的。这才想起来，MFC的很多句柄啦，都是保存在全局的Map里的，而且放在线程的私有数据区里，所以跨线程传递MFC对象是很 不安全的。但是，MFC为什么要这么做呢？这个问题，到目前为止，我还是搞不明白。<br> <br> 还是回到开始的代码，资源切换到底是如何进行的？<br> <br> <br> int CDialog::DoModal()<br> {<!-- --><br> ...<br> <br>    HINSTANCE hInst =AfxGetResourceHandle();<br>    if (m_lpszTemplateName != NULL)<br>    {<!-- --><br>        hInst =AfxFindResourceHandle(m_lpszTemplateName, RT_DIALOG);<br>        HRSRC hResource =::FindResource(hInst, m_lpszTemplateName, RT_DIALOG);<br>        hDialogTemplate =LoadResource(hInst, hResource);<br> ...<br> }<br> <br> <br> _AFXWIN_INLINE HINSTANCE AFXAPI AfxGetResourceHandle()<br>    { ASSERT(afxCurrentResourceHandle !=NULL);<br>        return afxCurrentResourceHandle; }<br> <br> #define afxCurrentResourceHandle   AfxGetModuleState()-&gt;m_hCurrentResourceHandle<br> <br> AFX_MODULE_STATE* AFXAPI AfxGetModuleState()<br> {<!-- --><br>    _AFX_THREAD_STATE* pState =_afxThreadState;<br>    AFX_MODULE_STATE* pResult;<br>    if (pState-&gt;m_pModuleState != NULL)<br>    {<!-- --><br>        // thread state's module stateserves as override<br>        pResult =pState-&gt;m_pModuleState;<br>    }<br>    else<br>    {<!-- --><br>        // otherwise, use global app state<br>        pResult =_afxBaseModuleState.GetData();<br>    }<br>    ASSERT(pResult != NULL);<br>    return pResult;<br> }<br> <br> 原 来MFC的对话框装载资源是通过获取当前线程对应的ModuleState保存的ResourceHandler来装载资源的。所以，DLL里的代码，需 要在函数的入口，首先把当前执行线程的ModuleState换成该Dll的State，这样才能装载该dll的资源！这时候，我突然明白过来，为什么需 要要依赖线程的私有数据来保存ModuleState，其实确切的说是传递！--这其实是因为CDialog是存放在另一个DLL里的，比如MFC40.dll，如果以共享模式连接MFC库的话。而用户自己编写的CDialog的子类并不放在CDialog同样的Dll里，他们如何来传递这个 资源句柄呢？两种解决办法：1，利用参数传递。2，存放在一个公共的地方。前者需要增加参数，显得很麻烦，Win32的API好像就是这样实现的吧？后 者，需要确定这个公共地方在何处？这让人想起来，建立一个公共的动态库？由主程序的提供？再多说一句，J2EE里有一个容器的概念（COM+好像也有，不知道.NET是如何的），组件都是生存在容器里，这时候我们就可以设想把该数据存放在容器里。不管怎样，MFC的实现就是放在线程的私有数据区，不需要公 共的动态库，也不需要麻烦主程序，它自己就搞定了！它自以为很好的解决方式，很完美，却引发了我们的一系列的问题，特别是不明白就里的人。<br> <br> 关 于资源装载，问题似乎已经解决了，但是还有一点点小麻烦就是，我实现的dll不是以普通的输出函数进行输出的，而是输出类，我可不想在每一个类的成员函数里添加AFX_MANAGE_STATE(AfxGetStaticModuleState())。怎么办呢？既然已经知道了资源切换的原理，我们添加两个输出函数，分别对应AFX_MAINTAIN_STATE2的构造和析构函数，在类的使用前后调用，就可以了。或者，分别放在类的构造和析构函数里。又或者，就声明为成员变量。无论怎样，需要保证的一点就是资源的切换要正确嵌套，不可交叉－－这种情况在不同的DLL之间交叉调用的时候会发生。<br> <br> 好 了，现在DLL里的资源可以正确调用了，但是在当Dialog上包含有IE控件的时候，我们还是失败了，为什么呢？我知道对于ActiveX控件， Dialog需要做一些特殊的处理，AfxEnableControlContainer()，我也知道，要使用COM，需要CoInitialize ()，但是我一直没有想过需要两个一起用才能把IE弄出来，但是最后就是这样的。奇怪的是，如果不是在工作线程里，根本不需要CoInitialize ()，就能装载IE控件的，这个暂时就先不管了。<br> <br> PROCESS_LOCAL(COccManager, _afxOccManager)<br> <br> void AFX_CDECL AfxEnableControlContainer(COccManager* pOccManager)<br> {<!-- --><br>    if (pOccManager == NULL)<br>        afxOccManager = _afxOccManager.GetData();<br>    else<br>        afxOccManager = pOccManager;<br> }<br> <br> #define afxOccManager  AfxGetModuleState()-&gt;m_pOccManager<br> <br> 这 样看来，这个_afxOccManager应该是属于整个进程的，整个进程只有一个，就在那个定义它的dll里。但是，你需要把该对象(或者创建一个自定 义的)传给ModuleState(请注意前面的AFX_MODULE_STATE里就包含了该属性)，也就是要 AfxEnableControlContainer()一下，这样特定的ModuleState就有了OccManager的信息！但是，请注意，一定 要在目标dll里，正确切换了资源之后，才能进行,如下：<br> <br> AFX_MANAGE_STATE(AfxGetStaticModuleState())；<br> CoInitialize(NULL);<br> AfxEnableControlContainer();<br> <br> 至此，这个困扰我很久的问题，终于脉络清晰起来了。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01a76a43070aaf649e246f181400f64c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43;位运算符 | &amp;  ^  ~ &amp;&amp; ||,补码，反码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a59b1283c604c6452b9ecb3c8b8beebc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">stdafx.h和int _tmain(int argc, _TCHAR* argv[])</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>