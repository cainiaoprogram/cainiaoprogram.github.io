<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>redis命令参考 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="redis命令参考" />
<meta property="og:description" content="当前命令集未注明统一参考版本 &gt;= 1.x
key 格式：DEL key [key …]
时间复杂度： 删N为O ( N ) ，删单个key，为O ( 1 )；
返回值： 受影响的数量
删除单个 key
redis&gt; SET name huangz OK redis&gt; DEL name (integer) 1 删除一个不存在的 key
redis&gt; EXISTS phone (integer) 0 redis&gt; DEL phone # 失败，没有 key 被删除 (integer) 0 同时删除多个 key
redis&gt; SET name &#34;redis&#34; OK redis&gt; SET type &#34;key-value store&#34; OK redis&gt; SET website &#34;redis.com&#34; OK redis&gt; DEL name type website (integer) 3 keys 格式：keys pattern 查找所有符合给定模式 pattern 的 key 。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/94f379f90a678e54dfad9c8b07b1cf12/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-24T00:39:11+08:00" />
<meta property="article:modified_time" content="2020-09-24T00:39:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">redis命令参考</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><font size="6">当前命令集未注明统一参考版本 &gt;= 1.x</font></p> 
<h4><a id="font_colorgreen_size10keyfont_5"></a><font color="green" size="10">key</font></h4> 
<ul><li> <p><strong>格式：DEL key [key …]</strong></p> </li><li> <p><strong>时间复杂度：</strong> 删N为O ( N ) ，删单个key，为O ( 1 )；</p> </li><li> <p><strong>返回值：</strong> 受影响的数量</p> </li></ul> 
<p>删除单个 key</p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SET name huangz
OK

redis<span class="token operator">&gt;</span> DEL name
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre> 
<p>删除一个不存在的 key</p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> EXISTS phone
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

redis<span class="token operator">&gt;</span> DEL phone  <span class="token comment"># 失败，没有 key 被删除</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
</code></pre> 
<p>同时删除多个 key</p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SET name <span class="token string">"redis"</span>
OK

redis<span class="token operator">&gt;</span> SET <span class="token function">type</span> <span class="token string">"key-value store"</span>
OK

redis<span class="token operator">&gt;</span> SET website <span class="token string">"redis.com"</span>
OK

redis<span class="token operator">&gt;</span> DEL name <span class="token function">type</span> website
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3

</code></pre> 
<h4><a id="font_colorgreen_size10_keysfont_52"></a><font color="green" size="10"> keys</font></h4> 
<ul><li><strong>格式：keys pattern</strong></li></ul> 
<p><font color="grey">查找所有符合给定模式 pattern 的 key 。</font></p> 
<p><font color="grey">KEYS * 匹配数据库中所有 key 。</font></p> 
<p><font color="grey">KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。</font></p> 
<p><font color="grey">KEYS h*llo 匹配 hllo 和 heeeeello 等。</font></p> 
<p><font color="grey">KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 。</font></p> 
<p><font color="grey">特殊符号用 \ 隔开</font></p> 
<p><font color="red"> 警告：KEYS 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如 果你需要从一个数据集中查找特定的 key ，你最好还是用 Redis 的集合结构(set)来代替。</font></p> 
<ul><li> <p><strong>时间复杂度：</strong> O ( N ) N为key的size</p> </li><li> <p><strong>返回值：</strong> 匹配到的key集合</p> </li></ul> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> MSET one 1 two 2 three 3 four 4 <span class="token comment"># 一次设置 4 个 key</span>
OK

redis<span class="token operator">&gt;</span> KEYS *o*
1<span class="token punctuation">)</span> <span class="token string">"four"</span>
2<span class="token punctuation">)</span> <span class="token string">"two"</span>
3<span class="token punctuation">)</span> <span class="token string">"one"</span>

redis<span class="token operator">&gt;</span> KEYS t??
1<span class="token punctuation">)</span> <span class="token string">"two"</span>

redis<span class="token operator">&gt;</span> KEYS t<span class="token punctuation">[</span>w<span class="token punctuation">]</span>*
1<span class="token punctuation">)</span> <span class="token string">"two"</span>

redis<span class="token operator">&gt;</span> KEYS * <span class="token comment"># 匹配数据库内所有 key</span>
1<span class="token punctuation">)</span> <span class="token string">"four"</span>
2<span class="token punctuation">)</span> <span class="token string">"three"</span>
3<span class="token punctuation">)</span> <span class="token string">"two"</span>
4<span class="token punctuation">)</span> <span class="token string">"one"</span>


</code></pre> 
<h4><a id="font_colorgreen_size10_randomkeyfont_100"></a><font color="green" size="10"> randomkey</font></h4> 
<ul><li><strong>格式：randomkey</strong></li></ul> 
<p>​ 从当前数据库中随机返回(不删除)一个 key</p> 
<ul><li> <p><strong>时间复杂度：</strong> O ( 1 )；</p> </li><li> <p><strong>返回值：</strong> 受影响的数量</p> <p>​ 当数据库不为空时，返回一个 key 。</p> <p>​ 当数据库为空时，返回 nil 。</p> </li></ul> 
<pre><code class="prism language-shell"><span class="token comment"># 数据库不为空</span>
redis<span class="token operator">&gt;</span> MSET fruit <span class="token string">"apple"</span> drink <span class="token string">"beer"</span> food <span class="token string">"cookies"</span> <span class="token comment"># 设置多个 key</span>
OK

redis<span class="token operator">&gt;</span> RANDOMKEY
<span class="token string">"fruit"</span>

redis<span class="token operator">&gt;</span> RANDOMKEY
<span class="token string">"food"</span>

redis<span class="token operator">&gt;</span> KEYS * <span class="token comment"># 查看数据库内所有 key，证明 RANDOMKEY 并不删除 key</span>
1<span class="token punctuation">)</span> <span class="token string">"food"</span>
2<span class="token punctuation">)</span> <span class="token string">"drink"</span>
3<span class="token punctuation">)</span> <span class="token string">"fruit"</span>

<span class="token comment"># 数据库为空</span>
redis<span class="token operator">&gt;</span> FLUSHDB <span class="token comment"># 删除当前数据库所有 key</span>
OK

redis<span class="token operator">&gt;</span> RANDOMKEY
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="font_colorgreen_size10_ttlfont_140"></a><font color="green" size="10"> ttl</font></h4> 
<ul><li> <p><strong>格式：ttl key</strong></p> </li><li> <p><strong>时间复杂度：</strong> O ( 1 )；</p> </li><li> <p><strong>返回值：</strong></p> <p>当 key 不存在时，返回 -2 。</p> <p>当 key 存在但没有设置剩余生存时间时，返回 -1 。</p> <p>否则，以秒为单位，返回 key 的剩余生存时间。</p> <p><font color="red">注：在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</font></p> </li></ul> 
<pre><code class="prism language-shell"><span class="token comment"># 不存在的 key</span>
redis<span class="token operator">&gt;</span> FLUSHDB
OK

redis<span class="token operator">&gt;</span> TTL key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -2

<span class="token comment"># key 存在，但没有设置剩余生存时间</span>
redis<span class="token operator">&gt;</span> SET key value
OK

redis<span class="token operator">&gt;</span> TTL key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -1

<span class="token comment"># 有剩余生存时间的 key</span>
redis<span class="token operator">&gt;</span> EXPIRE key 10086
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> TTL key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10084
</code></pre> 
<h4><a id="font_colorgreen_size10_pttlfont_183"></a><font color="green" size="10"> pttl</font></h4> 
<ul><li> <p><strong>格式：pttl key</strong></p> </li><li> <p><strong>参考版本：</strong>&gt;= 2.6X</p> </li><li> <p><strong>时间复杂度：</strong> O ( 1 )；</p> </li><li> <p><strong>返回值：</strong></p> </li></ul> 
<p>当 key 不存在时，返回 -2 。</p> 
<p>当 key 存在但没有设置剩余生存时间时，返回 -1 。</p> 
<p>否则，以毫秒为单位，返回 key 的剩余生存时间。</p> 
<p><font color="red">注：在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 </font></p> 
<pre><code class="prism language-shell"><span class="token comment"># 不存在的 key</span>
redis<span class="token operator">&gt;</span> FLUSHDB
OK

redis<span class="token operator">&gt;</span> PTTL key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -2

<span class="token comment"># key 存在，但没有设置剩余生存时间</span>
redis<span class="token operator">&gt;</span> SET key value
OK

redis<span class="token operator">&gt;</span> PTTL key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -1

<span class="token comment"># 有剩余生存时间的 key</span>
redis<span class="token operator">&gt;</span> PEXPIRE key 10086
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> PTTL key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6179
</code></pre> 
<h4><a id="font_colorgreen_size10_existsfont_226"></a><font color="green" size="10"> exists</font></h4> 
<ul><li> <p><strong>格式：exists key</strong></p> </li><li> <p><strong>时间复杂度：</strong> O ( 1 )；</p> </li><li> <p><strong>返回值：</strong> 若 key 存在，返回 1 ，否则返回 0</p> </li></ul> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SET db <span class="token string">"redis"</span>
OK

redis<span class="token operator">&gt;</span> EXISTS db
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> DEL db
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> EXISTS db
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
</code></pre> 
<h4><a id="font_colorgreen_size10_movefont_252"></a><font color="green" size="10"> move</font></h4> 
<ul><li><strong>格式：move key db</strong></li></ul> 
<p><font color="grey">将当前数据库的 key 移动到给定的数据库 db 当中</font></p> 
<p><font color="grey">如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者key 不存在于当前数据库，那么 MOVE 没有任何效果</font></p> 
<p><font color="grey">因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)</font></p> 
<ul><li><strong>时间复杂度：</strong> O ( 1 )；</li><li><strong>返回值：</strong> 移动成功返回 1 ，失败则返回 0</li></ul> 
<pre><code class="prism language-shell"><span class="token comment"># key 存在于当前数据库</span>
redis<span class="token operator">&gt;</span> SELECT 0 <span class="token comment">#redis 默认使用数据库 0，为了清晰起见，这里再显式指定一次。</span>
OK

redis<span class="token operator">&gt;</span> SET song <span class="token string">"secret base - Zone"</span>
OK

redis<span class="token operator">&gt;</span> MOVE song 1 <span class="token comment"># 将 song 移动到数据库 1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> EXISTS song <span class="token comment"># song 已经被移走</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

redis<span class="token operator">&gt;</span> SELECT 1 <span class="token comment"># 使用数据库 1</span>
OK

redis:1<span class="token operator">&gt;</span> EXISTS song <span class="token comment"># 证实 song 被移到了数据库 1 (注意命令提示符变成了"redis:1"，表明正在使用数据库 1)</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

<span class="token comment"># 当 key 不存在的时候</span>
redis:1<span class="token operator">&gt;</span> EXISTS fake_key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

redis:1<span class="token operator">&gt;</span> MOVE fake_key 0 <span class="token comment"># 试图从数据库 1 移动一个不存在的 key 到数据库0，失败</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

redis:1<span class="token operator">&gt;</span> <span class="token keyword">select</span> 0 <span class="token comment"># 使用数据库 0</span>
OK

redis<span class="token operator">&gt;</span> EXISTS fake_key <span class="token comment"># 证实 fake_key 不存在</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

<span class="token comment"># 当源数据库和目标数据库有相同的 key 时</span>
redis<span class="token operator">&gt;</span> SELECT 0 <span class="token comment"># 使用数据库 0</span>
OK

redis<span class="token operator">&gt;</span> SET favorite_fruit <span class="token string">"banana"</span>
OK

redis<span class="token operator">&gt;</span> SELECT 1 <span class="token comment"># 使用数据库 1</span>
OK

redis:1<span class="token operator">&gt;</span> SET favorite_fruit <span class="token string">"apple"</span>
OK

redis:1<span class="token operator">&gt;</span> SELECT 0 <span class="token comment"># 使用数据库 0，并试图将 favorite_fruit 移动到数据库 1</span>
OK

redis<span class="token operator">&gt;</span> MOVE favorite_fruit 1 <span class="token comment"># 因为两个数据库有相同的 key，MOVE 失败</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

redis<span class="token operator">&gt;</span> GET favorite_fruit <span class="token comment"># 数据库 0 的 favorite_fruit 没变</span>
<span class="token string">"banana"</span>

redis<span class="token operator">&gt;</span> SELECT 1
OK

redis:1<span class="token operator">&gt;</span> GET favorite_fruit <span class="token comment"># 数据库 1 的 favorite_fruit 也是</span>
<span class="token string">"apple"</span>
</code></pre> 
<h4><a id="font_colorgreen_size10_renamefont_329"></a><font color="green" size="10"> rename</font></h4> 
<ul><li><strong>格式：randomkey</strong></li></ul> 
<p><font color="grey">将 key 改名为 newkey </font></p> 
<p><font color="grey">当 key 和 newkey 相同，或者 key 不存在时，返回一个错误</font></p> 
<p><font color="grey">当 newkey 已经存在时， RENAME 命令将覆盖旧值</font></p> 
<ul><li><strong>时间复杂度：</strong> O ( 1 )；</li><li><strong>返回值：</strong> 改名成功时提示 OK ，失败时候返回一个错误</li></ul> 
<pre><code class="prism language-shell"><span class="token comment"># key 存在且 newkey 不存</span>
redis<span class="token operator">&gt;</span> SET message <span class="token string">"hello world"</span>
OK

redis<span class="token operator">&gt;</span> RENAME message greeting
OK

redis<span class="token operator">&gt;</span> EXISTS message <span class="token comment"># message 不复存在</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

redis<span class="token operator">&gt;</span> EXISTS greeting <span class="token comment"># greeting 取而代之</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

<span class="token comment"># 当 key 不存在时，返回错误</span>
redis<span class="token operator">&gt;</span> RENAME fake_key never_exists
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR no such key

<span class="token comment"># newkey 已存在时， RENAME 会覆盖旧 newkey</span>
redis<span class="token operator">&gt;</span> SET pc <span class="token string">"lenovo"</span>
OK

redis<span class="token operator">&gt;</span> SET personal_computer <span class="token string">"dell"</span>
OK

redis<span class="token operator">&gt;</span> RENAME pc personal_computer <span class="token comment">#这里相当于value换了一个新的地址引用</span>
OK

redis<span class="token operator">&gt;</span> GET pc
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>

redis:1<span class="token operator">&gt;</span> GET personal_computer <span class="token comment"># 原来的值 dell 被覆盖了</span>
<span class="token string">"lenovo"</span>
</code></pre> 
<h4><a id="font_colorgreen_size10_renamenxfont_381"></a><font color="green" size="10"> renamenx</font></h4> 
<ul><li><strong>格式：renamenx key newkey</strong></li></ul> 
<p><font color="grey">当且仅当 newkey 不存在时，将 key 改名为 newkey </font></p> 
<p><font color="grey">当 key 不存在时，返回一个错误</font></p> 
<ul><li><strong>时间复杂度：</strong> O ( 1 )；</li><li><strong>返回值：</strong></li></ul> 
<p>修改成功时，返回 1</p> 
<p>如果 newkey 已经存在，返回 0</p> 
<pre><code class="prism language-shell"><span class="token comment"># newkey 不存在，改名成功</span>
redis<span class="token operator">&gt;</span> SET player <span class="token string">"MPlyaer"</span>
OK

redis<span class="token operator">&gt;</span> EXISTS best_player
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

redis<span class="token operator">&gt;</span> RENAMENX player best_player
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

<span class="token comment"># newkey 存在时，失败</span>
redis<span class="token operator">&gt;</span> SET animal <span class="token string">"bear"</span>
OK

redis<span class="token operator">&gt;</span> SET favorite_animal <span class="token string">"butterfly"</span>
OK

redis<span class="token operator">&gt;</span> RENAMENX animal favorite_animal
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

redis<span class="token operator">&gt;</span> get animal
<span class="token string">"bear"</span>

redis<span class="token operator">&gt;</span> get favorite_animal
<span class="token string">"butterfly"</span>
</code></pre> 
<h4><a id="font_colorgreen_size10_typefont_428"></a><font color="green" size="10"> type</font></h4> 
<ul><li><strong>格式：type key</strong></li></ul> 
<p><font color="grey">返回 key 所储存的值的类型</font></p> 
<ul><li><strong>时间复杂度：</strong> O ( 1 )；</li><li><strong>返回值：</strong></li></ul> 
<pre><code class="prism language-txt">none (key 不存在)
string (字符串)
list (列表)
set (集合)
zset (有序集)
hash (哈希表)
</code></pre> 
<pre><code class="prism language-shell"><span class="token comment"># 字符串</span>
redis<span class="token operator">&gt;</span> SET weather <span class="token string">"sunny"</span>
OK

redis<span class="token operator">&gt;</span> TYPE weather
string

<span class="token comment"># 列表</span>
redis<span class="token operator">&gt;</span> LPUSH book_list <span class="token string">"programming in scala"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> TYPE book_list
list

<span class="token comment"># 集合</span>
redis<span class="token operator">&gt;</span> SADD pat <span class="token string">"dog"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> TYPE pat
<span class="token keyword">set</span>
</code></pre> 
<h4><a id="font_colorgreen_size10_expirefont_473"></a><font color="green" size="10"> expire</font></h4> 
<ul><li><strong>格式：expire key seconds</strong></li></ul> 
<blockquote> 
 <p><font color="grey">为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。</font></p> 
 <p><font color="grey">在 Redis 中，带有生存时间的 key 被称为『可挥发』(volatile)的</font></p> 
 <p><font color="grey">生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替(replace)它的话，那么生存时间不会被改变。</font></p> 
 <p><font color="grey">比如说，对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间。</font></p> 
 <p><font color="grey">另一方面，如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。<br> RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的another_key 的生存时间也和原本的 key 一样。</font></p> 
 <p><font color="grey">使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久化』(persistent) key 。</font></p> 
</blockquote> 
<blockquote> 
 <p><font color="grey"><strong>更新生存时间</strong></font><br> <font color="grey">可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。</font></p> 
</blockquote> 
<blockquote> 
 <p><font color="grey"><strong>过期时间的精确度</strong></font><br> <font color="grey">在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 key 已经过期，但它还是可能在过期后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。</font></p> 
</blockquote> 
<blockquote> 
 <p><font color="grey"><strong>Redis 2.1.3 之前的不同之处</strong></font><br> <font color="grey">在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。</font></p> 
</blockquote> 
<ul><li> <p><strong>时间复杂度：</strong> O ( 1 )；</p> </li><li> <p><strong>返回值：</strong></p> <p>设置成功返回 1 。</p> <p>当 key 不存在或者不能为 key 设置生存时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的生存时间)，返回 0</p> </li></ul> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SET cache_page <span class="token string">"www.google.com"</span>
OK

redis<span class="token operator">&gt;</span> EXPIRE cache_page 30 <span class="token comment"># 设置过期时间为 30 秒</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> TTL cache_page <span class="token comment"># 查看剩余生存时间</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 23

redis<span class="token operator">&gt;</span> EXPIRE cache_page 30000 <span class="token comment"># 更新过期时间</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> TTL cache_page
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 29996
</code></pre> 
<ul><li><strong>模式：导航会话</strong></li></ul> 
<p>假设你有一项 web 服务，打算根据用户最近访问的 N 个页面来进行物品推荐，并且假设用户停止阅览超过 60 秒，那么就清空阅览记录(为了减少物品推荐的计算量，并且保持推荐物品的新鲜度)。</p> 
<p>这些最近访问的页面记录，我们称之为『导航会话』(Navigation session)，可以用 INCR 和 RPUSH 命令在 Redis 中实现它：每当用户阅览一个网页的时候，执行以下代码：</p> 
<pre><code class="prism language-shell">MULTI
 RPUSH pagewviews.user:<span class="token operator">&lt;</span>userid<span class="token operator">&gt;</span> http://<span class="token punctuation">..</span><span class="token punctuation">..</span>.
 EXPIRE pagewviews.user:<span class="token operator">&lt;</span>userid<span class="token operator">&gt;</span> 60
EXEC
</code></pre> 
<p>如果用户停止阅览超过 60 秒，那么它的导航会话就会被清空，当用户重新开始阅览的时候，系统又会重新记录导航会话，继续进行物品推荐。</p> 
<h4><a id="font_colorgreen_size10_pexpirefont_545"></a><font color="green" size="10"> pexpire</font></h4> 
<ul><li><strong>格式：pexpire key milliseconds</strong></li></ul> 
<p><font color="grey">这个命令和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像 EXPIRE 命令那样，以秒为单位</font></p> 
<ul><li><strong>参考版本：</strong> &gt;= 2.6X</li><li><strong>时间复杂度：</strong> O ( 1 )；</li><li><strong>返回值：</strong></li></ul> 
<p>设置成功，返回 1</p> 
<p>key 不存在或设置失败，返回 0</p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SET mykey <span class="token string">"Hello"</span>
OK

redis<span class="token operator">&gt;</span> PEXPIRE mykey 1500
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> TTL mykey <span class="token comment"># TTL 的返回值以秒为单位</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2

redis<span class="token operator">&gt;</span> PTTL mykey <span class="token comment"># PTTL 可以给出准确的毫秒数</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1499
</code></pre> 
<h4><a id="font_colorgreen_size10_expireatfont_575"></a><font color="green" size="10"> expireat</font></h4> 
<ul><li><strong>格式：expireat key timestamp</strong></li></ul> 
<p><font color="grey">EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间</font></p> 
<p><font color="grey">不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)</font></p> 
<ul><li><strong>参考版本：</strong> &gt;= 1.2X</li><li><strong>时间复杂度：</strong> O ( 1 )；</li><li><strong>返回值：</strong></li></ul> 
<p>如果生存时间设置成功，返回 1</p> 
<p>当 key 不存在或没办法设置生存时间，返回 0</p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SET cache www.google.com
OK

redis<span class="token operator">&gt;</span> EXPIREAT cache 1355292000 <span class="token comment"># 这个 key 将在 2012.12.12 过期</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> TTL cache
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 45081860
</code></pre> 
<h4><a id="font_colorgreen_size10_pexpireatfont_604"></a><font color="green" size="10"> pexpireat</font></h4> 
<ul><li><strong>格式：pexpireat key milliseconds</strong></li></ul> 
<p><font color="grey">这个命令和 EXPIREAT 命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳，而不是像 EXPIREAT 那样，以秒为单位</font></p> 
<ul><li><strong>参考版本：</strong> &gt;= 2.6X</li><li><strong>时间复杂度：</strong> O ( 1 )；</li><li><strong>返回值：</strong></li></ul> 
<p>如果生存时间设置成功，返回 1 。</p> 
<p>当 key 不存在或没办法设置生存时间时，返回 0</p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SET mykey <span class="token string">"Hello"</span>
OK

redis<span class="token operator">&gt;</span> PEXPIREAT mykey 1555555555005
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> TTL mykey <span class="token comment"># TTL 返回秒</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 223157079

redis<span class="token operator">&gt;</span> PTTL mykey <span class="token comment"># PTTL 返回毫秒</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 223157079318
</code></pre> 
<h4><a id="font_colorgreen_size10_persistfont_634"></a><font color="green" size="10"> persist</font></h4> 
<ul><li><strong>格式：persist key</strong></li></ul> 
<p><font color="grey">移除给定 key 的生存时间，将这个 key 从『可挥发』的(带生存时间 key )转换成『持久化』的(一个不带生存时间、永不过期的 key )。</font></p> 
<ul><li><strong>参考版本：</strong> &gt;= 2.2X</li><li><strong>时间复杂度：</strong> O ( 1 )；</li><li><strong>返回值：</strong></li></ul> 
<p>当生存时间移除成功时，返回 1</p> 
<p>如果 key 不存在或 key 没有设置生存时间，返回 0</p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SET mykey <span class="token string">"Hello"</span>
OK

redis<span class="token operator">&gt;</span> EXPIRE mykey 10 <span class="token comment"># 为 key 设置生存时间</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> TTL mykey
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10

redis<span class="token operator">&gt;</span> PERSIST mykey <span class="token comment"># 移除 key 的生存时间</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> TTL mykey
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -1
</code></pre> 
<h4><a id="font_colorgreen_size10_sortfont_669"></a><font color="green" size="10"> sort</font></h4> 
<ul><li> <p><strong>格式：sort key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]</strong></p> <p><font color="grey">返回或保存给定列表、集合、有序集合 key 中经过排序的元素</font></p> <p><font color="grey">排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较</font></p> <p><font color="grey"><strong>一般 SORT 用法</strong> </font></p> <p><font color="grey">最简单的 SORT 使用方法是 SORT key </font></p> <p><font color="grey">假设 today_cost 是一个保存数字的列表， SORT 命令默认会返回该列表值的递增(从小到大)排序结果</font></p> </li></ul> 
<pre><code class="prism language-shell"><span class="token comment"># 将数据一一加入到列表中</span>
redis<span class="token operator">&gt;</span> LPUSH today_cost 30
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> LPUSH today_cost 1.5
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2

redis<span class="token operator">&gt;</span> LPUSH today_cost 10
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3

redis<span class="token operator">&gt;</span> LPUSH today_cost 8
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4

<span class="token comment"># 排序</span>
redis<span class="token operator">&gt;</span> SORT today_cost
1<span class="token punctuation">)</span> <span class="token string">"1.5"</span>
2<span class="token punctuation">)</span> <span class="token string">"8"</span>
3<span class="token punctuation">)</span> <span class="token string">"10"</span>
4<span class="token punctuation">)</span> <span class="token string">"30"</span>
</code></pre> 
<p><font color="grey">当数据集中保存的是字符串值时，你可以用 ALPHA 修饰符(modifier)进行排序。</font></p> 
<pre><code class="prism language-shell"><span class="token comment"># 将数据一一加入到列表中</span>
redis<span class="token operator">&gt;</span> LPUSH website <span class="token string">"www.reddit.com"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> LPUSH website <span class="token string">"www.slashdot.com"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2

redis<span class="token operator">&gt;</span> LPUSH website <span class="token string">"www.infoq.com"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3

<span class="token comment"># 默认排序</span>
redis<span class="token operator">&gt;</span> SORT website
1<span class="token punctuation">)</span> <span class="token string">"www.infoq.com"</span>
2<span class="token punctuation">)</span> <span class="token string">"www.slashdot.com"</span>
3<span class="token punctuation">)</span> <span class="token string">"www.reddit.com"</span>

<span class="token comment"># 按字符排序</span>
redis<span class="token operator">&gt;</span> SORT website ALPHA
1<span class="token punctuation">)</span> <span class="token string">"www.infoq.com"</span>
2<span class="token punctuation">)</span> <span class="token string">"www.reddit.com"</span>
3<span class="token punctuation">)</span> <span class="token string">"www.slashdot.com"</span>
</code></pre> 
<p><font color="grey">如果你正确设置了 !LC_COLLATE 环境变量的话，Redis 能识别 UTF-8 编码。</font></p> 
<p><font color="grey">排序之后返回的元素数量可以通过 LIMIT 修饰符进行限制。</font></p> 
<p><font color="grey">LIMIT 修饰符接受两个参数： offset 和 count 。</font></p> 
<p><font color="grey">offset 指定要跳过的元素数量， count 指定跳过 offset 个指定的元素之后，要返回多少个对象。</font></p> 
<p><font color="grey">以下例子返回排序结果的前 5 个对象( offset 为 0 表示没有元素被跳过)。</font></p> 
<pre><code class="prism language-shell"><span class="token comment"># 将数据一一加入到列表中</span>
redis<span class="token operator">&gt;</span> LPUSH rank 30
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> LPUSH rank 56
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2

redis<span class="token operator">&gt;</span> LPUSH rank 42
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3

redis<span class="token operator">&gt;</span> LPUSH rank 22
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4

redis<span class="token operator">&gt;</span> LPUSH rank 0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5

redis<span class="token operator">&gt;</span> LPUSH rank 11
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6

redis<span class="token operator">&gt;</span> LPUSH rank 32
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 7

redis<span class="token operator">&gt;</span> LPUSH rank 67
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 8

redis<span class="token operator">&gt;</span> LPUSH rank 50
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 9

redis<span class="token operator">&gt;</span> LPUSH rank 44
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10

redis<span class="token operator">&gt;</span> LPUSH rank 55
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 11

<span class="token comment"># 排序</span>
redis<span class="token operator">&gt;</span> SORT rank LIMIT 0 5 <span class="token comment"># 返回排名前五的元素</span>
1<span class="token punctuation">)</span> <span class="token string">"0"</span>
2<span class="token punctuation">)</span> <span class="token string">"11"</span>
3<span class="token punctuation">)</span> <span class="token string">"22"</span>
4<span class="token punctuation">)</span> <span class="token string">"30"</span>
5<span class="token punctuation">)</span> <span class="token string">"32"</span>
</code></pre> 
<p><font color="grey">修饰符可以组合使用。以下例子返回降序(从大到小)的前 5 个对象</font></p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SORT rank LIMIT 0 5 DESC
1<span class="token punctuation">)</span> <span class="token string">"78"</span>
2<span class="token punctuation">)</span> <span class="token string">"67"</span>
3<span class="token punctuation">)</span> <span class="token string">"56"</span>
4<span class="token punctuation">)</span> <span class="token string">"55"</span>
5<span class="token punctuation">)</span> <span class="token string">"50"</span>
</code></pre> 
<p><font color="grey"><strong>使用外部 key 进行排序</strong></font></p> 
<p><font color="grey">有时候你会希望使用外部的 key 作为权重来比较元素，代替默认的对比方法。</font></p> 
<p><font color="grey">假设现在有用户(user)数据如下</font></p> 
<p><img src="https://images2.imgbox.com/51/73/Hrdr28gu_o.png" alt="在这里插入图片描述"></p> 
<p><font color="grey">id 数据保存在 key 名为 user_id 的列表中</font></p> 
<p><font color="grey">name 数据保存在 key 名为 user_name_{id} 的列表中</font></p> 
<p><font color="grey">level 数据保存在 user_level_{id} 的 key 中</font></p> 
<pre><code class="prism language-shell"><span class="token comment"># 先将要使用的数据加入到数据库中</span>
<span class="token comment"># admin</span>
redis<span class="token operator">&gt;</span> LPUSH user_id 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> SET user_name_1 admin
OK

redis<span class="token operator">&gt;</span> SET user_level_1 9999
OK

<span class="token comment"># huangz</span>
redis<span class="token operator">&gt;</span> LPUSH user_id 2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2

redis<span class="token operator">&gt;</span> SET user_name_2 huangz
OK

redis<span class="token operator">&gt;</span> SET user_level_2 10
OK

<span class="token comment"># jack</span>
redis<span class="token operator">&gt;</span> LPUSH user_id 59230
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3

redis<span class="token operator">&gt;</span> SET user_name_59230 jack
OK

redis<span class="token operator">&gt;</span> SET user_level_59230 3
OK

<span class="token comment"># hacker</span>
redis<span class="token operator">&gt;</span> LPUSH user_id 222
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4

redis<span class="token operator">&gt;</span> SET user_name_222 hacker
OK

redis<span class="token operator">&gt;</span> SET user_level_222 9999
OK
</code></pre> 
<p><font color="grey">如果希望按 level 从大到小排序 user_id ，可以使用以下命令：</font></p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SORT user_id BY user_level_* DESC
1<span class="token punctuation">)</span> <span class="token string">"222"</span> <span class="token comment"># hacker</span>
2<span class="token punctuation">)</span> <span class="token string">"1"</span> <span class="token comment"># admin</span>
3<span class="token punctuation">)</span> <span class="token string">"2"</span> <span class="token comment"># huangz</span>
4<span class="token punctuation">)</span> <span class="token string">"59230"</span> <span class="token comment"># jack</span>
</code></pre> 
<p><font color="grey">但是有时候只是返回相应的 id 没有什么用，你可能更希望排序后返回 id 对应的用户名，这样更友好一点，使用 GET 选项可以做到这一点</font></p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SORT user_id BY user_level_* DESC GET user_name_*
1<span class="token punctuation">)</span> <span class="token string">"hacker"</span>
2<span class="token punctuation">)</span> <span class="token string">"admin"</span>
3<span class="token punctuation">)</span> <span class="token string">"huangz"</span>
4<span class="token punctuation">)</span> <span class="token string">"jack"</span>
</code></pre> 
<p><font color="grey">可以多次地、有序地使用 GET 操作来获取更多外部 key 。</font></p> 
<p><font color="grey">比如你不但希望获取用户名，还希望连用户的密码也一并列出，可以使用以下命令</font></p> 
<pre><code class="prism language-shell"><span class="token comment"># 先添加一些测试数据</span>
redis<span class="token operator">&gt;</span> SET user_password_222 <span class="token string">"hey,im in"</span>
OK

redis<span class="token operator">&gt;</span> SET user_password_1 <span class="token string">"a_long_long_password"</span>
OK

redis<span class="token operator">&gt;</span> SET user_password_2 <span class="token string">"nobodyknows"</span>
OK

redis<span class="token operator">&gt;</span> SET user_password_59230 <span class="token string">"jack201022"</span>
OK

<span class="token comment"># 获取 name 和 password</span>
redis<span class="token operator">&gt;</span> SORT user_id BY user_level_* DESC GET user_name_* GET 
user_password_*
1<span class="token punctuation">)</span> <span class="token string">"hacker"</span> <span class="token comment"># 用户名</span>
2<span class="token punctuation">)</span> <span class="token string">"hey,im in"</span> <span class="token comment"># 密码</span>
3<span class="token punctuation">)</span> <span class="token string">"jack"</span>
4<span class="token punctuation">)</span> <span class="token string">"jack201022"</span>
5<span class="token punctuation">)</span> <span class="token string">"huangz"</span>
6<span class="token punctuation">)</span> <span class="token string">"nobodyknows"</span>
7<span class="token punctuation">)</span> <span class="token string">"admin"</span>
8<span class="token punctuation">)</span> <span class="token string">"a_long_long_password"</span>

<span class="token comment"># 注意 GET 操作是有序的，GET user_name_* GET user_password_* 和 GET </span>
user_password_* GET user_name_*返回的结果位置不同
redis<span class="token operator">&gt;</span> SORT user_id BY user_level_* DESC GET user_password_* GET 
user_name_*
1<span class="token punctuation">)</span> <span class="token string">"hey,im in"</span> <span class="token comment"># 密码</span>
2<span class="token punctuation">)</span> <span class="token string">"hacker"</span> <span class="token comment"># 用户名</span>
3<span class="token punctuation">)</span> <span class="token string">"jack201022"</span>
4<span class="token punctuation">)</span> <span class="token string">"jack"</span>
5<span class="token punctuation">)</span> <span class="token string">"nobodyknows"</span>
6<span class="token punctuation">)</span> <span class="token string">"huangz"</span>
7<span class="token punctuation">)</span> <span class="token string">"a_long_long_password"</span>
8<span class="token punctuation">)</span> <span class="token string">"admin"</span>
</code></pre> 
<p><font color="grey">GET 还有一个特殊的规则—— “GET #” ，用于获取被排序对象(我们这里的例子是user_id )的当前元素。</font></p> 
<p><font color="grey">比如你希望 user_id 按 level 排序，还要列出 id 、 name 和 password ，可以使用以下命令：</font></p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SORT user_id BY user_level_* DESC GET <span class="token comment"># GET user_name_* GET </span>
user_password_*
1<span class="token punctuation">)</span> <span class="token string">"222"</span> <span class="token comment"># id</span>
2<span class="token punctuation">)</span> <span class="token string">"hacker"</span> <span class="token comment"># name</span>
3<span class="token punctuation">)</span> <span class="token string">"hey,im in"</span> <span class="token comment"># password</span>
4<span class="token punctuation">)</span> <span class="token string">"1"</span>
5<span class="token punctuation">)</span> <span class="token string">"admin"</span>
6<span class="token punctuation">)</span> <span class="token string">"a_long_long_password"</span>
7<span class="token punctuation">)</span> <span class="token string">"2"</span>
8<span class="token punctuation">)</span> <span class="token string">"huangz"</span>
9<span class="token punctuation">)</span> <span class="token string">"nobodyknows"</span>
10<span class="token punctuation">)</span> <span class="token string">"59230"</span>
11<span class="token punctuation">)</span> <span class="token string">"jack"</span>
12<span class="token punctuation">)</span> <span class="token string">"jack201022"</span>
</code></pre> 
<p><font color="grey"><strong>只获取对象而不排序</strong></font></p> 
<p><font color="grey">BY 修饰符可以将一个不存在的 key 当作权重，让 SORT 跳过排序操作。</font></p> 
<p><font color="grey">该方法用于你希望获取外部对象而又不希望引起排序开销时使用。</font></p> 
<pre><code class="prism language-shell"><span class="token comment"># 确保 fake_key 不存在</span>
redis<span class="token operator">&gt;</span> EXISTS fake_key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

<span class="token comment"># 以 fake_key 作 BY 参数，不排序，只 GET name 和 GET password</span>
redis<span class="token operator">&gt;</span> SORT user_id BY fake_key GET <span class="token comment"># GET user_name_* GET </span>
user_password_*
1<span class="token punctuation">)</span> <span class="token string">"222"</span> <span class="token comment"># id</span>
2<span class="token punctuation">)</span> <span class="token string">"hacker"</span> <span class="token comment"># user_name</span>
3<span class="token punctuation">)</span> <span class="token string">"hey,im in"</span> <span class="token comment"># password</span>
4<span class="token punctuation">)</span> <span class="token string">"59230"</span>
5<span class="token punctuation">)</span> <span class="token string">"jack"</span>
6<span class="token punctuation">)</span> <span class="token string">"jack201022"</span>
7<span class="token punctuation">)</span> <span class="token string">"2"</span>
8<span class="token punctuation">)</span> <span class="token string">"huangz"</span>
9<span class="token punctuation">)</span> <span class="token string">"nobodyknows"</span>
10<span class="token punctuation">)</span> <span class="token string">"1"</span>
11<span class="token punctuation">)</span> <span class="token string">"admin"</span>
12<span class="token punctuation">)</span> <span class="token string">"a_long_long_password"</span>
</code></pre> 
<p><font color="grey"><strong>保存排序结果</strong></font></p> 
<p><font color="grey">默认情况下， SORT 操作只是简单地返回排序结果，如果你希望保存排序结果，可以给STORE 选项指定一个 key 作为参数，排序结果将以列表的形式被保存到这个 key 上。(若指定 key 已存在，则覆盖。)</font></p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> EXISTS user_info_sorted_by_level <span class="token comment"># 确保指定 key 不存在</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

redis<span class="token operator">&gt;</span> SORT user_id BY user_level_* GET <span class="token comment"># GET user_name_* GET </span>
user_password_* STORE user_info_sorted_by_level <span class="token comment"># 排序</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 12 <span class="token comment"># 显示有 12 条结果被保存了</span>

redis<span class="token operator">&gt;</span> LRANGE user_info_sorted_by_level 0 11 <span class="token comment"># 查看排序结果</span>
1<span class="token punctuation">)</span> <span class="token string">"59230"</span>
2<span class="token punctuation">)</span> <span class="token string">"jack"</span>
3<span class="token punctuation">)</span> <span class="token string">"jack201022"</span>
4<span class="token punctuation">)</span> <span class="token string">"2"</span>
5<span class="token punctuation">)</span> <span class="token string">"huangz"</span>
6<span class="token punctuation">)</span> <span class="token string">"nobodyknows"</span>
7<span class="token punctuation">)</span> <span class="token string">"222"</span>
8<span class="token punctuation">)</span> <span class="token string">"hacker"</span>
9<span class="token punctuation">)</span> <span class="token string">"hey,im in"</span>
10<span class="token punctuation">)</span> <span class="token string">"1"</span>
11<span class="token punctuation">)</span> <span class="token string">"admin"</span>
12<span class="token punctuation">)</span> <span class="token string">"a_long_long_password"</span>
</code></pre> 
<blockquote> 
 <p><font color="grey">一个有趣的用法是将 SORT 结果保存，用 EXPIRE 为结果集设置生存时间，这样结果集就成了 SORT 操作的一个缓存。</font></p> 
</blockquote> 
<blockquote> 
 <p><font color="grey">这样就不必频繁地调用 SORT 操作了，只有当结果集过期时，才需要再调用一次 SORT操作。</font></p> 
</blockquote> 
<blockquote> 
 <p><font color="grey">有时候为了正确实现这一用法，你可能需要加锁以避免多个客户端同时进行缓存重建(也就是多个客户端，同一时间进行 SORT 操作，并保存为结果集)，具体参见 SETNX 命令。</font></p> 
</blockquote> 
<p><font color="grey"><strong>在 GET 和 BY 中使用哈希表</strong> </font></p> 
<blockquote> 
 <p><font color="grey">可以使用哈希表特有的语法，在 SORT 命令中进行 GET 和 BY 操作。</font></p> 
</blockquote> 
<pre><code class="prism language-shell"><span class="token comment"># 假设现在我们的用户表新增了一个 serial 项来为作为每个用户的序列号</span>
<span class="token comment"># 序列号以哈希表的形式保存在 serial 哈希域内。</span>
redis<span class="token operator">&gt;</span> HMSET serial 1 23131283 2 23810573 222 502342349 59230 
2435829758
OK

<span class="token comment"># 用 serial 中值的大小为根据，对 user_id 进行排序</span>
redis<span class="token operator">&gt;</span> SORT user_id BY *-<span class="token operator">&gt;</span>serial
1<span class="token punctuation">)</span> <span class="token string">"59230"</span>
2<span class="token punctuation">)</span> <span class="token string">"222"</span>
3<span class="token punctuation">)</span> <span class="token string">"2"</span>
4<span class="token punctuation">)</span> <span class="token string">"1"</span>
</code></pre> 
<blockquote> 
 <p><font color="grey">符号 “-&gt;” 用于分割哈希表的键名(key name)和索引域(hash field)，格式为"key-&gt;field" </font></p> 
</blockquote> 
<p><font color="grey">除此之外，哈希表的 BY 和 GET 操作和上面介绍的其他数据结构(列表、集合、有序集合)没有什么不同。</font></p> 
<ul><li><strong>时间复杂度：</strong></li></ul> 
<p>O(N+M*log(M))， N 为要排序的列表或集合内的元素数量， M 为要返回的元素数量。</p> 
<p>如果只是使用 SORT 命令的 GET 选项获取数据而没有进行排序，时间复杂度 O(N)。</p> 
<ul><li><strong>返回值：</strong></li></ul> 
<p>没有使用 STORE 参数，返回列表形式的排序结果。</p> 
<p>使用 STORE 参数，返回排序结果的元素数量。</p> 
<h4><a id="font_colorgreen_size10_objectfont_1047"></a><font color="green" size="10"> object</font></h4> 
<ul><li><strong>格式：object subcommand [arguments [arguments]]</strong> 
  <ul><li><font color="grey">OBJECT 命令允许从内部察看给定 key 的 Redis 对象。</font></li><li><font color="grey">它通常用在除错(debugging)或者了解为了节省空间而对 key 使用特殊编码的情况。</font></li><li><font color="grey">当将 Redis 用作缓存程序时，你也可以通过 OBJECT 命令中的信息，决定 key 的驱逐策略(eviction policies)。</font></li></ul> </li></ul> 
<p>​ 1. <font color="grey"><strong>OBJECT 命令有多个子命令：</strong></font></p> 
<ul><li><font color="grey">OBJECT REFCOUNT &lt;key&gt; 返回给定 key 引用所储存的值的次数。此命令主要用于除错。</font></li><li><font color="grey">OBJECT ENCODING &lt;key&gt; 返回给定 key 锁储存的值所使用的内部表示(representation)</font></li><li><font color="grey">OBJECT IDLETIME &lt;key&gt; 返回给定 key 自储存以来的空转时间(idle， 没有被读取也没有被写入)，以秒为单位。</font></li></ul> 
<p>​ 2. <font color="grey"><strong>对象可以以多种方式编码：</strong></font></p> 
<ul><li><font color="grey">字符串可以被编码为 raw (一般字符串)或 int (用字符串表示 64 位数字是为了节约空间)。</font></li><li><font color="grey">列表可以被编码为 ziplist 或 linkedlist 。ziplist 是为节约大小较小的列表空间而作的特殊表</font>示。</li><li><font color="grey">集合可以被编码为 intset 或者 hashtable 。 intset 是只储存数字的小集合的特殊表示。</font></li><li><font color="grey">哈希表可以编码为 zipmap 或者 hashtable 。 zipmap 是小哈希表的特殊表示。</font></li><li><font color="grey">有序集合可以被编码为 ziplist 或者 skiplist 格式。ziplist 用于表示小的有序集合，而 skiplist 则用于表示任何大小的有序集合。</font></li></ul> 
<p><font color="grey">假如你做了什么让 Redis 没办法再使用节省空间的编码时(比如将一个只有 1 个元素的集合扩展为一个有 100 万个元素的集合)，特殊编码类型(specially encoded types)会自动转换成通用类型(general type)。</font></p> 
<ul><li> <p><strong>参考版本：</strong> &gt;= 2.2X</p> </li><li> <p><strong>时间复杂度：</strong> O ( 1 )；</p> </li><li> <p><strong>返回值：</strong></p> <p>REFCOUNT 和 IDLETIME 返回数字。</p> <p>ENCODING 返回相应的编码类型</p> </li></ul> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SET game <span class="token string">"COD"</span> <span class="token comment"># 设置一个字符串</span>
OK

redis<span class="token operator">&gt;</span> OBJECT REFCOUNT game <span class="token comment"># 只有一个引用</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

redis<span class="token operator">&gt;</span> OBJECT IDLETIME game <span class="token comment"># 等待一阵。。。然后查看空转时间</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 90

redis<span class="token operator">&gt;</span> GET game <span class="token comment"># 提取 game， 让它处于活跃(active)状态</span>
<span class="token string">"COD"</span>

redis<span class="token operator">&gt;</span> OBJECT IDLETIME game <span class="token comment"># 不再处于空转</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

redis<span class="token operator">&gt;</span> OBJECT ENCODING game <span class="token comment"># 字符串的编码方式</span>
<span class="token string">"raw"</span>

redis<span class="token operator">&gt;</span> SET phone 15820123123 <span class="token comment"># 大的数字也被编码为字符串</span>
OK

redis<span class="token operator">&gt;</span> OBJECT ENCODING phone
<span class="token string">"raw"</span>

redis<span class="token operator">&gt;</span> SET age 20 <span class="token comment"># 短数字被编码为 int</span>
OK

redis<span class="token operator">&gt;</span> OBJECT ENCODING age
<span class="token string">"int"</span>
</code></pre> 
<h4><a id="font_colorgreen_size10_migratefont_1122"></a><font color="green" size="10"> migrate</font></h4> 
<ul><li> <p><strong>格式：migrate host port key destination-db timeout</strong></p> <p>​ - <font color="grey">将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。</font></p> <p>​ - <font color="grey">这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。</font></p> <p>​ - <font color="grey">命令的内部实现是这样的：它在当前实例对给定 key 执行 DUMP 命令 ，将它序列化，然后传送到目标实例，目标实例再使用 RESTORE 对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到 RESTORE 命令返回 OK ，它就会调用 DEL 删除自己数据库上的 key 。</font></p> <p>​ - <font color="grey">timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。</font></p> <p>​ - <font color="grey">MIGRATE 命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。 </font></p> <p>​ - <font color="grey">当 IOERR 出现时，有以下两种可能：</font></p> <pre><code>  	1. &lt;font color="grey"&gt;key 可能存在于两个实例&lt;/font&gt;
  	2. &lt;font color="grey"&gt;key 可能只存在于当前实例&lt;/font&gt;
</code></pre> <p>​ - <font color="grey">唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。</font></p> <p>​ - <font color="grey">如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）。</font></p> </li><li> <p><strong>参考版本：</strong> &gt;= 2.6X</p> </li><li> <p><strong>时间复杂度：</strong></p> </li></ul> 
<p>这个命令在源实例上实际执行 DUMP 命令和 DEL 命令，在目标实例执行 RESTORE 命令，查看以上命令的文档可以看到详细的复杂度说明。</p> 
<p>key 数据在两个实例之间传输的复杂度为 O(N)</p> 
<ul><li><strong>返回值：</strong> 迁移成功时返回 OK ，否则返回相应的错误</li></ul> 
<pre><code class="prism language-shell">$ ./redis-server <span class="token operator">&amp;</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span> 3557
<span class="token punctuation">..</span>.

$ ./redis-server --port 7777 <span class="token operator">&amp;</span>
<span class="token punctuation">[</span>2<span class="token punctuation">]</span> 3560
<span class="token punctuation">..</span>.
</code></pre> 
<p>然后用客户端连上 6379 端口的实例，设置一个键，然后将它迁移到 7777 端口的实例上：</p> 
<pre><code class="prism language-shell">$ ./redis-cli
redis 127.0.0.1:6379<span class="token operator">&gt;</span> flushdb
OK

redis 127.0.0.1:6379<span class="token operator">&gt;</span> SET greeting <span class="token string">"Hello from 6379 instance"</span>
OK

redis 127.0.0.1:6379<span class="token operator">&gt;</span> MIGRATE 127.0.0.1 7777 greeting 0 1000
OK

redis 127.0.0.1:6379<span class="token operator">&gt;</span> EXISTS greeting <span class="token comment"># 迁移成功后 key 被删除</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
</code></pre> 
<p>使用另一个客户端，查看 7777 端口上的实例：</p> 
<pre><code class="prism language-shell">$ ./redis-cli -p 7777
redis 127.0.0.1:7777<span class="token operator">&gt;</span> GET greeting
<span class="token string">"Hello from 6379 instance"</span>
</code></pre> 
<h4><a id="font_colorgreen_size10_dumpfont_1197"></a><font color="green" size="10"> dump</font></h4> 
<ul><li> <p><strong>格式：dump key</strong></p> <p><font color="grey">序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为Redis 键</font></p> </li></ul> 
<p><font color="grey"> <strong>序列化生成的值有以下几个特点：</strong></font></p> 
<ul><li> <p><font color="grey"> 它带有 64 位的校验和，用于检测错误， RESTORE 在进行反序列化之前会先检查校验和。</font></p> </li><li> <p><font color="grey">值的编码格式和 RDB 文件保持一致。</font></p> </li><li> <p><font color="grey">RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么Redis 会拒绝对这个值进行反序列化操作。</font></p> </li></ul> 
<p><font color="grey">序列化的值不包括任何生存时间信息。</font></p> 
<ul><li><strong>参考版本：</strong> &gt;= 2.6X</li><li><strong>时间复杂度：</strong></li></ul> 
<p>查找给定键的复杂度为 O(1) ，对键进行序列化的复杂度为 O(N*M) ，其中 N 是构成key 的 Redis 对象的数量，而 M 则是这些对象的平均大小</p> 
<p>如果序列化的对象是比较小的字符串，那么复杂度为 O(1)</p> 
<ul><li><strong>返回值：</strong></li></ul> 
<p>如果 key 不存在，那么返回 nil</p> 
<p>否则，返回序列化之后的值</p> 
<pre><code class="prism language-shell">redis<span class="token operator">&gt;</span> SET greeting <span class="token string">"hello, dumping world!"</span>
OK

redis<span class="token operator">&gt;</span> DUMP greeting <span class="token string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span>

redis<span class="token operator">&gt;</span> DUMP not-exists-key
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre> 
<br> 
<hr> 
<br> 
<p><font color="hotpink" size="10">未完待续。。。。</font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c50057d4d4d4754fb6ed403a867ecb0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Guava Cache源码剖析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f14c80d6c1145c6949da7783db757d91/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RocketMQ系列：rocketmq运维控制台使用详解（全网独家）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>