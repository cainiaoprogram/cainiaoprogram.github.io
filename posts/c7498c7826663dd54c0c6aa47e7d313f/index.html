<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>4.docker镜像及相关命令 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="4.docker镜像及相关命令" />
<meta property="og:description" content="目录
1 查看所有镜像 docker images
1.1 基本用法
1.2 docker images -q 只显示所有镜像ID
1.3 docker images -f [筛选条件] -q 只显示符合条件的所有镜像ID
1.4 docker images --no-trunc 显示完整的IMAGE ID
1.5 docker images --format [模板] 使用模板
2 从源拉取镜像 docker pull
3 从源查找镜像 docker search
4 移除本地镜像 docker rmi
4.1 基本使用
4.2 强制删除 -f
5 将镜像保存为tar文件 docker save
6 将docker save生成的tar文件加载为镜像 docker load
7 查看镜像的元数据 docker inspect
8 查询镜像的多架构信息 docker manifest inspect
9 查看镜像历史记录(分层) docker history" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c7498c7826663dd54c0c6aa47e7d313f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-21T14:27:17+08:00" />
<meta property="article:modified_time" content="2023-12-21T14:27:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">4.docker镜像及相关命令</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="查看所有镜像-docker-images-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E9%95%9C%E5%83%8F-docker-images" rel="nofollow">1  查看所有镜像 docker images</a></p> 
<p id="基本用法-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" rel="nofollow">1.1  基本用法</a></p> 
<p id="docker-images--q-只显示所有镜像ID-toc" style="margin-left:40px;"><a href="#docker-images--q-%E5%8F%AA%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E9%95%9C%E5%83%8FID" rel="nofollow">1.2  docker images -q 只显示所有镜像ID</a></p> 
<p id="docker-images--f-[筛选条件]--q-只显示符合条件的所有镜像ID-toc" style="margin-left:40px;"><a href="#docker-images--f-%5B%E7%AD%9B%E9%80%89%E6%9D%A1%E4%BB%B6%5D--q-%E5%8F%AA%E6%98%BE%E7%A4%BA%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%89%80%E6%9C%89%E9%95%9C%E5%83%8FID" rel="nofollow">1.3  docker images -f [筛选条件] -q 只显示符合条件的所有镜像ID</a></p> 
<p id="docker-images---no-trunc-显示完整的IMAGE-ID-toc" style="margin-left:40px;"><a href="#docker-images---no-trunc-%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%95%B4%E7%9A%84IMAGE-ID" rel="nofollow">1.4  docker images --no-trunc 显示完整的IMAGE ID</a></p> 
<p id="docker-images---format-[模板]-使用模板-toc" style="margin-left:40px;"><a href="#docker-images---format-%5B%E6%A8%A1%E6%9D%BF%5D-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF" rel="nofollow">1.5  docker images --format [模板] 使用模板</a></p> 
<p id="从源拉取镜像-docker-pull-toc" style="margin-left:0px;"><a href="#%E4%BB%8E%E6%BA%90%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F-docker-pull" rel="nofollow">2  从源拉取镜像 docker pull</a></p> 
<p id="从源查找镜像-docker-search-toc" style="margin-left:0px;"><a href="#%E4%BB%8E%E6%BA%90%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F-docker-search" rel="nofollow">3  从源查找镜像 docker search</a></p> 
<p id="移除本地镜像-docker-rmi-toc" style="margin-left:0px;"><a href="#%E7%A7%BB%E9%99%A4%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F-docker-rmi" rel="nofollow">4  移除本地镜像 docker rmi</a></p> 
<p id="基本使用-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">4.1  基本使用</a></p> 
<p id="强制删除--f-toc" style="margin-left:40px;"><a href="#%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4--f" rel="nofollow">4.2  强制删除 -f</a></p> 
<p id="将镜像保存为tar文件-docker-save-toc" style="margin-left:0px;"><a href="#%E5%B0%86%E9%95%9C%E5%83%8F%E4%BF%9D%E5%AD%98%E4%B8%BAtar%E6%96%87%E4%BB%B6-docker-save" rel="nofollow">5  将镜像保存为tar文件 docker save</a></p> 
<p id="将docker-save生成的tar文件加载为镜像-docker-load-toc" style="margin-left:0px;"><a href="#%E5%B0%86docker-save%E7%94%9F%E6%88%90%E7%9A%84tar%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%B8%BA%E9%95%9C%E5%83%8F-docker-load" rel="nofollow">6  将docker save生成的tar文件加载为镜像 docker load</a></p> 
<p id="查看镜像的元数据-docker-inspect-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE-docker-inspect" rel="nofollow">7  查看镜像的元数据 docker inspect</a></p> 
<p id="查询镜像的多架构信息-docker-manifest-inspect-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E8%AF%A2%E9%95%9C%E5%83%8F%E7%9A%84%E5%A4%9A%E6%9E%B6%E6%9E%84%E4%BF%A1%E6%81%AF-docker-manifest-inspect" rel="nofollow">8  查询镜像的多架构信息 docker manifest inspect</a></p> 
<p id="查看镜像历史记录(分层)-docker-history-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%28%E5%88%86%E5%B1%82%29-docker-history" rel="nofollow">9  查看镜像历史记录(分层) docker history</a></p> 
<p id="通过dockerfile构建镜像-docker-build-toc" style="margin-left:0px;"><a href="#%E9%80%9A%E8%BF%87dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F-docker-build" rel="nofollow">10  通过dockerfile构建镜像 docker build</a></p> 
<p id="给镜像贴标签-docker-tag-toc" style="margin-left:0px;"><a href="#%E7%BB%99%E9%95%9C%E5%83%8F%E8%B4%B4%E6%A0%87%E7%AD%BE-docker-tag" rel="nofollow">11  给镜像贴标签 docker tag</a></p> 
<p id="删除虚悬镜像-docker-image-prune-toc" style="margin-left:0px;"><a href="#%E5%88%A0%E9%99%A4%E8%99%9A%E6%82%AC%E9%95%9C%E5%83%8F-docker-image-prune" rel="nofollow">12  删除虚悬镜像 docker image prune</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>docker的镜像体积比较小，我们以mysql为例，在docker中mysql仅有516M。你正常安装一个mysql是要大于516M的</p> 
<p class="img-center"><img alt="" height="94" src="https://images2.imgbox.com/78/90/vUowlZ7F_o.png" width="609"></p> 
<p>docker镜像可以分为4类</p> 
<ul><li>Docker Official Image :docker官方镜像。镜像的名称就是软件的名称，比如redis就叫redis</li><li>Verified Publish :已验证发布者发布的镜像。这种镜像不是docker自己做的，但是也是比较重量级的作者做的，比如阿里，华为这种。镜像的名称是 作者/软件的名称 比如 ubuntu/nginx</li><li>Sponsored OSS:由docker公司赞助的作者开发的仓库。oss的意思是open source software 镜像的名称是 作者/软件的名称 比如 linuxserver/nginx</li><li>无认证仓库，这种仓库实际上就是我们自己写的仓库</li></ul> 
<p>可以使用第三方的镜像中心，我们在公司自己开发镜像的时候不会把资源发到官方的镜像中心中，而是会自己整一个。在第三方的镜像中心中镜像的命名一般为 域名（或IP）/上传镜像人的名字/软件的名称</p> 
<p>docker镜像有一些松耦合（相互的关联性不强）的只读镜像层组成，Docker Daemon负责堆叠这些镜像层并将它们关联为一个统一的整体。</p> 
<p>每个分层都是只读的，对分层的修改都是以新分层的形式出现，并不会破坏原分层内容。每个分层只记录变更内容，有利于节省储存空间。</p> 
<p>采用分层可以实现不同镜像间的资源共享。比如redis与mysql可能都有A层。如果pull完redis再pull mysql的时候就不用再下载A层了(pull的时候会显示Already exists)。同时存储也只存储一个A层，这个A层既可以给redis使用也可以给mysql</p> 
<p>每个镜像层由 镜像文件系统与镜像json文件 构成。镜像的文件系统（file system简称fs）由多个只读的镜像层组成，每层都完成了特定的功能，根据位置与功能可以分为基础镜像层与扩展镜像层</p> 
<p>所有镜像的最下层都由一个基础镜像层，这个基础镜像层的文件系统称为根文件系统rootfs。rootfs是建立在Linux系统的文件引导系统bootfs之上（无论你的宿主机是什么，docker的容器都是linux系统，如果是非linux系统安装docker可以理解为宿主先虚拟出一个linux然后给docker的容器用）</p> 
<p>基础镜像层之上的镜像层称为扩展镜像层。在Dockerfile中，每条指令都会生成一个扩展镜像层，所以尽可能在把多个指令合成一个指令来写</p> 
<p>容器是 基础镜像层与扩展镜像层 之上可读写的容器层，对文件的任何更改只存在于容器层而不会影响镜像本身。如果你像修改镜像层的东西，那么会首先从镜像层复制一份到容器层，然后改复制后的东西。如果容器层与镜像层存储的内容发生冲突，容器层的内容会覆盖镜像层的内容</p> 
<p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/2a/64/bQkKnXm3_o.png" width="688"></p> 
<p>很多镜像都是多架构（比如amd,arm）的，以便能在多个架构中运行，比如redis。镜像中的部分层是专门处理架构的，在拉取镜像的时候，架构的信息会自动发送给镜像中心，镜像中心根据不同的架构给你返回不同的镜像，如果没有你正在使用的架构那么就会拉取失败</p> 
<p class="img-center"><img alt="" height="658" src="https://images2.imgbox.com/bc/2a/draCjLL9_o.png" width="1081"></p> 
<h2 id="查看所有镜像-docker-images">1  查看所有镜像 docker images</h2> 
<h3 id="基本用法"><a id="基本用法-1.1"></a>1.1  基本用法</h3> 
<p>如果没有下载过镜像就是这样的</p> 
<p class="img-center"><img alt="" height="57" src="https://images2.imgbox.com/30/be/6Yx3aoLq_o.png" width="461"></p> 
<p>加载过就像就会把相关的信息显示出来</p> 
<p class="img-center"><img alt="" height="94" src="https://images2.imgbox.com/f6/1a/P7bFRPT3_o.png" width="555"></p> 
<ul><li>如果一个镜像没有REPOSITORY与TAG我们称这个镜像为虚悬镜像（Dangling Image）</li><li>镜像默认是按照 镜像作者的创建时间（不是你拉取的时间）排序的</li></ul> 
<p>可以追加名称筛选出想要的信息，比如我想在只想看mysql相关的信息，那么就写 docker images mysql</p> 
<p class="img-center"><img alt="" height="73" src="https://images2.imgbox.com/8e/53/r9pGrFmz_o.png" width="536"></p> 
<p>docker images可以配合参数，应用场景常为批量处理镜像的时候，比如我现在想删除所有的镜像我可以输入 docker rmi $(docker images -q)</p> 
<p>$(docker images -q)作为一个变量，意思是全部镜像的ID</p> 
<h3 id="docker-images--q-只显示所有镜像ID"><a id="docker-images--q-只显示所有镜像ID-1.2"></a>1.2  docker images -q 只显示所有镜像ID</h3> 
<p class="img-center"><img alt="" height="76" src="https://images2.imgbox.com/1a/c6/UyCAtBNw_o.png" width="488"></p> 
<h3 id="docker-images--f-[筛选条件]--q-只显示符合条件的所有镜像ID">1.3  docker images -f [筛选条件] -q 只显示符合条件的所有镜像ID</h3> 
<p>比如 docker images -f since=mysql:latest -q 筛选出晚于 mysql:latest的CREATED 的镜像ID</p> 
<p class="img-center"><img alt="" height="130" src="https://images2.imgbox.com/fa/e7/6imuq3TO_o.png" width="697"></p> 
<p>-f可以跟的筛选条件常用的有</p> 
<ul><li>dangling=true 筛选出所有虚悬镜像</li><li>since=mysql:latest 筛选出晚于 mysql:latest的CREATED 的镜像。比如镜像A的CREATED的创建时间是1 months ago，镜像B:latest的CREATED的创建时间是2 months ago，镜像C的CREATED的创建时间是3 months ago，如果写 since=B:latest 那么就会只显示A镜像(不会显示B，也不会显示C)</li><li>before=mysql:latest 筛选出早于 mysql:latest的CREATED 的镜像。比如镜像A的CREATED的创建时间是1 months ago，镜像B:latest的CREATED的创建时间是2 months ago，镜像C的CREATED的创建时间是3 months ago，如果写 before=B:latest 那么就会只显示C镜像(不会显示B，也不会显示A)</li></ul> 
<p>reference也是-f的筛选条件这个参数只会查官方的镜像，所以这个命令应用不多</p> 
<ul><li>reference=*:latest 可以查到所有tag为latest的镜像</li><li>reference=*llo* 可以查看 RESPOSITORY或TAG中含有llo的镜像</li></ul> 
<h3 id="docker-images---no-trunc-显示完整的IMAGE-ID"><a id="docker-images---no-trunc-显示完整的IMAGE-ID-1.4"></a>1.4  docker images --no-trunc 显示完整的IMAGE ID</h3> 
<p>IMAGE ID实际上就是digest</p> 
<p class="img-center"><img alt="" height="93" src="https://images2.imgbox.com/2e/80/9b9vNP6k_o.png" width="1086"></p> 
<h3 id="docker-images---format-[模板]-使用模板">1.5  docker images --format [模板] 使用模板</h3> 
<p>比如 docker images --format {<!-- -->{.Repository}} 就是只显示Repository这一列</p> 
<p class="img-center"><img alt="" height="76" src="https://images2.imgbox.com/7f/ae/AphoXbsS_o.png" width="688"></p> 
<p>我们再做个例子 docker images --format {<!-- -->{.Repository}}:{<!-- -->{.Tag}}:{<!-- -->{.Size}}</p> 
<p class="img-center"><img alt="" height="76" src="https://images2.imgbox.com/f3/f5/C6JcB6CV_o.png" width="857"></p> 
<h2 id="从源拉取镜像-docker-pull">2  从源拉取镜像 docker pull</h2> 
<p>比如我想从源拉一个最新的mysql，那你就输入docker pull mysql 拉取的过程是这样的</p> 
<ul><li>默认拉取latest版本</li><li>如果你要拉取指定的版本，那你就写 docker pull mysql:[指定的版本]</li><li>对于非官方镜像也可以带用户名比如 docker pull suyu/mysql:[指定的版本]</li><li>也可以使用digest值 比如 docker pull openanolis/mysql@sha256:78b2c0e8da2a374094d20aa521ca483c5b7c41de4b6f62fecf67f7582e9aa7d7 用digest值下载之后的镜像默认情况下没有tag</li><li>如果要拉取的镜像在源上没有会响应not found</li></ul> 
<p class="img-center"><img alt="" height="403" src="https://images2.imgbox.com/e7/3a/tmhTaNwu_o.png" width="1182"></p> 
<p>拉下来之后是这样的</p> 
<p class="img-center"><img alt="" height="347" src="https://images2.imgbox.com/40/17/aSLQP3ab_o.png" width="714"></p> 
<ul><li>Digest表示的是镜像的摘要，在下载之前会将要下载的内容与之前下载的内容进行比对（如果之前下载过）。如果比对结果相同就不进行下载，如果比对结果不同再进行下载。digest实际上就是IMAGE ID。每一个镜像都有一个长度为64位的16进制字符串摘要。本质上摘要是一个哈希值，具体来说是Content Hash(内容散列)。只要镜像内容发生了变更，digest也会发生改变。Docker默认采用的Hash算法是SHA256，SHA的意思是 Secure Hash Algorihm 安全哈希算法。SHA256本身是一个256位的二进制值，在Docker中改为了16进制表示，就变成了长度为64位的字符串</li><li>Digeset可以让客户端与镜像中心传递镜像的时候可以放置信息丢失。比如A的镜像digist是123，那么客户端会先把123发给镜像中心，之后再把镜像传给镜像中心，之后镜像中心会校验一遍传过来的镜像，如果校验结果是123证明镜像没有信息丢失，如果不是123，那么会自动重新传输</li><li>为了节省带宽，pull或push的时候镜像会被压缩，之后传输。压缩后的镜像与压缩前的镜像digist是不同的。为了解决这个问题Docker采用了分发散列值(Distribution Hash)，分发散列值在镜像压缩后立即计算。客户端与镜像中心使用分发散列值校验镜像</li></ul> 
<p>每一个pull complete代表这个镜像的每一个层，每一次下载的时候层都是有顺序的，第一层是72a6，第二层是9361。它是一层一层压上去，层太多了我就不每个都画上了，我们可以大概像下面图一样理解，一层一层往上盖，e043是最后一层</p> 
<p class="img-center"><img alt="" height="381" src="https://images2.imgbox.com/92/1d/lk9ucidM_o.png" width="353"></p> 
<p>查看镜像列表可以发现mysql</p> 
<p class="img-center"><img alt="" height="93" src="https://images2.imgbox.com/8c/0e/wwrIZXhl_o.png" width="565"></p> 
<p>可以追加一些参数，比如</p> 
<ul><li>docker pull -a zookeeper 这个就是把zookeeper镜像的所有版本都拉到你本地</li><li>docker pull -q zookeeper 这个是静默模式，静默模式就是在终端上不打印任何的东西</li></ul> 
<h2 id="从源查找镜像-docker-search"><a id="从源查找镜像-docker-search-3"></a>3  从源查找镜像 docker search</h2> 
<p>比如说我想找 redis 这个镜像，排序是根据综合得分排序的</p> 
<p class="img-center"><img alt="" height="506" src="https://images2.imgbox.com/80/2f/CuLv9LaR_o.png" width="1031"></p> 
<ul><li>NAME 镜像名称</li><li>DESCRIPTION 镜像描述</li><li>STARS 收藏数</li><li>OFFICIAL 写了OK的是官方的镜像</li><li>AUTOMATED 写了OK的是通过dockerfile自动构建的镜像。如果dockerfile有变动AUTOMATED为OK的镜像也会变动。AUTOMATED写了OK的可以理解为也是可以被信任的镜像，但不是官方自己做的</li></ul> 
<p>docker search可以配合参数比如-f是筛选</p> 
<ul><li>docker search -f is-official=true redis 这个可以筛选出redis的官方镜像</li><li>docker search -f is-automated=true redis 这个可以筛选出redis通过dockfile自动化构建的镜像</li><li>docker search -f stars=100 redis 这个可以筛选出redis的stars值<strong>大于</strong>100的镜像</li></ul> 
<p>--limit 是显示多少条数据，默认为25</p> 
<ul><li>docker search --limit=5 redis 只显示redis的前5条数据</li></ul> 
<p>--no-trunc 是不删减显示的信息，基本上只有描述比较长，会被删减一点</p> 
<ul><li>docker search --no-trunc redis 显示每一个redis的完整信息</li></ul> 
<p>--format 是按照模板显示</p> 
<ul><li>docker search --format {<!-- -->{.Name}} 只显示redis这一列</li></ul> 
<h2 id="移除本地镜像-docker-rmi"><a id="移除本地镜像-docker-rmi-4"></a>4  移除本地镜像 docker rmi</h2> 
<h3 id="基本使用"><a id="基本使用-4.1"></a>4.1  基本使用</h3> 
<p>比如我想删除mysql:latest这个镜像，那么就输入 docker rmi mysql:latest</p> 
<ul><li>如果不写tag默认是latest，删除的时候建议写全了</li><li>也可以写IMAGE ID，比如 docker rmi 3218b38490ce</li></ul> 
<p class="img-center"><img alt="" height="444" src="https://images2.imgbox.com/cd/3f/8kf2oywD_o.png" width="795"></p> 
<h3 id="强制删除--f">4.2  强制删除 -f</h3> 
<p>如果你有容器正在使用镜像，你只写rmi是删除不了的</p> 
<p class="img-center"><img alt="" height="110" src="https://images2.imgbox.com/26/02/ahrAmIc7_o.png" width="1200"></p> 
<p>加上 -f 就能删了</p> 
<p class="img-center"><img alt="" height="93" src="https://images2.imgbox.com/3c/e2/Vay8yzmE_o.png" width="842"></p> 
<p>镜像没有了，但是容器还有</p> 
<p class="img-center"><img alt="" height="111" src="https://images2.imgbox.com/15/97/J0kS400Y_o.png" width="948"></p> 
<h2 id="将镜像保存为tar文件-docker-save">5  将镜像保存为tar文件 docker save</h2> 
<p>保存可以保存一个或者多个，我们目前有两个镜像</p> 
<p class="img-center"><img alt="" height="95" src="https://images2.imgbox.com/ef/32/fgFsCgOz_o.png" width="554"></p> 
<p>我们可以将这两个镜像保存为一个tar文件，输入 docker save -o /home/suyu/my.tar mysql:latest hello-world:latest</p> 
<ul><li>也可以分开保存</li></ul> 
<p class="img-center"><img alt="" height="41" src="https://images2.imgbox.com/1a/f2/h4OKzjQZ_o.png" width="931"></p> 
<p class="img-center"><img alt="" height="151" src="https://images2.imgbox.com/d1/0f/HNjrbSC2_o.png" width="757"></p> 
<p>也可以这样写，效果与上面的命令相同</p> 
<p class="img-center"><img alt="" height="151" src="https://images2.imgbox.com/af/6e/Khay9WWP_o.png" width="757"></p> 
<p>tar文件大小与所保存的镜像大小之和基本一致</p> 
<p class="img-center"><img alt="" height="493" src="https://images2.imgbox.com/b8/20/dwZakxYU_o.png" width="428"></p> 
<h2 id="将docker-save生成的tar文件加载为镜像-docker-load">6  将docker save生成的tar文件加载为镜像 docker load</h2> 
<p>我首先把这两个镜像存为了tar文件</p> 
<p class="img-center"><img alt="" height="95" src="https://images2.imgbox.com/72/ab/NbNL88bY_o.png" width="554"></p> 
<p>然后我删掉这两个镜像</p> 
<p class="img-center"><img alt="" height="417" src="https://images2.imgbox.com/24/ff/v3YTPty6_o.png" width="843"></p> 
<p>之后我进行加载，输入 docker load -i my.tar</p> 
<p class="img-center"><img alt="" height="205" src="https://images2.imgbox.com/dd/f6/wYhoN4CH_o.png" width="887"></p> 
<p>加载完成后是这样的</p> 
<p class="img-center"><img alt="" height="308" src="https://images2.imgbox.com/d0/6c/5JsG9YfI_o.png" width="887"></p> 
<p>我们查询所有镜像，发现与保存前一致（包括镜像ID）</p> 
<p class="img-center"><img alt="" height="92" src="https://images2.imgbox.com/6d/0c/nfbJbTTZ_o.png" width="553"></p> 
<p>也可以这样加载 docker load &lt; my.tar 效果一样</p> 
<p class="img-center"><img alt="" height="417" src="https://images2.imgbox.com/2a/ba/QOCei1JF_o.png" width="892"></p> 
<h2 id="查看镜像的元数据-docker-inspect">7  查看镜像的元数据 docker inspect</h2> 
<p>比如docker inspect mysql</p> 
<p class="img-center"><img alt="" height="967" src="https://images2.imgbox.com/c9/f8/raVpuxqP_o.png" width="859"></p> 
<h2 id="查询镜像的多架构信息-docker-manifest-inspect">8  查询镜像的多架构信息 docker manifest inspect</h2> 
<p>比如 docker manifest inspect redis</p> 
<ul><li>这个是从源查询的，所以查的时候会慢一些</li><li>manifest本身一个文件，如果这个镜像不支持多架构就没有这个文件，没有这个文件执行 docker manifest inspect 就查不了。有的镜像支持多架构，但也没有manifest这个文件，那也查不了。</li></ul> 
<p class="img-center"><img alt="" height="901" src="https://images2.imgbox.com/8c/8a/q8diSpnk_o.png" width="842"></p> 
<h2 id="查看镜像历史记录(分层)-docker-history" style="background-color:transparent;">9  查看镜像历史记录(分层) docker history</h2> 
<p>比如我现在要查看 a7c6 这个镜像的历史记录</p> 
<p class="img-center"><img alt="" height="242" src="https://images2.imgbox.com/49/9d/6oKLj8Eb_o.png" width="863"></p> 
<h2 id="通过dockerfile构建镜像-docker-build" style="background-color:transparent;">10  通过dockerfile构建镜像 docker build</h2> 
<p>我在/home/suyu下有Dockerfile这个文件，还有一个可执行文件hello，可执行文件在终端执行后会打印hello world</p> 
<ul><li>可执行文件是通过gcc的静态编译编译出来的</li></ul> 
<p class="img-center"><img alt="" height="224" src="https://images2.imgbox.com/ca/bc/WdMYDPve_o.png" width="480"></p> 
<p>内容如下</p> 
<p class="img-center"><img alt="" height="104" src="https://images2.imgbox.com/04/ab/b3Yp2ND5_o.png" width="360"></p> 
<p>之后进入Dockerfile所在的目录，执行 docker build -t [镜像名] .</p> 
<ul><li>注意最后有个点儿，这个点儿代表的就是Dockerfile</li><li>如果不写tag默认为latest</li></ul> 
<p class="img-center"><img alt="" height="257" src="https://images2.imgbox.com/d7/bf/DISASSuc_o.png" width="1200"></p> 
<p>之后执行docker images就可以看到构建的镜像了</p> 
<p class="img-center"><img alt="" height="168" src="https://images2.imgbox.com/b2/87/Y67dnaPv_o.png" width="625"></p> 
<p>运行这个镜像可以成功执行hello</p> 
<p class="img-center"><img alt="" height="58" src="https://images2.imgbox.com/83/fa/Xh1Y0Ig6_o.png" width="591"></p> 
<p>如果[镜像名:tag]与之前的内容重复，且内容不一致。新的build的镜像会为你定义的名字，build前的同名镜像会变为虚悬镜像</p> 
<p class="img-center"><img alt="" height="670" src="https://images2.imgbox.com/79/b8/RUTN9Xkv_o.png" width="1026"></p> 
<p>如果你想指定其他的Dockerfile。比如路径下的Dockerfile2</p> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/62/cc/ytRLNhmn_o.png" width="383"></p> 
<p>那么就可以像下面这样写</p> 
<ul><li>注意最后的 点 还是要写</li></ul> 
<p class="img-center"><img alt="" height="311" src="https://images2.imgbox.com/88/12/QvNb5G2K_o.png" width="1200"></p> 
<p> </p> 
<h2 id="给镜像贴标签-docker-tag" style="background-color:transparent;">11  给镜像贴标签 docker tag</h2> 
<p>比如我现在想把 suyu_hello_world:latest 改为 111:222</p> 
<p>那么我可以执行 docker tag suyu_hello_world:latest 111:222</p> 
<p class="img-center"><img alt="" height="325" src="https://images2.imgbox.com/c7/0a/RqFBKZCx_o.png" width="745"></p> 
<p>添加完 111:222 之后发现之前的 suyu_hello_world:latest 还在，这个时候我们删掉它就可以了</p> 
<ul><li>注意不要用ID删除</li></ul> 
<p class="img-center"><img alt="" height="199" src="https://images2.imgbox.com/23/5d/rXUreJks_o.png" width="680"></p> 
<h2 id="删除虚悬镜像-docker-image-prune">12  删除虚悬镜像 docker image prune</h2> 
<p>我们现在有一个虚悬镜像</p> 
<p class="img-center"><img alt="" height="206" src="https://images2.imgbox.com/95/52/fYKbiZJe_o.png" width="754"></p> 
<p>我可以通过docker image prune删掉所有的虚悬镜像</p> 
<ul><li>如果该虚悬镜像生成了容器，即使容器为退出状态也删不掉该虚悬镜像</li></ul> 
<p class="img-center"><img alt="" height="334" src="https://images2.imgbox.com/00/cf/d8XuLZZA_o.png" width="887"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c1882778f2d37cf2d7a58afe7616569e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c# WPF 应用程序在屏幕上居中显示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71ae4b513a1708c61bfabf6145fee72a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu 常用命令之 ll 命令用法介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>