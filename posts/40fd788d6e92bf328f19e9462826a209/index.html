<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 文件操作 fopen、fclose、fprintf、fputs、fputc、fread、fwrite。。。 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux 文件操作 fopen、fclose、fprintf、fputs、fputc、fread、fwrite。。。" />
<meta property="og:description" content="1. fopen()函数
fopen函数用于打开文件, 其调用格式为:
FILE *fopen(char *filename, *type);
在介绍这个函数之;前, 先了解一下下面的知识。
(1) 流(stream)和文件(file)
流和文件 在Turbo C2.0中是有区别的, Turbo C2.0 为编程者和被访问的设备之间提供了一层抽象的东西, 称之为&#34;流&#34;, 而将具体的实际设备叫做文件。流是一个逻辑设备, 具有相同的行为。因此, 用来进行磁盘文件写的函数也同样可以用来进行打印机的写入。在Turbo C2.0中有两种性质的流: 文字流( text stream)和二进制(binary stream)。对磁盘来说就是文本文件和二进制文件。
(2) 文件指针FILE
实际上FILE是一个新的数据类型。它是Turbo C2.0的基本数据类型的集合, 称之为结构指针。有关结构的概念将在第四节中详细介绍, 这里只要将FILE理解为一个包括了文件管理有关信息的数据结构, 即在打开文件时必须先定义一个文件指针。
现在再来看打开文件函数的用法。
fopen()函数中第一个形式参数表示文件名, 可以包含路径和文件名两部分。如:
&#34;B:TEST.DAT&#34;
&#34;C://TC//TEST.DAT&#34;
如果将路径写成&#34;C:/TC/TEST.DAT&#34;是不正确的, 这一点要特别注意。
第二个形式参数表示打开文件的类型。关于文件类型的规定参见下表。
表 文件操作类型
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
字符 含义
───────────────────────────
&#34;r&#34; 打开文字文件只读
&#34;w&#34; 创建文字文件只写
&#34;a&#34; 增补, 如果文件不存在则创建一个
&#34;r&#43;&#34; 打开一个文字文件读/写
&#34;w&#43;&#34; 创建一个文字文件读/写
&#34;a&#43;&#34; 打开或创建一个文件增补
&#34;b&#34; 二进制文件(可以和上面每一项合用)
&#34;t&#34; 文这文件(默认项)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
如果要打开一个CCDOS子目录中, 文件名为CLIB的二进制文件, 可写成:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/40fd788d6e92bf328f19e9462826a209/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-29T18:03:21+08:00" />
<meta property="article:modified_time" content="2019-10-29T18:03:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 文件操作 fopen、fclose、fprintf、fputs、fputc、fread、fwrite。。。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#f33b45;"><strong> 1. fopen()函数</strong></span><br>     fopen函数用于打开文件, 其调用格式为:<br>      FILE *fopen(char *filename, *type);<br>     在介绍这个函数之;前, 先了解一下下面的知识。<br>     (1) 流(stream)和文件(file)<br>     流和文件 在Turbo C2.0中是有区别的, Turbo C2.0 为编程者和被访问的设备之间提供了一层抽象的东西, 称之为"流", 而将具体的实际设备叫做文件。流是一个逻辑设备, 具有相同的行为。因此, 用来进行磁盘文件写的函数也同样可以用来进行打印机的写入。在Turbo C2.0中有两种性质的流:   文字流( text stream)和二进制(binary stream)。对磁盘来说就是文本文件和二进制文件。<br>     (2) 文件指针FILE<br>     实际上FILE是一个新的数据类型。它是Turbo C2.0的基本数据类型的集合, 称之为结构指针。有关结构的概念将在第四节中详细介绍, 这里只要将FILE理解为一个包括了文件管理有关信息的数据结构, 即在打开文件时必须先定义一个文件指针。<br><br>     现在再来看打开文件函数的用法。<br>     fopen()函数中第一个形式参数表示文件名, 可以包含路径和文件名两部分。如:<br>      "B:TEST.DAT"<br>      "C://TC//TEST.DAT"<br>     如果将路径写成"C:/TC/TEST.DAT"是不正确的, 这一点要特别注意。<br>     第二个形式参数表示打开文件的类型。关于文件类型的规定参见下表。<br>                        表  文件操作类型<br>     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br>           字符                含义<br>     ───────────────────────────<br>            "r"           打开文字文件只读<br>            "w"           创建文字文件只写<br>            "a"           增补, 如果文件不存在则创建一个<br>            "r+"          打开一个文字文件读/写<br>            "w+"          创建一个文字文件读/写<br>            "a+"          打开或创建一个文件增补<br>            "b"           二进制文件(可以和上面每一项合用)<br>            "t"           文这文件(默认项)<br>     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br>     如果要打开一个CCDOS子目录中, 文件名为CLIB的二进制文件, 可写成:<br>      fopen("c://ccdos//clib", "rb");<br>     如果成功的打开一个文件, fopen()函数返回文件指针,   否则返回空指针 (NULL)。由此可判断文件打开是否成功。</p> 
<h3>fopen() 函数的打开方式</h3> 
<p>不同的操作需要不同的文件权限。例如，只想读取文件中的数据的话，“只读”权限就够了；既想读取又想写入数据的话，“读写”权限就是必须的了。<br><br> 另外，文件也有不同的类型，按照数据的存储方式可以分为二进制文件和文本文件，它们的操作细节是不同的。<br><br> 在调用 fopen() 函数时，这些信息都必须提供，称为“文件打开方式”。最基本的文件打开方式有以下几种：</p> 
<table><tbody><tr><th colspan="2">控制读写权限的字符串（必须指明）</th></tr><tr><th>打开方式</th><th>说明</th></tr><tr><td>"r"</td><td>以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。</td></tr><tr><td>"w"</td><td>以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。</td></tr><tr><td>"a"</td><td>以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。</td></tr><tr><td>"r+"</td><td>以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。</td></tr><tr><td>"w+"</td><td>以“写入/更新”方式打开文件，相当于<code>w</code>和<code>r+</code>叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。</td></tr><tr><td>"a+"</td><td>以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。</td></tr><tr><th colspan="2">控制读写方式的字符串（可以不写）</th></tr><tr><th>打开方式</th><th>说明</th></tr><tr><td>"t"</td><td>文本文件。如果不写，默认为<code>"t"</code>。</td></tr><tr><td>"b"</td><td>二进制文件。</td></tr></tbody></table> 
<p><br> 调用 fopen() 函数时必须指明读写权限，但是可以不指明读写方式（此时默认为<code>"t"</code>）。<br><br> 读写权限和读写方式可以组合使用，但是必须将读写方式放在读写权限的中间或者尾部（换句话说，不能将读写方式放在读写权限的开头）。例如：</p> 
<ul><li>将读写方式放在读写权限的末尾："rb"、"wt"、"ab"、"r+b"、"w+t"、"a+t"</li><li>将读写方式放在读写权限的中间："rb+"、"wt+"、"ab+"</li></ul> 
<p><br> 整体来说，文件打开方式由 r、w、a、t、b、+ 六个字符拼成，各字符的含义是：</p> 
<ul><li>r(read)：读</li><li>w(write)：写</li><li>a(append)：追加</li><li>t(text)：文本文件</li><li>b(banary)：二进制文件</li><li>+：读和写</li></ul> 
<p> </p> 
<p><strong>    <span style="color:#f33b45;">2. fclose()函数</span></strong><br>     fclose()函数用来关闭一个由fopen()函数打开的文件 , 其调用格式为:<br>       int fclose(FILE *stream);<br>     该函数返回一个整型数。当文件关闭成功时, 返回0, 否则返回一个非零值。可以根据函数的返回值判断文件是否关闭成功。</p> 
<p>    例:<br>      #iclude&lt;stdio.h&gt;<br>      main()<br>      {<!-- --><br>           FILE *fp;                /*定义一个文件指针*/<br>           int i;<br>           fp=fopen("CLIB", "rb");  /*打开当前目录名为CLIB的文件只读*/<br>           if(fp==NULL)             /*判断文件是否打开成功*/<br>              puts("File open error");/*提示打开不成功*/<br>           i=fclose(fp);            /*关闭打开的文件*/<br>           if(i==0)                 /*判断文件是否关闭成功*/<br>             printf("O,K");         /*提示关闭成功*/<br>           else<br>             puts("File close error");/*提示关闭不成功*/<br>      }<br>  </p> 
<p> </p> 
<p> </p> 
<p>二、有关文件操作的函数<br>     本节所讲的文件读写函数均是指顺序读写, 即读写了一条信息后, 指针自动加1。下面分别介绍写操作函数和读操作函数。</p> 
<p>    1. 文件的顺序写函数<br>    <span style="color:#f33b45;"><strong> fprintf()、fputs()和fputc()</strong></span>函数<br>     函数fprintf()、fputs()和fputc()均为文件的顺序写操作函数,  其调用格式如下:<br>     int fprintf(FILE *stream, char *format, &lt;variable-list&gt;);<br>     int fputs(char *string, FILE *steam);<br>     int fputc(int ch, FILE *steam);<br>     上述三个函数的返回值均为整型量。fprintf() 函数的返回值为实际写入文件中的字罕个数(字节数)。如果写错误, 则返回一个负数, fputs()函数返回0时表明将string指针所指的字符串写入文件中的操作成功, 返回非0时,  表明写操作失败。fputc()函数返回一个向文件所写字符的值, 此时写操作成功,  否则返回EOF(文件结束结束其值为-1, 在stdio.h中定义)表示写操作错误。<br>      fprintf( ) 函数中格式化的规定与printf( ) 函数相同,   所不同的只是 fprintf()函数是向文件中写入。而printf()是向屏幕输出。<br>     下面介绍一个例子, 运行后产后一个test.dat的文件。<br>     例11:<br>      #include&lt;stdio.h&gt;<br>      main()<br>      {<!-- --><br>           char *s="That's good news");  /*定义字符串指针并初始化*/<br>           int i=617;                    /*定义整型变量并初始化*/<br>           FILE *fp;                     /*定义文件指针*/<br>           fp=fopne("test.dat", "w");    /*建立一个文字文件只写*/<br>           fputs("Your score of TOEFLis", fp);/*向所建文件写入一串字符*/<br>           fputc(':', fp);               /*向所建文件写冒号:*/<br>           fprintf(fp, "%d/n", i);       /*向所建文件写一整型数*/<br>           fprintf(fp, "%s", s);         /*向所建文件写一字符串*/<br>           fclose(fp);                   /*关闭文件*/<br>      }<br>     用DOS的TYPE命令显示TEST.DAT的内容如下所示:<br>     屏幕显示<br>       Your score of TOEFL is: 617<br>       That's good news</p> 
<p>    2. 文件的顺序读操作函数<br>    <span style="color:#f33b45;"><strong> fscanf()、fgets()和fgetc()</strong></span>函数<br>     函数fscanf()、fgets()和fgetc()均为文件的顺序读操作函数, 其调用格式如下:<br>      int fscanf(FILE *stream, char *format, &lt;address-list&gt;);<br>      char fgets(char *string, int n, FILE *steam);<br>      int fgetc(FILE *steam);<br>     fscanf()函数的用法与scanf()函数相似,   只是它是从文件中读到信息。 fscanf()函数的返回值为EOF(即-1), 表明读错误, 否则读数据成功。fgets()函数从文件中读取至多n-1个字符(n用来指定字符数), 并把它们放入string指向的字符串中, 在读入之后自动向字符串未尾加一个空字符, 读成功返回string指针, 失败返回一个空指针。fgetc()函数返回文件当前位置的一个字符,  读错误时返回EOF。<br>     下面程序读取例11产生的test.dat文件, 并将读出的结果显示在屏幕上。<br>     例12<br>      #include&lt;stdio.h&gt;<br>      main()<br>      {<!-- --><br>           char *s, m[20];<br>           int i;<br>           FILE  *fp;<br>           fp=fopen("test.dat", "r");    /*打开文字文件只读*/<br>           fgets(s, 24, fp);             /*从文件中读取23个字符*/<br>           printf("%s", s);              /*输出所读的字符串*/<br>           fscanf(fp, "%d", &amp;i);         /*读取整型数*/<br>           printf("%d", i);              /*输出所读整型数*/<br>           putchar(fgetc(fp));           /*读取一个字符同时输出*/<br>           fgets(m, 17, fp);             /*读取16个字符*/<br>           puts(m);                      /*输出所读字符串*/<br>           fclose(fp);                   /*关闭文件*/<br>           getch();                      /*等待任一键*/<br>      }<br>     运行后屏幕显示:<br>     Your score of TOEFL is: 617<br>     That's good news<br>     如果将上例中fscanf(fp, "%d", &amp;i)改为fscanf(fp, "%s", m),  再将其后的输出语句改为printf("%s", m), 则可得出同样的结果。由此可见Turbo C2. 0 中只要是读文字文件, 则不论是字符还是数字都将按其ASCII值处理。 另外还要说明的一点就是fscanf()函数读到空白符时, 便自动结束, 在使用时要特别注意。</p> 
<p>    3. 文件的随机读写<br>     有时用户想直接读取文件中间某处的信息, 若用文件的顺序读写必须从文件头开始直到要求的文件位置再读, 这显然不方便。Turbo C2.0提供了一组文件的随机读写函数, 即可以将文件位置指针定位在所要求读写的地方直接读写。<br>     文件的随机读写函数如下:<br>     int <span style="color:#f33b45;"><strong>fseek</strong></span> (FILE *stream, long offset, int fromwhere);<br>     int <span style="color:#f33b45;"><strong>fread</strong></span>(void *buf, int size, int count, FILE *stream);<br>     int <span style="color:#f33b45;"><strong>fwrite</strong></span>(void *buf, int size, int count, FILE *stream);<br>     long <span style="color:#f33b45;"><strong>ftell</strong></span>(FILE *stream);<br>     fseek()函数的作用是将文件的位置指针设置到从fromwhere开始的第offset 字节的位置上, 其中fromwhere是下列几个宏定义之一:<br>     文件位置指针起始计算位置fromwhere ━━━━━━━━━━━━━━━━━━━━━━━━━━━<br>     符号常数         数值           含义            ───────────────────────<br>     SEEK_SET           0        从文件开头<br>     SEEK_CUR          1        从文件指针的现行位置<br>     SEEK_END          2        从文件末尾    ━━━━━━━━━━━━━━━━━━━━━━━━━━━<br>     offset是指文件位置指针从指定开始位置(fromwhere指出的位置)跳过的字节数。它是一个长整型量, 以支持大于64K字节的文件。fseek()函数一般用于对二进制文件进行操作。<br>     当fseek()函数返回0时表明操作成功, 返回非0表示失败。<br>     下面程序从二进制文件test_b.dat中读取第8个字节。<br>     例13:<br>      #include&lt;stdio.h&gt;<br>      main()<br>      {<!-- --><br>           FILE *fp;<br>           if((fp=fopen("test_b.dat", "rb"))==NULL)<br>             {<!-- --><br>               printf("Can't open file");<br>               exit(1);<br>             }<br>           fseek(fp, 8. 1, SEEK_SET);<br>           fgetc(fp);<br>           fclose(fp);<br>      }<br>     fread()函数是从文件中读count个字段, 每个字段长度为size个字节, 并把它们存放到buf指针所指的缓冲器中。<br>     fwrite()函数是把buf指针所指的缓冲器中, 长度为size个字节的count个字段写到stream指向的文件中去。<br>     随着读和写字节数的增大, 文件位置指示器也增大, 读多少个字节, 文件位置指示器相应也跳过多少个字节。读写完毕函数返回所读和所写的字段个数。<br>     ftell()函数返回文件位置指示器的当前值,  这个值是指示器从文件头开始算起的字节数, 返回的数为长整型数, 当返回-1时, 表明出现错误。<br>     下面程序把一个浮点数组以二进制方式写入文件test_b.dat中。<br>     例14:<br>      #include &lt;stdio.h&gt;<br>      main()<br>      {<!-- --><br>           float f[6]={3.2, -4.34, 25.04, 0.1, 50.56, 80.5};<br>                          /*定义浮点数组并初始化*/<br>           int i;<br>           FILE *fp;<br>           fp=fopen("test_b.dat", "wb"); /*创建一个二进制文件只写*/<br>           fwrite(f, sizeof(float), 6, fp);/*将6个浮点数写入文件中*/<br>           fclose(fp);                   /*关闭文件*/<br>      }<br>     下面例子从test_b.dat文件中读100个整型数, 并把它们放到dat数组中。<br>     例15:<br>      #include &lt;stdio.h&gt;<br>      main()<br>      {<!-- --><br>           FILE *fp;<br>           int dat[100];<br>           fp=fopen("test_b.dat", "rb");/*打开一个二进制文件只读*/<br>           if(fread(dat, sizeof(int), 100, fp)!=100)<br>                                         /*判断是否读了100个数*/<br>             {<!-- --><br>                if(feof(fp))<br>                  printf("End of file"); /*不到100个数文件结束*/<br>                else<br>                  printf("Read error");  /*读数错误*/<br>           fclose(fp);                   /*关闭文件*/<br>      }<br>     注意:<br>     当用标准文件函数对文件进行读写操作时, 首先将所读写的内容放进缓冲区, 即写函数只对输出缓冲区进行操作, 读函数只对输入缓冲区进行操作。例如向一个文件写入内容, 所写的内容将首先放在输出缓冲区中, 直到输出缓冲区存满或使用fclose()函数关闭文件时, 缓冲区的内容才会写入文件中。若无fclose() 函数, 则不会向文件中存入所写的内容或写入的文件内容不全。有一个对缓冲区进行刷新的函数, 即fflush(), 其调用格式为:<br>     int fflush(FILE *stream);<br>     该函数将输出缓冲区的内容实际写入文件中, 而将输入缓冲区的内容清除掉。</p> 
<p>    4.<span style="color:#f33b45;"><strong> feof()和rewind()</strong></span>函数<br>     这两个函数的调用格式为:<br>      int feof(FILE *stream);<br>      int rewind(FILE *stream);<br>     feof()函数检测文件位置指示器是否到达了文件结尾,  若是则返回一个非0 值, 否则返回0。这个函数对二进制文件操作特别有用, 因为二进制文件中,  文件结尾标志EOF也是一个合法的二进制数,  只简单的检查读入字符的值来判断文件是否结束是不行的。如果那样的话, 可能会造成文件未结尾而被认为结尾, 所以就必须有feof()函数。<br>     下面的这条语句是常用的判断文件是否结束的方法。<br>      while(!feof(fp))<br>         fgetc(fp);<br>     while为循环语句, 将在下面介绍。<br>     rewind()函数用于把文件位置指示器移到文件的起点处, 成功时返回0,  否则, 返回非0值。</p> 
<p><br>     1.2.2  非标准文件函数<br>     这类函数最早用于UNIX操作系统, ANSI标准未定义,   但有时也经常用到, DOS 3.0以上版本支持这些函数。它们的头文件为io.h。<br>     一、文件的打开和关闭<br>     1. <span style="color:#f33b45;"><strong>open()</strong></span>函数<br>     open()函数的作用是打开文件, 其调用格式为:<br>      int open(char *filename, int access);<br>     该函数表示按access的要求打开名为filename的文件, 返回值为文件描述字, 其中access有两部分内容: 基本模式和修饰符, 两者用" "("或")方式连接。修饰符可以有多个, 但基本模式只能有一个。access的规定如表3-2。<br>                表3-2  access的规定</p> 
<p>━━━━━━━━━━━━━━━━━━━━━━━━━━━━</p> 
<p>基本模式         含义    修饰符         含  义</p> 
<p>────────────────────────────</p> 
<p>O_RDONLY    只读   O_APPEND   文件指针指向末尾</p> 
<p>O_WRONLY    只写   O_CREAT    文件不存在时创建文件, 属性按基本模式属性</p> 
<p>O_RDWR      读写   O_TRUNC    若文件存在, 将其长度缩为0, 属性不变</p> 
<p><br> O_BINARY   打开一个二进制文件<br> O_TEXT       打开一个文字文件</p> 
<p>━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br>     open()函数打开成功, 返回值就是文件描述字的值(非负值), 否则返回-1。</p> 
<p>    2. <span style="color:#f33b45;"><strong>close()</strong></span>函数<br>     close()函数的作用是关闭由open()函数打开的文件, 其调用格式为:<br>      int close(int handle);<br>     该函数关闭文件描述字handle相连的文件。</p> 
<p>    二、读写函数<br>     1. <span style="color:#f33b45;"><strong>read()</strong></span>函数<br>     read()函数的调用格式为:<br>      int read(int handle, void *buf, int count);<br>     read()函数从handle(文件描述字)相连的文件中, 读取count个字节放到buf 所指的缓冲区中, 返回值为实际所读字节数, 返回-1表示出错。返回0 表示文件结束。</p> 
<p>    2. <span style="color:#f33b45;"><strong>write()</strong></span>函数<br>     write()函数的调用格式为:<br>      int write(int handle, void *buf, int count);<br>     write()函数把count个字节从buf指向的缓冲区写入与handle相连的文件中, 返回值为实际写入的字节数。</p> 
<p>    三、随机定位函数<br>     1.<span style="color:#f33b45;"><strong> lseek()</strong></span>函数<br>     lseek()函数的调用格式为:<br>      int lseek(int handle, long offset, int fromwhere);<br>     该函数对与handle相连的文件位置指针进行定位, 功能和用法与fseek() 函数相同。</p> 
<p>    2. <span style="color:#f33b45;"><strong>tell()</strong></span>函数<br>     tell()函数的调用格式为:<br>      long tell(int handle);<br>     该函数返回与handle相连的文件现生位置指针, 功能和用法与ftell()相同。<br> ————————————————<br> 原文链接：https://blog.csdn.net/zwt0112/article/details/54582036</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d7d9b8f1fa701d105c688272cad6d122/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android集成高德地图实现自定义Marker</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/88c5609bf0c5c8257794b61f497da3b0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CDH zookeeper 问题处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>