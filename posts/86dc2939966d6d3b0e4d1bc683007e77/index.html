<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java getter返回值_使用Java中的getter方法返回私有集合 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java getter返回值_使用Java中的getter方法返回私有集合" />
<meta property="og:description" content="我有许多在内部使用私有集或列表的Java类.我希望能够使用get … List()方法返回这些集/列表.
我正在考虑的替代方案：
&gt;返回对内部对象的引用
&gt;构建一个新的集/列表并填写它(这似乎是不好的做法？)
&gt;使用Collections.unmodifiableList(partitions);
以下哪一项是解决此问题的最常见/最佳方式？
解决方法:
这里有许多方面需要考虑.正如其他人已经指出的那样,最终决定取决于你的意图,但有关这三个选项的一般性陈述：
1.返回对内部对象的引用
这可能会带来问题.当你这样做时,你几乎不可能保证一致的状态.调用者可能会获取列表,然后做一些讨厌的事情
List list = object.getList();
list.clear();
list.add(null);
...
也许不是出于恶意,而是偶然,因为他认为安全/允许这样做.
2.构建一个新的集/列表并填写它(这似乎是不好的做法？)
这不是一般的“坏习惯”.无论如何,它是API设计方面迄今为止最安全的解决方案.这里唯一需要注意的是,可能存在性能损失,具体取决于几个因素.例如.列表中包含多少元素,以及如何使用返回的列表.像这样的一些(可疑的？)模式
for (int i=0; i
{
Element element = object.getList().get(i);
...
}
可能会变得非常昂贵(尽管有人可能会争辩说,在这种特殊情况下,是否是这样实现它的用户的错,一般问题仍然有效)
3.使用Collections.unmodifiableList(partitions);
这是我个人经常使用的.它在API设计意义上是安全的,与复制列表相比,其开销只有微不足道.但是,调用者在获得对它的引用之后知道该列表是否可能发生变化是很重要的.
这导致…
最重要的建议：
记录方法正在做什么！不要写这样的评论
/**
* Returns the list of elements.
*
* @return The list of elements.
*/
public List getList() { ... }
而是指定您可以确定列表的内容.例如
/**
* Returns a copy of the list of elements." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/86dc2939966d6d3b0e4d1bc683007e77/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-01T15:45:36+08:00" />
<meta property="article:modified_time" content="2021-03-01T15:45:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java getter返回值_使用Java中的getter方法返回私有集合</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>我有许多在内部使用私有集或列表的Java类.我希望能够使用get … List()方法返回这些集/列表.</p> 
 <p>我正在考虑的替代方案：</p> 
 <p>&gt;返回对内部对象的引用</p> 
 <p>&gt;构建一个新的集/列表并填写它(这似乎是不好的做法？)</p> 
 <p>&gt;使用Collections.unmodifiableList(partitions);</p> 
 <p>以下哪一项是解决此问题的最常见/最佳方式？</p> 
 <p>解决方法:</p> 
 <p>这里有许多方面需要考虑.正如其他人已经指出的那样,最终决定取决于你的意图,但有关这三个选项的一般性陈述：</p> 
 <p>1.返回对内部对象的引用</p> 
 <p>这可能会带来问题.当你这样做时,你几乎不可能保证一致的状态.调用者可能会获取列表,然后做一些讨厌的事情</p> 
 <p>List list = object.getList();</p> 
 <p>list.clear();</p> 
 <p>list.add(null);</p> 
 <p>...</p> 
 <p>也许不是出于恶意,而是偶然,因为他认为安全/允许这样做.</p> 
 <p>2.构建一个新的集/列表并填写它(这似乎是不好的做法？)</p> 
 <p>这不是一般的“坏习惯”.无论如何,它是API设计方面迄今为止最安全的解决方案.这里唯一需要注意的是,可能存在性能损失,具体取决于几个因素.例如.列表中包含多少元素,以及如何使用返回的列表.像这样的一些(可疑的？)模式</p> 
 <p>for (int i=0; i</p> 
 <p>{<!-- --></p> 
 <p>Element element = object.getList().get(i);</p> 
 <p>...</p> 
 <p>}</p> 
 <p>可能会变得非常昂贵(尽管有人可能会争辩说,在这种特殊情况下,是否是这样实现它的用户的错,一般问题仍然有效)</p> 
 <p>3.使用Collections.unmodifiableList(partitions);</p> 
 <p>这是我个人经常使用的.它在API设计意义上是安全的,与复制列表相比,其开销只有微不足道.但是,调用者在获得对它的引用之后知道该列表是否可能发生变化是很重要的.</p> 
 <p>这导致…</p> 
 <p>最重要的建议：</p> 
 <p>记录方法正在做什么！不要写这样的评论</p> 
 <p>/**</p> 
 <p>* Returns the list of elements.</p> 
 <p>*</p> 
 <p>* @return The list of elements.</p> 
 <p>*/</p> 
 <p>public List getList() { ... }</p> 
 <p>而是指定您可以确定列表的内容.例如</p> 
 <p>/**</p> 
 <p>* Returns a copy of the list of elements...</p> 
 <p>*/</p> 
 <p>要么</p> 
 <p>/**</p> 
 <p>* Returns an unmodifiable view on the list of elements...</p> 
 <p>*/</p> 
 <p>就个人而言,我总是在这种文档的两个选项之间徘徊：</p> 
 <p>&gt;明确该方法正在做什么以及如何使用它</p> 
 <p>&gt;不要暴露或过度指定实施细节</p> 
 <p>例如,我经常写这样的文档：</p> 
 <p>/**</p> 
 <p>* Returns an unmodifiable view on the list of elements.</p> 
 <p>* Changes in this object will be visible in the returned list.</p> 
 <p>*/</p> 
 <p>第二句是关于行为的明确而有约束力的陈述.调用者知道这一点非常重要.对于并发应用程序(并且大多数应用程序以一种方式或另一种方式并发),这意味着调用者必须假定列表在获得引用后可能会同时更改,这可能会导致在发生更改时发生ConcurrentModificationException正在迭代列表.</p> 
 <p>但是,这些详细的规范限制了之后改变实现的可能性.如果您以后决定返回内部列表的副本,则行为将以不兼容的方式更改.</p> 
 <p>所以有时候我也明确指出没有指定行为：</p> 
 <p>/**</p> 
 <p>* Returns an unmodifiable list of elements. It is unspecified whether</p> 
 <p>* changes in this object will be visible in the returned list. If you</p> 
 <p>* want to be informed about changes, you may attach a listener to this</p> 
 <p>* object using this-and-that method...</p> 
 <p>*/</p> 
 <p>当您打算创建公共API时,这些问题主要是不重要的.一旦你以某种方式实现它,人们就会以一种或另一种方式依赖这种行为.</p> 
 <p>所以回到第一点：它总是取决于你想要达到的目标.</p> 
 <p>标签：java</p> 
 <p>来源： https://codeday.me/bug/20190722/1506855.html</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b03d0484dba3c38b558058f2dc780172/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Linux内核时钟的简单闹钟应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c4db5b3d0255de17906f6f5e63ecd45/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【论文笔记】STANet：基于孪生神经网络的时空注意力变化检测模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>