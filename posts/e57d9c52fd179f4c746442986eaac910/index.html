<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>(七) 构建应用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="(七) 构建应用" />
<meta property="og:description" content="Chapter 7 Building Applications 译：章节7 构建应用 7.1 Using MapServer 译：7.1 使用 MapServer The Minnesota MapServer is an internet web-mapping server which conforms to the OpenGIS Web Map Service specification.
译：Minnesota 地图服务器是一个符合OpenGIS网络地图服务规范的互联网网络地图服务器。
• MapServer 主页
• OpenGIS Web地图服务规范
7.1.1 Basic Usage 译：7.1.1 基础用法 To use PostGIS with MapServer, you need to know how to configure MapServer, which is beyond the scope of this documentation. This section covers specific PostGIS issues and configuration details." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e57d9c52fd179f4c746442986eaac910/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-18T17:48:49+08:00" />
<meta property="article:modified_time" content="2023-07-18T17:48:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">(七) 构建应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>Chapter 7 Building Applications</h2> 
<h2><a name="t1"></a>译：章节7 构建应用</h2> 
<h3>7.1 Using MapServer</h3> 
<h3><a name="t3"></a>译：7.1  使用 MapServer</h3> 
<p>        The Minnesota MapServer is an internet web-mapping server which conforms to the OpenGIS Web Map Service specification.</p> 
<p>        译：Minnesota 地图服务器是一个符合OpenGIS网络地图服务规范的互联网网络地图服务器。</p> 
<blockquote> 
 <p>• <a class="link-info" href="http://mapserver.org" rel="nofollow" title="MapServer 主页">MapServer 主页</a></p> 
 <p>• <a class="link-info" href="http://www.opengeospatial.org/standards/wms" rel="nofollow" title="OpenGIS Web地图服务规范">OpenGIS Web地图服务规范</a></p> 
</blockquote> 
<h4>7.1.1 Basic Usage</h4> 
<h4><a name="t7"></a>译：7.1.1 基础用法</h4> 
<p>        To use PostGIS with MapServer, you need to know how to configure MapServer, which is beyond the scope of this documentation. This section covers specific PostGIS issues and configuration details.</p> 
<p>        译：要将PostGIS与MapServer一起使用，您需要知道如何配置MapServer，这超出了本文档的范围。本节介绍PostGIS的具体问题和配置细节。</p> 
<p>        To use PostGIS with MapServer, you will need:</p> 
<p>        译：要将PostGIS与MapServer一起使用，您需要：</p> 
<blockquote> 
 <p>• PostGIS V0.6+</p> 
 <p>• MapServer V3.5+</p> 
</blockquote> 
<p>        MapServer accesses PostGIS/PostgreSQL data like any other PostgreSQL client, using the libpq interface. This means that MapServer can be installed on any machine with network access to the PostGIS server, and use PostGIS as a source of data. The faster the connection between the systems, the better.</p> 
<p>        译：MapServer像任何其他PostgreSQL客户端一样，使用libpq接口访问PostGIS/PostgreSQL数据。这意味着MapServer可以安装在任何可以通过网络访问PostGIS服务器的机器上，并使用PostGIS作为数据源。系统之间的连接越快越好。</p> 
<blockquote> 
 <p>1. Compile and install MapServer, with whatever options you desire, including the "--with-postgis" configuration option.</p> 
 <p>        译：编译并安装MapServer，使用您想要的任何选项，包括“--withpostgis”配置选项。</p> 
 <p>2. In your MapServer map file, add a PostGIS layer. For example:</p> 
 <p>        译：在MapServer地图文件中，添加一个PostGIS图层。例如：</p> 
 <pre><code class="hljs">LAYER
    CONNECTIONTYPE postgis
    NAME "widehighways"
    # Connect to a remote spatial database
    CONNECTION "user=dbuser dbname=gisdatabase host=bigserver"
    PROCESSING "CLOSE_CONNECTION=DEFER"
    # Get the lines from the 'geom' column of the 'roads' table
    DATA "geom from roads using srid=4326 using unique gid"
    STATUS ON
    TYPE LINE
    # Of the lines in the extents, only render the wide highways
    FILTER "type = 'highway' and numlanes &gt;= 4"
    CLASS
        # Make the superhighways brighter and 2 pixels wide
        EXPRESSION ([numlanes] &gt;= 6)
        STYLE
            COLOR 255 22 22
            WIDTH 2
        END
    END
    CLASS
        # All the rest are darker and only 1 pixel wide
        EXPRESSION ([numlanes] &lt; 6)
        STYLE
            COLOR 205 92 82
        END
    END
END
</code></pre> 
 <p>        In the example above, the PostGIS-specific directives are as follows:</p> 
 <p>        译：在上面的示例中，PostGIS特定指令如下：</p> 
 <p><strong>CONNECTIONTYPE</strong> For PostGIS layers, this is always "postgis".</p> 
 <p>        译：对于PostGIS层，这始终是“PostGIS”。</p> 
 <p><strong>CONNECTION</strong> The database connection is governed by the a ’connection string’ which is a standard set of keys and values like this (with the default values in &lt;&gt;): user= password= dbname= hostname= port= An empty connection string is still valid, and any of the key/value pairs can be omitted. At a minimum you will generally supply the database name and username to connect with.</p> 
 <p>        译：数据库连接由一个“连接字符串”控制，该字符串是一组标准的键和值，如下所示（默认值在＜＞中）：user=password=dbname=hostname=port=空连接字符串仍然有效，任何键/值对都可以省略。至少，您通常会提供要连接的数据库名称和用户名。</p> 
 <p><strong>DATA</strong> The form of this parameter is " from using srid= using unique " where the column is the spatial column to be rendered to the map, the SRID is SRID used by the column and the primary key is the table primary key (or any other uniquely-valued column with an index). You can omit the "using srid" and "using unique" clauses and MapServer will automatically determine the correct values if possible, but at the cost of running a few extra queries on the server for each map draw.</p> 
 <p>        译：此参数的形式为“from using srid=using unique”，其中列是要呈现到映射的空间列，srid是列使用的srid，主键是表主键（或任何其他具有索引的唯一值列）。您可以省略“using srid”和“using unique”子句，如果可能的话，MapServer将自动确定正确的值，但代价是在服务器上为每次绘制地图运行一些额外的查询。</p> 
 <p><strong>PROCESSING</strong> Putting in a CLOSE_CONNECTION=DEFER if you have multiple layers reuses existing connections instead of closing them. This improves speed. Refer to for MapServer PostGIS Performance Tips for a more detailed explanation.</p> 
 <p>        译：如果有多个层，放入CLOSE_CONNECTION=DEFER会重用现有的连接，而不是关闭它们。这提高了速度。有关更详细的解释，请参阅MapServer PostGIS性能提示。</p> 
 <p><strong>FILTER</strong> The filter must be a valid SQL string corresponding to the logic normally following the "WHERE" keyword in a SQL query. So, for example, to render only roads with 6 or more lanes, use a filter of "num_lanes &gt;= 6".</p> 
 <p>        译：筛选器必须是与SQL查询中通常位于“WHERE”关键字后面的逻辑相对应的有效SQL字符串。因此，例如，要仅渲染具有6条或更多车道的道路，请使用“num_lanes&gt;=6”的过滤器。</p> 
 <p>3. In your spatial database, ensure you have spatial (GiST) indexes built for any the layers you will be drawing.</p> 
 <p>        译：在空间数据库中，确保为要绘制的任何图层都建立了空间（GiST）索引。</p> 
 <pre><code class="language-sql">CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometrycolumn] );</code></pre> 
 <p>4. If you will be querying your layers using MapServer you will also need to use the "using unique" clause in your DATA statement.</p> 
 <p>        译：如果要使用MapServer查询图层，还需要在DATA语句中使用“使用唯一”子句。</p> 
 <p>        MapServer requires unique identifiers for each spatial record when doing queries, and the PostGIS module of MapServer uses the unique value you specify in order to provide these unique identifiers. Using the table primary key is the best practice.</p> 
 <p>        译：在进行查询时，MapServer要求每个空间记录都有唯一的标识符，而MapServer的PostGIS模块使用您指定的唯一值来提供这些唯一的标识符。使用表主键是最佳实践。</p> 
</blockquote> 
<h4>7.1.2 Frequently Asked Questions</h4> 
<h4>译：7.1.2 常见问题解答</h4> 
<p>1. When I use an EXPRESSION in my map file, the condition never returns as true, even though I know the values exist in my table.</p> 
<p>        译：当我在映射文件中使用表达式时，即使我知道表中存在值，条件也永远不会返回true。</p> 
<p>        Unlike shape files, PostGIS field names have to be referenced in EXPRESSIONS using lower case.</p> 
<p>        译：与形状文件不同，PostGIS字段名称必须在EXPRESSIONS中使用小写引用。</p> 
<blockquote> 
 <p>EXPRESSION ([numlanes] &gt;= 6)</p> 
</blockquote> 
<p> 2. The FILTER I use for my Shapefiles is not working for my PostGIS table of the same data.</p> 
<p>        译：我用于Shapefiles的FILTER不适用于相同数据的PostGIS表。</p> 
<p>        Unlike shape files, filters for PostGIS layers use SQL syntax (they are appended to the SQL statement the PostGIS connector generates for drawing layers in MapServer).</p> 
<p>        译：与形状文件不同，PostGIS图层的过滤器使用SQL语法（它们附加到PostGIS连接器为MapServer中的图形图层生成的SQL语句中）。</p> 
<blockquote> 
 <p>FILTER "type = 'highway' and numlanes &gt;= 4"</p> 
</blockquote> 
<p> 3. My PostGIS layer draws much slower than my Shapefile layer, is this normal?</p> 
<p>        译：我的PostGIS图层绘制速度比我的Shapefile图层慢得多，这正常吗？</p> 
<p>        In general, the more features you are drawing into a given map, the more likely it is that PostGIS will be slower than Shapefiles. For maps with relatively few features (100s), PostGIS will often be faster. For maps with high feature density (1000s), PostGIS will always be slower. If you are finding substantial draw performance problems, it is possible that you have not built a spatial index on your table.</p> 
<p>        译：通常，在给定地图中绘制的要素越多，PostGIS的速度就越可能慢于Shapefiles。对于特征相对较少的地图（100个），PostGIS通常会更快。对于具有高特征密度（1000s）的地图，PostGIS的速度总是较慢。如果您发现绘图性能存在实质性问题，则可能是您没有在表上建立空间索引。</p> 
<blockquote> 
 <p>postgis# CREATE INDEX geotable_gix ON geotable USING GIST ( geocolumn );</p> 
 <p>postgis# VACUUM ANALYZE;</p> 
</blockquote> 
<p>4. My PostGIS layer draws fine, but queries are really slow. What is wrong?</p> 
<p>        译：我的PostGIS层绘制得很好，但查询确实很慢。怎么了？</p> 
<p>        For queries to be fast, you must have a unique key for your spatial table and you must have an index on that unique key.You can specify what unique key for mapserver to use with the USING UNIQUE clause in your DATA line:</p> 
<p>        译：为了快速查询，空间表必须有一个唯一键，并且该唯一键上必须有索引。您可以指定映射服务器要与DATA行中的USING unique子句一起使用的唯一键：</p> 
<pre><code class="language-sql">DATA "geom FROM geotable USING UNIQUE gid"</code></pre> 
<p>5. Can I use "geography" columns (new in PostGIS 1.5) as a source for MapServer layers?</p> 
<p>        译：我可以使用“geography”列（PostGIS 1.5中的新列）作为MapServer层的源吗？</p> 
<p>        Yes! MapServer understands geography columns as being the same as geometry columns, but always using an SRID of 4326. Just make sure to include a "using srid=4326" clause in your DATA statement. Everything else works exactly the same as with geometry.</p> 
<p>        译：是的。对MapServer将地理列理解为与几何体列相同，但始终使用4326的SRID。只需确保在DATA语句中包含一个“usingsrid=4326”子句。其他一切的工作原理与几何体完全相同。</p> 
<blockquote> 
 <p>DATA "geog FROM geogtable USING SRID=4326 USING UNIQUE gid"</p> 
</blockquote> 
<h4>7.1.3 Advanced Usage</h4> 
<h4>译：7.1.3 高级用法</h4> 
<p>        The USING pseudo-SQL clause is used to add some information to help mapserver understand the results of more complex queries. More specifically, when either a view or a subselect is used as the source table (the thing to the right of "FROM" in a DATA definition) it is more difficult for mapserver to automatically determine a unique identifier for each row and also the SRID for the table. The USING clause can provide mapserver with these two pieces of information as follows: </p> 
<p>        译：USING伪SQL语句用于添加一些信息，以帮助mapserver了解更复杂查询的结果。更具体地说，当视图或子选择用作源表（数据定义中“FROM”右侧的内容）时，映射服务器更难自动确定每行的唯一标识符以及表的SRID。USING子句可以向mapserver提供以下两条信息：</p> 
<pre><code class="language-java">DATA "geom FROM (
    SELECT
        table1.geom AS geom,
        table1.gid AS gid,
        table2.data AS data
    FROM table1
    LEFT JOIN table2
    ON table1.id = table2.id
) AS new_table USING UNIQUE gid USING SRID=4326"</code></pre> 
<p><strong>USING UNIQUE&lt;uniqueid&gt;</strong></p> 
<p><strong>        </strong>MapServer requires a unique id for each row in order to identify the row when doing map queries. Normally it identifies the primary key from the system tables. However, views and subselects don’t automatically have an known unique column. If you want to use MapServer’s query functionality, you need to ensure your view or subselect includes a uniquely valued column, and declare it with USING UNIQUE. For example, you could explicitly select nee of the table’s primary key values for this purpose, or any other column which is guaranteed to be unique for the result set.</p> 
<p>        译：MapServer要求每一行都有一个唯一的id，以便在进行地图查询时识别该行。通常，它从系统表中标识主键。但是，视图和子选择器不会自动具有已知的唯一列。如果要使用MapServer的查询功能，则需要确保视图或子选择包含一个值唯一的列，并使用USING UNIQUE声明该列。例如，您可以为此目的显式地选择表的主键值中的nee，或者保证对结果集唯一的任何其他列。</p> 
<hr> 
<p><img alt="" height="53" src="https://images2.imgbox.com/74/d9/fNhgS59T_o.png" width="59"><strong>Note/笔记</strong></p> 
<p>        "Querying a Map" is the action of clicking on a map to ask for information about the map features in that location. Don’t confuse "map queries" with the SQL query in a DATA definition.</p> 
<p>        译：“查询地图”是指点击地图，询问该位置地图特征的信息。不要混淆“映射查询”和DATA定义中的SQL查询。</p> 
<hr> 
<p><strong>USING SRID=&lt;srid&gt;</strong></p> 
<p>        PostGIS needs to know which spatial referencing system is being used by the geometries in order to return the correct data back to MapServer. Normally it is possible to find this information in the "geometry_columns" table in the PostGIS database, however, this is not possible for tables which are created on the fly such as subselects and views. So the USING SRID= option allows the correct SRID to be specified in the DATA definition.</p> 
<p>        译：PostGIS需要知道几何图形正在使用哪个空间参考系统，以便将正确的数据返回MapServer。通常情况下，可以在PostGIS数据库的“geometry_columns”表中找到这些信息，但对于动态创建的表（如子选项和视图），这是不可能的。因此，USING SRID=选项允许在DATA定义中指定正确的SRID。</p> 
<h4>7.1.4 Examples</h4> 
<h4>译：7.1.4 示例</h4> 
<p>        Lets start with a simple example and work our way up. Consider the following MapServer layer definition:</p> 
<p>        译：让我们从一个简单的例子开始。请看以下MapServer图层定义：</p> 
<pre><code class="language-java">LAYER
    CONNECTIONTYPE postgis
    NAME "roads"
    CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
    DATA "geom from roads"
    STATUS ON
    TYPE LINE
    CLASS
        STYLE
            COLOR 0 0 0
        END
    END
END
</code></pre> 
<p>        This layer will display all the road geometries in the roads table as black lines.</p> 
<p>        译：该图层将道路表中的所有道路几何图形显示为黑线。</p> 
<p>        Now lets say we want to show only the highways until we get zoomed in to at least a 1:100000 scale - the next two layers will achieve this effect:</p> 
<p>        译：现在，我们只想显示高速公路，直到我们放大到至少1:100000的比例——接下来的两个图层将达到这种效果：</p> 
<pre><code class="language-java">LAYER
    CONNECTIONTYPE postgis
    CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
    PROCESSING "CLOSE_CONNECTION=DEFER"
    DATA "geom from roads"
    MINSCALE 100000
    STATUS ON
    TYPE LINE
    FILTER "road_type = 'highway'"
    CLASS
        COLOR 0 0 0
    END
END
LAYER
    CONNECTIONTYPE postgis
    CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
    PROCESSING "CLOSE_CONNECTION=DEFER"
    DATA "geom from roads"
    MAXSCALE 100000
    STATUS ON
    TYPE LINE
    CLASSITEM road_type
    CLASS
        EXPRESSION "highway"
        STYLE
            WIDTH 2
            COLOR 255 0 0
        END
    END
    CLASS
        STYLE
            COLOR 0 0 0
        END
    END
END
</code></pre> 
<p>        The first layer is used when the scale is greater than 1:100000, and displays only the roads of type "highway" as black lines. The FILTER option causes only roads of type "highway" to be displayed.</p> 
<p>        译：当比例大于1:100000时，将使用第一层，并且仅将“公路”类型的道路显示为黑线。FILTER选项只显示“高速公路”类型的道路。</p> 
<p>        The second layer is used when the scale is less than 1:100000, and will display highways as double-thick red lines, and other roads as regular black lines.</p> 
<p>        译：当比例小于1:100000时使用第二层，并将高速公路显示为双粗红线，其他道路显示为规则黑线。</p> 
<p>        So, we have done a couple of interesting things using only MapServer functionality, but our DATA SQL statement has remained simple. Suppose that the name of the road is stored in another table (for whatever reason) and we need to do a join to get it and label our roads.</p> 
<p>        译：因此，我们只使用MapServer功能做了一些有趣的事情，但我们的DATASQL语句仍然很简单。假设道路的名称存储在另一个表中（无论出于何种原因），我们需要进行连接来获取它并标记我们的道路。</p> 
<pre><code class="language-java">LAYER
    CONNECTIONTYPE postgis
    CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
    DATA "geom FROM (SELECT roads.gid AS gid, roads.geom AS geom,
        road_names.name as name FROM roads LEFT JOIN road_names ON
        roads.road_name_id = road_names.road_name_id)
        AS named_roads USING UNIQUE gid USING SRID=4326"
    MAXSCALE 20000
    STATUS ON
    TYPE ANNOTATION
    LABELITEM name
    CLASS
        LABEL
            ANGLE auto
            SIZE 8
            COLOR 0 192 0
            TYPE truetype
            FONT arial
        END
    END
END</code></pre> 
<p>        This annotation layer adds green labels to all the roads when the scale gets down to 1:20000 or less. It also demonstrates how to use an SQL join in a DATA definition.</p> 
<p>        译：当比例降到1:20000或更低时，此注释层会向所有道路添加绿色标签。它还演示了如何在DATA定义中使用SQL联接。</p> 
<h3>7.2 Java Clients (JDBC)</h3> 
<h3>译：7.2 Java客户端(JDBC)</h3> 
<p>        Java clients can access PostGIS "geometry" objects in the PostgreSQL database either directly as text representations or using the JDBC extension objects bundled with PostGIS. In order to use the extension objects, the "postgis.jar" file must be in your CLASSPATH along with the "postgresql.jar" JDBC driver package.</p> 
<p>        译：Java客户端可以访问PostgreSQL数据库中的PostGIS“geometry”对象，既可以直接作为文本表示，也可以使用与PostGIS捆绑的JDBC扩展对象。为了使用扩展对象，“postgis.jar”文件必须与“postgresql.jar”JDBC驱动程序包一起位于CLASSPATH中。</p> 
<pre><code class="language-java">import java.sql.*;
import java.util.*;
import java.lang.*;
import org.postgis.*;
public class JavaGIS {
    public static void main(String[] args) {
        java.sql.Connection conn;
        try {
            /*
             * Load the JDBC driver and establish a connection.
             */
            Class.forName("org.postgresql.Driver");
            String url = "jdbc:postgresql://localhost:5432/database";
            conn = DriverManager.getConnection(url, "postgres", "");
            /*
             * Add the geometry types to the connection. Note that you
             * must cast the connection to the pgsql-specific connection
             * implementation before calling the addDataType() method.
             */
            ((org.postgresql.PGConnection)conn).addDataType("geometry",Class.forName("org.postgis.PGgeometry"));
            ((org.postgresql.PGConnection)conn).addDataType("box3d",Class.forName("org.postgis.PGbox3d"));
            /*
             * Create a statement and execute a select query.
             */
            Statement s = conn.createStatement();
            ResultSet r = s.executeQuery("select geom,id from geomtable");
            while( r.next() ) {
                /*
                 * Retrieve the geometry as an object then cast it to the geometry type.
                 * Print things out.
                 */
                PGgeometry geom = (PGgeometry)r.getObject(1);
                int id = r.getInt(2);
                System.out.println("Row " + id + ":");
                System.out.println(geom.toString());
            }
            s.close();
            conn.close();
        } catch( Exception e ) {
            e.printStackTrace();
        }
    }
}</code></pre> 
<p>        The "PGgeometry" object is a wrapper object which contains a specific topological geometry object (subclasses of the abstract class "Geometry") depending on the type: Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon.</p> 
<p>        译：“PGgeometry”对象是一个包装器对象，它包含特定的拓扑几何对象（抽象类“geometry”的子类），具体取决于类型：Point、LineString、Polygon、MultiPoint、MultiLineString、MultiPolygon。</p> 
<pre><code class="language-java">PGgeometry geom = (PGgeometry)r.getObject(1);
if( geom.getType() == Geometry.POLYGON ) {
    Polygon pl = (Polygon)geom.getGeometry();
    for( int r = 0; r &lt; pl.numRings(); r++) {
        LinearRing rng = pl.getRing(r);
        System.out.println("Ring: " + r);
        for( int p = 0; p &lt; rng.numPoints(); p++ ) {
            Point pt = rng.getPoint(p);
            System.out.println("Point: " + p);
            System.out.println(pt.toString());
        }
    }
}</code></pre> 
<p>        The JavaDoc for the extension objects provides a reference for the various data accessor functions in the geometric objects.</p> 
<p>        译：扩展对象的JavaDoc为几何对象中的各种数据访问器函数提供了参考。</p> 
<h3>7.3 C Clients (libpq)</h3> 
<h3>译：7.3 C客户端(libpq)</h3> 
<p>...</p> 
<h4>7.3.1 Text Cursors</h4> 
<h4>译：7.3.1 文本游标</h4> 
<p>...</p> 
<h4>7.3.2 Binary Cursors</h4> 
<h4>译：7.3.1 二进制游标</h4> 
<p>...</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a031ae1b309de0691c0476b358089de4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据可视化——用python绘制简单的折线图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72ac05a98ce6d696505ed92d8a866821/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【计算机视觉 | 目标检测 | 图像分割】arxiv 计算机视觉关于目标检测和图像分割的学术速递（7 月 17 日论文合集）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>