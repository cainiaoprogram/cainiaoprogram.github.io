<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】——队列 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】——队列" />
<meta property="og:description" content="队列的代码实现方式有两种：一种实现方式是连续内存的数组，一种实现方式是离散内存的链表。
而循环队列一般采用连续内存的数组来实现。
1.数组实现方式 / 循环队列 /************************************************************************* &gt; File Name: queue.c &gt; Author: &gt; Mail: &gt; Created Time: Sat 15 Jul 2023 07:59:42 PM CST ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; // 定义一个队列的数据结构 typedef struct Queue { int *data; int size; int head, tail; } Queue; int expand(Queue *q); // 初始化一个长度为n的队列 Queue *initQueue(int n) { Queue * q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;size = n; q-&gt;head = q-&gt;tail = 0; return q; } // 释放空间，养成习惯，一开始就写好 void freeQueue(Queue *q) { if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/41bbfc4c2d227420e3718c63e9687aeb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-16T10:00:17+08:00" />
<meta property="article:modified_time" content="2023-07-16T10:00:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】——队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>队列的代码实现方式有两种：一种实现方式是连续内存的数组，一种实现方式是离散内存的链表。</p> 
<p>而循环队列一般采用连续内存的数组来实现。</p> 
<h3>1.数组实现方式 / 循环队列</h3> 
<pre><code class="language-cpp">/*************************************************************************
        &gt; File Name: queue.c
        &gt; Author: 
        &gt; Mail: 
        &gt; Created Time: Sat 15 Jul 2023 07:59:42 PM CST
 ************************************************************************/

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;

// 定义一个队列的数据结构
typedef struct Queue {
    int *data;
    int size;
    int head, tail;
} Queue;

int expand(Queue *q);
// 初始化一个长度为n的队列
Queue *initQueue(int n) {
    Queue * q = (Queue *)malloc(sizeof(Queue));
    q-&gt;data = (int *)malloc(sizeof(int) * n);
    q-&gt;size = n;
    q-&gt;head = q-&gt;tail = 0;
    return q;
}

// 释放空间，养成习惯，一开始就写好
void freeQueue(Queue *q) {
    if (!q) {
        return ;
    }
    free(q-&gt;data); // 先释放里面开辟的空间
    free(q); // 后释放整个队列
    return ;
}

// 队列的元素压入
int push(Queue *q, int val) {
    if (!q) {
        return 0;
    }
    // 满队
    if ((q-&gt;tail + 1) % q-&gt;size == q-&gt;head) {
        if (!expand(q)) {
            return 0;
        }
    }
    q-&gt;data[q-&gt;tail] = val; 
    q-&gt;tail = (q-&gt;tail + 1) % q-&gt;size;
    return 1;
}

// 判断队列是否为空
int isEmpty(Queue *q) {
    // return !q || q-&gt;head == q-&gt;tail; 
    return !(q &amp;&amp; q-&gt;head != q-&gt;tail); // 对偶逻辑
}

// 队列的元素弹出
int pop(Queue *q) {
    int ret = q-&gt;data[q-&gt;head];
    q-&gt;head = (q-&gt;head + 1) % q-&gt;size; 
    return ret;
}

// 打印队列元素
void showQueue(Queue *q) {
    if (isEmpty(q)) {
        return ;
    }
    printf("Queue:[");
    for (int i = q-&gt;head; i != q-&gt;tail; i = (i + 1) % q-&gt;size) {
        i != q-&gt;head &amp;&amp; printf(", ");
        printf("%d", q-&gt;data[i]);
    }
    printf("]\n");
    return ;
}

// 队列的扩容
int expand(Queue *q) {
    if (!q) {
        return 0;
    }
    int expsize = q-&gt;size; // 额外扩容的大小
    int *tmp;
    while (expsize) {
        tmp = (int *)malloc(sizeof(int) * (q-&gt;size + expsize));
        // realloc 能够在保持旧的内容不变的基础上扩容,但地址离散不适合循环队列
        // 这里用malloc实现扩容后仍然是一片连续的地址，方便循环队列的扩容
        if (tmp) {
            break;
        }
        expsize &gt;&gt;= 1; // 剩余空间不足，则容量再缩小两倍
    }
    if (!tmp) { // 如果始终扩容不成功：没有多余的空间，返回0
        return 0;
    }
    // 把队列中的数据搬运到新地址
    int i, j;
    for (i = q-&gt;head, j = 0; i != q-&gt;tail; i = (i + 1) % q-&gt;size, j++) {
        tmp[j] = q-&gt;data[i];
    }
    free(q-&gt;data); // 把原来废弃的内存释放掉
    q-&gt;data = tmp;
    q-&gt;size += expsize;
    q-&gt;head = 0;
    q-&gt;tail = j;
    printf("expand successfully~, new size is %d\n", q-&gt;size);
    return 1;
}

int main () {
    srand(time(0));
    Queue *q = initQueue(7);

    int cnt = 20;
    while (cnt--) {
        int val = rand() % 100;
        int opt = rand() % 4;
        switch(opt) {
            case 0:
            case 1:
            case 2:
            printf("push %d, res = %s\n", val, push(q, val) ? "SUC" : "ERR");
                break;
            case 3:
                isEmpty(q) ? printf("pop nothing~~\n") : printf("pop %d\n", pop(q));
                break;
        }

        showQueue(q);
    }
    return 0;
}</code></pre> 
<h3>2. 链表实现方式</h3> 
<pre><code class="language-cpp">/*************************************************************************
        &gt; File Name: listQueue.c
        &gt; Author: jby
        &gt; Mail: 
        &gt; Created Time: Sat 15 Jul 2023 09:20:12 PM CST
 ************************************************************************/

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;

// 结点的数据结构
typedef struct Node {
    int val;
    struct Node *next;
} Node;

// 队列的数据结构
typedef struct Queue {
    Node *head, *tail;
} Queue;

// 节点的初始化
Node *initNode(int val) {
    Node *n = (Node *)malloc(sizeof(Node));
    n-&gt;val = val;
    n-&gt;next = NULL;
    return n;
}

// 释放结点
void freeNode (Node *p) {
    if (!p) {
        free(p);
    }
    return ;
}

// 队列初始化
Queue *initQueue() {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q-&gt;head = q-&gt;tail = NULL;
    return q;
}

// 释放队列
void freeQueue(Queue *q) {
    if (!q) {
        return ;
    }
    Node *p = q-&gt;head, *k;
    while (p) {
        k = p;
        p = p-&gt;next;
        freeNode(k);
    }
    free(q);
    return ;
}

// 队列压入元素
int push(Queue *q, int val) {
    if (!q) {
        return 0;
    }
    Node *n = initNode(val);
    if (!n) {
        return 0;
    }
    if (q-&gt;tail) {
        q-&gt;tail-&gt;next = n;
        q-&gt;tail = n;
    } else {
        q-&gt;head = q-&gt;tail = n;
    }
    return 1;
}

// 队列判空
int isEmpty(Queue *q) {
    return !(q &amp;&amp; q-&gt;head);
}

// 队列弹出元素
int pop(Queue *q) {
    Node *k = q-&gt;head;
    int tmp = k-&gt;val;
    q-&gt;head = k-&gt;next;
    freeNode(k);
    if (!q-&gt;head) {
        q-&gt;tail = NULL;
    }
    return tmp;
}

// 打印队列
void showQueue(Queue *q) {
    if (!q) {
        return ;
    }
    printf("Queue:[");
    Node *p = q-&gt;head;
    while (p) {
        printf("%d-&gt;", p-&gt;val);
        p = p-&gt;next;
    }
    printf("NULL]\n");
    return ;
}

int main () {
    srand(time(0));
    Queue *q = initQueue();
    
    int cnt = 20;
    while (cnt--) {
        int val = rand() % 20;
        int opt = rand() % 4;
        switch(opt) {
            case 0: 
            case 1:
            case 2:
                printf("push %d, res = %s\n", val, push(q, val) ? "SUC":"ERR");
                break;
            case 3:
                isEmpty(q) ? printf("pop nothing~\n") : printf("pop %d\n", pop(q));
                break; 
        }
        showQueue(q);
    }
    freeQueue(q);
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41a70b64a8ca1460838e8f0af57af5aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">互联网行业真的不行了吗？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d1cb5dce82336c5922cc363d6115cf3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【面试笔试算法】——拓扑排序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>