<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>各向异性扩散滤波_原理与算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="各向异性扩散滤波_原理与算法" />
<meta property="og:description" content=" 1.原理简述 各向异性扩散滤波主要是用来平滑图像的，克服了高斯模糊的缺陷，各向异性扩散在平滑图像时是保留图像边缘的，和双边滤波很像。 通常我们有将图像看作矩阵的，看作图的，看作随机过程的，记得过去还有看作力场的。这次新鲜，将图像看作热量场了。每个像素看作热流，根据当前像素和周围像素的关系，来确定是否要向周围扩散。比如某个邻域像素和当前像素差别较大，则代表这个邻域像素很可能是个边界，那么当前像素就不向这个方向扩散了，这个边界也就得到保留了。 具体的推导公式都是热学上的，自己也不太熟悉，感兴趣的可以去看原论文，引用量超7000吶。我这里只介绍一下最终结论用到的公式。
主要迭代方程如下：
I就是图像了，因为是个迭代公式，所以有迭代次数t。
四个散度公式是在四个方向上对当前像素求偏导，news就是东南西北嘛，公式如下：
而cN/cS/cE/cW则代表四个方向上的导热系数，边界的导热系数都是小的。公式如下：
最后整个公式需要先前设置的参数主要有三个，迭代次数t，根据情况设置；导热系数相关的k，取值越大越平滑，越不易保留边缘；lambda同样也是取值越大越平滑。
2.MATLAB仿真代码 clear all; close all; clc; k=15; %导热系数,控制平滑 lambda=0.15; %控制平滑 N=20; %迭代次数 img=double(imread(&#39;lena.jpg&#39;)); imshow(img,[]); [m n]=size(img); imgn=zeros(m,n); for i=1:N for p=2:m-1 for q=2:n-1 %当前像素的散度，对四个方向分别求偏导，局部不同方向上的变化量， %如果变化较多，就证明是边界，想方法保留边界 NI=img(p-1,q)-img(p,q); SI=img(p&#43;1,q)-img(p,q); EI=img(p,q-1)-img(p,q); WI=img(p,q&#43;1)-img(p,q); %四个方向上的导热系数，该方向变化越大，求得的值越小，从而达到保留边界的目的 cN=exp(-NI^2/(k*k)); cS=exp(-SI^2/(k*k)); cE=exp(-EI^2/(k*k)); cW=exp(-WI^2/(k*k)); imgn(p,q)=img(p,q)&#43;lambda*(cN*NI&#43;cS*SI&#43;cE*EI&#43;cW*WI); %扩散后的新值 end end img=imgn; %整个图像扩散完毕，用已扩散图像的重新扩散。 end figure; imshow(imgn,[]); 3.运行结果及分析 (处理图像) (原图)
各向异性滤波方法确实在保持边缘和图像平滑方面进行了很好的尝试，其结果和双边滤波有很大的相似性。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e28826509e534b8e45801a620a4f42b1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-10-23T00:00:54+08:00" />
<meta property="article:modified_time" content="2016-10-23T00:00:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">各向异性扩散滤波_原理与算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.原理简述</h2> 
<blockquote style="margin:0 0 0 40px; border:none; padding:0px"> 
 <div> 
  <span style="font-size:18px">各向异性扩散滤波主要是用来平滑图像的，克服了高斯模糊的缺陷，各向异性扩散在平滑图像时是保留图像边缘的，和双边滤波很像。</span> 
 </div> 
 <div> 
  <span style="font-size:18px">通常我们有将图像看作矩阵的，看作图的，看作随机过程的，记得过去还有看作力场的。这次新鲜，将图像看作热量场了。每个像素看作热流，根据当前像素和周围像素的关系，来确定是否要向周围扩散。比如某个邻域像素和当前像素差别较大，则代表这个邻域像素很可能是个边界，那么当前像素就不向这个方向扩散了，这个边界也就得到保留了。</span> 
 </div> 
 <div> 
  <span style="font-size:18px">具体的推导公式都是热学上的，自己也不太熟悉，感兴趣的可以去看原论文，引用量超7000吶。我这里只介绍一下最终结论用到的公式。<br> 主要迭代方程如下：<br> </span> 
 </div> 
 <div style="text-align:center"> 
  <span style="font-size:18px"><img src="https://images2.imgbox.com/7b/4b/lpHXToPb_o.png" width="600" alt=""><br> </span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:18px">I就是图像了，因为是个迭代公式，所以有迭代次数t。<br> 四个散度公式是在四个方向上对当前像素求偏导，news就是东南西北嘛，公式如下：<br> </span> 
 </div> 
 <div style="text-align:center"> 
  <span style="font-size:18px"><img src="https://images2.imgbox.com/b8/df/uMZtr6B5_o.png" width="200" alt=""><br> </span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:18px">而cN/cS/cE/cW则代表四个方向上的导热系数，边界的导热系数都是小的。公式如下：<br> </span> 
 </div> 
 <div style="text-align:center"> 
  <span style="font-size:18px"><img src="https://images2.imgbox.com/59/a0/bkm8dJcF_o.png" width="200" alt=""><br> </span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:18px">最后整个公式需要先前设置的参数主要有三个，迭代次数t，根据情况设置；导热系数相关的k，取值越大越平滑，越不易保留边缘；lambda同样也是取值越大越平滑。<br> </span> 
 </div> 
</blockquote> 
<h2><span style="font-size:24px">2.MATLAB仿真代码</span></h2> 
<span style="font-size:18px"><br> </span> 
<blockquote style="margin:0 0 0 40px; border:none; padding:0px"> 
 <div style="text-align:left"> 
  <pre><code class="language-cpp"><span style="font-size:18px;">clear all;
close all;
clc;

k=15;           %导热系数,控制平滑
lambda=0.15;    %控制平滑
N=20;           %迭代次数
img=double(imread('lena.jpg'));
imshow(img,[]);
[m n]=size(img);

imgn=zeros(m,n);
for i=1:N

    for p=2:m-1
        for q=2:n-1
            %当前像素的散度，对四个方向分别求偏导，局部不同方向上的变化量，
            %如果变化较多，就证明是边界，想方法保留边界
            NI=img(p-1,q)-img(p,q);
            SI=img(p+1,q)-img(p,q);
            EI=img(p,q-1)-img(p,q);
            WI=img(p,q+1)-img(p,q);
            
            %四个方向上的导热系数，该方向变化越大，求得的值越小，从而达到保留边界的目的
            cN=exp(-NI^2/(k*k));
            cS=exp(-SI^2/(k*k));
            cE=exp(-EI^2/(k*k));
            cW=exp(-WI^2/(k*k));
            
            imgn(p,q)=img(p,q)+lambda*(cN*NI+cS*SI+cE*EI+cW*WI);  %扩散后的新值      
        end
    end
    
    img=imgn;       %整个图像扩散完毕，用已扩散图像的重新扩散。
end

figure;
imshow(imgn,[]);</span></code></pre> 
 </div> 
</blockquote> 
<h2><span style="font-size:24px">3.运行结果及分析</span></h2> 
<blockquote style="margin:0 0 0 40px; border:none; padding:0px"> 
 <div style="text-align:center"> 
  <img src="https://images2.imgbox.com/c4/7d/eSZvnw6j_o.jpg" alt="">                                              
  <span style="font-size:18px"><img src="https://images2.imgbox.com/ac/36/3nqoEgI9_o.jpg" alt=""></span> 
 </div> 
 <div style="text-align:center"> 
  <span style="font-size:18px"> (<span style="font-size:18px; text-align:center">处理图像</span>)                                                                        (<span style="font-size:18px; text-align:center">原图</span>)<br> </span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:18px">各向异性滤波方法确实在保持边缘和图像平滑方面进行了很好的尝试，其结果和双边滤波有很大的相似性。</span> 
 </div> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cfd4edf8edde1b8ddea07b2837afc976/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java三大器之监听器（Listener）的工作原理和代码演示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e0a9bc4fb43b1b6f5ca21798200e768/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QT 5.7 QWebEngineView加载网页卡的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>