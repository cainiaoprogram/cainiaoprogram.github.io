<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构笔记（考研） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构笔记（考研）" />
<meta property="og:description" content="目录 一、算法概述算法的定义：基本特性：算法的基本要求存储结构与逻辑结构 二、数据的逻辑结构集合结构线性结构线性表广义表顺序表数组：查找算法 栈队列单链表循环链表双链表递归斐波那契数列汉诺塔问题 串 排序算法计算交换排序冒泡排序快速排序 插入排序直接插入排序希尔排序 选择排序简单选择排序堆排序 归并排序基数排序 树形结构链式存储的二叉树创建二叉树：前序、中序、后序遍历查找节点删除节点 顺序存储的二叉树线索二叉树赫夫曼树赫夫曼编码二叉排序树（二叉搜索树、BST）平衡二叉树（AVL树）多路查找树 哈希表（散列表）图形结构 一、算法概述 抽象数据类型（ADT）描述了数据的逻辑结构和抽象运算，通常用数据对象、数据关系、基本操作集这样的三元组来表示，从而构成一个完整的数据结构定义
算法的定义： 算法是解决特定问题求解决步骤的描述，再计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
基本特性： 输入、输出、又穷性、确定性、可行性
输入：算法具有零个或多个输入
输出：算法至少有一个或多个输出
有穷性：指算法再执行有限的步骤之后，自动结束而不会出现无心循环，并且每一个步骤再可接受的时间内完成
确定性：算法的每一个步骤都具有确定的意义，不会出现二义性
可行性：算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成
好的算法应考虑：正确性、可读性、健壮性、效率与低存储量需求
算法的基本要求 正确性、可读性、健壮性、时间复杂度、空间复杂度
存储结构与逻辑结构 存储结构有顺序存储、链式存储、索引存储和散列存储
有序表既可以链式存储又可顺序存储，属于逻辑结构
二、数据的逻辑结构 集合结构 线性结构 线性表 表中元素具有抽象性，仅讨论元素间的逻辑关系，不考虑元素究竟表示什么内容
广义表 表头可能是原子、列表，表尾必为列表
取表头：列表第一个原子
取表尾：列表删去第一个元素后的剩余列表
顺序表 顺序存储的存储结构是随机存储的存储结构
优点：
随机访问，可通过首地址和元素序号在时间O（1）内找到指定的元素
存储密度高，每个结点只存储数据元素
缺点：
相邻的元素物理上也相邻，插入和删除操作需要移动大量元素，时间复杂度为O（n）
数组： 中间元素删除：创建长度-1的新数组，将原数组头尾复制到新数组中（for循环分为删除之前之后的元素），新数组替换原数组
public class TestArray2 { public static void main(String[] args) { //目标数组 int[] arr = new int[] {9,8,7,6,5,4}; //要删除的元素下标 int dst = 3; //创建新数组，长度是原数组-1 int[] newArr = new int[arr." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/54b0966bf1cf803f57ac5e4f66a779f3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-19T02:26:50+08:00" />
<meta property="article:modified_time" content="2022-09-19T02:26:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构笔记（考研）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">一、算法概述</a></li><li><ul><li><a href="#_4" rel="nofollow">算法的定义：</a></li><li><a href="#_8" rel="nofollow">基本特性：</a></li><li><a href="#_16" rel="nofollow">算法的基本要求</a></li><li><a href="#_19" rel="nofollow">存储结构与逻辑结构</a></li></ul> 
  </li><li><a href="#_22" rel="nofollow">二、数据的逻辑结构</a></li><li><a href="#_23" rel="nofollow">集合结构</a></li><li><a href="#_24" rel="nofollow">线性结构</a></li><li><ul><li><a href="#_25" rel="nofollow">线性表</a></li><li><a href="#_27" rel="nofollow">广义表</a></li><li><a href="#_31" rel="nofollow">顺序表</a></li><li><a href="#_38" rel="nofollow">数组：</a></li><li><ul><li><a href="#_67" rel="nofollow">查找算法</a></li></ul> 
   </li><li><a href="#_121" rel="nofollow">栈</a></li><li><a href="#_205" rel="nofollow">队列</a></li><li><a href="#_314" rel="nofollow">单链表</a></li><li><a href="#_470" rel="nofollow">循环链表</a></li><li><a href="#_544" rel="nofollow">双链表</a></li><li><a href="#_617" rel="nofollow">递归</a></li><li><ul><li><a href="#_635" rel="nofollow">斐波那契数列</a></li><li><a href="#_656" rel="nofollow">汉诺塔问题</a></li></ul> 
   </li><li><a href="#_689" rel="nofollow">串</a></li></ul> 
  </li><li><a href="#_699" rel="nofollow">排序算法</a></li><li><ul><li><a href="#_702" rel="nofollow">计算</a></li><li><a href="#_728" rel="nofollow">交换排序</a></li><li><ul><li><a href="#_729" rel="nofollow">冒泡排序</a></li><li><a href="#_768" rel="nofollow">快速排序</a></li></ul> 
   </li><li><a href="#_812" rel="nofollow">插入排序</a></li><li><ul><li><a href="#_814" rel="nofollow">直接插入排序</a></li><li><a href="#_845" rel="nofollow">希尔排序</a></li></ul> 
   </li><li><a href="#_883" rel="nofollow">选择排序</a></li><li><ul><li><a href="#_884" rel="nofollow">简单选择排序</a></li><li><a href="#_918" rel="nofollow">堆排序</a></li></ul> 
   </li><li><a href="#_983" rel="nofollow">归并排序</a></li><li><a href="#_1049" rel="nofollow">基数排序</a></li></ul> 
  </li><li><a href="#_1175" rel="nofollow">树形结构</a></li><li><ul><li><a href="#_1207" rel="nofollow">链式存储的二叉树</a></li><li><ul><li><a href="#_1209" rel="nofollow">创建二叉树：</a></li><li><a href="#_1270" rel="nofollow">前序、中序、后序遍历</a></li><li><a href="#_1416" rel="nofollow">查找节点</a></li><li><a href="#_1663" rel="nofollow">删除节点</a></li></ul> 
   </li><li><a href="#_1954" rel="nofollow">顺序存储的二叉树</a></li><li><a href="#_2005" rel="nofollow">线索二叉树</a></li><li><a href="#_2167" rel="nofollow">赫夫曼树</a></li><li><a href="#_2257" rel="nofollow">赫夫曼编码</a></li><li><a href="#BST_2794" rel="nofollow">二叉排序树（二叉搜索树、BST）</a></li><li><a href="#AVL_3043" rel="nofollow">平衡二叉树（AVL树）</a></li><li><a href="#_3373" rel="nofollow">多路查找树</a></li></ul> 
  </li><li><a href="#_3404" rel="nofollow">哈希表（散列表）</a></li><li><a href="#_3502" rel="nofollow">图形结构</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>一、算法概述</h2> 
<p>抽象数据类型（ADT）描述了数据的逻辑结构和抽象运算，通常用数据对象、数据关系、基本操作集这样的三元组来表示，从而构成一个完整的数据结构定义</p> 
<h3><a id="_4"></a>算法的定义：</h3> 
<p>算法是解决特定问题求解决步骤的描述，再计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p> 
<h3><a id="_8"></a>基本特性：</h3> 
<p>输入、输出、又穷性、确定性、可行性<br> 输入：算法具有零个或多个输入<br> 输出：算法至少有一个或多个输出<br> 有穷性：指算法再执行有限的步骤之后，自动结束而不会出现无心循环，并且每一个步骤再可接受的时间内完成<br> 确定性：算法的每一个步骤都具有确定的意义，不会出现二义性<br> 可行性：算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成<br> 好的算法应考虑：正确性、可读性、健壮性、效率与低存储量需求</p> 
<h3><a id="_16"></a>算法的基本要求</h3> 
<p>正确性、可读性、健壮性、时间复杂度、空间复杂度</p> 
<h3><a id="_19"></a>存储结构与逻辑结构</h3> 
<p>存储结构有顺序存储、链式存储、索引存储和散列存储<br> 有序表既可以链式存储又可顺序存储，属于逻辑结构</p> 
<h2><a id="_22"></a>二、数据的逻辑结构</h2> 
<h2><a id="_23"></a>集合结构</h2> 
<h2><a id="_24"></a>线性结构</h2> 
<h3><a id="_25"></a>线性表</h3> 
<p>表中元素具有抽象性，仅讨论元素间的逻辑关系，不考虑元素究竟表示什么内容</p> 
<h3><a id="_27"></a>广义表</h3> 
<p>表头可能是原子、列表，表尾必为列表<br> 取表头：列表第一个原子<br> 取表尾：列表删去第一个元素后的剩余列表</p> 
<h3><a id="_31"></a>顺序表</h3> 
<p>顺序存储的存储结构是随机存储的存储结构<br> 优点：<br> 随机访问，可通过首地址和元素序号在时间O（1）内找到指定的元素<br> 存储密度高，每个结点只存储数据元素<br> 缺点：<br> 相邻的元素物理上也相邻，插入和删除操作需要移动大量元素，时间复杂度为O（n）</p> 
<h3><a id="_38"></a>数组：</h3> 
<p>中间元素删除：创建长度-1的新数组，将原数组头尾复制到新数组中（for循环分为删除之前之后的元素），新数组替换原数组</p> 
<pre><code class="prism language-css"><span class="token selector">public class TestArray2</span> <span class="token punctuation">{<!-- --></span>
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">//目标数组
		int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span>9<span class="token punctuation">,</span>8<span class="token punctuation">,</span>7<span class="token punctuation">,</span>6<span class="token punctuation">,</span>5<span class="token punctuation">,</span>4<span class="token punctuation">}</span><span class="token punctuation">;</span>
		//要删除的元素下标
		int dst = 3<span class="token punctuation">;</span>
		//创建新数组，长度是原数组-1
		int[] newArr = new int[arr.length-1]<span class="token punctuation">;</span>
		//复制原数组中除了要删除元素的其他元素
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i&lt;newArr.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token selector">//要删除元素之前的元素
			if(i&lt;dst)</span> <span class="token punctuation">{<!-- --></span>
				newArr[i] = arr[i]<span class="token punctuation">;</span>
			//要删除元素之后的元素
			<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				newArr[i] = arr[i+1]<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
			arr = newArr<span class="token punctuation">;</span>
			System.out.<span class="token function">print</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>中间元素插入：创建长度+1的新数组，原数组插入位置前后元素复制到新数组，插入元素放入新数组对应坐标处，新数组替换原数组</p> 
<h4><a id="_67"></a>查找算法</h4> 
<p>静态查找表：操作只涉及查询特定数据元素是否在查找表中、检索满足条件的某个特定的数据元素的各种属性，适合顺序、折半和散列查找<br> 动态查找表：二叉排序树的查找、散列查找<br> 对线性的链表只能进行顺序查找，ASL=（n+1）/2<br> 折半查找：ASL=log以二为底（n+1）-1<br> 线性查找： for循环一个一个找<br> 分块查找（引索顺序查找）：ASL=（s^2+2s+n）/2s<br> 二分查找：</p> 
<pre><code class="prism language-css"><span class="token selector">public class TestBinarySearch</span> <span class="token punctuation">{<!-- --></span>
	
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token selector">//目标数组
	int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span>1<span class="token punctuation">,</span>2<span class="token punctuation">,</span>3<span class="token punctuation">,</span>4<span class="token punctuation">,</span>5<span class="token punctuation">,</span>6<span class="token punctuation">,</span>7<span class="token punctuation">,</span>8<span class="token punctuation">,</span>9<span class="token punctuation">}</span><span class="token punctuation">;</span>
	//目标元素
	int target = 2<span class="token punctuation">;</span>
	//记录开始位置
	int begin = 0<span class="token punctuation">;</span>
	//记录结束的位置
	int end = arr.length-1<span class="token punctuation">;</span>
	//记录中间的位置
	int mid = <span class="token punctuation">(</span>begin+end<span class="token punctuation">)</span>/2<span class="token punctuation">;</span>
	//记录目标位置
	int index = -1<span class="token punctuation">;</span>
	<span class="token selector">//循环查找
	while(true)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token selector">//不存在元素时
		if(begin &gt; end)</span> <span class="token punctuation">{<!-- --></span>
			return<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">//判断中间元素是不是要查找的元素
		if(arr[mid] == target)</span> <span class="token punctuation">{<!-- --></span>
			index = mid<span class="token punctuation">;</span>
			break<span class="token punctuation">;</span>
		//中间元素不是要查的元素
		<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">//判断中间这个元素是不是比目标元素大
			if(arr[mid]&gt;target)</span> <span class="token punctuation">{<!-- --></span>
				//把结束位置调整到中间位置前一个位置
				end = mid - 1<span class="token punctuation">;</span>
			//判断中间这个元素是不是比目标元素小
			<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				//把开始位置调整到中间位置后一个位置
				begin = mid + 1<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			mid = <span class="token punctuation">(</span>begin+end<span class="token punctuation">)</span>/2<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	System.out.<span class="token function">print</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_121"></a>栈</h3> 
<p>栈是限制存储点的线性结构，n个不同元素进栈，出栈元素不同排列个数为1/（n+1）C（上n下2n）=1/(n+1) 2n!/n!n!<br> 采用链式存储的栈叫做链栈，链栈的优点是便于多个栈共享存储空间和提高效率，且不存在栈满上溢。所有操作都在单链表表头进行，链栈没有头结点，Lhead指向栈顶元素。</p> 
<pre><code class="prism language-css">package demo1<span class="token punctuation">;</span>

<span class="token selector">public class MyStack</span> <span class="token punctuation">{<!-- --></span>
	
	//栈的底层使用数组存储数据
	int[] elements<span class="token punctuation">;</span>
	<span class="token selector">public MyStack()</span> <span class="token punctuation">{<!-- --></span>
		elements = new int[0]<span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
	
	<span class="token selector">//压入元素
	public void push(int element)</span><span class="token punctuation">{<!-- --></span>
		int[] newArr = new int[elements.length + 1]<span class="token punctuation">;</span>
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i &lt; elements.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			newArr[i] = elements[i]<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//把添加的元素放入新数组中
		newArr[elements.length] = element<span class="token punctuation">;</span>
		elements = newArr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//取出栈顶元素
	public int pop()</span><span class="token punctuation">{<!-- --></span>
		<span class="token selector">//栈中无元素
		if(elements.length == 0)</span> <span class="token punctuation">{<!-- --></span>
			throw new <span class="token function">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"stack is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			
		<span class="token punctuation">}</span>
		//取出数组里最后一个元素
		int element = elements[elements.length - 1]<span class="token punctuation">;</span>
		//创建一个新的数组
		int newArr[] = new int[elements.length - 1]<span class="token punctuation">;</span>
		//原数组中除了最后一个元素的数组都放入新的数组中
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i &lt; elements.length-1<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			newArr[i] = elements[i]<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//替换数组
		elements = newArr<span class="token punctuation">;</span>
		//返回栈顶元素
		return element<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token selector">//查看栈顶元素
	public int peek()</span><span class="token punctuation">{<!-- --></span>
		<span class="token selector">//栈中无元素
		if(elements.length == 0)</span> <span class="token punctuation">{<!-- --></span>
			throw new <span class="token function">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"stack is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return elements[elements.length-1]<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token selector">//判断栈是否为空
	public boolean isEmpty()</span> <span class="token punctuation">{<!-- --></span>
		return elements.length == 0<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		//先创建一个栈
		MyStack ms = new <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//压入数据
		ms.<span class="token function">push</span><span class="token punctuation">(</span>9<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ms.<span class="token function">push</span><span class="token punctuation">(</span>8<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ms.<span class="token function">push</span><span class="token punctuation">(</span>7<span class="token punctuation">)</span><span class="token punctuation">;</span>
//		//取出栈顶元素
//		System.out.<span class="token function">print</span><span class="token punctuation">(</span>ms.<span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">print</span><span class="token punctuation">(</span>ms.<span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">print</span><span class="token punctuation">(</span>ms.<span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//查看栈顶元素
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>ms.<span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ms.<span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>ms.<span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>ms.<span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//空栈
//		int pop = ms.<span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//		System.out.<span class="token function">print</span><span class="token punctuation">(</span>pop<span class="token punctuation">)</span><span class="token punctuation">;</span>
//		
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_205"></a>队列</h3> 
<p>栈和队列的主要区别是插入、删除操作的限定不一样<br> 最不适合作链式队列的链表是只带队首指针的非循环双链表<br> 执行广度优先搜索图时，需要使用队列作为辅助空间<br> 顺序队列：<br> 队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置<br> 初始状态：Q.front= =Q.rear= =0<br> 进队操作：队不满时，先送值到队尾元素加一<br> 出队操作：队不空时，先取队头元素值，再讲队头指针加一<br> 循环 队列：<br> 初始时：Q.front= =Q.rear=0<br> 队首指针进一：Q.front = （Q.front+1）%MaxSize<br> 队尾指针进一：Q.rear = （Q.rear+1）%MaxSize<br> 队列长度：（Q.rear+MaxSize -Q.front）%MaxSize<br> 队空：Q.front= =Q.rear<br> 牺牲一个单元 队满（Q.rear+1）%MaxSize= =Q.front</p> 
<p>单链表表示的链式队列特别适合于数据元素变化比较大的情形，不存在队列满、产生溢出的问题<br> 双端队列：一端进行插入删除，另一端进行插入/删除</p> 
<p>中缀表达式变为后缀表达式：<br> isp(前)&lt;icp(后),后进栈<br> isp(前)&gt;icp(后),前出栈，后出栈<br> 操作符 isp icp<br> 井 0 0<br> ( 1 6<br> */ 5 4<br> ± 3 2<br> ） 6 1</p> 
<p>矩阵的压缩处理：</p> 
<p>对称矩阵：若对于一个n阶方阵A【1…n】【1…n】中任意一个元素aij都有aij=aji。将对称矩阵存放在一维数组B【n(n+1)/2】,只存放下三角部分（含主对角）的元素<br> <img src="https://images2.imgbox.com/7f/a6/9DxUR61b_o.jpg" alt="请添加图片描述"><br> 三角矩阵：<br> 上三角矩阵：下三角所有元素均为常数，存储完下三角区和主对角线所有元素后，存储对角线上方的常量<br> <img src="https://images2.imgbox.com/39/3b/jAWuBbvY_o.png" alt="在这里插入图片描述"></p> 
<p>下三角矩阵：上三角所有元素均为常数<br> <img src="https://images2.imgbox.com/ba/68/oN8KtwUI_o.png" alt="在这里插入图片描述"><br> 稀疏矩阵：<br> 适用于压缩存储稀疏矩阵的俩种存储结构是三元组表和十字链表<br> 将非零元素及其相应的行列构成一个三元组（行标，坐标，值）<br> M=【40001】<br> 对应三元组：<br> i j v<br> 0 0 4<br> 0 4 1</p> 
<pre><code class="prism language-css">package demo1<span class="token punctuation">;</span>

<span class="token selector">public class MyQueue</span> <span class="token punctuation">{<!-- --></span>
	int[] elements<span class="token punctuation">;</span>

	<span class="token selector">public MyQueue()</span> <span class="token punctuation">{<!-- --></span>
		elements = new int[0]<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token selector">//入队
	public void add(int element)</span> <span class="token punctuation">{<!-- --></span>
		int[] newArr = new int[elements.length + 1]<span class="token punctuation">;</span>
		for <span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span> i &lt; elements.length<span class="token punctuation">;</span> <span class="token selector">i++)</span> <span class="token punctuation">{<!-- --></span>
			newArr[i] = elements[i]<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 把添加的元素放入新数组中
		newArr[elements.length] = element<span class="token punctuation">;</span>
		elements = newArr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//出队
	public int poll()</span> <span class="token punctuation">{<!-- --></span>
		//把数组中第0个元素取出来
		int element = elements[0]<span class="token punctuation">;</span>
		//创建一个新数组
		int newArr[] = new int[elements.length - 1]<span class="token punctuation">;</span>
		//复制原数组的元素到新数组
		for <span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span> i &lt; newArr.length <span class="token selector">; i++)</span> <span class="token punctuation">{<!-- --></span>
			newArr[i] = elements[i+1]<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		// 替换数组
		elements = newArr<span class="token punctuation">;</span>
		return  element<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">// 判断队列是否为空
	public boolean isEmpty()</span> <span class="token punctuation">{<!-- --></span>
		return elements.length == 0<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		MyQueue mq = new <span class="token function">MyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//入队
		mq.<span class="token function">add</span><span class="token punctuation">(</span>9<span class="token punctuation">)</span><span class="token punctuation">;</span>
		mq.<span class="token function">add</span><span class="token punctuation">(</span>8<span class="token punctuation">)</span><span class="token punctuation">;</span>
		mq.<span class="token function">add</span><span class="token punctuation">(</span>7<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//出队
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>mq.<span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		mq.<span class="token function">add</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>mq.<span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>mq.<span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_314"></a>单链表</h3> 
<p>非随机存储的存储结构<br> 优点：<br> 解决顺序表需要大量连续存储单元的缺点<br> 插入删除不需要移动大量元素，只需修改指针<br> 缺点：<br> 附加指针域，浪费存储空间<br> 不能直接找到表中某个特定的节点，需要从表头遍历，依次查找</p> 
<p>引入头结点的优点：</p> 
<ol><li>由于第一个数据节点的位置被存放在头结点的指针域内，因此在链表中第一个位置上的操作和在表中的其他位置操作一致，无需进行特殊操作</li><li>无论链表是否为空，头指针都指向头结点的非空指针，空表和非空表的处理得到了统一</li></ol> 
<p>头插法建立单链表：将新节点插入当前节点的表头，读入数据的顺序与生成的链表的元素顺序相反，时间复杂度为O（n）<br> 尾插法建立单链表：将新节点插入当前节点的表尾，读入数据的顺序与生成的链表的元素顺序相同，时间复杂度为O（n）<br> 在给定的节点后插入新节点，时间复杂度为O（1）</p> 
<pre><code class="prism language-css">
<span class="token comment">/**
 * 单链表
 *
 */</span>
<span class="token selector">//一个节点
public class Node</span> <span class="token punctuation">{<!-- --></span>

	// 节点内容
	int data<span class="token punctuation">;</span>
	// 下一个节点
	Node next<span class="token punctuation">;</span>

	<span class="token selector">public Node(int data)</span> <span class="token punctuation">{<!-- --></span>
		this.data = data<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 为节点追加节点
//	public void append(Node node)</span> <span class="token punctuation">{<!-- --></span>
//		//this.next = node<span class="token punctuation">;</span>
//		//当前节点
//		Node currentNode = this<span class="token punctuation">;</span>
<span class="token selector">//		//循环向后找
//		while(true)</span> <span class="token punctuation">{<!-- --></span>
//			//取出下一个节点
//			Node nextNode = currentNode.next<span class="token punctuation">;</span>
<span class="token selector">//			//如果下一个节点为null,当前节点为最后的节点
//			if(nextNode == null)</span> <span class="token punctuation">{<!-- --></span>
//				break<span class="token punctuation">;</span>
//			<span class="token punctuation">}</span>
//			//赋给当前节点
//			currentNode = nextNode<span class="token punctuation">;</span>
//		<span class="token punctuation">}</span>
//		//把需要追加的节点追加为找到的当前节点的下一个节点
//		currentNode.next = node<span class="token punctuation">;</span>
//	<span class="token punctuation">}</span>
	<span class="token selector">public Node append(Node node)</span> <span class="token punctuation">{<!-- --></span>
		// this.next = node<span class="token punctuation">;</span>
		// 当前节点
		Node currentNode = this<span class="token punctuation">;</span>
		<span class="token selector">// 循环向后找
		while (true)</span> <span class="token punctuation">{<!-- --></span>
			// 取出下一个节点
			Node nextNode = currentNode.next<span class="token punctuation">;</span>
			<span class="token selector">// 如果下一个节点为null,当前节点为最后的节点
			if (nextNode == null)</span> <span class="token punctuation">{<!-- --></span>
				break<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			// 赋给当前节点
			currentNode = nextNode<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 把需要追加的节点追加为找到的当前节点的下一个节点
		currentNode.next = node<span class="token punctuation">;</span>
		return this<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 插入一个节点作为当前节点的下一个节点
	public void after(Node node)</span> <span class="token punctuation">{<!-- --></span>
		// 取出下一个节点作为下下个节点
		Node nextNext = next<span class="token punctuation">;</span>
		// 把新节点作为当前节点的下一个节点
		this.next = node<span class="token punctuation">;</span>
		// 把下下一个节点设置为新节点的下一个节点
		node.next = nextNext<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 显示节点信息
	public void show()</span> <span class="token punctuation">{<!-- --></span>
		Node currentNode = this<span class="token punctuation">;</span>
		<span class="token selector">while (true)</span> <span class="token punctuation">{<!-- --></span>
			System.out.<span class="token function">print</span><span class="token punctuation">(</span>currentNode.data + <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			// 取出下一个节点
			currentNode = currentNode.next<span class="token punctuation">;</span>
			<span class="token selector">// 如果是最后一个节点
			if (currentNode == null)</span> <span class="token punctuation">{<!-- --></span>
				break<span class="token punctuation">;</span>

			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 删除下一个节点
	public void removeNext()</span> <span class="token punctuation">{<!-- --></span>
		// 取出下一个节点
		Node newNext = next.next<span class="token punctuation">;</span>
		// 把下下一个节点设置为当前节点的下一个节点
		this.next = newNext<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 获取下一个节点
	public Node next()</span> <span class="token punctuation">{<!-- --></span>
		return this.next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 获取节点中的数据
	public int getData()</span> <span class="token punctuation">{<!-- --></span>
		return this.data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 当前节点是否是最后一个节点
	public boolean isLast()</span> <span class="token punctuation">{<!-- --></span>
		return next == null<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		// 创建节点
		Node n1 = new <span class="token function">Node</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		Node n2 = new <span class="token function">Node</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		Node n3 = new <span class="token function">Node</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 追加节点
		// n1.<span class="token function">append</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// n2.<span class="token function">append</span><span class="token punctuation">(</span>n3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// n1.<span class="token function">append</span><span class="token punctuation">(</span>n3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		n1.<span class="token function">append</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span>.<span class="token function">append</span><span class="token punctuation">(</span>n3<span class="token punctuation">)</span>.<span class="token function">append</span><span class="token punctuation">(</span>new <span class="token function">Node</span><span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 取出下一个节点
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>n1.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>n2.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>n1.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 判断节点是否为最后一个节点
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>n1.<span class="token function">isLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>n1.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">isLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		// 显示所有节点内容
		n1.<span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 删除一个节点
		// n1.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">removeNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// n1.<span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 插入一个新节点
		Node node = new <span class="token function">Node</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		n1.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">after</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
		n1.<span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_470"></a>循环链表</h3> 
<p>循环单链表仅设尾指针，可以从表中任意节点开始遍历整个链表<br> 循环双链表头结点的prior指针指向表尾结点</p> 
<pre><code class="prism language-css"><span class="token comment">/**
 * 循环链表
 *
 */</span>
<span class="token selector">public class LoopNode</span> <span class="token punctuation">{<!-- --></span>
	// 节点内容
	int data<span class="token punctuation">;</span>
	// 下一个节点<span class="token punctuation">(</span>好强<span class="token punctuation">)</span>
	LoopNode next = this<span class="token punctuation">;</span>

	<span class="token selector">public LoopNode(int data)</span> <span class="token punctuation">{<!-- --></span>
			this.data = data<span class="token punctuation">;</span>

		<span class="token punctuation">}</span>

	<span class="token selector">// 插入一个节点作为当前节点的下一个节点
	public void after(LoopNode node)</span> <span class="token punctuation">{<!-- --></span>
		// 取出下一个节点作为下下个节点
		LoopNode nextNext = next<span class="token punctuation">;</span>
		// 把新节点作为当前节点的下一个节点
		this.next = node<span class="token punctuation">;</span>
		// 把下下一个节点设置为新节点的下一个节点
		node.next = nextNext<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>



	<span class="token selector">// 删除下一个节点
	public void removeNext()</span> <span class="token punctuation">{<!-- --></span>
		// 取出下一个节点
		LoopNode newNext = next.next<span class="token punctuation">;</span>
		// 把下下一个节点设置为当前节点的下一个节点
		this.next = newNext<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 获取下一个节点
	public LoopNode next()</span> <span class="token punctuation">{<!-- --></span>
		return this.next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 获取节点中的数据
	public int getData()</span> <span class="token punctuation">{<!-- --></span>
		return this.data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 当前节点是否是最后一个节点
	public boolean isLast()</span> <span class="token punctuation">{<!-- --></span>
		return next == null<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		// 创建节点
		LoopNode n1 = new <span class="token function">LoopNode</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		LoopNode n2 = new <span class="token function">LoopNode</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		LoopNode n3 = new <span class="token function">LoopNode</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		LoopNode n4 = new <span class="token function">LoopNode</span><span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//增加节点
		n1.<span class="token function">after</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		n2.<span class="token function">after</span><span class="token punctuation">(</span>n3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		n3.<span class="token function">after</span><span class="token punctuation">(</span>n4<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>n1.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>n2.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>n3.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>n4.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_544"></a>双链表</h3> 
<p>优点：<br> 插入、删除操作时间复杂度为O(1)</p> 
<pre><code class="prism language-css"><span class="token selector">public class DoubleNode</span> <span class="token punctuation">{<!-- --></span>

	// 上一个节点
	DoubleNode pre = this<span class="token punctuation">;</span>
	// 节点数据
	int data<span class="token punctuation">;</span>
	// 下一个节点
	DoubleNode next = this<span class="token punctuation">;</span>

	<span class="token selector">public DoubleNode(int data)</span> <span class="token punctuation">{<!-- --></span>
		this.data = data<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 增加节点
	public void after(DoubleNode node)</span> <span class="token punctuation">{<!-- --></span>
		// 原来的下一个节点
		DoubleNode nextNext = next<span class="token punctuation">;</span>
		// 把新节点作为当前节点的下一个节点
		this.next = node<span class="token punctuation">;</span>
		// 把当前节点设置为新节点的前一个节点
		node.pre = this<span class="token punctuation">;</span>
		// 让原来的下一个节点作新节点的下一个节点
		node.next = nextNext<span class="token punctuation">;</span>
		// 让原来的下一个节点的上一个节点为新节点
		nextNext.pre = node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 下一个节点
	public DoubleNode next()</span> <span class="token punctuation">{<!-- --></span>
		return this.next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 上一个节点
	public DoubleNode pre()</span> <span class="token punctuation">{<!-- --></span>
		return this.pre<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 获取节点中的数据
	public int getData()</span> <span class="token punctuation">{<!-- --></span>
		return this.data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 当前节点是否是最后一个节点
	public boolean isLast()</span> <span class="token punctuation">{<!-- --></span>
		return next == null<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		// 创建节点
		DoubleNode n1 = new <span class="token function">DoubleNode</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		DoubleNode n2 = new <span class="token function">DoubleNode</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		DoubleNode n3 = new <span class="token function">DoubleNode</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		DoubleNode n4 = new <span class="token function">DoubleNode</span><span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 追加节点
		n1.<span class="token function">after</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		n2.<span class="token function">after</span><span class="token punctuation">(</span>n3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 查看上一个、自己、下一个节点的内容
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>n2.<span class="token function">pre</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>n2.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>n2.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>n3.<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>n1.<span class="token function">pre</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_617"></a>递归</h3> 
<pre><code class="prism language-css"><span class="token selector">public class TestRecursive</span> <span class="token punctuation">{<!-- --></span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		<span class="token function">print</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//递归操作
	public static void print(int i)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if(i&gt;0)</span> <span class="token punctuation">{<!-- --></span>
			System.out.<span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">print</span><span class="token punctuation">(</span>i-1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>	
	<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="_635"></a>斐波那契数列</h4> 
<pre><code class="prism language-css"><span class="token selector">public class TestFebonacci</span> <span class="token punctuation">{<!-- --></span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		//<span class="token property">斐波那契数列</span><span class="token punctuation">:</span> 1 1 2 3 5 8 13
		int i = <span class="token function">febomacci</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>
	<span class="token selector">//打印第n项斐波那契数列
	public static int febomacci(int i)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if(i == 1 || i == 2)</span> <span class="token punctuation">{<!-- --></span>
			return 1<span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			return <span class="token function">febomacci</span><span class="token punctuation">(</span>i-1<span class="token punctuation">)</span>+<span class="token function">febomacci</span><span class="token punctuation">(</span>i-2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_656"></a>汉诺塔问题</h4> 
<pre><code class="prism language-css"><span class="token selector">public class TestHanoi</span> <span class="token punctuation">{<!-- --></span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		<span class="token function">hanoi</span><span class="token punctuation">(</span>3<span class="token punctuation">,</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/**
	 * @param n ：共有N个盘子
	 * @param from：开始的柱子
	 * @param in：中间的柱子
	 * @param to：目标的柱子
	 * 无论有多少个盘子，都认为只有俩个，上面的所有盘子和最下面一个盘子。
	 * 通过柱子交换位置做相同动作
	 */</span>
	<span class="token selector">public static void hanoi(int n,char from,char in,char to)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">//只有一个盘子
		if(n == 1)</span> <span class="token punctuation">{<!-- --></span>
			System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第1个盘子"</span>+from+<span class="token string">"移到"</span>+to<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//无论有多少个盘子，都认为只有俩个，上面的所有盘子和最下面一个盘子。
		<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			//移动上面所有的盘子到中间位置
			<span class="token function">hanoi</span><span class="token punctuation">(</span>n-1<span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//移动下面的盘子
			System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span>+n+<span class="token string">"个盘子"</span>+from+<span class="token string">"移到"</span>+to<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//把上面的所有的盘子从中间位置移到目标位置
			<span class="token function">hanoi</span><span class="token punctuation">(</span>n-1<span class="token punctuation">,</span> in<span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_689"></a>串</h3> 
<p>串的数据对象为字符集<br> 串的存储结构：<br> 定长顺序存储表示：为每个串变量分配一个固定长度的存储区，串的实际长度小于等于最大长度，超过于定义长度的串值会被截断<br> 堆分配存储表示：存储空间动态分配<br> 块链存储表示：链表方式存储串值，每个结点存放一个或者多个字符，每个结点称为块，最后一个节点占不满时用#补上<br> 串的模式匹配：<br> 简单模式匹配：最坏时间复杂度为O（mn），n和m分别是主串和模式串（子串）的长度<br> KMP算法：利用PM表进行字符串匹配，匹配失败时就去找前一个元素值的部分匹配值，移动位数=已匹配的字符数-对应的部分匹配值，匹配过程中主串没有回退，时间复杂度为<br> O（m+n）</p> 
<h2><a id="_699"></a>排序算法</h2> 
<p>内部排序：元素全部存放在内存中<br> 外部排序：</p> 
<h3><a id="_702"></a>计算</h3> 
<p>衡量一个算法的优劣？<br> 一. 事后统计的方法<br> 二. 事前分析估算的方法<br> T（n）：一个算法中的语句执行次数称为语句频度<br> 低次项、系数、常数项可忽略</p> 
<ol><li>时间复杂度<br> n：问题的规模<br> T（n） = O(f(n))<br> 常数阶： O(1)<br> 对数阶： O（log2n）<br> 线性阶： O（n）<br> 平方阶： O（n^2）<br> 立方阶： O（n^3）<br> K次方阶： O（n^k）<br> 指数阶： O（2^n）<br> 从上往下时间复杂度增加，算法执行效率低</li></ol> 
<p>计算时间复杂度方法：<br> （1） 用常数1代替运行时间中所有加法常数<br> （2）修改后的运行次数函数中，只保留最高阶项<br> （3）去除最高阶项的系数</p> 
<p>平均时间复杂度：所有可能的输入实例以等概率出现的情况下，该算法的运行时间<br> 最坏时间复杂度：最坏情况下的时间复杂度，是算法在任何输入实例上运行时间的界限【通常情况下都讨论这个】<br> 2. 空 间复杂度</p> 
<h3><a id="_728"></a>交换排序</h3> 
<h4><a id="_729"></a>冒泡排序</h4> 
<pre><code class="prism language-css"><span class="token selector">public class BubbleSort</span> <span class="token punctuation">{<!-- --></span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span>5<span class="token punctuation">,</span>7<span class="token punctuation">,</span>2<span class="token punctuation">,</span>9<span class="token punctuation">,</span>4<span class="token punctuation">,</span>1<span class="token punctuation">,</span>0<span class="token punctuation">,</span>5<span class="token punctuation">,</span>7<span class="token punctuation">}</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>
	//冒泡排序
	<span class="token comment">/*
	 * 5,7,2,9,4,1,0,5,7  比较length-1轮
	 * 5,7,2,9,4,1,0,5,7 5比
	 * 5,2,7,9,4,1,0,5,7 2比
	 * 5,7,2,4,1,0,5,7,9 7比
	 * ......
	 */</span>
	<span class="token selector">public static void bubbleSort(int[] arr)</span> <span class="token punctuation">{<!-- --></span>
		//控制共比较多少轮
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i&lt;arr.length-1<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			//控制比较的次数
			<span class="token function">for</span><span class="token punctuation">(</span>int j = 0<span class="token punctuation">;</span>j&lt;arr.length-1-i<span class="token punctuation">;</span>j++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">if(arr[j]&gt;arr[j+1])</span> <span class="token punctuation">{<!-- --></span>
					int temp = arr[j]<span class="token punctuation">;</span>
					arr[j] = arr[j+1]<span class="token punctuation">;</span>
					arr[j+1] = temp<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
	<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="_768"></a>快速排序</h4> 
<p>平均性能最优</p> 
<pre><code class="prism language-css"><span class="token selector">public class QuickSort</span> <span class="token punctuation">{<!-- --></span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span>3<span class="token punctuation">,</span>4<span class="token punctuation">,</span>6<span class="token punctuation">,</span>7<span class="token punctuation">,</span>2<span class="token punctuation">,</span>7<span class="token punctuation">,</span>2<span class="token punctuation">,</span>8<span class="token punctuation">,</span>0<span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>0<span class="token punctuation">,</span>arr.length-1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public static void quickSort(int[] arr,int start,int end)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if(start&lt;end)</span> <span class="token punctuation">{<!-- --></span>
		//把数组第0个数字作为标准数
		int stard = arr[start]<span class="token punctuation">;</span>
		//记录需要排序的下标
		int low = start<span class="token punctuation">;</span>
		int high = end<span class="token punctuation">;</span>
		<span class="token selector">//循环找比标准数大的数和标准数小的数
		while(low&lt;high)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">//右边的数字比标准数小
			while(low&lt;high&amp;&amp;stard&lt;=arr[high])</span> <span class="token punctuation">{<!-- --></span>
				high--<span class="token punctuation">;</span>
				
			<span class="token punctuation">}</span>
			//使用右边的数字替换左边的数
			arr[low] = arr[high]<span class="token punctuation">;</span>
			<span class="token selector">//如果左边的数字比标准数小
			while(low&lt;high&amp;&amp;arr[low]&lt;=stard)</span> <span class="token punctuation">{<!-- --></span>
				low++<span class="token punctuation">;</span>
				
			<span class="token punctuation">}</span>
			arr[high] = arr[low]<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//把标准数赋给低所在的位置的元素
		arr[low] = stard<span class="token punctuation">;</span>
		//处理所有小的数字
		<span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> low<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//处理所有大的数字
		<span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low+1<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_812"></a>插入排序</h3> 
<p>时间复杂度O（n^2）</p> 
<h4><a id="_814"></a>直接插入排序</h4> 
<pre><code class="prism language-css"><span class="token selector">public class InsertSort</span> <span class="token punctuation">{<!-- --></span>
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span>5<span class="token punctuation">,</span>3<span class="token punctuation">,</span>2<span class="token punctuation">,</span>8<span class="token punctuation">,</span>5<span class="token punctuation">,</span>9<span class="token punctuation">,</span>1<span class="token punctuation">,</span>0<span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token function">insertSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token punctuation">}</span>

	<span class="token selector">public static void insertSort(int[] arr)</span> <span class="token punctuation">{<!-- --></span>
		//遍历所有的数字
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 1<span class="token punctuation">;</span>i&lt;arr.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">//如果当前数字比前一个数字小
			if(arr[i]&lt;arr[i-1])</span> <span class="token punctuation">{<!-- --></span>
				//把当前遍历数字存储起来
				int temp = arr[i]<span class="token punctuation">;</span>
				int j<span class="token punctuation">;</span>
				//遍历当前数字前面所有的数字
				<span class="token function">for</span><span class="token punctuation">(</span>j = i-1<span class="token punctuation">;</span>j&gt;=0&amp;&amp;temp&lt;arr[j]<span class="token punctuation">;</span>j--<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					//把前一个数字赋给后一个数字
					arr[j+1] = arr[j]<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				//循环结束后把临时变量（外层for循环当前的元素）赋给不满足条件的后一个值
				arr[j+1] = temp<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_845"></a>希尔排序</h4> 
<p>步长每轮除以二,不稳定，适用于线性表为顺序存储<br> <img src="https://images2.imgbox.com/52/eb/Ga4FIU6k_o.jpg" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-css"><span class="token selector">public class ShellSort</span> <span class="token punctuation">{<!-- --></span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span>3<span class="token punctuation">,</span>5<span class="token punctuation">,</span>2<span class="token punctuation">,</span>7<span class="token punctuation">,</span>9<span class="token punctuation">,</span>1<span class="token punctuation">,</span>2<span class="token punctuation">,</span>0<span class="token punctuation">,</span>4<span class="token punctuation">,</span>7<span class="token punctuation">,</span>4<span class="token punctuation">,</span>3<span class="token punctuation">,</span>8<span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token function">shellSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public static void shellSort(int[] arr)</span> <span class="token punctuation">{<!-- --></span>
		int k =1<span class="token punctuation">;</span>
		//遍历所有步长
		<span class="token function">for</span><span class="token punctuation">(</span>int d = arr.length/2<span class="token punctuation">;</span>d&gt;0<span class="token punctuation">;</span>d/=2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			//遍历所有的元素
			<span class="token function">for</span><span class="token punctuation">(</span>int i = d<span class="token punctuation">;</span>i&lt;arr.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				//遍历本组中所有的元素
				<span class="token function">for</span><span class="token punctuation">(</span>int j = i-d<span class="token punctuation">;</span>j&gt;=0<span class="token punctuation">;</span>j-=d<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token selector">//如果当前元素大于加上步长后的那个元素
					if(arr[j]&gt;arr[j+d])</span> <span class="token punctuation">{<!-- --></span>
						int temp = arr[j]<span class="token punctuation">;</span>
						arr[j] = arr[j+d]<span class="token punctuation">;</span>
						arr[j+d] = temp<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span>+k+<span class="token string">"次排序结果"</span>+Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			k++<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
	<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_883"></a>选择排序</h3> 
<h4><a id="_884"></a>简单选择排序</h4> 
<p>空间效率为O（1），时间复杂度为O（n^2），是一种不稳定的排序方式</p> 
<pre><code class="prism language-css"><span class="token selector">public class SelectSort</span> <span class="token punctuation">{<!-- --></span>
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span>3<span class="token punctuation">,</span>4<span class="token punctuation">,</span>5<span class="token punctuation">,</span>7<span class="token punctuation">,</span>1<span class="token punctuation">,</span>2<span class="token punctuation">,</span>0<span class="token punctuation">,</span>3<span class="token punctuation">,</span>6<span class="token punctuation">,</span>8<span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token function">selectSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public static void selectSort(int[] arr)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		//遍历所有的数
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i &lt; arr.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			int minIndex = i<span class="token punctuation">;</span>
			//把当前遍历的数和后面所有的数依次进行比较，并记录下最小的数的下标
			<span class="token function">for</span><span class="token punctuation">(</span>int j = i+1<span class="token punctuation">;</span>j&lt;arr.length<span class="token punctuation">;</span>j++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">//如果后面比较的数比记录的最小的数小
				if(arr[minIndex]&gt;arr[j])</span> <span class="token punctuation">{<!-- --></span>
					//记录下最小的那个数的下标
					minIndex = j<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token selector">//如果最小的数和当前遍历的数的下标不一致,说明下标为minIndex的数比当前遍历的数小
			if(i != minIndex)</span> <span class="token punctuation">{<!-- --></span>
				int temp = arr[i]<span class="token punctuation">;</span>
				arr[i] = arr[minIndex]<span class="token punctuation">;</span>
				arr[minIndex] = temp<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
	<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_918"></a>堆排序</h4> 
<p>L(i)&gt;=L(2i)且L(i)&gt;=L(2i+1)或L(i)&lt;=L(2i)且L(i)&lt;=L(2i+1)，可以将一堆数组视为一棵完全二叉树，满足前条件的称为大根堆，最大元素存放在根节点，任意非根节点的值小于等于其双亲节点的值<br> 用二叉树排列数组大小<br> 大顶堆（升序排列）：任何一个父节点都大于它的子节点<br> 小顶堆（降序排列）：任何一个父节点都小于它的子节点</p> 
<p>堆排序</p> 
<pre><code class="prism language-css">package demo2<span class="token punctuation">;</span>
<span class="token comment">/*
 * 堆排序
 */</span>
import java.util.Arrays<span class="token punctuation">;</span>

<span class="token selector">public class HeapSort</span> <span class="token punctuation">{<!-- --></span>

	<span class="token selector">public static void maxHeap(int[] arr, int size, int index)</span> <span class="token punctuation">{<!-- --></span>
		// 左子节点
		int leftNode = 2 * index + 1<span class="token punctuation">;</span>
		// 右子节点
		int rightNode = 2 * index + 2<span class="token punctuation">;</span>
		int max = index<span class="token punctuation">;</span>
		<span class="token selector">// 和两个节点对比，找出最大节点
		if (leftNode &lt; size &amp;&amp; arr[leftNode] &gt; arr[max])</span> <span class="token punctuation">{<!-- --></span>
			max = leftNode<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">if (rightNode &lt; size &amp;&amp; arr[rightNode] &gt; arr[max])</span> <span class="token punctuation">{<!-- --></span>
			max = rightNode<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 交换位置
		if (max != index)</span> <span class="token punctuation">{<!-- --></span>
			int temp = arr[index]<span class="token punctuation">;</span>
			arr[index] = arr[max]<span class="token punctuation">;</span>
			arr[max] = temp<span class="token punctuation">;</span>
			// 交换位置后，可能会破坏之前排好的堆，所以，之前排好的堆需要重新调整
			<span class="token function">maxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> size<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public static void heapSort(int[] arr)</span> <span class="token punctuation">{<!-- --></span>
		// 开始位置是最后一个非叶子节点，及最后一个节点的父节点
		int start = <span class="token punctuation">(</span>arr.length - 1<span class="token punctuation">)</span> / 2<span class="token punctuation">;</span>
		// 结束位置是数组的长度-1<span class="token punctuation">,</span>调整为大顶堆
		for <span class="token punctuation">(</span>int i = start<span class="token punctuation">;</span> i &gt;= 0<span class="token punctuation">;</span> <span class="token selector">i--)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">maxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr.length<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//先把数组中第0个和堆中最后一个数交换位置，再把前面的处理为大顶堆
		<span class="token function">for</span><span class="token punctuation">(</span>int i = arr.length-1<span class="token punctuation">;</span>i&gt;0<span class="token punctuation">;</span>i--<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			int temp = arr[0]<span class="token punctuation">;</span>
			arr[0] = arr[i]<span class="token punctuation">;</span>
			arr[i] = temp<span class="token punctuation">;</span>
			<span class="token function">maxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span> 9<span class="token punctuation">,</span> 6<span class="token punctuation">,</span> 8<span class="token punctuation">,</span> 7<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 10<span class="token punctuation">,</span> 4<span class="token punctuation">,</span> 2 <span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_983"></a>归并排序</h3> 
<pre><code class="prism language-css"><span class="token selector">public class MergeSort</span> <span class="token punctuation">{<!-- --></span>
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span>1<span class="token punctuation">,</span>3<span class="token punctuation">,</span>5<span class="token punctuation">,</span>2<span class="token punctuation">,</span>4<span class="token punctuation">,</span>6<span class="token punctuation">,</span>8<span class="token punctuation">,</span>10<span class="token punctuation">}</span><span class="token punctuation">;</span>
		//<span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 2<span class="token punctuation">,</span> arr.length-1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> arr.length-1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//归并排序
	public static void mergeSort(int[] arr,int low,int high)</span> <span class="token punctuation">{<!-- --></span>
		int middle = <span class="token punctuation">(</span>high+low<span class="token punctuation">)</span>/2<span class="token punctuation">;</span>
		<span class="token selector">if(low&lt;high)</span> <span class="token punctuation">{<!-- --></span>
		//处理左边
		<span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//处理右边
		<span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> middle+1<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//归并
		<span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> middle<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public static void merge(int[] arr,int low,int middle,int high)</span> <span class="token punctuation">{<!-- --></span>
		//用于存储归并后的临时数组
		int[] temp = new int[high-low+1]<span class="token punctuation">;</span>
		//记录第一个数组中需要遍历的下标
		int i = low<span class="token punctuation">;</span>
		//记录第二个数组中需要遍历的下标
		int j = middle+1<span class="token punctuation">;</span>
		//用于记录在临时数组中存放的下标
		int index = 0<span class="token punctuation">;</span>
		<span class="token selector">//遍历俩个数组取出小的数字，放入临时数组中
		while(i &lt;= middle &amp;&amp; j &lt;= high)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">//第一个数组的数据更小
			if(arr[i]&lt;=arr[j])</span> <span class="token punctuation">{<!-- --></span>
				//把小的数据放入临时数组中
				temp[index] = arr[i]<span class="token punctuation">;</span>
				//把下标向后移一位
				i++<span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				temp[index] = arr[j]<span class="token punctuation">;</span>
				j++<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			index++<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">//处理多余的数据
		while(j&lt;=high)</span> <span class="token punctuation">{<!-- --></span>
			temp[index] = arr[j]<span class="token punctuation">;</span>
			j++<span class="token punctuation">;</span>
			index++<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">while(i&lt;=middle)</span> <span class="token punctuation">{<!-- --></span>
			temp[index] = arr[i]<span class="token punctuation">;</span>
			i++<span class="token punctuation">;</span>
			index++<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//把临时数组中的数据重新存入原数组
		<span class="token function">for</span><span class="token punctuation">(</span>int k = 0<span class="token punctuation">;</span>k&lt;temp.length<span class="token punctuation">;</span>k++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			arr[k+low] = temp[k]<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
	<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_1049"></a>基数排序</h3> 
<pre><code class="prism language-css"><span class="token selector">public class RadixSort</span> <span class="token punctuation">{<!-- --></span>
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token selector">int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span>23<span class="token punctuation">,</span>6<span class="token punctuation">,</span>189<span class="token punctuation">,</span>45<span class="token punctuation">,</span>9<span class="token punctuation">,</span>287<span class="token punctuation">,</span>56<span class="token punctuation">,</span>1<span class="token punctuation">,</span>798<span class="token punctuation">,</span>34<span class="token punctuation">,</span>65<span class="token punctuation">,</span>652<span class="token punctuation">,</span>5<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public static void radixSort(int[] arr)</span> <span class="token punctuation">{<!-- --></span>
		//存数组中最大的数字
		int max = Integer.MIN_VALUE<span class="token punctuation">;</span>
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i&lt;arr.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">if(arr[i]&gt;max)</span> <span class="token punctuation">{<!-- --></span>
				max = arr[i]<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			
		<span class="token punctuation">}</span>
		//求最大数字是几位数
		int max_Length = <span class="token punctuation">(</span>max+<span class="token string">""</span><span class="token punctuation">)</span>.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//用于临时存储数据的数组
		int[][] temp = new int[10][arr.length]<span class="token punctuation">;</span>
		//用于记录在temp中相应的数组中存放的数字的数量
		int[] counts = new int[10]<span class="token punctuation">;</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>max_Length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//根据最大长度的数决定比较的次数
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">,</span>n = 1<span class="token punctuation">;</span>i&lt;max_Length<span class="token punctuation">;</span>i++<span class="token punctuation">,</span>n <span class="token selector">*= 10)</span> <span class="token punctuation">{<!-- --></span>
			//把每一个数字分别计算余数
			<span class="token function">for</span><span class="token punctuation">(</span>int j = 0<span class="token punctuation">;</span>j&lt;arr.length<span class="token punctuation">;</span>j++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				//计算余数
				int ys = arr[j]/n%10<span class="token punctuation">;</span>
				//把当前遍历的数据放入指定的数组中
			    temp[ys][counts[ys]] = arr[j]<span class="token punctuation">;</span>
			    //记录数量
			    counts[ys]++<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

			//记录取的元素需要放的位置
			int index = 0<span class="token punctuation">;</span>
			//把数字取出来
			<span class="token function">for</span><span class="token punctuation">(</span>int k =0<span class="token punctuation">;</span>k&lt;counts.length<span class="token punctuation">;</span>k++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">//记录数量的数组中当前余数记录的数量不为0
				if(counts[k] != 0)</span> <span class="token punctuation">{<!-- --></span>
					//循环取出元素
					<span class="token function">for</span><span class="token punctuation">(</span>int l = 0<span class="token punctuation">;</span>l&lt;counts[k]<span class="token punctuation">;</span>l++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						//取出元素
						arr[index] = temp[k][l]<span class="token punctuation">;</span>
						//记录下一个位置
						index++<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					//把数量置空
					counts[k] = 0<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token selector">//if(i == 0)</span> <span class="token punctuation">{<!-- --></span>
<span class="token selector">//			for(int[] nums:temp)</span> <span class="token punctuation">{<!-- --></span>
//				System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//			<span class="token punctuation">}</span>
		//<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
	<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-css"><span class="token comment">/*
 * 优化 利用队列 基数排序
 */</span>
<span class="token selector">public class RadixQueueSort</span> <span class="token punctuation">{<!-- --></span>
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span> 23<span class="token punctuation">,</span> 6<span class="token punctuation">,</span> 189<span class="token punctuation">,</span> 45<span class="token punctuation">,</span> 9<span class="token punctuation">,</span> 287<span class="token punctuation">,</span> 56<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 798<span class="token punctuation">,</span> 34<span class="token punctuation">,</span> 65<span class="token punctuation">,</span> 652<span class="token punctuation">,</span> 5 <span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public static void radixSort(int[] arr)</span> <span class="token punctuation">{<!-- --></span>
		// 存数组中最大的数字
		int max = Integer.MIN_VALUE<span class="token punctuation">;</span>
		for <span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span> i &lt; arr.length<span class="token punctuation">;</span> <span class="token selector">i++)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">if (arr[i] &gt; max)</span> <span class="token punctuation">{<!-- --></span>
				max = arr[i]<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

		<span class="token punctuation">}</span>
		// 求最大数字是几位数
		int max_Length = <span class="token punctuation">(</span>max + <span class="token string">""</span><span class="token punctuation">)</span>.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 用于临时存储数据的队列
		MyQueue[] temp = new MyQueue[10]<span class="token punctuation">;</span>
		// 为队列数组赋值
		for <span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span> i &lt; temp.length<span class="token punctuation">;</span> <span class="token selector">i++)</span> <span class="token punctuation">{<!-- --></span>
			temp[i] = new <span class="token function">MyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>max_Length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 根据最大长度的数决定比较的次数
		for <span class="token punctuation">(</span>int i = 0<span class="token punctuation">,</span> n = 1<span class="token punctuation">;</span> i &lt; max_Length<span class="token punctuation">;</span> <span class="token selector">i++, n *= 10)</span> <span class="token punctuation">{<!-- --></span>
			// 把每一个数字分别计算余数
			for <span class="token punctuation">(</span>int j = 0<span class="token punctuation">;</span> j &lt; arr.length<span class="token punctuation">;</span> <span class="token selector">j++)</span> <span class="token punctuation">{<!-- --></span>
				// 计算余数
				int ys = arr[j] / n % 10<span class="token punctuation">;</span>
				// 把当前遍历的数据放入指定的队列中
				temp[ys].<span class="token function">add</span><span class="token punctuation">(</span>arr[j]<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">;</span>

			<span class="token punctuation">}</span>

			// 记录取的元素需要放的位置
			int index = 0<span class="token punctuation">;</span>
			// 把所有队列中的数字取出来
			for <span class="token punctuation">(</span>int k = 0<span class="token punctuation">;</span> k &lt; temp.length<span class="token punctuation">;</span> <span class="token selector">k++)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">// 循环取出元素
				while (!temp[k].isEmpty())</span> <span class="token punctuation">{<!-- --></span>
					// 取出元素
					arr[index] = temp[k].<span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					// 记录下一个位置
					index++<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>

			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h2><a id="_1175"></a>树形结构</h2> 
<p>树是一种递归的数据结构，是一种逻辑结构也是一种分层结构<br> 节点的度：一个节点子节点的个数<br> 节点的权：这个节点赋予的数值<br> 叶子结点：没有子节点的节点<br> 满二叉树：所有叶子节点都在最后一层，而且节点总数为2^n-1，n是树的高度<br> 完全二叉树：所有叶子节点都在最后一层或倒数第二层，且最后一层的叶子结点在左边连续，倒数第二层的叶子节点在右边连续<br> 完全二叉树n个节点，叶节点个数为n/2，n0=n2+1,若一个节点没有左孩子，则它必是叶节点<br> 左斜树：都是左节点的树<br> 右斜树：都是右节点的树<br> 分支节点（非终端节点）：度大于0的节点<br> 高度为h的m叉树至多是（m^h-1）/（m-1）个结点<br> 具有n个结点的m叉树的最小高度为【log底为m (n(m-1)+1)】<br> 顺序存储的空间利用率较低，二叉树一般采用链式存储结构，含有n个结点的二叉链表中，含有n+1个空链域</p> 
<p>树的存储结构：<br> 双亲表示法：根节点下标为0，伪指针域为-1<br> 孩子表示法：每个节点的孩子节点都用单链表连接成一个线性结构<br> 孩子兄弟表示法：指向第一个孩子结点的指针，节点值，指向下一个兄弟结点的指针</p> 
<p>二叉树是一种逻辑结构，线索二叉树是物理结构<br> 线索二叉树：没有左孩子指向前驱<br> 后续线索二叉树不能解决后序后继的问题<br> 中序线索树中，若某节点有左节点，前驱节点为左子树最右的节点</p> 
<p>树转换成二叉树：左孩子右兄弟<br> 森林中树的棵树为根节点A的棵树<br> 森林转换成二叉树：第一棵的根为整个树的根，留左子树，第二棵放在右子树，第三棵放在第二棵树下<br> 情形一：节点u和v是兄弟节点，二者之间还有一个兄弟节点k,转换后节点v就变成节点k的右孩子，k是u的右孩子；情形二：v是u的第二个孩子节点，转换时，v变成u的第一个孩子的右孩子<br> 森林F对应的二叉树为B，它有m个结点，B的根为P，P的右子树节点个数为n,F第一棵树的节点个数为m-n；F有n个非终端节点，B中右指针为空的节点有n+1</p> 
<p>有序树转二叉树，后根排列为中序排列</p> 
<h3><a id="_1207"></a>链式存储的二叉树</h3> 
<p>在含有n个节点的二叉链表中，含有n+1个空链域</p> 
<h4><a id="_1209"></a>创建二叉树：</h4> 
<pre><code class="prism language-css"><span class="token comment">/*
 * 树节点
 */</span>
<span class="token selector">public class TreeNode</span> <span class="token punctuation">{<!-- --></span>
	//节点的权
	int value<span class="token punctuation">;</span>
	//左儿子
	TreeNode leftNode<span class="token punctuation">;</span>
	//右儿子
	TreeNode rightNode<span class="token punctuation">;</span>
	<span class="token selector">public TreeNode(int value)</span> <span class="token punctuation">{<!-- --></span>
		this.value = value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//设置左儿子
	public void setlNode(TreeNode lNode)</span> <span class="token punctuation">{<!-- --></span>
		this.leftNode = lNode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//设置右儿子
	public void setrNode(TreeNode rNode)</span> <span class="token punctuation">{<!-- --></span>
		this.rightNode = rNode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token comment">/*
 * 二叉树
 */</span>
<span class="token selector">public class BinaryTree</span> <span class="token punctuation">{<!-- --></span>
	//根节点
	TreeNode root<span class="token punctuation">;</span>
	<span class="token selector">//设置根节点
	public void setRoot(TreeNode root)</span> <span class="token punctuation">{<!-- --></span>
		this.root = root<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//获取根节点
	public TreeNode getRoot()</span> <span class="token punctuation">{<!-- --></span>
		return root<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		//创建一棵树
		BinaryTree binTree = new <span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个根节点
		TreeNode root = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//把根节点赋给树
		binTree.<span class="token function">setRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个左节点
		TreeNode rootL = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个右节点
		TreeNode rootR = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//把新创建的结点设置为根节点的子节点
		root.<span class="token function">setlNode</span><span class="token punctuation">(</span>rootL<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root.<span class="token function">setrNode</span><span class="token punctuation">(</span>rootR<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="_1270"></a>前序、中序、后序遍历</h4> 
<p><img src="https://images2.imgbox.com/81/e1/Uhp10IxS_o.jpg" alt="在这里插入图片描述"><br> 中序与前序遍历可以一致<br> 前序遍历：<br> 先取根节点，遍历左子树，后遍历右子树<br> 中序遍历：<br> 先取左节点，再取根结点，最后取右节点<br> 前序为入栈，中序为出栈<br> 后序遍历：<br> 先取左节点，再取右节点，最后想要遍历的结点<br> 时间复杂度为O（n），若只知道二叉树的先序序列和后序序列无法确定一棵二叉树<br> 层次遍历：<br> 借助队列，将第一层的根节点入队出队，访问出队节点，若有左/右子树，则将其入队出队访问出队节点<br> 出栈序列个数为1/(n+1)C(n,2n)</p> 
<pre><code class="prism language-css">package demo3<span class="token punctuation">;</span>
<span class="token comment">/*
 * 树节点
 */</span>
<span class="token selector">public class TreeNode</span> <span class="token punctuation">{<!-- --></span>
	//节点的权
	int value<span class="token punctuation">;</span>
	//左儿子
	TreeNode leftNode<span class="token punctuation">;</span>
	//右儿子
	TreeNode rightNode<span class="token punctuation">;</span>
	<span class="token selector">public TreeNode(int value)</span> <span class="token punctuation">{<!-- --></span>
		this.value = value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//设置左儿子
	public void setLeftNode(TreeNode lNode)</span> <span class="token punctuation">{<!-- --></span>
		this.leftNode = lNode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//设置右儿子
	public void setRightNode(TreeNode rNode)</span> <span class="token punctuation">{<!-- --></span>
		this.rightNode = rNode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//前序遍历
	public void frontShow()</span> <span class="token punctuation">{<!-- --></span>
		//遍历当前节点的内容
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">//左节点
		if(leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			leftNode.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">//右节点
		if(rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			rightNode.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//中序遍历
	public void midShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		//左节点
		if(leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			leftNode.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//当前节点
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">//右节点
		if(rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			rightNode.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//后序遍历
	public void afterShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		//左节点
		if(leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			leftNode.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">//右节点
		if(rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			rightNode.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//当前节点
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

package demo3<span class="token punctuation">;</span>
<span class="token comment">/*
 * 二叉树
 */</span>
<span class="token selector">public class BinaryTree</span> <span class="token punctuation">{<!-- --></span>
	//根节点
	TreeNode root<span class="token punctuation">;</span>
	<span class="token selector">//设置根节点
	public void setRoot(TreeNode root)</span> <span class="token punctuation">{<!-- --></span>
		this.root = root<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//获取根节点
	public TreeNode getRoot()</span> <span class="token punctuation">{<!-- --></span>
		return root<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public void frontShow()</span> <span class="token punctuation">{<!-- --></span>
		root.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
	<span class="token selector">public void midShow()</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		root.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public void afterShow()</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		root.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		//创建一棵树
		BinaryTree binTree = new <span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个根节点
		TreeNode root = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//把根节点赋给树
		binTree.<span class="token function">setRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个左节点
		TreeNode rootL = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个右节点
		TreeNode rootR = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//把新创建的结点设置为根节点的子节点
		root.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>rootL<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root.<span class="token function">setRightNode</span><span class="token punctuation">(</span>rootR<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//为第二层的左节点创建俩个子节点
		rootL.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		rootL.<span class="token function">setRightNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//为第二层的右节点创建俩个左节点
		rootR.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		rootR.<span class="token function">setRightNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>7<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//前序遍历
		binTree.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//中序遍历
		binTree.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//后序遍历
		binTree.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>




<span class="token punctuation">}</span>


</code></pre> 
<h4><a id="_1416"></a>查找节点</h4> 
<pre><code class="prism language-css">package demo3<span class="token punctuation">;</span>

<span class="token comment">/*
 * 树节点
 */</span>
<span class="token selector">public class TreeNode</span> <span class="token punctuation">{<!-- --></span>
	// 节点的权
	int value<span class="token punctuation">;</span>
	// 左儿子
	TreeNode leftNode<span class="token punctuation">;</span>
	// 右儿子
	TreeNode rightNode<span class="token punctuation">;</span>

	<span class="token selector">public TreeNode(int value)</span> <span class="token punctuation">{<!-- --></span>
		this.value = value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 设置左儿子
	public void setLeftNode(TreeNode lNode)</span> <span class="token punctuation">{<!-- --></span>
		this.leftNode = lNode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 设置右儿子
	public void setRightNode(TreeNode rNode)</span> <span class="token punctuation">{<!-- --></span>
		this.rightNode = rNode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 前序遍历
	public void frontShow()</span> <span class="token punctuation">{<!-- --></span>
		// 遍历当前节点的内容
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// 左节点
		if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			leftNode.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 右节点
		if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			rightNode.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 中序遍历
	public void midShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		// 左节点
		if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			leftNode.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 当前节点
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// 右节点
		if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			rightNode.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 后序遍历
	public void afterShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		// 左节点
		if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			leftNode.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 右节点
		if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			rightNode.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 当前节点
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 前序查找
	public TreeNode frontSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		TreeNode target = null<span class="token punctuation">;</span>
		<span class="token selector">// 对比当前节点的值
		if (this.value == i)</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
			// 当前结点的值不是要查找的节点
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">// 查找左儿子
			if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
				// 有可能查到，若查不到，target = null
				target = leftNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token selector">// 若不为空，在左儿子中已经找到
			if (target != null)</span> <span class="token punctuation">{<!-- --></span>
				return target<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token selector">// 查找右儿子
			if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
				target = rightNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		return target<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 中序查找
	public TreeNode midSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		TreeNode target = null<span class="token punctuation">;</span>
		<span class="token selector">// 查找左儿子
		if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			// 有可能查到，若查不到，target = null
			target = leftNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 若不为空，在左儿子中已经找到
		if (target != null)</span> <span class="token punctuation">{<!-- --></span>
			return target<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">if (this.value == i)</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 查找右儿子
		if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			target = rightNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 若不为空，在右儿子中已经找到
		if (target != null)</span> <span class="token punctuation">{<!-- --></span>
			return target<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">if (this.value == i)</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return target<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 后序查找
	public TreeNode afterSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		TreeNode target = null<span class="token punctuation">;</span>
		<span class="token selector">// 查找左儿子
		if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			// 有可能查到，若查不到，target = null
			target = leftNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 若不为空，在左儿子中已经找到
		if (target != null)</span> <span class="token punctuation">{<!-- --></span>
			return target<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 查找右儿子
		if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			target = rightNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 若不为空，在右儿子中已经找到
		if (target != null)</span> <span class="token punctuation">{<!-- --></span>
			return target<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">if (this.value == i)</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return target<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

package demo3<span class="token punctuation">;</span>
<span class="token comment">/*
 * 二叉树
 */</span>
<span class="token selector">public class BinaryTree</span> <span class="token punctuation">{<!-- --></span>
	//根节点
	TreeNode root<span class="token punctuation">;</span>
	<span class="token selector">//设置根节点
	public void setRoot(TreeNode root)</span> <span class="token punctuation">{<!-- --></span>
		this.root = root<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//获取根节点
	public TreeNode getRoot()</span> <span class="token punctuation">{<!-- --></span>
		return root<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public void frontShow()</span> <span class="token punctuation">{<!-- --></span>
		root.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
	<span class="token selector">public void midShow()</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		root.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public void afterShow()</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		root.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public TreeNode frontSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		return root.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public TreeNode afterSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		return root.<span class="token function">afterSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public TreeNode midSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		return root.<span class="token function">midSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		//创建一棵树
		BinaryTree binTree = new <span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个根节点
		TreeNode root = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//把根节点赋给树
		binTree.<span class="token function">setRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个左节点
		TreeNode rootL = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个右节点
		TreeNode rootR = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//把新创建的结点设置为根节点的子节点
		root.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>rootL<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root.<span class="token function">setRightNode</span><span class="token punctuation">(</span>rootR<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//为第二层的左节点创建俩个子节点
		rootL.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		rootL.<span class="token function">setRightNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//为第二层的右节点创建俩个左节点
		rootR.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		rootR.<span class="token function">setRightNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>7<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//前序遍历
		binTree.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//中序遍历
		binTree.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//后序遍历
		binTree.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//前序查找
		TreeNode result = binTree.<span class="token function">frontSearch</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
		TreeNode result1 = binTree.<span class="token function">midSearch</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		TreeNode result2 = binTree.<span class="token function">afterSearch</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	




<span class="token punctuation">}</span>


</code></pre> 
<h4><a id="_1663"></a>删除节点</h4> 
<pre><code class="prism language-css">package demo3<span class="token punctuation">;</span>

<span class="token comment">/*
 * 树节点
 */</span>
<span class="token selector">public class TreeNode</span> <span class="token punctuation">{<!-- --></span>
	// 节点的权
	int value<span class="token punctuation">;</span>
	// 左儿子
	TreeNode leftNode<span class="token punctuation">;</span>
	// 右儿子
	TreeNode rightNode<span class="token punctuation">;</span>

	<span class="token selector">public TreeNode(int value)</span> <span class="token punctuation">{<!-- --></span>
		this.value = value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 设置左儿子
	public void setLeftNode(TreeNode lNode)</span> <span class="token punctuation">{<!-- --></span>
		this.leftNode = lNode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 设置右儿子
	public void setRightNode(TreeNode rNode)</span> <span class="token punctuation">{<!-- --></span>
		this.rightNode = rNode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 前序遍历
	public void frontShow()</span> <span class="token punctuation">{<!-- --></span>
		// 遍历当前节点的内容
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// 左节点
		if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			leftNode.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 右节点
		if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			rightNode.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 中序遍历
	public void midShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		// 左节点
		if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			leftNode.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 当前节点
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// 右节点
		if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			rightNode.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 后序遍历
	public void afterShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		// 左节点
		if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			leftNode.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 右节点
		if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			rightNode.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 当前节点
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 前序查找
	public TreeNode frontSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		TreeNode target = null<span class="token punctuation">;</span>
		<span class="token selector">// 对比当前节点的值
		if (this.value == i)</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
			// 当前结点的值不是要查找的节点
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">// 查找左儿子
			if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
				// 有可能查到，若查不到，target = null
				target = leftNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token selector">// 若不为空，在左儿子中已经找到
			if (target != null)</span> <span class="token punctuation">{<!-- --></span>
				return target<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token selector">// 查找右儿子
			if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
				target = rightNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		return target<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 中序查找
	public TreeNode midSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		TreeNode target = null<span class="token punctuation">;</span>
		<span class="token selector">// 查找左儿子
		if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			// 有可能查到，若查不到，target = null
			target = leftNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 若不为空，在左儿子中已经找到
		if (target != null)</span> <span class="token punctuation">{<!-- --></span>
			return target<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">if (this.value == i)</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 查找右儿子
		if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			target = rightNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 若不为空，在右儿子中已经找到
		if (target != null)</span> <span class="token punctuation">{<!-- --></span>
			return target<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">if (this.value == i)</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return target<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 后序查找
	public TreeNode afterSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		TreeNode target = null<span class="token punctuation">;</span>
		<span class="token selector">// 查找左儿子
		if (leftNode != null)</span> <span class="token punctuation">{<!-- --></span>
			// 有可能查到，若查不到，target = null
			target = leftNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 若不为空，在左儿子中已经找到
		if (target != null)</span> <span class="token punctuation">{<!-- --></span>
			return target<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 查找右儿子
		if (rightNode != null)</span> <span class="token punctuation">{<!-- --></span>
			target = rightNode.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 若不为空，在右儿子中已经找到
		if (target != null)</span> <span class="token punctuation">{<!-- --></span>
			return target<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">if (this.value == i)</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return target<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token selector">//删除一个子树
	public void delete(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		TreeNode parent = this<span class="token punctuation">;</span>
		<span class="token selector">//判断左儿子
		if(parent.leftNode != null &amp;&amp; parent.leftNode.value == i)</span> <span class="token punctuation">{<!-- --></span>
			parent.leftNode = null<span class="token punctuation">;</span>
			return<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">//判断右儿子
		if(parent.rightNode != null &amp;&amp; parent.rightNode.value == i)</span> <span class="token punctuation">{<!-- --></span>
			parent.rightNode = null<span class="token punctuation">;</span>
			return<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//递归检查并删除左儿子
		parent = leftNode<span class="token punctuation">;</span>
		<span class="token selector">if(parent != null)</span> <span class="token punctuation">{<!-- --></span>
			parent.<span class="token function">delete</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//递归检查并删除右儿子
		parent = rightNode<span class="token punctuation">;</span>
		<span class="token selector">if(parent != null)</span> <span class="token punctuation">{<!-- --></span>
			parent.<span class="token function">delete</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

package demo3<span class="token punctuation">;</span>
<span class="token comment">/*
 * 二叉树
 */</span>
<span class="token selector">public class BinaryTree</span> <span class="token punctuation">{<!-- --></span>
	//根节点
	TreeNode root<span class="token punctuation">;</span>
	<span class="token selector">//设置根节点
	public void setRoot(TreeNode root)</span> <span class="token punctuation">{<!-- --></span>
		this.root = root<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//获取根节点
	public TreeNode getRoot()</span> <span class="token punctuation">{<!-- --></span>
		return root<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public void frontShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if(root != null)</span> <span class="token punctuation">{<!-- --></span>
		root.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public void midShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if(root != null)</span> <span class="token punctuation">{<!-- --></span>
		root.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public void afterShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if(root != null)</span> <span class="token punctuation">{<!-- --></span>
		root.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public TreeNode frontSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		return root.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public TreeNode afterSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		return root.<span class="token function">afterSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public TreeNode midSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		return root.<span class="token function">midSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token selector">public void delete(int i)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if(root.value == i)</span> <span class="token punctuation">{<!-- --></span>
			root = null<span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			root.<span class="token function">delete</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		//创建一棵树
		BinaryTree binTree = new <span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个根节点
		TreeNode root = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//把根节点赋给树
		binTree.<span class="token function">setRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个左节点
		TreeNode rootL = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个右节点
		TreeNode rootR = new <span class="token function">TreeNode</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//把新创建的结点设置为根节点的子节点
		root.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>rootL<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root.<span class="token function">setRightNode</span><span class="token punctuation">(</span>rootR<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//为第二层的左节点创建俩个子节点
		rootL.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		rootL.<span class="token function">setRightNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//为第二层的右节点创建俩个左节点
		rootR.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		rootR.<span class="token function">setRightNode</span><span class="token punctuation">(</span>new <span class="token function">TreeNode</span><span class="token punctuation">(</span>7<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//前序遍历
		binTree.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//中序遍历
		binTree.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//后序遍历
		binTree.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//前序查找
		TreeNode result = binTree.<span class="token function">frontSearch</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
		TreeNode result1 = binTree.<span class="token function">midSearch</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		TreeNode result2 = binTree.<span class="token function">afterSearch</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//删除一个子树
		binTree.<span class="token function">delete</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		binTree.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	




<span class="token punctuation">}</span>


</code></pre> 
<h3><a id="_1954"></a>顺序存储的二叉树</h3> 
<p>任何一个数组都可以看成是一棵完全二叉树<br> 顺序存储的二叉树只考虑完全二叉树<br> 第n个元素的左子节点是： 2<em>n+1<br> 第n个元素的右子节点是： 2</em>n+2<br> 第n个元素的父节点是： （n-1）/2</p> 
<pre><code class="prism language-css">package demo3<span class="token punctuation">;</span>

<span class="token comment">/*
 * 顺序存储的二叉树
 */</span>
<span class="token selector">public class ArrayBinaryTree</span> <span class="token punctuation">{<!-- --></span>
	int[] data<span class="token punctuation">;</span>

	<span class="token selector">public ArrayBinaryTree(int[] data)</span> <span class="token punctuation">{<!-- --></span>
		this.data = data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public void frontShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">frontShow</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 前序遍历
	public void frontShow(int index)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (data == null || data.length == 0)</span> <span class="token punctuation">{<!-- --></span>
			return<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 遍历当前节点的内容
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>data[index]<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// 左节点
		if (2 * index + 1 &lt; data.length)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">frontShow</span><span class="token punctuation">(</span>2 * index + 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 右节点
		if (2 * index + 2 &lt; data.length)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">frontShow</span><span class="token punctuation">(</span>2 * index + 2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">int[] data = new int[]</span> <span class="token punctuation">{<!-- --></span>1<span class="token punctuation">,</span>2<span class="token punctuation">,</span>3<span class="token punctuation">,</span>4<span class="token punctuation">,</span>5<span class="token punctuation">,</span>6<span class="token punctuation">,</span>7<span class="token punctuation">}</span><span class="token punctuation">;</span>
		ArrayBinaryTree tree = new <span class="token function">ArrayBinaryTree</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		tree.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_2005"></a>线索二叉树</h3> 
<p>线索化二叉树，一个节点的前一个节点，叫前继节点。一个节点的后一个节点，叫后继节点<br> lchild：指向左子树或前驱节点，ltag：标识lchild指向左子树或前驱节点，data，rtag:标识rchild指向右子树或后驱节点，rchild：指向右子树或后驱节点</p> 
<pre><code class="prism language-css">package demo3<span class="token punctuation">;</span>

<span class="token comment">/*
 *线索二叉树
 */</span>
<span class="token selector">public class ThreadedBinaryTree</span> <span class="token punctuation">{<!-- --></span>
	// 根节点
	ThreadedNode root<span class="token punctuation">;</span>
	// 临时存储前驱节点
	ThreadedNode pre = null<span class="token punctuation">;</span>

	<span class="token selector">// 遍历线索二叉树
	public void threadIterate()</span> <span class="token punctuation">{<!-- --></span>
		// 用于临时存储当前遍历节点
		ThreadedNode node = root<span class="token punctuation">;</span>
		<span class="token selector">while (node != null)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">// 循环找到最开始的节点
			while (node.leftType == 0)</span> <span class="token punctuation">{<!-- --></span>
				node = node.leftNode<span class="token punctuation">;</span>

			<span class="token punctuation">}</span>
			// 打印当前节点的值
			System.out.<span class="token function">println</span><span class="token punctuation">(</span>node.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token selector">// 如果当前节点的右指针指向的是后继节点，可能后继节点还有后继节点
			while (node.rightType == 1)</span> <span class="token punctuation">{<!-- --></span>
				node = node.rightNode<span class="token punctuation">;</span>
				System.out.<span class="token function">println</span><span class="token punctuation">(</span>node.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			// 替换遍历的节点
			node = node.rightNode<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 设置根节点
	public void setRoot(ThreadedNode root)</span> <span class="token punctuation">{<!-- --></span>
		this.root = root<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 中序线索化二叉树
	public void threadNodes()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">threadNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public void threadNodes(ThreadedNode node)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// 当前节点如果为null,直接返回
		if (node == null)</span> <span class="token punctuation">{<!-- --></span>
			return<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 处理左子树
		<span class="token function">threadNodes</span><span class="token punctuation">(</span>node.leftNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// 处理前驱节点
		if (node.leftNode == null)</span> <span class="token punctuation">{<!-- --></span>
			// 让当前节点的左指针指向前驱节点
			node.leftNode = null<span class="token punctuation">;</span>
			// 改变当前节点左指针类型
			node.leftType = 1<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 处理前驱的右指针，如果前驱节点的右指针是null（没有指下右子树）
		if (pre != null &amp;&amp; pre.rightNode == null)</span> <span class="token punctuation">{<!-- --></span>
			// 让前驱节点的右指针指向当前节点
			pre.rightNode = node<span class="token punctuation">;</span>
			// 改变前驱节点的右指针
			pre.rightType = 1<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 每处理一个节点，当前节点是下一个节点的前驱结点
		pre = node<span class="token punctuation">;</span>
		// 处理右子树
		<span class="token function">threadNodes</span><span class="token punctuation">(</span>node.rightNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//
	<span class="token punctuation">}</span>

	<span class="token selector">// 获取根节点
	public ThreadedNode getRoot()</span> <span class="token punctuation">{<!-- --></span>
		return root<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public void frontShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (root != null)</span> <span class="token punctuation">{<!-- --></span>
			root.<span class="token function">frontShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public void midShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if (root != null)</span> <span class="token punctuation">{<!-- --></span>
			root.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public void afterShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if (root != null)</span> <span class="token punctuation">{<!-- --></span>
			root.<span class="token function">afterShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public ThreadedNode frontSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		return root.<span class="token function">frontSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public ThreadedNode afterSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		return root.<span class="token function">afterSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public ThreadedNode midSearch(int i)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		return root.<span class="token function">midSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public void delete(int i)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if (root.value == i)</span> <span class="token punctuation">{<!-- --></span>
			root = null<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			root.<span class="token function">delete</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		// 创建一棵树
		ThreadedBinaryTree binTree = new <span class="token function">ThreadedBinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 创建一个根节点
		ThreadedNode root = new <span class="token function">ThreadedNode</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 把根节点赋给树
		binTree.<span class="token function">setRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 创建一个左节点
		ThreadedNode rootL = new <span class="token function">ThreadedNode</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 创建一个右节点
		ThreadedNode rootR = new <span class="token function">ThreadedNode</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 把新创建的结点设置为根节点的子节点
		root.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>rootL<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root.<span class="token function">setRightNode</span><span class="token punctuation">(</span>rootR<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 为第二层的左节点创建俩个子节点
		rootL.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>new <span class="token function">ThreadedNode</span><span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ThreadedNode fiveNode = new <span class="token function">ThreadedNode</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		rootL.<span class="token function">setRightNode</span><span class="token punctuation">(</span>fiveNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 为第二层的右节点创建俩个左节点
		rootR.<span class="token function">setLeftNode</span><span class="token punctuation">(</span>new <span class="token function">ThreadedNode</span><span class="token punctuation">(</span>6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		rootR.<span class="token function">setRightNode</span><span class="token punctuation">(</span>new <span class="token function">ThreadedNode</span><span class="token punctuation">(</span>7<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 中序遍历
		binTree.<span class="token function">midShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 中前线索化二叉树
		binTree.<span class="token function">threadNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 查找五节点
//		ThreadedNode afterFive = fiveNode.rightNode<span class="token punctuation">;</span>
//		System.out.<span class="token function">println</span><span class="token punctuation">(</span>afterFive.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		binTree.<span class="token function">threadIterate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_2167"></a>赫夫曼树</h3> 
<p>也就是最优二叉树，n个带权叶子结点构成的所有二叉树中，带权路径长度最小的二叉树<br> 树的带权路径长度WPL：树中所有叶子结点的带权路径长度之和</p> 
<p>只有度为0和2的节点，n0=n2+1<br> 赫夫曼编码中，一个编码不能是另一个编码的前缀<br> <img src="https://images2.imgbox.com/58/65/dRbR5YUC_o.jpg" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/aa/56/n4JYwUlK_o.jpg" alt="在这里插入图片描述"><br> 1.排序<br> 2.取出根节点权值最小的倆棵二叉树<br> 3.组成一棵新的二叉树，前面取出的两棵二叉树是新二叉树的子树<br> 4.根结点的权值是前面取出的俩棵二叉树根节点权值之和</p> 
<pre><code class="prism language-css">package demo3<span class="token punctuation">;</span>
<span class="token comment">/*
 * 赫夫曼树节点
 */</span>
<span class="token selector">public class Node implements Comparable&lt;Node&gt;</span><span class="token punctuation">{<!-- --></span>
	// 节点的权
		int value<span class="token punctuation">;</span>
		// 左儿子
		Node leftNode<span class="token punctuation">;</span>
		// 右儿子
		Node rightNode<span class="token punctuation">;</span>

		<span class="token selector">public Node(int value)</span> <span class="token punctuation">{<!-- --></span>
			this.value = value<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token atrule"><span class="token rule">@Override</span>
		public int <span class="token function">compareTo</span><span class="token punctuation">(</span>Node o<span class="token punctuation">)</span></span> <span class="token punctuation">{<!-- --></span>
			// TODO Auto-generated method stub
			return <span class="token function">-</span><span class="token punctuation">(</span>this.value-o.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token atrule"><span class="token rule">@Override</span>
		public String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span> <span class="token punctuation">{<!-- --></span>
			return <span class="token string">"Node [value="</span> + value + <span class="token string">"]"</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		
<span class="token punctuation">}</span>

package demo3<span class="token punctuation">;</span>

import java.util.ArrayList<span class="token punctuation">;</span>
import java.util.Collections<span class="token punctuation">;</span>
import java.util.List<span class="token punctuation">;</span>

<span class="token comment">/*
 * 赫夫曼树
 */</span>
<span class="token selector">public class HuffmanTree</span> <span class="token punctuation">{<!-- --></span>
	
	<span class="token selector">//创建赫夫曼树
	public static Node createHuffmanTree(int[] arr)</span> <span class="token punctuation">{<!-- --></span>
		//先使用数组中所有的元素创建若干个二叉树（只有一个节点）
		List&lt;Node&gt; nodes = new ArrayList&lt;&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">for(int value:arr)</span> <span class="token punctuation">{<!-- --></span>
			nodes.<span class="token function">add</span><span class="token punctuation">(</span>new <span class="token function">Node</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">//循环处理
		while(nodes.size()&gt;1)</span> <span class="token punctuation">{<!-- --></span>
			//排序
			Collections.<span class="token function">sort</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//取出权值最小的俩个二叉树
			//取出权值最小的二叉树
			Node left = nodes.<span class="token function">get</span><span class="token punctuation">(</span>nodes.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>-1<span class="token punctuation">)</span><span class="token punctuation">;</span>
			Node right = nodes.<span class="token function">get</span><span class="token punctuation">(</span>nodes.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>-2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//创建一棵新二叉树
			Node parent = new <span class="token function">Node</span><span class="token punctuation">(</span>left.value+right.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//把取出来的二叉树移除
			nodes.<span class="token function">remove</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			nodes.<span class="token function">remove</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//放入原来的二叉树集合中
			nodes.<span class="token function">add</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
			
		<span class="token punctuation">}</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		return nodes.<span class="token function">get</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">int[] arr =</span> <span class="token punctuation">{<!-- --></span>3<span class="token punctuation">,</span>7<span class="token punctuation">,</span>8<span class="token punctuation">,</span>29<span class="token punctuation">,</span>5<span class="token punctuation">,</span>11<span class="token punctuation">,</span>23<span class="token punctuation">,</span>14<span class="token punctuation">}</span><span class="token punctuation">;</span>
		Node node = <span class="token function">createHuffmanTree</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>


</code></pre> 
<h3><a id="_2257"></a>赫夫曼编码</h3> 
<p>定长编码：计算机接收到一句话时首先转成ASCII码，随后转成二进制<br> 非定长编码：计算一句话每个字符出现多少次，出现越少的转换成编码越长，出现越多转换成编码越短。字符的编码不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码<br> <img src="https://images2.imgbox.com/d1/52/ftsQj3LM_o.jpg" alt="在这里插入图片描述"><br> 编码步骤：</p> 
<ol><li>统计字符并排序</li><li>创建赫夫曼树</li><li>创建赫夫曼编码表</li><li>编码</li></ol> 
<pre><code class="prism language-css">package demo3<span class="token punctuation">;</span>

<span class="token comment">/*
 * 赫夫曼编码节点
 */</span>
<span class="token selector">public class Node02 implements Comparable&lt;Node02&gt;</span><span class="token punctuation">{<!-- --></span>
	Byte data<span class="token punctuation">;</span> //Byte封装类型，使其可以为空
	// 节点的权
	int weight<span class="token punctuation">;</span>
	// 左儿子
	Node02 left<span class="token punctuation">;</span>
	// 右儿子
	Node02 right<span class="token punctuation">;</span>

	<span class="token selector">public Node02(Byte data,int weight)</span> <span class="token punctuation">{<!-- --></span>
		this.data = data<span class="token punctuation">;</span>
		this.weight = weight<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

	<span class="token atrule"><span class="token rule">@Override</span>
	public int <span class="token function">compareTo</span><span class="token punctuation">(</span>Node02 o<span class="token punctuation">)</span></span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		return o.weight - this.weight<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token atrule"><span class="token rule">@Override</span>
	public String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span> <span class="token punctuation">{<!-- --></span>
		return <span class="token string">"Node02 [data="</span> + data + <span class="token string">", weight="</span> + weight + <span class="token string">"]"</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

package demo3<span class="token punctuation">;</span>

import java.util.ArrayList<span class="token punctuation">;</span>
import java.util.Arrays<span class="token punctuation">;</span>
import java.util.Collections<span class="token punctuation">;</span>
import java.util.HashMap<span class="token punctuation">;</span>
import java.util.List<span class="token punctuation">;</span>
import java.util.Map<span class="token punctuation">;</span>

<span class="token comment">/*
 * 赫夫曼编码
 */</span>
<span class="token selector">public class HuffmanCode</span> <span class="token punctuation">{<!-- --></span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		String msg = <span class="token string">"can you can a can as a can canner can a can."</span><span class="token punctuation">;</span>
		byte[] bytes = msg.<span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//进行赫夫曼编码压缩
		byte[] b = <span class="token function">huffmanZip</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>bytes.length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>b.length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//使用赫夫曼编码解码
		byte[] newBytes = <span class="token function">decode</span><span class="token punctuation">(</span>huffcodes<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>newBytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>new <span class="token function">String</span><span class="token punctuation">(</span>newBytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token selector">//使用指定的赫夫曼编码表进行解码
	private static byte[] decode(Map&lt;Byte, String&gt; huffcodes, byte[] bytes)</span> <span class="token punctuation">{<!-- --></span>
		StringBuilder sb = new <span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 把byte数组转为一个二进制字符串
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i&lt;bytes.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			//String s = Integer.<span class="token function">toBinaryString</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//System.out.<span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			byte b = bytes[i]<span class="token punctuation">;</span>
			//是否是最后一个
			boolean flag = <span class="token punctuation">(</span>i == bytes.length-1<span class="token punctuation">)</span><span class="token punctuation">;</span>
			sb.<span class="token function">append</span><span class="token punctuation">(</span><span class="token function">byteToBitStr</span><span class="token punctuation">(</span>!flag<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		
		<span class="token punctuation">}</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>sb.<span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//把字符串按照指定的赫夫曼编码进行解码
		//把赫夫曼编码的键值对进行调换
		Map&lt;String<span class="token punctuation">,</span> Byte&gt; map = new HashMap&lt;&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">for(Map.Entry&lt;Byte, String&gt; entry:huffcodes.entrySet())</span> <span class="token punctuation">{<!-- --></span>
			map.<span class="token function">put</span><span class="token punctuation">(</span>entry.<span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entry.<span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//创建一个集合用于存byte数组
		List&lt;Byte&gt; list = new ArrayList&lt;&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//处理字符串
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i&lt;sb.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			int count = 1<span class="token punctuation">;</span>
			boolean flag = true<span class="token punctuation">;</span>
			Byte b = null<span class="token punctuation">;</span>
			<span class="token selector">//截取出一个key
			while(flag)</span> <span class="token punctuation">{<!-- --></span>
				String key = sb.<span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i+count<span class="token punctuation">)</span><span class="token punctuation">;</span>
				b = map.<span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token selector">if(b == null)</span> <span class="token punctuation">{<!-- --></span>
					count++<span class="token punctuation">;</span>
				<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
					flag = false<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			//System.out.<span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//System.out.<span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			list.<span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			i+=count<span class="token punctuation">;</span>
			
		<span class="token punctuation">}</span>
		//把集合转为数组
		byte[] b = new byte[list.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>]<span class="token punctuation">;</span>
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i&lt;b.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			b[i] = list.<span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
		return b<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">private static String byteToBitStr(boolean flag,byte b)</span> <span class="token punctuation">{<!-- --></span>
		int temp = b<span class="token punctuation">;</span>
		<span class="token selector">if(flag)</span> <span class="token punctuation">{<!-- --></span>
			temp |= 256<span class="token punctuation">;</span> //保证非八位二进制能用0补齐成八位二进制
		<span class="token punctuation">}</span>
		String str = Integer.<span class="token function">toBinaryString</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">if(flag)</span> <span class="token punctuation">{<!-- --></span>
			return str.<span class="token function">substring</span><span class="token punctuation">(</span>str.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>-8<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			return str<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
	<span class="token punctuation">}</span>

	<span class="token selector">//进行赫夫曼编码压缩的方法
	private static byte[] huffmanZip(byte[] bytes)</span> <span class="token punctuation">{<!-- --></span>
		// 先统计每一个byte出现的次数，并放入集合中
		List&lt;Node02&gt; nodes = <span class="token function">getNodes</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个赫夫曼树
		Node02 tree  = <span class="token function">createHuffmanTree</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//创建一个赫夫曼编码表
		Map&lt;Byte<span class="token punctuation">,</span>String&gt; huffCodes = <span class="token function">getCodes</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>huffCodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//编码
		byte[] b = <span class="token function">zip</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span>huffcodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		return b<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//进行赫夫曼编码
	private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffcodes)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		StringBuilder sb = new <span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">//把需要压缩的byte数组处理成二进制字符串
		for(byte b:bytes)</span> <span class="token punctuation">{<!-- --></span>
			sb.<span class="token function">append</span><span class="token punctuation">(</span>huffcodes.<span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>sb.<span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//定义长度
		int len<span class="token punctuation">;</span>
		<span class="token selector">if(sb.length()/8 == 0)</span> <span class="token punctuation">{<!-- --></span>
			len = sb.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>/8<span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			len = sb.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>/8+1<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//用于存储压缩后的byte
		byte[] by = new byte[len]<span class="token punctuation">;</span>
		//记录新byte的位置
		int index = 0<span class="token punctuation">;</span>
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i&lt;sb.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i+=8<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			String strByte<span class="token punctuation">;</span>
			<span class="token selector">if(i+8&gt;sb.length())</span> <span class="token punctuation">{<!-- --></span>
				strByte = sb.<span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				strByte = sb.<span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i+8<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			byte byt = <span class="token punctuation">(</span>byte<span class="token punctuation">)</span> Integer.<span class="token function">parseInt</span><span class="token punctuation">(</span>strByte<span class="token punctuation">,</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//System.out.<span class="token function">println</span><span class="token punctuation">(</span>strByte+<span class="token string">":"</span>+byt<span class="token punctuation">)</span><span class="token punctuation">;</span>
			by[index] = byt<span class="token punctuation">;</span>
			index++<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return by<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	//用于临时存储路径
	static StringBuilder sb = new <span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	//用于存储赫夫曼编码
	static Map&lt;Byte<span class="token punctuation">,</span>String&gt; huffcodes = new HashMap&lt;&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token selector">//根据赫夫曼树获取赫夫曼编码
	private static Map&lt;Byte, String&gt; getCodes(Node02 tree)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if(tree == null)</span> <span class="token punctuation">{<!-- --></span>
			return null<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">getCodes</span><span class="token punctuation">(</span>tree.left<span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">,</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">getCodes</span><span class="token punctuation">(</span>tree.right<span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
		return huffcodes<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">private static void getCodes(Node02 node, String code, StringBuilder sb)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		StringBuilder sb2 = new <span class="token function">StringBuilder</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
		sb2.<span class="token function">append</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">if(node.data == null)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">getCodes</span><span class="token punctuation">(</span>node.left<span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">,</span>sb2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">getCodes</span><span class="token punctuation">(</span>node.right<span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span>sb2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			huffcodes.<span class="token function">put</span><span class="token punctuation">(</span>node.data<span class="token punctuation">,</span> sb2.<span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">//创建一个赫夫曼树
	private static Node02 createHuffmanTree(List&lt;Node02&gt; nodes)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		while(nodes.size()&gt;1)</span> <span class="token punctuation">{<!-- --></span>
			//排序
			Collections.<span class="token function">sort</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//取出俩个权值最低的二叉树
			Node02 left = nodes.<span class="token function">get</span><span class="token punctuation">(</span>nodes.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>-1<span class="token punctuation">)</span><span class="token punctuation">;</span>
			Node02 right = nodes.<span class="token function">get</span><span class="token punctuation">(</span>nodes.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>-2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//创建一个新的二叉树
			Node02 parent = new <span class="token function">Node02</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span>left.weight+right.weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//把之前取出的倆棵二叉树设置为新设置的倆棵二叉树的子树
			parent.left = left<span class="token punctuation">;</span>
			parent.right = right<span class="token punctuation">;</span>
			//把前面取出的倆棵二叉树删除
			nodes.<span class="token function">remove</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			nodes.<span class="token function">remove</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//把新创建的二叉树放入集合中
			nodes.<span class="token function">add</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return nodes.<span class="token function">get</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">//把byte数组转成node集合
	private static List&lt;Node02&gt; getNodes(byte[] bytes)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		List&lt;Node02&gt; nodes = new ArrayList&lt;&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//存储每一个byte出现的次数
		Map&lt;Byte<span class="token punctuation">,</span> Integer&gt; counts = new HashMap&lt;&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">//统计每一个byte出现的次数
		for(byte b : bytes)</span> <span class="token punctuation">{<!-- --></span>
			Integer count = counts.<span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token selector">if(count == null)</span> <span class="token punctuation">{<!-- --></span>
				counts.<span class="token function">put</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				counts.<span class="token function">put</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> count+1<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>counts<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">//把每一个键值对转成node对象
		for(Map.Entry&lt;Byte,Integer&gt; entry:counts.entrySet())</span> <span class="token punctuation">{<!-- --></span>
			nodes.<span class="token function">add</span><span class="token punctuation">(</span>new <span class="token function">Node02</span><span class="token punctuation">(</span>entry.<span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>entry.<span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return nodes<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<p>赫夫曼编码压缩解压文件：</p> 
<pre><code class="prism language-css">package demo3<span class="token punctuation">;</span>

import java.io.FileInputStream<span class="token punctuation">;</span>
import java.io.FileNotFoundException<span class="token punctuation">;</span>
import java.io.FileOutputStream<span class="token punctuation">;</span>
import java.io.IOException<span class="token punctuation">;</span>
import java.io.InputStream<span class="token punctuation">;</span>
import java.io.ObjectInputStream<span class="token punctuation">;</span>
import java.io.ObjectOutputStream<span class="token punctuation">;</span>
import java.io.OutputStream<span class="token punctuation">;</span>
import java.util.ArrayList<span class="token punctuation">;</span>
import java.util.Collections<span class="token punctuation">;</span>
import java.util.HashMap<span class="token punctuation">;</span>
import java.util.List<span class="token punctuation">;</span>
import java.util.Map<span class="token punctuation">;</span>

<span class="token comment">/*
 * 赫夫曼编码压缩文件
 */</span>
<span class="token selector">public class HuffmanZipFile</span> <span class="token punctuation">{<!-- --></span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		String src = <span class="token string">"E:/1.bmp"</span><span class="token punctuation">;</span>
		String dst = <span class="token string">"E:/2.zip"</span><span class="token punctuation">;</span>
<span class="token selector">//		try</span> <span class="token punctuation">{<!-- --></span>
//			<span class="token function">zipFile</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
//		<span class="token punctuation">}</span> <span class="token selector">catch (IOException e)</span> <span class="token punctuation">{<!-- --></span>
//			// TODO Auto-generated catch block
//			e.<span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//		<span class="token punctuation">}</span>
		<span class="token selector">try</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">unZip</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token string">"E:/3.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">catch (Exception e)</span> <span class="token punctuation">{<!-- --></span>
			// TODO Auto-generated catch block
			e.<span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 文件的解压
	public static void unZip(String src, String dst) throws Exception</span> <span class="token punctuation">{<!-- --></span>
		// 创建一个输入流
		InputStream is = new <span class="token function">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"E:/2.zip"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ObjectInputStream ois = new <span class="token function">ObjectInputStream</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 读取byte数组
		byte[] b = <span class="token punctuation">(</span>byte[]<span class="token punctuation">)</span> ois.<span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 读取赫夫曼编码表
		Map&lt;Byte<span class="token punctuation">,</span> String&gt; codes = <span class="token punctuation">(</span>Map&lt;Byte<span class="token punctuation">,</span> String&gt;<span class="token punctuation">)</span> ois.<span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ois.<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		is.<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 解码
		byte[] bytes = <span class="token function">decode</span><span class="token punctuation">(</span>codes<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 创建一个输出流
		OutputStream os = new <span class="token function">FileOutputStream</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 写出数据
		os.<span class="token function">write</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		os.<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 压缩文件
	public static void zipFile(String src, String dst) throws IOException</span> <span class="token punctuation">{<!-- --></span>
		// 创建一个输入流
		InputStream is = new <span class="token function">FileInputStream</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 创建一个和输入流指向的文件大小一样的数组
		byte[] b = new byte[is.<span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span>]<span class="token punctuation">;</span>
		// 读取文件内容
		is.<span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		is.<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 使用赫夫曼编码进行编码
		byte[] byteZip = <span class="token function">huffmanZip</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>b.length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>byteZip.length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 输出流
		OutputStream os = new <span class="token function">FileOutputStream</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ObjectOutputStream oos = new <span class="token function">ObjectOutputStream</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 把压缩后的byte数组写入文件
		oos.<span class="token function">writeObject</span><span class="token punctuation">(</span>byteZip<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 把赫夫曼编码表写入文件
		oos.<span class="token function">writeObject</span><span class="token punctuation">(</span>huffcodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		oos.<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		os.<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 使用指定的赫夫曼编码表进行解码
	private static byte[] decode(Map&lt;Byte, String&gt; huffcodes, byte[] bytes)</span> <span class="token punctuation">{<!-- --></span>
		StringBuilder sb = new <span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 把byte数组转为一个二进制字符串
		for <span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span> i &lt; bytes.length<span class="token punctuation">;</span> <span class="token selector">i++)</span> <span class="token punctuation">{<!-- --></span>
			// String s = Integer.<span class="token function">toBinaryString</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			// System.out.<span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			byte b = bytes[i]<span class="token punctuation">;</span>
			// 是否是最后一个
			boolean flag = <span class="token punctuation">(</span>i == bytes.length - 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
			sb.<span class="token function">append</span><span class="token punctuation">(</span><span class="token function">byteToBitStr</span><span class="token punctuation">(</span>!flag<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>sb.<span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 把字符串按照指定的赫夫曼编码进行解码
		// 把赫夫曼编码的键值对进行调换
		Map&lt;String<span class="token punctuation">,</span> Byte&gt; map = new HashMap&lt;&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">for (Map.Entry&lt;Byte, String&gt; entry : huffcodes.entrySet())</span> <span class="token punctuation">{<!-- --></span>
			map.<span class="token function">put</span><span class="token punctuation">(</span>entry.<span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entry.<span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 创建一个集合用于存byte数组
		List&lt;Byte&gt; list = new ArrayList&lt;&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 处理字符串
		for <span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span> i &lt; sb.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			int count = 1<span class="token punctuation">;</span>
			boolean flag = true<span class="token punctuation">;</span>
			Byte b = null<span class="token punctuation">;</span>
			<span class="token selector">// 截取出一个key
			while (flag)</span> <span class="token punctuation">{<!-- --></span>
				String key = sb.<span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i + count<span class="token punctuation">)</span><span class="token punctuation">;</span>
				b = map.<span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token selector">if (b == null)</span> <span class="token punctuation">{<!-- --></span>
					count++<span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
					flag = false<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			// System.out.<span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
			// System.out.<span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			list.<span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			i += count<span class="token punctuation">;</span>

		<span class="token punctuation">}</span>
		// 把集合转为数组
		byte[] b = new byte[list.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>]<span class="token punctuation">;</span>
		for <span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span> i &lt; b.length<span class="token punctuation">;</span> <span class="token selector">i++)</span> <span class="token punctuation">{<!-- --></span>
			b[i] = list.<span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
		return b<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">private static String byteToBitStr(boolean flag, byte b)</span> <span class="token punctuation">{<!-- --></span>
		int temp = b<span class="token punctuation">;</span>
		<span class="token selector">if (flag)</span> <span class="token punctuation">{<!-- --></span>
			temp |= 256<span class="token punctuation">;</span> // 保证非八位二进制能用0补齐成八位二进制
		<span class="token punctuation">}</span>
		String str = Integer.<span class="token function">toBinaryString</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">if (flag)</span> <span class="token punctuation">{<!-- --></span>
			return str.<span class="token function">substring</span><span class="token punctuation">(</span>str.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> - 8<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			return str<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 进行赫夫曼编码压缩的方法
	private static byte[] huffmanZip(byte[] bytes)</span> <span class="token punctuation">{<!-- --></span>
		// 先统计每一个byte出现的次数，并放入集合中
		List&lt;Node02&gt; nodes = <span class="token function">getNodes</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 创建一个赫夫曼树
		Node02 tree = <span class="token function">createHuffmanTree</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 创建一个赫夫曼编码表
		Map&lt;Byte<span class="token punctuation">,</span> String&gt; huffCodes = <span class="token function">getCodes</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>huffCodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 编码
		byte[] b = <span class="token function">zip</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> huffcodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		return b<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 进行赫夫曼编码
	private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffcodes)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		StringBuilder sb = new <span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// 把需要压缩的byte数组处理成二进制字符串
		for (byte b : bytes)</span> <span class="token punctuation">{<!-- --></span>
			sb.<span class="token function">append</span><span class="token punctuation">(</span>huffcodes.<span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>sb.<span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 定义长度
		int len<span class="token punctuation">;</span>
		<span class="token selector">if (sb.length() / 8 == 0)</span> <span class="token punctuation">{<!-- --></span>
			len = sb.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> / 8<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			len = sb.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> / 8 + 1<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 用于存储压缩后的byte
		byte[] by = new byte[len]<span class="token punctuation">;</span>
		// 记录新byte的位置
		int index = 0<span class="token punctuation">;</span>
		for <span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span> i &lt; sb.<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token selector">i += 8)</span> <span class="token punctuation">{<!-- --></span>
			String strByte<span class="token punctuation">;</span>
			<span class="token selector">if (i + 8 &gt; sb.length())</span> <span class="token punctuation">{<!-- --></span>
				strByte = sb.<span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				strByte = sb.<span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i + 8<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			byte byt = <span class="token punctuation">(</span>byte<span class="token punctuation">)</span> Integer.<span class="token function">parseInt</span><span class="token punctuation">(</span>strByte<span class="token punctuation">,</span> 2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			// System.out.<span class="token function">println</span><span class="token punctuation">(</span>strByte+<span class="token string">":"</span>+byt<span class="token punctuation">)</span><span class="token punctuation">;</span>
			by[index] = byt<span class="token punctuation">;</span>
			index++<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return by<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	// 用于临时存储路径
	static StringBuilder sb = new <span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	// 用于存储赫夫曼编码
	static Map&lt;Byte<span class="token punctuation">,</span> String&gt; huffcodes = new HashMap&lt;&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token selector">// 根据赫夫曼树获取赫夫曼编码
	private static Map&lt;Byte, String&gt; getCodes(Node02 tree)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if (tree == null)</span> <span class="token punctuation">{<!-- --></span>
			return null<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">getCodes</span><span class="token punctuation">(</span>tree.left<span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">getCodes</span><span class="token punctuation">(</span>tree.right<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
		return huffcodes<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">private static void getCodes(Node02 node, String code, StringBuilder sb)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		StringBuilder sb2 = new <span class="token function">StringBuilder</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
		sb2.<span class="token function">append</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">if (node.data == null)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">getCodes</span><span class="token punctuation">(</span>node.left<span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">,</span> sb2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">getCodes</span><span class="token punctuation">(</span>node.right<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> sb2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			huffcodes.<span class="token function">put</span><span class="token punctuation">(</span>node.data<span class="token punctuation">,</span> sb2.<span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 创建一个赫夫曼树
	private static Node02 createHuffmanTree(List&lt;Node02&gt; nodes)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		while (nodes.size() &gt; 1)</span> <span class="token punctuation">{<!-- --></span>
			// 排序
			Collections.<span class="token function">sort</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
			// 取出俩个权值最低的二叉树
			Node02 left = nodes.<span class="token function">get</span><span class="token punctuation">(</span>nodes.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> - 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
			Node02 right = nodes.<span class="token function">get</span><span class="token punctuation">(</span>nodes.<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> - 2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			// 创建一个新的二叉树
			Node02 parent = new <span class="token function">Node02</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> left.weight + right.weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
			// 把之前取出的倆棵二叉树设置为新设置的倆棵二叉树的子树
			parent.left = left<span class="token punctuation">;</span>
			parent.right = right<span class="token punctuation">;</span>
			// 把前面取出的倆棵二叉树删除
			nodes.<span class="token function">remove</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			nodes.<span class="token function">remove</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
			// 把新创建的二叉树放入集合中
			nodes.<span class="token function">add</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return nodes.<span class="token function">get</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 把byte数组转成node集合
	private static List&lt;Node02&gt; getNodes(byte[] bytes)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		List&lt;Node02&gt; nodes = new ArrayList&lt;&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 存储每一个byte出现的次数
		Map&lt;Byte<span class="token punctuation">,</span> Integer&gt; counts = new HashMap&lt;&gt;<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// 统计每一个byte出现的次数
		for (byte b : bytes)</span> <span class="token punctuation">{<!-- --></span>
			Integer count = counts.<span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token selector">if (count == null)</span> <span class="token punctuation">{<!-- --></span>
				counts.<span class="token function">put</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				counts.<span class="token function">put</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> count + 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>counts<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// 把每一个键值对转成node对象
		for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet())</span> <span class="token punctuation">{<!-- --></span>
			nodes.<span class="token function">add</span><span class="token punctuation">(</span>new <span class="token function">Node02</span><span class="token punctuation">(</span>entry.<span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entry.<span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return nodes<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="BST_2794"></a>二叉排序树（二叉搜索树、BST）</h3> 
<p>线性结构：<br> 顺序存储、不排序：查找困难<br> 顺序存储，排序：删除插入困难<br> 链式存储：无论是否排序，查找困难<br> 二叉查找树：对于二叉树中任何一个非叶子结点，要求左子节点比当前节点值小，右子节点比当前节点值大<br> 二叉树是一种动态查找表。查找效率较高。<br> 树的结构不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的结点时再进行插入。新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。所以二叉查找树不存在相同的节点。<br> 根节点的前趋节点是左子树的最大的那个节点，后继节点是右子树最小的那个节点，删除根节点时需要将根节点的后继节点删除，把后继节点的值替换根节点。如果根节点的后继节点存在子节点（一定是右子节点），则在删除后继节点后，将后继节点的子节点替换后继节点。有俩个子节点的节点删除同理。<br> 删除操作三种情况：<br> 1）若被删除节点Z是叶节点直接删除<br> 2）若节点z只有一棵左子树或右子树，则让z的子树成为z父节点的子树，替代z的位置<br> 3）若节点z有左右俩棵子树，则令z的直接后继（或直接前驱）替代z,然后从二叉排序树中删除这个直接后继（或直接前驱），转换成第一二种情况<br> 左右子树高度之差绝对值不超过1，平均查找长度为（O（log（底为2）n）），单支树平均查找长度O（n）<br> 最理想的深度为log以2为底（n+1）<br> 若有序表是动态查找表，选择二叉排序树为逻辑结构</p> 
<pre><code class="prism language-css">package demo3<span class="token punctuation">;</span>

<span class="token comment">/*
 * 二叉排序树
 */</span>
<span class="token selector">public class Node03</span> <span class="token punctuation">{<!-- --></span>
	int value<span class="token punctuation">;</span>
	Node03 left<span class="token punctuation">;</span>
	Node03 right<span class="token punctuation">;</span>

	<span class="token selector">public Node03(int value)</span> <span class="token punctuation">{<!-- --></span>
		this.value = value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 向子树中添加节点
	public void add(Node03 node)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if (node == null)</span> <span class="token punctuation">{<!-- --></span>
			return<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 判断传入的节点值比当前子树的根节点的值是大还是小
		// 添加节点比当前节点值小
		if (node.value &lt; this.value)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">// 如果子节点为空
			if (this.left == null)</span> <span class="token punctuation">{<!-- --></span>
				this.left = node<span class="token punctuation">;</span>
				// 如果不为空
			<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				this.left.<span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">// 如果右节点为空
			if (this.right == null)</span> <span class="token punctuation">{<!-- --></span>
				this.right = node<span class="token punctuation">;</span>
				// 如果不为空
			<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				this.right.<span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 中序遍历二叉排序树，结果是从小到大的
	public void middleShow(Node03 node)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if (node == null)</span> <span class="token punctuation">{<!-- --></span>
			return<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">middleShow</span><span class="token punctuation">(</span>node.left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>node.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">middleShow</span><span class="token punctuation">(</span>node.right<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 查找节点
	public Node03 search(int value)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if (this.value == value)</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else if (value &lt; this.value)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">if (left == null)</span> <span class="token punctuation">{<!-- --></span>
				return null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			return left.<span class="token function">search</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">if (right == null)</span> <span class="token punctuation">{<!-- --></span>
				return null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			return right.<span class="token function">search</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 搜索父节点
	public Node03 searchParent(int value)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value))</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">if (this.value &gt; value &amp;&amp; this.left != null)</span> <span class="token punctuation">{<!-- --></span>
				return this.left.<span class="token function">searchParent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token selector">else if (this.value &lt; value &amp;&amp; this.right != null)</span> <span class="token punctuation">{<!-- --></span>
				return this.right.<span class="token function">searchParent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		return null<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

package demo3<span class="token punctuation">;</span>

<span class="token comment">/*
 * 二叉排序树
 */</span>
<span class="token selector">public class BinarySortTree</span> <span class="token punctuation">{<!-- --></span>
	Node03 root<span class="token punctuation">;</span>

	<span class="token selector">// 向二叉排序树添加节点
	public void add(Node03 node)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// 如果是一棵空树
		if (root == null)</span> <span class="token punctuation">{<!-- --></span>
			root = node<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			root.<span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public void middleShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (root != null)</span> <span class="token punctuation">{<!-- --></span>
			root.<span class="token function">middleShow</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public Node03 search(int value)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (root == null)</span> <span class="token punctuation">{<!-- --></span>
			return null<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			return root.<span class="token function">search</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 删除节点
	public void delete(int value)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (root == null)</span> <span class="token punctuation">{<!-- --></span>
			return<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			// 找到这个节点
			Node03 target = <span class="token function">search</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token selector">// 如果没有这个节点
			if (target == null)</span> <span class="token punctuation">{<!-- --></span>
				return<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			// 找到他的父节点
			Node03 parent = <span class="token function">searchParent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token selector">// 要删除的节点是叶子结点
			if (target.left == null &amp;&amp; target.right == null)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">// 要删除的节点是父节点的左子节点
				if (parent.left.value == value)</span> <span class="token punctuation">{<!-- --></span>
					parent.left = null<span class="token punctuation">;</span>
					// 要删除的节点是父节点的右子节点
				<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
					parent.right = null<span class="token punctuation">;</span>

				<span class="token punctuation">}</span>
				// 要删除的节点有俩个子节点
			<span class="token punctuation">}</span> <span class="token selector">else if (target.left != null &amp;&amp; target.right != null)</span> <span class="token punctuation">{<!-- --></span>
				// 删除右子树中值最小的节点，获取该节点的值
				int min = <span class="token function">deleteMin</span><span class="token punctuation">(</span>target.right<span class="token punctuation">)</span><span class="token punctuation">;</span>
				// 替换目标节点中的值
				target.value = min<span class="token punctuation">;</span>
				// 要删除的节点有一个左子节点或者右子节点
			<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">// 有左子节点
				if (target.left != null)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token selector">// 要删除的节点是父节点的左子节点
					if (parent.left.value == value)</span> <span class="token punctuation">{<!-- --></span>
						parent.left = target.left<span class="token punctuation">;</span>
						// 要删除的节点是父节点的右子节点
					<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
						parent.right = target.left<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					// 有右子节点
				<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
					<span class="token selector">// 要删除的节点是父节点的左子节点
					if (parent.left.value == value)</span> <span class="token punctuation">{<!-- --></span>
						parent.left = target.right<span class="token punctuation">;</span>
						// 要删除的节点是父节点的右子节点
					<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
						parent.right = target.right<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 删除一棵树中最小的节点
	private int deleteMin(Node03 node)</span> <span class="token punctuation">{<!-- --></span>
		Node03 target = node<span class="token punctuation">;</span>
		<span class="token selector">// 循环向左找
		while (target.left != null)</span> <span class="token punctuation">{<!-- --></span>
			target = target.left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 删除最小的节点
		<span class="token function">delete</span><span class="token punctuation">(</span>target.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		return target.value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 搜索父节点
	public Node03 searchParent(int value)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (root == null)</span> <span class="token punctuation">{<!-- --></span>
			return null<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			return root.<span class="token function">searchParent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

	<span class="token punctuation">}</span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span> 7<span class="token punctuation">,</span> 3<span class="token punctuation">,</span> 10<span class="token punctuation">,</span> 12<span class="token punctuation">,</span> 5<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 9 <span class="token punctuation">}</span><span class="token punctuation">;</span>
		// 创建一个二叉排序树
		BinarySortTree bst = new <span class="token function">BinarySortTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// 循环添加
		for (int i : arr)</span> <span class="token punctuation">{<!-- --></span>
			bst.<span class="token function">add</span><span class="token punctuation">(</span>new <span class="token function">Node03</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 查看树中的值
		// bst.<span class="token function">middleShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 查找
		// Node03 node = bst.<span class="token function">search</span><span class="token punctuation">(</span>10<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>node.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// Node03 node02 = bst.<span class="token function">search</span><span class="token punctuation">(</span>101<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>node02<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// Node03 p1 = bst.<span class="token function">searchParent</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// System.out.<span class="token function">println</span><span class="token punctuation">(</span>p1.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 删除叶子结点
//		bst.<span class="token function">delete</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
//		bst.<span class="token function">middleShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//		System.out.<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 删除只有一个子节点的节点
//		bst.<span class="token function">delete</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>
//		bst.<span class="token function">middleShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//删除有俩个子节点的节点
		bst.<span class="token function">delete</span><span class="token punctuation">(</span>7<span class="token punctuation">)</span><span class="token punctuation">;</span>
		bst.<span class="token function">middleShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="AVL_3043"></a>平衡二叉树（AVL树）</h3> 
<p>任何一颗子树而言，左子树与右子树的高度差不超过1，保证查找效率<br> 节点数公式：Cn=C(n-1)+C(n-2)+1<br> 单旋转：<br> <strong>左左无右：</strong><br> <img src="https://images2.imgbox.com/8a/51/schw5C02_o.png" alt="在这里插入图片描述"><br> 变成↓<br> <img src="https://images2.imgbox.com/a6/65/qoMq0NJV_o.png" alt="在这里插入图片描述"><br> <strong>左左有右</strong><br> <img src="https://images2.imgbox.com/d5/d9/anvPaOhI_o.png" alt="在这里插入图片描述"><br> 变成↓<br> <img src="https://images2.imgbox.com/6d/31/ezJ9elIk_o.png" alt="在这里插入图片描述"><br> <strong>左左左右（鬼畜取名）</strong><br> <img src="https://images2.imgbox.com/38/3c/Lr5fQzGy_o.png" alt="在这里插入图片描述"><br> 第一步↓</p> 
<p><img src="https://images2.imgbox.com/43/82/RlxslXpI_o.png" alt="在这里插入图片描述"><br> 第二步↓<br> <img src="https://images2.imgbox.com/6a/16/zO61xrdr_o.png" alt="在这里插入图片描述"><br> 右旋转步骤：</p> 
<ol><li>创建一个新节点，值等于当前节点的值</li><li>把新节点的右子树设置为当前节点的右子树</li><li>把新节点的左子树设置为当前节点的左子树的右子树</li><li>把当前节点的值换为左子节点的值</li><li>把当前节点的左子树设置为左子树的左子树</li><li>把当前节点的右子树设置为新节点</li></ol> 
<p><strong>双旋转：</strong><br> 当左边的左子树高度&lt;右边的左子树高度<br> <img src="https://images2.imgbox.com/79/cc/XhdY5KjL_o.png" alt="在这里插入图片描述"><br> 分成俩个部分：<br> <img src="https://images2.imgbox.com/ae/dd/6xKexWnM_o.png" alt="在这里插入图片描述"></p> 
<p>左边的进行左旋转<br> <img src="https://images2.imgbox.com/3e/9d/CJfY9ZzN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e9/67/EduWMCHt_o.png" alt="在这里插入图片描述"><br> 然后整体进行右旋转<br> <img src="https://images2.imgbox.com/bd/35/HzIrF57M_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ba/5e/Xqzr53J0_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-css">package demo3<span class="token punctuation">;</span>

<span class="token comment">/*
 * 平衡二叉树
 */</span>
<span class="token selector">public class Node04</span> <span class="token punctuation">{<!-- --></span>
	int value<span class="token punctuation">;</span>
	Node04 left<span class="token punctuation">;</span>
	Node04 right<span class="token punctuation">;</span>

	<span class="token selector">public Node04(int value)</span> <span class="token punctuation">{<!-- --></span>
		this.value = value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 返回当前节点高度
	public int height()</span> <span class="token punctuation">{<!-- --></span>
		return Math.<span class="token function">max</span><span class="token punctuation">(</span>left == null ? 0 <span class="token punctuation">:</span> left.<span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> right == null ? 0 <span class="token punctuation">:</span> right.<span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> + 1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 获取左子树的高度
	public int leftHeight()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (left == null)</span> <span class="token punctuation">{<!-- --></span>
			return 0<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return left.<span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 获取右子树的高度
	public int rightHeight()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (right == null)</span> <span class="token punctuation">{<!-- --></span>
			return 0<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		return right.<span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 向子树中添加节点
	public void add(Node04 node)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if (node == null)</span> <span class="token punctuation">{<!-- --></span>
			return<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 判断传入的节点值比当前子树的根节点的值是大还是小
		// 添加节点比当前节点值小
		if (node.value &lt; this.value)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">// 如果子节点为空
			if (this.left == null)</span> <span class="token punctuation">{<!-- --></span>
				this.left = node<span class="token punctuation">;</span>
				// 如果不为空
			<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				this.left.<span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">// 如果右节点为空
			if (this.right == null)</span> <span class="token punctuation">{<!-- --></span>
				this.right = node<span class="token punctuation">;</span>
				// 如果不为空
			<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				this.right.<span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 检查是否平衡
		if (leftHeight() - rightHeight() &gt;= 2)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">//双旋转
			if(left!=null &amp;&amp; left.leftHeight()&lt;left.rightHeight())</span> <span class="token punctuation">{<!-- --></span>
				//先左旋转
				left.<span class="token function">leftRotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				//再右旋转
				<span class="token function">rightRotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			// 进行右旋转
			<span class="token function">rightRotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token selector">// 左旋转
		if (leftHeight() - rightHeight() &lt;= -2)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">//双旋转
			if(right!=null &amp;&amp; right.rightHeight()&lt;right.leftHeight())</span> <span class="token punctuation">{<!-- --></span>
				right.<span class="token function">rightRotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">leftRotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">leftRotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">//左旋转
	private void leftRotate()</span> <span class="token punctuation">{<!-- --></span>
		Node04 newLeft = new <span class="token function">Node04</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		newLeft.left = left<span class="token punctuation">;</span>
		newLeft.right = right.left<span class="token punctuation">;</span>
		value = right.value<span class="token punctuation">;</span>
		right = right.right<span class="token punctuation">;</span>
		left = newLeft<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 右旋转
	private void rightRotate()</span> <span class="token punctuation">{<!-- --></span>
		// 创建一个新的节点，值等于当前节点的值
		Node04 newRight = new <span class="token function">Node04</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		// 把新节点的右子树设置为当前节点的右子树
		newRight.right = right<span class="token punctuation">;</span>
		// 把新节点的左子树设置为当前节点的左子树的右子树
		newRight.left = left.right<span class="token punctuation">;</span>
		// 把当前节点的值换为左子节点的值
		value = left.value<span class="token punctuation">;</span>
		// 把当前节点的左子树设置为左子树的左子树
		left = left.left<span class="token punctuation">;</span>
		// 把当前节点的右子树设置为新节点
		right = newRight<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 中序遍历二叉排序树，结果是从小到大的
	public void middleShow(Node04 node)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if (node == null)</span> <span class="token punctuation">{<!-- --></span>
			return<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">middleShow</span><span class="token punctuation">(</span>node.left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>node.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">middleShow</span><span class="token punctuation">(</span>node.right<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token selector">// 查找节点
	public Node04 search(int value)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if (this.value == value)</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else if (value &lt; this.value)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">if (left == null)</span> <span class="token punctuation">{<!-- --></span>
				return null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			return left.<span class="token function">search</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">if (right == null)</span> <span class="token punctuation">{<!-- --></span>
				return null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			return right.<span class="token function">search</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 搜索父节点
	public Node04 searchParent(int value)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// TODO Auto-generated method stub
		if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value))</span> <span class="token punctuation">{<!-- --></span>
			return this<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">if (this.value &gt; value &amp;&amp; this.left != null)</span> <span class="token punctuation">{<!-- --></span>
				return this.left.<span class="token function">searchParent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token selector">else if (this.value &lt; value &amp;&amp; this.right != null)</span> <span class="token punctuation">{<!-- --></span>
				return this.right.<span class="token function">searchParent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		return null<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>


package demo3<span class="token punctuation">;</span>

<span class="token comment">/*
 * 平衡二叉树
 */</span>
<span class="token selector">public class BBinaryTree</span> <span class="token punctuation">{<!-- --></span>
	Node04 root<span class="token punctuation">;</span>

	<span class="token selector">// 向二叉排序树添加节点
	public void add(Node04 node)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">// 如果是一棵空树
		if (root == null)</span> <span class="token punctuation">{<!-- --></span>
			root = node<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			root.<span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public void middleShow()</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (root != null)</span> <span class="token punctuation">{<!-- --></span>
			root.<span class="token function">middleShow</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public Node04 search(int value)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (root == null)</span> <span class="token punctuation">{<!-- --></span>
			return null<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			return root.<span class="token function">search</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 删除节点
	public void delete(int value)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (root == null)</span> <span class="token punctuation">{<!-- --></span>
			return<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			// 找到这个节点
			Node04 target = <span class="token function">search</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token selector">// 如果没有这个节点
			if (target == null)</span> <span class="token punctuation">{<!-- --></span>
				return<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			// 找到他的父节点
			Node04 parent = <span class="token function">searchParent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token selector">// 要删除的节点是叶子结点
			if (target.left == null &amp;&amp; target.right == null)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">// 要删除的节点是父节点的左子节点
				if (parent.left.value == value)</span> <span class="token punctuation">{<!-- --></span>
					parent.left = null<span class="token punctuation">;</span>
					// 要删除的节点是父节点的右子节点
				<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
					parent.right = null<span class="token punctuation">;</span>

				<span class="token punctuation">}</span>
				// 要删除的节点有俩个子节点
			<span class="token punctuation">}</span> <span class="token selector">else if (target.left != null &amp;&amp; target.right != null)</span> <span class="token punctuation">{<!-- --></span>
				// 删除右子树中值最小的节点，获取该节点的值
				int min = <span class="token function">deleteMin</span><span class="token punctuation">(</span>target.right<span class="token punctuation">)</span><span class="token punctuation">;</span>
				// 替换目标节点中的值
				target.value = min<span class="token punctuation">;</span>
				// 要删除的节点有一个左子节点或者右子节点
			<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">// 有左子节点
				if (target.left != null)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token selector">// 要删除的节点是父节点的左子节点
					if (parent.left.value == value)</span> <span class="token punctuation">{<!-- --></span>
						parent.left = target.left<span class="token punctuation">;</span>
						// 要删除的节点是父节点的右子节点
					<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
						parent.right = target.left<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					// 有右子节点
				<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
					<span class="token selector">// 要删除的节点是父节点的左子节点
					if (parent.left.value == value)</span> <span class="token punctuation">{<!-- --></span>
						parent.left = target.right<span class="token punctuation">;</span>
						// 要删除的节点是父节点的右子节点
					<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
						parent.right = target.right<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 删除一棵树中最小的节点
	private int deleteMin(Node04 node)</span> <span class="token punctuation">{<!-- --></span>
		Node04 target = node<span class="token punctuation">;</span>
		<span class="token selector">// 循环向左找
		while (target.left != null)</span> <span class="token punctuation">{<!-- --></span>
			target = target.left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		// 删除最小的节点
		<span class="token function">delete</span><span class="token punctuation">(</span>target.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		return target.value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">// 搜索父节点
	public Node04 searchParent(int value)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">if (root == null)</span> <span class="token punctuation">{<!-- --></span>
			return null<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{<!-- --></span>
			return root.<span class="token function">searchParent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

	<span class="token punctuation">}</span>

	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token selector">//int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span> 8<span class="token punctuation">,</span>9<span class="token punctuation">,</span>6<span class="token punctuation">,</span>7<span class="token punctuation">,</span>5<span class="token punctuation">,</span>4 <span class="token punctuation">}</span><span class="token selector">;
		//int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span> 2<span class="token punctuation">,</span>1<span class="token punctuation">,</span>4<span class="token punctuation">,</span>3<span class="token punctuation">,</span>5<span class="token punctuation">,</span>6 <span class="token punctuation">}</span><span class="token selector">;
		int[] arr = new int[]</span> <span class="token punctuation">{<!-- --></span> 8<span class="token punctuation">,</span>9<span class="token punctuation">,</span>5<span class="token punctuation">,</span>4<span class="token punctuation">,</span>6<span class="token punctuation">,</span>7 <span class="token punctuation">}</span><span class="token punctuation">;</span>
		// 创建一个二叉排序树
		BBinaryTree bst = new <span class="token function">BBinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">// 循环添加
		for (int i : arr)</span> <span class="token punctuation">{<!-- --></span>
			bst.<span class="token function">add</span><span class="token punctuation">(</span>new <span class="token function">Node04</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//查看高度
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>bst.root.<span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>bst.root.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>bst.root.<span class="token function">leftHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//System.out.<span class="token function">println</span><span class="token punctuation">(</span>bst.root.<span class="token function">rightHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_3373"></a>多路查找树</h3> 
<p>内存存储：<br> 优点：使用电信号来保存信息，不存在机器操作，所以访问速度很快<br> 缺点：造价高，断电后数据丢失，一般作为CPU的高速缓存<br> B树的大部分操作所需的磁盘存取个数与B树的高度成正比<br> B树中所有的叶节点都在同一层<br> 2-3树： 可以有俩个子节点的节点叫二节点，二节点要么有俩个节点要么没有节点，可以有三个子节点的节点叫三节点，三节点要么有三个节点要么没有节点<br> B树的阶： 2-3树阶是3,2-3-4树阶是4<br> B树的查找：<br> 1.在B树找节点<br> 2.在节点内找关键字，由于B树存储在磁盘内，因此前一个查找操作时在磁盘上进行的，后一个查找操作是在内存中进行的，即找到目标节点中，先将节点信息读入内存，然后在节点内采用顺序查找法或折半查找法<br> B树的插入：<br> 复杂<br> 1.定位，利用B树查找算法，插入位置一定在最底层的某个非叶节点<br> 2.插入，溢出进行分裂<br> B树的删除：<br> 1.直接删除<br> 2.兄弟够借<br> 3.兄弟不够借，需合并<br> 节点的孩子个数=关键字个数+1</p> 
<p>B+树：<br> 非叶节点只存储引索信息，不存储数据<br> 叶子结点最右边的指针指向下一个相邻的叶节点，所有叶节点组成了一个有序链表</p> 
<p>B树与B+树的主要区别：</p> 
<ol><li>在B+树中，具有n个关键字节点只含有n棵子树，即每个关键字对应一颗子树，而在B树中，具有n个关键字的节点含有n+1个子树</li><li>在B+树中，每个结点的关键字个数n的范围是【m/2】&lt;=n&lt;=m，B树中，每个结点的关键字个数n的范围是【m/2】-1&lt;=n&lt;=m-1</li><li>在B+树中，叶节点包含信息，非叶节点仅起到了索引作用，非叶节点的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址</li><li>在B+树中，叶节点包含了全部关键字，非叶节点出现的关键字也会出现在叶节点中，而在B树中，叶节点包含的关键字和其他节点包含的关键字是不重复的<br> <img src="https://images2.imgbox.com/2a/54/wKP3hMRA_o.png" alt="在这里插入图片描述"></li></ol> 
<h2><a id="_3404"></a>哈希表（散列表）</h2> 
<p>建立了关键字和存储地址间的直接映射关系，一个萝卜一个坑，先挖有序坑（散列函数），再填萝卜（整条数据）<br> 设计俩个原则：计算简单 分布均匀<br> 设计方法：</p> 
<ol><li>直接定址法：直接把关键字作为地址</li><li>数字分析法</li><li>平方取中法：数据为13,13*13=169，将13放在第6个位置</li><li>取余法（常用）：13%10=3，将13放在第3个位置</li><li>随机数法：random()</li></ol> 
<p>散列冲突的解决方案：<br> 开放地址法：<br> 在地址后面再找一个地址存储重复值</p> 
<ol><li>线性探测法：找后面的第一个空余位</li><li>二次探测法：重复的数据放在 （当前地址平方+当前地址 ）存储</li><li>再哈希法：第一个散列函数后重复后，进行第二个散列函数，第二个重复后进行第三个<br> 链地址法（多数）：数组＋链表</li></ol> 
<pre><code class="prism language-css">package demo4<span class="token punctuation">;</span>
<span class="token comment">/*
 * 散列表学生信息
 */</span>
<span class="token selector">public class StuInfo</span> <span class="token punctuation">{<!-- --></span>
	private int age<span class="token punctuation">;</span>
	private int count<span class="token punctuation">;</span>
	<span class="token selector">public int getAge()</span> <span class="token punctuation">{<!-- --></span>
		return age<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public StuInfo(int age, int count)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		this.age = age<span class="token punctuation">;</span>
		this.count = count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public void setAge(int age)</span> <span class="token punctuation">{<!-- --></span>
		this.age = age<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public int getCount()</span> <span class="token punctuation">{<!-- --></span>
		return count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public void setCount(int count)</span> <span class="token punctuation">{<!-- --></span>
		this.count = count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public int hashCode()</span> <span class="token punctuation">{<!-- --></span>
		return age<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public StuInfo(int age)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		this.age = age<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token atrule"><span class="token rule">@Override</span>
	public String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span> <span class="token punctuation">{<!-- --></span>
		return <span class="token string">"StuInfo [age="</span> + age + <span class="token string">", count="</span> + count + <span class="token string">"]"</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

package demo4<span class="token punctuation">;</span>
<span class="token comment">/*
 * 散列表直接定址法
 */</span>
<span class="token selector">public class HashTable</span> <span class="token punctuation">{<!-- --></span>
	private StuInfo[] data = new StuInfo[100]<span class="token punctuation">;</span>
	<span class="token selector">//想散列表中添加数据
	public void put(StuInfo stuInfo)</span> <span class="token punctuation">{<!-- --></span>
		//调用散列函数获取存储位置
		int index = stuInfo.<span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		//添加元素
		data[index] = stuInfo<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public StuInfo get(StuInfo stuInfo)</span> <span class="token punctuation">{<!-- --></span>
		return data[stuInfo.<span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>]<span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		StuInfo s1 = new <span class="token function">StuInfo</span><span class="token punctuation">(</span>16<span class="token punctuation">,</span> 3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		StuInfo s2 = new <span class="token function">StuInfo</span><span class="token punctuation">(</span>17<span class="token punctuation">,</span> 11<span class="token punctuation">)</span><span class="token punctuation">;</span>
		StuInfo s3 = new <span class="token function">StuInfo</span><span class="token punctuation">(</span>18<span class="token punctuation">,</span> 23<span class="token punctuation">)</span><span class="token punctuation">;</span>
		StuInfo s4 = new <span class="token function">StuInfo</span><span class="token punctuation">(</span>19<span class="token punctuation">,</span> 24<span class="token punctuation">)</span><span class="token punctuation">;</span>
		StuInfo s5 = new <span class="token function">StuInfo</span><span class="token punctuation">(</span>20<span class="token punctuation">,</span> 9<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		HashTable ht = new <span class="token function">HashTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ht.<span class="token function">put</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ht.<span class="token function">put</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ht.<span class="token function">put</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ht.<span class="token function">put</span><span class="token punctuation">(</span>s4<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ht.<span class="token function">put</span><span class="token punctuation">(</span>s5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		//想要获取的目标数据
		StuInfo target = new <span class="token function">StuInfo</span><span class="token punctuation">(</span>18<span class="token punctuation">)</span><span class="token punctuation">;</span>
		StuInfo info = ht.<span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<h2><a id="_3502"></a>图形结构</h2> 
<p>顶点 边<br> 邻接表：每个顶点与其他顶点是否联通，上左为顶点，01标识是否联通<br> 深度优先搜索算法 类似栈<br> 广度优先搜索算法 类似队列<br> 有向图：E={&lt;1,2&gt;,&lt;2,1&gt;}<br> 无向图：E={（1,3),(1,2）}<br> 若一个无向图<br> 完全无向图：n(n-1)/2<br> 完全有向图：n（n-1）<br> 强联通：有顶点v,w，v到w和w到v都有路径<br> 度：无向图依附于顶点v的边的条数<br> 入度：有向图以顶点v为终点的有向边的数目<br> 出度：有向图以顶点v为起点的有向边的数目<br> 带全图/网：边上有数值<br> 简单路径：路径系列中，顶点不重复</p> 
<p>存储结构：<br> 临接矩阵：<br> 唯一<br> A[i][j]=1(是边，出度)/0（不是边）<br> A[i][j]=w(ij)(是边，放权值)/0或无穷（不是边）<br> 无向图额邻接矩阵为对称矩阵，可压缩存储，空间复杂度为O（n^2）<br> 无向图，邻接矩阵第i行/列非0元素个数是顶点i的度<br> 有向图，邻接矩阵第i行非0元素个数是顶点i的出度，第i列非0元素个数是顶点i的入度<br> 稠密图适合用邻接矩阵的存储表示<br> 设图G的邻接矩阵为A，A^n[i][j]等于i到j长度为n的路径的数目<br> <img src="https://images2.imgbox.com/72/9c/2TtqGNpc_o.jpg" alt="请添加图片描述"></p> 
<p>邻接表：<br> 稀疏图用，不唯一<br> 无向图存储空间为O（|v|+2|E|）,有向图存储空间为O（|v|+|E|），邻接表查找俩顶点是否有边，效率低<br> <img src="https://images2.imgbox.com/73/a7/GH2sfOvm_o.jpg" alt="请添加图片描述"><br> 十字链表：<br> 容易找到出度入度，不唯一<br> 顶点节点：data,firstin:以该顶点为弧头的第一个顶点，firstiout:以该顶点为弧尾的第一个顶点<br> 弧节点:tailvex:指向弧尾，headvex:指向弧头，hlink:指向弧头相同的下一条弧，tlink:指向弧尾相同的下一条弧，info<br> <img src="https://images2.imgbox.com/eb/c5/IR6ZgYAD_o.jpg" alt="请添加图片描述"><br> 邻接多重表：<br> 无向图的另一种链式存储结构，容易求得边的各种信息，求俩个顶点是否有边麻烦<br> 顶点节点：data,firstedge:第一条依附于该定点的边<br> 边节点：mark:标记该边是否搜索过,ivex：该边依附的俩个顶点在图中的位置,ilink：指向下一条依附于ivex的边，jvex,jlink,info<br> <img src="https://images2.imgbox.com/9f/b6/xBN04l04_o.jpg" alt="请添加图片描述"><br> 广度优先搜索BFS<br> 是二叉树的层次遍历算法的扩展<br> 最坏情况下空间复杂度为O(|V|),邻接表时间复杂度O（|V|+|E|）,邻接矩阵时间复杂度O（|V|^2）<br> 深度优先算法DFS<br> 基于邻接矩阵的遍历所得到的DFS序列和BFS序列是惟一的，基于邻接表的遍历所得到的DFS序列和BFS序列不唯一。<br> 时间复杂度为O(|V|)</p> 
<p>非强连通分量一次调用BFS（G，i）或DFS（G，i）,无法访问到该连通分量的所有顶点</p> 
<p>最小生成树：不是唯一的，权值之和唯一，边数为顶点数减一</p> 
<p>prim算法：<br> 时间复杂度为O（|V|^2）适用于求解边稠密的图的最小生成树<br> Kruskal算法：<br> 时间复杂度为O（|E|log|E|）,适用于边稀疏而顶点较多的图<br> Dijkstra算法：<br> 基于贪心策略，时间复杂度为O（|V|^2），不允许边上带负权值<br> Floyd算法：<br> 时间复杂度为O（|V|^3），允许带有负权值，不允许有负权值的边的回路,也适用于带权无向图</p> 
<p>有向无环图（DAG图）<br> AOV网：有向图称为顶点表示活动的网络,若一个顶点有多个直接后继，拓扑排序结果不唯一。若顶点已经排在一个线性有序的序列中，每个顶点有唯一的直接后继前驱关系，则唯一<br> 拓扑排序算法：<br> 1.选择一个没有前驱的顶点并输出<br> 2.从网中删除该顶点和所有以他为起点的有向边<br> 3.重复到AOV为空或者网中不存在无前驱的顶点为止，后一种情况说明有向图中必然存在环<br> 邻接表存储拓扑结构的时间复杂度为O（|V|+|E|），邻接矩阵存储为O(|V|^2)</p> 
<p>AOE网：以边上的权值表示该活动的开销，用边表示活动的网络<br> 关键活动：最大路径长度的路径<br> 最早发生时间Ve(k)：事件vk的最早发生时间决定了所有从vk开始的活动能够开工的最早时间<br> 最迟发生时间Vl(k)：再不推迟整个工程完成的前提下，保证它的后继事件vj在其最迟发生时间vl(j)能够发生时，该事件最迟必须发生的时间<br> 活动ai最早开始时间e(i)：活动弧的起点所表示的事件的最早发生时间<br> 活动ai最迟开始时间e(i)：活动弧的起点所表示的事件的最迟发生时间与该活动所需时间之差</p> 
<p>求关键路径算法：<br> 1.求ve()<br> 2.求vl()<br> 3.e()=该弧的起点的顶点的ve()<br> 4.l(i)=该弧的终点的顶点的vl()减去该弧持续的时间<br> 5.根据l(i)-e(i)=0的关键活动，得到关键路径<br> 可以加快关键活动缩短工期，不能任意缩短，关键路径不唯一</p> 
<pre><code class="prism language-css">package demo5<span class="token punctuation">;</span>
<span class="token comment">/*
 * 顶点
 */</span>
<span class="token selector">public class Vertex</span> <span class="token punctuation">{<!-- --></span>
	private String value<span class="token punctuation">;</span>
	public boolean visited<span class="token punctuation">;</span>

	<span class="token selector">public String getValue()</span> <span class="token punctuation">{<!-- --></span>
		return value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public void setValue(String value)</span> <span class="token punctuation">{<!-- --></span>
		this.value = value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token atrule"><span class="token rule">@Override</span>
	public String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span> <span class="token punctuation">{<!-- --></span>
		return <span class="token string">"Vertex [value="</span> + value + <span class="token string">"]"</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token selector">public Vertex(String value)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		this.value = value<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token punctuation">}</span>


package demo5<span class="token punctuation">;</span>

import java.util.Arrays<span class="token punctuation">;</span>

<span class="token comment">/*
 * 图
 */</span>
<span class="token selector">public class Graph</span> <span class="token punctuation">{<!-- --></span>
	private Vertex[] vertex<span class="token punctuation">;</span>
	private int currentSize<span class="token punctuation">;</span>
	public int[][] adjMat<span class="token punctuation">;</span>
	//之前写过了栈的代码，直接拿来用
	private MyStack stack = new <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	//当前遍历的下标
	private int currentIndex<span class="token punctuation">;</span>
	<span class="token selector">public Graph(int size)</span> <span class="token punctuation">{<!-- --></span>
		vertex = new Vertex[size]<span class="token punctuation">;</span>
		adjMat = new int[size][size]<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">public void addFage(String v1,String v2)</span> <span class="token punctuation">{<!-- --></span>
		//找出俩个顶点的下标
		int index1 = 0<span class="token punctuation">,</span>index2 = 0<span class="token punctuation">;</span>
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i&lt;vertex.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">if(vertex[i].getValue().equals(v1))</span> <span class="token punctuation">{<!-- --></span>
				index1 = i<span class="token punctuation">;</span>
				break<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token function">for</span><span class="token punctuation">(</span>int i = 0<span class="token punctuation">;</span>i&lt;vertex.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token selector">if(vertex[i].getValue().equals(v2))</span> <span class="token punctuation">{<!-- --></span>
				index2 = i<span class="token punctuation">;</span>
				break<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		adjMat[index1][index2] = 1<span class="token punctuation">;</span>
		adjMat[index2][index1] = 1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//向图中加入一个顶点
	public void addVertex(Vertex v)</span> <span class="token punctuation">{<!-- --></span>
		vertex[currentSize++] = v<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">//深度优先搜索算法
	public void dfs()</span> <span class="token punctuation">{<!-- --></span>
		//把第0个顶点标记为已访问状态
		vertex[0].visited = true<span class="token punctuation">;</span>
		//把第0个顶点的下标
		stack.<span class="token function">push</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
		//打印顶点的值
		System.out.<span class="token function">println</span><span class="token punctuation">(</span>vertex[0].<span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token selector">//遍历
		//out:
		while(!stack.isEmpty())</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">for</span><span class="token punctuation">(</span>int i = currentIndex+1<span class="token punctuation">;</span>i&lt;vertex.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token selector">//如果和下一个遍历的元素是联通的
				if(adjMat[currentIndex][i] == 1 &amp;&amp; vertex[i].visited == false)</span> <span class="token punctuation">{<!-- --></span>
					//把下一个元素压入展中
					stack.<span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
					vertex[i].visited = true<span class="token punctuation">;</span>
					System.out.<span class="token function">println</span><span class="token punctuation">(</span>vertex[i].<span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					//currentIndex = i<span class="token punctuation">;</span>
					//continue out<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			//遍历完发现没有相通的，则弹出栈顶元素
			stack.<span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token selector">//修改当前位置为栈顶元素的位置
			if(!stack.isEmpty())</span> <span class="token punctuation">{<!-- --></span>
			currentIndex = stack.<span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	
	<span class="token punctuation">}</span>
	<span class="token selector">public static void main(String[] args)</span> <span class="token punctuation">{<!-- --></span>
		// TODO Auto-generated method stub
		Vertex v1 = new <span class="token function">Vertex</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Vertex v2 = new <span class="token function">Vertex</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Vertex v3 = new <span class="token function">Vertex</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Vertex v4 = new <span class="token function">Vertex</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Vertex v5 = new <span class="token function">Vertex</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Graph g = new <span class="token function">Graph</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		g.<span class="token function">addVertex</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		g.<span class="token function">addVertex</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		g.<span class="token function">addVertex</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">;</span>
		g.<span class="token function">addVertex</span><span class="token punctuation">(</span>v4<span class="token punctuation">)</span><span class="token punctuation">;</span>
		g.<span class="token function">addVertex</span><span class="token punctuation">(</span>v5<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		//增加边
		g.<span class="token function">addFage</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		g.<span class="token function">addFage</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		g.<span class="token function">addFage</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		g.<span class="token function">addFage</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>![在这里插入图片描述]<span class="token punctuation">(</span><span class="token property">https</span><span class="token punctuation">:</span>//img-blog.csdnimg.cn/3e5ad18cebcd41e9939a11e3ab926d85.png?x-oss-process=image/watermark<span class="token punctuation">,</span>type_ZHJvaWRzYW5zZmFsbGJhY2s<span class="token punctuation">,</span>shadow_50<span class="token punctuation">,</span>text_Q1NETiBA5a2z56u5<span class="token punctuation">,</span>size_20<span class="token punctuation">,</span>color_FFFFFF<span class="token punctuation">,</span>t_70<span class="token punctuation">,</span>g_se<span class="token punctuation">,</span>x_16<span class="token punctuation">)</span>

		g.<span class="token function">addFage</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token selector">for(int[] a:g.adjMat)</span> <span class="token punctuation">{<!-- --></span>
			System.out.<span class="token function">println</span><span class="token punctuation">(</span>Arrays.<span class="token function">toString</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		//深度优先遍历
		g.<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/99e73b2af47ba0bbe1910b396e807d3d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Markdown详细教程&#43;技巧总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c3bae7f5a1e0b6c48751d7f571667f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ansible 概述与模块基本操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>