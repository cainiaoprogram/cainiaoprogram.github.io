<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MapReduce的处理流程（一） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MapReduce的处理流程（一）" />
<meta property="og:description" content="1、流程
代码编写 =》 作业配置 =》 作业提交 =》 Map任务的分配和执行 =》 处理中间结果 =》 Reduce任务的分配和执行 =》 作业完成
在每个任务的执行过程中，又包含输入准备 =》 任务执行 =》 输出结果
MapReduce作业的执行可以分为11个步骤，涉及4个独立的实体：
客户端(client)：编写MapReduce代码，配置作业、提交作业。
JobTracker：初始化作业，分配作业，与TaskTracker通信、协调整个作业的执行
TaskTracker：保持JobTracker的通信，在分配的数据片段上执行Map或Reduce任务。
HDFS：保存作业的数据、配置信息等，保存作业结果。
2、作业提交
一个MapReduce作业在提交到hadoop上之后，会进入完全的自动化执行过程。在这个过程中，用户除了监控程序的执行和强制中止作业之外，不能对作业的执行过程进行任何干扰。所以，在作业提交之前，用户需要将所有应该配置的参数按照自己的意愿配置完毕。需要配置的主要参数如下：
程序代码、Map和Reduce接口的配置、输入/输出路径、其他类型设置
整个提交过程包含以下步骤：
(1) 通过调用JobTracker对象的getNewJobId()从JobTracker处获取当前作业的id号
(2) 检查作业相关路径。
(3) 计算作业的输入划分，并将划分信息写入Job.split文件，如果写入失败就会返回错误。
(4) 将运行作业所需要的资源—包括作业JAR文件、配置文件和计算所得的输入划分等—复制到作业对应的HDFS上。
(5) 调用JobTracker对象的submit()方法来真正提交作业，告诉JobTracker作业准备执行。
3、初始化作业
在客户端用户作业调用JobTracker对象的submitJob()方法后，JobTracker会把此调用放入内部的taskScheduler变量中，然后进行调试。
初始化过程主要有以下步骤：
（1） 从HDFS中读取作业对应的job.split。
（2） 创建并初始化Map任务和Reduce任务。
（3） 最后就是创建两个初始化任务，根据Map和Reduce个数及输入分片中已经配置的信息，分别初始化Map和Reduce
4、分配任务
TaskTracker和JobTracker之间通过心跳通信汇报状态和分配任务。TaskTracker首先发送自己的状态（主要是Map任务和Reduce任务的个数是否小于上限），并根据自己的条件选择是否向JobTracker请求新的任务，最后发送心跳。JobTracker接收到TaskTracker的心跳后首先分析心跳信息，如果发现TaskTracker在请求一个新任务，那么任务调试器就会将任务和任务信息封装起来返回给TaskTracker。
针对Map任务和Reduce任务，TaskTracker有固定数量的任务槽（Map任务和Reduce任务的个数都有上限）。当TaskTracker从JobTracker返回的心跳信息中获取新的任务信息时，会将Map任务或者Reduce任务加入对应的任务槽中。需要注意的是，在JobTracker为TaskTracker分配Map任务时，为了减小网络带宽会考虑将Map任务数据本地化。它会根据TaskTracker的网络位置，选取距离最近的输入划分文件分配给些TaskTracker。最好情况是，划分文件就在TaskTracker本地。
5、执行任务
在TaskTracker申请到新的任务之后，就要在本地运行任务了。通过调用localizeJob()方法来完成本地化。
（1） 将job.split复制到本地。
（2） 将job.jar复制到本地。
（3） 将job的配置信息定稿job.xml
（4） 创建本地任务目录，解压job.jar
（5） 调用launchTaskForJob()方法发布任务。
本地化后，调用launchTaskForJob()真正启动起来，调用launchTask()方法启动任务。launchTask()方法先会为任务创建本地目录，然后启动TaskRunner，在启动TaskRunner后，对于Map任务，会启动MapTaskRunner；对于Reduce任务则启动ReduceTaskRunner。
6、更新任务执行进度和状态
TaskTracker每隔5s发送给JobTracker的心跳中封装任务状态，报告自己的任务执行状态。通过心跳通信机制，所有TaskTracker的统计信息都会汇总到JobTracker处。JobTracker将这些统计信息合并起来，产生一个全局作业进度统计信息，表明正在运行的所有作业及其中所含任务的状态。最后，JobClient通过每秒查看JobTracker来接收作业进度的最新状态。
7、完成作业
所有TaskTracker任务的执行进度信息都会汇总到JobTracker处，当JobTracker接收到最后一个任务已完成的通知后，便把作业的状态设置为“成功”。然后，JobClient也将及时得知任务已成功完成，它便会显示一条信息告知用户，最后从runJob()方法处返回（在返回后，JobTracker会清空作业的工作状态，并指示TaskTracker也清空作业的工作状态，如删除中间输出等）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e2f7d309373396977a785fe6d94ac4e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-08-10T21:18:37+08:00" />
<meta property="article:modified_time" content="2015-08-10T21:18:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MapReduce的处理流程（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、流程</p> 
<p>代码编写  =》 作业配置  =》 作业提交  =》 Map任务的分配和执行 =》 处理中间结果 =》 Reduce任务的分配和执行 =》 作业完成</p> 
<p>在每个任务的执行过程中，又包含输入准备 =》 任务执行 =》 输出结果</p> 
<p>MapReduce作业的执行可以分为11个步骤，涉及4个独立的实体：</p> 
<p>客户端(client)：编写MapReduce代码，配置作业、提交作业。</p> 
<p>JobTracker：初始化作业，分配作业，与TaskTracker通信、协调整个作业的执行</p> 
<p>TaskTracker：保持JobTracker的通信，在分配的数据片段上执行Map或Reduce任务。</p> 
<p>HDFS：保存作业的数据、配置信息等，保存作业结果。</p> 
<p>2、作业提交</p> 
<p>一个MapReduce作业在提交到hadoop上之后，会进入完全的自动化执行过程。在这个过程中，用户除了监控程序的执行和强制中止作业之外，不能对作业的执行过程进行任何干扰。所以，在作业提交之前，用户需要将所有应该配置的参数按照自己的意愿配置完毕。需要配置的主要参数如下：</p> 
<p>程序代码、Map和Reduce接口的配置、输入/输出路径、其他类型设置</p> 
<p>整个提交过程包含以下步骤：</p> 
<p>(1)  通过调用JobTracker对象的getNewJobId()从JobTracker处获取当前作业的id号</p> 
<p>(2)  检查作业相关路径。</p> 
<p>(3)  计算作业的输入划分，并将划分信息写入Job.split文件，如果写入失败就会返回错误。</p> 
<p>(4)  将运行作业所需要的资源—包括作业JAR文件、配置文件和计算所得的输入划分等—复制到作业对应的HDFS上。</p> 
<p>(5)  调用JobTracker对象的submit()方法来真正提交作业，告诉JobTracker作业准备执行。</p> 
<p>3、初始化作业</p> 
<p>在客户端用户作业调用JobTracker对象的submitJob()方法后，JobTracker会把此调用放入内部的taskScheduler变量中，然后进行调试。</p> 
<p>初始化过程主要有以下步骤：</p> 
<p>（1）    从HDFS中读取作业对应的job.split。</p> 
<p>（2）    创建并初始化Map任务和Reduce任务。</p> 
<p>（3）    最后就是创建两个初始化任务，根据Map和Reduce个数及输入分片中已经配置的信息，分别初始化Map和Reduce</p> 
<p>4、分配任务</p> 
<p>TaskTracker和JobTracker之间通过心跳通信汇报状态和分配任务。TaskTracker首先发送自己的状态（主要是Map任务和Reduce任务的个数是否小于上限），并根据自己的条件选择是否向JobTracker请求新的任务，最后发送心跳。JobTracker接收到TaskTracker的心跳后首先分析心跳信息，如果发现TaskTracker在请求一个新任务，那么任务调试器就会将任务和任务信息封装起来返回给TaskTracker。</p> 
<p>针对Map任务和Reduce任务，TaskTracker有固定数量的任务槽（Map任务和Reduce任务的个数都有上限）。当TaskTracker从JobTracker返回的心跳信息中获取新的任务信息时，会将Map任务或者Reduce任务加入对应的任务槽中。需要注意的是，在JobTracker为TaskTracker分配Map任务时，为了减小网络带宽会考虑将Map任务数据本地化。它会根据TaskTracker的网络位置，选取距离最近的输入划分文件分配给些TaskTracker。最好情况是，划分文件就在TaskTracker本地。</p> 
<p>5、执行任务</p> 
<p>在TaskTracker申请到新的任务之后，就要在本地运行任务了。通过调用localizeJob()方法来完成本地化。</p> 
<p>（1）    将job.split复制到本地。</p> 
<p>（2）    将job.jar复制到本地。</p> 
<p>（3）    将job的配置信息定稿job.xml</p> 
<p>（4）    创建本地任务目录，解压job.jar</p> 
<p>（5）    调用launchTaskForJob()方法发布任务。</p> 
<p>本地化后，调用launchTaskForJob()真正启动起来，调用launchTask()方法启动任务。launchTask()方法先会为任务创建本地目录，然后启动TaskRunner，在启动TaskRunner后，对于Map任务，会启动MapTaskRunner；对于Reduce任务则启动ReduceTaskRunner。</p> 
<p>6、更新任务执行进度和状态</p> 
<p>TaskTracker每隔5s发送给JobTracker的心跳中封装任务状态，报告自己的任务执行状态。通过心跳通信机制，所有TaskTracker的统计信息都会汇总到JobTracker处。JobTracker将这些统计信息合并起来，产生一个全局作业进度统计信息，表明正在运行的所有作业及其中所含任务的状态。最后，JobClient通过每秒查看JobTracker来接收作业进度的最新状态。</p> 
<p>7、完成作业</p> 
<p>所有TaskTracker任务的执行进度信息都会汇总到JobTracker处，当JobTracker接收到最后一个任务已完成的通知后，便把作业的状态设置为“成功”。然后，JobClient也将及时得知任务已成功完成，它便会显示一条信息告知用户，最后从runJob()方法处返回（在返回后，JobTracker会清空作业的工作状态，并指示TaskTracker也清空作业的工作状态，如删除中间输出等）。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5ac046d844eb9dc6011041f7c69f8090/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hadoop开发环境的配置（安装eclipse）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/86d771eca534dca72b85f381d7419aea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JMeter传递JSON数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>