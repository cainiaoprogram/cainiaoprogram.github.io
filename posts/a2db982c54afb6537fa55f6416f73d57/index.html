<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Quartz.net 动态定时任务 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Quartz.net 动态定时任务" />
<meta property="og:description" content="由于到新公司解决老旧系统定时任务基于bat脚本curl定时请求无法统一管理和扩展性太差问题，以及在搭建的过程中遇到的坑，故针对这情况写了一个定时任务的管理模块，支持Get,Post请求方式。
源代码地址：源代码地址
无缝嵌入项目，支持Swagger测试
什么是定时任务？ 定时发邮件，定时统计信息等内容，那么如何实现才能使得我们的项目整齐划一呢？本文通过一些简单的小例子，简述在.Net 7&#43;Quartz实现定时任务的一些基本操作，及相关知识介绍，仅供学习分享使用，如有不足之处，还请指正。
什么是Quartz？
Quartz 是一个开源的作业调度框架，它完全由 Java 写成，并设计用于 J2SE 和 J2EE 应用中。它提供了巨大的灵 活性而不牺牲简单性。你能够用它来为执行一个作业而创建简单的或复杂的调度。它有很多特征，如：数据库支持，集群，插件，EJB 作业预构 建，JavaMail 及其它，支持 cron-like 表达式等等。虽然Quartz最初是为Java编写的，但是目前已经有.Net版本的Quartz，所以在.Net中应用Quartz已经不再是奢望，而是轻而易举的事情了。
Github上开源网址为：https://github.com/quartznet
关于Quartz的快速入门和API文档，可以参考：
https://www.quartz-scheduler.net/documentation/quartz-3.x/quick-start.html
Quartz安装 为了方便，本项目采用仓储模式，由Api，BizManagement，DataBase，Entity 4个模块组成，本次基于Rider开发，通过Nuget包管理器进行安装，如下所示：
项目模块组成： 依赖组件： 1. redis (StackExchange.Redis: 2.6.122)查询全量数据的持久化
2. Nlog(5.3.5) 日志记录到文件
3. SkyApm(0.9.0) 接口追踪
4. Mysql(Pomelo.EntityFrameworkCore.MySql: 7.0.0) 持久化Scheduler到数据库
5. AutoMapper(12.0.1) 实体映射
6. EFCore(7.0.13) ORM管理
remark：数据库，Redis地址在api模块 appsetting.json修改
主要功能组件： QuartzManage: 对Job的管理，支持暂停，启动，更新频率，批量删除等操作
using System.Collections.Specialized; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; using org.huage.BizManagement.Job; using org.huage.BizManagement.Listener; using org.huage.BizManagement.Proxy; using org.huage.Entity.common; using org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a2db982c54afb6537fa55f6416f73d57/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-15T16:50:42+08:00" />
<meta property="article:modified_time" content="2023-12-15T16:50:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Quartz.net 动态定时任务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>由于到新公司解决老旧系统定时任务基于bat脚本curl定时请求无法统一管理和扩展性太差问题，以及在搭建的过程中遇到的坑，故针对这情况写了一个定时任务的管理模块，支持Get,Post请求方式。</p> 
<p>源代码地址：<a class="link-info" href="https://github.com/Austin-codeviewr/org.huage.SchedulerManage" title="源代码地址">源代码地址</a></p> 
<p>无缝嵌入项目，支持Swagger测试</p> 
<p></p> 
<h4><span style="color:#1c7331;"><strong>什么是定时任务？</strong></span></h4> 
<p>定时发邮件，定时统计信息等内容，那么如何实现才能使得我们的项目整齐划一呢？本文通过一些简单的小例子，简述在.Net 7+<a href="https://so.csdn.net/so/search?q=Quartz&amp;spm=1001.2101.3001.7020" title="Quartz">Quartz</a>实现定时任务的一些基本操作，及相关知识介绍，仅供学习分享使用，如有不足之处，还请指正。</p> 
<p></p> 
<p><span style="color:#1c7331;"><strong>什么是Quartz？</strong></span><br> Quartz 是一个开源的作业调度框架，它完全由 Java 写成，并设计用于 J2SE 和 J2EE 应用中。它提供了巨大的灵 活性而不牺牲简单性。你能够用它来为执行一个作业而创建简单的或复杂的调度。它有很多特征，如：数据库支持，集群，插件，EJB 作业预构 建，JavaMail 及其它，支持 cron-like 表达式等等。虽然Quartz最初是为Java编写的，但是目前已经有.Net版本的Quartz，所以在.Net中应用Quartz已经不再是奢望，而是轻而易举的事情了。</p> 
<p>Github上开源网址为：https://github.com/quartznet<br> 关于Quartz的快速入门和API文档，可以参考：</p> 
<p>https://www.quartz-scheduler.net/documentation/quartz-3.x/quick-start.html</p> 
<p></p> 
<h4><span style="color:#1c7331;"><strong>Quartz安装</strong></span></h4> 
<p>为了方便，本项目采用仓储模式，由Api，BizManagement，DataBase，Entity 4个模块组成，本次基于Rider开发，通过Nuget包管理器进行安装，如下所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/67/97/KzB4h7PG_o.png"></p> 
<h5></h5> 
<h4><span style="color:#1c7331;"><strong>项目模块组成：</strong></span></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5c/fe/FOcWjji9_o.png"></p> 
<h5></h5> 
<h4><span style="color:#1c7331;"><strong>依赖组件：</strong></span></h4> 
<p>1. redis (StackExchange.Redis: 2.6.122)查询全量数据的持久化</p> 
<p>2. Nlog(5.3.5) 日志记录到文件</p> 
<p>3. SkyApm(0.9.0) 接口追踪</p> 
<p>4. Mysql(Pomelo.EntityFrameworkCore.MySql: 7.0.0) 持久化Scheduler到数据库</p> 
<p>5. AutoMapper(12.0.1) 实体映射</p> 
<p>6. EFCore(7.0.13) ORM管理</p> 
<p>remark：数据库，Redis地址在api模块 appsetting.json修改</p> 
<p></p> 
<h4> <span style="color:#1c7331;">主要功能组件：</span></h4> 
<p><span style="color:#1c7331;">QuartzManage: 对Job的管理，支持暂停，启动，更新频率，批量删除等操作</span></p> 
<pre><code class="language-cs">using System.Collections.Specialized;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using org.huage.BizManagement.Job;
using org.huage.BizManagement.Listener;
using org.huage.BizManagement.Proxy;
using org.huage.Entity.common;
using org.huage.Entity.Request;
using Quartz;
using Quartz.Impl;
using Quartz.Impl.Matchers;
using Quartz.Impl.Triggers;
using Quartz.Spi;
using SchedulerException = Quartz.SchedulerException;

namespace org.huage.BizManagement.Manager;

public class QuartzManage : IQuartzManage
{
    private static ISchedulerFactory _schedulerFactory;
    private static IScheduler _scheduler;
    private readonly IJobFactory _jobFactory;
    
    public QuartzManage(IJobFactory jobFactory)
    {
        _jobFactory = jobFactory;
        
        var config = new NameValueCollection();
        config.Add("quartz.jobStore.misfireThreshold", "1000");
        
        _schedulerFactory = new StdSchedulerFactory(config);
        //获得调度器
        _scheduler = _schedulerFactory.GetScheduler().Result;
        
        _scheduler.JobFactory = jobFactory;
        //调度开始
        _scheduler.Start();
    }
    
    
    /// &lt;summary&gt;
    /// 判断corn表达式是否有效
    /// &lt;/summary&gt;
    /// &lt;param name="cronExpression"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    private bool IsValidExpression(string cronExpression)
    {
        CronTriggerImpl trigger = new CronTriggerImpl();
        try
        {
            trigger.CronExpressionString = cronExpression;
            DateTimeOffset? date = trigger.ComputeFirstFireTimeUtc(null);
            return date != null;
        }
        catch (Exception)
        {
            return false;
        }
    }
    
    /// &lt;summary&gt;
    /// 暂停Job
    /// &lt;/summary&gt;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    /// &lt;param name="jobName"&gt;&lt;/param&gt;
    /// &lt;param name="groupName"&gt;&lt;/param&gt;
    public async Task PauseJob(string jobName, string groupName)
    {
        //查询同一个分组的JobKey列表
        var jobKeys = await _scheduler.GetJobKeys(GroupMatcher&lt;JobKey&gt;.GroupEquals(groupName));
        if (jobKeys != null &amp;&amp; jobKeys.Count &gt; 0)
        {
            //获得指定名称jobName的的jobKey
            var jobKey = jobKeys.FirstOrDefault(p =&gt; p.Name.Equals(jobName));
            if (jobKey != null)
            {
                //暂停job的调度
                await _scheduler.PauseJob(jobKey);
            }
            else
            {
                throw new SchedulerException("Can' find this Job.");
            }
        }
        else
        {
            throw new SchedulerException("Can't fin this Job.");
        }
    }
    
    /// &lt;summary&gt;
    /// 重启job
    /// &lt;/summary&gt;
    /// &lt;param name="jobName"&gt;&lt;/param&gt;
    /// &lt;param name="groupName"&gt;&lt;/param&gt;
    /// &lt;exception cref="Exception"&gt;&lt;/exception&gt;
    public async Task StartJob(string jobName, string groupName)
    {
        //查询同一个分组的JobKey列表
        var jobKeys = await _scheduler.GetJobKeys(GroupMatcher&lt;JobKey&gt;.GroupEquals(groupName));
        if (jobKeys != null &amp;&amp; jobKeys.Any())
        {
            //获得指定名称jobName的的jobKey
            var jobKey = jobKeys.FirstOrDefault(p =&gt; p.Name.Equals(jobName));
            if (jobKey != null)
            {
                //暂停job的调度
                await _scheduler.ResumeJob(jobKey);
            }
            else
            {
                throw new SchedulerException("没有此Job");
            }
        }
        else
        {
            throw new SchedulerException("没有此Job");
        }
    }
    
    /// &lt;summary&gt;
    /// 创建Get请求方式Job
    /// &lt;/summary&gt;
    /// &lt;param name="jobName"&gt;&lt;/param&gt;
    /// &lt;param name="groupName"&gt;&lt;/param&gt;
    /// &lt;param name="desc"&gt;&lt;/param&gt;
    /// &lt;param name="cronExpression"&gt;&lt;/param&gt;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    /// &lt;exception cref="Exception"&gt;&lt;/exception&gt;
    public async Task AddJobForGet&lt;T&gt;(string jobName, string groupName, string remark,AddSchedulerRequest request)
        where T : IJob
    {
        //判断 cron 表达式是否有效
        if (!IsValidExpression(request.CronExpression))
        {
            throw new Exception("请输入cron表达式");
        }
        //判断url
        if (string.IsNullOrEmpty(request.Url) || ! Uri.TryCreate(request.Url,UriKind.Absolute,out var success))
        {
            throw new Exception($"当前Url 格式不正确：{request.Url}");
        }
        //创建Job
        var job = JobBuilder.Create&lt;T&gt;().UsingJobData(new JobDataMap()
            {
                new KeyValuePair&lt;string, object&gt;("RequestUrl", request.Url),
                new KeyValuePair&lt;string, object&gt;("RequestParam", request.MethodParams)
            })
            .WithIdentity(jobName, groupName)//键值
            .WithDescription(remark)//描述
            .Build();

        //创建触发器
        var timeUnit = SchedulerUtils.GetTimeUnit(request.StartTime);
        
        ITrigger trigger = TriggerBuilder.Create()
            .WithCronSchedule(request.CronExpression,x=&gt;x.WithMisfireHandlingInstructionFireAndProceed())
            .WithIdentity(jobName, groupName)
            .StartAt(DateBuilder.DateOf(timeUnit[3], timeUnit[4], 
                timeUnit[5],timeUnit[2],timeUnit[1],timeUnit[0]))
            .Build();

        //添加监听器
        //_scheduler.ListenerManager.AddJobListener(new JobListener(),GroupMatcher&lt;JobKey&gt;.AnyGroup());
        //_scheduler.ListenerManager.AddTriggerListener(new TriggerListener(), GroupMatcher&lt;TriggerKey&gt;.AnyGroup());
        //开始以创建的触发器调度创建的Job
        
        await _scheduler.ScheduleJob(job, trigger);
    }
    
    /// &lt;summary&gt;
    /// 创建post请求的参数
    /// &lt;/summary&gt;
    /// &lt;param name="jobName"&gt;&lt;/param&gt;
    /// &lt;param name="groupName"&gt;&lt;/param&gt;
    /// &lt;param name="request"&gt;&lt;/param&gt;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    /// &lt;exception cref="Exception"&gt;&lt;/exception&gt;
    public async Task AddJobForPost&lt;T&gt;(string jobName, string groupName,AddSchedulerRequest request)
        where T : IJob
    {
        //判断 cron 表达式是否有效
        if (!IsValidExpression(request.CronExpression))
        {
            throw new Exception("请输入cron表达式");
        }
        //创建Job
        var job = JobBuilder.Create&lt;T&gt;()
            .WithIdentity(jobName, groupName).UsingJobData(new JobDataMap()
            {
                new KeyValuePair&lt;string, object&gt;("RequestUrl", request.Url),
                new KeyValuePair&lt;string, object&gt;("RequestParam", request.MethodParams)
            }).RequestRecovery(true).WithDescription(request.Remark ?? "")
            .Build();

        //创建触发器
        var timeUnit = SchedulerUtils.GetTimeUnit(request.StartTime);
        ITrigger trigger = TriggerBuilder.Create()
            .WithCronSchedule(request.CronExpression,x=&gt;x.WithMisfireHandlingInstructionFireAndProceed())
            .WithIdentity(SchedulerKeyGenerator.TriggerKey(request.Id), groupName)
            .StartAt(DateBuilder.DateOf(timeUnit[3], timeUnit[4], 
                timeUnit[5],timeUnit[2],timeUnit[1],timeUnit[0]))
            .Build();

        //添加监听器
        //_scheduler.ListenerManager.AddJobListener(new JobListener(),GroupMatcher&lt;JobKey&gt;.AnyGroup());
        //_scheduler.ListenerManager.AddTriggerListener(new TriggerListener(), GroupMatcher&lt;TriggerKey&gt;.AnyGroup());
        
        await _scheduler.ScheduleJob(job, trigger);
    }
    
    
    /// &lt;summary&gt;
    /// 更新job调度频率
    /// &lt;/summary&gt;
    /// &lt;param name="jobName"&gt;&lt;/param&gt;
    /// &lt;param name="groupName"&gt;&lt;/param&gt;
    /// &lt;param name="remark"&gt;&lt;/param&gt;
    /// &lt;param name="cronExpression"&gt;&lt;/param&gt;
    /// &lt;exception cref="Exception"&gt;&lt;/exception&gt;
    /// &lt;exception cref="SchedulerException"&gt;&lt;/exception&gt;
    public async Task UpdateJobRate(string jobName, string groupName, string remark, string cronExpression,long startTime)
    {
        if (!IsValidExpression(cronExpression))
        {
            throw new Exception("cron表达式无效");
        }

        var jobKeys = await _scheduler.GetJobKeys(GroupMatcher&lt;JobKey&gt;.GroupEquals(groupName));
        if (jobKeys != null &amp;&amp; jobKeys.Any())
        {
            var jobKey = jobKeys.FirstOrDefault(p =&gt; p.Name.Equals(jobName));
            if (jobKey != null)
            {
                var job = await _scheduler.GetJobDetail(jobKey);
                if (job == null) throw new Exception("job不存在");
                //先删除原有job
                await _scheduler.DeleteJob(jobKey);
                
                var timeUnit = SchedulerUtils.GetTimeUnit(startTime);
        
                var trigger = TriggerBuilder.Create()
                    .WithCronSchedule(cronExpression)
                    .WithIdentity(jobName, groupName)
                    .StartAt(DateBuilder.DateOf(timeUnit[3], timeUnit[4], 
                        timeUnit[5],timeUnit[2],timeUnit[1],timeUnit[0]))
                    .Build();
                await _scheduler.ScheduleJob(job, trigger);
            }
            else
            {
                throw new SchedulerException("job不存在");
            }
        }
        else
        {
            throw new SchedulerException("job不存在");
        }
    }
    
    
    /// &lt;summary&gt;
    /// 删除job
    /// &lt;/summary&gt;
    /// &lt;param name="jobName"&gt;&lt;/param&gt;
    /// &lt;param name="groupName"&gt;&lt;/param&gt;
    /// &lt;exception cref="Exception"&gt;&lt;/exception&gt;
    public async Task DeleteJob(string jobName, string groupName)
    {
        var jobKeys = await _scheduler.GetJobKeys(GroupMatcher&lt;JobKey&gt;.GroupEquals(groupName));
        if (jobKeys != null &amp;&amp; jobKeys.Any())
        {
            var jobKey = jobKeys.FirstOrDefault(p =&gt; p.Name.Equals(jobName));
            if (jobKey != null)
            {
                await _scheduler.DeleteJob(jobKey);
            }
            else
            {
                throw new SchedulerException("要删除的job不存在");
            }
        }
        else
        {
            throw new SchedulerException("要删除的job不存在");
        }
    }
}
     
</code></pre> 
<h5></h5> 
<h4><span style="color:#1c7331;">SchedulerManage: 实际调用的服务，暴露给controller调用。</span></h4> 
<pre><code class="language-cs">using System.Linq.Expressions;
using AutoMapper;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using org.huage.BizManagement.Job;
using org.huage.BizManagement.Redis;
using org.huage.BizManagement.Wrapper;
using org.huage.Entity.common;
using org.huage.Entity.Enum;
using org.huage.Entity.Model;
using org.huage.Entity.Request;
using org.huage.Entity.Response;
using org.huage.EntityFramewok.Database;
using org.huage.EntityFramewok.Database.Table;
using SchedulerException = org.huage.Entity.common.SchedulerException;

namespace org.huage.BizManagement.Manager;

public class SchedulerManager : ISchedulerManager
{
    private readonly IRepositoryWrapper _wrapper;
    private readonly ILogger&lt;SchedulerManager&gt; _logger;

    private readonly IRedisHelper _redisHelper;
    private IMapper _mapper;

    private readonly IQuartzManage _quartzManage;
    
    
    public SchedulerManager(IRepositoryWrapper wrapper, ILogger&lt;SchedulerManager&gt; logger, IMapper mapper,
        IRedisHelper redisHelper, IQuartzManage quartzManage)
    {
        _wrapper = wrapper;
        _logger = logger;
        _mapper = mapper;
        _redisHelper = redisHelper;
        _quartzManage = quartzManage;
    }
    
    public async Task&lt;AddSchedulerResponse&gt; AddSchedulerAsync(AddSchedulerRequest request)
    {
        //先保存到数据库，后续丢失可以重新跑
        AddSchedulerResponse response = new AddSchedulerResponse();
        try
        {
            if (request is null ||  (request.RequestType != RequestType.REQUEST_TYPE_GET &amp;&amp; request.RequestType != RequestType.REQUEST_TYPE_POST))
                throw new SchedulerException("目前只支持Get,Post,请传入正确的RequestType.");
            //首先判断传进来的是get/post，然后在IJob定义向指定的接口发送请求。
            
            switch (request.RequestType)
            {
                case RequestType.REQUEST_TYPE_GET:
                    await _quartzManage.AddJobForGet&lt;GetJob&gt;(SchedulerKeyGenerator.JobKey(request.Id), SchedulerKeyGenerator.GroupKey(request.Id)
                        , "",request);
                    break;
                case RequestType.REQUEST_TYPE_POST:
                    await _quartzManage.AddJobForPost&lt;PostJob&gt;(SchedulerKeyGenerator.JobKey(request.Id), SchedulerKeyGenerator.GroupKey(request.Id), request);
                    break;
            }
            
            //删除缓存
            await _redisHelper.DelKey(RedisKeyGenerator.AllSchedulersRedisKey());
            
            //插入数据库
            var scheduler1 = _mapper.Map&lt;Scheduler&gt;(request);
            _wrapper.Scheduler.Create(scheduler1);
            await _wrapper.SaveChangeAsync();
            await _redisHelper.DelKey(RedisKeyGenerator.AllSchedulersRedisKey());
        }
        catch (Exception e)
        {
            _logger.LogError("AddSchedulerAsync occur error:{Message}", e.Message);
            throw;
        }

        return response;
    }

    /// &lt;summary&gt;
    /// 更新Scheduler Rate(调度速率)
    /// &lt;/summary&gt;
    /// &lt;param name="rateRequest"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task&lt;UpdateSchedulerRateResponse&gt; UpdateSchedulerRateAsync(UpdateSchedulerRateRequest rateRequest)
    {
        //先删除缓存
        await _redisHelper.DelKey(RedisKeyGenerator.AllSchedulersRedisKey());
        var schedulerUpdate = _mapper.Map&lt;Scheduler&gt;(rateRequest);

        schedulerUpdate.UpdateBy = "test";
        _wrapper.Scheduler.Update(schedulerUpdate);

        //1.移除原来的job; 2.修改trigger; 3.重新调度jobDetail

        await _quartzManage.UpdateJobRate(SchedulerKeyGenerator.JobKey(rateRequest.Id), SchedulerKeyGenerator.GroupKey(rateRequest.Id), rateRequest.Remark, rateRequest.CronExpression, rateRequest.StartTime);

        return new UpdateSchedulerRateResponse();
    }


    /// &lt;summary&gt;
    ///更新Scheduler状态，暂停，启用。
    /// &lt;/summary&gt;
    /// &lt;param name="statusRequest"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    /// &lt;exception cref="SchedulerException"&gt;&lt;/exception&gt;
    public async Task&lt;bool&gt; UpdateSchedulerStatusAsync(UpdateSchedulerStatusRequest statusRequest)
    {
        if (statusRequest is null || (statusRequest.Status != 0 &amp;&amp; statusRequest.Status != 1))
            throw new SchedulerException("请传入正确的参数: Status.");

        switch (statusRequest.Status)
        {
            case 0:
                //执行关闭；
                await _quartzManage.PauseJob(SchedulerKeyGenerator.JobKey(statusRequest.Id), SchedulerKeyGenerator.GroupKey(statusRequest.Id));
                break;
            case 1:
                //执行启动
                await _quartzManage.StartJob(SchedulerKeyGenerator.JobKey(statusRequest.Id), SchedulerKeyGenerator.GroupKey(statusRequest.Id));
                break;
        }

        //删除缓存
        await _redisHelper.DelKey(RedisKeyGenerator.AllSchedulersRedisKey());

        //更新数据库
        var scheduler = _wrapper.Scheduler.FindByCondition(data =&gt; data.Id == statusRequest.Id &amp;&amp; data.IsDeleted == false)
            .FirstOrDefault();
        if (scheduler != null)
        {
            scheduler.JobStatus = statusRequest.Status;
            _wrapper.Scheduler.Update(scheduler);
            return true;
        }

        return false;
    }
    
    /// &lt;summary&gt;
    /// 更新整个JobDetail内容
    /// &lt;/summary&gt;
    /// &lt;param name="statusRequest"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    /// &lt;exception cref="SchedulerException"&gt;&lt;/exception&gt;
    public async Task&lt;UpdateSchedulerResponse&gt; UpdateSchedulerAsync(UpdateSchedulerRequest request)
    {
        
        //Delay double delete.
        await _redisHelper.DelKey(RedisKeyGenerator.AllSchedulersRedisKey());
        
        //更新数据库
        var updateScheduler = _mapper.Map&lt;Scheduler&gt;(request);
        _wrapper.Scheduler.Update(updateScheduler);
        
        await _redisHelper.DelKey(RedisKeyGenerator.AllSchedulersRedisKey());
        
        var response = new UpdateSchedulerResponse();
        //思路就是把trigger jobdetail全部替换成新的；1.先移除，2.新建（同时考虑会不会数据库重复，筛选条件加isDel）
        if (request is null ||  !"Get".Equals(request.RequestType,StringComparison.OrdinalIgnoreCase) || !"Post".Equals(request.RequestType,StringComparison.OrdinalIgnoreCase))
            throw new SchedulerException("目前只支持Get,Post,请传入正确的RequestType.");

        await _quartzManage.DeleteJob(SchedulerKeyGenerator.JobKey(request.Id),SchedulerKeyGenerator.GroupKey(request.Id));
        switch (request.RequestType)
        {
            case RequestType.REQUEST_TYPE_GET:
                await _quartzManage.AddJobForGet&lt;GetJob&gt;(SchedulerKeyGenerator.JobKey(request.Id), SchedulerKeyGenerator.GroupKey(request.Id)
                    , "", new AddSchedulerRequest());
                break;
            case RequestType.REQUEST_TYPE_POST:
                var map = _mapper.Map&lt;AddSchedulerRequest&gt;(request);
                await _quartzManage.AddJobForPost&lt;PostJob&gt;(SchedulerKeyGenerator.JobKey(request.Id), SchedulerKeyGenerator.GroupKey(request.Id),map);
                break;
        }
        
        
        return response;
    }

    /// &lt;summary&gt;
    /// 批量删除Schedulers
    /// &lt;/summary&gt;
    /// &lt;param name="ids"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    /// &lt;exception cref="SchedulerException"&gt;&lt;/exception&gt;
    public async Task&lt;bool&gt; BatchDelSchedulerAsync(List&lt;Guid&gt; ids)
    {
        if (!ids.Any())
            throw new SchedulerException("请传入正确的参数: ids.");
        //删除缓存
        await _redisHelper.DelKey(RedisKeyGenerator.AllSchedulersRedisKey());
        
        //更新数据库，逻辑删除
        var list = await _wrapper.Scheduler.FindByCondition(x =&gt; ids.Contains(x.Id)).ToListAsync();
        foreach (var scheduler in list)
        {
            scheduler.IsDeleted = true;
            scheduler.JobStatus = 0;
            _wrapper.Scheduler.Update(scheduler);
            //删除
            await _quartzManage.DeleteJob(SchedulerKeyGenerator.JobKey(scheduler.Id), SchedulerKeyGenerator.GroupKey(scheduler.Id));
        }
        
        return true;
    }


    /// &lt;summary&gt;
    /// 查询所有的Scheduler列表
    /// &lt;/summary&gt;
    /// &lt;param name="request"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task&lt;QuerySchedulerListResponse&gt; QueryAllSchedulersAsync(QuerySchedulerListRequest request)
    {
        var response = new QuerySchedulerListResponse();
        try
        {
            //先去查redis
            var allSchedulers = await _redisHelper.HGetAllValue&lt;Scheduler&gt;(RedisKeyGenerator.AllSchedulersRedisKey());
            if (allSchedulers.Any())
            {
                var map = _mapper.Map&lt;List&lt;SchedulerModel&gt;&gt;(allSchedulers);
                response.Schedulers = map;
                return response;
            }

            //查数据库，并设置redis；
            var schedulers = _wrapper.Scheduler.FindAll().Where(_=&gt;_.IsDeleted==false).ToList();
            var data = _mapper.Map&lt;List&lt;SchedulerModel&gt;&gt;(schedulers);
            response.Schedulers = data;
            var schedulersDic = schedulers.ToDictionary(_ =&gt; _.Id);

            await schedulersDic.ParallelForEachAsync(async scheduler =&gt;
            {
                var redisKey = RedisKeyGenerator.AllSchedulersRedisKey();
                try
                {
                    foreach (var s in schedulers)
                    {
                        await _redisHelper.HashSet(redisKey, scheduler.Key.ToString(),
                            JsonConvert.SerializeObject(scheduler.Value));
                    }
                }
                catch (Exception e)
                {
                    _logger.LogError(e.Message);
                }
            });
        }
        catch (Exception e)
        {
            _logger.LogError($"QueryAllSchedulersAsync error: {e.Message}");
            throw;
        }

        return response;
    }


    /// &lt;summary&gt;
    /// 根据条件查找schedulers.
    /// &lt;/summary&gt;
    /// &lt;param name="request"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task&lt;QuerySchedulerListByConditionsResponse&gt; QuerySchedulerListByConditionsAsync(QuerySchedulerListByConditionsRequest request)
    {
        var response = new QuerySchedulerListByConditionsResponse();
        try
        {
            //Param Check
            Expression&lt;Func&lt;Scheduler, bool&gt;&gt; expression = ExpressionExtension.True&lt;Scheduler&gt;();
            if (!string.IsNullOrEmpty(request.MethodName))
            {
                expression = expression.And(p =&gt; p.MethodName.Contains(request.MethodName));
            }
            if (!string.IsNullOrEmpty(request.Url))
            {
                expression = expression.And(p =&gt; p.Url.Contains(request.Url));
            }
            if (!string.IsNullOrEmpty(request.RequesType))
            {
                expression = expression.And(p =&gt; p.RequestType.Contains(request.RequesType));
            }
            //查数据库
            var schedulers = await _wrapper.Scheduler.FindByCondition(expression)
                .OrderByDescending(_=&gt;_.UpdateTime).ToListAsync();
            if (schedulers.Any())
            {
                var map = _mapper.Map&lt;List&lt;SchedulerModel&gt;&gt;(schedulers);
                response.SchedulerModels = map;
            }
            
            return response;
        }
        catch (Exception e)
        {
            _logger.LogError($"QuerySchedulerListByConditions error:{e.Message}");
            throw;
        }
    }

    private void DelayedDoubleDeletion(string key)
    {
        _ = Task.Factory.StartNew(async () =&gt;
        {
            await Task.Delay(3000);
            //删除key
            _redisHelper.Remove(key);
        });
    }
    
}</code></pre> 
<h5></h5> 
<h4><span style="color:#1c7331;">GetJob和PostJob的定义：</span></h4> 
<p><strong><span style="color:#fe2c24;">注意这里需要解决Quartz.net的Job定义的时候默认不支持依赖注入</span>，我们需要自定义JobFactory去实现IJobFactory接口，本项目中为DefaultSchedulerServiceFactory，注入starup的时候注意要使用AddSingleton方式，然后在QuartzManage构造函数里面主动修改它的JobFactory：</strong></p> 
<pre><code class="language-cs">builder.Services.AddTransient&lt;ISchedulerManager, SchedulerManager&gt;();
builder.Services.AddTransient&lt;IRedisHelper, RedisHelper&gt;();
builder.Services.AddSingleton&lt;IJobFactory, DefaultScheduleServiceFactory&gt;();
//这里注意注入方式，以及上下这些注入都不可以缺少
builder.Services.AddSingleton&lt;ISchedulerFactory, StdSchedulerFactory&gt;();
builder.Services.AddSingleton&lt;GetJob&gt;();
builder.Services.AddSingleton&lt;PostJob&gt;();
builder.Services.AddTransient&lt;IQuartzManage, QuartzManage&gt;();</code></pre> 
<pre><code class="language-cs">//主动修改其默认JobFactory
_scheduler.JobFactory = jobFactory;</code></pre> 
<p></p> 
<p><span style="color:#9c8ec1;"><strong>GetJob定义：</strong></span></p> 
<pre><code class="language-cs">using Microsoft.Extensions.Logging;
using Quartz;

namespace org.huage.BizManagement.Job;

public class GetJob : IJob
{
    private readonly ILogger&lt;GetJob&gt; _logger;
    public GetJob(ILogger&lt;GetJob&gt; logger)
    {
        _logger = logger;
    }

    public async Task Execute(IJobExecutionContext context)
    {
        var url = context.MergedJobDataMap["RequestUrl"].ToString();
        var param = context.MergedJobDataMap["RequestParam"].ToString();
        try
        {
            _logger.LogInformation($"Current execute url: {url}, param is {param}");
            var client = new HttpClient();
            using var httpResponse = await client.GetAsync(url);
            var result = await httpResponse.Content.ReadAsStringAsync();
            _logger.LogInformation("Result is: "+ result);
        }
        catch (Exception e)
        {
            _logger.LogError("执行请求地址："+url+" 发生异常");
            _logger.LogError("ERROR："+e.Message);
        }
    }
}</code></pre> 
<p></p> 
<p><span style="color:#9c8ec1;"><strong>PostJob定义：</strong></span></p> 
<pre><code class="language-cs">using System.Text;
using Microsoft.Extensions.Logging;
using Quartz;

namespace org.huage.BizManagement.Job;

public class PostJob : IJob
{
    private readonly ILogger&lt;PostJob&gt; _logger;

    public PostJob(ILogger&lt;PostJob&gt; logger)
    {
        _logger = logger;
    }

    public async Task Execute(IJobExecutionContext context)
    {
        //httpClient.DefaultRequestHeaders.Add("Portfolio", Portfolio);
        var url = context.MergedJobDataMap["RequestUrl"].ToString();
        var param = context.MergedJobDataMap["RequestParam"].ToString();
        
        var content = new StringContent(param ?? "{}", Encoding.UTF8, "application/json");

        try
        {
            _logger.LogInformation($"Current execute url: {url}, param is {param}");
            var client = new HttpClient();
            using var httpResponse = await client.PostAsync(url, content);
            var result = await httpResponse.Content.ReadAsStringAsync();
            _logger.LogInformation("Result is：" + result);
        }
        catch (Exception e)
        {
            _logger.LogError("执行请求地址："+url+"发生异常");
            _logger.LogError("ERROR："+e.Message);
        }
    }
}</code></pre> 
<h5></h5> 
<h4><span style="color:#1c7331;">Swagger界面：</span></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6a/b7/bFV64DZd_o.png"></p> 
<p> remark: 测试AddScheduler RequestType为Post请求的时候需要把methodParams参数压缩转义传递。</p> 
<p><a class="link-info" href="https://www.sojson.com/yasuo.html" rel="nofollow" title="Json压缩转义工具">Json压缩转义工具</a></p> 
<p></p> 
<h4><span style="color:#be191c;">2023-12-15更新：</span></h4> 
<p>原因：为了满足在项目崩溃重启后能够执行之前的scheduler，我们在项目启动时基于IHostService注册一个后台任务run定时任务。</p> 
<h6><span style="color:#1c7331;">代码实现：</span></h6> 
<h6><span style="color:#1c7331;">1. Api项目新增：   RestartRegisterScheduler</span></h6> 
<pre><code class="language-cs">using AutoMapper;
using org.huage.BizManagement.Job;
using org.huage.BizManagement.Manager;
using org.huage.Entity.common;
using org.huage.Entity.Enum;
using org.huage.Entity.Model;
using org.huage.Entity.Request;

namespace org.huage.Api.Extension;

public class RestartRegisterScheduler : IHostedService
{
    private readonly ILogger&lt;RestartRegisterScheduler&gt; _logger;
    private readonly IServiceProvider _serviceProvider;

    public RestartRegisterScheduler(ILogger&lt;RestartRegisterScheduler&gt; logger, IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider ?? throw new ArgumentNullException("error");
    }

    /// &lt;summary&gt;
    /// 查詢所有的數據庫狀態為enable的，然後重新注冊。
    /// &lt;/summary&gt;
    /// &lt;param name="cancellationToken"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public async Task StartAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Register the Scheduler to task container.");

        using var scope = _serviceProvider.CreateScope();
        var manager = scope.ServiceProvider.GetRequiredService&lt;ISchedulerManager&gt;();
        var quartzManage = scope.ServiceProvider.GetRequiredService&lt;IQuartzManage&gt;();
        var mapper = scope.ServiceProvider.GetRequiredService&lt;IMapper&gt;();
        var request = new QuerySchedulerListByConditionsRequest()
        {
            Status = 0
        };
        var schedulerList = await manager.QuerySchedulerListByConditionsAsync(request);
        foreach (var scheduler in schedulerList.SchedulerModels)
        {
            if (request is null ||  (scheduler.RequestType != RequestType.REQUEST_TYPE_GET &amp;&amp; scheduler.RequestType != RequestType.REQUEST_TYPE_POST))
                continue;
            var addSchedulerRequest = mapper.Map&lt;SchedulerModel,AddSchedulerRequest&gt;(scheduler);
            //注冊服務
            switch (scheduler.RequestType)
            { 
                case RequestType.REQUEST_TYPE_GET:
                    await quartzManage.AddJobForGet&lt;GetJob&gt;(SchedulerKeyGenerator.JobKey(scheduler.Id), SchedulerKeyGenerator.GroupKey(scheduler.Id)
                        , "",addSchedulerRequest);
                    break;
                case RequestType.REQUEST_TYPE_POST:
                    await quartzManage.AddJobForPost&lt;PostJob&gt;(SchedulerKeyGenerator.JobKey(scheduler.Id), SchedulerKeyGenerator.GroupKey(scheduler.Id), addSchedulerRequest);
                    break;
            }
        }
        _logger.LogInformation("BackGround Service has all register.");
        
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Schedulers Program is shut down,please check out.");
        return Task.CompletedTask;
    }
}</code></pre> 
<h6><span style="color:#1c7331;">2. Program.cs注册后台服务</span></h6> 
<pre><code class="language-cs">builder.Services.AddHostedService&lt;RestartRegisterScheduler&gt;();</code></pre> 
<p></p> 
<p>以上就是.Net 7.0+Quartz项目定时任务调度的全部内容，后期会增加前端页面进行可视化界面进行管理。有任何问题欢迎留言，看到会第一时间回复。</p> 
<p><a class="link-info" href="https://github.com/Austin-codeviewr/org.huage.SchedulerManage" title="源代码地址，吴彦祖刘亦菲们动动小手点star">源代码地址，吴彦祖刘亦菲们动动小手点star</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/05aee4e511f29e97f4a01bbb634f8b33/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GO-基本语法2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab9b2db61e11de4a4b039f99fb81edd2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI开发训练平台功能梳理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>