<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL 锁机制、存储引擎、数据类型 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL 锁机制、存储引擎、数据类型" />
<meta property="og:description" content="目录 数据库锁的分类mysql的存储引擎MyISAMInnoDB mysql常用数据类型数值型字符串日期时间二进制数据关于 enum 枚举 mysql标识符命名规则mysql中utf8、utf8mb4字符集的区别关于null 数据库锁的分类 数据库本身也提供了一些锁，按加锁方式分为
乐观锁：需要增加一个额外的版本号字段，标识记录的数据版本，提交更新时校验数据版本是否一致。实际并没有加锁，并发支持好。悲观锁：数据库本身提供的锁机制，直接调用相关语句即可，可细分为排它锁、共享锁。操作之前需要先加锁，并发支持差。
按照读写权限分为
排它锁：又叫做写锁、X锁，同一时刻，最多只能被一个线程持有，最多只能有1个线程对加锁的这块数据进行读写。共享锁：又叫做读锁、S锁，同一时刻，可以被多线程共同持有，可以有多个线程同时对加锁的这块数据进行读，但读的同时所有线程都不能对这块数据进行写操作，进行写操作需要等对这块数据的所有读操作都完成、共享锁被释放。 排它锁、共享锁都是数据库提供的锁机制，直接调用数据库的相关语句即可。
共享锁可能发生死锁问题：一块数据已经加了共享锁，如果一个事务先对这块数据进行读，再进行写，写操作需要等待共享锁释放才能执行，而这个事务的写操作尚未执行，事务没有提交，一直持有共享锁，写操作永远等不到共享锁释放，即造成了死锁。
其它线程等待获取锁，如果等待指定时间后还没获取到锁，会抛出超时等待异常。
按锁粒度分为
行级锁：针对行加锁，加锁慢；锁粒度小，并发支持好。表级锁：直接给整张表加锁，加锁快；锁粒度大，并发支持差。间隙锁：对InnoDB引擎的表进行范围查找时，给整个范围区间加锁，区间上不存在的行也会被加锁。 eg. where id&gt;=1 and id&lt;=10，操作id在[1,10]上的记录，会给[1,10]整个id区间加锁，加锁范围的整个区间，不仅仅只是区间上存在的记录。
假设之前删除了id=5、id=8的记录，这2行不存在的记录即间隙，也会被锁住，暂时不能被其它线程访问。
mysql的存储引擎 mysql提供了多种存储引擎，最常见的有2种：MyISAM 、InnoDB 。
MyISAM 不支持事务、外键使用表级锁，不支持行级锁，并发支持差。读时自动给表加上读锁（也叫作共享锁），其它事务可以读、但不能写，其它事务要执行写操作需要等待表被释放；写时自动给表加上写锁（也叫作x锁、排它锁），其它事务不能读、写，直到表被释放。支持全文索引，但全文索引一般用ES、Solr，基本不使用mysql的全文索引
MyISAM是5.5之前默认的存储引擎，适合创建
不需要事务、不使用外键的表主要进行读操作的表。由于MyISAM写时要加表锁，性能差，所以不适合创建频繁增删改的表 InnoDB 支持外键。mysql的存储引擎中只有InnoDB支持外键支持事务。默认的事务隔离级别是可重复读默认使用行级锁（通过MVCC实现），也支持表级锁，并发支持好。读时自动给使用的行加读锁，写时自动给使用的行加写锁。
InnoDB是mysql5.5及其之后的默认存储引擎，适合创建
需要使用外键的表对安全性要求高、要使用事务的表频繁增删改的表
执行insert、update、delete语句之前，InnoDB会自动给涉及到的数据集加排它锁，但只有在sql语句走索引时加的排它锁才是行锁，表没有建立索引或者sql语句没有走索引时加的排它锁是表锁。
InnoDB的行锁是给索引中的行加锁，表锁是给数据表中的行加锁。行锁的性能远高于表锁，尽量让sql语句走索引，一来可以快速定位记录位置，二来借助行锁可以实现更高的并发。
mysql常用数据类型 数值型 数据类型描述tinyint1字节，-128 ~ 127。如果指定无符号，则为0~255，下列的其它整型可依此类推smallint2字节，正负3w&#43;mediumint3字节，正负800w&#43;int 或者 integer4字节，正负21亿&#43;bigint8字节，正负900千万亿&#43;float单精度，4字节，10的-38次方double双精度，8字节，10的-308次方decimal定点型 整型不能指定最大存储位数，但可以指定显示位数，需要和 zerofill 搭配使用才有效，超过指定位数时完整展示，长度不够时自动在开头补0凑齐位数，示例 status tinyint(4) zerofill not null comment &#39;状态&#39;。型的显示位数比较鸡肋，不建议指定。
float、double有误差，如果对精度要求很高，比如涉及到钱财，用decimal。
float 、decimal、decimal 都可以指定最大总位数、小数部分固定位数，示例：float(4,2)，总位数最多4位，小数部分固定2位，就是说整数部分最多2位
#小数部分位数不足时，自动在末尾补0 1.1 =&gt; 1.10 #整数部分位数超出时，即超出能存储的最值时，不会报错但会有warning，自动取能存储的最值 111.1 =&gt; 99.99 #整数部分位数ok，小数部分位数超出时，不会报错也没有warning，会自动对小数超出部分四舍五入，以满足小数部分的位数要求 11.1111 =&gt; 11.11 11." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bb8b2c0b17bc31e3b2881d77316aa549/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-02T15:22:28+08:00" />
<meta property="article:modified_time" content="2023-11-02T15:22:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL 锁机制、存储引擎、数据类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><ul><li><a href="#_3" rel="nofollow">数据库锁的分类</a></li><li><a href="#mysql_31" rel="nofollow">mysql的存储引擎</a></li><li><ul><li><a href="#MyISAM_35" rel="nofollow">MyISAM</a></li><li><a href="#InnoDB_47" rel="nofollow">InnoDB</a></li></ul> 
    </li><li><a href="#mysql_65" rel="nofollow">mysql常用数据类型</a></li><li><ul><li><a href="#_66" rel="nofollow">数值型</a></li><li><a href="#_97" rel="nofollow">字符串</a></li><li><a href="#_113" rel="nofollow">日期时间</a></li><li><a href="#_149" rel="nofollow">二进制数据</a></li><li><a href="#_enum__159" rel="nofollow">关于 enum 枚举</a></li></ul> 
    </li><li><a href="#mysql_170" rel="nofollow">mysql标识符命名规则</a></li><li><a href="#mysqlutf8utf8mb4_180" rel="nofollow">mysql中utf8、utf8mb4字符集的区别</a></li><li><a href="#null_189" rel="nofollow">关于null</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br>   
<p></p> 
<h4><a id="_3"></a>数据库锁的分类</h4> 
<p>数据库本身也提供了一些锁，按加锁方式分为</p> 
<ul><li>乐观锁：需要增加一个额外的版本号字段，标识记录的数据版本，提交更新时校验数据版本是否一致。实际并没有加锁，并发支持好。</li><li>悲观锁：数据库本身提供的锁机制，直接调用相关语句即可，可细分为排它锁、共享锁。操作之前需要先加锁，并发支持差。<br>  </li></ul> 
<p>按照读写权限分为</p> 
<ul><li>排它锁：又叫做写锁、X锁，同一时刻，最多只能被一个线程持有，最多只能有1个线程对加锁的这块数据进行读写。</li><li>共享锁：又叫做读锁、S锁，同一时刻，可以被多线程共同持有，可以有多个线程同时对加锁的这块数据进行读，但读的同时所有线程都不能对这块数据进行写操作，进行写操作需要等对这块数据的所有读操作都完成、共享锁被释放。</li></ul> 
<p>排它锁、共享锁都是数据库提供的锁机制，直接调用数据库的相关语句即可。</p> 
<p>共享锁可能发生死锁问题：一块数据已经加了共享锁，如果一个事务先对这块数据进行读，再进行写，写操作需要等待共享锁释放才能执行，而这个事务的写操作尚未执行，事务没有提交，一直持有共享锁，写操作永远等不到共享锁释放，即造成了死锁。</p> 
<p>其它线程等待获取锁，如果等待指定时间后还没获取到锁，会抛出超时等待异常。<br>  </p> 
<p>按锁粒度分为</p> 
<ul><li>行级锁：针对行加锁，加锁慢；锁粒度小，并发支持好。</li><li>表级锁：直接给整张表加锁，加锁快；锁粒度大，并发支持差。</li><li>间隙锁：对InnoDB引擎的表进行范围查找时，给整个范围区间加锁，区间上不存在的行也会被加锁。</li></ul> 
<blockquote> 
 <p>eg. where id&gt;=1 and id&lt;=10，操作id在[1,10]上的记录，会给[1,10]整个id区间加锁，加锁范围的整个区间，不仅仅只是区间上存在的记录。<br> <br> 假设之前删除了id=5、id=8的记录，这2行不存在的记录即间隙，也会被锁住，暂时不能被其它线程访问。</p> 
</blockquote> 
<p> </p> 
<h4><a id="mysql_31"></a>mysql的存储引擎</h4> 
<p>mysql提供了多种存储引擎，最常见的有2种：MyISAM 、InnoDB 。<br>  </p> 
<h5><a id="MyISAM_35"></a>MyISAM</h5> 
<ul><li>不支持事务、外键</li><li>使用表级锁，不支持行级锁，并发支持差。读时自动给表加上读锁（也叫作共享锁），其它事务可以读、但不能写，其它事务要执行写操作需要等待表被释放；写时自动给表加上写锁（也叫作x锁、排它锁），其它事务不能读、写，直到表被释放。</li><li>支持全文索引，但全文索引一般用ES、Solr，基本不使用mysql的全文索引<br>  </li></ul> 
<p>MyISAM是5.5之前默认的存储引擎，适合创建</p> 
<ul><li>不需要事务、不使用外键的表</li><li>主要进行读操作的表。由于MyISAM写时要加表锁，性能差，所以不适合创建频繁增删改的表</li></ul> 
<p> </p> 
<h5><a id="InnoDB_47"></a>InnoDB</h5> 
<ul><li>支持外键。mysql的存储引擎中只有InnoDB支持外键</li><li>支持事务。默认的事务隔离级别是可重复读</li><li>默认使用行级锁（通过MVCC实现），也支持表级锁，并发支持好。读时自动给使用的行加读锁，写时自动给使用的行加写锁。<br>  </li></ul> 
<p>InnoDB是mysql5.5及其之后的默认存储引擎，适合创建</p> 
<ul><li>需要使用外键的表</li><li>对安全性要求高、要使用事务的表</li><li>频繁增删改的表<br>  </li></ul> 
<p>执行insert、update、delete语句之前，InnoDB会自动给涉及到的数据集加排它锁，但只有在sql语句走索引时加的排它锁才是行锁，表没有建立索引或者sql语句没有走索引时加的排它锁是表锁。</p> 
<p>InnoDB的行锁是给索引中的行加锁，表锁是给数据表中的行加锁。行锁的性能远高于表锁，尽量让sql语句走索引，一来可以快速定位记录位置，二来借助行锁可以实现更高的并发。</p> 
<p> </p> 
<h4><a id="mysql_65"></a>mysql常用数据类型</h4> 
<h5><a id="_66"></a>数值型</h5> 
<table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">tinyint</td><td align="left">1字节，-128 ~ 127。如果指定无符号，则为0~255，下列的其它整型可依此类推</td></tr><tr><td align="left">smallint</td><td align="left">2字节，正负3w+</td></tr><tr><td align="left">mediumint</td><td align="left">3字节，正负800w+</td></tr><tr><td align="left">int 或者 integer</td><td align="left">4字节，正负21亿+</td></tr><tr><td align="left">bigint</td><td align="left">8字节，正负900千万亿+</td></tr><tr><td align="left">float</td><td align="left">单精度，4字节，10的-38次方</td></tr><tr><td align="left">double</td><td align="left">双精度，8字节，10的-308次方</td></tr><tr><td align="left">decimal</td><td align="left">定点型</td></tr></tbody></table> 
<p>整型不能指定最大存储位数，但可以指定显示位数，需要和 zerofill 搭配使用才有效，超过指定位数时完整展示，长度不够时自动在开头补0凑齐位数，示例 <code>status tinyint(4) zerofill not null comment '状态'</code>。型的显示位数比较鸡肋，不建议指定。</p> 
<p>float、double有误差，如果对精度要求很高，比如涉及到钱财，用decimal。</p> 
<p>float 、decimal、decimal 都可以指定最大总位数、小数部分固定位数，示例：float(4,2)，总位数最多4位，小数部分固定2位，就是说整数部分最多2位</p> 
<pre><code class="prism language-bash"><span class="token comment">#小数部分位数不足时，自动在末尾补0</span>
<span class="token number">1.1</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">1.10</span>

<span class="token comment">#整数部分位数超出时，即超出能存储的最值时，不会报错但会有warning，自动取能存储的最值</span>
<span class="token number">111.1</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">99.99</span>

<span class="token comment">#整数部分位数ok，小数部分位数超出时，不会报错也没有warning，会自动对小数超出部分四舍五入，以满足小数部分的位数要求</span>
<span class="token number">11.1111</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">11.11</span>
<span class="token number">11.1151</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">11.12</span>
</code></pre> 
<p> </p> 
<h5><a id="_97"></a>字符串</h5> 
<table><thead><tr><th align="left">数据类型</th><th align="left">最大字符数</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">255</td></tr><tr><td align="left">varchar</td><td align="left">6w+</td></tr><tr><td align="left">tinytext</td><td align="left">255</td></tr><tr><td align="left">text</td><td align="left">6w+</td></tr><tr><td align="left">mediumtext</td><td align="left">1千万+</td></tr><tr><td align="left">longtext</td><td align="left">42亿+</td></tr></tbody></table> 
<p>char是定长字符串，内容长度不够时自动补空格，适合存储固定长度的字符串，varchar是变长字符串。</p> 
<p>char、varchar可指定最大字符数、默认值，eg. varchar(5) 最多只能存储5个字符，其它字符串类型不能指定长度、默认值。</p> 
<p> </p> 
<h5><a id="_113"></a>日期时间</h5> 
<table><thead><tr><th align="left">数据类型</th><th align="left">范围</th></tr></thead><tbody><tr><td align="left">time</td><td align="left">hh:mm:ss，00:00:00~23:59:59</td></tr><tr><td align="left">date</td><td align="left">yyyy-MM-dd，1000-01-01 ~ 9999-12-31</td></tr><tr><td align="left">datetime</td><td align="left">格式：yyyy-MM-dd hh:mm:ss ；8字节，1000-01-01 00:00:00 ~ 9999-12-31 23:59:59；与时区无关</td></tr><tr><td align="left">timestamp</td><td align="left">格式：yyyy-MM-dd hh:mm:ss；4字节，1970-01-01 00:00:00 ~ 2038-01-19…；与时区有关（受时区影响）</td></tr></tbody></table> 
<p> </p> 
<p><strong>使用时间类型的注意点</strong><br> java.util.Date 是毫秒级时间，mysql中的 time、datetime、timestamp 默认保存到秒级，会自动对毫秒部分进行舍入，[0, 500)毫秒直接舍弃，[500, 999]毫秒则进1秒。示例</p> 
<table><thead><tr><th align="left">java.util.Date</th><th align="left">mysql datetime</th></tr></thead><tbody><tr><td align="left">2020-01-01 00:00:00.000</td><td align="left">2020-01-01 00:00:00</td></tr><tr><td align="left">2020-01-01 00:00:00.400</td><td align="left">2020-01-01 00:00:00</td></tr><tr><td align="left">2020-01-01 00:00:00.500</td><td align="left">2020-01-01 00:00:01</td></tr></tbody></table> 
<pre><code class="prism language-java"><span class="token comment">//假设是 2020-01-01 00:00:00.500</span>
<span class="token class-name">Date</span> nowTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//db中实际保存的 finshTime 是 2020-01-01 00:00:01</span>
<span class="token class-name">OrderDao</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">OrderPo</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">orderNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">finshTime</span><span class="token punctuation">(</span>nowTime<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//用 finsh_time &lt;= #{nowTime} 查不到刚才插入的记录</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderPo</span><span class="token punctuation">&gt;</span></span> orderPos <span class="token operator">=</span> <span class="token class-name">OrderDao</span><span class="token punctuation">.</span><span class="token function">listByQo</span><span class="token punctuation">(</span><span class="token class-name">OrderQo</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">maxFinshTime</span><span class="token punctuation">(</span>nowTime<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p> </p> 
<h5><a id="_149"></a>二进制数据</h5> 
<ul><li>blob</li><li>tinyblob</li><li>mediumblob</li><li>longblob</li></ul> 
<p>mysql可以存储二进制数据，但操作二进制数据的性能并不好，尽量少用二进制数据类型。</p> 
<p> </p> 
<h5><a id="_enum__159"></a>关于 enum 枚举</h5> 
<p>mysql支持enum这种数据类型，插入枚举类型时，mysql会先检查值是否在允许值列表中，如果不在则检查是否在枚举的索引列表中，在枚举索引列表中的值也可以插入。</p> 
<p>比如enum的允许值是字符串"0"、“1”、“2”，对应的索引列表是1、2、3（从1开始）</p> 
<ul><li>插入数值3，3不在允许值列表中，但3在索引值列表中，所以能插入；</li><li>插入字符串"3"时，3不再允许值列表中，自动转换为整型，在索引值列表中，也能插入。</li></ul> 
<p>不熟悉mysql枚举特性的人使用容易出错，尽量避免使用枚举。</p> 
<p> </p> 
<h4><a id="mysql_170"></a>mysql标识符命名规则</h4> 
<p>mysql标识符标识符包括表名、字段名、数据库编程中的变量名</p> 
<ul><li>可包含字母、数字、三个特殊字符（#_$），必须以字母开头</li><li>使用多个单词组成时，单词之间用下划线_连接</li><li>不能使用mysql的关键字、保留字</li></ul> 
<p>建表时尤其要注意：字段名不要使用数据库关键字，比如 type，可以换成 xxx_type</p> 
<p> </p> 
<h4><a id="mysqlutf8utf8mb4_180"></a>mysql中utf8、utf8mb4字符集的区别</h4> 
<p>utf8的表示一个字符最大可用三个字节，基本可以表示所有字符，但表示不了极其生僻的字符、新增的字符，比如Emoji 表情。</p> 
<p>utf8mb4是utf8的超集，mb4即most bytes 4的意思，用于兼容四字节的unicode。</p> 
<p>一般使用utf8就够了，当然使用utf8mb4兼容性更好。</p> 
<p> </p> 
<h4><a id="null_189"></a>关于null</h4> 
<p>在mysql中，如果不指定字段not null，字段默认可以为null。</p> 
<ul><li>存储：null不能像字符串、数值一样直接存储，需要mysql特殊处理。空字符串占用的长度是0，数值0占用的长度是1，null占用的长度并非是0，而是1。</li><li>对索引的影响：mysql难以对值可以为null的字段进行优化。</li><li>作为操作条件：判断字段是否为null，不能用=、!=、&lt;&gt;，要用is null、is not null。mysql会给!=会自动加上is not null，比如 username != ‘xxx’ ，相当于 username != ‘xxx’ and username is not null。</li><li>参与排序：null会当做最小值对待，asc排序时null会被放在最前面，desc排序时null会被放在最后面。</li><li>参与聚合：值为null的行不参与聚合。比如50个学生，10人缺考成绩是null，avg(score)、sum(score)统计的都是40个考了的同学的score，会先去除值为null的行再进行聚合。</li><li>参与计算：null参与计算时，结果都是null。比如select 1+null; 结果是null。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4cc7e9d7914c3237b2b850c6fc74bbb9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">输入一行字符，分别统计出其中英文字母、空格、数字和其他字符的个数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26cbe74241da247c7055631768980186/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据表 设计、规范</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>