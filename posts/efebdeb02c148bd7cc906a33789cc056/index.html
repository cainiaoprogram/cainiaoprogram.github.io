<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MyBatis自定义映射resultMap，处理一对多，多对一 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MyBatis自定义映射resultMap，处理一对多，多对一" />
<meta property="og:description" content="1、自定义映射resultMap 复习：查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射 关系
resultType：自动映射，用于属性名和表中字段名一致的情况 （或设置了下划线映射为驼峰）。
resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况
1.1、resultMap处理字段和属性的映射关系 若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射。
（补充：当字段名和属性名一样时，字段和属性是一 一对应的，jdbc会通过反射实现这种对应，所以，能查到完整的对象。当不一样时，又没有自己处理，那字段和属性就对应不上，查出来的对象属性全是null）
&lt;!-- select标签里的resultMap属性设置使用哪个映射规则 resultMap标签：设置自定义映射（自定义字段和属性的映射规则） 属性： id：表示自定义映射的唯一标识，即给你这个具体的映射规则resultMap起一个唯一名字 type：查询的数据要映射的实体类的类型 子标签： id标签：设置主键的映射关系 result标签：设置普通字段的映射关系。即你想要你的结果是怎么映射的，怎么一一对应填值的 association标签：设置多对一的映射关系。比如Employee类中有一个Department属性 collection标签：设置一对多的映射关系。比如Department类中有一个。List&lt;Employee&gt;属性 属性： property：设置映射关系中实体类中的属性名，必须是java中实体类的属性名 column：设置映射关系中的字段名.必须是sql查询出的某个字段（出现在sql查询语句的字段） 因为是自定义，所以，java中的属性名不是驼峰的也可，mysql里的属性不是_也可。 property和column的先后位置任意 --&gt; &lt;resultMap id=&#34;userResultMap&#34; type=&#34;User&#34;&gt; &lt;id property=&#34;userId&#34; column=&#34;userid&#34;&gt;&lt;/id&gt; &lt;result property=&#34;userName&#34; column=&#34;user_name&#34;&gt;&lt;/result&gt; &lt;result property=&#34;password&#34; column=&#34;password&#34;&gt;&lt;/result&gt; &lt;result property=&#34;age&#34; column=&#34;age&#34;&gt;&lt;/result&gt; &lt;result property=&#34;sex&#34; column=&#34;sex&#34;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--List&lt;User&gt; testMohu(@Param(&#34;mohu&#34;) String mohu);使用刚才定义的映射规则--&gt; &lt;select id=&#34;testMohu&#34; resultMap=&#34;userResultMap&#34;&gt; &lt;!--select * from t_user where username like &#39;%${mohu}%&#39;--&gt; select id,user_name,password,age,sex from t_user where user_name like concat(&#39;%&#39;,#{mohu},&#39;%&#39;) &lt;/select&gt; 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则，实体类中的属性 名符合Java的规则, 此时也可通过以下3种方式处理字段名和实体类中的属性的映射关系" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/efebdeb02c148bd7cc906a33789cc056/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-14T10:50:36+08:00" />
<meta property="article:modified_time" content="2023-10-14T10:50:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MyBatis自定义映射resultMap，处理一对多，多对一</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1、自定义映射resultMap</h3> 
<p>复习：查询的标签select必须设置属性resultType或resultMap，用于设置<strong>实体类和数据库表的映射 关系</strong></p> 
<p>result<strong>Type</strong>：自动映射，用于属性名和表中字段名一致的情况 （或设置了下划线映射为驼峰）。</p> 
<p>result<strong>Map</strong>：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</p> 
<h4>1.1、resultMap处理字段和属性的映射关系</h4> 
<blockquote> 
 <p>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射。</p> 
 <p>（补充：当字段名和属性名一样时，字段和属性是一 一对应的，jdbc会通过反射实现这种对应，所以，能查到完整的对象。当不一样时，又没有自己处理，那字段和属性就对应不上，查出来的对象属性全是null）</p> 
</blockquote> 
<pre><code class="language-XML">&lt;!--
	select标签里的resultMap属性设置使用哪个映射规则
    resultMap标签：设置自定义映射（自定义字段和属性的映射规则）
            	属性： id：表示自定义映射的唯一标识，即给你这个具体的映射规则resultMap起一个唯一名字
                	  type：查询的数据要映射的实体类的类型
    子标签：
        id标签：设置主键的映射关系
        result标签：设置普通字段的映射关系。即你想要你的结果是怎么映射的，怎么一一对应填值的
        association标签：设置多对一的映射关系。比如Employee类中有一个Department属性
        collection标签：设置一对多的映射关系。比如Department类中有一个。List&lt;Employee&gt;属性
        属性：
        property：设置映射关系中实体类中的属性名，必须是java中实体类的属性名
        column：设置映射关系中的字段名.必须是sql查询出的某个字段（出现在sql查询语句的字段）
因为是自定义，所以，java中的属性名不是驼峰的也可，mysql里的属性不是_也可。
		property和column的先后位置任意
--&gt;
&lt;resultMap id="userResultMap" type="User"&gt;
    &lt;id property="userId" column="userid"&gt;&lt;/id&gt;
    &lt;result property="userName" column="user_name"&gt;&lt;/result&gt;
    &lt;result property="password" column="password"&gt;&lt;/result&gt;
    &lt;result property="age" column="age"&gt;&lt;/result&gt;
    &lt;result property="sex" column="sex"&gt;&lt;/result&gt;
&lt;/resultMap&gt;
&lt;!--List&lt;User&gt; testMohu(@Param("mohu") String mohu);使用刚才定义的映射规则--&gt;
&lt;select id="testMohu" resultMap="userResultMap"&gt;
    &lt;!--select * from t_user where username like '%${mohu}%'--&gt;
    select id,user_name,password,age,sex from t_user where user_name like concat('%',#{mohu},'%')
&lt;/select&gt;</code></pre> 
<blockquote> 
 <p>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则，实体类中的属性 名符合Java的规则, 此时也可通过以下3种方式处理字段名和实体类中的属性的映射关系</p> 
 <p></p> 
 <p>a&gt;可以通过为字段起别名的方式，保证和实体类中的属性名保持一致</p> 
 <p></p> 
 <p>b&gt;可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可 以在查询表中数据时，自动将_类型的字段名转换为驼峰 （推荐）</p> 
 <p>例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为 userName</p> 
 <p></p> 
 <p>c&gt; 使用resultMap</p> 
</blockquote> 
<h4>1.2、多对一映射处理（对象属性）</h4> 
<blockquote> 
 <p>场景模拟：</p> 
 <p>查询员工信息以及员工所对应的【部门信息】</p> 
 <p>员工表和部门表的关系是多对一</p> 
</blockquote> 
<h5>1.2.1、级联方式处理映射关系</h5> 
<p><img alt="" height="394" src="https://images2.imgbox.com/47/25/4zsrD7HY_o.png" width="402"></p> 
<p><span style="background-color:#a2e043;">多对一映射：多位员工Emp对应一个部门Dept</span></p> 
<pre><code class="language-java">public class Emp {
    private Integer empId;
    private String empName;
    private Integer age;
    private String gender;
    //查询员工对应的部门信息时，必须要在Emp类中写一个Dept属性。且提供 get、set，构造器不用加上dept
    // 表与表有关系，在数据库中，员工表里有部门id字段。
    //表与表之间的关系体现在java中，就是在类中加入对象属性。因为员工和部门是多对一的关系，所以，在员工类中
    // 加一个Dept类型的属性。  
    //补充：若是一对多，那要在少的一方加一个集合，比如，在Dept里里加一个List&lt;Emp&gt;类型的属性.
    ///根据需求判断 只在一方加，还是两方都加。
    private Dept dept;//这就是所谓的  对象属性
    
   public Emp() {
    }

    public Emp(Integer empId, String empName, Integer age, String gender) {
        this.empId = empId;
        this.empName = empName;
        this.age = age;
        this.gender = gender;
    }
    。。。。。。
	//提供所有属性的get、set方法，重写toString
}</code></pre> 
<pre><code class="language-java">public class Dept {
    private Integer deptId;
    private String depName;
    public Dept() {
    }

    public Dept(Integer deptId, String depName) {
        this.deptId = deptId;
        this.depName = depName;
    }
    。。。。。。。。。。。。。。。。。。。。。。。
    //提供所有属性的get、set方法，重写toString
}</code></pre> 
<p><span style="background-color:#a2e043;">Mapper接口：</span></p> 
<pre><code class="language-java">public interface EmpMapper {
    /**
     * 查询指定员工的信息以及他所在部门的信息
     * @param empId
     * @return
     */
    Emp getEmpAndDeptByEid(@Param("empId") int empId);
}</code></pre> 
<p><span style="background-color:#38d8f0;">想明白字段该和哪个属性进行映射</span></p> 
<p><span style="background-color:#38d8f0;">因为dept是Emp类里的对象属性，所以，字段dept_name 对应 dept.depName</span></p> 
<pre><code class="language-XML">    &lt;resultMap id="empDeptMap" type="Emp"&gt;
        &lt;id column="emp_id" property="empId"&gt;&lt;/id&gt;
        &lt;result column="emp_name" property="empName"&gt;&lt;/result&gt;
        &lt;result column="age" property="age"&gt;&lt;/result&gt;
        &lt;result column="gender" property="gender"&gt;&lt;/result&gt;
        
        &lt;!--这里仍然用result标签。需要部门表里的哪几些字段，这就写几个，但要保证java类中有属性，且提供了get、set方法。dept是Emp类中的属性，depName是dept对象的属性，实际调用getDeptName方法--&gt;
        &lt;result column="dept_name" property="dept.depName"&gt;&lt;/result&gt;
    &lt;/resultMap&gt;
    &lt;!--Emp getEmpAndDeptByEid(@Param("empId") int empId);--&gt;
    &lt;select id="getEmpAndDeptByEid" resultMap="empDeptMap"&gt;
        SELECT t_emp.*, t_dept.dept_name
        FROM t_emp NATURAL JOIN t_dept
        WHERE t_emp.emp_id=#{empId}
    &lt;/select&gt;</code></pre> 
<p>根据自己具体业务需求写SQL语句，有时候可能写成外连接。</p> 
<h5 style="background-color:transparent;"><span style="background-color:#ffd900;">1.2.2、使用association处理映射关系(推荐)</span></h5> 
<p>同上。需要先在java类Emp中添加一个属性private Dept dept ；并提供get、set方法，构造器不用加上dept。重写toString。</p> 
<p>association标签：处理多对一的映射关系（处理实体类类型的属性）。比如Employee类中有一个Department属性</p> 
<p>用上这个标签更好理解，阅读也方便。我个人比较喜欢这种方式。</p> 
<p>将映射文件写成下面这样：</p> 
<pre><code class="language-XML">    &lt;resultMap id="empDeptMap" type="Emp"&gt;
        &lt;id column="emp_id" property="empId"&gt;&lt;/id&gt;
        &lt;result column="emp_name" property="empName"&gt;&lt;/result&gt;
        &lt;result column="age" property="age"&gt;&lt;/result&gt;
        &lt;result column="gender" property="gender"&gt;&lt;/result&gt;
        &lt;!--&lt;result column="dept_name" property="dept.deptName"&gt;&lt;/result&gt;--&gt;
        &lt;!--&lt;result column="dept_id" property="dept.deptId"&gt;&lt;/result&gt;--&gt;
        &lt;!--只有这发生了变化。--&gt;
        &lt;association property="dept" javaType="Dept"&gt;
            &lt;!--也是需要哪些部门表中的字段，就写哪些。因为我的部门表里总共2个字段，而且查的是t_dept.*,所以，我这写了2个。 --&gt;
            &lt;id column="dept_id" property="deptId"&gt;&lt;/id&gt;
            &lt;result column="dept_name" property="deptName"&gt;&lt;/result&gt;
      
        &lt;/association&gt;
    &lt;/resultMap&gt;

    &lt;!--Emp getEmpAndDeptByEid(@Param("empId") int empId);--&gt;
    &lt;select id="getEmpAndDeptByEid" resultMap="empDeptMap"&gt;
        SELECT t_emp.*, t_dept.*
        FROM t_emp NATURAL JOIN t_dept
        WHERE t_emp.emp_id=#{empId}
    &lt;/select&gt;</code></pre> 
<pre><code class="language-java">  @Test
    public void testEmpDept(){
        SqlSession sqlSession = sqlSessionUtils.getSqlSession();
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        Emp empAndDeptByEid = mapper.getEmpAndDeptByEid(1);
        System.out.println(empAndDeptByEid);
        //Emp{empId=1, empName='赵四', age=20, gender='男', dept=Dept{deptId=1, depName='a部门'}}

    }</code></pre> 
<h5 style="background-color:transparent;">1.2.3、分步查询</h5> 
<p>文字记录不太清楚</p> 
<p>去看尚硅谷杨博超老师的SSM视频。或其他学习资源</p> 
<h4>1.3、一对多映射处理( 集合属性)</h4> 
<p>多对一反过来就是一对多，一个部门对应多个员工。需要在部门类中加一个<code>List&lt;Emp&gt; emps</code>属性，提供get、set方法，toString。 构造器中不用加<code>List&lt;Emp&gt; emps</code>。 <strong>处理一对多的映射关系：</strong></p> 
<ul><li> <p>方式一：collection</p> </li><li> <p>方式二：分步查询</p> </li></ul> 
<pre><code class="language-java">public class Dept {
    private Integer deptId;
    private String deptName;
	//一对多，一个部门里有多个员工
    private List&lt;Emp&gt; emps;
    ..........
}</code></pre> 
<p>需求：根据部门id查询部门以及该部门中所有员工的信息</p> 
<h5>1.3.1、collection</h5> 
<p>根据具体业务需要写sql语句，看是否需要使用左外连接或右外连接. 例如下面的左外连接，因为有的人没有部门，但是又想查所有人。</p> 
<pre><code class="language-XML">SELECT *
FROM t_dept
LEFT JOIN t_emp ON t_dept.dept_id = t_emp.dept_id
WHERE t_dept.dept_id=#{deptId}

* 表示查询2表的所有字段</code></pre> 
<p>我的例子用的是自然连接:</p> 
<pre><code class="language-XML">SELECT *  # 两个表的所有字段
FROM t_dept
NATURAL JOIN t_emp WHERE t_dept.dept_id=#{deptId}</code></pre> 
<pre><code class="language-java">DeptMapper接口里：
/**
* 根据部门id查新部门以及该部门中的员工信息
* @param did
* @return
*/
  Dept getDeptAndEmpByDeptId(@Param("deptId") int deptId);</code></pre> 
<pre><code class="language-XML">   DeptMapper.xml 里：

&lt;resultMap id="deptAndEmpResultMap" type="Dept"&gt;
        &lt;id column="dept_id" property="deptId"&gt;&lt;/id&gt;
        &lt;result column="dept_name" property="deptName"&gt;&lt;/result&gt;
    &lt;!--collection标签：处理一对多的关系映射（处理属性为集合类型的）。一个Dept对象里有多个Emp对象--&gt;
        &lt;!--ofType属性：设置集合里面存储的数据类型是啥。存储的是Emp类型--&gt;
        &lt;!--因为collection标签已经说明是了处理集合的，所以不能用javaType
collection是集合的意思，List&lt;Emp&gt;正好是一个集合，所以用来处理一对多--&gt;
        &lt;collection property="emps" ofType="Emp"&gt;
            &lt;id column="emp_id" property="empId"&gt;&lt;/id&gt;
            &lt;result column="emp_name" property="empName"&gt;&lt;/result&gt;
            &lt;result column="age" property="age"&gt;&lt;/result&gt;
            &lt;result column="gender" property="gender"&gt;&lt;/result&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;!--Dept getDeptAndEmpByDeptId(@Param("deptId") int deptId);--&gt;
    &lt;select id="getDeptAndEmpByDeptId" resultMap="deptAndEmpResultMap"&gt;
        SELECT t_dept.*,t_emp.*
        FROM t_dept
                 NATURAL JOIN t_emp WHERE t_dept.dept_id=#{deptId}
    &lt;/select&gt;</code></pre> 
<pre><code class="language-java">    @Test
    public void testGetDeptAndEmpByDeptId(){
        SqlSession sqlSession = sqlSessionUtils.getSqlSession();
        DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);
        Dept deptAndEmpByDeptId = mapper.getDeptAndEmpByDeptId(1);
        System.out.println(deptAndEmpByDeptId);

    }

DEBUG 09-16 19:51:25,389 ==&gt;  Preparing: SELECT t_dept.*,t_emp.* FROM t_dept NATURAL JOIN t_emp WHERE t_dept.dept_id=? (BaseJdbcLogger.java:137) 
DEBUG 09-16 19:51:25,421 ==&gt; Parameters: 1(Integer) (BaseJdbcLogger.java:137) 
DEBUG 09-16 19:51:25,455 &lt;==      Total: 2 (BaseJdbcLogger.java:137) 
    
Dept{deptId=1, deptName='a部门',
     emps=[
           Emp{empId=1, empName='aaaa', age=20, gender='男', dept=null},
           Emp{empId=2, empName='bbbb', age=23, gender='男', dept=null}
          ]
    }
</code></pre> 
<p><span style="background-color:#a2e043;">个人理解：</span></p> 
<p>association 是“关系，关联”的意思，专门用来 负责属性为实体类对象（非List集合）时的映射规则，</p> 
<p>collection 是“集合”的意思，专门用来负责属性为List&lt;xxx&gt; 时的映射规则。</p> 
<p>所以，<span style="background-color:#a2e043;">association负责“多对一”，collection负责”一对多“</span>。</p> 
<h5 style="background-color:transparent;">1.3.2、分步查询</h5> 
<p>去看尚硅谷杨博超老师的SSM视频。或其他学习资源</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3004c263f016efd8389aeb5f20341819/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NodeMCU ESP8266 基于Arduino IDE的串口使用详解（图文并茂）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f02d13ea74e65fbfd87fc57bc225df5b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PLSQL中Initialization error解决办法及PLSQL位数查看方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>