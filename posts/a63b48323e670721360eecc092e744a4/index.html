<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>简单介绍GMP调度器模型 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="简单介绍GMP调度器模型" />
<meta property="og:description" content="一、调度器的由来 动机：单进程计算机只能一个任务一个任务地处理；CPU浪费
CPU调度器：轮询调度进程A\B\C，时间片轮转调度。这种有切换成本。
多线程的劣势：
1.每个线程创建一个线程，导致频繁切换线程CPU消耗
2.每个进程、线程占用一定内存
N：1的协程关系，线程调度CPU，通过一个调度器切换协程，避免CPU高消耗
go协程：改了内存-&gt;几KB；灵活调度；
GM调度器模型的缺点：
1.创建、销毁、调度G需要频繁地获取锁，造成激烈地锁竞争
2.从M转移到G会造成延迟和额外的系统负载
3.系统调用导致频繁的线程阻塞和取消阻塞操作增加了系统开销
二、GMP模型 新建goroutine会放到localP中，最大256G，不行再放到全局队列中
P数量可以设置，M数量根据程序动态销毁
三、GMP设计 设计策略分为四种：复用线程、利用并行、抢占、全局G队列
复用线程的两个机制：working stealing和hand off
3.1 working stealing机制 M2空闲，所以从M1从偷取协程。（先从localP偷，再从global偷）
3.2 hand off机制 M1阻塞在G1，创建和唤醒一个线程，绑定G1和M1
3.3 利用并行：GOMAXPROCS = CPU核数/2 3.4 新的协程会抢占老协程 四、go func()执行过程 大循环：创建协程-》进入局部队列-》M获取G-》小循环（调度-》执行-》时间片用完）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a63b48323e670721360eecc092e744a4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-17T20:13:34+08:00" />
<meta property="article:modified_time" content="2023-07-17T20:13:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">简单介绍GMP调度器模型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>一、调度器的由来</h2> 
<p><strong>动机</strong>：单进程计算机只能一个任务一个任务地处理；CPU浪费<br> <strong>CPU调度器</strong>：轮询调度进程A\B\C，时间片轮转调度。这种有切换成本。<br> <strong>多线程的劣势</strong>：<br> 1.每个线程创建一个线程，导致频繁切换线程CPU消耗<br> 2.每个进程、线程占用一定内存<br> <img src="https://images2.imgbox.com/d6/f3/xGVX2A2F_o.png" alt="在这里插入图片描述"></p> 
<p><strong>N：1的协程关系</strong>，线程调度CPU，通过一个调度器切换协程，避免CPU高消耗<br> <img src="https://images2.imgbox.com/e7/99/RTTgNiir_o.png" alt="在这里插入图片描述"></p> 
<p><strong>go协程</strong>：改了内存-&gt;几KB；灵活调度；<br> GM调度器模型的<strong>缺点</strong>：<br> 1.创建、销毁、调度G需要频繁地获取锁，造成激烈地锁竞争<br> 2.从M转移到G会造成延迟和额外的系统负载<br> 3.系统调用导致频繁的线程阻塞和取消阻塞操作增加了系统开销</p> 
<h2><a id="GMP_17"></a>二、GMP模型</h2> 
<p><img src="https://images2.imgbox.com/c2/a0/j6h9HeCh_o.png" alt="在这里插入图片描述"></p> 
<p>新建goroutine会放到localP中，最大256G，不行再放到全局队列中<br> <img src="https://images2.imgbox.com/d8/0a/oDFTOaE1_o.png" alt="在这里插入图片描述"></p> 
<p>P数量可以设置，M数量根据程序动态销毁</p> 
<h2><a id="GMP_24"></a>三、GMP设计</h2> 
<p><strong>设计策略分为四种：复用线程、利用并行、抢占、全局G队列</strong><br> 复用线程的两个机制：working stealing和hand off</p> 
<h3><a id="31_working_stealing_27"></a>3.1 working stealing机制</h3> 
<p><img src="https://images2.imgbox.com/ac/25/JyjcvD9E_o.png" alt="在这里插入图片描述"></p> 
<p>M2空闲，所以从M1从偷取协程。（先从localP偷，再从global偷）</p> 
<h3><a id="32_hand_off_31"></a>3.2 hand off机制</h3> 
<p><img src="https://images2.imgbox.com/44/22/EZay6eRJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c0/09/3UXLxyme_o.png" alt="在这里插入图片描述"></p> 
<p>M1阻塞在G1，创建和唤醒一个线程，绑定G1和M1</p> 
<h3><a id="33_GOMAXPROCS__CPU2_36"></a>3.3 利用并行：GOMAXPROCS = CPU核数/2</h3> 
<h3><a id="34__37"></a>3.4 新的协程会抢占老协程</h3> 
<h2><a id="go_func_38"></a>四、go func()执行过程</h2> 
<p><img src="https://images2.imgbox.com/ae/d4/agfidoo8_o.png" alt="在这里插入图片描述"></p> 
<p>大循环：创建协程-》进入局部队列-》M获取G-》小循环（调度-》执行-》时间片用完）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9312cfc9781d3bb43e0c6348d410f723/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">BERT系列算法解读:（RoBERTa/ALBERT/DistilBERT/Transformer/Hugging Face/NLP/预训练模型/模型蒸馏）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53b5ac5418d01b4ed00e7ebc86e51821/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大文件上传最全方案：秒传、断点续传、分片上传</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>