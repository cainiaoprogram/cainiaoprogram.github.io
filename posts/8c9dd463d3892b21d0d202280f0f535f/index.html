<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 7.0 Camera架构源码分析1 - CameraService启动 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 7.0 Camera架构源码分析1 - CameraService启动" />
<meta property="og:description" content="本系列教程主要讲解Camera从APP层到HAL层的整个流程，第一篇先讲解CameraService的启动，后面会讲解open、preview、takepicture的流程。
Android 7.0之前CameraService是在mediaserver进程中注册的，看下Android 6.0的代码：
//path: frameworks\av\media\mediaserver\main_mediaserver.cpp int main() { sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ALOGI(&#34;ServiceManager: %p&#34;, sm.get()); AudioFlinger::instantiate(); MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); //初始化相机服务 CameraService::instantiate(); AudioPolicyService::instantiate(); SoundTriggerHwService::instantiate(); RadioService::instantiate(); registerExtensions(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); } 接着看下Android 7.0中main_mediaserver.cpp的代码，发现没有了CameraService::instantiate(); 也就是说Android 7.0之后就不在main_mediaserver.cpp中注册了。
//没有CameraService::instantiate()，也少了几个别的服务，这里只关注CameraService int main(int argc __unused, char **argv __unused) { signal(SIGPIPE, SIG_IGN); sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm(defaultServiceManager()); ALOGI(&#34;ServiceManager: %p&#34;, sm.get()); InitializeIcuOrDie(); MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); registerExtensions(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); } 我们看下FrameWork层Camera的代码(frameworks\av\camera )，发现多了个cameraserver文件夹 ，看下里面的main_cameraserver.cpp，原来CameraServe::instantiaicte()在这里。
int main(int argc __unused, char** argv __unused) { signal(SIGPIPE, SIG_IGN); sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ALOGI(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8c9dd463d3892b21d0d202280f0f535f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-13T21:12:21+08:00" />
<meta property="article:modified_time" content="2017-12-13T21:12:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 7.0 Camera架构源码分析1 - CameraService启动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本系列教程主要讲解Camera从APP层到HAL层的整个流程，第一篇先讲解CameraService的启动，后面会讲解open、preview、takepicture的流程。</p> 
<p>Android 7.0之前CameraService是在mediaserver进程中注册的，看下Android 6.0的代码：</p> 
<pre class="prettyprint"><code class=" hljs lasso">    <span class="hljs-comment">//path: frameworks\av\media\mediaserver\main_mediaserver.cpp</span>
    int main()
    {
        sp<span class="hljs-subst">&lt;</span>ProcessState<span class="hljs-subst">&gt;</span> proc(ProcessState<span class="hljs-tag">::self</span>());
        sp<span class="hljs-subst">&lt;</span>IServiceManager<span class="hljs-subst">&gt;</span> sm <span class="hljs-subst">=</span> defaultServiceManager();
        ALOGI(<span class="hljs-string">"ServiceManager: %p"</span>, sm<span class="hljs-built_in">.</span>get());
        AudioFlinger<span class="hljs-tag">::instantiate</span>();
        MediaPlayerService<span class="hljs-tag">::instantiate</span>();
        ResourceManagerService<span class="hljs-tag">::instantiate</span>();
        <span class="hljs-comment">//初始化相机服务</span>
        CameraService<span class="hljs-tag">::instantiate</span>();
        AudioPolicyService<span class="hljs-tag">::instantiate</span>();
        SoundTriggerHwService<span class="hljs-tag">::instantiate</span>();
        RadioService<span class="hljs-tag">::instantiate</span>();
        registerExtensions();
        ProcessState<span class="hljs-tag">::self</span>()<span class="hljs-subst">-&gt;</span>startThreadPool();
        IPCThreadState<span class="hljs-tag">::self</span>()<span class="hljs-subst">-&gt;</span>joinThreadPool();
    }</code></pre> 
<p>接着看下Android 7.0中main_mediaserver.cpp的代码，发现没有了CameraService::instantiate(); 也就是说Android 7.0之后就不在main_mediaserver.cpp中注册了。</p> 
<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-comment">//没有CameraService::instantiate()，也少了几个别的服务，这里只关注CameraService</span>
int <span class="hljs-function">main(int argc __unused, char **argv __unused)</span>
{
    <span class="hljs-function">signal(SIGPIPE, SIG_IGN)</span>;

    sp&lt;ProcessState&gt; <span class="hljs-function">proc(ProcessState::<span class="hljs-function">self()</span>)</span>;
    sp&lt;IServiceManager&gt; <span class="hljs-function">sm(<span class="hljs-function">defaultServiceManager()</span>)</span>;
    <span class="hljs-function">ALOGI(<span class="hljs-string">"ServiceManager: %p"</span>, sm.<span class="hljs-function">get()</span>)</span>;
    <span class="hljs-function">InitializeIcuOrDie()</span>;
    MediaPlayerService<span class="hljs-value">::instantiate();</span>
    ResourceManagerService<span class="hljs-value">::instantiate();</span>
    <span class="hljs-function">registerExtensions()</span>;
    ProcessState<span class="hljs-value">::self()-&gt;startThreadPool();</span>
    IPCThreadState<span class="hljs-value">::self()-&gt;joinThreadPool();</span>
}</code></pre> 
<p>我们看下FrameWork层Camera的代码(frameworks\av\camera )，发现多了个cameraserver文件夹 ，看下里面的main_cameraserver.cpp，原来CameraServe::instantiaicte()在这里。</p> 
<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc <span class="hljs-number">__u</span>nused, <span class="hljs-keyword">char</span>** argv <span class="hljs-number">__u</span>nused)
{
    signal(SIGPIPE, SIG_IGN);

    sp&lt;ProcessState&gt; proc(ProcessState::<span class="hljs-keyword">self</span>());
    sp&lt;IServiceManager&gt; sm = defaultServiceManager();
    ALOGI(<span class="hljs-string">"ServiceManager: %p"</span>, sm.get());
    <span class="hljs-comment">//初始化CameraService服务</span>
    CameraServe::instantiaicte();
    ProcessState::<span class="hljs-keyword">self</span>()-&gt;startThreadPool();
    IPCThreadState::<span class="hljs-keyword">self</span>()-&gt;joinThreadPool();
}</code></pre> 
<p>从这里可以猜测cameraserver应该是作为独立的进程运行的，我们看下 cameraserver文件夹下面的另一个文件cameraserver.rc</p> 
<pre class="prettyprint"><code class=" hljs mel"><span class="hljs-comment">//这表示由init进程启动名字为cameraserver的进程，果然是独立进程，路径为/system/bin/cameraserver</span>
service cameraserver /<span class="hljs-keyword">system</span>/bin/cameraserver
    <span class="hljs-comment">//class表示类别，同一类别（这里是main类别）的进程同时启动，同时停止</span>
    class main
    <span class="hljs-comment">//用户名及分组</span>
    user cameraserver
    <span class="hljs-keyword">group</span> audio <span class="hljs-keyword">camera</span> input drmrpc
    ioprio rt <span class="hljs-number">4</span>
    writepid /dev/cpuset/<span class="hljs-keyword">camera</span>-daemon/tasks /dev/stune/top-app/tasks</code></pre> 
<p>cameraserver.rc由Android.mk文件来打包到指定位置：</p> 
<pre class="prettyprint"><code class=" hljs lasso">LOCAL_PATH<span class="hljs-subst">:=</span> $(call my<span class="hljs-attribute">-dir</span>)

include $(CLEAR_VARS)

<span class="hljs-comment">//源文件</span>
LOCAL_SRC_FILES<span class="hljs-subst">:=</span> <span class="hljs-subst">\</span>
    main_cameraserver<span class="hljs-built_in">.</span>cpp

LOCAL_SHARED_LIBRARIES <span class="hljs-subst">:=</span> <span class="hljs-subst">\</span>
    libcameraservice <span class="hljs-subst">\</span>
    libcutils <span class="hljs-subst">\</span>
    libutils <span class="hljs-subst">\</span>
    libbinder <span class="hljs-subst">\</span>
    libcamera_client

<span class="hljs-comment">//模块的名称</span>
LOCAL_MODULE<span class="hljs-subst">:=</span> cameraserver
LOCAL_32_BIT_ONLY <span class="hljs-subst">:=</span> <span class="hljs-literal">true</span>

LOCAL_CFLAGS <span class="hljs-subst">+=</span> <span class="hljs-attribute">-Wall</span> <span class="hljs-attribute">-Wextra</span> <span class="hljs-attribute">-Werror</span> <span class="hljs-attribute">-Wno</span><span class="hljs-attribute">-unused</span><span class="hljs-attribute">-parameter</span>

<span class="hljs-comment">//LOCAL_INIT_RC会将cameraserver.rc放在/system/etc/init/目录中，这个目录下的脚本会由init进程来启动。</span>
LOCAL_INIT_RC <span class="hljs-subst">:=</span> cameraserver<span class="hljs-built_in">.</span>rc

include $(BUILD_EXECUTABLE)</code></pre> 
<p>那cameraserver.rc文件什么时候执行呢？这里我们需要理解下Android系统启动过程，Android系统启动包括两大块：Linux内核启动，Android框架启动。</p> 
<p>1，Linux内核启动：</p> 
<ul><li>BootLoader启动</li></ul> 
<p>内核启动首先装载BootLoader引导程序，执行完进入kthreadd内核进程，这是所有内核进程的父进程。</p> 
<ul><li>加载Linux内核</li></ul> 
<p>初始化驱动、安装根文件系统等，最后启动第一个用户进程init进程，它是所有用户进程的父进程。这样就进入了Android框架的启动阶段。</p> 
<p>2，Android框架启动</p> 
<p>init进程启动后会加载init.rc(system\core\rootdir\init.rc)脚本，当它执行mount_all指令挂载分区时，会加载/{system,vendor,odm}/etc/init目录下的所有rc脚本，这样就会启动cameraserver进程，同时也会启动zygote进程（第一个Java层进程，也是Java层所有进程的父进程）、ServiceManager、mediaserver（多媒体服务进程）、surfaceflinger（屏幕渲染相关的进程）等。之后zygote会孵化出启动system_server进程，Android framework里面的所有service（ActivityManagerService、WindowManagerService等）都是由system_server启动，这里就不细讲了。</p> 
<p>那为什么Android 7.0之前cameraservice是运行在mediaserver进程中的，而从Android 7.0开始将cameraservice分离出来成一个单独的cameraserver进程？这是为了安全性，因为mediaserver 进程中有很多其它的Service，如AudioFlinger、MediaPlayerService等，如果这其中有一个Service挂掉就会导致mediaserver进程重启，如果相机正在执行，这样就会挂掉，用户体验很差。</p> 
<p>现在知道了cameraserver进程是怎么启动的了，下面分析下它的启动过程，cameraserver进程的入口是frameworks\av\camera\cameraserver\main_cameraserver.cpp的main函数，看下代码：</p> 
<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc <span class="hljs-number">__u</span>nused, <span class="hljs-keyword">char</span>** argv <span class="hljs-number">__u</span>nused)
{
    signal(SIGPIPE, SIG_IGN);
    <span class="hljs-comment">//获取一个ProcessState跟Binder驱动打交道</span>
    sp&lt;ProcessState&gt; proc(ProcessState::<span class="hljs-keyword">self</span>());
    <span class="hljs-comment">//获取ServiceManager用以注册该服务</span>
    sp&lt;IServiceManager&gt; sm = defaultServiceManager();
    ALOGI(<span class="hljs-string">"ServiceManager: %p"</span>, sm.get());
    CameraService::instantiate();
    <span class="hljs-comment">//线程池管理</span>
    ProcessState::<span class="hljs-keyword">self</span>()-&gt;startThreadPool();
    IPCThreadState::<span class="hljs-keyword">self</span>()-&gt;joinThreadPool();
}</code></pre> 
<p>我们主要关注CameraService::instantiate()，别的几行属于Binder机制，我这里假设你已经熟悉了，不熟悉的话先补下Binder知识，不然后面很难理解的。</p> 
<p>CameraService继承了BinderService和BnCameraService类。CameraService::instantiate()函数是调用其父类BinderService类的方法。</p> 
<pre class="prettyprint"><code class=" hljs lasso">class CameraService :
    <span class="hljs-keyword">public</span> BinderService<span class="hljs-subst">&lt;</span>CameraService<span class="hljs-subst">&gt;</span>,
    <span class="hljs-keyword">public</span> <span class="hljs-tag">::android</span><span class="hljs-tag">::hardware</span><span class="hljs-tag">::BnCameraService</span>,
    <span class="hljs-keyword">public</span> IBinder<span class="hljs-tag">::DeathRecipient</span>,
    <span class="hljs-keyword">public</span> camera_module_callbacks_t
{
<span class="hljs-attribute">...</span><span class="hljs-attribute">...</span>
}

<span class="hljs-comment">//模板类</span>
template<span class="hljs-subst">&lt;</span>typename SERVICE<span class="hljs-subst">&gt;</span>
class BinderService
{
<span class="hljs-keyword">public</span>:
    static status_t publish(bool allowIsolated <span class="hljs-subst">=</span> <span class="hljs-literal">false</span>) {
        sp<span class="hljs-subst">&lt;</span>IServiceManager<span class="hljs-subst">&gt;</span> sm(defaultServiceManager());
        <span class="hljs-keyword">return</span> sm<span class="hljs-subst">-&gt;</span>addService(
                String16(SERVICE<span class="hljs-tag">::getServiceName</span>()),
                <span class="hljs-literal">new</span> SERVICE(), allowIsolated);
    }

    static <span class="hljs-literal">void</span> publishAndJoinThreadPool(bool allowIsolated <span class="hljs-subst">=</span> <span class="hljs-literal">false</span>) {
        publish(allowIsolated);
        joinThreadPool();
    }

    static <span class="hljs-literal">void</span> instantiate() { publish(); }
<span class="hljs-attribute">...</span><span class="hljs-attribute">...</span>
}</code></pre> 
<p>BinderService使用了模板类，使用CameraService::instantiate()初始化时，SERVICE就是CameraService。替换模板后CameraService::instantiate()函数如下：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> instantiate() { publish(); }

<span class="hljs-keyword">static</span> status_t publish() {
    sp&lt;IServiceManager&gt; sm(defaultServiceManager());
    /getServiceName()返回<span class="hljs-string">"media.camera"</span>字符串
    <span class="hljs-keyword">return</span> sm-&gt;addService(
         String16(CameraService ::getServiceName()), <span class="hljs-keyword">new</span> CameraService (), <span class="hljs-keyword">false</span>);
}</code></pre> 
<p>我们知道defaultServiceManager返回的是BpServiceManager，看下它的addService函数：</p> 
<pre class="prettyprint"><code class=" hljs haskell">    virtual status_t addService(const <span class="hljs-type">String16</span>&amp; name, const sp&lt;<span class="hljs-type">IBinder</span>&gt;&amp; service,
            bool allowIsolated)
    {
        <span class="hljs-type">Parcel</span> <span class="hljs-typedef"><span class="hljs-keyword">data</span>, reply;</span>
        //写入<span class="hljs-type">Interface</span> name，这里是<span class="hljs-string">"android.os.IServiceManager"</span>
        <span class="hljs-typedef"><span class="hljs-keyword">data</span>.writeInterfaceToken<span class="hljs-container">(<span class="hljs-type">IServiceManager</span>::<span class="hljs-title">getInterfaceDescriptor</span>()</span>);</span>
        //写入<span class="hljs-type">Service</span> name
        <span class="hljs-typedef"><span class="hljs-keyword">data</span>.writeString16<span class="hljs-container">(<span class="hljs-title">name</span>)</span>;</span>
        //写入<span class="hljs-type">Service</span>实例
        <span class="hljs-typedef"><span class="hljs-keyword">data</span>.writeStrongBinder<span class="hljs-container">(<span class="hljs-title">service</span>)</span>;</span>
        <span class="hljs-typedef"><span class="hljs-keyword">data</span>.writeInt32<span class="hljs-container">(<span class="hljs-title">allowIsolated</span> ? 1 : 0)</span>;</span>
        //remote()实际上是指<span class="hljs-type">BpBinder</span>(<span class="hljs-number">0</span>)
        status_t err = remote()-&gt;transact(<span class="hljs-type">ADD_SERVICE_TRANSACTION</span>, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, &amp;reply);</span>
        return err == <span class="hljs-type">NO_ERROR</span> ? reply.readExceptionCode() : err;
    }</code></pre> 
<p>注意addService第二个参数service是sp类型，而sp初始化时，会调用其包装的对象的onFirstRef()函数，不懂的可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/6786239" target="_blank" rel="noopener noreferrer">Android系统的智能指针（轻量级指针、强指针和弱指针）的实现原理分析</a></p> 
<p>这里的service就是CameraService，看下它的onFirstRef()函数：</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-comment">//原始代码有点长，这里只保留了比较重要的代码</span>
<span class="hljs-literal">void</span> CameraService<span class="hljs-tag">::onFirstRef</span>()
{
    BnCameraService<span class="hljs-tag">::onFirstRef</span>();

    <span class="hljs-comment">//camera_module_t和CAMERA_HARDWARE_MODULE_ID定义在hardware\libhardware\include\hardware\camera_common.h中，</span>
    camera_module_t <span class="hljs-subst">*</span>rawModule;
    <span class="hljs-comment">//注意这里把rawModule强转成camera_module_t，至于为什么能强转，下面会讲的</span>
    int err <span class="hljs-subst">=</span> hw_get_module(CAMERA_HARDWARE_MODULE_ID,
            (const hw_module_t <span class="hljs-subst">**</span>)<span class="hljs-subst">&amp;</span>rawModule);

    <span class="hljs-comment">//创建CameraModule对象并初始化</span>
    mModule <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> CameraModule(rawModule);
    err <span class="hljs-subst">=</span> mModule<span class="hljs-subst">-&gt;</span>init();

    <span class="hljs-comment">//获取摄像头数量</span>
    mNumberOfCameras <span class="hljs-subst">=</span> mModule<span class="hljs-subst">-&gt;</span>getNumberOfCameras();
    mNumberOfNormalCameras <span class="hljs-subst">=</span> mNumberOfCameras;

    int latestStrangeCameraId <span class="hljs-subst">=</span> INT_MAX;
    for (int i <span class="hljs-subst">=</span> <span class="hljs-number">0</span>; i <span class="hljs-subst">&lt;</span> mNumberOfCameras; i<span class="hljs-subst">++</span>) {
        String8 cameraId <span class="hljs-subst">=</span> String8<span class="hljs-tag">::format</span>(<span class="hljs-string">"%d"</span>, i);
        <span class="hljs-comment">//获取每个camera的信息以及初始化状态</span>
    }

    <span class="hljs-comment">//因为CameraService继承了camera_module_callbacks_t，定义在camera_common.h中，所以这里的Callback主要监听camera_device_status_change和torch_mode_status_change</span>
    <span class="hljs-keyword">if</span> (mModule<span class="hljs-subst">-&gt;</span>getModuleApiVersion() <span class="hljs-subst">&gt;=</span> CAMERA_MODULE_API_VERSION_2_1) {
        mModule<span class="hljs-subst">-&gt;</span>setCallbacks(this);
    }
    <span class="hljs-comment">//连接CameraServiceProxy服务，也就是"media.camera.proxy"服务，此服务由SystemServer注册到ServiceManager中</span>
    CameraService<span class="hljs-tag">::pingCameraServiceProxy</span>();
}</code></pre> 
<p>camera_module_t（hardware\libhardware\include\hardware\camera_common.h）的声明如下：</p> 
<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> camera_module {
    <span class="hljs-comment">//注意common必须是camera_module的第一个成员，这样就可以根据camera_module_t的地址强转成hw_module_t</span>
    hw_module_t common;
    <span class="hljs-keyword">int</span> (*get_number_of_cameras)(<span class="hljs-keyword">void</span>);
    ......
} camera_module_t;</code></pre> 
<p>hw_get_module()函数定义在hardware\libhardware\hardware.c文件中</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">int</span> hw_get_module(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">id</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> hw_module_t **module)
{
    <span class="hljs-keyword">return</span> hw_get_module_by_class(<span class="hljs-keyword">id</span>, <span class="hljs-literal">NULL</span>, module);
}

<span class="hljs-keyword">int</span> hw_get_module_by_class(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *class_id, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *inst,
                           <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> hw_module_t **module)
{
    ......
    <span class="hljs-comment">//首先根据ro.hardware.class_id.inst查找动态链接库路径，如果可以找到，直接跳到found位置</span>
    snprintf(prop_name, <span class="hljs-keyword">sizeof</span>(prop_name), <span class="hljs-string">"ro.hardware.%s"</span>, name);
    <span class="hljs-keyword">if</span> (property_get(prop_name, prop, <span class="hljs-literal">NULL</span>) &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (hw_module_exists(path, <span class="hljs-keyword">sizeof</span>(path), name, prop) == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">goto</span> found;
        }
    }

    <span class="hljs-comment">//在所有的配置变量中查找所需模块的动态链接库路径</span>
    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;HAL_VARIANT_KEYS_COUNT; i++) {
        <span class="hljs-keyword">if</span> (property_get(variant_keys[i], prop, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">if</span> (hw_module_exists(path, <span class="hljs-keyword">sizeof</span>(path), name, prop) == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">goto</span> found;
        }
    }

    <span class="hljs-keyword">return</span> -ENOENT;

found:
    <span class="hljs-comment">//根据路径加载动态链接库，并将硬件模块的结构体地址赋给module</span>
    <span class="hljs-keyword">return</span> load(class_id, path, module);
}</code></pre> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> load(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *id,
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path,
        <span class="hljs-keyword">const</span> struct hw_module_t **pHmi)
{
    <span class="hljs-keyword">int</span> status = -EINVAL;
    <span class="hljs-keyword">void</span> *handle = NULL;
    struct hw_module_t *hmi = NULL;

    <span class="hljs-comment">//打开.so文件</span>
    handle = dlopen(path, RTLD_NOW);

    <span class="hljs-comment">//获取hal_module_info结构体的地址</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sym = HAL_MODULE_INFO_SYM_AS_STR;
    hmi = (struct hw_module_t *)dlsym(handle, sym);

}

<span class="hljs-comment">//hardware.h</span>
<span class="hljs-javadoc">/**
 * Name of the hal_module_info
 */</span>
#define HAL_MODULE_INFO_SYM         HMI

<span class="hljs-javadoc">/**
 * Name of the hal_module_info as a string
 */</span>
#define HAL_MODULE_INFO_SYM_AS_STR  <span class="hljs-string">"HMI"</span></code></pre> 
<p>根据上述代码，dlsym就是找HMI的地址，而HMI就是HAL_MODULE_INFO_SYM的宏定义，所以最终就是找HAL_MODULE_INFO_SYM的地址。</p> 
<p>通过查找Android 7.0 代码，发现HAL_MODULE_INFO_SYM是在hardware/qcom/camera/QCamera2/QCamera2Hal.cpp文件中实现的（如果你的7.0源码没有HAL层的代码，可以参考在线源代码<a href="http://androidxref.com/" rel="nofollow noopener noreferrer" target="_blank">http://androidxref.com/</a>）。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">static hw_module_t camera_common = {
    <span class="hljs-preprocessor">.tag</span>                    = HARDWARE_MODULE_TAG,
    <span class="hljs-preprocessor">.module</span>_api_version     = CAMERA_MODULE_API_VERSION_2_4,
    <span class="hljs-preprocessor">.hal</span>_api_version        = HARDWARE_HAL_API_VERSION,
    <span class="hljs-preprocessor">.id</span>                     = CAMERA_HARDWARE_MODULE_ID,
    <span class="hljs-preprocessor">.name</span>                   = <span class="hljs-string">"QCamera Module"</span>,
    <span class="hljs-preprocessor">.author</span>                 = <span class="hljs-string">"Qualcomm Innovation Center Inc"</span>,
    <span class="hljs-preprocessor">.methods</span>                = &amp;qcamera::QCamera2Factory::mModuleMethods,
    <span class="hljs-preprocessor">.dso</span>                    = NULL,
    <span class="hljs-preprocessor">.reserved</span>               = {<!-- --><span class="hljs-number">0</span>}
}<span class="hljs-comment">;</span>

camera_module_t HAL_MODULE_INFO_SYM = {
    <span class="hljs-preprocessor">.common</span>                 = camera_common,
    <span class="hljs-preprocessor">.get</span>_number_of_cameras  = qcamera::QCamera2Factory::get_number_of_cameras,
    <span class="hljs-preprocessor">.get</span>_camera_info        = qcamera::QCamera2Factory::get_camera_info,
    <span class="hljs-preprocessor">.set</span>_callbacks          = qcamera::QCamera2Factory::set_callbacks,
    <span class="hljs-preprocessor">.get</span>_vendor_tag_ops     = qcamera::QCamera3VendorTags::get_vendor_tag_ops,
    <span class="hljs-preprocessor">.open</span>_legacy            = qcamera::QCamera2Factory::open_legacy,
    <span class="hljs-preprocessor">.set</span>_torch_mode         = qcamera::QCamera2Factory::set_torch_mode,
    <span class="hljs-preprocessor">.init</span>                   = NULL,
    <span class="hljs-preprocessor">.reserved</span>               = {<!-- --><span class="hljs-number">0</span>}
}<span class="hljs-comment">;</span></code></pre> 
<p>所以最终rawModule就是指向HAL_MODULE_INFO_SYM，这样CameraService就跟Camera HAL层联系起来了。</p> 
<p>回到CameraService::onFirstRef()函数中：</p> 
<pre class="prettyprint"><code class=" hljs lasso">    <span class="hljs-comment">//创建CameraModule对象并初始化</span>
    mModule <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> CameraModule(rawModule);
    err <span class="hljs-subst">=</span> mModule<span class="hljs-subst">-&gt;</span>init();

    <span class="hljs-comment">//获取摄像头数量</span>
    mNumberOfCameras <span class="hljs-subst">=</span> mModule<span class="hljs-subst">-&gt;</span>getNumberOfCameras();
    mNumberOfNormalCameras <span class="hljs-subst">=</span> mNumberOfCameras;</code></pre> 
<pre class="prettyprint"><code class=" hljs lasso">CameraModule<span class="hljs-tag">::CameraModule</span>(camera_module_t <span class="hljs-subst">*</span>module) {
    <span class="hljs-comment">//对mModule进行初始化</span>
    mModule <span class="hljs-subst">=</span> module;
}

int CameraModule<span class="hljs-tag">::init</span>() {
    <span class="hljs-comment">//mModule-&gt;init就是指向HAL_MODULE_INFO_SYM的init，为NULL</span>
    <span class="hljs-keyword">if</span> (getModuleApiVersion() <span class="hljs-subst">&gt;=</span> CAMERA_MODULE_API_VERSION_2_4 <span class="hljs-subst">&amp;&amp;</span>
            mModule<span class="hljs-subst">-&gt;</span>init <span class="hljs-subst">!=</span> <span class="hljs-built_in">NULL</span>) {
        ATRACE_BEGIN(<span class="hljs-string">"camera_module-&gt;init"</span>);
        res <span class="hljs-subst">=</span> mModule<span class="hljs-subst">-&gt;</span>init();
        ATRACE_END();
    }
    <span class="hljs-comment">//调用getNumberOfCameras()</span>
    mCameraInfoMap<span class="hljs-built_in">.</span>setCapacity(getNumberOfCameras());
}

int CameraModule<span class="hljs-tag">::getNumberOfCameras</span>() {
    int numCameras;
    <span class="hljs-comment">//调用HAL_MODULE_INFO_SYM的get_number_of_cameras()函数</span>
    numCameras <span class="hljs-subst">=</span> mModule<span class="hljs-subst">-&gt;</span>get_number_of_cameras();
    <span class="hljs-keyword">return</span> numCameras;
}

<span class="hljs-comment">//查看HAL层代码</span>

int QCamera2Factory<span class="hljs-tag">::get_number_of_cameras</span>()
{
    int numCameras <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">//gQCamera2Factory为空的话，创建一个对象</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>gQCamera2Factory) {
        gQCamera2Factory <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> QCamera2Factory();
        <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>gQCamera2Factory) {
            LOGE(<span class="hljs-string">"Failed to allocate Camera2Factory object"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }

    <span class="hljs-keyword">if</span>(gQCameraMuxer)
        numCameras <span class="hljs-subst">=</span> gQCameraMuxer<span class="hljs-subst">-&gt;</span>get_number_of_cameras();
    <span class="hljs-keyword">else</span>
        <span class="hljs-comment">//获取Camera摄像头数量</span>
        numCameras <span class="hljs-subst">=</span> gQCamera2Factory<span class="hljs-subst">-&gt;</span>getNumberOfCameras();
    <span class="hljs-keyword">return</span> numCameras;
}

QCamera2Factory<span class="hljs-tag">::QCamera2Factory</span>()
{
    mHalDescriptors <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    mCallbacks <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    <span class="hljs-comment">//get_num_of_cameras()在mm_camera_interface.c中，之后就会进入到Linux内核，往下就不讲了</span>
    mNumOfCameras <span class="hljs-subst">=</span> get_num_of_cameras();
    mNumOfCameras_expose <span class="hljs-subst">=</span> get_num_of_cameras_to_expose();
    <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span>
}</code></pre> 
<p>onFirstRef函数主要是根据ID查找并加载HAL模块的动态链接库，然后创建CameraModule对象并初始化以及获取摄像头数量，之后给HAL层设置一个监听接口。</p> 
<p>回到addService函数中，接着看其里面的具体内容：</p> 
<pre class="prettyprint"><code class=" hljs haskell">    virtual status_t addService(const <span class="hljs-type">String16</span>&amp; name, const sp&lt;<span class="hljs-type">IBinder</span>&gt;&amp; service,
            bool allowIsolated)
    {
        <span class="hljs-type">Parcel</span> <span class="hljs-typedef"><span class="hljs-keyword">data</span>, reply;</span>
        //写入<span class="hljs-type">Interface</span> name，这里是<span class="hljs-string">"android.os.IServiceManager"</span>
        <span class="hljs-typedef"><span class="hljs-keyword">data</span>.writeInterfaceToken<span class="hljs-container">(<span class="hljs-type">IServiceManager</span>::<span class="hljs-title">getInterfaceDescriptor</span>()</span>);</span>
        //写入<span class="hljs-type">Service</span> name
        <span class="hljs-typedef"><span class="hljs-keyword">data</span>.writeString16<span class="hljs-container">(<span class="hljs-title">name</span>)</span>;</span>
        //写入<span class="hljs-type">Service</span>实例
        <span class="hljs-typedef"><span class="hljs-keyword">data</span>.writeStrongBinder<span class="hljs-container">(<span class="hljs-title">service</span>)</span>;</span>
        <span class="hljs-typedef"><span class="hljs-keyword">data</span>.writeInt32<span class="hljs-container">(<span class="hljs-title">allowIsolated</span> ? 1 : 0)</span>;</span>
        //remote()实际上是指<span class="hljs-type">BpBinder</span>(<span class="hljs-number">0</span>)，它是指<span class="hljs-type">Binder</span>驱动中的<span class="hljs-number">0</span>号引用，也就是指<span class="hljs-type">ServiceManager</span>的代理对象
        status_t err = remote()-&gt;transact(<span class="hljs-type">ADD_SERVICE_TRANSACTION</span>, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, &amp;reply);</span>
        return err == <span class="hljs-type">NO_ERROR</span> ? reply.readExceptionCode() : err;
    }

<span class="hljs-title">status_t</span> <span class="hljs-type">BpBinder</span>::transact(
    uint32_t code, const <span class="hljs-type">Parcel</span>&amp; <span class="hljs-typedef"><span class="hljs-keyword">data</span>, <span class="hljs-type">Parcel</span>* reply, uint32_t flags)</span>
{
    // <span class="hljs-type">Once</span> a binder has died, it will never come back to life.
    <span class="hljs-keyword">if</span> (mAlive) {
        //通过<span class="hljs-type">IPCThreadState</span>对象来向<span class="hljs-type">Binder</span>驱动发送添加服务的请求，注意mHandle值为<span class="hljs-number">0</span>
        status_t status = <span class="hljs-type">IPCThreadState</span>::self()-&gt;transact(
            mHandle, code, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, reply, flags);</span>
        <span class="hljs-keyword">if</span> (status == <span class="hljs-type">DEAD_OBJECT</span>) mAlive = <span class="hljs-number">0</span>;
        return status;
    }
    return <span class="hljs-type">DEAD_OBJECT</span>;
}

<span class="hljs-title">status_t</span> <span class="hljs-type">IPCThreadState</span>::transact(int32_t handle,
                                  uint32_t code, const <span class="hljs-type">Parcel</span>&amp; <span class="hljs-typedef"><span class="hljs-keyword">data</span>,</span>
                                  <span class="hljs-type">Parcel</span>* reply, uint32_t flags)
{
    status_t err = <span class="hljs-typedef"><span class="hljs-keyword">data</span>.errorCheck<span class="hljs-container">()</span>;</span>
    <span class="hljs-keyword">if</span> (err == <span class="hljs-type">NO_ERROR</span>) {
        //将数据封装成binder_transaction_data结构，并写到mOut变量中
        err = writeTransactionData(<span class="hljs-type">BC_TRANSACTION</span>, flags, handle, code, <span class="hljs-typedef"><span class="hljs-keyword">data</span>, <span class="hljs-type">NULL</span>);</span>
    }

    <span class="hljs-keyword">if</span> ((flags &amp; <span class="hljs-type">TF_ONE_WAY</span>) == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (reply) {
            err = waitForResponse(reply);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-type">Parcel</span> fakeReply;
            err = waitForResponse(&amp;fakeReply);
        }
    } 
    return err;
}

<span class="hljs-title">status_t</span> <span class="hljs-type">IPCThreadState</span>::writeTransactionData(int32_t cmd, uint32_t binderFlags,
    int32_t handle, uint32_t code, const <span class="hljs-type">Parcel</span>&amp; <span class="hljs-typedef"><span class="hljs-keyword">data</span>, status_t* statusBuffer)</span>
{
    binder_transaction_data tr;
    //封装数据
    tr.target.ptr = <span class="hljs-number">0</span>; /* <span class="hljs-type">Don't</span> pass uninitialized stack <span class="hljs-typedef"><span class="hljs-keyword">data</span> to a remote process */</span>
    tr.target.handle = handle;
    tr.code = code;
    tr.flags = binderFlags;
    tr.cookie = <span class="hljs-number">0</span>;
    tr.sender_pid = <span class="hljs-number">0</span>;
    tr.sender_euid = <span class="hljs-number">0</span>;

    const status_t err = <span class="hljs-typedef"><span class="hljs-keyword">data</span>.errorCheck<span class="hljs-container">()</span>;</span>
    <span class="hljs-keyword">if</span> (err == <span class="hljs-type">NO_ERROR</span>) {
        tr.data_size = <span class="hljs-typedef"><span class="hljs-keyword">data</span>.ipcDataSize<span class="hljs-container">()</span>;</span>
        tr.<span class="hljs-typedef"><span class="hljs-keyword">data</span>.ptr.buffer = <span class="hljs-keyword">data</span>.ipcData<span class="hljs-container">()</span>;</span>
        tr.offsets_size = <span class="hljs-typedef"><span class="hljs-keyword">data</span>.ipcObjectsCount<span class="hljs-container">()</span>*sizeof<span class="hljs-container">(<span class="hljs-title">binder_size_t</span>)</span>;</span>
        tr.<span class="hljs-typedef"><span class="hljs-keyword">data</span>.ptr.offsets = <span class="hljs-keyword">data</span>.ipcObjects<span class="hljs-container">()</span>;</span>
    } 
    ......
    //写到mOut变量中
    mOut.writeInt32(cmd);
    mOut.write(&amp;tr, sizeof(tr));

    return <span class="hljs-type">NO_ERROR</span>;
}</code></pre> 
<p>到这里只是将数据封装了一下，但是还没发送，接着看waitForResponse函数：</p> 
<pre class="prettyprint"><code class=" hljs cpp">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    uint32_t cmd;
    int32_t err;

    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        <span class="hljs-comment">//跟Binder驱动交互，这个是核心，在下面讲解</span>
        <span class="hljs-keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="hljs-keyword">break</span>;
        <span class="hljs-comment">//读取Binder驱动返回的命令</span>
        cmd = (uint32_t)mIn.readInt32();

        IF_LOG_COMMANDS() {
            alog &lt;&lt; <span class="hljs-string">"Processing waitForResponse Command: "</span>
                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;
        }

        <span class="hljs-keyword">switch</span> (cmd) {
        <span class="hljs-keyword">case</span> BR_TRANSACTION_COMPLETE:
            <span class="hljs-keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="hljs-keyword">goto</span> finish;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> BR_DEAD_REPLY:
            err = DEAD_OBJECT;
            <span class="hljs-keyword">goto</span> finish;

        <span class="hljs-keyword">case</span> BR_FAILED_REPLY:
            err = FAILED_TRANSACTION;
            <span class="hljs-keyword">goto</span> finish;

        <span class="hljs-keyword">case</span> BR_ACQUIRE_RESULT:
            {
                ALOG_ASSERT(acquireResult != NULL, <span class="hljs-string">"Unexpected brACQUIRE_RESULT"</span>);
                <span class="hljs-keyword">const</span> int32_t result = mIn.readInt32();
                <span class="hljs-keyword">if</span> (!acquireResult) <span class="hljs-keyword">continue</span>;
                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;
            }
            <span class="hljs-keyword">goto</span> finish;

        <span class="hljs-keyword">case</span> BR_REPLY:
            {
                binder_transaction_data tr;
                err = mIn.read(&amp;tr, <span class="hljs-keyword">sizeof</span>(tr));
                ALOG_ASSERT(err == NO_ERROR, <span class="hljs-string">"Not enough command data for brREPLY"</span>);
                <span class="hljs-keyword">if</span> (err != NO_ERROR) <span class="hljs-keyword">goto</span> finish;

                <span class="hljs-keyword">if</span> (reply) {
                    <span class="hljs-keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="hljs-number">0</span>) {
                        reply-&gt;ipcSetDataReference(
                            <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> binder_size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/<span class="hljs-keyword">sizeof</span>(binder_size_t),
                            freeBuffer, <span class="hljs-keyword">this</span>);
                    } <span class="hljs-keyword">else</span> {
                        err = *<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> status_t*&gt;(tr.data.ptr.buffer);
                        freeBuffer(NULL,
                            <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> binder_size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/<span class="hljs-keyword">sizeof</span>(binder_size_t), <span class="hljs-keyword">this</span>);
                    }
                } <span class="hljs-keyword">else</span> {
                    freeBuffer(NULL,
                        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),
                        tr.data_size,
                        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> binder_size_t*&gt;(tr.data.ptr.offsets),
                        tr.offsets_size/<span class="hljs-keyword">sizeof</span>(binder_size_t), <span class="hljs-keyword">this</span>);
                    <span class="hljs-keyword">continue</span>;
                }
            }
            <span class="hljs-keyword">goto</span> finish;

        <span class="hljs-keyword">default</span>:
            err = executeCommand(cmd);
            <span class="hljs-keyword">if</span> (err != NO_ERROR) <span class="hljs-keyword">goto</span> finish;
            <span class="hljs-keyword">break</span>;
        }
    }

finish:
    <span class="hljs-keyword">if</span> (err != NO_ERROR) {
        <span class="hljs-keyword">if</span> (acquireResult) *acquireResult = err;
        <span class="hljs-keyword">if</span> (reply) reply-&gt;setError(err);
        mLastError = err;
    }

    <span class="hljs-keyword">return</span> err;
}

<span class="hljs-comment">//不穿参数时doReceive为true</span>
status_t IPCThreadState::talkWithDriver(<span class="hljs-keyword">bool</span> doReceive)
{
    <span class="hljs-comment">//mProcess是IPCThreadState初始化时所包含的ProcessState对象，它的mDriverFD对应Binder驱动的文件描述符</span>
    <span class="hljs-keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> -EBADF;
    }
    <span class="hljs-comment">//将mOut的数据封装到binder_write_read结构体中</span>
    binder_write_read bwr;

    <span class="hljs-comment">// Is the read buffer empty?</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();

    <span class="hljs-comment">// We don't want to write anything if we are still reading</span>
    <span class="hljs-comment">// from data left in the input buffer and the caller</span>
    <span class="hljs-comment">// has requested to read the next data.</span>
    <span class="hljs-keyword">const</span> size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="hljs-number">0</span>;

    bwr.write_size = outAvail;
    bwr.write_buffer = (uintptr_t)mOut.data();

    <span class="hljs-comment">// This is what we'll read.</span>
    <span class="hljs-keyword">if</span> (doReceive &amp;&amp; needRead) {
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (uintptr_t)mIn.data();
    } <span class="hljs-keyword">else</span> {
        bwr.read_size = <span class="hljs-number">0</span>;
        bwr.read_buffer = <span class="hljs-number">0</span>;
    }

    bwr.write_consumed = <span class="hljs-number">0</span>;
    bwr.read_consumed = <span class="hljs-number">0</span>;
    status_t err;
    <span class="hljs-keyword">do</span> {
<span class="hljs-preprocessor">#if defined(__ANDROID__)</span>
        <span class="hljs-comment">//这里就是向Binder驱动写入命令和数据</span>
        <span class="hljs-keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="hljs-number">0</span>)
            err = NO_ERROR;
<span class="hljs-preprocessor">#else</span>
        err = INVALID_OPERATION;
<span class="hljs-preprocessor">#endif</span>
    } <span class="hljs-keyword">while</span> (err == -EINTR);
    ......
    <span class="hljs-keyword">return</span> err;
}</code></pre> 
<p>下面就进入到了Linux内核中了，AOSP中没有这部分代码，我们可以使用这两个Linux内核在线阅读网站：<a href="https://lxr.missinglinkelectronics.com/linux" rel="nofollow noopener noreferrer" target="_blank">https://lxr.missinglinkelectronics.com/linux</a> 或者 <a href="http://elixir.free-electrons.com/" rel="nofollow noopener noreferrer" target="_blank">http://elixir.free-electrons.com/</a></p> 
<pre class="prettyprint"><code class=" hljs php"><span class="hljs-comment">//路径</span>
linux/drivers/android/binder.c
linux/<span class="hljs-keyword">include</span>/uapi/linux/android/binder.h</code></pre> 
<p>首先binder_init函数会创建 /dev/binder节点：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init binder_init(<span class="hljs-keyword">void</span>)
{
    ......
    <span class="hljs-keyword">while</span> ((device_name = strsep(&amp;device_names, <span class="hljs-string">","</span>))) {
        <span class="hljs-comment">//初始化Binder设备</span>
        ret = init_binder_device(device_name);
    }
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init init_binder_device(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)
{
    <span class="hljs-keyword">int</span> ret;
    <span class="hljs-keyword">struct</span> binder_device *binder_device;

    binder_device = kzalloc(<span class="hljs-keyword">sizeof</span>(*binder_device), GFP_KERNEL);
    <span class="hljs-keyword">if</span> (!binder_device)
        <span class="hljs-keyword">return</span> -ENOMEM;

    <span class="hljs-comment">//操作函数结构体</span>
    binder_device-&gt;miscdev.fops = &amp;binder_fops;
    binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;
    <span class="hljs-comment">//设备名称，这里就是"binder"，这样用户空间可以通过/dev/binder节点进行操作</span>
    binder_device-&gt;miscdev.name = name;

    binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;
    binder_device-&gt;context.name = name;
    <span class="hljs-comment">//向内核中注册misc设备</span>
    ret = misc_register(&amp;binder_device-&gt;miscdev);
    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) {
        kfree(binder_device);
        <span class="hljs-keyword">return</span> ret;
    }

    hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);

    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-comment">//这里指定了文件操作的函数</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> file_operations binder_fops = {
    .owner = THIS_MODULE,
    .poll = binder_poll,
    <span class="hljs-comment">//从Linux kernel 2.6.36版本开始，删除了ioctl函数指针，用unlocked_ioctl取代</span>
    .unlocked_ioctl = binder_ioctl,
    .compat_ioctl = binder_ioctl,
    .mmap = binder_mmap,
    .open = binder_open,
    .flush = binder_flush,
    .release = binder_release,
};</code></pre> 
<p>回到IPCThreadState::talkWithDriver：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="hljs-number">0</span>)
    err = NO_ERROR;

<span class="hljs-comment">//ioctl就对应内核中的binder_ioctl函数，</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> binder_ioctl(<span class="hljs-keyword">struct</span> file *filp, unsigned <span class="hljs-keyword">int</span> cmd, unsigned <span class="hljs-keyword">long</span> arg)
{
    <span class="hljs-keyword">int</span> ret;
    <span class="hljs-keyword">struct</span> binder_proc *proc = filp-&gt;private_data;
    <span class="hljs-keyword">struct</span> binder_thread *thread;
    ......
    <span class="hljs-comment">//从binder_proc中查找binder_thread，如果当前线程已经加入到proc的线程队列则直接返回，如果不存在则创建binder_thread，并将当前线程添加到当前的proc</span>
    thread = binder_get_thread(proc);
    <span class="hljs-keyword">switch</span> (cmd) {
    <span class="hljs-keyword">case</span> BINDER_WRITE_READ:
        ret = binder_ioctl_write_read(filp, cmd, arg, thread);
        <span class="hljs-keyword">if</span> (ret)
            <span class="hljs-keyword">goto</span> err;
        <span class="hljs-keyword">break</span>;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> binder_ioctl_write_read(<span class="hljs-keyword">struct</span> file *filp,
                unsigned <span class="hljs-keyword">int</span> cmd, unsigned <span class="hljs-keyword">long</span> arg,
                <span class="hljs-keyword">struct</span> binder_thread *thread)
{
    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">struct</span> binder_proc *proc = filp-&gt;private_data;
    unsigned <span class="hljs-keyword">int</span> size = _IOC_SIZE(cmd);
    <span class="hljs-keyword">void</span> __user *ubuf = (<span class="hljs-keyword">void</span> __user *)arg;
    <span class="hljs-keyword">struct</span> binder_write_read bwr;

    <span class="hljs-keyword">if</span> (size != <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> binder_write_read)) {
        ret = -EINVAL;
        <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
    }
    <span class="hljs-comment">//把用户空间的binder_write_read数据拷贝到内核空间bwr</span>
    <span class="hljs-keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="hljs-keyword">sizeof</span>(bwr))) {
        ret = -EFAULT;
        <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
    }

    <span class="hljs-keyword">if</span> (bwr.write_size &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">//当写缓存中有数据时，执行Binder写操作</span>
        ret = binder_thread_write(proc, thread,
                      bwr.write_buffer,
                      bwr.write_size,
                      &amp;bwr.write_consumed);
        trace_binder_write_done(ret);
        <span class="hljs-comment">//如果Binder写操作失败，则将bwr数据拷回到内核空间，并返回</span>
        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) {
            bwr.read_consumed = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr)))
                ret = -EFAULT;
            <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
        }
    }
    <span class="hljs-keyword">if</span> (bwr.read_size &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">//当读缓存中有数据时，执行Binder读操作</span>
        ret = binder_thread_read(proc, thread, bwr.read_buffer,
                     bwr.read_size,
                     &amp;bwr.read_consumed,
                     filp-&gt;f_flags &amp; O_NONBLOCK);
        trace_binder_read_done(ret);
        <span class="hljs-keyword">if</span> (!list_empty(&amp;proc-&gt;todo))
            wake_up_interruptible(&amp;proc-&gt;wait);
        <span class="hljs-comment">//如果Binder读操作失败，则将bwr数据拷回到内核空间，并返回</span>
        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr)))
                ret = -EFAULT;
            <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
        }
    }

    <span class="hljs-comment">//将bwr数据拷回到内核空间，并返回</span>
    <span class="hljs-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr))) {
        ret = -EFAULT;
        <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
    }
<span class="hljs-keyword">out</span>:
    <span class="hljs-keyword">return</span> ret;
}</code></pre> 
<p>看下binder_thread_write写操作：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> binder_thread_write(<span class="hljs-keyword">struct</span> binder_proc *proc,
            <span class="hljs-keyword">struct</span> binder_thread *thread,
            binder_uintptr_t binder_buffer, size_t size,
            binder_size_t *consumed)
{
    uint32_t cmd;
    <span class="hljs-keyword">struct</span> binder_context *context = proc-&gt;context;
    <span class="hljs-keyword">void</span> __user *buffer = (<span class="hljs-keyword">void</span> __user *)(uintptr_t)binder_buffer;
    <span class="hljs-keyword">void</span> __user *ptr = buffer + *consumed;
    <span class="hljs-keyword">void</span> __user *end = buffer + size;

    <span class="hljs-keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
        <span class="hljs-keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr))
            <span class="hljs-keyword">return</span> -EFAULT;
        ptr += <span class="hljs-keyword">sizeof</span>(uint32_t);
        trace_binder_command(cmd);
        <span class="hljs-keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) {
            binder_stats.bc[_IOC_NR(cmd)]++;
            proc-&gt;stats.bc[_IOC_NR(cmd)]++;
            thread-&gt;stats.bc[_IOC_NR(cmd)]++;
        }
        <span class="hljs-keyword">switch</span> (cmd) {
         ......
         <span class="hljs-comment">//我们前面发送的命令就是BC_TRANSACTION</span>
         <span class="hljs-keyword">case</span> BC_TRANSACTION:
         <span class="hljs-keyword">case</span> BC_REPLY: {
            <span class="hljs-keyword">struct</span> binder_transaction_data tr;
            <span class="hljs-comment">//拷贝用户空间数据到内核空间tr</span>
            <span class="hljs-keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="hljs-keyword">sizeof</span>(tr)))
                <span class="hljs-keyword">return</span> -EFAULT;
            ptr += <span class="hljs-keyword">sizeof</span>(tr);
            binder_transaction(proc, thread, &amp;tr,
                       cmd == BC_REPLY, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> binder_transaction(<span class="hljs-keyword">struct</span> binder_proc *proc,
                   <span class="hljs-keyword">struct</span> binder_thread *thread,
                   <span class="hljs-keyword">struct</span> binder_transaction_data *tr, <span class="hljs-keyword">int</span> reply,
                   binder_size_t extra_buffers_size)
{
    ......
    <span class="hljs-keyword">if</span> (reply) {
        ......
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//因为我们传的tr-&gt;target.handle为0，也就是ServiceManager进程</span>
        <span class="hljs-keyword">if</span> (tr-&gt;target.handle) {
            ......
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//直接获取ServiceManager的在Binder驱动中的binder_node目标节点</span>
            target_node = context-&gt;binder_context_mgr_node;
        }
        <span class="hljs-comment">//获取ServiceManager的进程</span>
        target_proc = target_node-&gt;proc;
    }
    ......
    <span class="hljs-keyword">if</span> (target_thread) {
        e-&gt;to_thread = target_thread-&gt;pid;
        <span class="hljs-comment">//获取ServiceManager的TODO队列和等待队列</span>
        target_list = &amp;target_thread-&gt;todo;
        target_wait = &amp;target_thread-&gt;wait;
    }
    <span class="hljs-comment">//分配两个结构体内存</span>
    t = kzalloc(<span class="hljs-keyword">sizeof</span>(*t), GFP_KERNEL);
    binder_stats_created(BINDER_STAT_TRANSACTION);

    tcomplete = kzalloc(<span class="hljs-keyword">sizeof</span>(*tcomplete), GFP_KERNEL);
    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);
    ......
    <span class="hljs-comment">//为target_proc分配一块Buffer</span>
    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
        tr-&gt;offsets_size, extra_buffers_size,
        !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
    ......
    <span class="hljs-comment">//向target_list，也就是ServiceManager的TODO队列，添加BINDER_WORK_TRANSACTION事务</span>
    t-&gt;work.type = BINDER_WORK_TRANSACTION;
    list_add_tail(&amp;t-&gt;work.entry, target_list);
    <span class="hljs-comment">//向当前线程的TODO队列添加BINDER_WORK_TRANSACTION_COMPLETE事务</span>
    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
    <span class="hljs-comment">//如果ServiceManager进程正在等待，则唤醒</span>
    <span class="hljs-keyword">if</span> (target_wait) {
        <span class="hljs-keyword">if</span> (reply || !(t-&gt;flags &amp; TF_ONE_WAY))
            wake_up_interruptible_sync(target_wait);
        <span class="hljs-keyword">else</span>
            wake_up_interruptible(target_wait);
    }
    <span class="hljs-keyword">return</span>;
} </code></pre> 
<p><img src="https://images2.imgbox.com/e7/c0/suz63cp7_o.png" alt="这里写图片描述" title=""></p> 
<p>对比这张Binder架构图，Client就是cameraserver进程，Service就是servicemanager进程，整个注册服务的过程就是cameraserver进程发送BC_TRANSACTION命令到Binder驱动中，然后Binder驱动发送BR_TRANSACTION命令到servermanager进程中注册，这里会生成一个handle，用来标识”media.camera”服务，然后将此服务添加到svclist全局链表中。然后通过BC_REPLY命令将返回结果发送到Binder驱动中，Binder驱动再通过BR_REPLY命令将结果发送给cameraserver进程。</p> 
<p>至此，CameraService的servicename和实例就在ServiceManager中注册了，之后别的进程即可通过ServiceManager跨进程获取CameraService服务。并且CameraService通过onFirstRef()函数跟Camera HAL层联系起来了。</p> 
<p>作者：lb377463323 <br> 出处：<a href="http://blog.csdn.net/lb377463323">http://blog.csdn.net/lb377463323</a> <br> 原文链接：<a href="http://blog.csdn.net/lb377463323/article/details/78796915">http://blog.csdn.net/lb377463323/article/details/78796915</a> <br> 转载请注明出处！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e12530c983702d93a6023017efa7b07/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VR全景图片浏览实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4cab3fd182a3f4b694989f273eadba31/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android开发学习之路--APT技术</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>