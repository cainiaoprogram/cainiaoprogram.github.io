<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>POI之SXSSFWorkbook大量数据导出至excel - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="POI之SXSSFWorkbook大量数据导出至excel" />
<meta property="og:description" content="一：简介 SXSSFWorkbook是用来生成海量excel数据文件，主要原理是借助临时存储空间生成excel，
SXSSFWorkbook专门处理大数据，对于大型excel的创建且不会内存溢出的，就只有SXSSFWorkbook了。
它的原理很简单，用硬盘空间换内存（就像hashmap用空间换时间一样）。 SXSSFWorkbook是streaming
版本的XSSFWorkbook,它只会保存最新的excel rows在内存里供查看，在此之前的excel rows都会被写入到
硬盘里（Windows电脑的话，是写入到C盘根目录下的temp文件夹）。被写入到硬盘里的rows是不可见的/不
可访问的。只有还保存在内存里的才可以被访问到。 注:HSSFWorkbook和XSSFWorkbook的Excel Sheet导出条数上限(&lt;=2003版)是65535行、256列,(&gt;=2007版)
是1048576行,16384列,如果数据量超过了此上限,那么可以使用SXSSFWorkbook来导出。实际上上万条数据，
甚至上千条数据就可以考虑使用SXSSFWorkbook了。
注意：首先需要引入依赖：注意：4.0.0版本的JDK需要1.8以上，如果JDK是1.7的，那么就使用3.9版本的依赖
&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml-schemas --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; 二：实例一，我们使用SXSSFWorkbook向Excel中写入50万条数据，只需要 34秒左右，内存占用率最多在700M左右，CPU使用率在25%左右 代码如下：
package com.test.POI; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import org.apache.poi.openxml4j.exceptions.InvalidFormatException; import org.apache.poi.xssf.streaming.SXSSFRow; import org.apache.poi.xssf.streaming.SXSSFSheet; import org.apache.poi.xssf.streaming.SXSSFWorkbook; import org.apache.poi.xssf.usermodel.XSSFWorkbook; public class SXSSFWORKBookUtils { @SuppressWarnings(&#34;resource&#34;) public static void main(String[] args) throws FileNotFoundException, InvalidFormatException { long startTime = System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/877c6a94aa453e0fdb9fdbd0891afe38/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-24T01:02:30+08:00" />
<meta property="article:modified_time" content="2018-11-24T01:02:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">POI之SXSSFWorkbook大量数据导出至excel</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一：简介</h2> 
<p>          SXSSFWorkbook是用来生成海量excel数据文件，主要原理是借助临时存储空间生成excel，<br>           <a href="http://poi.apache.org/apidocs/org/apache/poi/xssf/streaming/SXSSFWorkbook.html" rel="nofollow">SXSSFWorkbook</a>专门处理大数据，对于大型excel的创建且不会内存溢出的，就只有SXSSFWorkbook了。<br>           它的原理很简单，用硬盘空间换内存（就像hashmap用空间换时间一样）。 SXSSFWorkbook是streaming<br>           版本的XSSFWorkbook,它只会保存最新的excel rows在内存里供查看，在此之前的excel rows都会被写入到<br>           硬盘里（Windows电脑的话，是写入到C盘根目录下的temp文件夹）。被写入到硬盘里的rows是不可见的/不<br>           可访问的。只有还保存在内存里的才可以被访问到。 <br>           注:HSSFWorkbook和XSSFWorkbook的Excel Sheet导出条数上限(&lt;=2003版)是65535行、256列,(&gt;=2007版)<br>                是1048576行,16384列,如果数据量超过了此上限,那么可以使用SXSSFWorkbook来导出。实际上上万条数据，<br>                甚至上千条数据就可以考虑使用SXSSFWorkbook了。<br>         注意：<strong><span style="color:#f33b45;">首先需要引入依赖：注意：4.0.0版本的JDK需要1.8以上，如果JDK是1.7的，那么就使用3.9版本的依赖</span></strong></p> 
<pre class="has"><code class="language-java">	&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml-schemas --&gt;
		&lt;dependency&gt;
		    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
		    &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt;
		    &lt;version&gt;4.0.0&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;
		&lt;dependency&gt;
		    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
		    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;
		    &lt;version&gt;4.0.0&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --&gt;
		&lt;dependency&gt;
		    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
		    &lt;artifactId&gt;poi&lt;/artifactId&gt;
		    &lt;version&gt;4.0.0&lt;/version&gt;
		&lt;/dependency&gt;</code></pre> 
<h2>二：实例一，我们使用SXSSFWorkbook向Excel中写入50万条数据，只需要         34秒左右，内存占用率最多在700M左右，CPU使用率在25%左右           <br>         <img alt="" class="has" height="64" src="https://images2.imgbox.com/ec/c2/UiczqDiB_o.png" width="624"></h2> 
<p><br>            代码如下：</p> 
<pre class="has"><code class="language-java">package com.test.POI;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.xssf.streaming.SXSSFRow;
import org.apache.poi.xssf.streaming.SXSSFSheet;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

public class SXSSFWORKBookUtils {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException, InvalidFormatException {
		long startTime = System.currentTimeMillis();
		String filePath = "E:\\txt\\111.xlsx";
		SXSSFWorkbook sxssfWorkbook = null;
		BufferedOutputStream outputStream = null;
		try {
			//这样表示SXSSFWorkbook只会保留100条数据在内存中，其它的数据都会写到磁盘里，这样的话占用的内存就会很少
			 sxssfWorkbook = new SXSSFWorkbook(getXSSFWorkbook(filePath),100);
			 //获取第一个Sheet页
			 SXSSFSheet sheet = sxssfWorkbook.getSheetAt(0);
			 for (int i = 0; i &lt; 50; i++) {
				 for (int z = 0; z &lt; 10000; z++) {
					 SXSSFRow row = sheet.createRow(i*10000+z);
					 for (int j = 0; j &lt; 10; j++) {
						 row.createCell(j).setCellValue("你好："+j);
					 }
				 }
			}
			 outputStream = new BufferedOutputStream(new FileOutputStream(filePath));
			 sxssfWorkbook.write(outputStream);
			 outputStream.flush();
			 sxssfWorkbook.dispose();// 释放workbook所占用的所有windows资源
		} catch (IOException e) {
			e.printStackTrace();
		}finally {
			if(outputStream!=null) {
				try {
					outputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
		long endTime = System.currentTimeMillis();
		System.out.println(endTime-startTime);
	}
	
	
	/**
	 * 先创建一个XSSFWorkbook对象
	 * @param filePath
	 * @return
	 */
	public static XSSFWorkbook getXSSFWorkbook(String filePath) {
		XSSFWorkbook workbook =  null;
		BufferedOutputStream outputStream = null;
		try {
			File fileXlsxPath = new File(filePath);
			outputStream = new BufferedOutputStream(new FileOutputStream(fileXlsxPath));
			workbook = new XSSFWorkbook();
			workbook.createSheet("测试Sheet");
			workbook.write(outputStream);
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			if(outputStream!=null) {
				try {
					outputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
		return workbook;
	}
	
}
</code></pre> 
<p>  效果：<br>       <img alt="" class="has" height="119" src="https://images2.imgbox.com/80/e3/5jdzO9ll_o.png" width="273"></p> 
<h2>三：我们使用XSSFWorkbook常规的方法分批向excel中写入50万条数据，内         存占用率最多在  2.1个G左右（占用了很大的内存），CPU使用率在90%           左右 ，最后内存 溢出了</h2> 
<p>          <img alt="" class="has" height="137" src="https://images2.imgbox.com/e9/c1/FhLqwn4g_o.png" width="636"><br>           代码如下：<br>           </p> 
<pre class="has"><code class="language-java">package com.test;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

public class POIController {
	/**
	 * 这种方式效率比较低并且特别占用内存，数据量越大越明显
	 * @param args
	 * @throws FileNotFoundException
	 * @throws InvalidFormatException
	 */
	public static void main(String[] args) throws FileNotFoundException, InvalidFormatException {
		long startTime = System.currentTimeMillis();
		BufferedOutputStream outPutStream = null;
		XSSFWorkbook workbook = null;
		FileInputStream inputStream = null;
		String filePath = "E:\\txt\\666.xlsx";
		try {
			 workbook = getWorkBook(filePath);
			 XSSFSheet sheet = workbook.getSheetAt(0);
			 for (int i = 0; i &lt; 50; i++) {
				 for (int z = 0; z &lt; 10000; z++) {
					 XSSFRow row = sheet.createRow(i*10000+z);
					 for (int j = 0; j &lt; 10; j++) {
						 row.createCell(j).setCellValue("你好："+j);
					 }
				 }
				 //每次要获取新的文件流对象，避免将之前写入的数据覆盖掉
				 outPutStream = new BufferedOutputStream(new FileOutputStream(filePath));
				 workbook.write(outPutStream);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}finally {
			if(outPutStream!=null) {
				try {
					outPutStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(inputStream!=null) {
				try {
					inputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(workbook!=null) {
				try {
					workbook.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
		long endTime = System.currentTimeMillis();
		System.out.println(endTime-startTime);
	}
	/**
	 * 先创建一个XSSFWorkbook对象
	 * @param filePath
	 * @return
	 */
	public static XSSFWorkbook getWorkBook(String filePath) {
		XSSFWorkbook workbook =  null;
		try {
			File fileXlsxPath = new File(filePath);
			BufferedOutputStream outPutStream = new BufferedOutputStream(new FileOutputStream(fileXlsxPath));
			workbook = new XSSFWorkbook();
			workbook.createSheet("测试");
			workbook.write(outPutStream);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return workbook;
	}
	
}
</code></pre> 
<p>效果：<br>    <img alt="" class="has" height="271" src="https://images2.imgbox.com/4b/54/7WmtAjs2_o.png" width="692"><br>         </p> 
<p><a href="https://blog.csdn.net/K_520_W/article/details/84349811">上一篇：POI分多次向生成的EXCEL中写入数据</a></p> 
<p><a href="https://blog.csdn.net/K_520_W/article/details/82824868">文章目录</a><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c48b2de6c3a5b0043ada7f02a1e9fce1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">word中分栏后文字均匀的分布在了左右两栏,而不是填满左栏再填右栏,怎么办?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f5cf197b0024d785114d28625c3e1b0f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">internal_error:xst:cmain.c:3423:1.29</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>