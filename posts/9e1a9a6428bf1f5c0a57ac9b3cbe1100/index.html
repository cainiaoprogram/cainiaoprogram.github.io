<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>NVDEC_VideoDecoder_API_ProgGuide - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="NVDEC_VideoDecoder_API_ProgGuide" />
<meta property="og:description" content="概述 从 NVIDIA® Fermi™ 一代开始，英伟达GPU包含一个视频解码器引擎（本文中简称NVDEC），它提供全硬件加速解码视频的能力。NVDEC能解码许多码流格式： H.264, HEVC (H.265), VP8, VP9, MPEG-1, MPEG-2, MPEG-4 and VC-1. NVDEC运行完全独立于计算/图像引擎。
英伟达提供编程NVDEC的软件API和库。这套软件API，以下称为NVDECODE API，它使开发者能访问NVDEC的解码特性，并且能让NVDEC与GPU上的其它引擎交互。
NVDEC解码压缩的视频流，然后复制解码后的YUV帧到显存，因此CUDA可以后续处理位于显存中的YUV帧。对于大多数流行的输出视频格式，NVDECODE API 也提供一些常用的CUDA优化的后处理，比如缩放、裁剪、宽高比转换、反交错和色彩空间转换。
解码后的视频帧可以传递给显示器播放，直接传给NVENC进行高性能视频转码，用于GPU加速的推理，通过CUDA或者基于CPU后续处理。
NVDECODE API 支持的解码格式如下：
‣ MPEG-1,
‣ MPEG-2,
‣ MPEG4,
‣ VC-1,
‣ H.264 (AVCHD) (8 bit),
‣ H.265 (HEVC) (8bit, 10 bit and 12 bit),
‣ VP8,
‣ VP9(8bit, 10 bit and 12 bit),
‣ Hybrid (CUDA &#43; CPU) JPEG
视频解码能力 下表展示每种GPU架构支持的解码格式和视频解码能力。
[1] 只支持 GP104, Turing 和 GA100" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9e1a9a6428bf1f5c0a57ac9b3cbe1100/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-16T17:43:58+08:00" />
<meta property="article:modified_time" content="2020-09-16T17:43:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">NVDEC_VideoDecoder_API_ProgGuide</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>概述</h2> 
<p>从 NVIDIA® Fermi™ 一代开始，英伟达GPU包含一个视频解码器引擎（本文中简称NVDEC），它提供全硬件加速解码视频的能力。NVDEC能解码许多码流格式： H.264, HEVC (H.265), VP8, VP9, MPEG-1, MPEG-2, MPEG-4 and VC-1. NVDEC运行完全独立于计算/图像引擎。</p> 
<p>英伟达提供编程NVDEC的软件API和库。这套软件API，以下称为NVDECODE API，它使开发者能访问NVDEC的解码特性，并且能让NVDEC与GPU上的其它引擎交互。</p> 
<p>NVDEC解码压缩的视频流，然后复制解码后的YUV帧到显存，因此CUDA可以后续处理位于显存中的YUV帧。对于大多数流行的输出视频格式，NVDECODE API 也提供一些常用的CUDA优化的后处理，比如缩放、裁剪、宽高比转换、反交错和色彩空间转换。</p> 
<p>解码后的视频帧可以传递给显示器播放，直接传给NVENC进行高性能视频转码，用于GPU加速的推理，通过CUDA或者基于CPU后续处理。</p> 
<p>NVDECODE API 支持的解码格式如下：<br> ‣ MPEG-1,<br> ‣ MPEG-2,<br> ‣ MPEG4,<br> ‣ VC-1,<br> ‣ H.264 (AVCHD) (8 bit),<br> ‣ H.265 (HEVC) (8bit, 10 bit and 12 bit),<br> ‣ VP8,<br> ‣ VP9(8bit, 10 bit and 12 bit),<br> ‣ Hybrid (CUDA + CPU) JPEG</p> 
<h2><a id="_20"></a>视频解码能力</h2> 
<p>下表展示每种GPU架构支持的解码格式和视频解码能力。<br> <img src="https://images2.imgbox.com/7e/52/6Ee6dveG_o.png" alt="在这里插入图片描述"></p> 
<p>[1] 只支持 GP104, Turing 和 GA100<br> [2] GP10x GPUs 支持 VP9 10-bit 和 12-bit 解码</p> 
<h2><a id="_27"></a>视频解码管道</h2> 
<p>解码管道包含三个主要的组件：解封装器，视频解析器，视频解码器。每个组件互不依赖因此能独立使用。NVDECODE API提供英伟达视频解析器和英伟达视频解码器API。英伟达视频解析器是一个纯软件组件，用户可以用自己的插件替换（比如ffmpeg解析器）。<br> <img src="https://images2.imgbox.com/0b/31/xZUGdDaK_o.png" alt="在这里插入图片描述"><br> 使用NVDECODE API 解码视频的步骤大致如下：</p> 
<ol><li>创建一个CUDA上下文。</li><li>查询硬件解码器的解码能力。</li><li>创建解码器实例。</li><li>解封装，这个可以使用第三方软件，如FFMPEG。</li><li>使用NVDECODE API 提供的解析器提取视频流，或者第三方解析器如FFMPEG。</li><li>使用NVDECODE API 开始解码。</li><li>获得解码后的YUV数据，用于后续处理。</li><li>查询解码帧的状态。</li><li>根据解码帧的状态，使用解码后的输出进行后续处理，比如：渲染，推理，后加工等。</li><li>如果应用程序需要显示解码后的输出： 
  <ul><li>将解码后的YUV 转换为RGBA</li><li>映射RGBA 到 DirectX or OpenGL 纹理</li><li>在屏幕上绘制纹理</li></ul> </li><li>完成解码过程后销毁解码器实例 。</li><li>销毁CUDA上下文。</li></ol> 
<h2><a id="_48"></a>使用英伟达视频解码器</h2> 
<p>所有的 NVDECODE APIs 声明在两个头文件中： cuviddec.h 和 nvcuvid.h。这些头文件存放在Video Codec SDK中的 …\Samples\NvCodec\NvDecoder 目录下。 NVIDIA Video Codec SDK 中的示例静态加载库函数，在源文件中包含cuviddec.h 和nvcuvid.h ，SDK包中包含静态库文件。windows 动态库nvcuvid.dll 包含在windows显卡驱动中，linux 动态库libnvcuvid.so 则包含在linux显卡驱动中。</p> 
<h3><a id="_51"></a>视频解析器</h3> 
<h4><a id="_52"></a>创建解析器</h4> 
<p>填充好 <code>CUVIDPARSERPARAMS</code>结构体后，通过调用 <code>cuvidCreateVideoParser()</code> 可以创建解析器对象。这个结构体应该填充好以下关于需要解码的流的信息。</p> 
<ul><li> <p>CodecType ：必须取值于 <code>enum cudaVideoCodec</code>，指示解码的类型，比如 <code>H.264, HEVC, VP9</code>等</p> </li><li> <p>ulMaxNumDecodeSurfaces：这是解析器的解码图片缓存的表面数量。这个值在解析器初始化时可能不知道，在创建解析器对象时可以预先设置成1. 应用必须向驱动注册一个回调函数 <code>pfnSequenceCallback</code>，当解析器遇到第一个序列头或者这个序列发生了任何变化时会回调这个函数。这个回调函数通过参数<code>CUVIDEOFORMAT::min_num_decode_surfaces</code>报告为了正确解码，解析器的解码图片缓存需要的最小的表面数量。如果想更新<code>CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces，</code>这个序列回调函数可能返回这个值给解析器，如果这个值大于1，解析器可以使用这个值重新设置<code>CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces</code>。因此，为了内存分配优化，解码器对象创建时使用的缓存数量，应该使用： <code>CUVIDDECODECREATEINFO::ulNumDecodeSurfaces =</code><br> CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces.</p> </li><li> <p>ulMaxDisplayDelay：调用显示回调函数延迟。0代表没有延迟</p> </li><li> <p>pfnSequenceCallback ： 应用必须注册一个回调函数序列改变的情况。当解析器初始化序列头或者视频格式改变时，触发这个回调函数。序列回调函数的返回值由驱动程序解释如下：</p> 
  <ul><li>0：失败</li><li>1：成功，但是不应该重新设置<code>CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces</code></li><li>&gt; 1 ： 成功，应该使用返回的值重新设置<code>CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces</code></li></ul> </li><li> <p>pfnDecodePicture ： 当一帧的码流数据准备好时，解析器触发这个回调函数。对于奇偶场的图片，因为两个场组成一帧，每一次显示回调会有两次解码回调。这个回调函数的返回值解释如下：</p> 
  <ul><li>0 ： failed</li><li>&gt;= 1 ：成功</li></ul> </li><li> <p>pfnDisplayPicture ： 当一帧按显示顺序准备就绪时，解析器调用这个函数。返回值同上。</p> </li></ul> 
<h4><a id="_69"></a>提取数据包</h4> 
<p>从解封装器中提取的数据包使用<code>cuvidParseVideoData()</code>函数传递给解析器，与此同时，当序列发生改变或者一帧画面已准备好解码或显示时，解析器触发创建解析器对象时注册的回调函数。</p> 
<p>解码后数据通过一个<code>CUVIDPICPARAMS</code>里的图片索引绑定，它由解析器提供。这个图片索引后续用于将解码帧映射到CUDA内存。</p> 
<h4><a id="_73"></a>销毁解析器</h4> 
<p>用户需要调用 <code>cuvidDestroyVideoParser()</code>函数销毁解析器对象以及释放所有分配的资源。</p> 
<h3><a id="_76"></a>视频解码器</h3> 
<h4><a id="_77"></a>查询解码能力</h4> 
<p>如表1所示，不同的GPU包含不同的能力. 因此，为了确保你的应用能在所有的GPU硬件上运行，很有必要查询硬件能力，然后根据所需的能力是否满足进行合适的操作。</p> 
<p>API <code>cuvidGetDecoderCaps()</code> 让用户能够查询底层硬件视频的解码能力。进行调用的线程应该有一个有效的CUDA上下文与之绑定。</p> 
<p>客户端在调用 <code>cuvidGetDecoderCaps()</code> 之前应该填充以下参数。</p> 
<p>‣ eCodecType: Codec type (H.264, HEVC, VP9, JPEG etc.)<br> ‣ eChromaFormat: 4:2:0, 4:4:4, etc.<br> ‣ nBitDepthMinus8: 0 for 8-bit, 2 for 10-bit, 4 for 12-bit</p> 
<p>当<code>cuvidGetDecoderCaps()</code> 调用后，底层驱动填充<code>CUVIDDECODECAPS</code>的剩余字段，显示对于查询的能力的支持情况。</p> 
<p>示例：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// set IN params for decodeCaps</span>
decodeCaps<span class="token punctuation">.</span>eCodecType <span class="token operator">=</span> cudaVideoCodec_HEVC<span class="token punctuation">;</span><span class="token comment">//HEVC </span>
decodeCaps<span class="token punctuation">.</span>eChromaFormat <span class="token operator">=</span> cudaVideoChromaFormat_420<span class="token punctuation">;</span><span class="token comment">//YUV 4:2:0</span>
decodeCaps<span class="token punctuation">.</span>nBitDepthMinus8 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 10 bit</span>
result <span class="token operator">=</span> <span class="token function">cuvidGetDecoderCaps</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>decodeCaps<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Check if content is supported</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>decodecaps<span class="token punctuation">.</span>bIsSupported<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token function">NVDEC_THROW_ERROR</span><span class="token punctuation">(</span>Codec <span class="token operator">not</span> supported on <span class="token keyword">this</span> GPU"<span class="token punctuation">,</span>
 CUDA_ERROR_NOT_SUPPORTED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// validate the content resolution supported on underlying hardware</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>coded_width <span class="token operator">&gt;</span> decodecaps<span class="token punctuation">.</span>nMaxWidth<span class="token punctuation">)</span> <span class="token operator">||</span>
 <span class="token punctuation">(</span>coded_height <span class="token operator">&gt;</span> decodecaps<span class="token punctuation">.</span>nMaxHeight<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token function">NVDEC_THROW_ERROR</span><span class="token punctuation">(</span>Resolution <span class="token operator">not</span> supported on <span class="token keyword">this</span> GPU"<span class="token punctuation">,</span>
 CUDA_ERROR_NOT_SUPPORTED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Max supported macroblock count CodedWidth*CodedHeight/256 must be &lt;= nMaxMBCount</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>coded_width<span class="token operator">&gt;&gt;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>coded_height<span class="token operator">&gt;&gt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> decodecaps<span class="token punctuation">.</span>nMaxMBCount<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token function">NVDEC_THROW_ERROR</span><span class="token punctuation">(</span>MBCount <span class="token operator">not</span> supported on <span class="token keyword">this</span> GPU"<span class="token punctuation">,</span>
CUDA_ERROR_NOT_SUPPORTED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Check supported output format</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>decodecaps<span class="token punctuation">.</span>nOutputFormatMask <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>cudaVideoSurfaceFormat_NV12<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token comment">// Decoder supports output surface format NV12</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>decodecaps<span class="token punctuation">.</span>nOutputFormatMask <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>cudaVideoSurfaceFormat_P010<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token comment">// Decoder supports output surface format P010</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_123"></a>创建解码器</h4> 
<p>在创建解码器示例之前，用户需要一个有效的CUDA上下文，它将在整个解码过程中使用。</p> 
<p>在填充<code>CUVIDDECODECREATEINFO</code>结构体后，通过调用<code>cuvidCreateDecoder()</code>创建解码器实例。<code>CUVIDDECODECREATEINFO</code>应该填充以下关于需要解码的流的信息：</p> 
<ul><li>CodecType ：必须取值于 <code>enum cudaVideoCodec</code>，指示解码的类型，比如 <code>H.264, HEVC, VP9</code>等</li><li>ulWidth, ulHeight ： 编码的宽和高，使用像素单位</li><li>ulMaxWidth, ulMaxHeight ： 解码器支持的最大宽高，当视频流的分辨率发生改变，并且不超过（ulMaxWidth, ulMaxHeight ），app 可以<code>cuvidReconfigureDecoder()</code>API 重新配置解码器，而不必销毁再重新创建解码器。如果ulMaxWidth 或 ulMaxHeight 设置为0，ulMaxWidth 和 ulMaxHeight 会分别设置为ulWidth 和ulHeight .</li><li>ChromaFormat：必须取值于<code>enum cudaVideoChromaFormat</code>，它代表色彩格式 4:2:0, 4:4:4,等</li><li>bitDepthMinus8 ： 视频流的位宽减去8，例如0代表8位，2代表10位。</li><li>ulNumDecodeSurfaces ： 正如本文中其它地方提到的解码表面，这是驱动为了保存解码帧内部分配的解码表面数量。更大的数字可以提供更好的流水线但会增大GPU内存消耗。<code>CUVIDEOFORMAT::min_num_decode_surfaces</code>中定义了最小的数字，可以从英伟达解析器的第一次序列回调函数中获取。NVDEC引擎将解码后的数据写入这些表面。用户无法通过NVDECODE<br> API访问这些表面，但是映射阶段，包括解码器格式转换，缩放，裁剪等，使用这些表面作为输入。</li><li>ulNumOutputSurfaces ： 这是客户端为了进行后续处理使用<code>cuvidMapVideoFrame().</code>同步映射解码表面的输出表面数量。这些表面将解码后表面进行后续处理后提供给客户端使用。驱动内部分配相应数量的表面（以下本文中指输出表面），客户端可以访问输出表面。</li><li>OutputFormat：输出表面的格式定义在<code>enum cudaVideoSurfaceFormat</code>，输出表面的格式必须是通过<code>cuvidGetDecoderCaps()</code>获取的<code>decodecaps.nOutputFormatMask</code>里支持的格式之一。如果传递的格式不支持，API会报错<code>CUDA_ERROR_NOT_SUPPORTED</code></li><li>ulTargetWidth, ulTargetHeight ： 输出表面的宽高，如果bu’she’ji缩放，这两个值应该分别设置为ulWidth, ulHeight</li><li>DeinterlaceMode ： 对于逐行扫面的画面，这个值应该设置成 <code>cudaVideoDeinterlaceMode_Weave</code>或 <code>cudaVideoDeinterlaceMode_Bob</code>。对于交错模式，设置成<code>cudaVideoDeinterlaceMode_Adaptive</code>，<code>cudaVideoDeinterlaceMode_Adaptive</code>质量更高但是内存消耗也更大。</li><li>ulCreationFlags ： 定义在<code>enum cudaVideoCreateFlags</code>，它是可选参数，如果没有定义，驱动会选择适合的模式。</li><li>ulIntraDecodeOnly ： 设置为1指示驱动，数据只包含I/IDR帧，这个参数帮助优化内存消耗。如果包含非I帧不要设置此参数。</li></ul> 
<p><code>cuvidCreateDecoder()</code>使用解码器句柄填充<code>CUvideodecoder</code>，在整个解码器会话期间，该句柄应该一直保留。该句柄需要被其它 NVDECODE API调用传递。</p> 
<p>用户可以指定<code>CUVIDDECODECREATEINFO</code>中的下列参数控制最终输出：</p> 
<ul><li>缩放尺寸</li><li>裁剪尺寸</li><li>宽高比</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// Scaling. Source size is 1280x960. Scale to 1920x1080.</span>
CUresult rResult<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> uScaleW<span class="token punctuation">,</span> uScaleH<span class="token punctuation">;</span>
uScaleW <span class="token operator">=</span> <span class="token number">1920</span><span class="token punctuation">;</span>
uScaleH <span class="token operator">=</span> <span class="token number">1080</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
CUVIDDECODECREATEINFO stDecodeCreateInfo<span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stDecodeCreateInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CUVIDDECODECREATEINFO<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Setup the remaining structure members</span>
stDecodeCreateInfo<span class="token punctuation">.</span>ulTargetWidth <span class="token operator">=</span> uScaleWidth<span class="token punctuation">;</span>
stDecodeCreateInfo<span class="token punctuation">.</span>ulTargetHeight <span class="token operator">=</span> uScaleHeight<span class="token punctuation">;</span>
rResult <span class="token operator">=</span> <span class="token function">cuvidCreateDecoder</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hDecoder<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stDecodeCreateInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Cropping. Source size is 1280x960</span>
CUresult rResult<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> uCropL<span class="token punctuation">,</span> uCropR<span class="token punctuation">,</span> uCropT<span class="token punctuation">,</span> uCropB<span class="token punctuation">;</span>
uCropL <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
uCropR <span class="token operator">=</span> <span class="token number">700</span><span class="token punctuation">;</span>
uCropT <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
uCropB <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
CUVIDDECODECREATEINFO stDecodeCreateInfo<span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stDecodeCreateInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CUVIDDECODECREATEINFO<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Setup the remaining structure members</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
stDecodeCreateInfo<span class="token punctuation">.</span>display_area<span class="token punctuation">.</span>left <span class="token operator">=</span> uCropL<span class="token punctuation">;</span>
stDecodeCreateInfo<span class="token punctuation">.</span>display_area<span class="token punctuation">.</span>right <span class="token operator">=</span> uCropR<span class="token punctuation">;</span>
stDecodeCreateInfo<span class="token punctuation">.</span>display_area<span class="token punctuation">.</span>top <span class="token operator">=</span> uCropT<span class="token punctuation">;</span>
stDecodeCreateInfo<span class="token punctuation">.</span>display_are<span class="token punctuation">.</span>bottom <span class="token operator">=</span> uCropB<span class="token punctuation">;</span>
rResult <span class="token operator">=</span> <span class="token function">cuvidCreateDecoder</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hDecoder<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stDecodeCreateInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// Aspect Ratio Conversion. Source size is 1280x960(4:3). Convert to</span>
<span class="token comment">// 16:9 </span>
CUresult rResult<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> uCropL<span class="token punctuation">,</span> uCropR<span class="token punctuation">,</span> uCropT<span class="token punctuation">,</span> uCropB<span class="token punctuation">;</span>
uDispAR_L <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
uDispAR_R <span class="token operator">=</span> <span class="token number">1280</span><span class="token punctuation">;</span>
uDispAR_T <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span>
uDispAR_B <span class="token operator">=</span> <span class="token number">790</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
CUVIDDECODECREATEINFO stDecodeCreateInfo<span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stDecodeCreateInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CUVIDDECODECREATEINFO<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// setup structure members</span>
stDecodeCreateInfo<span class="token punctuation">.</span>target_rect<span class="token punctuation">.</span>left <span class="token operator">=</span> uDispAR_L<span class="token punctuation">;</span>
stDecodeCreateInfo<span class="token punctuation">.</span>target_rect<span class="token punctuation">.</span>right <span class="token operator">=</span> uDispAR_R<span class="token punctuation">;</span>
stDecodeCreateInfo<span class="token punctuation">.</span>target_rect<span class="token punctuation">.</span>top <span class="token operator">=</span> uDispAR_T<span class="token punctuation">;</span>
stDecodeCreateInfo<span class="token punctuation">.</span>target_rect<span class="token punctuation">.</span>bottom <span class="token operator">=</span> uDispAR_B<span class="token punctuation">;</span>
reResult <span class="token operator">=</span> <span class="token function">cuvidCreateDecoder</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hDecoder<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stDecodeCreateInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<h4><a id="_202"></a>解码帧/场</h4> 
<p>在解封装和解析之后，客户端可以将一帧或一场数据传递给硬件解码器解码，步骤如下：</p> 
<ul><li>填充<code>CUVIDPICPARAMS</code>结构体 
  <ul><li>客户端需要使用解析过程中得到的参数填充这个结构体，<code>CUVIDPICPARAMS</code>包含一个特定于每个解码器的数据结构，它也应该被填充。</li></ul> </li><li>调用<code>cuvidDecodePicture()</code>并传递解码器句柄，在 NVDEC上开始解码。</li></ul> 
<h4><a id="_209"></a>准备解码后的帧进行后处理</h4> 
<p>用户需要通过调用<code>cuvidMapVideoFrame()</code>函数获取输出表面的CUDA设备指针和pitch大小，输出表面保存经过解码和后处理的帧。</p> 
<p><code>cuvidDecodePicture()</code>指导NVDEC硬件引擎开始解码帧/场.。然而，<code>cuvidMapVideoFrame()</code>调用成功意味着解码过程完成，而且解码后的格式转换成了<code>CUVIDDECODECREATEINFO::OutputFormat</code>中指定的yuv格式。</p> 
<p>API <code>cuvidMapVideoFrame()</code>使用解码表面索引作为输入，将它映射到一个有效的输出表面，对解码帧进行后处理然后拷贝到输出表面，返回CUDA设备指针和输出表面关联的pitch.</p> 
<p>上文的<code>cuvidMapVideoFrame()</code>操作以下称为mapping.</p> 
<p>在用户处理完帧后，必须调用<code>cuvidUnmapVideoFrame()</code>使得输出表面再次可用。</p> 
<p>如果在<code>cuvidMapVideoFrame()</code>之后，用户调用 cuvidUnmapVideoFrame()持续失败， <code>cuvidMapVideoFrame()</code>最终也会失败，最多<code>CUVIDDECODECREATEINFO::ulNumOutputSurfaces</code>数量的帧可以被映射。</p> 
<p><code>cuvidMapVideoFrame()</code>是一个阻塞式调用，它等待解码完成。如果<code>cuvidMapVideoFrame()和</code>cuvidDecodePicture()在同一个cpu线程调用，它会阻塞<code>cuvidDecodePicture()</code>。建议用户使用生产者-消费者队列，解码线程作为生产者，映射线程作为消费者。解码线程在显示回调函数中添加图片索引到队列，并且从回调函数迅速返回继续进行解码后面的帧。另一方面，映射线程监测队列，一旦有数据，使用<code>nPicIdx</code>作为图片索引调用<code>cuvidMapVideoFrame(…)</code>。解码线程必须确保避免用于存放解码后的输出的解码图片缓存，在被映射线程消费并释放之前被重复使用。</p> 
<p>示例：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// MapFrame: Call cuvidMapVideoFrame and get the devptr and associated </span>
<span class="token comment">// pitch. Copy this surface (in device memory) to host memory using </span>
<span class="token comment">// CUDA device to host memcpy.</span>
<span class="token keyword">bool</span> <span class="token function">MapFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 CUVIDPARSEDISPINFO stDispInfo<span class="token punctuation">;</span>
 CUVIDPROCPARAMS stProcParams<span class="token punctuation">;</span>
 CUresult rResult<span class="token punctuation">;</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cuDevPtr<span class="token punctuation">;</span> <span class="token keyword">int</span> nPitch<span class="token punctuation">,</span> nPicIdx<span class="token punctuation">;</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> pHostPtr<span class="token punctuation">;</span>
 <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stDispInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CUVIDPARSEDISPINFO<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stProcParams<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CUVIDPROCPARAMS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// setup stProcParams if required</span>
 <span class="token comment">// retrieve the frames from the Frame Display Queue. This Queue is</span>
 <span class="token comment">// is populated in HandlePictureDisplay.</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>g_pFrameQueue<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stDispInfo<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
 nPicIdx <span class="token operator">=</span> stDispInfo<span class="token punctuation">.</span>picture_index<span class="token punctuation">;</span>
 rResult <span class="token operator">=</span> <span class="token function">cuvidMapVideoFrame</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hDecoder<span class="token punctuation">,</span> nPicIdx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cuDevPtr<span class="token punctuation">,</span>
 <span class="token operator">&amp;</span>nPitch<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stProcParams<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// use CUDA based Device to Host memcpy</span>
 pHostPtr <span class="token operator">=</span> <span class="token function">cuMemAllocHost</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>pHostPtr<span class="token punctuation">,</span> nPitch<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>pHostPtr<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
 rResult <span class="token operator">=</span> <span class="token function">cuMemcpyDtoH</span><span class="token punctuation">(</span>pHostPtr<span class="token punctuation">,</span> cuDevPtr<span class="token punctuation">,</span> nPitch<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 rResult <span class="token operator">=</span> <span class="token function">cuvidUnmapVideoFrame</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hDecoder<span class="token punctuation">,</span> cuDevPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Dump YUV to a file</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>pHostPtr<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
 <span class="token function">cuMemFreeHost</span><span class="token punctuation">(</span>pHostPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在大多数使用场景下，NVDEC会成为性能瓶颈，如果驱动里的NVDEC 等待队列满了，<code>cuvidDecodePicture()</code>会卡住。</p> 
<h4><a id="_265"></a>查询解码状态</h4> 
<p>解码开始后， 可以随时调用<code>cuvidGetDecodeStatus()</code>查询帧的解码状态。底层驱动填充解码状态到<code>CUVIDGETDECODESTATUS::*pDecodeStatus</code>。</p> 
<p>NVDECODEAPI目前报告以下状态：</p> 
<ul><li>解码中</li><li>解码完成</li><li>码流损坏，被NVENC隐藏</li><li>码流损坏，无法被NVENC隐藏<br> 这个API用于需要根据帧的状态进行进一步操作的场景，比如是否推理一帧。</li></ul> 
<h4><a id="_275"></a>重新配置解码器</h4> 
<p>在码流分辨率发生改变或者修改后处理参数，API <code>cuvidReconfigureDecoder()</code>可以直接重新配置解码器，而不需要销毁解码器实例再重新创建。</p> 
<p>以下是使用<code>cuvidReconfigureDecoder()</code>的步骤：</p> 
<ul><li>用户在调用<code>cuvidCreateDecoder().</code>时需要指定<code>CUVIDDECODECREATEINFO::ulMaxWidth 和 CUVIDDECODECREATEINFO::ulMaxHeight</code>，用户需要确定在整个解码过程中码流的分辨率都不会超过这两个值。请注意，在一个解码会话中，这两个值都不允许改变。</li><li>当码流发生改变时，<code>cuvidReconfigureDecoder()</code>理论上应该在<code>CUVIDPARSERPARAMS::pfnSequenceCallback</code>中被调用。用户想重新配置的参数应该填充在<code>::CUVIDRECONFIGUREDECODERINFO</code>。请注意，<code>CUVIDRECONFIGUREDECODERINFO::ulWidth</code>和<code>CUVIDRECONFIGUREDECODERINFO::ulHeight</code>必须小于等于<code>CUVIDDECODECREATEINFO::ulMaxWidth和</code>CUVIDDECODECREATEINFO::ulMaxHeight<code>的值，否则</code>cuvidReconfigureDecoder()`会失败。</li></ul> 
<h4><a id="_282"></a>销毁解码器</h4> 
<p>用户应该调用<code>cuvidDestroyDecoder()</code>销毁解码器会话，并且释放所以分配的解码器资源。</p> 
<h4><a id="_284"></a>编写高性能解码应用</h4> 
<p>英伟达GPU上的NVDEC引擎是一个专用的硬件块，它解码支持的视频码流格式。一个典型视频解码应用大致包含以下几步：</p> 
<ul><li>解封装</li><li>视频码流解析和解码</li><li>准备帧进行进一步处理</li></ul> 
<p>这些步骤中，解封装和解析不带硬件加速因此超出了本文范围. 解封装可以使用第三方组件比如ffmpeg，它支持许多视频格式。SDK中的示例使用ffmpeg解封装。同样的，解码后处理可以使用用户自定义的CUDA核。进一步处理后的视频帧可以送往显示引擎显示。</p> 
<p>为了有效的管道操作，NVDEC驱动内部维护了一个4帧的队列。请注意，这个队列并不意味着解码延迟，一旦有帧进入队列，解码立即开始，只要队列未满，应用就可以排队帧。</p> 
<p>对于高性能和低延迟的视频解码应用，确保 PCIE 链接宽度设置为最大的有效值，PCIE 链接宽度的当前值可以通过运行<code>'nvidia-smi -q'.</code>命令获取，它可以在系统的BIOS设置中配置。</p> 
<p>在码流分辨率或者后处理参数经常改变的使用场景中，推荐使用<code>cuvidReconfigureDecoder()</code>，而不是先销毁再重新创建解码器。</p> 
<p>为了优化视频内存使用，以下步骤应该被遵守：</p> 
<ul><li> <p>保证<code>CUVIDDECODECREATEINFO::ulNumDecodeSurfaces = CUVIDEOFORMAT:: min_num_decode_surfaces</code>，它是在正确解码的情况下，驱动分配最小的最小解码表面。如果解码性能下降，可以适当增大`CUVIDDECODECREATEINFO::ulNumDecodeSurfaces</p> </li><li> <p><code>CUVIDDECODECREATEINFO::ulNumOutputSurfaces</code>应该在经过平衡吞吐量和内存消耗的测试后选择合适的值。</p> </li><li> <p><code>CUVIDDECODECREATEINFO::DeinterlaceMode</code>应该设置为<code>cudaVideoDeinterlaceMode_Weave</code>或<br> <code>cudaVideoDeinterlaceMode_Bob</code>.对于交错模式，使用<code>cudaVideoDeinterlaceMode_Adaptive</code>会提过质量但是会增大内存消耗，使用<code>cudaVideoDeinterlaceMode_Weave</code>或<code>cudaVideoDeinterlaceMode_Bob</code>.则相反</p> </li><li> <p>解码多路视频流时，推荐分配最小数量的CUDA上下然后在不同的会话间共享，这有利于节省创建CUDA上下文的内存支出。</p> </li><li> <p>如果预先知道码流只包含I帧 <code>CUVIDDECODECREATEINFO::ulIntraDecodeOnly</code>应该设置为1，这个特性只支持HEVC, H.264 和 VP9。然而如果这个标志位打开，但是码流中包含P帧或B帧，解码可能失败。</p> </li></ul> 
<p>SDK中示例用于演示各种API的功能，但可能没有全部优化，因此开发者应该确保他们的应该是精心设计的，在解封装、解析，解码各个阶段，以有效的方式结构化，以达到预期的性能和内存消耗。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4c1cf47e7c2a4a687f7bc98ec7334b04/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pymysql的使用-从数据库获取数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/302f6a946fc936cf588498587b765825/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">已解决 : org.apache.catalina.connector.ClientAbortException: java.io.IOException: 你的主机中的软件中止了一个已建立的连接。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>