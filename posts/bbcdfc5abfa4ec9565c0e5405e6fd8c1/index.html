<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java Web中的入侵检测及简单实现 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java Web中的入侵检测及简单实现" />
<meta property="og:description" content="作者：EasyJF开源团队 大峡
一、简介
在Java Web应用程中，特别是网站开发中，我们有时候需要为应用程序增加一个入侵检测程序来防止恶意刷新的功能，防止非法用户不断的往Web应用中重复发送数据。当然，入侵检测可以用很多方法实现，包括软件、硬件防火墙，入侵检测的策略也很多。在这里我们主要介绍的是Java Web应用程序中通过软件的方式实现简单的入侵检测及防御。
该方法的实现原理很简单，就是用户访问Web系统时记录每个用户的信息，然后进行对照，并根据设定的策略(比如：1秒钟刷新页面10次)判断用户是否属于恶意刷新。
我们的入侵检测程序应该放到所有Java Web程序的执行前，也即若发现用户是恶意刷新就不再继续执行Java Web中的其它部分内容，否则就会失去了意义。这就需要以插件的方式把入侵检测的程序置入Java Web应用中，使得每次用户访问Java Web，都先要到这个入侵检测程序中报一次到，符合规则才能放行。
Java Web应用大致分为两种，一种纯JSP(&#43;Java Bean)方式，一种是基于框架(如Struts、EasyJWeb等)的。第一种方式的Java Web可以通过Java Servlet中的Filter接口实现，也即实现一个Filter接口，在其doFilter方法中插入入侵检测程序，然后再web.xml中作简单的配置即可。在基于框架的Web应用中，由于所有应用都有一个入口，因此可以把入侵检测的程序直接插入框架入口引擎中，使框架本身支持入侵检测功能。当然,也可以通过实现Filter接口来实现。
在EasyJWeb框架中，已经置入了简单入侵检测的程序，因此，这里我们以EasyJWeb框架为例,介绍具体的实现方法及源码，完整的代码可以在EasyJWeb源码中找到。
在基于EasyJWeb的Java Web应用中(如http://www.easyjf.com/bbs/)，默认情况下你只要连续刷新页面次数过多，即会弹出如下的错误：
EasyJWeb框架友情提示!:-): 您对页面的刷新太快,请等待60秒后再刷新页面！ 详细请查询http://www.easyjf.com 二、用户访问信息记录UserConnect.java类　这个类是一个简单的Java Bean，主要代表用户的信息，包括用户名、IP、第一次访问时间、最后登录时间、登录次数、用户状态等。全部
代码如下：
package com.easyjf.web;
import java.util.Date;
/**
*
* &lt;p&gt;Title:用户验证信息&lt;/p&gt;
* &lt;p&gt;Description:记录用户登录信息,判断用户登录情况&lt;/p&gt;
* &lt;p&gt;Copyright: Copyright (c) 2006&lt;/p&gt;
* &lt;p&gt;Company: www.easyjf.com&lt;/p&gt;
* @author 蔡世友
* @version 1.0
*/
public class UserConnect {
private String userName;
private String ip;
private Date firstFailureTime;
private Date lastLoginTime;
private int failureTimes;//用户登录失败次数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bbcdfc5abfa4ec9565c0e5405e6fd8c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2006-04-10T12:09:00+08:00" />
<meta property="article:modified_time" content="2006-04-10T12:09:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java Web中的入侵检测及简单实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>　　　　　　作者：<a href="http://www.easyjf.com" rel="nofollow">EasyJF开源团队</a> 大峡<br><br><strong>一、简介</strong><br><br>　　在Java Web应用程中，特别是网站开发中，我们有时候需要为应用程序增加一个入侵检测程序来防止恶意刷新的功能，防止非法用户不断的往Web应用中重复发送数据。当然，入侵检测可以用很多方法实现，包括软件、硬件防火墙，入侵检测的策略也很多。在这里我们主要介绍的是Java Web应用程序中通过软件的方式实现简单的入侵检测及防御。</p> 
<p>　　该方法的实现原理很简单，就是用户访问Web系统时记录每个用户的信息，然后进行对照，并根据设定的策略(比如：1秒钟刷新页面10次)判断用户是否属于恶意刷新。</p> 
<p>　　我们的入侵检测程序应该放到所有Java Web程序的执行前，也即若发现用户是恶意刷新就不再继续执行Java Web中的其它部分内容，否则就会失去了意义。这就需要以插件的方式把入侵检测的程序置入Java Web应用中，使得每次用户访问Java Web，都先要到这个入侵检测程序中报一次到，符合规则才能放行。</p> 
<p>　　Java Web应用大致分为两种，一种纯JSP(+Java Bean)方式，一种是基于框架(如Struts、EasyJWeb等)的。第一种方式的Java Web可以通过Java Servlet中的Filter接口实现，也即实现一个Filter接口，在其doFilter方法中插入入侵检测程序，然后再web.xml中作简单的配置即可。在基于框架的Web应用中，由于所有应用都有一个入口，因此可以把入侵检测的程序直接插入框架入口引擎中，使框架本身支持入侵检测功能。当然,也可以通过实现Filter接口来实现。</p> 
<p>　　在EasyJWeb框架中，已经置入了简单入侵检测的程序，因此，这里我们以EasyJWeb框架为例,介绍具体的实现方法及源码，完整的代码可以在EasyJWeb源码中找到。</p> 
<p>　　在基于EasyJWeb的Java Web应用中(如<a href="http://www.easyjf.com/bbs/" rel="nofollow">http://www.easyjf.com/bbs/</a>)，默认情况下你只要连续刷新页面次数过多，即会弹出如下的错误：</p> 
<p>　　EasyJWeb框架友情提示!:-): <br><font color="#ff0000">　　您对页面的刷新太快,请等待60秒后再刷新页面！ <br>　　详细请查询<a href="http://www.easyjf.com" rel="nofollow noopener noreferrer" target="_blank">http://www.easyjf.com</a> </font></p> 
<font color="#ff0000"></font> 
<p><br><strong>二、用户访问信息记录UserConnect.java类</strong>　　<br><br>　　这个类是一个简单的Java Bean，主要代表用户的信息，包括用户名、IP、第一次访问时间、最后登录时间、登录次数、用户状态等。全部<br><br>代码如下：<br><br>package com.easyjf.web;</p> 
<p>import java.util.Date;<br>/**<br>*<br>* &lt;p&gt;Title:用户验证信息&lt;/p&gt;<br>* &lt;p&gt;Description:记录用户登录信息,判断用户登录情况&lt;/p&gt;<br>* &lt;p&gt;Copyright: Copyright (c) 2006&lt;/p&gt;<br>* &lt;p&gt;Company: <a href="http://www.easyjf.com&lt;/p" rel="nofollow">www.easyjf.com&lt;/p</a>&gt;<br>* @author 蔡世友<br>* @version 1.0<br>*/<br>public class UserConnect {<!-- --><br>private String userName;<br>private String ip;<br>private Date firstFailureTime;<br>private Date lastLoginTime;<br>private int failureTimes;//用户登录失败次数<br>private int status=0;//用户状态0表示正常,-1表示锁定<br>public int getFailureTimes() {<!-- --><br> return failureTimes;<br>}<br>public void setFailureTimes(int failureTimes) {<!-- --><br> this.failureTimes = failureTimes;<br>}<br>public Date getFirstFailureTime() {<!-- --><br> return firstFailureTime;<br>}</p> 
<p>public void setFirstFailureTime(Date firstFailureTime) {<!-- --><br> this.firstFailureTime = firstFailureTime;<br>}</p> 
<p>public String getIp() {<!-- --><br> return ip;<br>}</p> 
<p>public void setIp(String ip) {<!-- --><br> this.ip = ip;<br>}</p> 
<p>public Date getLastLoginTime() {<!-- --><br> return lastLoginTime;<br>}</p> 
<p>public void setLastLoginTime(Date lastLoginTime) {<!-- --><br> this.lastLoginTime = lastLoginTime;<br>}</p> 
<p>public String getUserName() {<!-- --><br> return userName;<br>}</p> 
<p>public void setUserName(String userName) {<!-- --><br> this.userName = userName;<br>}</p> 
<p>public int getStatus() {<!-- --><br> return status;<br>}</p> 
<p>public void setStatus(int status) {<!-- --><br> this.status = status;<br>}</p> 
<p>}</p> 
<p><br><strong>三、监控线程UserConnectManage.java类</strong><br><br>　　这是入侵检测的核心部分，主要实现具体的入侵检测、记录、判断用户信息、在线用户的刷新等功能，并提供其它应用程序使用本组件的调用接口。<br><br>package com.easyjf.web;</p> 
<p>import java.util.Date;<br>import java.util.HashMap;<br>import java.util.HashSet;<br>import java.util.Iterator;<br>import java.util.Map;<br>import java.util.Set;</p> 
<p>import org.apache.log4j.Logger;<br>/**<br>*<br>* &lt;p&gt;Title:用户入侵检测信息&lt;/p&gt;<br>* &lt;p&gt;Description:用于判断用户刷新情况检查，默认为10秒钟之内连续连接10次为超时&lt;/p&gt;<br>* &lt;p&gt;Copyright: Copyright (c) 2006&lt;/p&gt;<br>* &lt;p&gt;Company: <a href="http://www.easyjf.com&lt;/p" rel="nofollow">www.easyjf.com&lt;/p</a>&gt;<br>* @author 蔡世友<br>* @version 1.0<br>*/<br>public class UserConnectManage {<!-- --><br>private static final Logger logger = (Logger) Logger.getLogger(UserConnectManage.class.getName());<br>private static int maxFailureTimes=10;//最大登录失败次数<br>private static long maxFailureInterval=10000;//毫秒，达到最大登录次数且在这个时间范围内<br>private static long waitInterval=60000;//失败后接受连接的等待时间，默认1分钟<br>private static int maxOnlineUser=200;//同时在线的最大数<br>private final static Map users=new HashMap();//使用ip+userName为key存放用户登录信息UserLoginAuth<br>private static Thread checkThread=null;<br>private static class CheckTimeOut implements Runnable{ <br>private Thread parentThread;<br>public  CheckTimeOut(Thread parentThread) <br> {<!-- --><br>  this.parentThread=parentThread; <br>  synchronized(this){<!-- --><br>  if(checkThread==null){    <br>   checkThread= new Thread(this);<br>   //System.out.println("创建一个新线程！");<br>   checkThread.start();   <br>     }<br>  }<br> } <br> public void run() {  <br>  while(true)<br>  {<!-- --><br>   if(parentThread.isAlive()){<!-- --><br>   try{<!-- --><br>   Thread.sleep(2000);<br>   int i=0;<br>   if(users.size()&gt;maxOnlineUser)//当达到最大用户数时清除<br>   {<!-- --><br>    synchronized(users){//执行删除操作<br>    Iterator it=users.keySet().iterator();<br>    Set set=new HashSet();<br>    Date now=new Date();<br>    while(it.hasNext())<br>    {<!-- --><br>     Object key=it.next();<br>     UserConnect user=(UserConnect)users.get(key);<br>     if(now.getTime()-user.getFirstFailureTime().getTime()&gt;maxFailureInterval)//删除超时的用户<br>     {      <br>      set.add(key);<br>      logger.info("删除了一个超时的连接"+i);<br>      i++;<br>     }<br>    }<br>    if(i&lt;5)//如果删除少于5个，则强行删除1/2在线记录，牺牲性能的情况下保证内存<br>    {<!-- --><br>     int num=maxOnlineUser/2;<br>     it=users.keySet().iterator();<br>     while(it.hasNext() &amp;&amp; i&lt;num)<br>     {      <br>      set.add(it.next());<br>      logger.info("删除了一个多余的连接"+i);<br>      i++;<br>     }<br>    }<br>    users.keySet().removeAll(set);<br>    }<br>   }<br>   <br>   }<br>   catch(Exception e)<br>   {<!-- --><br>    e.printStackTrace();<br>   }<br>   <br>  }<br>   else<br>   {   <br>   break;<br>   }<br>  }<br>  logger.info("监视程序运行结束！"); <br> }<br>}<br>//通过checkLoginValidate判断是否合法的登录连接，如果合法则继续，非法则执行<br>public static boolean checkLoginValidate(String ip,String userName)//只检查认证失败次数<br>{<!-- --><br> boolean ret=true;<br> Date now=new Date(); <br> String key=ip+":"+userName;<br> UserConnect auth=(UserConnect)users.get(key);<br> if(auth==null)//把用户当前的访问信息加入到users容器中<br> {<!-- --><br>  auth=new UserConnect();<br>  auth.setIp(ip);<br>  auth.setUserName(userName);<br>  auth.setFailureTimes(0);<br>  auth.setFirstFailureTime(now);<br>  users.put(key,auth);  <br>  if(checkThread==null)new CheckTimeOut(Thread.currentThread());<br> } <br> else<br> {<!-- --><br>  if(auth.getFailureTimes()&gt;maxFailureTimes)<br>  {<!-- --><br>           //如果在限定的时间间隔内，则返回拒绝用户连接的信息<br>   if((now.getTime()-auth.getFirstFailureTime().getTime())&lt;maxFailureInterval)<br>   {<!-- --><br>    ret=false;<br>    auth.setStatus(-1);<br>   }<br>   else  if(auth.getStatus()==-1 &amp;&amp; (now.getTime()-auth.getFirstFailureTime().getTime()&lt;(maxFailureInterval+waitInterval)))//重置计数器<br>   {<!-- --><br>    ret=false;<br>   }<br>   else    <br>   {    <br>    auth.setFailureTimes(0);<br>    auth.setFirstFailureTime(now);<br>    auth.setStatus(0);<br>   }<br>   <br>  }<br>  //登录次数加1<br>  auth.setFailureTimes(auth.getFailureTimes()+1);<br> }<br> //System.out.println(key+":"+auth.getFailureTimes()+":"+ret+":"+(now.getTime()-auth.getFirstFailureTime().getTime()));<br> return ret;<br>}</p> 
<p>public static void reset(String ip,String userName)//重置用户信息<br>{ <br> Date now=new Date(); <br> String key=ip+":"+userName;<br> UserConnect auth=(UserConnect)users.get(key);<br> if(auth==null)//把用户当前的访问信息加入到users容器中<br> {<!-- --><br>  auth=new UserConnect();<br>  auth.setIp(ip);<br>  auth.setUserName(userName);<br>  auth.setFailureTimes(0);<br>  auth.setFirstFailureTime(now);<br>  users.put(key,auth);<br> } <br> else<br> {<!-- --><br>  auth.setFailureTimes(0);<br>  auth.setFirstFailureTime(now);<br> }<br>}<br>public static void remove(String ip,String userName)//删除用户在容器中的记录<br>{<!-- --><br> String key=ip+":"+userName;<br> users.remove(key);<br>}<br>public static void clear()//清空容器中内容<br>{<!-- --><br> if(!users.isEmpty())users.clear();<br>}<br>public static long getMaxFailureInterval() {<!-- --><br> return maxFailureInterval;<br>}</p> 
<p>public static void setMaxFailureInterval(long maxFailureInterval) {<!-- --><br> UserConnectManage.maxFailureInterval = maxFailureInterval;<br>}</p> 
<p>public static int getMaxFailureTimes() {<!-- --><br> return maxFailureTimes;<br>}</p> 
<p>public static void setMaxFailureTimes(int maxFailureTimes) {<!-- --><br> UserConnectManage.maxFailureTimes = maxFailureTimes;<br>}</p> 
<p>public static int getMaxOnlineUser() {<!-- --><br> return maxOnlineUser;<br>}</p> 
<p>public static void setMaxOnlineUser(int maxOnlineUser) {<!-- --><br> UserConnectManage.maxOnlineUser = maxOnlineUser;<br>}</p> 
<p>public static long getWaitInterval() {<!-- --><br> return waitInterval;<br>}</p> 
<p>public static void setWaitInterval(long waitInterval) {<!-- --><br> UserConnectManage.waitInterval = waitInterval;<br>}</p> 
<p><br><strong>四、调用接口</strong><br><br>　　在需要进入侵检测判断的地方，直接使用UserConnectManage类中的checkLoginValidate方法即可。如EasyJWeb的核心Servlet　<br><br>com.easyjf.web.ActionServlet中调用UserConnectManage的代码：<br>   if(!UserConnectManage.checkLoginValidate(request.getRemoteAddr(),"guest"))<br>       {            <br>           info(request,response,new Exception("您对页面的刷新太快,请等待"+UserConnectManage.getWaitInterval()/1000+"秒<br><br>后再刷新页面！"));<br>           return;<br>       }      <br><br>　　<br>　　　　<br><strong>五、总结</strong><br>　　当然，这里提供的方法只是一个简单的实现示例，由于上面的用户信息是直接保存在内存中，若并发用户很大的时候的代码的占用，可以考虑引入数据库来记录用户的访问信息，当然相应的执行效率肯定用降低。上面介绍的实现中，入侵检测判断的策略也只有用户访问次数及时间间隔两个元素，您还可以根据你的实现情况增加其它的检测元素。<br><br>　　由于水平有限，该设计上有N不合理或者需要改进的地方，恳请大家指正！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d8aac906033a16e989aa9b3c8e1b12b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常用软件滤波方法及其示例程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/155db83bcd2aac5fdabc8b9f9281d7fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">通用SQL数据库查询语句精华使用简介(1)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>