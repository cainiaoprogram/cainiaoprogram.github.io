<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>EXECUTABLE AND LINKABLE FORMAT (ELF) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="EXECUTABLE AND LINKABLE FORMAT (ELF)" />
<meta property="og:description" content="Notes on the Flat-Text Transcription
The content of this transcription differs from the content of the
original document in the following ways.
1. Page breaks and pagination have been omitted.
2. As a result of the above, the page numbers have been left out of
the table of contents, and the index has been omitted entirely.
(Unlike a Postscript document, a text file can be searched.)
3. The contents of the title page and the footer text has been placed" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/38afa049263477c7e26d80c5e2f1514d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2004-11-12T08:05:00+08:00" />
<meta property="article:modified_time" content="2004-11-12T08:05:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">EXECUTABLE AND LINKABLE FORMAT (ELF)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre>		 Notes on the Flat-Text Transcription<br><br>The content of this transcription differs from the content of the<br>original document in the following ways.<br><br>1. Page breaks and pagination have been omitted.<br>2. As a result of the above, the page numbers have been left out of<br>   the table of contents, and the index has been omitted entirely.<br>   (Unlike a Postscript document, a text file can be searched.)<br>3. The contents of the title page and the footer text has been placed<br>   at the beginning.<br>4. The lines and boxes in the original figures and tables have been<br>   adapted.<br>5. Differing fonts have, of necessity, been elided. For the most part,<br>   the context is sufficient to understand the meaning. In a few<br>   places, however, the original document used italics to implicitly<br>   indicate that the text stood for a variable string. In these cases,<br>   I have used &lt;angle brackets&gt; around the text to indicate this.<br>   There are no occurrences of angle brackets in the original.<br>6. The original contains three errors which are not immediately<br>   obvious as such upon a casual reading, but which can be<br>   unambiguously identified as such and the proper contents<br>   determined. I have taken the liberty to correct these errors. Their<br>   locations are marked in the text by a {*}. Any other (seeming)<br>   errors I have let stand.<br><br><strong>Any other differences between the contents of this file and the<br>original are my responsibility. Direct notices of such errors to<br>breadbox@muppetlabs.com.<br><br>Brian Raiter<br>[Last edited Fri Jul 23 1999]</strong>     ________________________________________________________________   		 EXECUTABLE AND LINKABLE FORMAT (ELF)  	     Portable Formats Specification, Version 1.1 		    Tool Interface Standards (TIS)     ________________________________________________________________      =========================== Contents ===========================      PREFACE 1. OBJECT FILES    Introduction    ELF Header    Sections    String Table    Symbol Table    Relocation 2. PROGRAM LOADING AND DYNAMIC LINKING    Introduction    Program Header    Program Loading    Dynamic Linking 3. C LIBRARY    C Library     ________________________________________________________________   			       PREFACE     ________________________________________________________________   		  ELF: Executable and Linking Format  The Executable and Linking Format was originally developed and published by UNIX System Laboratories (USL) as part of the Application Binary Interface (ABI). The Tool Interface Standards committee (TIS) has selected the evolving ELF standard as a portable object file format that works on 32-bit Intel Architecture environments for a variety of operating systems.  The ELF standard is intended to streamline software development by providing developers with a set of binary interface definitions that extend across multiple operating environments. This should reduce the number of different interface implementations, thereby reducing the need for recoding and recompiling code.   			 About This Document  This document is intended for developers who are creating object or executable files on various 32-bit environment operating systems. It is divided into the following three parts:  * Part 1, ``Object Files'' describes the ELF object file format for   the three main types of object files. * Part 2, ``Program Loading and Dynamic Linking'' describes the object   file information and system actions that create running programs. * Part 3, ``C Library'' lists the symbols contained in libsys, the   standard ANSI C and libc routines, and the global data symbols   required by the libc routines.  NOTE: References to X86 architecture have been changed to Intel Architecture.     ________________________________________________________________   			   1. OBJECT FILES     ________________________________________________________________      ========================= Introduction =========================   Part 1 describes the iABI object file format, called ELF (Executable and Linking Format). There are three main types of object files.  * A relocatable file holds code and data suitable for linking with   other object files to create an executable or a shared object file. * An executable file holds a program suitable for execution; the file   specifies how exec(BA_OS) creates a program's process image. * A shared object file holds code and data suitable for linking in two   contexts. First, the link editor [see ld(SD_CMD)] may process it   with other relocatable and shared object files to create another   object file. Second, the dynamic linker combines it with an   executable file and other shared objects to create a process image.  Created by the assembler and link editor, object files are binary representations of programs intended to execute directly on a processor. Programs that require other abstract machines, such as shell scripts, are excluded.  After the introductory material, Part 1 focuses on the file format and how it pertains to building programs. Part 2 also describes parts of the object file, concentrating on the information necessary to execute a program.   			     File Format  Object files participate in program linking (building a program) and program execution (running a program). For convenience and efficiency, the object file format provides parallel views of a file's contents, reflecting the differing needs of these activities. Figure 1-1 shows an object file's organization.  + Figure 1-1: Object File Format    Linking View                      Execution View   ============                      ==============   ELF header                        ELF header<br>  Program header table (optional)   Program header table<br>  Section 1                         Segment 1<br>  ...                               Segment 2<br>  Section n                         ...<br>  Section header table              Section header table (optional)<br><br>An ELF header resides at the beginning and holds a ``road map''<br>describing the file's organization. Sections hold the bulk of object<br>file information for the linking view: instructions, data, symbol<br>table, relocation information, and so on. Descriptions of special<br>sections appear later in Part 1. Part 2 discusses segments and the<br>program execution view of the file.<br><br>A program header table, if present, tells the system how to create a<br>process image. Files used to build a process image (execute a program)<br>must have a program header table; relocatable files do not need one. A<br>section header table contains information describing the file's<br>sections. Every section has an entry in the table; each entry gives<br>information such as the section name, the section size, etc. Files<br>used during linking must have a section header table; other object<br>files may or may not have one.<br><br>NOTE: Although the figure shows the program header table immediately<br>after the ELF header, and the section header table following the<br>sections, actual files may differ. Moreover, sections and segments<br>have no specified order. Only the ELF header has a fixed position in<br>the file.<br><br><br>			 Data Representation<br><br>As described here, the object file format supports various processors<br>with 8-bit bytes and 32-bit architectures. Nevertheless, it is<br>intended to be extensible to larger (or smaller) architectures.<br>Object files therefore represent some control data with a<br>machine-independent format, making it possible to identify object<br>files and interpret their contents in a common way. Remaining data in<br>an object file use the encoding of the target processor, regardless of<br>the machine on which the file was created.<br><br>+ Figure 1-2: 32-Bit Data Types<br><br>  Name           Size Alignment   Purpose<br>  ====           ==== =========   =======<br>  Elf32_Addr      4       4       Unsigned program address<br>  Elf32_Half      2       2       Unsigned medium integer<br>  Elf32_Off       4       4       Unsigned file offset<br>  Elf32_Sword     4       4       Signed large integer<br>  Elf32_Word      4       4       Unsigned large integer<br>  unsigned char   1       1       Unsigned small integer<br><br>All data structures that the object file format defines follow the<br>``natural'' size and alignment guidelines for the relevant class. If<br>necessary, data structures contain explicit padding to ensure 4-byte<br>alignment for 4-byte objects, to force structure sizes to a multiple<br>of 4, etc. Data also have suitable alignment from the beginning of the<br>file. Thus, for example, a structure containing an Elf32_Addr member<br>will be aligned on a 4-byte boundary within the file.<br><br>For portability reasons, ELF uses no bit-fields.<br><br><br>   ========================== ELF Header ==========================<br><br><br>Some object file control structures can grow, because the ELF header<br>contains their actual sizes. If the object file format changes, a<br>program may encounter control structures that are larger or smaller<br>than expected. Programs might therefore ignore``extra'' information.<br>The treatment of ``missing'' information depends on context and will<br>be specified when and if extensions are defined.<br><br>+ Figure 1-3: ELF Header<br><br>  #define EI_NIDENT       16<br><br>  typedef struct {<!-- --><br>      unsigned char       e_ident[EI_NIDENT];<br>      Elf32_Half          e_type;<br>      Elf32_Half          e_machine;<br>      Elf32_Word          e_version;<br>      Elf32_Addr          e_entry;<br>      Elf32_Off           e_phoff;<br>      Elf32_Off           e_shoff;<br>      Elf32_Word          e_flags;<br>      Elf32_Half          e_ehsize;<br>      Elf32_Half          e_phentsize;<br>      Elf32_Half          e_phnum;<br>      Elf32_Half          e_shentsize;<br>      Elf32_Half          e_shnum;<br>      Elf32_Half          e_shstrndx;<br>  } Elf32_Ehdr;<br><br>* e_ident<br><br>  The initial bytes mark the file as an object file and provide<br>  machine-independent data with which to decode and interpret the<br>  file's contents. Complete descriptions appear below, in ``ELF<br>  Identification.''<br><br>* e_type<br><br>  This member identifies the object file type.<br><br>               Name        Value  Meaning<br>               ====        =====  =======<br>               ET_NONE         0  No file type<br>               ET_REL          1  Relocatable file<br>               ET_EXEC         2  Executable file<br>               ET_DYN          3  Shared object file<br>	       ET_CORE         4  Core file<br>	       ET_LOPROC  0xff00  Processor-specific<br>	       ET_HIPROC  0xffff  Processor-specific<br><br>  Although the core file contents are unspecified, type ET_CORE is<br>  reserved to mark the file. Values from ET_LOPROC through ET_HIPROC<br>  (inclusive) are reserved for processor-specific semantics. Other<br>  values are reserved and will be assigned to new object file types as<br>  necessary.<br><br>* e_machine<br><br>  This member's value specifies the required architecture for an<br>  individual file.<br><br>                    Name      Value  Meaning<br>	            ====      =====  =======<br>                    EM_NONE       0  No machine<br>		    EM_M32        1  AT&amp;T WE 32100<br>                    EM_SPARC      2  SPARC<br>                    EM_386        3  Intel 80386<br>                    EM_68K        4  Motorola 68000<br>                    EM_88K        5  Motorola 88000<br>                    EM_860        7  Intel 80860<br>                    EM_MIPS       8  MIPS RS3000<br><br>  Other values are reserved and will be assigned to new machines as<br>  necessary. Processor-specific ELF names use the machine name to<br>  distinguish them. For example, the flags mentioned below use the<br>  prefix EF_; a flag named WIDGET for the EM_XYZ machine would be<br>  called EF_XYZ_WIDGET.<br><br>* e_version<br><br>  This member identifies the object file version.<br><br>                 Name         Value  Meaning<br>                 ====         =====  =======<br>                 EV_NONE          0  Invalid version<br>		 EV_CURRENT       1  Current version<br><br>  The value 1 signifies the original file format; extensions will<br>  create new versions with higher numbers. The value of EV_CURRENT,<br>  though given as 1 above, will change as necessary to reflect the<br>  current version number.<br><br>* e_entry<br><br>  This member gives the virtual address to which the system first<br>  transfers control, thus starting the process. If the file has no<br>  associated entry point, this member holds zero.<br><br>* e_phoff<br><br>  This member holds the program header table's file offset in bytes.<br>  If the file has no program header table, this member holds zero.<br><br>* e_shoff<br><br>  This member holds the section header table's file offset in bytes.<br>  If the file has no section header table, this member holds zero.<br><br>* e_flags<br><br>  This member holds processor-specific flags associated with the file.<br>  Flag names take the form EF_&lt;machine&gt;_&lt;flag&gt;. See ``Machine<br>  Information'' for flag definitions.<br><br>* e_ehsize<br><br>  This member holds the ELF header's size in bytes.<br><br>* e_phentsize<br><br>  This member holds the size in bytes of one entry in the file's<br>  program header table; all entries are the same size.<br><br>* e_phnum<br><br>  This member holds the number of entries in the program header<br>  table. Thus the product of e_phentsize and e_phnum gives the table's<br>  size in bytes. If a file has no program header table, e_phnum holds<br>  the value zero.<br><br>* e_shentsize<br><br>  This member holds a section header's size in bytes. A section header<br>  is one entry in the section header table; all entries are the same<br>  size.<br><br>* e_shnum<br><br>  This member holds the number of entries in the section header table.<br>  Thus the product of e_shentsize and e_shnum gives the section header<br>  table's size in bytes. If a file has no section header table,<br>  e_shnum holds the value zero.<br><br>* e_shstrndx<br><br>  This member holds the section header table index of the entry<br>  associated with the section name string table. If the file has no<br>  section name string table, this member holds the value SHN_UNDEF.<br>  See ``Sections'' and ``String Table'' below for more information.<br><br><br>			  ELF Identification<br><br>As mentioned above, ELF provides an object file framework to support<br>multiple processors, multiple data encodings, and multiple classes of<br>machines. To support this object file family, the initial bytes of the<br>file specify how to interpret the file, independent of the processor<br>on which the inquiry is made and independent of the file's remaining<br>contents.<br><br>The initial bytes of an ELF header (and an object file) correspond to<br>the e_ident member.<br><br>+ Figure 1-4: e_ident[] Identification Indexes<br><br>  Name           Value  Purpose<br>  ====           =====  =======<br>  EI_MAG0	     0  File identification<br>  EI_MAG1	     1  File identification<br>  EI_MAG2	     2  File identification<br>  EI_MAG3	     3  File identification<br>  EI_CLASS	     4  File class<br>  EI_DATA	     5  Data encoding<br>  EI_VERSION	     6  File version<br>  EI_PAD	     7  Start of padding bytes<br>  EI_NIDENT	    16  Size of e_ident[]<br><br>These indexes access bytes that hold the following values.<br><br>* EI_MAG0 to EI_MAG3<br><br>  A file's first 4 bytes hold a ``magic number,'' identifying the file<br>  as an ELF object file.<br><br>                  Name       Value  Position<br>                  ====       =====  ========<br>		  ELFMAG0    0x7f   e_ident[EI_MAG0]<br>                  ELFMAG1    'E'    e_ident[EI_MAG1]<br>                  ELFMAG2    'L'    e_ident[EI_MAG2]<br>                  ELFMAG3    'F'    e_ident[EI_MAG3]<br><br>* EI_CLASS<br><br>  The next byte, e_ident[EI_CLASS], identifies the file's class, or<br>  capacity.<br><br>                 Name           Value  Meaning<br>                 ====           =====  =======<br>                 ELFCLASSNONE       0  Invalid class<br>                 ELFCLASS32         1  32-bit objects<br>		 ELFCLASS64         2  64-bit objects<br><br>  The file format is designed to be portable among machines of various<br>  sizes, without imposing the sizes of the largest machine on the<br>  smallest. Class ELFCLASS32 supports machines with files and virtual<br>  address spaces up to 4 gigabytes; it uses the basic types defined<br>  above.<br><br>  Class ELFCLASS64 is reserved for 64-bit architectures. Its<br>  appearance here shows how the object file may change, but the 64-bit<br>  format is otherwise unspecified. Other classes will be defined as<br>  necessary, with different basic types and sizes for object file<br>  data.<br><br>* EI_DATA<br><br>  Byte e_ident[EI_DATA] specifies the data encoding of the<br>  processor-specific data in the object file. The following encodings<br>  are currently defined.<br><br>             Name           Value  Meaning<br>             ====           =====  =======<br>	     ELFDATANONE        0  Invalid data encoding<br>             ELFDATA2LSB        1  See below<br>             ELFDATA2MSB        2  See below<br><br>  More information on these encodings appears below. Other values are<br>  reserved and will be assigned to new encodings as necessary.<br><br>* EI_VERSION<br><br>  Byte e_ident[EI_VERSION] specifies the ELF header version number.<br>  Currently this, value must be EV_CURRENT, as explained above for<br>  e_version.<br><br>* EI_PAD<br><br>  This value marks the beginning of the unused bytes in e_ident. These<br>  bytes are reserved and set to zero; programs that read object files<br>  should ignore them.  The value of EI_PAD will change in the future<br>  if currently unused bytes are given meanings.<br><br>A file's data encoding specifies how to interpret the basic objects in<br>a file. As described above, class ELFCLASS32 files use objects that<br>occupy 1, 2, and 4 bytes. Under the defined encodings, objects are<br>represented as shown below. Byte numbers appear in the upper left<br>corners.<br><br>Encoding ELFDATA2LSB specifies 2's complement values, with the least<br>significant byte occupying the lowest address.<br><br>+ Figure 1-5: Data Encoding ELFDATA2LSB<br><br>               0------+<br>      0x0102   |  01  |<br>               +------+<br>               0------1------+<br>    0x010204   |  02  |  01  |<br>               +------+------+<br>               0------1------2------3------+<br>  0x01020304   |  04  |  03  |  02  |  01  |<br>               +------+------+------+------+<br><br>ELFDATA2MSB specifies 2's complement values, with the most significant<br>byte occupying the lowest address.<br><br>+ Figure 1-6: Data Encoding ELFDATA2MSB<br><br>               0------+<br>      0x0102   |  01  |<br>               +------+<br>               0------1------+<br>    0x010204   |  01  |  02  |<br>               +------+------+<br>               0------1------2------3------+<br>  0x01020304   |  01  |  02  |  03  |  04  |<br>               +------+------+------+------+<br><br><br>			 Machine Information<br><br>For file identification in e_ident, the 32-bit Intel Architecture<br>requires the following values.<br><br>+ Figure 1-7: 32-bit Intel Architecture Identification, e_ident <br><br>  Position           Value<br>  ========           =====<br>  e_ident[EI_CLASS]  ELFCLASS32<br>  e_ident[EI_DATA]   ELFDATA2LSB<br><br>Processor identification resides in the ELF header's e_machine member<br>and must have the value EM_386.<br><br>The ELF header's e_flags member holds bit flags associated with the<br>file. The 32-bit Intel Architecture defines no flags; so this member<br>contains zero.<br><br><br>   =========================== Sections ===========================<br><br><br>An object file's section header table lets one locate all the file's<br>sections. The section header table is an array of Elf32_Shdr<br>structures as described below. A section header table index is a<br>subscript into this array. The ELF header's e_shoff member gives the<br>byte offset from the beginning of the file to the section header<br>table; e_shnum tells how many entries the section header table<br>contains; e_shentsize gives the size in bytes of each entry.<br><br>Some section header table indexes are reserved; an object file will<br>not have sections for these special indexes.<br><br>+ Figure 1-8: Special Section Indexes<br><br>  Name             Value<br>  ====             =====<br>  SHN_UNDEF            0<br>  SHN_LORESERVE   0xff00<br>  SHN_LOPROC      0xff00<br>  SHN_HIPROC      0xff1f<br>  SHN_ABS         0xfff1<br>  SHN_COMMON      0xfff2<br>  SHN_HIRESERVE   0xffff<br><br>* SHN_UNDEF<br><br>  This value marks an undefined, missing, irrelevant, or otherwise<br>  meaningless section reference. For example, a symbol ``defined''<br>  relative to section number SHN_UNDEF is an undefined symbol.<br><br>NOTE: Although index 0 is reserved as the undefined value, the section<br>header table contains an entry for index 0. That is, if the e_shnum<br>member of the ELF header says a file has 6 entries in the section<br>header table, they have the indexes 0 through 5. The contents of the<br>initial entry are specified later in this section.<br><br>* SHN_LORESERVE<br><br>  This value specifies the lower bound of the range of reserved<br>  indexes.<br><br>* SHN_LOPROC through SHN_HIPROC<br><br>  Values in this inclusive range are reserved for processor-specific<br>  semantics.<br><br>* SHN_ABS<br><br>  This value specifies absolute values for the corresponding<br>  reference. For example, symbols defined relative to section number<br>  SHN_ABS have absolute values and are not affected by relocation.<br><br>* SHN_COMMON<br><br>  Symbols defined relative to this section are common symbols, such as<br>  FORTRAN COMMON or unallocated C external variables.<br><br>* SHN_HIRESERVE<br><br>  This value specifies the upper bound of the range of reserved<br>  indexes. The system reserves indexes between SHN_LORESERVE and<br>  SHN_HIRESERVE, inclusive; the values do not reference the section<br>  header table. That is, the section header table does not contain<br>  entries for the reserved indexes.<br><br>Sections contain all information in an object file, except the ELF<br>header, the program header table, and the section header<br>table. Moreover, object files' sections satisfy several conditions.<br><br>* Every section in an object file has exactly one section header<br>  describing it. Section headers may exist that do not have a section.<br>* Each section occupies one contiguous (possibly empty) sequence of<br>  bytes within a file.<br>* Sections in a file may not overlap. No byte in a file resides in<br>  more than one section.<br>* An object file may have inactive space. The various headers and the<br>  sections might not ``cover'' every byte in an object file. The<br>  contents of the inactive data are unspecified.<br><br>A section header has the following structure.<br><br>+ Figure 1-9: Section Header<br><br>  typedef struct {<!-- --><br>      Elf32_Word	sh_name;<br>      Elf32_Word	sh_type;<br>      Elf32_Word	sh_flags;<br>      Elf32_Addr	sh_addr;<br>      Elf32_Off		sh_offset;<br>      Elf32_Word	sh_size;<br>      Elf32_Word	sh_link;<br>      Elf32_Word	sh_info;<br>      Elf32_Word	sh_addralign;<br>      Elf32_Word	sh_entsize;<br>  } Elf32_Shdr;<br><br>* sh_name<br><br>  This member specifies the name of the section. Its value is an index<br>  into the section header string table section [see ``String Table''<br>  below], giving the location of a null-terminated string.<br><br>* sh_type<br><br>  This member categorizes the section's contents and semantics.<br>  Section types and their descriptions appear below.<br><br>* sh_flags<br><br>  Sections support 1-bit flags that describe miscellaneous attributes.<br>  Flag definitions appear below.<br><br>* sh_addr<br><br>  If the section will appear in the memory image of a process, this<br>  member gives the address at which the section's first byte should<br>  reside. Otherwise, the member contains 0.<br><br>* sh_offset<br><br>  This member's value gives the byte offset from the beginning of the<br>  file to the first byte in the section. One section type, SHT_NOBITS<br>  described below, occupies no space in the file, and its sh_offset<br>  member locates the conceptual placement in the file.<br><br>* sh_size<br>  This member gives the section's size in bytes.  Unless the section<br>  type is SHT_NOBITS, the section occupies sh_size bytes in the file.<br>  A section of type SHT_NOBITS may have a non-zero size, but it<br>  occupies no space in the file.<br><br>* sh_link<br><br>  This member holds a section header table index link, whose<br>  interpretation depends on the section type. A table below describes<br>  the values.<br><br>* sh_info<br><br>  This member holds extra information, whose interpretation depends on<br>  the section type. A table below describes the values.<br><br>* sh_addralign<br><br>  Some sections have address alignment constraints. For example, if a<br>  section holds a doubleword, the system must ensure doubleword<br>  alignment for the entire section. That is, the value of sh_addr must<br>  be congruent to 0, modulo the value of sh_addralign. Currently, only<br>  0 and positive integral powers of two are allowed. Values 0 and 1<br>  mean the section has no alignment constraints.<br><br>* sh_entsize<br><br>  Some sections hold a table of fixed-size entries, such as a symbol<br>  table. For such a section, this member gives the size in bytes of<br>  each entry. The member contains 0 if the section does not hold a<br>  table of fixed-size entries.<br><br>A section header's sh_type member specifies the section's semantics.<br><br>+ Figure 1-10: Section Types, sh_type<br><br>  Name               Value<br>  ====               =====<br>  SHT_NULL               0<br>  SHT_PROGBITS           1<br>  SHT_SYMTAB             2<br>  SHT_STRTAB	         3<br>  SHT_RELA	         4<br>  SHT_HASH	         5<br>  SHT_DYNAMIC            6<br>  SHT_NOTE	         7<br>  SHT_NOBITS	         8<br>  SHT_REL	         9<br>  SHT_SHLIB             10<br>  SHT_DYNSYM            11<br>  SHT_LOPROC    0x70000000<br>  SHT_HIPROC    0x7fffffff<br>  SHT_LOUSER    0x80000000<br>  SHT_HIUSER    0xffffffff<br><br>* SHT_NULL<br><br>  This value marks the section header as inactive; it does not have an<br>  associated section. Other members of the section header have<br>  undefined values.<br><br>* SHT_PROGBITS<br><br>  The section holds information defined by the program, whose format<br>  and meaning are determined solely by the program.<br><br>* SHT_SYMTAB and SHT_DYNSYM<br><br>  These sections hold a symbol table. Currently, an object file may<br>  have only one section of each type, but this restriction may be<br>  relaxed in the future. Typically, SHT_SYMTAB provides symbols for<br>  link editing, though it may also be used for dynamic linking. As a<br>  complete symbol table, it may contain many symbols unnecessary for<br>  dynamic linking. Consequently, an object file may also contain a<br>  SHT_DYNSYM section, which holds a minimal set of dynamic linking<br>  symbols, to save space. See ``Symbol Table'' below for details.<br><br>* SHT_STRTAB<br><br>  The section holds a string table. An object file may have multiple<br>  string table sections. See ``String Table'' below for details.<br><br>* SHT_RELA<br><br>  The section holds relocation entries with explicit addends, such as<br>  type Elf32_Rela for the 32-bit class of object files. An object file<br>  may have multiple relocation sections.  See ``Relocation'' below for<br>  details.<br><br>* SHT_HASH<br><br>  The section holds a symbol hash table. All objects participating in<br>  dynamic linking must contain a symbol hash table. Currently, an<br>  object file may have only one hash table, but this restriction may<br>  be relaxed in the future. See ``Hash Table'' in Part 2 for details.<br><br>* SHT_DYNAMIC<br><br>  The section holds information for dynamic linking. Currently, an<br>  object file may have only one dynamic section, but this restriction<br>  may be relaxed in the future. See ``Dynamic Section'' in Part 2 for<br>  details.<br><br>* SHT_NOTE<br><br>  The section holds information that marks the file in some way. See<br>  ``Note Section'' in Part 2 for details.<br><br>* SHT_NOBITS<br><br>  A section of this type occupies no space in the file but otherwise<br>  resembles SHT_PROGBITS. Although this section contains no bytes, the<br>  sh_offset member contains the conceptual file offset.<br><br>* SHT_REL<br><br>  The section holds relocation entries without explicit addends, such<br>  as type Elf32_Rel for the 32-bit class of object files. An object<br>  file may have multiple relocation sections. See ``Relocation'' below<br>  for details.<br><br>* SHT_SHLIB<br><br>  This section type is reserved but has unspecified<br>  semantics. Programs that contain a section of this type do not<br>  conform to the ABI.<br><br>* SHT_LOPROC through SHT_HIPROC<br><br>  Values in this inclusive range are reserved for processor-specific<br>  semantics.<br><br>* SHT_LOUSER<br><br>  This value specifies the lower bound of the range of indexes<br>  reserved for application programs.<br><br>* SHT_HIUSER<br><br>  This value specifies the upper bound of the range of indexes<br>  reserved for application programs. Section types between SHT_LOUSER<br>  and SHT_HIUSER may be used by the application, without conflicting<br>  with current or future system-defined section types.<br><br>Other section type values are reserved. As mentioned before, the<br>section header for index 0 (SHN_UNDEF) exists, even though the index<br>marks undefined section references. This entry holds the following.<br><br>+ Figure 1-11: Section Header Table Entry: Index 0<br><br>  Name            Value    Note<br>  ====            =====    ====<br>  sh_name           0      No name<br>  sh_type        SHT_NULL  Inactive<br>  sh_flags          0      No flags<br>  sh_addr           0      No address<br>  sh_offset         0      No file offset<br>  sh_size           0      No size<br>  sh_link	SHN_UNDEF  No link information<br>  sh_info	    0      No auxiliary information<br>  sh_addralign	    0      No alignment<br>  sh_entsize        0      No entries<br><br>A section header's sh_flags member holds 1-bit flags that describe the<br>section's attributes. Defined values appear below; other values are<br>reserved.<br><br>+ Figure 1-12: Section Attribute Flags, sh_flags<br><br>  Name                Value<br>  ====                =====<br>  SHF_WRITE             0x1<br>  SHF_ALLOC             0x2<br>  SHF_EXECINSTR         0x4<br>  SHF_MASKPROC   0xf0000000<br><br>If a flag bit is set in sh_flags, the attribute is ``on'' for the<br>section. Otherwise, the attribute is ``off'' or does not apply.<br>Undefined attributes are set to zero.<br><br>* SHF_WRITE<br><br>  The section contains data that should be writable during process<br>  execution.<br><br>* SHF_ALLOC<br><br>  The section occupies memory during process execution. Some control<br>  sections do not reside in the memory image of an object file; this<br>  attribute is off for those sections.<br><br>* SHF_EXECINSTR<br><br>  The section contains executable machine instructions.<br><br>* SHF_MASKPROC<br><br>  All bits included in this mask are reserved for processor-specific<br>  semantics.<br><br>Two members in the section header, sh_link and sh_info, hold special<br>information, depending on section type.<br><br>+ Figure 1-13: sh_link and sh_info Interpretation<br><br>  sh_type      sh_link                        sh_info<br>  =======      =======                        =======<br>  SHT_DYNAMIC  The section header index of    0<br>               the string table used by<br>               entries in the section.<br>  SHT_HASH     The section header index of    0<br>               the symbol table to which the<br>               hash table applies.<br>  SHT_REL,     The section header index of    The section header index of<br>  SHT_RELA     the associated symbol table.   the section to which the<br>                                              relocation applies.<br>  SHT_SYMTAB,  The section header index of    One greater than the symbol<br>  SHT_DYNSYM   the associated string table.   table index of the last local<br>                                              symbol (binding STB_LOCAL).<br>  other        SHN_UNDEF                      0<br><br><br>			   Special Sections<br><br>Various sections hold program and control information. Sections in the<br>list below are used by the system and have the indicated types and<br>attributes.<br><br>+ Figure 1-14: Special Sections<br><br>  Name         Type           Attributes<br>  ====         ====           ==========<br>  .bss         SHT_NOBITS     SHF_ALLOC+SHF_WRITE<br>  .comment     SHT_PROGBITS   none<br>  .data        SHT_PROGBITS   SHF_ALLOC+SHF_WRITE<br>  .data1       SHT_PROGBITS   SHF_ALLOC+SHF_WRITE<br>  .debug       SHT_PROGBITS   none<br>  .dynamic     SHT_DYNAMIC    see below<br>  .dynstr      SHT_STRTAB     SHF_ALLOC<br>  .dynsym      SHT_DYNSYM     SHF_ALLOC<br>  .fini        SHT_PROGBITS   SHF_ALLOC+SHF_EXECINSTR<br>  .got         SHT_PROGBITS   see below<br>  .hash        SHT_HASH       SHF_ALLOC<br>  .init        SHT_PROGBITS   SHF_ALLOC+SHF_EXECINSTR<br>  .interp      SHT_PROGBITS   see below<br>  .line        SHT_PROGBITS   none<br>  .note        SHT_NOTE       none<br>  .plt         SHT_PROGBITS   see below<br>  .rel&lt;name&gt;   SHT_REL        see below<br>  .rela&lt;name&gt;  SHT_RELA       see below<br>  .rodata      SHT_PROGBITS   SHF_ALLOC<br>  .rodata1     SHT_PROGBITS   SHF_ALLOC<br>  .shstrtab    SHT_STRTAB     none<br>  .strtab      SHT_STRTAB     see below<br>  .symtab      SHT_SYMTAB     see below<br>  .text        SHT_PROGBITS   SHF_ALLOC+SHF_EXECINSTR<br><br>* .bss<br><br>  This section holds uninitialized data that contribute to the<br>  program's memory image. By definition, the system initializes the<br>  data with zeros when the program begins to run. The section occupies<br>  no file space, as indicated by the section type, SHT_NOBITS.<br><br>* .comment<br><br>  This section holds version control information.<br><br>* .data and .data1<br><br>  These sections hold initialized data that contribute to the<br>  program's memory image.<br><br>* .debug<br><br>  This section holds information for symbolic debugging. The contents<br>  are unspecified.<br><br>* .dynamic<br><br>  This section holds dynamic linking information. The section's<br>  attributes will include the SHF_ALLOC bit. Whether the SHF_WRITE bit<br>  is set is processor specific. See Part 2 for more information.<br><br>* .dynstr<br><br>  This section holds strings needed for dynamic linking, most commonly<br>  the strings that represent the names associated with symbol table<br>  entries. See Part 2 for more information.<br><br>* .dynsym<br><br>  This section holds the dynamic linking symbol table, as ``Symbol<br>  Table'' describes. See Part 2 for more information.<br><br>* .fini<br><br>  This section holds executable instructions that contribute to the<br>  process termination code. That is, when a program exits normally,<br>  the system arranges to execute the code in this section.<br><br>* .got<br><br>  This section holds the global offset table. See ``Special Sections''<br>  in Part 1 and ``Global Offset Table'' in Part 2 for more<br>  information.<br><br>* .hash<br><br>  This section holds a symbol hash table. See ``Hash Table'' in Part 2<br>  for more information.<br><br>* .init<br><br>  This section holds executable instructions that contribute to the<br>  process initialization code. That is, when a program starts to run,<br>  the system arranges to execute the code in this section before<br>  calling the main program entry point (called main for C programs).<br><br>* .interp<br><br>  This section holds the path name of a program interpreter. If the<br>  file has a loadable segment that includes the section, the section's<br>  attributes will include the SHF_ALLOC bit; otherwise, that bit will<br>  be off. See Part 2 for more information.<br><br>* .line<br><br>  This section holds line number information for symbolic debugging,<br>  which describes the correspondence between the source program and<br>  the machine code. The contents are unspecified.<br><br>* .note<br><br>  This section holds information in the format that ``Note Section''<br>  in Part 2 describes.<br><br>* .plt<br><br>  This section holds the procedure linkage table. See ``Special<br>  Sections'' in Part 1 and ``Procedure Linkage Table'' in Part 2 for<br>  more information.<br><br>* .rel&lt;name&gt; and .rela&lt;name&gt;<br><br>  These sections hold relocation information, as ``Relocation'' below<br>  describes. If the file has a loadable segment that includes<br>  relocation, the sections' attributes will include the SHF_ALLOC bit;<br>  otherwise, that bit will be off. Conventionally, &lt;name&gt; is supplied<br>  by the section to which the relocations apply. Thus a relocation<br>  section for .text normally would have the name .rel.text or<br>  .rela.text.<br><br>* .rodata and .rodata1<br><br>  These sections hold read-only data that typically contribute to a<br>  non-writable segment in the process image. See ``Program Header'' in<br>  Part 2 for more information.<br><br>* .shstrtab<br><br>  This section holds section names.<br><br>* .strtab<br><br>  This section holds strings, most commonly the strings that represent<br>  the names associated with symbol table entries. If the file has a<br>  loadable segment that includes the symbol string table, the<br>  section's attributes will include the SHF_ALLOC bit; otherwise, that<br>  bit will be off.<br><br>* .symtab<br><br>  This section holds a symbol table, as ``Symbol Table'' in this<br>  section describes. If the file has a loadable segment that includes<br>  the symbol table, the section's attributes will include the<br>  SHF_ALLOC bit; otherwise, that bit will be off.<br><br>* .text<br><br>  This section holds the ``text,'' or executable instructions, of a<br>  program.<br><br>Section names with a dot (.) prefix are reserved for the system,<br>although applications may use these sections if their existing<br>meanings are satisfactory. Applications may use names without the<br>prefix to avoid conflicts with system sections. The object file format<br>lets one define sections not in the list above. An object file may<br>have more than one section with the same name.<br><br>Section names reserved for a processor architecture are formed by<br>placing an abbreviation of the architecture name ahead of the section<br>name. The name should be taken from the architecture names used for<br>e_machine. For instance .FOO.psect is the psect section defined by the<br>FOO architecture. Existing extensions are called by their historical<br>names.<br><br>		       Pre-existing Extensions<br>		       =======================<br>			 .sdata     .tdesc<br>			 .sbss      .lit4<br>			 .lit8      .reginfo<br>			 .gptab     .liblist<br>			 .conflict<br><br><br>   ========================= String Table =========================<br><br><br>String table sections hold null-terminated character sequences,<br>commonly called strings. The object file uses these strings to<br>represent symbol and section names. One references a string as an<br>index into the string table section. The first byte, which is index<br>zero, is defined to hold a null character. Likewise, a string table's<br>last byte is defined to hold a null character, ensuring null<br>termination for all strings. A string whose index is zero specifies<br>either no name or a null name, depending on the context. An empty<br>string table section is permitted; its section header's sh_size member<br>would contain zero. Non-zero indexes are invalid for an empty string<br>table.<br><br>A section header's sh_name member holds an index into the section<br>header string table section, as designated by the e_shstrndx member of<br>the ELF header. The following figures show a string table with 25<br>bytes and the strings associated with various indexes.<br><br>       Index   +0   +1   +2   +3   +4   +5   +6   +7   +8   +9<br>       =====   ==   ==   ==   ==   ==   ==   ==   ==   ==   ==<br>          0    /0   n    a    m    e    .    /0   V    a    r     <br>         10    i    a    b    l    e    /0   a    b    l    e<br>         20    /0   /0   x    x    /0<br><br><br>+ Figure 1-15: String Table Indexes<br><br>  Index   String<br>  =====   ======<br>      0   none<br>      1   "name."<br>      7   "Variable"<br>     11   "able"<br>     16   "able"<br>     24   null string<br><br>As the example shows, a string table index may refer to any byte in<br>the section. A string may appear more than once; references to<br>substrings may exist; and a single string may be referenced multiple<br>times. Unreferenced strings also are allowed.<br><br><br>   ========================= Symbol Table =========================<br><br><br>An object file's symbol table holds information needed to locate and<br>relocate a program's symbolic definitions and references. A symbol<br>table index is a subscript into this array. Index 0 both designates<br>the first entry in the table and serves as the undefined symbol<br>index. The contents of the initial entry are specified later in this<br>section.<br><br>                             Name       Value<br>                             ====       =====<br>			     STN_UNDEF      0<br><br>A symbol table entry has the following format.<br><br>+ Figure 1-16: Symbol Table Entry<br><br>  typedef struct {<!-- --><br>      Elf32_Word	st_name;<br>      Elf32_Addr	st_value;<br>      Elf32_Word	st_size;<br>      unsigned char	st_info;<br>      unsigned char	st_other;<br>      Elf32_Half	st_shndx;<br>  } Elf32_Sym;<br><br>* st_name<br><br>  This member holds an index into the object file's symbol string<br>  table, which holds the character representations of the symbol<br>  names. If the value is non-zero, it represents a string table index<br>  that gives the symbol name. Otherwise, the symbol table entry has no<br>  name.<br><br>NOTE: External C symbols have the same names in C and object files'<br>symbol tables.<br><br>* st_value<br><br>  This member gives the value of the associated symbol. Depending on<br>  the context, this may be an absolute value, an address, etc.;<br>  details appear below.<br><br>* st_size<br><br>  Many symbols have associated sizes. For example, a data object's<br>  size is the number of bytes contained in the object. This member<br>  holds 0 if the symbol has no size or an unknown size.<br><br>* st_info<br><br>  This member specifies the symbol's type and binding attributes.  A<br>  list of the values and meanings appears below. The following code<br>  shows how to manipulate the values.<br><br>    #define ELF32_ST_BIND(i)	((i)&gt;&gt;4)<br>    #define ELF32_ST_TYPE(i)	((i)&amp;0xf)<br>    #define ELF32_ST_INFO(b, t)	(((b)&lt;&lt;4)+((t)&amp;0xf))<br><br>* st_other<br><br>  This member currently holds 0 and has no defined meaning.<br><br>* st_shndx<br><br>  Every symbol table entry is ``defined'' in relation to some section;<br>  this member holds the relevant section header table index. As Figure<br>  1-8 {*} and the related text describe, some section indexes indicate<br>  special meanings.<br><br>A symbol's binding determines the linkage visibility and behavior.<br><br>+ Figure 1-17: Symbol Binding, ELF32_ST_BIND<br><br>  Name        Value<br>  ====        =====<br>  STB_LOCAL       0<br>  STB_GLOBAL      1<br>  STB_WEAK        2<br>  STB_LOPROC     13<br>  STB_HIPROC     15<br><br>* STB_LOCAL<br><br>  Local symbols are not visible outside the object file containing<br>  their definition. Local symbols of the same name may exist in<br>  multiple files without interfering with each other.<br><br>* STB_GLOBAL<br><br>  Global symbols are visible to all object files being combined. One<br>  file's definition of a global symbol will satisfy another file's<br>  undefined reference to the same global symbol.<br><br>* STB_WEAK<br><br>  Weak symbols resemble global symbols, but their definitions have<br>  lower precedence.<br><br>* STB_LOPROC through STB_HIPROC<br><br>  Values in this inclusive range are reserved for processor-specific<br>  semantics.<br><br>Global and weak symbols differ in two major ways.<br><br>* When the link editor combines several relocatable object files, it<br>  does not allow multiple definitions of STB_GLOBAL symbols with the<br>  same name. On the other hand, if a defined global symbol exists, the<br>  appearance of a weak symbol with the same name will not cause an<br>  error. The link editor honors the global definition and ignores the<br>  weak ones. Similarly, if a common symbol exists (i.e., a symbol<br>  whose st_shndx field holds SHN_COMMON), the appearance of a weak<br>  symbol with the same name will not cause an error. The link editor<br>  honors the common definition and ignores the weak ones.<br><br>* When the link editor searches archive libraries, it extracts archive<br>  members that contain definitions of undefined global symbols. The<br>  member's definition may be either a global or a weak symbol. The<br>  link editor does not extract archive members to resolve undefined<br>  weak symbols. Unresolved weak symbols have a zero value.<br><br>In each symbol table, all symbols with STB_LOCAL binding precede the<br>weak and global symbols. As ``Sections'' above describes, a symbol<br>table section's sh_info section header member holds the symbol table<br>index for the first non-local symbol.<br><br>A symbol's type provides a general classification for the associated<br>entity.<br><br>+ Figure 1-18: Symbol Types, ELF32_ST_TYPE<br><br>  Name         Value<br>  ====         =====<br>  STT_NOTYPE       0<br>  STT_OBJECT       1<br>  STT_FUNC         2<br>  STT_SECTION      3<br>  STT_FILE         4<br>  STT_LOPROC      13<br>  STT_HIPROC      15<br><br>* STT_NOTYPE<br><br>  The symbol's type is not specified.<br><br>* STT_OBJECT<br><br>  The symbol is associated with a data object, such as a variable, an<br>  array, etc.<br><br>* STT_FUNC<br><br>  The symbol is associated with a function or other executable code.<br><br>* STT_SECTION<br><br>  The symbol is associated with a section. Symbol table entries of<br>  this type exist primarily for relocation and normally have STB_LOCAL<br>  binding.<br><br>* STT_FILE<br><br>  Conventionally, the symbol's name gives the name of the source file<br>  associated with the object file. A file symbol has STB_LOCAL<br>  binding, its section index is SHN_ABS, and it precedes the other<br>  STB_LOCAL symbols for the file, if it is present.<br><br>* STT_LOPROC through STT_HIPROC<br><br>  Values in this inclusive range are reserved for processor-specific<br>  semantics.<br><br>Function symbols (those with type STT_FUNC) in shared object files<br>have special significance. When another object file references a<br>function from a shared object, the link editor automatically creates a<br>procedure linkage table entry for the referenced symbol. Shared object<br>symbols with types other than STT_FUNC will not be referenced<br>automatically through the procedure linkage table.<br><br>If a symbol's value refers to a specific location within a section,<br>its section index member, st_shndx, holds an index into the section<br>header table. As the section moves during relocation, the symbol's<br>value changes as well, and references to the symbol continue to<br>``point'' to the same location in the program. Some special section<br>index values give other semantics.<br><br>* SHN_ABS<br><br>  The symbol has an absolute value that will not change because of<br>  relocation.<br><br>* SHN_COMMON<br><br>  The symbol labels a common block that has not yet been allocated.<br>  The symbol's value gives alignment constraints, similar to a<br>  section's sh_addralign member. That is, the link editor will<br>  allocate the storage for the symbol at an address that is a multiple<br>  of st_value. The symbol's size tells how many bytes are required.<br><br>* SHN_UNDEF<br><br>  This section table index means the symbol is undefined. When the<br>  link editor combines this object file with another that defines the<br>  indicated symbol, this file's references to the symbol will be<br>  linked to the actual definition.<br><br>As mentioned above, the symbol table entry for index 0 (STN_UNDEF) is<br>reserved; it holds the following.<br><br>+ Figure 1-19: Symbol Table Entry: Index 0<br><br>  Name        Value    Note<br>  ====        =====    ====<br>  st_name       0      No name<br>  st_value      0      Zero value<br>  st_size       0      No size<br>  st_info       0      No type, local binding<br>  st_other      0<br>  st_shndx  SHN_UNDEF  No section<br><br><br>			    Symbol Values<br><br>Symbol table entries for different object file types have slightly<br>different interpretations for the st_value member.<br><br>* In relocatable files, st_value holds alignment constraints for a<br>  symbol whose section index is SHN_COMMON.<br>* In relocatable files, st_value holds a section offset for a defined<br>  symbol. That is, st_value is an offset from the beginning of the<br>  section that st_shndx identifies.<br>* In executable and shared object files, st_value holds a virtual<br>  address. To make these files' symbols more useful for the dynamic<br>  linker, the section offset (file interpretation) gives way to a<br>  virtual address (memory interpretation) for which the section number<br>  is irrelevant.<br><br>Although the symbol table values have similar meanings for different<br>object files, the data allow efficient access by the appropriate<br>programs.<br><br><br>   ========================== Relocation ==========================<br><br><br>Relocation is the process of connecting symbolic references with<br>symbolic definitions. For example, when a program calls a function,<br>the associated call instruction must transfer control to the proper<br>destination address at execution. In other words, relocatable files<br>must have information that describes how to modify their section<br>contents, thus allowing executable and shared object files to hold the<br>right information for a process's program image. Relocation entries<br>are these data.<br><br>+ Figure 1-20: Relocation Entries<br><br>  typedef struct {<!-- --><br>      Elf32_Addr	r_offset;<br>      Elf32_Word	r_info;<br>  } Elf32_Rel;<br><br>  typedef struct {<!-- --><br>      Elf32_Addr	r_offset;<br>      Elf32_Word	r_info;<br>      Elf32_Sword	r_addend;<br>  } Elf32_Rela;<br><br>* r_offset<br><br>  This member gives the location at which to apply the relocation<br>  action. For a relocatable file, the value is the byte offset from<br>  the beginning of the section to the storage unit affected by the<br>  relocation. For an executable file or a shared object, the value is<br>  the virtual address of the storage unit affected by the relocation.<br><br>* r_info<br><br>  This member gives both the symbol table index with respect to which<br>  the relocation must be made, and the type of relocation to apply.<br>  For example, a call instruction's relocation entry would hold the<br>  symbol table index of the function being called. If the index is<br>  STN_UNDEF, the undefined symbol index, the relocation uses 0 as the<br>  ``symbol value.'' Relocation types are processor-specific. When the<br>  text refers to a relocation entry's relocation type or symbol table<br>  index, it means the result of applying ELF32_R_TYPE or ELF32_R_SYM,<br>  respectively, to the entry's r_info member.<br><br>    #define ELF32_R_SYM(i)	((i)&gt;&gt;8)<br>    #define ELF32_R_TYPE(i)	((unsigned char)(i))<br>    #define ELF32_R_INFO(s, t)	((s)&lt;&lt;8+(unsigned char)(t))<br><br>* r_addend<br><br>  This member specifies a constant addend used to compute the value to<br>  be stored into the relocatable field.<br><br>As shown above, only Elf32_Rela entries contain an explicit<br>addend. Entries of type Elf32_Rel store an implicit addend in the<br>location to be modified. Depending on the processor architecture, one<br>form or the other might be necessary or more convenient. Consequently,<br>an implementation for a particular machine may use one form<br>exclusively or either form depending on context.<br><br>A relocation section references two other sections: a symbol table and<br>a section to modify. The section header's sh_info and sh_link members,<br>described in ``Sections'' above, specify these relationships.<br>Relocation entries for different object files have slightly different<br>interpretations for the r_offset member.<br><br>* In relocatable files, r_offset holds a section offset. That is, the<br>  relocation section itself describes how to modify another section in<br>  the file; relocation offsets designate a storage unit within the<br>  second section.<br>* In executable and shared object files, r_offset holds a virtual<br>  address. To make these files' relocation entries more useful for the<br>  dynamic linker, the section offset (file interpretation) gives way<br>  to a virtual address (memory interpretation).<br><br>Although the interpretation of r_offset changes for different object<br>files to allow efficient access by the relevant programs, the<br>relocation types' meanings stay the same.<br><br><br>			   Relocation Types<br><br>Relocation entries describe how to alter the following instruction and<br>data fields (bit numbers appear inthe lower box corners).<br><br>+ Figure 1-21: Relocatable Fields <br><br>    +---------------------------+<br>    |          word32           |<br>   31---------------------------0<br><br><br>* word32<br><br>  This specifies a 32-bit field occupying 4 bytes with arbitrary byte<br>  alignment. These values use the same byte order as other word values<br>  in the 32-bit Intel Architecture.<br><br>                           3------2------1------0------+<br>	     0x01020304    |  01  |  02  |  03  |  04  |<br>                          31------+------+------+------0<br><br>Calculations below assume the actions are transforming a relocatable<br>file into either an executable or a shared object file. Conceptually,<br>the link editor merges one or more relocatable files to form the<br>output. It first decides how to combine and locate the input files,<br>then updates the symbol values, and finally performs the relocation.<br>Relocations applied to executable or shared object files are similar<br>and accomplish the same result. Descriptions below use the following<br>notation.<br><br>* A<br><br>  This means the addend used to compute the value of the relocatable<br>  field.<br><br>* B<br><br>  This means the base address at which a shared object has been loaded<br>  into memory during execution. Generally, a shared object file is<br>  built with a 0 base virtual address, but the execution address will<br>  be different.<br><br>* G<br><br>  This means the offset into the global offset table at which the<br>  address of the relocation entry's symbol will reside during<br>  execution. See ``Global Offset Table'' in Part 2 for more<br>  information.<br><br>* GOT<br><br>  This means the address of the global offset table. See ``Global<br>  Offset Table'' in Part 2 for more information.<br><br>* L<br><br>  This means the place (section offset or address) of the procedure<br>  linkage table entry for a symbol. A procedure linkage table entry<br>  redirects a function call to the proper destination. The link editor<br>  builds the initial procedure linkage table, and the dynamic linker<br>  modifies the entries during execution. See ``Procedure Linkage<br>  Table'' in Part 2 for more information.<br><br>* P<br><br>  This means the place (section offset or address) of the storage unit<br>  being relocated (computed using r_offset).<br><br>* S<br><br>  This means the value of the symbol whose index resides in the<br>  relocation entry.<br><br>A relocation entry's r_offset value designates the offset or virtual<br>address of the first byte of the affected storage unit. The relocation<br>type specifies which bits to change and how to calculate their<br>values. The SYSTEM V architecture uses only Elf32_Rel relocation<br>entries, the field to be relocated holds the addend. In all cases, the<br>addend and the computed result use the same byte order.<br><br>+ Figure 1-22: Relocation Types<br><br>  Name            Value  Field   Calculation<br>  ====            =====  =====   ===========<br>  R_386_NONE        0    none    none<br>  R_386_32	    1    word32  S + A<br>  R_386_PC32	    2    word32  S + A - P<br>  R_386_GOT32	    3    word32  G + A - P<br>  R_386_PLT32	    4    word32  L + A - P<br>  R_386_COPY	    5    none    none<br>  R_386_GLOB_DAT    6    word32  S<br>  R_386_JMP_SLOT    7    word32  S<br>  R_386_RELATIVE    8    word32  B + A<br>  R_386_GOTOFF	    9    word32  S + A - GOT<br>  R_386_GOTPC	   10    word32  GOT + A - P<br><br>Some relocation types have semantics beyond simple calculation.<br><br>* R_386_GOT32<br><br>  This relocation type computes the distance from the base of the<br>  global offset table to the symbol's global offset table entry. It<br>  additionally instructs the link editor to build a global offset<br>  table.<br><br>* R_386_PLT32<br><br>  This relocation type computes the address of the symbol's procedure<br>  linkage table entry and additionally instructs the link editor to<br>  build a procedure linkage table.<br><br>* R_386_COPY<br><br>  The link editor creates this relocation type for dynamic linking.<br>  Its offset member refers to a location in a writable segment. The<br>  symbol table index specifies a symbol that should exist both in the<br>  current object file and in a shared object. During execution, the<br>  dynamic linker copies data associated with shared object's symbol to<br>  the location specified by the offset.<br><br>* R_386_GLOB_DAT<br><br>  This relocation type is used to set a global offset table entry to<br>  the address of the specified symbol. The special relocation type<br>  allows one to determine the correspondence between symbols and<br>  global offset table entries.<br><br>* R_386_JMP_SLOT {*}<br><br>  The link editor creates this relocation type for dynamic linking.<br>  Its offset member gives the location of a procedure linkage table<br>  entry. The dynamic linker modifies the procedure linkage table entry<br>  to transfer control to the designated symbol's address [see<br>  ``Procedure Linkage Table'' in Part 2].<br><br>* R_386_RELATIVE<br><br>  The link editor creates this relocation type for dynamic linking.<br>  Its offset member gives a location within a shared object that<br>  contains a value representing a relative address. The dynamic linker<br>  computes the corresponding virtual address by adding the virtual<br>  address at which the shared object was loaded to the relative<br>  address. Relocation entries for this type must specify 0 for the<br>  symbol table index.<br><br>* R_386_GOTOFF<br><br>  This relocation type computes the difference between a symbol's<br>  value and the address of the global offset table. It additionally<br>  instructs the link editor to build the global offset table.<br><br><br>* R_386_GOTPC<br><br>  This relocation type resembles R_386_PC32, except it uses the<br>  address of the global offset table in its calculation. The symbol<br>  referenced in this relocation normally is _GLOBAL_OFFSET_TABLE_,<br>  which additionally instructs the link editor to build the global<br>  offset table.<br><br>   ________________________________________________________________<br><br><br>		2. PROGRAM LOADING AND DYNAMIC LINKING<br><br>   ________________________________________________________________<br><br><br>   ========================= Introduction =========================<br><br><br>Part 2 describes the object file information and system actions that<br>create running programs. Some information here applies to all systems;<br>other information is processor-specific.<br><br>Executable and shared object files statically represent programs. To<br>execute such programs, the system uses the files to create dynamic<br>program representations, or process images. A process image has<br>segments that hold its text, data, stack, and so on. The major<br>sections in this part discuss the following.<br><br>* Program header. This section complements Part 1, describing object<br>  file structures that relate directly to program execution. The<br>  primary data structure, a program header table, locates segment<br>  images within the file and contains other information necessary to<br>  create the memory image for the program.<br>* Program loading. Given an object file, the system must load it into<br>  memory for the program to run.<br>* Dynamic linking. After the system loads the program, it must<br>  complete the process image by resolving symbolic references among<br>  the object files that compose the process.<br><br>NOTE: There are naming conventions for ELF constants that have<br>specified processor ranges. Names such as DT_, PT_, for<br>processor-specific extensions, incorporate the name of the processor:<br>DT_M32_SPECIAL, for example. Pre-existing processor extensions not<br>using this convention will be supported.<br><br>		       Pre-existing Extensions<br>		       =======================<br>			      DT_JMP_REL<br><br><br>   ======================== Program Header ========================<br><br><br>An executable or shared object file's program header table is an array<br>of structures, each describing a segment or other information the<br>system needs to prepare the program for execution. An object file<br>segment contains one or more sections, as ``Segment Contents''<br>describes below. Program headers are meaningful only for executable<br>and shared object files. A file specifies its own program header size<br>with the ELF header's e_phentsize and e_phnum members [see ``ELF<br>Header'' in Part 1].<br><br>+ Figure 2-1: Program Header<br><br>  typedef struct {<!-- --><br>      Elf32_Word	p_type;<br>      Elf32_Off		p_offset;<br>      Elf32_Addr	p_vaddr;<br>      Elf32_Addr	p_paddr;<br>      Elf32_Word	p_filesz;<br>      Elf32_Word	p_memsz;<br>      Elf32_Word	p_flags;<br>      Elf32_Word	p_align;<br>  } Elf32_Phdr;<br><br>* p_type<br><br>  This member tells what kind of segment this array element describes<br>  or how to interpret the array element's information. Type values and<br>  their meanings appear below.<br><br>* p_offset<br><br>  This member gives the offset from the beginning of the file at which<br>  the first byte of the segment resides.<br><br>* p_vaddr<br><br>  This member gives the virtual address at which the first byte of the<br>  segment resides in memory.<br><br>* p_paddr<br><br>  On systems for which physical addressing is relevant, this member is<br>  reserved for the segment's physical address. Because System V<br>  ignores physical addressing for application programs, this member<br>  has unspecified contents for executable files and shared objects.<br><br>* p_filesz<br><br>  This member gives the number of bytes in the file image of the<br>  segment; it may be zero.<br><br>* p_memsz<br><br>  This member gives the number of bytes in the memory image of the<br>  segment; it may be zero.<br><br>* p_flags<br><br>  This member gives flags relevant to the segment. Defined flag values<br>  appear below.<br><br>* p_align<br><br>  As ``Program Loading'' later in this part describes, loadable<br>  process segments must have congruent values for p_vaddr and<br>  p_offset, modulo the page size. This member gives the value to which<br>  the segments are aligned in memory and in the file. Values 0 and 1<br>  mean no alignment is required. Otherwise, p_align should be a<br>  positive, integral power of 2, and p_vaddr should equal p_offset,<br>  modulo p_align.<br><br>Some entries describe process segments; others give supplementary<br>information and do not contribute to the process image.  Defined<br>entries may appear in any order, except as explicitly noted<br>below. Segment type values follow; other values are reserved for<br>future use.<br><br>+ Figure 2-2: Segment Types, p_type<br><br>  Name             Value<br>  ====             =====<br>  PT_NULL              0<br>  PT_LOAD              1<br>  PT_DYNAMIC           2<br>  PT_INTERP            3<br>  PT_NOTE              4<br>  PT_SHLIB             5<br>  PT_PHDR              6<br>  PT_LOPROC   0x70000000<br>  PT_HIPROC   0x7fffffff<br><br>* PT_NULL<br><br>  The array element is unused; other members' values are undefined.<br>  This type lets the program header table have ignored entries.<br><br>* PT_LOAD<br><br>  The array element specifies a loadable segment, described by<br>  p_filesz and p_memsz. The bytes from the file are mapped to the<br>  beginning of the memory segment. If the segment's memory size<br>  (p_memsz) is larger than the file size (p_filesz), the ``extra''<br>  bytes are defined to hold the value 0 and to follow the segment's<br>  initialized area. The file size may not be larger than the memory<br>  size. Loadable segment entries in the program header table appear in<br>  ascending order, sorted on the p_vaddr member.<br><br>* PT_DYNAMIC<br><br>  The array element specifies dynamic linking information. See<br>  ``Dynamic Section'' below for more information.<br><br>* PT_INTERP<br><br>  The array element specifies the location and size of a<br>  null-terminated path name to invoke as an interpreter. This segment<br>  type is meaningful only for executable files (though it may occur<br>  for shared objects); it may not occur more than once in a file. If<br>  it is present, it must precede any loadable segment entry. See<br>  ``Program Interpreter'' below for further information.<br><br>* PT_NOTE<br><br>  The array element specifies the location and size of auxiliary<br>  information. See ``Note Section'' below for details.<br><br>* PT_SHLIB<br><br>  This segment type is reserved but has unspecified semantics.<br>  Programs that contain an array element of this type do not conform<br>  to the ABI.<br><br>* PT_PHDR<br><br>  The array element, if present, specifies the location and size of<br>  the program header table itself, both in the file and in the memory<br>  image of the program. This segment type may not occur more than once<br>  in a file. Moreover, it may occur only if the program header table<br>  is part of the memory image of the program. If it is present, it<br>  must precede any loadable segment entry. See ``Program Interpreter''<br>  below for further information.<br><br>* PT_LOPROC through PT_HIPROC<br><br>  Values in this inclusive range are reserved for processor-specific<br>  semantics.<br><br>NOTE: Unless specifically required elsewhere, all program header<br>segment types are optional. That is, a file's program header table may<br>contain only those elements relevant to its contents.<br><br><br>			     Base Address<br><br>Executable and shared object files have a base address, which is the<br>lowest virtual address associated with the memory image of the<br>program's object file. One use of the base address is to relocate the<br>memory image of the program during dynamic linking.<br><br>An executable or shared object file's base address is calculated<br>during execution from three values: the memory load address, the<br>maximum page size, and the lowest virtual address of a program's<br>loadable segment. As ``Program Loading'' in this chapter describes,<br>the virtual addresses in the program headers might not represent the<br>actual virtual addresses of the program's memory image. To compute the<br>base address, one determines the memory address associated with the<br>lowest p_vaddr value for a PT_LOAD segment. One then obtains the base<br>address by truncating the memory address to the nearest multiple of<br>the maximum page size. Depending on the kind of file being loaded into<br>memory, the memory address might or might not match the p_vaddr<br>values.<br><br>As ``Sections'' in Part 1 describes, the .bss section has the type<br>SHT_NOBITS. Although it occupies no space in the file, it contributes<br>to the segment's memory image. Normally, these uninitialized data<br>reside at the end of the segment, thereby making p_memsz larger than<br>p_filesz in the associated program header element.<br><br><br>			     Note Section<br><br>Sometimes a vendor or system builder needs to mark an object file with<br>special information that other programs will check for conformance,<br>compatibility, etc. Sections of type SHT_NOTE and program header<br>elements of type PT_NOTE can be used for this purpose. The note<br>information in sections and program header elements holds any number<br>of entries, each of which is an array of 4-byte words in the format of<br>the target processor. Labels appear below to help explain note<br>information organization, but they are not part of the specification.<br><br>+ Figure 2-3: Note Information<br><br>  namesz<br>  descsz<br>  type<br>  name ...<br>  desc ...<br><br>* namesz and name<br><br>  The first namesz bytes in name contain a null-terminated character<br>  representation of the entry's owner or originator. There is no<br>  formal mechanism for avoiding name conflicts. By convention, vendors<br>  use their own name, such as ``XYZ Computer Company,'' as the<br>  identifier. If no name is present, namesz contains 0. Padding is<br>  present, if necessary, to ensure 4-byte alignment for the<br>  descriptor. Such padding is not included in namesz.<br><br>* descsz and desc<br><br>  The first descsz bytes in desc hold the note descriptor. The ABI<br>  places no constraints on a descriptor's contents. If no descriptor<br>  is present, descsz contains 0. Padding is present, if necessary, to<br>  ensure 4-byte alignment for the next note entry. Such padding is not<br>  included in descsz.<br><br>* type<br><br>  This word gives the interpretation of the descriptor. Each<br>  originator controls its own types; multiple interpretations of a<br>  single type value may exist. Thus, a program must recognize both the<br>  name and the type to ``understand'' a descriptor. Types currently<br>  must be non-negative. The ABI does not define what descriptors mean.<br><br>To illustrate, the following note segment holds two entries.<br><br>+ Figure 2-4: Example Note Segment<br><br>           +0   +1   +2   +3<br>          -------------------<br>  namesz           7<br>  descsz           0           No descriptor<br>    type           1<br>    name   X    Y    Z    spc <br>           C    o    /0   pad<br>  namesz           7<br>  descsz           8<br>    type           3<br>    name   X    Y    Z    spc<br>           C    o    /0   pad<br>    desc         word0<br>                 word1<br><br>NOTE: The system reserves note information with no name (namesz==0)<br>and with a zero-length name (name[0]=='/0') but currently defines no<br>types. All other names must have at least one non-null character.<br><br>NOTE: Note information is optional. The presence of note information<br>does not affect a program's ABI conformance, provided the information<br>does not affect the program's execution behavior. Otherwise, the<br>program does not conform to the ABI and has undefined behavior.<br><br><br>   ======================= Program Loading ========================<br><br><br>As the system creates or augments a process image, it logically copies<br>a file's segment to a virtual memory segment. When--and if--the system<br>physically reads the file depends on the program's execution behavior,<br>system load, etc. A process does not require a physical page unless it<br>references the logical page during execution, and processes commonly<br>leave many pages unreferenced. Therefore delaying physical reads<br>frequently obviates them, improving system performance. To obtain this<br>efficiency in practice, executable and shared object files must have<br>segment images whose file offsets and virtual addresses are congruent,<br>modulo the page size.<br><br>Virtual addresses and file offsets for the SYSTEM V architecture<br>segments are congruent modulo 4 KB (0x1000) or larger powers of 2.<br>Because 4 KB is the maximum page size, the files will be suitable for<br>paging regardless of physical page size.<br><br>+ Figure 2-5: Executable File<br><br>           File Offset   File                  Virtual Address<br>           ===========   ====                  ===============<br>                     0   ELF header<br>  Program header table<br>                         Other information<br>                 0x100   Text segment          0x8048100<br>                         ...<br>                         0x2be00 bytes         0x8073eff<br>               0x2bf00   Data segment          0x8074f00<br>                         ...<br>                         0x4e00 bytes          0x8079cff<br>               0x30d00   Other information<br>                         ...<br><br>+ Figure 2-6: Program Header Segments<br><br>  Member    Text	 Data<br>  ======    ====         ====<br>  p_type    PT_LOAD      PT_LOAD<br>  p_offset  0x100	 0x2bf00<br>  p_vaddr   0x8048100	 0x8074f00<br>  p_paddr   unspecified	 unspecified<br>  p_filesz  0x2be00	 0x4e00<br>  p_memsz   0x2be00	 0x5e24<br>  p_flags   PF_R+PF_X    PF_R+PF_W+PF_X<br>  p_align   0x1000	 0x1000<br><br>Although the example's file offsets and virtual addresses are<br>congruent modulo 4 KB for both text and data, up to four file pages<br>hold impure text or data (depending on page size and file system block<br>size).<br><br>* The first text page contains the ELF header, the program header<br>  table, and other information.<br>* The last text page holds a copy of the beginning of data.<br>* The first data page has a copy of the end of text.<br>* The last data page may contain file information not relevant to the<br>  running process.<br><br>Logically, the system enforces the memory permissions as if each<br>segment were complete and separate; segments' addresses are adjusted<br>to ensure each logical page in the address space has a single set of<br>permissions. In the example above, the region of the file holding the<br>end of text and the beginning of data will be mapped twice: at one<br>virtual address for text and at a different virtual address for data.<br><br>The end of the data segment requires special handling for<br>uninitialized data, which the system defines to begin with zero<br>values. Thus if a file's last data page includes information not in<br>the logical memory page, the extraneous data must be set to zero, not<br>the unknown contents of the executable file. ``Impurities'' in the<br>other three pages are not logically part of the process image; whether<br>the system expunges them is unspecified. The memory image for this<br>program follows, assuming 4 KB (0x1000) pages.<br><br>+ Figure 2-7: Process Image Segments<br><br>  Virtual Address  Contents            Segment<br>  ===============  ========            =======<br>        0x8048000  Header padding      Text<br>                   0x100 bytes<br>        0x8048100  Text segment<br>                   ...<br>                   0x2be00 bytes<br>        0x8073f00  Data padding<br>                   0x100 bytes<br>        0x8074000  Text padding        Data<br>                   0xf00 bytes<br>        0x8074f00  Data segment<br>                   ...<br>                   0x4e00 bytes<br>        0x8079d00  Uninitialized data<br>                   0x1024 zero bytes<br>        0x807ad24  Page padding<br>                   0x2dc zero bytes<br><br>One aspect of segment loading differs between executable files and<br>shared objects. Executable file segments typically contain absolute<br>code. To let the process execute correctly, the segments must reside<br>at the virtual addresses used to build the executable file. Thus the<br>system uses the p_vaddr values unchanged as virtual addresses.<br><br>On the other hand, shared object segments typically contain<br>position-independent code. This lets a segment's virtual address<br>change from one process to another, without invalidating execution<br>behavior. Though the system chooses virtual addresses for individual<br>processes, it maintains the segments' relative positions. Because<br>position-independent code uses relative addressing between segments,<br>the difference between virtual addresses in memory must match the<br>difference between virtual addresses in the file. The following table<br>shows possible shared object virtual address assignments for several<br>processes, illustrating constant relative positioning. The table also<br>illustrates the base address computations.<br><br>+ Figure 2-8: Example Shared Object Segment Addresses<br><br>  Sourc             Text        Data  Base Address<br>  =====             ====        ====  ============<br>  File             0x200     0x2a400           0x0<br>  Process 1   0x80000200  0x8002a400    0x80000000<br>  Process 2   0x80081200  0x800ab400    0x80081000<br>  Process 3   0x900c0200  0x900ea400    0x900c0000<br>  Process 4   0x900c6200  0x900f0400    0x900c6000<br><br><br>   ======================= Dynamic Linking ========================<br><br><br>			 Program Interpreter<br><br>An executable file may have one PT_INTERP program header element.<br>During exec(BA_OS), the system retrieves a path name from the<br>PT_INTERP segment and creates the initial process image from the<br>interpreter file's segments. That is, instead of using the original<br>executable file's segment images, the system composes a memory image<br>for the interpreter. It then is the interpreter's responsibility to<br>receive control from the system and provide an environment for the<br>application program.<br><br>The interpreter receives control in one of two ways. First, it may<br>receive a file descriptor to read the executable file, positioned at<br>the beginning. It can use this file descriptor to read and/or map the<br>executable file's segments into memory. Second, depending on the<br>executable file format, the system may load the executable file into<br>memory instead of giving the interpreter an open file descriptor. With<br>the possible exception of the file descriptor, the interpreter's<br>initial process state matches what the executable file would have<br>received. The interpreter itself may not require a second interpreter.<br>An interpreter may be either a shared object or an executable file.<br><br>* A shared object (the normal case) is loaded as position-independent,<br>  with addresses that may vary from one process to another; the system<br>  creates its segments in the dynamic segment area used by mmap(KE_OS)<br>  and related services. Consequently, a shared object interpreter<br>  typically will not conflict with the original executable file's<br>  original segment addresses.<br><br>* An executable file is loaded at fixed addresses; the system creates<br>  its segments using the virtual addresses from the program header<br>  table. Consequently, an executable file interpreter's virtual<br>  addresses may collide with the first executable file; the<br>  interpreter is responsible for resolving conflicts.<br><br><br>			    Dynamic Linker<br><br>When building an executable file that uses dynamic linking, the link<br>editor adds a program header element of type PT_INTERP to an<br>executable file, telling the system to invoke the dynamic linker as<br>the program interpreter.<br><br>NOTE: The locations of the system provided dynamic linkers are<br>processor-specific.<br><br>Exec(BA_OS) and the dynamic linker cooperate to create the process<br>image for the program, which entails the following actions:<br><br>* Adding the executable file's memory segments to the process image;<br>* Adding shared object memory segments to the process image;<br>* Performing relocations for the executable file and its shared<br>  objects;<br>* Closing the file descriptor that was used to read the executable<br>  file, if one was given to the dynamic linker;<br>* Transferring control to the program, making it look as if the<br>  program had received control directly from exec(BA_OS).<br><br>The link editor also constructs various data that assist the dynamic<br>linker for executable and shared object files. As shown above in<br>``Program Header,'' these data reside in loadable segments, making<br>them available during execution. (Once again, recall the exact segment<br>contents are processor-specific. See the processor supplement for<br>complete information.)<br><br>* A .dynamic section with type SHT_DYNAMIC holds various data. The<br>  structure residing at the beginning of the section holds the<br>  addresses of other dynamic linking information.<br><br>* The .hash section with type SHT_HASH holds a symbol hash table.<br><br>* The .got and .plt sections with type SHT_PROGBITS hold two separate<br>  tables: the global offset table and the procedure linkage table.<br>  Sections below explain how the dynamic linker uses and changes the<br>  tables to create memory images for object files.<br><br>Because every ABI-conforming program imports the basic system services<br>from a shared object library, the dynamic linker participates in every<br>ABI-conforming program execution.<br><br>As ``Program Loading'' explains in the processor supplement, shared<br>objects may occupy virtual memory addresses that are different from<br>the addresses recorded in the file's program header table. The dynamic<br>linker relocates the memory image, updating absolute addresses before<br>the application gains control. Although the absolute address values<br>would be correct if the library were loaded at the addresses specified<br>in the program header table, this normally is not the case.<br><br>If the process environment [see exec(BA_OS)] contains a variable named<br>LD_BIND_NOW with a non-null value, the dynamic linker processes all<br>relocation before transferring control to the program. For example,<br>all the following environment entries would specify this behavior.<br><br>* LD_BIND_NOW=1<br>* LD_BIND_NOW=on<br>* LD_BIND_NOW=off<br><br>Otherwise, LD_BIND_NOW either does not occur in the environment or has<br>a null value. The dynamic linker is permitted to evaluate procedure<br>linkage table entries lazily, thus avoiding symbol resolution and<br>relocation overhead for functions that are not called. See ``Procedure<br>Linkage Table'' in this part for more information.<br><br><br>			   Dynamic Section<br><br>If an object file participates in dynamic linking, its program header<br>table will have an element of type PT_DYNAMIC. This ``segment''<br>contains the .dynamic section. A special symbol, _DYNAMIC, labels the<br>section, which contains an array of the following structures.<br><br>+ Figure 2-9: Dynamic Structure<br><br>  typedef struct {<!-- --><br>      Elf32_Sword d_tag;<br>      union {<!-- --><br>          Elf32_Sword	d_val;<br>          Elf32_Addr	d_ptr;<br>      } d_un;<br>  } Elf32_Dyn;<br><br>  extern Elf32_Dyn _DYNAMIC[];<br><br>For each object with this type, d_tag controls the interpretation of<br>d_un.<br><br>* d_val<br><br>  These Elf32_Word objects represent integer values with various<br>  interpretations.<br><br>* d_ptr<br><br>  These Elf32_Addr objects represent program virtual addresses. As<br>  mentioned previously, a file's virtual addresses might not match the<br>  memory virtual addresses during execution. When interpreting<br>  addresses contained in the dynamic structure, the dynamic linker<br>  computes actual addresses, based on the original file value and the<br>  memory base address. For consistency, files do not contain<br>  relocation entries to ``correct'' addresses in the dynamic<br>  structure.<br><br>The following table summarizes the tag requirements for executable and<br>shared object files. If a tag is marked ``mandatory,'' then the<br>dynamic linking array for an ABI-conforming file must have an entry of<br>that type. Likewise, ``optional'' means an entry for the tag may<br>appear but is not required.<br><br>+ Figure 2-10: Dynamic Array Tags, d_tag<br><br>  Name               Value  d_un         Executable   Shared Object<br>  ====               =====  ====         ==========   =============<br>  DT_NULL                0  ignored	 mandatory    mandatory<br>  DT_NEEDED		 1  d_val	 optional     optional<br>  DT_PLTRELSZ		 2  d_val	 optional     optional<br>  DT_PLTGOT		 3  d_ptr	 optional     optional<br>  DT_HASH		 4  d_ptr	 mandatory    mandatory<br>  DT_STRTAB		 5  d_ptr	 mandatory    mandatory<br>  DT_SYMTAB		 6  d_ptr	 mandatory    mandatory<br>  DT_RELA		 7  d_ptr	 mandatory    optional<br>  DT_RELASZ		 8  d_val	 mandatory    optional<br>  DT_RELAENT		 9  d_val	 mandatory    optional<br>  DT_STRSZ		10  d_val	 mandatory    mandatory<br>  DT_SYMENT		11  d_val	 mandatory    mandatory<br>  DT_INIT		12  d_ptr	 optional     optional<br>  DT_FINI		13  d_ptr	 optional     optional<br>  DT_SONAME		14  d_val	 ignored      optional<br>  DT_RPATH		15  d_val	 optional     ignored<br>  DT_SYMBOLIC		16  ignored	 ignored      optional<br>  DT_REL		17  d_ptr	 mandatory    optional<br>  DT_RELSZ		18  d_val	 mandatory    optional<br>  DT_RELENT		19  d_val	 mandatory    optional<br>  DT_PLTREL		20  d_val	 optional     optional<br>  DT_DEBUG		21  d_ptr	 optional     ignored<br>  DT_TEXTREL		22  ignored	 optional     optional<br>  DT_JMPREL		23  d_ptr	 optional     optional<br>  DT_LOPROC     0x70000000  unspecified  unspecified  unspecified<br>  DT_HIPROC     0x7fffffff  unspecified  unspecified  unspecified<br><br>* DT_NULL<br><br>  An entry with a DT_NULL tag marks the end of the _DYNAMIC array.<br><br>* DT_NEEDED<br><br>  This element holds the string table offset of a null-terminated<br>  string, giving the name of a needed library. The offset is an index<br>  into the table recorded in the DT_STRTAB entry. See ``Shared Object<br>  Dependencies'' for more information about these names. The dynamic<br>  array may contain multiple entries with this type. These entries'<br>  relative order is significant, though their relation to entries of<br>  other types is not.<br><br>* DT_PLTRELSZ<br><br>  This element holds the total size, in bytes, of the relocation<br>  entries associated with the procedure linkage table. If an entry of<br>  type DT_JMPREL is present, a DT_PLTRELSZ must accompany it.<br><br>* DT_PLTGOT<br><br>  This element holds an address associated with the procedure linkage<br>  table and/or the global offset table. See this section in the<br>  processor supplement for details.<br><br>* DT_HASH<br><br>  This element holds the address of the symbol hash table, described<br>  in ``Hash Table.'' This hash table refers to the symbol table<br>  referenced by the DT_SYMTAB element.<br><br>* DT_STRTAB<br><br>  This element holds the address of the string table, described in<br>  Part 1. Symbol names, library names, and other strings reside in<br>  this table.<br><br>* DT_SYMTAB<br><br>  This element holds the address of the symbol table, described in<br>  Part 1, with Elf32_Sym entries for the 32-bit class of files.<br><br>* DT_RELA<br><br>  This element holds the address of a relocation table, described in<br>  Part 1. Entries in the table have explicit addends, such as<br>  Elf32_Rela for the 32-bit file class. An object file may have<br>  multiple relocation sections. When building the relocation table for<br>  an executable or shared object file, the link editor catenates those<br>  sections to form a single table. Although the sections remain<br>  independent in the object file, the dynamic linker sees a single<br>  table. When the dynamic linker creates the process image for an<br>  executable file or adds a shared object to the process image, it<br>  reads the relocation table and performs the associated actions. If<br>  this element is present, the dynamic structure must also have<br>  DT_RELASZ and DT_RELAENT elements. When relocation is ``mandatory''<br>  for a file, either DT_RELA or DT_REL may occur (both are permitted<br>  but not required).<br><br>* DT_RELASZ<br><br>  This element holds the total size, in bytes, of the DT_RELA<br>  relocation table.<br><br>* DT_RELAENT<br><br>  This element holds the size, in bytes, of the DT_RELA relocation<br>  entry.<br><br>* DT_STRSZ<br><br>  This element holds the size, in bytes, of the string table.<br><br>* DT_SYMENT<br><br>  This element holds the size, in bytes, of a symbol table entry.<br><br>* DT_INIT<br><br>  This element holds the address of the initialization function,<br>  discussed in ``Initialization and Termination Functions'' below.<br><br>* DT_FINI<br><br>  This element holds the address of the termination function,<br>  discussed in ``Initialization and Termination Functions'' below.<br><br>* DT_SONAME<br><br>  This element holds the string table offset of a null-terminated<br>  string, giving the name of the shared object. The offset is an index<br>  into the table recorded in the DT_STRTAB entry. See ``Shared Object<br>  Dependencies'' below for more information about these names.<br><br>* DT_RPATH<br><br>  This element holds the string table offset of a null-terminated<br>  search library search path string, discussed in ``Shared Object<br>  Dependencies.'' The offset is an index into the table recorded in<br>  the DT_STRTAB entry.<br><br>* DT_SYMBOLIC<br><br>  This element's presence in a shared object library alters the<br>  dynamic linker's symbol resolution algorithm for references within<br>  the library. Instead of starting a symbol search with the executable<br>  file, the dynamic linker starts from the shared object itself. If<br>  the shared object fails to supply the referenced symbol, the dynamic<br>  linker then searches the executable file and other shared objects as<br>  usual.<br><br>* DT_REL<br><br>  This element is similar to DT_RELA, except its table has implicit<br>  addends, such as Elf32_Rel for the 32-bit file class. If this<br>  element is present, the dynamic structure must also have DT_RELSZ<br>  and DT_RELENT elements.<br><br>* DT_RELSZ<br><br>  This element holds the total size, in bytes, of the DT_REL<br>  relocation table.<br><br>* DT_RELENT<br><br>  This element holds the size, in bytes, of the DT_REL relocation<br>  entry.<br><br>* DT_PLTREL<br><br>  This member specifies the type of relocation entry to which the<br>  procedure linkage table refers. The d_val member holds DT_REL or<br>  DT_RELA, as appropriate. All relocations in a procedure linkage<br>  table must use the same relocation.<br><br>* DT_DEBUG<br><br>  This member is used for debugging. Its contents are not specified<br>  for the ABI; programs that access this entry are not ABI-conforming.<br><br>* DT_TEXTREL<br><br>  This member's absence signifies that no relocation entry should<br>  cause a modification to a non-writable segment, as specified by the<br>  segment permissions in the program header table. If this member is<br>  present, one or more relocation entries might request modifications<br>  to a non-writable segment, and the dynamic linker can prepare<br>  accordingly.<br><br>* DT_JMPREL<br><br>  If present, this entries's d_ptr member holds the address of<br>  relocation entries associated solely with the procedure linkage<br>  table. Separating these relocation entries lets the dynamic linker<br>  ignore them during process initialization, if lazy binding is<br>  enabled. If this entry is present, the related entries of types<br>  DT_PLTRELSZ and DT_PLTREL must also be present.<br><br>* DT_LOPROC through DT_HIPROC<br><br>  Values in this inclusive range are reserved for processor-specific<br>  semantics.<br><br>Except for the DT_NULL element at the end of the array, and the<br>relative order of DT_NEEDED elements, entries may appear in any order.<br>Tag values not appearing in the table are reserved.<br><br><br>		      Shared Object Dependencies<br><br>When the link editor processes an archive library, it extracts library<br>members and copies them into the output object file. These statically<br>linked services are available during execution without involving the<br>dynamic linker. Shared objects also provide services, and the dynamic<br>linker must attach the proper shared object files to the process image<br>for execution. Thus executable and shared object files describe their<br>specific dependencies.<br><br>When the dynamic linker creates the memory segments for an object<br>file, the dependencies (recorded in DT_NEEDED entries of the dynamic<br>structure) tell what shared objects are needed to supply the program's<br>services. By repeatedly connecting referenced shared objects and their<br>dependencies, the dynamic linker builds a complete process image. When<br>resolving symbolic references, the dynamic linker examines the symbol<br>tables with a breadth-first search. That is, it first looks at the<br>symbol table of the executable program itself, then at the symbol<br>tables of the DT_NEEDED entries (in order), then at the second level<br>DT_NEEDED entries, and so on. Shared object files must be readable by<br>the process; other permissions are not required.<br><br>NOTE: Even when a shared object is referenced multiple times in the<br>dependency list, the dynamic linker will connect the object only once<br>to the process.<br><br>Names in the dependency list are copies either of the DT_SONAME<br>strings or the path names of the shared objects used to build the<br>object file. For example, if the link editor builds an executable file<br>using one shared object with a DT_SONAME entry of lib1 and another<br>shared object library with the path name /usr/lib/lib2, the executable<br>file will contain lib1 and /usr/lib/lib2 in its dependency list.<br><br>If a shared object name has one or more slash (/) characters anywhere<br>in the name, such as /usr/lib/lib2 above or directory/file, the<br>dynamic linker uses that string directly as the path name. If the name<br>has no slashes, such as lib1 above, three facilities specify shared<br>object path searching, with the following precedence.<br><br>* First, the dynamic array tag DT_RPATH may give a string that holds a<br>  list of directories, separated by colons (:). For example, the<br>  string /home/dir/lib:/home/dir2/lib: tells the dynamic linker to<br>  search first the directory /home/dir/lib, then /home/dir2/lib, and<br>  then the current directory to find dependencies.<br>* Second, a variable called LD_LIBRARY_PATH in the process environment<br>  [see exec(BA_OS)] may hold a list of directories as above,<br>  optionally followed by a semicolon (;) and another directory list.<br>  The following values would be equivalent to the previous example:<br>    LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib:<br>    LD_LIBRARY_PATH=/home/dir/lib;/home/dir2/lib:<br>    LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib:;<br>  All LD_LIBRARY_PATH directories are searched after those from<br>  DT_RPATH. Although some programs (such as the link editor) treat the<br>  lists before and after the semicolon differently, the dynamic linker<br>  does not. Nevertheless, the dynamic linker accepts the semicolon<br>  notation, with the semantics described above.<br>* Finally, if the other two groups of directories fail to locate the<br>  desired library, the dynamic linker searches /usr/lib.<br><br>NOTE: For security, the dynamic linker ignores environmental search<br>specifications (such as LD_LIBRARY_PATH) for set-user and set-group ID<br>programs. It does, however, search DT_RPATH directories and /usr/lib.<br><br><br>			 Global Offset Table<br><br>Position-independent code cannot, in general, contain absolute virtual<br>addresses. Global offset tables hold absolute addresses in private<br>data, thus making the addresses available without compromising the<br>position-independence and sharability of a program's text. A program<br>references its global offset table using position-independent<br>addressing and extracts absolute values, thus redirecting<br>position-independent references to absolute locations.<br><br>Initially, the global offset table holds information as required by<br>its relocation entries [see ``Relocation'' in Part 1]. After the<br>system creates memory segments for a loadable object file, the dynamic<br>linker processes the relocation entries, some of which will be type<br>R_386_GLOB_DAT referring to the global offset table. The dynamic<br>linker determines the associated symbol values, calculates their<br>absolute addresses, and sets the appropriate memory table entries to<br>the proper values. Although the absolute addresses are unknown when<br>the link editor builds an object file, the dynamic linker knows the<br>addresses of all memory segments and can thus calculate the absolute<br>addresses of the symbols contained therein.<br><br>If a program requires direct access to the absolute address of a<br>symbol, that symbol will have a global offset table entry. Because the<br>executable file and shared objects have separate global offset tables,<br>a symbol's address may appear in several tables. The dynamic linker<br>processes all the global offset table relocations before giving<br>control to any code in the process image, thus ensuring the absolute<br>addresses are available during execution.<br><br>The table's entry zero is reserved to hold the address of the dynamic<br>structure, referenced with the symbol _DYNAMIC. This allows a program,<br>such as the dynamic linker, to find its own dynamic structure without<br>having yet processed its relocation entries. This is especially<br>important for the dynamic linker, because it must initialize itself<br>without relying on other programs to relocate its memory image. On the<br>32-bit Intel Architecture, entries one and two in the global offset<br>table also are reserved. ``Procedure Linkage Table'' below describes<br>them.<br><br>The system may choose different memory segment addresses for the same<br>shared object in different programs; it may even choose different<br>library addresses for different executions of the same program.<br>Nonetheless, memory segments do not change addresses once the process<br>image is established. As long as a process exists, its memory segments<br>reside at fixed virtual addresses.<br><br>A global offset table's format and interpretation are<br>processor-specific. For the 32-bit Intel Architecture, the symbol<br>_GLOBAL_OFFSET_TABLE_ may be used to access the table.<br><br>+ Figure 2-11: Global Offset Table<br><br>  extern Elf32_Addr _GLOBAL_OFFSET_TABLE_[];<br><br>The symbol _GLOBAL_OFFSET_TABLE_ may reside in the middle of the .got<br>section, allowing both negative and non-negative ``subscripts'' into<br>the array of addresses.<br><br><br>		       Procedure Linkage Table<br><br>Much as the global offset table redirects position-independent address<br>calculations to absolute locations, the procedure linkage table<br>redirects position-independent function calls to absolute locations.<br>The link editor cannot resolve execution transfers (such as function<br>calls) from one executable or shared object to another. Consequently,<br>the link editor arranges to have the program transfer control to<br>entries in the procedure linkage table. On the SYSTEM V architecture,<br>procedure linkage tables reside in shared text, but they use addresses<br>in the private global offset table. The dynamic linker determines the<br>destinations' absolute addresses and modifies the global offset<br>table's memory image accordingly. The dynamic linker thus can redirect<br>the entries without compromising the position-independence and<br>sharability of the program's text. Executable files and shared object<br>files have separate procedure linkage tables.<br><br>+ Figure 2-12: Absolute Procedure Linkage Table {*}<br><br>  .PLT0:pushl   got_plus_4<br>        jmp     *got_plus_8<br>        nop; nop<br>        nop; nop<br>  .PLT1:jmp     *name1_in_GOT<br>        pushl   $offset<br>        jmp     .PLT0@PC<br>  .PLT2:jmp     *name2_in_GOT<br>        pushl   $offset<br>        jmp     .PLT0@PC<br>        ...<br><br>+ Figure 2-13: Position-Independent Procedure Linkage Table<br><br>  .PLT0:pushl   4(%ebx)<br>        jmp     *8(%ebx)<br>        nop; nop<br>        nop; nop<br>  .PLT1:jmp     *name1@GOT(%ebx)<br>        pushl   $offset<br>        jmp     .PLT0@PC<br>  .PLT2:jmp     *name2@GOT(%ebx)<br>        pushl   $offset<br>        jmp     .PLT0@PC<br>        ...<br><br>NOTE: As the figures show, the procedure linkage table instructions<br>use different operand addressing modes for absolute code and for<br>position-independent code. Nonetheless, their interfaces to the<br>dynamic linker are the same.<br><br>Following the steps below, the dynamic linker and the program<br>``cooperate'' to resolve symbolic references through the procedure<br>linkage table and the global offset table.<br><br>1. When first creating the memory image of the program, the dynamic<br>   linker sets the second and the third entries in the global offset<br>   table to special values. Steps below explain more about these<br>   values.<br>2. If the procedure linkage table is position-independent, the address<br>   of the global offset table must reside in %ebx. Each shared object<br>   file in the process image has its own procedure linkage table, and<br>   control transfers to a procedure linkage table entry only from<br>   within the same object file. Consequently, the calling function is<br>   responsible for setting the global offset table base register<br>   before calling the procedure linkage table entry.<br>3. For illustration, assume the program calls name1, which transfers<br>   control to the label .PLT1.<br>4. The first instruction jumps to the address in the global offset<br>   table entry for name1. Initially, the global offset table holds the<br>   address of the following pushl instruction, not the real address of<br>   name1.<br>5. Consequently, the program pushes a relocation offset (offset) on<br>   the stack. The relocation offset is a 32-bit, non-negative byte<br>   offset into the relocation table. The designated relocation entry<br>   will have type R_386_JMP_SLOT, and its offset will specify the<br>   global offset table entry used in the previous jmp instruction. The<br>   relocation entry also contains a symbol table index, thus telling<br>   the dynamic linker what symbol is being referenced, name1 in this<br>   case.<br>6. After pushing the relocation offset, the program then jumps to<br>   .PLT0, the first entry in the procedure linkage table. The pushl<br>   instruction places the value of the second global offset table<br>   entry (got_plus_4 or 4(%ebx)) on the stack, thus giving the dynamic<br>   linker one word of identifying information. The program then jumps<br>   to the address in the third global offset table entry (got_plus_8<br>   or 8(%ebx)), which transfers control to the dynamic linker.<br>7. When the dynamic linker receives control, it unwinds the stack,<br>   looks at the designated relocation entry, finds the symbol's value,<br>   stores the ``real'' address for name1 in its global offset table<br>   entry, and transfers control to the desired destination.<br>8. Subsequent executions of the procedure linkage table entry will<br>   transfer directly to name1, without calling the dynamic linker a<br>   second time. That is, the jmp instruction at .PLT1 will transfer to<br>   name1, instead of ``falling through'' to the pushl instruction.<br><br>The LD_BIND_NOW environment variable can change dynamic linking<br>behavior. If its value is non-null, the dynamic linker evaluates<br>procedure linkage table entries before transferring control to the<br>program. That is, the dynamic linker processes relocation entries of<br>type R_386_JMP_SLOT during process initialization. Otherwise, the<br>dynamic linker evaluates procedure linkage table entries lazily,<br>delaying symbol resolution and relocation until the first execution of<br>a table entry.<br><br>NOTE: Lazy binding generally improves overall application performance,<br>because unused symbols do not incur the dynamic linking overhead.<br>Nevertheless, two situations make lazy binding undesirable for some<br>applications. First, the initial reference to a shared object function<br>takes longer than subsequent calls, because the dynamic linker<br>intercepts the call to resolve the symbol. Some applications cannot<br>tolerate this unpredictability. Second, if an error occurs and the<br>dynamic linker cannot resolve the symbol, the dynamic linker will<br>terminate the program. Under lazy binding, this might occur at<br>arbitrary times. Once again, some applications cannot tolerate this<br>unpredictability. By turning off lazy binding, the dynamic linker<br>forces the failure to occur during process initialization, before the<br>application receives control.<br><br><br>			      Hash Table<br><br>A hash table of Elf32_Word objects supports symbol table access.<br>Labels appear below to help explain the hash table organization, but<br>they are not part of the specification.<br><br>+ Figure 2-14: Symbol Hash Table<br><br>  nbucket<br>  nchain<br>  bucket[0]<br>  ...<br>  bucket[nbucket - 1]<br>  chain[0]<br>  ...<br>  chain[nchain - 1]<br><br>The bucket array contains nbucket entries, and the chain array<br>contains nchain entries; indexes start at 0. Both bucket and chain<br>hold symbol table indexes. Chain table entries parallel the symbol<br>table. The number of symbol table entries should equal nchain; so<br>symbol table indexes also select chain table entries. A hashing<br>function (shown below) accepts a symbol name and returns a value that<br>may be used to compute a bucket index. Consequently, if the hashing<br>function returns the value x for some name, bucket[x%nbucket] gives an<br>index, y, into both the symbol table and the chain table. If the<br>symbol table entry is not the one desired, chain[y] gives the next<br>symbol table entry with the same hash value. One can follow the chain<br>links until either the selected symbol table entry holds the desired<br>name or the chain entry contains the value STN_UNDEF.<br><br>+ Figure 2-15: Hashing Function<br><br>  unsigned long<br>  elf_hash(const unsigned char *name)<br>  {<!-- --><br>      unsigned long       h = 0, g;<br>  <br>      while (*name) {<!-- --><br>          h = (h &lt;&lt; 4) + *name++;<br>          if (g = h &amp; 0xf0000000)<br>              h ^= g &gt;&gt; 24;<br>          h &amp;= ~g;<br>      }<br>      return h;<br>  }<br><br><br>	       Initialization and Termination Functions<br><br>After the dynamic linker has built the process image and performed the<br>relocations, each shared object gets the opportunity to execute some<br>initialization code. These initialization functions are called in no<br>specified order, but all shared object initializations happen before<br>the executable file gains control.<br><br>Similarly, shared objects may have termination functions, which are<br>executed with the atexit(BA_OS) mechanism after the base process<br>begins its termination sequence. Once again, the order in which the<br>dynamic linker calls termination functions is unspecified.<br><br>Shared objects designate their initialization and termination<br>functions through the DT_INIT and DT_FINI entries in the dynamic<br>structure, described in ``Dynamic Section'' above. Typically, the code<br>for these functions resides in the .init and .fini sections, mentioned<br>in ``Sections'' of Part 1.<br><br>NOTE: Although the atexit(BA_OS) termination processing normally will<br>be done, it is not guaranteed to have executed upon process death. In<br>particular, the process will not execute the termination processing if<br>it calls _exit [see exit(BA_OS)] or if the process dies because it<br>received a signal that it neither caught nor ignored.<br><br>   ________________________________________________________________<br><br><br>			     3. C LIBRARY<br><br>   ________________________________________________________________<br><br><br>   ========================== C Library ===========================<br><br><br>The C library, libc, contains all of the symbols contained in libsys,<br>and, in addition, contains the routines listed in the following two<br>tables. The first table lists routines from the ANSI C standard.<br><br>+ Figure 3-1: libc Contents, Names without Synonyms<br><br>  abort        fputc        isprint      putc         strncmp<br>  abs	       fputs        ispunct      putchar      strncpy<br>  asctime      fread        isspace      puts         strpbrk<br>  atof	       freopen      isupper      qsort        strrchr<br>  atoi	       frexp        isxdigit     raise        strspn<br>  atol	       fscanf       labs         rand         strstr<br>  bsearch      fseek        ldexp        rewind       strtod<br>  clearerr     fsetpos      ldiv         scanf        strtok<br>  clock	       ftell        localtime    setbuf       strtol<br>  ctime	       fwrite       longjmp      setjmp       strtoul<br>  difftime     getc         mblen        setvbuf      tmpfile<br>  div	       getchar      mbstowcs     sprintf      tmpnam<br>  fclose       getenv       mbtowc       srand        tolower<br>  feof	       gets         memchr       sscanf       toupper<br>  ferror       gmtime       memcmp       strcat       ungetc<br>  fflush       isalnum      memcpy       strchr       vfprintf<br>  fgetc	       isalpha      memmove      strcmp       vprintf<br>  fgetpos      iscntrl      memset       strcpy       vsprintf<br>  fgets	       isdigit      mktime       strcspn      wcstombs<br>  fopen	       isgraph      perror       strlen       wctomb<br>  fprintf      islower      printf       strncat    <br><br>Additionally, libc holds the following services.<br><br>+ Figure 3-2: libc Contents, Names with Synonyms<br><br>  __assert     getdate      lockf **     sleep        tell ** <br>  cfgetispeed  getopt       lsearch      strdup       tempnam<br>  cfgetospeed  getpass      memccpy      swab         tfind<br>  cfsetispeed  getsubopt    mkfifo       tcdrain      toascii<br>  cfsetospeed  getw         mktemp       tcflow       _tolower<br>  ctermid      hcreate      monitor      tcflush      tsearch<br>  cuserid      hdestroy     nftw         tcgetattr    _toupper<br>  dup2	       hsearch      nl_langinfo  tcgetpgrp    twalk<br>  fdopen       isascii      pclose       tcgetsid     tzset<br>  __filbuf     isatty       popen        tcsendbreak  _xftw<br>  fileno       isnan        putenv       tcsetattr    <br>  __flsbuf     isnand **    putw         tcsetpgrp    <br>  fmtmsg **    lfind        setlabel     tdelete      <br><br>  ** = Function is at Level 2 in the SVID Issue 3 and therefore at<br>       Level 2 in the ABI.<br><br>Besides the symbols listed in the With Synonyms table above, synonyms<br>of the form _&lt;name&gt; exist for &lt;name&gt; entries that are not listed with<br>a leading underscore prepended to their name. Thus libc contains both<br>getopt and _getopt, for example.<br><br>Of the routines listed above, the following are not defined elsewhere.<br><br>int __filbuf(FILE *f); 	This function returns the next input character for f, filling 	its buffer as appropriate. It returns EOF if an error occurs.  int __flsbuf(int x, FILE *f); 	This function flushes the output characters for f as if 	putc(x, f) had been called and then appends the value of x to 	the resulting output stream. It returns EOF if an error occurs 	and x otherwise.  int _xftw(int, char *, int (*)(char *, struct stat *, int), int); 	Calls to the ftw(BA_LIB) function are mapped to this function 	when applications are compiled. This function is identical to 	ftw(BA_LIB), except that _xftw() takes an interposed first 	argument, which must have the value 2.  See this chapter's other library sections for more SVID, ANSI C, and POSIX facilities. See ``System Data Interfaces'' later in this chapter for more information.   			 Global Data Symbols  The libc library requires that some global external data symbols be defined for its routines to work properly. All the data symbols required for the libsys library must be provided by libc, as well as the data symbols listed in the table below.  For formal declarations of the data objects represented by these symbols, see the System V Interface Definition, Third Edition or the ``Data Definitions'' section of Chapter 6 in the appropriate processor supplement to the System V ABI.  For entries in the following table that are in &lt;name&gt;-_&lt;name&gt; form, both symbols in each pair represent the same data. The underscore synonyms are provided to satisfy the ANSI C standard.  + Figure 3-3: libc Contents, Global External Data Symbols    getdate_err		optarg   _getdate_err		opterr   __iob			optind 			optopt  </pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81ff814221fb7916dc78f053b17d2a4c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">唉~这种SOHO的生活啊。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>