<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>InfluxDB-FLUX语法介绍以及查询InfluxDB - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="InfluxDB-FLUX语法介绍以及查询InfluxDB" />
<meta property="og:description" content="文章目录 FLUX 语法介绍最简示例FLUX 的基本语法注释变量与复制基本表达式谓词表达式控制语句 FLUX 中的数据类型十个基本数据类型Boolean （布尔型）bytes （字节）Duration 持续时间Regular expression 正则表达式String 字符串Time 时间点Float 浮点数Integer 整数UIntegers 无符号整数Null 空值 FLUX 类型不代表 InfluxDB 类型4 个复合类型Record（记录）Array（数组）Dictionary（字典）function（函数） 函数包 FLUX 查询 InfluxDBFLUX 查询InfluxDB 的语法表、表流以及序列filter 维度过滤类型转换函数与下划线字段map 函数自定义管道函数在文档中区分管道函数和普通函数window 和 aggregateWindow 函数yield 和 join FLUX 语法 介绍 Flux 是一种函数式的数据脚本语言，它旨在将查询、处理、分析和操作数据统一为一种语法。
想要从概念上理解 FLUX，你可以想想水处理的过程。我们从源头把水抽取出来，然后按照我们的用水需求，在管道上进行一系列的处理修改（去除沉积物，净化）等，最终以消耗品的方式输送到我们的目的地（饮水机、灌溉等）。
注意：InfluxData 公司对 FLUX 语言构想并不是仅仅让它作为 InfluxDB 的特定查询语言，而是希望它像 SQL 一样，成为一种标准。按照这个计划，FLUX 语言应该具备处理来自不同数据源的数据的能力。
注意InfluxDB 支持的 FLUX 语言版本：
需要注意，因为 InfluxDB 是一个用 Go 语言编写的数据库，它的整个项目成果就是一个单独的可执行二进制文件，所以 FLUX 语言其实也会被编译到同一个文件里。这意味着InfluxDB 和 FLUX 会有版本绑定的关系。
这里，我放了一个链接 https://docs.influxdata.com/flux/v0.x/influxdb-versions/ ，它是官方 FLUX 文档的一部分，这里明确记录了 InfluxDB 版本的 FLUX 语言版本的对应关系。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/be3319ef9599f5a82aa2c206125ab42e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-06T16:34:45+08:00" />
<meta property="article:modified_time" content="2023-07-06T16:34:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">InfluxDB-FLUX语法介绍以及查询InfluxDB</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#FLUX__2" rel="nofollow">FLUX 语法</a></li><li><ul><li><a href="#_4" rel="nofollow">介绍</a></li><li><a href="#_20" rel="nofollow">最简示例</a></li><li><a href="#FLUX__100" rel="nofollow">FLUX 的基本语法</a></li><li><ul><li><a href="#_102" rel="nofollow">注释</a></li><li><a href="#_114" rel="nofollow">变量与复制</a></li><li><a href="#_131" rel="nofollow">基本表达式</a></li><li><a href="#_156" rel="nofollow">谓词表达式</a></li><li><a href="#_215" rel="nofollow">控制语句</a></li></ul> 
   </li></ul> 
   </li><li><a href="#FLUX__238" rel="nofollow">FLUX 中的数据类型</a></li><li><ul><li><a href="#_240" rel="nofollow">十个基本数据类型</a></li><li><ul><li><a href="#Boolean__242" rel="nofollow">Boolean （布尔型）</a></li><li><a href="#bytes__266" rel="nofollow">bytes （字节）</a></li><li><a href="#Duration__307" rel="nofollow">Duration 持续时间</a></li><li><a href="#Regular_expression__436" rel="nofollow">Regular expression 正则表达式</a></li><li><a href="#String__505" rel="nofollow">String 字符串</a></li><li><a href="#Time__566" rel="nofollow">Time 时间点</a></li><li><a href="#Float__595" rel="nofollow">Float 浮点数</a></li><li><a href="#Integer__689" rel="nofollow">Integer 整数</a></li><li><a href="#UIntegers__752" rel="nofollow">UIntegers 无符号整数</a></li><li><a href="#Null__775" rel="nofollow">Null 空值</a></li></ul> 
    </li><li><a href="#FLUX__InfluxDB__821" rel="nofollow">FLUX 类型不代表 InfluxDB 类型</a></li><li><a href="#4__827" rel="nofollow">4 个复合类型</a></li><li><ul><li><a href="#Record_829" rel="nofollow">Record（记录）</a></li><li><a href="#Array_980" rel="nofollow">Array（数组）</a></li><li><a href="#Dictionary_1026" rel="nofollow">Dictionary（字典）</a></li><li><a href="#function_1124" rel="nofollow">function（函数）</a></li></ul> 
    </li><li><a href="#_1154" rel="nofollow">函数包</a></li></ul> 
   </li><li><a href="#FLUX__InfluxDB_1174" rel="nofollow">FLUX 查询 InfluxDB</a></li><li><ul><li><a href="#FLUX_InfluxDB__1176" rel="nofollow">FLUX 查询InfluxDB 的语法</a></li><li><a href="#_1189" rel="nofollow">表、表流以及序列</a></li><li><a href="#filter__1201" rel="nofollow">filter 维度过滤</a></li><li><a href="#_1207" rel="nofollow">类型转换函数与下划线字段</a></li><li><a href="#map__1217" rel="nofollow">map 函数</a></li><li><a href="#_1233" rel="nofollow">自定义管道函数</a></li><li><a href="#_1263" rel="nofollow">在文档中区分管道函数和普通函数</a></li><li><a href="#window__aggregateWindow__1275" rel="nofollow">window 和 aggregateWindow 函数</a></li><li><a href="#yield__join_1281" rel="nofollow">yield 和 join</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="FLUX__2"></a>FLUX 语法</h3> 
<h4><a id="_4"></a>介绍</h4> 
<p><strong>Flux 是一种函数式的数据脚本语言，它旨在将查询、处理、分析和操作数据统一为一种语法。</strong></p> 
<p>想要从概念上理解 FLUX，你可以想想水处理的过程。我们从源头把水抽取出来，然后按照我们的用水需求，在管道上进行一系列的处理修改（去除沉积物，净化）等，最终以消耗品的方式输送到我们的目的地（饮水机、灌溉等）。</p> 
<p>注意：InfluxData 公司对 FLUX 语言构想并不是仅仅让它作为 InfluxDB 的特定查询语言，而是希望它像 SQL 一样，成为一种标准。按照这个计划，FLUX 语言应该具备处理来自不同数据源的数据的能力。</p> 
<p><strong>注意InfluxDB 支持的 FLUX 语言版本：</strong></p> 
<p>需要注意，因为 InfluxDB 是一个用 Go 语言编写的数据库，它的整个项目成果就是一个单独的可执行二进制文件，所以 FLUX 语言其实也会被编译到同一个文件里。这意味着InfluxDB 和 FLUX 会有版本绑定的关系。</p> 
<p>这里，我放了一个链接 <a href="https://docs.influxdata.com/flux/v0.x/influxdb-versions/" rel="nofollow">https://docs.influxdata.com/flux/v0.x/influxdb-versions/</a> ，它是官方 FLUX 文档的一部分，这里明确记录了 InfluxDB 版本的 FLUX 语言版本的对应关系。</p> 
<p><img src="https://images2.imgbox.com/8f/90/EtgOtnJp_o.png" alt="MMMSIZE"></p> 
<h4><a id="_20"></a>最简示例</h4> 
<p>与处理水一样，使用 FLUX 语言进行查询时会执行以下操作。</p> 
<ol><li> <p>从数据源中查询指定数量的数据</p> </li><li> <p>根据时间或字段筛选数据</p> </li><li> <p>将数据进行处理或者聚合以得到预期结果</p> </li><li> <p>返回最终的结果</p> </li></ol> 
<p>下面 3 个示例的处理逻辑都是一样的，只不过数据源有所不同，</p> 
<p>这 3 个示例只是让大家看一下语法，不需要运行。</p> 
<ul><li> <p>示例 1：从 InfluxDB 查询数据并聚合</p> <pre><code class="prism language-sql"><span class="token keyword">from</span><span class="token punctuation">(</span>bucket: <span class="token string">"example-bucket"</span><span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> range<span class="token punctuation">(</span><span class="token keyword">start</span>: <span class="token operator">-</span><span class="token number">1</span>d<span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> filter<span class="token punctuation">(</span>fn: <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> r<span class="token punctuation">.</span>_measurement <span class="token operator">=</span><span class="token operator">=</span> <span class="token string">"example-measurement"</span><span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> yield<span class="token punctuation">(</span>name: <span class="token string">"_results"</span><span class="token punctuation">)</span>
</code></pre> </li><li> <p>示例 2：从CSV 文件查询数据并聚合</p> <pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"csv"</span>
csv<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">file</span>: <span class="token string">"path/to/example/data.csv"</span><span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> range<span class="token punctuation">(</span><span class="token keyword">start</span>: <span class="token operator">-</span><span class="token number">1</span>d<span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> filter<span class="token punctuation">(</span>fn: <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> r<span class="token punctuation">.</span>_measurement <span class="token operator">=</span><span class="token operator">=</span> <span class="token string">"example-measurement"</span><span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> yield<span class="token punctuation">(</span>name: <span class="token string">"_results"</span><span class="token punctuation">)</span>
</code></pre> </li><li> <p>示例 3：从PostgreSQL 数据库查询数据并聚合</p> <pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"sql"</span>
<span class="token keyword">sql</span><span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>
 driverName: <span class="token string">"postgres"</span><span class="token punctuation">,</span>
 dataSourceName: <span class="token string">"postgresql://user:password@localhost"</span><span class="token punctuation">,</span>
 query: <span class="token string">"SELECT * FROM TestTable"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> filter<span class="token punctuation">(</span>fn: <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> r<span class="token punctuation">.</span>UserID <span class="token operator">=</span><span class="token operator">=</span> <span class="token string">"123ABC456DEF"</span><span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> mean<span class="token punctuation">(</span><span class="token keyword">column</span>: <span class="token string">"purchase_total"</span><span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> yield<span class="token punctuation">(</span>name: <span class="token string">"_results"</span><span class="token punctuation">)</span>
</code></pre> </li></ul> 
<p>上面 3 个示例用的函数都是一模一样的，下面来讲解示例中出现的代码：</p> 
<ul><li> <p>from( )函数可以指定数据源。</p> </li><li> <p>| &gt;管道转发符，将一个函数的输出转发给下一个函数。</p> </li><li> <p>range( )，fliter( ) 两个函数在根据列的值对数据进行过滤</p> </li><li> <p>mean( )函数在计算所剩数据的平均值。</p> </li><li> <p>yield( ) 将最终的计算结果返回给用户。</p> </li></ul> 
<p>虽然，FLUX 语言的自我定位一个脚本语言，但是我们必须注意它也是一个查询语言的事实。因此，一个 FLUX 脚本想要成功执行，它就必须返回一个表流。就像是 SQL 语言想要正确执行，它就必须返回一张表。</p> 
<p>表流是 FLUX 里提出一种数据结构。另外需要注意，我们后面的代码，如果只返回一个单值，比如单个整数或者字符串这种，那就必须把这个值转换成表流才能运行。这个时候必须使用 array.from 函数。</p> 
<p>示例如下：</p> 
<pre><code class="prism language-sql"><span class="token keyword">from</span> <span class="token string">"array
x = 1
array.from(rows: [{"</span><span class="token keyword">value</span>":x}<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>array.from 函数的作用就是把 x 这个单值，包装在了一个表流里面返回了。</p> 
<h4><a id="FLUX__100"></a>FLUX 的基本语法</h4> 
<h5><a id="_102"></a>注释</h5> 
<p>在 FLUX 脚本中，没有多行注释一说，用户只能写单行注释。如果一行以两个斜杠开头，那么这一行中的所有内容会被视为注释。</p> 
<p>示例：</p> 
<pre><code class="prism language-bash"> // 这是一行注释。
</code></pre> 
<h5><a id="_114"></a>变量与复制</h5> 
<p>使用赋值运算符（=）将表达式的结果赋值变量，最终你可以使用变量名来返回变量的值。</p> 
<p>示例：</p> 
<pre><code class="prism language-bash">s <span class="token operator">=</span> <span class="token string">"foo"</span> // string
i <span class="token operator">=</span> <span class="token number">1</span> // integer
f <span class="token operator">=</span> <span class="token number">2.0</span> // float <span class="token punctuation">(</span>floating point number<span class="token punctuation">)</span>
s // Returns foo
i // Returns <span class="token number">1</span>
f // Returns <span class="token number">2.0</span>
</code></pre> 
<h5><a id="_131"></a>基本表达式</h5> 
<p>FLUX 支持基本的表达式，比如：</p> 
<ul><li>+数字相加或字符串拼接</li><li>- 数字减法</li><li>* 数字相乘</li><li>/ 数字除法</li><li>% 取模</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-bash"><span class="token number">1</span> + <span class="token number">1</span>
// Returns <span class="token number">2</span>
<span class="token number">10</span> * <span class="token number">3</span>
// Returns <span class="token number">30</span>
<span class="token punctuation">(</span><span class="token number">12.0</span> + <span class="token number">18.0</span><span class="token punctuation">)</span> / <span class="token punctuation">(</span><span class="token number">2.0</span> ^ <span class="token number">2.0</span><span class="token punctuation">)</span> + <span class="token punctuation">(</span><span class="token number">240.0</span> % <span class="token number">55.0</span><span class="token punctuation">)</span>
// Returns <span class="token number">27.5</span>
<span class="token string">"John "</span> + <span class="token string">"Doe "</span> + <span class="token string">"is here!"</span>
// Returns John Doe is here<span class="token operator">!</span>
</code></pre> 
<h5><a id="_156"></a>谓词表达式</h5> 
<p><strong>（1）比较运算符</strong></p> 
<p>谓词表达式使用比较运算符和逻辑运算符来实现，谓词表达式的最后的返回结果只能为 true 或 false</p> 
<p>示例：</p> 
<pre><code class="prism language-bash"><span class="token string">"John"</span> <span class="token operator">==</span> <span class="token string">"John"</span>
// Returns <span class="token boolean">true</span>
<span class="token number">41</span> <span class="token operator">&lt;</span> <span class="token number">30</span>
// Returns <span class="token boolean">false</span>
<span class="token string">"John"</span> <span class="token operator">==</span> <span class="token string">"John"</span> and <span class="token number">41</span> <span class="token operator">&lt;</span> <span class="token number">30</span>
// Returns <span class="token boolean">false</span>
<span class="token string">"John"</span> <span class="token operator">==</span> <span class="token string">"John"</span> or <span class="token number">41</span> <span class="token operator">&lt;</span> <span class="token number">30</span>
// Returns <span class="token boolean">true</span>
</code></pre> 
<p>另外</p> 
<ul><li> <p>=~可以判断一个字符串时候能被正则表达式匹配上。</p> </li><li> <p>!~是=~的反操作，判断一个字符串是不是不能被某个正则表达式匹配。</p> </li></ul> 
<p>例如：</p> 
<pre><code class="prism language-bash"><span class="token string">"abcdefg"</span> <span class="token operator">=~</span> <span class="token string">"abc|bcd"</span>
// Returns <span class="token boolean">true</span>
<span class="token string">"abcdefg"</span> <span class="token operator">!</span>~ <span class="token string">"abc|bcd"</span>
// Returns <span class="token boolean">false</span>
</code></pre> 
<p><strong>（2）逻辑运算符</strong></p> 
<p>在 FLUX 语言中，表示与逻辑需要使用关键字 and，表示或逻辑需要使用关键字 or。示例：</p> 
<pre><code class="prism language-bash">a <span class="token operator">=</span> <span class="token boolean">true</span>
b <span class="token operator">=</span> <span class="token boolean">false</span>
x <span class="token operator">=</span> a and b
// Returns <span class="token boolean">false</span>
y <span class="token operator">=</span> a or b
// Returns <span class="token boolean">true</span>
</code></pre> 
<p>最后，not 可以用来进行逻辑取反。示例：</p> 
<pre><code class="prism language-bash">a <span class="token operator">=</span> <span class="token boolean">true</span>
b <span class="token operator">=</span> not a
// Returns <span class="token boolean">false</span>
</code></pre> 
<h5><a id="_215"></a>控制语句</h5> 
<p>所谓控制语句是指一个编程语言中用来空值代码执行顺序的语法。比如：</p> 
<ul><li> <p>if else</p> </li><li> <p>for while 循环</p> </li><li> <p>try catch 异常捕获</p> </li></ul> 
<p>不过，在 InfluxDB 中，这些语法统统没有。唯一一个和 if else 比较像的是 FLUX 语言中的条件子句，它和 python 中的条件子句功能一样且语法相似，和 java 语言相比的话它有些像三元表达式。</p> 
<p>示例如下：</p> 
<pre><code class="prism language-bash">x <span class="token operator">=</span> <span class="token number">0</span>
y <span class="token operator">=</span> <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">then</span> <span class="token string">"hello"</span> <span class="token keyword">else</span> <span class="token string">"world"</span>
</code></pre> 
<p>此处，if then else 被我们成为条件子句，你需要先指定一个条件，然后当条件为 true 的时候，条件子句会返回 then 后面的内容，也就是"hello"。如果是 flase，那么就会返回else 后面的内容，也就是"world"。</p> 
<h3><a id="FLUX__238"></a>FLUX 中的数据类型</h3> 
<h4><a id="_240"></a>十个基本数据类型</h4> 
<h5><a id="Boolean__242"></a>Boolean （布尔型）</h5> 
<p>使用 bool( )函数可以将下述的 4 个基本数据类型转换为 boolean：</p> 
<ul><li>string（字符串）：字符串必须是 “true” 或 “false”</li><li>float（浮点数）：值必须是 0.0（false）或 1.0（true）</li><li>int（整数）：值必须是 0（false）或 1（true）</li><li>uint（无符号整数）：值必须是 0（false）或 1（true）</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">bool</span><span class="token punctuation">(</span>v: <span class="token string">"true"</span><span class="token punctuation">)</span>
<span class="token comment">// Returns true</span>
<span class="token keyword">bool</span><span class="token punctuation">(</span>v: <span class="token number">0.0</span><span class="token punctuation">)</span>
<span class="token comment">// Returns false</span>
<span class="token keyword">bool</span><span class="token punctuation">(</span>v: <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token comment">// Returns false</span>
<span class="token keyword">bool</span><span class="token punctuation">(</span>v: uint<span class="token punctuation">(</span>v: <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// Returns true</span>
</code></pre> 
<h5><a id="bytes__266"></a>bytes （字节）</h5> 
<p>注意是 bytes（复数）不是byte，bytes 类型表示一个由字节组成的序列。</p> 
<p>（1）定义 <strong>bytes</strong></p> 
<p>FLUX 没有提供关于 bytes 的语法。可以使用bytes 函数将字符串转为bytes。</p> 
<pre><code class="prism language-bash">bytes<span class="token punctuation">(</span>v:<span class="token string">"hello"</span><span class="token punctuation">)</span>
// Returns <span class="token punctuation">[</span><span class="token number">104</span> <span class="token number">101</span> <span class="token number">108</span> <span class="token number">108</span> <span class="token number">111</span><span class="token punctuation">]</span>
</code></pre> 
<p>注意：只有字符串类型可以转换为 bytes。</p> 
<p>（2）将表示十六进制的字符串转为 <strong>bytes</strong></p> 
<p>引入"contrib/bonitoo-io/hex"包</p> 
<p>使用 hex.bytes() 将表示十六进制的字符串转为 bytes</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"contrib/bonitoo-io/hex"</span>
hex<span class="token punctuation">.</span>bytes<span class="token punctuation">(</span>v: <span class="token string">"FF5733"</span><span class="token punctuation">)</span>
<span class="token comment">// Returns [255 87 51] (bytes)</span>
</code></pre> 
<p>（3）使用 **display( )**函数获取 <strong>bytes</strong> 的字符串形式</p> 
<p>使用 display( )返回字节的字符串表示形式。bytes 的字符串表示是 0x 开头的十六进制表示。示例:</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"sampledata"</span>
sampledata<span class="token punctuation">.</span>string<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">|</span><span class="token operator">&gt;</span> map<span class="token punctuation">(</span>fn: <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>{r <span class="token keyword">with</span> _value: display<span class="token punctuation">(</span>v: bytes<span class="token punctuation">(</span>v: r<span class="token punctuation">.</span>_value<span class="token punctuation">)</span><span class="token punctuation">)</span>}<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/37/86/pGCOLUKh_o.png" alt="MMSIZE"></p> 
<h5><a id="Duration__307"></a>Duration 持续时间</h5> 
<p>持续时间提供了纳秒级精度的时间长度。</p> 
<p><strong>持续时间的语法：</strong></p> 
<ul><li> <p>ns：纳秒</p> </li><li> <p>us：微秒</p> </li><li> <p>ms：毫秒</p> </li><li> <p>s ：秒</p> </li><li> <p>m ：分钟</p> </li><li> <p>h ：小时</p> </li><li> <p>d ：天</p> </li><li> <p>w ：周</p> </li><li> <p>mo：日历月</p> </li><li> <p>y ：日历年</p> </li></ul> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token number">1</span>ns <span class="token comment">// 1 纳秒</span>
<span class="token number">1</span>us <span class="token comment">// 1 微妙</span>
<span class="token number">1</span>ms <span class="token comment">// 1 毫秒</span>
<span class="token number">1</span>s <span class="token comment">// 1 秒</span>
<span class="token number">1</span>m <span class="token comment">// 1 分钟</span>
<span class="token number">1</span>h <span class="token comment">// 1 小时</span>
<span class="token number">1</span>d <span class="token comment">// 1 天</span>
<span class="token number">1</span>w <span class="token comment">// 1 星期</span>
<span class="token number">1</span>mo <span class="token comment">// 1 日历月</span>
<span class="token number">1</span>y <span class="token comment">// 1 日历年</span>
<span class="token number">3</span>d12h4m25s <span class="token comment">// 3 天 12 小时 4 分钟又 25 秒</span>
</code></pre> 
<p>注意！持续时间的声明不要包含先导 0</p> 
<p>比如：</p> 
<pre><code class="prism language-bash">01m // 解析为整数 <span class="token number">0</span> 和 <span class="token number">1</span> 分钟的持续时间
02h05m //解析为整数 <span class="token number">0</span>、2 小时的持续时间，整数 <span class="token number">0</span> 和 <span class="token number">5</span> 分钟的持续时间。而不是 <span class="token number">2</span>小时又 <span class="token number">5</span> 分钟
</code></pre> 
<p><strong>将其他数据类型解释为持续时间：</strong></p> 
<p>使用 duration( )函数可以将以下基本数据类型转换为持续时间：</p> 
<ul><li>字符串：将表示持续时间字符串的函数转换为持续时间。</li><li>int：将整数先解释为纳秒再转换为持续时间</li><li>unit：将整数先解释为纳秒再转换为持续时间。</li></ul> 
<pre><code class="prism language-sql">duration<span class="token punctuation">(</span>v: <span class="token string">"1h30m"</span><span class="token punctuation">)</span>
<span class="token comment">// Returns 1h30m</span>
duration<span class="token punctuation">(</span>v: <span class="token number">1000000</span><span class="token punctuation">)</span>
<span class="token comment">// Returns 1ms</span>
duration<span class="token punctuation">(</span>v: uint<span class="token punctuation">(</span>v: <span class="token number">3000000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// Returns 3s</span>
</code></pre> 
<p>注意！你可以在 FLUX 语言中使用 duration 类型的变量与时间做运算，但是你不能在table 中创建 duration 类型的列。</p> 
<p><strong>duration</strong> 的算术运算：</p> 
<p>要对 duration 进行加法、减法、乘法或除法操作，需要按下面的步骤来。</p> 
<ol><li> <p>使用 int( )或 unit()将持续时间转换为int 数值</p> </li><li> <p>使用算术运算符进行运算</p> </li><li> <p>把运算的结果再转换回Duration 类型</p> </li></ol> 
<p>示例：</p> 
<pre><code class="prism language-sql">duration<span class="token punctuation">(</span>v: <span class="token keyword">int</span><span class="token punctuation">(</span>v: <span class="token number">6</span>h4m<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">int</span><span class="token punctuation">(</span>v: <span class="token number">22</span>h32s<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 返回 1d4h4m32s</span>
duration<span class="token punctuation">(</span>v: <span class="token keyword">int</span><span class="token punctuation">(</span>v: <span class="token number">22</span>h32s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">int</span><span class="token punctuation">(</span>v: <span class="token number">6</span>h4m<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 返回 15h56m32s</span>
duration<span class="token punctuation">(</span>v: <span class="token keyword">int</span><span class="token punctuation">(</span>v: <span class="token number">32</span>m10s<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment">// 返回 5h21m40s</span>
duration<span class="token punctuation">(</span>v: <span class="token keyword">int</span><span class="token punctuation">(</span>v: <span class="token number">24</span>h<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment">// 返回 12h</span>
</code></pre> 
<p>注意！声明持续时间的时候不要包含前导 0，前面的零会被 FLUX 识别为整数</p> 
<p><strong>时间和持续时间相加运算：</strong></p> 
<ol><li>导入 date 包</li><li>使用 date.add( )函数将持续时间和时间相加</li></ol> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"date"</span>
<span class="token keyword">date</span><span class="token punctuation">.</span><span class="token keyword">add</span><span class="token punctuation">(</span>d: <span class="token number">1</span>w<span class="token punctuation">,</span> <span class="token keyword">to</span>: <span class="token number">2021</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span>T00:<span class="token number">00</span>:<span class="token number">00</span>Z<span class="token punctuation">)</span>
<span class="token comment">// 2021-01-01 加上一周</span>
<span class="token comment">// Returns 2021-01-08T00:00:00.000000000Z</span>
</code></pre> 
<p><strong>时间和持续时间相减运算：</strong></p> 
<ol><li> <p>导入 date 包</p> </li><li> <p>使用 date.add( )函数从时间中减去持续时间</p> </li></ol> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"date"</span>
<span class="token keyword">date</span><span class="token punctuation">.</span>sub<span class="token punctuation">(</span>d: <span class="token number">1</span>w<span class="token punctuation">,</span> <span class="token keyword">from</span>: <span class="token number">2021</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span>T00:<span class="token number">00</span>:<span class="token number">00</span>Z<span class="token punctuation">)</span>
<span class="token comment">// 2021-01-01 减去一周</span>
<span class="token comment">// Returns 2020-12-25T00:00:00.000000000Z</span>
</code></pre> 
<h5><a id="Regular_expression__436"></a>Regular expression 正则表达式</h5> 
<p>（1）<strong>定义一个正则表达式</strong></p> 
<p>FLUX 语言是 GO 语言实现的，因此使用 GO 的正则表达式语法。正则表达式需要声明在正斜杠之间/ /</p> 
<p>（2）<strong>使用正则表达式进行逻辑判断</strong></p> 
<p>使用正则表达式进行逻辑判断，需要使用 =~ 和 != 操作符。=~ 的意思是左值（字符串）能够被右值匹配，!~表示左值（字符串）不能被右值匹配。</p> 
<pre><code class="prism language-bash"><span class="token string">"abc"</span> <span class="token operator">=~</span> /<span class="token punctuation">\</span>w/
// Returns <span class="token boolean">true</span>
<span class="token string">"z09se89"</span> <span class="token operator">=~</span> /^<span class="token punctuation">[</span>a-z0-9<span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token number">7</span><span class="token punctuation">}</span>$/
// Returns <span class="token boolean">true</span>
<span class="token string">"foo"</span> <span class="token operator">!</span>~ /^f/
// Returns <span class="token boolean">false</span>
<span class="token string">"FOO"</span> <span class="token operator">=~</span> /<span class="token punctuation">(</span>?i<span class="token punctuation">)</span>foo/
// Returns <span class="token boolean">true</span>
</code></pre> 
<p><strong>（3）将字符串转为正则表达式</strong></p> 
<ul><li>引入 regexp 包</li><li>使用 regexp.compile( ) 函数可以将字符串转为正则表达式</li></ul> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"regexp"</span>
<span class="token operator">regexp</span><span class="token punctuation">.</span>compile<span class="token punctuation">(</span>v: <span class="token string">"^- [a-z0-9]{7}"</span><span class="token punctuation">)</span>
<span class="token comment">// Returns ^- [a-z0-9]{7} (regexp type)</span>
</code></pre> 
<p><strong>（4）将匹配的子字符串全部替换</strong></p> 
<ul><li>引入 regexp 包</li><li>使用 regexp.replaceAllString( )函数，并提供下列参数： 
  <ul><li> <p>r：正则表达式</p> </li><li> <p>v：要搜索的字符串</p> </li><li> <p>t： 一旦匹配，就替换为该字符串</p> </li></ul> </li></ul> 
<p>示例：</p> 
<pre><code class="prism language-bash"><span class="token function">import</span> <span class="token string">"regexp"</span>
regexp.replaceAllString<span class="token punctuation">(</span>r: /a<span class="token punctuation">(</span>x*<span class="token punctuation">)</span>b/, v: <span class="token string">"-ab-axxb-"</span>, t: <span class="token string">"T"</span><span class="token punctuation">)</span>
// Returns <span class="token string">"-T-T-"</span>
</code></pre> 
<p><strong>（5）得到字符串中第一个匹配成功的结果</strong></p> 
<ul><li>导入 regexp 包</li><li>使用 regexp.findString( )来返回正则表达式匹配中的第一个字符串，需要传递以下参数： 
  <ul><li> <p>r：正则表达式</p> </li><li> <p>v：要进行匹配的字符串</p> </li></ul> </li></ul> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"regexp"</span>
<span class="token operator">regexp</span><span class="token punctuation">.</span>findString<span class="token punctuation">(</span>r:<span class="token string">"abc|bcd"</span><span class="token punctuation">,</span>v:<span class="token string">"xxabcwwed"</span><span class="token punctuation">)</span>
<span class="token comment">// Returns "abc"</span>
</code></pre> 
<h5><a id="String__505"></a>String 字符串</h5> 
<p><strong>（1）定义一个字符串</strong></p> 
<p>字符串类型表示一个字符序列。字符串是不可改变的，一旦创建就无法修改。</p> 
<p>字符串是一个由双引号括起来的字符序列，在 FLUX 中，还支持你用\x 作为前缀的十六进制编码来声明字符串。</p> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token string">"abc"</span>
<span class="token string">"string with double \" quote"</span>
<span class="token string">"string with backslash \\"</span> 
<span class="token string">"日本語"</span> 
<span class="token string">"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"</span>
</code></pre> 
<p><strong>（2）将其他基本数据类型转换为字符串</strong></p> 
<p>使用 srting( )函数可以将下述基本类型转换为字符串：</p> 
<ul><li> <p>boolean 布尔值</p> </li><li> <p>bytes 字节序列</p> </li><li> <p>duration 持续时间</p> </li><li> <p>float 浮点数</p> </li><li> <p>uint 无符号整数</p> </li><li> <p>time 时间</p> </li></ul> 
<pre><code class="prism language-bash">string<span class="token punctuation">(</span>v: <span class="token number">42</span><span class="token punctuation">)</span>
// 返回 <span class="token string">"42"</span>
</code></pre> 
<p>使用 display( )函数可以将任何类型的值输出为相应的字符串类型。示例：</p> 
<pre><code class="prism language-sql">x <span class="token operator">=</span> bytes<span class="token punctuation">(</span>v: <span class="token string">"foo"</span><span class="token punctuation">)</span>
display<span class="token punctuation">(</span>v: x<span class="token punctuation">)</span>
<span class="token comment">// Returns "0x666f6f"</span>
</code></pre> 
<p><strong>（3）将正则表达式转换为字符串</strong></p> 
<p>因为正则表达式也是一个基本数据类型，所以正则表达式也可以转换为字符串，但是需要借助额外的包。</p> 
<ol><li> <p>引入 regexp 包</p> </li><li> <p>使用 regexp.compile( )</p> </li></ol> 
<h5><a id="Time__566"></a>Time 时间点</h5> 
<p><strong>（1）定义一个时间点</strong></p> 
<p>一个 time 类型的变量其实是一个纳秒精度的时间点。</p> 
<p>示例：时间点必须使用RFC3339 的时间格式进行声明：</p> 
<pre><code class="prism language-bash">YYYY-MM-DD
YYYY-MM-DDT00:00:00Z
YYYY-MM-DDT00:00:00.000Z
</code></pre> 
<p>（2）<strong>date</strong> 包</p> 
<p>date 包里的函数主要是用来从Time 类型的值里提取年月日秒等信息的。比如 date.hour：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"date"</span>
x <span class="token operator">=</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span>T19:<span class="token number">22</span>:<span class="token number">31</span>Z
<span class="token keyword">date</span><span class="token punctuation">.</span><span class="token keyword">hour</span><span class="token punctuation">(</span>t:x<span class="token punctuation">)</span>
<span class="token comment">//Returns 19</span>
</code></pre> 
<h5><a id="Float__595"></a>Float 浮点数</h5> 
<p><strong>（1）定义一个浮点数</strong></p> 
<p>FLUX 中的浮点数是 64 位的浮点数。</p> 
<p>一个浮点数包含整数位，小数点，和小数位。示例：</p> 
<pre><code class="prism language-bash"><span class="token number">0.0</span>
<span class="token number">123.4</span>
-123.456
</code></pre> 
<p><strong>（2）科学计数法</strong></p> 
<p>FLUX 没有直接提供科学计数法语法，但是你可以使用字符换写出一个科学计数法表示的浮点数，再使用float( )函数将该字符串转换为浮点数。</p> 
<p>示例：</p> 
<pre><code class="prism language-bash"><span class="token number">1</span>.23456e+78
// Error: error @1:8-1:9: undefined identifier e
float<span class="token punctuation">(</span>v: <span class="token string">"1.23456e+78"</span><span class="token punctuation">)</span>
// Returns <span class="token number">1</span>.23456e+78 <span class="token punctuation">(</span>float<span class="token punctuation">)</span>
</code></pre> 
<p><strong>（3）无限</strong></p> 
<p>FLUX 也没有提供关于无限的语法，定义无限要使用字符串与 float( )函数结合的方式。示例：</p> 
<pre><code class="prism language-bash">+Inf
// Error: error @1:2-1:5: undefined identifier Inf
float<span class="token punctuation">(</span>v: <span class="token string">"+Inf"</span><span class="token punctuation">)</span>
// Returns +Inf <span class="token punctuation">(</span>float<span class="token punctuation">)</span>
</code></pre> 
<p>（4）<strong>Not a Number</strong> 非数字</p> 
<p>FLUX 语言不支持直接从语法上声明 NAN，但是你可以使用字符串与 float( )函数的方法声明一个NaN 的 float 类型变量。</p> 
<p>示例：</p> 
<pre><code class="prism language-bash">NaN
// Error: error @1:2-1:5: undefined identifier NaN
float<span class="token punctuation">(</span>v: <span class="token string">"NaN"</span><span class="token punctuation">)</span>
// Returns NaN <span class="token punctuation">(</span>float<span class="token punctuation">)</span>
</code></pre> 
<p>（5）<strong>将其他基本类型转换为 float</strong></p> 
<p>使用 float 函数可以将基本数据类型转换为 float 类型的值。</p> 
<ul><li>string：必须得是一个符合数字格式的字符串或者科学计数法。</li><li>bool：true 转换为 1.0，false 转换为 0.0</li><li>int（整数）</li><li>uint（无符号整数）</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-bash">float<span class="token punctuation">(</span>v: <span class="token string">"1.23"</span><span class="token punctuation">)</span>
// <span class="token number">1.23</span>
float<span class="token punctuation">(</span>v: <span class="token boolean">true</span><span class="token punctuation">)</span>
// Returns <span class="token number">1.0</span>
float<span class="token punctuation">(</span>v: <span class="token number">123</span><span class="token punctuation">)</span>
// Returns <span class="token number">123.0</span>
</code></pre> 
<p><strong>（6）对浮点数进行逻辑判断</strong></p> 
<p>使用 FLUX 表达式来比较浮点数。逻辑表达式两侧必须是同一种类型。示例：</p> 
<pre><code class="prism language-sql"><span class="token number">12345600.0</span> <span class="token operator">=</span><span class="token operator">=</span> <span class="token keyword">float</span><span class="token punctuation">(</span>v: <span class="token string">"1.23456e+07"</span><span class="token punctuation">)</span>
<span class="token comment">// Returns true</span>
<span class="token number">1.2</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">2.1</span>
<span class="token comment">// Returns true</span>
</code></pre> 
<h5><a id="Integer__689"></a>Integer 整数</h5> 
<p><strong>（1）定义一个整数</strong></p> 
<p>一个 integer 的变量是一个 64 位有符号的整数。</p> 
<ul><li>类型名称：int</li><li>最小值：<strong>-9223372036854775808</strong></li><li>最大值：<strong>9223372036854775807</strong></li></ul> 
<p>一个整数的声明就是普通的整数写法，前面可以加- 表示负数。-0 和 0 是等效的。示例：</p> 
<pre><code class="prism language-bash">02
<span class="token number">1254</span>
-1254
</code></pre> 
<p><strong>（2）将数据类型转换为整数</strong></p> 
<p>使用 int( )函数可以将下述的基本类型转换为整数：</p> 
<ul><li>string：字符串必须符合整数格式，由数字[0-9]组成</li><li>bool：true 返回 1，0 返回 false</li><li>duration：返回持续时间的纳秒数</li><li>time：返回时间点对应的 Unix 时间戳纳秒数</li><li>float：返回小数点前的整数部分，也就是截断</li><li>unit：返回等效于无符号整数的整数，如果超出范围，就会发生整数环绕</li></ul> 
<pre><code class="prism language-sql"><span class="token keyword">int</span><span class="token punctuation">(</span>v: <span class="token string">"123"</span><span class="token punctuation">)</span>
<span class="token comment">// 123</span>
<span class="token keyword">int</span><span class="token punctuation">(</span>v: <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token comment">// Returns 1</span>
<span class="token keyword">int</span><span class="token punctuation">(</span>v: <span class="token number">1</span>d3h24m<span class="token punctuation">)</span>
<span class="token comment">// Returns 98640000000000</span>
<span class="token keyword">int</span><span class="token punctuation">(</span>v: <span class="token number">2021</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span>T00:<span class="token number">00</span>:<span class="token number">00</span>Z<span class="token punctuation">)</span>
<span class="token comment">// Returns 1609459200000000000</span>
<span class="token keyword">int</span><span class="token punctuation">(</span>v: <span class="token number">12.54</span><span class="token punctuation">)</span>
<span class="token comment">// Returns 12</span>
</code></pre> 
<p>你可以在将浮点数转换为整数之前进行舍入操作。</p> 
<p>当你将浮点数转换为整数时，会进行截断操作。如果你想进行四舍五入，可以使用math 包中的 round( )函数。</p> 
<p><strong>（3）将表示十六进制数字的字符串转换为整数</strong></p> 
<p>将表示十六进制数字的字符串转换为整数，需要。</p> 
<ol><li> <p>引入 contrib/bonito-io/hex 包</p> </li><li> <p>使用 hex.int( )函数将表示十六进制数字的字符串转换为整数</p> </li></ol> 
<pre><code class="prism language-bash"><span class="token function">import</span> <span class="token string">"contrib/bonitoo-io/hex"</span>
hex.int<span class="token punctuation">(</span>v: <span class="token string">"e240"</span><span class="token punctuation">)</span>
// Returns <span class="token number">123456</span>
</code></pre> 
<h5><a id="UIntegers__752"></a>UIntegers 无符号整数</h5> 
<p>FLUX 语言里不能直接声明无符号整数，但这却是一个 InfluxDB 中具备的类型。在FLUX 语言中，我们需要使用 uint 函数来讲字符串、整数或者其他数据类型转换成无符号整数。</p> 
<p>示例：</p> 
<pre><code class="prism language-sql">uint<span class="token punctuation">(</span>v: <span class="token string">"123"</span><span class="token punctuation">)</span>
<span class="token comment">// 123</span>
uint<span class="token punctuation">(</span>v: <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token comment">// Returns 1</span>
uint<span class="token punctuation">(</span>v: <span class="token number">1</span>d3h24m<span class="token punctuation">)</span>
<span class="token comment">// Returns 98640000000000</span>
uint<span class="token punctuation">(</span>v: <span class="token number">2021</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span>T00:<span class="token number">00</span>:<span class="token number">00</span>Z<span class="token punctuation">)</span>
<span class="token comment">// Returns 1609459200000000000</span>
uint<span class="token punctuation">(</span>v: <span class="token number">12.54</span><span class="token punctuation">)</span>
<span class="token comment">// Returns 12</span>
uint<span class="token punctuation">(</span>v: <span class="token operator">-</span><span class="token number">54321</span><span class="token punctuation">)</span>
<span class="token comment">// Returns 18446744073709497295</span>
</code></pre> 
<h5><a id="Null__775"></a>Null 空值</h5> 
<p>（1）定义一个 <strong>Null</strong> 值</p> 
<p>FLUX 语言并不能在语法上直接支持声明一个 Null，但是我们可以通过 debug.null 这个函数来声明一个指定类型的空值。</p> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"internal/debug"</span>
<span class="token comment">// Return a null string</span>
debug<span class="token punctuation">.</span><span class="token boolean">null</span><span class="token punctuation">(</span><span class="token keyword">type</span>: <span class="token string">"string"</span><span class="token punctuation">)</span>
<span class="token comment">// Return a null integer</span>
debug<span class="token punctuation">.</span><span class="token boolean">null</span><span class="token punctuation">(</span><span class="token keyword">type</span>: <span class="token string">"int"</span><span class="token punctuation">)</span>
<span class="token comment">// Return a null boolean</span>
debug<span class="token punctuation">.</span><span class="token boolean">null</span><span class="token punctuation">(</span><span class="token keyword">type</span>: <span class="token string">"bool"</span><span class="token punctuation">)</span>
</code></pre> 
<p>（2）定义一个 <strong>null</strong></p> 
<p>截至目前，还无法在 FLUX 语言中手动地声明一个NULL 值。</p> 
<p>注意！空字符串不是 null 值。</p> 
<p>（3）判断值是否为 <strong>null</strong></p> 
<p>你可以使用 exists（存在）这个关键字来判断目标值是不是非空，如果是空值我们会得到一个 false，如果不是空值我们会得到一个 true。</p> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"array"</span>
<span class="token keyword">import</span> <span class="token string">"internal/debug"</span>
x <span class="token operator">=</span> debug<span class="token punctuation">.</span><span class="token boolean">null</span><span class="token punctuation">(</span><span class="token keyword">type</span>: <span class="token string">"string"</span><span class="token punctuation">)</span>
y <span class="token operator">=</span> <span class="token keyword">exists</span> x
<span class="token comment">// Returns false</span>
</code></pre> 
<h4><a id="FLUX__InfluxDB__821"></a>FLUX 类型不代表 InfluxDB 类型</h4> 
<p>需要注意，FLUX 语言里有些基本数据类型比如持续时间(Duration)和正则表达式是不能放在表流里面充当字段类型的。简单来说，Duration 类型和正则表达式类型都是 FLUX 语言特有的。有些类型是为了让 FLUX 在编写代码时更加方便，让它能够拥有更多的特性， 但这并不代表这些类型能够存储到 InfluxDB 中。</p> 
<h4><a id="4__827"></a>4 个复合类型</h4> 
<h5><a id="Record_829"></a>Record（记录）</h5> 
<p>（1）定义一个 <strong>Record</strong></p> 
<p>一个记录是一堆键值对的集合，其中键必须是字符串，值可以是任意类型，在键上没有空白字符的前提下，键上的双引号可以省略。</p> 
<p>在语法上，record 需要使用{}声明，键值对之间使用英文逗号（,）分开。另外，一个Record 的内容可以为空，也就是里面没有键值对。</p> 
<p>示例：0</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>foo: <span class="token string">"bar"</span>, baz: <span class="token number">123.4</span>, quz: -2<span class="token punctuation">}</span>
<span class="token punctuation">{<!-- --></span><span class="token string">"Company Name"</span><span class="token builtin class-name">:</span> <span class="token string">"ACME"</span>, <span class="token string">"Street Address"</span><span class="token builtin class-name">:</span> <span class="token string">"123 Main St."</span>, id: <span class="token number">1123445</span><span class="token punctuation">}</span>
</code></pre> 
<p>（2）从 <strong>record</strong> 中取值</p> 
<ul><li> <p>点表示法取值</p> <p>如果 key 中没有空白字符，那么你可以使用 .key 的方式从 record 中取值。示例：</p> <pre><code class="prism language-bash">c <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>name: <span class="token string">"John Doe"</span>, address: <span class="token string">"123 Main St."</span>, id: <span class="token number">1123445</span><span class="token punctuation">}</span>
c.name
// Returns John Doe
c.id
// Returns <span class="token number">1123445</span>
</code></pre> </li><li> <p>中括号方式取值</p> <p>可以使用[" "]的方式取值，当 key 中有空白字符的时候，也只能用这种方式来取值。</p> <pre><code class="prism language-sql">c <span class="token operator">=</span> {<!-- --><span class="token string">"Company Name"</span>: <span class="token string">"ACME"</span><span class="token punctuation">,</span> <span class="token string">"Street Address"</span>: <span class="token string">"123 Main St."</span><span class="token punctuation">,</span> id: 
<span class="token number">1123445</span>}
c<span class="token punctuation">[</span><span class="token string">"Company Name"</span><span class="token punctuation">]</span>
<span class="token comment">// Returns ACME</span>
c<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span>
<span class="token comment">// Returns 1123445</span>
</code></pre> </li></ul> 
<p><strong>（3）嵌套与链式取值</strong></p> 
<p>Record 类型可以进行嵌套引用。</p> 
<p>从嵌套的 Record 中引用值的时候可以采用链式调用的方式。链式调用时，点表示法和中括号还可以混用。</p> 
<pre><code class="prism language-sql">customer <span class="token operator">=</span> 
 {
     name: <span class="token string">"John Doe"</span><span class="token punctuation">,</span>
     address: {
         street: <span class="token string">"123 Main St."</span><span class="token punctuation">,</span>
         city: <span class="token string">"Pleasantville"</span><span class="token punctuation">,</span>
         state: <span class="token string">"New York"</span>
	 }
 }
customer<span class="token punctuation">.</span>address<span class="token punctuation">.</span>street
<span class="token comment">// Returns 123 Main St.</span>
customer<span class="token punctuation">[</span><span class="token string">"address"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"city"</span><span class="token punctuation">]</span>
<span class="token comment">// Returns Pleasantville</span>
customer<span class="token punctuation">[</span><span class="token string">"address"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>state
<span class="token comment">// Returns New York</span>
</code></pre> 
<p>（4）<strong>record</strong> 的 <strong>key</strong> 是静态的</p> 
<p>record 类型变量中的 key 是静态的，一旦声明，其中的 key 就被定死了。一旦你访问这个 record 中一个没有的key，就会直接抛出异常。正常的话应该返回null。</p> 
<pre><code class="prism language-sql">o <span class="token operator">=</span> {foo: <span class="token string">"bar"</span><span class="token punctuation">,</span> baz: <span class="token number">123.4</span>}
o<span class="token punctuation">.</span><span class="token keyword">key</span>
<span class="token comment">// Error: type error: record is missing label haha</span>
<span class="token comment">// 错误：类型错误：record 找不到 haha 这个标签</span>
</code></pre> 
<p>（5）操作 <strong>records</strong></p> 
<p>使用 with 操作符可以拓展一个 record，当原始的 record 中有这个 key 时，原先 record 的值会被覆盖；如果原先的 record 中没有制定的 key，那么会将旧 record 中的所有元素和with 中指定的元素复制到一个新的 record 中。</p> 
<p>示例： 覆盖原先的值，并添加一个 key 为 pet，value 为"Spot"的元素。</p> 
<pre><code class="prism language-sql">c <span class="token operator">=</span> {name: <span class="token string">"John Doe"</span><span class="token punctuation">,</span> id: <span class="token number">1123445</span>}
{c <span class="token keyword">with</span> name: <span class="token string">"Xiao Ming"</span><span class="token punctuation">,</span> pet: <span class="token string">"Spot"</span>}
<span class="token comment">// Returns {id: 1123445, name: Xiao Ming, pet: Spot}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1a/99/W752DYgi_o.png" alt="MMSIZE"></p> 
<p>（6）<strong>列出一个 record 中所有的 keys</strong></p> 
<ol><li> <p>导入 experimental（实验的）包。</p> </li><li> <p>使用 expertimental.objectyKeys(o:c)方法来拿到一个 record 的所有key。</p> </li></ol> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"experimental"</span>
c <span class="token operator">=</span> {name: <span class="token string">"John Doe"</span><span class="token punctuation">,</span> id: <span class="token number">1123445</span>}
experimental<span class="token punctuation">.</span>objectKeys<span class="token punctuation">(</span>o: c<span class="token punctuation">)</span>
<span class="token comment">// Returns [name, id]</span>
</code></pre> 
<p>（7）<strong>比较两个 record 是否相等</strong></p> 
<p>可以使用双等号= =来判断两个 record 是否相等。如果两个 record 的每个 key，每个key 对应的 value 和类型都相同，那么两个 record 就相等。示例：</p> 
<pre><code class="prism language-sql">{id: <span class="token number">1</span><span class="token punctuation">,</span> msg: <span class="token string">"hello"</span>} <span class="token operator">=</span><span class="token operator">=</span> {id: <span class="token number">1</span><span class="token punctuation">,</span> msg: <span class="token string">"goodbye"</span>}
<span class="token comment">// Returns false</span>
{foo: <span class="token number">12300.0</span><span class="token punctuation">,</span> bar: <span class="token number">34500.0</span>} <span class="token operator">=</span><span class="token operator">=</span> {bar: <span class="token keyword">float</span><span class="token punctuation">(</span>v: <span class="token string">"3.45e+04"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> foo: 
<span class="token keyword">float</span><span class="token punctuation">(</span>v: <span class="token string">"1.23e+04"</span><span class="token punctuation">)</span>}
<span class="token comment">// Returns true</span>
</code></pre> 
<p>（8）<strong>将 record 转为字符串</strong></p> 
<p>使用 display( )函数可以将 record 转为字符串。示例：</p> 
<pre><code class="prism language-sql">x <span class="token operator">=</span> {a: <span class="token number">1</span><span class="token punctuation">,</span> b: <span class="token number">2</span><span class="token punctuation">,</span> c: <span class="token number">3</span>}
display<span class="token punctuation">(</span>v: x<span class="token punctuation">)</span>
<span class="token comment">// Returns "{a: 1, b: 2, c: 3}"</span>
</code></pre> 
<p><strong>（9）嵌套 Record 的意义</strong></p> 
<p>注意，嵌套的 Record 无法放到 FLUX 语言返回的表流中，这个时候会发生类型错误， 它会说 Record 类型不能充当某一列的类型。那 FLUX 为什么还支持对 Record 进行嵌套使用呢？</p> 
<p>其实这是为了一些网络通讯的功能来服务，在 FLUX 语言中我们有一个 http 库。借助这个函数库，我们可以向外发送 http post 请求，而这种时候我们就有可能要发送嵌套的json。细心的同学可能发现，我们的 record 在语法层面上和 json 语法是统一的，而且FLUX 语言提供了一个 json 函数库，借助这个库中的 encode 函数，我们可以轻易地将一个record 转为 json 字符串然后发送出去。</p> 
<h5><a id="Array_980"></a>Array（数组）</h5> 
<p><strong>（1）定义一个 Array</strong></p> 
<p>数据是一个由相同类型的值构成的有序序列。</p> 
<p>在语法上，数组是用方括号[ ]起来的一堆同类型元素，元素之间用英文逗号( , )分隔， 并且类型必须相同。</p> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token punctuation">[</span><span class="token string">"1st"</span><span class="token punctuation">,</span> <span class="token string">"2nd"</span><span class="token punctuation">,</span> <span class="token string">"3rd"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1.23</span><span class="token punctuation">,</span> <span class="token number">4.56</span><span class="token punctuation">,</span> <span class="token number">7.89</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">15</span><span class="token punctuation">]</span>
</code></pre> 
<p><strong>（2）从 Array 中取值</strong></p> 
<p>可以使用中括号[ ] 加索引的方式从数组中取值，数组索引从 0 开始。示例：</p> 
<pre><code class="prism language-bash">arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"one"</span>, <span class="token string">"two"</span>, <span class="token string">"three"</span><span class="token punctuation">]</span>
arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
// Returns one
arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
// Returns two
</code></pre> 
<p><strong>（3）遍历一个数组</strong></p> 
<p><strong>（4）检查一个数组中是否包含某元素</strong></p> 
<p>示例：使用 contains( )函数可以检查一个数组中是否包含某个元素。</p> 
<pre><code class="prism language-sql">names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"Jane"</span><span class="token punctuation">,</span> <span class="token string">"Joe"</span><span class="token punctuation">,</span> <span class="token string">"Sam"</span><span class="token punctuation">]</span>
<span class="token keyword">contains</span><span class="token punctuation">(</span><span class="token keyword">value</span>: <span class="token string">"Joe"</span><span class="token punctuation">,</span> <span class="token keyword">set</span>: names<span class="token punctuation">)</span>
<span class="token comment">// Returns true</span>
</code></pre> 
<h5><a id="Dictionary_1026"></a>Dictionary（字典）</h5> 
<p><strong>（1）定义一个字典</strong></p> 
<p>字典和记录很像，但是 key-value 上的要求有所不同。</p> 
<p>一个字典是一堆键值对的集合，其中所有键的类型必须相同，且所有值的的类型必须相同。</p> 
<p>在语法上，dictionary 需要使用方括号[ ]声明，键的后面跟冒号（:）键值对之间需要使用英文逗号（ , ）分隔。</p> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token punctuation">[</span><span class="token number">0</span>: <span class="token string">"Sun"</span><span class="token punctuation">,</span> <span class="token number">1</span>: <span class="token string">"Mon"</span><span class="token punctuation">,</span> <span class="token number">2</span>: <span class="token string">"Tue"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"red"</span>: <span class="token string">"#FF0000"</span><span class="token punctuation">,</span> <span class="token string">"green"</span>: <span class="token string">"#00FF00"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span>: <span class="token string">"#0000FF"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1.0</span>: {stable: <span class="token number">12</span><span class="token punctuation">,</span> latest: <span class="token number">12</span>}<span class="token punctuation">,</span> <span class="token number">1.1</span>: {stable: <span class="token number">3</span><span class="token punctuation">,</span> latest: <span class="token number">15</span>}<span class="token punctuation">]</span>
</code></pre> 
<p><strong>（2）引用字典中的值</strong></p> 
<ol><li> <p>导入 dict 包</p> </li><li> <p>使用 dict.get( )并提供下述参数:</p> <p><strong>dict</strong>：要取值的字典</p> <p><strong>key</strong>：要用到的 key</p> <p><strong>default</strong>：默认值，如果对应的 key 不存在就返回该值</p> </li></ol> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"dict"</span>
positions <span class="token operator">=</span>
 <span class="token punctuation">[</span>
     <span class="token string">"Manager"</span>: <span class="token string">"Jane Doe"</span><span class="token punctuation">,</span>
     <span class="token string">"Asst. Manager"</span>: <span class="token string">"Jack Smith"</span><span class="token punctuation">,</span>
     <span class="token string">"Clerk"</span>: <span class="token string">"John Doe"</span><span class="token punctuation">,</span>
 <span class="token punctuation">]</span>
dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span>dict: positions<span class="token punctuation">,</span> <span class="token keyword">key</span>: <span class="token string">"Manager"</span><span class="token punctuation">,</span> <span class="token keyword">default</span>: <span class="token string">"Unknown position"</span><span class="token punctuation">)</span>
<span class="token comment">// Returns Jane Doe</span>
dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span>dict: positions<span class="token punctuation">,</span> <span class="token keyword">key</span>: <span class="token string">"Teller"</span><span class="token punctuation">,</span> <span class="token keyword">default</span>: <span class="token string">"Unknown position"</span><span class="token punctuation">)</span>
<span class="token comment">// Returns Unknown position</span>
</code></pre> 
<p><strong>（3）从列表创建字典</strong></p> 
<ol><li> <p>导入 dict 包</p> </li><li> <p>使用 dict.fromList( )函数从一个由 records 组成的数组中创建字典。其中，数组中的每个 record 必须是{key:xxx,value:xxx}形式</p> </li></ol> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"dict"</span>
list <span class="token operator">=</span> <span class="token punctuation">[</span>{<!-- --><span class="token keyword">key</span>: <span class="token string">"k1"</span><span class="token punctuation">,</span> <span class="token keyword">value</span>: <span class="token string">"v1"</span>}<span class="token punctuation">,</span> {<!-- --><span class="token keyword">key</span>: <span class="token string">"k2"</span><span class="token punctuation">,</span> <span class="token keyword">value</span>: <span class="token string">"v2"</span>}<span class="token punctuation">]</span>
dict<span class="token punctuation">.</span>fromList<span class="token punctuation">(</span>pairs: list<span class="token punctuation">)</span>
<span class="token comment">// Returns [k1: v1, k2: v2]</span>
</code></pre> 
<p><strong>（4）向字典中插入键值对</strong></p> 
<ol><li> <p>导入 dict 包</p> </li><li> <p>使用 dict.insert( )函数添加一个新的键值对，如果 key 早就存在，那么就会覆盖这个 key 对应的value。</p> </li></ol> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"dict"</span>
exampleDict <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"k1"</span>: <span class="token string">"v1"</span><span class="token punctuation">,</span> <span class="token string">"k2"</span>: <span class="token string">"v2"</span><span class="token punctuation">]</span>
dict<span class="token punctuation">.</span><span class="token keyword">insert</span><span class="token punctuation">(</span>dict: exampleDict<span class="token punctuation">,</span> <span class="token keyword">key</span>: <span class="token string">"k3"</span><span class="token punctuation">,</span> <span class="token keyword">value</span>: <span class="token string">"v3"</span><span class="token punctuation">)</span>
<span class="token comment">// Returns [k1: v1, k2: v2, k3: v3]</span>
</code></pre> 
<p><strong>（5）从字典中移除键值对</strong></p> 
<ol><li> <p>引入 dict 包</p> </li><li> <p>使用 dict.remove 方法从字典中删除一个键值对</p> </li></ol> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"dict"</span>
exampleDict <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"k1"</span>: <span class="token string">"v1"</span><span class="token punctuation">,</span> <span class="token string">"k2"</span>: <span class="token string">"v2"</span><span class="token punctuation">]</span>
dict<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>dict: exampleDict<span class="token punctuation">,</span> <span class="token keyword">key</span>: <span class="token string">"k2"</span><span class="token punctuation">)</span>
<span class="token comment">// Returns [k1: v1]</span>
</code></pre> 
<h5><a id="function_1124"></a>function（函数）</h5> 
<p><strong>（1）声明一个函数</strong></p> 
<p>一个函数是使用一组参数来执行操作的代码块。函数可以是命名的，也可以是匿名的。在小括号( )中声明参数，并使用箭头=\将参数传递到代码块中。</p> 
<p>示例：</p> 
<pre><code class="prism language-sql">square <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> n <span class="token operator">*</span> n
square<span class="token punctuation">(</span>n:<span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment">// Returns 9</span>
</code></pre> 
<p>FLUX 不支持位置参数。调用函数时，必须显示指定参数名称。</p> 
<p><strong>（2）为函数提供默认值</strong></p> 
<p>我们可以为某些函数指定默认值，如果为函数指定了默认值，也就意味着在调用这个函数时，有默认值的函数时非必须的。</p> 
<p>示例：</p> 
<pre><code class="prism language-sql">chengfa <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> a<span class="token operator">*</span> b
chengfa<span class="token punctuation">(</span>a:<span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment">// Returns 300</span>
</code></pre> 
<h4><a id="_1154"></a>函数包</h4> 
<p>Flux 的标准库使用包组织起来的。包将 Flux 的众多函数分门别类，默认情况下加载universe 包，这个包中的函数可以不用 import 直接使用。其他包的函数需要在你的 Flux 脚本中先用 import 语法导入一下。</p> 
<p>示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"array"</span>
<span class="token keyword">import</span> <span class="token string">"math"</span>
<span class="token keyword">import</span> <span class="token string">"influxdata/influxdb/sample"</span>
</code></pre> 
<p>但是，截至目前，虽然你可以自定义函数，但是你无法自定义包。如果希望将自己的自定义函数封装在一个包里以供复用，那就必须从源码上进行修改。</p> 
<p>这是 FLUX 语言的文档 https://docs.influxdata.com/flux/v0.x/ ，通常来说我们使用FLUX 的文档主要是用它来查看一些函数怎么用。</p> 
<h3><a id="FLUX__InfluxDB_1174"></a>FLUX 查询 InfluxDB</h3> 
<h4><a id="FLUX_InfluxDB__1176"></a>FLUX 查询InfluxDB 的语法</h4> 
<p>使用 FLUX 语言查询 InfluxDB，必须以 from -\ range 打头。例如：</p> 
<pre><code class="prism language-sql"><span class="token keyword">from</span><span class="token punctuation">(</span>bucket: <span class="token string">"test_init"</span><span class="token punctuation">)</span>
 <span class="token operator">|</span><span class="token operator">&gt;</span> range<span class="token punctuation">(</span><span class="token keyword">start</span>: <span class="token operator">-</span><span class="token number">1</span>h<span class="token punctuation">)</span>
</code></pre> 
<p>range 必须紧跟在 from 后面，不这么写的话会直接报错。</p> 
<h4><a id="_1189"></a>表、表流以及序列</h4> 
<p>我们知道 InfluxDB 是使用序列的方式去管理数据的。而 FLUX 语言又企图兼容一些关系型数据库的查询，而关系型数据库里的数据结构就是一个有行有列的 table。因此对于FLUX 语言来说，就需要将序列和表统一成一个东西。</p> 
<p>所以 FLUX 引入了表流的概念。</p> 
<p>简单来说，FLUX 可以一次性查出多个序列，这个时候一个序列对应一张表，而表流其实就是多张表的集合。同时表流和表的关系其实是全表和子表的关系，子表是全表按照_field，tag_set 和_measurement 进行 group by 之后的结果。在这种情况下，如果调用聚合函数，其实只会在子表中进行聚合。</p> 
<p>最后，如果一张表对应的是一个序列了，那么一张表里的一行其实就对应着序列中的一个数据点了。</p> 
<h4><a id="filter__1201"></a>filter 维度过滤</h4> 
<p>使用 filert 函数可以对数据按照_measurement、标签集和字段级进行过滤。</p> 
<h4><a id="_1207"></a>类型转换函数与下划线字段</h4> 
<p>Flux 语言中有很多不用指定字段名称的管道函数，比如 toInt()。其实 toInt()这个函数默认要求你的字段中必须要有_value 字段，没有_value 字段的话也会直接报错。</p> 
<p>其实在我们查询出来的数据中，以下划线开头的字段其实代表了一种约定，就是FLUX 中有很多函数想要正常运行时要依赖于这些下划线打头的字段的。</p> 
<p>所以原则上来说，程序员应该遵守这些约定，不要擅自更改下划线开头的字段。</p> 
<h4><a id="map__1217"></a>map 函数</h4> 
<p>map 函数的作用是遍历表流中的每一条数据。示例：</p> 
<pre><code class="prism language-sql"><span class="token keyword">import</span> <span class="token string">"array"</span>
array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">rows</span>: <span class="token punctuation">[</span>{<!-- --><span class="token string">"name"</span>:<span class="token string">"tony"</span>}<span class="token punctuation">,</span>{<!-- --><span class="token string">"name"</span>:<span class="token string">"jack"</span>}<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token operator">|</span><span class="token operator">&gt;</span> map<span class="token punctuation">(</span>fn: <span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span> {
		<span class="token keyword">return</span> <span class="token keyword">if</span> r<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">=</span> <span class="token string">"tony"</span> <span class="token keyword">then</span> {<!-- --><span class="token string">"_name"</span>: <span class="token string">"tony 不是jack"</span>} <span class="token keyword">else</span> {<!-- --><span class="token string">"_name"</span>:<span class="token string">"jack 不是 tony"</span>}
}<span class="token punctuation">)</span>
</code></pre> 
<p>这里需要注意，map 函数需要我们传递一个参数 fn，它要求传递一个单个参数输入， 且输出必须是record 的函数，其中输入数据的类型会是 record。</p> 
<h4><a id="_1233"></a>自定义管道函数</h4> 
<p>此处，我们定义一个管道函数，它可以将表流中的_value 字段的值乘上 x 倍。</p> 
<pre><code class="prism language-sql">big100 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">table</span><span class="token operator">=</span><span class="token operator">&lt;</span><span class="token operator">-</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> {
	<span class="token keyword">return</span> <span class="token keyword">table</span>
		<span class="token operator">|</span><span class="token operator">&gt;</span> map<span class="token punctuation">(</span>fn: <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>{r <span class="token keyword">with</span> <span class="token string">"_value"</span>:r<span class="token punctuation">[</span><span class="token string">"_value"</span><span class="token punctuation">]</span><span class="token operator">*</span>x}<span class="token punctuation">)</span><span class="token punctuation">)</span> 
}
</code></pre> 
<p>接下来我们调用刚才声明的函数，最终整个脚本如下:</p> 
<pre><code class="prism language-sql">big100 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">table</span><span class="token operator">=</span><span class="token operator">&lt;</span><span class="token operator">-</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> {
	<span class="token keyword">return</span> <span class="token keyword">table</span>
		<span class="token operator">|</span><span class="token operator">&gt;</span> map<span class="token punctuation">(</span>fn: <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>{r <span class="token keyword">with</span> <span class="token string">"_value"</span>:r<span class="token punctuation">[</span><span class="token string">"_value"</span><span class="token punctuation">]</span><span class="token operator">*</span>x}<span class="token punctuation">)</span><span class="token punctuation">)</span>
}
<span class="token keyword">from</span><span class="token punctuation">(</span>bucket: <span class="token string">"test_init"</span><span class="token punctuation">)</span>
    <span class="token operator">|</span><span class="token operator">&gt;</span> range<span class="token punctuation">(</span><span class="token keyword">start</span>: <span class="token operator">-</span><span class="token number">1</span>h<span class="token punctuation">)</span>
    <span class="token operator">|</span><span class="token operator">&gt;</span> filter<span class="token punctuation">(</span>fn: <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> r<span class="token punctuation">[</span><span class="token string">"_measurement"</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">=</span> <span class="token string">"go_goroutines"</span><span class="token punctuation">)</span>
    <span class="token operator">|</span><span class="token operator">&gt;</span> big100<span class="token punctuation">(</span>x:<span class="token number">100</span><span class="token punctuation">)</span>
</code></pre> 
<p>可以自行运行查看函数效果。</p> 
<p>这里需要强调的是，管道函数的第一个参数必须写成 table=&lt;-，它表示通过管道符输入进来的表流数据，需要注意，table 并不一定写成table 但是=&lt;-的格式绝对不能变。</p> 
<h4><a id="_1263"></a>在文档中区分管道函数和普通函数</h4> 
<p>再次来到函数文档。</p> 
<p><img src="https://images2.imgbox.com/ef/53/IAWIEhUW_o.png" alt="MMSIZE"></p> 
<p>当我们看到一个函数文档，它会有一个区域叫做 Function type Signature（函数签名），它表示着函数接收哪些参数以及会返回什么。最前面的小括号里的内容就是参数列表，如果参数列表的第一个参数是&lt;-tables: stream[A]，那就表示它是一个可以接收表流输入的管道函数。</p> 
<p>反之，如果没有&lt;-tables: stream[A]，那么它就是一个普通函数。</p> 
<h4><a id="window__aggregateWindow__1275"></a>window 和 aggregateWindow 函数</h4> 
<p>window 函数和 aggregateWindow 函数其实代表着 InfluxDB 中的两种开窗方式，两者不同的地方在于，window 函数会将整个表流重新分组。window 开窗后，是按照序列+窗口的方式对整个表流进行分组。但是 aggregateWindow 函数会保留原来的分组方式，这样一来， 使用 aggregateWindow 函数进行开窗后的表流，仍然是按照序列的方式来分组的。</p> 
<h4><a id="yield__join_1281"></a>yield 和 join</h4> 
<p>当 flux 脚本中出现未被赋值给某个变量的表流时，InfluxDB 执行 FLUX 脚本时会自动帮他们在管道的最后面加上|&gt; yield(name: “_result”)函数，yield 函数其实是指定了我们当前这个表流是整个 FLUX 脚本最后返回的结果，而且这个结果的名字叫"_result"。当 FLUX 脚本中出现多个为赋值给变量的表流时，给多个表流自动补上|&gt;yield(name:“_result”)就会出问题了，这是因为当有多个表流后面都有|&gt;yield 时，其实相当于一个 FLUX 脚本会返回多个结果。但是此处要求名称是不能重复的，所以当有多个未赋值的表流时，就必须显示指定 yield(name:“xxx”)，而且名称千万不可重复。</p> 
<p>但是，在一个 FLUX 脚本里同时返回多个结果集并不是推荐的操作，这通常会让程序的逻辑变的很奇怪，我们之所以能在一个 FLUX 脚本里面写多次 from 函数，其实是为了方便我们进行join 的。</p> 
<p>再但是，并不建议在 FLUX 脚本中使用 join 操作，这必须要谈到 FLUX 脚本的常见使用场景，就是每隔一段时间进行一次查询。如果这个时候，我用一个 from 从 InfluxDB 中查询数据，其中有 code=01 等机器编号信息。然后我再用一个 from 去查询 mysql，得到一张机器的属性表。接下来对两张表进行 join，这在逻辑上很合理，但最大的问题就是FLUX 脚本无法实现数据的缓存。如果我这个 FLUX 脚本是每 15 秒执行一次，那就会导致我们需要每 15 秒要去 mysql 上全表扫描一遍机器信息表，效率十分低下。</p> 
<p><strong>个人建议仅使用 FLUX 进行简单的查询，然后在应用层的程序里进行 join 操作。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e9ca4a3af08be976f6330059d6d395aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">二叉排序树、平衡二叉树、红黑树、B树、B&#43;树</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bffcde4044d3e7c5b69043495e255d6a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 简单的获取当前可用运行内存，总运行内存，获取包含系统软件在内的所有内存，获取系统参数显示的内存大小。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>