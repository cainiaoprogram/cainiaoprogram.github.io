<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单例模式的N种实现方式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="单例模式的N种实现方式" />
<meta property="og:description" content="我是小黑，一名在互联网“苟且”的程序员
关注同名公众号【小黑说Java】，更多干货内容抢先送达，更有不定期抽奖送书活动。
流水不争先，贵在滔滔不绝
如果你自认为已经掌握懒汉式、饿汉式、DCL、IoDH、枚举等单例实现方式，可以直接看最后的打破单例。如果不是，建议你耐心从头看完。
相信你看完本文能让你掌握Java中所有单例模式的设计方式。
单例设计模式是GOF 23中设计模式中常见的设计模式之一，不论是在我们日常开发，还是一些第三方库中几乎都能见到单例模式。包括在面试时初中级的程序员基本都会被问到单例模式。
单例模式的目的主要是为了保证在多线程场景下实例唯一的一种解决方案，实现起来还是比较简单的，但是实现方式各式各样，五花八门，今天小黑带大家梳理下单例模式的7种实现方式，并比较各有什么优缺点。
饿汉式 饿汉式，顾名思义一上来就会创建实例对象，因为很饿嘛，马上就要创建出来。
/** * @author java_xiaohei 公众号：小黑说Java * @ClassName Singleton * @Description 单例设计模式：饿汉式 * @date 2021/9/27 **/ public final class Singleton { // 定义变量时直接初始化 private static Singleton instance = new Singleton(); // 构造方法私有，不允许外部new private Singleton() { } // 外部通过getIntstance获取实例 public static Singleton getInstance() { return instance; } } 饿汉式的关键在于定义instance时直接实例化。通过饿汉式完全可以保证实例对象的线程安全。
但是有一个问题，如果该实例对象被创建之后过了很久才会被访问，那么在访问之前这个对象数据会一直存放在堆内存当中，如果实际场景中单例对象的实例数据很大，将会占用比较多的资源，这种方式则不太合适。
懒汉式 懒汉式相对饿汉式而言，区别的地方主要在创建对象的时机有区别，不会在定义变量时初始化，而是在需要使用时才进行创建。
public final class Singleton { // 定义变量时不做初始化 private static Singleton instance = null; // 构造方法私有，不允许外部new private Singleton() { } // 外部通过getIntstance获取实例 public static Singleton getInstance() { if(instance==null){ instance = new Singleton(); } return instance; } } 这种方式相对饿汉式而言，可以避免在使用对象之前创建对象造成的空间资源浪费。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/76b26d629b729f2803b1aed2536b6d15/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-27T10:55:41+08:00" />
<meta property="article:modified_time" content="2021-12-27T10:55:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单例模式的N种实现方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>我是小黑，一名在互联网“苟且”的程序员<br> 关注同名公众号【<strong>小黑说Java</strong>】，更多干货内容抢先送达，更有不定期抽奖送书活动。<br> <strong>流水不争先，贵在滔滔不绝</strong></p> 
</blockquote> 
<hr> 
<blockquote> 
 <p>如果你自认为已经掌握懒汉式、饿汉式、DCL、IoDH、枚举等单例实现方式，可以直接看最后的<strong>打破单例</strong>。如果不是，建议你耐心从头看完。</p> 
 <p>相信你看完本文能让你掌握Java中所有单例模式的设计方式。</p> 
</blockquote> 
<p>单例设计模式是GOF 23中设计模式中常见的设计模式之一，不论是在我们日常开发，还是一些第三方库中几乎都能见到单例模式。包括在面试时初中级的程序员基本都会被问到单例模式。</p> 
<p>单例模式的目的主要是为了保证在多线程场景下实例唯一的一种解决方案，实现起来还是比较简单的，但是实现方式各式各样，五花八门，今天小黑带大家梳理下单例模式的7种实现方式，并比较各有什么优缺点。</p> 
<h3><a id="_13"></a>饿汉式</h3> 
<p>饿汉式，顾名思义一上来就会创建实例对象，因为很饿嘛，马上就要创建出来。</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @author java_xiaohei 公众号：小黑说Java
 * @ClassName Singleton
 * @Description 单例设计模式：饿汉式
 * @date 2021/9/27
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 定义变量时直接初始化</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 构造方法私有，不允许外部new</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 外部通过getIntstance获取实例</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>饿汉式的关键在于定义instance时直接实例化。通过饿汉式完全可以保证实例对象的线程安全。</p> 
<p>但是有一个问题，如果该实例对象被创建之后过了很久才会被访问，那么在访问之前这个对象数据会一直存放在堆内存当中，如果实际场景中单例对象的实例数据很大，将会占用比较多的资源，这种方式则不太合适。</p> 
<h3><a id="_41"></a>懒汉式</h3> 
<p>懒汉式相对饿汉式而言，区别的地方主要在创建对象的时机有区别，不会在定义变量时初始化，而是在需要使用时才进行创建。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 定义变量时不做初始化</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 构造方法私有，不允许外部new</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 外部通过getIntstance获取实例</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这种方式相对饿汉式而言，可以避免在使用对象之前创建对象造成的空间资源浪费。</p> 
<p>上面代码在单线程场景下调用<code>getInstance()</code>没有问题，但是在多线程情况下，会有线程安全问题。</p> 
<p>是因为getInstance()方法中的if判断和对instance的赋值动作不是原子操作。</p> 
<p>如下图，有两个线程A和B先后调用<code>getInstance()</code>，线程A判断<code>instance==null</code>为<code>true</code>。</p> 
<p>在线程A进行实例化对象之前，线程B拿到了CPU的执行权，这时线程B判断<code>instance==null</code>也为<code>true</code>，此时线程B也会做实例化，这样无法保证实例的唯一性。</p> 
<p><img src="https://images2.imgbox.com/96/d8/0Qu0mDsM_o.png" alt=""></p> 
<p>这种懒汉式的实现方式因为不能保证线程安全，所以实际开发中不可以使用。</p> 
<h3><a id="_76"></a>懒汉式+同步方法</h3> 
<p>简单的懒汉式因为存在线程安全问题，那么我们可以通过加锁的方式来保证线程安全。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 定义变量时不做初始化</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 构造方法私有，不允许外部new</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 方法上加synchronized保证线程安全</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过在<code>getInstance()</code>方法上加锁，可以保证多线程情况下只能有一个线程进入此方法，也就保证了线程安全。</p> 
<p>但是这种方法未免有点太偷懒，在初次创建实例对象之时加锁可以避免实例对象被创建多个，但是在实例被成功创建之后，每次获取实例时都需要获取锁，这会极大的降低性能。</p> 
<h3><a id="DCL_101"></a>DCL</h3> 
<p>DCL是Double Check Lock的简写，意思是双重检查锁。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> msg<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 初始化msg</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">"对象描述信息"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 第一层检查</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 只能有一个线程获得Singleton.class锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 第二层检查</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>DCL方式在保证线程安全的做法上没有偷懒，并没有直接在方法上加锁。</p> 
<p>第一层判断如果为true，则会执行加锁和创建实例的操作；如果第一层判断为false，表示对象已经创建完成了，那么直接返回实例就OK，避免每次请求都加锁，性能高。</p> 
<p>在第一层判断结果为true，则需要加锁保证实例创建过程的安全性。</p> 
<p>加锁成功后的第二层判空检查的目的是为了防止在进入第一层检查和加锁成功的过程中已经有其他线程完成实例的创建，避免重复创建。</p> 
<p>DCL方式保证了线程安全的同时又没有损失性能，并且还是懒加载的，貌似是一种完美的解决方案。</p> 
<p>但是这种方式在多线程情况下可能会出现空指针异常。如果你有细心看我的代码会发现上面的代码中，<code>Singleton()</code>构造方法中对属性msg进行了初始化赋值。</p> 
<p>那么我们在getInstance()方法中的<code>instance = new Singleton();</code>可以分为三步操作。</p> 
<p>1.new Singleton()在堆中创建一个对象;</p> 
<p>2.msg赋值；</p> 
<p>3.instance赋值；</p> 
<p>但是根据JVM运行时Happens-before规则，这三步的顺序并没有前后依赖，很有可能实际运行的顺序是，3-&gt;1-&gt;2或者其他；那么就可能造成在getInstance()中<code>instance == null</code>的结果为true，但是实例中的msg为null；假设调用方拿到instance之后直接使用msg则会抛出空指针异常。</p> 
<h3><a id="volatileDCL_151"></a>volatile+DCL</h3> 
<p>DCL方式虽然看起来很巧妙的实现了单例模式，但是因为JVM的运行时指令重排序导致单例对象使用过程中的异常。</p> 
<p>解决这个问题则需要使用volatile关键字。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// volatile修饰</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> msg<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">"对象描述信息"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>volatile关键字可以防止重排序的发生。如果你对volatile的底层原理感兴趣，可以看看我另一篇文章。<a href="https://juejin.cn/post/7001351134631690247" rel="nofollow">Java内存模型</a></p> 
<h3><a id="_181"></a>静态内部类</h3> 
<p>使用静态内部类实现单例模式的方式主要是借助于类加载机制完成。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 实际是返回静态内部类中的实例</span>
        <span class="token keyword">return</span> <span class="token class-name">Holder</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Holder</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 在静态内部类中定义instance并实例化</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这种方式将单例对象的定义放在静态内部类Holder中，如果你对静态内部类的加载机制比较了解那这里你一定很明白了。</p> 
<p>静态内部类并不会随着外部类的加载一起加载，只有在使用时才会加载；</p> 
<p>而类加载的过程则直接保证了线程安全性，保证实例对象的唯一。</p> 
<p>这种方式又被称为<strong>IoDH</strong>(Initialization Demand Holder)技术，是目前使用比较广的方式之一，也算是最好的一种单例设计模式了。</p> 
<h3><a id="_209"></a>枚举</h3> 
<p>最后一种实现单例的方式是枚举。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    INSTANCE<span class="token punctuation">;</span>
    <span class="token class-name">String</span> data <span class="token operator">=</span> <span class="token string">"实例数据"</span><span class="token punctuation">;</span>

    <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用枚举方式实现单例是**《Effective Java》**中推荐的一种方式。枚举不可以被继承，并且线程安全，只会实例化一次。</p> 
<h3><a id="_229"></a>打破单例</h3> 
<p>以上说了这么多单例的实现方式，到底能不能保证实例只被创建一次呢？可不可以被突破呢？</p> 
<p>我们学过一种叫做反射的技术，可以来尝试能不能搞搞事情，使用饿汉式这种方式举例。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">SingletonTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Singleton</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Singleton</span> singleton <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>singleton<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果：</p> 
<p><img src="https://images2.imgbox.com/e3/9f/LBrofgFg_o.png" alt=""></p> 
<p>从结果上看，简单的将构造方法私有化并不能保证实例创建一个，如果使用方反射处理构造方法可以突破这个限制。</p> 
<p>如果要防止使用方这样操作，我们可以在构造方法上做点手脚。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span>instance <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"你不要搞事情"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果instance已经被实例化，则抛出异常，可以避免被反射突破单例。如果是懒汉式并不能保证在调用getInstance()方法之前被创建。</p> 
<p>这里我们会发现，不管是懒汉式还是饿汉式，通过私有化构造方法都不能保证构造方法不被外部执行，那么枚举能不能被突破唯一性呢？我们再来试试。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    INSTANCE<span class="token punctuation">;</span>
    <span class="token class-name">String</span> data <span class="token operator">=</span> <span class="token string">"实例数据"</span><span class="token punctuation">;</span>
    <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">SingletonTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Singleton</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Singleton</span> singleton <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>singleton<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果：</p> 
<p><img src="https://images2.imgbox.com/46/5a/tHKbNOYZ_o.png" alt=""></p> 
<p>从运行结果发现，枚举类型虽然从代码上有一个私有的构造方法，但是通过反射执行时并不能拿到。难道枚举没有构造方法？</p> 
<p><img src="https://images2.imgbox.com/1a/74/WQTUJ6ON_o.png" alt=""></p> 
<p>小黑通过Debug获取所有构造方法发现，枚举类虽然没有无参的构造方法，但是有一个有参的方法，第一个参数为String，第二个参数为int。我猜这俩个参数应该是枚举对象的name和ordinal属性，我们再来搞个事情看看。</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">SingletonTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> declaredConstructors <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> declaredConstructors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 按照指定参数创建</span>
        <span class="token class-name">Object</span> singleton <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"INSTANCE"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>singleton<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行结果：</p> 
<p><img src="https://images2.imgbox.com/e2/b2/mzGFBDDH_o.png" alt=""></p> 
<p>我们发现，通过反射获取构造方法，然后按照我们Debug看到的参数进行创建对象时，抛出了异常。</p> 
<p>异常描述为 <code>Cannot reflectively create enum objects</code>。不能反射创建枚举对象！！！</p> 
<p>原来JDK早就预料到可能会有人这样搞事情来破坏枚举对象的唯一性，在构造方法中进行处理了，想必这应该是《Effective Java》中推荐的一部分原因吧。</p> 
<h3><a id="_343"></a>总结</h3> 
<p>单例模式不管是在面试还是在实际的开发过程中会很高频的出现，看似简单，但是要实现一个线程安全，高性能，并且可以不被外部非法破坏，需要考虑的点还是挺多的，小黑通常会通过静态内部类实现IoDH方式或者枚举方式来设计单例。</p> 
<p>要是觉得有用，点个👍再走吧。</p> 
<blockquote> 
 <p>我是小黑，一名在互联网“苟且”的程序员</p> 
 <p>关注同名公众号【<strong>小黑说Java</strong>】，更多干货内容抢先送达，更有不定期抽奖送书活动。</p> 
 <p><strong>流水不争先，贵在滔滔不绝</strong></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/272d698c0dfb7665bb2bf6f4a42c2bb8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于TC和netem实现网络异常情况的模拟</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/019a4cfb9c155e2597ed82b1e289361e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SOP是什么？SOP的作用是什么？如何编写SOP？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>