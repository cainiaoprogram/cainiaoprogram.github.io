<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>log4j2配置参数详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="log4j2配置参数详解" />
<meta property="og:description" content="1.概述 JAVA常用的日志收集api和实现框架都有多种，不同的api和实现框架之间怎么相互兼容都比较复杂，不过大部分的日志框架实现也都提供了对其他日志收集方式的兼容和切换（可以参考slf4j、jcl、jul、log4j1、log4j2、logback大总结 - 乒乓狂魔 - OSCHINA - 中文开源技术交流社区）。本文主要介绍log4j2的Appenders下的组件列表，及几种比较常见的appender配置。
2.配置详解 log4j2.xml文件结构如下：
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
&lt;!DOCTYPE xml&gt;
&lt;Configuration&gt;
&lt;Properties&gt;
...
&lt;/Properties&gt;
&lt;Appenders&gt;
...
&lt;/Appenders&gt;
&lt;Loggers&gt;
...
&lt;/Loggers&gt;
&lt;/Configuration&gt;
配置文件由Properties、Appenders、Loggers三块组成。Properties配置基础变量，Loggers负责配置日志级别，Loggers配置日志收集方式、布局、输出、清理等功能。
2.1. appender组件列表 append描述AsyncAppender用于接受其他类型appender的引用，并使用单独线程异步写入logCassandraAppender将日志写入Cassandra数据库中，需要提前建立keyspace和tableConsoleAppender其日志写入System.out或System.err，默认为System.outFailoverAppender故障转移appender，可以指定主appender，并且包含一组appender集合，当主appender写入失败，则会依次使用其他append写入，直至写入成功或者全部appender写入失败FileAppender将日志写入文件，使用FileManager执行ioFlumeAppender将日志序列化后发送给Flume代理。
可选组件，由单独的jar提供。JDBCAppender使用标准JDBC将日志写入关系数据库表，必须使用连接池JMS Appender将日志发送至JMS中JPAAppender通过JPA将日志写入关系型数据库表，需要有单独的persistence.xml配置文件HttpAppender通过http请求发送日志，使用HttpURLConnection实现，响应2XX状态码为成功，否则抛出异常KafkaAppender将日志事件发送到Kafka的topic中MemoryMappedFileAppender2.1新增功能，将指定日志文件的一部分映射至内存，并将新日志事件写入此内存，达到阈值时将此内存刷新至存储设备NoSQLAppender使用内部轻量级Provider接口将日志事件写入NoSQL数据库。目前只有MongoDB和Apache CouchDB的Provider实现NoSQLAppender for MongoDB2.0.11开始，提供两个MongoDB模块：log4j-mongodb2、log4j-mongodb3NoSQLAppender for MongoDB 2使用MongoDB驱动程序版本2将日志写入MongoDB中NoSQLAppender for MongoDB 3使用MongoDB驱动程序版本3将日志写入MongoDB中NoSQLAppender for Apache CouchDB使用内部轻量级Provider将日志写入CouchDB中OutputStreamAppenderOutputStreamAppender不能直接配置，只是作为基础组件提供给其他Appender使用，如可以将日志事件写入输出流的File和SocketRandomAccessFileAppender与FileAppender相比，使用的I/O实现类不同，FileAppender使用FileOutputStream，RandomAccessFileAppender 使用RandomAccessFile。bufferedIO=true(默认是true)时，性能提高20-200％ 。RewriteAppender用于在日志被其他Appender写入文件之前，通过RewritePolicy修改日志事件RollingFileAppender将日志写入文件，并根据TriggeringPolicy和RolloverPolicy规则将文件归档、清理RollingRandomAccessFileAppender与RollingFileAppender相比，使用的I/O实现类不同，RollingFileAppender使用FileOutputStream，RollingRandomAccessFileAppender使用RandomAccessFile。bufferedIO=true(默认是true)时，性能提高20-200％ 。RoutingAppender配置不同的规则，将日志路由到不同的Appender进行输出SMTPAppender发生指定日志事件时，发送电子邮件ScriptAppenderSelector根据Script脚本的执行结果来选择AppenderSet中配置的Appender，并将结果输出至ScriptAppenderSelector的name中SocketAppender通过tcp或者udp，将日志写入远程目标中SyslogAppenderSyslogAppender是一个SocketAppender，它将其输出以符合BSD Syslog或RFC 5424格式的日志写入到远程目标ZeroMQ/JeroMQ AppenderZeroMQ Appender使用JeroMQ库将日志事件发送到一个或多个ZeroMQ端点 2.2.ConsoleAppender ConsoleAppender比较简单，就是把日志写入System.out或者System.err中，基本配置如下：
&lt;Console name=&#34;STDOUT&#34; target=&#34;SYSTEM_ERR&#34;&gt;
&lt;PatternLayout pattern=&#34;%d{yyyy-MM-dd HH:mm:ss.SSS} %t %5p [%c:%L] - %m%n&#34; /&gt;
&lt;/Console&gt;
Console一般使用基本配置就可以，唯一要注意的就是输出格式pattern，pattern的配置释义如下：
参数描述%c或%logger输出logName，如 Logger log = LoggerFactory." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ee89e87a53ad5bf04d423aacfb267069/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-28T14:49:20+08:00" />
<meta property="article:modified_time" content="2022-05-28T14:49:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">log4j2配置参数详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="articleContentId"></h2> 
<p></p> 
<h2 id="CvMYj"><a name="t1"></a>1.概述</h2> 
<p>JAVA常用的日志收集<a href="https://so.csdn.net/so/search?q=api&amp;spm=1001.2101.3001.7020" title="api">api</a>和实现框架都有多种，不同的api和实现框架之间怎么相互兼容都比较复杂，不过大部分的日志框架实现也都提供了对其他日志收集方式的兼容和切换（可以参考<a href="https://my.oschina.net/pingpangkuangmo/blog/410224" rel="nofollow" title="slf4j、jcl、jul、log4j1、log4j2、logback大总结 - 乒乓狂魔 - OSCHINA - 中文开源技术交流社区">slf4j、jcl、jul、log4j1、log4j2、logback大总结 - 乒乓狂魔 - OSCHINA - 中文开源技术交流社区</a>）。本文主要介绍log4j2的Appenders下的组件列表，及几种比较常见的appender配置。</p> 
<p></p> 
<h2 id="v6z5k"><a name="t2"></a>2.配置详解</h2> 
<p>log4j2.<a href="https://so.csdn.net/so/search?q=xml&amp;spm=1001.2101.3001.7020" title="xml">xml</a>文件结构如下：</p> 
<table><tbody><tr><td> <p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p> <p>&lt;!DOCTYPE xml&gt;</p> <p>&lt;Configuration&gt;</p> <p>    &lt;Properties&gt;</p> <p>        ...</p> <p>    &lt;/Properties&gt;</p> <p></p> <p>    &lt;Appenders&gt;</p> <p>        ...</p> <p>    &lt;/Appenders&gt;</p> <p></p> <p>    &lt;Loggers&gt;</p> <p>        ...</p> <p>    &lt;/Loggers&gt;</p> <p>&lt;/Configuration&gt;</p> </td></tr></tbody></table> 
<p>配置文件由Properties、Appenders、Loggers三块组成。Properties配置基础变量，Loggers负责配置日志级别，Loggers配置日志收集方式、布局、输出、清理等功能。</p> 
<h3 id="PRfOg"><a name="t3"></a>2.1. appender组件列表</h3> 
<table><thead><tr><td>append</td><td>描述</td></tr></thead><tbody><tr><td>AsyncAppender</td><td>用于接受其他类型appender的引用，并使用单独线程异步写入log</td></tr><tr><td>CassandraAppender</td><td>将日志写入Cassandra数据库中，需要提前建立keyspace和table</td></tr><tr><td>ConsoleAppender</td><td>其日志写入System.out或System.err，默认为System.out</td></tr><tr><td>FailoverAppender</td><td>故障转移appender，可以指定主appender，并且包含一组appender集合，当主appender写入失败，则会依次使用其他append写入，直至写入成功或者全部appender写入失败</td></tr><tr><td>FileAppender</td><td>将日志写入文件，使用FileManager执行io</td></tr><tr><td>FlumeAppender</td><td>将日志序列化后发送给Flume代理。<br> 可选组件，由单独的jar提供。</td></tr><tr><td>JDBCAppender</td><td>使用标准JDBC将日志写入关系数据库表，必须使用连接池</td></tr><tr><td>JMS Appender</td><td>将日志发送至JMS中</td></tr><tr><td>JPAAppender</td><td>通过JPA将日志写入关系型数据库表，需要有单独的persistence.xml配置文件</td></tr><tr><td>HttpAppender</td><td>通过http请求发送日志，使用HttpURLConnection实现，响应2XX状态码为成功，否则抛出异常</td></tr><tr><td>KafkaAppender</td><td>将日志事件发送到Kafka的topic中</td></tr><tr><td>MemoryMappedFileAppender</td><td>2.1新增功能，将指定日志文件的一部分映射至内存，并将新日志事件写入此内存，达到阈值时将此内存刷新至存储设备</td></tr><tr><td>NoSQLAppender</td><td>使用内部轻量级Provider接口将日志事件写入NoSQL数据库。目前只有MongoDB和Apache CouchDB的Provider实现</td></tr><tr><td>NoSQLAppender for MongoDB</td><td>2.0.11开始，提供两个MongoDB模块：log4j-mongodb2、log4j-mongodb3</td></tr><tr><td>NoSQLAppender for MongoDB 2</td><td>使用MongoDB驱动程序版本2将日志写入MongoDB中</td></tr><tr><td>NoSQLAppender for MongoDB 3</td><td>使用MongoDB驱动程序版本3将日志写入MongoDB中</td></tr><tr><td>NoSQLAppender for Apache CouchDB</td><td>使用内部轻量级Provider将日志写入CouchDB中</td></tr><tr><td>OutputStreamAppender</td><td>OutputStreamAppender不能直接配置，只是作为基础组件提供给其他Appender使用，如可以将日志事件写入输出流的File和Socket</td></tr><tr><td>RandomAccessFileAppender</td><td>与FileAppender相比，使用的I/O实现类不同，FileAppender使用FileOutputStream，RandomAccessFileAppender 使用RandomAccessFile。bufferedIO=true(默认是true)时，性能提高20-200％ 。</td></tr><tr><td>RewriteAppender</td><td>用于在日志被其他Appender写入文件之前，通过RewritePolicy修改日志事件</td></tr><tr><td>RollingFileAppender</td><td>将日志写入文件，并根据TriggeringPolicy和RolloverPolicy规则将文件归档、清理</td></tr><tr><td>RollingRandomAccessFileAppender</td><td>与RollingFileAppender相比，使用的I/O实现类不同，RollingFileAppender使用FileOutputStream，RollingRandomAccessFileAppender使用RandomAccessFile。bufferedIO=true(默认是true)时，性能提高20-200％ 。</td></tr><tr><td>RoutingAppender</td><td>配置不同的规则，将日志路由到不同的Appender进行输出</td></tr><tr><td>SMTPAppender</td><td>发生指定日志事件时，发送电子邮件</td></tr><tr><td>ScriptAppenderSelector</td><td>根据Script脚本的执行结果来选择AppenderSet中配置的Appender，并将结果输出至ScriptAppenderSelector的name中</td></tr><tr><td>SocketAppender</td><td>通过tcp或者udp，将日志写入远程目标中</td></tr><tr><td>SyslogAppender</td><td>SyslogAppender是一个SocketAppender，它将其输出以符合BSD Syslog或RFC 5424格式的日志写入到远程目标</td></tr><tr><td>ZeroMQ/JeroMQ Appender</td><td>ZeroMQ Appender使用JeroMQ库将日志事件发送到一个或多个ZeroMQ端点</td></tr></tbody></table> 
<h3 id="nKbDi"><a name="t4"></a>2.2.ConsoleAppender</h3> 
<p>ConsoleAppender比较简单，就是把日志写入System.out或者System.err中，基本配置如下：</p> 
<table><tbody><tr><td> <p>&lt;Console name="STDOUT" target="SYSTEM_ERR"&gt;</p> <p>    &lt;PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} %t %5p [%c:%L] - %m%n" /&gt;</p> <p>&lt;/Console&gt;</p> </td></tr></tbody></table> 
<p></p> 
<p>Console一般使用基本配置就可以，唯一要注意的就是输出格式pattern，pattern的配置释义如下：</p> 
<table><thead><tr><td>参数</td><td>描述</td></tr></thead><tbody><tr><td>%c或%logger</td><td>输出logName，如 Logger log = LoggerFactory.getLogger(“com.test.logName”); 则输出为“com.test.logName” ，如果格式为%c{参数}，则输出内容参考官网：<img alt="image" src="https://images2.imgbox.com/68/7e/6wKg6E7M_o.png"></td></tr><tr><td>%C或%class</td><td>输出为所在类的全路径名</td></tr><tr><td>d{pattern}或date{pattern}</td><td>输出时间，其中pattern可以是保留字，也可以是SimpleDateFormat中的字符。如<br> %d{DEFAULT} --&gt; 2012-11-02 14:34:02,781<br> %d{DEFAULT_MICROS} --&gt; 2012-11-02 14:34:02,123456<br> %d{yyyy-MM-dd HH:mm:ss.SSS} --&gt; 2020-03-31 23:25:13.321<br> 详见log4j PatternLayout</td></tr><tr><td>%F或%file</td><td>输出所在类名.java，如所在类为com.test.LogTest，则输出为LogTest.java</td></tr><tr><td>%l</td><td>输出错误的完整位置，全路径类名.方法名(类名.java:行号)，如，com.test.LogTest.testLog(LogTest.java:31)</td></tr><tr><td>%L</td><td>输出行号</td></tr><tr><td>%m或%msg或%message</td><td>输出log.error(text)中的text内容</td></tr><tr><td>%M或%method</td><td>输出方法名</td></tr><tr><td>%n</td><td>换行符</td></tr><tr><td>%t或%thread</td><td>输出线程名</td></tr><tr><td>%u{“RANDOM” | “TIME”}或uuid</td><td>输出uuid</td></tr><tr><td>%sn或%sequenceNumber</td><td>输出自增序列</td></tr><tr><td>%r或%relative</td><td>输出从JVM启动到当前时刻的毫秒数</td></tr><tr><td>%T或%tid或%threadId</td><td>输出线程id</td></tr><tr><td>%t或%tn或%thread或%threadName</td><td>输出线程id</td></tr><tr><td>%tp或%threadPriority</td><td>输出线程优先级</td></tr></tbody></table> 
<h3 id="a5Ngv"><a name="t5"></a> </h3> 
<h3 id="xAXcZ"><a name="t6"></a>2.3.RollingFileAppender</h3> 
<p>RollingFileAppender是一个OutputStreamAppender，可以根据TriggeringPolicy和RolloverPolicy将文件切割归档，通过RollingFileManager（扩展了OutputStreamManager）来实际执行文件I / O并执行归档。参数如下：</p> 
<table><thead><tr><td>参数</td><td>类型</td><td>描述</td></tr></thead><tbody><tr><td>append</td><td>boolean</td><td>默认为true。如果为true，记录将附加到文件末尾。设置为false时，将在写入新记录之前清除文件</td></tr><tr><td>bufferedIO</td><td>boolean</td><td>默认为true。如果为true，数据先写入缓冲区，如果缓冲区满或者immediateFlush 为true时，数据才被写入磁盘，如果为false直接写入磁盘。文件锁定不能与bufferedIO一起使用</td></tr><tr><td>bufferSize</td><td>int</td><td>缓冲区大小。bufferedIO为true时，此参数有效，默认为8192 bytes</td></tr><tr><td>createOnDemand</td><td>boolean</td><td>默认为false。按需创建文件。仅当日志事件通过所有Filter并且路由到该append时，append才创建文件</td></tr><tr><td>filter</td><td>Filter</td><td>确定事件是否应由此Appender处理，通过CompositeFilter（对应标签为）可以使用多个过滤器</td></tr><tr><td>fileName</td><td>String</td><td>要写入的文件名，如果不存在或者父目录不存在，则创建对应的文件或目录</td></tr><tr><td>filePattern</td><td>String</td><td>归档文件的模式，取决于所使用的RolloverPolicy</td></tr><tr><td>immediateFlush</td><td>boolean</td><td>默认为true。如果为true，每次写操作后都会将数据刷新入磁盘，可能会影响性能。<br> 每次写入后刷新仅在使用同步appender时才有用。即使设置为false，异步appender也将在一批事件结束后自动刷新，这也可以确保效率更高的将数据写入磁盘。</td></tr><tr><td>layout</td><td>Layout</td><td>格式化日志输出格式。如果未设置，则默认为’%m%n’</td></tr><tr><td>name</td><td>String</td><td>append名称</td></tr><tr><td>policy</td><td>TriggeringPolicy</td><td>用于确定归档的触发条件</td></tr><tr><td>strategy</td><td>RolloverStrategy</td><td>用于确定归档的文件名称、路径及归档方式</td></tr><tr><td>ignoreExceptions</td><td>boolean</td><td>默认为true。设置为true时，如果记录日志发生异常，此条日志和异常将被忽略。设置为false时，异常将被抛出到调用方。如果此append用在FailoverAppender中，则必须设置为false。</td></tr><tr><td>filePermissions</td><td>String</td><td>创建文件时指定文件的rwx权限，前提是文件系统应支持POSIX文件属性视图</td></tr><tr><td>fileOwner</td><td>String</td><td>文件所有者。出于安全原因，更改文件的所有者可能受到限制，并且不允许操作时会抛出IOException。<br> 如果_POSIX_CHOWN_RESTRICTED对路径有效，则只有有效用户ID等于文件用户ID或具有适当特权的进程才可以更改文件的所有权，前提是文件系统应支持文件所有者属性视图</td></tr><tr><td>fileGroup</td><td>String</td><td>文件组。，前提是文件系统应支持POSIX文件属性视图</td></tr></tbody></table> 
<h4 id="QpLZW"><a name="t7"></a>2.3.1.TriggeringPolicy</h4> 
<p>TriggeringPolicy是控制日志文件归档的触发条件。总共有四种类型的TriggeringPolicy，可以组合（CompositeTriggeringPolicy）多种触发策略来控制归档，标签为，如果配置了多种策略，则只要有一种策略返回true，就返回true。</p> 
<table><tbody><tr><td> <p>&lt;Policies&gt;</p> <p>  &lt;!-- &lt;CronTriggeringPolicy schedule="0 0 * * * ?"/&gt; --&gt;</p> <p>  &lt;OnStartupTriggeringPolicy minSize="2" /&gt;</p> <p>  &lt;SizeBasedTriggeringPolicy size="20 MB" /&gt;</p> <p>  &lt;TimeBasedTriggeringPolicy /&gt;</p> <p>&lt;/Policies&gt;</p> </td></tr></tbody></table> 
<p>四种类型如下：</p> 
<ul><li>OnStartupTriggeringPolicy<br> 如果日志文件的时间比JVM的启动时间早，或者达到minSize的值，则会触发归档。<br> minSize：触发文件归档的最小值，默认为1。</li><li>SizeBasedTriggeringPolicy<br> 当文件达到指定大小后，触发归档。大小可以通过size指定，单位为KB、MB、GB。与TimeBasedTriggeringPolicy配合使用时，filePattern中必须包含%i，否则文件每次归档时都会覆盖当前文件，因为TimeBasedTriggeringPolicy不会让文件名中的时间戳改变。如果不使用TimeBasedTriggeringPolicy，则SizeBasedTriggeringPolicy会让时间戳改变。</li><li>TimeBasedTriggeringPolicy<br> 当前时间与当前日志文件时间不匹配时，TimeBasedTriggeringPolicy会触发归档。参数如下：</li></ul> 
<table><thead><tr><td>参数</td><td>描述</td></tr></thead><tbody><tr><td>interval</td><td>基于filePattern中配置的最小时间单位进行来控制归档频率，默认值为1。如：filePattern中最小时间单位为小时，如果interval=1，则1小时归档一次；如果interval=2，则2小时归档一次。</td></tr><tr><td>modulate</td><td>默认为false。指明是否对interval进行调节，若modulate为true，会以0为开始对interval进行偏移计算。例如，最小时间粒度为小时，当前为3:00，interval为4，则后面归档时间依次为4:00，8:00，12:00，16:00</td></tr><tr><td>maxRandomDelay</td><td>指示随机延迟过渡的最大秒数。默认情况下，该值为0，表示没有延迟。此设置在配置了多个应用程序以同时滚动日志文件的服务器上很有用，并且可以在整个时间上分散这样做的负担。</td></tr></tbody></table> 
<ul><li>CronTriggeringPolicy<br> 基于cron表达式触发归档。此策略由计时器控制，并且与处理日志事件异步，因此上一个或下一个时间段的日志事件可能会出现在当前日志文件的开头或结尾。filePattern属性应包含一个时间戳，否则目标文件将在每次归档时被覆盖。参数如下：</li></ul> 
<table><thead><tr><td>参数</td><td>描述</td></tr></thead><tbody><tr><td>schedule</td><td>cron表达式，该表达式与Quartz调度程序中允许的表达式相同。详见CronExpression</td></tr><tr><td>EvaluationOnStartup</td><td>启动时，将根据文件的最后修改时间戳评估cron表达式。如果cron表达式指示应该在该时间和当前时间之间归档，则文件将立即被归档。</td></tr></tbody></table> 
<h4 id="AzUY5"><a name="t8"></a>2.3.2.RolloverPolicy</h4> 
<p>用来控制文件归档方式，目前有两种类型如下：</p> 
<p>2.3.2.1.DefaultRolloverStrategy</p> 
<p>通过接收filePattern属性中日期/时间模式（%d）和整数（%i）来控制归档方式。如果存在日期/时间模式，则将在归档时使用当前时间替换filePattern中配置的日期/时间部分，如果模式包含整数，则它将在每次归档时递增。如果归档时在模式中同时包含日期/时间和整数，则整数将递增，直到日期/时间部分也将被替换。如果文件模式以“ .gz”，“.zip”，“.bz2”，“.deflate”，“.pack200”或“ .xz”结尾，则将使用与后缀匹配的压缩方案来压缩文件。 bzip2, Deflate, Pack200 and XZ格式要求有Apache Commons Compress组件，另外xz格式还要求有XZ for Java组件。</p> 
<p>DefaultRolloverStrategy参数如下：</p> 
<table><thead><tr><td>参数</td><td>描述</td></tr></thead><tbody><tr><td>fileIndex</td><td>默认值为max。可选值为：min、max，2.8之后新增nomax。文件归档及新文件创建规则后面介绍。</td></tr><tr><td>min</td><td>计数器的最小值。预设值为1。</td></tr><tr><td>max</td><td>计数器的最大值。一旦达到此值，较旧的归档文件将在以后的转换中被删除。预设值为7。</td></tr><tr><td>compressionLevel</td><td>将压缩级别设置为0-9，其中0 =无，1 =最佳速度，直到9 =最佳压缩。仅针对ZIP文件实现</td></tr><tr><td>tempCompressedFilePattern</td><td>压缩期间归档日志文件的文件名的模式。</td></tr></tbody></table> 
<p>fileIndex设值不同，则文件归档及新文件创建及计数器递增方法都不同，计数器递增有三种方式，如下：</p> 
<ul><li>方式一：fileIndex值为max<br> 假设将DefaultRolloverStrategy的min属性设置为1，将max属性设置为3，fileName是“ foo.log”，filePattern是“ foo-％i.log”,归档规则如下：</li></ul> 
<table><thead><tr><td>归档数</td><td>当前日志文件</td><td>归档文件</td><td>描述</td></tr></thead><tbody><tr><td>0</td><td>foo.log</td><td>-</td><td>所有日志记录都将转到初始文件</td></tr><tr><td>1</td><td>foo.log</td><td>foo-1.log</td><td>第一次归档，foo.log重命名为foo-1.log。创建新的foo.log文件并继续写入</td></tr><tr><td>2</td><td>foo.log</td><td>foo-2.log，foo-1.log</td><td>第二次归档，foo.log重命名为foo-2.log。创建新的foo.log文件并继续写入</td></tr><tr><td>3</td><td>foo.log</td><td>foo-3.log，foo-2.log，foo-1.log</td><td>第三次归档，foo.log重命名为foo-3.log。创建新的foo.log文件并继续写入</td></tr><tr><td>4</td><td>foo.log</td><td>foo-3.log，foo-2.log，foo-1.log</td><td>第四次和随后的归档，foo-1.log被删除，foo-2.log被重命名为foo-1.log，foo-3.log被重命名为foo-2.log，foo.log被重命名为foo-3.log。创建新的foo.log文件并继续写入。</td></tr></tbody></table> 
<ul><li>方式二：fileIndex值为min</li></ul> 
<p>假设将DefaultRolloverStrategy的min属性设置为1，将max属性设置为3，fileName是“ foo.log”，filePattern是“ foo-％i.log”,归档规则如下：</p> 
<table><thead><tr><td>归档数</td><td>当前日志文件</td><td>归档文件</td><td>描述</td></tr></thead><tbody><tr><td>0</td><td>foo.log</td><td>-</td><td>所有日志记录都将转到初始文件</td></tr><tr><td>1</td><td>foo.log</td><td>foo-1.log</td><td>第一次归档，foo.log重命名为foo-1.log。创建新的foo.log文件并继续写入</td></tr><tr><td>2</td><td>foo.log</td><td>foo-1.log，foo-2.log</td><td>第二次归档，将foo-1.log重命名为foo-2.log，并将foo.log重命名为foo-1.log。创建新的foo.log文件并继续写入</td></tr><tr><td>3</td><td>foo.log</td><td>foo-1.log，foo-2.log，foo-3.log</td><td>第三次归档，将foo-2.log重命名为foo-3.log，将foo-1.log重命名为foo-2.log，将foo.log重命名为foo-1.log。创建新的foo.log文件并继续写入</td></tr><tr><td>4</td><td>foo.log</td><td>foo-1.log，foo-2.log，foo-3.log</td><td>第四次和随后的归档，删除foo-3.log，将foo-2.log重命名为foo-3.log，将foo-1.log重命名为foo-2.log，将foo.log重命名为foo -1.log。创建新的foo.log文件并继续写入。</td></tr></tbody></table> 
<ul><li>方式三：fileIndex值为nomax<br> nomax为2.8新增属性，设置为nomax时，将忽略DefaultRolloverStrategy的最大值和最小值，每次归档生成的新文件相对于前一个文件编号加1，没有最大文件数限制。</li></ul> 
<p>2.3.2.2.DirectWriteRolloverStrategy</p> 
<p>将日志事件直接写入由filePattern表示的文件。使用此策略文件不会执行重命名。如果是基于大小的触发策略，将在指定的时间段内写入多个文件，它们从1开始编号，并不断递增直到发生基于时间归档。</p> 
<p>注意：如果filePattern的后缀表示应该进行压缩，则在关闭应用程序时不会压缩当前文件。此外，如果时间更改使得filePattern不再与当前文件匹配，则启动时也不会对其进行压缩。</p> 
<p>DirectWriteRolloverStrategy模式参数如下：</p> 
<table><thead><tr><td>参数</td><td>描述</td></tr></thead><tbody><tr><td>maxFiles</td><td>与文件格式匹配的时间段内允许的最大文件数。如果超出文件数量，则最早的文件将被删除。如果指定，则该值必须大于1。如果该值小于零或省略，则文件数量将不受限制。</td></tr><tr><td>compressionLevel</td><td>将压缩级别设置为0-9，其中0 =无，1 =最佳速度，直到9 =最佳压缩。仅针对ZIP文件实现。</td></tr><tr><td>tempCompressedFilePattern</td><td>压缩期间归档日志文件的文件名的模式。</td></tr></tbody></table> 
<p>2.3.2.3.归档保留策略</p> 
<p>DefaultRolloverStrategy模式下，<a href="https://so.csdn.net/so/search?q=Log4j&amp;spm=1001.2101.3001.7020" title="Log4j">Log4j</a>-2.5引入了Delete（删除）操作（标签为），与 max属性所提供的功能相比，Log4j-2.5使用户可以更好地控制在归档时删除哪些文件。删除操作使用户可以配置一个或多个条件，以选择要相对于基本目录删除的文件。</p> 
<p>注意：可以删除任何文件，而不仅仅是删除日志文件，因此请谨慎使用此操作！使用testMode参数，可以测试配置，而不会意外删除错误的文件。</p> 
<p>delete参数如下：</p> 
<table><thead><tr><td>参数</td><td>描述</td></tr></thead><tbody><tr><td>basePath</td><td>必需。从此处开始扫描要删除的文件的基本路径。</td></tr><tr><td>maxDepth</td><td>要访问的目录的最大级别数。值为0表示仅访问起始文件，除非安全管理器拒绝。Integer.MAX_VALUE的值指示应访问所有级别。默认值为1，表示仅指定基本路径中的文件。</td></tr><tr><td>followLinks</td><td>是否遵循符号链接。默认为false。</td></tr><tr><td>testMode</td><td>如果为true，则不会删除文件，而是在INFO级别打印一条消息到状态记录器。使用此功能可以测试配置是否按预期工作。默认为false。</td></tr><tr><td>pathSorter</td><td>一个实现PathSorter 接口的插件， 用于在选择要删除的文件之前对文件进行排序。默认设置是首先对最近修改的文件进行排序。</td></tr><tr><td>pathConditions</td><td>如果未指定ScriptCondition，则为必需。 <p>可以指定一个或多个PathCondition元素。如果指定了多个PathCondition元素，则<strong>需要所有的PathCondition结果都为true</strong>才会进行删除。PathCondition也可以嵌套。如果进行嵌套，则是先判断外层的PathCondition，然后进行内层的判断。如果没有嵌套，则是按顺序进行判断。</p> <p>也可以创建自定义条件或使用内置条件：</p> <p>IfFileName 如果文件名与此参数匹配则结果为true，此参数为正则表达式或 glob的文件。</p> <p>IfLastModified 最后修改时间早于或等于此参数则结果为true，此参数为duration。</p> <p>IfAccumulatedFileCount 文件数超过指定个数则结果为true，此参数为整型。</p> <p>IfAccumulatedFileSize 所有文件总大小达到此参数则结果为true，此参数为KB、MB、GB。</p> <p>IfAll 如果此标签下的所有条件都配置成功（逻辑与），则结果为true。</p> <p>IfAny 如果此标签下的任何一个条件匹配成功（逻辑或），则结果为true。</p> <p>IfNot 如果此标签下的所有条件都不匹配（逻辑非），则结果为true。</p> </td></tr><tr><td>scriptCondition</td><td>如果未指定PathConditions，则为必需。指定脚本的ScriptCondition元素。ScriptCondition应该包含一个Script，ScriptRef或ScriptFile元素，该元素指定要执行的逻辑。（有关配置ScriptFiles和ScriptRefs的更多示例，另请参阅ScriptFilter文档。）该脚本传递了许多参数，包括在basePath下找到的路径列表（最大maxDepth），并且必须返回包含要删除的路径的列表。</td></tr></tbody></table> 
<p></p> 
<p></p> 
<h2 id="eBJT9"><a name="t9"></a>3.日志归档+日志清理配置demo</h2> 
<table><tbody><tr><td> <p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p> <p>&lt;Configuration status="WARN"&gt;</p> <p>    &lt;Properties&gt;</p> <p>        &lt;Property name="logDir"&gt;/export/Logs/meeting/&lt;/Property&gt;</p> <p>        &lt;Property name="logFile"&gt;gltLog&lt;/Property&gt;</p> <p>    &lt;/Properties&gt;</p> <p></p> <p>    &lt;Appenders&gt;</p> <p>        &lt;Console name="STDOUT" target="SYSTEM_ERR"&gt;</p> <p>            &lt;PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} %t %5p [%c:%L] - %m%n" /&gt;</p> <p>        &lt;/Console&gt;</p> <p></p> <p>        &lt;!--日志名称及归档的压缩包名称及规则--&gt;</p> <p>        &lt;RollingFile name="RollingFile" fileName="${logDir}/${logFile}.log"</p> <p>                     filePattern="${logDir}/$${date:yyyy-MM}/${logFile}.%d{yyyy-MM-dd}-%i.log.gz"&gt;</p> <p></p> <p>            &lt;!--日志输出格式--&gt;</p> <p>            &lt;PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} %t %5p [%c:%L] - %m%n" /&gt;</p> <p></p> <p>            &lt;!--满足任何一个policy即进行归档--&gt;</p> <p>            &lt;Policies&gt;</p> <p>                &lt;!--当前日志与开始日期不匹配（RollingFile中配置的filePattern中配置的最小时间单位不匹配时）时进行归档--&gt;</p> <p>                &lt;TimeBasedTriggeringPolicy/&gt;</p> <p>                &lt;!--文件超过5M进行归档--&gt;</p> <p>                &lt;SizeBasedTriggeringPolicy size="5 MB" /&gt;</p> <p>            &lt;/Policies&gt;</p> <p></p> <p>            &lt;!--归档的文件最大数量--&gt;</p> <p>            &lt;DefaultRolloverStrategy max="10"&gt;</p> <p>                &lt;!--删除规则--&gt;</p> <p>                &lt;Delete basePath="${logDir}" maxDepth="2"&gt;</p> <p>                    &lt;!--匹配文件规则--&gt;</p> <p>                    &lt;IfFileName glob="*.log.gz"&gt;</p> <p>                        &lt;IfLastModified age="7d"&gt;</p> <p>                            &lt;IfAny&gt;</p> <p>                                &lt;!--logDir下文件总大小超过50M，进行删除--&gt;</p> <p>                                &lt;IfAccumulatedFileSize exceeds="50 MB" /&gt;</p> <p>                                &lt;!--logDir下文件总数量超过10，进行删除--&gt;</p> <p>                                &lt;IfAccumulatedFileCount exceeds="10" /&gt;</p> <p>                            &lt;/IfAny&gt;</p> <p>                        &lt;/IfLastModified&gt;</p> <p>                    &lt;/IfFileName&gt;</p> <p>                &lt;/Delete&gt;</p> <p>            &lt;/DefaultRolloverStrategy&gt;</p> <p>        &lt;/RollingFile&gt;</p> <p>    &lt;/Appenders&gt;</p> <p></p> <p>    &lt;Loggers&gt;</p> <p>        &lt;Root level="debug"&gt;</p> <p>            &lt;AppenderRef ref="STDOUT" /&gt;</p> <p>            &lt;AppenderRef ref="RollingFile" /&gt;</p> <p>        &lt;/Root&gt;</p> <p>    &lt;/Loggers&gt;</p> <p>&lt;/Configuration&gt;</p> </td></tr></tbody></table> 
<h2 id="rsbJe"><a name="t10"></a> </h2> 
<table><tbody><tr><td> <p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p> <p>&lt;Configuration status="WARN" monitorInterval="300"&gt;</p> <p>   &lt;!-- debug="true"xmlns:log4j="http://jakarta.apache.org/log4j/"--&gt;</p> <p>   &lt;properties&gt;</p> <p>       &lt;property name="LOG_HOME"&gt;logs/kg&lt;/property&gt;</p> <p>       &lt;property name="FILE_NAME"&gt;kg&lt;/property&gt;</p> <p>   &lt;/properties&gt;</p> <p>   &lt;Appenders&gt;</p> <p>       &lt;Console name="Console" target="SYSTEM_OUT"&gt;</p> <p>           &lt;PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %class{36}:%M(%L)] - %msg%xEx%n"/&gt;</p> <p>       &lt;/Console&gt;</p> <p>       &lt;RollingRandomAccessFile name="MyFile"</p> <p>fileName="${LOG_HOME}/${FILE_NAME}.log"</p> <p>filePattern="${LOG_HOME}/$${date:yyyy-MM}/${FILE_NAME}-%d{yyyy-MM-dd-HH}-%i.log"&gt;</p> <p>           &lt;PatternLayout</p> <p>pattern="[%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %class{36}:%M(%L)] - %msg%xEx%n"/&gt;</p> <p>           &lt;!-- 设置每天晚上12点清除过期日志文件 --&gt;</p> <p>           &lt;CronTriggeringPolicy schedule="0 0 0 * * ?"/&gt;</p> <p>           &lt;Policies&gt;</p> <p>               &lt;TimeBasedTriggeringPolicy interval="1"/&gt;</p> <p>               &lt;!--每1小时/分/... 生成一个文件, 时间依据filePattern的配置--&gt;</p> <p>               &lt;SizeBasedTriggeringPolicy size="5 MB"/&gt;</p> <p>           &lt;/Policies&gt;</p> <p>           &lt;DefaultRolloverStrategy max="30"&gt;</p> <p>               &lt;Delete basePath="${LOG_HOME}/$${date:yyyy-MM}/" maxDepth="2"&gt;</p> <p>                   &lt;IfFileName glob="*/*.log" /&gt;</p> <p>                   &lt;!--!Note: 这里的age必须和filePattern协调, 后者是精确到HH, 这里就要写成xH, xd就不起作用</p> <p>                   另外, 数字最好&gt;2, 否则可能造成删除的时候, 最近的文件还处于被占用状态,导致删除不成功!--&gt;</p> <p>                   &lt;!--7天--&gt;</p> <p>                   &lt;IfLastModified age="168H" /&gt;</p> <p>               &lt;/Delete&gt;</p> <p>           &lt;/DefaultRolloverStrategy&gt;</p> <p>       &lt;/RollingRandomAccessFile&gt;</p> <p>   &lt;/Appenders&gt;</p> <p>   &lt;Loggers&gt;</p> <p>       &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</p> <p>       &lt;logger name="org.springframework" level="INFO"/&gt;</p> <p>       &lt;logger name="org.mybatis" level="INFO"/&gt;</p> <p>       &lt;Logger name="mylog" level="debug" additivity="false"&gt;</p> <p>           &lt;AppenderRef ref="MyFile"/&gt;</p> <p>           &lt;AppenderRef ref="Console"/&gt;</p> <p>       &lt;/Logger&gt;</p> <p>       &lt;Root level="debug"&gt;</p> <p>           &lt;AppenderRef ref="MyFile"/&gt;</p> <p>           &lt;AppenderRef ref="Console"/&gt;</p> <p>       &lt;/Root&gt;</p> <p>   &lt;/Loggers&gt;</p> <p>&lt;/Configuration&gt;</p> </td></tr></tbody></table> 
<p></p> 
<h2 id="bgWwP"><a name="t11"></a>4.总结</h2> 
<p>log4j 2.x相对于1.x增加了大量的api及高级特性，由于目前很少用到其他appender组件，本文仅仅列了下所有的appender组件的作用，只介绍了几个常用的appender组件，后面用到其他组件在总结吧。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94ebd31cb8108a8a6ce1ba67314e99db/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">highlight.js（代码高亮插件）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e0133015c1ce96a6038860c60769abb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTTP Cache（缓存）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>