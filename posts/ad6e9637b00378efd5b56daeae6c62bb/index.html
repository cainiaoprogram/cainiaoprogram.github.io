<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Tracert和Ping的命令区别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Tracert和Ping的命令区别" />
<meta property="og:description" content="Ping：主要就是检测目标主机是不是可连通。
实质：发送一个ICMP回显请求报文给目的主机，并等待回显的ICMP应答。然后打印出回显的报文。
注意：Ping不通一个地址，并不一定表示这个IP不存在或者没有连接在网络上，因为对方主机可能做了限制，比如安装了防火墙，因此Ping不通并不表示不能使用FTP或者TELNET连接。 结果：包括字节数、反应时间、以及生存时间。
Ping程序通过在ICMP报文数据中存放发送请求的时间来计算返回时间。当应答返回时，根据现在时间减去报文中存放的发送时间就得到反应时间了。生存时间（TTL），本来就存放在IP数据报的头部，直接就能够获取。 Tracert：一个探测路由的程序，可以让我们看见IP数据报到达目的地经过的路由。 实质：利用ICMP数据报和IP数据报头部中的TTL值。TTL（Time To Live）是一个IP数据报的生存时间，当每个IP数据报经过路由器的时候都回把TTL值减去1或者减去在路由器中停留的时间，但是大多数数据报在路由器中停留的时间都小于1秒种，因此实际上就是在TTL值减去了1。这样，TTL值就相当于一个路由器的计数器。 当路由器接收到一个TTL为0或者1的IP数据报的时候，路由器就不再转发这个数据了，而直接丢弃，并且发送一个ICMP“超时”信息给源主机。Tracert程序的关键就是这个回显的ICMP报文的IP报头的信源地址就是这个路由器的IP地址。同时，如果到达了目的主机，我们并不能知道，于是，Tracert还同时发送一个UDP信息给目的主机，并且选择一个很大的值作为UDP的端口，使主机的任何一个应用程序都不使用这个端口。所以，当达到目的主机的时候，UDP模块就产生一个“端口不可到达”的错误，这样就能判断是否是到达目的地了。 有说法是利用ping得到的TTL值来判断主机类型，这种办法可以大概地用来判断，有人问为什么一般得到的都不是标准的TTL值。这个就是因为ICMP数据包走的路由器线路的原因，所以，用ping 和 tracert 一起来用更容易判断主机类型（不过并不一定两次走的路线都一样，所以，还是个大概值，不过更接近点，而且主机的默认TTL值是可以改变的）。 C:\〉ping 211.99.199.204 Pinging 211.99.199.204 with 32 bytes of data: Reply from 211.99.199.204: bytes=32 time=20ms TTL=248 Reply from 211.99.199.204: bytes=32 time〈10ms TTL=248 Reply from 211.99.199.204: bytes=32 time=10ms TTL=248 Reply from 211.99.199.204: bytes=32 time=10ms TTL=248 Ping statistics for 211.99.199.204: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss), Approximate round trip times in milli-seconds: Minimum = 0ms, Maximum = 20ms, Average = 10ms C:\〉tracert 211." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ad6e9637b00378efd5b56daeae6c62bb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-12-21T14:05:27+08:00" />
<meta property="article:modified_time" content="2012-12-21T14:05:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Tracert和Ping的命令区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p align="left" style=""><strong>Ping：</strong>主要就是检测目标主机是不是可连通。</p> 
<p align="left" style=""> <wbr></wbr></p> 
<p align="left" style="">实质：发送一个ICMP回显请求报文给目的主机，并等待回显的ICMP应答。然后打印出回显的报文。</p> 
<p align="left" style=""> <wbr></wbr></p> 
<p align="left" style="">注意：Ping不通一个地址，并不一定表示这个IP不存在或者没有连接在网络上，因为对方主机可能做了限制，比如安装了防火墙，因此Ping不通并不表示不能使用FTP或者TELNET连接。 <wbr></wbr> <wbr></wbr><br> </p> 
<p align="left" style="">结果：包括字节数、反应时间、以及生存时间。</p> 
<p align="left" style=""> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> Ping程序通过在ICMP报文数据中存放发送请求的时间来计算返回时间。当应答返回时，根据现在时间减去报文中存放的发送时间就得到反应时间了。生存时间（TTL），本来就存放在IP数据报的头部，直接就能够获取。 <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr></p> 
<p align="left" style=""><strong>Tracert：</strong>一个探测路由的程序，可以让我们看见IP数据报到达目的地经过的路由。 <wbr></wbr> <wbr></wbr><br> 实质：利用ICMP数据报和IP数据报头部中的TTL值。TTL（Time <wbr></wbr>To <wbr></wbr>Live）是一个IP数据报的生存时间，当每个IP数据报经过路由器的时候都回把TTL值减去1或者减去在路由器中停留的时间，但是大多数数据报在路由器中停留的时间都小于1秒种，因此实际上就是在TTL值减去了1。这样，TTL值就相当于一个路由器的计数器。 <wbr></wbr> <wbr></wbr><br> 当路由器接收到一个TTL为0或者1的IP数据报的时候，路由器就不再转发这个数据了，而直接丢弃，并且发送一个ICMP“超时”信息给源主机。Tracert程序的关键就是这个回显的ICMP报文的IP报头的信源地址就是这个路由器的IP地址。同时，如果到达了目的主机，我们并不能知道，于是，Tracert还同时发送一个UDP信息给目的主机，并且选择一个很大的值作为UDP的端口，使主机的任何一个应用程序都不使用这个端口。所以，当达到目的主机的时候，UDP模块就产生一个“端口不可到达”的错误，这样就能判断是否是到达目的地了。 <wbr></wbr> <wbr></wbr><br> 有说法是利用ping得到的TTL值来判断主机类型，这种办法可以大概地用来判断，有人问为什么一般得到的都不是标准的TTL值。这个就是因为ICMP数据包走的路由器线路的原因，所以，用ping <wbr></wbr>和 <wbr></wbr>tracert <wbr></wbr>一起来用更容易判断主机类型（不过并不一定两次走的路线都一样，所以，还是个大概值，不过更接近点，而且主机的默认TTL值是可以改变的）。 <wbr></wbr> <wbr></wbr><br> C:\〉ping <wbr></wbr>211.99.199.204 <wbr></wbr> <wbr></wbr><br> Pinging <wbr></wbr>211.99.199.204 <wbr></wbr>with <wbr></wbr>32 <wbr></wbr>bytes <wbr></wbr>of <wbr></wbr>data: <wbr></wbr> <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>211.99.199.204: <wbr></wbr>bytes=32 <wbr></wbr>time=20ms <wbr></wbr>TTL=248 <wbr></wbr> <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>211.99.199.204: <wbr></wbr>bytes=32 <wbr></wbr>time〈10ms <wbr></wbr>TTL=248 <wbr></wbr> <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>211.99.199.204: <wbr></wbr>bytes=32 <wbr></wbr>time=10ms <wbr></wbr>TTL=248 <wbr></wbr> <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>211.99.199.204: <wbr></wbr>bytes=32 <wbr></wbr>time=10ms <wbr></wbr>TTL=248 <wbr></wbr> <wbr></wbr><br> Ping <wbr></wbr>statistics <wbr></wbr>for <wbr></wbr>211.99.199.204: <wbr></wbr> <wbr></wbr><br> Packets: <wbr></wbr>Sent <wbr></wbr>= <wbr></wbr>4, <wbr></wbr>Received <wbr></wbr>= <wbr></wbr>4, <wbr></wbr>Lost <wbr></wbr>= <wbr></wbr>0 <wbr></wbr>(0% <wbr></wbr>loss), <wbr></wbr> <wbr></wbr><br> Approximate <wbr></wbr>round <wbr></wbr>trip <wbr></wbr>times <wbr></wbr>in <wbr></wbr>milli-seconds: <wbr></wbr> <wbr></wbr><br> Minimum <wbr></wbr>= <wbr></wbr>0ms, <wbr></wbr>Maximum <wbr></wbr>= <wbr></wbr>20ms, <wbr></wbr>Average <wbr></wbr>= <wbr></wbr>10ms <wbr></wbr> <wbr></wbr><br> C:\〉tracert <wbr></wbr>211.99.199.204 <wbr></wbr> <wbr></wbr><br> Tracing <wbr></wbr>route <wbr></wbr>to <wbr></wbr>211.99.199.204 <wbr></wbr>over <wbr></wbr>a <wbr></wbr>maximum <wbr></wbr>of <wbr></wbr>30 <wbr></wbr>hops <wbr></wbr> <wbr></wbr><br> 1 <wbr></wbr>10 <wbr></wbr>ms <wbr></wbr>10 <wbr></wbr>ms <wbr></wbr>20 <wbr></wbr>ms <wbr></wbr>211.99.57.121 <wbr></wbr> <wbr></wbr><br> 2 <wbr></wbr>10 <wbr></wbr>ms <wbr></wbr>10 <wbr></wbr>ms <wbr></wbr>10 <wbr></wbr>ms <wbr></wbr>202.96.13.1 <wbr></wbr> <wbr></wbr><br> 3 <wbr></wbr>〈10 <wbr></wbr>ms <wbr></wbr>10 <wbr></wbr>ms <wbr></wbr>20 <wbr></wbr>ms <wbr></wbr>202.96.13.62 <wbr></wbr> <wbr></wbr><br> 4 <wbr></wbr>20 <wbr></wbr>ms <wbr></wbr>10 <wbr></wbr>ms <wbr></wbr>10 <wbr></wbr>ms <wbr></wbr>210.77.139.186 <wbr></wbr> <wbr></wbr><br> 5 <wbr></wbr>〈10 <wbr></wbr>ms <wbr></wbr>10 <wbr></wbr>ms <wbr></wbr>20 <wbr></wbr>ms <wbr></wbr>210.77.139.170 <wbr></wbr> <wbr></wbr><br> 6 <wbr></wbr>〈10 <wbr></wbr>ms <wbr></wbr>〈10 <wbr></wbr>ms <wbr></wbr>10 <wbr></wbr>ms <wbr></wbr>211.99.193.154 <wbr></wbr> <wbr></wbr><br> 7 <wbr></wbr>〈10 <wbr></wbr>ms <wbr></wbr>10 <wbr></wbr>ms <wbr></wbr>〈10 <wbr></wbr>ms <wbr></wbr>211.99.199.204 <wbr></wbr> <wbr></wbr><br> Trace <wbr></wbr>complete. <wbr></wbr> <wbr></wbr><br> C:\〉 <wbr></wbr> <wbr></wbr><br> Ping得到的TTL=248，经过了7个路由器，减少了7，所以主机的TTL值是255。这样来判断吧。 <wbr></wbr> <wbr></wbr><br> 下面是一些主机的默认TTL值。 <wbr></wbr> <wbr></wbr><br> LINUX <wbr></wbr>Kernel <wbr></wbr>2.2.x <wbr></wbr>&amp; <wbr></wbr>2.4.x <wbr></wbr>ICMP <wbr></wbr>回显应答的 <wbr></wbr>TTL <wbr></wbr>字段值为 <wbr></wbr>64 <wbr></wbr> <wbr></wbr><br> FreeBSD <wbr></wbr>4.1, <wbr></wbr>4.0, <wbr></wbr>3.4; <wbr></wbr> <wbr></wbr><br> Sun <wbr></wbr>Solaris <wbr></wbr>2.5.1, <wbr></wbr>2.6, <wbr></wbr>2.7, <wbr></wbr>2.8; <wbr></wbr> <wbr></wbr><br> OpenBSD <wbr></wbr>2.6, <wbr></wbr>2.7, <wbr></wbr> <wbr></wbr><br> NetBSD <wbr></wbr> <wbr></wbr><br> HP <wbr></wbr>UX <wbr></wbr>10.20 <wbr></wbr> <wbr></wbr><br> ICMP <wbr></wbr>回显应答的 <wbr></wbr>TTL <wbr></wbr>字段值为 <wbr></wbr>255 <wbr></wbr> <wbr></wbr><br> Windows <wbr></wbr>95/98/98SE <wbr></wbr> <wbr></wbr><br> Windows <wbr></wbr>ME <wbr></wbr> <wbr></wbr><br> ICMP <wbr></wbr>回显应答的 <wbr></wbr>TTL <wbr></wbr>字段值为 <wbr></wbr>32 <wbr></wbr> <wbr></wbr><br> Windows <wbr></wbr>NT <wbr></wbr> <wbr></wbr><br> Windows <wbr></wbr>2000 <wbr></wbr> <wbr></wbr><br> ICMP <wbr></wbr>回显应答的 <wbr></wbr>TTL <wbr></wbr>字段值为 <wbr></wbr>128</p> 
<p align="left" style="">03/3/12 <wbr></wbr>23:03 <wbr></wbr><strong>oniontang</strong></p> 
<p align="left" style=""><strong> <wbr></wbr></strong></p> 
<p align="left" style=""><strong>ping和tracert命令详解</strong><br> <br> ing只有在安装了TCP/IP协议以后才可以使用： <wbr></wbr><br> ping <wbr></wbr>[-t] <wbr></wbr>[-a] <wbr></wbr>[-n <wbr></wbr>count] <wbr></wbr>[-l <wbr></wbr>length] <wbr></wbr>[-f] <wbr></wbr>[-i <wbr></wbr>ttl] <wbr></wbr>[-v <wbr></wbr>tos] <wbr></wbr>[-r <wbr></wbr>count] <wbr></wbr>[-s <wbr></wbr>count] <wbr></wbr>[-j <wbr></wbr>computer-list] <wbr></wbr>| <wbr></wbr>[-k <wbr></wbr>computer-list] <wbr></wbr>[-w <wbr></wbr>timeout] <wbr></wbr>destination-list <wbr></wbr><br> Options: <wbr></wbr><br> -t <wbr></wbr>Ping <wbr></wbr>the <wbr></wbr>specified <wbr></wbr>host <wbr></wbr>until <wbr></wbr>stopped.To <wbr></wbr>see <wbr></wbr>statistics <wbr></wbr>and <wbr></wbr>continue <wbr></wbr>- <wbr></wbr>type <wbr></wbr>Control-Break;To <wbr></wbr>stop <wbr></wbr>- <wbr></wbr>type <wbr></wbr>Control-C. <wbr></wbr><br> 不停的ping地方主机，直到你按下Control-C。 <wbr></wbr><br> 此功能没有什么特别的技巧，不过可以配合其他参数使用，将在下面提到。 <wbr></wbr><br> -a <wbr></wbr>Resolve <wbr></wbr>addresses <wbr></wbr>to <wbr></wbr>hostnames. <wbr></wbr><br> 解析计算机NetBios名。 <wbr></wbr><br> 示例：C:＼&gt;ping <wbr></wbr>-a <wbr></wbr>192.168.1.21 <wbr></wbr><br> Pinging <wbr></wbr>iceblood.yofor.com <wbr></wbr>[192.168.1.21] <wbr></wbr>with <wbr></wbr>32 <wbr></wbr>bytes <wbr></wbr>of <wbr></wbr>data: <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>192.168.1.21: <wbr></wbr>bytes=32 <wbr></wbr>time&lt;10ms <wbr></wbr>TTL=254 <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>192.168.1.21: <wbr></wbr>bytes=32 <wbr></wbr>time&lt;10ms <wbr></wbr>TTL=254 <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>192.168.1.21: <wbr></wbr>bytes=32 <wbr></wbr>time&lt;10ms <wbr></wbr>TTL=254 <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>192.168.1.21: <wbr></wbr>bytes=32 <wbr></wbr>time&lt;10ms <wbr></wbr>TTL=254 <wbr></wbr><br> Ping <wbr></wbr>statistics <wbr></wbr>for <wbr></wbr>192.168.1.21: <wbr></wbr><br> Packets: <wbr></wbr>Sent <wbr></wbr>= <wbr></wbr>4, <wbr></wbr>Received <wbr></wbr>= <wbr></wbr>4, <wbr></wbr>Lost <wbr></wbr>= <wbr></wbr>0 <wbr></wbr>(0% <wbr></wbr>loss),Approximate <wbr></wbr>round <wbr></wbr>trip <wbr></wbr>times <wbr></wbr>in <wbr></wbr>milli-seconds: <wbr></wbr><br> Minimum <wbr></wbr>= <wbr></wbr>0ms, <wbr></wbr>Maximum <wbr></wbr>= <wbr></wbr>0ms, <wbr></wbr>Average <wbr></wbr>= <wbr></wbr>0ms <wbr></wbr><br> 从上面就可以知道IP为192.168.1.21的计算机NetBios名为iceblood.yofor.com。 <wbr></wbr><br> -n <wbr></wbr>count <wbr></wbr>Number <wbr></wbr>of <wbr></wbr>echo <wbr></wbr>requests <wbr></wbr>to <wbr></wbr>send. <wbr></wbr><br> 发送count指定的Echo数据包数。 <wbr></wbr><br> 在默认情况下，一般都只发送四个数据包，通过这个命令可以自己定义发送的个数，对衡量网络速度很有帮助，比如我想测试发送50个数据包的返回的平均时间为多少，最快时间为多少，最慢时间为多少就可以通过以下获知： <wbr></wbr><br> C:＼&gt;ping <wbr></wbr>-n <wbr></wbr>50 <wbr></wbr>202.103.96.68 <wbr></wbr><br> Pinging <wbr></wbr>202.103.96.68 <wbr></wbr>with <wbr></wbr>32 <wbr></wbr>bytes <wbr></wbr>of <wbr></wbr>data: <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>202.103.96.68: <wbr></wbr>bytes=32 <wbr></wbr>time=50ms <wbr></wbr>TTL=241 <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>202.103.96.68: <wbr></wbr>bytes=32 <wbr></wbr>time=50ms <wbr></wbr>TTL=241 <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>202.103.96.68: <wbr></wbr>bytes=32 <wbr></wbr>time=50ms <wbr></wbr>TTL=241 <wbr></wbr><br> Request <wbr></wbr>timed <wbr></wbr>out. <wbr></wbr><br> ……………… <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>202.103.96.68: <wbr></wbr>bytes=32 <wbr></wbr>time=50ms <wbr></wbr>TTL=241 <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>202.103.96.68: <wbr></wbr>bytes=32 <wbr></wbr>time=50ms <wbr></wbr>TTL=241 <wbr></wbr><br> Ping <wbr></wbr>statistics <wbr></wbr>for <wbr></wbr>202.103.96.68: <wbr></wbr><br> Packets: <wbr></wbr>Sent <wbr></wbr>= <wbr></wbr>50, <wbr></wbr>Received <wbr></wbr>= <wbr></wbr>48, <wbr></wbr>Lost <wbr></wbr>= <wbr></wbr>2 <wbr></wbr>(4% <wbr></wbr>loss),Approximate <wbr></wbr>round <wbr></wbr>trip <wbr></wbr>times <wbr></wbr>in <wbr></wbr>milli-seconds: <wbr></wbr><br> Minimum <wbr></wbr>= <wbr></wbr>40ms, <wbr></wbr>Maximum <wbr></wbr>= <wbr></wbr>51ms, <wbr></wbr>Average <wbr></wbr>= <wbr></wbr>46ms <wbr></wbr><br> 从以上我就可以知道在给202.103.96.68发送50个数据包的过程当中，返回了48个，其中有两个由于未知原因丢失，这48个数据包当中返回速度最快为40ms，最慢为51ms，平均速度为46ms。<br> -l <wbr></wbr>size <wbr></wbr>Send <wbr></wbr>buffer <wbr></wbr>size. <wbr></wbr><br> 定义echo数据包大小。 <wbr></wbr><br> 在默认的情况下windows的ping发送的数据包大小为32byt，我们也可以自己定义它的大小，但有一个大小的限制，就是最大只能发送65500byt，也许有人会问为什么要限制到65500byt，因为Windows系列的系统都有一个安全漏洞（也许还包括其他系统）就是当向对方一次发送的数据包大于或等于65532时，对方就很有可能挡机，所以微软公司为了解决这一安全漏洞于是限制了ping的数据包大小。虽然微软公司已经做了此限制，但这个参数配合其他参数以后危害依然非常强大，比如我们就可以通过配合-t参数来实现一个带有攻击性的命令：（以下介绍带有危险性，仅用于试验，请勿轻易施于别人机器上，否则后果自负） <wbr></wbr><br> C:＼&gt;ping <wbr></wbr>-l <wbr></wbr>65500 <wbr></wbr>-t <wbr></wbr>192.168.1.21 <wbr></wbr><br> Pinging <wbr></wbr>192.168.1.21 <wbr></wbr>with <wbr></wbr>65500 <wbr></wbr>bytes <wbr></wbr>of <wbr></wbr>data: <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>192.168.1.21: <wbr></wbr>bytes=65500 <wbr></wbr>time&lt;10ms <wbr></wbr>TTL=254 <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>192.168.1.21: <wbr></wbr>bytes=65500 <wbr></wbr>time&lt;10ms <wbr></wbr>TTL=254 <wbr></wbr><br> ……………… <wbr></wbr><br> 这样它就会不停的向192.168.1.21计算机发送大小为65500byt的数据包，如果你只有一台计算机也许没有什么效果，但如果有很多计算机那么就可以使对方完全瘫痪，我曾经就做过这样的试验，当我同时使用10台以上计算机ping一台Win2000Pro系统的计算机时，不到5分钟对方的网络就已经完全瘫痪，网络严重堵塞，HTTP和FTP服务完全停止，由此可见威力非同小可。 <wbr></wbr><br> <br> -f <wbr></wbr>Set <wbr></wbr>Don&lt;|&gt;t <wbr></wbr>Fragment <wbr></wbr>flag <wbr></wbr>in <wbr></wbr>packet. <wbr></wbr><br> 在数据包中发送“不要分段”标志。 <wbr></wbr><br> 在一般你所发送的数据包都会通过路由分段再发送给对方，加上此参数以后路由就不会再分段处理。 <wbr></wbr><br> <br> -i <wbr></wbr>TTL <wbr></wbr>Time <wbr></wbr>To <wbr></wbr>Live. <wbr></wbr><br> 指定TTL值在对方的系统里停留的时间。 <wbr></wbr><br> 此参数同样是帮助你检查网络运转情况的。 <wbr></wbr><br> <br> -v <wbr></wbr>TOS <wbr></wbr>Type <wbr></wbr>Of <wbr></wbr>Service. <wbr></wbr><br> 将“服务类型”字段设置为 <wbr></wbr>tos <wbr></wbr>指定的值。<br> r <wbr></wbr>count <wbr></wbr>Record <wbr></wbr>route <wbr></wbr>for <wbr></wbr>count <wbr></wbr>hops. <wbr></wbr><br> 在“记录路由”字段中记录传出和返回数据包的路由。 <wbr></wbr><br> 在一般情况下你发送的数据包是通过一个个路由才到达对方的，但到底是经过了哪些路由呢？通过此参数就可以设定你想探测经过的路由的个数，不过限制在了9个，也就是说你只能跟踪到9个路由，如果想探测更多，可以通过其他命令实现，我将在以后的文章中给大家讲解。以下为示例： <wbr></wbr><br> C:＼&gt;ping <wbr></wbr>-n <wbr></wbr>1 <wbr></wbr>-r <wbr></wbr>9 <wbr></wbr>202.96.105.101 <wbr></wbr>（发送一个数据包，最多记录9个路由） <wbr></wbr><br> Pinging <wbr></wbr>202.96.105.101 <wbr></wbr>with <wbr></wbr>32 <wbr></wbr>bytes <wbr></wbr>of <wbr></wbr>data: <wbr></wbr><br> Reply <wbr></wbr>from <wbr></wbr>202.96.105.101: <wbr></wbr>bytes=32 <wbr></wbr>time=10ms <wbr></wbr>TTL=249 <wbr></wbr><br> Route: <wbr></wbr>202.107.208.187 <wbr></wbr>-&gt; <wbr></wbr><br> 202.107.210.214 <wbr></wbr>-&gt; <wbr></wbr><br> 61.153.112.70 <wbr></wbr>-&gt; <wbr></wbr><br> 61.153.112.89 <wbr></wbr>-&gt; <wbr></wbr><br> 202.96.105.149 <wbr></wbr>-&gt; <wbr></wbr><br> 202.96.105.97 <wbr></wbr>-&gt; <wbr></wbr><br> 202.96.105.101 <wbr></wbr>-&gt; <wbr></wbr><br> 202.96.105.150 <wbr></wbr>-&gt; <wbr></wbr><br> 61.153.112.90 <wbr></wbr><br> Ping <wbr></wbr>statistics <wbr></wbr>for <wbr></wbr>202.96.105.101: <wbr></wbr><br> Packets: <wbr></wbr>Sent <wbr></wbr>= <wbr></wbr>1, <wbr></wbr>Received <wbr></wbr>= <wbr></wbr>1, <wbr></wbr>Lost <wbr></wbr>= <wbr></wbr>0 <wbr></wbr>(0% <wbr></wbr>loss), <wbr></wbr><br> Approximate <wbr></wbr>round <wbr></wbr>trip <wbr></wbr>times <wbr></wbr>in <wbr></wbr>milli-seconds: <wbr></wbr><br> Minimum <wbr></wbr>= <wbr></wbr>10ms, <wbr></wbr>Maximum <wbr></wbr>= <wbr></wbr>10ms, <wbr></wbr>Average <wbr></wbr>= <wbr></wbr>10ms <wbr></wbr><br> 从上面我就可以知道从我的计算机到202.96.105.101一共通过了202.107.208.187 <wbr></wbr>，202.107.210.214 <wbr></wbr>, <wbr></wbr>61.153.112.70 <wbr></wbr>, <wbr></wbr>61.153.112.89 <wbr></wbr>, <wbr></wbr>202.96.105.149 <wbr></wbr>, <wbr></wbr>202.96.105.97这几个路由。<br> s <wbr></wbr>count <wbr></wbr>Timestamp <wbr></wbr>for <wbr></wbr>count <wbr></wbr>hops. <wbr></wbr><br> 指定 <wbr></wbr>count <wbr></wbr>指定的跃点数的时间戳。 <wbr></wbr><br> 此参数和-r差不多，只是这个参数不记录数据包返回所经过的路由，最多也只记录4个。 <wbr></wbr><br> -j <wbr></wbr>host-list <wbr></wbr>Loose <wbr></wbr>source <wbr></wbr>route <wbr></wbr>along <wbr></wbr>host-list. <wbr></wbr><br> 利用 <wbr></wbr>computer-list <wbr></wbr>指定的计算机列表路由数据包。连续计算机可以被中间网关分隔（路由稀疏源）IP <wbr></wbr>允许的最大数量为 <wbr></wbr>9。 <wbr></wbr><br> -k <wbr></wbr>host-list <wbr></wbr>Strict <wbr></wbr>source <wbr></wbr>route <wbr></wbr>along <wbr></wbr>host-list. <wbr></wbr><br> 利用 <wbr></wbr>computer-list <wbr></wbr>指定的计算机列表路由数据包。连续计算机不能被中间网关分隔（路由严格源）IP <wbr></wbr>允许的最大数量为 <wbr></wbr>9。 <wbr></wbr><br> -w <wbr></wbr>timeout <wbr></wbr>Timeout <wbr></wbr>in <wbr></wbr>milliseconds <wbr></wbr>to <wbr></wbr>wait <wbr></wbr>for <wbr></wbr>each <wbr></wbr>reply. <wbr></wbr><br> 指定超时间隔，单位为毫秒。 <wbr></wbr><br> 此参数没有什么其他技巧。 <wbr></wbr><br> ping命令的其他技巧：在一般情况下还可以通过ping对方让对方返回给你的TTL值大小，粗略的判断目标主机的系统类型是Windows系列还是UNIX/Linux系列，一般情况下Windows系列的系统返回的TTL值在100-130之间，而UNIX/Linux系列的系统返回的TTL值在240-255之间，当然TTL的值在对方的主机里是可以修改的，Windows系列的系统可以通过修改注册表以下键值实现： <wbr></wbr><br> [HKEY_LOCAL_MACHINE＼sys <wbr></wbr>tem＼CurrentControlSet＼Services＼Tcpip＼Parameters] <wbr></wbr><br> "DefaultTTL"=dword:000000ff <wbr></wbr><br> 255---FF <wbr></wbr><br> 　 <wbr></wbr>128---80 <wbr></wbr><br> 　 <wbr></wbr>64----40 <wbr></wbr><br> 　 <wbr></wbr>32----20<br> 在路由器上-c可以指定发送的包数.<br> 例如:ping <wbr></wbr>-c <wbr></wbr>10000 <wbr></wbr>x.x.x.x<br> 就会ping <wbr></wbr>10000个数据包.并统计丢包率. </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ccbb38b7447805a9a50b453c74a23700/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;开源库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7a75ec8b5a0fae5c02b19a654de23b5f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows 无效驱动器 问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>