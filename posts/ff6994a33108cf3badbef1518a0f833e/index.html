<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>模型压缩与量化 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="模型压缩与量化" />
<meta property="og:description" content="模型压缩目的是减少网络参数量；模型加速的目标则是降低计算复杂度。
模型压缩和加速可以通过多种方式来实现。
首先是针对网络结构本身进行优化改进，常见的如使用3x3的小卷积核取代大卷积核；average-pooling取代了full-connection layers；MobileNets中使用depth-wise convolution替代传统的卷积方式等。
除了根据人工经验和数学模型设计的特有算子结构外，还包括模型剪枝、量化、蒸馏方法。剪枝方法去除神经网络结构中不重要的部分；量化方法则是调整网络结构中的权重或激活值的表达精度；蒸馏方法则是把复杂网络结构的知识转移到较小网络结构上。
其次是在推理框架上做优化，成熟的轻量化框架如TensorRT/Tf-lite/NCNN/MNN等，这些框架能够实现编译优化、缓存优化、算子优化、稀疏存储与计算、加速指令集应用等。能显著的提升模型推理速度。
二．剪枝
剪枝流程
深度神经网络结构中，有着大量的冗余参数。在推理过程中，仅有少部分的权值参与有效的计算，并对推理结果产生主要影响。剪枝方法通过把网络结构中冗余的权值、节点或层去掉，减少网络的规模，降低计算复杂度。让模型在推理效果、推理速度上达到平衡。
类似的，模型剪枝的主要流程如下：
（1）训练一个性能较好的原始模型。原模型网络参数量较大，推理速度较慢。
（2）判断原模型中参数的重要程度。
（3）去除重要程度较低的参数。
（4）在训练集上微调，尽量避免由于网络结构变化而出现的性能下降。
（5）判断模型大小、推理速度、效果等是否满足要求，不满足则继续剪枝。剪枝类型 图. 模型剪枝
从剪枝的基本操作单元来看，可以分为“非结构化剪枝（Unstructured pruning）”和“结构化剪枝（Structured pruning）”两大类。
“非结构化剪枝”主要通过对权重矩阵中的单个或整行、整列的权重值进行修剪。修剪后的新权重矩阵会变成稀疏矩阵（被修剪的值会设置为0）。因而除非硬件平台和计算库能够支持高效的稀疏矩阵计算，否则剪枝后的模型是无法获得真正的性能提升的。
“结构化剪枝”的基本修剪单元是滤波器或权重矩阵的一个或多个Channel。由于结构化剪枝没有改变权重矩阵本身的稀疏程度，现有的计算平台和框架都可以实现很好的支持。
2.1 非结构化剪枝
2.1.1 权值剪枝
剪掉神经元节点之间的不重要的连接。相当于把权重矩阵中的单个权重值设置为0。一般的，会对权重矩阵中所有的数值按照大小排序，把排在后面的一定比例的值设为0即可。
图. 权值剪枝的矩阵表现
2.1.2 神经元剪枝
把权重矩阵中某个神经元节点去掉，则和神经元相连接的突触也要全部去除。相当于同时去除权重矩阵中的某一行和列。如何判断神经元节点的重要程度呢？可以通过计算神经元对应的行和列的权重值的平方和的根的大小进行排序，把排序在后面一定比例的神经元节点去掉。
图. 神经元剪枝的矩阵表现
2.2 结构化剪枝
2.2.1 filter-wise
一个卷积核被剪枝，那么其前一个Feature Map和下一个Feature Map 都会发生相应的变化。
图. Filter-wise剪枝
以上图为例，在第i层卷积中，其中第2、5个卷积核被剪掉（卷积核数量变少，每个卷积核的shape不变）；当i-1层的featruemap经过第i层卷积矩阵卷积后得到的第i层feature map，其中的第2、5个channel也相应的被去除。为了匹配第i层featuremap通道维度产生的变化，第i&#43;1层的卷积中的每个卷积核的第2、5个channel的权重被去除（卷积核数量不变，但每个卷积的shape发生改变）。
为方便观察，把上图中每层卷积核排列成卷积核矩阵的形状，如下图kernel matrix。通过这种形式，我们继续探讨两种剪枝形式。
◎ 单层中卷积核剪枝
图. 剪掉一个卷积核，相关的feature层也同时被剪掉
如上图所示，kernel matrix 中的ni表示第i层feature map的通道深度；ni&#43;1表示第i&#43;1层feature map的通道深度。kernelmatrix中每个卷积核的尺寸为k x k。
从第i个卷积层剪掉n个卷积核的算法过程如下：
（1）计算每个卷积核的权重绝对值之和。
（2）根据的值大小排序。
（3）将最小的n个卷积核及对应的feature map剪掉。下一个卷积层中相关的卷积核也要移除。
（4）生成了第i层和第i&#43;1层新的权重矩阵，剩余的权重参数被复制到新模型中。
◎ 跨多层剪枝
在上图中的i&#43;1层的卷积矩阵中，由于i&#43;1层的featuremap减少一个通道，导致该卷积层中相关的卷积核（一行）被剪枝；如果同时要对该层卷积矩阵中某一列进行剪枝该，则这层卷积矩阵既被上一层的feature map影响，又能影响下一层feature map。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ff6994a33108cf3badbef1518a0f833e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-02T16:38:08+08:00" />
<meta property="article:modified_time" content="2022-08-02T16:38:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">模型压缩与量化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>模型压缩目的是减少网络参数量；模型加速的目标则是降低计算复杂度。<br> 模型压缩和加速可以通过多种方式来实现。<br> 首先是针对网络结构本身进行优化改进，常见的如使用3x3的小卷积核取代大卷积核；average-pooling取代了full-connection layers；MobileNets中使用depth-wise convolution替代传统的卷积方式等。<br> 除了根据人工经验和数学模型设计的特有算子结构外，还包括模型剪枝、量化、蒸馏方法。剪枝方法去除神经网络结构中不重要的部分；量化方法则是调整网络结构中的权重或激活值的表达精度；蒸馏方法则是把复杂网络结构的知识转移到较小网络结构上。<br> 其次是在推理框架上做优化，成熟的轻量化框架如TensorRT/Tf-lite/NCNN/MNN等，这些框架能够实现编译优化、缓存优化、算子优化、稀疏存储与计算、加速指令集应用等。能显著的提升模型推理速度。<br> 二．剪枝</p> 
<ol><li>剪枝流程<br> 深度神经网络结构中，有着大量的冗余参数。在推理过程中，仅有少部分的权值参与有效的计算，并对推理结果产生主要影响。剪枝方法通过把网络结构中冗余的权值、节点或层去掉，减少网络的规模，降低计算复杂度。让模型在推理效果、推理速度上达到平衡。<br> 类似的，模型剪枝的主要流程如下：<br> （1）训练一个性能较好的原始模型。原模型网络参数量较大，推理速度较慢。<br> （2）判断原模型中参数的重要程度。<br> （3）去除重要程度较低的参数。<br> （4）在训练集上微调，尽量避免由于网络结构变化而出现的性能下降。<br> （5）判断模型大小、推理速度、效果等是否满足要求，不满足则继续剪枝。</li><li>剪枝类型</li></ol> 
<p>图. 模型剪枝<br> 从剪枝的基本操作单元来看，可以分为“非结构化剪枝（Unstructured pruning）”和“结构化剪枝（Structured pruning）”两大类。<br> “非结构化剪枝”主要通过对权重矩阵中的单个或整行、整列的权重值进行修剪。修剪后的新权重矩阵会变成稀疏矩阵（被修剪的值会设置为0）。因而除非硬件平台和计算库能够支持高效的稀疏矩阵计算，否则剪枝后的模型是无法获得真正的性能提升的。<br> “结构化剪枝”的基本修剪单元是滤波器或权重矩阵的一个或多个Channel。由于结构化剪枝没有改变权重矩阵本身的稀疏程度，现有的计算平台和框架都可以实现很好的支持。<br> 2.1 非结构化剪枝<br> 2.1.1 权值剪枝<br> 剪掉神经元节点之间的不重要的连接。相当于把权重矩阵中的单个权重值设置为0。一般的，会对权重矩阵中所有的数值按照大小排序，把排在后面的一定比例的值设为0即可。</p> 
<p>图. 权值剪枝的矩阵表现<br> 2.1.2 神经元剪枝<br> 把权重矩阵中某个神经元节点去掉，则和神经元相连接的突触也要全部去除。相当于同时去除权重矩阵中的某一行和列。如何判断神经元节点的重要程度呢？可以通过计算神经元对应的行和列的权重值的平方和的根的大小进行排序，把排序在后面一定比例的神经元节点去掉。</p> 
<p>图. 神经元剪枝的矩阵表现<br> 2.2 结构化剪枝<br> 2.2.1 filter-wise<br> 一个卷积核被剪枝，那么其前一个Feature Map和下一个Feature Map 都会发生相应的变化。</p> 
<p>图. Filter-wise剪枝<br> 以上图为例，在第i层卷积中，其中第2、5个卷积核被剪掉（卷积核数量变少，每个卷积核的shape不变）；当i-1层的featruemap经过第i层卷积矩阵卷积后得到的第i层feature map，其中的第2、5个channel也相应的被去除。为了匹配第i层featuremap通道维度产生的变化，第i+1层的卷积中的每个卷积核的第2、5个channel的权重被去除（卷积核数量不变，但每个卷积的shape发生改变）。<br> 为方便观察，把上图中每层卷积核排列成卷积核矩阵的形状，如下图kernel matrix。通过这种形式，我们继续探讨两种剪枝形式。<br> ◎ 单层中卷积核剪枝</p> 
<p>图. 剪掉一个卷积核，相关的feature层也同时被剪掉<br> 如上图所示，kernel matrix 中的ni表示第i层feature map的通道深度；ni+1表示第i+1层feature map的通道深度。kernelmatrix中每个卷积核的尺寸为k x k。<br> 从第i个卷积层剪掉n个卷积核的算法过程如下：<br> （1）计算每个卷积核的权重绝对值之和。<br> （2）根据的值大小排序。<br> （3）将最小的n个卷积核及对应的feature map剪掉。下一个卷积层中相关的卷积核也要移除。<br> （4）生成了第i层和第i+1层新的权重矩阵，剩余的权重参数被复制到新模型中。</p> 
<p>◎ 跨多层剪枝<br> 在上图中的i+1层的卷积矩阵中，由于i+1层的featuremap减少一个通道，导致该卷积层中相关的卷积核（一行）被剪枝；如果同时要对该层卷积矩阵中某一列进行剪枝该，则这层卷积矩阵既被上一层的feature map影响，又能影响下一层feature map。<br> 方法1：分别独立的做每一次剪枝，既黄色的卷积核每次都会参与计算权重绝对值之和。<br> 方法2：采用贪心策略，已经被剪枝过的卷积核（黄色）不在参与下一次的剪枝。实验显示贪心策略的剪枝方式更好一些。</p> 
<p>图. 跨多层剪枝时，计算权重值和的方式<br> 2.2.2 channel-wise</p> 
<p>图. 利用BN放缩因子来修剪Channel<br> 以《Learning Efficient Convolutional Networks Through Network Slimming》为例。<br> conv-layer的每个channel的重要程度可以和batchnorm层关联起来，如果某个channel后的batchnorm层中对应的scaling factor足够小，就说明该channel的重要程度低，可以被忽略。如上图中橙色的两个通道被剪枝。<br> batchnorm的公式如下所示：</p> 
<p>其中：表示channel scaling factors。<br> 为了增加的稀疏程度，方便对channel进行剪枝，训练时需要对每个batchnorm层的scaling factor增加L1的约束。<br> channel-wise和filter-wise既有区别，也有联系。两者使用的剪枝评判方法不同，但最终都会体现在对卷积核或卷积核中某些layer的剪枝。<br> 2.2.3 shape-wise<br> filter-wise剪枝是对完整的卷积核（k x k x c）进行剪枝；channel-wise是对所有卷积核中相同layer进行剪枝。shape-wise的剪枝颗粒度相对而言则更小一些。剪枝对象是所有卷积核中相同位置的部分权重的剪枝。如下图所示可以看到三种剪枝的区别。</p> 
<p>图. 几种剪枝方式的图示<br> 由于每个卷积核中不重要的权重值的位置并不相同，这种剪枝方式可能会导致模型网络丢掉有效的信息。<br> 2.2.4 stripe-wise pruning (SWP)<br> 这种方法是腾讯优图发表的一篇论文《PRUNING FILTER IN FILTER》，从另外一个维度对权重矩阵中的卷积核进行剪枝：针对每个卷积核的depth维度整体剪枝。但是不同卷积核剪枝的位置和数量不相同。<br> 如下图所示，每个3x3xC的卷积核，被重组为9个1x1xC的stripe，然后对这些stripes做剪枝。</p> 
<p>图. stripe-wise剪枝，卷积核被重组</p> 
<p>图. strip-wise剪枝示意图<br> 论文通过在训练过程中引入FS（Filter Skeleton）模块，学习得到卷积核中每个stripe的重要程度。训练结束后每个卷积核就会得到一个特有权重的FS。并根据FS的权重值，确定要对哪些stripes进行剪枝。如下图：</p> 
<p>图. FS模块自动学习每个stripe的重要性<br> 相对于filter-wise剪枝有两个优势：首先，剪枝的操作对象数量变为原来的KxK倍（K为卷积核尺寸），这意味着可以获得更高的剪枝比率。其次在一些数据集上，即使不经过fine tuning，剪枝后的性能依然很好，这是由于FS模块为每个卷积核学到了最佳的形状。而filter-wise剪枝这破坏了原来最佳的网络结构，必须要经过fine tuning才会有好的表现。<br> 3. 剪枝评判标准<br> 最常使用的是贪心法，按照大小顺序排列，然后按照一定的比例去除。比如在非结构化剪枝中，比较权值本身的大小；或者结构化剪枝中比较卷积核的权重绝对值之和的大小等。<br> 在使用贪心法时，通常会使用一些策略以便于能更有效的剪枝：训练时在loss中加入L1正则化，使得权重稀疏化；在结构化剪枝时，使用group lasso来得到稀疏权重。当然L1正则化也可以使用在结构化剪枝中，如前面提到的channel-wise剪枝。<br> 4. Sparsity Ratio / Pruning Rate<br> 如果预定义的稀疏率用于所有的层，称之为全局稀疏率；如果不同的层有不同的预设稀疏率，则每层的稀疏率称为局部稀疏率。全局稀疏率设置方便，但是颗粒度较粗，没有考虑到不同的层对于剪枝的敏感程度。虽然为每层单独设置局部稀疏率较为繁琐，但能取得更好的效果。<br> 自适应稀疏率通常要有剪枝算法自动得到每层的值。如前面提到的stripe-wise中FS模块，就是在训练过程中获取每个FS的稀疏率。<br> 5. FINE TUNING<br> 由于剪枝直接改变了原模型最佳的网络参数/结构，往往对精度影响很大。需要通过finetuning 把损失的精度恢复回来。通常情况下，剪枝和fine tuning会交替进行，避免一次性孤独剪枝导致精度难以恢复。<br> 三．量化</p> 
<ol><li>量化<br> 模型量化方法本质上是函数映射。根据映射函数是否线性可以把量化分为线性量化和非线性量化。<br> 1.1 线性量化<br> 线性量化是目前最常用的量化方法，尤其是在工业界应用比较成熟的8比特量化方案采用的都是线性量化。<br> 模型量化建立了高精度的浮点数值和量化后低精度的定点数值之间的数据映射。浮点转换为定点的公式如下：</li></ol> 
<p>定点转换为浮点的公式如下所示：</p> 
<p>其中R表示输入的浮点数据，Q表示量化之后的定点数据，Z表示偏移量，或零点/最小值对应的量化数值，S表示缩放系数。S的求解方式如下：</p> 
<p>其中 、分别表示输入浮点数据中的最大值和最小值， 、分别表示量化后最大定点值和最小定点值。</p> 
<p>1.2 非线性量化<br> “非线性”映射函数多种多样，通常需要根据不同场景的权值输入分布特点，研究使用何种映射方式。<br> 非线性映射最显著的一个特点是，可以把不同重要程度的权值，映射到不同的量化范围。假如，权值输入主要分布在[，]中，其余区间的权值虽然比例较少，但也不能忽略，则可以通过非线性函数，把[，]区间中的权值映射到更大的量化后区间内，增加训练过程对于主要权值分布的敏感性。<br> 在模型量化早期，会使用聚类方法，把权值聚为若干个类别，然后每个类别量化为同一个定值。这也一种非常典型的非线性量化方式。<br> 2. 量化方法<br> 2.1 聚类量化<br> 典型代表如MIT韩松教授的 Deep Compression 论文，这篇论文中综合使用了剪枝、量化、编码等技术实现模型的轻量化。其中，量化这一部分的基本操作如图中所示：</p> 
<p>图. 聚类量化示意<br> 如上图所示，在这个4x4的权重矩阵中，所有权值的大小都在[-1.08, 2.12]之间，如果以-1，0，1，2这几个离散整数作为聚类中心，然后对权重矩阵中所有的权值聚类，并把同一类中的所有权值四舍五入为聚类中心的值即可。同一类的权值梯度相加做为量化后聚类终中心的梯度用于更新权重。图中相同颜色的权值表示属于同一个聚类组。<br> 作者采用K-means聚类方法，把原始的m个权重 W={W1，W2，…，Wm} 量化为k个聚类中心 C={C1，C2，…，Cm}。聚类算法最小化组内误差，目标函数如下所示：</p> 
<p>K-means 初始聚类中心的选择非常关键。常见的初始化方法三种：均匀初始化、随机初始化和按密度初始化。论文中证明最好使用均匀初始化，均匀初始化的方法是统计权值的最小值和最大值，并把数值区间平分为K份，以每一份的分界点处的权值作为聚类的中心。<br> 2.2 对数量化<br> 对数量化后的定点值是2的幂次倍，既两个邻近定点数值之间是在以2为底的对数域上均匀分布的。如量化定点值为，，，在对数域上的分布为-1，-2，-3。这种量化特性使得模型在推理时可以通过移位运算来实现快速的计算。<br> 下图展示了对数量化的一种方式，权重矩阵中权值量化到2的幂次的定点值上。与聚类量化方法不同的是，对每层的权重采用分批量化，而不是一次量化整个权重。这样分批量化的方式能够让部分权重保持高精度，更方便的进行训练优化。</p> 
<p>图. 对数量化并逐步量化过程<br> 2.3 二值量化（1bit）<br> 二值量化，也称作1bit量化。是目前压缩率最高的量化方法。有两种方法实现权重的二值化。一种是使用符号函数，如下面公式：</p> 
<p>另一种是以一定概率随机量化，如下面公式：</p> 
<p>其中，概率的计算方式如下：</p> 
<p>为了保持精度，权重在前向传播和反向传播计算的时候进行二值化，但是在进行参数更新的时候使用浮点类型。<br> 虽然二值量化的效率非常高，但是在模型精度损失非常大，落地比较困难。<br> 2.4 8bit量化<br> 8bit量化是目前在工程上应用最为成熟的方案。该方案非常好的平衡了推理速度和精度损失之间的矛盾。Google的Tensorflow和NVIDIA的TensorRT等框架都提供了对8bit量化的支持。Google采用的是非对称量化方案，而NVIDIA采用的是对称量化方案。<br> 对称量化和非对称量化都属于线性量化。常见的线性量化过程可以用下面的公式来表示示：<br> R=Round(S(Q−Z))<br> R表示的是原始的float32数值；<br> Z表示的是float32数值的偏移量，在很多地方又叫Zero Point；<br> S表示的是float32的缩放因子，在很多地方又叫Scale；<br> Q表示的是量化后的一个整数值。</p> 
<p>2.4.1 对称量化</p> 
<p>图. 对称量化<br> 如上图所示，对称量化将输入数据映射到[-128,127]的范围内。但是这种方法隐藏着一个问题：如果输入数据中存在偏离正常分布较远的离群点，则会导致比较大的量化精度损失；因此在实际使用时，通常会选择介于127和max(|xf|)之间的一个阈值T对输入数据进行截断，以避免离群点对量化精度额影响。既量化的输入区间从[-max(|xf|), max(|xf|)]变为[-|T|, +|T|]。<br> 对称量化需要保证原始的输入数据中的零点通过映射公式后仍然对应[-128,127]区间的零点。在上面的公式中，当 Z=0，且 Q=0时恰好有R=0。<br> 当Z=0，S的取值可以使用如下的公式表示。</p> 
<p>2.4.2 非对称量化</p> 
<p>图. 非对称量化<br> 如上图所示，非对称量化将输入数据映射到[0,255]的范围内。在非对称量化中，我们可以取Z=min(Xf)，S的取值可以使用如下的公式:</p> 
<p>Z值是区分对称量化和非对称量化的重要特点。当Z为零时，代表的是对称量化；Z不为零，代表的是非对称量化。</p> 
<p>2.4.3 量化步骤<br> （1）选择合适的量化方法，确定选用对称量化或者非对称量化；<br> （2）统计输入数据的数值区间[min_value, max_value]；<br> （3）根据量化方法，以及输入区间计算量化参数：零点值Z和缩放系数S。<br> （4）根据转换公式，对输入的float32精度的数据转换为int8精度的数据。<br> （5）可以尝试不同的S和Z，验证量化后的模型效果。<br> 2.5训练后量化和训练感知量化<br> 量化过程不可避免的会带来模型精度的损失，为了能够尽量保持原模型的精度，通常会对量化后的模型做fine tuning，或者进行重新训练。这种方式称作“训练感知量化”。<br> 如果模型量化的精度能够满足使用要求，则会忽略掉finetuning和重训过程，这种简单直接的量化方式称作“训练后量化”。<br> 训练感知量化能够获得更高的量化后模型精度，但是量化过程较为繁琐；训练后量化过程简单快速，但是模型精度损失会较大。尤其是规模较小的模型，有时可能会导致无法使用。</p> 
<p>2.5.1 训练感知量化（Quantization Aware Training）</p> 
<p>图. QAT流程<br> QAT的量化方法如下：<br> （1）训练一个高比特的浮点模型。<br> （2）确定模型网络中需要量化的部分，并在网络相应位置插入伪量化的Ops。<br> （3）在模拟量化过程（simulated quantization，伪量化）的模式下迭代训练。<br> （4）存储量化参数，生成并优化低比特的量化推理模型。<br> （5）使用量化模型执行推理。</p> 
<p>在训练过程中引入量化操作会面临一个问题，量化后的数值是离散的，在反向传播时无法进行求导。因此引入了伪量化模块。如下图所示。</p> 
<p>图. 伪量化训练过程<br> 在上图中的模型网络中，有两个部分添加了伪量化的Ops。一是权重矩阵weights在进入卷积之前先完成量化；另一个是激活函数的输出部分做量化。这种操作能够模拟量化产生的误差，并在训练过程中影响到权值的更新。<br> Google在量化白皮说中对量化的模块有明确的定义：</p> 
<p>其中x就是量化模块前的输入值，是原平滑连续区间的浮点型数值；在经过量化后，又转到了浮点型数值，只不过新的浮点区间并不是平滑连续的。这种伪量化（simulated quantization）方法能够有效减轻梯度传播中的量化累积误差。尤其是对参数规模较小的模型。</p> 
<p>下图展示了Google 在量化训练时采用的伪量化方法，让网络的优化更加简单。</p> 
<p>图. 伪量化的精度转换<br> 因为模拟量化方程在各个位置的导数都为0，不能求反向传播时的梯度，在实际的工程中会使用一种近似方程，定义如下公式。称为直通滤波器（STE,straight through estimator)。<br> 如下图所示，在前向传播时会对输入权值做量化，但是在反向传播时梯度值会直接通过STE。</p> 
<p>图. 直通滤波器STE</p> 
<p>2.5.2 训练后量化（Post Training Quantization）</p> 
<p>图.PQT<br> 相较于训练感知量化，训练后量化流程更为简单。主要流程如下：<br> （1）准备数据集，用于对量化模型进行量化参数校正。<br> （2）以训练好的高精度模型为基准，使用校正数据集对其量化。<br> （3）统计权重和激活值的数值范围，确定量化参数。<br> （4）使用量化参数对模型进行量化。</p> 
<p>◎权重量化和激活量化<br> 权重量化是指仅对模型中的weights进行量化。由于网络权重在训练结束后都是确定的值，因而通过对每一层权值的统计就可以得到量化参数。这时是不需要Calibaration Data参与的。既Data Free。<br> 但是如果还需要对网络中的激活值进行量化，既权重的卷积输出（也可能是经过激活函数后的输出）。由于feature的数值范围需要动态的获取，因而就需要Calibration Data作为数据输入，通过前向推理产生的各层的feature统计量化参数。</p> 
<p>◎ 量化参数的更新<br> 对激活值量化时，需要根据输入的Calibration Data动态的统计量化参数。通常会采用一些策略来确定更有效的量化参数：<br> （1）统计每个batch的量化参数，通过指数平滑方法更新参数值。<br> （2）统计量化参数时，需要去除偏离数据正常分布较远的离群点，以免造成大的量化误差。<br> （3）使用KL散度评估模型量化产生的信息损失，选择KL散度最小时的量化参数量化模型。如TensorRT使用该方法度量INT8的信息损失。<br> 3. 量化总结<br> ◎ 模型量化：<br> （1）选择训练后量化方法时，可以先尝试使用权重的对称逐通道量化。当精度出现出现损失时，需要考虑fine tune。<br> （2）使用训练感知量化能够进一步减小量化模型和浮点型模型的精度差距。采用8bit量化时可以将精度损失控制在5%以内，甚至对所有层做4bit量化后也能有同样的精度表现。</p> 
<p>◎ 性能表现：<br> （1）在CPU上，8bit量化推理能够获得2到3倍的速度提升。在专为低精度向量计算优化过的特定处理器上，如支持HVX的骁龙DSP，和原浮点型模型推理速度相比能够加速10倍。<br> （2）使用均匀量化（线性量化）可以在保持精度不变的情况下缩小4倍的模型大小。使用非均匀量化（非线性量化）技术则能够实现更高的压缩比，比如K-means聚类量化。</p> 
<p>◎ 模型结构和量化的关系：<br> （1）模型大小和压缩率之间存在明确的折中关系。规模越大的模型对量化误差的容忍程度越高。<br> （2）对于某一个模型结构，可以在特征数量（权重激活的数量）和量化之间进行折中，使用越多的特征数量参与量化，则卷积核可以相应支持更低的比特位宽。<br> （3）训练过程中不约束激活函数的输出范围，而是直接对输出进行量化，这样能进一步提升的精度。从一些实验结果看出，使用ReLU做为激活函数要优于ReLU6。<br> 引用<br> ● https://jinzhuojun.blog.csdn.net/article/details/100621397<br> ● https://cs.nju.edu.cn/wujx/paper/Pruning_Survey_MLA21.pdf<br> ● https://blog.csdn.net/weixin_49457347/article/details/117110458<br> ● https://zhuanlan.zhihu.com/p/138059904<br> ● https://blog.csdn.net/wspba/article/details/75675554<br> ● http://fjdu.github.io/machine/learning/2016/07/07/quantize-neural-networks-with-tensorflow.html<br> ● https://zhuanlan.zhihu.com/p/45496826<br> ● https://zhuanlan.zhihu.com/p/361957385<br> ● https://zhuanlan.zhihu.com/p/374374300<br> ● https://blog.csdn.net/WZZ18191171661/article/details/103332338<br> ● https://zhuanlan.zhihu.com/p/58182172<br> ● https://on-demand.gputechconf.com/gtc/2017/presentation/s7310-8-bit-inference-with-tensorrt.pdf<br> ● https://developer.download.nvidia.cn/video/gputechconf/gtc/2020/presentations/s21664-toward-int8-inference-deploying-quantization-aware-trained-networks-using-tensorrt.pdf<br> ● 《DEEP COMPRESSION: COMPRESSING DEEP NEURAL NETWORKS WITH PRUNING, TRAINED QUANTIZATION AND HUFFMAN CODING》<br> ● 《Learning Structured Sparsity in Deep Neural Networks》<br> ● 《Learning Effificient Convolutional Networks through Network Slimming》<br> ● 《Accelerating Convolutional Neural Networks by Group-wise 2D-fifilter Pruning》<br> ● 《PRUNING FILTERS FOR EFFICIENT CONVNETS》<br> ● 《Quantizing deep convolutional networks for effificient inference: A whitepaper》<br> ● 《Data-Free Quantization Through Weight Equalization and Bias Correction》<br> ● 《PRUNING FILTER IN FILTER》</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b1ddef9135536724f4061c25287c9a21/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">图像质量指标：PSNR、SSIM、MSE</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/18d6bb27e7eaafbc91feac00c6255051/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">圣杯布局与双飞翼布局</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>