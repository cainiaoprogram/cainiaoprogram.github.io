<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CTP源码分析1 CTP结构及概述 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CTP源码分析1 CTP结构及概述" />
<meta property="og:description" content="CTP做了什么
试想一个情景，在一定的物理空间中有很多的传感器，这些传感器会和你的一个手持设备进行通信，返回一些数据供你使用，那么这个通信应该如果做呢。最简单的一种想法就是这些节点和直接和手持设备进行通信，这就要求所有的传感器（通信节点）都在手持设备的通信范围之内，这就大大缩小了传感器可以放置的物理空间。而CTP通过在传感器以及手持设备之间组网，通过传感器与手持设备之间的多跳通信大大扩展了传感器放置的物理空间。换言之传感器既充当了信息的的采集和发送者，又充当了其他传感器信息的转发者，而传感器（普通节点）和手持节点之间就形成了一个汇聚树，手持设备（将信息进行集中汇总的节点）就是这个汇聚树的根。
我们将这个场景抽象出来，就是这样：
左边是最简单的思路，右边是CTP的方式
CTP如何实现
CTP（汇聚树协议）实现了灵活动态的树状拓扑结构，并满足拓扑中其他节点与根节点的单向通信。为了实现灵活动态的拓扑结构变化，CTP蕴含了两个稳定有效的汇聚树原则，这些原则可以让汇聚树得以获得稳定有效的连接质量估计，并且通过连接质量的估计值获得通往根节点的路径。当每个节点都获得通往根节点的路径之后，汇聚树也就形成了。
第一个原则是保证数据通道的有效性原则。CTP协议在数据传输的时候可以动态地进行拓扑结构的探测，快速发现并且修复路由环路。第二个就是自适应信标（beacon）原则，根据CTP协议，每个节点都会定时地发送广播帧，来进行链路质量的估计和拓扑结构的建立。而广播帧发送的时间间隔并不是固定的，CTP扩展了涓流算法（Trickle code），在广播帧的发送的时间间隔方面做了文章，在兼顾了路径修理延迟的基础上可以发送更少的广播帧。
TinyOS实现了CTP协议，旨在达成汇聚树协议的4大目标：
1、可靠性：99.9%的包发送成功率，即便在比较恶劣的条件下也可以达到90%的包发送成功率。
2、健壮性：汇聚树协议可以实现灵活的拓扑调整，可以根据节点的实时位置和网络情况自动变换拓扑而不需要人为的干涉。
3、高效率：只需要发送少量的数据包就可以达到高效性和健壮性的目标。Trickle算法和通过数据包发送成功率来计算链路质量的方式功不可没。
4、硬件独立性
CTP协议在结构上一共分为3层，从下到上分别是：
1、链路质量估计层。在这里有LEEP协议来实现Trickle算法，维护一个链路质量估计表，统计周边节点和此节点的连接质量。
2、路由引擎。这一层将进行路由帧的发送，值得一提的是，路由帧的发送使用的书链路质量估计层提供的发送接口，这个发送接口在路由帧的头部和尾部分别套上了LEEP帧的帧头和帧尾（header and footer）。这意味着路由的形成、链路质量的估计2位一体。
3、转发引擎。这一层主要是进行数据包的发送和其他节点数据包的转发，并且通过ACK帧来计算转发的成功率。将成功率回馈给链路质量估计层。由此来看，汇聚树中所有的数据包都将直接或者间接对链路质量估计值产生影响。此外转发引擎还维护了一个发送队列，这个发送队列提供了阻塞警告。
上面就是CTP结构的示意图。
接着说转发引擎。
CTP之所以可以实现灵活的拓扑主要是因为每个节点都可以灵活地找出在不同的网络环境下的父节点，无论是转发帧还是此节点自己发送的数据帧，都是发往在那个时刻的父节点的。但是这样子很可能会出现被称之为“路由环路”东西。这种情况是绝对不允许存在的，这样子会导致数据包的循环发送，并且数据包永远也到不了根节点，所以在转发引擎中还做了路由环路的侦测工作，一旦发现路由环路，那么发现路由环路的节点就要从路由表选出一个信号强度“合适”的父节点代替现有父节点。
帧类型
CTP一共两种数据帧，一个是路由帧（LEEP帧），还有一种是数据帧，路由帧由路由引擎发送，负责组网工作。数据帧是由转发引擎发送，是基于CTP的数据平台一切功能的基础。
路由帧：
数据帧：
具体功能后面展开。
以上就是CTP三个模块的工作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/959d027e3528dfb90366ceb443aaedc8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-08-10T10:55:19+08:00" />
<meta property="article:modified_time" content="2016-08-10T10:55:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CTP源码分析1 CTP结构及概述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><u>CTP做了什么</u></strong></p> 
<p>试想一个情景，在一定的物理空间中有很多的传感器，这些传感器会和你的一个手持设备进行通信，返回一些数据供你使用，那么这个通信应该如果做呢。最简单的一种想法就是这些节点和直接和手持设备进行通信，这就要求所有的传感器（通信节点）都在手持设备的通信范围之内，这就大大缩小了传感器可以放置的物理空间。而CTP通过在传感器以及手持设备之间组网，通过传感器与手持设备之间的多跳通信大大扩展了传感器放置的物理空间。换言之传感器既充当了信息的的采集和发送者，又充当了其他传感器信息的转发者，而传感器（普通节点）和手持节点之间就形成了一个汇聚树，手持设备（将信息进行集中汇总的节点）就是这个汇聚树的根。</p> 
<p><br> </p> 
<p>我们将这个场景抽象出来，就是这样：</p> 
<p>左边是最简单的思路，右边是CTP的方式</p> 
<p><img src="https://images2.imgbox.com/db/00/d4JiMkWV_o.png" alt=""><br> </p> 
<p><strong><u><br> </u></strong></p> 
<p><strong><u><br> </u></strong></p> 
<p><strong><u>CTP如何实现</u></strong></p> 
<p>CTP（汇聚树协议）实现了灵活动态的树状拓扑结构，并满足拓扑中其他节点与根节点的单向通信。为了实现灵活动态的拓扑结构变化，CTP蕴含了两个稳定有效的汇聚树原则，这些原则可以让汇聚树得以获得稳定有效的连接质量估计，并且通过连接质量的估计值获得通往根节点的路径。当每个节点都获得通往根节点的路径之后，汇聚树也就形成了。</p> 
<p><br> </p> 
<p>第一个原则是保证数据通道的有效性原则。CTP协议在数据传输的时候可以动态地进行拓扑结构的探测，快速发现并且修复路由环路。第二个就是自适应信标（beacon）原则，根据CTP协议，每个节点都会定时地发送广播帧，来进行链路质量的估计和拓扑结构的建立。而广播帧发送的时间间隔并不是固定的，CTP扩展了涓流算法（Trickle code），在广播帧的发送的时间间隔方面做了文章，在兼顾了路径修理延迟的基础上可以发送更少的广播帧。</p> 
<p><br> </p> 
<p>TinyOS实现了CTP协议，旨在达成汇聚树协议的4大目标：</p> 
<p>1、可靠性：99.9%的包发送成功率，即便在比较恶劣的条件下也可以达到90%的包发送成功率。</p> 
<p>2、健壮性：汇聚树协议可以实现灵活的拓扑调整，可以根据节点的实时位置和网络情况自动变换拓扑而不需要人为的干涉。</p> 
<p>3、高效率：只需要发送少量的数据包就可以达到高效性和健壮性的目标。Trickle算法和通过数据包发送成功率来计算链路质量的方式功不可没。</p> 
<p>4、硬件独立性</p> 
<p><br> </p> 
<p>CTP协议在结构上一共分为3层，从下到上分别是：</p> 
<p>1、链路质量估计层。在这里有LEEP协议来实现Trickle算法，维护一个链路质量估计表，统计周边节点和此节点的连接质量。</p> 
<p>2、路由引擎。这一层将进行路由帧的发送，值得一提的是，路由帧的发送使用的书链路质量估计层提供的发送接口，这个发送接口在路由帧的头部和尾部分别套上了LEEP帧的帧头和帧尾（header and footer）。这意味着路由的形成、链路质量的估计2位一体。</p> 
<p>3、转发引擎。这一层主要是进行数据包的发送和其他节点数据包的转发，并且通过ACK帧来计算转发的成功率。将成功率回馈给链路质量估计层。由此来看，汇聚树中所有的数据包都将直接或者间接对链路质量估计值产生影响。此外转发引擎还维护了一个发送队列，这个发送队列提供了阻塞警告。</p> 
<p><img src="https://images2.imgbox.com/7b/d8/UewvksSw_o.png" alt=""><br> </p> 
<p>上面就是CTP结构的示意图。</p> 
<p>接着说转发引擎。</p> 
<p>CTP之所以可以实现灵活的拓扑主要是因为每个节点都可以灵活地找出在不同的网络环境下的父节点，无论是转发帧还是此节点自己发送的数据帧，都是发往在那个时刻的父节点的。但是这样子很可能会出现被称之为“路由环路”东西。这种情况是绝对不允许存在的，这样子会导致数据包的循环发送，并且数据包永远也到不了根节点，所以在转发引擎中还做了路由环路的侦测工作，一旦发现路由环路，那么发现路由环路的节点就要从路由表选出一个信号强度“合适”的父节点代替现有父节点。</p> 
<p><br> </p> 
<p><u><strong>帧类型</strong></u></p> 
<p>CTP一共两种数据帧，一个是路由帧（LEEP帧），还有一种是数据帧，路由帧由路由引擎发送，负责组网工作。数据帧是由转发引擎发送，是基于CTP的数据平台一切功能的基础。</p> 
<p>路由帧：</p> 
<p><img src="https://images2.imgbox.com/61/99/wY1bDuE9_o.png" alt=""><br> </p> 
<p>数据帧：</p> 
<p><img src="https://images2.imgbox.com/74/93/9N2ZVCRg_o.png" alt=""><br> </p> 
<p>具体功能后面展开。</p> 
<p><br> </p> 
<p>以上就是CTP三个模块的工作。</p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/97efa3b607b604873cc274e91fb35233/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">struts2的处理请求的全过程是什么</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30654f9f2391ea5552e6a7dc76c39057/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CTP源码分析3 CTP链路质量估计层结构及源码分析（二）----LEEP协议中的Trickle算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>