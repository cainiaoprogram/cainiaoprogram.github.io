<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue3 与 React 全方面对比 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue3 与 React 全方面对比" />
<meta property="og:description" content="1. 编程风格 &amp; 视图风格 1.1 编程风格 React 语法少、难度大；Vue 语法多，难度小
例如指令：
Vue
&lt;input v-model=&#34;username&#34;/&gt; &lt;ul&gt; &lt;li v-for=&#34;(item,index) in list&#34; :key=&#34;index&#34;&gt;{{ item }}&lt;/li&gt; &lt;/ul&gt; React
&lt;input value={username} onChange={e =&gt; setUsername(e.target.value)}/&gt; &lt;ul&gt; { list.map((item,index) =&gt; &lt;li key={index}&gt;{item}&lt;/li&gt;) } &lt;/ul&gt; Vue 给我们提供了很多的指令功能，而这些功能在 React 中基本都需要我们使用原生 js 来实现。
所以会有很多人说: &#34;使用 Vue 实际上你就是在操作 Vue，使用 React 实际上你是在操作 js&#34;。
React 魔改少，手动实现；Vue 魔改多，自动完成。
例如事件：
Vue
&lt;button @click=&#34;handleClick(&#39;hello&#39;)&#34;&gt;点击&lt;/button&gt; const handleClick = (msg) =&gt; { console.log(&#39;msg&#39;) } React
&lt;button onClick=&#34;handleClick(&#39;hello&#39;)&#34;&gt;点击&lt;/button&gt; const handleClick = (msg) =&gt; { return () =&gt; { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cc7312b6d130c98e4d864c19f241cecf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-08T19:04:54+08:00" />
<meta property="article:modified_time" content="2023-07-08T19:04:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue3 与 React 全方面对比</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1. 编程风格 &amp; 视图风格</h2> 
<h3>1.1 编程风格</h3> 
<ol><li> <p><code>React</code> 语法少、难度大；<code>Vue</code> 语法多，难度小</p> </li></ol> 
<p>例如指令：</p> 
<p><strong>Vue</strong></p> 
<pre><code>&lt;input v-model="username"/&gt;

&lt;ul&gt;
    &lt;li v-for="(item,index) in list" :key="index"&gt;{<!-- -->{ item }}&lt;/li&gt;
&lt;/ul&gt;

</code></pre> 
<p><strong>React</strong></p> 
<pre><code>&lt;input value={username} onChange={e =&gt; setUsername(e.target.value)}/&gt;


&lt;ul&gt;
{ list.map((item,index) =&gt; &lt;li key={index}&gt;{item}&lt;/li&gt;) }
&lt;/ul&gt;

</code></pre> 
<p><code>Vue</code> 给我们提供了很多的指令功能，而这些功能在 <code>React</code> 中基本都需要我们使用原生 <code>js</code> 来实现。</p> 
<p>所以会有很多人说: "使用 Vue 实际上你就是在操作 Vue，使用 React 实际上你是在操作 js"。</p> 
<ol><li> <p>React 魔改少，手动实现；Vue 魔改多，自动完成。</p> </li></ol> 
<p>例如事件：</p> 
<p><strong>Vue</strong></p> 
<pre><code>&lt;button @click="handleClick('hello')"&gt;点击&lt;/button&gt;

const handleClick = (msg) =&gt; {
  console.log('msg')
}

</code></pre> 
<p><strong>React</strong></p> 
<pre><code>&lt;button onClick="handleClick('hello')"&gt;点击&lt;/button&gt;

const handleClick = (msg) =&gt; {
    return () =&gt; {
        console.log(msg)
    }
}

</code></pre> 
<p>像在点击事件中传参数这种功能：</p> 
<ol><li> <p>我们知道 <code>dom</code> 的点击事件是需要我们传递一个函数过去的，就像在 <code>React</code> 中例子一样，你的 <code>handleClick</code> 肯定需要返回一个函数（或者在 <code>jsx</code> 中写箭头函数调用 <code>handleClick</code>）。</p> </li><li> <p>而在 <code>Vue</code> 中可以在 <code>@click</code> 中直接调用 <code>handleClick</code> 函数，而这个函数又没有返回一个新的函数，按道理这样调用 <code>handleClick</code> 是会返回 <code>undefined</code> 的，但是由于 <code>Vue</code> 底层做了魔改优化，使得我们不再需要在返回一个函数。</p> </li></ol> 
<p>上面两个例子中，我们说不上哪种好哪种不好，只能说你更喜欢哪一种。<code>React</code> 中的实现更符合 <code>js</code> 的逻辑但却稍显麻烦，<code>Vue</code> 中的实现简单但却没有遵循原生 <code>js</code> 的特点。</p> 
<p>编程风格上的总结：就像我们前面讲的，<code>Vue</code> 写起来更像是写 <code>Vue</code> 代码，<code>React</code> 写起来更像是写 <code>JavaScript</code> 代码。</p> 
<h3>1.2 视图风格</h3> 
<ol><li> <p><code>Vue</code> 采用 <code>&lt;template&gt;</code> 字符串模板。更贴近 <code>HTML</code>，学习成本低，但有时候不灵活。</p> </li><li> <p><code>React</code> 采用 <code>JSX</code> 语法，更类似于 <code>js</code> ，限制比较多，（像一些关键字 <code>class</code>、<code>for</code>，单标签要闭合、属性要驼峰、组件名要大写等等这些都要注意），但是可以跟模板语法很好的进行结合</p> </li></ol> 
<p>比如下面是一个通过 <code>level</code> 的值来渲染不同的标签在 <code>Vue</code> 和 <code>React</code> 中的不同实现</p> 
<p><strong>Vue</strong></p> 
<pre><code>&lt;template&gt;
    &lt;h1 v-if="level === 1"&gt;标题1&lt;/h1&gt;
    &lt;h2 v-if="level === 2"&gt;标题2&lt;/h1&gt;
&lt;/template&gt;

</code></pre> 
<p><strong>React</strong></p> 
<pre><code>let App = () =&gt; {
    const level = 1
    const Tag = 'h' + level
    return (
        &lt;div&gt;
            { &lt;Tag&gt;标题{level}&lt;/Tag&gt;}
        &lt;/div&gt;
    )
}

</code></pre> 
<p>可以想象，如果当我们的条件判断很多时，使用 <code>JSX</code> 的方式会比使用模版字符串要灵活的多。</p> 
<p><strong>注意</strong>: <code>Vue</code> 一开始并不直接支持 <code>JSX</code> ，在 <code>Vue 2.1.0</code> 版本中，<code>Vue</code> 引入了 <code>render</code> 函数来代替模板，这使得使用 <code>JSX</code> 作为组件渲染函数成为可能。在<code>Vue 2.1.0</code>版本后的 <code>create-vue</code> 和 <code>Vue CLI</code> 都有预置的 <code>JSX</code> 语法支持。所以说在 <code>Vue</code> 中如果你想写 <code>JSX</code> 这个它也是支持的，但是在 <code>React</code> 是没办法用字符串模板的方式写。</p> 
<h2>2. 组件 &amp; 路由 &amp; 状态管理</h2> 
<h3>2.1 组件风格</h3> 
<ol><li> <p><code>Vue2</code> 中采用 <strong>选项式 API</strong>，但是由于它<strong>不够灵活</strong>，而且 <code>this</code> 指向不够简单，<code>Vue3</code> 中给我们提供了 <strong>组合式API</strong> 的写法，<strong>组合式 API</strong> 更偏向函数式编程的方式，它的复用能力和组合的能力更强，而且没有 <code>this</code> 指向问题，也是 <code>Vue</code> 比较推荐的写法。</p> </li><li> <p><code>React</code> 在 <code>16.8</code> 版本之前都是采用<strong>类组件</strong>的方式开发，<strong>类组件</strong>也会有 <code>this</code> 指向以及写起来很<strong>繁琐难度大</strong>的问题，在 <code>16.8</code> 之后 <code>React</code> 提供了<strong>函数组件</strong>的写法，其<strong>实函数组件</strong>和 <code>Vue</code> 的 <strong>组合式 API</strong> 是很像的，它的组合和复用的能力更强，而且也没有 <code>this</code> 指向问题，比类组件写起来简单很多，也是 <code>React</code> 比较推荐的写法</p> </li></ol> 
<p><strong>Vue 组件示意图：</strong></p> 
<pre><code>&lt;template&gt;
  &lt;div class="my-component"&gt;
    &lt;!-- HTML模板 --&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  // JavaScript代码
}
&lt;/script&gt;

&lt;style&gt;
.my-component {
  /* CSS样式 */
}
&lt;/style&gt;

</code></pre> 
<p><strong>React 组件示意图：</strong></p> 
<pre><code>import React from 'react';
import './MyComponent.css';

function MyComponent() {
  // JavaScript代码
  return (
    &lt;div className="my-component"&gt;
      {/* HTML模板 */}
    &lt;/div&gt;
  );
}

export default MyComponent;

</code></pre> 
<p>总结：这两种框架它们的最终趋势都是函数式编程，不管是 <code>Vue</code> 还是 <code>React</code> 都是推荐我们引入大量内置的函数或者是 use 函数来进行组合并且完成我们的开发需求。而简化使用面向对象或者是配置的写法，能简化我们使用 <code>this</code> 的场景从而提升代码的灵活度和简易度。</p> 
<h3>2.2 路由风格</h3> 
<p><code>Vue</code> 采用 <code>Vue-Router</code>；React 采用 <code>React-Router</code></p> 
<p>相比而言 <code>vue</code> 语法更加简练（useRouter useRoute），而 <code>react</code> 的 use 函数太多，不够统一化（useLocation、useParams、useSearchParams、useNavigate......）</p> 
<p>而像下面这些常规的功能它们都是大差不差的：</p> 
<ol><li> <p>路由表的配置</p> </li><li> <p>嵌套路由</p> </li><li> <p>动态路由</p> </li><li> <p>编程式路由</p> </li><li> <p>守卫路由</p> </li></ol> 
<p><strong>Vue-Router 示例代码</strong></p> 
<pre><code>&lt;!-- index.html --&gt;
&lt;div id="app"&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;

</code></pre> 
<pre><code>// main.js
import { createApp } from 'vue'
import { createRouter, createWebHistory } from 'vue-router'
import Home from './components/Home.vue'
import About from './components/About.vue'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    { path: '/', component: Home },
    { path: '/about', component: About }
  ]
})

const app = createApp({
  // 空的 `setup` 函数
  setup() {}
})

app.use(router)
app.mount('#app')

</code></pre> 
<pre><code>&lt;!-- Home.vue --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;Home Page&lt;/h1&gt;
    &lt;button @click="goToAbout"&gt;Go to About Page&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { useRouter } from 'vue-router'

const router = useRouter()

const goToAbout = () =&gt; {
  router.push('/about')
}
&lt;/script&gt;

</code></pre> 
<pre><code>&lt;!-- About.vue --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;About Page&lt;/h1&gt;
    &lt;p&gt;Param: {<!-- -->{ $route.params.id }}&lt;/p&gt;
    &lt;router-link to="/"&gt;Go to Home Page&lt;/router-link&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { useRoute } from 'vue-router'

const route = useRoute()
const id = route.params.id
&lt;/script&gt;


</code></pre> 
<p><strong>React-Router 示例代码</strong></p> 
<pre><code>import React from 'react'
import { BrowserRouter as Router, Switch, Route, Link, useParams, useHistory } from 'react-router-dom'
import Home from './components/Home'
import About from './components/About'

const App = () =&gt; {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;
          &lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt;
        &lt;/ul&gt;

        &lt;hr/&gt;

        &lt;Switch&gt;
          &lt;Route exact path="/"&gt;
            &lt;Home /&gt;
          &lt;/Route&gt;
          &lt;Route path="/about"&gt;
            &lt;About /&gt;
          &lt;/Route&gt;
        &lt;/Switch&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  )
}

const Home = () =&gt; {
  const history = useHistory()
  const handleClick = () =&gt; {
    history.push('/about')
  }
  return (
    &lt;div&gt;
      &lt;h1&gt;Home Page&lt;/h1&gt;
      &lt;button onClick={handleClick}&gt;Go to About Page&lt;/button&gt;
    &lt;/div&gt;
  )
}

const About = () =&gt; {
  const { id } = useParams()
  return (
    &lt;div&gt;
      &lt;h1&gt;About Page&lt;/h1&gt;
      &lt;p&gt;Param: {id}&lt;/p&gt;
      &lt;Link to="/"&gt;Go to Home Page&lt;/Link&gt;
    &lt;/div&gt;
  )
}

export default App


</code></pre> 
<h3>2.3 状态管理风格</h3> 
<p><code>Vue</code> 采用 <code>Vuex/Pinia</code> ；<code>React</code> 采用 <code>Redux/Mobx</code></p> 
<p>区别：</p> 
<ol><li> <p>语法和 <code>API</code> 的不同：<code>Vuex</code> 和 <code>Pinia</code> 是专门为 <code>Vue.js</code> 设计的状态管理库，因此它们的语法和API都非常类似。而 <code>Redux</code> 和 <code>Mobx</code> 可以在任何 <code>JavaScript</code> 应用程序中使用，因此<strong>它们的语法和API与特定的框架无关</strong>。</p> </li><li> <p>数据流的不同：在 <code>Redux</code> 中，数据是通过单向数据流进行管理的，即 <code>action \-&gt; reducer \-&gt; store \-&gt; view</code>。而在 <code>Vuex</code> 和 <code>Pinia</code> 中，数据是通过 <code>Vuex store</code> 或 <code>Pinia store</code> 直接管理的，不需要 <code>reducer</code>。而在 <code>Mobx</code> 中，数据则是通过响应式数据实现的。</p> </li><li> <p>异步处理的不同：在 <code>Redux</code> 中，异步处理通常需要使用中间件来处理异步操作。而在 <code>Vuex</code> 和 <code>Pinia</code> 中，异步操作可以通过 <code>actions</code> 处理。而在 <code>Mobx</code> 中，则可以使用 <code>async/await</code> 或 <code>reaction</code> 函数来处理异步操作。</p> </li><li> <p>开销和复杂性的不同：<code>Redux</code> 和 <code>Mobx</code> 都需要在应用程序中进行额外的设置和配置，并且在处理大量数据时可能会导致性能问题。而 <code>Vuex</code> 和 <code>Pinia</code> 的设置和配置相对简单，并且在大多数情况下可以处理大量数据。</p> </li></ol> 
<p>总的来说，<code>Vuex</code> 和 <code>Pinia</code> 适用于 <code>Vue.js</code> 应用程序，<strong>提供了一种简单和直接的状态管理方式</strong>，而 <code>Redux</code> 和 <code>Mobx</code> 则可以在多种应用程序中使用，<strong>提供了更灵活的状态管理方案</strong>。</p> 
<p><strong>Pinia 示例代码</strong></p> 
<pre><code>// store.js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore({
  id: 'counter',
  state: () =&gt; ({
    count: 0,
  }),
  actions: {
    increment() {
      this.count++
    },
  },
})

</code></pre> 
<pre><code>&lt;!-- App.vue --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;Count: {<!-- -->{ count }}&lt;/h1&gt;
    &lt;button @click="incrementCount"&gt;Increment&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineComponent } from 'vue'
import { useCounterStore } from './store'

const counterStore = useCounterStore()
const count = counterStore.count
const incrementCount = () =&gt; {
  counterStore.increment()
}
&lt;/script&gt;

&lt;!-- 在根组件中注入 store --&gt;
&lt;script&gt;
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

const app = createApp(App)
const pinia = createPinia()
app.use(pinia)
app.mount('#app')
&lt;/script&gt;


</code></pre> 
<p><strong>Redux Toolkit 示例代码</strong></p> 
<pre><code>// store.js
import { configureStore, createSlice } from '@reduxjs/toolkit'

const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    count: 0
  },
  reducers: {
    increment(state) {
      state.count++
    }
  }
})

export const store = configureStore({
  reducer: {
    counter: counterSlice.reducer
  }
})

export const { increment } = counterSlice.actions;

</code></pre> 
<pre><code>// App.js
import { useSelector, useDispatch } from 'react-redux'
import { increment } from './store'

function App() {
  const count = useSelector(state =&gt; state.counter.count)
  const dispatch = useDispatch()

  const incrementCount = () =&gt; {
    dispatch(increment())
  }

  return (
    &lt;div&gt;
      &lt;h1&gt;Count: {count}&lt;/h1&gt;
      &lt;button onClick={incrementCount}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  )
}

export default App

// 在根组件中注入 store
import { Provider } from 'react-redux'
import { store } from './store'

ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
);

</code></pre> 
<h2>3. 一些基础功能</h2> 
<h3>3.1 模板对比</h3> 
<p><code>Vue</code> 的视图变化主要通过：指令 + 模板的方式</p> 
<p><code>React</code> 的视图变化主要通过：原生JS + 模板的方式</p> 
<p><code>React</code> 的模板比较强大，因为可以编写 <code>JSX</code> 结构，所以可以做出更加灵活的结构处理。</p> 
<h3>3.2 样式对比</h3> 
<p><code>Vue</code> 的 <code>class</code> 和 <code>style</code> 都有三种写法：字符串、数组、对象</p> 
<p><code>React</code> 的 <code>style</code> 只能写对象，<code>class</code> 只能字符串，可借助 <code>classnames</code> 这个库</p> 
<p>两个框架基本上都可以满足常见的样式需求。</p> 
<h3>3.3 事件对比</h3> 
<p><code>Vue</code> 事件功能丰富</p> 
<p><code>React</code> 事件传参需要高阶处理</p> 
<pre><code>&lt;!-- Vue --&gt;
&lt;template&gt;
    &lt;ul&gt;
        &lt;li v-for="item,index in list" @click="handleClick(index)"&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
methods: {
 handleClick(index){
 
    }
}
&lt;/script&gt;

</code></pre> 
<pre><code>&lt;!-- React --&gt;
&lt;ul&gt;
{ 
    list.map((v, i)=&gt; &lt;li onClick={handleClick(i)}&gt;&lt;/li&gt;)
}
&lt;/ul&gt;
const handleClick = (index) =&gt; {
    return () =&gt; {
        console.log(index)
    }    
}


</code></pre> 
<h3>3.4 表单对比</h3> 
<p><code>Vue</code> 表单双向绑定 <code>v-model</code></p> 
<p><code>React</code> 表单受控与非受控</p> 
<p>针对表单操作这一块来说，<code>Vue</code> 的表单指令 <code>v-model</code> 还是非常灵活的，总体对比要比 <code>React</code> 使用方便且灵活。</p> 
<h3>3.5 组件通信对比</h3> 
<p><code>Vue</code> 父子组件通过 <code>props</code>属性通信，子父组件通过 <code>emits</code> 方法通信</p> 
<p><code>React</code> 父子组件也是通过 <code>props</code>属性通信，而子父组件则是通过回调函数通信的</p> 
<p><code>emits</code> 自定义事件和回调函数，实际上是一样的思想。</p> 
<p>跨组件的通信方案也很类似，都是一种依赖注入的方式来实现的。</p> 
<h3>3.6 逻辑复用</h3> 
<p><code>Vue</code> 选项式采用：<code>mixins混入</code>；组合式采用：<code>use函数</code></p> 
<p><code>React</code> 类组件采用：<code>Render Props</code>、<code>HOC</code>；函数组件：<code>use函数</code></p> 
<p>可以发现组合式API和函数组件都是采用use函数，所以基本复用是差不多的思想，这也是两个框架推荐的用法。</p> 
<h3>3.7 内容分发</h3> 
<p><code>Vue</code> 通过插槽，进行接收</p> 
<p><code>React</code> 通过 <code>props.children</code>，进行接收</p> 
<h3>3.8 DOM操作</h3> 
<p><code>Vue</code> 通过 <code>ref</code> 属性</p> 
<p><code>React</code> 也通过 <code>ref</code> 属性处理</p> 
<p>思路都是差不多的，就是给元素添加 <code>ref</code> 属性，在跟对象或字符串绑定在一起，这样就可以直接获取到 <code>DOM</code> 元素。</p> 
<h2>4. 响应式 &amp; 生命周期 &amp; 副作用</h2> 
<h3>4.1 响应式数据对比</h3> 
<p>Vue采用响应式数据，底层通过new Proxy()进行监控，灵活性更高</p> 
<p>React采用state状态，通过setState()方法进行内部re-render，可控性更强</p> 
<h3>4.2 生命周期对比</h3> 
<p>Vue生命周期钩子(常见)</p> 
<ol><li> <p>beforeCreate</p> </li><li> <p>created</p> </li><li> <p>beforeMount</p> </li><li> <p>mounted</p> </li><li> <p>beforeUpdate</p> </li><li> <p>updated</p> </li><li> <p>beforeUnmount</p> </li><li> <p>unmounted</p> </li></ol> 
<p>React生命周期钩子(常见)</p> 
<ol><li> <p>constructor</p> </li><li> <p>componentDidMount</p> </li><li> <p>componentDidUpdate</p> </li><li> <p>componentWillUnmount</p> </li><li> <p>render 整体对比来看，<code>Vue</code> 的生命周期会更丰富一些，<code>React</code> 生命周期会更简约一些。</p> </li></ol> 
<h3>4.3 副作用处理对比</h3> 
<p>vue使用，watchEffect()</p> 
<p>react使用，useEffect()</p> 
<p>都是处理副作用的方法，用法上还是有很大区别的。</p> 
<p>watchEffect会自动根据所依赖的值进行重渲染，而useEffect要明确指定对应的值才能进行重渲染，React团队已经给出在未来的版本中可能会改成根据所依赖的值自动进行重渲染的操作，但暂时还不行。</p> 
<p>watchEffect在更新前和卸载前触发的方式是通过回调函数的参数被调用来实现的，而useEffect是通过return的返回值来指定的。</p> 
<pre><code>// Vue
watchEffect((cb)=&gt;{
 cb(()=&gt;{
       //更新前的触发
    })
})

</code></pre> 
<pre><code>// React
useEffect(()=&gt;{
   return ()=&gt;{
      //更新前的触发
   }
})
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1063dfaea0a957c1b35ea66d114392b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Frp&#43;长亭雷池waf&#43;Nginx实现内网穿透</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/942f117e064a9389898a2a6ae2090944/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【网络】HTTPS协议原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>