<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ESP32-CAM网络摄像头系列-01-基于RTSP协议的局域网视频推流/拉流的简单实现 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ESP32-CAM网络摄像头系列-01-基于RTSP协议的局域网视频推流/拉流的简单实现" />
<meta property="og:description" content="前言： 由于项目需要，最近开始开坑关于ESP32-CAM系列的RTSP网络摄像头系列，该文章为该系列的第一篇文章。用于记录项目开发过程。
本文解决的问题： 使用ESP32-CAM获取图像数据，并通过RTSP协议将获取到的视频流传输到上位机进行显示。
具体实现： 使用ESP32-CAM进行视频推流，python端作为rtsp拉流，其中ESP32-CAM使用arduinoIDE开发，使用了安信可的支持库。支持包安装网址：
拉流效果： 一、推流部分 官方示例代码：
#include &#34;OV2640.h&#34; #include &lt;WiFi.h&gt; #include &lt;WebServer.h&gt; #include &lt;WiFiClient.h&gt; #include &#34;SimStreamer.h&#34; #include &#34;OV2640Streamer.h&#34; #include &#34;CRtspSession.h&#34; #define ENABLE_RTSPSERVER OV2640 cam; #ifdef ENABLE_WEBSERVER WebServer server(80); #endif #ifdef ENABLE_RTSPSERVER WiFiServer rtspServer(8554); #endif #ifdef SOFTAP_MODE IPAddress apIP = IPAddress(192, 168, 1, 1); #else #include &#34;wifikeys_template.h&#34; #endif #ifdef ENABLE_WEBSERVER void handle_jpg_stream(void) { WiFiClient client = server.client(); String response = &#34;HTTP/1.1 200 OK\r\n&#34;; response &#43;= &#34;Content-Type: multipart/x-mixed-replace; boundary=frame\r\n\r\n&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fdacbd305b639b9671f24abbd06f2279/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-24T16:31:10+08:00" />
<meta property="article:modified_time" content="2023-02-24T16:31:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ESP32-CAM网络摄像头系列-01-基于RTSP协议的局域网视频推流/拉流的简单实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言：</h2> 
<p>        由于项目需要，最近开始开坑关于ESP32-CAM系列的RTSP网络摄像头系列，该文章为该系列的第一篇文章。用于记录项目开发过程。</p> 
<h2>本文解决的问题：</h2> 
<p>        使用ESP32-CAM获取图像数据，并通过RTSP协议将获取到的视频流传输到上位机进行显示。</p> 
<h2>具体实现：</h2> 
<p>        使用ESP32-CAM进行视频推流，python端作为rtsp拉流，其中ESP32-CAM使用arduinoIDE开发，使用了安信可的支持库。支持包安装网址：</p> 
<h4>拉流效果：</h4> 
<p><img alt="" height="1045" src="https://images2.imgbox.com/22/1a/lFTzgsP6_o.png" width="1200"></p> 
<h3>一、推流部分</h3> 
<p>官方示例代码：</p> 
<pre><code class="language-cpp">#include "OV2640.h"
#include &lt;WiFi.h&gt;
#include &lt;WebServer.h&gt;
#include &lt;WiFiClient.h&gt;

#include "SimStreamer.h"
#include "OV2640Streamer.h"
#include "CRtspSession.h"

#define ENABLE_RTSPSERVER

OV2640 cam;

#ifdef ENABLE_WEBSERVER
WebServer server(80);
#endif

#ifdef ENABLE_RTSPSERVER
WiFiServer rtspServer(8554);
#endif


#ifdef SOFTAP_MODE
IPAddress apIP = IPAddress(192, 168, 1, 1);
#else
#include "wifikeys_template.h"
#endif

#ifdef ENABLE_WEBSERVER
void handle_jpg_stream(void)
{
    WiFiClient client = server.client();
    String response = "HTTP/1.1 200 OK\r\n";
    response += "Content-Type: multipart/x-mixed-replace; boundary=frame\r\n\r\n";
    server.sendContent(response);

    while (1)
    {
        cam.run();
        if (!client.connected())
            break;
        response = "--frame\r\n";
        response += "Content-Type: image/jpeg\r\n\r\n";
        server.sendContent(response);

        client.write((char *)cam.getfb(), cam.getSize());
        server.sendContent("\r\n");
        if (!client.connected())
            break;
    }
}

void handle_jpg(void)
{
    WiFiClient client = server.client();

    cam.run();
    if (!client.connected())
    {
        return;
    }
    String response = "HTTP/1.1 200 OK\r\n";
    response += "Content-disposition: inline; filename=capture.jpg\r\n";
    response += "Content-type: image/jpeg\r\n\r\n";
    server.sendContent(response);
    client.write((char *)cam.getfb(), cam.getSize());
}

void handleNotFound()
{
    String message = "Server is running!\n\n";
    message += "URI: ";
    message += server.uri();
    message += "\nMethod: ";
    message += (server.method() == HTTP_GET) ? "GET" : "POST";
    message += "\nArguments: ";
    message += server.args();
    message += "\n";
    server.send(200, "text/plain", message);
}
#endif

#ifdef ENABLE_OLED
#define LCD_MESSAGE(msg) lcdMessage(msg)
#else
#define LCD_MESSAGE(msg)
#endif

#ifdef ENABLE_OLED
void lcdMessage(String msg)
{
    if(hasDisplay) {
        display.clear();
        display.drawString(128 / 2, 32 / 2, msg);
        display.display();
    }
}
#endif

CStreamer *streamer;

void setup()
{
  #ifdef ENABLE_OLED
    hasDisplay = display.init();
    if(hasDisplay) {
        display.flipScreenVertically();
        display.setFont(ArialMT_Plain_16);
        display.setTextAlignment(TEXT_ALIGN_CENTER);
    }
  #endif
    LCD_MESSAGE("booting");

    Serial.begin(115200);
    while (!Serial)
    {
        ;
    }
    cam.init(esp32cam_aithinker_config);

    IPAddress ip;


#ifdef SOFTAP_MODE
    const char *hostname = "devcam";
    // WiFi.hostname(hostname); // FIXME - find out why undefined
    LCD_MESSAGE("starting softAP");
    WiFi.mode(WIFI_AP);
    WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));
    bool result = WiFi.softAP(hostname, "12345678", 1, 0);
    if (!result)
    {
        Serial.println("AP Config failed.");
        return;
    }
    else
    {
        Serial.println("AP Config Success.");
        Serial.print("AP MAC: ");
        Serial.println(WiFi.softAPmacAddress());

        ip = WiFi.softAPIP();
    }
#else
    LCD_MESSAGE(String("join ") + ssid);
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(500);
        Serial.print(F("."));
    }
    ip = WiFi.localIP();
    Serial.println(F("WiFi connected"));
    Serial.println("");
    Serial.println(ip);
#endif

    LCD_MESSAGE(ip.toString());

#ifdef ENABLE_WEBSERVER
    server.on("/", HTTP_GET, handle_jpg_stream);
    server.on("/jpg", HTTP_GET, handle_jpg);
    server.onNotFound(handleNotFound);
    server.begin();
#endif

#ifdef ENABLE_RTSPSERVER
    rtspServer.begin();

    //streamer = new SimStreamer(true);             // our streamer for UDP/TCP based RTP transport
    streamer = new OV2640Streamer(cam);             // our streamer for UDP/TCP based RTP transport
#endif
}

void loop()
{
#ifdef ENABLE_WEBSERVER
    server.handleClient();
#endif

#ifdef ENABLE_RTSPSERVER
    uint32_t msecPerFrame = 100;
    static uint32_t lastimage = millis();

    // If we have an active client connection, just service that until gone
    streamer-&gt;handleRequests(0); // we don't use a timeout here,
    // instead we send only if we have new enough frames
    uint32_t now = millis();
    if(streamer-&gt;anySessions()) {
        if(now &gt; lastimage + msecPerFrame || now &lt; lastimage) { // handle clock rollover
            streamer-&gt;streamImage(now);
            lastimage = now;

            // check if we are overrunning our max frame rate
            now = millis();
            if(now &gt; lastimage + msecPerFrame) {
                printf("warning exceeding max frame rate of %d ms\n", now - lastimage);
            }
        }
    }
    
    WiFiClient rtspClient = rtspServer.accept();
    if(rtspClient) {
        Serial.print("client: ");
        Serial.print(rtspClient.remoteIP());
        Serial.println();
        streamer-&gt;addSession(rtspClient);
    }
#endif
}</code></pre> 
<p>        对于ESP32的RTSP推流安信可官方已经给出了相应的示例代码，改代码使用宏定义的方式区分http和rtsp协议的不同代码。由于我们不需要用到基于http协议的视频推流，因此可以删去官方代码中不必要的部分。修改完的代码如下：</p> 
<p><strong>ESP32部分的代码由官方示例代码修改而来。只保留RTSP推流部分。</strong></p> 
<pre><code class="language-cpp">#include "OV2640.h"
#include &lt;WiFi.h&gt;
#include &lt;WebServer.h&gt;
#include &lt;WiFiClient.h&gt;

#include "SimStreamer.h"
#include "OV2640Streamer.h"
#include "CRtspSession.h"

// copy this file to wifikeys.h and edit
const char *ssid =     "YAN";         // Put your SSID here
const char *password = "qwertyuiop";     // Put your PASSWORD here

#define ENABLE_RTSPSERVER

OV2640 cam;

WiFiServer rtspServer(8554);

CStreamer *streamer;

void setup()
{
    Serial.begin(115200);
    while (!Serial);
    cam.init(esp32cam_aithinker_config);

    IPAddress ip;

    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(500);
        Serial.print(F("."));
    }
    ip = WiFi.localIP();
    Serial.println(F("WiFi connected"));
    Serial.println("");
    Serial.println(ip);

    rtspServer.begin();

    //streamer = new SimStreamer(true);             // our streamer for UDP/TCP based RTP transport
    streamer = new OV2640Streamer(cam);             // our streamer for UDP/TCP based RTP transport
}

void loop()
{
    uint32_t msecPerFrame = 100;
    static uint32_t lastimage = millis();

    // If we have an active client connection, just service that until gone
    streamer-&gt;handleRequests(0); // we don't use a timeout here,
    // instead we send only if we have new enough frames
    uint32_t now = millis();
    if(streamer-&gt;anySessions()) {
        if(now &gt; lastimage + msecPerFrame || now &lt; lastimage) { // handle clock rollover
            streamer-&gt;streamImage(now);
            lastimage = now;

            // check if we are overrunning our max frame rate
            now = millis();
            if(now &gt; lastimage + msecPerFrame) {
                printf("warning exceeding max frame rate of %d ms\n", now - lastimage);
            }
        }
    }
    
    WiFiClient rtspClient = rtspServer.accept();
    if(rtspClient) {
        Serial.print("client: ");
        Serial.print(rtspClient.remoteIP());
        Serial.println();
        streamer-&gt;addSession(rtspClient);
    }
}</code></pre> 
<p>ArduinoIDE串口监视器输出的初始化信息，我们需要将ESP32的IP地址安装RTSP协议推流的格式填入Python拉流代码中。</p> 
<blockquote> 
 <pre># RTSP 地址
rtsp_url = "rtsp://192.168.168.238:8554/mjpeg/2"
</pre> 
</blockquote> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e2/fb/RBh3u2Ws_o.png" width="1200"></p> 
<h3> 二、拉流部分</h3> 
<p>        由于Opencv-python集成了RTSP协议拉流的库函数，因此我们需要下载Opencv-python的支持包。可以打开Pycharm的Terminal使用pip指令快速下载。</p> 
<pre><code class="language-python">pip install opencv-python</code></pre> 
<h4><strong> 上位机python3拉流代码：</strong></h4> 
<pre><code class="language-python">import cv2

# RTSP 地址
rtsp_url = "rtsp://192.168.168.238:8554/mjpeg/2"

# 打开 RTSP 视频流
cap = cv2.VideoCapture(rtsp_url)

# 检查视频是否成功打开
if not cap.isOpened():
    print("Failed to open RTSP stream")
    exit()

# 循环读取视频帧
while True:
    # 读取视频帧
    ret, frame = cap.read()

    # 检查是否成功读取视频帧
    if not ret:
        break

    # 显示视频帧
    cv2.imshow("RTSP Stream", frame)

    # 按 'q' 键退出循环
    if cv2.waitKey(1) &amp; 0xFF == ord('q'):
        break

# 释放资源
cap.release()
cv2.destroyAllWindows()
</code></pre> 
<p><strong>PS:需要注意的是，进行RTSP拉流的上位机和推流的下位机都需要位于同一个局域网下才能进行推拉流传输。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e2beecfbbb31dd47fd2518d2bf5e0bc7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">再析jvm</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/75d0c00ecf59cd04edd7fdae22557ba6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pyinstaller打包程序后可能遇到的错误</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>