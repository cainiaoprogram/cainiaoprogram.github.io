<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Shell脚本学习笔记 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Shell脚本学习笔记" />
<meta property="og:description" content="1. 写在前面 工作中，需要用到写一些shell脚本去完成一些简单的重复性工作， 于是就想系统的学习下shell脚本的相关知识， 本篇文章是学习shell脚本整理的学习笔记，内容参考主要来自C语言中文网， 学习过程中， 加入了一些在学习过程中的实践经验和思考， 并抽取出一些常用的知识内容整理成这篇文章，方便以后回看回练， 如果想更系统的学习， 可以去前面这个网站进行学习。
大纲如下：
Shell基础Shell编程Shell高级Shell的一些快捷操作 Ok, let’s go!
2. Shell基础 2.1 what? shell: 用户和内核之间的”代理”
Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。 shell主要用来开发一些实用的、自动化的小工具，例如检测计算机的硬件参数、搭建 Web 运行环境、日志分析等，不适合开发具有复杂逻辑的中大型软件。
shell是一种脚本语言。
编译性语言：程序运行之前，把所有的代码翻译成二进制形式(可执行文件), 用户拿到的是可执行文件，看不到源码。这个过程叫做编译，这样的编程语言叫编译性语言，完成编译过程的软件叫编译器。 C/C&#43;&#43;， GO等 优点是执行速度快、对硬件要求低、保密性好，适合开发操作系统、大型应用程序、数据库等 解释性语言：一边执行，一边翻译，无须生成任何二进制文件， 用户拿到源码即可运行。程序运行后即时翻译，翻译一部分执行一部分，不会等所有代码都翻译完，这个过程叫做解释， 这样的编程语言叫解释性语言，完成解释过程的软件叫解释器。 python, javascript, php，shell等 脚本语言的优点是使用灵活、部署容易、跨平台性好，非常适合 Web 开发以及小工具的制作 2.2 why? Shell是运维人员必须掌握的技能, Shell 脚本是实现 Linux 系统自动管理以及自动化运维所必备的工具
Linux 运维工程师(OPS): 主要工作就是搭建起运行环境，让程序员写的代码能够高效、稳定、安全地在服务器上运行，他们属于后勤部门。OPS 的要求并不比程序员低，优秀的 OPS 拥有架设服务器集群的能力，还会编程开发常用的工具。工作细节如下： 安装操作系统，例如 CentOS、Ubuntu 等。部署代码运行环境，例如网站后台语言采用 PHP，就需要安装 Nginx、Apache、MySQL、PHP 运行时等。及时修复漏洞，防止服务器被攻击，这包括 Linux 本身漏洞以及各个软件的漏洞。根据项目需求升级软件，例如 PHP 7." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5573f2d677b6bb837556e9ddec9f60b2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T20:20:45+08:00" />
<meta property="article:modified_time" content="2024-01-02T20:20:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Shell脚本学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1__0"></a>1. 写在前面</h3> 
<p>工作中，需要用到写一些shell脚本去完成一些简单的重复性工作， 于是就想系统的学习下shell脚本的相关知识， 本篇文章是<strong>学习shell脚本整理的学习笔记</strong>，内容参考主要来自<a href="https://c.biancheng.net/shell/" rel="nofollow">C语言中文网</a>， 学习过程中， 加入了一些在学习过程中的实践经验和思考， 并抽取出一些常用的知识内容整理成这篇文章，方便以后回看回练， 如果想更系统的学习， 可以去前面这个网站进行学习。</p> 
<p><strong>大纲如下</strong>：</p> 
<ul><li>Shell基础</li><li>Shell编程</li><li>Shell高级</li><li>Shell的一些快捷操作</li></ul> 
<p>Ok, let’s go!</p> 
<h3><a id="2_Shell_11"></a>2. Shell基础</h3> 
<h4><a id="21_what_12"></a>2.1 what?</h4> 
<p>shell: 用户和内核之间的”代理”</p> 
<ul><li>Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。</li></ul> 
<p><img src="https://images2.imgbox.com/fd/c5/MnEXzI8M_o.png" alt="在这里插入图片描述"></p> 
<p>shell主要用来<mark>开发一些实用的、自动化的小工具</mark>，例如检测计算机的硬件参数、搭建 Web 运行环境、日志分析等，不适合开发具有复杂逻辑的中大型软件。</p> 
<p><mark>shell是一种脚本语言</mark>。</p> 
<ul><li><strong>编译性语言</strong>：<strong>程序运行之前，把所有的代码翻译成二进制形式</strong>(可执行文件), 用户拿到的是可执行文件，看不到源码。这个过程叫做编译，这样的编程语言叫编译性语言，完成编译过程的软件叫编译器。 C/C++， GO等 
  <ul><li>优点是执行速度快、对硬件要求低、保密性好，适合开发操作系统、大型应用程序、数据库等</li></ul> </li><li><strong>解释性语言</strong>：<strong>一边执行，一边翻译，无须生成任何二进制文件</strong>， 用户拿到源码即可运行。程序运行后即时翻译，翻译一部分执行一部分，不会等所有代码都翻译完，这个过程叫做解释， 这样的编程语言叫解释性语言，完成解释过程的软件叫解释器。 python, javascript, php，shell等 
  <ul><li>脚本语言的优点是使用灵活、部署容易、跨平台性好，非常适合 Web 开发以及小工具的制作</li></ul> </li></ul> 
<h4><a id="22_why_27"></a>2.2 why?</h4> 
<p>Shell是运维人员必须掌握的技能, Shell 脚本是<mark>实现 Linux 系统自动管理以及自动化运维所必备的工具</mark></p> 
<ul><li>Linux 运维工程师(OPS): 主要工作就是搭建起运行环境，让程序员写的代码能够高效、稳定、安全地在服务器上运行，他们属于后勤部门。OPS 的要求并不比程序员低，优秀的 OPS 拥有架设服务器集群的能力，还会编程开发常用的工具。工作细节如下： 
  <ul><li>安装操作系统，例如 CentOS、Ubuntu 等。</li><li>部署代码运行环境，例如网站后台语言采用 <a href="https://c.biancheng.net/php/" rel="nofollow">PHP</a>，就需要安装 Nginx、Apache、<a href="https://c.biancheng.net/mysql/" rel="nofollow">MySQL</a>、PHP 运行时等。</li><li>及时修复漏洞，防止服务器被攻击，这包括 Linux 本身漏洞以及各个软件的漏洞。</li><li>根据项目需求升级软件，例如 PHP 7.0 在性能方面获得了重大突破，如果现在服务器压力比较大，就可以考虑将旧版的 PHP 5.x 升级到 PHP 7.0。</li><li>监控服务器压力，别让服务器宕机。例如淘宝双十一的时候就会瞬间涌入大量用户，导致部分服务器宕机，网页没法访问，甚至连支付宝都不能使用。</li><li>分析日志，及时发现代码或者环境的问题，通知相关人员修复</li></ul> </li></ul> 
<h4><a id="23_Shell_37"></a>2.3 常见的Shell</h4> 
<p>常见的 Shell 有 sh、bash、csh、tcsh、ash, zsh等。 我现在使用的是zsh</p> 
<p>bash 由 GNU 组织开发，保持了对 sh shell 的兼容性，是各种 Linux 发行版默认配置的 shell</p> 
<pre><code class="prism language-python"><span class="token comment"># 查看当前系统可用的shell</span>
cat <span class="token operator">/</span>etc<span class="token operator">/</span>shells

<span class="token comment"># 查看当前系统的默认shell  默认是zsh，这里面插件很多，扩充了很多功能</span>
echo $SHELL

</code></pre> 
<p><code>SHELL</code>是 Linux 系统中的环境变量，它指明了当前使用的 Shell 程序的位置，也就是使用的哪个 Shell。</p> 
<p>这里安利一款比较好用的Shell， zsh， 这个安装一些插件之后有自动的代码补齐功能，还有一些很强大的功能，非常方便。</p> 
<pre><code class="prism language-python"><span class="token comment"># 安装zsh </span>
sudo apt<span class="token operator">-</span>get install zsh   <span class="token comment"># 切换完毕之后，需要重新登录</span>
<span class="token comment"># 显示存在的bash</span>
cat <span class="token operator">/</span>etc<span class="token operator">/</span>shells
<span class="token comment"># 取代bash 设为默认shell</span>
sudo usermod <span class="token operator">-</span>s <span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>zsh username  <span class="token keyword">or</span> chsh <span class="token operator">-</span>s <span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>zsh
<span class="token comment"># 切回去bash</span>
chsh <span class="token operator">-</span>s <span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>bash
</code></pre> 
<p>安装上zsh之后，还需要安装一些插件， 才能让其变强大</p> 
<pre><code class="prism language-python"><span class="token comment"># 安装oh my zsh 此时打开终端， 会发现颜色变了， 可以使用zsh --version看是否安装成功</span>
$ sh <span class="token operator">-</span>c <span class="token string">"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</span>

<span class="token comment"># 配置插件主题等</span>
vim <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>zshrc

<span class="token comment"># 推荐的插件  参考：https://segmentfault.com/a/1190000039860436</span>
<span class="token number">1.</span> git 
<span class="token number">2.</span> zsh<span class="token operator">-</span>syntx<span class="token operator">-</span>highlighting<span class="token punctuation">(</span>高亮语法<span class="token punctuation">)</span>
<span class="token number">3.</span> zsh<span class="token operator">-</span>autosuggestions<span class="token punctuation">(</span>自动补全<span class="token punctuation">)</span>

</code></pre> 
<h4><a id="24_Shell_80"></a>2.4 Shell命令</h4> 
<p>Shell 命令分为两种：</p> 
<ul><li>Shell 自带的命令称为内置命令，它在 Shell 内部可以通过函数来实现，当 Shell 启动后，这些命令所对应的代码（函数体代码）也被加载到内存中，所以使用内置命令是非常快速的。</li><li>更多的命令是外部的应用程序，一个命令就对应一个应用程序。运行外部命令是要开启一个新的应用程序，需要创建新的进程，加载代码等，所以效率上比内置命令差很多</li></ul> 
<p>用户输入一个命令，Shell先检测是不是内部的，如果是去执行，如果不是，则检测有没有对应的外部程序，如果有， 则执行，否则报错。</p> 
<p>怎么检测有没有对应的外部程序呢？</p> 
<ul><li> <p>Shell 在启动文件中增加了一个叫做<mark>PATH 的环境变量，该变量就保存了 Shell 对外部命令的查找路径</mark>，如果在这些路径下找不到同名的文件，Shell 报错找不到命令。这就是为啥有些软件安装之后，要配置环境变量的原因，如果不配置，软件里面的有些命令无法在shell里面使用。</p> <pre><code class="prism language-python">echo $PATH
</code></pre> </li></ul> 
<h4><a id="25_Shell_95"></a>2.5 Shell命令的选项和参数</h4> 
<p>shell命令的基本格式：</p> 
<pre><code class="prism language-python">command <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span>
</code></pre> 
<p>选项用于调整命令功能，而命令的参数是这个命令的操作对象。<mark>不管是内置命令还是外部命令，它后面附带的数据最终都以参数的形式传递给了函数</mark></p> 
<h4><a id="26_Shell_104"></a>2.6 Shell命令的提示符</h4> 
<p>命令提示符不是命令的一部分，起到提示作用。</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>wuzhongqiang@localhost <span class="token operator">~</span><span class="token punctuation">]</span>$
</code></pre> 
<p>各个部分的含义如下：</p> 
<ul><li><code>[]</code>是提示符的分隔符号，没有特殊含义。</li><li><code>wuzhongqiang</code>表示当前登录的用户。</li><li><code>@</code>是分隔符号，没有特殊含义。</li><li><code>localhost</code>表示当前系统的简写主机名</li><li><code>~</code>代表用户当前所在的目录为主目录（home 目录）。如果用户当前位于主目录下的 bin 目录中，那么这里显示的就是<code>bin</code>。</li><li><code>$</code>是命令提示符。Linux 用这个符号标识登录的用户权限等级：如果是超级用户（root 用户），提示符就是<code>#</code>；如果是普通用户，提示符就是<code>$</code>。</li></ul> 
<p>Shell通过修改PS1和PS2两个环境变量可以控制上面提示符的格式。</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>wuzhongqiang@localhost <span class="token operator">~</span><span class="token punctuation">]</span>$ echo $PS1
<span class="token punctuation">[</span>\u@\h \W<span class="token punctuation">]</span>\$
<span class="token punctuation">[</span>wuzhongqiang@localhost <span class="token operator">~</span><span class="token punctuation">]</span>$ echo $PS2
<span class="token operator">&gt;</span>

<span class="token punctuation">[</span>wuzhongqiang@localhost <span class="token operator">~</span><span class="token punctuation">]</span>$ PS1<span class="token operator">=</span><span class="token string">"[\t][\u]\$ "</span>
<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">:</span><span class="token number">51</span><span class="token punctuation">:</span><span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">[</span>wuzhongqiang<span class="token punctuation">]</span>$ PS1<span class="token operator">=</span><span class="token string">"[hello, world]\$ "</span>
</code></pre> 
<p>这种修改只对当前会话有效，如果想固定格式，让它对任何 Shell 会话都有效，那么就得把 PS1 变量的修改写入到 Shell 启动文件中</p> 
<h4><a id="27_Shell_133"></a>2.7 Shell脚本</h4> 
<p>shell脚本， 从hello world开始：</p> 
<pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>
echo <span class="token string">"Hello World !"</span>
</code></pre> 
<p><code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell；后面的<code>/bin/bash</code>就是指明了解释器的具体位置。</p> 
<p>脚本中，可以编写各种命令，实现一些自动话的操作等， 可以通过编写注释<code>#</code>开头，让脚本更加通俗易懂。</p> 
<p>Shell脚本的执行方式：</p> 
<ol><li>作为程序执行 <code>chmod a+x [test.sh](http://test.sh) ./test.sh</code></li><li>shell脚本作为参数传递给bash解释器 <code>/bin/bash [test.sh](http://test.sh)</code> , 这种方式运行脚本，其实不需要在脚本文件的第一行指定解释器信</li><li>source命令执行，不需要给脚本增加执行权限 <code>source [test.sh](http://test.sh) 或 . testsh</code> 这个是在当前进程中运行脚本，上面两个是开启了新进程运行脚本</li></ol> 
<p>如果需要在当前进程运行shell脚本，就用3的这两种方式，如果是开一个新进程运行shell脚本，就用1或者2这种方式。</p> 
<h4><a id="28_Shell_152"></a>2.8 Shell配置文件</h4> 
<p>Shell在启动时要配置运行环境，如初始化环境变量、设置命令提示符、指定系统命令路径等。这个过程会加载一系列配置文件。</p> 
<p>如果是登录式方式启动shell</p> 
<ul><li><code>/etc/profile</code>： 全局配置文件， 最优先加载</li><li><code>~/.bash_profile、~/.bash_login、~/.profile</code>： 个人用户的配置文件，不同系统配置文件可能不同，优先级依次降低， bash_profile中会读取bashrc</li></ul> 
<p>如果是非登陆方式启动shell， 会直接读<code>~/.bashrc</code></p> 
<ul><li><code>~/.bashrc、/etc/bashrc、/etc/profile.d/*.sh</code>: bashrc中会读<code>etc/bashrc</code></li></ul> 
<p>上面提到了登录式和非登录式， 这是啥意思呢？</p> 
<p>Shell其实有4种运行方式， 由下面的两个维度两两组合：</p> 
<ol><li>登录和非登录： 登录是需要输入用户名和密码， 非登录就是直接登录了，判断方法： <code>shopt login_shell</code></li><li>交互和非交互：交互是跟shell不停互动， 而非交互是把命令写到shell脚本种，一键运行。判断方法：<code>echo $PS1</code> $PS1在非交互下是空值</li></ol> 
<p>用户编写自己的shell脚本文件：把握好<code>~/.bashrc</code>。</p> 
<ul><li>将自己的一些代码添加到 <code>~/.bashrc</code>，这样每次启动 Shell 都可以个性化地配置。</li><li>或将自己编写的代码放到一个新脚本myconf.sh，然后在 <code>~/.bashrc</code> 中使用类似<code>. ./myconf.sh</code>的形式将新文件引入进来就行了</li></ul> 
<p>输入一个命令之后， Shell是去PATH变量中去找到对应的程序，所以PATH变量的设置很重要。</p> 
<ul><li>如果是登录式shell, PATH在<code>/etc/profile</code>中设置，然后在<code>~/.bash_profile</code>也会增加几个目录</li><li>如果是非登录式，PATH会在<code>etc/bashrc</code>中设置</li></ul> 
<p>如果我们想增加自己的一些命令路径，将路径放到<code>~/.bashrc</code> 中</p> 
<pre><code class="prism language-python">PATH<span class="token operator">=</span>$PATH<span class="token punctuation">:</span>xxx<span class="token operator">/</span>anaconda<span class="token operator">/</span><span class="token builtin">bin</span>
</code></pre> 
<h3><a id="3_Shell_187"></a>3. Shell编程</h3> 
<h4><a id="31__188"></a>3.1 变量</h4> 
<h5><a id="311__189"></a>3.1.1 变量初识</h5> 
<p>shell是一种脚本语言， 符合脚本语言定义变量的规则：<strong>不需要指定类型，直接赋值</strong></p> 
<p>Bash Shell中，每一个变量的值都是字符串，无论用没用引号， <mark>值都会以字符串的形式存储。即使你将整数和小数赋值给变量，它们也会被视为字符串</mark>。</p> 
<p>支持三种变量的定义：</p> 
<pre><code class="prism language-python">variable<span class="token operator">=</span>value
variable<span class="token operator">=</span><span class="token string">'value'</span>
variable<span class="token operator">=</span><span class="token string">"value"</span>
</code></pre> 
<p>赋值号<code>=</code>的周围不能有空格。使用变量， 变量前面加<code>$</code>符号即可, <code>$variable</code></p> 
<p>推荐给所有变量加上花括号<code>{ }</code> ， 有利于帮助解释器识别变量边界 <code>${variable}</code></p> 
<ul><li>单引号<code>' '</code>包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景</li><li>以双引号<code>" "</code>包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义</li></ul> 
<p><img src="https://images2.imgbox.com/33/4a/gcvSeSW2_o.png" alt="在这里插入图片描述"></p> 
<p>如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。</p> 
<p>如果想把命令的结果赋值给变量， 建议用这种方式：</p> 
<pre><code class="prism language-python">variable<span class="token operator">=</span>`command`  <span class="token comment"># 上面这个</span>
variable<span class="token operator">=</span>$<span class="token punctuation">(</span>command<span class="token punctuation">)</span>  <span class="token comment"># 这一种方式建议</span>

<span class="token comment"># 方式一可以在多种shell中有效， 但方式二只在bash shell中有效</span>
<span class="token comment"># 方式一不支持嵌套， 方式二可以</span>
Fir_File_Lines<span class="token operator">=</span>$<span class="token punctuation">(</span>wc <span class="token operator">-</span>l $<span class="token punctuation">(</span>ls <span class="token operator">|</span> sed <span class="token operator">-</span>n <span class="token string">'1p'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>readonly可以将变量声明为只读变量</p> 
<pre><code class="prism language-python">temp<span class="token operator">=</span><span class="token string">"wuzhongqiang"</span>
readonly temp
temp<span class="token operator">=</span><span class="token string">"zhangsan"</span>   <span class="token comment"># read-only variable: temp</span>
</code></pre> 
<p>unset可以删除变量</p> 
<pre><code class="prism language-python">unset variable_name
注意： unset不能删除只读变量
</code></pre> 
<h5><a id="312__239"></a>3.1.2 变量作用域</h5> 
<p>shell中变量的作用域有三种：</p> 
<ol><li> <p>局部变量： 只能在函数内部中使用</p> <p>shell支持自定义函数，但和其他语言不同的是， <strong>shell函数里面定义的变量， 默认是全局变量</strong>， 和在函数外部定义的变量有一样的效果。</p> <pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>
<span class="token comment">#定义函数</span>
function func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    a<span class="token operator">=</span><span class="token number">99</span>
<span class="token punctuation">}</span>
<span class="token comment">#调用函数</span>
func
<span class="token comment">#输出函数内部的变量</span>
echo $a    <span class="token number">99</span>
</code></pre> <p>如果仅仅想在函数内部使用， 需要加local关键字。</p> <pre><code class="prism language-python">function func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	local a<span class="token operator">=</span><span class="token number">99</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>全局变量： 当前shell进程中使用</p> <p>首先，注意一个点，shell进程和shell脚本是两个概念。 打开一个窗口时， 就新建了一个shell进程。 在该窗口下定义的变量，默认就是全局变量， 会在该窗口下有效。如果打开一个新的窗口， 就没有效果了。</p> <p>同一个窗口下，如果有多个shell脚本， 在a.sh中定义一个变量， 在b.sh中输出， 也会同样有效。</p> <p>这里做一个实验：</p> <pre><code class="prism language-python">vim a<span class="token punctuation">.</span>sh
写入：
<span class="token comment">#!/bin/bash</span>
a<span class="token operator">=</span><span class="token number">200</span>
echo $a

vim b<span class="token punctuation">.</span>sh
写入
<span class="token comment">#!/bin/bash</span>
echo $a

<span class="token comment"># 然后</span>
source a<span class="token punctuation">.</span>sh  <span class="token number">200</span>
source b<span class="token punctuation">.</span>sh  <span class="token number">200</span>

bash a<span class="token punctuation">.</span>sh  <span class="token number">200</span>
bash b<span class="token punctuation">.</span>sh  <span class="token string">""</span>
</code></pre> <p>原因是<code>source</code>或者是<code>.</code>, 表示当前进程执行脚本， 而bash表示新开进程执行脚本。 在同一个进程中，变量全局有效。不限于脚本。</p> </li><li> <p>环境变量： 子进程中有效</p> <p>全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用<code>export</code>命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。</p> <p>首先是子进程的概念：父进程中再创建进程， 该进程就是子进程， 父进程里面的变量子进程可以使用。 最简单的方式创建子进程，就是bash命令</p> <p><img src="https://images2.imgbox.com/4a/20/lWgfToKk_o.png" alt="在这里插入图片描述"></p> <p>如果是换一个窗口就无效了。</p> <p>如果想一个变量在所有窗口下都有效， 那就需要写入到配置文件中了。</p> </li></ol> 
<h5><a id="313_Shell_309"></a>3.1.3 Shell的位置参数</h5> 
<p>运行 Shell 脚本文件时可以给它传递一些参数，在脚本文件内部使用<code>$n</code>的形式来接收，例如，$1 表示第一个参数，$2 表示第二个参数…</p> 
<pre><code class="prism language-python">vim a<span class="token punctuation">.</span>sh

<span class="token comment">#!/bin/bash</span>
echo <span class="token string">"$1"</span>
echo <span class="token string">"$2"</span>

<span class="token punctuation">.</span><span class="token operator">/</span>a<span class="token punctuation">.</span>sh hello world
</code></pre> 
<p>在调用函数时也可以传递参数。<strong>Shell 函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目</strong>。换句话说，<mark>定义 Shell 函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用<code>$n</code>的形式接收</mark>，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p> 
<pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>
<span class="token comment">#定义函数</span>
function func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    echo <span class="token string">"$1"</span>
    echo <span class="token string">"$2"</span>
<span class="token punctuation">}</span>
<span class="token comment">#调用函数</span>
func hello world
</code></pre> 
<p>这种通过<code>$n</code>的形式来接收的参数，<mark>在 Shell 中称为位置参数</mark>。</p> 
<h5><a id="314_Shell_337"></a>3.1.4 Shell的特殊变量</h5> 
<p><img src="https://images2.imgbox.com/b9/0e/0RbOfjOG_o.png" alt="在这里插入图片描述"><br> demo:</p> 
<pre><code class="prism language-python">vim c<span class="token punctuation">.</span>sh 

bash c<span class="token punctuation">.</span>sh hello world

<span class="token comment">#!/bin/bash</span>

echo <span class="token string">"process id: $$"</span>   <span class="token number">589461</span>
echo <span class="token string">"file name: $0"</span>    c<span class="token punctuation">.</span>sh
echo <span class="token string">"first param: $1"</span>   hello
echo <span class="token string">"secord param: $2"</span>  world
echo <span class="token string">"all parameters 1: $@"</span>  hello world
echo <span class="token string">"all parameters 2: $*"</span> hello world
echo <span class="token string">"parameters count: $#"</span> <span class="token number">2</span>

<span class="token comment"># 函数亦然</span>
</code></pre> 
<p>几个点需要看一下：</p> 
<ul><li> <p><code>$@</code>和<code>$*</code>: 都表示给传递给脚本或者函数的所有脚本或者参数，如果不被<code>””</code>包围，两者没有区别，都会将每个参数看作一份数据，中间空格隔开。如果被<code>””</code>包围，两者就有区别：</p> 
  <ul><li><code>”$@”</code>: 仍然将每个参数都看作一份数据，彼此之间是独立的</li><li><code>“$*“</code>: 会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据</li></ul> <pre><code class="prism language-python">vim d<span class="token punctuation">.</span>sh

<span class="token comment"># 执行</span>
bash d<span class="token punctuation">.</span>sh a b c d

<span class="token comment">#!/bin/bash  </span>

echo <span class="token string">"$@"</span>    <span class="token comment"># a b c d   echo 输出没有区别</span>
echo <span class="token string">"$*"</span>    <span class="token comment"># a b c d</span>

<span class="token keyword">for</span> var <span class="token keyword">in</span> <span class="token string">"$@"</span>       <span class="token comment"># a</span>
do                    <span class="token comment"># b</span>
        echo $var     <span class="token comment"># c</span>
done                  <span class="token comment"># d</span>

<span class="token keyword">for</span> var <span class="token keyword">in</span> <span class="token string">"$*"</span>
do 
        echo $var    <span class="token comment"># a b c d</span>
done    

<span class="token keyword">for</span> var <span class="token keyword">in</span> $@        <span class="token comment"># a</span>
do                   <span class="token comment"># b</span>
        echo $var    <span class="token comment"># c</span>
done                 <span class="token comment"># d</span>

<span class="token keyword">for</span> var <span class="token keyword">in</span> $<span class="token operator">*</span>       <span class="token comment"># a</span>
do                  <span class="token comment"># b</span>
        echo $var   <span class="token comment"># c</span>
done                <span class="token comment"># d</span>

</code></pre> </li><li> <p><code>$?</code>: 用来获取上一个命令的退出状态，或者上一个函数的返回值</p> <pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"$1"</span> <span class="token operator">==</span> <span class="token number">100</span> <span class="token punctuation">]</span>
then
   exit <span class="token number">0</span>  <span class="token comment">#参数正确，退出状态为0</span>
<span class="token keyword">else</span>
   exit <span class="token number">1</span>  <span class="token comment">#参数错误，退出状态1</span>
fi

bash <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span>sh <span class="token number">100</span>  <span class="token comment"># 开启一个新进程，如果是和上面用同一个进程，退出之后就啥也看不见了</span>
echo $?    <span class="token number">0</span>
bash <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span>sh <span class="token number">1</span>
echo $?    <span class="token number">1</span>

vim test<span class="token punctuation">.</span>sh

<span class="token comment">#!/bin/bash</span>
function test<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> `expr $<span class="token number">1</span>`
<span class="token punctuation">}</span>
test <span class="token number">2</span>
echo $?  <span class="token comment"># 2</span>
</code></pre> <p>Shell 函数中的 return 关键字用来表示函数的退出状态，而不是函数的返回值。</p> </li></ul> 
<h4><a id="32__425"></a>3.2 字符串</h4> 
<p>字符串是 Shell 编程中最常用的数据类型之一。</p> 
<p>字符串可以不被引号包围， 可以被’’包围， 也可以被’’包围， 但是有区别：</p> 
<ul><li><code>‘’</code>包围：任何字符都会原样输出，在其中使用变量是无效的，字符串中不能出现单引号，即使对单引号进行转义也不行。</li><li><code>“”</code>包围：如果其中包含了某个变量，那么该变量会被解析（得到该变量的值），而不是原样输出，如果字符串中有双引号，只要被转义就可以。</li><li>没有引号包围：不被引号包围的字符串中出现变量时也会被解析，这一点和双引号<code>" "</code>包围的字符串一样，字符串中如果出现空格，空格后边的字符串会作为其他变量或者命令解析</li></ul> 
<p>demo:</p> 
<pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>
n<span class="token operator">=</span><span class="token number">666</span>
str0<span class="token operator">=</span>$n
str1<span class="token operator">=</span>hello$n world 
str2<span class="token operator">=</span><span class="token string">"hello \"world\" $n"</span>
str3<span class="token operator">=</span><span class="token string">'hello world $n'</span>
echo $str0    <span class="token comment"># 666</span>
echo $str1    <span class="token comment"># world 未找到命令  如果没有空格， 只会输出hello $n也不会被解析了, 如果是hello"$n"world   此时$n会被解析</span>
echo $str2   <span class="token comment"># hello "world" 666</span>
echo $str3   <span class="token comment"># hello world $n</span>
</code></pre> 
<p>获取字符串的长度 <code>${#str_name}</code></p> 
<pre><code class="prism language-python">echo $<span class="token punctuation">{<!-- --></span><span class="token comment">#str3}  14</span>
</code></pre> 
<p>字符串的拼接： 将两个字符串并排放实现拼接</p> 
<pre><code class="prism language-python">str1<span class="token operator">=</span>$name$url  <span class="token comment">#中间不能有空格</span>
str2<span class="token operator">=</span><span class="token string">"$name $url"</span>  <span class="token comment">#如果被双引号包围，那么中间可以有空格</span>
str3<span class="token operator">=</span>$name<span class="token string">": "</span>$url  <span class="token comment">#中间可以出现别的字符串</span>
str4<span class="token operator">=</span><span class="token string">"$name: $url"</span>  <span class="token comment">#这样写也可以</span>
str5<span class="token operator">=</span><span class="token string">"${name}Script: ${url}index.html"</span>  <span class="token comment">#这个时候需要给变量名加上大括号, 认清楚边界</span>
</code></pre> 
<p>字符串的截取：</p> 
<ul><li> <p>从指定位置截取字符</p> <pre><code class="prism language-python"><span class="token comment"># 从左边开始计数， 截取字符串</span>
$<span class="token punctuation">{<!-- --></span>string<span class="token punctuation">:</span> start <span class="token punctuation">:</span>length<span class="token punctuation">}</span>  <span class="token comment"># start从0开始，length如果不写，截取到末尾</span>
url<span class="token operator">=</span><span class="token string">"hello world"</span>
echo $<span class="token punctuation">{<!-- --></span>url<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span>  <span class="token comment"># llo</span>

<span class="token comment"># 从右边开始计数，截取字符串</span>
$<span class="token punctuation">{<!-- --></span>string<span class="token punctuation">:</span> <span class="token number">0</span><span class="token operator">-</span>start <span class="token punctuation">:</span>length<span class="token punctuation">}</span>
<span class="token comment"># 注意</span>
<span class="token comment"># 从左边开始计数时，起始数字是 0（这符合程序员思维）；</span>
<span class="token comment"># 从右边开始计数时，起始数字是 1（这符合常人思维）。计数方向不同，起始数字也不同。</span>
<span class="token comment"># 不管从哪边开始计数，截取方向都是从左到右。</span>
url<span class="token operator">=</span><span class="token string">"c.biancheng.net"</span>
echo $<span class="token punctuation">{<!-- --></span>url<span class="token punctuation">:</span> <span class="token number">0</span><span class="token operator">-</span><span class="token number">13</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">}</span>  <span class="token comment"># biancheng</span>
</code></pre> </li><li> <p>从指定字符截取字符</p> <p>无法指定字符串长度，只能从指定字符（子字符串）截取到字符串末尾</p> <pre><code class="prism language-python"><span class="token comment"># ‘#’截取字符右边的所有字符</span>
$<span class="token punctuation">{<!-- --></span>string<span class="token comment">#*chars}   # string是要截取的字符串， chars是指定字符， 不包括chars本身</span>
url<span class="token operator">=</span><span class="token string">"http://c.biancheng.net/index.html"</span>
echo $<span class="token punctuation">{<!-- --></span>url<span class="token comment">#*/}  # /c.biancheng.net/index.html</span>
<span class="token comment"># 遇到第一个字符就开始往后截取，如果是希望遇到最后一个指定字符往后截取</span>
echo $<span class="token punctuation">{<!-- --></span>url<span class="token comment">##*/}  # index.html</span>

<span class="token comment"># '%'截取字符左边的所有字符</span>
$<span class="token punctuation">{<!-- --></span>string<span class="token operator">%</span>chars<span class="token operator">*</span><span class="token punctuation">}</span>  <span class="token comment"># 注意*的位置，因为要截取 chars 左边的字符，而忽略 chars 右边的字符，所以*应该位于 chars 的右侧</span>
url<span class="token operator">=</span><span class="token string">"http://c.biancheng.net/index.html"</span>
echo $<span class="token punctuation">{<!-- --></span>url<span class="token operator">%</span><span class="token operator">/</span><span class="token operator">*</span><span class="token punctuation">}</span>  <span class="token comment"># http://c.biancheng.net</span>
echo $<span class="token punctuation">{<!-- --></span>url<span class="token operator">%</span><span class="token operator">%</span><span class="token operator">/</span><span class="token operator">*</span><span class="token punctuation">}</span>  <span class="token comment"># http:</span>
</code></pre> </li></ul> 
<p>字符串的分割(这里是我这边的一个真实需求， 给定两个可以分割的demo)</p> 
<pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>
<span class="token builtin">set</span> <span class="token operator">-</span>eux

car_fqdns<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">"eng.bhd.0001"</span> <span class="token string">"eng.bhd.0003"</span> <span class="token string">"eng.bhd.0004"</span> <span class="token string">"eng.bhd.0009"</span> <span class="token string">"eng.bhd.0010"</span><span class="token punctuation">)</span>

echo <span class="token string">"车辆: ${car_fqdns[*]}, 个数: ${#car_fqdns[*]}"</span>

<span class="token keyword">for</span> car <span class="token keyword">in</span> $car_fqdns
do
        IFS<span class="token operator">=</span><span class="token string">'.'</span> read <span class="token operator">-</span>r car_model car_type car_no <span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span> <span class="token string">"$car"</span>
        echo $car_type<span class="token operator">/</span>$car_no
done

<span class="token comment">#!/bin/bash</span>
<span class="token builtin">set</span> <span class="token operator">-</span>eux

car_fqdns<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">"eng.bhd.0001"</span> <span class="token string">"eng.bhd.0003"</span> <span class="token string">"eng.bhd.0004"</span> <span class="token string">"eng.bhd.0009"</span> <span class="token string">"eng.bhd.0010"</span><span class="token punctuation">)</span>

echo <span class="token string">"车辆: ${car_fqdns[*]}, 个数: ${#car_fqdns[*]}"</span>

<span class="token keyword">for</span> car <span class="token keyword">in</span> $car_fqdns
do
        car_model<span class="token operator">=</span>$<span class="token punctuation">(</span>echo $car <span class="token operator">|</span> cut <span class="token operator">-</span>d<span class="token string">'.'</span> <span class="token operator">-</span>f1<span class="token punctuation">)</span>
        car_type<span class="token operator">=</span>$<span class="token punctuation">(</span>echo $car <span class="token operator">|</span> cut <span class="token operator">-</span>d<span class="token string">'.'</span> <span class="token operator">-</span>f2<span class="token punctuation">)</span>
        car_no<span class="token operator">=</span>$<span class="token punctuation">(</span>echo $car <span class="token operator">|</span> cut <span class="token operator">-</span>d<span class="token string">'.'</span> <span class="token operator">-</span>f3<span class="token punctuation">)</span>
        echo $car_type<span class="token operator">/</span>$car_no
done
</code></pre> 
<h4><a id="33__537"></a>3.3 数组</h4> 
<p>Shell 只支持一维数组，不支持多维数组</p> 
<p>数组定义格式：</p> 
<pre><code class="prism language-python"><span class="token comment"># 数组用()定义，元素之间用空格</span>
array_name<span class="token operator">=</span><span class="token punctuation">(</span>ele1  ele2  ele3 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> elen<span class="token punctuation">)</span>

<span class="token comment"># shell数组是弱类型，不要求数组所有类型相同</span>
arr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">20</span> <span class="token number">56</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span>

<span class="token comment"># 长度也不是固定的，可以根据下表再加</span>
arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">666</span>
</code></pre> 
<p>获取数组元素：</p> 
<pre><code class="prism language-python">$<span class="token punctuation">{<!-- --></span>array_name<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">}</span>

<span class="token comment"># 获取数组中的所有元素  *或者@都可以的</span>
$<span class="token punctuation">{<!-- --></span>nums<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
$<span class="token punctuation">{<!-- --></span>nums<span class="token punctuation">[</span>@<span class="token punctuation">]</span><span class="token punctuation">}</span>

<span class="token comment">#!/bin/bash</span>

arr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span>
echo $<span class="token punctuation">{<!-- --></span>arr<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">}</span>   <span class="token comment"># 1 2 3 4 5</span>
echo $<span class="token punctuation">{<!-- --></span><span class="token comment">#arr[*]}  # 5</span>

<span class="token comment"># 获取数组中的元素个数  加面加#</span>
$<span class="token punctuation">{<!-- --></span><span class="token comment">#array_name[@]}</span>
$<span class="token punctuation">{<!-- --></span><span class="token comment">#array_name[*]}</span>

<span class="token comment"># 如果一个数组元素是字符串， 再通过#获取改字符串的长度</span>
$<span class="token punctuation">{<!-- --></span><span class="token comment">#arr[2]}</span>
</code></pre> 
<p>数组的拼接操作：将数组扩展成列表，然后再拼接起来</p> 
<pre><code class="prism language-python">array_new<span class="token operator">=</span><span class="token punctuation">(</span>$<span class="token punctuation">{<!-- --></span>array1<span class="token punctuation">[</span>@<span class="token punctuation">]</span><span class="token punctuation">}</span>  $<span class="token punctuation">{<!-- --></span>array2<span class="token punctuation">[</span>@<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
array_new<span class="token operator">=</span><span class="token punctuation">(</span>$<span class="token punctuation">{<!-- --></span>array1<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">}</span>  $<span class="token punctuation">{<!-- --></span>array2<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>数组的删除：</p> 
<pre><code class="prism language-python"><span class="token comment"># 删除某个单一的元素</span>
unset arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span>

<span class="token comment"># 删除全部的数组元素</span>
unset arr
</code></pre> 
<p>shell关联数组：也称为”键值对”， 和python里面的字典很像</p> 
<pre><code class="prism language-python"><span class="token comment"># 创建关联数组  必须带有-A选项</span>
declare <span class="token operator">-</span>A stu
stu<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"zhongqiang"</span>
stu<span class="token punctuation">[</span><span class="token string">"age"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"27"</span>
stu<span class="token punctuation">[</span><span class="token string">"sex"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"male"</span>

declare <span class="token operator">-</span>A stu<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"zhongqiang"</span> <span class="token punctuation">[</span><span class="token string">"age"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"27"</span> <span class="token punctuation">[</span><span class="token string">"sex"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"male"</span><span class="token punctuation">)</span>

<span class="token comment"># 访问关联数组元素</span>
echo $<span class="token punctuation">{<!-- --></span>stu<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>  <span class="token comment"># zhongqiang</span>

<span class="token comment"># 获取关联数组元素的所有value  *可以换成@</span>
echo $<span class="token punctuation">{<!-- --></span>stu<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">}</span>  <span class="token comment">#  zhongqiang 27 male</span>
<span class="token comment"># 获取关联数组元素的所有key</span>
echo $<span class="token punctuation">{<!-- --></span>!stu<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">}</span>   <span class="token comment"># name age sex</span>

<span class="token comment"># 获取关联数组的长度</span>
echo $<span class="token punctuation">{<!-- --></span><span class="token comment">#stu[*]}  # 3</span>

<span class="token comment">#获取所有元素值</span>
<span class="token keyword">for</span> value <span class="token keyword">in</span> $<span class="token punctuation">{<!-- --></span>stu<span class="token punctuation">[</span>@<span class="token punctuation">]</span><span class="token punctuation">}</span>
do
    echo $value
done
echo <span class="token string">"****************"</span>
<span class="token comment">#获取所有元素下标（键）</span>
<span class="token keyword">for</span> key <span class="token keyword">in</span> $<span class="token punctuation">{<!-- --></span>!stu<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
do
    echo $key
done
echo <span class="token string">"****************"</span>
<span class="token comment">#列出所有键值对</span>
<span class="token keyword">for</span> key <span class="token keyword">in</span> $<span class="token punctuation">{<!-- --></span>!stu<span class="token punctuation">[</span>@<span class="token punctuation">]</span><span class="token punctuation">}</span>
do
    echo <span class="token string">"${key} -&gt; ${stu[$key]}"</span>
done
</code></pre> 
<h4><a id="34__633"></a>3.4 命令</h4> 
<h5><a id="341__634"></a>3.4.1 内置命令</h5> 
<p>bash自身提供的命令，不是文件系统中某个可执行文件，比如<code>cd</code></p> 
<p>使用type可以确定一个命令是内部还是外部文件:</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ <span class="token builtin">type</span> cd
cd 是 shell 内嵌
<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ <span class="token builtin">type</span> ifconfig
ifconfig 是 <span class="token operator">/</span>usr<span class="token operator">/</span>sbin<span class="token operator">/</span>ifconfig
</code></pre> 
<p>内部命令，不需要触发磁盘IO， 不需要fork出一个单独进程， 所以执行通常比外部命令快。</p> 
<p><code>$PATH</code>变量包含的目录中的大多数，都是外部命令。</p> 
<pre><code class="prism language-python"><span class="token comment"># 最基础的</span>
cd <span class="token punctuation">.</span> <span class="token keyword">break</span> echo <span class="token keyword">exec</span> exit export <span class="token builtin">help</span> kill history pwd read <span class="token builtin">type</span> source nset <span class="token keyword">continue</span> wait

</code></pre> 
<p>下面整理几个比较常用的内部命令：</p> 
<ol><li> <p><code>alias</code>: 给命令创建别名， 如果直接输入该命令，不带参数， 会列出当前shell进程中使用了哪些别名。</p> <pre><code class="prism language-python"><span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ alias
alias egrep<span class="token operator">=</span><span class="token string">'egrep --color=auto'</span>
alias fgrep<span class="token operator">=</span><span class="token string">'fgrep --color=auto'</span>
alias grep<span class="token operator">=</span><span class="token string">'grep --color=auto'</span>
alias l<span class="token punctuation">.</span><span class="token operator">=</span><span class="token string">'ls -d .* --color=auto'</span>
alias ll<span class="token operator">=</span><span class="token string">'ls -l --color=auto'</span>        <span class="token comment"># 这个常用</span>
alias ls<span class="token operator">=</span><span class="token string">'ls --color=auto'</span>
alias vi<span class="token operator">=</span><span class="token string">'vim'</span>
alias which<span class="token operator">=</span><span class="token string">'alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'</span>

<span class="token comment"># alias定义别名</span>
alias new_name<span class="token operator">=</span><span class="token string">'command'</span>

<span class="token comment"># demo</span>
alias shutown<span class="token operator">=</span><span class="token string">'shutdown -h now'</span>
alias timestamp<span class="token operator">=</span><span class="token string">'date +%s'</span>   <span class="token comment"># date可以获取当前UNIX时间戳</span>

<span class="token comment"># 下面尝试了下在aliah.sh中测试alias</span>
<span class="token comment">#!/bin/bash</span>
alias timestamp<span class="token operator">=</span><span class="token string">'date +%s'</span>
echo `timestamp`

<span class="token comment"># 会报错说找不到timestamp命令，这个是因为非交互模式下，alias扩展时关闭的，所以需要用shopt命令将其开启才可以</span>
<span class="token comment"># 所以如果想运行网站上的例子，需要这么干</span>
<span class="token comment">#!/bin/bash</span>
alias timestamp<span class="token operator">=</span><span class="token string">'date +%s'</span>
shopt <span class="token operator">-</span>s expand_aliases
begin<span class="token operator">=</span>`timestamp`  
sleep 20s
finish<span class="token operator">=</span>$<span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span>
difference<span class="token operator">=</span>$<span class="token punctuation">(</span><span class="token punctuation">(</span>finish <span class="token operator">-</span> begin<span class="token punctuation">)</span><span class="token punctuation">)</span>
echo <span class="token string">"run time: ${difference}s"</span>  <span class="token comment"># 20s</span>

<span class="token comment"># unalias 删除别名</span>
unalias timestamp
</code></pre> <p>这里顺便整理下shopt命令， 这个也是shell的内置命令， 控制shell功能选项的开启和关闭，从而控制shell的行为</p> <pre><code class="prism language-python">shopt <span class="token operator">-</span>s opt_name                 Enable <span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">)</span> opt_name<span class="token punctuation">.</span>
shopt <span class="token operator">-</span>u opt_name                 Disable <span class="token punctuation">(</span>unset<span class="token punctuation">)</span> opt_name<span class="token punctuation">.</span>
shopt opt_name                    Show current status of opt_name

<span class="token comment"># 我们可以</span>
shopt command  
<span class="token comment"># 来查看功能选线的状态</span>
<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ shopt expand_aliases
expand_aliases 	on   <span class="token comment"># 交互shell中这东西是开着的，但是在脚本里面， 用这个命令会发现是off，说明非交互shell中这东西关着了，打开之后，才可以用alias命令</span>
</code></pre> <p>上面的别名设置是临时的，只在当前shell进程中有用，如果想对所有shell进程都有效， 就需要把别名写入配置文件。</p> </li><li> <p><code>echo</code>: 用来在终端输出字符串，并在最后默认加换行符，类似于Python里面的print</p> <pre><code class="prism language-python"><span class="token comment"># 如果不希望最后加换行， 可以-n参数</span>
<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ echo <span class="token string">"hello world"</span>
hello world
<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ echo <span class="token operator">-</span>n <span class="token string">"hello world"</span>
hello world<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$

<span class="token comment"># 默认情况，echo不会解析以\开头的转义字符</span>
<span class="token comment"># 如果想让echo解析转义字符， 加-e参数，此时，如果再让他不换行， 也可以加\c</span>
hello world<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ echo <span class="token string">"hello\nworld"</span>
hello\nworld
<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ echo <span class="token operator">-</span>e <span class="token string">"hello\nworld"</span>
hello
world
<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ echo <span class="token operator">-</span>e <span class="token string">"hello\nworld\c"</span>
hello
world<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ echo <span class="token operator">-</span>n <span class="token operator">-</span>e <span class="token string">"hello\nworld"</span>
hello
world<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$
</code></pre> </li><li> <p><code>read</code>: 从标准输入中读取数据赋值给变量，如果没有重定向，默认从键盘，如果有重定向，可以从文件</p> <pre><code class="prism language-python">read <span class="token punctuation">[</span><span class="token operator">-</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>variables<span class="token punctuation">]</span>

<span class="token comment"># options</span>
<span class="token operator">-</span>a array   <span class="token comment"># 读取的数据赋值给数组array</span>
<span class="token operator">-</span>d delimiter  <span class="token comment"># 字符串delimiter指定读取结束的位置(不包括delimiter)， 默认是换行符结束</span>
<span class="token operator">-</span>n num   <span class="token comment"># 读取num个字符</span>
<span class="token operator">-</span>p prompt   <span class="token comment"># 显示提示信息，提示内容prompt</span>
<span class="token operator">-</span>r     <span class="token comment"># 原样读取，\不解释为转移</span>
<span class="token operator">-</span>s     <span class="token comment"># 静默模式，不是在屏幕上显示输入的字符， 密码的时候常用</span>
<span class="token operator">-</span>t seconds  <span class="token comment"># 设置超时时间，单位s，用户没有指定时间输入，read退出</span>
<span class="token operator">-</span>u fd  <span class="token comment"># 用文件描述符fd作为输入源，类似重定向</span>
<span class="token comment"># variables</span>
<span class="token comment"># 也是可选的，如果没有提供变量名，那么读取的数据将存放到环境变量 REPLY</span>

<span class="token comment"># demo</span>
<span class="token comment">#!/bin/bash</span>
read <span class="token operator">-</span>p <span class="token string">"input you name and age &gt; "</span> name age
echo $<span class="token punctuation">{<!-- --></span>name<span class="token punctuation">}</span>
echo $<span class="token punctuation">{<!-- --></span>age<span class="token punctuation">}</span>

<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ bash read<span class="token punctuation">.</span>sh 
<span class="token builtin">input</span> you name <span class="token keyword">and</span> age <span class="token operator">&gt;</span> wuzhongqiang <span class="token number">28</span>
wuzhongqiang
<span class="token number">28</span>
<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$
<span class="token comment"># 看一个静默模式的</span>
<span class="token comment">#!/bin/bash</span>

read <span class="token operator">-</span>sp <span class="token string">"input passwd &gt; "</span> passwd
echo $<span class="token punctuation">{<!-- --></span>passwd<span class="token punctuation">}</span>

<span class="token comment"># 这时候输入的时候， 看不见输入了</span>
</code></pre> </li><li> <p><code>exit</code>: 退出当前进程， 并返回一个退出状态，使用<code>$?</code>可以接收这个状态，当然是在另一个shell进程中。</p> <pre><code class="prism language-python"><span class="token comment"># Shell 进程执行出错时，可以根据退出状态来判断具体出现了什么错误</span>
<span class="token comment"># 比如打开一个文件时，我们可以指定 1 表示文件不存在，2 表示文件没有读取权限，3 表示文件类型不对</span>
<span class="token comment">#!/bin/bash</span>
echo <span class="token string">"befor exit"</span>
exit <span class="token number">1</span>
echo <span class="token string">"after exit"</span>

<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ bash exit<span class="token punctuation">.</span>sh
before exit
<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$ echo $?
<span class="token number">1</span>
<span class="token punctuation">[</span>icss@hadoop102 shell_study<span class="token punctuation">]</span>$

<span class="token comment"># 这里之所以可以直接echo $? 是因为bash是新开了一个进程， 也就是bash新开进程后， 执行了exit.sh脚本</span>
<span class="token comment"># 遇到exit 1就退出新开的进程了，所以没有after exit没有显示</span>
<span class="token comment"># echo $? 其实是另一个进程了，如果上面不是用bash 而是用. exit.sh 就直接退出当前shell窗口了</span>
</code></pre> </li><li> <p><code>declare</code>： 设置变量属性</p> <pre><code class="prism language-python"><span class="token comment"># 用法： +表示给变量加属性， -表示减属性</span>
declare <span class="token punctuation">[</span><span class="token operator">+</span><span class="token operator">/</span><span class="token operator">-</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>aAfFgilprtux<span class="token punctuation">]</span> <span class="token punctuation">[</span>变量名<span class="token operator">=</span>变量值<span class="token punctuation">]</span>

<span class="token comment"># aFfFgilprtux  具体选项</span>
<span class="token comment"># -f [name] 列出之前由用户在脚本中定义的函数名函数体</span>
<span class="token comment"># -F [name]  仅自定义函数名</span>
<span class="token comment"># -g name  shell函数内部创建全局变量</span>
<span class="token comment"># -p [name]  显示指定变量的属性和值</span>
<span class="token comment"># -a name  声明变量是普通数组</span>
<span class="token comment"># -A name  关联数组</span>
<span class="token comment"># -i name  变量定义为整型</span>
<span class="token comment"># -r name[=value]  变量定义为只读(不可修改删除)</span>
<span class="token comment"># -x name[=value] 变量设置为环境变量，等价export name=value</span>

<span class="token comment">#!/bin/bash</span>
declare <span class="token operator">-</span>i m n ret  <span class="token comment">#将多个变量声明为整数</span>
m<span class="token operator">=</span><span class="token number">10</span>
n<span class="token operator">=</span><span class="token number">30</span>
ret<span class="token operator">=</span>$m<span class="token operator">+</span>$n
echo $ret

declare <span class="token operator">-</span>r n<span class="token operator">=</span><span class="token number">10</span>
n<span class="token operator">=</span><span class="token number">20</span>  <span class="token comment"># 报错 只读变量</span>

</code></pre> </li><li> <p>数学计算命令：shell不能直接算数运算， 必须用数学计算命令</p> <p>在 Bash Shell 中，如果不特别指明，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储，所以直接用数学运算符，其实是字符串之间的运算</p> <pre><code class="prism language-python">echo <span class="token number">2</span><span class="token operator">+</span><span class="token number">8</span>  <span class="token comment"># 2+8</span>

<span class="token comment"># 常用的数学计算命令</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 整数运算，效率很高，推荐  注： 只能进行整数运算，不能对小数（浮点数）或者字符串进行运算</span>
result<span class="token operator">=</span>$<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 普通运算</span>
result<span class="token operator">=</span>$<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">4</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 复杂运算</span>
result<span class="token operator">=</span>$<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 逻辑运算</span>
result<span class="token operator">=</span>$<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 自增运算</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span> b<span class="token operator">=</span>a<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 多表达式计算</span>
echo $a  <span class="token comment"># 8</span>
echo $b  <span class="token comment"># 18</span>
c<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 26   以最后一个表达式的结果作为整个(())命令的执行结果</span>

<span class="token comment"># bc 可以处理小数</span>
<span class="token comment"># shell脚本中，借助管道使用bc计算器</span>
variable<span class="token operator">=</span>$<span class="token punctuation">(</span>echo <span class="token string">"expression"</span> <span class="token operator">|</span> bc<span class="token punctuation">)</span>

echo <span class="token string">"3*8"</span><span class="token operator">|</span>bc  <span class="token comment"># 普通</span>
echo <span class="token string">"scale=4;3*8/7;last*5"</span><span class="token operator">|</span>bc   
echo <span class="token string">"scale=5;n=$x+2;e(n)"</span><span class="token operator">|</span>bc <span class="token operator">-</span>l   <span class="token comment"># shell脚本中的变量</span>

<span class="token comment"># 如果是大量的数学运算， 用输入重定向比较方便 可以换行写</span>
variable<span class="token operator">=</span>$<span class="token punctuation">(</span>bc <span class="token operator">&lt;&lt;</span> EOF
expressions
EOF
<span class="token punctuation">)</span>

m<span class="token operator">=</span>1E
n<span class="token operator">=</span>$<span class="token punctuation">(</span>bc <span class="token operator">&lt;&lt;</span> EOF
<span class="token operator">&gt;</span> obase<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>   <span class="token comment"># 10进制</span>
<span class="token operator">&gt;</span> ibase<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">;</span>   <span class="token comment"># 16进制</span>
<span class="token operator">&gt;</span> <span class="token keyword">print</span> $m
<span class="token operator">&gt;</span> EOF
<span class="token operator">&gt;</span> <span class="token punctuation">)</span>
</code></pre> <p>另外一种方式，使用declare命令，将变量声明为整数，但不灵活，开发中很少用</p> <pre><code class="prism language-python">declare <span class="token operator">-</span>i m n ret
m<span class="token operator">=</span><span class="token number">10</span>
n<span class="token operator">=</span><span class="token number">30</span>
ret<span class="token operator">=</span>$m<span class="token operator">+</span>$n
echo $ret
echo $m<span class="token operator">+</span>$n   <span class="token comment"># 此时， m,n依然被看作字符串</span>

<span class="token comment"># 注意</span>
<span class="token comment"># 除了将参与运算的变量定义为整数，还得将承载结果的变量定义为整数，而且只能用整数类型的变量来承载运算结果，不能直接使用 echo 输出</span>
</code></pre> </li></ol> 
<h4><a id="35__878"></a>3.5 结构</h4> 
<h5><a id="351_if_else_879"></a>3.5.1 if else语句</h5> 
<pre><code class="prism language-python"><span class="token comment"># 最简单的if语句</span>
<span class="token keyword">if</span>  condition
then
    statement<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
fi

<span class="token comment"># 还有种写法  下面的分号是必要的</span>
<span class="token keyword">if</span>  condition<span class="token punctuation">;</span>  then
    statement<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
fi

<span class="token comment"># if else</span>
<span class="token keyword">if</span>  condition
then
   statement1
<span class="token keyword">else</span>
   statement2
fi

<span class="token comment"># if elif </span>
<span class="token keyword">if</span>  condition1
then
   statement1
<span class="token keyword">elif</span> condition2
then
    statement2
<span class="token keyword">elif</span> condition3
then
    statement3
……
<span class="token keyword">else</span>
   statementn
fi
</code></pre> 
<p>选择结构语句比较常规，比较重要的是， 怎么写判断条件， <code>[[]]</code>用来检测某个条件是否成立。</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span><span class="token punctuation">[</span> expression <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 空格必须</span>

<span class="token comment"># 支持多个表达式的判断</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> expression1 <span class="token operator">|</span><span class="token operator">|</span> expression2 <span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> expression1 <span class="token operator">&amp;</span><span class="token operator">&amp;</span> expression2 <span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> !expression1 <span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>在shell脚本中， 经常使用判断语句来使得脚本更好的健壮性， 比如判断文件存不存在，目录是否存在， 输入是否有误等， 上面的语法可以检测某个条件是否成立，那么常用的判断条件会有哪些呢？</p> 
<pre><code class="prism language-python"><span class="token comment"># 文件类型检测相关</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>b filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在，并且是否为块设备文件</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>c filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在，并且是否为字符设备文件</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>d filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在，并且是否为目录文件（常用）</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>e filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>f filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在，并且是否为普通文件</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>L filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在，并且是否为符号链接文件</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>p filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在，并且是否为管道文件</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>s filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在，并且是否为非空</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>S filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在，并且是否为套接字文件</span>

<span class="token comment"># 文件权限检测相关</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>r filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在，并且是否有读权限</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>w filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在，并且是否有写权限</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>x filename <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 文件是否存在，并且是否有执行权限</span>

<span class="token comment"># 数值比较相关</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> num1 <span class="token operator">-</span>eq num2 <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># num1是否和num2相等</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> num1 <span class="token operator">-</span>ne num2 <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># num1是否和num2不相等</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> num1 <span class="token operator">-</span>gt num2 <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># num1是否大于num2</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> num1 <span class="token operator">-</span>lt num2 <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># num1是否小于num2</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> num1 <span class="token operator">-</span>ge num2 <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># num1是否大于等于num2</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> num1 <span class="token operator">-</span>le num2 <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># num1是否小于等于num2</span>

<span class="token comment"># 字符串判断相关</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>z <span class="token builtin">str</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 判断字符串str是否为空</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>n <span class="token builtin">str</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 判断字符串str是否非空</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> str1<span class="token operator">==</span>str2 <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 判断两字符串是否相等</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> str1\<span class="token operator">&gt;</span>str2 <span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 判断是否大于， 注意这里是转义，防止&gt;误认为重定向  \&lt;</span>
</code></pre> 
<p>注意两点：</p> 
<ol><li>Shell 中，<code>==、&gt;、&lt;</code>只能用来比较字符串，不能比较数字</li><li>不管是比较数字还是字符串，Shell 都不支持 <code>&gt;=</code> 和 <code>&lt;=</code> 运算符</li></ol> 
<p>一个建议：<code>[[ ]]</code> 对数字的比较仍然不友好，使用 if 判断条件时，用 <code>(())</code> 来处理整型数字，用 <code>[[ ]]</code> 来处理字符串或者文件，如果用到小数， 用bc</p> 
<h5><a id="352_case_in_968"></a>3.5.2 case in语句</h5> 
<p>当分支较多，并且判断条件比较简单时，使用 case in 语句可能会方便。</p> 
<pre><code class="prism language-python"><span class="token keyword">case</span> expression <span class="token keyword">in</span>
    pattern1<span class="token punctuation">)</span>
        statement1
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    pattern2<span class="token punctuation">)</span>
        statement2
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    pattern3<span class="token punctuation">)</span>
        statement3
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    ……
    <span class="token operator">*</span><span class="token punctuation">)</span>
        statementn
esac

<span class="token comment"># expression 可以是一个变量，一个数字，字符串活表达式，命令的执行结果等</span>
<span class="token comment"># pattern 可以是数字，字符串， 简单正则</span>

<span class="token comment"># ;;类似于 c里面的break， *类似于c里面的default， *之前的判断里面必须带着;;，否则会有语法错误</span>
<span class="token comment"># *作为最后的兜底</span>

<span class="token comment"># demo</span>
<span class="token comment">#!/bin/bash</span>
read <span class="token operator">-</span>n <span class="token number">1</span> char
<span class="token keyword">case</span> $char <span class="token keyword">in</span>
    <span class="token punctuation">[</span>a<span class="token operator">-</span>zA<span class="token operator">-</span>Z<span class="token punctuation">]</span><span class="token punctuation">)</span>
        printf <span class="token string">"\nletter\n"</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        printf <span class="token string">"\nDigit\n"</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        printf <span class="token string">"\nDigit\n"</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">.</span>?!<span class="token punctuation">]</span><span class="token punctuation">)</span>
        printf <span class="token string">"\nPunctuation\n"</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">)</span>
        printf <span class="token string">"\nerror\n"</span>
esac
</code></pre> 
<h5><a id="353_while_1014"></a>3.5.3 while循环</h5> 
<pre><code class="prism language-python"><span class="token keyword">while</span> condition
do
    statements
done

<span class="token comment"># demo</span>

<span class="token comment">#!/bin/bash</span>
read m
read n
<span class="token builtin">sum</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
do
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">sum</span> <span class="token operator">+=</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
done
echo <span class="token string">"The sum is: $sum"</span>
</code></pre> 
<h5><a id="354_for_1036"></a>3.5.4 for循环</h5> 
<p>shell支持两种风格的for循环， c风格和python风格， 这里只整理Python风格，平时用python较多。</p> 
<pre><code class="prism language-python"><span class="token keyword">for</span> variable <span class="token keyword">in</span> value_list
do
    statements
done

<span class="token comment"># 取值列表 value_list 的形式有多种</span>
<span class="token comment"># 直接给出具体的值 "abc" "390" "tom"</span>
<span class="token comment"># 可以给出一个范围 {start..end}， 比如{1..100} {A..z}   仅支持数字和字母</span>
<span class="token comment"># 可以使用命令产生的结果 $(seq 2, 2, 100)  表示从2开始，每次增加2到100，类似于python里面的range(2, 101, 2) $(ls *.sh)</span>
<span class="token comment"># 甚至使用通配符 *.sh</span>
<span class="token comment"># 使用特殊变量 $@ $*等</span>

<span class="token comment"># demo</span>
<span class="token comment">#!/bin/bash</span>
<span class="token keyword">for</span> filename <span class="token keyword">in</span> <span class="token operator">*</span><span class="token punctuation">.</span>sh
do
    echo $filename
done
</code></pre> 
<h5><a id="355_select_in__1061"></a>3.5.5 select in 循环详解</h5> 
<p>用来增强交互， 可以显示出带编号的菜单，用户输入不同编号， 可以选择不同菜单，执行不同功能。</p> 
<p>通常和case in一起使用，根据用户输入编号的不同作出反应</p> 
<pre><code class="prism language-python"><span class="token comment"># 注意，select 是无限循环（死循环），输入空值，或者输入的值无效，都不会结束循环</span>
<span class="token comment"># 只有遇到 break 语句，或者按下 Ctrl+D 组合键才能结束循环</span>
select variable <span class="token keyword">in</span> value_list
do
    statements
done

<span class="token comment"># 这里写一个demo  vim select_in.sh</span>
<span class="token comment">#!/bin/bash</span>

select name <span class="token keyword">in</span> <span class="token string">"wuzhongqiang"</span> <span class="token string">"zhangsan"</span> <span class="token string">"lisi"</span>
do
        <span class="token keyword">case</span> $name <span class="token keyword">in</span>
                <span class="token string">"wuzhongqiang"</span><span class="token punctuation">)</span>
                        echo <span class="token string">"${name} age 28"</span>
                        <span class="token punctuation">;</span><span class="token punctuation">;</span>
                <span class="token string">"zhangsan"</span><span class="token punctuation">)</span>
                        echo <span class="token string">"${name} age 30"</span>
                        <span class="token punctuation">;</span><span class="token punctuation">;</span>
                <span class="token string">"lisi"</span><span class="token punctuation">)</span>
                        echo <span class="token string">"${name} age 10"</span>
                        <span class="token punctuation">;</span><span class="token punctuation">;</span>
                <span class="token operator">*</span><span class="token punctuation">)</span>      
                        echo <span class="token string">"输入有错误"</span>
        esac
done

<span class="token comment"># 执行</span>
<span class="token punctuation">[</span>icss@hadoop102 <span class="token operator">~</span><span class="token punctuation">]</span>$ bash select_in<span class="token punctuation">.</span>sh
<span class="token number">1</span><span class="token punctuation">)</span> wuzhongqiang
<span class="token number">2</span><span class="token punctuation">)</span> zhangsan
<span class="token number">3</span><span class="token punctuation">)</span> lisi
<span class="token comment">#? 1</span>
wuzhongqiang age <span class="token number">28</span>
<span class="token comment">#? 2</span>
zhangsan age <span class="token number">30</span>
<span class="token comment">#? 3</span>
lisi age <span class="token number">10</span>
<span class="token comment">#? 4</span>
输入有错误
<span class="token comment">#? 5</span>
输入有错误
<span class="token comment">#? 3</span>
lisi age <span class="token number">10</span>
<span class="token comment">#?</span>
</code></pre> 
<h4><a id="36__1114"></a>3.6 函数</h4> 
<p>语法格式：</p> 
<pre><code class="prism language-python">function name<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    statements
    <span class="token punctuation">[</span><span class="token keyword">return</span> value<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment"># 和其它编程语言不同的是，Shell 函数在定义时不能指明参数，但是在调用时却可以传递参数，并且给它传递什么参数它就接收什么参数</span>
<span class="token comment"># Shell 也不限制定义和调用的顺序，你可以将定义放在调用的前面，也可以反过来，将定义放在调用的后面</span>

<span class="token comment"># demo</span>
<span class="token comment">#!/bin/bash</span>
function getsum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    local <span class="token builtin">sum</span><span class="token operator">=</span><span class="token number">0</span>
    <span class="token keyword">for</span> n <span class="token keyword">in</span> $@
    do
         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token operator">+=</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    done
    <span class="token keyword">return</span> $<span class="token builtin">sum</span>
<span class="token punctuation">}</span>
getsum <span class="token number">10</span> <span class="token number">20</span> <span class="token number">55</span> <span class="token number">15</span>  <span class="token comment">#调用函数并传递参数</span>
echo $?  <span class="token comment"># 100    # 这种方法虽然可用，但在shell中，这种方式非常错误 原因下面解释</span>
</code></pre> 
<ul><li> <p>shell的函数参数：</p> <p>函数参数是 shell位置参数的一种，在函数内部可以使用<code>$n</code>来接收，例如，<code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数</p> <p><code>$#</code>: 获取传递参数的个数 <code>$*</code>或者<code>$@</code>一次性获取所有参数。</p> <pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>
<span class="token comment">#定义函数</span>
function show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    echo <span class="token string">"Name: $1"</span>
    echo <span class="token string">"Age: $2"</span>
<span class="token punctuation">}</span>
<span class="token comment">#调用函数</span>
function getsum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    local <span class="token builtin">sum</span><span class="token operator">=</span><span class="token number">0</span>
    <span class="token keyword">for</span> n <span class="token keyword">in</span> $@
    do
         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token operator">+=</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    done
    echo $<span class="token builtin">sum</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
<span class="token comment">#调用函数并传递参数，最后将结果赋值给一个变量</span>
total<span class="token operator">=</span>$<span class="token punctuation">(</span>getsum <span class="token number">10</span> <span class="token number">20</span> <span class="token number">55</span> <span class="token number">15</span><span class="token punctuation">)</span>
echo $total  <span class="token comment"># 100  等价于echo $(getsum 10 20 55 15)</span>
</code></pre> </li><li> <p>shell的函数返回值：</p> <p>在 大部分编程语言中，返回值是指函数被调用之后，执行函数体中的代码所得到的结果，这个结果就通过 return 语句返回。</p> <p>But在shell中， 返回值表示的是函数的退出状态：</p> 
  <ul><li>返回值为 0 表示函数执行成功了，返回值为非 0 表示函数执行失败</li><li>函数执行失败时，可以根据返回值（退出状态）来判断具体出现了什么错误</li><li>如果函数体中没有return语句， 就会使用最后一条命令的退出状态</li></ul> <p>所以，在shell中，用<code>return返回函数的处理结果是不对</code>的。那么怎么得到函数的处理结果呢？两种方案</p> 
  <ol><li>借助全局变量， 将得到的结果赋值给全局变量</li><li>另外一种是在函数内部用<code>echo, printf</code>命令将结果输出，在函数外部用<code>$(</code>)或者````捕获结果</li></ol> <pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>
<span class="token builtin">sum</span><span class="token operator">=</span><span class="token number">0</span>  <span class="token comment">#全局变量</span>
function getsum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">=</span>$<span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>$<span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> do
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token operator">+=</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">#改变全局变量</span>
    done
    <span class="token keyword">return</span> $?  <span class="token comment">#返回上一条命令的退出状态</span>
<span class="token punctuation">}</span>
read m
read n
<span class="token keyword">if</span> getsum $m $n<span class="token punctuation">;</span> then
    echo <span class="token string">"The sum is $sum"</span>  <span class="token comment">#输出全局变量</span>
<span class="token keyword">else</span>
    echo <span class="token string">"Error!"</span>
fi

<span class="token comment"># 这种方法的弊端： 定义函数的同时还得额外弄一个全局变量，而全局变量是个不太好的编程思路，无意中可能增加函数之间的耦合性</span>

<span class="token comment"># 下面的方式较为优雅</span>
<span class="token comment">#!/bin/bash</span>
function getsum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    local <span class="token builtin">sum</span><span class="token operator">=</span><span class="token number">0</span>  <span class="token comment">#局部变量</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">=</span>$<span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>$<span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> do
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token operator">+=</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
    done
   
    echo $<span class="token builtin">sum</span>
    <span class="token keyword">return</span> $?
<span class="token punctuation">}</span>
read m
read n
total<span class="token operator">=</span>$<span class="token punctuation">(</span>getsum $m $n<span class="token punctuation">)</span>   <span class="token comment"># 捕获住了函数里面的输出给到total</span>
echo <span class="token string">"The sum is $total"</span>

<span class="token comment"># 如果函数里面， 想获取到多个输出怎么办呢？  从一个echo中打印，然后函数外部获取</span>
<span class="token comment">#!/bin/bash</span>

function getsum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    local <span class="token builtin">sum</span><span class="token operator">=</span><span class="token number">0</span>
    local product<span class="token operator">=</span><span class="token number">1</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">=</span>$<span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>$<span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> do
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token operator">+=</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>product<span class="token operator">*=</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
    done

    echo <span class="token string">"${sum} ${product}"</span>   <span class="token comment"># echo ${sum} ${product}也可以</span>
    <span class="token keyword">return</span> $?
<span class="token punctuation">}</span>
read m
read n
total<span class="token operator">=</span>$<span class="token punctuation">(</span>getsum $m $n<span class="token punctuation">)</span>
echo <span class="token string">"${total[*]}"</span>  <span class="token comment"># 可以算累加和累乘</span>
</code></pre> <p>下面看一个高级的， 就是想统计下某个目录下的文件个数</p> <pre><code class="prism language-python"><span class="token comment">#!/bin/sh</span>

func<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	echo `ls <span class="token operator">-</span><span class="token number">1</span> $ROOT_PATH`   <span class="token comment"># 没有""括起来， 第一个变量就返回了</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> `func`
do
	echo $i
done
<span class="token comment"># 但注意，echo的返回值， 被认为是一个一个的变量，所以必须写个for循环才能循环把文件都打印出来</span>

<span class="token comment"># 如果想统计某个目录下的文件个数呢， 用下面方式才可以</span>
<span class="token comment">#!/bin/sh</span>
func<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	echo <span class="token string">"`ls -1 $ROOT_PATH`"</span>  <span class="token comment"># 这样用""括起来， 这个命令的执行结果就变成了一个变量</span>
<span class="token punctuation">}</span>

echo `func <span class="token operator">|</span> wc <span class="token operator">-</span>l`  <span class="token comment"># 这样才能统计到正确的数</span>
</code></pre> </li></ul> 
<h3><a id="4_Shell_1263"></a>4. Shell高级</h3> 
<h4><a id="41_Shell_1264"></a>4.1 Shell重定向</h4> 
<p>标准的输入和输出： 用户从键盘输入，把输入给的到程序， 程序计算，产生结果，输出到屏幕</p> 
<ul><li>输入重定向： 数据不是从键盘输入给到程序，而是改变了输入源，比如从文件</li><li>输出重定向： 程序计算完结果不是输出到屏幕，而是改变了输出点，比如文件</li></ul> 
<h5><a id="411__1269"></a>4.1.1 输出重定向</h5> 
<p>指命令的结果不输出到屏幕上，而是输出到其他地方保存，需要的时候可以随时查。</p> 
<pre><code class="prism language-python"><span class="token comment"># 标准输出重定向</span>
command <span class="token operator">&gt;</span><span class="token builtin">file</span>   <span class="token comment"># command的正确结果输出，覆盖的方式输出到文件</span>
command <span class="token operator">&gt;&gt;</span><span class="token builtin">file</span>  <span class="token comment"># command的正确结果输出，追加的方式输出到文件</span>
command <span class="token number">2</span><span class="token operator">&gt;</span><span class="token builtin">file</span>  <span class="token comment"># command的错误结果输出，覆盖的方式输出到文件</span>
command <span class="token number">2</span><span class="token operator">&gt;&gt;</span><span class="token builtin">file</span>  <span class="token comment"># command的错误结果输出， 追加的方式输出到文件</span>

<span class="token comment"># 正确输出和错误输出同时保存</span>
command <span class="token operator">&gt;</span><span class="token builtin">file</span> <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>   <span class="token comment"># 覆盖的方式， 把command正确错误信息都保存到file</span>
command <span class="token operator">&gt;&gt;</span><span class="token builtin">file</span> <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>   <span class="token comment"># 追加的方式， 把command...</span>
command <span class="token operator">&gt;</span>file1 <span class="token number">2</span><span class="token operator">&gt;</span>file2  <span class="token comment"># 覆盖的方式， command的正确结果保存到file1, 错误结果保存到file2</span>
command <span class="token operator">&gt;&gt;</span>file1 <span class="token number">2</span><span class="token operator">&gt;&gt;</span>file2   <span class="token comment"># 追加的方式， ....</span>

<span class="token comment"># 输出重定向的完整写法其实是fd&gt;file或者fd&gt;&gt;file，其中 fd 表示文件描述符，如果不写，默认为 1，也就是标准输出文件</span>
<span class="token comment"># 默认为1时，可以省略， 如果不省略， command 1&gt;file, 1和&gt;不能有空格</span>

<span class="token comment"># demo</span>
<span class="token comment">#!/bin/bash</span>

<span class="token keyword">for</span> <span class="token builtin">str</span> <span class="token keyword">in</span> <span class="token string">"wuzhongqiang"</span> <span class="token string">"zhangsan"</span> <span class="token string">"lisi"</span>
do      
        echo $<span class="token builtin">str</span><span class="token operator">&gt;&gt;</span><span class="token string">"name.txt"</span>
done

➜  shell_study cat name<span class="token punctuation">.</span>txt   
wuzhongqiang
zhangsan
lisi

<span class="token comment"># 错误的输出重定向</span>
➜  shell_study ls java
ls<span class="token punctuation">:</span> 无法访问 <span class="token string">'java'</span><span class="token punctuation">:</span> 没有那个文件或目录
➜  shell_study ls java <span class="token number">2</span><span class="token operator">&gt;</span>error<span class="token punctuation">.</span>log
➜  shell_study cat error<span class="token punctuation">.</span>log 
ls<span class="token punctuation">:</span> 无法访问 <span class="token string">'java'</span><span class="token punctuation">:</span> 没有那个文件或目录

</code></pre> 
<h5><a id="412__1309"></a>4.1.2 输入重定向</h5> 
<p>输入重定向就是改变输入的方向，不再使用键盘作为命令输入的来源，而是使用文件作为命令的输入。</p> 
<pre><code class="prism language-python">command <span class="token operator">&lt;</span><span class="token builtin">file</span>   <span class="token comment"># file的内容作为command的输入</span>
command <span class="token operator">&lt;&lt;</span>END   <span class="token comment"># 标准输入作为command输入，直到遇到END为止</span>
command <span class="token operator">&lt;</span><span class="token builtin">file</span> <span class="token operator">&gt;&gt;</span>file2   <span class="token comment"># file作为command的输入，并把输出结果给到file2</span>

<span class="token comment"># demo 统计文档中的单词个数</span>
wc <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>文件名<span class="token punctuation">]</span>   
<span class="token comment"># -c 统计字节数</span>
<span class="token comment"># -w 统计单词数</span>
<span class="token comment"># -l 统计行数</span>

<span class="token comment"># demo </span>
wc <span class="token operator">-</span>l <span class="token operator">&lt;</span>name<span class="token punctuation">.</span>txt   <span class="token comment"># 4</span>
</code></pre> 
<p>Linux中一切皆文件，为了表示和区分文件，linux会给每个文件分配一个编号， 这个编号就是文件描述符。</p> 
<p>一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。</p> 
<p>除了文件描述符表，系统还维护另外两个表：</p> 
<ul><li>打开文件表</li><li>i-node表</li></ul> 
<p>文件描述符表，每个进程都有一个， 而后面两个表，是系统维护的。</p> 
<p><img src="https://images2.imgbox.com/cf/15/1gLVR9mx_o.png" alt="在这里插入图片描述"></p> 
<p><strong>文件描述符是一个数组下标</strong>，通过<mark>文件描述符，可以找到文件指针，从而进入打开文件表</mark>。该表存储了以下信息：</p> 
<ul><li>文件偏移量，也就是文件内部指针偏移量。调用 <code>read()</code> 或者 <code>write()</code> 函数时，文件偏移量会自动更新，当然也可以使用 <code>lseek()</code> 直接修改。</li><li>状态标志，比如只读模式、读写模式、追加模式、覆盖模式等。</li><li>i-node 表指针。</li></ul> 
<p>然而，要<mark>想真正读写文件，还得通过打开文件表的 i-node 指针进入 i-node 表</mark>，该表包含了诸如以下的信息：</p> 
<ul><li>文件类型，例如常规文件、套接字或 FIFO。</li><li>文件大小。</li><li>时间戳，比如创建时间、更新时间。</li><li>文件锁。</li></ul> 
<p>所以Linux每次读写文件的时候，都从文件描述符下手，通过文件描述符找到文件指针，然后进入打开文件表和 i-node 表。</p> 
<p>那么重定向是怎么做到的呢？ <mark>输入输出重定向就是通过修改文件指针实现的</mark></p> 
<ul><li> <p>发生重定向的时候，文件描述符并没有改变，<mark>改变的是文件描述符对应的文件指针</mark>。对于标准输出，Linux 系统始终向文件描述符 1 中输出内容，而不管它的文件指针指向哪里；只要我们修改了文件指针，就能向任意文件中输出内容</p> <pre><code class="prism language-python">command <span class="token number">1</span><span class="token operator">&gt;</span>log<span class="token punctuation">.</span>txt  <span class="token comment"># 把文件描述符1的文件指针指向了log.txt， 那么就会往log.txt中输出内容</span>
</code></pre> <p><code>&gt; 和 &lt;</code> 通过修改文件描述符改变了文件指针的指向，所以能够实现重定向的功能。</p> </li></ul> 
<p>那么shell对文件描述符有哪些操作呢？ 弄明白这个，才能看懂上面重定向的一些写法</p> 
<pre><code class="prism language-python"><span class="token comment"># 输出, 输入的时候同理， 无非是把&gt;换成&lt;</span>
n<span class="token operator">&gt;</span>filename  <span class="token comment"># 输出的方式打开filename, 并绑定到文件描述符n,默认是1,即标准输出  1&gt;log.txt   把指向log.txt的文件指针绑定到了1</span>
n<span class="token operator">&gt;</span><span class="token operator">&amp;</span>m  <span class="token comment"># 文件描述符m的内容覆盖文件描述符n, 比如上面command &gt;file 2&gt;&amp;1， 首先是file的文件指针绑定到了1, 然后又把文件描述符1的内容覆盖了2,2也指向了file</span>
n<span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token operator">-</span> <span class="token comment"># 关闭文件描述符n及代表的文件</span>
<span class="token operator">&amp;</span><span class="token operator">&gt;</span>filename  <span class="token comment"># 正确和错误的输出结果全部重定向到filename</span>
</code></pre> 
<h5><a id="413_exec_1378"></a>4.1.3 exec命令操作文件描述符</h5> 
<p>上面使用的重定向是临时的，只对当前命令有效</p> 
<pre><code class="prism language-python">echo <span class="token string">"hello world"</span> <span class="token operator">&gt;</span> log<span class="token punctuation">.</span>txt
echo <span class="token string">"hello shell"</span>  <span class="token comment"># hello shell</span>
cat log<span class="token punctuation">.</span>txt  <span class="token comment"># hello world</span>

<span class="token comment"># 只把hello world写入到了log.txt中，也就是重定向方法，只对当前命令有效</span>

<span class="token comment"># 如果想所有的echo命令，都写入到文件怎么办？  第一种方式就是每次echo都对他重定向， 显然太麻烦，于是乎，可以用exec,对当前shell中所有echo都重定向</span>
<span class="token keyword">exec</span> <span class="token number">1</span><span class="token operator">&gt;</span>log<span class="token punctuation">.</span>txt
echo <span class="token string">"hello world"</span>  <span class="token comment"># 此时，都会直接往log.txt里面写了</span>
echo <span class="token string">"hello shell"</span>

<span class="token keyword">exec</span> <span class="token number">1</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">2</span>   <span class="token comment"># 用2的文件指针内容覆盖1, 2这个是错误信息的输出指向，默认是显示屏，覆盖之后， 1就恢复成原样子,或者1&gt;/dev/tty  这个是显示器</span>
echo <span class="token string">"hello C++"</span>   <span class="token comment"># 此时就输出到屏幕了</span>

<span class="token comment"># 那么如果2里面的内容也被永久重定向怎么办？  那这种方式就无效了， 所以最好是exec重定向之前，也备份一下</span>
<span class="token keyword">exec</span> <span class="token number">6</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>     <span class="token comment"># 这样可以用1&gt;&amp;6把1给恢复了</span>

<span class="token comment"># 输入重定向</span>
<span class="token comment">#!/bin/bash</span>
<span class="token keyword">exec</span> <span class="token number">6</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token number">0</span>  <span class="token comment">#先将0号文件描述符保存</span>
<span class="token keyword">exec</span> <span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>txt  <span class="token comment">#输入重定向</span>
<span class="token builtin">sum</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">while</span> read n<span class="token punctuation">;</span> do
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">sum</span> <span class="token operator">+=</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
done
echo <span class="token string">"sum=$sum"</span>
<span class="token keyword">exec</span> <span class="token number">0</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token number">6</span> <span class="token number">6</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token operator">-</span>  <span class="token comment">#恢复输入重定向，并关闭文件描述符6</span>
</code></pre> 
<h4><a id="42__1411"></a>4.2 代码块重定向</h4> 
<p>代码块，就是由多条语句组成的一个整体；for、while、until 循环，或者 if…else、case…in 选择结构，或者由<code>{ }</code>包围的命令都可以称为代码块</p> 
<p>重定向命令放在代码块的结尾处，就可以对代码块中的所有命令实施重定向。</p> 
<pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>
<span class="token builtin">sum</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">while</span> read n<span class="token punctuation">;</span> do
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">sum</span> <span class="token operator">+=</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    echo <span class="token string">"this number: $n"</span>
done <span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>txt <span class="token operator">&gt;</span>log<span class="token punctuation">.</span>txt  <span class="token comment"># 从nums.txt里面读入n， 然后把最后的计算结果输出到log.txt</span>
echo <span class="token string">"sum=$sum"</span>
</code></pre> 
<h4><a id="43_Here_Document_1425"></a>4.3 Here Document与字符串重定向</h4> 
<p>Shell 还有一种特殊形式的重定向叫做“Here Document”， 可以理解成文档重定向，适合想在脚本中嵌入小块数据的情况</p> 
<pre><code class="prism language-python">command <span class="token operator">&lt;&lt;</span>END
    document  <span class="token comment"># 告诉 Shell 把 document 部分作为命令需要处理的数据，直到遇见终止符END为止</span>
END

<span class="token comment"># 这个感觉不常用， 衍生的字符串重定向有用</span>
command <span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span> string
<span class="token comment"># 对于发送较短的数据到进程很方便，比如</span>
tr a<span class="token operator">-</span>z A<span class="token operator">-</span>Z <span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span> one  <span class="token comment"># ONE    # 小写转成大写</span>

<span class="token comment"># 下面这个实用的多一些， 把字符串发送到grep 或者 sed 这样的过滤程序还是很方便的</span>
</code></pre> 
<h4><a id="44_shell_1440"></a>4.4 shell组命令</h4> 
<p>组命令可以<mark>将多条命令的输出结果合并在一起，在使用重定向和管道时会特别方便</mark></p> 
<pre><code class="prism language-python"><span class="token punctuation">{<!-- --></span> command1<span class="token punctuation">;</span> command2<span class="token punctuation">;</span> command3<span class="token punctuation">;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>  <span class="token punctuation">}</span>

<span class="token comment"># demo </span>
<span class="token punctuation">{<!-- --></span> ls <span class="token operator">-</span>l<span class="token punctuation">;</span> echo <span class="token string">"hello world"</span><span class="token punctuation">;</span> cat readme<span class="token punctuation">.</span>txt<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">&gt;</span> out<span class="token punctuation">.</span>txt
</code></pre> 
<h4><a id="45_Shell_1449"></a>4.5 Shell管道与过滤器</h4> 
<p>将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong></p> 
<pre><code class="prism language-python"><span class="token comment"># | 称为管道符</span>
command1 <span class="token operator">|</span> command2
command1 <span class="token operator">|</span> command2 <span class="token punctuation">[</span> <span class="token operator">|</span> commandN<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span>

command1 <span class="token operator">&lt;</span> <span class="token builtin">input</span><span class="token punctuation">.</span>txt <span class="token operator">|</span> command2
command1 <span class="token operator">&lt;</span> <span class="token builtin">input</span><span class="token punctuation">.</span>txt <span class="token operator">|</span> command2 <span class="token operator">-</span>option <span class="token operator">|</span> command3 <span class="token operator">&gt;</span> output<span class="token punctuation">.</span>txt

<span class="token comment"># demo</span>
tr a<span class="token operator">-</span>z A<span class="token operator">-</span>Z <span class="token operator">&lt;</span>os<span class="token punctuation">.</span>txt <span class="token operator">|</span> sort <span class="token operator">|</span> uniq <span class="token operator">&gt;</span>os<span class="token punctuation">.</span>txt<span class="token punctuation">.</span>new
</code></pre> 
<p>将几个命令通过管道符组合在一起就形成一个管道。通常，通过这种方式使用的命令就被称为过滤器。过滤器会获取输入，通过某种方式修改其内容，然后将其输出。过滤器通常与管道连用。</p> 
<pre><code class="prism language-python"><span class="token comment"># 常见的过滤器</span>
<span class="token comment"># awk   文本处理的解释性程序设计语言，通常用于数据提取，报告生成 awk -F: '{print $1}' /etc/passwd | sort</span>
<span class="token comment"># cut 将每个输入文件（如果没有指定文件则为标准输入）的每行的指定部分输出到标准输出 grep "bin/bash" /etc/passwd | cut -d: -f1,6 </span>
<span class="token comment"># grep  用于搜索一个或多个文件中匹配指定模式的行</span>
<span class="token comment"># tar   压缩</span>
<span class="token comment"># head  读取文件的开头部分</span>
<span class="token comment"># sed   过滤和转换文本的流编辑器</span>
<span class="token comment"># sort  对文本文件排序</span>
<span class="token comment"># split  将文件分块</span>
<span class="token comment"># tail  显示末尾</span>
<span class="token comment"># tee  用于从标准输入读取内容并写入到标准输出和文</span>
<span class="token comment"># uniq  去掉重复的行</span>
<span class="token comment"># wc  用于打印文件中的总行数、单词数或字节数</span>
</code></pre> 
<h4><a id="46_Shell_1481"></a>4.6 Shell模块化</h4> 
<p>所谓模块化，就是把代码分散到多个文件或者文件夹， 达到代码复用的效果。 shell中，可以用source来引入其他脚本，类似于c中的include</p> 
<pre><code class="prism language-python">vim func<span class="token punctuation">.</span>sh

function <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    local total<span class="token operator">=</span><span class="token number">0</span>
    <span class="token keyword">for</span> n <span class="token keyword">in</span> $@
    do
         <span class="token punctuation">(</span><span class="token punctuation">(</span>total<span class="token operator">+=</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    done
    echo $total
    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

vim main<span class="token punctuation">.</span>sh

<span class="token comment">#!/bin/bash</span>
source func<span class="token punctuation">.</span>sh   <span class="token comment"># 这里引入func.sh， 这里使用的相对路径， 也可以使用绝对路径</span>
echo $<span class="token punctuation">(</span><span class="token builtin">sum</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">55</span> <span class="token number">15</span><span class="token punctuation">)</span>
</code></pre> 
<p>避免重复引入的问题， C或者C++的头文件做了避免重复引入的处理，即使多次用include引入同一个文件， 最终也引入一次， 但是shell里面没有做，如果多次用source引入同一个脚本，就会执行多次， 那么，我们如何自己做重复引入避免操作处理呢？</p> 
<pre><code class="prism language-python">vim module<span class="token punctuation">.</span>sh

<span class="token comment">#!/bin/bash</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">-</span>n <span class="token string">"$__MODULE_SH__"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then
    <span class="token keyword">return</span>              <span class="token comment"># shell中的return可以退出source命令引入的脚本， 只能退出由 source 命令引入的脚本文件，对其它引入脚本的方式无效</span>
fi
__MODULE_SH__<span class="token operator">=</span><span class="token string">'module.sh'</span>
echo <span class="token string">"hello world"</span>

vim main bash

<span class="token comment">#!/bin/bash</span>
source module<span class="token punctuation">.</span>sh   <span class="token comment"># 下面多次引入，最终也只会引入一次</span>
source module<span class="token punctuation">.</span>sh
echo <span class="token string">"here executed"</span>
</code></pre> 
<h4><a id="47_Shell_1523"></a>4.7 Shell进程、信号与捕获</h4> 
<h4><a id="471_Linux_1524"></a>4.7.1 Linux中的进程小识</h4> 
<p>进程是运行在 Linux 中的程序的一个实例。执行一个程序时， 系统会为这个程序创建特定的环境，环境里面包括程序所需的所有东西。</p> 
<p>操作系统通过被称为 PID 或进程 ID 的数字编码来追踪进程。系统中的每一个进程都有一个唯一的 PID。</p> 
<pre><code class="prism language-python">sleep <span class="token number">10</span> <span class="token operator">&amp;</span>
ps <span class="token operator">-</span>ef <span class="token operator">|</span> grep sleep   <span class="token comment"># 产看进程</span>
</code></pre> 
<p>当启动一个进程时， 有两种方式运行：</p> 
<ol><li>前台进程：默认程序运行前台， 此时不能再输入命令启动其他进程</li><li>后台进程： 后面加个<code>&amp;</code>就将命令启动到后台，此时会显示一个进程ID出来， 可以再继续运行其他命令</li></ol> 
<p>每个进程，有自己的生命周期，比如创建，执行，结束，清除等，查看指定进程的状态</p> 
<pre><code class="prism language-python">ps <span class="token operator">-</span>C processName <span class="token operator">-</span>o pid<span class="token operator">=</span><span class="token punctuation">,</span>cmd<span class="token punctuation">,</span>stat

➜  <span class="token operator">~</span> sleep <span class="token number">20</span> <span class="token operator">&amp;</span>                    
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">228282</span>
➜  <span class="token operator">~</span> ps <span class="token operator">-</span>C sleep <span class="token operator">-</span>o pid<span class="token operator">=</span><span class="token punctuation">,</span>cmd<span class="token punctuation">,</span>stat
        CMD                         STAT
 <span class="token number">228282</span> sleep <span class="token number">20</span>                    SN
</code></pre> 
<p>ps命令可以查看当前的进程。</p> 
<pre><code class="prism language-python">ps 

➜  <span class="token operator">~</span> ps                    
    PID TTY          TIME CMD
  <span class="token number">41574</span> pts<span class="token operator">/</span><span class="token number">1</span>    <span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">02</span> zsh
 <span class="token number">228360</span> pts<span class="token operator">/</span><span class="token number">1</span>    <span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> ps

<span class="token comment"># ps 命令会显示进程 ID(PID)、与进程关联的终端（TTY）、格式为“[dd-]hh:mm:ss”的进程累积 CPU 时间（TIME），以及可执行文件的名称（CMD）</span>

<span class="token comment"># 使用标准语法显示系统中的每个进程</span>
ps <span class="token operator">-</span>ef

<span class="token comment"># 使用 BSD 语法显示系统中的每个进程</span>
ps <span class="token operator">-</span>aux 

➜  <span class="token operator">~</span> ps <span class="token operator">-</span>ef <span class="token operator">|</span> head <span class="token operator">-</span><span class="token number">5</span>
UID          PID    PPID  C STIME TTY          TIME CMD
root           <span class="token number">1</span>       <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">12</span>月<span class="token number">11</span> ?      <span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">11</span> <span class="token operator">/</span>sbin<span class="token operator">/</span>init splash
root           <span class="token number">2</span>       <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">12</span>月<span class="token number">11</span> ?      <span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>
root           <span class="token number">3</span>       <span class="token number">2</span>  <span class="token number">0</span> <span class="token number">12</span>月<span class="token number">11</span> ?      <span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token punctuation">[</span>rcu_gp<span class="token punctuation">]</span>
root           <span class="token number">4</span>       <span class="token number">2</span>  <span class="token number">0</span> <span class="token number">12</span>月<span class="token number">11</span> ?      <span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token punctuation">[</span>rcu_par_gp<span class="token punctuation">]</span>
➜  <span class="token operator">~</span> ps <span class="token operator">-</span>aux <span class="token operator">|</span> head <span class="token operator">-</span><span class="token number">5</span>
USER         PID <span class="token operator">%</span>CPU <span class="token operator">%</span>MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           <span class="token number">1</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">168268</span>  <span class="token number">9040</span> ?        Ss   <span class="token number">12</span>月<span class="token number">11</span>   <span class="token number">0</span><span class="token punctuation">:</span><span class="token number">11</span> <span class="token operator">/</span>sbin<span class="token operator">/</span>init splash
root           <span class="token number">2</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S    <span class="token number">12</span>月<span class="token number">11</span>   <span class="token number">0</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>
root           <span class="token number">3</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        I<span class="token operator">&lt;</span>   <span class="token number">12</span>月<span class="token number">11</span>   <span class="token number">0</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token punctuation">[</span>rcu_gp<span class="token punctuation">]</span>
root           <span class="token number">4</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        I<span class="token operator">&lt;</span>   <span class="token number">12</span>月<span class="token number">11</span>   <span class="token number">0</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token punctuation">[</span>rcu_par_gp<span class="token punctuation">]</span>

<span class="token comment"># 查看某个命令下的进程信息</span>
ps aux <span class="token operator">|</span> grep xxx命令
</code></pre> 
<p>另外还有两个命令：pstree和pgrep， 可以查看当前运行的进程， 这个这里不多整理了，没用到过。</p> 
<h4><a id="472_shell_1588"></a>4.7.2 子shell和子进程</h4> 
<p>shell中，有很多方式可以产生子进程，比如用新进程的方式运行shell脚本(bash, ./xxx.sh)， 使用组命令，管道，命令替换等， 但有些区别。</p> 
<p>shell脚本的执行过程：上到下，左到右， 如果shell脚本中遇到子脚本或者外部命令，就会申请一个新的进程执行，这个就是子进程，子进程执行完之后， 回到父进程。</p> 
<p><img src="https://images2.imgbox.com/5a/06/nj3IQ1Jf_o.png" alt="在这里插入图片描述"></p> 
<p>子进程创建方式两种：</p> 
<ol><li><code>fork()</code>函数创建一个子进程，除了PID这种参数， 子进程的一切都来自父进程，包括代码，数据，堆栈，打开的文件等。 虽然后面可能随着环境的不同，子进程和父进程会不一样，但<code>fork()</code>出来的那一刻，两者几乎一样。 比如组替换，命令替换，管道等，子进程可以使用父进程的一切，包括全局变量、局部变量、别名， 把这种进程称为<strong>子shell</strong>。</li><li>子进程被<code>fork()</code>出来之后，立即调用了<code>exec()</code>函数加载新的可执行文件，不用父进程继承来的东西。 比如<code>bash ./test.sh</code>、<code>chmod +x ./test.sh; ./test.sh</code></li></ol> 
<p>举个例子吧：~/bin目录下面有两个执行文件a.out, b.out， 运行a.out产生进程A， 在A里面用fork()函数创建了一个进程B，B就是A的子进程。此时他们一样。这就是1。 但如果调用fork()后， 立即调用exec()加载b.out， 这时候， B进程中的代码，数据等会被销毁，根据b.out重新建立，此时B除了ID没变，其他都变了， 这就是2.</p> 
<p>为了好理解， 看一段代码吧：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> os

<span class="token keyword">def</span> <span class="token function">child_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"This is the child process, PID:"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">parent_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"This is the parent process, PID:"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    child_pid <span class="token operator">=</span> os<span class="token punctuation">.</span>fork<span class="token punctuation">(</span><span class="token punctuation">)</span>
	  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"child_pid"</span><span class="token punctuation">,</span> child_pid<span class="token punctuation">)</span>
    <span class="token keyword">if</span> child_pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token comment"># 子进程执行的代码</span>
        child_process<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token comment"># 父进程执行的代码</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Parent process continued..."</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    parent_process<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 输出</span>
This <span class="token keyword">is</span> the parent process<span class="token punctuation">,</span> PID<span class="token punctuation">:</span> <span class="token number">224917</span>
child_pid<span class="token punctuation">:</span> <span class="token number">224956</span>
Parent process continued<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
child_pid<span class="token punctuation">:</span> <span class="token number">0</span>
This <span class="token keyword">is</span> the child process<span class="token punctuation">,</span> PID<span class="token punctuation">:</span> <span class="token number">224956</span>
</code></pre> 
<p>这就是从父进程里面，新建立了一个子进程的过程，父进程根据返回的pid来判断当前是处在父进程还是子进程，这里感觉和shell不同的是， python里面建立出子进程之后， 父进程会接着运行， 运行完之后，子进程开始运行。</p> 
<h4><a id="473_Linux_1636"></a>4.7.3 Linux中的信号</h4> 
<p>信号这个概念在linux中很重要，因为信号通常通过Linux命令用在一些常见活动中，比如<code>ctrl+c，kill -9 [pid]</code>等。</p> 
<p>Linux中，信号被用于进程通信，是一个发送到某个进程或同一进程特定线程之间的异步通知，告知发生的一个事件。</p> 
<p>Bash shell中， 可以用键盘发送信号：</p> 
<ul><li>ctrl+c: 中断信号，发送 SIGINT 信号到运行在前台的进程</li><li>ctrl+y: 延时挂起信号，使运行的进程在尝试从终端读取输入时停止。控制权返回给 Shell</li><li>ctrl+z: 挂起信号，发送 SIGTSTP 信号到运行的进程，由此将其停止，并将控制权返回给 Shell</li></ul> 
<p>kill命令也可以发送信号， 比较有用的：</p> 
<pre><code class="prism language-python"><span class="token operator">-</span> SIGHUP <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>： 终止，当进程的控制终端关闭时，HUP 信号会被发送到进程
<span class="token operator">-</span> SIGINT <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>： 当用户想要中断进程时，INT 信号被进程的控制终端发送到进程
<span class="token operator">-</span> SIGKILL <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>： 发送到进程的 KILL 信号会使进程立即终止。KILL 信号不能被捕获或忽略
<span class="token operator">-</span> SIGCONT <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>： CONT 信号指不操作系统重新开始先前被 STOP 或 TSTP 暂停的进程
<span class="token operator">-</span> SIGSTOP <span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span>： STOP 信号指示操作系统停止进程的执行
</code></pre> 
<p>这里面最常用的就是杀死进程：</p> 
<pre><code class="prism language-python">kill <span class="token operator">-</span><span class="token number">9</span> xxx

<span class="token comment"># kill终结命令</span>
kill <span class="token operator">%</span><span class="token number">1</span>

</code></pre> 
<p>设计一个大且复杂的脚本时，考虑到当脚本运行时出现用户退出或系统关机会发生什么是很重要的。当这样的事件发生时，一个信号将会发送到所有受影响的进程。相应地，这些进程的程序可以采取一些措施以确保程序正常有序地终结。比如说，我们编写了一个会在执行时生成临时文件的脚本。在好的设计过程中，我们会让脚本在执行完成时删除这些临时文件。同样聪明的做法是，如果脚本接收到了指示程序将提前结束的信号，也应删除这些临时文件。</p> 
<p>trap命令可以捕获特定的信号，并进行处理：</p> 
<pre><code class="prism language-python">trap command signal <span class="token punctuation">[</span> signal <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span>

<span class="token comment"># demo</span>
<span class="token comment">#!/bin/bash</span>

<span class="token comment">#捕获退出状态0</span>
trap <span class="token string">'echo "Exit 0 signal detected..."'</span> <span class="token number">0</span>

<span class="token comment">#打印信息</span>
echo <span class="token string">"This script is used for testing trap command."</span>

<span class="token comment">#以状态（信号）0 退出此 Shell 脚本</span>
exit <span class="token number">0</span>

<span class="token comment">#!/bin/bash</span>
<span class="token comment">#捕获信号 SIGINT，然后打印相应信息</span>
trap <span class="token string">"echo 'You hit control+C! I am ignoring you.'"</span> SIGINT   <span class="token comment"># ctrl+c发的就是这个信号，这里捕获住之后，输入这样的一条提示，然后忽略</span>

<span class="token comment">#捕获信号 SIGTERM，然后打印相应信息</span>
trap <span class="token string">"echo 'You tried to kill me! I am ignoring you.'"</span> SIGTERM   

<span class="token comment">#循环5次</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">{<!-- --></span><span class="token number">1.</span><span class="token number">.5</span><span class="token punctuation">}</span><span class="token punctuation">;</span> do
    echo <span class="token string">"Iteration $i of 5"</span>
    <span class="token comment">#暂停5秒</span>
    sleep <span class="token number">5</span>
done
</code></pre> 
<p>下面整理一个在实际中会使用的demo: 写一个脚本， 接收到ctrl-c行为，执行某个函数， 删除临时文件</p> 
<pre><code class="prism language-python">
<span class="token comment">#!/bin/bash</span>

<span class="token comment">#捕获INT和QUIT信号，如果收到这两个信号，则执行函数 my_exit 后退出</span>
trap <span class="token string">'my_exit; exit'</span> SIGINT SIGQUIT

<span class="token comment">#捕获HUP信号</span>
trap <span class="token string">'echo Going down on a SIGHUP - signal 1, no exiting...; exit'</span> SIGHUP

<span class="token comment">#定义count变量</span>
count<span class="token operator">=</span><span class="token number">0</span>

<span class="token comment">#创建临时文件</span>
tmp_file<span class="token operator">=</span>`mktemp <span class="token operator">/</span>tmp<span class="token operator">/</span><span class="token builtin">file</span><span class="token punctuation">.</span>$$<span class="token punctuation">.</span>XXXXXX`

<span class="token comment">#定义函数my_exit</span>
my_exit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    echo <span class="token string">"You hit Ctrl-C/CtrI-\, now exiting..."</span>
    <span class="token comment">#清除临时文件</span>
    rm <span class="token operator">-</span>f $tmp_file <span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token operator">/</span>dev<span class="token operator">/</span>null
<span class="token punctuation">}</span>

<span class="token comment">#向临时文件写入信息</span>
echo <span class="token string">"Do someting..."</span> <span class="token operator">&gt;</span> $tmp_file

<span class="token comment">#执行无限while循环</span>
<span class="token keyword">while</span> <span class="token punctuation">:</span>
do
    <span class="token comment">#休眠1秒</span>
    sleep <span class="token number">1</span>
    <span class="token comment">#将count变量的值加1</span>
    count<span class="token operator">=</span>$<span class="token punctuation">(</span>expr $count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment">#打印count变量的值</span>
    echo $count
done
</code></pre> 
<p>下面的一个效果：</p> 
<p><img src="https://images2.imgbox.com/55/ac/uKjkdjHO_o.png" alt="在这里插入图片描述"></p> 
<p>程序里面是一个无限循环，开始执行时， 在tmp目录下面会创建一个文件，里面写入了Do something， 当执行ctrl+c终止时， 退出程序，同时删掉临时文件。</p> 
<p>Bash shell中，有两个内部变量$LINENO, $BASH_COMMAND， 可以在方便处理信号时，提供更多与脚本终结的信息。这两个命令用于报告脚本当前执行的行号以及当前运行的命令。</p> 
<pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>
<span class="token comment">#捕获SIGHUP、SIGINT和SIGQUIT信号。如果收到这些信号，将执行函数my_exit后退出</span>
trap <span class="token string">'my_exit $LINENO $BASH_COMMAND; exit'</span> SIGHUP SIGINT SIGQUIT

<span class="token comment">#函数my_exit</span>
my_exit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">#打印脚本名称，及信号被捕获时所运行的命令和行号</span>
    echo <span class="token string">"$(basename $0) caught error on line : $1 command was: $2"</span>

    <span class="token comment">#将信息记录到系统日志中</span>
    logger <span class="token operator">-</span>p notice <span class="token string">"script: $(basename $0) was terminated: line: $1, command was $2"</span>

    <span class="token comment">#其他一些清埋命令</span>
<span class="token punctuation">}</span>

<span class="token comment">#执行无限while循环</span>
<span class="token keyword">while</span> <span class="token punctuation">:</span>
do
    <span class="token comment">#休眠1秒</span>
    sleep <span class="token number">1</span>
    <span class="token comment">#将变量count的值加1</span>
    count<span class="token operator">=</span>$<span class="token punctuation">(</span>expr $count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment">#打印count变量的值</span>
    echo $count
done

<span class="token comment"># temp.py caught error on line : 1 command was: sleep</span>
</code></pre> 
<p>还可以用trap语句，忽略某些信号：</p> 
<pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>

<span class="token comment">#忽略SIGINT和SIGQUIT信号</span>
trap <span class="token string">' '</span> SIGINT SIGQUIT

<span class="token comment">#打印提示信息</span>
echo <span class="token string">"You cannot terminate using ctrl+c or ctrl+\!"</span>

<span class="token comment">#休眠10秒</span>
sleep <span class="token number">10</span>

<span class="token comment">#重新捕获SIGINT和SIGQUIT信号。如果捕获到这两个信号，则打印信息后退出</span>
<span class="token comment">#现在可以中断脚本了</span>
trap <span class="token string">'echo Terminated!; exit'</span> SIGINT SIGQUIT

<span class="token comment">#打印提示信息</span>
echo <span class="token string">"OK! You can now terminate me using those keystrokes"</span>

<span class="token comment">#休眠10秒</span>
sleep <span class="token number">10</span>
</code></pre> 
<p>这个trap感觉在处理一些异常情况时会很有用。 移除信号的捕获：</p> 
<pre><code class="prism language-python">$ trap <span class="token operator">-</span> signal <span class="token punctuation">[</span> signal <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span>  <span class="token comment"># 将接收到信号时的行为处理重置为默认模式</span>

<span class="token comment">#定义函数cleanup</span>
function cleanup <span class="token punctuation">{<!-- --></span>
    <span class="token comment">#如果变量 msgfile 所指定的文件存在</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>e $msgfile <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> then
        <span class="token comment">#将文件重命名（或移除）</span>
        mv $msgfile $msgfile<span class="token punctuation">.</span>dead
    fi

    exit
<span class="token punctuation">}</span>

<span class="token comment">#捕获INT和TERM信号</span>
trap cleanup INT TERM

<span class="token comment">#创建一个临时文件</span>
msgfile<span class="token operator">=</span>`mktemp <span class="token operator">/</span>tmp<span class="token operator">/</span>testtrap<span class="token punctuation">.</span>$$<span class="token punctuation">.</span>XXXXXX`

<span class="token comment">#通过命令行向此临时文件中写入内容</span>
cat <span class="token operator">&gt;</span> $msgfile

<span class="token comment">#接下来，发送临时文件的内容到指定的邮件地址，你自己完善此部分代码</span>
<span class="token comment">#send the contents of $msgfile to the specified mail address...</span>

<span class="token comment">#删除临时文件</span>
rm $msgfile

<span class="token comment">#移除信号INT和TERM的捕获</span>
trap <span class="token operator">-</span> INT TERM
</code></pre> 
<h3><a id="5_Shell_1843"></a>5. Shell的一些快捷操作</h3> 
<p>shell的一些常用快捷键：</p> 
<pre><code class="prism language-python"><span class="token comment"># 光标移动系列</span>
	ctrl<span class="token operator">+</span>a<span class="token punctuation">:</span> 行首
	ctrl<span class="token operator">+</span>e<span class="token punctuation">:</span> 行尾
	ctrl<span class="token operator">+</span>f<span class="token punctuation">:</span> 往前移动光标， 类似<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> ctrl<span class="token operator">+</span>b<span class="token punctuation">:</span> 后移动光标， 类似<span class="token operator">&lt;</span><span class="token operator">-</span>
	alt<span class="token operator">+</span>f<span class="token punctuation">:</span> 前移动一个单词<span class="token punctuation">,</span> alt<span class="token operator">+</span>b<span class="token punctuation">:</span> 后移动一个单词
	ctrl<span class="token operator">+</span>l<span class="token punctuation">:</span> 清空屏幕

<span class="token comment"># 剪切和粘贴文本</span>
	ctrl<span class="token operator">+</span>k<span class="token punctuation">:</span> 剪切光标位置到行尾
	ctrl<span class="token operator">+</span>u<span class="token punctuation">:</span> 剪切光标位置到行首
</code></pre> 
<p>自动补全：</p> 
<pre><code class="prism language-python">tab键

一次tab键： 自动补全
两次tag键： 看看有哪些可以补全的列表

</code></pre> 
<p>搜索历史命令：</p> 
<pre><code class="prism language-python">history <span class="token operator">|</span> less 
history <span class="token operator">|</span> grep xxx命令

ctrl<span class="token operator">+</span>r 可以对历史命令搜索， 接连ctrl<span class="token operator">+</span>r往上找
找到之后， ctrl<span class="token operator">+</span>j可以复制到当前，或者直接enter
</code></pre> 
<p>脚本的鲁棒和调试命令：</p> 
<pre><code class="prism language-python"><span class="token comment">#!/bin/bash</span>

<span class="token builtin">set</span> <span class="token operator">-</span>eux

<span class="token comment"># shell脚本的开头可以加这样一行命令， 设置脚本行为</span>

<span class="token operator">-</span>e 脚本中如何任何命令返回非零的退出状态<span class="token punctuation">(</span>失败<span class="token punctuation">)</span>， 脚本立即停止运行
<span class="token operator">-</span>u 脚本中使用了未定义的变量，将会产生错误，脚本停止执行
<span class="token operator">-</span>x 执行脚本时，会输出执行的每一行命令及其参数，有助于调试和追踪脚本的执行流程
</code></pre> 
<h3><a id="6__1892"></a>6. 小总</h3> 
<p>本篇文章有点长， 主要是以整理常用的shell脚本命令为主， 命令有点多， 整理了两遍算是有些初步印象， 对shell脚本的知识通过一个架子可以拎起来了， 后面需要不断的在实践中多写多练才能融会贯通。 在工作中， 我发现Shell还真实蛮常用的， 特别适合一些重复性的，逻辑简单的一些工作辅助，比如同步迁移数据，重复性文件读写，同步修改一些文件，写一些定时任务等， 在shell里面还可以执行py文件， 把python和shell结合起来， 我发现可以大幅提高工作效率，所以掌握一些基本的shell脚本的语法还是蛮必要的，加油 😃</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a0e83c12ba2f07a307faf4902e27827d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">词嵌入位置编码的实现（基于pytorch）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/580fedb552642b7f8c7ee353140de6e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">虚幻UE 材质-边界混合之PDO像素深度偏移量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>