<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringSecurity安全框架（配置类版） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringSecurity安全框架（配置类版）" />
<meta property="og:description" content="1. 前言 1.1 SpringSecurity 框架用法简介 用户登录系统时我们协助 SpringSecurity 把用户对应的角色、权限组装好，同时把各个 资源所要求的权限信息设定好，剩下的“登录验证”、“权限验证”等等工作都交给 SpringSecurity
1.2 权限管理过程中的相关概念 1.2.1 主体 英文单词：principal 使用系统的用户或设备或从其他系统远程登录的用户等等。简单说就是谁使用系统 谁就是主体
1.2.2 认证 英文单词：authentication 权限管理系统确认一个主体的身份，允许主体进入系统。简单说就是“主体”证明 自己是谁。 笼统的认为就是以前所做的登录操作。
1.2.3 授权 英文单词：authorization
将操作系统的“权力”“授予”“主体”，这样主体就具备了操作系统中特定功能的 能力。所以简单来说，授权就是给用户分配权限。
1.3 security的特点 Spring 技术栈的组成部分，通过提供完整可扩展的认证和授权支持保护你的应用程序。官网地址：
https://spring.io/projects/spring-security
SpringSecurity 特点：
1）和 Spring 无缝整合。
2） 全面的权限控制。 3）专门为 Web 开发而设计。 4）旧版本不能脱离 Web 环境使用。 5）新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独 引入核心模块就可以脱离 Web 环境。
6）重量级
2. 环境准备 2.1 新建工程 2.1.1 引入SpringMVC依赖 &lt;project xmlns=&#34;http://maven.apache.org/POM/4.0.0&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.bjc&lt;/groupId&gt; &lt;artifactId&gt;springsecuryti-web&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7f6221bfdb47c0c081600a9ecea4b801/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-18T15:47:35+08:00" />
<meta property="article:modified_time" content="2020-07-18T15:47:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringSecurity安全框架（配置类版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1. <span style="color:#000000;">前言</span></h2> 
<h3><span style="color:#000000;">1.1 </span><span style="color:#000000;">SpringSecurity </span><span style="color:#000000;">框架用法简介</span></h3> 
<p>        用户登录系统时我们协助 SpringSecurity 把用户对应的角色、权限组装好，同时把各个 资源所要求的权限信息设定好，剩下的“登录验证”、“权限验证”等等工作都交给 SpringSecurity</p> 
<h3>1.2 权限管理过程中的相关概念</h3> 
<h4>1.2.1 主体</h4> 
<p>        英文单词：<span style="color:#f33b45;">principal </span></p> 
<p>        使用系统的用户或设备或从其他系统远程登录的用户等等。简单说就是谁使用系统 谁就是主体</p> 
<h4>1.2.2 认证</h4> 
<p>        英文单词：<span style="color:#f33b45;">authentication </span></p> 
<p>        权限管理系统确认一个主体的身份，允许主体进入系统。简单说就是“主体”证明 自己是谁。 笼统的认为就是以前所做的登录操作。</p> 
<h4>1.2.3 授权</h4> 
<p>        英文单词：<span style="color:#f33b45;">authorization</span></p> 
<p>        将操作系统的“权力”“授予”“主体”，这样主体就具备了操作系统中特定功能的 能力。所以简单来说，授权就是给用户分配权限。</p> 
<p><img alt="" height="598" src="https://images2.imgbox.com/98/5b/f1tb1qAa_o.png" width="782"></p> 
<p> </p> 
<h3>1.3 security的特点</h3> 
<p>        Spring 技术栈的组成部分，通过提供完整可扩展的认证和授权支持保护你的应用程序。官网地址：</p> 
<p><a href="https://spring.io/projects/spring-security" rel="nofollow">https://spring.io/projects/spring-security</a></p> 
<p>SpringSecurity 特点：</p> 
<p>1）和 Spring 无缝整合。</p> 
<p>2） 全面的权限控制。 </p> 
<p>3）专门为 Web 开发而设计。 </p> 
<p>4）旧版本不能脱离 Web 环境使用。 </p> 
<p>5）新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独 引入核心模块就可以脱离 Web 环境。</p> 
<p>6）重量级</p> 
<h2>2. 环境准备</h2> 
<h3>2.1 新建工程</h3> 
<h4>2.1.1 引入SpringMVC依赖</h4> 
<pre><code class="language-html">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;groupId&gt;com.bjc&lt;/groupId&gt;
	&lt;artifactId&gt;springsecuryti-web&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;packaging&gt;war&lt;/packaging&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
			&lt;version&gt;4.3.20.RELEASE&lt;/version&gt;
		&lt;/dependency&gt; 
		&lt;!-- 引入 Servlet 容器中相关依赖 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
			&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
			&lt;version&gt;2.5&lt;/version&gt;
			&lt;scope&gt;provided&lt;/scope&gt;
		&lt;/dependency&gt; 
		&lt;!-- JSP 页面使用的依赖 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
			&lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
			&lt;version&gt;2.1.3-b06&lt;/version&gt;
			&lt;scope&gt;provided&lt;/scope&gt;
		&lt;/dependency&gt;

	&lt;/dependencies&gt;

&lt;/project&gt;</code></pre> 
<h4>2.1.2 MVC的xml配置</h4> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt;

	&lt;context:component-scan
		base-package="com.bjc.security"&gt;&lt;/context:component-scan&gt;

	&lt;bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
		&lt;property name="prefix" value="/WEB-INF/views/"&gt;&lt;/property&gt;
		&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;
	&lt;/bean&gt;

	&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;
	&lt;mvc:default-servlet-handler /&gt;

&lt;/beans&gt;
</code></pre> 
<h4>2.1.3 web.xml</h4> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	version="2.5"&gt;

	&lt;servlet&gt;
		&lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;
		&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
		&lt;init-param&gt;
			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
			&lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;
		&lt;/init-param&gt;
		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
	&lt;/servlet&gt; 
	&lt;!-- Map all requests to the DispatcherServlet for handling --&gt;
	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;
		&lt;url-pattern&gt;/&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre> 
<p>然后引入静态资源等文件。访问，如图：</p> 
<p><img alt="" height="693" src="https://images2.imgbox.com/c0/ed/LqWbnSAN_o.png" width="713"></p> 
<h3>2.2 引入security框架</h3> 
<h4>2.2.1 引入security依赖</h4> 
<pre><code class="language-html">&lt;!-- 添加security依赖 --&gt;
&lt;!-- SpringSecurity 对 Web 应用进行权限管理 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
	&lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;
	&lt;version&gt;4.2.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt; 
&lt;!-- SpringSecurity 配置 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
	&lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;
	&lt;version&gt;4.2.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt; 
&lt;!-- SpringSecurity 标签库 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
	&lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;
	&lt;version&gt;4.2.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<h4>2.2.2 web.xml中配置过滤器</h4> 
<pre><code class="language-html">&lt;filter&gt;
	&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
	&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
	&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre> 
<h4>2.2.3 security配置类</h4> 
<pre><code class="language-java">package com.bjc.security.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity  // 启动web环境下的权限控制功能
public class WebApplicationSecurityConfig extends WebSecurityConfigurerAdapter{
	
}
</code></pre> 
<p>然后启动项目，访问，如图：</p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/95/43/hVnm0dY0_o.png" width="640"></p> 
<p>发现，需要输入用户名和密码才能进入首页了，这说明security已经生效了。</p> 
<h2>3. 放行首页和静态资源</h2> 
<p>        我们只需要在配置类中重写父类的configure方法即可，例如：</p> 
<pre><code class="language-java">@Configuration
@EnableWebSecurity  // 启动web环境下的权限控制功能
public class WebApplicationSecurityConfig extends WebSecurityConfigurerAdapter{

	@Override
	protected void configure(HttpSecurity security) throws Exception {
		security
			.authorizeRequests()			// 对请求进行授权
			.antMatchers("/index.jsp")		// 针对 /index.jsp路径进行授权
			.permitAll()					// 可以无条件访问
			.antMatchers("/layui/**")		// 针对 /layui目录下的静态资源进行授权
			.permitAll()					// 设置其可以无条件访问
			.and()
			.authorizeRequests()			// 对请求进行授权
			.anyRequest()					// 任意的请求
			.authenticated()				// 都需要登录之后才能访问
			;
	}
	
}</code></pre> 
<p>再次访问系统，如图：</p> 
<p><img alt="" height="723" src="https://images2.imgbox.com/af/3d/IvQh0d4R_o.png" width="702"></p> 
<p>可以正常访问了。</p> 
<h2>4. 指定登录页面</h2> 
<h3>4.1 无权限跳转到自带的登录页</h3> 
<p>使用formLogin</p> 
<p><img alt="" height="418" src="https://images2.imgbox.com/79/eb/WPuZptDL_o.png" width="918"></p> 
<p>访问无权限的野蛮，如图： </p> 
<p><img alt="" height="312" src="https://images2.imgbox.com/a0/70/dOd4Bqwz_o.png" width="762"></p> 
<h3>4.2 无权限跳转到指定的登录页</h3> 
<h4>4.2.1 loginPage</h4> 
<p>       通过loginPage方法指定登录页面（如果没有指定会访问security自带的登录页面），其可以修改security默认的登录请求地址</p> 
<p>指定登录页前后 SpringSecurity 登录地址变化：</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td colspan="1" rowspan="4" style="width:113px;">指定前</td><td> 
    <div> 
     <span style="color:#000000;">/login GET - the login form</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#000000;">/login POST - process the credentials and if valid authenticate the user</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#000000;">/login?error GET - redirect here for failed authentication attempts</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#000000;">/login?logout GET - redirect here after successfully logging out</span> 
    </div> </td></tr><tr><td colspan="1" rowspan="4" style="width:113px;">指定后</td><td> 
    <div> 
     <span style="color:#000000;">/index.jsp GET - the login form</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#000000;">/index.jsp POST - process the credentials and if valid authenticate the user</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#000000;">/index.jsp?error GET - redirect here for failed authentication attempts</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#000000;">/index.jsp?logout GET - redirect here after successfully logging out</span> 
    </div> </td></tr></tbody></table> 
<p>例如：</p> 
<p><img alt="" height="313" src="https://images2.imgbox.com/25/d9/8nySZ3qM_o.png" width="1119"></p> 
<h4>4.2.2 loginProcessingUrl</h4> 
<p>        通过调用 loginProcessingUrl()方法指定登录地址。如果指定了loginProcessingUrl，那么其值就会覆盖loginPage方法中设置的默认值（index.jsp POST）</p> 
<p>例如：</p> 
<p><img alt="" height="538" src="https://images2.imgbox.com/40/5d/jXHG4ST8_o.png" width="1133"></p> 
<h3>4.3 设置登录用户名和密码</h3> 
<p>实现思路，如图：</p> 
<p><img alt="" height="360" src="https://images2.imgbox.com/95/21/oyJgguEV_o.png" width="1076"></p> 
<p>通过上面的分析，我们知道，我们要实现登录，我们需要form表单的用户名和密码的name属性是一个约定好的值。如果是采用默认的，就是</p> 
<pre><code>SpringSecurity 默认账号的请求参数名：username 
SpringSecurity 默认密码的请求参数名：password</code></pre> 
<p>如果需要定制的话，我们需要配置一下。</p> 
<h4>4.3.1 定制登录用户名密码</h4> 
<p>1） 我们可以在配置类中指定参数，并指定登录成功跳转的路径例如：</p> 
<p><img alt="" height="329" src="https://images2.imgbox.com/c4/d4/UhjkeMG2_o.png" width="1200"></p> 
<p>注意：loginProcessingUrl后面的permitAll可以省略不要。 </p> 
<p>2）在jsp中，指定登录用户名和密码的参数名，如图：</p> 
<p><img alt="" height="295" src="https://images2.imgbox.com/9d/21/4AAzpPNc_o.png" width="1200"></p> 
<p><img alt="" height="460" src="https://images2.imgbox.com/3c/9a/boRhXlR0_o.png" width="1200"></p> 
<p>注意：标签</p> 
<pre><code class="language-html">&lt;input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/&gt;</code></pre> 
<p>需要加上，用于跨域验证的。在配置版中有过csrf的介绍</p> 
<p>3）配置授权信息</p> 
<p>        在配置类中，重写另一个configure方法，并设置用户名和密码以及对应的角色和权限，例如：</p> 
<pre><code class="language-java">@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth
		.inMemoryAuthentication()		// 内存授权
		.withUser("tom")				// 设置账号
		.password("123456")				// 设置密码
		.roles("ADMIN")					// 设置角色
		.and()
		.withUser("marry")				// 设置另一个用户
		.password("123456")				// 密码
		.authorities("SAVE","EDIT")		// 设置权限
		;
}</code></pre> 
<p>使用账号tom/123456访问，可以成功的进入系统，如图：</p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/f0/37/GOWl95Uw_o.png" width="786"></p> 
<p>目前为止完整的配置类如下：</p> 
<pre><code class="language-java">package com.bjc.security.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity  // 启动web环境下的权限控制功能
public class WebApplicationSecurityConfig extends WebSecurityConfigurerAdapter{
	
	// 授权
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth
			.inMemoryAuthentication()		// 内存授权
			.withUser("tom")				// 设置账号
			.password("123456")				// 设置密码
			.roles("ADMIN")					// 设置角色
			.and()
			.withUser("marry")				// 设置另一个用户
			.password("123456")				// 密码
			.authorities("SAVE","EDIT")		// 设置权限
			;
	}

	// 认证
	@Override
	protected void configure(HttpSecurity security) throws Exception {
		security
			.authorizeRequests()			// 对请求进行授权
			.antMatchers("/index.jsp")		// 针对 /index.jsp路径进行授权
			.permitAll()					// 可以无条件访问
			.antMatchers("/layui/**")		// 针对 /layui目录下的静态资源进行授权
			.permitAll()					// 设置其可以无条件访问
			.and()
			.authorizeRequests()			// 对请求进行授权
			.anyRequest()					// 任意的请求
			.authenticated()				// 都需要登录之后才能访问
			.and()
			.formLogin()					// 无权限跳转到自带的登录页
			/**
			   *  关于loginPage方法的特殊说明：
			 * 	指定登录页的同时会影响到：提交表单的地址、退出登录地址、登录失败的地址
			   *        如果指定loginPage的值为/index.jsp，那么，
			 *  1）去登录页：/index.jsp  Get
			 *  2）提交登录表单：/index.jsp  POST
			 *  3）登录失败：/index.jsp?error
			 *  4）退出登录：/index.jsp?logout
			 * */
			.loginPage("/index.jsp")		// 指定登录页面（如果没有指定会访问security自带的登录页面）
			/*
			 * loginProcessingUrl的说明：
			 * 		如果指定了loginProcessingUrl，那么其值就会覆盖loginPage方法中设置的默认值（index.jsp POST）
			 * */
			.loginProcessingUrl("/do/login.html")   // 指定提交登录表单的地址
			.permitAll()							// 允许登录地址访问（可以不要）
			.usernameParameter("loginAcct")			// 指定登录账号的请求参数名
			.passwordParameter("loginPwd")			// 指定登录密码号的请求参数名
			.defaultSuccessUrl("/main.html")		// 设置登录成功去到的页面
			;
	}
	
}
</code></pre> 
<h3>4.4 退出登录</h3> 
<h4>4.4.1 禁用csrf的退出登录</h4> 
<p>        csrf是security默认开启的，我们需要禁用掉它。如果 CSRF 功能没有禁用，那么退出请求必须是 POST 方式。如果禁用了 CSRF 功能则任何请求方式都可以。所以，我们可以直接使用a标签并指定退出url即可实现退出功能了。</p> 
<p>      我们可以使用logout()方法开启注销功能，使用logoutUrl()方法来自定义注销功能的 URL 地址。</p> 
<p>1）配置</p> 
<p><img alt="" height="394" src="https://images2.imgbox.com/2f/90/de2ghxc7_o.png" width="984"></p> 
<p>2）页面</p> 
<pre><code>&lt;a id="logoutAnchor" href="${pageContext.request.contextPath }/do/logout.html"&gt;退出&lt;/a&gt;</code></pre> 
<h4>4.4.2 启用csrf功能退出登录 </h4> 
<p>        如果 CSRF 功能没有禁用，那么退出请求必须是 POST 方式。</p> 
<p>1）配置</p> 
<p><img alt="" height="247" src="https://images2.imgbox.com/8f/e2/XDOT2498_o.png" width="1022"></p> 
<p>2）form表单</p> 
<pre><code class="language-html">&lt;li class="layui-nav-item"&gt;
	&lt;form id="logoutForm" action="${pageContext.request.contextPath }/do/logout.html" method="post"&gt;
		&lt;input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/&gt;
	&lt;/form&gt;
	&lt;a id="logoutAnchor" href=""&gt;退出&lt;/a&gt;
	&lt;script type="text/javascript"&gt;
		window.onload = function() {
			// 点击a标签，提交表单
			document.getElementById("logoutAnchor").onclick = function() {
				
				document.getElementById("logoutForm").submit();
				
				// 阻止a标签的默认执行动作
				return false;
				
			};
			
		};
	&lt;/script&gt;
&lt;/li&gt;</code></pre> 
<p>同时，我们可以自定义退出登录的处理器</p> 
<p>1）addLogoutHandler()方法：添加退出处理器</p> 
<p>2）logoutSuccessHandler()方法：退出成功处理器</p> 
<h2>5. 基于角色或权限访问控制</h2> 
<p>        我们可以给特定资源指定特定的权限或者角色才能访问。例如：</p> 
<h3>5.1 指定特定的资源需要哪些角色或者权限</h3> 
<p><img alt="" height="446" src="https://images2.imgbox.com/0f/a9/RSVA9de4_o.png" width="974"></p> 
<p>注意：要先设置小范围的授权在设置大范围的，即anyRequest()放在后面，如上图。 </p> 
<h3>5.2 指定用户具备的权限或者角色</h3> 
<p><img alt="" height="376" src="https://images2.imgbox.com/4b/ee/O13I3Skx_o.png" width="1036"></p> 
<p>所以，用户ton可以访问level1目录的内容，marry可以访问level2目录下的内容</p> 
<p>如图：</p> 
<p>1）tom用户</p> 
<p>访问level1下的内容</p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/50/a5/ExCIhq8s_o.png" width="697"></p> 
<p>访问level2下的内容</p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/ae/21/aiL59Yj6_o.png" width="629"></p> 
<p>2）marry用户</p> 
<p>访问lever1目录下的内容</p> 
<p><img alt="" height="360" src="https://images2.imgbox.com/47/fa/90ggWeCd_o.png" width="757"></p> 
<p>访问level2目录下的内容</p> 
<p><img alt="" height="412" src="https://images2.imgbox.com/a1/38/szveQZGn_o.png" width="659"></p> 
<p>注意：<span style="color:#000000;">SpringSecurity </span><span style="color:#000000;">会在角色字符串前面加“</span><span style="color:#000000;">ROLE_</span><span style="color:#000000;">”前缀，查看security源码，如图：</span></p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/79/44/DC6w895c_o.png" width="1176"></p> 
<p>        之所以要强调这个事情，是因为将来从数据库查询得到的用户信息、角色信息、权 限信息需要我们自己手动组装。手动组装时需要我们自己给角色字符串前面加“ROLE_” 前缀。</p> 
<h3>5.3 自定义403页面</h3> 
<p>        当我们访问的资源没有权限的时候，security默认给我们跳转到一个403的错误页面，这个体验极度不好，所以，我们需要自定义该页面。</p> 
<h4>5.3.1 访问被拒绝之后直接跳转到页面</h4> 
<p><img alt="" height="348" src="https://images2.imgbox.com/06/ef/MVbWRTTg_o.png" width="1015"></p> 
<p>controller</p> 
<pre><code class="language-java">@RequestMapping("/to/no/auth/page.html")
public String toNoAuthPage() {
	return "no_auth";
}</code></pre> 
<p>效果：</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/b1/50/ihlftyr2_o.png" width="1068"></p> 
<h4>5.3.2 访问被拒绝后走处理器</h4> 
<p>        该方式可以带一些数据到页面，当然，上一种也可以，只是带的数据是通用的数据，该方式可以根据不同的异常携带不同的数据，我们可以通过accessDeniedHandler方法来定制。</p> 
<p>例如：</p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/40/9e/amZ5ZZnf_o.png" width="1200"></p> 
<p>访问没权限的资源，如：</p> 
<p><img alt="" height="382" src="https://images2.imgbox.com/f7/3b/v2G2BJbj_o.png" width="1007"></p> 
<h2>6. 记住我功能（不重要）</h2> 
<h3>6.1 内存版本</h3> 
<p>        <span style="color:#000000;">HttpSecurity </span><span style="color:#000000;">对象调用 </span><span style="color:#000000;">rememberMe()方法，登录表单携带名为 </span><span style="color:#000000;">remember-me </span><span style="color:#000000;">的请求参数即可。例如：</span></p> 
<p><img alt="" height="437" src="https://images2.imgbox.com/84/be/EGz7t5Z3_o.png" width="772"></p> 
<p>页面</p> 
<p><img alt="" height="200" src="https://images2.imgbox.com/17/33/X7MwUdoN_o.png" width="921"></p> 
<p>这时候，在登录页，会有一个记住我的选择框，勾选之后，发起请求，就会在浏览器写入一个名为remember-me的cookie，再次在登录的时候，就根据这个 Cookie 的 value 在服务器端找到以前登录的 User，而且这个 Cookie 被设置为存储 2 个星期。</p> 
<p>当我们关闭浏览器，再次访问的时候，就可以直接进入系统了，不需要在输入用户名和密码。</p> 
<h3>6.2 数据库版（不重要）</h3> 
<p>        为了让服务器重启也不影响记住登录状态，将用户登录状态信息存入数据库</p> 
<h4>6.2.1 引入数据库相关依赖</h4> 
<pre><code class="language-html">&lt;!-- 引入数据库相关依赖 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
	&lt;artifactId&gt;druid&lt;/artifactId&gt;
	&lt;version&gt;1.1.12&lt;/version&gt;
&lt;/dependency&gt; 
&lt;!-- mysql 驱动 --&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;mysql&lt;/groupId&gt;
	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
	&lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework&lt;/groupId&gt;
	&lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
	&lt;version&gt;4.3.20.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<h4>6.2.2 配置数据源</h4> 
<pre><code class="language-html">&lt;!-- 配置数据源 --&gt;
&lt;bean id="dataSource"
	class="com.alibaba.druid.pool.DruidDataSource"&gt;
	&lt;property name="username" value="root"&gt;&lt;/property&gt;
	&lt;property name="password" value="root"&gt;&lt;/property&gt;
	&lt;property name="url" value="jdbc:mysql://localhost:3306/security?useSSL=false"&gt;&lt;/property&gt;
	&lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;
&lt;/bean&gt; 
&lt;!-- jdbcTemplate --&gt;
&lt;bean id="jdbcTemplate"
	class="org.springframework.jdbc.core.JdbcTemplate"&gt;
	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre> 
<h4>6.2.3 创建数据库</h4> 
<pre><code class="language-sql">CREATE DATABASE `security` CHARACTER SET utf8;

CREATE TABLE persistent_logins (
  username VARCHAR (64) NOT NULL,
  series VARCHAR (64) PRIMARY KEY,
  token VARCHAR (64) NOT NULL,
  last_used TIMESTAMP NOT NULL
) ;

</code></pre> 
<h4>6.2.4 配置类</h4> 
<p>1）在 WebAppSecurityConfig 类中注入数据源</p> 
<pre><code class="language-java">@Autowired
private DataSource dataSource;</code></pre> 
<p>2）启用令牌仓库功能</p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/2c/58/LpUKlI6C_o.png" width="534"></p> 
<p>repository是JdbcTokenRepositoryImpl对象</p> 
<pre><code class="language-java">JdbcTokenRepositoryImpl repository = new JdbcTokenRepositoryImpl(); 
repository.setDataSource(dataSource);</code></pre> 
<p><img alt="" height="246" src="https://images2.imgbox.com/29/4e/8rYSDcRx_o.png" width="1001"></p> 
<p>然后，重启服务器，登录成功，查看数据库，如图：</p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/2c/08/NNDCsRSv_o.png" width="1154"></p> 
<p>数据已经正确存入数据库，再次重启服务器，访问，一样可以不用登录就可以进入系统。</p> 
<p>注意：表来自于JdbcTokenRepositoryImpl类，如图：</p> 
<p><img alt="" height="361" src="https://images2.imgbox.com/14/79/5XZSUPOn_o.png" width="1200"></p> 
<p>既然该类已经有了建表语句，为什么我们还需要手动建表了，我们看源码，如图：</p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/fb/9d/8fvszyOK_o.png" width="890"></p> 
<p>有一个init方法，可以自动创建表，但是，问题来了，该方法用protected修饰的，该类是框架提供的，我们只能继承该类，才能调用到该方法，但是，这样做比较不划算，所以，我们还不如自己创建一个表算了。</p> 
<p>完整的配置类：</p> 
<pre><code class="language-java">package com.bjc.security.config;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;

@Configuration
@EnableWebSecurity  // 启动web环境下的权限控制功能
public class WebApplicationSecurityConfig extends WebSecurityConfigurerAdapter{
	
	@Autowired
	private DataSource dataSource;
	
	// 授权  确定用户有什么权限和角色
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth
			.inMemoryAuthentication()		// 内存授权
			.withUser("tom")				// 设置账号
			.password("123456")				// 设置密码
			.roles("ADMIN","门徒")			// 设置角色
			.and()
			.withUser("marry")				// 设置另一个用户
			.password("123456")				// 密码
			.authorities("SAVE","UPDATE")	// 设置权限
			;
	}
 
	// 认证  确定资源需要什么权限和角色才能访问
	@Override
	protected void configure(HttpSecurity security) throws Exception {
		
		JdbcTokenRepositoryImpl repository = new JdbcTokenRepositoryImpl(); 
		repository.setDataSource(dataSource);
		
		security
			.authorizeRequests()			// 对请求进行授权
			.antMatchers("/index.jsp")		// 针对 /index.jsp路径进行授权
			.permitAll()					// 可以无条件访问
			.antMatchers("/layui/**")		// 针对 /layui目录下的静态资源进行授权
			.permitAll()					// 设置其可以无条件访问
			// .and()
			// .authorizeRequests()			// 对请求进行授权
			.antMatchers("/level1/**")		// 访问level1下的资源
			.hasRole("门徒")					// 需要角色是门徒的才能访问
			.antMatchers("/level2/**")		// 访问level2下的资源
			.hasAuthority("UPDATE")			// 需要用户具备UPDATE权限才能访问
			.anyRequest()					// 其他未设置的全部请求
			.authenticated()				// 都需要登录之后才能访问
			.and()
			.formLogin()					// 无权限跳转到自带的登录页
			/**
			   *  关于loginPage方法的特殊说明：
			 * 	指定登录页的同时会影响到：提交表单的地址、退出登录地址、登录失败的地址
			   *        如果指定loginPage的值为/index.jsp，那么，
			 *  1）去登录页：/index.jsp  Get
			 *  2）提交登录表单：/index.jsp  POST
			 *  3）登录失败：/index.jsp?error
			 *  4）退出登录：/index.jsp?logout
			 * */
			.loginPage("/index.jsp")		// 指定登录页面（如果没有指定会访问security自带的登录页面）
			/*
			 * loginProcessingUrl的说明：
			 * 		如果指定了loginProcessingUrl，那么其值就会覆盖loginPage方法中设置的默认值（index.jsp POST）
			 * */
			.loginProcessingUrl("/do/login.html")   // 指定提交登录表单的地址
			.permitAll()							// 允许登录地址访问（可以不要）
			.usernameParameter("loginAcct")			// 指定登录账号的请求参数名
			.passwordParameter("loginPwd")			// 指定登录密码号的请求参数名
			.defaultSuccessUrl("/main.html")		// 设置登录成功去到的页面
			.and()
			//.csrf()
			//.disable()								// 禁用csrf功能
			.logout()								// 开启退出功能
			.logoutUrl("/do/logout.html")			// 指定退出url
			.logoutSuccessUrl("/index.jsp")			// 指定退出成功之后去到的url
			.and()
			.exceptionHandling()						// 指定异常处理器
			// .accessDeniedPage("/to/no/auth/page.html")	// 访问被拒绝的时候，前往的页面
			.accessDeniedHandler(new AccessDeniedHandler() {
				@Override
				public void handle(HttpServletRequest request, HttpServletResponse response,
						AccessDeniedException accessDeniedException) throws IOException, ServletException {
					// 携带数据到页面，页面用${message}接收数据
					request.setAttribute("message", "抱歉，您没有权限访问该页面，请找管理员配置合适的权限在访问。。。");
					// 转发
					request.getRequestDispatcher("/WEB-INF/views/no_auth.jsp").forward(request, response);
				}
			})
			.and()
			.rememberMe()		// 记住我
			.tokenRepository(repository);
			;
	}
	
}
</code></pre> 
<h2>7. 数据库登录</h2> 
<p>        前面我们的登录是采用的内存登录方式，适用于系统指定用户且用户量较少的系统适用，现在我们需要查询数据库，适用数据库中的用户来进行登录。</p> 
<h3>7.1 默认实现（了解）</h3> 
<p>        SpringSecurity 的默认实现已经将 SQL 语句硬编码在了 JdbcDaoImpl 类中，所以，默认方法显得比较刻板，源码如下：</p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/bc/65/AezSI9aT_o.png" width="1200"></p> 
<p>可以知道，默认实现表结构等都是规定好的，相当不方便。这种 情况下，我们有下面三种选择</p> 
<p>1）按照 JdbcDaoImpl 类中 SQL 语句设计表结构。</p> 
<p>2）修改 JdbcDaoImpl 类的源码。</p> 
<p>3）不使用 jdbcAuthentication()。</p> 
<pre><code class="language-java">auth.jdbcAuthentication().usersByUsernameQuery("tom")</code></pre> 
<h3>7.2 自定义数据库查询方式</h3> 
<p>        自定义数据库查询方式也很简单，只需要执行auth.userDetailsService(userDetailsService);即可，其中userDetailsService需要自定义实现UserDetailsService接口的类并自动装配。</p> 
<h4>7.2.1 自定义userDetailsService</h4> 
<pre><code class="language-java">package com.bjc.security.config;

import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

import com.bjc.security.entity.Admin;

@Component
public class MyUserDetailServiceImpl implements UserDetailsService{
	@Autowired
	private JdbcTemplate jdbcTemplate;
	
	// 总目标：根据表单提交的用户名查询User对象，并装配角色、权限等信息
	// username  表单提交的用户名
	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		// 1.从数据库查询Admin对象
		String sql = "SELECT id,loginacct,userpswd,username,email FROM t_admin WHERE loginacct=?";
		
		List&lt;Admin&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Admin.class), username);
		
		Admin admin = list.get(0);
		
		// 2.给Admin设置角色权限信息
		List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();
		
		// 角色前面需要添加ROLE_  这里应该查询对应的角色表的
		authorities.add(new SimpleGrantedAuthority("ROLE_ADMIN"));
		// 权限前面不需要添加前缀
		authorities.add(new SimpleGrantedAuthority("UPDATE"));
		
		// 3.把admin对象和authorities封装到UserDetails中
		
		String userpswd = admin.getUserpswd();
		
		// User是UserDetails的实现类
		return new User(username, userpswd, authorities);
	}

}
</code></pre> 
<h4>7.2.2 设置</h4> 
<p><img alt="" height="705" src="https://images2.imgbox.com/a3/c7/OnARsLJA_o.png" width="1152"></p> 
<p>访问，使用数据库中的用户名和密码，可以成功访问。</p> 
<h2>8. 密码加密</h2> 
<p>        加密我们需要通过passwordEncoder方法指定加密算法。</p> 
<h3>8.1 普通MD5加密</h3> 
<h4>8.1.1 加密算法类</h4> 
<pre><code class="language-java">package com.bjc.security.config;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

/**
 *加密类
 *
 */
@Component
public class MyPasswordEncoder implements PasswordEncoder {

	/**
	 *   加密方法：采用MD5加密
	 */
	@Override
	public String encode(CharSequence rawPassword) {
		return generatePwd(rawPassword);
	}

	/**
	 *   校验方法
	 *   1. rawPassword ：明文
	 *   2. encodedPassword：数据库查询出来的密文
	 */
	@Override
	public boolean matches(CharSequence rawPassword, String encodedPassword) {
		return encodedPassword.equals(generatePwd(rawPassword));
	}
	
	// 加密方法
	private String generatePwd(CharSequence rawPassword) {
		String pwd = (String)rawPassword;
		try {
			// 获取MD5加密类
			MessageDigest instance = MessageDigest.getInstance("MD5");
			// 得到加密后的密码字节数组
			byte[] afterPwd = instance.digest(pwd.getBytes());
			// 转换成16位
			return new BigInteger(1,afterPwd).toString(16);
		} catch (NoSuchAlgorithmException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

}
</code></pre> 
<h4>8.1.2 配置</h4> 
<p>1）引入加密算法</p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/78/e8/pmT8octj_o.png" width="662"></p> 
<p>2）设置加密算法</p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/e0/e8/cSn84oFG_o.png" width="1032"></p> 
<h3>8.2 带盐值的加密</h3> 
<p>        SpringSecutiry中，给我们提供了一个类bCryptPasswordEncoder，我们可以很方便的对密码进行加密，其比Md5更安全，采用的是动态“盐”机制。</p> 
<p>        使用起来很简单，直接将我们自定义的那个加密类替换成bCryptPasswordEncoder即可。</p> 
<p>例如：</p> 
<p><img alt="" height="114" src="https://images2.imgbox.com/a8/9f/S9R2oLvX_o.png" width="1098"></p> 
<p>注意：我们需要将该类注入到spring容器中</p> 
<p><img alt="" height="545" src="https://images2.imgbox.com/e0/6e/BBaCGjg2_o.png" width="1071"></p> 
<p>也可以直接调用getBCryptPasswordEncoder()传参。</p> 
<p>配置类最终版</p> 
<pre><code class="language-java">package com.bjc.security.config;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;

@Configuration
@EnableWebSecurity  // 启动web环境下的权限控制功能
public class WebApplicationSecurityConfig extends WebSecurityConfigurerAdapter{
	
	@Autowired
	private DataSource dataSource;
	
	@Autowired
	private MyUserDetailServiceImpl userDetailsService;
	
	/*
	 * @Autowired private MyPasswordEncoder passwordEncoder;
	 */
	
	@Autowired
	private BCryptPasswordEncoder bCryptPasswordEncoder;
	
	@Bean
	public BCryptPasswordEncoder getBCryptPasswordEncoder() {
		return new BCryptPasswordEncoder();
	}
	
	// 授权  确定用户有什么权限和角色
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		/*auth
			.inMemoryAuthentication()		// 内存授权
			.withUser("tom")				// 设置账号
			.password("123456")				// 设置密码
			.roles("ADMIN","门徒")			// 设置角色
			.and()
			.withUser("marry")				// 设置另一个用户
			.password("123456")				// 密码
			.authorities("SAVE","UPDATE")	// 设置权限
			;*/
		
		// 装配userDetailsService
		auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder);
	}
 
	// 认证  确定资源需要什么权限和角色才能访问
	@Override
	protected void configure(HttpSecurity security) throws Exception {
		
		JdbcTokenRepositoryImpl repository = new JdbcTokenRepositoryImpl(); 
		repository.setDataSource(dataSource);
		
		security
			.authorizeRequests()			// 对请求进行授权
			.antMatchers("/index.jsp")		// 针对 /index.jsp路径进行授权
			.permitAll()					// 可以无条件访问
			.antMatchers("/layui/**")		// 针对 /layui目录下的静态资源进行授权
			.permitAll()					// 设置其可以无条件访问
			// .and()
			// .authorizeRequests()			// 对请求进行授权
			.antMatchers("/level1/**")		// 访问level1下的资源
			.hasRole("门徒")					// 需要角色是门徒的才能访问
			.antMatchers("/level2/**")		// 访问level2下的资源
			.hasAuthority("UPDATE")			// 需要用户具备UPDATE权限才能访问
			.anyRequest()					// 其他未设置的全部请求
			.authenticated()				// 都需要登录之后才能访问
			.and()
			.formLogin()					// 无权限跳转到自带的登录页
			/**
			   *  关于loginPage方法的特殊说明：
			 * 	指定登录页的同时会影响到：提交表单的地址、退出登录地址、登录失败的地址
			   *        如果指定loginPage的值为/index.jsp，那么，
			 *  1）去登录页：/index.jsp  Get
			 *  2）提交登录表单：/index.jsp  POST
			 *  3）登录失败：/index.jsp?error
			 *  4）退出登录：/index.jsp?logout
			 * */
			.loginPage("/index.jsp")		// 指定登录页面（如果没有指定会访问security自带的登录页面）
			/*
			 * loginProcessingUrl的说明：
			 * 		如果指定了loginProcessingUrl，那么其值就会覆盖loginPage方法中设置的默认值（index.jsp POST）
			 * */
			.loginProcessingUrl("/do/login.html")   // 指定提交登录表单的地址
			.permitAll()							// 允许登录地址访问（可以不要）
			.usernameParameter("loginAcct")			// 指定登录账号的请求参数名
			.passwordParameter("loginPwd")			// 指定登录密码号的请求参数名
			.defaultSuccessUrl("/main.html")		// 设置登录成功去到的页面
			.and()
			//.csrf()
			//.disable()								// 禁用csrf功能
			.logout()								// 开启退出功能
			.logoutUrl("/do/logout.html")			// 指定退出url
			.logoutSuccessUrl("/index.jsp")			// 指定退出成功之后去到的url
			.and()
			.exceptionHandling()						// 指定异常处理器
			// .accessDeniedPage("/to/no/auth/page.html")	// 访问被拒绝的时候，前往的页面
			.accessDeniedHandler(new AccessDeniedHandler() {
				@Override
				public void handle(HttpServletRequest request, HttpServletResponse response,
						AccessDeniedException accessDeniedException) throws IOException, ServletException {
					// 携带数据到页面，页面用${message}接收数据
					request.setAttribute("message", "抱歉，您没有权限访问该页面，请找管理员配置合适的权限在访问。。。");
					// 转发
					request.getRequestDispatcher("/WEB-INF/views/no_auth.jsp").forward(request, response);
				}
			})
			.and()
			.rememberMe()		// 记住我
			.tokenRepository(repository);
			;
	}
	
}
</code></pre> 
<h2>9. security标签</h2> 
<p>        我们需要在页面中显示security提供的信息，可以使用security提供的标签库来显示相应的信息，例如，显示登录用户的名称</p> 
<h3>9.1 导入标签库</h3> 
<pre><code class="language-html">&lt;%@ taglib uri="http://www.springframework.org/security/tags" prefix="security" %&gt;</code></pre> 
<h3>9.2 使用标签</h3> 
<p>       如图，security给我们提供了如下几个标签</p> 
<p><img alt="" height="261" src="https://images2.imgbox.com/65/7f/AtGmlZRe_o.png" width="559"></p> 
<p>以security:authentication为例，标签写法如下：</p> 
<pre><code class="language-html">&lt;security:authentication property="xxx"/&gt;</code></pre> 
<p>property属性为表达式，这个表达式怎么写了，我们暂时用xxx代替，看页面显示什么，启动项目，如图：</p> 
<p><img alt="" height="353" src="https://images2.imgbox.com/6e/9b/nGU8GIkG_o.png" width="1200"></p> 
<p>页面报错了，我们看最下面的错误信息，如图：</p> 
<p><img alt="" height="329" src="https://images2.imgbox.com/5a/35/Kw1qUy1c_o.png" width="1200"></p> 
<p>可以知道，该标签获取的属性是类UsernamePasswordAuthenticationToken中的属性，打开该类，如图，发现了2个get方法</p> 
<p><img alt="" height="207" src="https://images2.imgbox.com/8d/9e/RzFXkBaH_o.png" width="539"></p> 
<p>我们在页面中获取一下principal（主体），看看它是何方神圣，如图：</p> 
<p><img alt="" height="167" src="https://images2.imgbox.com/c8/27/EVe8zcWb_o.png" width="523"></p> 
<p>SecurityAdmin是我们定义的一个继承了User的类，由此可以得出一个结论：</p> 
<p><span style="color:#f33b45;"><strong>SpringSecurity处理完登录操作之后把登录成功的User对象以principal属性名存入了UsernamePasswordAuthenticationToken对象</strong></span></p> 
<p>知道了这里的主体是什么了，表达式就好写了，例如：</p> 
<p>显示用户昵称：</p> 
<pre><code>&lt;security:authentication property="principal.originalAdmin.userName"/&gt;</code></pre> 
<p>注意：这里没有使用credentials，是因为credentials是密码擦除，最后程序将其置为了null，所以页面访问会报错。</p> 
<h2>10 权限控制</h2> 
<h3>10.1 使用角色控制</h3> 
<h4>10.1.1 配置方式 </h4> 
<p>指定某个连接必须具有某个角色或者权限才能访问</p> 
<p><img alt="" height="592" src="https://images2.imgbox.com/a4/e7/IgShb7dy_o.png" width="1177"></p> 
<h4>10.1.2 注解方式</h4> 
<p>         为了方便，我们往往在控制层（Controller）使用注解来进行权限控制，值得注意的是，使用注解方式，需要在配置类中开启注解权限功能</p> 
<p><strong>1） 开启注解权限功能</strong></p> 
<p>在配置类上加上如下注解</p> 
<pre><code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></pre> 
<p>例如： </p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/81/a3/HFhFoJ35_o.png" width="1200"></p> 
<p><strong>2） 在需要控制的地方加上注解</strong></p> 
<p> 例如：我们希望访问/role/getPageInfo.json需要有部长的角色才能访问</p> 
<p>我们只需要在方法上添加如下注解</p> 
<pre><code>@PreAuthorize("hasRole('部长')")</code></pre> 
<p>例如：</p> 
<p><img alt="" height="307" src="https://images2.imgbox.com/29/a5/ArGKE5h7_o.png" width="1011"></p> 
<h3>10.2 使用权限进行权限控制</h3> 
<p>同使用角色，只是单词不同，例如：</p> 
<p>1）配置类方式</p> 
<pre><code class="language-java">.antMatchers("/admin/getByPageInfo.html")
.hasAuthority("user:get")</code></pre> 
<p>2）注解方式</p> 
<pre><code>@PreAuthorize("hasAuthority('user:get')")</code></pre> 
<p><img alt="" height="284" src="https://images2.imgbox.com/85/c5/hNs9srfz_o.png" width="1121"></p> 
<h3> 10.3 使用角色与权限进行权限控制</h3> 
<p>        在配置中，我们可以access来使用角色与权限联合权限控制</p> 
<p>例如：只有是经理角色，并具有user:get的用户才能访问</p> 
<pre><code class="language-java">.access("hasRole('经理') OR hasAuthority('user:get')")</code></pre> 
<p><img alt="" height="640" src="https://images2.imgbox.com/22/85/7dSslGgA_o.png" width="1200"></p> 
<h2>11. 其他注解</h2> 
<h3> 11.1 <span style="color:#000000;">@PostAuthorize</span></h3> 
<p>        先执行方法然后根据方法返回值判断是否具备权限</p> 
<p>例如：查询一个 Admin 对象，在@PostAuthorize 注解中和当前登录的 Admin 对象 进行比较，如果不一致，则判断为不能访问。实现“只能查自己”效果。</p> 
<p>@PostAuthorize("returnObject.data.loginAcct == principal.username")</p> 
<p>注意：使用 returnObject 获取到方法返回值，使用 principal 获取到当前登录用户的主体对 象</p> 
<h3>11.2 @PreFilter</h3> 
<p>        在方法执行前对传入的参数进行过滤。只能对集合类型的数据进行过滤。</p> 
<pre><code class="language-java">@PreFilter(value="filterObject%2==0") 
@ResponseBody 
@RequestMapping("/admin/test/pre/filter") 
public ResultEntity&lt;List&lt;Integer&gt;&gt; saveList(@RequestBody List&lt;Integer&gt; valueList) { 
	return ResultEntity.successWithData(valueList); 
}</code></pre> 
<h3>11.3 @PostFilter</h3> 
<p>        在方法执行后对方法返回值进行过滤。只能对集合类型的数据进行过滤。</p> 
<h2>12. 页面元素的权限控制</h2> 
<p>        我们可以使用标签根据用户不同的权限来显示不同的内容，当然，前提是我们需要引入标签库</p> 
<pre><code class="language-html">&lt;%@ taglib uri="http://www.springframework.org/security/tags" prefix="security" %&gt;</code></pre> 
<p>使用标签&lt;security:authorize&gt;来实现，例如：</p> 
<pre><code class="language-html">&lt;!-- 有经理角色的才能看到 --&gt;
&lt;security:authorize access="hasRole('经理')"&gt;
    &lt;div class="col-xs-6 col-sm-3 placeholder"&gt;
      &lt;img data-src="holder.js/200x200/auto/sky" class="img-responsive" alt="Generic placeholder thumbnail"&gt;
      &lt;h4&gt;Label&lt;/h4&gt;
      &lt;span class="text-muted"&gt;Something else&lt;/span&gt;
    &lt;/div&gt;
&lt;/security:authorize&gt;
&lt;!-- 有部长角色的才能看到 --&gt;
&lt;security:authorize access="hasRole('部长')"&gt;
    &lt;div class="col-xs-6 col-sm-3 placeholder"&gt;
      &lt;img data-src="holder.js/200x200/auto/vine" class="img-responsive" alt="Generic placeholder thumbnail"&gt;
      &lt;h4&gt;Label&lt;/h4&gt;
      &lt;span class="text-muted"&gt;Something else&lt;/span&gt;
    &lt;/div&gt;
&lt;/security:authorize&gt;
&lt;!-- 有user:get权限的才能看到 --&gt;
&lt;security:authorize access="hasAuthority('user:get')"&gt;
    &lt;div class="col-xs-6 col-sm-3 placeholder"&gt;
      &lt;img data-src="holder.js/200x200/auto/sky" class="img-responsive" alt="Generic placeholder thumbnail"&gt;
      &lt;h4&gt;Label&lt;/h4&gt;
      &lt;span class="text-muted"&gt;Something else&lt;/span&gt;
   &lt;/div&gt;
&lt;/security:authorize&gt;</code></pre> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0771905faa45452423668ff1561254d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VBA获取汉字拼音首字母的函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fcc3fdb70536052d8a6242ae5d938b72/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Kali Linux虚拟机破解WiFi密码的一波三折及详细操作步骤</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>