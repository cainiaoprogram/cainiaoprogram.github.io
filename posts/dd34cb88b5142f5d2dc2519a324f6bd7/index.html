<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第一篇  Python图片处理模块PIL（pillow） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第一篇  Python图片处理模块PIL（pillow）" />
<meta property="og:description" content="本篇包含：一、Image类的属性：1、Format 2、Mode 3、Size 4、Palette 5、Info
二、类的函数：1、New 2、Open 3、Blend 4、Composite 5、Eval 6、Frombuffer 7、Fromstring 8、Merge
三、Image类的方法：1、Convert 2、Copy 3、Crop 4、Draft 5、Filter 6、Fromstring 7、Getbands 8、Getbbox 9、Getcolors 10、Getdata 1 1、 Getextrema 12、Getpixel 13、Histogram 14、Load 15、Paste
一、PIL的基本概念：
PIL中所涉及的基本概念有如下几个：通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。
1、 通道
每张图片都是由一个或者多个数据通道构成。PIL允许在单张图片中合成相同维数和深度的多个通道。
以RGB图像为例，每张图片都是由三个数据通道构成，分别为R、G和B通道。而对于灰度图像，则只有一个通道。
对于一张图片的通道数量和名称，可以通过方法getbands()来获取。方法getbands()是Image模块的方法，它会返回一个字符串元组（tuple）。该元组将包括每一个通道的名称。
Python的元组与列表类似，不同之处在于元组的元素不能修改,元组使用小括号，列表使用方括号，元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。
方法getbands()的使用如下：
from PIL import Image
im = Image.open(&#34;xiao.png&#34;)
print(im.getbands())
输出：
(&#39;R&#39;, &#39;G&#39;, &#39;B&#39;) 2、 模式
图像的模式定义了图像的类型和像素的位宽。当前支持如下模式：
1：1位像素，表示黑和白，但是存储的时候每个像素存储为8bit。 L：8位像素，表示黑和白。 P：8位像素，使用调色板映射到其他模式。 RGB：3x8位像素，为真彩色。 RGBA：4x8位像素，有透明通道的真彩色。 CMYK：4x8位像素，颜色分离。 YCbCr：3x8位像素，彩色视频格式。 I：32位整型像素。 F：32位浮点型像素。 PIL也支持一些特殊的模式，包括RGBX（有padding的真彩色）和RGBa（有自左乘alpha的真彩色）。 可以通过mode属性读取图像的模式。其返回值是包括上述模式的字符串。
属性mode的使用如下：
from PIL import Image im = Image." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dd34cb88b5142f5d2dc2519a324f6bd7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-07-07T09:30:00+08:00" />
<meta property="article:modified_time" content="2017-07-07T09:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第一篇  Python图片处理模块PIL（pillow）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><span style="font-size:14px;"><strong>本篇包含：一、Image类的属性：1、Format   2、Mode   3、Size    4、Palette    5、Info</strong></span></p> 
 <p><span style="font-size:14px;"><strong>                  二、类的函数：1、New   2、Open   3、Blend   4、Composite   5、Eval   6、Frombuffer   7、Fromstring   8、Merge</strong></span></p> 
 <p><span style="font-size:14px;"><strong>                  三、Image类的方法：1、Convert   2、Copy   3、Crop   4、Draft   5、Filter   6、Fromstring   7、Getbands   8、Getbbox   9、Getcolors </strong></span></p> 
 <p><span style="font-size:14px;"><strong>                                                     10、Getdata     </strong></span><strong>1 1、 Getextrema    12、Getpixel    </strong><strong>13、Histogram    14、Load    15、Paste</strong></p> 
 <p><strong><span style="font-size:14pt;">一、PIL的基本概念：</span></strong></p> 
 <p>PIL中所涉及的基本概念有如下几个：通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。</p> 
 <p><strong>1、  通道</strong></p> 
 <p>每张图片都是由一个或者多个数据通道构成。PIL允许在单张图片中合成相同维数和深度的多个通道。</p> 
 <p>以RGB图像为例，每张图片都是由三个数据通道构成，分别为R、G和B通道。而对于灰度图像，则只有一个通道。</p> 
 <p>对于一张图片的通道数量和名称，可以通过方法getbands()来获取。方法getbands()是Image模块的方法，它会返回一个字符串元组（tuple）。该元组将包括每一个通道的名称。</p> 
 <p>Python的元组与列表类似，不同之处在于元组的元素不能修改,元组使用小括号，列表使用方括号，元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p> 
 <p>方法getbands()的使用如下：</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span> Image<br>im = Image.open("xiao.png")<br>print(im.getbands())<br>输出：<br>('R', 'G', 'B')</pre> 
 </div> 
 <p><strong>2、  模式</strong></p> 
 <p>图像的模式定义了图像的类型和像素的位宽。当前支持如下模式：</p> 
 <div class="cnblogs_code"> 
  <pre>1<span style="color:#000000;">：1位像素，表示黑和白，但是存储的时候每个像素存储为8bit。
L：8位像素，表示黑和白。
P：8位像素，使用调色板映射到其他模式。
RGB：3x8位像素，为真彩色。
RGBA：4x8位像素，有透明通道的真彩色。
CMYK：4x8位像素，颜色分离。
YCbCr：3x8位像素，彩色视频格式。
I：32位整型像素。
F：32位浮点型像素。
PIL也支持一些特殊的模式，包括RGBX（有padding的真彩色）和RGBa（有自左乘alpha的真彩色）。</span></pre> 
 </div> 
 <p>可以通过mode属性读取图像的模式。其返回值是包括上述模式的字符串。</p> 
 <p>属性mode的使用如下：</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">xiao.png</span><span style="color:#800000;">"</span><span style="color:#000000;">)
print(im.mode)
输出：
'RGB'</span></pre> 
 </div> 
 <p><strong>3、  尺寸</strong></p> 
 <p>通过size属性可以获取图片的尺寸。这是一个二元组，包含水平和垂直方向上的像素数。</p> 
 <p>属性mode的使用如下：</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">xiao.png</span><span style="color:#800000;">"</span><span style="color:#000000;">)
print(im.size)
输出:<br>(670, 502)<br></span></pre> 
 </div> 
 <p><strong>4、  坐标系统</strong></p> 
 <p>PIL使用笛卡尔像素坐标系统，坐标(0，0)位于左上角。注意：坐标值表示像素的角；位于坐标（0，0）处的像素的中心实际上位于（0.5，0.5）。</p> 
 <p>坐标经常用于二元组（x，y）。长方形则表示为四元组，前面是左上角坐标。例如，一个覆盖800x600的像素图像的长方形表示为（0，0，800，600）。</p> 
 <p><strong>5、  调色板</strong></p> 
 <p>调色板模式 ("P")使用一个颜色调色板为每个像素定义具体的颜色值</p> 
 <p><strong>6、  信息</strong></p> 
 <p>使用info属性可以为一张图片添加一些辅助信息。这个是字典对象。加载和保存图像文件时，多少信息需要处理取决于文件格式。</p> 
 <p>属性info的使用如下：</p> 
 <div class="cnblogs_code"> 
  <pre>from PIL import Image
im = Image.open("xiao.png")
print(im.info)<br>输出：<br>{}</pre> 
 </div> 
 <p><strong>7、  滤波器</strong></p> 
 <p>对于将多个输入像素映射为一个输出像素的几何操作，PIL提供了4个不同的采样滤波器：</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">NEAREST：最近滤波。从输入图像中选取最近的像素作为输出像素。它忽略了所有其他的像素。
BILINEAR：双线性滤波。在输入图像的2x2矩阵上进行线性插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。
BICUBIC：双立方滤波。在输入图像的4x4矩阵上进行立方插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。
ANTIALIAS：平滑滤波。这是PIL </span>1.1<span style="color:#000000;">.3版本中新的滤波器。对所有可以影响输出像素的输入像素进行高质量的重采样滤波，以计算输出像素值。在当前的PIL版本中，这个滤波器只用于改变尺寸和缩略图方法。
注意：在当前的PIL版本中，ANTIALIAS滤波器是下采样（例如，将一个大的图像转换为小图）时唯一正确的滤波器。BILIEAR和BICUBIC滤波器使用固定的输入模板，用于固定比例的几何变换和上采样是最好的。</span></pre> 
 </div> 
 <p>Image模块中的方法resize()和thumbnail()用到了滤波器。</p> 
 <p>方法resize()的使用如下：</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">方法resize()的定义为：resize(size, filter=None)=&gt; image<br>from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">xiao.png</span><span style="color:#800000;">"</span><span style="color:#000000;">)
print(im.size)<br>im_resize = im.resize((256,256))<br>print(im_resize.size)<br>输出：<br>(670, 502)<br></span>(256,256)</pre> 
 </div> 
 <p>对参数filter不赋值的话，方法resize()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现：</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">xiao.png</span><span style="color:#800000;">"</span><span style="color:#000000;">)
print(im.size)
</span>im_resize0 = im.resize((256,256<span style="color:#000000;">), Image.BILINEAR)
</span><span style="color:#000000;">print(im_resize0.size)<br></span>im_resize1 = im.resize((256,256<span style="color:#000000;">), Image.BICUBIC)
</span><span style="color:#000000;">print(im_resize1.size)<br></span>im_resize2 = im.resize((256,256<span style="color:#000000;">), Image.ANTIALIAS)
</span><span style="color:#000000;">print(im_resize2.size)
输出：<br></span>(670, 502)<br><em>(256,256)<br></em>(256,256)<br>(256,256)</pre> 
 </div> 
 <p><span style="font-size:14pt;"><strong> 二、Image模块：</strong></span></p> 
 <p>Image模块是PIL中最重要的模块，它有一个类叫做image，与模块名称相同。Image类有很多函数、方法及属性，接下来将依次对image类的属性、函数和方法进行介绍。</p> 
 <p><span style="font-size:15px;"><strong>一、Image类的属性</strong></span></p> 
 <p>1、  Format</p> 
 <div class="cnblogs_code"> 
  <pre>定义：im.format ⇒ string <span style="color:#0000ff;">or</span><span style="color:#000000;"> None
含义：源文件的文件格式。如果是由PIL创建的图像，则其文件格式为None。
例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
</span>im= Image.open(<span style="color:#800000;">"xiao.png</span><span style="color:#800000;">"</span><span style="color:#000000;">)
</span><span style="color:#000000;">print(im.format)
输出：
</span><span style="color:#800000;">'png</span><span style="color:#800000;">'</span></pre> 
 </div> 
 <p>2、  Mode</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：im.mode ⇒ string
含义：图像的模式。这个字符串表明图像所使用像素格式。该属性典型的取值为“</span>1”，“L”，“RGB”或“CMYK”。</pre> 
 </div> 
 <p>3、  Size</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：im.size ⇒ (width, height)
含义：图像的尺寸，按照像素数计算。它的返回值为宽度和高度的二元组（width, height）。</span></pre> 
 </div> 
 <p>4、  Palette</p> 
 <div class="cnblogs_code"> 
  <pre>定义：im.palette ⇒ palette <span style="color:#0000ff;">or</span><span style="color:#000000;"> None
含义：颜色调色板表格。如果图像的模式是“P”，则返回ImagePalette类的实例；否则，将为None。
例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(im.mode)
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(im.palette)
输出： 
RGB
None</span></pre> 
 </div> 
 <p> 5、  Info</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：im.info ⇒ dictionary
含义：存储图像相关数据的字典。文件句柄使用该字典传递从文件中读取的各种非图像信息。大多数方法在返回新的图像时都会忽略这个字典；因为字典中的键并非标准化的，对于一个方法，它不能知道自己的操作如何影响这个字典。<br>     如果用户需要这些信息，需要在方法open()返回时保存这个字典。</span></pre> 
 </div> 
 <p><span style="font-size:15px;"><strong> 二、类的函数：</strong></span></p> 
 <p>1、  New</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：Image.new(mode,size) ⇒ image
     Image.new(mode, size, color) ⇒ image
含义：使用给定的变量mode和size生成新的图像。Size是给定的宽</span>/高二元组，这是按照像素数来计算的。对于单通道图像，变量color只给定一个值；对于多通道图像，变量color给定一个元组（每个通道对应一个值）。<br>     在版本1.1<span style="color:#000000;">.4及其之后，用户也可以用颜色的名称，比如给变量color赋值为“red”。如果没有对变量color赋值，图像内容将会被全部赋值为0（图像即为黑色）。如果变量color是空，图像将不会被初始化，即图像的内容全为0。<br>     这对向该图像复制或绘制某些内容是有用的。
例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
</span>im= Image.new(<span style="color:#800000;">"</span><span style="color:#800000;">RGB</span><span style="color:#800000;">"</span>, (128, 128), <span style="color:#800000;">"</span><span style="color:#800000;">#FF0000</span><span style="color:#800000;">"</span><span style="color:#000000;">)
im.save("test1.png")   </span><span style="color:#000000;">#图像im为128x128大小的红色图像。
</span>im= Image.new(<span style="color:#800000;">"</span><span style="color:#800000;">RGB</span><span style="color:#800000;">"</span>, (128, 128<span style="color:#000000;">))   #</span><span style="color:#000000;">图像im为128x128大小的黑色图像，因为变量color不赋值的话，图像内容被设置为0，即黑色。
im.save("test2.png")<br></span>im= Image.new(<span style="color:#800000;">"</span><span style="color:#800000;">RGB</span><span style="color:#800000;">"</span>, (128, 128), <span style="color:#800000;">"</span><span style="color:#800000;">red</span><span style="color:#800000;">"</span><span style="color:#000000;">)   #</span><span style="color:#000000;">图像im为128x128大小的红色图像。<br>im.save("test3.png")</span></pre> 
 </div> 
 <p>2、  Open</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：Image.open(file) ⇒ image
     Image.open(file, mode) ⇒ image
含义：打开并确认给定的图像文件。这个是一个懒操作；该函数只会读文件头，而真实的图像数据直到试图处理该数据才会从文件读取（调用load()方法将强行加载图像数据）。如果变量mode被设置，那必须是“r”。
     用户可以使用一个字符串（表示文件名称的字符串）或者文件对象作为变量file的值。文件对象必须实现read()，seek()和tell()方法，并且以二进制模式打开。
例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
</span>im = Image.open(<span style="color:#800000;">"xiao.png</span><span style="color:#800000;">"</span><span style="color:#000000;">)</span></pre> 
 </div> 
 <p>3、  Blend</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：Image.blend(image1,image2, alpha) ⇒ image
含义：使用给定的两张图像及透明度变量alpha，插值出一张新的图像。这两张图像必须有一样的尺寸和模式。
     合成公式为：out </span>= image1 *(1.0 - alpha) + image2 *<span style="color:#000000;"> alpha
     如果变量alpha为0.0，将返回第一张图像的拷贝。如果变量alpha为1.0，将返回第二张图像的拷贝。对变量alpha的值没有限制。

例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
im2 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">wu.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
im </span>= Image.blend(im1,im2,0.5<span style="color:#000000;">)
im.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span>)</pre> 
 </div> 
 <p>4、  Composite</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：Image.composite(image1,image2, mask) ⇒ image
含义：使用给定的两张图像及mask图像作为透明度，插值出一张新的图像。变量mask图像的模式可以为“</span>1<span style="color:#000000;">”，“L”或者“RGBA”。所有图像必须有相同的尺寸。
例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
im2 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">wu.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
r,g,b </span>=<span style="color:#000000;"> im1.split()
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(g.mode)
im </span>=<span style="color:#000000;"> Image.composite(im1,im2,b)
im.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
b.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he1.jpg</span><span style="color:#800000;">"</span>)</pre> 
 </div> 
 <p>5、  Eval</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：Image.eval(image,function) ⇒ image
含义：使用变量function对应的函数（该函数应该有一个参数）处理变量image所代表图像中的每一个像素点。如果变量image所代表图像有多个通道，那变量function对应的函数作用于每一个通道。
     注意：变量function对每个像素只处理一次，所以不能使用随机组件和其他生成器。
例子：

</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">def</span><span style="color:#000000;"> deffun(c):
    </span><span style="color:#0000ff;">return</span> c*0.89      #改变了亮度<span style="color:#000000;">
im_eval </span>=<span style="color:#000000;"> Image.eval(im,deffun)  
im_eval.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">gai.jpg</span><span style="color:#800000;">"</span>)<br><br>注：图像im_eval与im01比较，其像素值均为im01的一半，则其亮度自然也会比im01暗一些。</pre> 
 </div> 
 <p>6、  Frombuffer</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：Image.frombuffer(mode,size, data) ⇒ image
     Image.frombuffer(mode, size,data, decoder, parameters) ⇒ image
含义：（New </span><span style="color:#0000ff;">in</span> PIL 1.1.4<span style="color:#000000;">）使用标准的“raw”解码器，从字符串或者buffer对象中的像素数据产生一个图像存储。对于一些模式，这个图像存储与原始的buffer（这意味着对原始buffer对象的改变体现在图像本身）共享内存。<br>      并非所有的模式都可以共享内存；支持的模式有“L”，“RGBX”，“RGBA”和“CMYK”。对于其他模式，这个函数与fromstring()函数一致。
注意：版本1.</span>1<span style="color:#000000;">.6及其以下，这个函数的默认情况与函数fromstring()不同。这有可能在将来的版本中改变，所以为了最大的可移植性，当使用“raw”解码器时，推荐用户写出所有的参数，如下所示：
im </span>=Image.frombuffer(mode, size, data, <span style="color:#800000;">"</span><span style="color:#800000;">raw</span><span style="color:#800000;">"</span>, mode, 0, 1<span style="color:#000000;">)
函数Image.frombuffer(mode,size, data, decoder, parameters)与函数fromstring()的调用一致。
</span></pre> 
 </div> 
 <p>7、  Fromstring</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：Image.fromstring(mode,size, data) ⇒ image
     Image.fromstring(mode, size,data, decoder, parameters) ⇒ image
含义：函数Image.fromstring(mode,size, data)，使用标准的“raw”解码器，从字符串中的像素数据产生一个图像存储。
函数Image.fromstring(mode,size, data, decoder, parameters)也一样，但是允许用户使用PIL支持的任何像素解码器。更多信息可以参考：Writing YourOwn File Decoder.
注意：这个函数只对像素数据进行解码，而不是整个图像。如果用户的字符串包含整个图像，可以将该字符串包裹在StringIO对象中，使用函数open()来加载。</span></pre> 
 </div> 
 <p>8、  Merge</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：Image.merge(mode,bands) ⇒ image
含义：使用一些单通道图像，创建一个新的图像。变量bands为一个图像的元组或者列表，每个通道的模式由变量mode描述。所有通道必须有相同的尺寸。
变量mode与变量bands的关系：
len(ImageMode.getmode(mode).bands)</span>=<span style="color:#000000;"> len(bands)
例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
im2 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">wu.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
r1,g1,b1 </span>=<span style="color:#000000;"> im1.split()
r2,g2,b2 </span>=<span style="color:#000000;"> im2.split()
imgs </span>=<span style="color:#000000;">[r1,g2,b2]
im_merge </span>= Image.merge(<span style="color:#800000;">"</span><span style="color:#800000;">RGB</span><span style="color:#800000;">"</span><span style="color:#000000;">,imgs)
im_merge.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span>)</pre> 
 </div> 
 <p><strong><span style="font-size:15px;">三、Image类的方法</span></strong></p> 
 <p>除非另作说明，Image类的所有方法都将返回一个Image类的新实例，这个实例对应于结果图像。</p> 
 <p>1、  Convert</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义1：im.convert(mode)⇒ image
含义1：将当前图像转换为其他模式，并且返回新的图像。
当从一个调色板图像转换时，这个方法通过这个调色板来转换像素。如果不对变量mode赋值，该方法将会选择一种模式，在没有调色板的情况下，使得图像和调色板中的所有信息都可以被表示出来。
当从一个颜色图像转换为黑白图像时，PIL库使用ITU</span>-R601-2<span style="color:#000000;"> luma转换公式：
L </span>= R * 299/1000 + G * 587/1000 + B * 114/1000<span style="color:#000000;">
当转换为2位图像（模式“</span>1<span style="color:#000000;">”）时，源图像首先被转换为黑白图像。结果数据中大于127的值被设置为白色，其他的设置为黑色；这样图像会出现抖动。如果要使用其他阈值，更改阈值127，可以使用方法point()。<br>为了去掉图像抖动现象，可以使用dither选项。<br>　
例子1：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(im1.mode)
im_c </span>= im1.convert(<span style="color:#800000;">"</span><span style="color:#800000;">1</span><span style="color:#800000;">"</span><span style="color:#000000;">)
im_c.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(im_c.mode)
输出：<br>1
注：将“RGB”模式的im01图像，转换为“</span>1<span style="color:#000000;">”模式的im_c图像。

定义2：im.convert(“P”,</span>**<span style="color:#000000;">options) ⇒ image
含义2：这个与第一个方法定义一样，但是当“RGB”图像转换为8位调色板图像时能更好的处理。可供选择的选项为：
      Dither</span>=<span style="color:#000000;">. 控制颜色抖动。默认是FLOYDSTEINBERG，与邻近的像素一起承担错误。不使能该功能，则赋值为NONE。
      Palette</span>=<span style="color:#000000;">. 控制调色板的产生。默认是WEB，这是标准的216色的“web palette”。要使用优化的调色板，则赋值为ADAPTIVE。
      Colors</span>=<span style="color:#000000;">. 当选项palette为ADAPTIVE时，控制用于调色板的颜色数目。默认是最大值，即256种颜色。
 
定义3：im.convert(mode,matrix) ⇒ image
含义3：使用转换矩阵将一个“RGB”图像转换为“L”或者“RGB”图像。变量matrix为4或者16元组。
例子3：下面的例子将一个RGB图像（根据ITU</span>-<span style="color:#000000;">R709线性校准，使用D65亮度）转换到CIE XYZ颜色空间：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
im1.mode
rgb2xyz </span>=<span style="color:#000000;"> （
    </span>0.412453, 0.357580, 0.180423<span style="color:#000000;">, 0,
    </span>0.212671, 0.715160, 0.072169<span style="color:#000000;">, 0,
    </span>0.019334, 0.119193, 0.950227<span style="color:#000000;">, 0 )
im_c3 </span>= im1.convert(<span style="color:#800000;">"</span><span style="color:#800000;">L</span><span style="color:#800000;">"</span><span style="color:#000000;">, rgb2xyz)
im_c3.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">print</span>(im_c3.mode)<br>输出：<br>L</pre> 
 </div> 
 <p>2、  Copy</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：im.copy() ⇒ image
含义：拷贝这个图像。如果用户想粘贴一些数据到这张图，可以使用这个方法，但是原始图像不会受到影响。

例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
im2 </span>=<span style="color:#000000;"> im1.copy()
im2.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
注：图像im_copy和im01完全一样。</span></pre> 
 </div> 
 <p>3、  Crop</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：im.crop(box) ⇒ image
含义：从当前的图像中返回一个矩形区域的拷贝。变量box是一个四元组，定义了左、上、右和下的像素坐标。
这是一个懒操作。对源图像的改变可能或者可能不体现在裁减下来的图像中。为了获取一个分离的拷贝，对裁剪的拷贝调用方法load()。

例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(im1.size)
box </span>= [0,0,650,400]   <span style="color:#008000;">#</span><span style="color:#008000;">650(长)400（高）</span>
im_crop =<span style="color:#000000;"> im1.crop(box)
im_crop.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span>)</pre> 
 </div> 
 <p>4、  Draft</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：im.draft(mode,size)
含义：配置图像文件加载器，使得返回一个与给定的模式和尺寸尽可能匹配的图像的版本。例如，用户可以使用这个方法，在加载一个彩色JPEG图像时将其转换为灰色图像，或者从一个PCD文件中提取一个128x192的版本。
注意：这个方法会适时地修改图像对象（精确地说，它会重新配置文件的读取器）。如果图像已经被加载，那这个方法就没有作用了。

例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
im_draft </span>= im1.draft(<span style="color:#800000;">"</span><span style="color:#800000;">L</span><span style="color:#800000;">"</span>,(500,500<span style="color:#000000;">))
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(im_draft.size)
im_draft.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
输出：
(</span>650, 650)</pre> 
 </div> 
 <p>5、 Filter</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：im.filter(filter) ⇒ image
含义：返回一个使用给定滤波器处理过的图像的拷贝。可用滤波器需要参考ImageFilter模块。

例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image,ImageFilter
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
im_filter </span>=<span style="color:#000000;"> im1.filter(ImageFilter.BLUR)
im_filter.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
注：图像im_filter比im01变得有些模糊了。</span></pre> 
 </div> 
 <p>6、 Fromstring</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：im.fromstring(data)
     im.fromstring(data, decoder,parameters)
含义：与函数fromstring()一样，但是这个方法会将data加载到当前的图像中。</span> </pre> 
 </div> 
 <p>7、 Getbands</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：im.getbands()⇒ tuple of strings
含义：返回包括每个通道名称的元组。例如，对于RGB图像将返回（“R”，“G”，“B”）。</span></pre> 
 </div> 
 <p>8、 Getbbox</p> 
 <div class="cnblogs_code"> 
  <pre>定义：im.getbbox() ⇒ 4-tuple <span style="color:#0000ff;">or</span><span style="color:#000000;"> None
含义：计算图像非零区域的包围盒。这个包围盒是一个4元组，定义了左、上、右和下像素坐标。如果图像是空的，这个方法将返回空。

例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(im1.getbbox())
输出：
(0, 0, </span>650, 650)</pre> 
 </div> 
 <p>9、  Getcolors</p> 
 <div class="cnblogs_code"> 
  <pre>定义：im.getcolors() ⇒ a list of(count, color) tuples <span style="color:#0000ff;">or</span><span style="color:#000000;"> None
     im.getcolors(maxcolors) ⇒ a list of (count, color) tuples </span><span style="color:#0000ff;">or</span><span style="color:#000000;"> None
含义：（New </span><span style="color:#0000ff;">in</span> 1.1.5<span style="color:#000000;">）返回一个（count，color）元组的无序list，其中count是对应颜色在图像中出现的次数。
如果变量maxcolors的值被超过，该方法将停止计算并返回空。变量maxcolors默认值为256。为了保证用户可以获取图像中的所有颜色，you can </span><span style="color:#0000ff;">pass</span> <span style="color:#0000ff;">in</span> size[0]*size[1<span style="color:#000000;">]（请确保有足够的内存做这件事）。

例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">test.png</span><span style="color:#800000;">"</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">print</span>(im1.getcolors(8888888))<br>输出：<br>[(2, (255, 255, 255, 233)), (9, (0, 0, 0, 136)), (1, (0, 0, 0, 64)), (2, (0, 0, 0, 24)), (5, (0, 0, 0, 56)).......</pre> 
 </div> 
 <p>10、 Getdata</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：im.getdata() ⇒ sequence
含义：以包含像素值的sequence对象形式返回图像的内容。这个sequence对象是扁平的，以便第一行的值直接跟在第零行的值后面，等等。
注意：这个方法返回的sequence对象是PIL内部数据类型，它只支持某些sequence操作，包括迭代和基础sequence访问。使用list(im.getdata())，将它转换为普通的sequence。

例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
seq </span>=<span style="color:#000000;"> im1.getdata()
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(seq[0])
seq0 </span>=<span style="color:#000000;"> list(seq)
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(seq0[0])
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(len(seq0))
输出：
(</span>41, 183, 197<span style="color:#000000;">)
(</span>41, 183, 197<span style="color:#000000;">)
</span>422500        <span style="color:#008000;">#</span><span style="color:#008000;">这个值是长和高之积</span>
<span style="color:#000000;">
注：Sequence对象的每一个元素对应一个像素点的R、G和B三个值。</span></pre> 
 </div> 
 <p>11、   Getextrema</p> 
 <div class="cnblogs_code"> 
  <pre>定义：im.getextrema() ⇒ 2-<span style="color:#000000;">tuple
含义：返回一个2元组，包括该图像中的最小和最大值。

例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(im1.getextrema())
输出:
((0, </span>255), (0,255), (0, 255<span style="color:#000000;">)) 
该方法返回了R</span>/G/B三个通道的最小和最大值的2元组。</pre> 
 </div> 
 <p>12、    Getpixel</p> 
 <div class="cnblogs_code"> 
  <pre>定义：im.getpixel(xy) ⇒ value <span style="color:#0000ff;">or</span><span style="color:#000000;"> tuple
含义：返回给定位置的像素值。如果图像为多通道，则返回一个元组。
注意：该方法执行比较慢；如果用户需要使用python处理图像中较大部分数据，可以使用像素访问对象（见load），或者方法getdata()。

例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">print</span>(im1.getpixel((1,1<span style="color:#000000;">)))
</span><span style="color:#0000ff;">print</span>(im1.getpixel((649,649<span style="color:#000000;">)))
输出：
(</span>41, 183, 197<span style="color:#000000;">)
(</span>236, 210, 153)<br><em id="__mceDel">注：im.getpixel(xy)中的X,Y表示坐标，从0开始。</em></pre> 
 </div> 
 <p>13、     Histogram</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义1：im.histogram()⇒ list
含义1：返回一个图像的直方图。这个直方图是关于像素数量的list，图像中的每个象素值对应一个成员。如果图像有多个通道，所有通道的直方图会连接起来（例如，“RGB”图像的直方图有768个值）。
      二值图像（模式为“</span>1<span style="color:#000000;">”）当作灰度图像（模式为“L”）处理。

例子1：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
ls </span>=<span style="color:#000000;"> im1.histogram()
</span><span style="color:#0000ff;">print</span><span style="color:#000000;">(len(ls))
</span><span style="color:#0000ff;">print</span>(ls[767<span style="color:#000000;">])
输出：
</span>768
1471</pre> 
 </div> 
 <p>14、      Load</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义：im.load()
含义：为图像分配内存并从文件中加载它（或者从源图像，对于懒操作）。正常情况下，用户不需要调用这个方法，因为在第一次访问图像时，Image类会自动地加载打开的图像。

     （New </span><span style="color:#0000ff;">in</span> 1.1.6）在1.1<span style="color:#000000;">.6及以后的版本，方法load()返回一个用于读取和修改像素的像素访问对象。这个访问对象像一个二维队列，如：
      pix </span>=<span style="color:#000000;"> im.load()
      </span><span style="color:#0000ff;">print</span><span style="color:#000000;"> pix[x, y]
      pix[x, y] </span>=<span style="color:#000000;">value
      通过这个对象访问比方法getpixel()和putpixel()快很多。

例子：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
lm_load </span>=<span style="color:#000000;"> im1.load()
</span><span style="color:#0000ff;">print</span>(lm_load[649,649<span style="color:#000000;">])
输出：
(</span>236, 210, 153)</pre> 
 </div> 
 <p>15、  Paste</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">定义1：im.paste(image,box)
含义1：将一张图粘贴到另一张图像上。变量box或者是一个给定左上角的2元组，或者是定义了左，上，右和下像素坐标的4元组，或者为空（与（0，0）一样）。如果给定4元组，被粘贴的图像的尺寸必须与区域尺寸一样。
如果模式不匹配，被粘贴的图像将被转换为当前图像的模式。

例子1：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
box </span>= [0,0,200,200<span style="color:#000000;">]
im_crop </span>=<span style="color:#000000;"> im1.crop(box)
im1.paste(im_crop,(</span>200,200,400,400))  <span style="color:#008000;">#</span><span style="color:#008000;">等价于im1.paste(im_crop,(200,200))</span>
im1.save(<span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)

定义2：im.paste(colour,box)
含义2：它与定义1一样，但是它使用同一种颜色填充变量box对应的区域。对于单通道图像，变量colour为单个颜色值；对于多通道，则为一个元组。

例子2：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
im1.paste((</span>256,256,256),(200,100,500,200<span style="color:#000000;">))
im1.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
注：图像im1的（</span>200，100<span style="color:#000000;">）位置将出现一个300x100的白色方块，对于多通道的图像，如果变量colour只给定一个数值，将只会应用于图像的第一个通道。如果是“RGB”模式的图像，将应用于红色通道。

定义3：im.paste(image,box, mask)
含义3：与定义1一样，但是它使用变量mask对应的模板图像来填充所对应的区域。可以使用模式为“</span>1<span style="color:#000000;">”、“L”或者“RGBA”的图像作为模板图像。模板图像的尺寸必须与变量image对应的图像尺寸一致。<br>      如果变量mask对应图像的值为255，则模板图像的值直接被拷贝过来；如果变量mask对应图像的值为0，则保持当前图像的原始值。变量mask对应图像的其他值，将对两张图像的值进行透明融合。
注意：如果变量image对应的为“RGBA”图像，即粘贴的图像模式为“RGBA”，则alpha通道被忽略。用户可以使用同样的图像作为原图像和模板图像。

例子3：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
box </span>= [100,100,200,200<span style="color:#000000;">]
im_crop </span>=<span style="color:#000000;"> im1.crop(box)
r,g,b </span>=<span style="color:#000000;"> im_crop.split()
im1.paste(im_crop,(</span>200,100,300,200<span style="color:#000000;">),b)
im1.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
注：在图像im1的（0，0）位置将出现一个半透明的100x100的方块。

定义4：im.paste(colour,box, mask)
含义4：与定义3一样，只是使用变量colour对应的单色来填充区域。<br>
例子4：
</span><span style="color:#0000ff;">from</span> PIL <span style="color:#0000ff;">import</span><span style="color:#000000;"> Image
im1 </span>= Image.open(<span style="color:#800000;">"</span><span style="color:#800000;">jing.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
box </span>= [100,100,200,200<span style="color:#000000;">]
im_crop </span>=<span style="color:#000000;"> im1.crop(box)
r,g,b </span>=<span style="color:#000000;"> im_crop.split()
im1.paste((0,</span>256,0),(200,100,300,200<span style="color:#000000;">),b)
im1.save(</span><span style="color:#800000;">"</span><span style="color:#800000;">he.jpg</span><span style="color:#800000;">"</span><span style="color:#000000;">)
注：在图像im1的（0，0）位置将出现一个100x100的绿色方块。</span><em style="font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><em><em><em>         </em></em></em></em></pre> 
 </div> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/chimeiwangliang/p/7130434.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c764a6f6883126c14e57e0b9164a9675/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ado.net SqlHelp类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a86a48b0cb9da4c03e16c6e089bee0aa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mongodb安装配置详细图文教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>