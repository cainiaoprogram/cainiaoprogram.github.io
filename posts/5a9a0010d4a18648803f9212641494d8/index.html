<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Zynq-Linux移植学习笔记之55-国产ZYNQ Linux下适配NST175温感 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Zynq-Linux移植学习笔记之55-国产ZYNQ Linux下适配NST175温感" />
<meta property="og:description" content="1、背景介绍 模块中使用国产纳芯微的温感，型号为NST175，该温感通过I2C连接模块上的国产ZYNQ，实现温度采集功能。
通过查阅datasheet，能够发现该温感通过I2C读写时序为标准的I2C读写时序
Nst175的I2C地址为7位
温度寄存器地址为0
温度寄存器是一个16位的数，一般取前8位即可
2、vivado工程配置 vivado中通过PL中的I2C IP核来连接NST175，注意模式选择7bit，同时把中断接上
3、内核配置 内核中需要添加i2c-nst175的驱动，将驱动编译进内核
驱动源码可参考之前的cps1848，代码见下
/* * nst175 bus driver * * Copyright (C) 2014 CGT Corp. * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; version 2 of the License. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5a9a0010d4a18648803f9212641494d8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-17T20:42:57+08:00" />
<meta property="article:modified_time" content="2022-04-17T20:42:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Zynq-Linux移植学习笔记之55-国产ZYNQ Linux下适配NST175温感</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 style="text-align:justify;">1、背景介绍</h3> 
<p style="margin-left:.0001pt;text-align:justify;">模块中使用国产纳芯微的温感，型号为NST175，该温感通过I2C连接模块上的国产ZYNQ，实现温度采集功能。</p> 
<p style="margin-left:.0001pt;text-align:justify;">通过查阅datasheet，能够发现该温感通过I2C读写时序为标准的I2C读写时序</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="870" src="https://images2.imgbox.com/65/70/Uxab2xsr_o.jpg" width="1067"></p> 
<p style="margin-left:.0001pt;text-align:justify;">Nst175的I2C地址为7位</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="657" src="https://images2.imgbox.com/53/3c/GwdjLPR4_o.jpg" width="862"></p> 
<p style="margin-left:.0001pt;text-align:justify;">温度寄存器地址为0</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="340" src="https://images2.imgbox.com/ee/64/MKMi5pNf_o.jpg" width="1089"></p> 
<p style="margin-left:.0001pt;text-align:justify;">温度寄存器是一个16位的数，一般取前8位即可</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="794" src="https://images2.imgbox.com/bd/50/6gwBHFNC_o.jpg" width="1091"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="text-align:justify;">2、vivado工程配置</h3> 
<p style="margin-left:.0001pt;text-align:justify;">vivado中通过PL中的I2C IP核来连接NST175，注意模式选择7bit，同时把中断接上</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="770" src="https://images2.imgbox.com/f1/59/R2VZ7aHd_o.jpg" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="text-align:justify;">3、内核配置</h3> 
<p style="margin-left:.0001pt;text-align:justify;">内核中需要添加i2c-nst175的驱动，将驱动编译进内核</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="764" src="https://images2.imgbox.com/2d/d3/MVgJebrv_o.jpg" width="1081"></p> 
<p style="margin-left:.0001pt;text-align:justify;">驱动源码可参考之前的cps1848，代码见下</p> 
<pre><code class="language-cpp">/*
 * nst175 bus driver
 *
 * Copyright (C) 2014 CGT Corp.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

//#define DEBUG

#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/i2c.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;linux/delay.h&gt;

#include &lt;linux/serial_core.h&gt;

/* Each client has this additional data */
#define USER_EEPROM_SIZE	128
#define USER_XFER_MAX_COUNT	0x8

/* Addresses to scan */
static const unsigned short nst175_i2c[] = { 0x3, I2C_CLIENT_END };

static unsigned read_timeout = 25;
module_param(read_timeout, uint, 0);
MODULE_PARM_DESC(read_timeout, "Time (in ms) to try reads (default 25)");

static unsigned write_timeout = 25;
module_param(write_timeout, uint, 0);
MODULE_PARM_DESC(write_timeout, "Time (in ms) to try writes (default 25)");

struct nst175_data {
	struct mutex	lock;
	u8	*data;
};

static ssize_t nst175_read_data( struct i2c_client *client,
	char *buf, unsigned offset, size_t count)
{
	//printk("in tem.c, %s\n", __func__);
	struct i2c_msg msg[2];
	u8 msgbuf[4];
	unsigned long timeout, transfer_time;
	int status;
	struct nst175_data *data = i2c_get_clientdata(client);

	memset(msg, 0, sizeof(msg));

	msgbuf[0] =(u8)(offset&amp; 0xff);

	msg[0].addr = client-&gt;addr;
	msg[0].buf = msgbuf;
	msg[0].len = 1;

	msg[1].addr = client-&gt;addr;
	msg[1].flags = I2C_M_RD;
	msg[1].buf = buf;
	msg[1].len = count;

	/*
	 * Reads fail if the previous write didn't complete yet. We may
	 * loop a few times until this one succeeds, waiting at least
	 * long enough for one entire page write to work.
	 */
	timeout = jiffies + msecs_to_jiffies(read_timeout);
	do {
		transfer_time = jiffies;
		mutex_lock(&amp;data-&gt;lock);
		status = i2c_transfer(client-&gt;adapter, msg, 1);
                msleep(100); 
		status = i2c_transfer(client-&gt;adapter, &amp;msg[1], 1);
		mutex_unlock(&amp;data-&gt;lock);
		if (status == 2)
			status = count;

//		printk( "read %ld@0x%lx --&gt; %d (%ld)\n",
//				count, (unsigned long)offset, status, jiffies);

		if (status == count)
			return count;

		/* REVISIT: at HZ=100, this is sloooow */
		msleep(1);
	} while (time_before(transfer_time, timeout));

	return -ETIMEDOUT;

 }


static ssize_t nst175_read(struct file *filp, struct kobject *kobj,
			    struct bin_attribute *bin_attr,
			    char *buf, loff_t offset, size_t count)
{
	//printk("in tem.c, %s\n", __func__);
	struct i2c_client *client = kobj_to_i2c_client(kobj);
	struct nst175_data *data = i2c_get_clientdata(client);

	ssize_t retval = 0;

	if (offset &gt; USER_EEPROM_SIZE)
		return 0;

	if (offset + count &gt; USER_EEPROM_SIZE)
		count = USER_EEPROM_SIZE - offset;



//	printk("nst175 start1 read %ld@0x%lx ..\n", count, (unsigned long)offset);

	//printk("%s, count:%d\n",__func__, count);
	while (count &gt; 0) {
		ssize_t	status = count&gt;USER_XFER_MAX_COUNT?USER_XFER_MAX_COUNT:count;
#if 0
		printk("nst175 start2 read %ld@0x%lx ..\n", count, (unsigned long)offset);
#endif
		status = nst175_read_data(client, buf, offset, status);
		if (status &lt;= 0) {
			if (retval == 0)
				retval = status;
			break;
		}
		buf += status;
		offset += status;
		count -= status;
		retval += status;
	}

//	printk( "nst175 end read %ld@0x%lx  !\n", retval, (unsigned long)offset);

	

	return retval;

 }

static ssize_t nst175_write_config(
	struct i2c_client *client,
	struct nst175_data *data,
	char *buf, unsigned offset, size_t count)
{
	struct i2c_msg msg[1];
	u8 *msgbuf;
	unsigned long timeout, transfer_time;
	int status;

	memset(msg, 0, sizeof(msg));

	msgbuf = data-&gt;data;

#if 0
	msgbuf[0] = 0x04;
	msgbuf[1] =(u8)(offset&amp; 0xff);

	memcpy(msgbuf+2, buf, count);

	msg[0].addr = client-&gt;addr;
	msg[0].buf = msgbuf;
	msg[0].len = 2 + count;
#else	
	
	msg[0].addr = client-&gt;addr;
	msgbuf[0] = (u8)(offset&amp; 0xff);
	memcpy(msgbuf+1, buf, count);
	msg[0].buf = msgbuf;
	msg[0].len = 1 + count;
#endif

	/*
	 * Reads fail if the previous write didn't complete yet. We may
	 * loop a few times until this one succeeds, waiting at least
	 * long enough for one entire page write to work.
	 */
	timeout = jiffies + msecs_to_jiffies(write_timeout);
	do {
		transfer_time = jiffies;

		status = i2c_transfer(client-&gt;adapter, msg, 1);

		if (status == 1)
			status = count;

		dev_dbg(&amp;client-&gt;dev, "write %ld@0x%lx --&gt; %d (%ld)\n",
				count, (unsigned long)offset, status, jiffies);

		if (status == count)
			return count;

		/* REVISIT: at HZ=100, this is sloooow */
		msleep(1);
	} while (time_before(transfer_time, timeout));

	return -ETIMEDOUT;
 }

static ssize_t nst175_write(struct file *filp, struct kobject *kobj,
			    struct bin_attribute *bin_attr,
			    char *buf, loff_t offset, size_t count)
{
	struct i2c_client *client = kobj_to_i2c_client(kobj);
	struct nst175_data *data = i2c_get_clientdata(client);

	ssize_t retval = 0;

	if (offset &gt; USER_EEPROM_SIZE)
		return 0;

	if (offset + count &gt; USER_EEPROM_SIZE)
		count = USER_EEPROM_SIZE - offset;

	mutex_lock(&amp;data-&gt;lock);

	dev_dbg(&amp;client-&gt;dev, "nst175 start write %ld@0x%lx ..\n", count, (unsigned long)offset);

	while (count &gt; 0) {
		ssize_t	status = count&gt;USER_XFER_MAX_COUNT?USER_XFER_MAX_COUNT:count;
		status = nst175_write_config(client, data, buf, offset, status);
		if (status &lt;= 0) {
			if (retval == 0)
				retval = status;
			break;
		}
		buf += status;
		offset += status;
		count -= status;
		retval += status;
	}

	dev_dbg(&amp;client-&gt;dev, "nst175 end write %ld@0x%lx  !\n", retval, (unsigned long)offset);

	mutex_unlock(&amp;data-&gt;lock);

	return retval;

 }

static struct bin_attribute user_nst175_attr = {
	.attr = {
		.name = "nst175",
		.mode = (S_IRUSR | S_IWUSR),
	},
	.size = USER_EEPROM_SIZE,
	.read = nst175_read,
	.write = nst175_write,
};

/* Return 0 if detection is successful, -ENODEV otherwise */
static int nst175_detect(struct i2c_client *client, struct i2c_board_info *info)
{
	struct i2c_adapter *adapter = client-&gt;adapter;

	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
		dev_dbg(&amp;client-&gt;dev, "nst175 detect error for BYTE access !\n");
		return -ENODEV;
	}

	strlcpy(info-&gt;type, "nst175", I2C_NAME_SIZE);

	return 0;
 }

static int nst175_probe(struct i2c_client *client,
			 const struct i2c_device_id *id)
{
	struct i2c_adapter *adapter = client-&gt;adapter;
	struct nst175_data *data;
	int err ;

       printk( "in %s ... \n", __func__ );

	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
		dev_err(&amp;client-&gt;dev, "nst175 data driver:  BYTE DATA not supported! \n" );
		return -ENODEV;
	}

	if (!(data = kzalloc(sizeof(struct  nst175_data), GFP_KERNEL))) {
		dev_err(&amp;client-&gt;dev, "nst175 data driver:  Memory alloc error ! \n" );
		return -ENOMEM;
	}

	/* alloc buffer */
	data-&gt;data = devm_kzalloc(&amp;client-&gt;dev, USER_XFER_MAX_COUNT + 8, GFP_KERNEL);
	if (!data-&gt;data) {
		dev_err(&amp;client-&gt;dev, "nst175 data driver:  Memory alloc error ! \n" );
		err = -ENOMEM;
		goto exit_kfree;
	}

	/* Init real i2c_client */
	i2c_set_clientdata(client, data);
	mutex_init(&amp;data-&gt;lock);

	err = sysfs_create_bin_file(&amp;client-&gt;dev.kobj, &amp;user_nst175_attr);
	if (err) {
		dev_err(&amp;client-&gt;dev, "nst175 data driver:  sysfs create error ! \n" );
		goto exit_kfree;
	}

	return 0;

exit_kfree:
	if(data-&gt;data)
		kfree(data-&gt;data);
	kfree(data);
	return err;
 }

static int nst175_remove(struct i2c_client *client)
{
	struct nst175_data *data = i2c_get_clientdata(client);

	sysfs_remove_bin_file(&amp;client-&gt;dev.kobj, &amp;user_nst175_attr);
	if(data-&gt;data)
		kfree(data-&gt;data);
	kfree(data);

	return 0;
 }

static const struct i2c_device_id nst175_id[] = {
	{ "nst175", 0 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, nst175_id);

static struct i2c_driver nst175_driver = {
	.driver = {
		.name	= "nst175",
	},
	.probe		= nst175_probe,
	.remove		= nst175_remove,
	.id_table	= nst175_id,

	.class		= I2C_CLASS_SPD,
	.detect		= nst175_detect,
	.address_list	= nst175_i2c,
};

module_i2c_driver(nst175_driver);

MODULE_AUTHOR("RobinLee");
MODULE_DESCRIPTION("nst175 driver");
MODULE_LICENSE("GPL");
</code></pre> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;"></p> 
<h3 style="text-align:justify;">4、devicetree设置</h3> 
<p style="margin-left:.0001pt;text-align:justify;">设备树中需要增加两个nst175的节点，i2c地址需要跟硬件确认，如下</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="377" src="https://images2.imgbox.com/2c/c0/qmWpmbby_o.jpg" width="636"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="text-align:justify;">5、应用测试</h3> 
<p style="margin-left:.0001pt;text-align:justify;">系统启动后能够看到找到了两个nst175设备</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="278" src="https://images2.imgbox.com/27/78/yNraFpmM_o.jpg" width="1158"></p> 
<p style="margin-left:.0001pt;text-align:justify;">编写应用代码，代码如下</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;memory.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/poll.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;pthread.h&gt;
#include &lt;math.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;

#include &lt;termios.h&gt;
#include &lt;netinet/in.h&gt;

#include "xadc_core.h"

#define  I2C_0   	"/sys/class/i2c-dev/i2c-2/device/2-0049/nst175"
#define  I2C_1   	"/sys/class/i2c-dev/i2c-2/device/2-004a/nst175"

int fp_i2c_0, fp_i2c_1;

extern void printadc();

void init_i2c_file_opt()
{
	fp_i2c_0 = open(I2C_0, O_RDWR);
	printf("input fd:%d !\n", fp_i2c_0);
	if (fp_i2c_0 &lt;0)
	{
		printf("open ic-0 failed..\n");
	}
	fp_i2c_1 = open(I2C_1, O_RDWR);
	printf("input fd:%d !\n", fp_i2c_1);
	if (fp_i2c_1 &lt;0)
	{
		printf("open ic-1 failed..\n");
	}
}

int read_temperatue(unsigned int num, unsigned int offset)
{
	int fd = -1;
	char value = -1;

	if (num == 0)
	{
		fd = fp_i2c_0;
	}
	else if (num == 1)
	{
		fd = fp_i2c_1;
	}
	else
	{
		printf("input error::Invalid param !\n");
		return 0;
	}

	if (fd &lt; 0)
	{
		printf("Invalid device handle !\n");
		return value;
	}

	if (lseek(fd, offset, SEEK_SET) == (off_t) - 1)
	{
		printf("failed for seek to offset 0x%x !\n", offset);
		return value;
	}

	if (read(fd, &amp;value, sizeof(value)) != sizeof(value))
	{
		printf("failed for read from offset 0x%x !\n", offset);
		return value;
	}
	return value;
}

int main()
{
	int value = 0;
	int i = 0;
	init_i2c_file_opt();

	xadc_initialization();
	printadc();

	while (i &lt; 2)
	{
		value = read_temperatue(i, 0);
		printf("No. %d----value:%d cent\n", i, value);
		sleep(1);
		i++;
	}


	return 0;
}
</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">执行应用后能看到正确获取到温度寄存器的第一个字节，和实际温度一致。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="300" src="https://images2.imgbox.com/6a/fb/0tpWgYIV_o.jpg" width="377"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/752a8b997a4a8733d629c58596e3ba7c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker搭建vulhub</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f85c9f4baf826643164564701599460d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL存储引擎特性解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>