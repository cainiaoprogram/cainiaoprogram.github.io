<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试准备1 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试准备1" />
<meta property="og:description" content="上海银行
目录
1. java io 字节流 字符流 使用场景
你了解java的流吗？怎么用流打开一个大文件？
2. java序列化 什么时候会用到（必问）
3. java集合类 哪些是线程安全的 为什么它们是线程安全的
4. String a = &#34;a&#34;创建了几个对象
5. mysql存储引擎 隔离级别
6. mybatis缓存
7. 反射以及其意义
8. linux命令 查看进程 查看文件
linux查看一个想知道的进程？linux查看日志文件带有关键字的？
linux下如何查看网络状态，如何查看硬盘使用情况
9. spring中resources注解和Autowired的区别
10. spring中bean的构造器注入？
11. spring中的bean默认是单例还是多例
12. java设计模式 工厂方法如何实现14. 银行金额的计算在java中怎么实现比较好
15. 线程如何返回一个值
3.实现多线程的几种方式
4.HashSet有什么特点（唯一性），如何保证唯一性的？
5.进程和线程的区别
6.乐观锁和悲观锁
7.一个表（班级，课程名，姓名）有三条记录，说出具体的MySQL语句实现：A班课程最多的学生的姓名
8.进程间通信方式
9.JDBC过程
10.唯一约束和主键约束的区别
11.final关键字
12.Cookie和Session的区别
3.java一个文件里可以有多个类吗？不让用内部类？
4.ArrayList和LinkedList的区别？
5.java的内存回收机制？具体一点?
3.解释一下线程
4.线程间通信
6.mysql游标
1. java io 字节流 字符流 使用场景 在Java中所有数据都是使用流读写的。流是一组有序的数据序列，将数据从一个地方带到另一个地方。根据数据流向的不同，可以分为输入（Input）流和输出（Output）流两种。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fd582e51571d7f10da5114e29a753f48/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-31T15:35:56+08:00" />
<meta property="article:modified_time" content="2022-07-31T15:35:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试准备1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>上海银行</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%C2%A0java%20io%20%E5%AD%97%E8%8A%82%E6%B5%81%20%E5%AD%97%E7%AC%A6%E6%B5%81%20%C2%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#1.%20%C2%A0java%20io%20%E5%AD%97%E8%8A%82%E6%B5%81%20%E5%AD%97%E7%AC%A6%E6%B5%81%20%C2%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">1.  java io 字节流 字符流  使用场景</a></p> 
<p id="%E4%BD%A0%E4%BA%86%E8%A7%A3java%E7%9A%84%E6%B5%81%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%E6%B5%81%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%96%87%E4%BB%B6%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%BD%A0%E4%BA%86%E8%A7%A3java%E7%9A%84%E6%B5%81%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%E6%B5%81%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%96%87%E4%BB%B6%EF%BC%9F" rel="nofollow">你了解java的流吗？怎么用流打开一个大文件？</a></p> 
<p id="2.%20%C2%A0java%E5%BA%8F%E5%88%97%E5%8C%96%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%A8%E5%88%B0%EF%BC%88%E5%BF%85%E9%97%AE%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.%20%C2%A0java%E5%BA%8F%E5%88%97%E5%8C%96%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%A8%E5%88%B0%EF%BC%88%E5%BF%85%E9%97%AE%EF%BC%89" rel="nofollow">2.  java序列化 什么时候会用到（必问）</a></p> 
<p id="3.%20%C2%A0java%E9%9B%86%E5%90%88%E7%B1%BB%20%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E4%BB%AC%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-toc" style="margin-left:40px;"><a href="#3.%20%C2%A0java%E9%9B%86%E5%90%88%E7%B1%BB%20%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E4%BB%AC%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84" rel="nofollow">3.  java集合类 哪些是线程安全的 为什么它们是线程安全的</a></p> 
<p id="4.%20%C2%A0String%20a%20%3D%20%22a%22%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#4.%20%C2%A0String%20a%20%3D%20%22a%22%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1" rel="nofollow">4.  String a = "a"创建了几个对象</a></p> 
<p id="5.%20%C2%A0mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%20%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-toc" style="margin-left:40px;"><a href="#5.%20%C2%A0mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%20%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" rel="nofollow">5.  mysql存储引擎 隔离级别</a></p> 
<p id="6.%20%C2%A0mybatis%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#6.%20%C2%A0mybatis%E7%BC%93%E5%AD%98" rel="nofollow">6.  mybatis缓存</a></p> 
<p id="7.%20%C2%A0%E5%8F%8D%E5%B0%84%E4%BB%A5%E5%8F%8A%E5%85%B6%E6%84%8F%E4%B9%89-toc" style="margin-left:40px;"><a href="#7.%20%C2%A0%E5%8F%8D%E5%B0%84%E4%BB%A5%E5%8F%8A%E5%85%B6%E6%84%8F%E4%B9%89" rel="nofollow">7.  反射以及其意义</a></p> 
<p id="8.%20%C2%A0linux%E5%91%BD%E4%BB%A4%20%C2%A0%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%20%C2%A0%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#8.%20%C2%A0linux%E5%91%BD%E4%BB%A4%20%C2%A0%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%20%C2%A0%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6" rel="nofollow">8.  linux命令  查看进程  查看文件</a></p> 
<p id="linux%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9Flinux%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%B8%A6%E6%9C%89%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%EF%BC%9F-toc" style="margin-left:80px;"><a href="#linux%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9Flinux%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%B8%A6%E6%9C%89%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%EF%BC%9F" rel="nofollow">linux查看一个想知道的进程？linux查看日志文件带有关键字的？</a></p> 
<p id="linux%E4%B8%8B%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%A1%AC%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5-toc" style="margin-left:80px;"><a href="#linux%E4%B8%8B%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%A1%AC%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5" rel="nofollow">linux下如何查看网络状态，如何查看硬盘使用情况</a></p> 
<p id="%C2%A09.%20%C2%A0spring%E4%B8%ADresources%E6%B3%A8%E8%A7%A3%E5%92%8CAutowired%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#%C2%A09.%20%C2%A0spring%E4%B8%ADresources%E6%B3%A8%E8%A7%A3%E5%92%8CAutowired%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow"> 9.  spring中resources注解和Autowired的区别</a></p> 
<p id="10.%20spring%E4%B8%ADbean%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%EF%BC%9F-toc" style="margin-left:40px;"><a href="#10.%20spring%E4%B8%ADbean%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%EF%BC%9F" rel="nofollow">10. spring中bean的构造器注入？</a></p> 
<p id="11.%20spring%E4%B8%AD%E7%9A%84bean%E9%BB%98%E8%AE%A4%E6%98%AF%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B-toc" style="margin-left:40px;"><a href="#11.%20spring%E4%B8%AD%E7%9A%84bean%E9%BB%98%E8%AE%A4%E6%98%AF%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B" rel="nofollow">11. spring中的bean默认是单例还是多例</a></p> 
<p id="12.%20%C2%A0java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%C2%A0%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B014.%20%C2%A0%E9%93%B6%E8%A1%8C%E9%87%91%E9%A2%9D%E7%9A%84%E8%AE%A1%E7%AE%97%E5%9C%A8java%E4%B8%AD%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E5%A5%BD-toc" style="margin-left:40px;"><a href="#12.%20%C2%A0java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%C2%A0%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B014.%20%C2%A0%E9%93%B6%E8%A1%8C%E9%87%91%E9%A2%9D%E7%9A%84%E8%AE%A1%E7%AE%97%E5%9C%A8java%E4%B8%AD%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E5%A5%BD" rel="nofollow">12.  java设计模式  工厂方法如何实现14.  银行金额的计算在java中怎么实现比较好</a></p> 
<p id="15.%20%C2%A0%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%80%BC-toc" style="margin-left:40px;"><a href="#15.%20%C2%A0%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%80%BC" rel="nofollow">15.  线程如何返回一个值</a></p> 
<p id="3.%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#3.%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">3.实现多线程的几种方式</a></p> 
<p id="4.HashSet%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%88%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%89%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.HashSet%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%88%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%89%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%EF%BC%9F" rel="nofollow">4.HashSet有什么特点（唯一性），如何保证唯一性的？</a></p> 
<p id="5.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#5.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">5.进程和线程的区别</a></p> 
<p id="6.%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-toc" style="margin-left:40px;"><a href="#6.%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81" rel="nofollow">6.乐观锁和悲观锁</a></p> 
<p id="7.%E4%B8%80%E4%B8%AA%E8%A1%A8%EF%BC%88%E7%8F%AD%E7%BA%A7%EF%BC%8C%E8%AF%BE%E7%A8%8B%E5%90%8D%EF%BC%8C%E5%A7%93%E5%90%8D%EF%BC%89%E6%9C%89%E4%B8%89%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%8C%E8%AF%B4%E5%87%BA%E5%85%B7%E4%BD%93%E7%9A%84MySQL%E8%AF%AD%E5%8F%A5%E5%AE%9E%E7%8E%B0%EF%BC%9AA%E7%8F%AD%E8%AF%BE%E7%A8%8B%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E7%9A%84%E5%A7%93%E5%90%8D-toc" style="margin-left:40px;"><a href="#7.%E4%B8%80%E4%B8%AA%E8%A1%A8%EF%BC%88%E7%8F%AD%E7%BA%A7%EF%BC%8C%E8%AF%BE%E7%A8%8B%E5%90%8D%EF%BC%8C%E5%A7%93%E5%90%8D%EF%BC%89%E6%9C%89%E4%B8%89%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%8C%E8%AF%B4%E5%87%BA%E5%85%B7%E4%BD%93%E7%9A%84MySQL%E8%AF%AD%E5%8F%A5%E5%AE%9E%E7%8E%B0%EF%BC%9AA%E7%8F%AD%E8%AF%BE%E7%A8%8B%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E7%9A%84%E5%A7%93%E5%90%8D" rel="nofollow">7.一个表（班级，课程名，姓名）有三条记录，说出具体的MySQL语句实现：A班课程最多的学生的姓名</a></p> 
<p id="8.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#8.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F" rel="nofollow">8.进程间通信方式</a></p> 
<p id="9.JDBC%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#9.JDBC%E8%BF%87%E7%A8%8B" rel="nofollow">9.JDBC过程</a></p> 
<p id="10.%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F%E5%92%8C%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#10.%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F%E5%92%8C%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">10.唯一约束和主键约束的区别</a></p> 
<p id="11.final%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#11.final%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">11.final关键字</a></p> 
<p id="12.Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#12.Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">12.Cookie和Session的区别</a></p> 
<p id="3.java%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%90%97%EF%BC%9F%E4%B8%8D%E8%AE%A9%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#3.java%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%90%97%EF%BC%9F%E4%B8%8D%E8%AE%A9%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F" rel="nofollow">3.java一个文件里可以有多个类吗？不让用内部类？</a></p> 
<p id="4.ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">4.ArrayList和LinkedList的区别？</a></p> 
<p id="5.java%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%85%B7%E4%BD%93%E4%B8%80%E7%82%B9%3F-toc" style="margin-left:40px;"><a href="#5.java%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%85%B7%E4%BD%93%E4%B8%80%E7%82%B9%3F" rel="nofollow">5.java的内存回收机制？具体一点?</a></p> 
<p id="3.%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#3.%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B" rel="nofollow">3.解释一下线程</a></p> 
<p id="4.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-toc" style="margin-left:40px;"><a href="#4.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1" rel="nofollow">4.线程间通信</a></p> 
<p id="6.mysql%E6%B8%B8%E6%A0%87-toc" style="margin-left:40px;"><a href="#6.mysql%E6%B8%B8%E6%A0%87" rel="nofollow">6.mysql游标</a></p> 
<hr id="hr-toc"> 
<h3>1.  java io 字节流 字符流  使用场景</h3> 
<blockquote> 
 <p>在Java中所有数据都是使用流读写的。流是一组有序的数据序列，将数据从一个地方带到另一个地方。根据数据流向的不同，可以分为输入（Input）流和输出（Output）流两种。</p> 
 <p>Java 流根据操作的数据类型不同在处理上分为字符流和字节流。字符流处理的单元为 2 个字节的 Unicode 字符，分别操作字符、字符数组或字符串，而字节流处理单元为 1 个字节，操作字节和字节数组。</p> 
 <p>Java 内用 Unicode 编码存储字符，字符流处理类负责将外部的其他编码的字符流和 java 内 Unicode 字符流之间的转换。而类 InputStreamReader 和 OutputStreamWriter 处理字符流和字节流的转换。字符流（一次可以处理一个缓冲区）一次操作比字节流（一次一个字节）效率高。</p> 
</blockquote> 
<p><a href="https://blog.csdn.net/zj8692286/article/details/12650731" title="字符流和字节流的区别，使用场景，相关类_其实我是个好人的博客-CSDN博客_字符流和字节流的区别,使用场景,相关类">字符流和字节流的区别，使用场景，相关类_其实我是个好人的博客-CSDN博客_字符流和字节流的区别,使用场景,相关类</a></p> 
<p><a href="https://www.cnblogs.com/ywzbky/p/10692238.html" rel="nofollow" title="JAVA中IO流详解 - ControllerMe - 博客园">JAVA中IO流详解 - ControllerMe - 博客园</a></p> 
<p></p> 
<h4 id="%E4%BD%A0%E4%BA%86%E8%A7%A3java%E7%9A%84%E6%B5%81%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%E6%B5%81%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%96%87%E4%BB%B6%EF%BC%9F">你了解java的流吗？怎么用流打开一个大文件？</h4> 
<blockquote> 
 <p>  在Java中，文件的输入和输出是通过流（Stream）来实现的。一个流，必有源端和目的端，它们可以是计算机内存的某些区域，也可以是磁盘文件，甚至可以是 Internet 上的某个 URL。对于流而言，我们不用关心数据是如何传输的，只需要向源端输入数据，从目的端获取数据即可。</p> 
 <p>    流按照处理数据的单位，可以分为字节流和字符流。字节流的处理单位是字节，通常用来处理二进制文件，例如音乐、图片文件等。而字符流的处理单位是字符，因为Java采用Unicode编码，Java字符流处理的即为Unicode字符，所以在操作汉字、国际化等方面，字符流具有优势。</p> 
 <p><a href="https://www.cnblogs.com/jmcui/p/9096536.html" rel="nofollow" title="Java 文件流操作. - JMCui - 博客园">Java 文件流操作. - JMCui - 博客园</a></p> 
 <p><a href="https://blog.csdn.net/zhufenghao/article/details/51192043" title="java 分次读取大文件的三种方法_ifenghao的博客-CSDN博客_java 大文件读取">java 分次读取大文件的三种方法_ifenghao的博客-CSDN博客_java 大文件读取</a></p> 
 <pre><code class="language-java">Path path = Paths.get("file path");
byte[] data = Files.readAllBytes(path);
//这对于小文件是没有问题的，但是对于稍大一些的文件就会抛出异常</code></pre> 
 <p>对文件建立 <code>java.io.BufferedInputStream</code> ，每次调用 <code>read()</code> 方法时会接连取出文件中长度为 <code>arraySize</code> 的数据到 <code>array</code> 中。这种方法可行但是效率不高。</p> 
</blockquote> 
<h3 id="2.%20%C2%A0java%E5%BA%8F%E5%88%97%E5%8C%96%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%A8%E5%88%B0%EF%BC%88%E5%BF%85%E9%97%AE%EF%BC%89"><br><strong><span style="background-color:#fe2c24;">2.  java序列化 什么时候会用到（必问）</span></strong></h3> 
<blockquote> 
 <p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化,将数据分解成字节流，以便存储在文件中或在网络上传输。<br> 可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。 <br> 序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用<br> ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流;</p> 
</blockquote> 
<blockquote> 
 <p>序列化分为两大部分：序列化和反序列化。序列化是这个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。<br> 反序列化就是打开字节流并重构对象。对象序列化不仅要将基本数据类型转换成字节表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例 <br> 什么时候使用序列化： <br> 一：对象序列化可以实现分布式对象。主要应用例如：RMI要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。 <br> 二：java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的"深复制"，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。 </p> 
</blockquote> 
<h3 id="3.%20%C2%A0java%E9%9B%86%E5%90%88%E7%B1%BB%20%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E4%BB%AC%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84">3.  java集合类 哪些是线程安全的 为什么它们是线程安全的</h3> 
<blockquote> 
 <p>vector：就比arraylist多了个同步化机制（线程安全）<br> statck：堆栈类，先进后出<br> hashtable：就比hashmap多了个线程安全<br> ConcurrentHashMap:是一种高效但是线程安全的集合。<br> enumeration：枚举，相当于迭代器</p> 
</blockquote> 
<h3 id="4.%20%C2%A0String%20a%20%3D%20%22a%22%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1">4.  String a = "a"创建了几个对象</h3> 
<blockquote> 
 <p>如果字符串常量池中存在abc，则该语句并不会创建对象，只是讲字符串常量池中的引用返回而已。<br> 如果字符串常量池中不存在abc，则会创建并放入字符串常量池，并返回引用，此时会有一个对象进行创建。</p> 
</blockquote> 
<h3 id="5.%20%C2%A0mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%20%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">5.  mysql存储引擎 隔离级别</h3> 
<blockquote> 
 <p>REPEATABLE-READ(可重读)<br> 原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；<br> 一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；<br> 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；<br> 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。<br> 事务是逻辑上的一组操作，要么都执行，要么都不执行。<br> 在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务(多个用户对统一数据进行操作)。并发虽然是必须的，但可能会导致以下的问题。<br> 1.脏读(Dirty read): 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<br> 2.丢失修改(Lost to modify): 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。<br> 3.不可重复读(Unrepeatableread): 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。<br> 4.幻读(Phantom read): 幻读与不可重复读类似。它发生在一个事务(T1)读取了几行数据，接着另一个并发事务(T2)插入了一些数据时。在随后的查询中，第一个事务(T1)就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p> 
 <p>不可重复度和幻读区别：<br> 不可重复读的重点是修改，幻读的重点在于新增或者删除。<br> 例1(同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 )：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。<br> 例2(同样的条件, 第1次和第2次读出来的记录数不一样 )：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p> 
 <p>SQL 标准定义了四个隔离级别：<br> READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br> READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br> REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br> SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。<br> 隔离级别脏读不可重复读幻影读</p> 
</blockquote> 
<h3 id="6.%20%C2%A0mybatis%E7%BC%93%E5%AD%98">6.  mybatis缓存</h3> 
<blockquote> 
 <p>MyBatis 中的缓存就是说 MyBatis 在执行一次SQL查询或者SQL更新之后，这条SQL语句并不会消失，而是被MyBatis 缓存起来，当再次执行相同SQL语句的时候，就会直接从缓存中进行提取，而不是再次执行SQL命令。</p> 
</blockquote> 
<h3 id="7.%20%C2%A0%E5%8F%8D%E5%B0%84%E4%BB%A5%E5%8F%8A%E5%85%B6%E6%84%8F%E4%B9%89">7.  反射以及其意义</h3> 
<blockquote> 
 <p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；<br> 这种动态获取的以及动态调用对象的方法的功能称为java语言的反射机制。<br> 反射的应用场合：在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息.<br> 意义：1.增加程序的灵活性，避免将程序写死到代码里。<br> 2.代码简洁，提高代码的复用率，外部调用方便</p> 
 <p>3.对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法<br> 主要用途：<br> 反射最重要的用途就是开发各种通用框架。</p> 
</blockquote> 
<p><a href="https://blog.csdn.net/qq_43473073/article/details/88935183" title="反射的作用及意义_qq_43473073的博客-CSDN博客_反射的作用">反射的作用及意义_qq_43473073的博客-CSDN博客_反射的作用</a></p> 
<pre><code class="language-java">package cn.yonyong.reflection.testdemo;
 
interface Fruit { //水果接口
　 public void eat() ; //吃水果
}
 
class Apple implements Fruit{ //定义苹果
　　public void eat() {
　　　　System.out.println("**吃苹果。"); 
　　} 
}
 
class Orange implements Fruit{
　　public void eat() {
　　　　System.out.println("**吃橘子。"); 
　　}
}
 
class Factory{
　　public static Fruit getInstance(String className){
　　　　Fruit fruit = null ;
　　　　try{
　　　　　　fruit = (Fruit) Class.forName(className).newInstance() ;
　　　　}catch(Exception e ){
　　　　　　e.printStackTrace() ;
　　　　}
　　　　return fruit ;
　 }
}
 
public class FactoryDemo{
　　public static void main(String args[]){
　　//通过工厂类取得接口实例，传入完整的包.类名称
　　　　Fruit f = Factory.getInstance("cn.yonyong.reflection.testdemo.Apple") ;
　　　　if(f!=null){ //判断是否取得接口实例
　　　　　　f.eat() ;
　　　　}
　 }
}</code></pre> 
<blockquote> 
 <p>如果不用反射，那么我们如果再加一个西瓜类，就得在Factory里判断，每添加一个类都要修改一次Factory，但用了反射只用在调用的时候传入完整的类名就可完成。结果：用反射，修改一处代码；不用反射，修改两处代码。</p> 
</blockquote> 
<h3 id="8.%20%C2%A0linux%E5%91%BD%E4%BB%A4%20%C2%A0%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%20%C2%A0%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6">8.  linux命令  查看进程  查看文件</h3> 
<blockquote> 
 <p>查看进程：ps -ef/ax<br>    -e：显示系统内所有进程的信息。与 -A 选项功能相同<br>    -f：使用完整 (full) 的格式显示进程信息，如果只有 ps -e 则输出进程信息的格式和只使用 ps 一样（都只有PID TTY TIME CMD这几项，但是输出信息的内容和ps的不一样）<br>     a：显示当前终端下的所有进程信息，包含其他用户的进程信息。和 x 选项结合使用可以显示系统中所有进程的信息<br>     x：显示当前用户在所有终端下的进程信息</p> 
 <p>查看某个进程：<a href="https://www.cnblogs.com/EasonJim/p/8098217.html" rel="nofollow" title="Linux查看某个进程的线程 - EasonJim - 博客园">Linux查看某个进程的线程 - EasonJim - 博客园</a></p> 
 <pre><code>ps -T -p &lt;pid&gt; / top -H -p &lt;pid&gt;</code></pre> 
 <p>查看文件：lsof命令，可以列出被进程所打开的文件的信息。<br> cat：从第一行开始显示文本内容（适用于内容较少的）<br> tac：从最后一行开始显示，是 cat 的逆顺序<br> more：一页一页的显示文本内容（适用于内容较多的）<br> less：与 more 类似，但是比 more 更好的是，它可以往前翻页！<br> head：只看文本的前面几行<br> tail：只看文本的后面几行<br> nl：显示文本内容与行号</p> 
</blockquote> 
<h4 id="linux%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9Flinux%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%B8%A6%E6%9C%89%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%EF%BC%9F">linux查看一个想知道的进程？linux查看日志文件带有关键字的？</h4> 
<blockquote> 
 <p>1、查看日志 <strong>前 n行</strong>：</p> 
 <p>　　<strong>cat 文件名 | head -n 数量</strong></p> 
 <p>　　demo：cat  test.log | head -n 200　　# 查看test.log前200行</p> 
 <p>2、查看日志 <strong>尾 n行</strong>：</p> 
 <p>　　<strong>cat 文件名 | tail -n 数量</strong></p> 
 <p>　　demo：cat  test.log | tail -n 200　　# 查看test.log倒数200行</p> 
 <p>3、根据 <strong>关键词</strong> 查看日志 并<strong>返回关键词所在行</strong>：</p> 
 <p>　　<em>方法一：</em><strong>cat 路径/文件名 | grep 关键词</strong></p> 
 <p>　　demo：cat  test.log | grep "http"　　# 返回test.log中包含http的所有行</p> 
 <p>　　<em>方法二：</em><strong>grep -i 关键词 路径/文件名</strong>  （与方法一效果相同，不同写法而已）</p> 
 <p>　　demo：grep -i "http" ./test.log　　# 返回test.log中包含http的所有行(-i忽略大小写）</p> 
</blockquote> 
<h4 id="linux%E4%B8%8B%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%A1%AC%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5">linux下如何查看网络状态，如何查看硬盘使用情况</h4> 
<blockquote> 
 <p>使用命令：<strong>netstat</strong> 搭配-anp 来查看网络连接数和端口</p> 
 <p>使用<code>ifconfig</code>命令可以查看到本机的一些IP信息：</p> 
 <p><a href="https://blog.csdn.net/Moo_Lavender/article/details/106104401" title="【Linux】查看硬盘、CPU、内存、网络 相关信息的指令_Moo_Lavender的博客-CSDN博客">【Linux】查看硬盘、CPU、内存、网络 相关信息的指令_Moo_Lavender的博客-CSDN博客</a></p> 
</blockquote> 
<h3 id="%C2%A09.%20%C2%A0spring%E4%B8%ADresources%E6%B3%A8%E8%A7%A3%E5%92%8CAutowired%E7%9A%84%E5%8C%BA%E5%88%AB"> 9.  spring中resources注解和Autowired的区别</h3> 
<blockquote> 
 <p>首先，@Resource 是 JSR-250 标准的注释，不属于 Spring 中的标准注解，而@Autowired 属于 Spring 中的注解。<br> @Autowired 与@Resource 都可以用来装配 bean. 都可以写在字段上, 或写在 setter 方法上。<br> 不同在于：<br> @Autowired 默认按类型装配（byType），如果要按名称装配的话，必须和@Qualifier 注解一起使用。</p> 
 <pre><code class="language-java">@Autowired() 
@Qualifier("myBean")
private MyBean myBean;</code></pre> 
 <p>@Resource，默认按名称进行装配（byName），通过 name 属性设置名称，如果没有设置 name 属性，则默认取字段名名称进行查找。如果还是找不到名称，则会按照类型进行装配。需要注意的是，如果 name 属性被设置了，那么必须是按照名称进行装配。</p> 
 <pre><code class="language-java">@Resource("myBean")
private MyBean myBean;</code></pre> 
</blockquote> 
<h3 id="10.%20spring%E4%B8%ADbean%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%EF%BC%9F">10. spring中bean的构造器注入？</h3> 
<blockquote> 
 <p>spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。<br> 依赖注入的方式<br> 依赖注入有3种方式：构造器注入、set注入和注解注入。<br><a href="http://www.cnblogs.com/Jason-Xiang/p/5345342.html" rel="nofollow" title="www.cnblogs.com/Jason-Xiang/p/5345342.html">www.cnblogs.com/Jason-Xiang/p/5345342.html</a></p> 
</blockquote> 
<h3 id="11.%20spring%E4%B8%AD%E7%9A%84bean%E9%BB%98%E8%AE%A4%E6%98%AF%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B">11. spring中的bean默认是单例还是多例</h3> 
<blockquote> 
 <p>Spring容器管理的bean在默认情况下是单例的，也即，一个bean只会创建一个对象，存在内置map中，之后无论获取多少次该bean，都返回同一个对象。<br> 配置多例：多例 scope="prototype" 单例 scope="singleton"  （默认方式）<br>           例：&lt;bean id="dog" class="com.dreamguard.domain.Dog" scope="prototype"&gt;&lt;/bean&gt;<br> 单例模式下的生命周期 <br>           bean在单例模式下，spring容器启动时解析xml发现该bean标签后，直接创建该bean的对象存入内部map中保存，此后无论调用多少次getBean()获取该bean都是从map中获取该对象返回，一直是一个对象。此对象一直被Spring容器持有，直到容器退出时，随着容器的退出对象被销毁。<br> 多例模式下的生命周期<br>           bean在多例模式下，spring容器启动时解析xml发现该bean标签后，只是将该bean进行管理，并不会创建对象，此后每次使用 getBean()获取该bean时，spring都会重新创建该对象返回，每次都是一个新的对象。这个对象spring容器并不会持有，什么销毁取决于使用该对象的用户自己什么时候销毁该对象。</p> 
</blockquote> 
<h3 id="12.%20%C2%A0java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%C2%A0%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B014.%20%C2%A0%E9%93%B6%E8%A1%8C%E9%87%91%E9%A2%9D%E7%9A%84%E8%AE%A1%E7%AE%97%E5%9C%A8java%E4%B8%AD%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E5%A5%BD">12.  java设计模式  工厂方法如何实现<br> 14.  银行金额的计算在java中怎么实现比较好</h3> 
<blockquote> 
 <p>在牵涉到金额的计算时,为了保持高精度的准确性,使用bigDecimal类型.<br> 在使用BigDecimal类来进行计算的时候，主要分为以下步骤：<br>              1、用float或者double变量构建BigDecimal对象。<br>              2、通过调用BigDecimal的加，减，乘，除等相应的方法进行算术运算。<br>              3、把BigDecimal对象转换成float，double，int等类型。<br>           一般来说，可以使用BigDecimal的构造方法或者静态方法的valueOf()方法把基本类型的变量构建成BigDecimal对象。<br> 1 BigDecimal b1 = new BigDecimal(Double.toString(0.48));<br> 2 BigDecimal b2 = BigDecimal.valueOf(0.48);<br>         对于常用的加，减，乘，除，BigDecimal类提供了相应的成员方法。<br> 1 public BigDecimal add(BigDecimal value);                        //加法<br> 2 public BigDecimal subtract(BigDecimal value);                   //减法 <br> 3 public BigDecimal multiply(BigDecimal value);                   //乘法<br> 4 public BigDecimal divide(BigDecimal value);                     //除法<br>           进行相应的计算后，我们可能需要将BigDecimal对象转换成相应的基本数据类型的变量，可以使用floatValue()，doubleValue()等方法。</p> 
</blockquote> 
<h3 id="15.%20%C2%A0%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%80%BC">15.  线程如何返回一个值</h3> 
<blockquote> 
 <p>一、通过变量和方法返回数据<br> 二、通过回调函数返回数据<br> 三、实现 Callable 接口<br> isDone：利用state变量判断call方法有没有被执行<br> get：如果call方法已经执行完就返回call方法的返回值，如果call方法没有执行完就一直阻塞<br><a href="https://blog.csdn.net/qq_18505715/article/details/78726164" title="Java   从线程返回数据_YFL_iOS的博客-CSDN博客_java线程返回数据">Java 从线程返回数据_YFL_iOS的博客-CSDN博客_java线程返回数据</a><br><a href="https://blog.csdn.net/qq877728715/article/details/107003268/" title="【Java多线程】如何给线程传递数据及让线程返回数据_墩墩分墩的博客-CSDN博客_线程返回参数">【Java多线程】如何给线程传递数据及让线程返回数据_墩墩分墩的博客-CSDN博客_线程返回参数</a></p> 
</blockquote> 
<hr> 
<hr> 
<h3 id="3.%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">3.实现多线程的几种方式</h3> 
<blockquote> 
 <p>1、继承Thread类，重写run方法；</p> 
 <p>2、实现Runnable接口，重写run方法；</p> 
 <p>3、通过Callable和FutureTask创建线程；</p> 
 <p>4、通过线程池创建线程。</p> 
 <p>前面两种可以归结为一类：无返回值，原因很简单，通过重写run方法，run方式的返回值是void，所以没有办法返回结果</p> 
 <p>后面两种可以归结成一类：有返回值，通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中</p> 
</blockquote> 
<p><a href="https://www.cnblogs.com/felixzh/p/6036074.html" rel="nofollow" title="JAVA多线程实现的四种方式 - 大数据从业者FelixZh - 博客园">JAVA多线程实现的四种方式 - 大数据从业者FelixZh - 博客园</a></p> 
<h3 id="4.HashSet%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%88%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%89%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%EF%BC%9F"><br> 4.HashSet有什么特点（唯一性），如何保证唯一性的？</h3> 
<blockquote> 
 <p>HashSet是如何保证元素的唯一性的(判断元素相同的依据)： 是通过元素的两个方法，hashCode和equals来完成</p> 
 <p>　　-如果元素的HashCode值相同，才会判断equals是否为true<br> 　　-如果元素的hashcode值不同，不会调用equals</p> 
 <p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值 相同的两个对象不一定等价。 <strong>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</strong> 下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集 合中添加一个对象，但是因为 EqualExample 没有实现 hashCode() 方法，因此这两个对象的散列值是不同的，最终 导致集合添加了两个等价的对象</p> 
 <pre><code class="language-java">EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();
set.add(e1);
set.add(e2);
System.out.println(set.size()); // 2</code></pre> 
</blockquote> 
<p><a href="https://blog.csdn.net/jdsjlzx/article/details/51760634" title="Java HashSet特点：不重复（对象的哈希代码一样）、无序_一叶飘舟的博客-CSDN博客">Java HashSet特点：不重复（对象的哈希代码一样）、无序_一叶飘舟的博客-CSDN博客</a></p> 
<h3 id="5.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">5.进程和线程的区别</h3> 
<blockquote> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（1）进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（2）同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（4）线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（5）线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（6）线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志</span></p> 
</blockquote> 
<h3 id="6.%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">6.乐观锁和悲观锁</h3> 
<blockquote> 
 <p style="margin-left:0cm;"><span style="color:#000000;">乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。CAS技术。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式，认为数据被并发修改的概率比较大，所以需要在修改之前先加排他锁。</span></p> 
 <p style="margin-left:0cm;"></p> 
 <p style="margin-left:0cm;"><span style="background-color:#00ff00;"><span style="color:#000000;">死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？</span></span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（1）相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态。原因：系统资源不足、相互竞争资源、请求资源顺序不当</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（2）互斥、不可抢占、循环等待、请求与保持</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（3）因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法：剥夺资源、杀死其中一个线程</span></p> 
</blockquote> 
<h3 id="7.%E4%B8%80%E4%B8%AA%E8%A1%A8%EF%BC%88%E7%8F%AD%E7%BA%A7%EF%BC%8C%E8%AF%BE%E7%A8%8B%E5%90%8D%EF%BC%8C%E5%A7%93%E5%90%8D%EF%BC%89%E6%9C%89%E4%B8%89%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%8C%E8%AF%B4%E5%87%BA%E5%85%B7%E4%BD%93%E7%9A%84MySQL%E8%AF%AD%E5%8F%A5%E5%AE%9E%E7%8E%B0%EF%BC%9AA%E7%8F%AD%E8%AF%BE%E7%A8%8B%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E7%9A%84%E5%A7%93%E5%90%8D">7.一个表（班级，课程名，姓名）有三条记录，说出具体的MySQL语句实现：A班课程最多的学生的姓名</h3> 
<p>select name from a where class='A' group by name order by count(name) limit 1.</p> 
<blockquote> 
 <p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。用having就一定要和group by连用。select from where group by having order by</p> 
 <p>“Where” 是一个约束声明，使用Where来约束来之 数据库 的数据，Where是在结果返回之前起作用的，且Where中不能使用聚合函数。 “Having”是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在Having中可以使用聚合函数。 </p> 
</blockquote> 
<h3 id="8.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">8.进程间通信方式</h3> 
<blockquote> 
 <p style="margin-left:0cm;"><span style="color:#000000;">进程间通信又称IPC(Inter-Process Communication),指多个进程之间相互通信，交换信息的方法。根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">、低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">2</span><span style="color:#000000;">、高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等).</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">[</span><span style="color:#000000;">共享内存( shared memory )] ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</span></p> 
</blockquote> 
<h3 id="9.JDBC%E8%BF%87%E7%A8%8B">9.JDBC过程</h3> 
<blockquote> 
 <p>第一步：加载Driver类，注册数据库驱动；<br> 第二步：通过DriverManager,使用url，用户名和密码建立连接(Connection)；<br> 第三步：通过Connection，使用sql语句打开Statement对象；<br> 第四步：执行语句，将结果返回resultSet；<br> 第五步：对结果resultSet进行处理；<br> 第六步：倒叙释放资源resultSet-》preparedStatement-》connection。</p> 
</blockquote> 
<h3 id="10.%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F%E5%92%8C%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%8C%BA%E5%88%AB">10.唯一约束和主键约束的区别</h3> 
<blockquote> 
 <p>（1）.唯一性约束允许在该列上存在NULL值，而主键约束的限制更为严格，不但不允许有重复，而且也不允许有空值。</p> 
 <p>（2）.在创建唯一性约束和主键约束时可以创建聚集索引和非聚集索引，但在 默认情况下主键约束产生</p> 
</blockquote> 
<h3 id="11.final%E5%85%B3%E9%94%AE%E5%AD%97">11.final关键字</h3> 
<blockquote> 
 <p>final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）</p> 
 <p>1.修饰类</p> 
 <p>　　当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p> 
 <p>在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。</p> 
 <p>2.修饰方法</p> 
 <p>　　下面这段话摘自《Java编程思想》第四版第143页：</p> 
 <p>　　“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“</p> 
 <p>　　因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。</p> 
 <p>　　注：类的private方法会隐式地被指定为final方法。</p> 
 <p>3.修饰变量</p> 
 <p>　　修饰变量是final用得最多的地方，也是本文接下来要重点阐述的内容。首先了解一下final变量的基本语法：</p> 
 <p>　　对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p> 
</blockquote> 
<p><a href="https://www.cnblogs.com/dolphin0520/p/3736238.html" rel="nofollow" title="浅析Java中的final关键字 - Matrix海子 - 博客园">浅析Java中的final关键字 - Matrix海子 - 博客园</a></p> 
<p></p> 
<h3 id="12.Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB">12.Cookie和Session的区别</h3> 
<blockquote> 
 <ul><li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li><li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li></ul> 
 <p>Cookie 主要用于以下三个方面：</p> 
 <ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul> 
</blockquote> 
<hr> 
<p></p> 
<hr> 
<h3 id="3.java%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%90%97%EF%BC%9F%E4%B8%8D%E8%AE%A9%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F">3.java一个文件里可以有多个类吗？不让用内部类？</h3> 
<blockquote> 
 <p>可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。一个文件中可以只有非public类，如果只有一个非public类，此类可以跟文件名不同。</p> 
</blockquote> 
<h3 id="4.ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">4.ArrayList和LinkedList的区别？</h3> 
<blockquote> 
 <p>ArrayList 与 LinkedList 都是 List 接口的实现类，因此都实现了 List 的所有未实现的方法，只是实现的方式有所不同。<br> ArrayList 是基于动态数组数据结构的实现，访问元素速度优于 LinkedList。LinkedList 是基于链表数据结构的实现，占用的内存空间比较大，但在批量插入或删除数据时优于 ArrayList。<br> 对于快速访问对象的需求，使用 ArrayList 实现执行效率上会比较好。需要频繁向集合中插入和删除元素时，使用 LinkedList 类比 ArrayList 类效果高。</p> 
 <p><a href="http://c.biancheng.net/view/6843.html" rel="nofollow" title="Java List集合：ArrayList和LinkedList类的用法及区别">Java List集合：ArrayList和LinkedList类的用法及区别</a></p> 
</blockquote> 
<h3 id="5.java%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%85%B7%E4%BD%93%E4%B8%80%E7%82%B9%3F">5.java的内存回收机制？具体一点?</h3> 
<blockquote> 
 <p><code><strong>在Java 语言中，判断一块内存空间是否符合垃圾收集器收集标准的标准只有两个：</strong></code></p> 
 <p><code><strong>一个是给对象赋予了空值null，以下再没有调用过，</strong></code></p> 
 <p><code><strong>另一个是给对象赋予了新值，即 重新分配了内存空间。</strong></code></p> 
 <p><code><strong>JVM通过GC（Garbage Collection，垃圾回收器）来回收堆和方法区中的内存，这个过程是自动执行的。说到Java GC机制，其主要完成3件事：确定哪些内存需要回收；确定什么时候需要执行GC；如何执行GC。JVM主要采用回收器的方式实现GC，主要的回收器有引用计数回收器和跟踪回收器。</strong></code></p> 
 <pre><code class="language-html">　对象是否会被回收的两个经典算法：引用计数法，和可达性分析算法。</code></pre> 
 <p><a href="https://blog.csdn.net/weixin_39067991/article/details/81045201" title="一篇文章搞定java中的垃圾回收机制面试题_蓝Q_Q的博客-CSDN博客_垃圾回收机制面试题">一篇文章搞定java中的垃圾回收机制面试题_蓝Q_Q的博客-CSDN博客_垃圾回收机制面试题</a><br><a href="https://blog.csdn.net/u012723673/article/details/100695831" title="深入理解Java内存回收机制_老鼠只爱大米的博客-CSDN博客_java内存回收机制原理">深入理解Java内存回收机制_老鼠只爱大米的博客-CSDN博客_java内存回收机制原理</a></p> 
</blockquote> 
<p>6.设计模式？策略模式？程序如何知道如何替换？<br> 8.你用过中间件吗？（连接池？MQ）<br> 9.你了解分布式代码吗？<br> 10.springboot的项目是如何导入包的？你用过什么包管理？<br> 11.springboot的项目建了什么索引？Elasticsearch<br> 12.如何查看运行的docker？</p> 
<p><br> 14.你用过linux服务器吗？你知道如何安装docker吗？如果没没有网呢？本地安装？</p> 
<hr> 
<hr> 
<p>1.docker的使用实例<br> 2.docker namespace</p> 
<h3 id="3.%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B">3.解释一下线程</h3> 
<blockquote> 
 <p>线程：是进程的一个实体，是cpu调度和分派的基本单位，他是比进程更小的能够独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源。 一个线程可以创建和撤销拎一个线程。</p> 
</blockquote> 
<h3 id="4.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">4.线程间通信</h3> 
<blockquote> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（1）使用全局变量</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（2）使用消息实现通信</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">（3）使用事件CEvent类实现线程间通信</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">Event</span><span style="color:#000000;">对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。</span></p> 
</blockquote> 
<h3 id="6.mysql%E6%B8%B8%E6%A0%87">6.mysql游标</h3> 
<blockquote> 
 <p>游标就是一个标识，用来标识数据取到了什么地方在 MySQL 中，存储过程或函数中的查询有时会返回多条记录，而使用简单的 SELECT 语句，没有办法得到第一行、下一行或前十行的数据，这时可以使用游标来逐条读取查询结果集中的记录。</p> 
</blockquote> 
<p>7.了不了解spring cload等微服务架构</p> 
<p>10.zookeeper怎么使用<br> 11.sql优化</p> 
<p></p> 
<hr> 
<p>1.浏览器输入url地址之后的步骤，如何通过地址找到对应的服务器</p> 
<p>2.get和post请求之间的区别</p> 
<p>3.数据库各种连接</p> 
<p>4.exception都有什么</p> 
<p>5.hashset equals和==的区别，equals重写hashcode也要重写，为什么？重写和重载的区别</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f3c9ecba6037cd8f2eae065b1b7168d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql having的用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ef6c9859bb9f12c021e1607c82b4c1e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Less和Scss</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>