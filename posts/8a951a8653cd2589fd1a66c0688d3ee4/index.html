<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL存储过程的动态行转列 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL存储过程的动态行转列" />
<meta property="og:description" content="MySQL存储过程中使用动态行转列 最近做项目关于数据报表处理，然而数据库存储格式和报表展现形式不同，需要进行一下行转列的操作，在做上一个项目的时候也看了一下，但是后来换了读取方式，也就没深入研究这个问题了。
而这一次必须要直面这个问题了，奈何我是那么的不想看，可项目不能因为这个问题卡在这，只好好好找资料看如何解决这个问题。
开始也在网上找到一些MySQL行转列的例子，但大部分都是静态的，要么就是不知所云，说的不是很清楚。后来就找到国外的一个资料，参考了之后对照自己项目的数据库，然后便成功的实现了动态行转列。下面我以一个简单的数据库为例子，说明一下。
数据表结构 这里我用一个比较简单的例子来说明，也是行转列的经典例子，就是学生的成绩
三张表：学生表、课程表、成绩表
学生表
就简单一点，学生学号、学生姓名两个字段
CREATE TABLE `student` ( `stuid` VARCHAR(16) NOT NULL COMMENT &#39;学号&#39;, `stunm` VARCHAR(20) NOT NULL COMMENT &#39;学生姓名&#39;, PRIMARY KEY (`stuid`) ) COLLATE=&#39;utf8_general_ci&#39; ENGINE=InnoDB; 课程表
课程编号、课程名
CREATE TABLE `courses` ( `courseno` VARCHAR(20) NOT NULL, `coursenm` VARCHAR(100) NOT NULL, PRIMARY KEY (`courseno`) ) COMMENT=&#39;课程表&#39; COLLATE=&#39;utf8_general_ci&#39; ENGINE=InnoDB; 成绩表
学生学号、课程号、成绩
CREATE TABLE `score` ( `stuid` VARCHAR(16) NOT NULL, `courseno` VARCHAR(20) NOT NULL, `scores` FLOAT NULL DEFAULT NULL, PRIMARY KEY (`stuid`, `courseno`) ) COLLATE=&#39;utf8_general_ci&#39; ENGINE=InnoDB; 以上就是数据库表的结构了，这里没有建立外键，但是根据表的结构，可以清楚的看到成绩表中的学号和课程号是与学生表、课程表分别关联起来的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8a951a8653cd2589fd1a66c0688d3ee4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-01-15T21:54:50+08:00" />
<meta property="article:modified_time" content="2016-01-15T21:54:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL存储过程的动态行转列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article fmt article__content"> 
 <h3>MySQL存储过程中使用动态行转列</h3> 
 <p>最近做项目关于数据报表处理，然而数据库存储格式和报表展现形式不同，需要进行一下行转列的操作，在做上一个项目的时候也看了一下，但是后来换了读取方式，也就没深入研究这个问题了。</p> 
 <p>而这一次必须要直面这个问题了，奈何我是那么的不想看，可项目不能因为这个问题卡在这，只好好好找资料看如何解决这个问题。</p> 
 <p>开始也在网上找到一些MySQL行转列的例子，但大部分都是静态的，要么就是不知所云，说的不是很清楚。后来就找到国外的一个资料，参考了之后对照自己项目的数据库，然后便成功的实现了动态行转列。下面我以一个简单的数据库为例子，说明一下。</p> 
 <h3>数据表结构</h3> 
 <p>这里我用一个比较简单的例子来说明，也是行转列的经典例子，就是学生的成绩<br>三张表：学生表、课程表、成绩表</p> 
 <ul><li><p>学生表</p></li></ul> 
 <p>就简单一点，学生学号、学生姓名两个字段</p> 
 <pre><code>CREATE TABLE `student` (
    `stuid` VARCHAR(16) NOT NULL COMMENT '学号',
    `stunm` VARCHAR(20) NOT NULL COMMENT '学生姓名',
    PRIMARY KEY (`stuid`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;</code></pre> 
 <ul><li><p>课程表</p></li></ul> 
 <p>课程编号、课程名</p> 
 <pre><code>CREATE TABLE `courses` (
    `courseno` VARCHAR(20) NOT NULL,
    `coursenm` VARCHAR(100) NOT NULL,
    PRIMARY KEY (`courseno`)
)
COMMENT='课程表'
COLLATE='utf8_general_ci'
ENGINE=InnoDB;</code></pre> 
 <ul><li><p>成绩表</p></li></ul> 
 <p>学生学号、课程号、成绩</p> 
 <pre><code>CREATE TABLE `score` (
    `stuid` VARCHAR(16) NOT NULL,
    `courseno` VARCHAR(20) NOT NULL,
    `scores` FLOAT NULL DEFAULT NULL,
    PRIMARY KEY (`stuid`, `courseno`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;</code></pre> 
 <p>以上就是数据库表的结构了，这里没有建立外键，但是根据表的结构，可以清楚的看到成绩表中的学号和课程号是与学生表、课程表分别关联起来的。</p> 
 <h3>数据准备</h3> 
 <pre><code>/*学生表数据*/
Insert Into student (stuid, stunm) Values('1001', '张三');
Insert Into student (stuid, stunm) Values('1002', '李四');
Insert Into student (stuid, stunm) Values('1003', '赵二');
Insert Into student (stuid, stunm) Values('1004', '王五');
Insert Into student (stuid, stunm) Values('1005', '刘青');
Insert Into student (stuid, stunm) Values('1006', '周明');</code></pre> 
 <pre><code>/*课程表数据*/
Insert Into courses (courseno, coursenm) Values('C001', '大学语文');
Insert Into courses (courseno, coursenm) Values('C002', '新视野英语');
Insert Into courses (courseno, coursenm) Values('C003', '离散数学');
Insert Into courses (courseno, coursenm) Values('C004', '概率论与数理统计');
Insert Into courses (courseno, coursenm) Values('C005', '线性代数');
Insert Into courses (courseno, coursenm) Values('C006', '高等数学(一)');
Insert Into courses (courseno, coursenm) Values('C007', '高等数学(二)');</code></pre> 
 <pre><code>/*成绩表数据*/
Insert Into score(stuid, courseno, scores) Values('1001', 'C001', 67);
Insert Into score(stuid, courseno, scores) Values('1002', 'C001', 68);
Insert Into score(stuid, courseno, scores) Values('1003', 'C001', 69);
Insert Into score(stuid, courseno, scores) Values('1004', 'C001', 70);
Insert Into score(stuid, courseno, scores) Values('1005', 'C001', 71);
Insert Into score(stuid, courseno, scores) Values('1006', 'C001', 72);
Insert Into score(stuid, courseno, scores) Values('1001', 'C002', 87);
Insert Into score(stuid, courseno, scores) Values('1002', 'C002', 88);
Insert Into score(stuid, courseno, scores) Values('1003', 'C002', 89);
Insert Into score(stuid, courseno, scores) Values('1004', 'C002', 90);
Insert Into score(stuid, courseno, scores) Values('1005', 'C002', 91);
Insert Into score(stuid, courseno, scores) Values('1006', 'C002', 92);
Insert Into score(stuid, courseno, scores) Values('1001', 'C003', 83);
Insert Into score(stuid, courseno, scores) Values('1002', 'C003', 84);
Insert Into score(stuid, courseno, scores) Values('1003', 'C003', 85);
Insert Into score(stuid, courseno, scores) Values('1004', 'C003', 86);
Insert Into score(stuid, courseno, scores) Values('1005', 'C003', 87);
Insert Into score(stuid, courseno, scores) Values('1006', 'C003', 88);
Insert Into score(stuid, courseno, scores) Values('1001', 'C004', 88);
Insert Into score(stuid, courseno, scores) Values('1002', 'C004', 89);
Insert Into score(stuid, courseno, scores) Values('1003', 'C004', 90);
Insert Into score(stuid, courseno, scores) Values('1004', 'C004', 91);
Insert Into score(stuid, courseno, scores) Values('1005', 'C004', 92);
Insert Into score(stuid, courseno, scores) Values('1006', 'C004', 93);
Insert Into score(stuid, courseno, scores) Values('1001', 'C005', 77);
Insert Into score(stuid, courseno, scores) Values('1002', 'C005', 78);
Insert Into score(stuid, courseno, scores) Values('1003', 'C005', 79);
Insert Into score(stuid, courseno, scores) Values('1004', 'C005', 80);
Insert Into score(stuid, courseno, scores) Values('1005', 'C005', 81);
Insert Into score(stuid, courseno, scores) Values('1006', 'C005', 82);
Insert Into score(stuid, courseno, scores) Values('1001', 'C006', 77);
Insert Into score(stuid, courseno, scores) Values('1002', 'C006', 78);
Insert Into score(stuid, courseno, scores) Values('1003', 'C006', 79);
Insert Into score(stuid, courseno, scores) Values('1004', 'C006', 80);
Insert Into score(stuid, courseno, scores) Values('1005', 'C006', 81);
Insert Into score(stuid, courseno, scores) Values('1006', 'C006', 82);</code></pre> 
 <h3>为什么要行转列</h3> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/91/7f/N7PXWipU_o.jpg" alt="正常查询结果" title="正常查询结果"></span></p> 
 <p>这是我们进行成绩查询的时候看到的这种纵列的结果，但是一般的时候，我们想要看到下图这种结果</p> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/27/f2/r9ehnAem_o.jpg" alt="想要的结果" title="想要的结果"></span></p> 
 <p>那么需要这样的结果就要进行行转列来操作了。</p> 
 <h3>怎么行转列</h3> 
 <p>像得到上图的结果，一般的行转列，我们只需要这么做</p> 
 <h3>静态行转列</h3> 
 <pre><code>Select st.stuid, st.stunm, 
    MAX(CASE c.coursenm WHEN '大学语文' THEN s.scores ELSE 0 END ) '大学语文',
    MAX(CASE c.coursenm WHEN '新视野英语' THEN ifnull(s.scores,0) ELSE 0 END ) '新视野英语', 
    MAX(CASE c.coursenm WHEN '离散数学' THEN ifnull(s.scores,0) ELSE 0 END ) '离散数学',
    MAX(CASE c.coursenm WHEN '概率论与数理统计' THEN ifnull(s.scores,0) ELSE 0 END ) '概率论与数理统计',
    MAX(CASE c.coursenm WHEN '线性代数' THEN ifnull(s.scores,0) ELSE 0 END ) '线性代数',
    MAX(CASE c.coursenm WHEN '高等数学(一)' THEN ifnull(s.scores,0) ELSE 0 END ) '高等数学(一)',
    MAX(CASE c.coursenm WHEN '高等数学(二)' THEN ifnull(s.scores,0) ELSE 0 END ) '高等数学(二)'
From Student  st
Left Join score s On st.stuid = s.stuid
Left Join courses c On c.courseno = s.courseno
Group by st.stuid</code></pre> 
 <p>看上面的语句可以看出，我们是在知道固定的几门课程之后，可以使用</p> 
 <pre><code>MAX(CASE c.coursenm WHEN '线性代数' THEN ifnull(s.scores,0) ELSE 0 END ) '线性代数',</code></pre> 
 <p>这样的语句来实现行转列</p> 
 <p>但我们都知道，课程不仅仅这几门，如果用上面的语句去写，第一要确定有多少课程，这么多课程的课程名要再拿出来，那样的话写一个查询语句下来，可是要写很多了。那么就想能不能动态进行行转列的操作？答案当然是肯定的了！</p> 
 <h3>动态行转列</h3> 
 <p>那么如何进行动态行转列呢？</p> 
 <p>首先我们要动态获取这样的语句</p> 
 <pre><code>MAX(CASE c.coursenm WHEN '大学语文' THEN s.scores ELSE 0 END ) '大学语文',
MAX(CASE c.coursenm WHEN '线性代数' THEN ifnull(s.scores,0) ELSE 0 END ) '线性代数', 
MAX(CASE c.coursenm WHEN '离散数学' THEN ifnull(s.scores,0) ELSE 0 END ) '离散数学'</code></pre> 
 <p>而不是像上面那样一句句写出来，那如何得到这样的语句呢？</p> 
 <p>这里就要用到SQL语句拼接了。具体就是下面的语句</p> 
 <pre><code>SELECT
  GROUP_CONCAT(DISTINCT
    CONCAT(
      'MAX(IF(c.coursenm = ''',
      c.coursenm,
      ''', s.scores, 0)) AS ''',
      c.coursenm, ''''
    )
  )
FROM courses c;</code></pre> 
 <p>得到的结果就是</p> 
 <pre><code>MAX(IF(c.coursenm = '大学语文', s.scores, 0)) AS '大学语文',
MAX(IF(c.coursenm = '新视野英语', s.scores, 0)) AS '新视野英语',
MAX(IF(c.coursenm = '离散数学', s.scores, 0)) AS '离散数学',
MAX(IF(c.coursenm = '概率论与数理统计', s.scores, 0)) AS '概率论与数理统计',
MAX(IF(c.coursenm = '线性代数', s.scores, 0)) AS '线性代数',
MAX(IF(c.coursenm = '高等数学(一)', s.scores, 0)) AS '高等数学(一)',
MAX(IF(c.coursenm = '高等数学(二)', s.scores, 0)) AS '高等数学(二)'</code></pre> 
 <p>对，没错，就是我们上面进行行转列查询要用的语句，那样就不用知道多少课程和这些课程的名字，只要这样几行代码便可以得到动态的列了。</p> 
 <p>动态的列是拿到了，那如何再结合SQL语句进行查询得到结果呢？<br>这里要说明一点，因为用到了拼接函数，如果像上面的查询语句，只是把那几行语句替换掉，也就是下面这样</p> 
 <pre><code>Select st.stuid, st.stunm, 
(
    SELECT
      GROUP_CONCAT(DISTINCT
        CONCAT(
          'MAX(IF(c.coursenm = ''',
          c.coursenm,
          ''', s.scores, NULL)) AS ',
          c.coursenm
        )
      )
    FROM courses c
)
From Student  st
Left Join score s On st.stuid = s.stuid
Left Join courses c On c.courseno = s.courseno
Group by st.stuid;</code></pre> 
 <p>然而得到的结果却是这样的</p> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/f6/2e/IdwNLbJp_o.jpg" alt="拼接语句加入" title="拼接语句加入"></span></p> 
 <p>这里我就不多做赘述了，想必大家也明白。那么既然这样不行，那该怎么做呢？</p> 
 <p>没错，这里就要像普通的那些语句那样，进行声明，将语句拼接完整之后，再执行，也就是下面这样</p> 
 <pre><code>SET @sql = NULL;
SELECT
  GROUP_CONCAT(DISTINCT
    CONCAT(
      'MAX(IF(c.coursenm = ''',
      c.coursenm,
      ''', s.scores, 0)) AS ''',
      c.coursenm, ''''
    )
  ) INTO @sql
FROM courses c;

SET @sql = CONCAT('Select st.stuid, st.stunm, ', @sql, 
                        ' From Student  st 
                        Left Join score s On st.stuid = s.stuid
                        Left Join courses c On c.courseno = s.courseno
                        Group by st.stuid');
PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;</code></pre> 
 <p>直接执行这些语句，得到如下结果。</p> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/e5/5b/U8qyiuRw_o.jpg" alt="拼接语句行转列结果" title="拼接语句行转列结果"></span></p> 
 <p>没错，和开始的时候那种全部拼出来的语句一样，这样就实现了动态行转列的目的了。而且我们不用知道多少课程，也无需把这些课程名一一列出来。</p> 
 <p>当然这个语句拼接中的查询可以加入条件查询，比如我们要查询学号是1003的成绩<br>也就是下面这样</p> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/b3/18/bbgczLaD_o.jpg" alt="学号1003的成绩" title="学号1003的成绩"></span></p> 
 <p>语句则如下</p> 
 <pre><code>SET @sql = NULL;
SET @stuid = '1003';
SELECT
  GROUP_CONCAT(DISTINCT
    CONCAT(
      'MAX(IF(c.coursenm = ''',
      c.coursenm,
      ''', s.scores, 0)) AS ''',
      c.coursenm, ''''
    )
  ) INTO @sql
FROM courses c;

SET @sql = CONCAT('Select st.stuid, st.stunm, ', @sql, 
                        ' From Student  st 
                        Left Join score s On st.stuid = s.stuid
                        Left Join courses c On c.courseno = s.courseno
                        Where st.stuid = ''', @stuid, '''
                        Group by st.stuid');
PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;</code></pre> 
 <p>对比前面的语句，我们可以看到在第二行的Left join后面我改了一些，还有就是前面的变量加了一个@stuid [ 注：这里的 @ 符号是在SQL语句定义变量习惯用法，我个人理解应该是用来区分吧！]</p> 
 <p>那么问题来了，行转列的查询已经实现了，怎么标题中还写着存储过程？对，没错，就是存储过程！</p> 
 <p>像上面的语句，我们如果直接在MySQL中操作是没问题的，但如果用到项目中，那么这个语句显然我们没法用，而且我这次做的项目是结合使用MyBatis，大家都知道在MyBatis中的XML文件中可以自己写SQL语句，但是这样的很显然我们没法放到XML文件中。</p> 
 <p>而且最关键的是，这里不能用 If 条件，好比我们要判断学号是否为空或者等于0再加上条件进行查询，可是这里不支持。<br>没错就是下面这样</p> 
 <pre><code>SET @sql = NULL;
SET @stuid = '1003';
SET @courseno = 'C002';

SELECT
  GROUP_CONCAT(DISTINCT
    CONCAT(
      'MAX(IF(c.coursenm = ''',
      c.coursenm,
      ''', s.scores, 0)) AS ''',
      c.coursenm, ''''
    )
  ) INTO @sql
FROM courses c;

SET @sql = CONCAT('Select st.stuid, st.stunm, ', @sql, 
                        ' From Student  st 
                        Left Join score s On st.stuid = s.stuid
                        Left Join courses c On c.courseno = s.courseno');
                        
IF @stuid is not null and @stuid != 0 then
SET @sql = CONCAT(@sql, ' Where st.stuid = ''', @stuid, '''');
END IF;    

SET @sql = CONCAT(@sql, ' Group by st.stuid');

PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;</code></pre> 
 <p>对，我就是加上 if 之后人家就是不支持，就是这么任性。</p> 
 <p>所以就要用到存储过程啦，而且用存储过程的好处是，方便我们调用，相当于一个函数，其他可能也是类似的查询不需再重复写代码，直接调存储过程就好，还能随心所欲的加上if条件判断，多么美好的事情，哈哈~。</p> 
 <p>那么说到存储过程，这里该如何写呢？<br>创建存储过程的语句我就不多写了，这里呢把上面的查询语句直接放到创建存储过程的begin和end直接就可以了，如下：</p> 
 <pre><code>DELIMITER &amp;&amp;  
drop procedure if exists SP_QueryData;
Create Procedure SP_QueryData(IN stuid varchar(16))
READS SQL DATA 
BEGIN

SET @sql = NULL;
SET @stuid = NULL;
SELECT
  GROUP_CONCAT(DISTINCT
    CONCAT(
      'MAX(IF(c.coursenm = ''',
      c.coursenm,
      ''', s.scores, 0)) AS ''',
      c.coursenm, '\''
    )
  ) INTO @sql
FROM courses c;

SET @sql = CONCAT('Select st.stuid, st.stunm, ', @sql, 
                        ' From Student  st 
                        Left Join score s On st.stuid = s.stuid
                        Left Join courses c On c.courseno = s.courseno');
                        
IF stuid is not null and stuid &lt;&gt; '' then
SET @stuid = stuid;
SET @sql = CONCAT(@sql, ' Where st.stuid = \'', @stuid, '\'');
END IF;    

SET @sql = CONCAT(@sql, ' Group by st.stuid');

PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

END &amp;&amp;  

DELIMITER ;</code></pre> 
 <p>嗯，对比上面简单的SQL语句可以看出，这里使用了 if 语句，对学号进行了判断</p> 
 <p>不过这里要注意一点，这里的if语句不像我们平时java啊那种写法也就是下面</p> 
 <pre><code>if(条件)
{
    要执行的语句块
}</code></pre> 
 <p>对，在SQL里面的if语句不一样，不需要括号啊什么的，就像直接说英文一样</p> 
 <pre><code>IF @stuid is not null and @stuid != 0 then
SET @sql = CONCAT(@sql, ' Where st.stuid = ''', @stuid, '''');
END IF;    </code></pre> 
 <p>嗯，就是这么简单明了，如果条件满足，那么就怎么样，然后结束。</p> 
 <p>然后我们就可以传参数调用这个SP了</p> 
 <pre><code>CALL `SP_QueryData`('1001');</code></pre> 
 <p>得到如下结果<br><span class="img-wrap"><img src="https://images2.imgbox.com/ef/3a/LALOHB5y_o.jpg" alt="使用存储过程查询" title="使用存储过程查询"></span></p> 
 <p>当然我们也可以直接传个空串过去</p> 
 <pre><code>CALL `SP_QueryData`('');</code></pre> 
 <p>同样得到我们想要的结果</p> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/57/79/HZCxii17_o.jpg" alt="存储过程空串查询" title="存储过程空串查询"></span></p> 
 <p>好了，以上就是这次我在MySQL进行动态行转列的实现过程。</p> 
 <h3>总结及问题</h3> 
 <p>开始的时候，只想到要行转列，写着写着突然发现要动态的，因为我不确定到底有多少列。<br>在网上各种找资料，然而看不太懂！</p> 
 <p>后来，参考了<a href="http://stratosprovatopoulos.com/web-development/mysql/pivot-table-with-dynamic-columns/" rel="nofollow">Pivot table with dynamic columns in MySQL</a>这个，才写出来的。</p> 
 <p>然后是各种问题，先是SQL语句中加入if条件，我像平时写java那样，发现并没有什么用，网上也说就是这种</p> 
 <pre><code>IF(stuid is not null &amp;&amp; stuid &lt;&gt; '') then
SET @stuid = stuid;
SET @sql = CONCAT(@sql, ' Where st.stuid = \'', @stuid, '\'');
END IF;    </code></pre> 
 <p>可是我这么写了之后并没有什么用，还是报错，找了不少之后才发现原来不是这么写的，然后改了过来。</p> 
 <p>改完之后我以为可以了，可是，发现依旧不行。然后我就在想是不是这里不能用if判断，因为不是一个function或者procedure，于是我就写创建procedure的语句。</p> 
 <p>改造完之后，procedure成功的创建了。那创建完我就试试能不能，调用procedure之后，当当当当，结果出来了。</p> 
 <p>嗯，这个过程还是收获很多的，对MySQL的行转列，以及存储过程，还有在SQL语句中的使用不一样的地方等。<br>而且，这个行转列的实现了之后，这个项目基本上没啥大问题了对数据的处理，相当好啊，哈哈~</p> 
 <p>以上就是我在行转列实现的过程中所有的内容，相对来说，我觉得，这里写的很清楚很明了了，所以只要你有耐心看完并认真研究的话，这个内容对你的行转列还是有很大裨益的。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/93b0f228d9430d13e3d0d59b55c3beb8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android多用户系列：跨用户启动（绑定）Service、启动Activity、访问ContentProvider</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d2e3db001c4ab7c3efa5b731ed9b88e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql5.7 安装方法 (跟旧的不一样了)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>