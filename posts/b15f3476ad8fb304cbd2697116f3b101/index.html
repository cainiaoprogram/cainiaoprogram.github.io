<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构-树1 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构-树1" />
<meta property="og:description" content="树的基本定义 D：D是具有相同特性的数据元素的集合, hi是di上的二元关系(说明了谁是谁的孩子,谁是谁的父母)
(di,{hi})就是一颗子树；
基本操作 二叉树 基本操作 二叉树的性质 几种特殊的树 二叉树的存储结构 二叉树的顺序存储 缺点就是浪费空间
代码实现 // c6-1.h 二叉树的顺序存储表示 #define MAX_TREE_SIZE 100 // 二叉树的最大结点数 typedef TElemType SqBiTree[MAX_TREE_SIZE]; // 0号单元存储根结点 struct position { int level,order; // 结点的层,本层序号(按满二叉树计算) }; // bo6-1.cpp 二叉树的顺序存储(存储结构由c6-1.h定义)的基本操作(23个) //以数组的形式存储数据,但进行数据的读取操作却是树 Status InitBiTree(SqBiTree T) { // 构造空二叉树T。因为T是固定数组，不会改变，故不需要&amp; int i; for(i=0;i&lt;MAX_TREE_SIZE;i&#43;&#43;) T[i]=Nil; // 初值为空 return OK; } void DestroyBiTree() { // 由于SqBiTree是定长类型,无法销毁 } Status CreateBiTree(SqBiTree T) { // 按层序次序输入二叉树中结点的值(字符型或整型), 构造顺序存储的二叉树T int i=0; #if CHAR int l; char s[MAX_TREE_SIZE]; cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b15f3476ad8fb304cbd2697116f3b101/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-22T10:53:00+08:00" />
<meta property="article:modified_time" content="2022-12-22T10:53:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构-树1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>树的基本定义</h3> 
<p><img alt="" height="892" src="https://images2.imgbox.com/c5/e1/yTMLgDkD_o.png" width="1200"></p> 
<p> D：D是具有相同特性的数据元素的<strong>集合</strong>, hi是di上的<strong>二元关系</strong>(说明了谁是谁的孩子,谁是谁的父母)</p> 
<p>(di,{hi})就是一颗子树；</p> 
<h4>基本操作</h4> 
<p><img alt="" height="646" src="https://images2.imgbox.com/da/cc/nVTr60AX_o.png" width="1096"></p> 
<p> <img alt="" height="749" src="https://images2.imgbox.com/20/78/yTJg1v3Q_o.png" width="1082"></p> 
<h3> 二叉树</h3> 
<p><img alt="" height="913" src="https://images2.imgbox.com/ca/42/H3iSA4JF_o.png" width="1200"></p> 
<p><img alt="" height="785" src="https://images2.imgbox.com/2f/80/VZV0NP6m_o.png" width="1196"> </p> 
<p><img alt="" height="558" src="https://images2.imgbox.com/d9/29/pFoUQ3Ia_o.png" width="1175"> </p> 
<h4>基本操作 </h4> 
<p><img alt="" height="867" src="https://images2.imgbox.com/8d/ab/A7aZn2M1_o.png" width="985"></p> 
<p> <img alt="" height="551" src="https://images2.imgbox.com/0a/4a/xjuaj5CN_o.png" width="1138"></p> 
<h4> 二叉树的性质</h4> 
<p><img alt="" height="804" src="https://images2.imgbox.com/fb/a5/B6Xtgh3r_o.png" width="1151"></p> 
<p> <img alt="" height="694" src="https://images2.imgbox.com/bc/90/OuQmkmbn_o.png" width="1200"></p> 
<p> </p> 
<h3>几种特殊的树</h3> 
<p><img alt="" height="813" src="https://images2.imgbox.com/47/a1/eCxawjMc_o.png" width="1200"></p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/d1/fd/YUXOh3Gf_o.png" width="1072"></p> 
<h3> 二叉树的存储结构</h3> 
<p><img alt="" height="659" src="https://images2.imgbox.com/3b/62/gklBYcnn_o.png" width="1165"></p> 
<h3>二叉树的顺序存储</h3> 
<p>  <img alt="" height="849" src="https://images2.imgbox.com/64/12/47WPGemR_o.png" width="1200"></p> 
<p> </p> 
<p> 缺点就是浪费空间</p> 
<p> <img alt="" height="833" src="https://images2.imgbox.com/4b/63/ThkTiZoK_o.png" width="1190"></p> 
<p> </p> 
<h4>代码实现</h4> 
<pre><code class="hljs"> // c6-1.h 二叉树的顺序存储表示
 #define MAX_TREE_SIZE 100 // 二叉树的最大结点数
 typedef TElemType SqBiTree[MAX_TREE_SIZE]; // 0号单元存储根结点

 struct position
 {
   int level,order; // 结点的层,本层序号(按满二叉树计算)
 };
</code></pre> 
<pre><code class="hljs"> // bo6-1.cpp 二叉树的顺序存储(存储结构由c6-1.h定义)的基本操作(23个)
//以数组的形式存储数据,但进行数据的读取操作却是树
 Status InitBiTree(SqBiTree T)
 { // 构造空二叉树T。因为T是固定数组，不会改变，故不需要&amp;
   int i;
   for(i=0;i&lt;MAX_TREE_SIZE;i++)
     T[i]=Nil; // 初值为空
   return OK;
 }

 void DestroyBiTree()
 { // 由于SqBiTree是定长类型,无法销毁
 }

 Status CreateBiTree(SqBiTree T)
 { // 按层序次序输入二叉树中结点的值(字符型或整型), 构造顺序存储的二叉树T
   int i=0;
 #if CHAR
   int l;
   char s[MAX_TREE_SIZE];
   cout&lt;&lt;"请按层序输入结点的值(字符)，空格表示空结点，结点数≤"&lt;&lt;MAX_TREE_SIZE&lt;&lt;':'&lt;&lt;endl;
   gets(s); // 输入字符串
   l=strlen(s); // 求字符串的长度
   for(;i&lt;l;i++) // 将字符串赋值给T
   {
     T[i]=s[i];
     if(i!=0&amp;&amp;T[(i+1)/2-1]==Nil&amp;&amp;T[i]!=Nil) // 此结点(不空)无双亲且不是根
     {
       cout&lt;&lt;"出现无双亲的非根结点"&lt;&lt;T[i]&lt;&lt;endl;
       exit(ERROR);
     }
   }
   for(i=l;i&lt;MAX_TREE_SIZE;i++) // 将空赋值给T的后面的结点
     T[i]=Nil;
 #else
   cout&lt;&lt;"请按层序输入结点的值(整型)，0表示空结点，输999结束。结点数≤"&lt;&lt;MAX_TREE_SIZE&lt;&lt;':'&lt;&lt;endl;
   while(1)
   {
     cin&gt;&gt;T[i];
     if(T[i]==999)
       break;
     if(i!=0&amp;&amp;T[(i+1)/2-1]==Nil&amp;&amp;T[i]!=Nil) // 此结点(不空)无双亲且不是根
     {
       cout&lt;&lt;"出现无双亲的非根结点"&lt;&lt;T[i]&lt;&lt;endl;
       exit(ERROR);
     }
     i++;
   }
   while(i&lt;MAX_TREE_SIZE)
   {
     T[i]=Nil; // 将空赋值给T的后面的结点
     i++;
   }
 #endif
   return OK;
 }

 #define ClearBiTree InitBiTree // 在顺序存储结构中，两函数完全一样

 Status BiTreeEmpty(SqBiTree T)
 { // 初始条件: 二叉树T存在
   // 操作结果: 若T为空二叉树,则返回TRUE,否则FALSE
   if(T[0]==Nil) // 根结点为空,则树空
     return TRUE;
   else
     return FALSE;
 }

 int BiTreeDepth(SqBiTree T)
 { // 初始条件: 二叉树T存在。操作结果: 返回T的深度
   int i,j=-1;
   for(i=MAX_TREE_SIZE-1;i&gt;=0;i--) // 找到最后一个结点
     if(T[i]!=Nil)
       break;
   i++; // 为了便于计算
   do
     j++;
   while(i&gt;=pow(2,j));
   return j;
 }

 Status Root(SqBiTree T,TElemType &amp;e)
 { // 初始条件: 二叉树T存在
   // 操作结果:  当T不空,用e返回T的根,返回OK;否则返回ERROR,e无定义
   if(BiTreeEmpty(T)) // T空
     return ERROR;
   else
   {
     e=T[0];
     return OK;
   }
 }

 TElemType Value(SqBiTree T,position e)
 { // 初始条件: 二叉树T存在,e是T中某个结点(的位置)
   // 操作结果: 返回处于位置e(层,本层序号)的结点的值
   return T[int(pow(2,e.level-1)+e.order-2)];
 }

 Status Assign(SqBiTree T,position e,TElemType value)
 { // 初始条件: 二叉树T存在,e是T中某个结点(的位置)
   // 操作结果: 给处于位置e(层,本层序号)的结点赋新值value
   int i=int(pow(2,e.level-1)+e.order-2); // 将层、本层序号转为矩阵的序号
   if(value!=Nil&amp;&amp;T[(i+1)/2-1]==Nil) // 给叶子赋非空值但双亲为空
     return ERROR;
   else if(value==Nil&amp;&amp;(T[i*2+1]!=Nil||T[i*2+2]!=Nil)) //  给双亲赋空值但有叶子（不空）
     return ERROR;
   T[i]=value;
   return OK;
 }

 TElemType Parent(SqBiTree T,TElemType e)
 { // 初始条件: 二叉树T存在,e是T中某个结点
   // 操作结果: 若e是T的非根结点,则返回它的双亲,否则返回＂空＂
   int i;
   if(T[0]==Nil) // 空树
     return Nil;
   for(i=1;i&lt;=MAX_TREE_SIZE-1;i++)
     if(T[i]==e) // 找到e
       return T[(i+1)/2-1];
   return Nil; // 没找到e
 }

 TElemType LeftChild(SqBiTree T,TElemType e)
 { // 初始条件: 二叉树T存在,e是T中某个结点
   // 操作结果: 返回e的左孩子。若e无左孩子,则返回＂空＂
   int i;
   if(T[0]==Nil) // 空树
     return Nil;
   for(i=0;i&lt;=MAX_TREE_SIZE-1;i++)
     if(T[i]==e) // 找到e
       return T[i*2+1];
   return Nil; // 没找到e
 }

 TElemType RightChild(SqBiTree T,TElemType e)
 { // 初始条件: 二叉树T存在,e是T中某个结点
   // 操作结果: 返回e的右孩子。若e无右孩子,则返回＂空＂
   int i;
   if(T[0]==Nil) // 空树
     return Nil;
   for(i=0;i&lt;=MAX_TREE_SIZE-1;i++)
     if(T[i]==e) // 找到e
       return T[i*2+2];
   return Nil; // 没找到e
 }

 TElemType LeftSibling(SqBiTree T,TElemType e)
 { // 初始条件: 二叉树T存在,e是T中某个结点
   // 操作结果: 返回e的左兄弟。若e是T的左孩子或无左兄弟,则返回＂空＂
   int i;
   if(T[0]==Nil) // 空树
     return Nil;
   for(i=1;i&lt;=MAX_TREE_SIZE-1;i++)
     if(T[i]==e&amp;&amp;i%2==0) // 找到e且其序号为偶数(是右孩子)
       return T[i-1];
   return Nil; // 没找到e
 }

 TElemType RightSibling(SqBiTree T,TElemType e)
 { // 初始条件: 二叉树T存在,e是T中某个结点
   // 操作结果: 返回e的右兄弟。若e是T的右孩子或无右兄弟,则返回＂空＂
   int i;
   if(T[0]==Nil) // 空树
     return Nil;
   for(i=1;i&lt;=MAX_TREE_SIZE-1;i++)
     if(T[i]==e&amp;&amp;i%2) // 找到e且其序号为奇数(是左孩子)
       return T[i+1];
   return Nil; // 没找到e
 }

 void Move(SqBiTree q,int j,SqBiTree T,int i) // InsertChild()用到。加
 { // 把从q的j结点开始的子树移为从T的i结点开始的子树
   if(q[2*j+1]!=Nil) // q的左子树不空
     Move(q,(2*j+1),T,(2*i+1)); // 把q的j结点的左子树移为T的i结点的左子树
   if(q[2*j+2]!=Nil) // q的右子树不空
     Move(q,(2*j+2),T,(2*i+2)); // 把q的j结点的右子树移为T的i结点的右子树
   T[i]=q[j]; // 把q的j结点移为T的i结点
   q[j]=Nil; // 把q的j结点置空
 }

 Status InsertChild(SqBiTree T,TElemType p,Status LR,SqBiTree c)
 { // 初始条件: 二叉树T存在,p是T中某个结点的值,LR为0或1,非空二叉树c与T
   //           不相交且右子树为空
   // 操作结果: 根据LR为0或1,插入c为T中p结点的左或右子树。p结点的原有左或
   //           右子树则成为c的右子树
   int j,k,i=0;
   for(j=0;j&lt;int(pow(2,BiTreeDepth(T)))-1;j++) // 查找p的序号
     if(T[j]==p) // j为p的序号
       break;
   k=2*j+1+LR; // k为p的左或右孩子的序号
   if(T[k]!=Nil) // p原来的左或右孩子不空
     Move(T,k,T,2*k+2); // 把从T的k结点开始的子树移为从k结点的右子树开始的子树
   Move(c,i,T,k); // 把从c的i结点开始的子树移为从T的k结点开始的子树
   return OK;
 }

 typedef int QElemType; // 设队列元素类型为整型(序号)
 #include "c3-3.h" // 顺序非循环队列
 #include "bo3-4.cpp" // 顺序非循环队列的基本操作
 Status DeleteChild(SqBiTree T,position p,int LR)
 { // 初始条件: 二叉树T存在,p指向T中某个结点,LR为1或0
   // 操作结果: 根据LR为1或0,删除T中p所指结点的左或右子树
   int i;
   Status k=OK; // 队列不空的标志
   SqQueue q;
   InitQueue(q); // 初始化队列，用于存放待删除的结点
   i=(int)pow(2,p.level-1)+p.order-2; // 将层、本层序号转为矩阵的序号
   if(T[i]==Nil) // 此结点空
     return ERROR;
   i=i*2+1+LR; // 待删除子树的根结点在矩阵中的序号
   while(k)
   {
     if(T[2*i+1]!=Nil) // 左结点不空
       EnQueue(q,2*i+1); // 入队左结点的序号
     if(T[2*i+2]!=Nil) // 右结点不空
       EnQueue(q,2*i+2); // 入队右结点的序号
     T[i]=Nil; // 删除此结点
     k=DeQueue(q,i); // 队列不空
   }
   return OK;
 }

 Status(*VisitFunc)(TElemType); // 函数变量
 void PreTraverse(SqBiTree T,int e)
 { // PreOrderTraverse()调用
   VisitFunc(T[e]);
   if(T[2*e+1]!=Nil) // 左子树不空
     PreTraverse(T,2*e+1);
   if(T[2*e+2]!=Nil) // 右子树不空
     PreTraverse(T,2*e+2);
 }

 Status PreOrderTraverse(SqBiTree T,Status(*Visit)(TElemType))
 { // 初始条件: 二叉树存在,Visit是对结点操作的应用函数
   // 操作结果: 先序遍历T,对每个结点调用函数Visit一次且仅一次。
   //           一旦Visit()失败,则操作失败
   VisitFunc=Visit;
   if(!BiTreeEmpty(T)) // 树不空
     PreTraverse(T,0);
   cout&lt;&lt;endl;
   return OK;
 }

 void InTraverse(SqBiTree T,int e)
 { // InOrderTraverse()调用
   if(T[2*e+1]!=Nil) // 左子树不空
     InTraverse(T,2*e+1);
   VisitFunc(T[e]);
   if(T[2*e+2]!=Nil) // 右子树不空
     InTraverse(T,2*e+2);
 }

 Status InOrderTraverse(SqBiTree T,Status(*Visit)(TElemType))
 { // 初始条件: 二叉树存在,Visit是对结点操作的应用函数
   // 操作结果: 中序遍历T,对每个结点调用函数Visit一次且仅一次。
   //           一旦Visit()失败,则操作失败
   VisitFunc=Visit;
   if(!BiTreeEmpty(T)) // 树不空
     InTraverse(T,0);
   cout&lt;&lt;endl;
   return OK;
 }

 void PostTraverse(SqBiTree T,int e)
 { // PostOrderTraverse()调用
   if(T[2*e+1]!=Nil) // 左子树不空
     PostTraverse(T,2*e+1);
   if(T[2*e+2]!=Nil) // 右子树不空
     PostTraverse(T,2*e+2);
   VisitFunc(T[e]);
 }

 Status PostOrderTraverse(SqBiTree T,Status(*Visit)(TElemType))
 { // 初始条件: 二叉树T存在,Visit是对结点操作的应用函数
   // 操作结果: 后序遍历T,对每个结点调用函数Visit一次且仅一次。
   //           一旦Visit()失败,则操作失败
   VisitFunc=Visit;
   if(!BiTreeEmpty(T)) // 树不空
     PostTraverse(T,0);
   cout&lt;&lt;endl;
   return OK;
 }

 void LevelOrderTraverse(SqBiTree T,Status(*Visit)(TElemType))
 { // 层序遍历二叉树
   int i=MAX_TREE_SIZE-1,j;
   while(T[i]==Nil)
     i--; // 找到最后一个非空结点的序号
   for(j=0;j&lt;=i;j++)  // 从根结点起,按层序遍历二叉树
     if(T[j]!=Nil)
       Visit(T[j]); // 只遍历非空的结点
   cout&lt;&lt;endl;
 }

 void Print(SqBiTree T)
 { // 逐层、按本层序号输出二叉树
   int j,k;
   position p;
   TElemType e;
   for(j=1;j&lt;=BiTreeDepth(T);j++)
   {
     cout&lt;&lt;"第"&lt;&lt;j&lt;&lt;"层: ";
     for(k=1;k&lt;=pow(2,j-1);k++)
     {
       p.level=j;
       p.order=k;
       e=Value(T,p);
       if(e!=Nil)
         cout&lt;&lt;k&lt;&lt;':'&lt;&lt;e&lt;&lt;' ';
     }
     cout&lt;&lt;endl;
   }
 }
</code></pre> 
<p>检测代码</p> 
<pre><code class="hljs"> // main6-1.cpp 检验bo6-1.cpp的主程序，利用条件编译选择数据类型为char或int
 //#define CHAR 1 // 字符型
 #define CHAR 0 // 整型(二者选一)
 #include"c1.h"
 #if CHAR
   typedef char TElemType;
   TElemType Nil=' '; // 设字符型以空格符为空
 #else
   typedef int TElemType;
   TElemType Nil=0; // 设整型以0为空
 #endif
 #include"c6-1.h"
 #include"bo6-1.cpp"

 Status visit(TElemType e)
 {
   cout&lt;&lt;e&lt;&lt;' ';
   return OK;
 }

 void main()
 {
   Status i;
   int j;
   position p;
   TElemType e;
   SqBiTree T,s;
   InitBiTree(T);
   CreateBiTree(T);
   cout&lt;&lt;"建立二叉树后,树空否？"&lt;&lt;BiTreeEmpty(T)&lt;&lt;"(1:是 0:否) 树的深度="&lt;&lt;BiTreeDepth(T)&lt;&lt;endl;
   i=Root(T,e);
   if(i)
     cout&lt;&lt;"二叉树的根为："&lt;&lt;e&lt;&lt;endl;
   else
     cout&lt;&lt;"树空，无根"&lt;&lt;endl;
   cout&lt;&lt;"层序遍历二叉树:"&lt;&lt;endl;
   LevelOrderTraverse(T,visit);
   cout&lt;&lt;"中序遍历二叉树:"&lt;&lt;endl;
   InOrderTraverse(T,visit);
   cout&lt;&lt;"后序遍历二叉树:"&lt;&lt;endl;
   PostOrderTraverse(T,visit);
   cout&lt;&lt;"请输入待修改结点的层号 本层序号: ";
   cin&gt;&gt;p.level&gt;&gt;p.order;
   e=Value(T,p);
   cout&lt;&lt;"待修改结点的原值为"&lt;&lt;e&lt;&lt;"请输入新值: ";
   cin&gt;&gt;e;
   Assign(T,p,e);
   cout&lt;&lt;"先序遍历二叉树:"&lt;&lt;endl;
   PreOrderTraverse(T,visit);
   cout&lt;&lt;"结点"&lt;&lt;e&lt;&lt;"的双亲为"&lt;&lt;Parent(T,e)&lt;&lt;",左右孩子分别为";
   cout&lt;&lt;LeftChild(T,e)&lt;&lt;","&lt;&lt;RightChild(T,e)&lt;&lt;",左右兄弟分别为";
   cout&lt;&lt;LeftSibling(T,e)&lt;&lt;","&lt;&lt;RightSibling(T,e)&lt;&lt;endl;
   InitBiTree(s);
   cout&lt;&lt;"建立右子树为空的树s:"&lt;&lt;endl;
   CreateBiTree(s);
   cout&lt;&lt;"树s插到树T中,请输入树T中树s的双亲结点 s为左(0)或右(1)子树: ";
   cin&gt;&gt;e&gt;&gt;j;
   InsertChild(T,e,j,s);
   Print(T);
   cout&lt;&lt;"删除子树,请输入待删除子树根结点的层号 本层序号 左(0)或右(1)子树: ";
   cin&gt;&gt;p.level&gt;&gt;p.order&gt;&gt;j;
   DeleteChild(T,p,j);
   Print(T);
   ClearBiTree(T);
   cout&lt;&lt;"清除二叉树后,树空否？"&lt;&lt;BiTreeEmpty(T)&lt;&lt;"(1:是 0:否) 树的深度="&lt;&lt;BiTreeDepth(T)&lt;&lt;endl;
   i=Root(T,e);
   if(i)
     cout&lt;&lt;"二叉树的根为："&lt;&lt;e&lt;&lt;endl;
   else
     cout&lt;&lt;"树空，无根"&lt;&lt;endl;
 }</code></pre> 
<h3>二叉树的链式存储 </h3> 
<p><img alt="" height="749" src="https://images2.imgbox.com/42/bb/WUkb1hf5_o.png" width="1200"></p> 
<p><strong>基本操作的代码</strong></p> 
<pre><code class="hljs"> // c6-2.h 二叉树的二叉链表存储表示
 typedef struct BiTNode
 {
   TElemType data;
   BiTNode *lchild,*rchild; // 左右孩子指针
 }BiTNode,*BiTree;
</code></pre> 
<pre><code class="hljs"> // bo6-2.cpp 二叉树的二叉链表存储(存储结构由c6-2.h定义)的基本操作(22个)
 Status InitBiTree(BiTree &amp;T)
 { // 操作结果: 构造空二叉树T
   T=NULL;
   return OK;
 }

 void DestroyBiTree(BiTree &amp;T)
 { // 初始条件: 二叉树T存在。操作结果: 销毁二叉树T
   if(T) // 非空树
   {
     if(T-&gt;lchild) // 有左孩子
       DestroyBiTree(T-&gt;lchild); // 销毁左孩子子树
     if(T-&gt;rchild) // 有右孩子
       DestroyBiTree(T-&gt;rchild); // 销毁右孩子子树
     free(T); // 释放根结点
     T=NULL; // 空指针赋0
   }
 }

 void CreateBiTree(BiTree &amp;T)
 { // 算法6.4:按先序次序输入二叉树中结点的值（可为字符型或整型，在主程中
   // 定义），构造二叉链表表示的二叉树T。变量Nil表示空（子）树。有改动
   TElemType ch;
 #ifdef CHAR
   scanf("%c",&amp;ch);
 #endif
 #ifdef INT
   scanf("%d",&amp;ch);
 #endif
   if(ch==Nil) // 空
     T=NULL;
   else
   {
     T=(BiTree)malloc(sizeof(BiTNode));
     if(!T)
       exit(OVERFLOW);
     T-&gt;data=ch; // 生成根结点
     CreateBiTree(T-&gt;lchild); // 构造左子树
     CreateBiTree(T-&gt;rchild); // 构造右子树
   }
 }

 Status BiTreeEmpty(BiTree T)
 { // 初始条件: 二叉树T存在
   // 操作结果: 若T为空二叉树,则返回TRUE,否则FALSE
   if(T)
     return FALSE;
   else
     return TRUE;
 }

 #define ClearBiTree DestroyBiTree

 int BiTreeDepth(BiTree T)
 { // 初始条件: 二叉树T存在。操作结果: 返回T的深度
   int i,j;
   if(!T)
     return 0;
   if(T-&gt;lchild)
     i=BiTreeDepth(T-&gt;lchild);
   else
     i=0;
   if(T-&gt;rchild)
     j=BiTreeDepth(T-&gt;rchild);
   else
     j=0;
   return i&gt;j?i+1:j+1;
 }

 TElemType Root(BiTree T)
 { // 初始条件: 二叉树T存在。操作结果: 返回T的根
   if(BiTreeEmpty(T))
     return Nil;
   else
     return T-&gt;data;
 }

 TElemType Value(BiTree p)
 { // 初始条件: 二叉树T存在，p指向T中某个结点
   // 操作结果: 返回p所指结点的值
   return p-&gt;data;
 }

 void Assign(BiTree p,TElemType value)
 { // 给p所指结点赋值为value
   p-&gt;data=value;
 }

 typedef BiTree QElemType; // 设队列元素为二叉树的指针类型
 #include"c3-2.h"
 #include"bo3-2.cpp"
 TElemType Parent(BiTree T,TElemType e)
 { // 初始条件: 二叉树T存在,e是T中某个结点
   // 操作结果: 若e是T的非根结点,则返回它的双亲,否则返回＂空＂
   LinkQueue q;
   QElemType a;
   if(T) // 非空树
   {
     InitQueue(q); // 初始化队列
     EnQueue(q,T); // 树根入队
     while(!QueueEmpty(q)) // 队不空
     {
       DeQueue(q,a); // 出队,队列元素赋给a
       if(a-&gt;lchild&amp;&amp;a-&gt;lchild-&gt;data==e||a-&gt;rchild&amp;&amp;a-&gt;rchild-&gt;data==e) // 找到e(是其左或右孩子)
         return a-&gt;data; // 返回e的双亲的值
       else // 没找到e,则入队其左右孩子指针(如果非空)
       {
         if(a-&gt;lchild)
           EnQueue(q,a-&gt;lchild);
         if(a-&gt;rchild)
           EnQueue(q,a-&gt;rchild);
       }
     }
   }
   return Nil; // 树空或没找到e
 }

 BiTree Point(BiTree T,TElemType s)
 { // 返回二叉树T中指向元素值为s的结点的指针。另加
   LinkQueue q;
   QElemType a;
   if(T) // 非空树
   {
     InitQueue(q); // 初始化队列
     EnQueue(q,T); // 根结点入队
     while(!QueueEmpty(q)) // 队不空
     {
       DeQueue(q,a); // 出队,队列元素赋给a
       if(a-&gt;data==s)
         return a;
       if(a-&gt;lchild) // 有左孩子
         EnQueue(q,a-&gt;lchild); // 入队左孩子
       if(a-&gt;rchild) // 有右孩子
         EnQueue(q,a-&gt;rchild); // 入队右孩子
     }
   }
   return NULL;
 }

 TElemType LeftChild(BiTree T,TElemType e)
 { // 初始条件: 二叉树T存在,e是T中某个结点
   // 操作结果: 返回e的左孩子。若e无左孩子,则返回＂空＂
   BiTree a;
   if(T) // 非空树
   {
     a=Point(T,e); // a是结点e的指针
     if(a&amp;&amp;a-&gt;lchild) // T中存在结点e且e存在左孩子
       return a-&gt;lchild-&gt;data; // 返回e的左孩子的值
   }
   return Nil; // 其余情况返回空
 }

 TElemType RightChild(BiTree T,TElemType e)
 { // 初始条件: 二叉树T存在,e是T中某个结点
   // 操作结果: 返回e的右孩子。若e无右孩子,则返回＂空＂
   BiTree a;
   if(T) // 非空树
   {
     a=Point(T,e); // a是结点e的指针
     if(a&amp;&amp;a-&gt;rchild) // T中存在结点e且e存在右孩子
       return a-&gt;rchild-&gt;data; // 返回e的右孩子的值
   }
   return Nil; // 其余情况返回空
 }

 TElemType LeftSibling(BiTree T,TElemType e)
 { // 初始条件: 二叉树T存在,e是T中某个结点
   // 操作结果: 返回e的左兄弟。若e是T的左孩子或无左兄弟,则返回＂空＂
   TElemType a;
   BiTree p;
   if(T) // 非空树
   {
     a=Parent(T,e); // a为e的双亲
     p=Point(T,a); // p为指向结点a的指针
     if(p-&gt;lchild&amp;&amp;p-&gt;rchild&amp;&amp;p-&gt;rchild-&gt;data==e) // p存在左右孩子且右孩子是e
       return p-&gt;lchild-&gt;data; // 返回p的左孩子(e的左兄弟)
   }
   return Nil; // 树空或没找到e的左兄弟
 }

 TElemType RightSibling(BiTree T,TElemType e)
 { // 初始条件: 二叉树T存在,e是T中某个结点
   // 操作结果: 返回e的右兄弟。若e是T的右孩子或无右兄弟,则返回＂空＂
   TElemType a;
   BiTree p;
   if(T) // 非空树
   {
     a=Parent(T,e); // a为e的双亲
     p=Point(T,a); // p为指向结点a的指针
     if(p-&gt;lchild&amp;&amp;p-&gt;rchild&amp;&amp;p-&gt;lchild-&gt;data==e) // p存在左右孩子且左孩子是e
       return p-&gt;rchild-&gt;data; // 返回p的右孩子(e的右兄弟)
   }
   return Nil; // 树空或没找到e的右兄弟
 }

 Status InsertChild(BiTree p,int LR,BiTree c) // 形参T无用
 { // 初始条件: 二叉树T存在,p指向T中某个结点,LR为0或1,非空二叉树c与T
   //           不相交且右子树为空
   // 操作结果: 根据LR为0或1,插入c为T中p所指结点的左或右子树。p所指结点的
   //           原有左或右子树则成为c的右子树
   if(p) // p不空
   {
     if(LR==0)
     {
       c-&gt;rchild=p-&gt;lchild;
       p-&gt;lchild=c;
     }
     else // LR==1
     {
       c-&gt;rchild=p-&gt;rchild;
       p-&gt;rchild=c;
     }
     return OK;
   }
   return ERROR; // p空
 }

 Status DeleteChild(BiTree p,int LR) // 形参T无用
 { // 初始条件: 二叉树T存在,p指向T中某个结点,LR为0或1
   // 操作结果: 根据LR为0或1,删除T中p所指结点的左或右子树
   if(p) // p不空
   {
     if(LR==0) // 删除左子树
       ClearBiTree(p-&gt;lchild);
     else // 删除右子树
       ClearBiTree(p-&gt;rchild);
     return OK;
   }
   return ERROR; // p空
 }

 void PreOrderTraverse(BiTree T,Status(*Visit)(TElemType))
 { // 初始条件: 二叉树T存在,Visit是对结点操作的应用函数。算法6.1，有改动
   // 操作结果: 先序递归遍历T,对每个结点调用函数Visit一次且仅一次
   if(T) // T不空
   {
     Visit(T-&gt;data); // 先访问根结点
     PreOrderTraverse(T-&gt;lchild,Visit); // 再先序遍历左子树
     PreOrderTraverse(T-&gt;rchild,Visit); // 最后先序遍历右子树
   }
 }

 void InOrderTraverse(BiTree T,Status(*Visit)(TElemType))
 { // 初始条件: 二叉树T存在,Visit是对结点操作的应用函数
   // 操作结果: 中序递归遍历T,对每个结点调用函数Visit一次且仅一次
   if(T)
   {
     InOrderTraverse(T-&gt;lchild,Visit); // 先中序遍历左子树
     Visit(T-&gt;data); // 再访问根结点
     InOrderTraverse(T-&gt;rchild,Visit); // 最后中序遍历右子树
   }
 }

 typedef BiTree SElemType; // 设栈元素为二叉树的指针类型
 #include"c3-1.h"
 #include"bo3-1.cpp"
 Status InOrderTraverse1(BiTree T,Status(*Visit)(TElemType))
 { // 采用二叉链表存储结构，Visit是对数据元素操作的应用函数。算法6.3
   // 中序遍历二叉树T的非递归算法(利用栈)，对每个数据元素调用函数Visit
   SqStack S;
   InitStack(S);
   while(T||!StackEmpty(S))
   {
     if(T)
     { // 根指针进栈,遍历左子树
       Push(S,T);
       T=T-&gt;lchild;
     }
     else
     { // 根指针退栈,访问根结点,遍历右子树
       Pop(S,T);
       if(!Visit(T-&gt;data))
         return ERROR;
       T=T-&gt;rchild;
     }
   }
   printf("\n");
   return OK;
 }

 Status InOrderTraverse2(BiTree T,Status(*Visit)(TElemType))
 { // 采用二叉链表存储结构，Visit是对数据元素操作的应用函数。算法6.2
   // 中序遍历二叉树T的非递归算法(利用栈)，对每个数据元素调用函数Visit
   SqStack S;
   BiTree p;
   InitStack(S);
   Push(S,T); // 根指针进栈
   while(!StackEmpty(S))
   {
     while(GetTop(S,p)&amp;&amp;p)
       Push(S,p-&gt;lchild); // 向左走到尽头
     Pop(S,p); // 空指针退栈
     if(!StackEmpty(S))
     { // 访问结点,向右一步
       Pop(S,p);
       if(!Visit(p-&gt;data))
         return ERROR;
       Push(S,p-&gt;rchild);
     }
   }
   printf("\n");
   return OK;
 }

 void PostOrderTraverse(BiTree T,Status(*Visit)(TElemType))
 { // 初始条件: 二叉树T存在,Visit是对结点操作的应用函数
   // 操作结果: 后序递归遍历T,对每个结点调用函数Visit一次且仅一次
   if(T) // T不空
   {
     PostOrderTraverse(T-&gt;lchild,Visit); // 先后序遍历左子树
     PostOrderTraverse(T-&gt;rchild,Visit); // 再后序遍历右子树
     Visit(T-&gt;data); // 最后访问根结点
   }
 }

 void LevelOrderTraverse(BiTree T,Status(*Visit)(TElemType))
 { // 初始条件：二叉树T存在,Visit是对结点操作的应用函数
   // 操作结果：层序递归遍历T(利用队列),对每个结点调用函数Visit一次且仅一次
   LinkQueue q;
   QElemType a;
   if(T)
   {
     InitQueue(q);
     EnQueue(q,T);
     while(!QueueEmpty(q))
     {
       DeQueue(q,a);
       Visit(a-&gt;data);
       if(a-&gt;lchild!=NULL)
         EnQueue(q,a-&gt;lchild);
       if(a-&gt;rchild!=NULL)
         EnQueue(q,a-&gt;rchild);
     }
     printf("\n");
   }
 }
</code></pre> 
<pre><code class="hljs"> // main6-2.cpp 检验bo6-2.cpp的主程序,利用条件编译选择数据类型(另一种方法)
 #define CHAR // 字符型
 // #define INT // 整型（二者选一）
 #include"c1.h"
 #ifdef CHAR
   typedef char TElemType;
   TElemType Nil=' '; // 字符型以空格符为空
 #endif
 #ifdef INT
   typedef int TElemType;
   TElemType Nil=0; // 整型以0为空
 #endif
 #include"c6-2.h"
 #include"bo6-2.cpp"

 Status visitT(TElemType e)
 {
 #ifdef CHAR
   printf("%c ",e);
 #endif
 #ifdef INT
   printf("%d ",e);
 #endif
   return OK;
 }

 void main()
 {
   int i;
   BiTree T,p,c;
   TElemType e1,e2;
   InitBiTree(T);
   printf("构造空二叉树后,树空否？%d(1:是 0:否) 树的深度=%d\n",BiTreeEmpty(T),BiTreeDepth(T));
   e1=Root(T);
   if(e1!=Nil)
 #ifdef CHAR
     printf("二叉树的根为: %c\n",e1);
 #endif
 #ifdef INT
     printf("二叉树的根为: %d\n",e1);
 #endif
   else
     printf("树空，无根\n");
 #ifdef CHAR
   printf("请先序输入二叉树(如:ab三个空格表示a为根结点,b为左子树的二叉树)\n");
 #endif
 #ifdef INT
   printf("请先序输入二叉树(如:1 2 0 0 0表示1为根结点,2为左子树的二叉树)\n");
 #endif
   CreateBiTree(T);
   printf("建立二叉树后,树空否？%d(1:是 0:否) 树的深度=%d\n",BiTreeEmpty(T),BiTreeDepth(T));
   e1=Root(T);
   if(e1!=Nil)
 #ifdef CHAR
     printf("二叉树的根为: %c\n",e1);
 #endif
 #ifdef INT
     printf("二叉树的根为: %d\n",e1);
 #endif
   else
     printf("树空，无根\n");
   printf("中序递归遍历二叉树:\n");
   InOrderTraverse(T,visitT);
   printf("\n中序非递归遍历二叉树:\n");
   InOrderTraverse1(T,visitT);
   printf("中序非递归遍历二叉树(另一种方法):\n");
   InOrderTraverse2(T,visitT);
   printf("后序递归遍历二叉树:\n");
   PostOrderTraverse(T,visitT);
   printf("\n层序遍历二叉树:\n");
   LevelOrderTraverse(T,visitT);
   printf("请输入一个结点的值: ");
 #ifdef CHAR
   scanf("%*c%c",&amp;e1);
 #endif
 #ifdef INT
   scanf("%d",&amp;e1);
 #endif
   p=Point(T,e1); // p为e1的指针
 #ifdef CHAR
   printf("结点的值为%c\n",Value(p));
 #endif
 #ifdef INT
   printf("结点的值为%d\n",Value(p));
 #endif
   printf("欲改变此结点的值，请输入新值: ");
 #ifdef CHAR
   scanf("%*c%c%*c",&amp;e2);
 #endif
 #ifdef INT
   scanf("%d",&amp;e2);
 #endif
   Assign(p,e2);
   printf("层序遍历二叉树:\n");
   LevelOrderTraverse(T,visitT);
   e1=Parent(T,e2);
   if(e1!=Nil)
 #ifdef CHAR
     printf("%c的双亲是%c\n",e2,e1);
 #endif
 #ifdef INT
     printf("%d的双亲是%d\n",e2,e1);
 #endif
   else
 #ifdef CHAR
     printf("%c没有双亲\n",e2);
 #endif
 #ifdef INT
     printf("%d没有双亲\n",e2);
 #endif
   e1=LeftChild(T,e2);
   if(e1!=Nil)
 #ifdef CHAR
     printf("%c的左孩子是%c\n",e2,e1);
 #endif
 #ifdef INT
     printf("%d的左孩子是%d\n",e2,e1);
 #endif
   else
 #ifdef CHAR
     printf("%c没有左孩子\n",e2);
 #endif
 #ifdef INT
     printf("%d没有左孩子\n",e2);
 #endif
   e1=RightChild(T,e2);
   if(e1!=Nil)
 #ifdef CHAR
     printf("%c的右孩子是%c\n",e2,e1);
 #endif
 #ifdef INT
     printf("%d的右孩子是%d\n",e2,e1);
 #endif
   else
 #ifdef CHAR
     printf("%c没有右孩子\n",e2);
 #endif
 #ifdef INT
     printf("%d没有右孩子\n",e2);
 #endif
   e1=LeftSibling(T,e2);
   if(e1!=Nil)
 #ifdef CHAR
     printf("%c的左兄弟是%c\n",e2,e1);
 #endif
 #ifdef INT
     printf("%d的左兄弟是%d\n",e2,e1);
 #endif
   else
 #ifdef CHAR
     printf("%c没有左兄弟\n",e2);
 #endif
 #ifdef INT
     printf("%d没有左兄弟\n",e2);
 #endif
   e1=RightSibling(T,e2);
   if(e1!=Nil)
 #ifdef CHAR
     printf("%c的右兄弟是%c\n",e2,e1);
 #endif
 #ifdef INT
     printf("%d的右兄弟是%d\n",e2,e1);
 #endif
   else
 #ifdef CHAR
     printf("%c没有右兄弟\n",e2);
 #endif
 #ifdef INT
     printf("%d没有右兄弟\n",e2);
 #endif
   InitBiTree(c);
   printf("构造一个右子树为空的二叉树c:\n");
 #ifdef CHAR
   printf("请先序输入二叉树(如:ab三个空格表示a为根结点,b为左子树的二叉树)\n");
 #endif
 #ifdef INT
   printf("请先序输入二叉树(如:1 2 0 0 0表示1为根结点,2为左子树的二叉树)\n");
 #endif
   CreateBiTree(c);
   printf("先序递归遍历二叉树c:\n");
   PreOrderTraverse(c,visitT);
   printf("\n树c插到树T中,请输入树T中树c的双亲结点 c为左(0)或右(1)子树: ");
 #ifdef CHAR
   scanf("%*c%c%d",&amp;e1,&amp;i);
 #endif
 #ifdef INT
   scanf("%d%d",&amp;e1,&amp;i);
 #endif
   p=Point(T,e1); // p是T中树c的双亲结点指针
   InsertChild(p,i,c);
   printf("先序递归遍历二叉树:\n");
   PreOrderTraverse(T,visitT);
   printf("\n删除子树,请输入待删除子树的双亲结点  左(0)或右(1)子树: ");
 #ifdef CHAR
   scanf("%*c%c%d",&amp;e1,&amp;i);
 #endif
 #ifdef INT
   scanf("%d%d",&amp;e1,&amp;i);
 #endif
   p=Point(T,e1);
   DeleteChild(p,i);
   printf("先序递归遍历二叉树:\n");
   PreOrderTraverse(T,visitT);
   printf("\n");
   DestroyBiTree(T);
 }</code></pre> 
<p>除了二叉链表还有三叉链表,三叉链表就是在二叉链表的基础上多一个指向父节点的指针</p> 
<h3>静态链表实现二叉树存储</h3> 
<p><img alt="" height="818" src="https://images2.imgbox.com/0d/96/zUhWPvhp_o.png" width="1200"></p> 
<h4> 先序遍历</h4> 
<p><img alt="" height="750" src="https://images2.imgbox.com/ba/3f/J1Wi4Vvs_o.png" width="1196"></p> 
<p> </p> 
<pre><code class="hljs">void PreOrderTraverse(BiTree T,Status(*Visit)(TElemType))
 { // 初始条件: 二叉树T存在,Visit是对结点操作的应用函数。算法6.1，有改动
   // 操作结果: 先序递归遍历T,对每个结点调用函数Visit一次且仅一次
   if(T) // T不空
   {
     Visit(T-&gt;data); // 先访问根结点
     PreOrderTraverse(T-&gt;lchild,Visit); // 再先序遍历左子树
     PreOrderTraverse(T-&gt;rchild,Visit); // 最后先序遍历右子树
   }
 }</code></pre> 
<h4><img alt="" height="935" src="https://images2.imgbox.com/ad/23/y2gcaoIs_o.png" width="1200"></h4> 
<h4>中序遍历</h4> 
<pre><code class="hljs"> void InOrderTraverse(BiTree T,Status(*Visit)(TElemType))
 { // 初始条件: 二叉树T存在,Visit是对结点操作的应用函数
   // 操作结果: 中序递归遍历T,对每个结点调用函数Visit一次且仅一次
   if(T)
   {
     InOrderTraverse(T-&gt;lchild,Visit); // 先中序遍历左子树
     Visit(T-&gt;data); // 再访问根结点
     InOrderTraverse(T-&gt;rchild,Visit); // 最后中序遍历右子树
   }
 }</code></pre> 
<p>以非递归算法实现中序遍历</p> 
<pre><code class="hljs">Status InOrderTraverse1(BiTree T,Status(*Visit)(TElemType))
 { // 采用二叉链表存储结构，Visit是对数据元素操作的应用函数。算法6.3
   // 中序遍历二叉树T的非递归算法(利用栈)，对每个数据元素调用函数Visit
   SqStack S;
   InitStack(S);
   while(T||!StackEmpty(S))
   {
     if(T)
     { // 根指针进栈,遍历左子树
       Push(S,T);
       T=T-&gt;lchild;
     }
     else
     { // T为空,根指针退栈,访问根结点,遍历右子树
       Pop(S,T);
       if(!Visit(T-&gt;data))
         return ERROR;
       T=T-&gt;rchild;
     }
   }
   printf("\n");
   return OK;
 }</code></pre> 
<h4><img alt="" height="929" src="https://images2.imgbox.com/99/4f/xuC0Ghiu_o.png" width="1200"></h4> 
<p> <img alt="" height="916" src="https://images2.imgbox.com/9e/9b/BarSVHpr_o.png" width="1200"></p> 
<p>判断节点是否有左子树,有的话就将这个节点入栈,然后左子树成为新的节点;如果不存在左子树就访问这个节点的值,然后访问他的右子树,右子树不存在就返回这个节点的父节点；.........</p> 
<h4>后序遍历</h4> 
<pre><code class="hljs">void PostOrderTraverse(BiTree T,Status(*Visit)(TElemType))
 { // 初始条件: 二叉树T存在,Visit是对结点操作的应用函数
   // 操作结果: 后序递归遍历T,对每个结点调用函数Visit一次且仅一次
   if(T) // T不空
   {
     PostOrderTraverse(T-&gt;lchild,Visit); // 先后序遍历左子树
     PostOrderTraverse(T-&gt;rchild,Visit); // 再后序遍历右子树
     Visit(T-&gt;data); // 最后访问根结点
   }
 }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d94fd8b5f6ccc94c5d41f0ccbb734bce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git diff 命令6种使用场景</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf57fffe74060818ed97aaaad519c7b6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">海康威视网络摄像头sdk的开发（Demo的使用）指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>