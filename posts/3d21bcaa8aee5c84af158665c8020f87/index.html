<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>解读Google官方SwipeRefreshLayout控件源码，带你揭秘Android下拉刷新的实现原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="解读Google官方SwipeRefreshLayout控件源码，带你揭秘Android下拉刷新的实现原理" />
<meta property="og:description" content="from: http://blog.csdn.net/tellh/article/details/50782653
前言 想必大家也发现，时下的很多App都应用了这个Google出品的SwipeRefreshLayout下拉刷新控件，它以Material Design风格、适用场景广泛，简单易用等特性而独步江湖。但在我们使用的过程中，不可避免地会发现一些bug，或者需要添加某些特性来满足需求。出现这些问题，最好的方法就是解读源码，理解它实现的原理，并且在理解源码的基础上修改源码，达成需求。然而不知为何，至今还没有一篇关于SwipeRefreshLayout源码解析的文章，所以萌发了要写一篇这样的文章。鉴于阅读技术博文的枯燥，加之还是篇源码解析的文章，我不打算一下子扔出来一大段代码让读者去啃，而是一步一步往下走，揭开SwipeRefreshLayout的神秘面纱。
阅读源码的小技巧 为什么源码普遍都很难读，有人甚至谈之色变？其实代码（出自大神之手）生来是易读的，但代码多了就变得难读了。所以阅读源码时，要把握住主干，细枝末节可以暂时忽略，一路下来理解了程序工作流程后再回过头来会有一种豁然开朗的感觉。 阅读源码我还是选择Android Studio。这个强大的工具提供了很多快捷键，大大地方便了源码的阅读。
Ctrl&#43;F :在当页查找关键字Alt&#43;F7: 查看方法或变量在哪里被使用过Ctrl&#43;Q：查看java doc，如果该方法或变量有的话javadoc的话就可以更快知道该它的相关信息Ctrl&#43;左击：这个不用说了吧，进入方法体或者查看定义或者查看被使用的地方Ctrl&#43;Shift&#43;i：可以不离开当前阅读的位置，查看指定方法的方法体Ctrl&#43;F11：加BookMark，简直是非常有用的功能，不过需要去设置添加一下跳转下一个书签或上一个书签的快捷键才能发挥出该功能真正强大。Ctrl&#43;F12 : 输入关键字快速定位指定的变量或方法，支持模糊搜索。Ctrl &#43;Alt&#43;左箭头或右箭头：返回前一个或下一个光标的位置，在想回溯阅读位置的时候非常有用关于阅读源码的快捷键就这些吧，以后想到了再补充… 你应该知道： 在看往下看之前，我希望你了解：
事件分发机制ViewGroup的测量绘制过程 准备工作 所幸该控件没有跟系统api耦合，所以可以直接copy一份代码到自己的demo工程中，尽情地改。但是hint会理解报出一些错误。首先包名要改一下，类名最好也改吧，以免混淆~其次把CircleImageView和MaterialProgressDrawable这两个类都copy过来，放在同一个包里。如图： 如果嫌麻烦可以直接fork我的项目。
探究之旅 我们朝着未知的黑暗出发。打开SwipeRefreshTestLayout的类文件，看到左边这么小的滑块，其实我一开始是拒绝的~ 感觉无从下手啊有没有… 沉下心来，想想看看它是继承于ViewGroup的，所以想想它一定有两个很关键的方法：onMeasure和onLayout，分别解决了它和它的子View占多大地和搁到哪。因为它是一个下拉刷新控件，它必定要涉及到事件分发的处理，同样是两个关键方法：onInterceptTouchEvent和onTouchEvent，分别用于决定是否拦截点击事件和进行点击事件的处理。天空瞬间亮了许多…
onMeasure @Override public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); if (mTarget == null) { ensureTarget(); } if (mTarget == null) { return; } //mTarget的尺寸为match_parent，除去内边距 mTarget.measure(MeasureSpec.makeMeasureSpec( getMeasuredWidth() - getPaddingLeft() - getPaddingRight(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec( getMeasuredHeight() - getPaddingTop() - getPaddingBottom(), MeasureSpec.EXACTLY)); //设置mCircleView的尺寸 mCircleView.measure(MeasureSpec.makeMeasureSpec(mCircleWidth, MeasureSpec.EXACTLY), MeasureSpec." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3d21bcaa8aee5c84af158665c8020f87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-15T10:30:46+08:00" />
<meta property="article:modified_time" content="2018-03-15T10:30:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">解读Google官方SwipeRefreshLayout控件源码，带你揭秘Android下拉刷新的实现原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>from: <a href="http://blog.csdn.net/tellh/article/details/50782653">http://blog.csdn.net/tellh/article/details/50782653</a></p> 
<p></p> 
<h2 style="padding:0px;background-color:rgb(255,255,255);">前言</h2> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">想必大家也发现，时下的很多App都应用了这个Google出品的SwipeRefreshLayout下拉刷新控件，它以Material Design风格、适用场景广泛，简单易用等特性而独步江湖。但在我们使用的过程中，不可避免地会发现一些bug，或者需要添加某些特性来满足需求。出现这些问题，最好的方法就是解读源码，理解它实现的原理，并且在理解源码的基础上修改源码，达成需求。然而不知为何，至今还没有一篇关于SwipeRefreshLayout源码解析的文章，所以萌发了要写一篇这样的文章。鉴于阅读技术博文的枯燥，加之还是篇源码解析的文章，我不打算一下子扔出来一大段代码让读者去啃，而是一步一步往下走，揭开SwipeRefreshLayout的神秘面纱。</p> 
<h2 style="padding:0px;background-color:rgb(255,255,255);"><a style="margin:0px;padding:0px;font-weight:400;"></a>阅读源码的小技巧</h2> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">为什么源码普遍都很难读，有人甚至谈之色变？其实代码（出自大神之手）生来是易读的，但代码多了就变得难读了。所以阅读源码时，要把握住主干，细枝末节可以暂时忽略，一路下来理解了程序工作流程后再回过头来会有一种豁然开朗的感觉。 <br>阅读源码我还是选择Android Studio。这个强大的工具提供了很多快捷键，大大地方便了源码的阅读。</p> 
<ul style="list-style:none;color:rgb(69,69,69);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><li style="padding:0px;">Ctrl+F :在当页查找关键字</li><li style="padding:0px;">Alt+F7: 查看方法或变量在哪里被使用过</li><li style="padding:0px;">Ctrl+Q：查看java doc，如果该方法或变量有的话javadoc的话就可以更快知道该它的相关信息</li><li style="padding:0px;">Ctrl+左击：这个不用说了吧，进入方法体或者查看定义或者查看被使用的地方</li><li style="padding:0px;">Ctrl+Shift+i：可以不离开当前阅读的位置，查看指定方法的方法体</li><li style="padding:0px;">Ctrl+F11：加BookMark，简直是非常有用的功能，不过需要去设置添加一下跳转下一个书签或上一个书签的快捷键才能发挥出该功能真正强大。</li><li style="padding:0px;">Ctrl+F12 : 输入关键字快速定位指定的变量或方法，支持模糊搜索。</li><li style="padding:0px;">Ctrl +Alt+左箭头或右箭头：返回前一个或下一个光标的位置，在想回溯阅读位置的时候非常有用</li><li style="padding:0px;">关于阅读源码的快捷键就这些吧，以后想到了再补充…</li></ul> 
<h2 style="padding:0px;background-color:rgb(255,255,255);"><a style="margin:0px;padding:0px;font-weight:400;"></a>你应该知道：</h2> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">在看往下看之前，我希望你了解：</p> 
<ul style="list-style:none;color:rgb(69,69,69);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><li style="padding:0px;">事件分发机制</li><li style="padding:0px;">ViewGroup的测量绘制过程</li></ul> 
<h2 style="padding:0px;background-color:rgb(255,255,255);"><a style="margin:0px;padding:0px;font-weight:400;"></a>准备工作</h2> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">所幸该控件没有跟系统api耦合，所以可以直接copy一份代码到自己的demo工程中，尽情地改。但是hint会理解报出一些错误。首先包名要改一下，类名最好也改吧，以免混淆~其次把CircleImageView和MaterialProgressDrawable这两个类都copy过来，放在同一个包里。如图： <br><img src="https://images2.imgbox.com/17/53/1JSAtfOo_o.png" alt="这里写图片描述" title="" style="border:0px;margin-top:24px;margin-bottom:24px;"> <br>如果嫌麻烦可以直接fork我的<a href="https://github.com/TellH/Android_PullToRefreshLibrary_Collection" style="margin:0px;padding:0px;">项目</a>。</p> 
<h2 style="padding:0px;background-color:rgb(255,255,255);"><a style="margin:0px;padding:0px;font-weight:400;"></a>探究之旅</h2> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">我们朝着未知的黑暗出发。打开SwipeRefreshTestLayout的类文件，看到左边这么小的滑块，其实我一开始是拒绝的~ 感觉无从下手啊有没有… 沉下心来，想想看看它是继承于ViewGroup的，所以想想它一定有两个很关键的方法：onMeasure和onLayout，分别解决了它和它的子View占多大地和搁到哪。因为它是一个下拉刷新控件，它必定要涉及到事件分发的处理，同样是两个关键方法：onInterceptTouchEvent和onTouchEvent，分别用于决定是否拦截点击事件和进行点击事件的处理。天空瞬间亮了许多…</p> 
<h3 style="padding:0px;background-color:rgb(255,255,255);"><a style="margin:0px;padding:0px;font-weight:400;"></a>onMeasure</h3> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs axapta has-numbering">    @Override
    <span class="hljs-keyword" style="margin:0px;padding:0px;">public</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> onMeasure(<span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> widthMeasureSpec, <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> heightMeasureSpec) {
        <span class="hljs-keyword" style="margin:0px;padding:0px;">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mTarget == <span class="hljs-keyword" style="margin:0px;padding:0px;">null</span>) {
            ensureTarget();
        }
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mTarget == <span class="hljs-keyword" style="margin:0px;padding:0px;">null</span>) {
            <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span>;
        }
        <span class="hljs-comment" style="margin:0px;padding:0px;">//mTarget的尺寸为match_parent，除去内边距</span>
        mTarget.measure(MeasureSpec.makeMeasureSpec(
                getMeasuredWidth() - getPaddingLeft() - getPaddingRight(),
                MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(
                getMeasuredHeight() - getPaddingTop() - getPaddingBottom(), MeasureSpec.EXACTLY));
        <span class="hljs-comment" style="margin:0px;padding:0px;">//设置mCircleView的尺寸</span>
        mCircleView.measure(MeasureSpec.makeMeasureSpec(mCircleWidth, MeasureSpec.EXACTLY),
                MeasureSpec.makeMeasureSpec(mCircleHeight, MeasureSpec.EXACTLY));
        <span class="hljs-comment" style="margin:0px;padding:0px;">//如果mOriginalOffsetTop未被初始化并且mUsingCustomStart ？，则将下拉小圆的初始位置设置成默认值</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (!mUsingCustomStart &amp;&amp; !mOriginalOffsetCalculated) {
            mOriginalOffsetCalculated = <span class="hljs-keyword" style="margin:0px;padding:0px;">true</span>;
            mCurrentTargetOffsetTop = mOriginalOffsetTop = -mCircleView.getMeasuredHeight();
        }
        mCircleViewIndex = -<span class="hljs-number" style="margin:0px;padding:0px;">1</span>;
        <span class="hljs-comment" style="margin:0px;padding:0px;">// Get the index of the circleview.获取circleview的索引值，主要是为了后面重载getChildDrawingOrder时要用</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">for</span> (<span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">index</span> = <span class="hljs-number" style="margin:0px;padding:0px;">0</span>; <span class="hljs-keyword" style="margin:0px;padding:0px;">index</span> &lt; getChildCount(); <span class="hljs-keyword" style="margin:0px;padding:0px;">index</span>++) {
            <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (getChildAt(<span class="hljs-keyword" style="margin:0px;padding:0px;">index</span>) == mCircleView) {
                mCircleViewIndex = <span class="hljs-keyword" style="margin:0px;padding:0px;">index</span>;
                <span class="hljs-keyword" style="margin:0px;padding:0px;">break</span>;
            }
        }
    }</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li><li style="color:rgb(153,153,153);">7</li><li style="color:rgb(153,153,153);">8</li><li style="color:rgb(153,153,153);">9</li><li style="color:rgb(153,153,153);">10</li><li style="color:rgb(153,153,153);">11</li><li style="color:rgb(153,153,153);">12</li><li style="color:rgb(153,153,153);">13</li><li style="color:rgb(153,153,153);">14</li><li style="color:rgb(153,153,153);">15</li><li style="color:rgb(153,153,153);">16</li><li style="color:rgb(153,153,153);">17</li><li style="color:rgb(153,153,153);">18</li><li style="color:rgb(153,153,153);">19</li><li style="color:rgb(153,153,153);">20</li><li style="color:rgb(153,153,153);">21</li><li style="color:rgb(153,153,153);">22</li><li style="color:rgb(153,153,153);">23</li><li style="color:rgb(153,153,153);">24</li><li style="color:rgb(153,153,153);">25</li><li style="color:rgb(153,153,153);">26</li><li style="color:rgb(153,153,153);">27</li><li style="color:rgb(153,153,153);">28</li><li style="color:rgb(153,153,153);">29</li><li style="color:rgb(153,153,153);">30</li><li style="color:rgb(153,153,153);">31</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">我们看到，这个方法代码不长，但却很关键。重写该方法的作用是设置子View的尺寸。出现mTarget是什么未知生物？其实就是一个它包裹的子View，通常是ListView等一些可滚动的控件。ensureTarget();保证它非空并存在。如果不小心包裹了多个VIew呢？则mTarget就是其中的最后一个子View。mCircleView又是什么生物呢？顾名思义，下拉的白色小圆圈，一个ImageView而已。mCurrentTargetOffsetTop 和mOriginalOffsetTop 是两个非常关键的变量，分别表示当前mCircleView的位置（top值）和初始时mCircleView的位置（top值），当然它们初始化都等于mCircleView高度的负数。还有一个mUsingCustomStart 是什么呢？我当时也不知道。没关系，Ctrl+F11打个书签，等读完再回头看。或者我们可以通过Alt+F7看看它的在哪里被引用过。 <br><img src="https://images2.imgbox.com/06/3e/UZHWsntG_o.png" alt="这里写图片描述" title="" style="border:0px;margin-top:24px;margin-bottom:24px;"><br>可以看到，它在setProgressViewOffset被赋值为true，而该方法是用于设置CircleView初始的位置和刷新停留的位置，Custom是自定义的意思，所以mUsingCustomStart就是一个标志，表示是否用自定义的起始位置，而默认的起始位置就是CircleView高度的负数。</p> 
<h3 style="padding:0px;background-color:rgb(255,255,255);"><a style="margin:0px;padding:0px;font-weight:400;"></a>onLayout</h3> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">    <span class="hljs-annotation" style="margin:0px;padding:0px;">@Override</span>
    <span class="hljs-keyword" style="margin:0px;padding:0px;">protected</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">onLayout</span>(<span class="hljs-keyword" style="margin:0px;padding:0px;">boolean</span> changed, <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> left, <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> top, <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> right, <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> bottom) {
        <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> width = getMeasuredWidth();
        <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> height = getMeasuredHeight();
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (getChildCount() == <span class="hljs-number" style="margin:0px;padding:0px;">0</span>) {
            <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span>;
        }
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mTarget == <span class="hljs-keyword" style="margin:0px;padding:0px;">null</span>) {
            ensureTarget();
        }
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mTarget == <span class="hljs-keyword" style="margin:0px;padding:0px;">null</span>) {
            <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span>;
        }
        <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> View child = mTarget;
        <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> childLeft = getPaddingLeft();
        <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> childTop = getPaddingTop();
        <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> childWidth = width - getPaddingLeft() - getPaddingRight();
        <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> childHeight = height - getPaddingTop() - getPaddingBottom();
        <span class="hljs-comment" style="margin:0px;padding:0px;">//将mTarget放在覆盖parent的位置（除去内边距）</span>
        child.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight);
        <span class="hljs-comment" style="margin:0px;padding:0px;">//将mCircleView放在mTarget的平面位置上面居中，初始化时是完全隐藏在屏幕外的</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> circleWidth = mCircleView.getMeasuredWidth();
        <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> circleHeight = mCircleView.getMeasuredHeight();
        mCircleView.layout((width / <span class="hljs-number" style="margin:0px;padding:0px;">2</span> - circleWidth / <span class="hljs-number" style="margin:0px;padding:0px;">2</span>), mCurrentTargetOffsetTop,
                (width / <span class="hljs-number" style="margin:0px;padding:0px;">2</span> + circleWidth / <span class="hljs-number" style="margin:0px;padding:0px;">2</span>), mCurrentTargetOffsetTop + circleHeight);
    }</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li><li style="color:rgb(153,153,153);">7</li><li style="color:rgb(153,153,153);">8</li><li style="color:rgb(153,153,153);">9</li><li style="color:rgb(153,153,153);">10</li><li style="color:rgb(153,153,153);">11</li><li style="color:rgb(153,153,153);">12</li><li style="color:rgb(153,153,153);">13</li><li style="color:rgb(153,153,153);">14</li><li style="color:rgb(153,153,153);">15</li><li style="color:rgb(153,153,153);">16</li><li style="color:rgb(153,153,153);">17</li><li style="color:rgb(153,153,153);">18</li><li style="color:rgb(153,153,153);">19</li><li style="color:rgb(153,153,153);">20</li><li style="color:rgb(153,153,153);">21</li><li style="color:rgb(153,153,153);">22</li><li style="color:rgb(153,153,153);">23</li><li style="color:rgb(153,153,153);">24</li><li style="color:rgb(153,153,153);">25</li><li style="color:rgb(153,153,153);">26</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">这个方法代码也不长，很简单，但却很关键。作用是安排子View的位置。将mTarget填充整个控件，将mCircleView放在mTarget的平面位置上面居中，初始化时是完全隐藏在屏幕外的。</p> 
<h3 style="padding:0px;background-color:rgb(255,255,255);"><a style="margin:0px;padding:0px;font-weight:400;"></a>onInterceptTouchEvent</h3> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering"><span class="hljs-annotation" style="margin:0px;padding:0px;">@Override</span>
    <span class="hljs-keyword" style="margin:0px;padding:0px;">public</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">boolean</span> <span class="hljs-title" style="margin:0px;padding:0px;">onInterceptTouchEvent</span>(MotionEvent ev) {
        ensureTarget();

        <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> action = MotionEventCompat.getActionMasked(ev);

        <span class="hljs-comment" style="margin:0px;padding:0px;">//如果当mCircleView正在返回初始位置的同时手指按下了，将标志mReturningToStart复位</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mReturningToStart &amp;&amp; action == MotionEvent.ACTION_DOWN) {
            mReturningToStart = <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
        }

        <span class="hljs-comment" style="margin:0px;padding:0px;">//如果下拉被禁用、mCircleView正在返回初始位置、mTarget没有到达顶部、</span>
        <span class="hljs-comment" style="margin:0px;padding:0px;">//正在刷新、mNestedScrollInProgress</span>
        <span class="hljs-comment" style="margin:0px;padding:0px;">// 不拦截，不处理点击事件，处理权交还mTarget</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (!isEnabled() || mReturningToStart || canChildScrollUp()
                || mRefreshing || mNestedScrollInProgress) {
            <span class="hljs-comment" style="margin:0px;padding:0px;">// Fail fast if we're not in a state where a swipe is possible</span>
            <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
        }

        <span class="hljs-keyword" style="margin:0px;padding:0px;">switch</span> (action) {
            <span class="hljs-comment" style="margin:0px;padding:0px;">//手指按下时，记录按下的坐标</span>
            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEvent.ACTION_DOWN:
<span class="hljs-comment" style="margin:0px;padding:0px;">//                setTargetOffsetTopAndBottom(mOriginalOffsetTop - mCircleView.getTop(), true);</span>
                mActivePointerId = MotionEventCompat.getPointerId(ev, <span class="hljs-number" style="margin:0px;padding:0px;">0</span>);
                mIsBeingDragged = <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> initialDownY = getMotionEventY(ev, mActivePointerId);
                <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (initialDownY == -<span class="hljs-number" style="margin:0px;padding:0px;">1</span>) {
                    <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                }
                mInitialDownY = initialDownY;
                <span class="hljs-keyword" style="margin:0px;padding:0px;">break</span>;

            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEvent.ACTION_MOVE:
                <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mActivePointerId == INVALID_POINTER) {
                    Log.e(LOG_TAG, <span class="hljs-string" style="margin:0px;padding:0px;">"Got ACTION_MOVE event but don't have an active pointer id."</span>);
                    <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                }

                <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> y = getMotionEventY(ev, mActivePointerId);
                <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (y == -<span class="hljs-number" style="margin:0px;padding:0px;">1</span>) {
                    <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                }
                <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> yDiff = y - mInitialDownY;
                <span class="hljs-comment" style="margin:0px;padding:0px;">//如果是滑动动作，将mIsBeingDragged置为true</span>
                <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) {
                    mInitialMotionY = mInitialDownY + mTouchSlop;
                    mIsBeingDragged = <span class="hljs-keyword" style="margin:0px;padding:0px;">true</span>;
                    mProgress.setAlpha(STARTING_PROGRESS_ALPHA);
                }
                <span class="hljs-keyword" style="margin:0px;padding:0px;">break</span>;

            <span class="hljs-comment" style="margin:0px;padding:0px;">//处理多指触控</span>
            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEventCompat.ACTION_POINTER_UP:
                onSecondaryPointerUp(ev);
                <span class="hljs-keyword" style="margin:0px;padding:0px;">break</span>;

            <span class="hljs-comment" style="margin:0px;padding:0px;">//手指松开，将标志复位</span>
            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEvent.ACTION_UP:
            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEvent.ACTION_CANCEL:
                mIsBeingDragged = <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                mActivePointerId = INVALID_POINTER;
                <span class="hljs-keyword" style="margin:0px;padding:0px;">break</span>;
        }

        <span class="hljs-comment" style="margin:0px;padding:0px;">//如果正在被拖拽，拦截该系列的点击事件，并调用自己的onTouchEvent()来处理</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> mIsBeingDragged;
    }</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li><li style="color:rgb(153,153,153);">7</li><li style="color:rgb(153,153,153);">8</li><li style="color:rgb(153,153,153);">9</li><li style="color:rgb(153,153,153);">10</li><li style="color:rgb(153,153,153);">11</li><li style="color:rgb(153,153,153);">12</li><li style="color:rgb(153,153,153);">13</li><li style="color:rgb(153,153,153);">14</li><li style="color:rgb(153,153,153);">15</li><li style="color:rgb(153,153,153);">16</li><li style="color:rgb(153,153,153);">17</li><li style="color:rgb(153,153,153);">18</li><li style="color:rgb(153,153,153);">19</li><li style="color:rgb(153,153,153);">20</li><li style="color:rgb(153,153,153);">21</li><li style="color:rgb(153,153,153);">22</li><li style="color:rgb(153,153,153);">23</li><li style="color:rgb(153,153,153);">24</li><li style="color:rgb(153,153,153);">25</li><li style="color:rgb(153,153,153);">26</li><li style="color:rgb(153,153,153);">27</li><li style="color:rgb(153,153,153);">28</li><li style="color:rgb(153,153,153);">29</li><li style="color:rgb(153,153,153);">30</li><li style="color:rgb(153,153,153);">31</li><li style="color:rgb(153,153,153);">32</li><li style="color:rgb(153,153,153);">33</li><li style="color:rgb(153,153,153);">34</li><li style="color:rgb(153,153,153);">35</li><li style="color:rgb(153,153,153);">36</li><li style="color:rgb(153,153,153);">37</li><li style="color:rgb(153,153,153);">38</li><li style="color:rgb(153,153,153);">39</li><li style="color:rgb(153,153,153);">40</li><li style="color:rgb(153,153,153);">41</li><li style="color:rgb(153,153,153);">42</li><li style="color:rgb(153,153,153);">43</li><li style="color:rgb(153,153,153);">44</li><li style="color:rgb(153,153,153);">45</li><li style="color:rgb(153,153,153);">46</li><li style="color:rgb(153,153,153);">47</li><li style="color:rgb(153,153,153);">48</li><li style="color:rgb(153,153,153);">49</li><li style="color:rgb(153,153,153);">50</li><li style="color:rgb(153,153,153);">51</li><li style="color:rgb(153,153,153);">52</li><li style="color:rgb(153,153,153);">53</li><li style="color:rgb(153,153,153);">54</li><li style="color:rgb(153,153,153);">55</li><li style="color:rgb(153,153,153);">56</li><li style="color:rgb(153,153,153);">57</li><li style="color:rgb(153,153,153);">58</li><li style="color:rgb(153,153,153);">59</li><li style="color:rgb(153,153,153);">60</li><li style="color:rgb(153,153,153);">61</li><li style="color:rgb(153,153,153);">62</li><li style="color:rgb(153,153,153);">63</li><li style="color:rgb(153,153,153);">64</li><li style="color:rgb(153,153,153);">65</li><li style="color:rgb(153,153,153);">66</li><li style="color:rgb(153,153,153);">67</li><li style="color:rgb(153,153,153);">68</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">这个方法的逻辑非常清晰。当如果下拉被禁用、mCircleView正在返回初始位置、mTarget没有到达顶部、 <br>或者正在刷新时， 不拦截，不处理点击事件，处理权交还mTarget。排除以上情况后，还需要进一步判断。 <br>当手指按下时，记录按下的坐标；在MotionEvent.ACTION_MOVE当中，判断是否是滑动动作，如果是，拦截该系列的点击事件，并调用自己的onTouchEvent()来处理。</p> 
<h3 style="padding:0px;background-color:rgb(255,255,255);"><a style="margin:0px;padding:0px;font-weight:400;"></a>onTouchEvent</h3> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">重头戏来了！这个方法是关键中的关键：</p> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering"><span class="hljs-annotation" style="margin:0px;padding:0px;">@Override</span>
    <span class="hljs-keyword" style="margin:0px;padding:0px;">public</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">boolean</span> <span class="hljs-title" style="margin:0px;padding:0px;">onTouchEvent</span>(MotionEvent ev) {
        <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> action = MotionEventCompat.getActionMasked(ev);
        <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> pointerIndex = -<span class="hljs-number" style="margin:0px;padding:0px;">1</span>;

        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mReturningToStart &amp;&amp; action == MotionEvent.ACTION_DOWN) {
            mReturningToStart = <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
        }

        <span class="hljs-comment" style="margin:0px;padding:0px;">//如果被禁用、CircleView正在复位、没到达顶部、mNestedScrollInProgress，直接返回，不处理该事件</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (!isEnabled() || mReturningToStart || canChildScrollUp() || mNestedScrollInProgress) {
            <span class="hljs-comment" style="margin:0px;padding:0px;">// Fail fast if we're not in a state where a swipe is possible</span>
            <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
        }

        <span class="hljs-keyword" style="margin:0px;padding:0px;">switch</span> (action) {
            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEvent.ACTION_DOWN:
                mActivePointerId = MotionEventCompat.getPointerId(ev, <span class="hljs-number" style="margin:0px;padding:0px;">0</span>);
                mIsBeingDragged = <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                <span class="hljs-keyword" style="margin:0px;padding:0px;">break</span>;

            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEvent.ACTION_MOVE: {
                pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (pointerIndex &lt; <span class="hljs-number" style="margin:0px;padding:0px;">0</span>) {
                    Log.e(LOG_TAG, <span class="hljs-string" style="margin:0px;padding:0px;">"Got ACTION_MOVE event but have an invalid active pointer id."</span>);
                    <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                }

                <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> y = MotionEventCompat.getY(ev, pointerIndex);
                <span class="hljs-comment" style="margin:0px;padding:0px;">//下拉的总高度</span>
                <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> overscrollTop = (y - mInitialMotionY) * DRAG_RATE;
                <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mIsBeingDragged) {
                    <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (overscrollTop &gt; <span class="hljs-number" style="margin:0px;padding:0px;">0</span>) {
                        <span class="hljs-comment" style="margin:0px;padding:0px;">//spinner可理解为下拉组件，将spinner移到指定的高度</span>
                        <span class="hljs-comment" style="margin:0px;padding:0px;">//很关键的方法，进入看看</span>
                        moveSpinner(overscrollTop);
                    } <span class="hljs-keyword" style="margin:0px;padding:0px;">else</span> {
                        <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                    }
                }
                <span class="hljs-keyword" style="margin:0px;padding:0px;">break</span>;
            }
            <span class="hljs-comment" style="margin:0px;padding:0px;">//多指触控的处理</span>
            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEventCompat.ACTION_POINTER_DOWN: {
                pointerIndex = MotionEventCompat.getActionIndex(ev);
                <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (pointerIndex &lt; <span class="hljs-number" style="margin:0px;padding:0px;">0</span>) {
                    Log.e(LOG_TAG, <span class="hljs-string" style="margin:0px;padding:0px;">"Got ACTION_POINTER_DOWN event but have an invalid action index."</span>);
                    <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                }
                mActivePointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
                <span class="hljs-keyword" style="margin:0px;padding:0px;">break</span>;
            }

            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEventCompat.ACTION_POINTER_UP:
                onSecondaryPointerUp(ev);
                <span class="hljs-keyword" style="margin:0px;padding:0px;">break</span>;

            <span class="hljs-comment" style="margin:0px;padding:0px;">//关键代码！</span>
            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEvent.ACTION_UP: {
                pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (pointerIndex &lt; <span class="hljs-number" style="margin:0px;padding:0px;">0</span>) {
                    Log.e(LOG_TAG, <span class="hljs-string" style="margin:0px;padding:0px;">"Got ACTION_UP event but don't have an active pointer id."</span>);
                    <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                }

                <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> y = MotionEventCompat.getY(ev, pointerIndex);
                <span class="hljs-comment" style="margin:0px;padding:0px;">//计算松开手时下拉的总距离</span>
                <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> overscrollTop = (y - mInitialMotionY) * DRAG_RATE;
                mIsBeingDragged = <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                <span class="hljs-comment" style="margin:0px;padding:0px;">//关键方法，进去看看</span>
                finishSpinner(overscrollTop);
                mActivePointerId = INVALID_POINTER;
                <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
            }
            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEvent.ACTION_CANCEL:
                <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
        }

        <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">true</span>;
    }</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li><li style="color:rgb(153,153,153);">7</li><li style="color:rgb(153,153,153);">8</li><li style="color:rgb(153,153,153);">9</li><li style="color:rgb(153,153,153);">10</li><li style="color:rgb(153,153,153);">11</li><li style="color:rgb(153,153,153);">12</li><li style="color:rgb(153,153,153);">13</li><li style="color:rgb(153,153,153);">14</li><li style="color:rgb(153,153,153);">15</li><li style="color:rgb(153,153,153);">16</li><li style="color:rgb(153,153,153);">17</li><li style="color:rgb(153,153,153);">18</li><li style="color:rgb(153,153,153);">19</li><li style="color:rgb(153,153,153);">20</li><li style="color:rgb(153,153,153);">21</li><li style="color:rgb(153,153,153);">22</li><li style="color:rgb(153,153,153);">23</li><li style="color:rgb(153,153,153);">24</li><li style="color:rgb(153,153,153);">25</li><li style="color:rgb(153,153,153);">26</li><li style="color:rgb(153,153,153);">27</li><li style="color:rgb(153,153,153);">28</li><li style="color:rgb(153,153,153);">29</li><li style="color:rgb(153,153,153);">30</li><li style="color:rgb(153,153,153);">31</li><li style="color:rgb(153,153,153);">32</li><li style="color:rgb(153,153,153);">33</li><li style="color:rgb(153,153,153);">34</li><li style="color:rgb(153,153,153);">35</li><li style="color:rgb(153,153,153);">36</li><li style="color:rgb(153,153,153);">37</li><li style="color:rgb(153,153,153);">38</li><li style="color:rgb(153,153,153);">39</li><li style="color:rgb(153,153,153);">40</li><li style="color:rgb(153,153,153);">41</li><li style="color:rgb(153,153,153);">42</li><li style="color:rgb(153,153,153);">43</li><li style="color:rgb(153,153,153);">44</li><li style="color:rgb(153,153,153);">45</li><li style="color:rgb(153,153,153);">46</li><li style="color:rgb(153,153,153);">47</li><li style="color:rgb(153,153,153);">48</li><li style="color:rgb(153,153,153);">49</li><li style="color:rgb(153,153,153);">50</li><li style="color:rgb(153,153,153);">51</li><li style="color:rgb(153,153,153);">52</li><li style="color:rgb(153,153,153);">53</li><li style="color:rgb(153,153,153);">54</li><li style="color:rgb(153,153,153);">55</li><li style="color:rgb(153,153,153);">56</li><li style="color:rgb(153,153,153);">57</li><li style="color:rgb(153,153,153);">58</li><li style="color:rgb(153,153,153);">59</li><li style="color:rgb(153,153,153);">60</li><li style="color:rgb(153,153,153);">61</li><li style="color:rgb(153,153,153);">62</li><li style="color:rgb(153,153,153);">63</li><li style="color:rgb(153,153,153);">64</li><li style="color:rgb(153,153,153);">65</li><li style="color:rgb(153,153,153);">66</li><li style="color:rgb(153,153,153);">67</li><li style="color:rgb(153,153,153);">68</li><li style="color:rgb(153,153,153);">69</li><li style="color:rgb(153,153,153);">70</li><li style="color:rgb(153,153,153);">71</li><li style="color:rgb(153,153,153);">72</li><li style="color:rgb(153,153,153);">73</li><li style="color:rgb(153,153,153);">74</li><li style="color:rgb(153,153,153);">75</li><li style="color:rgb(153,153,153);">76</li><li style="color:rgb(153,153,153);">77</li><li style="color:rgb(153,153,153);">78</li><li style="color:rgb(153,153,153);">79</li><li style="color:rgb(153,153,153);">80</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">在case MotionEvent.ACTION_MOVE当中，计算下拉的总高度overscrollTop，DRAG_RATE是下拉阻尼，可以通过改变它的值来改变下拉手感哦~~然后进入到moveSpinner()方法，将spinner移到指定的高度。那么spinner是啥？其实就是下拉组件的意思。</p> 
<ul style="list-style:none;color:rgb(69,69,69);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><li style="padding:0px;">moveSpinner</li></ul> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">    <span class="hljs-javadoc" style="margin:0px;padding:0px;">/**
     * 通过调用setTargetOffsetTopAndBottom()方法移动下拉组件Spinner（mCircleView）
     * 同时更新mProgress（一个drawable）的绘制进度
     *<span class="hljs-javadoctag" style="margin:0px;padding:0px;"> @param</span> overscrollTop 下拉高度
     */</span>
    <span class="hljs-keyword" style="margin:0px;padding:0px;">private</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">moveSpinner</span>(<span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> overscrollTop) {
        mProgress.showArrow(<span class="hljs-keyword" style="margin:0px;padding:0px;">true</span>);<span class="hljs-comment" style="margin:0px;padding:0px;">//显示Progressbar的箭头</span>

        <span class="hljs-comment" style="margin:0px;padding:0px;">//经过一系列的计算，spinner控制下拉的最大距离</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> originalDragPercent = overscrollTop / mTotalDragDistance;
        <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> dragPercent = Math.min(<span class="hljs-number" style="margin:0px;padding:0px;">1</span>f, Math.abs(originalDragPercent));
        <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> adjustedPercent = (<span class="hljs-keyword" style="margin:0px;padding:0px;">float</span>) Math.max(dragPercent - <span class="hljs-number" style="margin:0px;padding:0px;">.4</span>, <span class="hljs-number" style="margin:0px;padding:0px;">0</span>) * <span class="hljs-number" style="margin:0px;padding:0px;">5</span> / <span class="hljs-number" style="margin:0px;padding:0px;">3</span>;
        <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> extraOS = Math.abs(overscrollTop) - mTotalDragDistance;
        <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> slingshotDist = mUsingCustomStart ? mSpinnerFinalOffset - mOriginalOffsetTop
                : mSpinnerFinalOffset;
        <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> tensionSlingshotPercent = Math.max(<span class="hljs-number" style="margin:0px;padding:0px;">0</span>, Math.min(extraOS, slingshotDist * <span class="hljs-number" style="margin:0px;padding:0px;">2</span>)
                / slingshotDist);
        <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> tensionPercent = (<span class="hljs-keyword" style="margin:0px;padding:0px;">float</span>) ((tensionSlingshotPercent / <span class="hljs-number" style="margin:0px;padding:0px;">4</span>) - Math.pow(
                (tensionSlingshotPercent / <span class="hljs-number" style="margin:0px;padding:0px;">4</span>), <span class="hljs-number" style="margin:0px;padding:0px;">2</span>)) * <span class="hljs-number" style="margin:0px;padding:0px;">2</span>f;
        <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> extraMove = (slingshotDist) * tensionPercent * <span class="hljs-number" style="margin:0px;padding:0px;">2</span>;

        <span class="hljs-comment" style="margin:0px;padding:0px;">//计算spinner将要（target）被移动到的位置对应的Y坐标,当targetY为0时，小圆圈刚好全部露出来</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> targetY = mOriginalOffsetTop + (<span class="hljs-keyword" style="margin:0px;padding:0px;">int</span>) ((slingshotDist * dragPercent) + extraMove);
        <span class="hljs-comment" style="margin:0px;padding:0px;">// where 1.0f is a full circle</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mCircleView.getVisibility() != View.VISIBLE) {
            mCircleView.setVisibility(View.VISIBLE);
        }
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (!mScale) {
            ViewCompat.setScaleX(mCircleView, <span class="hljs-number" style="margin:0px;padding:0px;">1</span>f);
            ViewCompat.setScaleY(mCircleView, <span class="hljs-number" style="margin:0px;padding:0px;">1</span>f);
        }
        <span class="hljs-comment" style="margin:0px;padding:0px;">//以下这对if-else主要是在通过下拉进度，对mProgress在下拉过程设置颜色透明度，箭头旋转角度，缩放大小的控制</span>
        <span class="hljs-comment" style="margin:0px;padding:0px;">//如果下拉高度小于mTotalDragDistance（一个触发下拉刷新的高度）</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (overscrollTop &lt; mTotalDragDistance) {
            <span class="hljs-comment" style="margin:0px;padding:0px;">//如果支持下拉小圆圈缩放，设置颜色透明度和缩放大小</span>
            <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mScale) {
                setAnimationProgress(overscrollTop / mTotalDragDistance);
            }
            <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mProgress.getAlpha() &gt; STARTING_PROGRESS_ALPHA
                    &amp;&amp; !isAnimationRunning(mAlphaStartAnimation)) {
                <span class="hljs-comment" style="margin:0px;padding:0px;">// Animate the alpha</span>
                startProgressAlphaStartAnimation();
            }
            <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> strokeStart = adjustedPercent * <span class="hljs-number" style="margin:0px;padding:0px;">.8</span>f;
            mProgress.setStartEndTrim(<span class="hljs-number" style="margin:0px;padding:0px;">0</span>f, Math.min(MAX_PROGRESS_ANGLE, strokeStart));
            mProgress.setArrowScale(Math.min(<span class="hljs-number" style="margin:0px;padding:0px;">1</span>f, adjustedPercent));
        } <span class="hljs-keyword" style="margin:0px;padding:0px;">else</span> {<!-- --><span class="hljs-comment" style="margin:0px;padding:0px;">//下拉高度达到了触发刷新的高度</span>
            <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mProgress.getAlpha() &lt; MAX_ALPHA &amp;&amp; !isAnimationRunning(mAlphaMaxAnimation)) {
                <span class="hljs-comment" style="margin:0px;padding:0px;">// Animate the alpha</span>
                startProgressAlphaMaxAnimation();
            }

            ViewCompat.setScaleX(mCircleView, <span class="hljs-number" style="margin:0px;padding:0px;">1</span>f);
            ViewCompat.setScaleY(mCircleView, <span class="hljs-number" style="margin:0px;padding:0px;">1</span>f);
        }
        <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> rotation = (-<span class="hljs-number" style="margin:0px;padding:0px;">0.25</span>f + <span class="hljs-number" style="margin:0px;padding:0px;">.4</span>f * adjustedPercent + tensionPercent * <span class="hljs-number" style="margin:0px;padding:0px;">2</span>) * <span class="hljs-number" style="margin:0px;padding:0px;">.5</span>f;
        mProgress.setProgressRotation(rotation);

        <span class="hljs-comment" style="margin:0px;padding:0px;">//这是关键调用！动态设置mSpinner的高度。进入该函数看看</span>
        setTargetOffsetTopAndBottom(targetY - mCurrentTargetOffsetTop, <span class="hljs-keyword" style="margin:0px;padding:0px;">true</span> <span class="hljs-comment" style="margin:0px;padding:0px;">/* requires update */</span>);
    }</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li><li style="color:rgb(153,153,153);">7</li><li style="color:rgb(153,153,153);">8</li><li style="color:rgb(153,153,153);">9</li><li style="color:rgb(153,153,153);">10</li><li style="color:rgb(153,153,153);">11</li><li style="color:rgb(153,153,153);">12</li><li style="color:rgb(153,153,153);">13</li><li style="color:rgb(153,153,153);">14</li><li style="color:rgb(153,153,153);">15</li><li style="color:rgb(153,153,153);">16</li><li style="color:rgb(153,153,153);">17</li><li style="color:rgb(153,153,153);">18</li><li style="color:rgb(153,153,153);">19</li><li style="color:rgb(153,153,153);">20</li><li style="color:rgb(153,153,153);">21</li><li style="color:rgb(153,153,153);">22</li><li style="color:rgb(153,153,153);">23</li><li style="color:rgb(153,153,153);">24</li><li style="color:rgb(153,153,153);">25</li><li style="color:rgb(153,153,153);">26</li><li style="color:rgb(153,153,153);">27</li><li style="color:rgb(153,153,153);">28</li><li style="color:rgb(153,153,153);">29</li><li style="color:rgb(153,153,153);">30</li><li style="color:rgb(153,153,153);">31</li><li style="color:rgb(153,153,153);">32</li><li style="color:rgb(153,153,153);">33</li><li style="color:rgb(153,153,153);">34</li><li style="color:rgb(153,153,153);">35</li><li style="color:rgb(153,153,153);">36</li><li style="color:rgb(153,153,153);">37</li><li style="color:rgb(153,153,153);">38</li><li style="color:rgb(153,153,153);">39</li><li style="color:rgb(153,153,153);">40</li><li style="color:rgb(153,153,153);">41</li><li style="color:rgb(153,153,153);">42</li><li style="color:rgb(153,153,153);">43</li><li style="color:rgb(153,153,153);">44</li><li style="color:rgb(153,153,153);">45</li><li style="color:rgb(153,153,153);">46</li><li style="color:rgb(153,153,153);">47</li><li style="color:rgb(153,153,153);">48</li><li style="color:rgb(153,153,153);">49</li><li style="color:rgb(153,153,153);">50</li><li style="color:rgb(153,153,153);">51</li><li style="color:rgb(153,153,153);">52</li><li style="color:rgb(153,153,153);">53</li><li style="color:rgb(153,153,153);">54</li><li style="color:rgb(153,153,153);">55</li><li style="color:rgb(153,153,153);">56</li><li style="color:rgb(153,153,153);">57</li><li style="color:rgb(153,153,153);">58</li><li style="color:rgb(153,153,153);">59</li><li style="color:rgb(153,153,153);">60</li><li style="color:rgb(153,153,153);">61</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">该方法主要干的事就是通过调用setTargetOffsetTopAndBottom()方法移动下拉组件Spinner（mCircleView），同时更新mProgress（一个drawable）的绘制进度。其中进行了一些复杂的运算，其实就是在控制下拉的最大高度，避免用户无限下拉…说明一下，这个mScale，因为我已经添加了javadoc，读者Ctrl+Q就可以查看它的相关信息。它觉得spinner下拉过程是否支持缩放，可以通过setProgressViewEndTarget()和setProgressViewOffset()设置。但我发现一个bug，如果手指下拉过快，小圆就会来不及放到最大…小圆明显变小了，如图 <br><img src="https://images2.imgbox.com/56/59/1q7g6qFG_o.gif" alt="这里写图片描述" title="" style="border:0px;margin-top:24px;margin-bottom:24px;"> <br>好，有改bug的希望就有了继续阅读的动力！我们进入setTargetOffsetTopAndBottom()看看。</p> 
<ul style="list-style:none;color:rgb(69,69,69);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><li style="padding:0px;">setTargetOffsetAndBottom</li></ul> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">    <span class="hljs-javadoc" style="margin:0px;padding:0px;">/**
     * 设置mCircleView的偏移量
     * 同时更新mCurrentTargetOffsetTop
     *<span class="hljs-javadoctag" style="margin:0px;padding:0px;"> @param</span> offset 偏移量，可正可负
     *<span class="hljs-javadoctag" style="margin:0px;padding:0px;"> @param</span> requiresUpdate 界面是否需要重绘invalidate();
     */</span>
    <span class="hljs-keyword" style="margin:0px;padding:0px;">private</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">setTargetOffsetTopAndBottom</span>(<span class="hljs-keyword" style="margin:0px;padding:0px;">int</span> offset, <span class="hljs-keyword" style="margin:0px;padding:0px;">boolean</span> requiresUpdate) {
        <span class="hljs-comment" style="margin:0px;padding:0px;">//bringToFront()该方法会调用requestLayout()和invalidate()把view放到前面</span>
        <span class="hljs-comment" style="margin:0px;padding:0px;">//已经重写了getChildDrawingOrder方法，所以没有必要再调用该方法了，我个人认为...</span>
        <span class="hljs-comment" style="margin:0px;padding:0px;">//可通过手动调用invalidate()来代替它</span>
<span class="hljs-comment" style="margin:0px;padding:0px;">//        mCircleView.bringToFront();</span>
        mCircleView.offsetTopAndBottom(offset);
        mCurrentTargetOffsetTop = mCircleView.getTop();
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (requiresUpdate <span class="hljs-comment" style="margin:0px;padding:0px;">/*&amp;&amp; android.os.Build.VERSION.SDK_INT &lt; 11*/</span>) {
            invalidate();
        }
    }</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li><li style="color:rgb(153,153,153);">7</li><li style="color:rgb(153,153,153);">8</li><li style="color:rgb(153,153,153);">9</li><li style="color:rgb(153,153,153);">10</li><li style="color:rgb(153,153,153);">11</li><li style="color:rgb(153,153,153);">12</li><li style="color:rgb(153,153,153);">13</li><li style="color:rgb(153,153,153);">14</li><li style="color:rgb(153,153,153);">15</li><li style="color:rgb(153,153,153);">16</li><li style="color:rgb(153,153,153);">17</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">该方法很短，却是mCircleView能够下拉的精髓所在啊！offsetTopAndBottom()本质上是调用layout(getLeft(),getTop()+offsetY,getRight(),getBottom()+offsetY);（注意不是onLayout()）同时对mCircleView的top和bottom进行偏移，offset是View整体在垂直方向上的偏移量。这里我把bringToFront()注释掉，bringToFront()该方法会调用requestLayout()和invalidate()把view放到前面，因为已经重写了getChildDrawingOrder方法，所以没有必要再调用该方法了，我个人认为…可通过手动调用invalidate()来代替它。</p> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-weight:700;">到此，我们已经了解过它下拉的的过程，下面进行回溯到onTouchEvent的case MotionEvent.ACTION_UP:</span></p> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">            <span class="hljs-keyword" style="margin:0px;padding:0px;">case</span> MotionEvent.ACTION_UP: {
                pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (pointerIndex &lt; <span class="hljs-number" style="margin:0px;padding:0px;">0</span>) {
                    Log.e(LOG_TAG, <span class="hljs-string" style="margin:0px;padding:0px;">"Got ACTION_UP event but don't have an active pointer id."</span>);
                    <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                }

                <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> y = MotionEventCompat.getY(ev, pointerIndex);
                <span class="hljs-comment" style="margin:0px;padding:0px;">//计算松开手时下拉的总距离</span>
                <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> overscrollTop = (y - mInitialMotionY) * DRAG_RATE;
                mIsBeingDragged = <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
                <span class="hljs-comment" style="margin:0px;padding:0px;">//关键方法，进去看看</span>
                finishSpinner(overscrollTop);
                mActivePointerId = INVALID_POINTER;
                <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
            }</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li><li style="color:rgb(153,153,153);">7</li><li style="color:rgb(153,153,153);">8</li><li style="color:rgb(153,153,153);">9</li><li style="color:rgb(153,153,153);">10</li><li style="color:rgb(153,153,153);">11</li><li style="color:rgb(153,153,153);">12</li><li style="color:rgb(153,153,153);">13</li><li style="color:rgb(153,153,153);">14</li><li style="color:rgb(153,153,153);">15</li><li style="color:rgb(153,153,153);">16</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">计算完了松开手时下拉的总距离后，交给方法finishSpinner(overscrollTop);处理。进去看看。</p> 
<ul style="list-style:none;color:rgb(69,69,69);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><li style="padding:0px;">finishSpinner(overscrollTop)</li></ul> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">    <span class="hljs-javadoc" style="margin:0px;padding:0px;">/**
     * 手指松开后，处理下拉组件Spinner
     * 设置开始刷新的动画，或者
     * 将下拉组件Spinner回滚隐藏
     *<span class="hljs-javadoctag" style="margin:0px;padding:0px;"> @param</span> overscrollTop 下拉距离
     */</span>
    <span class="hljs-keyword" style="margin:0px;padding:0px;">private</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">finishSpinner</span>(<span class="hljs-keyword" style="margin:0px;padding:0px;">float</span> overscrollTop) {
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (overscrollTop &gt; mTotalDragDistance) {<!-- --><span class="hljs-comment" style="margin:0px;padding:0px;">//下拉距离达到了可触发刷新的高度</span>
            <span class="hljs-comment" style="margin:0px;padding:0px;">//关键方法</span>
            setRefreshing(<span class="hljs-keyword" style="margin:0px;padding:0px;">true</span>, <span class="hljs-keyword" style="margin:0px;padding:0px;">true</span> <span class="hljs-comment" style="margin:0px;padding:0px;">/* notify */</span>);
        } <span class="hljs-keyword" style="margin:0px;padding:0px;">else</span> {<!-- --><span class="hljs-comment" style="margin:0px;padding:0px;">//下拉距离还未达到了可触发刷新的高度，做一些复位的操作</span>
            <span class="hljs-comment" style="margin:0px;padding:0px;">// cancel refresh</span>
            mRefreshing = <span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>;
            mProgress.setStartEndTrim(<span class="hljs-number" style="margin:0px;padding:0px;">0</span>f, <span class="hljs-number" style="margin:0px;padding:0px;">0</span>f);
            <span class="hljs-comment" style="margin:0px;padding:0px;">//值得关注的是这个回滚动画</span>
            AnimationListener listener = <span class="hljs-keyword" style="margin:0px;padding:0px;">null</span>;
            <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (!mScale) {
                listener = <span class="hljs-keyword" style="margin:0px;padding:0px;">new</span> AnimationListener() {
                    <span class="hljs-annotation" style="margin:0px;padding:0px;">@Override</span>
                    <span class="hljs-keyword" style="margin:0px;padding:0px;">public</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">onAnimationEnd</span>(Animation animation) {
                        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (!mScale) {
                            startScaleDownAnimation(<span class="hljs-keyword" style="margin:0px;padding:0px;">null</span>);
                        }
                    }
                };
            }
            <span class="hljs-comment" style="margin:0px;padding:0px;">//开始回滚动画</span>
            <span class="hljs-comment" style="margin:0px;padding:0px;">//这是一个比较复杂的方法，也是比较有用的方法</span>
            <span class="hljs-comment" style="margin:0px;padding:0px;">//其实这个本质上不是开启一个动画，而是一个数值产生器</span>
            <span class="hljs-comment" style="margin:0px;padding:0px;">//通过监听数值变化，</span>
            <span class="hljs-comment" style="margin:0px;padding:0px;">//从mCurrentTargetOffsetTop这个高度开始，</span>
            <span class="hljs-comment" style="margin:0px;padding:0px;">//调用setTargetOffsetTopAndBottom()慢慢回滚到mOriginalOffsetTop</span>
            animateOffsetToStartPosition(mCurrentTargetOffsetTop, listener);
            mProgress.showArrow(<span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>);
        }
    }</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li><li style="color:rgb(153,153,153);">7</li><li style="color:rgb(153,153,153);">8</li><li style="color:rgb(153,153,153);">9</li><li style="color:rgb(153,153,153);">10</li><li style="color:rgb(153,153,153);">11</li><li style="color:rgb(153,153,153);">12</li><li style="color:rgb(153,153,153);">13</li><li style="color:rgb(153,153,153);">14</li><li style="color:rgb(153,153,153);">15</li><li style="color:rgb(153,153,153);">16</li><li style="color:rgb(153,153,153);">17</li><li style="color:rgb(153,153,153);">18</li><li style="color:rgb(153,153,153);">19</li><li style="color:rgb(153,153,153);">20</li><li style="color:rgb(153,153,153);">21</li><li style="color:rgb(153,153,153);">22</li><li style="color:rgb(153,153,153);">23</li><li style="color:rgb(153,153,153);">24</li><li style="color:rgb(153,153,153);">25</li><li style="color:rgb(153,153,153);">26</li><li style="color:rgb(153,153,153);">27</li><li style="color:rgb(153,153,153);">28</li><li style="color:rgb(153,153,153);">29</li><li style="color:rgb(153,153,153);">30</li><li style="color:rgb(153,153,153);">31</li><li style="color:rgb(153,153,153);">32</li><li style="color:rgb(153,153,153);">33</li><li style="color:rgb(153,153,153);">34</li><li style="color:rgb(153,153,153);">35</li><li style="color:rgb(153,153,153);">36</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">这里看到的mTotalDragDistance同样可以通过Ctrl+Q查看它的信息。这个方法只有一对大大的if-else，如果下拉距离达到了可触发刷新的高度，开始刷新；否则开始回滚动画，将Spinner回滚到开始的位置（也就是mOriginalOffsetTop）。而animateOffsetToStartPosition这个方法是一个内涵很丰富的方法，涉及到多步跳转才能了解彻底。大家可以去<a href="https://github.com/TellH/Android_PullToRefreshLibrary_Collection" style="margin:0px;padding:0px;">github</a> fork下来，找到相应方法Ctrl+左击进去看看，里面的方法都添加了详细的注释，相信大家一定能看懂。有朋友可能会问，这里怎么用视图动画而不用属性动画呢？其实这里并不是开启一个真正意义上的动画，而是一个数值产生器，通过监听数值变化，从mCurrentTargetOffsetTop这个高度开始，调用setTargetOffsetTopAndBottom()慢慢回滚到mOriginalOffsetTop。 <br>下面我们一起来看看setRefreshing(true, true /* notify */);</p> 
<ul style="list-style:none;color:rgb(69,69,69);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><li style="padding:0px;">setRefreshing(true, true /* notify */)</li></ul> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">    <span class="hljs-javadoc" style="margin:0px;padding:0px;">/**
     * 设置刷新状态，该方法通常不是由类库使用者来调用，而是在用户下拉的时候由SwipeRefreshLayout来调用
     *<span class="hljs-javadoctag" style="margin:0px;padding:0px;"> @param</span> refreshing 是否刷新
     *<span class="hljs-javadoctag" style="margin:0px;padding:0px;"> @param</span> notify 是否回调onRefresh()
     */</span>
    <span class="hljs-keyword" style="margin:0px;padding:0px;">private</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">setRefreshing</span>(<span class="hljs-keyword" style="margin:0px;padding:0px;">boolean</span> refreshing, <span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">boolean</span> notify) {
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mRefreshing != refreshing) {
            mNotify = notify;
            ensureTarget();
            mRefreshing = refreshing;
            <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mRefreshing) {<!-- --><span class="hljs-comment" style="margin:0px;padding:0px;">//启动刷新</span>
                animateOffsetToCorrectPosition(mCurrentTargetOffsetTop, mRefreshListener);
            } <span class="hljs-keyword" style="margin:0px;padding:0px;">else</span> {<!-- --><span class="hljs-comment" style="margin:0px;padding:0px;">//停止刷新</span>
                <span class="hljs-comment" style="margin:0px;padding:0px;">//开始Spinner消失动画</span>
                startScaleDownAnimation(mRefreshListener);
            }
        }
    }</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li><li style="color:rgb(153,153,153);">7</li><li style="color:rgb(153,153,153);">8</li><li style="color:rgb(153,153,153);">9</li><li style="color:rgb(153,153,153);">10</li><li style="color:rgb(153,153,153);">11</li><li style="color:rgb(153,153,153);">12</li><li style="color:rgb(153,153,153);">13</li><li style="color:rgb(153,153,153);">14</li><li style="color:rgb(153,153,153);">15</li><li style="color:rgb(153,153,153);">16</li><li style="color:rgb(153,153,153);">17</li><li style="color:rgb(153,153,153);">18</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">该方法通常不是由类库使用者来调用，而是在用户下拉的时候由SwipeRefreshLayout自己来调用，所以它是private的。如果启动刷新，则调用animateOffsetToCorrectPosition(mCurrentTargetOffsetTop, mRefreshListener);将mCircleView移到正确的高度（也就是mSpinnerFinalOffset），animateOffsetToCorrectPosition()跟上文提到的animateOffsetToStartPosition()方法的实现机理是完全一样的。我们这里回想一下，刚才的bug是由于手指松开时mCircleView的Scale值没有达到1，那么在这里我们就可以在它的移动到刷新位置的动画结束时，把它的Scale手动设置为1。</p> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">    <span class="hljs-keyword" style="margin:0px;padding:0px;">private</span> AnimationListener mRefreshListener = <span class="hljs-keyword" style="margin:0px;padding:0px;">new</span> AnimationListener() {
        <span class="hljs-annotation" style="margin:0px;padding:0px;">@Override</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">public</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">onAnimationEnd</span>(Animation animation) {
            <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mRefreshing) {
                <span class="hljs-comment" style="margin:0px;padding:0px;">//改bug</span>
                ViewCompat.setScaleX(mCircleView, <span class="hljs-number" style="margin:0px;padding:0px;">1</span>f);
                ViewCompat.setScaleY(mCircleView, <span class="hljs-number" style="margin:0px;padding:0px;">1</span>f);
                <span class="hljs-comment" style="margin:0px;padding:0px;">// Make sure the progress view is fully visible</span>
                mProgress.setAlpha(MAX_ALPHA);
                mProgress.start();
                <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mNotify) {
                    <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mListener != <span class="hljs-keyword" style="margin:0px;padding:0px;">null</span>) {
                        mListener.onRefresh();
                    }
                }
            } <span class="hljs-keyword" style="margin:0px;padding:0px;">else</span> {
                mProgress.stop();
                mCircleView.setVisibility(View.GONE);
                setColorViewAlpha(MAX_ALPHA);
                <span class="hljs-comment" style="margin:0px;padding:0px;">// Return the circle to its start position</span>
                <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (mScale) {
                    setAnimationProgress(<span class="hljs-number" style="margin:0px;padding:0px;">0</span> <span class="hljs-comment" style="margin:0px;padding:0px;">/* animation complete and view is hidden */</span>);
                } <span class="hljs-keyword" style="margin:0px;padding:0px;">else</span> {
                    setTargetOffsetTopAndBottom(mOriginalOffsetTop - mCurrentTargetOffsetTop,
                            <span class="hljs-keyword" style="margin:0px;padding:0px;">true</span> <span class="hljs-comment" style="margin:0px;padding:0px;">/* requires update */</span>);
                }
            }
            mCurrentTargetOffsetTop = mCircleView.getTop();
        }
    };</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li><li style="color:rgb(153,153,153);">7</li><li style="color:rgb(153,153,153);">8</li><li style="color:rgb(153,153,153);">9</li><li style="color:rgb(153,153,153);">10</li><li style="color:rgb(153,153,153);">11</li><li style="color:rgb(153,153,153);">12</li><li style="color:rgb(153,153,153);">13</li><li style="color:rgb(153,153,153);">14</li><li style="color:rgb(153,153,153);">15</li><li style="color:rgb(153,153,153);">16</li><li style="color:rgb(153,153,153);">17</li><li style="color:rgb(153,153,153);">18</li><li style="color:rgb(153,153,153);">19</li><li style="color:rgb(153,153,153);">20</li><li style="color:rgb(153,153,153);">21</li><li style="color:rgb(153,153,153);">22</li><li style="color:rgb(153,153,153);">23</li><li style="color:rgb(153,153,153);">24</li><li style="color:rgb(153,153,153);">25</li><li style="color:rgb(153,153,153);">26</li><li style="color:rgb(153,153,153);">27</li><li style="color:rgb(153,153,153);">28</li><li style="color:rgb(153,153,153);">29</li><li style="color:rgb(153,153,153);">30</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">效果还可吧！ <br><img src="https://images2.imgbox.com/9c/b5/wGRaeimj_o.gif" alt="这里写图片描述" title="" style="border:0px;margin-top:24px;margin-bottom:24px;"> <br>我们发现onRefresh()是在这个被回调的，而且仅在这里被回调。</p> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">不知不觉，天亮了~框架脉络已经很清晰了吧。 <br>还有一些变量或方法的名字带有NestedScroll没有提到，其实那是跟嵌套滑动有关的，不知道也不影响源码的阅读。</p> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">下面说说我遇到过的一个问题，当我们在Activity的onCreate中</p> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs avrasm has-numbering">        mRefreshLayout = (SwipeRefreshTestLayout) findViewById(R<span class="hljs-preprocessor" style="margin:0px;padding:0px;">.id</span><span class="hljs-preprocessor" style="margin:0px;padding:0px;">.refresh</span>_widget)<span class="hljs-comment" style="margin:0px;padding:0px;">;</span>
        mRefreshLayout<span class="hljs-preprocessor" style="margin:0px;padding:0px;">.setRefreshing</span>(true)<span class="hljs-comment" style="margin:0px;padding:0px;">;</span></code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li></ul> 
<ul style="list-style:none;color:rgb(69,69,69);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><li style="padding:0px;">延迟调用</li></ul> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">        <span class="hljs-keyword" style="margin:0px;padding:0px;">new</span> Handler().postDelayed(<span class="hljs-keyword" style="margin:0px;padding:0px;">new</span> Runnable() {
            <span class="hljs-annotation" style="margin:0px;padding:0px;">@Override</span>
            <span class="hljs-keyword" style="margin:0px;padding:0px;">public</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">run</span>() {
                mRefreshLayout.setRefreshing(<span class="hljs-keyword" style="margin:0px;padding:0px;">true</span>);
            }
        },<span class="hljs-number" style="margin:0px;padding:0px;">100</span>);</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">或者</p> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">        mRefreshLayout.postDelayed(<span class="hljs-keyword" style="margin:0px;padding:0px;">new</span> Runnable() {
            <span class="hljs-annotation" style="margin:0px;padding:0px;">@Override</span>
            <span class="hljs-keyword" style="margin:0px;padding:0px;">public</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">run</span>() {
                mRefreshLayout.setRefreshing(<span class="hljs-keyword" style="margin:0px;padding:0px;">false</span>);
            }
        }, <span class="hljs-number" style="margin:0px;padding:0px;">3000</span>);</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li></ul> 
<ul style="list-style:none;color:rgb(69,69,69);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><li style="padding:0px;">改在onWindowFocusChanged当中调用 <br>因为回调该函数时Activity处于可见状态，注意如果在onResume中调用还是会没有效果的。</li></ul> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">    <span class="hljs-annotation" style="margin:0px;padding:0px;">@Override</span>
    <span class="hljs-keyword" style="margin:0px;padding:0px;">public</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">onWindowFocusChanged</span>(<span class="hljs-keyword" style="margin:0px;padding:0px;">boolean</span> hasFocus) {
        <span class="hljs-keyword" style="margin:0px;padding:0px;">super</span>.onWindowFocusChanged(hasFocus);
        mRefreshLayout.setRefreshing(<span class="hljs-keyword" style="margin:0px;padding:0px;">true</span>);
    }</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li></ul> 
<ul style="list-style:none;color:rgb(69,69,69);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><li style="padding:0px;">既然我们已经是看过源码的人了，能不能在setRefreshing的源码中解决这个问题呢？ <br>这是我自己的脑洞方案：</li></ul> 
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">    <span class="hljs-keyword" style="margin:0px;padding:0px;">public</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">setRefreshing</span>(<span class="hljs-keyword" style="margin:0px;padding:0px;">final</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">boolean</span> refreshing) {
        <span class="hljs-comment" style="margin:0px;padding:0px;">//防止类库使用者在SwipeRefreshLayout还没完全被初始化时调用该方法</span>
        <span class="hljs-comment" style="margin:0px;padding:0px;">//还是建议使用者重写Activity的onWindowFocusChanged()方法来调用setRefreshing(true);</span>
        <span class="hljs-keyword" style="margin:0px;padding:0px;">if</span> (!isShown()&amp;&amp; refreshing){
            Log.e(<span class="hljs-string" style="margin:0px;padding:0px;">"SwipeRefreshLayout"</span>, <span class="hljs-string" style="margin:0px;padding:0px;">"It's not advisable to invoke setRefreshing() when SwipeRefreshLayout is inVisible."</span>);
            <span class="hljs-keyword" style="margin:0px;padding:0px;">new</span> Handler().postDelayed(<span class="hljs-keyword" style="margin:0px;padding:0px;">new</span> Runnable() {
                <span class="hljs-annotation" style="margin:0px;padding:0px;">@Override</span>
                <span class="hljs-keyword" style="margin:0px;padding:0px;">public</span> <span class="hljs-keyword" style="margin:0px;padding:0px;">void</span> <span class="hljs-title" style="margin:0px;padding:0px;">run</span>() {
                    setRefreshing(<span class="hljs-keyword" style="margin:0px;padding:0px;">true</span>);
                }
            },<span class="hljs-number" style="margin:0px;padding:0px;">50</span><span class="hljs-comment" style="margin:0px;padding:0px;">/*该时间可以任意设置*/</span>);
            <span class="hljs-keyword" style="margin:0px;padding:0px;">return</span>;
        }
        .....省略若干代码......
     }</code></pre> 
<ul class="pre-numbering"><li style="color:rgb(153,153,153);">1</li><li style="color:rgb(153,153,153);">2</li><li style="color:rgb(153,153,153);">3</li><li style="color:rgb(153,153,153);">4</li><li style="color:rgb(153,153,153);">5</li><li style="color:rgb(153,153,153);">6</li><li style="color:rgb(153,153,153);">7</li><li style="color:rgb(153,153,153);">8</li><li style="color:rgb(153,153,153);">9</li><li style="color:rgb(153,153,153);">10</li><li style="color:rgb(153,153,153);">11</li><li style="color:rgb(153,153,153);">12</li><li style="color:rgb(153,153,153);">13</li><li style="color:rgb(153,153,153);">14</li><li style="color:rgb(153,153,153);">15</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">项目代码已上传至Github。—<a href="https://github.com/TellH/Android_PullToRefreshLibrary_Collection" style="margin:0px;padding:0px;">repo</a></p> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">点star和转发也是一种支持！</p> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">如果你发现有什么不清楚或不妥的地方欢迎留言讨论。</p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da597eb2229617aac1802c63c0754b4a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows小技巧5--如何通过vb脚本实现Chrome浏览器页面自动切换和刷新的功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e339e77e9f4909779e401c54d5445e2d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">本地存储localStorage用法详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>