<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python中__init__.py文件的作用详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python中__init__.py文件的作用详解" />
<meta property="og:description" content="init.py 文件 init.py 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有__init__.py 文件。
通常__init__.py 文件为空，但是我们还可以为它增加其他的功能。我们在导入一个包时，实际上是导入了它的__init__.py文件。这样我们可以在__init__.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入。
# package # __init__.py import re import urllib import sys import os # a.py import package print(package.re, package.urllib, package.sys, package.os) 注意这里访问__init__.py文件中的引用文件，需要加上包名。
init.py中还有一个重要的变量：** all **, 它用来将模块全部导入。
# __init__.py __all__ = [&#39;os&#39;, &#39;sys&#39;, &#39;re&#39;, &#39;urllib&#39;] # a.py from package import * 这时就会把注册在__init__.py文件中__all__列表中的模块和包导入到当前文件中来。
可以了解到，init.py主要控制包的导入行为。要想清楚理解__init__.py文件的作用，还需要详细了解一下import语句引用机制：
可以被import语句导入的对象是以下类型：
模块文件（.py文件）C或C&#43;&#43;扩展（已编译为共享库或DLL文件）包（包含多个模块）内建模块（使用C编写并已链接到Python解释器中） 当导入模块时，解释器按照sys.path列表中的目录顺序来查找导入文件。
import sys &gt;&gt;&gt; print(sys.path) # Linux: [&#39;&#39;, &#39;/usr/local/lib/python3.4&#39;, &#39;/usr/local/lib/python3.4/plat-sunos5&#39;, &#39;/usr/local/lib/python3.4/lib-tk&#39;, &#39;/usr/local/lib/python3.4/lib-dynload&#39;, &#39;/usr/local/lib/python3.4/site-packages&#39;] # Windows: path列表 目录顺序 # 第一个元素空字符串代表当前目录 [&#39;&#39;, &#39;C:\\WINDOWS\\system32\\python34." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/60456593d51b07542747e14e06ea9de6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-07T14:52:33+08:00" />
<meta property="article:modified_time" content="2022-05-07T14:52:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python中__init__.py文件的作用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="__init__py__0"></a><strong>init</strong>.py 文件</h2> 
<p><strong>init</strong>.py 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有__init__.py 文件。<br> 通常__init__.py 文件为空，但是我们还可以为它增加其他的功能。我们在导入一个包时，实际上是导入了它的__init__.py文件。这样我们可以在__init__.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入。</p> 
<pre><code># package
# __init__.py
import re
import urllib
import sys
import os
# a.py
import package 
print(package.re, package.urllib, package.sys, package.os)
</code></pre> 
<p>注意这里访问__init__.py文件中的<strong>引用文件</strong>，需要加上<strong>包名</strong>。</p> 
<p><strong>init</strong>.py中还有一个<strong>重要</strong>的变量：** <strong>all</strong> **, 它用来将模块全部导入。</p> 
<pre><code># __init__.py
__all__ = ['os', 'sys', 're', 'urllib']    

# a.py
from package import *
</code></pre> 
<p>这时就会把注册在__init__.py文件中__all__列表中的模块和包导入到当前文件中来。<br> 可以了解到，<strong>init</strong>.py主要控制包的导入行为。要想清楚理解__init__.py文件的作用，还需要详细了解一下import语句引用机制：<br> 可以被import语句导入的对象是以下类型：</p> 
<ul><li>模块文件（.py文件）</li><li>C或C++扩展（已编译为共享库或DLL文件）</li><li>包（包含多个模块）</li><li>内建模块（使用C编写并已链接到Python解释器中）</li></ul> 
<p><strong>当导入模块</strong>时，解释器按照<strong>sys.path</strong>列表中的<strong>目录顺序</strong>来查找导入文件。</p> 
<pre><code>import sys
&gt;&gt;&gt; print(sys.path)
# Linux:
['', '/usr/local/lib/python3.4',
'/usr/local/lib/python3.4/plat-sunos5',
'/usr/local/lib/python3.4/lib-tk',
'/usr/local/lib/python3.4/lib-dynload',
'/usr/local/lib/python3.4/site-packages']

# Windows:    path列表  目录顺序
#  第一个元素空字符串代表当前目录
['',            
'C:\\WINDOWS\\system32\\python34.zip', 
'C:\\Documents and Settings\\weizhong', 
'C:\\Python34\\DLLs', 
'C:\\Python34\\lib', 
'C:\\Python34\\lib\\plat-win', 
'C:\\Python34\\lib\\lib-tk', 
'C:\\Python34\\Lib\\site-packages\\pythonwin', 
'C:\\Python34', 
'C:\\Python34\\lib\\site-packages', 
'C:\\Python34\\lib\\site-packages\\win32', 
'C:\\Python34\\lib\\site-packages\\win32\\lib', 
'C:\\Python34\\lib\\site-packages\\wx-2.6-msw-unicode']

&gt;&gt;&gt;sys.path.append("../MvImport")          # 添加访问路径   即：import的访问路径
</code></pre> 
<p><strong>注意，list第一个元素空字符串代表当前目录</strong>。</p> 
<h2><a id="pyc___pyo__70"></a>关于.pyc 文件 与 .pyo 文件</h2> 
<p>.py文件的汇编过程，只有在import语句执行时进行。当.py文件第一次被导入时，它会被汇编为字节代码，并将字节码写入<strong>同名的.pyc</strong>文件中。后来每次导入操作都会直接执行.pyc 文件（当.py文件的修改时间发生改变，这样会生成新的.pyc文件），在<strong>解释器</strong>使用**-O选项<strong>时，将使用</strong>同名的.pyo**文件，这个文件去掉了断言（assert）、断行号以及其他调试信息，体积更小，运行更快。（使用-OO选项，生成的.pyo文件会忽略文档信息）</p> 
<h2><a id="_74"></a>导入模块</h2> 
<p>模块通常为单独的.py文件，可以用import直接引用，可以作为<strong>模块的文件类型</strong>有** .py、.pyo、.pyc、.pyd、.so、.dll **<br> 在导入模块时，解释器做以下工作：</p> 
<ol><li>已导入模块的名称<strong>创建新的命名空间</strong>，通过该命名空间就可以访问导入模块的属性和方法。</li><li>在新创建的命名空间中执行源代码文件。</li><li><strong>创建</strong>一个名为<strong>源代码文件的对象</strong>，该对象引用模块的名字空间，这样就可以通过这个对象访问模块中的函数及变量</li></ol> 
<p><strong>import 语句</strong>可以在程序的<strong>任何位置使用</strong>，你可以在程序中<strong>多次导入同一个</strong>模块，但模块中的代码<strong>仅在</strong>该模块被<strong>首次导入</strong>时执行。后面的import语句只是简单的创建一个到模块名字空间的引用而已。</p> 
<p><strong>sys.modules</strong>字典中保存着所有被导入模块的模块名到模块对象的映射。</p> 
<h2><a id="_86"></a>导入包</h2> 
<p><strong>多个相关联的模块</strong>组成<strong>一个包</strong>，以便于维护和使用，同时能有限的避免命名空间的冲突。一般来说，包的结构可以是这样的：</p> 
<pre><code>package
|- subpackage1
|- __init__.py
|- a.py
|- subpackage2
|- __init__.py
|- b.py
</code></pre> 
<p>有以下几种导入方式：</p> 
<pre><code>import subpackage1.a 
# 将模块subpackage.a导入全局命名空间，例如访问a中属性时用subpackage1.a.attr     注意，使用import的方式，使用a模块时 需要加包名

from subpackage1 import a 
#　将模块a导入全局命名空间，例如访问a中属性时用a.attr_a     注意，使用from import的导入方式，使用a模块时 不需要加包名

from subpackage.a import attr_a 
# 将模块a的属性直接导入到命名空间中，例如访问a中属性时直接用attr_a 

## 使用from语句可以把模块直接导入当前命名空间，from语句并 **不引用导入对象的命名空间**，而是将被导入对象直接引入**当前命名空间**。
</code></pre> 
<p>注意 import方式和form import方式的区别！！</p> 
<p>使用from import语句可以把模块直接导入当前命名空间，from语句并 <strong>不引用导入对象的命名空间</strong>，而是将被导入对象直接引入<strong>当前命名空间</strong>，这就是form import方式不需要加包（或者模块）名称的原理。</p> 
<p>值得注意，最好使用模块名称和包名，因为这样可以防止命名冲突！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/15b4bc851e841594a94c919696f3d295/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用于文本去重（相似度计算）的Simhash算法学习及python实现（持续学习中）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59d678dee25c89f99a4fca718f1166d9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大文件分片上传、断点上传</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>