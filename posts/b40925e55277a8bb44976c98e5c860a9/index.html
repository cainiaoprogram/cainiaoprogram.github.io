<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java Runnable，Callable和FutureTask详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java Runnable，Callable和FutureTask详解" />
<meta property="og:description" content="目 录
1 序言
2 基本概念
2.1 Runnable 和 Callable的区别
2.2 Future 和 FutureTask
2.3 ExecutorService中Future的应用
2.4 Future submit(Runnable task)
2.5 Future submit(Callable task)
2.6 ExecutorService中execute()在ThreadPoolExecutor中实现如下：
3 Future，RunnableFuture，FutureTask 关系
4 总结
参考文献
1 序言 本文针对多线程中使用的几种任务：Runnable、Callable、RunnableFuture，FutureTask等进行详细介绍
2 基本概念 2.1 Runnable 和 Callable的区别 Runnable和Callable都是定义了接口，可以用在线程池中异步执行，区别是：
Runnable可以直接被Thread执行，但是没有返回值Callable执行之后有返回值，但是只能提交给线程池执行。 2.2 Future 和 FutureTask Future是一个接口，主要是线程池中任务执行之后用于返回结果的获取，定义了
boolean cancel(boolean mayInterruptIfRunning); 取消任务boolean isCancelled(); 任务是否取消boolean isDone(); 任务是否执行完毕V get(); 获取任务执行的结果，注意这个方法阻塞线程V get(long timeout, TimeUnit unit)； 同上，只是增加了一个超时时间 Future有一个直接继承接口RunnableFuture，RunnableFuture有一个实现的子类FutureTask，RunnableFuture这个接口同时还继承了Runnable接口，这意味着FutureTask可以作为Future或者Runnable使用。
再来看一下FutureTask的实现，最终内部保存了一个Callable对象，也就是提交的任务
先看构造函数
一共2个构造函数，一个是接受Callable，一个是接受Runnable和默认返回值。
详细看一下第二个构造参数，注释很清楚的说明，当你需要runnable可取消同时不关心返回值时，可以这样构建
上面两个函数将一个Runnable适配成了一个Callable，是Executors中提供的静态方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b40925e55277a8bb44976c98e5c860a9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-05T12:09:19+08:00" />
<meta property="article:modified_time" content="2023-08-05T12:09:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java Runnable，Callable和FutureTask详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc" style="text-align:center;"><strong>目 录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1%20%E5%BA%8F%E8%A8%80-toc" style="margin-left:0px;"><a href="#1%20%E5%BA%8F%E8%A8%80" rel="nofollow">1 序言</a></p> 
<p id="2%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#2%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">2 基本概念</a></p> 
<p id="2.1%20Runnable%20%E5%92%8C%20Callable%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#2.1%20Runnable%20%E5%92%8C%20Callable%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">2.1 Runnable 和 Callable的区别</a></p> 
<p id="2.2%20Future%20%E5%92%8C%20FutureTask-toc" style="margin-left:40px;"><a href="#2.2%20Future%20%E5%92%8C%20FutureTask" rel="nofollow">2.2 Future 和 FutureTask</a></p> 
<p id="2.3%20ExecutorService%E4%B8%ADFuture%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.3%20ExecutorService%E4%B8%ADFuture%E7%9A%84%E5%BA%94%E7%94%A8" rel="nofollow">2.3 ExecutorService中Future的应用</a></p> 
<p id="2.4%20Future%20submit(Runnable%20task)-toc" style="margin-left:40px;"><a href="#2.4%20Future%20submit%28Runnable%20task%29" rel="nofollow">2.4 Future submit(Runnable task)</a></p> 
<p id="2.5%20Future%20submit(Callable%20task)-toc" style="margin-left:40px;"><a href="#2.5%20Future%20submit%28Callable%20task%29" rel="nofollow">2.5 Future submit(Callable task)</a></p> 
<p id="2.6%20ExecutorService%E4%B8%ADexecute()%E5%9C%A8ThreadPoolExecutor%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.6%20ExecutorService%E4%B8%ADexecute%28%29%E5%9C%A8ThreadPoolExecutor%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A" rel="nofollow">2.6 ExecutorService中execute()在ThreadPoolExecutor中实现如下：</a></p> 
<p id="3%20Future%EF%BC%8CRunnableFuture%EF%BC%8CFutureTask%20%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#3%20Future%EF%BC%8CRunnableFuture%EF%BC%8CFutureTask%20%E5%85%B3%E7%B3%BB" rel="nofollow">3 Future，RunnableFuture，FutureTask 关系</a></p> 
<p id="4%20%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#4%20%E6%80%BB%E7%BB%93" rel="nofollow">4 总结</a></p> 
<p id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-toc" style="margin-left:0px;"><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" rel="nofollow">参考文献</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%20%E5%BA%8F%E8%A8%80"><strong>1 序言</strong></h2> 
<p>本文针对多线程中使用的几种任务：Runnable、Callable、RunnableFuture，FutureTask等进行详细介绍</p> 
<h2 id="2%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2 基本概念</h2> 
<h3 id="2.1%20Runnable%20%E5%92%8C%20Callable%E7%9A%84%E5%8C%BA%E5%88%AB">2.1 Runnable 和 Callable的区别</h3> 
<p>Runnable和Callable都是定义了接口，可以用在线程池中异步执行，区别是：</p> 
<ul><li>Runnable可以直接被Thread执行，但是没有返回值</li><li>Callable执行之后有返回值，但是只能提交给线程池执行。</li></ul> 
<h3 id="2.2%20Future%20%E5%92%8C%20FutureTask">2.2 Future 和 FutureTask</h3> 
<p>Future是一个接口，主要是线程池中任务执行之后用于返回结果的获取，定义了</p> 
<ul><li>boolean cancel(boolean mayInterruptIfRunning); 取消任务</li><li>boolean isCancelled(); 任务是否取消</li><li>boolean isDone(); 任务是否执行完毕</li><li>V get(); 获取任务执行的结果，注意这个方法阻塞线程</li><li>V get(long timeout, TimeUnit unit)； 同上，只是增加了一个超时时间</li></ul> 
<p>Future有一个直接继承接口RunnableFuture，RunnableFuture有一个实现的子类FutureTask，RunnableFuture这个接口同时还继承了Runnable接口，这意味着FutureTask可以作为Future或者Runnable使用。</p> 
<p>再来看一下FutureTask的实现，最终内部保存了一个Callable对象，也就是提交的任务</p> 
<p>先看构造函数</p> 
<p><img alt="" height="538" src="https://images2.imgbox.com/5a/81/LPNo49wv_o.png" width="858"></p> 
<p> <img alt="" height="342" src="https://images2.imgbox.com/d1/e6/K20Bh0gT_o.png" width="839"></p> 
<p></p> 
<p></p> 
<p>一共2个构造函数，一个是接受Callable，一个是接受Runnable和默认返回值。</p> 
<p>详细看一下第二个构造参数，注释很清楚的说明，当你需要runnable可取消同时不关心返回值时，可以这样构建</p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/d3/be/MEt2sX2t_o.png" width="835"></p> 
<p></p> 
<p>上面两个函数将一个Runnable适配成了一个Callable，是Executors中提供的静态方法。</p> 
<p>再看一下FutureTask对Runnable的实现</p> 
<p><img alt="" height="704" src="https://images2.imgbox.com/66/bc/VBN2uaxd_o.png" width="945"></p> 
<p></p> 
<p>抛开其他的判断条件，其实就是对内部保存的Callable调用了call方法，进行执行并保存结果。这就是FutureTask主要的几个方法，下面有用。</p> 
<h3 id="2.3%20ExecutorService%E4%B8%ADFuture%E7%9A%84%E5%BA%94%E7%94%A8">2.3 ExecutorService中Future的应用</h3> 
<p>上面2点主要是为了给这点做伏笔，现在我们来看为什么ExecutorService中的submit()既可以提交Runnable又可以提交Callable并返回结果，同时看看直接execute() Runnable会有什么不同。</p> 
<h3 id="2.4%20Future%20submit(Runnable%20task)">2.4 Future submit(Runnable task)</h3> 
<p>先来看一下这个方法的实现</p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/4a/a4/F98U7u3I_o.png" width="641"></p> 
<p></p> 
<p>代码上可以很直观的看到，提交的Runnable被newTaskFor()适配成了RunnableFuture。来看一下newTaskFor()这个方法的实现。</p> 
<p>复制代码</p> 
<p><img alt="" height="588" src="https://images2.imgbox.com/73/98/Lzy3NBTp_o.png" width="674"></p> 
<p></p> 
<p>直接是new了一个FutureTask对象，上面我们分析过这种情况，runnable其实是会被适配成一个Callable的。</p> 
<h3 id="2.5%20Future%20submit(Callable%20task)">2.5 Future submit(Callable task)</h3> 
<p>再来看一下这个方法</p> 
<p>复制代码</p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/eb/21/OHptuxUn_o.png" width="684"></p> 
<p></p> 
<p>跟上面的代码简直一摸一样，都是适配成了RunnableFuture。</p> 
<p>看到这里可以明白，提交Runnable时是将Runnable适配成了Callable，也就是submit方法最终都会调用的的是Callable对象。</p> 
<p>上面我们说过RunnableFuture实现了Runnable接口，当他被execute时，肯定是被当作Runnable使用的，看一下两个submit方法最终都是通过execute来执行的。</p> 
<p>上面介绍FutureTask时我们知道，对Runnable的实现FutureTask最后调用的是Callable的call方法。</p> 
<p>到这里可以知道了，</p> 
<ol><li>当我们提交一个Runnable的任务时，首先通过FutureTask的构造函数被适配成了一个Callable对象被保存FutureTask中。</li><li>当任务被执行时，FutureTask又被当作一个Runnable使用，调用了保存在内部的Callable的call方法，任务被执行并返回了结果。</li><li>Runnable被适配成Callable时最终调用的还是自己的run方法。</li></ol> 
<h3 id="2.6%20ExecutorService%E4%B8%ADexecute()%E5%9C%A8ThreadPoolExecutor%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A">2.6 ExecutorService中execute()在ThreadPoolExecutor中实现如下：</h3> 
<p><img alt="" height="849" src="https://images2.imgbox.com/72/6f/lUq51zzb_o.png" width="644"></p> 
<p></p> 
<p>上面注释的意思是：</p> 
<ol><li>当前核心线程数少于corePoolSize是，尝试直接新建Thread用来执行任务。同时校验添加的过程，防止出错。</li><li>任务入队时二次校验是否需要新建线程，判断是否需要回滚等。</li><li>如果任务不能入队则新建非核心线程处理，如果失败那么就拒绝任务。</li></ol> 
<p>这个就是任务具体执行的过程</p> 
<h3 id="3%20Future%EF%BC%8CRunnableFuture%EF%BC%8CFutureTask%20%E5%85%B3%E7%B3%BB">3 Future，RunnableFuture，FutureTask 关系</h3> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/f6/26/J3CX7G11_o.png"></p> 
<p> 再来看构造方法，有两个构造方法如下</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/c3/04/D1hoZw2z_o.png"></p> 
<p></p> 
<p></p> 
<h2 id="4%20%E6%80%BB%E7%BB%93">4 总结</h2> 
<p>主要讲了几个概念Runnable、Callable、Future，RunnableFuture，FutureTask 以及相关的子类，总结如下：</p> 
<ul><li>Runnable可以直接被Thread执行，但是没有返回值</li><li>Callable执行之后有返回值，但是只能提交给线程池执行。</li><li>Future定义了一系列关于任务管理的接口方法</li><li>FutureTask是Future唯一实现类，它也实现了Runnable接口</li><li>线程池submit Callable和Runnable时最终都会转换成FutureTask</li><li>FutureTask被执行时是被当成Runnable使用的，执行了内部保存的Callable的call方法</li></ul> 
<p></p> 
<p><img alt="" height="455" src="https://images2.imgbox.com/2f/5c/VKGeHjQI_o.png" width="926"></p> 
<p></p> 
<p></p> 
<h2 id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</h2> 
<p>https://juejin.cn/post/6844903672736907272<br> https://blog.csdn.net/weixin_34244102/article/details/87973014<br> https://blog.csdn.net/sageyin/article/details/116035166<br> ​</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3901e1b804b811713b4d510f2db5f446/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Jupyter Notebook 7.0 更新远程访问配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/50b869d2d9269170c32235613e7b9a85/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】——内存管理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>