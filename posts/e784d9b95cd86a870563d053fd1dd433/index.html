<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【opencv】两条平行线之间的距离 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【opencv】两条平行线之间的距离" />
<meta property="og:description" content="问题：一张输入图片，图片上有两条平行线，求出这两条平行线之间的距离
解决思路：
1. 对图像中的直线进行细化
2. 提取直线的轮廓坐标
3. 对轮廓上的坐标进行直线集合，从而得到直线方程
4. 计算两条直线之间的距离
参考：
问题来源 http://www.opencvchina.com/thread-854-1-1.html
图像细化 http://blog.csdn.net/qianchenglenger/article/details/19332011
图像轮廓提取 http://blog.csdn.net/augusdi/article/details/9000893
直线拟合 http://blog.csdn.net/zhuoyue08/article/details/6803040
两条直线之间的距离公式3：http://zhidao.baidu.com/link?url=ef_DHNkjyq1qq7VgubX3afL2KIUQIB4ukd3zHGp0zz8iPPKC046azyvG5ltHR-i0WaLI72eO7j0sOJI4wZSE4q
工具：
opencv 2.4.8 &#43; VS2013
代码：
1.头文件 ProcessImage.h
//ProcessImage.h #pragma once #include &lt;opencv2/highgui/highgui.hpp&gt; /* 对输入图像进行细化 * src为输入图像,用cvThreshold函数处理过的8位灰度图像格式，元素中只有0与1,1代表有元素，0代表为空白 * dst为对src细化后的输出图像,格式与src格式相同，调用前需要分配空间，元素中只有0与1,1代表有元素，0代表为空白 * maxIterations限制迭代次数，如果不进行限制，默认为-1，代表不限制迭代次数，直到获得最终结果 */ void thinImage(IplImage* src, IplImage* dst, int maxIterations = -1); 2.代码实现 ProcessImage.cpp //ProcessImage.cpp #include &#34;ProcessImage.h&#34; #include &lt;utility&gt; #include &lt;vector&gt; void thinImage(IplImage* src, IplImage* dst, int maxIterations) { using namespace cv; CvSize size = cvGetSize(src); cvCopy(src, dst);//将src中的内容拷贝到dst中 int count = 0; //记录迭代次数 while (true) { count&#43;&#43;; if (maxIterations !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e784d9b95cd86a870563d053fd1dd433/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-03-10T23:05:42+08:00" />
<meta property="article:modified_time" content="2014-03-10T23:05:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【opencv】两条平行线之间的距离</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px"><strong>问题</strong>：一张输入图片，图片上有两条平行线，求出这两条平行线之间的距离</span></p> 
<p><strong><span style="font-size:18px">解决思路：</span></strong></p> 
<p><span style="font-size:18px">1. 对图像中的直线进行细化</span></p> 
<p><span style="font-size:18px">2. 提取直线的轮廓坐标</span></p> 
<p><span style="font-size:18px">3. 对轮廓上的坐标进行直线集合，从而得到直线方程</span></p> 
<p><span style="font-size:18px">4. 计算两条直线之间的距离</span></p> 
<p><span style="font-size:18px"><strong>参考：</strong></span></p> 
<p><span style="font-size:18px">问题来源 <a target="_blank" href="http://www.opencvchina.com/thread-854-1-1.html" rel="nofollow noopener noreferrer"> http://www.opencvchina.com/thread-854-1-1.html</a><strong><br> </strong></span></p> 
<p><span style="font-size:18px">图像细化 <a target="_blank" href="http://blog.csdn.net/qianchenglenger/article/details/19332011" rel="noopener noreferrer">http://blog.csdn.net/qianchenglenger/article/details/19332011</a></span><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">图像轮廓提取 <a target="_blank" href="http://blog.csdn.net/augusdi/article/details/9000893" rel="noopener noreferrer"> http://blog.csdn.net/augusdi/article/details/9000893</a></span></p> 
<p><span style="font-size:18px">直线拟合 <a target="_blank" href="http://blog.csdn.net/zhuoyue08/article/details/6803040" rel="noopener noreferrer"> http://blog.csdn.net/zhuoyue08/article/details/6803040</a></span></p> 
<p><span style="font-size:18px">两条直线之间的距离公式3：<a target="_blank" href="http://zhidao.baidu.com/link?url=ef_DHNkjyq1qq7VgubX3afL2KIUQIB4ukd3zHGp0zz8iPPKC046azyvG5ltHR-i0WaLI72eO7j0sOJI4wZSE4q" rel="nofollow noopener noreferrer">http://zhidao.baidu.com/link?url=ef_DHNkjyq1qq7VgubX3afL2KIUQIB4ukd3zHGp0zz8iPPKC046azyvG5ltHR-i0WaLI72eO7j0sOJI4wZSE4q</a></span><br> </p> 
<p><span style="font-size:18px"><strong>工具：</strong></span></p> 
<p><span style="font-size:18px"> opencv 2.4.8 + VS2013</span></p> 
<p><strong><span style="font-size:18px">代码：</span></strong></p> 
<p><span style="font-size:18px">1.头文件 ProcessImage.h</span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">//ProcessImage.h
#pragma once
#include &lt;opencv2/highgui/highgui.hpp&gt;

/* 对输入图像进行细化
 * src为输入图像,用cvThreshold函数处理过的8位灰度图像格式，元素中只有0与1,1代表有元素，0代表为空白
 * dst为对src细化后的输出图像,格式与src格式相同，调用前需要分配空间，元素中只有0与1,1代表有元素，0代表为空白
 * maxIterations限制迭代次数，如果不进行限制，默认为-1，代表不限制迭代次数，直到获得最终结果
 */
void thinImage(IplImage* src, IplImage* dst, int maxIterations = -1);
</code></pre> 
<br> 2.代码实现 ProcessImage.cpp 
<p></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">//ProcessImage.cpp
#include "ProcessImage.h"
#include &lt;utility&gt;
#include &lt;vector&gt;
void thinImage(IplImage* src, IplImage* dst, int maxIterations)
{
	using namespace cv;
	CvSize size = cvGetSize(src);
	cvCopy(src, dst);//将src中的内容拷贝到dst中  
	int count = 0;  //记录迭代次数  
	while (true)
	{
		count++;
		if (maxIterations != -1 &amp;&amp; count &gt; maxIterations) //限制次数并且迭代次数到达  
			break;
		//std::cout &lt;&lt; count &lt;&lt; ' ';输出迭代次数  
		std::vector&lt;std::pair&lt;int, int&gt; &gt; mFlag; //用于标记需要删除的点  
		//对点标记  
		for (int i = 0; i&lt;size.height; ++i)
		{
			for (int j = 0; j&lt;size.width; ++j)
			{
				//如果满足四个条件，进行标记  
				//  p9 p2 p3  
				//  p8 p1 p4  
				//  p7 p6 p5  
				int p1 = CV_IMAGE_ELEM(dst, uchar, i, j);
				int p2 = (i == 0) ? 0 : CV_IMAGE_ELEM(dst, uchar, i - 1, j);
				int p3 = (i == 0 || j == size.width - 1) ? 0 : CV_IMAGE_ELEM(dst, uchar, i - 1, j + 1);
				int p4 = (j == size.width - 1) ? 0 : CV_IMAGE_ELEM(dst, uchar, i, j + 1);
				int p5 = (i == size.height - 1 || j == size.width - 1) ? 0 : CV_IMAGE_ELEM(dst, uchar, i + 1, j + 1);
				int p6 = (i == size.height - 1) ? 0 : CV_IMAGE_ELEM(dst, uchar, i + 1, j);
				int p7 = (i == size.height - 1 || j == 0) ? 0 : CV_IMAGE_ELEM(dst, uchar, i + 1, j - 1);
				int p8 = (j == 0) ? 0 : CV_IMAGE_ELEM(dst, uchar, i, j - 1);
				int p9 = (i == 0 || j == 0) ? 0 : CV_IMAGE_ELEM(dst, uchar, i - 1, j - 1);

				if ((p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9) &gt;= 2 &amp;&amp; (p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9) &lt;= 6)
				{
					int ap = 0;
					if (p2 == 0 &amp;&amp; p3 == 1) ++ap;
					if (p3 == 0 &amp;&amp; p4 == 1) ++ap;
					if (p4 == 0 &amp;&amp; p5 == 1) ++ap;
					if (p5 == 0 &amp;&amp; p6 == 1) ++ap;
					if (p6 == 0 &amp;&amp; p7 == 1) ++ap;
					if (p7 == 0 &amp;&amp; p8 == 1) ++ap;
					if (p8 == 0 &amp;&amp; p9 == 1) ++ap;
					if (p9 == 0 &amp;&amp; p2 == 1) ++ap;

					if (ap == 1)
					{
						if (p2*p4*p6 == 0)
						{
							if (p4*p6*p8 == 0)
							{
								//标记  
								mFlag.push_back(std::make_pair(i, j));
							}
						}
					}
				}
			}
		}

		//将标记的点删除  
		for (std::vector&lt;std::pair&lt;int, int&gt; &gt;::iterator i = mFlag.begin(); i != mFlag.end(); ++i)
		{
			CV_IMAGE_ELEM(dst, uchar, i-&gt;first, i-&gt;second) = 0;
		}

		//直到没有点满足，算法结束  
		if (mFlag.size() == 0)
		{
			break;
		}
		else
		{
			mFlag.clear();//将mFlag清空  
		}

		//对点标记  
		for (int i = 0; i&lt;size.height; ++i)
		{
			for (int j = 0; j&lt;size.width; ++j)
			{
				//如果满足四个条件，进行标记  
				//  p9 p2 p3  
				//  p8 p1 p4  
				//  p7 p6 p5  
				int p1 = CV_IMAGE_ELEM(dst, uchar, i, j);
				if (p1 != 1) continue;
				int p2 = (i == 0) ? 0 : CV_IMAGE_ELEM(dst, uchar, i - 1, j);
				int p3 = (i == 0 || j == size.width - 1) ? 0 : CV_IMAGE_ELEM(dst, uchar, i - 1, j + 1);
				int p4 = (j == size.width - 1) ? 0 : CV_IMAGE_ELEM(dst, uchar, i, j + 1);
				int p5 = (i == size.height - 1 || j == size.width - 1) ? 0 : CV_IMAGE_ELEM(dst, uchar, i + 1, j + 1);
				int p6 = (i == size.height - 1) ? 0 : CV_IMAGE_ELEM(dst, uchar, i + 1, j);
				int p7 = (i == size.height - 1 || j == 0) ? 0 : CV_IMAGE_ELEM(dst, uchar, i + 1, j - 1);
				int p8 = (j == 0) ? 0 : CV_IMAGE_ELEM(dst, uchar, i, j - 1);
				int p9 = (i == 0 || j == 0) ? 0 : CV_IMAGE_ELEM(dst, uchar, i - 1, j - 1);

				if ((p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9) &gt;= 2 &amp;&amp; (p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9) &lt;= 6)
				{
					int ap = 0;
					if (p2 == 0 &amp;&amp; p3 == 1) ++ap;
					if (p3 == 0 &amp;&amp; p4 == 1) ++ap;
					if (p4 == 0 &amp;&amp; p5 == 1) ++ap;
					if (p5 == 0 &amp;&amp; p6 == 1) ++ap;
					if (p6 == 0 &amp;&amp; p7 == 1) ++ap;
					if (p7 == 0 &amp;&amp; p8 == 1) ++ap;
					if (p8 == 0 &amp;&amp; p9 == 1) ++ap;
					if (p9 == 0 &amp;&amp; p2 == 1) ++ap;

					if (ap == 1)
					{
						if (p2*p4*p8 == 0)
						{
							if (p2*p6*p8 == 0)
							{
								//标记  
								mFlag.push_back(std::make_pair(i, j));
							}
						}
					}
				}
			}
		}
		//删除  
		for (std::vector&lt;std::pair&lt;int, int&gt; &gt;::iterator i = mFlag.begin(); i != mFlag.end(); ++i)
		{
			CV_IMAGE_ELEM(dst, uchar, i-&gt;first, i-&gt;second) = 0;
		}

		//直到没有点满足，算法结束  
		if (mFlag.size() == 0)
		{
			break;
		}
		else
		{
			mFlag.clear();//将mFlag清空  
		}
	}
}
</code></pre>3.主函数所在文件 Source.cpp 
<p></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">//Source.cpp
#include "ProcessImage.h"
#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#define _TEST
using namespace cv;
int main(int argc, char * argv[])
{
	//判断输入是否满足要求
	if (argc != 2)
	{
		std::cout &lt;&lt; "argument error!";
		return -1;
	}
	IplImage *pSrc = cvLoadImage(argv[1], CV_LOAD_IMAGE_GRAYSCALE);
	if (!pSrc)
	{
		std::cout &lt;&lt; "read file failed!";
		return -1;
	}

	//显示原图
	namedWindow("原图", CV_WINDOW_AUTOSIZE);
	cvShowImage("原图", pSrc);

	IplImage *pTemp = cvCreateImage(cvGetSize(pSrc), pSrc-&gt;depth, pSrc-&gt;nChannels);
	IplImage *pDst = cvCreateImage(cvGetSize(pSrc), pSrc-&gt;depth, pSrc-&gt;nChannels);

	//将原图像转换为二值图像
	cvThreshold(pSrc, pTemp, 128, 1, CV_THRESH_BINARY_INV);
	//细化
	thinImage(pTemp, pDst);

#ifdef _TEST
	//显示细化后的图像
	IplImage *pThinImage = cvCreateImage(cvGetSize(pSrc), pSrc-&gt;depth, pSrc-&gt;nChannels);
	cvCopy(pDst, pThinImage);
	cvThreshold(pThinImage, pThinImage, 0.5, 255,CV_THRESH_BINARY);
	namedWindow("1 图像细化的结果", CV_WINDOW_AUTOSIZE);
	cvShowImage("1 图像细化的结果", pThinImage);
	cvReleaseImage(&amp;pThinImage);
#endif

	//求轮廓
	CvMemStorage* storage = cvCreateMemStorage(0);
	CvSeq* contours = 0;
	cvFindContours(pDst	, storage, &amp;contours, sizeof(CvContour), CV_RETR_LIST, CV_CHAIN_APPROX_NONE, cvPoint(0, 0));

#ifdef _TEST
	//将轮廓画出来
	IplImage *pDrawing1 = cvCreateImage(cvGetSize(pSrc),8,3);
	cvZero(pDrawing1);
	cvDrawContours(pDrawing1, contours, Scalar(255, 0, 0), Scalar(0, 0, 255), 1, 2, 8, cvPoint(0, 0));
	namedWindow("2 求轮廓", CV_WINDOW_AUTOSIZE);
	cvShowImage("2 求轮廓", pDrawing1);
	cvReleaseImage(&amp;pDrawing1);
#endif


	//轮廓已经寻找到，均在contours中存放,我们需要对轮廓进行拟合
	//FitLine函数的用法：
	// 二维空间点拟合时 是 float[4]
	// 三位空间点拟合时 是 float[6]	
	float *line1 = new float[4];
	float *line2 = new float[4];
	// 第一个参数： 存储点序列
	// 第二个参数： 拟合算法，其中 CV_DIST_L2 就是平常的最小二乘法
	// 第三，第四，第五参数推荐值是 0,   0.01,  0.01,
	// 第六参数： line中存储返回值
	// 二维空间时： line[0--3] 分别为 (vx, vy, x0, y0)
	//      其中 vx， vy 是正规化之后的斜率向量。 x0,y0 是直线经过的点。
	// 三维空间时： line[0--5]  分别是 (vx, vy, vz, x0, y0, z0) 。意义同上
	cvFitLine(contours, CV_DIST_L2, 0, 0.01, 0.01, line1);
	cvFitLine(contours-&gt;h_next, CV_DIST_L2, 0, 0.01, 0.01, line2);
	
	//输出四个点
	std::cout &lt;&lt; "第一条线： " &lt;&lt; line1[0] &lt;&lt; " " &lt;&lt; line1[1] &lt;&lt; " " &lt;&lt; line1[2] &lt;&lt; " " &lt;&lt; line1[3] &lt;&lt; std::endl;
	std::cout &lt;&lt; "第二条线： " &lt;&lt; line2[0] &lt;&lt; " " &lt;&lt; line2[1] &lt;&lt; " " &lt;&lt; line2[2] &lt;&lt; " " &lt;&lt; line2[3] &lt;&lt; std::endl;
	
#ifdef _TEST
	//根据直线方程公式，我们从直线上取点，并画出来
	IplImage *pDrawing2 = cvCreateImage(cvGetSize(pSrc), 8, 3);
	cvZero(pDrawing2);
	cvLine(pDrawing2, cvPoint(0, (int)(line1[3] - line1[1] / line1[0] * line1[2])),
		cvPoint(pDrawing2-&gt;width - 1, (int)((pDrawing2-&gt;width - 1 - line1[2])*line1[1] / line1[0] + line1[3])),
		cvScalar(255, 0, 0));
	cvLine(pDrawing2, cvPoint(0, (int)(line2[3] - line2[1] / line2[0] * line2[2])), 
		cvPoint(pDrawing2-&gt;width - 1, (int)((pDrawing2-&gt;width - 1 - line2[2])*line2[1] / line2[0] + line2[3])), 
		cvScalar(0, 0, 255));
	namedWindow("3 直线拟合", CV_WINDOW_AUTOSIZE);
	cvShowImage("3 直线拟合", pDrawing2);
	cvReleaseImage(&amp;pDrawing2);
#endif

	//我们根据距离方程，求出两条直线的距离
	double distance = abs(line1[0] * (line2[3]-line1[3]) - line1[1] * (line2[2]-line1[2]));	//注意,vx,vy已经正规化了
	std::cout &lt;&lt; "两条直线之间的距离为: " &lt;&lt; distance &lt;&lt; std::endl;
	delete[] line1;
	delete[] line2;

	cvReleaseMemStorage(&amp;storage);
	cvReleaseImage(&amp;pSrc);
	cvReleaseImage(&amp;pTemp);
	cvReleaseImage(&amp;pDst);

	waitKey(0);

	return 0;
}</code></pre> 
<strong><span style="font-size:18px">运行效果：</span></strong> 
<p></p> 
<p><span style="font-size:18px"><strong><span style="font-size:18px">输入:</span></strong><br> <img src="https://images2.imgbox.com/ce/ce/vWq1Qi6Q_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px"><strong><span style="font-size:18px">输出:</span></strong></span></p> 
<p><img src="https://images2.imgbox.com/20/bb/KxHOFI1V_o.jpg" alt=""></p> 
<p><img src="https://images2.imgbox.com/56/c5/tQ31PBib_o.jpg" alt=""></p> 
<p><img src="https://images2.imgbox.com/a5/0f/aitAi9OM_o.jpg" alt=""></p> 
<p><img src="https://images2.imgbox.com/d3/c5/2ck4ViYl_o.jpg" alt=""><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9462ddb2ad8cb2f82ac53adc6a16289b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">英特尔I217-V网卡驱动安装失败解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/365154aed6e65ca265eeeaf969af3357/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">几种常见的缺失数据插补方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>