<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统期末复习 （南昌大学） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统期末复习 （南昌大学）" />
<meta property="og:description" content="本人一名大三学生，最近要期末考试了自己整理一下操作系统需要复习的重点希望对大家的期末复习有帮助-
带！！的是老师着重强调的
第三章–内存管理 1.存储器的层次结构 存储器的层次
计算机系统的存储器可以分为寄存器、高速缓存、主存储器、磁盘缓存、固定磁盘、可移动存储介质等7个层次。
2.！！内存的分配方式特点（连续 非连续） 连续分配方式： 1.单一连续分配：特点：单道，分为系统区和用户区
2.固定分区分配：特点：多道，分区，大小可不等 产生内部碎片
3.动态分区分配：特点：根据进程的实际需求动态分配 产生外部碎片
动态分区分配策略：
1）首次适应算法：空闲分区以地址递增的次序链接。分配内存时从链首开始顺序查找，找到能满足第一个空闲分区的内存
2）临近适应算法：是首次适应算法的优化，从上次查找结束的位置开始重新继续查找
3）最佳适应算法：空闲分区以容量递增的次序形成空闲分区链，找到第一个能满足的空闲分区分配
4）最坏适应算法：空闲分区以容量递减的次序形成空闲分区链，找到第一个能满足的空闲分区分配
非连续分配方式： 基本分页存储管理：
为了使用内存时尽量避免碎片的产生，这就引入了分片的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位划分，进程在执行时，以块为单位逐个申请主存中的块空间
分页存储的相关概念：
1）页面和页面大小：进程中的块称为页或页面，内存中的块称为叶框或页帧，外存也以同样的单位划分称为块或盘块。进程在执行时需要申请主存空间，即要为页面分配主存可用的可用页框，这就产生了页和叶框的一一对应
为了方便地址转换，页面的大小应是2的整数幂
2）地址结构：
地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32位，其中011位为页内地址，即每页大小为4KB；1231位为页号，最多允许2^20页
3）页表：
为了方便内存找到进程中每一个页面所对应的物理块块，系统为每一个进程建一张表，记录页面在内存中对应的物理块号，页表一般放在内存里，通过页表实现从页号到物理块号（页框号）的映射
页表是由页表项组成
如何确定一个逻辑地址对应的页号和页内偏移量？
页号=逻辑地址/页面大小
页内偏移量=逻辑地址%页面大小
如何通过逻辑地址找到物理地址？
通过页号查询页表得到页面在内存中的内存块号
j号内存块起始地址=j*内存块大小
页面在内存中的起始地址&#43;页内偏移量=实际的物理地址
如果页面的大小刚好是2的整数次幂，2^k则末尾k位是页内偏移量，前面是页号
想要得到最终的物理内存地址只需要将内存块号拼接上内存偏移量就能得到物理地址
**基本地址转换机构：**用于实现逻辑地址到物理地址转变的硬件机构
将逻辑地址A转为物理地址的流程：
1.页号合法性的检查
2.如果合法，通过页号和页表始址计算找到页号对应的页表项，确定页面的内存块号
3.通过内存块号和页内偏移量来确定物理地址
每一个页表项大小是相同的，页号是“隐含的”
具有快表的地址变换机构：
快表（联想寄存器TLB）：是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项的副本，可以加速地址转换的速度，与此对应，内存中的页表称为慢表
将逻辑地址A转为物理地址的流程：
1.算页号、页内偏移量
2.检查页号合法性
3.查快表。若命中，即可知道页面存放的内存块号，可直接进行5，为命中则进行4
4.查页表，找到页面存放的内存块号，并且将页表项复制到块表中
5.根据内存块号与页内偏移量得到物理地址
6.访问目标内存单元
计算访问一个逻辑地址的平均耗时是多少？
假设快表耗时为1，访问内存是100，
则在为引进快表之前，CPU查一次逻辑地址需要两次访问内存，第一次是查页表，第二次是查实际物理地址。平均时间是200.
在引进快表之后，由于快表的命中率为0.9，在命中后耗时为，访问一次快表和访问一次内存，时间为1&#43;100=101，也还有可能快表未命中，耗时为201（访问一次快表&#43;访问两次内存），综合考虑为0.1201&#43;0.96101=111
也有CPU设计为两种访问机制同时进行，就为（1&#43;100）0.9&#43;200*0.1=110.9
基本分段式存储管理：
与分页最大的区别就是–离散分配时基本的单位不同
进程的地址空间：按照程序自身的逻辑关系划分为若干段，每个段都有一个段名，每段从0开始编址
内存分配规则：以段为单位分配，每个段在内存空间占据连续空间，但各段之间可以不相邻
分段系统的逻辑地址由段号（段名）和段内地址（段内偏移量）
段号的位数决定了每个进程最多可以分多少个段
段内地址位数决定了每个段的最大长度
由于图中段号占16位，所以这个进程可以最多分216=64K个段，段内地址16位，所以它每个段的最大长度为216KB
**段表：**为每个进程创建一个段映射表，保证能从物理内存中找到各个逻辑段的存放位置
1.每个段对应一个段表项，记录了该段在内存中的起始位置（基址）和段的长度" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/422f55ac33aa5ac96ad76071d0e7333d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T18:19:12+08:00" />
<meta property="article:modified_time" content="2024-01-09T18:19:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统期末复习 （南昌大学）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><em>本人一名大三学生，最近要期末考试了自己整理一下操作系统需要复习的重点希望对大家的期末复习有帮助<sup>-</sup></em></p> 
 <p><em>带！！的是老师着重强调的</em></p> 
</blockquote> 
<h2><a id="_6"></a>第三章–内存管理</h2> 
<h3><a id="1_8"></a>1.存储器的层次结构</h3> 
<blockquote> 
 <p><strong>存储器的层次</strong></p> 
 <p>计算机系统的存储器可以分为<strong>寄存器</strong>、<strong>高速缓存</strong>、<strong>主存储器</strong>、<strong>磁盘缓存</strong>、<strong>固定磁盘</strong>、<strong>可移动存储介质</strong>等7个层次。</p> 
</blockquote> 
<h3><a id="2___14"></a>2.！！内存的分配方式特点（连续 非连续）</h3> 
<h4><a id="_16"></a><strong>连续分配方式：</strong></h4> 
<blockquote> 
 <p>1.<strong>单一连续</strong>分配：特点：单道，分为系统区和用户区</p> 
 <p>2.<strong>固定分区</strong>分配：特点：多道，分区，大小可不等 产生内部碎片</p> 
 <p>3.<strong>动态分区</strong>分配：特点：根据进程的实际需求动态分配 产生外部碎片</p> 
 <p>动态分区分配策略：</p> 
 <p>1）<strong>首次适应</strong>算法：空闲分区以地址递增的次序链接。分配内存时从链首开始顺序查找，找到能满足第一个空闲分区的内存</p> 
 <p>2）<strong>临近适应</strong>算法：是首次适应算法的优化，从上次查找结束的位置开始重新继续查找</p> 
 <p>3）<strong>最佳适应</strong>算法：空闲分区以<strong>容量递增</strong>的次序形成空闲分区链，找到第一个能满足的空闲分区分配</p> 
 <p>4）<strong>最坏适应</strong>算法：空闲分区以<strong>容量递减</strong>的次序形成空闲分区链，找到第一个能满足的空闲分区分配</p> 
</blockquote> 
<h4><a id="_34"></a><strong>非连续分配方式：</strong></h4> 
<blockquote> 
 <p>基本<strong>分页存储管理</strong>：</p> 
 <p>为了使用内存时尽量避免碎片的产生，这就引入了分片的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位划分，进程在执行时，以块为单位逐个申请主存中的块空间</p> 
 <p>分页存储的相关概念：</p> 
 <p>1）<strong>页面和页面大小</strong>：进程中的块称为<strong>页或页面</strong>，内存中的块称为<strong>叶框或页帧</strong>，外存也以同样的单位划分称为<strong>块或盘块</strong>。进程在执行时需要申请主存空间，即要为页面分配主存可用的可用页框，这就产生了页和叶框的<strong>一一对应</strong></p> 
 <p>为了<strong>方便地址转换</strong>，页面的大小应是2的整数幂</p> 
 <p>2）地址结构：</p> 
 <p><img src="https://images2.imgbox.com/bb/a0/zlCOpWnv_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32位，其中0<sub>11位为页内地址，即每页大小为4KB；12</sub>31位为页号，最多允许2^20页</p> 
 <p>3）页表：</p> 
 <p>为了方便内存找到进程中每一个页面所对应的物理块块，系统为每一个进程建一张表，记录页面在内存中对应的物理块号，页表一般放在内存里，通过页表实现从页号到物理块号（页框号）的映射</p> 
 <p><img src="https://images2.imgbox.com/6f/29/7eDlBPZL_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/03/49/Hbun0O8x_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>页表是由页表项组成</p> 
 <p><strong>如何确定一个逻辑地址对应的页号和页内偏移量？</strong></p> 
 <p>页号=逻辑地址/页面大小</p> 
 <p>页内偏移量=逻辑地址%页面大小</p> 
 <p><strong>如何通过逻辑地址找到物理地址？</strong></p> 
 <p>通过页号查询页表得到页面在内存中的内存块号</p> 
 <p>j号内存块起始地址=j*内存块大小</p> 
 <p>页面在内存中的起始地址+页内偏移量=实际的物理地址</p> 
 <p>如果页面的大小刚好是2的整数次幂，2^k则末尾k位是页内偏移量，前面是页号</p> 
 <p>想要得到最终的物理内存地址只需要将内存块号拼接上内存偏移量就能得到物理地址</p> 
 <p>**基本地址转换机构：**用于实现逻辑地址到物理地址转变的硬件机构</p> 
 <p><strong>将逻辑地址A转为物理地址的流程：</strong></p> 
 <p>1.页号合法性的检查</p> 
 <p>2.如果合法，通过页号和页表始址计算找到页号对应的页表项，确定页面的内存块号</p> 
 <p>3.通过内存块号和页内偏移量来确定物理地址</p> 
 <p><img src="https://images2.imgbox.com/db/76/YxMgYeSF_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>每一个页表项大小是相同的，页号是“隐含的”</p> 
 <p><strong>具有快表的地址变换机构</strong>：</p> 
 <p>快表（联想寄存器TLB）：是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项的副本，可以加速地址转换的速度，与此对应，内存中的页表称为慢表</p> 
 <p><strong>将逻辑地址A转为物理地址的流程：</strong></p> 
 <p>1.算页号、页内偏移量<br> 2.检查页号合法性<br> 3.查快表。若命中，即可知道页面存放的内存块号，可直接进行5，为命中则进行4<br> 4.查页表，找到页面存放的内存块号，并且将页表项复制到块表中<br> 5.根据内存块号与页内偏移量得到物理地址<br> 6.访问目标内存单元</p> 
 <p><img src="https://images2.imgbox.com/79/66/HXoJ9erW_o.png" alt="在这里插入图片描述"></p> 
 <p><strong>计算访问一个逻辑地址的平均耗时是多少？</strong><br> 假设快表耗时为1，访问内存是100，<br> 则在为引进快表之前，CPU查一次逻辑地址需要两次访问内存，第一次是查页表，第二次是查实际物理地址。平均时间是200.<br> 在引进快表之后，由于快表的命中率为0.9，在命中后耗时为，访问一次快表和访问一次内存，时间为1+100=101，也还有可能快表未命中，耗时为201（访问一次快表+访问两次内存），综合考虑为0.1201+0.96101=111<br> 也有CPU设计为两种访问机制同时进行，就为（1+100）0.9+200*0.1=110.9</p> 
</blockquote> 
<p><strong>基本分段式存储管理：</strong></p> 
<blockquote> 
 <p>与分页最大的区别就是–离散分配时基本的单位不同</p> 
 <p>进程的地址空间：按照程序自身的逻辑关系划分为若干段，每个段都有一个段名，每段从0开始编址</p> 
 <p>内存分配规则：以段为单位分配，每个段在内存空间占据连续空间，但各段之间可以不相邻</p> 
 <p>分段系统的逻辑地址由段号（段名）和段内地址（段内偏移量）</p> 
 <p><img src="https://images2.imgbox.com/43/97/xoKJBapZ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>段号的位数决定了每个进程最多可以分多少个段</p> 
 <p>段内地址位数决定了每个段的最大长度</p> 
 <p>由于图中段号占16位，所以这个进程可以最多分2<sup>16=64K个段，段内地址16位，所以它每个段的最大长度为2</sup>16KB</p> 
 <p>**段表：**为每个进程创建一个段映射表，保证能从物理内存中找到各个逻辑段的存放位置</p> 
 <p><img src="https://images2.imgbox.com/27/fd/7zbLRY2t_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>1.每个段对应一个段表项，记录了该段在内存中的起始位置（基址）和段的长度</p> 
 <p><img src="https://images2.imgbox.com/98/d4/eJdVbSsh_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p><strong>将逻辑地址A转为物理地址的流程：</strong></p> 
 <p>1.通过逻辑地址得到段号S和段内地址W</p> 
 <p>2.判断段号是否越界，段表寄存器（段表始址F+段表长度M）S&gt;=M产生越界</p> 
 <p>3.查段表，找到对应的段表项为F+S*段表项长度</p> 
 <p>4.检查段内地址W是否超过段长</p> 
 <p>5.段基址+段内地址</p> 
 <p>分页管理因为页的大小相同，不需要对页内偏移量进行越界判断，而分段每个段大小不同，所以需要对段内地址的合法性进行判断</p> 
 <p><strong>段的共享和保护</strong></p> 
</blockquote> 
<h3><a id="3_167"></a>3.虚拟内存管理</h3> 
<blockquote> 
 <p>传统存储管理方式的特点：</p> 
 <p>1）一次性：作业必须一次性的全部装入内存后才能开始运行</p> 
 <p>2）驻留性：作业被装入内存后，就会一直驻留在内存直到作业完成</p> 
 <p>局部性原理</p> 
 <p>时间局部性：程序中存在大量的循环操作，被访问到的数据可能还会被再次访问</p> 
 <p>空间局部性：因为指令通常是顺序存放、顺序执行的，所以一旦访问了某个存储单元，那么不久之后附近的存储单元也会被访问</p> 
 <p>虚拟存储</p> 
 <p>虚拟存储基于局部性原理，将程序运行需要的页面少量多次的运送进内存，程序执行时由操作系统将所需部分调入内存，因此系统好像为用户提供了一个比实际容量大得多的存储器称为虚拟存储器</p> 
 <p>虚拟内存特点</p> 
 <p>1）多次性：作业分多次装入内存</p> 
 <p>2）对换性：作业无需常驻内存，允许作业运行时将作业换入换出</p> 
 <p>3）虚拟性：从逻辑上扩充了内存的容量</p> 
</blockquote> 
<h3><a id="4_193"></a>4.！！请求分页管理</h3> 
<blockquote> 
 <p>请求分页管理是在基本分页管理上的拓展，主要区别在于：</p> 
 <p>在程序执行过程中，如果所访问信息不在内存时，由操作系统将所需信息从外存调入内存</p> 
 <p>若内存空间不够，由操作系统将暂时不用的信息换出到外存</p> 
 <p><strong>页表（请求页表）：</strong></p> 
 <p><img src="https://images2.imgbox.com/ca/f7/eUg8KXVn_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p><strong>新增步骤：</strong></p> 
 <p>1.请求调页（查到页表项时进行判断）</p> 
 <p>2.页面置换（需要调入页面但没有空闲内存块时）</p> 
 <p>3.需要修改请求页表中新增的表项</p> 
 <p><strong>缺页中断机构：</strong></p> 
 <p>在请求分页管理系统中，如果需要访问的页不在内存中便会产生缺页中断，请求OS将缺页调入内存中</p> 
 <p><strong>地址变换流程：</strong></p> 
 <p>1.将逻辑地址转为页号+页内偏移量</p> 
 <p>2.对页号进行越界判断</p> 
 <p>3.查询快表有没有这个页号</p> 
 <p>4.命中直接得到最终的物理地址</p> 
 <p>5.没有命中查询内存中的慢表，查询对应页表项是否已经在内存中</p> 
 <p>6.若内有在内存则缺页中断机构产生缺页中断信号进行缺页中断处理（调页+页面置换）</p> 
</blockquote> 
<h3><a id="5_232"></a>5.!!请求分段管理</h3> 
<blockquote> 
 <p>请求分页管理是以页面为的那位进行换入和换出的 ，请求分段管理则是以分段为单位进行换入换出的</p> 
 <p><strong>1.请求分段表：</strong></p> 
 <p>在该表除了具有请求分页机制中有的访问字段A、修改位M、存在位P和外存始址四个字段外还增加了存取方式字段和增补位</p> 
 <p><strong>存取方式</strong>：如果该字段为两位则存取属性是只执行、只读和值允许读/写</p> 
 <p>访问字段A：用于记录该字段被访问的频繁程度</p> 
 <p>修改位M：该字段表示该页在进入内存后是否已经被修改过</p> 
 <p>存在位P：表示该字段是够已经被调入内存</p> 
 <p>增补位：请求分段管理特有，表示本段在运行过程中是否做过动态增长</p> 
 <p>外存始址：本段在外存中的起始地址</p> 
 <p><strong>2.缺段中断机构</strong></p> 
 <p>在请求分段管理系统中，如果需要访问的段不在内存中便会产生缺段中断，请求OS将缺段调入内存中</p> 
 <p>新增步骤：</p> 
 <p>a.判断是否符合存取方式</p> 
 <p>b.修改访问字段</p> 
 <p><strong>3.地址变换流程：</strong></p> 
 <p>将逻辑地址转为段号和段内地址</p> 
 <p>判断段内地址是否合法</p> 
 <p>之后判断是否符合存取方式</p> 
 <p>判断段是否在内存中，如果没有则产生缺段中断进行处理</p> 
 <p>修改访问字段，如访问字段、修改位、存在位、增补位</p> 
 <p>形成主存地址（主存始址+偏移量）</p> 
 <p><strong>4.分段保护</strong></p> 
 <p>在分段系统中，由于每个分段在逻辑上是相对独立的，因此比较容易实现信息的保护</p> 
 <p>1）越界检查</p> 
 <p>越界检查是利用地址变换机构完成的。为此，在地址变换机构中设置段表寄存器，用来存放段表始址和段表长度信息。在进行地址转换的时候，首先将逻辑地址空间的段号与段表长度进行比较，如果段号大于等于段表长度，将发出地址越界信号，此号还在段表中为每个段设置了段长字段，在进行地址转换的时候，还要检查段内地址是否大于等于段长，从而保证了每个进程只能在自己的地址空间内运行</p> 
 <p>2）存取控制检查</p> 
 <p>存取控制检查是以段为基本单位进行的。为此，在段表的每一个表项中都设置了存取控制字段</p> 
 <p>1）只读：只允许进程对该字段中的程序或数据进行读访问</p> 
 <p>2）只执行：只允许该进程调用该字段去执行，但不允许读或写该字段的内容</p> 
 <p>3）读/写：允许进程对该字段进行读/写</p> 
 <p>3）环保护机制：</p> 
 <p>在该机制中规定：低编号的环具有高优先级，OS操作系统核心位于0号环内；某些重要的应用程序和操作系统服务占据中间环；一般的应用程序安排在外环。在环系统中，程序的访问和调用规则：</p> 
 <p>1）一个程序可以访问驻留在相同环或较低特权环中的数据</p> 
 <p>2）一个程序可以调用驻留在相同环或较高特权环中的服务</p> 
</blockquote> 
<h3><a id="6_302"></a>6.！！页面置换算法</h3> 
<blockquote> 
 <p><strong>1.最佳（OPT）置换算法</strong></p> 
 <p>每次选择以后都不会使用的页面或者最长时间内不再被访问的页面，但是最佳置换算法由于需要知道页面访问序列，所以是无法实现的</p> 
 <p><img src="https://images2.imgbox.com/d0/97/uIhxWSu8_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <ol start="2"><li><strong>先进先出（FIFO）置换算法</strong></li></ol> 
 <p>每次选择淘汰的页面是最先进入内存的页面</p> 
 <p><img src="https://images2.imgbox.com/66/cf/m5ryUJlR_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/16/0d/9HWEV59f_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>Belady–发现增加内存块个数缺页次数不减反增</p> 
 <p>只有FIFO算法才会产生Belady异常</p> 
 <p>3.最近最久未使用(LRU)算法</p> 
 <p>每次淘汰的页面是最近最久未使用的页面</p> 
 <p><img src="https://images2.imgbox.com/fa/d8/M8Rf1r2Q_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>算法性能好，但实现困难开销大</p> 
 <p>4.时钟置换算法（CLOCK）</p> 
 <p>也成为最近未用算法（NRU）</p> 
 <p><strong>简单的时钟置换算法的实现</strong></p> 
 <p>为页面设置一个访问位（为1表示最近访问过为0反之），再将内存中的页面都通过链接指针=链接成一个循环队列。当某页被访问时其访问位被置为1 。当需要淘汰一个页面时，只需检查页的访问位。如果是0，则换出，如果是0则暂时不换出，继续检查下一个页面，如果全为1则需进行第二轮扫描</p> 
 <p><img src="https://images2.imgbox.com/1b/9f/8xMcbiPZ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/a6/fd/dK2GOCbb_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>改进型的时钟置换算法：</p> 
 <p>在简单时钟置换算法中只考虑到了最近页面是否被访问过，但实际上，如果一个被淘汰的页面没有被操作过不需要写回外存，如果能优先淘汰没有被修改过的页面可以减少IO的次数</p> 
 <p>再增加一个修改位 ，为0表示页面没有被修改过，为1表是页面被修改过 （访问位，修改位）</p> 
 <p>算法规则：</p> 
 <p>第一轮：从当前位置开始试图找到第一个为（0,0）的页面来替换，本轮扫描不修改标志位</p> 
 <p>第二轮：若第一轮失败，则重新扫描找到第一个为（0,1）的页面进行替换并且被扫描过的页面的访问位都会设置为0</p> 
 <p>第三轮：若第二轮失败，则重新找到第一个为（0,0），本轮扫描不修改标志位</p> 
 <p>第四轮：若第三轮失败，则重新扫描找到第一个为（0,1）的页面进行替换</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3d7db942d6d8a056e1fe702129acefc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">云卷云舒：kubernetes简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/73fab1dd3ae5bfeff2127cfb53b52156/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vscode中的node.js的安装与使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>