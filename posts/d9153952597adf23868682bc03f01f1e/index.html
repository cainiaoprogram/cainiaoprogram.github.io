<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Mybatis】日常知识点随笔（持续更新） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Mybatis】日常知识点随笔（持续更新）" />
<meta property="og:description" content="目录
【K】Mybatis使用@Select注解书写简单sql
【K】MySQL 数据类型与 Java 类型的对应关系
【K】Mybatis相同代码复用
1. 定义公共 SQL 片段
2. 引用公共 SQL 片段
3. 使用参数
4. 复用和组合
5. 注意事项
【K】mysql如何实现插入一条数据后立刻获取该数据自增长id进行调用
背景解析
代码使用
【K】Mybatis新增数据，存在就更新，不存在就添加
常规方法
Replace关键字
【K】MyBatis执行多个sql语句
背景
代码举例
实例举例
分析总结
【K】Mybatis 不同条件拼接不同sql
举例1
举例2: 判断某一个值
举例3
【K】-IFNULL处理N/A
背景知识
SQL语句分析
改进后的SQL语句
知识扩展
注意事项
【K】Mybatis条件查询＜where＞标签
【K】使用resultMap封装对象一对多
数据库模型
实体类
MyBatis 配置
举例
【K】Mybatis使用常见类型的类型别名
【K】Mybatis使用@Select注解书写简单sql //1. 基本查询 @Select(&#34;SELECT * FROM users WHERE id = #{id}&#34;) User selectUserById(int id); //2. 动态查询 @Select(&#34;&lt;script&gt;&#34; &#43; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d9153952597adf23868682bc03f01f1e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-18T20:57:37+08:00" />
<meta property="article:modified_time" content="2023-12-18T20:57:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Mybatis】日常知识点随笔（持续更新）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E3%80%90K%E3%80%91Mybatis%E4%BD%BF%E7%94%A8%40Select%E6%B3%A8%E8%A7%A3%E4%B9%A6%E5%86%99%E7%AE%80%E5%8D%95sql-toc" style="margin-left:40px;"><a href="#%E3%80%90K%E3%80%91Mybatis%E4%BD%BF%E7%94%A8%40Select%E6%B3%A8%E8%A7%A3%E4%B9%A6%E5%86%99%E7%AE%80%E5%8D%95sql" rel="nofollow">【K】Mybatis使用@Select注解书写简单sql</a></p> 
<p id="%E5%85%AD%E3%80%81MySQL%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%20Java%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81MySQL%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%20Java%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB" rel="nofollow">【K】MySQL 数据类型与 Java 类型的对应关系</a></p> 
<p id="%E3%80%90K%E3%80%91Mybatis%E7%9B%B8%E5%90%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E3%80%90K%E3%80%91Mybatis%E7%9B%B8%E5%90%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8" rel="nofollow">【K】Mybatis相同代码复用</a></p> 
<p id="1.%20%E5%AE%9A%E4%B9%89%E5%85%AC%E5%85%B1%20SQL%20%E7%89%87%E6%AE%B5-toc" style="margin-left:80px;"><a href="#1.%20%E5%AE%9A%E4%B9%89%E5%85%AC%E5%85%B1%20SQL%20%E7%89%87%E6%AE%B5" rel="nofollow">1. 定义公共 SQL 片段</a></p> 
<p id="2.%20%E5%BC%95%E7%94%A8%E5%85%AC%E5%85%B1%20SQL%20%E7%89%87%E6%AE%B5-toc" style="margin-left:80px;"><a href="#2.%20%E5%BC%95%E7%94%A8%E5%85%AC%E5%85%B1%20SQL%20%E7%89%87%E6%AE%B5" rel="nofollow">2. 引用公共 SQL 片段</a></p> 
<p id="3.%20%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.%20%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0" rel="nofollow">3. 使用参数</a></p> 
<p id="4.%20%E5%A4%8D%E7%94%A8%E5%92%8C%E7%BB%84%E5%90%88-toc" style="margin-left:80px;"><a href="#4.%20%E5%A4%8D%E7%94%A8%E5%92%8C%E7%BB%84%E5%90%88" rel="nofollow">4. 复用和组合</a></p> 
<p id="5.%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:80px;"><a href="#5.%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">5. 注意事项</a></p> 
<p id="%E3%80%90K%E3%80%91mysql%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%90%8E%E7%AB%8B%E5%88%BB%E8%8E%B7%E5%8F%96%E8%AF%A5%E6%95%B0%E6%8D%AE%E8%87%AA%E5%A2%9E%E9%95%BFid%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E3%80%90K%E3%80%91mysql%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%90%8E%E7%AB%8B%E5%88%BB%E8%8E%B7%E5%8F%96%E8%AF%A5%E6%95%B0%E6%8D%AE%E8%87%AA%E5%A2%9E%E9%95%BFid%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8" rel="nofollow">【K】mysql如何实现插入一条数据后立刻获取该数据自增长id进行调用</a></p> 
<p id="%E8%83%8C%E6%99%AF%E8%A7%A3%E6%9E%90-toc" style="margin-left:80px;"><a href="#%E8%83%8C%E6%99%AF%E8%A7%A3%E6%9E%90" rel="nofollow">背景解析</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%94%A8" rel="nofollow">代码使用</a></p> 
<p id="%E3%80%90K%E3%80%91Mybatis%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AD%98%E5%9C%A8%E5%B0%B1%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%B0%B1%E6%B7%BB%E5%8A%A0-toc" style="margin-left:40px;"><a href="#%E3%80%90K%E3%80%91Mybatis%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AD%98%E5%9C%A8%E5%B0%B1%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%B0%B1%E6%B7%BB%E5%8A%A0" rel="nofollow">【K】Mybatis新增数据，存在就更新，不存在就添加</a></p> 
<p id="%E5%B8%B8%E8%A7%84%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E5%B8%B8%E8%A7%84%E6%96%B9%E6%B3%95" rel="nofollow">常规方法</a></p> 
<p id="Replace%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:80px;"><a href="#Replace%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">Replace关键字</a></p> 
<p id="%E3%80%90K%E3%80%91MyBatis%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AAsql%E8%AF%AD%E5%8F%A5-toc" style="margin-left:40px;"><a href="#%E3%80%90K%E3%80%91MyBatis%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AAsql%E8%AF%AD%E5%8F%A5" rel="nofollow">【K】MyBatis执行多个sql语句</a></p> 
<p id="%E8%83%8C%E6%99%AF-toc" style="margin-left:80px;"><a href="#%E8%83%8C%E6%99%AF" rel="nofollow">背景</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B" rel="nofollow">代码举例</a></p> 
<p id="%E5%AE%9E%E4%BE%8B%E4%B8%BE%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E4%BE%8B%E4%B8%BE%E4%BE%8B" rel="nofollow">实例举例</a></p> 
<p id="%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93" rel="nofollow">分析总结</a></p> 
<p id="%E3%80%90K%E3%80%91Mybatis%20%E4%B8%8D%E5%90%8C%E6%9D%A1%E4%BB%B6%E6%8B%BC%E6%8E%A5%E4%B8%8D%E5%90%8Csql-toc" style="margin-left:40px;"><a href="#%E3%80%90K%E3%80%91Mybatis%20%E4%B8%8D%E5%90%8C%E6%9D%A1%E4%BB%B6%E6%8B%BC%E6%8E%A5%E4%B8%8D%E5%90%8Csql" rel="nofollow">【K】Mybatis 不同条件拼接不同sql</a></p> 
<p id="%E4%B8%BE%E4%BE%8B1-toc" style="margin-left:80px;"><a href="#%E4%B8%BE%E4%BE%8B1" rel="nofollow">举例1</a></p> 
<p id="%E4%B8%BE%E4%BE%8B2%3A%20%E6%88%96%E8%80%85%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E5%80%BC-toc" style="margin-left:80px;"><a href="#%E4%B8%BE%E4%BE%8B2%3A%20%E6%88%96%E8%80%85%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E5%80%BC" rel="nofollow">举例2: 判断某一个值</a></p> 
<p id="%E4%B8%BE%E4%BE%8B3-toc" style="margin-left:80px;"><a href="#%E4%B8%BE%E4%BE%8B3" rel="nofollow">举例3</a></p> 
<p id="%E3%80%90K%E3%80%91-IFNULL%E5%A4%84%E7%90%86N%2FA-toc" style="margin-left:40px;"><a href="#%E3%80%90K%E3%80%91-IFNULL%E5%A4%84%E7%90%86N%2FA" rel="nofollow">【K】-IFNULL处理N/A</a></p> 
<p id="%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86-toc" style="margin-left:80px;"><a href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86" rel="nofollow">背景知识</a></p> 
<p id="SQL%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#SQL%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90" rel="nofollow">SQL语句分析</a></p> 
<p id="%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84SQL%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84SQL%E8%AF%AD%E5%8F%A5" rel="nofollow">改进后的SQL语句</a></p> 
<p id="%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95-toc" style="margin-left:80px;"><a href="#%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95" rel="nofollow">知识扩展</a></p> 
<p id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:80px;"><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">注意事项</a></p> 
<p id="%E3%80%90K%E3%80%91Mybatis%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%EF%BC%9Cwhere%EF%BC%9E%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#%E3%80%90K%E3%80%91Mybatis%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%EF%BC%9Cwhere%EF%BC%9E%E6%A0%87%E7%AD%BE" rel="nofollow">【K】Mybatis条件查询＜where＞标签</a></p> 
<p id="articleContentId-toc" style="margin-left:40px;"><a href="#articleContentId" rel="nofollow">【K】使用resultMap封装对象一对多</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9E%8B" rel="nofollow">数据库模型</a></p> 
<p id="%E5%AE%9E%E4%BD%93%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E4%BD%93%E7%B1%BB" rel="nofollow">实体类</a></p> 
<p id="MyBatis%20%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#MyBatis%20%E9%85%8D%E7%BD%AE" rel="nofollow">MyBatis 配置</a></p> 
<p id="%E4%B8%BE%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%E4%B8%BE%E4%BE%8B" rel="nofollow">举例</a></p> 
<p id="%E3%80%90K%E3%80%91Mybatis%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D-toc" style="margin-left:40px;"><a href="#%E3%80%90K%E3%80%91Mybatis%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D" rel="nofollow">【K】Mybatis使用常见类型的类型别名</a></p> 
<hr> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ec/28/tn8ZIaZg_o.gif"></p> 
<h3 id="%E3%80%90K%E3%80%91Mybatis%E4%BD%BF%E7%94%A8%40Select%E6%B3%A8%E8%A7%A3%E4%B9%A6%E5%86%99%E7%AE%80%E5%8D%95sql">【K】Mybatis使用@Select注解书写简单sql</h3> 
<pre><code class="language-java">//1. 基本查询
@Select("SELECT * FROM users WHERE id = #{id}")
User selectUserById(int id);

//2. 动态查询
@Select("&lt;script&gt;" +
        "SELECT * FROM users" +
        "&lt;if test='id != null'&gt;" +
        " WHERE id = #{id}" +
        "&lt;/if&gt;" +
        "&lt;/script&gt;")
List&lt;User&gt; selectUsersById(@Param("id") Integer id);

//3. 返回 Map
@Select("SELECT * FROM users")
@MapKey("id")
Map&lt;Integer, User&gt; selectUsersAsMap();

//4. 使用注解参数
@Select("SELECT * FROM ${tableName}")
List&lt;User&gt; selectUsersFromTable(@Param("tableName") String tableName);

//5. 结果映射
@Select("SELECT id, name, email FROM users WHERE id = #{id}")
@Results({
    @Result(property = "id", column = "id"),
    @Result(property = "name", column = "name"),
    @Result(property = "email", column = "email")
})
User selectUserDetailedById(int id);

//6. 联合查询
@Select("SELECT u.id, u.name, a.city FROM users u INNER JOIN address a ON u.id = a.user_id WHERE u.id = #{id}")
User selectUserWithAddress(int id);

//7. 分页查询
@Select("SELECT * FROM users LIMIT #{limit} OFFSET #{offset}")
List&lt;User&gt; selectUsersByPage(@Param("limit") int limit, @Param("offset") int offset);</code></pre> 
<h3 id="%E5%85%AD%E3%80%81MySQL%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%20Java%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB">【K】MySQL 数据类型与 Java 类型的对应关系</h3> 
<p>在 MyBatis 中，Java 类型和 MySQL 数据库类型之间的映射是通过 `typeHandlers` 来实现的。以下是一些常见的 MySQL 数据类型与 Java 类型的对应关系，以及在 MyBatis 的 XML 配置文件中如何配置它们的示例。</p> 
<table><thead><tr><th>MySQL 数据类型</th><th>Java 类型</th><th>MyBatis XML 配置中的类型别名</th></tr></thead><tbody><tr><td><code>CHAR</code></td><td><code>String</code></td><td><code>VARCHAR</code></td></tr><tr><td><code>VARCHAR</code></td><td><code>String</code></td><td><code>VARCHAR</code></td></tr><tr><td><code>BLOB</code></td><td><code>byte[]</code></td><td><code>BLOB</code></td></tr><tr><td><code>TEXT</code></td><td><code>String</code></td><td><code>VARCHAR</code></td></tr><tr><td><code>INTEGER</code></td><td><code>int</code>/<code>Integer</code></td><td><code>INTEGER</code></td></tr><tr><td><code>TINYINT</code></td><td><code>byte</code>/<code>Byte</code></td><td><code>TINYINT</code></td></tr><tr><td><code>SMALLINT</code></td><td><code>short</code>/<code>Short</code></td><td><code>SMALLINT</code></td></tr><tr><td><code>MEDIUMINT</code></td><td><code>int</code>/<code>Integer</code></td><td><code>INTEGER</code></td></tr><tr><td><code>BIGINT</code></td><td><code>long</code>/<code>Long</code></td><td><code>BIGINT</code></td></tr><tr><td><code>FLOAT</code></td><td><code>float</code>/<code>Float</code></td><td><code>FLOAT</code></td></tr><tr><td><code>DOUBLE</code></td><td><code>double</code>/<code>Double</code></td><td><code>DOUBLE</code></td></tr><tr><td><code>DECIMAL</code></td><td><code>java.math.BigDecimal</code></td><td><code>DECIMAL</code></td></tr><tr><td><code>DATE</code></td><td><code>java.sql.Date</code></td><td><code>DATE</code></td></tr><tr><td><code>TIME</code></td><td><code>java.sql.Time</code></td><td><code>TIME</code></td></tr><tr><td><code>DATETIME</code></td><td><code>java.sql.Timestamp</code></td><td><code>TIMESTAMP</code></td></tr><tr><td><code>TIMESTAMP</code></td><td><code>java.sql.Timestamp</code></td><td><code>TIMESTAMP</code></td></tr><tr><td><code>BOOLEAN</code></td><td><code>boolean</code>/<code>Boolean</code></td><td><code>BOOLEAN</code></td></tr><tr><td><code>ENUM</code></td><td><code>String</code></td><td><code>VARCHAR</code></td></tr><tr><td><code>SET</code></td><td><code>String</code></td><td><code>VARCHAR</code></td></tr></tbody></table> 
<p>在 MyBatis 的配置文件 `mybatis-config.xml` 中，你不需要为每种类型映射都显式定义 `typeHandler`，因为 MyBatis 已经内置了对这些常见类型的处理。但如果你需要自定义类型处理器，你可以这样配置：</p> 
<pre><code class="language-XML">&lt;typeHandlers&gt;
  &lt;typeHandler handler="com.example.MyCustomTypeHandler"/&gt;
&lt;/typeHandlers&gt;</code></pre> 
<p>以下是一个包含所有类型映射的 MyBatis 映射文件 (`UserMapper.xml`) 示例：</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.example.mapper.UserMapper"&gt;

  &lt;resultMap id="UserResultMap" type="User"&gt;
    &lt;result property="id" column="id" javaType="int" jdbcType="INTEGER" /&gt;
    &lt;result property="username" column="username" javaType="String" jdbcType="VARCHAR" /&gt;
    &lt;result property="password" column="password" javaType="String" jdbcType="VARCHAR" /&gt;
    &lt;result property="email" column="email" javaType="String" jdbcType="VARCHAR" /&gt;
    &lt;result property="profilePhoto" column="profile_photo" javaType="byte[]" jdbcType="BLOB" /&gt;
    &lt;result property="age" column="age" javaType="Integer" jdbcType="TINYINT" /&gt;
    &lt;result property="balance" column="balance" javaType="java.math.BigDecimal" jdbcType="DECIMAL" /&gt;
    &lt;result property="birthDate" column="birth_date" javaType="java.sql.Date" jdbcType="DATE" /&gt;
    &lt;result property="loginTime" column="login_time" javaType="java.sql.Timestamp" jdbcType="TIMESTAMP" /&gt;
    &lt;result property="isActive" column="is_active" javaType="Boolean" jdbcType="BOOLEAN" /&gt;
  &lt;/resultMap&gt;

  &lt;select id="selectUsers" resultMap="UserResultMap"&gt;
    SELECT * FROM users
  &lt;/select&gt;

  &lt;!-- Other CRUD operations go here --&gt;

&lt;/mapper&gt;</code></pre> 
<p>在这个示例中，`&lt;resultMap&gt;` 定义了如何将数据库表 `users` 中的列映射到 Java 类 `User` 的属性上。每个 `&lt;result&gt;` 元素指定了一个属性到列的映射，包括 Java 类型 (`javaType`) 和 JDBC 类型 (`jdbcType`)。</p> 
<p>请注意，实际开发中可能不需要为每个字段都显式指定 `jdbcType`，因为 MyBatis 通常能够推断出对应的类型。但在某些情况下，特别是当 MyBatis 无法准确推断类型时（例如对于 `null` 值），指定 `jdbcType` 可以避免类型相关的错误。</p> 
<h3 id="%E3%80%90K%E3%80%91Mybatis%E7%9B%B8%E5%90%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8">【K】Mybatis相同代码复用</h3> 
<p>在 MyBatis 中，为了避免重复编写相同的 SQL 片段，可以使用 `&lt;sql&gt;` 元素定义可重用的 SQL 代码块，并通过 `&lt;include&gt;` 元素在需要的地方引入这些代码块。这种方式提高了代码的可维护性和可读性。以下是如何使用这些元素来提取和复用相同的代码段的总结：</p> 
<h4 id="1.%20%E5%AE%9A%E4%B9%89%E5%85%AC%E5%85%B1%20SQL%20%E7%89%87%E6%AE%B5">1. 定义公共 SQL 片段</h4> 
<p>   使用 `&lt;sql&gt;` 标签定义公共的 SQL 片段，并为其指定一个唯一的 `id`。这个 `id` 将在后续的 `&lt;include&gt;` 标签中被引用。</p> 
<pre><code class="language-XML">   &lt;sql id="common_sql_where"&gt;
       &lt;if test="id != null"&gt;
           AND id = #{id}
       &lt;/if&gt;
       &lt;!-- 可以继续添加其他公共条件 --&gt;
   &lt;/sql&gt;</code></pre> 
<h4 id="2.%20%E5%BC%95%E7%94%A8%E5%85%AC%E5%85%B1%20SQL%20%E7%89%87%E6%AE%B5">2. 引用公共 SQL 片段</h4> 
<p>   在实际的查询语句中，使用 `&lt;include&gt;` 标签引入公共 SQL 片段。通过 `refid` 属性指定需要引入的公共 SQL 片段的 `id`。</p> 
<pre><code class="language-XML">   &lt;select id="selectWithCommonWhere" resultType="YourResultType"&gt;
       SELECT * FROM your_table WHERE 1=1
       &lt;include refid="common_sql_where"/&gt;
   &lt;/select&gt;</code></pre> 
<h4 id="3.%20%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0">3. 使用参数</h4> 
<p>   在公共 SQL 片段中，可以使用 MyBatis 的参数占位符 `#{}` 来引用传入的参数。确保传入的参数名称与 `&lt;if&gt;` 测试条件中的参数名称相匹配。</p> 
<h4 id="4.%20%E5%A4%8D%E7%94%A8%E5%92%8C%E7%BB%84%E5%90%88">4. 复用和组合</h4> 
<p>   可以将多个 `&lt;sql&gt;` 片段组合在一起，使用多个 `&lt;include&gt;` 标签来构建复杂的查询条件。</p> 
<pre><code class="language-XML">   &lt;select id="selectAdvanced" resultType="YourResultType"&gt;
       SELECT * FROM your_table
       WHERE 1=1
       &lt;include refid="common_sql_where"/&gt;
       &lt;!-- 可以继续引入其他公共 SQL 片段 --&gt;
   &lt;/select&gt;</code></pre> 
<h4 id="5.%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5. 注意事项</h4> 
<p>   - 确保 `&lt;include&gt;` 标签中的 `refid` 正确无误地指向了预定义的 `&lt;sql&gt;` 片段的 `id`。<br>    - 在 `&lt;sql&gt;` 片段中定义的条件必须符合 SQL 语法，特别是在使用 `&lt;if&gt;` 条件时要注意不要遗漏必要的 SQL 关键字，比如 `AND`。<br>    - 当在 `&lt;sql&gt;` 片段中使用动态 SQL（如 `&lt;if&gt;`）时，要注意条件的逻辑组合，以避免生成无效的 SQL。</p> 
<p>通过这种方式，可以有效地管理和复用 SQL 代码，减少冗余，并使得 SQL 语句的维护变得更加简单。</p> 
<h3 id="%E3%80%90K%E3%80%91mysql%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%90%8E%E7%AB%8B%E5%88%BB%E8%8E%B7%E5%8F%96%E8%AF%A5%E6%95%B0%E6%8D%AE%E8%87%AA%E5%A2%9E%E9%95%BFid%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8">【K】mysql如何实现插入一条数据后立刻获取该数据自增长id进行调用</h3> 
<h4 id="%E8%83%8C%E6%99%AF%E8%A7%A3%E6%9E%90">背景解析</h4> 
<pre><code class="language-XML">useGeneratedKeys 取值范围true|false 默认值是：false。
含义：设置是否使用JDBC的.

getGenereatedKeys方法获取主键并赋值到keyProperty设置的领域模型属性中。</code></pre> 
<h4 id="%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%94%A8">代码使用</h4> 
<pre><code class="language-XML">  &lt;insert id="insert" parameterType="com.hy.common.entity.User"
          useGeneratedKeys="true" keyProperty="id"&gt;
    insert into user (name, age)
    values ( #{name,jdbcType=VARCHAR}, #{age,jdbcType=INTEGER})
  &lt;/insert&gt;</code></pre> 
<pre><code class="language-java">    @Override
    @Transactional(readOnly = false)
    public int insertUser() {
        User user = new User();
        user.setName("why");
        user.setAge(18);
 
        int count = userMapper.insert(user);
        System.out.println(count);   // 插入的条数:1
        int id = user.getId();   
        System.out.println(id); // 自增的id:666
 
        return id;
    }</code></pre> 
<h3 id="%E3%80%90K%E3%80%91Mybatis%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AD%98%E5%9C%A8%E5%B0%B1%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%B0%B1%E6%B7%BB%E5%8A%A0">【K】Mybatis新增数据，存在就更新，不存在就添加</h3> 
<h4 id="%E5%B8%B8%E8%A7%84%E6%96%B9%E6%B3%95">常规方法</h4> 
<p>先查询是否存在，存在就更新，不存在就添加.</p> 
<p>如果数据量过大, 使用foreach批量操作</p> 
<p><strong>举例: 集合唯一索引  id</strong></p> 
<p>可以查询所有的id集合idSet,  使用in idSet查询那些存在, 返回结果集oldSet.</p> 
<p>然后遍历判断idSet是否存在oldSet, 存在走更新逻辑，不存在走添加逻辑.</p> 
<h4 id="Replace%E5%85%B3%E9%94%AE%E5%AD%97">Replace<strong>关键字</strong></h4> 
<p><strong>REPLACE关键字的使用</strong></p> 
<p>      使用REPLACE的最大好处就是可以将DELETE和INSERT合二为一，形成一个原子操作。这样就可以不必考虑在同时使用DELETE和INSERT时添加事务等复杂操作了。<br>       在使用REPLACE时，表中必须有唯一索引，而且这个索引所在的字段不能允许空值，否则REPLACE就和INSERT完全一样的。<br>       在执行REPLACE后，系统返回了所影响的行数，如果返回1，说明没有重复的记录，如果返回2，说明有重复记录，系统先DELETE这条记录，然后再INSERT这条记录。<br> 语法和INSERT非常的相似，如下面的REPLACE语句是插入或更新一条记录。</p> 
<pre><code class="language-XML">REPLACE INTO users (id,name,age) VALUES(1, '李嘉欣', 18); </code></pre> 
<h3 id="%E3%80%90K%E3%80%91MyBatis%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AAsql%E8%AF%AD%E5%8F%A5">【K】MyBatis执行多个sql语句</h3> 
<h4 id="%E8%83%8C%E6%99%AF">背景</h4> 
<pre><code class="language-XML">驱动默认不开启支持多个sql执行。
在数据库连接的url增加参数allowMultiQueries，值为true，多个SQL直接一以“;”分隔即可

xxx.jdbcUrl=jdbc:mysql://xx.xx.xx:3306/xxxxx?characterEncoding=utf-8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;allowMultiQueries=true

&amp;allowMultiQueries=true</code></pre> 
<h4 id="%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B">代码举例</h4> 
<p><img alt="" height="58" src="https://images2.imgbox.com/25/74/BERRlDaV_o.png" width="709"></p> 
<pre><code class="language-XML">&lt;select id="getUserAndOrders" resultSets="user,orders"&gt;
  select * from user where id = #{id};
  select * from orders where user_id = #{id};
&lt;/select&gt;
</code></pre> 
<h4 id="%E5%AE%9E%E4%BE%8B%E4%B8%BE%E4%BE%8B">实例举例</h4> 
<pre><code>场景：

删除用户的时候需要先删除用户的外键关联数据，否则会触发规则报错。

本人遇到的是循环拼接不同字段条件的修改sql执行。</code></pre> 
<p><strong>直接写多条语句，用“；”隔开即可</strong></p> 
<pre><code class="language-XML">&lt;delete id="deleteUserById" parameterType="String"&gt;
    delete from sec_user_role where userId=#{id};
    delete from sec_user where id=#{id};
&lt;/delete&gt;</code></pre> 
<h4 id="%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93">分析总结</h4> 
<p>执行多个SQL查询并返回多个结果集的原因简述：</p> 
<ul><li>在某些业务场景中，需要从不同的数据表中提取数据并组合成一个复合数据对象。</li><li>执行多个查询并一次性返回所有结果集可以减少数据库IO操作，提高性能。</li><li>将相关查询逻辑集中到一个地方有助于提高代码的可读性和可维护性。</li></ul> 
<p>MyBatis执行多个查询并处理结果集的方法简述：</p> 
<ul><li>MyBatis允许通过resultSets属性在一个&lt;select&gt;元素中执行多个查询并命名各个结果集。</li><li>可以使用SqlSession的selectList或selectMap方法来获取这些结果集。</li><li>结果集可以映射到不同的Java对象，并可通过自定义resultMap进行详细配置。</li></ul> 
<p><strong>总结：</strong></p> 
<p>MyBatis支持一次执行多个SQL查询并返回多个结果集，这有助于优化性能和提升代码质量。</p> 
<h3 id="%E3%80%90K%E3%80%91Mybatis%20%E4%B8%8D%E5%90%8C%E6%9D%A1%E4%BB%B6%E6%8B%BC%E6%8E%A5%E4%B8%8D%E5%90%8Csql">【K】Mybatis 不同条件拼接不同sql</h3> 
<p>在MyBatis中，可以使用动态SQL功能来根据不同的条件拼接不同的SQL语句。动态SQL是MyBatis的一大特色，它允许在XML映射文件中构建灵活的SQL语句。主要通过&lt;if&gt;, &lt;choose&gt;, &lt;when&gt;, &lt;otherwise&gt;, &lt;where&gt;, &lt;set&gt;, &lt;foreach&gt;等元素来实现条件逻辑。</p> 
<h4 id="%E4%B8%BE%E4%BE%8B1">举例1</h4> 
<p>以下是一个使用MyBatis动态SQL的例子，我们将创建一个根据不同条件来查询用户的例子。</p> 
<p>首先，定义一个User对象和一个UserMapper接口：</p> 
<pre><code class="language-java">// User.java
public class User {
    private Integer id;
    private String name;
    private String email;
    // getters and setters...
}

// UserMapper.java
public interface UserMapper {
    List&lt;User&gt; findUsers(Map&lt;String, Object&gt; params);
}
</code></pre> 
<p>然后，在MyBatis的XML映射文件中，我们定义动态SQL查询：</p> 
<pre><code class="language-XML">&lt;!-- UserMapper.xml --&gt;
&lt;mapper namespace="com.example.mapper.UserMapper"&gt;
    &lt;select id="findUsers" resultType="com.example.User"&gt;
        SELECT id, name, email
        FROM users
        &lt;where&gt;
            &lt;if test="id != null"&gt;
                AND id = #{id}
            &lt;/if&gt;
            &lt;if test="name != null"&gt;
                AND name = #{name}
            &lt;/if&gt;
            &lt;if test="email != null"&gt;
                AND email = #{email}
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre> 
<p>在这个例子中，&lt;where&gt;元素会智能地插入WHERE关键字，并且只有当内部的条件成立时才会插入相应的条件语句，并且会处理好条件语句前的AND或OR关键字。</p> 
<p>现在，当我们调用findUsers方法时，可以传递一个包含id、name、email等键的Map对象。MyBatis会根据Map中的键值对是否存在来动态构建SQL语句。</p> 
<pre><code class="language-XML">// 使用MyBatis的SqlSession来执行查询
SqlSession sqlSession = sqlSessionFactory.openSession();
try {
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
    params.put("name", "John Doe");
    List&lt;User&gt; users = mapper.findUsers(params);
    // 处理查询结果...
} finally {
    sqlSession.close();
}
</code></pre> 
<p>在上面的Java代码中，我们创建了一个包含"name"键的Map，并将其作为参数传递给findUsers方法。MyBatis会生成一个包含AND name = 'John Doe'条件的SQL语句，因为Map中只有"name"键。</p> 
<h4 id="%E4%B8%BE%E4%BE%8B2%3A%20%E6%88%96%E8%80%85%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E5%80%BC"><strong>举例2: 判断某一个值</strong></h4> 
<p id="%E4%B8%8D%E5%90%8C%E6%9D%A1%E4%BB%B6%E6%8B%BC%E6%8E%A5%E4%B8%8D%E5%90%8Csql"><strong>不同条件拼接不同sql</strong></p> 
<pre><code class="language-XML">&lt;/where&gt;
    ORDER BY
&lt;if test="name != null and name !='' and name == '1'.toString()"&gt;
    dept DESC
&lt;/if&gt;
&lt;if test="name != null and name !='' and name == '2'.toString()"&gt;
    type DESC
&lt;/if&gt;</code></pre> 
<p id="Postman%E8%AE%BF%E9%97%AE">Postman访问</p> 
<p><img alt="" height="322" src="https://images2.imgbox.com/2a/5a/XsagNcnX_o.png" width="798"></p> 
<p id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><strong>注意事项</strong></p> 
<pre><code>前言：
name代码为String，
XML 代码为: &lt;if test="name != null and name !='' and name == '1'.toString()"&gt;</code></pre> 
<ol><li>postman入参可以为"name": "1",或"name": 1</li><li>'1'需要加上单引号</li><li>加单引号后为字符,类型为Charactor</li></ol> 
<p><img alt="" height="68" src="https://images2.imgbox.com/e6/a9/PIJf6Z9u_o.png" width="306"></p> 
<h4 id="%E4%B8%BE%E4%BE%8B3">举例3</h4> 
<p>某些特殊业务场景下的, 为了替换#{demoWay}的替换写法...</p> 
<pre><code class="language-XML">            &lt;if test="demoWay != null  and test="demoWay != '' "&gt;
                &lt;if test="demoWay == 'equal' "&gt;
                    &lt;![CDATA[ and demo_str = #{demoStr} ]]&gt; &lt;/if&gt;
                &lt;if test="demoWay == 'gt' "&gt;
                    &lt;![CDATA[ and demo_str &gt; #{demoStr} ]]&gt; &lt;/if&gt;
                &lt;if test="demoWay == 'lt' "&gt;
                    &lt;![CDATA[ and demo_str &lt; #{demoStr} ]]&gt; &lt;/if&gt;
                &lt;if test="demoWay == 'gte' "&gt;
                    &lt;![CDATA[ and demo_str &gt;= #{demoStr} ]]&gt; &lt;/if&gt;
                &lt;if test="demoWay == 'lte' "&gt;
                    &lt;![CDATA[ and demo_str &lt;= #{demoStr} ]]&gt; &lt;/if&gt;
            &lt;/if&gt;</code></pre> 
<p></p> 
<p>这种动态SQL的方法使得SQL语句的构建非常灵活，可以根据传入的参数不同构建不同的查询条件，而不必编写多个几乎相同的查询语句。这样的设计既简化了代码，也使得维护更加容易。</p> 
<h3 id="%E3%80%90K%E3%80%91-IFNULL%E5%A4%84%E7%90%86N%2FA">【K】-IFNULL处理N/A</h3> 
<h4 id="%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86">背景知识</h4> 
<p>在数据库中，有时需要生成具有特定格式的唯一ID。例如，这里的ID由当前日期（格式为yyyymmdd）和一个顺序号（四位数）组成。每当需要添加新的记录时，就要生成一个新的ID，该ID比当天已有的最大ID大1。</p> 
<h4 id="SQL%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90">SQL语句分析</h4> 
<p>原始的SQL语句试图获取当天最大的ID，然后将其加1以生成新的ID。如果当天没有ID，就默认使用<code>'0001'</code>作为顺序号。</p> 
<pre><code class="language-sql">公司表获取最大ID且加1:
ID示例:yyyymmdd+0001

SELECT
    IFNULL(RIGHT(ac.id + 1, 4), '0001') numMax
FROM
    app_company ac
WHERE
    LEFT(ac.id, 8) = DATE_FORMAT(now(), '%Y%m%d')
ORDER BY
    RIGHT(ac.id, 4) DESC
LIMIT 1
</code></pre> 
<p><img alt="" height="220" src="https://images2.imgbox.com/3b/bc/Tb9roo7g_o.png" width="461"></p> 
<p>这个查询有几个问题：</p> 
<ul><li>IFNULL函数不会处理非NULL的“无效”值（如'N/A'）。</li><li>在没有任何记录的情况下，RIGHT(ac.id + 1, 4)将不会返回任何结果，因此IFNULL将返回'0001'。</li><li>使用ORDER BY和LIMIT来获取最大值效率较低。</li></ul> 
<h4 id="%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84SQL%E8%AF%AD%E5%8F%A5">改进后的SQL语句</h4> 
<p>改进后的SQL语句使用MAX函数来找出当天最大的ID，然后通过IFNULL处理当天没有任何ID的情况。这样就不需要ORDER BY和LIMIT子句，因为MAX函数已经能够找到最大的ID。</p> 
<pre><code class="language-sql">SELECT
    IFNULL(MAX(RIGHT(ac.id, 4)) + 1, '0001') numMax
FROM
    app_company ac
WHERE
    LEFT(ac.id, 8) = DATE_FORMAT(now(), '%Y%m%d')
</code></pre> 
<h4><img alt="" height="181" src="https://images2.imgbox.com/9d/d0/KIB6zVWC_o.png" width="488"></h4> 
<h4 id="%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95">知识扩展</h4> 
<ul><li>IFNULL: MySQL中的IFNULL函数用来检查第一个表达式是否为NULL，如果是，就返回第二个参数的值。</li><li>MAX: MAX函数返回一组值中的最大值，如果集合为空，则返回NULL。</li><li>RIGHT: RIGHT函数从字符串的右侧返回指定数量的字符。</li><li>LEFT: LEFT函数从字符串的左侧返回指定数量的字符。</li><li>DATE_FORMAT: DATE_FORMAT函数用于格式化日期值。</li></ul> 
<h4 id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</h4> 
<p>在实际使用中，直接在数据库层面进行ID的生成可能会有并发问题，特别是在高并发的环境下。为了确保ID的唯一性和顺序，可能需要采用其他机制，比如应用层的锁或者使用数据库的序列（在MySQL 8.0+中为AUTO_INCREMENT属性）。</p> 
<p>此外，如果ac.id是字符型字段，直接进行+ 1操作可能会导致错误，因为字符型和数值型的操作不同。在这种情况下，可能需要先将ID的顺序号部分转换为数值型，进行加法操作后再转换回字符型。</p> 
<h3 id="%E3%80%90K%E3%80%91Mybatis%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%EF%BC%9Cwhere%EF%BC%9E%E6%A0%87%E7%AD%BE">【K】Mybatis条件查询＜where＞标签</h3> 
<p>MyBatis 的 &lt;where&gt; 标签用于动态生成 SQL 查询语句中的 WHERE 条件。该标签的主要作用是简化 SQL 编写，并自动处理 WHERE 关键字和条件之间的逻辑关系（如 AND 或 OR）。当内部条件为空时，它会智能地省略 WHERE 关键字，而当有条件时，则会自动加上 WHERE 关键字。这样可以避免在动态 SQL 中手动编写复杂的逻辑来判断是否需要添加 WHERE 关键字。<br> &lt;where&gt; 标签的基本规则：</p> 
<p>    &lt;where&gt; 标签内部可以包含 &lt;if&gt;、&lt;choose&gt;、&lt;when&gt;、&lt;otherwise&gt; 等子标签。<br>     如果 &lt;where&gt; 标签内部的条件都不成立，则整个 &lt;where&gt; 标签不会生成任何内容。<br>     如果 &lt;where&gt; 标签内部至少有一个条件成立，则会自动在这些条件前添加 WHERE 关键字。<br>     &lt;where&gt; 标签会自动处理条件之间的第一个 AND 或 OR 关键字。</p> 
<p><strong>示例：</strong></p> 
<p>假设我们有一个 User 表，包含 id、name、email 等字段，现在我们要根据这些字段的不同组合来查询用户。</p> 
<p>UserMapper 接口：</p> 
<pre><code class="language-java">public interface UserMapper {
    List&lt;User&gt; findUsers(Map&lt;String, Object&gt; params);
}
</code></pre> 
<p>UserMapper.xml 映射文件：</p> 
<pre><code class="language-XML">&lt;mapper namespace="com.example.mapper.UserMapper"&gt;
    &lt;select id="findUsers" resultType="com.example.User"&gt;
        SELECT id, name, email
        FROM User
        &lt;where&gt;
            &lt;if test="id != null"&gt;
                id = #{id}
            &lt;/if&gt;
            &lt;if test="name != null and name != ''"&gt;
                AND name = #{name}
            &lt;/if&gt;
            &lt;if test="email != null and email != ''"&gt;
                AND email = #{email}
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre> 
<p>在上述例子中：</p> 
<ul><li>如果 params 中没有任何一个键值对，则 SQL 语句将是 SELECT id, name, email FROM User。<br> 如果 params 中只有 name 键值对，则 SQL 语句将是 SELECT id, name, email FROM User WHERE name = '指定的name值'。<br> 如果 params 中有 name 和 email 键值对，则 SQL 语句将是 SELECT id, name, email FROM User WHERE name = '指定的name值' AND email = '指定的email值'。</li></ul> 
<p>这种方式确保了 WHERE 条件的灵活性和正确性，同时避免了手动编写复杂的逻辑来控制 SQL 语句的准确性。使用 &lt;where&gt; 标签可以大大提高 SQL 语句的可维护性和可读性。</p> 
<h3 id="articleContentId">【K】使用resultMap封装对象一对多</h3> 
<p>在 MyBatis 中，`resultMap` 是一个非常强大的映射工具，它能够处理复杂的数据库关系，如一对一、一对多和多对多的关系。通过正确使用 `resultMap`，可以在执行单个查询时获取关联的数据，而不必执行多次查询，这样可以提高应用程序的性能。</p> 
<p>下面是一个使用 `resultMap` 来处理一对一和一对多关系的完整示例。</p> 
<h4 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9E%8B">数据库模型</h4> 
<p>假设我们有以下三个表：</p> 
<p>1. 用户表 `user`<br> 2. 部门表 `department`<br> 3. 用户联系人表 `user_linkman`</p> 
<p>用户表（user）:</p> 
<pre><code class="language-sql">CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `code` varchar(255) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `age` int(2) unsigned DEFAULT NULL,
  `department_id` int(11) NOT NULL COMMENT '部门id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';</code></pre> 
<p>部门表（department）:</p> 
<pre><code class="language-sql">CREATE TABLE `department` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '部门id',
  `department_name` varchar(255) DEFAULT NULL COMMENT '部门名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT='部门表';</code></pre> 
<p>用户联系人表（user_linkman）:</p> 
<pre><code class="language-sql">CREATE TABLE `user_linkman` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户联系人表主键id',
  `user_id` int(11) DEFAULT NULL COMMENT '用户id',
  `linkman_id` varchar(255) DEFAULT NULL COMMENT '联系人id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COMMENT='用户联系人表';</code></pre> 
<h4 id="%E5%AE%9E%E4%BD%93%E7%B1%BB">实体类</h4> 
<p>用户实体类（User）:</p> 
<pre><code class="language-java">package com.example.demo.entity;

import lombok.Data;
import java.util.List;

@Data
public class User {
    private String id;
    private String code;
    private String name;
    private int age;
    private Department department;      // 对应部门实体
    private List&lt;UserLinkman&gt; linkmenList; // 对应联系人列表
}</code></pre> 
<h4 id="MyBatis%20%E9%85%8D%E7%BD%AE">MyBatis 配置</h4> 
<p>在 MyBatis 的映射文件中，我们可以定义一个 `resultMap` 来描述如何从数据库结果集映射到我们的实体类。</p> 
<pre><code class="language-XML">&lt;resultMap id="userResultMap" type="User"&gt;
    &lt;id property="id" column="id" /&gt;
    &lt;result property="code" column="code" /&gt;
    &lt;result property="name" column="name" /&gt;
    &lt;result property="age" column="age" /&gt;
    &lt;association property="department" column="department_id" javaType="Department" select="selectDepartmentById" /&gt;
    &lt;collection property="linkmenList" ofType="UserLinkman" column="id" select="selectLinkmanListByUserId" /&gt;
&lt;/resultMap&gt;

&lt;select id="selectDepartmentById" resultType="Department"&gt;
    SELECT id, department_name AS 'departmentName' FROM department WHERE id = #{id}
&lt;/select&gt;

&lt;select id="selectLinkmanListByUserId" resultType="UserLinkman"&gt;
    SELECT id, user_id AS 'userId', linkman_id AS 'linkmanId' FROM user_linkman WHERE user_id = #{id}
&lt;/select&gt;

&lt;select id="selectUserById" resultMap="userResultMap"&gt;
    SELECT * FROM user WHERE id = #{id}
&lt;/select&gt;</code></pre> 
<p>在上述配置中，我们定义了一个 `userResultMap`：</p> 
<p>- `&lt;association&gt;` 用于处理一对一的关系，这里是用户和部门的关系。<br> - `&lt;collection&gt;` 用于处理一对多的关系，这里是用户和联系人的关系。</p> 
<p>通过这种配置，当我们调用 `selectUserById` 查询时，MyBatis 会自动执行 `selectDepartmentById` 和 `selectLinkmanListByUserId` 查询来填充 `User` 实体中的 `department` 和 `linkmenList` 属性。</p> 
<h4 id="%E4%B8%BE%E4%BE%8B">举例</h4> 
<p>假设我们需要查询某次考试的所有单位信息，包括名称、参考人数、通过人数、通过率，以及本部门所有参考人员的信息。我们可以创建一个对应的 `resultMap`：</p> 
<pre><code class="language-XML">&lt;resultMap id="CountResultMap" type="com.example.demo.entity.vo.ExamTestVo"&gt;
    &lt;result column="department" jdbcType="VARCHAR" property="department"/&gt;
    &lt;result column="exam_num" jdbcType="VARCHAR" property="examNum"/&gt;
    &lt;result column="pass_num" jdbcType="VARCHAR" property="passNum"/&gt;
    &lt;result column="percent_pass" jdbcType="VARCHAR" property="percentPass"/&gt;
    &lt;collection property="userList" javaType="list" column="id" ofType="User" select="selectUserListByExamId" /&gt;
&lt;/resultMap&gt;</code></pre> 
<p>这里的 `&lt;collection&gt;` 标签将会把某个考试 ID 对应的所有用户信息作为一个列表映射到 `ExamTestVo` 的 `userList` 属性中。这样，通过单个查询，我们就能获取一个考试的所有相关信息，包括每个单位的详细数据和参考人员的列表。</p> 
<h3 id="%E3%80%90K%E3%80%91Mybatis%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D">【K】Mybatis使用常见类型的类型别名</h3> 
<p>MyBatis 提供了一系列内置的类型别名，用于简化 XML 配置文件中的类型引用。这些别名代表了 Java 中的一些常见类型。使用类型别名可以让你的 MyBatis 配置文件更加简洁易懂。</p> 
<p>下面是一些常见的 MyBatis 内置类型别名及其对应的 Java 类型：</p> 
<table><thead><tr><th>Java 类型</th><th>MyBatis 别名</th></tr></thead><tbody><tr><td>byte</td><td>_byte</td></tr><tr><td>long</td><td>_long</td></tr><tr><td>short</td><td>_short</td></tr><tr><td>int</td><td>_int</td></tr><tr><td>Integer</td><td>_integer</td></tr><tr><td>double</td><td>_double</td></tr><tr><td>float</td><td>_float</td></tr><tr><td>boolean</td><td>_boolean</td></tr></tbody></table> 
<p>还有一些引用类型的别名：</p> 
<table><thead><tr><th>Java 类型</th><th>MyBatis 别名</th></tr></thead><tbody><tr><td>String</td><td>string</td></tr><tr><td>Byte</td><td>byte</td></tr><tr><td>Long</td><td>long</td></tr><tr><td>Short</td><td>short</td></tr><tr><td>Integer</td><td>int</td></tr><tr><td>Double</td><td>double</td></tr><tr><td>Float</td><td>float</td></tr><tr><td>Boolean</td><td>boolean</td></tr><tr><td>Date</td><td>date</td></tr><tr><td>BigDecimal</td><td>decimal</td></tr><tr><td>BigDecimal</td><td>bigdecimal</td></tr><tr><td>Object</td><td>object</td></tr><tr><td>Map</td><td>map</td></tr><tr><td>HashMap</td><td>hashmap</td></tr><tr><td>List</td><td>list</td></tr><tr><td>ArrayList</td><td>arraylist</td></tr><tr><td>Collection</td><td>collection</td></tr><tr><td>Iterator</td><td>iterator</td></tr></tbody></table> 
<p>使用这些类型别名的例子：</p> 
<pre><code class="language-XML">&lt;select id="selectUserById" resultType="_int"&gt;
    SELECT age FROM user WHERE id = #{id}
&lt;/select&gt;

&lt;select id="selectUserName" resultType="string"&gt;
    SELECT name FROM user WHERE id = #{id}
&lt;/select&gt;

&lt;select id="selectAllUsers" resultType="map"&gt;
    SELECT * FROM user
&lt;/select&gt;</code></pre> 
<p>在上述例子中，`resultType="_int"` 表示查询的结果是一个基本类型 `int`，`resultType="string"` 表示查询的结果是 `String` 类型，而 `resultType="map"` 表示查询的结果是 `Map` 类型的集合。</p> 
<p>要注意的是，当我们使用类型别名 `_int` 时，通常是在查询返回单个值的场景，比如统计数量或者查询某个特定的数值</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b0/19/pneOSL5M_o.gif"></p> 
<p><span style="color:#ff9900;"><strong>有用请点赞，养成良好习惯！</strong></span></p> 
<p><span style="color:#ff9900;"><strong>疑问、交流、鼓励请留言！</strong></span></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/649b2560a300f81b30668e81acefa6f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Termux安装图形桌面xfce4</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b430ebe57b5ce6e50cf04b49dc19959/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">开源学习项目推荐</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>