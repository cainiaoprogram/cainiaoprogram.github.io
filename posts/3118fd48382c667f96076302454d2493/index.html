<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>存储性能软件加速库（SPDK） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="存储性能软件加速库（SPDK）" />
<meta property="og:description" content="存储性能软件加速库SPDK 存储加速存储性能软件加速库（SPDK）SPDK NVMe驱动1.用户态驱动1）UIO2）VFIOIOMMU（I/O Memory Management Unit） 3）用户态DMA4）大页（Hugepage） 2.SPDK用户态驱动1）异步轮询方式2）无锁化3）专门为Flash来优化 3.SPDK NVMe驱动性能4.SPDK NVMe驱动新特性5.SPDK用户态驱动多进程的支持1）共享内存2）共享NVMe SSD3）管理软件完成队列4）NVMe SSD共享管理流程 存储加速 一般从应用的角度来讲，一个存储任务或需求的完成，可以理解为用户从软件（客户端）发出一个存储需求（包括读和写），然后从存储设备返回用户的软件的过程。
存储服务到存储设备的整个I/O栈包括软件自身的I/O逻辑、网络的I/O逻辑、存储驱动的I/O逻辑，在其中可以找到很多可以优化的点。例如，在内存中，可以利用CPU的特殊指令对一些存储保护算法进行优化；在所经过的网络上，可以把数据传输的任务从CPU中卸载，交由具备RDMA功能的网卡或智能网卡来**进行远程DMA**；在操作系统到实际存储设备落盘的过程中，可以通过用户态的I/O栈来旁路（Bypass）操作系统内部的大部分I/O栈进行加速。
从目前来讲，无论在存储I/O处理的哪个阶段采用加速技术，都不能缺少软件的参与（可以是主机的软件，也可以是firmware中的软件），所以简单依照软件和硬件来划分存储技术的加速方案并没有多少价值。这里我们把存储的加速方案分为以下两类。
基于CPU处理器的加速和优化方案。基于协处理器或其他硬件的加速方案。 基于英特尔IA平台的两个对CPU加速的软件库：智能存储加速库（Intelligent StorageAcceleration Library，ISA-L）和存储性能软件的加速库（SPDK）。本章会着重介绍存储性能软件的加速库（SPDK）。
存储性能软件加速库（SPDK） SPDK每年发布4个版本,用于加速NVMe SSD作为后端存储使用的应用软件加速库,这个软件库的核心是用户态、异步、轮询方式的NVMe驱动,把**内核驱动放到用户态**，导致需要在用户态实施一套基于用户态软件驱动的完整I/O栈。文件系统毫无疑问是其中一个重要的话题，显而易见内核的文件系统，如ext4、Btrfs等都不能直接使用了。虽然目前SPDK提供了非常简单的文件系统blobfs/blostore，但是并不支持可移植操作系统接口，为此使用文件系统的应用需要将其直接迁移到SPDK的用户态“文件系统”上，同时需要做一些代码移植的工作，如不使用可移植操作系统接口，而采用类似AIO的异步读/写方式.
目前SPDK使用比较好的场景有以下几种
提供块设备接口的后端存储应用，如iSCSI Target、NVMe-oF Target。对虚拟机中I/O的加速SPDK加速数据库存储引擎 SPDK NVMe驱动 在NVMe之前，相对来说一个存在时间更长的接口标准是串行ATA高级 主 机 控 制 器 接 口 （ Serial ATA Advanced Host Controller Interface ，AHCI）。AHCI是在英特尔领导下由多家公司联合研发的接口标准，它允许存储驱动程序启用高级串行ATA功能。相对于传统的IDE技术，AHCI对传统硬盘性能提高带来了改善。但是随着新介质、新技术的发展，AHCI对Flash SSD来说逐渐成为性能瓶颈，这个时候NVMe应运而生。
性能的影响主要在于固态硬盘（包括firmware）和软件的开销。从持续满足上层应用的高性能的角度看，有两种途径：一是开发更高性能的固态硬盘硬件设备；二是减少软件的开销。
基于最新3D XPoint技术的Intel Optane NVMe SSD设备可以在延迟和吞吐量方面使得性能更上一层楼。**软件的开销是NVMe SSD的性能瓶颈**
SPDK的核心组件之一就是用户态NVMe驱动
1.用户态驱动 应用程序是怎么和内核驱动进行交互的?
当内核驱动模块在内核加载成功后，会被标识是块设备还是字符设备，同时定义相关的访问接口，包括管理接口、数据接口等。这些接口直接或间接和文件系统子系统结合，提供给用户态的程序，通过**系统调用的方式**发起控制和读/写操作。
用户态应用程序和内核驱动的交互离不开用户态和内核态的上下文切换，以及系统调用的开销。
用户态驱动出现的目的就是减少软件本身的开销，包括这里所说的上下文切换、系统调用等。
在用户态，目前可以通过UIO（Userspace I/O）或VFIO（Virtual Function I/O）两种方式对硬件固态硬盘设备进行访问。
1）UIO 要在用户态实现设备驱动，主要需要解决以下两个问题。
· 如何访问设备的内存：Linux通过映射物理设备的内存到用户态来提供访问，但是这种方法会引入安全性和可靠性的问题。UIO通过限制不相关的物理设备的映射改善了这个问题。由此基于UIO开发的用户态驱动不需要关心与内存映射相关的安全性和可靠性的问题。如何处理设备产生的中断：中断本身需要在内核处理，因此针对这个限制，还需要一个小的内核模块通过最基本的中断服务程序来处理。这个中断服务程序可以只是向操作系统确认中断，或者关闭中断等最基础的操作，剩下的具体操作可以在用户态处理。 UIO架构如图所示" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3118fd48382c667f96076302454d2493/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-16T15:46:54+08:00" />
<meta property="article:modified_time" content="2023-02-16T15:46:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">存储性能软件加速库（SPDK）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>存储性能软件加速库SPDK</h4> 
 <ul><li><a href="#_3" rel="nofollow">存储加速</a></li><li><a href="#SPDK_14" rel="nofollow">存储性能软件加速库（SPDK）</a></li><li><ul><li><a href="#SPDK_NVMe_24" rel="nofollow">SPDK NVMe驱动</a></li><li><ul><li><a href="#1_31" rel="nofollow">1.用户态驱动</a></li><li><ul><li><a href="#1UIO_40" rel="nofollow">1）UIO</a></li><li><a href="#2VFIO_52" rel="nofollow">2）VFIO</a></li><li><ul><li><a href="#IOMMUIO_Memory_Management_Unit_55" rel="nofollow">IOMMU（I/O Memory Management Unit）</a></li></ul> 
     </li><li><a href="#3DMA_60" rel="nofollow">3）用户态DMA</a></li><li><a href="#4Hugepage_79" rel="nofollow">4）大页（Hugepage）</a></li></ul> 
    </li><li><a href="#2SPDK_85" rel="nofollow">2.SPDK用户态驱动</a></li><li><ul><li><a href="#1_89" rel="nofollow">1）异步轮询方式</a></li><li><a href="#2_100" rel="nofollow">2）无锁化</a></li><li><a href="#3Flash_110" rel="nofollow">3）专门为Flash来优化</a></li></ul> 
    </li><li><a href="#3SPDK_NVMe_117" rel="nofollow">3.SPDK NVMe驱动性能</a></li><li><a href="#4SPDK_NVMe_121" rel="nofollow">4.SPDK NVMe驱动新特性</a></li><li><a href="#5SPDK_130" rel="nofollow">5.SPDK用户态驱动多进程的支持</a></li><li><ul><li><a href="#1_135" rel="nofollow">1）共享内存</a></li><li><a href="#2NVMe_SSD_140" rel="nofollow">2）共享NVMe SSD</a></li><li><a href="#3_145" rel="nofollow">3）管理软件完成队列</a></li><li><a href="#4NVMe_SSD_152" rel="nofollow">4）NVMe SSD共享管理流程</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>存储加速</h2> 
<p>一般从应用的角度来讲，<strong>一个存储任务或需求的完成</strong>，可以理解为用户从<code>软件（客户端）</code>发出一个<code>存储需求（包括读和写）</code>，然后<code>从存储设备返回用户的软件</code>的过程。</p> 
<p>存储服务到存储设备的整个I/O栈包括<code>软件自身的I/O逻辑</code>、网络的I/O逻辑、<code>存储驱动的I/O逻辑</code>，在其中可以找到很多可以优化的点。例如，<strong>在内存中</strong>，可以利用<strong>CPU的特殊指令</strong>对一些存储保护算法进行优化；<code>在所经过的网络上</code>，可以<strong>把数据传输的任务从CPU中卸载</strong>，交由具备<code>RDMA功能的网卡或智能网卡来**进行远程DMA**</code>；在<strong>操作系统到实际存储设备落盘的过程</strong>中，可以通过<code>用户态的I/O栈</code>来旁路（Bypass）操作系统内部的大部分I/O栈进行加速。<br> 从目前来讲，无论在<strong>存储I/O处理的哪个阶段采用加速技术</strong>，都不能缺少软件的参与（可以是主机的软件，也可以是firmware中的软件），所以简单依照软件和硬件来划分存储技术的加速方案并没有多少价值。这里我们把存储的加速方案分为以下两类。</p> 
<ul><li>基于CPU处理器的加速和优化方案。</li><li>基于协处理器或其他硬件的加速方案。</li></ul> 
<p>基于英特尔IA平台的两个对CPU加速的软件库：智能存储加速库（Intelligent StorageAcceleration Library，ISA-L）和<strong>存储性能软件的加速库（SPDK）</strong>。本章会着重介绍存储性能软件的加速库（SPDK）。</p> 
<h2><a id="SPDK_14"></a>存储性能软件加速库（SPDK）</h2> 
<p>SPDK每年发布<code>4</code>个版本,用于<code>加速NVMe SSD作为后端</code>存储使用的应用软件加速库,这个软件库的核心是<code>用户态、异步、轮询</code>方式的NVMe驱动,把<code>**内核驱动放到用户态**</code>，导致需要在用户态实施一套基于用户态软件驱动的完整I/O栈。文件系统毫无疑问是其中一个重要的话题，显而易见内核的文件系统，如ext4、Btrfs等都不能直接使用了。虽然目前SPDK提供了非常<strong>简单的文件系统blobfs/blostore</strong>，但是并<code>不支持</code>可移植操作系统接口，为此使用文件系统的应用需要将其直接迁移到SPDK的用户态“文件系统”上，同时需要做一些代码移植的工作，如<code>不使用可移植操作系统接口</code>，而采用<strong>类似AIO</strong>的异步读/写方式.<br> 目前SPDK使用比较好的场景有以下几种</p> 
<ul><li>提供块设备接口的后端存储应用，如iSCSI Target、NVMe-oF Target。</li><li>对虚拟机中I/O的加速</li><li>SPDK加速数据库存储引擎</li></ul> 
<h3><a id="SPDK_NVMe_24"></a>SPDK NVMe驱动</h3> 
<p>在NVMe之前，相对来说一个存在时间更长的接口标准是串行ATA高级 主 机 控 制 器 接 口 （ Serial ATA Advanced Host Controller Interface ，AHCI）。AHCI是在英特尔领导下由多家公司联合研发的接口标准，它允许存储驱动程序启用高级串行ATA功能。相对于传统的IDE技术，AHCI对传统硬盘性能提高带来了改善。但是随着新介质、新技术的发展，<strong>AHCI对Flash SSD来说逐渐成为性能瓶颈</strong>，这个时候NVMe应运而生。</p> 
<p>性能的影响主要在于<code>固态硬盘（包括firmware）</code>和<code>软件的开销</code>。从持续满足上层应用的高性能的角度看，有两种途径：一是<strong>开发更高性能的固态硬盘硬件设备</strong>；二是<code>减少软件的开销</code>。<br> 基于最新<strong>3D XPoint技术的Intel Optane NVMe SSD设备</strong>可以在延迟和吞吐量方面使得性能更上一层楼。<code>**软件的开销是NVMe SSD的性能瓶颈**</code></p> 
<p><strong>SPDK的核心组件之一就是<code>用户态NVMe驱动</code></strong></p> 
<h4><a id="1_31"></a>1.用户态驱动</h4> 
<p><strong>应用程序是怎么和内核驱动进行交互的?</strong><br> 当<strong>内核驱动模块在内核</strong>加载成功后，会被标识是<strong>块设备</strong>还是字符设备，同时定义相关的访问接口，包括<strong>管理接口、数据接口</strong>等。这些接口<code>直接或间接和文件系统子系统</code>结合，提供给用户态的程序，通过<code>**系统调用的方式**</code>发起控制和读/写操作。</p> 
<p>用户态应用程序和内核驱动的交互离不开用户态和内核态的上下文切换，以及系统调用的开销。</p> 
<p>用户态驱动出现的<strong>目的就是减少软件本身的开销，包括这里所说的上下文切换、系统调用等。</strong></p> 
<p><strong>在用户态</strong>，目前可以通过UIO（Userspace I/O）或VFIO（Virtual Function I/O）两种方式<strong>对硬件固态硬盘设备</strong>进行访问。</p> 
<h5><a id="1UIO_40"></a>1）UIO</h5> 
<p>要在<strong>用户态实现设备驱动</strong>，主要需要解决以下两个问题。</p> 
<ul><li>· <code>如何访问设备的内存</code>：Linux通过<strong>映射物理设备的内存到用户态来提供访问</strong>，但是这种方法会引入安全性和可靠性的问题。UIO通过限制不相关的物理设备的映射改善了这个问题。由此基于UIO开发的用户态驱动不需要关心与内存映射相关的安全性和可靠性的问题。</li><li><code>如何处理设备产生的中断</code>：<strong>中断本身需要在内核处理</strong>，因此针对这个限制，<strong>还需要</strong>一个小的内核模块通过<strong>最基本的中断服务程序</strong>来处理。这个中断服务程序可以只是向操作系统确认中断，或者关闭中断等最基础的操作，剩下的具体操作可以在用户态处理。</li></ul> 
<p>UIO架构如图所示<br> <img src="https://images2.imgbox.com/0f/d6/qYNVsAVe_o.png" alt="在这里插入图片描述"></p> 
<p>用户态驱动和UIO内核模块通过/dev/uioX设备来实现基本交互，同时通过sysfs来得到相关的设备、内存映射、内核驱动等信息。</p> 
<h5><a id="2VFIO_52"></a>2）VFIO</h5> 
<p><strong>VFIO</strong>不仅提供了UIO所能提供的两个最基础的功能，<strong>更多的是从安全角度考虑</strong><br> 把设备I/O、中断、DMA暴露到用户空间，从而可以在用户空间完成设备驱动的框架。这里的一个<strong>难点</strong>是<code>如何将DMA以安全可控的方式暴露到用户空间</code>，防止设备通过写内存的任意页来发动DMA攻击。</p> 
<h6><a id="IOMMUIO_Memory_Management_Unit_55"></a>IOMMU（I/O Memory Management Unit）</h6> 
<p><img src="https://images2.imgbox.com/2e/49/oESllehA_o.png" alt="在这里插入图片描述"></p> 
<p>IOMMU（I/O Memory Management Unit）的引入对<code>设备进行了限制</code>，设备I/O地址<code>需要经过IOMMU重映射</code>为内存物理地址（见图）。那么<code>恶意的或存在错误的设备</code>就不能读/写<strong>没有被明确映射过的内存</strong>。操作系统以<code>互斥的方式管理MMU和IOMMU</code>，这样物理设备将<code>不能绕过或污染</code>可配置的内存管理表项。</p> 
<h5><a id="3DMA_60"></a>3）用户态DMA</h5> 
<p>虚线代表设备通过DMA直接访问相应的内存页，实线代表CPU访问内存页的方式<br> <img src="https://images2.imgbox.com/22/a1/jsmXgy1k_o.png" alt="在这里插入图片描述"></p> 
<p>基于UIO和VFIO，我们可以实现用户态的驱动，<code>把一个硬件设备分配给一个进程</code>，允许该进程来操作和读/写该设备。这在一定程度上提高了进程对设备的访问效率，<strong>不需要通过内核驱动来产生额外的内存复制</strong>，而是可以<code>直接从用户态发起对设备的DMA</code></p> 
<p>是这里需要考虑以下3个问题:</p> 
<ul><li>提供设备可以认知的内存地址（可以是物理地址，也可以是虚拟地址）。</li><li><code>物理内存必须在位</code>（考虑到虚拟内存可能被操作系统交换出去，产生缺页）。</li><li>CPU对内存的更新必须对设备可见。</li></ul> 
<p>第1个和第3个问题得益于英特尔平台的技术演进，通过设备直接支持IOMMU，同时和CPU之间实现<strong>缓存一致性（Cache-Coherent）来解决</strong>。</p> 
<p>从用户态进程来看，<code>怎么保证在DMA的过程中物理内存是在位的</code>?<br> 现在Linux主流被认可的方法是<code>人工把虚拟地址对应的物理内存Pin在位置上</code>（意思是不会被换出）。这样，无论你用的是物理地址还是虚拟地址，只要完成了Pin的操作，这个地址就可以用于DMA。</p> 
<h5><a id="4Hugepage_79"></a>4）大页（Hugepage）</h5> 
<p><code>虚拟地址映射到物理地址的工作</code>主要是TLB（Translation Lookaside Buffers）与MMU一起来完成的。以4KB的页大小为例，虚拟地址寻址时，<strong>首先在TLB中查找</strong>，如果没有找到，则需要通过MMU加载的页表基地址<strong>进行多次寻表</strong>来找到对应的物理地址。如果找不到，则<strong>产生缺页</strong>，这时会有相应的<strong>handler进行处理</strong>，<strong>来填充页表和更新TLB</strong>。通过页表查询而导致缺页带来的CPU开销是非常大的，<strong>TLB的出现能很好地解决性能问题</strong>。但是经常性的缺页是不可避免的，为此我们可以<strong>采取大页的方式</strong>。因为页大小的增加，可以减少缺页异常。TLB同样的空间可以保存更多虚存空间到物理空间的映射。尽可能地利用TLB，少用MMU，以减少寻址和缺页处理带来的开销，从而提高应用程序的整体性能。</p> 
<p>大页还有一个优势是这些预先分配的内存基本上不会被换出，当进行DMA的时候，所对应的虚拟地址永远有相对应的物理页。</p> 
<h4><a id="2SPDK_85"></a>2.SPDK用户态驱动</h4> 
<p><img src="https://images2.imgbox.com/ad/d1/wRrlg3TA_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1_89"></a>1）异步轮询方式</h5> 
<p>UIO和VFIO需要在内核实现最基本的中断功能来响应设备的中断请求。而SPDK更进一步，这些中断<strong>请求不需要通知到用户态来处理</strong>，在UIO和VFIO内核模块做最简化的处理就可以了。</p> 
<p>这种处理方式的原因</p> 
<ul><li>把<strong>内核态的中断抛到用户态进程来处理</strong>对大部分硬件是不合适的</li><li>中断会<strong>引入软件处理的不确定性</strong>，同时不能避免上下文的切换</li></ul> 
<p>SPDK用户态驱动的操作基本上都是采用了异步轮询的方式，轮询到操作完成时会触发上层的回调函数，这样使得应用程序无须等待读或写操作的完成，就可以按需发送多个请求，再由回调函数处理。由此来提高应用的读/写性能。这样的方式从性能上来说是有很大帮助的，但是要发挥出这个特点，需要应用做出相应的修改来匹配优化的异步轮询操作。</p> 
<h5><a id="2_100"></a>2）无锁化</h5> 
<p>主要考虑以下问题</p> 
<ul><li>读/写处理要在一个CPU核上完成，避免核间的缓存同步。</li><li>单核上的处理，对资源的分配是无锁化的。</li></ul> 
<p>针对第一个问题，可以通过<code>线程亲和性</code>的方法，来将某个处理线程绑定到某个特定的核上，同时<code>通过轮询的方式占住该核的使用</code>，避免操作系统调度其他的线程到该核上面。当应用程序接收到这个核上的读/写请求的时候，采用运行直到完成（Run To Completion）的方式，把这个读/写请求的整个生命周期都绑定在这个核上来完成。</p> 
<p>这其中涉及第二个问题，在处理该核上的读/写请求时，需要分配相关的资源，如Buffer。这些Buffer主要通过大页分配而来。DPDK为SPDK提供了基础的内存管理，<code>单核上的资源依赖于DPDK的内存管理</code>，不仅提供了核上的专门资源，还提供了<code>高效访问全局资源的数据结构</code>，如mempool、无锁队列、环等。</p> 
<h5><a id="3Flash_110"></a>3）专门为Flash来优化</h5> 
<p>内核驱动的设计以<code>通用性</code>为主，<code>考虑了不同的硬件设备实现一个通用的块设备驱动的问题</code>。这样的设计有很好的兼容性和维护性，<code>但是单从性能角度看，不一定能发挥出特定性能的优势</code>。</p> 
<p>SPDK作为用户态驱动，就是<code>专门针对高速NVMe SSD设备的</code>。为了能让上层应用程序<code>充分利用硬件设备的高性能（高带宽、低延时）</code>，SPDK实现了一组C代码开发库，这些开发库的接口可以直接和应用程序结合起来。</p> 
<p><code>通过UIO或VFIO把PCI设备的BAR（Base Address Register）地址映射到应用进程的空间</code>，这样SPDK用户态驱动就可以遵循NVMe的规范来初始化NVMe SSD，创建出最基本的I/O发送和完成队列，最终实现对NVMe SSD设备的I/O读或写操作。</p> 
<h4><a id="3SPDK_NVMe_117"></a>3.SPDK NVMe驱动性能</h4> 
<p>SPDK用户态驱动是专门为NVMe SSD优化的，尤其是对高速NVMe SSD，比如基于3D XPoint的Intel Optane设备，能够在单CPU核上管理多个NVMe SSD设备，实现高吞吐量、低延时、多设备、高效CPU使用的特点</p> 
<h4><a id="4SPDK_NVMe_121"></a>4.SPDK NVMe驱动新特性</h4> 
<ul><li>Reservations：可以很好地<strong>支持双控制器的NVMe SSD</strong>（如Intel D3700），在需要高可靠性的场景下，达到控制器的备份冗余<br> · Scatter Gather List（SGL）：<strong>可以更灵活地分配内存，减少I/O操作，提供高效的读/写操作</strong><br> · Multiple Namespace：可以<code>暴露给上层应用多个逻辑空间</code>，做到在同一物理设备上的共享和隔离。<br> · In Controller Memory Buffer（CMB）：<code>可以把I/O的发送和完成队列放到固态硬盘设备上</code>，同时相应的Buffer也从固态硬盘设备上来分配，一方面可以减少延时，另一方面使得两个NVMe SSD设备间的DMA成为可能。</li></ul> 
<h4><a id="5SPDK_130"></a>5.SPDK用户态驱动多进程的支持</h4> 
<p>前面提到SPDK用户态驱动会暴露对应的API给应用程序来控制和操作硬件设备。<code>此时内核NVMe驱动已经不会对设备做任何的操作，所以类似于/dev/nvme0和/dev/nvme0n1的设备不会存在</code>。这样带来一个问题，<code>如果多个应用程序都需要访问同一个硬件设备的话</code>，那么SPDK用户态驱动该如何来支持。</p> 
<p><img src="https://images2.imgbox.com/b8/b8/gPphPquw_o.png" alt="在这里插入图片描述"><br> 这 里 NVMe SSD 可 以 <strong>通 过 不 同 的 Namespace</strong> ， 或 者 在 <strong>同 一 个Namespace中划分出不同的空间</strong>分配给不同的应用程序来进行数据存储**。Optane作为性能极高的设备**，可以划分不同的空间给不同的应用作为数据缓存。基于DPDK共享设备的底层支持，SPDK用户态驱动也解决了应用之间共享同一个硬件设备的问题。</p> 
<h5><a id="1_135"></a>1）共享内存</h5> 
<p><img src="https://images2.imgbox.com/84/1b/PMEjU7AX_o.png" alt="在这里插入图片描述"></p> 
<p>在初始化这些共享资源之前，我们<code>给相关的进程做了区分</code>，可以显示指定某个进程为主进程（Master Process），或者系统自动判断第一个进程为主进程。<code>当主进程启动的时候，把相关的资源分配好</code>，同时<code>初始化完成需要共享的资源</code>。当配置副进程（Slave Process）的应用启动时，<code>无须再去分配</code>内存资源，<code>只需要通过共同的标识符来匹配主进程</code>，把<code>相关的内存资源配置到副进程上即可</code></p> 
<h5><a id="2NVMe_SSD_140"></a>2）共享NVMe SSD</h5> 
<p>SPDK在单CPU核的情况下，可以很容易地具备低延时、高带宽的特性，这些性能指标只需要依赖少数甚至单个I/O队列就可以达到。因此这里的I/O队列是<code>需要让某个进程从逻辑上单独使用的，即便整个NVMe SSD是对多个进程共享可见的</code>。SPDK的用户态驱动对单独I/O队列是无锁化处理的，因此从性能考虑，<code>只需要应用程序分配自己的I/O队列</code>就可以达到较高的性能。</p> 
<p><code>由于NVMe SSD本身只有一个管理队列</code>，因此当多个应用程序需要对设备发起相应的管理操作时，这个管理队列需要<code>通过互斥的机制</code>来保证操作的顺序性。相对来说，<code>在控制通道上引入互斥机制</code>对每个进程影响不会很大。</p> 
<h5><a id="3_145"></a>3）管理软件完成队列</h5> 
<p>NVMe SSD只有<code>一个管理队列</code>，对应一个<code>发送队列</code>和一个<code>完成队列</code>列。这个管理队列是共享给所有进程的，比如每个进程都需要通过这个管理队列来<code>创建逻辑上独享的I/O队列</code>。这里除了通过互斥的机制来串行多个进程的需求，还需要记录<code>请求操作和进程的对应关系</code>，这样才能避免出现一种场景：进程A发送的创建I/O队列的请求由进程B来处理回调函数。<br> <img src="https://images2.imgbox.com/0b/bf/8mJEz3iL_o.png" alt="在这里插入图片描述"><br> 由此SPDK引入了<code>针对每个进程的单独数据结构</code>，来记录每个进程独享的资源，比如这里需要的软件模拟的完成队列。多个软件模拟的完成队列都对应到<code>同一个管理完成队列（Admin Completion Queue）</code>。为了区分哪一个操作属于哪一个进程，这里<code>通过PID（Process Identifier）来标识每个进程</code>。当任何一个进程去异步轮询管理队列时，<code>会把所有硬件设备完成的操作取回来</code>，同时根据请求的PID标志，将这些请求<code>插入到对应进程</code>的软件完成队列。之后<code>该进程会处理对应的软件完成队列来回调用户</code>的操作</p> 
<h5><a id="4NVMe_SSD_152"></a>4）NVMe SSD共享管理流程</h5> 
<p><strong>在多进程情况下，主进程和副进程需要做些什么工作来实现多个应用对同一个设备的共享?</strong><br> <img src="https://images2.imgbox.com/ae/f3/bAM7fWja_o.png" alt="在这里插入图片描述"></p> 
<p>SPDK用户态驱动提供了对多进程访问的支持后，有几个典型的使用场景。</p> 
<ul><li>主进程完成对设备的管理和读/写操作，副进程来监控设备，读取设备使用信息。</li><li>主进程只负责资源的初始化和设备的初始化工作，多个副进程来操作设备，区分设备的管理通道和数据通道。</li><li>当主进程和副进程不进行区分时，都会对设备进行管理和读/写操作</li></ul> 
<p>推荐一个零声学院免费公开课程，个人觉得老师讲得不错，分享给大家：<a href="https://ke.qq.com/course/417774?flowToken=1041943" rel="nofollow">Linux，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒体，CDN，P2P，K8S，Docker，TCP/IP，协程，DPDK等技术内容，立即学习</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1121be283c1486ac52584ff2e3460361/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">卷积神经网络</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d88dbd2b8f57318d6b7d78b9a359e512/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DeepLabV3&#43;：Mobilenetv2的改进以及浅层特征和深层特征的融合</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>