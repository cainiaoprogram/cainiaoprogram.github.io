<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C#】运算符重载(operator) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C#】运算符重载(operator)" />
<meta property="og:description" content="文章目录 概述可重载运算符不可重载运算符示例来源 概述 用户定义的类型可重载预定义的 C# 运算符。 也就是说，当一个或两个操作数都是某类型时，此类型可提供操作的自定义实现。
使用 operator 关键字来声明运算符。 运算符声明必须符合以下规则：
同时包含 public 和 static 修饰符。一元运算符有一个输入参数。 二元运算符有两个输入参数。 在每种情况下，都至少有一个参数必须具有类型 T 或 T?，其中 T
是包含运算符声明的类型。 可重载运算符 运算符说明&#43;x, -x, !x, ~x, &#43;&#43;, --, true, falsetrue和 false 运算符必须一起重载。x &#43; y, x - y, x * y, x / y, x % y,
x &amp; y, x | y, x ^ y,
x &lt;&lt; y, x &gt;&gt; y, x &gt;&gt;&gt; yx == y, x !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/893798edd8db6ee45f8b257dfcf67213/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-16T15:31:54+08:00" />
<meta property="article:modified_time" content="2023-01-16T15:31:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C#】运算符重载(operator)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">概述</a></li><li><a href="#_12" rel="nofollow">可重载运算符</a></li><li><a href="#_36" rel="nofollow">不可重载运算符</a></li><li><a href="#_68" rel="nofollow">示例</a></li><li><a href="#_118" rel="nofollow">来源</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>概述</h3> 
<p><strong>用户定义的类型</strong>可重载预定义的 C# 运算符。 也就是说，当一个或两个操作数都是某类型时，此类型可提供操作的自定义实现。</p> 
<p>使用 operator 关键字来声明运算符。 运算符声明必须符合以下规则：</p> 
<ul><li>同时包含 public 和 static 修饰符。</li><li>一元运算符有一个输入参数。 二元运算符有两个输入参数。 在每种情况下，都至少有一个参数必须具有类型 T 或 T?，其中 T<br> 是包含运算符声明的类型。</li></ul> 
<h3><a id="_12"></a>可重载运算符</h3> 
<table class="table table-sm"><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td><a href="arithmetic-operators#unary-plus-and-minus-operators" rel="nofollow"><code>+x</code></a>, <a href="arithmetic-operators#unary-plus-and-minus-operators" rel="nofollow"><code>-x</code></a>, <a href="boolean-logical-operators#logical-negation-operator-" rel="nofollow"><code>!x</code></a>, <a href="bitwise-and-shift-operators#bitwise-complement-operator-" rel="nofollow"><code>~x</code></a>, <a href="arithmetic-operators#increment-operator-" rel="nofollow"><code>++</code></a>, <a href="arithmetic-operators#decrement-operator---" rel="nofollow"><code>--</code></a>, <a href="true-false-operators" rel="nofollow"><code>true</code></a>, <a href="true-false-operators" rel="nofollow"><code>false</code></a></td><td><code>true</code>和 <code>false</code> 运算符必须一起重载。</td></tr><tr><td><a href="arithmetic-operators#addition-operator-" rel="nofollow"><code>x + y</code></a>, <a href="arithmetic-operators#subtraction-operator--" rel="nofollow"><code>x - y</code></a>, <a href="arithmetic-operators#multiplication-operator-" rel="nofollow"><code>x * y</code></a>, <a href="arithmetic-operators#division-operator-" rel="nofollow"><code>x / y</code></a>, <a href="arithmetic-operators#remainder-operator-" rel="nofollow"><code>x % y</code></a>,<br> <a href="boolean-logical-operators#logical-and-operator-" rel="nofollow"><code>x &amp; y</code></a>, <a href="boolean-logical-operators#logical-or-operator-" rel="nofollow"><code>x | y</code></a>, <a href="boolean-logical-operators#logical-exclusive-or-operator-" rel="nofollow"><code>x ^ y</code></a>,<br> <a href="bitwise-and-shift-operators#left-shift-operator-" rel="nofollow"><code>x &lt;&lt; y</code></a>, <a href="bitwise-and-shift-operators#right-shift-operator-" rel="nofollow"><code>x &gt;&gt; y</code></a>, <a href="bitwise-and-shift-operators#unsigned-right-shift-operator-" rel="nofollow"><code>x &gt;&gt;&gt; y</code></a></td><td></td></tr><tr><td><a href="equality-operators#equality-operator-" rel="nofollow"><code>x == y</code></a>, <a href="equality-operators#inequality-operator-" rel="nofollow"><code>x != y</code></a>, <a href="comparison-operators#less-than-operator-" rel="nofollow"><code>x &lt; y</code></a>, <a href="comparison-operators#greater-than-operator-" rel="nofollow"><code>x &gt; y</code></a>, <a href="comparison-operators#less-than-or-equal-operator-" rel="nofollow"><code>x &lt;= y</code></a>, <a href="comparison-operators#greater-than-or-equal-operator-" rel="nofollow"><code>x &gt;= y</code></a></td><td>必须按如下方式成对重载： <code>==</code> 和 <code>!=</code>、 <code>&lt;</code> 、 <code>&gt;</code><code>&lt;=</code> 和 <code>&gt;=</code>。</td></tr></tbody></table> 
<h3><a id="_36"></a>不可重载运算符</h3> 
<table class="table table-sm"><thead><tr><th>运算符</th><th>备选方法</th></tr></thead><tbody><tr><td><a href="boolean-logical-operators#conditional-logical-and-operator-" rel="nofollow"><code>x &amp;&amp; y</code></a>, <a href="boolean-logical-operators#conditional-logical-or-operator-" rel="nofollow"><code>x || y</code></a></td><td>重载 <a href="true-false-operators" rel="nofollow"><code>true</code></a> 和 <a href="true-false-operators" rel="nofollow"><code>false</code></a> 运算符以及 <a href="boolean-logical-operators#logical-and-operator-" rel="nofollow"><code>&amp;</code></a> 或 <a href="boolean-logical-operators#logical-or-operator-" rel="nofollow"><code>|</code></a> 运算符。 有关详细信息，请参阅<a href="../language-specification/expressions#11133-user-defined-conditional-logical-operators" rel="nofollow">用户定义的条件逻辑运算符</a>。</td></tr><tr><td><a href="member-access-operators#indexer-operator-" rel="nofollow"><code>a[i]</code></a>, <a href="member-access-operators#null-conditional-operators--and-" rel="nofollow"><code>a?[i]</code></a></td><td>定义<a href="../../programming-guide/indexers/" rel="nofollow">索引器</a>。</td></tr><tr><td><a href="type-testing-and-cast#cast-expression" rel="nofollow"><code>(T)x</code></a></td><td>定义可由强制转换表达式执行的自定义类型转换。 有关详细信息，请参阅<a href="user-defined-conversion-operators" rel="nofollow">用户定义转换运算符</a>。</td></tr><tr><td><a href="arithmetic-operators#compound-assignment" rel="nofollow"><code>+=</code></a>, <a href="arithmetic-operators#compound-assignment" rel="nofollow"><code>-=</code></a>, <a href="arithmetic-operators#compound-assignment" rel="nofollow"><code>*=</code></a>, <a href="arithmetic-operators#compound-assignment" rel="nofollow"><code>/=</code></a>, <a href="arithmetic-operators#compound-assignment" rel="nofollow"><code>%=</code></a>, <a href="boolean-logical-operators#compound-assignment" rel="nofollow"><code>&amp;=</code></a>, <a href="boolean-logical-operators#compound-assignment" rel="nofollow"><code>|=</code></a>, <a href="boolean-logical-operators#compound-assignment" rel="nofollow"><code>^=</code></a>, <a href="bitwise-and-shift-operators#compound-assignment" rel="nofollow"><code>&lt;&lt;=</code></a>, <a href="bitwise-and-shift-operators#compound-assignment" rel="nofollow"><code>&gt;&gt;=</code></a>, <a href="bitwise-and-shift-operators#compound-assignment" rel="nofollow"><code>&gt;&gt;&gt;=</code></a></td><td>重载相应的二元运算符。 例如，重载二元 <code>+</code> 运算符时， <code>+=</code> 将隐式重载。</td></tr><tr><td><a href="member-access-operators#index-from-end-operator-" rel="nofollow"><code>^x</code></a>, <a href="assignment-operator" rel="nofollow"><code>x = y</code></a>, <a href="member-access-operators#member-access-expression-" rel="nofollow"><code>x.y</code></a>, <a href="member-access-operators#null-conditional-operators--and-" rel="nofollow"><code>x?.y</code></a>, <a href="conditional-operator" rel="nofollow"><code>c ? t : f</code></a>, <a href="null-coalescing-operator" rel="nofollow"><code>x ?? y</code></a>, <a href="null-coalescing-operator" rel="nofollow"><code>??= y</code></a>,<br><a href="member-access-operators#range-operator-" rel="nofollow"><code>x..y</code></a>, <a href="pointer-related-operators#pointer-member-access-operator--" rel="nofollow"><code>x-&gt;y</code></a>, <a href="lambda-operator" rel="nofollow"><code>=&gt;</code></a>, <a href="member-access-operators#invocation-expression-" rel="nofollow"><code>f(x)</code></a>, <a href="type-testing-and-cast#as-operator" rel="nofollow"><code>as</code></a>, <a href="await" rel="nofollow"><code>await</code></a>, <a href="../statements/checked-and-unchecked" rel="nofollow"><code>checked</code></a>, <a href="../statements/checked-and-unchecked" rel="nofollow"><code>unchecked</code></a>, <a href="default" rel="nofollow"><code>default</code></a>, <a href="delegate-operator" rel="nofollow"><code>delegate</code></a>, <a href="type-testing-and-cast#is-operator" rel="nofollow"><code>is</code></a>, <a href="nameof" rel="nofollow"><code>nameof</code></a>, <a href="new-operator" rel="nofollow"><code>new</code></a>,<br><a href="sizeof" rel="nofollow"><code>sizeof</code></a>, <a href="stackalloc" rel="nofollow"><code>stackalloc</code></a>, <a href="switch-expression" rel="nofollow"><code>switch</code></a>, <a href="type-testing-and-cast#typeof-operator" rel="nofollow"><code>typeof</code></a>, <a href="with-expression" rel="nofollow"><code>with</code></a></td><td>无。</td></tr></tbody></table> 
<h3><a id="_68"></a>示例</h3> 
<p>下面是分数的一个极其简化的类。该类重载了 + 和 * 运算符，以执行分数加法和乘法；同时提供了将 Fraction 类型转换为 double 类型的转换运算符。</p> 
<pre><code class="prism language-csharp"><span class="token comment">// cs_keyword_operator.cs</span>
<span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Fraction</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name"><span class="token keyword">int</span></span> num<span class="token punctuation">,</span> den<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">Fraction</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> num<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> den<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>den <span class="token operator">=</span> den<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// overload operator +</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Fraction <span class="token keyword">operator</span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token class-name">Fraction</span> a<span class="token punctuation">,</span> <span class="token class-name">Fraction</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Fraction</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>num <span class="token operator">*</span> b<span class="token punctuation">.</span>den <span class="token operator">+</span> b<span class="token punctuation">.</span>num <span class="token operator">*</span> a<span class="token punctuation">.</span>den<span class="token punctuation">,</span>
           a<span class="token punctuation">.</span>den <span class="token operator">*</span> b<span class="token punctuation">.</span>den<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// overload operator *</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Fraction <span class="token keyword">operator</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">Fraction</span> a<span class="token punctuation">,</span> <span class="token class-name">Fraction</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Fraction</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>num <span class="token operator">*</span> b<span class="token punctuation">.</span>num<span class="token punctuation">,</span> a<span class="token punctuation">.</span>den <span class="token operator">*</span> b<span class="token punctuation">.</span>den<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// user-defined conversion from Fraction to double</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">implicit</span> <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token class-name">Fraction</span> f<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>num <span class="token operator">/</span> f<span class="token punctuation">.</span>den<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Fraction</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Fraction</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Fraction</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Fraction</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Fraction</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Fraction</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出：0.880952380952381</p> 
<h3><a id="_118"></a>来源</h3> 
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/operator-overloading" rel="nofollow">运算符重载 - 预定义的一元运算符、算术运算符、相等运算符和比较运算符</a><br> <a href="https://learn.microsoft.com/zh-cn/previous-versions/s53ehcz3%28v=vs.80%29" rel="nofollow">operator（C# 参考）</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/661bdaf47ee3c00a356f80d7ee8bb2e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器学习笔记之深度玻尔兹曼机(一)玻尔兹曼机系列整体介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d13a11647a4f920acf59c4b85a7d7aab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">srand和rand详细讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>