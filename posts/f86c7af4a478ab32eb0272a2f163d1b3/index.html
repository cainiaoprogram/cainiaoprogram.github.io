<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从零开始学Java之方法重写与方法重载到底有哪些区别？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从零开始学Java之方法重写与方法重载到底有哪些区别？" />
<meta property="og:description" content="一. 方法重写 在面向对象中，实现多态的必备条件是继承、重写和向上转型，现在我们已经学习了什么是继承。接下来我们再来学习什么是方法重写，这是我们能够实现多态的前提。
1. 概念 如果我们在子类中，创建了一个与父类中名称、返回值类型、参数列表都完全相同的方法，只是方法体的功能实现不同，这种方式被称为方法重写(override) ，或者叫方法覆盖。当父类中的方法无法满足子类的需求，或者子类需要有特殊功能时，就可以进行方法重写。
2. 基本要求 我们在进行方法重写时，需要遵循以下几点要求：
父类的成员方法只能被它的子类重写，即不能继承一个方法，就不能重写这个方法；被final修饰的方法不能被重写；被static修饰的方法不能被重写，但可以再次声明；构造方法不能被重写；子类和父类在同一个包中时，子类可以重写父类中除了被private和final修饰的其他所有方法；子类和父类不在同一个包中时，子类只能重写父类被public和protected修饰的非final方法；重写的方法建议使用@Override注解来标识。 3. 注意事项 另外我们在进行方法重写时，还要注意以下几点：
方法签名要相同：重写的方法和被重写的方法，在方法名、参数上都要相同；返回值类型一致：JDK 1.5之前重写方法的返回值类型必须一样，但之后的Java版本放宽了限制，返回值类型必须小于或等于父类方法的返回值类型；访问修饰符要更宽泛：子类重写父类的方法时，子类方法中的访问修饰符不能比父类中的更严格(public&gt;protected&gt;default&gt;private)。比如父类方法的修饰符是protected，则子类的同名方法其修饰符可以是protected或public，但不能是默认的或private；声明的异常类型要一致：重写的方法一定不能抛出新的检査异常，或者比被重写方法声明更宽泛的检査型异常。例如，父类的方法声明了IOException，重写该方法时就不能抛出Exception，只能拋出IOException或其子类异常。但可以抛出非检査异常。 4. 代码实现 接下来壹哥就通过一个案例来给大家讲解方法的重写该怎么实现。
4.1 定义父类 我们先定义一个Father父类，要注意父类中有哪些方法不能被重写。
public class Father { // 父类中的成员变量--变量隐藏 String name=&#34;老子&#34;; //构造方法不能被重写，因为构造方法不能被继承！ public Father() { System.out.println(&#34;爹的构造方法&#34;); } // 吃 public void eat() { System.out.println(&#34;爹吃馒头&#34;); } // 喝 public void drink() { System.out.println(&#34;爹喝水&#34;); } // 玩 //私有方法不能被重写 //	private void play() { // System.out.println(&#34;爹玩火&#34;); //	} //静态方法不能被重写，但可以在子类中声明一个同样的静态方法。 //	public static void play() { // System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f86c7af4a478ab32eb0272a2f163d1b3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-31T10:07:59+08:00" />
<meta property="article:modified_time" content="2023-03-31T10:07:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从零开始学Java之方法重写与方法重载到底有哪些区别？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一. 方法重写</h2> 
<p>在面向对象中，实现多态的必备条件是<strong>继承、重写和向上转型</strong>，现在我们已经学习了什么是继承。接下来我们再来学习什么是方法重写，这是我们能够实现多态的前提。</p> 
<h3>1. 概念</h3> 
<p>如果我们<strong>在子类中，创建了一个与父类中名称、返回值类型、参数列表都完全相同的方法，只是方法体的功能实现不同</strong>，这种方式被称为<strong>方法重写(override)</strong> ，或者叫<strong>方法覆盖</strong>。当父类中的方法无法满足子类的需求，或者子类需要有特殊功能时，就可以进行方法重写。</p> 
<h3>2. 基本要求</h3> 
<p>我们在进行方法重写时，需要遵循以下几点要求：</p> 
<blockquote> 
 <ul><li><strong>父类的成员方法只能被它的子类重写，即不能继承一个方法，就不能重写这个方法；</strong></li><li><strong>被final修饰的方法不能被重写；</strong></li><li><strong>被static修饰的方法不能被重写，但可以再次声明；</strong></li><li><strong>构造方法不能被重写；</strong></li><li><strong>子类和父类在同一个包中时，子类可以重写父类中除了被private和final修饰的其他所有方法；</strong></li><li><strong>子类和父类不在同一个包中时，子类只能重写父类被public和protected修饰的非final方法；</strong></li><li><strong>重写的方法建议使用@Override注解来标识。</strong></li></ul> 
</blockquote> 
<h3>3. 注意事项</h3> 
<p>另外我们在进行方法重写时，还要注意以下几点：</p> 
<blockquote> 
 <ul><li><strong>方法签名要相同</strong>：重写的方法和被重写的方法，在<strong>方法名、参数</strong>上都要相同；</li><li><strong>返回值类型一致</strong>：JDK 1.5之前重写方法的返回值类型必须一样，但之后的Java版本放宽了限制，<strong>返回值类型必须小于或等于父类方法的返回值类型</strong>；</li><li><strong>访问修饰符要更宽泛</strong>：子类重写父类的方法时，子类方法中的访问修饰符不能比父类中的更严格(public&gt;protected&gt;default&gt;private)。比如父类方法的修饰符是protected，则子类的同名方法其修饰符可以是protected或public，但不能是默认的或private；</li><li><strong>声明的异常类型要一致</strong>：重写的方法一定不能抛出新的检査异常，或者比被重写方法声明更宽泛的检査型异常。例如，父类的方法声明了IOException，重写该方法时就不能抛出Exception，只能拋出IOException或其子类异常。<strong>但可以抛出非检査异常</strong>。</li></ul> 
</blockquote> 
<h3>4. 代码实现</h3> 
<p>接下来<strong>壹哥</strong>就通过一个案例来给大家讲解方法的重写该怎么实现。</p> 
<h4>4.1 定义父类</h4> 
<p>我们先定义一个Father父类，要注意父类中有哪些方法不能被重写。</p> 
<pre><code>public class Father {
    // 父类中的成员变量--变量隐藏
    String name="老子";
	
    //构造方法不能被重写，因为构造方法不能被继承！
    public Father() {
	System.out.println("爹的构造方法");
    }

    // 吃
    public void eat() {
	System.out.println("爹吃馒头");
    }

    // 喝
    public void drink() {
	System.out.println("爹喝水");
    }
	
    // 玩
    //私有方法不能被重写
    //	private void play() {
    //       System.out.println("爹玩火");
    //	}
	
    //静态方法不能被重写，但可以在子类中声明一个同样的静态方法。
    //	public static void play() {
    //      System.out.println("爹玩火");
    //	}
	
    //final方法不能被重写
    public final void play() {
	System.out.println("爹玩火");
    }
}
复制代码</code></pre> 
<h4>4.2 定义子类</h4> 
<p>定义一个Son子类继承父类，有了继承才会有重写！</p> 
<pre><code>public class Son extends Father{
    //构造方法不能被重写，因为构造方法不能被继承！
    //@Override
    //public Father() {}

    // 吃
    /**
    * 方法重写时可以带有@Ovriride关键词，当重写的方法签名不一致时，可以有编译错误的提示。
    * 否则方法签名不一致时不会有错误提示，会被当做一个新的方法来处理。
    */
    @Override
    public void eat() {
	//如果子类的功能，是在父类的基础之上进行的额外扩展增加，
	//我们可以使用super关键字调用父类的同名方法,然后再进行自己的额外扩展！
	//如果子类的实现和父类完全不一样，可以不调用super！
	super.eat();
	//方法重写时，子类可以对父类的同名方法进行扩展实现，方法体的内容可以和父类中的实现不一样
	System.out.println("儿子吃肉");
    }

    // 喝
    @Override
    public void drink() {
	//如果子类的实现和父类完全不一样，可以不调用super！
	System.out.println("儿子喝酒");
    }
    /**
    * 父类私有的、static、final等方法无法被重写
    */
    //@Override
    //public void play() {}
	
    //static静态的父类方法不能被重写，但可以在子类中再重新编写一个静态的同名方法。
    //public static void play() {}

    //变量隐藏--调用父类和子类中的同名成员变量
    public void sayHello() {
	// 如果子类的实现和父类完全不一样，可以不调用super！
	System.out.println("父亲的名字=" + super.name);
	System.out.println("儿子的名字=" + name);
    }

    public static void main(String[] args) {
	Son son = new Son();
	son.sayHello();
    }
}
复制代码</code></pre> 
<p>我们在进行方法重写时，要注意以下几点：</p> 
<blockquote> 
 <ul><li><strong>方法重写时可以带有@Ovriride关键词。当重写的方法签名不一致时，会有编译错误的提示，否则方法签名不一致时不会有错误提示，会被当做一个新的方法来处理。</strong></li><li><strong>当子类对象调用重写的方法时，默认执行的是子类的方法，而不是父类中被重写的方法。如果我们想要调用父类中被重写的方法，则可以使用“super.方法名”的形式。</strong></li><li><strong>如果子类的功能是在父类的基础之上进行的额外扩展，我们可以使用super关键字调用父类的同名方法，然后再进行自己的额外扩展！</strong></li><li><strong>如果子类的实现和父类完全不一样，可以不调用super！</strong></li><li><strong>方法重写时，子类可以对父类的同名方法进行扩展实现，方法体的内容可以和父类中的实现不一样。</strong></li></ul> 
</blockquote> 
<h4>4.3 @Override注解</h4> 
<p>在上面的代码中，我们用到了一个新的关键字@Override。在Java中，@Override是一个注解，关于注解的更多内容，<strong>壹哥</strong>会在后面的文章中进行专门讲解，现在我们先知道注解这个概念就行。</p> 
<p>@Override是一个用来修饰被重新的方法的注解，只能用在被重新的方法上，不能用在其它的地方。该注解可以强制子类必须重写父类的方法或者接口中的方法，主要是告诉编译器检查重写的方法是否和父类中定义的一致。如果重写的方法签名不一致，会提示编译错误。如果方法签名不一致，则不会有错误提示，会被当做一个新的方法来处理。通过这样的机制，就可以避免程序员出现一些低级的错误。</p> 
<h3>5. 变量隐藏</h3> 
<h4>5.1 概念</h4> 
<p>如果子类中定义了一个成员变量，而该变量的名称与父类中的成员变量相同，数据类型不一定完全一致，我们就把这称为<strong>变量隐藏</strong>。也就是说，子类的成员变量，对从父类继承过来的成员变量进行了重新定义，出现了子类变量对父类变量的隐藏。所以子类执行自己定义的方法时，操作的成员变量默认是自己定义的变量，而不是父类中的同名变量。如果我们非要操作隐藏的成员变量，可以使用super关键字进行调用。</p> 
<p>接下来我们通过一个案例来给大家演示变量隐藏的使用。</p> 
<h4>5.2 案例实现</h4> 
<p>父类中定义一个成员变量name，如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e9/05/yzP3AeHt_o.png"></p> 
<p>子类中也定义一个相同的成员变量name，如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/16/b3/VMPUCQbA_o.png"></p> 
<p>如果我们在Son类中直接使用name，默认使用的是Son自己的变量；如果我们想使用Father类中的name变量，则可以通过“<strong>super.属性</strong>”的形式进行。执行结果如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/07/1a/goDuvW1p_o.png"></p> 
<h3>6. 方法隐藏</h3> 
<p>在子类继承父类时，既然存在变量隐藏的现象，同理也存在方法隐藏的现象。</p> 
<h4>6.1 概念</h4> 
<p>我们知道，方法的重写是子类覆盖父类的对象方法，而<strong>方法隐藏则是子类覆盖父类的</strong> <strong>静态方法(类方法)</strong> 。在java中的静态方法能被<a href="https://link.juejin.cn?target=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3D%25E5%25AD%2590%25E7%25B1%25BB%26spm%3D1001.2101.3001.7020" rel="nofollow" title="子类">子类</a>继承吗？答案是肯定的，但若子类中有与父类中同名同参的方法，则父类的方法将被隐藏。</p> 
<h4>6.2 案例实现</h4> 
<p>我们先定义一个Father父类，里面有个静态方法eat。</p> 
<pre><code>/**
 * @author 一一哥Sun 
 * 
 * 定义父类
 */
public class Father {
    // 吃---静态方法
    public static void eat() {
	System.out.println("爹吃馒头");
    }
}
复制代码</code></pre> 
<p>然后再定义一个Son子类，里面也有一个静态方法eat。我们知道，<strong>静态方法是可以被继承的，所以如果Son子类中没有定义自己的eat()方法，默认可以使用Father父类中的eat()方法。但如果我们在子类中也定义了一个eat()方法，子类的同名静态方法就会隐藏父类中的eat()方法，这就是方法隐藏。</strong></p> 
<pre><code>/**
 * @author 一一哥Sun 
 * 
 * 子类继承父类
 */
public class Son extends Father {
    // 吃---静态方法
    //如果子类中没有定义该方法，则子类可以继承使用父类的eat()方法
    public static void eat() {
	//子类覆盖父类中的同名静态方法(类)
	System.out.println("儿子吃肉");
    }
	
    public static void main(String[] args) {
	//调用子类自己的静态方法
	eat();
		
	//调用父类的静态方法
	Father.eat();
    }
}
复制代码</code></pre> 
<p>执行结果如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a6/45/5zDAo2gN_o.png"></p> 
<h4>6.3 小结</h4> 
<p>通过本案例，我们可以得出以下结论：</p> 
<blockquote> 
 <ol><li><strong>子类可以继承父类中的静态方法；</strong></li><li><strong>子类无法重写父类中的静态方法，但可以重载；</strong></li><li><strong>若子类中定义了与父类中同样的静态方法，则父类的同名方法会被子类隐藏</strong>。</li></ol> 
</blockquote> 
<h2>二. 重写与重载的区别</h2> 
<p>在Java中既有方法重写(Override)，也有方法重载(Overload)，对于初学者来说很容易搞混。所以有不少面试官，在招聘初级程序员时，就很喜欢问我们方法重写与方法重载的区别。</p> 
<p>其实方法重写Override和方法重载Overload的最大不同，在于方法签名的不同。如果同一个类中的多个方法签名不同，就是方法重载Overload，重载出的方法是一个新方法。如果父子类之间的多个方法签名相同，且返回值也相同，就是方法重写Override。</p> 
<p>当然，如果你想把关于重写和重载的区别说得更详细，可以参考以下章节。</p> 
<h3>1. 重载的特点</h3> 
<blockquote> 
 <ul><li><strong>方法重载要求方法同名不同参(参数类型、个数、顺序)；</strong></li><li><strong>重载的方法与返回值、访问修饰符无关；</strong></li><li><strong>重载的方法发生在同一个类中，是在一个类中创建多个同名的方法。</strong></li></ul> 
</blockquote> 
<h3>2. 重写的特点</h3> 
<blockquote> 
 <ul><li><strong>重写的方法发生在父子类中，需要有继承关系；</strong></li><li><strong>父类的成员方法只能被它的子类重写，即不能继承一个方法，就不能重写这个方法；</strong></li><li><strong>被final修饰的方法不能被重写；</strong></li><li><strong>被static修饰的方法不能被重写，但可以再次声明；</strong></li><li><strong>构造方法不能被重写；</strong></li><li><strong>子类和父类在同一个包中时，子类可以重写父类中除了被private和final修饰的其他所有方法；</strong></li><li><strong>子类和父类不在同一个包中时，子类只能重写父类被public和protected修饰的非final方法；</strong></li><li><strong>方法重写时可以使用@Override注解；</strong></li><li><strong>方法签名要相同</strong>；</li><li><strong>返回值类型一致</strong>；</li><li><strong>访问修饰符要更宽泛</strong>；</li><li><strong>声明的异常类型要一致</strong>。</li></ul> 
</blockquote> 
<p>------------------------------<strong>正片已结束，来根事后烟</strong>----------------------------</p> 
<h2>三. 结语</h2> 
<p>现在你知道方法重写是怎么回事了吗？另外方法重载和方法重写的区别，是我们面试初级程序员时很常见的题目，大家一定要牢牢掌握哦。现在有了方法重写的基础，接下来我们就可以学习多态的内容了，敬请关注下一篇文章哦。</p> 
<p>另外如果你独自学习觉得有很多困难，可以加入<strong>壹哥</strong>的学习互助群，大家一起交流学习。</p> 
<h2>四. 配套视频</h2> 
<p>如果你不习惯阅读技术文章，或是对文中的技术概念不能很好地理解，可以来看看<strong>壹哥</strong>帮你筛选出的视频教程。<strong>与本文配套的Java学习视频，链接如下：</strong></p> 
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fplayer.bilibili.com%2Fplayer.html%3Fbvid%3DBV1Ja411x7XB%26p%3D90%26page%3D90" rel="nofollow" title="player.bilibili.com/player.html…">player.bilibili.com/player.html…</a></p> 
<p></p> 
<p>作者：一一哥Sun<br> 链接：https://juejin.cn/post/7215736946252283964<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/16df5b98d4459462386a106f37f22ca9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【ESP8266 快速入门】硬件：ESP12S/ESP12F最小系统设计及typeC自动下载电路设计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f88bec7f692a56c255b8b97ae9917499/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mybatis批量更新优化方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>