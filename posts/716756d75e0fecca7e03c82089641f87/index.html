<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode第 787 题：K 站中转内最便宜的航班(C&#43;&#43;) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode第 787 题：K 站中转内最便宜的航班(C&#43;&#43;)" />
<meta property="og:description" content="787. K 站中转内最便宜的航班 - 力扣（LeetCode）
典型的dijkstra算法，几乎是固定优先级队列加上bfs（bfs求出的都是最大/最小）的思路了，这题多加了一个中转站的限制
不过我还是太年轻，代码并没有通过全部案例，第43个卡住了，主要问题是使用优先级队列的话，跳出循环的条件很难处理，k值和终点哪个作为判断依据暂时不明确。
class Solution { public: struct cmp{//按照距离排序 bool operator()(const pair&lt;pair&lt;int, int&gt;, int&gt; &amp;a, const pair&lt;pair&lt;int, int&gt;, int&gt; &amp;b){ return a.first.second &lt; b.first.second; } }; int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int K) { vector&lt;int&gt; distance(n, INT_MAX);//记录该节点到起点的距离 unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; adj; //pair里面的两个元素分别表示顶点编号和距离 for(const auto &amp;v : flights) adj[v[0]].push_back({v[1], v[2]});//构建邻接表 //pair&lt;pair&lt;编号，到起点的距离&gt;, 当前层次编号&gt;，当前层次编号是用来记录中转站的 priority_queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;, vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt;, cmp&gt; q; q.push({{src, 0}, 0});//起点自己到自己的距离为0 while(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/716756d75e0fecca7e03c82089641f87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-26T22:03:22+08:00" />
<meta property="article:modified_time" content="2020-08-26T22:03:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode第 787 题：K 站中转内最便宜的航班(C&#43;&#43;)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/" rel="nofollow">787. K 站中转内最便宜的航班 - 力扣（LeetCode）</a><br> <img src="https://images2.imgbox.com/4b/24/9gWzEH8I_o.png" alt="在这里插入图片描述"></p> 
<p>典型的dijkstra算法，几乎是固定优先级队列加上bfs（bfs求出的都是最大/最小）的思路了，这题多加了一个中转站的限制</p> 
<p>不过我还是太年轻，代码并没有通过全部案例，第43个卡住了，主要问题是使用优先级队列的话，跳出循环的条件很难处理，k值和终点哪个作为判断依据暂时不明确。</p> 
<pre><code>class Solution {
public:
    struct cmp{//按照距离排序
        bool operator()(const pair&lt;pair&lt;int, int&gt;, int&gt; &amp;a, const pair&lt;pair&lt;int, int&gt;, int&gt; &amp;b){
            return a.first.second &lt; b.first.second;
        }
    };
    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int K) {
        vector&lt;int&gt; distance(n, INT_MAX);//记录该节点到起点的距离
        unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; adj;
        //pair里面的两个元素分别表示顶点编号和距离
        for(const auto &amp;v : flights)    adj[v[0]].push_back({v[1], v[2]});//构建邻接表

        //pair&lt;pair&lt;编号，到起点的距离&gt;, 当前层次编号&gt;，当前层次编号是用来记录中转站的
        priority_queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;, vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt;, cmp&gt; q;
        q.push({<!-- -->{src, 0}, 0});//起点自己到自己的距离为0
        while(!q.empty()){
            int cur = q.top().first.first, dis = q.top().first.second;
            int level = q.top().second;
            q.pop();
            
            if(level &gt; K){
                break;
            }
            
            //考虑与当前节点cur相连（指向）的节点，并更新起点到他们的距离
            for(const auto &amp;v : adj[cur]){
                if(distance[v.first] &gt; dis + v.second){//更新距离
                    distance[v.first] = dis + v.second;
                    q.push({<!-- -->{v.first, distance[v.first]}, 1+level});
                }
            }
        }
        return distance[dst] == INT_MAX ? -1 : distance[dst];
    }
};
</code></pre> 
<h4><a id="__bfs_46"></a>队列 + bfs</h4> 
<p>而且上述代码很臃肿，主要是因为使用pair嵌套来传递当前的层次（类似二叉树的层次遍历的思路）。但是层次遍历的时候其实是没有必要专门传递层数的，可以每次在while里面再使用一个for循环处理队列中的全部元素，这样一个while循环就是一层，具体还是看代码：</p> 
<pre><code>class Solution {
public:
    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int K) {
    	//题目描述说不存在环，所以不用记录顶点是否访问过
        int res = INT_MAX;
        unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; adj;
        //pair里面的两个元素分别表示顶点编号和距离
        for(const auto &amp;v : flights)    adj[v[0]].push_back({v[1], v[2]});//构建邻接表
        //pair&lt;编号，到起点的距离&gt;
        queue&lt;pair&lt;int, int&gt;&gt; q;//使用普通队列而不是优先级队列

        q.push({src, 0});//起点自己到自己的距离为0
        int step = 0;
        while(!q.empty() &amp;&amp; step &lt;= K){
            int n = q.size();//事先记录size，一次while循环遍历一个层次
            for(int i = 0; i &lt; n; ++i){
                int cur = q.front().first, dis = q.front().second;
                q.pop();
                //考虑与当前节点cur相连（指向）的节点，并更新起点到他们的距离
                for(const auto &amp;v : adj[cur]){
                    if(dis + v.second &gt;= res)   continue;
                    if(v.first == dst)  res = dis+v.second;
                    else q.push({v.first, dis+v.second});
                }
            }
            ++step;
        }
        return res == INT_MAX ? -1 : res;
    }
};
</code></pre> 
<p>所以我还是常常把题目想得太复杂了，拿到题目就像往dijkstra算法上面去套。。。</p> 
<h4><a id="BellmanFord_84"></a>Bellman-Ford</h4> 
<p>这个算法目前还不懂，但是看起来真的好厉害。</p> 
<p>可以去看这儿的图;<a href="https://blog.csdn.net/wtyvhreal/article/details/43450727?utm_source=blogkpcl13&amp;utm_medium=distribute.pc_relevant.none-task-blog-title-4&amp;spm=1001.2101.3001.4242">最短路径（三）—Bellman-Ford算法（解决负权边）_小地盘的诺克萨斯-CSDN博客</a></p> 
<pre><code>class Solution {
public:
    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int K) {
        vector&lt;int&gt; dp(n, INT_MAX/2);//src到各个位置的最短距离
        vector&lt;int&gt; backup(n);
        dp[src] = 0;

        for(int k = 0; k &lt;= K; ++k){//k次松弛
            backup.assign(dp.begin(), dp.end());
            for(const auto &amp;f : flights){//枚举所有的边
                if(dp[f[1]] &gt; backup[f[0]] + f[2])  dp[f[1]] = backup[f[0]] + f[2];
            }
        }

        return dp[dst] == INT_MAX/2 ? -1 : dp[dst];
    }
};
</code></pre> 
<p>可以稍作优化：</p> 
<pre><code>class Solution {
public:
    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int K) {
        vector&lt;int&gt; dis(n, INT_MAX/2);//src到各个位置的最短距离
        vector&lt;int&gt; backup(n);
        dis[src] = 0;

        for(int k = 0; k &lt;= K; ++k){//k次松弛
            backup.assign(dis.begin(), dis.end());
            for(const auto &amp;f : flights){//枚举所有的边
                if(dis[f[1]] &gt; backup[f[0]] + f[2])  dis[f[1]] = backup[f[0]] + f[2];
            }
            if(backup == dis) break;//这一轮的松弛中每个顶点到起点的距离都没有变化
        }

        return dis[dst] == INT_MAX/2 ? -1 : dis[dst];
    }
};
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/90b74cc0b218d3d4a911ba35d4a24b0c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ios 后台任务_iOS后台任务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dd14719c439848327af1d5b2781665ca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cmake-debug和release模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>