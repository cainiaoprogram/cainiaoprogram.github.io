<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux中的BIO和NIO - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux中的BIO和NIO" />
<meta property="og:description" content="Linux中的BIO和NIO 1. 概念 BIO（阻塞IO）
执行某个操作时，若不能获得资源，则挂起进程知道满足条件获取资源后再执行。挂起进程的唤醒一般发生在中断里，因为硬件资源的获取一般伴随着一个中断
//以阻塞的方式从串口读取一个字符 char buf[20]; fd = open(&#34;/dev/ttyS1&#34;, O_RDWR); //阻塞读取字符 res = read(fd, &amp;buf, 1); printf(&#34;%c\n&#34;, buf); NIO（非阻塞IO）
执行某个操作时，若不能获得资源，不会挂起进行，要么放弃，要么不停的查询，直到可以进行操作为止
//以非阻塞的方式从串口读取一个字符 char buf[20]; fd = open(&#34;/dev/ttyS1&#34;, O_RDWR | O_NONBLOCK); //读取字符，读取操作立即返回，所以需要循环读取 while(read(fd, &amp;buf, 1) == -1) continue; printf(&#34;%c\n&#34;, buf); 改变文件的读写方式
除了可以在文件打开时定义读写方式外还可以通过ioctl()和fcntl()改变读写方式。
void ioctl(...); void fcntl(...); 2. 等待队列 等待队列是BIO的底层实现方式
等待队列与Linux内核的进程调度紧密结合信号量是依赖于等待队列实现的 //定义等待队列 wait_queue_head_t queue; //初始化头 void init_waitqueue_head(&amp;queue); //定义&#43;初始化头 DECLARE_WAIT_QUEUE_HEAD(name); //定义元素 DECLARE_WAITQUEUE(name, tsk); //添加到队列 void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait); //从队列移除 void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait); //等待事件 void wait_event(queue, condition); void wait_event_timeout(queue, condition); void wait_event_interruptible(queue, condition); void wait_event_interruptible_timeout(queue, condition); //唤醒队列 void wake_up(queue); void wake_up_interruptible(queue); 在等待队列中休眠（与wake_up成对使用）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/88753b93040e10079776703700b503a5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-17T20:00:12+08:00" />
<meta property="article:modified_time" content="2021-09-17T20:00:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux中的BIO和NIO</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="LinuxBIONIO_0"></a>Linux中的BIO和NIO</h3> 
<h4><a id="1__1"></a>1. 概念</h4> 
<ol><li> <p>BIO（阻塞IO）</p> <p>执行某个操作时，若不能获得资源，则挂起进程知道满足条件获取资源后再执行。挂起进程的唤醒一般发生在中断里，因为硬件资源的获取一般伴随着一个中断</p> <pre><code class="prism language-c"><span class="token comment">//以阻塞的方式从串口读取一个字符</span>
<span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/ttyS1"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//阻塞读取字符</span>
res <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>NIO（非阻塞IO）</p> <p>执行某个操作时，若不能获得资源，不会挂起进行，要么放弃，要么不停的查询，直到可以进行操作为止</p> <pre><code class="prism language-c"><span class="token comment">//以非阻塞的方式从串口读取一个字符</span>
<span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/ttyS1"</span><span class="token punctuation">,</span> O_RDWR <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//读取字符，读取操作立即返回，所以需要循环读取</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>改变文件的读写方式</p> <p>除了可以在文件打开时定义读写方式外还可以通过ioctl()和fcntl()改变读写方式。</p> <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">ioctl</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">fcntl</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li></ol> 
<h4><a id="2__39"></a>2. 等待队列</h4> 
<p>等待队列是BIO的底层实现方式</p> 
<ul><li>等待队列与Linux内核的进程调度紧密结合</li><li>信号量是依赖于等待队列实现的</li></ul> 
<pre><code class="prism language-c"><span class="token comment">//定义等待队列</span>
<span class="token class-name">wait_queue_head_t</span> queue<span class="token punctuation">;</span>
<span class="token comment">//初始化头</span>
<span class="token keyword">void</span> <span class="token function">init_waitqueue_head</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//定义+初始化头</span>
<span class="token function">DECLARE_WAIT_QUEUE_HEAD</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//定义元素</span>
<span class="token function">DECLARE_WAITQUEUE</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//添加到队列</span>
<span class="token keyword">void</span> <span class="token function">add_wait_queue</span><span class="token punctuation">(</span><span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token class-name">wait_queue_t</span> <span class="token operator">*</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//从队列移除</span>
<span class="token keyword">void</span> <span class="token function">remove_wait_queue</span><span class="token punctuation">(</span><span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token class-name">wait_queue_t</span> <span class="token operator">*</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//等待事件</span>
<span class="token keyword">void</span> <span class="token function">wait_event</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">wait_event_timeout</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">wait_event_interruptible</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">wait_event_interruptible_timeout</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//唤醒队列</span>
<span class="token keyword">void</span> <span class="token function">wake_up</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">wake_up_interruptible</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在等待队列中休眠（与wake_up成对使用）</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">sleep_on</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">interruptible_sleep_on</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="3__76"></a>3. 轮询操作</h4> 
<ol><li> <p>select()、poll()系统调用都是BIO中查询文件的方式，一次可以查询多个文件描述符，其中任一个变得可写或可读时返回。是一种多路复用的思想</p> </li><li> <p>select()、poll()在文件量增大时，性能降低</p> <pre><code class="prism language-c"><span class="token comment">//任一文件变得可读、可写、异常时返回</span>
<span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span>
    <span class="token comment">//监听的文件的最高fd+1</span>
    <span class="token keyword">int</span> numfds<span class="token punctuation">,</span> 
    <span class="token comment">//监听的读文件</span>
    fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span>
    <span class="token comment">//监听的写文件</span>
    fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>
    <span class="token comment">//监听的异常文件</span>
    fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span>
    <span class="token comment">//监听超时</span>
    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//下面的宏用于操作fd_set文件描述符集合</span>
<span class="token comment">//清空</span>
<span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//添加</span>
<span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//删除</span>
<span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//判断</span>
<span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//poll操作与select操作类似</span>
<span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token class-name">nfds_t</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>epoll()是poll()的扩展，是一种事件驱动的操作</p> </li><li> <p>epoll不会由于fd的数量变大而降低性能</p> <pre><code class="prism language-c"><span class="token comment">//创建epoll，设置监听的fd数量，epoll本身占用一个fd</span>
<span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//关闭epoll fd</span>
<span class="token keyword">void</span> <span class="token function">epoll_close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//等待事件产生，events是输出（从内核得到的事件集合），maxevents是本次最多接收的事件数</span>
<span class="token comment">//timeout是超时（毫秒）,-1表示永久</span>
<span class="token comment">//返回本次接收到的事件数</span>
<span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//设置epoll监听的fd</span>
<span class="token comment">//参数op: EPOLL_CTL_ADD 注册新的fd到epfd中</span>
<span class="token comment">//参数op: EPOLL_CTL_MOD 修改已注册的fd的监听事件</span>
<span class="token comment">//参数op: EPOLL_CTL_ADD 从epfd中删除一个fd</span>
<span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//struct epoll_event是监听的事件类型</span>
<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//EPOLLIN   可读</span>
    <span class="token comment">//EPOLLOUT  可写</span>
    <span class="token comment">//EPOLLPRI  有紧急数据可读（socket紧急数据）</span>
    <span class="token comment">//EPOLLERR  fd发生错误</span>
    <span class="token comment">//EPOLLHUP  fd被挂断</span>
    <span class="token comment">//EPOLLONESHOT 一次性监听，一次监听事件完成后，需要再次把fd加入epfd中</span>
    <span class="token comment">//EPOLLET   epoll设为边缘触发模式（Edge Triggered）</span>
    <span class="token comment">//默认是水平触发模式（Level Triggered）</span>
    <span class="token comment">//ET是高速模式，当fd从非就绪变为就绪时，不会发送就绪通知</span>
    __uint32_t events<span class="token punctuation">;</span>
    <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> </li><li> <p>少量fd的查询用select、poll，大量fd的查询用epoll</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5a01e949469c5c8feaaebae173e2902/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">中秋祝福python</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/233bc218d96b688c78a5232ab1047f7a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">华为云CPU架构鲲鹏计算ARM服务器架构详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>