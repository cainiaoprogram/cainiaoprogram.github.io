<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Golang interface 接口详细原理和使用技巧 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Golang interface 接口详细原理和使用技巧" />
<meta property="og:description" content="文章目录 Golang interface 接口详细原理和使用技巧一、Go interface 介绍interface 在 Go 中的重要性说明interface 的特性interface 接口和 reflect 反射 二、Go 里面为啥偏向使用 Interface可以实现泛型编程(虽然 Go 在 1.18 之后已经支持泛型了)可以隐藏具体的实现可以实现面向对象编程中的多态用法空接口可以接受任何类型的参数 三、Go interface 的常见应用和实战技巧interface 接口赋值通过对象实例赋值通过接口赋值 interface 接口嵌套interface 强制类型转换ret, ok := interface.(type) 断言switch x.(type) 断言 interface 与 nil 的比较 最后 Golang interface 接口详细原理和使用技巧 首次记录 2017 年下半年再次更新 2022 年底 一、Go interface 介绍 interface 在 Go 中的重要性说明 interface 接口在 Go 语言里面的地位非常重要，是一个非常重要的数据结构，只要是实际业务编程，并且想要写出优雅的代码，那么必然要用上 interface，因此 interface 在 Go 语言里面处于非常核心的地位。
我们都知道，Go 语言和典型的面向对象的语言不太一样，Go 在语法上是不支持面向对象的类、继承等相关概念的。但是，并不代表 Go 里面不能实现面向对象的一些行为比如继承、多态，在 Go 里面，通过 interface 完全可以实现诸如 C&#43;&#43; 里面的继承 和 多态的语法效果。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/eedcd7ec014cd83943254adf3ff5cb75/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-29T12:25:45+08:00" />
<meta property="article:modified_time" content="2022-11-29T12:25:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Golang interface 接口详细原理和使用技巧</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Golang_interface__1" rel="nofollow">Golang interface 接口详细原理和使用技巧</a></li><li><ul><li><a href="#Go_interface__6" rel="nofollow">一、Go interface 介绍</a></li><li><ul><li><a href="#interface__Go__8" rel="nofollow">interface 在 Go 中的重要性说明</a></li><li><a href="#interface__13" rel="nofollow">interface 的特性</a></li><li><a href="#interface__reflect__31" rel="nofollow">interface 接口和 reflect 反射</a></li></ul> 
   </li><li><a href="#Go__Interface_37" rel="nofollow">二、Go 里面为啥偏向使用 Interface</a></li><li><ul><li><a href="#_Go__118__40" rel="nofollow">可以实现泛型编程(虽然 Go 在 1.18 之后已经支持泛型了)</a></li><li><a href="#_113" rel="nofollow">可以隐藏具体的实现</a></li><li><a href="#_175" rel="nofollow">可以实现面向对象编程中的多态用法</a></li><li><a href="#_199" rel="nofollow">空接口可以接受任何类型的参数</a></li></ul> 
   </li><li><a href="#Go_interface__221" rel="nofollow">三、Go interface 的常见应用和实战技巧</a></li><li><ul><li><a href="#interface__223" rel="nofollow">interface 接口赋值</a></li><li><ul><li><a href="#_226" rel="nofollow">通过对象实例赋值</a></li><li><a href="#_252" rel="nofollow">通过接口赋值</a></li></ul> 
    </li><li><a href="#interface__263" rel="nofollow">interface 接口嵌套</a></li><li><a href="#interface__300" rel="nofollow">interface 强制类型转换</a></li><li><ul><li><a href="#ret_ok__interfacetype__302" rel="nofollow">ret, ok := interface.(type) 断言</a></li><li><a href="#switch_xtype__319" rel="nofollow">switch x.(type) 断言</a></li></ul> 
    </li><li><a href="#interface__nil__342" rel="nofollow">interface 与 nil 的比较</a></li></ul> 
   </li><li><a href="#_400" rel="nofollow">最后</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Golang_interface__1"></a>Golang interface 接口详细原理和使用技巧</h2> 
<ul><li>首次记录 2017 年下半年</li><li>再次更新 2022 年底</li></ul> 
<h3><a id="Go_interface__6"></a>一、Go interface 介绍</h3> 
<h4><a id="interface__Go__8"></a>interface 在 Go 中的重要性说明</h4> 
<p>interface 接口在 Go 语言里面的地位非常重要，是一个非常重要的数据结构，只要是实际业务编程，并且想要写出优雅的代码，那么必然要用上 interface，因此 interface 在 Go 语言里面处于非常核心的地位。</p> 
<p>我们都知道，Go 语言和典型的面向对象的语言不太一样，Go 在语法上是不支持面向对象的类、继承等相关概念的。但是，并不代表 Go 里面不能实现面向对象的一些行为比如继承、多态，在 Go 里面，通过 interface 完全可以实现诸如 C++ 里面的继承 和 多态的语法效果。</p> 
<h4><a id="interface__13"></a>interface 的特性</h4> 
<p>Go 中的 interface 接口有如下特性：</p> 
<ul><li> <p>关于接口的定义和签名</p> 
  <ul><li>接口是一个或多个方法签名的集合，接口只有方法声明，没有实现，没有数据字段，只要某个类型拥有该接口的所有方法签名，那么就相当于实现了该接口，无需显示声明了哪个接口，这称为 Structural Typing。</li><li>interface 接口可以匿名嵌入其他接口中，或嵌入到 struct 结构中</li><li>接口可以支持匿名字段方法</li></ul> </li><li> <p>关于接口赋值</p> 
  <ul><li>只有当接口存储的类型和对象都为 nil 时，接口才等于 nil</li><li>一个空的接口可以作为任何类型数据的容器</li><li>如果两个接口都拥有相同的方法，那么它们就是等同的，任何实现了他们这个接口的对象之间，都可以相互赋值</li><li>如果某个 struct 对象实现了某个接口的所有方法，那么可以直接将这个 struct 的实例对象直接赋值给这个接口类型的变量。</li></ul> </li><li> <p>关于接口嵌套，Go 里面支持接口嵌套，但是不支持递归嵌套</p> </li><li> <p>通过接口可以实现面向对象编程中的多态的效果</p> </li></ul> 
<h4><a id="interface__reflect__31"></a>interface 接口和 reflect 反射</h4> 
<p>在 Go 的实现里面，每个 interface 接口变量都有一个对应 pair，这个 pair 中记录了接口的实际变量的类型和值<code>(value, type)</code>，其中，value 是实际变量值，type 是实际变量的类型。任何一个 interface{} 类型的变量都包含了2个指针，一个指针指向值的类型，对应 pair 中的 type，这个 type 类型包括静态的类型 (static type，比如 int、string…)和具体的类型(concrete type，interface 所指向的具体类型)，另外一个指针指向实际的值，对应 pair 中的 value。</p> 
<p>interface 及其 pair 的存在，是 Go 语言中实现 reflect 反射的前提，理解了 pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair 对的一种机制。</p> 
<h3><a id="Go__Interface_37"></a>二、Go 里面为啥偏向使用 Interface</h3> 
<p>Go 里面为啥偏向使用 Interface 呢？ 主要原因有如下几点：</p> 
<h4><a id="_Go__118__40"></a>可以实现泛型编程(虽然 Go 在 1.18 之后已经支持泛型了)</h4> 
<p>在 C++ 等高级语言中使用泛型编程非常的简单，但是 Go 在 1.18 版本之前，是不支持泛型的，而通过 Go 的接口，可以实现类似的泛型编程，如下是一个参考示例</p> 
<pre><code>    package sort

    // A type, typically a collection, that satisfies sort.Interface can be
    // sorted by the routines in this package.  The methods require that the
    // elements of the collection be enumerated by an integer index.
    type Interface interface {
        // Len is the number of elements in the collection.
        Len() int
        // Less reports whether the element with
        // index i should sort before the element with index j.
        Less(i, j int) bool
        // Swap swaps the elements with indexes i and j.
        Swap(i, j int)
    }
    
    ...
    
    // Sort sorts data.
    // It makes one call to data.Len to determine n, and O(n*log(n)) calls to
    // data.Less and data.Swap. The sort is not guaranteed to be stable.
    func Sort(data Interface) {
        // Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
        n := data.Len()
        maxDepth := 0
        for i := n; i &gt; 0; i &gt;&gt;= 1 {
            maxDepth++
        }
        maxDepth *= 2
        quickSort(data, 0, n, maxDepth)
    }
    
</code></pre> 
<p>Sort 函数的形参是一个 interface，包含了三个方法：Len()，Less(i,j int)，Swap(i, j int)。使用的时候不管数组的元素类型是什么类型（int, float, string…），只要我们实现了这三个方法就可以使用 Sort 函数，这样就实现了“泛型编程”。</p> 
<p>这种方式，我在闪聊项目里面也有实际应用过，具体案例就是对消息排序。 下面给一个具体示例，代码能够说明一切，一看就懂：</p> 
<pre><code>    type Person struct {
    Name string
    Age  int
    }
    
    func (p Person) String() string {
        return fmt.Sprintf("%s: %d", p.Name, p.Age)
    }
    
    // ByAge implements sort.Interface for []Person based on
    // the Age field.
    type ByAge []Person //自定义
    
    func (a ByAge) Len() int           { return len(a) }
    func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
    func (a ByAge) Less(i, j int) bool { return a[i].Age &lt; a[j].Age }
    
    func main() {
        people := []Person{
            {"Bob", 31},
            {"John", 42},
            {"Michael", 17},
            {"Jenny", 26},
        }
    
        fmt.Println(people)
        sort.Sort(ByAge(people))
        fmt.Println(people)
    }
</code></pre> 
<h4><a id="_113"></a>可以隐藏具体的实现</h4> 
<p>隐藏具体的实现，是说我们提供给外部的一个方法(函数)，但是我们是通过 interface 接口的方式提供的，对调用方来说，只能通过 interface 里面的方法来做一些操作，但是内部的具体实现是完全不知道的。</p> 
<p>例如我们常用的 context 包，就是这样设计的，如果熟悉 Context 具体实现的就会很容易理解。详细代码如下：</p> 
<pre><code>    func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
        c := newCancelCtx(parent)
        propagateCancel(parent, &amp;c)
        return &amp;c, func() { c.cancel(true, Canceled) }
    }
    
</code></pre> 
<p>可以看到 WithCancel 函数返回的还是一个 Context interface，但是这个 interface 的具体实现是 cancelCtx struct。</p> 
<pre><code>        // newCancelCtx returns an initialized cancelCtx.
        func newCancelCtx(parent Context) cancelCtx {
            return cancelCtx{
                Context: parent,
                done:    make(chan struct{}),
            }
        }
        
        // A cancelCtx can be canceled. When canceled, it also cancels any children
        // that implement canceler.
        type cancelCtx struct {
            Context     //注意一下这个地方
        
            done chan struct{} // closed by the first cancel call.
            mu       sync.Mutex
            children map[canceler]struct{} // set to nil by the first cancel call
            err      error                 // set to non-nil by the first cancel call
        }
        
        func (c *cancelCtx) Done() &lt;-chan struct{} {
            return c.done
        }
        
        func (c *cancelCtx) Err() error {
            c.mu.Lock()
            defer c.mu.Unlock()
            return c.err
        }
        
        func (c *cancelCtx) String() string {
            return fmt.Sprintf("%v.WithCancel", c.Context)
        }
</code></pre> 
<p>尽管内部实现上下面三个函数返回的具体 struct （都实现了 Context interface）不同，但是对于使用者来说是完全无感知的。</p> 
<pre><code>    func WithCancel(parent Context) (ctx Context, cancel CancelFunc)    //返回 cancelCtx
    func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) //返回 timerCtx
    func WithValue(parent Context, key, val interface{}) Context    //返回 valueCtx

</code></pre> 
<h4><a id="_175"></a>可以实现面向对象编程中的多态用法</h4> 
<p>interface 只是定义一个或一组方法函数，但是这些方法只有函数签名，没有具体的实现，这个 C++ 中的虚函数非常类似。在 Go 里面，如果某个数据类型实现 interface 中定义的那些函数，则称这些数据类型实现（implement）了这个接口 interface，这是我们常用的 OO 方式，如下是一个简单的示例</p> 
<pre><code>    // 定义一个 SimpleLog 接口
    type SimpleLog interface {
        Print()
    }
    
    func TestFunc(x SimpleLog) {}
   
    // 定义一个 PrintImpl 结构，用来实现 SimpleLog 接口
    type PrintImpl struct {}
    // PrintImpl 对象实现了SimpleLog 接口的所有方法(本例中是 Print 方法)，就说明实现了  SimpleLog 接口
    func (p *PrintImpl) Print() {
    
    }
    
    func main() {
        var p PrintImpl
        TestFunc(p)
    }
</code></pre> 
<h4><a id="_199"></a>空接口可以接受任何类型的参数</h4> 
<p>空接口比较特殊，它不包含任何方法：interface{} ，在 Go 语言中，所有其它数据类型都实现了空接口，如下：</p> 
<pre><code>var v1 interface{} = 1
var v2 interface{} = "abc"
var v3 interface{} = struct{ X int }{1}
</code></pre> 
<p>因此，当我们给 func 定义了一个 interface{} 类型的参数(也就是一个空接口)之后，那么这个参数可以接受任何类型，官方包中最典型的例子就是标准库 fmt 包中的 Print 和 Fprint 系列的函数。</p> 
<p>一个简单的定义示例方法如下：</p> 
<pre><code>	Persist(context context.Context, msg interface{}) bool
</code></pre> 
<p>msg 可以为任何类型，如 pb.MsgInfo or pb.GroupMsgInfo，定义方法的时候可以统一命名模块，实现的时候，根据不同场景实现不同方法。</p> 
<h3><a id="Go_interface__221"></a>三、Go interface 的常见应用和实战技巧</h3> 
<h4><a id="interface__223"></a>interface 接口赋值</h4> 
<p>可以将一个实现接口的对象实例赋值给接口，也可以将另外一个接口赋值给接口。</p> 
<h5><a id="_226"></a>通过对象实例赋值</h5> 
<p>将一个对象实例赋值给一个接口之前，要保证该对象实现了接口的所有方法。在 Go 语言中，一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口，这个是非侵入式接口的设计模式，非侵入式接口一个很重要的优势就是可以免去面向对象里面那套比较复杂的类的继承体系。</p> 
<p>在 Go 里面，面向对象的那套类的继承体系就不需要关心了，定义接口的时候，我们只需关心这个接口应该提供哪些方法，当然，按照 Go 的原则，接口的功能要尽可能的保证职责单一。而对应接口的实现，也就是接口的调用方，我们只需要知道这个接口定义了哪些方法，然后我们实现这些方法就可以了，这个也无需提前规划，调用方也无需关系是否有其他模块定义过类似的接口或者实现，只关注自身就行。</p> 
<p>考虑如下示例：</p> 
<pre><code>type Integer int
func (a Integer) Less(b Integer) bool {
    return a &lt; b
}
func (a *Integer) Add(b Integer) {
    *a += b
}
type LessAdder interface { 
    Less(b Integer) bool 
    Add(b Integer)
}
var a Integer = 1
var b1 LessAdder = &amp;a  //OK
var b2 LessAdder = a   //not OK
</code></pre> 
<p>b2 的赋值会报编译错误，为什么呢？因为这个：<code>The method set of any other named type T consists of all methods with receiver type T. The method set of the corresponding pointer type T is the set of all methods with receiver T or T (that is, it also contains the method set of T).</code>也就是说 *Integer 这个指针类型实现了接口 LessAdder 的所有方法，而 Integer 只实现了 Less 方法，所以不能赋值。</p> 
<h5><a id="_252"></a>通过接口赋值</h5> 
<pre><code>        var r io.Reader = new(os.File)
        var rw io.ReadWriter = r   //not ok
        var rw2 io.ReadWriter = new(os.File)
        var r2 io.Reader = rw2    //ok
</code></pre> 
<p>因为 r 没有 Write 方法，所以不能赋值给rw。</p> 
<h4><a id="interface__263"></a>interface 接口嵌套</h4> 
<p>io package 中的一个接口：</p> 
<pre><code>// ReadWriter is the interface that groups the basic Read and Write methods.
type ReadWriter interface {
    Reader
    Writer
}
</code></pre> 
<p>ReadWriter 接口嵌套了 io.Reader 和 io.Writer 两个接口，实际上，它等同于下面的写法：</p> 
<pre><code>type ReadWriter interface {
    Read(p []byte) (n int, err error) 
    Write(p []byte) (n int, err error)
}
</code></pre> 
<p>注意，Go 语言中的接口不能递归嵌套，如下：</p> 
<pre><code>// illegal: Bad cannot embed itself
type Bad interface {
    Bad
}
// illegal: Bad1 cannot embed itself using Bad2
type Bad1 interface {
    Bad2
}
type Bad2 interface {
    Bad1
}
</code></pre> 
<h4><a id="interface__300"></a>interface 强制类型转换</h4> 
<h5><a id="ret_ok__interfacetype__302"></a>ret, ok := interface.(type) 断言</h5> 
<p>在 Go 语言中，可以通过 <code>interface.(type) </code>的方式来对一个 interface 进行强制类型转换，但是如果这个 interface 被转换为一个不包含指定类型的类型，那么就会出现 panic 。因此，实战应用中，我们通常都是通过 <code>ret, ok := interface.(type)</code>这种断言的方式来优雅的进行转换，这个方法中第一个返回值是对应类型的值，第二个返回值是类型是否正确，只有 ok = true 的情况下，才说明转换成功，最重要的是，通过这样的转换方式可以避免直接转换如果类型不对的情况下产生 panic。</p> 
<p>如下是一个以 string 为类型的示例：</p> 
<pre><code>str, ok := value.(string)
if ok {
    fmt.Printf("string value is: %q\n", str)
} else {
    fmt.Printf("value is not a string\n")
}

如果类型断言失败，则str将依然存在，并且类型为字符串，不过其为零值，即一个空字符串。
</code></pre> 
<h5><a id="switch_xtype__319"></a>switch x.(type) 断言</h5> 
<p>查询接口类型的方式为：</p> 
<pre><code>switch x.(type) {
    // cases :
}
</code></pre> 
<p>示例如下：</p> 
<pre><code>var value interface{} // Value provided by caller.
switch str := value.(type) {
case string:
    return str //type of str is string
case int: 
    return int //type of str is int
}
语句switch中的value必须是接口类型，变量str的类型为转换后的类型。
</code></pre> 
<h4><a id="interface__nil__342"></a>interface 与 nil 的比较</h4> 
<p>interface 与 nil 的比较是挺有意思的，例子是最好的说明，如下例子：</p> 
<pre><code>package main

import (
	"fmt"
	"reflect"
)

type State struct{}

func testnil1(a, b interface{}) bool {
	return a == b
}

func testnil2(a *State, b interface{}) bool {
	return a == b
}

func testnil3(a interface{}) bool {
	return a == nil
}

func testnil4(a *State) bool {
	return a == nil
}

func testnil5(a interface{}) bool {
	v := reflect.ValueOf(a)
	return !v.IsValid() || v.IsNil()
}

func main() {
	var a *State
	fmt.Println(testnil1(a, nil))
	fmt.Println(testnil2(a, nil))
	fmt.Println(testnil3(a))
	fmt.Println(testnil4(a))
	fmt.Println(testnil5(a))
}
</code></pre> 
<p>运行后返回的结果如下</p> 
<pre><code>false
false
false
true
true
</code></pre> 
<p>为什么是这个结果？</p> 
<p>*<strong>因为一个 interface{} 类型的变量包含了2个指针，一个指针指向值的类型，另外一个指针指向实际的值。对一个 interface{} 类型的 nil 变量来说，它的两个指针都是0；但是 var a <em>State 传进去后，指向的类型的指针不为0了，因为有类型了， 所以比较为 false。 interface 类型比较， 要是两个指针都相等，才能相等。</em></strong></p> 
<h3><a id="_400"></a>最后</h3> 
<p>请允许我打个小广告：<a href="https://mp.weixin.qq.com/s/G7woQjrAnjPcfHbHDUC1Ig" rel="nofollow">这篇文章首发在我微信公众号【后端系统和架构】中，点击这里可以去往公众号查看原文链接，如果对你有帮助，欢迎前往关注，更加方便快捷的接收最新优质文章</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6cf10d7907df86cf8923b1b3015c27e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">idea快速导出jar包工具：Hand Export Jar</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3793003608a066589f7623bae6adb37f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度剖析黑帽SEO手法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>