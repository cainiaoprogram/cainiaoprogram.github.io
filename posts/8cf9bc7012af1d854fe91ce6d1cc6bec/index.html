<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>javascript基础-多线程、携程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="javascript基础-多线程、携程" />
<meta property="og:description" content="一、js多线程 1.ConcurrentThread 在webworker之前，js只有单线程，但是有一些方法可以模拟多线程。
一个日本人开发的库 ConcurrentThread.js，他模拟多线程的原理是：
假设我有一个while循环，把它扔到 Concurrent 方法的回调函数中，他把你的回调函数取函数体，然后对函数体进行类似 AST 分析，然后把while循环替换成 requestAnimationFrame 之类的异步方法。
它的另一种做法是在 &lt;script type=&#34;text/x-script.multithreaded-js&#34;&gt; 内写代码，实际上道理类似，对标签内部做 AST 分析。
2.webworker webworker能够开辟一个新的对象，不占用window对象，所以它有自己的一个线程。所以死循环也不会造成页面阻塞。
⚠️webworker需要服务启动页面。
在html中：
// index.js是业务js const worker = new Worker(&#39;./index.js&#39;); worker.onmessage = function ({ data }){ // 获得返回的值 console.log(data); // 关闭这个worker self.close(); }; // 通知 message 开始 worker.postMessage(&#39;worker post-message start&#39;); 在业务js中：
onmessage = function (){ // 开始 let i = 0; // 处理一个非常占用线程的同步任务 for (; i &lt; 1000000000; i&#43;&#43;) {} // 通知worker对象同步任务已经完成 postMessage(i); }; 在上述代码中，业务js的for循环不会造成主线程阻塞。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8cf9bc7012af1d854fe91ce6d1cc6bec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-18T11:13:59+08:00" />
<meta property="article:modified_time" content="2023-03-18T11:13:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">javascript基础-多线程、携程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="main-toc">一、js多线程</h3> 
<h4 id="1.ConcurrentThread">1.ConcurrentThread</h4> 
<p>在webworker之前，js只有单线程，但是有一些方法可以<strong>模拟多线程</strong>。</p> 
<p>一个日本人开发的库 ConcurrentThread.js，他模拟多线程的原理是：</p> 
<p>假设我有一个while循环，把它扔到 Concurrent 方法的回调函数中，他把你的回调函数取函数体，然后对函数体进行类似 AST 分析，然后把while循环替换成 requestAnimationFrame 之类的异步方法。</p> 
<p>它的另一种做法是在 &lt;script type="text/x-script.multithreaded-js"&gt;  内写代码，实际上道理类似，对标签内部做 AST 分析。<br>  </p> 
<h4 id="2.webworker">2.webworker</h4> 
<p>webworker能够开辟一个新的对象，不占用window对象，所以它有自己的一个线程。所以死循环也不会造成页面阻塞。</p> 
<p>⚠️webworker需要服务启动页面。</p> 
<p>在html中：</p> 
<pre><code class="language-javascript">//    index.js是业务js
const worker = new Worker('./index.js');
worker.onmessage = function ({ data }){
    //  获得返回的值
    console.log(data);
    //  关闭这个worker
    self.close();
};
//  通知 message 开始
worker.postMessage('worker post-message start');</code></pre> 
<p>在业务js中：</p> 
<pre><code class="language-javascript">onmessage = function (){
    //  开始
    let i = 0;
    //  处理一个非常占用线程的同步任务
    for (; i &lt; 1000000000; i++) {}
    //  通知worker对象同步任务已经完成
    postMessage(i);
};
</code></pre> 
<p>在上述代码中，业务js的for循环不会造成主线程阻塞。</p> 
<h3 id="%E4%BA%94%E3%80%81%E5%8D%8F%E7%A8%8B">二、协程</h3> 
<p>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。</p> 
<p>协程是比线程更轻量级的概念，</p> 
<p>一个进程可以有多个线程；一个线程可以有多个协程。</p> 
<p>协程可以锁线程，在执行到当前代码前，当前代码 到 上一个协程结束后的代码 的 中间的代码 不执行。</p> 
<h4 id="1.promise">1.promise</h4> 
<pre><code class="language-javascript">new Promise(resolve =&gt; {
    //  同步
    console.log(1);
    resolve();
    new Promise(__resolve =&gt; {
        //  同步
        console.log(2);
        __resolve();
    })
        .then(() =&gt; {
            //  异步1， ⚠️内部的then先执行
            console.log(4);
        });
})
    .then(() =&gt; {
        //  异步2
        console.log(5);
    });
//  同步
console.log(3);</code></pre> 
<h4 id="2.generator">2.generator</h4> 
<pre><code class="language-javascript">let a = 0;

//  generator函数
function * generator(){
    a++;
    //    ⚠️协程，锁变量，直到再次执行之前不会变
    yield a++;
    a++;
    yield a++;
}

const g = generator();
//  0   虽然调用了 generator ，但在调用 next 前，函数不会执行
console.log(a);

a++;
//  1
console.log(a);

g.next();
//  3
console.log(a);

a++;
//  4
console.log(a);

g.next();
//  6
console.log(a);</code></pre> 
<h4 id="3.async">3.async</h4> 
<p>async 是 generator函数function *(){}的语法糖。</p> 
<p>async 代码：await只是阻塞了当前表达式本身，但是作为表达式的元素，如果是一个表达式，还是要先执行完。</p> 
<pre><code class="language-javascript">let a = 0;
let f = async function (){
    //  没有遇到await，同步执行，此时 a === 1
    a++;
    //  执行所有与await无关的表达式
    //  (a++) 与 (a = a + 1) 是await所在表达式的元素，先得得到这两个表达式的值
    //  (a++) 后 a === 2，(a++) 表达式的值为1
    //  (a = a + 1) 后 a === 3，表达式的值为3
    //  此时返回主线程 
    //  。。。。主线程完成后。。。。
    //  执行await，表达式的元素分别被锁定，a = 1 + 3 + 10
    a = a++ + await (a = a + 1) + 10;
    //  故 a === 14
    console.log(a === 14);
};

//  执行函数
f();
//  主线程，返回到此时，a === 3
console.log(a === 3);
a++;
//  a === 4
console.log(a === 4);
//  主线程执行完，返回携程
</code></pre> 
<pre><code class="language-javascript">const f1 = async () =&gt; {
    //  同步
    console.log(1);
    //  同步执行f2
    //  执行完f2后，返回主线程
    //  .........
    //  主线程完成后，先进入f2的携程，因为f2作为f1中await的操作元，还没有执行完  ⚠️ -&gt;
    await f2();
    //  -&gt;💡
    console.log(5);
};
const f2 = async () =&gt; {
    //  同步
    console.log(2);
    //  返回主线程，对于f2来说，主线程是f1
    await null;
    //  -&gt;⚠️
    console.log(4);
    //  💡-&gt;
};
//  开始
f1();
//  同步，主线程完成，返回携程
console.log(3);</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/43701baa0a1097dabc7df1a16d27235c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[前缀和&#43;hashmap]leetcode2588：统计美丽子数组数目(medium)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c3a98c760924c43183f4776159d067e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win10家庭版系统升级</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>