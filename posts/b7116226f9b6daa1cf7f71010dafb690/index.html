<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>5个 VueUse 库函数，让你工作效率翻倍(收藏！) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="5个 VueUse 库函数，让你工作效率翻倍(收藏！)" />
<meta property="og:description" content="大厂技术 高级前端 Node进阶
点击上方 程序员成长指北，关注公众号
回复1，加入高级Node交流群
英文 | https://learnvue.co/2021/07/5-vueuse-library-functions-that-can-speed-up-development/
翻译 | 小爱
VueUse 是 Anthony Fu 的一个开源项目，它为 Vue 开发人员提供了大量适用于 Vue 2 和 Vue 3 的基本 Composition API 实用程序函数。 它为常见的开发人员用例提供了数十种解决方案，例如，跟踪引用更改、检测元素可见性、简化常见的 Vue 模式、键盘/鼠标输入等。这是真正节省开发时间的好方法，因为你不必自己添加所有这些标准功能。 我喜欢 VueUse 库，因为在决定提供哪些实用程序时，它确实将开发人员放在首位，而且它是一个维护良好的库，因为它与当前版本的 Vue 保持同步。 VueUse 有哪些实用程序？ 如果你想查看每个实用程序的完整列表，我绝对建议你查看官方文档。但总结一下，VueUse 中有 9 种函数。 动画（Animation）—包含易于使用的过渡、超时和计时函数
浏览器（Browser）—可用于不同的屏幕控制、剪贴板、首选项等
组件（Component）— 为不同的组件方法提供简写
Formatters – 提供反应时间格式化功能
传感器（Sensors ）—用于监听不同的 DOM 事件、输入事件和网络事件
状态（State ）—管理用户状态（全局、本地存储、会话存储）
实用程序（Utility）—不同的实用程序函数，如 getter、条件、引用同步等
Watch —更高级的观察者类型，如可暂停观察者、去抖动观察者和条件观察者
杂项（Misc）— 事件、WebSockets 和 Web Worker 的不同类型的功能 这些类别中的大多数都包含几个不同的功能，因此 VueUse 可以灵活地用于你的用例，并且可以作为快速开始构建 Vue 应用程序的绝佳场所。 在本文中，我们将研究 5 个不同的 VueUse 函数，以便你了解在这个库中工作是多么容易。 但首先，让我们将它添加到我们的 Vue 项目中！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b7116226f9b6daa1cf7f71010dafb690/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-24T08:56:02+08:00" />
<meta property="article:modified_time" content="2022-01-24T08:56:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">5个 VueUse 库函数，让你工作效率翻倍(收藏！)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <h2>大厂技术  高级前端  Node进阶<br></h2> 
 <p style="text-align:center;">点击上方 程序员成长指北，关注公众号<br></p> 
 <p style="text-align:center;">回复1，加入高级Node交流群</p> 
 <p style="text-align:left;">英文 | https://learnvue.co/2021/07/5-vueuse-library-functions-that-can-speed-up-development/<br></p> 
 <p style="text-align:left;">翻译 | 小爱</p> 
 <p style="text-align:left;">VueUse 是 Anthony Fu 的一个开源项目，它为 Vue 开发人员提供了大量适用于 Vue 2 和 Vue 3 的基本 Composition API 实用程序函数。 </p> 
 <p style="text-align:center;"><img title="" src="https://images2.imgbox.com/47/64/Nv0RfNIM_o.png" alt="67ab66a9f553f7c1cbbc5dfa9493fc58.png"></p> 
 <p style="text-align:left;">它为常见的开发人员用例提供了数十种解决方案，例如，跟踪引用更改、检测元素可见性、简化常见的 Vue 模式、键盘/鼠标输入等。这是真正节省开发时间的好方法，因为你不必自己添加所有这些标准功能。 </p> 
 <p style="text-align:left;">我喜欢 VueUse 库，因为在决定提供哪些实用程序时，它确实将开发人员放在首位，而且它是一个维护良好的库，因为它与当前版本的 Vue 保持同步。 </p> 
 <h3><strong>VueUse 有哪些实用程序？</strong></h3> 
 <p style="text-align:left;">如果你想查看每个实用程序的完整列表，我绝对建议你查看官方文档。但总结一下，VueUse 中有 9 种函数。 </p> 
 <ol><li><p style="text-align:left;">动画（Animation）—包含易于使用的过渡、超时和计时函数</p></li><li><p style="text-align:left;">浏览器（Browser）—可用于不同的屏幕控制、剪贴板、首选项等</p></li><li><p style="text-align:left;">组件（Component）— 为不同的组件方法提供简写</p></li><li><p style="text-align:left;">Formatters – 提供反应时间格式化功能</p></li><li><p style="text-align:left;">传感器（Sensors ）—用于监听不同的 DOM 事件、输入事件和网络事件</p></li><li><p style="text-align:left;">状态（State ）—管理用户状态（全局、本地存储、会话存储）</p></li><li><p style="text-align:left;">实用程序（Utility）—不同的实用程序函数，如 getter、条件、引用同步等</p></li><li><p style="text-align:left;">Watch —更高级的观察者类型，如可暂停观察者、去抖动观察者和条件观察者</p></li><li><p style="text-align:left;">杂项（Misc）— 事件、WebSockets 和 Web Worker 的不同类型的功能 </p></li></ol> 
 <p style="text-align:left;">这些类别中的大多数都包含几个不同的功能，因此 VueUse 可以灵活地用于你的用例，并且可以作为快速开始构建 Vue 应用程序的绝佳场所。 </p> 
 <p style="text-align:left;">在本文中，我们将研究 5 个不同的 VueUse 函数，以便你了解在这个库中工作是多么容易。 </p> 
 <p style="text-align:left;">但首先，让我们将它添加到我们的 Vue 项目中！</p> 
 <h3><strong>将 VueUse 安装到你的 Vue 项目中</strong></h3> 
 <p style="text-align:left;">VueUse 的最佳特性之一是它仅通过一个包即可与 Vue 2 和 Vue 3 兼容！ </p> 
 <p style="text-align:left;">安装 VueUse 有两种选择：npm 或 CDN</p> 
 <pre class="has"><code class="language-nginx">npm i @vueuse/core # yarn add @vueuse/core</code></pre> 
 <pre class="has"><code class="language-xml">&lt;script src="https://unpkg.com/@vueuse/shared"&gt;&lt;/script&gt;
&lt;script src="https://unpkg.com/@vueuse/core"&gt;&lt;/script&gt;</code></pre> 
 <p style="text-align:left;">我建议使用 NPM，因为它使用法更容易理解，但如果我们使用 CDN，则可以通过以下方式在应用程序中访问 VueUse window.VueUse</p> 
 <p style="text-align:left;">对于 NPM 安装，所有函数都可以通过@vueuse/core使用标准对象解构导入它们来访问，如下所示：</p> 
 <pre class="has"><code class="language-nginx">// 从 VueUse 导入的示例
import { useRefHistory } from '@vueuse/core'</code></pre> 
 <p style="text-align:left;">好的。现在我们已经安装了 VueUse，让我们在我们的应用程序中使用它。</p> 
 <h3><strong>1、useRefHistory 跟踪响应式数据的更改</strong></h3> 
 <p style="text-align:left;">useRefHistory跟踪对 ref 所做的每个更改并将其存储在数组中。这使我们可以轻松地为我们的应用程序提供撤消和重做功能。 </p> 
 <p style="text-align:left;">让我们看一个示例，其中我们正在构建一个我们希望能够撤消的文本区域。 </p> 
 <p style="text-align:left;">第一步是在不使用 VueUse 的情况下创建我们的基本组件——使用 ref、textarea 和用于撤消和重做的按钮。 </p> 
 <pre class="has"><code class="language-xml">&lt;template&gt;
  &lt;p&gt; 
    &lt;button&gt; Undo &lt;/button&gt;
    &lt;button&gt; Redo &lt;/button&gt;
  &lt;/p&gt;
  &lt;textarea v-model="text"/&gt;
&lt;/template&gt;


&lt;script setup&gt;
import { ref } from 'vue'
const text = ref('')
&lt;/script&gt;


&lt;style scoped&gt;
  button {
    border: none;
    outline: none;
    margin-right: 10px;
    background-color: #2ecc71;
    color: white;
    padding: 5px 10px;;
  }
&lt;/style&gt;</code></pre> 
 <p style="text-align:left;">然后，让我们通过导入useRefHistory函数然后从我们的文本引用中提取历史、撤消和重做属性来添加 VueUse 。这就像调用useRefHistory和传递我们的 ref一样简单。 </p> 
 <pre class="has"><code class="language-javascript">import { ref } from 'vue'
import { useRefHistory } from '@vueuse/core'


const text = ref('')
const { history, undo, redo } = useRefHistory(text)</code></pre> 
 <p style="text-align:left;">每次我们的 ref 更改时，这都会触发一个观察者——更新history我们刚刚创建的属性。 </p> 
 <p style="text-align:left;">然后，为了让我们真正了解发生了什么，让我们在模板中打印历史记录，undo并redo在单击相应按钮时调用我们的函数。 </p> 
 <pre class="has"><code class="language-xml">&lt;template&gt;
  &lt;p&gt; 
    &lt;button @click="undo"&gt; Undo &lt;/button&gt;
    &lt;button @click="redo"&gt; Redo &lt;/button&gt;
  &lt;/p&gt;
  &lt;textarea v-model="text"/&gt;
  &lt;ul&gt;
    &lt;li v-for="entry in history" :key="entry.timestamp"&gt;
      {<!-- -->{ entry }}
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;


&lt;script setup&gt;
import { ref } from 'vue'
import { useRefHistory } from '@vueuse/core'
const text = ref('')
const { history, undo, redo } = useRefHistory(text)
&lt;/script&gt;


&lt;style scoped&gt;
  button {
    border: none;
    outline: none;
    margin-right: 10px;
    background-color: #2ecc71;
    color: white;
    padding: 5px 10px;;
  }
&lt;/style&gt;</code></pre> 
 <p style="text-align:left;">好的，现在让我们运行它。当我们输入时，每个字符都会触发历史数组中的一个新条目，如果我们单击撤消/重做，我们将转到相应的条目。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/62/fe/swbWn80s_o.gif" alt="19ffcb1f4356a847983739c4f2cd3c7a.gif"></p> 
 <p style="text-align:left;">还有不同的选项可以为此功能添加更多功能。例如，我们可以深入跟踪反应对象并限制这样的历史条目的数量。</p> 
 <pre class="has"><code class="language-properties">//高级选项
const { history, undo, redo } = useRefHistory(text, {
  deep: true,
  capacity: 10,
})</code></pre> 
 <p style="text-align:left;">如需完整的选项列表，请务必查看文档。 </p> 
 <h3><strong>2、onClickOutside 关闭模态</strong></h3> 
 <p style="text-align:left;">onClickOutside检测在元素之外进行的任何点击。根据我的经验，此功能最常见的用例是关闭任何模式或弹出窗口。 </p> 
 <p style="text-align:left;">通常，我们希望模态屏蔽网页的其余部分以吸引用户的注意力并限制错误。但是，如果他们确实在模态之外单击，我们希望它关闭。</p> 
 <p style="text-align:left;">只需两个步骤即可完成此操作：</p> 
 <ol><li><p>为我们要检测的元素创建一个模板引用</p></li><li><p>onClickOutside使用此模板引用 运行</p></li></ol> 
 <p style="text-align:left;">这是一个带有弹出窗口的简单组件，使用onClickOutside. </p> 
 <pre class="has"><code class="language-xml">&lt;template&gt;
  &lt;button @click="open = true"&gt; Open Popup &lt;/button&gt;
  &lt;div class="popup" v-if='open'&gt;
    &lt;div class="popup-content" ref="popup"&gt;
      Lorem ipsum dolor sit amet consectetur adipisicing elit. Corporis aliquid autem reiciendis eius accusamus sequi, ipsam corrupti vel laboriosam necessitatibus sit natus vero sint ullam! Omnis commodi eos accusantium illum?
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;


&lt;script setup&gt;
import { ref } from 'vue'
import { onClickOutside } from '@vueuse/core'
const open = ref(false) // state of our popup
const popup = ref() // template ref
// whenever our popup exists, and we click anything BUT it
onClickOutside(popup, () =&gt; {
  open.value  = false
})
&lt;/script&gt;


&lt;style scoped&gt;
  button {
    border: none;
    outline: none;
    margin-right: 10px;
    background-color: #2ecc71;
    color: white;
    padding: 5px 10px;;
  }
  .popup {
    position: fixed;
    top: ;
    left: ;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(, , , 0.1);
  }
  .popup-content {
    min-width: 300px;
    padding: 20px;
    width: 30%;
    background: #fff;
  }
&lt;/style&gt;</code></pre> 
 <p style="text-align:left;">结果是这样的，我们可以用我们的按钮打开弹出窗口，然后通过在弹出内容窗口外单击来关闭它。 </p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/4c/4a/nJQAAu0T_o.gif" alt="33ba5140d672ab28b401a3f791eefd0f.gif"></p> 
 <h3><strong>3、useVModel 简化了 v-model 绑定</strong></h3> 
 <p style="text-align:left;">Vue 开发人员的一个常见用例是为组件创建自定义 v-model 绑定。这意味着我们的组件接受一个值作为 prop，并且每当该值被修改时，我们的组件都会向父级发出更新事件。 </p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/62/47/zE0gmW4x_o.png" alt="6a52a969fd05dca9074e23e60e235785.png"></p> 
 <p style="text-align:left;">有关构建自定义 v-model 的完整教程，请查看我们关于该主题的完整指南。</p> 
 <p style="text-align:left;">useVModel 函数将其简化为仅使用标准 ref 语法。假设我们有一个自定义文本输入，它试图为其文本输入的值创建一个 v-model。通常，我们必须接受该值的 prop，然后发出更改事件以更新父组件中的数据值。</p> 
 <p style="text-align:left;">我们可以像普通的 ref 一样使用和对待它，而不是使用 ref 和调用props.value and ！这有助于减少我们需要记住的不同语法的数量！update:valueuseVModel</p> 
 <pre class="has"><code class="language-xml">&lt;template&gt;
    &lt;div&gt;
        &lt;input 
            type="text" 
            :value="data"
            @input="update"
        /&gt;
    &lt;/div&gt;
&lt;/template&gt;


&lt;script&gt;
import { useVModel } from '@vueuse/core'
export default {
  props: ['data'],
  setup(props, { emit }) {
    const data = useVModel(props, 'data', emit)
    console.log(data.value) // equal to props.data
    data.value = 'name' // equal to emit('update:data', 'name')
    const update = (event) =&gt; {
        data.value = event.target.value
    }
    return {
        data,
        update
    }
  },
}
&lt;/script&gt;</code></pre> 
 <p style="text-align:left;">每当我们需要访问我们的值时，我们只需调用.valueuseVModel 就会从我们的组件 props 中获取值。每当我们更改对象的值时，useVModel 都会向父组件发出更新事件。 </p> 
 <p style="text-align:left;">这是父组件可能是什么样子的一个快速示例......</p> 
 <pre class="has"><code class="language-xml">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt; {<!-- -->{ data }} &lt;/p&gt;
    &lt;custom-input 
      :data="data" 
      @update:data="data = $event"
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;


&lt;script&gt;
import CustomInput from './components/CustomInput.vue'
import { ref } from 'vue'
export default {
  components: {
    CustomInput,
  },
  setup () {
    const data = ref('hello')
    return {
      data
    }
  }
}</code></pre> 
 <p style="text-align:left;">结果看起来像这样，我们在父级中的值始终与子级中的输入保持同步。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/6a/8d/QwxcAoKj_o.gif" alt="206d9353a521f300d5a946a2ba67a1b2.gif"></p> 
 <h3><strong>4、使用IntersectionObserver 跟踪元素可见性</strong></h3> 
 <p style="text-align:left;">在确定两个元素是否重叠时，Intersection Observers非常强大。一个很好的用例是检查元素当前是否在视口中可见。 </p> 
 <p style="text-align:left;">本质上，它检查目标元素与根元素/文档相交的百分比。如果该百分比超过某个阈值，它会调用一个回调来确定目标元素是否可见。</p> 
 <p style="text-align:left;">useIntersectionObserver提供使用 IntersectionObserver API 的简单语法。我们需要做的就是为我们要检查的元素提供一个模板引用。</p> 
 <p style="text-align:left;">默认情况下，IntersectionObserver 将使用文档的视口作为根，阈值为 0.1——因此当在任一方向超过该阈值时，我们的交叉观察者将触发。 </p> 
 <p style="text-align:left;">该示例的代码可能看起来像这样，其中我们有一个虚拟段落，它只占用视口、目标元素中的空间。</p> 
 <pre class="has"><code class="language-xml">&lt;template&gt;
  &lt;p&gt; Is target visible? {<!-- -->{ targetIsVisible }} &lt;/p&gt;
  &lt;div class="container"&gt;
    &lt;div class="target" ref="target"&gt;
      &lt;h1&gt;Hello world&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;


&lt;script&gt;
import { ref } from 'vue'
import { useIntersectionObserver } from '@vueuse/core'
export default {
  setup() {
    const target = ref(null)
    const targetIsVisible = ref(false)
    const { stop } = useIntersectionObserver(
      target,
      ([{ isIntersecting }], observerElement) =&gt; {
        targetIsVisible.value = isIntersecting
      },
    )
    return {
      target,
      targetIsVisible,
    }
  },
}
&lt;/script&gt;


&lt;style scoped&gt;
.container {
  width: 80%;
  margin:  auto;
  background-color: #fafafa;
  max-height: 300px;
  overflow: scroll;
}
.target {
  margin-top: 500px;
  background-color: #1abc9c;
  color: white;
  padding: 20px;
}
&lt;/style&gt;</code></pre> 
 <p style="text-align:left;">当我们运行它并滚动时，我们会看到它正确更新。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/bd/cf/xVDsZaRn_o.png" alt="0cd370954e7c739bebcd22eb5b65d49f.png"></p> 
 <p style="text-align:left;">我们还可以为 Intersection Observer 指定更多选项，例如，更改其根元素、边距（用于计算交点的根边界框的偏移量）和阈值级别。 </p> 
 <pre class="has"><code class="language-typescript">//useIntersectionObserver 的选项
const { stop } = useIntersectionObserver(
      target,
([{ isIntersecting }], observerElement) =&gt; {
        targetIsVisible.value = isIntersecting
      },
      {
// root, rootMargin, threshold, window
// full options in the source: https://github.com/vueuse/vueuse/blob/main/packages/core/useIntersectionObserver/index.ts
        threshold: 0.5,
      }
)</code></pre> 
 <p style="text-align:left;">同样重要的是看到这个方法返回一个stop函数，我们可以调用它来停止观察交叉点。如果我们只想跟踪元素第一次在屏幕上可见时，这尤其有用。</p> 
 <p style="text-align:left;">在此代码片段中，一旦targetIsVisible设置为 true，观察者将停止，即使我们滚动离开目标元素，我们的值仍将保持为 true。</p> 
 <pre class="has"><code class="language-typescript">//停止 IntersectionObserver
const { stop } = useIntersectionObserver(
      target,
      ([{ isIntersecting }], observerElement) =&gt; {
        targetIsVisible.value = isIntersecting
        if (isIntersecting) {
          stop()
        }
      },
    )</code></pre> 
 <h3><strong>5、useTransition 在值之间缓和</strong></h3> 
 <p style="text-align:left;">useTransition是整个 VueUse 库中我最喜欢的函数之一。它允许我们在一行中平滑地在数值之间缓和。 </p> 
 <p style="text-align:left;">我们有一个存储为 ref 的数字源和一个输出，它将是不同值之间的缓和。例如，假设我们要为 Vue 3 备忘单构建一个类似于注册页面上的计数器。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/d1/19/itkwJ7FW_o.gif" alt="9a3b772630c954128d02ce2d6f691a29.gif"></p> 
 <p style="text-align:left;">我们可以通过三个步骤来做到这一点：</p> 
 <ul><li><p>创建我们的countref 并将其初始化为零</p></li><li><p>创建我们的output参考useTransition（设置我们的持续时间和转换类型）</p></li><li><p>改变count 的价值 </p></li></ul> 
 <pre class="has"><code class="language-xml">// 使用转换代码
&lt;script setup&gt;
import { ref } from 'vue'
import { useTransition, TransitionPresets } from '@vueuse/core'


const source = ref(0)


const output = useTransition(source, {
  duration: 3000,
  transition: TransitionPresets.easeOutExpo,
})


source.value = 5000
&lt;/script&gt;</code></pre> 
 <p style="text-align:left;">然后，在我们的模板中，我们希望显示的值，output因为它可以在不同值之间平滑过渡。</p> 
 <pre class="has"><code class="language-xml">&lt;template&gt;
  &lt;h2&gt; 
    &lt;p&gt; Join over &lt;/p&gt;
    &lt;p&gt; {<!-- -->{ Math.round(output) }}+ &lt;/p&gt;
    &lt;p&gt;Developers &lt;/p&gt;
  &lt;/h2&gt;
&lt;/template&gt;


&lt;script setup&gt;
import { ref } from 'vue'
import { useTransition, TransitionPresets } from '@vueuse/core'
const source = ref()
const output = useTransition(source, {
  duration: 3000,
  transition: TransitionPresets.easeOutExpo,
})
source.value = 5000
&lt;/script&gt;</code></pre> 
 <p style="text-align:left;">结果如下！</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/64/2a/Qo7JBYHl_o.gif" alt="5cf7a76bedded10703fb2ed2b690cb2c.gif"></p> 
 <p style="text-align:left;">我们还可以useTransition用来转换整个数字数组。这在处理位置或颜色时很有用。处理颜色的一个重要技巧是使用计算属性将 RGB 值格式化为正确的颜色语法。</p> 
 <pre class="has"><code class="language-xml">&lt;template&gt;
&lt;h2 :style="{ color: color } "&gt; COLOR CHANGING &lt;/h2&gt;
&lt;/template&gt;
&lt;script setup&gt;
import { ref, computed } from 'vue'
import { useTransition, TransitionPresets } from '@vueuse/core'
const source = ref([, , ])
const output = useTransition(source, {
duration: 3000,
transition: TransitionPresets.easeOutExpo,
})
const color = computed(() =&gt; {
const [r, g, b] = output.value
return `rgb(${r}, ${g}, ${b})`
})
source.value = [255, , 255]
&lt;/script&gt;</code></pre> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/eb/fd/EoAXGiEf_o.gif" alt="8d75587b327625f709aec1cd07b435b5.gif"></p> 
 <p style="text-align:left;">我们还可以采用一些很酷的方法来进一步定制它，可以使用任何内置的过渡预设或使用 CSS 缓动功能定义，这个可以自行决定。 <br></p> 
 <h3><strong>最后的想法</strong></h3> 
 <p style="text-align:left;">这绝不是 VueUse的完整指南。这些只是我发现 VueUse许多函数中最有趣的一些函数而已。 </p> 
 <p style="text-align:left;">我喜欢所有这些实用函数，它可以帮助我们加速开发项目，提升开发效率，因为它们中的每一个都是为了解决特定但常见的用例而设计的。 </p> 
 <p style="text-align:center;">Node 社群<br></p> 
 <p style="text-align:left;">我组建了一个氛围特别好的 Node.js 社群，里面有很多 Node.js小伙伴，如果你对Node.js学习感兴趣的话（后续有计划也可以），我们可以一起进行Node.js相关的交流、学习、共建。下方加 考拉 好友回复「Node」即可。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/a6/e5/Ja47ookb_o.png" alt="2dbe6b3a191c5e7ee4c608b21fe98235.png"></p> 
 <p style="text-align:right;">  <strong> “分享、点赞、在看” 支持一波👍</strong></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/250797f6b323553595a2013350c164a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RS485/RS232串口通信实现源码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/48a988187cfd49d80649c9ead67f6a7f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">变分自编码器（VAE）（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>