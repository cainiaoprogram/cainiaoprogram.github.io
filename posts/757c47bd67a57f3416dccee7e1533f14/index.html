<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单链表的构造及其功能 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="单链表的构造及其功能" />
<meta property="og:description" content="定义 线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表节点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。
单链表的优缺点 优点 ： 1、增加、删除元素方便，不用大量移动元素 2、不需要空间提前开辟，易扩充 缺点 ： 1、不支持随机存储 2、开辟了指针域，会浪费额外的空间 单链表的初始化 LinkList InitList(){ //初始化 LinkList L = (LinkList)malloc(sizeof(LNode)); //C开辟动态内存 //L = new (LNode); //C&#43;&#43;开辟动态内存 if (L == NULL){ return NULL; //内存不足，分配失败 } L-&gt;next = NULL; //将L的指针域设为空 return L; } 单链表的头插法的构建 优点：可用于链表的逆置
LinkList List_Front_Insert(LinkList L){ //初始化头插 printf(&#34;请输入数据(-1结束)：&#34;); //连续输入数据，-1结束 int n; LNode* newNode; //新节点 scanf(&#34;%d&#34;, &amp;n); while (n != -1){ newNode = (LNode*)malloc(sizeof(LNode)); //为新节点开辟空间 newNode-&gt;data = n; newNode-&gt;next = L-&gt;next; L-&gt;next = newNode; scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/757c47bd67a57f3416dccee7e1533f14/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T19:45:59+08:00" />
<meta property="article:modified_time" content="2023-03-15T19:45:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单链表的构造及其功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h3 style="">定义</h3> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">线性表的链式存储又称</span><span class="kdocs-color" style="color:#DB7800;"><span class="kdocs-bold" style="font-weight:bold;">单链表</span></span><span class="kdocs-color" style="color:#080F17;"><span class="kdocs-bold" style="font-weight:bold;">，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表节点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:377px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:66.047745%;height:0;"> 
    <img src="https://images2.imgbox.com/1e/eb/UgPyuR2Z_o.png" style="margin-left:;display:block;width:377px;margin-top:-66.047745%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <blockquote class="kdocs-blockquote" style=""> 
  <span class="kdocs-bold" style="font-weight:bold;">单链表的优缺点</span> 
  <br> 
  <span class="kdocs-color" style="color:#DA326B;"><span class="kdocs-bold" style="font-weight:bold;">优点</span></span> 
  <span class="kdocs-bold" style="font-weight:bold;">：</span> 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">1、增加、删除元素方便，不用大量移动元素</span> 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">2、不需要空间提前开辟，易扩充</span> 
  <br> 
  <span class="kdocs-color" style="color:#DA326B;"><span class="kdocs-bold" style="font-weight:bold;">缺点</span></span> 
  <span class="kdocs-bold" style="font-weight:bold;">：</span> 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">1、不支持随机存储</span> 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">2、开辟了指针域，会浪费额外的空间</span> 
  <br> 
 </blockquote> 
 <h3 style="">单链表的初始化</h3> 
 <pre class="kdocs-cpp"><code class="language-cpp">LinkList InitList(){ //初始化
    LinkList L = (LinkList)malloc(sizeof(LNode)); //C开辟动态内存
    //L = new (LNode);  //C++开辟动态内存
    if (L == NULL){
        return NULL;    //内存不足，分配失败
    }
    L-&gt;next = NULL; //将L的指针域设为空
    return L;
}</code></pre> 
 <p style=""></p> 
 <h3 style="">单链表的头插法的构建</h3> 
 <p style=""><span class="kdocs-color" style="color:#DA326B;"><span class="kdocs-bold" style="font-weight:bold;">优点：可用于链表的逆置</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:857px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:40.49008%;height:0;"> 
    <img src="https://images2.imgbox.com/9a/ff/CtnbFvAu_o.png" style="margin-left:;display:block;width:857px;margin-top:-40.49008%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">LinkList List_Front_Insert(LinkList L){ //初始化头插
    printf("请输入数据(-1结束)：");  //连续输入数据，-1结束
    int n;
    LNode* newNode;  //新节点

    scanf("%d", &amp;n);

    while (n != -1){
        newNode = (LNode*)malloc(sizeof(LNode));  //为新节点开辟空间
        newNode-&gt;data = n;
        newNode-&gt;next = L-&gt;next;
        L-&gt;next = newNode;

        scanf("%d", &amp;n);
    }
    return L;
}</code></pre> 
 <p style=""></p> 
 <h3 style="">单链表的尾插法的构建</h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1062px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:31.261772%;height:0;"> 
    <img src="https://images2.imgbox.com/63/dc/w4Pm4sUI_o.png" style="margin-left:;display:block;width:1062px;margin-top:-31.261772%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">LinkList List_Tail_Insert(LinkList L){ //初始化尾插
    printf("请输入数据(-1结束)：");
    int n;
    LNode* newNode;  //新节点
    LNode* tail = L; //尾结点

    scanf("%d", &amp;n);
    while ( n!=-1 ){
        newNode = (LNode*)malloc(sizeof(LNode)); //为新节点开辟空间
        newNode-&gt;data = n;
        tail-&gt;next = newNode;
        tail = newNode;
        
        scanf("%d", &amp;n);
    }
    tail-&gt;next = NULL;  //尾结点指向空，很重要
    return L;
}</code></pre> 
 <p style=""></p> 
 <h3 style="">单链表的查找操作</h3> 
 <blockquote class="kdocs-blockquote" style=""> 
  <span class="kdocs-bold" style="font-weight:bold;">从单链表的第一个结点开始，由前往后依次比较表中各节点数据域的值，若某结点数据域的值等于给定值elem，则返回该节点的指针；否则该链表中没有该元素，返回NULL。</span> 
 </blockquote> 
 <pre class="kdocs-cpp"><code class="language-cpp">LNode* LocatElem(LinkList L, ElemType elem){ //查找
    LNode* p = L-&gt;next;
    while (p != NULL &amp;&amp; p-&gt;data != elem){
        p = p-&gt;next;
    }
    return p;  //返回该结点
}</code></pre> 
 <p style=""></p> 
 <h3 style="">单链表的插入操作</h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:687px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:57.059677%;height:0;"> 
    <img src="https://images2.imgbox.com/e2/d4/3BC75BO8_o.png" style="margin-left:;display:block;width:687px;margin-top:-57.059677%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">LinkList ListInsert(LinkList L, int index, ElemType elem){ //插入
    LNode* newNode = (LNode*)malloc(sizeof(LNode));
    newNode-&gt;data = elem;  //待插入的结点

    if (index == 1){  //类似头插
        newNode-&gt;next = L-&gt;next;
        L-&gt;next = newNode;
        return L;
    }

    LNode* p = getElem(L, index - 1);  //找到待插入位置的前一个结点
    newNode-&gt;next = p-&gt;next;
    p-&gt;next = newNode;

    return L;
}</code></pre> 
 <p style=""></p> 
 <h3 style="">单链表的删除操作</h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:754px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:42.97082%;height:0;"> 
    <img src="https://images2.imgbox.com/a0/64/VTnMqYHe_o.png" style="margin-left:;display:block;width:754px;margin-top:-42.97082%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">LinkList ListDelete(LinkList L, int index){  //删除
    //方法一：通过获取index前面一个元素的结点，指向index后面一个元素的结点
    //方法二：
    LNode* front = L-&gt;next; //当前结点的前一个
    LNode* cur = NULL;      //当前结点

    if (index == 1){  //删除第一个结点
        L-&gt;next = front-&gt;next;
        free(front);
        return L;
    }

    while (index &gt; 2){  //遍历寻找当前结点的前一个结点
        front = front-&gt;next;
        index--;
    }
    cur = front-&gt;next;
    front-&gt;next = cur-&gt;next;
    free(cur);  //释放被删除结点的空间
    return L;
}</code></pre> 
 <p style=""></p> 
 <h3 style="">单链表的销毁操作</h3> 
 <pre class="kdocs-cpp"><code class="language-cpp">LinkList ListDestory(LinkList L){
    L-&gt;next = NULL;  //将头节点的next置空
    free(L);  //释放头节点的空间
    return L;
}</code></pre> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">单链表的输出操作</h3> 
 <pre class="kdocs-cpp"><code class="language-cpp">void printList(LinkList L){  //输出
    LNode* p = L-&gt;next;
    while (p != NULL){
        printf("%d ", p-&gt;data);
        p = p-&gt;next;
    }
    printf("\n");
}</code></pre> 
 <p style=""></p> 
 <h3 style="">单链表的取值操作</h3> 
 <blockquote class="kdocs-blockquote" style=""> 
  <span class="kdocs-bold" style="font-weight:bold;">在单链表中从第一个结点出发，顺指针的next域逐个往下搜索，直到找到第index个结点位置，否在返回最后一个指针的域NULL。</span> 
 </blockquote> 
 <pre class="kdocs-cpp"><code class="language-cpp">LNode* getElem(LinkList L, int index){//取值
    LNode* p = L-&gt;next;
    int i = 1;
    if (index == 0) {  //返回头节点
        return L;
    }
    if (index &lt; 0){  //index不合法
        return NULL;
    }
    while (i &lt; index &amp;&amp; p){  //i小于index，且p不为空
        p = p-&gt;next;
        i++;
    }
    
    return p;
}</code></pre> 
 <p style=""></p> 
 <h3 style="">源码</h3> 
 <blockquote class="kdocs-blockquote" style="">
   Linklist.h 
 </blockquote> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;malloc.h&gt;

typedef int ElemType;
typedef struct LNode{
    ElemType data;
    struct LNode* next; 
}LNode, *LinkList;


void menu(); //菜单
LinkList InitList(); //初始化
void printList(LinkList L); //输出
LNode* getElem(LinkList L, int index); //取值
LNode* LocatElem(LinkList L, ElemType elem); //查找
LinkList ListInsert(LinkList L, int index, ElemType elem); //插入
LinkList ListDelete(LinkList L, int index); //删除
LinkList ListDestory(LinkList L); //销毁
LinkList List_Tail_Insert(LinkList L); //尾插
LinkList List_Front_Insert(LinkList L);//头插</code></pre> 
 <p style=""></p> 
 <blockquote class="kdocs-blockquote" style="">
   Linklist.c 
 </blockquote> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include "Linklist.h"


void menu(){
    printf("&lt; G取值  P打印  L查找  I插入  D删除  X销毁  Q退出 &gt;\n");
    printf("请选择您的操作：");
}

LinkList InitList(){ //初始化
    LinkList L = (LinkList)malloc(sizeof(LNode)); //C开辟动态内存
    //L = new (LNode);  //C++开辟动态内存
    if (L == NULL){
        return NULL;    //内存不足，分配失败
    }
    L-&gt;next = NULL; //将L的指针域设为空
    return L;
}

LNode* getElem(LinkList L, int index){//取值
    LNode* p = L-&gt;next;
    int i = 1;
    if (index == 0) {  //返回头节点
        return L;
    }
    if (index &lt; 0){  //index不合法
        return NULL;
    }
    while (i &lt; index &amp;&amp; p){  //i小于index，且p不为空
        p = p-&gt;next;
        i++;
    }
    
    return p;
}

void printList(LinkList L){  //输出
    LNode* p = L-&gt;next;
    while (p != NULL){
        printf("%d ", p-&gt;data);
        p = p-&gt;next;
    }
    printf("\n");
}

LNode* LocatElem(LinkList L, ElemType elem){ //查找
    LNode* p = L-&gt;next;
    while (p != NULL &amp;&amp; p-&gt;data != elem){
        p = p-&gt;next;
    }
    return p;  //返回该结点
}
LinkList ListInsert(LinkList L, int index, ElemType elem){ //插入
    LNode* newNode = (LNode*)malloc(sizeof(LNode));
    newNode-&gt;data = elem;  //待插入的结点

    if (index == 1){  //类似头插
        newNode-&gt;next = L-&gt;next;
        L-&gt;next = newNode;
        return L;
    }

    LNode* p = getElem(L, index - 1);  //找到待插入位置的前一个结点
    newNode-&gt;next = p-&gt;next;
    p-&gt;next = newNode;

    return L;
}

LinkList ListDelete(LinkList L, int index){  //删除
    //方法一：通过获取index前面一个元素的结点，指向index后面一个元素的结点
    //方法二：
    LNode* front = L-&gt;next; //当前结点的前一个
    LNode* cur = NULL;      //当前结点

    if (index == 1){
        L-&gt;next = front-&gt;next;
        free(front);
        return L;
    }

    while (index &gt; 2){  //遍历寻找当前结点的前一个结点
        front = front-&gt;next;
        index--;
    }
    cur = front-&gt;next;
    front-&gt;next = cur-&gt;next;
    free(cur);
    return L;
}

LinkList ListDestory(LinkList L){
    L-&gt;next = NULL;
    free(L);
    return L;
}

LinkList List_Front_Insert(LinkList L){ //初始化头插
    printf("请输入数据(-1结束)：");
    int n;
    LNode* newNode;  //新节点

    scanf("%d", &amp;n);
    while (n != -1){
        newNode = (LNode*)malloc(sizeof(LNode));
        newNode-&gt;data = n;
        newNode-&gt;next = L-&gt;next;
        L-&gt;next = newNode;

        scanf("%d", &amp;n);
    }
    return L;
}

LinkList List_Tail_Insert(LinkList L){ //初始化尾插
    printf("请输入数据(-1结束)：");
    int n;
    LNode* newNode;  //新节点
    LNode* tail = L; //尾结点

    scanf("%d", &amp;n);
    while ( n!=-1 ){
        newNode = (LNode*)malloc(sizeof(LNode));
        newNode-&gt;data = n;
        tail-&gt;next = newNode;
        tail = newNode;
        
        scanf("%d", &amp;n);
    }
    tail-&gt;next = NULL;
    return L;
}</code></pre> 
 <p style=""></p> 
 <blockquote class="kdocs-blockquote" style="">
   test.c 
 </blockquote> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include "Linklist.h"

int main(){
    LinkList L = InitList(); // 初始化
    L = List_Tail_Insert(L); //数据尾插
    //L = List_Front_Insert(L); //数据头插
    
    while (1){
        menu();
        char key;
        int n = 0;
        int index = 0;
        LNode* p = NULL;
        getchar();  //释放scanf读取的\n
        scanf("%c", &amp;key);

        switch(key){
            case 'G':
                printf("要查找第几个元素：");
                scanf("%d", &amp;n);
                p = getElem(L, n);
                if (p != NULL){
                    printf("%d\n", p-&gt;data);
                }
                else{
                    printf("输入有误！\n");
                }
                break;

            case 'P':
                printList(L);
                break;

            case 'L':
                printf("要查找的元素：");
                scanf("%d", &amp;n);
                p = LocatElem(L, n);
                if (p != NULL){
                    printf("找到了该元素：%d\n", p-&gt;data);
                }
                else{
                    printf("没有该元素\n");
                }
                break;

            case 'I':
                printf("请输入插入的下标和数：");
                scanf("%d %d", &amp;index, &amp;n);
                L = ListInsert(L, index, n);
                printf("插入成功！\n");
                break;

            case 'D':
                printf("要删除第几个元素：");
                scanf("%d", &amp;n);
                p = ListDelete(L, n);
                if (p != NULL){
                    printf("删除成功！\n");
                }
                else{
                    printf("删除失败！\n");
                }
                break;

            case 'X':
                L = ListDestory(L);
                if (L == NULL){
                    printf("链表已经销毁！\n");
                }
                else{
                    printf("链表销毁失败！\n");
                }
                break;

            case 'Q':
                printf("退出成功！");
                exit(0);
        }
    }
    system("pause");
}</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9af082651c174e5bf6a04fa264319651/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用python实现矩阵</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7c7c837ba35ab9ef66b3a9b69e4678d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用百度地图API和echarts时遇到的一些问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>