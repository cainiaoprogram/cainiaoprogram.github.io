<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>BGP/MPLS IP VPF(N) 实验（ensp) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="BGP/MPLS IP VPF(N) 实验（ensp)" />
<meta property="og:description" content="实验拓扑图 如图1所示，本次实验使用了6台路由器（R1-R6），其中R3、R4、R5作为运营商网络中的P或PE路由器，R1、R2作为VPN客户端（CE）路由器，R6作为VPN客户端要访问的目标路由器。运营商网络使用OSPF作为IGP协议，并开启MPLS LDP功能。PE路由器使用MP-BGP协议发布VPN路由信息，并创建两个VRF实例（1和2）对应两个VPN客户。CE路由器使用静态路由与PE路由器互通。
实验目的和需求 本次实验旨在通过以下几个方面达到以下目的：
了解MPLS VPN的基本原理和配置方法，包括MPLS LDP、MP-BGP、VRF、RD、RT等概念和功能.。 掌握VRF、RD和RT的作用和配置方法，包括如何创建VRF实例、如何指定RD和RT值、如何将接口划分到VRF中等。
验证MPLS VPN的功能和效果，包括如何测试不同VPN之间的连通性和隔离性。
实验步骤 1. 配置IP地址和路由协议
- 在CE、PE和P路由器上配置IP地址和路由协议，使得各个路由器之间可以互相ping通
- 在PE路由器上配置loopback0接口，作为BGP的源地址
- 在P路由器上配置MPLS LDP，使得P路由器之间可以建立标签交换路径
2. 配置VRF和RD
- 在PE路由器上创建两个VRF实例，分别命名为1和2，分别对应两个VPN客户
- 在每个VRF实例下配置RD值，使得同一VPN内的IP地址可以区分开来
- 在PE路由器上将连接CE的接口划分到相应的VRF中，使得不同VPN之间可以隔离
3. 配置MP-BGP和RT
- 在PE路由器上配置MP-BGP，并激活VPNv4邻居会话，使得PE之间可以交换VPN路由信息
- 在每个VRF实例下配置RT值，使得不同VPN之间可以根据需要导入或导出路由信息
- 在PE和CE之间配置相应的动态或静态路由协议，并根据需要重新分发路由信息
1. 配置IP地址和路由协议 在CE、PE和P路由器上配置IP地址和路由协议，使得各个路由器之间可以互相ping通
在PE路由器上配置loopback0接口，作为BGP的源地址
在P路由器上配置MPLS LDP，使得P路由器之间可以建立标签交换路径
(首先要在系统界面下开启mpls ldp）
在R3、R4、R5上开启MPLS LDP功能，并配置OSPF协议，如下：
r3 r4 r5上操作 [r3][r4][r5]mpls [r3][r4][r5]mpls ldp [r3][r4][r5]qui [r3] ospf 1 router-id 3.3.3.3 area 0.0.0.0 # interface GigabitEthernet0/0/2 ip address 34.1.1.3 255.255.255.0 ospf enable 1 area 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dbc963c860af1e5106d2e3bf01ee47f0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-21T22:09:38+08:00" />
<meta property="article:modified_time" content="2023-08-21T22:09:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">BGP/MPLS IP VPF(N) 实验（ensp)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>实验拓扑图</h2> 
<h2><img alt="" height="668" src="https://images2.imgbox.com/62/b5/9NFuPex2_o.png" width="1200"></h2> 
<p>         如图1所示，本次实验使用了6台路由器（R1-R6），其中R3、R4、R5作为运营商网络中的P或PE路由器，R1、R2作为VPN客户端（CE）路由器，R6作为VPN客户端要访问的目标路由器。运营商网络使用OSPF作为IGP协议，并开启MPLS LDP功能。PE路由器使用MP-BGP协议发布VPN路由信息，并创建两个VRF实例（1和2）对应两个VPN客户。CE路由器使用静态路由与PE路由器互通。</p> 
<h2>实验目的和需求</h2> 
<p>本次实验旨在通过以下几个方面达到以下目的：</p> 
<p>了解MPLS VPN的基本原理和配置方法，包括MPLS LDP、MP-BGP、VRF、RD、RT等概念和功能.。 </p> 
<p>掌握VRF、RD和RT的作用和配置方法，包括如何创建VRF实例、如何指定RD和RT值、如何将接口划分到VRF中等。<br> 验证MPLS VPN的功能和效果，包括如何测试不同VPN之间的连通性和隔离性。</p> 
<p>    </p> 
<h2>实验步骤</h2> 
<h2></h2> 
<p>1. 配置IP地址和路由协议</p> 
<p>- 在CE、PE和P路由器上配置IP地址和路由协议，使得各个路由器之间可以互相ping通<br> - 在PE路由器上配置loopback0接口，作为BGP的源地址<br> - 在P路由器上配置MPLS LDP，使得P路由器之间可以建立标签交换路径</p> 
<p>2. 配置VRF和RD</p> 
<p>- 在PE路由器上创建两个VRF实例，分别命名为1和2，分别对应两个VPN客户<br> - 在每个VRF实例下配置RD值，使得同一VPN内的IP地址可以区分开来<br> - 在PE路由器上将连接CE的接口划分到相应的VRF中，使得不同VPN之间可以隔离</p> 
<p>3. 配置MP-BGP和RT</p> 
<p>- 在PE路由器上配置MP-BGP，并激活VPNv4邻居会话，使得PE之间可以交换VPN路由信息<br> - 在每个VRF实例下配置RT值，使得不同VPN之间可以根据需要导入或导出路由信息<br> - 在PE和CE之间配置相应的动态或静态路由协议，并根据需要重新分发路由信息</p> 
<h3>1. 配置IP地址和路由协议</h3> 
<p>在CE、PE和P路由器上配置IP地址和路由协议，使得各个路由器之间可以互相ping通</p> 
<p>在PE路由器上配置loopback0接口，作为BGP的源地址<br> 在P路由器上配置MPLS LDP，使得P路由器之间可以建立标签交换路径</p> 
<p>(首先要在系统界面下开启mpls ldp）</p> 
<p>在R3、R4、R5上开启MPLS LDP功能，并配置OSPF协议，如下：</p> 
<pre><code>r3 r4 r5上操作

[r3][r4][r5]mpls
[r3][r4][r5]mpls ldp
[r3][r4][r5]qui</code></pre> 
<pre><code>[r3]
ospf 1 router-id 3.3.3.3 
 area 0.0.0.0
#
interface GigabitEthernet0/0/2
 ip address 34.1.1.3 255.255.255.0 
 ospf enable 1 area 0.0.0.0 
 mpls
 mpls ldp
interface LoopBack0
 ip address  4.4.4.4 255.255.255.255 
 ospf enable 1 area 0.0.0.0</code></pre> 
<pre><code>[r4]
ospf 1 router-id 4.4.4.4 
 area 0.0.0.0
#
interface GigabitEthernet0/0/2
 ip address 34.1.1.4 255.255.255.0 
 ospf enable 1 area 0.0.0.0 
 mpls
 mpls ldp
#
interface GigabitEthernet0/0/1
 ip address 45.1.1.4 255.255.255.0 
 ospf enable 1 area 0.0.0.0
 mpls
 mpls ldp
interface LoopBack0
 ip address 4.4.4.4 255.255.255.255 
 ospf enable 1 area 0.0.0.0</code></pre> 
<pre><code>[r5]
ospf 1 router-id 5.5.5.5
 area 0.0.0.0 
interface GigabitEthernet0/0/1
 ip address 45.1.1.5 255.255.255.0 
 ospf enable 1 area 0.0.0.0  
 mpls
 mpls ldp
interface LoopBack0
 ip address 5.5.5.5 255.255.255.255 
 ospf enable 1 area 0.0.0.0</code></pre> 
<h3>2. 配置VRF和RD</h3> 
<p>在PE路由器上创建两个VRF实例，分别命名为1和2，分别对应两个VPN客户，在另外一个PE路由器上创建一个VRF实例，命名为1，对应两个VPN用户都要访问的目的地。并且在每个VRF实例下配置RD值，使得同一VPN内的IP地址可以区分开来。</p> 
<p>在R3上创建两个VRF实例，并指定RD值，如下：</p> 
<pre><code>[r3]
ip vpn-instance 1
  route-distinguisher 1:1
#
ip vpn-instance 2                             
  route-distinguisher 2:2
</code></pre> 
<p>在R5上创建一个VRF实例，并指定RD值，如下： </p> 
<pre><code>[r5]
ip vpn-instance 1
  route-distinguisher 3:3
</code></pre> 
<p> 在PE路由器上将连接CE的接口划分到相应的VRF中，使得不同VPN之间可以隔离</p> 
<p>在R3上将连接R1和R2的接口划分到相应的VRF中，如下：</p> 
<pre><code>[r3]
interface GigabitEthernet0/0/0
 ip binding vpn-instance 1                
 ip address 192.168.1.254 255.255.255.0 
#
interface GigabitEthernet0/0/1
 ip binding vpn-instance 2
 ip address 192.168.3.254 255.255.255.0 
</code></pre> 
<p>在R5上将连接R6的接口划分到VRF中，如下：</p> 
<pre><code>[r5]
interface GigabitEthernet0/0/0
 ip binding vpn-instance 1
 ip address 56.1.1.5 255.255.255.0 </code></pre> 
<h3>3. 配置MP-BGP和RT</h3> 
<p> 在PE路由器上配置MP-BGP，并激活VPNv4邻居会话，使得PE之间可以交换VPN路由信息</p> 
<p>在R3和R5上配置MP-BGP，并激活VPNv4邻居会话，如下：</p> 
<pre><code>[r3]
bgp 35
 router-id 3.3.3.3
 undo default ipv4-unicast
 peer 5.5.5.5 as-number 35 
 peer 5.5.5.5 connect-interface LoopBack0
 ipv4-family vpnv4
  policy vpn-target
  peer 5.5.5.5 enable</code></pre> 
<pre><code>[r5]
bgp 35
 router-id 5.5.5.5
 undo default ipv4-unicast
 peer 3.3.3.3 as-number 35 
 peer 3.3.3.3 connect-interface LoopBack0                                       
 ipv4-family vpnv4
  policy vpn-target
  peer 3.3.3.3 enable
</code></pre> 
<p> 在每个VRF实例下配置RT值，使得不同VPN之间可以根据需要导入或导出路由信息</p> 
<p>在R3上为每个VRF实例配置RT值，如下：</p> 
<pre><code>[r3]
ip vpn-instance 1
  vpn-target 1:1 export-extcommunity
  vpn-target 1:1 import-extcommunity
#
ip vpn-instance 2                             
  vpn-target 2:2 export-extcommunity
  vpn-target 2:2 import-extcommunity</code></pre> 
<p>在R5上为VRF实例配置RT值，如下： </p> 
<pre><code>[r5]
ip vpn-instance 1
  route-distinguisher 3:3
  vpn-target 1:1 2:2 export-extcommunity
  vpn-target 3:3 1:1 2:2 import-extcommunity</code></pre> 
<p><br> 在PE和CE之间配置相应的动态或静态路由协议（这里用BGP协议举例），并根据需要重新分发路由信息</p> 
<p>R1和R2,与R3配置BGP邻居关系，并宣告自己的路由信息</p> 
<pre><code>[r1]
bgp 1
 peer 192.168.1.254 as-number 35 
  network 1.1.1.1 255.255.255.255         
  network 192.168.1.0 
</code></pre> 
<pre><code>[r2]
bgp 2
 peer 192.168.3.254 as-number 35 
  network 2.2.2.2 255.255.255.255         
  network 192.168.3.0 </code></pre> 
<pre><code>[r3]
bgp 35
 ipv4-family vpn-instance 1 
  peer 192.168.1.1 as-number 1 
 #
 ipv4-family vpn-instance 2 
  peer 192.168.3.1 as-number 2 </code></pre> 
<p>R5和R6建立BGP邻居关系，并宣告自己的路由信息</p> 
<pre><code>[r6]
bgp 6
 peer 192.168.2.254 as-number 35 
  network 6.6.6.6 255.255.255.255 
  network 192.168.2.0                     </code></pre> 
<pre><code>[r5]
bgp 35        
 ipv4-family vpn-instance 1 
  peer 192.168.2.1 as-number 6 </code></pre> 
<p></p> 
<h3>实验结果</h3> 
<p>1. 验证MPLS VPN的连通性</p> 
<p>在CE上使用ping或tracer命令测试不同VPN之间的连通性，观察结果是否符合预期</p> 
<pre><code>&lt;r1&gt;ping 192.168.2.1
  PING 192.168.2.1: 56  data bytes, press CTRL_C to break
    Reply from 192.168.2.1: bytes=56 Sequence=1 ttl=252 time=50 ms
    Reply from 192.168.2.1: bytes=56 Sequence=2 ttl=252 time=40 ms

&lt;r1&gt;ping 6.6.6.6
  PING 6.6.6.6: 56  data bytes, press CTRL_C to break
    Reply from 6.6.6.6: bytes=56 Sequence=1 ttl=252 time=40 ms
    Reply from 6.6.6.6: bytes=56 Sequence=2 ttl=252 time=40 ms

&lt;r1&gt;tracert 192.168.2.1
 traceroute to  192.168.2.1(192.168.2.1), max hops: 30 ,packet length: 40,press CTRL_C to break 
 1 192.168.1.254 20 ms  20 ms  30 ms 
 2 34.1.1.4 40 ms  30 ms  30 ms 
 3 192.168.2.254 &lt; AS=6 &gt; 40 ms  30 ms  40 ms 
 4 192.168.2.1 &lt; AS=6 &gt; 40 ms  40 ms  30 ms</code></pre> 
<pre><code>&lt;r2&gt;ping 192.168.2.1
  PING 192.168.2.1: 56  data bytes, press CTRL_C to break
    Reply from 192.168.2.1: bytes=56 Sequence=1 ttl=252 time=30 ms
    Reply from 192.168.2.1: bytes=56 Sequence=2 ttl=252 time=50 ms


&lt;r2&gt;ping 6.6.6.6    
  PING 6.6.6.6: 56  data bytes, press CTRL_C to break
    Reply from 6.6.6.6: bytes=56 Sequence=1 ttl=252 time=30 ms
    Reply from 6.6.6.6: bytes=56 Sequence=2 ttl=252 time=30 ms

&lt;r2&gt;tracert 6.6.6.6
 traceroute to  6.6.6.6(6.6.6.6), max hops: 30 ,packet length: 40,press CTRL_C to break 
 1 192.168.3.254 20 ms  20 ms  20 ms 
 2 34.1.1.4 30 ms  20 ms  30 ms 
 3 192.168.2.254 &lt; AS=6 &gt; 40 ms  30 ms  30 ms 
 4 192.168.2.1 &lt; AS=6 &gt; 40 ms  30 ms  50 ms 
</code></pre> 
<p></p> 
<pre><code>
&lt;r6&gt;ping 1.1.1.1
  PING 1.1.1.1: 56  data bytes, press CTRL_C to break
    Reply from 1.1.1.1: bytes=56 Sequence=1 ttl=252 time=40 ms
    Reply from 1.1.1.1: bytes=56 Sequence=2 ttl=252 time=50 ms

&lt;r6&gt;ping 2.2.2.2
  PING 2.2.2.2: 56  data bytes, press CTRL_C to break
    Reply from 2.2.2.2: bytes=56 Sequence=1 ttl=252 time=40 ms
    Reply from 2.2.2.2: bytes=56 Sequence=2 ttl=252 time=40 ms

&lt;r6&gt;ping 192.168.1.1
  PING 192.168.1.1: 56  data bytes, press CTRL_C to break
    Reply from 192.168.1.1: bytes=56 Sequence=1 ttl=252 time=40 ms
    Reply from 192.168.1.1: bytes=56 Sequence=2 ttl=252 time=40 ms

&lt;r6&gt;ping 192.168.3.1
  PING 192.168.3.1: 56  data bytes, press CTRL_C to break
    Reply from 192.168.3.1: bytes=56 Sequence=1 ttl=252 time=30 ms
    Reply from 192.168.3.1: bytes=56 Sequence=2 ttl=252 time=30 ms</code></pre> 
<p>2. 验证MPLS VPN的隔离性</p> 
<p>- 在CE上使用ping或traceroute命令测试不同VPN之间的隔离性，观察结果是否符合预期<br>  </p> 
<pre><code>&lt;r1&gt;ping 192.168.3.1
  PING 192.168.3.1: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out

&lt;r1&gt;ping  3.3.3.3
  PING 3.3.3.3: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out</code></pre> 
<pre><code>&lt;r2&gt;ping 1.1.1.1
  PING 1.1.1.1: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out

&lt;r2&gt;ping 192.168.1.1   
  PING 192.168.1.1: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out</code></pre> 
<p> BGP/MPLS IP VPN的优点有：</p> 
<p></p> 
<ul><li>提高网络性能，利用MPLS的快速转发机制，减少报文的路由查找次数，降低网络延迟和抖动。</li><li>节省地址空间，利用路由区分符(RD)和路由标记(RT)实现不同VPN之间的地址空间隔离，允许VPN使用重叠的私有地址，避免了公网地址的浪费。</li><li>增强网络安全，利用MPLS的标签交换机制，在公网上建立隧道，实现VPN报文的封装和解封装，保护VPN报文不被窃听或篡改。</li><li>简化网络管理，利用BGP的多协议扩展(MP-BGP)实现VPN路由的发布和维护，避免了复杂的隧道配置和维护，提高了网络可扩展性和灵活性。</li></ul> 
<p>BGP/MPLS IP VPN的缺点有：</p> 
<ul><li>增加网络复杂度，需要在PE和P路由器上配置IP CEF、IGP、MPLS、MP-BGP等多种协议，并在PE路由器上创建和管理多个VPN实例(VRF)，增加了网络设备的负载和配置难度。</li><li>需要额外的设备支持，需要在PE和P路由器上支持MPLS和MP-BGP等功能，并在CE路由器上支持与PE之间的动态或静态路由协议，增加了网络设备的成本和兼容性问题。</li><li>存在标签栈溢出等风险，如果骨干网中存在多层MPLS隧道或者跨域VPN场景，可能导致报文中携带过多的标签，超过设备的处理能力或MTU限制，造成报文丢失或分片。</li></ul> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d828c3df79e05d17711b061fd0f04dd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用QOpenGLWidget(调用GPU)渲染QImage加载的图片</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e096c7617946f130f0d8a2d52e2d36c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">gRPC 客户端调用服务端需要连接池吗？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>