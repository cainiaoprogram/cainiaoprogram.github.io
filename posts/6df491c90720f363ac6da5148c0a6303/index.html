<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue中前端导出word文件 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue中前端导出word文件" />
<meta property="og:description" content="很多时候在工作中会碰到完全由前端导出word文件的需求，因此特地记录一下比较常用的几种方式。
一、提供一个word模板 该方法提供一个word模板文件，数据通过参数替换的方式传入word文件中，灵活性较差，适用于简单的文件导出。需要依赖：docxtemplater、file-saver、jszip-utils、pizzip。
javascript 复制代码 import Docxtemplater from &#34;docxtemplater&#34;; import { saveAs } from &#34;file-saver&#34;; import JSZipUtils from &#34;jszip-utils&#34;; import PizZip from &#34;pizzip&#34;; export function downloadWithTemplate(path, data, fileName) { JSZipUtils.getBinaryContent(path, (error, content) =&gt; { if (error) throw error; const zip = new PizZip(content); const doc = new Docxtemplater().loadZip(zip); doc.setData({ ...data.form, // 循环项参数 list: data.list, outsideList: data.outsideList, }); try { doc.render(); } catch (error) { const e = { message: error." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6df491c90720f363ac6da5148c0a6303/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-25T18:30:11+08:00" />
<meta property="article:modified_time" content="2023-09-25T18:30:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue中前端导出word文件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>很多时候在工作中会碰到完全由前端导出word文件的需求，因此特地记录一下比较常用的几种方式。</strong></p> 
<h4><a id="word_2"></a>一、提供一个word模板</h4> 
<p>该方法提供一个word模板文件，数据通过参数替换的方式传入word文件中，灵活性较差，适用于简单的文件导出。需要依赖：<strong>docxtemplater、file-saver、jszip-utils、pizzip</strong>。</p> 
<p><img src="https://images2.imgbox.com/42/d9/xxVGozwo_o.png" alt="在这里插入图片描述"></p> 
<pre><code>javascript
复制代码
import Docxtemplater from "docxtemplater";
import { saveAs } from "file-saver";
import JSZipUtils from "jszip-utils";
import PizZip from "pizzip";

export function downloadWithTemplate(path, data, fileName) {
  JSZipUtils.getBinaryContent(path, (error, content) =&gt; {
    if (error) throw error;

    const zip = new PizZip(content);
    const doc = new Docxtemplater().loadZip(zip);
    doc.setData({
      ...data.form,
      // 循环项参数
      list: data.list,
      outsideList: data.outsideList,
    });

    try {
      doc.render();
    } catch (error) {
      const e = {
        message: error.message,
        name: error.name,
        stack: error.stack,
        properties: error.properties,
      };
      ElMessage.error("文件格式有误!");
      throw error;
    }
    const out = doc.getZip().generate({
      type: "blob",
      mimeType:
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    });
    saveAs(out, fileName);
  });
}

let data = {
    form: {
      title: "这是word标题",
      test: "这是表单1的数据",
      test1: "111",
      test2: 222,
      test3: 333,
    },
    outsideList: [
      {
        list: [
          {
            index: 0,
            table: "表格第一项",
            table1: "表格第二项",
            table2: "表格第三项",
          },
          {
            index: 1,
            table: "表格第一项",
            table1: "表格第二项",
            table2: "表格第三项",
          },
        ],
      },
      {
        list: [
          {
            index: 0,
            table: "表格第一项",
            table1: "表格第二项",
            table2: "表格第三项",
          },
          {
            index: 1,
            table: "表格第一项",
            table1: "表格第二项",
            table2: "表格第三项",
          },
        ],
      },
    ],
  };
  
  downloadWithTemplate("template.docx", data, "模板word.docx")
  
</code></pre> 
<p>调用downloadWithTemplate方法即可导出如下文件: <img src="https://images2.imgbox.com/7a/db/R3Fb9sHO_o.png" alt="在这里插入图片描述"><br> <strong>注: 上述方法中的path参数为你在vue项目中存放公共文件的位置，在vue2中为static文件夹下，在vue3中为public文件夹下。</strong></p> 
<h4><a id="htmlword_102"></a>二、根据html代码转换为word文件(推荐)</h4> 
<p>顾名思义，这个方法就是将我们在页面上书写的html代码直接转换成word文件，这也是我最推荐的一种方法，因为大部分的样式可控，且毕竟是我们较为熟悉的方式。需要插件: <strong>html-docx-js-typescript、file-saver。</strong></p> 
<pre><code>xml
复制代码
import { saveAs } from "file-saver";
import { asBlob } from "html-docx-js-typescript";

 export function downloadWordWithHtmlString(html, name) {
  let htmlString = `
  &lt;!DOCTYPE html&gt;
  &lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    ${html}
  &lt;/body&gt;
  &lt;/html&gt;
  `;
  asBlob(htmlString).then((data) =&gt; {
    saveAs(data, `${name}.docx`);
  });
}
  `
</code></pre> 
<p>使用案例:</p> 
<pre><code>ini
复制代码
&lt;div ref="word"&gt;
  &lt;h3 style="text-align: center"&gt;word标题&lt;/h3&gt;
  &lt;table
    border="1"
    cellspacing="0"
    width="600"
    style="font-size: 12px; color: #000; text-align: center"
  &gt;
    &lt;tr height="50"&gt;
      &lt;td width="100"&gt;1111&lt;/td&gt;
      &lt;td widt="200" colspan="2"&gt;合并单元格&lt;/td&gt;
      &lt;td width="300"&gt;最长的一项&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr height="100"&gt;
      &lt;td width="100"&gt;222&lt;/td&gt;
      &lt;td width="100"&gt;222&lt;/td&gt;
      &lt;td width="100"&gt;222&lt;/td&gt;
      &lt;td width="100"&gt;222&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
  &lt;table width="600" border="1" cellspacing="0"&gt;
    &lt;tr height="50"&gt;
      &lt;td width="100"&gt;1111&lt;/td&gt;
      &lt;td rowspan="3"&gt;合并包括此行在内的下面三行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr height="100"&gt;
      &lt;td&gt;222&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr height="300"&gt;
      &lt;td&gt;3333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;50&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;

let word = ref(null);
downloadWordWithHtmlString(word.value.innerHTML, 'html字符串word.docx');
</code></pre> 
<p>生成的word文件可以看到效果和在网页中的html代码一样：</p> 
<p><img src="https://images2.imgbox.com/71/5b/SiZXF5ML_o.png" alt="在这里插入图片描述"><br> 另外需要注意的是，若是需要在word中添加分页符，在需要分页的内容处添加CSS属性<a href="https://www.runoob.com/cssref/pr-print-pagebb.html" rel="nofollow">page-break-before</a>即可。此时在浏览器上打印出innerHTML值会发现:</p> 
<p><img src="https://images2.imgbox.com/a4/d2/SJVCkrpm_o.png" alt="在这里插入图片描述"></p> 
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/page-break-before" rel="nofollow">mdn</a>上介绍page-break-before属性已经被break-before属性替代，但是经过我实际测试发现当html字符串是page-break: always时生成的word文件没有分页效果，反而是将其替换回page-break-before后实现了分页效果。若有大神知道这是什么问题还望不吝赐教。 因此需要在downloadWordWithHtmlString方法中添加一句正则： <code>htmlString = htmlString.replace( /break-(after|before): page/g, "page-break-$1: always;" );</code>，此时就能实现分页效果。</p> 
<h4><a id="docx_188"></a>三、使用docx插件</h4> 
<p>第二种方法有个很致命的问题就是它无法在生成的word文件中添加图片页眉，我搜遍了npm也只找到一个能添加文字页眉的插件: <a href="https://www.npmjs.com/package/html-docx-ts" rel="nofollow">html-docx-ts</a>要想实现这个需求，就需要用到<a href="https://docx.js.org/#/" rel="nofollow">docx</a>插件。 docx官网的介绍是"Easily generate and modify .docx files with JS/TS. Works for Node and on the Browser."，意味着是一个专门用于生成word和修改word的文件。该插件就需要一个一个去配置你要生成的项，然后组合成一个word。一个简单的案例是：</p> 
<pre><code>css
复制代码
import {
  Document,
  Paragraph,
  Header,
  TextRun,
  Table,
  TableRow,
  TableCell,
  WidthType,
  Packer,
} from "docx";
import { saveAs } from "file-saver";

const document = new Document({
    sections: [
      {
        headers: {
          default: new Header({
            children: [new Paragraph("我是页眉")],
          }),
        },
        children: [
          new Paragraph({
            children: [
              new TextRun({
                text: "我是文字内容",
                size: 16,
                bold: true,
              }),
            ],
          }),
          new Table({
            columnWidths: [1500, 7500],
            rows: [
              new TableRow({
                children: [
                  new TableCell({
                    width: {
                      size: 1500,
                      type: WidthType.DXA,
                    },
                    children: [
                      new Paragraph({
                        alignment: "center",
                        children: [
                          new TextRun({
                            text: "测试",
                            size: 24,
                            font: {
                              name: "楷体",
                            },
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      },
    ],
  });
  
  Packer.toBlob(document).then((blob) =&gt; {
    saveAs(blob, "test.docx");
  });
</code></pre> 
<p>导出的word文件形式为：</p> 
<p><img src="https://images2.imgbox.com/8f/36/x9Y4AHDG_o.png" alt="在这里插入图片描述"><br> 下面是我个人总结的比较常见能用到的功能和配置项：</p> 
<pre><code>css
复制代码
// 导出文字
1.new Paragraph(text) -&gt; 默认字体样式: 宋体,五号字
2.new Paragraph({
    children: [
      new TextRun({
        text: "我是文字内容",
        size: 16, // 对应word中的字体大小8
        bold: true, // 是否加粗
        underline: {
          type: UnderlineType.SINGLE,
          color: "#2e32ee",
        }, // 下划线类型及颜色
        font: {
          name: "仿宋", // 只要是word中有的字体类型都可以生效
        },
      }),
    ],
    indent: {
      left: 100,
    }, // 离左边距离 类似于margin-left
    spacing: {
      before: 150,
      after: 200,
    }, // 离上边和下边的距离 类似于margin-top/bottom
    alignment: "center", // 对齐方式
    pageBreakBefore: true, // 是否在这段文字前加入分页符
  })
  
 // 导出表格
new Table({
  columnWidths: [1500, 7500], // 表示单行有几项,总宽度是9000,对应宽度;
  rows: [
    new TableRow({
      children: [
        new TableCell({
          width: {
            size: 1500, // 需与columnWidths的第一项对应
            type: WidthType.DXA, // 官网的介绍是Value is in twentieths of a point
            // 因为表格的总宽度是以twips(每英寸的1/20)为单位进行计算的
          },
          children: [
            new Paragraph({
              alignment: "center",
              children: [
                new TextRun({
                  text: "测试",
                  size: 24,
                  font: {
                    name: "楷体",
                  },
                }),
              ],
            }),
          ],
        }),
        new TableCell({
          width: {
            size: 7500,
            type: WidthType.DXA,
          },
          children: [
            new Paragraph('ccc'),
          ],
          margins: {
            top: 500,
            bottom: 500,
            left: 500
          } // 类似于单元格内容的padding
        }),
      ],
    }),
  ],
})

// 导出图片
new Paragraph({
  children: [
    new ImageRun({
      data: "base64", // 图片需转成base64的形式
      transformation: {
        width: 100,
        height: 30,
      }, // 图片宽高
    }),
  ],
})

// 设置页眉页脚
headers: {
  default: new Header({
    children: [new Paragraph("我是页眉")],
  }),
},
footers: {
  default: new Footer({
    children: [new Paragraph("我是页脚")],
  }),
}
</code></pre> 
<p>下面是一个完整的使用案例：</p> 
<pre><code>css
复制代码
const document = new Document({
  sections: [
    {
      headers: {
        default: new Header({
          children: [
            new Paragraph({
              children: [
                new ImageRun({
                  data: "data:image/jpeg;base64,...",
                  transformation: {
                    width: 150,
                    height: 150,
                  },
                }),
              ],
            }),
          ],
        }),
      },
      footers: {
        default: new Footer({
          children: [new Paragraph("我是页脚")],
        }),
      },
      children: [
         new Paragraph("第一行直接默认形式"),
         new Paragraph({
           children: [
             new TextRun({
               text: "下一页",
             }),
           ],
           pageBreakBefore: true,
         }),
         new Table({
           columnWidths: [1500, 7500],
           rows: [
             new TableRow({
               children: [
                 new TableCell({
                   width: {
                     size: 1500,
                     type: WidthType.DXA,
                   },
                   children: [
                     new Paragraph({
                       alignment: "center",
                       children: [
                         new TextRun({
                           text: "测试",
                           size: 24,
                           font: {
                             name: "楷体",
                           },
                         }),
                       ],
                     }),
                   ],
                 }),
                 new TableCell({
                   width: {
                     size: 7500,
                     type: WidthType.DXA,
                   },
                   children: [
                     new Paragraph({
                       children: [
                         new ImageRun({
                           data: "data:image/jpeg;base64,...",
                           transformation: {
                             width: 150,
                             height: 150,
                           },
                         }),
                       ],
                     }),
                   ],
                   margins: {
                     top: 500,
                     bottom: 500,
                    left: 500,
                  },
                }),
              ],
            }),
          ],
        }),
      ],
    },
  ],
});

Packer.toBlob(document).then((blob) =&gt; {
  saveAs(blob, "test.docx");
});
</code></pre> 
<p>此时导出的word文件如下:</p> 
<p><img src="https://images2.imgbox.com/c5/a4/WbOSGhpH_o.png" alt="在这里插入图片描述"><br> 学习更多vue开发知识请下载​​<a href="https://pan.baidu.com/s/14G-bpVthImHD4eosZUNSFA?pwd=yu27" rel="nofollow">CRMEB开源商城</a>​​附件学习</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7c901deb342ac5085f57620e9cc4d6b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Elasticsearch：与多个 PDF 聊天 | LangChain Python 应用教程（免费 LLMs 和嵌入）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/940bdc0fc265068290a836103ae7fef1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Rust 基础再理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>