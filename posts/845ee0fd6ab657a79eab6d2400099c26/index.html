<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常用排序算法分析与实现 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常用排序算法分析与实现" />
<meta property="og:description" content="排序分为两类：内排序和外排序。
内排序：指排序过程中，待排序列全部存放在内存中处理，不需涉及数据的内、外存交换。适用于元素序列不太大的小文件。
外排序：指排序过程中，待排序列不能全部存放在内存中处理，内、外存之间需要多次进行数据交换。适用于元素序列太大，不能一次将其全部放入内存的大文件。
内排序分为六类：插入排序、交换排序、选择排序、归并排序、分配排序和计数排序。这里主要介绍前四类。
一、插入排序
插入排序是指将无序子序列中的一个或几个元素“插入”到有序子序列中。插入排序主要有直接插入排序，折半插入排序，和希尔（shell）排序。
直接插入排序：时间复杂度为O(n^2)，特殊情况（原表有序）为O(n)。(稳定)
//如果升序排序
void SimpleInsertSort(int* pData, int length)
{
if(NULL == pData || length &lt;= 0)
return ;
int i, j, temp;
for(i = 1; i &lt; length; i&#43;&#43;)
{//对待排元素序列进行扫描。从第二个元素开始循环到最后一个元素。
for(j = i - 1; j &gt;= 0; j--)
{//从有序序列最后一个元素开始向前扫描，将待插入元素放入合适位置。
if(pData[j&#43;1] &gt; pData[j])
break;
temp = pData[j&#43;1];
pData[j&#43;1] = pData[j];
pData[j] = temp;
}
}
}
2）折半插入排序：由于插入排序的基本操作是在一个有序表中进行查找和插入，这个查找操作可以利用折半查找来实现，由此称之为折半插入排序。折半插入排序只是减少了元素间的比较次数，而元素的移动次数不变，因此时间复杂度为O(n^2)。(稳定)
void BinaryInsertSort(int data[], int length)
{
if(NULL == data || length &lt;= 0)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/845ee0fd6ab657a79eab6d2400099c26/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-10-27T15:23:38+08:00" />
<meta property="article:modified_time" content="2015-10-27T15:23:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常用排序算法分析与实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px">排序分为两类：内排序和外排序。</span></p> 
<p><span style="font-size:18px">内排序：指排序过程中，待排序列全部存放在内存中处理，不需涉及数据的内、外存交换。适用于元素序列不太大的小文件。</span></p> 
<p><span style="font-size:18px">外排序：指排序过程中，待排序列不能全部存放在内存中处理，内、外存之间需要多次进行数据交换。适用于元素序列太大，不能一次将其全部放入内存的大文件。</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px"> </span></p> 
<p><span style="font-size:18px">内排序分为六类：插入排序、交换排序、选择排序、归并排序、分配排序和计数排序。这里主要介绍前四类。</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px"> </span></p> 
<p><span style="font-size:18px">一、插入排序</span></p> 
<p><span style="font-size:18px">插入排序是指将无序子序列中的一个或几个元素“插入”到有序子序列中。插入排序主要有直接插入排序，折半插入排序，和希尔（<span style="font-family:Times New Roman">shell</span>）排序。</span></p> 
<p><span style="font-size:18px">直接插入排序：时间复杂度为<span style="font-family:Times New Roman">O(n^2)</span>，特殊情况（原表有序）为<span style="font-family:Times New Roman">O(n)</span>。<span style="color:red"><span style="font-family:Times New Roman">(</span></span><span style="color:red">稳定</span><span style="color:red"><span style="font-family:Times New Roman">)</span></span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">//</span>如果升序排序</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">void SimpleInsertSort(int* pData, int length)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    if(NULL == pData || length &lt;= 0)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        return ;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    int i, j, temp;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    for(i = 1; i &lt; length; i++)</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">    {//</span>对待排元素序列进行扫描。从第二个元素开始循环到最后一个元素。</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        for(j = i - 1; j &gt;= 0; j--)</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">        {//</span>从有序序列最后一个元素开始向前扫描，将待插入元素放入合适位置。</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            if(pData[j+1] &gt; pData[j])</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                break;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            temp = pData[j+1];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            pData[j+1] = pData[j];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            pData[j] = temp;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">}</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">2</span>）折半插入排序：由于插入排序的基本操作是在一个有序表中进行查找和插入，这个查找操作可以利用折半查找来实现，由此称之为折半插入排序。折半插入排序只是减少了元素间的比较次数，而元素的移动次数不变，因此时间复杂度为<span style="font-family:Times New Roman">O(n^2)</span>。<span style="color:red"><span style="font-family:Times New Roman">(</span></span><span style="color:red">稳定</span><span style="color:red"><span style="font-family:Times New Roman">)</span></span></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">void BinaryInsertSort(int data[], int length)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    if(NULL == data || length &lt;= 0)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        return ;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    int i, j;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    for(i = 1; i &lt; length; i++)</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">    {//</span>对待排元素序列进行扫描。从第二个元素开始循环到最后一个元素。</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        int low = 0;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        int high = i - 1;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        int mid = 0;</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">        int temp = data[i]; //</span>定义一个<span style="font-family:Times New Roman">temp</span>来存<span style="font-family:Times New Roman">data[i]</span>的值，避免移动序列将其覆盖</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        while(low &lt;= high)</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">        {//</span>在<span style="font-family:Times New Roman">[low...high]</span>中折半查找出有序插入的位置，位置为<span style="font-family:Times New Roman">high+1</span></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            mid = (low + high) &gt;&gt; 1;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            if(data[mid] &gt; temp)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                high = mid - 1;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            else</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                low = mid + 1;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        for(j = i - 1; j &gt; high; j--)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            data[j+1] = data[j];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        data[high+1] = temp;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">}</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">3</span>）希尔（<span style="font-family:Times New Roman">shell</span>）排序：是对直接插入排序的一种改进，又称<span style="font-family:Times New Roman">“</span>缩小增量排序<span style="font-family:Times New Roman">”</span>。基本思想是先将待排记录序列以一定的增量间隔<span style="font-family:Times New Roman">d</span>分割成多个子序列，对每个子序列分别进行一次直接插入排序，然后逐步减小增量间隔，重复上述的分组和排序，直至所取的增量为<span style="font-family:Times New Roman">1</span>，即所有记录放在同一组中进行直接插入排序为止。时间复杂度为<span style="font-family:Times New Roman">O(n^(1+u)) (0 &lt; u &lt; 1) </span>。<span style="color:red"><span style="font-family:Times New Roman">(</span></span><span style="color:red">不稳定</span><span style="color:red"><span style="font-family:Times New Roman">)</span></span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">//</span>增量初始值不容易选择，代码只是参考</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">void ShellSort(int* pData, int length)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    int d = length;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    while(d &gt; 1)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        int i, temp;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        d = (d + 1)&gt;&gt; 1;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        for(i = 0; i &lt; length - d; ++i)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            if(pData[i] &gt; pData[i+d])</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                temp = pData[i];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                pData[i] = pData[i+d];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                pData[i+d] = temp;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">}</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px"> </span></p> 
<p><span style="font-size:18px">二、交换排序</span></p> 
<p><span style="font-size:18px">交换排序的基本思想是两两比较待排序记录的关键字，两个记录的次序相反时即进行交换，直到没有反序的记录为止。交换排序主要有冒泡排序和快速排序。</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">1</span>）冒泡排序：时间复杂度为<span style="font-family:Times New Roman">O(n^2)</span>，特殊情况（原表有序）为<span style="font-family:Times New Roman">O(n)</span>。<span style="color:red"><span style="font-family:Times New Roman">(</span></span><span style="color:red">稳定</span><span style="color:red"><span style="font-family:Times New Roman">)</span></span></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">void BubbleSort(int data[], int length)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    int i, j, temp;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    for(i=0; i&lt;length-1; ++i)</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">    { //</span>外层<span style="font-family:Times New Roman">for</span>循环控制趟数，共<span style="font-family:Times New Roman">n-1</span>趟<span style="font-family:Times New Roman">,</span>大数放在最后面</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        for(j=0; j&lt;length-1-i; ++j)</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">        {//</span>内层<span style="font-family:Times New Roman">for</span>循环控制相邻元素比较次数</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            if(data[j]&gt;data[j+1])</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                temp = data[j];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                data[j] = data[j+1];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                data[j+1] = temp;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">}</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">2</span>）快速排序：是对冒泡排序的一种改进，又称“分区交换排序”。基本思想是从待排序列中任选一个记录（通常可选第一个记录），以它作为枢轴点，分别把小于和大于枢轴点的记录移到枢轴点两边。然后在两边序列中重复上述操作，直至全部序列有序。</span></p> 
<p><span style="font-size:18px">时间复杂度是<span style="font-family:Times New Roman">O(n*log2(n)), </span>特殊情况（原表有序，退化为冒泡排序）<span style="font-family:Times New Roman">O(n^2)</span>，空间复杂度是<span style="font-family:Times New Roman">O(log2(n))</span>。<span style="color:red"><span style="font-family:Times New Roman">(</span></span><span style="color:red">不稳定</span><span style="color:red"><span style="font-family:Times New Roman">)</span></span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">//</span>划分算法</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">int Partition(int data[], int low, int high, int length)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    if(NULL==data || low&lt;0 || high&gt;=length)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">        printf("</span>输入无效参数<span style="font-family:Times New Roman">\n");</span></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        exit(-1);</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    int temp = data[low];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    while(low &lt; high)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        while(low &lt; high &amp;&amp; data[high]&gt;=temp)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            high--;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        if(low &lt; high)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            data[low++] = data[high];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        while(low &lt; high &amp;&amp; data[low]&lt;=temp)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            low++;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        if(low &lt; high)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            data[high--] = data[low];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    data[low] = temp;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    return low;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">}</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">void QuickSort(int data[], int low, int high, int length)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    int index;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    if(low &lt; high)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        index = Partition(data, low, high, length);</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        QuickSort(data, low, index-1, length);</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        QuickSort(data, index+1, high, length);</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">}</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px"> </span></p> 
<p><span style="font-size:18px">三、选择排序</span></p> 
<p><span style="font-size:18px">选择排序的基本思想是每一次从待排序序列中选出最小（或最大）的一个元素，存放在已排序列的最后位置，直到全部待排序的记录排定。选择排序主要有简单选择排序和堆排序。</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">1</span>）简单选择排序：时间复杂度为<span style="font-family:Times New Roman">O(n^2)</span>。<span style="color:red"><span style="font-family:Times New Roman">(</span></span><span style="color:red">不稳定</span><span style="color:red"><span style="font-family:Times New Roman">)</span></span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">//</span>大小到大排序</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">void SimpleSelectSort(int data[], int length)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    int i, j, temp;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    for(i = 0; i &lt; length-1; ++i)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        for(j = i+1; j &lt; length; ++j)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            if(data[i] &gt; data[j])</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                temp = data[i];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                data[i] = data[j];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">                data[j] = temp;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">}</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">2</span>）堆排序：堆实质上是一棵完全二叉树，树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。堆分为小根堆和大根堆两种。小根堆要求父结点小于等于其<span style="font-family:Times New Roman">2</span>个子结点；大根堆要求父结点大于等于其<span style="font-family:Times New Roman">2</span>个子结点。</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">N</span>（<span style="font-family:Times New Roman">N&gt;1</span>）个节点的的完全二叉树编号原则是：从上到下，从左自右。最后一个分枝结点（非叶子结点）的编号为<span style="font-family:Times New Roman"> N/2 </span>取整。且对于编号<span style="font-family:Times New Roman"> i</span>（<span style="font-family:Times New Roman">1&lt;=i&lt;=N</span>）有：父结点为<span style="font-family:Times New Roman"> i/2 </span>向下取整；若<span style="font-family:Times New Roman">2i&gt;N</span>，则结点<span style="font-family:Times New Roman">i</span>没有左孩子，否则其左孩子为<span style="font-family:Times New Roman">2i</span>；若<span style="font-family:Times New Roman">2i+1&gt;N</span>，则没有右孩子，否则其右孩子为<span style="font-family:Times New Roman">2i+1</span>。</span></p> 
<p><span style="font-size:18px">注：使用完全二叉树只是为了好描述算法，它只是一种逻辑结构，真正在实现时我们还是使用数组来存储这棵完全二叉树的。</span></p> 
<p><span style="font-size:18px">堆排序时间，主要由“建堆”和反复“调整”重建堆这两部分时间构成。时间复杂度为<span style="font-family:Times New Roman">O(n*log2(n))</span>，空间复杂度为<span style="font-family:Times New Roman">O(1)</span>。<span style="color:red"><span style="font-family:Times New Roman">(</span></span><span style="color:red">不稳定</span><span style="color:red"><span style="font-family:Times New Roman">)</span></span></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">void Swap(int* pFirstData, int* pSecondData)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    int temp = *pFirstData;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    *pFirstData = *pSecondData;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    *pSecondData = temp;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">}</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">void HeapAdjust(int data[], int startIndex, int length)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    int i;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    for(i = 2*startIndex+1; i &lt; length; i = 2*startIndex+1)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        if(i&lt;length-1 &amp;&amp; data[i]&lt;data[i+1])</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">            i++; //</span>较大的记录下标</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        if(data[startIndex] &gt;= data[i])</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">            break;  //</span>不用调整了，满足堆的定义</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        Swap(&amp;data[startIndex], &amp;data[i]);</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        startIndex = i;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">}</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">void HeapSort(int data[], int length)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    int i;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    for(i = length/2-1; i &gt;= 0; --i)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">//</span>先建堆，从最后一个非叶结点开始调整，完全二叉树的最后一个非叶结点是<span style="font-family:Times New Roman">n/2</span></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">HeapAdjust(data, i, length);</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    for(i = length-1; i &gt;= 0; --i)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        Swap(&amp;data[0], &amp;data[i]);</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        HeapAdjust(data, 0, i);</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">}</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px"> </span></p> 
<p><span style="font-size:18px">四、归并排序</span></p> 
<p><span style="font-size:18px">归并排序是采用分治法的一个典型应用。该算法通过归并操作，将已有序的子序列合并，得到一个整体有序的序列。归并排序主要有二路归并排序。</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">1</span>）二路归并排序：将一个具有<span style="font-family:Times New Roman">N</span>个待排序记录的序列看成<span style="font-family:Times New Roman">N</span>个长度为<span style="font-family:Times New Roman">1</span>的有序序列，然后进行两两归并，得到（<span style="font-family:Times New Roman">N/2</span>取整）个长度为<span style="font-family:Times New Roman">2</span>的有序序列，再进行两两归并。如此重复，直到得到一个长度为<span style="font-family:Times New Roman">N</span>的有序序列为止。时间复杂度是<span style="font-family:Times New Roman">O(n*log2(n))</span>，空间复杂度是<span style="font-family:Times New Roman">O(n)</span>。<span style="color:red"><span style="font-family:Times New Roman">(</span></span><span style="color:red">稳定</span><span style="color:red"><span style="font-family:Times New Roman">)</span></span></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">void Merge(int data[], int copy[], int first, int mid, int last)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    int indexCopy = first;</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">    int i = first; // </span>前半段第一个数字下标</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">    int j = mid+1; // </span>后半段第一个数字下标</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    while(i &lt;= mid &amp;&amp; j &lt;= last)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        if(data[i] &lt; data[j])</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            copy[indexCopy++] = data[i++];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        else</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">            copy[indexCopy++] = data[j++];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    while(i &lt;= mid)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        copy[indexCopy++] = data[i++];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    while(j &lt;= last)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        copy[indexCopy++] = data[j++];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    for(i = first; i &lt;= last; ++i)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        data[i] = copy[i];</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">}</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">/*** </span> 使用递归实现<span style="font-family:Times New Roman"> ***/</span></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">void BiMergeSort(int data[], int copy[], int first, int last)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">{<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    if(first &lt; last)</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    {<!-- --></span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        int mid = (first+last)&gt;&gt;1;</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        BiMergeSort(data, copy, first, mid);</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        BiMergeSort(data, copy, mid+1, last);</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">        Merge(data, copy, first, mid, last);</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">    }</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px">} </span></p> 
<p><span style="font-family:Times New Roman; font-size:18px"> </span></p> 
<p><span style="font-size:18px">外部排序最常用的是归并排序算法，它由两个阶段组成：</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">1）</span>  生成初始归并段：将外存文件中的信息分段输入内存，使用内部排序算法对其进行排序，生成初始归并段，并将其写回外部文件，直至外部文件的信息全部转换成初始归并段时为止；（把原始数据分成<span style="font-family:Times New Roman">M</span>段，每段都排好序，分别存入<span style="font-family:Times New Roman">M</span>个文件中，称为顺串文件）</span></p> 
<p><span style="font-size:18px"><span style="font-family:Times New Roman">2）</span>  归并：从<span style="font-family:Times New Roman">M</span>个顺串文件中读出头条记录，进行<span style="font-family:Times New Roman">M</span>路归并排序，最小的放到输出文件，同时删除对应的顺串文件中的记录。直至整个外部文件归并为单一归并段时为止。</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px"> </span></p> 
<p><span style="font-size:18px">例如：假设有一个含<span style="font-family:Times New Roman">10000</span>个记录的磁盘文件，而当前所用的计算机一次只能对　　　　　　<span style="font-family:Times New Roman">1,000</span>个记录进行内部排序，则首先利用内部排序的方法得到<span style="font-family:Times New Roman">10</span>个初始归并段，然后进行逐趟归并。假设进行二路归并<span style="font-family:Times New Roman">(</span>即两两归并<span style="font-family:Times New Roman">)</span>，则第一趟由<span style="font-family:Times New Roman">10</span>个归并段得到<span style="font-family:Times New Roman">5</span>个归并段；第二趟由<span style="font-family:Times New Roman"> 5 </span>个归并段得到<span style="font-family:Times New Roman">3</span>个归并段；第三趟由<span style="font-family:Times New Roman">3</span>个归并段得到<span style="font-family:Times New Roman">2</span>个归并段；最后一趟归并得到整个记录的有序序列。</span></p> 
<p><span style="font-family:Times New Roman; font-size:18px"> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b99fb859402d9bc6f101889b0bf46a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java线程池 ExecutorService</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a44064e732157d6a51c0d9c8cb1b223a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">POST上传JSON数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>