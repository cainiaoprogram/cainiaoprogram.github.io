<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CubeMx-freeRTOS智能门锁 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CubeMx-freeRTOS智能门锁" />
<meta property="og:description" content="前言：本文基于之前的标准库的写的 freeRTOS小项目练习—智能门锁 用CubeMx进行移植，以此学习CubeMX和HAL库。
目录
一、项目的基本配置
二、配置相关项
三、项目移植
四、模块通信
五、完整项目工程代码
一、项目的基本配置 1、RCC中选择外置晶振
2、SYS中选定Debug方法，Serial Wire
3、配置系统频率，同时要选定外部晶振源HSE、使能CSS。
4、Project Manager
工程名以及保存路径不能含中文选定自己的编译器Toolchain/IDECode Generator中选定用到什么库就复制什么库；选择.c/.h文件分别生成 5、GENERATE CODE
二、配置相关项 1、配置串口printf重定向：记得开启 MicroLIB
#include &#34;usart.h&#34; /* USER CODE BEGIN 0 */ #include &lt;stdio.h&gt; int fputc(int ch, FILE *f)	{ HAL_UART_Transmit(&amp;huart1,(uint8_t *)&amp;ch,1,0xFFFF); return (ch); } /* USER CODE END 0 */ UART_HandleTypeDef huart1; 2、freeRTOS的配置;
MDK的编译器不能使用V6版本会报错：
我这里是将ARM_CM3进行替换(因为我用的103ZET6是Cortex-M3的核)，而非ARM_CM4F(ARM_CM4F目录,是针对Cortex-M4 FPU功能的)，查看port.c的引用路局为可以发现为ARM_CM3
【Keil】CubeMX配置的FreeRTOS利用V6编译出错_ac6 freertos编译不通过_米杰的声音的博客-CSDN博客
参考文章： FreeRTOS&#43;CubeMX系列第一篇——初识FreeRTOS_cubemx freertos_冬瓜~的博客-CSDN博客
CubeMX使用FreeRTOS编程指南_cubemx freertos_Top嵌入式的博客-CSDN博客
继续配置：
Config parameters 堆栈大小设置TOTAL_HEAPS = 15360Advanced settings :Enabled Newlib settingsV10版本的流缓冲区和消息缓冲区（用于数据量大长度不定） 任务优先级的理解 任务优先级分配和修改 这样freeRTOS设置了56个优先级对应配置中的MAX_PRIORITIES FreeRTOS 任务优先级问题" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0dcf711a813fa46f7d07588a5a413b3c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-12T20:55:39+08:00" />
<meta property="article:modified_time" content="2023-09-12T20:55:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CubeMx-freeRTOS智能门锁</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前言：本文基于之前的标准库的写的<a href="https://blog.csdn.net/qq_45803449/article/details/130632818?spm=1001.2014.3001.5502" title=" freeRTOS小项目练习—智能门锁"> freeRTOS小项目练习—智能门锁</a> 用CubeMx进行移植，以此学习CubeMX和HAL库。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE" rel="nofollow">一、项目的基本配置</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E9%A1%B9-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E9%A1%B9" rel="nofollow">二、配置相关项</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D" rel="nofollow">三、项目移植</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%A8%A1%E5%9D%97%E9%80%9A%E4%BF%A1-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E6%A8%A1%E5%9D%97%E9%80%9A%E4%BF%A1" rel="nofollow">四、模块通信</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81" rel="nofollow">五、完整项目工程代码</a></p> 
<h3 id="%E4%B8%80%E3%80%81%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">一、项目的基本配置</h3> 
<hr> 
<p>1、RCC中选择外置晶振</p> 
<p>2、SYS中选定Debug方法，Serial Wire</p> 
<p>3、配置系统频率，同时要选定外部晶振源HSE、使能CSS。</p> 
<p>4、Project Manager</p> 
<ul><li>工程名以及保存路径不能含中文</li><li>选定自己的编译器Toolchain/IDE</li><li>Code Generator中选定用到什么库就复制什么库；选择.c/.h文件分别生成<img alt="" height="264" src="https://images2.imgbox.com/16/7e/RDhFbGgd_o.png" width="880"></li></ul> 
<p>5、GENERATE CODE</p> 
<hr> 
<h3 id="%E4%BA%8C%E3%80%81%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E9%A1%B9">二、配置相关项</h3> 
<hr> 
<p>1、配置串口printf重定向：记得开启 MicroLIB</p> 
<pre><code class="language-cpp">#include "usart.h"
/* USER CODE BEGIN 0 */
#include &lt;stdio.h&gt;
int fputc(int ch, FILE *f)	
{
	HAL_UART_Transmit(&amp;huart1,(uint8_t *)&amp;ch,1,0xFFFF);
	return (ch);
}

/* USER CODE END 0 */

UART_HandleTypeDef huart1;</code></pre> 
<p>2、freeRTOS的配置;</p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/37/27/3RnG2EMG_o.png" width="1182"><img alt="" height="569" src="https://images2.imgbox.com/4a/3e/dJoxGuTx_o.png" width="965"></p> 
<p>MDK的编译器不能使用V6版本会报错：</p> 
<p>我这里是将ARM_CM3进行替换(因为我用的103ZET6是Cortex-M3的核)，而非ARM_CM4F(<em>ARM_CM4F</em>目录,是针对Cortex-M4 FPU功能的)，查看port.c的引用路局为可以发现为ARM_CM3</p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/47/ba/p8XXHVZH_o.png" width="634"></p> 
<p><img alt="" height="114" src="https://images2.imgbox.com/21/d6/iEKuDWyD_o.png" width="553"><a href="https://blog.csdn.net/Roger_717/article/details/128060949" title="【Keil】CubeMX配置的FreeRTOS利用V6编译出错_ac6 freertos编译不通过_米杰的声音的博客-CSDN博客">【Keil】CubeMX配置的FreeRTOS利用V6编译出错_ac6 freertos编译不通过_米杰的声音的博客-CSDN博客</a></p> 
<p>参考文章： </p> 
<p> <a href="https://blog.csdn.net/weixin_44793491/article/details/107577711" title="FreeRTOS+CubeMX系列第一篇——初识FreeRTOS_cubemx freertos_冬瓜~的博客-CSDN博客">FreeRTOS+CubeMX系列第一篇——初识FreeRTOS_cubemx freertos_冬瓜~的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/qq_45396672/article/details/120877303" title="CubeMX使用FreeRTOS编程指南_cubemx freertos_Top嵌入式的博客-CSDN博客">CubeMX使用FreeRTOS编程指南_cubemx freertos_Top嵌入式的博客-CSDN博客</a></p> 
<blockquote> 
 <p>继续配置：</p> 
 <ul><li>Config parameters 堆栈大小设置TOTAL_HEAPS = 15360</li><li>Advanced settings :Enabled Newlib settings</li><li>V10版本的流缓冲区和消息缓冲区（用于数据量大长度不定）</li><li> <p>任务优先级的理解 <a href="https://www.cnblogs.com/armfly/p/15763236.html" rel="nofollow" title="任务优先级分配和修改">任务优先级分配和修改</a>  这样freeRTOS设置了56个优先级对应配置中的MAX_PRIORITIES <a href="https://blog.csdn.net/xinghuanmeiying/article/details/78206416#:~:text=%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%E8%AF%B4%E6%98%8E%201%20FreeRTOS%20%E4%B8%AD%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9C%80%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E9%80%9A%E8%BF%87%20FreeRTOSConfig.h%20%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%20configMAX_PRIORITIES%20%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%E7%9A%84%EF%BC%8C%E7%94%A8%E6%88%B7%E5%AE%9E%E9%99%85%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E8%8C%83%E5%9B%B4%E6%98%AF,5%20%E4%B8%93%E7%94%A8%E6%96%B9%E5%BC%8F%20%EF%BC%8C%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E2%80%94%E9%85%8D%E7%BD%AE%E5%AE%8F%E5%AE%9A%E4%B9%89%20configUSE_PORT_OPTIMISED_TASK_SELECTION%20%E4%B8%BA%E4%B8%BA%201%EF%BC%9A%20...%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE" title="FreeRTOS 任务优先级问题">FreeRTOS 任务优先级问题</a></p> </li><li> <p></p> </li></ul> 
 <p> 补充：<strong>中断优先级和任务优先级区别<br> 初学者也容易在这两个概念上面出现问题。 简单的说，这两个之间没有任何关系，不管中断的优先级是多少，中断的优先级永远高于任何任务的优先级，即任务在执行的过程中，中断来了就开始执行中断服务程序。另外对于 STM32F103，F407 和 F429 来说，中断优先级的数值越小，优先级越高。 而 FreeRTOS的任务优先级是，任务优先级数值越小，任务优先级越低</strong><br>  </p> 
</blockquote> 
<hr> 
<h3 id="%E4%B8%89%E3%80%81%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D">三、项目移植</h3> 
<p>将这个项目进行CubeMX的移植</p> 
<p>1：RC552</p> 
<blockquote> 
 <p>①：直接用图形化配置添加RC552的任务</p> 
 <p>②：RC552改用硬件SPI <a href="https://blog.csdn.net/weixin_56565733/article/details/122023591" title="MFRC-522 无线射频IC卡驱动教程">MFRC-522 无线射频IC卡驱动教程</a></p> 
 <p>③：存在问题print汉字输出错误</p> 
 <p>        <img alt="" height="252" src="https://images2.imgbox.com/15/14/jddzboKa_o.png" width="312"></p> 
 <p>④：基于CubeMX、HAL库修改开发</p> 
 <p>⑤：在Keil中添加自己的.c/.h文件后要保存，这样用CubeMX重新生成代码时才不会被删除。</p> 
 <hr> 
 <p>用  strncmp((char *)readUid,(char *)UID,4) </p> 
 <p>替换 (cid[0] == ID[0]) &amp;&amp; (cid[1] == ID[1])&amp;&amp; (cid[2] == ID[2]) &amp;&amp; (cid[3] == ID[3])  做对比</p> 
 <p><a href="https://www.runoob.com/cprogramming/c-function-strncmp.html" rel="nofollow" title="C 库函数 – strncmp()">C 库函数 – strncmp()</a></p> 
</blockquote> 
<p>2:AS608</p> 
<blockquote> 
 <p>①：HAL库配置外部中断<a href="https://blog.csdn.net/lcx1837/article/details/119684251" title=" 外部中断基础"> 外部中断基础</a></p> 
 <p>②：移植之前的失败参考新方式 串口空闲中断的方式 <a href="https://blog.csdn.net/weixin_56565733/article/details/124474632?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168494137416800211553350%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168494137416800211553350&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124474632-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=as608%20hal%E5%BA%93&amp;spm=1018.2226.3001.4187" title=" AS608(（HAL库  )"> AS608(（HAL库 )</a></p> 
 <p><a href="https://blog.csdn.net/wuyiyu_/article/details/129238627?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168493502116800182173915%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168493502116800182173915&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-129238627-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=STM32CubeMXP%E9%85%8D%E7%BD%AEUSART%E4%B8%AD%E6%96%AD&amp;spm=1018.2226.3001.4187" title="STM32CubeMX串口USART中断发送接收数据">STM32CubeMX串口USART中断发送接收数据</a></p> 
 <p> <img alt="" height="241" src="https://images2.imgbox.com/a6/25/aCgIZW6B_o.png" width="344"></p> 
 <p>对于这段函数的理解：串口不定长数据改用空闲中断的方式</p> 
 <hr> 
 <pre><code class="language-cpp">/*指纹模块初始化*/
uint8_t as608_init(void)
{
    //设置uart3接收中断
    HAL_UART_Receive_IT(&amp;AS608_UART,USART2_RX_BUF,sizeof( USART2_RX_BUF));//接收数据，且产生中断
    //使能空闲中断
    __HAL_UART_ENABLE_IT(&amp;AS608_UART,UART_IT_IDLE);//
    
    return AS608_Check();
}</code></pre> 
 <hr> 
 <pre><code class="language-cpp">void USART2_IRQHandler(void)
{
  /* USER CODE BEGIN USART2_IRQn 0 */
    //串口接收不定长数据
    //判断是否为空闲中断，如果是就认为接收数据完成    
    if(__HAL_UART_GET_FLAG(&amp;AS608_UART,UART_FLAG_IDLE) != RESET)
    {
        //认为数据接收完成，进行处理
        //1、清除空闲中断
        __HAL_UART_CLEAR_IDLEFLAG(&amp;AS608_UART);
        
        //2、获取接收大小

        //3、清空接收状态

        AS608_UART.RxXferCount = sizeof(USART2_RX_BUF);
        AS608_UART.pRxBuffPtr = USART2_RX_BUF;
        USART2_RX_STA = 1;//接收数据完成
        return ;    
    }
    
  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&amp;huart2);
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}</code></pre> 
</blockquote> 
<p>3:CPU使用情况 <a href="https://blog.csdn.net/m0_37978258/article/details/88570269" title="添加系统任务状态及任务运行显示">添加系统任务状态及任务运行显示</a></p> 
<blockquote> 
 <p>①：设置一个是freeRTOS心跳(1ms)10倍小(0.1ms)的定时器，以及中断</p> 
 <p><img alt="" height="299" src="https://images2.imgbox.com/47/65/Majx3LXf_o.png" width="894"></p> 
 <p><em><strong><span style="background-color:#ffd900;">1. auto-reload precload=Disable：自动重装载寄存器写入新值后，计数器立即产生计数溢出，然后开始新的计数周期</span><br><span style="background-color:#ffd900;">2. auto-reload precload=Enable：自动重装载寄存器写入新值后，计数器完成当前旧的计数后，再开始新的计数周期</span></strong></em></p> 
 <p><span style="background-color:#ffd900;"><strong><em>所以这里</em></strong></span><em><strong><span style="background-color:#ffd900;">Disable或者Enable都可以。</span></strong></em></p> 
 <p><em><strong><span style="background-color:#ffd900;">任务栈的大小要够大因为有任务信息要打印栈太小会导致任务失败</span></strong></em></p> 
 <p><img alt="" height="190" src="https://images2.imgbox.com/12/f1/t1MtDpj6_o.png" width="900"></p> 
 <p>②：开启freeRTOS的</p> 
 <p><code>GENERATE_RUN_TIME_STATS</code>、<code>USE_TRACE_FACILITY</code>、<code>USE_STATS_FORMATTING_FUNCTIONS</code></p> 
 <p><img alt="" height="112" src="https://images2.imgbox.com/8e/9f/Iucrbk7N_o.png" width="887"></p> 
 <p>③：创建按键任务来触发</p> 
 <pre><code class="language-cpp">void key_Task(void *argument)
{
  /* USER CODE BEGIN key_Task */
  /* Infinite loop */
	uint8_t CPU_RunInfo[400];
	uint8_t key;
  for(;;)
  {
	memset(CPU_RunInfo,0,sizeof(CPU_RunInfo));
	vTaskList((char *)&amp;CPU_RunInfo);		//获取任务列表
	printf("---------------------------------------------\r\n");
	printf("任务名      任务状态 优先级   剩余栈 任务序号\r\n");
	printf("%s", CPU_RunInfo);
	printf("---------------------------------------------\r\n");

	memset(CPU_RunInfo,0,400);
	vTaskGetRunTimeStats((char *)&amp;CPU_RunInfo);		//获取任务运行状态
	printf("任务名       运行计数         利用率\r\n");
	printf("%s", CPU_RunInfo);
	printf("---------------------------------------------\r\n");
	
	 osDelay(1000);
  }
  /* USER CODE END key_Task */
}</code></pre> 
 <hr> 
 <pre><code class="language-cpp">//统计CPU利用率的TIM7定时器中断函数
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim-&gt;Instance == TIM7)
    {
        g_osRuntimeCounter++;//g_osRuntimeCounter为一个全局变量
    }
} </code></pre> 
 <hr> 
 <p>实现FreeRTOSConfig.h中定义的两函数</p> 
 <p><img alt="" height="141" src="https://images2.imgbox.com/cf/c9/LztXSgeO_o.png" width="1005"></p> 
 <pre><code class="language-cpp">void configureTimerForRunTimeStats(void)
{
    g_osRuntimeCounter = 0;
}

unsigned long getRunTimeCounterValue(void)
{
    return g_osRuntimeCounter;
}</code></pre> 
 <hr> 
 <p>最后CubeMX配置完后要手动打开配置的定时器，自动生成的不会打开。</p> 
 <p>没有打开的话运行占用率是不会打印出来，只会打印出与任务信息；</p> 
 <p><img alt="" height="149" src="https://images2.imgbox.com/0f/03/EPNVrpCY_o.png" width="491"></p> 
 <p>要自己打开定时器</p> 
 <pre><code class="language-cpp">  /* USER CODE BEGIN 2 */
  HAL_TIM_Base_Start_IT(&amp;htim7);
  /* USER CODE END 2 */</code></pre> 
 <p><img alt="" height="252" src="https://images2.imgbox.com/e8/53/jRawVt61_o.png" width="406"></p> 
 <p>④：模块中的delay_ms全部用freeRTOS的osDelay任务利用率会降低</p> 
 <p><img alt="" height="130" src="https://images2.imgbox.com/29/23/AlrJhWV8_o.png" width="693"></p> 
</blockquote> 
<p> 4:舵机 <a href="https://blog.csdn.net/Reasally/article/details/126799988#:~:text=%E9%A6%96%E5%85%88%EF%BC%8C%E5%9C%A8%20STM32Cube%20MX%E4%B8%AD%E9%85%8D%E7%BD%AE%20PWM%E8%BE%93%E5%87%BA%20%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B0%86%20PWM%E8%BE%93%E5%87%BA%20%E5%BC%95%E8%84%9A%E8%BF%9E%E6%8E%A5%E5%88%B0%20%E8%88%B5%E6%9C%BA,%EF%BC%9B3.%20%E5%9C%A8while%E5%BE%AA%E7%8E%AF%E4%B8%AD%E8%B0%83%E7%94%A8HAL_TIM_%20PWM%20_Start%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%20PWM%E8%BE%93%E5%87%BA%20%E7%9A%84%E5%8D%A0%E7%A9%BA%E6%AF%94%EF%BC%8C%E7%84%B6%E5%90%8E%E8%B0%83%E7%94%A8HAL_GPIO_WritePin%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%20%E8%88%B5%E6%9C%BA%20%E7%9A%84%E8%BD%AC%E5%8A%A8%E6%96%B9%E5%90%91%EF%BC%9B4." title="HAL库PWM输出驱动舵机">HAL库PWM输出驱动舵机</a></p> 
<blockquote> 
 <p>①：定时器的配置</p> 
 <p>②：要注意项目中的延迟应该都用freeRTOS的延迟函数，这样才能切换到别的任务运行，而不是死等。</p> 
 <p>③：这里配置的是PWM的占空比，舵机0°对应的是500，但是配置成500舵机精度问题会到不了一直卡死，所以这里配置大一点。</p> 
 <p><img alt="" height="475" src="https://images2.imgbox.com/5e/50/xmEkiYVy_o.png" width="739"></p> 
</blockquote> 
<p> 4:ESP866</p> 
<blockquote> 
 <p>①：按照之前的移植</p> 
 <p>②：串口不定长数据改用空闲中断的方式</p> 
</blockquote> 
<h3 id="%E5%9B%9B%E3%80%81%E6%A8%A1%E5%9D%97%E9%80%9A%E4%BF%A1">四、模块通信</h3> 
<p>之前采用的事件组的方式进行同步现在改用任务通知的ICP通信方式</p> 
<p>任务完整代码</p> 
<pre><code>/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include &lt;stdio.h&gt;
#include "myconfig.h"
#include "tim.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
void Set_Angle(float angle);
void Suspen_Servo(void);
void Warn(void);
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define EVENT1 (0X01 &lt;&lt; 0)
#define EVENT2 (0X01 &lt;&lt; 1)
#define EVENT3 (0X01 &lt;&lt; 2)
#define ULONG_MAX (0xFFFFFFFF)

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */
extern volatile uint8_t finger_status;
uint8_t err=0;

/* USER CODE END Variables */
/* Definitions for Start */
osThreadId_t StartHandle;
const osThreadAttr_t Start_attributes = {
  .name = "Start",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityBelowNormal,
};
/* Definitions for LED */
osThreadId_t LEDHandle;
const osThreadAttr_t LED_attributes = {
  .name = "LED",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for AS608 */
osThreadId_t AS608Handle;
const osThreadAttr_t AS608_attributes = {
  .name = "AS608",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal1,
};
/* Definitions for KEY */
osThreadId_t KEYHandle;
const osThreadAttr_t KEY_attributes = {
  .name = "KEY",
  .stack_size = 512 * 4,
  .priority = (osPriority_t) osPriorityNormal2,
};
/* Definitions for SERVO */
osThreadId_t SERVOHandle;
const osThreadAttr_t SERVO_attributes = {
  .name = "SERVO",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal3,
};
/* Definitions for ESP */
osThreadId_t ESPHandle;
const osThreadAttr_t ESP_attributes = {
  .name = "ESP",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal4,
};

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */

/* USER CODE END FunctionPrototypes */

void Start_Task(void *argument);
void led_Task(void *argument);
void AS608_Task(void *argument);
void key_Task(void *argument);
void Servo_Task(void *argument);
void ESP_Task(void *argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* Hook prototypes */
void configureTimerForRunTimeStats(void);
unsigned long getRunTimeCounterValue(void);

/* USER CODE BEGIN 1 */
/* Functions needed when configGENERATE_RUN_TIME_STATS is on */
__weak void configureTimerForRunTimeStats(void)
{
	
}

__weak unsigned long getRunTimeCounterValue(void)
{
return 0;
}
/* USER CODE END 1 */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of Start */
  StartHandle = osThreadNew(Start_Task, NULL, &amp;Start_attributes);

  /* creation of LED */
  LEDHandle = osThreadNew(led_Task, NULL, &amp;LED_attributes);

  /* creation of AS608 */
  AS608Handle = osThreadNew(AS608_Task, NULL, &amp;AS608_attributes);

  /* creation of KEY */
  KEYHandle = osThreadNew(key_Task, NULL, &amp;KEY_attributes);

  /* creation of SERVO */
  SERVOHandle = osThreadNew(Servo_Task, NULL, &amp;SERVO_attributes);

  /* creation of ESP */
  ESPHandle = osThreadNew(ESP_Task, NULL, &amp;ESP_attributes);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* USER CODE BEGIN RTOS_EVENTS */
  /* add events, ... */
  /* USER CODE END RTOS_EVENTS */

}

/* USER CODE BEGIN Header_Start_Task */
/**
  * @brief  Function implementing the Start thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_Start_Task */
void Start_Task(void *argument)
{
  /* USER CODE BEGIN Start_Task */
	
	MFRC_Init();
	PCD_Reset();
 	printf("RC522初始化完成\r\n");
	osStatus_t result;
	uint8_t readUid[5]; 
	uint8_t UID[5]={0x83,0xFE,0x28,0xA1};//
	BaseType_t xReturn = pdPASS;

	unsigned char cid[4];
  /* Infinite loop */
  for(;;)
  {
	  
	if(!readCard(readUid,NULL))
	{
		printf("卡号：%.2X-%.2X-%.2X-%.2X\r\n",readUid[0],readUid[1],readUid[2],readUid[3]);
		if(!strncmp((char *)readUid,(char *)UID,4))
		{
			//比对卡号正确要做什么
			printf("卡号正确\r\n");
			xReturn = xTaskNotify((TaskHandle_t)SERVOHandle,
								   (uint32_t)EVENT3,
								   (eNotifyAction)eSetBits);
			if(xReturn == pdTRUE)	printf("send event3 succeed\r\n");
			else printf("send event3 fail\r\n");
		
		}else{
			//比对卡号错误要做什么
			printf("卡号错误\r\n");
			err++;
			Suspen_Servo();
		}
	}
	  osDelay(100);
  }
  /* USER CODE END Start_Task */
}

/* USER CODE BEGIN Header_led_Task */
/**
* @brief Function implementing the LED thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_led_Task */
void led_Task(void *argument)
{
  /* USER CODE BEGIN led_Task */
	printf("led_Task\r\n");
  /* Infinite loop */
  for(;;)
  {
	HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);
	  osDelay(1000);
  }
  /* USER CODE END led_Task */
}

/* USER CODE BEGIN Header_AS608_Task */
/**
* @brief Function implementing the AS608 thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_AS608_Task */
void AS608_Task(void *argument)
{
  /* USER CODE BEGIN AS608_Task */
	osStatus_t result;
	printf("AS608_Task\r\n");
	as608_init();
	BaseType_t xReturn = pdPASS;

//  /* Infinite loop */
  for(;;)
  {
    if(finger_status == FINGER_EXIST)
	{
		finger_status = FINGER_NO_EXIST;
		if(press_FR())
		{
			xReturn = xTaskNotify((TaskHandle_t)SERVOHandle,
								   (uint32_t)EVENT1,
								   (eNotifyAction)eSetBits);
			if(xReturn == pdTRUE)	printf("send event1 succeed\r\n");
			else printf("send event1 fail\r\n");
		}
		else
		{
			err++;
			Suspen_Servo();
		}
	}
	  osDelay(100);
  }
  /* USER CODE END AS608_Task */
}

/* USER CODE BEGIN Header_key_Task */
/**
* @brief Function implementing the KEY thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_key_Task */
void key_Task(void *argument)
{
  /* USER CODE BEGIN key_Task */
  /* Infinite loop */
	uint8_t CPU_RunInfo[400];
	uint8_t key;
  for(;;)
  {
	key=KEY_Scan(0);   //扫描按键 
	if(key == KEY_UP_PRESS)
	{
		memset(CPU_RunInfo,0,sizeof(CPU_RunInfo));
		vTaskList((char *)&amp;CPU_RunInfo);		//获取任务列表
		printf("---------------------------------------------\r\n");
		printf("任务名      任务状态 优先级   剩余栈 任务序号\r\n");
		printf("%s", CPU_RunInfo);
		printf("---------------------------------------------\r\n");

		memset(CPU_RunInfo,0,400);
		vTaskGetRunTimeStats((char *)&amp;CPU_RunInfo);		//获取任务运行状态
		printf("任务名       运行计数         利用率\r\n");
		printf("%s", CPU_RunInfo);
		printf("---------------------------------------------\r\n");
	}
	else if(key == KEY1_PRESS)
	{
		HAL_TIM_Base_Stop_IT(&amp;htim4);
		printf("舵机任务恢复\r\n");
		vTaskResume(SERVOHandle);
		err = 0;
	}
	
	 osDelay(10);
  }
  /* USER CODE END key_Task */
}

/* USER CODE BEGIN Header_Servo_Task */
/**
* @brief Function implementing the SERVO thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_Servo_Task */
void Servo_Task(void *argument)
{
  /* USER CODE BEGIN Servo_Task */
	uint8_t key;
	BaseType_t xReturn = pdPASS;
	uint32_t r_event = 0;
  /* Infinite loop */
  for(;;)
  {
	xReturn = xTaskNotifyWait(0x00,ULONG_MAX,&amp;r_event,portMAX_DELAY);
	if(xReturn == pdTRUE)
	{
		if(r_event | EVENT1| EVENT2 | EVENT3)
		{
			Warn();
			printf("OPEN\r\n");
			Set_Angle(0);
			osDelay(1000);
			Set_Angle(170);
			osDelay(1000);
			err = 0;
		}
	}			
    osDelay(10);
  }
  /* USER CODE END Servo_Task */
}

/* USER CODE BEGIN Header_ESP_Task */
/**
* @brief Function implementing the ESP thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_ESP_Task */
void ESP_Task(void *argument)
{
  /* USER CODE BEGIN ESP_Task */
	ESP8266_Init();
	osStatus_t result;
	BaseType_t xReturn = pdPASS;
  /* Infinite loop */
  for(;;)
  {
    if(USART3_RX_STA)
	{
		if(strstr((const char*)USART3_RX_BUF,"on"))	
		{
			printf("%s\r\n",USART3_RX_BUF);	
			xReturn = xTaskNotify((TaskHandle_t)SERVOHandle,
								  (uint32_t)EVENT2,
								  (eNotifyAction)eSetBits);
			if(xReturn == pdTRUE)	printf("send event2 succeed\r\n");
			else printf("send event2 fail\r\n");
		}
		memset(USART3_RX_BUF,0,sizeof(USART3_RX_BUF));
        USART3_RX_STA = 0;
	}
	  osDelay(1000);
  }
  /* USER CODE END ESP_Task */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */
void Set_Angle(float angle)
{
	int servo_temp;
	if(angle &gt; 180) angle = 180;
	else if(angle &lt; 0) angle = 0;
	servo_temp = angle*2000/180 + 600;
	__HAL_TIM_SET_COMPARE(&amp;htim3,TIM_CHANNEL_1,(uint16_t)servo_temp);
}

//Suspen_Servo
void Suspen_Servo(void)
{
	printf("ERRO:%d",err);
	if(err == 3)
	{
		HAL_TIM_Base_Start_IT(&amp;htim4);
		vTaskSuspend(SERVOHandle);
		printf("舵机任务挂起\r\n");
	}

}
void Warn(void)
{
	HAL_TIM_Base_Start_IT(&amp;htim4);
	osDelay(100);
	HAL_TIM_Base_Stop_IT(&amp;htim4);
	osDelay(100);
	HAL_TIM_Base_Start_IT(&amp;htim4);
	osDelay(100);
	HAL_TIM_Base_Stop_IT(&amp;htim4);
}
/* USER CODE END Application */
</code></pre> 
<p>实验效果同库函数的效果一样 详见<a href="https://blog.csdn.net/qq_45803449/article/details/130632818?spm=1001.2014.3001.5501" title="freeRTOS小项目练习—智能门锁_rtos项目_kedvellek的博客-CSDN博客">freeRTOS小项目练习—智能门锁_rtos项目_kedvellek的博客-CSDN博客</a></p> 
<blockquote> 
 <p>①：学习cubeMX的配置 用于开发STM的确实方便</p> 
 <p>②：HAL库学习，HAL库与标准库比会更加简单感觉</p> 
 <p>③：freeRTOS的进一步了解学习</p> 
 <p>                                                                                                                                23.5.28</p> 
</blockquote> 
<h3 id="%E4%BA%94%E3%80%81%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81">五、完整项目工程代码</h3> 
<p>（用的是普中的PZ6806L开发板）</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf3cfb24899ecc257a8ba5db0c8e385f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">十一、Redis——分布式缓存</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e54cb00defb47751a65285f106af947f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MyabtisPlus（高级查询）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>