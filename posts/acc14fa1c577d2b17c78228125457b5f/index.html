<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>10、RabbitMQ高频面试题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="10、RabbitMQ高频面试题" />
<meta property="og:description" content="1、你们项目中哪里用到了RabbitMQ RabbitMQ是我们项目中服务通信的主要方式之一 , 我们项目中服务通信主要有二种方式实现 :
通过Feign实现服务的同步调用通过MQ实现服务的异步通信 下面要结合自己的项目中功能来说两个地方
xxx
xxx
2、为什么会选择使用RabbitMQ 我们项目中之所以选择使用RabbitMQ，是因为它的功能比较丰富 , 支持各种消息收发模式, 支持延迟队列 , 惰性队列
而且天然支持集群, 保证服务的高可用, 同时性能非常不错 , 社区也比较活跃, 文档资料非常丰富
使用MQ有很多好处，简单跟您说几个：
吞吐量提升：无需等待订阅者处理完成，响应更快速
故障隔离：服务没有直接调用，不存在级联失败问题
调用间没有阻塞，不会造成无效的资源占用
耦合度极低，每个服务都可以灵活插拔，可替换
流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件
当然使用使用MQ也有一些缺点
架构复杂了，业务没有明显的流程线，不好管理需要依赖于Broker的可靠、安全、性能 总之，瑕不掩瑜，使用了RabbitMQ之后可以大大提供程序的效率
3、使用RabbitMQ如何保证消息不丢失 消息从生产者发送到消费者接收，会经历多个过程 , 其中的每一步都可能导致消息丢失
大体可以分为这样几种情况:
消息发送到交换机丢失消息从交换机路由到队列丢失消息保存到队列中丢失消费者消费消息丢失 针对每一步，RabbitMQ分别给出了解决方案：
消息发送到交换机丢失：发布者确认机制
消息发送到交换机失败会向生产者返回失败原因，生产者通过回调接收发送结果，如果发送失败，重新发送，或者记录日志人工介入
消息从交换机路由到队列丢失：发布者回执机制
消息从交换机路由到队列失败会向生产者返回失败原因 ，生产者通过回调接收回调结果，如果发送失败，重新发送，或者记录日志人工介入
消息保存到队列中丢失：MQ持久化
RabbitMQ运行开启交换机持久化、队列持久化、消息持久化，以保证消息在传输过程中不会丢失
消费者消费消息丢失：消费者确认机制
消费者确认机制指的是只有消费者一方确认消息消费成功了，mq才删除消息，否则就会重新发送消息给消费者
通过RabbitMQ本身所提供的机制基本上已经可以保证消息不丢失, 但是因为一些特殊的原因还是会发送消息丢失问题 ,
例如 : 回调丢失 , 系统宕机, 磁盘损坏等 , 这种概率很小 , 但是如果想规避这些问题 , 进一步提高消息发送的成功率, 也可以通过程序自己进行控制
设计一个消息状态表 , 主要包含 : 消息id , 消息内容 , 交换机 , 消息路由key , 发送时间, 签收状态等字段 , 发送方业务执行完毕之后 , 向消息状态表保存一条消息记录, 消息状态为未签收 , 之后再向MQ发送消息 , 消费方接收消息消费完毕之后 , 向发送方发送一条签收消息 , 发送方接收到签收消息之后 , 修改消息状态表中的消息状态为已签收 !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/acc14fa1c577d2b17c78228125457b5f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T21:01:04+08:00" />
<meta property="article:modified_time" content="2023-12-29T21:01:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">10、RabbitMQ高频面试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1RabbitMQ_0"></a>1、你们项目中哪里用到了RabbitMQ</h3> 
<p>RabbitMQ是我们项目中服务通信的主要方式之一 , 我们项目中服务通信主要有二种方式实现 :</p> 
<ol><li>通过Feign实现服务的同步调用</li><li>通过MQ实现服务的异步通信</li></ol> 
<p>下面要结合自己的项目中功能来说两个地方</p> 
<ol><li> <p>xxx</p> </li><li> <p>xxx</p> </li></ol> 
<h3><a id="2RabbitMQ_13"></a>2、为什么会选择使用RabbitMQ</h3> 
<p>我们项目中之所以选择使用RabbitMQ，是因为它的功能比较丰富 , 支持各种消息收发模式, 支持延迟队列 , 惰性队列</p> 
<p>而且天然支持集群, 保证服务的高可用, 同时性能非常不错 , 社区也比较活跃, 文档资料非常丰富</p> 
<p>使用MQ有很多好处，简单跟您说几个：</p> 
<ul><li> <p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p> </li><li> <p>故障隔离：服务没有直接调用，不存在级联失败问题</p> </li><li> <p>调用间没有阻塞，不会造成无效的资源占用</p> </li><li> <p>耦合度极低，每个服务都可以灵活插拔，可替换</p> </li><li> <p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p> </li></ul> 
<p>当然使用使用MQ也有一些缺点</p> 
<ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul> 
<p>总之，瑕不掩瑜，使用了RabbitMQ之后可以大大提供程序的效率</p> 
<h3><a id="3RabbitMQ_35"></a>3、使用RabbitMQ如何保证消息不丢失</h3> 
<p>消息从生产者发送到消费者接收，会经历多个过程 , 其中的每一步都可能导致消息丢失</p> 
<p>大体可以分为这样几种情况:</p> 
<ol><li>消息发送到交换机丢失</li><li>消息从交换机路由到队列丢失</li><li>消息保存到队列中丢失</li><li>消费者消费消息丢失</li></ol> 
<p>针对每一步，RabbitMQ分别给出了解决方案：</p> 
<ol><li> <p>消息发送到交换机丢失：发布者确认机制</p> <p>消息发送到交换机失败会向生产者返回失败原因，生产者通过回调接收发送结果，如果发送失败，重新发送，或者记录日志人工介入</p> </li><li> <p>消息从交换机路由到队列丢失：发布者回执机制</p> <p>消息从交换机路由到队列失败会向生产者返回失败原因 ，生产者通过回调接收回调结果，如果发送失败，重新发送，或者记录日志人工介入</p> </li><li> <p>消息保存到队列中丢失：MQ持久化</p> <p>RabbitMQ运行开启交换机持久化、队列持久化、消息持久化，以保证消息在传输过程中不会丢失</p> </li><li> <p>消费者消费消息丢失：消费者确认机制</p> <p>消费者确认机制指的是只有消费者一方确认消息消费成功了，mq才删除消息，否则就会重新发送消息给消费者</p> </li></ol> 
<p>通过RabbitMQ本身所提供的机制基本上已经可以保证消息不丢失, 但是因为一些特殊的原因还是会发送消息丢失问题 ,</p> 
<p>例如 : 回调丢失 , 系统宕机, 磁盘损坏等 , 这种概率很小 , 但是如果想规避这些问题 , 进一步提高消息发送的成功率, 也可以通过程序自己进行控制<br> <img src="https://images2.imgbox.com/7b/80/EGt7DGMq_o.png" alt="在这里插入图片描述"></p> 
<p>设计一个消息状态表 , 主要包含 : 消息id , 消息内容 , 交换机 , 消息路由key , 发送时间, 签收状态等字段 , 发送方业务执行完毕之后 , 向消息状态表保存一条消息记录, 消息状态为未签收 , 之后再向MQ发送消息 , 消费方接收消息消费完毕之后 , 向发送方发送一条签收消息 , 发送方接收到签收消息之后 , 修改消息状态表中的消息状态为已签收 ! 之后通过定时任务扫描消息状态表中这些未签收的消息 , 重新发送消息, 直到成功为止 , 对于已经完成消费的消息定时清理即可 !</p> 
<h3><a id="4_72"></a>4、消息的重复消费问题如何解决的</h3> 
<p>在使用RabbitMQ进行消息收发的时候，如果发送失败或者消费失败会自动进行重试，那么就有可能会导致消息的重复消费</p> 
<p>解决方案：</p> 
<ul><li>每条消息设置一个唯一的标识id</li><li>幂等方案 
  <ul><li>token+redis</li><li>分布式锁</li><li>数据库锁（悲观锁、乐观锁）</li></ul> </li></ul> 
<h3><a id="5MQ_84"></a>5、如何解决消息堆积在MQ的问题</h3> 
<p>解决消息堆积有几种种思路：</p> 
<ol><li>提高消费者的消费能力，例如使用多线程消费</li><li>增加消费者数量，提高消费速度，可以使用ork队列模式，设置多个消费者消费消费同一个队列中的消息</li><li>扩大队列容积，提高堆积上限</li><li>使用RabbitMQ惰性队列，接收到消息后直接存入磁盘而非内存，消费者要消费消息时才会从磁盘中读取并加载到内存</li></ol> 
<h3><a id="6RabbitMQ_93"></a>6、RabbitMQ如何保证消费的顺序性</h3> 
<p>一个队列只设置一个消费者消费即可 , 多个消费者之间是无法保证消息消费顺序性的</p> 
<h3><a id="7RabbitMQ_97"></a>7、RabbitMQ的延迟队列有了解过嘛</h3> 
<p>RabbitMQ的延迟队列有两种实现方案 :</p> 
<ol><li>使用消息过期TTL + 死信交换机</li><li>使用延迟交换机插件</li></ol> 
<h3><a id="8RabbitMQ_104"></a>8、RabbitMQ如何设置消息过期</h3> 
<p>RabbitMQ设置消息过期的方式有两种 :</p> 
<ol><li> <p>在队列上设置过期时间，所有进到这个队列的消息就会具有统一的过期时间</p> </li><li> <p>为消息单独设置过期时间</p> </li></ol> 
<p>注意 :</p> 
<ol><li>队列过期和消息过期同时存在 , 会以时间短的时间为准</li><li>RabbitMQ队列消息过期的机制是判断队列头部元素是否过期 , 如果队里头部消息没有到过期时间 , 中间消息到了过期时间, 这个消息也不会被自动剔除</li></ol> 
<h3><a id="9_118"></a>9、什么是死信交换机</h3> 
<p>死信交换机和正常的交换机没有什么不同，当一个包含<code>死信</code>的队列使用<code>dead-letter-exchange</code>属性，指定了一个交换机，这个交换机称为死信交换机</p> 
<p>也就是说只有队列中的死信才会流转到死信交换机，而当一个队列中的消息满足下列情况之一时，就会成为死信：</p> 
<ul><li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul> 
<p>一般的死信交换机还会再跟着一个专门的队列，用来专门存储所有的死信，以方便后期的人工干预</p> 
<h3><a id="10RabbitMQ_130"></a>10、RabbitMQ的集群有哪些</h3> 
<p>RabbitMQ天然支持集群模式，它的集群有两种模式：</p> 
<ul><li> <p>普通集群：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力</p> <p>这种集群会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</p> <p>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</p> <p>如果队列所在节点宕机，队列中的消息就会丢失</p> </li><li> <p>镜像集群：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。</p> <p>这种集群模式下，交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份</p> <p>创建队列的节点被称为该队列的主节点，备份到的其它节点叫做该队列的镜像节点。</p> <p>一个队列的主节点可能是另一个队列的镜像节点</p> <p>所有操作都是主节点完成，然后同步给镜像节点</p> <p>主宕机后，镜像节点会替代成新的主</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74f1fb039117716b0bcd2a59bd1cf341/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">虚幻UE 材质-材质基础</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a416805a71200eb20abb820b9c63cc3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ref 系列 UniRef&#43;&#43;: Segment Every Reference Object in Spatial and Temporal Spaces 论文阅读笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>