<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;知识点43——解引用运算符和箭头运算符的重载及智能指针类的实现 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;知识点43——解引用运算符和箭头运算符的重载及智能指针类的实现" />
<meta property="og:description" content="一、概念、
在自定义行为类似指针的类时，需要重载*和-&gt;。C&#43;&#43;中的智能指针就重载了这两个运算符。-&gt;必须是成员函数，*也应该是成员函数。与内置类型保持一致，这两个函数通常都是const的。以为*和-&gt;通常不会也不应该改变对象的状态
*运算符的返回值通常都是一个类型的引用（因为类内部的数据不一定非得指向T的对象，也可能指向一个T的派生类对象。如果是这样并且operator*返回的是个T对象，而非一个引用（代表真正的派生类对象），那么，operator*函数便是返回一个错误类型的对象！，也就是导致子类对象转基类对象的切割问题）
-&gt;运算符的返回值必须是一个类的指针。因为当自定义类型的operator-&gt;被调用时，编译器会将operator-&gt;转化为
(obejct.operator-&gt;())-&gt;member 所以，operator-&gt;的返回值必须是一个指针
二、示例
通过实现一个智能指针来熟悉这两个运算符的重载，类的整体实现如下
#include &lt;iostream&gt; #include &lt;memory&gt; using namespace std; template &lt;typename T&gt; class mysmartpointer { public: mysmartpointer(T *ptr=nullptr): ptr_(ptr), pcount_(new size_t(0)) { cout&lt;&lt;__func__&lt;&lt;endl; if (ptr_==nullptr) {//空指针不增加引用计数 *(this-&gt;pcount_)=0; } else { *(this-&gt;pcount_)=1; } } mysmartpointer(const mysmartpointer &amp;rval): ptr_(rval.ptr_), pcount_(rval.pcount_) { if (ptr_) {//拷贝初始化，如果指针不为空，增加引用计数 &#43;&#43;*pcount_; } cout&lt;&lt;&#34;mysmartpointer(const mysmartpointer &amp;rval)&#34;&lt;&lt;endl; } mysmartpointer &amp;operator=(const mysmartpointer &amp;rval) { cout&lt;&lt;__func__&lt;&lt;endl; mysmartpointer t(rval); this-&gt;swap(t); --*pcount_;//减少左值的引用计数 if (*pcount_==0) {//此时如果引用计数为0，那么释放指向的对象和引用计数 cout&lt;&lt;&#34;delete object when operator=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/85bd467a163d0b3c206f7972f7e54a3d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-07T15:43:14+08:00" />
<meta property="article:modified_time" content="2020-11-07T15:43:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;知识点43——解引用运算符和箭头运算符的重载及智能指针类的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0pt;">一、概念、</p> 
<p style="margin-left:0pt;">在自定义行为类似指针的类时，需要重载*和-&gt;。C++中的智能指针就重载了这两个运算符。-&gt;必须是成员函数，*也应该是成员函数。与内置类型保持一致，这两个函数通常都是const的。以为*和-&gt;通常不会也不应该改变对象的状态</p> 
<p style="margin-left:0pt;">*运算符的返回值通常都是一个类型的引用（因为类内部的数据不一定非得指向T的对象，也可能指向一个T的派生类对象。如果是这样并且operator*返回的是个T对象，而非一个引用（代表真正的派生类对象），那么，operator*函数便是返回一个错误类型的对象！，也就是导致子类对象转基类对象的切割问题）</p> 
<p style="margin-left:0pt;">-&gt;运算符的返回值必须是一个类的指针。因为当自定义类型的operator-&gt;被调用时，编译器会将operator-&gt;转化为</p> 
<pre><code class="language-cpp">(obejct.operator-&gt;())-&gt;member</code></pre> 
<p style="margin-left:0pt;">所以，operator-&gt;的返回值必须是一个指针</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">二、示例</p> 
<p style="margin-left:0pt;">通过实现一个智能指针来熟悉这两个运算符的重载，类的整体实现如下</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

using namespace std;

template &lt;typename T&gt;
class mysmartpointer
{
public:
	mysmartpointer(T *ptr=nullptr):
	 ptr_(ptr),
	 pcount_(new size_t(0))
	{
		cout&lt;&lt;__func__&lt;&lt;endl;
		if (ptr_==nullptr) {//空指针不增加引用计数
			*(this-&gt;pcount_)=0;
		}
		else {
			*(this-&gt;pcount_)=1;
		}
	}

	mysmartpointer(const mysmartpointer &amp;rval):
	ptr_(rval.ptr_),
	pcount_(rval.pcount_)
	{
		if (ptr_) {//拷贝初始化，如果指针不为空，增加引用计数
			++*pcount_;
		}
		cout&lt;&lt;"mysmartpointer(const mysmartpointer &amp;rval)"&lt;&lt;endl;
	}
	
	mysmartpointer &amp;operator=(const mysmartpointer &amp;rval)
	{
		cout&lt;&lt;__func__&lt;&lt;endl;
		mysmartpointer t(rval);
		this-&gt;swap(t);
		--*pcount_;//减少左值的引用计数
		if (*pcount_==0) {//此时如果引用计数为0，那么释放指向的对象和引用计数
			cout&lt;&lt;"delete object when operator="&lt;&lt;endl;
			delete ptr_;
			delete pcount_;
		}
		++*rval.pcount_;//增加右值的引用计数
		return *this;
	}

	T &amp;operator*() const
	{
		cout&lt;&lt;__func__&lt;&lt;endl;
		return *ptr_;//返回指向对象本身
	}

	T *operator-&gt;() const
	{
		cout&lt;&lt;__func__&lt;&lt;endl;
		return &amp;this-&gt;operator*();//通过调用operator*来实现operator-&gt;
	}

	explicit operator bool()
	{
		cout&lt;&lt;__func__&lt;&lt;endl;
		return !(ptr_==nullptr &amp;&amp; *pcount_==0);
	}

	void swap(mysmartpointer &amp;t)//交换指针和引用计数
	{
		cout&lt;&lt;__func__&lt;&lt;endl;
		std::swap(this-&gt;ptr_, t.ptr_);
		std::swap(this-&gt;pcount_, t.pcount_);
	}

	size_t use_count()
	{
		cout&lt;&lt;__func__&lt;&lt;endl;
		return *pcount_;
	}

	~mysmartpointer()
	{
		cout&lt;&lt;__func__&lt;&lt;endl;
		if (--*pcount_==0) {//析构时，--引用计数
			cout&lt;&lt;"delete object"&lt;&lt;endl;
			delete ptr_;
			delete pcount_;
		}
	}
	
private:
	T *ptr_;
	size_t *pcount_;
};</code></pre> 
<p>上述代码中，operator-&gt;的实现使用过operator*来实现。这两个函数一般只实现一个，另一个直接调用即可</p> 
<p style="margin-left:0pt;">该类中引用计数是采用指针的方式实现的，当对智能指针进行赋值、拷贝时，可以利用指针的特性让两个对象的引用计数同时指向一块内存，共享引用计数</p> 
<p style="margin-left:0pt;">operator=的实现也是采用swap方式，避免重新分配内存，而且可以处理自赋值的情况</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">测试</p> 
<pre><code class="language-cpp">int main(int argc, char const *argv[])
{
	mysmartpointer&lt;string&gt; spstr1(new string("1234"));
	mysmartpointer&lt;string&gt; spstr2=spstr1;
	cout&lt;&lt;spstr1.use_count()&lt;&lt;endl;
	cout&lt;&lt;spstr2.use_count()&lt;&lt;endl;
	cout&lt;&lt;"------"&lt;&lt;endl;
	mysmartpointer&lt;string&gt; spstr3;
	spstr3=spstr1;
	spstr1=spstr1;
	cout&lt;&lt;spstr3.use_count()&lt;&lt;endl;
	cout&lt;&lt;spstr1.use_count()&lt;&lt;endl;
	cout&lt;&lt;spstr2.use_count()&lt;&lt;endl;
	cout&lt;&lt;spstr1-&gt;size()&lt;&lt;endl;
	if (spstr1) {
		cout&lt;&lt;"spstr1 is not nullptr"&lt;&lt;endl;
	}
	return 0;
}</code></pre> 
<p style="margin-left:0pt;"><img alt="" height="426" src="https://images2.imgbox.com/0b/6a/RnnAvrPE_o.png" width="553"></p> 
<p style="margin-left:0pt;"> </p> 
<p>参考</p> 
<p>《C++ Primer》</p> 
<p>《More Effective C++》</p> 
<p> </p> 
<p>欢迎大家评论交流，作者水平有限，如有错误，欢迎指出</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7d60d8b7ad2217a911d933aa73150a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【ros学习】13.URDF机器人建模详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/18a8d773503743fda6663b673e5e790b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java学习笔记 面向对象（上）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>