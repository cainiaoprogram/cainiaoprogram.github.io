<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[Opengl]图形学final_project作业记录 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[Opengl]图形学final_project作业记录" />
<meta property="og:description" content="文章目录 提示信息a.函数1、2、4、5b.函数3c.注意代码复用d.程序运行截图e.操作界面 半边数据结构VS小技巧查找查看定义查找所有引用 1. 计算三角网格中每个三角形的面积 (10分)题目说明算法思想代码示例 2. 计算三角网格中每个顶点(vertex)的法向 (20分)题目说明算法思想代码示例 3. 用OpenGL把三角网格中每个三角形面片的法向画出来（在每个三角面片的重心处画） (20分)题目说明算法思想代码示例ogl_writer() 算法思想 4. 实现一种三角网格去噪算法(30分)题目说明算法思想代码示例 5. （可选/可做可不做）实现一种基于三角网格的操作（例如，特征点/边提取，给三角网格添加随机高斯噪声，求三角网格每个顶点的高斯曲率，三角网格简化，三角网格四边形化等等） (20分)题目说明算法思想代码示例 本次结课大作业5个题目，最后一道题为选做题。老师给的原项目非常复杂，得仔细研究，在这之前还得了解C&#43;&#43;的语法，特别是标准库的一些功能，函数等，可参考我写的一点内容(C&#43;&#43;模板、命名空间)：
模板.
命名空间.
另外，好好阅读文档“final_project作业题2020.docx”，还有课件PPT“计算机图形学8-2020-第二学期”，有对本项目的简单介绍。
配置环境我也有博客介绍：环境配置.
提示信息 a.函数1、2、4、5 其中1. 2. 4. 5的函数声明在 mesh/extension/ExKernelT.h(截图如下)
函数实现请在mesh/extension/ExkernelT.cpp中完成 (务必)
b.函数3 b. 其中3的函数声明在read_write/read_write.h
函数实现请在read_write/read_write.cpp中完成 (务必)
c.注意代码复用 请把整个代码看明白，里面实现了各种基本操作，例如求三角网格中每个三角形的重心、求每个三角面片的法向等等。
d.程序运行截图 如下：
e.操作界面 鼠标点击右键，会出现一个操作界面，里面有一些灯光和其他绘制效果。
半边数据结构 定义如下：
简单来说，半边有方向，一条边由两个半边组成，一个面片唯一对应三个半边，如下图：
黑色的三个半边仅属于蓝色的面片，而绿色的半边不属于。如果一条半边不属于任何面片，那么该半边称作边界半边，并配有相关函数(KernelT.h)：
半边之间可以相互转换，半边①可以使用函数prev_halfedge_handle()，得到半边③；还可以使用函数next_halfedge_handle()，得到半边②；或者使用函数opposite_halfedge_handle()得到半边④；(如下图)
顶点可以通过函数halfedge_handle_，得到一条半边，该半边指向该顶点。
其余的就不一一介绍了。
VS小技巧 查找 本项目过于复杂，经常找不到函数位置，所以“查找”功能使用的比较多，快捷键为==“Ctrl &#43; F”==，并且我常常使用“在项目中查找”，因为常常会出现在意想不到的文件中。
查看定义 注意代码复用，例如老师已经完成了边长计算函数：
(鼠标拖动选择函数，点击右键，转到“查看定义”；)
(得到如下小窗口提示：)
重点关注函数名，输入参数以及返回参数类型。老师写的函数名比较规范，见名知意，用来计算边的长度，需要输入 EdgeHandle 类型的参数，返回的长度是浮点数类型的。以后还有很多的函数、变量等通过“查看定义”的方式弄清楚其含义。
(有可能“查看定义”会找不到什么实质性东西，建议用第一种“查找”来解决)
查找所有引用 鼠标拖动选择函数，点击右键，转到“查找所有引用”：
在下方弹出提示信息：
找到项目调用它的地方。
1. 计算三角网格中每个三角形的面积 (10分) 题目说明 此函数已经被声明为：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/deeebc9646bb42f34b3f3ba42b4de2b3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-16T14:50:26+08:00" />
<meta property="article:modified_time" content="2020-12-16T14:50:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[Opengl]图形学final_project作业记录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_8" rel="nofollow">提示信息</a></li><li><ul><li><a href="#a1245_9" rel="nofollow">a.函数1、2、4、5</a></li><li><a href="#b3_13" rel="nofollow">b.函数3</a></li><li><a href="#c_18" rel="nofollow">c.注意代码复用</a></li><li><a href="#d_21" rel="nofollow">d.程序运行截图</a></li><li><a href="#e_24" rel="nofollow">e.操作界面</a></li></ul> 
  </li><li><a href="#_28" rel="nofollow">半边数据结构</a></li><li><a href="#VS_45" rel="nofollow">VS小技巧</a></li><li><ul><li><a href="#_46" rel="nofollow">查找</a></li><li><a href="#_49" rel="nofollow">查看定义</a></li><li><a href="#_58" rel="nofollow">查找所有引用</a></li></ul> 
  </li><li><a href="#1%09_10_66" rel="nofollow">1. 计算三角网格中每个三角形的面积 (10分)</a></li><li><ul><li><a href="#_67" rel="nofollow">题目说明</a></li><li><a href="#_74" rel="nofollow">算法思想</a></li><li><a href="#_82" rel="nofollow">代码示例</a></li></ul> 
  </li><li><a href="#2%09vertex_20_136" rel="nofollow">2. 计算三角网格中每个顶点(vertex)的法向 (20分)</a></li><li><ul><li><a href="#_137" rel="nofollow">题目说明</a></li><li><a href="#_144" rel="nofollow">算法思想</a></li><li><a href="#_169" rel="nofollow">代码示例</a></li></ul> 
  </li><li><a href="#3%09OpenGL_20_200" rel="nofollow">3. 用OpenGL把三角网格中每个三角形面片的法向画出来（在每个三角面片的重心处画） (20分)</a></li><li><ul><li><a href="#_201" rel="nofollow">题目说明</a></li><li><a href="#_205" rel="nofollow">算法思想</a></li><li><a href="#_229" rel="nofollow">代码示例</a></li><li><ul><li><a href="#ogl_writer__316" rel="nofollow">ogl_writer() 算法思想</a></li></ul> 
  </li></ul> 
  </li><li><a href="#4%0930_321" rel="nofollow">4. 实现一种三角网格去噪算法(30分)</a></li><li><ul><li><a href="#_322" rel="nofollow">题目说明</a></li><li><a href="#_330" rel="nofollow">算法思想</a></li><li><a href="#_336" rel="nofollow">代码示例</a></li></ul> 
  </li><li><a href="#5%09_20_384" rel="nofollow">5. （可选/可做可不做）实现一种基于三角网格的操作（例如，特征点/边提取，给三角网格添加随机高斯噪声，求三角网格每个顶点的高斯曲率，三角网格简化，三角网格四边形化等等） (20分)</a></li><li><ul><li><a href="#_386" rel="nofollow">题目说明</a></li><li><a href="#_388" rel="nofollow">算法思想</a></li><li><a href="#_397" rel="nofollow">代码示例</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>本次结课大作业5个题目，最后一道题为选做题。老师给的原项目非常复杂，得仔细研究，在这之前还得了解C++的语法，特别是标准库的一些功能，函数等，可参考我写的一点内容(C++模板、命名空间)：<br> <a href="https://blog.csdn.net/weixin_44092088/article/details/110749654">模板</a>.<br> <a href="https://blog.csdn.net/weixin_44092088/article/details/110749637">命名空间</a>.<br> 另外，好好阅读文档“final_project作业题2020.docx”，还有课件PPT“计算机图形学8-2020-第二学期”，有对本项目的简单介绍。<br> 配置环境我也有博客介绍：<a href="https://blog.csdn.net/weixin_44092088/article/details/109450850">环境配置</a>.</p> 
<h2><a id="_8"></a>提示信息</h2> 
<h3><a id="a1245_9"></a>a.函数1、2、4、5</h3> 
<p>其中1. 2. 4. 5的函数声明在 <code>mesh/extension/ExKernelT.h</code>(截图如下)<br> 函数实现请在<code>mesh/extension/ExkernelT.cpp</code>中完成 (务必)<br> <img src="https://images2.imgbox.com/a5/a1/CLu7sz07_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="b3_13"></a>b.函数3</h3> 
<p>b. 其中3的函数声明在<code>read_write/read_write.h</code><br> 函数实现请在<code>read_write/read_write.cpp</code>中完成 (务必)<br> <img src="https://images2.imgbox.com/f1/43/TLYnBuVN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="c_18"></a>c.注意代码复用</h3> 
<p>请把整个代码看明白，里面实现了各种基本操作，例如求三角网格中每个三角形的重心、求每个三角面片的法向等等。</p> 
<h3><a id="d_21"></a>d.程序运行截图</h3> 
<p>如下：<br> <img src="https://images2.imgbox.com/bb/8f/92IaSWgH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="e_24"></a>e.操作界面</h3> 
<p>鼠标点击右键，会出现一个操作界面，里面有一些灯光和其他绘制效果。</p> 
<p><img src="https://images2.imgbox.com/b7/a1/WLON5PzE_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_28"></a>半边数据结构</h2> 
<p><img src="https://images2.imgbox.com/b2/8f/zYmaMZUN_o.png" alt="在这里插入图片描述"><br> 定义如下：<br> <img src="https://images2.imgbox.com/a8/30/DpSMTI5a_o.png" alt="在这里插入图片描述"><br> 简单来说，半边有方向，一条边由两个半边组成，一个面片<mark>唯一</mark>对应三个半边，如下图：<br> <img src="https://images2.imgbox.com/a9/5e/iTYmmhpE_o.png" alt="在这里插入图片描述"><br> 黑色的三个半边仅属于蓝色的面片，而绿色的半边不属于。如果一条半边不属于任何面片，那么该半边称作<mark>边界半边</mark>，并配有相关函数(<code>KernelT.h</code>)：<br> <img src="https://images2.imgbox.com/cb/8a/NfZ1z49n_o.png" alt="在这里插入图片描述"><br> 半边之间可以相互转换，半边①可以使用函数<code>prev_halfedge_handle()</code>，得到半边③；还可以使用函数<code>next_halfedge_handle()</code>，得到半边②；或者使用函数<code>opposite_halfedge_handle()</code>得到半边④；(如下图)<br> <img src="https://images2.imgbox.com/a7/f2/dY9q2UzB_o.png" alt="在这里插入图片描述"></p> 
<p>顶点可以通过函数<code>halfedge_handle_</code>，得到一条半边，该半边指向该顶点。<br> <img src="https://images2.imgbox.com/f6/aa/yZZROTtW_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/bc/1f/0EAXsaYA_o.png" alt="在这里插入图片描述"><br> 其余的就不一一介绍了。</p> 
<h2><a id="VS_45"></a>VS小技巧</h2> 
<h3><a id="_46"></a>查找</h3> 
<p>本项目过于复杂，经常找不到函数位置，所以“查找”功能使用的比较多，快捷键为==“Ctrl + F”==，并且我常常使用“在项目中查找”，因为常常会出现在意想不到的文件中。<br> <img src="https://images2.imgbox.com/c2/89/ByMzWDf2_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_49"></a>查看定义</h3> 
<p>注意代码复用，例如老师已经完成了边长计算函数：<br> (鼠标拖动选择函数，点击右键，转到“查看定义”；)<br> <img src="https://images2.imgbox.com/bb/40/BizCI6en_o.png" alt="在这里插入图片描述"><br> (得到如下小窗口提示：)<img src="https://images2.imgbox.com/cf/8f/QHiqi30o_o.png" alt="在这里插入图片描述"><br> 重点关注函数名，输入参数以及返回参数类型。老师写的函数名比较规范，见名知意，用来计算边的长度，需要输入 <strong>EdgeHandle</strong> 类型的参数，返回的长度是浮点数类型的。以后还有很多的函数、变量等通过“查看定义”的方式弄清楚其含义。<br> (有可能“查看定义”会<strong>找不到</strong>什么实质性东西，建议用第一种“查找”来解决)</p> 
<h3><a id="_58"></a>查找所有引用</h3> 
<p>鼠标拖动选择函数，点击右键，转到“查找所有引用”：<br> <img src="https://images2.imgbox.com/00/ed/pVCjokcV_o.png" alt="在这里插入图片描述"><br> 在下方弹出提示信息：<br> <img src="https://images2.imgbox.com/dc/ce/pVH7DKEw_o.jpg" alt="在这里插入图片描述"><br> 找到项目调用它的地方。</p> 
<h2><a id="1%09_10_66"></a>1. 计算三角网格中每个三角形的面积 (10分)</h2> 
<h3><a id="_67"></a>题目说明</h3> 
<p>此函数已经被声明为：</p> 
<pre><code class="prism language-C++">Scalar calc_facet_area(const FacetHandle&amp; _fh); //给定一个三角面片，计算它的面积
</code></pre> 
<p>Tips: 可以根据程序输出结果判定是否计算正确，例如，输入模型cow.off，它的所有三角形面片中，面积最大的三角形面片的面积为：The maximal area of the mesh is: 0.0494426</p> 
<h3><a id="_74"></a>算法思想</h3> 
<p>想办法计算出三角形三边长，再利用海伦公式。<br> 变量类型转化过程：<br> <strong>FacetHandle</strong> -&gt; <strong>HalfedgeHandle</strong> -&gt; <strong>EdgeHandle</strong> -&gt; <strong>double</strong> ;<br> <strong>面片</strong> -&gt; <strong>半边句柄</strong> -&gt; <strong>边句柄</strong> -&gt; <strong>边长</strong></p> 
<p><strong>调用</strong>了老师已经写好的 <code>calc_edge_length</code>函数。</p> 
<h3><a id="_82"></a>代码示例</h3> 
<pre><code class="prism language-C++">	template&lt;class ExItems&gt;
	typename ExKernelT&lt;ExItems&gt;::Scalar
		ExKernelT&lt;ExItems&gt;::calc_facet_area(const FacetHandle&amp; _fh)
	{
		/计算三角形的面积
		float a, b, c, p;//a, b, c 为三角形三边长

		///得到半边句柄
		HalfedgeHandle&amp; half1 = halfedge_handle(_fh);			//这样使用变量的引用效率高
		HalfedgeHandle&amp; half2 = next_halfedge_handle(half1);
		HalfedgeHandle&amp; half3 = next_halfedge_handle(half2);
		由半边句柄得到边句柄
		EdgeHandle&amp; edge1 = edge_handle(half1);
		EdgeHandle&amp; edge2 = edge_handle(half2);
		EdgeHandle&amp; edge3 = edge_handle(half3);
		由边句柄得到各边长
		a = calc_edge_length(edge1);
		b = calc_edge_length(edge2);
		c = calc_edge_length(edge3);

		利用海伦公式求面积s=sqrt(p(p-a)(p-b)(p-c))
		Scalar area = 0.0;
		p = (a + b + c) / 2.0;
		area = sqrt(p*(p - a)*(p - b)*(p - c));

		facet_ref(_fh).area_ = area;
		return area;
	}
</code></pre> 
<p>代码末尾的 <code>facet_ref()</code>函数，输入 <strong>FacetHandle</strong> 类型的参数，返回 <strong>Facet</strong> (面片) 类型。会发现有许许多多名字里带 <mark>Handle</mark>的东西，这玩意就像 <code>iterator</code>(迭代器)，也可以理解为指针。<br> <img src="https://images2.imgbox.com/1d/25/kqnxBdZI_o.png" alt="在这里插入图片描述"><br> (<code>KernelT.h</code>)<br> 有 handlle , 有 iterator，虽然我傻傻分不清。。。<br> <img src="https://images2.imgbox.com/4d/18/DVYxIekW_o.png" alt="在这里插入图片描述"></p> 
<p><code>facet_ref(_fh).area_ = area;</code>这一行代码的意思是：将计算好的面积赋值给该面片对象的<code>area_</code>属性；<br> <img src="https://images2.imgbox.com/9e/41/5ZqdWi8y_o.png" alt="在这里插入图片描述"><br> <code>area_</code>定义如下：<br> <img src="https://images2.imgbox.com/9c/d7/djepo335_o.png" alt="在这里插入图片描述"></p> 
<p><strong>注意</strong>，不要被函数名前面那一大堆奇奇怪怪的东西吓住了，那些带尖括号的 “&lt;…&gt;” 是<strong>模板</strong>，相当于我现在要把模板里面设置成什么参数；那些带2个冒号的“::”，是和命名空间有关，就相当于我现在要调用哪片区域里的那些东西。所以函数名就只有短短一小句：<code>calc_facet_area</code><br> (不瞒你说，好多小傻瓜第一次看到这块，压根就不知道函数名到底是啥，(～￣▽￣)～ )<br> 再把那又臭又长的东西拖出来：<br> <code>template&lt;class ExItems&gt;</code><br> <code>typename ExKernelT&lt;ExItems&gt;::</code><mark>Scalar</mark><br> <code>ExKernelT&lt;ExItems&gt;::</code><mark>calc_facet_area</mark><code>(const</code><mark>FacetHandle</mark><code>&amp; _fh)</code><br> 返回类型：<mark>Scalar</mark><br> 函数名：<mark>calc_facet_area</mark><br> 输入类型：<mark>FacetHandle</mark></p> 
<h2><a id="2%09vertex_20_136"></a>2. 计算三角网格中每个顶点(vertex)的法向 (20分)</h2> 
<h3><a id="_137"></a>题目说明</h3> 
<p>此函数已经被声明为：</p> 
<pre><code class="prism language-C++">inline Normal calc_normal(const VertexHandle&amp; _vh);///计算顶点的法向值
</code></pre> 
<p>Tips: 注意法向要归一化。</p> 
<h3><a id="_144"></a>算法思想</h3> 
<p>把当前顶点周围面片的法向加起来，求平均，就是当前顶点的法向。<br> 有条件了可以来个加权平均，例如以面片面积为权重(我没有实现。。)</p> 
<p><strong>调用函数</strong><code>calc_normal</code>(另一个同名函数)<br> 计算面片法向量，输入面片迭代器<code>FacetHandle</code>，返回法向量<code>Normal</code></p> 
<pre><code class="prism language-C++">	template &lt;class ExItems&gt; 
	typename ExKernelT&lt;ExItems&gt;::Normal
		ExKernelT&lt;ExItems&gt;::calc_normal(const FacetHandle&amp; _fh) {
			assert( _fh.is_valid() );
			assert( _fh.idx() &lt; facet_size() );

			const HalfedgeHandle&amp;   hh = halfedge_handle(_fh);
			const HalfedgeHandle&amp; p_hh = prev_halfedge_handle(hh);
			const HalfedgeHandle&amp; n_hh = next_halfedge_handle(hh);

			const Coord&amp; cd0 = coord( vertex_handle( hh) );
			const Coord&amp; cd1 = coord( vertex_handle(p_hh) );
			const Coord&amp; cd2 = coord( vertex_handle(n_hh) );

			//return ((cd1-cd0)%(cd2-cd1)).normalize();
			return ((cd2-cd1)%(cd1-cd0)).normalize();//两个向量叉乘并且单位化 be careful
	}
</code></pre> 
<h3><a id="_169"></a>代码示例</h3> 
<pre><code class="prism language-C++">template &lt;class ExItems&gt; 
	typename ExKernelT&lt;ExItems&gt;::Normal
		ExKernelT&lt;ExItems&gt;::calc_normal(const VertexHandle&amp; _vh) {更新一个顶点的法向
			assert( _vh.is_valid());
			assert( _vh.idx() &lt; vertex_size() );

			Normal          norm(1,1,1);///用norm存储求得的法向值

//在此实现
			//最简单最不负责的一种做法啦
			HalfedgeHandle half1, half2, half3;
			FacetHandle face;

			half1 = halfedge_handle(_vh);
			face = facet_handle(half1);
			
			norm = norm + calc_normal(face);
			half2 = next_halfedge_handle(half1); //1.
			half2 = opposite_halfedge_handle(half2); //1.//
			while (half2 != half1)
			{
				face = facet_handle(half2);
				norm = norm + calc_normal(face);//把每个面的法向加起来
				half2 = next_halfedge_handle(half2);
				half2 = opposite_halfedge_handle(half2); //1.//
			}
</code></pre> 
<h2><a id="3%09OpenGL_20_200"></a>3. 用OpenGL把三角网格中每个三角形面片的法向画出来（在每个三角面片的重心处画） (20分)</h2> 
<h3><a id="_201"></a>题目说明</h3> 
<p>此函数已经被声明为：<code>bool ogl_writer2(bool _orient = true, bool _smooth = false);</code><br> Tips: 可以参照函数<code>bool ogl_writer(bool _orient = true, bool _smooth = false)</code>的来实现，这时只需要在每个三角形面片中画出法向即可（法向用Line表示，也可以在绘制出的直线上加上箭头（代表方向）。按键盘上”m”可以查看画出面片法向后的结果。）</p> 
<h3><a id="_205"></a>算法思想</h3> 
<p>遍历每一块三角面片，画出重心，画出由重心加上法向量到达的点，使用<code>glBegin(GL_LINES);</code>，自动连成线，法向量显示完成；<br> 注意，这里只是单纯画出来了法向量，记得加上<code>ogl_writer()</code>把本体也画出来，要不然你就会得到一堆针漂浮在半空中。另外，画出的法向量长度可以自行调整，要看着舒服，可通过除以一个整数来解决。</p> 
<p><img src="https://images2.imgbox.com/be/76/LNyjeUsP_o.png" alt="在这里插入图片描述"><br> <strong>调用函数</strong>：<code>calc_centroid()</code><br> 输入面片迭代器类型<code>FacetHandle</code>，输出<code>Coord</code>(坐标)类型；</p> 
<pre><code class="prism language-C++">	template&lt;class ExItems&gt;
	typename ExKernelT&lt;ExItems&gt;::Coord
		ExKernelT&lt;ExItems&gt;::calc_centroid(const FacetHandle&amp; _fh)//求重心
	{

		HalfedgeHandle&amp; hh = halfedge_handle(_fh);
		HalfedgeHandle&amp; n_hh = next_halfedge_handle(hh);
		HalfedgeHandle&amp; pre_hh = prev_halfedge_handle(hh);

		VertexHandle&amp; vh = vertex_handle(hh);
		VertexHandle&amp; n_vh = vertex_handle(n_hh);
		VertexHandle&amp; pre_vh = vertex_handle(pre_hh);

		return Coord(coord(vh) + coord(n_vh) + coord(pre_vh)) / 3.0;
	}
</code></pre> 
<h3><a id="_229"></a>代码示例</h3> 
<pre><code class="prism language-C++">	template &lt;class Mesh&gt;
	bool ReaderWriterT&lt;Mesh&gt;::ogl_writer2(bool _orient, bool _smooth)//画出法向量
	{
		//在里面把三角面片法向画出
		HalfedgeHandle       half;
		Mesh::FacetIterator  face_it(mesh_-&gt;facet_begin());//初始面片，既然是 "iterator" 那我就把它当作一个指针呗
		bool orient;
		FacetHandle face;
		float blue[] = { 0, 0, 1.0, 0.8 };
		
		reader.ogl_writer(0, 1);   //这里加了一个，就把原本的画出来啦

		glShadeModel(GL_SMOOTH);
		orient = true;
		mesh_-&gt;update_normals();
		
		for (; face_it != mesh_-&gt;facet_end(); face_it++)//遍历所有的面
		{
			if ((*face_it).status_.is_deleted())	//跳过已经被删除的
			{
				continue;
			}
			half = face_it-&gt;halfedge_handle_;	//当前半边
			face = mesh_-&gt;facet_handle(half); //所在面片
			const VertexHandle&amp; vertex0 = mesh_-&gt;vertex_handle(half);//当前半边顶点

			glMaterialfv(GL_FRONT, GL_AMBIENT, blue);
			glBegin(GL_LINES);	//画直线
			do {
				const VertexHandle&amp; vertex = mesh_-&gt;vertex_handle(half);//当前顶点
				half = mesh_-&gt;next_halfedge_handle(half);			//下一个半边
				//先画重心，再画法向
				glVertex3fv(mesh_-&gt;calc_centroid(face));//重心
				glVertex3fv(mesh_-&gt;calc_centroid(face) + mesh_-&gt;normal(face) / 2.0); //重心+法向 -&gt; 上端点 (你给我短一点)
				
			} while (half != face_it-&gt;halfedge_handle_);//把当前面片的半边都遍历完
			glEnd();
			glFlush();
		}

		return true;
	}
</code></pre> 
<p>这里我们走一个捷径，在函数<code>ogl_writer2()</code>上方，老师已经实现了它的兄弟函数<code>ogl_writer()</code>，它是用来画出<code>.off</code>文件存储的3D物体的。先研究研究，再模仿就好了，(我不会告诉你我就只改动了两三行。。。)</p> 
<pre><code class="prism language-C++">	//把这个函数看懂就可以啦，就可以写下边的了
	template &lt;class Mesh&gt;
	bool ReaderWriterT&lt;Mesh&gt;::ogl_writer(bool _orient, bool _smooth) //画出原图形
	{
		HalfedgeHandle       half;
		Mesh::FacetIterator  face_it(mesh_-&gt;facet_begin());
		float green[] = { 0, 1.0, 0.0, 0.8 };

		//glShadeModel(GL_FLAT);
		glShadeModel(GL_SMOOTH);
		int orient = true;//orient 朝向
		// (_orient) ? 1 : -1; 
		mesh_-&gt;update_normals();

		for (; face_it != mesh_-&gt;facet_end(); face_it++)
		{
			if ((*face_it).status_.is_deleted())
			{
				continue;
			}
			half = face_it-&gt;halfedge_handle_;
			FacetHandle face = mesh_-&gt;facet_handle(half);
			const VertexHandle&amp; vertex0 = mesh_-&gt;vertex_handle(half);
			glMaterialfv(GL_FRONT, GL_AMBIENT, green);
			glBegin(GL_TRIANGLES);
			do {
				const VertexHandle&amp; vertex = mesh_-&gt;vertex_handle(half);

				glNormal3fv(mesh_-&gt;normal(face)*orient);
				glVertex3fv(mesh_-&gt;coord(vertex));
				half = mesh_-&gt;next_halfedge_handle(half);
			} while (half != face_it-&gt;halfedge_handle_);
			glEnd();
		}

		return true;
	}
</code></pre> 
<h4><a id="ogl_writer__316"></a>ogl_writer() 算法思想</h4> 
<p>遍历每一块面片，画出三角面片的每一个点，使用<code>glBegin(GL_TRIANGLES);</code>，自动连接成三角形；</p> 
<h2><a id="4%0930_321"></a>4. 实现一种三角网格去噪算法(30分)</h2> 
<h3><a id="_322"></a>题目说明</h3> 
<p>（例如Laplacian smoothing （全局或者局部Laplacian Smoothing），全局双边滤波 (bilateral mesh denoising “Shachar Fleishman, Iddo Drori, Daniel Cohen-Or: Bilateral mesh denoising. ACM Trans. Graph. 22(3): 950-953 (2003)” 或者 bilateral normal filtering for mesh denoising “Youyi Zheng, Hongbo Fu, Oscar Kin-Chung Au, Chiew-Lan Tai: Bilateral Normal Filtering for Mesh Denoising. IEEE Trans. Vis. Comput. Graph. 17(10): 1521-1530 (2011)”)，引导双边滤波(guided mesh normal filtering, “Wangyu Zhang, Bailin Deng, Juyong Zhang, Sofien Bouaziz, Ligang Liu: Guided Mesh Normal Filtering. Comput. Graph. Forum 34(7): 23-34 (2015)”), L0方法” Lei He, Scott Schaefer: Mesh denoising via L0 minimization. ACM Trans. Graph. 32(4): 64:1-64:8 (2013)”等等）</p> 
<p>此函数声明为：</p> 
<pre><code class="prism language-C++">void Laplacian_Smoothing();//实现一种三角网格去噪算法
</code></pre> 
<p>Tips: 可以参照已经实现的两个去噪算法；按键盘上”b”可以查看去噪结果。</p> 
<h3><a id="_330"></a>算法思想</h3> 
<p>拉普拉斯变换，对于当前顶点来说，把它周围所有顶点的坐标加起来，求平均，再赋值给当前顶点，达到平滑去噪的效果。</p> 
<p>了解了解这里遍历当前顶点周围所有顶点的过程：<br> <img src="https://images2.imgbox.com/ba/b5/Cq4ApbLC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_336"></a>代码示例</h3> 
<pre><code class="prism language-C++">	template&lt;class ExItems&gt;
	void ExKernelT&lt;ExItems&gt;::Laplacian_Smoothing()
	{
		/请实现自己的去噪算法
		int vertex_num = vertex_size();//顶点数量
		int iterations, i = 0, j = 0;  //iterations : 迭代次数
		clock_t t1, t2;
		std::cout &lt;&lt; "Input laplacian vertex update iterations(5-30次): ";
		std::cin &gt;&gt; iterations;
		std::cout &lt;&lt; "由于迭代，比较耗时！" &lt;&lt; std::endl;
		std::cout &lt;&lt; "Please wait.....  " &lt;&lt; std::endl;
		t1 = clock(); //注意哦
		do{
			std::vector&lt;Coord&gt; updateVertexPosition; //向量，存储... ...
			updateVertexPosition.resize(vertex_num); //调整大小
			VertexIterator vertex_it(vertex_begin());
			for (i = 0; vertex_it != vertex_end(); vertex_it++)
			{
				HalfedgeHandle&amp; half = vertex_it-&gt;halfedge_handle_;  //顶点处半边
				HalfedgeHandle half2(opposite_halfedge_handle(half));//对面的半边
				j = 0;
				do
				{
					updateVertexPosition[i] += coord(vertex_handle(half2)); //获取顶点坐标
					j++;
					half2 = opposite_halfedge_handle(prev_halfedge_handle(half2));
				} while (opposite_halfedge_handle(half2) != half);
				updateVertexPosition[i] /= j;//顶点坐标取平均
				i++;
			}
			i = 0;
			for ( vertex_it = vertex_begin(); vertex_it != vertex_end(); vertex_it++)
			{
				vertex_it-&gt;coord_ = updateVertexPosition[i]; //用刚求得的平均值代替原来的，可避免毛刺产生
				i++;
			}
		} while (iterations--);
		t2 = clock();
		std::cout &lt;&lt; "The time of laplacian vertex updating: " &lt;&lt; (t2 - t1) * 1.0 / CLOCKS_PER_SEC &lt;&lt; "s" &lt;&lt; std::endl;
	}
</code></pre> 
<p>实现之前可以先看看老师已经完成的其它2种去噪方式。<br> <code>Mesh_Denoising_FE()</code><br> <code>Mesh_Denoising_YouyiZheng()</code></p> 
<h2><a id="5%09_20_384"></a>5. （可选/可做可不做）实现一种基于三角网格的操作（例如，特征点/边提取，给三角网格添加随机高斯噪声，求三角网格每个顶点的高斯曲率，三角网格简化，三角网格四边形化等等） (20分)</h2> 
<h3><a id="_386"></a>题目说明</h3> 
<p>此函数声明为: <code>void mesh_process();</code></p> 
<h3><a id="_388"></a>算法思想</h3> 
<p>我反着来一遍拉普拉斯变换，把周围顶点和当前顶点坐标的差距放大，还是这张熟悉的图：</p> 
<p><img src="https://images2.imgbox.com/5e/d4/Uqi1ua3s_o.png" alt="在这里插入图片描述"></p> 
<p>绿颜色的“5”，替换成周围的顶点数“j”，就具有普遍性。<br> <img src="https://images2.imgbox.com/14/82/OH7coTJx_o.png" alt="在这里插入图片描述"><br> 这里除以10的原因是，减小一点噪声，让画面显得更清晰。</p> 
<h3><a id="_397"></a>代码示例</h3> 
<pre><code class="prism language-C++">	template&lt;class ExItems&gt;
	void ExKernelT&lt;ExItems&gt;::mesh_process()
	{
		//放大噪声
		int vertex_num = vertex_size();
		int iterations, i, j;
		clock_t t1, t2;
		std::cout &lt;&lt; "Input sharpening vertex update iterations(1-30次): ";
		std::cin &gt;&gt; iterations;
		i = 0;
		std::cout &lt;&lt; "由于迭代，比较耗时！" &lt;&lt; std::endl;
		std::cout &lt;&lt; "Please wait.....  " &lt;&lt; std::endl;
		t1 = clock();
		do{
			std::vector&lt;Coord&gt; updateVertexPosition;
			updateVertexPosition.resize(vertex_num);
			VertexIterator vertex_it(vertex_begin());
			for (i = 0; vertex_it != vertex_end(); vertex_it++)
			{
				HalfedgeHandle&amp; half = vertex_it-&gt;halfedge_handle_;
				HalfedgeHandle half2(opposite_halfedge_handle(half));
				j = 0;
				do{
					updateVertexPosition[i] +=coord(vertex_handle(half2));//coordinates 坐标
					j++;
					half2 = prev_halfedge_handle(half2);
					half2 = opposite_halfedge_handle(half2);
				} while (opposite_halfedge_handle(half2) != half);
				updateVertexPosition[i] -= coord(vertex_handle(half)) * j;
				updateVertexPosition[i] /= j;
				updateVertexPosition[i] *= -1;
				i++;
			}
			i = 0;
			for ( vertex_it = vertex_begin(); vertex_it != vertex_end(); vertex_it++)
			{
				vertex_it-&gt;coord_ += updateVertexPosition[i] * 0.1; 
				//小一点，小一点
				i++;
			}
		} while (iterations--);
		t2 = clock();
		std::cout &lt;&lt; "The time of sharpening vertex updating: " &lt;&lt; (t2 - t1) * 1.0 / CLOCKS_PER_SEC &lt;&lt; "s" &lt;&lt; std::endl;
	}
</code></pre> 
<p>项目中没有调用该函数，请自行调用：<br> 在这里设置为 <code>choice == 4</code>就好<br> <img src="https://images2.imgbox.com/b3/63/LKNryhFe_o.png" alt="在这里插入图片描述"></p> 
<p>如有不足，恳请指正。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b503fd4da7c7f2a2e28e445e7d8263c4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">让NotePad&#43;&#43;添加到右键快捷方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a695fc9ff78678b7a80f5071d1fa6f1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">剑桥雅思真题精讲10pdf_剑桥雅思真题及精讲1-15高清无水印版PDF＋MP3音频</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>