<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Opencv入门到项目实战】（十一）：harris角点检测|SIFT|特征匹配 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Opencv入门到项目实战】（十一）：harris角点检测|SIFT|特征匹配" />
<meta property="og:description" content="所有订阅专栏的同学可以私信博主获取源码文件
文章目录 1.harris角点检测2.尺度不变特征变换（SIFT）2.1图像尺度空间2.2 关键点定位2.3 消除边界响应2.4 代码示例 1.harris角点检测 这一节我们来讨论一下Harris角点检测，由Chris Harris和Mike Stephens于1988年提出。该算法通过计算图像的局部灰度变化来检测角点，并利用协方差矩阵的特征值来确定是否为角点。
它的基本思想是，对于图像I(x,y)，当在点(x,y)处平移( Δ \Delta Δx, Δ \Delta Δy)后的灰度变化有多大。我们定义其变换后的自相似性为:
w(x, y)是以点(x,y)为中心的一个窗口，一般我们用高斯窗口函数，用于平滑梯度。
然后对右边利用泰勒展开:
其中，Ix和Iy分别表示图像在x和y方向上的梯度
代入后近似得到下列结果：
其中M为协方差矩阵:
接下来我们利用协方差的特征值来计算每个像素点的角点相响应值R
其中，det(M)表示协方差矩阵M的行列式，trace(M)表示协方差矩阵M的迹， α \alpha α是一个常数，用于调整响应函数的灵敏度。
在Opencv中，我们调用cv2.cornerHarris()函数实现
import cv2 import numpy as np # 导入图片 img = cv2.imread(&#39;test_1.jpg&#39;) print (&#39;img.shape:&#39;,img.shape) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) gray = np.float32(gray)#转换为float32格式 dst = cv2.cornerHarris(gray, 2, 3, 0.04) print (&#39;dst.shape:&#39;,dst.shape) img.shape: (512, 512, 3) dst.shape: (512, 512) img[dst&gt;0.01*dst.max()]=[0,0,255] #非极大值抑制,将边界点标红 cv2.imshow(&#39;dst&#39;,img) cv2.waitKey(0) cv2.destroyAllWindows() 上图可以看出，我们将当中的角点都检测出来了" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a1063e8328f58141be3e2f1f6daa6bda/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-08T20:46:54+08:00" />
<meta property="article:modified_time" content="2023-09-08T20:46:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Opencv入门到项目实战】（十一）：harris角点检测|SIFT|特征匹配</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><mark><font size="4"><strong>所有订阅专栏的同学可以私信博主获取源码文件</strong></font></mark></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1harris_8" rel="nofollow">1.harris角点检测</a></li><li><a href="#2SIFT_76" rel="nofollow">2.尺度不变特征变换（SIFT）</a></li><li><ul><li><a href="#21_101" rel="nofollow">2.1图像尺度空间</a></li><li><a href="#22__148" rel="nofollow">2.2 关键点定位</a></li><li><a href="#23__162" rel="nofollow">2.3 消除边界响应</a></li><li><a href="#24__174" rel="nofollow">2.4 代码示例</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1harris_8"></a>1.harris角点检测</h2> 
<p>这一节我们来讨论一下Harris角点检测，由Chris Harris和Mike Stephens于1988年提出。该算法通过计算图像的局部灰度变化来检测角点，并利用协方差矩阵的特征值来确定是否为角点。</p> 
<p>它的基本思想是，对于图像I(x,y)，当在点(x,y)处平移(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Δ 
        
       
      
        \Delta 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord">Δ</span></span></span></span></span>x,<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Δ 
        
       
      
        \Delta 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord">Δ</span></span></span></span></span>y)后的灰度变化有多大。我们定义其变换后的自相似性为:</p> 
<p><img src="https://images2.imgbox.com/e6/ab/lpExv9YM_o.png" alt="image-20230803160902306"></p> 
<p>w(x, y)是以点(x,y)为中心的一个窗口，一般我们用高斯窗口函数，用于平滑梯度。</p> 
<p>然后对右边利用<font size="4" color="red"><strong>泰勒展开</strong></font>:</p> 
<p><img src="https://images2.imgbox.com/27/f7/oNS1CpSL_o.png" alt="image-20230803160951244"></p> 
<p>其中，Ix和Iy分别表示图像在x和y方向上的梯度</p> 
<p>代入后近似得到下列结果：</p> 
<p><img src="https://images2.imgbox.com/c5/73/Vuk3vYkb_o.png" alt="image-20230803161116510"></p> 
<p><font size="4" color="red"><strong>其中M为协方差矩阵:</strong></font></p> 
<p><img src="https://images2.imgbox.com/24/4d/bu8rNRYo_o.png" alt="image-20230803163046978"></p> 
<p>接下来我们利用协方差的特征值来计算每个像素点的角点相响应值R</p> 
<p><img src="https://images2.imgbox.com/10/07/Ej3tpjuS_o.png" alt="image-20230803163132552"></p> 
<p>其中，det(M)表示协方差矩阵M的行列式，trace(M)表示协方差矩阵M的迹，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         α 
        
       
      
        \alpha 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0037em;">α</span></span></span></span></span>是一个常数，用于调整响应函数的灵敏度。</p> 
<p>在<code>Opencv</code>中，我们调用<code>cv2.cornerHarris()</code>函数实现</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2 
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token comment"># 导入图片</span>
img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'test_1.jpg'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'img.shape:'</span><span class="token punctuation">,</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>
gray <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span>gray<span class="token punctuation">)</span><span class="token comment">#转换为float32格式</span>
dst <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cornerHarris<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0.04</span><span class="token punctuation">)</span>
<span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'dst.shape:'</span><span class="token punctuation">,</span>dst<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>

</code></pre> 
<pre><code>img.shape: (512, 512, 3)
dst.shape: (512, 512)
</code></pre> 
<pre><code class="prism language-python">img<span class="token punctuation">[</span>dst<span class="token operator">&gt;</span><span class="token number">0.01</span><span class="token operator">*</span>dst<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">]</span> <span class="token comment">#非极大值抑制,将边界点标红</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'dst'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span> 
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> 
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/95/f5/64WuIdcN_o.png" alt="image-20230803212927010"></p> 
<p>上图可以看出，我们将当中的角点都检测出来了</p> 
<p><strong>Harris角点检测算法</strong>的优点在于它对旋转、尺度和亮度的变化具有一定的鲁棒性，并且适用于不同类型的图像。该算法还相对简单，计算速度较快。然而，Harris角点检测算法也存在一些限制。例如，它对侧向边缘非常敏感，会将边缘点误判为角点。此外，该算法对于纹理较为平滑的区域可能无法准确地检测到角点。</p> 
<h2><a id="2SIFT_76"></a>2.尺度不变特征变换（SIFT）</h2> 
<p>**Scale Invariant Feature Transform（SIFT）**是一种用于计算机视觉和图像处理中的特征检测和描述的算法，可以说是在计算机视觉一种非常流行和广泛使用的算法，它能够检测和描述图像中的关键点，并具有尺度、旋转和视角的不变性，适用于各种图像处理任务，例如目标识别、图像匹配、图像拼接等。SIFT算法主要包括：<strong>尺度空间检测、特征关键点检测、特征描述</strong>等，接下来我们来分别看一下这些概念</p> 
<p>以下是对SIFT算法的详细介绍：</p> 
<ol><li><strong>特征点检测：</strong> 
  <ul><li>尺度空间极值检测：SIFT首先在不同尺度下使用高斯模糊滤波器构建尺度空间金字塔，然后通过比较每个像素与其周围像素及所处尺度上的像素进行检测，找到图像中的关键点。</li><li>关键点精化：通过利用尺度空间的极值点，对关键点进行精化，计算其精确位置和尺度尺度，并根据梯度方向来确定主方向。</li></ul> </li><li><strong>特征描述：</strong> 
  <ul><li>局部图像描述子：以关键点为中心，在其周围的邻域内构建一个具有旋转不变性和尺度不变性的局部图像描述子。该描述子基于关键点附近的梯度方向和强度信息，通过生成一个特征向量来描述关键点周围的图像结构。</li><li>方向直方图：在计算局部图像描述子之前，首先根据关键点周围的梯度方向计算一个方向直方图，用来确定主方向。</li></ul> </li><li><strong>特征匹配：</strong> 
  <ul><li>特征向量匹配：将两幅图像的特征向量进行匹配，通常使用最近邻匹配方法（如欧氏距离）来寻找每个特征点的最佳匹配。同时，还可以使用二次最近邻比率测试来过滤不可靠的匹配。</li><li>鲁棒性和一致性：为了提高匹配的鲁棒性和一致性，可以使用诸如RANSAC（随机抽样一致性）等方法来剔除异常和错误的匹配点。</li></ul> </li></ol> 
<p>SIFT算法的关键优势在于其对尺度、旋转和视角的不变性，使得它能够在多种条件下鲁棒地检测和匹配图像中的特征点。此外，SIFT算法还具有以下特点：</p> 
<ul><li>独特性：SIFT特征是在图像中独一无二的，它们可以用来区分不同的图像区域。</li><li>不变性：SIFT特征对于有限的视角变化、尺度变化以及轻微的仿射变换都具有较好的不变性。</li><li>高鲁棒性：SIFT算法对于光照变化、噪声和部分遮挡等情况下仍能产生准确的匹配结果。</li><li>可扩展性：SIFT算法可以应用于各种图像尺寸和分辨率的图像，并且在大规模图像数据库中进行高效匹配。</li></ul> 
<p>，因此在目标识别、图像匹配和图像拼接等应用中具有重要的作用。</p> 
<h3><a id="21_101"></a>2.1图像尺度空间</h3> 
<p>我们知道在一定的范围内，无论物体是大还是小，我们人眼都可以分辨出来，然而计算机要有相同的能力却很难，所以要让机器能够对物体在不同尺度下有一个统一的认知，就需要考虑图像在不同的尺度下都存在的特点。</p> 
<p><strong>图像尺度空间</strong>是指在不同尺度下对图像进行分析和处理的一种表示方式。在图像尺度空间中，同一物体或结构的特征在不同尺度下具有不同的尺度信息。这是因为图像中的物体和结构可能以不同的尺度出现，例如大小、边缘和纹理等。通过在不同尺度下分析图像，我们可以获取更全面和鲁棒的特征表示，以适应不同尺度上的目标检测、识别和描述任务。</p> 
<p>尺度空间的获取通常使用高斯模糊来实现，</p> 
<p><img src="https://images2.imgbox.com/fd/87/czPqawMF_o.png" alt="image-20230809221841944"></p> 
<ul><li> <p><strong>高斯金字塔</strong>： 高斯金字塔是一种通过对图像进行连续的高斯滤波和下采样操作来构建图像尺度空间的方法。具体步骤如下：</p> 
  <ul><li>先对原始图像应用一个初始尺度的高斯滤波器。</li><li>对滤波后的图像进行下采样（通常是进行二次减半），得到下一层金字塔图像。</li><li>重复以上步骤，直到达到预定的尺度层数。</li></ul> </li><li> <p><strong>多分辨率金字塔</strong>，它是通过将原始图像进行分解，得到一系列具有不同分辨率的图像层级，从而实现对图像的多尺度分析和处理通常采用逐步降采样（downsampling）和上采样（upsampling）的方法。</p> 
  <ul><li>首先，原始图像通过降采样操作被缩小为较低分辨率的图像，然后这个较低分辨率的图像再次进行降采样，直到达到所需的分辨率层级。</li><li>这样就形成了一个金字塔状的层级结构，其中每个层级的图像都比上一层级的图像具有更低的分辨率。</li><li>在每层进行高斯滤波器操作</li></ul> <p>多分辨率金字塔的主要优势之一是可以在不同尺度下对图像进行分析。高层级的图像层级具有较低的分辨率，但能够捕捉到图像的整体特征和结构信息；而低层级的图像层级具有较高的分辨率，能够提供更多的细节信息。因此，通过在不同层级上对图像进行处理，可以获得更全面和准确的分析结果。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/30/a8/GYjKnfmU_o.png" alt="image-20230829185617231"></p> 
<ul><li><strong>尺度空间差分金字塔</strong>： 尺度空间差分金字塔是基于高斯金字塔的构建方法。它通过计算高斯金字塔相邻层之间的差分图像来获取尺度空间的特征。这样做可以捕捉到图像中的细节信息，而较高尺度的层级可以揭示出图像中的整体结构。通过在不同层级上进行差分操作，可以凸显出图像中的边缘、角点等局部结构。具体步骤如下： 
  <ul><li>构建高斯金字塔，并对每一层进行高斯平滑。</li><li>对相邻两层图像进行差分操作，得到差分图像。</li><li>重复以上步骤，直到达到预定的尺度层数。</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/65/81/Jj3HHQtU_o.png" alt="image-20230829185556147"></p> 
<p><strong>DOG定义：</strong></p> 
<p><img src="https://images2.imgbox.com/2f/9a/JQkXZfPs_o.png" alt="image-20230830001359520"></p> 
<p><strong>DoG空间极值检测</strong></p> 
<p>为了寻找尺度空间的极值点，每个像素点要和其图像域（同一尺度空间）和尺度域（相邻的尺度空间）的所有相邻点进行比较，当其大于（或者小于）所有相邻点时，该点就是极值点。如下图所示，中间的检测点要和其所在图像的<code>3×3</code>邻域<code>8</code>个像素点，以及其相邻的上下两层的<code>3×3</code>领域<code>18</code>个像素点，共<code>26</code>个像素点进行比较。</p> 
<p><img src="https://images2.imgbox.com/b0/27/EBfIhibs_o.png" alt="image-20230830001520780"></p> 
<h3><a id="22__148"></a>2.2 关键点定位</h3> 
<p>这些候选关键点是DOG空间的局部极值点，而且这些极值点均为离散的点，精确定位极值点的一种方法是：对尺度空间DoG函数进行曲线拟合，计算其极值点，从而实现关键点的精确定位。</p> 
<p><img src="https://images2.imgbox.com/96/f0/iz69xqAQ_o.png" alt="image-20230830001809889"></p> 
<p>我们使用<strong>泰勒展开</strong>来拟合，假设在0点展开，则具体表达式如下所示：</p> 
<p><img src="https://images2.imgbox.com/f2/4d/1IEJt8QG_o.png" alt="image-20230830001835576"></p> 
<p>用矩阵形式表示如下：</p> 
<p><img src="https://images2.imgbox.com/7b/2e/euLPmxR5_o.png" alt="image-20230830001856211"></p> 
<h3><a id="23__162"></a>2.3 消除边界响应</h3> 
<p>接下来得到了这些极值点具体位置之后，我们还需要对位置进行一些过滤，这里有一个方法就是<strong>消除边界响应</strong>。因为之前我们通过高斯滤波器对图像进行各种操作，可能会增加一些边界的响应，此时我们需要将其消除掉。</p> 
<p>在这里啊，修正方法和我们之前介绍边缘检测类似，当一个特征值大，一个特征值小的时候，它就是边界，这里我们定义了一个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         α 
        
       
      
        \alpha 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0037em;">α</span></span></span></span></span>和一个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         β 
        
       
      
        \beta 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0528em;">β</span></span></span></span></span>。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         α 
        
       
      
        \alpha 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0037em;">α</span></span></span></span></span>=较大特征值，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         β 
        
       
      
        \beta 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0528em;">β</span></span></span></span></span>=较小特征值，组成一个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         e 
        
       
         s 
        
       
         s 
        
       
         i 
        
       
         a 
        
       
         n 
        
       
      
        Hessian 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">Hess</span><span class="mord mathnormal">ian</span></span></span></span></span>矩阵，具体如下：</p> 
<p><img src="https://images2.imgbox.com/57/9d/yVLyKSMk_o.png" alt="image-20230830002922601"></p> 
<p><img src="https://images2.imgbox.com/c6/e0/8eXcUzrv_o.png" alt="image-20230830003003981"></p> 
<p>当<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         γ 
        
       
         &gt; 
        
       
         10 
        
       
      
        \gamma&gt;10 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7335em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0556em;">γ</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">10</span></span></span></span></span>时，进行过滤操作。</p> 
<h3><a id="24__174"></a>2.4 代码示例</h3> 
<p>下面我们看如何在opencv中实现SIFT特征变换</p> 
<p>==注意：==新版本的opencv不能直接调用，需要降版本为3.4.1，安装命令如下；</p> 
<p><code>pip install opencv-python==3.4.1.15 </code></p> 
<p><code>pip install opencv-contrib-python==3.4.1.15</code></p> 
<p>下面我们来看具体代码：</p> 
<p>首先读取图片，这里我们还是使用之前的<strong>小狗洋气图片</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'yangqi.jpg'</span><span class="token punctuation">)</span>
gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span><span class="token comment">#灰度图</span>
</code></pre> 
<p><font size="4" color="blue"><strong>得到关键点:</strong></font></p> 
<p>接下来调用<code>xfeatures2d.SIFT_create()函数</code>初始化SIFT 检测器对象，然后使用<code>detect()</code>函数检测关键点</p> 
<pre><code class="prism language-python">sift <span class="token operator">=</span> cv2<span class="token punctuation">.</span>xfeatures2d<span class="token punctuation">.</span>SIFT_create<span class="token punctuation">(</span><span class="token punctuation">)</span>
kp <span class="token operator">=</span> sift<span class="token punctuation">.</span>detect<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span class="token comment">#得到特征点</span>

img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawKeypoints<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> kp<span class="token punctuation">,</span> img<span class="token punctuation">)</span> <span class="token comment">#绘制特征点</span>

cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'drawKeypoints'</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/38/23/6Cua8WVF_o.png" alt="image-20230830103702934"></p> 
<p><font size="4" color="blue"><strong>计算特征</strong></font>:</p> 
<p>接下来使用<code>sift.compute()</code>函数计算关键的及其对应的特征</p> 
<pre><code class="prism language-python">kp<span class="token punctuation">,</span> des <span class="token operator">=</span> sift<span class="token punctuation">.</span>compute<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> kp<span class="token punctuation">)</span>
</code></pre> 
<ul><li> <p><code>kp</code>：关键点</p> </li><li> <p><code>des</code>：每一个关键点对应的特征</p> </li></ul> 
<p>接下来我们来看一下他们的纬度</p> 
<pre><code class="prism language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>kp<span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token comment">#kp是一个列表，需要转换成ndarray</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>des<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
</code></pre> 
<pre><code>(605,)
(605, 128)
</code></pre> 
<p>结果表示我们一共得到了605个关键点，每个关键点是一个128维的向量。</p> 
<blockquote> 
 <p>🔎<font size="4" color="red">本章的介绍到此介绍，如果文章对你有帮助，请多多点赞、收藏、评论、订阅支持！！<a href="https://blog.csdn.net/weixin_45052363/category_12398250.html">《Opencv入门到项目实战》</a></font></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13af8a081df4272305f915da42273575/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python串口采集数据绘制波形图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a9decabb9dc2b25b27b05741c2d7540/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人工智能入门 | 分类算法-KNN(原理&#43;代码&#43;结果)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>