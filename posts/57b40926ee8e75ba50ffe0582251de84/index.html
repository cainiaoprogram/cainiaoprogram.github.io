<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Rust 学习 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Rust 学习" />
<meta property="og:description" content="Rust官网：https://www.rust-lang.org/zh-CN/
Rust模块 库：https://crates.io/
官方文档：https://rustwiki.org/zh-CN/std/all.html
Rust Cookbook：https://rust-lang-nursery.github.io/rust-cookbook/
Rust 爬虫：https://zhuanlan.zhihu.com/p/516033159
[Rust] Scraper 爬虫简单使用：https://zhuanlan.zhihu.com/p/595712847
所有内容全部来自 《Rust 程序设计语言》和 《通过例子学 Rust》！！！！！
1、Rust 简介 Rust 语言的主要目标之一是解决传统 系统级编程语言（如 C 和 C&#43;&#43;）中常见的安全性问题，例如空指针引用、数据竞争等。为了实现这个目标，Rust 引入了一种称为 &#34;所有权&#34; 的概念，通过静态检查来确保内存安全和线程安全。此外，Rust 还具有其他一些特性，如模式匹配、代数数据类型、函数式编程风格的特性（如闭包和高阶函数）等。它还提供了丰富的标准库和包管理器 Cargo，使得开发者可以轻松构建和管理他们的项目。
Rust 是一门注重安全（safety）、速度（speed）和并发（concurrency）的现代系统编程语言。Rust 通过内存安全来实现以上目标，但不使用垃圾回收机制（garbage collection, GC）。
Rust 是 静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。
Rust 特点 高性能：Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。可靠性：Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。生产力：Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具——包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。 Rust 相关概念 channel：Rust 会发布3个不同版本：stable、beta、nightly。
stable：Rust 的稳定版本，每 6 周发布一次。
beta：Rust 的公开测试版本，将是下一个 stable 版本。
nightly：每天更新，包含以一些实验性的新特性。toolchain：一套 Rust 组件，包括编译器及其相关工具，并且包含 channel，版本及支持的平台信息。target：指编译的目标平台，即：编译后的程序在哪种操作系统上运行。component (组件)：toolchain 是由 component 组成的。查看所有可用和已经安装的组件命令如下：rustup component list。rustup 默认安装的组件：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/57b40926ee8e75ba50ffe0582251de84/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T01:18:16+08:00" />
<meta property="article:modified_time" content="2024-01-01T01:18:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Rust 学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><br>  </p> 
<p>Rust官网：<a class="link-info" href="https://www.rust-lang.org/zh-CN/" rel="nofollow" title="https://www.rust-lang.org/zh-CN/">https://www.rust-lang.org/zh-CN/</a><br> Rust模块 库：<a class="link-info" href="https://crates.io/" rel="nofollow" title="https://crates.io/">https://crates.io/</a><br> 官方文档：<a class="link-info" href="https://rustwiki.org/zh-CN/std/all.html" rel="nofollow" title="https://rustwiki.org/zh-CN/std/all.html">https://rustwiki.org/zh-CN/std/all.html</a><br> Rust Cookbook：<a class="link-info" href="https://rust-lang-nursery.github.io/rust-cookbook/" rel="nofollow" title="https://rust-lang-nursery.github.io/rust-cookbook/">https://rust-lang-nursery.github.io/rust-cookbook/</a></p> 
<p>Rust 爬虫：<a class="link-info" href="https://zhuanlan.zhihu.com/p/516033159" rel="nofollow" title="https://zhuanlan.zhihu.com/p/516033159">https://zhuanlan.zhihu.com/p/516033159</a><br> [Rust] Scraper 爬虫简单使用：<a class="link-info" href="https://zhuanlan.zhihu.com/p/595712847" rel="nofollow" title="https://zhuanlan.zhihu.com/p/595712847">https://zhuanlan.zhihu.com/p/595712847</a></p> 
<p></p> 
<p><strong><span style="color:#fe2c24;">所有内容全部来自 《Rust 程序设计语言》和 《通过例子学 Rust》！！！！！</span></strong></p> 
<p></p> 
<p></p> 
<h2>1、Rust 简介</h2> 
<p></p> 
<p>Rust 语言的主要目标之一是解决传统 <strong>系统级编程语言（如 C 和 C++）</strong>中常见的安全性问题，例如空指针引用、数据竞争等。为了实现这个目标，Rust 引入了一种称为 "所有权" 的概念，通过静态检查来确保内存安全和线程安全。此外，Rust 还具有其他一些特性，如模式匹配、代数数据类型、函数式编程风格的特性（如闭包和高阶函数）等。它还提供了丰富的标准库和包管理器 Cargo，使得开发者可以轻松构建和管理他们的项目。</p> 
<p>Rust 是一门注重安全（safety）、速度（speed）和并发（concurrency）的现代系统编程语言。Rust 通过内存安全来实现以上目标，但不使用垃圾回收机制（garbage collection, GC）。</p> 
<p>Rust 是 <strong>静态类型</strong>（<em>statically typed</em>）语言，也就是说在编译时就必须知道所有变量的类型。</p> 
<p></p> 
<h3>Rust 特点</h3> 
<ul><li><strong><span style="background-color:#ffd900;">高性能</span></strong>：Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。</li><li><strong><span style="background-color:#ffd900;">可靠性</span></strong>：Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。</li><li><strong><span style="background-color:#ffd900;">生产力</span></strong>：Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具——包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。</li></ul> 
<p></p> 
<h3>Rust 相关概念</h3> 
<ul><li><strong><span style="background-color:#ffd900;">channel</span></strong>：Rust 会发布3个不同版本：stable、beta、nightly。<br>         stable：Rust 的稳定版本，每 6 周发布一次。<br>         beta：Rust 的公开测试版本，将是下一个 stable 版本。<br>         nightly：每天更新，包含以一些实验性的新特性。</li><li><strong><span style="background-color:#ffd900;">toolchain</span></strong>：一套 Rust 组件，包括编译器及其相关工具，并且包含 channel，版本及支持的平台信息。</li><li><strong><span style="background-color:#ffd900;">target</span></strong>：指编译的目标平台，即：编译后的程序在哪种操作系统上运行。</li><li><strong><span style="background-color:#ffd900;">component </span></strong>(组件)：toolchain 是由 component 组成的。查看所有可用和已经安装的组件命令如下：<strong><span style="background-color:#ffd900;">rustup component list</span></strong>。rustup 默认安装的组件：<br>         rustc：Rust 编译器。<br>         rust-std：Rust 标准库。<br>         cargo：包管理和构建工具。<br>         rust-docs：Rust 文档。<br>         rustfmt：用来格式化 Rust 源代码。<br>         clippy：Rust 的代码检查工具。</li><li><strong><span style="background-color:#ffd900;">profile</span></strong>：为了方便对 component 进行管理，使用 profile 定义一组 component。不同的 profile 包含不同的组件，安装 rustup 时有三种 profile 可选，修改 profile 命令如下：rustup set profile minimal</li><li><strong><span style="background-color:#ffd900;">Rustup 是什么</span></strong>：<strong><span style="color:#fe2c24;">Rustup 是 Rust安装器和版本管理工具</span>。</strong><span style="color:#4d4d4d;">安装 Rust 的主要方式是通过 Rustup 这一工具，它既是一个 Rust 安装器又是一个版本管理工具。</span><span style="color:#4d4d4d;">Rust 的升级非常频繁。运行 </span><code>rustup update</code><span style="color:#4d4d4d;"> 获取最新版本的 Rust。<strong>文档：</strong><a class="link-info" href="https://rust-lang.github.io/rustup/" rel="nofollow" title="https://rust-lang.github.io/rustup/">https://rust-lang.github.io/rustup/</a></span></li><li><span style="color:#4d4d4d;"><strong><span style="background-color:#ffd900;">Cargo 是什么</span></strong>：</span><span style="color:#fe2c24;"><strong>Cargo 是 Rust 的 构建工具 和 包管理器</strong></span>。安装 Rustup 时会自动安装。Cargo 可以做很多事情：<br>         cargo build      可以构建项目<br>         cargo run        可以运行项目<br>         cargo test       可以测试项目<br>         cargo doc       可以为项目构建文档<br>         cargo publish 可以将库发布到 crates.io。<br> 检查是否安装了 Rust 和 Cargo，可以在终端中运行：cargo --version</li></ul> 
<p></p> 
<h3>下载、安装</h3> 
<p>下载：<a class="link-info" href="https://www.rust-lang.org/tools/install" rel="nofollow" title="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a><br> 安装：<a class="link-info" href="https://www.rust-lang.org/zh-CN/learn/get-started" rel="nofollow" title="https://www.rust-lang.org/zh-CN/learn/get-started">https://www.rust-lang.org/zh-CN/learn/get-started</a></p> 
<p>默认情况，Rust 依赖 C++ build tools，没有安装也关系。安装过程需要保证网络正常。</p> 
<p>在 Rust 开发环境中，所有工具都安装在 ~/.cargo/bin 目录中，可以在这里找到包括 rustc、cargo 和 rustup 在内的 Rust 工具链。在安装过程中，rustup 会尝试配置 PATH，如果 rustup 对 PATH 的修改不生效，可以手动添加路径到 PATH</p> 
<blockquote> 
 <p>~/.cargo/bin</p> 
 <p class="img-center"><img alt="" height="194" src="https://images2.imgbox.com/b9/23/sFTKFAYB_o.png" width="676"></p> 
</blockquote> 
<blockquote> 
 <p>~/.rustup/bin</p> 
 <p class="img-center"><img alt="" height="251" src="https://images2.imgbox.com/db/3b/SbYODYGf_o.png" width="613"></p> 
</blockquote> 
<p>以下是一些常用的命令：</p> 
<p>rustup 相关</p> 
<blockquote> 
 <p>rustup -h                # 查看帮助<br> rustup show              # 显示当前安装的工具链信息<br> rustup update            # 检查安装更新<br> rustup self uninstall    # 卸载<br> rustup default stable-x86_64-pc-windows-gnu    # 设置当前默认工具链</p> 
 <p>rustup toolchain list    # 查看工具链<br> rustup toolchain install stable-x86_64-pc-windows-gnu    # 安装工具链<br> rustup toolchain uninstall stable-x86_64-pc-windows-gnu  # 卸载工具链<br> rustup toolchain link &lt;toolchain-name&gt; "&lt;toolchain-path&gt;"    # 设置自定义工具链</p> 
 <p>rustup override list    # 查看已设置的默认工具链<br> rustup override set &lt;toolchain&gt; --path &lt;path&gt;    # 设置该目录以及其子目录的默认工具链<br> rustup override unset --path &lt;path&gt;    # 取消目录以及其子目录的默认工具链</p> 
 <p>rustup target list               # 查看目标列表<br> rustup target add &lt;target&gt;       # 安装目标<br> rustup target remove &lt;target&gt;    # 卸载目标<br> rustup target add --toolchain &lt;toolchain&gt; &lt;target&gt;    # 为特定工具链安装目标</p> 
 <p>rustup component list                 # 查看可用组件<br> rustup component add &lt;component&gt;      # 安装组件<br> rustup component remove &lt;component&gt;   # 卸载组件</p> 
</blockquote> 
<p>rustc 相关</p> 
<blockquote> 
 <p>rustc --version    # 查看rustc版本</p> 
</blockquote> 
<p>cargo 相关</p> 
<blockquote> 
 <p>cargo --version    # 查看cargo版本<br> cargo new &lt;project_name&gt;    # 新建项目<br> cargo build    # 构建项目<br> cargo run      # 运行项目<br> cargo check    # 检查项目<br> cargo -h       # 查看帮助</p> 
</blockquote> 
<p>配置工具链安装位置</p> 
<blockquote> 
 <p>在系统环境变量中添加如下变量：<br> CARGO_HOME 指定 cargo 的安装目录<br> RUSTUP_HOME 指定 rustup 的安装目录<br> 默认分别安装到用户目录下的.cargo 和.rustup 目录</p> 
</blockquote> 
<p>配置国内镜像</p> 
<p>配置 rustup 国内镜像。在系统环境变量中添加如下变量（选一个就可以，可以组合）：</p> 
<blockquote> 
 <p># 清华大学<br> RUSTUP_DIST_SERVER：https://mirrors.tuna.tsinghua.edu.cn/rustup<br> RUSTUP_UPDATE_ROOT：https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup</p> 
 <p># 中国科学技术大学<br> RUSTUP_DIST_SERVER：https://mirrors.ustc.edu.cn/rust-static<br> RUSTUP_UPDATE_ROOT：https://mirrors.ustc.edu.cn/rust-static/rustup</p> 
</blockquote> 
<p>配置 cargo 国内镜像。在 cargo 安装目录下新建 config 文件（注意 config 没有任何后缀），文件内容如下：</p> 
<blockquote> 
 <p>[source.crates-io]<br> registry = "https://github.com/rust-lang/crates.io-index"<br> replace-with = 'tuna'</p> 
 <p># 清华大学<br> [source.tuna]<br> registry = "https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"</p> 
 <p># 中国科学技术大学<br> [source.ustc]<br> registry = "git://mirrors.ustc.edu.cn/crates.io-index"<br> # 设置代理<br> [http]<br> proxy = "127.0.0.1:8889"<br> [https]<br> proxy = "127.0.0.1:8889"</p> 
</blockquote> 
<p>Windows 交叉编译 Linux 程序。目标服务器是 <code>Linux(CentOS 7) 64bit</code>, 所以我们添加的 target 应该是<code>x86_64-unknown-linux-gnu</code>(动态依赖) 或者<code>x86_64-unknown-linux-musl</code>（静态依赖）</p> 
<ul><li>动态依赖：目标服务器需要包含动态依赖的相关库（用户共享库）</li><li>静态依赖，目标服务器不需要包含相应的库，但是打包文件会更大些</li></ul> 
<p>1). 添加需要的 target<br> rustup target add  x86_64-unknown-linux-musl<br> 2). 在 cargo 安装目录下新建 config 文件（注意 config 没有任何后缀），添加的文件内容如下：<br> [target.x86_64-unknown-linux-musl]<br> linker = "rust-lld"<br> 3). 构建<br> cargo build --target x86_64-unknown-linux-musl</p> 
<p></p> 
<h3>示例：</h3> 
<h4>创建新项目</h4> 
<p>用 Cargo 创建一个新项目。在终端中执行：<strong><span style="background-color:#ffd900;">cargo new hello-rust</span></strong>，会生成一个名为 <code>hello-rust</code> 的新目录，其中包含以下文件：</p> 
<p class="img-center"><img alt="" height="311" src="https://images2.imgbox.com/a4/58/6l9qGTzc_o.png" width="337"></p> 
<ul><li><code>Cargo.toml</code> 为 Rust 的清单文件。其中包含了项目的元数据和依赖库。</li><li><code>src/main.rs</code> 为编写应用代码的地方。</li></ul> 
<p>进入新创建的目录中，执行命令运行此程序：<strong><span style="background-color:#ffd900;">cargo run</span></strong></p> 
<p class="img-center"><img alt="" height="140" src="https://images2.imgbox.com/f6/3b/Yufzm1SM_o.png" width="573"></p> 
<p></p> 
<h4>添加 依赖</h4> 
<p>现在来为程序添加依赖。可以在 <a href="https://crates.io/" rel="nofollow" title="crates.io">crates.io</a>，即 Rust 包的仓库中找到所有类别的库。<span style="color:#fe2c24;"><strong>在 Rust 中通常把 "包" 称作 "crates"</strong></span>。在本项目中，使用了名为 <a href="https://crates.io/crates/ferris-says" rel="nofollow" title="ferris-says">ferris-says</a> 的库。</p> 
<p>在 <code>Cargo.toml</code> 文件中添加以下信息（从 crate 页面上获取）：</p> 
<blockquote> 
 <p>[dependencies]<br> ferris-says = "0.3.1"</p> 
</blockquote> 
<h4>下载 依赖</h4> 
<blockquote> 
 <p>运行：<strong><span style="background-color:#ffd900;">cargo build</span></strong>  ， Cargo 就会安装该依赖。运行 build 会创建一个新文件 <code>Cargo.lock</code>，该文件记录了本地所用依赖库的精确版本。</p> 
</blockquote> 
<h4>使用 依赖</h4> 
<blockquote> 
 <p>使用该依赖库：可以打开 <code>main.rs</code>，删除其中所有的内容（它不过是个示例而已），然后在其中添加下面这行代码：<strong><span style="background-color:#ffd900;">use ferris_says::say;</span></strong></p> 
 <p>这样就可以使用 <code>ferris-says</code> crate 中导出的 <code>say</code> 函数了。</p> 
</blockquote> 
<h4>完整 Rust 示例</h4> 
<p>现在用上面的依赖库编写一个小应用。在 <code>main.rs</code> 中添加以下代码：</p> 
<pre><code class="language-rust">use ferris_says::say; // from the previous step
use std::io::{stdout, BufWriter};

fn main() {
    let stdout = stdout();
    let message = String::from("Hello fellow Rustaceans!");
    let width = message.chars().count();

    let mut writer = BufWriter::new(stdout.lock());
    say(&amp;message, width, &amp;mut writer).unwrap();
}</code></pre> 
<p>保存完毕后，执行命令运行程序：cargo run</p> 
<p class="img-center"><img alt="" height="607" src="https://images2.imgbox.com/78/47/v0n6TiTZ_o.png" width="605"></p> 
<p>成功执行后，会打印一个字符形式的螃蟹图案。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/80/7b/eS5Q4J9t_o.gif"></p> 
<p>Ferris ( 费理斯 ) 是 Rust 社区的非官方吉祥物。</p> 
<p></p> 
<p></p> 
<p></p> 
<h2>2、Rust 相关文档</h2> 
<p></p> 
<p>：<a class="link-info" href="https://www.rust-lang.org/zh-CN/learn" rel="nofollow" title="https://www.rust-lang.org/zh-CN/learn">https://www.rust-lang.org/zh-CN/learn</a></p> 
<p></p> 
<h3>核心文档</h3> 
<p>以下所有文档都可以用 <code>rustup doc</code> 命令在本地阅读，它会在浏览器中离线打开这些资源！</p> 
<p></p> 
<h4>标准库</h4> 
<blockquote> 
 <p>详尽的 Rust 标准库 API 手册。：<a class="link-info" href="https://doc.rust-lang.org/std/index.html" rel="nofollow" title="https://doc.rust-lang.org/std/index.html">https://doc.rust-lang.org/std/index.html</a></p> 
</blockquote> 
<h4>版本指南</h4> 
<blockquote> 
 <p>Rust 版本指南。：<a class="link-info" href="https://doc.rust-lang.org/edition-guide/index.html" rel="nofollow" title="https://doc.rust-lang.org/edition-guide/index.html">https://doc.rust-lang.org/edition-guide/index.html</a></p> 
</blockquote> 
<h4>CARGO 手册</h4> 
<blockquote> 
 <p>Rust 的包管理器和构建系统。：<a class="link-info" href="https://doc.rust-lang.org/cargo/index.html" rel="nofollow" title="https://doc.rust-lang.org/cargo/index.html">https://doc.rust-lang.org/cargo/index.html</a></p> 
</blockquote> 
<p></p> 
<p>Cargo 有两个主要的配置：运行 <code>cargo build</code> 时采用的 <code>dev</code> 配置和运行 <code>cargo build --release</code> 的 <code>release</code> 配置。<code>dev</code> 配置为开发定义了良好的默认配置，<code>release</code> 配置则为发布构建定义了良好的默认配置。</p> 
<p>可以在项目中使用 <a href="https://crates.io/" rel="nofollow" title="crates.io">crates.io</a> 上的包作为依赖，也可以发布自己的包来向他人分享代码。<a href="https://crates.io/" rel="nofollow" title="crates.io">crates.io</a> 用来分发包的源代码，所以它主要托管开源代码。</p> 
<p>文档注释使用三斜杠 <code>///</code></p> 
<p>使用 pub use 导出合适的公有 API</p> 
<pre><code class="language-rust">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
    }
}</code></pre> 
<p></p> 
<p></p> 
<h4>RUSTDOC 手册</h4> 
<blockquote> 
 <p>学习如何为 crate 编写完美的文档。：<a class="link-info" href="https://doc.rust-lang.org/rustdoc/index.html" rel="nofollow" title="https://doc.rust-lang.org/rustdoc/index.html">https://doc.rust-lang.org/rustdoc/index.html</a></p> 
</blockquote> 
<h4>RUSTC 手册</h4> 
<blockquote> 
 <p>熟悉 Rust 编译器中可用的选项。：<a class="link-info" href="https://doc.rust-lang.org/rustc/index.html" rel="nofollow" title="https://doc.rust-lang.org/rustc/index.html">https://doc.rust-lang.org/rustc/index.html</a></p> 
</blockquote> 
<h4>编译错误索引表</h4> 
<blockquote> 
 <p>深入解释遇到的编译错误。：<a class="link-info" href="https://doc.rust-lang.org/error_codes/error-index.html" rel="nofollow" title="https://doc.rust-lang.org/error_codes/error-index.html">https://doc.rust-lang.org/error_codes/error-index.html</a></p> 
</blockquote> 
<p></p> 
<h3>Rust 程序</h3> 
<h4>命令行 程序</h4> 
<blockquote> 
 <p>用 Rust 构建高效的命令行应用。：<a class="link-info" href="https://rust-cli.github.io/book/index.html" rel="nofollow" title="https://rust-cli.github.io/book/index.html">https://rust-cli.github.io/book/index.html</a></p> 
</blockquote> 
<h4>WEBASSEMBLY 手册</h4> 
<blockquote> 
 <p>通过 WebAssembly 用 Rust 构建浏览器原生的库。：<a class="link-info" href="https://rustwasm.github.io/docs/book/" rel="nofollow" title="https://rustwasm.github.io/docs/book/">https://rustwasm.github.io/docs/book/</a></p> 
</blockquote> 
<h4>嵌入式手册</h4> 
<blockquote> 
 <p>Rust 编写嵌入式程序。：<a class="link-info" href="https://doc.rust-lang.org/stable/embedded-book/" rel="nofollow" title="https://doc.rust-lang.org/stable/embedded-book/">https://doc.rust-lang.org/stable/embedded-book/</a></p> 
</blockquote> 
<p></p> 
<h3>Learn X in Y</h3> 
<pre><code class="language-rust">// 这是注释，单行注释...
/* ...这是多行注释 */

///
// 1. 基础   //
///

// 函数 (Functions)
// `i32` 是有符号 32 位整数类型(32-bit signed integers)
fn add2(x: i32, y: i32) -&gt; i32 {
    // 隐式返回 (不要分号)
    x + y
}

// 主函数(Main function)
fn main() {
    // 数字 (Numbers) //

    // 不可变绑定
    let x: i32 = 1;

    // 整形/浮点型数 后缀
    let y: i32 = 13i32;
    let f: f64 = 1.3f64;

    // 类型推导
    // 大部分时间，Rust 编译器会推导变量类型，所以不必把类型显式写出来。
    // 这个教程里面很多地方都显式写了类型，但是只是为了示范。
    // 绝大部分时间可以交给类型推导。
    let implicit_x = 1;
    let implicit_f = 1.3;

    // 算术运算
    let sum = x + y + 13;

    // 可变变量
    let mut mutable = 1;
    mutable = 4;
    mutable += 2;

    // 字符串 (Strings) //

    // 字符串字面量
    let x: &amp;str = "hello world!";

    // 输出
    println!("{} {}", f, x); // 1.3 hello world

    // 一个 `String` – 在堆上分配空间的字符串
    let s: String = "hello world".to_string();

    // 字符串分片(slice) - 另一个字符串的不可变视图
    // 基本上就是指向一个字符串的不可变指针，它不包含字符串里任何内容，只是一个指向某个东西的指针
    // 比如这里就是 `s`
    let s_slice: &amp;str = &amp;s;

    println!("{} {}", s, s_slice); // hello world hello world

    // 数组 (Vectors/arrays) //

    // 长度固定的数组 (array)
    let four_ints: [i32; 4] = [1, 2, 3, 4];

    // 变长数组 (vector)
    let mut vector: Vec&lt;i32&gt; = vec![1, 2, 3, 4];
    vector.push(5);

    // 分片 - 某个数组(vector/array)的不可变视图
    // 和字符串分片基本一样，只不过是针对数组的
    let slice: &amp;[i32] = &amp;vector;

    // 使用 `{:?}` 按调试样式输出
    println!("{:?} {:?}", vector, slice); // [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]

    // 元组 (Tuples) //

    // 元组是固定大小的一组值，可以是不同类型
    let x: (i32, &amp;str, f64) = (1, "hello", 3.4);

    // 解构 `let`
    let (a, b, c) = x;
    println!("{} {} {}", a, b, c); // 1 hello 3.4

    // 索引
    println!("{}", x.1); // hello

    //
    // 2. 类型 (Type)  //
    //

    // 结构体（Sturct)
    struct Point {
        x: i32,
        y: i32,
    }

    let origin: Point = Point { x: 0, y: 0 };

    // 匿名成员结构体，又叫“元组结构体”（‘tuple struct’）
    struct Point2(i32, i32);

    let origin2 = Point2(0, 0);

    // 基础的 C 风格枚举类型（enum）
    enum Direction {
        Left,
        Right,
        Up,
        Down,
    }

    let up = Direction::Up;

    // 有成员的枚举类型
    enum OptionalI32 {
        AnI32(i32),
        Nothing,
    }

    let two: OptionalI32 = OptionalI32::AnI32(2);
    let nothing = OptionalI32::Nothing;

    // 泛型 (Generics) //

    struct Foo&lt;T&gt; { bar: T }

    // 这个在标准库里面有实现，叫 `Option`
    enum Optional&lt;T&gt; {
        SomeVal(T),
        NoVal,
    }

    // 方法 (Methods) //

    impl&lt;T&gt; Foo&lt;T&gt; {
        // 方法需要一个显式的 `self` 参数
        fn get_bar(self) -&gt; T {
            self.bar
        }
    }

    let a_foo = Foo { bar: 1 };
    println!("{}", a_foo.get_bar()); // 1

    // 接口（Traits） （其他语言里叫 interfaces 或 typeclasses） //

    trait Frobnicate&lt;T&gt; {
        fn frobnicate(self) -&gt; Option&lt;T&gt;;
    }

    impl&lt;T&gt; Frobnicate&lt;T&gt; for Foo&lt;T&gt; {
        fn frobnicate(self) -&gt; Option&lt;T&gt; {
            Some(self.bar)
        }
    }

    let another_foo = Foo { bar: 1 };
    println!("{:?}", another_foo.frobnicate()); // Some(1)

    ///
    // 3. 模式匹配 (Pattern matching) //
    ///

    let foo = OptionalI32::AnI32(1);
    match foo {
        OptionalI32::AnI32(n) =&gt; println!("it’s an i32: {}", n),
        OptionalI32::Nothing  =&gt; println!("it’s nothing!"),
    }

    // 高级模式匹配
    struct FooBar { x: i32, y: OptionalI32 }
    let bar = FooBar { x: 15, y: OptionalI32::AnI32(32) };

    match bar {
        FooBar { x: 0, y: OptionalI32::AnI32(0) } =&gt;
            println!("The numbers are zero!"),
        FooBar { x: n, y: OptionalI32::AnI32(m) } if n == m =&gt;
            println!("The numbers are the same"),
        FooBar { x: n, y: OptionalI32::AnI32(m) } =&gt;
            println!("Different numbers: {} {}", n, m),
        FooBar { x: _, y: OptionalI32::Nothing } =&gt;
            println!("The second number is Nothing!"),
    }

    ///
    // 4. 流程控制 (Control flow) //
    ///

    // `for` 循环
    let array = [1, 2, 3];
    for i in array {
        println!("{}", i);
    }

    // 区间 (Ranges)
    for i in 0u32..10 {
        print!("{} ", i);
    }
    println!("");
    // 输出 `0 1 2 3 4 5 6 7 8 9 `

    // `if`
    if 1 == 1 {
        println!("Maths is working!");
    } else {
        println!("Oh no...");
    }

    // `if` 可以当表达式
    let value = if true {
        "good"
    } else {
        "bad"
    };

    // `while` 循环
    while 1 == 1 {
        println!("The universe is operating normally.");
    }

    // 无限循环
    loop {
        println!("Hello!");
    }

    
    // 5. 内存安全和指针 (Memory safety &amp; pointers) //
    

    // 独占指针 (Owned pointer) - 同一时刻只能有一个对象能“拥有”这个指针
    // 意味着 `Box` 离开他的作用域后，会被安全地释放
    let mut mine: Box&lt;i32&gt; = Box::new(3);
    *mine = 5; // 解引用
    // `now_its_mine` 获取了 `mine` 的所有权。换句话说，`mine` 移动 (move) 了
    let mut now_its_mine = mine;
    *now_its_mine += 2;

    println!("{}", now_its_mine); // 7
    // println!("{}", mine); // 编译报错，因为现在 `now_its_mine` 独占那个指针

    // 引用 (Reference) – 引用其他数据的不可变指针
    // 当引用指向某个值，我们称为“借用”这个值，因为是被不可变的借用，所以不能被修改，也不能移动
    // 借用一直持续到生命周期结束，即离开作用域
    let mut var = 4;
    var = 3;
    let ref_var: &amp;i32 = &amp;var;

    println!("{}", var); //不像 `mine`, `var` 还可以继续使用
    println!("{}", *ref_var);
    // var = 5; // 编译报错，因为 `var` 被借用了
    // *ref_var = 6; // 编译报错，因为 `ref_var` 是不可变引用

    // 可变引用 (Mutable reference)
    // 当一个变量被可变地借用时，也不可使用
    let mut var2 = 4;
    let ref_var2: &amp;mut i32 = &amp;mut var2;
    *ref_var2 += 2;

    println!("{}", *ref_var2); // 6
    // var2 = 2; // 编译报错，因为 `var2` 被借用了
}</code></pre> 
<h4><strong>rust 打印占位符</strong></h4> 
<p>格式化输出：<a class="link-info" href="https://rustwiki.org/zh-CN/rust-by-example/hello/print.html" rel="nofollow" title="https://rustwiki.org/zh-CN/rust-by-example/hello/print.html">https://rustwiki.org/zh-CN/rust-by-example/hello/print.html</a></p> 
<p>在 Rust 中，打印的占位符由格式化宏提供，最常用的是 <code>println!</code> 和 <code>format!</code>。下面是一些常见的占位符及其用法：</p> 
<ul><li>{}：默认占位符，根据值的类型自动选择合适的显示方式。</li><li>{:?}：调试占位符，用于打印调试信息。通常用于 Debug trait 的实现。</li><li>{:#?}：类似于 {:?}，但打印出更具可读性的格式化调试信息，可以嵌套显示结构体和枚举的字段。</li><li>{x}：将变量 x 的值插入到占位符的位置。</li><li>{x:format}：将变量 x 按照指定的格式进行格式化输出。例如，{x:?}", {x:b}, {x:e}` 等。</li></ul> 
<p>这只是一小部分常见的占位符用法，你还可以根据需要使用其他格式化选项。Rust 的格式化宏提供了非常灵活和强大的格式化功能，可以满足大多数打印需求。</p> 
<pre><code class="language-rust">fn main() {
    let name = "Alice";
    let age = 25;
    let height = 1.65;

    println!("Name: {}", name);
    println!("Age: {}", age);
    println!("Height: {:.2}", height);  // 格式化为小数点后两位

    let point = (3, 5);
    println!("Point: {:?}", point);
}
</code></pre> 
<p>打印 "枚举、结构体"</p> 
<pre><code class="language-rust">#[derive(Debug)]
enum MyEnum {
    Variant1,
    Variant2(u32),
    Variant3 { name: String, age: u32 },
}

#[derive(Debug)]
struct MyStruct{
    field_1: String,
    field_2: usize,
}

impl MyStruct {
    fn init_field(&amp;self){
        let name = &amp;self.field_1;
        let age = self.field_2;
        println!("{name} ---&gt; {age}")
    }
}

fn main() {
    let my_enum = MyEnum::Variant2(42);
    println!("{:?}", my_enum);
    let my_struct = MyStruct{
        field_1: String::from("king"),
        field_2: 100
    };
    my_struct.init_field();
    println!("{:?}", my_struct);
}
</code></pre> 
<p></p> 
<p></p> 
<h2>3、<strong>Rust 程序设计语言</strong></h2> 
<p></p> 
<p>英文文档：<a class="link-info" href="https://doc.rust-lang.org/book/" rel="nofollow" title="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></p> 
<p>中文文档：<a class="link-info" href="https://kaisery.github.io/trpl-zh-cn/" rel="nofollow" title="https://kaisery.github.io/trpl-zh-cn/">https://kaisery.github.io/trpl-zh-cn/</a></p> 
<p><strong>《Rust 程序设计语言》</strong>被亲切地称为“圣经”。给出了 Rust 语言的概览。在阅读的过程中构建几个项目，读完后，就能扎实地掌握 Rust 语言。</p> 
<ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch01-00-getting-started.html" rel="nofollow" title="1. 入门指南">1. 入门指南</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch01-01-installation.html" rel="nofollow" title="1.1. 安装">1.1. 安装</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html" rel="nofollow" title="1.2. Hello, World!">1.2. Hello, World!</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch01-03-hello-cargo.html" rel="nofollow" title="1.3. Hello, Cargo!">1.3. Hello, Cargo!</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch02-00-guessing-game-tutorial.html" rel="nofollow" title="2. 写个猜数字游戏">2. 写个猜数字游戏</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch03-00-common-programming-concepts.html" rel="nofollow" title="3. 常见编程概念">3. 常见编程概念</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch03-01-variables-and-mutability.html" rel="nofollow" title="3.1. 变量与可变性">3.1. 变量与可变性</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html" rel="nofollow" title="3.2. 数据类型">3.2. 数据类型</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch03-03-how-functions-work.html" rel="nofollow" title="3.3. 函数">3.3. 函数</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch03-04-comments.html" rel="nofollow" title="3.4. 注释">3.4. 注释</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch03-05-control-flow.html" rel="nofollow" title="3.5. 控制流">3.5. 控制流</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch04-00-understanding-ownership.html" rel="nofollow" title="4. 认识所有权">4. 认识所有权</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html" rel="nofollow" title="4.1. 什么是所有权？">4.1. 什么是所有权？</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html" rel="nofollow" title="4.2. 引用与借用">4.2. 引用与借用</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html" rel="nofollow" title="4.3. Slice 类型">4.3. Slice 类型</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch05-00-structs.html" rel="nofollow" title="5. 使用结构体组织相关联的数据">5. 使用结构体组织相关联的数据</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html" rel="nofollow" title="5.1. 结构体的定义和实例化">5.1. 结构体的定义和实例化</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch05-02-example-structs.html" rel="nofollow" title="5.2. 结构体示例程序">5.2. 结构体示例程序</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html" rel="nofollow" title="5.3. 方法语法">5.3. 方法语法</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch06-00-enums.html" rel="nofollow" title="6. 枚举和模式匹配">6. 枚举和模式匹配</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch06-01-defining-an-enum.html" rel="nofollow" title="6.1. 枚举的定义">6.1. 枚举的定义</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html" rel="nofollow" title="6.2. match 控制流结构">6.2. match 控制流结构</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch06-03-if-let.html" rel="nofollow" title="6.3. if let 简洁控制流">6.3. if let 简洁控制流</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html" rel="nofollow" title="7. 使用包、Crate 和模块管理不断增长的项目">7. 使用包、Crate 和模块管理不断增长的项目</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch07-01-packages-and-crates.html" rel="nofollow" title="7.1. 包和 Crate">7.1. 包和 Crate</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch07-02-defining-modules-to-control-scope-and-privacy.html" rel="nofollow" title="7.2. 定义模块来控制作用域与私有性">7.2. 定义模块来控制作用域与私有性</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" rel="nofollow" title="7.3. 引用模块项目的路径">7.3. 引用模块项目的路径</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" rel="nofollow" title="7.4. 使用 use 关键字将路径引入作用域">7.4. 使用 use 关键字将路径引入作用域</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch07-05-separating-modules-into-different-files.html" rel="nofollow" title="7.5. 将模块拆分成多个文件">7.5. 将模块拆分成多个文件</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch08-00-common-collections.html" rel="nofollow" title="8. 常见集合">8. 常见集合</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch08-01-vectors.html" rel="nofollow" title="8.1. 使用 Vector 储存列表">8.1. 使用 Vector 储存列表</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html" rel="nofollow" title="8.2. 使用字符串储存 UTF-8 编码的文本">8.2. 使用字符串储存 UTF-8 编码的文本</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch08-03-hash-maps.html" rel="nofollow" title="8.3. 使用 Hash Map 储存键值对">8.3. 使用 Hash Map 储存键值对</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch09-00-error-handling.html" rel="nofollow" title="9. 错误处理">9. 错误处理</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch09-01-unrecoverable-errors-with-panic.html" rel="nofollow" title="9.1. 用 panic! 处理不可恢复的错误">9.1. 用 panic! 处理不可恢复的错误</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html" rel="nofollow" title="9.2. 用 Result 处理可恢复的错误">9.2. 用 Result 处理可恢复的错误</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html" rel="nofollow" title="9.3. 要不要 panic!">9.3. 要不要 panic!</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch10-00-generics.html" rel="nofollow" title="10. 泛型、Trait 和生命周期">10. 泛型、Trait 和生命周期</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html" rel="nofollow" title="10.1. 泛型数据类型">10.1. 泛型数据类型</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html" rel="nofollow" title="10.2. Trait：定义共同行为">10.2. Trait：定义共同行为</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html" rel="nofollow" title="10.3. 生命周期确保引用有效">10.3. 生命周期确保引用有效</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch11-00-testing.html" rel="nofollow" title="11. 编写自动化测试">11. 编写自动化测试</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch11-01-writing-tests.html" rel="nofollow" title="11.1. 如何编写测试">11.1. 如何编写测试</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch11-02-running-tests.html" rel="nofollow" title="11.2. 控制测试如何运行">11.2. 控制测试如何运行</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch11-03-test-organization.html" rel="nofollow" title="11.3. 测试的组织结构">11.3. 测试的组织结构</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch12-00-an-io-project.html" rel="nofollow" title="12. 一个 I/O 项目：构建命令行程序">12. 一个 I/O 项目：构建命令行程序</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch12-01-accepting-command-line-arguments.html" rel="nofollow" title="12.1. 接受命令行参数">12.1. 接受命令行参数</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch12-02-reading-a-file.html" rel="nofollow" title="12.2. 读取文件">12.2. 读取文件</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch12-03-improving-error-handling-and-modularity.html" rel="nofollow" title="12.3. 重构以改进模块化与错误处理">12.3. 重构以改进模块化与错误处理</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch12-04-testing-the-librarys-functionality.html" rel="nofollow" title="12.4. 采用测试驱动开发完善库的功能">12.4. 采用测试驱动开发完善库的功能</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch12-05-working-with-environment-variables.html" rel="nofollow" title="12.5. 处理环境变量">12.5. 处理环境变量</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch12-06-writing-to-stderr-instead-of-stdout.html" rel="nofollow" title="12.6. 将错误信息输出到标准错误而不是标准输出">12.6. 将错误信息输出到标准错误而不是标准输出</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch13-00-functional-features.html" rel="nofollow" title="13. Rust 中的函数式语言功能：迭代器与闭包">13. Rust 中的函数式语言功能：迭代器与闭包</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch13-01-closures.html" rel="nofollow" title="13.1. 闭包：可以捕获其环境的匿名函数">13.1. 闭包：可以捕获其环境的匿名函数</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch13-02-iterators.html" rel="nofollow" title="13.2. 使用迭代器处理元素序列">13.2. 使用迭代器处理元素序列</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch13-03-improving-our-io-project.html" rel="nofollow" title="13.3. 改进之前的 I/O 项目">13.3. 改进之前的 I/O 项目</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch13-04-performance.html" rel="nofollow" title="13.4. 性能比较：循环对迭代器">13.4. 性能比较：循环对迭代器</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch14-00-more-about-cargo.html" rel="nofollow" title="14. 更多关于 Cargo 和 Crates.io 的内容">14. 更多关于 Cargo 和 Crates.io 的内容</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch14-01-release-profiles.html" rel="nofollow" title="14.1. 采用发布配置自定义构建">14.1. 采用发布配置自定义构建</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch14-02-publishing-to-crates-io.html" rel="nofollow" title="14.2. 将 crate 发布到 Crates.io">14.2. 将 crate 发布到 Crates.io</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch14-03-cargo-workspaces.html" rel="nofollow" title="14.3. Cargo 工作空间">14.3. Cargo 工作空间</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch14-04-installing-binaries.html" rel="nofollow" title="14.4. 使用 cargo install 安装二进制文件">14.4. 使用 cargo install 安装二进制文件</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch14-05-extending-cargo.html" rel="nofollow" title="14.5. Cargo 自定义扩展命令">14.5. Cargo 自定义扩展命令</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch15-00-smart-pointers.html" rel="nofollow" title="15. 智能指针">15. 智能指针</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch15-01-box.html" rel="nofollow" title="15.1. 使用Box&lt;T&gt; 指向堆上数据">15.1. 使用Box&lt;T&gt; 指向堆上数据</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch15-02-deref.html" rel="nofollow" title="15.2. 使用Deref Trait 将智能指针当作常规引用处理">15.2. 使用Deref Trait 将智能指针当作常规引用处理</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch15-03-drop.html" rel="nofollow" title="15.3. 使用Drop Trait 运行清理代码">15.3. 使用Drop Trait 运行清理代码</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch15-04-rc.html" rel="nofollow" title="15.4. Rc&lt;T&gt; 引用计数智能指针">15.4. Rc&lt;T&gt; 引用计数智能指针</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch15-05-interior-mutability.html" rel="nofollow" title="15.5. RefCell&lt;T&gt; 与内部可变性模式">15.5. RefCell&lt;T&gt; 与内部可变性模式</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch15-06-reference-cycles.html" rel="nofollow" title="15.6. 引用循环会导致内存泄漏">15.6. 引用循环会导致内存泄漏</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch16-00-concurrency.html" rel="nofollow" title="16. 无畏并发">16. 无畏并发</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch16-01-threads.html" rel="nofollow" title="16.1. 使用线程同时地运行代码">16.1. 使用线程同时地运行代码</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch16-02-message-passing.html" rel="nofollow" title="16.2. 使用消息传递在线程间通信">16.2. 使用消息传递在线程间通信</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch16-03-shared-state.html" rel="nofollow" title="16.3. 共享状态并发">16.3. 共享状态并发</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch16-04-extensible-concurrency-sync-and-send.html" rel="nofollow" title="16.4. 使用Sync 与 Send Traits 的可扩展并发">16.4. 使用Sync 与 Send Traits 的可扩展并发</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch17-00-oop.html" rel="nofollow" title="17. Rust 的面向对象编程特性">17. Rust 的面向对象编程特性</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch17-01-what-is-oo.html" rel="nofollow" title="17.1. 面向对象语言的特点">17.1. 面向对象语言的特点</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch17-02-trait-objects.html" rel="nofollow" title="17.2. 为使用不同类型的值而设计的 trait 对象">17.2. 为使用不同类型的值而设计的 trait 对象</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch17-03-oo-design-patterns.html" rel="nofollow" title="17.3. 面向对象设计模式的实现">17.3. 面向对象设计模式的实现</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch18-00-patterns.html" rel="nofollow" title="18. 模式与模式匹配">18. 模式与模式匹配</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch18-01-all-the-places-for-patterns.html" rel="nofollow" title="18.1. 所有可能会用到模式的位置">18.1. 所有可能会用到模式的位置</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch18-02-refutability.html" rel="nofollow" title="18.2. Refutability（可反驳性）: 模式是否会匹配失效">18.2. Refutability（可反驳性）: 模式是否会匹配失效</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html" rel="nofollow" title="18.3. 模式语法">18.3. 模式语法</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch19-00-advanced-features.html" rel="nofollow" title="19. 高级特征">19. 高级特征</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch19-01-unsafe-rust.html" rel="nofollow" title="19.1. 不安全的 Rust">19.1. 不安全的 Rust</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch19-03-advanced-traits.html" rel="nofollow" title="19.2. 高级 trait">19.2. 高级 trait</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch19-04-advanced-types.html" rel="nofollow" title="19.3. 高级类型">19.3. 高级类型</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch19-05-advanced-functions-and-closures.html" rel="nofollow" title="19.4. 高级函数与闭包">19.4. 高级函数与闭包</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html" rel="nofollow" title="19.5. 宏">19.5. 宏</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch20-00-final-project-a-web-server.html" rel="nofollow" title="20. 最后的项目：构建多线程 web server">20. 最后的项目：构建多线程 web server</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/ch20-01-single-threaded.html" rel="nofollow" title="20.1. 建立单线程 web server">20.1. 建立单线程 web server</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch20-02-multithreaded.html" rel="nofollow" title="20.2. 将单线程 server 变为多线程 server">20.2. 将单线程 server 变为多线程 server</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/ch20-03-graceful-shutdown-and-cleanup.html" rel="nofollow" title="20.3. 优雅停机与清理">20.3. 优雅停机与清理</a></li></ol></li><li><a href="https://kaisery.github.io/trpl-zh-cn/appendix-00.html" rel="nofollow" title="21. 附录">21. 附录</a></li><li> 
  <ol><li><a href="https://kaisery.github.io/trpl-zh-cn/appendix-01-keywords.html" rel="nofollow" title="21.1. A - 关键字">21.1. A - 关键字</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/appendix-02-operators.html" rel="nofollow" title="21.2. B - 运算符与符号">21.2. B - 运算符与符号</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/appendix-03-derivable-traits.html" rel="nofollow" title="21.3. C - 可派生的 trait">21.3. C - 可派生的 trait</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/appendix-04-useful-development-tools.html" rel="nofollow" title="21.4. D - 实用开发工具">21.4. D - 实用开发工具</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/appendix-05-editions.html" rel="nofollow" title="21.5. E - 版本">21.5. E - 版本</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/appendix-06-translation.html" rel="nofollow" title="21.6. F - 本书译本">21.6. F - 本书译本</a></li><li><a href="https://kaisery.github.io/trpl-zh-cn/appendix-07-nightly-rust.html" rel="nofollow" title="21.7. G - Rust 是如何开发的与 “Nightly Rust”">21.7. G - Rust 是如何开发的与 “Nightly Rust”</a></li></ol></li></ol> 
<p></p> 
<h3>使用 <code>let</code> 定义变量</h3> 
<ul><li>使用 <code>let</code> 定义变量。使用注解来描述变量的类型。当编译器可以自动推导出变量的类型时，注解可以省略。</li><li>变量绑定默认是不可变的（immutable），但加上 <code>mut</code> 修饰语后变量就可以改变。</li><li>变量绑定有一个作用域（scope），它被限定只在一个<strong>代码块</strong>（block）中生存（live）。 代码块是一个被 <code>{}</code> 包围的语句集合。另外也允许<a href="https://en.wikipedia.org/wiki/Variable_shadowing" rel="nofollow" title="变量遮蔽">变量遮蔽</a>（variable shadowing）。</li><li>编译器禁止使用未经初始化的变量，因为这会产生未定义行为（undefined behavior）。</li><li>当数据被相同的名称不变地绑定时，它还会<strong>冻结</strong>（freeze）。在不可变绑定超出作用域之前，无法修改已冻结的数据：</li></ul> 
<pre><code class="language-rust">fn main() {
    let mut _mutable_integer = 7i32;

    {
        // 被不可变的 `_mutable_integer` 遮蔽
        let _mutable_integer = _mutable_integer;

        // 报错！`_mutable_integer` 在本作用域被冻结
        _mutable_integer = 50;
        // 改正 ^ 注释掉上面这行

        // `_mutable_integer` 离开作用域
    }

    // 正常运行！ `_mutable_integer` 在这个作用域没有冻结
    _mutable_integer = 3;
}
</code></pre> 
<p>示例</p> 
<pre><code class="language-rust">fn main() {
    // let 变量赋值
    // let PATTERN = EXPRESSION;
    let x = 5;
    let (a, b, c) = (1, 2, 3);
    let (x1, y2, _) = (1, 2, 3);

}</code></pre> 
<p></p> 
<h3>Rust 数据类型</h3> 
<ul><li>Rust 是 <strong>静态类型</strong>（<em>statically typed</em>）语言，在编译时就必须知道所有变量的类型。</li><li>Rust 不提供原生类型之间的隐式类型转换（coercion），但可以使用 <code>as</code> 关键字进行显式类型转换（casting）。</li><li>可以用 <code>type</code> 语句给已有的类型取个新的名字。类型的名字必须遵循驼峰命名法（像是 <code>CamelCase</code> 这样），否则编译器将给出警告。原生类型是例外，比如： <code>usize</code>、<code>f32</code>，等等。</li></ul> 
<p>内置类型列表：</p> 
<ul><li>原生类型(primitive types): 
  <ul><li><a href="https://rustwiki.org/zh-CN/reference/types/boolean.html" rel="nofollow" title="布尔型(Boolean)">布尔型(Boolean)</a> — <code>true</code> 或 <code>false</code></li><li><a href="https://rustwiki.org/zh-CN/reference/types/numeric.html" rel="nofollow" title="数字类(Numeric)">数字类(Numeric)</a> — 整型(integer) 和 浮点型(float)</li><li><a href="https://rustwiki.org/zh-CN/reference/types/textual.html" rel="nofollow" title="文本类(Textual)">文本类(Textual)</a> — 字符型(<code>char</code>) 和 字符串切片(<code>str</code>)</li><li><a href="https://rustwiki.org/zh-CN/reference/types/never.html" rel="nofollow" title="never类型">never类型</a> — <code>!</code> — 没有值的类型</li></ul></li><li>序列类型(sequence types)： 
  <ul><li><a href="https://rustwiki.org/zh-CN/reference/types/tuple.html" rel="nofollow" title="元组(Tuple)">元组(Tuple)</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/array.html" rel="nofollow" title="数组(Array)">数组(Array)</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/slice.html" rel="nofollow" title="切片(Slice)">切片(Slice)</a></li></ul></li><li>用户自定义类型(user-defined types)： 
  <ul><li><a href="https://rustwiki.org/zh-CN/reference/types/struct.html" rel="nofollow" title="结构体(Struct)">结构体(Struct)</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/enum.html" rel="nofollow" title="枚举(Enum)">枚举(Enum)</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/union.html" rel="nofollow" title="联合体(Union)">联合体(Union)</a></li></ul></li><li>函数类型(function types)： 
  <ul><li><a href="https://rustwiki.org/zh-CN/reference/types/function-item.html" rel="nofollow" title="函数(Functions)">函数(Functions)</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/closure.html" rel="nofollow" title="闭包(Closures)">闭包(Closures)</a></li></ul></li><li>指针类型(pointer types)： 
  <ul><li><a href="https://rustwiki.org/zh-CN/reference/types/pointer.html#shared-references-" rel="nofollow" title="引用(References)">引用(References)</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/pointer.html#raw-pointers-const-and-mut" rel="nofollow" title="裸指针(Raw pointers)">裸指针(Raw pointers)</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/function-pointer.html" rel="nofollow" title="函数指针(Function pointers)">函数指针(Function pointers)</a></li></ul></li><li>trait类型(Trait types): 
  <ul><li><a href="https://rustwiki.org/zh-CN/reference/types/trait-object.html" rel="nofollow" title="trait对象(Trait objects)">trait对象(Trait objects)</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/impl-trait.html" rel="nofollow" title="实现trait(Impl trait)">实现trait(Impl trait)</a></li></ul></li></ul> 
<pre><code class="language-rust">// 不显示类型转换产生的溢出警告。
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // 错误！不提供隐式转换
    let integer: u8 = decimal;
    // 改正 ^ 注释掉这一行

    // 可以显式转换
    let integer = decimal as u8;
    let character = integer as char;

    println!("Casting: {} -&gt; {} -&gt; {}", decimal, integer, character);

    // 当把任何类型转换为无符号类型 T 时，会不断加上或减去 (std::T::MAX + 1)
    // 直到值位于新类型 T 的范围内。

    // 1000 已经在 u16 的范围内
    println!("1000 as a u16 is: {}", 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // 事实上的处理方式是：从最低有效位（LSB，least significant bits）开始保留
    // 8 位，然后剩余位置，直到最高有效位（MSB，most significant bit）都被抛弃。
    // 译注：MSB 就是二进制的最高位，LSB 就是二进制的最低位，按日常书写习惯就是
    // 最左边一位和最右边一位。
    println!("1000 as a u8 is : {}", 1000 as u8);
    // -1 + 256 = 255
    println!("  -1 as a u8 is : {}", (-1i8) as u8);

    // 对正数，这就和取模一样。
    println!("1000 mod 256 is : {}", 1000 % 256);

    // 当转换到有符号类型时，（位操作的）结果就和 “先转换到对应的无符号类型，
    // 如果 MSB 是 1，则该值为负” 是一样的。

    // 当然如果数值已经在目标类型的范围内，就直接把它放进去。
    println!(" 128 as a i16 is: {}", 128 as i16);
    // 128 转成 u8 还是 128，但转到 i8 相当于给 128 取八位的二进制补码，其值是：
    println!(" 128 as a i8 is : {}", 128 as i8);

    // 重复之前的例子
    // 1000 as u8 -&gt; 232
    println!("1000 as a u8 is : {}", 1000 as u8);
    // 232 的二进制补码是 -24
    println!(" 232 as a i8 is : {}", 232 as i8);
}
</code></pre> 
<pre><code class="language-rust">// `NanoSecond` 是 `u64` 的新名字。
type NanoSecond = u64;
type Inch = u64;

// 通过这个属性屏蔽警告。
#[allow(non_camel_case_types)]
type u64_t = u64;
// 试一试 ^ 移除上面那个属性

fn main() {
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    // 注意类型别名*并不能*提供额外的类型安全，因为别名*并不是*新的类型。
    println!("{} nanoseconds + {} inches = {} unit?",
             nanoseconds,
             inches,
             nanoseconds + inches);
}
</code></pre> 
<p></p> 
<h4>标量 ( <span style="color:#fe2c24;"><strong>整型、浮点型、布尔类型、字符</strong></span> )</h4> 
<p>Rust 2大类数据类型：标量、复合</p> 
<ul><li>标量（scalar）：代表一个单独的值。4种基本的标量：<span style="color:#fe2c24;"><strong>整型、浮点型、布尔类型、字符</strong></span>。</li></ul> 
<pre><code class="language-rust">fn main() {
    // 变量可以给出类型说明。
    let logical: bool = true;

    let a_float: f64 = 1.0;  // 常规说明
    let an_integer   = 5i32; // 后缀说明

    // 否则会按默认方式决定类型。
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`

    // 类型也可根据上下文自动推断。
    let mut inferred_type = 12; // 根据下一行的赋值推断为 i64 类型
    inferred_type = 12345i64;

    // 可变的（mutable）变量，其值可以改变。
    let mut mutable = 12; // Mutable `i32`
    mutable = 21;

    // 报错！变量的类型并不能改变。
    mutable = true;

    // 但可以用遮蔽（shadow）来覆盖前面的变量。
    let mutable = true;
}
</code></pre> 
<p></p> 
<h4>复合 ( <span style="color:#fe2c24;"><strong>元组、数组</strong></span> )</h4> 
<p>参见：<a href="https://rustwiki.org/zh-CN/std/" rel="nofollow" title="std 库">std 库</a>、<a href="https://rustwiki.org/zh-CN/rust-by-example/variable_bindings/mut.html" rel="nofollow" title="mut">mut</a>、<a href="https://rustwiki.org/zh-CN/rust-by-example/types/inference.html" rel="nofollow" title="类型推断">类型推断</a> 和 <a href="https://rustwiki.org/zh-CN/rust-by-example/variable_bindings/scope.html" rel="nofollow" title="变量遮蔽">变量遮蔽</a></p> 
<p>Rust 有两个原生的 复合（compound）类型：<span style="color:#fe2c24;"><strong>元组（tuple）、数组（array）</strong></span>。</p> 
<ul><li><span style="color:#fe2c24;"><strong>元组</strong></span> 是一个可以包含各种类型值的组合。元组使用括号 <code>()</code> 来构造（construct），而每个元组自身又是一个类型标记为 <code>(T1, T2, ...)</code> 的值，其中 <code>T1</code>、<code>T2</code> 是每个元素的类型。函数可以使用元组来返回多个值，因为元组可以拥有任意多个值。<strong><span style="background-color:#ffd900;">元组长度固定，一旦声明，其长度不会增大或缩小</span></strong>。一元元组的元素类型后面需要有一个逗号。</li><li><span style="color:#fe2c24;"><strong>数组（array）</strong></span>也可以包含多个值。但是与元组不同的是 "<strong><span style="background-color:#ffd900;">数组中的每个元素的类型必须相同</span></strong>"。<strong><span style="background-color:#ffd900;">Rust 中的数组长度是固定的</span></strong>。</li></ul> 
<p></p> 
<h4>元组</h4> 
<p>元组类型的示例：</p> 
<ul><li><code>()</code> 空元组（empty tuple），也被称为“单位类型”（unit type），类似于空结构体，不包含任何值。单位类型 <code>()</code> 在 Rust 中用于表示没有返回值的函数或表达式。一个函数不返回任何值的时候，其返回类型将是 ()。类似地，当调用一个没有返回值的函数或方法时，表达式的类型也将是 ()。</li><li><code>(f64, f64)</code></li><li><code>(String, i32)</code></li><li><code>(i32, String)</code> (跟前一个示例类型不一样)</li><li><code>(i32, f64, Vec&lt;String&gt;, Option&lt;bool&gt;)</code></li></ul> 
<p>元组字段可以通过<a href="https://rustwiki.org/zh-CN/reference/expressions/tuple-expr.html#tuple-indexing-expressions" rel="nofollow" title="元组索引表达式">元组索引表达式</a>或<a href="https://rustwiki.org/zh-CN/reference/patterns.html#tuple-patterns" rel="nofollow" title="模式匹配">模式匹配</a>来访问。</p> 
<pre><code>// 元组可以充当函数的参数和返回值
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
    // 可以使用 `let` 把一个元组的成员绑定到一些变量
    let (integer, boolean) = pair;

    (boolean, integer)
}

// 在 “动手试一试” 的练习中要用到下面这个结构体。
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // 包含各种不同类型的元组
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // 通过元组的下标来访问具体的值
    println!("long tuple first value: {}", long_tuple.0);
    println!("long tuple second value: {}", long_tuple.1);

    // 元组也可以充当元组的元素
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // 元组可以打印
    println!("tuple of tuples: {:?}", tuple_of_tuples);

    // 但很长的元组无法打印
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!("too long tuple: {:?}", too_long_tuple);
    // 试一试 ^ 取消上面两行的注释，阅读编译器给出的错误信息。

    let pair = (1, true);
    println!("pair is {:?}", pair);

    println!("the reversed pair is {:?}", reverse(pair));

    // 创建单元素元组需要一个额外的逗号，这是为了和被括号包含的字面量作区分。
    println!("one element tuple: {:?}", (5u32,));
    println!("just an integer: {:?}", (5u32));

    // 元组可以被解构（deconstruct），从而将值绑定给变量
    let tuple = (1, "hello", 4.5, true);

    let (a, b, c, d) = tuple;
    println!("{:?}, {:?}, {:?}, {:?}", a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!("{:?}", matrix)

}
</code></pre> 
<p></p> 
<h4>数组</h4> 
<ul><li>数组使用中括号 <code>[]</code> 来创建，是一组拥有相同类型 <code>T</code> 的对象的集合，在内存中是连续存储的。</li></ul> 
<pre><code class="language-rust">use std::mem;

// 此函数借用一个 slice
fn analyze_slice(slice: &amp;[i32]) {
    println!("first element of the slice: {}", slice[0]);
    println!("the slice has {} elements", slice.len());
}

fn main() {
    // 定长数组（类型标记是多余的）
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // 所有元素可以初始化成相同的值
    let ys: [i32; 500] = [0; 500];

    // 下标从 0 开始
    println!("first element of the array: {}", xs[0]);
    println!("second element of the array: {}", xs[1]);

    // `len` 返回数组的大小
    println!("array size: {}", xs.len());

    // 数组是在栈中分配的
    println!("array occupies {} bytes", mem::size_of_val(&amp;xs));

    // 数组可以自动被借用成为 slice
    println!("borrow the whole array as a slice");
    analyze_slice(&amp;xs);

    // slice 可以指向数组的一部分
    println!("borrow a section of the array as a slice");
    analyze_slice(&amp;ys[1 .. 4]);

    // 越界的下标会引发致命错误（panic）
    println!("{}", xs[5]);
}
</code></pre> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
// 一个栈分配的数组
    let array: [i32; 3] = [1, 2, 3];

// 一个堆分配的数组，被自动强转成切片
    let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h4>切片</h4> 
<ul><li>切片（slice）类型和数组类似，但其大小在编译时是不确定的。相反，切片是一个双字对象（two-word object），第一个字是一个指向数据的指针，第二个字是切片的长度。这个 “字” 的宽度和 usize 相同，由处理器架构决定，比如在 x86-64 平台上就是 64 位。slice 可以用来借用数组的一部分。slice 的类型标记为 <code>&amp;[T]</code>。</li></ul> 
<p><strong>句法</strong><br><em>SliceType</em> :<br>    <code>[</code> <a href="https://rustwiki.org/zh-CN/reference/types.html#type-expressions" rel="nofollow" title="Type">Type</a> <code>]</code></p> 
<p>切片是一种<a href="https://rustwiki.org/zh-CN/reference/dynamically-sized-types.html" rel="nofollow" title="动态尺寸类型(dynamically sized type)">动态尺寸类型(dynamically sized type)</a>，它代表类型为 <code>T</code> 的元素组成的数据序列的一个“视图(view)”。切片类型写为 <code>[T]</code>。</p> 
<p>要使用切片类型，通常必须放在指针后面使用，例如：</p> 
<ul><li><code>&amp;[T]</code>，共享切片('shared slice')，常被直接称为切片(<code>slice</code>)，它不拥有它指向的数据，只是借用。</li><li><code>&amp;mut [T]</code>，可变切片('mutable slice')，可变借用它指向的数据。</li><li><code>Box&lt;[T]&gt;</code>, boxed切片('boxed slice')。</li></ul> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
// 一个堆分配的数组，被自动强转成切片
    let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);

// 数组上的（共享）切片
    let slice: &amp;[i32] = &amp;boxed_array[..];
}</code></pre> 
<p></p> 
<h4>自定义类型：结构体、枚举</h4> 
<p>Rust 自定义数据类型主要是通过下面这两个关键字来创建：</p> 
<ul><li>struct： 定义一个结构体（structure）</li><li>enum： 定义一个枚举类型（enumeration）</li></ul> 
<pre><code class="language-rust">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// 单元结构体
struct Unit;

// 元组结构体
struct Pair(i32, f32);

// 带有两个字段的结构体
struct Point {
    x: f32,
    y: f32,
}

// 结构体可以作为另一个结构体的字段
#[allow(dead_code)]
struct Rectangle {
    // 可以在空间中给定左上角和右下角在空间中的位置来指定矩形。
    top_left: Point,
    bottom_right: Point,
}

fn main() {
    // 使用简单的写法初始化字段，并创建结构体
    let name = String::from("Peter");
    let age = 27;
    let peter = Person { name, age };

    // 以 Debug 方式打印结构体
    println!("{:?}", peter);

    // 实例化结构体 `Point`
    let point: Point = Point { x: 10.3, y: 0.4 };

    // 访问 point 的字段
    println!("point coordinates: ({}, {})", point.x, point.y);

    // 使用结构体更新语法创建新的 point，
    // 这样可以用到之前的 point 的字段
    let bottom_right = Point { x: 5.2, ..point };

    // `bottom_right.y` 与 `point.y` 一样，因为这个字段就是从 `point` 中来的
    println!("second point: ({}, {})", bottom_right.x, bottom_right.y);

    // 使用 `let` 绑定来解构 point
    let Point { x: left_edge, y: top_edge } = point;

    let _rectangle = Rectangle {
        // 结构体的实例化也是一个表达式
        top_left: Point { x: left_edge, y: top_edge },
        bottom_right: bottom_right,
    };

    // 实例化一个单元结构体
    let _unit = Unit;

    // 实例化一个元组结构体
    let pair = Pair(1, 0.1);

    // 访问元组结构体的字段
    println!("pair contains {:?} and {:?}", pair.0, pair.1);

    // 解构一个元组结构体
    let Pair(integer, decimal) = pair;

    println!("pair contains {:?} and {:?}", integer, decimal);
}
</code></pre> 
<pre><code class="language-rust">// 该属性用于隐藏对未使用代码的警告。
#![allow(dead_code)]

// 创建一个 `enum`（枚举）来对 web 事件分类。注意变量名和类型共同指定了 `enum`
// 取值的种类：`PageLoad` 不等于 `PageUnload`，`KeyPress(char)` 不等于
// `Paste(String)`。各个取值不同，互相独立。
enum WebEvent {
    // 一个 `enum` 可以是单元结构体（称为 `unit-like` 或 `unit`），
    PageLoad,
    PageUnload,
    // 或者一个元组结构体，
    KeyPress(char),
    Paste(String),
    // 或者一个普通的结构体。
    Click { x: i64, y: i64 }
}

// 此函数将一个 `WebEvent` enum 作为参数，无返回值。
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!("page loaded"),
        WebEvent::PageUnload =&gt; println!("page unloaded"),
        // 从 `enum` 里解构出 `c`。
        WebEvent::KeyPress(c) =&gt; println!("pressed '{}'.", c),
        WebEvent::Paste(s) =&gt; println!("pasted \"{}\".", s),
        // 把 `Click` 解构给 `x` and `y`。
        WebEvent::Click { x, y } =&gt; {
            println!("clicked at x={}, y={}.", x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()` 从一个字符串切片中创建一个具有所有权的 `String`。
    let pasted  = WebEvent::Paste("my text".to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}
</code></pre> 
<pre><code class="language-rust">enum EnumTest {
    Add,
    Subtract,
}

impl EnumTest {
    fn run(&amp;self, x: i32, y: i32) -&gt; i32 {
        match self {
            Self::Add =&gt; x + y,
            Self::Subtract =&gt; x - y,
        }
    }
}

fn main() {
    let temp: EnumTest = EnumTest::Add;
    let result = temp.run(10,20);
    println!("{result}");
}
</code></pre> 
<p><code>enum</code> 的一个常见用法就是创建链表（linked-list）：</p> 
<pre><code class="language-rust">use List::*;

enum List {
    // Cons：元组结构体，包含链表的一个元素和一个指向下一节点的指针
    Cons(u32, Box&lt;List&gt;),
    // Nil：末结点，表明链表结束
    Nil,
}

// 可以为 enum 定义方法
impl List {
    // 创建一个空的 List 实例
    fn new() -&gt; List {
        // `Nil` 为 `List` 类型（译注：因 `Nil` 的完整名称是 `List::Nil`）
        Nil
    }

    // 处理一个 List，在其头部插入新元素，并返回该 List
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons` 同样为 List 类型
        Cons(elem, Box::new(self))
    }

    // 返回 List 的长度
    fn len(&amp;self) -&gt; u32 {
        // 必须对 `self` 进行匹配（match），因为这个方法的行为取决于 `self` 的
        // 取值种类。
        // `self` 为 `&amp;List` 类型，`*self` 为 `List` 类型，匹配一个具体的 `T`
        // 类型要好过匹配引用 `&amp;T`。
        match *self {
            // 不能得到 tail 的所有权，因为 `self` 是借用的；
            // 因此使用一个对 tail 的引用
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // （递归的）基准情形（base case）：一个长度为 0 的空列表
            Nil =&gt; 0
        }
    }

    // 返回列表的字符串表示（该字符串是堆分配的）
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!` 和 `print!` 类似，但返回的是一个堆分配的字符串，
                // 而不是打印结果到控制台上
                format!("{}, {}", head, tail.stringify())
            },
            Nil =&gt; {
                format!("Nil")
            },
        }
    }
}

fn main() {
    // 创建一个空链表
    let mut list = List::new();

    // 追加一些元素
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // 显示链表的最后状态
    println!("linked list has length: {}", list.len());
    println!("{}", list.stringify());
}
</code></pre> 
<h4>常量</h4> 
<p>常量（constant）可以通过 const 和 static 关键字来创建。</p> 
<p>Rust 有两种常量，可以在任意作用域声明，包括全局作用域。它们都需要显式的类型声明：</p> 
<ul><li><code>const</code>：不可改变的值（通常使用这种）。</li><li><code>static</code>：具有 <a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/static_lifetime.html" rel="nofollow" title="'static">'static</a> 生命周期的，可以是可变的变量（译注：须使用 <code>static mut</code> 关键字）。</li></ul> 
<p>有个特例就是 <code>"string"</code> 字面量。它可以不经改动就被赋给一个 <code>static</code> 变量，因为它的类型标记：<code>&amp;'static str</code> 就包含了所要求的生命周期 <code>'static</code>。其他的引用类型都必须特地声明，使之拥有 <code>'static</code> 生命周期。这两种引用类型的差异似乎也无关紧要，因为无论如何，<code>static</code> 变量都得显式地声明。</p> 
<pre><code class="language-rust">// 全局变量是在所有其他作用域之外声明的。
static LANGUAGE: &amp;'static str = "Rust";
const  THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // 在一般函数中访问常量
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // 在 main 函数（主函数）中访问常量
    println!("This is {}", LANGUAGE);
    println!("The threshold is {}", THRESHOLD);
    println!("{} is {}", n, if is_big(n) { "big" } else { "small" });

    // 报错！不能修改一个 `const` 常量。
    THRESHOLD = 5;
    // 改正 ^ 注释掉此行
}
</code></pre> 
<p>三个在 Rust 程序中被广泛使用的集合：</p> 
<ul><li><strong><em>vector</em>  </strong>一个挨着一个地储存一系列数量可变的值。为了创建一个新的空 vector，可以调用 Vec::new 函数，会用初始值来创建一个 Vec&lt;T&gt; 而 Rust 会推断出储存值的类型，所以很少会需要这些类型注解。为了方便 Rust 提供了 vec! 宏，这个宏会根据我们提供的值来创建一个新的 vector。</li><li><strong>字符串</strong>（<em>string</em>）是字符的集合。我们之前见过 <code>String</code> 类型，不过在本章我们将深入了解。</li><li><strong>哈希 map</strong>（<em>hash map</em>）允许我们将值与一个特定的键（key）相关联。这是一个叫做 <em>map</em> 的更通用的数据结构的特定实现。</li></ul> 
<p>对于标准库提供的其他类型的集合，请查看<a href="https://doc.rust-lang.org/std/collections/index.html" rel="nofollow" title="文档">文档</a>。</p> 
<p></p> 
<h3>标准库 类型</h3> 
<p>参考：<a href="https://rustwiki.org/zh-CN/rust-by-example/primitives.html" rel="nofollow" title="原生类型">原生类型</a> 和 <a href="https://rustwiki.org/zh-CN/std/" rel="nofollow" title="标准库">标准库</a></p> 
<p>标准库提供了很多自定义类型，在<strong>原生类型</strong>基础上进行了大量扩充。这是部分自定义类型：</p> 
<ul><li>可增长的 <code>String</code>（字符串），如: <code>"hello world"</code></li><li>可增长的向量（vector）: <code>[1, 2, 3]</code></li><li>选项类型（optional types）: <code>Option&lt;i32&gt;</code></li><li>错误处理类型（error handling types）: <code>Result&lt;i32, i32&gt;</code></li><li>堆分配的指针（heap allocated pointers）: <code>Box&lt;i32&gt;</code></li></ul> 
<p></p> 
<h4><strong>字符串（<code>String</code>）</strong></h4> 
<p><strong><span style="background-color:#ffd900;">字符串（</span><code><span style="background-color:#ffd900;">String</span></code><span style="background-color:#ffd900;">）类型由 Rust 标准库提供，而不是编入核心语言。</span></strong></p> 
<p>更多 <code>str</code>/<code>String</code> 方法可以在 <a href="https://rustwiki.org/zh-CN/std/str/" rel="nofollow" title="std::str">std::str</a> 和 <a href="https://rustwiki.org/zh-CN/std/string/" rel="nofollow" title="std::string">std::string</a> 模块中找到。若需要在编码间转换，请使用 <a href="https://crates.io/crates/encoding" rel="nofollow" title="encoding">encoding</a> crate。Rust 参考中的 <a href="https://rustwiki.org/zh-CN/reference/tokens.html" rel="nofollow" title="Tokens">Tokens</a> 一章详细地列出了书写字符串字面量和转义字符的方法。</p> 
<p>Rust 中有两种字符串类型：<code>String</code> 和 <code>&amp;str</code>。</p> 
<ul><li><code>&amp;str</code>：表示 "<strong>字符串字面值</strong>"，使用双引号括起来，例如："Hello, World!"。这是一种字符串类型的常量表示方法。字符串字面值是静态不可变的，不能修改其中的内容。你可以直接使用字符串字面值进行一些简单的操作，如拼接、切割等，但无法修改它们的值。<strong><span style="background-color:#fe2c24;">字符串字面值就是 String 的 slice str，通常以被借用的形式出现，</span><code><span style="background-color:#fe2c24;">&amp;str</span></code><span style="background-color:#fe2c24;">。</span></strong></li><li><code>String</code>：表示 String 类型，是动态可变的字符串。<code>String</code> 被存储为由字节组成的 vector（<code>Vec&lt;u8&gt;</code>），但保证了它一定是一个有效的 UTF-8 序列。<code>String</code> 是堆分配的，可增长的，且不是零结尾的（null terminated）。</li></ul> 
<pre><code class="language-rust">fn main() {
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // 注意 s1 被移动了，不能继续使用

    println!("s2 ---&gt; {s2}");
    println!("s3 ---&gt; {s3}");

    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");
    // 宏 format! 生成的代码使用引用所以不会获取任何参数的所有权。
    let s = format!("{s1}-{s2}-{s3}"); 

索引字符串
    println!("s ---&gt; {s}");
    println!("s1 ---&gt; {s1}");
    println!("s2 ---&gt; {s2}");
    println!("s3 ---&gt; {s3}");
}
</code></pre> 
<p>示例：</p> 
<pre><code class="language-rust">fn main() {
    // （所有的类型标注都不是必需的）
    // 一个对只读内存中分配的字符串的引用
    let pangram: &amp;'static str = "the quick brown fox jumps over the lazy dog";
    println!("Pangram: {}", pangram);

    // 逆序迭代单词，这里并没有分配新的字符串
    println!("Words in reverse");
    for word in pangram.split_whitespace().rev() {
        println!("&gt; {}", word);
    }

    // 复制字符到一个 vector，排序并移除重复值
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // 创建一个空的且可增长的 `String`
    let mut string = String::new();
    for c in chars {
        // 在字符串的尾部插入一个字符
        string.push(c);
        // 在字符串尾部插入一个字符串
        string.push_str(", ");
    }

    // 这个缩短的字符串是原字符串的一个切片，所以没有执行新的分配操作
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!("Used characters: {}", trimmed_str);

    // 堆分配一个字符串
    let alice = String::from("I like dogs");
    // 分配新内存并存储修改过的字符串
    let bob: String = alice.replace("dog", "cat");

    println!("Alice says: {}", alice);
    println!("Bob says: {}", bob);
}
</code></pre> 
<p>slice 数据结构仅仅储存了开始位置和 slice 的长度。所以虽然 <code>&amp;T</code> 是一个储存了 <code>T</code> 所在的内存位置的单个值，<code>&amp;str</code> 则是 <strong>两个</strong> 值：<code>str</code> 的地址和其长度。</p> 
<p>字面量中出现的字符串或字符定界符必须转义："\""、'\''。<br> 也可以使用原始字符串(raw string): r"Escapes don't work here: \x3F \u{211D}"</p> 
<p></p> 
<h4>大小可变的数组 vec</h4> 
<p>vector 是大小可变的数组。和 slice（切片）类似，它们的大小在编译时是未知的，但它们可以随时扩大或缩小。一个 vector 使用 3 个词来表示：一个指向数据的指针，vector 的长度，还有它的容量。此容量指明了要为这个 vector 保留多少内存。vector 的长度只要小于该容量，就可以随意增长；当需要超过这个阈值时，会给 vector 重新分配一段更大的容量。</p> 
<p>更多 <code>Vec</code> 方法可以在 <a href="https://rustwiki.org/zh-CN/std/vec/" rel="nofollow" title="std::vec">std::vec</a> 模块中找到。</p> 
<pre><code class="language-rust">fn main() {

    let mut v = Vec::new();
    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
    println!("{:?}", v);

    let v = vec![1, 2, 3, 4, 5];
    let third: &amp;i32 = &amp;v[2];
    println!("The third element is {third}");

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!("The third element is {third}"),
        None =&gt; println!("There is no third element."),
    }
}</code></pre> 
<pre><code class="language-rust">fn main() {
    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        // 为了修改可变引用所指向的值，在使用 += 运算符之前
        // 必须使用解引用运算符（*）获取 i 中的值。
        *i += 100;
    }
    for i in &amp;v{
        println!("{i}")
    }
}
</code></pre> 
<p>示例：</p> 
<pre><code class="language-rust">fn main() {

    let mut v = Vec::new();
    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
    println!("{:?}", v);

    let v = vec![1, 2, 3, 4, 5];
    let third: &amp;i32 = &amp;v[2];
    println!("The third element is {third}");

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!("The third element is {third}"),
        None =&gt; println!("There is no third element."),
    }

    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 100;
    }
    for i in &amp;v{
        println!("{i}")
    }

    #[derive(Debug)]
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    // 使用枚举来存储多个类型，类比 Python 的 list
    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];

    for cell in &amp;row {
        match cell {
            SpreadsheetCell::Int(value) =&gt; println!("整数值: {}", value),
            SpreadsheetCell::Text(value) =&gt; println!("文本值: {}", value),
            SpreadsheetCell::Float(value) =&gt; println!("浮点数值: {}", value),
        }
    }
}</code></pre> 
<pre><code class="language-rust">fn main() {
    // 迭代器可以被收集到 vector 中
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!("Collected (0..10) into: {:?}", collected_iterator);

    // `vec!` 宏可用来初始化一个 vector
    let mut xs = vec![1i32, 2, 3];
    println!("Initial vector: {:?}", xs);

    // 在 vector 的尾部插入一个新的元素
    println!("Push 4 into the vector");
    xs.push(4);
    println!("Vector: {:?}", xs);

    // 报错！不可变 vector 不可增长
    // collected_iterator.push(0);
    // 改正 ^ 将此行注释掉

    // `len` 方法获得一个 vector 的当前大小
    println!("Vector size: {}", xs.len());

    // 下标使用中括号表示（从 0 开始）
    println!("Second element: {}", xs[1]);

    // `pop` 移除 vector 的最后一个元素并将它返回
    println!("Pop last element: {:?}", xs.pop());

    // 超出下标范围将抛出一个 panic
    println!("Fourth element: {}", xs[3]);
    // 改正 ^ 注释掉此行

    // 迭代一个 `Vector` 很容易
    println!("Contents of xs:");
    for x in xs.iter() {
        println!("&gt; {}", x);
    }

    // 可以在迭代 `Vector` 的同时，使用独立变量（`i`）来记录迭代次数
    for (i, x) in xs.iter().enumerate() {
        println!("In position {} we have value {}", i, x);
    }

    // 多亏了 `iter_mut`，可变的 `Vector` 在迭代的同时，其中每个值都能被修改
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!("Updated vector: {:?}", xs);
}
</code></pre> 
<p>Rust 在编译时就必须准确的知道 vector 中类型的原因在于它需要知道储存每个元素到底需要多少内存。第二个好处是可以准确的知道这个 vector 中允许什么类型。如果 Rust 允许 vector 存放任意类型，那么当对 vector 元素执行操作时一个或多个类型的值就有可能会造成错误。使用枚举外加 <code>match</code> 意味着 Rust 能在编译时就保证总是会处理所有可能的情况，</p> 
<p>如果在编写程序时不能确切无遗地知道运行时会储存进 vector 的所有类型，枚举技术就行不通了。相反，你可以使用 trait 对象，</p> 
<p></p> 
<h4><strong>散列表 HashMap：</strong>HashMap&lt;K, V&gt;</h4> 
<p>vector 通过整型下标来存储值，而 <code>HashMap</code>（散列表）通过键（key）来存储值。<code>HashMap</code> 的键可以是布尔型、整型、字符串，或任意实现了 <code>Eq</code> 和 <code>Hash</code> trait 的其他类型。<code>HashMap&lt;K, V&gt;</code> 类型储存了一个键类型 <code>K</code> 对应一个值类型 <code>V</code> 的映射。它通过一个 <strong>哈希函数</strong>（<em>hashing function</em>）来实现映射，决定如何将键和值放入内存中。很多编程语言支持这种数据结构，不过通常有不同的名字：哈希、map、对象、哈希表、关联数组、Python的字典(Dict) 等。</p> 
<p>和 vector 类似，<code>HashMap</code> 也是可增长的，但 HashMap 在占据了多余空间时还可以缩小自己。可以使用 <code>HashMap::with_capacity(unit)</code> 创建具有一定初始容量的 HashMap，也可以使用 <code>HashMap::new()</code> 来获得一个带有默认初始容量的 HashMap（推荐方式）。</p> 
<pre><code class="language-rust">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        "798-1364" =&gt; "We're sorry, the call cannot be completed as dialed. 
            Please hang up and try again.",
        "645-7689" =&gt; "Hello, this is Mr. Awesome's Pizza. My name is Fred.
            What can I get for you today?",
        _ =&gt; "Hi! Who is this again?"
    }
}

fn main() {
    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
    
    let mut contacts = HashMap::new();
    contacts.insert("Daniel", "798-1364");
    contacts.insert("Ashley", "645-7689");
    contacts.insert("Katie", "435-8291");
    contacts.insert("Robert", "956-1745");
    // 接受一个引用并返回 Option&lt;&amp;V&gt;
    match contacts.get(&amp;"Daniel") {
        Some(&amp;number) =&gt; println!("Calling Daniel: {}", call(number)),
        _ =&gt; println!("Don't have Daniel's number."),
    }
    // 如果被插入的值为新内容，那么 `HashMap::insert()` 返回 `None`，
    // 否则返回 `Some(value)`
    contacts.insert("Daniel", "164-6743");
    match contacts.get(&amp;"Ashley") {
        Some(&amp;number) =&gt; println!("Calling Ashley: {}", call(number)),
        _ =&gt; println!("Don't have Ashley's number."),
    }
    contacts.remove(&amp;("Ashley"));
    // `HashMap::iter()` 返回一个迭代器，该迭代器以任意顺序举出
    // (&amp;'a key, &amp;'a value) 对。
    for (contact, &amp;number) in contacts.iter() {
        println!("Calling {}: {}", contact, call(number));
    }
}
</code></pre> 
<p>必须首先 <code>use</code> 标准库中集合部分的 <code>HashMap</code>。在这三个常用集合中，<code>HashMap</code> 是最不常用的，所以并没有被 prelude 自动引用。标准库中对 <code>HashMap</code> 的支持也相对较少，例如，并没有内建的构建宏。<span style="color:#0d0016;"><strong>类似于 vector，哈希 map 是同质的</strong></span><span style="color:#fe2c24;"><strong>：所有的键必须是相同类型，值也必须都是相同类型。</strong></span></p> 
<p></p> 
<h4>定义 key 类型</h4> 
<p>任何实现了 <code>Eq</code> 和 <code>Hash</code> trait 的类型都可以充当 <code>HashMap</code> 的键。这包括：</p> 
<ul><li><code>bool</code> （当然这个用处不大，因为只有两个可能的键）</li><li><code>int</code>，<code>unit</code>，以及其他整数类型</li><li><code>String</code> 和 <code>&amp;str</code>（友情提示：如果使用 <code>String</code> 作为键来创建 <code>HashMap</code>，则可以 将 <code>&amp;str</code> 作为散列表的 <code>.get()</code> 方法的参数，以获取值）</li></ul> 
<p>注意到 <code>f32</code> 和 <code>f64</code> <strong>没有</strong>实现 <code>Hash</code>，这很大程度上是由于若使用浮点数作为散列表的键，<a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems" rel="nofollow" title="浮点精度误差">浮点精度误差</a>会很容易导致错误。</p> 
<p>对于所有的集合类（collection class），如果它们包含的类型都分别实现了 <code>Eq</code> 和 <code>Hash</code>，那么这些集合类也就实现了 <code>Eq</code> 和 <code>Hash</code>。例如，若 <code>T</code> 实现了 <code>Hash</code>，则 <code>Vec&lt;T&gt;</code> 也实现了 <code>Hash</code>。</p> 
<p>对自定义类型可以轻松地实现 <code>Eq</code> 和 <code>Hash</code>，只需加上一行代码：<code>#[derive(PartialEq, Eq, Hash)]</code>。</p> 
<p>编译器将会完成余下的工作。如果你想控制更多的细节，你可以手动实现 <code>Eq</code> 和/或 <code>Hash</code>。</p> 
<pre><code class="language-rust">use std::collections::HashMap;

// Eq 要求你对此类型推导 PartiaEq。
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
                 username: &amp;'a str, password: &amp;'a str){
    println!("Username: {}", username);
    println!("Password: {}", password);
    println!("Attempting logon...");

    let logon = Account {
        username: username,
        password: password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!("Successful logon!");
            println!("Name: {}", account_info.name);
            println!("Email: {}", account_info.email);
        },
        _ =&gt; println!("Login failed!"),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: "j.everyman",
        password: "password123",
    };

    let account_info = AccountInfo {
        name: "John Everyman",
        email: "j.everyman@email.com",
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, "j.everyman", "psasword123");

    try_logon(&amp;accounts, "j.everyman", "password123");
}
</code></pre> 
<p></p> 
<h4>散列集 HashSet</h4> 
<p>（<code>HashSet&lt;T&gt;</code> 实际上只是对 <code>HashMap&lt;T, ()&gt;</code> 的封装）。不会出现重复的 值。 如果插入的值已经存在于 <code>HashSet</code> 中（也就是，新值等于已存在的值，并且拥有相同的散列值），那么新值将会替换旧的值。集合（set）可以做更多的事。</p> 
<p>集合（set）拥有 4 种基本操作（下面的调用全部都返回一个迭代器）：</p> 
<ul><li> <p><code>union</code>（并集）：获得两个集合中的所有元素（不含重复值）。</p> </li><li> <p><code>difference</code>（差集）：获取属于第一个集合而不属于第二集合的所有元素。</p> </li><li> <p><code>intersection</code>（交集）：获取同时属于两个集合的所有元素。</p> </li><li> <p><code>symmetric_difference</code>（对称差）：获取所有只属于其中一个集合，而不同时属于 两个集合的所有元素。</p> </li></ul> 
<pre><code class="language-rust">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec!(1i32, 2, 3).into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec!(2i32, 3, 4).into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // 如果值已经存在，那么 `HashSet::insert()` 返回 false。
    assert!(b.insert(4), "Value 4 is already in set B!");
    // 改正 ^ 将此行注释掉。

    b.insert(5);

    // 若一个集合（collection）的元素类型实现了 `Debug`，那么该集合也就实现了 `Debug`。
    // 这通常将元素打印成这样的格式 `[elem1, elem2, ...]
    println!("A: {:?}", a);
    println!("B: {:?}", b);

    // 乱序打印 [1, 2, 3, 4, 5]。
    println!("Union: {:?}", a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 这将会打印出 [1]
    println!("Difference: {:?}", a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 乱序打印 [2, 3, 4]。
    println!("Intersection: {:?}", a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 打印 [1, 5]
    println!("Symmetric Difference: {:?}",
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}
</code></pre> 
<p></p> 
<h3>类型转换</h3> 
<h4>类型转换：from、into</h4> 
<p>Rust 使用 <a href="https://rustwiki.org/zh-CN/rust-by-example/trait.html" rel="nofollow" title="trait">trait</a> 解决类型之间的转换问题。最一般的转换会用到 <a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html" rel="nofollow" title="From">From</a> 和 <a href="https://rustwiki.org/zh-CN/std/convert/trait.Into.html" rel="nofollow" title="Into">Into</a> 两个 trait。不过，即便常见的情况也可能会用到特别的 trait，尤其是从 <code>String</code> 转换到别的类型，以及把别的类型转换到 <code>String</code> 时。</p> 
<p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html" rel="nofollow" title="From">From</a> 和 <a href="https://rustwiki.org/zh-CN/std/convert/trait.Into.html" rel="nofollow" title="Into">Into</a> 两个 trait 是内部相关联的。如果我们能够从类型 B 得到类型 A，那么很容易相信我们也能够把类型 B 转换为类型 A。</p> 
<p>From trait 允许一种类型定义 “怎么根据另一种类型生成自己”，因此它提供了一种类型转换的简单机制。在标准库中有无数 From 的实现，规定原生类型及其他常见类型的转换功能。<br> 比如，可以很容易地把 str 转换成 String：</p> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
    let my_str = "hello";
    let my_string = String::from(my_str);
}
</code></pre> 
<p>也可以为我们自己的类型定义转换机制：</p> 
<pre><code class="language-rust">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!("My number is {:?}", num);
}
</code></pre> 
<p>Into trait 就是把 From trait 倒过来而已。 就是根据自己类型怎么生成其他类型。使用 <code>Into</code> trait 通常要求指明要转换到的类型，因为编译器大多数时候不能推断它。</p> 
<pre><code class="language-rust">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // 试试删除类型说明
    let num: Number = int.into();
    println!("My number is {:?}", num);
}
</code></pre> 
<h4>类型转换：TryFrom、TryInto</h4> 
<p><code>TryFrom</code> 和 <code>TryInto</code> trait 用于易出错的转换，也正因如此，其返回值是 <a href="https://rustwiki.org/zh-CN/std/result/enum.Result.html" rel="nofollow" title="Result">Result</a> 型。</p> 
<pre><code class="language-rust">use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom&lt;i32&gt; for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();
    assert_eq!(result, Err(()));
}
</code></pre> 
<h4>类型转换：ToString、FromStr</h4> 
<p>要把任何类型转换成 <code>String</code>，只需要实现那个类型的 <a href="https://rustwiki.org/zh-CN/std/string/trait.ToString.html" rel="nofollow" title="ToString">ToString</a> trait。如果不实现，也可以实现 <a href="https://rustwiki.org/zh-CN/std/fmt/trait.Display.html" rel="nofollow" title="fmt::Display">fmt::Display</a> trait，它会自动提供 <a href="https://rustwiki.org/zh-CN/std/string/trait.ToString.html" rel="nofollow" title="ToString">ToString</a>，并且还可以用来打印类型，就像 <a href="https://rustwiki.org/zh-CN/rust-by-example/hello/print.html" rel="nofollow" title="print!">print!</a> 一节中讨论的那样。</p> 
<pre><code class="language-rust">use std::fmt;

struct Circle {
    radius: i32
}

impl fmt::Display for Circle {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "Circle of radius {}", self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!("{}", circle.to_string());
}
</code></pre> 
<pre><code class="language-rust">use std::string::ToString;

struct Circle {
    radius: i32
}

impl ToString for Circle {
    fn to_string(&amp;self) -&gt; String {
        format!("Circle of radius {:?}", self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!("{}", circle.to_string());
}
</code></pre> 
<p>解析字符串。经常需要把字符串转成数字。完成这项工作的标准手段是用 parse 函数。我们得提供要转换到的类型，这可以通过不使用类型推断，或者用 “涡轮鱼” 语法（turbo fish，&lt;&gt;）实现。</p> 
<pre><code class="language-rust">fn main() {
    let parsed: i32 = "5".parse().unwrap();
    let turbo_parsed = "10".parse::&lt;i32&gt;().unwrap();

    let sum = parsed + turbo_parsed;
    println!{"Sum: {:?}", sum};
}
</code></pre> 
<p></p> 
<h3>Rust 的 所有权</h3> 
<ul><li>所有权：<a class="link-info" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html" rel="nofollow" title="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html">https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html</a></li><li>所有权、移动、借用、生命周期：<a class="link-info" href="https://rustwiki.org/zh-CN/rust-by-example/scope/move.html" rel="nofollow" title="https://rustwiki.org/zh-CN/rust-by-example/scope/move.html">https://rustwiki.org/zh-CN/rust-by-example/scope/move.html</a></li></ul> 
<p>所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全，因此理解 Rust 中所有权如何工作是十分重要的。</p> 
<h4>RAII (资源获取即初始化)</h4> 
<p>Rust 强制实行 RAII（Resource Acquisition Is Initialization，资源获取即初始化），所以任何对象在离开作用域时，它的析构函数（destructor）就被调用，然后它占有的资源就被释放。这种行为避免了<strong>资源泄漏</strong>（resource leak），所以不用手动释放内存或担心内存泄漏（memory leak）！</p> 
<p>快速入门示例：</p> 
<pre><code class="language-rust">// raii.rs
fn create_box() {
    // 在堆上分配一个整型数据
    let _box1 = Box::new(3i32);

    // `_box1` 在这里被销毁，内存得到释放
}

fn main() {
    // 在堆上分配一个整型数据
    let _box2 = Box::new(5i32);

    // 嵌套作用域：
    {
        // 在堆上分配一个整型数据
        let _box3 = Box::new(4i32);

        // `_box3` 在这里被销毁，内存得到释放
    }

    // 创建一大堆 box（只是因为好玩）。
    // 完全不需要手动释放内存！
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2` 在这里被销毁，内存得到释放
}
</code></pre> 
<h4>析构函数</h4> 
<p>Rust 中的析构函数概念是通过 <a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html" rel="nofollow" title="Drop">Drop</a> trait 提供的。当资源离开作用域，就调用析构函数。你无需为每种类型都实现 <a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html" rel="nofollow" title="Drop">Drop</a> trait，只要为那些需要自己的析构函数逻辑的类型实现就可以了。</p> 
<p>示例：当 <code>main</code> 函数中的变量离开作用域，自定义的析构函数就会被调用：</p> 
<pre><code class="language-rust">struct ToDrop;

impl Drop for ToDrop {
    fn drop(&amp;mut self) {
        println!("ToDrop is being dropped");
    }
}

fn main() {
    let x = ToDrop;
    println!("Made a ToDrop!");
}
</code></pre> 
<h4>所有权(ownership)  的  规则</h4> 
<p>因为变量要负责释放它们拥有的资源，所以<strong>资源只能拥有一个所有者</strong>。这也防止了资源的重复释放。注意并非所有变量都拥有资源（例如<a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/destructuring/destructure_pointers.html" rel="nofollow" title="引用">引用</a>）。</p> 
<ol><li>Rust 中定义一个变量就是开辟一块内存资源，每个变量都有一个 <strong>所有者</strong>（<em>owner</em>）。</li><li>变量 在任一时刻有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个 "变量所持有的资源"  将被 丢弃(释放内存空间)。</li><li> <p>在进行 <strong><span style="background-color:#fe2c24;">赋值(let x = y)</span></strong> 或 <strong><span style="background-color:#fe2c24;">通过值来传递函数参数(foo(x))</span></strong> 的时候，资源的 <strong>所有权</strong>（ownership）会发生转移。按照 Rust 的说法，这被称为资源的<strong>移动</strong>（move）。在移动资源之后，原来的所有者不能再被使用，这可避免悬挂指针（dangling pointer）的产生。</p> </li></ol> 
<pre><code class="language-rust">// 此函数取得堆分配的内存的所有权
fn destroy_box(c: Box&lt;i32&gt;) {
    println!("Destroying a box that contains {}", c);

    // `c` 被销毁且内存得到释放
}

fn main() {
    // 栈分配的整型
    let x = 5u32;

    // 将 `x` *复制*到 `y`——不存在资源移动
    let y = x;

    // 两个值各自都可以使用
    println!("x is {}, and y is {}", x, y);

    // `a` 是一个指向堆分配的整数的指针
    let a = Box::new(5i32);

    println!("a contains: {}", a);

    // *移动* `a` 到 `b`
    let b = a;
    // 把 `a` 的指针地址（而非数据）复制到 `b`。现在两者都指向
    // 同一个堆分配的数据，但是现在是 `b` 拥有它。

    // 报错！`a` 不能访问数据，因为它不再拥有那部分堆上的内存。
    //println!("a contains: {}", a);
    // 试一试 ^ 去掉此行注释

    // 此函数从 `b` 中取得堆分配的内存的所有权
    destroy_box(b);

    // 此时堆内存已经被释放，这个操作会导致解引用已释放的内存，而这是编译器禁止的。
    // 报错！和前面出错的原因一样。
    //println!("b contains: {}", b);
    // 试一试 ^ 去掉此行注释
}
</code></pre> 
<p>当所有权转移时，数据的可变性可能发生改变。</p> 
<pre><code class="language-rust">fn main() {
    let immutable_box = Box::new(5u32);

    println!("immutable_box contains {}", immutable_box);

    // 可变性错误
    //*immutable_box = 4;

    // *移动* box，改变所有权（和可变性）
    let mut mutable_box = immutable_box;

    println!("mutable_box contains {}", mutable_box);

    // 修改 box 的内容
    *mutable_box = 4;

    println!("mutable_box now contains {}", mutable_box);
}
</code></pre> 
<p>在单个变量的<a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/destructuring.html" rel="nofollow" title="解构">解构</a>内，可以同时使用 <code>by-move</code> 和 <code>by-reference</code> 模式绑定。这样做将导致变量的<strong>部分移动</strong>（partial move），这意味着变量的某些部分将被移动，而其他部分将保留。在这种情况下，后面不能整体使用父级变量，但是仍然可以使用只引用（而不移动）的部分。</p> 
<pre><code class="language-rust">fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: u8,
    }

    let person = Person {
        name: String::from("Alice"),
        age: 20,
    };

    // `name` 从 person 中移走，但 `age` 只是引用
    let Person { name, ref age } = person;

    println!("The person's age is {}", age);

    println!("The person's name is {}", name);

    // 报错！部分移动值的借用：`person` 部分借用产生
    //println!("The person struct is {:?}", person);

    // `person` 不能使用，但 `person.age` 因为没有被移动而可以继续使用
    println!("The person's age from person struct is {}", person.age);
}
</code></pre> 
<p>参考：<a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/destructuring.html" rel="nofollow" title="解构">解构</a></p> 
<p></p> 
<h4>变量、作用域</h4> 
<p>作用域在所有权（ownership）、借用（borrow）和生命周期（lifetime）中起着重要作用。作用域告诉编译器什么时候借用是合法的、什么时候资源可以释放、以及变量何时被创建或销毁。</p> 
<p>变量是否有效与作用域的关系跟其他编程语言是类似的。</p> 
<blockquote> 
 <p>fn main() {<!-- --><br>     {                      // s 在这里无效，它尚未声明<br>         let s = "hello";   // 从此处起，s 是有效的<br>         // 使用 s<br>     }                      // 此作用域已结束，s 不再有效，清理并drop(释放掉)内存空间<br> }</p> 
 <p>这里有两个重要的时间点：</p> 
 <ul><li>当 <code>s</code> <strong>进入作用域</strong> 时，它就是有效的。</li><li>这一直持续到它 <strong>离开作用域</strong> 为止。</li></ul> 
</blockquote> 
<h4>移动 (浅拷贝)、克隆 (深拷贝)</h4> 
<ul><li><strong>浅拷贝</strong>（<em>shallow copy</em>）和 <strong>深拷贝</strong>（<em>deep copy</em>）<br><strong><span style="background-color:#ffd900;">浅拷贝：</span></strong>拷贝指针、长度和容量，而不拷贝指针所指向内存空间的数据。<br><strong><span style="background-color:#ffd900;">深拷贝：</span></strong>拷贝指针、长度和容量，同时也拷贝指针所指向内存空间的数据。</li></ul> 
<blockquote> 
 <p>fn main() {<!-- --><br>     let s1 = String::from("hello");<br>     let s2 = s1;          // 在 C++ 中，这里会发生浅拷贝，<span style="background-color:#ffd900;">不过在 Rust 中会使第一个变量无效，这个操作被称为 </span><strong><span style="background-color:#ffd900;">移动</span></strong><span style="background-color:#ffd900;">（</span><em><span style="background-color:#ffd900;">move</span></em><span style="background-color:#ffd900;">），而不是叫做浅拷贝。</span>为了确保内存安全，在 <code>let s2 = s1;</code> 之后，Rust 认为 <code>s1</code> 不再有效，因此 Rust 不需要在 <code>s1</code> 离开作用域后清理任何东西。</p> 
 <p>    println!("{}, world!", s1);    // 看看在 <code>s2</code> 被创建之后尝试使用 <code>s1</code> 会发生什么，这里会报错，                                             // 因为只有 <code>s2</code> 是有效的，当其离开作用域，它就释放自己的内存<br> }</p> 
 <p>这里隐含了 Rust 的一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。</p> 
</blockquote> 
<p>变量的 "移动(转移)"</p> 
<p>只要进行 "<span style="color:#fe2c24;"><strong>赋值(=)、函数传参</strong></span>" <strong>都会有 <span style="color:#fe2c24;">移动</span></strong></p> 
<blockquote> 
 <ul><li>移动 ( 转移 )：变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。</li></ul> 
</blockquote> 
<p>变量的 克隆</p> 
<blockquote> 
 <p><strong>确实</strong> 需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的通用函数。</p> 
 <p>fn main() {<!-- --><br>     let s1 = String::from("hello");<br>     let s2 = s1.clone();</p> 
 <p>    println!("s1 = {}, s2 = {}", s1, s2);<br> }</p> 
</blockquote> 
<p>只在栈上的数据：拷贝</p> 
<blockquote> 
 <p>fn main() {<!-- --><br>     let x = 5;<br>     let y = x;</p> 
 <p>    println!("x = {}, y = {}", x, y);<br> }</p> 
 <p>一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。如下是一些 Copy 的类型：</p> 
 <ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li></ul> 
</blockquote> 
<h4>所有权与函数</h4> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样。</span></strong></p> 
 <p>fn main() {<!-- --><br>     let s = String::from("hello");  // s 进入作用域</p> 
 <p>    takes_ownership(s);             // s 的值移动到函数里 ...<br>                                     // ... 所以到这里不再有效</p> 
 <p>    let x = 5;                      // x 进入作用域</p> 
 <p>    makes_copy(x);                  // x 应该移动函数里，<br>                                     // 但 i32 是 Copy 的，<br>                                     // 所以在后面可继续使用 x</p> 
 <p>} // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，<br>   // 没有特殊之处</p> 
 <p>fn takes_ownership(some_string: String) { // some_string 进入作用域<br>     println!("{}", some_string);<br> } // 这里，some_string 移出作用域并调用 `drop` 方法。<br>   // 占用的内存被释放</p> 
 <p>fn makes_copy(some_integer: i32) { // some_integer 进入作用域<br>     println!("{}", some_integer);<br> } // 这里，some_integer 移出作用域。没有特殊之处<br>  </p> 
</blockquote> 
<h4>返回值与作用域</h4> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">返回值也可以转移所有权。</span></strong></p> 
 <p>fn main() {<!-- --><br>     let s1 = gives_ownership();         // gives_ownership 将返回值<br>                                         // 转移给 s1</p> 
 <p>    let s2 = String::from("hello");     // s2 进入作用域</p> 
 <p>    let s3 = takes_and_gives_back(s2);  // s2 被移动到<br>                                         // takes_and_gives_back 中，<br>                                         // 它也将返回值移给 s3<br> } // 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，<br>   // 所以什么也不会发生。s1 离开作用域并被丢弃</p> 
 <p>fn gives_ownership() -&gt; String {             // gives_ownership 会将<br>                                              // 返回值移动给<br>                                              // 调用它的函数</p> 
 <p>    let some_string = String::from("yours"); // some_string 进入作用域。</p> 
 <p>    some_string                              // 返回 some_string <br>                                              // 并移出给调用的函数<br>                                              // <br> }</p> 
 <p>// takes_and_gives_back 将传入字符串并返回该值<br> fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 进入作用域<br>                                                       // </p> 
 <p>    a_string  // 返回 a_string 并移出给调用的函数<br> }</p> 
</blockquote> 
<h4>借用 (引用)</h4> 
<blockquote> 
 <p>"<strong><span style="background-color:#fe2c24;">借用 (引用)</span></strong>" 其实就相当于一个 "<strong><span style="background-color:#fe2c24;">别名、外号</span></strong>"</p> 
</blockquote> 
<p>Rust <strong>借用</strong>（borrowing）：<strong><span style="background-color:#ffd900;">只访问数据，但同时不获取其所有权</span></strong>。也就是 <strong><span style="background-color:#ffd900;">对象通过引用（</span><code><span style="background-color:#ffd900;">&amp;T</span></code><span style="background-color:#ffd900;">）来传递，而不是通过值（</span><code><span style="background-color:#ffd900;">T</span></code><span style="background-color:#ffd900;">）来传递</span></strong>。编译器（通过借用检查）静态地保证了引用<strong>总是</strong>指向有效的对象。即当存在引用指向一个对象时，该对象不能被销毁。</p> 
<p>理解 Rust 的 引用与借用：<a class="link-info" href="https://www.jianshu.com/p/ac519d8c5ec9" rel="nofollow" title="https://www.jianshu.com/p/ac519d8c5ec9">https://www.jianshu.com/p/ac519d8c5ec9</a></p> 
<ul><li>在任意给定时间，<strong>要么</strong> 只能有一个可变借用 (引用)，<strong>要么</strong> 只能有多个不可变借用 (引用)。<strong>同时出现时  " 可变</strong>借用 (引用)<strong>、不可变</strong>借用 (引用)<strong> 作用域 不能重叠"</strong></li><li><strong><span style="background-color:#ffd900;">借用 (引用) 不传递所有权</span></strong>。&amp; 符号就是 <strong>引用</strong>，它允许你使用值，但不获取其所有权。<span style="color:#fe2c24;"><strong>因为没有所有权，所以在离开作用域时，不会进行清理释放内存。</strong></span></li><li>借用 (引用) 与 指针 不同，引用必须确保指向某个特定类型的值有效。即 <strong><span style="background-color:#ffd900;">借用 (引用) 必须总是有效的</span></strong>。引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。</li></ul> 
<blockquote> 
 <p>fn main() {<!-- --><br>     let s1 = String::from("hello");</p> 
 <p>    let len = calculate_length(&amp;s1);</p> 
 <p>    println!("The length of '{}' is {}.", s1, len);<br> }</p> 
 <p>fn calculate_length(s: &amp;String) -&gt; usize { // s 是 String 的引用<br>     s.len()<br> } // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，<br>   // 所以什么也不会发生</p> 
 <p>变量 <code>s</code> 有效的作用域与函数参数的作用域一样，不过当 <code>s</code> 停止使用时并不丢弃引用指向的数据，因为 <code>s</code> 并没有所有权。当函数使用引用而不是实际值作为参数，无需返回值来交还所有权，因为就不曾拥有所有权。</p> 
 <ul><li>总结：将创建一个引用的行为称为 <strong>借用</strong>（<em>borrowing</em>）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完毕，必须还回去。因为并不拥有它。</li></ul> 
 <p>正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。</p> 
 <p>如果想要修改引用的值，就需要用到 <strong>可变引用</strong>（<em>mutable reference</em>）。可变引用有一个很大的限制：如果创建了一个变量的可变引用，就不能再创建对该变量的引用。不可变引用的值本身就不希望被改变，一个变量可以有多个不可变引用。</p> 
 <p></p> 
 <p>fn main() {<!-- --><br>     let mut s = String::from("hello");</p> 
 <p>    let r1 = &amp;mut s;<br>     let r2 = &amp;mut s;</p> 
 <p>    println!("{}, {}", r1, r2);<br> }<br> 这个报错说这段代码是无效的，因为我们不能在同一时间多次将 <code>s</code> 作为可变变量借用。第一个可变的借入在 <code>r1</code> 中，并且必须持续到在 <code>println！</code> 中使用它，但是在那个可变引用的创建和它的使用之间，我们又尝试在 <code>r2</code> 中创建另一个可变引用，该引用借用与 <code>r1</code> 相同的数据。</p> 
 <p>这一限制以一种非常小心谨慎的方式允许可变性，防止同一时间对同一数据存在多个可变引用。新 Rustacean 们经常难以适应这一点，因为大部分语言中变量任何时候都是可变的。这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p> 
 <ul><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ul> 
 <p>数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！</p> 
 <p>可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 <strong>同时</strong> 拥有：</p> 
 <p>fn main() {<!-- --><br>     let mut s = String::from("hello");</p> 
 <p>    {<!-- --><br>         let r1 = &amp;mut s;<br>     } // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</p> 
 <p>    let r2 = &amp;mut s;<br> }<br> Rust 在同时使用可变与不可变引用时也采用的类似的规则。这些代码会导致一个错误：</p> 
 <p>fn main() {<!-- --><br>     let mut s = String::from("hello");</p> 
 <p>    let r1 = &amp;s; // 没问题<br>     let r2 = &amp;s; // 没问题<br>     let r3 = &amp;mut s; // 大问题</p> 
 <p>    println!("{}, {}, and {}", r1, r2, r3);   <br> }   // r1、r2、r3 作用域都是到这里结束，但是上面打印时，r1、r2 生效时 r3 也生效，所以报错。因为 rust 会自动判断 <strong><span style="background-color:#ffd900;">变量引用的作用域是否重叠</span></strong>，所以可以调整 println 的顺序即可。</p> 
 <p>fn main() {<!-- --><br>     let mut s = String::from("hello");</p> 
 <p>    let r1 = &amp;s; // 没问题<br>     let r2 = &amp;s; // 没问题</p> 
 <p>    println!("{}, {}", r1, r2);<br>     let r3 = &amp;mut s; // 大问题<br>     println!("{}", r3);<br> }</p> 
 <p>不可变引用 <code>r1</code> 和 <code>r2</code> 的作用域在 <code>println!</code> 最后一次使用之后结束，这也是创建可变引用 <code>r3</code> 的地方。它们的作用域没有重叠，所以代码是可以编译的。编译器可以在作用域结束之前判断不再使用的引用。记住这是 Rust 编译器在提前指出一个潜在的 bug 的规定。</p> 
</blockquote> 
<ul><li><strong>可变引用(</strong>mutable reference<strong>)</strong>：用 <strong><span style="background-color:#ffd900;">&amp;mut T</span></strong> 对数据进行可变借用，使借用者可以 读/写 数据。</li><li>不可变引用(immutable reference)：用 <code>&amp;T</code> 对数据进行借用，借用者只能读数据，而不能修改</li></ul> 
<pre><code class="language-rust">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str` 是一个对分配在只读内存区的字符串的引用
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// 此函数接受一个对 Book 类型的引用
fn borrow_book(book: &amp;Book) {
    println!("I immutably borrowed {} - {} edition", book.title, book.year);
}

// 此函数接受一个对可变的 Book 类型的引用，它把年份 `year` 改为 2014 年
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!("I mutably borrowed {} - {} edition", book.title, book.year);
}

fn main() {
    // 创建一个名为 `immutabook` 的不可变的 Book 实例
    let immutabook = Book {
        // 字符串字面量拥有 `&amp;'static str` 类型
        author: "Douglas Hofstadter",
        title: "Gödel, Escher, Bach",
        year: 1979,
    };

    // 创建一个 `immutabook` 的可变拷贝，命名为 `mutabook`
    let mut mutabook = immutabook;

    // 不可变地借用一个不可变对象
    borrow_book(&amp;immutabook);

    // 不可变地借用一个可变对象
    borrow_book(&amp;mutabook);

    // 可变地借用一个可变对象
    new_edition(&amp;mut mutabook);

    // 报错！不能可变地借用一个不可变对象
    new_edition(&amp;mut immutabook);
    // 改正 ^ 注释掉此行
}
</code></pre> 
<h4>ref 模式</h4> 
<p>在 Rust 中，<code>&amp;</code> 和 <code>ref</code> 都与 引用 相关，<strong>借用(&amp;)</strong><span style="color:#fe2c24;"><strong>的对象是必须存在的，ref引用的对象可以虚拟的，后期附上对象。</strong></span><strong>区别：ref 关键字用于模式匹配中，将值绑定到引用上。其它地方，借用(&amp;) 等价于 引用(ref)</strong></p> 
<pre><code class="language-rust">fn main() {
    let x = 42;
    if let Some(ref y) = Some(x) { // 使用 ref 将值 x 绑定到引用 y 上
        println!("Got a reference: {}", y);
    }
}</code></pre> 
<p>赋值语句中左边的 ref 关键字等价于右边的 &amp; 符号。即 ref 可以不用 &amp; 从而创建引用。</p> 
<pre><code class="language-rust">fn main() {
    let val = String::from("abc");
    
    let a = &amp;val; // 直接引用
    println!("{:?}", a);
    
    let ref c = val; // 通过 ref, 对具体值创建引用。
    println!("{:?}", c);
}</code></pre> 
<pre><code class="language-rust">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // 赋值语句中左边的 `ref` 关键字等价于右边的 `&amp;` 符号。
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!("ref_c1 equals ref_c2: {}", *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // 在解构一个结构体时 `ref` 同样有效。
    let _copy_of_x = {
        // `ref_to_x` 是一个指向 `point` 的 `x` 字段的引用。
        let Point { x: ref ref_to_x, y: _ } = point;

        // 返回一个 `point` 的 `x` 字段的拷贝。
        *ref_to_x
    };

    // `point` 的可变拷贝
    let mut mutable_point = point;

    {
        // `ref` 可以与 `mut` 结合以创建可变引用。
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // 通过可变引用来改变 `mutable_point` 的字段 `y`。
        *mut_ref_to_y = 1;
    }

    println!("point is ({}, {})", point.x, point.y);
    println!("mutable_point is ({}, {})", mutable_point.x, mutable_point.y);

    // 包含一个指针的可变元组
    let mut mutable_tuple = (Box::new(5u32), 3u32);

    {
        // 解构 `mutable_tuple` 来改变 `last` 的值。
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }

    println!("tuple is {:?}", mutable_tuple);
}
</code></pre> 
<h4>as_ref()</h4> 
<p>as_ref() 是一个方法，通常用于将某个类型转换为其引用类型，以便在函数参数或方法调用中接受引用类型而不是拥有所有权的类型。<code>as_ref()</code> 方法是由标准库中 <code>AsRef</code> trait 定义的，并可用于所有实现了该 trait 的类型。它返回一个对原始值的引用，而不是拷贝整个值。</p> 
<pre><code class="language-rust">fn print_length&lt;T: AsRef&lt;str&gt;&gt;(text: T) {
    let text_ref: &amp;str = text.as_ref();
    println!("Length: {}", text_ref.len());
}

fn main() {
    let text = "Hello, world!";
    print_length(text);  // T类型 ---&gt; &amp;T类型
}
</code></pre> 
<p></p> 
<h4>悬垂引用</h4> 
<p>悬垂引用（Dangling References）</p> 
<blockquote> 
 <p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 <strong>悬垂指针</strong>（<em>dangling pointer</em>），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p> 
 <p>fn main() {<!-- --><br>     let reference_to_nothing = dangle();<br> }</p> 
 <p>fn dangle() -&gt; &amp;String { // dangle 返回一个字符串的引用</p> 
 <p>    let s = String::from("hello"); // s 是一个新字符串</p> 
 <p>    &amp;s // 返回字符串 s 的引用，但是引用不转移所有权，所以函数结束时，s 被销毁释放内存<br> } // 这里 s 离开作用域并被丢弃。其内存被释放。<br>   // 危险！<br> 正确的做法：不返回引用。</p> 
 <p>fn main() {<!-- --><br>     let string = no_dangle();<br> }</p> 
 <p>fn no_dangle() -&gt; String {<!-- --><br>     let s = String::from("hello");<br>     s   // 这样就没有任何错误了。所有权被移动出去，所以没有值被释放。<br> }</p> 
</blockquote> 
<p>Slice 类型：<em>slice</em> 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它同样没有所有权。</p> 
<h4>指针、引用</h4> 
<p>：<a class="link-info" href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/destructuring/destructure_pointers.html" rel="nofollow" title="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/destructuring/destructure_pointers.html">https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/destructuring/destructure_pointers.html</a></p> 
<ul><li>解引用使用 <code>*</code></li><li>解构使用 <code>&amp;</code>、<code>ref</code>、和 <code>ref mut</code></li></ul> 
<pre><code class="language-rust">fn main() {
    // 获得一个 `i32` 类型的引用。`&amp;` 表示取引用。
    let reference = &amp;4;

    match reference {
        // 如果用 `&amp;val` 这个模式去匹配 `reference`，就相当于做这样的比较：
        // `&amp;i32`（译注：即 `reference` 的类型）
        // `&amp;val`（译注：即用于匹配的模式）
        // ^ 我们看到，如果去掉匹配的 `&amp;`，`i32` 应当赋给 `val`。
        // 译注：因此可用 `val` 表示被 `reference` 引用的值 4。
        &amp;val =&gt; println!("Got a value via destructuring: {:?}", val),
    }

    // 如果不想用 `&amp;`，需要在匹配前解引用。
    match *reference {
        val =&gt; println!("Got a value via dereferencing: {:?}", val),
    }

    // 如果一开始就不用引用，会怎样？ `reference` 是一个 `&amp;` 类型，因为赋值语句
    // 的右边已经是一个引用。但下面这个不是引用，因为右边不是。
    let _not_a_reference = 3;

    // Rust 对这种情况提供了 `ref`。它更改了赋值行为，从而可以对具体值创建引用。
    // 下面这行将得到一个引用。
    let ref _is_a_reference = 3;

    // 相应地，定义两个非引用的变量，通过 `ref` 和 `ref mut` 仍可取得其引用。
    let value = 5;
    let mut mut_value = 6;

    // 使用 `ref` 关键字来创建引用。
    // 译注：下面的 r 是 `&amp;i32` 类型，它像 `i32` 一样可以直接打印，因此用法上
    // 似乎看不出什么区别。但读者可以把 `println!` 中的 `r` 改成 `*r`，仍然能
    // 正常运行。前面例子中的 `println!` 里就不能是 `*val`，因为不能对整数解
    // 引用。
    match value {
        ref r =&gt; println!("Got a reference to a value: {:?}", r),
    }

    // 类似地使用 `ref mut`。
    match mut_value {
        ref mut m =&gt; {
            // 已经获得了 `mut_value` 的引用，先要解引用，才能改变它的值。
            *m += 10;
            println!("We added 10. `mut_value`: {:?}", m);
        },
    }
}
</code></pre> 
<p></p> 
<p></p> 
<h3>生命周期</h3> 
<p><strong>生命周期</strong>（lifetime）是这样一种概念，编译器（中的借用检查器）用它来保证所有的借用都是有效的。确切地说，一个变量的生命周期在它创建的时候开始，在它销毁的时候结束。虽然生命周期和作用域经常被一起提到，但它们并不相同。</p> 
<p class="img-center"><img alt="" height="552" src="https://images2.imgbox.com/c3/c9/1hNxI4Vm_o.png" width="1027"></p> 
<p></p> 
<h4>显式 标注 生命周期</h4> 
<p>和<a href="https://rustwiki.org/zh-CN/rust-by-example/fn/closures/anonymity.html" rel="nofollow" title="闭包">闭包</a>类似，使用生命周期需要泛型。若要给类型显式地标注生命周期，其语法会像是 &amp;'a T</p> 
<blockquote> 
 <p>foo&lt;'a&gt;        // foo 的生命周期  <strong><span style="background-color:#ffd900;">小于等于</span></strong>  'a 的周期。<br> foo&lt;'a, 'b&gt;   // foo 的生命周期  <strong><span style="background-color:#ffd900;">小于等于</span></strong>  'a 和 'b 中任一个的周期。</p> 
</blockquote> 
<p>显式生命周期标注的运用：</p> 
<pre><code class="language-rust">// `print_refs` 接受两个 `i32` 的引用，它们有不同的生命周期 `'a` 和 `'b`。
// 这两个生命周期都必须至少要和 `print_refs` 函数一样长。
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!("x is {} and y is {}", x, y);
}

// 不带参数的函数，不过有一个生命周期参数 `'a`。
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // 报错：`_x` 的生命周期不够长
    //let y: &amp;'a i32 = &amp;_x;
    // 在函数内部使用生命周期 `'a` 作为显式类型标注将导致失败，因为 `&amp;_x` 的
    // 生命周期比 `y` 的短。短生命周期不能强制转换成长生命周期。
}

fn main() {
    // 创建变量，稍后用于借用。
    let (four, nine) = (4, 9);

    // 两个变量的借用（`&amp;`）都传进函数。
    print_refs(&amp;four, &amp;nine);
    // 任何被借用的输入量都必须比借用者生存得更长。
    // 也就是说，`four` 和 `nine` 的生命周期都必须比 `print_refs` 的长。

    failed_borrow();
    // `failed_borrow` 未包含引用，因此不要求 `'a` 长于函数的生命周期，
    // 但 `'a` 寿命确实更长。因为该生命周期从未被约束，所以默认为 `'static`。
}
</code></pre> 
<p></p> 
<h4>函数 中的 生命周期</h4> 
<p>带上生命周期的函数签名有一些限制：</p> 
<ul><li>任何引用<strong>都必须</strong>拥有标注好的生命周期。</li><li>任何被返回的引用<strong>都必须</strong>有和某个输入量相同的生命周期或是静态类型（<code>static</code>）。</li></ul> 
<p>另外要注意，如果没有输入的函数返回引用，有时会导致返回的引用指向无效数据，这种情况下禁止它返回这样的引用。下面例子展示了一些合法的带有生命周期的函数：</p> 
<pre><code class="language-rust">// 一个拥有生命周期 `'a` 的输入引用，其中 `'a` 的存活时间
// 至少与函数的一样长。
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!("`print_one`: x is {}", x);
}

// 可变引用同样也可能拥有生命周期。
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// 拥有不同生命周期的多个元素。对下面这种情形，两者即使拥有
// 相同的生命周期 `'a` 也没问题，但对一些更复杂的情形，可能
// 就需要不同的生命周期了。
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!("`print_multi`: x is {}, y is {}", x, y);
}

// 返回传递进来的引用也是可行的。
// 但必须返回正确的生命周期。
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

//fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { &amp;String::from("foo") }
// 上面代码是无效的：`'a` 存活的时间必须比函数的长。
// 这里的 `&amp;String::from("foo")` 将会创建一个 `String` 类型，然后对它取引用。
// 数据在离开作用域时删掉，返回一个指向无效数据的引用。

fn main() {
    let x = 7;
    let y = 9;

    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);

    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}
</code></pre> 
<p></p> 
<h4>方法 中的 生命周期</h4> 
<p>方法一般是不需要标明生命周期的，因为 <code>self</code> 的生命周期会赋给所有的输出生命周期参数，</p> 
<p>方法的标注和函数类似：</p> 
<pre><code class="language-rust">struct Owner(i32);

impl Owner {
    // 标注生命周期，就像独立的函数一样。
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!("`print`: {}", self.0);
    }
}

fn main() {
    let mut owner  = Owner(18);

    owner.add_one();
    owner.print();
}
</code></pre> 
<p></p> 
<h4>结构体 中的 生命周期</h4> 
<p>在结构体中标注生命周期也和函数的类似：</p> 
<pre><code class="language-rust">// 一个 `Borrowed` 类型，含有一个指向 `i32` 类型的引用。
// 该引用必须比 `Borrowed` 寿命更长。
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// 和前面类似，这里的两个引用都必须比这个结构体长寿。
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// 一个枚举类型，其取值不是 `i32` 类型就是一个指向 `i32` 的引用。
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!("x is borrowed in {:?}", single);
    println!("x and y are borrowed in {:?}", double);
    println!("x is borrowed in {:?}", reference);
    println!("y is *not* borrowed in {:?}", number);
}
</code></pre> 
<p></p> 
<h4>trait 中的 生命周期 (实现多态)</h4> 
<p>trait 方法中生命期的标注基本上与函数类似。注意，<code>impl</code> 也可能有生命周期的标注。</p> 
<pre><code class="language-rust">// 带有生命周期标注的结构体。
#[derive(Debug)]
 struct Borrowed&lt;'a&gt; {
     x: &amp;'a i32,
 }

// 给 impl 标注生命周期。
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();  // 实现多态
    println!("b is {:?}", b);
}
</code></pre> 
<p></p> 
<h4>约束 中的 生命周期</h4> 
<p>就如泛型类型能够被约束一样，生命周期（它们本身就是泛型）也可以使用约束。<code>:</code> 字符的意义在这里稍微有些不同，不过 <code>+</code> 是相同的。注意下面的说明：</p> 
<ol><li><code>T: 'a</code>：在 <code>T</code> 中的<strong>所有</strong>引用都必须比生命周期 <code>'a</code> 活得更长。</li><li><code>T: Trait + 'a</code>：<code>T</code> 类型必须实现 <code>Trait</code> trait，并且在 <code>T</code> 中的<strong>所有</strong>引用都必须比 <code>'a</code> 活得更长。</li></ol> 
<p>示例：</p> 
<pre><code class="language-rust">use std::fmt::Debug; // 用于约束的 trait。

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` 包含一个指向泛型类型 `T` 的引用，其中 `T` 拥有一个未知的生命周期
// `'a`。`T` 拥有生命周期限制， `T` 中的任何*引用*都必须比 `'a` 活得更长。另外
// `Ref` 的生命周期也不能超出 `'a`。

// 一个泛型函数，使用 `Debug` trait 来打印内容。
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!("`print`: t is {:?}", t);
}

// 这里接受一个指向 `T` 的引用，其中 `T` 实现了 `Debug` trait，并且在 `T` 中的
// 所有*引用*都必须比 `'a'` 存活时间更长。另外，`'a` 也要比函数活得更长。
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!("`print_ref`: t is {:?}", t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}
</code></pre> 
<p>参考：<a href="https://rustwiki.org/zh-CN/rust-by-example/generics.html" rel="nofollow" title="泛型">泛型</a>, <a href="https://rustwiki.org/zh-CN/rust-by-example/generics/bounds.html" rel="nofollow" title="泛型中的约束">泛型中的约束</a>, 以及 <a href="https://rustwiki.org/zh-CN/rust-by-example/generics/multi_bounds.html" rel="nofollow" title="泛型中的多重约束">泛型中的多重约束</a></p> 
<p></p> 
<h4>生命周期 的 强制转换</h4> 
<p>一个较长的生命周期可以强制转成一个较短的生命周期，使它在一个通常情况下不能工作的作用域内也能正常工作。强制转换可由编译器隐式地推导并执行，也可以通过声明不同的生命周期的形式实现。</p> 
<pre><code class="language-rust">// 在这里，Rust 推导了一个尽可能短的生命周期。
// 然后这两个引用都被强制转成这个生命周期。
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;` 读作生命周期 `'a` 至少和 `'b` 一样长。
// 在这里我们我们接受了一个 `&amp;'a i32` 类型并返回一个 `&amp;'b i32` 类型，这是
// 强制转换得到的结果。
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // 较长的生命周期

    {
        let second = 3; // 较短的生命周期

        println!("The product is {}", multiply(&amp;first, &amp;second));
        println!("{} is the first", choose_first(&amp;first, &amp;second));
    };
}
</code></pre> 
<p></p> 
<h4>static 生命周期</h4> 
<p><code>'static</code> 生命周期是可能的生命周期中最长的，它会在整个程序运行的时期中存在。<code>'static</code> 生命周期也可被强制转换成一个更短的生命周期。有两种方式使变量拥有 <code>'static</code> 生命周期，它们都把数据保存在可执行文件的只读内存区：</p> 
<ul><li>使用 <code>static</code> 声明来产生常量（constant）。</li><li>产生一个拥有 <code>&amp;'static str</code> 类型的 <code>string</code> 字面量。</li></ul> 
<pre><code class="language-rust">// 产生一个拥有 `'static` 生命周期的常量。
static NUM: i32 = 18;

// 返回一个指向 `NUM` 的引用，该引用不取 `NUM` 的 `'static` 生命周期，
// 而是被强制转换成和输入参数的一样。
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // 产生一个 `string` 字面量并打印它：
        let static_string = "I'm in read-only memory";
        println!("static_string: {}", static_string);

        // 当 `static_string` 离开作用域时，该引用不能再使用，不过
        // 数据仍然存在于二进制文件里面。
    }

    {
        // 产生一个整型给 `coerce_static` 使用：
        let lifetime_num = 9;

        // 将对 `NUM` 的引用强制转换成 `lifetime_num` 的生命周期：
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!("coerced_static: {}", coerced_static);
    }

    println!("NUM: {} stays accessible!", NUM);
}
</code></pre> 
<p>参考：<a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/constants.html" rel="nofollow" title="'static 常量">'static 常量</a></p> 
<p></p> 
<h4>省略 生命周期</h4> 
<p>有些生命周期的模式太常用了，所以借用检查器将会隐式地添加它们以减少程序输入量和增强可读性。这种隐式添加生命周期的过程称为省略（elision）。在 Rust 使用省略仅仅是因为这些模式太普遍了。对于省略的详细描述，可以参考官方文档的<a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision" rel="nofollow" title="生命周期省略">生命周期省略</a>。</p> 
<pre><code class="language-rust">// `elided_input` 和 `annotated_input` 事实上拥有相同的签名，
// `elided_input` 的生命周期会被编译器自动添加：
fn elided_input(x: &amp;i32) {
    println!("`elided_input`: {}", x)
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!("`annotated_input`: {}", x)
}

// 类似地，`elided_pass` 和 `annotated_pass` 也拥有相同的签名，
// 生命周期会被隐式地添加进 `elided_pass`：
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!("`elided_pass`: {}", elided_pass(&amp;x));
    println!("`annotated_pass`: {}", annotated_pass(&amp;x));
}
</code></pre> 
<p>参考：<a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision" rel="nofollow" title="省略">省略</a></p> 
<p></p> 
<h3>枚举、结构体</h3> 
<ul><li>枚举（enumerations），也被称作 enums。枚举允许你通过列举可能的 成员（variants）来定义一个类型。 枚举 实际上只会使用其中的一个成员，所以枚举所需的空间等于储存其最大成员的空间大小。</li><li>struct，或者 structure，是一个自定义数据类型，允许你包装和命名多个相关的值，从而形成一个有意义的组合。结构体可以定义方法。<strong>结构体作用就是将字段和数据聚合在一块，<span style="color:#fe2c24;">形成新的数据类型</span></strong>。</li></ul> 
<pre><code class="language-rust">fn main() {
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));
    let loopback = IpAddr::V6(String::from("::1"));

    match home {
        IpAddr::V4(ip) =&gt; println!("Home IPv4 地址是: {}", ip),
        IpAddr::V6(ip) =&gt; println!("Home IPv6 地址是: {}", ip),
    }

    match loopback {
        IpAddr::V4(ip) =&gt; println!("Loopback IPv4 地址是: {}", ip),
        IpAddr::V6(ip) =&gt; println!("Loopback IPv6 地址是: {}", ip),
    }
}</code></pre> 
<h4>枚举类型 Option</h4> 
<p><code>Option</code> 类型提供了一种表示可能存在或不存在的值的方式。<code>Option&lt;T&gt;</code> 是一个枚举类型，它有两个变体：<code>Some(T)</code> 表示存在一个值，<code>None</code> 表示不存在值。<code>Option</code> 类型还提供了一些方法来处理包含值的情况。其中之一是 <code>Some</code> 函数，它被用于将一个值封装在 <code>Some</code> 变体中。</p> 
<pre><code class="language-rust">fn get_name() -&gt; Option&lt;String&gt; {
    let name = "Alice".to_string();
    Some(name)
}

fn main() {
    let name_option = get_name();

    match name_option {
        Some(name) =&gt; println!("Name: {}", name),
        None =&gt; println!("No name found"),
    }
}
</code></pre> 
<h4>枚举类型 Result</h4> 
<p>在 Rust 中，<code>Result</code> 是一个枚举类型，它代表了可能产生错误的操作的结果。<code>Result</code> 枚举有两个变体：<code>Ok</code> 和 <code>Err</code>。</p> 
<ul><li><code>Ok</code> 变体表示操作成功，并包含操作返回的值。</li><li><code>Err</code> 变体表示操作失败，并包含一个错误值，用于描述错误的原因。</li></ul> 
<p>通常，<code>Result</code> 类型被用于表示可能会发生错误的函数的返回类型。这样，调用者可以通过检查 <code>Result</code> 来处理操作的成功或失败。简单的示例，演示如何使用 <code>Result</code>：</p> 
<pre><code class="language-rust">fn divide(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        return Err(String::from("除数不能为零"));
    }

    Ok(a / b)
}

fn main() {
    let result = divide(10, 2);

    match result {
        Ok(value) =&gt; println!("结果是: {}", value),
        Err(error) =&gt; println!("出现错误: {}", error),
    }
}
</code></pre> 
<p>示例 2：</p> 
<pre><code class="language-rust">use std::io;
use std::io::stdin;

fn main() {
    let mut input_str = String::from("");
    stdin().read_line(&amp;mut input_str).expect("获取输入失败");
    let input_int:usize = match input_str.trim().parse() {
        Ok(n) =&gt; n,
        Err(_) =&gt; {
            println!("无效的输入");
            return;
        }
    };
    let result = input_int * 100;
    println!("{result}")
}</code></pre> 
<p>Rust 的 "<strong><span style="background-color:#ffd900;">Ok、Err</span></strong>" <span style="color:#fe2c24;"><strong>宏</strong></span>。这些宏用于将一个值包装在 Ok 或 Err 变体中，并返回相应的 Result 类型</p> 
<pre><code class="language-rust">fn divide(a: i32, b: i32) -&gt; Result&lt;i32, &amp;'static str&gt; {
    if b == 0 {
        Err("除数不能为零")
    } else {
        Ok(a / b)
    }
}

fn main() {
    // let ret_val = divide(10, 2);
    let ret_val = divide(10, 0);
    let result = match ret_val {
        Ok(v) =&gt; v,
        Err(e) =&gt; {
            println!("{}", e);
            return; // 添加 return 语句以结束程序
        }
    };
    println!("结果: {}", result);
}</code></pre> 
<p>读文件 示例：</p> 
<pre><code class="language-rust">#![allow(unused)]    //禁止编译器对未使用的变量进行检查

use std::io;
use std::fs;

fn main() {
    fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
        fs::read_to_string("d:/hello.txt")
    }

    let ret_val = read_username_from_file();
    let result = match ret_val {
        Ok(v) =&gt; v,
        Err(e) =&gt; {
            println!("{}", e);
            return;
        }
    };
    println!("{result}");
}
</code></pre> 
<h3>match、Option&lt;T&gt;</h3> 
<ul><li>Rust 通过 <code>match</code> 关键字来提供模式匹配，和 C 语言的 <code>switch</code> 用法类似。第一个匹配分支会被比对，并且所有可能的值都必须被覆盖。匹配<strong>模式</strong> 可由字面值、变量、通配符和许多其他内容构成。</li><li> <code>Option&lt;T&gt;</code> 时，是为了从 <code>Some</code> 中取出其内部的 <code>T</code> 值；<code>Option&lt;T&gt;</code> 有两个变量：<br>         None，表明失败或缺少值<br>         Some(value)，元组结构体，封装了一个T类型的值value</li></ul> 
<pre><code class="language-rust">fn main() {
    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    // 使用模式匹配
    match six {
        Some(value) =&gt; println!("Some 值是: {}", value),
        None =&gt; println!("None"),
    }

    // 使用 unwrap() 方法
    if let Some(value) = five {
        println!("Some 值是: {}", value);
    } else {
        println!("None");
    }

    if let Some(value) = six {
        println!("Some 值是: {}", value);
    } else {
        println!("None");
    }
}</code></pre> 
<pre><code class="language-rust">fn main() {
    let number = 13;
    // 试一试 ^ 将不同的值赋给 `number`

    println!("Tell me about {}", number);
    match number {
        // 匹配单个值
        1 =&gt; println!("One!"),
        // 匹配多个值
        2 | 3 | 5 | 7 | 11 =&gt; println!("This is a prime"),
        // 试一试 ^ 将 13 添加到质数列表中
        // 匹配一个闭区间范围
        13..=19 =&gt; println!("A teen"),
        // 处理其他情况
        _ =&gt; println!("Ain't special"),
        // 试一试 ^ 注释掉这个总括性的分支
    }

    let boolean = true;
    // match 也是一个表达式
    let binary = match boolean {
        // match 分支必须覆盖所有可能的值
        false =&gt; 0,
        true =&gt; 1,
        // 试一试 ^ 将其中一条分支注释掉
    };

    println!("{} -&gt; {}", boolean, binary);
}
</code></pre> 
<p><strong>模式</strong>（<em>Patterns</em>）是 Rust 中特殊的语法，它用来匹配类型中的结构，无论类型是简单还是复杂。结合使用模式和 <code>match</code> 表达式以及其他结构可以提供更多对程序控制流的支配权。模式由如下一些内容组合而成：</p> 
<ul><li>字面值</li><li>解构的数组、枚举、结构体或者元组</li><li>变量</li><li>通配符</li><li>占位符</li></ul> 
<p>一些模式的例子包括<code>x</code>, <code>(a, 3)</code> 和 <code>Some(Color::Red)</code>。在模式为有效的上下文中，这些部分描述了数据的形状。接着可以用其匹配值来决定程序是否拥有正确的数据来运行特定部分的代码。</p> 
<p>一个模式常用的位置是 <code>match</code> 表达式的分支。</p> 
<blockquote> 
 <p>match VALUE {<!-- --><br>     PATTERN =&gt; EXPRESSION,<br>     PATTERN =&gt; EXPRESSION,<br>     PATTERN =&gt; EXPRESSION,<br> }</p> 
</blockquote> 
<p>示例：匹配变量 <code>x</code> 中 <code>Option&lt;i32&gt;</code> 值的 <code>match</code> 表达式：</p> 
<pre><code class="language-rust">fn main() {
    let x = Option::Some(5);
    let result = match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    };
    println!("{:?}", result);
}
</code></pre> 
<p><code>match</code> 表达式必须是 <strong>穷尽</strong>（<em>exhaustive</em>）的，意为 <code>match</code> 表达式所有可能的值都必须被考虑到。</p> 
<p>有一个特定的模式 <code>_</code> 可以匹配所有情况，不过它从不绑定任何变量。<a href="https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#%E5%BF%BD%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%80%BC" rel="nofollow" title="“忽略模式中的值”">“忽略模式中的值”</a> 详细介绍 <code>_</code> 模式</p> 
<p></p> 
<h4>解构 "元组、枚举、指针、结构体"</h4> 
<p>元组可以在 <code>match</code> 中解构。参考：<a href="https://rustwiki.org/zh-CN/rust-by-example/primitives/tuples.html" rel="nofollow" title="元组">元组</a></p> 
<pre><code class="language-rust">fn main() {
    let triple = (0, -2, 3);
    // 试一试 ^ 将不同的值赋给 `triple`

    println!("Tell me about {:?}", triple);
    // match 可以解构一个元组
    match triple {
        // 解构出第二个和第三个元素
        (0, y, z) =&gt; println!("First is `0`, `y` is {:?}, and `z` is {:?}", y, z),
        (1, ..)  =&gt; println!("First is `1` and the rest doesn't matter"),
        // `..` 可用来忽略元组的其余部分
        _      =&gt; println!("It doesn't matter what they are"),
        // `_` 表示不将值绑定到变量
    }
}
</code></pre> 
<p>解构 <code>enum。参考：</code><a href="https://rustwiki.org/zh-CN/rust-by-example/attribute/unused.html" rel="nofollow" title="#[allow(...)]">#[allow(...)]</a>, <a href="https://en.wikipedia.org/wiki/Color_model" rel="nofollow" title="色彩模型">色彩模型</a> 和 <a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum.html" rel="nofollow" title="enum">enum</a></p> 
<pre><code class="language-rust">// 需要 `allow` 来消除警告，因为只使用了枚举类型的一种取值。
#[allow(dead_code)]
enum Color {
    // 这三个取值仅由它们的名字（而非类型）来指定。
    Red,
    Blue,
    Green,
    // 这些则把 `u32` 元组赋予不同的名字，以色彩模型命名。
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);
    // 试一试 ^ 将不同的值赋给 `color`

    println!("What color is it?");
    // 可以使用 `match` 来解构 `enum`。
    match color {
        Color::Red   =&gt; println!("The color is Red!"),
        Color::Blue  =&gt; println!("The color is Blue!"),
        Color::Green =&gt; println!("The color is Green!"),
        Color::RGB(r, g, b) =&gt;
            println!("Red: {}, green: {}, and blue: {}!", r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!("Hue: {}, saturation: {}, value: {}!", h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!("Hue: {}, saturation: {}, lightness: {}!", h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!("Cyan: {}, magenta: {}, yellow: {}!", c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!("Cyan: {}, magenta: {}, yellow: {}, key (black): {}!",
                     c, m, y, k),
        // 不需要其它分支，因为所有的情形都已覆盖
    }
}
</code></pre> 
<p>解构 指针和引用。</p> 
<p>对指针来说，解构（destructure）和解引用（dereference）要区分开，因为这两者的概念是不同的，和 <code>C</code> 那样的语言用法不一样。参考：<a href="https://rustwiki.org/zh-CN/rust-by-example/scope/borrow/ref.html" rel="nofollow" title="ref 模式">ref 模式</a></p> 
<ul><li>解引用使用 <code>*</code></li><li>解构使用 <code>&amp;</code>、<code>ref</code>、和 <code>ref mut</code></li></ul> 
<pre><code class="language-rust">fn main() {
    // 获得一个 `i32` 类型的引用。`&amp;` 表示取引用。
    let reference = &amp;4;

    match reference {
        // 如果用 `&amp;val` 这个模式去匹配 `reference`，就相当于做这样的比较：
        // `&amp;i32`（译注：即 `reference` 的类型）
        // `&amp;val`（译注：即用于匹配的模式）
        // ^ 我们看到，如果去掉匹配的 `&amp;`，`i32` 应当赋给 `val`。
        // 译注：因此可用 `val` 表示被 `reference` 引用的值 4。
        &amp;val =&gt; println!("Got a value via destructuring: {:?}", val),
    }

    // 如果不想用 `&amp;`，需要在匹配前解引用。
    match *reference {
        val =&gt; println!("Got a value via dereferencing: {:?}", val),
    }

    // 如果一开始就不用引用，会怎样？ `reference` 是一个 `&amp;` 类型，因为赋值语句
    // 的右边已经是一个引用。但下面这个不是引用，因为右边不是。
    let _not_a_reference = 3;

    // Rust 对这种情况提供了 `ref`。它更改了赋值行为，从而可以对具体值创建引用。
    // 下面这行将得到一个引用。
    let ref _is_a_reference = 3;

    // 相应地，定义两个非引用的变量，通过 `ref` 和 `ref mut` 仍可取得其引用。
    let value = 5;
    let mut mut_value = 6;

    // 使用 `ref` 关键字来创建引用。
    // 译注：下面的 r 是 `&amp;i32` 类型，它像 `i32` 一样可以直接打印，因此用法上
    // 似乎看不出什么区别。但读者可以把 `println!` 中的 `r` 改成 `*r`，仍然能
    // 正常运行。前面例子中的 `println!` 里就不能是 `*val`，因为不能对整数解
    // 引用。
    match value {
        ref r =&gt; println!("Got a reference to a value: {:?}", r),
    }

    // 类似地使用 `ref mut`。
    match mut_value {
        ref mut m =&gt; {
            // 已经获得了 `mut_value` 的引用，先要解引用，才能改变它的值。
            *m += 10;
            println!("We added 10. `mut_value`: {:?}", m);
        },
    }
}
</code></pre> 
<p>解构 结构体。参考：<a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/structs.html" rel="nofollow" title="结构体">结构体</a>, <a href="https://rustwiki.org/zh-CN/rust-by-example/scope/borrow/ref.html" rel="nofollow" title="ref 模式">ref 模式</a></p> 
<pre><code class="language-rust">fn main() {
    struct Foo { x: (u32, u32), y: u32 }

    // 解构结构体的成员
    let foo = Foo { x: (1, 2), y: 3 };
    let Foo { x: (a, b), y } = foo;

    println!("a = {}, b = {},  y = {} ", a, b, y);

    // 可以解构结构体并重命名变量，成员顺序并不重要

    let Foo { y: i, x: j } = foo;
    println!("i = {:?}, j = {:?}", i, j);

    // 也可以忽略某些变量
    let Foo { y, .. } = foo;
    println!("y = {}", y);

    // 这将得到一个错误：模式中没有提及 `x` 字段
    // let Foo { y } = foo;
}
</code></pre> 
<h4><strong>匹配守卫</strong>（<em>match guard</em>）</h4> 
<p>加上 <code>match</code> <strong>卫语句</strong>（guard） 来过滤分支。就是 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它也必须被满足才能选择此分支。</p> 
<pre><code class="language-rust">fn main() {
    let pair = (2, -2);
    // 试一试 ^ 将不同的值赋给 `pair`

    println!("Tell me about {:?}", pair);
    match pair {
        (x, y) if x == y =&gt; println!("These are twins"),
        // ^ `if` 条件部分是一个卫语句
        (x, y) if x + y == 0 =&gt; println!("Antimatter, kaboom!"),
        (x, _) if x % 2 == 1 =&gt; println!("The first one is odd"),
        _ =&gt; println!("No correlation..."),
    }
}
</code></pre> 
<pre><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {:?}", x),
    }
    println!("at the end: x = {:?}, y = {y}", x);

    let x = 4;
    let y = false;
    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
}</code></pre> 
<h4>@ 绑定</h4> 
<p>在 <code>match</code> 中，若间接地访问一个变量，则不经过重新绑定就无法在分支中再使用它。<code>match</code> 提供了 <code>@</code> 符号来绑定变量到名称：<em>at</em> 运算符（<code>@</code>）可以在一个模式中同时测试和保存变量值。</p> 
<pre><code class="language-rust">fn main() {
    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("Found an id in range: {}", id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {}", id),
    }

}</code></pre> 
<pre><code class="language-rust">// `age` 函数，返回一个 `u32` 值。
fn age() -&gt; u32 {
    15
}

fn main() {
    println!("Tell me what type of person you are");

    match age() {
        0             =&gt; println!("I haven't celebrated my first birthday yet"),
        // 可以直接匹配（`match`） 1 ..= 12，但那样的话孩子会是几岁？
        // 相反，在 1 ..= 12 分支中绑定匹配值到 `n` 。现在年龄就可以读取了。
        n @ 1  ..= 12 =&gt; println!("I'm a child of age {:?}", n),
        n @ 13 ..= 19 =&gt; println!("I'm a teen of age {:?}", n),
        // 不符合上面的范围。返回结果。
        n             =&gt; println!("I'm an old person of age {:?}", n),
    }
}
</code></pre> 
<p>也可以使用绑定来“解构” <code>enum</code> 变体，例如 <code>Option</code>:</p> 
<pre><code class="language-rust">fn some_number() -&gt; Option&lt;u32&gt; {
    Some(42)
}

fn main() {
    match some_number() {
        // 得到 `Some` 可变类型，如果它的值（绑定到 `n` 上）等于 42，则匹配。
        Some(n @ 42) =&gt; println!("The Answer: {}!", n),
        // 匹配任意其他数字。
        Some(n)      =&gt; println!("Not interesting... {}", n),
        // 匹配任意其他值（`None` 可变类型）。
        _            =&gt; (),
    }
}
</code></pre> 
<p>参考：<a href="https://rustwiki.org/zh-CN/rust-by-example/fn.html" rel="nofollow" title="函数">函数</a>，<a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum.html" rel="nofollow" title="枚举">枚举</a> 和 <a href="https://rustwiki.org/zh-CN/rust-by-example/std/option.html" rel="nofollow" title="Option">Option</a></p> 
<p></p> 
<h4><strong>if let 条件表达式</strong></h4> 
<p><strong>参考：</strong><a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum.html" rel="nofollow" title="枚举">枚举</a>，<a href="https://rustwiki.org/zh-CN/rust-by-example/std/option.html" rel="nofollow" title="Option">Option</a>，和相关的 <a href="https://github.com/rust-lang/rfcs/pull/160" title="RFC">RFC</a></p> 
<p>在一些场合下，用 <code>match</code> 匹配枚举类型并不优雅。比如：</p> 
<pre><code class="language-rust">
#![allow(unused)]
fn main() {
// 将 `optional` 定为 `Option&lt;i32&gt;` 类型
let optional = Some(7);

match optional {
    Some(i) =&gt; {
        println!("This is a really long string and `{:?}`", i);
        // ^ 行首需要 2 层缩进。这里从 optional 中解构出 `i`。
        // 译注：正确的缩进是好的，但并不是 “不缩进就不能运行” 这个意思。
    },
    _ =&gt; {},
    // ^ 必须有，因为 `match` 需要覆盖全部情况。不觉得这行很多余吗？
};

}
</code></pre> 
<p><code>if let</code> 在这样的场合要简洁得多，可以只匹配关心的分支。还可以组合并匹配 <code>if let</code>、<code>else if</code> 和 <code>else if let</code> 表达式。</p> 
<p>示例：</p> 
<pre><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}</code></pre> 
<pre><code class="language-rust">fn main() {
    // 全部都是 `Option&lt;i32&gt;` 类型
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // `if let` 结构读作：若 `let` 将 `number` 解构成 `Some(i)`，则执行
    // 语句块（`{}`）
    if let Some(i) = number {
        println!("Matched {:?}!", i);
    }

    // 如果要指明失败情形，就使用 else：
    if let Some(i) = letter {
        println!("Matched {:?}!", i);
    } else {
        // 解构失败。切换到失败情形。
        println!("Didn't match a number. Let's go with a letter!");
    };

    // 提供另一种失败情况下的条件。
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!("Matched {:?}!", i);
        // 解构失败。使用 `else if` 来判断是否满足上面提供的条件。
    } else if i_like_letters {
        println!("Didn't match a number. Let's go with a letter!");
    } else {
        // 条件的值为 false。于是以下是默认的分支：
        println!("I don't like letters. Let's go with an emoticon :)!");
    };
}
</code></pre> 
<p><code>if let</code> 匹配任何枚举值：</p> 
<pre><code class="language-rust">// 以这个 enum 类型为例
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    // 创建变量
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);

    // 变量 a 匹配到了 Foo::Bar
    if let Foo::Bar = a {
        println!("a is foobar");
    }

    // 变量 b 没有匹配到 Foo::Bar，因此什么也不会打印。
    if let Foo::Bar = b {
        println!("b is foobar");
    }

    // 变量 c 匹配到了 Foo::Qux，它带有一个值，就和上面例子中的 Some() 类似。
    if let Foo::Qux(value) = c {
        println!("c is {}", value);
    }
}
</code></pre> 
<p></p> 
<h4>while let 条件循环</h4> 
<p>与 <code>if let</code> 结构类似的是 <code>while let</code> 条件循环，它允许只要模式匹配就一直进行 <code>while</code> 循环。</p> 
<pre><code class="language-rust">fn main() {
    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!("{}", top);
    }

}</code></pre> 
<p>会打印出 3、2 接着是 1。<code>pop</code> 方法取出 vector 的最后一个元素并返回 <code>Some(value)</code>。如果 vector 是空的，它返回 <code>None</code>。<code>while</code> 循环只要 <code>pop</code> 返回 <code>Some</code> 就会一直运行其块中的代码。一旦其返回 <code>None</code>，<code>while</code> 循环停止。我们可以使用 <code>while let</code> 来弹出栈中的每一个元素。</p> 
<p>和 <code>if let</code> 类似，<code>while let</code> 也可以把别扭的 <code>match</code> 改写得好看一些。考虑下面这段使 <code>i</code> 不断增加的代码：</p> 
<pre><code class="language-rust">
#![allow(unused)]
fn main() {
// 将 `optional` 设为 `Option&lt;i32&gt;` 类型
let mut optional = Some(0);

// 重复运行这个测试。
loop {
    match optional {
        // 如果 `optional` 解构成功，就执行下面语句块。
        Some(i) =&gt; {
            if i &gt; 9 {
                println!("Greater than 9, quit!");
                optional = None;
            } else {
                println!("`i` is `{:?}`. Try again.", i);
                optional = Some(i + 1);
            }
            // ^ 需要三层缩进！
        },
        // 当解构失败时退出循环：
        _ =&gt; { break; }
        // ^ 为什么必须写这样的语句呢？肯定有更优雅的处理方式！
    }
}
}
</code></pre> 
<p>使用 <code>while let</code> 可以使这段代码变得更加优雅：</p> 
<pre><code class="language-rust">fn main() {
    // 将 `optional` 设为 `Option&lt;i32&gt;` 类型
    let mut optional = Some(0);

    // 这读作：当 `let` 将 `optional` 解构成 `Some(i)` 时，就
    // 执行语句块（`{}`）。否则就 `break`。
    while let Some(i) = optional {
        if i &gt; 9 {
            println!("Greater than 9, quit!");
            optional = None;
        } else {
            println!("`i` is `{:?}`. Try again.", i);
            optional = Some(i + 1);
        }
        // ^ 使用的缩进更少，并且不用显式地处理失败情况。
    }
    // ^ `if let` 有可选的 `else`/`else if` 分句，
    // 而 `while let` 没有。
}
</code></pre> 
<h4>for 循环</h4> 
<pre><code class="language-rust">fn main() {
    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{} is at index {}", value, index);
    }

}</code></pre> 
<p>使用 <code>enumerate</code> 方法适配一个迭代器来产生一个值和其在迭代器中的索引，它们位于一个元组中。第一个产生的值是元组 <code>(0, 'a')</code>。当这个值匹配模式 <code>(index, value)</code>，<code>index</code> 将会是 0 而 <code>value</code> 将会是 <code>'a'</code>，并打印出第一行输出。</p> 
<h4><strong>函数参数</strong></h4> 
<p>函数参数也可以是模式。</p> 
<pre><code class="language-rust">fn foo(x: i32) {
    // code goes here
}

fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre> 
<h4>refutable、irrefutable</h4> 
<p>模式有两种形式：</p> 
<ul><li>refutable（可反驳的）：对某些可能的值进行匹配会失败的模式被称为是 <strong>可反驳的</strong>（<em>refutable</em>）。一个这样的例子便是 <code>if let Some(x) = a_value</code> 表达式中的 <code>Some(x)</code>；如果变量 <code>a_value</code> 中的值是 <code>None</code> 而不是 <code>Some</code>，那么 <code>Some(x)</code> 模式不能匹配。</li><li>irrefutable（不可反驳的）：能匹配任何传递的可能值的模式被称为是 <strong>不可反驳的</strong>（<em>irrefutable</em>）。一个例子就是 <code>let x = 5;</code> 语句中的 <code>x</code>，因为 <code>x</code> 可以匹配任何值所以不可能会失败。</li></ul> 
<p>不可反驳模式的地方使用可反驳模式，直接报错。示例：let Some(x) = some_option_value;</p> 
<p>为了修复在需要不可反驳模式的地方使用可反驳模式的情况，可以修改使用模式的代码：不同于使用 <code>let</code>，可以使用 <code>if let</code>。如此，如果模式不匹配，大括号中的代码将被忽略，其余代码保持有效。示例</p> 
<blockquote> 
 <p>if let Some(x) = some_option_value {<!-- --><br>     println!("{}", x);<br> }</p> 
</blockquote> 
<h4><strong>所有的模式语法</strong></h4> 
<blockquote> 
 <p>匹配字面值<br> let x = 1;<br> match x {<!-- --><br>     1 =&gt; println!("one"),<br>     2 =&gt; println!("two"),<br>     3 =&gt; println!("three"),<br>     _ =&gt; println!("anything"),<br> }</p> 
</blockquote> 
<blockquote> 
 <p>匹配命名变量<br> let x = Some(5);<br> let y = 10;<br> match x {<!-- --><br>     Some(50) =&gt; println!("Got 50"),<br>     Some(y) =&gt; println!("Matched, y = {y}"),<br>     _ =&gt; println!("Default case, x = {:?}", x),<br> }</p> 
 <p>println!("at the end: x = {:?}, y = {y}", x);</p> 
</blockquote> 
<blockquote> 
 <p>多个模式。在 match 表达式中，可以使用 | 语法匹配多个模式，它代表 或（or）运算符模式。<br> let x = 1;<br> match x {<!-- --><br>     1 | 2 =&gt; println!("one or two"),<br>     3 =&gt; println!("three"),<br>     _ =&gt; println!("anything"),<br> }</p> 
</blockquote> 
<blockquote> 
 <p>通过 ..= 匹配值的范围, 允许你匹配一个闭区间范围内的值。<br> let x = 5;</p> 
 <p>match x {<!-- --><br>     1..=5 =&gt; println!("one through five"),<br>     _ =&gt; println!("something else"),<br> }<br> let x = 'c';</p> 
 <p>match x {<!-- --><br>     'a'..='j' =&gt; println!("early ASCII letter"),<br>     'k'..='z' =&gt; println!("late ASCII letter"),<br>     _ =&gt; println!("something else"),<br> }</p> 
</blockquote> 
<p>解构并分解值。使用模式来解构结构体、枚举和元组，以便使用这些值的不同部分。</p> 
<blockquote> 
 <p>// 解构结构体</p> 
 <p>struct Point {<!-- --><br>     x: i32,<br>     y: i32,<br> }</p> 
 <p>fn main() {<!-- --><br>     let p = Point { x: 0, y: 7 };</p> 
 <p>    match p {<!-- --><br>         Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),<br>         Point { x: 0, y } =&gt; println!("On the y axis at {y}"),<br>         Point { x, y } =&gt; {<!-- --><br>             println!("On neither axis: ({x}, {y})");<br>         }<br>     }</p> 
 <p>    let Point { x: a, y: b } = p;<br>     assert_eq!(0, a);<br>     assert_eq!(7, b);</p> 
 <p>    let Point { x, y } = p;<br>     assert_eq!(0, x);<br>     assert_eq!(7, y);<br> }</p> 
</blockquote> 
<blockquote> 
 <p>解构枚举<br> enum Message {<!-- --><br>     Quit,<br>     Move { x: i32, y: i32 },<br>     Write(String),<br>     ChangeColor(i32, i32, i32),<br> }</p> 
 <p>fn main() {<!-- --><br>     let msg = Message::ChangeColor(0, 160, 255);</p> 
 <p>    match msg {<!-- --><br>         Message::Quit =&gt; {<!-- --><br>             println!("The Quit variant has no data to destructure.");<br>         }<br>         Message::Move { x, y } =&gt; {<!-- --><br>             println!("Move in the x direction {x} and in the y direction {y}");<br>         }<br>         Message::Write(text) =&gt; {<!-- --><br>             println!("Text message: {text}");<br>         }<br>         Message::ChangeColor(r, g, b) =&gt; {<!-- --><br>             println!("Change the color to red {r}, green {g}, and blue {b}",)<br>         }<br>     }<br> }</p> 
</blockquote> 
<blockquote> 
 <p>解构嵌套的结构体和枚举<br> enum Color {<!-- --><br>     Rgb(i32, i32, i32),<br>     Hsv(i32, i32, i32),<br> }</p> 
 <p>enum Message {<!-- --><br>     Quit,<br>     Move { x: i32, y: i32 },<br>     Write(String),<br>     ChangeColor(Color),<br> }</p> 
 <p>fn main() {<!-- --><br>     let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));</p> 
 <p>    match msg {<!-- --><br>         Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {<!-- --><br>             println!("Change color to red {r}, green {g}, and blue {b}");<br>         }<br>         Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {<!-- --><br>             println!("Change color to hue {h}, saturation {s}, value {v}")<br>         }<br>         _ =&gt; (),<br>     }<br> }</p> 
</blockquote> 
<blockquote> 
 <p>// 解构结构体和元组<br> let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });</p> 
</blockquote> 
<h4>忽略模式中的值</h4> 
<p>有时忽略模式中的一些值是有用的，比如 <code>match</code> 中最后捕获全部情况的分支实际上没有做任何事，但是它确实对所有剩余情况负责。</p> 
<blockquote> 
 <p>使用 <code>_</code> 模式</p> 
 <p>fn foo(_: i32, y: i32) {    // 完全忽略作为第一个参数传递的值 3<br>     println!("This code only uses the y parameter: {}", y);<br> }</p> 
 <p>fn main() {<!-- --><br>     foo(3, 4);<br> }</p> 
</blockquote> 
<pre><code class="language-rust">fn main() {
    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {:?}", setting_value);

}</code></pre> 
<pre><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);
    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}")
        }
    }

}</code></pre> 
<p>在名字前以一个 _ 开头来忽略未使用的变量。如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为未使用的变量可能会是个 bug。但是有时创建一个还未使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头。</p> 
<pre><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre> 
<pre><code class="language-rust">fn main() {
    let s = Some(String::from("Hello!"));

    //###################################
    // if let Some(_s) = s {
    //     println!("found a string");
    // }
    // println!("{:?}", s); // 这里报错,因为s所有权被移动到了_s
    //###################################
    if let Some(_) = s {
        println!("found a string");
    }
    println!("{:?}", s); // 不报错,因为没有把s绑定到任何变量；它没有被移动。
}</code></pre> 
<p>使用 <code>..</code> 表示 "剩余未使用的部分"</p> 
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
    z: i32,
}

fn main() {
    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {}", x),
    }

}</code></pre> 
<p>这里用 <code>first</code> 和 <code>last</code> 来匹配第一个和最后一个值。<code>..</code> 将匹配并忽略中间的所有值。</p> 
<pre><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre> 
<p>使用 <code>..</code> 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错。示例：</p> 
<pre><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {}", second)
        },
    }
}</code></pre> 
<p>Rust 不可能决定在元组中匹配 <code>second</code> 值之前应该忽略多少个值，以及在之后忽略多少个值。这段代码可能表明我们意在忽略 <code>2</code>，绑定 <code>second</code> 为 <code>4</code>，接着忽略 <code>8</code>、<code>16</code> 和 <code>32</code>；抑或是意在忽略 <code>2</code> 和 <code>4</code>，绑定 <code>second</code> 为 <code>8</code>，接着忽略 <code>16</code> 和 <code>32</code>，以此类推。变量名 <code>second</code> 对于 Rust 来说并没有任何特殊意义，所以会得到编译错误，因为在这两个地方使用 <code>..</code> 是有歧义的。</p> 
<p></p> 
<h3>函数、方法、闭包、高阶函数、发散函数</h3> 
<h4>函数</h4> 
<ul><li>函数（function）使用 <code>fn</code> 关键字来声明。</li><li>函数的参数需要标注类型，就和变量一样，</li><li>如果函数返回一个值，返回类型必须在箭头 <code>-&gt;</code> 之后指定。一个 "不" 返回值的函数。实际上会返回一个单元类型 `()`。当函数返回 `()` 时，函数签名可以省略返回类型</li></ul> 
<h4>方法</h4> 
<ul><li>方法（method）是依附于对象的函数。这些方法通过关键字 <code>self</code> 来访问对象中的数据和其他。方法在 <code>impl</code> 代码块中定义。</li></ul> 
<pre><code class="language-rust">struct Point {
    x: f64,
    y: f64,
}

// 实现的代码块，`Point` 的所有方法都在这里给出
impl Point {
    // 这是一个静态方法（static method）
    // 静态方法不需要被实例调用
    // 这类方法一般用作构造器（constructor）
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // 另外一个静态方法，需要两个参数：
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // 这是一个实例方法（instance method）
    // `&amp;self` 是 `self: &amp;Self` 的语法糖（sugar），其中 `Self` 是方法调用者的
    // 类型。在这个例子中 `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // `self` 通过点运算符来访问结构体字段
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs` 是一个 `f64` 类型的方法，返回调用者的绝对值
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // 这个方法要求调用者是可变的
    // `&amp;mut self` 为 `self: &amp;mut Self` 的语法糖
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` 拥有资源：两个堆分配的整型
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // 这个方法会 “消耗” 调用者的资源
    // `self` 为 `self: Self` 的语法糖
    fn destroy(self) {
        // 解构 `self`
        let Pair(first, second) = self;

        println!("Destroying Pair({}, {})", first, second);

        // `first` 和 `second` 离开作用域后释放
    }
}

fn main() {
    let rectangle = Rectangle {
        // 静态方法使用双冒号调用
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // 实例方法通过点运算符来调用
    // 注意第一个参数 `&amp;self` 是隐式传递的，亦即：
    // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!("Rectangle perimeter: {}", rectangle.perimeter());
    println!("Rectangle area: {}", rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // 报错！ `rectangle` 是不可变的，但这方法需要一个可变对象
    //rectangle.translate(1.0, 0.0);
    // 试一试 ^ 去掉此行的注释

    // 正常运行！可变对象可以调用可变方法
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // 报错！前面的 `destroy` 调用 “消耗了” `pair`
    //pair.destroy();
    // 试一试 ^ 将此行注释去掉
}
</code></pre> 
<h4><strong>闭包 ( </strong>lambda 表达式 <strong>)</strong></h4> 
<p>Rust 中的闭包（closure），也叫做 lambda 表达式或者 lambda，是一类能够捕获周围作用域中变量的函数。例如，一个可以捕获 x 变量的闭包如下：|val| val + x</p> 
<p>调用一个闭包和调用一个函数完全相同，不过调用闭包时，输入和返回类型两者都<strong>可以</strong>自动推导，而输入变量名<strong>必须</strong>指明。</p> 
<p>其他的特点包括：</p> 
<ul><li>声明时使用 <code>||</code> 替代 <code>()</code> 将输入参数括起来。</li><li>函数体定界符（<code>{}</code>）对于单个表达式是可选的，其他情况必须加上。</li><li>有能力捕获外部环境的变量。</li></ul> 
<pre><code class="language-rust">fn main() {
    // 通过闭包和函数分别实现自增。
    // 译注：下面这行是使用函数的实现
    fn function(i: i32) -&gt; i32 { i + 1 }

    // 闭包是匿名的，这里我们将它们绑定到引用。
    // 类型标注和函数的一样，不过类型标注和使用 `{}` 来围住函数体都是可选的。
    // 这些匿名函数（nameless function）被赋值给合适地命名的变量。
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred = |i| i + 1;

    // 译注：将闭包绑定到引用的说法可能不准。
    // 据[语言参考](https://doc.rust-lang.org/beta/reference/types.html#closure-types)
    // 闭包表达式产生的类型就是 “闭包类型”，不属于引用类型，而且确实无法对上面两个
    // `closure_xxx` 变量解引用。

    let i = 1;
    // 调用函数和闭包。
    println!("function: {}", function(i));
    println!("closure_annotated: {}", closure_annotated(i));
    println!("closure_inferred: {}", closure_inferred(i));

    // 没有参数的闭包，返回一个 `i32` 类型。
    // 返回类型是自动推导的。
    let one = || 1;
    println!("closure returning one: {}", one());
}
</code></pre> 
<p>闭包语法与函数语法有很多相似：</p> 
<blockquote> 
 <p>fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }    // 个函数定义<br> let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };    // 完整标注的闭包定义<br> let add_one_v3 = |x|             { x + 1 };    // 闭包定义中省略了类型注解<br> let add_one_v4 = |x|               x + 1  ;    // 闭包体只有一个表达式, 去掉可选的大括号</p> 
</blockquote> 
<p>闭包<span style="color:#fe2c24;"><strong> 从周围的作用域中捕获变量</strong></span>，可以通过三种方式 ：</p> 
<ul><li>通过引用：<code>&amp;T </code><strong><span style="background-color:#ffd900;">不可变借用</span></strong></li><li>通过可变引用：<code>&amp;mut T  </code><strong><span style="background-color:#ffd900;">可变借用</span></strong></li><li>通过值：<code>T  </code><strong><span style="background-color:#ffd900;">获取所有权</span></strong></li></ul> 
<p>直接对应到函数获取参数的三种方式："<strong><span style="background-color:#ffd900;">不可变借用，可变借用、获取所有权</span></strong>"。</p> 
<p>闭包优先通过引用来捕获变量，并且仅在需要时使用其他方式。</p> 
<pre><code class="language-rust">fn main() {
    use std::mem;

    let color = String::from("green");

    // 这个闭包打印 `color`。它会立即借用（通过引用，`&amp;`）`color` 并将该借用和
    // 闭包本身存储到 `print` 变量中。`color` 会一直保持被借用状态直到
    // `print` 离开作用域。
    //
    // `println!` 只需传引用就能使用，而这个闭包捕获的也是变量的引用，因此无需
    // 进一步处理就可以使用 `println!`。
    let print = || println!("`color`: {}", color);

    // 使用借用来调用闭包 `color`。
    print();

    // `color` 可再次被不可变借用，因为闭包只持有一个指向 `color` 的不可变引用。
    let _reborrow = &amp;color;
    print();

    // 在最后使用 `print` 之后，移动或重新借用都是允许的。
    let _color_moved = color;

    let mut count = 0;
    // 这个闭包使 `count` 值增加。要做到这点，它需要得到 `&amp;mut count` 或者
    // `count` 本身，但 `&amp;mut count` 的要求没那么严格，所以我们采取这种方式。
    // 该闭包立即借用 `count`。
    //
    // `inc` 前面需要加上 `mut`，因为闭包里存储着一个 `&amp;mut` 变量。调用闭包时，
    // 该变量的变化就意味着闭包内部发生了变化。因此闭包需要是可变的。
    let mut inc = || {
        count += 1;
        println!("`count`: {}", count);
    };

    // 使用可变借用调用闭包
    inc();

    // 因为之后调用闭包，所以仍然可变借用 `count`
    // 试图重新借用将导致错误
    // let _reborrow = &amp;count;
    // ^ 试一试：将此行注释去掉。
    inc();

    // 闭包不再借用 `&amp;mut count`，因此可以正确地重新借用
    let _count_reborrowed = &amp;mut count;

    // 不可复制类型（non-copy type）。
    let movable = Box::new(3);

    // `mem::drop` 要求 `T` 类型本身，所以闭包将会捕获变量的值。这种情况下，
    // 可复制类型将会复制给闭包，从而原始值不受影响。不可复制类型必须移动
    // （move）到闭包中，因而 `movable` 变量在这里立即移动到了闭包中。
    let consume = || {
        println!("`movable`: {:?}", movable);
        mem::drop(movable);
    };

    // `consume` 消耗了该变量，所以该闭包只能调用一次。
    consume();
    //consume();
    // ^ 试一试：将此行注释去掉。
}
</code></pre> 
<p>定义并调用一个捕获不可变引用的闭包</p> 
<pre><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let only_borrows = || println!("From closure: {:?}", list);

    println!("Before calling closure: {:?}", list);
    only_borrows();
    println!("After calling closure: {:?}", list);
}</code></pre> 
<p>定义并调用一个捕获可变引用的闭包</p> 
<pre><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {:?}", list);
}</code></pre> 
<p>在竖线 <code>|</code> 之前使用 <code>move</code> 会强制闭包取得被捕获变量的所有权。</p> 
<pre><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    thread::spawn(move || println!("From thread: {:?}", list))
        .join()
        .unwrap();
}</code></pre> 
<p>在闭包定义前写上 <code>move</code> 关键字来指明 <code>list</code> 应当被移动到闭包中。新线程可能在主线程剩余部分执行完前执行完，或者也可能主线程先执行完。如果主线程维护了 <code>list</code> 的所有权但却在新线程之前结束并且丢弃了 <code>list</code>，则在线程中的不可变引用将失效。因此，编译器要求 <code>list</code> 被移动到在新线程中运行的闭包中，这样引用就是有效的。试着去掉 <code>move</code> 关键字或在闭包被定义后在主线程中使用 <code>list</code> 看看你会得到什么编译器报错！</p> 
<p><strong>闭包 作为 "函数输入参数、输出返回值、类型匿名"</strong></p> 
<p>虽然 Rust 无需类型说明就能在大多数时候完成变量捕获，但在编写函数时，这种模糊写法是不允许的。当以闭包作为输入参数时，必须指出闭包的完整类型，它是通过使用以下 <code>trait</code> 中的一种来指定的。其受限制程度按以下顺序递减：</p> 
<ul><li><code>Fn</code>：表示捕获方式为通过引用（<code>&amp;T</code>）的闭包</li><li><code>FnMut</code>：表示捕获方式为通过可变引用（<code>&amp;mut T</code>）的闭包</li><li><code>FnOnce</code>：表示捕获方式为通过值（<code>T</code>）的闭包</li></ul> 
<p><code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code> 这些 <code>trait</code> 明确了闭包如何从周围的作用域中捕获变量。对闭包所要捕获的每个变量，是在满足使用需求的前提下尽量以限制最多的方式捕获。这是因为如果能以移动的方式捕获变量，则闭包也有能力使用其他方式借用变量。注意反过来就不再成立：如果参数的类型说明是 <code>Fn</code>，那么不允许该闭包通过 <code>&amp;mut T</code> 或 <code>T</code> 捕获变量。</p> 
<p>示例：</p> 
<pre><code class="language-rust">// 该函数将闭包作为参数并调用它。
fn apply&lt;F&gt;(f: F) where
// 闭包没有输入值和返回值。
    F: FnOnce() {
    // ^ 试一试：将 `FnOnce` 换成 `Fn` 或 `FnMut`。

    f();
}

// 输入闭包，返回一个 `i32` 整型的函数。
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
// 闭包处理一个 `i32` 整型并返回一个 `i32` 整型。
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = "hello";
    // 不可复制的类型。
    // `to_owned` 从借用的数据创建有所有权的数据。
    let mut farewell = "goodbye".to_owned();

    // 捕获 2 个变量：通过引用捕获 `greeting`，通过值捕获 `farewell`。
    let diary = || {
        // `greeting` 通过引用捕获，故需要闭包是 `Fn`。
        println!("I said {}.", greeting);

        // 下文改变了 `farewell` ，因而要求闭包通过可变引用来捕获它。
        // 现在需要 `FnMut`。
        farewell.push_str("!!!");
        println!("Then I screamed {}.", farewell);
        println!("Now I can sleep. zzzzz");

        // 手动调用 drop 又要求闭包通过值获取 `farewell`。
        // 现在需要 `FnOnce`。
        mem::drop(farewell);
    };

    // 以闭包作为参数，调用函数 `apply`。
    apply(diary);

    // 闭包 `double` 满足 `apply_to_3` 的 trait 约束。
    let double = |x| 2 * x;

    println!("3 doubled: {}", apply_to_3(double));
}
</code></pre> 
<p>使用闭包作为函数参数，这要求闭包是<a href="https://rustwiki.org/zh-CN/rust-by-example/generics.html" rel="nofollow" title="泛型">泛型</a>的，闭包定义的方式决定了这是必要的。</p> 
<pre><code class="language-rust">
#![allow(unused)]
fn main() {
// `F` 必须是泛型的。
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {
    f();
}
}
</code></pre> 
<p>当闭包被定义，编译器会隐式地创建一个匿名类型的结构体，用以储存闭包捕获的变量，同时为这个未知类型的结构体实现函数功能，通过 <code>Fn</code>、<code>FnMut</code> 或 <code>FnOnce</code> 三种 <code>trait</code> 中的一种。</p> 
<p>若使用闭包作为函数参数，由于这个结构体的类型未知，任何的用法都要求是泛型的。然而，使用未限定类型的参数 <code>&lt;T&gt;</code> 过于不明确，并且是不允许的。事实上，指明为该结构体实现的是 <code>Fn</code>、<code>FnMut</code>、或 <code>FnOnce</code> 中的哪种 <code>trait</code>，对于约束该结构体的类型而言就已经足够了。</p> 
<pre><code class="language-rust">// `F` 必须为一个没有输入参数和返回值的闭包实现 `Fn`，这和对 `print` 的
// 要求恰好一样。
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // 捕获 `x` 到匿名类型中，并为它实现 `Fn`。
    // 将闭包存储到 `print` 中。
    let print = || println!("{}", x);

    apply(print);
}
</code></pre> 
<p>函数作为参数 (必须满足输入限定)</p> 
<p>既然闭包可以作为参数，你很可能想知道函数是否也可以呢。确实可以！如果你声明一个接受闭包作为参数的函数，那么任何满足该闭包的 trait 约束的函数都可以作为其参数。</p> 
<pre><code class="language-rust">// 定义一个函数，可以接受一个由 `Fn` 限定的泛型 `F` 参数并调用它。
fn call_me&lt;F: Fn()&gt;(f: F) {
    f()
}

// 定义一个满足 `Fn` 约束的封装函数（wrapper function）。
fn function() {
    println!("I'm a function!");
}

fn main() {
    // 定义一个满足 `Fn` 约束的闭包。
    let closure = || println!("I'm a closure!");
    
    call_me(closure);
    call_me(function);
}
</code></pre> 
<p>闭包作为输入参数是可能的，所以返回闭包作为输出参数（output parameter）也应该是可能的。然而返回闭包类型会有问题，因为目前 Rust 只支持返回具体（非泛型）的类型。按照定义，匿名的闭包的类型是未知的，所以只有使用<code>impl Trait</code>才能返回一个闭包。</p> 
<p>返回闭包的有效特征是：</p> 
<ul><li><code>Fn</code></li><li><code>FnMut</code></li><li><code>FnOnce</code></li></ul> 
<p>除此之外，还必须使用 <code>move</code> 关键字，它表明所有的捕获都是通过值进行的。这是必须的，因为在函数退出时，任何通过引用的捕获都被丢弃，在闭包中留下无效的引用。</p> 
<pre><code class="language-rust">fn create_fn() -&gt; impl Fn() {
    let text = "Fn".to_owned();

    move || println!("This is a: {}", text)
}

fn create_fnmut() -&gt; impl FnMut() {
    let text = "FnMut".to_owned();

    move || println!("This is a: {}", text)
}

fn create_fnonce() -&gt; impl FnOnce() {
    let text = "FnOnce".to_owned();

    move || println!("This is a: {}", text)
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();
    let fn_once = create_fnonce();

    fn_plain();
    fn_mut();
    fn_once();
}

</code></pre> 
<p><strong>Iterator::any</strong></p> 
<p><code>Iterator::any</code> 是一个函数，若传给它一个迭代器（iterator），当其中任一元素满足谓词（predicate）时它将返回 <code>true</code>，否则返回 <code>false</code>（译注：谓词是闭包规定的， <code>true</code>/<code>false</code> 是闭包作用在元素上的返回值）。它的签名如下：</p> 
<pre><code class="language-rust">pub trait Iterator {
    // 被迭代的类型。
    type Item;

    // `any` 接受 `&amp;mut self` 参数（译注：回想一下，这是 `self: &amp;mut Self` 的简写）
    // 表明函数的调用者可以被借用和修改，但不会被消耗。
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut` 表示被捕获的变量最多只能被修改，而不能被消耗。
        // `Self::Item` 表明变量是通过值传递给闭包（译注：是迭代器对应的元素的类型）
        F: FnMut(Self::Item) -&gt; bool {}
}
</code></pre> 
<pre><code class="language-rust">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // 对 vec 的 `iter()` 举出 `&amp;i32`。（通过用 `&amp;x` 匹配）把它解构成 `i32`。
    // 译注：注意 `any` 方法会自动地把 `vec.iter()` 举出的迭代器的元素一个个地
    // 传给闭包。因此闭包接收到的参数是 `&amp;i32` 类型的。
    println!("2 in vec1: {}", vec1.iter()     .any(|&amp;x| x == 2));
    // 对 vec 的 `into_iter()` 举出 `i32` 类型。无需解构。
    println!("2 in vec2: {}", vec2.into_iter().any(| x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // 对数组的 `iter()` 举出 `&amp;i32`。
    println!("2 in array1: {}", array1.iter()     .any(|&amp;x| x == 2));
    // 对数组的 `into_iter()` 举出 `i32`。
    println!("2 in array2: {}", array2.into_iter().any(|x| x == 2));
}
</code></pre> 
<p><strong>Iterator::find</strong></p> 
<p><code>Iterator::find</code> 是一个函数，在传给它一个迭代器时，将用 <code>Option</code> 类型返回第一个满足谓词的元素。它的签名如下：</p> 
<pre><code class="language-rust">pub trait Iterator {
    // 被迭代的类型。
    type Item;

    // `find` 接受 `&amp;mut self` 参数，表明函数的调用者可以被借用和修改，
    // 但不会被消耗。
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut` 表示被捕获的变量最多只能被修改，而不能被消耗。
        // `&amp;Self::Item` 指明了被捕获变量的类型（译注：是对迭代器元素的引用类型）
        P: FnMut(&amp;Self::Item) -&gt; bool {}
}
</code></pre> 
<pre><code class="language-rust">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // 对 vec1 的 `iter()` 举出 `&amp;i32` 类型。
    let mut iter = vec1.iter();
    // 对 vec2 的 `into_iter()` 举出 `i32` 类型。
    let mut into_iter = vec2.into_iter();

    // 对迭代器举出的元素的引用是 `&amp;&amp;i32` 类型。解构成 `i32` 类型。
    // 译注：注意 `find` 方法会把迭代器元素的引用传给闭包。迭代器元素自身
    // 是 `&amp;i32` 类型，所以传给闭包的是 `&amp;&amp;i32` 类型。
    println!("Find 2 in vec1: {:?}", iter     .find(|&amp;&amp;x| x == 2));
    // 对迭代器举出的元素的引用是 `&amp;i32` 类型。解构成 `i32` 类型。
    println!("Find 2 in vec2: {:?}", into_iter.find(| &amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // 对数组的 `iter()` 举出 `&amp;i32`。
    println!("Find 2 in array1: {:?}", array1.iter()     .find(|&amp;&amp;x| x == 2));
    // 对数组的 `into_iter()` 通常举出 `&amp;i32``。
    println!("Find 2 in array2: {:?}", array2.into_iter().find(|&amp;x| x == 2));
}
</code></pre> 
<h4>高阶函数</h4> 
<p>Rust 提供了高阶函数（Higher Order Function, HOF），指那些输入一个或多个函数，并且/或者产生一个更有用的函数的函数。HOF 和惰性迭代器（lazy iterator）给 Rust 带来了函数式（functional）编程的风格。</p> 
<pre><code class="language-rust">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    println!("Find the sum of all the squared odd numbers under 1000");
    let upper = 1000;

    // 命令式（imperative）的写法
    // 声明累加器变量
    let mut acc = 0;
    // 迭代：0，1, 2, ... 到无穷大
    for n in 0.. {
        // 数字的平方
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // 若大于上限则退出循环
            break;
        } else if is_odd(n_squared) {
            // 如果是奇数就计数
            acc += n_squared;
        }
    }
    println!("imperative style: {}", acc);

    // 函数式的写法
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n)             // 所有自然数取平方
            .take_while(|&amp;n| n &lt; upper) // 取小于上限的
            .filter(|&amp;n| is_odd(n))     // 取奇数
            .fold(0, |sum, i| sum + i); // 最后加起来
    println!("functional style: {}", sum_of_squared_odd_numbers);
}
</code></pre> 
<p><a href="https://rustwiki.org/zh-CN/core/option/enum.Option.html" rel="nofollow" title="Option">Option</a> 和 <a href="https://rustwiki.org/zh-CN/core/iter/trait.Iterator.html" rel="nofollow" title="迭代器">迭代器</a> 都实现了不少高阶函数。</p> 
<h4><strong>迭代器</strong>（<em>iterator</em>）</h4> 
<p><code>Option&lt;T&gt;</code> 上的 <code>unwrap_or_else</code> 方法的定义：</p> 
<pre><code class="language-rust">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre> 
<p><code>T</code> 是表示 <code>Option</code> 中 <code>Some</code> 成员中的值的类型的泛型。类型 <code>T</code> 也是 <code>unwrap_or_else</code> 函数的返回值类型：举例来说，在 <code>Option&lt;String&gt;</code> 上调用 <code>unwrap_or_else</code> 会得到一个 <code>String</code>。</p> 
<p>接着注意到 <code>unwrap_or_else</code> 函数有额外的泛型参数 <code>F</code>。 <code>F</code> 是 <code>f</code> 参数（即调用 <code>unwrap_or_else</code> 时提供的闭包）的类型。</p> 
<p>泛型 <code>F</code> 的 trait bound 是 <code>FnOnce() -&gt; T</code>，这意味着 <code>F</code> 必须能够被调用一次，没有参数并返回一个 <code>T</code>。在 trait bound 中使用 <code>FnOnce</code> 表示 <code>unwrap_or_else</code> 将最多调用 <code>f</code> 一次。在 <code>unwrap_or_else</code> 的函数体中可以看到，如果 <code>Option</code> 是 <code>Some</code>，<code>f</code> 不会被调用。如果 <code>Option</code> 是 <code>None</code>，<code>f</code> 将会被调用一次。由于所有的闭包都实现了 <code>FnOnce</code>，<code>unwrap_or_else</code> 能接收绝大多数不同类型的闭包，十分灵活。</p> 
<blockquote> 
 <p>注意：函数也可以实现所有的三种 <code>Fn</code> traits。如果我们要做的事情不需要从环境中捕获值，则可以在需要某种实现了 <code>Fn</code> trait 的东西时使用函数而不是闭包。举个例子，可以在 <code>Option&lt;Vec&lt;T&gt;&gt;</code> 的值上调用 <code>unwrap_or_else(Vec::new)</code> 以便在值为 <code>None</code> 时获取一个新的空的 vector。</p> 
</blockquote> 
<p>std 中闭包示例：<strong>迭代器</strong>（<em>iterator</em>）</p> 
<p>负责遍历序列中的每一项和决定序列何时结束的逻辑。迭代器是 <strong>惰性的</strong>（<em>lazy</em>），这意味着在调用方法使用迭代器之前它都不会有效果。</p> 
<ul><li><code>iter</code> 方法生成一个不可变引用的迭代器。如果希望迭代可变引用，则调用 <code>iter_mut</code> </li><li><code>into_iter </code>方法可以获取所有权并返回拥有所有权的迭代器。</li></ul> 
<p>示例：</p> 
<pre><code class="language-rust">fn main() {
    let v1 = vec![1, 2, 3];
    let v1_iter = v1.iter();
    for val in v1_iter {
        println!("Got: {}", val);
    }
}</code></pre> 
<pre><code class="language-rust">fn main() {
    let v1 = vec![1, 2, 3];
    let v1_iter = v1.iter();
    let total: i32 = v1_iter.sum();
    assert_eq!(total, 6);
}</code></pre> 
<p>sum 方法方法获取迭代器的所有权并反复调用 next 来遍历迭代器，因而会消费迭代器。当其遍历每一个项时，它将每一个项加总到一个总和并在迭代完成时返回总和。调用 <code>sum</code> 之后不再允许使用 <code>v1_iter</code> 因为调用 <code>sum</code> 时它会获取迭代器的所有权。</p> 
<pre><code class="language-rust">fn main() {
    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];
    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();
    assert_eq!(v2, vec![2, 3, 4]);
}</code></pre> 
<p> <code>map</code> 获取一个闭包，可以指定任何希望在遍历的每个元素上执行的操作。这是一个展示如何使用闭包来自定义行为同时又复用 <code>Iterator</code> trait 提供的迭代行为的绝佳例子。</p> 
<h4>发散函数：never type</h4> 
<p>发散函数（diverging function）被称为 "<strong>绝不会返回(never type)</strong>" 。 它们使用 <code>!</code> 标记，这是一个空类型(<em>empty type</em>)，因为它没有值。在函数从不返回的时候充当返回值。例如：这读 "<strong><span style="background-color:#ffd900;">函数 </span><code><span style="background-color:#ffd900;">bar</span></code><span style="background-color:#ffd900;"> 从不返回</span></strong>"，不能创建 <code>!</code> 类型的值，所以 <code>bar</code> 也不可能返回值。</p> 
<pre><code class="language-rust">fn bar() -&gt; ! {
    // --snip--
}</code></pre> 
<p>和所有其他类型相反，这个类型无法实例化，因为此类型可能具有的所有可能值的集合为空。 注意，它与 <code>()</code> 类型不同，后者只有一个可能的值。</p> 
<p>虽然返回值中没有信息，但此函数会照常返回。</p> 
<pre><code class="language-rust">fn some_fn() {
    ()
}

fn main() {
    let a: () = some_fn();
    println!("This function returns and you can see this line.")
}
</code></pre> 
<p>下面这个函数相反，这个函数永远不会将控制内容返回给调用者。</p> 
<pre><code class="language-rust">#![feature(never_type)]

fn main() {
    let x: ! = panic!("This call never returns.");
    println!("You will never see this line!");
}
</code></pre> 
<p>这种类型的主要优点是它可以被转换为任何其他类型，从而可以在需要精确类型的地方使用，例如在 <code>match</code> 匹配分支。</p> 
<pre><code class="language-rust">fn main() {
    fn sum_odd_numbers(up_to: u32) -&gt; u32 {
        let mut acc = 0;
        for i in 0..up_to {
            // 注意这个 match 表达式的返回值必须为 u32，
            // 因为 “addition” 变量是这个类型。
            let addition: u32 = match i%2 == 1 {
                // “i” 变量的类型为 u32，这毫无问题。
                true =&gt; i,
                // 另一方面，“continue” 表达式不返回 u32，但它仍然没有问题，
                // 因为它永远不会返回，因此不会违反匹配表达式的类型要求。
                false =&gt; continue,
            };
            acc += addition;
        }
        acc
    }
    println!("Sum of odd numbers up to 9 (excluding): {}", sum_odd_numbers(9));
}
</code></pre> 
<p></p> 
<h3>模块 ( 包 )、Crate</h3> 
<p>Rust 提供了一套强大的模块（module）系统，可以将代码按层次分成多个逻辑单元（模块），并管理这些模块之间的可见性（公有（public）或私有（private））。</p> 
<p>模块是 "<strong><span style="background-color:#ffd900;">项(item)</span></strong>" 的集合，项可以是：函数，结构体，trait，<code>impl</code> 块，甚至其它模块。</p> 
<ul><li><strong>私有 vs 公用：</strong>模块里的代码默认是私有，使用pub mod可以使模块变成公用。模块内部的成员前面加上pub也可以变成公用。结构体的字段默认私有，加上pub也可以变成共有</li><li><strong>use 关键字</strong>：将一个完整的路径绑定到一个新的名字，就相当于创建一个成员的快捷方式， <p>        //创建一个快捷方式，然后在作用域中只写Asparagus来使用该类型。<br>         use crate::garden::vegetables::Asparagus;<br>         // 将 `deeply::nested::function` 路径绑定到 `other_function`。<br>         use deeply::nested::function as other_function;</p> </li></ul> 
<p>模块的路径有两种形式：</p> 
<ul><li><strong>绝对路径</strong>（<em>absolute path</em>）是以 crate 根（root）开头的全路径；对于外部 crate 的代码，是以 crate 名开头的绝对路径，对于当前 crate 的代码，则以字面值 <code>crate</code> 开头。</li><li><strong>相对路径</strong>（<em>relative path</em>）从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块的标识符开头。</li></ul> 
<pre><code class="language-rust">fn function() {
    println!("called `function()`");
}

mod cool {
    pub fn function() {
        println!("called `cool::function()`");
    }
}

mod my {
    fn function() {
        println!("called `my::function()`");
    }
    
    mod cool {
        pub fn function() {
            println!("called `my::cool::function()`");
        }
    }
    
    pub fn indirect_call() {
        // 让我们从这个作用域中访问所有名为 `function` 的函数！
        print!("called `my::indirect_call()`, that\n&gt; ");
        
        // `self` 关键字表示当前的模块作用域——在这个例子是 `my`。
        // 调用 `self::function()` 和直接调用 `function()` 都得到相同的结果，
        // 因为他们表示相同的函数。
        self::function();
        function();
        
        // 我们也可以使用 `self` 来访问 `my` 内部的另一个模块：
        self::cool::function();
        
        // `super` 关键字表示父作用域（在 `my` 模块外面）。
        super::function();
        
        // 这将在 *crate* 作用域内绑定 `cool::function` 。
        // 在这个例子中，crate 作用域是最外面的作用域。
        {
            use crate::cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
</code></pre> 
<p>绝对路径和相对路径都后跟一个或多个由双冒号（<code>::</code>）分割的标识符。</p> 
<ul><li><strong>从 crate 根节点开始：</strong>当编译一个 crate，编译器首先在 <strong><span style="background-color:#ffd900;">crate 根文件</span></strong>（通常，对于一个库 crate 而言是 <strong><em><span style="background-color:#ffd900;">src/lib.rs</span></em></strong>，对于一个二进制 crate 而言是 <strong><em><span style="background-color:#ffd900;">src/main.rs</span></em></strong>）中寻找需要被编译的代码。</li><li><strong>声明模块</strong>: 在 crate 根文件中，你可以声明一个新模块；比如，你用<code>mod garden</code>声明了一个叫做<code>garden</code>的模块。编译器会在下列路径中寻找模块代码： 
  <ul><li>内联，在大括号中，当<code>mod garden</code>后方不是一个分号而是一个大括号</li><li>在文件 <em>src/garden.rs</em></li><li>在文件 <em>src/garden/mod.rs</em></li></ul></li><li><strong>声明子模块</strong>: 在除了 crate 根节点以外的其他文件中，你可以定义子模块。比如，你可能在<em>src/garden.rs</em>中定义了<code>mod vegetables;</code>。编译器会在以父模块命名的目录中寻找子模块代码： 
  <ul><li>内联，在大括号中，当<code>mod vegetables</code>后方不是一个分号而是一个大括号</li><li>在文件 <em>src/garden/vegetables.rs</em></li><li>在文件 <em>src/garden/vegetables/mod.rs</em></li></ul></li><li><strong>模块中的代码路径</strong>: 一旦一个模块是你 crate 的一部分，你可以在隐私规则允许的前提下，从同一个 crate 内的任意地方，通过代码路径引用该模块的代码。举例而言，一个 garden vegetables 模块下的<code>Asparagus</code>类型可以在<code>crate::garden::vegetables::Asparagus</code>被找到。</li></ul> 
<p></p> 
<h4>文件分层</h4> 
<p>模块可以分配到文件/目录的层次结构中。</p> 
<p class="img-center"><img alt="" height="132" src="https://images2.imgbox.com/86/76/i7UAN3ME_o.png" width="235"></p> 
<p>split.rs 的内容：</p> 
<pre><code>// 此声明将会查找名为 `my.rs` 或 `my/mod.rs` 的文件，并将该文件的内容放到
// 此作用域中一个名为 `my` 的模块里面。
mod my;

fn function() {
    println!("called `function()`");
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}
</code></pre> 
<p>my/mod.rs 的内容：</p> 
<pre><code class="language-rust">// 类似地，`mod inaccessible` 和 `mod nested` 将找到 `nested.rs` 和
// `inaccessible.rs` 文件，并在它们放到各自的模块中。
mod inaccessible;
pub mod nested;

pub fn function() {
    println!("called `my::function()`");
}

fn private_function() {
    println!("called `my::private_function()`");
}

pub fn indirect_access() {
    print!("called `my::indirect_access()`, that\n&gt; ");

    private_function();
}
</code></pre> 
<p>my/nested.rs 的内容：</p> 
<pre><code class="language-rust">pub fn function() {
    println!("called `my::nested::function()`");
}

#[allow(dead_code)]
fn private_function() {
    println!("called `my::nested::private_function()`");
}
</code></pre> 
<p>my/inaccessible.rs 的内容：</p> 
<pre><code class="language-rust">#[allow(dead_code)]
pub fn public_function() {
    println!("called `my::inaccessible::public_function()`");
}
</code></pre> 
<p>编译运行</p> 
<blockquote> 
 <p>$ rustc split.rs &amp;&amp; ./split<br> called `my::function()`<br> called `function()`<br> called `my::indirect_access()`, that<br> &gt; called `my::private_function()`<br> called `my::nested::function()`</p> 
</blockquote> 
<p></p> 
<h4>crate</h4> 
<ul><li><strong>crate ：</strong>crate（中文有 “包，包装箱” 之意）是 Rust 在编译时最小的代码单位。当调用 <code>rustc</code> 而不是 <code>cargo</code> 来编译<code>some_file.rs</code> 时，<code>some_file.rs</code> 被当作 <strong>crate 文件</strong>。如果 <code>some_file.rs</code> 里面含有 <code>mod</code> 声明，那么模块文件的内容将在编译之前被插入 crate 文件的相应声明处。换句话说，模块<strong>不会</strong>单独被编译，只有 crate 才会被编译。crate 可以编译成二进制可执行文件（binary）或库文件（library）。默认情况下，<code>rustc</code> 将从 crate 产生二进制可执行文件。这种行为可以通过 <code>rustc</code> 的选项 <code>--crate-type</code> 重载。</li><li><strong>Crates</strong> ：一个模块的树形结构，它形成了库或二进制项目。</li></ul> 
<p></p> 
<h4>库、使用库</h4> 
<p>创建一个库</p> 
<pre><code class="language-rust">pub fn public_function() {
    println!("called rary's `public_function()`");
}

fn private_function() {
    println!("called rary's `private_function()`");
}

pub fn indirect_access() {
    print!("called rary's `indirect_access()`, that\n&gt; ");

    private_function();
}
</code></pre> 
<p>编译：</p> 
<blockquote> 
 <p>$ rustc --crate-type=lib rary.rs<br> $ ls lib*<br> library.rlib</p> 
</blockquote> 
<p>默认情况下，库会使用 crate 文件的名字，前面加上 “lib” 前缀，但这个默认名称可以使用 <a href="https://rustwiki.org/zh-CN/rust-by-example/attribute/crate.html" rel="nofollow" title="crate_name 属性">crate_name 属性</a> 覆盖。</p> 
<p>使用库，可以使用 <code>rustc</code> 的 <code>--extern</code> 选项</p> 
<pre><code class="language-rust">// extern crate rary; // 在 Rust 2015 版或更早版本需要这个导入语句

fn main() {
    rary::public_function();

    // 报错！ `private_function` 是私有的
    //rary::private_function();

    rary::indirect_access();
}
</code></pre> 
<blockquote> 
 <p># library.rlib 是已编译好的库的路径，这里假设它在同一目录下：<br> $ rustc executable.rs --extern rary=library.rlib --edition=2018 &amp;&amp; ./executable <br> called rary's `public_function()`<br> called rary's `indirect_access()`, that<br> &gt; called rary's `private_function()`</p> 
</blockquote> 
<p></p> 
<h4>cargo</h4> 
<p><code>cargo</code> 是官方的 Rust 包管理工具。<code>cargo</code> 还支持<a href="https://doc.rust-lang.org/cargo/guide/project-layout.html" rel="nofollow" title="更多功能">更多功能</a>，如基准测试，测试和示例</p> 
<p>功能包括：</p> 
<ul><li>依赖管理和与 <a href="https://crates.io/" rel="nofollow" title="crates.io">crates.io</a>（官方 Rust 包注册服务）集成</li><li>方便的单元测试</li><li>方便的基准测试</li></ul> 
<p>介绍一些快速入门的基础知识，在 <a href="https://doc.rust-lang.org/cargo/" rel="nofollow" title="cargo 官方手册">cargo 官方手册</a>中找到详细内容。</p> 
<p>创建一个新的 Rust 项目：</p> 
<blockquote> 
 <p># 二进制可执行文件<br> cargo new foo</p> 
 <p class="img-center"><img alt="" height="83" src="https://images2.imgbox.com/33/1c/UIi5fDxV_o.png" width="184"></p> 
 <p># 或者库<br> cargo new --lib foo</p> 
</blockquote> 
<p><code>main.rs</code> 是新项目的入口源文件——这里没什么新东西。 <code>Cargo.toml</code> 是本项目（<code>foo</code>）的 <code>cargo</code> 的配置文件。 浏览 <code>Cargo.toml</code> 文件，将看到类似以下的的内容：</p> 
<p class="img-center"><img alt="" height="118" src="https://images2.imgbox.com/c1/bd/n9e9dYUB_o.png" width="220"></p> 
<p>package 节点</p> 
<ul><li>name 字段表明项目的名称。 如果您发布 crate，那么 crates.io 将使用此字段标明的名称。 这也是编译时输出的二进制可执行文件的名称。</li><li>version 字段是使用语义版本控制（Semantic Versioning）的 crate 版本号。</li><li>authors 字段表明发布 crate 时的作者列表。</li></ul> 
<p>dependencies 节点是为项目添加 第三方包(模块) 依赖。</p> 
<p><code>cargo</code> 还支持<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html" rel="nofollow" title="其他类型的依赖">其他类型的依赖</a>。 下面是一个简单的示例：</p> 
<p class="img-center"><img alt="" height="173" src="https://images2.imgbox.com/95/9b/Ghpm2DM7_o.png" width="652"></p> 
<p>在项目目录中的任何位置（包括子目录！）执行 cargo build 都可以下载依赖并构建项目。<code>cargo run</code> 是构建和运行</p> 
<p>测试。可以将单元测试放在需要测试的模块中，并将集成测试放在源码中 <code>tests/</code> 目录中：</p> 
<p class="img-center"><img alt="" height="137" src="https://images2.imgbox.com/3d/95/tJH6RBcR_o.png" width="263"></p> 
<p>tests 目录下的每个文件都是一个单独的集成测试。cargo 很自然地提供了一种便捷的方法来运行所有测试：<strong><span style="background-color:#ffd900;">cargo test</span></strong></p> 
<p>还可以运行如下测试，其中名称匹配一个模式：cargo test test_foo</p> 
<p>需要注意：<code>cargo</code> 可能同时进行多项测试，因此请确保它们不会相互竞争。例如，如果它们都输出到文件，则应该将它们写入不同的文件。</p> 
<p>编译之前执行一些先决代码。比如代码生成或者需要编译的一些本地代码。为了解决这个问题，我们构建了 cargo 可以运行的脚本。要向包中添加构建脚本，可以在 <code>Cargo.toml</code> 中指定它，如下所示：</p> 
<p class="img-center"><img alt="" height="61" src="https://images2.imgbox.com/1d/fe/mgm3WVAA_o.png" width="192"></p> 
<p>这里 cargo 将在项目目录中优先查找 <code>build.rs</code> 文件。构建脚本只是另一个 Rust 文件，此文件将在编译包中的任何其他内容之前，优先进行编译和调用。 因此，此文件可实现满足 crate 的先决条件。</p> 
<p></p> 
<h3>属性 #[attribute(value)]</h3> 
<p>属性是应用于某些模块、crate 或项的元数据（metadata）。这元数据可以用来：</p> 
<ul><li><a href="https://rustwiki.org/zh-CN/rust-by-example/attribute/cfg.html" rel="nofollow" title="条件编译代码">条件编译代码</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/attribute/crate.html" rel="nofollow" title="设置 crate 名称、版本和类型（二进制文件或库）">设置 crate 名称、版本和类型（二进制文件或库）</a></li><li>禁用 <a href="https://en.wikipedia.org/wiki/Lint_%28software%29" rel="nofollow" title="lint">lint</a> （警告）</li><li>启用编译器的特性（宏、全局导入（glob import）等）</li><li>链接到一个非 Rust 语言的库</li><li>标记函数作为单元测试</li><li>标记函数作为基准测试的某个部分</li></ul> 
<p>当属性作用于整个 crate 时，它们的语法为 <code>#![crate_attribute]</code>，当它们用于模块或项时，语法为 <code>#[item_attribute]</code>（注意少了感叹号 <code>!</code>）。</p> 
<p>属性可以接受参数，有不同的语法形式：</p> 
<ul><li><code>#[attribute = "value"]</code></li><li><code>#[attribute(key = "value")]</code></li><li><code>#[attribute(value)]</code></li></ul> 
<p>属性可以多个值，它们可以分开到多行中：</p> 
<blockquote> 
 <p>#[attribute(value, value2)]</p> 
 <p>#[attribute(value, value2, value3,<br>             value4, value5)]</p> 
</blockquote> 
<h4>debug 属性</h4> 
<p><code>#[derive(Debug)]</code> 是一个属性（attribute），用于自动生成调试输出所需的 <code>Debug</code> trait 的实现。通过添加 <code>#[derive(Debug)]</code> 属性，你可以方便地为结构体或枚举类型派生 <code>Debug</code> trait，从而在调试过程中打印出该类型的值。</p> 
<pre><code class="language-rust">#[derive(Debug)] // 添加 #[derive(Debug)] 属性
#[allow(dead_code)]
struct MyStruct {
    field1: i32,
    field2: String,
}

fn main() {
    let my_struct = MyStruct {
        field1: 42,
        field2: String::from("Hello, World!"),
    };

    println!("{:?}", my_struct); // 打印结构体的调试输出
}
</code></pre> 
<h4>dead_code (死代码)</h4> 
<p>编译器提供了 <code>dead_code</code>（死代码，无效代码）<a href="https://en.wikipedia.org/wiki/Lint_%28software%29" rel="nofollow" title="lint">lint</a>，这会对未使用的函数产生警告。可以用一个<strong>属性</strong>来禁用这个 lint。</p> 
<pre><code class="language-rust">fn used_function() {}

// `#[allow(dead_code)]` 属性可以禁用 `dead_code` lint
#[allow(dead_code)]
fn unused_function() {}

fn noisy_unused_function() {}
// 改正 ^ 增加一个属性来消除警告

fn main() {
    used_function();
}
</code></pre> 
<h4>条件编译 cfg</h4> 
<p>条件编译可能通过两种不同的操作符实现：</p> 
<ul><li><code>cfg</code> 属性：在属性位置中使用 <code>#[cfg(...)]</code></li><li><code>cfg!</code> 宏：在布尔表达式中使用 <code>cfg!(...)</code></li></ul> 
<p>两种形式使用的参数语法都相同。</p> 
<pre><code class="language-rust">// 这个函数仅当目标系统是 Linux 的时候才会编译
#[cfg(target_os = "linux")]
fn are_you_on_linux() {
    println!("You are running linux!")
}

// 而这个函数仅当目标系统 **不是** Linux 时才会编译
#[cfg(not(target_os = "linux"))]
fn are_you_on_linux() {
    println!("You are *not* running linux!")
}

fn main() {
    are_you_on_linux();
    
    println!("Are you sure?");
    if cfg!(target_os = "linux") {
        println!("Yes. It's definitely linux!");
    } else {
        println!("Yes. It's definitely *not* linux!");
    }
}
</code></pre> 
<p>参考：<a href="https://rustwiki.org/zh-CN/reference/conditional-compilation.html" rel="nofollow" title="引用">引用</a>, <a href="https://rustwiki.org/zh-CN/std/macro.cfg!.html" rel="nofollow" title="cfg!">cfg!</a>, 和 <a href="https://rustwiki.org/zh-CN/rust-by-example/macros.html" rel="nofollow" title="宏">宏</a>.</p> 
<p></p> 
<h3>错误处理</h3> 
<p>在 Rust 中有多种处理错误的方式，使用场景也不尽相同。总的来说：</p> 
<ul><li><code>panic</code> 主要用于测试，以及处理不可恢复的错误。当执行 panic!宏 时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。</li><li><code>Option</code> 类型是为了值是可选的、或者缺少值并不是错误的情况准备的。当处理 <code>Option</code> 时，<code>unwrap</code> 可用于原型开发，也可以用于能够确定 <code>Option</code> 中一定有值 的情形。然而 <code>expect</code> 更有用，因为它允许你指定一条错误信息，以免万一还是出现 了错误。</li><li> <code>Result</code> 用于当错误有可能发生，且应当由调用者处理。也可以 <code>unwrap</code> 然后 使用 <code>expect</code></li></ul> 
<p>有关错误处理的更多内容，可参考<a href="https://rustwiki.org/zh-CN/book/ch09-00-error-handling.html" rel="nofollow" title="官方文档">官方文档</a>的错误处理的章节。</p> 
<p></p> 
<h4>panic (恐慌、忙乱、错误)</h4> 
<p>最简单的错误处理机制就是 <code>panic</code>。它会打印一个错误消息，开始回退（unwind）任务且通常会退出程序。在回退栈的同时，运行时将会释放该线程所<strong>拥有</strong>的所有资源，这是通过调用线程中所有对象的析构函数完成的。</p> 
<pre><code class="language-rust">fn give_princess(gift: &amp;str) {
    // 公主讨厌蛇，所以如果公主表示厌恶的话我们要停止！
    if gift == "snake" { panic!("AAAaaaaa!!!!"); }

    println!("I love {}s!!!!!", gift);
}

fn main() {
    give_princess("teddy bear");
    give_princess("snake");
}
</code></pre> 
<p>公主收到蛇这件不合适的礼物时，程序直接 panic。但是，如果公主期待收到礼物，却没收到呢？<br> 可以检查空字符串（""），这就是下面的 Option</p> 
<p></p> 
<h4>Option&lt;T&gt;</h4> 
<p>标准库（<code>std</code>）中有个叫做 <code>Option&lt;T&gt;</code>（option 中文意思是 “选项”）的枚举类型，用于有 “不存在” 的可能性的情况。它表现为以下两个 “option”（选项）中的一个：</p> 
<ul><li><code>Some(T)</code>：找到一个属于 <code>T</code> 类型的元素</li><li><code>None</code>：找不到相应元素</li></ul> 
<p>这些选项可以通过 <code>match</code> 显式地处理，或使用 <code>unwrap</code> 隐式地处理。隐式处理要么返回 <code>Some</code> 内部的元素，要么就 <code>panic</code>。</p> 
<pre><code class="language-rust">// 平民（commoner）们见多识广，收到什么礼物都能应对。
// 所有礼物都显式地使用 `match` 来处理。
fn give_commoner(gift: Option&lt;&amp;str&gt;) {
    // 指出每种情况下的做法。
    match gift {
        Some("snake") =&gt; println!("Yuck! I'm throwing that snake in a fire."),
        Some(inner)   =&gt; println!("{}? How nice.", inner),
        None          =&gt; println!("No gift? Oh well."),
    }
}

// 养在深闺人未识的公主见到蛇就会 `panic`（恐慌）。
// 这里所有的礼物都使用 `unwrap` 隐式地处理。
fn give_princess(gift: Option&lt;&amp;str&gt;) {
    // `unwrap` 在接收到 `None` 时将返回 `panic`。
    let inside = gift.unwrap();
    if inside == "snake" { panic!("AAAaaaaa!!!!"); }

    println!("I love {}s!!!!!", inside);
}

fn main() {
    let food  = Some("chicken");
    let snake = Some("snake");
    let void  = None;

    give_commoner(food);
    give_commoner(snake);
    give_commoner(void);

    let bird = Some("robin");
    let nothing = None;

    give_princess(bird);
    give_princess(nothing);
}
</code></pre> 
<p></p> 
<h4>unwrap 和 expect</h4> 
<p><code>unwrap</code> 和 <code>expect</code> 是用于从 <code>Result</code> 或 <code>Option</code> 类型中提取值的方法。<code>unwrap</code> 方法会尝试将一个 <code>Result</code> 或 <code>Option</code> 对象中的值提取出来。如果对象是一个 <code>Ok</code> 或 <code>Some</code>，则 <code>unwrap</code> 方法返回该值；否则，它会触发 panic 异常并终止程序的执行。<code>expect</code> 用来在触发了 panic 时并打印出提供的错误消息。</p> 
<pre><code class="language-rust">fn func_1() {
    let x: Result&lt;i32, &amp;str&gt; = Ok(42);
    let val = x.unwrap(); // 正常情况下，val 的值为 42

    let y: Result&lt;i32, &amp;str&gt; = Err("error message");
    let val = y.unwrap(); // 这里会触发 panic
    println!("测试函数 func_1");
}

fn func_2() {
    let x: Result&lt;i32, &amp;str&gt; = Ok(42);
    let val = x.expect("提取值失败"); // 正常情况下，val 的值为 42

    let y: Result&lt;i32, &amp;str&gt; = Err("error message");
    let val = y.expect("提取值失败"); // 这里会触发 panic，并打印出 "提取值失败"
    println!("测试函数 func_2");
}

fn main() {
    // func_1();
    func_2();
}</code></pre> 
<p>示例</p> 
<pre><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("Problem creating the file: {:?}", e),
            },
            other_error =&gt; {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
</code></pre> 
<p>自己不处理错误并抛出错误，而是让调用者处理错误。这被称为 <strong>传播</strong>（<em>propagating</em>）错误。因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误。</p> 
<p>示例：</p> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
    use std::fs::File;
    use std::io::{self, Read};

    fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
        let username_file_result = File::open("hello.txt");

        let mut username_file = match username_file_result {
            Ok(file) =&gt; file,
            Err(e) =&gt; return Err(e),
        };

        let mut username = String::new();

        match username_file.read_to_string(&amp;mut username) {
            Ok(_) =&gt; Ok(username),
            Err(e) =&gt; Err(e),
        }
    }
}
</code></pre> 
<h4> x?、Option.map、and_then</h4> 
<p>在Rust中，<code>x?</code>是一种简洁的错误处理和传播机制，通常用于处理 <code>Result</code> 或 <code>Option</code> 类型的值。可用于函数中的返回类型为 <code>Result</code> 或 <code>Option</code> 的情况。</p> 
<p><code>x?</code>作用是将被包裹的 <code>Result</code> 或 <code>Option</code> 值进行解包，并根据其结果进行处理。</p> 
<ul><li>如果结果是 <code>Ok</code> 或 <code>Some</code>，则将包裹的值返回；</li><li>如果结果是 <code>Err</code> 或 <code>None</code>，则将整个表达式的结果设定为 <code>Err</code> 或 <code>None</code>，并将错误或空值传播到调用方。</li></ul> 
<p>可以使用 <code>match</code> 语句来解开 <code>Option</code>，但使用 <code>?</code> 运算符通常会更容易。对<code>x?</code>表达式求值将返回底层值，否则无论函数是否正在执行都将终止且返回 <code>None</code>。</p> 
<pre><code class="language-rust">use rand::distributions::WeightedError::NoItem;

fn next_birthday(current_age: Option&lt;u8&gt;) -&gt; Option&lt;String&gt; {
    // 如果 `current_age` 是 `None`，这将返回 `None`。
    // 如果 `current_age` 是 `Some`，内部的 `u8` 将赋值给 `next_age`。
    let next_age: u8 = current_age?;
    Some(format!("Next year I will be {}", next_age))
}
fn main() {
    let ret_val = next_birthday(None);
    if let Some(s) = ret_val {
        println!("{:?}", s);
    } else {
        println!("None");
    }
}</code></pre> 
<p>对 Result&lt;T, E&gt; 使用 x? 表达式 如下：</p> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
}
</code></pre> 
<p>? 问号 运算符 也可以 链式调用</p> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
    use std::fs::File;
    use std::io::{self, Read};

    fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
        let mut username = String::new();
        File::open("hello.txt")?.read_to_string(&amp;mut username)?;
        Ok(username)
    }
}
</code></pre> 
<blockquote> 
 <p><code>?</code> 运算符只能被用于返回值与 <code>?</code> 作用的值相兼容的函数。因为 <code>?</code> 运算符被定义为从函数中提早返回一个值。<strong>总结：</strong><span style="color:#fe2c24;"><strong>? 运算符 只能在返回 <code>Result</code> 或者其它实现了 <code>FromResidual</code> 的类型的函数中使用 <code>?</code> 运算符。</strong></span>为了修复这个错误，有两个选择。一个是，如果没有限制的话将函数的返回值改为 <code>Result&lt;T, E&gt;</code>。另一个是使用 <code>match</code> 或 <code>Result&lt;T, E&gt;</code> 的方法中合适的一个来处理 <code>Result&lt;T, E&gt;</code>。 <code>?</code> 也可用于 <code>Option&lt;T&gt;</code> 值。如同对 <code>Result</code> 使用 <code>?</code> 一样，只能在返回 <code>Option</code> 的函数中对 <code>Option</code> 使用 <code>?</code>。在 <code>Option&lt;T&gt;</code> 上调用 <code>?</code> 运算符的行为与 <code>Result&lt;T, E&gt;</code> 类似：如果值是 <code>None</code>，此时 <code>None</code> 会从函数中提前返回。如果值是 <code>Some</code>，<code>Some</code> 中的值作为表达式的返回值同时函数继续。</p> 
 <p>use std::fs::File;</p> 
 <p>fn main() {<!-- --><br>     let greeting_file = File::open("hello.txt")?;<br> }</p> 
 <p>代码打开一个文件，这可能会失败。<code>?</code> 运算符作用于 <code>File::open</code> 返回的 <code>Result</code> 值，不过 <code>main</code> 函数的返回类型是 <code>()</code> 而不是 <code>Result</code>。当编译这段代码会报错。</p> 
 <p><code>Box&lt;dyn Error&gt;</code> 类型是一个 <strong>trait 对象。</strong>目前可以将 <code>Box&lt;dyn Error&gt;</code> 理解为 “任何类型的错误”。在返回 <code>Box&lt;dyn Error&gt;</code> 错误类型 <code>main</code> 函数中对 <code>Result</code> 使用 <code>?</code> 是允许的，因为它允许任何 <code>Err</code> 值提前返回。即便 <code>main</code> 函数体从来只会返回 <code>std::io::Error</code> 错误类型，通过指定 <code>Box&lt;dyn Error&gt;</code>，这个签名也仍是正确的，甚至当 <code>main</code> 函数体中增加更多返回其他错误类型的代码时也是如此。</p> 
 <p>use std::error::Error;<br> use std::fs::File;</p> 
 <p>fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {<!-- --><br>     let greeting_file = File::open("hello.txt")?;</p> 
 <p>    Ok(())<br> }</p> 
</blockquote> 
<p>示例</p> 
<pre><code class="language-rust">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        // --snip--

        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("The secret number will be between 1 and 100.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}
</code></pre> 
<p><code>Option</code> 有一个内置方法 <code>map()</code>，这个组合算子可用于 <code>Some -&gt; Some</code> 和 <code>None -&gt; None</code> 这样的简单映射。多个不同的 <code>map()</code> 调用可以串起来，这样更加灵活。</p> 
<p>参考：<a href="https://rustwiki.org/zh-CN/rust-by-example/fn/closures.html" rel="nofollow" title="闭包">闭包</a>, <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html" rel="nofollow" title="Option">Option</a>, 和 <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html#method.map" rel="nofollow" title="Option::map()">Option::map()</a></p> 
<pre><code class="language-rust">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Banana }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// 削皮。如果没有食物，就返回 `None`。否则返回削好皮的食物。
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// 切食物。如果没有食物，就返回 `None`。否则返回切好的食物。
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// 烹饪食物。这里，我们使用 `map()` 来替代 `match` 以处理各种情况。
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// 这个函数会完成削皮切块烹饪一条龙。我们把 `map()` 串起来，以简化代码。
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// 在尝试吃食物之前确认食物是否存在是非常重要的！
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!("Mmm. I love {:?}", food),
        None       =&gt; println!("Oh no! It wasn't edible."),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let cooked_apple = cook(chop(peel(apple)));
    eat(cooked_apple);
    println!("######################################################");
    let banana = Some(Food::Banana);
    // 现在让我们试试看起来更简单的 `process()`。
    let cooked_banana = process(banana);
    eat(cooked_banana);
}
</code></pre> 
<p><code>map()</code> 以链式调用的方式来简化 <code>match</code> 语句。然而，如果以返回类型是 <code>Option&lt;T&gt;</code> 的函数作为 <code>map()</code> 的参数，会导致出现嵌套形式 <code>Option&lt;Option&lt;T&gt;&gt;</code>。这样多层串联调用就会变得混乱。所以有必要引入 <code>and_then()</code>，在某些语言中它叫做 flatmap。<code>and_then()</code> 使用被 <code>Option</code> 包裹的值来调用其输入函数并返回结果。 如果 <code>Option</code> 是 <code>None</code>，那么它返回 <code>None</code>。</p> 
<pre><code class="language-rust">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// 我们没有制作寿司所需的原材料（ingredient）（有其他的原材料）。
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// 我们拥有全部食物的食谱，除了法国蓝带猪排（Cordon Bleu）的。
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}


// 要做一份好菜，我们需要原材料和食谱。
// 我们可以借助一系列 `match` 来表达这个逻辑：
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_ingredients(food) {
        None       =&gt; None,
        Some(food) =&gt; match have_recipe(food) {
            None       =&gt; None,
            Some(food) =&gt; Some(food),
        },
    }
}

// 也可以使用 `and_then()` 把上面的逻辑改写得更紧凑：
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_ingredients(food).and_then(have_recipe)
}

fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) =&gt; println!("Yay! On {:?} we get to eat {:?}.", day, food),
        None       =&gt; println!("Oh no. We don't get to eat on {:?}?", day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
</code></pre> 
<p><code>and_then()</code> 使用被 <code>Option</code> 包裹的值来调用其输入函数并返回结果。 如果 <code>Option</code> 是 <code>None</code>，那么它返回 <code>None</code>。</p> 
<p><code>?</code> 之前被解释为要么 <code>unwrap</code>，要么 <code>return Err(err)</code>，这只是在大多数情况下是正确的。<code>?</code> 实际上是指 <code>unwrap</code> 或 <code>return Err(From::from(err))</code>。由于 <code>From::from</code> 是不同类型之间的转换工具，也就是说，如果在错误可转换成返回类型地方使用 <code>?</code>，它将自动转换成返回类型。</p> 
<p>调用 <code>parse</code> 后总是立即将错误从标准库的错误 <code>map</code>（映射）到装箱错误。</p> 
<blockquote> 
 <p>.and_then(|s| s.parse::&lt;i32&gt;()<br>     .map_err(|e| e.into())</p> 
 <p>因为这个操作很简单常见，如果有省略写法就好了。遗憾的是 <code>and_then</code> 不够灵活，所以实现不了这样的写法。不过，我们可以使用 <code>?</code> 来代替它。</p> 
</blockquote> 
<p>使用 <code>?</code> 重写之前的例子。重写后，只要为我们的错误类型实现 <code>From::from</code>，就可以不再使用 <code>map_err</code>。</p> 
<pre><code class="language-rust">use std::error;
use std::fmt;

// 为 `Box&lt;error::Error&gt;` 取别名。
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "invalid first item to double")
    }
}

impl error::Error for EmptyVec {}

// 这里的结构和之前一样，但是这次没有把所有的 `Result` 和 `Option` 串起来，
// 而是使用 `?` 立即得到内部值。
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;
    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!("The first doubled is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre> 
<p>参考：<a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html" rel="nofollow" title="From::from">From::from</a> 和 <a href="https://rustwiki.org/zh-CN/reference/expressions/operator-expr.html#%E9%97%AE%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow" title="?">?</a></p> 
<p></p> 
<h4>只 unwrap 且避免产生 panic</h4> 
<p>对 <code>unwrap</code> 的错误处理都在强迫我们一层层地嵌套，然而我们只是想把里面的变量拿出来。<code>?</code> 正是为这种情况准备的。</p> 
<p>当找到一个 <code>Err</code> 时，可以采取两种行动：</p> 
<ol><li><code>panic!</code>，不过我们已经决定要尽可能避免 panic 了。</li><li>返回它，因为 <code>Err</code> 就意味着它已经不能被处理了。</li></ol> 
<p>? 几乎就等于一个会返回 Err 而不是 panic 的 unwrap。</p> 
<p>更多细节请看<a href="https://rustwiki.org/zh-CN/rust-by-example/error/multiple_error_types/reenter_question_mark.html" rel="nofollow" title="? 的更多用法">? 的更多用法</a>。</p> 
<pre><code class="language-rust">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = first_number_str.parse::&lt;i32&gt;()?;
    let second_number = second_number_str.parse::&lt;i32&gt;()?;

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!("n is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    print(multiply("10", "2"));
    print(multiply("t", "2"));
}
</code></pre> 
<h4>try! 宏</h4> 
<p>在 <code>?</code> 出现以前，相同的功能是使用 <code>try!</code> 宏完成的。现在推荐使用 <code>?</code> 运算符，但是在老代码中仍然会看到 <code>try!</code>。</p> 
<p></p> 
<p></p> 
<h4>Result&lt;T，E&gt;、unwrap()</h4> 
<p>查阅<a href="https://rustwiki.org/zh-CN/std/result/index.html" rel="nofollow" title="文档">文档</a>，里面有很多匹配/组合 <code>Result</code> 的方法。</p> 
<p><code>Result&lt;T，E&gt;</code> 可以有两个结果的其中一个：</p> 
<ul><li><code>Ok&lt;T&gt;</code>：找到 <code>T</code> 元素，并包装操作返回的 <code>value</code>（<code>value</code> 拥有 <code>T</code> 类型）。</li><li><code>Err&lt;E&gt;</code>：找到 <code>E</code> 元素，<code>E</code> 即表示错误的类型。</li></ul> 
<p>按照约定，预期结果是 “Ok”，而意外结果是 “Err”。</p> 
<p><code>Result</code> 有很多类似 <code>Option</code> 的方法。例如 <code>unwrap()</code>，它要么举出元素 <code>T</code>，要么就 <code>panic</code>。</p> 
<pre><code class="language-rust">fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; i32 {
    // 我们试着用 `unwrap()` 把数字放出来。它会咬我们一口吗？
    let first_number = first_number_str.parse::&lt;i32&gt;().unwrap();
    let second_number = second_number_str.parse::&lt;i32&gt;().unwrap();
    first_number * second_number
}

fn main() {
    let twenty = multiply("10", "2");
    println!("double is {}", twenty);

    let tt = multiply("t", "2");
    println!("double is {}", tt);
}
</code></pre> 
<p>在失败的情况下，<code>parse()</code> 产生一个错误，留给 <code>unwrap()</code> 来解包并产生 <code>panic</code>。另外，<code>panic</code> 会退出我们的程序，并提供一个让人很不爽的错误消息。</p> 
<p>为了改善错误消息的质量，我们应该更具体地了解返回类型并考虑显式地处理错误。</p> 
<p>为了确定 <code>Err</code> 的类型，我们可以用 <a href="https://rustwiki.org/zh-CN/std/primitive.str.html#method.parse" rel="nofollow" title="parse()">parse()</a> 来试验。Rust 已经为 <a href="https://rustwiki.org/zh-CN/std/primitive.i32.html" rel="nofollow" title="i32">i32</a> 类型使用 <a href="https://rustwiki.org/zh-CN/std/str/trait.FromStr.html" rel="nofollow" title="FromStr">FromStr</a> trait 实现了 <code>parse()</code>。结果表明，这里的 <code>Err</code> 类型被指定为 <a href="https://rustwiki.org/zh-CN/std/num/struct.ParseIntError.html" rel="nofollow" title="ParseIntError">ParseIntError</a>。</p> 
<p>如何确定 <code>Err</code> 的类型，可以用间接的方法。代码如下：</p> 
<pre><code class="language-rust">fn main () {
    let i: () = "t".parse::&lt;i32&gt;();
}</code></pre> 
<p>由于不可能把 <code>Result</code> 类型赋给单元类型变量 <code>i</code>，编译器会提示我们：</p> 
<p>note: expected type `()`<br>          found type `std::result::Result&lt;i32, std::num::ParseIntError&gt;`</p> 
<p>这样就知道了 <code>parse&lt;i32&gt;</code> 函数的返回类型详情。</p> 
<pre><code class="language-rust">// use std::num::ParseIntError;
// 
// // 修改了上一节中的返回类型，现在使用模式匹配而不是 `unwrap()`。
// fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
//     match first_number_str.parse::&lt;i32&gt;() {
//         Ok(first_number)  =&gt; {
//             match second_number_str.parse::&lt;i32&gt;() {
//                 Ok(second_number)  =&gt; {
//                     Ok(first_number * second_number)
//                 },
//                 Err(e) =&gt; Err(e),
//             }
//         },
//         Err(e) =&gt; Err(e),
//     }
// }
// 
// fn print(result: Result&lt;i32, ParseIntError&gt;) {
//     match result {
//         Ok(n)  =&gt; println!("n is {}", n),
//         Err(e) =&gt; println!("Error: {}", e),
//     }
// }
// 
// fn main() {
//     // 这种情形下仍然会给出正确的答案。
//     let twenty = multiply("10", "2");
//     print(twenty);
// 
//     // 这种情况下就会提供一条更有用的错误信息。
//     let tt = multiply("t", "2");
//     print(tt);
// }

use std::num::ParseIntError;

// 就像 `Option` 那样，我们可以使用 `map()` 之类的组合算子。
// 除去写法外，这个函数与上面那个完全一致，它的作用是：
// 如果值是合法的，计算其乘积，否则返回错误。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!("n is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    // 这种情况下仍然会给出正确的答案。
    let twenty = multiply("10", "2");
    print(twenty);

    // 这种情况下就会提供一条更有用的错误信息。
    let tt = multiply("t", "2");
    print(tt);
}
</code></pre> 
<p></p> 
<h4>遍历 Result</h4> 
<pre><code class="language-rust">fn main() {
    let strings = vec!["tofu", "93", "18"];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!("Results: {:?}", numbers);
}
</code></pre> 
<p>使用 filter_map() 忽略失败的项。filter_map 会调用一个函数，过滤掉为 None 的所有结果。</p> 
<pre><code class="language-rust">fn main() {
    let strings = vec!["tofu", "93", "18"];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .filter_map(|s| s.parse::&lt;i32&gt;().ok())
        .collect();
    println!("Results: {:?}", numbers);
}
</code></pre> 
<p>使用 collect() 使整个操作失败。Result 实现了 FromIter，因此结果的向量（Vec&lt;Result&lt;T, E&gt;&gt;）可以被转换成结果包裹着向量（Result&lt;Vec&lt;T&gt;, E&gt;）。一旦找到一个 Result::Err ，遍历就被终止。</p> 
<pre><code class="language-rust">fn main() {
    let strings = vec!["tofu", "93", "18"];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!("Results: {:?}", numbers);
}
</code></pre> 
<p>同样的技巧可以对 <code>Option</code> 使用。</p> 
<p>使用 Partition() 收集所有合法的值与错误</p> 
<pre><code class="language-rust">fn main() {
    let strings = vec!["tofu", "93", "18"];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!("Numbers: {:?}", numbers);
    println!("Errors: {:?}", errors);
}
</code></pre> 
<p>会发现所有东西还在 <code>Result</code> 中保存着。要取出它们，需要一些模板化的代码。</p> 
<pre><code class="language-rust">fn main() {
    let strings = vec!["tofu", "93", "18"];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!("Numbers: {:?}", numbers);
    println!("Errors: {:?}", errors);
}
</code></pre> 
<p></p> 
<p></p> 
<h4>提前 return</h4> 
<p>另一种处理错误的方式是使用 <code>match</code> 语句和<strong>提前返回</strong>（early return）的结合。也就是说，如果发生错误，我们可以停止函数的执行然后返回错误。</p> 
<pre><code class="language-rust">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; first_number,
        Err(e) =&gt; return Err(e),
    };

    let second_number = match second_number_str.parse::&lt;i32&gt;() {
        Ok(second_number)  =&gt; second_number,
        Err(e) =&gt; return Err(e),
    };

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!("n is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    print(multiply("10", "2"));
    print(multiply("t", "2"));
}
</code></pre> 
<p></p> 
<h4>处理多种错误类型 (Result、Option 混合)</h4> 
<p>有时 <code>Option</code> 需要和 <code>Result</code> 进行交互，或是 <code>Result&lt;T, Error1&gt;</code> 需要和 <code>Result&lt;T, Error2&gt;</code> 进行交互。在这类情况下，我们想要以一种方式来管理不同的错误类型，使得它们可组合且易于交互。</p> 
<p>示例：<code>unwrap</code> 的两个实例生成了不同的错误类型。<code>Vec::first</code> 返回一个 <code>Option</code>，而 <code>parse::&lt;i32&gt;</code> 返回一个 <code>Result&lt;i32, ParseIntError&gt;</code>：</p> 
<p>示例：</p> 
<pre><code class="language-rust">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // 生成错误 1
    2 * first.parse::&lt;i32&gt;().unwrap() // 生成错误 2
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];
    
    println!("The first doubled is {}", double_first(numbers));
    
    println!("The first doubled is {}", double_first(empty));
    // 错误1：输入 vector 为空
    
    println!("The first doubled is {}", double_first(strings));
    // 错误2：此元素不能解析成数字
}
</code></pre> 
<p>处理混合错误类型的最基本的手段就是让它们互相包含。</p> 
<pre><code class="language-rust">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Option&lt;Result&lt;i32, ParseIntError&gt;&gt; {
    vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    })
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    println!("The first doubled is {:?}", double_first(numbers));

    println!("The first doubled is {:?}", double_first(empty));
    // Error 1: the input vector is empty

    println!("The first doubled is {:?}", double_first(strings));
    // Error 2: the element doesn't parse to a number
}
</code></pre> 
<p>有时候不想再处理错误（比如使用 <a href="https://rustwiki.org/zh-CN/rust-by-example/error/result/enter_question_mark.html" rel="nofollow" title="?">?</a> 的时候），但如果 <code>Option</code> 是 <code>None</code> 则继续处理错误。一些组合算子可以让我们轻松地交换 <code>Result</code> 和 <code>Option</code>。</p> 
<pre><code class="language-rust">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;Option&lt;i32&gt;, ParseIntError&gt; {
    let opt = vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    });

    opt.map_or(Ok(None), |r| r.map(Some))
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    println!("The first doubled is {:?}", double_first(numbers));
    println!("The first doubled is {:?}", double_first(empty));
    println!("The first doubled is {:?}", double_first(strings));
}
</code></pre> 
<p></p> 
<h4>所有不同的错误视为一种</h4> 
<p>把所有不同的错误都视为一种错误类型会简化代码。</p> 
<p>Rust 允许我们定义自己的错误类型。一般来说，一个 “好的” 错误类型应当：</p> 
<ul><li>用同一个类型代表了多种错误</li><li>向用户提供了清楚的错误信息</li><li>能够容易地与其他类型比较 
  <ul><li>好的例子：<code>Err(EmptyVec)</code></li><li>坏的例子：<code>Err("Please use a vector with at least one element".to_owned())</code></li></ul></li><li>能够容纳错误的具体信息 
  <ul><li>好的例子：<code>Err(BadChar(c, position))</code></li><li>坏的例子：<code>Err("+ cannot be used here".to_owned())</code></li></ul></li><li>能够与其他错误很好地整合</li></ul> 
<pre><code class="language-rust">use std::error;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug, Clone)]
// 定义我们的错误类型，这种类型可以根据错误处理的实际情况定制。
// 我们可以完全自定义错误类型，也可以在类型中完全采用底层的错误实现，
// 也可以介于二者之间。
struct DoubleError;

// 错误的生成与它如何显示是完全没关系的。没有必要担心复杂的逻辑会导致混乱的显示。
//
// 注意我们没有储存关于错误的任何额外信息，也就是说，如果不修改我们的错误类型定义的话，
// 就无法指明是哪个字符串解析失败了。
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "invalid first item to double")
    }
}

// 为 `DoubleError` 实现 `Error` trait，这样其他错误可以包裹这个错误类型。
impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        // 泛型错误，没有记录其内部原因。
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
       // 把错误换成我们的新类型。
       .ok_or(DoubleError)
       .and_then(|s| {
            s.parse::&lt;i32&gt;()
                // 这里也换成新类型。
                .map_err(|_| DoubleError)
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!("The first doubled is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre> 
<p></p> 
<h4>把错误 "装箱"</h4> 
<p>如果又想写简单的代码，又想保存原始错误信息，一个方法是把它们<a href="https://rustwiki.org/zh-CN/std/boxed/struct.Box.html" rel="nofollow" title="装箱">装箱</a>（<code>Box</code>）。这样做的坏处就是，被包装的错误类型只能在运行时了解，而不能被<a href="https://rustwiki.org/zh-CN/book/ch17-02-trait-objects.html#trait-%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91" rel="nofollow" title="静态地判别">静态地判别</a>。</p> 
<p>对任何实现了 <code>Error</code> trait 的类型，标准库的 <code>Box</code> 通过 <a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html" rel="nofollow" title="From">From</a> 为它们提供了到 <code>Box&lt;Error&gt;</code> 的转换。</p> 
<pre><code class="language-rust">use std::error;
use std::fmt;

// 为 `Box&lt;error::Error&gt;` 取别名。
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "invalid first item to double")
    }
}

impl error::Error for EmptyVec {
    fn description(&amp;self) -&gt; &amp;str {
        "invalid first item to double"
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn error::Error&gt; {
        // 泛型错误。没有记录其内部原因。
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
       .ok_or_else(|| EmptyVec.into())  // 装箱
       .and_then(|s| {
            s.parse::&lt;i32&gt;()
                .map_err(|e| e.into())  // 装箱
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!("The first doubled is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre> 
<p>参考：<a href="https://rustwiki.org/zh-CN/book/ch17-02-trait-objects.html#trait-%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91" rel="nofollow" title="动态分发">动态分发</a> and <a href="https://rustwiki.org/zh-CN/std/error/trait.Error.html" rel="nofollow" title="Error trait">Error trait</a></p> 
<p>把错误装箱这种做法也可以改成把它包裹到你自己的错误类型中。</p> 
<pre><code class="language-rust">use std::error;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // 在这个错误类型中，我们采用 `parse` 的错误类型中 `Err` 部分的实现。
    // 若想提供更多信息，则该类型中还需要加入更多数据。
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, "please use a vector with at least one element"),
            // 这是一个封装（wrapper），它采用内部各类型对 `fmt` 的实现。
            DoubleError::Parse(ref e) =&gt; e.fmt(f),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // 原因采取内部对错误类型的实现。它隐式地转换成了 trait 对象 `&amp;error:Error`。
            // 这可以工作，因为内部的类型已经实现了 `Error` trait。
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// 实现从 `ParseIntError` 到 `DoubleError` 的转换。
// 在使用 `?` 时，或者一个 `ParseIntError` 需要转换成 `DoubleError` 时，它会被自动调用。
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!("The first doubled is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre> 
<p>参考：<a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html" rel="nofollow" title="From::from">From::from</a> and <a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum.html" rel="nofollow" title="枚举类型">枚举类型</a></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h3>泛型</h3> 
<p>泛型的 <strong><span style="background-color:#ffd900;">类型参数</span></strong> 是使用 <strong><span style="background-color:#ffd900;">尖括号和大驼峰命名</span></strong> 的名称：&lt;Aaa, Bbb, ...&gt; 来指定的。泛型类型参数一般用&lt;T&gt;来表示。使用泛型定义函数时，本来在函数签名中指定参数和返回值的类型的地方，会改用泛型来表示：fn foo&lt;T&gt;(arg: T) { ... }    采用这种技术，使得代码适应性更强，从而为函数的调用者提供更多的功能，同时也避免了代码的重复。</p> 
<pre><code class="language-rust">// 一个具体类型 `A`。
struct A;

// 在定义类型 `Single` 时，第一次使用类型 `A` 之前没有写 `&lt;A&gt;`。
// 因此，`Single` 是个具体类型，`A` 取上面的定义。
struct Single(A);
//            ^ 这里是 `Single` 对类型 `A` 的第一次使用。

// 此处 `&lt;T&gt;` 在第一次使用 `T` 前出现，所以 `SingleGen` 是一个泛型类型。
// 因为 `T` 是泛型的，所以它可以是任何类型，包括在上面定义的具体类型 `A`。
struct SingleGen&lt;T&gt;(T);

fn main() {
    // `Single` 是具体类型，并且显式地使用类型 `A`。
    let _s = Single(A);
    
    // 创建一个 `SingleGen&lt;char&gt;` 类型的变量 `_char`，并令其值为 `SingleGen('a')`
    // 这里的 `SingleGen` 的类型参数是显式指定的。
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // `SingleGen` 的类型参数也可以隐式地指定。
    let _t    = SingleGen(A); // 使用在上面定义的 `A`。
    let _i32  = SingleGen(6); // 使用 `i32` 类型。
    let _char = SingleGen('a'); // 使用 `char`。
}
</code></pre> 
<h4>函数中使用 泛型</h4> 
<p>调用函数时，使用显式指定的类型参数会像是这样：<strong><span style="background-color:#ffd900;">fun::&lt;A, B, ...&gt;()</span></strong></p> 
<pre><code class="language-rust">struct A;  // 具体类型 `A`。
struct S(A);  // 具体类型 `S`。
struct SGen&lt;T&gt;(T); // 泛型类型 `SGen`。
// 下面全部函数都得到了变量的所有权，并立即使之离开作用域，将变量释放。
// 定义一个函数 `reg_fn`，接受一个 `S` 类型的参数 `_s`。
// 因为没有 `&lt;T&gt;` 这样的泛型类型参数，所以这不是泛型函数。
fn reg_fn(_s: S) {}

// 定义一个函数 `gen_spec_t`，接受一个 `SGen&lt;A&gt;` 类型的参数 `_s`。
// `SGen&lt;&gt;` 显式地接受了类型参数 `A`，且在 `gen_spec_t` 中，`A` 没有被用作
// 泛型类型参数，所以函数不是泛型的。
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// 定义一个函数 `gen_spec_i32`，接受一个 `SGen&lt;i32&gt;` 类型的参数 `_s`。
// `SGen&lt;&gt;` 显式地接受了类型参量 `i32`，而 `i32` 是一个具体类型。
// 由于 `i32` 不是一个泛型类型，所以这个函数也不是泛型的。
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// 定义一个函数 `generic`，接受一个 `SGen&lt;T&gt;` 类型的参数 `_s`。
// 因为 `SGen&lt;T&gt;` 之前有 `&lt;T&gt;`，所以这个函数是关于 `T` 的泛型函数。
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];
    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);
    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest(&amp;char_list);
    println!("The largest char is {}", result);
    println!("###########################################");
    // 使用非泛型函数
    reg_fn(S(A));          // 具体类型。
    gen_spec_t(SGen(A));   // 隐式地指定类型参数 `A`。
    gen_spec_i32(SGen(6)); // 隐式地指定类型参数 `i32`。
    // 为 `generic()` 显式地指定类型参数 `char`。
    generic::&lt;char&gt;(SGen('a'));
    // 为 `generic()` 隐式地指定类型参数 `char`。
    generic(SGen('c'));
}</code></pre> 
<h4>结构体中使用 泛型</h4> 
<pre><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre> 
<h4><code>impl</code> 实现泛型 格式</h4> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
    struct S; // 具体类型 `S`
    struct GenericVal&lt;T&gt;(T,); // 泛型类型 `GenericVal`

    // GenericVal 的 `impl`，此处我们显式地指定了类型参数：
    impl GenericVal&lt;f32&gt; {} // 指定 `f32` 类型
    impl GenericVal&lt;S&gt; {} // 指定为上面定义的 `S`

    // `&lt;T&gt;` 必须在类型之前写出来，以使类型 `T` 代表泛型。
    impl &lt;T&gt; GenericVal&lt;T&gt; {}
}</code></pre> 
<pre><code class="language-rust">struct Val {
    val: f64
}

struct GenVal&lt;T&gt;{
    gen_val: T
}

// Val 的 `impl`
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 { &amp;self.val }
}

// GenVal 的 `impl`，指定 `T` 是泛型类型
impl &lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T { &amp;self.gen_val }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };

    println!("{}, {}", x.value(), y.value());
}
</code></pre> 
<h4><strong><span style="background-color:#ffd900;">多个 泛型类型 参数</span></strong></h4> 
<p>可以在定义中使用任意多的泛型类型参数，不过太多的话，代码将难以阅读和理解。当你发现代码中需要很多泛型时，这可能表明你的代码需要重构分解成更小的结构。</p> 
<p>修改 <code>Point</code> 的定义为拥有两个泛型类型 <code>T</code> 和 <code>U</code>。其中字段 <code>x</code> 是 <code>T</code> 类型的，而字段 <code>y</code> 是 <code>U</code> 类型的：</p> 
<pre><code class="language-rust">struct Point1&lt;T, U&gt; {
    x: T,
    y: U,
}

struct Point2&lt;T1, T2&gt; {
    x: T1,
    y: T2,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre> 
<h4>枚举定义中 泛型</h4> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
}
</code></pre> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
}
</code></pre> 
<h4>方法定义中的泛型</h4> 
<pre><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
</code></pre> 
<p>注意必须在 <code>impl</code> 后面声明 <code>T</code>，这样就可以在 <code>Point&lt;T&gt;</code> 上实现的方法中使用 <code>T</code> 了。通过在 <code>impl</code> 之后声明泛型 <code>T</code>，Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。可以为泛型参数选择一个与结构体定义中声明的泛型参数所不同的名称，不过依照惯例使用了相同的名称。<code>impl</code> 中编写的方法声明了泛型类型可以定位为任何类型的实例，不管最终替换泛型类型的是何具体类型。</p> 
<p>定义方法时也可以为泛型指定限制（constraint）。例如，可以选择为 <code>Point&lt;f32&gt;</code> 实例实现方法，而不是为泛型 <code>Point</code> 实例。示例 10-10 展示了一个没有在 <code>impl</code> 之后（的尖括号）声明泛型的例子，这里使用了一个具体类型，<code>f32</code>：</p> 
<pre><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
</code></pre> 
<pre><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
</code></pre> 
<p>Rust 通过在编译时进行泛型代码的 单态化（monomorphization）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。编译器寻找所有泛型代码被调用的位置并使用泛型代码针对具体类型生成代码。</p> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
    let integer = Some(5);
    let float = Some(5.0);
}
</code></pre> 
<p>当 Rust 编译这些代码的时候，它会进行单态化。编译器会读取传递给 <code>Option&lt;T&gt;</code> 的值并发现有两种 <code>Option&lt;T&gt;</code>：一个对应 <code>i32</code> 另一个对应 <code>f64</code>。为此，它会将泛型定义 <code>Option&lt;T&gt;</code> 展开为两个针对 <code>i32</code> 和 <code>f64</code> 的定义，接着将泛型定义替换为这两个具体的定义。</p> 
<p>编译器生成的单态化版本的代码看起来像这样</p> 
<pre><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre> 
<h4>Trait：方法的集合</h4> 
<p><em>trait</em> 类似于其他语言中的常被称为 <strong>接口</strong>（<em>interfaces</em>）的功能。定义共同拥有的方法。</p> 
<p>一个类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。</p> 
<pre><code class="language-rust">// 定义 trait
pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre> 
<p>使用 <code>trait</code> 关键字来声明一个 trait，后面是 trait 的名字，在这个例子中是 <code>Summary</code>。我们也声明 <code>trait</code> 为 <code>pub</code> 以便依赖这个 crate 的 crate 也可以使用这个 trait。大括号中声明描述实现这个 trait 的类型所需要的行为的方法签名，在这个例子中是 <code>fn summarize(&amp;self) -&gt; String</code>。</p> 
<p>在方法签名后跟分号，而不是在大括号中提供其实现。接着每一个实现这个 trait 的类型都需要提供其自定义行为的方法体，编译器也会确保任何实现 <code>Summary</code> trait 的类型都拥有与这个签名的定义完全一致的 <code>summarize</code> 方法。</p> 
<p><strong>trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。</strong></p> 
<p>实现 trait</p> 
<pre><code class="language-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

// 实现 trail
impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

// 实现 trail
impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}

fn main() {
    
}</code></pre> 
<p>在类型上实现 trait 类似于实现与 trait 无关的方法。区别在于 <code>impl</code> 关键字之后，我们提供需要实现 trait 的名称，接着是 <code>for</code> 和需要实现 trait 的类型的名称。在 <code>impl</code> 块中，使用 trait 定义中的方法签名，不过不再后跟分号，而是需要在大括号中编写函数体来为特定类型实现 trait 方法所拥有的行为。</p> 
<p>现在库在 <code>NewsArticle</code> 和 <code>Tweet</code> 上实现了<code>Summary</code> trait，crate 的用户可以像调用常规方法一样调用 <code>NewsArticle</code> 和 <code>Tweet</code> 实例的 trait 方法了。唯一的区别是 trait 必须和类型一起引入作用域以便使用额外的 trait 方法。这是一个二进制 crate 如何利用 <code>aggregator</code> 库 crate 的例子：</p> 
<pre><code class="language-rust">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
</code></pre> 
<p>注意限制：<span style="color:#fe2c24;"><strong>只有在 trait 或类型至少有一个属于当前 crate 时，我们才能对类型实现该 trait。不能为外部类型实现外部 trait。</strong></span></p> 
<p>这个限制是被称为 <strong>相干性</strong>（<em>coherence</em>）的程序属性的一部分，或者更具体的说是 <strong>孤儿规则</strong>（<em>orphan rule</em>），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。</p> 
<h4><strong>trait 作为参数</strong></h4> 
<pre><code class="language-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}

pub fn notify(item: &amp;impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
</code></pre> 
<p>该 notify 参数支持任何实现了指定 trait 的类型。在 <code>notify</code> 函数体中，可以调用任何来自 <code>Summary</code> trait 的方法，比如 <code>summarize</code>。我们可以传递任何 <code>NewsArticle</code> 或 <code>Tweet</code> 的实例来调用 <code>notify</code>。任何用其它如 <code>String</code> 或 <code>i32</code> 的类型调用该函数的代码都不能编译，因为它们没有实现 <code>Summary</code>。</p> 
<p></p> 
<h4><strong>trait  泛型</strong></h4> 
<pre><code class="language-rust">// 不可复制的类型。
struct Empty;
struct Null;

// `T` 的泛型 trait。
trait DoubleDrop&lt;T&gt; {
    // 定义一个调用者的方法，接受一个额外的参数 `T`，但不对它做任何事。
    fn double_drop(self, _: T);
}

// 对泛型的调用者类型 `U` 和任何泛型类型 `T` 实现 `DoubleDrop&lt;T&gt;` 。
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // 此方法获得两个传入参数的所有权，并释放它们。
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // 释放 `empty` 和 `null`。
    empty.double_drop(null);

    //empty;
    //null;
    // ^ 试一试：去掉这两行的注释。
}
</code></pre> 
<p></p> 
<h4><strong>泛型 约束 ( trait bound )</strong></h4> 
<p>在使用泛型时，类型参数常常必须使用 trait 作为<strong>约束</strong>（bound）来明确规定类型应实现哪些功能。</p> 
<p>示例：用到了 <code>Display</code> trait 来打印，所以它用 <code>Display</code> 来约束 <code>T</code>，也就是说 <code>T</code> <strong>必须</strong>实现 <code>Display</code>。</p> 
<pre><code class="language-rust">// 定义一个函数 `printer`，接受一个类型为泛型 `T` 的参数，
// 其中 `T` 必须实现 `Display` trait。
fn printer&lt;T: Display&gt;(t: T) {
    println!("{}", t);
}
</code></pre> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>泛型参数 </strong></span>与 <span style="color:#fe2c24;"><strong>泛型 约束 ( trait bound )</strong></span><span style="color:#956fe7;"><strong> </strong></span>声明在一起，位于 <strong><span style="background-color:#ffd900;">尖括号中的冒号后面</span></strong>。</p> 
 <p><strong>fn func&lt;<span style="color:#956fe7;">泛型参数</span>: <span style="color:#fe2c24;">泛型约束</span>&gt;(<span style="background-color:#fe2c24;">形参</span>: <span style="background-color:#fe2c24;">泛型参数</span>) {<!-- --><br>     // <br> }</strong></p> 
 <ul><li><span style="background-color:#fe2c24;">约束</span> 把 <span style="background-color:#fe2c24;">泛型类型</span> 限制为符合约束的类型。 <pre><code class="language-rust">struct S&lt;T: Display&gt;(T);
// 报错！`Vec&lt;T&gt;` 未实现 `Display`。此次泛型具体化失败。
let s = S(vec![1]);
</code></pre> </li><li>约束的另一个作用是泛型的实例可以访问作为约束的 trait 的方法。 <pre><code class="language-rust">// 这个 trait 用来实现打印标记：`{:?}`。
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// 泛型 `T` 必须实现 `Debug` 。只要满足这点，无论什么类型
// 都可以让下面函数正常工作。
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!("{:?}", t);
}

// `T` 必须实现 `HasArea`。任意符合该约束的泛型的实例
// 都可访问 `HasArea` 的 `area` 函数
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!("Area: {}", area(&amp;rectangle));

    //print_debug(&amp;_triangle);
    //println!("Area: {}", area(&amp;_triangle));
    // ^ 试一试：取消上述语句的注释。
    // | 报错：未实现 `Debug` 或 `HasArea`。
}
</code></pre> </li><li>某些情况下也可使用 <a href="https://rustwiki.org/zh-CN/rust-by-example/generics/where.html" rel="nofollow" title="where">where</a> 分句来形成约束，这拥有更好的表现力。</li></ul> 
</blockquote> 
<p><code>impl Trait</code> 很方便，适用于短小的例子。更长的 trait bound 则适用于更复杂的场景。例如，可以获取两个实现了 <code>Summary</code> 的参数。使用 <code>impl Trait</code> 的语法看起来像这样：</p> 
<blockquote> 
 <p>pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {<!-- --></p> 
</blockquote> 
<p>这适用于 <code>item1</code> 和 <code>item2</code> 允许是不同类型的情况（只要它们都实现了 <code>Summary</code>）。不过如果你希望强制它们都是相同类型呢？这只有在使用 trait bound 时才有可能：</p> 
<blockquote> 
 <p>pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {<!-- --></p> 
</blockquote> 
<p>泛型 <code>T</code> 被指定为 <code>item1</code> 和 <code>item2</code> 的参数限制，如此传递给参数 <code>item1</code> 和 <code>item2</code> 值的具体类型必须一致。</p> 
<p></p> 
<h4>空约束</h4> 
<p>约束的工作机制会产生这样的效果：即使一个 <code>trait</code> 不包含任何功能，你仍然可以用它作为约束。标准库中的 <code>Eq</code> 和 <code>Ord</code> 就是这样的 <code>trait</code>。</p> 
<pre><code class="language-rust">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// 这些函数只对实现了相应的 trait 的类型有效。
// 事实上这些 trait 内部是空的，但这没有关系。
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { "red" }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { "blue" }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;

    // 由于约束，`red()` 不能作用于 blue_jay （蓝松鸟），反过来也一样。
    println!("A cardinal is {}", red(&amp;cardinal));
    println!("A blue jay is {}", blue(&amp;blue_jay));
    //println!("A turkey is {}", red(&amp;_turkey));
    // ^ 试一试：去掉此行注释。
}
</code></pre> 
<p>参考：<a href="https://rustwiki.org/zh-CN/std/cmp/trait.Eq.html" rel="nofollow" title="std::cmp::Eq">std::cmp::Eq</a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.Ord.html" rel="nofollow" title="std::cmp::Ord">std::cmp::Ord</a>, 和 <a href="https://rustwiki.org/zh-CN/rust-by-example/trait.html" rel="nofollow" title="trait">trait</a></p> 
<p></p> 
<h4>多重 约束</h4> 
<ul><li>多重约束（multiple bounds）可以用 <code>+</code> 连接。</li><li>类型之间使用 <code>,</code> 隔开。</li></ul> 
<pre><code class="language-rust">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!("Debug: `{:?}`", t);
    println!("Display: `{}`", t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!("t: `{:?}`", t);
    println!("u: `{:?}`", u);
}

fn main() {
    let string = "words";
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    //compare_prints(&amp;array);
    // 试一试 ^ 将此行注释去掉。

    compare_types(&amp;array, &amp;vec);
}
</code></pre> 
<p></p> 
<h4>使用 where 简化 trait bound</h4> 
<p>使用过多的 trait bound 也有缺点。每个泛型有其自己的 trait bound，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 trait bound 信息，这使得函数签名难以阅读。为此，Rust 有另一个在函数签名之后的 <code>where</code> 从句中指定 trait bound 的语法。所以除了这么写：</p> 
<blockquote> 
 <p>fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {<!-- --></p> 
</blockquote> 
<p>使用 <code>where</code> 从句简化：</p> 
<blockquote> 
 <p>fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32<br>     where<br>         T: Display + Clone,<br>         U: Clone + Debug,<br> {<!-- --><br>     unimplemented!()<br> }</p> 
</blockquote> 
<p>这个函数签名就显得不那么杂乱，函数名、参数列表和返回值类型都离得很近，看起来跟没有那么多 trait bounds 的函数很像。</p> 
<pre><code class="language-rust">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// 使用 `where` 从句来表达约束
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre> 
<pre><code class="language-rust">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// 这里需要一个 `where` 从句，否则就要表达成 `T: Debug`（这样意思就变了），
// 或者改用另一种间接的方法。
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // 我们要将 `Option&lt;T&gt;: Debug` 作为约束，因为那是要打印的内容。
    // 否则我们会给出错误的约束。
    fn print_in_option(self) {
        println!("{:?}", Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
</code></pre> 
<p></p> 
<h4>返回实现了 trait 的类型</h4> 
<p>也可以在返回值中使用 impl Trait 语法，来返回实现了某个 trait 的类型：</p> 
<pre><code class="language-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}

fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
</code></pre> 
<p>通过使用 <code>impl Summary</code> 作为返回值类型，我们指定了 <code>returns_summarizable</code> 函数返回某个实现了 <code>Summary</code> trait 的类型，但是不确定其具体的类型。在这个例子中 <code>returns_summarizable</code> 返回了一个 <code>Tweet</code>，不过调用方并不知情。</p> 
<p>返回一个只是指定了需要实现的 trait 的类型的能力在闭包和迭代器场景十分的有用</p> 
<p>使用 trait bound 有条件地实现方法</p> 
<p>对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 <em>blanket implementations</em>，它们被广泛的用于 Rust 标准库中。例如，标准库为任何实现了 <code>Display</code> trait 的类型实现了 <code>ToString</code> trait。这个 <code>impl</code> 块看起来像这样：</p> 
<pre><code class="language-rust">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre> 
<p>trait 和 trait bound 让我们能够使用泛型类型参数来减少重复，而且能够向编译器明确指定泛型类型需要拥有哪些行为。然后编译器可以利用 trait bound 信息检查代码中所用到的具体类型是否提供了正确的行为。在动态类型语言中，如果我们调用了一个未定义的方法，会在运行时出现错误。Rust 将这些错误移动到了编译时，甚至在代码能够运行之前就强迫我们修复问题。另外，我们也无需编写运行时检查行为的代码，因为在编译时就已经检查过了。这样既提升了性能又不必放弃泛型的灵活性。</p> 
<p></p> 
<h4>new type 惯用法</h4> 
<p>在 Rust 中，"Newtype" 是一种惯用法，它允许你创建一个新的类型来封装现有类型。通过这种方式，你可以在类型层级上引入更多的安全性和表达力。</p> 
<p></p> 
<h4>关联 类型</h4> 
<p>一种将类型占位符与 trait 联系起来的 做法，这样 trait 中的方法签名中就可以使用这些占位符类型。trait 的实现会指定在 该实现中那些占位符对应什么具体类型。</p> 
<pre><code class="language-rust">struct Container(i32, i32);

// 这个 trait 检查给定的 2 个项是否储存于容器中
// 并且能够获得容器的第一个或最后一个值。
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; // 显式地要求 `A` 和 `B`
    fn first(&amp;self) -&gt; i32; // 未显式地要求 `A` 或 `B`
    fn last(&amp;self) -&gt; i32;  // 未显式地要求 `A` 或 `B`
}

impl Contains&lt;i32, i32&gt; for Container {
    // 如果存储的数字和给定的相等则为真。
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // 得到第一个数字。
    fn first(&amp;self) -&gt; i32 { self.0 }

    // 得到最后一个数字。
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// 容器 `C` 就包含了 `A` 和 `B` 类型。鉴于此，必须指出 `A` 和 `B` 显得很麻烦。
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!("Does container contain {} and {}: {}",
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!("First number: {}", container.first());
    println!("Last number: {}", container.last());

    println!("The difference is: {}", difference(&amp;container));
}
</code></pre> 
<p>通过把容器内部的类型放到 <code>trait</code> 中作为<strong>输出类型</strong>，使用 “关联类型” 增加了代码的可读性。这样的 <code>trait</code> 的定义语法如下：</p> 
<pre><code class="language-rust">
#![allow(unused)]
fn main() {
// `A` 和 `B` 在 trait 里面通过 `type` 关键字来定义。
// （注意：此处的 `type` 不同于为类型取别名时的 `type`）。
trait Contains {
    type A;
    type B;

    // 这种语法能够泛型地表示这些新类型。
    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
}
}
</code></pre> 
<p>注意使用了 <code>Contains</code> <code>trait</code> 的函数就不需要写出 <code>A</code> 或 <code>B</code> 了：</p> 
<pre><code class="language-rust">// 不使用关联类型
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// 使用关联类型
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }
</code></pre> 
<p>使用关联类型来重写上面代码</p> 
<pre><code class="language-rust">struct Container(i32, i32);

// 这个 trait 检查给定的 2 个项是否储存于容器中
// 并且能够获得容器的第一个或最后一个值。
trait Contains {
    // 在这里定义可以被方法使用的泛型类型。
    type A;
    type B;

    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // 指出 `A` 和 `B` 是什么类型。如果 `input`（输入）类型
    // 为 `Container(i32, i32)`，那么 `output`（输出）类型
    // 会被确定为 `i32` 和 `i32`。
    type A = i32;
    type B = i32;

    // `&amp;Self::A` 和 `&amp;Self::B` 在这里也是合法的类型。
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // 得到第一个数字。
    fn first(&amp;self) -&gt; i32 { self.0 }

    // 得到最后一个数字。
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!("Does container contain {} and {}: {}",
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!("First number: {}", container.first());
    println!("Last number: {}", container.last());
    
    println!("The difference is: {}", difference(&amp;container));
}
</code></pre> 
<p></p> 
<h4>虚类型（phantom type）参数</h4> 
<p>虚类型（phantom type）参数是一种在运行时不出现，而在（且仅在）编译时进行静态检查的类型参数。可以用额外的泛型类型参数指定数据类型，该类型可以充当标记，也可以供编译时类型检查使用。这些额外的参数没有存储值，也没有运行时行为。参考：<a href="https://rustwiki.org/zh-CN/rust-by-example/trait/derive.html" rel="nofollow" title="Derive">Derive</a>, <a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/structs.html" rel="nofollow" title="结构体">结构体</a>, 和 <a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/structs.html" rel="nofollow" title="元组结构体">元组结构体</a></p> 
<p></p> 
<h4>使用生命周期来确保引用有效</h4> 
<p>生命周期是另一类泛型。不同于确保类型有期望的行为，生命周期确保引用如预期一直有效。</p> 
<p>Rust 中的每一个引用都有其 <strong>生命周期</strong>（<em>lifetime</em>），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明它们的关系，这样就能确保运行时实际使用的引用绝对是有效的。</p> 
<ul><li>生命周期的主要目标是避免<strong>悬垂引用</strong>（<em>dangling references</em>）。</li><li>生命周期参数：指定哪个参数的生命周期与返回值的生命周期相关联。<br> pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {<!-- --><br>     vec![]<br> }<br> 解释：返回的 vector 中会包含引用参数 contents (而不是参数query) slice 的字符串 slice。换句话说，我们需要告诉 Rust 编译器：函数 <code>search</code> 返回的数据将与 <code>search</code> 函数中的参数 <code>contents</code> 的数据存在的一样久。这是非常重要的！参数 <code>contents</code> 包含了所有的文本而且我们希望返回匹配的那部分文本，所以 <code>contents</code> 参数需要使用 <strong><span style="background-color:#ffd900;">生命周期语法</span></strong> 来与返回值相关联。其他语言中并不需要你在函数签名中将参数与返回值相关联。 <a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%BC%95%E7%94%A8%E6%9C%89%E6%95%88%E6%80%A7" rel="nofollow" title="“生命周期与引用有效性”">“生命周期与引用有效性”</a> 。</li></ul> 
<p><strong>函数中的泛型生命周期</strong></p> 
<p>生命周期注解有着一个不太常见的语法：生命周期参数名称必须以撇号（<code>'</code>）开头，其名称通常全是小写，类似于泛型其名称非常短。大多数人使用 <code>'a</code> 作为第一个生命周期注解。生命周期参数注解位于引用的 <code>&amp;</code> 之后，并有一个空格来将引用类型与生命周期注解分隔开。</p> 
<p>这里有一些例子：我们有一个没有生命周期参数的 <code>i32</code> 的引用，一个有叫做 <code>'a</code> 的生命周期参数的 <code>i32</code> 的引用，和一个生命周期也是 <code>'a</code> 的 <code>i32</code> 的可变引用：</p> 
<blockquote> 
 <p>&amp;i32        // 引用<br> &amp;'a i32     // 带有显式生命周期的引用<br> &amp;'a mut i32 // 带有显式生命周期的可变引用</p> 
</blockquote> 
<p>单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的。让我们在 <code>longest</code> 函数的上下文中理解生命周期注解如何相互联系。</p> 
<p>例如如果函数有一个生命周期 <code>'a</code> 的 <code>i32</code> 的引用的参数 <code>first</code>。还有另一个同样是生命周期 <code>'a</code> 的 <code>i32</code> 的引用的参数 <code>second</code>。这两个生命周期注解意味着引用 <code>first</code> 和 <code>second</code> 必须与这泛型生命周期存在得一样久。</p> 
<p><strong>函数签名中的生命周期注解</strong></p> 
<p>为了在函数签名中使用生命周期注解，需要在函数名和参数列表间的尖括号中声明泛型生命周期（<em>lifetime</em>）参数，就像泛型类型（<em>type</em>）参数一样。</p> 
<p>我们希望函数签名表达如下限制：也就是这两个参数和返回的引用存活的一样久。（两个）参数和返回的引用的生命周期是相关的。就像示例 10-21 中在每个引用中都加上了 <code>'a</code> 那样。</p> 
<pre><code class="language-rust">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

// longest 函数定义指定了签名中所有的引用必须有相同的生命周期 'a
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre> 
<p>现在函数签名表明对于某些生命周期 <code>'a</code>，函数会获取两个参数，它们都是与生命周期 <code>'a</code> 存在的一样长的字符串 slice。函数会返回一个同样也与生命周期 <code>'a</code> 存在的一样长的字符串 slice。它的实际含义是 <code>longest</code> 函数返回的引用的生命周期与函数参数所引用的值的生命周期的较小者一致。这些关系就是我们希望 Rust 分析代码时所使用的。</p> 
<p>通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。注意 <code>longest</code> 函数并不需要知道 <code>x</code> 和 <code>y</code> 具体会存在多久，而只需要知道有某个可以被 <code>'a</code> 替代的作用域将会满足这个签名。</p> 
<p>当在函数中使用生命周期注解时，这些注解出现在函数签名中，而不存在于函数体中的任何代码中。生命周期注解成为了函数约定的一部分，非常像签名中的类型。让函数签名包含生命周期约定意味着 Rust 编译器的工作变得更简单了。如果函数注解有误或者调用方法不对，编译器错误可以更准确地指出代码和限制的部分。如果不这么做的话，Rust 编译会对我们期望的生命周期关系做更多的推断，这样编译器可能只能指出离出问题地方很多步之外的代码。</p> 
<p>当具体的引用被传递给 <code>longest</code> 时，被 <code>'a</code> 所替代的具体生命周期是 <code>x</code> 的作用域与 <code>y</code> 的作用域相重叠的那一部分。换一种说法就是泛型生命周期 <code>'a</code> 的具体生命周期等同于 <code>x</code> 和 <code>y</code> 的生命周期中较小的那一个。因为我们用相同的生命周期参数 <code>'a</code> 标注了返回的引用值，所以返回的引用值就能保证在 <code>x</code> 和 <code>y</code> 中较短的那个生命周期结束之前保持有效。</p> 
<p>让我们看看如何通过传递拥有不同具体生命周期的引用来限制 <code>longest</code> 函数的使用。</p> 
<pre><code class="language-rust">fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre> 
<p>从人的角度读上述代码，我们可能会觉得这个代码是正确的。 <code>string1</code> 更长，因此 <code>result</code> 会包含指向 <code>string1</code> 的引用。因为 <code>string1</code> 尚未离开作用域，对于 <code>println!</code> 来说 <code>string1</code> 的引用仍然是有效的。然而，我们通过生命周期参数告诉 Rust 的是： <code>longest</code> 函数返回的引用的生命周期应该与传入参数的生命周期中较短那个保持一致。因此，借用检查器代码检查失败，因为它可能会存在无效的引用。</p> 
<p><strong>深入理解生命周期</strong></p> 
<p>指定生命周期参数的正确方式依赖函数实现的具体功能。例如，如果将 <code>longest</code> 函数的实现修改为总是返回第一个参数而不是最长的字符串 slice，就不需要为参数 <code>y</code> 指定一个生命周期。如下代码将能够编译：</p> 
<pre><code class="language-rust">fn main() {
    let string1 = String::from("abcd");
    let string2 = "efghijklmnopqrstuvwxyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre> 
<p>为参数 <code>x</code> 和返回值指定了生命周期参数 <code>'a</code>，不过没有为参数 <code>y</code> 指定，因为 <code>y</code> 的生命周期与参数 <code>x</code> 和返回值的生命周期没有任何关系。</p> 
<blockquote> 
 <p><strong>总结：</strong><span style="color:#fe2c24;"><strong>生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦它们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。</strong></span></p> 
</blockquote> 
<p>定义包含引用的结构体，不过这需要为结构体定义中的每一个引用添加生命周期注解。</p> 
<pre><code>struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre> 
<p>这个结构体有唯一一个字段 <code>part</code>，它存放了一个字符串 slice，这是一个引用。类似于泛型参数类型，必须在结构体名称后面的尖括号中声明泛型生命周期参数，以便在结构体定义中使用生命周期参数。这个注解意味着 <code>ImportantExcerpt</code> 的实例不能比其 <code>part</code> 字段中的引用存在的更久。</p> 
<p>这里的 <code>main</code> 函数创建了一个 <code>ImportantExcerpt</code> 的实例，它存放了变量 <code>novel</code> 所拥有的 <code>String</code> 的第一个句子的引用。<code>novel</code> 的数据在 <code>ImportantExcerpt</code> 实例创建之前就存在。另外，直到 <code>ImportantExcerpt</code> 离开作用域之后 <code>novel</code> 都不会离开作用域，所以 <code>ImportantExcerpt</code> 实例中的引用是有效的。</p> 
<p><strong>生命周期省略（Lifetime Elision）</strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>每一个引用都有一个生命周期，而且我们需要为那些使用了引用的函数或结构体指定生命周期。</strong></span></p> 
 <p>函数或方法的参数的生命周期被称为 <strong>输入生命周期</strong>（<em>input lifetimes</em>），而返回值的生命周期被称为 <strong>输出生命周期</strong>（<em>output lifetimes</em>）。</p> 
</blockquote> 
<p>编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则适用于 <code>fn</code> 定义，以及 <code>impl</code> 块。</p> 
<ul><li>第一条规则是编译器为每一个引用参数都分配一个生命周期参数。换句话说就是，函数有一个引用参数的就有一个生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>，有两个引用参数的函数就有两个不同的生命周期参数，<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>，依此类推。</li><li>第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</li><li>第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，说明是个对象的方法 (method)(译者注：这里涉及 rust 的面向对象参见 17 章)，那么所有输出生命周期参数被赋予 <code>self</code> 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。</li></ul> 
<pre><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}

fn main() {
    let my_string = String::from("hello world");

    // first_word works on slices of `String`s
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = "hello world";

    // first_word works on slices of string literals
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
</code></pre> 
<p>假设我们自己就是编译器。并应用这些规则来计算示例中 <code>first_word</code> 函数签名中的引用的生命周期。开始时签名中的引用并没有关联任何生命周期：fn first_word(s: &amp;str) -&gt; &amp;str {<!-- --></p> 
<p>接着编译器应用第一条规则，也就是每个引用参数都有其自己的生命周期。我们像往常一样称之为 <code>'a</code>，所以现在签名看起来像这样：fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {<!-- --></p> 
<p>对于第二条规则，因为这里正好只有一个输入生命周期参数所以是适用的。第二条规则表明输入参数的生命周期将被赋予输出生命周期参数，所以现在签名看起来像这样：fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {<!-- --></p> 
<p>现在这个函数签名中的所有引用都有了生命周期，如此编译器可以继续它的分析而无须程序员标记这个函数签名中的生命周期。</p> 
<p>另一个例子：</p> 
<blockquote> 
 <p>从没有生命周期参数的 <code>longest</code> 函数开始：fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {<!-- --></p> 
</blockquote> 
<p>再次假设我们自己就是编译器并应用第一条规则：每个引用参数都有其自己的生命周期。这次有两个参数，所以就有两个（不同的）生命周期：fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {<!-- --></p> 
<p>再来应用第二条规则，因为函数存在多个输入生命周期，它并不适用于这种情况。再来看第三条规则，它同样也不适用，这是因为没有 <code>self</code> 参数。应用了三个规则之后编译器还没有计算出返回值类型的生命周期。这就是在编译示例 10-20 的代码时会出现错误的原因：编译器使用所有已知的生命周期省略规则，仍不能计算出签名中所有引用的生命周期。</p> 
<p>因为第三条规则真正能够适用的就只有方法签名，现在就让我们看看那种情况中的生命周期，并看看为什么这条规则意味着我们经常不需要在方法签名中标注生命周期。</p> 
<p><strong>方法定义中的生命周期注解</strong></p> 
<p>当为带有生命周期的结构体实现方法时，其语法依然类似泛型类型参数的语法。我们在哪里声明和使用生命周期参数，取决于它们是与结构体字段相关还是与方法参数和返回值相关。</p> 
<p>（实现方法时）结构体字段的生命周期必须总是在 <code>impl</code> 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。</p> 
<p><code>impl</code> 块里的方法签名中，引用可能与结构体字段中的引用相关联，也可能是独立的。另外，生命周期省略规则也经常让我们无需在方法签名中使用生命周期注解。让我们看看一些使用示例 10-24 中定义的结构体 <code>ImportantExcerpt</code> 的例子。</p> 
<p>首先，这里有一个方法 <code>level</code>。其唯一的参数是 <code>self</code> 的引用，而且返回值只是一个 <code>i32</code>，并不引用任何值：</p> 
<pre><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}

impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {}", announcement);
        self.part
    }
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre> 
<p><code>impl</code> 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 <code>self</code> 引用的生命周期。</p> 
<p>这里是一个适用于第三条生命周期省略规则的例子：</p> 
<pre><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}

impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {}", announcement);
        self.part
    }
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre> 
<p>这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 <code>&amp;self</code> 和 <code>announcement</code> 它们各自的生命周期。接着，因为其中一个参数是 <code>&amp;self</code>，返回值类型被赋予了 <code>&amp;self</code> 的生命周期，这样所有的生命周期都被计算出来了。</p> 
<p><strong>静态生命周期</strong></p> 
<p>其生命周期<strong>能够</strong>存活于整个程序期间。所有的字符串字面值都拥有 <code>'static</code> 生命周期，我们也可以选择像下面这样标注出来：</p> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
    let s: &amp;'static str = "I have a static lifetime.";
}
</code></pre> 
<p>这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。因此所有的字符串字面值都是 <code>'static</code> 的。</p> 
<p>你可能在错误信息的帮助文本中见过使用 <code>'static</code> 生命周期的建议，不过将引用指定为 <code>'static</code> 之前，思考一下这个引用是否真的在整个程序的生命周期里都有效，以及你是否希望它存在得这么久。大部分情况中，推荐 <code>'static</code> 生命周期的错误信息都是尝试创建一个悬垂引用或者可用的生命周期不匹配的结果。在这种情况下的解决方案是修复这些问题而不是指定一个 <code>'static</code> 的生命周期。</p> 
<p><strong>结合泛型类型参数、trait bounds 和生命周期</strong></p> 
<pre><code class="language-rust">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest_with_an_announcement(
        string1.as_str(),
        string2,
        "Today is someone's birthday!",
    );
    println!("The longest string is {}", result);
}

use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
    where
        T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre> 
<p>返回两个字符串 slice 中较长者的 <code>longest</code> 函数，不过带有一个额外的参数 <code>ann</code>。<code>ann</code> 的类型是泛型 <code>T</code>，它可以被放入任何实现了 <code>where</code> 从句中指定的 <code>Display</code> trait 的类型。这个额外的参数会使用 <code>{}</code> 打印，这也就是为什么 <code>Display</code> trait bound 是必须的。因为生命周期也是泛型，所以生命周期参数 <code>'a</code> 和泛型类型参数 <code>T</code> 都位于函数名后的同一尖括号列表中。</p> 
<p>泛型类型参数意味着代码可以适用于不同的类型。trait 和 trait bounds 保证了即使类型是泛型的，这些类型也会拥有所需要的行为。由生命周期注解所指定的引用生命周期之间的关系保证了这些灵活多变的代码不会出现悬垂引用。而所有的这一切发生在编译时所以不会影响运行时效率！</p> 
<p></p> 
<h3>智能指针</h3> 
<p><strong>指针</strong> （<em>pointer</em>）是一个包含内存地址的变量的通用概念。这个地址引用，或 “指向”（points at）一些其他数据。Rust 中最常见的指针是第四章介绍的 <strong>引用</strong>（<em>reference</em>）。引用以 <code>&amp;</code> 符号为标志并借用了它们所指向的值。除了引用数据没有任何其他特殊功能，也没有额外开销。</p> 
<p><strong>智能指针</strong>（<em>smart pointers</em>）是一类数据结构，它们的表现类似指针，但是也拥有额外的元数据和功能。智能指针的概念并不为 Rust 所独有；其起源于 C++ 并存在于其他语言中。Rust 标准库中定义了多种不同的智能指针，它们提供了多于引用的额外功能。</p> 
<p></p> 
<h4>引用计数</h4> 
<p>为了探索其基本概念，我们来看看一些智能指针的例子，</p> 
<ul><li><strong>引用计数</strong> （<em>reference counting</em>）智能指针类型，这种指针允许数据有多个所有者，它会记录所有者的数量，当没有所有者时清理数据。</li><li><strong>普通引用 </strong>和 <strong>智能指针</strong> 的一个额外的区别：引用是一类只借用数据的指针，因为在 Rust 中因为引用就是借用；相反，在大部分情况下，智能指针 <strong>拥有</strong> 它们指向的数据。</li></ul> 
<p><span style="color:#fe2c24;"><strong>智能指针通常使用结构体实现</strong></span>。<strong><span style="background-color:#ffd900;">智能指针不同于结构体的地方在于其实现了 </span><code><span style="background-color:#ffd900;">Deref</span></code><span style="background-color:#ffd900;"> 和 </span><code><span style="background-color:#ffd900;">Drop</span></code><span style="background-color:#ffd900;"> trait</span></strong>。<code>Deref</code> trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码。<code>Drop</code> trait 允许我们自定义当智能指针离开作用域时运行的代码。</p> 
<p>智能指针是一个在 Rust 经常被使用的通用设计模式，这里不会覆盖所有现存的智能指针。很多库都有自己的智能指针而你也可以编写属于你自己的智能指针。这里将会讲到的是来自标准库中最常用的一些：</p> 
<ul><li><code>Box&lt;T&gt;</code>，用于已知的大小并指向分配在堆上的数据。</li><li><code>Rc&lt;T&gt;</code>，一个引用计数类型，其数据可以有多个所有者。</li><li><code>RefCell&lt;T&gt;</code> 和其内部可变性提供了一个可以用于当需要不可变类型但是需要改变其内部值能力的类型，并在运行时而不是编译时检查借用规则。（ <code>RefCell&lt;T&gt;</code> 是一个在运行时而不是在编译时执行借用规则的类型）。<strong>内部可变性</strong>（<em>interior mutability</em>）模式，这是不可变类型暴露出改变其内部值的 API。</li><li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，通过 <code>RefCell&lt;T&gt;</code> 访问。</li></ul> 
<p></p> 
<h4>Box&lt;T&gt;</h4> 
<p>最简单的智能指针是 <em>box</em>，其类型是 <code>Box&lt;T&gt;</code>。<strong><span style="background-color:#ffd900;">box 允许将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。</span></strong>当<em>box</em>离开作用域时，它的析构函数会被调用，内部的对象会被销毁，堆上分配的内存也会被释放。被<em>box指向</em>的值可以使用 <code>*</code> 运算符进行解引用；这会移除掉一层装箱。除了数据被储存在堆上而不是栈上之外，box 没有性能损失。</p> 
<pre><code class="language-rust">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

#[allow(dead_code)]
struct Rectangle {
    p1: Point,
    p2: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // 在堆上分配这个点（point），并返回一个指向它的指针
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // （所有的类型标注都不是必需的）
    // 栈分配的变量
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        p1: origin(),
        p2: Point { x: 3.0, y: 4.0 }
    };

    // 堆分配的 rectangle（矩形）
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        p1: origin(),
        p2: origin()
    });

    // 函数的输出可以装箱
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // 两层装箱
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!("Point occupies {} bytes in the stack",
             mem::size_of_val(&amp;point));
    println!("Rectangle occupies {} bytes in the stack",
             mem::size_of_val(&amp;rectangle));

    // box 的宽度就是指针宽度
    println!("Boxed point occupies {} bytes in the stack",
             mem::size_of_val(&amp;boxed_point));
    println!("Boxed rectangle occupies {} bytes in the stack",
             mem::size_of_val(&amp;boxed_rectangle));
    println!("Boxed box occupies {} bytes in the stack",
             mem::size_of_val(&amp;box_in_a_box));

    // 将包含在 `boxed_point` 中的数据复制到 `unboxed_point`
    let unboxed_point: Point = *boxed_point;
    println!("Unboxed point occupies {} bytes in the stack",
             mem::size_of_val(&amp;unboxed_point));
}
</code></pre> 
<p>多用于如下场景：</p> 
<ul><li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候。在 <a href="https://kaisery.github.io/trpl-zh-cn/ch15-01-box.html#box-%E5%85%81%E8%AE%B8%E5%88%9B%E5%BB%BA%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B" rel="nofollow" title="“box 允许创建递归类型”">“box 允许创建递归类型”</a> 部分展示第一种场景</li><li>转移大量数据的所有权可能会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 box 将这些数据储存在堆上。</li><li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候。 <a href="https://kaisery.github.io/trpl-zh-cn/ch17-02-trait-objects.html#%E4%B8%BA%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E8%80%8C%E8%AE%BE%E8%AE%A1%E7%9A%84-trait-%E5%AF%B9%E8%B1%A1" rel="nofollow" title="“顾及不同类型值的 trait 对象”">“顾及不同类型值的 trait 对象”</a> </li></ul> 
<p>示例：使用 Box&lt;T&gt; 在堆上储存数据</p> 
<pre><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}</code></pre> 
<p></p> 
<h4>智能指针 实现 链表</h4> 
<p>Box 允许创建递归类型：<strong>递归类型</strong>（<em>recursive type</em>）的值可以拥有另一个同类型的值作为其自身的一部分。但是这会产生一个问题，因为 Rust 需要在编译时知道类型占用多少空间。递归类型的值嵌套理论上可以无限地进行下去，所以 Rust 不知道递归类型需要多少空间。因为 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了。</p> 
<p>示例：cons ("construct function" 的缩写) list 来展示(递归类型)概念。有一个包含列表 1，2，3 的 cons list 的伪代码表示，其每一个列表在一个括号中：(1, (2, (3, Nil)))，cons list 的每一项都包含两个元素：当前项的值和下一项。其最后一项值包含一个叫做 <code>Nil</code> 的值且没有下一项。cons list 通过递归调用 <code>cons</code> 函数产生。代表递归的终止条件（base case）的规范名称是 <code>Nil</code>，它宣布列表的终止。</p> 
<pre><code class="language-rust">use crate::List::{Cons, Nil};
enum List {
    Cons(i32, List),
    Nil,
}
fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre> 
<p>尝试定义一个递归枚举时得到的错误，这个错误表明这个类型 “有无限的大小”。其原因是 <code>List</code> 的一个成员被定义为是递归的：它直接存放了另一个相同类型的值。这意味着 Rust 无法计算为了存放 <code>List</code> 值到底需要多少空间。让我们拆开来看为何会得到这个错误。首先了解一下 Rust 如何决定需要多少空间来存放一个非递归类型。</p> 
<p>编译器尝试计算出储存一个 <code>List</code> 枚举需要多少内存，并开始检查 <code>Cons</code> 成员，那么 <code>Cons</code> 需要的空间等于 <code>i32</code> 的大小加上 <code>List</code> 的大小。为了计算 <code>List</code> 需要多少内存，它检查其成员，从 <code>Cons</code> 成员开始。<code>Cons</code>成员储存了一个 <code>i32</code> 值和一个<code>List</code>值，这样的计算将无限进行下去。</p> 
<p>如图：一个包含无限个 Cons 成员的无限 List</p> 
<p class="img-center"><img alt="" height="464" src="https://images2.imgbox.com/1b/e9/L9gNXOIY_o.png" width="515"></p> 
<p>因为 Rust 无法计算出要为定义为递归的类型分配多少空间，所以编译器给出了一个包括了有用建议的错误：</p> 
<blockquote> 
 <p>help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable<br>   |<br> 2 |     Cons(i32, Box&lt;List&gt;),<br>   |               ++++    +</p> 
</blockquote> 
<p>使用 Box&lt;T&gt; 的 List 定义</p> 
<pre><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre> 
<p><code>Cons</code> 成员将会需要一个 <code>i32</code> 的大小加上储存 box 指针数据的空间。<code>Nil</code> 成员不储存值，所以它比 <code>Cons</code> 成员需要更少的空间。现在我们知道了任何 <code>List</code> 值最多需要一个 <code>i32</code> 加上 box 指针数据的大小。通过使用 box，打破了这无限递归的连锁，这样编译器就能够计算出储存 <code>List</code> 值需要的大小了。如图：因为 Cons 存放一个 Box 所以 List 不是无限大小的了</p> 
<p class="img-center"><img alt="" height="293" src="https://images2.imgbox.com/7d/05/ktw74yIA_o.png" width="333"></p> 
<p></p> 
<h4>解引用 运算符 *</h4> 
<p><code>Deref</code> trait 允许我们重载 <strong>解引用运算符</strong>（<em>dereference operator</em>）<code>*</code></p> 
<p>常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头。</p> 
<pre><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;
    assert_eq!(5, x);
    assert_eq!(5, *y);
    let number = 100;
    let pointer = &amp;number as *const i32;
    println!("Pointer value: {:?}", pointer);
}</code></pre> 
<p><strong><span style="color:#fe2c24;">"数字的引用、数字" 无法进行比较，因为它们是不同的类型。必须使用解引用运算符追踪引用所指向的值。</span></strong>变量 <code>x</code> 存放了一个 <code>i32</code> 值 <code>5</code>。<code>y</code> 等于 <code>x</code> 的一个引用。可以断言 <code>x</code> 等于 <code>5</code>。然而，如果希望对 <code>y</code> 的值做出断言，必须使用 <code>*y</code> 来追踪引用所指向的值（也就是 <strong>解引用</strong>），这样编译器就可以比较实际的值了。一旦解引用了 <code>y</code>，就可以访问 <code>y</code> 所指向的整型值并可以与 <code>5</code> 做比较。</p> 
<p>使用 Box&lt;T&gt; 时，就像使用引用一样。</p> 
<pre><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);
    assert_eq!(5, x);
    assert_eq!(5, *y);   // 底层运行的 *(y.deref())

    println!("y 地址: {:p}", y.as_ref());
}</code></pre> 
<p>自定义智能指针，通过实现 Deref trait 将某类型像引用一样处理</p> 
<p>为了体会默认情况下智能指针与引用的不同，让我们创建一个类似于标准库提供的 <code>Box&lt;T&gt;</code> 类型的智能指针。接着学习如何增加使用解引用运算符的功能。</p> 
<p>从根本上说，<code>Box&lt;T&gt;</code> 被定义为包含一个元素的元组结构体，所以示例 15-8 以相同的方式定义了 <code>MyBox&lt;T&gt;</code> 类型。我们还定义了 <code>new</code> 函数来对应定义于 <code>Box&lt;T&gt;</code> 的 <code>new</code> 函数：</p> 
<pre><code class="language-rust">use std::ops::Deref;

struct MyBox&lt;T&gt;(T);
impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre> 
<p>定义了一个结构体 <code>MyBox</code> 并声明了一个泛型参数 <code>T</code>，因为我们希望其可以存放任何类型的值。<code>MyBox</code> 是一个包含 <code>T</code> 类型元素的元组结构体。<code>MyBox::new</code> 函数获取一个 <code>T</code> 类型的参数并返回一个存放传入值的 <code>MyBox</code> 实例。为了启用 <code>*</code> 运算符的解引用功能，需要实现 <code>Deref</code> trait。 <a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#implementing-a-trait-on-a-type" rel="nofollow" title="“为类型实现 trait”">“为类型实现 trait”</a> 部分所讨论的，为了实现 trait，需要提供 trait 所需的方法实现。<code>Deref</code> trait，由标准库提供，要求实现名为 <code>deref</code> 的方法，其借用 <code>self</code> 并返回一个内部数据的引用。<code>deref</code> 方法体中写入了 <code>&amp;self.0</code>，这样 <code>deref</code> 返回了我希望通过 <code>*</code> 运算符访问的值的引用。<code>.0</code> 用来访问元组结构体的第一个元素。</p> 
<p>在代码中使用 <code>*</code> 时， <code>*</code> 运算符都被替换成了先调用 <code>deref</code> 方法再接着使用 <code>*</code> 解引用的操作，且只会发生一次，不会对 <code>*</code> 操作符无限递归替换，解引用出上面 <code>i32</code> 类型的值就停止了</p> 
<p><strong>Deref 强制转换</strong>（<em>deref coercions</em>）将实现了 <code>Deref</code> trait 的类型的引用转换为另一种类型的引用。例如，Deref 强制转换可以将 <code>&amp;String</code> 转换为 <code>&amp;str</code>，因为 <code>String</code> 实现了 <code>Deref</code> trait 因此可以返回 <code>&amp;str</code>。Deref 强制转换是 Rust 在函数或方法传参上的一种便利操作，并且只能作用于实现了 <code>Deref</code> trait 的类型。当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时将自动进行。这时会有一系列的 <code>deref</code> 方法被调用，把我们提供的类型转换成了参数所需的类型。</p> 
<p>Deref 强制转换的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 <code>&amp;</code> 和 <code>*</code> 的引用和解引用。</p> 
<pre><code class="language-rust">fn hello(name: &amp;str) {
    println!("Hello, {name}!");
}

fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;m);
}</code></pre> 
<p>如果 Rust 没有实现 Deref 强制转换，为了使用 <code>&amp;MyBox&lt;String&gt;</code> 类型的值调用 <code>hello</code>，则不得不编写示</p> 
<pre><code class="language-rust">fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;(*m)[..]);
}</code></pre> 
<p><code>(*m)</code> 将 <code>MyBox&lt;String&gt;</code> 解引用为 <code>String</code>。接着 <code>&amp;</code> 和 <code>[..]</code> 获取了整个 <code>String</code> 的字符串 slice 来匹配 <code>hello</code> 的签名。没有 Deref 强制转换所有这些符号混在一起将更难以读写和理解。Deref 强制转换使得 Rust 自动的帮我们处理这些转换。</p> 
<p>Rust 在发现类型和 trait 实现满足三种情况时会进行 Deref 强制转换：</p> 
<ul><li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;T</code> 到 <code>&amp;U</code>。</li><li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code>。</li><li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;U</code>。</li></ul> 
<p>头两个情况除了第二种实现了可变性之外是相同的：第一种情况表明如果有一个 <code>&amp;T</code>，而 <code>T</code> 实现了返回 <code>U</code> 类型的 <code>Deref</code>，则可以直接得到 <code>&amp;U</code>。第二种情况表明对于可变引用也有着相同的行为。</p> 
<p>第三个情况有些微妙：Rust 也会将可变引用强转为不可变引用。但是反之是 <strong>不可能</strong> 的：不可变引用永远也不能强转为可变引用。因为根据借用规则，如果有一个可变引用，其必须是这些数据的唯一引用（否则程序将无法编译）。将一个可变引用转换为不可变引用永远也不会打破借用规则。将不可变引用转换为可变引用则需要初始的不可变引用是数据唯一的不可变引用，而借用规则无法保证这一点。因此，Rust 无法假设将不可变引用转换为可变引用是可能的。</p> 
<p>指定在值离开作用域时应该执行的代码的方式是实现 <code>Drop</code> trait。<code>Drop</code> trait 要求实现一个叫做 <code>drop</code> 的方法，它获取一个 <code>self</code> 的可变引用。<strong><code><span style="background-color:#ffd900;">Drop</span></code><span style="background-color:#ffd900;"> trait 相当于C++的析构函数，离开作用域时自动执行</span></strong>。为了能够看出 Rust 何时调用 <code>drop</code>，下面示例使用 <code>println!</code> 语句实现 <code>drop</code>。</p> 
<pre><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
            println!("清理自定义智能指针的 data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("创建自定义智能指针.");
}</code></pre> 
<p>通过 std::mem::drop 提早丢弃值。有时需要提早清理某个值。一个例子是当使用智能指针管理锁时；你可能希望强制运行 <code>drop</code> 方法来释放锁以便作用域中的其他代码可以获取锁。</p> 
<pre><code class="language-rust">fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre> 
<p>Rust 不允许显式调用 <code>drop</code> 因为 Rust 仍然会在 <code>main</code> 的结尾对值自动调用 <code>drop</code>，这会导致一个 <strong>double free</strong> 错误，因为 Rust 会尝试清理相同的值两次。</p> 
<pre><code class="language-rust">use std::mem::drop;


struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre> 
<p></p> 
<h4>引用计数 智能指针 Rc&lt;T&gt;</h4> 
<p>当需要多个所有权时，可以使用 <code>Rc</code>（引用计数，Reference Counting 缩写）。<code>Rc</code> 跟踪引用的数量，这相当于包裹在 <code>Rc</code> 值的所有者的数量。Rc&lt;T&gt; 引用计数智能指针，允许在程序的多个部分之间只读地共享数据。</p> 
<p>每当克隆一个 <code>Rc</code> 时，<code>Rc</code> 的引用计数就会增加 1，而每当克隆得到的 <code>Rc</code> 退出作用域时，引用计数就会减少 1。当 <code>Rc</code> 的引用计数变为 0 时，这意味着已经没有所有者，<code>Rc</code> 和值两者都将被删除。</p> 
<p>克隆 <code>Rc</code> 从不执行深拷贝。克隆只创建另一个指向包裹值的指针，并增加计数。</p> 
<pre><code class="language-rust">use std::rc::Rc;

fn main() {
    let rc_examples = "Rc examples".to_string();
    {
        println!("--- rc_a is created ---");

        let rc_a: Rc&lt;String&gt; = Rc::new(rc_examples);
        println!("Reference Count of rc_a: {}", Rc::strong_count(&amp;rc_a));

        {
            println!("--- rc_a is cloned to rc_b ---");

            let rc_b: Rc&lt;String&gt; = Rc::clone(&amp;rc_a);
            println!("Reference Count of rc_b: {}", Rc::strong_count(&amp;rc_b));
            println!("Reference Count of rc_a: {}", Rc::strong_count(&amp;rc_a));

            // 如果两者内部的值相等的话，则两个 `Rc` 相等。
            println!("rc_a and rc_b are equal: {}", rc_a.eq(&amp;rc_b));

            // 我们可以直接使用值的方法
            println!("Length of the value inside rc_a: {}", rc_a.len());
            println!("Value of rc_b: {}", rc_b);

            println!("--- rc_b is dropped out of scope ---");
        }

        println!("Reference Count of rc_a: {}", Rc::strong_count(&amp;rc_a));

        println!("--- rc_a is dropped out of scope ---");
    }

    // 报错！`rc_examples` 已经移入 `rc_a`。
    // 而且当 `rc_a` 被删时，`rc_examples` 也被一起删除。
    // println!("rc_examples: {}", rc_examples);
    // 试一试 ^ 注释掉此行代码
}
</code></pre> 
<p>大部分情况下所有权是非常明确的：可以准确地知道哪个变量拥有某个值。然而，有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的节点，而这个节点从概念上讲为所有指向它的边所拥有。节点直到没有任何边指向它之前都不应该被清理因此也没有所有者。</p> 
<p>为了启用多所有权需要显式地使用 Rust 类型 <code>Rc&lt;T&gt;</code>，其为 <strong>引用计数</strong>（<em>reference counting</em>）的缩写。引用计数意味着记录一个值的引用数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。</p> 
<p>可以将其想象为客厅中的电视。当一个人进来看电视时，他打开电视。其他人也可以进来看电视。当最后一个人离开房间时，他关掉电视因为它不再被使用了。如果某人在其他人还在看的时候就关掉了电视，正在看电视的人肯定会抓狂的！</p> 
<p>注意 <code>Rc&lt;T&gt;</code> 只能用于单线程场景；第十六章并发会涉及到如何在多线程程序中进行引用计数。</p> 
<p>使用 Rc&lt;T&gt; 共享数据。创建两个共享第三个列表所有权的列表，如图 </p> 
<p class="img-center"><img alt="" height="267" src="https://images2.imgbox.com/a2/b9/bBiSlxe9_o.png" width="682"></p> 
<p>两个列表，<code>b</code> 和 <code>c</code>, 共享第三个列表 <code>a</code> 的所有权。列表 <code>a</code> 包含 5 之后是 10，之后是另两个列表：<code>b</code> 从 3 开始而 <code>c</code> 从 4 开始。<code>b</code> 和 <code>c</code> 会接上包含 5 和 10 的列表 <code>a</code>。换句话说，这两个列表会尝试共享第一个列表所包含的 5 和 10。</p> 
<p>错误代码：</p> 
<pre><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre> 
<p><code>Cons</code> 成员拥有其储存的数据，所以当创建 <code>b</code> 列表时，<code>a</code> 被移动进了 <code>b</code> 这样 <code>b</code> 就拥有了 <code>a</code>。接着当再次尝试使用 <code>a</code> 创建 <code>c</code> 时，这不被允许，因为 <code>a</code> 的所有权已经被移动。</p> 
<p>可以改变 <code>Cons</code> 的定义来存放一个引用，不过接着必须指定生命周期参数。通过指定生命周期参数，表明列表中的每一个元素都至少与列表本身存在的一样久。也可以修改 <code>List</code> 的定义为使用 <code>Rc&lt;T&gt;</code> 代替 <code>Box&lt;T&gt;，</code>现在每一个 <code>Cons</code> 变量都包含一个值和一个指向 <code>List</code> 的 <code>Rc&lt;T&gt;</code>。当创建 <code>b</code> 时，不同于获取 <code>a</code> 的所有权，这里会克隆 <code>a</code> 所包含的 <code>Rc&lt;List&gt;</code>，这会将引用计数从 1 增加到 2 并允许 <code>a</code> 和 <code>b</code> 共享 <code>Rc&lt;List&gt;</code> 中数据的所有权。创建 <code>c</code> 时也会克隆 <code>a</code>，这会将引用计数从 2 增加为 3。每次调用 <code>Rc::clone</code>，<code>Rc&lt;List&gt;</code> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。</p> 
<pre><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre> 
<p>克隆 Rc&lt;T&gt; 会增加引用计数</p> 
<pre><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;


fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("创建a后的引用计数 = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("创建b后的引用计数 = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("创建c后的引用计数 = {}", Rc::strong_count(&amp;a));
    }
    println!("退出\"块作用域\"后的引用计数 = {}", Rc::strong_count(&amp;a));
}</code></pre> 
<p>在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 <code>Rc::strong_count</code> 函数获得。这个函数叫做 <code>strong_count</code> 而不是 <code>count</code> 是因为 <code>Rc&lt;T&gt;</code> 也有 <code>weak_count</code>；在 <a href="https://kaisery.github.io/trpl-zh-cn/ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt" rel="nofollow" title="“避免引用循环：将 Rc&lt;T&gt; 变为 Weak&lt;T&gt;”">“避免引用循环：将 Rc&lt;T&gt; 变为 Weak&lt;T&gt;”</a> 部分会讲解 <code>weak_count</code> 的用途。</p> 
<p>选择 <code>Box&lt;T&gt;</code>，<code>Rc&lt;T&gt;</code> 或 <code>RefCell&lt;T&gt;</code> 的理由：</p> 
<ul><li><code>Rc&lt;T&gt;</code> 允许相同数据有多个所有者；<code>Box&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 有单一所有者。</li><li><code>Box&lt;T&gt;</code> 允许在编译时执行不可变或可变借用检查；<code>Rc&lt;T&gt;</code>仅允许在编译时执行不可变借用检查；<code>RefCell&lt;T&gt;</code> 允许在运行时执行不可变或可变借用检查。</li><li>因为 <code>RefCell&lt;T&gt;</code> 允许在运行时执行可变借用检查，所以在即便 <code>RefCell&lt;T&gt;</code> 自身是不可变的情况下也可以修改其内部的值。</li></ul> 
<p></p> 
<h4>共享引用计数 Arc</h4> 
<p>当线程之间所有权需要共享时，可以使用<code>Arc</code>（共享引用计数，Atomic Reference Counted 缩写）可以使用。这个结构通过 <code>Clone</code> 实现可以为内存堆中的值的位置创建一个引用指针，同时增加引用计数器。由于它在线程之间共享所有权，因此当指向某个值的最后一个引用指针退出作用域时，该变量将被删除。</p> 
<pre><code class="language-rust">use std::sync::Arc;
use std::thread;

fn main() {
    // 这个变量声明用来指定其值的地方。
    let apple = Arc::new("the same apple");

    for _ in 0..10 {
        // 这里没有数值说明，因为它是一个指向内存堆中引用的指针。
        let apple = Arc::clone(&amp;apple);

        thread::spawn(move || {
            // 由于使用了Arc，线程可以使用分配在 `Arc` 变量指针位置的值来生成。
            println!("{:?}", apple);
        });
    }
}

</code></pre> 
<p></p> 
<p></p> 
<h4>RefCell&lt;T&gt;</h4> 
<p>在不可变值内部改变值就是 <strong>内部可变性</strong> 模式。</p> 
<p>结合 Rc&lt;T&gt; 和 RefCell&lt;T&gt; 来拥有多个可变数据所有者。<code>RefCell&lt;T&gt;</code> 的一个常见用法是与 <code>Rc&lt;T&gt;</code> 结合。 <code>Rc&lt;T&gt;</code> 允许对相同数据有多个所有者，不过只能提供数据的不可变访问。如果有一个储存了 <code>RefCell&lt;T&gt;</code> 的 <code>Rc&lt;T&gt;</code> 的话，就可以得到有多个所有者 <strong>并且</strong> 可以修改的值了！</p> 
<p>示例：cons list 的例子中使用 <code>Rc&lt;T&gt;</code> 使得多个列表共享另一个列表的所有权。因为 <code>Rc&lt;T&gt;</code> 只存放不可变值，所以一旦创建了这些列表值后就不能修改。现在加入 <code>RefCell&lt;T&gt;</code> 来获得修改列表中值的能力。就可以修改所有列表中的值了：</p> 
<pre><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}</code></pre> 
<p>创建了一个 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> 实例并储存在变量 <code>value</code> 中以便之后直接访问。接着在 <code>a</code> 中用包含 <code>value</code> 的 <code>Cons</code> 成员创建了一个 <code>List</code>。需要克隆 <code>value</code> 以便 <code>a</code> 和 <code>value</code> 都能拥有其内部值 <code>5</code> 的所有权，而不是将所有权从 <code>value</code> 移动到 <code>a</code> 或者让 <code>a</code> 借用 <code>value</code>。</p> 
<p>我们将列表 <code>a</code> 封装进了 <code>Rc&lt;T&gt;</code> 这样当创建列表 <code>b</code> 和 <code>c</code> 时，它们都可以引用 <code>a</code>，正如示例 15-18 一样。</p> 
<p>一旦创建了列表 <code>a</code>、<code>b</code> 和 <code>c</code>，我们将 <code>value</code> 的值加 10。为此对 <code>value</code> 调用了 <code>borrow_mut</code>，这里使用了第五章讨论的自动解引用功能（<a href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#--%E8%BF%90%E7%AE%97%E7%AC%A6%E5%88%B0%E5%93%AA%E5%8E%BB%E4%BA%86" rel="nofollow" title="“-&gt; 运算符到哪去了？”">“-&gt; 运算符到哪去了？”</a> 部分）来解引用 <code>Rc&lt;T&gt;</code> 以获取其内部的 <code>RefCell&lt;T&gt;</code> 值。<code>borrow_mut</code> 方法返回 <code>RefMut&lt;T&gt;</code> 智能指针，可以对其使用解引用运算符并修改其内部值。</p> 
<p>当我们打印出 <code>a</code>、<code>b</code> 和 <code>c</code> 时，可以看到它们都拥有修改后的值 15 而不是 5：</p> 
<p>通过使用 <code>RefCell&lt;T&gt;</code>，我们可以拥有一个表面上不可变的 <code>List</code>，不过可以使用 <code>RefCell&lt;T&gt;</code> 中提供内部可变性的方法来在需要时修改数据。<code>RefCell&lt;T&gt;</code> 的运行时借用规则检查也确实保护我们免于出现数据竞争——有时为了数据结构的灵活性而付出一些性能是值得的。注意 <code>RefCell&lt;T&gt;</code> 不能用于多线程代码！<code>Mutex&lt;T&gt;</code> 是一个线程安全版本的 <code>RefCell&lt;T&gt;</code> ，</p> 
<p></p> 
<h4><strong>循环引用</strong></h4> 
<p>在 <code>a</code> 中创建了一个列表，一个指向 <code>a</code> 中列表的 <code>b</code> 列表，接着修改 <code>a</code> 中的列表指向 <code>b</code> 中的列表，这会创建一个引用循环。在这个过程的多个位置有 <code>println!</code> 语句展示引用计数。</p> 
<pre><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&amp;a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&amp;a));
    println!("b initial rc count = {}", Rc::strong_count(&amp;b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&amp;b));
    println!("a rc count after changing a = {}", Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}</code></pre> 
<p>在变量 <code>a</code> 中创建了一个 <code>Rc&lt;List&gt;</code> 实例来存放初值为 <code>5, Nil</code> 的 <code>List</code> 值。接着在变量 <code>b</code> 中创建了存放包含值 10 和指向列表 <code>a</code> 的 <code>List</code> 的另一个 <code>Rc&lt;List&gt;</code> 实例。</p> 
<p>最后，修改 <code>a</code> 使其指向 <code>b</code> 而不是 <code>Nil</code>，这就创建了一个循环。为此需要使用 <code>tail</code> 方法获取 <code>a</code> 中 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> 的引用，并放入变量 <code>link</code> 中。接着使用 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> 的 <code>borrow_mut</code> 方法将其值从存放 <code>Nil</code> 的 <code>Rc&lt;List&gt;</code> 修改为 <code>b</code> 中的 <code>Rc&lt;List&gt;</code>。</p> 
<blockquote> 
 <p>$ cargo run<br>    Compiling cons-list v0.1.0 (file:///projects/cons-list)<br>     Finished dev [unoptimized + debuginfo] target(s) in 0.53s<br>      Running `target/debug/cons-list`<br> a initial rc count = 1<br> a next item = Some(RefCell { value: Nil })<br> a rc count after b creation = 2<br> b initial rc count = 1<br> b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })<br> b rc count after changing a = 2<br> a rc count after changing a = 2</p> 
</blockquote> 
<p>可以看到将列表 <code>a</code> 修改为指向 <code>b</code> 之后， <code>a</code> 和 <code>b</code> 中的 <code>Rc&lt;List&gt;</code> 实例的引用计数都是 2。在 <code>main</code> 的结尾，Rust 丢弃 <code>b</code>，这会使 <code>b</code> <code>Rc&lt;List&gt;</code> 实例的引用计数从 2 减为 1。然而，<code>b</code> <code>Rc&lt;List&gt;</code> 不能被回收，因为其引用计数是 1 而不是 0。接下来 Rust 会丢弃 <code>a</code> 将 <code>a</code> <code>Rc&lt;List&gt;</code> 实例的引用计数从 2 减为 1。这个实例也不能被回收，因为 <code>b</code> <code>Rc&lt;List&gt;</code> 实例依然引用它，所以其引用计数是 1。这些列表的内存将永远保持未被回收的状态。如图所示的引用循环：</p> 
<p><img alt="" height="435" src="https://images2.imgbox.com/63/7f/vCOyUyWZ_o.png" width="771"></p> 
<p>如果取消最后 <code>println!</code> 的注释并运行程序，Rust 会尝试打印出 <code>a</code> 指向 <code>b</code> 指向 <code>a</code> 这样的循环直到栈溢出。</p> 
<p></p> 
<h4>Weak&lt;T&gt;</h4> 
<p>避免引用循环：将 Rc&lt;T&gt; 变为 Weak&lt;T&gt;。调用 <code>Rc::clone</code> 会增加 <code>Rc&lt;T&gt;</code> 实例的 <code>strong_count</code>，和只在其 <code>strong_count</code> 为 0 时才会被清理的 <code>Rc&lt;T&gt;</code> 实例。你也可以通过调用 <code>Rc::downgrade</code> 并传递 <code>Rc&lt;T&gt;</code> 实例的引用来创建其值的 <strong>弱引用</strong>（<em>weak reference</em>）。强引用代表如何共享 <code>Rc&lt;T&gt;</code> 实例的所有权。弱引用并不属于所有权关系，当 <code>Rc&lt;T&gt;</code> 实例被清理时其计数没有影响。它们不会造成引用循环，因为<strong><span style="background-color:#ffd900;">任何涉及弱引用的循环会在其相关的值的强引用计数为 0 时被打断</span></strong>。</p> 
<p>调用 <code>Rc::downgrade</code> 时会得到 <code>Weak&lt;T&gt;</code> 类型的智能指针。不同于将 <code>Rc&lt;T&gt;</code> 实例的 <code>strong_count</code> 加 1，调用 <code>Rc::downgrade</code> 会将 <code>weak_count</code> 加 1。<code>Rc&lt;T&gt;</code> 类型使用 <code>weak_count</code> 来记录其存在多少个 <code>Weak&lt;T&gt;</code> 引用，类似于 <code>strong_count</code>。其区别在于 <code>weak_count</code> 无需计数为 0 就能使 <code>Rc&lt;T&gt;</code> 实例被清理。</p> 
<p>强引用代表如何共享 <code>Rc&lt;T&gt;</code> 实例的所有权，但弱引用并不属于所有权关系。它们不会造成引用循环，因为任何弱引用的循环会在其相关的强引用计数为 0 时被打断。</p> 
<p>创建树形数据结构：带有子节点的 Node</p> 
<blockquote> 
 <p>use std::cell::RefCell;<br> use std::rc::Rc;</p> 
 <p>#[derive(Debug)]<br> struct Node {<!-- --><br>     value: i32,<br>     children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,<br> }</p> 
</blockquote> 
<p>希望 <code>Node</code> 能够拥有其子节点，同时也希望能将所有权共享给变量，以便可以直接访问树中的每一个 <code>Node</code>，为此 <code>Vec&lt;T&gt;</code> 的项的类型被定义为 <code>Rc&lt;Node&gt;</code>。我们还希望能修改其他节点的子节点，所以 <code>children</code> 中 <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> 被放进了 <code>RefCell&lt;T&gt;</code>。</p> 
<p>接下来，使用此结构体定义来创建一个叫做 <code>leaf</code> 的带有值 3 且没有子节点的 <code>Node</code> 实例，和另一个带有值 5 并以 <code>leaf</code> 作为子节点的实例 <code>branch</code></p> 
<pre><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}


fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}</code></pre> 
<p>一个节点就能够引用其父节点，但不拥有其父节点。</p> 
<p>可视化 strong_count 和 weak_count 的改变</p> 
<pre><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}


fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre> 
<p>一旦创建了 <code>leaf</code>，其 <code>Rc&lt;Node&gt;</code> 的强引用计数为 1，弱引用计数为 0。在内部作用域中创建了 <code>branch</code> 并与 <code>leaf</code> 相关联，此时 <code>branch</code> 中 <code>Rc&lt;Node&gt;</code> 的强引用计数为 1，弱引用计数为 1（因为 <code>leaf.parent</code> 通过 <code>Weak&lt;Node&gt;</code> 指向 <code>branch</code>）。这里 <code>leaf</code> 的强引用计数为 2，因为现在 <code>branch</code> 的 <code>branch.children</code> 中储存了 <code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 的拷贝，不过弱引用计数仍然为 0。</p> 
<p>当内部作用域结束时，<code>branch</code> 离开作用域，<code>Rc&lt;Node&gt;</code> 的强引用计数减少为 0，所以其 <code>Node</code> 被丢弃。来自 <code>leaf.parent</code> 的弱引用计数 1 与 <code>Node</code> 是否被丢弃无关，所以并没有产生任何内存泄漏！</p> 
<p>如果在内部作用域结束后尝试访问 <code>leaf</code> 的父节点，会再次得到 <code>None</code>。在程序的结尾，<code>leaf</code> 中 <code>Rc&lt;Node&gt;</code> 的强引用计数为 1，弱引用计数为 0，因为现在 <code>leaf</code> 又是 <code>Rc&lt;Node&gt;</code> 唯一的引用了。</p> 
<p>所有这些管理计数和值的逻辑都内建于 <code>Rc&lt;T&gt;</code> 和 <code>Weak&lt;T&gt;</code> 以及它们的 <code>Drop</code> trait 实现中。通过在 <code>Node</code> 定义中指定从子节点到父节点的关系为一个<code>Weak&lt;T&gt;</code>引用，就能够拥有父节点和子节点之间的双向引用而不会造成引用循环和内存泄漏。</p> 
<p></p> 
<h3>并发</h3> 
<p>安全且高效地处理并发编程是 Rust 的另一个主要目标。</p> 
<ul><li><strong>并发编程</strong>（<em>Concurrent programming</em>），代表程序的不同部分相互独立地执行，</li><li><strong>并行编程</strong>（<em>parallel programming</em>）代表程序不同部分同时执行，</li></ul> 
<blockquote> 
 <p>这两个概念随着计算机越来越多的利用多处理器的优势而显得愈发重要。</p> 
 <p>注意：出于简洁的考虑，将很多问题归类为 <strong>并发</strong>，而不是更准确的区分 <strong>并发和（或）并行</strong>。如果这是一本专注于并发和/或并行的书，我们肯定会更加精确的。对于本章，当我们谈到 <strong>并发</strong> 时，请自行脑内替换为 <strong>并发和（或）并行</strong>。</p> 
</blockquote> 
<p>涉及到的内容：</p> 
<ul><li>如何创建线程来同时运行多段代码。</li><li><strong>消息传递</strong>（<em>Message passing</em>）并发，其中信道（channel）被用来在线程间传递消息。</li><li><strong>共享状态</strong>（<em>Shared state</em>）并发，其中多个线程可以访问同一片数据。</li><li><code>Sync</code> 和 <code>Send</code> trait，将 Rust 的并发保证扩展到用户定义的以及标准库提供的类型中。</li></ul> 
<p>在大部分现代操作系统中，已执行程序的代码在一个 <strong>进程</strong>（<em>process</em>）中运行，操作系统则会负责管理多个进程。在程序内部，也可以拥有多个同时运行的独立部分。这些运行这些独立部分的功能被称为 <strong>线程</strong>（<em>threads</em>）。例如，web 服务器可以有多个线程以便可以同时响应多个请求。</p> 
<p>将程序中的计算拆分进多个线程可以改善性能，因为程序可以同时进行多个任务，不过这也会增加复杂性。因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：</p> 
<ul><li>竞态条件（Race conditions），多个线程以不一致的顺序访问数据或资源</li><li>死锁（Deadlocks），两个线程相互等待对方，这会阻止两者继续运行</li><li>只会发生在特定情况且难以稳定重现和修复的 bug</li></ul> 
<p></p> 
<h4>使用 spawn 创建新线程。</h4> 
<p>为了创建一个新线程，需要调用 <code>thread::spawn</code> 函数并传递一个闭包，并在其中包含希望在新线程运行的代码。</p> 
<pre><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre> 
<p>注意当 Rust 程序的主线程结束时，新线程也会结束，而不管其是否执行完毕。</p> 
<p><code>thread::sleep</code> 调用强制线程停止执行一小段时间，这会允许其他不同的线程运行。这些线程可能会轮流运行，不过并不保证如此：这依赖操作系统如何调度线程。在这里，主线程首先打印，即便新创建线程的打印语句位于程序的开头，甚至即便我们告诉新建的线程打印直到 <code>i</code> 等于 9，它在主线程结束之前也只打印到了 5。</p> 
<pre><code class="language-rust">use std::thread;

static NTHREADS: i32 = 10;

// 这是主（`main`）线程
fn main() {
    // 提供一个 vector 来存放所创建的子线程（children）。
    let mut children = vec![];

    for i in 0..NTHREADS {
        // 启动（spin up）另一个线程
        children.push(thread::spawn(move || {
            println!("this is thread number {}", i)
        }));
    }

    for child in children {
        // 等待线程结束。返回一个结果。
        let _ = child.join();
    }
}
</code></pre> 
<p>把它们分成几块，放入不同的线程。每个线程会把自己那一块数字的每一位加起来，之后我们再把每个线程提供的结果再加起来。</p> 
<pre><code class="language-rust">use std::thread;

// 这是 `main` 线程
fn main() {

    // 这是我们要处理的数据。
    // 我们会通过线程实现 map-reduce 算法，从而计算每一位的和
    // 每个用空白符隔开的块都会分配给单独的线程来处理
    //
    // 试一试：插入空格，看看输出会怎样变化！
    let data = "86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668";

    // 创建一个向量，用于储存将要创建的子线程
    let mut children = vec![];

    /*************************************************************************
     * "Map" 阶段
     *
     * 把数据分段，并进行初始化处理
     ************************************************************************/

    // 把数据分段，每段将会单独计算
    // 每段都是完整数据的一个引用（&amp;str）
    let chunked_data = data.split_whitespace();

    // 对分段的数据进行迭代。
    // .enumerate() 会把当前的迭代计数与被迭代的元素以元组 (index, element)
    // 的形式返回。接着立即使用 “解构赋值” 将该元组解构成两个变量，
    // `i` 和 `data_segment`。
    for (i, data_segment) in chunked_data.enumerate() {
        println!("data segment {} is \"{}\"", i, data_segment);

        // 用单独的线程处理每一段数据
        //
        // spawn() 返回新线程的句柄（handle），我们必须拥有句柄，
        // 才能获取线程的返回值。
        //
        // 'move || -&gt; u32' 语法表示该闭包：
        // * 没有参数（'||'）
        // * 会获取所捕获变量的所有权（'move'）
        // * 返回无符号 32 位整数（'-&gt; u32'）
        //
        // Rust 可以根据闭包的内容推断出 '-&gt; u32'，所以我们可以不写它。
        //
        // 试一试：删除 'move'，看看会发生什么
        children.push(thread::spawn(move || -&gt; u32 {
            // 计算该段的每一位的和：
            let result = data_segment
                        // 对该段中的字符进行迭代..
                        .chars()
                        // ..把字符转成数字..
                        .map(|c| c.to_digit(10).expect("should be a digit"))
                        // ..对返回的数字类型的迭代器求和
                        .sum();

            // println! 会锁住标准输出，这样各线程打印的内容不会交错在一起
            println!("processed segment {}, result={}", i, result);

            // 不需要 “return”，因为 Rust 是一种 “表达式语言”，每个代码块中
            // 最后求值的表达式就是代码块的值。
            result

        }));
    }


    /*************************************************************************
     * "Reduce" 阶段
     *
     * 收集中间结果，得出最终结果
     ************************************************************************/

    // 把每个线程产生的中间结果收入一个新的向量中
    let mut intermediate_sums = vec![];
    for child in children {
        // 收集每个子线程的返回值
        let intermediate_sum = child.join().unwrap();
        intermediate_sums.push(intermediate_sum);
    }

    // 把所有中间结果加起来，得到最终结果
    //
    // 我们用 “涡轮鱼” 写法 ::&lt;&gt; 来为 sum() 提供类型提示。
    //
    // 试一试：不使用涡轮鱼写法，而是显式地指定 intermediate_sums 的类型
    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();

    println!("Final sum result: {}", final_result);
}


</code></pre> 
<p></p> 
<h4>使用 join 等待所有线程结束</h4> 
<p>由于主线程结束，上面示例代码大部分时候不光会提早结束新建线程，因为无法保证线程运行的顺序，我们甚至不能实际保证新建线程会被执行！可以通过将 <code>thread::spawn</code> 的返回值储存在变量中来修复新建线程部分没有执行或者完全没有执行的问题。<code>thread::spawn</code> 的返回值类型是 <code>JoinHandle</code>。<code>JoinHandle</code> 是一个拥有所有权的值，当对其调用 <code>join</code> 方法时，它会等待其线程结束。将 <code>join</code> 调用放在了主线程的 <code>for</code> 循环之后</p> 
<pre><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre> 
<p>调用 handle 的 <code>join</code> 会阻塞当前线程直到 handle 所代表的线程结束。<strong>阻塞</strong>（<em>Blocking</em>）线程意味着阻止该线程执行工作或退出。上面代码中，两个线程仍然会交替执行，不过主线程会由于 <code>handle.join()</code> 调用会等待直到新建线程执行完毕。</p> 
<p><code>move</code> 关键字经常用于传递给 <code>thread::spawn</code> 的闭包，因为闭包会获取从环境中取得的值的所有权，因此会将这些值的所有权从一个线程传送到另一个线程。在 <a href="https://kaisery.github.io/trpl-zh-cn/ch13-01-closures.html#%E9%97%AD%E5%8C%85%E4%BC%9A%E6%8D%95%E8%8E%B7%E5%85%B6%E7%8E%AF%E5%A2%83" rel="nofollow" title="“闭包会捕获其环境”">“闭包会捕获其环境”</a> 部分讨论了闭包上下文中的 <code>move</code>。现在专注于 <code>move</code> 和 <code>thread::spawn</code> 之间的交互。</p> 
<p>使用 <code>move</code> 关键字强制闭包获取其使用的环境值的所有权。这个技巧在创建新线程将值的所有权从一个线程移动到另一个线程时最为实用。</p> 
<p>闭包之前增加 <code>move</code> 关键字，我们强制闭包获取其使用的值的所有权，</p> 
<pre><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}</code></pre> 
<p></p> 
<h4>线程间 通信 (<strong>消息传递</strong>)</h4> 
<p>通过 <strong>消息传递</strong>（<em>message passing</em>）确保安全并发。这个思想来源于 <a href="https://golang.org/doc/effective_go.html#concurrency" rel="nofollow" title="Go 编程语言文档中">Go 编程语言文档中</a> 的口号：“不要通过共享内存来通讯；而是通过通讯来共享内存。”（“Do not communicate by sharing memory; instead, share memory by communicating.”）<strong>。</strong><strong><span style="background-color:#ffd900;">Rust 为线程之间的通信提供了异步的通道（</span><code><span style="background-color:#ffd900;">channel</span></code><span style="background-color:#ffd900;">）。通道允许两个端点之间信息的单向流动：</span><code><span style="background-color:#ffd900;">Sender</span></code><span style="background-color:#ffd900;">（发送端） 和 </span><code><span style="background-color:#ffd900;">Receiver</span></code><span style="background-color:#ffd900;">（接收端）</span></strong>。<strong><span style="color:#fe2c24;">信道都是单所有权，因为一旦将一个值传送到信道中，将无法再使用这个值</span></strong></p> 
<pre><code class="language-rust">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // 通道有两个端点：`Sender&lt;T&gt;` 和 `Receiver&lt;T&gt;`，其中 `T` 是要发送
    // 的消息的类型（类型标注是可选的）
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();

    for id in 0..NTHREADS {
        // sender 端可被复制
        let thread_tx = tx.clone();

        // 每个线程都将通过通道来发送它的 id
        thread::spawn(move || {
            // 被创建的线程取得 `thread_tx` 的所有权
            // 每个线程都把消息放在通道的消息队列中
            thread_tx.send(id).unwrap();

            // 发送是一个非阻塞（non-blocking）操作，线程将在发送完消息后
            // 会立即继续进行
            println!("thread {} finished", id);
        });
    }

    // 所有消息都在此处被收集
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // `recv` 方法从通道中拿到一个消息
        // 若无可用消息的话，`recv` 将阻止当前线程
        ids.push(rx.recv());
    }

    // 显示消息被发送的次序
    println!("{:?}", ids);
}
</code></pre> 
<p>示例：在一个线程生成值向信道发送，而在另一个线程会接收值并打印出来。一旦你熟悉了这项技术，你就可以将信道用于任何相互通信的任何线程，例如一个聊天系统，或利用很多线程进行分布式计算并将部分计算结果发送给一个线程进行聚合。</p> 
<pre><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}</code></pre> 
<p>使用 <code>thread::spawn</code> 来创建一个新线程并使用 <code>move</code> 将 <code>tx</code> 移动到闭包中这样新建线程就拥有 <code>tx</code> 了。新建线程需要拥有信道的发送端以便能向信道发送消息。信道的发送端有一个 <code>send</code> 方法用来获取需要放入信道的值。<code>send</code> 方法返回一个 <code>Result&lt;T, E&gt;</code> 类型，所以如果接收端已经被丢弃了，将没有发送值的目标，所以发送操作会返回错误。在这个例子中，出错的时候调用 <code>unwrap</code> 产生 panic。不过对于一个真实程序，需要合理地处理它</p> 
<p>信道的接收者有两个有用的方法：<code>recv</code> 和 <code>try_recv</code>。这里，我们使用了 <code>recv</code>，它是 <em>receive</em> 的缩写。这个方法会阻塞主线程执行直到从信道中接收一个值。一旦发送了一个值，<code>recv</code> 会在一个 <code>Result&lt;T, E&gt;</code> 中返回它。当信道发送端关闭，<code>recv</code> 会返回一个错误表明不会再有新的值到来了。</p> 
<p><code>try_recv</code> 不会阻塞，相反它立刻返回一个 <code>Result&lt;T, E&gt;</code>：<code>Ok</code> 值包含可用的信息，而 <code>Err</code> 值代表此时没有任何消息。如果线程在等待消息过程中还有其他工作时使用 <code>try_recv</code> 很有用：可以编写一个循环来频繁调用 <code>try_recv</code>，在有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查。</p> 
<p>出于简单的考虑，这个例子使用了 <code>recv</code>；主线程中除了等待消息之外没有任何其他工作，所以阻塞主线程是合适的。</p> 
<p><strong>信道与所有权转移。</strong></p> 
<blockquote> 
 <p>所有权规则在消息传递中扮演了重要角色，其有助于我们编写安全的并发代码。也可以防止并发编程中的错误。</p> 
 <p><code>send</code> 函数获取其参数的所有权并移动这个值归接收者所有。这可以防止在发送后再次意外地使用这个值；所有权系统检查一切是否合乎规则。</p> 
 <p>示例：信道与所有权如何一同协作以避免产生问题：我们将尝试在新建线程中的信道中发送完 <code>val</code> 值 <strong>之后</strong> 再使用它。</p> 
</blockquote> 
<pre><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {}", val);
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}</code></pre> 
<p><strong>发送多个值并观察接收者的等待</strong></p> 
<pre><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}</code></pre> 
<p>这一次，在新建线程中有一个字符串 vector 希望发送到主线程。我们遍历它们，单独的发送每一个字符串并通过一个 <code>Duration</code> 值调用 <code>thread::sleep</code> 函数来暂停一秒。</p> 
<p>在主线程中，不再显式调用 <code>recv</code> 函数：而是将 <code>rx</code> 当作一个迭代器。对于每一个接收到的值，我们将其打印出来。当信道被关闭时，迭代器也将结束。</p> 
<p><strong>通过克隆发送者来创建多个生产者</strong></p> 
<pre><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }

    // --snip--
}</code></pre> 
<p>在创建新线程之前，我们对发送者调用了 <code>clone</code> 方法。这会给我们一个可以传递给第一个新建线程的发送端句柄。我们会将原始的信道发送端传递给第二个新建线程。这样就会有两个线程，每个线程将向信道的接收端发送不同的消息。</p> 
<p><strong>共享状态 实现并发</strong></p> 
<blockquote> 
 <p>虽然消息传递是一个很好的处理并发的方式，但并不是唯一一个。另一种方式是让多个线程拥有相同的共享数据。再一次思考一下 Go 编程语言文档中口号的这一部分：“不要通过共享内存来通讯”（“do not communicate by sharing memory.”）：</p> 
 <p>在某种程度上，任何编程语言中的信道都类似于单所有权，因为一旦将一个值传送到信道中，将无法再使用这个值。共享内存类似于多所有权：多个线程可以同时访问相同的内存位置。介绍智能指针时，如何使得多所有权成为可能，然而这会增加额外的复杂性，因为需要以某种方式管理这些不同的所有者。Rust 的类型系统和所有权规则极大的协助了正确地管理这些所有权。作为一个例子，让我们看看互斥器，一个更为常见的共享内存并发原语。</p> 
</blockquote> 
<p></p> 
<h4>互斥锁</h4> 
<p><strong>互斥器</strong>（<em>mutex</em>）是 <em>mutual exclusion</em> 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 <strong>锁</strong>（<em>lock</em>）来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统 <strong>保护</strong>（<em>guarding</em>）其数据。</p> 
<p>作为一个现实中互斥器的例子，想象一下在某个会议的一次小组座谈会中，只有一个麦克风。如果一位成员要发言，他必须请求或表示希望使用麦克风。一旦得到了麦克风，他可以畅所欲言，然后将麦克风交给下一位希望讲话的成员。如果一位成员结束发言后忘记将麦克风交还，其他人将无法发言。如果对共享麦克风的管理出现了问题，座谈会将无法如期进行！</p> 
<p>正确的管理互斥器异常复杂，这也是许多人之所以热衷于信道的原因。然而，在 Rust 中，得益于类型系统和所有权，不会在锁和解锁上出错。</p> 
<p><span style="color:#fe2c24;"><strong>多线程和多所有权</strong></span></p> 
<pre><code class="language-rust">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre> 
<p><strong>直接报错</strong>，因为 <strong><code><span style="background-color:#ffd900;">Rc&lt;T&gt;</span></code><span style="background-color:#ffd900;"> 并不能安全的在线程间共享</span></strong>。当 <code>Rc&lt;T&gt;</code> 管理引用计数时，它必须在每一个 <code>clone</code> 调用时增加计数，并在每一个克隆被丢弃时减少计数。<code>Rc&lt;T&gt;</code> 并没有使用任何并发原语，来确保改变计数的操作不会被其他线程打断。在计数出错时可能会导致诡异的 bug，比如可能会造成内存泄漏，或在使用结束之前就丢弃一个值。我们所需要的是一个完全类似 <code>Rc&lt;T&gt;</code>，又以一种线程安全的方式改变引用计数的类型。</p> 
<p><strong><span style="background-color:#ffd900;">原子引用计数 Arc&lt;T&gt;</span></strong>。<code>Arc&lt;T&gt;</code> <strong>正是</strong> 这么一个类似 <code>Rc&lt;T&gt;</code> 并可以安全的用于并发环境的类型。字母 “a” 代表 <strong>原子性</strong>（<em>atomic</em>），所以这是一个 <strong>原子引用计数</strong>（<em>atomically reference counted</em>）类型。原子性是另一类这里还未涉及到的并发原语：请查看标准库中 <a href="https://doc.rust-lang.org/std/sync/atomic/index.html" rel="nofollow" title="std::sync::atomic">std::sync::atomic</a> 的文档来获取更多细节。目前我们只需要知道原子类就像基本类型一样可以安全的在线程间共享。</p> 
<pre><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre> 
<p><strong>使用 Sync 和 Send trait 的可扩展并发</strong></p> 
<blockquote> 
 <p>Rust 的并发模型中一个有趣的方面是：语言本身对并发知之 <strong>甚少</strong>。我们之前讨论的几乎所有内容，都属于标准库，而不是语言本身的内容。由于不需要语言提供并发相关的基础设施，并发方案不受标准库或语言所限：我们可以编写自己的或使用别人编写的并发功能。</p> 
 <p>然而有两个并发概念是内嵌于语言中的：<code>std::marker</code> 中的 <code>Sync</code> 和 <code>Send</code> trait。</p> 
</blockquote> 
<p>因为 Rust 本身很少有处理并发的部分内容，有很多的并发方案都由 crate 实现。它们比标准库要发展的更快；请在网上搜索当前最新的用于多线程场景的 crate。</p> 
<p></p> 
<h4>子进程</h4> 
<p><code>process::Output</code> 结构体表示已结束的子进程（child process）的输出，而 <code>process::Command</code> 结构体是一个进程创建者（process builder）。</p> 
<pre><code class="language-rust">use std::process::Command;

fn main() {
    let output = Command::new("rustc")
        .arg("--version")
        .output().unwrap_or_else(|e| {
        panic!("failed to execute process: {}", e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!("rustc succeeded and stdout was:\n{}", s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!("rustc failed and stderr was:\n{}", s);
    }
}
</code></pre> 
<p></p> 
<h4>管道</h4> 
<p><code>std::Child</code> 结构体代表了一个正在运行的子进程，它暴露了 <code>stdin</code>（标准输入），<code>stdout</code>（标准输出）和 <code>stderr</code>（标准错误）句柄，从而可以通过管道与所代表的进程交互。</p> 
<pre><code class="language-rust">use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
    "the quick brown fox jumped over the lazy dog\n";

fn main() {
    // 启动 `wc` 命令
    let process = match Command::new("wc")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn() {
        Err(why) =&gt; panic!("couldn't spawn wc: {:?}", why),
        Ok(process) =&gt; process,
    };

    // 将字符串写入 `wc` 的 `stdin`。
    //
    // `stdin` 拥有 `Option&lt;ChildStdin&gt;` 类型，不过我们已经知道这个实例不为空值，
    // 因而可以直接 `unwrap 它。
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!("couldn't write to wc stdin: {:?}", why),
        Ok(_) =&gt; println!("sent pangram to wc"),
    }

    // 因为 `stdin` 在上面调用后就不再存活，所以它被 `drop` 了，管道也被关闭。
    //
    // 这点非常重要，因为否则 `wc` 就不会开始处理我们刚刚发送的输入。

    // `stdout` 字段也拥有 `Option&lt;ChildStdout&gt;` 类型，所以必需解包。
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!("couldn't read wc stdout: {:?}", why),
        Ok(_) =&gt; print!("wc responded with:\n{}", s),
    }
}
</code></pre> 
<p></p> 
<h4>等待 子进程</h4> 
<p>等待一个 <code>process::Child</code> 完成，就必须调用 <code>Child::wait</code>，这会返回一个 <code>process::ExitStatus</code>。</p> 
<pre><code class="language-rust">use std::process::Command;

fn main() {
    let mut child = Command::new("sleep").arg("5").spawn().unwrap();
    let _result = child.wait().unwrap();

    println!("reached end of main");
}
</code></pre> 
<p></p> 
<h4>文件系统操作：std::io::fs</h4> 
<p>std::io::fs 模块包含几个处理文件系统的函数。</p> 
<pre><code class="language-rust">use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

// `% cat path` 的简单实现
fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// `% echo s &gt; path` 的简单实现
fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// `% touch path` 的简单实现（忽略已存在的文件）
fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) =&gt; Ok(()),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    println!("`mkdir a`");
    // 创建一个目录，返回 `io::Result&lt;()&gt;`
    match fs::create_dir("a") {
        Err(why) =&gt; println!("! {:?}", why.kind()),
        Ok(_) =&gt; {},
    }

    println!("`echo hello &gt; a/b.txt`");
    // 前面的匹配可以用 `unwrap_or_else` 方法简化
    echo("hello", &amp;Path::new("a/b.txt")).unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`mkdir -p a/c/d`");
    // 递归地创建一个目录，返回 `io::Result&lt;()&gt;`
    fs::create_dir_all("a/c/d").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`touch a/c/e.txt`");
    touch(&amp;Path::new("a/c/e.txt")).unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`ln -s ../b.txt a/c/b.txt`");
    // 创建一个符号链接，返回 `io::Resutl&lt;()&gt;`
    if cfg!(target_family = "unix") {
        unix::fs::symlink("../b.txt", "a/c/b.txt").unwrap_or_else(|why| {
            println!("! {:?}", why.kind());
        });
    }

    println!("`cat a/c/b.txt`");
    match cat(&amp;Path::new("a/c/b.txt")) {
        Err(why) =&gt; println!("! {:?}", why.kind()),
        Ok(s) =&gt; println!("&gt; {}", s),
    }

    println!("`ls a`");
    // 读取目录的内容，返回 `io::Result&lt;Vec&lt;Path&gt;&gt;`
    match fs::read_dir("a") {
        Err(why) =&gt; println!("! {:?}", why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!("&gt; {:?}", path.unwrap().path());
        },
    }

    println!("`rm a/c/e.txt`");
    // 删除一个文件，返回 `io::Result&lt;()&gt;`
    fs::remove_file("a/c/e.txt").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`rmdir a/c/d`");
    // 移除一个空目录，返回 `io::Result&lt;()&gt;`
    fs::remove_dir("a/c/d").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });
}
</code></pre> 
<p>另一种定义 <code>cat</code> 函数的方式是使用 <code>?</code> 标记：</p> 
<pre><code class="language-rust">fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre> 
<p></p> 
<p></p> 
<h3>文件 IO</h3> 
<p><code>Path</code> 结构体代表了底层文件系统的文件路径。<code>Path</code> 分为两种：<code>posix::Path</code>，针对类 UNIX 系统；以及 <code>windows::Path</code>，针对 Windows。prelude 会选择并输出符合平台类型的 <code>Path</code> 种类。</p> 
<blockquote> 
 <p>prelude 是 Rust 自动地在每个程序中导入的一些通用的东西，这样我们就不必每写 一个程序就手动导入一番。</p> 
</blockquote> 
<p><code>Path</code> 可从 <code>OsStr</code> 类型创建，并且它提供数种方法，用于获取路径指向的文件/目录的信息。</p> 
<p>注意 <code>Path</code> 在内部并不是用 UTF-8 字符串表示的，而是存储为若干字节（<code>Vec&lt;u8&gt;</code>）的 vector。因此，将 <code>Path</code> 转化成 <code>&amp;str</code> 并非零开销的（free），且可能失败（因此它返回一个 <code>Option</code>）。</p> 
<pre><code class="language-rust">use std::path::Path;

fn main() {
    // 从 `&amp;'static str` 创建一个 `Path`
    let path = Path::new(".");

    // `display` 方法返回一个可显示（showable）的结构体
    let display = path.display();

    // `join` 使用操作系统特定的分隔符来合并路径到一个字节容器，并返回新的路径
    let new_path = path.join("a").join("b");

    // 将路径转换成一个字符串切片
    match new_path.to_str() {
        None =&gt; panic!("new path is not a valid UTF-8 sequence"),
        Some(s) =&gt; println!("new path is {}", s),
    }
}</code></pre> 
<p><code>File</code> 结构体表示一个被打开的文件（它包裹了一个文件描述符），并赋予了对所表示的文件的读写能力。由于在进行文件 I/O（输入/输出）操作时可能出现各种错误，因此 <code>File</code> 的所有方法都返回 <code>io::Result&lt;T&gt;</code> 类型，它是 <code>Result&lt;T, io::Error&gt;</code> 的别名。</p> 
<p></p> 
<h4>打开文件 open</h4> 
<p><code>open</code> 静态方法能够以只读模式（read-only mode）打开一个文件。</p> 
<p><code>File</code> 拥有资源，即文件描述符（file descriptor），它会在自身被 <code>drop</code> 时关闭文件。</p> 
<pre><code class="language-rust">use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // 创建指向所需的文件的路径
    let path = Path::new("hello.txt");
    let display = path.display();

    // 以只读方式打开路径，返回 `io::Result&lt;File&gt;`
    let mut file = match File::open(&amp;path) {
        // `io::Error` 的 `description` 方法返回一个描述错误的字符串。
        Err(why) =&gt; panic!("couldn't open {}: {:?}", display, why),
        Ok(file) =&gt; file,
    };

    // 读取文件内容到一个字符串，返回 `io::Result&lt;usize&gt;`
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!("couldn't read {}: {:?}", display, why),
        Ok(_) =&gt; print!("{} contains:\n{}", display, s),
    }

    // `file` 离开作用域，并且 `hello.txt` 文件将被关闭。
}
</code></pre> 
<p></p> 
<h4>创建文件 create</h4> 
<p><code>create</code> 静态方法以只写模式（write-only mode）打开一个文件。若文件已经存在，则旧内容将被销毁。否则，将创建一个新文件。</p> 
<pre><code class="language-rust">static LOREM_IPSUM: &amp;'static str =
    "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
";

use std::io::prelude::*;
use std::fs::File;
use std::path::Path;

fn main() {
    let path = Path::new("out/lorem_ipsum.txt");
    let display = path.display();

    // 以只写模式打开文件，返回 `io::Result&lt;File&gt;`
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!("couldn't create {}: {:?}", display, why),
        Ok(file) =&gt; file,
    };

    // 将 `LOREM_IPSUM` 字符串写进 `file`，返回 `io::Result&lt;()&gt;`
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; {
            panic!("couldn't write to {}: {:?}", display, why)
        },
        Ok(_) =&gt; println!("successfully wrote to {}", display),
    }
}
</code></pre> 
<p></p> 
<h4>读取行</h4> 
<p>方法 <code>lines()</code> 在文件的行上返回一个迭代器。<code>File::open</code> 需要一个泛型 <code>AsRef&lt;Path&gt;</code>。这正是 <code>read_lines()</code> 期望的输入。</p> 
<pre><code class="language-rust">use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // 在生成输出之前，文件主机必须存在于当前路径中
    if let Ok(lines) = read_lines("./hosts") {
        // 使用迭代器，返回一个（可选）字符串
        for line in lines {
            if let Ok(ip) = line {
                println!("{}", ip);
            }
        }
    }
}

// 输出包裹在 Result 中以允许匹配错误，
// 将迭代器返回给文件行的读取器（Reader）。
fn read_lines&lt;P&gt;(filename: P) -&gt; io::Result&lt;io::Lines&lt;io::BufReader&lt;File&gt;&gt;&gt;
    where P: AsRef&lt;Path&gt;, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
</code></pre> 
<p></p> 
<h3>Rust 的面向对象</h3> 
<p>面向对象编程语言所共享的一些特性往往是 对象、且对象有 "<span style="color:#fe2c24;"><strong>封装、继承、多态</strong></span>"</p> 
<p>在一些定义下，Rust 是面向对象的；在其他定义下，Rust 不是。</p> 
<ul><li>面向对象的程序是由 "<strong>对象</strong>" 组成的，对象包含数据和行为，即一个 "<strong>对象</strong>" 包含数据和操作这些数据的过程，这些过程通常被称为 "<strong>方法</strong> 或 <strong>操作</strong>"。<span style="color:#956fe7;"><strong>在这个定义下，Rust 是面向对象的：</strong></span><span style="color:#0d0016;">结构体和枚举包含数据，而 <code>impl</code> 块提供了在结构体和枚举之上的方法。</span><span style="color:#fe2c24;">虽然带有方法的结构体和枚举并不被 称为 "<strong>对象</strong>"，但是它们提供了与对象相同的功能。</span></li><li><strong>封装</strong>（<em>encapsulation</em>）：对象的实现细节不能被 使用对象 的代码获取到，所有与对象交互的方式是通过对象提供的公有 API；在 Rust 中可以使用 <code>pub</code> 关键字可以决定 模块、类型、函数和方法是公有的，没有pub时默认都是私有的。那么 Rust 满足 <strong>封装 </strong>这个要求。在代码中不同的部分使用 <code>pub</code> 与否可以封装其实现细节。</li></ul> 
<p>示例：在结构体上实现 <code>add</code>、<code>remove</code> 和 <code>average</code> 方法，并通过 pub 暴露给外部进行调用</p> 
<pre><code class="language-rust">impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}</code></pre> 
<ul><li><strong>继承</strong>（<em>Inheritance</em>）："子类" 通过继承 "父类"，来获取父类中定义的成员和方法。从这个角度看 Rust 不是面向对象的。因为 Rust 无法定义一个结构体继承父结构体的成员和方法。</li><li><strong>多态（polymorphism）：</strong>选择继承有两个主要的原因。<br> 第一：是为了重用代码，Rust 中可以使用默认 trait 方法实现来进行有限的共享。<br> 第二：是为了 <strong><span style="background-color:#ffd900;">多态（polymorphism）</span></strong>。对于继承来说，这些 <strong><span style="background-color:#ffd900;">多态(多种类型)</span></strong> 通常是子类。<strong><span style="background-color:#ffd900;">Rust 使用 trait 对象来实现多态，而不是继承。</span></strong> Rust 则通过泛型来对不同的可能类型进行抽象，并通过 trait bounds 对这些类型所必须提供的内容施加约束。这有时被称为 bounded parametric polymorphism。</li></ul> 
<p>总结</p> 
<ul><li>Rust 是一种多范式的编程语言，它支持面向对象编程（Object-oriented programming，OOP）的一些概念和特性，但并不是一个纯粹的面向对象语言。也提供了其他范式（如函数式编程）的支持，以满足不同的编程需求。</li><li>在 Rust 中，可以使用结构体（Structs）和枚举（Enums）来定义数据结构，使用 impl 块来为结构体或枚举实现方法。这些特性可以用于实现面向对象编程中的封装、抽象、继承和多态等概念。</li><li>Rust 中的结构体可以包含字段和相关的方法，可以通过关联函数（Associated Functions）和实例方法（Methods）来定义结构体的行为。这与面向对象编程中的类和对象的概念有些相似。</li><li><strong><span style="background-color:#fe2c24;">Rust 使用 trait 来定义接口和抽象类型</span></strong>，<strong><span style="background-color:#fe2c24;">trait 可以看作是一组方法的集合</span><span style="background-color:#ffd900;">，类似 Java 中的接口。</span></strong>通过实现 trait，可以实现接口的多态性，即不同的类型可以实现相同的 trait，并具有相同的行为。</li><li>Rust 也有一些区别于传统面向对象编程的特点。例如，Rust 强调所有权和借用规则，通过 Borrow Checker 来保证内存安全。Rust 还引入了所有权模型、生命周期和模块系统等概念，使得代码更加安全和高效。因此，尽管 Rust 支持部分面向对象编程的概念和特性，但它并不是一种纯粹的面向对象语言。</li></ul> 
<p>Rust 刻意不将结构体与枚举称为 "<strong>对象</strong>" ，以便与其他语言中的对象相区别。在结构体或枚举中，结构体字段中的数据和 <code>impl</code> 块中的行为是分开的，"<strong>trait 对象</strong>" 将数据和行为两者相结合，但是不能向 "<strong>trait 对象</strong>" 增加数据。"<strong>trait 对象</strong>" 具体的作用是允许对通用行为进行抽象。</p> 
<p></p> 
<h4>通过 trait 实现多态</h4> 
<p><span style="color:#fe2c24;"><strong>必须带上类型标注，才能实现多态调用。</strong></span></p> 
<pre><code class="language-rust">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    // 静态方法签名；`Self` 表示实现者类型（implementor type）。
    fn new(name: &amp;'static str) -&gt; Self;

    // 实例方法签名；这些方法将返回一个字符串。
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // trait 可以提供默认的方法定义。
    fn talk(&amp;self) {
        println!("{} says {}", self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // 实现者可以使用它的 trait 方法。
            println!("{} is already naked...", self.name());
        } else {
            println!("{} gets a haircut!", self.name);

            self.naked = true;
        }
    }
}

// 对 `Sheep` 实现 `Animal` trait。
impl Animal for Sheep {
    // `Self` 是实现者类型：`Sheep`。
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            "baaaaah?"
        } else {
            "baaaaah!"
        }
    }

    // 默认 trait 方法可以重载。
    fn talk(&amp;self) {
        // 例如我们可以增加一些安静的沉思。
        println!("{} pauses briefly... {}", self.name, self.noise());
    }
}

fn main() {
    // 这种情况需要类型标注。
    let mut dolly: Sheep = Animal::new("Dolly");
    // 试一试 ^ 移除类型标注。

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre> 
<p>示例 2：</p> 
<pre><code class="language-rust">// 带有生命周期标注的结构体。
#[derive(Debug)]
 struct Borrowed&lt;'a&gt; {
     x: &amp;'a i32,
 }
 
// 给 impl 标注生命周期。
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}
 
fn main() {
    let b: Borrowed = Default::default();  // 必须带上类型标注，才能实现多态调用。
    println!("b is {:?}", b);
}</code></pre> 
<p>示例 3：</p> 
<pre><code class="language-rust">use std::fmt::Debug;
 
trait PrintInOption {
    fn print_in_option(self);
}
 
// 这里需要一个 `where` 从句，否则就要表达成 `T: Debug`（这样意思就变了），
// 或者改用另一种间接的方法。
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // 我们要将 `Option&lt;T&gt;: Debug` 作为约束，因为那是要打印的内容。
    // 否则我们会给出错误的约束。
    fn print_in_option(self) {
        println!("{:?}", Some(self));
    }
}
 
fn main() {
    let vec = vec![1, 2, 3];
 
    vec.print_in_option();
}</code></pre> 
<p></p> 
<h4>通过 属性 动态添加方法</h4> 
<blockquote> 
 <p>派生本指江河的源头产生出支流，引申为从一个主要事物的发展中分化出来。</p> 
 <p>继承和派生从两个不同的角度来说明的，举例如下：</p> 
 <ul><li>B 是 A 的子类，则可以说 B 继承 A，是 A 的派生类</li><li>如果C又是B的子类，就不能说C继承A，而只能说C是A的派生类。其实就是隔代的问题</li></ul> 
</blockquote> 
<p>参考：<a href="https://rustwiki.org/zh-CN/reference/attributes.html#%E6%B4%BE%E7%94%9F" rel="nofollow" title="derive">derive</a></p> 
<p>通过 <code>#[derive]</code> <a href="https://rustwiki.org/zh-CN/rust-by-example/attribute.html" rel="nofollow" title="属性">属性</a>，编译器能够提供某些 trait 的基本实现。如果需要更复杂的行为，这些 trait 也可以手动实现。</p> 
<p>下面是可以自动派生的 trait：</p> 
<ul><li>比较 trait: <a href="https://rustwiki.org/zh-CN/std/cmp/trait.Eq.html" rel="nofollow" title="Eq">Eq</a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialEq.html" rel="nofollow" title="PartialEq">PartialEq</a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.Ord.html" rel="nofollow" title="Ord">Ord</a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialOrd.html" rel="nofollow" title="PartialOrd">PartialOrd</a></li><li><a href="https://rustwiki.org/zh-CN/std/clone/trait.Clone.html" rel="nofollow" title="Clone">Clone</a>, 用来从 <code>&amp;T</code> 创建副本 <code>T</code>。</li><li><a href="https://rustwiki.org/zh-CN/core/marker/trait.Copy.html" rel="nofollow" title="Copy">Copy</a>，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。</li><li><a href="https://rustwiki.org/zh-CN/std/hash/trait.Hash.html" rel="nofollow" title="Hash">Hash</a>，从 <code>&amp;T</code> 计算哈希值（hash）。</li><li><a href="https://rustwiki.org/zh-CN/std/default/trait.Default.html" rel="nofollow" title="Default">Default</a>, 创建数据类型的一个空实例。</li><li><a href="https://rustwiki.org/zh-CN/std/fmt/trait.Debug.html" rel="nofollow" title="Debug">Debug</a>，使用 <code>{:?}</code> formatter 来格式化一个值。</li></ul> 
<pre><code class="language-rust">// `Centimeters`，可以比较的元组结构体
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`，可以打印的元组结构体
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;
        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`，不带附加属性的元组结构体
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);
    // 报错：`Seconds` 不能打印；它没有实现 `Debug` trait
    //println!("One second looks like: {:?}", _one_second);
    // 试一试 ^ 取消此行注释

    // 报错：`Seconds`不能比较；它没有实现 `PartialEq` trait
    //let _this_is_true = (_one_second == _one_second);
    // 试一试 ^ 取消此行注释

    let foot = Inches(12);
    println!("One foot equals {:?}", foot);
    let meter = Centimeters(100.0);
    let cmp =
        if foot.to_centimeters() &lt; meter {
            "smaller"
        } else {
            "bigger"
        };
    println!("One foot is {} than one meter.", cmp);
}
</code></pre> 
<p></p> 
<h4>动态分发 (dyn) : 通过 "父类指向子类" 实现多态</h4> 
<p><code>dyn</code> 是一个关键字，用于声明动态分发（dynamic dispatch）的 <span style="color:#fe2c24;"><strong>trait 对象</strong></span>。即<strong><span style="background-color:#ffd900;">当使用 trait 对象实现多态时，必须使用dyn修饰。</span></strong></p> 
<p>Rust 编译器需要知道每个函数的返回类型需要多少空间。这意味着所有函数都必须返回一个具体类型。与其他语言不同，如果你有个像 <code>Animal</code> 那样的的 trait，则不能编写返回 <code>Animal</code> 的函数，因为其不同的实现将需要不同的内存量。</p> 
<p>但是，有一个简单的解决方法。相比于直接返回一个 trait 对象，我们的函数返回一个包含一些 <code>Animal</code> 的 <code>Box</code>。<code>box</code> 只是对堆中某些内存的引用。因为引用的大小是静态已知的，并且编译器可以保证引用指向已分配的堆 <code>Animal</code>，所以我们可以从函数中返回 trait！</p> 
<p>每当在堆上分配内存时，Rust 都会尝试尽可能明确。因此，如果你的函数以这种方式返回指向堆的 trait 指针，则需要使用 <code>dyn</code> 关键字编写返回类型，例如 <code>Box&lt;dyn Animal&gt;</code>。</p> 
<p>示例：</p> 
<pre><code class="language-rust">struct Sheep {}
struct Cow {}

trait Animal {
    // 实例方法签名
    fn noise(&amp;self) -&gt; &amp;'static str;
}

// 实现 `Sheep` 的 `Animal` trait。
impl Animal for Sheep {
    fn noise(&amp;self) -&gt; &amp;'static str {
        "baaaaah!"
    }
}

// 实现 `Cow` 的 `Animal` trait。
impl Animal for Cow {
    fn noise(&amp;self) -&gt; &amp;'static str {
        "moooooo!"
    }
}

// 返回一些实现 Animal 的结构体，但是在编译时我们不知道哪个结构体。
fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {
    if random_number &lt; 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!("You've randomly chosen an animal, and it says {}", animal.noise());
}

</code></pre> 
<p>示例：使用 <code>dyn</code> 关键字可以创建一个指向实现了特定 trait 的类型的 trait 对象。</p> 
<p><img alt="" height="443" src="https://images2.imgbox.com/0e/af/YIuNv1sf_o.png" width="822"></p> 
<p>"父类" 的说法是来自C++，这里是为了更好的理解。其实更像Java中的 "父接口"</p> 
<p>动态分发会阻止编译器有选择的内联方法代码，这会相应的禁用一些优化。</p> 
<pre><code class="language-rust">// 相当于定义接口
pub trait Draw {
    // 接口中的方法列表,
    fn draw(&amp;self); // 声明方法(没有方法体的实现)
}
//####################################################################
pub struct Button {
    // 定义 button, 通过 pub 暴露给外部
    pub width: u32,
    pub height: u32,
    pub label: String,
}
// button "继承" 接口
impl Draw for Button {
    // 实现接口的方法
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}

//####################################################################
struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
//####################################################################
//一个 Screen 结构体的定义，它带有一个字段 components，
// 其包含实现了 Draw trait 的 trait 对象的 vector
pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
impl Screen {
    // 在 Screen 结构体上，定义一个 run 方法，
    // 该方法会对其 components 上的每一个组件调用 draw 方法
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
//####################################################################
fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };
    screen.run();
}</code></pre> 
<p></p> 
<h4>运算符重载</h4> 
<p>在 Rust 中，很多运算符可以通过 trait 来重载。也就是说，这些运算符可以根据它们的输入参数来完成不同的任务。这之所以可行，是因为运算符就是方法调用的语法糖。例如，<code>a + b</code> 中的 <code>+</code> 运算符会调用 <code>add</code> 方法（也就是 <code>a.add(b)</code>）。这个 <code>add</code> 方法是 <code>Add</code> trait 的一部分。因此，<code>+</code> 运算符可以被任何 <code>Add</code> trait 的实现者使用。</p> 
<p>会重载运算符的 <code>trait</code>（比如 <code>Add</code> 这种）可以在<a href="https://rustwiki.org/zh-CN/core/ops/" rel="nofollow" title="这里">这里</a>查看。</p> 
<pre><code class="language-rust">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// `std::ops::Add` trait 用来指明 `+` 的功能，这里我们实现 `Add&lt;Bar&gt;`，它是用于
// 把对象和 `Bar` 类型的右操作数（RHS）加起来的 `trait`。
// 下面的代码块实现了 `Foo + Bar = FooBar` 这样的运算。
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!("&gt; Foo.add(Bar) was called");

        FooBar
    }
}

// 通过颠倒类型，我们实现了不服从交换律的加法。
// 这里我们实现 `Add&lt;Foo&gt;`，它是用于把对象和 `Foo` 类型的右操作数加起来的 trait。
// 下面的代码块实现了 `Bar + Foo = BarFoo` 这样的运算。
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!("&gt; Bar.add(Foo) was called");

        BarFoo
    }
}

fn main() {
    println!("Foo + Bar = {:?}", Foo + Bar);
    println!("Bar + Foo = {:?}", Bar + Foo);
}
</code></pre> 
<p>参考：<a href="https://rustwiki.org/zh-CN/core/ops/trait.Add.html" rel="nofollow" title="Add">Add</a>, <a href="https://rustwiki.org/zh-CN/book/appendix-02-operators.html" rel="nofollow" title="语法索引">语法索引</a></p> 
<p></p> 
<h4>析构方法 (drop)</h4> 
<p><a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html" rel="nofollow" title="Drop">Drop</a> trait 只有一个方法：<code>drop</code>，当对象离开作用域时会自动调用该方法。<code>Drop</code> trait 的主要作用是释放实现者的实例拥有的资源。<code>Box</code>，<code>Vec</code>，<code>String</code>，<code>File</code>，以及 <code>Process</code> 都实现了 <code>Drop</code> trait 来释放资源的类型。<code>Drop</code> trait 也可以为任何自定义数据类型手动实现。</p> 
<p>示例：给 <code>drop</code> 函数增加了打印到控制台的功能</p> 
<pre><code class="language-rust">struct Droppable {
    name: &amp;'static str,
}

// 这个简单的 `drop` 实现添加了打印到控制台的功能。
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!("&gt; Dropping {}", self.name);
    }
}

fn main() {
    let _a = Droppable { name: "a" };
    // 代码块 A
    {
        let _b = Droppable { name: "b" };
        // 代码块 B
        {
            let _c = Droppable { name: "c" };
            let _d = Droppable { name: "d" };
            println!("Exiting block B");
        }
        println!("Just exited block B");
        println!("Exiting block A");
    }
    println!("Just exited block A");
    // 变量可以手动使用 `drop` 函数来销毁。
    drop(_a);
    // 试一试 ^ 将此行注释掉。
    println!("end of the main function");
    // `_a` *不会*在这里再次销毁，因为它已经被（手动）销毁。
}
</code></pre> 
<p></p> 
<h4>面向对象的设计模式</h4> 
<p><strong>状态模式</strong>（<em>state pattern</em>）是一个面向对象设计模式。该模式的关键在于定义一系列值的内含状态。这些状态体现为一系列的 <strong>状态对象</strong>，同时值的行为随着其内部状态而改变。</p> 
<p>take() 方法获取并清空某个对象的可变状态。这种用法通常与 <code>Option&lt;T&gt;</code> 类型一起使用。<code>Option&lt;T&gt;</code> 是一个泛型枚举类型，表示一个可能存在或可能不存在的值。它有两个变体：<code>Some(T)</code> 表示存在一个值 <code>T</code>，<code>None</code> 表示不存在值。当我们需要获取某个对象的状态，并在同一时间将其重置为初始状态时，可以使用 <code>self.state.take()</code>。<code>take()</code> 方法从 <code>Option&lt;T&gt;</code> 中获取值并将其替换为 <code>None</code>，以确保状态被取走后不再存在。</p> 
<pre><code class="language-rust">struct MyStruct {
    state: Option&lt;String&gt;,
}

impl MyStruct {
    fn take_state(&amp;mut self) -&gt; Option&lt;String&gt; {
        self.state.take()
    }
}

fn main() {
    let mut my_struct = MyStruct {
        state: Some("Hello".to_string()),
    };

    let state = my_struct.take_state();
    println!("{:?}", state);  // 输出 Some("Hello")
    
    let empty_state = my_struct.take_state();
    println!("{:?}", empty_state);  // 输出 None
}
</code></pre> 
<p>示例：编写一个博客发布结构体的例子，它拥有一个包含其状态的字段，这是一个有着 "draft"、"review" 或 "published" 的状态对象</p> 
<pre><code class="language-rust">//###############################################################
trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}
//###############################################################
struct Draft {}
impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
//###############################################################
struct PendingReview {}
impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}
//###############################################################
struct Published {}
impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
//###############################################################
pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}
impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}
//###############################################################
fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre> 
<p>见识了 trait 对象是一个 Rust 中获取部分面向对象功能的方法。动态分发可以通过牺牲少量运行时性能来为你的代码提供一些灵活性。这些灵活性可以用来实现有助于代码可维护性的面向对象模式。Rust 也有像所有权这样不同于面向对象语言的功能。面向对象模式并不总是利用 Rust 优势的最好方式，但也是可用的选项。</p> 
<p></p> 
<h4>Iterator</h4> 
<p><code>Iterator</code> trait 用来对集合（collection）类型（比如数组）实现迭代器。</p> 
<p>这个 trait 只需定义一个返回 <code>next</code>（下一个）元素的方法，这可手动在 <code>impl</code> 代码块中定义，或者自动定义（比如在数组或区间中）。</p> 
<p>为方便起见，<code>for</code> 结构会使用 <a href="https://rustwiki.org/zh-CN/std/iter/trait.IntoIterator.html" rel="nofollow" title=".into_iter()">.into_iter()</a> 方法将一些集合类型转换为迭代器。</p> 
<p>下面例子展示了如何使用 <code>Iterator</code> trait 的方法，更多可用的方法可以看<a href="https://rustwiki.org/zh-CN/core/iter/trait.Iterator.html" rel="nofollow" title="这里">这里</a>。</p> 
<pre><code class="language-rust">struct Fibonacci {
    curr: u32,
    next: u32,
}

// 为 `Fibonacci`（斐波那契）实现 `Iterator`。
// `Iterator` trait 只需定义一个能返回 `next`（下一个）元素的方法。
impl Iterator for Fibonacci {
    type Item = u32;

    // 我们在这里使用 `.curr` 和 `.next` 来定义数列（sequence）。
    // 返回类型为 `Option&lt;T&gt;`：
    //     * 当 `Iterator` 结束时，返回 `None`。
    //     * 其他情况，返回被 `Some` 包裹（wrap）的下一个值。
    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        // 既然斐波那契数列不存在终点，那么 `Iterator` 将不可能
        // 返回 `None`，而总是返回 `Some`。
        Some(self.curr)
    }
}

// 返回一个斐波那契数列生成器
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 1, next: 1 }
}

fn main() {
    // `0..3` 是一个 `Iterator`，会产生：0、1 和 2。
    let mut sequence = 0..3;

    println!("Four consecutive `next` calls on 0..3");
    println!("&gt; {:?}", sequence.next());
    println!("&gt; {:?}", sequence.next());
    println!("&gt; {:?}", sequence.next());
    println!("&gt; {:?}", sequence.next());

    // `for` 遍历 `Iterator` 直到返回 `None`，
    // 并且每个 `Some` 值都被解包（unwrap），然后绑定给一个变量（这里是 `i`）。       
    println!("Iterate through 0..3 using `for`");
    for i in 0..3 {
        println!("&gt; {}", i);
    }

    // `take(n)` 方法提取 `Iterator` 的前 `n` 项。
    println!("The first four terms of the Fibonacci sequence are: ");
    for i in fibonacci().take(4) {
        println!("&gt; {}", i);
    }

    // `skip(n)` 方法移除前 `n` 项，从而缩短了 `Iterator` 。
    println!("The next four terms of the Fibonacci sequence are: ");
    for i in fibonacci().skip(4).take(4) {
        println!("&gt; {}", i);
    }

    let array = [1u32, 3, 3, 7];

    // `iter` 方法对数组/slice 产生一个 `Iterator`。
    println!("Iterate the following array {:?}", &amp;array);
    for i in array.iter() {
        println!("&gt; {}", i);
    }
}
</code></pre> 
<p></p> 
<h4>返回 impl Trait</h4> 
<p>如果函数返回实现了 <code>MyTrait</code> 的类型，可以将其返回类型编写为 <code>-&gt; impl MyTrait</code>。这可以大大简化你的类型签名！</p> 
<pre><code class="language-rust">use std::iter;
use std::vec::IntoIter;

// 该函数组合了两个 `Vec &lt;i32&gt;` 并在其上返回一个迭代器。
// 看看它的返回类型多么复杂！
fn combine_vecs_explicit_return_type(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;i32&gt;, IntoIter&lt;i32&gt;&gt;&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

// 这是完全相同的函数，但其返回类型使用 `impl Trait`。
// 看看它多么简单！
fn combine_vecs(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; impl Iterator&lt;Item=i32&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5];
    let mut v3 = combine_vecs(v1, v2);
    assert_eq!(Some(1), v3.next());
    assert_eq!(Some(2), v3.next());
    assert_eq!(Some(3), v3.next());
    assert_eq!(Some(4), v3.next());
    assert_eq!(Some(5), v3.next());
    println!("all done");
}
</code></pre> 
<p>更重要的是，某些 Rust 类型无法写出。例如，每个闭包都有自己未命名的具体类型。在使用 <code>impl Trait</code> 语法之前，必须在堆上进行分配才能返回闭包。但是现在你可以像下面这样静态地完成所有操作：</p> 
<pre><code class="language-rust">// 返回一个将输入和 `y` 相加的函数
fn make_adder_function(y: i32) -&gt; impl Fn(i32) -&gt; i32 {
    let closure = move |x: i32| { x + y };
    closure
}

fn main() {
    let plus_one = make_adder_function(1);
    assert_eq!(plus_one(2), 3);
}
</code></pre> 
<p>还可以使用 <code>impl Trait</code> 返回使用 <code>map</code> 或 <code>filter</code> 闭包的迭代器！这使得使用 <code>map</code> 和 <code>filter</code> 更容易。因为闭包类型没有名称，所以如果函数返回带闭包的迭代器，则无法写出显式的返回类型。但是有了 <code>impl Trait</code>，你就可以轻松地做到这一点：</p> 
<pre><code class="language-rust">fn double_positives&lt;'a&gt;(numbers: &amp;'a Vec&lt;i32&gt;) -&gt; impl Iterator&lt;Item = i32&gt; + 'a {
    numbers
        .iter()
        .filter(|x| x &gt; &amp;&amp;0)
        .map(|x| x * 2)
}
</code></pre> 
<p></p> 
<h4>Clone</h4> 
<p>当处理资源时，默认的行为是在赋值或函数调用的同时将它们转移。但是我们有时候也需要把资源复制一份。<a href="https://rustwiki.org/zh-CN/std/clone/trait.Clone.html" rel="nofollow" title="Clone">Clone</a> trait 正好帮助我们完成这任务。可以使用由 <code>Clone</code> trait 定义的 <code>.clone()</code> 方法。</p> 
<pre><code class="language-rust">// 不含资源的单元结构体
#[derive(Debug, Clone, Copy)]
struct Nil;

// 一个包含资源的结构体，它实现了 `Clone` trait
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // 实例化 `Nil`
    let nil = Nil;
    // 复制 `Nil`，没有资源用于移动（move）
    let copied_nil = nil;

    // 两个 `Nil` 都可以独立使用
    println!("original: {:?}", nil);
    println!("copy: {:?}", copied_nil);

    // 实例化 `Pair`
    let pair = Pair(Box::new(1), Box::new(2));
    println!("original: {:?}", pair);

    // 将 `pair` 绑定到 `moved_pair`，移动（move）了资源
    let moved_pair = pair;
    println!("copy: {:?}", moved_pair);

    // 报错！`pair` 已失去了它的资源。
    //println!("original: {:?}", pair);
    // 试一试 ^ 取消此行注释。

    // 将 `moved_pair`（包括其资源）克隆到 `cloned_pair`。
    let cloned_pair = moved_pair.clone();
    // 使用 std::mem::drop 来销毁原始的 pair。
    drop(moved_pair);

    // 报错！`moved_pair` 已被销毁。
    //println!("copy: {:?}", moved_pair);
    // 试一试 ^ 将此行注释掉。

    // 由 .clone() 得来的结果仍然可用！
    println!("clone: {:?}", cloned_pair);
}
</code></pre> 
<p></p> 
<h4>父 trait</h4> 
<p>Rust 没有“继承”，但是可以将一个 trait 定义为另一个 trait 的超集（即父 trait）。例如：</p> 
<pre><code class="language-rust">
trait Person {
    fn name(&amp;self) -&gt; String;
}

// Person 是 Student 的父 trait。
// 实现 Student 需要你也 impl 了 Person。
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (computer science student，计算机科学的学生) 是 Programmer 和 Student 两者的子类。
// 实现 CompSciStudent 需要你同时 impl 了两个父 trait。
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

struct TempTest;


impl Programmer for TempTest {
    fn fav_language(&amp;self) -&gt; String {
        String::from("C++/Python/Rust").clone()
    }
}

impl Student for TempTest {
    fn university(&amp;self) -&gt; String {
        String::from("宇宙社会大学").clone()
    }
}

impl Person for TempTest {
    fn name(&amp;self) -&gt; String {
        String::from("无名氏").clone()
    }
}

impl CompSciStudent for TempTest {
    fn git_username(&amp;self) -&gt; String {
        String::from("无名").clone()
    }
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        "姓名:{}, 学校:{}, 编程语言:{}, github名:{}",
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

fn main() {
    let temp = Box::new(TempTest);
    println!("{}", comp_sci_student_greeting(&amp;*temp));

    let temp = TempTest;
    println!("{}", comp_sci_student_greeting(&amp;temp));
}
</code></pre> 
<p></p> 
<h4>消除重叠 trait (C++菱形继承)</h4> 
<p>一个类型可以实现许多不同的 trait。如果两个 trait 都需要相同的名称怎么办？例如，许多 trait 可能拥有名为 <code>get()</code> 的方法。他们甚至可能有不同的返回类型！</p> 
<p>有个好消息：由于每个 trait 实现都有自己的 <code>impl</code> 块，因此很清楚您要实现哪个 trait 的 <code>get</code> 方法。</p> 
<p>何时需要<strong>调用</strong>这些方法呢？为了消除它们之间的歧义，我们必须使用完全限定语法（Fully Qualified Syntax）。</p> 
<pre><code class="language-rust">trait UsernameWidget {
    // 从这个 widget 中获取选定的用户名
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    // 从这个 widget 中获取选定的年龄
    fn get(&amp;self) -&gt; u8;
}

// 同时具有 UsernameWidget 和 AgeWidget 的表单
struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
        self.age
    }
}

fn main() {
    let form = Form{
        username: "rustacean".to_owned(),
        age: 28,
    };

    // 如果取消注释此行，则会收到一条错误消息，提示 “multiple `get` found”（找到了多个`get`）。
    // 因为毕竟有多个名为 `get` 的方法。
    // println!("{}", form.get());

    let username = &lt;Form as UsernameWidget&gt;::get(&amp;form);
    assert_eq!("rustacean".to_owned(), username);
    let age = &lt;Form as AgeWidget&gt;::get(&amp;form);
    assert_eq!(28, age);
}
</code></pre> 
<p></p> 
<h3><strong>宏 (Macro)</strong></h3> 
<p>Rust 提供了一个强大的宏系统，可进行元编程（metaprogramming）。宏看起来和函数很像，只不过名称末尾有一个感叹号 <code>!</code> 。宏并不产生函数调用，而是展开成源码，并和程序的其余部分一起被编译。Rust 又有一点和 C 以及其他语言都不同，那就是 Rust 的宏会展开为抽象语法树（AST，abstract syntax tree），而不是像字符串预处理那样直接替换成代码，这样就不会产生无法预料的优先权错误。</p> 
<p>宏 (Macro) 指的是 Rust 中一系列的功能：使用 <code>macro_rules!</code> 的 <strong>声明</strong>（<em>Declarative</em>）宏。但是为什么已经有了函数还需要宏呢？<strong>宏和函数的区别：</strong>从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 <strong>元编程</strong>（<em>metaprogramming</em>）。宏可以在编译器翻译代码前展开，宏定义要比函数定义更复杂，在一个文件里调用宏 <strong>之前</strong> 必须定义它，或将其引入作用域，而函数则可以在任何地方定义和调用。</p> 
<p>三种 <strong>过程</strong>（<em>Procedural</em>）宏：</p> 
<ul><li>自定义 <code>#[derive]</code> 宏在结构体和枚举上指定通过 <code>derive</code> 属性添加的代码</li><li>类属性（Attribute-like）宏定义可用于任意项的自定义属性</li><li>类函数宏看起来像函数不过作用于作为参数传递的 token</li></ul> 
<p></p> 
<h4>使用 macro_rules! 创建宏</h4> 
<p>宏是通过 <code>macro_rules!</code> 宏来创建的。</p> 
<pre><code>// 这是一个简单的宏，名为 `say_hello`。
macro_rules! say_hello {
    // `()` 表示此宏不接受任何参数。
    () =&gt; (
        // 此宏将会展开成这个代码块里面的内容。
        println!("Hello!");
    )
}

fn main() {
    // 这个调用将会展开成 `println("Hello");`!
    say_hello!()
}
</code></pre> 
<p></p> 
<h4>模式、指示符</h4> 
<p>宏的参数使用一个美元符号 <code>$</code> 作为前缀，并使用一个<strong>指示符</strong>（designator）来注明类型：</p> 
<p>全部指示符：</p> 
<ul><li><code>block</code></li><li><code>expr</code> 用于表达式</li><li><code>ident</code> 用于变量名或函数名</li><li><code>item</code></li><li><code>literal</code> 用于字面常量</li><li><code>pat</code> (<strong>模式</strong> <em>pattern</em>)</li><li><code>path</code></li><li><code>stmt</code> (<strong>语句</strong> <em>statement</em>)</li><li><code>tt</code> (<strong>标记树</strong> <em>token tree</em>)</li><li><code>ty</code> (<strong>类型</strong> <em>type</em>)</li><li><code>vis</code> (<em>可见性描述符</em>)</li></ul> 
<p>完整列表详见 <a href="https://doc.rust-lang.org/reference/macros-by-example.html" rel="nofollow" title="Rust Reference">Rust Reference</a>。</p> 
<pre><code class="language-rust">macro_rules! create_function {
    // 此宏接受一个 `ident` 指示符表示的参数，并创建一个名为 `$func_name` 的函数。
    // `ident` 指示符用于变量名或函数名
    ($func_name:ident) =&gt; (
        fn $func_name() {
            // `stringify!` 宏把 `ident` 转换成字符串。
            println!("You called {:?}()",
                     stringify!($func_name))
        }
    )
}

// 借助上述宏来创建名为 `foo` 和 `bar` 的函数。
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // 此宏接受一个 `expr` 类型的表达式，并将它作为字符串，连同其结果一起
    // 打印出来。
    // `expr` 指示符表示表达式。
    ($expression:expr) =&gt; (
        // `stringify!` 把表达式*原样*转换成一个字符串。
        println!("{:?} = {:?}",
                 stringify!($expression),
                 $expression)
    )
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // 回想一下，代码块也是表达式！
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}
</code></pre> 
<p>示例：查看 <code>vec!</code> 宏定义来探索如何使用 <code>macro_rules!</code> 结构。</p> 
<pre><code class="language-rust">let v: Vec&lt;u32&gt; = vec![1, 2, 3];

// 一个 vec! 宏定义的简化版本
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
</code></pre> 
<p>注意：标准库中实际定义的 <code>vec!</code> 包括预分配适当量的内存的代码。这部分为代码优化，为了让示例简化，此处并没有包含在内。</p> 
<p>首先，一对括号包含了整个模式。我们使用美元符号（<code>$</code>）在宏系统中声明一个变量来包含匹配该模式的 Rust 代码。美元符号明确表明这是一个宏变量而不是普通 Rust 变量。之后是一对括号，其捕获了符合括号内模式的值用以在替代代码中使用。<code>$()</code> 内则是 <code>$x:expr</code> ，其匹配 Rust 的任意表达式，并将该表达式命名为 <code>$x</code>。<code>$()</code> 之后的逗号说明一个可有可无的逗号分隔符可以出现在 <code>$()</code> 所匹配的代码之后。紧随逗号之后的 <code>*</code> 说明该模式匹配零个或更多个 <code>*</code> 之前的任何模式。当以 <code>vec![1, 2, 3];</code> 调用宏时，<code>$x</code> 模式与三个表达式 <code>1</code>、<code>2</code> 和 <code>3</code> 进行了三次匹配。</p> 
<p>在线文档或其他资源，如 <a href="https://veykril.github.io/tlborm/" rel="nofollow" title="“The Little Book of Rust Macros”">“The Little Book of Rust Macros”</a> 来更多地了解如何写宏，</p> 
<p></p> 
<h4>宏重载</h4> 
<p>宏可以重载，从而接受不同的参数组合。在这方面，<code>macro_rules!</code> 的作用类似于匹配（match）代码块：</p> 
<pre><code class="language-rust">// 根据你调用它的方式，`test!` 将以不同的方式来比较 `$left` 和 `$right`。
macro_rules! test {
    // 参数不需要使用逗号隔开。
    // 参数可以任意组合！
    ($left:expr; and $right:expr) =&gt; (
        println!("{:?} and {:?} is {:?}",
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    );
    // ^ 每个分支都必须以分号结束。
    ($left:expr; or $right:expr) =&gt; (
        println!("{:?} or {:?} is {:?}",
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    );
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
</code></pre> 
<p></p> 
<h4>宏参数 的 重复</h4> 
<p>宏在参数列表中可以使用 <code>+</code> 来表示一个参数可能出现一次或多次，使用 <code>*</code> 来表示该参数可能出现零次或多次。</p> 
<p>例子中，把模式这样： <code>$(...),+</code> 包围起来，就可以匹配一个或多个用逗号隔开的表达式。另外注意到，宏定义的最后一个分支可以不用分号作为结束。</p> 
<pre><code class="language-rust">// `min!` 将求出任意数量的参数的最小值。
macro_rules! find_min {
    // 基本情形：
    ($x:expr) =&gt; ($x);
    // `$x` 后面跟着至少一个 `$y,`
    ($x:expr, $($y:expr),+) =&gt; (
        // 对 `$x` 后面的 `$y` 们调用 `find_min!` 
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!("{}", find_min!(1u32));
    println!("{}", find_min!(1u32 + 2 , 2u32));
    println!("{}", find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre> 
<p></p> 
<h4>DRY (不写重复代码)</h4> 
<p>通过提取函数或测试集的公共部分，宏可以让你写出 DRY 的代码（DRY 是 Don't Repeat Yourself 的缩写，意思为 “不要写重复代码”）。</p> 
<p>示例：对 <code>Vec&lt;T&gt;</code> 实现并测试了关于 <code>+=</code>、<code>*=</code> 和 <code>-=</code> 等运算符。</p> 
<pre><code class="language-rust">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // `tt`（token tree，标记树）指示符表示运算符和标记。
    ($a:ident, $b: ident, $func:ident, $op:tt) =&gt; (
        assert!($a.len() == $b.len(),
                "{:?}: dimension mismatch: {:?} {:?} {:?}",
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    )
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; (
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    )
}

// 实现 `add_assign`、`mul_assign` 和 `sub_assign` 等函数。
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func: ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        }
    }

    // 测试 `add_assign`、`mul_assign` 和 `sub_assign`
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}

</code></pre> 
<p>$ rustc --test dry.rs &amp;&amp; ./dry<br> running 3 tests<br> test test::mul_assign ... ok<br> test test::add_assign ... ok<br> test test::sub_assign ... ok</p> 
<p>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured</p> 
<p></p> 
<h4>DSL（领域专用语言）</h4> 
<p>DSL 是 Rust 的宏中集成的微型 “语言”。这种语言是完全合法的，因为宏系统会把它转换成普通的 Rust 语法树，它只不过看起来像是另一种语言而已。这就允许你为一些特定功能创造一套简洁直观的语法（当然是有限制的）。</p> 
<p>示例：想要定义一套小的计算器 API，可以传给它表达式，它会把结果打印到控制台上。</p> 
<pre><code class="language-rust">macro_rules! calculate {
    (eval $e:expr) =&gt; {<!-- -->{
        {
            let val: usize = $e; // 强制类型为整型
            println!("{} = {}", stringify!{$e}, val);
        }
    }};
}

fn main() {
    calculate! {
        eval 1 + 2 // 看到了吧，`eval` 可并不是 Rust 的关键字！
    }

    calculate! {
        eval (1 + 2) * (3 / 4)
    }
}
</code></pre> 
<p>输出：</p> 
<p>1 + 2 = 3<br> (1 + 2) * (3 / 4) = 0</p> 
<p>这个例子非常简单，但是已经有很多利用宏开发的复杂接口了，比如 <a href="https://crates.io/crates/lazy_static" rel="nofollow" title="lazy_static">lazy_static</a> 和 <a href="https://crates.io/crates/clap" rel="nofollow" title="clap">clap</a>。</p> 
<p></p> 
<h4>可变参数接口</h4> 
<p>可变参数接口可以接受任意数目的参数。比如说 <code>println</code> 就可以，其参数的数目是由格式化字符串指定的。把之前的 <code>calculate!</code> 宏改写成可变参数接口：</p> 
<pre><code class="language-rust">macro_rules! calculate {
    // 单个 `eval` 的模式
    (eval $e:expr) =&gt; {<!-- -->{
        {
            let val: usize = $e; // Force types to be integers
            println!("{} = {}", stringify!{$e}, val);
        }
    }};

    // 递归地拆解多重的 `eval`
    (eval $e:expr, $(eval $es:expr),+) =&gt; {<!-- -->{
        calculate! { eval $e }
        calculate! { $(eval $es),+ }
    }};
}

fn main() {
    calculate! { // 妈妈快看，可变参数的 `calculate!`！
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }
}
</code></pre> 
<p>输出：<br> 1 + 2 = 3<br> 3 + 4 = 7<br> (2 * 3) + 1 = 7</p> 
<p></p> 
<h4><strong>过程宏：从属性生成代码</strong></h4> 
<p>第二种形式的宏被称为 <strong>过程宏</strong>（<em>procedural macros</em>），因为它们更像函数（一种过程类型）。过程宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，而非像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码。有三种类型的过程宏（<strong><span style="background-color:#ffd900;">自定义派生（derive），类属性和类函数</span></strong>），不过它们的工作方式都类似。</p> 
<pre><code class="language-rust">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre> 
<p>定义过程宏的函数接收一个 TokenStream 作为输入并生成 TokenStream 作为输出。<code>TokenStream</code> 是定义于<code>proc_macro</code> crate 里代表一系列 token 的类型，Rust 默认携带了<code>proc_macro</code> crate。这就是宏的核心：宏所处理的源代码组成了输入 <code>TokenStream</code>，宏生成的代码是输出 <code>TokenStream</code>。函数上还有一个属性；这个属性指明了我们创建的过程宏的类型。在同一 crate 中可以有多种的过程宏。</p> 
<p></p> 
<h4><strong>过程宏：编写自定义 derive 宏</strong></h4> 
<p>提供一个过程式宏以便用户可以使用 <code>#[derive(HelloMacro)]</code> 注解它们的类型来得到 <code>hello_macro</code> 函数的默认实现。该默认实现会打印 <code>Hello, Macro! My name is TypeName!</code>，其中 <code>TypeName</code> 为定义了 trait 的类型名。</p> 
<p></p> 
<h4><strong>过程宏：类属性宏</strong></h4> 
<p>类属性宏与自定义派生宏相似，不同的是 <code>derive</code> 属性生成代码，它们（类属性宏）能让你创建新的属性。它们也更为灵活；<code>derive</code> 只能用于结构体和枚举；属性还可以用于其它的项，比如函数。作为一个使用类属性宏的例子，可以创建一个名为 <code>route</code> 的属性用于注解 web 应用程序框架（web application framework）的函数：</p> 
<blockquote> 
 <p>#[route(GET, "/")]<br> fn index() {<!-- --></p> 
</blockquote> 
<p></p> 
<h4><strong>过程宏：</strong>类函数宏</h4> 
<p>类函数（Function-like）宏的定义看起来像函数调用的宏。类似于 <code>macro_rules!</code>，它们比函数更灵活；例如，可以接受未知数量的参数。然而 <code>macro_rules!</code> 宏只能使用之前 <a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html#%E4%BD%BF%E7%94%A8-macro_rules-%E7%9A%84%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%94%A8%E4%BA%8E%E9%80%9A%E7%94%A8%E5%85%83%E7%BC%96%E7%A8%8B" rel="nofollow" title="“使用 macro_rules! 的声明宏用于通用元编程”">“使用 macro_rules! 的声明宏用于通用元编程”</a> 介绍的类匹配的语法定义。类函数宏获取 <code>TokenStream</code> 参数，其定义使用 Rust 代码操纵 <code>TokenStream</code>，就像另两种过程宏一样。一个类函数宏例子是可以像这样被调用的 <code>sql!</code> 宏：</p> 
<blockquote> 
 <p>let sql = sql!(SELECT * FROM posts WHERE id=1);</p> 
</blockquote> 
<p>这个宏会解析其中的 SQL 语句并检查其是否是句法正确的，这是比 <code>macro_rules!</code> 可以做到的更为复杂的处理。<code>sql!</code> 宏应该被定义为如此：</p> 
<blockquote> 
 <p>#[proc_macro]</p> 
 <p>pub fn sql(input: TokenStream) -&gt; TokenStream {<!-- --></p> 
</blockquote> 
<p>这类似于自定义派生宏的签名：获取括号中的 token，并返回希望生成的代码。</p> 
<p></p> 
<h3>程序 参数</h3> 
<p>命令行参数可使用 <code>std::env::args</code> 进行接收，这将返回一个迭代器，该迭代器会对每个参数举出一个字符串。</p> 
<pre><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // 第一个参数是调用本程序的路径
    println!("My path is {}.", args[0]);

    // 其余的参数是被传递给程序的命令行参数。
    // 请这样调用程序：
    //   $ ./args arg1 arg2
    println!("I got {:?} arguments: {:?}.", args.len() - 1, &amp;args[1..]);
}
</code></pre> 
<p>可以用模式匹配来解析简单的参数：</p> 
<pre><code class="language-rust">use std::env;

fn increase(number: i32) {
    println!("{}", number + 1);
}

fn decrease(number: i32) {
    println!("{}", number - 1);
}

fn help() {
    println!("usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {<!-- -->{increase|decrease}} &lt;integer&gt;
    Increase or decrease given integer by one.");
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // 没有传入参数
        1 =&gt; {
            println!("My name is 'match_args'. Try passing some arguments!");
        },
        // 一个传入参数
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!("This is the answer!"),
                _ =&gt; println!("This is not the answer."),
            }
        },
        // 传入一条命令和一个参数
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // 解析数字
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    println!("error: second argument not an integer");
                    help();
                    return;
                },
            };
            // 解析命令
            match &amp;cmd[..] {
                "increase" =&gt; increase(number),
                "decrease" =&gt; decrease(number),
                _ =&gt; {
                    println!("error: invalid command");
                    help();
                },
            }
        },
        // 所有其他情况
        _ =&gt; {
            // 显示帮助信息
            help();
        }
    }
}
</code></pre> 
<p>$ ./match_args Rust<br> This is not the answer.<br> $ ./match_args 42<br> This is the answer!<br> $ ./match_args do something<br> error: second argument not an integer<br> usage:<br> match_args &lt;string&gt;<br>     Check whether given string is the answer.<br> match_args {increase|decrease} &lt;integer&gt;<br>     Increase or decrease given integer by one.<br> $ ./match_args do 42<br> error: invalid command<br> usage:<br> match_args &lt;string&gt;<br>     Check whether given string is the answer.<br> match_args {increase|decrease} &lt;integer&gt;<br>     Increase or decrease given integer by one.<br> $ ./match_args increase 42<br> 43<br>  </p> 
<h3>Rust 测试</h3> 
<p>测试有三种风格：</p> 
<ul><li><a href="https://rustwiki.org/zh-CN/rust-by-example/testing/unit_testing.html" rel="nofollow" title="单元">单元</a>测试。</li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/testing/doc_testing.html" rel="nofollow" title="文档">文档</a>测试。</li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/testing/integration_testing.html" rel="nofollow" title="集成">集成</a>测试。</li></ul> 
<p>Rust 也支持在测试中指定额外的依赖：</p> 
<ul><li><a href="https://rustwiki.org/zh-CN/rust-by-example/testing/dev_dependencies.html" rel="nofollow" title="开发依赖">开发依赖</a></li></ul> 
<p></p> 
<h4>单元测试</h4> 
<p>大多数单元测试都会被放到一个叫 <code>tests</code> 的、带有 <code>#[cfg(test)]</code> 属性的<a href="https://rustwiki.org/zh-CN/rust-by-example/mod.html" rel="nofollow" title="模块">模块</a>中，测试函数要加上 <code>#[test]</code> 属性。</p> 
<p>当测试函数中有什么东西 <a href="https://rustwiki.org/zh-CN/rust-by-example/std/panic.html" rel="nofollow" title="panic">panic</a> 了，测试就失败。有一些这方面的辅助<a href="https://rustwiki.org/zh-CN/rust-by-example/macros.html" rel="nofollow" title="宏">宏</a>：</p> 
<ul><li><code>assert!(expression)</code> - 如果表达式的值是 <code>false</code> 则 panic。</li><li><code>assert_eq!(left, right)</code> 和 <code>assert_ne!(left, right)</code> - 检验左右两边是否 相等/不等。</li></ul> 
<pre><code class="language-rust">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// 这个加法函数写得很差，本例中我们会使它失败。
#[allow(dead_code)]
fn bad_add(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[cfg(test)]
mod tests {
    // 注意这个惯用法：在 tests 模块中，从外部作用域导入所有名字。
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        // 这个断言会导致测试失败。注意私有的函数也可以被测试！
        assert_eq!(bad_add(1, 2), 3);
    }
}
</code></pre> 
<p>可以使用 <code>cargo test</code> 来运行测试。</p> 
<p>测试 panic</p> 
<p>一些函数应当在特定条件下 panic。为测试这种行为，请使用 <code>#[should_panic]</code> 属性。这个属性接受可选参数 <code>expected = </code>以指定 panic 时的消息。如果你的函数能以多种方式 panic，这个属性就保证了你在测试的确实是所指定的 panic。</p> 
<pre><code class="language-rust">pub fn divide_non_zero_result(a: u32, b: u32) -&gt; u32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    } else if a &lt; b {
        panic!("Divide result is zero");
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = "Divide result is zero")]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}
</code></pre> 
<p>运行特定的测试。要运行特定的测试，只要把测试名称传给 <code>cargo test</code> 命令就可以了。</p> 
<p>cargo test test_any_panic<br> cargo test panic</p> 
<p>忽略测试。可以把属性 #[ignore] 赋予测试以排除某些测试，或者使用 cargo test -- --ignored 命令来运行它们。</p> 
<pre><code class="language-rust">
#![allow(unused)]
fn main() {
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}
}
</code></pre> 
<p>cargo test<br> cargo test -- --ignored</p> 
<p></p> 
<h4>集成测试</h4> 
<p><a href="https://rustwiki.org/zh-CN/rust-by-example/testing/unit_testing.html" rel="nofollow" title="单元测试">单元测试</a>一次仅能单独测试一个模块，这种测试是小规模的，并且能测试私有代码；集成测试是 crate 外部的测试，并且仅使用 crate 的公共接口，就像其他使用该 crate 的程序那样。集成测试的目的是检验你的库的各部分是否能够正确地协同工作。</p> 
<p>cargo 在与 <code>src</code> 同级别的 <code>tests</code> 目录寻找集成测试。</p> 
<p>文件 <code>src/lib.rs</code>：</p> 
<pre><code class="language-rust">// 在一个叫做 'adder' 的 crate 中定义此函数。
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre> 
<p>包含测试的文件：<code>tests/integration_test.rs</code>：</p> 
<pre><code class="language-rust">
#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre> 
<p>使用 <code>cargo test</code> 命令：</p> 
<p><code>tests</code> 目录中的每一个 Rust 源文件都被编译成一个单独的 crate。在集成测试中要想共享代码，一种方式是创建具有公用函数的模块，然后在测试中导入并使用它。</p> 
<p>文件 <code>tests/common.rs</code>:</p> 
<pre><code class="language-rust">pub fn setup() {
    // 一些配置代码，比如创建文件/目录，开启服务器等等。
}
</code></pre> 
<p>包含测试的文件：<code>tests/integration_test.rs</code></p> 
<pre><code class="language-rust">// 导入共用模块。
mod common;

#[test]
fn test_add() {
    // 使用共用模块。
    common::setup();
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre> 
<p></p> 
<h4>开发依赖</h4> 
<p>有时仅在测试中才需要一些依赖（比如基准测试相关的）。这种依赖要写在 <code>Cargo.toml</code> 的 <code>[dev-dependencies]</code> 部分。这些依赖不会传播给其他依赖于这个包的包。</p> 
<p>比如说使用 <code>pretty_assertions</code>，这是扩展了标准的 <code>assert!</code> 宏的一个 crate。</p> 
<blockquote> 
 <p># 这里省略了标准的 crate 数据<br> [dev-dependencies]<br> pretty_assertions = "1"</p> 
</blockquote> 
<p>文件 <code>src/lib.rs</code>:</p> 
<pre><code class="language-rust">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq; // 仅用于测试, 不能在非测试代码中使用

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
</code></pre> 
<p></p> 
<h3>Rust 高级特征</h3> 
<p>涉及如下内容：</p> 
<ul><li>不安全 Rust：用于当需要舍弃 Rust 的某些保证并负责手动维持这些保证</li><li>高级 trait：与 trait 相关的关联类型，默认类型参数，完全限定语法（fully qualified syntax），超（父）trait（supertraits）和 newtype 模式</li><li>高级类型：关于 newtype 模式的更多内容，类型别名，never 类型和动态大小类型</li><li>高级函数和闭包：函数指针和返回闭包</li><li>宏：定义在编译时定义更多代码的方式</li></ul> 
<p></p> 
<h4>unsafe(不安全) 操作</h4> 
<p>不安全代码块主要用于四件事情：</p> 
<ul><li>解引用裸指针</li><li>通过 FFI 调用函数（在<a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/ffi.html" rel="nofollow" title="之前的章节">之前的章节</a>介绍过）</li><li>调用不安全的函数</li><li>内联汇编（inline assembly）</li></ul> 
<p>上面所有论过的代码都有 Rust 在编译时会强制执行的内存安全保证。然而，Rust 还隐藏有第二种语言，它不会强制执行这类内存安全保证：这被称为 <strong>不安全 Rust</strong>（<em>unsafe Rust</em>）。它与常规 Rust 代码无异，但是会提供额外的超能力。尽管代码可能没问题，但如果 Rust 编译器没有足够的信息可以确定，它将拒绝代码。</p> 
<p>不安全 Rust 之所以存在，是因为静态分析本质上是保守的。当编译器尝试确定一段代码是否支持某个保证时，拒绝一些合法的程序比接受无效的程序要好一些。这必然意味着有时代码 <strong>可能</strong> 是合法的，但如果 Rust 编译器没有足够的信息来确定，它将拒绝该代码。在这种情况下，可以使用不安全代码告诉编译器，“相信我，我知道我在干什么。” 不过千万注意，使用不安全 Rust 风险自担：如果不安全代码出错了，比如解引用空指针，可能会导致不安全的内存使用。</p> 
<p>另一个 Rust 存在不安全一面的原因是：底层计算机硬件固有的不安全性。如果 Rust 不允许进行不安全操作，那么有些任务则根本完成不了。Rust 需要能够进行像直接与操作系统交互，甚至于编写你自己的操作系统这样的底层系统编程！这也是 Rust 语言的目标之一。</p> 
<p>通过 <code>unsafe</code> 关键字来切换到不安全 Rust，接着可以开启一个新的存放不安全代码的块。这里有五类可以在不安全 Rust 中进行而不能用于安全 Rust 的操作，它们称之为 “不安全的超能力。（<em>unsafe superpowers</em>）” 这些超能力是：</p> 
<ul><li>解引用裸指针</li><li>调用不安全的函数或方法</li><li>访问或修改可变静态变量</li><li>实现不安全 trait</li><li>访问 <code>union</code> 的字段</li></ul> 
<p><code>unsafe</code> 并不会关闭借用检查器或禁用任何其他 Rust 安全检查：如果在不安全代码中使用引用，它仍会被检查。<code>unsafe</code> 关键字只是提供了那五个不会被编译器检查内存安全的功能。你仍然能在不安全块中获得某种程度的安全。</p> 
<p>再者，<code>unsafe</code> 不意味着块中的代码就一定是危险的或者必然导致内存安全问题：其意图在于作为程序员你将会确保 <code>unsafe</code> 块中的代码以有效的方式访问内存。</p> 
<p>人是会犯错误的，错误总会发生，不过通过要求这五类操作必须位于标记为 <code>unsafe</code> 的块中，就能够知道任何与内存安全相关的错误必定位于 <code>unsafe</code> 块内。保持 <code>unsafe</code> 块尽可能小，如此当之后调查内存 bug 时就会感谢你自己了。</p> 
<p>为了尽可能隔离不安全代码，将不安全代码封装进一个安全的抽象并提供安全 API 是一个好主意，当我们学习不安全函数和方法时会讨论到。标准库的一部分被实现为在被评审过的不安全代码之上的安全抽象。这个技术防止了 <code>unsafe</code> 泄露到所有你或者用户希望使用由 <code>unsafe</code> 代码实现的功能的地方，因为使用其安全抽象是安全的。</p> 
<p></p> 
<h4>原始指针（raw pointer，裸指针）</h4> 
<p>裸指针与引用和智能指针的区别在于</p> 
<ul><li>允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针</li><li>不保证指向有效的内存</li><li>允许为空</li><li>不能实现任何自动清理功能</li></ul> 
<p>从引用同时创建不可变和可变裸指针。</p> 
<pre><code class="language-rust">fn main() {
    let mut int_val = 5;

    let r1 = &amp;int_val as *const i32;
    let r2 = &amp;mut int_val as *mut i32;

    println!("{:?}", r1);
    println!("{:?}", r2);

    unsafe { *r2 = 100; }
    println!("{:?}", r2);

    unsafe {
        println!("{:?}", *r1);
        println!("{:?}", *r2);
    }
}</code></pre> 
<p>原始指针（raw pointer，裸指针）<code>*</code> 和引用 <code>&amp;T</code> 有类似的功能，但引用总是安全的，因为借用检查器保证了它指向一个有效的数据。解引用一个裸指针只能通过不安全代码块执行。</p> 
<pre><code class="language-rust">fn main() {
    let raw_p: *const u32 = &amp;10;

    unsafe {
        assert!(*raw_p == 10);
    }
}
</code></pre> 
<p></p> 
<h4><strong>调用 unsafe 函数或方法</strong></h4> 
<p>第二类可以在不安全块中进行的操作是调用不安全函数。不安全函数和方法与常规函数方法十分类似，除了其开头有一个额外的 <code>unsafe</code>。在此上下文中，关键字<code>unsafe</code>表示该函数具有调用时需要满足的要求，而 Rust 不会保证满足这些要求。通过在 <code>unsafe</code> 块中调用不安全函数，表明我们已经阅读过此函数的文档并对其是否满足函数自身的契约负责。<span style="background-color:#ffd900;">不安全函数体也是有效的 </span><code><span style="background-color:#ffd900;">unsafe</span></code><span style="background-color:#ffd900;"> 块，所以在不安全函数中进行另一个不安全操作时无需新增额外的 </span><code><span style="background-color:#ffd900;">unsafe</span></code><span style="background-color:#ffd900;"> 块。</span></p> 
<blockquote> 
 <p>unsafe fn dangerous() {}</p> 
 <p>unsafe {<!-- --><br>     dangerous();<br> }</p> 
</blockquote> 
<p>一些函数可以声明为不安全的（<code>unsafe</code>），这意味着在使用它时保证正确性不再是编译器的责任，而是程序员的。一个例子就是 <a href="https://rustwiki.org/zh-CN/std/slice/fn.from_raw_parts.html" rel="nofollow" title="std::slice::from_raw_parts">std::slice::from_raw_parts</a>，向它传入指向第一个元素的指针和长度参数，它会创建一个切片。</p> 
<pre><code class="language-rust">use std::slice;

fn main() {
    let some_vector = vec![1, 2, 3, 4];

    let pointer = some_vector.as_ptr();
    let length = some_vector.len();

    unsafe {
        let my_slice: &amp;[u32] = slice::from_raw_parts(pointer, length);

        assert_eq!(some_vector.as_slice(), my_slice);
    }
}
</code></pre> 
<p>slice::from_raw_parts 假设传入的指针指向有效的内存，且被指向的内存具有正确的数据类型，我们必须满足这一假设，否则程序的行为是未定义的（undefined），于是我们就不能预测会发生些什么了。</p> 
<p></p> 
<h4><strong>创建 unsafe 代码的安全抽象</strong></h4> 
<p>仅仅因为函数包含不安全代码并不意味着整个函数都需要标记为不安全的。事实上，将不安全代码封装进安全函数是一个常见的抽象。</p> 
<pre><code class="language-rust">fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];
    let r = &amp;mut v[..];
    let (a, b) = r.split_at_mut(3);
    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
}</code></pre> 
<p>示例：</p> 
<pre><code class="language-rust">use std::slice;
fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();
    assert!(mid &lt;= len);
    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}

fn main() {
    let address = 0x01234usize;
    let r = address as *mut i32;
    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
}</code></pre> 
<p> <a href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#slice-%E7%B1%BB%E5%9E%8B" rel="nofollow" title="“Slice 类型” ">“Slice 类型” </a>部分，slice 是一个指向一些数据的指针，并带有该 slice 的长度。可以使用 <code>len</code> 方法获取 slice 的长度，使用 <code>as_mut_ptr</code> 方法访问 slice 的裸指针。</p> 
<p></p> 
<h4>使用 extern 函数调用外部代码</h4> 
<p>有时你的 Rust 代码可能需要与其他语言编写的代码交互。为此 Rust 有一个关键字，<code>extern</code>，有助于创建和使用 <strong>外部函数接口</strong>（<em>Foreign Function Interface</em>，FFI）。外部函数接口是一个编程语言用以定义函数的方式，其允许不同（外部）编程语言调用这些函数。</p> 
<p>示例：如何集成 C 标准库中的 <code>abs</code> 函数。</p> 
<pre><code class="language-rust">extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}</code></pre> 
<p>Rust 提供了到 C 语言库的外部语言函数接口（Foreign Function Interface，FFI）。外部语言函数必须在一个 <code>extern</code> 代码块中声明，且该代码块要带有一个包含库名称的 <code>#[link]</code> 属性。</p> 
<pre><code class="language-rust">use std::fmt;

// 这个 extern 代码块链接到 libm 库
#[link(name = "m")]
extern {
    // 这个外部函数用于计算单精度复数的平方根
    fn csqrtf(z: Complex) -&gt; Complex;

    // 这个用来计算单精度复数的复变余弦
    fn ccosf(z: Complex) -&gt; Complex;
}

// 由于调用其他语言的函数被认为是不安全的，我们通常会给它们写一层安全的封装
fn cos(z: Complex) -&gt; Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };

    // 调用外部语言函数是不安全操作
    let z_sqrt = unsafe { csqrtf(z) };

    println!("the square root of {:?} is {:?}", z, z_sqrt);

    // 调用不安全操作的安全的 API 封装
    println!("cos({:?}) = {:?}", z, cos(z));
}

// 单精度复数的最简实现
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, "{}-{}i", self.re, -self.im)
        } else {
            write!(f, "{}+{}i", self.re, self.im)
        }
    }
}
</code></pre> 
<p></p> 
<h4>访问或修改可变静态变量</h4> 
<p>Rust 避免讨论 <strong>全局变量</strong>（<em>global variables</em>），Rust 确实支持，不过这对于 Rust 的所有权规则来说是有问题的。如果有两个线程访问相同的可变全局变量，则可能会造成数据竞争。</p> 
<p>全局变量在 Rust 中被称为 <strong>静态</strong>（<em>static</em>）变量。</p> 
<pre><code class="language-rust">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}</code></pre> 
<p>静态（<code>static</code>）变量类似于 <a href="https://kaisery.github.io/trpl-zh-cn/ch03-01-variables-and-mutability.html#%E5%B8%B8%E9%87%8F" rel="nofollow" title="“变量和常量的区别”">“变量和常量的区别”</a> 部分讨论的常量。通常静态变量的名称采用 <code>SCREAMING_SNAKE_CASE</code> 写法。静态变量只能储存拥有 <code>'static</code> 生命周期的引用，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注。访问不可变静态变量是安全的。</p> 
<pre><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        // 读取或修改一个可变静态变量是不安全的
        println!("COUNTER: {}", COUNTER);
    }
}</code></pre> 
<p>注意：拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的。任何可能的情况，请优先使用第十六章讨论的并发技术和线程安全智能指针，这样编译器就能检测不同线程间的数据访问是否是安全的。</p> 
<h4>实现 unsafe trait</h4> 
<p><code>unsafe</code> 的另一个操作用例是实现不安全 trait。当 trait 中至少有一个方法中包含编译器无法验证的不变式（invariant）时 trait 是不安全的。可以在 <code>trait</code> 之前增加 <code>unsafe</code> 关键字将 trait 声明为 <code>unsafe</code>，同时 trait 的实现也必须标记为 <code>unsafe</code>，</p> 
<pre><code class="language-rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}</code></pre> 
<h4>关联类型在 trait 定义中指定占位符类型</h4> 
<p><strong>关联类型</strong>（<em>associated types</em>）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。trait 的实现者会针对特定的实现在这个占位符类型指定相应的具体类型。如此可以定义一个使用多种类型的 trait，直到实现此 trait 时都无需知道这些类型具体是什么。</p> 
<p>个带有关联类型的 trait 的例子是标准库提供的 <code>Iterator</code> trait。它有一个叫做 <code>Item</code> 的关联类型来替代遍历的值的类型。<code>Iterator</code> trait 的定义如示例</p> 
<pre><code class="language-rust">pub trait Iterator {
    // Iterator trait 的定义中带有关联类型 Item
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}

struct Counter{}

impl Iterator for Counter {
    // 实现中指定了 Item 的类型为 u32：
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
        Some(5)
    }
}
fn main() {
    let mut temp = Counter{};
    match temp.next() {
        Some(val) =&gt; println!("{val}"),
        _ =&gt; println!("返回值为空")
    };
}</code></pre> 
<p>这个语法类似于泛型。</p> 
<pre><code class="language-rust">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre> 
<h4>默认泛型类型参数和运算符重载</h4> 
<p>当使用泛型类型参数时，可以为泛型指定一个默认的具体类型。如果默认类型就足够的话，这消除了为具体类型实现 trait 的需要。为泛型类型指定默认类型的语法是在声明泛型类型时使用：<code>&lt;PlaceholderType=ConcreteType&gt;</code>。</p> 
<p>这种情况的一个非常好的例子是使用 <strong>运算符重载</strong>（<em>Operator overloading</em>），这是指在特定情况下自定义运算符（比如 <code>+</code>）行为的操作。</p> 
<pre><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre> 
<p><code>add</code> 方法将两个 <code>Point</code> 实例的 <code>x</code> 值和 <code>y</code> 值分别相加来创建一个新的 <code>Point</code>。<code>Add</code> trait 有一个叫做 <code>Output</code> 的关联类型，它用来决定 <code>add</code> 方法的返回值类型。</p> 
<p>这里默认泛型类型位于 <code>Add</code> trait 中。这里是其定义：</p> 
<pre><code class="language-rust">trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
</code></pre> 
<p>带有一个方法和一个关联类型的 trait。尖括号中的 <code>Rhs=Self</code>：这个语法叫做 <strong>默认类型参数</strong>（<em>default type parameters</em>）。<code>Rhs</code> 是一个泛型类型参数（“right hand side” 的缩写），它用于定义 <code>add</code> 方法中的 <code>rhs</code> 参数。如果实现 <code>Add</code> trait 时不指定 <code>Rhs</code> 的具体类型，<code>Rhs</code> 的类型将是默认的 <code>Self</code> 类型，也就是在其上实现 <code>Add</code> 的类型。</p> 
<h4>完全限定语法与消歧义：调用相同名称的方法</h4> 
<p>完全限定语法定义为：<span style="color:#fe2c24;"><strong>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</strong></span></p> 
<p>Rust 既不能避免一个 trait 与另一个 trait 拥有相同名称的方法，也不能阻止为同一类型同时实现这两个 trait。甚至直接在类型上实现开始已经有的同名方法也是可能的！</p> 
<p>不过，当调用这些同名方法时，需要告诉 Rust 我们希望使用哪一个。</p> 
<pre><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*waving arms furiously*");
    }
}
fn main() {
    let p1 = Human{};
    /*当调用 Human 实例的 fly 时，编译器默认调用直接实现在类型上的方法*/
    p1.fly();

    let p2 = Human;
    Human::fly(&amp;p2);
    
    let p3 = Human;
    Pilot::fly(&amp;p3);
    Wizard::fly(&amp;p3);
    p3.fly();
}
</code></pre> 
<p>示例：</p> 
<pre><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("11111")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("22222")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
    println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
}</code></pre> 
<h4>trait 中使用另一个 trait</h4> 
<p>可能会需要编写一个依赖另一个 trait 的 trait 定义：对于一个实现了第一个 trait 的类型，你希望要求这个类型也实现了第二个 trait。如此就可使 trait 定义使用第二个 trait 的关联项。这个所需的 trait 是我们实现的 trait 的 <strong>父（超）trait</strong>（<em>supertrait</em>）。</p> 
<pre><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
struct Point {
    x: i32,
    y: i32,
}
impl OutlinePrint for Point {}
impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

fn main() {
    let p = Point{x:1, y:2};
    p.outline_print()
}

</code></pre> 
<p>实现 OutlinePrint trait，它要求来自 Display 的功能。因为指定了 <code>OutlinePrint</code> 需要 <code>Display</code> trait，则可以在 <code>outline_print</code> 中使用 <code>to_string</code>，其会为任何实现 <code>Display</code> 的类型自动实现。如果不在 trait 名后增加 <code>: Display</code> 并尝试在 <code>outline_print</code> 中使用 <code>to_string</code>，则会得到一个错误说在当前作用域中没有找到用于 <code>&amp;Self</code> 类型的方法 <code>to_string</code>。</p> 
<h4>newtype 模式用以在外部类型上实现外部 trait</h4> 
<p> <a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0-trait" rel="nofollow" title="“为类型实现 trait”">“为类型实现 trait”</a> 部分，提到了孤儿规则（orphan rule），它说明只要 trait 或类型对于当前 crate 是本地的话就可以在此类型上实现该 trait。一个绕开这个限制的方法是使用 <strong>newtype 模式</strong>（<em>newtype pattern</em>），它涉及到在一个元组结构体（ <a href="https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E6%B2%A1%E6%9C%89%E5%91%BD%E5%90%8D%E5%AD%97%E6%AE%B5%E7%9A%84%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E5%9E%8B" rel="nofollow" title="“用没有命名字段的元组结构体来创建不同的类型”">“用没有命名字段的元组结构体来创建不同的类型”</a> 介绍了元组结构体）中创建一个新类型。这个元组结构体带有一个字段作为希望实现 trait 的类型的简单封装。接着这个封装类型对于 crate 是本地的，这样就可以在这个封装上实现 trait。<em>Newtype</em> 是一个源自 （U.C.0079，逃） Haskell 编程语言的概念。使用这个模式没有运行时性能惩罚，这个封装类型在编译时就被省略了。</p> 
<p>例如，如果想要在 <code>Vec&lt;T&gt;</code> 上实现 <code>Display</code>，而孤儿规则阻止我们直接这么做，因为 <code>Display</code> trait 和 <code>Vec&lt;T&gt;</code> 都定义于我们的 crate 之外。可以创建一个包含 <code>Vec&lt;T&gt;</code> 实例的 <code>Wrapper</code> 结构体，接着可以如列表 19-23 那样在 <code>Wrapper</code> 上实现 <code>Display</code> 并使用 <code>Vec&lt;T&gt;</code> 的值：</p> 
<pre><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}</code></pre> 
<p><code>Display</code> 的实现使用 <code>self.0</code> 来访问其内部的 <code>Vec&lt;T&gt;</code>，因为 <code>Wrapper</code> 是元组结构体而 <code>Vec&lt;T&gt;</code> 是结构体总位于索引 0 的项。接着就可以使用 <code>Wrapper</code> 中 <code>Display</code> 的功能了。</p> 
<p>此方法的缺点是，因为 <code>Wrapper</code> 是一个新类型，它没有定义于其值之上的方法；必须直接在 <code>Wrapper</code> 上实现 <code>Vec&lt;T&gt;</code> 的所有方法，这样就可以代理到<code>self.0</code> 上 —— 这就允许我们完全像 <code>Vec&lt;T&gt;</code> 那样对待 <code>Wrapper</code>。如果希望新类型拥有其内部类型的每一个方法，为封装类型实现 <code>Deref</code> trait（第十五章 <a href="https://kaisery.github.io/trpl-zh-cn/ch15-02-deref.html#%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0-deref-trait-%E5%B0%86%E6%9F%90%E7%B1%BB%E5%9E%8B%E5%83%8F%E5%BC%95%E7%94%A8%E4%B8%80%E6%A0%B7%E5%A4%84%E7%90%86" rel="nofollow" title="“通过 Deref trait 将智能指针当作常规引用处理”">“通过 Deref trait 将智能指针当作常规引用处理”</a> 部分讨论过）并返回其内部类型是一种解决方案。如果不希望封装类型拥有所有内部类型的方法 —— 比如为了限制封装类型的行为 —— 则必须只自行实现所需的方法。</p> 
<p></p> 
<h4>类型 别名</h4> 
<p>使用 <code>type</code> 关键字来给予现有类型另一个名字。例如，可以像这样创建 <code>i32</code> 的别名 <code>Kilometers</code>：</p> 
<blockquote> 
 <p>type Kilometers = i32;</p> 
</blockquote> 
<p>类型别名的主要用途是减少重复。例如，可能会有这样很长的类型：Box&lt;dyn Fn() + Send + 'static&gt;</p> 
<p>在函数签名或类型注解中每次都书写这个类型将是枯燥且易于出错的。示例代码的项目：</p> 
<blockquote> 
 <p>let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hi"));</p> 
 <p>fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {<!-- --><br>     // --snip--<br> }</p> 
 <p>fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {<!-- --><br>     // --snip--<br> }</p> 
</blockquote> 
<p>示例：</p> 
<pre><code class="language-rust">use std::fmt;
use std::io::Error;

pub trait Write_1 {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}

type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
pub trait Write_2 {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre> 
<h4></h4> 
<h4>函数指针</h4> 
<p>向函数传递常规函数。<code>fn</code> 被称为 <strong>函数指针</strong>（<em>function pointer</em>）。通过函数指针允许我们使用函数作为另一个函数的参数。</p> 
<p>指定参数为函数指针的语法类似于闭包</p> 
<pre><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);
}</code></pre> 
<p>示例 ：</p> 
<pre><code class="language-rust">fn main() {
    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
    println!("{:?}", list_of_strings);

    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
    println!("{:?}", list_of_strings);
}</code></pre> 
<h4>返回闭包</h4> 
<p>闭包表现为 trait，这意味着不能直接返回闭包。因为它们没有一个可返回的具体类型；例如不允许使用函数指针 <code>fn</code> 作为返回值类型。</p> 
<p>这段代码尝试直接返回闭包，它并不能编译：</p> 
<pre><code class="language-rust">fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}</code></pre> 
<p>错误又一次指向了 <code>Sized</code> trait！Rust 并不知道需要多少空间来储存闭包。不过我们在上一部分见过这种情况的解决办法：可以使用 trait 对象：</p> 
<pre><code class="language-rust">fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}</code></pre> 
<p>这段代码正好可以编译。关于 trait 对象的更多内容 <a href="https://kaisery.github.io/trpl-zh-cn/ch17-02-trait-objects.html#%E4%B8%BA%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E8%80%8C%E8%AE%BE%E8%AE%A1%E7%9A%84-trait-%E5%AF%B9%E8%B1%A1" rel="nofollow" title="“为使用不同类型的值而设计的 trait 对象”">“为使用不同类型的值而设计的 trait 对象”</a> 。</p> 
<p></p> 
<p></p> 
<h3>项目：构建多线程 web server</h3> 
<p>：<a class="link-info" href="https://kaisery.github.io/trpl-zh-cn/ch20-00-final-project-a-web-server.html" rel="nofollow" title="https://kaisery.github.io/trpl-zh-cn/ch20-00-final-project-a-web-server.html">https://kaisery.github.io/trpl-zh-cn/ch20-00-final-project-a-web-server.html</a></p> 
<p>实现一个返回 “hello” 的 web server，它在浏览器中看起来就如图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f0/15/DKQR8MTU_o.png"></p> 
<p>内容</p> 
<ol><li>学习一些 TCP 与 HTTP 知识</li><li>在套接字（socket）上监听 TCP 请求</li><li>解析少量的 HTTP 请求</li><li>创建一个合适的 HTTP 响应</li><li>通过线程池改善 server 的吞吐量</li></ol> 
<p>这里使用的方法并不是使用 Rust 构建 web server 最好的方法。<a href="https://crates.io/" rel="nofollow" title="crates.io">crates.io</a> 上有很多可用于生产环境的 crate，它们提供了更为完整的 web server 和线程池实现。本章的目的在于学习，而不是走捷径。新建一个项目：cargo new hello</p> 
<h4><strong>监听 TCP 连接</strong></h4> 
<pre><code class="language-rust">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}</code></pre> 
<h4>读取请求</h4> 
<pre><code class="language-rust">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre> 
<p>hello.html</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>404.html</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre> 
<pre><code class="language-rust">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    for stream in listener.incoming() {
        let stream = stream.unwrap();
        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre> 
<h4>变为多线程 server</h4> 
<p><strong>线程池</strong>（<em>thread pool</em>）是一组预先分配的等待或准备处理任务的线程。当程序收到一个新任务，线程池中的一个线程会被分配任务，这个线程会离开并处理任务。其余的线程则可用于处理在第一个线程处理任务的同时处理其他接收到的任务。当第一个线程处理完任务时，它会返回空闲线程池中等待处理新任务。线程池允许我们并发处理连接，增加 server 的吞吐量。</p> 
<p>为每一个请求分配线程</p> 
<pre><code class="language-rust">fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
</code></pre> 
<p>创建有限数量的线程</p> 
<pre><code class="language-rust">fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
</code></pre> 
<h4>优雅停机与清理</h4> 
<p>为 <code>ThreadPool</code> 实现 <code>Drop</code> trait 对线程池中的每一个线程调用 <code>join</code>，这样这些线程将会执行完它们的请求。接着会为 <code>ThreadPool</code> 实现一个告诉线程它们应该停止接收新请求并结束的方式。</p> 
<p></p> 
<p></p> 
<p></p> 
<h2>4、Rust 语言圣经(Rust Course)</h2> 
<p></p> 
<p>：<a class="link-info" href="https://course.rs/about-book.html" rel="nofollow" title="https://course.rs/about-book.html">https://course.rs/about-book.html</a></p> 
<p></p> 
<h3>Rust 语言基础学习</h3> 
<blockquote> 
 <p>1. 寻找牛刀，以便小试：<a class="link-info" href="https://course.rs/first-try/intro.html" rel="nofollow" title="https://course.rs/first-try/intro.html">https://course.rs/first-try/intro.html</a><br> 2. Rust 基础入门：<a class="link-info" href="https://course.rs/basic/intro.html" rel="nofollow" title="https://course.rs/basic/intro.html">https://course.rs/basic/intro.html</a><br> 3. 入门实战：文件搜索工具：<a class="link-info" href="https://course.rs/basic-practice/intro.html" rel="nofollow" title="https://course.rs/basic-practice/intro.html">https://course.rs/basic-practice/intro.html</a></p> 
</blockquote> 
<h3>Rust 语言进阶学习</h3> 
<blockquote> 
 <p>4. Rust 高级进阶：<a class="link-info" href="https://course.rs/advance/intro.html" rel="nofollow" title="https://course.rs/advance/intro.html">https://course.rs/advance/intro.html</a><br> 5. 进阶实战1: 实现一个 web 服务器：<a class="link-info" href="https://course.rs/advance-practice1/intro.html" rel="nofollow" title="https://course.rs/advance-practice1/intro.html">https://course.rs/advance-practice1/intro.html</a><br> 6. 进阶实战2: 实现一个简单 Redis：<a class="link-info" href="https://course.rs/advance-practice/intro.html" rel="nofollow" title="https://course.rs/advance-practice/intro.html">https://course.rs/advance-practice/intro.html</a><br> 7. Rust 难点攻关：<a class="link-info" href="https://course.rs/difficulties/intro.html" rel="nofollow" title="https://course.rs/difficulties/intro.html">https://course.rs/difficulties/intro.html</a></p> 
</blockquote> 
<h3>常用工具链</h3> 
<blockquote> 
 <p>8. 自动化测试：<a class="link-info" href="https://course.rs/test/intro.html" rel="nofollow" title="https://course.rs/test/intro.html">https://course.rs/test/intro.html</a><br> 9. Cargo 使用指南：<a class="link-info" href="https://course.rs/cargo/intro.html" rel="nofollow" title="https://course.rs/cargo/intro.html">https://course.rs/cargo/intro.html</a></p> 
</blockquote> 
<h3>开发实践</h3> 
<blockquote> 
 <p>10. 企业落地实践：<a class="link-info" href="https://course.rs/usecases/intro.html" rel="nofollow" title="https://course.rs/usecases/intro.html">https://course.rs/usecases/intro.html</a><br> 11. 日志和监控：<a class="link-info" href="https://course.rs/logs/intro.html" rel="nofollow" title="https://course.rs/logs/intro.html">https://course.rs/logs/intro.html</a><br> 12. Rust 最佳实践：<a class="link-info" href="https://course.rs/practice/intro.html" rel="nofollow" title="https://course.rs/practice/intro.html">https://course.rs/practice/intro.html</a><br> 13. 手把手带你实现链表：<a class="link-info" href="https://course.rs/too-many-lists/intro.html" rel="nofollow" title="https://course.rs/too-many-lists/intro.html">https://course.rs/too-many-lists/intro.html</a></p> 
</blockquote> 
<h3>攻克编译错误</h3> 
<blockquote> 
 <p>14. 征服编译错误：<a class="link-info" href="https://course.rs/compiler/intro.html" rel="nofollow" title="https://course.rs/compiler/intro.html">https://course.rs/compiler/intro.html</a></p> 
</blockquote> 
<h3>性能优化</h3> 
<blockquote> 
 <p>15. Rust 性能优化 todo：<a class="link-info" href="https://course.rs/profiling/intro.html" rel="nofollow" title="https://course.rs/profiling/intro.html">https://course.rs/profiling/intro.html</a></p> 
</blockquote> 
<h3>附录</h3> 
<blockquote> 
 <p>16. Appendix：<a class="link-info" href="https://course.rs/appendix/keywords.html" rel="nofollow" title="https://course.rs/appendix/keywords.html">https://course.rs/appendix/keywords.html</a></p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<h2>5、通过例子学 Rust</h2> 
<p></p> 
<p>英文文档：<a class="link-info" href="https://doc.rust-lang.org/rust-by-example/" rel="nofollow" title="https://doc.rust-lang.org/rust-by-example/">https://doc.rust-lang.org/rust-by-example/</a></p> 
<p>中文文档：<a class="link-info" href="https://rustwiki.org/zh-CN/rust-by-example/" rel="nofollow" title="https://rustwiki.org/zh-CN/rust-by-example/">https://rustwiki.org/zh-CN/rust-by-example/</a></p> 
<p>查看更多 <a href="https://rustwiki.org/" rel="nofollow" title="Rust 官方文档中英文双语教程">Rust 官方文档中英文双语教程</a>，包括双语版<a href="https://rustwiki.org/zh-CN/book/" rel="nofollow" title="《Rust 程序设计语言》">《Rust 程序设计语言》</a>（出版书名为《Rust 权威指南》）， <a href="https://rustwiki.org/zh-CN/std/" rel="nofollow" title="Rust 标准库中文版">Rust 标准库中文版</a>。</p> 
<p>《通过例子学 Rust》(Rust By Example 中文版)翻译自 <a href="https://doc.rust-lang.org/rust-by-example/" rel="nofollow" title="Rust By Example">Rust By Example</a>，中文版最后更新时间：2022-1-26。查看此书的 <a href="https://github.com/rust-lang-cn/rust-by-example-cn" title="Github 翻译项目和源码">Github 翻译项目和源码</a>。</p> 
<p></p> 
<ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/hello.html" rel="nofollow" title="1. Hello World">1. Hello World</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/hello/comment.html" rel="nofollow" title="1.1. 注释">1.1. 注释</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/hello/print.html" rel="nofollow" title="1.2. 格式化输出">1.2. 格式化输出</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/hello/print/print_debug.html" rel="nofollow" title="1.2.1. 调试（debug）">1.2.1. 调试（debug）</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/hello/print/print_display.html" rel="nofollow" title="1.2.2. 显示（display）">1.2.2. 显示（display）</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/hello/print/print_display/testcase_list.html" rel="nofollow" title="1.2.3. 测试实例：List">1.2.3. 测试实例：List</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/hello/print/fmt.html" rel="nofollow" title="1.2.4. 格式化">1.2.4. 格式化</a></li></ol></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/primitives.html" rel="nofollow" title="2. 原生类型">2. 原生类型</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/primitives/literals.html" rel="nofollow" title="2.1. 字面量和运算符">2.1. 字面量和运算符</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/primitives/tuples.html" rel="nofollow" title="2.2. 元组">2.2. 元组</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/primitives/array.html" rel="nofollow" title="2.3. 数组和切片">2.3. 数组和切片</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types.html" rel="nofollow" title="3. 自定义类型">3. 自定义类型</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/structs.html" rel="nofollow" title="3.1. 结构体">3.1. 结构体</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum.html" rel="nofollow" title="3.2. 枚举">3.2. 枚举</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum/enum_use.html" rel="nofollow" title="3.2.1. 使用 use">3.2.1. 使用 use</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum/c_like.html" rel="nofollow" title="3.2.2. C 风格用法">3.2.2. C 风格用法</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum/testcase_linked_list.html" rel="nofollow" title="3.2.3. 测试实例：链表">3.2.3. 测试实例：链表</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/constants.html" rel="nofollow" title="3.3. 常量">3.3. 常量</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/variable_bindings.html" rel="nofollow" title="4. 变量绑定">4. 变量绑定</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/variable_bindings/mut.html" rel="nofollow" title="4.1. 可变变量">4.1. 可变变量</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/variable_bindings/scope.html" rel="nofollow" title="4.2. 作用域和遮蔽">4.2. 作用域和遮蔽</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/variable_bindings/declare.html" rel="nofollow" title="4.3. 变量先声明">4.3. 变量先声明</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/variable_bindings/freeze.html" rel="nofollow" title="4.4. 冻结">4.4. 冻结</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/types.html" rel="nofollow" title="5. 类型系统">5. 类型系统</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/types/cast.html" rel="nofollow" title="5.1. 类型转换">5.1. 类型转换</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/types/literals.html" rel="nofollow" title="5.2. 字面量">5.2. 字面量</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/types/inference.html" rel="nofollow" title="5.3. 类型推断">5.3. 类型推断</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/types/alias.html" rel="nofollow" title="5.4. 别名">5.4. 别名</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/conversion.html" rel="nofollow" title="6. 类型转换">6. 类型转换</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/conversion/from_into.html" rel="nofollow" title="6.1. From 和 Into">6.1. From 和 Into</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/conversion/try_from_try_into.html" rel="nofollow" title="6.2. TryFrom 和 TryInto">6.2. TryFrom 和 TryInto</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/conversion/string.html" rel="nofollow" title="6.3. ToString 和 FromStr">6.3. ToString 和 FromStr</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/expression.html" rel="nofollow" title="7. 表达式">7. 表达式</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control.html" rel="nofollow" title="8. 流程控制">8. 流程控制</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/if_else.html" rel="nofollow" title="8.1. if/else">8.1. if/else</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/loop.html" rel="nofollow" title="8.2. loop 循环">8.2. loop 循环</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/loop/nested.html" rel="nofollow" title="8.2.1. 嵌套循环和标签">8.2.1. 嵌套循环和标签</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/loop/return.html" rel="nofollow" title="8.2.2. 从 loop 循环返回">8.2.2. 从 loop 循环返回</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/while.html" rel="nofollow" title="8.3. while 循环">8.3. while 循环</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/for.html" rel="nofollow" title="8.4. for 循环和区间">8.4. for 循环和区间</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match.html" rel="nofollow" title="8.5. match 匹配">8.5. match 匹配</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/destructuring.html" rel="nofollow" title="8.5.1. 解构">8.5.1. 解构</a></li><li> 
      <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/destructuring/destructure_tuple.html" rel="nofollow" title="8.5.1.1. 元组">8.5.1.1. 元组</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/destructuring/destructure_enum.html" rel="nofollow" title="8.5.1.2. 枚举">8.5.1.2. 枚举</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/destructuring/destructure_pointers.html" rel="nofollow" title="8.5.1.3. 指针和引用">8.5.1.3. 指针和引用</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/destructuring/destructure_structures.html" rel="nofollow" title="8.5.1.4. 结构体">8.5.1.4. 结构体</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/guard.html" rel="nofollow" title="8.5.2. 卫语句">8.5.2. 卫语句</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/match/binding.html" rel="nofollow" title="8.5.3. 绑定">8.5.3. 绑定</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/if_let.html" rel="nofollow" title="8.6. if let">8.6. if let</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/flow_control/while_let.html" rel="nofollow" title="8.7. while let">8.7. while let</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn.html" rel="nofollow" title="9. 函数">9. 函数</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/methods.html" rel="nofollow" title="9.1. 方法">9.1. 方法</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/closures.html" rel="nofollow" title="9.2. 闭包">9.2. 闭包</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/closures/capture.html" rel="nofollow" title="9.2.1. 捕获">9.2.1. 捕获</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/closures/input_parameters.html" rel="nofollow" title="9.2.2. 作为输入参数">9.2.2. 作为输入参数</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/closures/anonymity.html" rel="nofollow" title="9.2.3. 类型匿名">9.2.3. 类型匿名</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/closures/input_functions.html" rel="nofollow" title="9.2.4. 输入函数">9.2.4. 输入函数</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/closures/output_parameters.html" rel="nofollow" title="9.2.5. 作为输出参数">9.2.5. 作为输出参数</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/closures/closure_examples.html" rel="nofollow" title="9.2.6. std 中的例子">9.2.6. std 中的例子</a></li><li> 
      <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/closures/closure_examples/iter_any.html" rel="nofollow" title="9.2.6.1. Iterator::any">9.2.6.1. Iterator::any</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/closures/closure_examples/iter_find.html" rel="nofollow" title="9.2.6.2. Iterator::find">9.2.6.2. Iterator::find</a></li></ol></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/hof.html" rel="nofollow" title="9.3. 高阶函数">9.3. 高阶函数</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/fn/diverging.html" rel="nofollow" title="9.4. 发散函数">9.4. 发散函数</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/mod.html" rel="nofollow" title="10. 模块">10. 模块</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/mod/visibility.html" rel="nofollow" title="10.1. 可见性">10.1. 可见性</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/mod/struct_visibility.html" rel="nofollow" title="10.2. 结构体的可见性">10.2. 结构体的可见性</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/mod/use.html" rel="nofollow" title="10.3. use 声明">10.3. use 声明</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/mod/super.html" rel="nofollow" title="10.4. super 和 self">10.4. super 和 self</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/mod/split.html" rel="nofollow" title="10.5. 文件分层">10.5. 文件分层</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/crates.html" rel="nofollow" title="11. crate">11. crate</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/crates/lib.html" rel="nofollow" title="11.1. 库">11.1. 库</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/crates/using_lib.html" rel="nofollow" title="11.2. 使用库">11.2. 使用库</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/cargo.html" rel="nofollow" title="12. cargo">12. cargo</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/cargo/deps.html" rel="nofollow" title="12.1. 依赖">12.1. 依赖</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/cargo/conventions.html" rel="nofollow" title="12.2. 约定规范">12.2. 约定规范</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/cargo/test.html" rel="nofollow" title="12.3. 测试">12.3. 测试</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/cargo/build_scripts.html" rel="nofollow" title="12.4. 构建脚本">12.4. 构建脚本</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/attribute.html" rel="nofollow" title="13. 属性">13. 属性</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/attribute/unused.html" rel="nofollow" title="13.1. 死代码 dead_code">13.1. 死代码 dead_code</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/attribute/crate.html" rel="nofollow" title="13.2. crate">13.2. crate</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/attribute/cfg.html" rel="nofollow" title="13.3. cfg">13.3. cfg</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/attribute/cfg/custom.html" rel="nofollow" title="13.3.1. 自定义条件">13.3.1. 自定义条件</a></li></ol></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics.html" rel="nofollow" title="14. 泛型">14. 泛型</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/gen_fn.html" rel="nofollow" title="14.1. 函数">14.1. 函数</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/impl.html" rel="nofollow" title="14.2. 实现">14.2. 实现</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/gen_trait.html" rel="nofollow" title="14.3. trait">14.3. trait</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/bounds.html" rel="nofollow" title="14.4. 约束">14.4. 约束</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/bounds/testcase_empty.html" rel="nofollow" title="14.4.1. 测试实例：空约束">14.4.1. 测试实例：空约束</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/multi_bounds.html" rel="nofollow" title="14.5. 多重约束">14.5. 多重约束</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/where.html" rel="nofollow" title="14.6. where 子句">14.6. where 子句</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/new_types.html" rel="nofollow" title="14.7. newtype 惯用法">14.7. newtype 惯用法</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/assoc_items.html" rel="nofollow" title="14.8. 关联项">14.8. 关联项</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/assoc_items/the_problem.html" rel="nofollow" title="14.8.1. 存在问题">14.8.1. 存在问题</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/assoc_items/types.html" rel="nofollow" title="14.8.2. 关联类型">14.8.2. 关联类型</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/phantom.html" rel="nofollow" title="14.9. 虚类型参数">14.9. 虚类型参数</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/generics/phantom/testcase_units.html" rel="nofollow" title="14.9.1. 测试实例：单位检查">14.9.1. 测试实例：单位检查</a></li></ol></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope.html" rel="nofollow" title="15. 作用域规则">15. 作用域规则</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/raii.html" rel="nofollow" title="15.1. RAII">15.1. RAII</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/move.html" rel="nofollow" title="15.2. 所有权和移动">15.2. 所有权和移动</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/move/mut.html" rel="nofollow" title="15.2.1. 可变性">15.2.1. 可变性</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/move/partial_move.html" rel="nofollow" title="15.2.2. 部分移动">15.2.2. 部分移动</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/borrow.html" rel="nofollow" title="15.3. 借用">15.3. 借用</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/borrow/mut.html" rel="nofollow" title="15.3.1. 可变性">15.3.1. 可变性</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/borrow/alias.html" rel="nofollow" title="15.3.2. 别名使用">15.3.2. 别名使用</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/borrow/ref.html" rel="nofollow" title="15.3.3. ref 模式">15.3.3. ref 模式</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime.html" rel="nofollow" title="15.4. 生命周期">15.4. 生命周期</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/explicit.html" rel="nofollow" title="15.4.1. 显式标注">15.4.1. 显式标注</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/fn.html" rel="nofollow" title="15.4.2. 函数">15.4.2. 函数</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/methods.html" rel="nofollow" title="15.4.3. 方法">15.4.3. 方法</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/struct.html" rel="nofollow" title="15.4.4. 结构体">15.4.4. 结构体</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/trait.html" rel="nofollow" title="15.4.5. trait">15.4.5. trait</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/lifetime_bounds.html" rel="nofollow" title="15.4.6. 约束">15.4.6. 约束</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/lifetime_coercion.html" rel="nofollow" title="15.4.7. 强制转换">15.4.7. 强制转换</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/static_lifetime.html" rel="nofollow" title="15.4.8. static">15.4.8. static</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/elision.html" rel="nofollow" title="15.4.9. 省略">15.4.9. 省略</a></li></ol></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/trait.html" rel="nofollow" title="16. 特质 trait">16. 特质 trait</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/trait/derive.html" rel="nofollow" title="16.1. 派生">16.1. 派生</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/trait/dyn.html" rel="nofollow" title="16.2. 使用 dyn 返回 trait">16.2. 使用 dyn 返回 trait</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/trait/ops.html" rel="nofollow" title="16.3. 运算符重载">16.3. 运算符重载</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/trait/drop.html" rel="nofollow" title="16.4. Drop">16.4. Drop</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/trait/iter.html" rel="nofollow" title="16.5. Iterator">16.5. Iterator</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/trait/impl_trait.html" rel="nofollow" title="16.6. impl Trait">16.6. impl Trait</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/trait/clone.html" rel="nofollow" title="16.7. Clone">16.7. Clone</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/trait/supertraits.html" rel="nofollow" title="16.8. 父 trait">16.8. 父 trait</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/trait/disambiguating.html" rel="nofollow" title="16.9. 消除重叠 trait">16.9. 消除重叠 trait</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/macros.html" rel="nofollow" title="17. 使用 macro_rules! 来创建宏">17. 使用 macro_rules! 来创建宏</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/macros/syntax.html" rel="nofollow" title="17.1. 语法">17.1. 语法</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/macros/designators.html" rel="nofollow" title="17.1.1. 指示符">17.1.1. 指示符</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/macros/overload.html" rel="nofollow" title="17.1.2. 重载">17.1.2. 重载</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/macros/repeat.html" rel="nofollow" title="17.1.3. 重复">17.1.3. 重复</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/macros/dry.html" rel="nofollow" title="17.2. DRY (不写重复代码)">17.2. DRY (不写重复代码)</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/macros/dsl.html" rel="nofollow" title="17.3. DSL (领域专用语言)">17.3. DSL (领域专用语言)</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/macros/variadics.html" rel="nofollow" title="17.4. 可变参数接口">17.4. 可变参数接口</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error.html" rel="nofollow" title="18. 错误处理">18. 错误处理</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/panic.html" rel="nofollow" title="18.1. panic">18.1. panic</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/option_unwrap.html" rel="nofollow" title="18.2. Option 和 unwrap">18.2. Option 和 unwrap</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/option_unwrap/question_mark.html" rel="nofollow" title="18.2.1. 使用 ? 解开 Option">18.2.1. 使用 ? 解开 Option</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/option_unwrap/map.html" rel="nofollow" title="18.2.2. 组合算子：map">18.2.2. 组合算子：map</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/option_unwrap/and_then.html" rel="nofollow" title="18.2.3. 组合算子：and_then">18.2.3. 组合算子：and_then</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/result.html" rel="nofollow" title="18.3. 结果 Result">18.3. 结果 Result</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/result/result_map.html" rel="nofollow" title="18.3.1. Result 的 map">18.3.1. Result 的 map</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/result/result_alias.html" rel="nofollow" title="18.3.2. 给 Result 取别名">18.3.2. 给 Result 取别名</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/result/early_returns.html" rel="nofollow" title="18.3.3. 提前返回">18.3.3. 提前返回</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/result/enter_question_mark.html" rel="nofollow" title="18.3.4. 引入 ?">18.3.4. 引入 ?</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/multiple_error_types.html" rel="nofollow" title="18.4. 处理多种错误类型">18.4. 处理多种错误类型</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/multiple_error_types/option_result.html" rel="nofollow" title="18.4.1. 从 Option 中取出 Result">18.4.1. 从 Option 中取出 Result</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/multiple_error_types/define_error_type.html" rel="nofollow" title="18.4.2. 定义一种错误类型">18.4.2. 定义一种错误类型</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/multiple_error_types/boxing_errors.html" rel="nofollow" title="18.4.3. 把错误 “装箱”">18.4.3. 把错误 “装箱”</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/multiple_error_types/reenter_question_mark.html" rel="nofollow" title="18.4.4. ? 的其他用法">18.4.4. ? 的其他用法</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/multiple_error_types/wrap_error.html" rel="nofollow" title="18.4.5. 包裹错误">18.4.5. 包裹错误</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/error/iter_result.html" rel="nofollow" title="18.5. 遍历 Result">18.5. 遍历 Result</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std.html" rel="nofollow" title="19. 标准库类型">19. 标准库类型</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/box.html" rel="nofollow" title="19.1. 箱子、栈和堆">19.1. 箱子、栈和堆</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/vec.html" rel="nofollow" title="19.2. 动态数组 vector">19.2. 动态数组 vector</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/str.html" rel="nofollow" title="19.3. 字符串 String">19.3. 字符串 String</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/option.html" rel="nofollow" title="19.4. 选项 Option">19.4. 选项 Option</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/result.html" rel="nofollow" title="19.5. 结果 Result">19.5. 结果 Result</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/result/question_mark.html" rel="nofollow" title="19.5.1. ? 用法">19.5.1. ? 用法</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/panic.html" rel="nofollow" title="19.6. panic!">19.6. panic!</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/hash.html" rel="nofollow" title="19.7. 散列表 HashMap">19.7. 散列表 HashMap</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/hash/alt_key_types.html" rel="nofollow" title="19.7.1. 更改或自定义关键字类型">19.7.1. 更改或自定义关键字类型</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/hash/hashset.html" rel="nofollow" title="19.7.2. 散列集 HashSet">19.7.2. 散列集 HashSet</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/rc.html" rel="nofollow" title="19.8. 引用计数 Rc">19.8. 引用计数 Rc</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std/arc.html" rel="nofollow" title="19.9. 共享引用计数 Arc">19.9. 共享引用计数 Arc</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc.html" rel="nofollow" title="20. 标准库更多介绍">20. 标准库更多介绍</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/threads.html" rel="nofollow" title="20.1. 线程">20.1. 线程</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/threads/testcase_mapreduce.html" rel="nofollow" title="20.1.1. 测试实例：map-reduce">20.1.1. 测试实例：map-reduce</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/channels.html" rel="nofollow" title="20.2. 通道">20.2. 通道</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/path.html" rel="nofollow" title="20.3. 路径">20.3. 路径</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/file.html" rel="nofollow" title="20.4. 文件输入输出（I/O）">20.4. 文件输入输出（I/O）</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/file/open.html" rel="nofollow" title="20.4.1. 打开文件 open">20.4.1. 打开文件 open</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/file/create.html" rel="nofollow" title="20.4.2. 创建文件 create">20.4.2. 创建文件 create</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/file/read_lines.html" rel="nofollow" title="20.4.3. 读取行 read lines">20.4.3. 读取行 read lines</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/process.html" rel="nofollow" title="20.5. 子进程">20.5. 子进程</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/process/pipe.html" rel="nofollow" title="20.5.1. 管道">20.5.1. 管道</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/process/wait.html" rel="nofollow" title="20.5.2. 等待">20.5.2. 等待</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/fs.html" rel="nofollow" title="20.6. 文件系统操作">20.6. 文件系统操作</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/arg.html" rel="nofollow" title="20.7. 程序参数">20.7. 程序参数</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/arg/matching.html" rel="nofollow" title="20.7.1. 参数解析">20.7.1. 参数解析</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/ffi.html" rel="nofollow" title="20.8. 外部语言函数接口">20.8. 外部语言函数接口</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/testing.html" rel="nofollow" title="21. 测试">21. 测试</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/testing/unit_testing.html" rel="nofollow" title="21.1. 单元测试">21.1. 单元测试</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/testing/doc_testing.html" rel="nofollow" title="21.2. 文档测试">21.2. 文档测试</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/testing/integration_testing.html" rel="nofollow" title="21.3. 集成测试">21.3. 集成测试</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/testing/dev_dependencies.html" rel="nofollow" title="21.4. 开发依赖">21.4. 开发依赖</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/unsafe.html" rel="nofollow" title="22. 不安全操作">22. 不安全操作</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/compatibility.html" rel="nofollow" title="23. 兼容性">23. 兼容性</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/compatibility/raw_identifiers.html" rel="nofollow" title="23.1. 原始标志符">23.1. 原始标志符</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/meta.html" rel="nofollow" title="24. 补充">24. 补充</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/rust-by-example/meta/doc.html" rel="nofollow" title="24.1. 文档">24.1. 文档</a></li><li><a href="https://rustwiki.org/zh-CN/rust-by-example/meta/playpen.html" rel="nofollow" title="24.2. Playpen">24.2. Playpen</a></li></ol></li></ol> 
<p></p> 
<h3>Rust 异步编程 (async/await/Future)</h3> 
<p>Rust学习笔记-异步编程(async/await/Future)：<a class="link-info" href="https://zhuanlan.zhihu.com/p/611587154" rel="nofollow" title="https://zhuanlan.zhihu.com/p/611587154">https://zhuanlan.zhihu.com/p/611587154</a></p> 
<p></p> 
<p></p> 
<h2>6、 Rust 参考手册</h2> 
<p></p> 
<ol><li><a href="https://rustwiki.org/zh-CN/reference/introduction.html" rel="nofollow" title="简介">简介</a></li><li><a href="https://rustwiki.org/zh-CN/reference/notation.html" rel="nofollow" title="1. 表义符">1. 表义符</a></li><li><a href="https://rustwiki.org/zh-CN/reference/lexical-structure.html" rel="nofollow" title="2. 词法结构">2. 词法结构</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/reference/input-format.html" rel="nofollow" title="2.1. 输入格式">2.1. 输入格式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/keywords.html" rel="nofollow" title="2.2. 关键字">2.2. 关键字</a></li><li><a href="https://rustwiki.org/zh-CN/reference/identifiers.html" rel="nofollow" title="2.3. 标识符">2.3. 标识符</a></li><li><a href="https://rustwiki.org/zh-CN/reference/comments.html" rel="nofollow" title="2.4. 注释">2.4. 注释</a></li><li><a href="https://rustwiki.org/zh-CN/reference/whitespace.html" rel="nofollow" title="2.5. 空白符">2.5. 空白符</a></li><li><a href="https://rustwiki.org/zh-CN/reference/tokens.html" rel="nofollow" title="2.6. token">2.6. token</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/reference/macros.html" rel="nofollow" title="3. 宏">3. 宏</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/reference/macros-by-example.html" rel="nofollow" title="3.1. 声明宏">3.1. 声明宏</a></li><li><a href="https://rustwiki.org/zh-CN/reference/procedural-macros.html" rel="nofollow" title="3.2. 过程宏">3.2. 过程宏</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/reference/crates-and-source-files.html" rel="nofollow" title="4. crate 和源文件">4. crate 和源文件</a></li><li><a href="https://rustwiki.org/zh-CN/reference/conditional-compilation.html" rel="nofollow" title="5. 条件编译">5. 条件编译</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items.html" rel="nofollow" title="6. 程序项">6. 程序项</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/reference/items/modules.html" rel="nofollow" title="6.1. 模块">6.1. 模块</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/extern-crates.html" rel="nofollow" title="6.2. 外部crate">6.2. 外部crate</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/use-declarations.html" rel="nofollow" title="6.3. use声明">6.3. use声明</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/functions.html" rel="nofollow" title="6.4. 函数">6.4. 函数</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/type-aliases.html" rel="nofollow" title="6.5. 类型别名">6.5. 类型别名</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/structs.html" rel="nofollow" title="6.6. 结构体">6.6. 结构体</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/enumerations.html" rel="nofollow" title="6.7. 枚举">6.7. 枚举</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/unions.html" rel="nofollow" title="6.8. 联合体">6.8. 联合体</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/constant-items.html" rel="nofollow" title="6.9. 常量项">6.9. 常量项</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/static-items.html" rel="nofollow" title="6.10. 静态项">6.10. 静态项</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/traits.html" rel="nofollow" title="6.11. trait">6.11. trait</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/implementations.html" rel="nofollow" title="6.12. 实现">6.12. 实现</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/external-blocks.html" rel="nofollow" title="6.13. 外部块">6.13. 外部块</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/generics.html" rel="nofollow" title="6.14. 泛型参数">6.14. 泛型参数</a></li><li><a href="https://rustwiki.org/zh-CN/reference/items/associated-items.html" rel="nofollow" title="6.15. 关联程序项">6.15. 关联程序项</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/reference/attributes.html" rel="nofollow" title="7. 属性">7. 属性</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/reference/attributes/testing.html" rel="nofollow" title="7.1. 测试">7.1. 测试</a></li><li><a href="https://rustwiki.org/zh-CN/reference/attributes/derive.html" rel="nofollow" title="7.2. 派生">7.2. 派生</a></li><li><a href="https://rustwiki.org/zh-CN/reference/attributes/diagnostics.html" rel="nofollow" title="7.3. 诊断">7.3. 诊断</a></li><li><a href="https://rustwiki.org/zh-CN/reference/attributes/codegen.html" rel="nofollow" title="7.4. 代码生成">7.4. 代码生成</a></li><li><a href="https://rustwiki.org/zh-CN/reference/attributes/limits.html" rel="nofollow" title="7.5. 极限值设置">7.5. 极限值设置</a></li><li><a href="https://rustwiki.org/zh-CN/reference/attributes/type_system.html" rel="nofollow" title="7.6. 类型系统">7.6. 类型系统</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/reference/statements-and-expressions.html" rel="nofollow" title="8. 语句和表达式">8. 语句和表达式</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/reference/statements.html" rel="nofollow" title="8.1. 语句">8.1. 语句</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions.html" rel="nofollow" title="8.2. 表达式">8.2. 表达式</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/reference/expressions/literal-expr.html" rel="nofollow" title="8.2.1. 字面量表达式">8.2.1. 字面量表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/path-expr.html" rel="nofollow" title="8.2.2. 路径表达式">8.2.2. 路径表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/block-expr.html" rel="nofollow" title="8.2.3. 块表达式">8.2.3. 块表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/operator-expr.html" rel="nofollow" title="8.2.4. 运算符表达式">8.2.4. 运算符表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/grouped-expr.html" rel="nofollow" title="8.2.5. 分组表达式">8.2.5. 分组表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/array-expr.html" rel="nofollow" title="8.2.6. 数组和索引表达式">8.2.6. 数组和索引表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/tuple-expr.html" rel="nofollow" title="8.2.7. 元组和索引表达式">8.2.7. 元组和索引表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/struct-expr.html" rel="nofollow" title="8.2.8. 结构体表达式">8.2.8. 结构体表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/call-expr.html" rel="nofollow" title="8.2.9. 调用表达式">8.2.9. 调用表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/method-call-expr.html" rel="nofollow" title="8.2.10. 方法调用表达式">8.2.10. 方法调用表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/field-expr.html" rel="nofollow" title="8.2.11. 字段访问表达式">8.2.11. 字段访问表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/closure-expr.html" rel="nofollow" title="8.2.12. 闭包表达式">8.2.12. 闭包表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/loop-expr.html" rel="nofollow" title="8.2.13. 循环表达式">8.2.13. 循环表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/range-expr.html" rel="nofollow" title="8.2.14. 区间表达式">8.2.14. 区间表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/if-expr.html" rel="nofollow" title="8.2.15. if 和 if let 表达式">8.2.15. if 和 if let 表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/match-expr.html" rel="nofollow" title="8.2.16. 匹配表达式">8.2.16. 匹配表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/return-expr.html" rel="nofollow" title="8.2.17. 返回表达式">8.2.17. 返回表达式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/expressions/await-expr.html" rel="nofollow" title="8.2.18. 等待(await)表达式">8.2.18. 等待(await)表达式</a></li></ol></li></ol></li><li><a href="https://rustwiki.org/zh-CN/reference/patterns.html" rel="nofollow" title="9. 模式">9. 模式</a></li><li><a href="https://rustwiki.org/zh-CN/reference/type-system.html" rel="nofollow" title="10. 类型系统">10. 类型系统</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/reference/types.html" rel="nofollow" title="10.1. 类型">10.1. 类型</a></li><li> 
    <ol><li><a href="https://rustwiki.org/zh-CN/reference/types/boolean.html" rel="nofollow" title="10.1.1. 布尔型">10.1.1. 布尔型</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/numeric.html" rel="nofollow" title="10.1.2. 数字型">10.1.2. 数字型</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/textual.html" rel="nofollow" title="10.1.3. 字符型">10.1.3. 字符型</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/never.html" rel="nofollow" title="10.1.4. never类型">10.1.4. never类型</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/tuple.html" rel="nofollow" title="10.1.5. 元组">10.1.5. 元组</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/array.html" rel="nofollow" title="10.1.6. 数组">10.1.6. 数组</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/slice.html" rel="nofollow" title="10.1.7. 切片">10.1.7. 切片</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/struct.html" rel="nofollow" title="10.1.8. 结构体">10.1.8. 结构体</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/enum.html" rel="nofollow" title="10.1.9. 枚举">10.1.9. 枚举</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/union.html" rel="nofollow" title="10.1.10. 联合体">10.1.10. 联合体</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/function-item.html" rel="nofollow" title="10.1.11. 函数项类型">10.1.11. 函数项类型</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/closure.html" rel="nofollow" title="10.1.12. 闭包">10.1.12. 闭包</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/pointer.html" rel="nofollow" title="10.1.13. 指针型">10.1.13. 指针型</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/function-pointer.html" rel="nofollow" title="10.1.14. 函数指针">10.1.14. 函数指针</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/trait-object.html" rel="nofollow" title="10.1.15. trait对象">10.1.15. trait对象</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/impl-trait.html" rel="nofollow" title="10.1.16. 实现trait">10.1.16. 实现trait</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/parameters.html" rel="nofollow" title="10.1.17. 类型参数">10.1.17. 类型参数</a></li><li><a href="https://rustwiki.org/zh-CN/reference/types/inferred.html" rel="nofollow" title="10.1.18. 推断型">10.1.18. 推断型</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/reference/dynamically-sized-types.html" rel="nofollow" title="10.2. 动态尺寸类型(DST)">10.2. 动态尺寸类型(DST)</a></li><li><a href="https://rustwiki.org/zh-CN/reference/type-layout.html" rel="nofollow" title="10.3. 类型布局">10.3. 类型布局</a></li><li><a href="https://rustwiki.org/zh-CN/reference/interior-mutability.html" rel="nofollow" title="10.4. 内部可变性">10.4. 内部可变性</a></li><li><a href="https://rustwiki.org/zh-CN/reference/subtyping.html" rel="nofollow" title="10.5. 子类型和型变">10.5. 子类型和型变</a></li><li><a href="https://rustwiki.org/zh-CN/reference/trait-bounds.html" rel="nofollow" title="10.6. trait约束及其生存期约束">10.6. trait约束及其生存期约束</a></li><li><a href="https://rustwiki.org/zh-CN/reference/type-coercions.html" rel="nofollow" title="10.7. 类型自动强转">10.7. 类型自动强转</a></li><li><a href="https://rustwiki.org/zh-CN/reference/destructors.html" rel="nofollow" title="10.8. 析构函数">10.8. 析构函数</a></li><li><a href="https://rustwiki.org/zh-CN/reference/lifetime-elision.html" rel="nofollow" title="10.9. 生存期省略">10.9. 生存期省略</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/reference/special-types-and-traits.html" rel="nofollow" title="11. 特殊类型和 trait">11. 特殊类型和 trait</a></li><li><a href="https://rustwiki.org/zh-CN/reference/names.html" rel="nofollow" title="12. 名称">12. 名称</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/reference/names/namespaces.html" rel="nofollow" title="12.1. 命名空间">12.1. 命名空间</a></li><li><a href="https://rustwiki.org/zh-CN/reference/names/scopes.html" rel="nofollow" title="12.2. 作用域">12.2. 作用域</a></li><li><a href="https://rustwiki.org/zh-CN/reference/names/preludes.html" rel="nofollow" title="12.3. 预导入包">12.3. 预导入包</a></li><li><a href="https://rustwiki.org/zh-CN/reference/paths.html" rel="nofollow" title="12.4. 路径">12.4. 路径</a></li><li><a href="https://rustwiki.org/zh-CN/reference/names/name-resolution.html" rel="nofollow" title="12.5. 名称解析">12.5. 名称解析</a></li><li><a href="https://rustwiki.org/zh-CN/reference/visibility-and-privacy.html" rel="nofollow" title="12.6. 可见性与隐私权">12.6. 可见性与隐私权</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/reference/memory-model.html" rel="nofollow" title="13. 内存模型">13. 内存模型</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/reference/memory-allocation-and-lifetime.html" rel="nofollow" title="13.1. 内存分配和生存期">13.1. 内存分配和生存期</a></li><li><a href="https://rustwiki.org/zh-CN/reference/variables.html" rel="nofollow" title="13.2. 变量">13.2. 变量</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/reference/linkage.html" rel="nofollow" title="14. 链接(linkage)">14. 链接(linkage)</a></li><li><a href="https://rustwiki.org/zh-CN/reference/unsafety.html" rel="nofollow" title="15. 非安全性">15. 非安全性</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/reference/unsafe-functions.html" rel="nofollow" title="15.1. 非安全函数">15.1. 非安全函数</a></li><li><a href="https://rustwiki.org/zh-CN/reference/unsafe-blocks.html" rel="nofollow" title="15.2. 非安全代码块">15.2. 非安全代码块</a></li><li><a href="https://rustwiki.org/zh-CN/reference/behavior-considered-undefined.html" rel="nofollow" title="15.3. 未定义行为">15.3. 未定义行为</a></li><li><a href="https://rustwiki.org/zh-CN/reference/behavior-not-considered-unsafe.html" rel="nofollow" title="15.4. 不被认为是非安全的行为">15.4. 不被认为是非安全的行为</a></li></ol></li><li><a href="https://rustwiki.org/zh-CN/reference/const_eval.html" rel="nofollow" title="16. 常量求值">16. 常量求值</a></li><li><a href="https://rustwiki.org/zh-CN/reference/abi.html" rel="nofollow" title="17. ABI">17. ABI</a></li><li><a href="https://rustwiki.org/zh-CN/reference/runtime.html" rel="nofollow" title="18. Rust运行时">18. Rust运行时</a></li><li><a href="https://rustwiki.org/zh-CN/reference/appendices.html" rel="nofollow" title="19. 附录">19. 附录</a></li><li> 
  <ol><li><a href="https://rustwiki.org/zh-CN/reference/macro-ambiguity.html" rel="nofollow" title="19.1. 宏定义规范">19.1. 宏定义规范</a></li><li><a href="https://rustwiki.org/zh-CN/reference/influences.html" rel="nofollow" title="19.2. 影响来源">19.2. 影响来源</a></li><li><a href="https://rustwiki.org/zh-CN/reference/glossary.html" rel="nofollow" title="19.3. 术语表">19.3. 术语表</a></li></ol></li></ol> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96cc40500ebf320b82319ed84b574e08/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2023年终总结——你相信光吗</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a22c743a7f1ceffeb804b756cc90337c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图书管理系统 毕业设计-附源码97051</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>