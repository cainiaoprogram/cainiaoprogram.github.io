<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s的陈述式资源管理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s的陈述式资源管理" />
<meta property="og:description" content="k8s的陈述式资源管理 命令行
kubectl命令行工具
优点：90%以上的场景都可以满足
对资源的增，删，查比较方便，对改不不太好
缺点：
命令比较冗长，复杂，难记
声明式：
k8s当中的yml文件来实现资源管理---声明式
GUI：图形化工具的管理
1 kubectl命令的详解 查看 部署 产看pod的情况（详细的信息，日志，发布和回滚）
kubectl get cs #查看master节点的状态（基本信息查看）
kubectl get pod #查看默认命名空间的内pod的信息
kubectl get ns #查看当前集群所有的命名空间
kubectl get pod -n kube-system #要查看指定命令空间内的pod需要加-n 命令空间的名称
kubectl get pod -o wide #查看默认命名空间内pod的详细信息
#kubectl get node #查询节点的信息和状态
kubectl get node -o wide #查看node节点的详细信息。
kubectl describe pod &#43;pod的名称 #查看已经部署好的pod的详细信息。
kubectl create ns xxx 创建命名空间
#如果是基于deployment方式创建的pod,或者是daemonset方式创建的pod，是由控制器创建的pod,使用delete删除pod是不删不掉的，相当于重启pod.l
#基于deployment方式创建pod.一旦删除deployment,基于这个deployment创建的pod都会被删除。
不是基于控制器创建，会被直接删除。（比如 run 创建的）
deployment的部署pod:
陈述式部署:命令行
声明式: yaml文件部署" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/db9537039e1b69befc6d5c0c13f418e6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-10T15:03:41+08:00" />
<meta property="article:modified_time" content="2024-01-10T15:03:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s的陈述式资源管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:.0001pt;text-align:justify;">k8s的陈述式资源管理</h2> 
<p style="margin-left:.0001pt;text-align:justify;">命令行</p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl命令行工具</p> 
<p style="margin-left:.0001pt;text-align:justify;">优点：90%以上的场景都可以满足</p> 
<p style="margin-left:.0001pt;text-align:justify;">对资源的增，删，查比较方便，对改不不太好</p> 
<p style="margin-left:.0001pt;text-align:justify;">缺点：</p> 
<p style="margin-left:.0001pt;text-align:justify;">命令比较冗长，复杂，难记</p> 
<p style="margin-left:.0001pt;text-align:justify;">声明式：</p> 
<p style="margin-left:.0001pt;text-align:justify;">k8s当中的yml文件来实现资源管理---声明式</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">GUI：图形化工具的管理</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">1 kubectl命令的详解 查看 部署 产看pod的情况（详细的信息，日志，发布和回滚）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl get cs  #查看master节点的状态（基本信息查看）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl get pod #查看默认命名空间的内pod的信息</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl get ns #查看当前集群所有的命名空间</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl get pod -n kube-system #要查看指定命令空间内的pod需要加-n 命令空间的名称</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl get pod -o wide #查看默认命名空间内pod的详细信息</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">#kubectl get node #查询节点的信息和状态</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl get node -o wide #查看node节点的详细信息。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl describe pod +pod的名称  #查看已经部署好的pod的详细信息。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl create ns xxx  创建命名空间</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">#<span style="color:#ff0000;">如果是基于deployment方式创建的pod,或者是daemonset方式创建的pod，是由控制器创建的pod,使用delete删除pod是不删不掉的，相当于重启pod.l</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">#基于deployment方式创建pod.一旦删除deployment,基于这个deployment创建的pod都会被删除。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">不是基于控制器创建，会被直接删除。（比如 run 创建的）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">deployment的部署pod:</p> 
<p style="margin-left:.0001pt;text-align:justify;">陈述式部署:命令行</p> 
<p style="margin-left:.0001pt;text-align:justify;">声明式: yaml文件部署</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">滚动更新:不是一次性的把所有pod全部部署，而是一个个来。pod的更新时使用，逐步的引入新的pod.逐步的减少日的pod.</p> 
<p style="margin-left:.0001pt;text-align:justify;">自我修复:如果有pod节点发生故障，deployment会自动启动新的pod来进行代替</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">回滚:如果更新有问题,deployment会提供还原点，可以手动还原到未更新前的状态。</p> 
<p style="margin-left:.0001pt;text-align:justify;">扩容和缩容: deployment可以随时调整pod的数量，以适应流量的变化。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">上述的功能必须是基于deployment创建的服务才可以。绝大多岁的POD都是使用deployment创建的。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">daemonset:不能通过命令行创建。只能在yaml文件当中定义这种创建方式。</p> 
<p style="margin-left:.0001pt;text-align:justify;">后台运行创建，在每个节点上都创建一个相同方式的，相同版本的容器运行的pod</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">一般都是依赖环境和重要组件，一般也不会去对</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl exec -it nginx-dn-6d6cd9c7c5-j7ffr bash  #远程进入节点容器。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">docker的exec只能在本机内部使用,不能跨主机，kubectl exec可以跨主机进入容器。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl delete pod nginx-dn-6d6cd9c7c5-j7ffr --force --grace-period=o</p> 
<p style="margin-left:.0001pt;text-align:justify;">快速结束pod的创建（主要是用于结束卡在销毁状态的pod.）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">grace-period:表示过度存活旗，默认是30秒。可以让pod优雅的结束容器内的进程，然后退出pod=0，表示立刻停止pod.必须要force.</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">#对deployment创建的pod进行扩缩容</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">#创建pod时并没有指定副本数，后续也可以对他的副本数进行修改。</p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl scale deployment nginx-dn --replicas=3  <span style="color:#ff0000;">扩容</span>  </p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl scale deployment nginx-dn --replicas=1   <span style="color:#ff0000;">缩容</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">service的类型:</p> 
<p style="margin-left:.0001pt;text-align:justify;">ClusterlP:创建service的默认类型，提供一个集群内部的虚拟ip地址，这是service的默认类型。通过这个虚拟ip可以直接访问pod的资源，无法对外提供访问。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">NodePort:会在每个node节点上都开放一个相同的端口。外部可以通过node的本机ip+端口，防护pod资源。集群外部访问service资源的一种方式。四层代理方式</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">nodeip:nodeport</p> 
<p style="margin-left:.0001pt;text-align:justify;">随机指派，也可以指定30000-32767</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">kubectl expose deployment nginx --port=80 --target-port=80 --name=nginx-service --type=NodePort</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">--port=80service集群的端口</p> 
<p style="margin-left:.0001pt;text-align:justify;">--target-port=80 pod内部容器的端口</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="316" src="https://images2.imgbox.com/94/ca/JiFW4WoQ_o.png" width="831"></p> 
<p style="margin-left:.0001pt;text-align:justify;">LoadBalancer:如果service的类型设定为LoadBalancer，映射地址(云平台提供LoadBalancer的地址)这种用法仅用于公有云服务供应商在云台上设置的service的场景。外部来访问，实现负载均衡。LoadBalancer这个是地址是要付费的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">创建好了service,指定类型为LoadBalancer，会给你提供一个地址来带代理pod内部的ip地址。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">ExternalName: DNS映射，给service分配一个域名，通过域名来访问后端pod资源。ExternalName的service类型，不能提供负载均衡,必须要设置一个LoadBalancer的地址才可以实现。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">更新和回滚以及发布的方式：</p> 
<p style="margin-left:.0001pt;text-align:justify;">项目的生命周期：</p> 
<p style="margin-left:.0001pt;text-align:justify;">创建------发布-----更新-----回滚-----删除</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">更新版本：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="54" src="https://images2.imgbox.com/0d/87/JjKw6Cqe_o.png" width="831"></p> 
<p style="margin-left:.0001pt;text-align:justify;">加标签：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="31" src="https://images2.imgbox.com/ef/65/t0wCoB7G_o.png" width="831"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="145" src="https://images2.imgbox.com/39/47/qJegaEtH_o.png" width="831"></p> 
<p style="margin-left:.0001pt;text-align:justify;">数字的大小决定了距离上次操作的远近，数字越大，就是你最近的一次操作。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="59" src="https://images2.imgbox.com/28/71/Q23NvSDU_o.png" width="831"></p> 
<p style="margin-left:.0001pt;text-align:justify;">回到1 这个还原点</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="43" src="https://images2.imgbox.com/d3/ab/x96dlNI9_o.png" width="694"></p> 
<p style="margin-left:.0001pt;text-align:justify;">查看当前命名空间里的所有信息的详细信息</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;">三种常见的项目发布方式：</h3> 
<h5 style="margin-left:.0001pt;text-align:justify;">蓝绿发布</h5> 
<h5 style="margin-left:.0001pt;text-align:justify;">金丝雀发布（灰度发布）</h5> 
<h5 style="margin-left:.0001pt;text-align:justify;">滚动发布</h5> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">应用程序升级，面临的最大的问题是新旧业务之间的切换。立项………定稿……需求发布…….……开发----测试.……发布，测试之后上线，再完美也会有问题。为了不让发生的问题影响所有用户，上述的三种发布方式。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">蓝绿发布∶把应用服务集群标记为两个组，蓝组和绿组。先升级蓝组，要把蓝组从负载均衡当中移除，绿组继续提供服务。</p> 
<p style="margin-left:.0001pt;text-align:justify;">蓝组升级完毕，在把绿组从负载均衡当中移除，绿组升级，然后都加入回负载均衡当中去，完成对外服务。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">对硬件资源要求很高，但是有了云计算和微服务，现在的成本也大大降低了</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">蓝绿发布的特点：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1、—旦出现问题，问题的影响范围很大</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、发布策略简单</p> 
<p style="margin-left:.0001pt;text-align:justify;">3、基于现在的云计算和微服务，用户无感知。</p> 
<p style="margin-left:.0001pt;text-align:justify;">4、升级和回滚都比较方便。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">缺点：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1  在发布升级的过程之中，只有一部分集群在对外提供服务，可能会是集群的负载能力下降，响应变慢，需要注意给集群增加负载能力()</p> 
<p style="margin-left:.0001pt;text-align:justify;">2   短时间内可能会浪费—定的资源成本。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">金丝雀发布(灰度发布):</p> 
<p style="margin-left:.0001pt;text-align:justify;">deployment控制器创建的服务，才可以使用这种发布方式。滚动更新，暂停。发布的过程中，暂时停止，只有一部分的pod先升级，其他的pod还是处于老的版本。只有一部分用户可以访问新的版本，绝大数用户还是在老版本。确定无问题之后，再把剩下的老版本，升级成新的版本，把暂停取消，继续发布。如果有问题，可以立刻回滚。暂停不是回滚，一旦取消暂停只能全部升级完毕之后，再回滚。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">更新一个pod就暂停：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="50" src="https://images2.imgbox.com/50/0c/6lscq37W_o.png" width="986"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="151" src="https://images2.imgbox.com/b8/82/b5Trpazw_o.png" width="831"></p> 
<p style="margin-left:.0001pt;text-align:justify;">继续更新：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="57" src="https://images2.imgbox.com/98/89/g174OCu3_o.png" width="759"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">灰度发布：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1、自动化的要求比较，对运维人员的要求比较高</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、方便问题，及时解决。影响范围比较小。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3、用户无感知，平滑过度。节约资源。</p> 
<p style="margin-left:.0001pt;text-align:justify;">4、发布策略比较复杂。</p> 
<p style="margin-left:.0001pt;text-align:justify;">5、不易回滚，必须要全部发布成功之后才能回滚。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">滚动更新：</p> 
<p style="margin-left:.0001pt;text-align:justify;">deployment的默认就是滚动更新。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/93b4b17bfba7ac6ff9f70ae3c1e1d154/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于uniapp 组件uniform 得自定义picker 选择器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5fb04fae8730722330068daac3a32ca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">element-plus里el-date-picker日期选择器，默认值不显示的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>