<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VC&#43;&#43;6.0关于分割窗口的CSize初始大小不起作用问题的解释 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VC&#43;&#43;6.0关于分割窗口的CSize初始大小不起作用问题的解释" />
<meta property="og:description" content="首先多谢小虫同学一直关注我的博客，昨日小虫同学按照我的分割窗体的文章举一反三自己写了一段代码，但是运行后发现问题，即，分割后显示的大小和CSize设置的初始大小不一样，那么我们现在来看一下这段代码：
BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) {
// TODO: Add your specialized code here and/or call the base class
//创建一个静态分栏窗口，分为1行2列
CRect rect;
GetClientRect(&amp;rect);
if(wndSplitter_erect.CreateStatic(this,1,2)==NULL) return FALSE;
wndSplitter_erect.CreateView(0,1,RUNTIME_CLASS(CDownView),CSize(rect.Width()-rect.Width()/6,rect.Height()),pContext);
if(wndSplitter_horizontal.CreateStatic(&amp;wndSplitter_erect,2,1,WS_CHILD|WS_VISIBLE, wndSplitter_erect.IdFromRowCol(0, 0))==NULL)
return FALSE;
wndSplitter_horizontal.CreateView(0,0,RUNTIME_CLASS(CUpView),CSize(rect.Width()/6,rect.Height()/3),pContext);
wndSplitter_horizontal.CreateView(1,0,RUNTIME_CLASS(CLeftView),CSize(rect.Width()/6,rect.Height()-rect.Height()/3),pContext);
return TRUE;
//return CFrameWnd::OnCreateClient(lpcs, pContext);
}
我把这段代码运行一遍以后发现，CLeftView占满了整个视图，而CDownView和CUpView则被压缩为一小条。
好了，现在先来分析一下这段代码，首先将视图分割为一行两列，再然后将第一列分为两行一列，原本看似没有什么问题的程序，为什么运行起来就出问题了呢？
这个问题在于，第一次把视图分为一行两列后，我们指定了第二列的宽度，但是我们没有指定第一列的宽度，后来，我们又将第一列分为两行一列了，虽然第二次分割为两个视图CDownView和CUpView指定了宽和高，但是，它的父视图，即第一次分割后的第一列没有指定，系统则自动将大小设为0了。所以，我们看到的CDownView和CUpView被压缩为一小条。
现在我们把问题的原因搞清楚了，那么有什么解决办法呢？现在我们来看两个函数，如下：
1、SetRowInfo函数：
CSplitterWnd::SetRowInfo
void SetRowInfo( int row, int cyIdeal, int cyMin );
参数： row 指定一个分隔器窗口行。 cyIdeal 指定分隔器窗口行的以像素表示的理想高度。 cyMin 指定分隔器窗口行以像素表示的最小高度。
现在我通俗的解释下这三个参数，row：表示要设置哪行的高度。cyldeal：表示你所要设置的理想行高，即显示时的高度。cyMin：表示当用鼠标拖动分隔条的时候，此行的最小高度，通常，我们设置为0即可。
2、SetColumInfo函数：
CSplitterWnd::SetColumnInfo
void SetColumnInfo( int col, int cxIdeal, int cxMin );" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0e5eb90168a4e713c9d48b847862f463/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-12-08T15:40:23+08:00" />
<meta property="article:modified_time" content="2011-12-08T15:40:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VC&#43;&#43;6.0关于分割窗口的CSize初始大小不起作用问题的解释</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4> </h4> 
<table style="width:100%; table-layout:fixed"><tbody><tr><td> 
    <div id="blog_text" class="cnt"> 
     <p>首先多谢小虫同学一直关注我的博客，昨日小虫同学按照我的分割窗体的文章举一反三自己写了一段代码，但是运行后发现问题，即，分割后显示的大小和CSize设置的初始大小不一样，那么我们现在来看一下这段代码：</p> 
     <p><span style="color:#ff0000">BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) <br> {<!-- --><br> // TODO: Add your specialized code here and/or call the base class<br> //创建一个静态分栏窗口，分为1行2列</span></p> 
     <p><span style="color:#ff0000">CRect rect;<br> GetClientRect(&amp;rect);</span></p> 
     <p><span style="color:#ff0000">if(wndSplitter_erect.CreateStatic(this,1,2)==NULL) <br>   <br>    return FALSE;<br> <br> wndSplitter_erect.CreateView(0,1,RUNTIME_CLASS(CDownView),CSize(rect.Width()-rect.Width()/6,rect.Height()),pContext);</span></p> 
     <p><span style="color:#ff0000">if(wndSplitter_horizontal.CreateStatic(&amp;wndSplitter_erect,2,1,WS_CHILD|WS_VISIBLE, wndSplitter_erect.IdFromRowCol(0, 0))==NULL)<br>   <br>    return FALSE;</span></p> 
     <p><span style="color:#ff0000">wndSplitter_horizontal.CreateView(0,0,RUNTIME_CLASS(CUpView),CSize(rect.Width()/6,rect.Height()/3),pContext);</span></p> 
     <p><span style="color:#ff0000">wndSplitter_horizontal.CreateView(1,0,RUNTIME_CLASS(CLeftView),CSize(rect.Width()/6,rect.Height()-rect.Height()/3),pContext);<br> <br>    return TRUE;<br> <br> //return CFrameWnd::OnCreateClient(lpcs, pContext);<br> }</span></p> 
     <p>我把这段代码运行一遍以后发现，CLeftView占满了整个视图，而CDownView和CUpView则被压缩为一小条。</p> 
     <p>好了，现在先来分析一下这段代码，首先将视图分割为一行两列，再然后将第一列分为两行一列，原本看似没有什么问题的程序，为什么运行起来就出问题了呢？</p> 
     <p>这个问题在于，第一次把视图分为一行两列后，我们指定了第二列的宽度，但是我们没有指定第一列的宽度，后来，我们又将第一列分为两行一列了，虽然第二次分割为两个视图CDownView和CUpView指定了宽和高，但是，它的父视图，即第一次分割后的第一列没有指定，系统则自动将大小设为0了。所以，我们看到的CDownView和CUpView被压缩为一小条。</p> 
     <p>现在我们把问题的原因搞清楚了，那么有什么解决办法呢？现在我们来看两个函数，如下：</p> 
     <p>1、SetRowInfo函数：</p> 
     <p>CSplitterWnd::SetRowInfo<br> <br> void SetRowInfo( int row, int cyIdeal, int cyMin );<br> <br> 参数： row 指定一个分隔器窗口行。 <br> cyIdeal 指定分隔器窗口行的以像素表示的理想高度。 <br> cyMin 指定分隔器窗口行以像素表示的最小高度。</p> 
     <p>现在我通俗的解释下这三个参数，row：表示要设置哪行的高度。cyldeal：表示你所要设置的理想行高，即显示时的高度。cyMin：表示当用鼠标拖动分隔条的时候，此行的最小高度，通常，我们设置为0即可。</p> 
     <p>2、SetColumInfo函数：</p> 
     <p>CSplitterWnd::SetColumnInfo<br> <br> void SetColumnInfo( int col, int cxIdeal, int cxMin );<br> <br> 参数： col 指定一个分隔器窗口列。 <br> cxIdeal 指定分隔器窗口列的以像素表示的理想宽度。 <br> cxMin 指定分隔器窗口列以像素表示的最小宽度。</p> 
     <p>现在我通俗的解释下这三个参数，col：表示要设置哪列的宽度。cxldeal：表示你所要设置的理想列宽，即显示时的宽度。cxMin：表示当用鼠标拖动分割条的时候，此列的最小宽度，通常，我们设置为0即可。</p> 
     <p>好了，我们要想解决问题，就要用到这两个函数，下面是我修改过的代码：</p> 
     <p><span style="color:#ff0000">BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) <br> {<!-- --><br> // TODO: Add your specialized code here and/or call the base class<br> //创建一个静态分栏窗口，分为1行2列</span></p> 
     <p><span style="color:#ff0000">CRect rect;<br> GetClientRect(&amp;rect);</span></p> 
     <p><span style="color:#ff0000">if(wndSplitter_erect1.CreateStatic(this,1,2)==NULL) <br>   <br>    return FALSE;<br> <br> wndSplitter_erect1.CreateView(0,1,RUNTIME_CLASS(CMsmonitorDownView),CSize(rect.Width()-rect.Width()/6,rect.Height()),pContext);</span></p> 
     <p><span style="color:#ff0000">if(wndSplitter_horizontal1.CreateStatic(&amp;wndSplitter_erect1,2,1,WS_CHILD|WS_VISIBLE, wndSplitter_erect1.IdFromRowCol(0, 0))==NULL)<br>   <br>    return FALSE;</span></p> 
     <p><span style="color:#ff0000">wndSplitter_horizontal1.CreateView(0,0,RUNTIME_CLASS(CMsmonitorUpView),CSize(rect.Width()/6,rect.Height()/3),pContext);</span></p> 
     <p><span style="color:#ff0000">wndSplitter_horizontal1.CreateView(1,0,RUNTIME_CLASS(CMsmonitorTreeView),CSize(rect.Width()/6,rect.Height()-rect.Height()/3),pContext);<br> <br> wndSplitter_erect1.SetColumnInfo(0,rect.Width()/6,0);//设置第一次分割时第0列的列宽</span></p> 
     <p><span style="color:#ff0000">return TRUE;<br> <br> //return CFrameWnd::OnCreateClient(lpcs, pContext);<br> }</span></p> 
     <p>在我修改的代码中加入了一句，wndSplitter_erect1.SetColumnInfo(0,rect.Width()/6,0);设置第一次分割时第0列的列宽。</p> 
     <p>这个问题解决了，最后我们总结一下：</p> 
     <p>1、在分割的时候注意各个视图的大小，对没有指定宽高的视图再次分割一定要注意为这个视图初始化宽高，用SetColumnInfo和SetRowInfo函数。</p> 
     <p>2、对于没有初始化的视图，系统会自动初始化宽高为0。</p> 
    </div> </td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d59c73708720ba71ed3f3966f7db3ae5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android工程师不得不看的建议</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/95db80448747d4e86549d4d19ab37cb0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决缺少streams.h的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>