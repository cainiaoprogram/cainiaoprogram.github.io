<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spring aop运行时执行栈分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spring aop运行时执行栈分析" />
<meta property="og:description" content="问题： 1.spring aop的切面方法是怎样被添加的？
2.spring aop的切面方法是怎样被执行的？
spring aop的切面方法是怎样被添加的？ 首先定义3个MethodInterceptor Advisor :
ExposeInvocationInterceptor【spring默认添加的，why?】ScfMethodLogger【通过继承StaticMethodMatcherPointcutAdvisor】AspectJAroundAdvice【aspectJAdviceMethod是LoggerAspect】 spring启动时，首先会最大努力寻找所有的bean定义，包括上面的Advisor定义。然后spring容器对bd进行实例化和初始化，初始化后，容器会执行代理proxy配置，此时就会把上面的advisor添加到执行chain里。
代码的参考位置：
org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator#shouldSkip org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean spring aop的切面方法是怎样被执行的？ 调用栈如下：
org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor#intercept org.springframework.aop.framework.DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice org.springframework.aop.framework.CglibAopProxy.CglibMethodInvocation(this$123)#proceed org.aopalliance.intercept.MethodInterceptor#invoke(this$123)【MethodInterceptor:ExposeInvocationInterceptor】 org.springframework.aop.framework.CglibAopProxy.CglibMethodInvocation(this$123)#proceed org.aopalliance.intercept.MethodInterceptor#invoke(this$123)【MethodInterceptor:ScfMethodLogger】 org.springframework.aop.framework.CglibAopProxy.CglibMethodInvocation(this$123)#lllll org.aopalliance.intercept.MethodInterceptor#invoke(this$123)【MethodInterceptor:AspectJAroundAdvice】 org.springframework.aop.aspectj.AspectJAroundAdvice#lazyGetProceedingJoinPoint【封装this$123为ProceedingJoinPoint，即MethodInvocationProceedingJoinPoint$10986】 org.springframework.aop.aspectj.AbstractAspectJAdvice#invokeAdviceMethod(org.aspectj.lang.JoinPoint, org.aspectj.weaver.tools.JoinPointMatch, java.lang.Object, java.lang.Throwable) org.springframework.aop.aspectj.AbstractAspectJAdvice#argBinding org.springframework.aop.aspectj.AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs java.lang.reflect.Method#invoke【this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);】 com.zhuanzhuan.hunter.zeus.po.aspect.LoggerAspect#doAround【参数是MethodInvocationProceedingJoinPoint$10986】 org.aspectj.lang.ProceedingJoinPoint#proceed()【ProceedingJoinPoint：MethodInvocationProceedingJoinPoint$10986】 this.methodInvocation.invocableClone()【this.methodInvocation=this$123,return CglibMethodInvocation$14252】 CglibMethodInvocation$14252.proceed org.springframework.aop.framework.ReflectiveMethodInvocation#invokeJoinpoint org.springframework.aop.support.AopUtils#invokeJoinpointUsingReflection real method 为什么要invocableClone？
public abstract org.aopalliance.intercept.MethodInvocation invocableClone() Create a clone of this object. If cloning is done before proceed() is invoked on this object, proceed() can be invoked once per clone to invoke the joinpoint (and the rest of the advice chain) more than once." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ef1e751aa778fa0b9db3525f33b254e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-15T14:31:40+08:00" />
<meta property="article:modified_time" content="2020-08-15T14:31:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spring aop运行时执行栈分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>问题：</h3> 
<p>1.spring aop的切面方法是怎样被添加的？</p> 
<p>2.spring aop的切面方法是怎样被执行的？</p> 
<p> </p> 
<h4>spring aop的切面方法是怎样被添加的？</h4> 
<p>首先定义3个MethodInterceptor Advisor :</p> 
<ul><li>ExposeInvocationInterceptor【spring默认添加的，why?】</li><li>ScfMethodLogger【通过继承StaticMethodMatcherPointcutAdvisor】</li><li>AspectJAroundAdvice【aspectJAdviceMethod是LoggerAspect】</li></ul> 
<p>spring启动时，首先会最大努力寻找所有的bean定义，包括上面的Advisor定义。然后spring容器对bd进行实例化和初始化，初始化后，容器会执行代理proxy配置，此时就会把上面的advisor添加到执行chain里。</p> 
<p>代码的参考位置：</p> 
<pre><code>org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator#shouldSkip
	org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans
org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code></pre> 
<h4>spring aop的切面方法是怎样被执行的？</h4> 
<p>调用栈如下：</p> 
<pre><code class="language-java">org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor#intercept
	org.springframework.aop.framework.DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice
	org.springframework.aop.framework.CglibAopProxy.CglibMethodInvocation(this$123)#proceed
		org.aopalliance.intercept.MethodInterceptor#invoke(this$123)【MethodInterceptor:ExposeInvocationInterceptor】
			org.springframework.aop.framework.CglibAopProxy.CglibMethodInvocation(this$123)#proceed
				org.aopalliance.intercept.MethodInterceptor#invoke(this$123)【MethodInterceptor:ScfMethodLogger】
					org.springframework.aop.framework.CglibAopProxy.CglibMethodInvocation(this$123)#lllll
						org.aopalliance.intercept.MethodInterceptor#invoke(this$123)【MethodInterceptor:AspectJAroundAdvice】
							org.springframework.aop.aspectj.AspectJAroundAdvice#lazyGetProceedingJoinPoint【封装this$123为ProceedingJoinPoint，即MethodInvocationProceedingJoinPoint$10986】
							org.springframework.aop.aspectj.AbstractAspectJAdvice#invokeAdviceMethod(org.aspectj.lang.JoinPoint, org.aspectj.weaver.tools.JoinPointMatch, java.lang.Object, java.lang.Throwable)
								org.springframework.aop.aspectj.AbstractAspectJAdvice#argBinding
								org.springframework.aop.aspectj.AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs
									java.lang.reflect.Method#invoke【this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);】
										com.zhuanzhuan.hunter.zeus.po.aspect.LoggerAspect#doAround【参数是MethodInvocationProceedingJoinPoint$10986】
											org.aspectj.lang.ProceedingJoinPoint#proceed()【ProceedingJoinPoint：MethodInvocationProceedingJoinPoint$10986】
												this.methodInvocation.invocableClone()【this.methodInvocation=this$123,return CglibMethodInvocation$14252】
												CglibMethodInvocation$14252.proceed
													org.springframework.aop.framework.ReflectiveMethodInvocation#invokeJoinpoint
														org.springframework.aop.support.AopUtils#invokeJoinpointUsingReflection
															real method
</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b0/d3/a6zi2CSw_o.png"></p> 
<p>为什么要invocableClone？</p> 
<pre><code>public abstract org.aopalliance.intercept.MethodInvocation invocableClone()

Create a clone of this object. If cloning is done before proceed() is invoked on this object, proceed() can be invoked once per clone to invoke the joinpoint (and the rest of the advice chain) more than once.

Returns:
an invocable clone of this invocation. proceed() can be called once per clone.    </code></pre> 
<p>其中一个效果就是，被clone的MethodInvocation对象可以再执行一次proceed，就可以实现多次调用joinpoint。</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65d467440813768ad3c2e8c9e3b83fb8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">彻底清除RecycleView，防止复用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/787b3903753f2329f0d515a9c8748194/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows10 关闭指定端口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>