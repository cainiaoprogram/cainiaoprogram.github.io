<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>BlockingQueue（阻塞队列）详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="BlockingQueue（阻塞队列）详解" />
<meta property="og:description" content="这文章写得很详细，忍不住转过来,原文地址：
BlockingQueue（阻塞队列）详解_codingXT的博客-CSDN博客
一. 前言 在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。
二. 认识BlockingQueue 阻塞队列，顾名思义，首先它是一个队列，而一个队列在数据结构中所起的作用大致如下图所示：
从上图我们可以很清楚看到，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出。
常用的队列主要有以下两种：（当然通过不同的实现方式，还可以延伸出很多不同类型的队列，DelayQueue就是其中的一种）。
先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性。后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。 多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的concurrent包横空出世了，而它也给我们带来了强大的BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒），下面两幅图演示了BlockingQueue的两个常见阻塞场景：
如上图所示：当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。
如上图所示：当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。
这也是我们在多线程环境下，为什么需要BlockingQueue的原因。作为BlockingQueue的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。既然BlockingQueue如此神通广大，让我们一起来见识下它的常用方法。
三. BlockingQueue的核心方法 1.放入数据 offer(E e)：表示如果可能的话，将e加到BlockingQueue里，即如果BlockingQueue可以容纳，则返回true，否则返回false（本方法不阻塞当前执行方法的线程）。offer(E e, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入e，则返回失败。put(E e)：把e加到BlockingQueue里，如果BlockQueue没有空间，则调用此方法的线程被阻塞，直到BlockingQueue里面有空间再继续。add(E e): 如果可以在不违反容量限制的情况下立即将指定元素插入此队列，则在成功时返回true ，如果当前没有可用空间则IllegalStateException 。 当使用容量受限的队列时，通常最好使用offer 2.获取数据 poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则时间超时还没有数据可取，返回失败。take()：取走BlockingQueue里排在首位的对象，若BlockingQueue为空，阻塞进入等待状态直到BlockingQueue有新的数据被加入。drainTo(Collection&lt;? super E&gt; c)：一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数drainTo(Collection&lt;? super E&gt; c, int maxElements)），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。 3.删除数据 remove(Object o):从此队列中移除指定元素的单个实例（如果存在）。则返回true 。 无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。
可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。
四. 常见BlockingQueue 在了解了BlockingQueue的基本功能后，让我们来看看BlockingQueue家庭大致有哪些成员？
1. ArrayBlockingQueue 基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。
ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e6baf6add3de495f15795f244441bbeb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-24T10:21:48+08:00" />
<meta property="article:modified_time" content="2023-11-24T10:21:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">BlockingQueue（阻塞队列）详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h6></h6> 
<p>这文章写得很详细，忍不住转过来,原文地址：</p> 
<p><a href="https://blog.csdn.net/qq_37774171/article/details/122742494" title="BlockingQueue（阻塞队列）详解_codingXT的博客-CSDN博客">BlockingQueue（阻塞队列）详解_codingXT的博客-CSDN博客</a></p> 
<p></p> 
<h4>一. 前言</h4> 
<p>在新增的Concurrent包中，<span style="color:#fe2c24;">BlockingQueue</span>很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。</p> 
<h4>二. 认识BlockingQueue</h4> 
<p>阻塞队列，顾名思义，首先它是一个队列，而一个队列在数据结构中所起的作用大致如下图所示：<br><img alt="" height="216" src="https://images2.imgbox.com/7d/5d/3XYDcmAW_o.png" width="213"></p> 
<p></p> 
<p>从上图我们可以很清楚看到，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出。</p> 
<p>常用的队列主要有以下两种：（当然通过不同的实现方式，还可以延伸出很多不同类型的队列，DelayQueue就是其中的一种）。</p> 
<ul><li>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性。</li><li>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。</li></ul> 
<p>多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的concurrent包横空出世了，而它也给我们带来了强大的BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒），下面两幅图演示了BlockingQueue的两个常见阻塞场景：</p> 
<p><img alt="" height="164" src="https://images2.imgbox.com/72/a5/a8UZuGhv_o.png" width="169"></p> 
<p></p> 
<p> 如上图所示：当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</p> 
<p> <img alt="" height="163" src="https://images2.imgbox.com/34/61/dKMjDYPI_o.png" width="236"></p> 
<p></p> 
<p>如上图所示：当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。</p> 
<p>这也是我们在多线程环境下，为什么需要BlockingQueue的原因。作为BlockingQueue的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。既然BlockingQueue如此神通广大，让我们一起来见识下它的常用方法。</p> 
<h4>三. BlockingQueue的核心方法</h4> 
<h5><br> 1.放入数据</h5> 
<ul><li>offer(E e)：表示如果可能的话，将e加到BlockingQueue里，即如果BlockingQueue可以容纳，则返回true，否则返回false（本方法不阻塞当前执行方法的线程）。</li><li>offer(E e, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入e，则返回失败。</li><li>put(E e)：把e加到BlockingQueue里，如果BlockQueue没有空间，则调用此方法的线程被阻塞，直到BlockingQueue里面有空间再继续。</li><li>add(E e): 如果可以在不违反容量限制的情况下立即将指定元素插入此队列，则在成功时返回true ，如果当前没有可用空间则IllegalStateException 。 当使用容量受限的队列时，通常最好使用offer</li></ul> 
<h5>2.获取数据</h5> 
<p></p> 
<ul><li>poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则时间超时还没有数据可取，返回失败。</li><li>take()：取走BlockingQueue里排在首位的对象，若BlockingQueue为空，阻塞进入等待状态直到BlockingQueue有新的数据被加入。</li><li>drainTo(Collection&lt;? super E&gt; c)：一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数drainTo(Collection&lt;? super E&gt; c, int maxElements)），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</li></ul> 
<h5>3.删除数据</h5> 
<ul><li>remove(Object o):从此队列中移除指定元素的单个实例（如果存在）。则返回true 。</li></ul> 
<p>无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。<br> 可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。</p> 
<h4>四. 常见BlockingQueue</h4> 
<p>在了解了BlockingQueue的基本功能后，让我们来看看BlockingQueue家庭大致有哪些成员？<br><img alt="" height="182" src="https://images2.imgbox.com/81/db/ZDKgPxiB_o.png" width="826"></p> 
<h5>1. ArrayBlockingQueue</h5> 
<p>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p> 
<p>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p> 
<p><br><strong>ArrayBlockingQueue的重要字段有如下几个：</strong></p> 
<pre><code class="hljs">/** The queued items */
final Object[] items;

/** items index for next take, poll, peek or remove */
int takeIndex;

/** items index for next put, offer, or add */
int putIndex;

/** Number of elements in the queue */
int count;

/** Main lock guarding all access */
final ReentrantLock lock;

/** Condition for waiting takes */
private final Condition notEmpty;

/** Condition for waiting puts */
private final Condition notFull;
</code></pre> 
<p><strong>put(E e)方法</strong></p> 
<p>put(E e)方法在队列不满的情况下，将会将元素添加到队列尾部，如果队列已满，将会阻塞，直到队列中有剩余空间可以插入。该方法的实现如下：</p> 
<pre><code class="hljs">public void put(E e) throws InterruptedException {

   //检查元素是否为null，如果是，抛出NullPointerException       
   checkNotNull(e);
   final ReentrantLock lock = this.lock;

   //加锁       
   lock.lockInterruptibly();
   try {
       //如果队列已满，阻塞，等待队列成为不满状态           
       while (count == items.length)
           notFull.await();
       //将元素入队           
       enqueue(e);
   } finally {
       lock.unlock();
   }
}
</code></pre> 
<p><strong>put方法总结:</strong></p> 
<ol><li>ArrayBlockingQueue不允许元素为null</li><li>ArrayBlockingQueue在队列已满时将会调用notFull的await()方法释放锁并处于阻塞状态</li><li>一旦ArrayBlockingQueue不为满的状态，就将元素入队</li></ol> 
<p> <strong>E take()方法</strong></p> 
<p>take()方法用于取走队头的元素，当队列为空时将会阻塞，直到队列中有元素可取走时将会被释放。其实现如下：</p> 
<pre><code class="hljs">public E take() throws InterruptedException {

    final ReentrantLock lock = this.lock;
    //首先加锁       
    lock.lockInterruptibly();

    try {
        //如果队列为空，阻塞           
        while (count == 0)
            notEmpty.await();
        //队列不为空，调用dequeue()出队           
        return dequeue();
    } finally {
        //释放锁           
        lock.unlock();
    }
}</code></pre> 
<p><strong>take方法总结:</strong></p> 
<p>一旦获得了锁之后，如果队列为空，那么将阻塞；否则调用dequeue()出队一个元素。</p> 
<p><strong>ArrayBlockingQueue总结：</strong></p> 
<p>ArrayBlockingQueue的并发阻塞是通过ReentrantLock和Condition来实现的，ArrayBlockingQueue内部只有一把锁，意味着同一时刻只有一个线程能进行入队或者出队的操作。</p> 
<h5>2.LinkedBlockingQueue</h5> 
<p>基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者线程，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。为了维持线程安全，LinkedBlockingQueue使用一个AtomicInterger类型的变量表示当前队列中含有的元素个数，所以可以确保两个线程之间操作底层队列是线程安全的。</p> 
<p>作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p> 
<p>ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</p> 
<p>下面的代码演示了如何使用BlockingQueue：</p> 
<p>(1) 测试类</p> 
<pre><code class="hljs">import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue; 

public class BlockingQueueTest {
 
    public static void main(String[] args) throws InterruptedException {
        // 声明一个容量为10的缓存队列
        BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;String&gt;(10);
 
        //new了三个生产者和一个消费者
        Producer producer1 = new Producer(queue);
        Producer producer2 = new Producer(queue);
        Producer producer3 = new Producer(queue);
        Consumer consumer = new Consumer(queue);
 
        // 借助Executors
        ExecutorService service = Executors.newCachedThreadPool();
        // 启动线程
        service.execute(producer1);
        service.execute(producer2);
        service.execute(producer3);
        service.execute(consumer);
 
        // 执行10s
        Thread.sleep(10 * 1000);
        producer1.stop();
        producer2.stop();
        producer3.stop();
 
        Thread.sleep(2000);
        // 退出Executor
        service.shutdown();
    }
}</code></pre> 
<p>（2）生产者类：</p> 
<pre><code class="hljs">import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
 
/**
 * 生产者线程
 * 
 * @author jackyuj
 */
public class Producer implements Runnable {
    
    private volatile boolean  isRunning = true;//是否在运行标志
    private BlockingQueue queue;//阻塞队列
    private static AtomicInteger count = new AtomicInteger();//自动更新的值
    private static final int DEFAULT_RANGE_FOR_SLEEP = 1000;
 
    //构造函数
    public Producer(BlockingQueue queue) {
        this.queue = queue;
    }
 
    public void run() {
        String data = null;
        Random r = new Random();
 
        System.out.println("启动生产者线程！");
        try {
            while (isRunning) {
                System.out.println("正在生产数据...");
                Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));//取0~DEFAULT_RANGE_FOR_SLEEP值的一个随机数
 
                data = "data:" + count.incrementAndGet();//以原子方式将count当前值加1
                System.out.println("将数据：" + data + "放入队列...");
                if (!queue.offer(data, 2, TimeUnit.SECONDS)) {//设定的等待时间为2s，如果超过2s还没加进去返回false
                    System.out.println("放入数据失败：" + data);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        } finally {
            System.out.println("退出生产者线程！");
        }
    }
 
    public void stop() {
        isRunning = false;
    }
}</code></pre> 
<p>（3）消费者类：</p> 
<pre><code class="hljs">import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
 
/**
 * 消费者线程
 * 
 * @author jackyuj
 */
public class Consumer implements Runnable {
    
    private BlockingQueue&lt;String&gt; queue;
    private static final int DEFAULT_RANGE_FOR_SLEEP = 1000;
 
    //构造函数
    public Consumer(BlockingQueue&lt;String&gt; queue) {
        this.queue = queue;
    }
 
    public void run() {
        System.out.println("启动消费者线程！");
        Random r = new Random();
        boolean isRunning = true;
        try {
            while (isRunning) {
                System.out.println("正从队列获取数据...");
                String data = queue.poll(2, TimeUnit.SECONDS);//有数据时直接从队列的队首取走，无数据时阻塞，在2s内有数据，取走，超过2s还没数据，返回失败
                if (null != data) {
                    System.out.println("拿到数据：" + data);
                    System.out.println("正在消费数据：" + data);
                    Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));
                } else {
                    // 超过2s还没数据，认为所有生产线程都已经退出，自动退出消费线程。
                    isRunning = false;
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        } finally {
            System.out.println("退出消费者线程！");
        }
    }
}
</code></pre> 
<h6>LinkedBlockingQueue源码分析</h6> 
<p>LinkedBlockingQueue可以指定容量，内部维持一个队列，所以有一个头节点head和一个尾节点last，内部维持两把锁，一个用于入队，一个用于出队，还有锁关联的Condition对象。主要对象的定义如下：</p> 
<pre><code class="hljs">//容量，如果没有指定，该值为Integer.MAX_VALUE;
private final int capacity;

//当前队列中的元素
private final AtomicInteger count =new AtomicInteger();

//队列头节点，始终满足head.item==null
transient Node head;

//队列的尾节点，始终满足last.next==null
private transient Node last;

//用于出队的锁
private final ReentrantLock takeLock =new ReentrantLock();

//当队列为空时，保存执行出队的线程
private final Condition notEmpty = takeLock.newCondition();

//用于入队的锁
private final ReentrantLock putLock =new ReentrantLock();

//当队列满时，保存执行入队的线程
private final Condition notFull = putLock.newCondition();
</code></pre> 
<p><strong>put(E e)方法</strong></p> 
<p>put(E e)方法用于将一个元素插入到队列的尾部，其实现如下：</p> 
<pre><code class="hljs">public void put(E e)throws InterruptedException {
	//不允许元素为null
    if (e ==null)
		throw new NullPointerException();
		
    int c = -1;
    //以当前元素新建一个节点
    Node node =new Node(e);
    final ReentrantLock putLock =this.putLock;
    final AtomicInteger count =this.count;

    //获得入队的锁
    putLock.lockInterruptibly();
    try {
       //如果队列已满，那么将该线程加入到Condition的等待队列中
        while (count.get() == capacity) {
             notFull.await();
        }
       //将节点入队
        enqueue(node);
        //得到插入之前队列的元素个数
        c = count.getAndIncrement();
        //如果还可以插入元素，那么释放等待的入队线程
        if (c +1 &lt; capacity){
              notFull.signal();
        }
	}finally {
        //解锁
        putLock.unlock();
    }
//通知出队线程队列非空
    if (c ==0)
		signalNotEmpty();
}
</code></pre> 
<p><strong>put方法总结：</strong></p> 
<ol><li>LinkedBlockingQueue不允许元素为null。</li><li>同一时刻，只能有一个线程执行入队操作，因为putLock在将元素插入到队列尾部时加锁了</li><li>如果队列满了，那么将会调用notFull的await()方法将该线程加入到Condition等待队列中。await()方法就会释放线程占有的锁，这将导致之前由于被锁阻塞的入队线程将会获取到锁，执行到while循环处，不过可能因为由于队列仍旧是满的，也被加入到条件队列中。</li><li>一旦一个出队线程取走了一个元素，并通知了入队等待队列中可以释放线程了，那么第一个加入到Condition队列中的将会被释放，那么该线程将会重新获得put锁，继而执行enqueue()方法，将节点插入到队列的尾部</li><li>然后得到插入一个节点之前的元素个数，如果队列中还有空间可以插入，那么就通知notFull条件的等待队列中的线程。</li><li>通知出队线程队列为空了，因为插入一个元素之前的个数为0，而插入一个之后队列中的元素就从无变成了有，就可以通知因队列为空而阻塞的出队线程了。<br>  </li></ol> 
<p><strong>E take()方法</strong></p> 
<p>take()方法用于得到队头的元素，在队列为空时会阻塞，知道队列中有元素可取。其实现如下：</p> 
<pre><code class="hljs">public E take() throws InterruptedException {
    E x;
    int c = -1;
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    //获取takeLock锁       
    takeLock.lockInterruptibly();
    try {
        //如果队列为空，那么加入到notEmpty条件的等待队列中           
        while (count.get() == 0) {
            notEmpty.await();
        }
        //得到队头元素           
        x = dequeue();
        //得到取走一个元素之前队列的元素个数           
        c = count.getAndDecrement();
        //如果队列中还有数据可取，释放notEmpty条件等待队列中的第一个线程           
        if (c &gt; 1)
			notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
    //如果队列中的元素从满到非满，通知put线程       
       if (c == capacity)
        	signalNotFull();
    return x;
}</code></pre> 
<p><strong>take方法总结:</strong></p> 
<p>当队列为空时，就加入到notEmpty(的条件等待队列中，当队列不为空时就取走一个元素，当取完发现还有元素可取时，再通知一下自己的伙伴（等待在条件队列中的线程）；最后，如果队列从满到非满，通知一下put线程。</p> 
<p><strong>remove()方法</strong></p> 
<p>remove()方法用于删除队列中一个元素，如果队列中不含有该元素，那么返回false；有的话则删除并返回true。入队和出队都是只获取一个锁，而remove()方法需要同时获得两把锁，其实现如下： </p> 
<pre><code class="hljs">public boolean remove(Object o) {
        //因为队列不包含null元素，返回false     
        if (o == null) return false;
        //获取两把锁        
        fullyLock();
        try {
            //从头的下一个节点开始遍历           
            for (Node trail = head, p = trail.next;
                p != null;
                trail = p, p = p.next) {
                //如果匹配，那么将节点从队列中移除，trail表示前驱节点               
               if (o.equals(p.item)) {
                    unlink(p, trail);
                    return true;
                }
            }
            return false;
        } finally {
            //释放两把锁         
            fullyUnlock();
        }
}</code></pre> 
<p> 获取两把锁</p> 
<pre><code class="hljs">void fullyLock() {
     putLock.lock();
     takeLock.lock();
}
</code></pre> 
<p> <strong>为什么remove()方法同时需要两把锁?</strong></p> 
<p><strong>LinkedBlockingQueue总结:</strong></p> 
<p>LinkedBlockingQueue是允许两个线程同时在两端进行入队或出队的操作的，但一端同时只能有一个线程进行操作，这是通过两把锁来区分的；</p> 
<p>为了维持底部数据的统一，引入了AtomicInteger的一个count变量，表示队列中元素的个数。count只能在两个地方变化，一个是入队的方法（可以+1），另一个是出队的方法（可以-1），而AtomicInteger是原子安全的，所以也就确保了底层队列的数据同步。</p> 
<h6>ArrayBlockingQueue和LinkedBlockingQueue的对比：</h6> 
<p><strong>ArrayBlockingQueue：</strong><br></p> 
<p>一个对象数组+一把锁+两个条件<br> 入队与出队都用同一把锁<br> 在只有入队高并发或出队高并发的情况下，因为操作数组，且不需要扩容，性能很高<br> 采用了数组，必须指定大小，即容量有限</p> 
<p> <strong>LinkedBlockingQueue：</strong></p> 
<p> 一个单向链表+两把锁+两个条件<br> 两把锁，一把用于入队，一把用于出队，有效的避免了入队与出队时使用一把锁带来的竞争。<br> 在入队与出队都高并发的情况下，性能比ArrayBlockingQueue高很多<br> 采用了链表，最大容量为整数最大值，可看做容量无限</p> 
<h4> 3. DelayQueue</h4> 
<p> DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br> DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口<br>  </p> 
<pre><code class="hljs">public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt; 
</code></pre> 
<p> java.util.concurrent.Delayed 接口</p> 
<pre><code class="hljs">public interface Delayed extends Comparable&lt;Delayed&gt; {

    /**
     * Returns the remaining delay associated with this object, in the
     * given time unit.
     *
     * @param unit the time unit
     * @return the remaining delay; zero or negative values indicate
     * that the delay has already elapsed
     */
    long getDelay(TimeUnit unit);
}
</code></pre> 
<p></p> 
<p> DelayQueue 将会在每个元素的 getDelay() 方法返回的值的时间段之后才释放掉该元素。如果返回的是 0 或者负值，延迟将被认为过期，该元素将会在 DelayQueue 的下一次 take 被调用的时候被释放掉。<br> 传递给 getDelay 方法的 getDelay 实例是一个枚举类型，它表明了将要延迟的时间段。TimeUnit 枚举将会取以下值：<br>  </p> 
<p>正如你所看到的，Delayed 接口也继承了 java.lang.Comparable 接口，这也就意味着 Delayed 对象之间可以进行对比。这个可能在对 DelayQueue 队列中的元素进行排序时有用，因此它们可以根据过期时间进行有序释放。</p> 
<p>DelayQueue使用场景：</p> 
<p></p> 
<p> DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。</p> 
<p> </p> 
<ul><li>DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。</li></ul> 
<p> </p> 
<h5>4. PriorityBlockingQueue</h5> 
<p> </p> 
<p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p> 
<p>注意 PriorityBlockingQueue 对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。<br> 同时注意，如果你从一个 PriorityBlockingQueue 获得一个 Iterator 的话，该 Iterator 并不能保证它对元素的遍历是以优先级为序的。<br>  </p> 
<h5>5. SynchronousQueue</h5> 
<p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p> 
<p>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:</p> 
<ul><li>如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体现整体的公平策略。</li><li>但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而这一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥饿的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。<br>  </li></ul> 
<h4>五. 小结 </h4> 
<p>BlockingQueue不光实现了一个完整队列所具有的基本功能，同时在多线程环境下，他还自动管理了多线间的自动等待与唤醒功能，从而使得程序员可以忽略这些细节，关注更高级的功能。 </p> 
<h4>References:</h4> 
<p></p> 
<ul><li>https://www.jb51.net/article/117204.htm</li><li>https://www.jb51.net/article/222527.htm</li><li>https://www.jianshu.com/p/7b2f1fa616c6</li><li>https://blog.csdn.net/defonds/article/details/44021605#t7<br>  </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d079957d57db133cd9427fcc952d845/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LAMP平台搭建-上</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/96bbb2c06c97f673cdc85b6398ca0c93/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C51 PWM控制舵机</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>