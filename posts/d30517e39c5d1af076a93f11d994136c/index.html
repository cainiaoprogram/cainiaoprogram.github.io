<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java获取GET和POST请求参数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java获取GET和POST请求参数" />
<meta property="og:description" content="URL和参数列表 一 获取请求方式
request.getMethod(); get和post都可用，
二 获取请求类型
request.getContentType(); get和post都可用，示例值：application/json ，multipart/form-data， application/xml等
三 获取所有参数key
request.getParameterNames(); get和post都可用，注：不适用contentType为multipart/form-data
四 获取参数值value
request.getParameter(&#34;test&#34;); get和post都可用，注：不适用contentType为multipart/form-data
五 获取取参数请求集合
request.getParameterMap(); get和post都可用，注： 不适用contentType为multipart/form-data
六 获取文本流
request.getInputStream() 适用于如：application/json，xml,multipart/form-data文本流或者大文件形式提交的请求或者xml等形式的报文
七 获取URL
getRequestURL()
八 获取参数列表:
1.getQueryString()
只适用于GET,比如客户端发送http://localhost/testServlet?a=b&amp;c=d&amp;e=f,通过request.getQueryString()得到的是a=b&amp;c=d&amp;e=f.
2.getParameter()
GET和POST都可以使用
但如果是POST请求要根据&lt;form&gt;表单提交数据的编码方式来确定能否使用.
当编码方式是(application/x- www-form-urlencoded)时才能使用.
这种编码方式(application/x-www-form-urlencoded)虽然简单，但对于传输大块的二进制数据显得力不从心.
对于传输大块的二进制数这类数据，浏览器采用了另一种编码方式(&#34;multipart/form-data&#34;),这时就需要使用下面的两种方法.
3.getInputStream()
4.getReader()
上面两种方法获取的是Http请求包的包体,因为GET方式请求一般不包含包体.所以上面两种方法一般用于POST请求获取参数.
需要注意的是：
request.getParameter()、 request.getInputStream()、request.getReader()这三种方法是有冲突的，因为流只能被读一次。
比如：
当form表单内容采用 enctype=application/x-www-form-urlencoded编码时，先通过调用request.getParameter()方法得到参数后,
再调用request.getInputStream()或request.getReader()已经得不到流中的内容，
因为在调用 request.getParameter()时系统可能对表单中提交的数据以流的形式读了一次,反之亦然。
当form表单内容采用 enctype=multipart/form-data编码时，即使先调用request.getParameter()也得不到数据，
所以这时调用request.getParameter()方法对 request.getInputStream()或request.getReader()没有冲突，
即使已经调用了 request.getParameter()方法也可以通过调用request.getInputStream()或request.getReader()得到表单中的数据,
而request.getInputStream()和request.getReader()在同一个响应中是不能混合使用的,如果混合使用就会抛异常。
九：下面附上解析multipart/form-data格式的报文方法，
示例报文如下：
解析：（利用upload方式解析的可以忽略）
/** * 解析multipart/form-data * @param res 这是通过request." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d30517e39c5d1af076a93f11d994136c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-05T17:22:01+08:00" />
<meta property="article:modified_time" content="2022-05-05T17:22:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java获取GET和POST请求参数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div id="article_content" class="article_content clearfix"> 
 <div id="content_views" class="htmledit_views"> 
  <h2 class="postTitle"> <a target="_blank" id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/xiancheng/p/5524338.html" rel="noopener noreferrer noopener noreferrer">URL和参数列表</a></h2> 
  <div class="clear"> 
  </div> 
  <div class="postBody"> 
   <div id="cnblogs_post_body"> 
    <p> 一 获取请求方式<br> request.getMethod(); get和post都可用，</p> 
    <p> 二 获取请求类型</p> 
    <p> request.getContentType(); get和post都可用，示例值：application/json ，multipart/form-data， application/xml等<br> </p> 
    <p> 三 获取所有参数key</p> 
    <p> request.getParameterNames(); get和post都可用，注：不适用contentType为multipart/form-data<br> </p> 
    <p> 四 获取参数值value</p> 
    <p> request.getParameter("test"); get和post都可用，注：不适用contentType为multipart/form-data<br> </p> 
    <p> 五 获取取参数请求集合</p> 
    <p> request.getParameterMap(); get和post都可用，注： 不适用contentType为multipart/form-data<br> </p> 
    <p> <br> </p> 
    <p> 六 获取文本流</p> 
    <p> request.getInputStream() 适用于如：application/json，xml,multipart/form-data文本流或者大文件形式提交的请求或者xml等形式的报文</p> 
    <p> </p> 
    <p> 七 获取URL</p> 
    <p> getRequestURL()</p> 
    <p> 八 获取参数列表:</p> 
    <p> 1.getQueryString()</p> 
    <p> <span id="__mceDel">只适用于GET,比如客户端发送http://localhost/testServlet?a=b&amp;c=d&amp;e=f,通过request.getQueryString()得到的是a=b&amp;c=d&amp;e=f.</span></p> 
    <p> <br> 2.getParameter()<br> GET和POST都可以使用<br> 但如果是POST请求要根据&lt;form&gt;表单提交数据的编码方式来确定能否使用.<br> 当编码方式是(application/x- www-form-urlencoded)时才能使用.<br> 这种编码方式(application/x-www-form-urlencoded)虽然简单，但对于传输大块的二进制数据显得力不从心.<br> 对于传输大块的二进制数这类数据，浏览器采用了另一种编码方式("multipart/form-data"),这时就需要使用下面的两种方法.</p> 
    <p> 3.getInputStream()<br> 4.getReader()<br> 上面两种方法获取的是Http请求包的包体,因为GET方式请求一般不包含包体.所以上面两种方法一般用于POST请求获取参数.</p> 
    <p> 需要注意的是：<br> request.getParameter()、 request.getInputStream()、request.getReader()这三种方法是有冲突的，因为流只能被读一次。<br> 比如：<br> 当form表单内容采用 enctype=application/x-www-form-urlencoded编码时，先通过调用request.getParameter()方法得到参数后,<br> 再调用request.getInputStream()或request.getReader()已经得不到流中的内容，<br> 因为在调用 request.getParameter()时系统可能对表单中提交的数据以流的形式读了一次,反之亦然。</p> 
    <p> 当form表单内容采用 enctype=multipart/form-data编码时，即使先调用request.getParameter()也得不到数据，<br> 所以这时调用request.getParameter()方法对 request.getInputStream()或request.getReader()没有冲突，<br> 即使已经调用了 request.getParameter()方法也可以通过调用request.getInputStream()或request.getReader()得到表单中的数据,<br> 而request.getInputStream()和request.getReader()在同一个响应中是不能混合使用的,如果混合使用就会抛异常。</p> 
    <p> <br> </p> 
    <p> <strong>九：下面附上解析multipart/form-data格式的报文方法，</strong></p> 
    <p> 示例报文如下：</p> 
    <p> <img src="https://images2.imgbox.com/ba/6e/PnWwU5v8_o.png" alt=""><br> </p> 
    <p> <strong><img src="" alt=""></strong></p> 
    <p> <strong>解析：（利用upload方式解析的可以忽略）</strong></p> 
    <p> </p> 
    <pre><code class="language-java">     /**
     * 解析multipart/form-data
     * @param res 这是通过request.getInputStream()都出来的报文
     * @param contentType multipart/form-data
     * @return  解析multipart/form-data格式提交过来的的流，转成json，这里忽略了报文中的“文件”部分，只解析“文本”字段
     */
    private static String getData(String res, String contentType) {
        BufferedReader reqbuf = null;
        JSONObject jsonObject = new JSONObject();
        try {
            final int NONE = 0; // 状态码，表示没有特殊操作
            final int DATAHEADER = 1; // 表示下一行要读到报头信息
            final int FIELDDATA = 2; // 表示下面要读到表单域的文本值
            String fieldname = ""; // 表单域的名称
            String fieldvalue = ""; // 表单域的值
            String boundary = ""; // 分界符字符串
            String lastboundary = ""; // 结束分界符字符串
            int pos = contentType.indexOf("boundary=");
            if (pos != -1) {
                pos += "boundary=".length();
                boundary = "--" + contentType.substring(pos); // 解析出分界符
                lastboundary = boundary + "--"; // 得到结束分界符
            }
            // 起始状态为NONE
            int state = NONE;
            // 从字符串中得到输出缓冲流
            reqbuf = new BufferedReader(new StringReader(res));
            while (true) {
                //读一行
                String s = reqbuf.readLine();
                //如果读到结束标志
                if (s == lastboundary || s == null) {
                    break;
                }
                switch (state) {
                    case NONE:
                        if ((s.startsWith(boundary))) {
                            // 如果读到分界符，则表示下一行一个头信息
                            state = DATAHEADER;
                        }
                        break;
                    case DATAHEADER:
                        pos = s.indexOf("name=");
                        if(pos != -1){
                            pos += "name=".length() + 1; // 1表示后面的"的占位(引号的占位)
                            s = s.substring(pos, s.length() - 1);
                            fieldname = s; // 表单域的名称放入fieldname
                            state = FIELDDATA; // 设置状态码，准备读取表单域的值
                        }
                        break;
                    case FIELDDATA:
                        // 读取表单域的值,再次读取，因为中间有空行
                        s = reqbuf.readLine();
                        fieldvalue = s; // 存入fieldvalue
                        jsonObject.put(fieldname, fieldvalue);
                        state = NONE;
                        break;
                }
            }
        } catch (IOException e) {
            log.error("解析异常", e);
        } finally {
            try {
                reqbuf.close();
            } catch (IOException e) {
                log.error("关闭异常", e);
            }
        }
        return jsonObject.toJSONString();
    }</code></pre> 
    <br> 
    <p></p> 
    <p></p> 
   </div> 
  </div> 
 </div> 
</div> 
<div id="treeSkill"></div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2be80260705af43c5032598cbdf13699/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker搭建emqx服务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9e33a09ea2d4bc4ae782fe189d34d03a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小区选择、重选和轻松测量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>