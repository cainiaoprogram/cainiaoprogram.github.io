<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux内存管理 -- 白话Linux page cache / swap cache/页框回收 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux内存管理 -- 白话Linux page cache / swap cache/页框回收" />
<meta property="og:description" content="文章目录 Linux内存管理 -- 白话页框回收什么是Page Cache？什么是Swap Cache？什么是buffer Cache？图解页框回收 Linux内存管理 – 白话页框回收 经过前面几篇博客翻译和阅读Understaning Linux Virtutal Memory Manger，对于Linux页框回收有了一些基本的理解。现在自己再来对照Linux kernel2.6.9源码来做一些总结。
什么是Page Cache？ 在Linux中所谓的page cache就是指struct address_space。磁盘中一个文件或者其他虚拟文件（shmem）所对应的page每次都是经过同一个struct address_space来进行管理，便于此类型的page在多进程见进行共享，以及阻止一些不必要的磁盘IO。
如下图中，两个进程打开同一个文件file A，以及读取文件内容：
从上图中可以看出，page cache的作用主要是将磁盘中文件缓存到内存，并集中管理，便于回收利用。
什么是Swap Cache？ 系统中常常会有一些进程在初始化时要了很多memory（主要是通过malloc获取的匿名page），初始化完成之后，这部分memory该进程不会经常用到，也没有释放。这就造成了内存的浪费。Linux就想了个办法要把这些memory中的数据置换到磁盘中，然后将这个memory标记为可回收，然后Linux中页框回收机制就会将这些page回收然后将这些page让给有需要的进程来用。
swap cache主要是要解决两个层面的问题：
&lt;1&gt;哪些page可以加入到swap cache中？swap cache中page如何管理?
&lt;2&gt;swap cache中被交换到磁盘中page，如何知道放在磁盘哪个位置，再次被找回来 ？
第一个问题有一个特殊的address_space,swapper_space来管理，具体如何回收由下一小节说明。
第二个问题通过struct swap_info_struct来管理，其中最终要的是将原来这个page的对应的PTE替换成type &#43; offset的形式。
什么是buffer Cache？ 在page cache出现之前，文件的缓存或者块设备的数据缓存叫做buffer cache。现在都叫page cache。
图解页框回收 在Linux的每个Zone中有两个list:active_list和inactive_list,这两个list包含了该Zone中所有已经分配的page。其中active_list中表示正在使用的page，而inactive_list中是很少使用待回收的page。在下列两种case下会触发内存回收机制:从active_list的底部循环将active_list中符合条件的page添加待inactive_list,然后再从inactive_list中选择合适的page释放内存。 每当alloc page时，如果发现memory不够了，调用try_to_free_pages()来释放内存。通过守护进程kswapd来check zone的memory water mark，发现内存到达低水位，触发内存回收机制释放内存。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/417a4dbdca19d321800b99eddc2a7045/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-18T18:19:35+08:00" />
<meta property="article:modified_time" content="2020-02-18T18:19:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux内存管理 -- 白话Linux page cache / swap cache/页框回收</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Linux___1" rel="nofollow">Linux内存管理 -- 白话页框回收</a></li><li><ul><li><a href="#Page_Cache_3" rel="nofollow">什么是Page Cache？</a></li><li><a href="#Swap_Cache_8" rel="nofollow">什么是Swap Cache？</a></li><li><a href="#buffer_Cache_16" rel="nofollow">什么是buffer Cache？</a></li><li><a href="#_18" rel="nofollow">图解页框回收</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Linux___1"></a>Linux内存管理 – 白话页框回收</h2> 
<p>经过前面几篇博客翻译和阅读<a href="https://www.kernel.org/doc/gorman/html/understand/understand013.html" rel="nofollow">Understaning Linux Virtutal Memory Manger</a>，对于Linux页框回收有了一些基本的理解。现在自己再来对照Linux kernel2.6.9源码来做一些总结。</p> 
<h3><a id="Page_Cache_3"></a>什么是Page Cache？</h3> 
<p>在Linux中所谓的page cache就是指struct address_space。磁盘中一个文件或者其他虚拟文件（shmem）所对应的page每次都是经过同一个struct address_space来进行管理，便于此类型的page在多进程见进行共享，以及阻止一些不必要的磁盘IO。<br> 如下图中，两个进程打开同一个文件file A，以及读取文件内容：<br> <img src="https://images2.imgbox.com/b6/35/zeHTpmAc_o.png" alt="address_space"><br> 从上图中可以看出，page cache的作用主要是将磁盘中文件缓存到内存，并集中管理，便于回收利用。</p> 
<h3><a id="Swap_Cache_8"></a>什么是Swap Cache？</h3> 
<p>系统中常常会有一些进程在初始化时要了很多memory（主要是通过malloc获取的匿名page），初始化完成之后，这部分memory该进程不会经常用到，也没有释放。这就造成了内存的浪费。Linux就想了个办法要把这些memory中的数据置换到磁盘中，然后将这个memory标记为可回收，然后Linux中页框回收机制就会将这些page回收然后将这些page让给有需要的进程来用。<br> swap cache主要是要解决两个层面的问题：<br> &lt;1&gt;哪些page可以加入到swap cache中？swap cache中page如何管理?<br> &lt;2&gt;swap cache中被交换到磁盘中page，如何知道放在磁盘哪个位置，再次被找回来 ？<br> 第一个问题有一个特殊的address_space,swapper_space来管理，具体如何回收由下一小节说明。<br> 第二个问题通过struct swap_info_struct来管理，其中最终要的是将原来这个page的对应的PTE替换成type + offset的形式。<br> <img src="https://images2.imgbox.com/3b/a1/oxnlIgTo_o.png" alt="swap"></p> 
<h3><a id="buffer_Cache_16"></a>什么是buffer Cache？</h3> 
<p>在page cache出现之前，文件的缓存或者块设备的数据缓存叫做buffer cache。现在都叫page cache。</p> 
<h3><a id="_18"></a>图解页框回收</h3> 
<ul><li>在Linux的每个Zone中有两个list:active_list和inactive_list,这两个list包含了该Zone中所有已经分配的page。其中active_list中表示正在使用的page，而inactive_list中是很少使用待回收的page。</li><li>在下列两种case下会触发内存回收机制:从active_list的底部循环将active_list中符合条件的page添加待inactive_list,然后再从inactive_list中选择合适的page释放内存。 
  <ul><li>每当alloc page时，如果发现memory不够了，调用try_to_free_pages()来释放内存。</li><li>通过守护进程kswapd来check zone的memory water mark，发现内存到达低水位，触发内存回收机制释放内存。<br> <img src="https://images2.imgbox.com/52/a8/PDHOcjgs_o.png" alt="de"></li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72477e677365342cf16ecd79983cbdcf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Camera6  MTK camera启动流程介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17d80b4d1fe96d9403a57f0fee3916d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">优化算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>