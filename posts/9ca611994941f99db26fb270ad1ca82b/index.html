<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32笔记_10(ADC—电压采集) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32笔记_10(ADC—电压采集)" />
<meta property="og:description" content="ADC—电压采集 ADC 简介 STM32f103 系列有 3 个 ADC，精度为 12 位，每个 ADC 最多有 16 个外部通道。其中 ADC1 和ADC2 都有 16 个外部通道， ADC3 根据 CPU 引脚的不同通道数也不同，一般都有 8 个外部通道。
ADC 功能框图剖析 电压输入范围 ADC 输入范围为： VREF- ≤ VIN ≤ VREF&#43;。由 VREF-、 VREF&#43; 、 VDDA 、 VSSA、这四个外部引脚决定。
一般把 VSSA 和 VREF- 接地，把 VREF&#43; 和 VDDA 接 3V3，得到 ADC 的输入电压范围为： 0~3.3V。
想让输入的电压范围变宽的话，在外部加一个电压调理电路，把需要转换的电压抬升或者降压到 0~3.3V，这样 ADC 就可以测量。
输入通道 STM32 的ADC 多达 18 个通道，其中外部的 16 个通道就是框图中的ADCx_IN0 ,ADCx_IN1… ADCx_IN15。
这十六个通道对应不同的IO口。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9ca611994941f99db26fb270ad1ca82b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-08T16:23:22+08:00" />
<meta property="article:modified_time" content="2023-02-08T16:23:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32笔记_10(ADC—电压采集)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;">ADC—电压采集</h2> 
<h3>ADC 简介</h3> 
<blockquote> 
 <p>STM32f103 系列有<span style="color:#fe2c24;"> 3 个 ADC</span>，精度为 <span style="color:#fe2c24;">12 位</span>，每个 ADC 最多有 <span style="color:#fe2c24;">16 个外部通道</span>。其中 ADC1 和ADC2 都有 16 个外部通道， ADC3 根据 CPU 引脚的不同通道数也不同，一般都有 8 个外部通道。</p> 
</blockquote> 
<h3>ADC 功能框图剖析</h3> 
<p><img alt="" height="984" src="https://images2.imgbox.com/f6/fc/YJelWMjS_o.png" width="913"></p> 
<h3><strong>电压输入范围</strong></h3> 
<p>        ADC 输入范围为： <strong>VREF- ≤ VIN ≤ VREF+</strong>。由 VREF-、 VREF+ 、 VDDA 、 VSSA、这四个外部引脚决定。</p> 
<p>        一般把<strong> VSSA 和 VREF- 接地</strong>，把 <strong>VREF+ 和 VDDA 接 3V3</strong>，得到 ADC 的输入电压范围为： <strong>0~3.3V</strong>。</p> 
<p>        想让输入的电压范围变宽的话，在外部加一个电压调理电路，把需要转换的<strong>电压抬升或者降压到 0~3.3V</strong>，这样 ADC 就可以测量。</p> 
<h3>输入通道</h3> 
<p>        STM32 的ADC 多达 18 个通道，其中外部的 16 个通道就是框图中的ADCx_IN0 ,ADCx_IN1… ADCx_IN15。</p> 
<p>        这十六个通道对应<strong>不同的IO口</strong>。</p> 
<p>        ADC1/2/3 还有<strong>内部通道</strong>： ADC1 的通道 16 连接到了芯片内部的温度传感器， Vrefint 连接到了通道 17。</p> 
<p>        ADC2 的模拟通道 16 和 17 连接到了内部的 VSS。</p> 
<p>                ADC3 的模拟通道 9、 14、 15、 16 和 17 连接到了内部的 VSS。</p> 
<p><img alt="" height="601" src="https://images2.imgbox.com/0c/c9/IttdSzKh_o.png" width="1047"></p> 
<p></p> 
<p>        外部的 16 个通道在转换时分为<strong>规则通道</strong>和<strong>注入通道</strong>，<strong>规则通道最多有 16 路，注入通道最多有 4 路。</strong></p> 
<h3>规则通道</h3> 
<blockquote> 
 <p>        规则通道：顾名思意，规则通道就是很规矩的意思，我们平时一般使用的就是这个通道，或者应该说我们用到的都是这个通道，没有什么特别要注意的可讲。</p> 
</blockquote> 
<h3>注入通道</h3> 
<blockquote> 
 <p>        注入通道：一种在规则通道转换的时候强行插入要转换的一种通道，跟中断程序很像。</p> 
</blockquote> 
<p>        如果在规则通道转换过程中，有注入通道插队，那么就要先转换完注入通道，等注入通道转换完成后，再回到规则通道的转换流程。</p> 
<p>        <strong>注入通道只有在规则通道存在时才会出现。</strong></p> 
<h3>转换顺序</h3> 
<h4>规则序列</h4> 
<p>        规则序列寄存器有 3 个，分别为 SQR3、 SQR2、 SQR1。</p> 
<p>        由多达16个转换组成。规则通道和它们的转换顺序在ADC_SQRx寄存器中选择。规则组中转换的总数应写入ADC_SQR1寄存器的L[3:0]位中。</p> 
<p>        SQR3 控制着规则序列中的第一个到第六个转换，对应的位为： SQ1[4:0]~SQ6[4:0]，第一次转换的是位 4:0 SQ1[4:0]，如果通道 16 想第一次转换，那么在 SQ1[4:0] 写 16 即可。</p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/97/ca/nEPb6kQZ_o.png" width="1134"></p> 
<p></p> 
<p>        SQR2 控制着规则序列中的第 7 到第 12 个转换，对应的位为： SQ7[4:0]~SQ12[4:0]，如果通道 1 想第 8 个转换，则 SQ8[4:0] 写 1 即可。</p> 
<p><img alt="" height="672" src="https://images2.imgbox.com/96/80/twvFDW8P_o.png" width="1160"></p> 
<p></p> 
<p>        SQR1 控制着规则序列中的第 13 到第 16 个转换，对应位为： SQ13[4:0]~SQ16[4:0]，如果通道 6 想第 10 个转换，则SQ10[4:0] 写 6 即可。</p> 
<p><img alt="" height="752" src="https://images2.imgbox.com/cd/2e/ZgWa8yuD_o.png" width="1185"></p> 
<p></p> 
<p>        具体使用多少个通道，由 SQR1 的位 L[3:0] 决定，最多 16 个通道。</p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/e9/37/TuJN3ozv_o.png" width="1036"></p> 
<p></p> 
<h4>注入序列</h4> 
<p>        注入序列寄存器 JSQR 只有一个，最多支持 4 个通道，具体多少个由 JSQR 的 JL[2:0] 决定。</p> 
<p>        如果JL 的值小于 4 的话，则 JSQR 跟 SQR 决定转换顺序的设置不一样，第一次转换的不是 JSQR1[4:0]，而是 JCQRx[4:0] ， x = 4-JL），跟 SQR 刚好相反。</p> 
<p>        如果 JL=00（1 个转换），那么转换的顺序是从JSQR4[4:0] 开始，而不是从 JSQR1[4:0] 开始，这个要注意，编程的时候不要搞错。当 JL 等于 4时，跟 SQR 一样。</p> 
<p></p> 
<p><img alt="" height="801" src="https://images2.imgbox.com/83/60/Ubvjrys7_o.png" width="1045"></p> 
<p><img alt="" height="269" src="https://images2.imgbox.com/64/07/UU8v2oIc_o.png" width="1044"></p> 
<p></p> 
<h3>触发源</h3> 
<p>        ADC 转换可以由 ADC 控制寄存器 2: ADC_CR2 的 ADON 这个位来控制，<strong>写 1 的时候开始转换，写 0 的时候停止转换</strong>，这个是最简单也是最好理解的开启 ADC 转换的控制方式，理解起来没啥技术含量。        </p> 
<p><img alt="" height="260" src="https://images2.imgbox.com/87/94/qJtHfMgy_o.png" width="969"></p> 
<p></p> 
<p>        ADC 还支持触发转换，包括内部定时器触发和外部 IO 触发。</p> 
<p>        触发源的选择：ADC 控制寄存器 2:ADC_CR2 的 EXTSEL[2:0] 和JEXTSEL[2:0] 位来控制。EXTSEL[2:0] 用于选择规则通道的触发源， JEXTSEL[2:0] 用于选择注入通道的触发源。</p> 
<p>        触发源之后，触发源是否要激活，则由 ADC 控制寄存器 2:ADC_CR2 的EXTTRIG 和 JEXTTRIG 这两位来激活。</p> 
<h4><strong>规则通道的触发源</strong></h4> 
<p><img alt="" height="588" src="https://images2.imgbox.com/56/8e/DGkBazw4_o.png" width="986"></p> 
<p></p> 
<h4>注入通道的触发源</h4> 
<p><img alt="" height="613" src="https://images2.imgbox.com/b2/9e/NjGeJKXj_o.png" width="981"></p> 
<p></p> 
<p>        ADC3 的规则转换和注入转换的触发源与 ADC1/2的有所不同。</p> 
<p><img alt="" height="422" src="https://images2.imgbox.com/8c/9d/AIKjPulf_o.png" width="477"></p> 
<p></p> 
<h3>转换时间 </h3> 
<h4>ADC 时钟</h4> 
<p>        ADC 输入时钟 ADC_CLK 由 PCLK2 经过分频产生，<strong>最大是 14M</strong>，分频因子由 RCC 时钟配置寄存器 RCC_CFGR 的位 15:14 ADCPRE[1:0] 设置，可以是 2/4/6/8 分频，注意这里没有 1 分频。一般我们设置 PCLK2=HCLK=72M。</p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/67/25/6yRmIHEX_o.png" width="968"></p> 
<p></p> 
<h4>采样时间</h4> 
<p>        ADC 使用若干个 ADC_CLK 周期对输入的电压进行采样，采样的周期数可通过 ADC 采样时间寄存器 ADC_SMPR1 和 ADC_SMPR2 中的 SMP[2:0] 位设置， ADC_SMPR2 控制的是通道 0~9，ADC_SMPR1 控制的是通道 10~17。</p> 
<p>        每个通道可以分别用不同的时间采样。其中<strong>采样周期最小是1.5 个</strong>，即如果我们要达到最快的采样，那么应该设置采样周期为 1.5 个周期，这里说的周期就是 1/ADC_CLK。</p> 
<h4>转换时间</h4> 
<p>        ADC 的转换时间跟 ADC 的<strong>输入时钟</strong>和<strong>采样时间</strong>有关，公式为： <strong>Tconv = 采样时间 + 12.5 个周期。</strong></p> 
<p>当 ADCLK = 14MHZ（最高），采样时间设置为 1.5 周期（最快），那么总的转换时间（最短） Tconv= 1.5 周期 + 12.5 周期 = 14 周期 = 1us。</p> 
<p><strong>一般我们设置 PCLK2=72M，经过 ADC 预分频器能分频到最大的时钟只能是 12M，采样周期设置为 1.5 个周期，算出最短的转换时间为 1.17us，这个才是最常用的。</strong></p> 
<h3>数据寄存器</h3> 
<p>        ADC 转换后的数据根据转换组的不同，规则组的数据放在 ADC_DR 寄存器，注入组的数据放在 JDRx。</p> 
<h4>规则数据寄存器</h4> 
<p>        ADC 规则组数据寄存器 ADC_DR 只有一个，是一个 <strong>32 位</strong>的寄存器。</p> 
<p>        <strong>低 16 位在单 ADC</strong> 时使用，<strong>高 16 位</strong>是在 ADC1 中<strong>双模式</strong>下保存 ADC2 转换的规则数据。</p> 
<p>        <strong>双模式就是 ADC1 和 ADC2 同时使用。</strong></p> 
<p>        由于ADC 的<strong>精度是 12 位(2^12 = 4096)</strong>，无论 ADC_DR 的高16 或者低 16 位都放不满，只能左对齐或者右对齐（ADC_CR2 的11 位 ALIGN 设置）。</p> 
<p>        规则通道可以有 16 个这么多，可规则数据寄存器只有一个，如果使用多通道转换，那转换的数据就全部都挤在了 DR 里面，前一个时间点转换的通道数据，就会被下一个时间点的另外一个通道转换的数据覆盖掉，所以当通道转换完成后就应该把数据取走，或者开启 DMA 模式，把数据传输到内存里面，不然就会造成数据的覆盖。最常用的做法就是开启 DMA 传输。</p> 
<h4>注入数据寄存器</h4> 
<p>        ADC 注入组<strong>最多有 4 个通道</strong>，刚好注入数据寄存器也有 4 个，<strong>每个通道对应着自己的寄存器，不会跟规则寄存器那样产生数据覆盖的问题</strong>。</p> 
<p>ADC_JDRx 是 32 位的，低 16 位有效，高 16 位保留，数据同样分为左对齐和右对齐（ADC_CR2 的 11 位 ALIGN 设置</p> 
<p>）。</p> 
<h3>中断</h3> 
<p>        转换结束中断</p> 
<p>        数据转换结束后，可以产生中断。</p> 
<p>        中断分为三种：规则通道转换结束中断，注入转换通道转换结束中断，模拟看门狗中断。</p> 
<p>        模拟看门狗中断</p> 
<p>        当被 ADC 转换的模拟电压低于低阈值或者高于高阈值时，就会产生中断，前提是我们开启了模拟看门狗中断，其中低阈值和高阈值由 ADC_LTR 和 ADC_HTR 设置。</p> 
<p>        例如我们设置高阈值是2.5V，那么模拟电压超过 2.5V 的时候，就会产生模拟看门狗中断，反之低阈值也一样。</p> 
<h3>DMA 请求</h3> 
<p>        规则和注入通道转换结束后，除了产生中断外，还可以产生 DMA 请求，把转换好的数据直接存储在内存里面。要注意的是只有 ADC1 和 ADC3 可以产生 DMA 请求。</p> 
<p>        一般我们在使用 ADC 的时候都会开启 DMA 传输。</p> 
<h3>电压转换</h3> 
<p>        一般在设计原理图的时候会把 ADC 的输入电压范围设定在： 0~3.3v，因为 ADC 是 12 位的，那么 12 位满量程对应的就是 3.3V， 12 位满量程对应的数字值是： 2^12 = 4096。</p> 
<p>        数值 0 对应的就是 0V。如果转换后的数值为 X ， X 对应的模拟电压为 Y，那么会有这么一个等式成立： <strong>2^12 / 3.3 = X/Y， =&gt; Y = (3.3 * X ) / 2^12</strong>。</p> 
<h3>ADC 初始化结构体详解</h3> 
<h4>ADC_InitTypeDef 结构体</h4> 
<p><img alt="" height="410" src="https://images2.imgbox.com/ab/e2/4wdmwzYr_o.png" width="1080"></p> 
<p></p> 
<p><strong>ADC_Mode：</strong>配置 ADC 的模式，当使用一个 ADC 时是独立模式，使用两个 ADC 时是双模式，在双模式下还有很多细分模式可选，我们一般使用一个 ADC 的独立模式。</p> 
<p><strong>ScanConvMode：</strong>可选参数为 ENABLE 和 DISABLE，配置是否使用扫描。如果是单通道 AD 转换使用 DISABLE，如果是多通道 AD 转换使用 ENABLE。</p> 
<p><strong>ADC_ContinuousConvMode：</strong>可选参数为 ENABLE 和 DISABLE，配置是启动自动连续转换还是单次转换。使用 ENABLE 配置为使能自动连续转换；使用 DISABLE 配置为单次转换，转换一次后停止需要手动控制才重新启动转换。一般设置为连续转换。</p> 
<p><strong>ADC_ExternalTrigConv：</strong>外部触发选择，图单个 ADC 功能框图 中列举了很多外部触发条件，可根据项目需求配置触发来源。实际上，我们一般使用软件自动触发。</p> 
<p><strong>ADC_DataAlign：</strong>转换结果数据对齐模式，可选右对齐 ADC_DataAlign_Right 或者左对齐ADC_DataAlign_Left。一般我们选择右对齐模式。</p> 
<p><strong>ADC_NbrOfChannel：</strong> AD 转换通道数目，根据实际设置即可。</p> 
<h3>ADC电压采集（独立模式单通道采集中断读取实验）</h3> 
<p><strong>硬件部分：</strong></p> 
<p><img alt="" height="707" src="https://images2.imgbox.com/6d/9a/6KFDlcu4_o.png" width="897"> </p> 
<p></p> 
<p>        贴片滑动变阻器的动触点通过连接至 STM32 芯片的 ADC 通道引脚。当我们使用旋转滑动变阻器调节旋钮时，其动触点电压也会随之改变，电压变化范围为 0~3.3V，亦是开发板默认的 ADC电压采集范围。</p> 
<h4>编程要点</h4> 
<p>1) 初始 ADC 用到的 GPIO；</p> 
<p>2) 设置 ADC 的工作参数并初始化；</p> 
<p>3) 设置 ADC 工作时钟；</p> 
<p>4) 设置 ADC 转换通道顺序及采样时间；</p> 
<p>5) 配置使能 ADC 转换完成中断，在中断内读取转换完数据；</p> 
<p>6) 使能 ADC；</p> 
<p>7) 使能软件触发 ADC 转换。ADC 转换结果数据使用中断方式读取，这里没有使用 DMA 进行数据传输。</p> 
<p><strong> adc.c</strong></p> 
<pre><code class="hljs">#include "./adc/adc.h"

__IO uint16_t ADC_ConvertedValue;

static void ADC_NVIC_Config(void)
{
	NVIC_InitTypeDef NVIC_InitStruct;
	
	//优先级分组
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
	//NVIC结构体配置
	NVIC_InitStruct.NVIC_IRQChannel = ADC_IRQ;
	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
	
	NVIC_Init(&amp;NVIC_InitStruct);
}

//ADC的GPIO初始化
void ADCx_GPIO_Config(void)
{
	GPIO_InitTypeDef GPIO_InitStruct;
	//打开GPIO时钟
	ADC_GPIO_APBxClock_FUN(ADC_GPIO_CLK,ENABLE);
	//GPIO结构体配置
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;
	GPIO_InitStruct.GPIO_Pin = ADC_PIN;
	//初始化GPIO
	GPIO_Init(ADC_PORT,&amp;GPIO_InitStruct);
}

//ADC初始化
void ADCx_MODE_Config(void)
{
	ADC_InitTypeDef ADC_InitStruct;
	
	//打开 ADC 时钟
	ADC_APBxClock_FUN(ADC_CLK,ENABLE);
	
	// ADC 模式配置
	// 只使用一个ADC，属于独立模式
	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;
	// 禁止扫描模式，多通道才要，单通道不需要
	ADC_InitStruct.ADC_ScanConvMode = DISABLE;
	// 连续转换模式
	ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;
	// 不用外部触发转换，软件开启即可
	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
	// 转换结果右对齐
	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;
	// 转换通道1个
	ADC_InitStruct.ADC_NbrOfChannel = 1;
	// 初始化ADC
	ADC_Init(ADC_x,&amp;ADC_InitStruct);
	
	// 配置ADC时钟为PCLK2的8分频，即9MHz
	RCC_ADCCLKConfig(RCC_PCLK2_Div8);
	
	// 配置 ADC 通道转换顺序和采样时间
	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL, 1, ADC_SampleTime_55Cycles5);
	
	// ADC 转换结束产生中断，在中断服务程序中读取转换值
	ADC_ITConfig(ADC_x, ADC_IT_EOC, ENABLE);
	
	// 开启ADC ，并开始转换
	ADC_Cmd(ADC_x,ENABLE);
	
	// 初始化ADC 校准寄存器  
	ADC_ResetCalibration(ADC_x);
	// 等待校准寄存器初始化完成
	while(ADC_GetResetCalibrationStatus(ADC_x));
	// ADC开始校准
	ADC_StartCalibration(ADC_x);
	// 等待校准寄存器初始化完成
	while(ADC_GetResetCalibrationStatus(ADC_x));
	// 由于没有采用外部触发，所以使用软件触发ADC转换 
	ADC_SoftwareStartConvCmd(ADC_x,ENABLE);
}

//ADC初始化
void ADCx_Init(void)
{
	ADC_NVIC_Config();
	ADCx_GPIO_Config();
	ADCx_MODE_Config();
}
</code></pre> 
<p>adc.h</p> 
<pre><code class="hljs">#ifndef _ADC_H
#define _ADC_H

#include "stm32f10x.h"

// ADC 编号选择	使用ADC2
#define    ADC_APBxClock_FUN         RCC_APB2PeriphClockCmd    
#define    ADC_x                     ADC2     
#define    ADC_CLK                   RCC_APB2Periph_ADC2    

// ADC GPIO宏定义
// 注意：用作ADC采集的IO必须没有复用，否则采集电压会有影响
#define    ADC_GPIO_APBxClock_FUN   RCC_APB2PeriphClockCmd     
#define    ADC_GPIO_CLK             RCC_APB2Periph_GPIOC     
#define    ADC_PORT                 GPIOC     
#define    ADC_PIN                  GPIO_Pin_1     

// ADC 通道宏定义
#define    ADC_CHANNEL              ADC_Channel_11     

// ADC 中断相关宏定义
#define    ADC_IRQ                  ADC1_2_IRQn    
#define    ADC_IRQHandler           ADC1_2_IRQHandler     

void ADCx_Init(void);

#endif
</code></pre> 
<p><strong>中断服务函数</strong></p> 
<pre><code class="hljs">void ADC_IRQHandler(void)
{
	if(ADC_GetITStatus(ADC_x,ADC_IT_EOC) != RESET)
	{
		// 读取ADC的转换值
		ADC_ConvertedValue = ADC_GetConversionValue(ADC_x);
	}
	ADC_ClearITPendingBit(ADC_x,ADC_IT_EOC);
}</code></pre> 
<p><strong>main.c</strong></p> 
<pre><code class="hljs">#include "stm32f10x.h"
#include "led.h"
#include "./usart/usart.h"
#include "./adc/adc.h"
#include "./delay/delay.h"

extern __IO uint16_t ADC_ConvertedValue;

//采集到的真时电压
float ADC_ConvertedValue_Reality; 

int main(void)
{
	usart_init();
	ADCx_Init();
	
	printf("这是一个adc采集电压的实验！！！");
	
	while(1)
	{
		//计算采集的真实电压
		ADC_ConvertedValue_Reality = (float)ADC_ConvertedValue/4096*3.3;
		printf("ADC采集到的值ADC_ConvertedValue：%d\n",ADC_ConvertedValue);
		printf("ADC采集到的实际电压值ADC_ConvertedValue_Reality：%.2fV\n",ADC_ConvertedValue_Reality);	
		Delay_ms(500);
	}
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e87b5109806d61d177d78b09bc8861d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通俗讲解曲面参数化(三角网格参数化)是怎么做的</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d411a1f8f25579b8dc7e5579fc92bd15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenCV调用工业相机</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>