<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Leecode刷题常用函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Leecode刷题常用函数" />
<meta property="og:description" content="Leecode刷题常用函数 1.accumulate
定义在#include中，作用：累加求和
accumulate带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值。
int sum = accumulate(vec.begin() , vec.end() , 42); 2,sort 排序&#43;Lambda表达式
sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt; a, vector&lt;int&gt; b) { return a[1] &lt; b[1]; 3.哈希表写法
unordered_map &lt;key, value&gt; ori 遍历：
for(const auto &amp;p:sin) { if(cur[p.first]&lt;p.second) { //return false; } } 4.compare
C&#43;&#43;string的compare()比较函数
两个字符串相同，返回0。 调用字符串小与被调用字符串，返回-1。 调用字符串大于被调用字符串，返回1。 字符串说的大小通常和字典顺序是一致的。 字符串小的在字典里靠前，字符串大的在字典里靠后。即返回值是-1的话，调用字符串比被调用字符串靠前；返回值是1的话，调用字符串比被调用字符串靠后。
compare()比较时逐字符比较的，一旦能比较出结果，就不再比较了。 例如“abc”和“adf”，首先a和a比较，比不出结果；则b和d比较，结果就是“abc”小于“adf”,返回-1，即字典里“abc”在“adf”前面。例如“abc”和“abcd”比较，若“abc”都比完了，“abcd”还没完，说明“abc”小,返回值为-1,字典里“abc”靠前。总之记住这个比较规则和字典顺序一致即可.
5.size()和length()
对于.length()和.size()，其实是没有区别的，是因为容器都含有.size()方法，但是对于string类来说，.length()更加直观，所以新加了这个函数，但是其实他俩相当于是同义词。
5.哈希表排序写法
我们首先假设我们要操作的map、unordered_map对象是m。
第一种做法是先建立一个vector&lt;pair&lt;type, type&gt;&gt;的容器。
std::vector&lt;std::pair&lt;int, int&gt;&gt; tmp; for (auto&amp; i : m) tmp.push_back(i); std::sort(tmp.begin(), tmp.end(), [=](std::pair&lt;int, int&gt;&amp; a, std::pair&lt;int, int&gt;&amp; b) { return a." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cefb80e2f0445d443aec963221601a29/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-13T16:27:46+08:00" />
<meta property="article:modified_time" content="2021-05-13T16:27:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Leecode刷题常用函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Leecode_0"></a>Leecode刷题常用函数</h3> 
<p>1.<strong>accumulate</strong><br> 定义在#include中，作用：累加求和<br> accumulate带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>2,sort 排序+Lambda表达式</p> 
<pre><code class="prism language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>3.哈希表写法</p> 
<pre><code class="prism language-cpp">unordered_map <span class="token operator">&lt;</span>key<span class="token punctuation">,</span> value<span class="token operator">&gt;</span> ori
</code></pre> 
<p>遍历：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>p<span class="token operator">:</span>sin<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">[</span>p<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token operator">&lt;</span>p<span class="token punctuation">.</span>second<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//return false;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p>4.compare<br> C++string的compare()比较函数</p> 
<pre><code>两个字符串相同，返回0。
调用字符串小与被调用字符串，返回-1。
调用字符串大于被调用字符串，返回1。
</code></pre> 
<p>字符串说的大小通常和字典顺序是一致的。 字符串小的在字典里靠前，字符串大的在字典里靠后。即返回值是-1的话，调用字符串比被调用字符串靠前；返回值是1的话，调用字符串比被调用字符串靠后。</p> 
<p>compare()比较时逐字符比较的，一旦能比较出结果，就不再比较了。 例如“abc”和“adf”，首先a和a比较，比不出结果；则b和d比较，结果就是“abc”小于“adf”,返回-1，即字典里“abc”在“adf”前面。例如“abc”和“abcd”比较，若“abc”都比完了，“abcd”还没完，说明“abc”小,返回值为-1,字典里“abc”靠前。总之记住这个比较规则和字典顺序一致即可.<br> 5.size()和length()<br> 对于.length()和.size()，其实是没有区别的，是因为容器都含有.size()方法，但是对于string类来说，.length()更加直观，所以新加了这个函数，但是其实他俩相当于是同义词。</p> 
<p>5.哈希表排序写法<br> 我们首先假设我们要操作的map、unordered_map对象是m。<br> 第一种做法是先建立一个vector&lt;pair&lt;type, type&gt;&gt;的容器。</p> 
<pre><code class="prism language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> tmp<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> i <span class="token operator">:</span> m<span class="token punctuation">)</span>
    tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
          <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a<span class="token punctuation">.</span>second <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>second<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>6.清空vector&lt;&gt;<br> (1).使用clear ，清空元素，不回收空间</p> 
<pre><code class="prism language-cpp"> vecInt<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>(2）使用swap,清除元素并回收内存<br> <code>vector &lt;int&gt;().swap(vecInt); //清除容器并最小化它的容量</code>，<br> 7.vector清除末尾元素</p> 
<pre><code class="prism language-cpp">a<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>8.vector查找<br> 调用find方法（需要include）</p> 
<pre><code class="prism language-cpp">iVector <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>9.to_string()</p> 
<p>10.set<br> set是集合，set中不会包含重复的元素，这是和vector的区别。</p> 
<p>定义：<br> 定义一个元素为整数的集合a，可以用 set a;</p> 
<p>1，set的含义是集合，它是一个有序的容器，里面的元素都是排序好的，支持插入，删除，查找等操作，就像一个集合一样。所有的操作的都是严格在logn时间之内完成，效率非常高。 set和multiset的区别是：set插入的元素不能相同，但是multiset可以相同。</p> 
<p>set的基本操作：</p> 
<ol><li>begin() 返回指向第一个元素的迭代器</li><li>clear() 清除所有元素</li><li>count() 返回某个值元素的个数</li><li>empty() 如果集合为空，返回true</li><li>end() 返回指向最后一个元素的迭代器</li><li>equal_range() 返回集合中与给定值相等的上下限的两个迭代器</li><li>erase() 删除集合中的元素</li><li>find() 返回一个指向被查找到元素的迭代器</li><li>get_allocator() 返回集合的分配器<br> 10.insert() 在集合中插入元素<br> 11.lower_bound() 返回指向大于（或等于）某值的第一个元素的迭代器<br> 12.key_comp() 返回一个用于元素间值比较的函数<br> 13.max_size() 返回集合能容纳的元素的最大限值<br> 14.rbegin() 返回指向集合中最后一个元素的反向迭代器<br> 15.rend() 返回指向集合中第一个元素的反向迭代器<br> 16.size() 集合中元素的数目<br> 17.swap() 交换两个集合变量<br> 18.upper_bound() 返回大于某个值元素的迭代器<br> 19.value_comp() 返回一个用于比较元素间的值的函数</li></ol> 
<p>11.栈的定义<br> stack stk;<br> stk.pop();<br> stk.push(ch);<br> stk.empty()<br> stk.top()</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8740262ffeef002edc94d5e359880aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">go-zero 单体应用框架学习—4 监听端口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e51c14cdd428a7ae4f3ba6e2100d8b71/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用AI算法玩起了素描</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>