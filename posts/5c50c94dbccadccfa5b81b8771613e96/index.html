<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>手把手教你实现 MySQL 读写分离 &#43; 故障转移 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="手把手教你实现 MySQL 读写分离 &#43; 故障转移" />
<meta property="og:description" content="公众号后台回复“学习”，免费获取精品学习资料
扫描下方海报 试听
本文来源：Java知音
前言 上一篇发了手动搭建Redis集群和MySQL主从同步(非Docker)之后，很多同学对文中主从结构提到的读写分离感兴趣，本打算在双十一期间直接把读写分离分享给大家，奈何工作一直没停下，所以这周抽空把这些分享出来。
关于MySQL的读写分离的实现，有两种方式，第一种方式即我们手动在代码层实现逻辑，来解析读请求或者写请求，分别分发到不同的数据库中，实现读写分离；第二种方式就是基于MyCat中间件来实现读写分离的效果；这两种方式我都会在这篇博客中进行详细地介绍、搭建，并且分析其中的优劣。
原理初探 从MySQL的主从同步开始谈起，最开始我们的数据库架构是这样的。
主库负责了所有的读写操作，而从库只对主库进行了备份，就像我在上一篇文章中说的那样，我认为如果只实现了一个备份，不能读写分离和故障转移，不能降低Master节点的IO压力，这样的主从架构看起来性价比似乎不是很高。
我们所希望的主从架构是，当我们在写数据时，请求全部发到Master节点上，当我们需要读数据时，请求全部发到Slave节点上。并且多个Slave节点最好可以存在负载均衡，让集群的效率最大化。
那么这样的架构就不够我们使用了，我们需要找寻某种方式，来实现读写分离。那么实际上有两种方式。
方法1：代码层实现读写分离 这种方法的优势就是比较灵活，我们可以按照自己的逻辑来决定读写分离的规则。如果使用了这样的方法，我们整个数据库的架构就可以用下面这张图进行概括：
方法2：使用中间层（虚拟节点）进行请求的转发 这种方式最主要的特点就是我们在除了数据库以外地方，新构建了一个虚拟节点，而我们所有的请求都发到这个虚拟节点上，由这个虚拟节点来转发读写请求该相应的数据库。
这种方式的特点就是，其构建了一个独立的节点来接收所有的请求，而不用在我们的程序中配置多数据源，我们的项目只需要将url指向这个虚拟节点，然后由这个虚拟节点来处理读写请求。不是有这么一句话吗，专业的事交给专业的人来做，大概是这么个意思吧。而现在存在的MyCat等中间件，就是这样的一个”专业的人“。
那么下面我就会动手实现上述两个读写分离的解决方案，代码层实现读写分离和使用中间件实现读写分离
手动实现读写分离 实现读写分离的方法有很多，我这里会说到两种，第一种是使用MyBatis和Spring，手写MyBatis拦截器来判断SQL是读或者写，从而选择数据源，最后交给Spring注入数据源，来实现读写分离；第二种是使用MyCat中间件，配置化地实现读写分离，每种方式都有其可取之处，可以自己视情况选用。
环境说明 这里用到了我的上篇博客手动搭建Redis集群和MySQL主从同步(非Docker)中所搭建的MySQL主从同步，如果手上没有这套环境的，可以先比着这篇博客进行搭建。但是需要注意的是，要将8.0版本的MySQL改为5.7。
192.168.43.201:3306 Master
192.168.43.202:3306 Slave
开发环境：
IDE:Eclipse
Spring boot 2.1.7
MySQL 5.7
CentOS 7.3
新建Maven项目 为了演示方便，这里使用SpringBoot作为测试的基础框架，省去了很多Spring需要的xml配置。没有用过SpringBoot的同学也没关系，我会一步一步地进行演示操作。
导入依赖 &lt;parent&gt;
&lt;groupId&gt;org.springframework.boot&lt;groupId&gt;
&lt;artifactId&gt;spring-boot-starter-parent&lt;artifactId&gt;
&lt;version&gt;2.1.7.RELEASE&lt;version&gt;
&lt;relativePath /&gt; &lt;parent&gt;
&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;groupId&gt;
&lt;artifactId&gt;spring-boot-starter-web&lt;artifactId&gt;
&lt;dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;com.oracle&lt;groupId&gt;
&lt;artifactId&gt;ojdbc7&lt;artifactId&gt;
&lt;version&gt;12.1.0&lt;version&gt;
&lt;dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.mybatis.spring.boot&lt;groupId&gt;
&lt;artifactId&gt;mybatis-spring-boot-starter&lt;artifactId&gt;
&lt;version&gt;2.0.0&lt;version&gt;
&lt;dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;mysql&lt;groupId&gt;
&lt;artifactId&gt;mysql-connector-java&lt;artifactId&gt;
&lt;dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;groupId&gt;
&lt;artifactId&gt;spring-boot-starter-test&lt;artifactId&gt;
&lt;dependency&gt;
&lt;dependency&gt;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5c50c94dbccadccfa5b81b8771613e96/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-06T08:30:00+08:00" />
<meta property="article:modified_time" content="2019-12-06T08:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">手把手教你实现 MySQL 读写分离 &#43; 故障转移</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align: center">公众号后台回复“<strong>学习</strong>”，免费获取精品学习资料</p> 
 <p style="text-align: center"><img width="750" src="https://images2.imgbox.com/2b/f9/akFwBkLc_o.png"></p> 
 <p style="text-align: center">扫描下方海报 <strong>试听</strong></p> 
 <p style="text-align: center"><img width="750" src="https://images2.imgbox.com/69/87/paHgSUbm_o.png"></p> 
 <p style="text-align: right">本文来源：Java知音</p> 
 <h3>前言</h3> 
 <p>上一篇发了<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ%3D%3D&amp;chksm=ebd6240fdca1ad19a363b3c0a917352f78ca4cdb20c79f639298ef731295bde3753fd55cf539&amp;idx=1&amp;mid=2247490339&amp;scene=21&amp;sn=355246186ce9cad69a8a4fe578141ffb#wechat_redirect" rel="nofollow">手动搭建Redis集群和MySQL主从同步(非Docker)</a>之后，很多同学对文中主从结构提到的读写分离感兴趣，本打算在双十一期间直接把读写分离分享给大家，奈何工作一直没停下，所以这周抽空把这些分享出来。</p> 
 <p>关于MySQL的读写分离的实现，有两种方式，第一种方式即我们<strong>手动在代码层实现逻辑，来解析读请求或者写请求，分别分发到不同的数据库中，实现读写分离</strong>；第二种方式就是<strong>基于MyCat中间件来实现读写分离的效果</strong>；这两种方式我都会在这篇博客中进行详细地介绍、搭建，并且分析其中的优劣。</p> 
 <hr> 
 <h3>原理初探</h3> 
 <p>从MySQL的主从同步开始谈起，最开始我们的数据库架构是这样的。</p> 
 <p><img width="444" src="https://images2.imgbox.com/e3/e1/ChwOXXge_o.png"></p> 
 <p>主库负责了所有的读写操作，而从库只对主库进行了备份，就像我在上一篇文章中说的那样，我认为如果只实现了一个备份，不能读写分离和故障转移，不能降低Master节点的IO压力，这样的主从架构看起来性价比似乎不是很高。</p> 
 <p>我们所希望的主从架构是，当我们在写数据时，请求全部发到Master节点上，当我们需要读数据时，请求全部发到Slave节点上。并且多个Slave节点最好可以存在负载均衡，让集群的效率最大化。</p> 
 <p>那么这样的架构就不够我们使用了，我们需要找寻某种方式，来实现读写分离。那么实际上有两种方式。</p> 
 <h4>方法1：代码层实现读写分离</h4> 
 <p>这种方法的优势就是比较灵活，我们可以按照自己的逻辑来决定读写分离的规则。如果使用了这样的方法，我们整个数据库的架构就可以用下面这张图进行概括：</p> 
 <p style="text-align: center"><img width="585" src="https://images2.imgbox.com/7c/6e/pRnkCAnK_o.png"></p> 
 <h4>方法2：使用中间层（虚拟节点）进行请求的转发</h4> 
 <p>这种方式最主要的特点就是我们在除了数据库以外地方，新构建了一个虚拟节点，而我们所有的请求都发到这个虚拟节点上，由这个虚拟节点来转发读写请求该相应的数据库。</p> 
 <p>这种方式的特点就是，其构建了一个独立的节点来接收所有的请求，而不用在我们的程序中配置多数据源，我们的项目只需要将url指向这个虚拟节点，然后由这个虚拟节点来处理读写请求。不是有这么一句话吗，<strong>专业的事交给专业的人来做</strong>，大概是这么个意思吧。而现在存在的MyCat等中间件，就是这样的一个”专业的人“。</p> 
 <p><img width="620" src="https://images2.imgbox.com/4d/6b/fEncOHOI_o.png"></p> 
 <p>那么下面我就会动手实现上述两个读写分离的解决方案，代码层实现读写分离和使用中间件实现读写分离</p> 
 <hr> 
 <h3>手动实现读写分离</h3> 
 <p>实现读写分离的方法有很多，我这里会说到两种，第一种是使用MyBatis和Spring，手写MyBatis拦截器来判断SQL是读或者写，从而选择数据源，最后交给Spring注入数据源，来实现读写分离；第二种是使用MyCat中间件，配置化地实现读写分离，每种方式都有其可取之处，可以自己视情况选用。</p> 
 <h4>环境说明</h4> 
 <p>这里用到了我的上篇博客<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ%3D%3D&amp;chksm=ebd6240fdca1ad19a363b3c0a917352f78ca4cdb20c79f639298ef731295bde3753fd55cf539&amp;idx=1&amp;mid=2247490339&amp;scene=21&amp;sn=355246186ce9cad69a8a4fe578141ffb#wechat_redirect" rel="nofollow">手动搭建Redis集群和MySQL主从同步(非Docker)</a>中所搭建的MySQL主从同步，如果手上没有这套环境的，可以先比着这篇博客进行搭建。但是需要注意的是，要将8.0版本的MySQL改为5.7。</p> 
 <blockquote> 
  <p>192.168.43.201:3306 Master<br>192.168.43.202:3306 Slave</p> 
 </blockquote> 
 <p>开发环境：</p> 
 <blockquote> 
  <p>IDE:Eclipse<br>Spring boot 2.1.7<br>MySQL 5.7<br>CentOS 7.3</p> 
 </blockquote> 
 <h4>新建Maven项目</h4> 
 <p>为了演示方便，这里使用SpringBoot作为测试的基础框架，省去了很多Spring需要的xml配置。没有用过SpringBoot的同学也没关系，我会一步一步地进行演示操作。</p> 
 <h4>导入依赖</h4> 
 <pre class="has"><code class="language-go"><code>&lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-parent&lt;artifactId&gt;<br>        &lt;version&gt;2.1.7.RELEASE&lt;version&gt;<br>        &lt;relativePath /&gt; <br>&lt;parent&gt;<br>&lt;dependencies&gt;<br>        <br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-web&lt;artifactId&gt;<br>        &lt;dependency&gt;<br>        <br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.oracle&lt;groupId&gt;<br>            &lt;artifactId&gt;ojdbc7&lt;artifactId&gt;<br>            &lt;version&gt;12.1.0&lt;version&gt;<br>        &lt;dependency&gt;<br>        <br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.mybatis.spring.boot&lt;groupId&gt;<br>            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;artifactId&gt;<br>            &lt;version&gt;2.0.0&lt;version&gt;<br>        &lt;dependency&gt;<br>        <br>        &lt;dependency&gt;<br>            &lt;groupId&gt;mysql&lt;groupId&gt;<br>            &lt;artifactId&gt;mysql-connector-java&lt;artifactId&gt;<br>        &lt;dependency&gt;<br>        <br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-test&lt;artifactId&gt;<br>        &lt;dependency&gt;<br>        <br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;groupId&gt;<br>            &lt;artifactId&gt;<br>                spring-boot-configuration-processor<br>            &lt;artifactId&gt;<br>            &lt;optional&gt;true&lt;optional&gt;<br>        &lt;dependency&gt;<br>&lt;dependencies&gt;<br></code></code></pre> 
 <h4>application.yml</h4> 
 <p>为了测试项目尽量简单，所以我们不用去过多地配置其它东西。只有一些基本配置和数据源配置。</p> 
 <pre class="has"><code class="language-go"><code>server: <br>  port: 10001<br>spring: <br>  datasource:<br>    url: jdbc:mysql://192.168.43.201:3306/springtestdemo?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC<br>    username: Object<br>    password: Object971103.<br>    driver-class-name: com.mysql.cj.jdbc.Driver<br><br>#MyBatis配置<br>mybatis:<br>  mapper-locations: classpath:mapper/*.xml<br>  configuration:<br>    map-underscore-to-camel-case: true<br></code></code></pre> 
 <h4>编写启动类</h4> 
 <pre class="has"><code class="language-go"><code>@SpringBootApplication<br>public class ApplicationStarter {<!-- --><br>    public static void main(String[] args) {<!-- --><br>        SpringApplication.run(ApplicationStarter.class, args);<br>    }<br>}<br></code></code></pre> 
 <h4>启动</h4> 
 <p><img width="1435" src="https://images2.imgbox.com/35/04/V7WB1i8b_o.png"></p> 
 <p>出现以上信息代表启动成功。嗯……这应该是一个数据库相关的博客，好像讲了太多的SpringBoot</p> 
 <p>到这里说明我们的SpringBoot项目没有问题，已经搭建成功，如果还不放心，可以自行访问一下http://localhost:10001这个路径，如果出现SpringBoot的404，则代表启动成功。</p> 
 <h4>新建Student实体并创建数据库</h4> 
 <pre class="has"><code class="language-php"><p>package cn.objectspace.springtestdemo.domain;<br>public class Student {<!-- --><br>    private String studentId;<br>    private String studentName;<br>    public String getStudentId() {<!-- --><br>        return studentId;<br>    }<br>    public void setStudentId(String studentId) {<!-- --><br>        this.studentId = studentId;<br>    }<br>    public String getStudentName() {<!-- --><br>        return studentName;<br>    }<br>    public void setStudentName(String studentName) {<!-- --><br>        this.studentName = studentName;<br>    }   <br>}<br></p></code></pre> 
 <pre class="has"><code class="language-php"><p>CREATE TABLE student(<br>    student_id VARCHAR(32),<br>    student_name VARCHAR(32)<br>);<br></p></code></pre> 
 <h4>编写StudentDao接口，并进行测试</h4> 
 <p>接口：</p> 
 <pre class="has"><code class="language-php"><p>package cn.objectspace.springtestdemo.dao;<br><br>import org.apache.ibatis.annotations.Insert;<br>import org.apache.ibatis.annotations.Mapper;<br>import org.apache.ibatis.annotations.Select;<br><br>import cn.objectspace.springtestdemo.domain.Student;<br><br>@Mapper<br>public interface StudentDao {<!-- --><br>    @Insert("INSERT INTO student(student_id,student_name)VALUES(#{studentId},#{studentName})")<br>    public Integer insertStudent(Student student);<br>    @Select("SELECT * FROM student WHERE student_id = #{studentId}")<br>    public Student queryStudentByStudentId(Student student);<br>}<br></p></code></pre> 
 <p>测试类：</p> 
 <pre class="has"><code class="language-php"><p>@RunWith(SpringRunner.class)<br>@SpringBootTest(classes = {ApplicationStarter.class})// 指定启动类<br>public class DaoTest {<!-- --><br>    @Autowired StudentDao studentDao;<br>    @Test<br>    public void test01() {<!-- --><br>        Student student = new Student();<br>        student.setStudentId("20191130");<br>        student.setStudentName("Object6");<br>        studentDao.insertStudent(student);<br>        studentDao.queryStudentByStudentId(student);<br>    }<br>}<br></p></code></pre> 
 <p>如果可以正确往数据库中插入数据，如下图，则MyBatis搭建成功。</p> 
 <p><img width="364" src="https://images2.imgbox.com/b4/12/MJYi8D7s_o.png"></p> 
 <h4>正式搭建</h4> 
 <p>通过上面的准备工作，我们已经可以实现对数据库的读写，但是并没有实现读写分离，现在才是开始实现数据库的读写分离。</p> 
 <h4>修改application.yml</h4> 
 <p>刚才我们的配置文件中只有单数据源，而读写分离肯定不会是单数据源，所以我们首先要在application.yml中配置多数据源。</p> 
 <pre class="has"><code class="language-php"><p>server: <br>  port: 10001<br>spring: <br>  datasource:<br>    master: <br>      url: jdbc:mysql://192.168.43.201:3306/springtestdemo?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC<br>      username: Object<br>      password: Object971103.<br>      driver-class-name: com.mysql.cj.jdbc.Driver<br>    slave: <br>      url: jdbc:mysql://192.168.43.202:3306/springtestdemo?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC<br>      username: Object<br>      password: Object971103.<br>      driver-class-name: com.mysql.cj.jdbc.Driver<br><br><br>#MyBatis配置<br>mybatis:<br>  mapper-locations: classpath:mapper/*.xml<br>  configuration:<br>    cache-enabled: true #开启二级缓存<br>    map-underscore-to-camel-case: true<br></p></code></pre> 
 <h4>DataSource的配置</h4> 
 <p>首先要先创建两个ConfigurationProperties类，这一步不是非必须的，直接配置DataSource也是可以的，但是我还是比较习惯去写这个Properties。</p> 
 <h5>MasterProperpties</h5> 
 <pre class="has"><code class="language-php"><p>package cn.objectspace.springtestdemo.config;<br><br>import org.springframework.boot.context.properties.ConfigurationProperties;<br>import org.springframework.stereotype.Component;<br><br>@ConfigurationProperties(prefix = "spring.datasource.master")<br>@Component<br>public class MasterProperties {<!-- --><br>    private String url;<br>    private String username;<br>    private String password;<br>    private String driverClassName;<br>    public String getUrl() {<!-- --><br>        return url;<br>    }<br>    public void setUrl(String url) {<!-- --><br>        this.url = url;<br>    }<br>    public String getUsername() {<!-- --><br>        return username;<br>    }<br>    public void setUsername(String username) {<!-- --><br>        this.username = username;<br>    }<br>    public String getPassword() {<!-- --><br>        return password;<br>    }<br>    public void setPassword(String password) {<!-- --><br>        this.password = password;<br>    }<br>    public String getDriverClassName() {<!-- --><br>        return driverClassName;<br>    }<br>    public void setDriverClassName(String driverClassName) {<!-- --><br>        this.driverClassName = driverClassName;<br>    }<br><br>}<br></p></code></pre> 
 <h5>SlaveProperties</h5> 
 <pre class="has"><code class="language-php"><p>package cn.objectspace.springtestdemo.config;<br><br>import org.springframework.boot.context.properties.ConfigurationProperties;<br>import org.springframework.stereotype.Component;<br><br>@ConfigurationProperties(prefix = "spring.datasource.slave")<br>@Component<br>public class SlaveProperties {<!-- --><br>    private String url;<br>    private String username;<br>    private String password;<br>    private String driverClassName;<br>    public String getUrl() {<!-- --><br>        return url;<br>    }<br>    public void setUrl(String url) {<!-- --><br>        this.url = url;<br>    }<br>    public String getUsername() {<!-- --><br>        return username;<br>    }<br>    public void setUsername(String username) {<!-- --><br>        this.username = username;<br>    }<br>    public String getPassword() {<!-- --><br>        return password;<br>    }<br>    public void setPassword(String password) {<!-- --><br>        this.password = password;<br>    }<br>    public String getDriverClassName() {<!-- --><br>        return driverClassName;<br>    }<br>    public void setDriverClassName(String driverClassName) {<!-- --><br>        this.driverClassName = driverClassName;<br>    }<br><br>}<br></p></code></pre> 
 <h5>DataSourceConfig</h5> 
 <p>这个配置主要是对主从数据源进行配置。</p> 
 <pre class="has"><code class="language-php"><p>@Configuration<br>public class DataSourceConfig {<!-- --><br>    private Logger logger = LoggerFactory.getLogger(DataSourceConfig.class);<br>    @Autowired<br>    private MasterProperties masterProperties;<br><br>    @Autowired<br>    private SlaveProperties slaveProperties;<br><br>    //默认是master数据源<br>    @Bean(name = "masterDataSource")<br>    @Primary<br>    public DataSource masterProperties(){<!-- --><br>        logger.info("masterDataSource初始化");<br>        HikariDataSource dataSource = new HikariDataSource();<br>        dataSource.setJdbcUrl(masterProperties.getUrl());<br>        dataSource.setUsername(masterProperties.getUsername());<br>        dataSource.setPassword(masterProperties.getPassword());<br>        dataSource.setDriverClassName(masterProperties.getDriverClassName());<br>        return dataSource;<br>    }<br><br>    @Bean(name = "slaveDataSource")<br>    public DataSource dataBase2DataSource(){<!-- --><br>        logger.info("slaveDataSource初始化");<br>        HikariDataSource dataSource = new HikariDataSource();<br>        dataSource.setJdbcUrl(slaveProperties.getUrl());<br>        dataSource.setUsername(slaveProperties.getUsername());<br>        dataSource.setPassword(slaveProperties.getPassword());<br>        dataSource.setDriverClassName(slaveProperties.getDriverClassName());<br>        return dataSource;<br>    }<br>}<br></p></code></pre> 
 <h4>动态数据源的切换</h4> 
 <p>这里使用到的主要是Spring提供的AbstractRoutingDataSource，其提供了动态数据源的功能，可以帮助我们实现读写分离。其determineCurrentLookupKey()可以决定最终使用哪个数据源，这里我们自己创建了一个DynamicDataSourceHolder，来给他传一个数据源的类型（主、从）。</p> 
 <pre class="has"><code class="language-php"><p>package cn.objectspace.springtestdemo.dao.split;<br><br>import java.util.HashMap;<br>import java.util.Map;<br><br>import javax.annotation.Resource;<br>import javax.sql.DataSource;<br><br>import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;<br>/**<br> * <br>* @Description: spring提供了AbstractRoutingDataSource，提供了动态选择数据源的功能，替换原有的单一数据源后，即可实现读写分离:<br>* @Author: Object<br>* @Date: 2019年11月30日<br> */<br>public class DynamicDataSource extends AbstractRoutingDataSource{<!-- --><br>    //注入主从数据源<br>    @Resource(name="masterDataSource")<br>    private DataSource masterDataSource;<br>    @Resource(name="slaveDataSource")<br>    private DataSource slaveDataSource;<br>    @Override<br>    public void afterPropertiesSet() {<!-- --><br>        setDefaultTargetDataSource(masterDataSource);<br>        Map</p></code></pre> 
 <h4>DynamicDataSourceHolder的实现</h4> 
 <p>这个类由我们自己实现，主要是提供给Spring我们需要用到的数据源类型。</p> 
 <pre class="has"><code class="language-php"><p>package cn.objectspace.springtestdemo.dao.split;<br><br>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;<br><br>/**<br>* @Description: 获取DataSource<br>* @Author: Object<br>* @Date: 2019年11月30日<br>*/<br>public class DynamicDataSourceHolder {<!-- --><br>    private static Logger logger = LoggerFactory.getLogger(DynamicDataSourceHolder.class);<br>    private static ThreadLocal contextHolder = new ThreadLocal&lt;&gt;();<br>    public static final String DB_MASTER = "master";<br>    public static final String DB_SLAVE="slave";<br>    /**<br>     * @Description: 获取线程的DbType<br>     * @Param: args<br>     * @return: String<br>     * @Author: Object<br>     * @Date: 2019年11月30日<br>     */<br>    public static String getDbType() {<!-- --><br>        String db = contextHolder.get();<br>        if(db==null) {<!-- --><br>            db = "master";<br>        }<br>        return db;<br>    }<br>    /**<br>     * @Description: 设置线程的DbType<br>     * @Param: args<br>     * @return: void<br>     * @Author: Object<br>     * @Date: 2019年11月30日<br>     */<br>    public static void setDbType(String str) {<!-- --><br>        logger.info("所使用的数据源为:"+str);<br>        contextHolder.set(str);<br>    }<br><br>    /**<br>     * @Description: 清理连接类型<br>     * @Param: args<br>     * @return: void<br>     * @Author: Object<br>     * @Date: 2019年11月30日<br>     */<br>    public static void clearDbType() {<!-- --><br>        contextHolder.remove();<br>    }<br>}<br></p></code></pre> 
 <h4>MyBatis拦截器的实现</h4> 
 <p>最后就是我们实现读写分离的核心了，这个类可以对SQL进行判断，是读SQL还是写SQL，从而进行数据源的选择，最终调用DynamicDataSourceHolder的setDbType方法，将数据源类型传入。</p> 
 <pre class="has"><code class="language-php"><p>package cn.objectspace.springtestdemo.dao.split;<br><br>import java.util.Locale;<br>import java.util.Properties;<br><br>import org.apache.ibatis.executor.Executor;<br>import org.apache.ibatis.executor.keygen.SelectKeyGenerator;<br>import org.apache.ibatis.mapping.BoundSql;<br>import org.apache.ibatis.mapping.MappedStatement;<br>import org.apache.ibatis.mapping.SqlCommandType;<br>import org.apache.ibatis.plugin.Interceptor;<br>import org.apache.ibatis.plugin.Intercepts;<br>import org.apache.ibatis.plugin.Invocation;<br>import org.apache.ibatis.plugin.Plugin;<br>import org.apache.ibatis.plugin.Signature;<br>import org.apache.ibatis.session.ResultHandler;<br>import org.apache.ibatis.session.RowBounds;<br>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;<br>import org.springframework.stereotype.Component;<br>import org.springframework.transaction.support.TransactionSynchronizationManager;<br><br>/**<br> * @Description: MyBatis级别拦截器，根据SQL信息，选择不同的数据源<br> * @Author: Object<br> * @Date: 2019年11月30日<br> */<br>@Intercepts({ <br>    @Signature(type = Executor.class, method = "update", args = { MappedStatement.class, Object.class }),<br>    @Signature(type = Executor.class, method = "query", args = { MappedStatement.class, Object.class,RowBounds.class, ResultHandler.class })<br>    })<br>@Component<br>public class DynamicDataSourceInterceptor implements Interceptor {<!-- --><br>    private Logger logger = LoggerFactory.getLogger(DynamicDataSourceInterceptor.class);<br>    // 验证是否为写SQL的正则表达式<br>    private static final String REGEX = ".*insert\\u0020.*|.*delete\\u0020.*|.*update\\u0020.*";<br><br>    /**<br>     * 主要的拦截方法<br>     */<br>    @Override<br>    public Object intercept(Invocation invocation) throws Throwable {<!-- --><br>        // 判断当前是否被事务管理<br>        boolean synchronizationActive = TransactionSynchronizationManager.isActualTransactionActive();<br>        String lookupKey = DynamicDataSourceHolder.DB_MASTER;<br>        if (!synchronizationActive) {<!-- --><br>            //如果是非事务的，则再判断是读或者写。<br>            // 获取SQL中的参数<br>            Object[] objects = invocation.getArgs();<br>            // object[0]会携带增删改查的信息，可以判断是读或者是写<br>            MappedStatement ms = (MappedStatement) objects[0];<br>            // 如果为读，且为自增id查询主键，则使用主库<br>            // 这种判断主要用于插入时返回ID的操作，由于日志同步到从库有延时<br>            // 所以如果插入时需要返回id，则不适用于到从库查询数据，有可能查询不到<br>            if (ms.getSqlCommandType().equals(SqlCommandType.SELECT)<br>                    &amp;&amp; ms.getId().contains(SelectKeyGenerator.SELECT_KEY_SUFFIX)) {<!-- --><br>                lookupKey = DynamicDataSourceHolder.DB_MASTER;<br>            } else {<!-- --><br>                BoundSql boundSql = ms.getSqlSource().getBoundSql(objects[1]);<br>                String sql = boundSql.getSql().toLowerCase(Locale.CHINA).replaceAll("[\\t\\n\\r]", " ");<br>                // 正则验证<br>                if (sql.matches(REGEX)) {<!-- --><br>                    // 如果是写语句<br>                    lookupKey = DynamicDataSourceHolder.DB_MASTER;<br>                } else {<!-- --><br>                    lookupKey = DynamicDataSourceHolder.DB_SLAVE;<br>                }<br>            }<br>        } else {<!-- --><br>            // 如果是通过事务管理的，一般都是写语句,直接通过主库<br>            lookupKey = DynamicDataSourceHolder.DB_MASTER;<br>        }<br><br>        logger.info("在" + lookupKey + "中进行操作");<br>        DynamicDataSourceHolder.setDbType(lookupKey);<br>        // 最后直接执行SQL<br>        return invocation.proceed();<br>    }<br><br>    /**<br>     * 返回封装好的对象，或代理对象<br>     */<br>    @Override<br>    public Object plugin(Object target) {<!-- --><br>        // 如果存在增删改查，则直接拦截下来，否则直接返回<br>        if (target instanceof Executor)<br>            return Plugin.wrap(target, this);<br>        else<br>            return target;<br>    }<br><br>    /**<br>     * 类初始化的时候做一些相关的设置<br>     */<br>    @Override<br>    public void setProperties(Properties properties) {<!-- --><br>        // TODO Auto-generated method stub<br>    }<br>}<br></p></code></pre> 
 <h4>代码梳理</h4> 
 <p>通过上文中的程序，我们已经可以实现读写分离了，但是这么看着还是挺乱的。所以在这里重新梳理一遍上文中的代码。</p> 
 <p>其实逻辑并不难：</p> 
 <ul><li><p>通过<code>@Configuration</code>实现多数据源的配置。</p></li><li><p>通过MyBatis的拦截器，DynamicDataSourceInterceptor来判断某条SQL语句是读还是写，如果是读，则调用<code>DynamicDataSourceHolder.setDbType("slave")</code>，否则调用<code>DynamicDataSourceHolder.setDbType("master")</code>。</p></li><li><p>通过AbstractRoutingDataSource的<code>determineCurrentLookupKey()</code>方法，返回<code>DynamicDataSourceHolder.getDbType();</code>也就是我们在拦截器中设置的数据源。</p></li><li><p>对注入的数据源执行SQL。</p></li></ul> 
 <h4>测试</h4> 
 <pre class="has"><code class="language-php"><p>@RunWith(SpringRunner.class)<br>@SpringBootTest(classes = {ApplicationStarter.class})// 指定启动类<br>public class DaoTest {<!-- --><br>    @Autowired StudentDao studentDao;<br>    @Test<br>    public void test01() {<!-- --><br>        Student student = new Student();<br>        student.setStudentId("20191130");<br>        student.setStudentName("Object6");<br>        studentDao.insertStudent(student);<br>        studentDao.queryStudentByStudentId(student);<br>    }<br>}<br></p></code></pre> 
 <p>测试结果：</p> 
 <p><img width="652" src="https://images2.imgbox.com/a6/49/5Hc8SeIK_o.png"></p> 
 <p>至此，代码层读写分离已完整地实现。</p> 
 <hr> 
 <h3>基于MyCat中间件实现读写分离、故障转移</h3> 
 <h4>简介</h4> 
 <p>在上文中我们已经实现了使用手写代码的方式对数据库进行读写分离，但是不知道大家发现了没有，我只使用了一主一从。那么<strong>为什么我有一主二从的环境却只实现一主一从的读写分离呢？</strong><strong>因为，在代码层实现一主多从的读写分离我也不会写。</strong><strong>那么假设数据库集群不止于一主二从，而是一主三从，一主四从，多主多从呢？</strong><strong>如果Master节点宕机了，又该怎么处理？</strong></p> 
 <p>每次动态增加一个节点，我们就要重新修改我们的代码，这不但会给开发人员造成很大的负担，而且不符合开闭原则。</p> 
 <p>所以接下来的MyCat应该可以解决这样的问题。并且我会直接使用一主二从的环境演示。</p> 
 <h4>MyCat介绍</h4> 
 <p>这里直接套官方文档。</p> 
 <blockquote> 
  <ul><li><p>一个彻底开源的，面向企业应用开发的大数据库集群</p></li><li><p>支持事务、ACID、可以替代MySQL的加强版数据库</p></li><li><p>一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群</p></li><li><p>一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server</p></li><li><p>结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品</p></li><li><p>一个新颖的数据库中间件产品</p></li></ul> 
 </blockquote> 
 <h4>环境说明</h4> 
 <blockquote> 
  <p>MyCat 192.168.43.90<br>MySQL master 192.168.43.201<br>MySQL slave1 192.168.43.202<br>MySQL slave2 192.168.43.203</p> 
 </blockquote> 
 <p>接上篇博客的MySQL数据库一主二从，不过<strong>MySQL版本需要从8.0改为5.7</strong>，否则会出现密码问题无法连接。</p> 
 <p><strong>另外，我们需要在每个数据库中都为MyCat创建一个账号并赋上权限：</strong></p> 
 <pre class="has"><code class="language-php"><p>CREATE USER  'user_name'@'host'  IDENTIFIED BY  'password';<br>GRANT privileges ON  databasename.tablename  TO  ‘username’@‘host’;<br>--可以使用下面这句 赋予所有权限<br>GRANT ALL PRIVILEGES ON *.* TO  ‘username’@‘host’;<br>--最后刷新权限<br>FLUSH PRIVILEGES;<br></p></code></pre> 
 <p>在开始之前，先保证主从库的搭建是成功的：</p> 
 <p><img width="1594" src="https://images2.imgbox.com/6e/90/vUVWgdra_o.png"></p> 
 <p>如何安装MyCat在这里我就不说了，百度上有很多帖子有，按照上面的教程一步一步来其实没有多大问题。我们着重说说和我们MyCat配置相关的两个配置文件——schema.xml和server.xml，当然还有一个rules.xml，但是这里暂时不介绍分库分表，所以这个暂且不提。</p> 
 <h4>配置文件说明</h4> 
 <h5>server.xml</h5> 
 <p>打开mycat安装目录下的/conf/server.xml文件，这个配置文件比较长，看着比较费脑，但其实对于初学者来说，我们需要配置的地方并不多，所以不用太害怕这种长篇幅的配置文件。（其实在上一篇文章的结尾，我也说过，面对一个新技术的时候首先不能懵逼，一步一步地去分析并接受他，扯远了）配置文件简化之后大概是这样的一个结构。</p> 
 <pre class="has"><code class="language-go"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>&lt;!DOCTYPE mycat:server SYSTEM "server.dtd"&gt;<br>&lt;mycat:server xmlns:mycat="http://io.mycat/"&gt;<br>    &lt;system&gt;<br>    &lt;/system&gt;<br>    &lt;user name="MyCat" defaultAccount="true"&gt;<br>    &lt;/user&gt;<br><br>&lt;/mycat:server&gt;</code></code></pre> 
 <p>这样看起来是不是简单多了，其实对于Server.xml，我们主要配置的就是下面的user模块，我们把它展开，着重讲讲这部分的配置。</p> 
 <pre class="has"><code class="language-go"><code>&lt;user name="这里写MyCat的用户名 可以自定义" defaultAccount="true"&gt;<br>   &lt;property name="password"&gt;这里写MyCat的密码&lt;/property&gt;<br>   &lt;property name="schemas"&gt;这里配置MyCat的虚拟database&lt;/property&gt;<br>            &lt;!-- 表级 DML 权限设置 --&gt;<br>            &lt;!--<br>                这里是我们配置的mycat用户对某张表的权限配置，我们这里暂不配置但是还是说一                 下。下文中的0000 1111 每一位 代表CRUD  1111就是有增删改查的权限，0000就                是没有这些权限。以此类推<br>            &lt;privileges check="false"&gt;<br>                    &lt;schema name="TESTDB" dml="0110" &gt;<br>                            &lt;table name="tb01" dml="0000"&gt;&lt;/table&gt;<br>                            &lt;table name="tb02" dml="1111"&gt;&lt;/table&gt;<br>                    &lt;/schema&gt;<br>            &lt;/privileges&gt;<br>             --&gt;<br>&lt;/user&gt;</code></code></pre> 
 <p>user代表MyCat的用户，我们在使用MySQL的时候都会有一个用户，<strong>MyCat作为一个虚拟节点，我们可以把它想象成它就是一个MySQL</strong>，所以自然而然它也需要有一个用户。但是他的用户并不是我们用命令创建的，而是直接在配置文件中配置好的，我们之后登录MyCat，就是用这里的用户名和密码进行登录。至于如何配置，我在上面的配置中都写好啦。跟着做就没有问题。</p> 
 <h5>schema.xml</h5> 
 <p>打开MyCat安装目录的conf/<strong>schema.xml，这个配置文件是我们需要关注的一个配置文件</strong>，因为我们的读写分离、分库分表、故障转移、都配置在这个配置文件中。但是这个配置文件并不长，我们可以一点一点慢慢分析。</p> 
 <p>首先是<code></code>标签中的内容。这个标签主要是为MyCat虚拟出一个数据库，我们连接到MyCat上能看到的数据库就是这里配置的,而<strong>分库分表也主要在这个标签中进行配置</strong>。</p> 
 <p>这个标签中的name属性，就是为虚拟数据库指定一个名字，也是我们连接MyCat看到的数据库的库名，dataNode是和下文的dataNode标签中的name相对应的，代表这个虚拟的数据库和下面的dataNode进行绑定。</p> 
 <pre class="has"><code class="language-go"><code>&lt;schema name="MyCatDatabase" checkSQLschema="false" sqlMaxLimit="100" dataNode="这里写节点名，需要和dataNode中的name相对应"&gt;<br>    &lt;!-- 分库分表 --&gt;<br>        &lt;!--&lt;table name="travelrecord" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" /&gt;--&gt;<br>&lt;/schema&gt;</code></code></pre> 
 <p>第二个标签是<code></code>标签，这个标签是和我们真实数据库中的database联系起来的，name属性是我们对这个dataNode自定义的一个名字，要注意的是，这个名字需要和schema标签中的dataNode内容一致，database属性写的是我们真实数据库中的真实database的名字。而dataHost的内容需要和之后<code></code>标签中的name属性的值相对应。</p> 
 <pre class="has"><code class="language-go"><code>&lt;dataNode name="这里写节点名，需要和schema中的dataNode相对应" dataHost="这里也是一个自定义名字，需要和dataHost中的name相对应" database="这里填MySQL真实的数据库名" /&gt;</code></code></pre> 
 <p>第三个标签要说的是<code></code>标签，这个标签是和我们真实数据库的主从、读写分离联系起来的标签，什么意思呢。这个标签中有这么两个子标签<code></code>和<code></code>分别代表我们的写库和读库，<code></code>中配置的库可以用于读或者写，而<code></code>中配置的库只能用于读。</p> 
 <p>可以看到schema.xml的配置是一环扣一环的，每个标签之间都有相互进行联系的属性。我们最后配置完的schema.xml应该长下面这个样子：</p> 
 <pre class="has"><code class="language-go"><code>&lt;?xml version="1.0"?&gt;<br>&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;<br>&lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt;<br>    &lt;schema name="这里写虚拟database名，需要和server.xml中的schema相对应" checkSQLschema="false" sqlMaxLimit="100" dataNode="这里写节点名，需要和dataNode中的name相对应"&gt;<br>    &lt;!-- 分库分表 --&gt;<br>        &lt;!--&lt;table name="travelrecord" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" /&gt;--&gt;<br>    &lt;/schema&gt;<br>        &lt;dataNode name="这里写节点名，需要和schema中的dataNode相对应" dataHost="这里也是一个自定义名字，需要和dataHost中的name相对应" database="这里填MySQL真实的数据库名" /&gt;<br>        &lt;dataHost name="这里写和dataNode中的dataHost相同的名字" maxCon="1000" minCon="10" balance="1" writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100"&gt;<br>            &lt;!-- 心跳语句，证明myCat和mySQL是相互连接的状态--&gt;<br>            &lt;heartbeat&gt;show slave status&lt;/heartbeat&gt;<br>            &lt;!-- 读写分离 --&gt;<br>            &lt;writeHost host="节点的名字，随便取" url="数据库的url（IP:PORT）" user="数据库中给MyCat创建的用户名" password="数据库中给MyCat创建的密码"&gt;<br>                &lt;readHost host="节点的名字，随便取" url="数据库的url（IP:PORT）" user="数据库中给MyCat创建的用户名" password="数据库中给MyCat创建的密码"&gt;<br>                &lt;/readHost&gt;<br>                &lt;readHost host="节点的名字，随便取" url="数据库的url（IP:PORT）" user="数据库中给MyCat创建的用户名" password="数据库中给MyCat创建的密码"&gt;<br>                &lt;/readHost&gt;<br>            &lt;/writeHost&gt;<br>            &lt;!-- 主从切换 --&gt;<br>            &lt;writeHost host="节点的名字，随便取" url="数据库的url（IP:PORT）" user="数据库中给MyCat创建的用户名" password="数据库中给MyCat创建的密码"&gt;&lt;/writeHost&gt;<br>            &lt;writeHost host="节点的名字，随便取" url="数据库的url（IP:PORT）" user="数据库中给MyCat创建的用户名" password="数据库中给MyCat创建的密码"&gt;&lt;/writeHost&gt;<br>        &lt;/dataHost&gt;<br>&lt;/mycat:schema&gt;</code></code></pre> 
 <h4>MyCat配置读写分离</h4> 
 <p>上文中我们对MyCat的两个配置文件进行了基本的解读，那么现在就开始搭建一个基于MyCat的读写分离。我这里有三个数据库，一主二从，再说一遍环境吧：</p> 
 <blockquote> 
  <p>192.168.43.201 master库<br>192.168.43.202 slave库<br>192.168.43.203 slave库</p> 
 </blockquote> 
 <p>那么对于server.xml和schema.xml的配置如下：</p> 
 <h5>server.xml:</h5> 
 <pre class="has"><code class="language-go"><code>&lt;user name="MyCat" defaultAccount="true"&gt;<br>    &lt;property name="password"&gt;123456&lt;/property&gt;<br>    &lt;property name="schemas"&gt;MyCat&lt;/property&gt;<br>&lt;/user&gt;</code></code></pre> 
 <h5>schema.xml:</h5> 
 <pre class="has"><code class="language-go"><code>&lt;?xml version="1.0"?&gt;<br>&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;<br>&lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt;<br>        &lt;schema name="MyCat" checkSQLschema="false" sqlMaxLimit="100" dataNode="mycatdb"&gt;&lt;/schema&gt;<br>        &lt;!-- testcluster是我真实数据库中的名字 --&gt;<br>        &lt;dataNode name="mycatdb" dataHost="mycluster" database="testcluster" /&gt;<br>        &lt;!-- 开启读写分离必须将balance修改为1--&gt;<br>        &lt;dataHost name="mycluster" maxCon="1000" minCon="10" balance="1"<br>                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100"&gt;<br>                &lt;heartbeat&gt;show slave status&lt;/heartbeat&gt;<br>                &lt;!-- 读写分离 --&gt;<br>                &lt;writeHost host="Master201" url="192.168.43.201:3306" user="MyCat" password="123456"&gt;<br>                    &lt;readHost host="Slave202" url="192.168.43.202:3306" user="MyCat" password="123456"&gt;<br>                    &lt;/readHost&gt;<br>                    &lt;readHost host="Slave203" url="192.168.43.203:3306" user="MyCat" password="123456"&gt;<br>                    &lt;/readHost&gt;<br>                &lt;/writeHost&gt;<br>        &lt;/dataHost&gt;<br>&lt;/mycat:schema&gt;</code></code></pre> 
 <p><strong>启动MyCat并测试:</strong><br></p> 
 <p>启动MyCat:</p> 
 <p><code>./mycat start</code></p> 
 <p>连接MyCat:</p> 
 <p><code>mysql -u MyCat -h 192.168.43.90 -P 8066 -p</code></p> 
 <p><img width="512" src="https://images2.imgbox.com/0f/71/DGAHc6dT_o.png"></p> 
 <p>可以正确看到MyCat中存在一个数据库，名字叫MyCat，而这个数据库是我们虚拟出来的，并不真实存在，实际上就是我们配置的<code></code>起了作用。</p> 
 <p><strong>在MyCat库中创建一张表</strong></p> 
 <p><code>CREATE TABLE student(student_id VARCHAR(32),student_name VARCHAR(32));</code></p> 
 <p><img width="471" src="https://images2.imgbox.com/58/cd/da0LnG3G_o.png"></p> 
 <p><img width="606" src="https://images2.imgbox.com/36/66/3kH2xv57_o.png"></p> 
 <p>这样就可以证明我们的mycat连接真实数据库成功。那么我们下面就要开始证明读写分离，何谓读写分离呢？就是读数据操作从从库中读取，而主库只负责写操作，下面我们开始进行验证。</p> 
 <p>在验证之前，我们需要将MyCat的日志设置为debug模式，因为在info模式下，是不能在日志中显示SQL语句转发到哪一个数据库中进行查询的。</p> 
 <h5>如何设置：</h5> 
 <p>打开conf/log4j2.xml</p> 
 <p><img width="1048" src="https://images2.imgbox.com/f3/f1/QSiV3Pho_o.png"></p> 
 <p>执行一条插入语句：</p> 
 <p><code>INSERT INTO student(student_id,student_name) VALUES('20191130','Object');</code></p> 
 <p style="text-align: left"><img width="485" src="https://images2.imgbox.com/17/13/DrfiZxZH_o.png"></p> 
 <p>查看日志：<br></p> 
 <p style="text-align: center"><img width="1703" src="https://images2.imgbox.com/9e/c7/FPhxDwcC_o.png"></p> 
 <p>可以看到，INSERT语句是在201中写入的，201是Master库，也就是写库。</p> 
 <p>写在我们来执行一条读语句：</p> 
 <p><code>SELECT * FROM student;</code></p> 
 <p style="text-align: center"><img width="1711" src="https://images2.imgbox.com/ba/48/SGSICPwt_o.png"></p> 
 <p>可以看到，SELECT 语句是在202中执行的，202是Slave库，也就是读库。<br></p> 
 <p>再执行一次：</p> 
 <p style="text-align: center"><img width="1695" src="https://images2.imgbox.com/cd/a4/ZVwmI0Mn_o.png"></p> 
 <p>这个时候读语句在203中执行，还是读库,<strong>这两个读库是基于负载均衡规则来进行读取的。</strong></p> 
 <p>这样就完成了读写分离的配置，当我们需要进行INSERT/UPDATE/DELETE时，会直接到Master中进行写入，然后同步到Slave库，而要进行SELECT操作时，就改为去Slave中读，不影响Master的写入，<strong>这种读写分离，拓展了MySQL主从同步的功能，可以在容灾备份的同时，提升数据库的性能。</strong></p> 
 <h4>MyCat配置故障转移</h4> 
 <p>我们在上文中已经完成了MyCat关于读写分离的配置，那么我们大胆假设，假如我们的Master数据库突然宕机了，那么是否整个集群就丧失了写功能呢？</p> 
 <p>在没有故障转移之前，这个答案是肯定的，当主库宕机时，从库作为读库，是不会有写的功能的，整个集群也就丧失了写的功能，这是我们不希望看到的。</p> 
 <p>我们希望看到的场景是：当<strong>主库宕机，某一个从库自动变为主库，承担写的功能，保证整个集群的可用性。</strong></p> 
 <p>那么我们开始进行配置，其实思路很简单，MyCat的标签中有一个switchType属性，其决定了切换的条件。</p> 
 <p>switchType指的是切换的模式，目前的取值也有4种：</p> 
 <blockquote> 
  <ul><li><p>switchType='-1' 表示不自动切换</p></li><li><p>switchType='1' 默认值，表示自动切换</p></li><li><p>switchType='2' 基于MySQL主从同步的状态决定是否切换,心跳语句为 show slave status</p></li><li><p>switchType='3'基于MySQL galary cluster的切换机制（适合集群）（1.4.1），心跳语句为 show status like 'wsrep%'。</p></li></ul> 
 </blockquote> 
 <p>我们直接将switchType修改为2，然后将两个读库配置为第一个写库同级的写库。</p> 
 <p>配置文件如下:</p> 
 <pre class="has"><code class="language-go"><code>&lt;?xml version="1.0"?&gt;<br>&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;<br>&lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt;<br>    &lt;schema name="MyCat" checkSQLschema="false" sqlMaxLimit="100" dataNode="mycatdb"&gt;<br>    &lt;/schema&gt;<br>    &lt;dataNode name="mycatdb" dataHost="mycluster" database="testcluster" /&gt;<br>    &lt;dataHost name="mycluster" maxCon="1000" minCon="10" balance="1"<br>                      writeType="0" dbType="mysql" dbDriver="native" switchType="2"  slaveThreshold="100"&gt;<br>            &lt;heartbeat&gt;show slave status&lt;/heartbeat&gt;<br>            &lt;!-- 读写分离 --&gt;<br>            &lt;writeHost host="Master201" url="192.168.43.201:3306" user="MyCat" password="123456"&gt;<br>                &lt;readHost host="Slave202" url="192.168.43.202:3306" user="MyCat" password="123456"&gt;<br>                &lt;/readHost&gt;<br>                &lt;readHost host="Slave203" url="192.168.43.203:3306" user="MyCat" password="123456"&gt;<br>                &lt;/readHost&gt;<br>            &lt;/writeHost&gt;<br>            &lt;!-- 主从切换 --&gt;<br>            &lt;writeHost host="Slave202" url="192.168.43.202:3306" user="MyCat" password="123456"&gt;&lt;/writeHost&gt;<br>            &lt;writeHost host="Slave203" url="192.168.43.203:3306" user="MyCat" password="123456"&gt;&lt;/writeHost&gt;<br>        &lt;/dataHost&gt;<br>&lt;/mycat:schema&gt;</code></code></pre> 
 <h5>重启MyCat</h5> 
 <p>现在我们来停掉Master库，然后执行写操作，看看是什么结果。</p> 
 <p><code>service mysqld stop</code></p> 
 <p>MyCat日志：</p> 
 <p style="text-align: center"><img width="1690" src="https://images2.imgbox.com/1c/51/S0O0RNJM_o.png"></p> 
 <p style="text-align: center"><img width="1659" src="https://images2.imgbox.com/8d/1b/k1WC9nB2_o.png"></p> 
 <p>执行</p> 
 <p><code>INSERT INTO student(student_id,student_name)VALUES('test','testdown');</code></p> 
 <p>MyCat日志</p> 
 <p style="text-align: center"><img width="1687" src="https://images2.imgbox.com/17/ec/hgcEYu4o_o.png"></p> 
 <p>可以看到，现在当我们执行完这个语句时，他自动切换到202数据库进行写入，而202是Slave而非master，这就说明MyCat对写库进行了自动切换，我们的MySQL集群依旧可以提供写的功能。</p> 
 <p><strong>当然，此时我们MySQL的主从架构已经被破坏，如果需要恢复主从结构，就需要手动地重新去恢复我们的主从架构。</strong><strong>我们需要将201和203作为Slave，202作为Master，因为Master拥有最完整的数据。</strong></p> 
 <hr> 
 <h3>优劣分析</h3> 
 <p>关于这两种方式的优劣，相信如果仔细看完这篇文章的同学都会有一个深刻的体会。</p> 
 <p><strong>代码层实现读写分离</strong>，主要的优点就是<strong>灵活，可以自己根据不同的需求对读写分离的规则进行定制化开发</strong>，但其缺点也十分明显，就是当我们动态增减主从库数量的时候，都需要对代码进行一个或多或少的修改。并且当主库宕机了，如果我们没有实现相应的容灾逻辑，那么整个数据库集群将丧失对外的写功能。</p> 
 <p><strong>使用MyCat中间件实现读写分离</strong>，优点十分明显，我们只需要进行配置就可以享受读写分离带来的效率的提升，不用写一行代码，并且当主库宕机时，我们还可以通过配置的方式进行主从库的自动切换，这样即使主库宕机我们的整个集群也不会丧失写的功能。其缺点可能就是我们得多付出一台服务器作为虚拟节点了吧，毕竟服务器也是需要成本的。</p> 
 <p><strong>两种方式如何抉择：</strong>如果你目前的项目比较小，或者干脆是一个毕业设计、课程设计之类的，不会有动态增减数据库的需求，那么自己动手实现一个数据库的读写分离会比较适合你，毕竟答辩的时候，可以一行一行代码跟你的导师和同学解（zhuang）释（bi）。如果项目比较大了，数据库节点有可能进行增减，并且需要主从切换之类的功能，那么就使用第二种方式吧。这种配置化的实现可以降低第二天洗头时候下水管堵塞的几率。</p> 
 <p style="text-align: center"><strong>END</strong></p> 
 <p style="text-align: center"><strong>如有收获，请划至底部，点击“在看”，谢</strong><strong>谢</strong><strong>！</strong><br></p> 
 <p style="text-align: center"><img width="100%" src="https://images2.imgbox.com/55/4e/vX8co7u3_o.png"></p> 
 <p style="text-align: center">欢迎长按下图关注公众号<strong>石杉的架构笔记</strong></p> 
 <p style="text-align: center"><img width="258" src="https://images2.imgbox.com/b1/f3/CxxZRh7q_o.png"></p> 
 <p style="text-align: center"><strong>BAT架构经验倾囊相授</strong></p> 
 <p> </p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ec9cd8bd7e80301d40b00d425f8515e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">当PS弹出&#34;你的PS已经停止工作&#34;，你或许还可以使用这个方法挽救！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5af94c1bf6df3fce65221596bc98fdf8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">12.flowable 流程实例 终止流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>