<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构与算法】堆的应用：堆排序和topk问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构与算法】堆的应用：堆排序和topk问题" />
<meta property="og:description" content="目录
一.堆排序
二.topk问题
一.堆排序 我们知道冒泡算法的时间复杂度是O（N^2），在数据量很多的时候，N^2是个很可怕的数字，二分算法的时间复杂度是O(logn)，但是二分算法有限制条件，实用性并不高，那怎样才能高效实用的排序呢？
堆排序就能很好解决上述问题，堆排序的时间复杂度是O(logn)，也没啥限制条件，可以实现高效排序。
这里要注意，排升序要建大堆，排降序要建小堆;
1.假设排升序，所以建大堆；
2.堆建好后，定义一个 end 变量，令其 =n-1（数组最后一个元素的下标是n-1） ；
3.堆建好后，数组第一个元素就是最大的，将其与最后一个数据交换，然后这个数据就不需要动了，为了保持它是个大堆，让它的前 end-1 个元素向下调整，然后end--，当 end&lt;=0 时就结束循环。
堆排序不需要手搓个堆，只需要用到向下调整这个函数，所以使用堆排序时，只需写个向下调整就行了。
void Swap(int* p1, int* p2) { int tmp = *p1; *p1 = *p2; *p2 = tmp; } void AdjustDown(int* arr, int parent, int n) { assert(arr); int child = 2 * parent &#43; 1; while (child &lt; n) { if ((child &#43; 1) &lt; n&amp;&amp; arr[child &#43; 1] &gt; arr[child]) { child&#43;&#43;; } if (arr[child] &gt; arr[parent]) { Swap(&amp;arr[child], &amp;arr[parent]); parent = child; child = 2 * parent &#43; 1; } else break; } } void Heapsort(int* arr, int n) { assert(arr); int i = 0; for (i = (n - 2) / 2; i &gt;= 0; i--) //建堆 { AdjustDown(arr, i, n); } int end = n - 1; while (end) { Swap(&amp;arr[0], &amp;arr[end]); AdjustDown(arr, 0, end); end--; } for (i = 0; i &lt; n; i&#43;&#43;) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/101fc86ca9b26c24f3b11bec105174eb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-30T11:54:30+08:00" />
<meta property="article:modified_time" content="2023-03-30T11:54:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构与算法】堆的应用：堆排序和topk问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="210" src="https://images2.imgbox.com/a8/d0/lACH0WSR_o.gif" width="240"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">一.堆排序</a></p> 
<p id="%E4%BA%8C.topk%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.topk%E9%97%AE%E9%A2%98" rel="nofollow">二.topk问题</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E5%A0%86%E6%8E%92%E5%BA%8F">一.堆排序</h2> 
<blockquote> 
 <p>我们知道冒泡算法的时间复杂度是<span style="background-color:#ffd900;">O（N^2）</span>，在数据量很多的时候，N^2是个很可怕的数字，二分算法的时间复杂度是<span style="background-color:#ffd900;">O(logn)</span>，但是二分算法<span style="background-color:#ffd900;">有限制条件</span>，实用性并不高，那怎样才能高效实用的排序呢？</p> 
 <p>堆排序就能很好解决上述问题，<span style="background-color:#ffd900;">堆排序的时间复杂度是O(logn)，也没啥限制条件</span>，可以实现高效排序。</p> 
</blockquote> 
<blockquote> 
 <p>这里要注意，<span style="background-color:#ffd900;">排升序要建大堆，排降序要建小堆;</span></p> 
 <p>1.假设排升序，所以建大堆；</p> 
 <p>2.堆建好后，<span style="background-color:#ffd900;">定义一个 end 变量，令其 =n-1（数组最后一个元素的下标是n-1）</span> ；</p> 
 <p>3.堆建好后，数组第一个元素就是最大的，<span style="background-color:#ffd900;">将其与最后一个数据交换，然后这个数据就不需要动了</span>，为了保持它是个大堆，<span style="background-color:#ffd900;">让它的前 end-1 个元素向下调整，然后end--</span>，当 end&lt;=0 时就结束循环。</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/4b/f7/Y3BXFxbC_o.png" width="1200"></p> 
 <p> </p> 
</blockquote> 
<blockquote> 
 <p>堆排序不需要手搓个堆，<span style="background-color:#ffd900;">只需要用到向下调整这个函数</span>，所以使用堆排序时，只需写个向下调整就行了。</p> 
</blockquote> 
<pre><code class="language-cpp">void Swap(int* p1, int* p2)
{
	int tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}
void AdjustDown(int* arr, int parent, int n)
{
	assert(arr);
	int child = 2 * parent + 1;
	while (child &lt; n)
	{
		if ((child + 1) &lt; n&amp;&amp; arr[child + 1] &gt; arr[child])
		{
			child++;
		}

		if (arr[child] &gt; arr[parent])
		{
			Swap(&amp;arr[child], &amp;arr[parent]);
			parent = child;
			child = 2 * parent + 1;
		}
		else
			break;
	}
}
void Heapsort(int* arr, int n)
{
	assert(arr);
	int i = 0;
	for (i = (n - 2) / 2; i &gt;= 0; i--)   //建堆
	{
		AdjustDown(arr, i, n);
	}
	int end = n - 1;
	while (end)
	{
		Swap(&amp;arr[0], &amp;arr[end]);

		AdjustDown(arr, 0, end);

		end--;
	}
	for (i = 0; i &lt; n; i++)
	{
		printf("%d  ", arr[i]);
	}
	printf("\n");
}</code></pre> 
<hr> 
<h2 id="%E4%BA%8C.topk%E9%97%AE%E9%A2%98">二.topk问题</h2> 
<blockquote> 
 <p><span style="background-color:#ffd900;">TOP-K问题：即求数据结合中前K个最大的元素或者最小的元素，一般情况下数据量都比较大。</span></p> 
</blockquote> 
<blockquote> 
 <p>基本思路如下：<br> 1. 用数据集合中前K个元素来建堆，注意：<br>    <span style="background-color:#ffd900;">前k个最大的元素，则建小堆；</span><br><span style="background-color:#ffd900;">   前k个最小的元素，则建大堆；</span><br> 2. <span style="background-color:#ffd900;">用剩余的N-K个元素依次与堆顶元素来比较，不满足则替换堆顶元素；</span><br> 3.将剩余N-K个元素依次与堆顶元素比完之后，堆中剩余的K个元素就是所求的前K个最小或者最大的元素。</p> 
</blockquote> 
<blockquote> 
 <p>我们可以从文件中读取数据，这样的实用性更高些；</p> 
 <p>假设找的是最大的前k个数据，所以建小堆；</p> 
 <p>具体：</p> 
 <p>1.<span style="background-color:#ffd900;">创建一个k个元素的数组，模拟建堆</span>，从文件中读取k个数据存入数组中；</p> 
 <p>2<span style="background-color:#ffd900;">.从文件中取数据与数组的第一个元素比较，也就是堆顶的数据</span>，因为是小堆，如果该数据比堆顶数据大，<span style="background-color:#ffd900;">则将值赋给堆顶，成为新的堆顶</span>，不用担心会出什么问题，因为是小堆，所以那些<span style="background-color:#ffd900;">大的数据会往下沉</span>，如果不大于堆顶的数据，则继续从文件中取数据出来比较；</p> 
 <p>3.<span style="background-color:#ffd900;">当读取文件结束时就结束循环</span>。</p> 
</blockquote> 
<blockquote> 
 <p>如果对文件操作不太熟悉的话，可参考-&gt;<a class="link-info" href="https://mp.csdn.net/mp_blog/creation/editor/128704745" title="文件的基础操作">文件的基础操作</a></p> 
</blockquote> 
<blockquote> 
 <p>如要想检验你写的代码是否能解决topk问题时，可以在数据创建完成后，<span style="background-color:#ffd900;">手动修改文件中的k个数据</span>，如果是找最大的k个数据，那么只需要修改k个数据，且每个都大于原来文件的最大值，这样在测试代码时，输出的就是你修改的k个数据。</p> 
</blockquote> 
<pre><code class="language-cpp">void Createdata(const char file,int n)   //创建数据
{
	int i = 0;
	int x = 0;
	FILE* fin = fopen("file", "w");  //打开文件
	if (fin == NULL)
	{
		perror("fopen fail");
		exit(-1);
	}
	for (i = 0; i &lt; n; i++)
	{
		x = rand() % 100 + 1;   //利用随机数生成函数，创建k个范围在1~100之间的数据
		fprintf(fin, "%d\n", x);  //将数据写入文件中
	}
	fclose(fin);  //关闭文件
	fin = NULL;
}

void topk(const char file, int k)
{
	FILE* fout = fopen("file", "r");
	if (fout == NULL)
	{
		perror("fopen fail");
		exit(-1);
	}
	HPdatatype* arr = (HPdatatype*)malloc(sizeof(HPdatatype) * k);
	if (arr == NULL)
	{
		perror("malloc fail");
		exit(-1);
	}
	int i = 0;
	for (i = 0; i &lt; k; i++)
	{
		fscanf(fout, "%d", &amp;arr[i]);  //从文件中写入k个数据到数组中，模拟堆的创建
	}

	int val = 0, ret = 0;
	ret = fscanf(fout, "%d", &amp;val);   //从文件中取数据
	while (ret != EOF)
	{
		if (val &gt; arr[0])  //将取出的数据与堆顶数据比较，若大于，则其成为新的堆顶
		{
			arr[0] = val;
			AdjustDown(arr, 0, k);   //向下调整，保持小堆或是大堆
		}

		ret = fscanf(fout, "%d", &amp;val);  //从文件中取数据
	}
	free(arr);
	fclose(fout);
	arr = NULL;
	fout = NULL;

}

int main()
{
	srand((unsigned int)time(NULL));
	const char file = "data.txt";
	int n = 1000;
	int k = 10;
	//Createdata(file,n);
	topk(file, k);
	return 0;
}</code></pre> 
<hr> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>🐬🤖本篇文章到此就结束了，若有错我或是建议的话，欢迎小伙伴们指出；🕊️👻</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>😄😆希望小伙伴们能支持支持博主啊，你们的支持对我很重要哦；🥰🤩</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>😍😁谢谢你的阅读。😸😼</strong></span></p> 
</blockquote> 
<p><img alt="" height="260" src="https://images2.imgbox.com/d0/1f/Etyu96Nz_o.gif" width="258"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d024e26509a52f408f6d7f382767efb4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">云计算ACP云服务器ECS实例题库（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d543da2dab0b8cebd03b11566530bbdb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用WebSocket和EventSource实现服务端推送</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>