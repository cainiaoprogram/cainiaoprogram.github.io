<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python-can库基于PCAN-USB使用方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python-can库基于PCAN-USB使用方法" />
<meta property="og:description" content="一、概述 1.介绍
python-can库为Python提供了控制器局域网的支持，为不同的硬件设备提供了通用的抽象，并提供了一套实用程序，用于在CAN总线上发送和接收消息。
支持硬件接口：
Name
Documentation
&#34;socketcan&#34;
SocketCAN
&#34;kvaser&#34;
Kvaser’s CANLIB
&#34;serial&#34;
CAN over Serial
&#34;slcan&#34;
CAN over Serial / SLCAN
&#34;ixxat&#34;
IXXAT Virtual CAN Interface
&#34;pcan&#34;
PCAN Basic API
&#34;usb2can&#34;
USB2CAN Interface
&#34;nican&#34;
NI-CAN
&#34;iscan&#34;
isCAN
&#34;neovi&#34;
neoVI
&#34;vector&#34;
Vector
&#34;virtual&#34;
Virtual
&#34;canalystii&#34;
CANalyst-II
&#34;systec&#34;
SYSTEC interface
2.环境搭建
Python安装：https://www.python.org/ftp/python/3.7.9/python-3.7.9-amd64.exe
PCAN-USB驱动：https://www.peak-system.com/fileadmin/media/files/pcan-basic.zip
库：pip install python-can
3.参考文档
https://python-can.readthedocs.io/en/master/#
二、常用方法 1.接收报文
from can.interfaces.pcan.pcan import PcanBus def bus_recv(): &#34;&#34;&#34;轮询接收消息&#34;&#34;&#34; try: while True: msg = bus." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cfe8c14b4fff9a901c682c2efd9f3fde/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-01T22:33:34+08:00" />
<meta property="article:modified_time" content="2023-02-01T22:33:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python-can库基于PCAN-USB使用方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <h3>一、概述</h3> 
 <p>1.介绍</p> 
 <p>python-can库为Python提供了控制器局域网的支持，为不同的硬件设备提供了通用的抽象，并提供了一套实用程序，用于在CAN总线上发送和接收消息。</p> 
 <p>支持硬件接口：</p> 
 <table><thead><tr><th> <p>Name</p> </th><th> <p>Documentation</p> </th></tr></thead><tbody><tr><td> <p><code>"socketcan"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/socketcan.html" rel="nofollow" title="SocketCAN">SocketCAN</a></p> </td></tr><tr><td> <p><code>"kvaser"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/kvaser.html" rel="nofollow" title="Kvaser’s CANLIB">Kvaser’s CANLIB</a></p> </td></tr><tr><td> <p><code>"serial"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/serial.html" rel="nofollow" title="CAN over Serial">CAN over Serial</a></p> </td></tr><tr><td> <p><code>"slcan"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/slcan.html" rel="nofollow" title="CAN over Serial / SLCAN">CAN over Serial / SLCAN</a></p> </td></tr><tr><td> <p><code>"ixxat"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/ixxat.html" rel="nofollow" title="IXXAT Virtual CAN Interface">IXXAT Virtual CAN Interface</a></p> </td></tr><tr><td> <p><code>"pcan"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/pcan.html" rel="nofollow" title="PCAN Basic API">PCAN Basic API</a></p> </td></tr><tr><td> <p><code>"usb2can"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/usb2can.html" rel="nofollow" title="USB2CAN Interface">USB2CAN Interface</a></p> </td></tr><tr><td> <p><code>"nican"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/nican.html" rel="nofollow" title="NI-CAN">NI-CAN</a></p> </td></tr><tr><td> <p><code>"iscan"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/iscan.html" rel="nofollow" title="isCAN">isCAN</a></p> </td></tr><tr><td> <p><code>"neovi"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/neovi.html" rel="nofollow" title="neoVI">neoVI</a></p> </td></tr><tr><td> <p><code>"vector"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/vector.html" rel="nofollow" title="Vector">Vector</a></p> </td></tr><tr><td> <p><code>"virtual"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/virtual.html" rel="nofollow" title="Virtual">Virtual</a></p> </td></tr><tr><td> <p><code>"canalystii"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/canalystii.html" rel="nofollow" title="CANalyst-II">CANalyst-II</a></p> </td></tr><tr><td> <p><code>"systec"</code></p> </td><td> <p><a class="reference internal" href="https://python-can.readthedocs.io/en/master/interfaces/systec.html" rel="nofollow" title="SYSTEC interface">SYSTEC interface</a></p> </td></tr></tbody></table> 
 <p>2.环境搭建</p> 
 <p>Python安装：<a href="https://www.python.org/ftp/python/3.7.9/python-3.7.9-amd64.exe" rel="nofollow" title="https://www.python.org/ftp/python/3.7.9/python-3.7.9-amd64.exe">https://www.python.org/ftp/python/3.7.9/python-3.7.9-amd64.exe</a></p> 
 <p>PCAN-USB驱动：<a href="https://www.peak-system.com/fileadmin/media/files/pcan-basic.zip" rel="nofollow" title="https://www.peak-system.com/fileadmin/media/files/pcan-basic.zip">https://www.peak-system.com/fileadmin/media/files/pcan-basic.zip</a></p> 
 <p>库：pip install python-can</p> 
 <p>3.参考文档</p> 
 <p>https://python-can.readthedocs.io/en/master/#</p> 
 <h3>二、常用方法</h3> 
 <p>1.接收报文</p> 
 <div> 
  <pre><code>from can.interfaces.pcan.pcan import PcanBus


def bus_recv():
    """轮询接收消息"""
    try:
        while True:
            msg = bus.recv(timeout=100)
            print(msg)
    except KeyboardInterrupt:
        pass

if __name__ == '__main__':
    bus = PcanBus(channel='PCAN_USBBUS1', bitrate=500000)
    bus_recv()</code>
</pre> 
 </div> 
 <p>2.发送报文</p> 
 <div> 
  <pre><code>from can.interfaces.pcan.pcan import PcanBus


def bus_send():
    """can消息发送"""
    while True:
        time.sleep(0.02)
        try:
            bus.send(msg)
            print("消息发送 {}".format(bus.channel_info))
        except can.CanError:
            print("消息未发送")


if __name__ == '__main__':
    msg = can.Message(arbitration_id=0x181DFF00, data=[0xEE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFF, 0xFF, 0xFE],
                      is_extended_id=True)  # 报文
    bus = PcanBus(channel='PCAN_USBBUS1', bitrate=500000)
    bus_send()</code>
</pre> 
 </div> 
 <p>3.定期发送报文</p> 
 <div> 
  <pre><code>def bus_send_periodic():
    """周期发送报文"""
    print("开始每200毫秒发送一条消息。持续时间10s")
    task = bus.send_periodic(msg, 1.5)  # 定期发送
    if not isinstance(task, can.ModifiableCyclicTaskABC):  # 断言task类型
        print("此接口似乎不支持")
        task.stop()
        return
    time.sleep(5)  # 持续时间
    print("发送完成")
    print("更改运行任务的数据以99开头")
    msg.data[0] = 0x99
    task.modify_data(msg)  # 修改data首字节
    time.sleep(10)

    task.stop()
    print("停止循环发送")
    print("将停止任务的数据更改为单个 ff 字节")
    msg.data = bytearray([0xff])  # 重新定向data
    msg.dlc = 1  # 定义data长度
    task.modify_data(msg)  # 修改data
    time.sleep(10)
    print("重新开始")
    task.start()  # 重新启动已停止的周期性任务
    time.sleep(10)
    task.stop()
    print("完毕")

if __name__ == '__main__':
    msg = can.Message(arbitration_id=0x181DFF00, data=[0xEE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFF, 0xFF, 0xFE],
                      is_extended_id=True)  # 报文
    bus = PcanBus(channel='PCAN_USBBUS1', bitrate=500000)
    bus_send_periodic()</code>
</pre> 
 </div> 
 <p>4.循环收发消息</p> 
 <div> 
  <pre><code class="language-python">from can.interfaces.pcan.pcan import PcanBus


def send_cyclic(stop_event):
    """循环发送消息"""
    print("开始每1秒发送1条消息")
    start_time = time.time()
    while not stop_event.is_set():
        msg.timestamp = time.time() - start_time
        bus.send(msg)
        print(f"tx: {msg}")
        time.sleep(1)
    print("停止发送消息")


def receive(stop_event):
    """循环接收消息"""
    print("开始接收消息")
    while not stop_event.is_set():
        rx_msg = bus.recv(1)
        if rx_msg is not None:
            print(f"rx: {rx_msg}")
    print("停止接收消息")


def send_and_recv_msg():
    """发送一个消息并接收一个消息,需要双通道CAN"""
    stop_event = threading.Event()
    t_send_cyclic = threading.Thread(target=send_cyclic, args=(stop_event,))
    t_receive = threading.Thread(target=receive, args=(stop_event,))
    t_receive.start()
    t_send_cyclic.start()
    try:
        while True:
            time.sleep(0)  # yield
    except KeyboardInterrupt:
        pass  # 正常退出
    stop_event.set()
    time.sleep(0.5)


if __name__ == '__main__':
    msg = can.Message(arbitration_id=0x181DFF00, data=[0xEE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFF, 0xFF, 0xFE],
                      is_extended_id=True)  # 报文
    bus = PcanBus(channel='PCAN_USBBUS1', bitrate=500000)
    send_and_recv_msg()</code>
</pre> 
 </div> 
</div> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2deb8c2c2930ad06dfcc4b490db08c92/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RabbitMq 消息确认机制详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/613d96cc902c869364f764a50fa4b4f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言-输出*     图形             **      ***            ****      *****</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>