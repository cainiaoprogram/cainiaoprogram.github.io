<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java实习生】每日面试题打卡——操作系统篇 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java实习生】每日面试题打卡——操作系统篇" />
<meta property="og:description" content="临近秋招，备战暑期实习，祝大家每天进步亿点点！Day15本篇总结的是 操作系统 相关的面试题，后续会每日更新~ 1、请分别简单说一说进程和线程以及它们的区别? 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。包含关系：一个进程最少由一条线程组成。所处环境区别：在操作系统中能同时运行多个进程（程序）；而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。内存分配：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。 2、进程间的通信方式有哪些？ 管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。命名管道FIFO：未命名的管道只能在两个相关的进程之间通信，通过命名管道FIFO，不相关的进程也能交换数据。消息队列： 消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。消息队列允许一个或多个进程向它写入与读取消息。管道和命名管道的通信数据都是先进先出原则，消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取，比FIFO更有优势。 共享内存：共享内存是允许一个或多个进程共享的一块内存区域。信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。 3、线程同步的方式有哪些？ 互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 4、进程的状态及其转换 进程的状态有：就绪状态、运行状态、阻塞状态。
进程状态间的转换关系为：
5、Java线程的状态 Java 线程有以下几个状态：
新建状态（New）就绪状态（Runnable）运行状态（Running）阻塞状态（Blocked）： 等待阻塞同步阻塞其他阻塞 死亡状态（Dead） 6、进程的调度算法有哪些？ 先来先服务算法短作业优先算法优先权调度算法时间片轮转调度算法 参考文章：几个常用的操作系统进程调度算法
7、死锁产生的原因，死锁产生的必要条件是什么，如何预防死锁，如何避免死锁？ **死锁产生的原因：**资源竞争、进程推进顺序不当。
死锁产生的四个必要条件：
互斥：某个资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问了，直到该进程访问结束。不可剥夺：进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，只能由获得该资源使用权的进程释放资源。占有且等待：一个进程请求某个资源并将其占有，即使该进程被阻塞了，也不会释放占有的资源。循环等待：若干进程之间形成一种头尾相接的环形循环等待链。 **预防死锁：**破坏产生死锁的四个必要条件之一即可。
死锁的解除：
强制性地从系统中撤销一个或多个死锁的进程以断开循环等待链。强制性抢占死锁进程正在争取的资源以解除死锁。 8、进程、线程的上下文切换 进程上下文切换：
一个进程切换到另一个进程运行，称为进程的上下文切换。进程是由内核管理和调度的，所以进程的切换只能发生在内核态。
线程上下文切换：
多线程编程中一般线程的个数都大于CPU核心的个数。
但一个线程时间片用完后，会重新处于就绪状态并让给其他线程使用，这个过程属于一次上下文切换。
概括：当前任务在执行完CPU时间片切换到另一个任务前会保存自己的状态，以便下一次再切换回这个任务时，可以再加载这个任务的状态。
9、操作系统的内存管理机制了解吗？内存管理有哪⼏种⽅式? 块式管理：远古时代的计算机操系统的内存管理⽅式。将内存分为⼏个固定⼤⼩的块，每 个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，如果程序 运⾏只需要很⼩的空间的话，分配的这块内存很⼤⼀部分⼏乎被浪费了。这些在每个块中未 被利⽤的空间，我们称之为碎⽚。⻚式管理：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，⻚᫾⼩，相对相⽐于块式管理的 划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。⻚式管理通过⻚表对应逻辑地址和物理地址。段式管理：⻚式管理虽然提⾼了内存利⽤率，但是⻚式管理其中的⻚实际并⽆任何实际意 义。 段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多 。但是，最重 要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如,有主程序段 MAIN、⼦程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。 10、 CPU 寻址了解吗?为什么需要虚拟地址空间? 处理器使⽤的是⼀种称为虚拟寻址的寻址⽅式。使⽤虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有⼀个被称为内存管理单元 的硬件。
11、什么是用户态和核心态？ 在计算机系统中，分两种程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态——用户态、核心态。
用户态：只能受限的访问内存，运行所有的应用程序。核心态：运行操作系统程序，CPU 可以访问内存的所有数据，包括外围设备。 12、操作系统内存管理方式，分页分段以及段页式的优缺点？ 内存管理方式：块式管理、页式管理、段式管理、段页式管理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f92f65cddea957cbe7a18ab0a70b8d80/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-04T08:24:50+08:00" />
<meta property="article:modified_time" content="2021-06-04T08:24:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java实习生】每日面试题打卡——操作系统篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ul><li>临近秋招，备战暑期实习，祝大家每天进步亿点点！<mark>Day15</mark></li><li>本篇总结的是 <strong>操作系统</strong> 相关的面试题，后续会每日更新~</li></ul> 
<p><img src="https://images2.imgbox.com/22/58/u9pY5Ch7_o.jpg" alt="在这里插入图片描述" width="400" height="400"></p> 
<hr> 
<h3><a id="1_7"></a>1、请分别简单说一说进程和线程以及它们的区别?</h3> 
<ul><li>根本区别：<strong>进程</strong>是操作系统资源分配的基本单位，而<strong>线程</strong>是任务调度和执行的基本单位。</li><li>包含关系：一个进程最少由一条线程组成。</li><li>所处环境区别：在操作系统中能同时运行多个进程（程序）；而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。</li><li>内存分配：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（<strong>线程所使用的资源来自其所属进程的资源</strong>），线程组之间只能共享资源。</li></ul> 
<hr> 
<h3><a id="2_16"></a>2、进程间的通信方式有哪些？</h3> 
<ul><li><strong>管道</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li><li><strong>命名管道FIFO</strong>：未命名的管道只能在两个相关的进程之间通信，通过命名管道FIFO，不相关的进程也能交换数据。</li><li><strong>消息队列</strong>： 
  <ul><li>消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。</li><li>消息队列允许一个或多个进程向它写入与读取消息。</li><li>管道和命名管道的通信数据都是先进先出原则，消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取，比FIFO更有优势。</li></ul> </li><li><strong>共享内存</strong>：共享内存是允许一个或多个进程共享的一块内存区域。</li><li><strong>信号量</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。</li></ul> 
<hr> 
<h3><a id="3_29"></a>3、线程同步的方式有哪些？</h3> 
<ul><li>互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li><li>信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li></ul> 
<hr> 
<h3><a id="4_37"></a>4、进程的状态及其转换</h3> 
<p>进程的状态有：就绪状态、运行状态、阻塞状态。</p> 
<p>进程状态间的转换关系为：</p> 
<p><img src="https://images2.imgbox.com/79/56/RzIVgycM_o.jpg" alt=""></p> 
<hr> 
<h3><a id="5Java_47"></a>5、Java线程的状态</h3> 
<p>Java 线程有以下几个状态：</p> 
<ul><li>新建状态（New）</li><li>就绪状态（Runnable）</li><li>运行状态（Running）</li><li>阻塞状态（Blocked）： 
  <ul><li><em>等待阻塞</em></li><li><em>同步阻塞</em></li><li><em>其他阻塞</em></li></ul> </li><li>死亡状态（Dead）</li></ul> 
<hr> 
<h3><a id="6_62"></a>6、进程的调度算法有哪些？</h3> 
<ul><li><strong>先来先服务算法</strong></li><li><strong>短作业优先算法</strong></li><li><strong>优先权调度算法</strong></li><li><strong>时间片轮转调度算法</strong></li></ul> 
<p>参考文章：<a href="https://blog.csdn.net/luyafei_89430/article/details/12971171">几个常用的操作系统进程调度算法</a></p> 
<hr> 
<h3><a id="7_73"></a>7、死锁产生的原因，死锁产生的必要条件是什么，如何预防死锁，如何避免死锁？</h3> 
<p>**死锁产生的原因：**资源竞争、进程推进顺序不当。</p> 
<p><strong>死锁产生的四个必要条件：</strong></p> 
<ul><li>互斥：某个资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问了，直到该进程访问结束。</li><li>不可剥夺：进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，只能由获得该资源使用权的进程释放资源。</li><li>占有且等待：一个进程请求某个资源并将其占有，即使该进程被阻塞了，也不会释放占有的资源。</li><li>循环等待：若干进程之间形成一种头尾相接的环形循环等待链。</li></ul> 
<p>**预防死锁：**破坏产生死锁的四个必要条件之一即可。</p> 
<p><strong>死锁的解除：</strong></p> 
<ul><li>强制性地从系统中撤销一个或多个死锁的进程以断开循环等待链。</li><li>强制性抢占死锁进程正在争取的资源以解除死锁。</li></ul> 
<hr> 
<h3><a id="8_93"></a>8、进程、线程的上下文切换</h3> 
<blockquote> 
 <p>进程上下文切换：</p> 
</blockquote> 
<p>一个进程切换到另一个进程运行，称为进程的上下文切换。进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</p> 
<blockquote> 
 <p>线程上下文切换：</p> 
</blockquote> 
<p>多线程编程中一般线程的个数都大于CPU核心的个数。</p> 
<p>但一个线程时间片用完后，会重新处于就绪状态并让给其他线程使用，这个过程属于一次上下文切换。</p> 
<p><strong>概括</strong>：当前任务在执行完CPU时间片切换到另一个任务前会保存自己的状态，以便下一次再切换回这个任务时，可以再加载这个任务的状态。</p> 
<hr> 
<h3><a id="9_108"></a>9、操作系统的内存管理机制了解吗？内存管理有哪⼏种⽅式?</h3> 
<ul><li><strong>块式管理</strong>：远古时代的计算机操系统的内存管理⽅式。将内存分为⼏个固定⼤⼩的块，每 个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，如果程序 运⾏只需要很⼩的空间的话，分配的这块内存很⼤⼀部分⼏乎被浪费了。这些在每个块中未 被利⽤的空间，我们称之为碎⽚。</li><li><strong>⻚式管理</strong>：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，⻚᫾⼩，相对相⽐于块式管理的 划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。⻚式管理通过⻚表对应逻辑地址和物理地址。</li><li><strong>段式管理</strong>：⻚式管理虽然提⾼了内存利⽤率，但是⻚式管理其中的⻚实际并⽆任何实际意 义。 段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多 。但是，最重 要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如,有主程序段 MAIN、⼦程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li></ul> 
<hr> 
<h3><a id="10_CPU__116"></a>10、 CPU 寻址了解吗?为什么需要虚拟地址空间?</h3> 
<p>处理器使⽤的是⼀种称为<strong>虚拟寻址</strong>的寻址⽅式。使⽤虚拟寻址，CPU 需要<strong>将虚拟地址翻译成物理地址</strong>，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有⼀个被称为<strong>内存管理单元</strong> 的硬件。</p> 
<hr> 
<h3><a id="11_122"></a>11、什么是用户态和核心态？</h3> 
<p>在计算机系统中，分两种程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态——用户态、核心态。</p> 
<ul><li><strong>用户态</strong>：只能受限的访问内存，运行所有的应用程序。</li><li><strong>核心态</strong>：运行操作系统程序，CPU 可以访问内存的所有数据，包括外围设备。</li></ul> 
<hr> 
<h3><a id="12_131"></a>12、操作系统内存管理方式，分页分段以及段页式的优缺点？</h3> 
<p>内存管理方式：块式管理、页式管理、段式管理、段页式管理。</p> 
<p><strong>分段管理：</strong></p> 
<ul><li>在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</li></ul> 
<p><strong>分页管理</strong>：</p> 
<ul><li>在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。</li></ul> 
<p><strong>段页式管理</strong>：</p> 
<ul><li>段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲ 段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的。</li></ul> 
<hr> 
<h3><a id="13IOIO_149"></a>13、讲一讲操作系统的I/O模型？什么是I/O多路复用？</h3> 
<p>I/O请求有两个阶段：</p> 
<ul><li><strong>等待资源阶段</strong>：I/O请求一般需要请求特殊的资源（如磁盘、RAM、文件），当资源被上一个使用者使用没有被释放时，IO请求就会被阻塞，直到能够使用这个资源。</li><li><strong>使用资源阶段</strong>：真正进行数据接收和发送。</li></ul> 
<p>在等待数据阶段，I/O分为 阻塞I/O 模型 和 非阻塞I/O 模型：</p> 
<ul><li><strong>阻塞I/O</strong> 模型： 资源不可用时，I/O请求一直阻塞，直到反馈结果（有数据或超时）。</li><li><strong>非阻塞I/O</strong> 模型：资源不可用时，I/O请求不会被阻塞，直接返回数据标识资源不可用。但是进程会不停的去轮询检测资源是否可用。</li></ul> 
<p>在使用资源阶段，I/O分为 同步I/O 模型 和 异步I/O 模型。</p> 
<ul><li><strong>同步I/O</strong> 模型：应用阻塞在发送或接收数据的状态，直到数据成功传输或返回失败结果。</li><li><strong>异步I/O</strong> 模型：应用发送或接收数据后立刻返回，数据写入操作系统缓存，由操作系统完成数据发送或接收，并返回成功或失败的信息给应用。</li></ul> 
<p><strong>I/O多路复用</strong>（I/O复用模型）：</p> 
<ul><li>I/O 多路复用可以同时阻塞多个I/O操作，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写。</li></ul> 
<p><strong>正因为阻塞I/O只能阻塞一个I/O操作，而I/O复用模型能够阻塞多个I/O操作，所以才叫做多路复用</strong>。</p> 
<h3><a id="14_172"></a>14、什么是生产者消费者模型？</h3> 
<p>对于生产者：</p> 
<ul><li>在操作系统中，生产者生产一条数据，首先查看缓冲区能否放入数据，有没有空的位置，如果有往下执行，否则说明缓冲区全满了，消费者还没有及时的来消费数据。这时候生产者会进入阻塞等待（会唤醒消费者去消费数据）。</li><li>同样的，假设<strong>多个</strong>生产者都已经申请到执行权时，此时只能有一个生产者可以进入生产状态，所以其他几个生产者又要被阻塞一次。</li></ul> 
<p>对于消费者：</p> 
<ul><li>消费者消费一条数据时，首先查看缓冲区是否有数据单元，如果有执行消费，否则消费者进入阻塞等待（会唤醒生产者去生产数据）。</li></ul> 
<hr> 
<p><font color="red">总结的面试题也挺费时间的，文章会不定时更新，有时候一天多更新几篇，如果帮助您复习巩固了知识点，还请三连支持一下，后续会亿点点的更新！</font></p> 
<p><img src="https://images2.imgbox.com/43/93/7mhrveQH_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c09ef2ce0d1143e762ca60a12671833c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">终于有阿里大牛把Spring Cloud的精髓全总结出来了！不服不行啊</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0557fae442a0bfc0e82a9e3e1cd68b6a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在Arm服务器上使用jaybedeapi操作oracle数据库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>