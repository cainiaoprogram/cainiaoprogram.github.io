<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>iOS常量、变量、属性及其特性 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="iOS常量、变量、属性及其特性" />
<meta property="og:description" content="1.Objective-C中声明常量使用关键字const。如:const double PI = 3.1514;
2.Objective-C中变量可以分为成员变量、局部变量和全局变量(用的很少，尽量不要用)。
//————————------------常量—————————————————//
方法一:
#define kDetailKey @“detail text”
#define DOWNLOAD_TIMEOUT 60.0
#define degresssToRadian(x) (M_PT*(X)/180.0)
这种方法直接使用#define定义函数、字符串和数字，和普通的C/C&#43;&#43;一样，唯一的区别是字符串需要在前面加上“@”符号。
方法二: typedef enum{
kTagLanguageView = 100,
kTagSeriesView,
kTagSeriesDetailView,
kTagThumbView,
kTagVideoView,
kTagFullPhotoView,
}TagSystemViews;
使用枚举定义常量，在这里kTagSeriesView等于101,在程序中直接使用kTagSeriesView来表示这个常量，这和C/C&#43;&#43;一样。 方法三:
在.m或者.mm文件中使用静态常量声明，和C/C&#43;&#43;使用方法一样，例如：
static NSString *BlockColorAlphaComponentKey =@&#34;blockColorAlphaComponent”; //————————------------变量—————————————————//
1.为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性。
但是为了提供灵活性，苹果也让开发者显示设置范围(四选一)。
2.四种编译指令如下:
@private 实例变量只能被声明它的类访问。
@protected 实例变量能被声明它的类和子类，所有没有显示指定范围的实例变量都是@protected。
@public 实例变量可以在任何地方被访问。
@packge
使用modern运行时，一个@package实例变量在实现这个类的可执行文件镜像中实际上是@public的，但是在外面就是@private。
OC中的@package与C语言中的变量和函数的private_extern类似。任何在实现类的镜像之外想使用这个实例变量都会引发link error。
这个类型最常用于框架类的实例变量，使用@private太限制，使用@protected或者@public又太开放。
//——————————————属性—————————————————//
属性:@property:@property只不过是给编译器看的一种指令，它可以编译之后自动为你生成相应的getter和setter方法。 1.公共属性表示你打算如何使用这一类的对象。
2.属性声明是一个指令，它告诉编译器如何为变量生成存取方法。（添加属性声明后，你将了解到有关存取方法的信息）
3.id类型是一个通用类型，OC使用id表示任意类型的对象，它可以作为一个占位符表示这是一个不确定的类型的对象或者引用。因此，所有的对象都可以用id来表示。
4.编译器指令@property可以为一个类声明属性，这是一个偷懒的好方法，用@property声明属性相当于同时声明并实现了对应的实例变量的访问器方法。当然，也可以通过指定属性的特性（Attribute）类控制自动生成的访问器方法的行为。
5.OC里的实例变量默认都是私有的。私有变量只在类自身和子类的实例方法里可见。
6.iOS OC声明变量在@interface括号中和使用@proper的区别：
方式一：直接在@interface中的大括号中声明。
@interface MyTest：NSObject
{
NSString *mystr；
}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7b3045abd8e8a5cb0b955a518dc605f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-05-23T15:33:00+08:00" />
<meta property="article:modified_time" content="2015-05-23T15:33:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">iOS常量、变量、属性及其特性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p class="p1"><span class="s1">1.Objective-C中声明常量使用关键字const。如:const double PI = 3.1514;</span></p> 
 <p class="p1"><span class="s1">2.Objective-C中变量可以分为成员变量、局部变量和全局变量(用的很少，尽量不要用)。</span></p> 
 <p class="p2"><span class="s1" style="color:#ff0000;">//————————------------常量—————————————————//</span></p> 
 <p class="p1"><span class="s1">方法一:</span></p> 
 <p class="p1"><span class="s1">    #define kDetailKey            @“detail text”</span></p> 
 <p class="p1"><span class="s1">    #define DOWNLOAD_TIMEOUT      60.0</span></p> 
 <p class="p1"><span class="s1">    #define degresssToRadian(x)   (M_PT*(X)/180.0)</span></p> 
 <p class="p1"><span class="s1">    这种方法直接使用#define定义函数、字符串和数字，和普通的C/C++一样，唯一的区别是字符串需要在前面加上“@”符号。</span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1">方法二: </span></p> 
 <p class="p3"><span class="s2">    <span class="s1">typedef<span class="s2"> <span class="s1">enum<span class="s2">{<!-- --></span></span></span></span></span></p> 
 <p class="p1"><span class="s1">        kTagLanguageView = <span class="s3">100<span class="s1">,</span></span></span></p> 
 <p class="p1"><span class="s1">        kTagSeriesView,</span></p> 
 <p class="p1"><span class="s1">        kTagSeriesDetailView,</span></p> 
 <p class="p1"><span class="s1">        kTagThumbView,</span></p> 
 <p class="p1"><span class="s1">        kTagVideoView,</span></p> 
 <p class="p1"><span class="s1">        kTagFullPhotoView,</span></p> 
 <p class="p1"><span class="s1">    }TagSystemViews;</span></p> 
 <p class="p1"><span class="s1">    使用枚举定义常量，在这里kTagSeriesView等于101,在程序中直接使用kTagSeriesView来表示这个常量，这和C/C++一样。 </span></p> 
 <p class="p4"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1">方法三:</span></p> 
 <p class="p1"><span class="s1">    在.m或者.mm文件中使用静态常量声明，和C/C++使用方法一样，例如：</span></p> 
 <p class="p1"><span class="s4">static<span class="s1"> <span class="s5">NSString<span class="s1"> *BlockColorAlphaComponentKey =<span class="s6">@"blockColorAlphaComponent”<span class="s1">;      </span></span></span></span></span></span></p> 
 <p class="p4"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p2"><span class="s1" style="color:#ff0000;">//————————------------变量—————————————————//</span></p> 
 <p class="p1"><span class="s1">1.为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性。</span></p> 
 <p class="p1"><span class="s1">   但是为了提供灵活性，苹果也让开发者显示设置范围(四选一)。</span></p> 
 <p class="p1"><span class="s1">2.四种编译指令如下:</span></p> 
 <p class="p5"><span class="s1">@private   <span class="s2"> </span></span></p> 
 <p class="p1"><span class="s1">    实例变量只能被声明它的类访问。</span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1">@protected  </span></p> 
 <p class="p1"><span class="s1">    实例变量能被声明它的类和子类，所有没有显示指定范围的实例变量都是@protected。</span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1">@public    </span></p> 
 <p class="p1"><span class="s1">    实例变量可以在任何地方被访问。</span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1">@packge</span></p> 
 <p class="p1"><span class="s1">    使用modern运行时，一个@package实例变量在实现这个类的可执行文件镜像中实际上是@public的，但是在外面就是@private。</span></p> 
 <p class="p1"><span class="s1">    OC中的@package与C语言中的变量和函数的private_extern类似。任何在实现类的镜像之外想使用这个实例变量都会引发link error。</span></p> 
 <p class="p1"><span class="s1">    这个类型最常用于框架类的实例变量，使用@private太限制，使用@protected或者@public又太开放。</span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p2"><span class="s1" style="color:#ff0000;">//——————————————属性—————————————————//</span></p> 
 <p class="p1"><span class="s1">属性:@property:@property只不过是给编译器看的一种指令，它可以编译之后自动为你生成相应的getter和setter方法。 </span></p> 
 <p class="p1"><span class="s1">1.公共属性表示你打算如何使用这一类的对象。</span></p> 
 <p class="p1"><span class="s1">2.属性声明是一个指令，它告诉编译器如何为变量生成存取方法。（添加属性声明后，你将了解到有关存取方法的信息）</span></p> 
 <p class="p1"><span class="s1">3.id类型是一个通用类型，OC使用id表示任意类型的对象，它可以作为一个占位符表示这是一个不确定的类型的对象或者引用。因此，所有的对象都可以用id来表示。</span></p> 
 <p class="p1"><span class="s1">4.编译器指令@property可以为一个类声明属性，这是一个偷懒的好方法，用@property声明属性相当于同时声明并实现了对应的实例变量的访问器方法。当然，也可以通过指定属性的特性（Attribute）类控制自动生成的访问器方法的行为。</span></p> 
 <p class="p4"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1">5.OC里的实例变量默认都是私有的。私有变量只在类自身和子类的实例方法里可见。</span></p> 
 <p class="p4"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1">6.iOS OC声明变量在@interface括号中和使用@proper的区别：</span></p> 
 <p class="p1"><span class="s1">方式一：直接在@interface中的大括号中声明。</span></p> 
 <p class="p1"><span class="s1"><span class="Apple-tab-span"> @interface MyTest：NSObject</span></span></p> 
 <p class="p1"><span class="s1"><span class="Apple-tab-span"> {<!-- --></span></span></p> 
 <p class="p1"><span class="s1"><span class="Apple-tab-span"> <span class="Apple-tab-span"> NSString *mystr；</span></span></span></p> 
 <p class="p4"> </p> 
 <p class="p1"><span class="s1"><span class="Apple-tab-span"> }</span></span></p> 
 <p class="p1"><span class="s1">方式二：直接用@property声明</span></p> 
 <p class="p1"><span class="s1"><span class="Apple-tab-span"> @interface MyTest：NSObject</span></span></p> 
 <p class="p1"><span class="s1"><span class="Apple-tab-span"> @property（strong，nonatomic）NSString *mystr;</span></span></p> 
 <p class="p1"><span class="s1"><span class="Apple-tab-span"> 随后在.m文件中@synthesize mystr = _myStr;（也可以在.m文件中不加@synthesize）</span></span></p> 
 <p class="p1"><span class="s1">区别：</span></p> 
 <p class="p1"><span class="s1"><span class="Apple-tab-span"> 方式一声明的成员变量是只能在自己类内部使用，而不能在类的外部使用（就是通过类名.点的方式显示不出来。）。</span></span></p> 
 <p class="p1"><span class="s1"><span class="Apple-tab-span"> 方式二可以在类的外部访问，也可以在类的内部通过下划线+变量名或者self.变量名的方式访问。</span></span></p> 
 <p class="p1"><span class="s1"><span class="Apple-tab-span"> 苹果开发模板推荐的是方式二。</span></span></p> 
 <p class="p1"><span class="s1">7.OC是C的严格父集，C能做的事情OC中都能做。</span></p> 
 <p class="p1"><span class="s1">属性实际上一个setter方法和一个getter方法，所有对实例变量的访问都是如此，通过setter方法设置值，通过 getter方法获取值</span></p> 
 <p class="p1"><span class="s1">你没有必要去优化没有必要优化的东西，你要优化的是很花时间的东西，而访问实例变量不会花太多时间。</span></p> 
 <p class="p1"><span class="s1">8..h是共有的API</span></p> 
 <p class="p1"><span class="s1">.m是私有的API以及你所有的实现。</span></p> 
 <p class="p4"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1">所有指针要么是强的，要么是弱的，因为OC需要知道怎样处理内存和堆。强表示保持这个的存储，在堆中，保持这个所指的东西</span></p> 
 <p class="p4"><span class="s1"> </span></p> 
 <p class="p6"><span class="s1">7.plist:属性配置文件，基于XML格式，也扮演了一部分定义UI的角色，Xcode在编译的时候会读取里面的配置信息。</span></p> 
 <p class="p6"><span class="s1">8.类的声明提供了这个类和程序员之间的接口，类的声明即接口，其实现代码才是真正执行实际任务的地方。类的声明以@interface指令开始，以@end指令结束。</span></p> 
 <p class="p6"><span class="s1">9.蓝色的竖线：它是UI控件和屏幕边框的距离参考线以及对齐参考线，用于设置控件在不同大小的屏幕上的位置。</span></p> 
 <p class="p7"><span class="s1"> </span></p> 
 <p class="p7"><span class="s1"> </span></p> 
 <p class="p6"><span class="s1">13.属性使用点语法，其他情况使用方括号标记语法。</span></p> 
 <p class="p1"><span class="s1">***********************************</span></p> 
 <p class="p1"><span class="s1">copy：</span></p> 
 <p class="p1"><span class="s1">1.简单复制只能实现浅拷贝：指针赋值，使每个指针指向相同的一块内存空间，操作不安全。</span></p> 
 <p class="p1"><span class="s1">2.在iOS中可以这样实现：Foundation类已经遵守了&lt;NSCopying&gt;和&lt;NSMutableCopying&gt;协议，即实现了copy和mutableCopy方法，因此Foundation对象可以使用这些方法创建对象的副本或可变副本。</span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1">************************** </span></p> 
 <p class="p8"><span class="s1" style="color:#ff0000;">为属性声明自定义特性</span></p> 
 <p class="p8"><span class="s1">1.访问器方法</span></p> 
 <p class="p1"><span class="s1">    a。我们通过@synthesize这个标记来为属性生成访问器方法。</span></p> 
 <p class="p1"><span class="s1">    b。默认情况下，如果我们声明的属性名为propertyName，那么编译器自动生成的访问器方法分别为propertyName：和setPropertyName:。</span></p> 
 <p class="p1"><span class="s1">    c。可以通过“getter=getterName”和“setter=setterName”这两个属性的自定义特性来设置访问器方法的名称。</span></p> 
 <p class="p1"><span class="s1">    d。自定义访问器方法的名称会导致“点句式”语法糖不好使。</span></p> 
 <p class="p8"><span class="s1">2.可写性</span></p> 
 <p class="p1"><span class="s1">    如果给属性加上readonly的特性：编译器不会自动生成setter访问器方法，属性也就变成只读的。</span></p> 
 <p class="p8"><span class="s1">3.setter支持的特性</span></p> 
 <p class="p1"><span class="s1">    a。setter方法不仅仅是简单的赋值，有这么几个修饰词是用来描述setter方法的：assign，retain，copy和weak，用不同的修饰词表示生成的setter方法会有所不同。</span></p> 
 <p class="p1"><span class="s1">    b。默认是assign，这意味着在setter方法中真的就是简单的赋值。</span></p> 
 <p class="p1"><span class="s1">    c。retain：表示赋值之后会调用新值的retain方法和旧值的release方法。</span></p> 
 <p class="p1"><span class="s1">    d。copy：表示先将值拷贝一份，然后将这个拷贝赋给实例变量，这个修饰词只适用于实现了NSCopying协议的类型。</span></p> 
 <p class="p1"><span class="s1">    e。weak：表示这个值将是一个弱引用，引用和被引用之间没有所属关系。如果系统销毁了某个属性所引用的对象，属性的值会自动地变为nil。一般情况下，如果父对象拥有子对象的引用，那么子对象就不应该再持有父对象的强引用，而是使用弱引用的方式来引用父对象。</span></p> 
 <p class="p1"><span class="s1">    f。strong：表示这个值是一个强引用，引用和被引用之间具有所属关系。从内存使用的角度来看，就是引用对象被回收之前，被引用的对象不会被回收。</span></p> 
 <p class="p8"><span class="s1">4.原子化和非原子化:atomi和nonatomic用来决定编译器生成的getter和setter是否为原子操作。</span></p> 
 <p class="p9"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1">    a。nonatomic指定访问器方式是非线程安全的，即多个线程可以同时访问这个属性。</span></p> 
 <p class="p1"><span class="s1">    b。默认情况下，访问器方法都是 线程安全的，即使在多线程环境中也毫无风险的。然而，即使要保证在多线程环境中能正常工作，访问器也不一定必须是线程安全的。而将访问器方法指定为非线程安全的，可以让getter方法直接返回实例变量的值，效率更高。</span></p> 
 <p class="p4"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1">********************</span></p> 
 <p class="p8"><span class="s1">合成(Synthesizing)属性</span></p> 
 <p class="p1"><span class="s1">1.声明一个属性之后编译器会自动将相关的代码补充完整，即编译器会自动声明一个实例变量以及相关的访问器方法，实例变量的名称是属性名称前面加上下划线。</span></p> 
 <p class="p1"><span class="s1">2.不过有时候我们需要自己来指定实例变量的名称，这时候就需要用到@synthesize指令了。</span></p> 
 <p class="p1"><span class="s1">3.</span></p> 
 <p class="p1"><span class="s1">    a。如果你不得不手动指定属性对应的实例变量的名称，请在@implementation指令之后使用@synthesize指令做如下声明：</span></p> 
 <p class="p1"><span class="s1">        @synthesize label;</span></p> 
 <p class="p1"><span class="s1">这行代码要求编译器根据接口中声明的属性来自动生成访问器方法。</span></p> 
 <p class="p1"><span class="s1">    b。也可以使用如下的方式来指明访问器方法使用的实例变量的名称：</span></p> 
 <p class="p1"><span class="s1">        @synthesize label = _label;</span></p> 
 <p class="p1"><span class="s1">这里指明了实例变量名为_label，而且这是一种很好的封装实例变量的方法，让所有对该实例变量的访问都通过访问器方法来执行。同时，这种方法也可以避免编译器自动取名字时和已用的实例变量名称冲突的情况。</span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1"> </span></p> 
 <p class="p1"><span class="s1"> </span></p> 
</div> 
<p>转载于:https://www.cnblogs.com/123qw/p/4524366.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ecb2b385342e242236526483565b1b14/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">移动设备支持方式-移动设备管理MDM</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e0b14bbb8f6008cde81f06e3c01c5075/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">多服务器之间Session共享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>