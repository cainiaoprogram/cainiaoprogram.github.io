<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 9.0 Bluetooth源码分析（三）蓝牙配对流程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 9.0 Bluetooth源码分析（三）蓝牙配对流程" />
<meta property="og:description" content="1 UI
蓝牙配对开始于settings设备列表 /packages/apps/Settings/src/com/android/settings/bluetooth/DeviceListPreferenceFragment.java中。
DeviceListPreferenceFragment是蓝牙扫描到的设备列表，点击其中一个蓝牙设备，调用onPreferenceTreeClick方法开始蓝牙的配对过程。
@Override
public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen,
Preference preference) {
if (KEY_BT_SCAN.equals(preference.getKey())) {
mLocalAdapter.startScanning(true);
return true;
}
if (preference instanceof BluetoothDevicePreference) { BluetoothDevicePreference btPreference = (BluetoothDevicePreference) preference; CachedBluetoothDevice device = btPreference.getCachedDevice(); mSelectedDevice = device.getDevice(); //配对连接 onDevicePreferenceClick(btPreference); return true; } return super.onPreferenceTreeClick(preferenceScreen, preference); } 在本地onDevicePreferenceClick方法中调用/packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothDevicePreference.java的onClicked方法：
void onClicked() {
Context context = getContext();
int bondState = mCachedDevice.getBondState();// 获取设备的绑定状态
final MetricsFeatureProvider metricsFeatureProvider = FeatureFactory.getFactory(context).getMetricsFeatureProvider(); if (mCachedDevice.isConnected()) { metricsFeatureProvider.action(context, MetricsEvent.ACTION_SETTINGS_BLUETOOTH_DISCONNECT); askDisconnect(); // 已连接，询问是否断开连接 } else if (bondState == BluetoothDevice." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8bd07f1599be31c346d932e7c7349ddc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-19T11:34:59+08:00" />
<meta property="article:modified_time" content="2020-06-19T11:34:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 9.0 Bluetooth源码分析（三）蓝牙配对流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1 UI</p> 
<p>蓝牙配对开始于settings设备列表 /packages/apps/Settings/src/com/android/settings/bluetooth/DeviceListPreferenceFragment.java中。<br> DeviceListPreferenceFragment是蓝牙扫描到的设备列表，点击其中一个蓝牙设备，调用onPreferenceTreeClick方法开始蓝牙的配对过程。<br> @Override<br> public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen,<br> Preference preference) {<!-- --><br> if (KEY_BT_SCAN.equals(preference.getKey())) {<!-- --><br> mLocalAdapter.startScanning(true);<br> return true;<br> }</p> 
<pre><code>    if (preference instanceof BluetoothDevicePreference) {
        BluetoothDevicePreference btPreference = (BluetoothDevicePreference) preference;
        CachedBluetoothDevice device = btPreference.getCachedDevice();
        mSelectedDevice = device.getDevice();
        //配对连接
        onDevicePreferenceClick(btPreference);
        return true;
    }

    return super.onPreferenceTreeClick(preferenceScreen, preference);
}
</code></pre> 
<p>在本地onDevicePreferenceClick方法中调用/packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothDevicePreference.java的onClicked方法：<br> void onClicked() {<!-- --><br> Context context = getContext();<br> int bondState = mCachedDevice.getBondState();// 获取设备的绑定状态</p> 
<pre><code>      final MetricsFeatureProvider metricsFeatureProvider =
              FeatureFactory.getFactory(context).getMetricsFeatureProvider();
      if (mCachedDevice.isConnected()) {
          metricsFeatureProvider.action(context,
                  MetricsEvent.ACTION_SETTINGS_BLUETOOTH_DISCONNECT);
          askDisconnect(); // 已连接，询问是否断开连接
      } else if (bondState == BluetoothDevice.BOND_BONDED) {
          metricsFeatureProvider.action(context,
                  MetricsEvent.ACTION_SETTINGS_BLUETOOTH_CONNECT);
          mCachedDevice.connect(true);// 已绑定，则进行连接
      } else if (bondState == BluetoothDevice.BOND_NONE) {
          metricsFeatureProvider.action(context,
                  MetricsEvent.ACTION_SETTINGS_BLUETOOTH_PAIR);
          if (!mCachedDevice.hasHumanReadableName()) {
              metricsFeatureProvider.action(context,
                  MetricsEvent.ACTION_SETTINGS_BLUETOOTH_PAIR_DEVICES_WITHOUT_NAMES);
          }
          pair();// 如果未绑定，则进行配对
      }
  }
</code></pre> 
<p>这里先获取mCachedDevice的绑定状态，如果已经连接，则询问是否断开；如果已经绑定未连接，则开始连接；如果未连接也未绑定，则开始配对。这里我们先看配对。配对调用的是本地的pair方法：<br> private void pair() {<!-- --><br> if (!mCachedDevice.startPairing()) {<!-- --><br> Utils.showError(getContext(), mCachedDevice.getName(),<br> R.string.bluetooth_pairing_error_message);<br> }<br> }</p> 
<p>pair方法会调用/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java中的startPairing，启动配对<br> 2 framework<br> public boolean startPairing() {<!-- --><br> // Pairing is unreliable while scanning, so cancel discovery<br> // 配对时，如果正在扫描，则取消扫描<br> if (mLocalAdapter.isDiscovering()) {<!-- --><br> mLocalAdapter.cancelDiscovery();<br> }<br> // 开始配对<br> if (!mDevice.createBond()) {<!-- --><br> return false;<br> }<br> // 标识位，配对完成后，自动连接<br> mConnectAfterPairing = true; // auto-connect after pairing<br> return true;<br> }</p> 
<p>createBond调用/frameworks/base/core/java/android/bluetooth/BluetoothDevice.java<br> 中的createBond方法：<br> public boolean createBond(int transport) {<!-- --><br> final IBluetooth service = sService;<br> if (service == null) {<!-- --><br> Log.e(TAG, “BT not enabled. Cannot create bond to Remote Device”);<br> return false;<br> }<br> if (TRANSPORT_AUTO &gt; transport || transport &gt; TRANSPORT_LE) {<!-- --><br> throw new IllegalArgumentException(transport + " is not a valid Bluetooth transport");<br> }<br> try {<!-- --><br> Log.i(TAG, "createBond() for device " + getAddress()<br> + " called by pid: " + Process.myPid()<br> + " tid: " + Process.myTid());<br> return service.createBond(this, transport);<br> } catch (RemoteException e) {<!-- --><br> Log.e(TAG, “”, e);<br> }<br> return false;<br> }</p> 
<p>createBond接着调用IBluetooth的createBond方法，通过aidl方式调用蓝牙远程服务。<br> 3 Bluetooth app</p> 
<p>和蓝牙扫描一样，实现IBluetooth接口的类是AdapterServiceBinder，AdapterServiceBinder实现IBluetooth.Stub接口，是/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterService的私有内部类，AdapterServiceBinder收到的操作，都会转交AdapterService处理，所以会调用AdapterService的createBond方法。<br> boolean createBond(BluetoothDevice device, int transport) {<!-- --><br> enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,<br> “Need BLUETOOTH ADMIN permission”);<br> DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);<br> //属性检查<br> if (deviceProp != null &amp;&amp; deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {<!-- --><br> return false;<br> }</p> 
<pre><code>    // Pairing is unreliable while scanning, so cancel discovery
    // Note, remove this when native stack improves
    cancelDiscoveryNative();// 配对过程，取消扫描
    // 给配对的状态机发消息，创建了BondStateMachine.CREATE_BOND
    Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);
    msg.obj = device;
    msg.arg1 = transport;
    mBondStateMachine.sendMessage(msg);
    return true;
}
</code></pre> 
<p>createBond 方法会检查一下远程设备属性信息，取消蓝牙扫描任务，将配对任务转交mBondStateMachine，由状态机处理该信息。<br> @Override<br> public boolean processMessage(Message msg) {<!-- --></p> 
<pre><code>        BluetoothDevice dev = (BluetoothDevice)msg.obj;

        switch (msg.what) {
            case CREATE_BOND:
                OobData oobData = null;
                if (msg.getData() != null) {
                    oobData = msg.getData().getParcelable(OOBDATA);
                }

                result = createBond(dev, msg.arg1, oobData, false);
                break;
                ........................省略.................................
                }
        }
</code></pre> 
<p>BondStateMachine处理服务发送过来的BondStateMachine.CREATE_BOND消息 ，在processMessage 中调用 BondStateMachine的createBond 方法:<br> private boolean createBond(BluetoothDevice dev, int transport, OobData oobData,<br> boolean transition) {<!-- --><br> if (dev.getBondState() == BluetoothDevice.BOND_NONE) {<!-- --><br> infoLog(“Bond address is:” + dev);<br> byte[] addr = Utils.getBytesFromAddress(dev.getAddress());<br> boolean result;<br> if (oobData != null) {// 判断是否借助其他硬件进行无绑定配对<br> result = mAdapterService.createBondOutOfBandNative(addr, transport, oobData);<br> } else {<!-- --><br> result = mAdapterService.createBondNative(addr, transport);// 调用到JNI层，进行配对<br> }</p> 
<pre><code>          if (!result) {
              sendIntent(dev, BluetoothDevice.BOND_NONE, BluetoothDevice.UNBOND_REASON_REMOVED);
              return false;
          } else if (transition) {
              transitionTo(mPendingCommandState);
          }
          return true;
      }
      return false;
  }
</code></pre> 
<p>createBondNative方法实现在/packages/apps/Bluetooth/jni/com_android_bluetooth_btservice_AdapterService.cpp中：<br> static jboolean createBondNative(JNIEnv* env, jobject obj, jbyteArray address,<br> jint transport) {<!-- --><br> ALOGV("%s", <strong>func</strong>);</p> 
<pre><code>if (!sBluetoothInterface) return JNI_FALSE;

jbyte* addr = env-&gt;GetByteArrayElements(address, NULL);
if (addr == NULL) {
  jniThrowIOException(env, EINVAL);
  return JNI_FALSE;
}
// 调用到hal层的配对函数
int ret = sBluetoothInterface-&gt;create_bond((RawAddress*)addr, transport);
env-&gt;ReleaseByteArrayElements(address, addr, 0);
return (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
</code></pre> 
<p>}</p> 
<p>这里通过create_bond这个方法调用到了蓝牙协议栈里面。<br> 4 蓝牙协议栈</p> 
<p>create_bond方法位于/system/bt/btif/src/bluetooth.cc：<br> static int create_bond(const RawAddress* bd_addr, int transport) {<!-- --><br> /* sanity check */<br> if (!interface_ready()) return BT_STATUS_NOT_READY;</p> 
<pre><code>return btif_dm_create_bond(bd_addr, transport);
</code></pre> 
<p>}</p> 
<p>create_bond方法调用/system/bt/btif/src/btif_dm.cc的btif_dm_create_bond方法：<br> bt_status_t btif_dm_create_bond(const RawAddress* bd_addr, int transport) {<!-- --><br> btif_dm_create_bond_cb_t create_bond_cb;<br> create_bond_cb.transport = transport;<br> create_bond_cb.bdaddr = *bd_addr;</p> 
<pre><code>BTIF_TRACE_EVENT("%s: bd_addr=%s, transport=%d", __func__,
                 bd_addr-&gt;ToString().c_str(), transport);
// 如果如果不是未配对状态，则取消配对
if (pairing_cb.state != BT_BOND_STATE_NONE) return BT_STATUS_BUSY;

btif_stats_add_bond_event(*bd_addr, BTIF_DM_FUNC_CREATE_BOND,
                          pairing_cb.state);// 添加了绑定事件

// 这里create_bond_cb在上面已经传入了要绑定的蓝牙地址，
// 会分别发送给底层两部分，最后会调用btif_dm_generic_evt
btif_transfer_context(btif_dm_generic_evt, BTIF_DM_CB_CREATE_BOND,
                      (char*)&amp;create_bond_cb,
                      sizeof(btif_dm_create_bond_cb_t), NULL);

return BT_STATUS_SUCCESS;
</code></pre> 
<p>}</p> 
<p>btif_dm_create_bond方法最终调用了本地的btif_dm_generic_evt方法，传入BTIF_DM_CB_CREATE_BOND事件：<br> static void btif_dm_generic_evt(uint16_t event, char* p_param) {<!-- --><br> BTIF_TRACE_EVENT("%s: event=%d", <strong>func</strong>, event);<br> switch (event) {<!-- --><br> …省略…<br> case BTIF_DM_CB_CREATE_BOND: {// 根据传入的事件，走这里进行配对<br> pairing_cb.timeout_retries = NUM_TIMEOUT_RETRIES;<br> btif_dm_create_bond_cb_t* create_bond_cb =<br> (btif_dm_create_bond_cb_t*)p_param;<br> btif_dm_cb_create_bond(create_bond_cb-&gt;bdaddr, create_bond_cb-&gt;transport);<br> } break;<br> …省略…<br> }<br> }</p> 
<p>这里又调用本地的btif_dm_cb_create_bond方法：<br> static void btif_dm_cb_create_bond(const RawAddress&amp; bd_addr,<br> tBTA_TRANSPORT transport) {<!-- --><br> bool is_hid = check_cod(&amp;bd_addr, COD_HID_POINTING);<br> // 这里开始回调，将绑定状态变成绑定中<br> bond_state_changed(BT_STATUS_SUCCESS, bd_addr, BT_BOND_STATE_BONDING);<br> …省略…<br> if (is_hid &amp;&amp; (device_type &amp; BT_DEVICE_TYPE_BLE) == 0) {<!-- --><br> bt_status_t status;<br> status = (bt_status_t)btif_hh_connect(&amp;bd_addr);<br> if (status != BT_STATUS_SUCCESS)<br> bond_state_changed(status, bd_addr, BT_BOND_STATE_NONE);<br> } else {<!-- --><br> BTA_DmBondByTransport(bd_addr, transport);// 第一次调用会走这里<br> }<br> /* Track originator of bond creation */<br> pairing_cb.is_local_initiated = true;<br> }</p> 
<p>BTA_DmBondByTransport方法位于\system\bt\bta\dm\bta_dm_api.c：<br> void BTA_DmBondByTransport(BD_ADDR bd_addr, tBTA_TRANSPORT transport)<br> {<!-- --><br> // 调用bta的bta_dm_bond方法<br> do_in_bta_thread(FROM_HERE, base::Bind(bta_dm_bond, bd_addr, transport));<br> }</p> 
<p>这里通过do_in_bta_thread调用/system/bt/bta/dm/bta_dm_act.cc里面的bta_dm_bond方法，进入bta进程：<br> void bta_dm_bond (tBTA_DM_MSG *p_data)<br> {<!-- --><br> tBTM_STATUS status;<br> tBTA_DM_SEC sec_event;<br> char *p_name;</p> 
<pre><code>if (p_data-&gt;bond.transport == BTA_TRANSPORT_UNKNOWN)
    status = BTM_SecBond ( p_data-&gt;bond.bd_addr, 0, NULL, 0 );
else
    status = BTM_SecBondByTransport ( p_data-&gt;bond.bd_addr, p_data-&gt;bond.transport, 0, NULL, 0 );


if (bta_dm_cb.p_sec_cback &amp;&amp; (status != BTM_CMD_STARTED))
{

    memset(&amp;sec_event, 0, sizeof(tBTA_DM_SEC));
    bdcpy(sec_event.auth_cmpl.bd_addr, p_data-&gt;bond.bd_addr);
    p_name = BTM_SecReadDevName(p_data-&gt;bond.bd_addr);
    if (p_name != NULL)
    {
        memcpy(sec_event.auth_cmpl.bd_name, p_name, (BD_NAME_LEN-1));
        sec_event.auth_cmpl.bd_name[BD_NAME_LEN-1] = 0;
    }
</code></pre> 
<p>/* taken care of by memset [above]<br> sec_event.auth_cmpl.key_present = FALSE;<br> sec_event.auth_cmpl.success = FALSE;<br> <em>/<br> sec_event.auth_cmpl.fail_reason = HCI_ERR_ILLEGAL_COMMAND;<br> if (status == BTM_SUCCESS)<br> {<!-- --><br> sec_event.auth_cmpl.success = TRUE;<br> }<br> else<br> {<!-- --><br> /</em> delete this device entry from Sec Dev DB */<br> bta_dm_remove_sec_dev_entry(p_data-&gt;bond.bd_addr);<br> }<br> bta_dm_cb.p_sec_cback(BTA_DM_AUTH_CMPL_EVT, &amp;sec_event);// 配对事件回调<br> }<br> }</p> 
<p>然后来到\system\bt\stack\btm\btm_sec.c的BTM_SecBondByTransport 方法：<br> tBTM_STATUS BTM_SecBondByTransport (BD_ADDR bd_addr, tBT_TRANSPORT transport,<br> UINT8 pin_len, UINT8 *p_pin, UINT32 trusted_mask[])<br> {<!-- --><br> tBT_DEVICE_TYPE dev_type;<br> tBLE_ADDR_TYPE addr_type;</p> 
<pre><code>BTM_ReadDevInfo(bd_addr, &amp;dev_type, &amp;addr_type);
/* LE device, do SMP pairing */
if ((transport == BT_TRANSPORT_LE &amp;&amp; (dev_type &amp; BT_DEVICE_TYPE_BLE) == 0) ||
    (transport == BT_TRANSPORT_BR_EDR &amp;&amp; (dev_type &amp; BT_DEVICE_TYPE_BREDR) == 0))
{
    return BTM_ILLEGAL_ACTION;
}
return btm_sec_bond_by_transport(bd_addr, transport, pin_len, p_pin, trusted_mask);
</code></pre> 
<p>}</p> 
<p>调用本地btm_sec_bond_by_transport方法，这个方法内容很多，着重看这段代码：<br> if (!controller_get_interface()-&gt;supports_simple_pairing())//这里做一个判断，看是否支持简单配对方式<br> {<!-- --><br> /* The special case when we authenticate keyboard. Set pin type to fixed <em>/<br> /</em> It would be probably better to do it from the application, but it is <em>/<br> /</em> complicated */<br> if (((p_dev_rec-&gt;dev_class[1] &amp; BTM_COD_MAJOR_CLASS_MASK) == BTM_COD_MAJOR_PERIPHERAL)<br> &amp;&amp; (p_dev_rec-&gt;dev_class[2] &amp; BTM_COD_MINOR_KEYBOARD)<br> &amp;&amp; (btm_cb.cfg.pin_type != HCI_PIN_TYPE_FIXED)) {<!-- --><br> btm_cb.pin_type_changed = TRUE;<br> btsnd_hcic_write_pin_type (HCI_PIN_TYPE_FIXED);// 这里就在和hci层打交道<br> }<br> }</p> 
<p>这里调用system/bt/stack/hcic/hcicmds.cc的btsnd_hcic_write_pin_type方法通过HCI向底层发送命令进行控制<br> void btsnd_hcic_write_pin_type (UINT8 type)<br> {<!-- --><br> BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);<br> UINT8 *pp = (UINT8 *)(p + 1);</p> 
<pre><code>p-&gt;len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_WRITE_PARAM1;
p-&gt;offset = 0;

UINT16_TO_STREAM (pp, HCI_WRITE_PIN_TYPE);
UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_WRITE_PARAM1);

UINT8_TO_STREAM (pp, type);

btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);//这里是向hci层发命令，
</code></pre> 
<p>}</p> 
<p>可以看出，这里是通过和hci层的通信，host告诉controlor蓝牙地址、数据、命令等，从而控制其底层硬件发起配对操作。具体btu如何与hci通信，过程也是很繁琐，可以参考《Android BT STACK BTU 和 HCI之间的消息传递》这篇文章。<br> 到此绑定的流程就结束了。有一个遗留问题就是绑定状态是如何返回给上层的呢？<br> 5 配对状态改变的回传</p> 
<p>上文我们在bta里面调用/system/bt/bta/dm/bta_dm_act.cc里面的bta_dm_bond方法，进行配对，这个方法里面有这样一段代码：<br> bta_dm_cb.p_sec_cback(BTA_DM_AUTH_CMPL_EVT, &amp;sec_event);</p> 
<p>这个就是bta的回调函数，回调事件是BTA_DM_AUTH_CMPL_EVT，根据这个事件标志，我们找到了 /system/bt/btif/src/btif_dm.cc里面的btif_dm_upstreams_evt方法，这个方法就是用于向上层回调消息的，相关代码是：<br> case BTA_DM_AUTH_CMPL_EVT:<br> btif_dm_auth_cmpl_evt(&amp;p_data-&gt;auth_cmpl);<br> break;</p> 
<p>可以看到是调用这个函数，返回配对完成的事件，这个函数代码很多这里就不引用了，无论配对成功还是失败，这里都会用 bond_state_changed这个方法进行处理：<br> static void bond_state_changed(bt_status_t status, const RawAddress&amp; bd_addr,<br> bt_bond_state_t state) {<!-- --><br> btif_stats_add_bond_event(bd_addr, BTIF_DM_FUNC_BOND_STATE_CHANGED, state);</p> 
<pre><code>// Send bonding state only once - based on outgoing/incoming we may receive
// duplicates
if ((pairing_cb.state == state) &amp;&amp; (state == BT_BOND_STATE_BONDING)) {
  // Cross key pairing so send callback for static address
  if (!pairing_cb.static_bdaddr.IsEmpty()) {
    auto tmp = bd_addr;
    HAL_CBACK(bt_hal_cbacks, bond_state_changed_cb, status, &amp;tmp, state);
  }
  return;
}

if (pairing_cb.bond_type == BOND_TYPE_TEMPORARY) state = BT_BOND_STATE_NONE;

BTIF_TRACE_DEBUG("%s: state=%d, prev_state=%d, sdp_attempts = %d", __func__,
                 state, pairing_cb.state, pairing_cb.sdp_attempts);

auto tmp = bd_addr;
HAL_CBACK(bt_hal_cbacks, bond_state_changed_cb, status, &amp;tmp, state);

if (state == BT_BOND_STATE_BONDING) {
  pairing_cb.state = state;
  pairing_cb.bd_addr = bd_addr;
} else if ((state == BT_BOND_STATE_NONE) &amp;&amp;
    ((bd_addr == pairing_cb.bd_addr) ||
    (bd_addr == pairing_cb.static_bdaddr))) {
   memset(&amp;pairing_cb, 0, sizeof(pairing_cb));
}else{
  if ((!pairing_cb.sdp_attempts)&amp;&amp;
        ((bd_addr == pairing_cb.bd_addr) ||
        (bd_addr == pairing_cb.static_bdaddr)))
    memset(&amp;pairing_cb, 0, sizeof(pairing_cb));
  else
    BTIF_TRACE_DEBUG("%s: BR-EDR service discovery active", __func__);
}
</code></pre> 
<p>}</p> 
<p>可以发现也是通过HAL_CBACK(bt_hal_cbacks, bond_state_changed_cb, status, &amp;tmp, state);这样的方法进行回调的，bond_state_changed_cb这个函数在bluetooth.h被定义对应的是com_android_bluetooth_btservice_AdapterService.cpp里的bond_state_changed_callback，关键代码如下：<br> sCallbackEnv-&gt;CallVoidMethod(sJniCallbacksObj, method_bondStateChangeCallback,<br> (jint)status, addr.get(), (jint)state);</p> 
<p>这里将bondStateChangeCallback方法对应到jni的method_bondStateChangeCallback方法<br> jclass jniCallbackClass =<br> env-&gt;FindClass(“com/android/bluetooth/btservice/JniCallbacks”);<br> …省略…<br> method_bondStateChangeCallback =<br> env-&gt;GetMethodID(jniCallbackClass, “bondStateChangeCallback”, “(I[BI)V”);</p> 
<p>就找到了JniCallbacks.java里面的bondStateChangeCallback方法<br> void bondStateChangeCallback(int status, byte[] address, int newState) {<!-- --><br> mBondStateMachine.bondStateChangeCallback(status, address, newState);<br> }</p> 
<p>接下来便进入了/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/BondStateMachine.java状态机里面：<br> void bondStateChangeCallback(int status, byte[] address, int newState) {<!-- --><br> BluetoothDevice device = mRemoteDevices.getDevice(address);</p> 
<pre><code>      if (device == null) {
          infoLog("No record of the device:" + device);
          // This device will be added as part of the BONDING_STATE_CHANGE intent processing
          // in sendIntent above
          device = mAdapter.getRemoteDevice(Utils.getAddressStringFromByte(address));
      }

      infoLog("bondStateChangeCallback: Status: " + status + " Address: " + device
              + " newState: " + newState);

      Message msg = obtainMessage(BONDING_STATE_CHANGE);
      msg.obj = device;

      if (newState == BOND_STATE_BONDED)
          msg.arg1 = BluetoothDevice.BOND_BONDED;
      else if (newState == BOND_STATE_BONDING)
          msg.arg1 = BluetoothDevice.BOND_BONDING;
      else
          msg.arg1 = BluetoothDevice.BOND_NONE;
      msg.arg2 = status;

      sendMessage(msg);
  }
</code></pre> 
<p>状态机里面通过sendMessage进行配对状态的变更。<br> 到此，配对流程就分析结束了。</p> 
<p>作者：猫疏<br> 链接：https://www.jianshu.com/p/0b748b11fa62<br> 来源：简书<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5556a9066b789864561b6978869c5e00/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">“八皇后问题”之回溯法——C&#43;&#43;实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a4335d39e322dd7d0198689735f4aa2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43; 中的 Unicode 与 UTF-8 字符编码互转</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>