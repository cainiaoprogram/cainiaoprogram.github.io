<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LVS的FULLNAT模式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LVS的FULLNAT模式" />
<meta property="og:description" content="LVS的FULLNAT模式
fullnat模式原理：
fullnat模式和nat模式比较类似，客户端的请求和响应都会经过lvs，不同的是nat模式下转换仅存在于目的方向，也就是说客户端的发来的请求经过lvs后，请求的目的ip会转化成rs的ip地址，目的端口会转化成rs的目的端口，而在fullnat模式下，客户端发来的请求的源ip和源端口都会被转换成lvs的内网ip地址和端口，同理对于rs回复的响应，nat模式下，响应的目的ip和目的端口均为客户端的，而fullnat模式下，响应的目的ip和目的端口均为lvs内网的，这样lvs收到这个响应后会将源ip和源端口转换成vip的地址和端口，目的ip和目的端口会被转换成客户端的ip地址和端口，也就是说在nat模式下对于客户端的请求仅发生DNAT转换，对于RS的响应仅发生SNAT转换，而fullnat模式下，在请求和响应上都会发生SNAT和DNAT转换；另一点不同是nat模式下要求lvs的内网ip和rs的ip地址在同一网段，lvs和rs之间需要二层交换设备，而fullnat对于请求和响应都会发生DNAT和SNAT所以lvs的内网ip地址可以和rs不再同一网段，这样lvs和rs之间就需要三层交换设备，所以相对于nat模式，fullnat的部署会更加灵活，它不要求lvs的内网ip和rs的ip在同一网段，下边做实验来模拟一下fullnat模式的过程：
安装过程：
fullnat模式的内核版本比较低，所以安装最好在centos6下进行，这里不能使用原来的通过yum安装的ipvsadm，而是需要编译安装经过阿里改造后的，所以需要卸载原来的ipvsadm
1. 下载内核rpm包
wget ftp://ftp.redhat.com/pub/redhat/linux/enterprise/6Server/en/os/SRPMS/kernel-2.6.32-220.23.1.el6.src.rpm
2. 在root目录下
vim ~/.rpmmacros;
并添加
%_topdir /home/pukong/rpms
%_tmppath /home/pukong/rpms/tmp
%_sourcedir /home/pukong/rpms/SOURCES
%_specdir /home/pukong/rpms/SPECS
%_srcrpmdir /home/pukong/rpms/SRPMS
%_rpmdir /home/pukong/rpms/RPMS
%_builddir /home/pukong/rpms/BUILD
这样可以把rpm安装到/home/pukong路径下
3. 安装rpm包，安装rpm-build
rpm -ivh kernel-2.6.32-220.23.1.el6.src.rpm
cd /home/pukong/rpms/SPECS
yum install rpm-build
rpmbuild -bp kernel.spec
这样就可以在/home/pukong/rpms/BUILD目录里看到内核的源码了
4. 安装lvs补丁
从http://kb.linuxvirtualserver.org/images/a/a5/Lvs-fullnat-synproxy.tar.gz下载Lvs-fullnat-synproxy.tar.gz然后解压，将解压后的里边的lvs-2.6.32-220.23.1.el6.patch补丁拷贝到/home/pukong/rpms/BUILD/路径下，并执行patch -p1&lt;lvs-2.6.32-220.23.1.el6.patch命令
5. 安装依赖并在/home/pukong/rpms/BUILD目录里编译安装内核
yum install -y xmlto gcc-c&#43;&#43; rpm-build patchutils asciidoc elfutils-libelf-devel zlib-devel binutils-devel newt-devel python-devel hmaccalc perl\(ExtUtils::Embed\) rng-tools lrzsz openssl-devel popt-devel
make" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b655f1766bda686b6a39c36df9b41095/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-23T10:19:41+08:00" />
<meta property="article:modified_time" content="2019-08-23T10:19:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LVS的FULLNAT模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;"><strong>LVS</strong><strong>的FULLNAT模式</strong></p> 
<p style="margin-left:0cm;"><strong>fullnat模式原理：</strong></p> 
<p><img alt="" class="has" height="353" src="https://images2.imgbox.com/2b/3d/Aizt46HN_o.png" width="554"></p> 
<p> </p> 
<p style="margin-left:0cm;">fullnat模式和nat模式比较类似，客户端的请求和响应都会经过lvs，不同的是nat模式下转换仅存在于目的方向，也就是说客户端的发来的请求经过lvs后，请求的目的ip会转化成rs的ip地址，目的端口会转化成rs的目的端口，而在fullnat模式下，客户端发来的请求的源ip和源端口都会被转换成lvs的内网ip地址和端口，同理对于rs回复的响应，nat模式下，响应的目的ip和目的端口均为客户端的，而fullnat模式下，响应的目的ip和目的端口均为lvs内网的，这样lvs收到这个响应后会将源ip和源端口转换成vip的地址和端口，目的ip和目的端口会被转换成客户端的ip地址和端口，也就是说在nat模式下对于客户端的请求仅发生DNAT转换，对于RS的响应仅发生SNAT转换，而fullnat模式下，在请求和响应上都会发生SNAT和DNAT转换；另一点不同是nat模式下要求lvs的内网ip和rs的ip地址在同一网段，lvs和rs之间需要二层交换设备，而fullnat对于请求和响应都会发生DNAT和SNAT所以lvs的内网ip地址可以和rs不再同一网段，这样lvs和rs之间就需要三层交换设备，所以相对于nat模式，fullnat的部署会更加灵活，它不要求lvs的内网ip和rs的ip在同一网段，下边做实验来模拟一下fullnat模式的过程：</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>安装过程：</strong></p> 
<p style="margin-left:0cm;">fullnat模式的内核版本比较低，所以安装最好在centos6下进行，这里不能使用原来的通过yum安装的ipvsadm，而是需要编译安装经过阿里改造后的，所以需要卸载原来的ipvsadm</p> 
<p style="margin-left:0cm;">1. 下载内核rpm包</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">wget ftp://ftp.redhat.com/pub/redhat/linux/enterprise/6Server/en/os/SRPMS/kernel-2.6.32-220.23.1.el6.src.rpm</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">2. 在root目录下</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">vim ~/.rpmmacros;</p> <p style="margin-left:0cm;">   并添加</p> <p style="margin-left:0cm;">     %_topdir /home/pukong/rpms</p> <p style="margin-left:0cm;">     %_tmppath /home/pukong/rpms/tmp</p> <p style="margin-left:0cm;">     %_sourcedir /home/pukong/rpms/SOURCES</p> <p style="margin-left:0cm;">     %_specdir /home/pukong/rpms/SPECS</p> <p style="margin-left:0cm;">     %_srcrpmdir /home/pukong/rpms/SRPMS</p> <p style="margin-left:0cm;">     %_rpmdir /home/pukong/rpms/RPMS</p> <p style="margin-left:0cm;">     %_builddir /home/pukong/rpms/BUILD</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">这样可以把rpm安装到/home/pukong路径下</p> 
<p style="margin-left:0cm;">3. 安装rpm包，安装rpm-build</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">rpm -ivh kernel-2.6.32-220.23.1.el6.src.rpm</p> <p style="margin-left:0cm;">cd /home/pukong/rpms/SPECS</p> <p style="margin-left:0cm;">yum install rpm-build</p> <p style="margin-left:0cm;">rpmbuild -bp kernel.spec</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">这样就可以在/home/pukong/rpms/BUILD目录里看到内核的源码了</p> 
<p style="margin-left:0cm;">4. 安装lvs补丁</p> 
<p style="margin-left:0cm;">从http://kb.linuxvirtualserver.org/images/a/a5/Lvs-fullnat-synproxy.tar.gz下载Lvs-fullnat-synproxy.tar.gz然后解压，将解压后的里边的lvs-2.6.32-220.23.1.el6.patch补丁拷贝到/home/pukong/rpms/BUILD/路径下，并执行patch -p1&lt;lvs-2.6.32-220.23.1.el6.patch命令</p> 
<p style="margin-left:0cm;">5. 安装依赖并在/home/pukong/rpms/BUILD目录里编译安装内核</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">yum install -y xmlto gcc-c++ rpm-build patchutils asciidoc elfutils-libelf-devel zlib-devel binutils-devel newt-devel python-devel hmaccalc perl\(ExtUtils::Embed\)  rng-tools lrzsz openssl-devel popt-devel</p> <p style="margin-left:0cm;">make</p> <p style="margin-left:0cm;">make modules_install</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">6. 重启切换内核然后再切换到/home/pukong/rpms/BUILD目录里执行make install命令，这样lvs内核模块就安装完成了</p> 
<p style="margin-left:0cm;">7. 切换到Lvs-fullnat-synproxy.tar.gz文件里，解压lvs-tools.tar.gz，编译安装lvs的各种工具</p> 
<p style="margin-left:0cm;">keepalived</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">./configure --with-kernel-dir="/lib/modules/`uname -r`/build"</p> <p style="margin-left:0cm;">make</p> <p style="margin-left:0cm;">make install</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">ipvsadm</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">make;</p> <p style="margin-left:0cm;">make install;</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">quaage</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">./configure --disable-ripd --disable-ripngd --disable-bgpd --disable-watchquagga --disable-doc  --enable-user=root --enable-vty-group=root --enable-group=root --enable-zebra --localstatedir=/var/run/quagga</p> <p style="margin-left:0cm;">make</p> <p style="margin-left:0cm;">make install</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>实验拓扑：</strong></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="242" src="https://images2.imgbox.com/2a/a9/XWiU0Sgc_o.png" width="554"></p> 
<p style="margin-left:0cm;"><strong>实验步骤：</strong></p> 
<p style="margin-left:0cm;">1. 配置各虚拟机IP地址以及路由</p> 
<p style="margin-left:0cm;">centos7各网卡的ip直接用ifconfig配置即可，但是centos6虚拟机里没有网卡的配置文件，所以使用ifconfig配置网卡的ip地址的时候过一段时间就失效了，所以需要手动添加网卡的配置文件</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="228" src="https://images2.imgbox.com/10/22/8FA6Xxyh_o.png" width="340"></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="232" src="https://images2.imgbox.com/8c/a0/QhDhvFQ9_o.png" width="517"></p> 
<p style="margin-left:0cm;">文件放在/etc/sysconfig/network-scripts里，文件创建完成后要重启网络服务，然后需要配置路由器端口的ip地址以及路由表，这里记录一下路由器一个端口的ip地址的配置过程和配置rip协议的过程</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="84" src="https://images2.imgbox.com/98/e4/ycCtV9yV_o.png" width="753"></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="78" src="https://images2.imgbox.com/8e/c8/E4IsldZp_o.png" width="223"></p> 
<p style="margin-left:0cm;">然后需要在lvs和两个rs上配置路由，首先在lvs虚拟机上配置</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="38" src="https://images2.imgbox.com/62/91/4FUfmDbA_o.png" width="482"></p> 
<p style="margin-left:0cm;">两个RS在两个子网中，所以要添加两条路由，然后在RS上添加一条路由即可</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="25" src="https://images2.imgbox.com/51/c9/7zY9ln71_o.png" width="475"></p> 
<p style="margin-left:0cm;">这样整个网络就打通了</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">2. 用ipvsadm添加lvs服务，并在两个RS上开启http服务</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="88" src="https://images2.imgbox.com/11/dd/o7m5qcW3_o.png" width="383"></p> 
<p style="margin-left:0cm;">首先清空ipvsadm已有的服务，然后用-A选项添加一个服务，然后添加两个RS，-b代表开启fullnat模式，最后一条命令是指SNAT转换的IP地址，也就是客户端的请求经过lvs的转换后源ip地址转换成10.0.3.1也就是lvs的eth1的ip地址，这里为了体现端口转换的效果，将两个RS的http的服务开启在8080端口上</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="84" src="https://images2.imgbox.com/64/39/RQz0PrOQ_o.png" width="547"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">3. 在客户端上用curl命令即可看到效果</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="289" src="https://images2.imgbox.com/ea/7c/1VojWkp7_o.png" width="276"></p> 
<p style="margin-left:0cm;"><strong>抓包分析过程（以请求到web1为例）：</strong></p> 
<p style="margin-left:0cm;">首先在client与lvs之间的链路抓包</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="203" src="https://images2.imgbox.com/82/3d/oyIemlfF_o.png" width="1200"></p> 
<p style="margin-left:0cm;">这是一个完整的http的请求过程，来看第一个syn数据包</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="107" src="https://images2.imgbox.com/e5/c3/FSQ6MFJr_o.png" width="823"></p> 
<p style="margin-left:0cm;">可以看到，这个数据包的源ip是客户端的ip，目的ip是lvs的eth0的ip地址（vip），源端口是50026，目的端口是vip的端口，这个数据包经过lvs转换后，会变成这样</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="101" src="https://images2.imgbox.com/f2/34/5ULscLhl_o.png" width="820"></p> 
<p style="margin-left:0cm;">可以看到这个syn数据包的源ip是lvs的eth1的ip地址，目的ip转换成了web1的ip地址，并且源端口从客户端发来的50026端口转换成了5014端口，目的端口也转换成了web1的http服务的端口，所以从这里就可以看到了fullnat和nat模式的区别了，nat模式的转换仅仅存在于目的方向，也就是可以实现对目的ip和目的端口的转换，但是源ip和源端口一直都是客户端的源ip和端口，并且转换后的目的ip可以和lvs的ip地址不在同一个子网中，所以和nat模式相比fullnat不能使用二层交换设备来实现负载均衡了，而是需要三层交换设备，并且对于源ip和源端口的转换，也能够让RS的响应通过路由器回复给lvs，这样就增加了灵活性，不要求lvs和RS必须在同一个网段中，转换后的这个数据包会被路由器转发到web1上，web1收到这个数据包后会产生syn,ack数据包</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="113" src="https://images2.imgbox.com/5d/c5/vsQTej1f_o.png" width="817"></p> 
<p style="margin-left:0cm;">可以看到这个数据包的源ip是web1的ip，源端口是8080，目的ip是lvs的ip地址，目的端口也是lvs的5014端口，这个处理逻辑和nat模式也是一样的，RS上不会对数据包做出什么改变，而是仅仅将发来的请求的数据包的源ip和源端口作为响应的目的ip和目的端口返回回去，只不过这个请求的源ip和源端口已经被lvs转换了，这样这个响应包会经过路由器转发给lvs，并且会被lvs转换，转换后的syn,ack数据包为</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="99" src="https://images2.imgbox.com/ad/7d/Mo3WPx1m_o.png" width="800"></p> 
<p style="margin-left:0cm;">可以看到源ip被转换成vip，源端口也从8080端口转化为80端口，目的ip从lvs的ip地址转化成了客户端的ip地址，目的端口从lvs的5014端口转换成了客户端最初的syn请求的源端口50026这样，客户端就能够收到这个数据包并建立连接，后边的数据包的处理过程和这个过程是一样的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/433b1006df3afbc7fb2783d43b7388dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LVS的NAT模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ffb2f2cce849ad087c7b5c5f65aeb136/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">建议看一下，零基础学Python都想问的6个问题，老司机给你两千字解答</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>