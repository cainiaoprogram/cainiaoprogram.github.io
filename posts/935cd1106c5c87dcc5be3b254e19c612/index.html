<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>rabbitMQ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="rabbitMQ" />
<meta property="og:description" content="文章目录
RabbitMQ实战教程
1.什么是MQ
2.RabbitMQ
2.1.RabbitMQ的简介
2.2.官网
2.3.MQ的其他产品
2.4.学习5种队列
2.5.安装文档
3.搭建RabbitMQ环境
3.1.下载
3.2.windows下安装
3.3.Linux下安装
3.4.安装的注意事项
3.5.安装完成后操作
4.添加用户
4.1.添加admin用户
4.2.用户角色
4.3.创建Virtual Hosts
4.4.管理界面中的功能
5.学习五种队列
5.1.导入my-rabbitmq项目
5.2.简单队列
5.3.Work模式
5.4.Work模式的“能者多劳”
5.5.消息的确认模式
5.6.订阅模式
5.7.路由模式
5.8.主题模式（通配符模式）
6.Spring-Rabbit
6.1.Spring项目
6.2.简介
6.3.使用
6.4.持久化交换机和队列
7.Spring集成RabbitMQ一个完整案例
7.1.在A系统中发送消息到交换机
7.2.在B系统接收消息
7.3.在C系统中接收消息
8.Springboot集成RabbitMQ
8.1.简单队列
8.2.多对多使用（Work模式）
8.3.Topic Exchange（主题模式）
8.4.Fanout Exchange（订阅模式）
9.总结
RabbitMQ实战教程
1.什么是MQ
消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。
其主要用途：不同进程Process/线程Thread之间通信。
为什么会产生消息队列？有几个原因：
不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；
不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列；
关于消息队列的详细介绍请参阅：
《Java帝国之消息队列》
《一个故事告诉你什么是消息队列》
《到底什么时候该使用MQ》
MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。
本教程pdf及代码下载地址：
代码：https://download.csdn.net/download/zpcandzhj/10585077
教程：https://download.csdn.net/download/zpcandzhj/10585092
2.RabbitMQ
2.1.RabbitMQ的简介
这里写图片描述
开发语言：Erlang – 面向并发的编程语言。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/935cd1106c5c87dcc5be3b254e19c612/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-25T14:59:46+08:00" />
<meta property="article:modified_time" content="2019-03-25T14:59:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">rabbitMQ</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>文章目录</p> 
<p>        RabbitMQ实战教程<br>             1.什么是MQ<br>             2.RabbitMQ<br>                 2.1.RabbitMQ的简介<br>                 2.2.官网<br>                 2.3.MQ的其他产品<br>                 2.4.学习5种队列<br>                 2.5.安装文档<br>             3.搭建RabbitMQ环境<br>                 3.1.下载<br>                 3.2.windows下安装<br>                 3.3.Linux下安装<br>                 3.4.安装的注意事项<br>                 3.5.安装完成后操作<br>             4.添加用户<br>                 4.1.添加admin用户<br>                 4.2.用户角色<br>                 4.3.创建Virtual Hosts<br>                 4.4.管理界面中的功能<br>             5.学习五种队列<br>                 5.1.导入my-rabbitmq项目<br>                 5.2.简单队列<br>                 5.3.Work模式<br>                 5.4.Work模式的“能者多劳”<br>                 5.5.消息的确认模式<br>                 5.6.订阅模式<br>                 5.7.路由模式<br>                 5.8.主题模式（通配符模式）<br>             6.Spring-Rabbit<br>                 6.1.Spring项目<br>                 6.2.简介<br>                 6.3.使用<br>                 6.4.持久化交换机和队列<br>             7.Spring集成RabbitMQ一个完整案例<br>                 7.1.在A系统中发送消息到交换机<br>                 7.2.在B系统接收消息<br>                 7.3.在C系统中接收消息<br>             8.Springboot集成RabbitMQ<br>                 8.1.简单队列<br>                 8.2.多对多使用（Work模式）<br>                 8.3.Topic Exchange（主题模式）<br>                 8.4.Fanout Exchange（订阅模式）<br>             9.总结</p> 
<p>RabbitMQ实战教程<br> 1.什么是MQ</p> 
<p>    消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。<br>     其主要用途：不同进程Process/线程Thread之间通信。</p> 
<p>为什么会产生消息队列？有几个原因：</p> 
<p>    不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；</p> 
<p>    不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列；</p> 
<p>    关于消息队列的详细介绍请参阅：<br>     《Java帝国之消息队列》<br>     《一个故事告诉你什么是消息队列》<br>     《到底什么时候该使用MQ》</p> 
<p>    MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。</p> 
<p>    本教程pdf及代码下载地址：<br>     代码：https://download.csdn.net/download/zpcandzhj/10585077<br>     教程：https://download.csdn.net/download/zpcandzhj/10585092</p> 
<p>2.RabbitMQ<br> 2.1.RabbitMQ的简介</p> 
<p>这里写图片描述<br> 开发语言：Erlang – 面向并发的编程语言。</p> 
<p>这里写图片描述</p> 
<p>2.1.1.AMQP<br> AMQP是消息队列的一个协议。</p> 
<p>这里写图片描述<br> 2.2.官网</p> 
<p>这里写图片描述<br> 2.3.MQ的其他产品</p> 
<p>这里写图片描述<br> 2.4.学习5种队列</p> 
<p>这里写图片描述<br> 2.5.安装文档</p> 
<p>这里写图片描述<br> 3.搭建RabbitMQ环境<br> 3.1.下载</p> 
<p>下载地址：http://www.rabbitmq.com/download.html<br> 3.2.windows下安装</p> 
<p>3.2.1.安装Erlang<br> 下载：http://www.erlang.org/download/otp_win64_17.3.exe<br> 安装：<br> 这里写图片描述<br> 这里写图片描述<br> 这里写图片描述<br> 这里写图片描述<br> 这里写图片描述<br> 安装完成。</p> 
<p>3.2.2.安装RabbitMQ<br> 这里写图片描述<br> 这里写图片描述<br> 这里写图片描述<br> 安装完成。</p> 
<p>开始菜单里出现如下选项：<br> 这里写图片描述</p> 
<p>启动、停止、重新安装等。</p> 
<p>3.2.3.启用管理工具<br> 1、双击这里写图片描述<br> 2、进入C:\Program Files (x86)\RabbitMQ Server\rabbitmq_server-3.4.1\sbin输入命令：<br> rabbitmq-plugins enable rabbitmq_management<br> 这里写图片描述</p> 
<p>这样就启动了管理工具，可以试一下命令：<br> 停止：net stop RabbitMQ<br> 启动：net start RabbitMQ</p> 
<p>3、在浏览器中输入地址查看：http://127.0.0.1:15672/<br> 这里写图片描述<br> 4、使用默认账号登录：guest/ guest<br> 3.3.Linux下安装</p> 
<p>3.3.1.安装Erlang<br> 3.3.2.添加yum支持<br> cd /usr/local/src/<br> mkdir rabbitmq<br> cd rabbitmq</p> 
<p>wget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm<br> rpm -Uvh erlang-solutions-1.0-1.noarch.rpm</p> 
<p>rpm --import http://packages.erlang-solutions.com/rpm/erlang_solutions.asc</p> 
<p>使用yum安装：<br> sudo yum install erlang<br> 这里写图片描述</p> 
<p>3.3.3.安装RabbitMQ<br> 上传rabbitmq-server-3.4.1-1.noarch.rpm文件到/usr/local/src/rabbitmq/<br> 安装：<br> rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm</p> 
<p>3.3.4.启动、停止<br> service rabbitmq-server start<br> service rabbitmq-server stop<br> service rabbitmq-server restart<br> 3.3.5.设置开机启动<br> chkconfig rabbitmq-server on<br> 3.3.6.设置配置文件<br> cd /etc/rabbitmq<br> cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/</p> 
<p>mv rabbitmq.config.example rabbitmq.config<br> 3.3.7.开启用户远程访问<br> vi /etc/rabbitmq/rabbitmq.config<br> 这里写图片描述<br> 注意要去掉后面的逗号。<br> 3.3.8.开启web界面管理工具<br> rabbitmq-plugins enable rabbitmq_management<br> service rabbitmq-server restart<br> 3.3.9.防火墙开放15672端口<br> /sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT<br> /etc/rc.d/init.d/iptables save<br> 3.4.安装的注意事项</p> 
<p>1、推荐使用默认的安装路径<br> 2、系统用户名必须是英文<br> Win10改名字非常麻烦，具体方法百度<br> 这里写图片描述<br> 3、计算机名必须是英文<br> 这里写图片描述<br> 4、系统的用户必须是管理员</p> 
<p>如果安装失败应该如何解决：<br> 1、重装系统 – 不推荐<br> 2、将RabbitMQ安装到linux虚拟机中<br> a)推荐<br> 3、使用别人安装好的RabbitMQ服务<br> a)只要给你开通一个账户即可。<br> b)使用公用的RabbitMQ服务，在192.168.50.22<br> c)推荐</p> 
<p>常见错误：<br> 这里写图片描述<br> 3.5.安装完成后操作</p> 
<p>1、系统服务中有RabbitMQ服务，停止、启动、重启<br> 这里写图片描述<br> 2、打开命令行工具<br> 这里写图片描述<br> 如果找不到命令行工具,直接cd到相应目录：<br> 这里写图片描述<br> 输入命令rabbitmq-plugins enable rabbitmq_management启用管理插件<br> 这里写图片描述<br> 查看管理页面<br> 这里写图片描述<br> 通过默认账户 guest/guest 登录<br> 如果能够登录，说明安装成功。<br> 这里写图片描述<br> 4.添加用户<br> 4.1.添加admin用户</p> 
<p>这里写图片描述<br> 4.2.用户角色</p> 
<p>1、超级管理员(administrator)<br> 可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。<br> 2、监控者(monitoring)<br> 可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)<br> 3、策略制定者(policymaker)<br> 可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。<br> 4、普通管理者(management)<br> 仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。<br> 5、其他<br> 无法登陆管理控制台，通常就是普通的生产者和消费者。<br> 4.3.创建Virtual Hosts</p> 
<p>这里写图片描述</p> 
<p>选中Admin用户，设置权限：<br> 这里写图片描述<br> 看到权限已加：<br> 这里写图片描述<br> 4.4.管理界面中的功能</p> 
<p>这里写图片描述</p> 
<p>这里写图片描述<br> 5.学习五种队列</p> 
<p>这里写图片描述<br> 5.1.导入my-rabbitmq项目</p> 
<p>项目下载地址：<br> https://download.csdn.net/download/zpcandzhj/10585077<br> 这里写图片描述<br> 5.2.简单队列</p> 
<p>5.2.1.图示<br> 这里写图片描述</p> 
<p>P：消息的生产者<br> C：消息的消费者<br> 红色：队列</p> 
<p>生产者将消息发送到队列，消费者从队列中获取消息。<br> 5.2.2.导入RabbitMQ的客户端依赖</p> 
<p>&lt;dependency&gt;<br>    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;<br>    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;<br>    &lt;version&gt;3.4.1&lt;/version&gt;<br> &lt;/dependency&gt;</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5</p> 
<p>5.2.3.获取MQ的连接</p> 
<p>package com.zpc.rabbitmq.util;<br> import com.rabbitmq.client.ConnectionFactory;<br> import com.rabbitmq.client.Connection;</p> 
<p>public class ConnectionUtil {<!-- --></p> 
<p>    public static Connection getConnection() throws Exception {<!-- --><br>         //定义连接工厂<br>         ConnectionFactory factory = new ConnectionFactory();<br>         //设置服务地址<br>         factory.setHost("localhost");<br>         //端口<br>         factory.setPort(5672);<br>         //设置账号信息，用户名、密码、vhost<br>         factory.setVirtualHost("testhost");<br>         factory.setUsername("admin");<br>         factory.setPassword("admin");<br>         // 通过工程获取连接<br>         Connection connection = factory.newConnection();<br>         return connection;<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22</p> 
<p>5.2.4.生产者发送消息到队列</p> 
<p>package com.zpc.rabbitmq.simple;</p> 
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p> 
<p>import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;</p> 
<p>public class Send {<!-- --></p> 
<p>    private final static String QUEUE_NAME = "q_test_01";</p> 
<p>    public static void main(String[] argv) throws Exception {<!-- --><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         // 从连接中创建通道<br>         Channel channel = connection.createChannel();</p> 
<p>        // 声明（创建）队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);</p> 
<p>        // 消息内容<br>         String message = "Hello World!";<br>         channel.basicPublish("", QUEUE_NAME, null, message.getBytes());<br>         System.out.println(" [x] Sent '" + message + "'");<br>         //关闭通道和连接<br>         channel.close();<br>         connection.close();<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29</p> 
<p>5.2.5.管理工具中查看消息<br> 这里写图片描述</p> 
<p>点击上面的队列名称，查询具体的队列中的信息：<br> 这里写图片描述<br> 5.2.6.消费者从队列中获取消息</p> 
<p>package com.zpc.rabbitmq.simple;</p> 
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p> 
<p>import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;</p> 
<p>public class Recv {<!-- --></p> 
<p>    private final static String QUEUE_NAME = "q_test_01";</p> 
<p>    public static void main(String[] argv) throws Exception {<!-- --></p> 
<p>        // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         // 从连接中创建通道<br>         Channel channel = connection.createChannel();<br>         // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);</p> 
<p>        // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);</p> 
<p>        // 监听队列<br>         channel.basicConsume(QUEUE_NAME, true, consumer);</p> 
<p>        // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [x] Received '" + message + "'");<br>         }<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35</p> 
<p>5.3.Work模式</p> 
<p>这里写图片描述</p> 
<p>5.3.1.图示<br> 这里写图片描述</p> 
<p>一个生产者、2个消费者。</p> 
<p>一个消息只能被一个消费者获取。<br> 5.3.2.消费者1</p> 
<p>package com.zpc.rabbitmq.work;</p> 
<p>import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;<br> import com.zpc.rabbitmq.util.ConnectionUtil;</p> 
<p>public class Recv {<!-- --></p> 
<p>    private final static String QUEUE_NAME = "test_queue_work";</p> 
<p>    public static void main(String[] argv) throws Exception {<!-- --></p> 
<p>        // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();</p> 
<p>        // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);</p> 
<p>        // 同一时刻服务器只会发一条消息给消费者<br>         //channel.basicQos(1);</p> 
<p>        // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，false表示手动返回完成状态，true表示自动<br>         channel.basicConsume(QUEUE_NAME, true, consumer);</p> 
<p>        // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [y] Received '" + message + "'");<br>             //休眠<br>             Thread.sleep(10);<br>             // 返回确认状态，注释掉表示使用自动确认模式<br>             //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40</p> 
<p>5.3.3.消费者2</p> 
<p>package com.zpc.rabbitmq.work;</p> 
<p>import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;<br> import com.zpc.rabbitmq.util.ConnectionUtil;</p> 
<p>public class Recv2 {<!-- --></p> 
<p>    private final static String QUEUE_NAME = "test_queue_work";</p> 
<p>    public static void main(String[] argv) throws Exception {<!-- --></p> 
<p>        // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();</p> 
<p>        // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);</p> 
<p>        // 同一时刻服务器只会发一条消息给消费者<br>         //channel.basicQos(1);</p> 
<p>        // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，false表示手动返回完成状态，true表示自动<br>         channel.basicConsume(QUEUE_NAME, true, consumer);</p> 
<p>        // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [x] Received '" + message + "'");<br>             // 休眠1秒<br>             Thread.sleep(1000);<br>             //下面这行注释掉表示使用自动确认模式<br>             //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40</p> 
<p>5.3.4.生产者<br> 向队列中发送100条消息。</p> 
<p>package com.zpc.rabbitmq.work;</p> 
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p> 
<p>import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;</p> 
<p>public class Send {<!-- --></p> 
<p>    private final static String QUEUE_NAME = "test_queue_work";</p> 
<p>    public static void main(String[] argv) throws Exception {<!-- --><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();</p> 
<p>        // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);</p> 
<p>        for (int i = 0; i &lt; 100; i++) {<!-- --><br>             // 消息内容<br>             String message = "" + i;<br>             channel.basicPublish("", QUEUE_NAME, null, message.getBytes());<br>             System.out.println(" [x] Sent '" + message + "'");</p> 
<p>            Thread.sleep(i * 10);<br>         }</p> 
<p>        channel.close();<br>         connection.close();<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32</p> 
<p>5.3.5.测试<br> 测试结果：<br> 1、消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。<br> 2、消费者1和消费者2获取到的消息的数量是相同的，一个是消费奇数号消息，一个是偶数。</p> 
<p>    其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。<br>     RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。</p> 
<p>    怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。<br>     basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。</p> 
<p>    2个概念</p> 
<p>    轮询分发 ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。</p> 
<p>    公平分发 ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。</p> 
<p>为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。<br> 还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。<br> 5.4.Work模式的“能者多劳”</p> 
<p>打开上述代码的注释：</p> 
<p>// 同一时刻服务器只会发一条消息给消费者<br> channel.basicQos(1);</p> 
<p>    1<br>     2</p> 
<p>//开启这行 表示使用手动确认模式<br> channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</p> 
<p>    1<br>     2</p> 
<p>同时改为手动确认：</p> 
<p>// 监听队列，false表示手动返回完成状态，true表示自动<br> channel.basicConsume(QUEUE_NAME, false, consumer);</p> 
<p>    1<br>     2</p> 
<p>测试：<br> 消费者1比消费者2获取的消息更多。<br> 5.5.消息的确认模式</p> 
<p>消费者从队列中获取消息，服务端如何知道消息已经被消费呢？</p> 
<p>模式1：自动确认<br> 只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。<br> 模式2：手动确认<br> 消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态。</p> 
<p>手动模式：<br> 这里写图片描述</p> 
<p>自动模式：<br> 这里写图片描述<br> 5.6.订阅模式</p> 
<p>这里写图片描述<br> 5.6.1.图示<br> 这里写图片描述</p> 
<p>解读：<br> 1、1个生产者，多个消费者<br> 2、每一个消费者都有自己的一个队列<br> 3、生产者没有将消息直接发送到队列，而是发送到了交换机<br> 4、每个队列都要绑定到交换机<br> 5、生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的<br> 注意：一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费<br> 这里写图片描述</p> 
<p>5.6.2.消息的生产者（看作是后台系统）<br> 向交换机中发送消息。</p> 
<p>package com.zpc.rabbitmq.subscribe;</p> 
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p> 
<p>import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;</p> 
<p>public class Send {<!-- --></p> 
<p>    private final static String EXCHANGE_NAME = "test_exchange_fanout";</p> 
<p>    public static void main(String[] argv) throws Exception {<!-- --><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();</p> 
<p>        // 声明exchange<br>         channel.exchangeDeclare(EXCHANGE_NAME, "fanout");</p> 
<p>        // 消息内容<br>         String message = "Hello World!";<br>         channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes());<br>         System.out.println(" [x] Sent '" + message + "'");</p> 
<p>        channel.close();<br>         connection.close();<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28</p> 
<p>注意：消息发送到没有队列绑定的交换机时，消息将丢失，因为，交换机没有存储消息的能力，消息只能存在在队列中。<br> 5.6.3.消费者1（看作是前台系统）</p> 
<p>package com.zpc.rabbitmq.subscribe;</p> 
<p>import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;</p> 
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p> 
<p>public class Recv {<!-- --></p> 
<p>    private final static String QUEUE_NAME = "test_queue_work1";</p> 
<p>    private final static String EXCHANGE_NAME = "test_exchange_fanout";</p> 
<p>    public static void main(String[] argv) throws Exception {<!-- --></p> 
<p>        // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();</p> 
<p>        // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);</p> 
<p>        // 绑定队列到交换机<br>         channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "");</p> 
<p>        // 同一时刻服务器只会发一条消息给消费者<br>         channel.basicQos(1);</p> 
<p>        // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，手动返回完成<br>         channel.basicConsume(QUEUE_NAME, false, consumer);</p> 
<p>        // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [Recv] Received '" + message + "'");<br>             Thread.sleep(10);</p> 
<p>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40<br>     41<br>     42<br>     43<br>     44<br>     45</p> 
<p>5.6.4.消费者2（看作是搜索系统）</p> 
<p>package com.zpc.rabbitmq.subscribe;</p> 
<p>import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;</p> 
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p> 
<p>public class Recv2 {<!-- --></p> 
<p>    private final static String QUEUE_NAME = "test_queue_work2";</p> 
<p>    private final static String EXCHANGE_NAME = "test_exchange_fanout";</p> 
<p>    public static void main(String[] argv) throws Exception {<!-- --></p> 
<p>        // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();</p> 
<p>        // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);</p> 
<p>        // 绑定队列到交换机<br>         channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "");</p> 
<p>        // 同一时刻服务器只会发一条消息给消费者<br>         channel.basicQos(1);</p> 
<p>        // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，手动返回完成<br>         channel.basicConsume(QUEUE_NAME, false, consumer);</p> 
<p>        // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [Recv2] Received '" + message + "'");<br>             Thread.sleep(10);</p> 
<p>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40<br>     41<br>     42<br>     43<br>     44<br>     45</p> 
<p>5.6.5.测试<br> 测试结果：<br> 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。</p> 
<p>在管理工具中查看队列和交换机的绑定关系：</p> 
<p>这里写图片描述<br> 5.7.路由模式</p> 
<p>这里写图片描述<br> 5.7.1.图示<br> 这里写图片描述</p> 
<p>5.7.2.生产者<br> 这里写图片描述<br> 5.7.3.消费者1(假设是前台系统)<br> 这里写图片描述<br> 5.7.4.消费2（假设是搜索系统）<br> 这里写图片描述<br> 5.8.主题模式（通配符模式）</p> 
<p>这里写图片描述</p> 
<p>这里写图片描述</p> 
<p>5.8.1.图示<br> 这里写图片描述<br> 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。</p> 
<p>5.8.2.生产者</p> 
<p>package com.zpc.rabbitmq.topic;</p> 
<p>import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;</p> 
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p> 
<p>public class Send {<!-- --></p> 
<p>    private final static String EXCHANGE_NAME = "test_exchange_topic";</p> 
<p>    public static void main(String[] argv) throws Exception {<!-- --><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();</p> 
<p>        // 声明exchange<br>         channel.exchangeDeclare(EXCHANGE_NAME, "topic");</p> 
<p>        // 消息内容<br>         String message = "Hello World!!";<br>         channel.basicPublish(EXCHANGE_NAME, "routekey.1", null, message.getBytes());<br>         System.out.println(" [x] Sent '" + message + "'");</p> 
<p>        channel.close();<br>         connection.close();<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28</p> 
<p>5.8.3.消费者1（前台系统）</p> 
<p>package com.zpc.rabbitmq.topic;</p> 
<p>import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;</p> 
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p> 
<p>public class Recv {<!-- --></p> 
<p>    private final static String QUEUE_NAME = "test_queue_topic_work_1";</p> 
<p>    private final static String EXCHANGE_NAME = "test_exchange_topic";</p> 
<p>    public static void main(String[] argv) throws Exception {<!-- --></p> 
<p>        // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();</p> 
<p>        // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);</p> 
<p>        // 绑定队列到交换机<br>         channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "routekey.*");</p> 
<p>        // 同一时刻服务器只会发一条消息给消费者<br>         channel.basicQos(1);</p> 
<p>        // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，手动返回完成<br>         channel.basicConsume(QUEUE_NAME, false, consumer);</p> 
<p>        // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [Recv_x] Received '" + message + "'");<br>             Thread.sleep(10);</p> 
<p>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40<br>     41<br>     42<br>     43<br>     44<br>     45</p> 
<p>5.8.4.消费者2（搜索系统）</p> 
<p>package com.zpc.rabbitmq.topic;</p> 
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p> 
<p>import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;</p> 
<p>public class Recv2 {<!-- --></p> 
<p>    private final static String QUEUE_NAME = "test_queue_topic_work_2";</p> 
<p>    private final static String EXCHANGE_NAME = "test_exchange_topic";</p> 
<p>    public static void main(String[] argv) throws Exception {<!-- --></p> 
<p>        // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();</p> 
<p>        // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);</p> 
<p>        // 绑定队列到交换机<br>         channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "*.*");</p> 
<p>        // 同一时刻服务器只会发一条消息给消费者<br>         channel.basicQos(1);</p> 
<p>        // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，手动返回完成<br>         channel.basicConsume(QUEUE_NAME, false, consumer);</p> 
<p>        // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [Recv2_x] Received '" + message + "'");<br>             Thread.sleep(10);</p> 
<p>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40<br>     41<br>     42<br>     43<br>     44<br>     45</p> 
<p>6.Spring-Rabbit<br> 6.1.Spring项目</p> 
<p>http://spring.io/projects</p> 
<p>这里写图片描述<br> 6.2.简介</p> 
<p>这里写图片描述<br> 这里写图片描述<br> 6.3.使用</p> 
<p>6.3.1.消费者</p> 
<p>package com.zpc.rabbitmq.spring;</p> 
<p>/**<br>  * 消费者<br>  *<br>  * @author Evan<br>  */<br> public class Foo {<!-- --></p> 
<p>    //具体执行业务的方法<br>     public void listen(String foo) {<!-- --><br>         System.out.println("\n消费者： " + foo + "\n");<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14</p> 
<p>6.3.2.生产者</p> 
<p>package com.zpc.rabbitmq.spring;</p> 
<p>import org.springframework.amqp.rabbit.core.RabbitTemplate;<br> import org.springframework.context.support.AbstractApplicationContext;<br> import org.springframework.context.support.ClassPathXmlApplicationContext;</p> 
<p>public class SpringMain {<!-- --><br>     public static void main(final String... args) throws Exception {<!-- --><br>         AbstractApplicationContext ctx = new ClassPathXmlApplicationContext(<br>                 "classpath:spring/rabbitmq-context.xml");<br>         //RabbitMQ模板<br>         RabbitTemplate template = ctx.getBean(RabbitTemplate.class);<br>         //发送消息<br>         template.convertAndSend("Hello, 鸟鹏!");<br>         Thread.sleep(1000);// 休眠1秒<br>         ctx.destroy(); //容器销毁<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18</p> 
<p>6.3.3.配置文件<br> 1、定义连接工厂</p> 
<p>&lt;!-- 定义RabbitMQ的连接工厂 --&gt;<br> &lt;rabbit:connection-factory id="connectionFactory"<br>    host="127.0.0.1" port="5672" username="admin" password="admin"<br>    virtual-host="testhost" /&gt;</p> 
<p>    1<br>     2<br>     3<br>     4</p> 
<p>2、定义模板（可以指定交换机或队列）</p> 
<p>&lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="fanoutExchange" /&gt;</p> 
<p>    1</p> 
<p>3、定义队列、交换机、以及完成队列和交换机的绑定</p> 
<p>&lt;!-- 定义队列，自动声明 --&gt;<br> &lt;rabbit:queue name="zpcQueue" auto-declare="true"/&gt;</p> 
<p>&lt;!-- 定义交换器，把Q绑定到交换机，自动声明 --&gt;<br> &lt;rabbit:fanout-exchange name="fanoutExchange" auto-declare="true"&gt;<br>    &lt;rabbit:bindings&gt;<br>       &lt;rabbit:binding queue="zpcQueue"/&gt;<br>    &lt;/rabbit:bindings&gt;<br> &lt;/rabbit:fanout-exchange&gt;</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9</p> 
<p>4、定义监听</p> 
<p>&lt;rabbit:listener-container connection-factory="connectionFactory"&gt;<br>    &lt;rabbit:listener ref="foo" method="listen" queue-names="zpcQueue" /&gt;<br> &lt;/rabbit:listener-container&gt;</p> 
<p>&lt;bean id="foo" class="com.zpc.rabbitmq.spring.Foo" /&gt;</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5</p> 
<p>5、定义管理，用于管理队列、交换机等：</p> 
<p>&lt;!-- MQ的管理，包括队列、交换器等 --&gt;<br> &lt;rabbit:admin connection-factory="connectionFactory" /&gt;</p> 
<p>    1<br>     2</p> 
<p>完整配置文件rabbitmq-context.xml</p> 
<p>&lt;beans xmlns="http://www.springframework.org/schema/beans"<br>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit"<br>    xsi:schemaLocation="http://www.springframework.org/schema/rabbit<br>    http://www.springframework.org/schema/rabbit/spring-rabbit-1.4.xsd<br>    http://www.springframework.org/schema/beans<br>    http://www.springframework.org/schema/beans/spring-beans-4.1.xsd"&gt;</p> 
<p>   &lt;!-- 定义RabbitMQ的连接工厂 --&gt;<br>    &lt;rabbit:connection-factory id="connectionFactory"<br>       host="127.0.0.1" port="5672" username="admin" password="admin"<br>       virtual-host="testhost" /&gt;</p> 
<p>   &lt;!-- 定义Rabbit模板，指定连接工厂以及定义exchange --&gt;<br>    &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="fanoutExchange" /&gt;<br>    &lt;!-- &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory"<br>       exchange="fanoutExchange" routing-key="foo.bar" /&gt; --&gt;</p> 
<p>   &lt;!-- MQ的管理，包括队列、交换器等 --&gt;<br>    &lt;rabbit:admin connection-factory="connectionFactory" /&gt;</p> 
<p>   &lt;!-- 定义队列，自动声明 --&gt;<br>    &lt;rabbit:queue name="zpcQueue" auto-declare="true"/&gt;<br>    <br>    &lt;!-- 定义交换器，把Q绑定到交换机，自动声明 --&gt;<br>    &lt;rabbit:fanout-exchange name="fanoutExchange" auto-declare="true"&gt;<br>       &lt;rabbit:bindings&gt;<br>          &lt;rabbit:binding queue="zpcQueue"/&gt;<br>       &lt;/rabbit:bindings&gt;<br>    &lt;/rabbit:fanout-exchange&gt;<br>    <br> &lt;!--   &lt;rabbit:topic-exchange name="myExchange"&gt;<br>       &lt;rabbit:bindings&gt;<br>          &lt;rabbit:binding queue="myQueue" pattern="foo.*" /&gt;<br>       &lt;/rabbit:bindings&gt;<br>    &lt;/rabbit:topic-exchange&gt; --&gt;</p> 
<p>   &lt;!-- 队列监听 --&gt;<br>    &lt;rabbit:listener-container connection-factory="connectionFactory"&gt;<br>       &lt;rabbit:listener ref="foo" method="listen" queue-names="zpcQueue" /&gt;<br>    &lt;/rabbit:listener-container&gt;</p> 
<p>   &lt;bean id="foo" class="com.zpc.rabbitmq.spring.Foo" /&gt;</p> 
<p>&lt;/beans&gt;</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40<br>     41<br>     42<br>     43<br>     44</p> 
<p>6.4.持久化交换机和队列</p> 
<p>这里写图片描述</p> 
<p>持久化：将交换机或队列的数据保存到磁盘，服务器宕机或重启之后依然存在。<br> 非持久化：将交换机或队列的数据保存到内存，服务器宕机或重启之后将不存在。</p> 
<p>非持久化的性能高于持久化。</p> 
<p>如何选择持久化？非持久化？ – 看需求。<br> 7.Spring集成RabbitMQ一个完整案例</p> 
<p>创建三个系统A,B,C<br> A作为生产者，B、C作为消费者(B,C作为web项目启动)<br> 项目下载地址：https://download.csdn.net/download/zpcandzhj/10585077<br> 7.1.在A系统中发送消息到交换机</p> 
<p>7.1.1.导入依赖</p> 
<p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br>    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</p> 
<p>   &lt;groupId&gt;com.zpc&lt;/groupId&gt;<br>    &lt;artifactId&gt;myrabbitA&lt;/artifactId&gt;<br>    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br>    &lt;packaging&gt;jar&lt;/packaging&gt;<br>    &lt;name&gt;myrabbit&lt;/name&gt;</p> 
<p>   &lt;dependencies&gt;<br>       &lt;dependency&gt;<br>          &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;<br>          &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;<br>          &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;<br>       &lt;/dependency&gt;</p> 
<p>      &lt;dependency&gt;<br>          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>          &lt;artifactId&gt;fastjson&lt;/artifactId&gt;<br>          &lt;version&gt;1.2.47&lt;/version&gt;<br>       &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br> &lt;/project&gt;</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25</p> 
<p>7.1.2.队列和交换机的绑定关系<br> 实现：<br> 1、在配置文件中将队列和交换机完成绑定<br> 2、可以在管理界面中完成绑定<br> a)绑定关系如果发生变化，需要修改配置文件，并且服务需要重启<br> b)管理更加灵活<br> c)更容易对绑定关系的权限管理，流程管理<br> 本例选择第2种方式<br> 7.1.3.配置<br> rabbitmq-context.xml</p> 
<p>&lt;beans xmlns="http://www.springframework.org/schema/beans"<br>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit"<br>    xsi:schemaLocation="http://www.springframework.org/schema/rabbit<br>    http://www.springframework.org/schema/rabbit/spring-rabbit-1.4.xsd<br>    http://www.springframework.org/schema/beans<br>    http://www.springframework.org/schema/beans/spring-beans-4.1.xsd"&gt;</p> 
<p>   &lt;!-- 定义RabbitMQ的连接工厂 --&gt;<br>    &lt;rabbit:connection-factory id="connectionFactory"<br>       host="127.0.0.1" port="5672" username="admin" password="admin"<br>       virtual-host="testhost" /&gt;</p> 
<p>   &lt;!-- MQ的管理，包括队列、交换器等 --&gt;<br>    &lt;rabbit:admin connection-factory="connectionFactory" /&gt;</p> 
<p>   &lt;!-- 定义交换器，暂时不把Q绑定到交换机，在管理界面去绑定 --&gt;<br>    &lt;!--&lt;rabbit:topic-exchange name="topicExchange" auto-declare="true" &gt;&lt;/rabbit:topic-exchange&gt;--&gt;<br>    &lt;rabbit:direct-exchange name="directExchange" auto-declare="true" &gt;&lt;/rabbit:direct-exchange&gt;<br>    &lt;!--&lt;rabbit:fanout-exchange name="fanoutExchange" auto-declare="true" &gt;&lt;/rabbit:fanout-exchange&gt;--&gt;</p> 
<p>   &lt;!-- 定义Rabbit模板，指定连接工厂以及定义exchange(exchange要和上面的一致) --&gt;<br>    &lt;!--&lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="topicExchange" /&gt;--&gt;<br>    &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="directExchange" /&gt;<br>    &lt;!--&lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="fanoutExchange" /&gt;--&gt;<br> &lt;/beans&gt;</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25</p> 
<p>7.1.4.消息内容<br> 方案：<br> 1、消息内容使用对象做json序列化发送<br> a)数据大<br> b)有些数据其他人是可能用不到的<br> 2、发送特定的业务字段，如id、操作类型</p> 
<p>7.1.5.实现<br> 生产者MsgSender.java：</p> 
<p>package com.zpc.myrabbit;</p> 
<p>import com.alibaba.fastjson.JSON;<br> import org.springframework.amqp.rabbit.core.RabbitTemplate;<br> import org.springframework.context.support.AbstractApplicationContext;<br> import org.springframework.context.support.ClassPathXmlApplicationContext;</p> 
<p>import java.text.SimpleDateFormat;<br> import java.util.Date;<br> import java.util.HashMap;<br> import java.util.Map;</p> 
<p><br> /**<br>  * 消息生产者<br>  */<br> public class MsgSender {<!-- --><br>     public static void main(String[] args) throws Exception {<!-- --><br>         AbstractApplicationContext ctx = new ClassPathXmlApplicationContext(<br>                 "classpath:spring/rabbitmq-context.xml");<br>         //RabbitMQ模板<br>         RabbitTemplate template = ctx.getBean(RabbitTemplate.class);</p> 
<p>        String date = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());//24小时制<br>         //发送消息<br>         Map&lt;String, Object&gt; msg = new HashMap&lt;String, Object&gt;();<br>         msg.put("type", "1");<br>         msg.put("date", date);<br>         template.convertAndSend("type2", JSON.toJSONString(msg));<br>         Thread.sleep(1000);// 休眠1秒<br>         ctx.destroy(); //容器销毁<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33</p> 
<p>7.2.在B系统接收消息</p> 
<p>7.2.1.导入依赖</p> 
<p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br>          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br>     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</p> 
<p>    &lt;groupId&gt;com.zpc&lt;/groupId&gt;<br>     &lt;artifactId&gt;myrabbitB&lt;/artifactId&gt;<br>     &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br>     &lt;packaging&gt;war&lt;/packaging&gt;</p> 
<p>    &lt;name&gt;myrabbit&lt;/name&gt;<br>     &lt;properties&gt;<br>         &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt;<br>         &lt;fastjson.version&gt;1.2.46&lt;/fastjson.version&gt;<br>     &lt;/properties&gt;</p> 
<p>    &lt;dependencies&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;<br>             &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;<br>             &lt;version&gt;3.4.1&lt;/version&gt;<br>         &lt;/dependency&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;<br>             &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;<br>             &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;<br>         &lt;/dependency&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>             &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;<br>             &lt;version&gt;${spring.version}&lt;/version&gt;<br>         &lt;/dependency&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>             &lt;artifactId&gt;fastjson&lt;/artifactId&gt;<br>             &lt;version&gt;1.2.47&lt;/version&gt;<br>         &lt;/dependency&gt;<br>     &lt;/dependencies&gt;</p> 
<p>    &lt;build&gt;<br>         &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;<br>         &lt;plugins&gt;<br>             &lt;!-- web层需要配置Tomcat插件 --&gt;<br>             &lt;plugin&gt;<br>                 &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;<br>                 &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;<br>                 &lt;configuration&gt;<br>                     &lt;path&gt;/testRabbit&lt;/path&gt;<br>                     &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;<br>                     &lt;port&gt;8081&lt;/port&gt;<br>                 &lt;/configuration&gt;<br>             &lt;/plugin&gt;<br>         &lt;/plugins&gt;<br>     &lt;/build&gt;<br> &lt;/project&gt;</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40<br>     41<br>     42<br>     43<br>     44<br>     45<br>     46<br>     47<br>     48<br>     49<br>     50<br>     51<br>     52<br>     53<br>     54<br>     55</p> 
<p>7.2.2.配置</p> 
<p>&lt;beans xmlns="http://www.springframework.org/schema/beans"<br>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit"<br>    xsi:schemaLocation="http://www.springframework.org/schema/rabbit<br>    http://www.springframework.org/schema/rabbit/spring-rabbit-1.4.xsd<br>    http://www.springframework.org/schema/beans<br>    http://www.springframework.org/schema/beans/spring-beans-4.1.xsd"&gt;</p> 
<p>   &lt;!-- 定义RabbitMQ的连接工厂 --&gt;<br>    &lt;rabbit:connection-factory id="connectionFactory"<br>       host="127.0.0.1" port="5672" username="admin" password="admin"<br>       virtual-host="testhost" /&gt;</p> 
<p>   &lt;!-- MQ的管理，包括队列、交换器等 --&gt;<br>    &lt;rabbit:admin connection-factory="connectionFactory" /&gt;</p> 
<p>   &lt;!-- 定义B系统需要监听的队列，自动声明 --&gt;<br>    &lt;rabbit:queue name="q_topic_testB" auto-declare="true"/&gt;</p> 
<p>   &lt;!-- 队列监听 --&gt;<br>    &lt;rabbit:listener-container connection-factory="connectionFactory"&gt;<br>       &lt;rabbit:listener ref="myMQlistener" method="listen" queue-names="q_topic_testB" /&gt;<br>    &lt;/rabbit:listener-container&gt;</p> 
<p>   &lt;bean id="myMQlistener" class="com.zpc.myrabbit.listener.Listener" /&gt;<br> &lt;/beans&gt;</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25</p> 
<p>7.2.3.具体处理逻辑</p> 
<p>public class Listener {<!-- --><br>     //具体执行业务的方法<br>     public void listen(String msg) {<!-- --><br>         System.out.println("\n消费者B开始处理消息： " + msg + "\n");<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6</p> 
<p>7.2.4.在界面管理工具中完成绑定关系<br> 选中定义好的交换机(exchange)<br> 这里写图片描述<br> 1）direct<br> 这里写图片描述<br> 2）fanout<br> 这里写图片描述<br> 3）topic<br> 这里写图片描述<br> 7.3.在C系统中接收消息</p> 
<p>（和B系统配置差不多，无非是Q名和Q对应的处理逻辑变了）</p> 
<p>7.3.1.配置</p> 
<p>&lt;beans xmlns="http://www.springframework.org/schema/beans"<br>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit"<br>    xsi:schemaLocation="http://www.springframework.org/schema/rabbit<br>    http://www.springframework.org/schema/rabbit/spring-rabbit-1.4.xsd<br>    http://www.springframework.org/schema/beans<br>    http://www.springframework.org/schema/beans/spring-beans-4.1.xsd"&gt;</p> 
<p>   &lt;!-- 定义RabbitMQ的连接工厂 --&gt;<br>    &lt;rabbit:connection-factory id="connectionFactory"<br>       host="127.0.0.1" port="5672" username="admin" password="admin"<br>       virtual-host="testhost" /&gt;</p> 
<p>   &lt;!-- MQ的管理，包括队列、交换器等 --&gt;<br>    &lt;rabbit:admin connection-factory="connectionFactory" /&gt;</p> 
<p>   &lt;!-- 定义C系统需要监听的队列，自动声明 --&gt;<br>    &lt;rabbit:queue name="q_topic_testC" auto-declare="true"/&gt;</p> 
<p>   &lt;!-- 队列监听 --&gt;<br>    &lt;rabbit:listener-container connection-factory="connectionFactory"&gt;<br>       &lt;rabbit:listener ref="myMQlistener" method="listen" queue-names="q_topic_testC" /&gt;<br>    &lt;/rabbit:listener-container&gt;</p> 
<p>   &lt;bean id="myMQlistener" class="com.zpc.myrabbit.listener.Listener" /&gt;<br> &lt;/beans&gt;</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25</p> 
<p>7.3.2.处理业务逻辑</p> 
<p>public class Listener {<!-- --></p> 
<p>    //具体执行业务的方法<br>     public void listen(String msg) {<!-- --><br>         System.out.println("\n消费者C开始处理消息： " + msg + "\n");<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7</p> 
<p>7.3.3.在管理工具中绑定队列和交换机<br> 见7.2.4</p> 
<p>7.3.4.测试<br> 分别启动B,C两个web应用，然后运行A的MsgSender主方法发送消息，分别测试fanout、direct、topic三种类型<br> 8.Springboot集成RabbitMQ</p> 
<p>    springboot集成RabbitMQ非常简单，如果只是简单的使用配置非常少，springboot提供了spring-boot-starter-amqp对消息各种支持。<br>     代码下载地址：https://download.csdn.net/download/zpcandzhj/10585077</p> 
<p>8.1.简单队列</p> 
<p>1、配置pom文件，主要是添加spring-boot-starter-amqp的支持</p> 
<p>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br> &lt;/dependency&gt;</p> 
<p>    1<br>     2<br>     3<br>     4</p> 
<p>2、配置application.properties文件<br> 配置rabbitmq的安装地址、端口以及账户信息</p> 
<p>spring.application.name=spirng-boot-rabbitmq<br> spring.rabbitmq.host=127.0.0.1<br> spring.rabbitmq.port=5672<br> spring.rabbitmq.username=admin<br> spring.rabbitmq.password=admin</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5</p> 
<p>3、配置队列</p> 
<p>package com.zpc.rabbitmq;</p> 
<p>import org.springframework.amqp.core.Queue;<br> import org.springframework.context.annotation.Bean;<br> import org.springframework.context.annotation.Configuration;</p> 
<p>@Configuration<br> public class RabbitConfig {<!-- --><br>     @Bean<br>     public Queue queue() {<!-- --><br>         return new Queue("q_hello");<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13</p> 
<p>4、发送者</p> 
<p>package com.zpc.rabbitmq;</p> 
<p>import org.springframework.amqp.core.AmqpTemplate;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.stereotype.Component;</p> 
<p>import java.text.SimpleDateFormat;<br> import java.util.Date;</p> 
<p>@Component<br> public class HelloSender {<!-- --><br>     @Autowired<br>     private AmqpTemplate rabbitTemplate;</p> 
<p>    public void send() {<!-- --><br>         String date = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());//24小时制<br>         String context = "hello " + date;<br>         System.out.println("Sender : " + context);<br>         //简单对列的情况下routingKey即为Q名<br>         this.rabbitTemplate.convertAndSend("q_hello", context);<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22</p> 
<p>5、接收者</p> 
<p>package com.zpc.rabbitmq;</p> 
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;</p> 
<p>@Component<br> @RabbitListener(queues = "q_hello")<br> public class HelloReceiver {<!-- --></p> 
<p>    @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("Receiver  : " + hello);<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15</p> 
<p>6、测试</p> 
<p>package com.zpc.rabbitmq;</p> 
<p>import org.junit.Test;<br> import org.junit.runner.RunWith;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.boot.test.context.SpringBootTest;<br> import org.springframework.test.context.junit4.SpringRunner;</p> 
<p>@RunWith(SpringRunner.class)<br> @SpringBootTest<br> public class RabbitMqHelloTest {<!-- --></p> 
<p>    @Autowired<br>     private HelloSender helloSender;</p> 
<p>    @Test<br>     public void hello() throws Exception {<!-- --><br>         helloSender.send();<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20</p> 
<p>8.2.多对多使用（Work模式）</p> 
<p>注册两个Receiver:</p> 
<p>package com.zpc.rabbitmq;</p> 
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;</p> 
<p>@Component<br> @RabbitListener(queues = "q_hello")<br> public class HelloReceiver2 {<!-- --></p> 
<p>    @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("Receiver2  : " + hello);<br>     }</p> 
<p>}</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16</p> 
<p>@Test<br> public void oneToMany() throws Exception {<!-- --><br>     for (int i=0;i&lt;100;i++){<!-- --><br>         helloSender.send(i);<br>         Thread.sleep(300);<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7</p> 
<p>public void send(int i) {<!-- --><br>     String date = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());//24小时制<br>     String context = "hello " + i + " " + date;<br>     System.out.println("Sender : " + context);<br>     //简单对列的情况下routingKey即为Q名<br>     this.rabbitTemplate.convertAndSend("q_hello", context);<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7</p> 
<p>8.3.Topic Exchange（主题模式）</p> 
<p>    topic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列</p> 
<p>首先对topic规则配置，这里使用两个队列(消费者)来演示。<br> 1)配置队列，绑定交换机</p> 
<p>package com.zpc.rabbitmq.topic;</p> 
<p>import org.springframework.amqp.core.Binding;<br> import org.springframework.amqp.core.BindingBuilder;<br> import org.springframework.amqp.core.Queue;<br> import org.springframework.amqp.core.TopicExchange;<br> import org.springframework.context.annotation.Bean;<br> import org.springframework.context.annotation.Configuration;</p> 
<p>@Configuration<br> public class TopicRabbitConfig {<!-- --></p> 
<p>    final static String message = "q_topic_message";<br>     final static String messages = "q_topic_messages";</p> 
<p>    @Bean<br>     public Queue queueMessage() {<!-- --><br>         return new Queue(TopicRabbitConfig.message);<br>     }</p> 
<p>    @Bean<br>     public Queue queueMessages() {<!-- --><br>         return new Queue(TopicRabbitConfig.messages);<br>     }</p> 
<p>    /**<br>      * 声明一个Topic类型的交换机<br>      * @return<br>      */<br>     @Bean<br>     TopicExchange exchange() {<!-- --><br>         return new TopicExchange("mybootexchange");<br>     }</p> 
<p>    /**<br>      * 绑定Q到交换机,并且指定routingKey<br>      * @param queueMessage<br>      * @param exchange<br>      * @return<br>      */<br>     @Bean<br>     Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) {<!-- --><br>         return BindingBuilder.bind(queueMessage).to(exchange).with("topic.message");<br>     }</p> 
<p>    @Bean<br>     Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) {<!-- --><br>         return BindingBuilder.bind(queueMessages).to(exchange).with("topic.#");<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40<br>     41<br>     42<br>     43<br>     44<br>     45<br>     46<br>     47<br>     48<br>     49<br>     50</p> 
<p>2)创建2个消费者<br> q_topic_message 和q_topic_messages</p> 
<p>package com.zpc.rabbitmq.topic;</p> 
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;</p> 
<p>@Component<br> @RabbitListener(queues = "q_topic_message")<br> public class Receiver1 {<!-- --></p> 
<p>    @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("Receiver1  : " + hello);<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15</p> 
<p>package com.zpc.rabbitmq.topic;</p> 
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;</p> 
<p>@Component<br> @RabbitListener(queues = "q_topic_messages")<br> public class Receiver2 {<!-- --></p> 
<p>    @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("Receiver2 : " + hello);<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15</p> 
<p>3)消息发送者（生产者）</p> 
<p>package com.zpc.rabbitmq.topic;</p> 
<p>import org.springframework.amqp.core.AmqpTemplate;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.stereotype.Component;</p> 
<p>@Component<br> public class MsgSender {<!-- --></p> 
<p>    @Autowired<br>     private AmqpTemplate rabbitTemplate;</p> 
<p>    public void send1() {<!-- --><br>         String context = "hi, i am message 1";<br>         System.out.println("Sender : " + context);<br>         this.rabbitTemplate.convertAndSend("mybootexchange", "topic.message", context);<br>     }</p> 
<p><br>     public void send2() {<!-- --><br>         String context = "hi, i am messages 2";<br>         System.out.println("Sender : " + context);<br>         this.rabbitTemplate.convertAndSend("mybootexchange", "topic.messages", context);<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25</p> 
<p>send1方法会匹配到topic.#和topic.message，两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息。<br> 4)测试</p> 
<p>package com.zpc.rabbitmq.topic;</p> 
<p>import org.junit.Test;<br> import org.junit.runner.RunWith;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.boot.test.context.SpringBootTest;<br> import org.springframework.test.context.junit4.SpringRunner;</p> 
<p>@RunWith(SpringRunner.class)<br> @SpringBootTest<br> public class RabbitTopicTest {<!-- --></p> 
<p>    @Autowired<br>     private MsgSender msgSender;</p> 
<p>    @Test<br>     public void send1() throws Exception {<!-- --><br>         msgSender.send1();<br>     }</p> 
<p>    @Test<br>     public void send2() throws Exception {<!-- --><br>         msgSender.send2();<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25</p> 
<p>8.4.Fanout Exchange（订阅模式）</p> 
<p>    Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。<br>     1)配置队列，绑定交换机</p> 
<p>package com.zpc.rabbitmq.fanout;</p> 
<p>import org.springframework.amqp.core.Binding;<br> import org.springframework.amqp.core.BindingBuilder;<br> import org.springframework.amqp.core.FanoutExchange;<br> import org.springframework.amqp.core.Queue;<br> import org.springframework.context.annotation.Bean;<br> import org.springframework.context.annotation.Configuration;</p> 
<p>@Configuration<br> public class FanoutRabbitConfig {<!-- --></p> 
<p>    @Bean<br>     public Queue aMessage() {<!-- --><br>         return new Queue("q_fanout_A");<br>     }</p> 
<p>    @Bean<br>     public Queue bMessage() {<!-- --><br>         return new Queue("q_fanout_B");<br>     }</p> 
<p>    @Bean<br>     public Queue cMessage() {<!-- --><br>         return new Queue("q_fanout_C");<br>     }</p> 
<p>    @Bean<br>     FanoutExchange fanoutExchange() {<!-- --><br>         return new FanoutExchange("mybootfanoutExchange");<br>     }</p> 
<p>    @Bean<br>     Binding bindingExchangeA(Queue aMessage, FanoutExchange fanoutExchange) {<!-- --><br>         return BindingBuilder.bind(aMessage).to(fanoutExchange);<br>     }</p> 
<p>    @Bean<br>     Binding bindingExchangeB(Queue bMessage, FanoutExchange fanoutExchange) {<!-- --><br>         return BindingBuilder.bind(bMessage).to(fanoutExchange);<br>     }</p> 
<p>    @Bean<br>     Binding bindingExchangeC(Queue cMessage, FanoutExchange fanoutExchange) {<!-- --><br>         return BindingBuilder.bind(cMessage).to(fanoutExchange);<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40<br>     41<br>     42<br>     43<br>     44<br>     45<br>     46<br>     47</p> 
<p>2）创建3个消费者</p> 
<p>package com.zpc.rabbitmq.fanout;</p> 
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;</p> 
<p>@Component<br> @RabbitListener(queues = "q_fanout_A")<br> public class ReceiverA {<!-- --></p> 
<p>    @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("AReceiver  : " + hello + "/n");<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15</p> 
<p>package com.zpc.rabbitmq.fanout;</p> 
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;</p> 
<p>@Component<br> @RabbitListener(queues = "q_fanout_B")<br> public class ReceiverB {<!-- --></p> 
<p>    @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("BReceiver  : " + hello + "/n");<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15</p> 
<p>package com.zpc.rabbitmq.fanout;</p> 
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;</p> 
<p>@Component<br> @RabbitListener(queues = "q_fanout_C")<br> public class ReceiverC {<!-- --></p> 
<p>    @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("CReceiver  : " + hello + "/n");<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15</p> 
<p>3）生产者</p> 
<p>package com.zpc.rabbitmq.fanout;</p> 
<p>import org.springframework.amqp.core.AmqpTemplate;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.stereotype.Component;</p> 
<p>@Component<br> public class MsgSenderFanout {<!-- --></p> 
<p>    @Autowired<br>     private AmqpTemplate rabbitTemplate;</p> 
<p>    public void send() {<!-- --><br>         String context = "hi, fanout msg ";<br>         System.out.println("Sender : " + context);<br>         this.rabbitTemplate.convertAndSend("mybootfanoutExchange","", context);<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18</p> 
<p>4）测试</p> 
<p>package com.zpc.rabbitmq.fanout;</p> 
<p>import org.junit.Test;<br> import org.junit.runner.RunWith;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.boot.test.context.SpringBootTest;<br> import org.springframework.test.context.junit4.SpringRunner;</p> 
<p>@RunWith(SpringRunner.class)<br> @SpringBootTest<br> public class RabbitFanoutTest {<!-- --></p> 
<p>    @Autowired<br>     private MsgSenderFanout msgSender;</p> 
<p>    @Test<br>     public void send1() throws Exception {<!-- --><br>         msgSender.send();<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20</p> 
<p>结果如下，三个消费者都收到消息：<br> AReceiver : hi, fanout msg<br> CReceiver : hi, fanout msg<br> BReceiver : hi, fanout msg<br> 9.总结</p> 
<p>    使用MQ实现商品数据的同步优势：<br>     1、降低系统间耦合度<br>     2、便于管理数据的同步（数据一致性）</p> 
<p>    推荐阅读<br>     《RabbitMQ详解》<br>     《大型网站技术架构：核心原理与案例分析》<br> ---------------------<br> 作者：niaobirdfly<br> 来源：CSDN<br> 原文：https://blog.csdn.net/hellozpc/article/details/81436980<br> 版权声明：本文为博主原创文章，转载请附上博文链接！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13fffb8f3bd64b38d53d0ea608203668/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">hbase和hive的区别是什么？怎么区分两者之间的关系？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c0e622a135192d7d7d84158f678170f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（国内）计算机核心期刊排名及投稿经验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>