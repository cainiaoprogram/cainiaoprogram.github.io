<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Pytest之@pytest.mark.parametrize使用详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Pytest之@pytest.mark.parametrize使用详解" />
<meta property="og:description" content="以下内容纯属个人理解，如有不足，还请指正，转载请注明出处，喜欢请动动小指头点赞评论哦(▽)！
Fixture参数详解及使用
Fixture的调用方式：
参数详解：
1、SCOPE
scope = &#34;function&#34;
scope = &#34;class&#34;：
scope = &#34;module&#34;：与class相同，只从.py文件开始引用fixture的位置生效
scope = &#34;session&#34;：用法将在conftest.py文章内详细介绍
2、params:
3、ids:
4、autouse:
5、Name:
写在最后
Fixture的调用方式：
@pytest.fixture(scope = &#34;function&#34;,params=None,autouse=False,ids=None,name=None)
1
参数详解：
1、SCOPE
用于控制Fixture的作用范围
作用类似于Pytest的setup/teardown
默认取值为function（函数级别），控制范围的排序为：session &gt; module &gt; class &gt; function
取值 范围 说明
function 函数级 每一个函数或方法都会调用
class 类级别 每个测试类只运行一次
module 模块级 每一个.py文件调用一次
session 会话级 每次会话只需要运行一次，会话内所有方法及类，模块都共享这个方法
作用范围举例：
scope = “function”
语法：
@pytest.fixture() #或者
@pytest.fixture(scope=&#39;function&#39;)
1
2
3
场景一：做为参数传入
# -*- coding:utf-8 -*-" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/25303f890abf09095032264f377a1b55/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-14T21:36:22+08:00" />
<meta property="article:modified_time" content="2021-09-14T21:36:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Pytest之@pytest.mark.parametrize使用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>以下内容纯属个人理解，如有不足，还请指正，转载请注明出处，喜欢请动动小指头点赞评论哦(▽)！<br> Fixture参数详解及使用<br> Fixture的调用方式：<br> 参数详解：<br> 1、SCOPE<br> scope = "function"<br> scope = "class"：<br> scope = "module"：与class相同，只从.py文件开始引用fixture的位置生效<br> scope = "session"：用法将在conftest.py文章内详细介绍<br> 2、params:<br> 3、ids:<br> 4、autouse:<br> 5、Name:<br> 写在最后<br> Fixture的调用方式：<br> @pytest.fixture(scope = "function",params=None,autouse=False,ids=None,name=None)<br> 1<br> 参数详解：<br> 1、SCOPE<br> 用于控制Fixture的作用范围<br> 作用类似于Pytest的setup/teardown<br> 默认取值为function（函数级别），控制范围的排序为：session &gt; module &gt; class &gt; function<br> 取值    范围    说明<br> function    函数级    每一个函数或方法都会调用<br> class    类级别    每个测试类只运行一次<br> module    模块级    每一个.py文件调用一次<br> session    会话级    每次会话只需要运行一次，会话内所有方法及类，模块都共享这个方法<br> 作用范围举例：</p> 
<p>scope = “function”<br> 语法：</p> 
<p>@pytest.fixture() <br> #或者<br> @pytest.fixture(scope='function')<br> 1<br> 2<br> 3<br> 场景一：做为参数传入</p> 
<p># -*- coding:utf-8 -*-<br> '''<br> @Author     : 测试工程师Jane<br> @FileName   : d.py<br> @Description:<br> '''<br> import pytest<br> # fixture函数(类中) 作为多个参数传入<br> @pytest.fixture()<br> def login():<br>     print("打开浏览器")<br>     a = "account"<br>     return a<br>     <br> @pytest.fixture()<br> def logout():<br>     print("关闭浏览器")</p> 
<p>class TestLogin:<br>     #传入lonin fixture<br>     def test_001(self, login):<br>         print("001传入了loging fixture")<br>         assert login == "account"</p> 
<p>    #传入logout fixture<br>     def test_002(self, logout):<br>         print("002传入了logout fixture")</p> 
<p>    def test_003(self, login, logout):<br>         print("003传入了两个fixture")</p> 
<p>    def test_004(self):<br>         print("004未传入仍何fixture哦")</p> 
<p>if __name__ == '__main__':<br>     pytest.main()<br>  <br> 运行结果：</p> 
<p>从运行结果可以看出，fixture做为参数传入时，会在执行函数之前执行该fixture函数。再将值传入测试函数做为参数使用，这个场景多用于登录</p> 
<p>场景二、Fixture的相互调用<br> 代码：</p> 
<p># -*- coding:utf-8 -*-<br> '''<br> @Author     : 测试工程师Jane<br> @FileName   : e.py<br> @Description:<br> '''</p> 
<p>import pytest<br> # fixtrue作为参数，互相调用传入<br> @pytest.fixture()<br> def account():<br>     a = "account"<br>     print("第一层fixture")<br>     return a<br>     <br> #Fixture的相互调用一定是要在测试类里调用这层fixture才会生次，普通函数单独调用是不生效的<br> @pytest.fixture()   <br> def login(account):<br>     print("第二层fixture")</p> 
<p>class TestLogin:<br>     def test_1(self, login):<br>         print("直接使用第二层fixture,返回值为{}".format(login))</p> 
<p>    def test_2(self, account):<br>         print("只调用account fixture,返回值为{}".format(account))</p> 
<p><br> if __name__ == '__main__':<br>     pytest.main()<br>  <br>  <br> 运行结果：</p> 
<p>注：<br> 1.即使fixture之间支持相互调用，但普通函数直接使用fixture是不支持的，一定是在测试函数内调用才会逐级调用生效<br> 2.有多层fixture调用时，最先执行的是最后一层fixture，而不是先执行传入测试函数的fixture<br> 3.上层fixture的值不会自动return,这里就类似函数相互调用一样的逻辑</p> 
<p>scope = “class”：<br> 当测试类内的每一个测试方法都调用了fixture，fixture只在该class下所有测试用例执行前执行一次<br> 测试类下面只有一些测试方法使用了fixture函数名，这样的话，fixture只在该class下第一个使用fixture函数的测试用例位置开始算，后面所有的测试用例执行前只执行一次。而该位置之前的测试用例就不管。<br> 语法：</p> 
<p>@pytest.fixture(scope='class')<br> 1<br> 场景一、</p> 
<p># -*- coding:utf-8 -*-<br> '''<br> @Time       : 2020/12/28 19:56<br> @Author     : 测试工程师Jane<br> @FileName   : g.py<br> @Description:<br> '''</p> 
<p>import pytest<br> # fixture作用域 scope = 'class'<br> @pytest.fixture(scope='class')<br> def login():<br>     print("scope为class")</p> 
<p><br> class TestLogin:<br>     def test_1(self, login):<br>         print("用例1")</p> 
<p>    def test_2(self, login):<br>         print("用例2")</p> 
<p>    def test_3(self, login):<br>         print("用例3")</p> 
<p><br> if __name__ == '__main__':<br>     pytest.main()<br>  <br>  <br> 运行结果：</p> 
<p>场景二、</p> 
<p># -*- coding:utf-8 -*-<br> '''<br> @Author     : 测试工程师Jane<br> @FileName   : 1.py<br> @Description:<br> '''<br> import pytest<br> @pytest.fixture(scope='class')<br> def login():<br>     a = '123'<br>     print("输入账号密码登陆")</p> 
<p>class TestLogin:<br>     def test_1(self):<br>         print("用例1")</p> 
<p>    def test_2(self, login):<br>         print("用例2")</p> 
<p>    def test_3(self, login):<br>         print("用例3")</p> 
<p>    def test_4(self):<br>         print("用例4")</p> 
<p>if __name__ == '__main__':<br>     pytest.main()<br>  <br> 运行结果：</p> 
<p><br> scope = “module”：与class相同，只从.py文件开始引用fixture的位置生效<br> # -*- coding:utf-8 -*-<br> '''<br> @Author     : 测试工程师Jane<br> @FileName   : 2.py<br> @Description:<br> '''</p> 
<p>import pytest<br> # fixture scope = 'module'<br> @pytest.fixture(scope='module')<br> def login():<br>     print("fixture范围为module")</p> 
<p><br> def test_01():<br>     print("用例01")</p> 
<p><br> def test_02(login):<br>     print("用例02")</p> 
<p><br> class TestLogin():<br>     def test_1(self):<br>         print("用例1")</p> 
<p>    def test_2(self):<br>         print("用例2")</p> 
<p>    def test_3(self):<br>         print("用例3")</p> 
<p>if __name__ == '__main__':<br>     pytest.main()<br>  <br> 运行结果：</p> 
<p><br> scope = “session”：用法将在conftest.py文章内详细介绍<br> session的作用范围是针对.py级别的，module是对当前.py生效，seesion是对多个.py文件生效<br> session只作用于一个.py文件时，作用相当于module<br> 所以session多数与contest.py文件一起使用，做为全局Fixture<br> 2、params:<br> Fixture的可选形参列表，支持列表传入<br> 默认None，每个param的值<br> fixture都会去调用执行一次，类似for循环<br> 可与参数ids一起使用，作为每个参数的标识，详见ids<br> 被Fixture装饰的函数要调用是采用：Request.param(固定写法，如下图)<br> 举个栗子：</p> 
<p>3、ids:<br> 用例标识ID<br> 与params配合使用，一对一关系<br> 举个栗子：<br> 未配置ids之前，用例：</p> 
<p>配置了IDS后：</p> 
<p>4、autouse:<br> 默认False<br> 若为True，刚每个测试函数都会自动调用该fixture,无需传入fixture函数名<br> 由此我们可以总结出调用fixture的三种方式：<br> 　　1.函数或类里面方法直接传fixture的函数参数名称<br> 　　2.使用装饰器@pytest.mark.usefixtures()修饰<br> 　　3.autouse=True自动调用，无需传仍何参数，作用范围跟着scope走（谨慎使用）<br> 让我们来看一下，当autouse=ture的效果：</p> 
<p>5、Name:<br> fixture的重命名<br> 通常来说使用 fixture 的测试函数会将 fixture 的函数名作为参数传递，但是 pytest 也允许将fixture重命名<br> 如果使用了name,那只能将name传如，函数名不再生效<br> 调用方法：@pytest.mark.usefixtures(‘fixture1’,‘fixture2’)<br> 举栗：<br> # -*- coding:utf-8 -*-<br> '''<br> @Author     : 测试工程师Jane<br> @FileName   : nametest.py<br> '''<br> import pytest<br> @pytest.fixture(name="new_fixture")<br> def test_name():<br>     pass<br>     <br> #使用name参数后，传入重命名函数，执行成功<br> def test_1(new_fixture):<br>     print("使用name参数后，传入重命名函数，执行成功")</p> 
<p>#使用name参数后，仍传入函数名称，会失败<br> def test_2(test_name):<br>     print("使用name参数后，仍传入函数名称，会失败")<br>  <br> 运行结果：</p> 
<p><br> 写在最后<br> 以上为Fixture的部分使用详解，纯属个人理解，有部分内容参考此篇博文，感谢大佬的分享https://www.cnblogs.com/liudinglong/p/12885632.html<br> ————————————————<br> 版权声明：本文为CSDN博主「测试工程师Jane」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/totorobig/article/details/111823208</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/06677100273eafccc0819e7dd0e2c411/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LINUX学习------Linux自动化运维——REDIS</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e9f1c0c9e9c09477a1a437c559dfed5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML 5 video 视频标签全属性详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>