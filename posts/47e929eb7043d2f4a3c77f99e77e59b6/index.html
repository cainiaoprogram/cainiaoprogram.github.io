<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态规划——详解经典的完全背包与多重背包问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="动态规划——详解经典的完全背包与多重背包问题" />
<meta property="og:description" content="今天是算法数据结构专题的第13篇文章，也是动态规划专题的第二篇。
上一讲当中我们一起学习了动态规划算法中的零一背包问题，我们知道了所谓的零一背包是指每一种物品只有一个，所以它的状态只有0和1两种，即拿或者不拿。而今天我们要来讨论物品不止有一个的情况，物品不止有一个也分两种，一种是不作任何限制，要多少有多少，这种称为完全背包问题，另一种是依然有个数限制，这种称为多重背包问题。
我们一个一个来看，我们先从其中比较简单的完全背包开始。由于我们这是一个连续的专题，没有看过上篇文章或者是新关注的同学可以移步我们专题的第一篇：
动态规划入门——详解经典的零一背包问题
完全背包 在之前的文章当中，我们阐述了动态规划当中状态和决策以及状态转移的相关概念。在背包问题当中，背包的容量是状态，而选择哪个物品进行获取则是决策，当我们制定了一个决策之后，背包会从一个状态转移到另一个状态。而动态规划算法就是枚举所有状态和决策，获得所有的状态转移，并且记录这个过程中每个状态能够获得的最优解。
在之前的文章当中，我们先遍历了所有的决策，然后再枚举了所有的状态，计算在决策下进行转移之后得到的结果。在之前的零一背包问题当中，由于我们每个物品只能获取一个，如果在前面的状态执行了决策，那么后面的状态则不能进行相同的决策。这也就是动态规划的后效性，而在完全背包问题当中，我们去掉了这个限制，也就意味着决策之间不再有后效性，一个决策可以重复应用在各个状态当中。
所以如果你能理解上面这段话，那么整个算法其实非常简单，几乎就是零一背包的代码。只不过我们把其中倒叙遍历的背包状态再”修正“回来。
之前我们为了避免物品的重复获取，所以采用了倒叙遍历的方法，如今我们不再对数量进行限制，意味着我们可以自由地采取决策进行转移。要做到这点，就是单纯的两重循环，第一种枚举决策， 第二重枚举状态，记录所有转移可能带来的最优解即可。我们来看代码：
dp = [0 for _ in range(11)] items = [[6, 10], [5, 8], [5, 9]] # 遍历物品 for v, w in items: # 遍历背包空间（状态） # 更新vp&#43;v的状态，即当前容量放入物品之后的状态 for vp in range(0, 10-v&#43;1): dp[vp&#43;v] = max(dp[vp&#43;v], dp[vp] &#43; w) print(max(dp])) 如果你还没能完全理解其中的逻辑，我们可以对照一下代码再来理解一下。在第一种循环当中，我们遍历了所有的物品，每一个物品对应了一种决策。每一个决策可以应用在各个状态上，比如第一个物品是6， 15，代表它的体积是6，价值是15。那么我们遍历所有能够应用这个决策的状态，也就是在不超过背包容量的情况下能够放下的状态。显然对于一个体积是6的物品来说，只有0到4的状态可以放下。比如说我们选择状态2，状态2放下了这个物品之后，自然会转移到状态8，因为体积增加了6。有可能这个决策会使得状态8获得更好的结果，也有可能不会，如果会的话我们就更新一下状态8记录的值。这个从一个状态采取决策到另一个状态的过程就是状态转移。
完全背包就是零一背包的无限制版，从原理上来说，两者的思路和做法基本上是一样的。如果你能理解零一背包，那么完全背包对你来说也一定不在话下。
细小的优化 在完全背包当中，由于所有的物品都可以无限获取。所以我们可以引入一些零一背包不能进行的优化，比如对于同样体积的物品而言，我们可以只保留价值最高的物品，将其他的物品过滤掉。这个思路很朴素，我想大家应该都能理解。
比如两个物品体积都是3，一个价值是4，另一个价值是3，我们完全可以忽略价值是3的那一种。因为两者带来的状态转移是一样的，但是明显前者收益更好。而这个优化在零一背包当中不可行是因为每个物品只有一个，很有可能会出现两者都要的情况，所以不能简单地替换。而在完全背包当中则没有这个问题。
多重背包 和零一背包以及完全背包相比，多重背包要难上一些，它的解法也非常多样。我们今天先来看一些相对比较简单的方法。
同样，我们从最简单的方法开始讲起。最简单的方法当然就是将多重背包蜕化成零一背包来解决，比如一个物品最多可以拿N个，我们就把它拆成N种物品，这N种每种物品最多拿一个，相当于我们一种物品可以最多拿N个。这个思路应该很简单，大家都能想明白，但是有个很大的问题，就是复杂度。当然我们可以根据背包的体积做一些优化，比如当物品的数量很多并且超过了背包容量的时候，我们可以把超过容量的数量去掉，但是整体的复杂度还是很高。尤其是当我们背包容量很大的时候。
那么，我们怎么来解决这个问题呢？
这里要介绍一个比较通用的算法，这个算法可以用来优化很多问题，也是很多算法的思想。它就是二进制表示法。这个方法我们在之前的文章当中曾经讲到过，思想非常简单，但是非常实用。
二进制表示法 所谓二进制表示法就是将一个int类型的数表示成二进制，整个算法的思想就是这一句话，所以我想大家应该都能理解。但是我们为什么要将一个int转成二进制，以及转成二进制之后怎么样来优化算法，这个才是我们想知道的，也才是算法的核心重点，不要着急，我们一点点来说明。
我们都知道在计算机系统当中都是以二进制存储的所有数据，最典型的就是整数。一个32位的int，可以表示最大21亿的整数。这个都是我们已知的，但是换一个角度来看，一个21亿的数最后用32个二进制位就表示了，其实非常惊人。为什么说二进制是一个非常伟大的思想？不在于它难，而在于它高效地压缩了数据。
我们进一步来看，32个二进制位为什么能表示这么大的数据呢？因为这32位int表示的数据是不一样的，第0位表示1，第1位表示2，第2位表示4……到了第31位的时候，表示的数已经非常庞大。我们用这32个数不同的组合来表示不同的数，换句话说范围内的所有数最终都变成了这32个数中若干个的累加。我们写成公式就是： x = ∑ i = 0 31 a i ⋅ 2 i x = \sum_{i=0}^{31} a_i\cdot 2^i x=∑i=031​ai​⋅2i，这里的 a i a_i ai​表示的是第i位的系数，它只有0和1两个取值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/47e929eb7043d2f4a3c77f99e77e59b6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-26T08:37:02+08:00" />
<meta property="article:modified_time" content="2020-03-26T08:37:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态规划——详解经典的完全背包与多重背包问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>今天是<strong>算法数据结构专题的第13篇</strong>文章，也是动态规划专题的第二篇。</p> 
<p>上一讲当中我们一起学习了动态规划算法中的零一背包问题，我们知道了所谓的零一背包是指每一种物品只有一个，所以它的状态只有0和1两种，即拿或者不拿。而今天我们要来讨论物品不止有一个的情况，物品不止有一个也分两种，一种是不作任何限制，要多少有多少，这种称为完全背包问题，另一种是依然有个数限制，这种称为多重背包问题。</p> 
<p><img src="https://images2.imgbox.com/20/e3/j2X8MDyx_o.png" alt=""></p> 
<p>我们一个一个来看，我们先从其中比较简单的完全背包开始。由于我们这是一个连续的专题，没有看过上篇文章或者是新关注的同学可以移步我们专题的第一篇：</p> 
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyMTM5OTM2NA==&amp;mid=2247484886&amp;idx=1&amp;sn=8460834d53d467cae60cd31c48c480bb&amp;chksm=f9daf8fdcead71eb258215aabf61ca82d493e3a27318b17365199c9952bc0ac7124ba9808c9b&amp;token=1213336307&amp;lang=zh_CN#rd" rel="nofollow">动态规划入门——详解经典的零一背包问题</a></p> 
<h3><a id="_12"></a>完全背包</h3> 
<p>在之前的文章当中，我们阐述了动态规划当中<strong>状态和决策以及状态转移</strong>的相关概念。在背包问题当中，背包的容量是状态，而选择哪个物品进行获取则是决策，当我们制定了一个决策之后，背包会从一个状态转移到另一个状态。而动态规划算法就是枚举所有状态和决策，获得所有的状态转移，并且<strong>记录这个过程中每个状态能够获得的最优解</strong>。</p> 
<p>在之前的文章当中，我们先遍历了所有的决策，然后再枚举了所有的状态，计算在决策下进行转移之后得到的结果。在之前的零一背包问题当中，由于我们每个物品只能获取一个，如果在前面的状态执行了决策，那么后面的状态则不能进行相同的决策。这也就是动态规划的<strong>后效性</strong>，而在完全背包问题当中，我们去掉了这个限制，也就意味着决策之间不再有后效性，一个决策可以重复应用在各个状态当中。</p> 
<p>所以如果你能理解上面这段话，那么整个算法其实非常简单，几乎就是零一背包的代码。只不过我们把其中倒叙遍历的背包状态再”修正“回来。</p> 
<p>之前我们为了避免物品的重复获取，所以采用了倒叙遍历的方法，如今我们不再对数量进行限制，意味着我们可以自由地采取决策进行转移。要做到这点，就是单纯的两重循环，第一种枚举决策， 第二重枚举状态，记录所有转移可能带来的最优解即可。我们来看代码：</p> 
<pre><code class="prism language-python">dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

<span class="token comment"># 遍历物品</span>
<span class="token keyword">for</span> v<span class="token punctuation">,</span> w <span class="token keyword">in</span> items<span class="token punctuation">:</span>
    <span class="token comment"># 遍历背包空间（状态）</span>
    <span class="token comment"># 更新vp+v的状态，即当前容量放入物品之后的状态</span>
    <span class="token keyword">for</span> vp <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">-</span>v<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        dp<span class="token punctuation">[</span>vp<span class="token operator">+</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>vp<span class="token operator">+</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>vp<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果你还没能完全理解其中的逻辑，我们可以对照一下代码再来理解一下。在第一种循环当中，我们遍历了所有的物品，每一个物品对应了一种决策。每一个决策可以应用在各个状态上，比如第一个物品是6， 15，代表它的体积是6，价值是15。那么我们遍历所有能够应用这个决策的状态，也就是在<strong>不超过背包容量</strong>的情况下能够放下的状态。显然对于一个体积是6的物品来说，只有0到4的状态可以放下。比如说我们选择状态2，状态2放下了这个物品之后，自然会转移到状态8，因为体积增加了6。有可能这个决策会使得状态8获得更好的结果，也有可能不会，如果会的话我们就更新一下状态8记录的值。这个从一个状态采取决策到另一个状态的过程就是状态转移。</p> 
<p>完全背包就是<strong>零一背包的无限制版</strong>，从原理上来说，两者的思路和做法基本上是一样的。如果你能理解零一背包，那么完全背包对你来说也一定不在话下。</p> 
<h4><a id="_41"></a>细小的优化</h4> 
<p>在完全背包当中，由于所有的物品都可以无限获取。所以我们可以引入一些零一背包不能进行的优化，比如<strong>对于同样体积的物品而言，我们可以只保留价值最高的物品</strong>，将其他的物品过滤掉。这个思路很朴素，我想大家应该都能理解。</p> 
<p>比如两个物品体积都是3，一个价值是4，另一个价值是3，我们完全可以忽略价值是3的那一种。因为两者带来的状态转移是一样的，但是明显前者收益更好。而这个优化在零一背包当中不可行是因为每个物品只有一个，<strong>很有可能会出现两者都要的情况</strong>，所以不能简单地替换。而在完全背包当中则没有这个问题。</p> 
<h3><a id="_47"></a>多重背包</h3> 
<p>和零一背包以及完全背包相比，多重背包要难上一些，它的解法也非常多样。我们今天先来看一些相对比较简单的方法。</p> 
<p>同样，我们从最简单的方法开始讲起。最简单的方法当然就是<strong>将多重背包蜕化成零一背包</strong>来解决，比如一个物品最多可以拿N个，我们就把它拆成N种物品，这N种每种物品最多拿一个，相当于我们一种物品可以最多拿N个。这个思路应该很简单，大家都能想明白，但是有个很大的问题，就是复杂度。当然我们可以根据背包的体积做一些优化，比如当物品的数量很多并且超过了背包容量的时候，我们可以把超过容量的数量去掉，但是<strong>整体的复杂度还是很高。尤其是当我们背包容量很大的时候</strong>。</p> 
<p>那么，我们怎么来解决这个问题呢？</p> 
<p>这里要介绍一个比较通用的算法，这个算法可以用来优化很多问题，也是很多算法的思想。它就是<strong>二进制表示法</strong>。这个方法我们在之前的文章当中曾经讲到过，思想非常简单，但是非常实用。</p> 
<h4><a id="_57"></a>二进制表示法</h4> 
<p>所谓二进制表示法就是将一个int类型的数表示成二进制，整个算法的思想就是这一句话，所以我想大家应该都能理解。但是我们为什么要将一个int转成二进制，以及转成二进制之后怎么样来优化算法，这个才是我们想知道的，也才是算法的核心重点，不要着急，我们一点点来说明。</p> 
<p>我们都知道在计算机系统当中都是以二进制存储的所有数据，最典型的就是整数。一个32位的int，可以表示最大21亿的整数。这个都是我们已知的，但是换一个角度来看，一个21亿的数最后用32个二进制位就表示了，其实非常惊人。为什么说二进制是一个非常伟大的思想？不在于它难，而在于它高效地压缩了数据。</p> 
<p><img src="https://images2.imgbox.com/24/7f/5slayelz_o.png" alt=""></p> 
<p>我们进一步来看，32个二进制位为什么能表示这么大的数据呢？因为这32位int表示的数据是不一样的，第0位表示1，第1位表示2，第2位表示4……到了第31位的时候，表示的数已经非常庞大。我们用这32个数不同的组合来表示不同的数，换句话说范围内的所有数最终都变成了这32个数中若干个的累加。我们写成公式就是：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         = 
        
        
        
          ∑ 
         
         
         
           i 
          
         
           = 
          
         
           0 
          
         
        
          31 
         
        
        
        
          a 
         
        
          i 
         
        
       
         ⋅ 
        
        
        
          2 
         
        
          i 
         
        
       
      
        x = \sum_{i=0}^{31} a_i\cdot 2^i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.25372em; vertical-align: -0.29971em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.954008em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.29971em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.824664em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span>，这里的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          a 
         
        
          i 
         
        
       
      
        a_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示的是第i位的系数，它只有0和1两个取值。</p> 
<p>这个式子大家都熟悉，但是我们把它应用在方程当中可能很多人就不清楚了。比如说某个函数如果满足这样的性质:<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         a 
        
       
         + 
        
       
         b 
        
       
         ) 
        
       
         = 
        
       
         f 
        
       
         ( 
        
       
         a 
        
       
         ) 
        
       
         + 
        
       
         f 
        
       
         ( 
        
       
         b 
        
       
         ) 
        
       
      
        f(a+b) = f(a) + f(b) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span>，如果直接求<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         a 
        
       
         + 
        
       
         b 
        
       
         ) 
        
       
      
        f(a+b) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span>很麻烦，或者是开销很大，我们就可以用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         a 
        
       
         ) 
        
       
      
        f(a) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         b 
        
       
         ) 
        
       
      
        f(b) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span>来获得。同理，我们用在二进制上，我们可以得到：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          ( 
         
        
          x 
         
        
          ) 
         
        
          = 
         
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            0 
           
          
         
           31 
          
         
         
         
           a 
          
         
           i 
          
         
        
          ⋅ 
         
        
          f 
         
        
          ( 
         
         
         
           2 
          
         
           i 
          
         
        
          ) 
         
        
       
         f(x) = \sum_{i=0}^{31} a_i \cdot f(2^i) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 3.07878em; vertical-align: -1.27767em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.80111em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.30001em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.12466em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.874664em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p> 
<p>看到了吗，我们把<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        f(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>的值转化成了最多32个值的和，在有些场景当中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
        
        
          2 
         
        
          i 
         
        
       
         ) 
        
       
      
        f(2^i) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.07466em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>是很容易计算的，但是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        f(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>很难直接计算，这个时候我们通过二进制转化就会很简单。</p> 
<p>同理，累加理解了，累乘也就水到渠成。如果某个函数<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        f(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>满足:<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         a 
        
       
         b 
        
       
         ) 
        
       
         = 
        
       
         f 
        
       
         ( 
        
       
         a 
        
       
         ) 
        
       
         ⋅ 
        
       
         f 
        
       
         ( 
        
       
         b 
        
       
         ) 
        
       
      
        f(ab) = f(a)\cdot f(b) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span>，那么我们同样可以用二进制来表达<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        f(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          ( 
         
        
          x 
         
        
          ) 
         
        
          = 
         
         
         
           ∏ 
          
          
          
            i 
           
          
            = 
           
          
            0 
           
          
         
           31 
          
         
        
          g 
         
        
          ( 
         
        
          i 
         
        
          ) 
         
        
       
         f(x) = \prod_{i=0}^{31} g(i) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 3.07878em; vertical-align: -1.27767em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.80111em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∏</span></span></span><span class="" style="top: -4.30001em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></span><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          g 
         
        
          ( 
         
        
          i 
         
        
          ) 
         
        
          = 
         
         
         
           { 
          
          
           
            
             
              
              
                1 
               
              
                , 
               
              
             
            
            
             
              
               
               
                 a 
                
               
                 i 
                
               
              
                = 
               
              
                = 
               
              
                0 
               
              
             
            
           
           
            
             
              
              
                f 
               
              
                ( 
               
               
               
                 2 
                
               
                 i 
                
               
              
                ) 
               
              
                , 
               
              
             
            
            
             
              
               
               
                 a 
                
               
                 i 
                
               
              
                = 
               
              
                = 
               
              
                1 
               
              
             
            
           
          
         
        
       
         g(i) = \begin{cases} 1, &amp; a_i == 0\\ f(2^i), &amp; a_i == 1 \end{cases} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 3.00003em; vertical-align: -1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size4">{<!-- --></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.69em;"><span class="" style="top: -3.69em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.19em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.69em;"><span class="" style="top: -3.69em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">0</span></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.19em;"><span class=""></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<p>对于多重背包这个问题，显然我们<strong>满足的是累加性质</strong>。也就是说，对于一个较大的x而言，我们可以用若干个子状态累加得到。由于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         a 
        
       
         + 
        
       
         b 
        
       
         ) 
        
       
         = 
        
       
         f 
        
       
         ( 
        
       
         a 
        
       
         ) 
        
       
         + 
        
       
         f 
        
       
         ( 
        
       
         b 
        
       
         ) 
        
       
      
        f(a+b) = f(a) + f(b) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span>，所以我们很容易发现<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         2 
        
       
         ) 
        
       
         = 
        
       
         2 
        
       
         f 
        
       
         ( 
        
       
         1 
        
       
         ) 
        
       
      
        f(2) = 2f(1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         4 
        
       
         ) 
        
       
         = 
        
       
         2 
        
       
         f 
        
       
         ( 
        
       
         2 
        
       
         ) 
        
       
      
        f(4) = 2f(2) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span>，也就是说这些子状态之间彼此存在倍数关系。因此我们可以很轻松地计算出这些子状态，再根据x的二进制表示来累加求到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        f(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>，而直接计算<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         x 
        
       
         ) 
        
       
      
        f(x) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span>则困难得多，计算量也大得多。</p> 
<p>在这个问题当中，函数f表示的是我们拿取物品的价值。也就是说，某一种物品，假设最多有n个，并且单个的价值是p，那么我们拿取2个就是2p，拿取4个就是4p，对于所有2的幂个数的价值都很容易计算。我们需要枚举这n个物品拿取的情况，我们枚举的范围应该是[0, n]。我们将n转化成二进制之后，可以通过logn个2的幂排列组合的和得到[0, n]当中的任意一个数。那么，我们<strong>只需要将2的幂个数的物品看成是新的物品</strong>，这样，我们可以用新的物品的01组合，来代替原物品拿取0-n的所有情况。</p> 
<p>举个例子，我们有一个物品一共有15个，价值是3，其中15=<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          2 
         
        
          0 
         
        
       
         + 
        
        
        
          2 
         
        
          1 
         
        
       
         + 
        
        
        
          2 
         
        
          2 
         
        
       
         + 
        
        
        
          2 
         
        
          3 
         
        
       
      
        2^0+2^1+2^2+2^3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.897438em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.897438em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.897438em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>，也就是说我们用4个二进制位就可以表示1-15这15这数字。那么我们用4种物品映射这4个二进制位之后，就可以用这4种物品的组合来表示获取1-15个原物品了。也就是说我们把15个价值是3的物品打了四个包，第一个包里有一个，第二个包里有两个，第三个包里有四个，第四个包里有八个。如果我们要拿3个原物品，相当于拿第一和第二个包裹。如果我们要拿5个原物品，相当于拿第一个和第三个包裹。<strong>这样我们就把多重背包的问题转化回了零一背包</strong>。</p> 
<p>我们之前说了，32位二进制位就可以表示20亿以上的数，所以虽然我们进行二进制处理之后物品的数量会增多一些，但也是非常有限的。我们做个简单的复杂度分析，假设物品的总数是N，每种物品最多M个，背包的容量是V。如果用朴素的拆分方法，复杂度是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         N 
        
       
         M 
        
       
         V 
        
       
         ) 
        
       
      
        O(NMV) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="mclose">)</span></span></span></span></span>，而使用二进制拆分的复杂度是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         N 
        
       
         log 
        
       
         ⁡ 
        
       
         M 
        
       
         V 
        
       
      
        N\log M V 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span></span></span></span></span>。和前者相比，从M到logM是一个巨大的优化，尤其当M很大的时候。</p> 
<p>最后，还有一个小问题，<strong>我们的物品数量并不一定刚好能分成若干个2的幂的和</strong>，这种情况下怎么办呢？其实也简单，我们把分剩下的部分单独打一个包就好了。比如如果物品的数量是10，10=1+2+4+3，所以最后一个包就是3。虽然我们用1+2也能表示3，但是这并不会影响结果的正确性。</p> 
<p>到这里，多重背包的解法就介绍完了，说了这么多其实也只是介绍了二进制表示这个方法而已。理解了这个方法，它就转化成了零一背包。不得不说这个方法实在是非常巧妙，并且除了在背包问题之外，在许多其他问题中也有类似的运用。所以这个方法不建议错过。</p> 
<p>最后，我们来看下代码，首先我们来看下二进制拆分的部分：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">binary_divide</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> volume<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">:</span>
    divides <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 从0位开始枚举</span>
        cur <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i
        <span class="token comment"># 如果小于枚举值，说明已经拆分完毕了</span>
        <span class="token keyword">if</span> cnt <span class="token operator">&lt;</span> cur<span class="token punctuation">:</span>
            <span class="token comment"># 把剩下的部分打包</span>
            divides<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> cnt <span class="token operator">*</span> volume<span class="token punctuation">,</span> cnt <span class="token operator">*</span> price<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># 否则继续拆分，打包1 &lt;&lt; i个物品</span>
            cnt <span class="token operator">-=</span> cur
            divides<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> cur <span class="token operator">*</span> volume<span class="token punctuation">,</span> cur <span class="token operator">*</span> price<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> divides
</code></pre> 
<p>进行完二进制拆分之后，这个问题就转化成了零一背包。我们只需要套用零一背包的代码就可以了：</p> 
<pre><code class="prism language-python"><span class="token comment"># 物品，分别是数量，体积和单位价格</span>
items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
volume <span class="token operator">=</span> <span class="token number">20</span>
dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>volume<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
new_items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> items<span class="token punctuation">:</span>
    <span class="token comment"># 二进制拆分</span>
    new_items<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>binary_divide<span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> item <span class="token keyword">in</span> new_items<span class="token punctuation">:</span>
    v<span class="token punctuation">,</span> p <span class="token operator">=</span> item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> item<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>volume<span class="token operator">-</span>v<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        dp<span class="token punctuation">[</span>i <span class="token operator">+</span> v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>通过神乎其神的二进制表示法，我们将多重背包问题又还原成了零一背包，不得不说实在是神奇。但<strong>二进制表示法并不是唯一的方案</strong>，我们也可以不用二进制来完成这道题。这涉及到一种全新的方法，由于篇幅限制，我们会在下篇文章当中和大家一起学习。</p> 
<p>今天关于多重背包和完全背包的文章就到这里，如果觉得有所收获，请顺手点个<strong>关注或者转发</strong>吧，你们的举手之劳对我来说很重要。</p> 
<p><img src="https://images2.imgbox.com/0e/96/QILJgh6k_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/12c5c214b1fa8df106839ca5c39b75cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">英语入门2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/56f18482df0449720e0c58b7353223f5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一个例子带你入门Python装饰器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>