<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringCloud Stream集成rabbitMQ（延时队列） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringCloud Stream集成rabbitMQ（延时队列）" />
<meta property="og:description" content="上节咱们讲了SpringCloud Stream集成rabbitMQ，本章节咱们将实现延时队列功能。在实际开发中我们有些场景用延时队列实现非常方便。下面列举延时队列适合使用的场景：
用户下单30分钟后未付款自动关闭订单用户下单外卖以后，距离超时时间还有 10 分钟时提醒外卖小哥即将超时邮箱编辑好邮件定时发送等等 上节已经讲过SpringCloud Stream集成rabbitMQ步骤，下面就不在重复赘述了，不明白的同学可以去看上节的内容。
1.主要的变化是配置文件 spring: application: name: rabbitmq-dome cloud: function: definition: source;sink; #函数名称，对应服务中的注入的Bean stream: binders: #需要绑定的rabbitmq的服务信息 default-binder: #定义的名称，用于bidding整合 type: rabbit #消息组件类型 environment: #配置rabbimq连接环境 spring: rabbitmq: addresses: 10.0.1.141:5672 #服务器的地址和端口 username: xt3dev #用户名 password: 4V9prcFbRoYxLCMd #密码 bindings: source-out-0: #自定义消息通道的名称 destination: QUEUE_DOME #exchange名称,交换模式默认是topic，创建时同时会创建QUEUE_DOME.${spring.application.name}队列 content-type: application/json #设置消息的类型为json group: ${spring.application.name} #分组 binder: default-binder #绑定的binder名称 sink-in-0: destination: QUEUE_DOME content-type: application/json group: ${spring.application.name} binder: default-binder rabbit: bindings: source-out-0: producer: ttl: 5000 #延时队列的延时时间，单位毫秒 auto-bind-dlq: true #为true是开启死信队列 dead-letter-exchange: QUEUE_DOME_IN #死信队列的交换机 dead-letter-queueName: QUEUE_DOME_IN." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fc539852836d2ccdc6f3440f1ebf1307/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-08T16:05:12+08:00" />
<meta property="article:modified_time" content="2022-04-08T16:05:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringCloud Stream集成rabbitMQ（延时队列）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>上节咱们讲了SpringCloud Stream集成rabbitMQ，本章节咱们将实现延时队列功能。在实际开发中我们有些场景用延时队列实现非常方便。下面列举延时队列适合使用的场景：</p> 
<ol><li>用户下单30分钟后未付款自动关闭订单</li><li>用户下单外卖以后，距离超时时间还有 10 分钟时提醒外卖小哥即将超时</li><li>邮箱编辑好邮件定时发送等等</li></ol> 
<p>上节已经讲过<a class="link-info" href="https://blog.csdn.net/zsx_xiaoxin/article/details/124040081" title="SpringCloud Stream集成rabbitMQ步骤">SpringCloud Stream集成rabbitMQ步骤</a>，下面就不在重复赘述了，不明白的同学可以去看上节的内容。</p> 
<h2>1.主要的变化是配置文件</h2> 
<pre><code>spring:
  application:
    name: rabbitmq-dome
  cloud:
    function:
      definition: source;sink; #函数名称，对应服务中的注入的Bean
    stream:
      binders: #需要绑定的rabbitmq的服务信息
        default-binder: #定义的名称，用于bidding整合
          type: rabbit #消息组件类型
          environment: #配置rabbimq连接环境
            spring:
              rabbitmq:
                addresses: 10.0.1.141:5672 #服务器的地址和端口
                username: xt3dev #用户名
                password: 4V9prcFbRoYxLCMd #密码
      bindings:
        source-out-0: #自定义消息通道的名称
          destination: QUEUE_DOME #exchange名称,交换模式默认是topic，创建时同时会创建QUEUE_DOME.${spring.application.name}队列
          content-type: application/json #设置消息的类型为json
          group: ${spring.application.name} #分组
          binder: default-binder #绑定的binder名称
        sink-in-0:
          destination: QUEUE_DOME
          content-type: application/json
          group: ${spring.application.name}
          binder: default-binder
      rabbit:
        bindings:
          source-out-0:
            producer:
              ttl: 5000 #延时队列的延时时间，单位毫秒
              auto-bind-dlq: true #为true是开启死信队列
              dead-letter-exchange: QUEUE_DOME_IN #死信队列的交换机
              dead-letter-queueName: QUEUE_DOME_IN.${spring.application.name} #死信队列名称</code></pre> 
<h2>2.启动项目测试</h2> 
<p>浏览器访问<a href="http://localhost:8080/sendMessage?message=hello%20rabbitMQ" rel="nofollow" title="http://localhost:8080/sendMessage?message=hello rabbitMQ">http://localhost:8080/sendMessage?message=hello rabbitMQ</a>，从控制台我看可以看出生产者发送消息到消费者接收到消息是有5秒钟的延时，我们配置文件配置的也是5000毫秒，说明延时队列功能是可以的。</p> 
<p><img alt="" height="293" src="https://images2.imgbox.com/f3/aa/tmOCSa93_o.png" width="1200"></p> 
<h2>3.延时队列原理分析</h2> 
<p>RabbitMQ本身没有直接支持延迟队列功能，两种方式可以实现延迟队列，一种是利用对的TTL特性来实现，另外一种是使用RabbitMQ延迟插件来实现。本文主要讲述的是TTL的方式来实现的</p> 
<p>RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为<strong>dead letter</strong><br> RabbitMQ针对队列中的消息过期时间有两种方法可以设置。</p> 
<ul><li>A: 通过队列属性设置，队列中所有消息都有相同的过期时间。</li><li>B: 对消息进行单独设置，每条消息TTL可以不同。<br> 如果同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。消息在队列的生存时间一旦超过设置的TTL值，就成为dead letter</li></ul> 
<p>延迟队列原理分析图</p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/8e/90/8TT4AsMg_o.png" width="888"></p> 
<h2> 4.设置单条消息过期时间</h2> 
<p>使用spring cloud stream的方式是没办法设置单条消息过期时间的，只能利用RabbitTemplate来设置单条消息过期时间。</p> 
<h3>4.1 创建RabbitConfig类</h3> 
<pre><code class="language-java">@Configuration
@RequiredArgsConstructor
public class RabbitConfig {

  private final BinderFactory binderFactory;

  private final static String binderName = "default-binder";

  @Bean
  public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) throws NoSuchFieldException, IllegalAccessException {

    // 获取目标binder
    Binder&lt;BinderConfiguration, ? extends ConsumerProperties, ? extends ProducerProperties&gt; binder =
            binderFactory.getBinder(binderName, BinderConfiguration.class);
    Assert.notNull(binder, binderName + " is null");

    // 获取binder的connectionFactory
    Field field = binder.getClass().getDeclaredField("connectionFactory");
    field.setAccessible(true);
    connectionFactory = (ConnectionFactory) field.get(binder);

    // new
    return new RabbitTemplate(connectionFactory);
  }
}</code></pre> 
<p></p> 
<h3>4.2 改造生产者实现类</h3> 
<pre><code class="language-java">@Slf4j
@Service
@RequiredArgsConstructor
public class ProducerServiceImpl implements ProducerService {

    private final RabbitTemplate rabbitTemplate;

    private final Sinks.Many&lt;Message&lt;String&gt;&gt; sinks =
            Sinks.many().multicast().onBackpressureBuffer();

    @Bean
    public Supplier&lt;Flux&lt;Message&lt;String&gt;&gt;&gt; source(){
        return sinks::asFlux;
    }

    @Override
    public void sendMessage(String message, String expiration) {
        log.info("发送时间:{}, 生产者发送消息:{}", new Date(), message);
        rabbitTemplate.convertAndSend("QUEUE_DOME_OUT", "#", message, msg -&gt; {
            MessageProperties messageProperties = msg.getMessageProperties();
            // 设置过期时间，单位：毫秒
            messageProperties.setExpiration(expiration);
            return msg;
        });
    }
}
</code></pre> 
<h3>4.3 改造MessageController类</h3> 
<pre><code class="language-java">@RestController
@RequiredArgsConstructor
public class MessageController {

    private final ProducerService producerService;

    @GetMapping("/sendMessage")
    public void sendMessage(@RequestParam(value = "message", defaultValue = "hello world") String message,
                            @RequestParam(value = "expiration", defaultValue = "5000") String expiration) {
        producerService.sendMessage(message, expiration);
    }
}</code></pre> 
<h3>4.4 启动项目测试</h3> 
<p>浏览器访问<a href="http://localhost:8080/sendMessage?message=hello%20rabbitMQ&amp;expiration=3000" rel="nofollow" title="http://localhost:8080/sendMessage?message=hello%20rabbitMQ&amp;expiration=3000">http://localhost:8080/sendMessage?message=hello%20rabbitMQ&amp;expiration=3000</a>，设置消息过期时间为3秒</p> 
<p> 结果：</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/1f/5d/IMl8MxQl_o.png" width="1200"></p> 
<p>浏览器访问<a href="http://localhost:8080/sendMessage?message=hello%20rabbitMQ&amp;expiration=3000" rel="nofollow" title="http://localhost:8080/sendMessage?message=hello%20rabbitMQ&amp;expiration=3000">http://localhost:8080/sendMessage?message=hello%20rabbitMQ&amp;expiration=3000</a>，设置消息过期时间为5秒 </p> 
<p>结果：</p> 
<p><img alt="" height="414" src="https://images2.imgbox.com/b1/88/Hc5VrqRK_o.png" width="1200"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4aa748e252988eb6688a32b653818c13/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MacOS下iterm，Dracula主题配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17056926eae32de434d30ea6f8aa0293/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MyEclipse破解教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>