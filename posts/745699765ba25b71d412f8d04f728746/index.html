<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>angular2单元测试学习 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="angular2单元测试学习" />
<meta property="og:description" content="单元测试简介：https://segmentfault.com/a/1190000009737186
单元测试-Jasmine：https://segmentfault.com/a/1190000009737204
angular2单元测试：https://segmentfault.com/a/1190000009769787#articleHeader1
概念简介 Jasmine Jasmine测试框架提供了编写测试脚本的工具集，而且非常优秀的语义化，让测试代码看起来像是在读一段话。
describe，beforeEach，it，expect等方法，利用这些方法可以定义单元测试如何执行，单元测试的结果和预期。
官方文档：https://jasmine.github.io/api/edge/global.html#expect
Karma 有Jasmine测试脚本，还需要Karma来帮忙管理这些脚本，以便于在浏览器中运行，可以理解Karma为运行这些测试脚本的容器。
需要在根目录创建 karma.conf.js 文件，这相当于一些约定。文件是为了告知karma需要启用哪些插件、加载哪些测试脚本、需要哪些测试浏览器环境、测试报告通知方式、日志等等。
官方文档：https://karma-runner.github.io/1.0/config/configuration-file.html
Angular测试工具集 testded
testded是angular提供用于单元测试的主要工具方法。为单元测试配置和初始化环境，提供创建组件和服务的方法。
还有spy和一些异步支持
结合Jasmine和Angular测试工具集编写单元测试案例 Jasmine单元测试的基础概念
Jasmine中的单元测试有几个概念：test suit、Specs、Expectations
test suit 测试套件
可以理解为一组单元测试用例的集合。Jasmine用describe函数来表示
Specs 测试案例
一个单元测试用例，Jasmine使用函数it来表示
Expectations 期望值
一个单元测试用例执行后，对执行结果的期待，Jasmine使用函数expect来表示
Jasmine单元测试常用方法 Matchers：对期待值进行判断，toBeTruthy，toBeNull这种，也可以自己实现Matcher
Setup 与 Teardown：在测试套件中，一些重复的代码可以放在setup和teardown中。setup（对应beforeEach）为每一个单元测试案例执行之前会执行，Teardown（对应afterEach）为每一个单元测试案例执行之后会执行，
数据共享：在describe 来定义相应的变量，这样每个 it 内部可以共享它们
spy： 文档翻译：https://blog.csdn.net/GuoJiangweigege/article/details/52130589 并参照：https://www.cnblogs.com/laixiangran/p/5060922.html
spyOn(object, &#34;methodNam&#34;);//在object对象上添加methodNam，当调用object对象上的方法，为模拟调用，不会执行methodNam方法的代码。spyOn写在beforEach或者it中，每一个测试案例执行完之后，被销毁。
spyOn(object, &#34;methodNam&#34;).and.callThrough();//methodNam方法的代码会被执行
spyOn(object, &#34;methodNam&#34;).and.callFake(fn);//methodNam方法会被fn替代，执行fn
spyOn(object, &#34;methodNam&#34;).and.returnValue(value);//methodNam的返回值为value
Angular工具集 TestBed
如官方所说，是angular单元测试最主要的api。个人理解是一组单元测试的测试context，按配置生成模块、组件，然后提供这些模块或者组件用于单元测试。
1 TestBed创建模块：TestBed.configureTestingModule
构建一个angular模块，并返回，接受参数用于配置模块，和@NgModule的配置无差别。
beforeEach(() =&gt; { TestBed.configureTestingModule({ imports: [HttpModule], declarations: [TestComponent] }); }); 2 TestBed创建组件：TestBed." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/745699765ba25b71d412f8d04f728746/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-30T10:55:00+08:00" />
<meta property="article:modified_time" content="2019-09-30T10:55:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">angular2单元测试学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>单元测试简介：https://segmentfault.com/a/1190000009737186</p> 
 <p>单元测试-Jasmine：https://segmentfault.com/a/1190000009737204</p> 
 <p>angular2单元测试：https://segmentfault.com/a/1190000009769787#articleHeader1</p> 
 <p> </p> 
 <h2>概念简介</h2> 
 <h4>Jasmine </h4> 
 <p>Jasmine测试框架提供了编写测试脚本的工具集，而且非常优秀的语义化，让测试代码看起来像是在读一段话。</p> 
 <p>describe，beforeEach，it，expect等方法，利用这些方法可以定义单元测试如何执行，单元测试的结果和预期。</p> 
 <p>官方文档：https://jasmine.github.io/api/edge/global.html#expect</p> 
 <h4>Karma</h4> 
 <p>有Jasmine测试脚本，还需要Karma来帮忙管理这些脚本，以便于在浏览器中运行，可以理解Karma为运行这些测试脚本的容器。</p> 
 <p>需要在根目录创建 karma.conf.js 文件，这相当于一些约定。文件是为了告知karma需要启用哪些插件、加载哪些测试脚本、需要哪些测试浏览器环境、测试报告通知方式、日志等等。</p> 
 <p>官方文档：https://karma-runner.github.io/1.0/config/configuration-file.html</p> 
 <h4>Angular测试工具集</h4> 
 <p>testded</p> 
 <p>testded是angular提供用于单元测试的主要工具方法。为单元测试配置和初始化环境，提供创建组件和服务的方法。</p> 
 <p>还有spy和一些异步支持</p> 
 <p> </p> 
 <h2>结合Jasmine和Angular测试工具集编写单元测试案例</h2> 
 <p><strong>Jasmine单元测试的基础概念</strong></p> 
 <p>Jasmine中的单元测试有几个概念：test suit、Specs、Expectations</p> 
 <p><strong>test suit 测试套件</strong></p> 
 <p>可以理解为一组单元测试用例的集合。Jasmine用describe函数来表示</p> 
 <p id="articleHeader2"><strong>Specs 测试案例</strong></p> 
 <p>一个单元测试用例，Jasmine使用函数it来表示</p> 
 <p><strong>Expectations 期望值</strong></p> 
 <p>一个单元测试用例执行后，对执行结果的期待，Jasmine使用函数expect来表示</p> 
 <p> </p> 
 <h4>Jasmine单元测试常用方法</h4> 
 <p><strong>Matchers</strong>：对期待值进行判断，toBeTruthy，toBeNull这种，也可以自己实现Matcher</p> 
 <p><strong>Setup 与 Teardown</strong>：在测试套件中，一些重复的代码可以放在setup和teardown中。setup（对应beforeEach）为每一个单元测试案例执行之前会执行，Teardown（对应afterEach）为每一个单元测试案例执行之后会执行，</p> 
 <p><strong>数据共享</strong>：在describe 来定义相应的变量，这样每个 it 内部可以共享它们</p> 
 <p><strong>spy</strong>： 文档翻译：https://blog.csdn.net/GuoJiangweigege/article/details/52130589  并参照：https://www.cnblogs.com/laixiangran/p/5060922.html</p> 
 <p>spyOn(object, "methodNam");//在object对象上添加methodNam，当调用object对象上的方法，为模拟调用，不会执行methodNam方法的代码。spyOn写在beforEach或者it中，每一个测试案例执行完之后，被销毁。</p> 
 <p>spyOn(object, "methodNam").and.callThrough();//methodNam方法的代码会被执行</p> 
 <p>spyOn(object, "methodNam").and.callFake(fn);//methodNam方法会被fn替代，执行fn</p> 
 <p>spyOn(object, "methodNam").and.returnValue(value);//methodNam的返回值为value</p> 
 <p> </p> 
 <h4 id="articleHeader10">Angular工具集</h4> 
 <p><strong>TestBed</strong></p> 
 <p>如官方所说，是angular单元测试最主要的api。个人理解是一组单元测试的测试context，按配置生成模块、组件，然后提供这些模块或者组件用于单元测试。</p> 
 <p>1 TestBed创建模块：TestBed.configureTestingModule</p> 
 <p>构建一个angular模块，并返回，接受参数用于配置模块，和@NgModule的配置无差别。</p> 
 <div class="cnblogs_code"> 
  <pre>beforeEach(() =&gt;<span style="color:#000000;"> {
    TestBed.configureTestingModule({
        imports: [HttpModule],
        declarations: [TestComponent]
    });
});</span></pre> 
 </div> 
 <p>2 TestBed创建组件：TestBed.createComponent</p> 
 <p>创建组件，返回一个fixture。fixture 包括组件实例、变更监测以及DOM相关的属性，它是用来写单元测试的核心。</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008080;"> 1</span> <span style="color:#000000;">@Component({
</span><span style="color:#008080;"> 2</span>     template: `&lt;trade-view [id]="id" (close)="_close()"&gt;&lt;/trade-view&gt;`
<span style="color:#008080;"> 3</span> <span style="color:#000000;">})
</span><span style="color:#008080;"> 4</span> <span style="color:#000000;">class TestComponent {
</span><span style="color:#008080;"> 5</span>     id: number = 0<span style="color:#000000;">;
</span><span style="color:#008080;"> 6</span> <span style="color:#000000;">    _close() { }
</span><span style="color:#008080;"> 7</span> <span style="color:#000000;">}
</span><span style="color:#008080;"> 8</span> 
<span style="color:#008080;"> 9</span> beforeEach(() =&gt;<span style="color:#000000;"> {
</span><span style="color:#008080;">10</span> <span style="color:#000000;">    TestBed.configureTestingModule({
</span><span style="color:#008080;">11</span> <span style="color:#000000;">        imports: [HttpModule],
</span><span style="color:#008080;">12</span> <span style="color:#000000;">        declarations: [TestComponent]
</span><span style="color:#008080;">13</span> <span style="color:#000000;">    });
</span><span style="color:#008080;">14</span>     fixture =<span style="color:#000000;"> TestBed.createComponent(TestComponent);
</span><span style="color:#008080;">15</span>     component =<span style="color:#000000;"> fixture.componentInstance; //组件实例
</span><span style="color:#008080;">16</span>     el =<span style="color:#000000;"> fixture.nativeElement; //组件原生元素</span><span style="color:#008080;">17</span> });</pre> 
 </div> 
 <p> 3 异步beforeach（具体可参考angular官方文档 测试-调用compileComponents()）</p> 
 <p>如果一个组件使用了templateUrl和styleUrls获取模板或者模板样式，这是一个异步的过程，那么需要使用异步beforeach创建组件，否则会报错无法编译组件。</p> 
 <p>如下是没有使用异步beforeach创建组件：</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008080;">1</span> beforeEach(() =&gt;<span style="color:#000000;"> {
</span><span style="color:#008080;">2</span> <span style="color:#000000;">  TestBed.configureTestingModule({
</span><span style="color:#008080;">3</span> <span style="color:#000000;">    declarations: [ BannerComponent ],
</span><span style="color:#008080;">4</span> <span style="color:#000000;">  });
</span><span style="color:#008080;">5</span>   fixture =<span style="color:#000000;"> TestBed.createComponent(BannerComponent);
</span><span style="color:#008080;">6</span> });</pre> 
 </div> 
 <p>如果这个组件没有使用templateUrl或styleUrls，那么不会有任何问题，因为createComponet就会执行组件的编译，然后再创建组件。但如果使用了templateUrl或styleUrls，则获取url地址文件的过程是异步的，在createComponent时如果没有返回地址，那么执行编译就会报错。这时，用异步的beforeach来解决这个问题。</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008080;"> 1</span> beforeEach(async(() =&gt;<span style="color:#000000;"> { //使用angular提供的辅助异步函数
</span><span style="color:#008080;"> 2</span> <span style="color:#000000;">  TestBed.configureTestingModule({
</span><span style="color:#008080;"> 3</span> <span style="color:#000000;">    declarations: [ BannerComponent ],
</span><span style="color:#008080;"> 4</span> <span style="color:#000000;">  })
</span><span style="color:#008080;"> 5</span> <span style="color:#000000;">  .compileComponents()
</span><span style="color:#008080;"> 6</span>   .then(() =&gt;<span style="color:#000000;"> {
</span><span style="color:#008080;"> 7</span>     fixture =<span style="color:#000000;"> TestBed.createComponent(BannerComponent);
</span><span style="color:#008080;"> 8</span>     component =<span style="color:#000000;"> fixture.componentInstance;
</span><span style="color:#008080;"> 9</span>     h1 = fixture.nativeElement.querySelector('h1'<span style="color:#000000;">);
</span><span style="color:#008080;">10</span> <span style="color:#000000;">  });
</span><span style="color:#008080;">11</span> }));</pre> 
 </div> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/hahlzj/p/11294630.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/def68d47c46879af3c8e5920749cd9a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SFM 与MVS的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/669aaaa13aa6f4d92efcbdf9adf31e33/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python中变量作用域规则详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>