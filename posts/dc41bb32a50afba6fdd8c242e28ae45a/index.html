<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从MySQL小表驱动大表说起 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从MySQL小表驱动大表说起" />
<meta property="og:description" content=" 刚刚开始学习MySQL的时候，连表查询直接使用left join或者更粗暴点，两个表直接查询，where过滤条件，组装笛卡尔积，最终出现自己想要的结果。
当然，现在left join也是会用的，毕竟嘛，方便！
犹记的当时身为初出茅庐去做的一个面试题，类似这种吧：
a表有100条记录，b表有10000条记录，两张表做关联查询时，是将a表放前面效率高，还是b表放前面效率高？
当然，当时虽然不太懂为啥，也没头铁的硬刚，直接是大表在前，小表在后回答，嘿嘿。
不过后来好像绕进了胡同，a*b和b*a有个啥子区别？为啥一定要小表驱动大表？
关于这个，看了不少的文章，其中讲的最深刻，最明了的应该是百度的百家号里面的一篇文章， 由简入深，很能说服人。
当然，后来有时候也会忘了，又在原地打转，今天就小记一下。
首先，连表查询肯定是需要至少把一张表的数据加载到内存的，然后关联查询，比如sql：
select u.* from order o left join user u on o.user_id = u.id where u.id = &#39;9527&#39;;
查询的时候，首先将user表的数据加载到MySQL内存，然后去匹配Order表数据。假设user表的数据匹配量是a，Order表的数据匹配量是b，一般来说，on的条件必须是大表的索引，不然，查询速度贼慢，当然小表最好也是索引。还有就是where中的条件，最好也是和on条件的联合索引或者其他主键之类的，这样查询起来会轻松许多。说多了，继续。
那么根据查询的过程，时间复杂度是a*b吗？
当然！不是！
刚开始加载到内存不是还有个操作吗？没错，就是读取User表的操作，也就是a次操作！
所以：小表驱动大表的操作次数就是 a&#43;a*b
那大表驱动小表的操作次数也就很容易得到为：b&#43;b*a
都说了，b是大表，那么b &gt;a,自然(b&#43;b*a) &gt;(a&#43;a*b)
仅仅看扫描的次数，也能看到，小表驱动大表方案更优！
然后，仅仅是如此？
当然不！
先说内存方面，将数据加载的内存，然后进行对比，获取到最终的结果，如果大表驱动小表，需要将大表数据加载到内存，无疑，这必然占据大量的系统内存，要知道内存的每一分空间都是珍贵的，内存占用过大，必然会挤压其他线程可以使用的空间。而且如果表数据过大，内存放不下，还必须建立临时表，然后一部分一部分的取数据进行对比，那不用说，更慢！
再说，数据IO，将表数据加载到系统内存，肯定要消耗系统IO的。如果是小表驱动大表，也就是需要加载a条数据，然后去匹配过滤数据。反过来，就需要加载b条数据，虽然对比数据的时候都是 a*b次，但是明显加载小表更省IO。
然后，看下数据锁定，可以减少锁竞争的可能，当使用小表驱动大表时，可以避免大表上的锁竞争，因为这些锁会在更早的阶段被获取并且释放。而如果是直接访问大表，则需要在整个查询过程中保持锁定状态，这可能导致其他事务无法正常执行。
为防忘记，小记一下~
如有错误，还望斧正
no sacrifice，no victory~ " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dc41bb32a50afba6fdd8c242e28ae45a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-19T19:05:25+08:00" />
<meta property="article:modified_time" content="2023-04-19T19:05:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从MySQL小表驱动大表说起</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        刚刚开始学习MySQL的时候，连表查询直接使用left join或者更粗暴点，两个表直接查询，where过滤条件，组装笛卡尔积，最终出现自己想要的结果。</p> 
<p>        当然，现在left join也是会用的，毕竟嘛，方便！</p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/6b/01/VUPbjKwZ_o.jpg" width="150"></p> 
<p>         犹记的当时身为初出茅庐去做的一个面试题，类似这种吧：</p> 
<blockquote> 
 <p>a表有100条记录，b表有10000条记录，两张表做关联查询时，是将a表放前面效率高，还是b表放前面效率高？</p> 
</blockquote> 
<p>        当然，当时虽然不太懂为啥，也没头铁的硬刚，直接是大表在前，小表在后回答，嘿嘿。</p> 
<p>        不过后来好像绕进了胡同，a*b和b*a有个啥子区别？为啥一定要小表驱动大表？</p> 
<p>        关于这个，看了不少的文章，其中讲的最深刻，最明了的应该是百度的百家号里面的一篇文章， 由简入深，很能说服人。</p> 
<p>        当然，后来有时候也会忘了，又在原地打转，今天就小记一下。</p> 
<p>首先，连表查询肯定是需要至少把一张表的数据加载到内存的，然后关联查询，比如sql：</p> 
<p>select  u.* from order o left join user u on o.user_id = u.id where u.id = '9527';</p> 
<p>        查询的时候，首先将user表的数据加载到MySQL内存，然后去匹配Order表数据。假设user表的数据匹配量是a，Order表的数据匹配量是b，一般来说，on的条件必须是大表的索引，不然，查询速度贼慢，当然小表最好也是索引。还有就是where中的条件，最好也是和on条件的联合索引或者其他主键之类的，这样查询起来会轻松许多。说多了，继续。</p> 
<p>        那么根据查询的过程，时间复杂度是a*b吗？</p> 
<p>        当然！不是！</p> 
<p>        刚开始加载到内存不是还有个操作吗？没错，就是读取User表的操作，也就是a次操作！</p> 
<p>所以：小表驱动大表的操作次数就是 a+a*b</p> 
<p>那大表驱动小表的操作次数也就很容易得到为：b+b*a</p> 
<p>都说了，b是大表，那么b &gt;a,自然(b+b*a) &gt;(a+a*b)</p> 
<p>仅仅看扫描的次数，也能看到，小表驱动大表方案更优！</p> 
<p>然后，仅仅是如此？</p> 
<p></p> 
<p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/6d/88/hiR12IgN_o.png" width="190"></p> 
<p>       当然不！</p> 
<p>        先说内存方面，将数据加载的内存，然后进行对比，获取到最终的结果，如果大表驱动小表，需要将大表数据加载到内存，无疑，这必然占据大量的系统内存，要知道内存的每一分空间都是珍贵的，内存占用过大，必然会挤压其他线程可以使用的空间。而且如果表数据过大，内存放不下，还必须建立临时表，然后一部分一部分的取数据进行对比，那不用说，更慢！</p> 
<p>        再说，数据IO，将表数据加载到系统内存，肯定要消耗系统IO的。如果是小表驱动大表，也就是需要加载a条数据，然后去匹配过滤数据。反过来，就需要加载b条数据，虽然对比数据的时候都是 a*b次，但是明显加载小表更省IO。</p> 
<p>        然后，看下数据锁定，可以减少锁竞争的可能，当使用小表驱动大表时，可以避免大表上的锁竞争，因为这些锁会在更早的阶段被获取并且释放。而如果是直接访问大表，则需要在整个查询过程中保持锁定状态，这可能导致其他事务无法正常执行。</p> 
<p>        为防忘记，小记一下~</p> 
<p>        如有错误，还望斧正</p> 
<p>    no sacrifice，no victory~       </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c7e34f08273494efee349535cd3c162/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL主从搭建及主从不同步问题处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27eef847847017045ef33dee4203c98a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">element-ui中input组件的autofocus自动聚焦不生效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>