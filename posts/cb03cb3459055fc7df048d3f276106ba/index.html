<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网站如何解决图片过大加载慢的问题？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="网站如何解决图片过大加载慢的问题？" />
<meta property="og:description" content=" 看看这些人的想法能不能帮上你：
甲：
1，不太“在乎”用户体验的省事方法：
图片保存成渐进式的，加载会慢慢变清晰，而不是从上往下依次加载，然后放在 CDN，设置缓存之类。
2，比较“在乎”用户体验的高端方案：
判断用户的设备（主要用在移动端）、网络等，分别加载不同质量的图片（例如高端 iPhone wifi 情况下，就可以加载双倍高清图等，蜂窝网络下面，就加载个单倍或者有损压缩过的）。
或者先加载低质量的图片，让浏览者可以看到，然后再在后台加载更高清的，等加载完了，浏览者还在观看，就插入替换掉。或者先加载低质量小图片列表，然后让用户点击，触发类似 fancybox 的效果，弹窗出现大图片。或者利用资源预加载（三个 HTML5 不常见特性简介）当用户还没打开的时候，就开始加载。还有好多思路，后面想到再补充。
乙：
压缩，预加载，缓存，图床。
丙：
1.使用缓存
2.使用CDN加速
3.使用jq延迟加载图片, 用到那个 加载哪个.
4.加大服务器宽带
5.检查服务器硬盘读取速度.
丁：
要尽可能的压缩，看用户的忍受程度。jpg 可以用很多方法压缩，png 推荐使用 工具（不过正文图片，显然要选择 jpg 格式的）。
推荐个压缩图片的神器：
https://tinypng.com/ 如图所示：
不过缺点就是不能设置压缩比例。只能直接压缩至最小。作为大banner图的有时候清晰度就不够达标。
戊：
直接一开始用压缩过的体积小的图，等加载完毕后，再用高清无码图来替换掉
高清无码的图片随便怎么命名，但是压缩过的命名有要求，那就是必须在原图的名称前面加上相同的便于分辨的标识。比如
高清图1命名为wozuishuai.jpg 那么相应的压缩图就叫wozuishuai_min.jpg (_min这个随你取名，但是要一致，不能一个叫_min,下一个就成了_small)
然后，高清图在网页上都不用，用压缩过的图。比如这样子
这样子，你打开网页的速度就会快很多，但是图片会失真，虽然有的时候不影响使用，但是会影响用户的体验，以及老板拍桌子骂你干什么吃的？ 不用怕，可以用下面这段代码来解决这个问题，这个是基于jq的，要先引入jq &lt;script&gt; $(function(){ //一段正则，匹配所有_min.的图片src属性 var test = /_min\./ //遍历所有的图片节点 $(&#34;img&#34;).each(function(index,obj){	if(test.test($(this).attr(&#34;src&#34;))){ var reSrc = $(this).attr(&#34;src&#34;).replace(test,&#34;.&#34;); $(this).attr(&#34;src&#34;,reSrc) }	}) }) &lt;/script&gt; 最后我们用一张图来测试下这个方法的可行性 其实不用1s，这些图基本上都可以用了，都可以看了，只不过我们这个是东郭先生，滥竽充数，但是最起码能知道图片讲的什么内容。但是，如果只加载高清图，那么，用户势必要等待好几s甚至十几s。这样的话，用户是很容易抛弃这个网站的。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cb03cb3459055fc7df048d3f276106ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-07-26T15:17:11+08:00" />
<meta property="article:modified_time" content="2017-07-26T15:17:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网站如何解决图片过大加载慢的问题？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:14px"><strong>看看这些人的想法能不能帮上你：</strong></span></p> 
<p><span style="font-size:14px"><strong><br> </strong></span></p> 
<p><strong><span style="font-size:14px">甲：</span></strong></p> 
<p><span style="font-size:12px">1，不太“在乎”用户体验的省事方法：</span></p> 
<p><span style="font-size:12px">图片保存成渐进式的，加载会慢慢变清晰，而不是从上往下依次加载，然后放在 CDN，设置缓存之类。</span></p> 
<p><span style="font-size:12px"><br> </span></p> 
<p><span style="font-size:12px">2，比较“在乎”用户体验的高端方案：</span></p> 
<p><span style="font-size:12px">判断用户的设备（主要用在移动端）、网络等，分别加载不同质量的图片（例如高端 iPhone wifi 情况下，就可以加载双倍高清图等，蜂窝网络下面，就加载个单倍或者有损压缩过的）。</span></p> 
<p><span style="font-size:12px">或者先加载低质量的图片，让浏览者可以看到，然后再在后台加载更高清的，等加载完了，浏览者还在观看，就插入替换掉。或者先加载低质量小图片列表，然后让用户点击，触发类似 fancybox 的效果，弹窗出现大图片。或者利用资源预加载（三个 HTML5 不常见特性简介）当用户还没打开的时候，就开始加载。还有好多思路，后面想到再补充。<br> </span></p> 
<p><span style="font-size:12px"><br> </span></p> 
<p><strong><span style="font-size:14px">乙：</span></strong></p> 
<p><span style="font-size:12px">压缩，预加载，缓存，图床。</span></p> 
<p><span style="font-size:12px"><br> </span></p> 
<p><strong><span style="font-size:14px">丙：</span></strong></p> 
<p><span style="font-size:12px">1.使用缓存</span></p> 
<span style="font-size:12px">2.使用CDN加速<br> 3.使用jq延迟加载图片, 用到那个 加载哪个.<br> 4.加大服务器宽带<br> </span> 
<p><span style="font-size:12px">5.检查服务器硬盘读取速度.</span></p> 
<p><span style="font-size:12px"><br> </span></p> 
<p><strong><span style="font-size:14px">丁：</span></strong></p> 
<p><span style="font-size:12px"><span style='color:rgb(38,38,38); font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","Noto Sans CJK SC","WenQuanYi Micro Hei",Arial,sans-serif; white-space:pre-wrap'>要尽可能的压缩，看用户的忍受程度。jpg 可以用很多方法压缩，png 推荐使用 </span><span style='color:rgb(38,38,38); font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","Noto Sans CJK SC","WenQuanYi Micro Hei",Arial,sans-serif; white-space:pre-wrap'>工具（不过正文图片，显然要选择 jpg 格式的）。</span><br> </span></p> 
<p><span style="font-size:12px">推荐个压缩图片的神器：</span></p> 
<p><span style="font-size:12px">https://tinypng.com/      如图所示：<br> </span></p> 
<p><span style="font-size:12px"><br> </span></p> 
<p><span style="font-size:12px"><img src="https://images2.imgbox.com/ef/72/73teW9N1_o.png" alt=""><br> </span></p> 
<p><span style="font-size:12px"><br> </span></p> 
<p><span style="font-size:12px"><br> </span></p> 
<p><span style="font-size:12px">不过缺点就是不能设置压缩比例。只能直接压缩至最小。作为大banner图的有时候清晰度就不够达标。</span></p> 
<p><span style="font-size:12px"><br> </span></p> 
<p><strong><span style="font-size:14px">戊：</span></strong></p> 
<p><span style="font-size:12px"></span></p> 
<div> 
 <div> 
  <p>直接一开始用压缩过的体积小的图，等加载完毕后，再用高清无码图来替换掉</p> 
  <p>高清无码的图片随便怎么命名，但是压缩过的命名有要求，那就是必须在原图的名称前面加上相同的便于分辨的标识。比如</p> 
  <p>高清图1命名为wozuishuai.jpg 那么相应的压缩图就叫wozuishuai_min.jpg (_min这个随你取名，但是要一致，不能一个叫_min,下一个就成了_small)</p> 
  <p>然后，高清图在网页上都不用，用压缩过的图。比如这样子</p> 
 </div> 
 <br> 
 <img src="https://images2.imgbox.com/00/48/JZA0sKIf_o.png" alt=""> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div>
  这样子，你打开网页的速度就会快很多，但是图片会失真，虽然有的时候不影响使用，但是会影响用户的体验，以及老板拍桌子骂你干什么吃的？ 
 <br> 
 <br> 不用怕，可以用下面这段代码来解决这个问题，这个是基于jq的，要先引入jq 
</div> 
<div> 
 <br> 
 <pre><code class="language-html">&lt;script&gt;
$(function(){
//一段正则，匹配所有_min.的图片src属性
var test = /_min\./
//遍历所有的图片节点
$("img").each(function(index,obj){	
if(test.test($(this).attr("src"))){
var reSrc = $(this).attr("src").replace(test,".");
$(this).attr("src",reSrc)
}	
})
})
&lt;/script&gt;</code></pre> 
 <br> 最后我们用一张图来测试下这个方法的可行性 
 <br> 
 <img src="https://images2.imgbox.com/d6/89/tkjawNsG_o.png" alt=""> 
 <br> 
 <br> 
 <br> 
</div> 
<div>
  其实不用1s，这些图基本上都可以用了，都可以看了，只不过我们这个是东郭先生，滥竽充数，但是最起码能知道图片讲的什么内容。但是，如果只加载高清图，那么，用户势必要等待好几s甚至十几s。这样的话，用户是很容易抛弃这个网站的。 
 <br> 
</div> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cfb344d95750c40aafb8dca191453f17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决文件嵌套太深无法删除问题。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ee20fc4f8b8759211d1bd3014006302f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 内存溢出和内存泄漏的区别以及造成的原因</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>