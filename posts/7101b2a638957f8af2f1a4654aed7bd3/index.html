<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅出Vue 错误处理机制errorCaptured、errorHandler - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅出Vue 错误处理机制errorCaptured、errorHandler" />
<meta property="og:description" content="引子 JavaScript本身是一个弱类型语言，项目中容易发生错误，做好网页错误监控，能帮助开发者迅速定位问题，保证线上稳定。vue项目需接入公司内部监控平台，本人之前vue errorHooks不甚了解, 决定探一探?
介绍 errorHandler、errorCaptured 文档传送门: errorHandler、errorCaptured
errorHandler 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例
Vue.config.errorHandler = function (err, vm, info) { #处理错误信息, 进行错误上报 #err错误对象 #vm Vue实例 #`info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 #只在 2.2.0&#43; 可用 } 版本分割点 2.2.0 起，捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃2.4.0 起，也会捕获 Vue 自定义事件处理函数内部的错误2.6.0 起，也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理 errorCaptured 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播
错误传播规则 默认情况下，如果全局的 config.errorHandler定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler，不能捕获异步promise内部抛出的错误和自身的错误一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7101b2a638957f8af2f1a4654aed7bd3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-03T15:57:50+08:00" />
<meta property="article:modified_time" content="2019-04-03T15:57:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅出Vue 错误处理机制errorCaptured、errorHandler</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4>引子</h4> 
<p>JavaScript本身是一个弱类型语言，项目中容易发生错误，做好网页错误监控，能帮助开发者迅速定位问题，保证线上稳定。vue项目需接入公司内部监控平台，本人之前vue errorHooks不甚了解, 决定探一探?</p> 
<h4>介绍 errorHandler、errorCaptured</h4> 
<p>文档传送门: <a href="https://cn.vuejs.org/v2/api/" rel="nofollow noreferrer">errorHandler</a>、<a href="https://cn.vuejs.org/v2/api/" rel="nofollow noreferrer">errorCaptured</a></p> 
<h5>errorHandler</h5> 
<p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例</p> 
<pre><code>


Vue.config.errorHandler = function (err, vm, info) {
  #处理错误信息, 进行错误上报
  #err错误对象
  #vm Vue实例
  #`info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子
  #只在 2.2.0+ 可用
}
</code></pre> 
<blockquote>
  版本分割点 
</blockquote> 
<ul><li>2.2.0 起，捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃</li><li>2.4.0 起，也会捕获 Vue 自定义事件处理函数内部的错误</li><li>2.6.0 起，也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理</li></ul> 
<h5>errorCaptured</h5> 
<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播</p> 
<blockquote>
  错误传播规则 
</blockquote> 
<ul><li>默认情况下，如果全局的 config.errorHandler定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报</li><li>如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。</li><li>如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler，不能捕获异步promise内部抛出的错误和自身的错误</li><li>一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler</li></ul> 
<h4>错误信息示例 errorHandler、errorCaptured</h4> 
<p>光说不练，说了白干，呈上结果供各位看官老爷查看</p> 
<blockquote>
  mounted hook 写入未定义的变量，例如：a 
 <br>mounted() {a} 
</blockquote> 
<ul><li>Vue.config.errorHandler err、vm、info</li></ul> 
<p><img src="https://images2.imgbox.com/32/95/Soe3A4lc_o.jpg" alt="在这里插入图片描述"></p> 
<ul><li>Vue.config.errorHandler 抛出同样的错误 throw err</li></ul> 
<p>globalHandleError函数有 e !== err 判断防止log两次错误<br></p> 
<p><img src="https://images2.imgbox.com/a0/98/2cV6nkvN_o.jpg" alt="在这里插入图片描述"></p> 
<ul><li>Vue.config.errorHandler 抛出新的错误 throw new Error('你好毒')</li></ul> 
<p><img src="https://images2.imgbox.com/02/95/xS5lm7WY_o.jpg" alt="在这里插入图片描述"></p> 
<ul><li>errorCaptured (err, vm, info) =&gt; ?Boolean 类似于React 错误处理边界</li></ul> 
<pre><code>


&amp;lt;error-boundary&amp;gt;
  &amp;lt;another-component/&amp;gt;
&amp;lt;/error-boundary&amp;gt;
</code></pre> 
<pre><code>


Vue.component('ErrorBoundary', {
  data: () =&amp;gt; ({ error: null }),
  errorCaptured (err, vm, info) {
    this.error = `${err.stack}\n\nfound in ${info} of component`
    return false
  },
  render (h) {
    if (this.error) {
      return h('pre', { style: { color: 'red' }}, this.error)
    }
    // ignoring edge cases for the sake of demonstration
    return this.$slots.default[0]
  }
})
</code></pre> 
<h4>正文</h4> 
<p>copy 半天官网文档，你是copy忍者吗☺，各位看官老爷，请往下面看，注意自己使用时的Vue版本，避免err抓取不到?</p> 
<h5>解读error.js源码</h5> 
<p>Vue 源码中，异常处理的逻辑放在 /src/core/util/error.js 中</p> 
<blockquote>
  handleError、globalHandleError、invokeWithErrorHandling、logError 
</blockquote> 
<ul><li>handleError</li></ul> 
<p>在需要捕获异常的地方调用。首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法。在遍历调用完所有 errorCaptured 方法、或 errorCaptured 方法有报错时，调用 globalHandleError 方法</p> 
<ul><li>globalHandleError</li></ul> 
<p>调用全局的 errorHandler 方法，如果 errorHandler 方法自己又报错了呢？生产环境下会使用 console.error 在控制台中输出</p> 
<ul><li>invokeWithErrorHandling</li></ul> 
<p>更好的异步错误处理，当时写这篇文章时，git history显示小右哥，一周之前敲的代码，瞬间透心凉，心飞扬</p> 
<ul><li>logError</li></ul> 
<p>判断环境，选择不同的抛错方式。非生产环境下，调用warn方法处理错误</p> 
<p>errorCaptured 和 errorHandler 的触发时机都是相同的，不同的是 errorCaptured 发生在前，且如果某个组件的 errorCaptured 方法返回了 false，那么这个异常信息不会再向上冒泡也不会再调用 errorHandler 方法</p> 
<pre><code>


/* @flow */
# Vue 全局配置,也就是上面的Vue.config
import config from '../config'
import { warn } from './debug'
# 判断环境
import { inBrowser, inWeex } from './env'
# 判断是否是Promise，通过val.then === 'function' &amp;amp;&amp;amp; val.catch === 'function', val ！=== null &amp;amp;&amp;amp; val !== undefined
import { isPromise } from 'shared/util'
# 当错误函数处理错误时，停用deps跟踪以避免可能出现的infinite rendering
# 解决以下出现的问题https://github.com/vuejs/vuex/issues/1505的问题
import { pushTarget, popTarget } from '../observer/dep'

export function handleError (err: Error, vm: any, info: string) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  pushTarget()
  try {
    # vm指当前报错的组件实例
    if (vm) {
      let cur = vm
      # 首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法。
      # 在遍历调用完所有 errorCaptured 方法、或 errorCaptured 方法有报错时，调用 globalHandleError 方法
      while ((cur = cur.$parent)) {
        const hooks = cur.$options.errorCaptured
        # 判断是否存在errorCaptured钩子函数
        if (hooks) {
        # 选项合并的策略，钩子函数会被保存在一个数组中
          for (let i = 0; i &amp;lt; hooks.length; i++) {
            # 如果errorCaptured 钩子执行自身抛出了错误，
            # 则用try{}catch{}捕获错误，将这个新错误和原本被捕获的错误都会发送给全局的config.errorHandler
            # 调用globalHandleError方法
            try {
              # 当前errorCaptured执行，根据返回是否是false值
              # 是false，capture = true，阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler
              # 是true capture = fale，组件的继承或父级从属链路中存在的多个 errorCaptured 钩子，会被相同的错误逐个唤起
              # 调用对应的钩子函数，处理错误
              const capture = hooks[i].call(cur, err, vm, info) === false
              if (capture) return
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook')
            }
          }
        }
      }
    }
    # 除非禁止错误向上传播，否则都会调用全局的错误处理函数
    globalHandleError(err, vm, info)
  } finally {
    popTarget()
  }
}
# 异步错误处理函数
export function invokeWithErrorHandling (
  handler: Function,
  context: any,
  args: null | any[],
  vm: any,
  info: string
) {
  let res
  try {
    # 根据参数选择不同的handle执行方式
    res = args ? handler.apply(context, args) : handler.call(context)
    # handle返回结果存在
    # res._isVue an flag to avoid this being observed，如果传入值的_isVue为ture时(即传入的值是Vue实例本身)不会新建observer实例
    # isPromise(res) 判断val.then === 'function' &amp;amp;&amp;amp; val.catch === 'function', val ！=== null &amp;amp;&amp;amp; val !== undefined
    # !res._handled  _handle是Promise 实例的内部变量之一，默认是false，代表onFulfilled,onRejected是否被处理
    if (res &amp;amp;&amp;amp; !res._isVue &amp;amp;&amp;amp; isPromise(res) &amp;amp;&amp;amp; !res._handled) {
      res.catch(e =&amp;gt; handleError(e, vm, info + ` (Promise/async)`))
      # avoid catch triggering multiple times when nested calls
      # 避免嵌套调用时catch多次的触发
      res._handled = true
    }
  } catch (e) {
    # 处理执行错误
    handleError(e, vm, info)
  }
  return res
}

#全局错误处理
function globalHandleError (err, vm, info) {
  # 获取全局配置，判断是否设置处理函数，默认undefined
  # 已配置
  if (config.errorHandler) {
    # try{}catch{} 住全局错误处理函数
    try {
      # 执行设置的全局错误处理函数，handle error 想干啥就干啥?
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      # 如果开发者在errorHandler函数中手动抛出同样错误信息throw err
      # 判断err信息是否相等，避免log两次
      # 如果抛出新的错误信息throw err Error('你好毒')，将会一起log输出
      if (e !== err) {
        logError(e, null, 'config.errorHandler')
      }
    }
  }
  # 未配置常规log输出
  logError(err, vm, info)
}

# 错误输出函数
function logError (err, vm, info) {
  if (process.env.NODE_ENV !== 'production') {
    warn(`Error in ${info}: "${err.toString()}"`, vm)
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) &amp;amp;&amp;amp; typeof console !== 'undefined') {
    console.error(err)
  } else {
    throw err
  }
}
</code></pre> 
<h4>欢乐时光</h4> 
<p>以上是本人对vue 错误处理的浅显理解，欢迎大家评论交流，共同进步， enjoy !</p> 
<h5>参考文档：</h5> 
<p><a href="https://cn.vuejs.org/v2/api/" rel="nofollow noreferrer">vue错误api</a><br><a href="https://zhuanlan.zhihu.com/p/37404624" rel="nofollow noreferrer">vue错误处理</a><br><a href="https://www.jqhtml.com/15698.html" rel="nofollow noreferrer">Promise源码剖析</a><br><a href="https://github.com/vuejs/vue/issues/7074" rel="nofollow noreferrer">vue/issues/7074</a></p> 
<p>来源：<a href="https://segmentfault.com/a/1190000018606181" rel="nofollow">https://segmentfault.com/a/1190000018606181</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d7f9221bf54764ee8e65ec494b9b30f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL 宏</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f231805516be3b4ac1858739fdb937e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">laravel 路由404问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>