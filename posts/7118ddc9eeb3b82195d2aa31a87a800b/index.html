<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【时空序列预测paper】PredRNN: Recurrent Neural Networks for PredictiveLearning using Spatiotemporal LSTMs - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【时空序列预测paper】PredRNN: Recurrent Neural Networks for PredictiveLearning using Spatiotemporal LSTMs" />
<meta property="og:description" content="前言： 论文和两位大佬的解读一起看AI蜗牛车和翻滚的小@强
论文原文：PredRNN: Recurrent Neural Networks for Predictive Learning using Spatiotemporal LSTMs
Abstract: 1.介绍任务：时空序列的预测是通过从历史帧中学习来生成未来图像
2.提出一种新的递归网络结构(PredRNN)：认为时空预测的学习应该在一个统一的记忆池中同时记录空间和时间的变化
3.简单介绍模型结构：内存状态不再局限于每个LSTM单元内，它们可以在两个方向上进行传递：垂直穿过堆叠的RNN层，水平穿过所有的RNN状态。模型结构的核心是一个新的时空LSTM(ST-LSTM)，该LSTM可以同时提取和存储空间和时间表示。
4.介绍实验结果：PredRNN在三个视频预测数据集上实现了最先进的预测性能
Introduction： 1.1 why spatiotemporal memory?
时空预测学习中，有两个关键方面：空间变化和时间变化。简述时空监督学习和时空预测学习的不同：
时空监督学习一般满足两个条件：1）时间特征对于分类任务来说足够强大，空间特征不需要很显著；2）不需要输出复杂的空间结构，所以空间表示可以高度抽象时空预测学习则完全不同，空间变化和时间变化对于生成未来帧同样重要。也就是说，为了更好的预测未来帧，对历史帧学习的时候，不仅仅要学习物体的运动，还要学习到从粗到细的视觉现象 基于此
提出了一种称为Predictive RNN的新的递归架构：它允许不同LSTM的内存状态跨层交互（特别说明：传统RNN中，内存状态不可以跨层交互）
设计了一种称为ST-LSTM的时空单元：它在一个统一的存储空间中对空间变化和时间变化进行建模，同时可以在垂直层和水平层传递状态。
1.2 Related work
之前的工作各有各的不完善性。1）基于RNN体系结构使用LSTM进行建模，由于缺少细粒度的视觉外观，预测图像会变模糊；2）集于CNN的网络，一次预测一帧，更关注于图像外观，捕获长期运动方面比较弱。
Preliminaries: 2.1 Spatiotemporal predictive learning
介绍一下时空预测，时空预测经典公式：
2.2 Convolutional LSTM
介绍一下ConvLSTM，更详细的内容可以看ConvLSTM介绍。指出了ConvLSTM的不足之处：假设对于4层的ConvLSTM编解码网络，输入帧会输入到第一层ConvLSTM，未来的输出帧是在第四层ConvLSTM，在传递的过程中，空间结构被一层一层的解码，同时隐藏状态自下而上的传递。但是，记忆单元在这四层结构中是相互独立的，只在同层的时域之间传递，那么，地层就会完全忽略顶层在上个时间步中记住的内容。克服这种层独立记忆机制的缺点对于视频预测非常重要。
借蜗牛车的图展示一下上面描述的内容：
相同色块的记忆单元没有时间信息的联系。
PredRNN 介绍灵感来源：1）最开始来源于一个想法：预测性学习系统应该在统一的记忆池中记忆空间和时间的变化。然后就让记忆状态沿着Z字形的方向流过整个网络。2）后来想更进一步：想要使时空记忆与原始的长短期记忆相互作用，因此对LSTM和ConvLSTM的内部存储单元、存储门和存储融合机制进行了探索。最后推导出了能在水平和竖直方向上传递存储状态的ST-LSTM。
3.1 Spatiotemporal memory flow
右边：将ConvLSTM进行了堆叠，堆叠后的ConvLSTM逐层抽取高度抽象的特征，然后通过将它们映射回像素值空间进行预测。看图中，记忆单元被限制到只能水平更新，信息只能由隐藏状态向上传递。这种时间记忆流的方式对时空监督学习是有效的，这些隐藏层从下到上会越来越抽象和特定于类。
左边：但是在时空预测学习中，原始输入序列的详细信息应该保持不变，如果我们想展望未来，我们需要从不同级别的卷积层提取的特征中学习。因此，构建了如左图的结构，橙色箭头代表LSTM存储单元的前馈方向。所有的LSTM共享一个统一的内存，该内存沿之字形方向更新。
简单来说：t时刻的第一层cell接收上一个时间步的最后一层cell的隐藏状态和记忆状态，经过第一层传递给第二层一直到最后一层。
3.2 Spatiotemporal memory flow
ST-LSTM以及最终版的结构，橙色的部分是新加入的时空记忆模块M，这一块负责层与层之间的时空记忆传递，白色部分是时间记忆模块C，这一块负责横向时间的流传递。总公式如下：
Experiments 一共在三个数据集上做了实验：MovingMNIST、KTH和radar echo，在这三个数据集上的表现都达到了最好。使用的损失函数是L1&#43;L2loss，特别说明其他的损失函数也用过，但是L1&#43;L2loss效果最好。初始学习率是10-3，这里应该用了动态学习率，迭代了8万次，batch_size为8
1 MovingMNIST
多次实验后，最优架构为4层ST-LSTM，每层128个隐藏状态。实验结果如下
VPN在长期预测表现很差，虽然有时候图像清晰，但是轨迹可能预测的非常不准（比如把8和0相遇后预测成为了3）。相比之下，PredRNN的结果不仅清晰，对于长期运动预测也更准确。
2 KTH action dataset" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7118ddc9eeb3b82195d2aa31a87a800b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-01T10:50:18+08:00" />
<meta property="article:modified_time" content="2022-04-01T10:50:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【时空序列预测paper】PredRNN: Recurrent Neural Networks for PredictiveLearning using Spatiotemporal LSTMs</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>前言：</strong></h2> 
<p>论文和两位大佬的解读一起看<a class="link-info" href="https://chehongshu.blog.csdn.net/article/details/104128016" rel="nofollow" title="AI蜗牛车">AI蜗牛车</a>和<a class="link-info" href="https://zhongqiang.blog.csdn.net/article/details/104348099" rel="nofollow" title="翻滚的小@强">翻滚的小@强</a></p> 
<p>论文原文：<a class="link-info" href="https://proceedings.neurips.cc/paper/2017/hash/e5f6ad6ce374177eef023bf5d0c018b6-Abstract.html" rel="nofollow" title="PredRNN: Recurrent Neural Networks for Predictive Learning using Spatiotemporal LSTMs">PredRNN: Recurrent Neural Networks for Predictive Learning using Spatiotemporal LSTMs</a></p> 
<h2>Abstract:</h2> 
<p><strong>1.介绍任务：</strong>时空序列的预测是通过从历史帧中学习来生成未来图像</p> 
<p><strong>2.提出一种新的递归网络结构(PredRNN)：</strong>认为时空预测的学习应该在一个统一的记忆池中同时记录空间和时间的变化</p> 
<p><strong>3.简单介绍模型结构：</strong>内存状态不再局限于每个LSTM单元内，它们可以在两个方向上进行传递：垂直穿过堆叠的RNN层，水平穿过所有的RNN状态。模型结构的核心是一个新的时空LSTM(ST-LSTM)，该LSTM可以同时提取和存储空间和时间表示。</p> 
<p><strong>4.介绍实验结果：</strong>PredRNN在三个视频预测数据集上实现了最先进的预测性能</p> 
<h2><strong>Introduction：</strong></h2> 
<p><strong>1.1 why spatiotemporal memory?</strong></p> 
<p>时空预测学习中，有两个关键方面：<strong>空间变化和时间变化</strong>。简述时空监督学习和时空预测学习的不同：</p> 
<ul><li>时空监督学习一般满足两个条件：1）时间特征对于分类任务来说足够强大，空间特征不需要很显著；2）不需要输出复杂的空间结构，所以空间表示可以高度抽象</li><li>时空预测学习则完全不同，空间变化和时间变化对于生成未来帧同样重要。也就是说，为了更好的预测未来帧，对历史帧学习的时候，不仅仅要学习物体的运动，还要学习到从粗到细的视觉现象</li></ul> 
<p>基于此</p> 
<p>提出了一种称为Predictive RNN的新的递归架构：它允许不同LSTM的内存状态跨层交互（特别说明：传统RNN中，内存状态不可以跨层交互）</p> 
<p>设计了一种称为ST-LSTM的时空单元：它在一个统一的存储空间中对空间变化和时间变化进行建模，同时可以在垂直层和水平层传递状态。</p> 
<p><strong>1.2 Related work</strong></p> 
<p>之前的工作各有各的不完善性。1）基于RNN体系结构使用LSTM进行建模，由于缺少细粒度的视觉外观，预测图像会变模糊；2）集于CNN的网络，一次预测一帧，更关注于图像外观，捕获长期运动方面比较弱。</p> 
<h2>Preliminaries:</h2> 
<p><strong>2.1 Spatiotemporal predictive learning</strong></p> 
<p>介绍一下时空预测，时空预测经典公式：</p> 
<p class="img-center"><img alt="" height="39" src="https://images2.imgbox.com/f9/b5/lA8ittdM_o.png" width="443"></p> 
<p><strong> 2.2 Convolutional LSTM</strong></p> 
<p>介绍一下ConvLSTM，更详细的内容可以看<a class="link-info" href="https://blog.csdn.net/qq_46919013/article/details/123432103?spm=1001.2014.3001.5501" title="ConvLSTM介绍">ConvLSTM介绍</a>。指出了ConvLSTM的不足之处：假设对于4层的ConvLSTM编解码网络，输入帧会输入到第一层ConvLSTM，未来的输出帧是在第四层ConvLSTM，在传递的过程中，空间结构被一层一层的解码，同时<strong>隐藏状态</strong>自下而上的传递。但是，<strong>记忆单元</strong>在这四层结构中是相互独立的，只在同层的时域之间传递，那么，地层就会完全忽略顶层在上个时间步中记住的内容。克服这种层独立记忆机制的缺点对于视频预测非常重要。</p> 
<p>借蜗牛车的图展示一下上面描述的内容：</p> 
<p class="img-center"><img alt="" height="222" src="https://images2.imgbox.com/bc/87/v0Vdldwv_o.png" width="290"></p> 
<p> 相同色块的记忆单元没有时间信息的联系。</p> 
<h2>PredRNN</h2> 
<p>介绍灵感来源：1）最开始来源于一个想法：预测性学习系统应该在统一的记忆池中记忆空间和时间的变化。然后就让记忆状态沿着Z字形的方向流过整个网络。2）后来想更进一步：想要使时空记忆与原始的长短期记忆相互作用，因此对LSTM和ConvLSTM的内部存储单元、存储门和存储融合机制进行了探索。最后推导出了能在水平和竖直方向上传递存储状态的ST-LSTM。</p> 
<p><strong>3.1 Spatiotemporal memory flow</strong></p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/f7/7c/8n0iGTuj_o.png" width="992"></p> 
<p> 右边：将ConvLSTM进行了堆叠，堆叠后的ConvLSTM逐层抽取高度抽象的特征，然后通过将它们映射回像素值空间进行预测。看图中，记忆单元被限制到只能水平更新，信息只能由隐藏状态向上传递。这种时间记忆流的方式对时空监督学习是有效的，这些隐藏层从下到上会越来越抽象和特定于类。</p> 
<p>左边：但是在时空预测学习中，<strong>原始输入序列的详细信息应该保持不变</strong>，如果我们想展望未来，我们需要从不同级别的卷积层提取的特征中学习。因此，构建了如左图的结构，橙色箭头代表LSTM存储单元的前馈方向。所有的LSTM共享一个统一的内存，该内存沿之字形方向更新。</p> 
<p>简单来说：<strong>t时刻的第一层cell接收上一个时间步的最后一层cell的隐藏状态和记忆状态，经过第一层传递给第二层一直到最后一层。</strong></p> 
<p><strong>3.2 Spatiotemporal memory flow</strong></p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/dd/2f/K1EY29In_o.png" width="1095"></p> 
<p> ST-LSTM以及最终版的结构，橙色的部分是新加入的时空记忆模块M，这一块负责层与层之间的时空记忆传递，白色部分是时间记忆模块C，这一块负责横向时间的流传递。总公式如下：</p> 
<p class="img-center"><img alt="" height="284" src="https://images2.imgbox.com/fd/8e/YYT1zrYg_o.png" width="482"></p> 
<h2> Experiments</h2> 
<p>一共在三个数据集上做了实验：MovingMNIST、KTH和radar echo，在这三个数据集上的表现都达到了最好。使用的损失函数是L1+L2loss，特别说明其他的损失函数也用过，但是L1+L2loss效果最好。初始学习率是10-3，这里应该用了动态学习率，迭代了8万次，batch_size为8</p> 
<p><strong>1 MovingMNIST</strong></p> 
<p>多次实验后，最优架构为4层ST-LSTM，每层128个隐藏状态。实验结果如下</p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/5c/66/6PLKSfZ6_o.png" width="1032"><img alt="" height="438" src="https://images2.imgbox.com/59/82/Tx6LU8ks_o.png" width="1076"></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/43/dd/jgEpvpAs_o.png" width="1098"></p> 
<p> VPN在长期预测表现很差，虽然有时候图像清晰，但是轨迹可能预测的非常不准（比如把8和0相遇后预测成为了3）。相比之下，PredRNN的结果不仅清晰，对于长期运动预测也更准确。</p> 
<p><strong>2 KTH action dataset</strong></p> 
<p>构建数据集的时候有一个手动修剪过程，保证人始终出现在帧序列内。最终训练集为108717个seq,测试集为4086个seq，预测结果如下</p> 
<p><img alt="" height="392" src="https://images2.imgbox.com/52/39/wqceNMQG_o.png" width="926"></p> 
<p><img alt="" height="625" src="https://images2.imgbox.com/d3/c7/2O8GNB67_o.png" width="1035"></p> 
<p> 用了两个评分：SSIM和PSNR，相似度和峰值信噪比，这也是图像预测的时候经常用到的两个评分。结论还是predrnn表现最好，预测的精度最高，时间最长。</p> 
<p><strong>3 Radar echo dataset</strong></p> 
<p>雷达回波数据集，预测未来雷达回波的形状和运动。它的预测更加困难，他们的形状可能由于天气过程的变化迅速积累，消散或变化。训练集是7800个seq，测试集是1800个seq。两个ST-LSTM和128个隐藏层构成。卷积核设置为3，结果进行Z-R转换后如下图</p> 
<p><img alt="" height="734" src="https://images2.imgbox.com/de/a6/kqwxL7xI_o.png" width="1093"></p> 
<h2> Conclusions</h2> 
<p>提出了一种端到端的网络结构PredRNN，可以同时用来模拟空间和时间变化。设计了ST-LSTM，使用门控双存储器，最终在三个数据集上的表现都是最优的。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70e8f3e4ef74fa0eccea5242f0e06ff7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Win10系统VS2022开发环境中(X86)Win32汇编(MASM32)环境配置和一些示例源码及解释</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e6b4a938d968c1f3e247183a787284cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu SMP 16.04.1使用huggingface/transformers 4.8.2报错 version `GLIBC_2.29‘ not found</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>