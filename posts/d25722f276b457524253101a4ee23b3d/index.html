<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 关闭应用程序的6种方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 关闭应用程序的6种方法" />
<meta property="og:description" content="1.方法一killProcess结束进程
android.os.Process.killProcess(android.os.Process.myPid()); android中所有的activity都在主进程中，在Androidmanifest.xml中可以设置成启动不同进程，Service不是一个单独的进程也不是一个线程。当你Kill掉当前程序的进程时也就是说整个程序的所有线程都会结束，Service也会停止，整个程序完全退出。 2.方法二exit结束java虚拟机
System.exit(0); 这个方法是用来结束当前正在运行中的java虚拟机。如何status是非零参数，那么表示是非正常退出。当调用System.exit(0)时，杀死了整个进程，这时候活动所占的资源也会被释放。 和return 相比有以下不同点：return是回到上一层，而System.exit(status)是回到最上层。进一步探索System.exit被调用后的行为，它在虚拟机在退出前会执行两个清除任务。第一，它会执行所有通过Runtime.addShutdownHook注册的shutdownhooks.它能有效的释放JVM之外的资源。第二，执行清除任务，运行相关的finalizer方法终结对象。 在android手机中查看当前正在运行的进程时可以发现还可以查看&#34;后台缓存的进程&#34;，你会发现很多退出了的程序还在后台缓存的进程中，如果不要让程序在后台缓存那么就可以用System.exit(0);来退出程序了，可以清除后台缓存的本进程，对于有些手机也是没有用的。这是退出Java程序的方法，也可以用来退出Android。 3.方法三通过activity管理器重启，这个方法已经过时，不建议再使用
ActivityManager activitymanager= (ActivityManager)getSystemService (Context.ACTIVITY_SERVICE); activitymanager.restartPackage(getPackageName()); 注意：需要注册的权限&lt;uses-permission android:name=\&#34;android.permission.RESTART_PACKAGES\&#34;&gt;&lt;/uses- permission&gt; 在android2.2版本之后则不能再使用restartPackage()方法，而应该使用killBackgroundProcesses()方法
ActivityManager manager = (ActivityManager)getSystemService(ACTIVITY_SERVICE); manager.killBackgroundProcesses(getPackageName()); //需要在xml中加入权限声明 &lt;uses-permission android:name=&#34;android.permission.KILL_BACKGROUND_PROCESSES&#34;/&gt; 注意：在android2.2以后，如果服务在ondestroy里加上了start自己，用kill backgroudprocess通常无法结束自己。
定外一种方法：利用反射
Method forceStopPackage = am.getClass().getDeclaredMethod(&#34;forceStopPackage&#34;, String.class); forceStopPackage.setAccessible(true); forceStopPackage.invoke(am, yourpkgname); &lt;uses-permission android:name=&#34;android.permission.FORCE_STOP_PACKAGES&#34;&gt;&lt;/uses-permission&gt; 需要在manifest里加上shareduid定义 android:sharedUserId=&#34;android.uid.system&#34; 并且采用系统platform签名
因为需要用FORCE_STOP_PACKAGES权限，该权限只赋予系统签名级程序
4.方法四根据Activity的生命周期
我们知道Android的窗口类提供了历史栈，我们可以通过stack的原理来巧妙的实现，这里我们在A窗口打开B 窗口时在Intent中直接加入标志 Intent.FLAG_ACTIVITY_CLEAR_TOP，这样开启B时将会清除该进程空间的所有Activity。
Intent intent = new Intent(); intent.setClass(MainActivity.this, SecondActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); //注意本行的FLAG设置 startActivity(intent); 5.方法五finish()将活动推向后台
finish();finish是Activity的类，仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理； 6.方法六 比较常用的方法，使用Activity栈管理Activity
package com.example.test; import java.util.ArrayList; import java.util.List; import java." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d25722f276b457524253101a4ee23b3d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-06-16T14:57:52+08:00" />
<meta property="article:modified_time" content="2015-06-16T14:57:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 关闭应用程序的6种方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.方法一killProcess结束进程</p> 
<p></p> 
<pre><code class="language-java">android.os.Process.killProcess(android.os.Process.myPid());</code></pre> 
<span style="font-size:12px">android中所有的activity都在主进程中，在Androidmanifest.xml中可以设置成启动不同进程，Service不是一个单独的进程也不是一个线程。当你Kill掉当前程序的进程时也就是说整个程序的所有线程都会结束，Service也会停止，整个程序完全退出。</span> 
<p></p> 
<p>2.方法二exit结束java虚拟机<br> </p> 
<p></p> 
<pre><code class="language-java">System.exit(0);</code></pre> 
这个方法是用来结束当前正在运行中的java虚拟机。如何status是非零参数，那么表示是非正常退出。当调用System.exit(0)时，杀死了整个进程，这时候活动所占的资源也会被释放。 
和return 相比有以下不同点：return是回到上一层，而System.exit(status)是回到最上层。进一步探索System.exit被调用后的行为，它在虚拟机在退出前会执行两个清除任务。第一，它会执行所有通过Runtime.addShutdownHook注册的shutdownhooks.它能有效的释放JVM之外的资源。第二，执行清除任务，运行相关的finalizer方法终结对象。 
<span style="font-size:12px">在android手机中查看当前正在运行的进程时可以发现还可以查看"后台缓存的进程"，你会发现很多退出了的程序还在后台缓存的进程中，如果不要让程序在后台缓存那么就可以用System.exit(0);来退出程序了，可以清除后台缓存的本进程，对于有些手机也是没有用的。这是退出Java程序的方法，也可以用来退出Android。</span> 
<p><span style="font-size:12px">3.方法三通过activity管理器重启，这个方法已经过时，不建议再使用</span><br> <span style="font-size:12px"></span></p> 
<pre><code class="language-java">ActivityManager activitymanager= (ActivityManager)getSystemService (Context.ACTIVITY_SERVICE);
activitymanager.restartPackage(getPackageName());
注意：需要注册的权限&lt;uses-permission android:name=\"android.permission.RESTART_PACKAGES\"&gt;&lt;/uses-  permission&gt;</code></pre> 
<p>在android2.2版本之后则不能再使用restartPackage()方法，而应该使用killBackgroundProcesses()方法<br> </p> 
<p></p> 
<pre><code class="language-java">ActivityManager manager = (ActivityManager)getSystemService(ACTIVITY_SERVICE);       
manager.killBackgroundProcesses(getPackageName()); </code></pre> 
<span style="font-size:12px"></span> 
<pre><code class="language-java">//需要在xml中加入权限声明    
&lt;uses-permission android:name="android.permission.KILL_BACKGROUND_PROCESSES"/&gt; </code></pre> 
<p></p> 
<p><span style="font-size:12px"></span></p> 
<p><strong><em>注意：在android2.2以后，如果服务在ondestroy里加上了start自己，用kill backgroudprocess通常无法结束自己。</em></strong><span style="font-size:12px"><br> </span></p> 
<p><span style="font-size:12px">定外一种方法：利用反射</span></p> 
<p><span style="font-size:12px"></span></p> 
<pre><code class="language-java">Method forceStopPackage = am.getClass().getDeclaredMethod("forceStopPackage", String.class);  
forceStopPackage.setAccessible(true);  
forceStopPackage.invoke(am, yourpkgname);  
</code></pre> 
<pre><code class="language-java">&lt;uses-permission android:name="android.permission.FORCE_STOP_PACKAGES"&gt;&lt;/uses-permission&gt;
</code></pre> 
<pre><code class="language-java">需要在manifest里加上shareduid定义
android:sharedUserId="android.uid.system"</code></pre> 
<p></p> 
<p><strong>并且采用系统platform签名</strong></p> 
<p>因为需要用FORCE_STOP_PACKAGES权限，该权限只赋予系统签名级程序</p> 
<p><span style="font-size:12px">4.方法四</span>根据Activity的生命周期</p> 
<p>我们知道Android的窗口类提供了历史栈，我们可以通过stack的原理来巧妙的实现，这里我们在A窗口打开B 窗口时在Intent中直接加入标志 Intent.FLAG_ACTIVITY_CLEAR_TOP，这样开启B时将会清除该进程空间的所有Activity。<br> </p> 
<p><span style="font-size:12px"></span></p> 
<pre><code class="language-java">Intent intent = new Intent();
intent.setClass(MainActivity.this, SecondActivity.class);
intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);  //注意本行的FLAG设置
startActivity(intent); </code></pre> 
<p></p> 
<p>5.方法五finish()将活动推向后台</p> 
<p></p> 
<pre><code class="language-java">finish();</code></pre>finish是Activity的类，仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理； 
<br> 
<p></p> 
<p>6.方法六 比较常用的方法，使用Activity栈管理Activity</p> 
<p></p> 
<pre><code class="language-java">package com.example.test;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import android.app.Activity;
import android.content.Context;

/**
 * @author Administrator Panca 上午11:19:49
 *
 *	描述: 应用程序Activity管理类：用于Activity管理和应用程序退出
 *
 * Tel: 15211164134 QQ: 643691522
 */
public class ActManager {
	
	private static Stack&lt;Activity&gt; activityStack;
	private static ActManager instance;
	
	/**
	 * 单例模式 创建单一实例
	 * @return
	 */
	public static ActManager getAppManager() {
		if (instance == null) {
			instance = new ActManager();
		}
		return instance;
	}

	/**
	 * 初始化Stack&lt;Activity&gt;
	 */
	private void initActivityStack() {
		if (activityStack == null) {
			activityStack = new Stack&lt;Activity&gt;();
		}
	}
	
	/**
	 * 添加Activity到堆栈
	 * @param activity
	 */
	public void addActivity(Activity activity) {
		initActivityStack();
		activityStack.add(activity);
	}
	
	/**
	 * 获取当前Activity（堆栈中最后一个压入的）
	 * @return
	 */
	public Activity currentActivity() {
		Activity activity = activityStack.lastElement();
		return activity;
	}
	
	/**
	 * 结束指定的Activity
	 */
	public void finishActivity(Activity activity) {
		if (activity != null) {
			activityStack.remove(activity);
			activity.finish();
			activity = null;
		}
	}
	
	/**
	 * 结束当前Activity（堆栈中最后一个压入的）
	 */
	public void finishActivity() {
		//获取到当前Activity
		Activity activity = activityStack.lastElement();
		//结束指定Activity
		finishActivity(activity);
	}
	
	/**
	 * 结束指定类名的Activity
	 */
	public void finishActivity(Class&lt;?&gt; cls) {
		List&lt;Activity&gt; activities = new ArrayList&lt;Activity&gt;();
		for (Activity activity : activityStack) {
			if (activity.getClass().equals(cls)) {
				// finishActivity(activity);
				activities.add(activity);
			}
		}
		// 结束所有类名相同activity
		activityStack.removeAll(activities);
		for (Activity activity : activities) {
			finishActivity(activity);
		}
	}
	
	/**
	 * 结束所有Activity
	 */
	public void finishAllActivity() {
		for (int i = 0, size = activityStack.size(); i &lt; size; i++) {
			if (null != activityStack.get(i)) {
				Activity activity = activityStack.get(i);
				if (!activity.isFinishing()) {
					activity.finish();
				}
			}
		}
		activityStack.clear();
	}
	
	/**
	 * 退出应用程序
	 * 这里关闭的是所有的Activity，没有关闭Activity之外的其他组件;
	 * android.os.Process.killProcess(android.os.Process.myPid())
	 * 杀死进程关闭了整个应用的所有资源，有时候是不合理的，通常是用
	 * 堆栈管理Activity;System.exit(0)杀死了整个进程，这时候活动所占的
	 * 资源也会被释放,它会执行所有通过Runtime.addShutdownHook注册的shutdown hooks.
	 * 它能有效的释放JVM之外的资源,执行清除任务，运行相关的finalizer方法终结对象，
	 * 而finish只是退出了Activity。
	 */
	public void AppExit(Context context) {
		try {
			finishAllActivity();
			//DalvikVM的本地方法
			// 杀死该应用进程
			//android.os.Process.killProcess(android.os.Process.myPid());
			//System.exit(0);
			//这些方法如果是放到主Activity就可以退出应用，如果不是主Activity
			//就是退出当前的Activity
		} catch (Exception e) {
		}
	}
}
</code></pre> 
<br> 如果是在主Activity中就退出应用，反之就是退出当前Activity。用于学习，大家根据不同的需要使用。 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/75c266186a08279e1916821b9d00e7cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java数组求平均数且输出大于平均数的数字</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8cf2de51e60785af67c9fe8467ef984a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在SAS数据集中插入列并赋值</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>