<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringCloud系列篇：核心组件之配置中心组件 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringCloud系列篇：核心组件之配置中心组件" />
<meta property="og:description" content="🥳🥳Welcome Huihui&#39;s Code World ! !🥳🥳 接下来看看由辉辉所写的关于SpringCloud的相关操作吧
目录
🥳🥳Welcome Huihui&#39;s Code World ! !🥳🥳
一.前言
二.配置中心组件是什么
三. 为什么要使用配置中心组件
四.使用配置中心组件的步骤 1.引入依赖
2.进入nacos编写配置
3.读取配置 4.不同环境下的配置
一.前言 微服务意味着要将单体应用中的业务拆分成一个个子服务,每个服务的粒度相对较小,因此系统中会出现大量的服务。 由于每个服务都需要必要的配置信息才能运行,所以一套集中式的,动态的配置管理设施是必不可少的。 Spring Cloud 提供了 ConfigServer来解决这个问题. Spring Cloud Config 为微服务架构中的微服务提供集中化的外部配置支持,配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。 SpringCloud Config 分为服务端和客户端两部分。
服务端也称为分布式配置中心,他是一个独立的微服务应用,用来连接配置服务器并为客户端提供获取配置信息,加密/解密信息等访问接口。
客户端则是通过制定的配置中心来管理应用资源,以及与业务相关的配置内容,并在启动的时候从配置中心 获取和加载配置信息，配置服务器默认采用git来存储配置信息,这样就有助于对环境配置进行版本管理,并 且可以通过git客户端工具来方便的管理和访问配置内容
一个使用微服务架构的应用系统可能会包括成百上千个微服务,配置各部相同,需求各不相同：
不同环境不同配置：例如数据源在不同的环境（开发,测试,生产）是不同的,可以通过配置中心运行期间可以动态调整：例如根据各个微服务的负载状况,动态调整数据源连接池大小或者熔断阀 值,并且调整时不停止微服务（配置修改后可以自动更新） 二.配置中心组件是什么 配置中心组件是一种用于管理应用程序配置信息的工具或服务。它通常可以集中存储应用程序的各种配置数据，如数据库连接字符串、API密钥、环境变量等，以便方便地进行配置管理和维护。使用配置中心组件可以大大简化应用程序的部署和维护工作，同时也有助于提高应用程序的可靠性和安全性。常见的配置中心组件包括Spring Cloud Config、Consul、Zookeeper等
三. 为什么要使用配置中心组件 这里我还是列举一些场景，来便于理解吧
我们在生产环境部署的时候，为了服务的可用性以及负载，通常一个服务会启动多个实例,要么在不同的机器 要么在相同机器不同端口…【例如 商品服务启动4个，订单服务启动4个，用户服务启动N个，文件上传服务启动X个等等…】
当服务启动的时候便会去加载自己的配置文件application.properties或者application.yml
一气呵成…这本身，是没有问题的。但是我们总会面临因业务更改导致配置文件需要新增/修改/删除属性…那么在这样的场景中，我们该如何面对呢？？
是选择更改配置文件后，从新打包部署？
还是将配置文件存放部署的服务机器某路径上，更改保存再重启服务？
两种方式对比的话，第二种方式可能效率更高一点。但是我们微服务通常又是使用容器化部署，如果保存在宿主机某一处的话，也是涉及到目录挂载问题的，且在服务器上，也不方便多个服务统一管理…
这时候，咱们统一的配置中心就横空出世啦！！！
四.使用配置中心组件的步骤 1.引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; 2.进入nacos编写配置 关于nacos的下载，在之前的博文中已经提及了nacos的使用
点击发布即是编写好了这个配置文件，那么再配置列表中便可以看到刚刚所写好的这个配置文件" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ee26051defaef4e3d9ba36c1a5c9f6d4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-07T19:17:50+08:00" />
<meta property="article:modified_time" content="2024-01-07T19:17:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringCloud系列篇：核心组件之配置中心组件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h2 id="%F0%9F%A5%B3%F0%9F%A5%B3Welcome%20Huihui's%20Code%20World%20!%20!%F0%9F%A5%B3%F0%9F%A5%B3" style="text-align:center;"><span style="color:#ffd900;">🥳🥳Welcome Huihui's Code World ! !🥳🥳</span></h2> 
 <p style="text-align:center;"><strong>接下来看看由辉辉所写的关于SpringCloud的相关操作吧</strong></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%A5%B3%F0%9F%A5%B3Welcome%20Huihui's%20Code%20World%20!%20!%F0%9F%A5%B3%F0%9F%A5%B3-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%B3%F0%9F%A5%B3Welcome%20Huihui'%20rel=">🥳🥳Welcome Huihui's Code World ! !🥳🥳</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%C2%A0%E4%B8%80.%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%80.%E5%89%8D%E8%A8%80" rel="nofollow"> 一.前言</a></p> 
<p id="%E4%BA%8C.%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">二.配置中心组件是什么</a></p> 
<p id="%E4%B8%89.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6" rel="nofollow">三. 为什么要使用配置中心组件</a></p> 
<p id="%E5%9B%9B.%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4%C2%A0" rel="nofollow">四.使用配置中心组件的步骤 </a></p> 
<p id="1.%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-toc" style="margin-left:40px;"><a href="#1.%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96" rel="nofollow">1.引入依赖</a></p> 
<p id="2.%E8%BF%9B%E5%85%A5nacos%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#2.%E8%BF%9B%E5%85%A5nacos%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE" rel="nofollow">2.进入nacos编写配置</a></p> 
<p id="3.%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0-toc" style="margin-left:40px;"><a href="#3.%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0" rel="nofollow">3.读取配置       </a></p> 
<p id="4.%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#4.%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE" rel="nofollow">4.不同环境下的配置</a></p> 
<hr id="hr-toc"> 
<h2>一.前言</h2> 
<blockquote> 
 <p>        <span style="color:#0d0016;">微服务意味着要<strong>将单体应用中的业务拆分成一个个子服务</strong>,每个服务的粒度相对较小,因此系统中会出现大量的服务。 </span></p> 
 <p><span style="color:#0d0016;">        由于每个服务都需要必要的配置信息才能运行,所以</span><span style="color:#fe2c24;"><strong>一套集中式的,动态的配置管理设施是必不可少的</strong></span><span style="color:#0d0016;">。 </span></p> 
 <p><span style="color:#0d0016;">        Spring Cloud 提供了 <strong>ConfigServer</strong>来解决这个问题. Spring Cloud Config 为微服务架构中的微服务提供集中化的外部配置支持,配置服务器为各个不同微服务应用的所有环境</span><span style="color:#fe2c24;"><strong>提供了一个中心化的外部配置</strong></span><span style="color:#0d0016;">。 SpringCloud Config 分为服务端和客户端两部分。</span></p> 
 <p><img alt="" height="393" src="https://images2.imgbox.com/e7/e3/iaNN6Fcp_o.png" width="1200"></p> 
 <p>      <span style="color:#0d0016;">  服务端也称为分布式配置中心,他是一个独立的微服务应用,<strong>用来连接配置服务器并为客户端提供获取配置信息,加密/解密信息等访问接口</strong>。</span></p> 
 <p><span style="color:#0d0016;">        客户端则是通过制定的配置中心来管理应用资源,以及与业务相关的配置内容,并在<strong>启动的时候从配置中心 获取和加载配置信息，</strong>配置服务器默认采用git来存储配置信息,这样就有助于对环境配置进行版本管理,并 且可以通过git客户端工具来方便的管理和访问配置内容</span></p> 
 <p><img alt="" height="710" src="https://images2.imgbox.com/bf/4d/Zoki4A7D_o.png" width="1124"></p> 
 <p><span style="color:#0d0016;">一个使用微服务架构的应用系统可能会包括成百上千个微服务,配置各部相同,<strong>需求各不相同</strong></span>：</p> 
 <ul><li><strong>不同环境不同配置</strong>：例如数据源在不同的环境（开发,测试,生产）是不同的,可以通过配置中心</li><li>运行期间可以动态调整：例如根据各个微服务的负载状况,动态调整数据源连接池大小或者熔断阀 值,并且调整时不停止微服务（配置修改后可以自动更新）</li></ul> 
</blockquote> 
<h2 id="%E4%BA%8C.%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88" style="background-color:transparent;">二.配置中心组件是什么</h2> 
<blockquote> 
 <p><span style="color:#0d0016;">        配置中心组件是一种用于管理应用程序配置信息的工具或服务。它通常可以<strong>集中存储应用程序的各种配置数据</strong>，如数据库连接字符串、API密钥、环境变量等，以便方便地进行配置管理和维护。使用配置中心组件<strong>可以大大简化应用程序的部署和维护工作，同时也有助于提高应用程序的可靠性和安全性</strong>。常见的配置中心组件包括Spring Cloud Config、Consul、Zookeeper等</span></p> 
</blockquote> 
<h2 id="%E4%B8%89.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6">三. 为什么要使用配置中心组件</h2> 
<blockquote> 
 <p><span style="color:#0d0016;">这里我还是列举一些场景，来便于理解吧</span></p> 
 <hr> 
 <p><span style="color:#0d0016;">        我们在生产环境部署的时候，为了服务的可用性以及负载，通常一个服务会启动多个实例,要么在不同的机器 要么在相同机器不同端口…【例如 商品服务启动4个，订单服务启动4个，用户服务启动N个，文件上传服务启动X个等等…】</span></p> 
 <p><span style="color:#0d0016;">        当服务启动的时候便会去<strong>加载自己的配置文件</strong>application.properties或者application.yml</span></p> 
 <p><span style="color:#0d0016;">一气呵成…这本身，是没有问题的。但是我们总会面临因业务更改导致配置文件<strong>需要新增/修改/删除属性</strong>…那么在这样的场景中，我们该如何面对呢？？</span></p> 
 <p><img alt="" height="946" src="https://images2.imgbox.com/91/a3/m7JB5z8p_o.png" width="975"></p> 
 <p><span style="color:#0d0016;">是选择更改配置文件后，从新打包部署？</span></p> 
 <p><span style="color:#0d0016;">还是将配置文件存放部署的服务机器某路径上，更改保存再重启服务？</span></p> 
 <p><span style="color:#0d0016;">两种方式对比的话，第二种方式可能效率更高一点。但是我们微服务通常又是使用容器化部署，如果保存在宿主机某一处的话，也是涉及到目录挂载问题的，且在服务器上，也不方便多个服务统一管理…</span></p> 
 <p><img alt="" height="1020" src="https://images2.imgbox.com/10/7b/DLrLAkl1_o.png" width="1033"></p> 
 <p>这时候，咱们统一的配置中心就横空出世啦！！！</p> 
</blockquote> 
<h2 id="%E5%9B%9B.%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4%C2%A0">四.使用配置中心组件的步骤 </h2> 
<blockquote> 
 <h3 id="1.%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96">1.引入依赖</h3> 
 <pre><code class="language-XML">&lt;dependency&gt;
&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
 <h3 id="2.%E8%BF%9B%E5%85%A5nacos%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE">2.进入nacos编写配置</h3> 
 <p>关于nacos的下载，在之前的博文中已经提及了<strong><a class="link-info" href="http://t.csdnimg.cn/gAhr8" rel="nofollow" title="nacos的使用">nacos的使用</a></strong></p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/b0/de/IaglULMP_o.png" width="1200"></p> 
 <p>点击发布即是编写好了这个配置文件，那么再配置列表中便可以看到刚刚所写好的这个配置文件</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/96/78/cK2FxAZe_o.png" width="1200"></p> 
 <h3 id="3.%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0"><span style="color:#0d0016;">3.读取配置       </span></h3> 
 <p><span style="color:#0d0016;"> 然后咱自己写的项目就要去读取这个配置文件，那么这个配置文件在项目中肯定要比我们自身项目中的配置文件先读取。所以这里需要再写一个配置文件用于读取nacos中所编写的文件</span></p> 
 <p><span style="color:#fe2c24;"><strong>bootstrap.yml：</strong></span></p> 
 <p><span style="color:#0d0016;">bootstrap.yml是SpringBoot默认支持properties和YAML两种格式的配置文件。bootstrap.yml（bootstrap.properties）用来<strong>程序引导时执行</strong>,应用于<strong>更加早期配置信息读取</strong>,可以用来配置application.yml中使用到参数等。application.yml（application.properties) 应用程序特有配置信息,可以用来配置后续各个模块中需使用 的公共参数等。</span></p> 
 <p><img alt="" height="839" src="https://images2.imgbox.com/1c/07/Efl0ujJk_o.png" width="775"></p> 
 <p><span style="color:#0d0016;">要使bootstrap.yml 先于application.yml 加载，就必须先导入一个依赖</span></p> 
 <pre><code class="language-XML">&lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
 <p>然后需要再项目中读取配置文件</p> 
 <p><span style="color:#fe2c24;"><strong>单个读取文件中的属性</strong></span></p> 
 <pre><code class="language-java">package com.provider.main;
import com.provider.main.config.EmailProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/myconfig")
@Slf4j
public class ConfigController {

    @Value("${email.user}")
    private String user;
    @Value("${email.code}")
    private String code;

 

    @RequestMapping("/test1")
    public String test1() {
        log.info("user{},code{}",user,code);
        return "SB";
    }

    @RequestMapping("/test2")
   

}
</code></pre> 
 <p>效果演示</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/07/31/UzcaQ151_o.png" width="1200"></p> 
 <p><span style="color:#fe2c24;"><strong>读取整个文件中的配置属性</strong></span></p> 
 <pre><code class="language-java">package com.provider.main.config;

import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * @author是辉辉啦
 * @create 2024-01-07-18:41
 */
@ConfigurationProperties(prefix = "email")
@Component
@Data
public class EmailProperties {
    private String user;
    private String code;

}
</code></pre> 
 <p>测试</p> 
 <pre><code class="language-java">package com.provider.main;
import com.provider.main.config.EmailProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/myconfig")
@Slf4j
public class ConfigController {
    @Autowired
    private EmailProperties emailProperties;

    @RequestMapping("/test2")
    public Object test2() {
        return emailProperties;
    }


}
</code></pre> 
 <p>效果演示</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/79/5a/wiPh2opn_o.png" width="1200"></p> 
 <p>以上两种方式都可以读取到配置文件的属性值，不过整个的读取效率会更加高</p> 
 <h3 id="4.%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE">4.不同环境下的配置</h3> 
 <p>我们可以在整个命名空间中去增加多个环境的空间，其中去存放不同环境中所需的配置文件</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/d2/ef/6orL0n9H_o.png" width="1200"></p> 
 <p>我们只需要在配置文件中加上这一个配置，就能够指定对应的空间了</p> 
 <pre><code class="language-java">namespace: 1e189198-5765-4b5d-acdd-71e8baa387c0</code></pre> 
 <p>其中填的是对应空间的id</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/b8/ed/5mK175fs_o.png" width="1200"></p> 
 <p>我们在项目完成了，打包的时候是不需要将这个配置给写上的，因为这样子的话，我们就不好更改空间了，我们直接不写，这样运行这个打好的jar包时，可以使用命令的方式指定对应的空间</p> 
 <p>在最后，我也附上整个yml文件的配置</p> 
 <pre><code class="language-java">server:
  port: 8082
spring:
  application:
    name: provider
  cloud:
    nacos:
        server-addr: localhost:8848
        config:
          server-addr: ${spring.cloud.nacos.server-addr}
          prefix: ${spring.application.name}
          file-extension: yaml
          group: DEFAULT_GROUP
          # 共享配置集数组
          shared-configs:
            - data-id: redis.yaml
            # 使用的 Nacos 配置分组，默认为 DEFAULT_GROUP
              group: DEFAULT_GROUP
            # 是否自动刷新配置，默认为 false
              refresh: true
          #dev环境 --开发
          namespace: 1e189198-5765-4b5d-acdd-71e8baa387c0

</code></pre> 
 <p></p> 
</blockquote> 
<p style="text-align:center;"><span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;">好啦，今天的分享就到这了，希望能够帮到你呢！😊😊</span></strong><span style="background-color:#fefcd8;">  </span></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74cf1e270f44c9d5dc306fbe90053162/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Flutter 开发实战】Dart 基础篇：从了解背景开始</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4634dab9f1838f40a507168e716a654e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python：sqlalchemy报错DetachedInstanceError</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>