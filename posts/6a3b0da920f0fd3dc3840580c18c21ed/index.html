<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java Excel的数据导入导出 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java Excel的数据导入导出" />
<meta property="og:description" content="EasyExcel简介 easyexcel 是阿里巴巴开源的一款excel 解析工具，底层逻辑也是基于apache poi进行二次开发的。不同的是，再读写数据的时候，采用 sax 模式一行一行解析，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）在并发量很大的情况下，依然能稳定运行！easyexcel支持采用注解方式进行导出、导入！
引入依赖 &lt;!-- EasyExcel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--csv文件操作--&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.javacsv&lt;/groupId&gt; &lt;artifactId&gt;javacsv&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; AnalysisEventListener读取监听 对象命名时严格遵守驼峰命名法，如果忽略可能会导致读取数据失败。 导入数据时，程序解析和读取数据用，通用读取监听类！
import com.baomidou.mybatisplus.toolkit.ReflectionKit; /** * excel通用读取监听类 */ public class ExcelListener&lt;T&gt; extends AnalysisEventListener&lt;T&gt; { /** * 自定义用于暂时存储data 可以通过实例获取该值 */ private final List&lt;T&gt; list = new ArrayList&lt;&gt;(); /** * 这个每一条数据解析都会来调用 * * @param data * @param context */ @Override public void invoke(T data, AnalysisContext context) { // 如果一行Excel数据均为空值，则不装载该行数据 if (isLineNullValue(data)) { return; } if (context." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6a3b0da920f0fd3dc3840580c18c21ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-17T16:10:44+08:00" />
<meta property="article:modified_time" content="2023-11-17T16:10:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java Excel的数据导入导出</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>EasyExcel简介</h3> 
<p>easyexcel 是阿里巴巴开源的一款excel 解析工具，底层逻辑也是基于apache poi进行二次开发的。不同的是，再读写数据的时候，采用 sax 模式一行一行解析，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）在并发量很大的情况下，依然能稳定运行！easyexcel支持采用注解方式进行导出、导入！</p> 
<h3>引入依赖</h3> 
<pre><code>&lt;!-- EasyExcel --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;
    &lt;version&gt;2.2.7&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--csv文件操作--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.sourceforge.javacsv&lt;/groupId&gt;
    &lt;artifactId&gt;javacsv&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<h3 id="articleContentId">AnalysisEventListener读取监听</h3> 
<p><strong>对象</strong>命名时严格遵守<span style="color:#fe2c24;">驼峰命名法</span>，如果忽略可能会导致读取数据失败。 </p> 
<p><img alt="" height="198" src="https://images2.imgbox.com/16/36/XTMEmErZ_o.png" width="964"></p> 
<p id="ueaea3be0">导入数据时，程序解析和读取数据用，通用读取监听类！</p> 
<pre><code>import com.baomidou.mybatisplus.toolkit.ReflectionKit;

/**
 * excel通用读取监听类
 */
public class ExcelListener&lt;T&gt; extends AnalysisEventListener&lt;T&gt; {
  /**
   * 自定义用于暂时存储data 可以通过实例获取该值
   */
  private final List&lt;T&gt; list = new ArrayList&lt;&gt;();
  
  /**
   * 这个每一条数据解析都会来调用
   *
   * @param data
   * @param context
   */
  @Override
  public void invoke(T data, AnalysisContext context) {
    // 如果一行Excel数据均为空值，则不装载该行数据
    if (isLineNullValue(data)) {
      return;
    }
    if (context.readRowHolder().getRowIndex() &gt; 2) {
      System.out.println("解析到一条数据:{}", JSON.toJSONString(data));
      list.add(data);
    }
  }

  /**
   * 所有数据解析完成了 都会来调用
   *
   * @param context
   */
  @Override
  public void doAfterAllAnalysed(AnalysisContext context) {
    String sheetName = context.readWorkbookHolder().getExcelType().equals(ExcelTypeEnum.CSV) ? "CSV" : context.readSheetHolder().getSheetName();
    System.out.println(sheetName + " 所有数据解析完成,数据条数：" + list.size());
  }

  /**
   * 返回所有记录
   *
   * @return
   */
  public List&lt;T&gt; getRows() {
    return list;
  }

  /**
   * 判断整行单元格数据是否均为空
   */
  private boolean isLineNullValue(Object data) {
    if (data == null) {
      return true;
    }
    List&lt;Field&gt; fields = Arrays.stream(data.getClass().getDeclaredFields())
        .filter(f -&gt; f.isAnnotationPresent(ExcelProperty.class))
        .collect(Collectors.toList());
    List&lt;Boolean&gt; lineNullList = new ArrayList&lt;&gt;(fields.size());
    for (Field key : fields){
      if (ReflectionKit.getMethodValue(data, key.getName()) == null) {
        lineNullList.add(Boolean.TRUE);
      } else {
        lineNullList.add(Boolean.FALSE);
      }
    }
    return lineNullList.stream().allMatch(Boolean.TRUE::equals);
  }
}</code></pre> 
<p>通用非model类型监听</p> 
<pre><code>import com.alibaba.excel.context.AnalysisContext;
import com.alibaba.excel.event.AnalysisEventListener;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class NoModelDataListener extends AnalysisEventListener&lt;Map&lt;Integer, String&gt;&gt; {

  //Excel数据缓存结构
  private List&lt;Map&lt;String, String&gt;&gt; list;

  //Excel表头（列名）数据缓存结构
  private Map&lt;Integer, String&gt; headTitleMap = new HashMap&lt;&gt;();

  @Override
  public void invoke(Map&lt;Integer, String&gt; data, AnalysisContext context) {
    //excel的行号
    Integer rowIndex = context.readRowHolder().getRowIndex();
    log.info("行号：{}，Excel数据：{}", rowIndex, getRowContentWithHeaderKey(data));
    list.add(getRowContentWithHeaderKey(data));
  }

  /**
   * 解析表头数据,解析第一行触发
   **/
  @Override
  public void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) {
    headTitleMap = new HashMap&lt;&gt;();
    for (Integer i : headMap.keySet()) {
      String value = "";
      if (headMap.get(i) != null) {
        value = headMap.get(i).trim();
      }
      headTitleMap.put(i, value);
    }
  }

  @Override
  public void doAfterAllAnalysed(AnalysisContext analysisContext) {
    log.info("数据解析完成！");
  }

  /**
   * 按照表头作为map的key,提供Excel行数据。兼容key重复。行乱序
   *
   * @param data
   * @return
   */
  public Map&lt;String, String&gt; getRowContentWithHeaderKey(Map&lt;Integer, String&gt; data) {
    Map&lt;String, String&gt; dataWithHeader = new IdentityHashMap&lt;&gt;();
    data.forEach((index, value) -&gt; {
      dataWithHeader.put(headTitleMap.get(index), value);
    });
    return dataWithHeader;
  }
}</code></pre> 
<h4>单sheet海量excel的数据读取</h4> 
<p>根据设置每批次数据量的大小，当list里面数据量达到设置每批次最大数据量时，进行入库操作，海量数据的话，<span style="color:#fe2c24;">通常每批次1000的速度最快</span>，可以避免内存溢出</p> 
<pre><code>public void invoke(CallExcelVO data, AnalysisContext context) {
	list.add(data);
	// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM
	if (list.size() &gt;= BATCH_COUNT) {
		saveData();
		//存储完成清理 list
		list.clear();
	}
}</code></pre> 
<h4> 读取Excel内容</h4> 
<pre><code>ExcelListener listener = new ExcelListener();
String fileName = "demo.xlsx";
EasyExcel.read(fileName, DemoData.class, listener).sheet().autoTrim(true).doRead();
List&lt;DemoData&gt; dataList = listener.getRows();

//EasyExcel3.3 导入csv
ExcelListener listener = new ExcelListener();
ExcelReader excelReader = EasyExcel.read(inputStream, listener).build();
String code = CsvReader.getFileCharset(fileName);
System.out.println("文件编码为:" + code);
//excelReader = EasyExcel.read(inputStream, listener).excelType(ExcelTypeEnum.CSV).charset(Charset.forName(code)).build();
inputStream.close();


Integer sheetSize = 1;//csv
if (excelReader != null) {
    List&lt;ReadSheet&gt; readSheets = excelReader.excelExecutor().sheetList();
    sheetSize = readSheets.size();
}
for (int sheetNo = 0; sheetNo &lt; sheetSize; sheetNo++) {
   ExcelUtil.readExcel(fileName, sheetNo);
}</code></pre> 
<h4>接收外部参数，需添加构造方法</h4> 
<pre><code>public ExcelListener(String fileName) {
  this.fileName = fileName;
}

ExcelListener parseListener = new ExcelListener("a.xls");</code></pre> 
<h4>读类</h4> 
<pre><code>import com.alibaba.excel.EasyExcel;
import com.alibaba.excel.ExcelReader;
import com.alibaba.excel.read.metadata.ReadSheet;
import java.io.InputStream;
import java.util.List;

/**
 * 定制化Excel读写工具类
 */
public class ExcelUtil {

  /**
   * 单sheet版本Excel读取 从Excel中读取文件，读取的文件是一个DTO类
   *
   * @param inputStream 文件流
   * @param clazz       行数据类型
   * @param sheetNo     sheet编号 从0开始
   */
  public static &lt;T&gt; List&lt;T&gt; readExcelOneSheet(InputStream inputStream, final Class&lt;?&gt; clazz, Integer sheetNo) {
    // 1.创建监听类
    ExcelListener&lt;T&gt; listener = new ExcelListener&lt;&gt;();
    // 2.构建工作簿对象的输入流
    ExcelReader excelReader = EasyExcel.read(inputStream, clazz, listener).build();
    // 3.构建工作表对象的输入流，默认是第一张工作表
    ReadSheet readSheet = EasyExcel.readSheet(sheetNo).build();
    // 4.读取信息，每读取一行都会调用监听类的 invoke 方法
    excelReader.read(readSheet);
    // 5.关闭流，如果不关闭，读的时候会创建临时文件，到时磁盘会崩的
    excelReader.finish();
    return listener.getRows();
  }
}</code></pre> 
<h3>EasyExcel导入invoke函数不执行，不报错</h3> 
<ul><li>重写hasNext方法时写成返回false了</li><li>使用easyexcel时默认是第一张sheet页，不是第一张sheet</li><li>将不使用的字段使用@ExcelIgnore标注 </li><li>EasyExcel和Lombok结合使用导致的问题,去掉@Accessors(chain = true)</li></ul> 
<h4>EasyExcel 相关参数</h4> 
<ul><li>readListener 监听器，在读取数据的过程中会不断的调用监听器。</li><li>converter 转换器，默认加载了很多转换器。也可以自定义，如果使用的是 registerConverter，那么该转换器是全局的，如果要对单个字段生效，可以在 ExcelProperty 注解的 converter 指定转换器。</li><li>headRowNumber <span style="color:#fe2c24;">需要读的表格有几行头数据。默认有一行头</span>，也就是认为第二行开始起为数据。</li><li>head 与 clazz 二选一。读取文件头对应的列表，会根据列表匹配数据，建议使用 class。</li><li>autoTrim <span style="color:#fe2c24;">字符串、表头等数据自动 trim</span>。</li><li>sheetNo 需要读取 Sheet 的编码，建议使用这个来指定读取哪个 Sheet。</li><li>sheetName 根据名字去匹配 Sheet,excel 2003 不支持根据名字去匹配。 </li></ul> 
<p></p> 
<h3><img alt="" height="276" src="https://images2.imgbox.com/db/ca/m6Clp9Jo_o.png" width="453"></h3> 
<p></p> 
<h3>Excel工具类</h3> 
<p>根据EasyExcel Model 导出工具类,<span style="color:#fe2c24;">CSV支持easyexcel获取ExcelProperty</span></p> 
<h4>ExportUtil</h4> 
<pre><code class="language-java">package net.demo.excel.common.util;

import com.alibaba.excel.ExcelWriter;
import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.excel.metadata.BaseRowModel;
import com.alibaba.excel.metadata.Sheet;
import com.alibaba.excel.support.ExcelTypeEnum;
import com.csvreader.CsvWriter;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.lang.reflect.Field;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

/**
 * @desc: 根据EasyExcel Model 导出工具类
 * @Author: Swift
 * @Date: 2019-08-26 15:18

*/
public class ExportUtil {

    /**
     * 获取ExcelProperty Value
     * @return
     */
    public static &lt;T extends BaseRowModel&gt; String[] getFieldNames(Class&lt;T&gt; tClass) {
        Field[] fields = tClass.getDeclaredFields();
        List&lt;String&gt; headers = new ArrayList&lt;&gt;();
        for (Field field: fields) {
            ExcelProperty property = field.getAnnotation(ExcelProperty.class);
            if (property != null) {
                String[] s = property.value();
                if (s.length &gt; 0) {
                    headers.add(s[0]);
                }
            }
        }
        String[] strings = new String[headers.size()];
        headers.toArray(strings);
        return strings;
    }

    /**
     * 获取filedName
     * @param vo
     * @param &lt;T&gt;
     * @return
     */
    public static &lt;T extends BaseRowModel&gt;  String[] getFields(T vo) {
        Field[] fields = vo.getClass().getDeclaredFields();
        List&lt;String&gt; columns = new ArrayList&lt;&gt;();
        for (Field field: fields) {
            ExcelProperty property = field.getAnnotation(ExcelProperty.class);
            if (property != null) {
                try {
                    field.setAccessible(true);
                    columns.add(field.get(vo)==null ? "" : field.get(vo).toString());
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    throw new RuntimeException("写入内容到csv失败!");
                }
            }
        }

        String[] strings = new String[columns.size()];
        columns.toArray(strings);
        return strings;
    }

    public static &lt;T extends BaseRowModel&gt; void export(String type, List&lt;T&gt; vos, HttpServletResponse response, Class&lt;T&gt; t
    ) throws IOException {

        Boolean isCsv = "csv".equals(type);
        String fileName = "data" + CalendarUtils.getCurrentTime();
        response.setCharacterEncoding("utf-8");
        if (isCsv) {
            fileName += ".csv";
            response.setContentType("text/csv;charset=UTF-8");
        } else {
            fileName += ".xlsx";
            response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        }
        response.setHeader("Content-disposition", "attachment;filename=" + fileName);

        ServletOutputStream outputStream = response.getOutputStream();

        if (isCsv) {
            CsvWriter csvWriter = new CsvWriter(outputStream, ',', Charset.forName("GBK"));
            csvWriter.writeRecord(getFieldNames(t));
            for (T vo : vos) {
                String[] fields = getFields(vo);
                csvWriter.writeRecord(fields);
            }
            csvWriter.close();
        } else {
            ExcelWriter excelWriter = new ExcelWriter(outputStream, ExcelTypeEnum.XLSX, true);

            Sheet sheet = new Sheet(1, 0, t);
            excelWriter.write(vos, sheet);
            sheet.setAutoWidth(true);
            excelWriter.finish();
        }
        outputStream.flush();
    }

    public static &lt;T extends BaseRowModel&gt; void export(String type,String fileName, List&lt;T&gt; vos, HttpServletResponse response, Class&lt;T&gt; t
    ) throws IOException {

        Boolean isCsv = "csv".equals(type);
//        String fileName = "data" + CalendarUtils.getCurrentTime();
        response.setContentType("multipart/form-data");
        response.setCharacterEncoding("utf-8");
        if (isCsv) {
            fileName += ".csv";
        } else {
            fileName += ".xlsx";
        }
        response.setHeader("Content-disposition", "attachment;filename=" + fileName);

        ServletOutputStream outputStream = response.getOutputStream();

        if (isCsv) {
            CsvWriter csvWriter = new CsvWriter(outputStream, ',', Charset.forName("GBK"));
            csvWriter.writeRecord(getFieldNames(t));
            for (T vo : vos) {
                String[] fields = getFields(vo);
                csvWriter.writeRecord(fields);
            }
            csvWriter.close();
        } else {
            ExcelWriter excelWriter = new ExcelWriter(outputStream, ExcelTypeEnum.XLSX, true);

            Sheet sheet = new Sheet(1, 0, t);
            excelWriter.write(vos, sheet);
            sheet.setAutoWidth(true);
            excelWriter.finish();
        }
        outputStream.flush();
    }

    /**
     * 根据Excel模板，批量导入数据
     * @param file  导入的Excel
     * @param clazz 解析的类型
     * @return  解析完成的数据
     */
    public static List&lt;?&gt; importExcel(MultipartFile file, Class&lt;?&gt; clazz){
        if (file == null || file.isEmpty()){
            throw new RuntimeException("没有文件或者文件内容为空！");
        }
        List&lt;Object&gt; dataList = null;
        BufferedInputStream ipt = null;
        try {
            InputStream is = file.getInputStream();
            // 用缓冲流对数据流进行包装
            ipt = new BufferedInputStream(is);
            // 数据解析监听器
            ExcelListener&lt;Object&gt; listener = new ExcelListener&lt;&gt;();
            // 读取数据
            EasyExcel.read(ipt, clazz,listener).sheet().doRead();
            // 获取去读完成之后的数据
            dataList = listener.getDataList();
        } catch (Exception e){
            log.error(String.valueOf(e));
            throw new RuntimeException("数据导入失败！" + e);
        }
        return dataList;
    }
}</code></pre> 
<h4>WriterFactory</h4> 
<p>导出工厂实现了xlsx与csv 两种方式</p> 
<pre><code>package net.demo.excel.common.export;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import javax.servlet.http.HttpServletResponse;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import net.demo.excel.common.constants.Constants;
import net.demo.excel.common.constants.ExportTypeEnum;
import net.demo.excel.common.export.csv.CsvExport;
import net.demo.excel.common.export.excel.ExcelExport;


/**
 * 导出工厂
 */
@Data
@Slf4j
public class WriterFactory {

  /**
   * 返回文件流方式
   *
   * @param key
   * @param fileName
   * @param response
   * @return
   */
  public static ExportWriter getExportWriter(String key, String fileName,
      HttpServletResponse response) {
    ExportWriter exportWriter = null;
    try {
      OutputStream os = response.getOutputStream();
      ExportTypeEnum exportTypeEnum = ExportTypeEnum.findByType(key);
      fileName = fileName + exportTypeEnum.getSuffix();
      exportWriter = generateExportWriter(exportTypeEnum, os);
      response.setContentType("application/force-download");
      // 设置文件名
      response.addHeader("Content-Disposition",
          "attachment;filename=" + URLEncoder.encode(fileName, "utf-8"));
    } catch (UnsupportedEncodingException e) {
      log.error("UnsupportedEncoding:", e);
    } catch (IOException e) {
      log.error("IOException:", e);
    }
    return exportWriter;
  }

  /**
   * 输出到文件方式
   *
   * @param key
   * @param fileName
   * @return
   */
  public static ExportWriter getExportWriter(String key, String fileName)
      throws FileNotFoundException {
    ExportTypeEnum exportTypeEnum = ExportTypeEnum.findByType(key);
    String filePath =
        Constants.EXPORT_TMP_DIR + File.separator + fileName + exportTypeEnum.getSuffix();
    File file = new File(filePath);
    OutputStream os = new FileOutputStream(file);
    ExportWriter exportWriter = generateExportWriter(exportTypeEnum, os);
    exportWriter.setFilePath(filePath);
    return exportWriter;
  }

  private static ExportWriter generateExportWriter(ExportTypeEnum exportTypeEnum, OutputStream os) {
    ExportWriter exportWriter = null;
    switch (exportTypeEnum) {
      case EXCEL:
        exportWriter = new ExcelExport(os);
        break;
      case CSV:
        exportWriter = new CsvExport(os);
        break;
      default:
    }
    return exportWriter;
  }
}</code></pre> 
<h4>ExportModel抽象类</h4> 
<pre><code>package net.demo.excel.common.export.model;

import com.alibaba.excel.ExcelWriter;
import com.alibaba.excel.metadata.Sheet;
import com.csvreader.CsvWriter;

/**
 * 抽象实体
 */
public abstract class ExportModel {

  public abstract ExcelWriter getExcelWriter();

  public abstract Sheet getSheet();

  public abstract CsvWriter getCsvWriter();
}
</code></pre> 
<h4>CsvModel 实体类 </h4> 
<pre><code>package net.demo.excel.common.export.csv.model;

import com.alibaba.excel.ExcelWriter;
import com.alibaba.excel.metadata.Sheet;
import com.csvreader.CsvWriter;
import lombok.Data;
import net.demo.excel.common.export.model.ExportModel;

/**
 * csv相关实体
 */
@Data
public class CsvModel extends ExportModel {

  private CsvWriter csvWriter;

  @Override
  public ExcelWriter getExcelWriter() {
    return null;
  }

  @Override
  public Sheet getSheet() {
    return null;
  }

  @Override
  public CsvWriter getCsvWriter() {
    return csvWriter;
  }

  public CsvModel(CsvWriter csvWriter) {
    this.csvWriter = csvWriter;
  }
}</code></pre> 
<h4>ExcelModel 实体类 </h4> 
<pre><code>package net.demo.excel.common.export.excel.model;

import com.alibaba.excel.ExcelWriter;
import com.alibaba.excel.metadata.Sheet;
import com.csvreader.CsvWriter;
import lombok.Data;
import net.demo.excel.common.export.model.ExportModel;

/**
 * excel,csv相关实体
 */
@Data
public class ExcelModel extends ExportModel {

  private ExcelWriter excelWriter;

  private Sheet sheet;

  @Override
  public ExcelWriter getExcelWriter() {
    return excelWriter;
  }

  @Override
  public Sheet getSheet() {
    return sheet;
  }

  @Override
  public CsvWriter getCsvWriter() {
    return null;
  }

  public ExcelModel(ExcelWriter excelWriter, Sheet sheet) {
    this.excelWriter = excelWriter;
    this.sheet = sheet;
  }
}</code></pre> 
<h4>ExportWriter接口</h4> 
<pre><code>package net.demo.excel.common.export;

import com.alibaba.excel.metadata.BaseRowModel;
import com.alibaba.fastjson.JSONArray;
import java.util.List;
import net.demo.excel.common.bean.Column;

/**
 * 导出接口
 */
public interface ExportWriter {

  public static final int EXPORT_PAGE_SIZE = 5000;

  /**
   * 写入表头 结构为{"code":"字段名","title":"显示名"}
   *
   * @param columnList
   */
  public void writeTitle(List&lt;Column&gt; columnList);

  public &lt;T extends BaseRowModel&gt; void writeTitle(Class&lt;T&gt; t);

  /**
   * 添加内容 data的Map结构为{"字段名":"字段值"}
   *
   * @param dataList
   * @param columnList
   */
  public void appendContent(JSONArray dataList, List&lt;Column&gt; columnList);

  public &lt;T extends BaseRowModel&gt; void appendContent(List&lt;T&gt; vos, Class&lt;T&gt; t);

  /**
   * 关闭文件流
   */
  public void close();

  public String getFilePath();

  public void setFilePath(String filePath);

}</code></pre> 
<h4>Column</h4> 
<pre><code>package net.demo.excel.common.bean;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class Column {

  /**
   * 英文名称
   */
  private String code;

  /**
   * 中文名称
   */
  private String title;
}</code></pre> 
<h4>ExcelExport实现类</h4> 
<p>model.getSheet() 的<span style="color:#fe2c24;">sheet的初始化在ExcelExport</span>中完成。new sheet(1, 0, ExcelProperty)第3个参数com.alibaba.excel.annotation.ExcelProperty通过注解来生成表头。</p> 
<pre><code>package net.demo.excel.common.export.excel;

import com.alibaba.excel.ExcelWriter;
import com.alibaba.excel.metadata.BaseRowModel;
import com.alibaba.excel.metadata.Sheet;
import com.alibaba.excel.support.ExcelTypeEnum;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import net.demo.excel.common.bean.Column;
import net.demo.excel.common.export.ExportWriter;
import net.demo.excel.common.export.excel.model.ExcelModel;
import net.demo.excel.common.export.model.ExportModel;
import net.demo.excel.common.util.ExportUtil;

import java.io.*;
import java.util.ArrayList;
import java.util.List;

/**
 * excel具体实现
 */
@Slf4j
@Data
public class ExcelExport implements ExportWriter {

	private ExportModel model;

	private OutputStream os;

	private String filePath;

	/**
	 * 初始化
	 *
	 * @param os
	 */
	public ExcelExport(OutputStream os) {
		ExcelWriter writer = new ExcelWriter(os, ExcelTypeEnum.XLSX);
		Sheet sheet = new Sheet(1, 0);
		sheet.setSheetName("1");
		this.model = new ExcelModel(writer, sheet);
		this.os = os;
	}

	/**
	 * 写标题
	 *
	 * @param columnList
	 */
	@Override
	public void writeTitle(List&lt;Column&gt; columnList) {
		List&lt;List&lt;String&gt;&gt; dataList = new ArrayList&lt;List&lt;String&gt;&gt;();
		//组装标题行
		for (int i = 0; i &lt; columnList.size(); i++) {
			List&lt;String&gt; titleList = new ArrayList&lt;String&gt;();
			Column column = columnList.get(i);
			String title = column.getTitle();
			titleList.add(title);
			dataList.add(titleList);
		}
		model.getSheet().setHead(dataList);
	}

	/**
	 * 写标题
	 */
	@Override
	public &lt;T extends BaseRowModel&gt; void writeTitle(Class&lt;T&gt; t) {
		List&lt;List&lt;String&gt;&gt; dataList = new ArrayList&lt;List&lt;String&gt;&gt;();
		String[] columns = ExportUtil.getFieldNames(t);
		//组装标题行
		for (int i = 0; i &lt; columns.length; i++) {
			List&lt;String&gt; titleList = new ArrayList&lt;String&gt;();
			String title = columns[i];
			titleList.add(title);
			dataList.add(titleList);
		}
		model.getSheet().setHead(dataList);
	}

	/**
	 * 内容追加
	 *
	 * @param dataList
	 * @param columnList
	 */
	@Override
	public void appendContent(JSONArray dataList, List&lt;Column&gt; columnList) {
		List&lt;List&lt;String&gt;&gt; dataArray = new ArrayList&lt;List&lt;String&gt;&gt;();
		//组装数据行
		for (Object obj : dataList) {
			JSONObject json = (JSONObject) JSONObject.toJSON(obj);
			List&lt;String&gt; rowList = new ArrayList&lt;&gt;();
			for (int j = 0; j &lt; columnList.size(); j++) {
				Column columnMap = columnList.get(j);
				String code = columnMap.getCode();
				Object value = json.get(code);
				String valueStr = value == null ? "" : value.toString();
				rowList.add(valueStr);
			}
			dataArray.add(rowList);
		}
		model.getExcelWriter().write1(dataArray, model.getSheet());
	}

	/**
	 * 追加内容
	 *
	 * @param vos
	 * @param t
	 * @param &lt;T&gt;
	 */
	@Override
	public &lt;T extends BaseRowModel&gt; void appendContent(List&lt;T&gt; vos, Class&lt;T&gt; t) {
        //--start 修复sheet行数据为null时，列对齐错位--
        List&lt;List&lt;Object&gt;&gt; dataArray = new ArrayList&lt;List&lt;Object&gt;&gt;();
        for (T vo : vos) {
          Field[] fields = vo.getClass().getDeclaredFields();
          List&lt;Object&gt; rowList = new ArrayList&lt;&gt;();
          for (Field field : fields) {
            ExcelProperty property = field.getAnnotation(ExcelProperty.class);
            if (property != null) {
              try {
                field.setAccessible(true);
                Object fieldValue = field.get(vo) == null ? "" : field.get(vo);
                rowList.add(fieldValue);
              } catch (IllegalAccessException e) {
                e.printStackTrace();
                throw new RuntimeException("写入内容到xlsx失败!");
              }
            }
          }
          dataArray.add(rowList);
        }
		model.getExcelWriter().write(dataArray, model.getSheet());
		//--end 修复api行数据为null时，列对齐错位--
    
		model.getSheet().setClazz(t); //注解来生成表头
		//model.getExcelWriter().write(vos, model.getSheet());
		model.getSheet().setAutoWidth(true);
	}

	/**
	 * 关闭流
	 */
	@Override
	public void close() {
		ExcelWriter writer = model.getExcelWriter();
		try {
			if (writer != null) {
				writer.finish();
			}
			os.close();
		} catch (IOException e) {
			log.error("os close error", e);
		}
	}

	@Override
	public String getFilePath() {
		return filePath;
	}

	@Override
	public void setFilePath(String filePath) {
		this.filePath = filePath;
	}
}</code></pre> 
<h4 style="background-color:transparent;">CsvReader文件读取</h4> 
<pre><code class="language-java">import com.alibaba.excel.util.FileUtils;
import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringUtils;

/**
 * CSV读取工具类
 */
public class CsvReader {

  /**
   * 列分隔符
   */
  private static final String WORDS_SPLIT = ",";

  /**
   * 读取200万条数据
   */
  private static final int READ_LINES = Integer.MAX_VALUE;

  /**
   * csv、txt 文件处理
   *
   * @param filePath 文件路径
   * @return
   */
  public static Map&lt;Integer, Map&lt;Integer, String&gt;&gt; getTxtCsvFileContent(String filePath) {
    Map&lt;Integer, Map&lt;Integer, String&gt;&gt; map = new HashMap&lt;&gt;();
    try {
      Map&lt;Integer, String&gt; rowContent = getTxtCsvLineContentMap(
          FileUtils.openInputStream(new File(filePath)), filePath, READ_LINES);
      if (rowContent != null) {
        rowContent.forEach((k, v) -&gt; {
          Map&lt;Integer, String&gt; tmp = new LinkedHashMap&lt;&gt;();
          String[] row = v.split(WORDS_SPLIT);
          for (int i = 0; i &lt; row.length; i++) {
            tmp.put(i, row[i]);
          }
          map.put(k, tmp);
        });
      }
    } catch (IOException e) {
      e.printStackTrace();
    }

    return map;
  }

  /**
   * 兼容Excel多sheet格式
   *
   * @param filePath
   * @return
   */
  public static List&lt;Map&lt;Integer, Map&lt;Integer, String&gt;&gt;&gt; getExcelStyleData(String filePath) {
    List sheet = new ArrayList&lt;&gt;();
    Map&lt;Integer, Map&lt;Integer, String&gt;&gt; sheetData = getTxtCsvFileContent(filePath);
    sheet.add(0, sheetData);
    return sheet;
  }

  /**
   * csv、txt 文件第一行表头
   *
   * @param filePath 文件路径
   * @param charset
   * @return
   */
  public static Map&lt;Integer, String&gt; getTxtCsvFileHeader(String filePath, String charset) {
    Map&lt;Integer, String&gt; headerMap = new LinkedHashMap&lt;&gt;();

    try {
      if (StringUtils.isBlank(charset)) {
        charset = getFileCharset(filePath);
        if (StringUtils.isBlank(charset)) {
          charset = StandardCharsets.UTF_8.name();
        }
      }
      InputStream is = new BufferedInputStream(FileUtils.openInputStream(new File(filePath)));
      // 解析平面文件
      BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset));
      // 获取第一行的数据当做字段
      String headContent = reader.readLine();
      if (StringUtils.isNotBlank(headContent)) {
        if (isMessyCode(headContent, Charset.forName(charset)) &amp;&amp; !charset.equals(StandardCharsets.UTF_8.name())) {
          System.out.println("文件编码：" + charset + "，内容存在乱码，自动修正编码为utf8");
          is.close();
          reader.close();
          return getTxtCsvFileHeader(filePath, StandardCharsets.UTF_8.name());
        }
        String[] row = headContent.split(WORDS_SPLIT);
        for (int i = 0; i &lt; row.length; i++) {
          headerMap.put(i, row[i]);
        }
      }
      is.close();
      reader.close();
    } catch (IOException e) {
      e.printStackTrace();
    }

    return headerMap;
  }

  /**
   * 获取 txt/csv 文件前 size 行数据
   *
   * @param inputStream
   * @param filePath
   * @param size
   * @return
   * @throws IOException
   */
  public static Map&lt;Integer, String&gt; getTxtCsvLineContentMap(InputStream inputStream,
      String filePath, int size) throws IOException {
    Map&lt;Integer, String&gt; map = new LinkedHashMap&lt;&gt;();
    String charset = getFileCharset(filePath);
    if (StringUtils.isBlank(charset)) {
      charset = StandardCharsets.UTF_8.name();
    }
    InputStream is = new BufferedInputStream(inputStream);
    // 解析平面文件
    BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset));
    // 获取第一行的数据当做字段
    String line = reader.readLine();
    if (StringUtils.isBlank(line)) {
      is.close();
      reader.close();
      return null;
    }
    int fileLineNum = getFileLineNum(filePath);
    if (fileLineNum &lt; size) {
      size = fileLineNum;
    }
    for (int i = 1; i &lt;= size; i++) {
      String nowLineContent = reader.readLine();
      Integer lineIndex = i + 1;
      if (StringUtils.isNotBlank(nowLineContent)) {
        System.out.println("读取csv第" + lineIndex + "/" + size + "内容：" + nowLineContent);
        map.put(lineIndex, nowLineContent);
      }
    }
    is.close();
    reader.close();
    return map;
  }

  /**
   * 高效获取大文件的行数:3千万行只要1秒钟
   *
   * @param filePath
   * @return int
   */
  public static int getFileLineNum(String filePath) {
    int fileLines = 0;
    try (LineNumberReader lineNumberReader = new LineNumberReader(new FileReader(filePath))) {
      lineNumberReader.skip(Long.MAX_VALUE);
      int lineNumber = lineNumberReader.getLineNumber();
      //实际上是读取换行符数量 , 所以需要+1
      fileLines = lineNumber + 1;
    } catch (IOException e) {
      e.printStackTrace();
    }
    return fileLines;
  }

  /**
   * 根据关键字获取表头
   *
   * @param filePath
   * @param headerKey
   * @return
   */
  public static Map&lt;Integer, String&gt; getTxtCsvFileHeaderContainsKeywords(String filePath,
      String headerKey) {
    Map&lt;Integer, String&gt; headerMap = new LinkedHashMap&lt;&gt;();
    try {
      InputStream inputStream = new FileInputStream(filePath);
      Map&lt;Integer, String&gt; tmp = CsvReader.getTxtCsvLineContentMap(inputStream, filePath, 50);
      for (Map.Entry&lt;Integer, String&gt; entry : tmp.entrySet()) {
        String[] row = entry.getValue().split(CsvReader.WORDS_SPLIT);
        for (int i = 0; i &lt; row.length; i++) {
          if (row[0].equals(headerKey)) {
            headerMap.put(i, row[i]);
          }
        }
        if (row[0].equals(headerKey)) {
          break;
        }
      }
      inputStream.close();
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    } catch (IOException e) {
      e.printStackTrace();
    }
    return headerMap;
  }

  /**
   * 获取 txt/csv/dat 文件编码
   *
   * @param filePath 文件路径
   * @return
   */
  private static String getFileCharset(String filePath) {
    String charset = "UTF-8";

    byte[] bytes = new byte[3];
    try (InputStream inputStream = new FileInputStream(filePath)) {
      inputStream.read(bytes);
      if (bytes[0] == (byte) 0xEF &amp;&amp; bytes[1] == (byte) 0xBB &amp;&amp; bytes[2] == (byte) 0xBF) {
        charset = "UTF-8";
      } else if (bytes[0] == (byte) 0xFE &amp;&amp; bytes[1] == (byte) 0xFF) {
        charset = "UTF-16BE";
      } else if (bytes[0] == (byte) 0xFF &amp;&amp; bytes[1] == (byte) 0xFE) {
        charset = "UTF-16LE";
      } else {
        //或GB2312，即ANSI
        charset = "GBK";
      }
      inputStream.close();
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    } catch (IOException e) {
      e.printStackTrace();
    }

    return charset;
  }

  /**
   * 判断在指定编码下是否包含乱码 输出 false，表示不包含乱码字符
   *
   * @param str
   * @param charset
   * @return
   */
  public static boolean isMessyCode(String str, Charset charset) {
    String decodedStr = new String(str.getBytes(charset), charset);
    return !decodedStr.equals(str);
  }
}</code></pre> 
<h4>CsvExport实现类</h4> 
<pre><code>package net.demo.excel.common.export.csv;

import com.alibaba.excel.metadata.BaseRowModel;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.csvreader.CsvWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import net.demo.excel.common.bean.Column;
import net.demo.excel.common.export.ExportWriter;
import net.demo.excel.common.export.csv.model.CsvModel;
import net.demo.excel.common.export.model.ExportModel;
import net.demo.excel.common.util.ExportUtil;

/**
 * csv具体实现
 */
@Slf4j
@Data
public class CsvExport implements ExportWriter {

	private ExportModel model;

	private OutputStream os;

	private String filePath;

	/**
	 * 初始化
	 *
	 * @param os
	 */
	public CsvExport(OutputStream os) {
		CsvWriter csvWriter = new CsvWriter(os, ',', Charset.forName("GBK"));
		this.model = new CsvModel(csvWriter);
		this.os = os;
	}

	/**
	 * 写标题
	 *
	 * @param columnList
	 */
	@Override
	public void writeTitle(List&lt;Column&gt; columnList) {
		String[] headers = new String[columnList.size()];
		for (int i = 0; i &lt; columnList.size(); i++) {
			Column tmp = columnList.get(i);
			headers[i] = tmp.getTitle();
		}
		try {
			model.getCsvWriter().writeRecord(headers);
		} catch (IOException e) {
			log.error("写入标题到csv失败!", e);
			throw new RuntimeException("写入标题到csv失败!");
		}
	}

	@Override
	public &lt;T extends BaseRowModel&gt; void writeTitle(Class&lt;T&gt; t){
		try {
			model.getCsvWriter().writeRecord(ExportUtil.getFieldNames(t));
		} catch (IOException e) {
			log.error("写入标题到csv失败!", e);
			throw new RuntimeException("写入标题到csv失败!");
		}
	}

	/**
	 * 内容追加
	 *
	 * @param dataList
	 * @param columnList
	 */
	@Override
	public void appendContent(JSONArray dataList, List&lt;Column&gt; columnList) {
		String[] content = null;
		List&lt;String&gt; codeList = new ArrayList&lt;String&gt;();
		for (int i = 0; i &lt; columnList.size(); i++) {
			Column tmp = columnList.get(i);
			String code = tmp.getCode();
			codeList.add(code);
		}
		try {
			for (Object obj : dataList) {
				JSONObject json = (JSONObject) JSONObject.toJSON(obj);
				content = new String[codeList.size()];
				for (int i = 0; i &lt; codeList.size(); i++) {
					String code = codeList.get(i);
					Object value = json.get(code);
					content[i] = value == null ? "" : value.toString();
				}
				model.getCsvWriter().writeRecord(content);
			}
		} catch (Exception e) {
			log.error("写入内容到csv失败!", e);
			throw new RuntimeException("写入内容到csv失败!");
		}
	}

	@Override
	public &lt;T extends BaseRowModel&gt; void appendContent(List&lt;T&gt; vos, Class&lt;T&gt; t) {
		try {
			for (T vo : vos) {
				String[] fields = ExportUtil.getFields(vo);
				model.getCsvWriter().writeRecord(fields);
			}
		} catch (IOException e) {
			log.error("写入内容到csv失败!", e);
			throw new RuntimeException("写入内容到csv失败!");
		}
	}

	/**
	 * 关闭
	 */
	@Override
	public void close() {
		CsvWriter csvWriter = model.getCsvWriter();
		if (csvWriter != null) {
			csvWriter.close();
		}
		try {
			os.close();
		} catch (IOException e) {
			log.error("os close error", e);
		}
	}

	@Override
	public String getFilePath() {
		return filePath;
	}

	@Override
	public void setFilePath(String filePath) {
		this.filePath = filePath;
	}
}</code></pre> 
<h3>创建导入数据模板类</h3> 
<pre><code>import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.excel.annotation.write.style.ColumnWidth;
import lombok.Data;
import lombok.experimental.Accessors;
 
import javax.validation.constraints.NotEmpty;
import java.io.Serializable;
 
/**
 * 数据导入的Excel模板实体
 */
@Data
public class ImportExcelVo implements Serializable {
    private static final long serialVersionUID = 1L;
 
    @ColumnWidth(20)
    @ExcelProperty(value = "公司名称", index = 0)
    private String name;
 
    @ColumnWidth(20)
    @ExcelProperty(value = "公司联系电话", index = 1)
    private String phone;
 
    @ColumnWidth(28)
    @ExcelProperty(value = "公司统一社会信用代码", index = 2)
    private String creditCode;
 
    @ColumnWidth(15)
    @ExcelProperty(value = "区域", index = 3)
    private String province;
 
    @ColumnWidth(15)
    @ExcelProperty(value = "公司法人", index = 4)
    private String legalPerson;
 
    @ExcelProperty(value = "备注", index = 5)
    private String remark;

    @DateTimeFormat("yyyy-MM-dd")  //指定日期格式
    private Date date;
}</code></pre> 
<h4>invoke时间格式，需要使用easyExcel中的<code>@ExcelProperty</code>注解，并指定日期格式</h4> 
<pre><code>  public void invoke(Object data, AnalysisContext context) {
    // 读取日期属性并进行处理
    if (rowData.get(columnIndex) instanceof Date) {
      Date date = (Date) rowData.get(columnIndex);
      // 在这里对日期进行处理
      SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
      String dateStr = sdf.format(date);
      //其他属性的处理...
      System.out.println(data);
    }
  }</code></pre> 
<h3>创建数据导出模板</h3> 
<pre><code>import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.excel.metadata.BaseRowModel;
import com.alibaba.excel.annotation.write.style.ColumnWidth;
import lombok.Data;
import lombok.experimental.Accessors;
 
import java.io.Serializable;
 
/**
 * 资质信息导出实体
 */
@Data   // Lombok注解，用于生成getter setter
@Accessors(chain = true) //Lombok注解，链式赋值使用
public class ExportExcelVo extends BaseRowModel {
    private static final long serialVersionUID = 1L;
 
    @ColumnWidth(25)
    @ExcelProperty(value = "企业名称")
    private String name;
 
    @ColumnWidth(25)
    @ExcelProperty(value = "社会统一信用代码")
    private String creditCode;
 
    @ColumnWidth(15)
    @ExcelProperty(value = "曾用名", converter = NullConverter.class)
    private String formerName;
 
    @ColumnWidth(15)
    @ExcelProperty(value = "公司法人")
    private String legalPerson;
 
    @ExcelProperty(value = "区域")
    private String province;
 
    @DateTimeFormat("yyyy年MM月dd日HH时mm分ss秒")
    @ExcelProperty(value = "录入时间")
    private String createTime;
 
    @ColumnWidth(15)
    @ExcelProperty(value = "公司股东")
    private String stockholder;
 
    @ExcelProperty(value = "企业联系方式")
    private String contact;
 
    @NumberFormat("#.##%")		// 使用百分比格式格式化这个数字
    @ExcelProperty("数字")
    private Double doubleData;
}</code></pre> 
<h4>ExcelProperty注解</h4> 
<p>可以定义表头的名称。这个注解还提供了index、order两个属性，可以定义列的位置和顺序。<img alt="" height="236" src="https://images2.imgbox.com/6c/7a/0m4P6a0W_o.png" width="1200"></p> 
<ul><li> 1）关于index</li></ul> 
<p>如果所有字段都不加index的话，<span style="color:#fe2c24;">默认index会从0开始</span>，最早的声明的字段的名字的index的值就是0。之后字段的index就从0开始递增，依次类推。index是几决定了该字段数据会赋值给Excel中的第几列。如果不想按这个顺序把数据写到Excel当中。那么就可以手动设置index的值，把字段写到想要的列中去。如果index相同，直接会抛出异常，因为程序无法判断这个列放那个字段。</p> 
<ul><li>2）关于order</li></ul> 
<p>index和order虽然都决定顺序，但是两者语义不同：如果order和index同时使用，index优先占据位置，order再进行排序。index=-1的话，使用jJava进行默认排序。order的默认值为Integer.MAX_VALUE，<span style="color:#fe2c24;">其中order的值越小，列越靠前</span>。</p> 
<h4>其他注解</h4> 
<ul><li>@DateTimeFormat 日期转换，用String去接收excel日期格式的数据会调用这个注解。@DateTimeFormat(value = "yyyy-MM-dd HH:mm:ss")指定Excel中的日期类型</li><li>@NumberFormat 数字转换，用<code>String</code>去接收<code>excel</code>数字格式的数据会调用这个注解。</li><li>@ColumnWith  设置列宽度。只有一个参数value，value的单位是字符长度，最大可以设置255个字符。</li></ul> 
<h3>@ExcelIgnore</h3> 
<p>EasyExcel组件标注在成员变量上，默认所有字段都会和excel去匹配，<span style="color:#fe2c24;">加了这个注解会忽略该字段</span></p> 
<p></p> 
<h3 id="KErfe">使用方法</h3> 
<pre><code>/**
 * Excel批量导入数据
 *
 * @param file 导入文件
 */
@RequestMapping(value = "/import", method = RequestMethod.POST)
public CommonResponse&lt;String&gt; importEvents(MultipartFile file) {
  try {
    List&lt;?&gt; list = ExportUtil.importExcel(file, ImportExcelVo.class);
    System.out.println(list);
    return CommonResponse.success("数据导入完成");
  } catch (Exception e) {
    return CommonResponse.error("数据导入失败！" + e.getMessage());
  }
}


//生成excel文件
try {
    exportWriter = WriterFactory.getExportWriter(
        dto.getExportType() == null ? "csv" : dto.getExportType(), fileName);
    exportWriter.writeTitle(PhoneExportVO.class);
    exportWriter.appendContent(list, PhoneExportVO.class);
} catch (Exception e) {
    log.error("导出失败", e);
    throw new BaseException("导出失败");
} finally {
    if (exportWriter != null) {
        exportWriter.close();
    }
}


ExportWriter exportWriter = WriterFactory.getExportWriter(exportType, fileName);
List&lt;Column&gt; columns = trunkAreaVOResp.getColumns();
exportWriter.writeTitle(columns);
JSONArray dataList = (JSONArray) JSON.toJSON(trunkAreaVOResp.getTrunkArea());
exportWriter.appendContent(dataList, columns);
exportWriter.close();</code></pre> 
<h2>EasyExcel自定义转换器Converter</h2> 
<h4>Timestamp 转换器</h4> 
<pre><code>import java.sql.Timestamp;
import java.text.SimpleDateFormat;
 
import com.alibaba.excel.converters.Converter;
import com.alibaba.excel.enums.CellDataTypeEnum;
import com.alibaba.excel.metadata.CellData;
import com.alibaba.excel.metadata.GlobalConfiguration;
import com.alibaba.excel.metadata.property.ExcelContentProperty;

public class TimestampConverter implements Converter&lt;Timestamp&gt; {

  @Override
  public Class&lt;Timestamp&gt; supportJavaTypeKey() {
    return Timestamp.class;
  }

  @Override
  public CellDataTypeEnum supportExcelTypeKey() {
    return CellDataTypeEnum.STRING;
  }

  /**
   * 将excel对象转换为Java对象
   */
  @Override
  public Timestamp convertToJavaData(CellData cellData, ExcelContentProperty contentProperty,
      GlobalConfiguration globalConfiguration) throws Exception {
    return null;
  }


  /**
   * 将 Java 对象转换为 excel 对象
   */
  @Override
  public CellData convertToExcelData(Timestamp timestamp, ExcelContentProperty contentProperty,
      GlobalConfiguration globalConfiguration) throws Exception {
    return new CellData(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(timestamp));
  }
}</code></pre> 
<h4>NullConverter</h4> 
<pre><code>import com.alibaba.excel.converters.Converter;
import com.alibaba.excel.enums.CellDataTypeEnum;
import com.alibaba.excel.metadata.CellData;
import com.alibaba.excel.metadata.GlobalConfiguration;
import com.alibaba.excel.metadata.property.ExcelContentProperty;

public class NullConverter implements Converter&lt;String&gt; {

	/**
	 * 回到 Java 中的对象类型
	 *
	 * @return 支持 Java 类
	 */
	@Override
	public Class supportJavaTypeKey() {
		return String.class;
	}

	/**
	 * * 返回 excel 中的对象枚举
	 * * @return 支持 {@link Cell DataTypeEnum}
	 * */
	@Override
	public CellDataTypeEnum supportExcelTypeKey() {
		return CellDataTypeEnum.STRING;
	}

	/**
	 * 将excel对象转换为Java对象
	 *
	 * @param cellData
	 * Excel 单元格数据。NotNull。
	 * @param contentProperty
	 * 内容属性。可空。
	 * @param globalConfiguration
	 * 全局配置。NotNull。
	 * @return 要放入 Java 对象的数据
	 * @抛出异常
	 *             例外。
	 */
	@Override
	public String convertToJavaData(CellData cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) throws Exception {
		return "-".equals(cellData.getStringValue()) ? null : cellData.getStringValue();
	}

	/**
	 * 将 Java 对象转换为 excel 对象
	 *
	 * @参数值
	 * Java 数据.NotNull。
	 * @param contentProperty
	 * 内容属性。可空。
	 * @param globalConfiguration
	 * 全局配置。NotNull。
	 * @return 数据放入 Excel
	 * @抛出异常
	 *             例外。
	 */
	@Override
	public CellData convertToExcelData(String value, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) throws Exception {
		return new CellData&lt;&gt;(null == value ? "-" : value);
	}
}
</code></pre> 
<h4>StatusConverter</h4> 
<pre><code>import com.test.project.StatusEnum;

import com.alibaba.excel.converters.Converter;
import com.alibaba.excel.enums.CellDataTypeEnum;
import com.alibaba.excel.metadata.CellData;
import com.alibaba.excel.metadata.GlobalConfiguration;
import com.alibaba.excel.metadata.property.ExcelContentProperty;

/**
 * 状态枚举转换器
 */
public class StatusConverter implements Converter&lt;Integer&gt; {

  @Override
  public Class&lt;Integer&gt; supportJavaTypeKey() {
    return Integer.class;
  }

  @Override
  public CellDataTypeEnum supportExcelTypeKey() {
    return CellDataTypeEnum.STRING;
  }

  /**
   * 将excel对象转换为Java对象
   */
  @Override
  public Integer convertToJavaData(CellData cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) throws Exception {
    return StatusEnum.getKey(cellData.getStringValue());
  }

  /**
   * 将 Java 对象转换为 excel 对象
   */
  @Override
  public CellData convertToExcelData(Integer integer, ExcelContentProperty excelContentProperty,
      GlobalConfiguration globalConfiguration) throws Exception {
    return new CellData(StatusEnum.getValue(integer));
  }
}</code></pre> 
<h4>使用方法一</h4> 
<p>每个字段都要添加@ExcelProperty(converter = NullConverter.class)代码，如果遇到大量的数据字段去填充处理会增加很多工作量。转换器仅支持需要被处理的数据字段,也就是适用于从数据库查询出来已有的数据，如日期格式或性别字段做转换时才生效</p> 
<h4>使用方法二</h4> 
<pre><code>File uploadFile = File.createTempFile("export", ".xlsx");
String templateFilePath = systemUrl + "/template/exportPublishShop.xlsx";
 
ExcelWriterSheetBuilder excelWriterSheetBuilder = 
EasyExcel.write(uploadFile).registerConverter(new TimestampConverter()).withTemplate(templateFilePath).sheet();
 
List&lt;Map&lt;String, String&gt;&gt; productList = 查询数据数据
 
// productList 如果数据量很大一定要做分页查询，避免占用内存过大
excelWriterSheetBuilder.doFill(productList);</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/259d0c0ec867a75ffa32d7147d57f192/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Anaconda最新安装图文教程（详细版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43179ccad6ef259cccf93b2df7115982/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于UniGUI的管理系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>