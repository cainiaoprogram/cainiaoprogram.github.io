<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java 原子类能做什么_Java原子类 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java 原子类能做什么_Java原子类" />
<meta property="og:description" content="一、CAS
什么是CAS,CAS就是Compare and Swap
CAS是一种无锁算法
原理：
对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
举个例子，表示一下CAS的原理。假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败。(失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试)。t1线程去更新变量值改为57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了(想改的值不再是原来的值)。
代码：
public final int getAndAddInt(Object var1, long var2, int var4) {
//1 操作的对象，2 对象中字段的偏移量，3 原来的值，4 要修改的值。
int var5;
do {
var5 = this.getIntVolatile(var1, var2);//得到当前的值。
} while(!this.compareAndSwapInt(var1, var2, var5, var5 &#43; var4));
return var5;
}
上面的代码是原子类中的一个例子。
ABA问题：
CAS乐观锁机制确实能够提升吞吐，并保证一致性，但在极端情况下可能会出现ABA问题。就是期望值被从A改为B,又从B改为A.CAS还能成功。
解决方法：加版本号。
二、原子类
原子类，顾名思义就是不可分割的，当原子类去执行操作的话是一步合成的。
以前的时候我们并发操作的时候，回去选择加锁。加锁还是有很多影响的。比如：性能损耗、逻辑复杂。所以在JDK1.5的时候Doug Lea写了原子类，也是在JUC包下。
1、原子类介绍
1.1、原子更新基本类型
下面是三种基本原子类型，以及他们常用的API。
AtomicInteger atomicInteger = new AtomicInteger(1);
atomicInteger.getAndAdd(1); //以原子方式将给定值添加到当前值。
atomicInteger.compareAndSet(1,2); //如果当前值==期望值，则以原子方式将该值设置为给定的更新值。
atomicInteger.get(); //获取当前值
atomicInteger.getAndIncrement(); //以原子方式将当前值增加一。
atomicInteger.getAndDecrement(); //以原子方式将当前值减一。
atomicInteger.addAndGet(2); //以原子方式将给定值添加到当前值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c61ac0b4be28de87a9f5423452468215/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-16T12:49:28+08:00" />
<meta property="article:modified_time" content="2021-02-16T12:49:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java 原子类能做什么_Java原子类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>一、CAS</p> 
 <p>什么是CAS,CAS就是Compare and Swap</p> 
 <p>CAS是一种无锁算法</p> 
 <p>原理：</p> 
 <p>对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p> 
 <p>举个例子，表示一下CAS的原理。假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败。(失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试)。t1线程去更新变量值改为57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了(想改的值不再是原来的值)。</p> 
 <p>代码：</p> 
 <p>public final int getAndAddInt(Object var1, long var2, int var4) {<!-- --></p> 
 <p>//1 操作的对象，2 对象中字段的偏移量，3 原来的值，4 要修改的值。</p> 
 <p>int var5;</p> 
 <p>do {<!-- --></p> 
 <p>var5 = this.getIntVolatile(var1, var2);//得到当前的值。</p> 
 <p>} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</p> 
 <p>return var5;</p> 
 <p>}</p> 
 <p>上面的代码是原子类中的一个例子。</p> 
 <p>ABA问题：</p> 
 <p>CAS乐观锁机制确实能够提升吞吐，并保证一致性，但在极端情况下可能会出现ABA问题。就是期望值被从A改为B,又从B改为A.CAS还能成功。</p> 
 <p>解决方法：加版本号。</p> 
 <p>二、原子类</p> 
 <p>原子类，顾名思义就是不可分割的，当原子类去执行操作的话是一步合成的。</p> 
 <p>以前的时候我们并发操作的时候，回去选择加锁。加锁还是有很多影响的。比如：性能损耗、逻辑复杂。所以在JDK1.5的时候Doug Lea写了原子类，也是在JUC包下。</p> 
 <p>1、原子类介绍</p> 
 <p>1.1、原子更新基本类型</p> 
 <p>下面是三种基本原子类型，以及他们常用的API。</p> 
 <p>AtomicInteger atomicInteger = new AtomicInteger(1);</p> 
 <p>atomicInteger.getAndAdd(1); //以原子方式将给定值添加到当前值。</p> 
 <p>atomicInteger.compareAndSet(1,2); //如果当前值==期望值，则以原子方式将该值设置为给定的更新值。</p> 
 <p>atomicInteger.get(); //获取当前值</p> 
 <p>atomicInteger.getAndIncrement(); //以原子方式将当前值增加一。</p> 
 <p>atomicInteger.getAndDecrement(); //以原子方式将当前值减一。</p> 
 <p>atomicInteger.addAndGet(2); //以原子方式将给定值添加到当前值。</p> 
 <p>atomicInteger.weakCompareAndSet(1,2); //如果当前值==期望值，则以原子方式将该值设置为给定的更新值。可能会虚假地失败，并且不提供排序保证，因此，很少是compareAndSet的适当替代方法。</p> 
 <p>AtomicBoolean atomicBoolean = new AtomicBoolean();</p> 
 <p>atomicBoolean.lazySet(true); //最终设置为给定值。</p> 
 <p>AtomicLong atomicLong = new AtomicLong(1L);</p> 
 <p>atomicLong.addAndGet(2L); //以原子方式将给定值添加到当前值。</p> 
 <p>//基本和Integer相似，就不一一列举了。</p> 
 <p>总的来说，它们的底层都使用了CAS，我们来找一个看看。</p> 
 <p>atomicInteger.addAndGet(2);</p> 
 <p>//第一层</p> 
 <p>public final int addAndGet(int delta) {<!-- --></p> 
 <p>return unsafe.getAndAddInt(this, valueOffset, delta) + delta;</p> 
 <p>}</p> 
 <p>//第二层</p> 
 <p>public final int getAndAddInt(Object var1, long var2, int var4) {<!-- --></p> 
 <p>int var5;</p> 
 <p>do {<!-- --></p> 
 <p>var5 = this.getIntVolatile(var1, var2); //预期值</p> 
 <p>} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); //var4是我们想要增加的值</p> 
 <p>return var5; //注意这个var5是加var4之前的值。</p> 
 <p>}</p> 
 <p>1.2、原子更新数组</p> 
 <p>我们再来看一下原子更新数组的一些基本操作</p> 
 <p>AtomicIntegerArray array = new AtomicIntegerArray(16);</p> 
 <p>array.set(1,16); //将位置i的元素设置为给定值。</p> 
 <p>array.addAndGet(1,13); //以原子方式将给定值添加到索引i处的元素。</p> 
 <p>System.out.println(array.get(1)); //获取位置i的当前值。</p> 
 <p>AtomicLongArray longArray = new AtomicLongArray(16);</p> 
 <p>// 基本和AtomicIntegerArray的API相似</p> 
 <p>longArray.set(1,2);</p> 
 <p>我们看一下AtomicIntegerArray的内部原理</p> 
 <p>public AtomicIntegerArray(int length) { //我们看一下初始化方法，内部就是维护了一个private final int[] array;</p> 
 <p>array = new int[length];</p> 
 <p>}</p> 
 <p>看一下array.addAndGet(1,13);这个方法的内部原理。</p> 
 <p>//第一层</p> 
 <p>public final int addAndGet(int i, int delta) {<!-- --></p> 
 <p>return getAndAdd(i, delta) + delta;</p> 
 <p>}</p> 
 <p>//第二层</p> 
 <p>public final int getAndAdd(int i, int delta) {<!-- --></p> 
 <p>return unsafe.getAndAddInt(array, checkedByteOffset(i), delta);</p> 
 <p>}</p> 
 <p>private long checkedByteOffset(int i) {<!-- --></p> 
 <p>if (i &lt; 0 || i &gt;= array.length)</p> 
 <p>throw new IndexOutOfBoundsException("index " + i);</p> 
 <p>return byteOffset(i);</p> 
 <p>}</p> 
 <p>//第三层</p> 
 <p>public final int getAndAddInt(Object var1, long var2, int var4) {<!-- --></p> 
 <p>int var5;</p> 
 <p>do {<!-- --></p> 
 <p>var5 = this.getIntVolatile(var1, var2);</p> 
 <p>} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</p> 
 <p>return var5;</p> 
 <p>}</p> 
 <p>//还是调用的这个方法。</p> 
 <p>AtomicReferenceArray引用数组的基本使用方法。</p> 
 <p>AtomicReferenceArray referenceArray = new AtomicReferenceArray(16);</p> 
 <p>referenceArray.set(1, "222");</p> 
 <p>//将给定函数应用于当前值和给定值，以原子方式更新索引i处的元素，并返回更新后的值。</p> 
 <p>// 该功能应无副作用，因为当尝试更新由于线程之间的争用而失败时，可以重新应用该功能。</p> 
 <p>// 应用该函数时，将索引i处的当前值作为其第一个参数，并将给定的update作为第二个参数。</p> 
 <p>referenceArray.accumulateAndGet(1, "999", (x, y) -&gt; x.toString() + y);</p> 
 <p>//输出结果为222999</p> 
 <p>我们看一下这个方法内部原理。</p> 
 <p>public final E accumulateAndGet(int i, E x,</p> 
 <p>BinaryOperator accumulatorFunction) {<!-- --></p> 
 <p>long offset = checkedByteOffset(i); //获取下标在数组中的偏移量</p> 
 <p>E prev, next;</p> 
 <p>do {<!-- --></p> 
 <p>prev = getRaw(offset); //获取当前的值</p> 
 <p>next = accumulatorFunction.apply(prev, x); //获取函数执行后的值</p> 
 <p>} while (!compareAndSetRaw(offset, prev, next)); //CAS赋值。</p> 
 <p>return next;</p> 
 <p>}</p> 
 <p>1.3、原子更新属性、引用。</p> 
 <p>原子的更新某个类里面的字段时，需要使用原子更新字段类。</p> 
 <p>我们来看看有一个原子类型。</p> 
 <p>AtomicStampedReference、AtomicReference、FiledUpdater。</p> 
 <p>不过使用上述几个引用，有几个规则必须遵守</p> 
 <p>字段必须是voliatile类型的，在线程之间共享变量时能保持可见性。</p> 
 <p>字段的描述类型是与调用者的操作对象字段保持一致。</p> 
 <p>也就是说调用者可以直接操作对象字段，那么就可以反射进行原子操作。</p> 
 <p>对父类的字段，子类不能直接操作的，尽管子类可以访问父类的字段。</p> 
 <p>只能是实例变量，不能是类变量，也就是说不能加static关键字。</p> 
 <p>只能是可修改变量，不能使用final修饰变量，final的语义，不可更改。</p> 
 <p>对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型(Integer/Long)</p> 
 <p>AtomicLongFieldUpdater这个只对long进行更新的使用方法。</p> 
 <p>AtomicLongFieldUpdater updater = AtomicLongFieldUpdater.newUpdater(Son.class, "id");</p> 
 <p>Son son = new Son();</p> 
 <p>son.setId(9);</p> 
 <p>updater.addAndGet(son,7);</p> 
 <p>如果我们想更改包装类，就使用AtomicReferenceFieldUpdater</p> 
 <p>AtomicReferenceFieldUpdater fieldUpdater = AtomicReferenceFieldUpdater.newUpdater(Son.class,String.class,"name");</p> 
 <p>fieldUpdater.compareAndSet(son,"777","666");</p> 
 <p>AtomicStampedReference 前面我们提到了ABA问题并且提到了解决办法就是加版本号，这个原子类就是带版本号的。</p> 
 <p>AtomicStampedReference stampedReference = new AtomicStampedReference("aaa", 1);</p> 
 <p>stampedReference.compareAndSet("aaa", "bbb", stampedReference.getStamp(), stampedReference.getStamp() + 1);</p> 
 <p>小结</p> 
 <p>我们去看原子类内部时，发现最终都是使用了CAS的方法。原子类就是在CAS发展来的。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa71ca8da5629961e294bcd3f2452f73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java web常见异常_javaweb中一下常见的错误及排查方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2d3cefc1026374c8c4b8d8cba517ee13/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是计算机病毒？是怎么产生的？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>