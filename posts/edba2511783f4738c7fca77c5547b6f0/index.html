<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式——单例模式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式——单例模式" />
<meta property="og:description" content="单例模式 目的 单例是一种创造性的设计模式，它允许您确保一个类只有一个实例同时为这个实例提供一个全局访问点。
问题 单例模式同时解决了两个问题，违反了单责任原则:
确保一个类只有一个实例。为什么会有人想要控制一个类有多少个实例？最常见的原因是控制对某些共享资源(例如数据库或文件)的访问。它是这样工作的：假设您创建了一个对象，但过了一段时间后决定创建一个新对象。您将获得已经创建的对象而不是接收一个新的对象。注意这种行为不可能用常规构造函数实现，因为构造函数调用必须按照设计总是返回一个新对象。
为该实例提供一个全局访问点。还记得你用来存储一些基本对象的全局变量吗？虽然它们非常方便但也非常不安全，因为任何代码都可能覆盖这些变量的内容，从而导致应用程序崩溃。就像全局变量一样，单例模式允许您从程序中的任何地方访问某个对象。但是它还可以保护该实例不被其他代码覆盖。这个问题还有另一个方面：您不希望解决问题1的代码分散在您的程序中。最好将它放在一个类中，尤其是在其他代码已经依赖于它的情况下。 如今单例模式已经变得如此流行以至于人们可能会称某个类为单例，即使它只解决了列出的其中一个问题。
解决方案 所有单例模式的实现都有这两个共同的步骤:
将默认构造函数设为private，以防止其他对象对单例类使用new操作符。创建一个充当构造函数的静态创建方法。在实现中这个方法调用私有构造函数来创建一个对象并将其保存在一个静态字段中。对这个方法的所有后续调用都会返回缓存的对象。 如果您的代码能够访问单例类，那么它就能够调用单例类的静态方法。无论何时调用那个方法总是返回相同的对象。
与真实世界的对比 政府是单例模式的一个很好的例子。一个国家只能有一个官方政府。无论组成政府的个人身份如何，“政府of X”这个头衔都是一个全球性的访问点，可以识别出政府负责人的身份。
结构 单例类声明了一个静态方法getInstance，该方法返回它自己类的同一个实例。单例的构造函数应该对客户端代码隐藏。调用getInstance方法应该是获取Singleton对象的唯一方法。 伪码 在本例中数据库连接类充当单例。这个类没有公共构造函数，所以获得它的对象的唯一方法是调用getInstance方法。这个方法缓存第一个创建的对象，并在所有后续调用中返回它。
// The Database class defines the `getInstance` method that lets // clients access the same instance of a database connection // throughout the program. class Database is // The field for storing the singleton instance should be // declared static. private static field instance: Database // The singleton&#39;s constructor should always be private to // prevent direct construction calls with the `new` // operator." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/edba2511783f4738c7fca77c5547b6f0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-16T05:52:50+08:00" />
<meta property="article:modified_time" content="2022-06-16T05:52:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式——单例模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>单例模式</h3> 
<h4><a id="_1"></a>目的</h4> 
<p><strong>单例</strong>是一种创造性的设计模式，它允许您确保一个类只有一个实例同时为这个实例提供一个全局访问点。<br> <img src="https://images2.imgbox.com/b5/86/vxZI2XlK_o.png" alt="单例模式示意图"></p> 
<h4><a id="_4"></a>问题</h4> 
<p>单例模式同时解决了两个问题，违反了单责任原则:</p> 
<ol><li><strong>确保一个类只有一个实例</strong>。为什么会有人想要控制一个类有多少个实例？最常见的原因是控制对某些共享资源(例如数据库或文件)的访问。它是这样工作的：假设您创建了一个对象，但过了一段时间后决定创建一个新对象。您将获得已经创建的对象而不是接收一个新的对象。注意这种行为不可能用常规构造函数实现，因为构造函数调用必须按照设计总是返回一个新对象。<br> <img src="https://images2.imgbox.com/b2/2e/Kkr1X6NQ_o.png" alt="在这里插入图片描述"></li><li><strong>为该实例提供一个全局访问点</strong>。还记得你用来存储一些基本对象的全局变量吗？虽然它们非常方便但也非常不安全，因为任何代码都可能覆盖这些变量的内容，从而导致应用程序崩溃。就像全局变量一样，单例模式允许您从程序中的任何地方访问某个对象。但是它还可以保护该实例不被其他代码覆盖。这个问题还有另一个方面：您不希望解决问题1的代码分散在您的程序中。最好将它放在一个类中，尤其是在其他代码已经依赖于它的情况下。</li></ol> 
<p>如今单例模式已经变得如此流行以至于人们可能会称某个类为单例，即使它只解决了列出的其中一个问题。</p> 
<h4><a id="_13"></a>解决方案</h4> 
<p>所有单例模式的实现都有这两个共同的步骤:</p> 
<ul><li>将默认构造函数设为private，以防止其他对象对单例类使用new操作符。</li><li>创建一个充当构造函数的静态创建方法。在实现中这个方法调用私有构造函数来创建一个对象并将其保存在一个静态字段中。对这个方法的所有后续调用都会返回缓存的对象。</li></ul> 
<p>如果您的代码能够访问单例类，那么它就能够调用单例类的静态方法。无论何时调用那个方法总是返回相同的对象。</p> 
<h4><a id="_21"></a>与真实世界的对比</h4> 
<p>政府是单例模式的一个很好的例子。一个国家只能有一个官方政府。无论组成政府的个人身份如何，“政府of X”这个头衔都是一个全球性的访问点，可以识别出政府负责人的身份。</p> 
<h4><a id="_24"></a>结构</h4> 
<p><img src="https://images2.imgbox.com/08/fc/pCxHst01_o.png" alt="在这里插入图片描述"></p> 
<ol><li><strong>单例类</strong>声明了一个静态方法getInstance，该方法返回它自己类的同一个实例。单例的构造函数应该对客户端代码隐藏。调用getInstance方法应该是获取Singleton对象的唯一方法。</li></ol> 
<h4><a id="_28"></a>伪码</h4> 
<p>在本例中数据库连接类充当<strong>单例</strong>。这个类没有公共构造函数，所以获得它的对象的唯一方法是调用getInstance方法。这个方法缓存第一个创建的对象，并在所有后续调用中返回它。</p> 
<pre><code class="prism language-java"><span class="token comment">// The Database class defines the `getInstance` method that lets</span>
<span class="token comment">// clients access the same instance of a database connection</span>
<span class="token comment">// throughout the program.</span>
<span class="token keyword">class</span> <span class="token class-name">Database</span> is
    <span class="token comment">// The field for storing the singleton instance should be</span>
    <span class="token comment">// declared static.</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> field instance<span class="token operator">:</span> <span class="token class-name">Database</span>

    <span class="token comment">// The singleton's constructor should always be private to</span>
    <span class="token comment">// prevent direct construction calls with the `new`</span>
    <span class="token comment">// operator.</span>
    <span class="token keyword">private</span> constructor <span class="token class-name">Database</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token comment">// Some initialization code, such as the actual</span>
        <span class="token comment">// connection to a database server.</span>
        <span class="token comment">// ...</span>

    <span class="token comment">// The static method that controls access to the singleton</span>
    <span class="token comment">// instance.</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> method <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Database</span><span class="token punctuation">.</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> then
            <span class="token function">acquireThreadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> and then
                <span class="token comment">// Ensure that the instance hasn't yet been</span>
                <span class="token comment">// initialized by another thread while this one</span>
                <span class="token comment">// has been waiting for the lock's release.</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Database</span><span class="token punctuation">.</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> then
                    <span class="token class-name">Database</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Database</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token class-name">Database</span><span class="token punctuation">.</span>instance

    <span class="token comment">// Finally, any singleton should define some business logic</span>
    <span class="token comment">// which can be executed on its instance.</span>
    <span class="token keyword">public</span> method <span class="token function">query</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span> is
        <span class="token comment">// For instance, all database queries of an app go</span>
        <span class="token comment">// through this method. Therefore, you can place</span>
        <span class="token comment">// throttling or caching logic here.</span>
        <span class="token comment">// ...</span>

<span class="token keyword">class</span> <span class="token class-name">Application</span> is
    method <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token class-name">Database</span> foo <span class="token operator">=</span> <span class="token class-name">Database</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        foo<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"SELECT ..."</span><span class="token punctuation">)</span>
        <span class="token comment">// ...</span>
        <span class="token class-name">Database</span> bar <span class="token operator">=</span> <span class="token class-name">Database</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        bar<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"SELECT ..."</span><span class="token punctuation">)</span>
        <span class="token comment">// The variable `bar` will contain the same object as</span>
        <span class="token comment">// the variable `foo`.</span>
</code></pre> 
<h4><a id="_80"></a>应用</h4> 
<p><strong>当你的程序中的一个类只有一个对所有客户端可用的实例时，使用单例模式;例如由程序的不同部分共享的单个数据库对象。</strong></p> 
<p>单例模式禁用了创建类对象的所有其他方法除了特殊的创建方法。这个方法要么创建一个新对象要么返回一个已经创建的对象。</p> 
<p><strong>当你需要对全局变量进行更严格的控制时，使用单例模式。</strong></p> 
<p>与全局变量不同单例模式保证一个类只有一个实例。除了单例类本身之外，没有任何东西可以替代缓存的实例。请注意您总是可以调整这个限制并允许创建任意数量的单例实例。惟一需要更改的代码片段是getInstance方法的主体。</p> 
<h4><a id="_90"></a>如何实现</h4> 
<ol><li>向类中添加一个私有静态字段，用于存储单例实例。</li><li>声明一个公共静态创建方法来获取单例实例。</li><li>在静态方法中实现“延迟初始化”。它应该在第一次调用时创建一个新对象并将其放入静态字段中。在所有后续调用中，该方法应该始终返回该实例。</li><li>将类的构造函数设为private。类的静态方法仍然可以调用构造函数，但不能调用其他对象。</li><li>仔细检查客户端代码，将所有对单例构造函数的直接调用替换为对其静态创建方法的调用。</li></ol> 
<h4><a id="_98"></a>正反面</h4> 
<p><strong>正面因素：</strong></p> 
<ul><li>你可以保证一个类只有一个实例。</li><li>你可以获得此实例的全局访问点。</li><li>单例对象只有在第一次被请求时才会初始化。</li></ul> 
<p><strong>反面因素：</strong></p> 
<ul><li>违反单一责任原则。该模式同时解决了两个问题。</li><li>单例模式可以掩盖糟糕的设计，例如当程序的组件彼此了解太多时。</li><li>该模式需要在多线程环境中进行特殊处理，保证多个线程不会多次创建一个单例对象。</li><li>对单例的客户端代码进行单元测试可能很困难，因为许多测试框架在生成模拟对象时依赖于继承。由于单例类的构造函数是私有的并且在大多数语言中重写静态方法是不可能的，因此您需要想出一种创造性的方法来模拟单例。或者干脆不写测试，或者不要使用Singleton模式。</li></ul> 
<h4><a id="_110"></a>同其他设计模式的关联</h4> 
<ul><li> <p><strong>外观类</strong>通常可以转换为<strong>单例类</strong>，因为在大多数情况下单个外观对象就足够了。</p> </li><li> <p>如果您设法将对象的所有共享状态减少到一个<strong>轻量化</strong>对象，那么轻量级模式将类似于<strong>单例</strong>模式。但是这些模式之间有两个基本的区别:</p> </li></ul> 
<ol><li>应该只有一个单例实例，而轻量化类可以有多个具有不同内在状态的实例。</li><li>单例对象可以是可变的。轻量化对象是不可变的。</li></ol> 
<ul><li><strong>抽象工厂</strong>、<strong>构造器</strong>和<strong>原型</strong>都可以实现为单例。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/886af524c8c107213e01d16646cd906e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">EMQX——docker安装及简单使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3922feeda1fd536bb2d346dd2540b7cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TB6612FNG电机驱动模块纯硬件调试</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>