<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解 Golang 中的值类型和引用类型 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入理解 Golang 中的值类型和引用类型" />
<meta property="og:description" content="目录
Golang 的内存模型
值类型
引用类型
值类型与引用类型在函数传递中的差异
指针类型（Pointer Types）
值类型与引用类型的比较
小结
在 Golang 中，数据类型可以分为两大类：值类型（Value Types）和引用类型（Reference Types）。理解这两种类型的区别对于理解 Golang 中的数据传递和内存管理是很重要的。
Golang 的内存模型 Golang 在内存分配上有两个主要的区域：栈（stack）和堆（heap）。栈用于存储函数调用时的局部变量和函数参数，特点是分配和回收速度快。而堆则用于存储那些可能需要跨函数存活的数据，由垃圾回收器管理。
值类型 值类型是指变量直接存储了实际的数据，并且每个变量都拥有独立的存储空间。当一个值类型的变量被赋给另一个变量时，会进行值拷贝，对其中一个变量的修改不会影响到原始变量。
在 Golang 中，值类型包括以下几种：
基本数据类型：整型（int、uint、int8等）、浮点型（float32、float64）、复数（complex64, complex128）、布尔型（bool）、字符串型（string）复合数据类型：数组（array）、结构体（struct） 值类型有以下特点：
直接存储值，不存储地址。变量间赋值或作为函数参数传递时进行值复制。值类型的变量副本是独立的，修改一个变量的副本不会影响另一个。值类型的复制会涉及整个值的拷贝，因此对于大的结构体或数组，复制操作可能会较慢。值类型通常在栈上分配，除非是通过 new 函数分配的，或者是作为闭包中的变量被分配到堆上。 看一个简单的示例：
package main import &#34;fmt&#34; func main() { x := 10 y := x x&#43;&#43; fmt.Println(x, y) // 输出：11 10 } 在这个例子中，x 和 y 都是整型值，y 是 x 的一个副本。对 x 的修改不会影响到 y，因此 y 的值仍然是10。
引用类型 引用类型并不直接存储数据本身，而是存储指向数据的指针，当复制一个引用类型的变量时，复制的是指针，新旧变量将指向相同的底层数据。
在 Golang 中，引用类型主要包括：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/780342c9499dcf70cb481e92ced683ce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T21:51:34+08:00" />
<meta property="article:modified_time" content="2024-01-04T21:51:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解 Golang 中的值类型和引用类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="Golang%20%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px;"><a href="#Golang%20%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B" rel="nofollow">Golang 的内存模型</a></p> 
<p id="%E5%80%BC%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E5%80%BC%E7%B1%BB%E5%9E%8B" rel="nofollow">值类型</a></p> 
<p id="%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B" rel="nofollow">引用类型</a></p> 
<p id="%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%BC%82-toc" style="margin-left:0px;"><a href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%BC%82" rel="nofollow">值类型与引用类型在函数传递中的差异</a></p> 
<p id="%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%EF%BC%88Pointer%20Types%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%EF%BC%88Pointer%20Types%EF%BC%89" rel="nofollow">指针类型（Pointer Types）</a></p> 
<p id="%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:0px;"><a href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">值类型与引用类型的比较</a></p> 
<p id="%E5%B0%8F%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%B0%8F%E7%BB%93" rel="nofollow">小结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>在 Golang 中，数据类型可以分为两大类：值类型（Value Types）和引用类型（Reference Types）。理解这两种类型的区别对于理解 Golang 中的数据传递和内存管理是很重要的。</p> 
<h2 id="Golang%20%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">Golang 的内存模型</h2> 
<p>Golang 在内存分配上有两个主要的区域：栈（stack）和堆（heap）。栈用于存储函数调用时的局部变量和函数参数，特点是分配和回收速度快。而堆则用于存储那些可能需要跨函数存活的数据，由垃圾回收器管理。</p> 
<h2 id="%E5%80%BC%E7%B1%BB%E5%9E%8B">值类型</h2> 
<p>值类型是指变量直接存储了实际的数据，并且每个变量都拥有独立的存储空间。当一个值类型的变量被赋给另一个变量时，会进行值拷贝，对其中一个变量的修改不会影响到原始变量。</p> 
<p>在 Golang 中，值类型包括以下几种：</p> 
<ul><li>基本数据类型：整型（int、uint、int8等）、浮点型（float32、float64）、复数（complex64, complex128）、布尔型（bool）、字符串型（string）</li><li>复合数据类型：数组（array）、结构体（struct）</li></ul> 
<p>值类型有以下特点：</p> 
<ul><li>直接存储值，不存储地址。</li><li>变量间赋值或作为函数参数传递时进行值复制。</li><li>值类型的变量副本是独立的，修改一个变量的副本不会影响另一个。</li><li>值类型的复制会涉及整个值的拷贝，因此对于大的结构体或数组，复制操作可能会较慢。</li><li>值类型通常在栈上分配，除非是通过 new 函数分配的，或者是作为闭包中的变量被分配到堆上。</li></ul> 
<p>看一个简单的示例：</p> 
<pre><code>package main

import "fmt"

func main() {
    x := 10
    y := x
    x++
    fmt.Println(x, y) // 输出：11 10
}</code></pre> 
<p>在这个例子中，x 和 y 都是整型值，y 是 x 的一个副本。对 x 的修改不会影响到 y，因此 y 的值仍然是10。</p> 
<h2 id="%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</h2> 
<p>引用类型并不直接存储数据本身，而是存储指向数据的指针，当复制一个引用类型的变量时，复制的是指针，新旧变量将指向相同的底层数据。</p> 
<p>在 Golang 中，引用类型主要包括：</p> 
<ul><li>切片（Slices）：切片是对数组的封装，提供了一个灵活、动态的视图。当修改切片中的元素时，实际上是在修改底层数组的相应元素。</li><li>映射（Maps）：映射是一种存储键值对的集合。将映射传递给一个函数或者赋值给另一个变量时，任何对映射的修改都会反映在所有引用了这个映射的地方。</li><li>通道（Channels）：通道用于在不同的 goroutine 之间传递消息。通道本质上是引用类型，当复制或传递它们时，实际上传递的是对通道数据结构的引用。</li><li>接口（Interfaces）：接口类型是一种抽象类型，定义了一组方法，但不会实现这些方法。接口内部存储的是指向实现了接口方法的值的指针和指向该类型信息的指针。</li><li>函数（Functions）：在 Go 中，函数也是一种引用类型。当把一个函数赋给另一个变量时，实际上是在复制一个指向该函数的引用。</li></ul> 
<p>引用类型有以下特点</p> 
<ul><li>存储的是指向数据的地址，而不是数据本身。</li><li>当引用类型的变量被赋值或作为函数参数传递时，实际上是将该地址复制一份，因此多个变量可能共享同一份数据。</li><li>引用类型的数据通常在堆上分配，即使变量本身在栈上。</li><li>引用类型的零值是 nil，一个未初始化的引用类型的变量将会是 nil，不指向任何内存地址。</li></ul> 
<p>看一个简单的示例：</p> 
<pre><code>package main

import "fmt"

func modifySlice(s []int) {
    s[0] = 100 // 对切片元素的修改会影响到原切片
}

func main() {
    numbers := []int{1, 2, 3}
    modifySlice(numbers)
    fmt.Println(numbers) // 输出：[100 2 3]
}</code></pre> 
<h2 id="%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%BC%82">值类型与引用类型在函数传递中的差异</h2> 
<p>在函数参数传递时，值类型和引用类型的行为也不同。值类型参数在传递给函数时会创建一个副本，而引用类型参数传递的是指针的副本，所以函数内部对引用类型参数的修改会影响原始数据。</p> 
<pre><code>package main

import "fmt"

func modifySlice(s []int) {
    s[0] = 100
}

func main() {
    s := []int{1, 2, 3}
    modifySlice(s)
    fmt.Println(s) // 输出 [100 2 3], 切片被修改了
}</code></pre> 
<h2 id="%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%EF%BC%88Pointer%20Types%EF%BC%89">指针类型（Pointer Types）</h2> 
<p>指针类型也是 Golang 中的一种基本类型，存储了值的内存地址。指针类型可以指向任何值类型的数据，并且通过指针，可以在不同的函数之间共享和修改数据。</p> 
<pre><code>package main

import "fmt"

func modifyValue(p *int) {
    *p = 100
}

func main() {
    a := 1
    modifyValue(&amp;a)
    fmt.Println(a) // 输出 100, 值被修改了
}</code></pre> 
<h2 id="%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83">值类型与引用类型的比较</h2> 
<ul><li>内存分配：值类型在声明或初始化时即分配内存，引用类型仅在声明指针或容器时分配内存，而所指向的数据通常在首次使用时动态分配。</li><li>内存占用：值类型的每次复制都会产生新的数据副本，可能会消耗更多内存；引用类型在多处共享数据时只需存储数据一次，节省内存。</li><li>数据安全性：值类型在函数调用过程中保证了数据的隔离性，不易出现并发问题；引用类型在并发环境下的数据共享可能导致竞态条件，需要额外同步机制来保护。</li><li>性能考虑：由于不存在共享数据的问题，值类型的计算相对简单，有时性能更好；然而，在需要大量数据共享或动态扩容缩容的场景下，引用类型更具有优势。</li></ul> 
<h2 id="%E5%B0%8F%E7%BB%93">小结</h2> 
<p>理解值类型和引用类型的区别和特性有助于编写更加高效、可靠的代码。在实际应用中，应综合考虑需求、性能和安全性等因素来选择适当的类型。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d9fe1b5392ef539b1f74994e84fa1d8a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Pytorch从零开始实战15</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fce7480ab6d2c2874ff6f7fc5aab7e88/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VRPSolverEasy：可求解多种VRP变体（rich vehicle routing）问题的精确算法python包</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>