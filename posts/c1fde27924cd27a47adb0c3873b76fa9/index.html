<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>初探linux子系统集之led子系统(三) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="初探linux子系统集之led子系统(三)" />
<meta property="og:description" content="世界杯结束了，德国战车夺得了大力神杯，阿根廷最终还是失败了。也许3年，5年，或者10年后，人们就不知道巴西世界杯的亚军是谁，但是总是会记得冠军是谁。就像什么考试，比赛，第一永远会被人们所记住，所以我们都想去追寻第一，渴望第一，在一次次的追寻中，成者为王败者为寇。而处在第一的位置，永远担心下面的会超越自己，从而活得很累，而第二永远想争取第一，也活得很累，有时候，想想，人一生当中，成功真的就那么重要吗？富有真的那么重要吗？采菊东篱下，悠然见南山不是也很有诗意吗？说了好多，还是继续写led子系统吧。
前面写了很多关于led子系统的相关知识，现在终于可以开始分析leds-gpio.c这个驱动了。
注册了platform驱动。
platform_driver_register(&amp;gpio_led_driver);
platform总线就不多说了，在自己的平台下添加platform device就可以了。
当device和dirver匹配后，就会调用driver的probe函数，这里调用的是下面这个函数。
static int __devinit gpio_led_probe(struct platform_device *pdev) { structgpio_led_platform_data *pdata = pdev-&gt;dev.platform_data; struct gpio_leds_priv*priv; int i, ret = 0; if (pdata &amp;&amp;pdata-&gt;num_leds) { priv =kzalloc(sizeof_gpio_leds_priv(pdata-&gt;num_leds), GFP_KERNEL); if (!priv) return-ENOMEM; priv-&gt;num_leds= pdata-&gt;num_leds; for (i = 0;i &lt; priv-&gt;num_leds; i&#43;&#43;) { ret= create_gpio_led(&amp;pdata-&gt;leds[i], &amp;priv-&gt;leds[i], &amp;pdev-&gt;dev,pdata-&gt;gpio_blink_set); if(ret &lt; 0) { /*On failure: unwind the led creations */ for(i = i - 1; i &gt;= 0; i--) delete_gpio_led(&amp;priv-&gt;leds[i]); kfree(priv); returnret; } } } else { priv =gpio_leds_create_of(pdev); if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c1fde27924cd27a47adb0c3873b76fa9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-07-15T19:20:14+08:00" />
<meta property="article:modified_time" content="2014-07-15T19:20:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">初探linux子系统集之led子系统(三)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">        世界杯结束了，德国战车夺得了大力神杯，阿根廷最终还是失败了。也许3年，5年，或者10年后，人们就不知道巴西世界杯的亚军是谁，但是总是会记得冠军是谁。就像什么考试，比赛，第一永远会被人们所记住，所以我们都想去追寻第一，渴望第一，在一次次的追寻中，成者为王败者为寇。而处在第一的位置，永远担心下面的会超越自己，从而活得很累，而第二永远想争取第一，也活得很累，有时候，想想，人一生当中，成功真的就那么重要吗？富有真的那么重要吗？采菊东篱下，悠然见南山不是也很有诗意吗？说了好多，还是继续写led子系统吧。</span></p> 
<p><span style="font-size:18px">        前面写了很多关于led子系统的相关知识，现在终于可以开始分析leds-gpio.c这个驱动了。</span></p> 
<p><span style="font-size:18px">        注册了platform驱动。</span></p> 
<p><span style="font-size:18px">         platform_driver_register(&amp;gpio_led_driver);</span></p> 
<p><span style="font-size:18px">        platform总线就不多说了，在自己的平台下添加platform device就可以了。</span></p> 
<p><span style="font-size:18px">         当device和dirver匹配后，就会调用driver的probe函数，这里调用的是下面这个函数。</span></p> 
<p></p> 
<pre><code class="language-html">static int __devinit gpio_led_probe(struct platform_device *pdev)
{
         structgpio_led_platform_data *pdata = pdev-&gt;dev.platform_data;
         struct gpio_leds_priv*priv;
         int i, ret = 0;
 
         if (pdata &amp;&amp;pdata-&gt;num_leds) {
                   priv =kzalloc(sizeof_gpio_leds_priv(pdata-&gt;num_leds),
                                     GFP_KERNEL);
                   if (!priv)
                            return-ENOMEM;
 
                   priv-&gt;num_leds= pdata-&gt;num_leds;
                   for (i = 0;i &lt; priv-&gt;num_leds; i++) {
                            ret= create_gpio_led(&amp;pdata-&gt;leds[i],
                                                     &amp;priv-&gt;leds[i],
                                                     &amp;pdev-&gt;dev,pdata-&gt;gpio_blink_set);
                            if(ret &lt; 0) {
                                     /*On failure: unwind the led creations */
                                     for(i = i - 1; i &gt;= 0; i--)
                                               delete_gpio_led(&amp;priv-&gt;leds[i]);
                                     kfree(priv);
                                     returnret;
                            }
                   }
         } else {
                   priv =gpio_leds_create_of(pdev);
                   if (!priv)
                            return-ENODEV;
         }
 
         platform_set_drvdata(pdev,priv);
 
         return 0;
}</code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">获取platform里的device的数据，然后create_gpio_led，这里可以注册很多歌led，具体的leds-gpio的platform数据可以参考</span></p> 
<p><span style="font-size:18px"><a target="_blank" href="http://blog.csdn.net/eastmoon502136/article/details/37569789" rel="noopener noreferrer">http://blog.csdn.net/eastmoon502136/article/details/37569789</a>。</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">接着看一下create_gpio_led这个函数。</span></p> 
<p></p> 
<pre><code class="language-html">static int __devinit create_gpio_led(const struct gpio_led*template,
         struct gpio_led_data*led_dat, struct device *parent,
         int (*blink_set)(unsigned,int, unsigned long *, unsigned long *))
{
         int ret, state;
 
         led_dat-&gt;gpio = -1;
 
         /* skip leds thataren't available */
         if(!gpio_is_valid(template-&gt;gpio)) {
                   printk(KERN_INFO"Skipping unavailable LED gpio %d (%s)\n",
                                     template-&gt;gpio,template-&gt;name);
                   return 0;
         }
 
         ret =gpio_request(template-&gt;gpio, template-&gt;name);
         if (ret &lt; 0)
                   return ret;
 
         led_dat-&gt;cdev.name= template-&gt;name;
         led_dat-&gt;cdev.default_trigger= template-&gt;default_trigger;
         led_dat-&gt;gpio =template-&gt;gpio;
         led_dat-&gt;can_sleep= gpio_cansleep(template-&gt;gpio);
         led_dat-&gt;active_low= template-&gt;active_low;
         led_dat-&gt;blinking =0;
         if (blink_set) {
                   led_dat-&gt;platform_gpio_blink_set= blink_set;
                   led_dat-&gt;cdev.blink_set= gpio_blink_set;
         }
         led_dat-&gt;cdev.brightness_set= gpio_led_set;
         if(template-&gt;default_state == LEDS_GPIO_DEFSTATE_KEEP)
                   state =!!gpio_get_value(led_dat-&gt;gpio) ^ led_dat-&gt;active_low;
         else
                   state =(template-&gt;default_state == LEDS_GPIO_DEFSTATE_ON);
         led_dat-&gt;cdev.brightness= state ? LED_FULL : LED_OFF;
         if(!template-&gt;retain_state_suspended)
                   led_dat-&gt;cdev.flags|= LED_CORE_SUSPENDRESUME;
 
         ret =gpio_direction_output(led_dat-&gt;gpio, led_dat-&gt;active_low ^ state);
         if (ret &lt; 0)
                   goto err;
                  
         INIT_WORK(&amp;led_dat-&gt;work,gpio_led_work);
 
         ret =led_classdev_register(parent, &amp;led_dat-&gt;cdev);
         if (ret &lt; 0)
                   goto err;
 
         return 0;
err:
         gpio_free(led_dat-&gt;gpio);
         return ret;
}</code></pre> 
<br> 
<br> 
<p></p> 
<p></p> 
<pre><code class="language-html"> 
struct gpio_led_data {
         struct led_classdevcdev;
         unsigned gpio;
         struct work_structwork;
         u8 new_level;
         u8 can_sleep;
         u8 active_low;
         u8 blinking;
         int(*platform_gpio_blink_set)(unsigned gpio, int state,
                            unsignedlong *delay_on, unsigned long *delay_off);
};
 </code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px">申请gpio，以及对于一些变量和函数指针的赋值，最后注册led设备。</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">关于应用层的调用:</span></p> 
<p><span style="font-size:18px">比如我们在platform设备中注册了</span></p> 
<p></p> 
<pre><code class="language-html">Static struct gpio_led gpio_leds[] = {
         {
                   .name=”my-led”,
                   .default_trigger= “timer”,
                   .gpio= 30,
                   .active_low= 1,
                   .default_state= LEDS_GPIO_DEFSTATE_OFF,
}
};</code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">那么在/sys/class/leds/下会有my-led目录，在目录下面会创建两个文件delay_on和delay_off。</span></p> 
<p><span style="font-size:18px">可以通过</span></p> 
<p><span style="font-size:18px">echo 100 &gt; /sys/class/leds/my-led/delay_on</span></p> 
<p><span style="font-size:18px">echo 100 &gt; /sys/class/leds/my-led/delay_off</span></p> 
<p><span style="font-size:18px">来控制闪烁的时间。</span></p> 
<p><span style="font-size:18px">         cat /sys/class/leds/my-led/delay_on</span></p> 
<p><span style="font-size:18px">cat  /sys/class/leds/my-led/delay_off</span></p> 
<p><span style="font-size:18px">来获取当前的delay_on和delay_off的值</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">对于led子系统就简单的介绍到这里了。</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px"> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/33a8ea7d156d56d314ed6d280cfd91fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">bat中if语句的用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b20014fc7bb35ebb6fcdf3493c563d9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Profibus DP/PA/FMS</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>