<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>armcm3权威指南笔记 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="armcm3权威指南笔记" />
<meta property="og:description" content="CM3系列处理器优势：
功耗低。延长了电池的寿命——这简直就是便携式设备的命门（如无线网络应用）
实时性好。采用了很前卫甚至革命性的设计理念，使它能极速地响应中断，而且响应中断所需的周期数是确定的。
代码密度得到很大改善（应用thumb指令？）。一方面力挺大型应用程序，另一方面为低成本设计而省吃俭用。
降低成本还有一招，就是使基础代码在所有系统中都可以重用，至少要方便移植。CM3的内核架构非常精工细作，使它与C语言成为了一个梦幻绝配。优质的C程序代码三下五除二就可以移植并重用，使升级和移植一下子从拦路虎变成了纸老虎。
，CM3还突破性地引入了很多时尚的甚至崭新的技术，专门满足单片机应用程序的需求。比如，服务于“使命-关键”应用的不可屏蔽中断，极度敏捷并且拥有确定性的嵌套向量中断系统.
P15和P16有关于cortex-m和cortex-a其他系列的比较，讲的比较好。
还有关键的対实时系统的定义：
通用处理器能否胜任实时系统的控制，常遭受质疑，并且在这方面的争论从没停止过。从定义的角度讲，“实时”就是指系统必须在给定的死线（deadline，亦称作“最后期限”）内做出响应。在一个以ARM处理器为核心的系统中，决定能否达到“实时”这个目标的，有很多因素，包括是否使用“实时操作系统”，中断延迟，存储器延时，以及当时处理器是否在运行更高优先级的中断服务例程。
MMU，存储器管理单元，用于实现虚拟内存和内存的分区保护，这是应用处理器与嵌入式处理器的分水岭。电脑和数码产品所使用的处理器几乎清一色地都带MMU。但是MMU也引入了不确定性，这有时是嵌入式领域——尤其是实时系统不可接受的。然而对于安全关键（safety-critical）的嵌入式系统，还是不能没有内存的分区保护的。为解决矛盾，于是就有了MPU。可以把MPU认为是MMU的功能子集，它只支持分区保护，不支持具有“定位决定性”的虚拟内存机制。
1.5 Cortex-M3处理器的舞台也比较有意思
当呼叫一个子程序时，由R14存储返回地址
不像大多数其它处理器，ARM为了减少访问内存的次数（访问内存的操作往往要3个以上指令周期，带MMU和cache的就更加不确定了），把返回地址直接存储在寄存器中。这样足以使很多只有1级子程序调用的代码无需访问内存（堆栈内存），从而提高了子程序调用的效率。如果多于1级，则需要把前一级的R14值压到堆栈里。在ARM上编程时，应尽量只使用寄存器保存中间结果，迫不得以时才访问内存。
中断可屏蔽
既可以屏蔽优先级低于某个阈值的中断/异常［译注8］(设置BASEPRI寄存器)，也可以全体封杀(设置PRIMASK和FAULTMASK寄存器)。这是为了让时间关键（time-critical）的任务能在死线Cortex-M3权威指南 第 2 章 27
(deadline，或曰最后期限)到来前完成，而不被干扰。
Cortex-M3只使用Thumb-2指令集。这是个了不起的突破，因为它允许32位指令和16位指令水乳交融，代码密度与处理性能两手抓，两手都硬。而且虽然它很强大，却依然易于使用。
在过去，做ARM开发必须处理好两个状态。这两个状态是井水不犯河水的，它们是：32位的ARM状态和16位的Thumb状态。当处理器在ARM状态下时，所有的指令均是32位的（哪怕只是个”NOP”指令），此时性能相当高。而在Thumb状态下，所有的指令均是16位的，代码密度提高了一倍。不过，thumb状态下的指令功能只是ARM下的一个子集，结果可能需要更多条的指令去完成相同的工作，导致处理性能下降。
事实上，Cortex-M3内核干脆都不支持ARM指令，中断也在Thumb态下处理（以前的ARM总是在ARM状态下处理所有的中断和异常）。这可不是小便宜，它使CM3在好几个方面都比传统的ARM处理器更先进
因为CM3专情于最新的Thumb-2，旧的应用程序需要移植和重建。对于大多数C源程序，只需简单地重新编译就能重建，汇编代码则可能需要大面积地修改和重写，才能使用CM3的新功能，并且融入CM3新引入的统一汇编器框架(unified assembler framework)中。
Cortex-M3的设计允许单片机高频运行（现代半导体制造技术能保证100MHz以上的速度）。即使在相同的速度下运行，CM3的每指令周期数(CPI)也更低，于是同样的MHz下可以做更多的工作；另一方面，也使同一个应用在CM3上需要更低的主频。P32
这句话是不是说芯片刚启动是4MHZ，然后经过PLL倍频变为60M或者144MHZ？
先进的中断处理功能
内建的嵌套向量中断控制器支持多达240条外部中断输入。向量化的中断功能剧烈地缩短了中断延迟，因为不再需要软件去判断中断源。中断的嵌套也是在硬件水平上实现的，不需要软件代码来实现。怎么去体现粗体字，是不是指下面的东西
Cortex-M3在进入异常服务例程时，自动压栈了R0-R3, R12, LR, PSR和PC，并且在返回时自动弹出它们，这多清爽！既加速了中断的响应，也再不需要汇编语言代码了（第8章有详述）。
优化中断响应还有两招，它们分别是“咬尾中断机制”和“晚到中断机制”。
有些需要较多周期才能执行完的指令，是可以被中断－继续的——就好比它们是一串指令一样。这些指令包括加载多个寄存器（LDM），存储多个寄存器（STM），多个寄存器参与的PUSH，以及多个寄存器参与的POP。 这些不懂？？？
尽管PC的LSB总是0（因为代码至少是字对齐的），LR的LSB却是可读可写的。这是历史遗留的产物。在以前，由位0来指示ARM/Thumb状态。因为其它有些ARM处理器支持ARM和Thumb状态并存，为了方便汇编程序移植，CM3需要允许LSB可读可写。P38
上面这段是不是就解释了同页的
寄存器的PUSH和POP操作永远都是4字节对齐的——也就是说他们的地址必须是0x4,0x8,0xc,……。事实上，R13的最低两位被硬线连接到0,并且总是读出0（Read As Zero）。
如果向PC中写数据，就会引起一次程序的分支（但是不更新LR寄存器）。CM3中的指令至少是半字对齐的，所以PC的LSB总是读回0。然而，在分支时，无论是直接写PC的值还是使用分支指令，都必须保证加载到PC的数值是奇数（即LSB=1），用以表明这是在Thumb状态下执行。倘若写了0，则视为企图转入ARM模式，CM3将产生一个fault异常。
这句话又对上面的做了补充说明，粗体部分的原因是因为CM3还支持16位的指令
3.2.3 控制寄存器（CONTROL）的介绍
Ut-kernel里面只用了特权级和两种类型的堆栈，ut-kernel这方面设计得过于简单，使用户在编写应用程序时，竟然也可以访问特殊功能寄存器。给用户权限太大了。
代码依据：
Icrt0.s:
;;----------------------------------------------------------------------
;MSP setting
;;----------------------------------------------------------------------
mov r0, #0 ;MSP Effective ( privileged mode )
msr control, r0
isb ;It is necessary after control register is operated." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5b3b108a9aef3fe3e61306615705d22f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-26T17:56:42+08:00" />
<meta property="article:modified_time" content="2022-05-26T17:56:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">armcm3权威指南笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>CM3系列处理器优势：</p> 
<p>功耗低。延长了电池的寿命——这简直就是便携式设备的命门（如无线网络应用）</p> 
<p><strong>实时性好。采用了很前卫甚至革命性的设计理念，使它能极速地响应中断，而且响应中断所需的周期数是确定的</strong>。</p> 
<p><strong>代码密度得到很大改善（应用thumb指令？）。</strong>一方面力挺大型应用程序，另一方面为低成本设计而省吃俭用。</p> 
<p></p> 
<p><strong>降低成本还有一招，就是使基础代码在所有系统中都可以重用，至少要方便移植。</strong>CM3的内核架构非常精工细作，使它与C语言成为了一个梦幻绝配。优质的C程序代码三下五除二就可以移植并重用，使升级和移植一下子从拦路虎变成了纸老虎。</p> 
<p></p> 
<p>，CM3还突破性地引入了很多时尚的甚至崭新的技术，专门满足单片机应用程序的需求。比如，服务于“使命-关键”应用的不可屏蔽中断，极度敏捷并且拥有确定性的嵌套向量中断系统.</p> 
<p>P15和P16有关于cortex-m和cortex-a其他系列的比较，讲的比较好。</p> 
<p>还有关键的対实时系统的定义：</p> 
<p>通用处理器能否胜任实时系统的控制，常遭受质疑，并且在这方面的争论从没停止过。从定义的角度讲，“实时”就是指系统必须在给定的死线（deadline，亦称作“最后期限”）内做出响应。在一个以ARM处理器为核心的系统中，决定能否达到“实时”这个目标的，有很多因素，包括是否使用“实时操作系统”，中断延迟，存储器延时，以及当时处理器是否在运行更高优先级的中断服务例程。</p> 
<p></p> 
<p> MMU，存储器管理单元，用于实现虚拟内存和内存的分区保护，这是应用处理器与嵌入式处理器的分水岭。电脑和数码产品所使用的处理器几乎清一色地都带MMU。但是MMU也引入了不确定性，这有时是嵌入式领域——尤其是实时系统不可接受的。然而对于安全关键（safety-critical）的嵌入式系统，还是不能没有内存的分区保护的。为解决矛盾，<strong>于是就有了MPU。</strong>可以把MPU认为是MMU的功能子集，它只支持分区保护，不支持具有“定位决定性”的虚拟内存机制。</p> 
<p></p> 
<p>1.5 Cortex-M3处理器的舞台也比较有意思</p> 
<p></p> 
<p>当呼叫一个子程序时，由R14存储返回地址</p> 
<p>不像大多数其它处理器，<strong>ARM为了减少访问内存的次数（访问内存的操作往往要3个以上指令周期，带MMU和cache的就更加不确定了），把返回地址直接存储在寄存器中。这样足以使很多只有1级子程序调用的代码无需访问内存（堆栈内存），</strong>从而提高了子程序调用的效率。如果多于1级，则需要把前一级的R14值压到堆栈里。在ARM上编程时，应尽量只使用寄存器保存中间结果，迫不得以时才访问内存。</p> 
<p></p> 
<p>中断可屏蔽</p> 
<p>既可以屏蔽优先级低于某个阈值的中断/异常［译注8］(设置BASEPRI寄存器)，也可以全体封杀(设置PRIMASK和FAULTMASK寄存器)。这是为了让时间关键（time-critical）的任务能在死线Cortex-M3权威指南 第 2 章 27</p> 
<p>(deadline，或曰最后期限)到来前完成，而不被干扰。</p> 
<p></p> 
<p>Cortex-M3只使用Thumb-2指令集。这是个了不起的突破，因为它允许32位指令和16位指令水乳交融，代码密度与处理性能两手抓，两手都硬。而且虽然它很强大，却依然易于使用。</p> 
<p>在过去，做ARM开发必须处理好两个状态。这两个状态是井水不犯河水的，它们是：32位的ARM状态和16位的Thumb状态。<strong>当处理器在ARM状态下时，所有的指令均是32位的（哪怕只是个”NOP”指令），此时性能相当高</strong>。而<strong>在Thumb状态下，所有的指令均是16位的，代码密度提高了一倍</strong>。不过，thumb状态下的指令功能只是ARM下的一个子集，<strong>结果可能需要更多条的指令去完成相同的工作，导致处理性能下降</strong>。</p> 
<p></p> 
<p>事实上，<strong>Cortex-M3内核干脆都不支持ARM指令</strong>，中断也在Thumb态下处理（以前的ARM总是在ARM状态下处理所有的中断和异常）。这可不是小便宜，它使CM3在好几个方面都比传统的ARM处理器更先进</p> 
<p>因为CM3专情于最新的Thumb-2，旧的应用程序需要移植和重建。对于大多数C源程序，只需简单地重新编译就能重建，汇编代码则可能需要大面积地修改和重写，才能使用CM3的新功能，并且融入CM3新引入的统一汇编器框架(unified assembler framework)中。</p> 
<p></p> 
<p><span style="color:#000000;"> </span></p> 
<p>Cortex-M3的设计允许单片机高频运行（现代半导体制造技术能保证100MHz以上的速度）。即使在相同的速度下运行，CM3的每指令周期数(CPI)也更低，于是同样的MHz下可以做更多的工作；另一方面，也使同一个应用在CM3上需要更低的主频。P32</p> 
<p>这句话是不是说芯片刚启动是4MHZ，然后经过PLL倍频变为60M或者144MHZ？</p> 
<p>先进的中断处理功能</p> 
<p>内建的嵌套向量中断控制器支持多达240条外部中断输入。向量化的中断功能剧烈地缩短了中断延迟，因为不再需要软件去判断中断源。<strong>中断的嵌套也是在硬件水平上实现的，不需要软件代码来实现</strong>。怎么去体现粗体字，是不是指下面的东西</p> 
<p>Cortex-M3在进入异常服务例程时，自动压栈了R0-R3, R12, LR, PSR和PC，并且在返回时自动弹出它们，这多清爽！既加速了中断的响应，也再不需要汇编语言代码了（第8章有详述）。</p> 
<p></p> 
<p>优化中断响应还有两招，它们分别是“咬尾中断机制”和“晚到中断机制”。</p> 
<p></p> 
<p>有些需要较多周期才能执行完的指令，是可以被中断－继续的——就好比它们是一串指令一样。这些指令包括加载多个寄存器（LDM），存储多个寄存器（STM），多个寄存器参与的PUSH，以及多个寄存器参与的POP。 这些不懂？？？</p> 
<p>尽管PC的LSB总是0（因为代码至少是字对齐的），LR的LSB却是可读可写的。这是历史遗留的产物。在以前，由位0来指示ARM/Thumb状态。因为其它有些ARM处理器支持ARM和Thumb状态并存，为了方便汇编程序移植，CM3需要允许LSB可读可写。P38</p> 
<p>上面这段是不是就解释了同页的</p> 
<p>寄存器的PUSH和POP操作永远都是4字节对齐的——也就是说他们的地址必须是0x4,0x8,0xc,……。事实上，R13的最低两位被硬线连接到0,并且总是读出0（Read As Zero）。</p> 
<p> </p> 
<p>如果向PC中写数据，就会引起一次程序的分支（但是不更新LR寄存器）。<strong>CM3中的指令至少是半字对齐的，所以PC的LSB总是读回0</strong><strong>。</strong>然而，在分支时，无论是直接写PC的值还是使用分支指令，都必须保证加载到PC的数值是奇数（即LSB=1），用以表明这是在Thumb状态下执行。倘若写了0，则视为企图转入ARM模式，CM3将产生一个fault异常。</p> 
<p>这句话又对上面的做了补充说明，粗体部分的原因是因为CM3还支持16位的指令</p> 
<p></p> 
<p></p> 
<p><strong>3.2.3 </strong>控制寄存器（<strong>CONTROL</strong>）的介绍</p> 
<p><strong>Ut-kernel里面只用了特权级和两种类型的堆栈，ut-kernel这方面设计得过于简单，使用户在编写应用程序时，竟然也可以访问特殊功能寄存器。给用户权限太大了。</strong></p> 
<p>代码依据：</p> 
<p>Icrt0.s:</p> 
<p>       ;;----------------------------------------------------------------------</p> 
<p>       ;MSP setting</p> 
<p>       ;;----------------------------------------------------------------------</p> 
<p>       mov r0, #0                         ;MSP Effective ( privileged mode )</p> 
<p>       msr  control, r0</p> 
<p>       isb                     ;It is necessary after control register is operated.</p> 
<p>       </p> 
<p>       ldr   r0, =_kernel_MSP_stack_top</p> 
<p>       msr  msp, r0</p> 
<p>特权级和用户级主要是限定了不同的寄存器访问权限，有些特殊功能寄存器只能在用户级才能访问</p> 
<p>Ut-kernel的usetrap功能好像就是针对这方面的。</p> 
<p>当处理器处在线程状态下时，既可以使用特权级，也可以使用用户级；另一方面，handler模式总是特权级的。<strong>在复位后，处理器进入线程模式＋特权级</strong>。</p> 
<p><strong>在线程模式＋用户级下，对系统控制空间（SCS）的访问将被阻止——该空间包含了配置寄存器组以及调试组件的寄存器组</strong>。除此之外，还禁止使用MRS/MSR访问刚才讲到的，除了APSR之外的特殊功能寄存器。如果以身试法，则对于访问特殊功能寄存器的，访问操作被忽略；而对于访问SCS空间的，将fault伺候。</p> 
<p>在<strong>特权级下的代码可以通过置位</strong><strong>CONTROL[0]来进入用户级。而不管是任何原因产生了任何异常，处理器都将以特权级来运行其服务例程</strong>，<strong>异常返回后，系统将回到产生异常时所处的级别</strong>。<strong>用户级下的代码不能再试图修改</strong><strong>CONTROL[0]来回到特权级。它必须通过一个异常handler，由那个异常handler来修改CONTROL[0]，才能在返回到线程模式后拿到特权级(用户级的代码怎样拿到特权级)。</strong>P41</p> 
<p> </p> 
<p>还有P42也是对上面的讲得做更进一步地补充说明，感觉这方面还得仔细看看，<strong>结合着本项目组之前做的FM3 reference代码移植中usetrap讨论，还得看看</strong></p> 
<p> </p> 
<p>Ut-kernel中判断是否在中断上下文还是任务上下文是通过knl_isTaskIndependent内联函数来判断的，它调用knl_get_stack_mode_impl，这个又是汇编函数的形式实现，通过写R0寄存器带回函数返回值为control寄存器的值，然后通过判断是MSP还是PSP模式来判断是否是中断或者任务上下文的。</p> 
<p><strong>下面这段貌似也跟我们组的usetrap问题讨论相关：</strong></p> 
<p>由CM3的中断优先级模型可知，我们不能在SVC服务例程中嵌套使用SVC指令（事实上这样做也没意义），因为同优先级的异常不能抢占自身。这种作法会产生一个用法fault。同理，在NMI服务例程中也不得使用SVC，否则将触发硬fault。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p><strong>伪指令概念：</strong></p> 
<p><strong>32位指令MOVW和MOVT可以支持16位立即数加载。</strong></p> 
<p><strong>那要加载32位立即数怎么办呢？如果要直来直去，当前是要用两条指令来完成了</strong>。通过组合使用MOVW和MOVT就能产生32位立即数，但是要注意，必须先使用MOVW，再使用MOVT。这种顺序是不能颠倒的，因为MOVW会清零高16位。</p> 
<p>不过，更流行的是另一种方法：使用<strong>汇编器提供的”LDR Rd, = imm32”伪指令。</strong>例如：</p> 
<p>LDR, r0, =0x12345678</p> 
<p>酷吧！它的名字也是LDR，而且能加载32位立即数！但可别忘了，<strong>它是伪指令</strong>，是“妖怪变的”，而且有若干种原形。所以不要因为名字相同就混淆。</p> 
<p>大多数情况下，当汇编器遇到LDR伪指令时，都会把它转换成一条相对于PC的加载指令，来产生需要的数据。。大可依赖汇编器，它会明智地使用最合适的形式来实现该伪指令。</p> 
<p>P62 <strong>LDR</strong>伪指令<strong>vs. ADR</strong>伪指令比较也比较有意思。</p> 
<p><strong>ISB指令的运用</strong></p> 
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;"> <p>ISB</p> </td><td style="vertical-align:top;"> <p>指令同步隔离。最严格：它会清洗流水线，以保证所有它前面的指令都执行完毕之后，才执行它后面的指令。 P72</p> </td></tr></tbody></table> 
<p></p> 
<p>       ;MSP setting</p> 
<p>       ;;----------------------------------------------------------------------</p> 
<p>       mov r0, #0                         ;MSP Effective ( privileged mode )</p> 
<p>       msr  control, r0</p> 
<p>       isb                     ;It is necessary after control register is operated</p> 
<p> </p> 
<p><strong><span style="color:#000000;">位带区的作用：</span></strong></p> 
<p>。位带操作只适用于数据访问，不适用于取指。通过位带的功能，可以把多个布尔型数据打包在单一的字中，却依然可以从位带别名区中，像访问普通内存一样地使用它们。位带别名区中的访问操作是原子的，消灭了传统的“读－改－写”三步曲。P84</p> 
<p></p> 
<p><span style="color:#000000;">CM3</span><span style="color:#000000;">中可支持非对齐数据传送，</span></p> 
<p><span style="color:#000000;">CM3</span><span style="color:#000000;">支持在单一的访问中使用非（地址）对齐的传送，数据存储器的访问无需对齐。在以前，</span><strong><span style="color:#000000;">ARM</span><span style="color:#000000;">处理器只允许对齐的数据传送</span></strong><span style="color:#000000;">。这种对齐是说：<strong>以字为单位的传送，其地址的最低两位必须是</strong></span><strong><span style="color:#000000;">0</span></strong><span style="color:#000000;">；<strong>以半字为单位的传送，其地址的</strong></span><strong><span style="color:#000000;">LSB</span><span style="color:#000000;">必须是</span><span style="color:#000000;">0</span></strong><span style="color:#000000;">；以字节为单位的传送则无所谓对不对齐。<strong>如果使用</strong></span><strong><span style="color:#000000;">0x1001,0x1002</span><span style="color:#000000;">或</span><span style="color:#000000;">0x1003</span><span style="color:#000000;">这样的地址做字传送</span></strong><span style="color:#000000;">，<strong>在以前的</strong></span><strong><span style="color:#000000;">ARM</span><span style="color:#000000;">处理器中则会触发一个数据流产（</span><span style="color:#000000;">Data abort</span><span style="color:#000000;">）异常</span><span style="color:#000000;">——</span><span style="color:#000000;">与</span><span style="color:#000000;">CM3</span><span style="color:#000000;">中总线</span><span style="color:#000000;">fault</span><span style="color:#000000;">异常的作用相同</span></strong><span style="color:#000000;">。</span></p> 
<p><span style="color:#000000;">在</span><span style="color:#000000;">CM3</span><span style="color:#000000;">中，<strong>非对齐的数据传送只发生在常规的数据传送指令中，如</strong></span><strong><span style="color:#000000;">LDR/LDRH/LDRSH</span><span style="color:#000000;">（刚好这些指令也是伪指令吧）。其它指令则不支持</span></strong></p> 
<p><span style="color:#000000;"> </span></p> 
<p><span style="color:#000000;">但是最好：</span></p> 
<p><span style="color:#000000;">事实上，<strong>节省内存有很多方法</strong>，但没有一个是通过压缩数据的地址，不惜破坏对齐性的这种旁门左道。因此，应养成好习惯，总是<strong>保证地址对齐，这也是让程序可以移植到其它</strong></span><strong><span style="color:#000000;">ARM</span><span style="color:#000000;">芯片上的必要条件</span></strong><span style="color:#000000;">。</span></p> 
<p><span style="color:#000000;">为此，<strong>可以编程</strong></span><strong><span style="color:#000000;">NVIC</span><span style="color:#000000;">，使之监督地址对齐</span></strong><span style="color:#000000;">。当发现非对齐访问时触发一个</span><span style="color:#000000;">fault</span><span style="color:#000000;">。具体的办法是设置</span><strong><span style="color:#000000;">“</span><span style="color:#000000;">配置控制寄存器</span><span style="color:#000000;">”</span><span style="color:#000000;">中的</span><span style="color:#000000;">UNALIGN_TRP</span><span style="color:#000000;">位</span></strong><span style="color:#000000;">。这样，在整个调试期间就可以保证非对齐访问能当场被发现。</span></p> 
<p>.</p> 
<p>还有对Pendsv的理解，</p> 
<p>另一个相关的异常是PendSV（可悬起的系统调用），它和SVC协同使用。一方面，<strong>SVC异常是必须在执行SVC指令后立即得到响应的</strong>（对于SVC异常来说，若<strong>因优先级不比当前正处理的高</strong>，或是其它原因使之无法立即响应，将上访成硬fault译者注），<strong>应用程序执行</strong><strong>SVC时都是希望所需的请求立即得到响应</strong>。另一方面，PendSV则不同，它是可以像普通的中断一样被悬起的（不像SVC那样会上访）。OS可以利用它“缓期执行”一个异常直到<strong>其它重要的任务</strong>完成后才执行动作。悬起PendSV的方法是：手工往NVIC的PendSV悬起寄存器中写1。悬起后，如果<strong>优先级不够高，则将缓期等待执行</strong>。P125，至于代码具体对应knl_dispatch_request函数</p> 
<p>然后下面讲述的pendsv的应用实例。</p> 
<p>应用时，<strong>需要把</strong><strong>PendSV编程为最低优先级的异常</strong></p> 
<p>我觉得ut-kernel中pendsv中断是做任务切换工作的。具体为什么<strong>ut-kernel中用pendsv，</strong></p> 
<p><strong>1是因为确实推迟任务切换的执行，直到ut-kernel API执行完END_CRITICAL_SECTION;后才会有可能启动pendsv执行。</strong></p> 
<p><strong>另外一方面也是由于在执行完END_CRITICAL_SECTION;如果此时有其他优先级更高的中断到来，则优先执行其他优先级更高的中断，执行完后再执行pendsv进行任务切换。</strong></p> 
<p> </p> 
<p>但若在产生SysTick异常时正在响应一个中断，则SysTick异常会抢占其ISR。在这种情况下，OS是不能执行上下文切换的，否则将使中断请求被延迟，而且在真实系统中延迟时间还往往不可预知任何有一丁点实时要求的系统都决不能容忍这种事。因此，在CM3中也是严禁没商量如果OS在某中断活跃时尝试切入线程模式，将触犯用法fault异常。</p> 
<p><strong>以下是我对上面文字的解释：</strong></p> 
<p>这段话中首先执行个用户实时中断，然后被SysTick异常打断，SysTick异常中会去进行任务切换，等切换回来发现之前被systick打断的那个中断竟然延迟这么长时间去执行（主要是有个任务切换的时间算在内了）。</p> 
<p>这段话说明如果任务切花不交给pendsv去做的话，结果在真实系统中这种用户实时中断被延迟时间还往往不可预知。任何有一丁点实时要求的系统都决不能容忍这种事。所以最好交给</p> 
<p>Pendsv去做。</p> 
<p>另外上面这种特例在CM3中会自动触发fault异常。</p> 
<p>原文这样说的：</p> 
<p>在CM3中也是严禁没商量如果OS在某中断活跃时尝试切入线程模式，将触犯用法fault异常。</p> 
<p><strong>中断活跃怎么理解：</strong></p> 
<p>每个外部中断都有一个活动状态位。<strong>在处理器执行了其</strong><strong>ISR的第一条指令后，它的活动位就被置1，并且直到ISR返回时才硬件清零</strong>。由于支持嵌套，允许高优先级异常抢占某个ISR。然而，<strong>哪怕中断被抢占，其活动状态也依然为</strong><strong>1</strong>（请仔细琢磨前文讲到的“直到ISR返回时才清零）</p> 
<p> </p> 
<p>下面文字：</p> 
<p><strong>如果中断发生时，正在处理同级或高优先级异常，或者被掩蔽，则中断不能立即得到响应。此时中断被悬起。P130</strong></p> 
<p> 让我想起代码中：</p> 
<p>SYSCALL ID tk_cre_mpl_impl( T_CMPL *pk_cmpl )</p> 
<p>{<!-- --></p> 
<p>BEGIN_CRITICAL_SECTION;</p> 
<p>A;</p> 
<p>END_CRITICAL_SECTION;</p> 
<p>}</p> 
<p><strong>A在执行中，如果发生systick，则被悬起暂不执行，等到执行完END_CRITICAL_SECTION;</strong></p> 
<p><strong>先执行systick，后执行Pendsv。</strong></p> 
<p><strong>不过END_CRITICAL_SECTION后，不一定就打开中断了，它只是恢复</strong>BEGIN_CRITICAL_SECTION;之前的中断状态。</p> 
<p></p> 
<p><strong>中断系统设置全过程的演示</strong></p> 
<p>P135还做了CM3上怎么建立中断，使中断发挥作用。</p> 
<p></p> 
<p>看过下面确认：</p> 
<p>MSP和PSP是两个不同的寄存器。</p> 
<p>在入栈和取向量操作完成之后，执行服务例程之前，还要更新一系列的寄存器：</p> 
<p>l SP：在入栈后会把堆栈指针（PSP或MSP）更新到新的位置。在执行服务例程时，将由MSP负责对堆栈的访问。</p> 
<p></p> 
<p>嵌套的中断P144</p> 
<p>然而，有一件事情却必须更加一丝不苟地处理了，否则有功能紊乱甚至死机的危险。<strong>这就是计算主堆栈容量的最小安全值。我们已经知道，所有服务例程都只使用主堆栈。所以当中断嵌套加深时，对主堆栈的压力会增大</strong>：每嵌套一级，就至少再需要8个字，即32字节的堆栈空间而且这还没算上ISR对堆栈的额外需求，并且何时嵌套多少级也是不可预料的。如果主堆栈的容量本来就已经所剩无几了，中断嵌套又突然加深，则主堆栈有被用穿的凶险</p> 
<p></p> 
<p>另一个要注意的，是<strong>相同的异常是不允许重入的。</strong>因为<strong>每个异常都有自己的优先级，并且在异常处理期间，同级或低优先级的异常是要阻塞的</strong>。因此对于同一个异常，只有在上次实例的服务例程执行完毕后，方可继续响应新的请求。由此可知，<strong>在SVC服务例程中，就不得再使用SVC指令，否则将fault伺候。</strong></p> 
<p>我们组usetrap那个讨论好像也是针对这个的。</p> 
<p>Armcm3通过<strong>9.4</strong>咬尾中断和<strong>9.5</strong>晚到（的高优先级）异常来加快中断的响应。P145</p> 
<p>Cm3主要是为了做实时系统来的。</p> 
<p>在设计实时系统时，<strong>必须对中断延迟进行严肃和仔细地估算</strong>。在这里，中断延迟的定义是：从检测到某中断请求，到执行了其服务例程的第一条指令时，已经流逝了的时间。在CM3中，若存储器系统够快，且总线系统允许入栈与取指同时进行，同时该中断可以立即响应，则<strong>中断延迟是雷打不动的12周期（满足硬实时所要求的确定性）。</strong>在与时间赛跑的这12个周期里，处理器内部一直开足马力，进行了入栈、取向量、更新寄存器以及服务例程取指的一系列操作。但若存储器太慢以至于引入等待周期，或者还有其它因素，则会引入额外的延时反正如果有拖后腿的，<strong>那绝不可能是CM3内核</strong>。P148</p> 
<p></p> 
<p><strong>为了加快中断响应，</strong></p> 
<p>有些指令需要较多的周期才能完成。它们是除法指令，双字传送指令LDRD/STRD以及多重数据传送指令(LDM/STM)。</p> 
<p>对于除法指令,双字传送指令LDRD/STRDCM3,将为了保证中断及时响应而取消它们的执行，待返回后重新开始这牺牲了一点性能，以及某些子程序的一点个人利益，但换来了对意外事件的更快救援。</p> 
<p>对于LDM/STM，则有另外的处理方式。因为它们<strong>不照前两者那么浑然一体它们其实是一串LDR/STR的速度优化版</strong>。于是，为了加速中断的响应，<strong>CM3支持LDM/STM指令的中止和继续，就好像它们只是普通的一串LDR/STR一样。</strong>为了实现“指令撕裂与粘合”的目的，需要记录中断时数据传送的进程。为此，CM3在xPSR中开出若干个“ICI位”，记录下一个即将传送的寄存器是哪一个（LDM/STM在汇编时，都把寄存器号升序排序）。在<strong>服务例程返回后，xPSR被弹出，CM3再从ICI bits中获取当时LDM/STM执行的进度，从而可以继续传送</strong>。</p> 
<p><strong>LDR/STR为伪指令？</strong></p> 
<p><strong> </strong></p> 
<p>当<strong>多个中断同时请求时，也会发生中断延迟</strong>，这<strong>表现在只有优先级最高的得到立即响应，所有其它的中断将被延迟</strong>。另外，在中断嵌套时，每个中断都会阻塞同级和低优先级的中断。最后，<strong>如果中断被掩蔽（也就是俗称的关中，在多任务系统下满地都有），则在掩蔽期间也会附加中断延迟。</strong></p> 
<p><strong>最后一句话更加验证了本文档P6中的ut-kernel中对Pendsv中断的运用之我理解</strong></p> 
<p><strong> </strong></p> 
<p><strong>ARM编程规范吧，为了更好地利用硬件的特性</strong></p> 
<p>不过，在大多数场合下的情况都比较简单：当主调函数需要传递参数（实参）时，它们使用R0-R3。其中R0传递第一个，R1传递第2个……在返回时，把返回值写到R0中。在子程序中，可以随心所欲Cortex-M3权威指南 第 10 章 153</p> 
<p>地使用R0-R3，以及R12（回顾第9章，想想为什么会PUSH它们）。<strong>但若使用R4-R11，则必须在使用之前先PUSH它们，使用后POP回来。</strong></p> 
<p><strong>10.4 </strong>第一步工作</p> 
<p>而且实际上，开发工具几乎都会把启动工作做好，让我们根本不用去想还有启动代码的事（不过，这也妨碍了我们学习得更深入）。P153最下面</p> 
<p><strong>上文说的意思是一般各个开发工具自带的库和示例程序已经包含了启动代码及其他设置硬件的代码，框架有些都有了，不需要我们再写了。</strong></p> 
<p><strong> </strong></p> 
<p><strong>10.4中这个小代码示例的编译链接选项配置使我想起了MDK环境下的CMSIS测试工作，不管MDK开发环境如何复杂，其实最后传到命令行里面的还是这些基本选项。只是--rw_base 0x20000000 --ro_base 0x0这些选项可以换成scatfile的形式进行link。</strong></p> 
<p>如果想要看看生成的映像是否确实是我们想要的，还可以像这样对它做反汇编：</p> 
<p>$&gt; fromelf -c --output test1.list test1.elf</p> 
<p><strong>一般各个开发工具（keil, IAR, DS-4）中都带相应的反汇编工具的。</strong></p> 
<p></p> 
<p><strong>使用位带实现互斥锁操作</strong></p> 
<p><strong>潜在BUG</strong></p> 
<p><strong><span style="color:#000000;">如果把向量表重定位到了RAM</span>中，且这块RAM所在的存储器区域是写缓冲的，向量更新就可能被延迟</strong></p> 
<p><strong><span style="color:#000000;">为了以防万一，必须在建立完所有向量后追加一条“数据同步隔离(DSB)</span>”指令（见第4章），以等待缓冲写入后再继续，从而确保所有数据都已落实。</strong></p> 
<p><span style="color:#000000;">Cortex-M3 </span><span style="color:#000000;">权威指南 第</span><span style="color:#000000;">11</span><span style="color:#000000;">章</span><span style="color:#000000;">168</span></p> 
<p><span style="color:#000000;"> </span></p> 
<p><strong>中断服务程序的返回使用指令：</strong></p> 
<p>这里的服务例程都是使用BX LR返回的，但是真到了写程序时，往往利用POP ｛…,PC｝的形式来使程序更精练（当然也可以使用LDMIA指令）。</p> 
<p></p> 
<p><strong>P171d的指令DSB ;数据同步隔离运用。</strong></p> 
<p></p> 
<p><strong>我觉得像P174中那些TST，ITE，MRSEQ，MRSNE指令的灵活运用下来</strong><strong>我还得开辟一个章节，好好研究下这些指令的变形，应用</strong><strong>。</strong></p> 
<p><strong>下面让我对指令中的立即数提取有了一定认识：</strong></p> 
<p>LDRB R0, [R1,#-2] ; 从SVC指令中读取立即数放到R0</p> 
<p><strong>好像前面一些章节中说指令中存取16位立即数，指令必须为32位；存取8位立即数，指令可以为16位。</strong></p> 
<p>还有：</p> 
<p>LDR R1, [R0,#24] ;从栈中读取PC的值</p> 
<p>因为中断响应时，硬件压入栈中的寄存器多少长度都是固定的，所以可以算出PC的偏移量。</p> 
<p>Ut-kernel中有关于svc_handler的代码实现，写的还不错。</p> 
<p></p> 
<p>在前面的例子中，我们写了若干个函数用于输出。但是有的时候，可能有一些障碍，使得我们不能用BL指令。例如，<strong>需要调用的函数是在另外的目标文件中，这就会导致有的时候我们无法定位子程序的入口地址</strong>；另外，<strong>如果跳转的目的地太远，也有诸多不便</strong>；或者，<strong>当使用OS时，这些输出函数已经被OS包装成系统调用了</strong>。在这些场合下，我们就需要使用SVC来作为传送门，如下面示例代码所示：</p> 
<p><strong>上面这一句话是不是告诉我BL指令的使用限制，跳转太远的就不能使用BL指令吧。这里面提出来用SVC传送门来处理这个问题。下来再看下这几个跳转指令的差异问题</strong></p> 
<p><strong> </strong></p> 
<p>P175那个代码中的</p> 
<p>LDR R0, [R1,#0] ; 从堆栈中读取R0的值，此处R1应该改为R0</p> 
<p>还有为什么这个地方还要从栈中取出R0值，为什么不直接读R0寄存器，因为晚到中断的缘故</p> 
<p>可见同页最下面的那段叙述</p> 
<p></p> 
<p>PUSH {LR} ; 保护LR的值，因为后面将使用的BL指令</p> 
<p><strong>是因为下面的第二段的话：</strong></p> 
<p><strong> </strong></p> 
<p><span style="color:#000000;">最基本的无条件跳转指令有两条： </span></p> 
<p><span style="color:#000000;">B Label ;</span><span style="color:#000000;">跳转到</span><span style="color:#000000;">Label</span><span style="color:#000000;">处对应的地址</span></p> 
<p><span style="color:#000000;">BX reg ;</span><span style="color:#000000;">跳转到由寄存器</span><span style="color:#000000;">reg</span><span style="color:#000000;">给出的地址</span></p> 
<p><span style="color:#000000;">在</span><span style="color:#000000;">BX</span><span style="color:#000000;">中，</span><span style="color:#000000;">reg</span><span style="color:#000000;">的最低位指示出在转移后将进入的状态：是</span><span style="color:#000000;">ARM(LSB=0)</span><span style="color:#000000;">呢，还是</span><span style="color:#000000;">Thumb(LSB=1)</span><span style="color:#000000;">。<strong>既然</strong></span><strong><span style="color:#000000;">CM3</span><span style="color:#000000;">只在</span><span style="color:#000000;">Thumb</span><span style="color:#000000;">中运行，就必须保证</span><span style="color:#000000;">reg</span><span style="color:#000000;">的</span><span style="color:#000000;">LSB=1</span><span style="color:#000000;">，否则一个</span><span style="color:#000000;">fault</span><span style="color:#000000;">打过来。</span></strong></p> 
<p><strong>ARM的fault。P69</strong></p> 
<p><strong> </strong></p> 
<p>有心的读者可能已经发现，<strong>ARM的BL虽然省去了耗时的访内操作，却只能支持一级子程序调用。如果子程序再呼叫“孙程序”，则返回地址会被覆盖。因此当函数嵌套多于一级时，必须在调用“孙程序”之前先把LR压入堆栈也就是所谓的“溅出</strong>”。</p> 
<p>BL常用在函数调用中，调用函数用BL，然后函数里面最后一条指令 BX LR直接进行调用返回。</p> 
<p></p> 
<p>编程技巧：善用LDR/STR中的多种寻址方式P176更加告诉我们熟悉指令使用，精简指令条数。这个回去有空可以再看看，想想ARM中那些灵活使用的指令。</p> 
<p></p> 
<p></p> 
<p></p> 
<p><strong>P183，最下面那个程序告诉我们用PC值和正确的栈指针（栈上保存了一个可执行任务的上下文环境，设置正确的栈指针代表把栈指针挪到当时PC值对应的正确地当时上下文环境）就能把程序切换到正确的地方。</strong></p> 
<p><strong> </strong></p> 
<p>第二，如果没有必要，中断向量表也放到代码区中。只有这样，才能使取向量(I-Code总线)与入栈(System总线)同时进行。如果向量表在RAM中，就会出现取向量与入栈抢总线的情况，必然导致额外的中断延迟被引入（当然在极个别情况下，如果把SRAM放到Code区，则使用D-Code总线入栈。但如果就为了放向量表而专配一个SRAM，代价未免也太大了）。</p> 
<p><strong>上面说明了哈佛结构的性能优化。</strong></p> 
<p><strong> </strong></p> 
<p><strong> </strong></p> 
<p><strong> </strong></p> 
<p>第三、限制使用非对齐访问。前面讲到，CM3总线内部其实只接受对齐访问，而由总线接口来堵窟窿：把一个非对齐的访问拆成若干个对齐的访问，来实现这种透明性。可见，一次非对齐访问可能要数次对齐访问才能完成（最坏情况下3次）。而且节省内存的正道，在于优良的程序结构和算法设计，从来不在这种见缝插针地乱挤上。除非是客观上被定死的（常见于某些早期网络协议的报文头部），否则应在心里暗下决心：决不染指非对齐访问，在设计数据结构及定义变量时，都高度自觉。在ARM汇编器中，提供了ALIGN指示字（GNU AS中也有类似的汇率器指示字），可以保证产生所需的对齐方式。</p> 
<p><strong>回去查下关于arm 对齐访问方面的东西，这里面有很多料，甚至涉及到RISC和CISC设计思想的不同。</strong></p> 
<p></p> 
<p><strong>CM3</strong>中一些前卫的指令</p> 
<p><strong>IF-THEN指令P75</strong></p> 
<p>IT&lt;x&gt;&lt;y&gt;&lt;z&gt; &lt;cond&gt; ;围起4条指令的IF-THEN块</p> 
<p>其中&lt;x&gt;, &lt;y&gt;, &lt;z&gt;的取值可以是“T”或者“E”。</p> 
<p>CMP R0, R1 ; 比较R0和R1</p> 
<p><strong>ITTEE EQ ;如果R0 == R1, Then-Then-Else-Else</strong></p> 
<p>ADDEQ R3, R4, R5 ; 相等时加法</p> 
<p>ASREQ R3, R3, #1 ; 相等时算术右移</p> 
<p>ADDNE R3, R6, R7 ; 不等时加法</p> 
<p>ASRNE R3, R3, #1 ; 不等时算术右移</p> 
<p></p> 
<p><strong>Then-Then-Else-Else意思为下面4条指令前两条为if then块中的语句，后两条为 else块中的语句。</strong></p> 
<p><strong>P158，174也有它的使用方式</strong></p> 
<p><strong> </strong></p> 
<p><strong>cpu如果被锁定，则比较危险了。P186</strong></p> 
<p>在锁定下，寄存器和存储器都被“冻结”，PC的值被强制为0xFFFF_FFFx，并且原地打转地定死在那里一直取指</p> 
<p></p> 
<p><strong>如何避免被锁定：</strong></p> 
<p>简化硬fault和NMI的服务例程确实是个好主意：它们只做必需的，然后悬起PendSV，让诸如错误报告等其它工作在PendSV中处理，当然，软件中断兴许也能凑和着用。</p> 
<p>除此之外，我们<strong>还必须杜绝在硬NMI/fault例程中使用SVC指令，这</strong>也是斩立决的因为SVC的优先级总是没有NMI和硬fault的高，而且它又不允许悬起（悬起时触发fault）</p> 
<p>。而对于<strong>硬</strong><strong>fault来说，有可能就是因为SP指针指飞了（干扰、堆栈溢出等），以致前面的堆栈操作触发了本次硬fault，再操作堆栈还不当场被秒杀？</strong>如下面代码所警示：</p> 
<p>hard_fault_handler </p> 
<p>PUSH {R4-R7,LR}; 除非确保堆栈是安全可用的（谁能确保？），否则不要这样做</p> 
<p>...</p> 
<p>值此危难关头，必<strong>须沉着冷静。在我们设计硬fault，总线fault以及存储管理fault的服务例程时，值得先花点工夫去查一查SP的值，看它是否在可接受的范</strong>围，然后再做后续工作。对于NMI服务例程来说，它做的通常是应急工作，设计系统时就应该让这种应急工作极简单（比如，只改变一个I/O脚的电平，最多也就是修改若干寄存器的值，就可以开启相关的应急硬件译者注）<strong>，因此常常可以只使用R0-R3以及R12就完全够用，无需堆栈操作。</strong></p> 
<p></p> 
<p><strong>程序出错产生异常时的故障调查分析：</strong></p> 
<p>二、产生异常时：</p> 
<p></p> 
<p></p> 
<p></p> 
<p>1、有一个压栈的过程，产生异常时使用PSP，就压入到PSP中，产生异常时使用MSP，就压入到MSP中</p> 
<p></p> 
<p>2、会根据处理器的模式和使用的堆栈，设置LR的值（当然设置完的LR的值再压栈）</p> 
<p>三、异常返回时：</p> 
<p></p> 
<p>根据LR的值，判读使用那个堆栈，然后再从相应的堆栈中POP数据到寄存器。</p> 
<p></p> 
<p></p> 
<p></p> 
<p>举例说明：</p> 
<p></p> 
<p>在利用OSStartHighRdy-&gt;OSPendSV-&gt;OSPendSV_nosave启动第一个线程时，在异常进入的时候，压栈到MSP（不会影响PSP的内容），在<strong>通过BX      LR指令从异常返回之前，有一句ORR     LR, LR, #0x04来设置LR的值，保证我们从异常返回时是从PSP中POP数据到寄存器里，</strong>而此时PSP的值是OSTCBHighRdy-&gt;OSTCBStkPtr，即任务创建时定义的堆栈数组，同时在OSTaskStkInit函数中对该任务数组初始化时，要保证其组织结构和异常产生时处理器自动压栈产生的栈的结构相同。</p> 
<p><strong>由于异常死机了之后的具体操作：</strong></p> 
<p></p> 
<p></p> 
<p></p> 
<p>产生异常时，两个值我们需要，一个是pc，一个是LR，<strong>通过LR找到栈，再通过栈找到pc（调查ARM下程序故障的原因方法）</strong></p> 
<p></p> 
<p>1、如果<strong>LR=0xFFFFFFF9说明产生异常的时候使用的是MSP，我们只需要读出当前sp的值，</strong></p> 
<p><strong> </strong></p> 
<p><strong>sp  += 0x1c;</strong><strong>读出的内容就是产生异常时压入栈的PC的值，这个值跟反汇编代码对比，就能得到具体哪句话产生的异常。</strong></p> 
<p></p> 
<p>2、如果LR=0xFFFFFFFD明产生异常的时候使用的是PSP，我们需要读出PSP的值，不要直接来读sp的值，在keil集成开发环境中，调试时寄存器窗口有个Banked选项，会给出当前PSP的值，当然也可以在异常处理中加入两句话：</p> 
<p></p> 
<p>MRS        R0,PSP</p> 
<p></p> 
<p>PUSH             {R0}</p> 
<p></p> 
<p><strong>我们就能在当前MSP中得到,我们PSP的值了，之后操作和上面一样，psp+=0x1c;读出的内容就是产生异常时压入栈的PC的值，这</strong>个值跟反汇编代码对比，就能得到具体哪句话产生的异常。</p> 
<p></p> 
<p>注意：如果启用了堆栈的双字对齐特性，但是SP却没能对齐到双字，则堆栈帧的顶部有可能从((OLD_SP-4) AND 0xFFFF_FFF8)处开始，且其余的内容被向下错位一个字 P301</p> 
<p>  </p> 
<p><span style="color:#000000;">CM3</span><span style="color:#000000;">中有许多新特性，加以利用的话常常可以大大提高程序的性能，或者降低对存储器的使用。对于积极向上的我们，一定要挖掘这些特性：P251</span></p> 
<p><span style="color:#000000;">l </span><span style="color:#000000;">使用</span><strong><span style="color:#000000;">32</span></strong><span style="color:#000000;">位</span><strong><span style="color:#000000;">Thumb-2</span></strong><span style="color:#000000;">指令</span><span style="color:#000000;">：对于下列的场合<strong>：先使用一条</strong></span><strong><span style="color:#000000;">16</span><span style="color:#000000;">位</span><span style="color:#000000;">thumb</span><span style="color:#000000;">指令把数据从一个寄存器传送到另一个，再对该数据执行数据处理</span></strong><span style="color:#000000;">。<strong>有时能使用一条</strong></span><strong><span style="color:#000000;">Thumb-2</span><span style="color:#000000;">指令来完</span></strong><span style="color:#000000;">成（这主要是因为</span><span style="color:#000000;">16</span><span style="color:#000000;">位</span><span style="color:#000000;">Thumb</span><span style="color:#000000;">指令不能使用</span><span style="color:#000000;">“</span><span style="color:#000000;">高寄存器</span><span style="color:#000000;">”</span><span style="color:#000000;">——</span><span style="color:#000000;">译者注），从而使所需的处理时间缩短。</span></p> 
<p><span style="color:#000000;"> </span></p> 
<p><span style="color:#000000;">立即数</span><span style="color:#000000;">：<strong>有些</strong></span><strong><span style="color:#000000;">Thumb-2</span><span style="color:#000000;">指令支持长达</span><span style="color:#000000;">12</span><span style="color:#000000;">位的立即数，</span></strong><span style="color:#000000;">因此<strong>可以把以前</strong></span><strong><span style="color:#000000;">Thumb</span><span style="color:#000000;">指令无法加载的立即数使用一条</span><span style="color:#000000;">Thumb-2</span><span style="color:#000000;">来加载</span></strong><span style="color:#000000;">。</span></p> 
<p><span style="color:#000000;"> </span></p> 
<p><strong><span style="color:#000000;">IT</span></strong><span style="color:#000000;">指令块</span><span style="color:#000000;">：有些短距跳转可以使用</span><span style="color:#000000;">IT</span><span style="color:#000000;">指令取代，这样做消灭了因流水线清洗而引入的等待周期，从而提高了性能。</span></p> 
<p><span style="color:#000000;">l </span><strong><span style="color:#000000;">ARM/Thumb</span></strong><span style="color:#000000;">状态切换</span><span style="color:#000000;">：在大多情况下，可以把大部分代码以</span><span style="color:#000000;">Thumb</span><span style="color:#000000;">指令编码，一小部分以</span><span style="color:#000000;">ARM</span><span style="color:#000000;">指令编码。这主要是为了在平时提高代码密度，而在紧急关头下提高性能。在</span><span style="color:#000000;">CM3</span><span style="color:#000000;">下有<strong>了</strong></span><strong><span style="color:#000000;">Thumb-2</span><span style="color:#000000;">代码，可以在同一模式下解决时间与空间的权衡。</span></strong><span style="color:#000000;">这就可以去掉这些状态转换及其所带来的额外负担（</span><span style="color:#000000;">overhead</span><span style="color:#000000;">），也简化了对工程的管理。</span></p> 
<p><strong><span style="color:#000000;">看看上面对ARM</span>汇编指令有所理解。</strong></p> 
<p><span style="color:#000000;"> </span></p> 
<p><span style="color:#000000;">读者可能还注意到了，在本例中我们使用了另一个称为</span><span style="color:#000000;">-nostartfiles</span><span style="color:#000000;">的编译器开关。<strong>使用它，就可以让编译器不再往可执行映像中插入启动代码</strong></span><strong><span style="color:#000000;">(crt)</span><span style="color:#000000;">，</span></strong><span style="color:#000000;">这样做的目的之一就是减少程序映像的尺寸。不过，使用该选项的主要原因，其实是在于</span><span style="color:#000000;">GNU</span><span style="color:#000000;">工具链的启动代码是与发布包的提供者相关的，而有些人提供的启动代码不适合</span><span style="color:#000000;">CM3</span><span style="color:#000000;">它们往往是用于传统的</span><span style="color:#000000;">ARM</span><span style="color:#000000;">处理器的</span><span style="color:#000000;">如</span><span style="color:#000000;">ARM7</span><span style="color:#000000;">（<strong>典型地这些启动代码使用了</strong></span><strong><span style="color:#000000;">ARM</span><span style="color:#000000;">代码，而没有使用</span><span style="color:#000000;">Thumb</span><span style="color:#000000;">代码</span></strong><span style="color:#000000;">）。</span></p> 
<p><span style="color:#000000;">但是，在<strong>许多情况下，取决于应用程序和使用的库，都必须使用启动代码来执行初始化的过程，最主要的就是对数据的初始化</strong>（<strong>例如，把</strong></span><strong><span style="color:#000000;">bss</span><span style="color:#000000;">区的存储单元全部清零</span></strong><span style="color:#000000;">）。P263</span></p> 
<p>最后一句粗体话，使我想起了icrt0.asm文件中</p> 
<p>__reset    FUNCTION</p> 
<p>       EXPORT  start                     [WEAK]</p> 
<p>       B       start</p> 
<p>start</p> 
<p>       cpsid       f             ;Interrupt disable</p> 
<p>       ;;----------------------------------------------------------------------</p> 
<p>       ;; RO/RW Area Copy</p> 
<p>       ;; Initialize ZI Area (Use ARM Library)</p> 
<p>       ;;----------------------------------------------------------------------</p> 
<p>       <strong>IMPORT  __main</strong></p> 
<p><strong>       B       __main</strong></p> 
<p></p> 
<p>       EXPORT  __rt_entry</p> 
<p><strong>__rt_entry</strong></p> 
<p>。。。。自己的ut-kernel代码</p> 
<p><strong> </strong></p> 
<p>粗体代码既是对上面文字的代码叙述。</p> 
<p></p> 
<p><strong>关于程序进行fault历程后，怎么调试的总结：</strong></p> 
<p>首先看看本文档P12的程序出错产生异常时的故障调查分析：</p> 
<p><strong> </strong></p> 
<p>为了调查MemManage fault的案发现场，<strong>NVIC中有一个“存储器管理fault状态寄存器（MFSR）”，它指出导致MemManage fault的原因</strong>。如果是因为一个数据访问违例（DACCVIOL位）或是一个取指访问违例（IACCVIOL位），则违例指令的地址已经被压入栈中。<strong>如果还有MMARVALID位被置位，则还能进一步查出引发此fault时访问的地址读取NVIC“存储器管理地址寄存器（MMAR）”的值</strong>。P122</p> 
<p><strong>附录rtex-M3疑难解答这一节貌似非常不错的，讲了出现fault时的调查思路。</strong></p> 
<p><strong>E.2 </strong>设计<strong>Fault</strong>服务例程</p> 
<p><strong>这一节讲得视野很开阔。</strong></p> 
<p>用于<strong>开发阶段的</strong><strong>fault</strong><strong>服务例程，与用于实际系统中的服务例程，在绝大多数场合下是截然不同的</strong>。对于软件开发，<strong>fault服务例程应关注于准确及时地上报发生fault</strong><strong>时上下文</strong>；而实际<strong>系统中的</strong><strong>fault</strong><strong>服务例程则要把这当作是危急关头来处理，它要尽可能地想办法来恢复系统，实在不可救要时可能只有重启</strong>。这里我们主要讨论前者，因为<strong>后者是比较有技术含量的，而且不同的应用需要不同的策略</strong>。</p> 
<p>对于比较专业复杂的软件，</p> 
<p>首先：通常<strong>不直接在fault服务例程中报告与fault相关的状态</strong>，而是把<strong>它倾倒（专业术语：dump）到一块专用的内存中</strong>（主要包括fault状态寄存器，通用寄存器，自动入栈的内容等），</p> 
<p>其次接着悬起PendSV。等到PendSV服务例程执行后，再上报问题。这是因为上报过程执行的工作可能比较多，夜长梦多有可能在上报过程中又不小心触发了其它的fault，使得处理器被锁死。因此先暂记下来，稍后转交PendSV处理。</p> 
<p>当然如果软件很简单，则可以斟情简化fault的处理过程，甚至直接在服务例程中上报。</p> 
<p><strong>E.2.3 </strong>上报<strong>fault</strong>地址寄存器</p> 
<p>这一节讲了为什么要：必须先读BFAR/MMAR，再读BFARVALID/MMARVALID。如果后者为零，则丢弃读出的地址值。</p> 
<p>然后还有个注意事项：</p> 
<p>在fault上报完毕后，一定不要忘记清除FSR中的fault状态位。否则下次再发生fault时，就分不清FSR中的状态位是反映新来的fault，还是反映以前的fault了。而且，如果fault地Cortex-M3权威指南附录 E 318</p> 
<p>址有效位没有清除，下次发生fault时，BFAR/MMAR的值就无法更新。</p> 
<p><strong>Arm汇编和C语言的结合：</strong></p> 
<p>E.3 在C中上报入栈的寄存器和各fault状态寄存器</p> 
<p>在这里有栈溢出错误检测还有C语言汇编，跟栈的关系</p> 
<p>大多数的CM3项目还是以C语言为主的。然而，在<strong>C中不方便定位和直接访问堆栈帧（入栈的寄存器）。因为在标准C语言中是不能获取SP指针的</strong>。因此，如果使用C来写fault服务例程，<strong>最好配合一小段汇编码来获取SP的值</strong>，再把该值以一个参数传送给fault上报函数。P318</p> 
<p>紧接着下面就有一个<strong>Arm汇编和C语言的结合的示例程序</strong></p> 
<p></p> 
<p>请注意：<strong>如果发生了堆栈溢出或其它错误</strong>，使<strong>SP指向了无效的存储空对空区域</strong>，则上段代码会失能。在大多数情况下，这种错误都<strong>会影响C代码，因为所有C代码都需要堆栈</strong>。</p> 
<p>（<strong>是否说汇编代码可以减少堆栈的使用啊?</strong>）,建议多查查堆栈溢出错误方面的资料。</p> 
<p>但是栈溢出BUG最近发生了一个新的现象，它的解决方法详见arm权威指南及我们组项目笔记中王SAN的栈溢出BUG解决方案。</p> 
<p></p> 
<p>P320可以根据MemManage fault状态寄存器<strong>MSTKERR 位或者</strong>总线fault状态寄存器<strong>STKERR 位检查是否栈溢出，详见armcm3项目相关资料资料《</strong>一种利用fault异常自检栈溢出的方法》</p> 
<p>用法fault状态寄存器的<strong>INVSTATE位通常检查是否切入了ARM态，详见armcm3项目相关资料资料定位产生HARD FAULT之前的代码。</strong></p> 
<p></p> 
<p></p> 
<p><strong> </strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/150e64d41efcce0093b95bd205de0d06/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">服务器重启进不了系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e9da6f61dce0492796acc8147cf9c0be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ACL与NAT</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>