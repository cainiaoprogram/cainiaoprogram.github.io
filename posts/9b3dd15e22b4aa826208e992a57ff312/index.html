<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java面试技巧之每天一个Tip——Redis持久化方式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java面试技巧之每天一个Tip——Redis持久化方式" />
<meta property="og:description" content="Redis持久化方式的问题，可能是被问到最多的有关Redis的问题了，几乎一提到Redis这个主题，肯定是要被问到这个问题的，所以大家应该好好准备。
当然，还是简单的Tips，简单直接地回答：
两种方式：RDB和AOF。
这里不要等着面试官问，继续往下答，解释下两种方式的内涵就好，完整地答完是什么的问题。
RDB，指定时间的数据快照（dump.rdb文件），从内存复制到磁盘，等到Redis重启的时候加载使用。
AOF，将每条写入命令通过追加的方式插入日志文件，等到Redis重启的时候，通过回放命令进行恢复。
答到这里，基本就答清楚了「是什么」的问题了。
扩展性问题：
1、RDB是如何进行持久化的？
答：save和bgsave方式，save方式由于会阻塞Redis服务器，非开发环境已经不推荐使用了，一般使用bgsave命令。
bgsave的流程是：
向服务器发送bgsave命令；系统调用fork函数，fork一个子进程；子进程创建rdb文件，从内存拷贝快照数据到磁盘上的rdb文件中；子进程负责将旧的rdb文件替换成新的；通知redis服务端完成状态； 2、RDB和AOF的优缺点比较？
RDB可以指定压缩成二进制文件，节省空间，效率高；适合需要全量备份的应用场景，并且可以方便地进行灾备传输；RDB恢复数据要比AOF快。
但是，RDB会造成数据丢失，fork子进程会丧失一些性能，不同版本Redis的rdb文件格式不统一，产生兼容问题。
AOF可以通过设置fsync策略（默认是每秒）进行及时追加，最多丢失1秒内的数据。AOF具有重写极致，会合并重复的命令，只保留最新的；性能损耗要比RDB模式大（即时备份的代价），日志文件体积更大，恢复速度较慢。
3、RDB和AOF模式同时开启会如何？
注意，RDB是默认开启的，AOF默认不开启。
redis4.0版本之前，即使两种方式同时开启，redis服务器恢复时也只会使用AOF的文件来进行恢复，rdb文件根本不用。
redis4.0版本之后，两种方式同时开启，RDB会将二进制快照数据写入aof文件！AOF的命令会追加到rdb文件内容之后，结果就是前半部分是rdb数据，后半部分是aof的命令。
这样，恢复的时候，二进制数据先加载进内存，后面再执行剩余的aof命令，这时候要执行的aof命令肯定要比只使用aof模式更少。
二者完美结合～
追加清单：
这里的追加问题清单就太多了，可以列一下，有关普通hash、一致性hash、hash槽的内容后面准备单独一篇文章给大家讲，敬请期待～
Redis哨兵模式的原理； Redis-Cluster模式的原理； 为什么Redis用hash槽来解决数据分配的问题？ hash槽为什么是16384？具体是如何做的数据分配？ 说说Redis的缓存问题？缓存穿透、缓存击穿和缓存雪崩的区别，以及你遇到的应用场景是什么？ Redis如何实现互斥锁？ 你使用过哪些Redis客户端？ 这里提到了锁——这就意味着问题可以无限扩展了……
好了，大家周末愉快，就写到这里吧，下次说点别的，😁
～以上为本人原创，请尊重知识产权，不接受任何抄袭、演绎和未经注明出处的转载。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9b3dd15e22b4aa826208e992a57ff312/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-21T17:23:01+08:00" />
<meta property="article:modified_time" content="2023-04-21T17:23:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java面试技巧之每天一个Tip——Redis持久化方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>Redis持久化方式的问题，可能是被问到最多的有关Redis的问题了，几乎一提到Redis这个主题，肯定是要被问到这个问题的，所以大家应该好好准备。</strong></p> 
<p>当然，还是简单的Tips，简单直接地回答：</p> 
<p>两种方式：RDB和AOF。</p> 
<p>这里不要等着面试官问，继续往下答，解释下两种方式的内涵就好，完整地答完是什么的问题。</p> 
<p><strong>RDB，指定时间的数据快照（dump.rdb文件），从内存复制到磁盘，等到Redis重启的时候加载使用。</strong></p> 
<p><strong>AOF，将每条写入命令通过追加的方式插入日志文件，等到Redis重启的时候，通过回放命令进行恢复。</strong></p> 
<p>答到这里，基本就答清楚了「是什么」的问题了。</p> 
<p><strong>扩展性问题：</strong></p> 
<p>1、RDB是如何进行持久化的？</p> 
<p>答：save和bgsave方式，save方式由于会阻塞Redis服务器，非开发环境已经不推荐使用了，一般使用bgsave命令。</p> 
<p><strong>bgsave的流程是：</strong></p> 
<ul><li>向服务器发送bgsave命令；</li><li>系统调用fork函数，fork一个子进程；</li><li>子进程创建rdb文件，从内存拷贝快照数据到磁盘上的rdb文件中；</li><li>子进程负责将旧的rdb文件替换成新的；</li><li>通知redis服务端完成状态；</li></ul> 
<p><strong>2、RDB和AOF的优缺点比较？</strong></p> 
<p>RDB可以指定压缩成二进制文件，节省空间，效率高；适合需要全量备份的应用场景，并且可以方便地进行灾备传输；RDB恢复数据要比AOF快。</p> 
<p>但是，RDB会造成数据丢失，fork子进程会丧失一些性能，不同版本Redis的rdb文件格式不统一，产生兼容问题。</p> 
<p>AOF可以通过设置fsync策略（默认是每秒）进行及时追加，最多丢失1秒内的数据。AOF具有重写极致，会合并重复的命令，只保留最新的；性能损耗要比RDB模式大（即时备份的代价），日志文件体积更大，恢复速度较慢。</p> 
<p><strong>3、RDB和AOF模式同时开启会如何？</strong></p> 
<p>注意，RDB是默认开启的，AOF默认不开启。</p> 
<p>redis4.0版本之前，即使两种方式同时开启，redis服务器恢复时也只会使用AOF的文件来进行恢复，rdb文件根本不用。</p> 
<p>redis4.0版本之后，两种方式同时开启，RDB会将二进制快照数据写入aof文件！AOF的命令会追加到rdb文件内容之后，结果就是前半部分是rdb数据，后半部分是aof的命令。</p> 
<p>这样，恢复的时候，二进制数据先加载进内存，后面再执行剩余的aof命令，这时候要执行的aof命令肯定要比只使用aof模式更少。</p> 
<p>二者完美结合～</p> 
<p><strong>追加清单：</strong></p> 
<p>这里的追加问题清单就太多了，可以列一下，有关普通hash、一致性hash、hash槽的内容后面准备单独一篇文章给大家讲，敬请期待～</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> Redis哨兵模式的原理；</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> Redis-Cluster模式的原理；</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 为什么Redis用hash槽来解决数据分配的问题？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> hash槽为什么是16384？具体是如何做的数据分配？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 说说Redis的缓存问题？缓存穿透、缓存击穿和缓存雪崩的区别，以及你遇到的应用场景是什么？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> Redis如何实现互斥锁？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 你使用过哪些Redis客户端？</li></ul> 
<p>这里提到了锁——这就意味着问题可以无限扩展了……</p> 
<p>好了，大家周末愉快，就写到这里吧，下次说点别的，😁</p> 
<p><strong>～以上为本人原创，请尊重知识产权，不接受任何抄袭、演绎和未经注明出处的转载。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/33e483895d47f1ec2a330aec2c762ef0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android默认时区、语言设置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dcc81cbf9ddfb66f4bc4f0fb866df146/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图像处理与分析（二）傅里叶变换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>