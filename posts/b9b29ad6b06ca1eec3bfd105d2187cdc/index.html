<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux中信号量介绍及使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux中信号量介绍及使用" />
<meta property="og:description" content="1.初始化条件变量pthread_cond_init
#include &lt;pthread.h&gt;
int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr);
返回值：函数成功返回0；任何其他返回值都表示错误
初始化一个条件变量。当参数cattr为空指针时，函数创建的是一个缺省的条件变量。否则条件变量的属性将由cattr中的属性值来决定。调用 pthread_cond_init函数时，参数cattr为空指针等价于cattr中的属性为缺省属性，只是前者不需要cattr所占用的内存开销。这个函数返回时，条件变量被存放在参数cv指向的内存中。
可以用宏PTHREAD_COND_INITIALIZER来初始化静态定义的条件变量，使其具有缺省属性。这和用pthread_cond_init函数动态分配的效果是一样的。初始化时不进行错误检查。如：
pthread_cond_t cv = PTHREAD_COND_INITIALIZER;
不能由多个线程同时初始化一个条件变量。当需要重新初始化或释放一个条件变量时，应用程序必须保证这个条件变量未被使用。
2.阻塞在条件变量上pthread_cond_wait
#include &lt;pthread.h&gt;
int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex);
返回值：函数成功返回0；任何其他返回值都表示错误
函数将解锁mutex参数指向的互斥锁，并使当前线程阻塞在cv参数指向的条件变量上。
被阻塞的线程可以被pthread_cond_signal函数，pthread_cond_broadcast函数唤醒，也可能在被信号中断后被唤醒。
pthread_cond_wait函数的返回并不意味着条件的值一定发生了变化，必须重新检查条件的值。
pthread_cond_wait函数返回时，相应的互斥锁将被当前线程锁定，即使是函数出错返回。
一般一个条件表达式都是在一个互斥锁的保护下被检查。当条件表达式未被满足时，线程将仍然阻塞在这个条件变量上。当另一个线程改变了条件的值并向条件变量发出信号时，等待在这个条件变量上的一个线程或所有线程被唤醒，接着都试图再次占有相应的互斥锁。
阻塞在条件变量上的线程被唤醒以后，直到pthread_cond_wait()函数返回之前条件的值都有可能发生变化。所以函数返回以后，在锁定相应的互斥锁之前，必须重新测试条件值。最好的测试方法是循环调用pthread_cond_wait函数，并把满足条件的表达式置为循环的终止条件。如：
pthread_mutex_lock();
while (condition_is_false)
pthread_cond_wait();
pthread_mutex_unlock();
阻塞在同一个条件变量上的不同线程被释放的次序是不一定的。
注意：pthread_cond_wait()函数是退出点，如果在调用这个函数时，已有一个挂起的退出请求，且线程允许退出，这个线程将被终止并开始执行善后处理函数，而这时和条件变量相关的互斥锁仍将处在锁定状态。
3.解除在条件变量上的阻塞pthread_cond_signal
#include &lt;pthread.h&gt;
int pthread_cond_signal(pthread_cond_t *cv);
返回值：函数成功返回0；任何其他返回值都表示错误
函数被用来释放被阻塞在指定条件变量上的一个线程。
必须在互斥锁的保护下使用相应的条件变量。否则对条件变量的解锁有可能发生在锁定条件变量之前，从而造成死锁。
唤醒阻塞在条件变量上的所有线程的顺序由调度策略决定，如果线程的调度策略是SCHED_OTHER类型的，系统将根据线程的优先级唤醒线程。
如果没有线程被阻塞在条件变量上，那么调用pthread_cond_signal()将没有作用。
4.阻塞直到指定时间pthread_cond_timedwait
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;
int pthread_cond_timedwait(pthread_cond_t *cv, pthread_mutex_t *mp, const structtimespec * abstime);
返回值：函数成功返回0；任何其他返回值都表示错误
函数到了一定的时间，即使条件未发生也会解除阻塞。这个时间由参数abstime指定。函数返回时，相应的互斥锁往往是锁定的，即使是函数出错返回。
注意：pthread_cond_timedwait函数也是退出点。
超时时间参数是指一天中的某个时刻。使用举例：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b9b29ad6b06ca1eec3bfd105d2187cdc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-16T11:07:26+08:00" />
<meta property="article:modified_time" content="2019-07-16T11:07:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux中信号量介绍及使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.初始化条件变量pthread_cond_init</p> 
<p>#include &lt;pthread.h&gt;</p> 
<p>int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr);</p> 
<p>返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>初始化一个条件变量。当参数cattr为空指针时，函数创建的是一个缺省的条件变量。否则条件变量的属性将由cattr中的属性值来决定。调用 pthread_cond_init函数时，参数cattr为空指针等价于cattr中的属性为缺省属性，只是前者不需要cattr所占用的内存开销。这个函数返回时，条件变量被存放在参数cv指向的内存中。</p> 
<p>可以用宏PTHREAD_COND_INITIALIZER来初始化静态定义的条件变量，使其具有缺省属性。这和用pthread_cond_init函数动态分配的效果是一样的。初始化时不进行错误检查。如：</p> 
<p>pthread_cond_t cv = PTHREAD_COND_INITIALIZER;</p> 
<p>不能由多个线程同时初始化一个条件变量。当需要重新初始化或释放一个条件变量时，应用程序必须保证这个条件变量未被使用。</p> 
<p> </p> 
<p>2.阻塞在条件变量上pthread_cond_wait</p> 
<p>#include &lt;pthread.h&gt;</p> 
<p>int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex);</p> 
<p>返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>函数将解锁mutex参数指向的互斥锁，并使当前线程阻塞在cv参数指向的条件变量上。</p> 
<p>被阻塞的线程可以被pthread_cond_signal函数，pthread_cond_broadcast函数唤醒，也可能在被信号中断后被唤醒。</p> 
<p>pthread_cond_wait函数的返回并不意味着条件的值一定发生了变化，必须重新检查条件的值。</p> 
<p>pthread_cond_wait函数返回时，相应的互斥锁将被当前线程锁定，即使是函数出错返回。</p> 
<p>一般一个条件表达式都是在一个互斥锁的保护下被检查。当条件表达式未被满足时，线程将仍然阻塞在这个条件变量上。当另一个线程改变了条件的值并向条件变量发出信号时，等待在这个条件变量上的一个线程或所有线程被唤醒，接着都试图再次占有相应的互斥锁。</p> 
<p>阻塞在条件变量上的线程被唤醒以后，直到pthread_cond_wait()函数返回之前条件的值都有可能发生变化。所以函数返回以后，在锁定相应的互斥锁之前，必须重新测试条件值。最好的测试方法是循环调用pthread_cond_wait函数，并把满足条件的表达式置为循环的终止条件。如：</p> 
<p>pthread_mutex_lock();</p> 
<p>while (condition_is_false)</p> 
<p>    pthread_cond_wait();</p> 
<p>pthread_mutex_unlock();</p> 
<p>阻塞在同一个条件变量上的不同线程被释放的次序是不一定的。</p> 
<p>注意：pthread_cond_wait()函数是退出点，如果在调用这个函数时，已有一个挂起的退出请求，且线程允许退出，这个线程将被终止并开始执行善后处理函数，而这时和条件变量相关的互斥锁仍将处在锁定状态。</p> 
<p> </p> 
<p>3.解除在条件变量上的阻塞pthread_cond_signal</p> 
<p>#include &lt;pthread.h&gt;</p> 
<p>int pthread_cond_signal(pthread_cond_t *cv);</p> 
<p>返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>函数被用来释放被阻塞在指定条件变量上的一个线程。</p> 
<p>必须在互斥锁的保护下使用相应的条件变量。否则对条件变量的解锁有可能发生在锁定条件变量之前，从而造成死锁。</p> 
<p>唤醒阻塞在条件变量上的所有线程的顺序由调度策略决定，如果线程的调度策略是SCHED_OTHER类型的，系统将根据线程的优先级唤醒线程。</p> 
<p>如果没有线程被阻塞在条件变量上，那么调用pthread_cond_signal()将没有作用。</p> 
<p> </p> 
<p>4.阻塞直到指定时间pthread_cond_timedwait</p> 
<p>#include &lt;pthread.h&gt;</p> 
<p>#include &lt;time.h&gt;</p> 
<p>int pthread_cond_timedwait(pthread_cond_t *cv, pthread_mutex_t *mp, const structtimespec * abstime);</p> 
<p>返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>函数到了一定的时间，即使条件未发生也会解除阻塞。这个时间由参数abstime指定。函数返回时，相应的互斥锁往往是锁定的，即使是函数出错返回。</p> 
<p>注意：pthread_cond_timedwait函数也是退出点。</p> 
<p>超时时间参数是指一天中的某个时刻。使用举例：</p> 
<p>pthread_timestruc_t to;</p> 
<p>to.tv_sec = time(NULL) + TIMEOUT;</p> 
<p>to.tv_nsec = 0;</p> 
<p>超时返回的错误码是ETIMEDOUT。</p> 
<p> </p> 
<p>5.释放阻塞的所有线程pthread_cond_broadcast</p> 
<p>#include &lt;pthread.h&gt;</p> 
<p>int pthread_cond_broadcast(pthread_cond_t *cv);</p> 
<p>返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>函数唤醒所有被pthread_cond_wait函数阻塞在某个条件变量上的线程，参数cv被用来指定这个条件变量。当没有线程阻塞在这个条件变量上时，pthread_cond_broadcast函数无效。</p> 
<p>由于pthread_cond_broadcast函数唤醒所有阻塞在某个条件变量上的线程，这些线程被唤醒后将再次竞争相应的互斥锁，所以必须小心使用pthread_cond_broadcast函数。</p> 
<p> </p> 
<p>6.释放条件变量pthread_cond_destroy</p> 
<p>#include &lt;pthread.h&gt;</p> 
<p>int pthread_cond_destroy(pthread_cond_t *cv);</p> 
<p>返回值：函数成功返回0；任何其他返回值都表示错误</p> 
<p>释放条件变量。</p> 
<p>注意：条件变量占用的空间并未被释放。</p> 
<p> </p> 
<p>7.唤醒丢失问题</p> 
<p>在线程未获得相应的互斥锁时调用pthread_cond_signal或pthread_cond_broadcast函数可能会引起唤醒丢失问题。</p> 
<p>唤醒丢失往往会在下面的情况下发生：</p> 
<ol><li>一个线程调用pthread_cond_signal或pthread_cond_broadcast函数；</li><li>另一个线程正处在测试条件变量和调用pthread_cond_wait函数之间；</li><li>没有线程正在处在阻塞等待的状态下。</li></ol> 
<p>实例：<br> LINUX环境下多线程编程肯定会遇到需要条件变量的情况，此时必然要使用pthread_cond_wait()函数。但这个函数的执行过程比较难于理解。<br>     pthread_cond_wait()的工作流程如下（以MAN中的EXAMPLE为例）：<br>       </p> 
<pre class="has"><code class="language-cpp">Consider two shared variables x and y, protected by the mutex mut, and a condition vari-
       able cond that is to be signaled whenever x becomes greater than y.

              int x,y;
              pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
              pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

       Waiting until x is greater than y is performed as follows:

              pthread_mutex_lock(&amp;mut);
              while (x &lt;= y) {
                      pthread_cond_wait(&amp;cond, &amp;mut);
              }
              /* operate on x and y */
              pthread_mutex_unlock(&amp;mut);

       Modifications on x and y that may cause x to become greater than y should signal the con-
       dition if needed:

              pthread_mutex_lock(&amp;mut);
              /* modify x and y */
              if (x &gt; y) pthread_cond_broadcast(&amp;cond);
              pthread_mutex_unlock(&amp;mut);</code></pre> 
<p>     这个例子的意思是，两个线程要修改X和 Y的值，第一个线程当X&lt;=Y时就挂起，直到X&gt;Y时才继续执行（由第二个线程可能会修改X,Y的值，当X&gt;Y时唤醒第一个线程），即 首先初始化一个普通互斥量mut和一个条件变量cond。之后分别在两个线程中分别执行如下函数体：</p> 
<pre class="has"><code class="language-cpp">              pthread_mutex_lock(&amp;mut);
              while (x &lt;= y) {
                      pthread_cond_wait(&amp;cond, &amp;mut);
              }
              /* operate on x and y */
              pthread_mutex_unlock(&amp;mut);</code></pre> 
<p>和：       </p> 
<pre class="has"><code class="language-cpp">            pthread_mutex_lock(&amp;mut);
              /* modify x and y */
              if (x &gt; y) pthread_cond_signal(&amp;cond);
              pthread_mutex_unlock(&amp;mut); </code></pre> 
<p><br>     其实函数的执行过程非常简单，在第一个线程执行到pthread_cond_wait(&amp;cond,&amp;mut)时，此时如果X&lt;=Y，则此函数就将mut互斥量解锁 ，再将cond条件变量加锁 ，此时第一个线程挂起 （不占用任何CPU周期）。<br>     而在第二个线程中，本来因为mut被第一个线程锁住而阻塞，此时因为mut已经释放，所以可以获得锁mut，并且进行修改X和Y的值，在修改之后，一个IF语句判定是不是X&gt;Y，如果是，则此时pthread_cond_signal()函数会唤醒第一个线程 ，并在下一句中释放互斥量mut。然后第一个线程开始从pthread_cond_wait()执行，首先要再次<strong>锁mut</strong> ， 如果锁成功，再进行<strong>条件的判断</strong> （至于为什么用WHILE，即在被唤醒之后还要再判断，后面有原因分析），如果满足条件，则<strong>被唤醒</strong> 进行处理，最后释放互斥量mut 。</p> 
<p>    至于为什么在被唤醒之后还要再次进行条件判断（即为什么要使用while循环来判断条件），是因为可能有“惊群效应”。有人觉得此处既然是被唤醒的，肯定 是满足条件了，其实不然。如果是多个线程都在等待这个条件，而同时只能有一个线程进行处理，此时就必须要再次条件判断，以使只有一个线程进入临界区处理。</p> 
<p><strong>可以看出：</strong> <br> 1，pthread_cond_signal在多处理器上可能同时唤醒多个线程，当你只能让一个线程处理某个任务时，其它被唤醒的线程就需要继续 wait,while循环的意义就体现在这里了，而且规范要求pthread_cond_signal至少唤醒一个pthread_cond_wait上 的线程，其实有些实现为了简单在单处理器上也会唤醒多个线程. <br> 2，某些应用，如线程池，pthread_cond_broadcast唤醒全部线程，但我们通常只需要一部分线程去做执行任务，所以其它的线程需要继续wait.所以强烈推荐此处使用while循环.</p> 
<p>       其实说白了很简单，就是pthread_cond_signal()也可能唤醒多个线程，而如果你同时只允许一个线程访问的话，就必须要使用while来进行条件判断，以保证临界区内只有一个线程在处理。</p> 
<p> </p> 
<p>pthread_cond_wait()  用于阻塞当前线程，等待别的线程使用 pthread_cond_signal() 或pthread_cond_broadcast来唤醒它 。  pthread_cond_wait()   必须与pthread_mutex 配套使用。pthread_cond_wait() 函数一进入wait状态就会自动release mutex。当其他线程通过 pthread_cond_signal() 或pthread_cond_broadcast ，把该线程唤醒，使 pthread_cond_wait()通过（返回）时，该线程又自动获得该mutex 。</p> 
<p>        pthread_cond_signal 函数的作用是发送一个信号给另外一个正在处于阻塞等待状态的线程,使其脱离阻塞状态,继续执行.如果没有线程处在阻塞等待状态,pthread_cond_signal也会成功返回。</p> 
<p>        使用pthread_cond_signal一般不会有“惊群现象”产生，他最多只给一个线程发信号。假如有多个线程正在阻塞等待着这个条件变量的话，那么是根据各等待线程优先级的高低确定哪个线程接收到信号开始继续执行。如果各线程优先级相同，则根据等待时间的长短来确定哪个线程获得信号。但无论如何一个pthread_cond_signal调用最多发信一次。</p> 
<p>        但是 pthread_cond_signal 在多处理器上可能同时唤醒多个线程，当你只能让一个线程处理某个任务时，其它被唤醒的线程就需要继续 wait．</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f704d95bfcf2ae4e502d58f9a340072c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信扫码登录前端要做的工作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f68d7daa0bb327e2acaee121d235ef69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenCV—Python 图像去模糊（维纳滤波，约束最小二乘方滤波）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>