<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分布式任务调度 ElasticJob 多线程处理海量数据 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="分布式任务调度 ElasticJob 多线程处理海量数据" />
<meta property="og:description" content="项目中经常遇到海量数据批量处理的问题，第一时间想到通过多线程来处理，要想海量数据快速的处理完成， 就需要使用多台服务器并行处理。本文演示如何在分布式环境下使用 ElasticJob 处理海量数据， 通过 Demo 展示多机任务如何分片，作业如何拆分，如何水平扩容等问题。
1 概述 Elastic Job 是面向互联网生态和海量任务的分布式调度解决方案。最初由当当基于 ZooKeeper、 Quartz 进行二次开发的分布式解决方案。2020年 6月，经过 Apache ShardingSphere 社区投票，接纳 ElasticJob 为其子项目。 目前 ElasticJob 的四个子项目已经正式迁入 Apache 仓库。
源码地址： https://github.com/apache/shardingsphere-elasticjob文档地址（3.X版本）： https://shardingsphere.apache.org/elasticjob/current/cn/overview/ 2 演示目标 leader 节点选举；任务分片， 分片是否均匀；水平扩容； 3 演示源码 3.1 相关依赖包引入 演示代码基于 3.0.0-RC1 版本编写，环境要求： Java 8及以上版本、Maven 3.5.0 及以上版本、 ZooKeeper 3.6.0 及以上版本；本文采用 Java 8、 Maven 3.6.3、 ZooKeeper 3.7.0、SpringBoot 2.3.4.RELEASE；ZooKeeper 3.7.0 下载地址： https://apache.claz.org/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz项目启动前需要下载并启动 ZooKeeper： ./zkServer.sh start &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere.elasticjob&lt;/groupId&gt; &lt;artifactId&gt;elasticjob-lite-core&lt;/artifactId&gt; &lt;version&gt;3.0.0-RC1&lt;/version&gt; &lt;/dependency&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ec1b6dda222c68b3db2f3979a3f507a7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-06T21:41:38+08:00" />
<meta property="article:modified_time" content="2021-07-06T21:41:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分布式任务调度 ElasticJob 多线程处理海量数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" height="493" src="https://images2.imgbox.com/ca/3d/ukQqDPpI_o.jpg" width="713"></p> 
<p></p> 
<p>项目中经常遇到海量数据批量处理的问题，第一时间想到通过多线程来处理，要想海量数据快速的处理完成， 就需要使用多台服务器并行处理。本文演示如何在分布式环境下使用 ElasticJob 处理海量数据， 通过 Demo 展示多机任务如何分片，作业如何拆分，如何水平扩容等问题。</p> 
<h2>1 概述</h2> 
<p>Elastic Job 是面向互联网生态和海量任务的分布式调度解决方案。最初由当当基于 ZooKeeper、 Quartz 进行二次开发的分布式解决方案。2020年 6月，经过 Apache ShardingSphere 社区投票，接纳 ElasticJob 为其子项目。 目前 ElasticJob 的四个子项目已经正式迁入 Apache 仓库。</p> 
<ul><li>源码地址： <a href="https://github.com/apache/shardingsphere-elasticjob">https://github.com/apache/shardingsphere-elasticjob</a></li><li>文档地址（3.X版本）： <a href="https://shardingsphere.apache.org/elasticjob/current/cn/overview/" rel="nofollow">https://shardingsphere.apache.org/elasticjob/current/cn/overview/</a></li></ul> 
<h2>2 演示目标</h2> 
<ul><li>leader 节点选举；</li><li>任务分片， 分片是否均匀；</li><li>水平扩容；</li></ul> 
<h2>3 演示源码</h2> 
<p></p> 
<h3>3.1 相关依赖包引入</h3> 
<ul><li>演示代码基于 3.0.0-RC1 版本编写，环境要求： Java 8及以上版本、Maven 3.5.0 及以上版本、 ZooKeeper 3.6.0 及以上版本；</li><li>本文采用 Java 8、 Maven 3.6.3、 ZooKeeper 3.7.0、SpringBoot 2.3.4.RELEASE；</li><li>ZooKeeper 3.7.0 下载地址： https://apache.claz.org/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz</li><li>项目启动前需要下载并启动 ZooKeeper： ./zkServer.sh start</li></ul> 
<pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shardingsphere.elasticjob&lt;/groupId&gt;
    &lt;artifactId&gt;elasticjob-lite-core&lt;/artifactId&gt;
    &lt;version&gt;3.0.0-RC1&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<pre><code class="language-XML">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
            &lt;version&gt;${curator.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-client&lt;/artifactId&gt;
            &lt;version&gt;${curator.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
            &lt;version&gt;${curator.version}&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre> 
<h3>3.2 配置文件</h3> 
<pre><code class="language-java">elasticjob:
  zookeeper:
    server-lists: localhost:2181
    namespace: note-elasticjob</code></pre> 
<h3>3.3 ElasticJob 配置类</h3> 
<pre><code class="language-java">@Configuration
@ConditionalOnExpression("'${elasticjob.zookeeper.server-lists}'.length() &gt; 0")
public class ElasticJobConfig {

    @Value("${elasticjob.zookeeper.server-lists}")
    private String serverList;

    @Value("${elasticjob.zookeeper.namespace}")
    private String namespace;

    @Bean(initMethod = "init")
    public CoordinatorRegistryCenter coordinatorRegistryCenter() {
        ZookeeperConfiguration zookeeperConfiguration = new ZookeeperConfiguration(serverList, namespace);
        // 失败重试次数
        zookeeperConfiguration.setMaxRetries(3);
        // 20 分钟
        zookeeperConfiguration.setSessionTimeoutMilliseconds(20 * 60 * 1000);

        CoordinatorRegistryCenter registryCenter = new ZookeeperRegistryCenter(zookeeperConfiguration);
        registryCenter.init();

        return registryCenter;
    }
}
</code></pre> 
<h3>3.4 构建 Job 生成器</h3> 
<ul><li>根据配置构建 Job</li></ul> 
<pre><code class="language-java">@Component
public class ElasticJobGenerator {
    protected final Logger logger = LoggerFactory.getLogger(ElasticJobGenerator.class);

    @Autowired
    protected CoordinatorRegistryCenter coordinatorRegistryCenter;

    public void build(String jobName, String jobParams, SimpleJob jobInstance, String cronStr, int shardingTotalCnt) {
        JobConfiguration jobConfiguration = JobConfiguration.newBuilder(jobName, shardingTotalCnt)
                .cron(cronStr)
                .jobParameter(jobParams)
                .misfire(false)
                .overwrite(true).build();

        ScheduleJobBootstrap scheduleJobBootstrap = new ScheduleJobBootstrap(coordinatorRegistryCenter,
                jobInstance, jobConfiguration);

        try {
            logger.info("开始创建任务");
            scheduleJobBootstrap.schedule();
        } catch (Exception e) {
            logger.error("任务创建失败", e);
        }
    }
}</code></pre> 
<h3>3.5 Job处理类</h3> 
<pre><code class="language-java">
@Component
public class MyJob implements SimpleJob {
    private static Logger logger = LoggerFactory.getLogger(MyJob.class);

    @Override
    public void execute(ShardingContext shardingContext) {
        int shardingTotalCnt = shardingContext.getShardingTotalCount();
        int shardingItem = shardingContext.getShardingItem();
        String params = shardingContext.getJobParameter();
        MDC.put("shardingItem", "sharding_" + shardingItem);
        logger.debug("当前作业分片：{}", shardingItem);
        logger.debug("作业参数： {}", params);

        long startTime = System.currentTimeMillis();
        int dataLen = 100;
        logger.info("当前分片：{}， 开始执行任务", shardingItem);
        for (int i = 0; i &lt; dataLen; i++) {
            if (i % shardingTotalCnt != shardingItem) {
                logger.debug("当前分片：{}, 其他分片的任务： {}", shardingItem, i);
                continue;
            }

            logger.debug("当前分片：{}， 任务： {}, 开始工作", shardingItem, i);
            try {
                // 模拟任务执行 1s
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
            }

            logger.debug("当前分片：{}， 任务： {}, 工作完成", shardingItem, i);
        }

        logger.info("当前分片：{}，任务执行完成， 耗时： {}秒", shardingItem, (System.currentTimeMillis() - startTime) / 1000);

        MDC.remove("shardingItem");
    }
}
</code></pre> 
<h3>3.6 写个测试接口</h3> 
<pre><code class="language-java">@RestController
public class TestJobController {

    @Autowired
    protected ElasticJobGenerator elasticJobGenerator;

    @Autowired
    protected MyJob myJob;

    @PostMapping("/test_job")
    public String testJob(@RequestParam("jobName") String jobName, @RequestParam("shardingTotalCount") int shardingTotalCount) {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("ss mm HH dd MM ? yyyy");
        Date startTime = new Date();
        // 延迟 5秒后执行
        startTime.setTime(startTime.getTime() + 5 * 1000);

        elasticJobGenerator.build(jobName,
                "",
                myJob,
                simpleDateFormat.format(startTime),
                shardingTotalCount);

        return "finished";
    }
}</code></pre> 
<h2>4 单机启动</h2> 
<ul><li>启动参数配置： -Dserver.port=8081</li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/de/841e3A2I_o.png"></p> 
<ul><li>查看 ZooKeeper ， 可以发现 Leader 选举情况， 以及分片情况</li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e5/99/fejLhlsj_o.png"></p> 
<p></p> 
<p></p> 
<ul><li>验证是否拆分了 10个线程执行， 输出日志中的分片个数；</li></ul> 
<pre><code class="language-bash"># 分片拆分情况
grep -r -n 'test1' ~/logs/note-elastic-job/app/note-elastic-job.log | awk '{ for(i=1;i&lt;=NF;i++) { if (match($i, /sharding_/)) {print $i} }}' | sort | uniq</code></pre> 
<blockquote> 
 <p>输出结果 =&gt;</p> 
 <p>[sharding_0]</p> 
 <p>[sharding_1]</p> 
 <p>[sharding_2]</p> 
 <p>[sharding_3]</p> 
 <p>[sharding_4]</p> 
 <p>[sharding_5]</p> 
 <p>[sharding_6]</p> 
 <p>[sharding_7]</p> 
 <p>[sharding_8]</p> 
 <p>[sharding_9]</p> 
</blockquote> 
<ul><li>拆分了 10个分片处理这 100个任务； </li></ul> 
<pre><code class="language-bash"># 查询任务是否分布均匀
grep -r -n 'elasticjob-test1' ~/logs/note-elastic-job/app/note-elastic-job.log | grep "sharding_[[:digit:]]\{1,2\}" | grep '工作完成' |  awk '{count[$6]++;} END { for(i in count) {print "分片：" i " 任务个数: " count[i]} }'|sort</code></pre> 
<blockquote> 
 <p>分片：[sharding_0] 任务个数: 10</p> 
 <p>分片：[sharding_1] 任务个数: 10</p> 
 <p>分片：[sharding_2] 任务个数: 10</p> 
 <p>分片：[sharding_3] 任务个数: 10</p> 
 <p>分片：[sharding_4] 任务个数: 10</p> 
 <p>分片：[sharding_5] 任务个数: 10</p> 
 <p>分片：[sharding_6] 任务个数: 10</p> 
 <p>分片：[sharding_7] 任务个数: 10</p> 
 <p>分片：[sharding_8] 任务个数: 10</p> 
 <p>分片：[sharding_9] 任务个数: 10</p> 
</blockquote> 
<ul><li>可以看出每个分片上任务拆分很均匀， 每个分片上平均都拆分 10个任务进行处理， 默认采用平均分片算法； </li></ul> 
<pre><code class="language-bash"># 任务执行时长
grep -r -n 'elasticjob-test1' ~/logs/note-elastic-job/app/note-elastic-job.log | grep '任务执行完成'</code></pre> 
<blockquote> 
 <p>[elasticjob-test1-10] [INFO ] [cn.yuerbest.note.spring.boot.elasticjob.job.MyJob:44] [sharding_9] - 当前分片：9，任务执行完成， 耗时： 10秒<br> [elasticjob-test1-7] [INFO ] [cn.yuerbest.note.spring.boot.elasticjob.job.MyJob:44] [sharding_6] - 当前分片：6，任务执行完成， 耗时： 10秒<br> [elasticjob-test1-8] [INFO ] [cn.yuerbest.note.spring.boot.elasticjob.job.MyJob:44] [sharding_7] - 当前分片：7，任务执行完成， 耗时： 10秒<br> [elasticjob-test1-9] [INFO ] [cn.yuerbest.note.spring.boot.elasticjob.job.MyJob:44] [sharding_8] - 当前分片：8，任务执行完成， 耗时： 10秒<br> [elasticjob-test1-6] [INFO ] [cn.yuerbest.note.spring.boot.elasticjob.job.MyJob:44] [sharding_5] - 当前分片：5，任务执行完成， 耗时： 10秒<br> [elasticjob-test1-5] [INFO ] [cn.yuerbest.note.spring.boot.elasticjob.job.MyJob:44] [sharding_4] - 当前分片：4，任务执行完成， 耗时： 10秒<br> [elasticjob-test1-2] [INFO ] [cn.yuerbest.note.spring.boot.elasticjob.job.MyJob:44] [sharding_1] - 当前分片：1，任务执行完成， 耗时： 10秒<br> [elasticjob-test1-3] [INFO ] [cn.yuerbest.note.spring.boot.elasticjob.job.MyJob:44] [sharding_2] - 当前分片：2，任务执行完成， 耗时： 10秒<br> [elasticjob-test1-4] [INFO ] [cn.yuerbest.note.spring.boot.elasticjob.job.MyJob:44] [sharding_3] - 当前分片：3，任务执行完成， 耗时： 10秒<br> [elasticjob-test1-1] [INFO ] [cn.yuerbest.note.spring.boot.elasticjob.job.MyJob:44] [sharding_0] - 当前分片：0，任务执行完成， 耗时： 10秒</p> 
</blockquote> 
<ul><li>任务执行耗时均匀， 每个任务耗时 10秒完成；</li><li>原本单线程执行需要 100秒完成的任务， 现在进行 10个分片后， 只需要 10秒就可以完成任务了。</li></ul> 
<h2>5 验证水平扩容效果</h2> 
<ul><li>打包项目， 发布项目到两台测试服务器分别是 192.170.3.129 和 192.170.3.139；</li></ul> 
<pre><code class="language-bash"># 打包项目
mvn clean package -Dmaven.test.skip=true -e

# 上传到服务器
scp target/note-spring-boot-elasticjob.jar vagrant@192.170.3.129:/home/vagrant/jar/note-elasticjob

# 启动项目
java -jar -Xmx1024M -Xss100M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof -XX:+UseG1GC -Xloggc:g1-gc.log -Dspring.profiles.active=test note-spring-boot-elasticjob.jar &amp;

</code></pre> 
<ul><li>查询分片是否均匀</li></ul> 
<pre><code class="language-bash"># 查询任务是否分布均匀
grep -r -n 'elasticjob-test1' ~/logs/note-elastic-job/app/note-elastic-job.log | grep "sharding_[[:digit:]]\{1,2\}" | grep '工作完成' |  awk '{count[$6]++;} END { for(i in count) {print "分片：" i " 任务个数: " count[i]} }'|sort</code></pre> 
<blockquote> 
 <p>192.170.3.129 服务器的信息 =&gt;</p> 
 <p>分片：[sharding_0] 任务个数: 10</p> 
 <p>分片：[sharding_1] 任务个数: 10</p> 
 <p>分片：[sharding_2] 任务个数: 10</p> 
 <p>分片：[sharding_3] 任务个数: 10</p> 
 <p>分片：[sharding_4] 任务个数: 10</p> 
</blockquote> 
<blockquote> 
 <p>192.170.3.139 服务器的信息 =&gt;</p> 
 <p>分片：[sharding_5] 任务个数: 10</p> 
 <p>分片：[sharding_6] 任务个数: 10</p> 
 <p>分片：[sharding_7] 任务个数: 10</p> 
 <p>分片：[sharding_8] 任务个数: 10</p> 
 <p>分片：[sharding_9] 任务个数: 10</p> 
</blockquote> 
<ul><li>任务已经很均匀的分配到两台服务器， 水平扩容成功；</li><li>为了充分利用服务器的性能， 可以尝试增加分片数。</li></ul> 
<h2>5 总结</h2> 
<ul><li>Elastic Job 可以用于处理分布式任务调度， 使用较为简单， 也可以很轻松的进行水平扩容， 不用再担心单机性能瓶颈；</li><li>根据实际服务器的配置进行合理的调整分片个数， 充分利用服务器资源， 不是分片个数越多越好， 根据实际业务逻辑进行合理调配， 达到最佳效果；</li><li>不同分片线程需要对根据分片信息合理拆分任务， 避免重复执行， 造成性能或数据问题；</li><li>如果有数据库操作， 增加分片的同时， 也要注意数据库连接池的大小， 避免连接池不够，大量任务处理失败；</li><li>根据实际业务场景，调整 JVM 参数， 充分利用内存， CPU 算力，避免频繁 Full GC；</li><li>Demo 采用最新的 3.0.0-RC1 版本， 该版本对 JDK、 ZooKeeper、 Maven 都有版本要求， 为了达到更好的效果， 建议使用稳定版本，同时注意相关依赖的版本要求。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b2925edc116641d68adb7254748f7f5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java】log4j2-spring.xml</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac3ddf567587faea4198c1b7add0a720/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序实现跳转的几种方式总结（推荐）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>