<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>岛屿数量JAVA_算法练习帖--54--岛屿数量(Java) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="岛屿数量JAVA_算法练习帖--54--岛屿数量(Java)" />
<meta property="og:description" content="岛屿数量(DFS、BFS、并查集)
一、题目简介
给你一个由 ‘1’(陆地)和 ‘0’(水)组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
(题目来源：力扣(LeetCode))
示例 1：
输入：grid = [
[&#34;1&#34;,&#34;1&#34;,&#34;1&#34;,&#34;1&#34;,&#34;0&#34;],
[&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;1&#34;,&#34;0&#34;],
[&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;],
[&#34;0&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;]
]
输出：1
示例 2：
输入：grid = [
[&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;],
[&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;],
[&#34;0&#34;,&#34;0&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;],
[&#34;0&#34;,&#34;0&#34;,&#34;0&#34;,&#34;1&#34;,&#34;1&#34;]
]
输出：3
提示：
m == grid.length
n == grid[i].length
1 &lt;= m, n &lt;= 300
grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;
二、解决方法
1.DFS算法(Depth First Search，深度优先搜索算法)
package com.lxf.graph;
public class DFS {
//小岛数组行长度
private int ir;
//小岛数组列长度
private int ic;
public int numIslands(char[][] grid){" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3639727239a23a495513220960caaa97/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-28T12:10:46+08:00" />
<meta property="article:modified_time" content="2021-02-28T12:10:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">岛屿数量JAVA_算法练习帖--54--岛屿数量(Java)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>岛屿数量(DFS、BFS、并查集)</p> 
 <p>一、题目简介</p> 
 <p>给你一个由 ‘1’(陆地)和 ‘0’(水)组成的的二维网格，请你计算网格中岛屿的数量。</p> 
 <p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p> 
 <p>此外，你可以假设该网格的四条边均被水包围。</p> 
 <p>(题目来源：力扣(LeetCode))</p> 
 <p>示例 1：</p> 
 <p>输入：grid = [</p> 
 <p>["1","1","1","1","0"],</p> 
 <p>["1","1","0","1","0"],</p> 
 <p>["1","1","0","0","0"],</p> 
 <p>["0","0","0","0","0"]</p> 
 <p>]</p> 
 <p>输出：1</p> 
 <p>示例 2：</p> 
 <p>输入：grid = [</p> 
 <p>["1","1","0","0","0"],</p> 
 <p>["1","1","0","0","0"],</p> 
 <p>["0","0","1","0","0"],</p> 
 <p>["0","0","0","1","1"]</p> 
 <p>]</p> 
 <p>输出：3</p> 
 <p>提示：</p> 
 <p>m == grid.length</p> 
 <p>n == grid[i].length</p> 
 <p>1 &lt;= m, n &lt;= 300</p> 
 <p>grid[i][j] 的值为 '0' 或 '1'</p> 
 <p>二、解决方法</p> 
 <p>1.DFS算法(Depth First Search，深度优先搜索算法)</p> 
 <p>package com.lxf.graph;</p> 
 <p>public class DFS {<!-- --></p> 
 <p>//小岛数组行长度</p> 
 <p>private int ir;</p> 
 <p>//小岛数组列长度</p> 
 <p>private int ic;</p> 
 <p>public int numIslands(char[][] grid){<!-- --></p> 
 <p>if (grid==null||grid.length==0) {<!-- --></p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>//小岛数组行长度赋值</p> 
 <p>ir=grid.length;</p> 
 <p>//小岛数组列长度赋值</p> 
 <p>ic=grid[0].length;</p> 
 <p>//小岛数量</p> 
 <p>int numOfIsland=0;</p> 
 <p>for (int i = 0; i &lt; ir; i++) {<!-- --></p> 
 <p>for (int j = 0; j &lt; ic; j++) {<!-- --></p> 
 <p>if(grid[i][j]=='1'){<!-- --></p> 
 <p>//小岛数量加1</p> 
 <p>++numOfIsland;</p> 
 <p>//深度遍历:将连通的1全部置为0，就是找第一个1相邻的1全集，也就是一个‘小岛’</p> 
 <p>dfs(grid,i,j);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>return numOfIsland;</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* @param grid 小岛数组</p> 
 <p>* @param i 当前横坐标</p> 
 <p>* @param j 当前纵坐标</p> 
 <p>*/</p> 
 <p>private void dfs(char[][] grid, int i, int j) {<!-- --></p> 
 <p>if(i&lt;0||j&lt;0||i&gt;ir||j&gt;ic||grid[i][j]=='0'){<!-- --></p> 
 <p>//超出数组或者搜索到了0(这里就是以0为阻隔，也就是小岛周围的水)</p> 
 <p>return;</p> 
 <p>}</p> 
 <p>//搜索到一个1就直接置为0</p> 
 <p>grid[i][j]='0';</p> 
 <p>//上下左右深度搜索为1的相邻点</p> 
 <p>dfs(grid,i-1,j);</p> 
 <p>dfs(grid,i+1,j);</p> 
 <p>dfs(grid,i,j-1);</p> 
 <p>dfs(grid,i,j+1);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>BFS(Breadth First Search,广度优先搜索算法)</p> 
 <p>package com.lxf.graph;</p> 
 <p>import java.util.LinkedList;</p> 
 <p>import java.util.Queue;</p> 
 <p>public class BFS {<!-- --></p> 
 <p>public int numIslands(char[][] grid) {<!-- --></p> 
 <p>if (grid == null || grid.length == 0) {<!-- --></p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>//小岛数组行长度</p> 
 <p>int ir=grid.length;</p> 
 <p>//小岛数组列长度</p> 
 <p>int ic=grid[0].length;</p> 
 <p>//小岛数</p> 
 <p>int numOfIsland=0;</p> 
 <p>for (int i = 0; i &lt; ir; i++) {<!-- --></p> 
 <p>for (int j = 0; j &lt; ic; j++) {<!-- --></p> 
 <p>//遇到1就处理</p> 
 <p>if(grid[i][j]=='1'){<!-- --></p> 
 <p>//小岛数+1，并且当前值要置为0</p> 
 <p>++numOfIsland;</p> 
 <p>grid[i][j]='0';</p> 
 <p>//广度优先搜索辅助队列</p> 
 <p>Queue linkedList = new LinkedList&lt;&gt;();</p> 
 <p>//将当前位置的一维坐标加入队列(二维坐标转一维坐标)</p> 
 <p>linkedList.add(i*ic+j);</p> 
 <p>while (!linkedList.isEmpty()) {<!-- --></p> 
 <p>//获取当前的坐标</p> 
 <p>int coordinate=linkedList.remove();</p> 
 <p>//获取当前横坐标</p> 
 <p>int row=coordinate/ic;</p> 
 <p>//获取当前纵坐标</p> 
 <p>int column=coordinate%ic;</p> 
 <p>//从当前坐标搜索上下左右为1的坐标(且不超出数组的范围)</p> 
 <p>//相当于从当前坐标搜索周边为1的坐标组成一个小岛，搜索到0后退出</p> 
 <p>if(row-1&gt;=0&amp;&amp;grid[row-1][column]=='1'){<!-- --></p> 
 <p>linkedList.add((row-1)*ic+column);</p> 
 <p>grid[row-1][column]='0';</p> 
 <p>}</p> 
 <p>if(row+1</p> 
 <p>linkedList.add((row+1)*ic+column);</p> 
 <p>grid[row+1][column]='0';</p> 
 <p>}</p> 
 <p>if(column-1&gt;=0&amp;&amp;grid[row][column-1]=='1'){<!-- --></p> 
 <p>linkedList.add(row*ic+column-1);</p> 
 <p>grid[row][column-1]='0';</p> 
 <p>}</p> 
 <p>if(column+1</p> 
 <p>linkedList.add(row*ic+column+1);</p> 
 <p>grid[row][column+1]='0';</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>return numOfIsland;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>并查集</p> 
 <p>package com.lxf.graph;</p> 
 <p>public class MSL {<!-- --></p> 
 <p>//小岛数组行长度</p> 
 <p>private int ir;</p> 
 <p>//小岛数组列长度</p> 
 <p>private int ic;</p> 
 <p>class UnionFind{<!-- --></p> 
 <p>//统计小岛数</p> 
 <p>private int count;</p> 
 <p>//结点数组，用于指向当前结点的父结点</p> 
 <p>private int[] parent;</p> 
 <p>//存结点对应的‘秩’数组</p> 
 <p>private int[] rank;</p> 
 <p>public int getCount() {<!-- --></p> 
 <p>return count;</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* 初始化方法</p> 
 <p>* @param grid 小岛数组</p> 
 <p>*/</p> 
 <p>public UnionFind(char[][] grid) {<!-- --></p> 
 <p>count=0;</p> 
 <p>parent=new int[ir*ic];</p> 
 <p>rank=new int[ir*ic];</p> 
 <p>for (int i = 0; i &lt; ir; i++) {<!-- --></p> 
 <p>for (int j = 0; j &lt; ic; j++) {<!-- --></p> 
 <p>if(grid[i][j]=='1'){<!-- --></p> 
 <p>//将结点数组中‘1’结点的父结点指向本身</p> 
 <p>parent[i*ic+j]=i*ic+j;</p> 
 <p>//统计所有的1数目</p> 
 <p>++count;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* 合并方法</p> 
 <p>* @param x 合并第一个结点的下标</p> 
 <p>* @param y 合并第二个结点的下标</p> 
 <p>*/</p> 
 <p>public void union(int x,int y){<!-- --></p> 
 <p>//找到第一个结点的父结点</p> 
 <p>int rootx=find(x);</p> 
 <p>//找到第二个结点的父结点</p> 
 <p>int rooty=find(y);</p> 
 <p>//只有当两个结点的父结点不同时才合并</p> 
 <p>//相同时说明已经合并完毕了</p> 
 <p>if (rootx!=rooty){<!-- --></p> 
 <p>//下面三种情况都是执行操作：完全压缩路径以及按秩归并</p> 
 <p>if(rank[rootx]&gt;rank[rooty]){<!-- --></p> 
 <p>//如果第一个结点的父结点的秩大于第二个结点的父结点的秩</p> 
 <p>//直接将第二个结点的父结点等于第一个结点的父结点</p> 
 <p>parent[rooty]=rootx;</p> 
 <p>}else if(rank[rootx]</p> 
 <p>//第一种情况的相反</p> 
 <p>parent[rootx]=rooty;</p> 
 <p>}else{<!-- --></p> 
 <p>//如果两个秩相等</p> 
 <p>//第二个结点的父结点还是要等于第一个结点的父结点</p> 
 <p>//而且第一个结点的父结点的秩要+1</p> 
 <p>parent[rooty]=rootx;</p> 
 <p>rank[rootx]+=1;</p> 
 <p>}</p> 
 <p>//合并一次，小岛数量就要减一个</p> 
 <p>--count;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* 找到当前结点的父结点方法</p> 
 <p>* @param i 当前结点的下标</p> 
 <p>* @return</p> 
 <p>*/</p> 
 <p>public int find(int i){<!-- --></p> 
 <p>//如果当前结点不是指向自己，直接找他的父结点</p> 
 <p>if(parent[i]!=i){<!-- --></p> 
 <p>parent[i]=find(parent[i]);</p> 
 <p>}</p> 
 <p>return parent[i];</p> 
 <p>}</p> 
 <p>}</p> 
 <p>public int numIslands(char[][] grid) {<!-- --></p> 
 <p>if (grid==null||grid.length==0) {<!-- --></p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>//小岛数组行长度赋值</p> 
 <p>ir=grid.length;</p> 
 <p>//小岛数组列长度赋值</p> 
 <p>ic=grid[0].length;</p> 
 <p>//并查集类对象</p> 
 <p>UnionFind uf = new UnionFind(grid);</p> 
 <p>for (int i = 0; i &lt; ir; i++) {<!-- --></p> 
 <p>for (int j = 0; j &lt; ic; j++) {<!-- --></p> 
 <p>//遇到1执行操作</p> 
 <p>if(grid[i][j]=='1'){<!-- --></p> 
 <p>grid[i][j]='0';</p> 
 <p>//以当前1开始上下左右合并临近的1</p> 
 <p>if(i-1&gt;=0&amp;&amp;grid[i-1][j]=='1'){<!-- --></p> 
 <p>uf.union(i*ic+j,(i-1)*ic+j);</p> 
 <p>}</p> 
 <p>if(i+1</p> 
 <p>uf.union(i*ic+j,(i+1)*ic+j);</p> 
 <p>}</p> 
 <p>if(j-1&gt;=0&amp;&amp;grid[i][j-1]=='1'){<!-- --></p> 
 <p>uf.union(i*ic+j,i*ic+j-1);</p> 
 <p>}</p> 
 <p>if(j+1</p> 
 <p>uf.union(i*ic+j,i*ic+j+1);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>return uf.getCount();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>标签：结点,Java,--,54,int,grid,小岛,ic,row</p> 
 <p>来源： https://blog.csdn.net/Inmaturity_7/article/details/113129090</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed6417cccc91b4b893a6f68ac890f8fb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql用户关注店铺表_求助微博关注用户表的设计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d1718b56694fd8bf62559a39dc27a814/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">tmp在java中的意思_tmp是什么文件？tmp文件用什么打开？图文讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>