<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何用Java实现KMP字符串匹配算法？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何用Java实现KMP字符串匹配算法？" />
<meta property="og:description" content="KMP算法是一种高效的字符串匹配算法，用于在一个主串中查找一个模式串的出现位置。它通过利用已经匹配过的字符信息，避免不必要的回溯操作，提高了匹配的效率。
KMP算法的核心思想是构建一个最大公共前后缀表（也称为部分匹配表），根据该表在匹配过程中确定模式串向后移动的位置。下面将详细介绍KMP算法的实现步骤和Java代码。
一、构建最大公共前后缀表
最大公共前后缀表是一个长度与模式串相等的数组，用于存储每个位置对应的最大公共前后缀长度。具体的构建方法如下：
1、初始化最大公共前后缀表为一个与模式串长度相同的数组，默认值都为0。
2、从第二个位置开始遍历模式串，依次计算每个位置对应的最大公共前后缀长度。
1）、假设当前位置为i，已知前i-1个位置的最大公共前后缀长度为prefixLen[i-1]。
2）、如果模式串的第prefixLen[i-1]个字符与模式串的第i个字符相等，则最大公共前后缀长度为prefixLen[i-1]&#43;1。
3）、否则，继续往前查找长度为prefixLen[i-1]的最大公共前后缀，直到找到相等的字符或长度为0。
4）、更新prefixLen[i]为找到的最大公共前后缀的长度。
以下是使用Java代码实现构建最大公共前后缀表的函数：
private int[] buildPrefixTable(String pattern) { int[] prefixLen = new int[pattern.length()]; prefixLen[0] = 0; int len = 0; int i = 1; while (i &lt; pattern.length()) { if (pattern.charAt(i) == pattern.charAt(len)) { len&#43;&#43;; prefixLen[i] = len; i&#43;&#43;; } else { if (len != 0) { len = prefixLen[len - 1]; } else { prefixLen[i] = 0; i&#43;&#43;; } } } return prefixLen; } 二、KMP算法的匹配过程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ef1e4324046d7205aa31d8492977f1c2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-10T08:47:07+08:00" />
<meta property="article:modified_time" content="2023-07-10T08:47:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何用Java实现KMP字符串匹配算法？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>KMP算法是一种高效的字符串匹配算法，用于在一个主串中查找一个模式串的出现位置。它通过利用已经匹配过的字符信息，避免不必要的回溯操作，提高了匹配的效率。</p> 
<p>KMP算法的核心思想是构建一个最大公共前后缀表（也称为部分匹配表），根据该表在匹配过程中确定模式串向后移动的位置。下面将详细介绍KMP算法的实现步骤和Java代码。</p> 
<p>一、构建最大公共前后缀表</p> 
<p>最大公共前后缀表是一个长度与模式串相等的数组，用于存储每个位置对应的最大公共前后缀长度。具体的构建方法如下：</p> 
<p>1、初始化最大公共前后缀表为一个与模式串长度相同的数组，默认值都为0。</p> 
<p>2、从第二个位置开始遍历模式串，依次计算每个位置对应的最大公共前后缀长度。</p> 
<p>1）、假设当前位置为i，已知前i-1个位置的最大公共前后缀长度为prefixLen[i-1]。</p> 
<p>2）、如果模式串的第prefixLen[i-1]个字符与模式串的第i个字符相等，则最大公共前后缀长度为prefixLen[i-1]+1。</p> 
<p>3）、否则，继续往前查找长度为prefixLen[i-1]的最大公共前后缀，直到找到相等的字符或长度为0。</p> 
<p>4）、更新prefixLen[i]为找到的最大公共前后缀的长度。</p> 
<p>以下是使用Java代码实现构建最大公共前后缀表的函数：</p> 
<pre><code>private int[] buildPrefixTable(String pattern) {
    int[] prefixLen = new int[pattern.length()];
    prefixLen[0] = 0;

    int len = 0;
    int i = 1;

    while (i &lt; pattern.length()) {
        if (pattern.charAt(i) == pattern.charAt(len)) {
            len++;
            prefixLen[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = prefixLen[len - 1];
            } else {
                prefixLen[i] = 0;
                i++;
            }
        }
    }

    return prefixLen;
}
</code></pre> 
<p></p> 
<p></p> 
<p>二、KMP算法的匹配过程</p> 
<p>KMP算法的匹配过程分为主串与模式串的对比和模式串的后移两个步骤。具体的实现如下：</p> 
<p>1、初始化一个指针i指向主串的第一个位置，一个指针j指向模式串的第一个位置。</p> 
<p>2、在匹配过程中，一直循环直到到达主串的末尾或找到了一个匹配的位置。</p> 
<p>1）、如果主串的第i个字符与模式串的第j个字符相等，则同时将i和j都向后移动一位。</p> 
<p>2）、如果j已经到达模式串的末尾，说明找到了一个匹配的位置，将该位置记录下来（可以是存储到一个List中或直接打印）。</p> 
<p>3）、如果主串的第i个字符与模式串的第j个字符不相等：根据最大公共前后缀表，将模式串向右移动j - prefixLen[j-1]位。如果prefixLen[j-1]为0，则将模式串向右移动一位。注意：主串的指针i不需要回溯，继续与新的j进行对比。</p> 
<p>以下是使用Java代码实现KMP算法的匹配过程：</p> 
<pre><code>public List&lt;Integer&gt; kmpMatch(String text, String pattern) {
    List&lt;Integer&gt; positions = new ArrayList&lt;&gt;();
    int n = text.length();
    int m = pattern.length();
    int[] prefixLen = buildPrefixTable(pattern);

    int i = 0; // 主串指针
    int j = 0; // 模式串指针

    while (i &lt; n) {
        if (text.charAt(i) == pattern.charAt(j)) {
            i++;
            j++;
        }

        if (j == m) { // 找到一个匹配位置
            positions.add(i - j);
            j = prefixLen[j - 1];
        } else if (i &lt; n &amp;&amp; text.charAt(i) != pattern.charAt(j)) {
            if (j != 0) {
                j = prefixLen[j - 1];
            } else {
                i++;
            }
        }
    }

    return positions;
}
</code></pre> 
<p>三、KMP算法的应用举例</p> 
<p>使用KMP算法，我们可以在一个主串中高效地查找一个模式串的出现位置。以下是一个简单的示例代码：</p> 
<pre><code>public static void main(String[] args) {
    String text = "ABABDABACDABABCABAB";
    String pattern = "ABABCABAB";
    List&lt;Integer&gt; positions = kmpMatch(text, pattern);
    System.out.println("Pattern found at positions: " + positions);
}
</code></pre> 
<p>输出结果为：Pattern found at positions: [10]</p> 
<p>表示在主串text的位置10处找到了与模式串pattern相匹配的子串。</p> 
<p>KMP算法的时间复杂度为O(n+m)，其中n为主串的长度，m为模式串的长度。相对于简单的暴力匹配算法，KMP算法具有更高的效率和优化性能。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ef40169a173e0a8f29dfbab90db5f5a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux下查看cpu个数，核数，线程数, GPU，内存</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/981c9acffcd0d694a890f2712f471e15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">客户端证书身份验证</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>