<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Token和Refresh Token - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Token和Refresh Token" />
<meta property="og:description" content="一、Token 在计算机身份认证中代表令牌，在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位。
1.1、Jwt简介 JWT(JSON Web Token)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。
它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证；应用场景如用户登录。
1.2、为什么有Jwt 目前主流的Web开发模式有两种：
基于服务端渲染的传统Web开发模式基于前后端分离的新型Web开发模式 对于这两种开发模式的身份认证，服务端渲染推荐使用 Session认证机制，前后端分离推荐使用JWT认证机制。
对于传统的session认证，因为HTTP是无协议的，为了记住用户状态，服务器在用户第一次访问时会返回一个cookie同时服务端保存一个对应的session，但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，大量session会话的创建对服务器是一个巨大的开销；
同时，当服务端为集群时，用户登录其中一台服务器，会将session保存在该服务器的内存中，
只有再次访问这台服务器才能拿到授权资源。
另外session认证机制依赖Cookie，但是Cookie默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域Session认证。这就有了JWT的出现，流程上是这样的：
用户使用用户名密码来请求服务器服务器进行验证用户的信息服务器通过验证发送给用户一个token客户端存储token，并在每次请求时附送上这个token值服务端验证token值，并返回数据 1.3、Jwt Token结构 JWT由三部分构成，第一部分我们称它为头部（header),第二部分我们称其为载荷（payload)，第三部分是签证（signature)。
header：Header通常由两部分组成：令牌的类型，即JWT。和常用的散列算法，如HMAC SHA256或RSA。 {
“typ”: “JWT”,
“alg”: “HS256”
}
由上可知，该token使用HS256加密算法，将头部进行base64加密（该加密是可以对称解密的)，构成了第一部分：
eyJhbGciOiJIUzI1NiJ91
Playload：载荷就是存放有效信息的地方，这些有效信息包含三个部分
1、 Registered claims（注册声明）: 这些是一组预先定义的声明，它们不是强制性的，但推荐使用，以提供一组有用的，可互操作的声明。 其中一些是：iss（发行者），exp（到期时间），sub（主题），aud（受众）等
2、Public claims （公开声明）: 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。
3、Private claims（私有声明）: 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。
{
“iss”: “Online JWT Builder”,
“iat”: 1416797419,
“exp”: 1448333419,
…….
“userid”:10001
}
有效载荷中存放了token的签发者（iss）、签发时间（iat）、过期时间（exp）等以及一些我们需要写进token中的信息。然后将其进行base64加密，得到Jwt的第二部分：
eyJ1c2VyaWQiOjB91
Signature：这个部分需要base64加密后的header和base64加密后的payload使用，连接组成的字符串(头部在前)，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。 例如头部与载体加密拼接后的字符串为eyJhbGciOiJIUzI1NiJ91.eyJ1c2VyaWQiOjB91再次利用加密算法（HS256）与自定义的密钥（secret）加密得到签名部分字符：
rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
将上面三个方法生成的字符串再次拼接就得到了完整的Token:
eyJhbGciOiJIUzI1NiJ91.eyJ1c2VyaWQiOjB91.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token
1.4、JWT的优缺点 优点：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f3fba7d9b666bbc159c4acb91f9e69fe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-19T10:20:27+08:00" />
<meta property="article:modified_time" content="2023-02-19T10:20:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Token和Refresh Token</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Token_0"></a>一、Token</h2> 
<p>在计算机身份认证中代表令牌，在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位。</p> 
<h3><a id="11Jwt_3"></a>1.1、Jwt简介</h3> 
<p>JWT(JSON Web Token)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。</p> 
<p>它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证；应用场景如用户登录。</p> 
<h3><a id="12Jwt_8"></a>1.2、为什么有Jwt</h3> 
<blockquote> 
 <p>目前主流的Web开发模式有两种：</p> 
 <ul><li>基于服务端渲染的传统Web开发模式</li><li>基于前后端分离的新型Web开发模式</li></ul> 
</blockquote> 
<p>对于这两种开发模式的身份认证，服务端渲染推荐使用 Session认证机制，前后端分离推荐使用JWT认证机制。</p> 
<p>对于传统的session认证，因为HTTP是无协议的，为了记住用户状态，服务器在用户第一次访问时会返回一个cookie同时服务端保存一个对应的session，但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，大量session会话的创建对服务器是一个巨大的开销；</p> 
<p>同时，当服务端为集群时，用户登录其中一台服务器，会将session保存在该服务器的内存中，<br> 只有再次访问这台服务器才能拿到授权资源。</p> 
<p>另外session认证机制依赖Cookie，但是Cookie默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域Session认证。这就有了JWT的出现，流程上是这样的：</p> 
<ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据</li></ul> 
<p><img src="https://images2.imgbox.com/c1/b5/GkRpMcan_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="13Jwt_Token_32"></a>1.3、Jwt Token结构</h3> 
<p>JWT由三部分构成，第一部分我们称它为头部（header),第二部分我们称其为载荷（payload)，第三部分是签证（signature)。</p> 
<ul><li><strong>header</strong>：Header通常由两部分组成：令牌的类型，即JWT。和常用的散列算法，如HMAC SHA256或RSA。</li></ul> 
<blockquote> 
 <p>{<!-- --><br> “typ”: “JWT”,<br> “alg”: “HS256”<br> }<br> 由上可知，该token使用HS256加密算法，将头部进行base64加密（该加密是可以对称解密的)，构成了第一部分：<br> eyJhbGciOiJIUzI1NiJ91</p> 
</blockquote> 
<ul><li> <p><strong>Playload</strong>：载荷就是存放有效信息的地方，这些有效信息包含三个部分</p> <p>1、 <strong>Registered claims</strong>（注册声明）: 这些是一组预先定义的声明，它们不是强制性的，但推荐使用，以提供一组有用的，可互操作的声明。 其中一些是：iss（发行者），exp（到期时间），sub（主题），aud（受众）等<br> 2、<strong>Public claims</strong> （公开声明）: 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。<br> 3、<strong>Private claims</strong>（私有声明）: 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p> </li></ul> 
<blockquote> 
 <p>{<!-- --><br> “iss”: “Online JWT Builder”,<br> “iat”: 1416797419,<br> “exp”: 1448333419,<br> …….<br> “userid”:10001<br> }<br> 有效载荷中存放了token的签发者（iss）、签发时间（iat）、过期时间（exp）等以及一些我们需要写进token中的信息。然后将其进行base64加密，得到Jwt的第二部分：<br> eyJ1c2VyaWQiOjB91</p> 
</blockquote> 
<ul><li><strong>Signature</strong>：这个部分需要base64加密后的header和base64加密后的payload使用，连接组成的字符串(头部在前)，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。</li></ul> 
<blockquote> 
 <p>例如头部与载体加密拼接后的字符串为eyJhbGciOiJIUzI1NiJ91.eyJ1c2VyaWQiOjB91再次利用加密算法（HS256）与自定义的密钥（secret）加密得到签名部分字符：<br> rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM<br> 将上面三个方法生成的字符串再次拼接就得到了完整的Token:<br> eyJhbGciOiJIUzI1NiJ91.eyJ1c2VyaWQiOjB91.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</p> 
</blockquote> 
<p>如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token</p> 
<h3><a id="14JWT_69"></a>1.4、JWT的优缺点</h3> 
<ul><li> <p><strong>优点</strong>：<br> 1、因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。<br> 2、payload可以在自身存储一些其他业务逻辑所必要的非敏感信息。<br> 3、它不需要在服务端保存会话信息, 所以它易于应用的扩展</p> </li><li> <p><strong>缺点</strong>：<br> 1、安全性：由于JWT的payload是使用Base64编码的，并没有加密，因此JWT中不能存储敏感数据。而Session的信息是存在服务端的，相对来说更安全。<br> 2、一次性：无状态是JWT的特点，但也导致了这个问题，JWT是一次性的。想修改里面的内容，就必须签发一个新的JWT。即缺陷是一旦下发，服务后台无法拒绝携带该jwt的请求（如踢除用户）</p> </li></ul> 
<h2><a id="Refresh_Token_79"></a>二、Refresh Token</h2> 
<p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位，而Token的playload部分一般会存储相关的过期时间，一旦Token过期就会被拦截，因此如何设置Token刷新机制也是一个重点。</p> 
<p>过长的过期时间会让系统有长期暴露在接口的风险，理论上过期时间越短越好，但是过短的时间明显会带来不好的用户体验。那么我们可以考虑使用Refresh Token刷新，一旦 Token 过期，就反馈给前端，前端使用 Refresh Token 申请一个全新 Token 继续使用。</p> 
<p>这种方案中，服务端只需要在客户端请求更新 Token 的时候对 Refresh Token 的有效性进行一次检查，大大减少了更新有效期的操作，也就避免了频繁读写。</p> 
<h3><a id="21_86"></a>2.1、实现原理</h3> 
<p>前端第一次发起请求时，后端准备两个 token，一个有效时间较短的作为认证 token（token），一个有效时间较长的作为刷新 token（refreshToken），返回给前端。</p> 
<p>前端拿到两个 token 后，把它们都存储在 localStorage 中，后面再次发起请求时携带两个token：</p> 
<ul><li>token 未过期时，可以正常请求。</li><li>token 过期了，refreshToken 未过期，请求后端的刷新token接口对两个token进行更新并返回给前端。</li><li>token 和 refreshToken 均过期了，则用户必须重新登录。</li></ul> 
<h3><a id="22_96"></a>2.2、代码实现</h3> 
<p><strong>demo:</strong><br> <a href="https://github.com/robinsyn/jwt-refresh_token-demo.git">Token refresh的实现</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd44794a9fb0d9f36b780a24236c1518/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">帮我写一篇关于基于51单片机的智能温控风扇的论文</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/faf1d3b8b3a46ca7edaa167c0bbb3038/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot操作elasticsearch</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>