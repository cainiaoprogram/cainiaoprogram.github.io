<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JPEG图像压缩优化-算术编码 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JPEG图像压缩优化-算术编码" />
<meta property="og:description" content="转载自：(https://blog.csdn.net/shelldon/article/details/54234436)
开场白 JPEG使用了量化、Huffman编码等，极大地压缩了图片的大小。DropBox开源的lepton，在JPEG基础上，可以再节省22%左右的空间。lepton中使用算术编码（VP8）替换Huffman编码，以得到更高的压缩率。
算术编码（Arithmetic Coding）发展历史 1948年，香农提出将信源符号依其概率降序排序，用符号序列累计的二进制作为对信源数据的编码。
1960年，Peter Elias发现无需排序，只要编解码端使用相同的符号顺序即可，提出了算术编码的概念。
1967年，R. Pasco和J. Rissanen分别用丁昌德寄存器实现了有限精度的算术编码。
1979年，Rissanen和G. G. Langdon一起将算术编码系统化，并于1981年实现了二进制编码。
1987年，Witten等人发表了一个实用的算术编码程序，即CACM87，后用于ITUT的H.263视频压缩标准。同期，IMB公司发表了著名的Q-编码器，后用于JPEG和JBIG图像压缩标准。
算术编码介绍 无损数据压缩，熵编码。
一般熵编码把输入的消息分割为符号，然后对每个符号进行编码。算术编码是将整个要编码的数据映射到一个位于[0,1)的实数区间，这样可以让压缩率无线地接近数据的熵值，从而获得理论上的最高压缩率。
算术编码用到的两个基本参数：符号的概率和它的编码间隔。信源符号的概率决定压缩编码的效率，也决定编码过程汇总信源符号的间隔，而这些间隔包含在0到1之间。编码过程中的间隔决定了符号压缩输出后的输出。
算术编码可以是静态的或者自适应的。
在静态算术编码中，信源符号的概率是固定的。在自适应算术编码中，信源符号的概率根据编码时符号出现的频繁程度动态地进行修改，在编码期间估算信源符号概率的过程叫做建模。
需要开发动态算术编码的原因是，很难知道精确的信源概率。在压缩消息时，不能期待一个算术编码器获得最大的概率，所能做的最有效的方法是在编码过程中估算概率。因此动态建模就成为确定编码器压缩效率的关键。
算术编码思想 算术编码的基本原理是将编码的消息表示成实数０和１之间的一个间隔（Interval），消息越长，编码表示它的间隔就越小，表示这一间隔所需的二进制位就越多。
算术编码进行编码时，从实数区间[0,1)开始，按照符号的频度将当前的区间分割成多个子区间。根据当前输入的符号选择对应的子区间，然后从选择的子区间中继续进行下一轮的分割。不断的进行这个过程，直到所有符号编码完毕。对于最后选择的一个子区间，输出属于该区间的一个小数。这个小数就是所有数据的编码。
给定事件序列的算术编码步骤如下：
编码器在开始时将 “当前间隔 ” [ L， H) 设置为 [0， 1)。对每一个输入事件，编码器按下边的步骤（ a）和（ b）进行处理。
（a）编码器将“ 当前间隔”分为子间隔，每一个事件一个。一个子间隔的大小与将出现的事件的概率成正比。
（b）编码器选择与下一个发生事件相对应的子间隔，并使它成为新的 “当前间隔 ”。最后输出的 “当前间隔 ”的下边界就是该给定事件序列的算术编码。 在算术编码中需要注意几个问题：
由于实际计算机的精度不可能无限长，运算中出现溢出是一个明显的问题，但多数及其都有 16位， 32位或者 64位的精度，因此这个问题可以使用比例缩放方法解决。算术编码器对整个消息只产生一个码字，这个码字是在间隔[0,1)中的一个实数，因此译码器在接受到表示这个实数的所有位之前不能进行译码。算术编码是一种对错误很敏感的编码方法，如果有一位发生错误就会导致整个消息译错。 算术编码伪代码 定义一些变量，设 Low和 High分别表示 “当前间隔 ”的下边界和上边界；CodeRange为编码间隔的长度，即&#34;当前间隔 &#34;的长度；LowRange(symbol)和HighRange(symbol) 分别代表为了事件 symbol的编码间隔下边界和上边界。
如果symbol的编码间隔固定不变，则为静态编码；反之，如果 symbol的编码间隔随输入事件动态变化，则为自适应编码。
算术编码的编码过程可用伪代码描述如下：
set Low to 0 set High to 1 while there are input symbols do take a symbol CodeRange = High – Low High = Low &#43; CodeRange *HighRange(symbol) Low = Low &#43; CodeRange * LowRange(symbol) end of while output Low 算术编码解码过程用伪代码描述如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3e23c57f645f67e2bc3d743b7ba52690/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-01T15:03:56+08:00" />
<meta property="article:modified_time" content="2019-03-01T15:03:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JPEG图像压缩优化-算术编码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>转载自：(<a href="https://blog.csdn.net/shelldon/article/details/54234436">https://blog.csdn.net/shelldon/article/details/54234436</a>)</p> 
<h6><a id="_1"></a>开场白</h6> 
<p>JPEG使用了量化、Huffman编码等，极大地压缩了图片的大小。DropBox开源的lepton，在JPEG基础上，可以再节省22%左右的空间。lepton中使用算术编码（VP8）替换Huffman编码，以得到更高的压缩率。</p> 
<h6><a id="Arithmetic_Coding_3"></a>算术编码（Arithmetic Coding）发展历史</h6> 
<p>1948年，香农提出将信源符号依其概率降序排序，用符号序列累计的二进制作为对信源数据的编码。<br> 　　1960年，Peter Elias发现无需排序，只要编解码端使用相同的符号顺序即可，提出了算术编码的概念。<br> 　　1967年，R. Pasco和J. Rissanen分别用丁昌德寄存器实现了有限精度的算术编码。<br> 　　1979年，Rissanen和G. G. Langdon一起将算术编码系统化，并于1981年实现了二进制编码。<br> 　　1987年，Witten等人发表了一个实用的算术编码程序，即CACM87，后用于ITUT的H.263视频压缩标准。同期，IMB公司发表了著名的Q-编码器，后用于JPEG和JBIG图像压缩标准。</p> 
<h6><a id="_9"></a>算术编码介绍</h6> 
<p>无损数据压缩，熵编码。<br> 　　一般熵编码把输入的消息分割为符号，然后对每个符号进行编码。算术编码是将整个要编码的数据映射到一个位于[0,1)的实数区间，这样可以让压缩率无线地接近数据的熵值，从而获得理论上的最高压缩率。<br> 　　算术编码用到的两个基本参数：符号的概率和它的编码间隔。信源符号的概率决定压缩编码的效率，也决定编码过程汇总信源符号的间隔，而这些间隔包含在0到1之间。编码过程中的间隔决定了符号压缩输出后的输出。<br> 　　算术编码可以是静态的或者自适应的。<br> 　　在静态算术编码中，信源符号的概率是固定的。在自适应算术编码中，信源符号的概率根据编码时符号出现的频繁程度动态地进行修改，在编码期间估算信源符号概率的过程叫做建模。<br> 　　需要开发动态算术编码的原因是，很难知道精确的信源概率。在压缩消息时，不能期待一个算术编码器获得最大的概率，所能做的最有效的方法是在编码过程中估算概率。因此动态建模就成为确定编码器压缩效率的关键。</p> 
<h6><a id="_16"></a>算术编码思想</h6> 
<p>算术编码的基本原理是将编码的消息表示成实数０和１之间的一个间隔（Interval），消息越长，编码表示它的间隔就越小，表示这一间隔所需的二进制位就越多。<br> 　　算术编码进行编码时，从实数区间[0,1)开始，按照符号的频度将当前的区间分割成多个子区间。根据当前输入的符号选择对应的子区间，然后从选择的子区间中继续进行下一轮的分割。不断的进行这个过程，直到所有符号编码完毕。对于最后选择的一个子区间，输出属于该区间的一个小数。这个小数就是所有数据的编码。<br> 　　<br> 　　给定事件序列的算术编码步骤如下：</p> 
<ol><li>编码器在开始时将 “当前间隔 ” [ L， H) 设置为 [0， 1)。</li><li>对每一个输入事件，编码器按下边的步骤（ a）和（ b）进行处理。<br> （a）编码器将“ 当前间隔”分为子间隔，每一个事件一个。一个子间隔的大小与将出现的事件的概率成正比。<br> （b）编码器选择与下一个发生事件相对应的子间隔，并使它成为新的 “当前间隔 ”。</li><li>最后输出的 “当前间隔 ”的下边界就是该给定事件序列的算术编码。</li></ol> 
<p>在算术编码中需要注意几个问题：</p> 
<ol><li>由于实际计算机的精度不可能无限长，运算中出现溢出是一个明显的问题，但多数及其都有 16位， 32位或者 64位的精度，因此这个问题可以使用比例缩放方法解决。</li><li>算术编码器对整个消息只产生一个码字，这个码字是在间隔[0,1)中的一个实数，因此译码器在接受到表示这个实数的所有位之前不能进行译码。</li><li>算术编码是一种对错误很敏感的编码方法，如果有一位发生错误就会导致整个消息译错。</li></ol> 
<h6><a id="_31"></a>算术编码伪代码</h6> 
<p>定义一些变量，设 Low和 High分别表示 “当前间隔 ”的下边界和上边界；CodeRange为编码间隔的长度，即"当前间隔 "的长度；LowRange(symbol)和HighRange(symbol) 分别代表为了事件 symbol的编码间隔下边界和上边界。<br> 　　如果symbol的编码间隔固定不变，则为静态编码；反之，如果 symbol的编码间隔随输入事件动态变化，则为自适应编码。<br> 　　算术编码的编码过程可用伪代码描述如下：</p> 
<pre><code>set Low to 0
set High to 1
while there are input symbols do
    take a symbol
    CodeRange = High – Low
    High = Low + CodeRange *HighRange(symbol)
    Low = Low + CodeRange * LowRange(symbol)
end of while
output Low
</code></pre> 
<p>算术编码解码过程用伪代码描述如下：</p> 
<pre><code>get encoded number
do
    find symbol whose range straddles the encoded number
    output the symbol
    range = symbo.LowValue – symbol.HighValue
    substract symbol.LowValue from encoded number
    divide encoded number by range
until no more symbols
</code></pre> 
<h6><a id="_57"></a>静态的算术编码</h6> 
<p>算术编码器的编码解码过程可用例子演示和解释。<br> 　　例1：假设信源符号为 {A，B，C，D} ，这些符号的概率分别为 { 0.1，0.4，0.2，0.3 }，根据这些概率可把间隔 [0，1]分成 4个子间隔：[0，0.1]， [0.1，0.5]， [0.5，0.7]， [0.7，1]，其中 [x，y]表示半开放间隔，即包含 x不包含 y。上面的信息如下表。</p> 
<table><thead><tr><th>符号</th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>概率</td><td>0.1</td><td>0.4</td><td>0.2</td><td>0.3</td></tr><tr><td>初始编码间隔</td><td>[ 0, 0.1 )</td><td>[ 0.1, 0.5 )</td><td>[ 0.5, 0.7 )</td><td>[ 0.7, 1 ]</td></tr></tbody></table> 
<p>如果二进制消息序列的输入为： C A D A C D B。<br> 　　编码时首先输入的符号是C，找到它的编码范围是[0.5，0.7]。由于消息中第二个符号A的编码范围是[0，0.1]，因此它的间隔就取[0.5，0.7]的第一个十分之一作为新间隔[0.5，0.52]。<br> 　　依此类推，编码第3个符号D时取新间隔为[0.514，0.52]，编码第4个符号A时，取新间隔为[0.514，0.5146]， …。<br> 　　消息的编码输出可以是最后一个间隔中的任意数。整个编码过程如下图所示。<br> <img src="https://images2.imgbox.com/24/c5/O8He0iLT_o.gif" alt="图　算术编码过程举例"><br> 　　取一个 (0.5143876~0.514402)之间的数：0.5143876，(0.5143876)D≈ (0.1000001)B，去掉小数点和前面的 0，得 1000001。所以： cadacdb的编码 =1000001，长度为 7。<br> 　　编码和译码的全过程分别表示如下。</p> 
<table><thead><tr><th>步骤</th><th>输入符号</th><th>编码间隔</th><th>编码判决</th></tr></thead><tbody><tr><td>1</td><td>C</td><td>[0.5， 0.7]</td><td>符号的间隔范围[0.5， 0.7]</td></tr><tr><td>2</td><td>A</td><td>[0.5， 0.52]</td><td>[0.5， 0.7]间隔的第1个1/10</td></tr><tr><td>3</td><td>D</td><td>[0.514， 0.52]</td><td>[0.5， 0.52]间隔的最后1个3/10</td></tr><tr><td>4</td><td>A</td><td>[0.514， 0.5146]</td><td>[0.514， 0.52]间隔的第1个1/10</td></tr><tr><td>5</td><td>C</td><td>[0.5143， 0.51442]</td><td>[0.514， 0.5146]间隔的第五个1/10开始，1个2/10</td></tr><tr><td>6</td><td>D</td><td>[0.514384， 0.51442]</td><td>[0.5143， 0.51442]间隔的最后1个3/10</td></tr><tr><td>7</td><td>B</td><td>[0.5143876， 0.514402]</td><td>[0.514384，0.51442]间隔的第2个1/10开始,1个4/10</td></tr><tr><td>8</td><td></td><td></td><td>从[0.5143876， 0.514402]中选择一个数作为输出：0.5143876</td></tr></tbody></table> 
<table><thead><tr><th>步骤</th><th>间隔</th><th>译码符号</th><th>译码判决</th></tr></thead><tbody><tr><td>1</td><td>[0.5， 0.7]</td><td>C</td><td>0.5143876在间隔 [0.5， 0.7)</td></tr><tr><td>2</td><td>[0.5， 0.52]</td><td>A</td><td>0.5143876在间隔 [0.5， 0.7)的第1个1/10里</td></tr><tr><td>3</td><td>[0.514， 0.52]</td><td>D</td><td>0.5143876在间隔[0.5， 0.52)的第7个1/10后</td></tr><tr><td>4</td><td>[0.514， 0.5146]</td><td>A</td><td>0.5143876在间隔[0.514， 0.52]的第1个1/10里</td></tr><tr><td>5</td><td>[0.5143， 0.51442]</td><td>C</td><td>0.5143876在间隔[0.514， 0.5146]的第5个1/10后</td></tr><tr><td>6</td><td>[0.514384， 0.51442]</td><td>D</td><td>0.5143876在间隔[0.5143， 0.51442]的第7个1/10后</td></tr><tr><td>7</td><td>[0.5143836， 0.514402]</td><td>B</td><td>0.5143876在间隔[0.514384，0.51442]的第1个1/10后</td></tr><tr><td>8</td><td></td><td></td><td>译码的消息：C A D A C D B</td></tr></tbody></table> 
<p>在上面的例子中，我们假定编码器和译码器都知道消息的长度，因此译码器的译码过程不会无限制地运行下去。实际上在译码器中需要添加一个专门的终止符，当译码器看到终止符时就停止译码。</p> 
<h6><a id="_93"></a>算术编码压缩率高</h6> 
<p>算术编码可以对一个二进制序列进一步编码，得到比原序列更小的编码结果。例如，假设二进制序列信源符号为 {1,0} ，如果消息序列的输入为 1101 。则符号 1和 0的概率分别为 : 符号 1的概率 3/4，符号 0的概率 1/4 。整个编码过程如图所示。<br> <img src="https://images2.imgbox.com/0f/ac/xzSmLhZr_o.gif" alt="在这里插入图片描述"><br> 　　算术编码的结果：<br> 　　下界=121/256 ，即0.47265625 或二进制0.0111；<br> 　　上界为37/64 ，即0.578125 或二进制0.10010。<br> 　　在该区间范围内任取一个数，例如 0.5（对应二进制 0.1），只取小数点后边的部分，即 1。这样，原来的1101 序列就可以用编码 1来代替。</p> 
<h6><a id="_100"></a>自适应的算术编码</h6> 
<p>自适应模型中，在编码开始时，各个符号出现的概率相同，都为 1/n。随着编码的进行再更新出现概率。另外，在计算时理论上要使用无限小数。这里为了说明方便，四舍五入到小数点后 4位。<br> 　　举个例子来说明自适应算术编码。假设一份数据由“A” 、“B” 、“C” 三个符号组成。现在要编码数据 “BCCB”，编码过程如图所示。<br> <img src="https://images2.imgbox.com/d3/44/7YvbyDN5_o.png" alt="在这里插入图片描述"></p> 
<ol><li>算术编码是从区间[0,1)开始。这时三个符号的概率都是 1/3，按照这个概率分割区间。</li><li>第一个输入的符号是“B”，所以我们选择子区间 [0.3333,0.6667)作为下一个区间。</li><li>输入“B” 后更新概率，根据新的概率对区间 [0.3333,0.6667)进行分割。</li><li>第二个输入的符号是“C”，选择子区间 [0.5834,0.6667)。</li><li>以此类推，根据输入的符号继续更新频度、分割 区间、选择子区间，直到符号全部编码完成。</li></ol> 
<p>我们最后得到的区间是[0.6390,0.6501)。输出属于这个区间的一个小数，例如 0.64。那么经过算术编码的压缩，数据 “BCCB”最后输出的编码就是 0.64。我们最后得到的区间是[0.6390,0.6501)。输出属于这个区间的一个小数，例如 0.64。那么经过算术编码的压缩，数据 “BCCB”最后输出的编码就是 0.64。</p> 
<h6><a id="_111"></a>自适应模型的解码</h6> 
<p>算术编码进行解码时仅输入一个小数。整个过程相当于编码时的逆运算。解码过程是这样：</p> 
<ol><li>解码前首先需要对区间 [0,1)按照初始时的符号频度进行分割，然后观察输入的小数位于哪个子区间，输出对应的符号。</li><li>之后选择对应的子区间，然后从选择的子区间中继续进行下一轮的分割。</li><li>不断的进行这个过程，直到所有的符号都解码出来。</li></ol> 
<p>在我们的例子中，输入的小数是 0.64。</p> 
<ol><li>初始时三个符号的概率都是 1 / 3，按照这个概率分割区间。</li><li>根据上图可以发现0.64落在子区间 [0.3333,0.6667)中，于是可以解码出 “B”，并且选择子区间 [0.3333,0.6667)作为下一个区间。</li><li>输出“B” 后更新频度，根据新的概率对区间 [0.3333,0.6667)进行分割。</li><li>这时0.64 落在子 区间 [0.5834,0.6667)中，于是可以解码出 “C”。</li><li>按照上述过程进行，直到所有的符号都解码出来。</li></ol> 
<p>可见，只需要一个小数就可以完整还原出原来的所有数据。</p> 
<h6><a id="_125"></a>自适应模型的整数编码方式</h6> 
<p>上边介绍的编码都是得到一个[0,1)内的小数，下面说明整数编码方式，以8位编码为例，阐述算术编码和解码过程 。<br> 　　例如对字符串"ababcab"进行编解码，最终得到8位编码。<br> 确定上下界：由于8位的取值范围是[0,255]，因此下界为0，上界为255 。<br> 　　符号概率：编码开始时，a、b、c的出现概率都是1/3 。</p> 
<h6><a id="_130"></a>编码过程</h6> 
<p>1.“ababcab” 第1 个字符为a，初始化时三个字符出现概率相同，因此 a的编码间隔为 [0,1/3]，即 LowRange(a) = 0, HighRange(a) = 1/3<br> 2.更新上下界的值为 [0, 85]，根据伪代码：</p> 
<pre><code>CodeRange = High – Low
High = Low + CodeRange *HighRange(symbol)
Low = Low + CodeRange * LowRange(symbol)
</code></pre> 
<p>计算得到：</p> 
<pre><code>CodeRange = 255 - 0 = 255
High = 0 + 255 * 1/3 = 85
Low = 0 + 255 * 0 = 0
</code></pre> 
<p>此时各个符号的编码间隔动态调整为?️[0,2/4]，b:[2/4,3/4]，c:[3/4,1]。<br> 3."ababcab"第2个字符为b ，取编码间隔[2/4, 3/4]，并更新上下界：</p> 
<pre><code>CodeRange = 85 - 0 = 85
High = 0 + 85 * 3/4 = 63   （向下取整）
Low = 0 + 85 * 2/4 = 43   （向上取整）
</code></pre> 
<p>4.同理可得到 “ababcab"第3、4个字符a 、b的编码。<br> 5.计算"ababcab” 第5个字符c的编码，此时 High=49，Low=49。因为是有限整数，每次又是取的上一区间的子区间 ,high和low趋于相等是必然的。<br> <img src="https://images2.imgbox.com/ab/1a/UKTxmfUx_o.png" alt="在这里插入图片描述"><br> 我们在此使用High和Low向左移的方式进行扩大区间。<br> 极限情况：位移后Low的二进制首位为0，其他位为全1；High的二进制首位为1，其他位为全0。如8位时:Low=01111111B，High=10000000B的情况。<br> 出现这种情况时，我们可以规定，保留相同位，并将该区间扩展至原始区间，如 8位是 [0, 255)， 32位是 [0, 0xffffffff)。</p> 
<p>位移时遵循两个原则 :<br> (1) 设 Total为字符表中的字符数 +已出现的字符数（即编码间隔的分母），需保证 High-Low&gt;=total，否则继续位移<br> (2) 保证 [Low, High]在上一个 [Low, High]的子区间。 (实际上这条已经在取整运算时得到了保证 )</p> 
<p>上下界左移1位后溢出位用新变量out存储，同时，用bits保存out到底存了几个位。 (0B表示二进制0)</p> 
<table><thead><tr><th>位移轮数</th><th>Total</th><th>Out</th><th>Bits</th><th>High</th><th>Low</th></tr></thead><tbody><tr><td>1</td><td>7</td><td>0B</td><td>1</td><td>98(49&lt;&lt;1)</td><td>94(47&lt;&lt;1)</td></tr><tr><td>2</td><td>7</td><td>00B</td><td>2</td><td>196(98&lt;&lt;1)</td><td>188(94&lt;&lt;1)</td></tr></tbody></table> 
<p>此时满足两条 "位移原则 "，继续编码。<br> <img src="https://images2.imgbox.com/ea/fc/0wkzOrOL_o.png" alt="在这里插入图片描述"><br> 编码第6个字符 a和第 7个字符 b，分别需要位移 3次和 2次。</p> 
<table><thead><tr><th>位移轮数</th><th>Total</th><th>Out</th><th>Bits</th><th>High</th><th>Low</th></tr></thead><tbody><tr><td>1</td><td>8</td><td>001B</td><td>3</td><td>136</td><td>134</td></tr><tr><td>2</td><td>8</td><td>0011B</td><td>4</td><td>16 (136&lt;&lt;1)</td><td>12 (134&lt;&lt;1)</td></tr><tr><td>3</td><td>8</td><td>00110B</td><td>5</td><td>32</td><td>24</td></tr></tbody></table> 
<table><thead><tr><th>位移轮数</th><th>Total</th><th>Out</th><th>Bits</th><th>High</th><th>Low</th></tr></thead><tbody><tr><td>1</td><td>9</td><td>001100B</td><td>6</td><td>54</td><td>48</td></tr><tr><td>2</td><td>9</td><td>0011000B</td><td>7</td><td>108</td><td>96</td></tr></tbody></table> 
<p>编码结束时最后的区间是 [102, 105]，后面已经没有字符，不需要位移了。记下此区间的某一个数即可，这里选 magic=104。</p> 
<p>整个编码过程结束，得到编码结果：<br> out=0011000B， bits=7， magic=104。<br> 编码全过程如图<br> <img src="https://images2.imgbox.com/fe/04/J9vl1CtK_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="_186"></a>解码过程</h6> 
<p>根据编码结果： out=0011000B， bits=7， magic=104。（ Total=9可选）<br> 将magic转换为 8位二进制，拼在 out后，得到 15位数：<br> X = out&lt;&lt;8 | magic = 0011000 01101000B</p> 
<p>（1）取 X的高 8位，令 z = 00110000B = 48;<br> （2） 48是 a所在区间，于是解码得到字符 “a”<br> （3）更新上下界为[0, 85] ，更新各符号的编码间隔 a： [0, 2/4]， b ： [2/4, 3/4]， c： [3/4, 1]<br> （4）满足位移原则1 ，不需要位移，继续解码。 48是 b所在区间，解码得到字符串 “ab”。更新上下界和编码间隔；<br> （5）继续解码得到字符串”abab”，此时上下界为 [47, 49]，不满足位移原则 1，需要位移；<br> （6）去掉z 的首位，即左边第一位；取 X中下一位接到 z右边，得到 z = 01100001B = 97。<br> Total=7，上下界[94, 98] ，不满足原则 1，继续位移得到 z = 11000011B = 195；<br> 满足原则1，继续解码；<br> （7）195是c所在区间，解码得到字符串 “ababc”；<br> （8）此时需要位移，位移3次，得到 z = 00001101B = 25，解码得到字符串 “ababca”；<br> （9）此时需要位移，位移2次， Total=9，上下界 [96, 108)，满足位移原则 1。<br> 但是z = 00110100B = 52，不在上下界范围内，于是 z位移 z = 01101000B = 104 (到达X末尾 )；<br> 解码得到字符串 “ababcab”；<br> （10）此时需要位移，位移1次，上下界为 [152, 164)，满足位移原则 1。<br> 但是z = 01101000B = 104，不在上下界范围内， z需要位移。此时 X已经到达末尾， z不能继续位移，此时编码结束。<br> （若编码结果中有 Total=9信息，在上一步就可以结束）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/718bafac995cd53d85e63adeae50d231/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">飞机大战html游戏全代码js、jquery操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1d50dea3fd4c0a9f209b85258273a36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">二进制负数用补码表示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>