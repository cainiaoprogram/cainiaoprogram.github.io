<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot &#43; Docker 实现一次构建到处运行 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot &#43; Docker 实现一次构建到处运行" />
<meta property="og:description" content="一、容器化部署的好处 Docker 作为一种新兴的虚拟化方式，它可以更高效的利用系统资源，不需要进行硬件虚拟以及运行完整操作系统等额外开销。
传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。
最重要的是一致的运行环境。Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性。从而达到真正意义上的 一次构建，到处执行。
二、构建镜像 2.1、Dockerfile 接着我们开始使用 Dockerfile 来定制我们的镜像，从而达到容器化的目的。Dockerfile 的本质就是将一系列修改、安装、构建、操作的命令整合到一起，去构建一个个性化的镜像，以达到一次构建，到处运行。接下来我们就来构建自定义镜像。
在my-project-server模块下创建docker目录，在docker目录下创建Dockerfile。代码如下：
FROM openjdk:8-jre MAINTAINER Micromaple &lt;micromaple@qq.com&gt; RUN mkdir /app COPY my-project-server-1.0.0-SNAPSHOT.jar /app/app.jar ENTRYPOINT [&#34;java&#34;, &#34;-Djava.security.egd=file:/dev/./urandom&#34;, &#34;-jar&#34;, &#34;/app/app.jar&#34;, &#34;--spring.profiles.active=prod,druid-prod&#34;] EXPOSE 8899 FROM：指定基础镜像，项目是使用jdk8开发的项目，所以我们指定的基础镜像为openjdk:8-jre
MAINTAINER：项目维护人员
RUN：执行命令，在根目录下创建app目录
COPY：将宿主机当前目录下的my-project-server-1.0.0-SNAPSHOT.jar文件拷贝到app目录下，并重命名为app.jar
ENTRYPOINT：指定容器启动程序及参数
EXPOSE：指定运行时容器提供服务的端口
2.2、开始构建 在虚拟机创建目录
mkdir -p /usr/local/docker/my-project/docker 将打包后的my-project-server-1.0.0-SNAPSHOT.jar文件和Dockerfile文件上传至该目录。
执行镜像构建命令
docker build -t my-project-server:v1 . 构建成功
$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE my-project-server v1 ed30386b06d2 11 seconds ago 334MB openjdk 8-jre 26ac3f63d29f 9 months ago 273MB 三、搭建私服 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0cd45e89e7e06c3b4af3760dab165271/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-07T20:22:45+08:00" />
<meta property="article:modified_time" content="2023-07-07T20:22:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot &#43; Docker 实现一次构建到处运行</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、容器化部署的好处</h2> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c3/89/uPBP8dVu_o.png"></p> 
<p>Docker 作为一种新兴的虚拟化方式，它可以更高效的利用系统资源，不需要进行硬件虚拟以及运行完整操作系统等额外开销。</p> 
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p> 
<p>最重要的是一致的运行环境。Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性。从而达到真正意义上的 一次构建，到处执行。</p> 
<h2>二、构建镜像</h2> 
<h4>2.1、Dockerfile</h4> 
<p>接着我们开始使用 Dockerfile 来定制我们的镜像，从而达到容器化的目的。Dockerfile 的本质就是将一系列修改、安装、构建、操作的命令整合到一起，去构建一个个性化的镜像，以达到<strong>一次构建，到处运行。</strong>接下来我们就来构建自定义镜像。</p> 
<p>在my-project-server模块下创建docker目录，在docker目录下创建Dockerfile。代码如下：</p> 
<pre><code>FROM openjdk:8-jre

MAINTAINER Micromaple &lt;micromaple@qq.com&gt;

RUN mkdir /app

COPY my-project-server-1.0.0-SNAPSHOT.jar /app/app.jar

ENTRYPOINT ["java", "-Djava.security.egd=file:/dev/./urandom", "-jar", "/app/app.jar", "--spring.profiles.active=prod,druid-prod"]

EXPOSE 8899
</code></pre> 
<ul><li> <p><code>FROM</code>：指定基础镜像，项目是使用jdk8开发的项目，所以我们指定的基础镜像为openjdk:8-jre</p> </li><li> <p><code>MAINTAINER</code>：项目维护人员</p> </li><li> <p><code>RUN</code>：执行命令，在根目录下创建app目录</p> </li><li> <p><code>COPY</code>：将宿主机当前目录下的<code>my-project-server-1.0.0-SNAPSHOT.jar</code>文件拷贝到app目录下，并重命名为app.jar</p> </li><li> <p><code>ENTRYPOINT</code>：指定容器启动程序及参数</p> </li><li> <p><code>EXPOSE</code>：指定运行时容器提供服务的端口</p> </li></ul> 
<h4>2.2、开始构建</h4> 
<p>在虚拟机创建目录</p> 
<pre><code>mkdir -p /usr/local/docker/my-project/docker
</code></pre> 
<p>将打包后的<code>my-project-server-1.0.0-SNAPSHOT.jar</code>文件和Dockerfile文件上传至该目录。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e1/72/Oi1sFHI0_o.png"></p> 
<p>执行镜像构建命令</p> 
<pre><code>docker build -t my-project-server:v1 .
</code></pre> 
<p>构建成功</p> 
<pre><code>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
my-project-server   v1                  ed30386b06d2        11 seconds ago      334MB
openjdk             8-jre               26ac3f63d29f        9 months ago        273MB
</code></pre> 
<h2>三、搭建私服</h2> 
<h4>3.1、搭建 Docker Registry</h4> 
<p>创建目录</p> 
<pre><code>mkdir -p /usr/local/docker/registry
</code></pre> 
<p>在该目录下创建Docker Registry 的 docker-compose.yml。内容如下：</p> 
<pre><code>cd /usr/local/docker/registry
</code></pre> 
<pre><code>version: '3.1'
services:
  registry:
    image: registry
    restart: always
    container_name: registry
    ports:
      - 5000:5000
    volumes:
      - ./data:/var/lib/registry
</code></pre> 
<p>启动容器</p> 
<pre><code>docker-compose up -d
</code></pre> 
<h4>3.2、搭建 Docker Registry WebUI</h4> 
<p>创建目录</p> 
<pre><code>mkdir -p /usr/local/docker/docker-registry-frontend
</code></pre> 
<p>在该目录下创建Docker Registry 的 docker-compose.yml。内容如下：</p> 
<pre><code>cd /usr/local/docker/docker-registry-frontend
</code></pre> 
<pre><code>version: '3.1'
services:
  frontend:
    image: konradkleine/docker-registry-frontend:v2
    ports:
      - 8080:80
    volumes:
      - ./certs/frontend.crt:/etc/apache2/server.crt:ro
      - ./certs/frontend.key:/etc/apache2/server.key:ro
    environment:
      - ENV_DOCKER_REGISTRY_HOST=192.168.110.158(Docker仓库的IP)
      - ENV_DOCKER_REGISTRY_PORT=5000
</code></pre> 
<blockquote> 
 <p>需要将<code>ENV_DOCKER_REGISTRY_HOST</code>的值更改为自己搭建的 <code>DockerRegistry</code> 服务的IP</p> 
</blockquote> 
<p>启动容器</p> 
<pre><code>docker-compose up -d
</code></pre> 
<p>浏览器访问<code>http://192.168.110.158:8080/</code>，效果如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/58/c5/sIoclE0D_o.png"></p> 
<h4>3.3、客户端配置</h4> 
<p>在需要上传 Docker 镜像的客户端需配置daemon.json，完整路径在 <code>/etc/docker/daemon.json</code></p> 
<pre><code>vi /etc/docker/daemon.json
</code></pre> 
<p>需增加如下内容：</p> 
<pre><code>"insecure-registries": [
  "Docker仓库的IP:5000"
]
</code></pre> 
<p>完整daemon.json内容：</p> 
<pre><code>{
  "registry-mirrors": [
    "https://xxx.mirror.aliyuncs.com"
  ],
  "insecure-registries": [
    "192.168.110.158:5000"
  ]
}
</code></pre> 
<ul><li> <p><code>registry-mirrors</code>：为镜像加速地址，这里为我自己申请的加速地址。大家可以自己申请一个，也可以在网上找一个。</p> </li><li> <p><code>insecure-registries</code>：Docker仓库的IP。</p> </li></ul> 
<p>重新启动服务</p> 
<pre><code>systemctl daemon-reload
systemctl restart docker
</code></pre> 
<h4>3.4、上传私服</h4> 
<p>搭建以及配置完成后，需要将我们之前构建的镜像上传至我们自己的Docker仓库。</p> 
<p>查看镜像</p> 
<pre><code>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
my-project-server   v1                  6af7d633afb7        5 seconds ago       334MB
openjdk             8-jre               26ac3f63d29f        9 months ago        273MB
</code></pre> 
<h5>1)、镜像标记</h5> 
<p>使用 docker tag 将 my-project-server:v1 这个镜像标记为 <code>192.168.110.158:5000/my-project-server:v</code>1。</p> 
<p>192.168.110.158为我的Docker仓库的IP。</p> 
<p>格式为：<code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code></p> 
<p>命令如下：</p> 
<pre><code>docker tag my-project-server:v1 192.168.110.158:5000/my-project-server:v1
</code></pre> 
<p>标记后，查看镜像</p> 
<pre><code>$ docker images
REPOSITORY                               TAG                 IMAGE ID            CREATED             SIZE
192.168.110.158:5000/my-project-server   v1                  6af7d633afb7        3 minutes ago       334MB
my-project-server                        v1                  6af7d633afb7        3 minutes ago       334MB
openjdk                                  8-jre               26ac3f63d29f        9 months ago        273MB
</code></pre> 
<h5>2)、镜像上传</h5> 
<p>使用 docker push 上传镜像。</p> 
<pre><code>$ docker push 192.168.110.158:5000/my-project-server
The push refers to repository [192.168.110.158:5000/my-project-server]
5b9e874b9f9c: Pushed 
e87c042d22f8: Pushed 
b4cfcb8385a8: Pushed 
2b730cf18c09: Pushed 
edeaba958753: Pushed 
8bf42db0de72: Pushed 
31892cc314cb: Pushed 
11936051f93b: Pushed 
v1: digest: sha256:5c8a0efff409649a389d0bc74dda94ca96e67e87c92673b4c7dad0078657af40 size: 2000
</code></pre> 
<h5>3)、查看镜像</h5> 
<p>使用 curl 查看 <code>192.168.110.158:5000/v2/_catalog</code> 地址，可以看到上传成功的镜像</p> 
<pre><code>$ curl 192.168.110.158:5000/v2/_catalog
{"repositories":["my-project-server"]}
</code></pre> 
<p>这里我们可以成功的看到我们上传的镜像。</p> 
<p>我们也可以在我们刚刚搭建的WebUI上可视化的查看我们的镜像。效果图如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/09/2d/aaUmY92l_o.png"></p> 
<h5>4)、验证</h5> 
<p>此时我们将本地镜像删除，尝试从私有仓库下载这个镜像</p> 
<p>先删除已有镜像</p> 
<pre><code>docker rmi my-project-server:v1 192.168.110.158:5000/my-project-server:v1
</code></pre> 
<p>下载镜像</p> 
<pre><code>docker pull 192.168.110.158:5000/my-project-server:v1
</code></pre> 
<pre><code>$ docker pull 192.168.110.158:5000/my-project-server:v1
v1: Pulling from my-project-server
0e29546d541c: Already exists 
9b829c73b52b: Already exists 
cb5b7ae36172: Already exists 
99ce012bef04: Already exists 
22dc2a72d098: Already exists 
9c69a57e10d9: Already exists 
776f54050ab5: Pull complete 
65a83a9a7871: Pull complete 
Digest: sha256:5c8a0efff409649a389d0bc74dda94ca96e67e87c92673b4c7dad0078657af40
Status: Downloaded newer image for 192.168.110.158:5000/my-project-server:v1
192.168.110.158:5000/my-project-server:v1
$ docker images
REPOSITORY                               TAG                 IMAGE ID            CREATED             SIZE
192.168.110.158:5000/my-project-server   v1                  6af7d633afb7        15 minutes ago      334MB
openjdk                                  8-jre               26ac3f63d29f        9 months ago        273MB
</code></pre> 
<p>我们可以看到可以正常拉取。</p> 
<h2>四、容器启动</h2> 
<p>镜像构建并上传至完成后，可以直接使用Docker Compose来启动容器。实现一次构建到处运行。</p> 
<p>创建目录</p> 
<pre><code>mkdir -p /usr/local/docker/my-project
</code></pre> 
<p>在该目录下创建Docker Registry 的 docker-compose.yml。内容如下：</p> 
<pre><code>cd /usr/local/docker/my-project
</code></pre> 
<pre><code>version: '3.1'
services:
  my_project_server:
    image: 192.168.110.158:5000/my-project-server:v1
    container_name: my-project-server
    restart: always
    ports:
      - 8899:8899
    volumes:
      - ./logs:/logs
    environment:
      TZ: Asia/Shanghai
</code></pre> 
<p>启动容器</p> 
<pre><code>docker-compose up -d
</code></pre> 
<p>查看容器启动状态</p> 
<pre><code>docker ps -a
</code></pre> 
<p>访问查询所有用户接口</p> 
<blockquote> 
 <ul><li> <p>http://ip:8899/sys-user/get/all</p> </li></ul> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b5/d2/cIpsizOI_o.png"></p> 
<p><em><strong>-END-</strong></em></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/60fdfeff3089793a0bfec07bd586fd67/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决幂等问题，只需要记住这个口诀！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40fd8a2224392755dfacaa1b4c969a64/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL事务管理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>