<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go语言的自动内存管理及优化(字节跳动Balanced GC优化方案)(Day5) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go语言的自动内存管理及优化(字节跳动Balanced GC优化方案)(Day5)" />
<meta property="og:description" content="目录
&gt;自动内存管理
&gt;&gt;自动内存管理-相关概念
&gt;&gt;追踪垃圾回收
&gt;&gt;回收步骤
&gt;&gt;分代GC（Generational GC）
&gt;&gt;引用计数
&gt;Go内存管理及优化
&gt;&gt;Go内存分配——分块
&gt;&gt;Go内存分配——缓存
&gt;&gt;Go内存管理优化
&gt;&gt;字节跳动内存分配优化方案:Balanced GC
&gt;&gt;Balanced GC——性能收益
&gt;自动内存管理 动态分配内存 程序在运行时根据需求动态分配的内存：malloc（）自动内存管理（垃圾回收）：由程序语言的运行时系统管理动态内存 避免手动内存管理，专注于实现业务逻辑保证内存使用的正确性和安全性：double-free proble，use-after-free problemdouble-free proble：两次回收内存，use-after-free problem：回收内存后再使用三个任务 为对象分配空间找到存活对象回收死亡对象的内存空间 &gt;&gt;自动内存管理-相关概念 Mutator：业务线程，分配新对象，修改对象指向关系Collector：GC线程，找到存活对象，回收死亡对象的内存空间Serial GC：只有一个collector Mutator Pause后执行一个collector
Parallel GC：支持多个collectors同时回收的GC算法 Mutator Pause之后执行多个collectors同时回收
Concurrent GC：mutator(s)和collector(s)可以同时执行 Collectors必须感知对象指向关系的改变！
评价GC算法 安全性（Safety）：不能回收存活的对象 基本要求吞吐率（Throughput）：花在GC上的时间，吞吐率越高越好暂停时间（Pause time）：stop the world(STW) 业务是否感知内存开销（Space overhead）GC元数据开销追踪垃圾回收（Tracing garbage collection）引用计数（Reference counting） &gt;&gt;追踪垃圾回收 对象被回收的条件：指针指向关系不可达的对象 标记根对象 静态变量，全局变量，常量，线程栈等 标记：找到可达对象 求指针指向关系的传递闭包：从根对象出发，找到所有可达对象 清理：所有不可达对象 将存活对象复制到另外的内存空间（Copying GC）将死亡对象的内存标记为“可分配”（Mark-sweep GC）移动并整理存活对象（Mark-compack GC）根据对象的生命周期，使用不同的标记和清理策略 &gt;&gt;回收步骤 &gt;&gt;&gt;未标记之前
&gt;&gt;&gt;标记根对象
&gt;&gt;&gt;标记根对象指针可以指向的对象，然后对象再一层一层的指向指针可指向的对象，传递闭包，从根对象出发，找到所有可达对象，将他们标记处理
&gt;&gt;&gt;清理所有的不可达对象，也就是没有指针指向的对象（虚线圈圈）
Copying GC：将存活对象复制到另外的内存空间
Mark-sweep GC：使用free list管理空闲内存，跳过存活对象" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7bdf5b10ead1de127944dc3eee3ecab8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-23T11:27:11+08:00" />
<meta property="article:modified_time" content="2023-01-23T11:27:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go语言的自动内存管理及优化(字节跳动Balanced GC优化方案)(Day5)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p id="%3E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;"><a href="#%3E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" rel="nofollow">&gt;自动内存管理</a></p> 
<p id="%3E%3E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%3E%3E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">&gt;&gt;自动内存管理-相关概念</a></p> 
<p id="%3E%3E%E8%BF%BD%E8%B8%AA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-toc" style="margin-left:40px;"><a href="#%3E%3E%E8%BF%BD%E8%B8%AA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" rel="nofollow">&gt;&gt;追踪垃圾回收</a></p> 
<p id="%3E%3E%E5%9B%9E%E6%94%B6%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><a href="#%3E%3E%E5%9B%9E%E6%94%B6%E6%AD%A5%E9%AA%A4" rel="nofollow">&gt;&gt;回收步骤</a></p> 
<p id="%C2%A0%3E%3E%E5%88%86%E4%BB%A3GC%EF%BC%88Generational%20GC%EF%BC%89-toc" style="margin-left:40px;"><a href="#%C2%A0%3E%3E%E5%88%86%E4%BB%A3GC%EF%BC%88Generational%20GC%EF%BC%89" rel="nofollow"> &gt;&gt;分代GC（Generational GC）</a></p> 
<p id="%C2%A0%3E%3E%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%3E%3E%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" rel="nofollow"> &gt;&gt;引用计数</a></p> 
<p id="%C2%A0%3EGo%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96-toc" style="margin-left:0px;"><a href="#%C2%A0%3EGo%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96" rel="nofollow"> &gt;Go内存管理及优化</a></p> 
<p id="%3E%3EGo%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E2%80%94%E2%80%94%E5%88%86%E5%9D%97-toc" style="margin-left:40px;"><a href="#%3E%3EGo%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E2%80%94%E2%80%94%E5%88%86%E5%9D%97" rel="nofollow">&gt;&gt;Go内存分配——分块</a></p> 
<p id="%C2%A0%3E%3EGo%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#%C2%A0%3E%3EGo%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98" rel="nofollow"> &gt;&gt;Go内存分配——缓存</a></p> 
<p id="%C2%A0%3E%3EGo%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#%C2%A0%3E%3EGo%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96" rel="nofollow"> &gt;&gt;Go内存管理优化</a></p> 
<p id="%C2%A0%3E%3E%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%3ABalanced%20GC-toc" style="margin-left:40px;"><a href="#%C2%A0%3E%3E%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%3ABalanced%20GC" rel="nofollow"> &gt;&gt;字节跳动内存分配优化方案:Balanced GC</a></p> 
<p id="%C2%A0%3E%3EBalanced%20GC%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E6%94%B6%E7%9B%8A-toc" style="margin-left:40px;"><a href="#%C2%A0%3E%3EBalanced%20GC%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E6%94%B6%E7%9B%8A" rel="nofollow"> &gt;&gt;Balanced GC——性能收益</a></p> 
<p></p> 
<hr> 
<h2 id="%3E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">&gt;自动内存管理</h2> 
<ul><li>动态分配内存 
  <ul><li>程序在运行时根据需求动态分配的内存：malloc（）</li></ul></li><li>自动内存管理（垃圾回收）：由程序语言的运行时系统管理动态内存 
  <ul><li>避免手动内存管理，专注于实现业务逻辑</li><li>保证内存使用的<strong>正确性</strong><strong>和</strong><strong>安全性</strong>：double-free proble，use-after-free problem</li><li>double-free proble：两次回收内存，use-after-free problem：回收内存后再使用</li></ul></li><li>三个任务 
  <ul><li>为对象分配空间</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul></li></ul> 
<hr> 
<h3 id="%3E%3E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">&gt;&gt;自动内存管理-相关概念</h3> 
<ul><li>Mutator：业务线程，分配新对象，修改对象指向关系</li><li>Collector：GC线程，找到存活对象，回收死亡对象的内存空间</li><li>Serial GC：只有一个collector</li></ul> 
<p>Mutator Pause后执行一个collector</p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/b4/1c/RBof9vur_o.png" width="300"></p> 
<p></p> 
<ul><li>Parallel GC：支持多个collectors同时回收的GC算法</li></ul> 
<p>Mutator Pause之后执行多个collectors同时回收</p> 
<p><img alt="" height="119" src="https://images2.imgbox.com/22/37/YSlaUAWD_o.png" width="292"></p> 
<ul><li>Concurrent GC：mutator(s)和collector(s)可以同时执行</li></ul> 
<p><img alt="" height="108" src="https://images2.imgbox.com/7d/80/Emkcd5TP_o.png" width="288"></p> 
<p><strong><span style="color:#fe2c24;"> Collectors必须感知对象指向关系的改变！</span></strong></p> 
<p><img alt="" height="198" src="https://images2.imgbox.com/26/ca/6oKsOGUY_o.png" width="354"></p> 
<ul><li> 评价GC算法 <p></p> 
  <ul><li>安全性（Safety）：不能回收存活的对象 <strong><span style="color:#fe2c24;">基本要求</span></strong></li><li>吞吐率（Throughput）：<span style="color:#fe2c24;"><strong>花在GC上的时间，吞吐率越高越好</strong></span><img alt="" height="52" src="https://images2.imgbox.com/5c/ea/rfXf8FeR_o.png" width="132"></li><li>暂停时间（Pause time）：stop the world(STW) <span style="color:#fe2c24;"><strong>业务是否感知</strong></span></li><li>内存开销（Space overhead）<strong><span style="color:#fe2c24;">GC元数据开销</span></strong></li></ul></li><li><span style="color:#0d0016;">追踪垃圾回收（Tracing garbage collection）</span></li><li><span style="color:#0d0016;">引用计数（Reference counting）</span></li></ul> 
<hr> 
<h3 id="%3E%3E%E8%BF%BD%E8%B8%AA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">&gt;&gt;追踪垃圾回收</h3> 
<ul><li> <h4 id="%E5%AF%B9%E8%B1%A1%E8%A2%AB%E5%9B%9E%E6%94%B6%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9A%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%85%B3%E7%B3%BB%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1">对象被回收的条件：指针指向关系不可达的对象</h4> </li><li> <h4 id="%E6%A0%87%E8%AE%B0%E6%A0%B9%E5%AF%B9%E8%B1%A1">标记根对象</h4> 
  <ul><li>静态变量，全局变量，常量，线程栈等</li></ul></li><li> <h4 id="%E6%A0%87%E8%AE%B0%EF%BC%9A%E6%89%BE%E5%88%B0%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1">标记：找到可达对象</h4> 
  <ul><li>求指针指向关系的传递闭包：从根对象出发，找到所有可达对象</li></ul></li><li> <h4 id="%E6%B8%85%E7%90%86%EF%BC%9A%E6%89%80%E6%9C%89%E4%B8%8D%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1">清理：所有不可达对象</h4> 
  <ul><li>将存活对象复制到另外的内存空间（Copying GC）</li><li>将死亡对象的内存标记为“可分配”（Mark-sweep GC）</li><li>移动并整理存活对象（Mark-compack GC）</li></ul></li><li><span style="color:#fe2c24;"><strong>根据对象的生命周期，使用不同的标记和清理策略</strong></span></li></ul> 
<h3 id="%3E%3E%E5%9B%9E%E6%94%B6%E6%AD%A5%E9%AA%A4">&gt;&gt;回收步骤</h3> 
<p><span style="color:#0d0016;">&gt;&gt;&gt;未标记之前</span></p> 
<p><img alt="" height="370" src="https://images2.imgbox.com/f5/f3/nbv3DoQV_o.png" width="349"></p> 
<p>&gt;&gt;&gt;标记根对象</p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/f1/e5/oU3wGFJg_o.png" width="348"></p> 
<p> &gt;&gt;&gt;标记根对象指针可以指向的对象，然后对象再一层一层的指向指针可指向的对象，传递闭包，从根对象出发，找到所有可达对象，将他们标记处理</p> 
<p><img alt="" height="368" src="https://images2.imgbox.com/ad/3b/u9d5piKd_o.png" width="348"></p> 
<p> &gt;&gt;&gt;清理所有的不可达对象，也就是没有指针指向的对象（虚线圈圈）</p> 
<p><img alt="" height="368" src="https://images2.imgbox.com/73/c8/dVW65Xvf_o.png" width="348"></p> 
<p> Copying GC：将存活对象复制到另外的内存空间</p> 
<p><img alt="" height="85" src="https://images2.imgbox.com/8d/39/JP5GMrhy_o.png" width="479"></p> 
<p> Mark-sweep GC：使用free list管理空闲内存，跳过存活对象</p> 
<p><img alt="" height="85" src="https://images2.imgbox.com/10/42/VsoQzcm5_o.png" width="496"></p> 
<p>Mark-Compact GC：原地整理对象，将存活对象压缩</p> 
<p><img alt="" height="90" src="https://images2.imgbox.com/43/89/cvPfhR8L_o.png" width="436"></p> 
<h3 id="%C2%A0%3E%3E%E5%88%86%E4%BB%A3GC%EF%BC%88Generational%20GC%EF%BC%89"> &gt;&gt;分代GC（Generational GC）</h3> 
<ul><li>分代假说（Generational hypothesis）：most objects die young</li><li>Intuition：很对对象在分配出来后很快就不再使用了</li><li>每个对象都有年龄：经历过GC的次数</li><li>目的：针对年轻和老年的对象，指定不同的GC策略，<span style="color:#fe2c24;"><strong>降低整体内存开销</strong></span></li><li>不同年龄的对象处于heap的不同区域</li></ul> 
<p><img alt="" height="78" src="https://images2.imgbox.com/eb/c7/RSnRgQSI_o.png" width="444"></p> 
<ul><li> 年轻代（Young generation） 
  <ul><li>常规的对象分配</li><li>由于<strong><span style="color:#fe2c24;">存活对象很少</span></strong>，可以采用copying collection</li><li>GC吞吐率很高</li></ul></li></ul> 
<p><img alt="" height="112" src="https://images2.imgbox.com/46/e7/heaC6EOk_o.png" width="442"></p> 
<ul><li>老年代（Old generation） 
  <ul><li><span style="color:#fe2c24;"><strong>对象趋向于一直活着，反复复制开销较大</strong></span></li><li>可以采用 mark-sweep collection</li></ul></li></ul> 
<p><img alt="" height="137" src="https://images2.imgbox.com/83/42/4ASuDZcg_o.png" width="445"></p> 
<hr> 
<h3 id="%C2%A0%3E%3E%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"> &gt;&gt;引用计数</h3> 
<ul><li> 每个对象都有一个与之关联的引用数目</li><li>对象存活的条件：当且仅当引用数大于0</li><li><strong>优点</strong> 
  <ul><li>内存管理的操作被平摊到程序执行过程中</li><li>内存管理不需要了解runtime的实现细节：C++只能指针（smart pointer）</li></ul></li><li><strong>缺点</strong> 
  <ul><li>维护引用计数的开销较大：通过<span style="color:#fe2c24;"><strong>原子操作</strong></span>保证对引用计数操作的<span style="color:#fe2c24;"><strong>原子性</strong></span>和<span style="color:#fe2c24;"><strong>可见性</strong></span></li><li>无法回收环形数据结构——weak reference</li><li>内存开销：每个对象都引入的额外内存空间存储引用数目</li><li>回收内存时依然可能引发暂停</li></ul></li></ul> 
<p>途中红色的环形数据结构无法回收，因为每一个对象的引用计数都不为0</p> 
<p>途中的灰色就是需要被回收的对象，例如左下角，引用计数0的对象A要被回收了，A引用的引用计数1为B，因为对象A要被回收了，所以对象B的引用计数也会变为0，所以对象B也要被回收</p> 
<p><img alt="" height="146" src="https://images2.imgbox.com/cc/73/WAp4vtwF_o.png" width="415"></p> 
<p>o被p引用，此时o的引用计数为1，然后o又被q引用，此时o的引用计数为2，然后p,q都为空，此时o的引用计数为0，所以o要被回收。</p> 
<p> <img alt="" height="166" src="https://images2.imgbox.com/2f/de/sRpMtt6n_o.png" width="259"><img alt="" height="160" src="https://images2.imgbox.com/ad/31/wXJWq6yI_o.png" width="325"><img alt="" height="160" src="https://images2.imgbox.com/53/99/fm1gtChf_o.png" width="322"></p> 
<hr> 
<h2 id="%C2%A0%3EGo%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96"> &gt;Go内存管理及优化</h2> 
<hr> 
<h3 id="%3E%3EGo%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E2%80%94%E2%80%94%E5%88%86%E5%9D%97">&gt;&gt;Go内存分配——分块</h3> 
<ul><li>目标：为对象在heap上分配内存</li><li>提前将内存分块 
  <ul><li>调用系统调用mmap() 向OS申请一大块内存，例如4MB</li><li>先将内存划分成大块，例如8KB，称作mspan</li><li>再将大块继续划分成<span style="color:#fe2c24;"><strong>特定大小</strong></span>的小块，用于对象分配</li><li>noscan mspan：分配不包含指针的对象——GC不需要扫描</li><li>scan mspan：分配包含指针的对象——GC需要扫描</li></ul></li><li>对象分配：根据对象的大小，选择最合适的块返回</li></ul> 
<p><img alt="" height="146" src="https://images2.imgbox.com/0f/31/S3NDs1Gp_o.png" width="353"></p> 
<h3 id="%C2%A0%3E%3EGo%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98"> &gt;&gt;Go内存分配——缓存</h3> 
<ul><li>TCMalloc:thread caching</li><li>每个p包含一个mcache用于快速分配，用于为绑定于p上的g分配对象</li><li>mcache管理一组mspan</li><li><img alt="" height="358" src="https://images2.imgbox.com/3e/4e/6BujS5fK_o.png" width="449"></li><li>当mcache中的mspan分配wanbi，向mcentral申请带有未分配块mspan</li><li><img alt="" height="359" src="https://images2.imgbox.com/00/23/l6b6esDZ_o.png" width="451"></li><li>当mspan中没有分配的对象，mspan会被缓存在mcentral中，而不是立刻释放并归还给OS</li><li><img alt="" height="355" src="https://images2.imgbox.com/f0/dc/ZCrOWGfw_o.png" width="451"></li></ul> 
<h3 id="%C2%A0%3E%3EGo%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96"> &gt;&gt;Go内存管理优化</h3> 
<ul><li>对象分配是非常高频的操作：每秒分配GB级别的内存</li><li>小对象占比较高</li><li>Go内存分配比较耗时 
  <ul><li>分配路径长：g-&gt;m-&gt;p-&gt;mcache-&gt;mspan-&gt;memory block-&gt;return pointer</li><li>pprof：对象分配的函数是最频繁调用的函数之一</li></ul></li></ul> 
<h3 id="%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91"> <img alt="" height="382" src="https://images2.imgbox.com/95/5b/HxFmymfm_o.png" width="584"></h3> 
<h3 id="%C2%A0%3E%3E%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%3ABalanced%20GC"> &gt;&gt;字节跳动内存分配优化方案:Balanced GC</h3> 
<ul><li>每个g都绑定一大块内存（1KB），称作goroutine allocation buffer(GAB)<img alt="" height="46" src="https://images2.imgbox.com/76/fd/RHBs1okU_o.png" width="318"></li><li>GAB用于noscan类型的小对象分配：&lt;128B</li><li>使用三个指针维护GAB:base,end,top</li><li>Bump pointer(指针碰撞)风格对象分配 
  <ul><li>无须和其他分配请求互斥</li><li>分配动作简单高效</li></ul></li></ul> 
<p></p> 
<p><img alt="" height="127" src="https://images2.imgbox.com/c6/34/h5luT7o2_o.png" width="521"><img alt="" height="124" src="https://images2.imgbox.com/63/c8/lpgg4ktr_o.png" width="251"></p> 
<ul><li> GAB对于Go内存管理来说是<span style="color:#fe2c24;"><strong>一个对象</strong></span></li><li>本质：<span style="color:#fe2c24;"><strong>将多个小对象的分配合并成和一次达对象的分配</strong></span></li><li>问题：GAB的对象分配方式会导致内存被延迟释放</li><li>方案：移动GAB中存活的对象 
  <ul><li>当GAB总大小超过一定阈值时，将GAB中存活的对象复制到另外分配的GAB中</li><li>原来的GAB可以释放，避免内存泄漏</li><li>本质：<span style="color:#fe2c24;"><strong>用copying GC的算法管理小对象</strong></span></li></ul></li></ul> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="86" src="https://images2.imgbox.com/81/f5/CDogxjOz_o.png" width="423"></h4> 
<p> <img alt="" height="171" src="https://images2.imgbox.com/e3/68/p6879Boa_o.png" width="519"></p> 
<h4 id="%E6%A0%B9%E6%8D%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%87%E8%AE%B0%E5%92%8C%E6%B8%85%E7%90%86%E7%AD%96%E7%95%A5"><span style="color:#fe2c24;">根据对象的生命周期，使用不同的标记和清理策略</span></h4> 
<h3 id="%C2%A0%3E%3EBalanced%20GC%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E6%94%B6%E7%9B%8A"> &gt;&gt;Balanced GC——性能收益</h3> 
<p><img alt="" height="298" src="https://images2.imgbox.com/bc/a5/x9QaLp5l_o.png" width="832"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/208d1e61fbec7a0cb974276e96fa7298/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Typora搭建Gitee图床</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/244560ab598496e351d18cd17bd5b973/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue修改数据后没有更新新值($nextTick函数）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>