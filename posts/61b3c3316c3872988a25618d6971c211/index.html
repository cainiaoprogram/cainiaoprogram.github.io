<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2013 B 碎纸片拼接与复原 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2013 B 碎纸片拼接与复原" />
<meta property="og:description" content="摘 要
对重要文件的拼接复原，传统上都由人工完成，拼接准确率虽然高但是效率很低。本文旨在建立模型，利用计算机编程加少量的人工干预实现碎纸片的拼接复原。
针对问题1，由于对任意一个字符来讲，笔画是连续的，所以对于一般情况，即使文字被切开，两边的像素还是有联系的，是呈现离散性渐变的。针对此特征，建立了文字连续性模型来求解该问题。而又因为被切开的两边碎片边缘灰度是具有高相关性的，所以，又建立了向量相关模型来求解进行图片拼接。用两种模型分别求解，都得到了对附件一和附件二的正确拼接结果。
针对问题2，可以采用第一问的模型，先进行全局搜索，找出每个碎片最相似的右侧邻近碎片，拼接出每一行的图片，再利用向量相关性进行横向拼接，得到拼接结果。但是，由于纸片同时被横向与纵向切割，碎片小，数量多，碎片之间的信息量不够，容易造成误判。所以建立向量投影分类模型，首先将可能处于同一行的碎片用模糊C均值(FCM)聚类方法分到同一类。对于汉字或英文的缺行碎片（碎片中只有一行或者两行字），利用掩码补充模型将投影中缺失的行用掩码补齐，然后再放入分类。分类完成后，将每一类中的碎片进行横向排序拼接。每一类横向拼接完成后，从而拼接成完整图片。对于不能正确拼接的部分，采取了多种人工干预的策略，最终得到正确的拼接结果。
针对问题3，由于附件中的碎片分为正反两面，所以可以建立组合匹配模型将碎片首先将正反面碎片的灰度矩阵上下拼接，每张碎片的拼接方案有两种（灰度矩阵a放在左右镜像处理后的b上或灰度矩阵b放在左右镜像处理后的a上）。拼接过后，边缘灰度向量信息会增加为原来的两倍，这时利用问题二中的全局搜索模型用向量相关性的方法进行匹配拼接。拼接出所有行后，将每一行的下半部分矩阵切割放在上半部分的右边，又可增加横向拼接时的边缘信息，然后各行再次利用向量相关性的方法进行横向拼接，最终得到结果图，但是仍然存在较多的碎片不能正确匹配，需要人工干预。
由于碎片在切割时的随机性，使得机器自动拼接存在一定的难度，因此，采取恰当的人工干预的措施，是保证正确拼接的必要手段。
关键词：文字连续性 匹配 FCM聚类方法 掩码补充模型 向量投影分类模型
一．问题背景及重述
破碎文件的拼接在司法物证复原、历史文献修复以及军事情报获取等领域都有着重要的应用。传统上，拼接复原工作需由人工完成，准确率较高，但效率很低。特别是当碎片数量巨大，人工拼接很难在短时间内完成任务。但如果借助计算机技术，开发出碎纸片的自动拼接技术，提高拼接复原效率将会大大提高。
问题1：给定的来自同一页印刷文字文件的碎纸机破碎纸片（仅纵切），建立碎纸片拼接复原模型和算法，并且拼接复原附件1和附件2给出的中、英文各一页文件的碎片数据。
问题2： 对于碎纸机既纵切又横切的情形，设计碎纸片拼接复原模型和算法，并针对附件3和附件4给出的中、英文各一页文件的碎片数据进行拼接复原。
问题3：从现实情形出发，还可能有双面打印文件的碎纸片拼接复原问题需要解决。附件5给出了一页英文印刷文字双面打印文件的碎片数据。设计相应的碎纸片拼接复原模型与算法，并就附件5的碎片数据给出拼接复原结果。
二．模型假设
1、不计碎纸片边缘的磨损，没有边缘像素损耗；
2、假设纸张垂直放入碎纸机即每张小碎纸片都是规则矩形；
3、图片中的文字像素没有任何断点；
4、图像上没有任何噪声或污点造成像素干扰。
三．变量说明
四．模型准备与问题分析
针对题目中附件所给的图片信息，我们学习准备了图像的处理方法[1]、模式匹配方法[2]和图像拼接方法[3,4]。将图片批处理成范围值0-255之间的灰度矩阵（纯黑为0，纯白为255，数字越大，颜色越亮）。
问题一中的附件图片，碎片数据较少，每一张碎片都比较大，那么相应的灰度矩阵中包含的信息就比较多，处理起来相对容易。而且仔细观察，分别只有一张图片的最左端和最右端边缘是没有文字的。由于完整纸片切开后，边缘处仍然是有联系的。所以可以提取图像边缘的灰度信息，首先找出第一张图片，然后利用图片的边缘信息找出下一张图片与之拼接。
问题二中，给出的图片碎片比较小，只有180*72像素，图像信息以及边缘信息都比较少。而且，由于既横切又纵切，图片的顺序被打乱，无法直接拼接。因此，首先得将这些碎片分类，将同一行的图片归在同一类中，然后将归类后的图片进行横向排序，拼接出这一行的图片碎片，因为有些碎片包含的边缘信息过少，可能无法分类或者成功排序，这时进行人工干预。每一行图片按排序拼接后，即可将问题转化为第一问的问题进行纵向拼接，最终得到结果。
问题三中附件五的碎片与问题二中附件四的类似，都是英文小碎片，但是正反面被打乱。虽然正反面一开始无法识别，但是某一张图的正面与另一张正面横向投影对齐，反面的横向投影也就会对齐。所以我们可以利用a面和b面的矩阵上下组合，变成一个大的单面图片，一方面增加了拼接的信息量，同时又将问题转化为第二问中类似的问题，利用第二问的模型即可找出双面碎片的拼接结果。
五．模型建立与求解
5.1 问题一的求解
5.1.1 基于文字连续性模型的碎片拼接
首先，对问题1的分析可知，该问题为一个图像处理问题。根据字的特征，我们知道笔画是连续的，图片放大之后我们也能看到有字的部分图像偏暗，由字中间向边缘，慢慢变亮直至超过字范围而变成白色。我们利用这一点，建立文字连续性模型来处理拼接问题。
（a） （b） 图1：点阵字体的锯齿现象
由字体放大图1(a)可以看出笔画周边的锯齿，每一个锯齿方块就是一个像素，范围大小在255以下。切割后的图像，这些锯齿也会分开。但是，虽然像素分开了，由于汉字字体或者英文字体大部分是连体的，所以这些碎片的图像灰度信息会有一定的相关性或者说是连续性。
如图1(b)，假如图片像素按照红线所示切开分为a，b两块。可以看到红线左右两边的像素块大都是相连的，最理想的情况就是如同像素块2，3或者4，5在同一位置直接对应，这种情况就可以认为这两个像素块匹配，匹配数num加1。但是，也有可能出现像素块1这样的情况，与之对应的位置没有像素块，但是下方或者上方有像素块，由于这些像素的连续性，所以也认为像素1得到匹配，num=num&#43;1。
读取所有图片，由于纸张有页边距，若某一张碎片为完整纸片上的最左一张，则其图像左侧必定全为白色，即灰度值的前几列为255，通过这种方法，能很快找到第一张碎片，将其放入集合中，记为。
找到第一张碎片后，用第一张碎片的右边缘去和中所有碎片的左边缘进行匹配。由于白色点太多，匹配成功数会很大，影响结果。所以，我们只选取非白色点进行匹配，匹配过程中，非白色点的总数记为sumofb，每选取边缘非白色点匹配一次，sumofb=sumofb&#43;1。
匹配率[3]的计算方法为：
（1）
求得第一张碎片的右边缘和集合中每张碎片左边缘的匹配率后，将所得的匹配率对比，选取匹配率最高的那张碎片，将其放入集合中，记为（i为碎片的排列顺序），将右边缘像素去和中剩余碎片的左边缘像素进行匹配，重复此类操作，直到中没有碎片，最终得到排序结果即为碎片的拼接方案。计算所得集合中与的最大匹配率如表1所示。
表1：附件一中中文字符碎片拼接顺序及匹配情况：
当前碎片编号
8
14
12
15
13
10
2
16
1
最佳匹配碎片编号
14
12
15
13
10
2
16
1
4
最大匹配率
0.83
0.96" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/61b3c3316c3872988a25618d6971c211/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-07T20:43:24+08:00" />
<meta property="article:modified_time" content="2018-11-07T20:43:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2013 B 碎纸片拼接与复原</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>摘  要</p> 
<p>对重要文件的拼接复原，传统上都由人工完成，拼接准确率虽然高但是效率很低。本文旨在建立模型，利用计算机编程加少量的人工干预实现碎纸片的拼接复原。</p> 
<p>针对问题1，由于对任意一个字符来讲，笔画是连续的，所以对于一般情况，即使文字被切开，两边的像素还是有联系的，是呈现离散性渐变的。针对此特征，建立了文字连续性模型来求解该问题。而又因为被切开的两边碎片边缘灰度是具有高相关性的，所以，又建立了向量相关模型来求解进行图片拼接。用两种模型分别求解，都得到了对附件一和附件二的正确拼接结果。</p> 
<p>针对问题2，可以采用第一问的模型，先进行全局搜索，找出每个碎片最相似的右侧邻近碎片，拼接出每一行的图片，再利用向量相关性进行横向拼接，得到拼接结果。但是，由于纸片同时被横向与纵向切割，碎片小，数量多，碎片之间的信息量不够，容易造成误判。所以建立向量投影分类模型，首先将可能处于同一行的碎片用模糊C均值(FCM)聚类方法分到同一类。对于汉字或英文的缺行碎片（碎片中只有一行或者两行字），利用掩码补充模型将投影中缺失的行用掩码补齐，然后再放入分类。分类完成后，将每一类中的碎片进行横向排序拼接。每一类横向拼接完成后，从而拼接成完整图片。对于不能正确拼接的部分，采取了多种人工干预的策略，最终得到正确的拼接结果。</p> 
<p>针对问题3，由于附件中的碎片分为正反两面，所以可以建立组合匹配模型将碎片首先将正反面碎片的灰度矩阵上下拼接，每张碎片的拼接方案有两种（灰度矩阵a放在左右镜像处理后的b上或灰度矩阵b放在左右镜像处理后的a上）。拼接过后，边缘灰度向量信息会增加为原来的两倍，这时利用问题二中的全局搜索模型用向量相关性的方法进行匹配拼接。拼接出所有行后，将每一行的下半部分矩阵切割放在上半部分的右边，又可增加横向拼接时的边缘信息，然后各行再次利用向量相关性的方法进行横向拼接，最终得到结果图，但是仍然存在较多的碎片不能正确匹配，需要人工干预。</p> 
<p>由于碎片在切割时的随机性，使得机器自动拼接存在一定的难度，因此，采取恰当的人工干预的措施，是保证正确拼接的必要手段。</p> 
<p> </p> 
<p> </p> 
<p>关键词：文字连续性  匹配  FCM聚类方法 掩码补充模型  向量投影分类模型</p> 
<p><br> 一．问题背景及重述</p> 
<p>破碎文件的拼接在司法物证复原、历史文献修复以及军事情报获取等领域都有着重要的应用。传统上，拼接复原工作需由人工完成，准确率较高，但效率很低。特别是当碎片数量巨大，人工拼接很难在短时间内完成任务。但如果借助计算机技术，开发出碎纸片的自动拼接技术，提高拼接复原效率将会大大提高。</p> 
<p>问题1：给定的来自同一页印刷文字文件的碎纸机破碎纸片（仅纵切），建立碎纸片拼接复原模型和算法，并且拼接复原附件1和附件2给出的中、英文各一页文件的碎片数据。</p> 
<p>问题2： 对于碎纸机既纵切又横切的情形，设计碎纸片拼接复原模型和算法，并针对附件3和附件4给出的中、英文各一页文件的碎片数据进行拼接复原。</p> 
<p>问题3：从现实情形出发，还可能有双面打印文件的碎纸片拼接复原问题需要解决。附件5给出了一页英文印刷文字双面打印文件的碎片数据。设计相应的碎纸片拼接复原模型与算法，并就附件5的碎片数据给出拼接复原结果。</p> 
<p>二．模型假设</p> 
<p>1、不计碎纸片边缘的磨损，没有边缘像素损耗；</p> 
<p>2、假设纸张垂直放入碎纸机即每张小碎纸片都是规则矩形；</p> 
<p>3、图片中的文字像素没有任何断点；</p> 
<p>4、图像上没有任何噪声或污点造成像素干扰。</p> 
<p>三．变量说明</p> 
<p><br>   </p> 
<p> </p> 
<p>四．模型准备与问题分析</p> 
<p>针对题目中附件所给的图片信息，我们学习准备了图像的处理方法[1]、模式匹配方法[2]和图像拼接方法[3,4]。将图片批处理成范围值0-255之间的灰度矩阵（纯黑为0，纯白为255，数字越大，颜色越亮）。</p> 
<p>问题一中的附件图片，碎片数据较少，每一张碎片都比较大，那么相应的灰度矩阵中包含的信息就比较多，处理起来相对容易。而且仔细观察，分别只有一张图片的最左端和最右端边缘是没有文字的。由于完整纸片切开后，边缘处仍然是有联系的。所以可以提取图像边缘的灰度信息，首先找出第一张图片，然后利用图片的边缘信息找出下一张图片与之拼接。</p> 
<p>问题二中，给出的图片碎片比较小，只有180*72像素，图像信息以及边缘信息都比较少。而且，由于既横切又纵切，图片的顺序被打乱，无法直接拼接。因此，首先得将这些碎片分类，将同一行的图片归在同一类中，然后将归类后的图片进行横向排序，拼接出这一行的图片碎片，因为有些碎片包含的边缘信息过少，可能无法分类或者成功排序，这时进行人工干预。每一行图片按排序拼接后，即可将问题转化为第一问的问题进行纵向拼接，最终得到结果。</p> 
<p>问题三中附件五的碎片与问题二中附件四的类似，都是英文小碎片，但是正反面被打乱。虽然正反面一开始无法识别，但是某一张图的正面与另一张正面横向投影对齐，反面的横向投影也就会对齐。所以我们可以利用a面和b面的矩阵上下组合，变成一个大的单面图片，一方面增加了拼接的信息量，同时又将问题转化为第二问中类似的问题，利用第二问的模型即可找出双面碎片的拼接结果。</p> 
<p>五．模型建立与求解</p> 
<p>5.1   问题一的求解</p> 
<p>5.1.1 基于文字连续性模型的碎片拼接</p> 
<p>首先，对问题1的分析可知，该问题为一个图像处理问题。根据字的特征，我们知道笔画是连续的，图片放大之后我们也能看到有字的部分图像偏暗，由字中间向边缘，慢慢变亮直至超过字范围而变成白色。我们利用这一点，建立文字连续性模型来处理拼接问题。</p> 
<p>       </p> 
<p>（a）                                                                  （b）        </p> 
<p>图1：点阵字体的锯齿现象</p> 
<p>由字体放大图1(a)可以看出笔画周边的锯齿，每一个锯齿方块就是一个像素，范围大小在255以下。切割后的图像，这些锯齿也会分开。但是，虽然像素分开了，由于汉字字体或者英文字体大部分是连体的，所以这些碎片的图像灰度信息会有一定的相关性或者说是连续性。</p> 
<p>如图1(b)，假如图片像素按照红线所示切开分为a，b两块。可以看到红线左右两边的像素块大都是相连的，最理想的情况就是如同像素块2，3或者4，5在同一位置直接对应，这种情况就可以认为这两个像素块匹配，匹配数num加1。但是，也有可能出现像素块1这样的情况，与之对应的位置没有像素块，但是下方或者上方有像素块，由于这些像素的连续性，所以也认为像素1得到匹配，num=num+1。</p> 
<p>读取所有图片，由于纸张有页边距，若某一张碎片为完整纸片上的最左一张，则其图像左侧必定全为白色，即灰度值的前几列为255，通过这种方法，能很快找到第一张碎片，将其放入集合中，记为。</p> 
<p>找到第一张碎片后，用第一张碎片的右边缘去和中所有碎片的左边缘进行匹配。由于白色点太多，匹配成功数会很大，影响结果。所以，我们只选取非白色点进行匹配，匹配过程中，非白色点的总数记为sumofb，每选取边缘非白色点匹配一次，sumofb=sumofb+1。</p> 
<p>匹配率[3]的计算方法为：</p> 
<p>                         （1）</p> 
<p>求得第一张碎片的右边缘和集合中每张碎片左边缘的匹配率后，将所得的匹配率对比，选取匹配率最高的那张碎片，将其放入集合中，记为（i为碎片的排列顺序），将右边缘像素去和中剩余碎片的左边缘像素进行匹配，重复此类操作，直到中没有碎片，最终得到排序结果即为碎片的拼接方案。计算所得集合中与的最大匹配率如表1所示。</p> 
<p> </p> 
<p>表1：附件一中中文字符碎片拼接顺序及匹配情况：</p> 
<p>当前碎片编号<br> 8<br> 14<br> 12<br> 15<br> 13<br> 10<br> 2<br> 16<br> 1<br> 最佳匹配碎片编号<br> 14<br> 12<br> 15<br> 13<br> 10<br> 2<br> 16<br> 1<br> 4<br> 最大匹配率<br> 0.83<br> 0.96<br> 0.82<br> 0.92<br> 0．97<br> 0.92<br> 0．97<br> 0．94<br> 0.83<br> 当前碎片编号<br> 4<br> 5<br> 9<br> 13<br> 18<br> 11<br> 7<br> 17<br> 0<br> 最佳匹配碎片编号<br> 5<br> 9<br> 13<br> 18<br> 11<br> 7<br> 17<br> 0<br> 6<br> 最大匹配率<br> 0.85<br> 0.87<br> 0.97<br> 0.92<br> 0.74<br> 0.89<br> 0.98<br> 0.91<br> 0.99<br>  </p> 
<p>表2：附件一中英文字符碎片拼接顺序及匹配情况：</p> 
<p>当前碎片编号<br> 3<br> 6<br> 2<br> 7<br> 15<br> 18<br> 11<br> 0<br> 5<br> 最佳匹配碎片编号<br> 6<br> 2<br> 7<br> 15<br> 18<br> 11<br> 0<br> 5<br> 1<br> 最大匹配率<br> 0.93<br> 0.91<br> 0.95<br> 0.92<br> 0.89<br> 0.90<br> 0.76<br> 0.96<br> 0.88<br> 当前碎片编号<br> 1<br> 9<br> 13<br> 10<br> 8<br> 12<br> 14<br> 13<br> 16<br> 最佳匹配碎片编号<br> 9<br> 13<br> 10<br> 8<br> 12<br> 14<br> 13<br> 16<br> 4<br> 最大匹配率<br> 0.99<br> 0.87<br> 0.87<br> 0.94<br> 093<br> 0.92<br> 0.96<br> 0.84<br> 0.82<br>  </p> 
<p>5.1.2  基于向量相关性的碎片拼接</p> 
<p>     提取碎片边缘向量，选出第一张图片后，计算右边缘向量与集合中的每一张碎片左边缘向量的相关系数[5]：</p> 
<p>                                                    （2）</p> 
<p>将所得的对比，选出相关系数最最大的，放入集合中。再用选出的碎片右边缘向量与中剩余碎片匹配，重复此操作，直到中没有碎片，最终得到排序结果即为碎片的拼接方案。计算求得集合中与的相关系数为：</p> 
<p>表3：附件二中中文字符碎片拼接顺序及匹配情况：</p> 
<p>当前碎片编号<br> 8<br> 14<br> 12<br> 15<br> 13<br> 10<br> 2<br> 16<br> 1<br> 最相关碎片编号<br> 14<br> 12<br> 15<br> 13<br> 10<br> 2<br> 16<br> 1<br> 4<br> 最大相关系数<br> 0.80<br> 0.85<br> 0.88<br> 0.91<br> 0．84<br> 0.89<br> 0．94<br> 0．88<br> 0.86<br> 当前碎片编号<br> 4<br> 5<br> 9<br> 13<br> 18<br> 11<br> 7<br> 17<br> 0<br> 最相关碎片编号<br> 5<br> 9<br> 13<br> 18<br> 11<br> 7<br> 17<br> 0<br> 6<br> 最大相关系数<br> 0.88<br> 0.88<br> 0.88<br> 0.87<br> 0.86<br> 0.86<br> 0.84<br> 0.88<br> 0.90<br>  </p> 
<p>5．2  问题二的求解</p> 
<p>问题二中所给附件三、四都是小碎片，宽度为72像素，与第一问中的一致，但是高度只有180像素，为第一问碎片的1/11，所以左右边缘的灰度信息较少，容易造成误判。</p> 
<p>5.2.1 模型1 建立全局搜索的碎片拼接模型</p> 
<p>由问题一的求解可以看出，利用向量相关模型或者文字连续性模型可以不必区分碎片的文字语言。所以对于问题二，可以建立全局搜索模型，同时利用第一问中的向量相关分析来进行碎片拼接。全局搜索模型算法如下：</p> 
<p>Step 1：根据页边距找出11张处于纸片第一列的碎纸片，记为集合。取其中一张记为，放入；</p> 
<p>Step 2：我们从存放于U的所有纸片中任取一张碎纸片与进行向量匹配，记录下匹配的相关系数，取相关系数最大的那张图片作为的下一张纸片，记为,以此法依次匹配得到后面的18张图片（最后一张同样存在页边距）；对于得到的这样一条横串，我们记为</p> 
<p>Step 3：从上面的集合中再任取一张图片记为，重复step2；</p> 
<p>Step 4：当，我们根据问题1中的方法对进行拼接，即可得到整张纸片原图。</p> 
<p>5.2.2模型2 基于向量投影分类的碎片拼接模型</p> 
<p>但是由于附件三和四中都给出了209张碎片，如果进行全局搜索的话，时间复杂度，计算量十分庞大。所以为了减少计算时间，我们首先根据碎片中行距的位置对碎片进行预分类，将同一行的碎片分在一类，再对同一类中的碎片利用第一文的方法进行排序。</p> 
<p>由于中英文文字在像素图片中的显示形式不一样，所以我们通过这两种文字显示的不同特征来用两种投影方式来进行分类排序。</p> 
<p>1、 中文字的碎片拼接</p> 
<p>（1）中文字碎片向量投影</p> 
<p>针对中文字像素图片，可以利用中文字是方块字的特点首先建立向量投影匹配分组模型。附件3中所给11×19共209张图片，可以拼成完整的一篇文章，那么同一行的文字被切开后，字体仍然在相对的同一高度上。</p> 
<p>图2 碎片投影</p> 
<p>所以，利用这一特征，我们可以首先利用掩码补充法将图片中文字的行间距找出来，利用不同行的文字中行间距在图片中的高度不通，对碎片经行预分类，将同一行的碎片分在一类总，然后利用第一问中的方法对行内小块经行排序。掩码补充法的具体做法是：将像素矩阵水平投影，如图2，设当某一像素行都为白色255时，投影值只为0，当一像素行有小于255的像素块时，此行投影为1。最终，209张图片生成209列的投影矩阵Shadow。</p> 
<p>（2）字符的填补</p> 
<p>投影碎片的灰度信息，由于中文字中有上下结构的字，如，附件三中的“010.bmp”碎片中的“翁”字，中间有一小段的投影出现缺失。这时，由于投影向量中全白色段的长度很小（甚至可能为1个像素点），并且上下两字段的长度加起来接近一个中文字符块的高度时，我们将此段的投影向量填充为1，似得其投影矩阵具有连续性。</p> 
<p> </p> 
<p>图3 字符缺损补充</p> 
<p>（3） 字块的填补</p> 
<p>利用掩码补充模型补充缺行碎片。在投影过程中，会遇到缺行的图片，这种缺行的图片大致分为三种：</p> 
<p>                   </p> 
<p>     图4 掩码补充时的特殊情况</p> 
<p>如图4所示，有上部缺行，中部缺行和底部缺行。如果出现这样的情况，因为若全为白色的像素行过多，就有可能匹配不到分组。所以我们建立掩码补充模型，补充缺失的文字像素投影行，将缺失的文字像素投影段都补充为1，每一列的投影矩阵都叫做“投影编码”。</p> 
<p>首先，我们将缺失投影行的图片搜寻出来，由于缺失一个字段，那么这些图片的向量投影值为1的连续段就会小于3，只有两段甚至是一段。利用这个方法，我们成功找出了缺失字段的图片，分别是第5 9 15 17 22 2628 33 41 61 67 71 72 75 86 90 94 102 107 109 110 111 114 115 118 120 124 126140 141 146 147 151 153 154 155 156 158 166 167 174 182 185 186 188 195 197 198205 206 208共51张（此数列的值比实际图片编号大一，如，第五张对应附件三中的004号图片）图片。</p> 
<p>然后，我们将这些缺损字段的图片投影数据进行整合，计算每一段全白色段和非全白色段的段长（例如投影编码为00000011111100011，就记为6，6，3，2）并存入段长矩阵中，为了以后处理方便，我们都以全白色段的段长值开头，若起始为非纯白色段，则在此段长前加一0值，作为开头的全白色段长。</p> 
<p>经过投影后的统计，一个中文字的高度Hz大约为41-42像素，而两行中文字之间的间距Dz大约为26-28像素。首先我们考虑上部缺行的图片，由于我们规定了段长矩阵中的第一列都为全白色段的长度，所以当第一列的值LenofD[i,1]大于间距Dz时，表示这张图片上部是有缺损的。然后根据上部缺损的不同长度段长LenofD[i,1]，将LenofD[i,1]分割成几个段长（这些段长为全白色段与非全白色段间隔表示），放在矩阵head中，用分割后的段长head取代LenofD[i,1]。</p> 
<p>        （3）</p> 
<p>对于中部缺行的图片我们也采取类似的方案进行处理。对于图片中间部分的全白色段段长LenofD[i,mid],因为中部缺损肯定的是缺[非全白色段，全白色段，非全白色段]或者是[非全白色段，全白色段，非全白色段，全白色段，非全白色段]，只有两种情况，所以当LenofD[i,mid]大于（2×Dz+Hz）时：</p> 
<p>     （4）</p> 
<p>用mid矩阵取代LenofD[i,mid]。</p> 
<p>最后一种底部缺行的处理方案也与上部缺行的类似。如果图片底部的LenofD[i,bom]大于间距Dz，就将LenofD[i,bom]分解成小块段长：</p> 
<p>   （5）</p> 
<p>用bom矩阵取代LenofD[i,bom]。</p> 
<p>将补充好的段长矩阵LenofDnew，重新按照段长和全白色段，非全白色段间隔排列的规则还原出新的投影矩阵Shadownew，在Shadownew中的原先缺行图片的缺失段都会被赋值1，这些补充后值为1的段就称作“掩码”。补充掩码后的投影急诊对应的图片，就相当于在缺行的那一段，补充了一个高度Hz的字段，效果如图5：</p> 
<p>图5 掩码遮盖</p> 
<p> （4）用FCM聚类方法将碎片分类</p> 
<p>将这些覆盖掩码后的投影矩阵Shadownew用模糊C均值(FCM)聚类方法[2]进行分类，根据投影矩阵中的投影编码一共分为11类碎片。每一类所包含的图片序号为（序号比实际编号大一）：</p> 
<p>表4：FCM预分类结果</p> 
<p>C1<br> 6     11    30    38    45    49    56    60    65    76    93    99    105  112  172  173  181  202  207<br> C2<br> 7     20    21    37    53    62    64    68    70    73    79    80    97    100  117  132  163  164  178<br> C3<br> 3     12    23    29    50    55    58    66    92    96    119  130  142  144  179  187  189  191  193<br> C4<br> 9     10    25    26    36    39    47    75    82    89    104  106  123  131  149  162  168  190  194<br> C5<br> 1     8     33    46    54    57    69    71    94    127  138  139  154  159  167  175  176  197  209<br> C6<br> 17    22    67    107  110  111  140  146  151  158  174  182  185  188  198  205<br> C7<br> 35    43    44    48    59    78    85    91    95    98    113  122  125  128  137  145  150  165  184<br> C8<br> 4     13    15    32    40    52    74    83    108  116  129  135  136  160  161  170  177  200  204<br> C9<br> 14    16    18    28    34    72    81    84    86    133  134  153  157  166  171  183  199  201  203  206<br> C10<br> 2     19    24    27    31    42    51    63    77    87    88    101  121  143  148  169  180  192  196<br> C11<br> 5  41  61     90    102  103  109  114  115  118  120  124  126  141  147  152  155  156  186  195 208<br> 分类后C6中只有16张图片（少3张），C9中有20张（多1张），C11中有21张（多2张）。</p> 
<p>（5）将分类好的碎片逐类横向拼接</p> 
<p>分类完毕之后，继续利用向量相关模型进行横向拼接，拼接好同一类的一行之后，观察是否有拼接出错碎片。此时，由于程序对有些碎片无法正确匹配，必须进行人工干预，根据语义和偏旁部首进行手工拼接。</p> 
<p>图6 人工干预前后比较</p> 
<p>如图6，第46张与第25张碎片匹配出错，因为“迎”和“晴”都切在了竖线上，所以相关系数会很大，这是第一类典型的出错原因：边缘字形相近；第74张与第9张匹配出错，因为第74张碎片的右端边缘没有任何中文字符，造成正确无法计算相关系数，这是第二类出错原因：碎片边缘没有任何字符灰度信息。</p> 
<p>人工干预时，根据中文字的特征，以及上下文的语义，我们进行手动调整错误的图片的位置，将此行拼成正确图片。</p> 
<p>当每一个分类都成功拼接出正确图片行后，将这11个分类用在纵向进行拼接。纵向拼接成功后，在用向量相关模型进行横向拼接，最终得到正确结果：</p> 
<p>表5：附件三的拼接结果</p> 
<p>49<br> 54<br> 65<br> 143<br> 186<br> 2<br> 57<br> 192<br> 178<br> 118<br> 190<br> 95<br> 11<br> 22<br> 129<br> 28<br> 91<br> 188<br> 141<br> 61<br> 19<br> 78<br> 67<br> 69<br> 99<br> 162<br> 96<br> 131<br> 79<br> 63<br> 116<br> 163<br> 72<br> 6<br> 177<br> 20<br> 52<br> 36<br> 168<br> 100<br> 76<br> 62<br> 142<br> 30<br> 41<br> 23<br> 147<br> 191<br> 50<br> 179<br> 120<br> 86<br> 195<br> 26<br> 1<br> 87<br> 18<br> 38<br> 148<br> 46<br> 161<br> 24<br> 35<br> 81<br> 189<br> 122<br> 103<br> 130<br> 193<br> 88<br> 167<br> 25<br> 8<br> 9<br> 105<br> 74<br> 71<br> 156<br> 83<br> 132<br> 200<br> 17<br> 80<br> 33<br> 202<br> 198<br> 15<br> 133<br> 170<br> 205<br> 85<br> 152<br> 165<br> 27<br> 60<br> 14<br> 128<br> 3<br> 159<br> 82<br> 199<br> 135<br> 12<br> 73<br> 160<br> 203<br> 169<br> 134<br> 39<br> 31<br> 51<br> 107<br> 115<br> 176<br> 94<br> 34<br> 84<br> 183<br> 90<br> 47<br> 121<br> 42<br> 124<br> 144<br> 77<br> 112<br> 149<br> 97<br> 136<br> 164<br> 127<br> 58<br> 43<br> 125<br> 13<br> 182<br> 109<br> 197<br> 16<br> 184<br> 110<br> 187<br> 66<br> 106<br> 150<br> 21<br> 173<br> 157<br> 181<br> 204<br> 139<br> 145<br> 29<br> 64<br> 111<br> 201<br> 5<br> 92<br> 180<br> 48<br> 37<br> 75<br> 55<br> 44<br> 206<br> 10<br> 104<br> 98<br> 172<br> 171<br> 59<br> 7<br> 208<br> 138<br> 158<br> 126<br> 68<br> 175<br> 45<br> 174<br> 0<br> 137<br> 53<br> 56<br> 93<br> 153<br> 70<br> 166<br> 32<br> 196<br> 89<br> 146<br> 102<br> 154<br> 114<br> 40<br> 151<br> 207<br> 155<br> 140<br> 185<br> 108<br> 117<br> 4<br> 101<br> 113<br> 194<br> 119<br> 123<br>  </p> 
<p>2、英文字的碎片拼接</p> 
<p>（1）英文字碎片向量投影</p> 
<p>对于英文字母，我们可以利用英文字母“四线三格”的书写格式，如图7所示：</p> 
<p>图7 英文字符“四线三格”表示</p> 
<p>这种书写格式我们也可以通过碎片灰度矩阵的每行灰度值的和表示成折线图，从中图7</p> 
<p>观察出来。每当那一行的值变化比较剧烈时，那一行一般情况下总是四线中的某一线。</p> 
<p>通过多次分析得出相邻两条直线之间的距离，大致分别为(12,20,15,25),之后制作模板，把每一个碎片与模板比较。</p> 
<p>通过寻找每一个碎片起始直线位置，与模板对应寻找可以匹配的个数，通过循环找出与模板匹配率最高的模式。根据匹配的模式，从起始位置对碎片根据此模式的间距向上向下添加直线，完成直线填补工作。</p> 
<p>之后，通过模糊C均值(FCM)聚类方法进行分类，根据补齐直线投影矩阵分出11类，由于分类方法的模糊性特征，造成分出的类别误差相对较大（如下），在之后运用相关性函数匹配时造成了很大的错误，在人工干预时大大增加了工作量。</p> 
<p>表6：英文碎片分类结果</p> 
<p>C1<br> 7     15    18    24    48    55    61    62    63    69    71    85    91    92    97    100  101  102  104  123 138  147  149  157  173  175  186  196  197  199  209<br> C2<br> 27    29    34    143  163  170<br> C3<br> 3     5     12    22    33    40    65    66    68    76    105  107  113  120  137  148  150  155  180  181 185  190  191  192  193  198  205<br> C4<br> 8     50    119  134  169<br> C5<br> 10    11    17    20    45    57    58    67    72    83    84    93    94    106  122  127  135  142  146  153 158  172  177  183  184  195  203  206<br> C6<br> 19    23    28    35    36    43    56    75    89    111  115  152  156  166  168<br> C7<br> 16    21    37    42    44    46    74    77    78    80    103  109  117  124  136  141  144  162  174  200 208<br> C8<br> 1     2     49    51    53    54    64    73    82    86    88    90    98    116  121  125  126  129  130  132 139  140  154  160  161  176  178  188  194  201 <br> C9<br> 4     6     14    25    31    38    41    47    52    59    108  112  114  118  128  131  133  145  151  159 164  179  187  189  202  207<br> C10<br> 13    32    39    60    70    79    95    96    99  165  167  204<br> C11<br> 9     26    30    81    87    110  171  182<br> 尽管直线修补后误差依然不小，相比于直接模糊C均值(FCM)聚类方法分类，大大提高了成功率，所以可以根据英文字书写格式的这种特征来进行向量投影。</p> 
<p>表7：附件四的拼接顺序</p> 
<p>191<br> 75<br> 11<br> 154<br> 190<br> 184<br> 2<br> 104<br> 180<br> 64<br> 106<br> 4<br> 149<br> 32<br> 204<br> 65<br> 39<br> 67<br> 147<br> 201<br> 148<br> 170<br> 196<br> 198<br> 94<br> 113<br> 164<br> 78<br> 103<br> 91<br> 80<br> 101<br> 26<br> 100<br> 6<br> 17<br> 28<br> 146<br> 86<br> 51<br> 107<br> 29<br> 40<br> 158<br> 186<br> 98<br> 24<br> 117<br> 150<br> 5<br> 59<br> 58<br> 92<br> 30<br> 37<br> 46<br> 127<br> 19<br> 194<br> 93<br> 141<br> 88<br> 121<br> 126<br> 105<br> 155<br> 114<br> 176<br> 182<br> 151<br> 22<br> 57<br> 202<br> 71<br> 165<br> 82<br> 159<br> 139<br> 1<br> 129<br> 63<br> 138<br> 153<br> 53<br> 38<br> 123<br> 120<br> 175<br> 85<br> 50<br> 160<br> 187<br> 97<br> 203<br> 31<br> 20<br> 41<br> 108<br> 116<br> 136<br> 73<br> 36<br> 207<br> 135<br> 15<br> 76<br> 43<br> 199<br> 45<br> 173<br> 79<br> 116<br> 179<br> 143<br> 208<br> 21<br> 7<br> 49<br> 61<br> 119<br> 33<br> 142<br> 168<br> 62<br> 169<br> 54<br> 192<br> 133<br> 118<br> 189<br> 162<br> 197<br> 112<br> 70<br> 84<br> 60<br> 14<br> 68<br> 174<br> 137<br> 195<br> 8<br> 47<br> 172<br> 156<br> 96<br> 23<br> 99<br> 122<br> 90<br> 185<br> 109<br> 132<br> 181<br> 95<br> 69<br> 167<br> 163<br> 166<br> 188<br> 111<br> 144<br> 206<br> 3<br> 130<br> 34<br> 13<br> 110<br> 25<br> 27<br> 178<br> 171<br> 42<br> 66<br> 205<br> 10<br> 157<br> 74<br> 145<br> 83<br> 134<br> 55<br> 18<br> 56<br> 35<br> 16<br> 9<br> 183<br> 152<br> 44<br> 81<br> 77<br> 128<br> 200<br> 131<br> 52<br> 125<br> 140<br> 193<br> 87<br> 89<br> 48<br> 72<br> 12<br> 177<br> 124<br> 0<br> 102<br> 115<br> 根据不同的文字特征，对中英文碎片采取了不同的数学模型，汉字属于方块字，有明显的笔画连续性，字宽、字高，通过对方块字字块的判断可以比较好的判断匹配率；英文有明显的四线三格模式，通过直线寻找可以很好地把英文特征识别，提高匹配率。</p> 
<p>5.3问题三的求解</p> 
<p>5.3.1 基于组合匹配模型的双面碎片拼接</p> 
<p>针对第三问附件中碎片的正反面，若某一碎片正面与另一碎片正面能够匹配，那么这两张图片的反面就是匹配的。利用这一特性，我们可以建立组合匹配模型。</p> 
<p>将碎片图像信息转化为灰度矩阵，将每张图片的a，b面所对应的灰度矩阵上下拼接，每张碎片的拼接方案有两种（灰度矩阵a放在左右镜像处理后的b上或灰度矩阵b放在左右镜像处理后的a上），效果如图8所示：</p> 
<p>图8 拼接方案</p> 
<p>通过拼接大大增加碎片的信息量，在接下来的模式匹配寻找，行列拼接时提高了成功率。</p> 
<p>拼接之后，延用第二问的全局搜索模型。首先，搜索碎片的行首、行尾放到两个数组中，并把行首、行尾为之标记；接着，全文搜索，运用相关系数函数匹配，寻找出与之匹配率最高的碎片，放进一个集合中。</p> 
<p>由于灰度矩阵的相似性，匹配时出现错误，形成一段一段拼接好的碎片图像，观察每一行用肉眼可以看出的错误的位置，并进行调整，最后，把每一行的碎片拼接完成。每一行拼接好之后，假设a面为正面，b面为反面，把b面的灰度矩阵连接到a面后面，形成Z（a，b）灰度矩阵；如果b为正面，a为反面，形成Z（b，a）灰度矩阵。</p> 
<p>把每一行的灰度矩阵，之后把灰度矩阵进行转置，运用第一问的碎片相关性方法对灰度矩阵进行匹配，最后得出正确结果：</p> 
<p>表8：附件五碎片正面拼接顺序</p> 
<p>136a<br> 047b<br> 020b<br> 164a<br> 081a<br> 189a<br> 029b<br> 018a<br> 108b<br> 066b<br> 110b<br> 174a<br> 183a<br> 150b<br> 155b<br> 140b<br> 125b<br> 111a<br> 078a<br> 005b<br> 152b<br> 147b<br> 060a<br> 059b<br> 014b<br> 079b<br> 144b<br> 120a<br> 022b<br> 124a<br> 192b<br> 025a<br> 044b<br> 178b<br> 076a<br> 036b<br> 010a<br> 089b<br> 143a<br> 200a<br> 086a<br> 187a<br> 131a<br> 056a<br> 138b<br> 045b<br> 137a<br> 061a<br> 094a<br> 098b<br> 121b<br> 038b<br> 030b<br> 042a<br> 084a<br> 153b<br> 186a<br> 083b<br> 039a<br> 097b<br> 175b<br> 072a<br> 093b<br> 132a<br> 087b<br> 198a<br> 181a<br> 034b<br> 156b<br> 206a<br> 173a<br> 194a<br> 169a<br> 161b<br> 011a<br> 199a<br> 090b<br> 203a<br> 162a<br> 002b<br> 139a<br> 070a<br> 041b<br> 170a<br> 151a<br> 001a<br> 166a<br> 115a<br> 065a<br> 191b<br> 037a<br> 180b<br> 149a<br> 107b<br> 088a<br> 013b<br> 024b<br> 057b<br> 142b<br> 208b<br> 064a<br> 102a<br> 017a<br> 012b<br> 028a<br> 154a<br> 179b<br> 158b<br> 058b<br> 207b<br> 116a<br> 179a<br> 184a<br> 114b<br> 035b<br> 159b<br> 073a<br> 193a<br> 163b<br> 130b<br> 021a<br> 202b<br> 053a<br> 077a<br> 016a<br> 019a<br> 092a<br> 190a<br> 050b<br> 201b<br> 031b<br> 171a<br> 146b<br> 172b<br> 122b<br> 182a<br> 040b<br> 127b<br> 188b<br> 068a<br> 008a<br> 117a<br> 167b<br> 075a<br> 063a<br> 067b<br> 046b<br> 168b<br> 157b<br> 128b<br> 195b<br> 165a<br> 105b<br> 204a<br> 141b<br> 135a<br> 027b<br> 080a<br> 000a<br> 185b<br> 176b<br> 126a<br> 074a<br> 032b<br> 069b<br> 004b<br> 077b<br> 148a<br> 085a<br> 007a<br> 03a<br> 009a<br> 145b<br> 082a<br> 205b<br> 015a<br> 101b<br> 118a<br> 129a<br> 062b<br> 052b<br> 071a<br> 033a<br> 119b<br> 160a<br> 095b<br> 051a<br> 048b<br> 133b<br> 023a<br> 054a<br> 196a<br> 112b<br> 103b<br> 055a<br> 100a<br> 106a<br> 091b<br> 049a<br> 026a<br> 113b<br> 134b<br> 104b<br> 006b<br> 123b<br> 109b<br> 096a<br> 043b<br> 099b<br> 表9：附件五碎片反面拼接顺序</p> 
<p>078b<br> 111b<br> 125a<br> 140a<br> 155a<br> 150a<br> 183b<br> 174b<br> 110a<br> 066a<br> 108a<br> 018b<br> 029a<br> 189b<br> 081b<br> 164b<br> 020a<br> 047a<br> 136b<br> 089a<br> 010b<br> 036a<br> 076b<br> 178a<br> 044a<br> 025b<br> 192a<br> 124b<br> 022a<br> 120b<br> 144a<br> 079a<br> 014a<br> 059a<br> 060b<br> 147a<br> 152a<br> 005a<br> 186b<br> 153a<br> 084b<br> 042b<br> 030a<br> 038a<br> 121a<br> 098a<br> 094b<br> 061b<br> 137b<br> 045a<br> 138a<br> 056b<br> 131b<br> 187b<br> 086b<br> 200b<br> 143b<br> 199b<br> 011b<br> 161a<br> 169b<br> 194b<br> 173b<br> 206b<br> 156a<br> 034a<br> 181b<br> 198b<br> 087a<br> 132b<br> 093a<br> 072b<br> 175a<br> 097a<br> 039b<br> 083a<br> 088b<br> 107a<br> 149b<br> 180a<br> 037b<br> 191a<br> 065b<br> 115b<br> 166b<br> 001b<br> 151b<br> 170b<br> 041a<br> 070b<br> 139b<br> 002a<br> 162b<br> 203b<br> 090a<br> 114a<br> 184b<br> 179b<br> 116b<br> 207a<br> 058a<br> 158a<br> 179a<br> 154b<br> 028b<br> 012a<br> 017b<br> 102b<br> 064b<br> 208a<br> 142a<br> 057a<br> 024a<br> 013a<br> 146a<br> 171b<br> 031a<br> 201a<br> 050a<br> 190b<br> 092b<br> 019b<br> 016b<br> 077b<br> 053b<br> 202a<br> 021b<br> 130a<br> 163a<br> 193b<br> 073b<br> 159a<br> 035a<br> 165b<br> 195a<br> 128a<br> 157a<br> 168a<br> 046a<br> 067a<br> 063b<br> 075b<br> 167a<br> 117b<br> 008b<br> 068b<br> 188a<br> 127a<br> 040a<br> 182b<br> 122a<br> 172a<br> 03b<br> 007b<br> 085b<br> 148b<br> 077a<br> 004a<br> 069a<br> 032a<br> 074b<br> 126b<br> 176a<br> 185a<br> 000b<br> 080b<br> 027a<br> 135b<br> 141a<br> 204b<br> 105a<br> 023b<br> 133a<br> 048a<br> 051b<br> 095a<br> 160b<br> 119a<br> 033b<br> 071b<br> 052a<br> 062a<br> 129b<br> 118b<br> 101a<br> 015b<br> 205a<br> 082b<br> 145a<br> 009b<br> 099a<br> 043a<br> 096b<br> 109a<br> 123a<br> 006a<br> 104a<br> 134a<br> 113a<br> 026b<br> 049b<br> 091a<br> 106b<br> 100b<br> 055b<br> 103a<br> 112a<br> 196b<br> 054b<br> 六．模型结果的分析与检验</p> 
<p>6.1 连续性模型的实验分析检验</p> 
<p>利用文字连续性模型，最终成功将附件一和附件二的长条型中英文字体碎片很好的拼接起来了，拼接后的文章语意通顺，说明结果正确。由于问题一中的纵向切割，使得形成的边缘处除了第一张和最后一张外，其余碎片没有完全空白的情况，这给我们寻找第一张碎片带来了很大的便利。这种先找出第一张碎片，再继续拼接后续碎片的方法。可以大大简化边缘匹配的过程。</p> 
<p>经过程序实验论证，针对问题一的中英文碎片拼接，拼接后的正确率为100%。</p> 
<p>这种连续性模型可以很好的拼接出边缘所含信息较多的碎片。但如果对于边缘只含有少量文字或者与其他碎片含有相似字形较多的碎片，就会产生误差。</p> 
<p>所以这种模型适用于边缘信息较多的碎片拼接。</p> 
<p>6.2  全局搜索模型以及向量投影分组模型的分析检验</p> 
<p>问题二中所给附件三、四都是小碎片，宽度为72像素，与第一问中的一致，但是高度只有180像素，为第一问碎片的1/11，所以左右边缘的像素信息也只为附件一和二的1/11,如果实用文全局搜索模型利用向量相关性的方法来拼接碎片的时间复杂度。</p> 
<p>而如果使用向量投影分组模型，把每一行有黑点的情况投影到一个数组中，组成以一个180*209的数组，之后运用聚类分析方法分出11类，分类时由于空白处造成分类误差，运用相关系数函数匹配判断时出现匹配错误后，运用人工干预，分为11类。然后进行横向匹配，此时的时间复杂度只为。此模型能节约大量运算时间并且能较好得适应边缘特征并不明显的时候，但由于分类的误差，造成最后匹配时出现了错误，需要人工干预，增加了工作量。</p> 
<p>6.3  组合匹配模型的分析检验</p> 
<p>通过图片的组合拼接，把碎片的信息量进行扩充，增大信息量，图片特征，在下面的对每一行的分类，每一列的匹配拼接提高了成功率。并通过反面对正面的检测分析，可以更好的避免误差，减少人工干预的次数，减少了工作量。但由于使用的是全局搜索模型，在时间复杂度，耗时较多。</p> 
<p>图9附件五碎片横向拼接</p> 
<p>根据碎片拼接图片可以看出，有碎片拼接错误，主要缘由是匹配函数的选取，相关性的匹配，近似灰度矩阵就会造成干扰。使得最后匹配的数据出现了错误，造成一段一段的碎片，给人工干预时造成了一定的麻烦。通过反面的拼接去检验正面拼接的正确性。</p> 
<p>七．模型的评价与推广</p> 
<p>7．1 模型的评价</p> 
<p>（1）问题一中的连续性模型对于拼接边缘信息量较大的碎片有较高的效率以及很高的准确率，但是当单独用该模型解决例如附件三、四的小碎片时，虽然效率很高，但是准确率较低。比如，如果有两张或者多张图片边缘切割都为白色时，可能就会出现无法匹配的情况，这时就需要人工干预；向量相关模型相对于文字连续性模型，具有更高的准确度。</p> 
<p>（2）问题二中的全局搜索模型不仅耗时多，而且由于给的信息很少，在这么多图片中匹配，会造成准确率很低的情况；向量投影分组模型，投影图片灰度向量到投影矩阵中，利用FCM聚类分析方法让打乱的横切及纵切的图片得以分类，从而分步实现了碎片的排序，简化了拼接过程，大大减少了循环匹配的次数；</p> 
<p>（3）问题三中组合匹配模型将附件五中的a，b两图片上下拼接，然后用拼接后的图片进行分类，这样不仅提高了效率，还一定程度上增加了碎片所提供的信息。</p> 
<p>7. 2 模型的推广</p> 
<p>这三种模型针对不同的情况，利用多种模型和匹配方法，能够较好的解决题目中的三个问题。</p> 
<p>但是，我们仍然可以考虑其他特征，结合连续性模型或者向量相关模型综合考虑，比如字宽特征，计算两边的碎片边缘被切开字的缺损字宽，两边相加，当和值与标准字宽相差较大时，就可以排除不利因素。</p> 
<p>现在已经有很多模式识别的算法和软件，我们可以利用文字识别算法来计算拼接后的两片碎片上的文字上的准确率，当准确率较高时，则认为匹配成功。利用已有的技术，可以大大效率有准确率</p> 
<p>八．参考文献</p> 
<p>[1] 章毓晋. 图像处理（第三版）. 清华大学出版社，2012.2</p> 
<p>[2] 边肇祺，张学工. 模式识别（第二版）.清华大学出版社 2000.1</p> 
<p>[3] 冯宇平,戴明,孙立悦，张威. 图像自动拼接融合的优化设计.光学精密工程.2012,18（2）</p> 
<p>[4] 李仁发，杨高波. 特征提取与图像处理（第二版）.电子工业出版社 2010.10</p> 
<p>[5] 陈丽莉，刘贵喜.一种有效的序列图像自动拼接方法. 光电子激光. 2011,22（7）</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>九．附录</p> 
<p>附录一：程序代码</p> 
<p>% 第一问代码 文件名：Qusetion1.m</p> 
<p>files=dir('C:\Users\ZYF\Desktop\新建文件夹\B\附件1\*.bmp');    %批量载入图像</p> 
<p>for n=1:numel(files)</p> 
<p> image{n}=imread(['C:\Users\ZYF\Desktop\新建文件夹\B\附件1\'files(n).name]);</p> 
<p>end</p> 
<p>[h,z]=size(image{1,1});</p> 
<p>for k=1:n</p> 
<p>   byz(:,k)=image{1,k}(:,1);      %将第k张图片的最左边一列放入矩阵byz的第k列                         </p> 
<p>   byy(:,k)=image{1,k}(:,z);      %将第k张图片的最右边一列放入矩阵byy的第k列</p> 
<p>end</p> 
<p>%利用页边距寻找第一张图片</p> 
<p>for i=1:n</p> 
<p>    sum=0;</p> 
<p>    for j=1:h</p> 
<p>        if byz(j,i)==255</p> 
<p>            sum=sum+1;</p> 
<p>        else</p> 
<p>            break;</p> 
<p>        end</p> 
<p>    end</p> 
<p>    if sum==h</p> 
<p>        f=i;</p> 
<p>    end</p> 
<p>end</p> 
<p>paixu=zeros(1,n);</p> 
<p>index=1;</p> 
<p>paixu(index)=f; </p> 
<p> </p> 
<p>%依据连续性模型需找匹配点</p> 
<p>for i=2:n</p> 
<p>    max=0;</p> 
<p>    for j=1:n</p> 
<p>        sumofbp=0;</p> 
<p>        num=0;</p> 
<p>        for k=2:h-1</p> 
<p>            ifbyy(k,paixu(index))~=255</p> 
<p>                ifbyz(k,j)&lt;255||byz(k-1,j)&lt;255||byz(k+1,j)&lt;255</p> 
<p>                    num=num+1;</p> 
<p>                else</p> 
<p>                    num=num;</p> 
<p>                end;</p> 
<p>            end</p> 
<p>        end</p> 
<p>    if num&gt;max</p> 
<p>       max=num;</p> 
<p>       signal=j;</p> 
<p>    end</p> 
<p>  end</p> 
<p>    index=index+1;</p> 
<p>    paixu(index)=signal;               %存放排好序的图片序号</p> 
<p>end</p> 
<p>temp=image{paixu(1)};</p> 
<p>for i=2:n</p> 
<p>    temp=[tempimage{paixu(i)}];       %将排序好的图片存放与temp       </p> 
<p>end</p> 
<p>imshow(temp)                           %完整显示整张纸片</p> 
<p> </p> 
<p> </p> 
<p>%第二问中文拼接中投影代码   文件名reflect.m</p> 
<p>% 碎片预处理，图像投影，存放投影数组</p> 
<p>files=dir('C:\Users\ZYF\Desktop\新建文件夹\B\附件3\*.bmp');%载入图像</p> 
<p>figure;</p> 
<p>A=zeros(1,180);</p> 
<p>for n=1:numel(files)</p> 
<p>image{n}=imread(['C:\Users\ZYF\Desktop\新建文件夹\B\附件3\' files(n).name]);</p> 
<p>end</p> 
<p>[x,y]=size(image{1});</p> 
<p>flag1=zeros(x,n);</p> 
<p>for i=1:n</p> 
<p>    for j=1:x</p> 
<p>        sum=0;</p> 
<p>        for k=1:y</p> 
<p>            ifimage{i}(j,k)&lt;255       </p> 
<p>                break;</p> 
<p>            else</p> 
<p>                sum=sum+1;</p> 
<p>            end</p> 
<p>        end</p> 
<p>        if sum==y</p> 
<p>            flag1(j,i)=0;</p> 
<p>        else</p> 
<p>            flag1(j,i)=1;</p> 
<p>        end</p> 
<p>    end</p> 
<p>end</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>%如果采用掩码模型，则运行代码yanma.m（包含3个函数top.m,mid.m,back.m）</p> 
<p>%附件三掩码补充代码   文件名   yanma.m</p> 
<p>files4=dir('C:\Users\asus\Desktop\2013B3\附件3\*.bmp');%载入图像</p> 
<p>for n4=1:numel(files4)</p> 
<p> image4{n4}=imread(['C:\Users\asus\Desktop\2013B3\附件3\' files4(n4).name]);</p> 
<p>end</p> 
<p>fid1=fopen('C:\Users\asus\Desktop\数模数据.txt','wt');</p> 
<p>fid2=fopen('C:\Users\asus\Desktop\需补充.txt','wt');</p> 
<p>[x,y]=size(image4{1});</p> 
<p>flag=zeros(x,n4);</p> 
<p>%向量投影</p> 
<p>for i=1:n4</p> 
<p>    for j=1:x</p> 
<p>        sum=0;</p> 
<p>        for k=1:y</p> 
<p>            ifimage4{i}(j,k)&lt;255</p> 
<p>                break;</p> 
<p>            else</p> 
<p>                sum=sum+1;</p> 
<p>            end</p> 
<p>        end</p> 
<p>        if sum==y</p> 
<p>            flag(j,i)=0;</p> 
<p>        else</p> 
<p>            flag(j,i)=1;</p> 
<p>        end</p> 
<p>    end</p> 
<p>end</p> 
<p> </p> 
<p>sumofb=0;</p> 
<p>for i=1:209</p> 
<p>    sumofb=0;</p> 
<p>    for j=1:179      </p> 
<p>       ifflag(j,i)==1&amp;&amp;flag(j+1,i)==0             </p> 
<p>              sumofb=sumofb+1;</p> 
<p>       else</p> 
<p>              sumofb=sumofb;</p> 
<p>       end    </p> 
<p>    end</p> 
<p>    if flag(180,i)==1</p> 
<p>        sumofb=sumofb+1;</p> 
<p>    end</p> 
<p>    numofb(i)=sumofb;</p> 
<p>end</p> 
<p>for i=1:209</p> 
<p>    if numofb(i)&lt;3</p> 
<p>        fprintf(fid2,'%g ',i);</p> 
<p>    end</p> 
<p>end</p> 
<p>flagnew=flag;</p> 
<p>A=[5 9 15 17 22 26 28 33 41 61 67 71 72 75 86 90 94 102 107 109 110111 114 115 118 120 124 126 140 141 146 147 151 153 154 155 156 158 166 167 174182 185 186 188 195 197 198 205 206 208];</p> 
<p>[ax,ay]=size(A);</p> 
<p>shul=zeros(ay,6);</p> 
<p>for i=1:ay%统计投影白色0和黑色1的数量</p> 
<p>    sumofd=0;</p> 
<p>    index=1;</p> 
<p>    if flag(1,A(i))==1%若第一个为黑色，则白色个数为0</p> 
<p>        shul(i,index)=0;</p> 
<p>        index=index+1;</p> 
<p>    end</p> 
<p>    for j=1:179</p> 
<p>        ifflag(j,A(i))==flag(j+1,A(i))</p> 
<p>            sumofd=sumofd+1;</p> 
<p>        else</p> 
<p>            sumofd=sumofd+1;</p> 
<p>           shul(i,index)=sumofd;</p> 
<p>            index=index+1;</p> 
<p>            sumofd=0;</p> 
<p>        end</p> 
<p>    end</p> 
<p>    shul(i,index)=sumofd+1;</p> 
<p>end</p> 
<p>for i=1:ay</p> 
<p>    if shul(i,1)&gt;26</p> 
<p>        topout=top(shul(i,1));</p> 
<p>        hebin(i,:)=[topoutshul(i,2:6)];</p> 
<p>    end</p> 
<p>end</p> 
<p>for i=1:ay</p> 
<p>    for j=3</p> 
<p>        if shul(i,j)&gt;31</p> 
<p>           midout=mid(shul(i,j));</p> 
<p>           hebin(i,:)=[shul(i,1:2) midout shul(i,4:6)];</p> 
<p>        end</p> 
<p>    end</p> 
<p>end</p> 
<p>for i=1:ay</p> 
<p>    for j=5</p> 
<p>        if shul(i,j)&gt;26</p> 
<p>           backout=back(shul(i,j));</p> 
<p>           hebin(i,:)=[shul(i,1:4) backout];</p> 
<p>        end</p> 
<p>    end</p> 
<p>end</p> 
<p> for i=1:ay</p> 
<p>     if hebin(i,1)~=0</p> 
<p>        temp=hebin(i,1);</p> 
<p>     else</p> 
<p>         temp=1;</p> 
<p>     end</p> 
<p>     for j=2:2:6</p> 
<p>        flagnew(temp:(temp+hebin(i,j)),A(i))=1;</p> 
<p>        temp=temp+hebin(i,j)+hebin(i,j+1);</p> 
<p>     end</p> 
<p> end</p> 
<p> </p> 
<p> </p> 
<p>%top函数代码   文件名top.m</p> 
<p>%top函数        </p> 
<p> function [ topout ] = top( in)</p> 
<p>if in&lt;69</p> 
<p>    topout=[0 in-26 26];</p> 
<p>elseif 68&lt;in&lt;95</p> 
<p>    topout=[in-68 42 26];</p> 
<p>elseif 94&lt;in&lt;137</p> 
<p>    topout=[0 in-94 26 42 26];</p> 
<p>elseif 136&lt;in&lt;163</p> 
<p>    topout=[in-136 42 26 4226];</p> 
<p>else</p> 
<p>    topout=[0 in-162 26 42 2642 26];</p> 
<p>end</p> 
<p>end</p> 
<p> </p> 
<p>%mid函数   文件名   mid.m</p> 
<p>%mid函数</p> 
<p>function [ midout ] = mid( in )</p> 
<p>if in&lt;101</p> 
<p>    midout=[26 in-52 26];</p> 
<p>elseif 100&lt;in&lt;163</p> 
<p>    midout=[26 42 26 in-12026];</p> 
<p>end</p> 
<p>end</p> 
<p> </p> 
<p>%back函数   文件名 back.m</p> 
<p>%back函数</p> 
<p>function [ backout ] = back( in )</p> 
<p>if in&lt;69</p> 
<p>    backout=[26 in-26 0 0];</p> 
<p>elseif 68&lt;in&lt;95</p> 
<p>    backout=[26 42 in-68 0];</p> 
<p>elseif 94&lt;in&lt;137</p> 
<p>    backout=[26 42 26 in-94];</p> 
<p>end</p> 
<p>end</p> 
<p> </p> 
<p> </p> 
<p>%第二问C均值分类代码  文件名Classify.m</p> 
<p>%模糊C均值（fcm）分类</p> 
<p>clear;</p> 
<p>close all;</p> 
<p>load flag1.mat;</p> 
<p>files=dir('C:\Users\ZYF\Desktop\新建文件夹\B\附件3\*.bmp');%载入图像</p> 
<p>figure;</p> 
<p>for n=1:numel(files)</p> 
<p> image{n}=imread(['C:\Users\ZYF\Desktop\新建文件夹\B\附件3\' files(n).name]);</p> 
<p>end</p> 
<p>data = flag1';</p> 
<p>[center,U,obj_fcn] = fcm(data, 11);</p> 
<p>maxU = max(U);</p> 
<p>%index(i)中存放第i类分组的图片</p> 
<p>index(1).t = find(U(1,:) == maxU);</p> 
<p>index(2).t = find(U(2, :) == maxU);</p> 
<p>index(3).t = find(U(3,:) == maxU);</p> 
<p>index(4).t = find(U(4,:) == maxU);</p> 
<p>index(5).t = find(U(5,:) == maxU);</p> 
<p>index(6).t = find(U(6,:) == maxU);</p> 
<p>index(7).t = find(U(7,:) == maxU);</p> 
<p>index(8).t = find(U(8,:) == maxU);</p> 
<p>index(9).t = find(U(9,:) == maxU);</p> 
<p>index(10).t = find(U(10,:) == maxU);</p> 
<p>index(11).t= find(U(11,:) == maxU);</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>%第二问中文拼接代码   文件名Question_Chinese.m</p> 
<p>clear;</p> 
<p>close all;</p> 
<p>% 问题二汉字匹配拼接</p> 
<p>load index.mat;</p> 
<p>class=12;</p> 
<p>files=dir('C:\Users\ZYF\Desktop\新建文件夹\B\附件3\*.bmp');%载入图像</p> 
<p> </p> 
<p>for n=1:numel(files)</p> 
<p> image{n}=imread(['C:\Users\ZYF\Desktop\新建文件夹\B\附件3\' files(n).name]);</p> 
<p>end</p> 
<p> </p> 
<p>for k=1:n</p> 
<p>    bz(:,k)=image{1,k}(:,1);                 %将第k张图片的最左边一列放入矩阵bz的第k列</p> 
<p>   br(:,k)=image{1,k}(:,72);               %将第k张图片的最右边一列放入矩阵br的第k列</p> 
<p>end</p> 
<p>ind=1;</p> 
<p>for oo=1:class</p> 
<p>    tmp=[];</p> 
<p>    first=index(oo).t;                      %将index分组的第oo组存放入first矩阵</p> 
<p>    cd=length(first);</p> 
<p>    f=zeros(1,cd);                         %标记图片是否已被使用，初始为0</p> 
<p>     kk=0;</p> 
<p>    for j=1:cd</p> 
<p>        sum=0;</p> 
<p>        for p=1:180</p> 
<p>            for q=1:5</p> 
<p>             ifimage{first(1,j)}(p,q)==255</p> 
<p>                sum=sum+1;</p> 
<p>             end</p> 
<p>            end</p> 
<p>        end</p> 
<p>        if sum==900</p> 
<p>            figure (oo);</p> 
<p>            subplot(1,cd,1)</p> 
<p>            imshow( image{first(j)});</p> 
<p>            kk=first(j);</p> 
<p>           f(1,1)=first(j);                 %已用图片</p> 
<p>            break;</p> 
<p>        end</p> 
<p>    end</p> 
<p>    jj=1;</p> 
<p>    if(kk==0)</p> 
<p>       figure (oo);</p> 
<p>            subplot(1,cd,1)</p> 
<p>            imshow( image{first(1)});</p> 
<p>            kk=first(1);</p> 
<p>           f(1,1)=first(1);                % 已用图片</p> 
<p>    end</p> 
<p>    tmp=[tmp kk];</p> 
<p>    sign=kk;</p> 
<p>    for z=1:cd</p> 
<p>        max=0;</p> 
<p>        for a=1:cd</p> 
<p>           sum1=0;</p> 
<p>           hh=0;</p> 
<p>          for ll=1:cd</p> 
<p>             if(first(a)==f(1,ll))</p> 
<p>                  hh=1;</p> 
<p>              end</p> 
<p>          end</p> 
<p>          if(hh==0)</p> 
<p>             co=corrcoef(double(bz(:,first(a))),double(br(:,kk)));% 相关性函数判断</p> 
<p>                 sum1=abs(co(1,2));</p> 
<p>           if(max&lt;sum1)</p> 
<p>               max=sum1;</p> 
<p>               sign=first(a);</p> 
<p>           end</p> 
<p>          end</p> 
<p>        end</p> 
<p> </p> 
<p>    if(kk ~= sign)</p> 
<p>        tmp=[tmp sign];</p> 
<p>        subplot(1,cd,jj+1)</p> 
<p>        imshow(image{sign});</p> 
<p>        kk=sign;                          %现在图片</p> 
<p>        f(1,jj+1)=sign;</p> 
<p>        jj=jj+1;</p> 
<p>    else</p> 
<p>       for d=1:cd</p> 
<p>             for s=1:cd</p> 
<p>                 gg=0;</p> 
<p>                if(first(d) ==f(1,s))</p> 
<p>                  gg=1;</p> 
<p>                 end</p> 
<p>             end</p> 
<p>              if(gg==0)</p> 
<p>                  kk=first(d);</p> 
<p>                  break;</p> 
<p>              end</p> 
<p>        end</p> 
<p>        cc(ind).a=tmp;</p> 
<p>        ind=ind+1;</p> 
<p>        tmp=[kk];</p> 
<p>     end</p> 
<p>    end</p> 
<p> end</p> 
<p> </p> 
<p> </p> 
<p>%第二问英文添加直线代码  文件名  Line.m</p> 
<p>% 英文直线的修补</p> 
<p>clear;</p> 
<p>close all;</p> 
<p>files=dir('.\附件4\*.bmp');%载入图像</p> 
<p>for n=1:numel(files)</p> 
<p>   image{n}=imread(['.\附件4\' files(n).name]);</p> 
<p>   A(n).t=sum(image{n},2);</p> 
<p>end</p> 
<p> </p> 
<p>B=[12,20,15,25,12,20,15,25];%做模板</p> 
<p>B1=[12,20,15,25,12,20,15,25,12,20,15,25];</p> 
<p>B2=[20,15,25,12,20,15,25,12,20,15,25,12];</p> 
<p>B3=[15,25,12,20,15,25,12,20,15,25,12,20];</p> 
<p>B4=[25,12,20,15,25,12,20,15,25,12,20,15];</p> 
<p>idx1=zeros(600,1);% 模板数组</p> 
<p>idx1(1,1)=1;</p> 
<p>mm=1;</p> 
<p>for i=1:6</p> 
<p>   for j=1:4</p> 
<p>       mm=mm+B(j);</p> 
<p>       idx1(mm,1)=1;</p> 
<p>   end</p> 
<p>end</p> 
<p> </p> 
<p>%ind=A(10).t;</p> 
<p>BZ=zeros(180,209);</p> 
<p>for pp=1:209</p> 
<p>   ind=A(pp).t;</p> 
<p>   for i=2:179   % 拐点找出</p> 
<p>       if(ind(i-1)-ind(i)&gt;10 &amp;&amp;ind(i+1)-ind(i)&gt;10)</p> 
<p>           BZ(i,pp)=1;</p> 
<p>       end</p> 
<p>   end</p> 
<p>   if ind(1)&lt;ind(2)</p> 
<p>       BZ(1,pp)=1;</p> 
<p>   end</p> 
<p>   if ind(180)&lt;ind(179)</p> 
<p>       BZ(180,pp)=1;</p> 
<p>   end</p> 
<p>   po=find(BZ(:,pp)==1);</p> 
<p>   gg=1;</p> 
<p>   max=0;</p> 
<p>    for ii=1:5  % 与模板匹配</p> 
<p>       dd=0;</p> 
<p>       fh=0;</p> 
<p>       for z=po(1):180</p> 
<p>           if(BZ(z,pp)==1&amp;&amp;idx1(z+gg,1)==1||z+1&lt;=180&amp;&amp;BZ(z+1,pp)==1&amp;&amp;idx1(z+gg,1)==1||(z-1)~=0&amp;&amp; BZ(z-1,pp)==1&amp;&amp;idx1(z+gg,1)==1)% 与模板匹配</p> 
<p>                dd=dd+1;</p> 
<p>           end</p> 
<p>        end</p> 
<p>       if(max&lt;dd)</p> 
<p>           SG=ii;</p> 
<p>           max=dd;</p> 
<p>           kh=po(1);</p> 
<p>       end</p> 
<p>       gg=gg+B(ii);</p> 
<p>   end</p> 
<p>   </p> 
<p>   if SG==1||SG==4</p> 
<p>       AB=kh;</p> 
<p>       j=1;</p> 
<p>       while AB-B1(5-j)&gt;=1</p> 
<p>           BZ(AB-B1(5-j))=1;</p> 
<p>           AB=AB-B1(5-j);</p> 
<p>           j=mod(j+1,4);</p> 
<p>       end</p> 
<p>       AD=kh;</p> 
<p>       j=1;</p> 
<p>       while AD+B1(j)&lt;=180</p> 
<p>           BZ(AD+B1(j),pp)=1;</p> 
<p>           AD=AD+B1(j);</p> 
<p>           j=j+1;</p> 
<p>       end</p> 
<p>   end</p> 
<p>   if SG==2       </p> 
<p>       AB=kh;</p> 
<p>       j=1;</p> 
<p>        while AB-B2(5-j)&gt;=1</p> 
<p>           BZ(AB-B2(5-j))=1;</p> 
<p>           AB=AB-B2(5-j);</p> 
<p>           j=mod(j+1,4);</p> 
<p>       end</p> 
<p>       AD=kh;</p> 
<p>       j=1;</p> 
<p>       while AD+B2(j)&lt;=180</p> 
<p>           BZ(AD+B2(j),pp)=1;</p> 
<p>           AD=AD+B2(j);</p> 
<p>           j=j+1;</p> 
<p>       end</p> 
<p>   end</p> 
<p>   if SG==3</p> 
<p>       AB=kh;</p> 
<p>       j=1;</p> 
<p>       while AB-B3(5-j)&gt;=1</p> 
<p>           BZ(AB-B3(5-j))=1;</p> 
<p>           AB=AB-B3(5-j);</p> 
<p>           j=mod(j+1,4);</p> 
<p>       end</p> 
<p>       AD=kh;</p> 
<p>       j=1;</p> 
<p>       while AD+B3(j)&lt;=180</p> 
<p>           BZ(AD+B3(j),pp)=1;</p> 
<p>           AD=AD+B3(j);</p> 
<p>           j=j+1;</p> 
<p>       end</p> 
<p>   end</p> 
<p>   if SG == 4</p> 
<p>       AB=kh;</p> 
<p>       j=1;</p> 
<p>       while AB-B4(5-j)&gt;=1</p> 
<p>           BZ(AB-B4(5-j))=1;</p> 
<p>           AB=AB-B4(5-j);</p> 
<p>           j=mod(j+1,4);</p> 
<p>       end</p> 
<p>       AD=kh;</p> 
<p>        j=1;</p> 
<p>       while AD+B4(j)&lt;=180</p> 
<p>           BZ(AD+B4(j),pp)=1;</p> 
<p>           AD=AD+B4(j);</p> 
<p>           j=j+1;</p> 
<p>       end</p> 
<p>   end</p> 
<p>end</p> 
<p> </p> 
<p>%第二问英文拼接主代码  文件名  Question.m</p> 
<p>clear;</p> 
<p>close all;</p> 
<p>load index2.mat;</p> 
<p>class=12;</p> 
<p>files=dir('C:\Users\ZYF\Desktop\新建文件夹\B\附件4\*.bmp');%载入图像</p> 
<p>for n=1:numel(files)</p> 
<p>   image{n}=imread(['C:\Users\ZYF\Desktop\新建文件夹\B\附件4\'files(n).name]);</p> 
<p>end</p> 
<p>for k=1:n</p> 
<p>   bz(:,k)=image{1,k}(:,1); %首行</p> 
<p>   br(:,k)=image{1,k}(:,72);%末行</p> 
<p>end</p> 
<p>ind=1; % 类别计数器</p> 
<p>for oo=1:class</p> 
<p>   dx=0;   %  倒序寻找</p> 
<p>   tmp=[];</p> 
<p>   first=index2(oo).t;</p> 
<p>   cd=length(first);</p> 
<p>   f=zeros(1,length(first));  %标记</p> 
<p>   kk=0;</p> 
<p>   while (sum(f)&lt;length(first))</p> 
<p>       if length(tmp)==0            % 找行首块</p> 
<p>           for j=1:length(first)</p> 
<p>                if f(j)==0</p> 
<p>                    im=image{ first(j)};</p> 
<p>                    sumim=sum(im,1);</p> 
<p>                    ifsum(sumim(1:10))==255*180*10  % 找到行首</p> 
<p>                        figure (oo);</p> 
<p>                       subplot(1,length(first),1)</p> 
<p>                        imshow( image{first(j)});</p> 
<p>                        kk=first(j);</p> 
<p>                        f(j)=1;% 标记已用图片</p> 
<p>                        break;</p> 
<p>                    end</p> 
<p>                end</p> 
<p>           end</p> 
<p>           % 找块尾</p> 
<p>           for j=1:length(first)</p> 
<p>                if f(j)==0</p> 
<p>                    im=image{ first(j)};</p> 
<p>                    sumim=sum(im,1);</p> 
<p>                    ifsum(sumim(70:72))==255*180*3  % 找到行尾</p> 
<p>                        figure (oo);</p> 
<p>                       subplot(1,length(first),1)</p> 
<p>                        imshow( image{ first(j)});</p> 
<p>                        kk=first(j);</p> 
<p>                        f(j)=1;% 标记已用图片</p> 
<p>                        dx=1;</p> 
<p>                        break;</p> 
<p>                    end</p> 
<p>                end</p> 
<p>           end           </p> 
<p>           if(kk==0)  % dou找不到，用第可用一个图片</p> 
<p>                figure (oo);</p> 
<p>                subplot(1,length(first),1);</p> 
<p>                imshow( image{ first(1)});</p> 
<p>                pos=find(f==0);</p> 
<p>                kk=first(pos(1));</p> 
<p>                f(pos(1))=1; % 标记已用图片</p> 
<p>           end</p> 
<p>           tmp=[tmp kk];</p> 
<p>       end       </p> 
<p>       maxsum=0; % 找最接近的</p> 
<p>       sign=kk;</p> 
<p>       for z=1:length(first)</p> 
<p>           if f(z)==0   % 没有用过</p> 
<p>                sum1=0;</p> 
<p>                for p=1:180</p> 
<p>                    if dx==1</p> 
<p>                        cha=abs(bz(p,kk)-br(p,first(z)));</p> 
<p>                        if ( cha ==0 &amp;&amp;bz(p,kk)~= 255 &amp;&amp; br(p,first(z))~=255)</p> 
<p>                            sum1=sum1+1;</p> 
<p>                        end</p> 
<p>                    else</p> 
<p>                       cha=abs(br(p,kk)-bz(p,first(z)));</p> 
<p>                       if ( cha &lt;20&amp;&amp; br(p,kk)~= 255 &amp;&amp; bz(p,first(z))~=255)</p> 
<p>                            sum1=sum1+1;</p> 
<p>                        end</p> 
<p>                    end</p> 
<p>                end</p> 
<p>                if(maxsum&lt;sum1)</p> 
<p>                    maxsum=sum1;</p> 
<p>                   fpos=z;</p> 
<p>                    sign=first(z);</p> 
<p>                end</p> 
<p>           end</p> 
<p>       end</p> 
<p>       if maxsum&lt;1</p> 
<p>           sign=kk;</p> 
<p>       end</p> 
<p>       if(kk~=sign)</p> 
<p>           %找到了</p> 
<p>           if dx==1</p> 
<p>                tmp=[sign tmp ];</p> 
<p>           else</p> 
<p>                tmp=[tmp sign];</p> 
<p>           end</p> 
<p>           imshow(image{sign});</p> 
<p>           kk=sign;%现在图片</p> 
<p>           f(fpos)=1;</p> 
<p>       else            %没找到</p> 
<p>           cc(ind).a=tmp;ind=ind+1;</p> 
<p>           kk=0;tmp=[];dx=0;</p> 
<p>       end</p> 
<p>   end</p> 
<p>end</p> 
<p>for i=1:length(cc)</p> 
<p>   figure(20);clf;</p> 
<p>   for j=1:length(cc(i).a)</p> 
<p>       subplot(1,length(cc(i).a),j);</p> 
<p>       imshow(image{cc(i).a(j)});</p> 
<p>   end</p> 
<p>   pause;</p> 
<p>end</p> 
<p> </p> 
<p>%第三问英文拼接主代码   文件名  Question3_English.m</p> 
<p>clc,clear;</p> 
<p>% 碎片匹配连接</p> 
<p>for n=1:209</p> 
<p>   fnamea=[num2str(n-1,'%03d') 'a.bmp'];</p> 
<p>   fnameb=[num2str(n-1,'%03d') 'b.bmp'];</p> 
<p>   image5{n}.a=imread(['.\附件5\' fnamea]);</p> 
<p>   image5{n}.b=imread(['.\附件5\' fnameb]);</p> 
<p>   image5a{2*n-1}=[image5{n}.a;fliplr(image5{n}.b)];%碎片a、b组合连接</p> 
<p>   image5a{2*n} =[image5{n}.b;fliplr(image5{n}.a)];  </p> 
<p>end</p> 
<p>figure(1);clf;</p> 
<p>subplot(2,1,1);imshow(image5{1}.a);</p> 
<p>subplot(2,1,2);imshow(image5{1}.b);</p> 
<p>figure(2);clf;</p> 
<p>subplot(1,2,1);imshow(image5a{1});title('ab');% 显示组合效果</p> 
<p>subplot(1,2,2);imshow(image5a{2});title('ba');</p> 
<p>save image5.mat;</p> 
<p>%load image5</p> 
<p>n=209;</p> 
<p>for k=1:2*n</p> 
<p>   bz(:,k)=image5a{1,k}(:,1);</p> 
<p>   br(:,k)=image5a{1,k}(:,72);</p> 
<p>end</p> 
<p>first=zeros(1,22);</p> 
<p>last=zeros(1,22);</p> 
<p>flag=zeros(2*n,1);</p> 
<p>for i=1:2*n</p> 
<p>   im=image5a{i};</p> 
<p>   sim=sum(im,1);</p> 
<p>   if sum(sim(1:5))==360*255*5</p> 
<p>       flag(i)=1;  % 标记行首</p> 
<p>    end</p> 
<p>   if sum(sim(72-4:72))==360*255*5</p> 
<p>       flag(i)=2; % 标记行尾</p> 
<p>   end</p> 
<p>end</p> 
<p>first=find(flag==1);</p> 
<p>last=find(flag==2);</p> 
<p>ind=1;</p> 
<p>flg=zeros(2*n,1); % 判断是否被用过</p> 
<p>for hh=1:length(first)</p> 
<p>   tmp=[];</p> 
<p>   k=first(hh);</p> 
<p>   tmp=[tmp k];</p> 
<p>   flg(k)=1;</p> 
<p>   ry=1;% 另起一行的标志</p> 
<p>   while ry == 1</p> 
<p>       maxsum=0;</p> 
<p>       for i=1:2*n</p> 
<p>           sum1=0;</p> 
<p>           if( (flag(i)~= 1) &amp;&amp; (flg(i)==0) )</p> 
<p>                co=corrcoef(double(bz(:,i)),double(br(:,k)));</p> 
<p>                 sum1=abs(co(1,2));</p> 
<p>                if(maxsum&lt;sum1)</p> 
<p>                    maxsum=sum1;</p> 
<p>                    sign=i;</p> 
<p>                end</p> 
<p>           end</p> 
<p>       end</p> 
<p>       if(k ~= sign) % 找到了</p> 
<p>           tmp=[tmp sign]</p> 
<p>           k=sign; % 现在图片</p> 
<p>           flg(k)=1;</p> 
<p>           ry=1;</p> 
<p>       else</p> 
<p>           cc(ind).a=tmp; % 没找到</p> 
<p>           ind=ind+1;</p> 
<p>           ry=0;</p> 
<p>       end</p> 
<p>   end</p> 
<p>end</p> 
<p>save cc.mat cc</p> 
<p>% for i=1:length(cc)</p> 
<p>%    figure(i);clf;</p> 
<p>%    for j=1:length(cc(i).a)       </p> 
<p>%        leibie(i,j)=cc(i).a(j);</p> 
<p>%        subplot(1,length(cc(i).a),j);</p> 
<p>%        imshow(image5a{cc(i).a(j)});</p> 
<p>%    end</p> 
<p>% end</p> 
<p> </p> 
<p>%第三问英文拼接图片显示代码   文件名  Question3show.m</p> 
<p>% 附件5碎片拼接后，每一行的显示</p> 
<p>load image5.mat;</p> 
<p>load cc.mat;</p> 
<p>close all;</p> 
<p>for i=1:length(cc)</p> 
<p>   figure(i);clf;</p> 
<p>   for j=1:length(cc(i).a)       </p> 
<p>       leibie(i,j)=cc(i).a(j);</p> 
<p>       subplot(1,length(cc(i).a),j);</p> 
<p>       imshow(image5a{cc(i).a(j)});</p> 
<p>   end</p> 
<p>end</p> 
<p><br> 附件二：实验结果</p> 
<p>    附件1结果：</p> 
<p> </p> 
<p>附件2结果：</p> 
<p>  </p> 
<p>附件3结果：</p> 
<p> </p> 
<p>附件4结果：</p> 
<p> </p> 
<p>附件5结果：</p> 
<p>正面：</p> 
<p> </p> 
<p> 反面：</p> 
<p><br> --------------------- <br> 作者：陌上西风听雨 <br> 来源：CSDN <br> 原文：https://blog.csdn.net/z1143709608/article/details/60139479 <br> 版权声明：本文为博主原创文章，转载请附上博文链接！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35685f7df04ff932b5e644a1b3104d0e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">详述解决jupyter notebook打开浏览器空白</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2d62876a57a76fc12fcb55c52bb363aa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">unix/linux 文件系统结构浅析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>