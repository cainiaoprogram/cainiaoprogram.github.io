<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux入门攻坚——12、Linux网络属性配置相关知识2 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux入门攻坚——12、Linux网络属性配置相关知识2" />
<meta property="og:description" content="CentOS 7网络属性配置：
传统命名机制：以太网eth[0,1,2,...]，wlan[0,1,2...]
可预测功能的命名机制：
udev支持多种不同的命名方案：
Firmware ，拓扑结构
在对待设备文件这块，Linux改变了几次策略。早期，设备文件仅仅是一些带有适当的属性集的普通文件，它由mknod命令创建，文件存放在/dev目录下。后来，采用了devfs,一个基于内核的动态设备文件系统，他首次出现在2.3.46 内核中。devfs创建的设备文件是动态的。但是devfs有一些严重的限制，从 2.6.13版本后移走了。目前取代他的便是udev－－一个用户空间程序。
在工作中多次碰到这样的要求：linux系统中原来有一块SCSI硬盘，系统分配的设备文件是/dev/sda。现在新增加了一个外置的磁盘阵列，通过SCSI卡连接。但接上这个磁盘阵列后，/dev/sda变成了磁盘阵列的硬盘了，原来内置的SCSI硬盘变成了 /dev/sdb，现在希望将设备文件固定下来。过去，这个比较麻烦，因为/dev/sda等文件都是linux内核自动分配的。很难固定下来，除非你更改加载SCSI卡驱动程序的顺序，让内置硬盘连接的SCSI卡比外接磁盘阵列连接的SCSI卡的驱动模块先加载到内核，这样就能保证/dev/sda总是指向内置的硬盘。但这种解决方法毕竟不太完美，而且对于其他的即插即用设备，如USB设备等都不适用。
udev是一种工具，它能够根据系统中的硬件设备的状态动态更新设备文件，包括设备文件的创建，删除等。设备文件通常放在/dev目录下。使用udev后，在/dev目录下就只包含系统中真正存在的设备。udev能够实现所有devfs实现的功能。但udev运行在用户模式中，而devfs运行在内核中。据称：devfs具有一些不太容易解决的先天缺陷。
udev的工作过程：
1. 当内核检测到在系统中出现了新设备后，内核会在sysfs文件系统中为该新设备生成一项新的记录，一般sysfs文件系统会被 mount到 /sys目录中。新记录是以一个或多个文件或目录的方式来表示。每个文件都包含有特定的信息。
2. udev在系统中是以守护进程的方式udevd在运行，它通过某种途径，检测到新设备的出现，通过查找设备对应的sysfs中的记录得到设备的一些信息。
3. udev 会根据/etc/udev/udev.conf文件中的udev_rules指定的目录，逐个检查该目录下的文件，这个目录下的文件都是针对某类或某个设备应该施行什么措施的规则文件。udev读取文件是按照文件名的ASCII字母顺序来读取的，如果udev一旦找到了与新加入的设备匹配的规则，udev 就会根据规则定义的措施对新设备进行配置。同时不再读后续的规则文件。
（1）网卡命名机制
systemd对网络设备的命名方式：
1）如果Firmware或BIOS为主板上集成的设备提供的索引信息可用，且可预测则根据此索引进行命名，例如：eno1；
2）如果Firmware或BIOS为PCI-E扩展槽所提供的索引信息可用，且可预测，则根据此索引进行命名，例如：ens1；
3）如果硬件接口的物理位置信息可用，则根据此信息进行命名，例如enp2s0；
4）如果用户显示启动，也可根据MAC地址进行命名，enx2387aadc56；
5）上述均不可用，则使用传统命名机制；
上述命名机制中，有的需要biosdevname程序的参与；
（2）名称组成格式
en：ethernet
wl：wlan，无线局域网设备
ww：wwan，无线广域网设备
名称类型：
o&lt;index&gt;：集成设备的设备索引号；
s&lt;slot&gt;：扩展槽的索引号，支持虚拟设备
x&lt;MAC&gt;：基于MAC地址的命名；
p&lt;bus&gt;s&lt;slot&gt;：enp2s1
网卡设备的命名过程：
第一步：
udev，辅助工具程序/lib/udev/rename_device,根据 /usr/lib/udev/rules.d/60-net.rules的指示，查找/etc/sysconfig/network-scripts/下的ifcfg-文件，如果HWADDR相同，将其中的DEVICE值作为网卡的名字。
第二步：
biosdevname会根据/usr/lib/udev/rules.d/71-biosdevname.rules所定义的规则进行命名
第三步：
通过检测网络接口设备，根据/usr/lib/udev/rules.d/75-net-description.rules
ID_NET_NAME_ONBOARD，ID_NET_NAME_SLOT，ID_NET_NAME_PATH
对于CentOS6，是在/lib/udev/rules.d/目录下。
回归传统命名方式：
1）编辑/etc/default/grub配置文件
GRUB_CMDLINE_LINUX=&#34;net.ifnames=0 rhgb quiet&#34;
2）为grub2生成其配置文件
grub2-mkconfig -o /etc/grub2.cfg
3）重启系统
地址配置工具：nmcli
0.8.1版本：nmcli [ OPTIONS ] OBJECT { COMMAND | help }" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0574ebd8d87a452f1843cb434d5f341a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T16:06:49+08:00" />
<meta property="article:modified_time" content="2024-01-09T16:06:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux入门攻坚——12、Linux网络属性配置相关知识2</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>CentOS 7网络属性配置</strong>：</p> 
<p>传统命名机制：以太网eth[0,1,2,...]，wlan[0,1,2...]<br> 可预测功能的命名机制：<br>     udev支持多种不同的命名方案：<br>         Firmware ，拓扑结构</p> 
<p>    在对待设备文件这块，Linux改变了几次策略。早期，设备文件仅仅是一些带有适当的属性集的普通文件，它由mknod命令创建，文件存放在/dev目录下。后来，采用了devfs,一个基于内核的动态设备文件系统，他首次出现在2.3.46 内核中。devfs创建的设备文件是动态的。但是devfs有一些严重的限制，从 2.6.13版本后移走了。目前取代他的便是udev－－一个用户空间程序。<br> 在工作中多次碰到这样的要求：linux系统中原来有一块SCSI硬盘，系统分配的设备文件是/dev/sda。现在新增加了一个外置的磁盘阵列，通过SCSI卡连接。但接上这个磁盘阵列后，/dev/sda变成了磁盘阵列的硬盘了，原来内置的SCSI硬盘变成了 /dev/sdb，现在希望将设备文件固定下来。过去，这个比较麻烦，因为/dev/sda等文件都是linux内核自动分配的。很难固定下来，除非你更改加载SCSI卡驱动程序的顺序，让内置硬盘连接的SCSI卡比外接磁盘阵列连接的SCSI卡的驱动模块先加载到内核，这样就能保证/dev/sda总是指向内置的硬盘。但这种解决方法毕竟不太完美，而且对于其他的即插即用设备，如USB设备等都不适用。<br> udev是一种工具，它能够根据系统中的硬件设备的状态动态更新设备文件，包括设备文件的创建，删除等。设备文件通常放在/dev目录下。使用udev后，在/dev目录下就只包含系统中真正存在的设备。udev能够实现所有devfs实现的功能。但udev运行在用户模式中，而devfs运行在内核中。据称：devfs具有一些不太容易解决的先天缺陷。</p> 
<p>udev的工作过程：<br> 1. 当内核检测到在系统中出现了新设备后，内核会在sysfs文件系统中为该新设备生成一项新的记录，一般sysfs文件系统会被 mount到 /sys目录中。新记录是以一个或多个文件或目录的方式来表示。每个文件都包含有特定的信息。<br>  2. udev在系统中是以守护进程的方式udevd在运行，它通过某种途径，检测到新设备的出现，通过查找设备对应的sysfs中的记录得到设备的一些信息。<br>  3. udev 会根据/etc/udev/udev.conf文件中的udev_rules指定的目录，逐个检查该目录下的文件，这个目录下的文件都是针对某类或某个设备应该施行什么措施的规则文件。udev读取文件是按照文件名的ASCII字母顺序来读取的，如果udev一旦找到了与新加入的设备匹配的规则，udev 就会根据规则定义的措施对新设备进行配置。同时不再读后续的规则文件。</p> 
<p>    （1）网卡命名机制<br>         systemd对网络设备的命名方式：<br>             1）如果Firmware或BIOS为主板上集成的设备提供的索引信息可用，且可预测则根据此索引进行命名，例如：eno1；<br>             2）如果Firmware或BIOS为PCI-E扩展槽所提供的索引信息可用，且可预测，则根据此索引进行命名，例如：ens1；<br>             3）如果硬件接口的物理位置信息可用，则根据此信息进行命名，例如enp2s0；<br>             4）如果用户显示启动，也可根据MAC地址进行命名，enx2387aadc56；<br>             5）上述均不可用，则使用传统命名机制；</p> 
<p>        上述命名机制中，有的需要biosdevname程序的参与；</p> 
<p>    （2）名称组成格式<br>             en：ethernet<br>             wl：wlan，无线局域网设备<br>             ww：wwan，无线广域网设备<br>         名称类型：<br>             o&lt;index&gt;：集成设备的设备索引号；<br>             s&lt;slot&gt;：扩展槽的索引号，支持虚拟设备<br>             x&lt;MAC&gt;：基于MAC地址的命名；<br>             p&lt;bus&gt;s&lt;slot&gt;：enp2s1</p> 
<p>    网卡设备的命名过程：<br>         第一步：<br>             udev，辅助工具程序/lib/udev/rename_device,根据 /usr/lib/udev/rules.d/60-net.rules的指示，查找/etc/sysconfig/network-scripts/下的ifcfg-文件，如果HWADDR相同，将其中的DEVICE值作为网卡的名字。<br><img alt="" height="591" src="https://images2.imgbox.com/30/d0/EqzQl3RC_o.png" width="764"><br><img alt="" height="81" src="https://images2.imgbox.com/b4/b4/3WpsU4pc_o.png" width="844"><br>         第二步：<br>             biosdevname会根据/usr/lib/udev/rules.d/71-biosdevname.rules所定义的规则进行命名<br><img alt="" height="62" src="https://images2.imgbox.com/cc/94/rdkAy3w7_o.png" width="426"><br><img alt="" height="547" src="https://images2.imgbox.com/d9/19/PVhfSAuj_o.png" width="839"><br>         第三步：<br>             通过检测网络接口设备，根据/usr/lib/udev/rules.d/75-net-description.rules<br>             ID_NET_NAME_ONBOARD，ID_NET_NAME_SLOT，ID_NET_NAME_PATH<br><img alt="" height="303" src="https://images2.imgbox.com/74/ca/QHyJQik8_o.png" width="839"></p> 
<p>对于CentOS6，是在/lib/udev/rules.d/目录下。</p> 
<p>    回归传统命名方式：<br>         1）编辑/etc/default/grub配置文件<br>             GRUB_CMDLINE_LINUX="net.ifnames=0 rhgb quiet"<br><img alt="" height="187" src="https://images2.imgbox.com/80/5e/opoEAwA3_o.png" width="838"><br>         2）为grub2生成其配置文件<br>             grub2-mkconfig -o /etc/grub2.cfg<br>         3）重启系统</p> 
<p><strong>地址配置工具</strong>：nmcli</p> 
<p>0.8.1版本：<span style="color:#956fe7;">nmcli  [ OPTIONS ] OBJECT { COMMAND | help }</span><br><img alt="" height="253" src="https://images2.imgbox.com/67/05/P4gjIQvT_o.png" width="838"><br> 1.18.8版本：<br><span style="color:#956fe7;">nmcli [OPTIONS...] {help | general | networking | radio | connection | device |<br>              agent | monitor} [COMMAND] [ARGUMENTS...]</span></p> 
<pre><code>[root@localhost rules.d]# nmcli help
Usage: nmcli [OPTIONS] OBJECT { COMMAND | help }

OPTIONS
  -a, --ask                                ask for missing parameters
  -c, --colors auto|yes|no                 whether to use colors in output
  -e, --escape yes|no                      escape columns separators in values
  -f, --fields &lt;field,...&gt;|all|common      specify fields to output
  -g, --get-values &lt;field,...&gt;|all|common  shortcut for -m tabular -t -f
  -h, --help                               print this help
  -m, --mode tabular|multiline             output mode
  -o, --overview                           overview mode
  -p, --pretty                             pretty output
  -s, --show-secrets                       allow displaying passwords
  -t, --terse                              terse output
  -v, --version                            show program version
  -w, --wait &lt;seconds&gt;                     set timeout waiting for finishing operations

OBJECT
  g[eneral]       NetworkManager's general status and operations
  n[etworking]    overall networking control
  r[adio]         NetworkManager radio switches
  c[onnection]    NetworkManager's connections
  d[evice]        devices managed by NetworkManager
  a[gent]         NetworkManager secret agent or polkit agent
  m[onitor]       monitor NetworkManager changes
</code></pre> 
<p><span style="color:#956fe7;">nmcli general {status | hostname | permissions | logging} [ARGUMENTS...]</span><br><img alt="" height="136" src="https://images2.imgbox.com/5d/98/hr8x2rEf_o.png" width="608"><br><br><span style="color:#956fe7;">nmcli networking {on | off | connectivity} [ARGUMENTS...]</span><br><span style="color:#956fe7;">nmcli connection {show | up | down | modify | add | edit | clone | delete |<br>                         monitor | reload | load | import | export} [ARGUMENTS...]</span><br><img alt="" height="96" src="https://images2.imgbox.com/5f/48/TkKZADZ1_o.png" width="613"><br>      <span style="color:#956fe7;">modify [--temporary] [id | uuid | path] &lt;ID&gt; ([+|-]&lt;setting&gt;.&lt;property&gt; &lt;value&gt;)+</span><br><img alt="" height="866" src="https://images2.imgbox.com/cc/88/AdtyrChr_o.png" width="843"><br><img alt="" height="342" src="https://images2.imgbox.com/1f/ee/mNHLhGDm_o.png" width="825"><br> setting.property:<br>     ipv4.address<br>     ipv4.gateway<br>     ipv4.dns<br>     ipv4.method<br><span style="color:#956fe7;">nmcli c modify ens33 -ipv4.address 192.168.138.139/24</span>      删除IP<br><img alt="" height="395" src="https://images2.imgbox.com/ab/fd/COc9inSH_o.png" width="817"><br> 添加网关：[root@localhost rules.d]#<span style="color:#956fe7;"> nmcli c modify ens33 ipv4.gateway 192.168.138.2</span><br> 错误：修改连接 "ens33" 失败：ipv4.gateway: 如果没有配置地址，网关会无法设置</p> 
<pre><code>[root@localhost rules.d]# cat /etc/sysconfig/network-scripts/ifcfg-ens33
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=4c3624ae-a8b2-4dbc-8aec-5e475bc122c8
DEVICE=ens33
ONBOOT=yes
PEERDNS=no
PEERROUTES=no
[root@localhost rules.d]# cat /etc/sysconfig/network-scripts/ifcfg-ens33
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=4c3624ae-a8b2-4dbc-8aec-5e475bc122c8
DEVICE=ens33
ONBOOT=yes
PEERDNS=no
PEERROUTES=no
IPADDR=192.168.138.139
PREFIX=24
GATEWAY=192.168.138.2
[root@localhost rules.d]# 
</code></pre> 
<p>出现错误，IP地址配的是dhcp，查看/etc/sysconfig/network-scripts/ifcfg-ens33,如上，然后增加了一个IP：192.168.138.139/24，然后再增加网关，就成功了。<br><span style="color:#956fe7;"> nmcli device {status | show | set | connect | reapply | modify | disconnect |<br>                     delete | monitor | wifi | lldp} [ARGUMENTS...]</span><br><img alt="" height="440" src="https://images2.imgbox.com/a2/24/qOoOiFjW_o.png" width="823"></p> 
<p>Linux语言环境管理命令：localectl<br><img alt="" height="490" src="https://images2.imgbox.com/ed/ee/svAGjPx6_o.png" width="649"><br><img alt="" height="95" src="https://images2.imgbox.com/c4/05/SuyZgOHj_o.png" width="360"></p> 
<p>nmtui工具：nmtui<br><img alt="" height="291" src="https://images2.imgbox.com/9c/27/gYBV5ocS_o.png" width="215"></p> 
<p>主机名称配置工具：hostname与hostnamectl命令：<br><img alt="" height="640" src="https://images2.imgbox.com/5f/50/YqjtdA8a_o.png" width="562"></p> 
<p><strong>网络客户端工具：lftp，ftp，lftpget，wget</strong></p> 
<p>安装：yum install lftp</p> 
<p><span style="color:#956fe7;">lft [-p port] [-u user [, password]] server</span></p> 
<p>在CentOS7下访问windows下的ftp服务器时，中文出现乱码，登录后进行如下设置（CentOS7的LANG=zh_CN.UTF-8）：</p> 
<p>lftp admin@192.168.138.1:/&gt; set ftp:charset gbk<br> lftp admin@192.168.138.1:/&gt; set file:charset utf8</p> 
<p><img alt="" height="146" src="https://images2.imgbox.com/72/2e/NnCFhnEm_o.png" width="842"></p> 
<p><img alt="" height="455" src="https://images2.imgbox.com/b1/65/CPVZoNFx_o.png" width="840"></p> 
<p>下载文件，使用get（下载单个文件），或mget（同时下载多个文件），mget *，下载所有文件<br><img alt="" height="98" src="https://images2.imgbox.com/d5/65/XjCpGB2V_o.png" width="738"></p> 
<p>lftpget URL</p> 
<p>ftp已落后，不建议使用了。</p> 
<p>wget ：<br>   <span style="color:#956fe7;">  wget [option]...  URL...</span><br>         -q：静默模式<br>         -c：续传<br>         -O：保存位置（另存为别的名字）<br>         --limit-rates=：指定传输速率</p> 
<p><strong>nmap，ncat，tcpdump</strong></p> 
<p><strong>nmap</strong>：“Network Mapper(网络映射器)”。是一款网络探测和安全审核的工具。目标是快速地扫描大型网络。它使用原始IP报文来发现网络上有哪些主机，主机提供什么服务(应用程序名和版本)，服务运行在什么操作系统(包括版本信息)， 它们使用什么类型的报文过滤器/防火墙，以及其它功能。<br><img alt="" height="468" src="https://images2.imgbox.com/e5/ec/Ir1IJ2Z3_o.png" width="837"><br><img alt="" height="678" src="https://images2.imgbox.com/87/d3/kWnD2wNl_o.png" width="838"></p> 
<p>用法：<span style="color:#956fe7;">nmap [Scan Type(s)] [Options] {target specification}</span><br> 其中，target Specification用于指定扫描的目标，可以是一个主机或是一个网络，主机可以使用IP或主机名等。如指定一个IP：192.168.138.137，指定一个名字，如：www.baidu.com，指定一个网络，如：192.168.138.0/24，使用IP地址，四个数字部分都可以使用范围表示：如192.168.138.1-254，代表扫描192.168.138.1到192.168.138.254，或者192.168.138-140.1-254。使用逗号是列出多个值，如192.168.138.1,3-5，代表192.168.138.1,192.168.138.3,192.168.138.4,192.168.138.5.<br> 选项：<br>     -sL：仅仅列出要扫描的目标列表<br><img alt="" height="361" src="https://images2.imgbox.com/10/00/OUmU2wyX_o.png" width="594"><br>     -sP：ping扫描，仅仅确定主机是否在线<br><img alt="" height="289" src="https://images2.imgbox.com/41/3f/2kllWX5C_o.png" width="590"><br> 从运行报表结果可以看到，只报告在线的主机及其MAC地址，没有其他信息。<br>     -p&lt;port range&gt;：扫描开放相关端口的主机<br><img alt="" height="394" src="https://images2.imgbox.com/09/a2/NBdJIqc7_o.png" width="581"><br>     -A：激烈扫描模式，会扫描很多信息，包括操作系统、端口、服务、等等。<br><img alt="" height="436" src="https://images2.imgbox.com/0e/20/6D8AAzJN_o.png" width="839"></p> 
<p>这里只是入门，nmap更详细的使用需要以后使用中再精通。<br> Usage: nmap [Scan Type(s)] [Options] {target specification}<br> TARGET SPECIFICATION:<br>   Can pass hostnames, IP addresses, networks, etc.<br>       Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0-255.0-255.1-254<br>      -iL &lt;inputfilename&gt;: Input from list of hosts/networks<br>       -iR &lt;num hosts&gt;: Choose random targets<br>       --exclude &lt;host1[,host2][,host3],...&gt;: Exclude hosts/networks<br>       --excludefile &lt;exclude_file&gt;: Exclude list from file<br> HOST DISCOVERY:<br>       -sL: List Scan - simply list targets to scan<br>       -sP: Ping Scan - go no further than determining if host is online<br>       -P0: Treat all hosts as online -- skip host discovery<br>       -PS/PA/PU [portlist]: TCP SYN/ACK or UDP discovery probes to given ports<br>       -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes<br>       -n/-R: Never do DNS resolution/Always resolve [default: sometimes resolve]<br> SCAN TECHNIQUES:<br>       -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans<br>       -sN/sF/sX: TCP Null, FIN, and Xmas scans<br>       --scanflags &lt;flags&gt;: Customize TCP scan flags<br>       -sI &lt;zombie host[:probeport]&gt;: Idlescan<br>       -sO: IP protocol scan<br>       -b &lt;ftp relay host&gt;: FTP bounce scan<br> PORT SPECIFICATION AND SCAN ORDER:<br>       -p &lt;port ranges&gt;: Only scan specified ports<br>         Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080<br>       -F: Fast - Scan only the ports listed in the nmap-services file)<br>       -r: Scan ports sequentially - don't randomize<br> SERVICE/VERSION DETECTION:<br>       -sV: Probe open ports to determine service/version info<br>       --version-light: Limit to most likely probes for faster identification<br>       --version-all: Try every single probe for version detection<br>       --version-trace: Show detailed version scan activity (for debugging)<br> OS DETECTION:<br>       -O: Enable OS detection<br>       --osscan-limit: Limit OS detection to promising targets<br>       --osscan-guess: Guess OS more aggressively<br> TIMING AND PERFORMANCE:<br>       -T[0-6]: Set timing template (higher is faster)<br>       --min-hostgroup/max-hostgroup &lt;size&gt;: Parallel host scan group sizes<br>       --min-parallelism/max-parallelism &lt;numprobes&gt;: Probe parallelization<br>       --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout &lt;msec&gt;: Specifies<br>       probe round trip time.<br>       --host-timeout &lt;msec&gt;: Give up on target after this long<br>       --scan-delay/--max-scan-delay &lt;msec&gt;: Adjust delay between probes<br> FIREWALL/IDS EVASION AND SPOOFING:<br>       -f; --mtu &lt;val&gt;: fragment packets (optionally w/given MTU)<br>       -D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys<br>       -S &lt;IP_Address&gt;: Spoof source address<br>       -e &lt;iface&gt;: Use specified interface<br>       -g/--source-port &lt;portnum&gt;: Use given port number<br>       --data-length &lt;num&gt;: Append random data to sent packets<br>       --ttl &lt;val&gt;: Set IP time-to-live field<br>       --spoof-mac &lt;mac address, prefix, or vendor name&gt;: Spoof your MAC address<br> OUTPUT:<br>   -oN/-oX/-oS/-oG &lt;file&gt;: Output scan results in normal, XML, s|&lt;rIpt kIddi3,<br>      and Grepable format, respectively, to the given filename.<br>       -oA &lt;basename&gt;: Output in the three major formats at once<br>       -v: Increase verbosity level (use twice for more effect)<br>       -d[level]: Set or increase debugging level (Up to 9 is meaningful)<br>       --packet-trace: Show all packets sent and received<br>       --iflist: Print host interfaces and routes (for debugging)<br>       --append-output: Append to rather than clobber specified output files<br>       --resume &lt;filename&gt;: Resume an aborted scan<br>       --stylesheet &lt;path/URL&gt;: XSL stylesheet to transform XML output to HTML<br>       --no-stylesheet: Prevent Nmap from associating XSL stylesheet w/XML output<br> MISC:<br>       -6: Enable IPv6 scanning<br>       -A: Enables OS detection and Version detection<br>       --datadir &lt;dirname&gt;: Specify custom Nmap data file location<br>       --send-eth/--send-ip: Send packets using raw ethernet frames or IP packets<br>       --privileged: Assume that the user is fully privileged<br>       -V: Print version number<br>       -h: Print this help summary page.<br> EXAMPLES:<br>       nmap -v -A scanme.nmap.org<br>       nmap -v -sP 192.168.0.0/16 10.0.0.0/8<br>       nmap -v -iR 10000 -P0 -p 80<br><strong>ncat</strong>：ncat即Netcat，用于从TCP/UDP连接中读取或发送网络数据，连接和重定向套接字<br> 有如下作用：<br>     端口侦听，ncat 可以作为 server 以 TCP 或 UDP 方式侦听指定端口；<br>     端口扫描，ncat 可以作为 client 发起 TCP 或 UDP 请求；<br>     机器之间传输文件；<br>     机器之间网络测速。<br> 命令格式：<span style="color:#956fe7;">ncat [OPTIONS...] [hostname] [port]</span><br> 选项说明：</p> 
<table align="left" border="1" cellpadding="0" cellspacing="0" style="width:680px;"><tbody><tr><td>-4/6<br>     强制只使用 IPv4/IPv6 地址。<br> -d, --delay &lt;time&gt;<br>     读/写之间等待时间。<br> -h, --help<br>     打印出帮助信息。<br> -k, --keep-open<br>     在当前连接完成后继续侦听另一个连接。注意如果不使用 -l 选项，则使用此选项是错误的。<br> -l, --listen<br>     指定应该侦听传入的连接，而不是启动到远程主机的连接。将此选项与 -p、-s 或 -z 选项结合使用是错误的。此外，使用 -w 选项指定的超时将被忽略。<br> -n, --nodns<br>     不要在任何指定的地址、主机名或端口上执行任何 DNS 或服务查找。<br> -t, --telnet<br>     使 nc 发送 RFC 854 DON'T 和 WON'T 响应 RFC 854 的 DO 和 WILL 请求。这使得使用 nc 编写 telnet 会话脚本成为可能<br> -U, --unixsock<br>     指定使用 Unix 域套接字。<br> -u, --udp<br>     使用 UDP 代替默认选项 TCP。<br> -v, --verbose<br>     显示命令执行过程。<br> -z<br>     表示 zero，只扫描侦听守护进程，而不向它们发送任何数据。此选项与 -l 选项结合使用是错误的<br> -C, --crlf<br>     发送 CRLF 作为换行符。<br> -i, --idle-timeout &lt;time&gt;<br>     空闲读/写超时时间。<br> -p,  --source-port &lt;port&gt;<br>     指定源端口，但须受特权限制和可用性限制。将此选项与 -l 选项结合使用是错误的。<br> -s, --source &lt;addr&gt;<br>     设置本地主机送出数据包的 IP 地址。注意将此选项与 -l 选项结合使用是错误的。<br> -w, --wait &lt;time&gt;<br>     如果连接和 stdin 空闲超过指定秒数，则连接将被关闭。-w 标志对 -l 选项没有影响。缺省不超时。<br> -o, --output &lt;filename&gt;<br>     将会话数据转储到文件。<br> -x, --hex-dump &lt;filename&gt;<br>     将会话数据作为十六进制转储到文件。<br> --version<br>     显示版本信息。</td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>监听本地端口：使用-l选项<br><span style="color:#956fe7;">ncat -vl 8888 </span>    <br><img alt="" height="145" src="https://images2.imgbox.com/22/b4/2qDSNy9C_o.png" width="432"><br><img alt="" height="111" src="https://images2.imgbox.com/49/83/Caif5wvR_o.png" width="462"></p> 
<p>在192.168.138.137的8888端口启动监听，在132机器上连接此端口。<br> 双方可以通话了，类似聊天功能。<br> 文件传输：把 A 机器上的一个文本文件发送到 B 机器上，需注意操作次序，receiver 先侦听端口，sender 向 receiver 所在机器的该端口发送数据。<br><img alt="" height="139" src="https://images2.imgbox.com/ae/11/wpltJE7h_o.png" width="446"><br><img alt="" height="116" src="https://images2.imgbox.com/68/42/c3F1zL39_o.png" width="585"></p> 
<p>检查SSH版本信息：<br><img alt="" height="79" src="https://images2.imgbox.com/09/ee/ftvJqzkq_o.png" width="509"></p> 
<p><strong>tcpdump</strong>：一个运行在命令行下的抓包工具。<br> 语法：<br> tcpdump [ -AdDefIJKlLnNOpqRStuUvxX ] [ -B buffer_size ] [ -c count ]<br>                [ -C file_size ] [ -G rotate_seconds ] [ -F file ]<br>                [ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ]<br>                [ -P in|out|inout ]<br>                [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]<br>                [ -W filecount ]<br>                [ -E spi@ipaddr algo:secret,...  ]<br>                [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ]<br>                [ expression ]</p> 
<table align="left" border="1" cellpadding="1" cellspacing="1" style="width:670px;"><tbody><tr><td> <p>-a 　将网络地址和广播地址转变成名字<br> -d 　将匹配信息包的代码以人们能够理解的汇编格式给出<br> -dd  将匹配信息包的代码以c语言程序段的格式给出<br> -ddd 将匹配信息包的代码以十进制的形式给出<br> -D   显示所有可用网络接口的列表<br> -e 　在输出行打印出数据链路层的头部信息<br> -f 　将外部的Internet地址以数字的形式打印出来<br> -l 　使标准输出变为缓冲行形式<br> -L   列出指定网络接口所支持的数据链路层的类型后退出<br> -n 　不把网络地址转换成名字，即不做反向域名解析<br> -q   简洁地打印输出。即打印很少的协议相关信息, 从而输出行都比较简短<br> -t   在每行的输出中不输出时间<br> -tt  在每行的输出中会输出时间戳<br> -ttt 输出每两行打印的时间间隔(以毫秒为单位)<br> -tttt 在每行打印的时间戳之前添加日期的打印（此种选项，输出的时间最直观）</p> <p>-v   产生详细的输出. 比如包的TTL，id标识，数据包长度，以及IP包的一些选项。同时它还会打开一些附加的包完整性检测，比如对IP或ICMP包头部的校验和。<br> -vv  产生比-v更详细的输出. 比如NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码。<br> -vvv 产生比-vv更详细的输出。比如 telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面，其相应的图形选项将会以16进制的方式打印出来<br> -c 　在收到指定的包的数目后，tcpdump就会停止<br> -F 　从指定的文件中读取表达式,忽略其它的表达式<br> -i 　指定监听的网络接口<br> -r 　从指定的文件中读取包(这些包一般通过-w选项产生)<br> -w 　直接将数据报写入文件中，并不分析和打印出来<br> -T 　将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单　网络管理协议)<br> -s   tcpdump 默认只会截取前 `96` 字节的内容，要想截取所有的报文内容，可以使用 `-s number`， `number` 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。<br> -S  seq ack 使用绝对序列号，而不是相对序列号<br> -Z  后接用户名，在抓包时会受到权限的限制。如果以root用户启动tcpdump，tcpdump将会有超级用户权限</p> </td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p><span style="color:#956fe7;">tcpdump -i ens33</span>    #捕获指定接口（网卡）的数据包<br><img alt="" height="503" src="https://images2.imgbox.com/23/fa/fbRhbvSq_o.png" width="837"><br><span style="color:#956fe7;">tcpdump -i ens33 -c 3</span>       #捕获指定个数的数据包（3个数据包）<br><span style="color:#956fe7;">tcpdump -A -i ens33 -c 3</span>    #用ASCII码格式输出捕获的数据包<br><span style="color:#956fe7;">tcpdump -XX -i ens33</span>        #用十六进制和ASCII码格式显示捕获的数据包<br><img alt="" height="592" src="https://images2.imgbox.com/55/f8/4wKPv2Au_o.png" width="838"><br><img alt="" height="379" src="https://images2.imgbox.com/18/ba/WCLYCveW_o.png" width="836"><br><span style="color:#956fe7;">tcpdump -D </span>   #显示可用的系统接口</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/7b/96/YoL3fiGk_o.png" width="494"><br><span style="color:#956fe7;">tcpdump -w mydata.pcap -i ens33 -c 10</span>      #把捕获的数据包写入到一个.pcap后缀的文件中<br><img alt="" height="131" src="https://images2.imgbox.com/8a/c5/0GCHJaWB_o.png" width="754"><br><span style="color:#956fe7;">tcpdump -r tempDump.pcap</span>    #读取捕获数据包文件的内容<br><img alt="" height="285" src="https://images2.imgbox.com/f3/49/5tq6ujnm_o.png" width="838"><br><span style="color:#956fe7;">tcpdump -n -i eth0</span>    # 单个 n 表示不解析域名，直接显示 IP<br><span style="color:#956fe7;">tcpdump -i eth0 tcp</span>    #捕获TCP类型的数据包，tcp可以换成其他，icmp如<br><img alt="" height="813" src="https://images2.imgbox.com/ff/b8/JFUvSvkA_o.png" width="839"><br><span style="color:#956fe7;">tcpdump -i eth0 port 22</span>   #捕获指定端口（这里是22）的数据包<br><img alt="" height="468" src="https://images2.imgbox.com/be/07/fZdxD8T2_o.png" width="841"><br><span style="color:#956fe7;">tcpdump -i eth0 src 源ip地址</span>   #捕获请求源是 192.169.12.101 的数据包<br><img alt="" height="291" src="https://images2.imgbox.com/e7/e2/Ffr7QsvK_o.png" width="837"><br><span style="color:#956fe7;">tcpdump -i eth0 dst 目标ip地址</span>   #捕获指定目的IP的数据包<br><span style="color:#956fe7;">tcpdump -i eth0 dst host 目标ip地址 and port 8800 -w data.pcap</span>  #抓取指定网卡，指定IP和端口的数据包 并写入到data.pcap文件中<br><img alt="" height="290" src="https://images2.imgbox.com/05/83/Bm9WTA3u_o.png" width="839"><br><span style="color:#956fe7;">tcpdump host 192.168.12.101 and 192.168.1.201 -w out &amp; </span> #后台抓取两主机之间的数据<br><span style="color:#956fe7;">tcpdump -nn</span> 单个 n 表示不解析域名，直接显示 IP；两个 n 表示不解析域名和端口。这样不仅方便查看 IP 和端口号，而且在抓取大量数据时非常高效，因为域名解析会降低抓取速度</p> 
<p>tcpdump输出解释<br> tcpdump的Flags代表了这个数据包的用途，这些标记是TCP首部的内容<br>     [S] : SYN（开始连接）<br>     [S.]: SYN同步标识，以及确认[S]的ACK<br>     [P.] : PSH（推送数据）<br>     [F.] : FIN （结束连接）<br>     [R.] : RST（重置连接）<br>     [.] : 没有 Flag （意思是除上面四种类型外的其他情况，有可能是 ACK 也有可能是 URG:紧急指针）<br>      [FP.]: 标记FIN、PUSH、ACK组合，这样做是为了提升网络效率，减少数据来回确认等</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86d4a5a628660e1f46e4754104d0803e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【CSS】CSS中的BFC，是什么？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b52575cbc8b614bdb47b6261ca2067c2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《计算机网络》 第七章 网络安全</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>