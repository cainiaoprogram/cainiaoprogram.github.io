<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>中间件系列 - Redis入门到实战(高级篇-分布式缓存) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="中间件系列 - Redis入门到实战(高级篇-分布式缓存)" />
<meta property="og:description" content="前言 学习视频： 黑马程序员Redis入门到实战教程，深度透析redis底层原理&#43;redis分布式锁&#43;企业解决方案&#43;黑马点评实战项目
中间件系列 - Redis入门到实战
本内容仅用于个人学习笔记，如有侵扰，联系删除
学习目标
Redis持久化Redis主从Redis哨兵Redis分片集群 一 分布式缓存 - 基于Redis集群解决单机Redis存在的问题
单机的Redis存在四大问题：
1.Redis持久化 Redis有两种持久化方案：
RDB持久化AOF持久化 1.1.RDB持久化 RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。
1.1.1.执行时机 RDB持久化在四种情况下会执行：
执行save命令执行bgsave命令Redis停机时触发RDB条件时 1）save命令
执行下面的命令，可以立即执行一次RDB：
save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。
2）bgsave命令
下面的命令可以异步执行RDB：
这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。
3）停机时
Redis停机时会执行一次save命令，实现RDB持久化。
4）触发RDB条件
Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：
# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &#34;&#34; 则表示禁用RDB save 900 1 save 300 10 save 60 10000 RDB的其它配置也可以在redis.conf文件中设置：
# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱 rdbcompression yes # RDB文件名称 dbfilename dump.rdb # 文件保存的路径目录 dir ./ 1.1.2.RDB原理 bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。
fork采用的是copy-on-write技术：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4b092e42625d93950f4f73039f9f3332/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-27T14:15:16+08:00" />
<meta property="article:modified_time" content="2023-12-27T14:15:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">中间件系列 - Redis入门到实战(高级篇-分布式缓存)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<ol><li> <p>学习视频： <a href="https://www.bilibili.com/video/BV1cr4y1671t/?p=97&amp;spm_id_from=pageDriver&amp;vd_source=503d91c4d0bbdd15aaedc32c35838917" rel="nofollow">黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目</a></p> </li><li> <p><a href="https://blog.csdn.net/wts563540/article/details/134771495">中间件系列 - Redis入门到实战</a></p> </li><li> <p>本内容仅用于个人学习笔记，如有侵扰，联系删除</p> </li><li> <p>学习目标</p> 
  <blockquote> 
   <ul><li>Redis持久化</li><li>Redis主从</li><li>Redis哨兵</li><li>Redis分片集群</li></ul> 
  </blockquote> </li></ol> 
<h2><a id="__10"></a>一 分布式缓存</h2> 
<p><strong>- 基于Redis集群解决单机Redis存在的问题</strong></p> 
<p><strong>单机的Redis存在四大问题：</strong></p> 
<p><img src="https://images2.imgbox.com/38/0d/zK9BlbN6_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="1Redis_17"></a>1.Redis持久化</h2> 
<p><strong>Redis有两种持久化方案：</strong></p> 
<ul><li><code>RDB持久化</code></li><li><code>AOF持久化</code></li></ul> 
<h3><a id="11RDB_22"></a>1.1.RDB持久化</h3> 
<p><code>RDB</code>全称<code>Redis Database Backup file</code>（<code>Redis</code>数据备份文件），也被叫做<code>Redis</code>数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当<code>Redis</code>实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为<code>RDB</code>文件，默认是保存在当前运行目录。</p> 
<h4><a id="111_26"></a>1.1.1.执行时机</h4> 
<p><strong>RDB持久化在四种情况下会执行：</strong></p> 
<ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul> 
<p><strong>1）save命令</strong></p> 
<p>执行下面的命令，可以立即执行一次RDB：<br> <img src="https://images2.imgbox.com/0f/86/wgw7jHBT_o.png" alt="在这里插入图片描述"><br> save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p> 
<p><strong>2）bgsave命令</strong></p> 
<p>下面的命令可以异步执行RDB：<br> <img src="https://images2.imgbox.com/ef/95/YkWP3uBy_o.png" alt="在这里插入图片描述"></p> 
<p>这个命令执行后会开启独立进程完成<code>RDB</code>，主进程可以持续处理用户请求，不受影响。</p> 
<p><strong>3）停机时</strong></p> 
<p><code>Redis</code>停机时会执行一次<code>save</code>命令，实现<code>RDB</code>持久化。</p> 
<p><strong>4）触发RDB条件</strong></p> 
<p><code>Redis</code>内部有触发<code>RDB</code>的机制，可以在<code>redis.conf</code>文件中找到，格式如下：</p> 
<pre><code class="prism language-properties"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save "" 则表示禁用RDB
save 900 1  
save 300 10  
save 60 10000 
</code></pre> 
<p><code>RDB</code>的其它配置也可以在<code>redis.conf</code>文件中设置：</p> 
<pre><code class="prism language-properties"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱
rdbcompression yes

# RDB文件名称
dbfilename dump.rdb  

# 文件保存的路径目录
dir ./ 
</code></pre> 
<h4><a id="112RDB_76"></a>1.1.2.RDB原理</h4> 
<p><code>bgsave</code>开始时会<code>fork</code>主进程得到子进程，子进程共享主进程的内存数据。完成<code>fork</code>后读取内存数据并写入 <code>RDB</code> 文件。</p> 
<p><code>fork</code>采用的是<code>copy-on-write</code>技术：</p> 
<ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul> 
<p><img src="https://images2.imgbox.com/96/a1/4sRoZMe9_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="113_86"></a>1.1.3.小结</h4> 
<p><strong><code>RDB</code>方式<code>bgsave</code>的基本流程？</strong></p> 
<ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul> 
<p><strong>RDB会在什么时候执行？save 60 1000代表什么含义？</strong></p> 
<ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul> 
<p><strong>RDB的缺点？</strong></p> 
<ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul> 
<h3><a id="12_AOF_103"></a>1.2 AOF持久化</h3> 
<h4><a id="121_AOF_104"></a>1.2.1 AOF原理</h4> 
<p>AOF全称为<code>Append Only File</code>（追加文件）。<code>Redis</code>处理的每一个写命令都会记录在<code>AOF</code>文件，可以看做是命令日志文件。<br> <img src="https://images2.imgbox.com/73/ec/JlhzObxb_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="122_AOF_108"></a>1.2.2 AOF配置</h4> 
<p><code>AOF</code>默认是关闭的，需要修改<code>redis.conf</code>配置文件来开启<code>AOF</code>：</p> 
<pre><code class="prism language-properties"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename "appendonly.aof"
</code></pre> 
<p><code>AOF</code>的命令记录的频率也可以通过<code>redis.conf</code>文件来配：</p> 
<pre><code class="prism language-properties"># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always 
# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec 
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre> 
<p>三种策略对比：<br> <img src="https://images2.imgbox.com/2e/95/qK1NLb6j_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="123_AOF_131"></a>1.2.3 AOF文件重写</h4> 
<p>因为是记录命令，<code>AOF</code>文件会比<code>RDB</code>文件大的多。而且<code>AOF</code>会记录对同一个<code>key</code>的多次写操作，但只有最后一次写操作才有意义。通过执行<code>bgrewriteaof</code>命令，可以让<code>AOF</code>文件执行重写功能，用最少的命令达到相同效果。<br> <img src="https://images2.imgbox.com/eb/b7/ci7Bw5ix_o.png" alt="在这里插入图片描述"><br> 如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p> 
<p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p> 
<p><code>Redis</code>也会在触发阈值时自动去重写<code>AOF</code>文件。阈值也可以在<code>redis.conf</code>中配置：</p> 
<pre><code class="prism language-properties"># AOF文件比上次文件 增长超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写 
auto-aof-rewrite-min-size 64mb 
</code></pre> 
<h3><a id="13_RDBAOF_147"></a>1.3 RDB与AOF对比</h3> 
<p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。<br> <img src="https://images2.imgbox.com/cd/88/3yoIsdQg_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2_Redis_151"></a>2 Redis主从</h2> 
<h3><a id="21_Redis_152"></a>2.1 Redis主从集群</h3> 
<h4><a id="211__153"></a>2.1.1 搭建主从架构</h4> 
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p> 
<p>我们搭建的主从集群结构如图：<br> <img src="https://images2.imgbox.com/9d/bd/pPIZSfe1_o.png" alt="在这里插入图片描述"><br> 共包含三个节点，一个主节点，两个从节点。</p> 
<p>这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下：</p> 
<table><thead><tr><th align="center">IP</th><th align="center">PORT</th><th align="center">角色</th></tr></thead><tbody><tr><td align="center">192.168.150.101</td><td align="center">7001</td><td align="center">master</td></tr><tr><td align="center">192.168.150.101</td><td align="center">7002</td><td align="center">slave</td></tr><tr><td align="center">192.168.150.101</td><td align="center">7003</td><td align="center">slave</td></tr></tbody></table> 
<h4><a id="212__168"></a>2.1.2 准备实例和配置</h4> 
<p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p> 
<p>1）创建目录</p> 
<p>我们创建三个文件夹，名字分别叫7001、7002、7003：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 进入/tmp目录</span>
<span class="token builtin class-name">cd</span> /tmp
<span class="token comment"># 创建目录</span>
<span class="token function">mkdir</span> <span class="token number">7001</span> <span class="token number">7002</span> <span class="token number">7003</span>
</code></pre> 
<p>如图：<br> <img src="https://images2.imgbox.com/dd/45/LpTuAMOZ_o.png" alt="在这里插入图片描述"></p> 
<p>2）恢复原始配置</p> 
<p>修改redis-6.2.4/redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。</p> 
<pre><code class="prism language-properties"># 开启RDB
# save ""
save 3600 1
save 300 100
save 60 10000

# 关闭AOF
appendonly no
</code></pre> 
<p>3）拷贝配置文件到每个实例目录</p> 
<p>然后将redis-6.2.4/redis.conf文件拷贝到三个目录中（在/tmp目录执行下列命令）：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 方式一：逐个拷贝</span>
<span class="token function">cp</span> redis-6.2.4/redis.conf <span class="token number">7001</span>
<span class="token function">cp</span> redis-6.2.4/redis.conf <span class="token number">7002</span>
<span class="token function">cp</span> redis-6.2.4/redis.conf <span class="token number">7003</span>

<span class="token comment"># 方式二：管道组合命令，一键拷贝</span>
<span class="token builtin class-name">echo</span> <span class="token number">7001</span> <span class="token number">7002</span> <span class="token number">7003</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-t</span> <span class="token parameter variable">-n</span> <span class="token number">1</span> <span class="token function">cp</span> redis-6.2.4/redis.conf
</code></pre> 
<p>4）修改每个实例的端口、工作目录</p> 
<p>修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在/tmp目录执行下列命令）：</p> 
<pre><code class="prism language-sh"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-e</span> <span class="token string">'s/6379/7001/g'</span> <span class="token parameter variable">-e</span> <span class="token string">'s/dir .\//dir \/tmp\/7001\//g'</span> <span class="token number">7001</span>/redis.conf
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-e</span> <span class="token string">'s/6379/7002/g'</span> <span class="token parameter variable">-e</span> <span class="token string">'s/dir .\//dir \/tmp\/7002\//g'</span> <span class="token number">7002</span>/redis.conf
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-e</span> <span class="token string">'s/6379/7003/g'</span> <span class="token parameter variable">-e</span> <span class="token string">'s/dir .\//dir \/tmp\/7003\//g'</span> <span class="token number">7003</span>/redis.conf
</code></pre> 
<p>5）修改每个实例的声明IP</p> 
<p>虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下：</p> 
<pre><code class="prism language-properties"># redis实例的声明 IP
replica-announce-ip 192.168.150.101
</code></pre> 
<p>每个目录都要改，我们一键完成修改（在/tmp目录执行下列命令）：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 逐一执行</span>
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'1a replica-announce-ip 192.168.150.101'</span> <span class="token number">7001</span>/redis.conf
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'1a replica-announce-ip 192.168.150.101'</span> <span class="token number">7002</span>/redis.conf
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'1a replica-announce-ip 192.168.150.101'</span> <span class="token number">7003</span>/redis.conf

<span class="token comment"># 或者一键修改</span>
<span class="token builtin class-name">printf</span> <span class="token string">'%s\n'</span> <span class="token number">7001</span> <span class="token number">7002</span> <span class="token number">7003</span> <span class="token operator">|</span> <span class="token function">xargs</span> -I<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token parameter variable">-t</span> <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'1a replica-announce-ip 192.168.150.101'</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>/redis.conf
</code></pre> 
<h4><a id="213__251"></a>2.1.3 启动</h4> 
<p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 第1个</span>
redis-server <span class="token number">7001</span>/redis.conf
<span class="token comment"># 第2个</span>
redis-server <span class="token number">7002</span>/redis.conf
<span class="token comment"># 第3个</span>
redis-server <span class="token number">7003</span>/redis.conf
</code></pre> 
<p>启动后：<br> <img src="https://images2.imgbox.com/1d/8f/RhiApn22_o.png" alt="在这里插入图片描述"><br> 如果要一键停止，可以运行下面命令：</p> 
<pre><code class="prism language-sh"><span class="token builtin class-name">printf</span> <span class="token string">'%s\n'</span> <span class="token number">7001</span> <span class="token number">7002</span> <span class="token number">7003</span> <span class="token operator">|</span> <span class="token function">xargs</span> -I<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token parameter variable">-t</span> redis-cli <span class="token parameter variable">-p</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token function">shutdown</span>
</code></pre> 
<h4><a id="214__270"></a>2.1.4 开启主从关系</h4> 
<p>现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。</p> 
<p>有临时和永久两种模式：</p> 
<ul><li> <p>修改配置文件（永久生效）</p> 
  <ul><li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul> </li><li> <p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p> <pre><code class="prism language-sh">slaveof <span class="token operator">&lt;</span>masterip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>masterport<span class="token operator">&gt;</span>
</code></pre> </li></ul> 
<p><strong><font color="red">注意</font></strong>：在5.0以后新增命令replicaof，与salveof效果一致。</p> 
<p>这里我们为了演示方便，使用方式二。</p> 
<p>通过redis-cli命令连接7002，执行下面命令：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 连接 7002</span>
redis-cli <span class="token parameter variable">-p</span> <span class="token number">7002</span>
<span class="token comment"># 执行slaveof</span>
slaveof <span class="token number">192.168</span>.150.101 <span class="token number">7001</span>
</code></pre> 
<p>通过redis-cli命令连接7003，执行下面命令：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 连接 7003</span>
redis-cli <span class="token parameter variable">-p</span> <span class="token number">7003</span>
<span class="token comment"># 执行slaveof</span>
slaveof <span class="token number">192.168</span>.150.101 <span class="token number">7001</span>
</code></pre> 
<p>然后连接 7001节点，查看集群状态：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 连接 7001</span>
redis-cli <span class="token parameter variable">-p</span> <span class="token number">7001</span>
<span class="token comment"># 查看状态</span>
info replication
</code></pre> 
<p>结果：<br> <img src="https://images2.imgbox.com/22/ab/voPsDiMU_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="215__327"></a>2.1.5 测试</h4> 
<p>执行下列操作以测试：</p> 
<ul><li> <p>利用redis-cli连接7001，执行<code>set num 123</code></p> </li><li> <p>利用redis-cli连接7002，执行<code>get num</code>，再执行<code>set num 666</code></p> </li><li> <p>利用redis-cli连接7003，执行<code>get num</code>，再执行<code>set num 888</code></p> </li></ul> 
<pre><code class="prism language-java"><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7001</span><span class="token operator">&gt;</span> set num <span class="token number">123</span>
<span class="token constant">OK</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7001</span><span class="token operator">&gt;</span> get num
<span class="token string">"123"</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7001</span><span class="token operator">&gt;</span> get num
<span class="token punctuation">[</span>root<span class="token annotation punctuation">@VM</span><span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span><span class="token number">14</span><span class="token operator">-</span>centos tmp<span class="token punctuation">]</span># redis<span class="token operator">-</span>cli <span class="token operator">-</span>p <span class="token number">7002</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7002</span><span class="token operator">&gt;</span> get num
<span class="token string">"123"</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7002</span><span class="token operator">&gt;</span> set num <span class="token number">666</span>
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token constant">READONLY</span> <span class="token class-name">You</span> can't write against a read only replica<span class="token punctuation">.</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7002</span><span class="token operator">&gt;</span>
<span class="token punctuation">[</span>root<span class="token annotation punctuation">@VM</span><span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span><span class="token number">14</span><span class="token operator">-</span>centos tmp<span class="token punctuation">]</span># redis<span class="token operator">-</span>cli <span class="token operator">-</span>p <span class="token number">7003</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7003</span><span class="token operator">&gt;</span> get num
<span class="token string">"123"</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7003</span><span class="token operator">&gt;</span> set num <span class="token number">666</span>
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token constant">READONLY</span> <span class="token class-name">You</span> can't write against a read only replica<span class="token punctuation">.</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7003</span><span class="token operator">&gt;</span>
</code></pre> 
<p>可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。</p> 
<h3><a id="22_358"></a>2.2.主从数据同步原理</h3> 
<h4><a id="221__359"></a>2.2.1 全量同步</h4> 
<p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：<br> <img src="https://images2.imgbox.com/8c/0c/WPUjegYa_o.png" alt="在这里插入图片描述"><br> 这里有一个问题，master如何得知salve是第一次来连接呢？？</p> 
<p>有几个概念，可以作为判断依据：</p> 
<ul><li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li><li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul> 
<p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p> 
<p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p> 
<p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p> 
<p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p> 
<p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p> 
<p>如图：<br> <img src="https://images2.imgbox.com/96/09/L9745eYi_o.png" alt="在这里插入图片描述"><br> 完整流程描述：</p> 
<ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，拒绝增量同步</li><li>master将完整内存数据生成RDB，发送RDB到slave</li><li>slave清空本地数据，加载master的RDB</li><li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li><li>slave执行接收到的命令，保持与master之间的同步</li></ul> 
<h4><a id="222_390"></a>2.2.2.增量同步</h4> 
<p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p> 
<p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：<br> <img src="https://images2.imgbox.com/de/eb/yBqqMKEy_o.png" alt="在这里插入图片描述"><br> 那么master怎么知道slave与自己的数据差异在哪里呢?</p> 
<h4><a id="223_repl_backlog_397"></a>2.2.3 repl_backlog原理</h4> 
<p>master怎么知道slave与自己的数据差异在哪里呢?</p> 
<p>这就要说到全量同步时的repl_baklog文件了。</p> 
<p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p> 
<p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：<br> <img src="https://images2.imgbox.com/f3/81/mF9eC6DA_o.png" alt="在这里插入图片描述"></p> 
<p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p> 
<p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：<br> <img src="https://images2.imgbox.com/70/e0/BuZyKPNf_o.png" alt="在这里插入图片描述"></p> 
<p>直到数组被填满：<br> <img src="https://images2.imgbox.com/eb/00/BKDn3d5Q_o.png" alt="在这里插入图片描述"></p> 
<p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p> 
<p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：<br> <img src="https://images2.imgbox.com/8b/f5/dzfCD58c_o.png" alt="在这里插入图片描述"></p> 
<p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：<br> <img src="https://images2.imgbox.com/ec/cb/IF4zkZI4_o.png" alt="在这里插入图片描述"></p> 
<p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。<br> <img src="https://images2.imgbox.com/07/c4/p3PNVRcr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23__426"></a>2.3 主从同步优化</h3> 
<p>主从同步可以保证主从数据的一致性，非常重要。</p> 
<p><strong>可以从以下几个方面来优化Redis主从就集群：</strong></p> 
<ul><li>在<code>master</code>中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li><li><code>Redis</code>单节点上的内存占用不要太大，减少<code>RDB</code>导致的过多磁盘IO</li><li>适当提高<code>repl_baklog</code>的大小，发现<code>slave</code>宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个<code>master</code>上的<code>slave</code>节点数量，如果实在是太多<code>slave</code>，则可以采用主-从-从链式结构，减少<code>master</code>压力</li></ul> 
<p>主从从架构图：<br> <img src="https://images2.imgbox.com/64/f4/dDbVKCiy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24_439"></a>2.4.小结</h3> 
<p><strong>简述全量同步和增量同步区别？</strong></p> 
<ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul> 
<p><strong>什么时候执行全量同步？</strong></p> 
<ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul> 
<p><strong>什么时候执行增量同步？</strong></p> 
<ul><li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li></ul> 
<h2><a id="3_Redis_455"></a>3 Redis哨兵</h2> 
<p><code>Redis</code>提供了哨兵（<code>Sentinel</code>）机制来实现主从集群的自动故障恢复。</p> 
<h3><a id="31_458"></a>3.1.哨兵原理</h3> 
<h4><a id="311_459"></a>3.1.1.集群结构和作用</h4> 
<p>哨兵的结构如图：<br> <img src="https://images2.imgbox.com/eb/e4/MfNIy94d_o.png" alt="在这里插入图片描述"><br> <strong>哨兵的作用如下：</strong></p> 
<ul><li><strong>监控</strong>：<code>Sentinel</code> 会不断检查您的<code>master</code>和<code>slave</code>是否按预期工作</li><li><strong>自动故障恢复</strong>：如果<code>master</code>故障，<code>Sentinel</code>会将一个<code>slave</code>提升为<code>master</code>。当故障实例恢复后也以新的<code>master</code>为主</li><li><strong>通知</strong>：<code>Sentinel</code>充当<code>Redis</code>客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给<code>Redis</code>的客户端</li></ul> 
<h4><a id="312_468"></a>3.1.2.集群监控原理</h4> 
<p><code>Sentinel</code>基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送<code>ping</code>命令：</p> 
<p>•<strong>主观下线</strong>：如果某<code>sentinel</code>节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p> 
<p>•<strong>客观下线</strong>：若超过指定数量（<code>quorum</code>）的<code>sentinel</code>都认为该实例主观下线，则该实例<strong>客观下线</strong>。<code>quorum</code>值最好超过<code>Sentinel</code>实例数量的一半。</p> 
<p><img src="https://images2.imgbox.com/fc/f0/QRCZCmAf_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="313__477"></a>3.1.3 集群故障恢复原理</h4> 
<p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p> 
<ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul> 
<p>当选出一个新的master后，该如何实现切换呢？</p> 
<p><strong>流程如下：</strong></p> 
<ul><li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li><li>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul> 
<p><img src="https://images2.imgbox.com/69/2e/YxgbRAJI_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="314__495"></a>3.1.4 小结</h4> 
<p><strong>Sentinel的三个作用是什么？</strong></p> 
<ul><li>监控</li><li>故障转移</li><li>通知</li></ul> 
<p><strong>Sentinel如何判断一个redis实例是否健康？</strong></p> 
<ul><li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li><li>如果大多数sentinel都认为实例主观下线，则判定服务下线</li></ul> 
<p><strong>故障转移步骤有哪些？</strong></p> 
<ul><li>首先选定一个slave作为新的master，执行slaveof no one</li><li>然后让所有节点都执行slaveof 新master</li><li>修改故障节点配置，添加slaveof 新master</li></ul> 
<h3><a id="32__513"></a>3.2 搭建哨兵集群</h3> 
<h4><a id="321__514"></a>3.2.1 集群结构</h4> 
<p>这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：<br> <img src="https://images2.imgbox.com/6b/92/ckNmsN7E_o.png" alt="在这里插入图片描述"></p> 
<p>三个sentinel实例信息如下：</p> 
<table><thead><tr><th>节点</th><th align="center">IP</th><th align="center">PORT</th></tr></thead><tbody><tr><td>s1</td><td align="center">192.168.150.101</td><td align="center">27001</td></tr><tr><td>s2</td><td align="center">192.168.150.101</td><td align="center">27002</td></tr><tr><td>s3</td><td align="center">192.168.150.101</td><td align="center">27003</td></tr></tbody></table> 
<h4><a id="322__527"></a>3.2.2 准备实例和配置</h4> 
<p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p> 
<p>我们创建三个文件夹，名字分别叫s1、s2、s3：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 进入/tmp目录</span>
<span class="token builtin class-name">cd</span> /tmp
<span class="token comment"># 创建目录</span>
<span class="token function">mkdir</span> s1 s2 s3
</code></pre> 
<p>如图：<br> <img src="https://images2.imgbox.com/e2/5b/6W81jBwp_o.png" alt="在这里插入图片描述"></p> 
<p>然后我们在<code>s1</code>目录创建一个<code>sentinel.conf</code>文件，添加下面的内容：</p> 
<pre><code class="prism language-ini">port 27001
sentinel announce-ip 192.168.150.101
sentinel monitor mymaster 192.168.150.101 7001 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 60000
dir "/tmp/s1"
</code></pre> 
<p>解读：</p> 
<ul><li><code>port 27001</code>：是当前sentinel实例的端口</li><li><code>sentinel monitor mymaster 192.168.150.101 7001 2</code>：指定主节点信息 
  <ul><li><code>mymaster</code>：主节点名称，自定义，任意写</li><li><code>192.168.150.101 7001</code>：主节点的ip和端口</li><li><code>2</code>：选举master时的quorum值</li></ul> </li></ul> 
<p>然后将s1/sentinel.conf文件拷贝到s2、s3两个目录中（在/tmp目录执行下列命令）：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 方式一：逐个拷贝</span>
<span class="token function">cp</span> s1/sentinel.conf s2
<span class="token function">cp</span> s1/sentinel.conf s3
<span class="token comment"># 方式二：管道组合命令，一键拷贝</span>
<span class="token builtin class-name">echo</span> s2 s3 <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-t</span> <span class="token parameter variable">-n</span> <span class="token number">1</span> <span class="token function">cp</span> s1/sentinel.conf
</code></pre> 
<p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p> 
<pre><code class="prism language-sh"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-e</span> <span class="token string">'s/27001/27002/g'</span> <span class="token parameter variable">-e</span> <span class="token string">'s/s1/s2/g'</span> s2/sentinel.conf
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-e</span> <span class="token string">'s/27001/27003/g'</span> <span class="token parameter variable">-e</span> <span class="token string">'s/s1/s3/g'</span> s3/sentinel.conf
</code></pre> 
<h4><a id="323__582"></a>3.2.3 启动</h4> 
<p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 第1个</span>
redis-sentinel s1/sentinel.conf
<span class="token comment"># 第2个</span>
redis-sentinel s2/sentinel.conf
<span class="token comment"># 第3个</span>
redis-sentinel s3/sentinel.conf
</code></pre> 
<p>启动后：<br> <img src="https://images2.imgbox.com/58/88/FowbyRpM_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="324__599"></a>3.2.4 测试</h4> 
<p>尝试让master节点7001宕机，查看sentinel日志：<br> <img src="https://images2.imgbox.com/86/84/MFHUEE22_o.png" alt="在这里插入图片描述"><br> 查看7003的日志：<br> <img src="https://images2.imgbox.com/f0/3b/6W8ciZKn_o.png" alt="在这里插入图片描述"><br> 查看7002的日志：<br> <img src="https://images2.imgbox.com/cb/1e/vVD5mvpo_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="33RedisTemplate_608"></a>3.3.RedisTemplate</h3> 
<p>在<code>Sentinel</code>集群监管下的<code>Redis</code>主从集群，其节点会因为自动故障转移而发生变化，<code>Redis</code>的客户端必须感知这种变化，及时更新连接信息。<code>Spring</code>的<code>RedisTemplate</code>底层利用<code>lettuce</code>实现了节点的感知和自动切换。</p> 
<p>下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。</p> 
<h4><a id="331_Demo_613"></a>3.3.1 导入Demo工程</h4> 
<p>首先，我们引入课前资料提供的Demo工程：<br> <img src="https://images2.imgbox.com/db/ea/y8k1Nefs_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="332__617"></a>3.3.2 引入依赖</h4> 
<p>在项目的pom文件中引入依赖：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h4><a id="333_Redis_627"></a>3.3.3 配置Redis地址</h4> 
<p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p> 
<pre><code class="prism language-java">spring<span class="token operator">:</span>
  redis<span class="token operator">:</span>
    sentinel<span class="token operator">:</span>
      master<span class="token operator">:</span> mymaster
      nodes<span class="token operator">:</span>
        <span class="token operator">-</span> <span class="token number">192.168</span><span class="token number">.150</span><span class="token number">.101</span><span class="token operator">:</span><span class="token number">27001</span>
        <span class="token operator">-</span> <span class="token number">192.168</span><span class="token number">.150</span><span class="token number">.101</span><span class="token operator">:</span><span class="token number">27002</span>
        <span class="token operator">-</span> <span class="token number">192.168</span><span class="token number">.150</span><span class="token number">.101</span><span class="token operator">:</span><span class="token number">27003</span>
</code></pre> 
<h4><a id="334__641"></a>3.3.4 配置读写分离</h4> 
<p>在项目的启动类中，添加一个新的bean：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">LettuceClientConfigurationBuilderCustomizer</span> <span class="token function">clientConfigurationBuilderCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> clientConfigurationBuilder <span class="token operator">-&gt;</span> clientConfigurationBuilder<span class="token punctuation">.</span><span class="token function">readFrom</span><span class="token punctuation">(</span><span class="token class-name">ReadFrom</span><span class="token punctuation">.</span><span class="token constant">REPLICA_PREFERRED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个bean中配置的就是读写策略，包括四种：</p> 
<ul><li><code>MASTER</code>：从主节点读取</li><li><code>MASTER_PREFERRED</code>：优先从master节点读取，master不可用才读取replica</li><li><code>REPLICA</code>：从slave（replica）节点读取</li><li><code>REPLICA _PREFERRED</code>：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li></ul> 
<h2><a id="4_Redis_658"></a>4 Redis分片集群</h2> 
<h3><a id="41__659"></a>4.1 搭建分片集群</h3> 
<p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p> 
<ul><li> <p>海量数据存储问题</p> </li><li> <p>高并发写的问题</p> </li></ul> 
<p>使用分片集群可以解决上述问题</p> 
<h4><a id="411__668"></a>4.1.1 集群结构</h4> 
<p>分片集群需要的节点数量较多，这里我们搭建一个最小的分片集群，包含3个master节点，每个master包含一个slave节点，结构如下：<br> <img src="https://images2.imgbox.com/f7/af/ARIdv5gG_o.png" alt="在这里插入图片描述"><br> 分片集群特征：</p> 
<ul><li> <p>集群中有多个master，每个master保存不同数据</p> </li><li> <p>每个master都可以有多个slave节点</p> </li><li> <p>master之间通过ping监测彼此健康状态</p> </li><li> <p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p> </li></ul> 
<p>这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下：</p> 
<table><thead><tr><th align="center">IP</th><th align="center">PORT</th><th align="center">角色</th></tr></thead><tbody><tr><td align="center">192.168.150.101</td><td align="center">7001</td><td align="center">master</td></tr><tr><td align="center">192.168.150.101</td><td align="center">7002</td><td align="center">master</td></tr><tr><td align="center">192.168.150.101</td><td align="center">7003</td><td align="center">master</td></tr><tr><td align="center">192.168.150.101</td><td align="center">8001</td><td align="center">slave</td></tr><tr><td align="center">192.168.150.101</td><td align="center">8002</td><td align="center">slave</td></tr><tr><td align="center">192.168.150.101</td><td align="center">8003</td><td align="center">slave</td></tr></tbody></table> 
<h4><a id="412__694"></a>4.1.2 准备实例和配置</h4> 
<p>删除之前的7001、7002、7003这几个目录，重新创建出7001、7002、7003、8001、8002、8003目录：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 进入/tmp目录</span>
<span class="token builtin class-name">cd</span> /tmp
<span class="token comment"># 删除旧的，避免配置干扰</span>
<span class="token function">rm</span> <span class="token parameter variable">-rf</span> <span class="token number">7001</span> <span class="token number">7002</span> <span class="token number">7003</span>
<span class="token comment"># 创建目录</span>
<span class="token function">mkdir</span> <span class="token number">7001</span> <span class="token number">7002</span> <span class="token number">7003</span> <span class="token number">8001</span> <span class="token number">8002</span> <span class="token number">8003</span>
</code></pre> 
<p>在/tmp下准备一个新的redis.conf文件，内容如下：</p> 
<pre><code class="prism language-ini">port 6379
# 开启集群功能
cluster-enabled yes
# 集群的配置文件名称，不需要我们创建，由redis自己维护
cluster-config-file /tmp/6379/nodes.conf
# 节点心跳失败的超时时间
cluster-node-timeout 5000
# 持久化文件存放目录
dir /tmp/6379
# 绑定地址
bind 0.0.0.0
# 让redis后台运行
daemonize yes
# 注册的实例ip
replica-announce-ip 192.168.150.101
# 保护模式
protected-mode no
# 数据库数量
databases 1
# 日志
logfile /tmp/6379/run.log
</code></pre> 
<p>将这个文件拷贝到每个目录下：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 进入/tmp目录</span>
<span class="token builtin class-name">cd</span> /tmp
<span class="token comment"># 执行拷贝</span>
<span class="token builtin class-name">echo</span> <span class="token number">7001</span> <span class="token number">7002</span> <span class="token number">7003</span> <span class="token number">8001</span> <span class="token number">8002</span> <span class="token number">8003</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-t</span> <span class="token parameter variable">-n</span> <span class="token number">1</span> <span class="token function">cp</span> redis.conf
</code></pre> 
<p>修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 进入/tmp目录</span>
<span class="token builtin class-name">cd</span> /tmp
<span class="token comment"># 修改配置文件</span>
<span class="token builtin class-name">printf</span> <span class="token string">'%s\n'</span> <span class="token number">7001</span> <span class="token number">7002</span> <span class="token number">7003</span> <span class="token number">8001</span> <span class="token number">8002</span> <span class="token number">8003</span> <span class="token operator">|</span> <span class="token function">xargs</span> -I<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token parameter variable">-t</span> <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/6379/{}/g'</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>/redis.conf
</code></pre> 
<h4><a id="413__754"></a>4.1.3 启动</h4> 
<p>因为已经配置了后台启动模式，所以可以直接启动服务：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 进入/tmp目录</span>
<span class="token builtin class-name">cd</span> /tmp
<span class="token comment"># 一键启动所有服务</span>
<span class="token builtin class-name">printf</span> <span class="token string">'%s\n'</span> <span class="token number">7001</span> <span class="token number">7002</span> <span class="token number">7003</span> <span class="token number">8001</span> <span class="token number">8002</span> <span class="token number">8003</span> <span class="token operator">|</span> <span class="token function">xargs</span> -I<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token parameter variable">-t</span> redis-server <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>/redis.conf
</code></pre> 
<p>通过ps查看状态：</p> 
<pre><code class="prism language-sh"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> redis
</code></pre> 
<p>发现服务都已经正常启动：<br> <img src="https://images2.imgbox.com/dc/54/t1dvLsv2_o.png" alt="在这里插入图片描述"></p> 
<p>如果要关闭所有进程，可以执行命令：</p> 
<pre><code class="prism language-sh"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> redis <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">kill</span>
</code></pre> 
<p>或者（推荐这种方式）：</p> 
<pre><code class="prism language-sh"><span class="token builtin class-name">printf</span> <span class="token string">'%s\n'</span> <span class="token number">7001</span> <span class="token number">7002</span> <span class="token number">7003</span> <span class="token number">8001</span> <span class="token number">8002</span> <span class="token number">8003</span> <span class="token operator">|</span> <span class="token function">xargs</span> -I<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token parameter variable">-t</span> redis-cli <span class="token parameter variable">-p</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token function">shutdown</span>
</code></pre> 
<h4><a id="414__785"></a>4.1.4 创建集群</h4> 
<p>虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。</p> 
<p>我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。</p> 
<p>1）Redis5.0之前</p> 
<p>Redis5.0之前集群命令都是用redis安装包下的src/redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。</p> 
<pre><code class="prism language-sh"><span class="token comment"># 安装依赖</span>
yum <span class="token parameter variable">-y</span> <span class="token function">install</span> zlib ruby rubygems
gem <span class="token function">install</span> redis
</code></pre> 
<p>然后通过命令来管理集群：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 进入redis的src目录</span>
<span class="token builtin class-name">cd</span> /tmp/redis-6.2.4/src
<span class="token comment"># 创建集群</span>
./redis-trib.rb create <span class="token parameter variable">--replicas</span> <span class="token number">1</span> <span class="token number">192.168</span>.150.101:7001 <span class="token number">192.168</span>.150.101:7002 <span class="token number">192.168</span>.150.101:7003 <span class="token number">192.168</span>.150.101:8001 <span class="token number">192.168</span>.150.101:8002 <span class="token number">192.168</span>.150.101:8003
</code></pre> 
<p>2）Redis5.0以后</p> 
<p>我们使用的是Redis6.2.4版本，集群管理以及集成到了redis-cli中，格式如下：</p> 
<pre><code class="prism language-sh">redis-cli <span class="token parameter variable">--cluster</span> create --cluster-replicas <span class="token number">1</span> <span class="token number">192.168</span>.150.101:7001 <span class="token number">192.168</span>.150.101:7002 <span class="token number">192.168</span>.150.101:7003 <span class="token number">192.168</span>.150.101:8001 <span class="token number">192.168</span>.150.101:8002 <span class="token number">192.168</span>.150.101:8003
</code></pre> 
<p>命令说明：</p> 
<ul><li><code>redis-cli --cluster</code>或者<code>./redis-trib.rb</code>：代表集群操作命令</li><li><code>create</code>：代表是创建集群</li><li><code>--replicas 1</code>或者<code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</li></ul> 
<p>运行后的样子：<br> <img src="https://images2.imgbox.com/02/28/XR8Hucwn_o.png" alt="在这里插入图片描述"></p> 
<p>这里输入yes，则集群开始创建：<br> <img src="https://images2.imgbox.com/37/35/vKoOy0E6_o.png" alt="在这里插入图片描述"></p> 
<p>通过命令可以查看集群状态：</p> 
<pre><code class="prism language-sh">redis-cli <span class="token parameter variable">-p</span> <span class="token number">7001</span> cluster nodes
</code></pre> 
<p><img src="https://images2.imgbox.com/62/74/XrdrkhtZ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>【注意】</strong><br> redis-cluster配置过程中，如果出现了，Waiting for the cluster to join… 这句话，并一直卡在这里，需要考虑以下原因：</p> 
<pre><code>	假如现在有3台机器信息如下：
   A 192.168.131.1 1111(Master)  1112(Slave)
   B 192.168.131.2 2221(Master)  2222(Slave)
   C 192.168.131.3 3331(Master)  3332(Slave)
</code></pre> 
<ul><li> <p>1）配置文件redis.conf 中的bind 设置，IP要是本机地址</p> <pre><code class="prism language-java">    <span class="token class-name">A</span><span class="token operator">-</span>redis<span class="token punctuation">.</span>conf ：bind <span class="token number">192.168</span><span class="token number">.131</span><span class="token number">.1</span>
</code></pre> <pre><code class="prism language-java">    <span class="token class-name">B</span><span class="token operator">-</span>redis<span class="token punctuation">.</span>conf ：bind <span class="token number">192.168</span><span class="token number">.131</span><span class="token number">.2</span>
</code></pre> <pre><code class="prism language-java">    <span class="token class-name">C</span><span class="token operator">-</span>redis<span class="token punctuation">.</span>conf ：bind <span class="token number">192.168</span><span class="token number">.131</span><span class="token number">.3</span>
</code></pre> </li><li> <p>2）确保所有使用的端口之间互通，可用telnet ip port 测试**</p> </li><li> <p>3）登录到每个客户端，执行 flushall、 cluster reset，重启实例之前你要删除以下文件:</p> <pre><code class="prism language-java"> 	 rm <span class="token operator">-</span>rf nodes<span class="token punctuation">.</span>conf          <span class="token comment">// cluster-config-file</span>
	 rm <span class="token operator">-</span>rf dump<span class="token punctuation">.</span>rdb            <span class="token comment">// dbfilename</span>
	 rm <span class="token operator">-</span>rf appendonly<span class="token punctuation">.</span>aof      <span class="token comment">// appendfilename</span>
</code></pre> </li><li> <p>4）如果通讯端口为6379，那么集群总线端口16379一定要打开【重要】</p> </li><li> <p>5）使用cluster meet语法<br> 如果B给 A、C发送cluster meet信息（这里挺坑的）：</p> <pre><code class="prism language-java"><span class="token class-name">B</span>上执行redis<span class="token operator">-</span>cli <span class="token operator">-</span>c <span class="token operator">-</span>h <span class="token number">192.168</span><span class="token number">.131</span><span class="token number">.2</span> <span class="token operator">-</span>p <span class="token number">2221</span>
    cluster meet <span class="token number">192.168</span><span class="token number">.131</span><span class="token number">.1</span> <span class="token number">1111</span>
    cluster meet <span class="token number">192.168</span><span class="token number">.131</span><span class="token number">.1</span> <span class="token number">1112</span>
    cluster meet <span class="token number">192.168</span><span class="token number">.131</span><span class="token number">.3</span> <span class="token number">3331</span>
    cluster meet <span class="token number">192.168</span><span class="token number">.131</span><span class="token number">.3</span> <span class="token number">3332</span>
</code></pre> <p>如果执行完cluster meet之后，A与B处于handshanke，然后就断掉，导致cluster meet不成功</p> <p>尝试检查你机器上的这些端口是否已打开：</p> <pre><code class="prism language-java">  	    <span class="token class-name">A</span><span class="token operator">-</span>port 打开：<span class="token number">1111</span>（通讯端口）、<span class="token function">11111</span><span class="token punctuation">(</span>总线端口<span class="token punctuation">)</span>
                     <span class="token number">1112</span>（通讯端口）、<span class="token function">11112</span><span class="token punctuation">(</span>总线端口<span class="token punctuation">)</span>
        <span class="token class-name">B</span><span class="token operator">-</span>port 打开：<span class="token number">2221</span>（通讯端口）、<span class="token function">12221</span><span class="token punctuation">(</span>总线端口<span class="token punctuation">)</span>
                     <span class="token number">2222</span>（通讯端口）、<span class="token function">12222</span><span class="token punctuation">(</span>总线端口<span class="token punctuation">)</span>
        <span class="token class-name">C</span><span class="token operator">-</span>port 打开：<span class="token number">3331</span>（通讯端口）、<span class="token function">13331</span><span class="token punctuation">(</span>总线端口<span class="token punctuation">)</span>
                     <span class="token number">3332</span>（通讯端口）、<span class="token function">13332</span><span class="token punctuation">(</span>总线端口<span class="token punctuation">)</span>
</code></pre> </li></ul> 
<h4><a id="415__899"></a>4.1.5 测试</h4> 
<p>尝试连接7001节点，存储一个数据：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 连接</span>
redis-cli <span class="token parameter variable">-p</span> <span class="token number">7001</span>
<span class="token comment"># 存储数据</span>
<span class="token builtin class-name">set</span> num <span class="token number">123</span>
<span class="token comment"># 读取数据</span>
get num
<span class="token comment"># 再次存储</span>
<span class="token builtin class-name">set</span> a <span class="token number">1</span>
</code></pre> 
<p>结果悲剧了：<br> <img src="https://images2.imgbox.com/b2/82/vsIzk8hQ_o.png" alt="在这里插入图片描述"></p> 
<p>集群操作时，需要给<code>redis-cli</code>加上<code>-c</code>参数才可以：</p> 
<pre><code class="prism language-sh">redis-cli <span class="token parameter variable">-c</span> <span class="token parameter variable">-p</span> <span class="token number">7001</span>
</code></pre> 
<p>这次可以了：<br> <img src="https://images2.imgbox.com/6e/68/t4tWESM9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="42__926"></a>4.2 散列插槽</h3> 
<h4><a id="421__927"></a>4.2.1 插槽原理</h4> 
<p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：<br> <img src="https://images2.imgbox.com/99/34/IwFmuzrH_o.png" alt="在这里插入图片描述"><br> 数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p> 
<ul><li>key中包含"{}"，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li><li>key中不包含“{}”，整个key都是有效部分</li></ul> 
<p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。<br> <img src="https://images2.imgbox.com/fb/ba/sWA9qrBU_o.png" alt="在这里插入图片描述"></p> 
<p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。</p> 
<p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p> 
<h4><a id="421__942"></a>4.2.1 小结</h4> 
<p><strong>Redis如何判断某个key应该在哪个实例？</strong></p> 
<ul><li>将16384个插槽分配到不同的实例</li><li>根据key的有效部分计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul> 
<p><strong>如何将同一类数据固定的保存在同一个Redis实例？</strong></p> 
<ul><li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li></ul> 
<h3><a id="43__953"></a>4.3 集群伸缩</h3> 
<p>redis-cli --cluster提供了很多操作集群的命令，可以通过下面方式查看：<br> <img src="https://images2.imgbox.com/26/77/eUiAPIm8_o.png" alt="在这里插入图片描述"><br> 比如，添加节点的命令：<br> <img src="https://images2.imgbox.com/5f/e5/nW9Bhr1U_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="431__959"></a>4.3.1 需求分析</h4> 
<p>需求：向集群中添加一个新的master节点，并向其中存储 num = 10</p> 
<ul><li>启动一个新的redis实例，端口为7004</li><li>添加7004到之前的集群，并作为一个master节点</li><li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li></ul> 
<p>这里需要两个新的功能：</p> 
<ul><li>添加一个节点到集群中</li><li>将部分插槽分配到新插槽</li></ul> 
<h4><a id="432_redis_971"></a>4.3.2 创建新的redis实例</h4> 
<p>创建一个文件夹：</p> 
<pre><code class="prism language-sh"><span class="token function">mkdir</span> <span class="token number">7004</span>
</code></pre> 
<p>拷贝配置文件：</p> 
<pre><code class="prism language-sh"><span class="token function">cp</span> redis.conf ./7004
</code></pre> 
<p>修改配置文件：</p> 
<pre><code class="prism language-sh"><span class="token function">sed</span> <span class="token parameter variable">-i</span> /s/6379/7004/g <span class="token number">7004</span>/redis.conf
</code></pre> 
<p>启动</p> 
<pre><code class="prism language-sh">redis-server <span class="token number">7004</span>/redis.conf
</code></pre> 
<h4><a id="433_redis_996"></a>4.3.3 添加新节点到redis</h4> 
<p>添加节点的语法如下：<br> <img src="https://images2.imgbox.com/d6/69/YRfdR806_o.png" alt="在这里插入图片描述"></p> 
<p>执行命令：</p> 
<pre><code class="prism language-sh">redis-cli <span class="token parameter variable">--cluster</span> add-node  <span class="token number">192.168</span>.150.101:7004 <span class="token number">192.168</span>.150.101:7001
</code></pre> 
<p>通过命令查看集群状态：</p> 
<pre><code class="prism language-sh">redis-cli <span class="token parameter variable">-p</span> <span class="token number">7001</span> cluster nodes
</code></pre> 
<p>如图，7004加入了集群，并且默认是一个master节点：<br> <img src="https://images2.imgbox.com/23/88/w6sil0Ee_o.png" alt="在这里插入图片描述"><br> 但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</p> 
<h4><a id="434__1016"></a>4.3.4 转移插槽</h4> 
<p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：<br> <img src="https://images2.imgbox.com/32/0d/9VI8rkyt_o.png" alt="在这里插入图片描述"><br> 如上图所示，num的插槽为2765.</p> 
<p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：<br> <img src="https://images2.imgbox.com/8d/84/ah5ijKeU_o.png" alt="在这里插入图片描述"></p> 
<p>具体命令如下：</p> 
<p>建立连接：<br> <img src="https://images2.imgbox.com/dd/ad/nZB6AzDS_o.png" alt="在这里插入图片描述"></p> 
<p>得到下面的反馈：<br> <img src="https://images2.imgbox.com/d7/5a/EDmKzvgQ_o.png" alt="在这里插入图片描述"><br> 询问要移动多少个插槽，我们计划是3000个：</p> 
<p>新的问题来了：<br> <img src="https://images2.imgbox.com/a7/70/GQenAF28_o.png" alt="在这里插入图片描述"></p> 
<p>那个node来接收这些插槽？？</p> 
<p>显然是7004，那么7004节点的id是多少呢？<br> <img src="https://images2.imgbox.com/e0/d6/MSwZBapV_o.png" alt="在这里插入图片描述"><br> 复制这个id，然后拷贝到刚才的控制台后：<br> <img src="https://images2.imgbox.com/1e/c1/WexiVHAz_o.png" alt="在这里插入图片描述"></p> 
<p>这里询问，你的插槽是从哪里移动过来的？</p> 
<ul><li>all：代表全部，也就是三个节点各转移一部分</li><li>具体的id：目标节点的id</li><li>done：没有了</li></ul> 
<p>这里我们要从7001获取，因此填写7001的id：<br> <img src="https://images2.imgbox.com/ea/c2/P5bqjbAI_o.png" alt="在这里插入图片描述"></p> 
<p>填完后，点击done，这样插槽转移就准备好了：<br> <img src="https://images2.imgbox.com/b5/b0/iTnxywHG_o.png" alt="在这里插入图片描述"><br> 确认要转移吗？输入yes：</p> 
<p>然后，通过命令查看结果：<br> <img src="https://images2.imgbox.com/58/4d/JVSp0Jed_o.png" alt="在这里插入图片描述"><br> 可以看到：<br> <img src="https://images2.imgbox.com/67/1b/w58ToMNz_o.png" alt="image-20210725162224058.png"><br> 目的达成。</p> 
<h3><a id="44__1062"></a>4.4 故障转移</h3> 
<p>集群初识状态是这样的：<br> <img src="https://images2.imgbox.com/6a/3c/2C4bH88D_o.png" alt="在这里插入图片描述"><br> 其中7001、7002、7003都是master，我们计划让7002宕机。</p> 
<h4><a id="441__1067"></a>4.4.1 自动故障转移</h4> 
<p>当集群中有一个master宕机会发生什么呢？</p> 
<p>直接停止一个redis实例，例如7002：</p> 
<pre><code class="prism language-sh">redis-cli <span class="token parameter variable">-p</span> <span class="token number">7002</span> <span class="token function">shutdown</span>
</code></pre> 
<p>1）首先是该实例与其它实例失去连接</p> 
<p>2）然后是疑似宕机：<br> <img src="https://images2.imgbox.com/1b/7a/TliLYp6E_o.png" alt="在这里插入图片描述"><br> 3）最后是确定下线，自动提升一个slave为新的master：<br> <img src="https://images2.imgbox.com/fd/40/lkVOMXZc_o.png" alt="在这里插入图片描述"><br> 4）当7002再次启动，就会变为一个slave节点了：<br> <img src="https://images2.imgbox.com/c1/d2/iNqKIduj_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="442__1085"></a>4.4.2 手动故障转移</h4> 
<p>利用<code>cluster failover</code>命令可以手动让集群中的某个<code>master</code>宕机，切换到执行<code>cluster failover</code>命令的这个<code>slave</code>节点，实现无感知的数据迁移。其流程如下：<br> <img src="https://images2.imgbox.com/eb/59/m15iM9Yu_o.png" alt="在这里插入图片描述"></p> 
<p><strong>这种<code>failover</code>命令可以指定三种模式：</strong></p> 
<ul><li><strong>缺省</strong>：默认的流程，如图1~6歩</li><li><strong>force</strong>：省略了对offset的一致性校验</li><li><strong>takeover</strong>：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li></ul> 
<p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p> 
<p>步骤如下：</p> 
<p>1）利用redis-cli连接7002这个节点</p> 
<p>2）执行cluster failover命令</p> 
<p>如图：<br> <img src="https://images2.imgbox.com/9c/1e/Wm4NkFcM_o.png" alt="在这里插入图片描述"><br> 效果：<br> <img src="https://images2.imgbox.com/17/62/CoH1ShdY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="45_RedisTemplate_1110"></a>4.5 RedisTemplate访问分片集群</h3> 
<p><code>RedisTemplate</code>底层同样基于<code>lettuce</code>实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p> 
<p>1）引入redis的starter依赖</p> 
<p>2）配置分片集群地址</p> 
<p>3）配置读写分离</p> 
<p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">cluster</span><span class="token punctuation">:</span>
      <span class="token key atrule">nodes</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">7001</span>
        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">7002</span>
        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">7003</span>
        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8001</span>
        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8002</span>
        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8003</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/849ab9e5a6f97f80defe683f1e8b348a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">中间件系列 - Redis入门到实战(实战篇)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d4e5155b52d2d5136bdd2d73154e56a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【电商应用提升用户体验：抖音商品详情API的技术实践与优化策略无标题】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>