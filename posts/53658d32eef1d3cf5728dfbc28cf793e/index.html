<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>iOS中UITableView性能优化 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="iOS中UITableView性能优化" />
<meta property="og:description" content="在iOS应用中，UITableView应该是使用率最高的视图之一了。iPod、时钟、日历、备忘录、Mail、天气、照片、电话、短信、Safari、App Store、iTunes、Game Center⋯几乎所有自带的应用中都能看到它的身影，可见它的重要性。
然而在使用第三方应用时，却经常遇到性能上的问题，普遍表现在滚动时比较卡，特别是table cell中包含图片的情况时。
实际上只要针对性地优化一下，这种问题就不会有了。有兴趣的可以看看LazyTableImages这个官方的例子程序，虽然也要从网上下载图片并显示，但滚动时丝毫不卡。
下面就说说我对UITableView的了解。不过由于我也是初学者，或许会说错或遗漏一些，因此仅供参考。
首先说下UITableView的原理。有兴趣的可以看看《About Table Views in iOS-Based Applications》。
UITableView是UIScrollView的子类，因此它可以自动响应滚动事件（一般为上下滚动）。
它内部包含0到多个UITableViewCell对象，每个table cell展示各自的内容。当新cell需要被显示时，就会调用tableView:cellForRowAtIndexPath:方法来获取或创建一个cell；而不可视时，它又会被释放。由此可见，同一时间其实只需要存在一屏幕的cell对象即可，不需要为每一行创建一个cell。
此外，UITableView还可以分为多个sections，每个区段都可以有自己的head、foot和cells。而在定位一个cell时，就需要2个字段了：在哪个section，以及在这个section的第几行。这在iOS SDK中是用NSIndexPath来表述的，UIKit为其添加了indexPathForRow:inSection:这个创建方法。
其他诸如编辑之类的就不提了，因为和本文无关。
介绍完原理，接下来就开始优化吧。
使用不透明视图。
不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将table cell及其子视图的opaque属性设为YES（默认值）。
其中的特例包括背景色，它的alpha值应该为1（例如不要使用clearColor）；图像的alpha值也应该为1，或者在画图时设为不透明。
当一个view是透明的，iOS需要渲染一个像素两次或多次，这是因为一个像素同时属于很多subviews。这是一个非常耗时的过程。
通过代码或者InterfaceBuilder能够很简单的做到。开发者应该多次检查所有的subviews是不透明的。
对于自定义代码，你可以通过代码来设置，如下：
view.opaque = YES;
不要重复创建不必要的table cell。
前面说了，UITableView只需要一屏幕的UITableViewCell对象即可。因此在cell不可见时，可以将其缓存起来，而在需要时继续使用它即可。
而UITableView也提供了这种机制，只需要简单地设置一个identifier即可：
static NSString *CellIdentifier = @&#34;xxx&#34;;
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
if (cell == nil) {
cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease];
}
值得一提的是，cell被重用时，它内部绘制的内容并不会被自动清除，因此你可能需要调用setNeedsDisplayInRect:或setNeedsDisplay方法。
此外，在添加table cell的时候，如果不需要动画效果，最好不要使用insertRowsAtIndexPaths:withRowAnimation:方法，而是直接调用reloadData方法。因为前者会对所有indexPaths调用tableView:cellForRowAtIndexPath:方法，即便该cell并不需要显示（不知道是不是bug），这就可能创建大量多余的cell。勘误：只是在模拟器上测试如此，真机调试时没有这种bug。
减少视图的数目。
UITableViewCell包含了textLabel、detailTextLabel和imageView等view，而你还可以自定义一些视图放在它的contentView里。然而view是很大的对象，创建它会消耗较多资源，并且也影响渲染的性能。
如果你的table cell包含图片，且数目较多，使用默认的UITableViewCell会非常影响性能。奇怪的是，使用自定义的view，而非预定义的view，明显会快些。
当然，最佳的解决办法还是继承UITableViewCell，并在其drawRect:中自行绘制：
- (void)drawRect:(CGRect)rect {
if (image) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/53658d32eef1d3cf5728dfbc28cf793e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-10-21T23:09:23+08:00" />
<meta property="article:modified_time" content="2015-10-21T23:09:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">iOS中UITableView性能优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在iOS应用中，UITableView应该是使用率最高的视图之一了。iPod、时钟、日历、备忘录、Mail、天气、照片、电话、短信、Safari、App Store、iTunes、Game Center⋯几乎所有自带的应用中都能看到它的身影，可见它的重要性。<br></p> 
<p>然而在使用第三方应用时，却经常遇到性能上的问题，普遍表现在滚动时比较卡，特别是table cell中包含图片的情况时。</p> 
<p>实际上只要针对性地优化一下，这种问题就不会有了。有兴趣的可以看看LazyTableImages这个官方的例子程序，虽然也要从网上下载图片并显示，但滚动时丝毫不卡。</p> 
<p>下面就说说我对UITableView的了解。不过由于我也是初学者，或许会说错或遗漏一些，因此仅供参考。</p> 
<p>首先说下UITableView的原理。有兴趣的可以看看《About Table Views in iOS-Based Applications》。</p> 
<p>UITableView是UIScrollView的子类，因此它可以自动响应滚动事件（一般为上下滚动）。</p> 
<p>它内部包含0到多个UITableViewCell对象，每个table cell展示各自的内容。当新cell需要被显示时，就会调用tableView:cellForRowAtIndexPath:方法来获取或创建一个cell；而不可视时，它又会被释放。由此可见，同一时间其实只需要存在一屏幕的cell对象即可，不需要为每一行创建一个cell。</p> 
<p>此外，UITableView还可以分为多个sections，每个区段都可以有自己的head、foot和cells。而在定位一个cell时，就需要2个字段了：在哪个section，以及在这个section的第几行。这在iOS SDK中是用NSIndexPath来表述的，UIKit为其添加了indexPathForRow:inSection:这个创建方法。</p> 
<p>其他诸如编辑之类的就不提了，因为和本文无关。</p> 
<p>介绍完原理，接下来就开始优化吧。</p> 
<p>使用不透明视图。</p> 
<p>不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将table cell及其子视图的opaque属性设为YES（默认值）。</p> 
<p>其中的特例包括背景色，它的alpha值应该为1（例如不要使用clearColor）；图像的alpha值也应该为1，或者在画图时设为不透明。</p> 
<p>当一个view是透明的，iOS需要渲染一个像素两次或多次，这是因为一个像素同时属于很多subviews。这是一个非常耗时的过程。</p> 
<p>通过代码或者InterfaceBuilder能够很简单的做到。开发者应该多次检查所有的subviews是不透明的。</p> 
<p>对于自定义代码，你可以通过代码来设置，如下：</p> 
<p>view.opaque = YES;</p> 
<p>不要重复创建不必要的table cell。</p> 
<p>前面说了，UITableView只需要一屏幕的UITableViewCell对象即可。因此在cell不可见时，可以将其缓存起来，而在需要时继续使用它即可。</p> 
<p>而UITableView也提供了这种机制，只需要简单地设置一个identifier即可：</p> 
<p>static NSString *CellIdentifier = @"xxx";</p> 
<p>UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];</p> 
<p>if (cell == nil) {<!-- --></p> 
<p>cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease];</p> 
<p>}</p> 
<p>值得一提的是，cell被重用时，它内部绘制的内容并不会被自动清除，因此你可能需要调用setNeedsDisplayInRect:或setNeedsDisplay方法。</p> 
<p>此外，在添加table cell的时候，如果不需要动画效果，最好不要使用insertRowsAtIndexPaths:withRowAnimation:方法，而是直接调用reloadData方法。因为前者会对所有indexPaths调用tableView:cellForRowAtIndexPath:方法，即便该cell并不需要显示（不知道是不是bug），这就可能创建大量多余的cell。勘误：只是在模拟器上测试如此，真机调试时没有这种bug。</p> 
<p>减少视图的数目。</p> 
<p>UITableViewCell包含了textLabel、detailTextLabel和imageView等view，而你还可以自定义一些视图放在它的contentView里。然而view是很大的对象，创建它会消耗较多资源，并且也影响渲染的性能。</p> 
<p>如果你的table cell包含图片，且数目较多，使用默认的UITableViewCell会非常影响性能。奇怪的是，使用自定义的view，而非预定义的view，明显会快些。</p> 
<p>当然，最佳的解决办法还是继承UITableViewCell，并在其drawRect:中自行绘制：</p> 
<p>- (void)drawRect:(CGRect)rect {<!-- --></p> 
<p>if (image) {<!-- --></p> 
<p>[image drawAtPoint:imagePoint];</p> 
<p>self.image = nil;</p> 
<p>} else {<!-- --></p> 
<p>[placeHolder drawAtPoint:imagePoint];</p> 
<p>}</p> 
<p>[text drawInRect:textRect withFont:font lineBreakMode:UILineBreakModeTailTruncation];</p> 
<p>}</p> 
<p>不过这样一来，你会发现选中一行后，这个cell就变蓝了，其中的内容就被挡住了。最简单的方法就是将cell的selectionStyle属性设为UITableViewCellSelectionStyleNone，这样就不会被高亮了。</p> 
<p>此外还可以创建CALayer，将内容绘制到layer上，然后对cell的contentView.layer调用addSublayer:方法。这个例子中，layer并不会显著影响性能，但如果layer透明，或者有圆角、变形等效果，就会影响到绘制速度了。解决办法可参见后面的预渲染图像。</p> 
<p>不要做多余的绘制工作。</p> 
<p>在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。</p> 
<p>例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。</p> 
<p>预渲染图像。</p> 
<p>你会发现即使做到了上述几点，当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕，详细做法可见《利用预渲染加速iOS设备的图像显示》。</p> 
<p>不要阻塞主线程。</p> 
<p>做到前几点后，你的table view滚动时应该足够流畅了，不过你仍可能让用户感到不爽。常见的现象就是在更新数据时，整个界面卡住不动，完全不响应用户请求。</p> 
<p>出现这种现象的原因就是主线程执行了耗时很长的函数或方法，在其执行完毕前，无法绘制屏幕和响应用户请求。其中最常见的就是网络请求了，它通常都需要花费数秒的时间，而你不应该让用户等待那么久。</p> 
<p>解决办法就是使用多线程，让子线程去执行这些函数或方法。这里面还有一个学问，当下载线程数超过2时，会显著影响主线程的性能。因此在使用ASIHTTPRequest时，可以用一个NSOperationQueue来维护下载请求，并将其maxConcurrentOperationCount设为2。而NSURLRequest则可以配合GCD来实现，或者使用NSURLConnection的setDelegateQueue:方法。</p> 
<p>当然，在不需要响应用户请求时，也可以增加下载线程数，以加快下载速度：</p> 
<p>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate {<!-- --></p> 
<p>if (!decelerate) {<!-- --></p> 
<p>queue.maxConcurrentOperationCount = 5;</p> 
<p>}</p> 
<p>}</p> 
<p>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView {<!-- --></p> 
<p>queue.maxConcurrentOperationCount = 5;</p> 
<p>}</p> 
<p>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {<!-- --></p> 
<p>queue.maxConcurrentOperationCount = 2;</p> 
<p>}</p> 
<p>此外，自动载入更新数据对用户来说也很友好，这减少了用户等待下载的时间。例如每次载入50条信息，那就可以在滚动到倒数第10条以内时，加载更多信息：</p> 
<p>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {<!-- --></p> 
<p>if (count - indexPath.row &lt; 10 &amp;&amp; !updating) {<!-- --></p> 
<p>updating = YES;</p> 
<p>[self update];</p> 
<p>}</p> 
<p>}</p> 
<p>// update方法获取到结果后，设置updating为NO</p> 
<p>还有一点要注意的就是当图片下载完成后，如果cell是可见的，还需要更新图像：</p> 
<p>NSArray *indexPaths = [self.tableView indexPathsForVisibleRows];</p> 
<p>for (NSIndexPath *visibleIndexPath in indexPaths) {<!-- --></p> 
<p>if (indexPath == visibleIndexPath) {<!-- --></p> 
<p>MyTableViewCell *cell = (MyTableViewCell *)[self.tableView cellForRowAtIndexPath:indexPath];</p> 
<p>cell.image = image;</p> 
<p>[cell setNeedsDisplayInRect:imageRect];</p> 
<p>break;</p> 
<p>}</p> 
<p>}</p> 
<p>// 也可不遍历，直接与头尾相比较，看是否在中间即可。</p> 
<p>最后还是前面所说过的insertRowsAtIndexPaths:withRowAnimation:方法，插入新行需要在主线程执行，而一次插入很多行的话（例如50行），会长时间阻塞主线程。而换成reloadData方法的话，瞬间就处理完了。</p> 
<p>7、减少预加载时间</p> 
<p>通常，我会通过缓存来重用图片，同时减少初始化的过程。当OS需要为TableView渲染一个新的cell，会通过调用下面的方法来返回一个新的cell：</p> 
<p>view sourceprint?</p> 
<p>1.</p> 
<p>- (UITableViewCell *)tableView:(UITableView *)tableViewcellForRowAtIndexPath:(NSIndexPath *)indexPath {<!-- --></p> 
<p>2.</p> 
<p>// Initialize and return the Cell here</p> 
<p>3.</p> 
<p>}</p> 
<p>因此，如果你在这里阻塞了太长的时间，UserInterface渲染的过程就会被阻塞；它将不能做任何事情或显示任何新的东西。这就是为什么用户看到在某个地方滚动停止的原因。</p> 
<p>为了使这个过程尽可能的快，你可以去除一些逻辑，延迟计算，通过重用来缓存数据和图片。另外一个方法是通过首先使用默认的图片和数据来重用cell。当要获取图片或数据的时候，你可以使用多线程，然后稍后进行填充。从用户的角度来看，这种方法将会使得滚动更加流程，加载图片的速度更快。</p> 
<p>8、缓存高度</p> 
<p>无论是否需要创建一个新的cell，你需要缓存rows的高度，因为这是TableView所需要的信息。如果你的cell的高度是固定的，你不必担心。然而，如果它不是固定的，你需要确保你的cell计算足够的快。</p> 
<p>可以尝试使用如下代码：</p> 
<p>view sourceprint?</p> 
<p>1.</p> 
<p>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath*)indexPath {<!-- --></p> 
<p>2.</p> 
<p>return 80;</p> 
<p>3.</p> 
<p>}</p> 
<p>避免使用下面的代码：</p> 
<p>view sourceprint?</p> 
<p>1.</p> 
<p>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath*)indexPath {<!-- --></p> 
<p>2.</p> 
<p>for (int i = 0; i &lt; 100; i++) {<!-- --></p> 
<p>3.</p> 
<p>// find the smallest possible height for the row</p> 
<p>4.</p> 
<p>}</p> 
<p>5.</p> 
<p>return smallestHeight;</p> 
<p>6.</p> 
<p>}</p> 
<p>当需要渲染cell或者在动画过程中需要编辑/重排序cell的时候，OS会多次运行第一段代码段。xiang像第二段代码中有一个循环，无论是否需要知道cell的高度，OS都会运行一个重复100次的循环。</p> 
<p>9、避免使用图形特效</p> 
<p>避免在UIImage中使用复杂的图形特效(例如渐变)。</p> 
<p>总结</p> 
<p>恰当的重用cell：这是第一步，也是最重要的一步。重用一个cell非常简单，但是很多应用都会漏了这一步。因此，你如果有很多性能问题，确保多次检查这方面的问题。</p> 
<p>恰当的 缓存/重用 图片/数据：另外一个重要的步骤就是当返回一个cell显示的时候，减少数据加载和逻辑处理的时间。</p> 
<p>减少总的加载和计算时间：并不是仅仅只有IO会减慢和阻塞UI线程；任何数据的处理都会减慢这个过程。因此，你应该总是尽可能的减少这个过程的处理时间。</p> 
<p>自行绘制cell：在渲染table view的时候，为了充分利用GPU计算密集型的优势，你应该考虑使用直接绘制的方法。这样会显著的提升渲染的速度，增加测量的性能；fps几乎接近最大。你可以通过复写drawRect方法绘制自己的cell，然后在每个元素中调用不同的方法绘制每个UI元素。</p> 
<p>透明度：当开发者将他们的UI元素放进view的时候，这是经常会遇到的小问题。如果他们没有设置view为不透明，渲染的时候就要对同一个点绘制两次或多次。</p> 
<p>缓存高度：这是开发者经常会犯的另一个小错误。每当需要一个新的cell，每次都会有两个主要的方法被调用。</p> 
<p>避免图形特效：在cell中有越多的特效，渲染的过程就越慢。因此，你应该对此进行测试。你可以使用CoreAnimation来查看每个UI元素渲染的效率。</p> 
<p>编辑/重排序性能：滚动性能优化，对于编辑或重排序来说，可能会带来一些问题，因为UIKit和动画框架已经多subview进行了优化。如果你是自己绘制的话，这些框架的优化将不起作用</p> 
<p> <br></p> 
<p>相关链接:http://blog.csdn.net/majiakun1/article/details/8948663</p> 
<p>https://developer.apple.com/library/ios/samplecode/LazyTableImages/Introduction/Intro.html<br></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85cd059a04476f8ffe763b8d32323926/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java 函数返回多个函数值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ecfc9162d05374960eec93385fc529cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux文件和文件夹复制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>