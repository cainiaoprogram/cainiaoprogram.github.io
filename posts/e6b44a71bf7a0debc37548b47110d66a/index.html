<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>方向向量转欧拉角 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="方向向量转欧拉角" />
<meta property="og:description" content="转载原始帖子：https://www.jianshu.com/p/1b4f310fb883
本节就一个功能，加载一个导弹，让其在上一节的基础上，从发射架那里打到地面站那里。
image.png
具体实现 这里我们输入的是一连串的经纬高，组成导弹的路径。然后生成一个animationPath就可以了。第10节 实例-双击跑过去操作器 在这一节也用了animationPath，animationPath最关键的参数是位置、朝向，位置好说，关键点就是位置。关键在朝向。有了位置、朝向、时间直接就可以生成animationPath。
要计算导弹在一个点的朝向确非易事，要先搞明白一件事情：就是导弹在建模时有个方向，这是导弹的局部坐标。将其放在地球上是使用的这样的方法：
osg::MatrixTransform* mt = new osg::MatrixTransform; mt-&gt;addChild(LodAutoMode(fileName, radioSize)); osg::Matrixd mts; _em-&gt;computeLocalToWorldTransformFromLatLongHeight(osg::inDegrees(LLH.y()), osg::inDegrees(LLH.x()), LLH.z(), mts); mt-&gt;setMatrix(mts); 我们要知道mts这个矩阵，将物体从世界坐标系的(0,0,0)给移到地表，除了改变了位置以外，还改变了朝向。这个要想象一下，假如平移则放在地表的角度是不对的。拿坐标轴来比一下，在世界坐标下这个轴是这样的（Y轴正北，Z轴从地心连，X轴正东）：
本例中计算朝向使用了一个函数叫做：void GetFlyPosture(osg::Vec3d First, osg::Vec3d Second, double&amp; PitchAngle, double&amp; yAngleHengGun, double&amp; YawAngle)
给定起点、终点，然后计算出导弹的俯仰角、横滚角、航向角。这里详细的判断了起点和终点的经纬高之间的关系，读者可以看一下理解一下，比如经纬度没有变，只高度变化，则就是顺着地表垂直向上发射
作者：杨石兴
链接：https://www.jianshu.com/p/1b4f310fb883
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
#include &lt;osgViewer/Viewer&gt;
#include &lt;osgEarth/EarthManipulator&gt;
#include &lt;osgDB/ReadFile&gt;
#include &lt;osg/Geode&gt;
#include &lt;osg/MatrixTransform&gt;
#include &lt;osg/LineWidth&gt;
#include &lt;osg/LineStipple&gt;
#include &lt;osg/AutoTransform&gt;
#include &lt;osg/AnimationPath&gt;
#include &lt;osg/ImageSequence&gt;
#include &lt;osg/Depth&gt;
#include &lt;osgParticle/Particle&gt;
#include &lt;osgParticle/ParticleSystem&gt;
#include &lt;osgParticle/ModularEmitter&gt;
#include &lt;osgParticle/RandomRateCounter&gt;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e6b44a71bf7a0debc37548b47110d66a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-15T20:23:52+08:00" />
<meta property="article:modified_time" content="2021-08-15T20:23:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">方向向量转欧拉角</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>转载原始帖子：<a href="https://www.jianshu.com/p/1b4f310fb883" rel="nofollow">https://www.jianshu.com/p/1b4f310fb883</a></p> 
<p>本节就一个功能，加载一个导弹，让其在上一节的基础上，从发射架那里打到地面站那里。</p> 
<p><img alt="" height="438" src="https://images2.imgbox.com/08/fe/9XE4UbR3_o.png" width="685"></p> 
<p> </p> 
<p> </p> 
<p></p> 
<p>image.png</p> 
<h4>具体实现</h4> 
<p>这里我们输入的是一连串的经纬高，组成导弹的路径。然后生成一个animationPath就可以了。第10节 实例-双击跑过去操作器 在这一节也用了animationPath，animationPath最关键的参数是<strong>位置、朝向</strong>，位置好说，关键点就是位置。关键在朝向。有了位置、朝向、时间直接就可以生成animationPath。</p> 
<p>要计算导弹在一个点的朝向确非易事，要先搞明白一件事情：就是导弹在建模时有个方向，这是导弹的局部坐标。将其放在地球上是使用的这样的方法：</p> 
<p></p> 
<pre><code>    osg::MatrixTransform* mt = new osg::MatrixTransform;
    mt-&gt;addChild(LodAutoMode(fileName, radioSize));

    osg::Matrixd mts;
    _em-&gt;computeLocalToWorldTransformFromLatLongHeight(osg::inDegrees(LLH.y()), osg::inDegrees(LLH.x()), LLH.z(), mts);
    mt-&gt;setMatrix(mts);
</code></pre> 
<p>我们要知道mts这个矩阵，将物体从世界坐标系的(0,0,0)给移到地表，除了改变了位置以外，还改变了朝向。这个要想象一下，假如平移则放在地表的角度是不对的。拿坐标轴来比一下，在世界坐标下这个轴是这样的（Y轴正北，Z轴从地心连，X轴正东）：</p> 
<p></p> 
<p></p> 
<p><img alt="" height="447" src="https://images2.imgbox.com/ee/1b/KiHXcV34_o.png" width="848"></p> 
<p> </p> 
<p>本例中计算朝向使用了一个函数叫做：void GetFlyPosture(osg::Vec3d First, osg::Vec3d Second, double&amp; PitchAngle, double&amp; yAngleHengGun, double&amp; YawAngle)<br> 给定起点、终点，然后计算出导弹的<strong>俯仰角、横滚角、航向角</strong>。这里详细的判断了起点和终点的经纬高之间的关系，读者可以看一下理解一下，比如经纬度没有变，只高度变化，则就是顺着地表垂直向上发射</p> 
<p><br><br> 作者：杨石兴<br> 链接：https://www.jianshu.com/p/1b4f310fb883<br> 来源：简书<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> 
<p>#include &lt;osgViewer/Viewer&gt;<br> #include &lt;osgEarth/EarthManipulator&gt;<br> #include &lt;osgDB/ReadFile&gt;<br> #include &lt;osg/Geode&gt;<br> #include &lt;osg/MatrixTransform&gt;<br> #include &lt;osg/LineWidth&gt;<br> #include &lt;osg/LineStipple&gt;<br> #include &lt;osg/AutoTransform&gt;<br> #include &lt;osg/AnimationPath&gt;<br> #include &lt;osg/ImageSequence&gt;<br> #include &lt;osg/Depth&gt;</p> 
<p>#include &lt;osgParticle/Particle&gt;<br> #include &lt;osgParticle/ParticleSystem&gt;<br> #include &lt;osgParticle/ModularEmitter&gt;<br> #include &lt;osgParticle/RandomRateCounter&gt;<br> #include &lt;osgParticle/SectorPlacer&gt;<br> #include &lt;osgParticle/ModularProgram&gt;<br> #include &lt;osgParticle/AccelOperator&gt;<br> #include &lt;osgParticle/ParticleSystemUpdater&gt;</p> 
<p>//全局椭球体，用于经纬度坐标与XYZ坐标互相转换<br> osg::EllipsoidModel* _em = new osg::EllipsoidModel;<br> osg::Node* _lanFang = nullptr;</p> 
<p>class FindNodeVisitor : public osg::NodeVisitor<br> {<!-- --><br> public:<br>     FindNodeVisitor() :osg::NodeVisitor(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN)<br>     {<!-- --><br>     }</p> 
<p>    virtual void apply(osg::Node&amp; node)<br>     {<!-- --><br>         if (node.getName() == _showName)<br>         {<!-- --><br>             node.asGroup()-&gt;getChild(0)-&gt;setNodeMask(~0);<br>         }</p> 
<p>        if (node.getName() == _hideName)<br>         {<!-- --><br>             node.asGroup()-&gt;getChild(0)-&gt;setNodeMask(0);<br>         }</p> 
<p>        traverse(node);<br>     }</p> 
<p>    std::string _showName;<br>     std::string _hideName;<br> };</p> 
<p>class apCtrl : public osg::NodeCallback<br> {<!-- --><br> public:    <br>     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv)<br>     {<!-- --><br>         //先获取当前路径更新回调<br>         osg::AnimationPathCallback* apc = dynamic_cast&lt;osg::AnimationPathCallback*&gt;(node-&gt;getUpdateCallback());<br>         if (nullptr != apc)<br>         {<!-- --><br>             //判断推演是否结束<br>             if (apc-&gt;getAnimationPath()-&gt;getPeriod() &lt;= (apc-&gt;getAnimationTime() + 0.0001))<br>             {<!-- --><br>                 //推演结束，导弹消失，爆炸要爆<br>                 FindNodeVisitor fnv;<br>                 fnv._showName = "Explosion";<br>                 fnv._hideName = "BaseMode";<br>                 node-&gt;accept(fnv);</p> 
<p>                //蓝方的房子也要隐藏<br>                 _lanFang-&gt;accept(fnv);<br>             }<br>         }<br>         //不需要再往下处理了，就处理这一个结点就行<br>         //traverse(node, nv);<br>     }</p> 
<p>};</p> 
<p>//创建爆炸效果<br> osg::Node* explosion(int size)<br> {<!-- --><br>     osg::ImageSequence* imageSequence = new osg::ImageSequence;<br>     for (int i = 1; i &lt;= 121; i++)<br>     {<!-- --><br>         std::stringstream buf;<br>         buf &lt;&lt; "./image/Explosion" &lt;&lt; std::setw(4) &lt;&lt; std::setfill('0') &lt;&lt; i &lt;&lt; ".png";<br>         std::string imageName = buf.str();</p> 
<p>        osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(imageName);<br>         if (image.valid())<br>         {<!-- --><br>             imageSequence-&gt;addImage(image.get());<br>         }<br>     }</p> 
<p>    unsigned int maxNum = imageSequence-&gt;getNumImageData();<br>     imageSequence-&gt;setLength(double(maxNum) * (1.0 / 30.0));</p> 
<p>    //<br>     imageSequence-&gt;setLoopingMode(osg::ImageStream::LOOPING);</p> 
<p>    osg::Texture2D* texture = new osg::Texture2D;<br>     texture-&gt;setFilter(osg::Texture::MIN_FILTER, osg::Texture::LINEAR);<br>     texture-&gt;setFilter(osg::Texture::MAG_FILTER, osg::Texture::LINEAR);<br>     texture-&gt;setWrap(osg::Texture::WRAP_R, osg::Texture::REPEAT);<br>     texture-&gt;setResizeNonPowerOfTwoHint(false);<br>     texture-&gt;setImage(imageSequence);</p> 
<p>    osg::Billboard* center = new osg::Billboard();<br>     center-&gt;setMode(osg::Billboard::POINT_ROT_EYE);<br>     center-&gt;addDrawable(osg::createTexturedQuadGeometry(osg::Vec3(-size / 2, 0.0, -size / 2), osg::Vec3(size, 0.0f, 0.0), osg::Vec3(0.0f, 0.0f, size)));</p> 
<p>    osg::StateSet* stateset2 = center-&gt;getOrCreateStateSet();<br>     stateset2-&gt;setTextureAttributeAndModes(0, texture, osg::StateAttribute::ON);<br>     stateset2-&gt;setMode(GL_BLEND, osg::StateAttribute::ON | osg::StateAttribute::PROTECTED | osg::StateAttribute::OVERRIDE);<br>     stateset2-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED | osg::StateAttribute::OVERRIDE);</p> 
<p>    osg::Depth* dp = new osg::Depth();<br>     dp-&gt;setWriteMask(false);<br>     center-&gt;getOrCreateStateSet()-&gt;setAttribute(dp, osg::StateAttribute::ON | osg::StateAttribute::PROTECTED | osg::StateAttribute::OVERRIDE);</p> 
<p>    imageSequence-&gt;play();<br>     imageSequence-&gt;rewind();</p> 
<p>    return center;<br> }</p> 
<p>void RadianLLH2XYZ(const osg::Vec3d&amp; vecLLH, osg::Vec3d&amp; vecXYZ)<br> {<!-- --><br>     _em-&gt;convertLatLongHeightToXYZ(<br>         vecLLH.y(), vecLLH.x(), vecLLH.z(), vecXYZ.x(), vecXYZ.y(), vecXYZ.z());<br> }</p> 
<p>void DegreeLLH2XYZ(const osg::Vec3d&amp; vecLLH, osg::Vec3d&amp; vecXYZ)<br> {<!-- --><br>     osg::Vec3d vecRadianLLH(osg::DegreesToRadians(vecLLH.x()), osg::DegreesToRadians(vecLLH.y()), vecLLH.z());<br>     return RadianLLH2XYZ(vecRadianLLH, vecXYZ);<br> }</p> 
<p>double GetDistance(const osg::Vec3d&amp; start, const osg::Vec3d&amp; end)<br> {<!-- --><br>     return (end - start).length();<br> }</p> 
<p>bool FLOAT_EQUAL(float l, float r)<br> {<!-- --><br>     if (0.000001 &gt;= (l - r) &amp;&amp; -0.000001 &lt;= (l - r))<br>     {<!-- --><br>         return true;<br>     }<br>     return false;<br> }</p> 
<p>void GetFlyPosture(osg::Vec3d First, osg::Vec3d Second, double&amp; PitchAngle, double&amp; yAngleHengGun, double&amp; YawAngle)<br> {<!-- --><br>     //记录第一个点转换为世界坐标后的值<br>     osg::Vec3d FirstXYZ;<br>     //记录第二个点转换为世界坐标后的值<br>     osg::Vec3d SecondXYZ;</p> 
<p>    DegreeLLH2XYZ(First, FirstXYZ);<br>     DegreeLLH2XYZ(Second, SecondXYZ);</p> 
<p>    <br>     //首先计算俯仰角<br>     if (FLOAT_EQUAL(First.z(), Second.z()))<br>     {<!-- --><br>         PitchAngle = 0;<br>     }<br>     else<br>     {<!-- --><br>         double distance = GetDistance(FirstXYZ, SecondXYZ);<br>         double detal = First.z() - Second.z();</p> 
<p>        while (abs(detal) &gt;= abs(distance))<br>         {<!-- --><br>             if (distance &gt; 0)<br>             {<!-- --><br>                 distance = distance + 0.001;<br>             }<br>             else<br>             {<!-- --><br>                 distance = distance - 0.001;//因为经纬高都是double类型的计算距离等于0时可能是取的近似值。<br>             }<br>         }<br>         PitchAngle = -asin(detal / distance);<br>     }</p> 
<p>    <br>     //计算航向角<br>     //如果第一个点和第二个点的纬度相同，则航向角为90度或者-90度<br>     if (FLOAT_EQUAL(First.y(), Second.y()))<br>     {<!-- --><br>         double detal = Second.x() - First.x();//计算经度差<br>         if (detal &lt; -180 || (detal &gt; 0 &amp;&amp; detal &lt; 180))<br>         {<!-- --><br>             //在其右侧180度内<br>             YawAngle = osg::DegreesToRadians(-90.0);//逆时针转为正向，所以在右侧时转的角度为负值。<br>         }<br>         else<br>         {<!-- --><br>             //在其左侧180度内<br>             YawAngle = osg::DegreesToRadians(90.0);<br>         }<br>     }<br>     //如果第一个点的经度和第二个点的经度相同则航向角为0度或者180度<br>     else if (FLOAT_EQUAL(First.x(), Second.x()))<br>     {<!-- --><br>         double detal = Second.y() - First.y();<br>         if (detal &gt; 0)<br>         {<!-- --><br>             YawAngle = osg::DegreesToRadians(0.0);<br>         }<br>         else<br>         {<!-- --><br>             YawAngle = osg::DegreesToRadians(180.0);<br>         }<br>     }<br>     //第一个点和第二个点的经度和维度都不同，此种情况下只考虑xy坐标就可以了不用考虑z即只在XOY平面做计算就可以了<br>     else<br>     {<!-- --><br>         double detalX = Second.x() - First.x();</p> 
<p>        osg::Vec3d Second1(Second.x(), Second.y(), First.z());<br>         osg::Vec3d Second1XYZ;<br>         DegreeLLH2XYZ(Second1, Second1XYZ);</p> 
<p>        double dDistance1 = GetDistance(FirstXYZ, Second1XYZ);</p> 
<p>        osg::Vec3d three(First.x(), Second.y(), Second1.z());<br>         osg::Vec3d threeXYZ;<br>         DegreeLLH2XYZ(three, threeXYZ);<br>         double dDistance2 = GetDistance(FirstXYZ, threeXYZ);</p> 
<p>        while (abs(dDistance2) &gt;= abs(dDistance1))<br>         {<!-- --><br>             if (dDistance1 &gt; 0)<br>             {<!-- --><br>                 dDistance1 = dDistance1 + 0.001;<br>             }<br>             else<br>             {<!-- --><br>                 dDistance1 = dDistance1 - 0.001;<br>             }<br>         }</p> 
<p>        double Angle = acos(dDistance2 / dDistance1);<br>         //如果第二个点在第一个点的右边<br>         if (detalX &lt; -180 || (detalX &gt; 0 &amp;&amp; detalX &lt; 180))<br>         {<!-- --><br>             if (Second.y() &gt; First.y())<br>             {<!-- --><br>                 YawAngle = -Angle;<br>             }<br>             else<br>             {<!-- --><br>                 YawAngle = -(osg::PI - Angle);<br>             }<br>         }<br>         //第二点在第一个点的左侧<br>         else<br>         {<!-- --><br>             if (Second.y() &gt; First.y())<br>             {<!-- --><br>                 YawAngle = Angle;<br>             }<br>             else<br>             {<!-- --><br>                 YawAngle = osg::PI - Angle;<br>             }<br>         }<br>     }<br>     //std::cout&lt;&lt;osg::RadiansToDegrees(YawAngle)&lt;&lt;std::endl;<br> }</p> 
<p>//注意这里的osg::Vec3 xyz是纬、经、高<br> osg::AnimationPath* creatAnimation(osg::Vec3dArray* arrayPosition, double time)<br> {<!-- --><br>     osg::AnimationPath* ap = new osg::AnimationPath;<br>     ap-&gt;setLoopMode(osg::AnimationPath::NO_LOOPING);</p> 
<p>    osg::Matrix posMatrix;<br>     osg::Matrix matrix;</p> 
<p><br>     double dPitch = 0.0, dRoll = 0.0, dYaw = 0.0;</p> 
<p>    if (arrayPosition-&gt;size() &gt; 1)<br>     {<!-- --><br>         _em-&gt;computeLocalToWorldTransformFromLatLongHeight(<br>                 osg::DegreesToRadians(arrayPosition-&gt;at(0).y()),<br>                 osg::DegreesToRadians(arrayPosition-&gt;at(0).x()),<br>                 arrayPosition-&gt;at(0).z(), matrix);</p> 
<p>        GetFlyPosture(arrayPosition-&gt;at(0), arrayPosition-&gt;at(1), dPitch, dRoll, dYaw);<br>     }</p> 
<p>    osg::Matrix adjustPosture = osg::Matrix::rotate(dPitch, osg::X_AXIS, 0.0, osg::Y_AXIS, dYaw, osg::Z_AXIS);</p> 
<p>    posMatrix = adjustPosture * matrix;</p> 
<p>    ap-&gt;insert(0.0, osg::AnimationPath::ControlPoint(posMatrix.getTrans(), posMatrix.getRotate()));<br>     double dAveTime = time / (arrayPosition-&gt;size() - 1.0);<br>     for (unsigned int first = 0, second = first + 1; second &lt; arrayPosition-&gt;size(); first++, second++)<br>     {<!-- --><br>         _em-&gt;computeLocalToWorldTransformFromLatLongHeight(<br>                 osg::DegreesToRadians(arrayPosition-&gt;at(second).y()),<br>                 osg::DegreesToRadians(arrayPosition-&gt;at(second).x()),<br>                 arrayPosition-&gt;at(second).z(), matrix);</p> 
<p>        double dPitch = 0.0, dRoll = 0.0, dYaw = 0.0;<br>         GetFlyPosture(arrayPosition-&gt;at(first), arrayPosition-&gt;at(second), dPitch, dRoll, dYaw);</p> 
<p>        osg::Matrix adjustPosture = osg::Matrix::rotate(dPitch, osg::X_AXIS, 0.0, osg::Y_AXIS, dYaw, osg::Z_AXIS);</p> 
<p>        posMatrix = adjustPosture * matrix;</p> 
<p>        ap-&gt;insert(dAveTime * (first + 1),<br>             osg::AnimationPath::ControlPoint(<br>                 posMatrix.getTrans(),<br>                 posMatrix.getRotate()));<br>     }</p> 
<p>    return ap;<br> }</p> 
<p>osg::Node* LodAutoMode(std::string fileName, float radioSize)<br> {<!-- --><br>     osg::MatrixTransform* tm0 = new osg::MatrixTransform;<br>     tm0-&gt;addChild(osgDB::readNodeFile(fileName));<br>     tm0-&gt;setMatrix(osg::Matrix::scale(osg::Vec3(radioSize, radioSize, radioSize)));<br>     tm0-&gt;setName("BaseMode");</p> 
<p>    //之所以上面要加一层，是隐藏之后NodeVisitor就访问不到了，就无<br>     //法再被遍历到<br>     osg::Group* exTm0 = new osg::Group;<br>     exTm0-&gt;setName("BaseMode");<br>     exTm0-&gt;addChild(tm0);</p> 
<p>    osg::AutoTransform* at = new osg::AutoTransform;<br>     at-&gt;addChild(exTm0);</p> 
<p>    //给每个模型都加个爆炸效果，之所以上面要加一层，是隐藏之后NodeVisitor就访问不到了，就无<br>     //法再被遍历到<br>     osg::Group* exRoot = new osg::Group;<br>     exRoot-&gt;setName("Explosion");<br>     osg::Node* ex = explosion(200.0);<br>     exRoot-&gt;addChild(ex);<br>     ex-&gt;setNodeMask(0);</p> 
<p>    at-&gt;addChild(exRoot);</p> 
<p>    at-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);<br>     at-&gt;setAutoScaleToScreen(true);<br>     at-&gt;setMinimumScale(100.0);<br>     at-&gt;setMaximumScale(10000);<br>     at-&gt;setAutoScaleTransitionWidthRatio(0.0);<br>     return at;<br> }</p> 
<p>osg::Node* LodAutoModel(std::string fileName, osg::Vec3 LLH, float radioSize)<br> {<!-- --><br>     osg::MatrixTransform* mt = new osg::MatrixTransform;<br>     mt-&gt;addChild(LodAutoMode(fileName, radioSize));</p> 
<p>    osg::Matrixd mts;<br>     _em-&gt;computeLocalToWorldTransformFromLatLongHeight(osg::inDegrees(LLH.y()), osg::inDegrees(LLH.x()), LLH.z(), mts);<br>     mt-&gt;setMatrix(mts);</p> 
<p>    return mt;<br> }</p> 
<p><br> //起点经纬度，终点经纬度，中间最高点，来创建一个简单的曲线，再加个导弹来飞循环飞一下<br> osg::Group* BuildScene(osg::Vec3 fromLLH, osg::Vec3 toLLH, float topH)<br> {<!-- --><br>     osg::Group* sceneRoot = new osg::Group;<br>     <br>     //给线前面加一个mt是为了防止大坐标抖动<br>     osg::MatrixTransform* mtLine = new osg::MatrixTransform;<br>     sceneRoot-&gt;addChild(mtLine);</p> 
<p>    osg::Geode* line = new osg::Geode;<br>     mtLine-&gt;addChild(line);</p> 
<p>    osg::Geometry* lineGeom = new osg::Geometry;<br>     line-&gt;addDrawable(lineGeom);</p> 
<p>    //线的宽度设置成5<br>     osg::LineWidth* lw = new osg::LineWidth(3.0);<br>     lineGeom-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(lw, osg::StateAttribute::ON);<br>     lineGeom-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF);</p> 
<p>    //设置成点画线<br>     osg::LineStipple* ls = new osg::LineStipple(1, 0x00FF);<br>     lineGeom-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(ls, osg::StateAttribute::ON);</p> 
<p>    osg::Vec3Array* vertex = new osg::Vec3Array;<br>     lineGeom-&gt;setVertexArray(vertex);</p> 
<p>    //线的颜色设置成高级灰<br>     osg::Vec4Array* color = new osg::Vec4Array;<br>     color-&gt;push_back(osg::Vec4(0.8, 0.8, 0.8, 1.0));<br>     lineGeom-&gt;setColorArray(color, osg::Array::BIND_OVERALL);</p> 
<p>    //从起点到终点的经纬度，采用简单插值算法，插上100个点<br>     float deltaLat = (toLLH.x() - fromLLH.x()) / 100;<br>     float deltaLon = (toLLH.y() - fromLLH.y()) / 100;<br>     //高度变化前半程<br>     float deltaHF = (topH - fromLLH.z()) / 50;<br>     //高度变化后半程<br>     float deltaHT = (toLLH.z() - topH) / 50;</p> 
<p>    //防止大坐标抖动，将所有顶点的值都减动一个fromLLH<br>     osg::Vec3d fromV;<br>     _em-&gt;convertLatLongHeightToXYZ(osg::inDegrees(fromLLH.y()), osg::inDegrees(fromLLH.x()), fromLLH.z(), fromV.x(), fromV.y(), fromV.z());<br>     mtLine-&gt;setMatrix(osg::Matrix::translate(fromV));</p> 
<p>    //关键点的经纬度形式<br>     osg::Vec3dArray* llhArray = new osg::Vec3dArray;</p> 
<p>    for (int i = 0; i &lt; 100; i++)<br>     {<!-- --><br>         osg::Vec3 tempPoint = fromLLH + osg::Vec3(deltaLat*i, deltaLon*i, deltaHF*i);<br>         if (i &gt; 49)//到中间了要往下了<br>         {<!-- --><br>             tempPoint.z() = topH + deltaHT*(i-49);<br>         }</p> 
<p>        llhArray-&gt;push_back(tempPoint);</p> 
<p>        osg::Vec3d tempV;<br>         _em-&gt;convertLatLongHeightToXYZ(osg::inDegrees(tempPoint.y()), osg::inDegrees(tempPoint.x()), tempPoint.z(), tempV.x(), tempV.y(), tempV.z());<br>         tempV -= fromV; //防止大坐标抖动<br>         vertex-&gt;push_back(tempV);<br>     }</p> 
<p>    lineGeom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_LINE_STRIP, 0, vertex-&gt;size()));</p> 
<p>    osg::AnimationPath* ap = creatAnimation(llhArray, 30.0);<br>     osg::MatrixTransform* mtAp = new osg::MatrixTransform;<br>     mtAp-&gt;addUpdateCallback(new osg::AnimationPathCallback(ap));<br>     //下面这个callback用来负责控制导弹是否击中目标（其实就是路径播完）<br>     mtAp-&gt;addUpdateCallback(new apCtrl());<br>     mtAp-&gt;addChild(LodAutoMode("huojianend.ive", 35.0));<br>     sceneRoot-&gt;addChild(mtAp);</p> 
<p>    return sceneRoot;<br> }</p> 
<p>int main(int argc, char** argv)<br> {<!-- --><br>     osgEarth::initialize();<br>     osgViewer::Viewer viewer;<br>     viewer.setCameraManipulator(new osgEarth::Util::EarthManipulator);</p> 
<p>    osg::Group* root = new osg::Group;<br>     root-&gt;addChild(BuildScene(osg::Vec3(121.50, 25.04, 100), osg::Vec3(131.66, 33.22, 100), 100000));<br>     root-&gt;addChild(osgDB::readNodeFile("simple.earth"));<br>     root-&gt;addChild(LodAutoModel("RedCar.ive", osg::Vec3(121.50, 25.04, 100), 5.0));</p> 
<p>    _lanFang = LodAutoModel("house.ive", osg::Vec3(131.66, 33.22, 100), 0.08);<br>     root-&gt;addChild(_lanFang);</p> 
<p>    viewer.setSceneData(root);<br>     return viewer.run();<br> }</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/91541b6be85e2f7b060dec9477357685/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">支持向量机——SVM原理阐述</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f44634ce3cc0b56d501a15e4ceac9804/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ROS WARNING: disk usage in log directory [/home/***/.ros/log] is over 1GB.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>