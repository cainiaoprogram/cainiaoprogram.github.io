<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之工厂方法模式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式之工厂方法模式" />
<meta property="og:description" content="文章目录 工厂方法模式（Factory Method Pattern）示例 设计模式是经验总结，是学习软件设计的有效方法，因此，了解和理解现有的设计模式，是提高软件设计的有效途径之一，这里将介绍相关的设计模式，并通过示例了理解其用法。 工厂方法模式（Factory Method Pattern） 工厂方法模式定义了一个创建对象的接口，但是由子类来决定要实例化的类是哪一个。它让类把实例化推迟到了子类。
工厂方法模式是 Java 中最常用的设计模式之一，提供了一种创建对象的最佳方式，属于创建型模式。
**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
主要解决： 主要解决接口选择的问题。
何时使用： 我们明确地计划不同条件下创建不同实例时。
如何解决： 让其子类实现工厂接口，返回的也是一个抽象的产品。
关键代码： 创建过程在其子类执行。
应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。
优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。
缺点： 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。
使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。
注意事项： 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
示例 这里以产品创建为例，来说明如何使用工厂方法模式。
首先定义创建者和产品接口，有具体的创建者生产具体的产品，这是基本的设计思路，下面来看看具体实现。
先来看看创建者类，代码如下：
package cn.lut.curiezhang.designpattern.factorymethod; public abstract class Creator { public abstract Product makeProduct(); } 接着是产品类，代码如下：
package cn.lut.curiezhang.designpattern.factorymethod; public abstract class Product { abstract void print(); } 抽象层，两者之间是并行的关系，具体的创建者类来负责具体的产品类的对象的创建，从而，形成二者之间的关系。
具体的创建者A，代码如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f8c5bcf99c8e3a9ebee99aa315f59670/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-08T09:44:24+08:00" />
<meta property="article:modified_time" content="2020-03-08T09:44:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之工厂方法模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Factory_Method_Pattern_2" rel="nofollow">工厂方法模式（Factory Method Pattern）</a></li><li><a href="#_16" rel="nofollow">示例</a></li></ul> 
</div> 
<br> 设计模式是经验总结，是学习软件设计的有效方法，因此，了解和理解现有的设计模式，是提高软件设计的有效途径之一，这里将介绍相关的设计模式，并通过示例了理解其用法。 
<p></p> 
<h2><a id="Factory_Method_Pattern_2"></a>工厂方法模式（Factory Method Pattern）</h2> 
<p>工厂方法模式定义了一个创建对象的接口，但是由子类来决定要实例化的类是哪一个。它让类把实例化推迟到了子类。<br> <img src="https://images2.imgbox.com/e9/bd/8OJ6fFq5_o.png" alt="英文"><br> 工厂方法模式是 Java 中最常用的设计模式之一，提供了一种创建对象的最佳方式，属于创建型模式。<br> **意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br> <strong>主要解决：</strong> 主要解决接口选择的问题。<br> <strong>何时使用：</strong> 我们明确地计划不同条件下创建不同实例时。<br> <strong>如何解决：</strong> 让其子类实现工厂接口，返回的也是一个抽象的产品。<br> <strong>关键代码：</strong> 创建过程在其子类执行。<br> <strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br> <strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。<br> <strong>缺点：</strong> 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。<br> <strong>使用场景：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。<br> <strong>注意事项：</strong> 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p> 
<h2><a id="_16"></a>示例</h2> 
<p>这里以产品创建为例，来说明如何使用工厂方法模式。<br> 首先定义创建者和产品接口，有具体的创建者生产具体的产品，这是基本的设计思路，下面来看看具体实现。<br> 先来看看创建者类，代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>lut<span class="token punctuation">.</span>curiezhang<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>factorymethod<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Creator</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Product <span class="token function">makeProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>接着是产品类，代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>lut<span class="token punctuation">.</span>curiezhang<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>factorymethod<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>抽象层，两者之间是并行的关系，具体的创建者类来负责具体的产品类的对象的创建，从而，形成二者之间的关系。<br> 具体的创建者A，代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>lut<span class="token punctuation">.</span>curiezhang<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>factorymethod<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCreatorA</span> <span class="token keyword">extends</span> <span class="token class-name">Creator</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Product <span class="token function">makeProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>具体的创建者B，代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>lut<span class="token punctuation">.</span>curiezhang<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>factorymethod<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCreatorB</span> <span class="token keyword">extends</span> <span class="token class-name">Creator</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Product <span class="token function">makeProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>从中可以看出，他们分别生产具体的产品A、产品B，具体的产品A，代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>lut<span class="token punctuation">.</span>curiezhang<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>factorymethod<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProductA</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> String x <span class="token operator">=</span> <span class="token string">"A"</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x = "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>具体的产品B，代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>lut<span class="token punctuation">.</span>curiezhang<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>factorymethod<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProductB</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> String x <span class="token operator">=</span> <span class="token string">"B"</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x = "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>现在，已经完成工厂方法的整体构造，那么就来看看如何使用吧，代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>lut<span class="token punctuation">.</span>curiezhang<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>factorymethod<span class="token punctuation">;</span>

<span class="token comment">/**
 * Client
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        Creator creator<span class="token punctuation">;</span>
        Product product<span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"您好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

        creator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCreatorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        product <span class="token operator">=</span> creator<span class="token punctuation">.</span><span class="token function">makeProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        product<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        creator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCreatorB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        product <span class="token operator">=</span> creator<span class="token punctuation">.</span><span class="token function">makeProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        product<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码执行结果如下图所示：<br> <img src="https://images2.imgbox.com/b7/0e/z9Rr0SZO_o.png" alt="结果"><br> 代码实现就是这样的，下面来看看上面设计模式的基本结构，通过类图了解其基本构成，如下图所示：<br> <img src="https://images2.imgbox.com/14/93/oDijAKro_o.png" alt="类图"><br> 了解了其基本结构，就需要搞清楚这些类是怎么样来完成交互的，也就是这些对象之间是如何协作的？就通过顺序图来了解其工作过程，如下图所示：<br> <img src="https://images2.imgbox.com/9f/43/36uqWXag_o.png" alt="顺序图"><br> 请注意其交互过程。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e56efc835d007f39dad69bb387f78975/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">6个高效学习编程的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cda90d1767d31317c5051482b5164433/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">H3C Cloud lab连接CRT并保存会话</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>