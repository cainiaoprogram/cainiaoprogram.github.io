<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql having的用法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql having的用法" />
<meta property="og:description" content="一、 having的用法 having字句可以让我们筛选成组后的各种数据，where字句在聚合前先筛选记录，也就是说作用在group by和having字句前。而 having子句在聚合后对组记录进行筛选。
二、SQL实例 显示每个地区的总人口数和总面积． SELECT region, SUM(population), SUM(area) FROM bbc GROUP BY region 先以region把返回记录分成多个组，这就是GROUP BY的字面含义。分完组后，然后用聚合函数对每组中的不同字段（一或多条记录）作运算。
显示每个地区的总人口数和总面积．仅显示那些面积超过1000000的地区。 //在这里，我们不能用where来筛选超过1000000的地区，因为表中不存在这样一条记录。相反，having子句可以让我们筛选成组后的各组数据 SELECT region, SUM(population), SUM(area) FROM bbc GROUP BY region HAVING SUM(area)&gt;1000000 mysql判断某个字段的长度： select home_page from aaa表 where char_length(trim(home_page))&lt;10 and char_length(trim(home_page))&gt;1; 三、mysql中的where和having子句的区别 mysql中的where和having子句都可以实现过滤记录的功能,但他们的用法还是有一些区别的。 用group by和having子句联合来查出不重复的记录,sql如下:
select uid,email,count(*) as ct from `edm_user081217` GROUP BY email 然后看这个，就容易理解了
//先用group by 对email进行分组,在用having来过滤大于1的,这样查找出来的就是重复的记录了 select uid,email,count(*) as ct from `edm_user081217` GROUP BY email HAVING ct &gt; 1 以下是having和where的区别： Select city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather); 作用的对象不同。 WHERE 子句作用于表和视图HAVING 子句作用于组。 WHERE 在分组和聚集计算之前选取输入行（因此，它控制哪些行进入聚集计算）， 而 HAVING 在分组和聚集之后选取分组的行。因此，WHERE 子句不能包含聚集函数； 因为试图用聚集函数判断那些行输入给聚集运算是没有意义的。 相反，HAVING 子句总是包含聚集函数。（严格说来，你可以写不使用聚集的 HAVING 子句， 但这样做只是白费劲。同样的条件可以更有效地用于 WHERE 阶段。）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0f3c9ecba6037cd8f2eae065b1b7168d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-31T13:57:44+08:00" />
<meta property="article:modified_time" content="2022-07-31T13:57:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql having的用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_having_0"></a>一、 having的用法</h3> 
<p>having字句可以让我们筛选成组后的各种数据，<code>where字句在聚合前先筛选记录，也就是说作用在group by和having字句前。而 having子句在聚合后对组记录进行筛选。</code></p> 
<h3><a id="SQL_4"></a>二、SQL实例</h3> 
<ol><li>显示每个地区的总人口数和总面积．</li></ol> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> region<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>population<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span> <span class="token keyword">FROM</span> bbc <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> region
</code></pre> 
<p>先以region把返回记录分成多个组，这就是GROUP BY的字面含义。<code>分完组后，然后用聚合函数对每组中的不同字段（一或多条记录）作运算。</code></p> 
<ol start="2"><li>显示每个地区的总人口数和总面积．仅显示那些面积超过1000000的地区。</li></ol> 
<pre><code class="prism language-sql"><span class="token comment">//在这里，我们不能用where来筛选超过1000000的地区，因为表中不存在这样一条记录。相反，having子句可以让我们筛选成组后的各组数据</span>
<span class="token keyword">SELECT</span> region<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>population<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span> <span class="token keyword">FROM</span> bbc <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> region <span class="token keyword">HAVING</span> <span class="token function">SUM</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">1000000</span>
</code></pre> 
<ol start="3"><li>mysql判断某个字段的长度：</li></ol> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> home_page <span class="token keyword">from</span> aaa表 <span class="token keyword">where</span> char_length<span class="token punctuation">(</span>trim<span class="token punctuation">(</span>home_page<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">and</span> char_length<span class="token punctuation">(</span>trim<span class="token punctuation">(</span>home_page<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="mysqlwherehaving_28"></a>三、mysql中的where和having子句的区别</h3> 
<ol><li>mysql中的where和having子句<code>都可以实现过滤记录的功能</code>,但他们的用法还是有一些区别的。</li></ol> 
<p>用group by和having子句联合来查出不重复的记录,sql如下:</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> uid<span class="token punctuation">,</span>email<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ct <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">`</span>edm_user081217<span class="token punctuation">`</span></span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> email
</code></pre> 
<p>然后看这个，就容易理解了</p> 
<pre><code class="prism language-sql"><span class="token comment">//先用group by 对email进行分组,在用having来过滤大于1的,这样查找出来的就是重复的记录了</span>
<span class="token keyword">select</span> uid<span class="token punctuation">,</span>email<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ct <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">`</span>edm_user081217<span class="token punctuation">`</span></span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> email <span class="token keyword">HAVING</span> ct <span class="token operator">&gt;</span> <span class="token number">1</span>
</code></pre> 
<ol start="2"><li>以下是having和where的区别：</li></ol> 
<pre><code class="prism language-sql"><span class="token keyword">Select</span> city <span class="token keyword">FROM</span> weather <span class="token keyword">WHERE</span> temp_lo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">max</span><span class="token punctuation">(</span>temp_lo<span class="token punctuation">)</span> <span class="token keyword">FROM</span> weather<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>作用的对象不同。</li></ul> 
<blockquote> 
 <ul><li>WHERE 子句作用于表和视图</li><li>HAVING 子句作用于组。</li></ul> 
</blockquote> 
<p>WHERE 在分组和聚集计算之前选取输入行（因此，它控制哪些行进入聚集计算）， 而 HAVING 在分组和聚集之后选取分组的行。因此，<code>WHERE 子句不能包含聚集函数</code>； 因为试图用聚集函数判断那些行输入给聚集运算是没有意义的。 <code>相反，HAVING 子句总是包含聚集函数。</code>（严格说来，你可以写不使用聚集的 HAVING 子句， 但这样做只是白费劲。同样的条件可以更有效地用于 WHERE 阶段。）<br> 在前面的例子里，我们可以在 WHERE 里应用城市名称限制，因为它不需要聚集。 这样比在 HAVING 里增加限制更加高效，因为我们避免了为那些未通过 WHERE 检查的行进行分组和聚集计算<br> 综上所述：</p> 
<blockquote> 
 <ul><li>having一般跟在group by之后，执行记录组选择的一部分来工作的。</li><li>where则是执行所有数据来工作的。</li><li>再者having可以用聚合函数，如having sum(qty)&gt;1000</li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/499aab40101c63b7376024e2ba0ffdb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">设计模式——工厂方法模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd582e51571d7f10da5114e29a753f48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">面试准备1</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>