<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>变分自编码器（VAE）（一） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="变分自编码器（VAE）（一）" />
<meta property="og:description" content="前言
说来惭愧，VAE接触很久了，一直想把VAE好好的总结一下，一直拖到现在。
闲话少说，关于VAE的文章网上也有不少，解释的最好最清楚的还是苏剑林老师的这篇文章文章链接，还有B站白板推导系列中关于变分推断跟变分自编码器链接。大家可以多看看这两个资料，或者直接看我这次的总结肯定也不错的。
一、理解VAE前需要了解的知识点
1.极大似然估计 关于极大似然估计可以看我这篇文章，理解极大似然估计的原理，因为VAE中也用到了极大似然估计的原理。https://blog.csdn.net/zeronose/article/details/122437636?spm=1001.2014.3001.5501https://blog.csdn.net/zeronose/article/details/122437636?spm=1001.2014.3001.5501
2.高斯混合模型（GMM） 理解高斯混合模型主要是想让GMM跟VAE进行对比，更容易理解，因为GMM和VAE都属于是隐变量模型，其中都有隐变量这个概念。
这篇之前的文章是介绍EM算法的，里面的例子就是用EM算法去解决高斯混合模型的参数估计问题。可以通过这篇文章来理解高斯混合模型。https://blog.csdn.net/zeronose/article/details/122465732?spm=1001.2014.3001.5501https://blog.csdn.net/zeronose/article/details/122465732?spm=1001.2014.3001.5501
3.变分推断 变分推断是想办法找到一个分布去逼近无法计算得出解析解的后验分布。这也是VAE中用来求解后验分布的方法。可以看B站白板推导关于变分推断部分https://www.bilibili.com/video/BV1aE411o7qd?spm_id_from=333.999.0.0https://www.bilibili.com/video/BV1aE411o7qd?spm_id_from=333.999.0.0
二、AE的基本认识 这里的图全部来源于网络，侵权必删，其中下面关于月亮的一部分，来源于这篇文章，侵权必删。
这篇文章也非常的不错http://www.gwylab.com/note-vae.htmlhttp://www.gwylab.com/note-vae.html
AE就是自动编码器，VAE是在AE的基础上来的，所以这里先介绍一下AE。 先看一下下面两个图：
如上面两个图所示，AE主要有encoder和decoder两个部分组成，其中encoder和decoder都是神经网络。其中encoder负责将高维输入转换为低维的code，decoder负责将低维的code转换为高维的输入，其中输出要跟输入尽可能的相似，最好是能完全一样。
看第二个图的中间部分，就代表了code，我们经过训练，最终得到了一个6维的code，且每个维度有一个具体的值代表。因为AE就是想生成跟输入相同的图像，所以AE是不会产生新的图像的，就像上面第二个图，最后生成的这个大叔，不会是一个闭嘴不笑，红头发的大叔。
再举一个例子，如下图：
如上图，经过训练我们的AE已经能还原这两张图片。接下来，我们在code空间上，两张图片的编码点中间处取一点，然后将这一点交给解码器，我们希望新的生成图片是一张清晰的图片（类似3/4全月的样子）。但是，实际的结果是，生成图片是模糊且无法辨认的乱码图。
为什么我们在code的中间取一点，无法生成3/4月亮的图呢？？？？
还是因为，AE就是要生成跟输入尽可能相同的图，类似与压缩与解压缩的过程，你想让AE生成一个相似但全新的图，它是做不到的。
那如果我就是想生成3/4月亮的图怎么办？有一种方法，我们可以引入噪声，使得图片的编码区域得到扩大，从而掩盖掉失真的空白编码点。如下图所示：
如上图所示，现在在给两张图片编码的时候加上一点噪音，使得每张图片的编码点出现在绿色箭头所示范围内，于是在训练模型的时候，绿色箭头范围内的点都有可能被采样到，这样解码器在训练时会把绿色范围内的点都尽可能还原成和原图相似的图片。然后我们可以关注之前那个失真点，现在它处于全月图和半月图编码的交界上，于是解码器希望它既要尽量相似于全月图，又要尽量相似于半月图，于是它的还原结果就是两种图的折中（3/4全月图）。
由此我们发现，给编码器增添一些噪音，可以有效覆盖失真区域。不过这还并不充分，因为在上图的距离训练区域很远的黄色点处，它依然不会被覆盖到，仍是个失真点。为了解决这个问题，我们可以试图把噪音无限拉长，使得对于每一个样本，它的编码会覆盖整个编码空间，不过我们得保证，在原编码附近编码的概率最高，离原编码点越远，编码概率越低。在这种情况下，图像的编码就由原先离散的编码点变成了一条连续的编码分布曲线，如下图所示。
那么上述的这种将图像编码由离散变为连续的方法，就是变分自编码的核心思想。VAE中间的code不是具体的值，而是一种分布。如下图所示：
三、VAE的基本认识 上面介绍完了AE，接着就来介绍一下VAE。VAE是从AE的基础上来的，其中我们知道，AE类似于一种压缩解压缩的过程，只能生成与输入图像尽可能一样的图像，而不会生成与输入图像相似但不同的图像，这是AE本身所限制的。在这个基础上，VAE中间的code是一个分布，从分布中采样然后输入到decoder中，VAE可以生成与输入图像相似但不同的图像。
如下图所示，为VAE的基本结构图：
如下图所示，为VAE原文中给出的VAE的图模型，从VAE的图模型我们可以看到，z是服从标准正太分布的。
如下图所示，为VAE原文中给出的VAE的结构图。其中分为左右两个部分，右边才是最终的VAE结构。右边比左边就多了一个从标准正太分布中采样的过程，称为重参数化技巧，后面会说到为什么要有这个重参数化技巧。
感觉东西有点多，一篇文章写下来比较臃肿，大家看到后面会没有兴趣，所以将VAE分为（一）、（二）两个部分去介绍，（二）会介绍如下内容：
三、VAE公式推导 四、补充说明 （二）部分是重中之重，理解了公式的推导，基本上就算彻底理解了VAE。https://blog.csdn.net/zeronose/article/details/122660359
​​​​​​​
​​​​​​​" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/48a988187cfd49d80649c9ead67f6a7f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-24T14:20:34+08:00" />
<meta property="article:modified_time" content="2022-01-24T14:20:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">变分自编码器（VAE）（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言</strong></p> 
<p><span style="color:#999aaa;">说来惭愧，VAE接触很久了，一直想把VAE好好的总结一下，一直拖到现在。</span></p> 
<p>闲话少说，关于VAE的文章网上也有不少，解释的最好最清楚的还是苏剑林老师的这篇文章<a href="https://spaces.ac.cn/archives/5253" rel="nofollow" title="文章链接">文章链接</a>，还有B站白板推导系列中关于变分推断跟变分自编码器<a class="link-info" href="https://www.bilibili.com/video/BV1aE411o7qd?spm_id_from=333.999.0.0" rel="nofollow" title="链接">链接</a>。大家可以多看看这两个资料，或者直接看我这次的总结肯定也不错的。</p> 
<hr> 
<p><strong>一、理解VAE前需要了解的知识点</strong></p> 
<h3><a id="1_27"></a>1.极大似然估计</h3> 
<p><span style="color:#999aaa;">关于极大似然估计可以看我这篇文章，理解极大似然估计的原理，因为VAE中也用到了极大似然估计的原理。<a class="link-info has-card" href="https://blog.csdn.net/zeronose/article/details/122437636?spm=1001.2014.3001.5501" title="https://blog.csdn.net/zeronose/article/details/122437636?spm=1001.2014.3001.5501"><span class="link-card-box"><span class="link-title">https://blog.csdn.net/zeronose/article/details/122437636?spm=1001.2014.3001.5501</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/59/bd/ZZOyiDtl_o.png">https://blog.csdn.net/zeronose/article/details/122437636?spm=1001.2014.3001.5501</span></span></a></span></p> 
<h3><a id="2_45"></a>2.高斯混合模型（GMM）</h3> 
<p><span style="color:#999aaa;">理解高斯混合模型主要是想让GMM跟VAE进行对比，更容易理解，因为GMM和VAE都属于是隐变量模型，其中都有隐变量这个概念。</span></p> 
<p><span style="color:#999aaa;">这篇之前的文章是介绍EM算法的，里面的例子就是用EM算法去解决高斯混合模型的参数估计问题。可以通过这篇文章来理解高斯混合模型。<a class="link-info has-card" href="https://blog.csdn.net/zeronose/article/details/122465732?spm=1001.2014.3001.5501" title="https://blog.csdn.net/zeronose/article/details/122465732?spm=1001.2014.3001.5501"><span class="link-card-box"><span class="link-title">https://blog.csdn.net/zeronose/article/details/122465732?spm=1001.2014.3001.5501</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/38/d3/8f8gCCcf_o.png">https://blog.csdn.net/zeronose/article/details/122465732?spm=1001.2014.3001.5501</span></span></a></span></p> 
<h3><strong>3.变分推断</strong></h3> 
<p>变分推断是想办法找到一个分布<img alt="q(z)" class="mathcode" src="https://images2.imgbox.com/0f/3e/6M5sRyy3_o.png">去逼近无法计算得出解析解的后验分布<img alt="p(z|x)" class="mathcode" src="https://images2.imgbox.com/44/c2/ZHJLW0jb_o.png">。这也是VAE中用来求解后验分布的方法。可以看B站白板推导关于变分推断部分<a class="link-info has-card" href="https://www.bilibili.com/video/BV1aE411o7qd?spm_id_from=333.999.0.0" rel="nofollow" title="https://www.bilibili.com/video/BV1aE411o7qd?spm_id_from=333.999.0.0"><span class="link-card-box"><span class="link-title">https://www.bilibili.com/video/BV1aE411o7qd?spm_id_from=333.999.0.0</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/1d/02/YgC0uNJd_o.png">https://www.bilibili.com/video/BV1aE411o7qd?spm_id_from=333.999.0.0</span></span></a></p> 
<p></p> 
<h2>二、AE的基本认识</h2> 
<p>这里的图全部来源于网络，侵权必删，其中下面关于月亮的一部分，来源于这篇文章，侵权必删。</p> 
<p>这篇文章也非常的不错<a class="link-info has-card" href="http://www.gwylab.com/note-vae.html" rel="nofollow" title="http://www.gwylab.com/note-vae.html"><span class="link-card-box"><span class="link-title">http://www.gwylab.com/note-vae.html</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/3b/be/rGIINf89_o.png">http://www.gwylab.com/note-vae.html</span></span></a></p> 
<p>AE就是自动编码器，VAE是在AE的基础上来的，所以这里先介绍一下AE。 </p> 
<p>先看一下下面两个图：</p> 
<p><img alt="" height="604" src="https://images2.imgbox.com/62/d8/cQx3Yrb4_o.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="475" src="https://images2.imgbox.com/72/09/XAN8JE19_o.png" width="1200"></p> 
<p>如上面两个图所示，AE主要有encoder和decoder两个部分组成，其中encoder和decoder都是神经网络。其中encoder负责将高维输入转换为低维的code，decoder负责将低维的code转换为高维的输入，其中输出要跟输入尽可能的相似，最好是能完全一样。</p> 
<p>看第二个图的中间部分，就代表了code，我们经过训练，最终得到了一个6维的code，且每个维度有一个具体的值代表。因为AE就是想生成跟输入相同的图像，所以<strong>AE是不会产生新的图像的</strong>，就像上面第二个图，最后生成的这个大叔，不会是一个闭嘴不笑，红头发的大叔。</p> 
<p>再举一个例子，如下图：</p> 
<p><img alt="" height="477" src="https://images2.imgbox.com/f6/5f/savnGB6F_o.png" width="538"></p> 
<p>如上图，经过训练我们的AE已经能还原这两张图片。接下来，我们在code空间上，两张图片的编码点中间处取一点，然后将这一点交给解码器，我们希望新的生成图片是一张清晰的图片（类似3/4全月的样子）。但是，实际的结果是，生成图片是模糊且无法辨认的乱码图。</p> 
<p><strong>为什么我们在code的中间取一点，无法生成3/4月亮的图呢？？？？</strong></p> 
<p>还是因为，AE就是要生成跟输入尽可能相同的图，类似与压缩与解压缩的过程，你想让AE生成一个相似但全新的图，它是做不到的。</p> 
<p>那如果我就是想生成3/4月亮的图怎么办？有一种方法，我们可以引入噪声，使得图片的编码区域得到扩大，从而掩盖掉失真的空白编码点。如下图所示：</p> 
<p><img alt="" height="494" src="https://images2.imgbox.com/ec/b3/WkZPG8gP_o.png" width="428"></p> 
<p>如上图所示，现在在给两张图片编码的时候加上一点噪音，使得每张图片的编码点出现在绿色箭头所示范围内，于是在训练模型的时候，绿色箭头范围内的点都有可能被采样到，这样解码器在训练时会把绿色范围内的点都尽可能还原成和原图相似的图片。然后我们可以关注之前那个失真点，现在它处于全月图和半月图编码的交界上，于是解码器希望它既要尽量相似于全月图，又要尽量相似于半月图，于是它的还原结果就是两种图的折中（3/4全月图）。</p> 
<p>由此我们发现，给编码器增添一些噪音，可以有效覆盖失真区域。不过这还并不充分，因为在上图的距离训练区域很远的黄色点处，它依然不会被覆盖到，仍是个失真点。为了解决这个问题，我们可以试图把噪音无限拉长，使得对于每一个样本，它的编码会覆盖整个编码空间，不过我们得保证，在原编码附近编码的概率最高，离原编码点越远，编码概率越低。在这种情况下，<strong>图像的编码就由原先离散的编码点变成了一条连续的编码分布曲线</strong>，如下图所示。</p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/e7/4b/5p9itd9r_o.png" width="576"></p> 
<p>那么上述的这种将图像编码由离散变为连续的方法，就是变分自编码的核心思想。VAE中间的code不是具体的值，而是一种分布。如下图所示：</p> 
<p><img alt="" height="688" src="https://images2.imgbox.com/8b/b2/uPBTTIZf_o.png" width="1200"></p> 
<h2>三、VAE的基本认识</h2> 
<p>上面介绍完了AE，接着就来介绍一下VAE。VAE是从AE的基础上来的，其中我们知道，<strong>AE类似于一种压缩解压缩的过程</strong>，只能生成与输入图像尽可能一样的图像，而<strong>不会生成与输入图像相似但不同的图像</strong>，这是AE本身所限制的。在这个基础上，VAE中间的code是一个分布，从分布中采样然后输入到decoder中，<strong>VAE可以生成与输入图像相似但不同的图像</strong>。</p> 
<p>如下图所示，为VAE的基本结构图：</p> 
<p><img alt="" height="382" src="https://images2.imgbox.com/64/d3/KHbCj4rl_o.png" width="749"></p> 
<p>如下图所示，为<strong>VAE原文</strong>中给出的VAE的图模型，从VAE的图模型我们可以看到，<strong>z是服从标准正太分布的</strong>。</p> 
<p><img alt="" height="478" src="https://images2.imgbox.com/70/a0/4frb4Em1_o.png" width="621"></p> 
<p>如下图所示，为<strong>VAE原文</strong>中给出的VAE的结构图。其中分为左右两个部分，右边才是最终的VAE结构。右边比左边就多了一个从标准正太分布中采样的过程，称为<strong>重参数化技巧，</strong>后面会说到为什么要有这个重参数化技巧。</p> 
<p><img alt="" height="597" src="https://images2.imgbox.com/b6/49/it15DhTK_o.png" width="1161"></p> 
<p>感觉东西有点多，一篇文章写下来比较臃肿，大家看到后面会没有兴趣，所以将VAE分为（一）、（二）两个部分去介绍，（二）会介绍如下内容：</p> 
<h2>三、VAE公式推导</h2> 
<h2>四、补充说明</h2> 
<p> <strong>（二）部分是重中之重，理解了公式的推导，基本上就算彻底理解了VAE。<a class="link-info" href="https://blog.csdn.net/zeronose/article/details/122660359" title="https://blog.csdn.net/zeronose/article/details/122660359">https://blog.csdn.net/zeronose/article/details/122660359</a></strong></p> 
<p><strong>​​​​​​​</strong></p> 
<p><strong>​​​​​​​</strong></p> 
<h2><a id="_63"></a></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7116226f9b6daa1cf7f71010dafb690/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">5个 VueUse 库函数，让你工作效率翻倍(收藏！)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e055f35b1d0e4098dcbe0673cae872b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nacos 服务注册 管理列表中没有注册</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>