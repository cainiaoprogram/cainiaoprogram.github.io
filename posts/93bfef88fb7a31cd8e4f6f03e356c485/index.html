<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算几何学（工程版） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算几何学（工程版）" />
<meta property="og:description" content="昨天写了计算几何学的东西，今天主要是工程化一下，工程借鉴B站up主
【自动驾驶】自动驾驶planning方向中常用的计算几何学知识 01_哔哩哔哩_bilibili
#pragma once #include &lt;cmath&gt; #include &lt;iostream&gt; class Point{ public: Point() = default; Point(double x_in, double y_in) : x(x_in), y(y_in) {} Point operator &#43; (const Point&amp; p) const{ return {x &#43; p.x, y &#43; p.y}; } Point operator - (const Point&amp; p) const{ return {x - p.x, y - p.y}; } Point operator*(double k)const { return {x * k, y * k}; } friend std::ostream &amp;operator &lt;&lt; (std::ostream &amp;out, const Point &amp;p){ out &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/93bfef88fb7a31cd8e4f6f03e356c485/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T21:24:31+08:00" />
<meta property="article:modified_time" content="2024-01-09T21:24:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算几何学（工程版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>昨天写了计算几何学的东西，今天主要是工程化一下，工程借鉴B站up主</p> 
<p><a href="https://www.bilibili.com/video/BV1D34y1N7dp/?spm_id_from=333.999.0.0" rel="nofollow" title="【自动驾驶】自动驾驶planning方向中常用的计算几何学知识 01_哔哩哔哩_bilibili">【自动驾驶】自动驾驶planning方向中常用的计算几何学知识 01_哔哩哔哩_bilibili</a></p> 
<pre><code class="hljs">#pragma once

#include &lt;cmath&gt;
#include &lt;iostream&gt;

class Point{
public:
    Point() = default;
    Point(double x_in, double y_in) : x(x_in), y(y_in) {}

    Point operator + (const Point&amp; p) const{
        return {x + p.x, y + p.y};
    }
    Point operator - (const Point&amp; p) const{
        return {x - p.x, y - p.y};
    }
    Point operator*(double k)const {
        return {x * k, y * k};
    }

    friend std::ostream &amp;operator &lt;&lt; (std::ostream &amp;out, const Point &amp;p){
        out &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")";
        return out;
    }

    double DistanceTo(const Point&amp; p) const{
        double dx = x - p.x;
        double dy = y - p.y;
        return std::sqrt(dx * dx + dy * dy);
    }

    double modulus() const{
        return sqrt(x * x + y * y);
    }

    double x;
    double y;
};

class Segment{
public:
    Segment() = default;
    Segment(Point start_in, Point end_in) : start(start_in), end(end_in), direction(end - start) {}

    Segment &amp;operator = (const Segment &amp;s){
        start = s.start;
        end = s.end;
        return *this;
    }
    Segment operator + (const Segment&amp; rhs)const {
        return {start + rhs.start, end + rhs.end};
    }
    Segment operator - (const Segment&amp; rhs)const {
        return {start - rhs.start, end - rhs.end};
    }

    double Length() const{
        return direction.modulus();
    }

    Point unit_direction() const{
        double len = Length();
        if (len != 0) {
            return {direction.x / len, direction.y / len};
        } else {
            // Handle the case where the length is zero (avoid division by zero).
            throw std::runtime_error("Cannot calculate unit direction for a segment with zero length.");
        }
    }

    Point start;
    Point end;
    Point direction;
};

class Line{
public:
    Line() = default;
    Line(Point p1_in, Point p2_in) : p1(p1_in), p2(p2_in), direction(p2_in - p1_in) {}

    Point p1;
    Point p2;
    Point direction;
};
</code></pre> 
<pre><code class="hljs">#pragma once

#include "Geometry.h"
#include "utils.h"

double ComputeProjectionLength(const Point&amp; p, const Segment&amp; segement){
    const auto&amp; p1p = p - segement.start;
    return DotProduct(p1p, segement.unit_direction());
}

Point ComputeProjection(const Point&amp; p, const Segment&amp; segment){
    double projection_length = ComputeProjectionLength(p, segment);
    return segment.start + segment.unit_direction() * projection_length;
}
</code></pre> 
<pre><code class="hljs">#pragma once

#include "Geometry.h"
#include "utils.h"

// Get distance between point p1 and point p2.
double GetDistance(const Point&amp; p1,  const Point&amp; p2){
    return p1.DistanceTo(p2);
}

// Get distance between point p and a straight line.
double GetDistance(const Point&amp; p, const Line&amp; line){
    Segment p1p2(line.p1, line.p2);
    Segment p1p(line.p1, p);
    return std::abs(CrossProduct(p1p2.direction, p1p.direction)) / p1p2.Length();
}

// Get distance between point p and segment(p1,p2).
double GetDistance(const Point&amp; p, const Segment&amp; segment){
    Segment p1p(segment.start, p);
    Segment p2p(segment.end, p);
    const auto c1 = DotProduct(p1p.direction, segment.direction);
    const auto c2 = DotProduct(p2p.direction, segment.direction);
    if(c1 &lt;= 0){
        //distance(p,segment)=distacne(p1,p).
        return GetDistance(segment.start, p);
    }
    if(c2 &gt;= 0){
        //distance(p,segment)=distacne(p2,p).
        return GetDistance(segment.end, p);
    }
    return std::abs(CrossProduct(segment.direction, p1p.direction)) / segment.Length();
}</code></pre> 
<pre><code class="hljs">#pragma once

#include &lt;iostream&gt;
#include "Geometry.h"

// Calculates dot product.
double DotProduct(const Point&amp; p1, const Point&amp; p2){
    return p1.x * p2.x + p1.y * p2.y;
}

// Calculates cross product.
double CrossProduct(const Point&amp; p1, const Point&amp; p2) {
    return p1.x * p2.y - p2.x * p1.y;
}</code></pre> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include "Geometry.h"
#include "Projection.h"
#include "Distance.h"

int main(){
    Point point(3, 4);
    Segment segment(Point(0.0, 0.0), Point(10.0, 0.0));
    Point projection = ComputeProjection(point, segment);
    std::cout &lt;&lt; "projection: " &lt;&lt; projection &lt;&lt; std::endl;

    Point p1(1, 1);
    Point p2(3, 5);
    std::cout &lt;&lt; "Distance between p1 and p2: "
              &lt;&lt; GetDistance(p1, p2) &lt;&lt; std::endl;

    Line line(Point(0, 0), Point(10, 0));
    Point p(3, 4);
    std::cout &lt;&lt; "Distance between p and line: "
              &lt;&lt; GetDistance(p, line) &lt;&lt; std::endl; 

    Segment seg(Point(5, 5), Point(9, 6));
    std::cout &lt;&lt; "Distance between p and segment: "
              &lt;&lt; GetDistance(p, seg) &lt;&lt; std::endl;
    return 0;
}</code></pre> 
<p></p> 
<p>TODO</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42f006099fd71c6dacf035a15ac60a8e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【UBUNTU】随手记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a461abc86c530bbf37d20172742ad08a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">keil5调试问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>