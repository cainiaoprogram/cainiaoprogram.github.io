<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hystrix的线程池隔离和信号量隔离 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hystrix的线程池隔离和信号量隔离" />
<meta property="og:description" content="信号量的隔离：
it executes on the calling thread and concurrent requests are limited by the semaphore count.
每次调用线程，当前请求通过计数信号量进行限制，当信号大于了最大请求数（maxConcurrentRequests）时，进行限制，调用fallback接口快速返回。
最重要的是，信号量的调用是同步的，也就是说，每次调用都得阻塞调用方的线程，直到结果返回。这样就导致了无法对访问做超时（只能依靠调用协议超时，无法主动释放）
官网对信号量隔离的描述建议
Generally the only time you should use semaphore isolation for HystrixCommands is when the call is so high volume (hundreds per second, per instance) that the overhead of separate threads is too high; this typically only applies to non-network calls.
隔离的细粒度太高，数百个实例需要隔离，此时用线程池做隔离开销过大通常这种都是非网络调用的情况下线程池隔离:
it executes on a separate thread and concurrent requests are limited by the number of threads in the thread-pool" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3d98511e7c38f56e8082b2b5ca48ab2e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-26T19:08:48+08:00" />
<meta property="article:modified_time" content="2019-02-26T19:08:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hystrix的线程池隔离和信号量隔离</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>信号量的隔离：<br> it executes on the calling thread and concurrent requests are limited by the semaphore count.</p> 
<p>每次调用线程，当前请求通过计数信号量进行限制，当信号大于了最大请求数（maxConcurrentRequests）时，进行限制，调用fallback接口快速返回。<a id="more"></a></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/32/b7/usFZznTW_o.png"></p> 
<p>最重要的是，信号量的调用是同步的，也就是说，每次调用都得阻塞调用方的线程，直到结果返回。这样就导致了无法对访问做超时（只能依靠调用协议超时，无法主动释放）</p> 
<p>官网对信号量隔离的描述建议</p> 
<p>Generally the only time you should use semaphore isolation for HystrixCommands is when the call is so high volume (hundreds per second, per instance) that the overhead of separate threads is too high; this typically only applies to non-network calls.</p> 
<p>隔离的细粒度太高，数百个实例需要隔离，此时用线程池做隔离开销过大通常这种都是非网络调用的情况下线程池隔离:<br> it executes on a separate thread and concurrent requests are limited by the number of threads in the thread-pool<br> 通过每次都开启一个单独线程运行。它的隔离是通过线程池，即每个隔离粒度都是个线程池，互相不干扰</p> 
<p>Commands executed in threads have an extra layer of protection against latencies beyond what network timeouts can offer.<br> 线程池隔离方式，等于多了一层的保护措施，可以通过hytrix直接设置超时，超时后直接返回。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/99/92/afAYi3Q0_o.png"></p> 
<p>最后总结对比下：</p> 
<table><thead><tr><th>隔离方式</th><th>是否支持超时</th><th>是否支持熔断</th><th>隔离原理</th><th>是否是异步调用</th><th>资源消耗</th></tr></thead><tbody><tr><td>线程池隔离</td><td>支持,可直接返回</td><td>支持,当线程池到达maxSize后,再请求会触发fallback接口进行熔断</td><td>每个服务单独用线程池</td><td>可以是异步,也可以是同步。看调用的方法</td><td>大,大量线程的上下文切换，容易造成机器负载高</td></tr><tr><td>信号量隔离</td><td>不支持,如果阻塞，只能通过调用协议（如:socket超时才能返回）</td><td>支持，当信号量达到maxConcurrentRequests后。再请求会触发fallback</td><td>通过信号量的计数器</td><td>同步调用,不支持异步</td><td>小,只是个计数器</td></tr></tbody></table> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5ee7bb6513737b0c3496bdbdbfe378c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hystrix原理流程图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e7d51cbc7851e8e7e672ff91d05f906/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">五大常用算法学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>