<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>阿里面试，让我十五分钟内手写 LRU。。。 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="阿里面试，让我十五分钟内手写 LRU。。。" />
<meta property="og:description" content="点击上方“五分钟学算法”，选择“星标”公众号
重磅干货，第一时间送达
你面试的时候遇见过LRU吗？ LRU 算法，全称是Least Recently Used。
翻译过来就是最近最少使用算法。
这个算法的思想就是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。所以，当指定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。
听描述你也知道了，它是一种淘汰算法。
这个算法也是面试的一个高频考点。
有的面试官甚至要求手撸一个 LRU 算法出来。
其实我觉得吧，遇到这种情况也不要慌，你就按照自己的思路写一个出来就行。
赌一把，面试官也许自己短时间内都手撸不出来一个无 bug 的 LRU。他也只是检查几个关键点、看看你的代码风格、观察一下你的解题思路而已。
但其实大多数情况下面试场景都是这样的：
面试官：你知道 LRU 算法吗？
我：知道，翻译过来就是最近最少使用算法。其思想是(前面说过，就不复述了)......
面试官：那你能给我谈谈你有哪些方法来实现 LRU 算法呢？
这个时候问的是什么？
问的是：我们都知道这个算法的思路了，请你按照这个思路给出一个可以落地的解决方案。
不用徒手撸一个。
方案一：数组 如果之前完全没有接触过 LRU 算法，仅仅知道其思路。
第一次听就要求你给一个实现方案，那么数组的方案应该是最容易想到的。
假设我们有一个定长数组。数组中的元素都有一个标记。这个标记可以是时间戳，也可以是一个自增的数字。
我这里用自增的数字。
每放入一个元素，就把数组中已经存在的数据的标记更新一下，进行自增。当数组满了后，就将数字最大的元素删除掉。
每访问一个元素，就将被访问的元素的数字置为 0 。
这不就是 LRU 算法的一个实现方案吗？
按照这个思路，撸一份七七八八的代码出来，问题应该不大吧？
但是这一种方案的弊端也是很明显：需要不停地维护数组中元素的标记。
那么你觉得它的时间复杂度是多少？
是的，每次操作都伴随着一次遍历数组修改标记的操作，所以时间复杂度是 O(n)。
但是这个方案，面试官肯定是不会满意的。因为，这不是他心中的标准答案。
也许他都没想过：你还能给出这种方案呢？
但是它不会说出来，只会轻轻的说一句：还有其他的方案吗？
方案二：链表 于是你扣着脑壳想了想。最近最少使用，感觉是需要一个有序的结构。
我每插入一个元素的时候，就追加在数组的末尾。
等等。
我每访问一个元素，也要把被访问的元素移动到数组的末尾。
这样最近被用的一定是在最后面的，头部的就是最近最少使用的。
当指定长度被用完了之后，就把头部元素移除掉就行了。
这是个什么结构？
这不就是个链表吗？
维护一个有序单链表，越靠近链表头部的结点是越早之前访问的。
当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表。
如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表尾部。
如果此数据没在缓存链表中，怎么办？
分两种情况：
如果此时缓存未满，可直接在链表尾部插入新节点存储此数据；
如果此时缓存已满，则删除链表头部节点，再在链表尾部插入新节点。
你看，这不又是 LRU 算法的一个实现方案吗？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ce6e88102a189077298e536fb1e29a1e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-09T22:44:00+08:00" />
<meta property="article:modified_time" content="2022-09-09T22:44:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">阿里面试，让我十五分钟内手写 LRU。。。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="font-size: 16px;"> 
 <div id="js_content"> 
  <p>点击上方“<strong>五分钟学算法</strong>”，选择“星标”公众号</p> 
  <p>重磅干货，第一时间送达<img src="https://images2.imgbox.com/91/d2/ChV08FtI_o.png" width="100%" style="outline: none;"></p> 
  <p><img src="https://images2.imgbox.com/5f/9a/5QKnSjSc_o.png" style="outline: none;"></p> 
  <h3>你面试的时候遇见过LRU吗？</h3> 
  <p>LRU 算法，全称是Least Recently Used。</p> 
  <p>翻译过来就是最近最少使用算法。</p> 
  <p>这个算法的思想就是：<strong>如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。所以，当指定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</strong></p> 
  <p>听描述你也知道了，它是一种淘汰算法。</p> 
  <p>这个算法也是面试的一个高频考点。</p> 
  <p>有的面试官甚至要求手撸一个 LRU 算法出来。</p> 
  <p>其实我觉得吧，遇到这种情况也不要慌，你就按照自己的思路写一个出来就行。</p> 
  <p>赌一把，面试官也许自己短时间内都手撸不出来一个无 bug 的 LRU。他也只是检查几个关键点、看看你的代码风格、观察一下你的解题思路而已。</p> 
  <p>但其实大多数情况下面试场景都是这样的：</p> 
  <p>面试官：你知道 LRU 算法吗？</p> 
  <p>我：知道，翻译过来就是最近最少使用算法。其思想是(前面说过，就不复述了)......</p> 
  <p>面试官：那你能给我谈谈你有哪些方法来实现 LRU 算法呢？</p> 
  <p>这个时候问的是什么？</p> 
  <p>问的是：我们都知道这个算法的思路了，请你按照这个思路给出一个可以落地的解决方案。</p> 
  <p>不用徒手撸一个。</p> 
  <div style="text-align: center;"> 
   <img src="https://images2.imgbox.com/51/df/PxMi1hWz_o.png" style="outline: none;"> 
  </div> 
  <h3>方案一：数组</h3> 
  <p>如果之前完全没有接触过 LRU 算法，仅仅知道其思路。</p> 
  <p>第一次听就要求你给一个实现方案，那么数组的方案应该是最容易想到的。</p> 
  <p>假设我们有一个定长数组。数组中的元素都有一个标记。这个标记可以是时间戳，也可以是一个自增的数字。</p> 
  <p>我这里用自增的数字。</p> 
  <p>每放入一个元素，就把数组中已经存在的数据的标记更新一下，进行自增。当数组满了后，就将数字最大的元素删除掉。</p> 
  <p>每访问一个元素，就将被访问的元素的数字置为 0 。</p> 
  <p>这不就是 LRU 算法的一个实现方案吗？</p> 
  <p>按照这个思路，撸一份七七八八的代码出来，问题应该不大吧？</p> 
  <p><strong>但是这一种方案的弊端也是很明显：需要不停地维护数组中元素的标记。</strong></p> 
  <p>那么你觉得它的时间复杂度是多少？</p> 
  <p>是的，每次操作都伴随着一次遍历数组修改标记的操作，所以时间复杂度是 O(n)。</p> 
  <p>但是这个方案，面试官肯定是不会满意的。因为，这不是他心中的标准答案。</p> 
  <p>也许他都没想过：你还能给出这种方案呢？</p> 
  <p>但是它不会说出来，只会轻轻的说一句：还有其他的方案吗？</p> 
  <div style="text-align: center;"> 
   <img src="https://images2.imgbox.com/00/fb/SfXggYyU_o.png" style="outline: none;"> 
  </div> 
  <h3>方案二：链表</h3> 
  <p>于是你扣着脑壳想了想。最近最少使用，感觉是需要一个有序的结构。</p> 
  <p>我每插入一个元素的时候，就追加在数组的末尾。</p> 
  <p>等等。</p> 
  <p>我每访问一个元素，也要把被访问的元素移动到数组的末尾。</p> 
  <p>这样最近被用的一定是在最后面的，头部的就是最近最少使用的。</p> 
  <p>当指定长度被用完了之后，就把头部元素移除掉就行了。</p> 
  <p>这是个什么结构？</p> 
  <p>这不就是个链表吗？</p> 
  <p>维护一个有序单链表，越靠近链表头部的结点是越早之前访问的。</p> 
  <p>当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表。</p> 
  <p>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表尾部。</p> 
  <p>如果此数据没在缓存链表中，怎么办？</p> 
  <p>分两种情况：</p> 
  <blockquote> 
   <ul><li><p>如果此时缓存未满，可直接在链表尾部插入新节点存储此数据；</p></li><li><p>如果此时缓存已满，则删除链表头部节点，再在链表尾部插入新节点。</p></li></ul> 
  </blockquote> 
  <p>你看，这不又是 LRU 算法的一个实现方案吗？</p> 
  <p>按照这个思路，撸一份八九不离十的代码出来，问题应该不大吧？</p> 
  <p>这个方案比数组的方案好在哪里呢？</p> 
  <p>我觉得就是莫名其妙的高级感，就是看起来就比数组高级了一点。</p> 
  <div style="text-align: center;"> 
   <img src="https://images2.imgbox.com/a0/a0/OUqswkUa_o.png" style="outline: none;"> 
  </div> 
  <p>从时间复杂度的角度看，因为链表插入、查询的时候都要遍历链表，查看数据是否存在，所以它还是O(n)。</p> 
  <p>总之，这也不是面试官想要的答案。</p> 
  <p>当你回答出这个方案之后，面试官也许会说：<strong>你能不能给我一个查询和插入的时间复杂度都是O(1)的解决方案？</strong></p> 
  <p>到这里，如果第一次遇到这题，就得看天分了。</p> 
  <p>有一说一，如果我之前完全没有接触过 LRU 算法，我可以非常自信的说：</p> 
  <div style="text-align: center;"> 
   <img src="https://images2.imgbox.com/f7/bd/FZNseV9m_o.png" style="outline: none;"> 
  </div> 
  <h3>方案三：双向链表+哈希表</h3> 
  <p>如果我们想要查询和插入的时间复杂度都是 O(1)，那么我们需要一个满足下面三个条件的数据结构：</p> 
  <blockquote> 
   <ul><li><p>1.首先这个数据结构必须是有时序的，以区分最近使用的和很久没有使用的数据，当容量满了之后，要删除最久未使用的那个元素。</p></li><li><p>2.要在这个数据结构中快速找到某个 key 是否存在，并返回其对应的 value。</p></li><li><p>3.每次访问这个数据结构中的某个 key，需要将这个元素变为最近使用的。也就是说，这个数据结构要支持在任意位置快速插入和删除元素。</p></li></ul> 
  </blockquote> 
  <p>那么，你说什么样的数据结构同时符合上面的条件呢？</p> 
  <p>查找快，我们能想到哈希表。但是哈希表的数据是乱序的。</p> 
  <p>有序，我们能想到链表，插入、删除都很快，但是查询慢。</p> 
  <p><strong>所以，我们得让哈希表和链表结合一下，成长一下，形成一个新的数据结构，那就是：哈希链表，LinkedHashMap。</strong></p> 
  <div style="text-align: center;"> 
   <img src="https://images2.imgbox.com/59/e8/CAEUn5Je_o.png" style="outline: none;"> 
  </div> 
  <p>这个结构大概长这样：</p> 
  <div style="text-align: center;"> 
   <img src="https://images2.imgbox.com/a5/23/uO7EGEkO_o.png" style="outline: none;"> 
  </div> 
  <p>借助这个结构，我们再来分析一下上面的三个条件：</p> 
  <blockquote> 
   <ul><li><p>1.如果每次默认从链表尾部添加元素，那么显然越靠近尾部的元素就越是最近使用的。越靠近头部的元素就是越久未使用的。</p></li><li><p>2.对于某一个 key ，可以通过哈希表快速定位到链表中的节点，从而取得对应的 value。</p></li><li><p>3.链表显示是支持在任意位置快速插入和删除的，修改指针就行。但是单链表无非按照索引快速访问某一个位置的元素，都是需要遍历链表的，所以这里借助哈希表，可以通过 key，快速的映射到任意一个链表节点，然后进行插入和删除。</p></li></ul> 
  </blockquote> 
  <p>这才是面试官想要关于 LRU 的正确答案。</p> 
  <p>但是你以为回答到这里就结束了吗？</p> 
  <p>面试官为了确认你的掌握程度，还会追问一下。</p> 
  <p>那么请问：<strong>为什么这里要用双链表呢，单链表为什么不行？</strong></p> 
  <p>你心里一慌：我靠，这题我也背过。一时想不起来了。</p> 
  <div style="text-align: center;"> 
   <img src="https://images2.imgbox.com/61/b7/50ttCTog_o.png" style="outline: none;"> 
  </div> 
  <p>所以，别只顾着背答案，得理解。</p> 
  <p>你想啊，我们是不是涉及到删除元素的操作？</p> 
  <p>那么链表删除元素除了自己本身的指针信息，还需要什么东西？</p> 
  <p>是不是还需要前驱节点的指针？</p> 
  <p>那么我们这里要求时间复杂度是O(1)，所以怎么才能直接获取到前驱节点的指针？</p> 
  <p>这玩意是不是就得上双链表？</p> 
  <p>咦，你看在一波灵魂追问中，就得到了答案。</p> 
  <p>面试官的第二个问题又随之而来了：<strong>哈希表里面已经保存了 key ，那么链表中为什么还要存储 key 和 value 呢，只存入 value 不就行了？</strong></p> 
  <p>不会，也不要慌，你先分析一波。</p> 
  <p>刚刚我们说删除链表中的节点，需要借助双链表来实现 O(1)。</p> 
  <p>删除了链表中的节点，然后呢？</p> 
  <p>是不是还忘记了什么东西？</p> 
  <p>是不是还有一个哈希表忘记操作了？</p> 
  <p>哈希表是不是也得进行对应的删除操作？</p> 
  <p>删除哈希表需要什么东西？</p> 
  <p>是不是需要 key，才能删除对应的 value？</p> 
  <p>这个 key 从哪里来？</p> 
  <p>是不是只能从链表中的结点里面来？</p> 
  <p>如果链表中的结点，只有 value 没有 key，那么我们就无法删除哈希表的 key。那不就完犊子了吗？</p> 
  <p>又是一波灵魂追问。</p> 
  <p>所以，你现在知道答案了吗？</p> 
  <p>另外在多说一句，有的小伙伴可能会直接回答借助 LinkedHashMap 来实现。</p> 
  <p>我觉得吧，你要是实在不知道，也可以这样说。</p> 
  <p>但是，这个回答可能是面试官最不想听到的回答了。</p> 
  <p>他会觉得你投机取巧。</p> 
  <p>但是呢，实际开发中，真正要用的时候，我们还是用的 LinkedHashMap。</p> 
  <p>而且更多的实际情况是，你开发，写业务代码的时候，根本就不会用到 LRU 算法。</p> 
  <p>你说这个事情，难受不难受。</p> 
  <div style="text-align: center;"> 
   <img src="https://images2.imgbox.com/7e/99/o25ZpWeF_o.png" style="outline: none;"> 
  </div> 
  <p>好了，你以为到这里面试就结束了？</p> 
  <p>天真。</p> 
  <h3>LRU 在 MySQL 中的应用</h3> 
  <p>面试官：小伙子刚刚 LRU 回答的不错哈。要不你给我讲讲，LRU 在 MySQL 中的应用？</p> 
  <p>LRU 在 MySQL 的应用就是 Buffer Pool，也就是缓冲池。</p> 
  <p>它的目的是为了减少磁盘 IO。</p> 
  <p>缓冲池具体是干啥的，我这里就不展开说了。</p> 
  <p>你就知道它是一块连续的内存，默认大小 128M，可以进行修改。</p> 
  <p>这一块连续的内存，被划分为若干默认大小为 16KB 的页。</p> 
  <p>既然它是一个 pool，那么必然有满了的时候，怎么办？</p> 
  <p>就得移除某些页了，对吧？</p> 
  <p>那么问题就来了：移除哪些页呢？</p> 
  <p>刚刚说了，它是为了减少磁盘 IO。所以应该淘汰掉很久没有被访问过的页。</p> 
  <p>很久没有使用，这不就是 LRU 的主场吗？</p> 
  <p>但是在 MySQL 里面并不是简单的使用了 LRU 算法。</p> 
  <p>因为 MySQL 里面有一个预读功能。预读的出发点是好的，但是有可能预读到并不需要被使用的页。</p> 
  <p>这些页也被放到了链表的头部，容量不够，导致尾部元素被淘汰。</p> 
  <p>哦豁，降低命中率了，凉凉。</p> 
  <p><img src="https://images2.imgbox.com/bd/a7/4pAci97k_o.png" style="outline: none;"></p> 
  <p>还有一个场景是全表扫描的 sql，有可能直接把整个缓冲池里面的缓冲页都换了一遍，影响其他查询语句在缓冲池的命中率。</p> 
  <p>那么怎么处理这种场景呢？</p> 
  <p>把 LRU 链表分为两截，一截里面放的是热数据，一截里面放的是冷数据。</p> 
  <p>打住，不能再说了。</p> 
  <p>再说就是另外一篇文章了，点到为止。</p> 
  <p>你就了解在 MySQL 里面，LRU 是有一个变种的。</p> 
  <p>如果你不清楚，建议去学习一下哦。</p> 
  <p>只要你学的够快，你就会被卷的越慢。</p> 
  <h3>LRU 在 Redis 中的应用</h3> 
  <p>既然是内存淘汰算法，那么我们常用的 Redis 里面必然也有对应的实现。</p> 
  <p>Redis 的内存淘汰策略有如下几种：</p> 
  <blockquote> 
   <ul><li><p>noenviction：默认策略。不继续执行写请求(DEL 请求可以处理)，读请求可以继续进行。</p></li><li><p>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。没有设置过期时间的 key 不会被淘汰。</p></li><li><p>volatile-random：从已设置过期时间的数据集中随机选择数据淘汰。</p></li><li><p>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</p></li><li><p>allkeys-lru：和 volatile-lru 不同的是，这个策略要淘汰的 key 对象是全体的 key 集合。</p></li><li><p>allkeys-random：从所有数据集中随机选择数据淘汰。</p></li></ul> 
  </blockquote> 
  <p>关于 Redis 中的 LRU 算法，官网上是这样说的：</p> 
  <p><code>https://github.com/redis/redis-doc/blob/master/topics/lru-cache.md</code></p> 
  <div style="text-align: center;"> 
   <img src="https://images2.imgbox.com/04/d0/5ru0mYBy_o.png" style="outline: none;"> 
  </div> 
  <p>在 Redis 中的 LRU 算法不是严格的 LRU 算法。</p> 
  <p>Redis 会尝试执行一个近似的LRU算法，通过采样一小部分键，然后在采样键中回收最适合的那个，也就是最久没有被访问的那个(with the oldest access time)。</p> 
  <p>然而，从 Redis 3.0 开始，改善了算法的性能，使得更接近于真实的 LRU 算法。做法就是维护了一个回收候选键池。</p> 
  <p>Redis 的 LRU 算法有一个非常重要的点就是你可以通过修改下面这个参数的配置，自己调整算法的精度。</p> 
  <p><code>maxmemory-samples 5</code></p> 
  <p>而上面截图中，我认为最重要的一句话也已经标志出来了：</p> 
  <p><code>The reason why Redis does not use a true LRU implementation is because it costs more memory.</code></p> 
  <p>Redis 没有使用真实的 LRU 算法的原因是因为这会消耗更多的内存。</p> 
  <p>然后官网上给了一个随机 LRU 算法和严格 LRU 算法的对比图：</p> 
  <p><img src="https://images2.imgbox.com/df/34/VZRDuHFH_o.png" style="outline: none;"></p> 对于这个图官网是这样说的： 
  <div style="text-align: center;"> 
   <img src="https://images2.imgbox.com/6c/bd/oUmf73KB_o.png" style="outline: none;"> 
  </div> 
  <p>你可以从图中看到三种不同的小圆点形成的三个不同的带：</p> 
  <blockquote> 
   <ul><li><p>浅灰色带是被回收(被 LRU 算法淘汰)的对象</p></li><li><p>灰色带是没有被回收的对象</p></li><li><p>绿色带是新添加的对象</p></li></ul> 
  </blockquote> 
  <p>由于 Redis 3.0 对 LRU 算法进行了改进，增加了淘汰池。</p> 
  <p>所以你可以看到，同样使用 5 个采样点，Redis 3.0 表现得比 Redis 2.8 要好。</p> 
  <p>同时可以看出，在 Redis 3.0 中使用 10 为采样大小，近似值已经非常接近理论性能。</p> 
  <p>写到这里我突然想起了另外一个面试题。</p> 
  <p><strong>数据库中有 3000w 的数据，而 Redis 中只有 100w 数据，如何保证 Redis 中存放的都是热点数据？</strong></p> 
  <p>这个题你说它的考点是什么？</p> 
  <p>考的就是淘汰策略呀，同志们，只是方式比较隐晦而已。</p> 
  <p>我们先指定淘汰策略为 allkeys-lru 或者 volatile-lru，然后再计算一下 100w 数据大概占用多少内存，根据算出来的内存，限定 Redis 占用的内存。</p> 
  <p>接下来的，就交给 Redis 的淘汰策略了。</p> 
  <p>搞定。</p> 
  <hr> 
  <h4><strong>推荐阅读</strong></h4> 
  <p>•   <a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg%3D%3D&amp;chksm=fa0e75efcd79fcf9c65ebb5070122b9705e18cb1c46b06c5eb3e299520ed4a25e327bc07bb4b&amp;idx=2&amp;mid=2247490158&amp;scene=21&amp;sn=12e587a361f0df072d2dc164c219a61e#wechat_redirect" rel="noopener">吴师兄实名吐槽 LeetCode 上的一道题目。。。</a>•   <a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg%3D%3D&amp;chksm=fa0e75aecd79fcb8b5f932c7ba5ed7a9e34a6c99f20bc129cef33774167d668e8745755d02ad&amp;idx=1&amp;mid=2247490095&amp;scene=21&amp;sn=baa0379b1ca62db17327a2cb825a1b24#wechat_redirect" rel="noopener">面试字节跳动时，我竟然遇到了原题……</a>•   <a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg%3D%3D&amp;chksm=fa0d87aacd7a0ebc3ada34a076d1fa3943ee24097966257132b1042b7a3e4debedc78f38c8cf&amp;idx=1&amp;mid=2247493675&amp;scene=21&amp;sn=6b501ef2032ab911f0a3519eb7397017#wechat_redirect" rel="noopener">计算机专业的学生怎样练习编程才能把编程学精通？</a>•   <a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg%3D%3D&amp;chksm=fa0e759ccd79fc8a73c77eacfd7c8b1391b08864e2e13fdf5a6e41e218a499d5a87ee12e4e6a&amp;idx=2&amp;mid=2247490077&amp;scene=21&amp;sn=56c52b385c98c7f0ad33c2621da101eb#wechat_redirect" rel="noopener">为什么 MySQL 使用 B+ 树</a>•   <a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg%3D%3D&amp;chksm=fa0e767dcd79ff6b2733dd8905f188afb19eb400d5e644f5b5127f909ee7c3583786031f9c20&amp;idx=2&amp;mid=2247490044&amp;scene=21&amp;sn=bb3610dfedbb2e0c017c3ff3d5e4684b#wechat_redirect" rel="noopener">一道简简单单的字节跳动算法面试题</a></p> 
  <hr> 
  <p>欢迎关注我的公众号“<strong>五分钟学算法</strong>”，如果喜欢，麻烦点一下“<strong>在看</strong>”，点击左下方阅读原文，获取谷歌师兄的算法刷题笔记。</p> 
  <div style="text-align: center;"> 
   <img src="https://images2.imgbox.com/e4/09/KNHJrr51_o.png" style="outline: none;"> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f17abc4703a3df2cdfa1d9aff2c4ce6b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Prometheus TSDB (Part 3): Memory Mapping of Head Chunks from Disk</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3a36c22cd9170797f702fd29e727fefa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">和微信大佬聊了一夜，他告诉我为什么指针被誉为 C 语言灵魂？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>