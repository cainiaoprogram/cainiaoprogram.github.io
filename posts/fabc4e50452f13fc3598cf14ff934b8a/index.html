<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux内存映射 mmap munmap - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux内存映射 mmap munmap" />
<meta property="og:description" content="我之前接触过windows下的内存映射文件，当时接触那个主要是要用它来实现程序crash之后的现场恢复。能恢复部分需要恢复部分内存的数据，这个时候内存映射文件就体现了作用，将需要的内存数据放到映射文件上，这样就可以实现了部分内存的持久化了，当然性能也是有很大的损失的。
现在有一个需求，需要linux的进程在遇到突发意外的时候能够恢复现场，读取之前的内存，这样意外重启之后能够让用户最小的损失体验。这种需求到我手上的时候，我自然想到了以前我在windows下的积累的经验，肯定有对应的内存映射来处理，我网上找了一下，自然有一个mmap来实现我所说的。一下我官网翻译了一点，并且加上了自己的理解总结了mmap的东西，作为马上要开展的工作的准备，具体能不能实现我也不太清楚
Name mmap 的英文名是map files or devices into memeory
英文名很好的解释了他的含义，比中文名更好的理解，他是将文件映射到内存上，我们可以读写内存一样来读写这个文件
定义 #include &lt;sys/mman.h&gt; void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);//用来 int munmap(void *addr, size_t length); mmap() 该函数可以从创建进程的的虚拟内存中创建一个映射。 参数： addr 指定我从虚拟内存中创建映射的其实地址，使用的时候一般设置成NULL length 指定我创建内存映射的内存长度 prot 这个指定我创建内存映射使用进程的对该内存的权限，可以有多个权限。PROT_EXEC，PROT_READ，PROT_ERITE以及PROT_NONE意思很简单，对应的执行，读，写权限。这个模式权限不能跟你对应的文件相冲突，如果这边配置可写，但是打开的文件是不可写，就会出现问题 flag 指定映射对象的类型，有很多含义。这个文件主要用来设置该映射文件的所属进程，以及其余进程打开这个文件的权限设定 例如WAP_SHARED 当进程对这个映射区域写入数据会复制到文件内，并且其他进程可以读取修改的数据，当然这个是我需要的。 fd 这个指定我内存映射关联的物理文件，一般是一个文件打开的句柄，fopen文件的时候的返回值。 offset 被映射文件的偏移值，这个可以直接填0 返回值 如果成功，mmap返回一个指向已经映射的内存区域首地址。如果错误返回MAP_FAILED（(void*)-1），错误可以通过errno来查询错误。 应用场景 目的：内存的持久化 现场环境：一个比较大map需要内存持久化，map里面有指针。直接拷贝内存不可行。并且该map命中率较高，更新频繁，但是保持定时更新。持久化村是内存不需要实时持久化。 计划实现： 1.创建映射文件 进程内创建映射文件，并且保持可读写，并且落地到相关文件中，独立该文件到IO操作并不大的盘符 2.实现 启动定时器，定时器中将map内存连续化，即转换json，将json写入到内存映射中 3.启动进程 读取内存映射，并且解析，读入到map中，实现现场的恢复 官方例子 #include &lt;sys/mman.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fabc4e50452f13fc3598cf14ff934b8a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-24T17:38:21+08:00" />
<meta property="article:modified_time" content="2017-11-24T17:38:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux内存映射 mmap munmap</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>我之前接触过windows下的内存映射文件，当时接触那个主要是要用它来实现程序crash之后的现场恢复。能恢复部分需要恢复部分内存的数据，这个时候内存映射文件就体现了作用，将需要的内存数据放到映射文件上，这样就可以实现了部分内存的持久化了，当然性能也是有很大的损失的。</p> 
<p>现在有一个需求，需要linux的进程在遇到突发意外的时候能够恢复现场，读取之前的内存，这样意外重启之后能够让用户最小的损失体验。这种需求到我手上的时候，我自然想到了以前我在windows下的积累的经验，肯定有对应的内存映射来处理，我网上找了一下，自然有一个mmap来实现我所说的。一下我官网翻译了一点，并且加上了自己的理解总结了mmap的东西，作为马上要开展的工作的准备，具体能不能实现我也不太清楚</p> 
<h2>Name</h2> 
<p>mmap 的英文名是map files or devices into memeory</p> 
<p>英文名很好的解释了他的含义，比中文名更好的理解，他是将文件映射到内存上，我们可以读写内存一样来读写这个文件</p> 
<h2>定义</h2> 
<div>
  #include &lt;sys/mman.h&gt; 
 <br> void *mmap(void *addr, size_t length, int prot, int flags, 
 <br> 
 <span style="white-space:pre"></span>  int fd, off_t offset);//用来 
 <br> int munmap(void *addr, size_t length); 
</div> 
<div>
  mmap() 该函数可以从创建进程的的虚拟内存中创建一个映射。 
</div> 
<div>
  参数： 
</div> 
<div>
  addr 指定我从虚拟内存中创建映射的其实地址，使用的时候一般设置成NULL 
</div> 
<div>
  length 指定我创建内存映射的内存长度 
</div> 
<div>
  prot 这个指定我创建内存映射使用进程的对该内存的权限，可以有多个权限。PROT_EXEC，PROT_READ，PROT_ERITE以及PROT_NONE意思很简单，对应的执行，读，写权限。这个模式权限不能跟你对应的文件相冲突，如果这边配置可写，但是打开的文件是不可写，就会出现问题 
</div> 
<div>
  flag 指定映射对象的类型，有很多含义。这个文件主要用来设置该映射文件的所属进程，以及其余进程打开这个文件的权限设定 
</div> 
<div>
  例如WAP_SHARED 当进程对这个映射区域写入数据会复制到文件内，并且其他进程可以读取修改的数据，当然这个是我需要的。 
</div> 
<div>
  fd 这个指定我内存映射关联的物理文件，一般是一个文件打开的句柄，fopen文件的时候的返回值。 
</div> 
<div>
  offset 被映射文件的偏移值，这个可以直接填0 
</div> 
<h2>返回值</h2> 
<div>
  如果成功，mmap返回一个指向已经映射的内存区域首地址。如果错误返回MAP_FAILED（(void*)-1），错误可以通过errno来查询错误。 
</div> 
<h2>应用场景</h2> 
<div>
  目的：内存的持久化 
</div> 
<div>
  现场环境：一个比较大map需要内存持久化，map里面有指针。直接拷贝内存不可行。并且该map命中率较高，更新频繁，但是保持定时更新。持久化村是内存不需要实时持久化。 
</div> 
<div>
  计划实现： 
</div> 
<h3>1.创建映射文件</h3> 
<div>
  进程内创建映射文件，并且保持可读写，并且落地到相关文件中，独立该文件到IO操作并不大的盘符 
</div> 
<h3>2.实现</h3> 
<div>
  启动定时器，定时器中将map内存连续化，即转换json，将json写入到内存映射中 
</div> 
<h3>3.启动进程</h3> 
<div>
  读取内存映射，并且解析，读入到map中，实现现场的恢复 
</div> 
<div> 
 <br> 
</div> 
<h2>官方例子</h2> 
<div>
   #include &lt;sys/mman.h&gt; 
 <br>        #include &lt;sys/stat.h&gt; 
 <br>        #include &lt;fcntl.h&gt; 
 <br>        #include &lt;stdio.h&gt; 
 <br>        #include &lt;stdlib.h&gt; 
 <br>        #include &lt;unistd.h&gt; 
 <br> 
 <br>        #define handle_error(msg) \ 
 <br>            do { perror(msg); exit(EXIT_FAILURE); } while (0) 
 <br>        int 
 <br>        main(int argc, char *argv[]) 
 <br>        { 
 <br>            char *addr; 
 <br>            int fd; 
 <br>            struct stat sb; 
 <br>            off_t offset, pa_offset; 
 <br>            size_t length; 
 <br>            ssize_t s; 
 <br>            if (argc &lt; 3 || argc &gt; 4) { 
 <br>                fprintf(stderr, "%s file offset [length]\n", argv[0]); 
 <br>                exit(EXIT_FAILURE); 
 <br>            } 
 <br>            fd = open(argv[1], O_RDONLY); 
 <br>            if (fd == -1) 
 <br>                handle_error("open"); 
 <br>            if (fstat(fd, &amp;sb) == -1)           /* To obtain file size */ 
 <br>                handle_error("fstat"); 
 <br>            offset = atoi(argv[2]); 
 <br>            pa_offset = offset &amp; ~(sysconf(_SC_PAGE_SIZE) - 1); 
 <br>                /* offset for mmap() must be page aligned */ 
 <br>            if (offset &gt;= sb.st_size) { 
 <br>                fprintf(stderr, "offset is past end of file\n"); 
 <br>                exit(EXIT_FAILURE); 
 <br>            } 
 <br>            if (argc == 4) { 
 <br>                length = atoi(argv[3]); 
 <br>                if (offset + length &gt; sb.st_size) 
 <br>                    length = sb.st_size - offset; 
 <br>                        /* Can't display bytes past end of file */ 
 <br>            } else {    /* No length arg ==&gt; display to end of file */ 
 <br>                length = sb.st_size - offset; 
 <br>            } 
 <br>            addr = mmap(NULL, length + offset - pa_offset, PROT_READ, 
 <br>                        MAP_PRIVATE, fd, pa_offset); 
 <br>            if (addr == MAP_FAILED) 
 <br>                handle_error("mmap"); 
 <br>            s = write(STDOUT_FILENO, addr + offset - pa_offset, length); 
 <br>            if (s != length) { 
 <br>                if (s == -1) 
 <br>                    handle_error("write"); 
 <br>                fprintf(stderr, "partial write"); 
 <br>                exit(EXIT_FAILURE); 
 <br>            } 
 <br>           munmap(addr, length + offset - pa_offset); 
 <br>            close(fd); 
 <br>            exit(EXIT_SUCCESS); 
 <br>        } 
 <br> 
</div> 
<div> 
 <pre style="margin-left:8px; font-family:monospace,courier; color:rgb(24,24,24); font-size:16px">
</pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/abea9d989bd008a09da8c30884b17830/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring boot-应用打包部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21603f918caf311732f8e60f2b48eee8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WIN7自定义管理员账户无法创建或使用设备</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>