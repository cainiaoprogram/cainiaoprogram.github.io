<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux MMC 驱动子系统详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux MMC 驱动子系统详解" />
<meta property="og:description" content="Linxu MMC 驱动子系统 文章目录 Linxu MMC 驱动子系统硬件关联目录说明mmc子系统的逻辑架构设备-总线-驱动模型一、MMC驱动抽象模型二、SDIO驱动抽象模型三、MMC/SDIO总线1. 总线结构体定义2. 总线注册3. 驱动注册4. 设备注册 四、MMC设备控制器（mmc host）1. 控制器结构体定义 MMC驱动注册MMC设备注册注册过程(瑞芯微MMC驱动源码)mmc卡(mmc type card)协议相关操作DTS配置参考资料 SD/SDIO/MMC 驱动是一种基于 SDMMC 和 SD SPI 主机驱动的协议级驱动程序，目前已支持 SD 存储器、SDIO 卡和 eMMC 芯片。
因为linux内核mmc子系统里面已经实现了这些协议，我们以后并不需要重新实现这些，只需要对协议有个简单的了解。
mmc是比较老的存储卡了，sd是mmc的替代者，sdio是基于sd而额外开发出的一种io接口卡。
硬件关联 CPU、MMC controller、存储设备之间的关联如下图所示，主要包括了MMC controller、总线、存储卡等内容的连接，针对控制器与设备的总线连接，主要包括时钟、数据、命令三种类型的引脚，而这些引脚中的cd引脚主要用于卡的在位检测，当mmc controller检测到该位的变化后，则会进行mmc card的注册或注销操作。
目录说明 针对mmc子系统，在代码实现上主要包括mmc core、mmc block、 mmc host这三个模块
mmc card：衔接最上层应用，主要用于实现mmc block驱动以及mmc driver即mmc层驱动（实际上我研究的源代码并没有这个目录（5.15.0-52-generic），猜测是合并到了core目录下）；而mmc core：实现mmc/sd/sdio协议，主要包括mmc 总线、sdio总线的实现、mmc device、mmc driver的注册接口、mmc host与mmc card的注册与注销接口等内容。mmc host：存放各个mmc/sd/sdio控制器的驱动代码，最终操作mmc/sd/sdio卡的部分； mmc子系统的逻辑架构 MMC子系统从上到下分为3层
块设备层(MMC card)：与Linux的块设备子系统对接，实现块设备驱动以及完成请求，如sys_open调用；通过调用core接口函数(具体如host-&gt;ops-&gt;rquest),驱动MMC core抽象出来的虚拟的card设备，如mmc、sd、tf卡，实现读写数据。
核心层(MMC core)：是不同协议和规范的实现，为MMC控制器层和块设备驱动层提供接口函数。
核心层封装了 MMC/SD 卡的命令（CMD)，例如存储卡的识别、设置、读写、识别、设置等命令。
MMC核心层由三个部分组成：MMC，SD和SDIO，分别为三类设备驱动提供接口函数；
core.c 把 MMC 卡、 SD 卡的共性抽象出来，它们的差别由 sd." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/333b31054bb4720ac5c772cd0be43fc6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-02T13:57:44+08:00" />
<meta property="article:modified_time" content="2023-03-02T13:57:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux MMC 驱动子系统详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Linxu_MMC__0"></a>Linxu MMC 驱动子系统</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Linxu_MMC__0" rel="nofollow">Linxu MMC 驱动子系统</a></li><li><ul><li><a href="#_9" rel="nofollow">硬件关联</a></li><li><a href="#_16" rel="nofollow">目录说明</a></li><li><a href="#mmc_24" rel="nofollow">mmc子系统的逻辑架构</a></li><li><a href="#_61" rel="nofollow">设备-总线-驱动模型</a></li><li><ul><li><a href="#MMC_78" rel="nofollow">一、MMC驱动抽象模型</a></li><li><a href="#SDIO_97" rel="nofollow">二、SDIO驱动抽象模型</a></li><li><a href="#MMCSDIO_103" rel="nofollow">三、MMC/SDIO总线</a></li><li><ul><li><a href="#1__107" rel="nofollow">1. 总线结构体定义</a></li><li><a href="#2__149" rel="nofollow">2. 总线注册</a></li><li><a href="#3__204" rel="nofollow">3. 驱动注册</a></li><li><a href="#4__300" rel="nofollow">4. 设备注册</a></li></ul> 
    </li><li><a href="#MMCmmc_host_479" rel="nofollow">四、MMC设备控制器（mmc host）</a></li><li><ul><li><a href="#1__481" rel="nofollow">1. 控制器结构体定义</a></li></ul> 
   </li></ul> 
   </li><li><a href="#MMC_498" rel="nofollow">MMC驱动注册</a></li><li><a href="#MMC_512" rel="nofollow">MMC设备注册</a></li><li><a href="#MMC_522" rel="nofollow">注册过程(瑞芯微MMC驱动源码)</a></li><li><a href="#mmcmmc_type_card_545" rel="nofollow">mmc卡(mmc type card)协议相关操作</a></li><li><a href="#DTS_599" rel="nofollow">DTS配置</a></li><li><a href="#_634" rel="nofollow">参考资料</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>SD/SDIO/MMC 驱动是一种基于 SDMMC 和 SD SPI 主机驱动的协议级驱动程序，目前已支持 SD 存储器、SDIO 卡和 eMMC 芯片。</p> 
<p>因为linux内核mmc子系统里面已经实现了这些协议，我们以后并不需要重新实现这些，只需要对协议有个简单的了解。</p> 
<p>mmc是比较老的存储卡了，sd是mmc的替代者，sdio是基于sd而额外开发出的一种io接口卡。</p> 
<h3><a id="_9"></a>硬件关联</h3> 
<p>CPU、MMC controller、存储设备之间的关联如下图所示，主要包括了MMC controller、总线、存储卡等内容的连接，针对控制器与设备的总线连接，主要包括时钟、数据、命令三种类型的引脚，而这些引脚中的cd引脚主要用于卡的在位检测，当mmc controller检测到该位的变化后，则会进行mmc card的注册或注销操作。</p> 
<p><img src="https://images2.imgbox.com/f7/18/DFl1XFef_o.jpg" alt="cpu mmc硬件关联图"></p> 
<h3><a id="_16"></a>目录说明</h3> 
<p>针对mmc子系统，在代码实现上主要包括mmc core、mmc block、 mmc host这三个模块</p> 
<ul><li>mmc card：衔接最上层应用，主要用于实现mmc block驱动以及mmc driver即<strong>mmc层驱动</strong>（实际上我研究的源代码并没有这个目录（5.15.0-52-generic），猜测是合并到了core目录下）；</li><li>而mmc core：实现mmc/sd/sdio协议，主要包括mmc 总线、sdio总线的实现、mmc device、mmc driver的注册接口、mmc host与mmc card的注册与注销接口等内容。</li><li>mmc host：存放各个mmc/sd/sdio<strong>控制器的驱动</strong>代码，最终操作mmc/sd/sdio卡的部分；</li></ul> 
<h3><a id="mmc_24"></a>mmc子系统的逻辑架构</h3> 
<p>MMC子系统从上到下分为3层</p> 
<ul><li> <p><strong>块设备层</strong>(MMC card)：与Linux的块设备子系统对接，实现块设备驱动以及完成请求，如sys_open调用；通过调用core接口函数(具体如host-&gt;ops-&gt;rquest),驱动MMC core抽象出来的虚拟的card设备，如mmc、sd、tf卡，实现读写数据。</p> </li><li> <p><strong>核心层</strong>(MMC core)：是不同协议和规范的实现，为MMC控制器层和块设备驱动层提供接口函数。</p> <p>核心层封装了 MMC/SD 卡的命令（CMD)，例如存储卡的识别、设置、读写、识别、设置等命令。</p> <p>MMC核心层由三个部分组成：MMC，SD和SDIO，分别为三类设备驱动提供接口函数；</p> <p>core.c 把 MMC 卡、 SD 卡的共性抽象出来，它们的差别由 sd.c 和 sd_ops.c 、 mmc.c 和 mmc_ops.c 来完成。</p> </li><li> <p><strong>控制器层</strong>(MMC host)：主机端MMC controller的驱动，依赖于平台，由struct mmc_host描述。</p> <p>围绕此结构设计了struct mmc_host_ops(访问方法)、struct mmc_ios(相关参数)、struct mmc_bus_ops(电源管理和在位检测方法)</p> </li></ul> 
<p>针对不同芯片，实现不同控制器对应的驱动代码。</p> 
<p><img src="https://images2.imgbox.com/b6/2d/5BVwsmHx_o.jpg" alt="mmc子系统框架结构图"></p> 
<p>块设备层与Linux的块设备子系统对接，实现块设备驱动以及完成请求，具体协议经过核心层的接口，最终通过控制器层完成传输，对MMC设备进行实际的操作。</p> 
<p>更详细的结构图如下，指明了个部分的相关实现文件：</p> 
<p><img src="https://images2.imgbox.com/28/78/SD9TMm9d_o.png" alt="在这里插入图片描述"></p> 
<p>mmc core指的是mmc 子系统的核心，这里的mmc表示的是mmc总线、结构、设备相关的统称，而下方文件名的mmc单指mmc卡，区别于sd卡和sdio卡。</p> 
<p>drivers/mmc/core/mmc.c（提供接口），<br> drivers/mmc/core/mmc-ops.c（提供和mmc type card协议相关的操作）</p> 
<p>在mmc core层中的bus指的是由core抽象出来的虚拟总线，而与物理卡连接的MMC bus是物理的实际总线，是和host controller直接关联的。</p> 
<h3><a id="_61"></a>设备-总线-驱动模型</h3> 
<p>针对MMC子系统而言，主要使用了系统中的两个模型：<strong>设备-总线-驱动模型</strong>、<strong>块设备驱动</strong>模型。</p> 
<p>在Linux驱动模型框架下，三者对应结构体以及MMC驱动子系统对应的实现关系如下：</p> 
<ul><li>总线 (struct bus_type) —— MMC总线（ mmc_bus )</li><li>设备(struct device) —— 被封装在platform_device下的<strong>主设备</strong> <strong>host</strong></li><li>驱动 (struct device_driver) —— 依附于MMC总线的MMC驱动( mmc_driver )</li></ul> 
<p>三者之间的关联图如下，每一个具体的总线均包括设备与驱动两部分，而每一个具体总线的所有添加的设备均链接至device下，每一个总线的所有注册的驱动均链接至drivers，而bus接口所有实现的功能也可以大致分为总线的注册、设备的注册、驱动的注册这三个部分。</p> 
<p><img src="https://images2.imgbox.com/a4/cf/6ItmM1mE_o.jpg" alt="设备-总线-驱动关联图"></p> 
<p>设备和对应的驱动必须依附于同一种总线</p> 
<h4><a id="MMC_78"></a>一、MMC驱动抽象模型</h4> 
<p>MMC驱动模型也是基于实际的硬件连接进行抽象的</p> 
<ul><li>针对通信总线，抽象出<strong>mmc_bus</strong>；</li><li>针对mmc controller，该子系统抽象为<strong>mmc_host</strong>，用于描述一个进行设备通信的控制器，提供了相应的访问接口（记为mmc_host-&gt;request）；</li><li>针对mmc、sd、tf卡具体设备，该子系统抽象为<strong>mmc_card</strong>，用于描述卡信息。mmc子系统提供年rescan接口用于mmc card的注册；</li><li>针对mmc、sd、tf，mmc子系统完成了统一的<strong>mmc driver</strong>，针对mmc总线规范以及SD规范，其已经详细的定义了一个存储卡的通信方式、通信命令，因此LINUXmmc子系统定义了mmc driver，用于和mmc、sd、tf等卡的通信，而<strong>不需要</strong>驱动开发人员来开发卡驱动。</li></ul> 
<p><img src="https://images2.imgbox.com/42/4d/p3UzweR3_o.jpg" alt="bus driver host card 关联图"></p> 
<p>特点:</p> 
<ol><li>mmc总线模型仅注册一个驱动类型，即mmc driver</li><li>一个mmc host与一个mmc card绑定</li><li>mmc card属于热插拔的设备，而mmc card的创建主要由mmc host负责探测与创建，mmc host根据卡在位检测引脚，当检测到mmc card的存在后，即创建mmc card，同时注册至mmc bus上，并完成与mmc driver的绑定操作。</li><li>host和card可以分别理解为 MMC device的两个子设备：MMC主设备和MMC从设备，其中host为集成于MMC设备内部的MMC controller，card为MMC设备内部实际的存储设备。</li></ol> 
<h4><a id="SDIO_97"></a>二、SDIO驱动抽象模型</h4> 
<p>sdio总线驱动模型和mmc类似，结构体上的区别为其driver类型为sdio_driver，并增加了sdio_func结构体变量（该结构体包含了该sdio设备相关的厂商id、设备id，同时包含了mmc_card）</p> 
<p>因sdio主要突出接口概念，其设备端可以连接wifi、gps等设备，因此其外设备驱动<strong>需要</strong>由驱动工程师自己实现，sdio驱动模块不提供对应的驱动。</p> 
<h4><a id="MMCSDIO_103"></a>三、MMC/SDIO总线</h4> 
<p>总线接口实现的功能可分为总线的注册、设备的注册、驱动的注册这三个部分。</p> 
<h5><a id="1__107"></a>1. 总线结构体定义</h5> 
<p>结构体定义位于<code>core\bus.c</code></p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">bus_type</span> mmc_bus_type <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 总线名称</span>
    <span class="token punctuation">.</span>name        <span class="token operator">=</span> <span class="token string">"mmc"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>dev_groups    <span class="token operator">=</span> mmc_dev_groups<span class="token punctuation">,</span>
    <span class="token comment">// match接口用于实现mmc card与mmc driver的匹配检测，返回值均为1；</span>
    <span class="token punctuation">.</span>match        <span class="token operator">=</span> mmc_bus_match<span class="token punctuation">,</span>  
    <span class="token comment">// 应用层通知接口,用于添加该mmc bus的uevent参数（在调用device_add时，会调用kobject_uevent向应用层发送设备添加相关的事件,而kobject_uevent会调用该device所属bus和class的uevent接口，添加需要发送到应用的event参数</span>
    <span class="token punctuation">.</span>uevent        <span class="token operator">=</span> mmc_bus_uevent<span class="token punctuation">,</span>
    <span class="token comment">// probe接口主要用于mmc card与mmc driver匹配成功后，则会调用该mmc bus的probe接口实现探测操作；</span>
    <span class="token punctuation">.</span>probe        <span class="token operator">=</span> mmc_bus_probe<span class="token punctuation">,</span>
    <span class="token comment">// remove接口主要用于mmc card与mmc driver解绑时，调用该接口，进行remove操作（对于mmc drivemmc_ops</span>
    <span class="token punctuation">.</span>shutdown    <span class="token operator">=</span> mmc_bus_shutdown<span class="token punctuation">,</span>
    <span class="token comment">// pm是电源管理相关的接口。</span>
    <span class="token punctuation">.</span>pm        <span class="token operator">=</span> <span class="token operator">&amp;</span>mmc_bus_pm_ops<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>总线匹配接口 .mmc_bus_match</strong><br> 当向linux系统总线添加设备或驱动时，总是会调用各总线对应的match匹配函数来判断驱动和设备是否匹配。</p> 
<p>此处的mmc_bus_match并没有进行匹配检测，直接返回1，表示mmc子系统实现的mmc driver可匹配所有注册至mmc bus上的mmc card</p> 
<p><strong>*sdio总线结构体</strong><br> 位于<code>sdio_bus.c</code></p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">bus_type</span> sdio_bus_type <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span>name        <span class="token operator">=</span> <span class="token string">"sdio"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>dev_groups    <span class="token operator">=</span> sdio_dev_groups<span class="token punctuation">,</span>mmc_ops
    <span class="token punctuation">.</span>match        <span class="token operator">=</span> sdio_bus_match<span class="token punctuation">,</span>  <span class="token comment">// 根据id_table来匹配</span>
    <span class="token punctuation">.</span>uevent        <span class="token operator">=</span> sdio_bus_uevent<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>probe        <span class="token operator">=</span> sdio_bus_probe<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>remove        <span class="token operator">=</span> sdio_bus_remove<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>pm        <span class="token operator">=</span> <span class="token operator">&amp;</span>sdio_bus_pm_ops<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="2__149"></a>2. 总线注册</h5> 
<p>调用入口位于<code>core/core.c</code>，通过<code>mmc_init()</code>实现。</p> 
<p><em>core/core.c</em></p> 
<pre><code class="prism language-c"><span class="token function">subsys_initcall</span><span class="token punctuation">(</span>mmc_init<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">mmc_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">// 将mmc总线注册到linux的总线系统中,管理块设备</span>
    ret <span class="token operator">=</span> <span class="token function">mmc_register_bus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 注册mmc_host_class</span>
    ret <span class="token operator">=</span> <span class="token function">mmc_register_host_class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 注册sido总线到linux的总线系统中,管理sdio接口类型的设备</span>
    ret <span class="token operator">=</span> <span class="token function">sdio_register_bus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>主要工作是：</p> 
<p>a. <code>mmc_register_bus</code>注册mmc总线，这个总线主要是为card目录里实现的mmc设备驱动层和mmc控制器实例化一个mmc(包括sd/sdio)设备对象建立的。</p> 
<p>b. <code>sdio_register_bus</code>这是sdio的部分，它比较特殊，需要额外的一条总线</p> 
<p>具体包括两个方面：</p> 
<ul><li>利用 bus_register() 注册 mmc_bus，包括mmc总线和sdio总线。对应sysfs下的 /sys/bus/mmc/ 目录。</li><li>利用 class_register() 注册 mmc_host_class 。对应sysfs下的 /sys/class/mmc_host 目录。</li></ul> 
<p><em>core/bus.c</em></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">mmc_register_bus</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 实际调用内核接口,注册总线</span>
    <span class="token keyword">return</span> <span class="token function">bus_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mmc_bus_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><em>core/sdio_bus.c</em></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">sdio_register_bus</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">bus_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sdio_bus_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="3__204"></a>3. 驱动注册</h5> 
<p>mmc_dirver的注册、注销接口是对内核函数的封装。实现将mmc_driver注册到mmc_bus总线中。</p> 
<p>调用入口位于<code>core/block.c</code>，通过<code>mmc_blk_init()</code>实现，先给出mmc设备结构体的定义：。</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">mmc_driver</span> mmc_driver <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span>drv        <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>device_register
        <span class="token punctuation">.</span>name    <span class="token operator">=</span> <span class="token string">"mmcblk"</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>pm    <span class="token operator">=</span> <span class="token operator">&amp;</span>mmc_blk_pm_ops<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>probe        <span class="token operator">=</span> mmc_blk_probe<span class="token punctuation">,</span>  <span class="token comment">// probe回调函数</span>
    <span class="token punctuation">.</span>remove        <span class="token operator">=</span> mmc_blk_remove<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>shutdown    <span class="token operator">=</span> mmc_blk_shutdown<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>入口函数：</p> 
<p><em>core/block.c</em></p> 
<pre><code class="prism language-c"><span class="token function">module_init</span><span class="token punctuation">(</span>mmc_blk_init<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">mmc_blk_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> res<span class="token punctuation">;</span>

    <span class="token comment">// 注册mmc_rpmb_bus总线</span>
    res  <span class="token operator">=</span> <span class="token function">bus_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mmc_rpmb_bus_type<span class="token punctuation">)</span><span class="token punctuation">;</span>

    res <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mmc_rpmb_devt<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_DEVICES<span class="token punctuation">,</span> <span class="token string">"rpmb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 注册块设备，申请块设备号</span>
    res <span class="token operator">=</span> <span class="token function">register_blkdev</span><span class="token punctuation">(</span>MMC_BLOCK_MAJOR<span class="token punctuation">,</span> <span class="token string">"mmc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 将mmc_driver注册到mmc_bus总线系统中</span>
    res <span class="token operator">=</span> <span class="token function">mmc_register_driver</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mmc_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><em>core/bus.c</em></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">mmc_register_driver</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    drv<span class="token operator">-&gt;</span>drv<span class="token punctuation">.</span>bus <span class="token operator">=</span> <span class="token operator">&amp;</span>mmc_bus_type<span class="token punctuation">;</span>
    <span class="token comment">// 实际调用内核接口,注册设备到总线系统</span>
    <span class="token keyword">return</span> <span class="token function">driver_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>drv<span class="token operator">-&gt;</span>drv<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用EXPORT_SYMBOL将函数以符号的方式导出给其他模块使用。</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>mmc_register_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>主要步骤包括：</p> 
<p>a. 通过 register_blkdev() 向内核注册块设备。（仅注册，初始化的其他操作在mmc_driver结构体的<strong>prob接口</strong>中完成）</p> 
<p>借助该块设备驱动模型，将mmc card与vfs（虚拟文件系统）完成了关联，即可通过系统调用借助VFS模型实现对块设备的读写访问操作。</p> 
<p>b. 调用 mmc_register_driver() 将 mmc_driver 注册到 mmc_bus 总线系统。简单封装，和大部分驱动注册方式一致。</p> 
<p><strong>*sdio驱动注册</strong><br> 这两个接口的实现与mmc_driver的实现类似，均是简单的对driver_register/driver_unregister的封装（还有设置driver需要绑定的bus_type）</p> 
<p><em>sdio_uart.c</em></p> 
<pre><code class="prism language-c"><span class="token function">module_init</span><span class="token punctuation">(</span>sdio_uart_init<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">sdio_uart_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ……</span>
    ret <span class="token operator">=</span> <span class="token function">tty_register_driver</span><span class="token punctuation">(</span>tty_drv<span class="token punctuation">)</span><span class="token punctuation">;</span>

    ret <span class="token operator">=</span> <span class="token function">sdio_register_driver</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sdio_uart_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ……</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><em>sdio_bus.c</em></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">sdio_register_driver</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sdio_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    drv<span class="token operator">-&gt;</span>drv<span class="token punctuation">.</span>name <span class="token operator">=</span> drv<span class="token operator">-&gt;</span>name<span class="token punctuation">;</span>
    drv<span class="token operator">-&gt;</span>drv<span class="token punctuation">.</span>bus <span class="token operator">=</span> <span class="token operator">&amp;</span>sdio_bus_type<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">driver_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>drv<span class="token operator">-&gt;</span>drv<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL_GPL</span><span class="token punctuation">(</span>sdio_register_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="4__300"></a>4. 设备注册</h5> 
<p>主要包括mmc card内存的申请、mmc card的注册、mmc card的注销等接口。</p> 
<p>调用入口位于实际host设备的驱动文件中，通过<code>xxx_driver</code>实现。下面以mvsdio驱动为例分析。</p> 
<p><em>host/mvsdio.c</em></p> 
<pre><code class="prism language-c"><span class="token function">module_platform_driver</span><span class="token punctuation">(</span>mvsd_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">platform_driver</span> mvsd_driver <span class="token operator">=</span> device_register<span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span>probe        <span class="token operator">=</span> mvsd_probe<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>remove        <span class="token operator">=</span> mvsd_remove<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>driver        <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">.</span>name    <span class="token operator">=</span> DRIVER_NAME<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>probe_type <span class="token operator">=</span> PROBE_PREFER_ASYNCHRONOUS<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>of_match_table <span class="token operator">=</span> mvsdio_dt_ids<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 在probe回调中调用</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mvsd_probe</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span>pdev<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ……</span>
    <span class="token comment">// 实例化一个控制器对象</span>
    mmc <span class="token operator">=</span> <span class="token function">mmc_alloc_host</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mvsd_host</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ……</span>
    mmc<span class="token operator">-&gt;</span>ops <span class="token operator">=</span> <span class="token operator">&amp;</span>mvsd_ops<span class="token punctuation">;</span>  <span class="token comment">// 控制器操作集</span>
    <span class="token comment">// ……（一系列对控制器对象的初始化工作）</span>
    ret <span class="token operator">=</span> <span class="token function">mmc_add_host</span><span class="token punctuation">(</span>mmc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ……</span>
<span class="token punctuation">}</span>

<span class="token comment">// 控制器操作集，编写控制器驱动的一个主要任务就是实现这个操作集</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">mmc_host_ops</span> mvsd_ops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span>request        <span class="token operator">=</span> mvsd_request<span class="token punctuation">,</span>  <span class="token comment">// 最终执行硬件操作的函数，参数由核心层提供，由核心层更上一层的card设备驱动层向下调用</span>
    <span class="token punctuation">.</span>get_ro            <span class="token operator">=</span> mmc_gpio_get_ro<span class="token punctuation">,</span>  <span class="token comment">// 判断是否写保护</span>
    <span class="token punctuation">.</span>set_ios        <span class="token operator">=</span> mvsd_set_ios<span class="token punctuation">,</span>  <span class="token comment">// 配置控制器的函数</span>
    <span class="token punctuation">.</span>enable_sdio_irq    <span class="token operator">=</span> mvsd_enable_sdio_irq<span class="token punctuation">,</span>  <span class="token comment">// 与sdio相关</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><em>host.c</em></p> 
<p>mmc host子系统提供了延迟队列机制，在执行mmc_alloc_host、mmc_add_host后，则完成了mmc card rescan延迟工作队列及其处理接口的创建<code>INIT_DELAYED_WORK</code></p> 
<p>若要触发mmc card rescan（即调度工作队列），则调用<strong>mmc_detect_change</strong>接口，即可触发mmc card rescan(即完成mmc_host-&gt;detect队列的调度)；</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token function">mmc_alloc_host</span><span class="token punctuation">(</span><span class="token keyword">int</span> extra<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ……</span>
    <span class="token comment">// 将mmc_rescan指定为延时工作队列的工作函数</span>
    <span class="token function">INIT_DELAYED_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>host<span class="token operator">-&gt;</span>detect<span class="token punctuation">,</span> mmc_rescan<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ……</span>
<span class="token punctuation">}</span>

<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>mmc_alloc_host<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>mmc_rescan</code>函数的大致调用流程如下，由mmc子系统通过mmc card的rescan机制，实现mmc card的自动检测及注册机制，依次完成了对sdio、sd和mmc设备的添加与移除操作。</p> 
<p>换句话说，是使用事件的触发监控机制完成了卡(mmc,sd,sdio)的热插拔处理。</p> 
<pre><code class="prism language-c">mmc_rescan<span class="token punctuation">[</span>core<span class="token punctuation">.</span>c<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">&gt;</span>
    mmc_rescan_try_freq<span class="token punctuation">[</span>core<span class="token punctuation">.</span>c<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">&gt;</span>
        mmc_attach_sdio<span class="token punctuation">[</span>sdio<span class="token punctuation">.</span>c<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">&gt;</span>
            mmc_attach_bus<span class="token punctuation">[</span>core<span class="token punctuation">.</span>c<span class="token punctuation">]</span>
            mmc_sdio_init_card<span class="token punctuation">[</span>sdio<span class="token punctuation">.</span>c<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">&gt;</span>
                mmc_alloc_card<span class="token punctuation">[</span>bus<span class="token punctuation">.</span>c<span class="token punctuation">]</span>
            sdio_init_func<span class="token punctuation">[</span>sdio<span class="token punctuation">.</span>c<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">&gt;</span>
                sdio_alloc_func<span class="token punctuation">[</span>sdio_bus<span class="token punctuation">.</span>c<span class="token punctuation">]</span>
            mmc_add_card<span class="token punctuation">[</span>bus<span class="token punctuation">.</span>c<span class="token punctuation">]</span>
            sdio_add_func<span class="token punctuation">[</span>sdio_bus<span class="token punctuation">.</span>c<span class="token punctuation">]</span>
        mmc_attach_sd<span class="token punctuation">[</span>sd<span class="token punctuation">.</span>c<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">&gt;</span>
            mmc_attach_bus<span class="token punctuation">[</span>core<span class="token punctuation">.</span>c<span class="token punctuation">]</span>
            mmc_sd_init_card<span class="token punctuation">[</span>sd<span class="token punctuation">.</span>c<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">&gt;</span>
                mmc_alloc_card<span class="token punctuation">[</span>bus<span class="token punctuation">.</span>c<span class="token punctuation">]</span>
            mmc_add_card<span class="token punctuation">[</span>bus<span class="token punctuation">.</span>c<span class="token punctuation">]</span>
        mmc_attach_mmc<span class="token punctuation">[</span>mmc<span class="token punctuation">.</span>c<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">&gt;</span>
            mmc_attach_bus<span class="token punctuation">[</span>core<span class="token punctuation">.</span>c<span class="token punctuation">]</span>
            mmc_init_card<span class="token punctuation">[</span>mmc<span class="token punctuation">.</span>c<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">&gt;</span>
                mmc_alloc_card<span class="token punctuation">[</span>bus<span class="token punctuation">.</span>c<span class="token punctuation">]</span>
            mmc_add_card<span class="token punctuation">[</span>bus<span class="token punctuation">.</span>c<span class="token punctuation">]</span>
</code></pre> 
<p>从mmc_rescan调用关系中可以看出，mmc设备注册的过程依次完成了sdio设备、sd卡和mmc卡设备的初始化。</p> 
<p><strong>A. mmc_attach_sdio()</strong><br> SDIO卡初始化的入口</p> 
<p>a. 向卡发送CMD5命令，该命令有两个作用：</p> 
<p>第一，通过判断卡是否有反馈信息来判断是否为SDIO设备<code>mmc_send_io_op_cond()</code>：</p> 
<ol><li>如果有响应，并且响应中的MP位为0，说明对应卡槽中的卡为SDIO卡，进而开始SDIO卡的初始化流程</li><li>如果命令没有响应，则说明对应卡槽的卡为SD或MMC卡，进而开始SD/MMC卡的初始化流程(sdio卡时有魄力sdio协议，sd卡使用sd协议)</li><li>如果有响应，且响应中的MP位为说明这个卡mmc_alloc_card不但是SDIO卡，同时也时SD卡，也就是所谓的combo卡，则进行combo卡的初始化流程mmc_sdio_ops)</li></ol> 
<p>第二，如果是SDIO设备，就会给host反馈电压信息，就是说告诉host，本卡所能支持的电压是多少多少。</p> 
<p>b. 设置sdio卡的总线操作集<code>mmc_attach_bus()</code>，传入struct mmc_bus_ops类型的实现mmc_sdio_ops。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">mmc_attach_bus</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span>host<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">mmc_bus_ops</span> <span class="token operator">*</span>ops<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    host<span class="token operator">-&gt;</span>bus_ops <span class="token operator">=</span> ops<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>c. host根据SDIO卡反馈回来的电压要求，给其提供合适的电压<code>mmc_select_voltage()</code></p> 
<p>d. 对sdio卡进行探测和初始化<code>mmc_sdio_init_card()</code></p> 
<p>e. 注册SDIO的各个功能模块<code>sdio_init_func()</code></p> 
<p>f. 注册SDIO卡<code>mmc_add_card()</code></p> 
<p>g. 将所有SDIO功能添加到device架构中<code>sdio_add_func()</code></p> 
<p><strong>mmc_alloc_card():</strong><br> 调用device模型对应的接口完成device类型变量的初始化，并完成mmc_card与mmc_host的绑定。</p> 
<p><strong>mmc_add_card():</strong></p> 
<ol><li>调用device_add，完成将该mmc_card注册至mmc bus上；</li><li>设置mmc_card的状态为在位状态。</li></ol> 
<p><strong>sdio func</strong><br> sdio_func的注册与注销接口对应于mmc_card的注册与注销接口。主要函数有sdio_alloc_func、sdio_add_func、sdio_remove_func、sdio_release_func（相比mmc card，多了针对acpi的配置调用）</p> 
<p><strong>B. mmc_attach_sd()</strong><br> SD卡初始化的入口</p> 
<p>a. 发送CMD41指令，（sd卡支持该指令，但mmc卡不支持，所以可以以此区分）<code>mmc_send_app_op_cond()</code></p> 
<p>b. 设置sdio卡的总线操作集<code>mmc_attach_bus()</code>，传入struct mmc_bus_ops类型的实现mmc_sd_ops。</p> 
<p>c. 设置合适的电压<code>mmc_select_voltage()</code></p> 
<p>d. 调用<code>mmc_sd_init_card()</code>（探测和初始化），获取mmc card的csd、cid，并创建mmc_card，并对mmc card进行初始化（如是否只读等信息）</p> 
<p>e.调用<code>mmc_add_card()</code>，将该mmc_card注册至mmc_bus中，该接口会调用device_register将mmc_card注册至mmc_bus上，而这即触发mmc_driver与mmc_card的绑定流程，从而调用mmc_driver-&gt;probe接口，即执行mmc block device的注册操作（待解决，没有找到device_register相关代码）。</p> 
<p><strong>c. mmc_attach_mmc()</strong><br> mmc卡初始化入口</p> 
<p>a. 发送CMD1指令<code>mmc_send_op_cond()</code></p> 
<p>b. 设置mmc卡的总线操作集<code>mmc_attach_bus()</code>，传入struct mmc_bus_ops类型的实现mmc_ops。</p> 
<p>c. 选择一个card和host都支持的最低工作电压<code>mmc_select_voltage()</code></p> 
<p>d. 初始化card使其进入工作状态<code>mmc_init_card()</code></p> 
<p>e. 为card构造对应的mmc_card并且注册到mmc_bus中<code>mmc_add_card()</code>，之后mmc_card就挂在了mmc_bus上，会和mmc_bus上的block（mmc_driver）匹配起来。相应block（mmc_driver）就会进行probe，驱动card，实现card的实际功能（也就是存储设备的功能）。会对接到块设备子系统中。</p> 
<p>上面多次提到了<strong>mmc_bus_ops</strong>结构体，这是一个定义在core/core.h中的，用于表示总线操作的结构体。</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">mmc_bus_ops</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>remove<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>detect<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pre_suspend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>suspend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>resume<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>runtime_suspend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>runtime_resume<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>alive<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>shutdown<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>hw_reset<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>sw_reset<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>cache_enabled<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flush_cache<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mmc_host</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="MMCmmc_host_479"></a>四、MMC设备控制器（mmc host）</h4> 
<h5><a id="1__481"></a>1. 控制器结构体定义</h5> 
<p>该模块最重要的数据结构为<code>mmc_host</code>，位于<code>core/host.h</code>文件，用于描述一个mmc controller</p> 
<p>而围绕着mmc controller又定义了相应的数据结构，用于描述mmc controller的各种行为（包括针对该mmc controller的访问方法抽象而来的数据结构<code>mmc_host_ops</code>、该mmc controller相关的参数抽象而来的数据结构体<code>mmc_ios</code>、针对mmc card相关的电源管理及在位检测方法抽象而来的数据结构<code>mmc_bus_ops</code>）</p> 
<p>部分成员如下：</p> 
<ul><li><code>struct device class_dev</code>:<br> host对应的device，用于借助设备模型与系统中注册的设备、class完成关联。</li><li><code>const struct mc_host_ops *ops</code>:<br> 定义本mmc_host的操作接口，包括与mmccard通信的接口request、卡检测相关的接口等。</li><li>块设备相关参数，包括段大小、块大小等。</li><li><code>u32 caps</code> <code>u32 caps2</code>:<br> 指示host支持的功能特性，包括4bit数据模式、mmc high speed mode、sd high speed mode、spi mode、8bit data、noneremovable mode（emmc mode）、cd与wp引脚的active high/low等等。</li></ul> 
<h3><a id="MMC_498"></a>MMC驱动注册</h3> 
<p>调用入口位于mmc/core/block.c,将mmc_driver注册到mmc_bus总线中.</p> 
<p>主要步骤包括：</p> 
<ul><li> <p>通过 register_blkdev() 向内核注册块设备。</p> <p>借助该块设备驱动模型，将mmc card与vfs完成了关联，即可通过系统调用借助VFS模型实现对块设备的读写访问操作。</p> </li><li> <p>调用 driver_register() 将 mmc_driver 注册到 mmc_bus 总线系统。和其他驱动注册方式一致。</p> </li></ul> 
<p>关键函数为：<code>platform_driver_register() --&gt; driver_register() --&gt; bus_add_driver()</code></p> 
<h3><a id="MMC_512"></a>MMC设备注册</h3> 
<p>每个host均有调用入口,使用moduSD/SDIO/MMC 驱动是一种基于 SDMMC 和 SD SPI 主机驱动的协议级驱动程序，目前已支持 SD 存储器、SDIO 卡和 eMMC 芯片。</p> 
<p>le_platform_driver()宏实现。</p> 
<p>驱动入口函数中将注册 platform_driver 和 platform_device ， name 均定义为 xxx_mmc 。根据驱动模型，最终会回调 xxx_mmc_driver 中的 probe() 函数： xxx_mmc_probe() 。</p> 
<p>关键函数为: <code>platform_device_add() --&gt; device_add() --&gt; bus_add_device() / bus_probe_device()</code></p> 
<h3><a id="MMC_522"></a>注册过程(瑞芯微MMC驱动源码)</h3> 
<p>设备启动时，首先向linux系统注册mmc_bus和sdio_bus两条总线,用来管理块设备和sdio接口类型的设备。同时注册mmc_host_class类</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">core</span><span class="token expression"><span class="token punctuation">.</span>c</span></span>
<span class="token function">subsys_initcall</span><span class="token punctuation">(</span>mmc_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>接着调用module_init向系统注册一条mmc_rpmb_bus总线、一个mmc块设备和mmc driver。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">block</span><span class="token expression"><span class="token punctuation">.</span>c</span></span>
<span class="token function">module_init</span><span class="token punctuation">(</span>mmc_blk_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>最后调用module_platform_driver，把mmc controler注册到platform总线，同时扫描一次挂载到mmc控制器上的设备。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">meson</span><span class="token expression"><span class="token operator">-</span>mx<span class="token operator">-</span>sdio<span class="token punctuation">.</span>c</span></span>
<span class="token function">module_platform_driver</span><span class="token punctuation">(</span>mmc_pwrseq_emmc_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="mmcmmc_type_card_545"></a>mmc卡(mmc type card)协议相关操作</h3> 
<p>mmc_ops提供了部分和mmc卡协议相关的操作。</p> 
<p><strong>mmc_go_idle</strong><br> 发送CMD0指令，GO_IDLE_STATE<br> 使mmc card进入idle state。<br> 虽然进入到了Idle State，但是上电复位过程并不一定完成了，这主要靠读取OCR的busy位来判断，而流程归结为下一步。</p> 
<p><strong>mmc_send_op_cond</strong><br> 发送CMD1指令，SEND_OP_COND<br> 这里会设置card的工作电压寄存器OCR，并且通过busy位（bit31）来判断card的上电复位过程是否完成，如果没有完成的话需要重复发送。<br> 完成之后，mmc card进入ready state。</p> 
<p><strong>mmc_all_send_cid</strong><br> 这里会发送CMD2指令，ALL_SEND_CID<br> 广播指令，使card回复对应的CID寄存器的值。在这里就相应获得了CID寄存器的值了，存储在cid中。<br> 完成之后，MMC card会进入Identification State。</p> 
<p><strong>mmc_set_relative_addr</strong><br> 发送CMD3指令，SET_RELATIVE_ADDR<br> 设置该mmc card的关联地址为card-&gt;rca，也就是0x0001<br> 完成之后，该MMC card进入standby模式。</p> 
<p><strong>mmc_send_csd</strong><br> 发送CMD9指令，MMC_SEND_CSD<br> 要求mmc card发送csd寄存器，存储到card-&gt;raw_csd中，也就是原始的csd寄存器的值。<br> 此时mmc card还是处于standby state</p> 
<p><strong>mmc_select_card &amp; mmc_deselect_cards</strong><br> 发送CMD7指令，SELECT/DESELECT CARD<br> 选择或者断开指定的car成员或者sending-data state依次来进行数据的传输</p> 
<p><strong>mmc_get_ext_csd</strong><br> 发送CMD8指令，SEND_EXT_CSD<br> 这里要求处于transfer state的card发送ext_csd寄存器，这里获取之后存放在ext_csd寄存器中<br> 这里会使card进入sending-data state，完成之后又退出到transfer state。</p> 
<p><strong>mmc_switch</strong><br> 发送CMD6命令，MMC_SWITCH<br> 用于设置ext_csd寄存器的某些bit</p> 
<p><strong>mmc_send_status</strong><br> 发送CMD13命令，MMC_SEND_STATUS<br> 要求card发送自己当前的状态寄存器</p> 
<p><strong>mmc_send_cid</strong><br> 发送CMD10命令，MMC_SEND_CID<br> 要求mmc card回复cid寄存器</p> 
<p><strong>mmc_card_sleepawake</strong><br> 发送CMD5命令，MMC_SLEEP_AWAKE<br> 使card进入或者退出sleep state，由参数决定。关于sleep state是指card的一种状态，具体参考emmc 5.1协议。</p> 
<h3><a id="DTS_599"></a>DTS配置</h3> 
<p>参考瑞芯微RK3568，配置文件位于</p> 
<pre><code class="prism language-bash">ARM：arch/arm/boot/dts/  // 主要是芯片级的配置，无需修改
ARM64：arch/arm64/boot/dts/rockchip  // 主要是板级相关的配置，可以根据实际需求修改
</code></pre> 
<p>对应文件为</p> 
<pre><code class="prism language-bash">arch<span class="token punctuation">\</span>arm64<span class="token punctuation">\</span>boot<span class="token punctuation">\</span>dts<span class="token punctuation">\</span>rockchip<span class="token punctuation">\</span>rk3568.dtsi
arch<span class="token punctuation">\</span>arm68<span class="token punctuation">\</span>boot<span class="token punctuation">\</span>dts<span class="token punctuation">\</span>rockchip<span class="token punctuation">\</span>rk3568-pinctrl.dsti
arch<span class="token punctuation">\</span>arm64<span class="token punctuation">\</span>boot<span class="token punctuation">\</span>dts<span class="token punctuation">\</span>rockchip<span class="token punctuation">\</span>rk3568-evb1-v10.dts
</code></pre> 
<p>rk3568.dtsi</p> 
<pre><code class="prism language-dtsi">    sdmmc0: mmc@fe2b0000 {
        compatible = "rockchip,rk3568-dw-mshc", "rockchip,rk3288-dw-mshc";
        reg = &lt;0x0 0xfe2b0000 0x0 0x4000&gt;;
        interrupts = &lt;GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH&gt;;
        clocks = &lt;&amp;cru HCLK_SDMMC0&gt;, &lt;&amp;cru CLK_SDMMC0&gt;,
             &lt;&amp;cru SCLK_SDMMC0_DRV&gt;, &lt;&amp;cru SCLK_SDMMC0_SAMPLE&gt;;
        clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
        fifo-depth = &lt;0x100&gt;;
        max-frequency = &lt;150000000&gt;;
        resets = &lt;&amp;cru SRST_SDMMC0&gt;;
        reset-names = "reset";
        status = "disabled";
    };
</code></pre> 
<h3><a id="_634"></a>参考资料</h3> 
<ol><li><a href="https://www.cnblogs.com/hueyxu/p/13751636.html" rel="nofollow">Linux MMC 驱动子系统</a></li><li><a href="https://www.cnblogs.com/hueyxu/p/13659262.html" rel="nofollow">Linux设备驱动模型和sysfs文件系统</a></li><li><a href="https://jerry-cheng.blog.csdn.net/article/details/104717742" rel="nofollow">LINUX MMC子系统分析之一 概述</a></li><li><a href="https://jerry-cheng.blog.csdn.net/article/details/102655073" rel="nofollow">LINUX设备驱动模型分析之一 总体概念说明</a></li><li><a href="https://jerry-cheng.blog.csdn.net/article/details/104717819?spm=1001.21device_add01.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-104717819-blog-104717742.pc_relevant_landingrelevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-104717819-blog-104717742.pc_relevant_landingrelevant&amp;utm_relevant_index=2" rel="nofollow">LINUX MMC子系统分析之二 MMC子系统驱动模型分析（包括总线、设备、驱动）</a></li><li><a href="https://jerry-cheng.blog.csdn.net/article/details/102709219" rel="nofollow">LINUX设备驱动模型分析之二 总线（BUS）接口分析</a></li><li><a href="https://jerry-cheng.blog.csdn.net/article/details/104717889" rel="nofollow">LINUX MMC子系统分析之三 MMC/SDIO总线接口分析</a></li><li><a href="https://jerry-cheng.blog.csdn.net/article/details/102768085" rel="nofollow">LINUX设备驱动模型分析之三 驱动（DRIVER）接口分析</a></li><li><a href="https://blog.csdn.net/lickylin/article/details/104718117">LINUX MMC 子系统分析之六 MMC card添加流程分析</a></li><li><a href="https://blog.csdn.net/yangguoyu8023/article/details/122554472">Linux内核4.14版本——mmc core(4)——card相关模块（mmc type card）</a></li><li><a href="https://blog.csdn.net/weixin_43245753/article/details/124461034?spm=1001.2101.3001.6650.7&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7-124461034-blog-100496004.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7-124461034-blog-100496004.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=8">Rockchip RK3588 kernel dts解析之MMC_loitawu的博客-CSDN博客</a></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a2fbae82d0222dc4684dbc1ac7357a69/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java之多线程下载网络图片</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e49bb53e775e8a7d6c06818293facdac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[C语言] 冒泡排序法 - 详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>