<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>api 接口测试工具：Postman、Apifox、Apipost、api压测(locust)、locust爬虫 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="api 接口测试工具：Postman、Apifox、Apipost、api压测(locust)、locust爬虫" />
<meta property="og:description" content="Postman：支持离线使用，未登录状态下，以及内网环境下，都可以正常进行大部分操作
Apipost：支持离线使用，未登录状态下，以及内网环境下，都可以正常进行大部分操作。
apifox：不支持离线，而且不登录没法用。
1、Postman From：https://zhuanlan.zhihu.com/p/534078123
Postman V9.16 绿色版汉化：https://www.cr173.com/soft/1497202.html
一、postman 简介 Postman 是一款功能强大的网页调试与发送网页HTTP请求的工具。有 Chrome 插件版本，也有Postman 本地应用程序版本，插件版本早已停止更新。详细了解为什么支持 Postman Chrome 应用程序已被弃用？：http://chromecj.com/web-development/2018-04/1376.html
postman 的特点 postman 只做 http协议 的接口的测试，是一种最广泛 REST 接口测试客户端软件。postman 支持 http 协议的所有请求方式，包括 get、post、head、put、delete 等。postman 支持各种额外的头部字段的添加。postman 除了可以模拟普通表单数据外，还支持文件、图片、视频等数据请求。postman 是一个接口的开发和测试的全流程支持软件。支持前端开发：mock(模拟) 测试支持后端开发：接口测试、开发接口文档支持测试：接口测试支持运维：监控功能postman 支持云服务：随时随地都能无缝对接加班。数据同步功能，家里、办公室的电脑登录同一账号，数据即可同步。团队协作，你设计的请求可以团队内的推送，交给其他人执行或继续开发。 安装 postman 官网下载 postman：https://www.postman.com/downloads/
根据自己使用系统，下载对应的平台版本，默认安装即可。
注册和登录 也可以不注册，但是有些功能不能用
第一个接口测试 百度翻译接口的实现：是一个get类型的请求：https://fanyi-api.baidu.com/api/trans/vip/translate?q=apple&amp;from=auto&amp;to=zh&amp;appid=&amp;xxxxsalt=888888&amp;sign=a9adc2d687fbacecc3b5059b9ccedc95
1）创建一个工程目录
如果没有特别的要求，只需要创建一次即可。
2）在工程目录下创建一个 collection 集合
collection 是 postman 管理接口请求的基本单位，首先就是把他创建出来。
3）创建一个接口请求（接口用例）
新建请求，重命名为baiduTest01：
4）拼装一个接口请求参数
对于一个get请求来说，需要三部分内容：
​请求地址：https://fanyi-api.baidu.com/api/trans/vip/translate
请求方式：get
请求参数（params）
5) 断言
后续细讲。
6）发送请求
点击url地址栏后面的send按钮。
老版本 postman 界面" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7643169bd4a3b389c3fd0a06ba6cdcd8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-07T19:11:58+08:00" />
<meta property="article:modified_time" content="2024-01-07T19:11:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">api 接口测试工具：Postman、Apifox、Apipost、api压测(locust)、locust爬虫</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p></p> 
<p><strong>Postman</strong>：支持离线使用，未登录状态下，以及内网环境下，都可以正常进行大部分操作<br><strong>Apipost</strong>：支持离线使用，未登录状态下，以及内网环境下，都可以正常进行大部分操作。<br><strong>apifox</strong>：<strong><span style="background-color:#ffd900;">不支持离线，而且不登录没法用</span></strong>。</p> 
<p></p> 
<p></p> 
<h2>1、Postman</h2> 
<p></p> 
<p>From：<a class="link-info" href="https://zhuanlan.zhihu.com/p/534078123" rel="nofollow" title="https://zhuanlan.zhihu.com/p/534078123">https://zhuanlan.zhihu.com/p/534078123</a><br> Postman V9.16 绿色版汉化：<a class="link-info" href="https://www.cr173.com/soft/1497202.html" rel="nofollow" title="https://www.cr173.com/soft/1497202.html">https://www.cr173.com/soft/1497202.html</a></p> 
<p></p> 
<h3 id="h_534078123_0"><strong>一、postman 简介</strong></h3> 
<p></p> 
<p>Postman 是一款功能强大的网页调试与发送网页HTTP请求的工具。有 Chrome 插件版本，也有Postman 本地应用程序版本，插件版本早已停止更新。详细了解为什么支持 Postman Chrome 应用程序已被弃用？：<a href="http://chromecj.com/web-development/2018-04/1376.html" rel="nofollow" title="http://chromecj.com/web-development/2018-04/1376.html">http://chromecj.com/web-development/2018-04/1376.html</a></p> 
<h4 id="h_534078123_1"><strong>postman 的特点</strong></h4> 
<ul><li>postman 只做 <strong>http协议 </strong>的接口的测试，是一种最广泛 REST 接口测试客户端软件。</li><li>postman 支持 http 协议的所有请求方式，包括 get、post、head、put、delete 等。</li><li>postman 支持各种额外的头部字段的添加。</li><li>postman 除了可以模拟普通表单数据外，还支持文件、图片、视频等数据请求。</li><li>postman 是一个接口的开发和测试的全流程支持软件。</li><li>支持前端开发：mock(模拟) 测试</li><li>支持后端开发：接口测试、开发接口文档</li><li>支持测试：接口测试</li><li>支持运维：监控功能</li><li>postman 支持云服务：随时随地都能无缝对接加班。</li><li>数据同步功能，家里、办公室的电脑登录同一账号，数据即可同步。</li><li>团队协作，你设计的请求可以团队内的推送，交给其他人执行或继续开发。</li></ul> 
<h4 id="h_534078123_2"><strong>安装 postman</strong></h4> 
<p>官网下载 postman：<a href="https://www.postman.com/downloads/" rel="nofollow" title="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/41/3a/EZW5KvGr_o.png"></p> 
<p>根据自己使用系统，下载对应的平台版本，默认安装即可。</p> 
<h4 id="h_534078123_3"><strong>注册和登录</strong></h4> 
<p>也可以不注册，但是有些功能不能用</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/74/6d/w1NYtl70_o.png"></p> 
<h4 id="h_534078123_4">第一个接口测试</h4> 
<p>百度翻译接口的实现：是一个get类型的请求：https://fanyi-api.baidu.com/api/trans/vip/translate?q=apple&amp;from=auto&amp;to=zh&amp;appid=&amp;xxxxsalt=888888&amp;sign=a9adc2d687fbacecc3b5059b9ccedc95</p> 
<p>1）创建一个工程目录</p> 
<p>如果没有特别的要求，只需要创建一次即可。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/36/d7/J7tBtbkk_o.png"></p> 
<p>2）在工程目录下创建一个 collection 集合</p> 
<p>collection 是 postman 管理接口请求的基本单位，首先就是把他创建出来。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9a/b4/NytoyX4r_o.png"></p> 
<p>3）创建一个接口请求（接口用例）</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/20/04/8xwgNP4H_o.png"></p> 
<p>新建请求，重命名为baiduTest01：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/82/21/gR8B8DB1_o.png"></p> 
<p>4）拼装一个接口请求参数</p> 
<p>对于一个get请求来说，需要三部分内容：</p> 
<p>​请求地址：https://fanyi-api.baidu.com/api/trans/vip/translate</p> 
<p>请求方式：get</p> 
<p>请求参数（params）</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f5/cf/aIpTnSYI_o.png"></p> 
<p>5) 断言</p> 
<p>后续细讲。</p> 
<p>6）发送请求</p> 
<p>点击url地址栏后面的send按钮。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/60/7c/b85V9BlF_o.png"></p> 
<p>老版本 postman 界面</p> 
<p><img alt="这里写图片描述" src="https://images2.imgbox.com/86/c4/u68OuXKf_o.png"></p> 
<p></p> 
<h3 id="h_534078123_5">二、接口 测试的流程</h3> 
<h4 id="h_534078123_6">获取请求的基本参数</h4> 
<ul><li>做接口测试，基本上就是手动打包 http 请求报文，你要知道请求报文到底有哪些内容。</li><li>接口的 url 地址：找到接口所在的服务器及资源（一个文件夹或者一个文件、接口）</li><li>接口的请求方式：get、post等</li><li>必须的请求头部：（content-type、referer、cookie等）</li><li>请求参数（querry string parameters）：可以单独存放，也可以拼接在url地址后面</li><li>请求的正文数据</li></ul> 
<p>怎么获取这些个参数：</p> 
<p>1）有专门的接口文档，通过这个文档就能获取上面的参数</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/99/02/IzOlQYsd_o.png"></p> 
<p>2）通过抓包工具获取（浏览器、fiddler等）</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8b/77/y7CKYrtX_o.png"></p> 
<h4 id="h_534078123_7">设计测试用例</h4> 
<p>按照指定的用例模板，依据接口的参数，采用等价类、边界值、参数组合（有的参数必选、可选等）形参请求数据，整理响应其他参数（url、请求方式等）和预期结果（断言），形成测试用例。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ad/7d/xFkUoMkU_o.png"></p> 
<h4 id="h_534078123_8">通过 postman 拼接请求</h4> 
<p>根据测试用例，将postman中的请求拼接出来，并send发送，查看结果。</p> 
<p>创建collection--&gt;request(请求，或者接口用例)</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/06/51/n4wD0XFl_o.png"></p> 
<h4 id="h_534078123_9">断言</h4> 
<p>通过断言能够自动判断业务逻辑是否正确，一般可以采用对响应的状态码、响应的正文进行判断,还可以采用响应头部的一些字段来断言。在接口测试中，断言也是必须的，没有断言的话，只是把请求发出去，不知道处理的对不对（接口实功能实现对不对）。</p> 
<p></p> 
<h3 id="h_534078123_10">三、使用 postman 进行 HTTP 接口测试</h3> 
<h4 id="h_534078123_11">get 请求</h4> 
<p>get请求不需要有请求的正文数据的，其他都要（url和请求方式必须，可选的是头部字段）。</p> 
<p>1）百度翻译接口</p> 
<p>自己再去做一遍即可。</p> 
<p>请求地址：url：https://fanyi-api.baidu.com/api/trans/vip/translate</p> 
<p>请求方式：get</p> 
<blockquote> 
 <p>params：q=apple&amp;from=auto&amp;to=zh&amp;appid=xxxxx&amp;salt=888888&amp;sign=a9adc2d687fbacecc3b5059b9ccedc95</p> 
</blockquote> 
<p>2）B站视频最新评论接口</p> 
<blockquote> 
 <p>url：https://api.bilibili.com/x/v2/reply/main</p> 
</blockquote> 
<p>请求方式：get</p> 
<p>params: callback=jQuery17207775567550413909_1655259544202&amp;jsonp=jsonp&amp;next=0&amp;type=1&amp;oid=248143527&amp;mode=2&amp;plat=1&amp;_=1655259574655</p> 
<p>在postman中实现上述的参数，形成参数用例：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/59/06/t4eblPpB_o.png"></p> 
<p>视频类的网站都有一个防盗链功能，就算抓到了请求的基本参数，你也不能通过工具获取评论的参数，其实是通过一个头部字段进行的限制，这个字段就起到了防盗链的作用。</p> 
<p>referer：一般只是当前视频所在的地址，用它做防盗链的作用，必须指定referer，而且referer的值和当前视频的地址一致，你才有权限获取评论信息。</p> 
<p>至于使用哪一个字段来做防盗链，开发设计的，只不过使用referer的居多。</p> 
<p>解决方法：</p> 
<p>postman的header标签下，添加一个头字段referer（可以抓包获取）。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/42/f8/L8OkF4Fx_o.png"></p> 
<h4 id="h_534078123_12">post 请求</h4> 
<p>除了 get 所需的所有参数（请求方式、请求地址、请求头部等），还需要请求正文数据。</p> 
<p>1）百度翻译</p> 
<p>​使用post请求实现百度翻译功能，content-type一定是x-www-form-urlencoded<br> https://fanyi-api.baidu.com/api/trans/vip/translate?q=apple&amp;from=auto&amp;to=zh&amp;appid=xxxxxx&amp;salt=888888&amp;sign=a9adc2d687fbacecc3b5059b9ccedc95<br> 请求地址：https://fanyi-api.baidu.com/api/trans/vip/translate</p> 
<p>请求类型：post</p> 
<p>请求正文：</p> 
<ul><li>q：apple</li><li>from：auto</li><li>to：zh</li><li>appid：xxxxx</li><li>salt：888888</li><li>sign：a9adc2d687fbacecc3b5059b9ccedc95</li><li>请求头部：content-type：x-www-form-urlencoded</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/38/85/j9AZsB3V_o.png"></p> 
<p>2） 电商前台的注册接口</p> 
<p>特点是post请求，content-type要求是以x-www-form-urlencoded。</p> 
<p>请求的地址：http://xxxxx/qftest/index.php?c=user&amp;a=register&amp;step=submit</p> 
<p>请求的方式：post</p> 
<p>请求的参数：拼接在地址栏了</p> 
<p>请求的数据：</p> 
<ul><li>username: 给一个已注册的数据、空、4位、数字开头、正常未注册等</li><li>email</li><li>password</li><li>repassword</li><li>agree</li></ul> 
<p>请求的头部：content-type：application/x-www-form-urlencoded</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e5/60/ZeSBglYO_o.png"></p> 
<p>3）电商登录接口</p> 
<p>请求地址：http://xxxxx/qftest/user/login.html?step=submit</p> 
<p>请求方式: post</p> 
<p>请求正文：</p> 
<ul><li>username：bk2201_00001</li><li>password：200c6d94e583e62c6964de3acdc723e5</li></ul> 
<p>请求头部：content-type：application/x-www-form-urlencoded</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/14/31/7xi3GbVi_o.png"></p> 
<p></p> 
<h4 id="h_534078123_13">post 请求体</h4> 
<p>content-type 类型位form-data，数据传输仍然是键值对，数据类型可以是文件（word、excel、图片、视频等）。</p> 
<p>1）蜜锋OA系统登录功能--urlencoded</p> 
<p>请求url：http://xxxxx/MiFengOA/index.php?a=check&amp;m=login&amp;d=&amp;ajaxbool=true&amp;rnd=607798</p> 
<p>请求方式：post</p> 
<p>请求的数据：</p> 
<p>请求头部：content-type: x-www-form-urlencoded</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d1/e2/KD8a9zVK_o.png"></p> 
<p>2）蜜锋OA系统上传图片的功能--form-data</p> 
<p>只有登录成功之后才能够上传图片，登录失败（没有登录）不能上传。</p> 
<p>请求地址：http://xxxxx/MiFengOA/index.php?a=upfile&amp;m=upload&amp;d=public&amp;maxsize=80&amp;uptype=image&amp;thumbnail=150x150&amp;ajaxbool=true&amp;rnd=322198</p> 
<p>请求方式：post</p> 
<p>请求数据：file: (binary)</p> 
<p>请求头部：content-type：multipart/form-data</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/62/68/VwMeXk5k_o.png"></p> 
<p>3) 多接口的实现-cookie的使用</p> 
<p>cookie作为一种鉴权的方式，登录某个系统之后，再次访问系统的不同页面，都能保持登录状态，就是因为后续的所有请求都携带了cookie的参数。</p> 
<p>第一次登录成功，postman或者浏览器，可以将登录所用的用户名及密码等记录在本地。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4c/62/AeIsQFSQ_o.png"></p> 
<p>再在访问其他接口的时候，浏览器发出的请求就会自动化从cookie管理器中携带和当前主机相关的cookie及值，这样就一直保持了登录状态。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9c/55/a3h9ifsJ_o.png"></p> 
<p>在postman中的两个请求，登录和上传签名。</p> 
<p>如果希望通过postman的cookie管理器，来共享cookie值，就可以调整他俩的现后执行顺序即可，先登录再上传即可，每次都能动态获取最新的cookie值，一般不会出错。</p> 
<p>如果不想使用cookie管理器，不想先登录怎么办，只能手动给上传接口添加一个cookie参数，应为cookie是有时效性的，过一段时间就不能用了。</p> 
<h4 id="h_534078123_14">post 请求头</h4> 
<p>json 数据结构作为请求的正文数据及响应正文数据是最常见的用法，将来大家接触的80%都是这种格式的。</p> 
<p>将来项目中 json 数据会更复杂、内容会更多，上百行数据都很正常。</p> 
<p>住逻辑的登录的接口来演示。</p> 
<p>请求地址：https://xxx/designer_api/account/login_quick</p> 
<p>请求的方式：post</p> 
<p>请求的数据:</p> 
<pre><code>{"phone":"xxx","code":"123456","messageType":3,"key":"a2088d42-2eb0-4194-aada-e3a0019ed5f1","registration_type":1,"channel":"zhulogic","unionid":""}</code></pre> 
<p>请求的头部</p> 
<p>Content-Type:application/json;charset=UTF-8</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/74/1e/Sbua9U3o_o.png"></p> 
<p></p> 
<h3 id="h_534078123_15">四、变量的使用</h3> 
<h4 id="h_534078123_16">环境变量</h4> 
<p>主要用于环境迁移。</p> 
<p>postman中支持两种环境，一种是全局的环境变量、另一种是局部的环境变量。</p> 
<ul><li>全局的环境变量：只有一组，就是global环境，所有的集合和请求可以共享这个环境的变量。</li><li>局部的环境变量：environment环境，可以设置多组，需要指定给集合或者请求才能使用。</li></ul> 
<p>场景：假设我们一个系统有500条接口请求，突然有一天服务器的地址更换了（测试环境迁移到预发布环境中去），这时候需要把500个请求中的主机名部分更换一遍。</p> 
<p>而全局环境及局部环境的变量就可以解决这种耗时的任务。</p> 
<p>1）globals全局环境设置</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/36/d0/NUiRejYZ_o.png"></p> 
<p>2）environment局部环境设置</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/00/fb/5m66Qszm_o.png"></p> 
<h4 id="h_534078123_17">集合 collection 变量</h4> 
<p>绑定在集合上的变量，只能给集合下的请求使用。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/19/1a/zqLwJqjs_o.png"></p> 
<p>然后在该集合中就可以直接使用{<!-- -->{password}}来参数化数据了。</p> 
<p>注意：不能跨集合使用。</p> 
<p></p> 
<h3 id="h_534078123_18">五、预处理、断言</h3> 
<p>这两个模块采用的是js语法脚本。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/86/f6/DFBhtxOT_o.png"></p> 
<h4 id="h_534078123_19">预处理 --- pre-request script 模块</h4> 
<p>在当前请求发送之前要处理的脚本，我们能做点什么事情？</p> 
<p>用于处理请求数据（获取、设置、加密等）</p> 
<p>在发送当前请求之前发送另外一个请求（OA的登录和上传图片）。</p> 
<p>1）发送一个 get 请求</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/10/f8/DDewl4IR_o.png"></p> 
<p>2）获取参数（全局环境、局部环境、集合变量）</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1b/20/7AjqodEl_o.png"></p> 
<p>3）修改、设置参数(掌握)</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/48/75/DEcGvX8k_o.png"></p> 
<p>4）发送一个post类型的请求</p> 
<pre><code>//发一次登录请求？？
//是在OALoadImage前要处理的脚本
//实现发送一个post请求
var  postInfo = {
    "url":"http://xxxx/MiFengOA/index.php?a=check&amp;m=login&amp;d=&amp;ajaxbool=true&amp;rnd=607798",
    "method":"post",
    "body":{
        "mode":"urlencoded",
        "urlencoded":"rempass=0&amp;jmpass=false&amp;device=1650464000397&amp;ltype=0&amp;adminuser=YWRtaW4:&amp;adminpass=YTg5ODM5ODM:&amp;yanzm="

    }
}
pm.sendRequest(postInfo, function (err, response) {
    //如果响应正文是json格式的，就可以response.json()输出响应正文
    //如果响应正文是不是json格式的，就输出字符粗格式：response.text()
    console.log(response.json());
});</code></pre> 
<p></p> 
<h4 id="h_534078123_20">断言 - tests</h4> 
<p>在当前请求发送之后要处理的脚本，是作为断言来使用的。</p> 
<p>发送完当前请求之后，对响应的结果进行判断、断言</p> 
<p>断言的内容可以是：响应正文、响应状态码、响应头部的字段呢？响应时间等</p> 
<p>响应正文断言：包含子字符串（掌握）和json断言（掌握）</p> 
<p>其他断言方式了解：响应状态码断言、响应时间断言等</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/26/c3/fHAjfIvw_o.png"></p> 
<pre><code>//实现断言，是在当前请求发送完成之后，得到响应结果才能进行的。

//1、判断响应状态码是否符合预期，并不能完全确定业务是否是正确的
pm.test("响应状态码是200？", function () {
    //实现判断语法
    //pm.response: http的响应报文（四大组成部分）
    // to.have.status(200)：是否包含状态码200呢？
    pm.response.to.have.status(200);
});
//了解就行
tests["响应状态码是否为200？"] = responseCode.code === 200;
// 2、响应正文做断言(重点掌握)
// 以字符串格式的正文形式断言（都行）
// 大串（实际结果）包小串（预期结果）。
//  pm.response.text()：将响应报文中的正文部分转化为字符串格式
pm.test("大串包小串？？", function () {
    pm.expect(pm.response.text()).to.include("用户名不符合格式要求");
});

//responseBody ：获取的是响应正文
tests["响应正文包括指定字符串？"] = responseBody.has("用户名不符合格式要求");

// 以json格式的正文进行i断言（响应报文头部的content-type为json的可以用）
//直接使用json断言
pm.test("Your test name", function () {
    var jsonData = pm.response.json();
    console.log(jsonData.trans_result[0].dst)
    pm.expect(jsonData.trans_result[0].dst).to.eql("苹果");
});

//响应时间：从发出请求，到接收到响应结果的时间差就是响应时间，是接口的一个性能指标
// 假设要求，该请求响应时间不应该高于200ms
pm.test("响应时间的判断：", function () {
    //pm.response.responseTime:实际的响应时间
    // to.be.below：低于某个指定的值
    pm.expect(pm.response.responseTime).to.be.below(400);
});</code></pre> 
<p></p> 
<h3 id="h_534078123_21">六、Runner 运行器的用法</h3> 
<p>runner 是 postman 中执行 collection 集合中请求的一种用法，可以调整执行的顺序和用例的数量。可以记录执行结果及导出结果报告（json格式的报告）。</p> 
<h4 id="h_534078123_22">运行测试集合</h4> 
<p>选择一个测试集合，启动运行器。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/e8/mQGECbPV_o.png"></p> 
<p>按照如下设置，点击运行：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ba/91/WQLsiM2K_o.png"></p> 
<p>执行结果：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4f/67/T0ScQejQ_o.png"></p> 
<p></p> 
<h4 id="h_534078123_23">参数化（数据驱动测试）</h4> 
<p>1）json文件数据驱动</p> 
<p>创建json文件，并设置数据：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/09/fa/QQnXCvqV_o.png"></p> 
<p>使用文件中的键名参数化postman正文数据值。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/07/a8/1iZ16NnB_o.png"></p> 
<p>断言也需要进行参数化：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3e/31/x0UQykT5_o.png"></p> 
<p>使用Runner运行器，导入、并查看数据文件</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d4/64/VBvNHov6_o.png"></p> 
<p>因为有四条数据，迭代次数就默认给设置成了4次。</p> 
<p>它会每次迭代从文件中读取一行数据进行参数化，并允许。</p> 
<p>直到四次迭代结束，数据使用完毕。</p> 
<p>做好设置，保存响应结果，点击运行集合。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1f/c2/NPy0O3NG_o.png"></p> 
<p>2）csv文件数据驱动</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/40/bd/TutJrm0i_o.png"></p> 
<p>后续操作过程见json数据驱动过程。</p> 
<p></p> 
<h3 id="h_534078123_24">七、newman 插件的使用</h3> 
<p>newman是postman的插件，是用于命令行运行测试集合的一个插件。</p> 
<h4 id="h_534078123_25">安装</h4> 
<p>先安装nodejs，通过npm -v验证</p> 
<p>最好安装16版本以上。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d3/26/k6T3OP2l_o.png"></p> 
<p>再安装Newman，npm install -g newman，也是通过newman -v来验证。</p> 
<p>指定版本安装格式： npm install -g newman@5.2.4</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/24/42/yaZJDTYn_o.png"></p> 
<p>如果出现安装进度慢，默认镜像源（软件所在的服务器）在国外，可以更新到国内的镜像源服务器上去。</p> 
<p>npm config set registry <a href="https://link.zhihu.com/?target=http%3A//registry.npm.taobao.org" rel="nofollow" title="http://registry.npm.taobao.org">http://registry.npm.taobao.org</a></p> 
<h4 id="h_534078123_26">使用newman运行collection</h4> 
<p>前提准备：</p> 
<ul><li>测试集合文件，是通过postman导出的json文件。</li><li>环境变量文件，是需要通过postman导出的json文件。</li><li>数据驱动文件：data.json、data.csv</li></ul> 
<p>1) 只运行一个collection集合（不涉及到环境变量、不涉及参数化）</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/25/a3/51um1Hkc_o.png"></p> 
<p>导出集合文件为：zhuluoji_collection.json</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/10/b7/B6OJVyx1_o.png"></p> 
<p>就可以使用newman运行这个集合文件了：</p> 
<p>格式： newman run 集合文件的全路径</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/89/50/xEJnFojR_o.png"></p> 
<p>2） 指定迭代次数 ： -n</p> 
<pre><code>newman run e:\zhuluoji_collection.json  -n 2</code></pre> 
<p>3) 指定局部环境变量：-e</p> 
<p>导出environment环境变量文件。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/27/c6/5yDLkBjj_o.png"></p> 
<pre><code>newman run e:\zhuluoji_collection.json -e e:\BaiDuTrans_environment.json  -n 2</code></pre> 
<p>4) 指定全局环境变量：-g</p> 
<p>导出globals环境变量文件：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1f/b6/rR6gG9mz_o.png"></p> 
<pre><code>newman run e:\BaiDuTrans_collection.json -e e:\BaiDuTrans_environment.json -g e:\globals.json -n 1</code></pre> 
<p>5) 指定参数化文件的：-d</p> 
<p>可以支持json和csv文件进行参数化的。</p> 
<pre><code>newman run e:\MiFeng_collection.json -d e:\data.json
newman run e:\MiFeng_collection.json -d e:\data.csv</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/30/1d/4tooOxI8_o.png"></p> 
<h4 id="h_534078123_27">生成报告</h4> 
<p>1） cli过格式报告</p> 
<p>在cmd下运行的结果报告的展示形似。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ad/36/v4hqLlta_o.png"></p> 
<p>2） json格式报告</p> 
<p>-r json : 指定输出报告的格式是json格式。</p> 
<p>newman run e:\MiFeng_collection.json -d e:\data.csv -r json --reporter-json-export e:\data\result1212.json</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/99/64/X4YJXNj9_o.png"></p> 
<p>3) html格式报告</p> 
<p>-r html ： 指定输出报告的格式为html格式</p> 
<pre><code>newman run e:\MiFeng_collection.json -d e:\data.csv -r html --reporter-html-export e:\data\result1212.html</code></pre> 
<p>但是html格式输出，需要安装插件才能使用。</p> 
<pre><code>npm install -g  newman-reporter-html</code></pre> 
<p>4) 集成命令到批处理文件中（bat文件）</p> 
<p>创建一个txt文件，重命名为run.bat文件，将其编码改为utf-8,将上面可执行的newman命令复制到该文件即可。</p> 
<p>保存后，双击该文件运行。</p> 
<p></p> 
<h3 id="h_534078123_28">八、newman+jenkins集成做定时任务</h3> 
<h4 id="h_534078123_29">配置jenkins支持newman的环境变量</h4> 
<p>需要配置newman和node的路径，通过where命令来获取。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b2/6f/XJ0kKgJy_o.png"></p> 
<p>填如下面的path变量中。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/46/d4/KWLaZFnV_o.png"></p> 
<h4 id="h_534078123_30">创建自由风格的项目</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/86/13/3MXHlc0d_o.png"></p> 
<h4 id="h_534078123_31">配置项目</h4> 
<p>1）定时任务</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f2/8a/b68UtNDL_o.png"></p> 
<p>2）创建windows patch command构建</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8f/59/YBCyZ1qX_o.png"></p> 
<p>保存、退出。</p> 
<h4 id="h_534078123_32">运行任务</h4> 
<p>1）手动运行</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a7/ef/jWtE2BGW_o.png"></p> 
<p>2）定时运行</p> 
<p>根据设置的触发时间，自动运行脚本。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/62/65/pSjBBdlv_o.png"></p> 
<p></p> 
<h3 id="h_534078123_33">九、Mock 挡板测试</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b4/39/ScDvR2NG_o.png"></p> 
<h4 id="h_534078123_34">创建挡板服务</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/af/85/QI4Agc2P_o.png"></p> 
<h4 id="h_534078123_35">配置相关参数</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d7/73/NqhL8U55_o.png"></p> 
<h4 id="h_534078123_36">指定环境变量，运行挡板测试</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bf/8e/36nGUBuk_o.png"></p> 
<p></p> 
<h3 id="h_534078123_37">十、监控测试</h3> 
<p>系统上线了，客户使用的时候有个接口失效了，客户会反馈问题给运维、运维会提交给测试、测试提交给开发，开发定位、修复这个问题，走这么一圈，可能三四天时间过去了，反馈的效率太低，影响会很大。</p> 
<p>诉求：反馈效率要高，影响降低到最小。</p> 
<p>解决：通过实时监控接口的方式，每隔固定时间给接口发送请求，通过返回的响应结果确定接口的正确性，如果接口断言失败，则直接发送邮件给指定的人。</p> 
<p>postman中如何实现：</p> 
<h4 id="h_534078123_38">配置监控</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f8/62/sTeXE6qf_o.png"></p> 
<h4 id="h_534078123_39">运行监控</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/75/c0/NrpuqUPQ_o.png"></p> 
<h4 id="h_534078123_40">监控过程</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d3/59/mUxK5dRh_o.png"></p> 
<h4 id="h_534078123_41">邮件提醒</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ae/b0/2IrpuKjV_o.png"></p> 
<p></p> 
<h3 id="h_534078123_42">十一：关联技术</h3> 
<p>关联技术：解决多个接口之间，数据交互的问题（比如第一个接口响应数据要给第二个接口作为参数使用），我们动态提前第一个接口响应数据，参数化第二个接口的过程就是关联。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/20/4d/NblfRJcn_o.png"></p> 
<h4 id="h_534078123_43">电商后台首页接口</h4> 
<p>请求地址：<a href="https://link.zhihu.com/?target=http%3A//xxxx/qftest/index.php%3Fm%3Dbackend%26c%3Dmain%26a%3Dindex" rel="nofollow" title="http://xxxx/qftest/index.php?m=backend&amp;c=main&amp;a=index">http://xxxx/qftest/index.php?m=backend&amp;c=main&amp;a=index</a></p> 
<p>请求方式：get</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c9/47/wGcjSR6n_o.png"></p> 
<p></p> 
<h4 id="h_534078123_44">电商登录接口</h4> 
<p>请求地址：<a href="https://link.zhihu.com/?target=http%3A//xxxxxx/qftest/index.php%3Fm%3Dbackend%26c%3Dmain%26a%3Dlogin" rel="nofollow" title="http://xxxxxx/qftest/index.php?m=backend&amp;c=main&amp;a=login">http://xxxxxx/qftest/index.php?m=backend&amp;c=main&amp;a=login</a></p> 
<p>请求方式：post</p> 
<p>请求头部：Content-Type: application/x-www-form-urlencoded</p> 
<p>请求正文：</p> 
<ul><li>M98v8: 848750613</li><li>username: xxxx</li><li>password: 091bfa87c505bba664b431baf83cbc19</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3d/b2/quGCdzHd_o.png"></p> 
<h4 id="h_534078123_45">商品的删除</h4> 
<p>通过商品的id删除商品</p> 
<p>请求地址：<a href="https://link.zhihu.com/?target=http%3A//xxxx/qftest/index.php%3Fm%3Dbackend%26c%3Dgoods%26a%3Ddelete%26id%3D212" rel="nofollow" title="http://xxxx/qftest/index.php?m=backend&amp;c=goods&amp;a=delete&amp;id=212">http://xxxx/qftest/index.php?m=backend&amp;c=goods&amp;a=delete&amp;id=212</a></p> 
<p>请求方式：get</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/94/2f/0eMSFqnJ_o.png"></p> 
<h4 id="h_534078123_46"> 商品的添加</h4> 
<p>Request URL: <a href="https://link.zhihu.com/?target=http%3A//xxxxxx/qftest/index.php%3Fm%3Dbackend%26c%3Dgoods%26a%3Dadd%26step%3Dsubmit" rel="nofollow" title="http://xxxxxx/qftest/index.php?m=backend&amp;c=goods&amp;a=add&amp;step=submit">http://xxxxxx/qftest/index.php?m=backend&amp;c=goods&amp;a=add&amp;step=submit</a></p> 
<p>Request Method:POST</p> 
<p>请求头部：Content-Type: multipart/form-data</p> 
<p>请求数据：</p> 
<ul><li>goods_name: xiaomi12pro</li><li>cate_id: 59</li><li>brand_id: 1</li><li>goods_sn: 010100112</li><li>now_price: 1999</li><li>original_price: 2999</li><li>newarrival: 1</li><li>status: 1</li><li>goods_image:</li><li>stock_qty: 9999</li><li>goods_weight: 0.00</li><li>meta_keywords:</li><li>meta_description:</li><li>goods_brief: &lt;p&gt;aa&lt;/p&gt;</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/22/19/rf0ulyYV_o.png"></p> 
<p></p> 
<h3 id="h_534078123_47">十二、token 技术使用</h3> 
<p>通过关联技术获取验证码接口提供的token，并在后续的请求中带上token值，才能访问到服务器端的数据。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b6/89/gOkV0eOY_o.png"></p> 
<h4 id="h_534078123_48">获取验证码的接口</h4> 
<p>Request URL: <a href="https://link.zhihu.com/?target=http%3A//xxxxxx/student/api/capchaRestController/captcha" rel="nofollow" title="http://xxxxxx/student/api/capchaRestController/captcha">http://xxxxxx/student/api/capchaRestController/captcha</a></p> 
<p>Request Method: POST</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d5/a7/4UAq7VRm_o.png"></p> 
<h4 id="h_534078123_49">登录接口</h4> 
<p>Request URL: <a href="https://link.zhihu.com/?target=http%3A//zxxxxx/student/api/login" rel="nofollow" title="http://zxxxxx/student/api/login">http://zxxxxx/student/api/login</a></p> 
<p>Request Method: POST</p> 
<p>Request Header：Content-Type: application/json</p> 
<p>Requests Body：</p> 
<pre><code>{
"mobile":"xxxxx",
"password":"123456",
"imgCode":"00635",
"imgToken":"9be7d1a7-86ef-4f96-bbd0-97dfb11dbf6e"
}</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/28/ae/J4cMdpeU_o.png"></p> 
<h4 id="h_534078123_50">登录后的其他操作-学习中心</h4> 
<p>Request URL: <a href="https://link.zhihu.com/?target=http%3A//xxxx/student/api/line/list/24" rel="nofollow" title="http://xxxx/student/api/line/list/24">http://xxxx/student/api/line/list/24</a></p> 
<p>Request Method: POST</p> 
<p>Request Header：Authorization:</p> 
<pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJRRkVEVV9Qc1lEMkdkM3lvMFg2bGttQXJyTnRBPT0iLCJleHAiOjE2NTYxMzM1ODV9.GaMxcrj6uYfyFhWYQKJCNqcIRrLCM9YnJXA0mX2_5es</code></pre> 
<p>Content-Type：application/json</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/65/ee/F5JHy5GT_o.png"></p> 
<h4 id="h_534078123_51">runner运行器测试执行</h4> 
<p>使用runner运行器，按照业务流程顺序执行接口，便可实现业务流程。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4c/4c/26pCnMRh_o.png"></p> 
<p>到此，allen老师的又一篇万字长文就暂告段落，后续postman的其他功能也会持续更新在这篇文章里，大家可以收藏该文章，持续学习。</p> 
<p></p> 
<p></p> 
<h2>2、Apifox 快速入门</h2> 
<p></p> 
<p>帮助文档：<a class="link-info" href="https://apifox.com/help/" rel="nofollow" title="https://apifox.com/help/">https://apifox.com/help/</a></p> 
<p></p> 
<h3>入门</h3> 
<ul><li><a href="https://apifox.com/help/" rel="nofollow" title="快速入门">快速入门</a></li><li><a href="https://apifox.com/help/overview/introduction" rel="nofollow" title="产品介绍">产品介绍</a></li><li><a href="https://apifox.com/help/overview/best-practice" rel="nofollow" title="最佳实践">最佳实践</a></li><li><a href="https://apifox.com/help/overview/contact-us" rel="nofollow" title="联系我们">联系我们</a></li><li><a href="https://apifox.com/help/overview/contact-us-and-on-premise-deployment" rel="nofollow" title="私有化部署">私有化部署</a></li></ul> 
<p></p> 
<h3>接口文档</h3> 
<ul><li><a href="https://apifox.com/help/api-docs/api-design" rel="nofollow" title="新建 &amp; 设计接口">新建 &amp; 设计接口</a></li><li><a href="https://apifox.com/help/api-docs/data-schemas" rel="nofollow" title="数据模型 / 结构">数据模型 / 结构</a></li><li><a href="https://apifox.com/help/api-docs/component-library" rel="nofollow" title="组件库">组件库</a></li><li><a href="https://apifox.com/help/api-docs/api-modification-history" rel="nofollow" title="接口修改历史">接口修改历史</a></li><li><a href="https://apifox.com/help/api-docs/batch-api-management" rel="nofollow" title="接口批量管理">接口批量管理</a></li><li> <p><a href="https://apifox.com/help/#" rel="nofollow" title="分享 &amp; 发布文档">分享 &amp; 发布文档</a></p> </li><li> <p><a href="https://apifox.com/help/#" rel="nofollow" title="高级功能">高级功能</a></p> </li></ul> 
<p></p> 
<h3>接口调试</h3> 
<ul><li><a href="https://apifox.com/help/debugging-api/introduction" rel="nofollow" title="功能简介">功能简介</a></li><li><a href="https://apifox.com/help/debugging-api/getting-started" rel="nofollow" title="快速上手">快速上手</a></li><li><a href="https://apifox.com/help/debugging-api/debug-mode-and-design-mode" rel="nofollow" title="调试 / 文档模式">调试 / 文档模式</a></li><li><a href="https://apifox.com/help/debugging-api/sending-requests" rel="nofollow" title="快捷请求">快捷请求</a></li><li><a href="https://apifox.com/help/debugging-api/sse" rel="nofollow" title="SSE 调试">SSE 调试</a></li><li><a href="https://apifox.com/help/debugging-api/requesting-history" rel="nofollow" title="请求历史">请求历史</a></li></ul> 
<p></p> 
<h3>环境 &amp; 变量</h3> 
<ul><li><a href="https://apifox.com/help/environment-and-variables/environment-management" rel="nofollow" title="环境管理">环境管理</a></li><li><a href="https://apifox.com/help/environment-and-variables/environment-variables-global-variables-temporary-variables" rel="nofollow" title="环境变量 / 全局变量 / 临时变量">环境变量 / 全局变量 / 临时变量</a></li><li><a href="https://apifox.com/help/environment-and-variables/dynamic-values" rel="nofollow" title="动态值">动态值</a></li></ul> 
<p></p> 
<h3>前后置操作 &amp; 脚本</h3> 
<ul><li><a href="https://apifox.com/help/pre-post-processors-and-scripts/introduction" rel="nofollow" title="功能简介">功能简介</a></li><li><a href="https://apifox.com/help/pre-post-processors-and-scripts/assertions" rel="nofollow" title="断言">断言</a></li><li><a href="https://apifox.com/help/pre-post-processors-and-scripts/variable-extraction" rel="nofollow" title="提取变量">提取变量</a></li><li> <p><a href="https://apifox.com/help/#" rel="nofollow" title="数据库">数据库</a></p> </li><li> <p><a href="https://apifox.com/help/#" rel="nofollow" title="使用脚本">使用脚本</a></p> </li><li> <p><a href="https://apifox.com/help/#" rel="nofollow" title="常见问题">常见问题</a></p> </li></ul> 
<p></p> 
<h3>自动化测试</h3> 
<ul><li> <p><a href="https://apifox.com/help/#" rel="nofollow" title="编排测试场景">编排测试场景</a></p> </li><li> <p><a href="https://apifox.com/help/#" rel="nofollow" title="运行测试">运行测试</a></p> </li><li> <p><a href="https://apifox.com/help/#" rel="nofollow" title="持续集成">持续集成</a></p> </li><li><a href="https://apifox.com/help/automated-testing/executing-test/apifox-cli" rel="nofollow" title="Apifox CLI">Apifox CLI</a></li><li><a href="https://apifox.com/help/automated-testing/view-testing-report" rel="nofollow" title="查看测试结果">查看测试结果</a></li></ul> 
<p></p> 
<h3>接口 Mock ( 模拟 )</h3> 
<ul><li><a href="https://apifox.com/help/api-mock/intro-to-mock" rel="nofollow" title="功能简介">功能简介</a></li><li><a href="https://apifox.com/help/api-mock/rules" rel="nofollow" title="Mock 语法">Mock 语法</a></li><li><a href="https://apifox.com/help/api-mock/intelligent-mock" rel="nofollow" title="智能 Mock">智能 Mock</a></li><li><a href="https://apifox.com/help/api-mock/advanced-mock" rel="nofollow" title="高级 Mock">高级 Mock</a></li><li><a href="https://apifox.com/help/api-mock/cloud-mock" rel="nofollow" title="云端 Mock">云端 Mock</a></li><li><a href="https://apifox.com/help/api-mock/default-mock" rel="nofollow" title="默认 Mock 方式">默认 Mock 方式</a></li></ul> 
<p></p> 
<h3>自动生成代码</h3> 
<p>：<a class="link-info" href="https://apifox.com/help/code-generation" rel="nofollow" title="https://apifox.com/help/code-generation">https://apifox.com/help/code-generation</a></p> 
<p></p> 
<h3>导入 / 导出接口</h3> 
<ul><li> <p><a href="https://apifox.com/help/code-generation#" rel="nofollow" title="导入接口">导入接口</a></p> </li><li><a href="https://apifox.com/help/api-docs/exporting-api" rel="nofollow" title="导出接口">导出接口</a></li></ul> 
<p></p> 
<h3>团队 &amp; 项目</h3> 
<ul><li><a href="https://apifox.com/help/team/team-projects" rel="nofollow" title="团队与项目">团队与项目</a></li><li><a href="https://apifox.com/help/team/managing-team" rel="nofollow" title="管理团队">管理团队</a></li><li><a href="https://apifox.com/help/team/managing-project" rel="nofollow" title="管理项目">管理项目</a></li><li><a href="https://apifox.com/help/team/managing-team-member" rel="nofollow" title="邀请成员">邀请成员</a></li><li><a href="https://apifox.com/help/team/member-permissions" rel="nofollow" title="成员权限设置">成员权限设置</a></li><li><a href="https://apifox.com/help/team/notification-settings" rel="nofollow" title="通知设置">通知设置</a></li><li><a href="https://apifox.com/help/team/collaboration-link" rel="nofollow" title="团队协作">团队协作</a></li></ul> 
<p></p> 
<h3>账号 &amp; 软件设置</h3> 
<ul><li><a href="https://apifox.com/help/personal/register-and-login" rel="nofollow" title="注册 / 登录">注册 / 登录</a></li><li><a href="https://apifox.com/help/personal/account-settings" rel="nofollow" title="账号设置">账号设置</a></li><li><a href="https://apifox.com/help/personal/hot-keys" rel="nofollow" title="快捷键">快捷键</a></li><li><a href="https://apifox.com/help/personal/proxy" rel="nofollow" title="网络代理">网络代理</a></li><li><a href="https://apifox.com/help/personal/language-settings" rel="nofollow" title="语言设置">语言设置</a></li><li><a href="https://apifox.com/help/personal/updating-apifox" rel="nofollow" title="更新 Apifox">更新 Apifox</a></li></ul> 
<p></p> 
<h3>应用与插件</h3> 
<ul><li> <p><a href="https://apifox.com/help/code-generation#" rel="nofollow" title="桌面端应用">桌面端应用</a></p> </li><li> <p><a href="https://apifox.com/help/code-generation#" rel="nofollow" title="IDEA 插件">IDEA 插件</a></p> </li><li> <p><a href="https://apifox.com/help/code-generation#" rel="nofollow" title="浏览器扩展">浏览器扩展</a></p> </li></ul> 
<p></p> 
<h3>最佳实践</h3> 
<ul><li><a href="https://apifox.com/help/best-practices/workflow" rel="nofollow" title="团队协作流程">团队协作流程</a></li><li><a href="https://apifox.com/help/best-practices/how-to-pass-data-between-apis" rel="nofollow" title="接口之间如何传递数据">接口之间如何传递数据</a></li><li><a href="https://apifox.com/help/best-practices/how-to-handle-auth" rel="nofollow" title="登录态（Auth）如何处理">登录态（Auth）如何处理</a></li><li><a href="https://apifox.com/help/best-practices/how-to-handle-api-signature" rel="nofollow" title="接口签名如何处理">接口签名如何处理</a></li><li><a href="https://apifox.com/help/best-practices/how-to-encrypt-or-decrypt-interface-data" rel="nofollow" title="如何加密/解密接口数据">如何加密/解密接口数据</a></li><li><a href="https://apifox.com/help/best-practices/automated-testing" rel="nofollow" title="如何开展自动化接口测试">如何开展自动化接口测试</a></li><li><a href="https://apifox.com/help/best-practices/sse-token" rel="nofollow" title="如何计算 AI 问答成本">如何计算 AI 问答成本</a></li></ul> 
<p></p> 
<h3>WebSocket 接口</h3> 
<ul><li><a href="https://apifox.com/help/websocket" rel="nofollow" title="WebSocket 接口">WebSocket 接口</a></li></ul> 
<p></p> 
<h3>WebService 接口</h3> 
<ul><li><a href="https://apifox.com/help/webservice" rel="nofollow" title="WebService 接口">WebService 接口</a></li></ul> 
<p></p> 
<h3>Socket 接口</h3> 
<ul><li><a href="https://apifox.com/help/socket/intro-to-socket" rel="nofollow" title="功能简介">功能简介</a></li><li><a href="https://apifox.com/help/socket/data-processor" rel="nofollow" title="报文数据处理器">报文数据处理器</a></li></ul> 
<p></p> 
<h3>gRPC 接口</h3> 
<ul><li><a href="https://apifox.com/help/grpc" rel="nofollow" title="gRPC 接口">gRPC 接口</a></li></ul> 
<p></p> 
<h3>Dubbo 接口</h3> 
<div> 
 <ul><li><a href="https://apifox.com/help/dubbo/creating-dubbo" rel="nofollow" title="新建接口">新建接口</a></li><li><a href="https://apifox.com/help/dubbo/debugging-dubbo" rel="nofollow" title="调试接口">调试接口</a></li><li><a href="https://apifox.com/help/dubbo/dubbo-specificaiton" rel="nofollow" title="接口文档">接口文档</a></li></ul> 
</div> 
<div></div> 
<div></div> 
<h3>参考资料</h3> 
<div> 
 <ul><li><a href="https://apifox.com/help/reference/swagger-extension" rel="nofollow" title="Apifox Swagger 扩展">Apifox Swagger 扩展</a></li><li><a href="https://apifox.com/help/reference/json-schema" rel="nofollow" title="JSON Schema 介绍">JSON Schema 介绍</a></li><li><a href="https://apifox.com/help/reference/json-path" rel="nofollow" title="JSON Path 介绍">JSON Path 介绍</a></li><li><a href="https://apifox.com/help/reference/xpath" rel="nofollow" title="XPath 介绍">XPath 介绍</a></li><li><a href="https://apifox.com/help/reference/regex" rel="nofollow" title="正则表达式">正则表达式</a></li><li><a href="https://apifox.com/help/reference/csv" rel="nofollow" title="CSV 格式规范">CSV 格式规范</a></li><li><a href="https://apifox.com/help/reference/socket-stick" rel="nofollow" title="Socket 粘包和分包问题">Socket 粘包和分包问题</a></li><li><a href="https://apifox.com/help/reference/install-java" rel="nofollow" title="安装 Java 环境">安装 Java 环境</a></li><li><a href="https://apifox.com/help/reference/programming-languages-list" rel="nofollow" title="常见编程语言对应的数据类型">常见编程语言对应的数据类型</a></li></ul> 
</div> 
<div></div> 
<div></div> 
<div> 
 <h3>常见问题</h3> 
</div> 
<div></div> 
<div></div> 
<div> 
 <p id="_1-apifox-是否收费"><strong>1. Apifox 是否收费？</strong><a href="https://apifox.com/help/faq#_1-apifox-%E6%98%AF%E5%90%A6%E6%94%B6%E8%B4%B9" rel="nofollow" title="​">​</a></p> 
 <blockquote> 
  <p><a href="https://apifox.com/" rel="nofollow" title="Apifox">Apifox</a> 公网版 (SaaS 版) 免费，私有化部署版收费。</p> 
 </blockquote> 
 <p id="_2-登录-auth-态如何实现"><strong>2. 登录（Auth）态如何实现？</strong><a href="https://apifox.com/help/faq#_2-%E7%99%BB%E5%BD%95-auth-%E6%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0" rel="nofollow" title="​">​</a></p> 
 <blockquote> 
  <p>请参考文档：<a href="https://apifox.com/help/best-practices/how-to-handle-auth" rel="nofollow" title="登录态（Auth）如何处理">登录态（Auth）如何处理</a>。</p> 
 </blockquote> 
 <p id="_3-接口发送请求前需要调用登录接口获取-token-放在-header-如何实现"><strong>3. 接口发送请求前需要调用登录接口获取 token 放在 header，如何实现？</strong><a href="https://apifox.com/help/faq#_3-%E6%8E%A5%E5%8F%A3%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%89%8D%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96-token-%E6%94%BE%E5%9C%A8-header-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0" rel="nofollow" title="​">​</a></p> 
 <blockquote> 
  <p>请参考文档：<a href="https://apifox.com/help/best-practices/how-to-handle-auth" rel="nofollow" title="登录态（Auth）如何处理">登录态（Auth）如何处理</a>。</p> 
 </blockquote> 
 <p id="_4-b-接口请求参数依赖于-a-接口返回的数据-如何实现"><strong>4. B 接口请求参数依赖于 A 接口返回的数据，如何实现？</strong><a href="https://apifox.com/help/faq#_4-b-%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%BE%9D%E8%B5%96%E4%BA%8E-a-%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0" rel="nofollow" title="​">​</a></p> 
 <blockquote> 
  <p>请参考文档：<a href="https://apifox.com/help/best-practices/how-to-pass-data-between-apis" rel="nofollow" title="接口之间如何传递数据">接口之间如何传递数据</a>。</p> 
 </blockquote> 
 <p id="_5-同项目下有不同域名的接口-如何处理"><strong>5. 同项目下有不同域名的接口，如何处理？</strong><a href="https://apifox.com/help/faq#_5-%E5%90%8C%E9%A1%B9%E7%9B%AE%E4%B8%8B%E6%9C%89%E4%B8%8D%E5%90%8C%E5%9F%9F%E5%90%8D%E7%9A%84%E6%8E%A5%E5%8F%A3-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86" rel="nofollow" title="​">​</a></p> 
 <blockquote> 
  <p><strong>方案一</strong>：在环境里新增多个服务，分别设置不同的前置 URL ,接口分组和接口维度可以指定对应的前置 URL。<strong>推荐本方案！</strong></p> 
  <p><strong>方案二</strong>：把域名设置成环境变量如<code>DOMAIN_1</code>，接口路径这样填写：<code>https://{<!-- -->{DOMAIN_1}}/users</code>。接口路径是以<code>http://</code>或<code>https://</code>起始的，系统会自动忽略里环境里前置 URL。</p> 
  <p><strong>方案三</strong>：给不同域名接口设置不同环境，通过切换环境来运行不同域名下的接口。<strong>不推荐本方案！</strong></p> 
 </blockquote> 
 <p id="_6-脚本如何读取或修改接口请求信息"><strong>6. 脚本如何读取或修改接口请求信息？</strong><a href="https://apifox.com/help/faq#_6-%E8%84%9A%E6%9C%AC%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E6%88%96%E4%BF%AE%E6%94%B9%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF" rel="nofollow" title="​">​</a></p> 
 <blockquote> 
  <p>请参考文档：<a href="https://apifox.com/help/pre-post-processors-and-scripts/scripts/examples/handling-request" rel="nofollow" title=" 脚本读取/修改接口请求信息"> 脚本读取/修改接口请求信息</a></p> 
 </blockquote> 
 <p id="_7-是否支持查询数据库字段作为参数传给接口"><strong>7. 是否支持查询数据库字段作为参数传给接口？</strong><a href="https://apifox.com/help/faq#_7-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E7%BB%99%E6%8E%A5%E5%8F%A3" rel="nofollow" title="​">​</a></p> 
 <blockquote> 
  <p>支持，请参考文档：<a href="https://apifox.com/help/processor/database/" rel="nofollow" title="数据库操作">数据库操作</a></p> 
 </blockquote> 
 <p id="_8-数据是存储在本地还是云端-可否离线使用-可否私有化部署"><strong>8. 数据是存储在本地还是云端？可否离线使用？可否私有化部署？</strong><a href="https://apifox.com/help/faq#_8-%E6%95%B0%E6%8D%AE%E6%98%AF%E5%AD%98%E5%82%A8%E5%9C%A8%E6%9C%AC%E5%9C%B0%E8%BF%98%E6%98%AF%E4%BA%91%E7%AB%AF-%E5%8F%AF%E5%90%A6%E7%A6%BB%E7%BA%BF%E4%BD%BF%E7%94%A8-%E5%8F%AF%E5%90%A6%E7%A7%81%E6%9C%89%E5%8C%96%E9%83%A8%E7%BD%B2" rel="nofollow" title="​">​</a></p> 
 <blockquote> 
  <p>目前 Apifox 有 <code>Saas 版</code> 和<code>私有化部署版</code> 。</p> 
  <p><code>Saas 版</code> 是免费的，数据都是存在云端的，需要联网才能使用。</p> 
  <p><code>私有化部署版</code> 是收费的，数据存在使用者企业内部，不连外网也可以使用。</p> 
  <p>注意</p> 
  <p>环境变量/全局变量里的 <strong>本地值</strong> 仅存放在本地，不会同步到云端，团队成员之间也不会相互同步，适合存放<code>token</code>、<code>账号</code>、<code>密码</code>之类的敏感数据。</p> 
 </blockquote> 
 <p id="_9-使用-postman-调用接口返回正常-而-apifox-返回错误"><strong>9. 使用 Postman 调用接口返回正常，而 Apifox 返回错误</strong><a href="https://apifox.com/help/faq#_9-%E4%BD%BF%E7%94%A8-postman-%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E6%AD%A3%E5%B8%B8-%E8%80%8C-apifox-%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF" rel="nofollow" title="​">​</a></p> 
 <blockquote> 
  <p>解决方法：对比 postman 和 apifox 实际发出的请求内容（url、参数、body、header）是否完全一样。</p> 
  <p>查看实际请求内容方法：</p> 
  <ol><li>Apifox：返回内容下的<code>实际请求</code> tab 里查看</li><li>Postman：点击底部状态栏里的<code>Console</code>查看</li></ol> 
 </blockquote> 
 <p id="_10-为什么修改了环境变量-或全局变量-值-而引用的地方没有生效"><strong>10. 为什么修改了环境变量（或全局变量）值，而引用的地方没有生效？</strong><a href="https://apifox.com/help/faq#_10-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BF%AE%E6%94%B9%E4%BA%86%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-%E6%88%96%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%80%BC-%E8%80%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88" rel="nofollow" title="​">​</a></p> 
 <blockquote> 
  <ol><li>请检查<code>环境变量</code>、<code>全局变量</code>、<code>临时变量</code>里是不是有多个地方定义了<code>相同名称</code>的变量，如果有，系统会根据优先级来取值。优先级顺序如下：<code>临时变量</code>&gt;<code>环境变量</code>&gt;<code>全局变量</code>。</li><li>请检查修改的是否是<code>本地值</code>，环境变量（或全局变量）仅读取<code>本地值</code>，而不会读取<code>远程值</code>。</li></ol> 
 </blockquote> 
 <p id="_11-web-端与客户端有何区别"><strong>11. Web 端与客户端有何区别？</strong><a href="https://apifox.com/help/faq#_11-web-%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB" rel="nofollow" title="​">​</a></p> 
 <p>Web 端与客户端在主要流程的使用上没有明显差异，都能够满足团队内的接口协作需求，但以下功能存在差异。</p> 
 <blockquote> 
  <p>以下截图均为 Web 端截图。</p> 
 </blockquote> 
 <p id="导出接口"><strong>导出接口</strong><a href="https://apifox.com/help/faq#%E5%AF%BC%E5%87%BA%E6%8E%A5%E5%8F%A3" rel="nofollow" title="​">​</a></p> 
 <p>Web 端：❌ 客户端：✅</p> 
 <p></p> 
 <p class="img-center"><img alt="" height="1188" src="https://images2.imgbox.com/f4/2c/gonEw4jZ_o.png" width="1200"></p> 
 <p id="agent-服务"><strong>Agent 服务</strong><a href="https://apifox.com/help/faq#agent-%E6%9C%8D%E5%8A%A1" rel="nofollow" title="​">​</a></p> 
 <p>Web 端：✅ 客户端：❌</p> 
 <p></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/ca/44/4XNPhCRO_o.png" width="1200"></p> 
 <p id="本地-mock-功能"><strong>本地 Mock 功能</strong><a href="https://apifox.com/help/faq#%E6%9C%AC%E5%9C%B0-mock-%E5%8A%9F%E8%83%BD" rel="nofollow" title="​">​</a></p> 
 <p>Web 端：❌ 客户端：✅</p> 
 <p></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/9e/b8/X7SX8dfh_o.png" width="1200"></p> 
 <p id="生成业务代码"><strong>生成业务代码</strong><a href="https://apifox.com/help/faq#%E7%94%9F%E6%88%90%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81" rel="nofollow" title="​">​</a></p> 
 <p>Web 端：❌ 客户端：✅</p> 
 <p></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/de/cf/jclHp7kC_o.png" width="1200"></p> 
 <p id="外部程序"><strong>外部程序</strong><a href="https://apifox.com/help/faq#%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F" rel="nofollow" title="​">​</a></p> 
 <p>Web 端：❌ 客户端：✅</p> 
 <p></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/a5/e9/aDpUHPrP_o.png" width="1200"></p> 
 <p id="调整字体大小"><strong>调整字体大小</strong><a href="https://apifox.com/help/faq#%E8%B0%83%E6%95%B4%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F" rel="nofollow" title="​">​</a></p> 
 <p>Web 端：❌ 客户端：✅</p> 
 <p></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/99/b2/IAtdxVc6_o.png" width="1200"></p> 
 <p id="网络代理"><strong>网络代理</strong><a href="https://apifox.com/help/faq#%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86" rel="nofollow" title="​">​</a></p> 
 <p>Web 端：❌ 客户端：✅</p> 
 <p id="_12-web-端与客户端数据不同步如何处理"><strong>12. Web 端与客户端数据不同步如何处理？</strong><a href="https://apifox.com/help/faq#_12-web-%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%90%8C%E6%AD%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86" rel="nofollow" title="​">​</a></p> 
 <p>若发现客户端中某个项目的接口数据与 Web 端不一致，那么有可能是因为两端数据未同步。你可以尝试以下两种方法解决：</p> 
 <ol><li>退出 Apifox 客户端后重新运行。</li><li>进入 Apifox 客户端中的项目后，点击右上角的“刷新”按钮。</li></ol> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/55/8f/8MJ5Hdiy_o.png" width="1200"></p> 
 <p></p> 
 <p></p> 
 <h2>3、<strong>Apipost</strong></h2> 
 <p></p> 
 <p>官网：<a class="link-info" href="https://www.apipost.cn/" rel="nofollow" title="https://www.apipost.cn/">https://www.apipost.cn/</a><br> 官网文档：<a class="link-info" href="https://v7-wiki.apipost.cn/docs/3/" rel="nofollow" title="https://v7-wiki.apipost.cn/docs/3/">https://v7-wiki.apipost.cn/docs/3/</a></p> 
 <p></p> 
 <p></p> 
 <h2>4、api 压测 工具</h2> 
 <p></p> 
 <p>web 压测 工具</p> 
 <blockquote> 
  <ul><li>JMeter：一个广泛使用的开源压力测试工具，可用于测试Web应用程序的性能，包括APIs。</li><li>PerformanceRunner：泽众PerformanceRunner(简称PR)是国内专业的支持http、https、websocket、tcp/ip、MQ等各种协议、10万+海量并发、可靠的性能测试工具/压力测试工具，降低了应用系统运行风险。</li><li>Gatling：这是另一个开源压力测试工具，使用Scala编写，可用于测试Web应用程序和APIs的性能。</li><li>LoadRunner：这是一种商业压力测试工具，可测试多种协议，包括Web、API等</li><li>Postman：这是一个流行的API开发工具，它还具有测试和监视API性能的功能。</li><li>Apache Bench：这是一个简单但功能强大的工具，可用于测试Web应用程序和APIs的性能。</li><li>Siege：这是另一个免费的压力测试工具，可用于测试Web应用程序和APIs的性能。</li></ul> 
 </blockquote> 
 <p class="img-center"><img alt="" height="247" src="https://images2.imgbox.com/46/30/tdg2amrL_o.png" width="638"></p> 
 <p>Jmeter 基于多线程，Locust 基于协程。 Locust 默认的 HttpSession 客户端性能有点低，做压测还是建议使用 FastHttpLocust 客户端，但是 Locust 官网也提到了，FastHttpLocust 并不能完全替代 HttpSession，这个还得取决于测试场景</p> 
 <p>发压能力：相同并发下，Locust（使用FastHttpLocust）&gt; Jmeter</p> 
 <p>并发能力：Locust和Jmeter旗鼓相当，都能满足工作需求，Jmeter 消耗的内存更高</p> 
 <p class="img-center"><img alt="" height="790" src="https://images2.imgbox.com/49/05/Qc1Po9hs_o.png" width="503"></p> 
 <p>如果只是做简单的接口测试、压力测试，没有需要写代码来扩展的特殊需求，首选 Jmeter；<br> 如果某些测试场景需要写代码来扩展，你会 Java 的话，可以选择Jmeter；<br> 如果某些测试场景需要写代码来扩展，你会 Python 的话，可以选择 Locust；<br> 如果想在单台机器发起更大的压力的话，并且 Python 代码能力不错的话，可以选择 Locust，记得一定要使用 FastHttpLocust 客户端</p> 
 <p></p> 
 <p></p> 
 <h3>蝗虫 (LOCUST)</h3> 
 <p></p> 
 <p>官网：<a class="link-info" href="https://www.locust.io/" rel="nofollow" title="https://www.locust.io/">https://www.locust.io/</a><br> 官网文档：<a class="link-info" href="https://docs.locust.io/en/latest/" rel="nofollow" title="https://docs.locust.io/en/latest/">https://docs.locust.io/en/latest/</a><br> github：<a class="link-info" href="https://github.com/locustio/locust" title="https://github.com/locustio/locust">https://github.com/locustio/locust</a></p> 
 <p></p> 
 <p>蝗虫测试本质上只是一个 Python 程序，向要测试的系统发出请求。来进行百万长连接性能测试。Locust 基于 gevent 使用协程机制，避免了系统资源调度，由此可以大幅度提高单机的并发性能。</p> 
 <p>Locust 是使用 python 开发的，自带一个Web UI，用于定义用户模型，发起测试，实时测试数据，错误统计等。</p> 
 <blockquote> 
  <p>使用类 linux 平台时请一定要修改最大文件打开数量。 可以使用 ulimit -n 查看当前支持的文件句柄，并用 ulimit -n xxxx 来进行修改。<strong><span style="background-color:#ffd900;">ulimit -n 65535</span></strong></p> 
 </blockquote> 
 <p>API</p> 
 <ul><li> 
   <ul><li><a href="https://docs.locust.io/en/latest/api.html#user-class" rel="nofollow" title="User class">User class</a></li><li><a href="https://docs.locust.io/en/latest/api.html#httpuser-class" rel="nofollow" title="HttpUser class">HttpUser class</a></li><li><a href="https://docs.locust.io/en/latest/api.html#fasthttpuser-class" rel="nofollow" title="FastHttpUser class">FastHttpUser class</a></li><li><a href="https://docs.locust.io/en/latest/api.html#taskset-class" rel="nofollow" title="TaskSet class">TaskSet class</a></li><li><a href="https://docs.locust.io/en/latest/api.html#task-decorator" rel="nofollow" title="task decorator">task decorator</a></li><li><a href="https://docs.locust.io/en/latest/api.html#tag-decorator" rel="nofollow" title="tag decorator">tag decorator</a></li><li><a href="https://docs.locust.io/en/latest/api.html#sequentialtaskset-class" rel="nofollow" title="SequentialTaskSet class">SequentialTaskSet class</a></li><li><a href="https://docs.locust.io/en/latest/api.html#module-locust.wait_time" rel="nofollow" title="Built in wait_time functions">Built in wait_time functions</a></li><li><a href="https://docs.locust.io/en/latest/api.html#httpsession-class" rel="nofollow" title="HttpSession class">HttpSession class</a></li><li><a href="https://docs.locust.io/en/latest/api.html#response-class" rel="nofollow" title="Response class">Response class</a></li><li><a href="https://docs.locust.io/en/latest/api.html#responsecontextmanager-class" rel="nofollow" title="ResponseContextManager class">ResponseContextManager class</a></li><li><a href="https://docs.locust.io/en/latest/api.html#exceptions" rel="nofollow" title="Exceptions">Exceptions</a></li><li><a href="https://docs.locust.io/en/latest/api.html#environment-class" rel="nofollow" title="Environment class">Environment class</a></li><li><a href="https://docs.locust.io/en/latest/api.html#event-hooks" rel="nofollow" title="Event hooks">Event hooks</a></li><li><a href="https://docs.locust.io/en/latest/api.html#runner-classes" rel="nofollow" title="Runner classes">Runner classes</a></li><li><a href="https://docs.locust.io/en/latest/api.html#web-ui-class" rel="nofollow" title="Web UI class">Web UI class</a></li><li><a href="https://docs.locust.io/en/latest/api.html#other" rel="nofollow" title="Other">Other</a></li></ul></li></ul> 
 <ul><li><a href="https://docs.locust.io/en/latest/changelog.html" rel="nofollow" title="Changelog Highlights">Changelog Highlights</a></li></ul> 
 <p></p> 
 <h4>安装 Locust</h4> 
 <p>安装：<strong><span style="background-color:#ffd900;">pip install locust</span></strong></p> 
 <p class="img-center"><img alt="" height="496" src="https://images2.imgbox.com/59/67/6fd9r1KJ_o.png" width="748"></p> 
 <p></p> 
 <h4><strong><span style="background-color:#ffd900;">locust --help</span></strong> </h4> 
 <p>用法: locust [options] [UserClass ...]</p> 
 <p>命令选项:</p> 
 <blockquote> 
  <p>  -h, --help                              帮助<br>   -f &lt;filename&gt;, --locustfile &lt;filename&gt;  py脚本文件<br>   --config &lt;filename&gt;                     配置文件<br>   -H &lt;base url&gt;, --host &lt;base url&gt;        要测试的URL地址<br>   -u &lt;int&gt;, --users &lt;int&gt;                 Locust并发用户的数量<br>   -r &lt;float&gt;, --spawn-rate &lt;float&gt;        生成用户的速率(每秒)<br>   -t &lt;time string&gt;, --run-time &lt;time string&gt;  运行多长时间(300s, 20m, 3h, 1h30m), 默认一直运行<br>   -l, --list            列出可用的 User classes 并退出。示例： locust -f my_py.py -l</p> 
 </blockquote> 
 <p>Web UI 选项:</p> 
 <blockquote> 
  <p>  --web-host &lt;ip&gt;       运行web绑定的网卡地址. 默认所有。<br>   --web-port &lt;port number&gt;, -P &lt;port number&gt;  运行web的绑定端口                        <br>   --headless            无头模式，关闭web界面，立即启动测试。使用-u和-t来控制用户数量和运行时间<br>   --autostart           立刻开始测试 (跟 --headless 很像, 但是不会禁用 web UI)<br>   --autoquit &lt;seconds&gt;  在运行结束后X秒完全退出蝗虫。只能与 --autostart 一起使用。<br>                         默认情况下，Locust将一直运行，直到您使用CTRL+C关闭它<br>   --web-auth &lt;username:password&gt;  基本验证。格式:username:password                        <br>   --tls-cert &lt;filename&gt;    用于通过HTTPS提供服务的TLS证书的可选路径                        <br>   --tls-key &lt;filename&gt;     用于通过HTTPS提供服务的TLS私钥的可选路径<br>   --class-picker           启用web界面中的选择框，选择 "用户类"<br>   --modern-ui              使用新的基于react的web UI前端</p> 
 </blockquote> 
 <p>Master options: 主节点选项</p> 
 <blockquote> 
  <p>worker节点连接到master节点后，master才能进行负载测试<br>   --master                           启动 master 节点，等待 worker 进行连接<br>   --master-bind-host &lt;ip&gt;            master节点绑定的网卡ip，默认绑定所有网卡。<br>   --master-bind-port &lt;port number&gt;   master监听的端口，默认 5557<br>   --expect-workers &lt;int&gt;         延迟测试，至到指定数量的worker连接成功后才进行测试<br>   --expect-workers-max-wait &lt;int&gt;   等待时间。</p> 
 </blockquote> 
 <p>Worker options: 从节点 选项</p> 
 <blockquote> 
  <p>  --worker                     设置为 worker 节点<br>   --processes &lt;int&gt;            worker的进程数<br>   --master-host &lt;hostname&gt;     master节点的ip. 默认 127.0.0.1.<br>   --master-port &lt;port number&gt;  master节点的端口. 默认 5557.</p> 
 </blockquote> 
 <p>Tag 选项:</p> 
 <blockquote> 
  <p>  可以使用@tag装饰器标记蝗虫任务。这些选项允许指定在测试期间包含或排除哪些任务。<br>   -T [&lt;tag&gt; ...], --tags [&lt;tag&gt; ...]            列出包含的测试<br>   -E [&lt;tag&gt; ...], --exclude-tags [&lt;tag&gt; ...]    列出排除的测试</p> 
 </blockquote> 
 <p>Request statistics options:</p> 
 <blockquote> 
  <p>  --csv &lt;filename&gt;      以CSV格式存储请求统计信息到文件。<br>   --csv-full-history    <br>   --print-stats         启用在UI运行中定期打印请求状态<br>   --only-summary        禁用在 --headless 运行期间定期打印请求统计信息<br>   --reset-stats         一旦 spawning 完成就重置状态<br>   --html &lt;filename&gt;     将HTML报告存储到指定的文件路径<br>   --json                将最终统计数据以JSON格式打印到stdout。</p> 
 </blockquote> 
 <p>Logging options:</p> 
 <blockquote> 
  <p>  --skip-log-setup      禁用蝗虫的日志设置。使用由Locust测试或者Python提供的。<br>   --loglevel &lt;level&gt;, -L &lt;level&gt;  DEBUG/INFO/WARNING/ERROR/CRITICAL. Default is INFO<br>   --logfile &lt;filename&gt;   log文件路径</p> 
 </blockquote> 
 <p>其他 options:</p> 
 <blockquote> 
  <p>  --show-task-ratio         打印用户类的任务执行比率表。<br>   --show-task-ratio-json    打印User类任务执行率的json数据。<br>   --version, -V         <br>   --exit-code-on-error &lt;int&gt;  设置要在测试结果包含任何失败或错误时使用的进程退出代码。默认为1<br>   -s &lt;number&gt;, --stop-timeout &lt;number&gt;<br>   --equal-weights       使用均匀分布的任务权重，覆盖locustfile中指定的权重。<br>   --enable-rebalancing  允许在测试运行期间添加或删除新工作者时自动重新平衡用户。</p> 
 </blockquote> 
 <p>User classes:</p> 
 <blockquote> 
  <p>  &lt;UserClass1 UserClass2&gt;  在命令行末尾，您可以列出要使用的用户类(可用的用户类)<br>                            可以用——list)列出。LOCUST_USER_CLASSES环境变量也可用于<br>                            指定用户类。默认是使用所有可用的User类</p> 
 </blockquote> 
 <p>示例:</p> 
 <blockquote> 
  <p>    locust -f my_test.py -H https://www.example.com<br>     locust --headless -u 100 -t 20m --processes 4 MyHttpUser AnotherUser</p> 
 </blockquote> 
 <p></p> 
 <h4>编写 web 服务</h4> 
 <p>首先使用 fastapi 启动一个 web 服务：</p> 
 <pre><code class="language-python">import fastapi
import uvicorn
from pathlib import Path
from fastapi import Request

app_main = fastapi.FastAPI()


@app_main.get("/hello")
@app_main.post("/hello")
async def func(request: Request):
    ret_val = {"response": "测试 hello 请求"}
    return ret_val


@app_main.get("/world")
@app_main.post("/world")
async def func(request: Request):
    ret_val = {"response": "测试 world 请求"}
    return ret_val


def http_server():
    uvicorn.run(f'{Path(__file__).stem}:app_main', host="0.0.0.0", port=9000)
    pass


if __name__ == '__main__':
    http_server()
    pass</code></pre> 
 <p></p> 
 <h4>使用 locust 测试 并发数</h4> 
 <p>my_test.py</p> 
 <pre><code class="language-python">from locust import HttpUser, task


class HelloWorldUser(HttpUser):
    @task
    def hello_world(self):
        self.client.get("/hello")
        self.client.get("/world")
</code></pre> 
 <p>执行命令：locust -f my_test.py --modern-ui  </p> 
 <p><img alt="" height="71" src="https://images2.imgbox.com/a5/0f/oCf3RSew_o.png" width="978"></p> 
 <p>访问 http://127.0.0.1:8089 进行测试前的配置。</p> 
 <p><img alt="" height="802" src="https://images2.imgbox.com/c5/52/TGy6Sfna_o.png" width="1200"></p> 
 <ul><li>第1个"Number of total users to simulate" 填写的是 总共将运行的用户数；<strong><span style="background-color:#ffd900;">默认1就可以。</span></strong></li><li>第2个 "Hatch rate"每秒加载的用户数；<strong><span style="background-color:#ffd900;">默认1就可以。</span></strong></li><li>第3个 "Host"，被测接口的域名或ip端口地址(带http://)</li></ul> 
 <p>配置完成后，点击 start swarm 开始进行测试，locust 就会不停的向测试服务发送请求，就可以测出每条中并发数了</p> 
 <p><img alt="" height="463" src="https://images2.imgbox.com/ba/44/NPmE4SW1_o.png" width="1200"></p> 
 <p>因为高级参数里面没有配置测试时间， 所以会一直向 <code>/hello</code> 发出 <code>/world</code> HTTP 请求，手动点击 stop 停止发送请求。</p> 
 <p></p> 
 <h4>Python 直接运行</h4> 
 <p>可以直接执行 Python 代码启动负载测试，而不是使用命令 <code>locust</code> 。</p> 
 <p>首先 创建一个 <code>Environment</code> 实例：</p> 
 <pre><code class="language-python">from locust.env import Environment

env = Environment(user_classes=[MyTestUser])</code></pre> 
 <p><code>Environment</code> 的实例方法 create_local_runner、create_master_runner 可以用来启动一个 Runner实例，Runner实例可以用来启动一个负载测试:</p> 
 <pre><code class="language-python">from locust import HttpUser, task


class HelloWorldUser(HttpUser):
    @task
    def hello_world(self):
        self.client.get("/hello")
        self.client.get("/world")


if __name__ == "__main__":
    from locust.env import Environment
    env = Environment(user_classes=[HelloWorldUser], host="http://127.0.0.1:9000")
    env.create_local_runner()
    env.runner.start(5000, spawn_rate=20)
    env.runner.greenlet.join()
</code></pre> 
 <p>也可以绕过调度和分发逻辑，手动控制生成的用户：</p> 
 <pre><code class="language-python">new_users = env.runner.spawn_users({MyUserClass.__name__: 2})
new_users[1].my_custom_token = "custom-token-2"
new_users[0].my_custom_token = "custom-token-1"</code></pre> 
 <p>上面的示例仅适用于独立/本地运行程序模式，并且是一个实验性功能。更常见/更好的方法是使用init 或 test_start 事件钩子来获取/创建令牌列表，并使用on_start和on_stop方法从该列表中读取并将它们设置在您的单个User实例上。</p> 
 <p><strong><span style="color:#fe2c24;">虽然可以通过这种方式 ( 使用 <code>create_worker_runner</code> ) 创建 locust 工作线程，但这几乎没有意义。每个工作线程都需要在单独的Python进程中，直接与工作线程运行程序交互可能会破坏一些东西。只需使用常规 locust --worker ...命令启动工作程序即可。</span></strong></p> 
 <p>还可以使用 <code>Environment</code> 实例 <code>create_web_ui</code> 的方法启动一个 Web UI，该 UI 可用于查看统计信息并控制运行器（例如启动和停止负载测试）：</p> 
 <pre><code class="language-python">from locust import HttpUser, task


class HelloWorldUser(HttpUser):
    @task
    def hello_world(self):
        self.client.get("/hello")
        self.client.get("/world")


if __name__ == "__main__":
    from locust.env import Environment
    env = Environment(user_classes=[HelloWorldUser], host="http://127.0.0.1:9000")
    env.create_local_runner()
    env.create_web_ui()
    env.web_ui.greenlet.join()
</code></pre> 
 <pre><code class="language-python">import os
import sys
from locust import HttpUser, task


class HelloWorldUser(HttpUser):
    @task
    def hello_world(self):
        self.client.get("/hello")
        self.client.get("/world")


if __name__ == "__main__":
    script_file_path = sys.argv[0]
    print(script_file_path)
    os.system(f"locust -f {script_file_path}")
</code></pre> 
 <p><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">完整示例</span></span></strong></p> 
 <pre><code class="language-python">#!/usr/bin/env python3
import gevent
from locust import HttpUser, task, events
from locust.env import Environment
from locust.stats import stats_printer, stats_history
from locust.log import setup_logging

setup_logging("INFO", None)


class MyUser(HttpUser):
    host = "https://docs.locust.io"

    @task
    def t(self):
        self.client.get("/")


# setup Environment and Runner
env = Environment(user_classes=[MyUser], events=events)
runner = env.create_local_runner()

# start a WebUI instance
web_ui = env.create_web_ui("127.0.0.1", 8089)

# execute init event handlers (only really needed if you have registered any)
env.events.init.fire(environment=env, runner=runner, web_ui=web_ui)

# start a greenlet that periodically outputs the current stats
gevent.spawn(stats_printer(env.stats))

# start a greenlet that save current stats to history
gevent.spawn(stats_history, env.runner)

# start the test
runner.start(1, spawn_rate=10)

# in 60 seconds stop the runner
gevent.spawn_later(60, lambda: runner.quit())

# wait for the greenlets
runner.greenlet.join()

# stop the web server for good measures
web_ui.stop()</code></pre> 
 <p></p> 
 <h4>示例：百万长连接性能测试</h4> 
 <p>：<a class="link-info" href="https://zhuanlan.zhihu.com/p/97577744" rel="nofollow" title="https://zhuanlan.zhihu.com/p/97577744">https://zhuanlan.zhihu.com/p/97577744</a></p> 
 <pre><code class="language-python"># locust_test1.py
from locust import HttpLocust, TaskSet, task, between

class UserBehavior(TaskSet):
    def on_start(self):
        # on_start是在task中任何用户开始时都会调用的部分我们一般来进行初始化
        self.login()

    def on_stop(self):
        # on_stop 在停止时调用，我们可以用来回收资源
        self.logout()

    def login(self):
        self.client.post("/login", {"username":"ellen_key", "password":"education"})

    def logout(self):
        self.client.post("/logout", {"username":"ellen_key", "password":"education"})

    # @task装饰器，更方便我们的使用，所有带@task都会进行调用
    @task(2)
    def index(self):
        # 2/3的概率调用获得首页方法
        self.client.get("/")

    @task(1)
    def profile(self):
        # 1/3概率调用获得用户信息方法
        self.client.get("/profile")

class WebsiteUser(HttpLocust):
    host = "http://test.cn"
    # 我们首先给task_set赋值
    task_set = UserBehavior
    # 设定下次调用等待时间，单位为秒
    wait_time = between(5, 9)</code></pre> 
 <p>接下来我们开始启动测试</p> 
 <ul><li>启用 WEB 界面：<strong><span style="background-color:#ffd900;">locust -f locust_test1.py</span></strong> 执行后可以去 WEB 界面 http://127.0.0.1:8089 进行控制，</li><li>启用无WEB界面的方案 <strong><span style="background-color:#ffd900;">locust -f locust_test1.py --no-web -c 100 -r 20 -t 20m</span></strong>  模拟100用户，按20来进行递增，请求20分钟。</li></ul> 
 <p></p> 
 <p><strong>主从模式启动</strong></p> 
 <blockquote> 
  <p>locust -f locst_test1.py --master<br> locust -f locst_test1.py --slave --master-host=192.168.110.19</p> 
 </blockquote> 
 <p><strong>长连接脚本</strong></p> 
 <p>简单的安装和QG我们都看过了，现在我们开始实战tcp长连接方式。因内部通信协议保密我们使用之前我开源的一个<a href="https://github.com/guohai163/earth-server" title="《超快地球物理坐标计算服务器》">《超快地球物理坐标计算服务器》</a>来进行演示。首先我们使用docker来启动服务器 <code>docker run --rm -t -p 40000:40000 gcontainer/earth-server earth_server -c</code></p> 
 <p>我们首先创建一个Socket连接的基础类，主要负责socket连接的建立、收发消息、关闭</p> 
 <pre><code class="language-python">class SocketClient(object):

    def __init__(self):
        # 仅在新建实例的时候创建socket.
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    def __getattr__(self, name):
        conn = self._socket
        def wrapper(*args, **kwargs):
            # 根据后面做的业务类，不同的方法做不同的处理
            if name == "connect":
                try:
                    conn.connect(args[0])
                except Exception as e:
                    print(e)
            elif name == "send":
                print(' '.join(hex(ord(i)) for i in args[0]))
                conn.sendall(args[0])
                data = conn.recv(1024)
                print(data)
            elif name == "close":
                conn.close()
        return wrapper</code></pre> 
 <p>接下来我们创建一个实际的业务处理类UserBehavior集成自TaskSet</p> 
 <pre><code class="language-python">class UserBehavior(TaskSet):
    def on_start(self):
        # 该方法每用户启动时调用进行连接打开
        self.client.connect((self.locust.host, self.locust.port))
    def on_stop(self):
        # 该方法当程序结束时每用户进行调用，关闭连接
        self.client.close()

    @task(1)
    def sendAddCmd(self):
        # 处理坐标的增加1%的概率调用 该方法
        lat, log = generate_random_gps()
        dataBody = [
            'add ',
            ranstr(6),
            ' ',
            format(log,'f'),
            ' ',
            format(lat,'f'),
            '\x0d','\x0a']
        start_time = time.time()
        # 接下来做实际的网络调用，并通过request_failure和request_success方法分别统计成功和失败的次数以及所消耗的时间
        try:
            self.client.send("".join(dataBody))
        except Exception as e:
            total_time = int((time.time() - start_time) * 1000)
            events.request_failure.fire(request_type="earthtest", name="add", response_time=total_time, response_length=0, exception=e)
        else:
            total_time = int((time.time() - start_time) * 1000)
            events.request_success.fire(request_type="earthtest", name="add", response_time=total_time, response_length=0)
    @task(99)
    def sendGetCmd(self):
        lat, log = generate_random_gps()
        dataBody = [
            'get ',
            format(log,'f'),
            ' ',
            format(lat,'f'),
            ' 5',
            '\x0d','\x0a']
        start_time = time.time()
        try:
            self.client.send("".join(dataBody))
        except Exception as e:
            total_time = int((time.time() - start_time) * 1000)
            events.request_failure.fire(request_type="earthtest", name="get", response_time=total_time, response_length=0, exception=e)
        else:
            total_time = int((time.time() - start_time) * 1000)
            events.request_success.fire(request_type="earthtest", name="get", response_time=total_time, response_length=0)</code></pre> 
 <p>最终实现我们的启动类，一个完整的调用过程结束</p> 
 <pre><code class="language-python">class SocketUser(SocketLocust):
    # 目标地址
    host = "127.0.0.1"
    # 目标端口
    port = 40000
    task_set = UserBehavior
    wait_time = between(0.1, 1)</code></pre> 
 <p>我们模拟200用户启动下试试脚本。<code>locust -f locust_tcptest.py --no-web -c 200 -r 50 -t 10m</code></p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/00/aa/cTvxkbkF_o.jpg"></p> 
 <p>参考资料</p> 
 <ul><li><a href="https://github.com/guohai163/earth-server/blob/master/tools/locustscript.py" title="完整代码">完整代码</a></li><li><a href="https://github.com/guohai163/earth-server" title="超快地球物理坐标服务器">超快地球物理坐标服务器</a></li><li><a href="https://docs.locust.io/en/stable/" rel="nofollow" title="Locust官网文档">Locust官网文档</a></li></ul> 
 <p></p> 
 <h4>示例：变成性能测试老司机</h4> 
 <p>：<a class="link-info" href="https://zhuanlan.zhihu.com/p/143892229" rel="nofollow" title="https://zhuanlan.zhihu.com/p/143892229">https://zhuanlan.zhihu.com/p/143892229</a></p> 
 <p></p> 
 <h3><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">编写 locustfile</span></span></strong></h3> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">locustfile 文件</span></span></strong></h4> 
 <p>locust 文件只是一个普通的 Python 模块</p> 
 <p>一个更完整/更现实的测试示例：</p> 
 <pre><code class="language-python">import time
from locust import HttpUser, task, between

class QuickstartUser(HttpUser):
    wait_time = between(1, 5)  # 使模拟用户在执行每个任务（见下文）后等待 1 到 5 秒

    @task
    def hello_world(self):
        self.client.get("/hello")
        self.client.get("/world")

    @task(3)
    def view_items(self):
        for item_id in range(10):
            self.client.get(f"/item?id={item_id}", name="/item")
            time.sleep(1)

    def on_start(self):
        self.client.post("/login", json={"username":"foo", "password":"bar"})</code></pre> 
 <ul><li>继承 <code>HttpUser</code> ，为每个用户提供一个 <code>client</code> 属性，该属性是 <code>HttpSession</code> 的实例，可用于向我们要加载测试的目标系统发出 HTTP 请求。当测试开始时，Locust 将为其模拟的每个用户创建一个此类的实例，并且每个用户都将开始在他们自己的绿色 gevent 线程中运行。要使文件成为有效的 locustfile，它必须包含至少一个继承自 <code>User</code> 的类。</li><li><code>@task</code> 方法是 locust 文件的核心。对于每个正在运行的用户，Locust 都会创建一个 greenlet（微线程），它将调用这些方法。其中一个方法被赋予了更高的权重3，没有权重时任务是随机选择的，分配不同的权重，代表执行的次数更多，这里权重是3，说明调用view_items的次数可能是 hello_world 的 三倍</li></ul> 
 <p>HttpUser 不是真正的浏览器，因此不会解析 HTML 响应来加载资源或呈现页面。不过，它会跟踪 cookie。</p> 
 <pre><code class="language-python">@task(3)
def view_items(self):
    for item_id in range(10):
        self.client.get(f"/item?id={item_id}", name="/item")
        time.sleep(1)</code></pre> 
 <p>在 <code>view_items</code> 任务中，通过查询参数载入了10个不同的url，为了不让在locust的统计状态中显示，可以使用 <code>"/item"</code> 参数进行分组显示</p> 
 <p></p> 
 <h4>自动生成 <strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">locustfile 文件</span></span></strong></h4> 
 <p>对于不习惯编写 locustfile 的初学者特别有用。har2locust 仍处于测试阶段。它可能并不总是生成正确的 locustfile，并且其界面可能会在版本之间更改。</p> 
 <p></p> 
 <h3>User 类</h3> 
 <p>用户类表示系统的一种用户/方案类型。当进行测试运行时，您可以指定要模拟的并发用户数，Locust 将为每个用户创建一个实例。你可以将任何你喜欢的属性添加到这些类/实例中，但有一些属性对 Locust 有特殊意义：</p> 
 <ul><li><code>wait_time</code> 的方法可以很容易地在每次任务执行后引入延迟。如果未指定wait_time，则下一个任务将在完成后立即执行。</li><li><code>constant</code> 在固定的时间内</li><li><code>between</code> 最小值和最大值之间的随机时间</li></ul> 
 <p>示例：使每个用户在每次任务执行之间等待 0.5 到 10 秒：</p> 
 <pre><code class="language-python">from locust import User, task, between

class MyUser(User):
    @task
    def my_task(self):
        print("executing my_task")

    wait_time = between(0.5, 10)</code></pre> 
 <ul><li><code>constant_throughput</code> 用于确保任务每秒运行（最多）X 次的自适应时间。</li><li><code>constant_pacing</code> 用于确保任务（最多）每 X 秒运行一次的自适应时间（它是 constant_throughput 的数学倒数）。</li></ul> 
 <p>例如，如果希望 Locust 在峰值负载下每秒运行 500 次任务迭代，则可以使用 wait_time = constant_throughput（0.1） 和 5000 的用户计数。</p> 
 <p>等待时间只会限制吞吐量，而不能启动新用户来达到目标。因此，在我们的示例中，如果任务迭代时间超过 10 秒，则吞吐量将小于 500。</p> 
 <p>等待时间是在任务执行后应用的，因此，如果您的生成率很高，您最终可能会在爬坡期间超过您的目标。</p> 
 <p></p> 
 <h4>weight 和 fixed_count 属性</h4> 
 <p>如果希望模拟更多特定类型的用户，则可以在这些类上设置权重属性。例如，网络用户的可能性是移动用户的三倍：@task采用可选的权重参数，该参数可用于指定任务的执行比率</p> 
 <pre><code class="language-python">class WebUser(User):
    weight = 3
    ...

class MobileUser(User):
    weight = 1
    ...</code></pre> 
 <p>也可以设置属性 <code>fixed_count</code> 。在这种情况下，权重属性将被忽略，并且将生成确切的计数用户。首先生成这些用户。在下面的示例中，将只生成一个 AdminUser 实例，以便进行一些特定的工作，更准确地控制请求计数，而不受用户总数的影响。</p> 
 <pre><code class="language-python">class AdminUser(User):
    wait_time = constant(600)
    fixed_count = 1

    @task
    def restart_app(self):
        ...

class WebUser(User):
    ...</code></pre> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">host 属性</span></span></strong></h4> 
 <p>host 属性是要测试的主机的 URL 前缀（例如 <code>https://google.com</code> ）。它会自动添加到请求中，因此您可以这样做 <code>self.client.get("/")</code> 。可以在 Locust 的 Web UI 中或使用该 <code>--host</code> 选项在命令行上覆盖此值。</p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">@tasks 和  task属性</span></span></strong></h4> 
 <p>启动负载测试时，将为每个模拟用户创建一个 User 类的实例，并且这些用户将开始在自己的绿色线程中运行。当这些用户运行时，他们会选择他们执行的任务，休眠一段时间，然后选择一个新任务，依此类推。User 类用 <code>@task</code> 装饰器将任务声明为其下的方法，也可以使用 tasks 属性指定任务</p> 
 <p><strong><code>@task</code> 装饰器</strong>：为用户添加任务的最简单方法是使用 <code>@task</code> 装饰器。</p> 
 <pre><code class="language-python">from locust import User, task, constant

class MyUser(User):
    wait_time = constant(1)

    @task
    def my_task(self):
        print("User instance (%r) executing my_task" % self)</code></pre> 
 <p><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">tasks 属性：</span></span></strong>定义用户任务的另一种方法是设置 <code>tasks</code> 属性。</p> 
 <p>tasks 属性可以是 Tasks 列表，也可以是 字典，其中 Task 是 python 可调用对象或 TaskSet 类。如果任务是普通的 python 函数，则它们会收到一个参数，即执行任务的 User 实例。</p> 
 <pre><code class="language-python">from locust import User, constant

def my_task(user):
    pass

class MyUser(User):
    tasks = [my_task]
    wait_time = constant(1)</code></pre> 
 <p>如果将 tasks 属性指定为列表，则每次执行任务时，都会从 tasks 属性中随机选择该任务。但是，如果 tasks 是一个字典 - 将可调用对象作为键，int 作为值 - 将随机选择要执行的任务，但以 int 作为比率。因此，对于如下所示的任务：{my_task: 3, another_task: 1}  表示 my_task被执行可能性是another_task的 3 倍。在内部，上面的字典实际上将扩展为一个列表（并且属性 <code>tasks</code> 已更新），如下所示：[my_task, my_task, my_task, another_task]，然后使用 Python <code>random.choice()</code> 从列表中选择任务。</p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">@tag装饰器</span></span></strong></h4> 
 <p>使用 <code>@tag</code> 装饰器标记任务，然后通过 <code>--tags</code> 和 <code>--exclude-tags</code> 参数来选择在测试期间执行的任务。示例：</p> 
 <pre><code class="language-python">from locust import User, constant, task, tag

class MyUser(User):
    wait_time = constant(1)

    @tag('tag1')
    @task
    def task1(self):
        pass

    @tag('tag1', 'tag2')
    @task
    def task2(self):
        pass

    @tag('tag3')
    @task
    def task3(self):
        pass

    @task
    def task4(self):
        pass</code></pre> 
 <p>使用 <code>--tags tag1</code> 启动此测试，则在测试期间将仅执行 task1 和 task2。如果以 <code>--tags tag2 tag3</code> 启动它，则只会执行 task2 和 task3。</p> 
 <p></p> 
 <h4>event 事件</h4> 
 <p>如果你想在测试中运行一些设置代码，通常把它放在 locustfile 的模块级别就足够了，但有时你需要在运行中的特定时间做一些事情。为了满足这一需求，Locust 提供了事件钩子。</p> 
 <pre><code class="language-python">from locust import events

@events.test_start.add_listener
def on_test_start(environment, **kwargs):
    print("A new test is starting")

@events.test_stop.add_listener
def on_test_stop(environment, **kwargs):
    print("A new test is ending")</code></pre> 
 <p></p> 
 <h4>init 初始化</h4> 
 <p>该 <code>init</code> 事件在每个 locust 进程开始时触发。这在分布式模式下特别有用，在分布式模式下，每个工作进程（而不是每个用户）都需要机会进行一些初始化。例如，假设您有一些全局状态，从此过程中生成的所有用户都需要该状态：</p> 
 <pre><code class="language-python">from locust import events
from locust.runners import MasterRunner

@events.init.add_listener
def on_locust_init(environment, **kwargs):
    if isinstance(environment.runner, MasterRunner):
        print("I'm on master node")
    else:
        print("I'm on a worker or standalone node")</code></pre> 
 <p><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">其他事件</span></span></strong></p> 
 <p>参阅<span style="color:#404040;"><span style="background-color:#fcfcfc;"> </span></span><a class="reference internal" href="https://docs.locust.io/en/latest/extending-locust.html#extending-locust" rel="nofollow" title="extending locust using event hooks">extending locust using event hooks</a><span style="color:#404040;"><span style="background-color:#fcfcfc;"> </span></span>以获取其他事件，以及如何使用它们的更多示例。</p> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">on_start 和 on_stop 方法</span></span></strong></h4> 
 <p></p> 
 <h3><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">HttpUser 类</span></span></strong></h3> 
 <p><code>HttpUser</code> 是最常用 <code>User</code> 的。它添加了一个 <code>client</code> 用于发出 HTTP 请求的属性。</p> 
 <pre><code class="language-python">from locust import HttpUser, task, between

class MyUser(HttpUser):
    wait_time = between(5, 15)

    @task(4)
    def index(self):
        self.client.get("/")

    @task(1)
    def about(self):
        self.client.get("/about/")</code></pre> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">client 属性 / HttpSession</span></span></strong></h4> 
 <p><code>client</code> 是 <code>HttpSession</code> 的实例。HttpSession 是 <code>requests.Session</code> 的子类/包装器。就像 <code>requests.Session</code> 一样，它会在请求之间保留 cookie，因此可以轻松用于登录网站。</p> 
 <blockquote> 
  <p>response = self.client.post("/login", {"username":"testuser", "password":"secret"})<br> print("Response status code:", response.status_code)<br> print("Response text:", response.text)<br> response = self.client.get("/my-profile")</p> 
 </blockquote> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">验证 response</span></span></strong></h4> 
 <p>如果 HTTP 响应代码正常 （&lt;400），则认为请求成功，但对响应进行一些额外的验证通常很有用。可以使用 catch_response 参数、with 语句和对 response.failure（） 的调用将请求标记为失败</p> 
 <pre><code class="language-python">with self.client.get("/", catch_response=True) as response:
    if response.text != "Success":
        response.failure("Got wrong response")
    elif response.elapsed.total_seconds() &gt; 0.5:
        response.failure("Request took too long")</code></pre> 
 <p>您还可以将请求标记为成功，即使响应代码错误：</p> 
 <pre><code class="language-python">with self.client.get("/does_not_exist/", catch_response=True) as response:
    if response.status_code == 404:
        response.success()</code></pre> 
 <p>您甚至可以通过抛出异常，然后在 with-block 之外捕获它来完全避免记录请求。或者你可以抛出一个 locust 异常让 locust 捕捉到它。</p> 
 <pre><code class="language-python">from locust.exception import RescheduleTask
...
with self.client.get("/does_not_exist/", catch_response=True) as response:
    if response.status_code == 404:
        raise RescheduleTask()</code></pre> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">对请求进行分组</span></span></strong></h4> 
 <p>网站的 URL 包含某种动态参数的页面很常见。通常，在用户的统计信息中将这些 URL 组合在一起是有意义的。这可以通过将 name 参数传递给 <code>HttpSession's</code> 不同的请求方法来完成。</p> 
 <pre><code class="language-python">for i in range(10):
    self.client.get("/blog?id=%i" % i, name="/blog?id=[id]")</code></pre> 
 <p>在某些情况下，可能无法将参数传递到请求函数中，例如在与包装请求会话的库/SDK 交互时。通过设置 <code>client.request_name</code> 属性，提供了对请求进行分组的另一种方法。</p> 
 <pre><code class="language-python">self.client.request_name="/blog?id=[id]"
for i in range(10):
    self.client.get("/blog?id=%i" % i)
self.client.request_name=None</code></pre> 
 <p>如果要使用最少的样板链接多个分组，则可以使用 <code>client.rename_request()</code> 上下文管理器。</p> 
 <pre><code class="language-python">@task
def multiple_groupings_example(self):
    # Statistics for these requests will be grouped under: /blog/?id=[id]
    with self.client.rename_request("/blog?id=[id]"):
        for i in range(10):
            self.client.get("/blog?id=%i" % i)

    # Statistics for these requests will be grouped under: /article/?id=[id]
    with self.client.rename_request("/article?id=[id]"):
        for i in range(10):
            self.client.get("/article?id=%i" % i)</code></pre> 
 <p>使用 catch_response 并直接访问request_meta，您甚至可以根据响应中的某些内容重命名请求。</p> 
 <pre><code class="language-python">with self.client.get("/", catch_response=True) as resp:
    resp.request_meta["name"] = resp.json()["name"]</code></pre> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">HTTP 代理设置</span></span></strong></h4> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">连接池</span></span></strong></h4> 
 <p>由于每个 <code>HttpUser</code> 都会创建新的 <code>HttpSession</code> ，所以每个用户实例都有自己的连接池。这类似于真实用户与 Web 服务器的交互方式。</p> 
 <p>但是，如果要在所有用户之间共享连接，则可以使用单个池管理器。为此，请将 class 属性设置为 <code>pool_manager</code> 的 <code>urllib3.PoolManager</code> 实例。</p> 
 <pre><code class="language-python">from locust import HttpUser
from urllib3 import PoolManager

class MyUser(HttpUser):
    # All users will be limited to 10 concurrent connections at most.
    pool_manager = PoolManager(maxsize=10, block=True)</code></pre> 
 <p></p> 
 <h3><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">TaskSets </span></span></strong><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">任务集</span></span></strong></h3> 
 <p>TaskSets 是一种对分层网站/系统进行结构化测试的方法。You can <a href="https://docs.locust.io/en/latest/tasksets.html#tasksets" rel="nofollow" title="read more about it here">read more about it here</a>.</p> 
 <p></p> 
 <h3><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">Examples 示例</span></span></strong></h3> 
 <p>这里有很多 locustfile 示例： <a href="https://github.com/locustio/locust/tree/master/examples" title="here">here</a></p> 
 <p></p> 
 <h3><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">分布式 负载</span></span></strong></h3> 
 <p>如果测试计划很复杂，或者想要运行更多负载，则需要横向扩展到多个进程，甚至可能是多台计算机。由于 Python 无法充分利用每个进程的多个内核（参见 GIL），因此您可能需要为每个处理器内核运行一个工作器实例才能访问所有计算能力。</p> 
 <p>为此，您可以使用该 <code>--master</code> 标志在主模式下启动一个 Locust 实例，并使用该 <code>--worker</code> 标志启动多个工作实例。如果工作线程与主服务器不在同一台计算机上，则用于 <code>--master-host</code> 将他们指向运行主服务器的计算机的 IP/主机名。</p> 
 <p>为了简化此操作，您可以使用该 <code>--processes</code> 标志启动多个实例。默认情况下，它将启动一个主进程和指定数量的工作进程。与 <code>--worker</code> 它结合使用只会启动 worker。</p> 
 <p>子进程使用 fork 启动，这在 Windows 中不可用。</p> 
 <p>主实例运行 Locust 的 Web 界面，并告诉 worker 何时生成/停止用户。工作线程实例运行您的用户并将统计信息发送回主服务器。主实例本身不运行任何用户。</p> 
 <p>每个工作线程可以运行的用户数几乎没有限制。Locust/gevent 每个进程可以运行数千甚至数万个用户，只要它们的总请求速率 （RPS） 不太高。</p> 
 <p>如果 Locust 即将耗尽 CPU 资源，它将记录警告。如果没有警告，您可以非常确定您的测试不受负载生成器 CPU 的限制。</p> 
 <h4><strong>示例 1：单台机器</strong></h4> 
 <blockquote> 
  <p>启动一个主进程和 4 个工作进程非常简单：<strong><span style="background-color:#ffd900;">locust --processes 4</span></strong></p> 
  <p>也可以自动检测机器中的内核数量，并为每个内核启动一个工作线程：<strong><span style="background-color:#ffd900;">locust --processes -1</span></strong></p> 
 </blockquote> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">示例 2：多台机器</span></span></strong></h4> 
 <blockquote> 
  <p>在一台机器上以主模式启动蝗虫：<strong><span style="background-color:#ffd900;">locust -f my_locustfile.py --master</span></strong></p> 
  <p>然后在每台工作机器上：<strong><span style="background-color:#ffd900;">locust -f my_locustfile.py --worker --master-host &lt;your master's address&gt; --processes 4</span></strong></p> 
 </blockquote> 
 <p>请注意，主节点和工作节点都需要访问 locustfile，它不会自动从 master 发送到 worker。但是你可以使用 locust-swarm 来自动化它。</p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">跨节点通信</span></span></strong></h4> 
 <p>在分布式模式下运行 Locust 时，您可能希望在主节点和工作节点之间进行通信以协调数据。这可以通过使用内置消息挂钩的自定义消息轻松完成：</p> 
 <pre><code class="language-python">from locust import events
from locust.runners import MasterRunner, WorkerRunner

# Fired when the worker receives a message of type 'test_users'
def setup_test_users(environment, msg, **kwargs):
    for user in msg.data:
        print(f"User {user['name']} received")
    environment.runner.send_message('acknowledge_users', f"Thanks for the {len(msg.data)} users!")

# Fired when the master receives a message of type 'acknowledge_users'
def on_acknowledge(msg, **kwargs):
    print(msg.data)

@events.init.add_listener
def on_locust_init(environment, **_kwargs):
    if not isinstance(environment.runner, MasterRunner):
        environment.runner.register_message('test_users', setup_test_users)
    if not isinstance(environment.runner, WorkerRunner):
        environment.runner.register_message('acknowledge_users', on_acknowledge)

@events.test_start.add_listener
def on_test_start(environment, **_kwargs):
    if not isinstance(environment.runner, WorkerRunner):
        users = [
            {"name": "User1"},
            {"name": "User2"},
            {"name": "User3"},
        ]
        environment.runner.send_message('test_users', users)</code></pre> 
 <p></p> 
 <h3><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">FastHttpUser</span></span></strong></h3> 
 <p>使用更快的 HTTP 客户端提高性能: <a href="https://docs.locust.io/en/latest/increase-performance.html#increase-performance" rel="nofollow" title="Increase performance with a faster HTTP client">Increase performance with a faster HTTP client</a>.</p> 
 <p>Locust 的默认 HTTP 客户端使用 python-requests。</p> 
 <pre><code class="language-python">from locust import task, FastHttpUser

class MyUser(FastHttpUser):
    @task
    def index(self):
        response = self.client.get("/")</code></pre> 
 <p>Locust 还附带使用 geventhttpclient 实现的 <code>FastHttpUser</code> 以非常高的吞吐量运行测试。它提供了一个非常相似的 API，并且使用的 CPU 时间要少得多，有时在给定硬件上每秒的最大请求数会增加 5 倍到 6 倍。假设单个 Locust 进程（仅限于一个 CPU 内核）使用 FastHttpUser 每秒可以执行大约 16000 个请求，使用 HttpUser 每秒可以执行 4000 个请求</p> 
 <p>只要负载生成器 CPU 没有过载，FastHttpUser 的响应时间应该与 HttpUser 的响应时间几乎相同。它不会更快地提出单个请求。</p> 
 <p>单个 FastHttpUser/geventhttpclient 会话可以并发执行请求，只需为每个请求启动 greenlets：</p> 
 <pre><code class="language-python">@task
def t(self):
    def concurrent_request(url):
        self.client.get(url)

    pool = gevent.pool.Pool()
    urls = ["/url1", "/url2", "/url3"]
    for url in urls:
        pool.spawn(concurrent_request, url)
    pool.join()</code></pre> 
 <p></p> 
 <h3><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">在调试器中运行测试</span></span></strong></h3> 
 <p>在调试器中运行 Locust 在开发测试时非常有用。除此之外，您可以检查特定的响应或检查某些用户实例变量。</p> 
 <p>但是调试器有时会遇到像 Locust 这样的复杂 gevent 应用程序的问题，而且框架本身发生了很多事情，您可能不感兴趣。为了简化这一点，Locust 提供了一种称为 <code>run_single_user</code> ：</p> 
 <pre><code class="language-python">from locust import HttpUser, task, run_single_user


class QuickstartUser(HttpUser):
    host = "http://localhost"

    @task
    def hello_world(self):
        with self.client.get("/hello", catch_response=True) as resp:
            pass  # maybe set a breakpoint here to analyze the resp object?


# if launched directly, e.g. "python3 debugging.py", not "locust -f debugging.py"
if __name__ == "__main__":
    run_single_user(QuickstartUser)</code></pre> 
 <p>它隐式地为请求事件注册一个事件处理程序，以打印有关每个请求的一些统计信息：</p> 
 <p>可以通过将参数指定为 <code>run_single_user</code> 来准确配置打印的内容。</p> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">打印 HTTP 通信</span></span></strong></h4> 
 <p>对于 <code>HttpUser</code> （ python-requests）：</p> 
 <pre><code class="language-python"># put this at the top of your locustfile (or just before the request you want to trace)
import logging
from http.client import HTTPConnection

HTTPConnection.debuglevel = 1
logging.basicConfig()
logging.getLogger().setLevel(logging.DEBUG)
requests_log = logging.getLogger("requests.packages.urllib3")
requests_log.setLevel(logging.DEBUG)
requests_log.propagate = True</code></pre> 
 <p>对于 <code>FastHttpUser</code> （ geventhttpclient）：</p> 
 <pre><code class="language-python">import sys
...

class MyUser(FastHttpUser):
    @task
    def t(self):
        self.client.get("http://example.com/", debug_stream=sys.stderr)</code></pre> 
 <p></p> 
 <h3>无头 模式</h3> 
 <p>可以在没有 Web UI 的情况下运行 locust 通过将 <code>--headless</code> 与 <code>-u/--users</code> 和 <code>-r/--spawn-rate</code> 一起使用：<strong><span style="background-color:#ffd900;">locust -f locust_files/my_locust_file.py --headless -u 100 -r 5</span></strong></p> 
 <p>即使在无头模式下，您也可以在测试运行时更改用户计数。按下 <code>w</code> 可添加 1 个用户或 <code>W</code> 添加 10 个用户。按下 <code>s</code> 可移除 1 或 <code>S</code> 移除 10。</p> 
 <blockquote> 
  <p>若要指定测试的运行时间，请使用 <code>-t/--run-time</code> ：</p> 
  <p>locust --headless -u 100 --run-time 1h30m<br> $ locust --headless -u 100 --run-time 60 # default unit is seconds</p> 
 </blockquote> 
 <p>默认情况下，Locust 会立即停止您的任务（甚至无需等待请求完成）。要给正在运行的任务一些时间来完成迭代，请使用 <code>-s/--stop-timeout</code> ：locust --headless --run-time 1h30m --stop-timeout 10s</p> 
 <p>如果要在没有 Web UI 的情况下运行 Locust 分布式，则应在启动主节点时指定 <code>--expect-workers</code> 选项，以指定预期连接的工作节点数。然后，它将等到许多工作节点连接后再开始测试。</p> 
 <p></p> 
 <h3>Event hooks</h3> 
 <p>Locust 带有许多事件钩子，可用于以不同的方式扩展 Locust。</p> 
 <p>例如，下面介绍如何设置在请求完成后触发的事件侦听器：</p> 
 <pre><code class="language-python">from locust import events

@events.request.add_listener
def my_request_handler(request_type, name, response_time, response_length, response,
                       context, exception, start_time, url, **kwargs):
    if exception:
        print(f"Request to {name} failed with exception {exception}")
    else:
        print(f"Successfully made a request to: {name}")
        print(f"The response was {response.text}")</code></pre> 
 <p>在分布式模式下运行 locust 时，在运行测试之前在工作节点上进行一些设置可能很有用。您可以通过检查节点的类型来检查以确保您没有在主节点上运行 <code>runner</code> ：</p> 
 <pre><code class="language-python">from locust import events
from locust.runners import MasterRunner

@events.test_start.add_listener
def on_test_start(environment, **kwargs):
    if not isinstance(environment.runner, MasterRunner):
        print("Beginning test setup")
    else:
        print("Started test from Master node")

@events.test_stop.add_listener
def on_test_stop(environment, **kwargs):
    if not isinstance(environment.runner, MasterRunner):
        print("Cleaning up test data")
    else:
        print("Stopped test from Master node")</code></pre> 
 <p>若要查看可用事件的完整列表，请参阅事件挂钩。<a href="https://docs.locust.io/en/latest/api.html#events" rel="nofollow" title="Event hooks">Event hooks</a>.</p> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">请求上下文</span></span></strong></h4> 
 <p>有一个 <code>request event</code> context 参数，使您能够传递有关请求的数据（例如用户名、标签等）。它可以直接在对请求方法的调用中设置，也可以在用户级别通过重写 User.context（） 方法进行设置。</p> 
 <pre><code class="language-python">class MyUser(HttpUser):
    @task
    def t(self):
        self.client.post("/login", json={"username": "foo"})
        self.client.get("/other_request", context={"username": "foo"})

    @events.request.add_listener
    def on_request(context, **kwargs):
        if context:
            print(context["username"])</code></pre> 
 <p>来自用户实例的上下文：</p> 
 <pre><code class="language-python">class MyUser(HttpUser):
    def context(self):
        return {"username": self.username}

    @task
    def t(self):
        self.username = "foo"
        self.client.post("/login", json={"username": self.username})

    @events.request.add_listener
    def on_request(context, **kwargs):
        print(context["username"])</code></pre> 
 <p>响应中值的上下文，使用catch_response：</p> 
 <pre><code class="language-python">with self.client.get("/", catch_response=True) as resp:
    resp.request_meta["context"]["requestId"] = resp.json()["requestId"]</code></pre> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">添加 Web 路由</span></span></strong></h4> 
 <p>Locust 使用 Flask 来提供 Web UI，因此很容易将 Web 端点添加到 Web UI。通过侦听事件 <code>init</code> ，我们可以检索对 Flask 应用实例的引用，并使用它来设置新路由：</p> 
 <pre><code class="language-python">from locust import events

@events.init.add_listener
def on_locust_init(environment, **kw):
    @environment.web_ui.app.route("/added_page")
    def my_added_page():
        return "Another page"</code></pre> 
 <p>您现在应该能够启动 Locust 并浏览到 http://127.0.0.1:8089/added_page</p> 
 <p></p> 
 <h3><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">扩展 Web UI</span></span></strong></h3> 
 <p>作为添加简单 Web 路由的替代方法，您可以使用 Flask 蓝图和模板不仅可以添加路由，还可以扩展 Web UI，以便与内置的 Locust 统计信息一起显示自定义数据。这更高级，因为它还涉及编写和包含路由提供的 HTML 和 Javascript 文件，但可以大大增强 Web UI 的实用性和可定制性。</p> 
 <p>扩展 Web UI 的工作示例，包括 HTML 和 Javascript 示例文件，可以在 Locust 源代码的 examples 目录中找到。</p> 
 <p></p> 
 <h3><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">运行后台 greenlet </span></span></strong></h3> 
 <p>因为蝗虫文件“只是代码”，所以没有什么能阻止你生成自己的 greenlet 与你的实际负载/用户并行运行。</p> 
 <pre><code class="language-python">import gevent
from locust import events
from locust.runners import STATE_STOPPING, STATE_STOPPED, STATE_CLEANUP, MasterRunner, LocalRunner

def checker(environment):
    while not environment.runner.state in [STATE_STOPPING, STATE_STOPPED, STATE_CLEANUP]:
        time.sleep(1)
        if environment.runner.stats.total.fail_ratio &gt; 0.2:
            print(f"fail ratio was {environment.runner.stats.total.fail_ratio}, quitting")
            environment.runner.quit()
            return


@events.init.add_listener
def on_locust_init(environment, **_kwargs):
    # dont run this on workers, we only care about the aggregated numbers
    if isinstance(environment.runner, MasterRunner) or isinstance(environment.runner, LocalRunner):
        gevent.spawn(checker, environment)</code></pre> 
 <p></p> 
 <h3><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">Logging 日志 </span></span></strong></h3> 
 <p>Locust 使用 Python 内置的日志记录框架来处理日志记录。</p> 
 <p></p> 
 <p></p> 
 <h3>使用 locust 进行爬虫</h3> 
 <p>既然可以发起请求测试，那么肯定可以用来爬虫爬数据。</p> 
 <p>：<a class="link-info" href="https://docs.locust.io/en/latest/writing-a-locustfile.html#user-class" rel="nofollow" title="https://docs.locust.io/en/latest/writing-a-locustfile.html#user-class">https://docs.locust.io/en/latest/writing-a-locustfile.html#user-class</a></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">client 属性 / HttpSession</span></span></strong></h4> 
 <p><code>client</code> 是 <code>HttpSession</code> 的实例。HttpSession 是 <code>requests.Session</code> 的子类/包装器。就像 <code>requests.Session</code> 一样，它会在请求之间保留 cookie，因此可以轻松用于登录网站。</p> 
 <blockquote> 
  <p>response = self.client.post("/login", {"username":"testuser", "password":"secret"})<br> print("Response status code:", response.status_code)<br> print("Response text:", response.text)<br> response = self.client.get("/my-profile")</p> 
 </blockquote> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">验证 response</span></span></strong></h4> 
 <p>如果 HTTP 响应代码正常 （&lt;400），则认为请求成功，但对响应进行一些额外的验证通常很有用。可以使用 catch_response 参数、with 语句和对 response.failure（） 的调用将请求标记为失败</p> 
 <pre><code class="language-python">with self.client.get("/", catch_response=True) as response:
    if response.text != "Success":
        response.failure("Got wrong response")
    elif response.elapsed.total_seconds() &gt; 0.5:
        response.failure("Request took too long")</code></pre> 
 <p>您还可以将请求标记为成功，即使响应代码错误：</p> 
 <pre><code class="language-python">with self.client.get("/does_not_exist/", catch_response=True) as response:
    if response.status_code == 404:
        response.success()</code></pre> 
 <p>您甚至可以通过抛出异常，然后在 with-block 之外捕获它来完全避免记录请求。或者你可以抛出一个 locust 异常让 locust 捕捉到它。</p> 
 <pre><code class="language-python">from locust.exception import RescheduleTask
...
with self.client.get("/does_not_exist/", catch_response=True) as response:
    if response.status_code == 404:
        raise RescheduleTask()</code></pre> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">对请求进行分组</span></span></strong></h4> 
 <p>网站的 URL 包含某种动态参数的页面很常见。通常，在用户的统计信息中将这些 URL 组合在一起是有意义的。这可以通过将 name 参数传递给 <code>HttpSession's</code> 不同的请求方法来完成。</p> 
 <pre><code class="language-python">for i in range(10):
    self.client.get("/blog?id=%i" % i, name="/blog?id=[id]")</code></pre> 
 <p>在某些情况下，可能无法将参数传递到请求函数中，例如在与包装请求会话的库/SDK 交互时。通过设置 <code>client.request_name</code> 属性，提供了对请求进行分组的另一种方法。</p> 
 <pre><code class="language-python">self.client.request_name="/blog?id=[id]"
for i in range(10):
    self.client.get("/blog?id=%i" % i)
self.client.request_name=None</code></pre> 
 <p>如果要使用最少的样板链接多个分组，则可以使用 <code>client.rename_request()</code> 上下文管理器。</p> 
 <pre><code class="language-python">@task
def multiple_groupings_example(self):
    # Statistics for these requests will be grouped under: /blog/?id=[id]
    with self.client.rename_request("/blog?id=[id]"):
        for i in range(10):
            self.client.get("/blog?id=%i" % i)

    # Statistics for these requests will be grouped under: /article/?id=[id]
    with self.client.rename_request("/article?id=[id]"):
        for i in range(10):
            self.client.get("/article?id=%i" % i)</code></pre> 
 <p>使用 catch_response 并直接访问request_meta，您甚至可以根据响应中的某些内容重命名请求。</p> 
 <pre><code class="language-python">with self.client.get("/", catch_response=True) as resp:
    resp.request_meta["name"] = resp.json()["name"]</code></pre> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">HTTP 代理设置</span></span></strong></h4> 
 <p></p> 
 <h4><strong><span style="color:#404040;"><span style="background-color:#fcfcfc;">连接池</span></span></strong></h4> 
 <p>由于每个 <code>HttpUser</code> 都会创建新的 <code>HttpSession</code> ，所以每个用户实例都有自己的连接池。这类似于真实用户与 Web 服务器的交互方式。</p> 
 <p>但是，如果要在所有用户之间共享连接，则可以使用单个池管理器。为此，请将 class 属性设置为 <code>pool_manager</code> 的 <code>urllib3.PoolManager</code> 实例。</p> 
 <pre><code class="language-python">from locust import HttpUser
from urllib3 import PoolManager

class MyUser(HttpUser):
    # All users will be limited to 10 concurrent connections at most.
    pool_manager = PoolManager(maxsize=10, block=True)</code></pre> 
 <p></p> 
 <h4>限制 并发数</h4> 
 <p>注意：locust 如果未指定 wait_time 则一个任务完成后立即执行下一个任务。所以一定要限制并发数，防止对网站造成 DDOS 共计。可以在每个任务之间设置等待时间，来限制并发数。</p> 
 <blockquote> 
  <p>User 类的 <code>wait_time</code> 的方法可以很容易地在每次任务执行后引入延迟。</p> 
  <p>class MyUser(User):<br>     # wait between 3.0 and 10.5 seconds after each task<br>     wait_time = between(3.0, 10.5)</p> 
 </blockquote> 
 <ul><li><code>constant</code> 在固定的时间内</li></ul> 
 <pre><code class="language-python">from locust import User, task, constant

class MyUser(User):
    wait_time = constant(1)

    @task
    def my_task(self):
        print("User instance (%r) executing my_task" % self)</code></pre> 
 <ul><li><code>between</code> 最小值和最大值之间的随机时间</li></ul> 
 <pre><code class="language-python">from locust import User, task, between

class MyUser(User):
    @task
    def my_task(self):
        print("executing my_task")

    wait_time = between(0.5, 10)</code></pre> 
 <p>例如，如果希望 Locust 在峰值负载下每秒运行 500 次任务迭代，则可以使用 wait_time = constant_throughput（0.1） 和 5000 的用户计数。</p> 
 <p>等待时间只会限制吞吐量，而不能启动新用户来达到目标。因此，在我们的示例中，如果任务迭代时间超过 10 秒，则吞吐量将小于 500。</p> 
 <p></p> 
 <h4 style="background-color:transparent;">分布式 爬虫</h4> 
 <p>可以使用redis 作为任务队列，每个 work 从redis 获取任务</p> 
 <p></p> 
 <h4>示例 代码</h4> 
 <p>test.py</p> 
 <pre><code class="language-python">from gevent import monkey; monkey.patch_all()
import gevent
import redis
from locust import task, FastHttpUser, constant
from locust.exception import RescheduleTask
from bs4 import BeautifulSoup


rk = "task_queue"
redis_conn = redis.StrictRedis(host='127.0.0.1', port=6379, db=0)


class MyUser(FastHttpUser):
    wait_time = constant(0.5)  // 用来限制并发, 每0.5秒发送一个请求

    def get_redis_task(self):
        task_byte = redis_conn.spop(rk)
        if not task_byte:
            return None
        task_string = task_byte.decode('utf8')
        return task_string

    @task
    def crawl(self):
        task_string = self.get_redis_task()
        if not task_string:
            raise RescheduleTask()
            return None
        req_url = task_string
        with self.client.get(req_url, catch_response=True) as response:
            if response.status_code != 200:
                response.failure("请求失败")
            else:
                response.encoding = "utf-8"
                resp_text = response.text
                soup = BeautifulSoup(resp_text, "html.parser", from_encoding='utf-8')
                img_list = soup.find_all('img')
                list(map(lambda x=None: print(x["src"]), img_list))


def add_redis_task():
    # https://www.2meinv.com
    for page_num in range(1, 100):
        url = f"https://www.2meinv.com/index-{page_num}.html"
        redis_conn.sadd(rk, url)
    pass


if __name__ == '__main__':
    gevent.spawn(add_redis_task).join()


</code></pre> 
 <p>首先添加任务：python test.py</p> 
 <p>然后 locust 执行：locust -f test.py</p> 
 <p><img alt="" height="369" src="https://images2.imgbox.com/e6/2a/jGrboPqZ_o.png" width="1200"></p> 
 <p>浏览器打开 url</p> 
 <p><img alt="" height="933" src="https://images2.imgbox.com/04/38/cc4gl2ao_o.png" width="1104"></p> 
 <p></p> 
 <p></p> 
 <p></p> 
 <p></p> 
 <p></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71326017c824a29912928c518dea795f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【北邮国院大四上】Business Technology Strategy 企业技术战略</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74cf1e270f44c9d5dc306fbe90053162/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Flutter 开发实战】Dart 基础篇：从了解背景开始</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>