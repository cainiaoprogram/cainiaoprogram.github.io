<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FreeRTOS入门教程（任务通知） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FreeRTOS入门教程（任务通知）" />
<meta property="og:description" content="文章目录 前言一、什么是任务通知二、任务通知和队列，信号量的区别三、任务通知的优点和缺点1.优点2.缺点 四、任务状态和通知值五、任务通知相关的函数发出通知取出通知 六、任务通知具体使用1.实现轻量级信号量二进制信号量计数型信号量 2.实现轻量级队列 总结 前言 本篇文章将带大家学习任务通知的概念和使用方法。
一、什么是任务通知 FreeRTOS中的任务通知（Task Notification）是一种轻量级的同步机制，允许一个任务通知另一个任务已发生的事件或条件。这对于多任务系统中的协作和同步非常有用。以下是有关FreeRTOS任务通知的详细讲解：
任务通知的作用：
任务通知的主要作用是允许一个任务通知其他任务已发生的事件，而无需使用更重的互斥锁或信号量。这可以用于线程间的通信和同步，以及处理任务之间的依赖关系。
通知值（Notification Value）：
任务通知包括一个32位的通知值，用于传递信息。通知值可以是整数或位掩码，具体的含义由应用程序自行定义。任务可以等待特定的通知值或位掩码，以便在通知发生时采取相应的行动。
二、任务通知和队列，信号量的区别 任务通知、队列和信号量是FreeRTOS中用于任务间通信和同步的不同机制，它们有不同的特点和适用场景：
1.任务通知（Task Notification）：
用途：任务通知主要用于任务之间的事件通知和同步，一个任务向其他任务发送通知，以表明某些事件已发生。
特点：轻量级、高效，通常用于一对一或一对多的任务通信。
通信方式：通知是无数据的，只包含一个32位的通知值，任务可以等待特定的通知值。
适用场景：适用于任务之间的事件通知、依赖关系、同步等情况，以及需要高效且快速的通信。
使用任务通知时发送方可以直接将发送信息给接收方，不需要通过中间的结构体对象（信号量，队列结构体）。
2.队列（Queue）：
用途：队列用于任务之间的数据传递，允许一个任务发送数据给另一个任务。
特点：队列是有缓冲区的，可以传输多个数据元素，支持FIFO（先进先出）顺序。
通信方式：队列是带数据的通信机制，任务可以发送和接收数据。
适用场景：适用于需要任务之间传递数据的情况，如生产者-消费者问题、数据采集等。
3.信号量（Semaphore）：
用途：信号量用于控制对共享资源的访问，允许任务对资源的使用进行同步和互斥。
特点：信号量通常用于资源保护和互斥访问，可以是二进制信号量（互斥锁）或计数信号量（资源计数）。
通信方式：信号量通常用于任务之间互斥，以确保只有一个任务可以访问共享资源。
适用场景：适用于共享资源的访问控制、互斥操作等情况，如保护共享内存、硬件设备等。
使用队列，信号量时都需要创建出通信对象结构体，通过这个结构体进行通信。
总的来说，任务通知适用于事件通知和轻量级的同步，队列适用于任务之间的数据传递，而信号量适用于资源访问的同步和互斥。在选择合适的通信和同步机制时，应根据具体需求和任务之间的关系来决定使用哪种机制。有时，这些机制也可以结合使用，以满足更复杂的任务间通信和同步需求。
三、任务通知的优点和缺点 1.优点 1.轻量级和高效： 任务通知是一种轻量级的通信机制，它不需要大量的内存和处理时间来维护，因此非常高效。
2.适用于一对多通信： 任务通知适用于一对多的任务通信，一个任务可以通知多个等待通知的任务，这在某些场景下非常有用。
3.实时性强： 任务通知可以提供较低的延迟，因为一旦通知被发送，接收通知的任务可以立即响应。
4.支持不同类型的通知： 任务通知可以发送不同类型的通知，任务可以等待特定的通知类型。
5.无需额外的资源： 与消息队列等机制不同，任务通知不需要为数据缓冲区分配额外的内存，因此它更节省资源。
2.缺点 1.无数据传递： 任务通知本身不支持数据传递，只能传递一个32位的通知值。如果需要传递数据，你可能需要结合其他机制来实现。
2.适用性有限： 任务通知更适用于简单的事件通知和同步需求，对于复杂的数据交换和同步需求，可能需要使用其他机制，如消息队列或信号量。
3.不适用于多生产者-多消费者问题： 任务通知通常不适合解决多生产者和多消费者问题，因为它不提供数据缓冲区来处理多个生产者和消费者之间的数据共享。
4.不适合长期阻塞： 任务通知通常用于短期同步，如果任务需要长期等待，其他机制如消息队列可能更合适。
总的来说，任务通知是一种非常高效的任务间通信机制，适用于简单的事件通知和同步需求，但对于复杂的数据传递和同步问题，可能需要结合其他FreeRTOS机制来实现。选择合适的通信机制应根据具体的应用需求来决定。
四、任务状态和通知值 每个任务都有一个结构体: TCB(Task Control Block)，里面有2个成员。
一个是uint8 t类型，用来表示通知状态。
volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; ucNotifyState[] 数组：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/782d4b4b53c0447b59882222759bfff0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-26T09:30:50+08:00" />
<meta property="article:modified_time" content="2023-11-26T09:30:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FreeRTOS入门教程（任务通知）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_7" rel="nofollow">前言</a></li><li><a href="#_10" rel="nofollow">一、什么是任务通知</a></li><li><a href="#_20" rel="nofollow">二、任务通知和队列，信号量的区别</a></li><li><a href="#_55" rel="nofollow">三、任务通知的优点和缺点</a></li><li><ul><li><a href="#1_56" rel="nofollow">1.优点</a></li><li><a href="#2_66" rel="nofollow">2.缺点</a></li></ul> 
  </li><li><a href="#_77" rel="nofollow">四、任务状态和通知值</a></li><li><a href="#_120" rel="nofollow">五、任务通知相关的函数</a></li><li><ul><li><a href="#_121" rel="nofollow">发出通知</a></li><li><a href="#_153" rel="nofollow">取出通知</a></li></ul> 
  </li><li><a href="#_187" rel="nofollow">六、任务通知具体使用</a></li><li><ul><li><a href="#1_189" rel="nofollow">1.实现轻量级信号量</a></li><li><ul><li><a href="#_192" rel="nofollow">二进制信号量</a></li><li><a href="#_228" rel="nofollow">计数型信号量</a></li></ul> 
   </li><li><a href="#2_258" rel="nofollow">2.实现轻量级队列</a></li></ul> 
  </li><li><a href="#_290" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_7"></a>前言</h2> 
<p>本篇文章将带大家学习任务通知的概念和使用方法。</p> 
<h2><a id="_10"></a>一、什么是任务通知</h2> 
<p>FreeRTOS中的任务通知（Task Notification）是一种轻量级的同步机制，允许一个任务通知另一个任务已发生的事件或条件。这对于多任务系统中的协作和同步非常有用。以下是有关FreeRTOS任务通知的详细讲解：</p> 
<p><code>任务通知的作用：</code><br> 任务通知的主要作用是允许一个任务通知其他任务已发生的事件，而无需使用更重的互斥锁或信号量。这可以用于线程间的通信和同步，以及处理任务之间的依赖关系。</p> 
<p><code>通知值（Notification Value）：</code><br> 任务通知包括一个32位的通知值，用于传递信息。通知值可以是整数或位掩码，具体的含义由应用程序自行定义。任务可以等待特定的通知值或位掩码，以便在通知发生时采取相应的行动。</p> 
<h2><a id="_20"></a>二、任务通知和队列，信号量的区别</h2> 
<p>任务通知、队列和信号量是FreeRTOS中用于任务间通信和同步的不同机制，它们有不同的特点和适用场景：</p> 
<p><code>1.任务通知（Task Notification）：</code></p> 
<p>用途：任务通知主要用于任务之间的事件通知和同步，一个任务向其他任务发送通知，以表明某些事件已发生。<br> 特点：轻量级、高效，通常用于一对一或一对多的任务通信。<br> 通信方式：通知是无数据的，只包含一个32位的通知值，任务可以等待特定的通知值。<br> 适用场景：适用于任务之间的事件通知、依赖关系、同步等情况，以及需要高效且快速的通信。</p> 
<p><code>使用任务通知时发送方可以直接将发送信息给接收方，不需要通过中间的结构体对象（信号量，队列结构体）。</code><br> <img src="https://images2.imgbox.com/ab/1a/7pg4GqsE_o.png" alt="在这里插入图片描述"></p> 
<p><code>2.队列（Queue）：</code></p> 
<p>用途：队列用于任务之间的数据传递，允许一个任务发送数据给另一个任务。<br> 特点：队列是有缓冲区的，可以传输多个数据元素，支持FIFO（先进先出）顺序。<br> 通信方式：队列是带数据的通信机制，任务可以发送和接收数据。<br> 适用场景：适用于需要任务之间传递数据的情况，如生产者-消费者问题、数据采集等。</p> 
<p><code>3.信号量（Semaphore）：</code></p> 
<p>用途：信号量用于控制对共享资源的访问，允许任务对资源的使用进行同步和互斥。<br> 特点：信号量通常用于资源保护和互斥访问，可以是二进制信号量（互斥锁）或计数信号量（资源计数）。<br> 通信方式：信号量通常用于任务之间互斥，以确保只有一个任务可以访问共享资源。<br> 适用场景：适用于共享资源的访问控制、互斥操作等情况，如保护共享内存、硬件设备等。</p> 
<p><code>使用队列，信号量时都需要创建出通信对象结构体，通过这个结构体进行通信。</code><br> <img src="https://images2.imgbox.com/f7/ca/crDxG41e_o.png" alt="在这里插入图片描述"></p> 
<p><code>总的来说，任务通知适用于事件通知和轻量级的同步，队列适用于任务之间的数据传递，而信号量适用于资源访问的同步和互斥。在选择合适的通信和同步机制时，应根据具体需求和任务之间的关系来决定使用哪种机制。有时，这些机制也可以结合使用，以满足更复杂的任务间通信和同步需求。</code></p> 
<h2><a id="_55"></a>三、任务通知的优点和缺点</h2> 
<h3><a id="1_56"></a>1.优点</h3> 
<p>1.轻量级和高效： 任务通知是一种轻量级的通信机制，它不需要大量的内存和处理时间来维护，因此非常高效。</p> 
<p>2.适用于一对多通信： 任务通知适用于一对多的任务通信，一个任务可以通知多个等待通知的任务，这在某些场景下非常有用。</p> 
<p>3.实时性强： 任务通知可以提供较低的延迟，因为一旦通知被发送，接收通知的任务可以立即响应。</p> 
<p>4.支持不同类型的通知： 任务通知可以发送不同类型的通知，任务可以等待特定的通知类型。</p> 
<p>5.无需额外的资源： 与消息队列等机制不同，任务通知不需要为数据缓冲区分配额外的内存，因此它更节省资源。</p> 
<h3><a id="2_66"></a>2.缺点</h3> 
<p>1.无数据传递： 任务通知本身不支持数据传递，只能传递一个32位的通知值。如果需要传递数据，你可能需要结合其他机制来实现。</p> 
<p>2.适用性有限： 任务通知更适用于简单的事件通知和同步需求，对于复杂的数据交换和同步需求，可能需要使用其他机制，如消息队列或信号量。</p> 
<p>3.不适用于多生产者-多消费者问题： 任务通知通常不适合解决多生产者和多消费者问题，因为它不提供数据缓冲区来处理多个生产者和消费者之间的数据共享。</p> 
<p>4.不适合长期阻塞： 任务通知通常用于短期同步，如果任务需要长期等待，其他机制如消息队列可能更合适。</p> 
<p><code>总的来说，任务通知是一种非常高效的任务间通信机制，适用于简单的事件通知和同步需求，但对于复杂的数据传递和同步问题，可能需要结合其他FreeRTOS机制来实现。选择合适的通信机制应根据具体的应用需求来决定。</code></p> 
<h2><a id="_77"></a>四、任务状态和通知值</h2> 
<p>每个任务都有一个结构体: TCB(Task Control Block)，里面有2个成员。</p> 
<p><code>一个是uint8 t类型，用来表示通知状态。</code></p> 
<pre><code class="prism language-c"><span class="token keyword">volatile</span> <span class="token class-name">uint8_t</span> ucNotifyState<span class="token punctuation">[</span> configTASK_NOTIFICATION_ARRAY_ENTRIES <span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>ucNotifyState[] 数组：</p> 
<p>类型：volatile uint8_t<br> 作用：通常用于存储任务通知的状态。<br> FreeRTOS允许任务等待多个通知。这个数组可能用于记录每个任务是否已经接收到通知，或者通知的处理状态。每个元素可能对应一个任务的通知状态。</p> 
<p><code>任务通知的三种状态：</code></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">taskNOT_WAITING_NOTIFICATION</span>              <span class="token expression"><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token class-name">uint8_t</span> <span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">)</span></span></span>
</code></pre> 
<p>含义：任务处于未等待通知的状态。<br> 初始状态或者任务已经完成了对通知的等待，准备进入下一个等待通知的周期。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">taskWAITING_NOTIFICATION</span>                  <span class="token expression"><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token class-name">uint8_t</span> <span class="token punctuation">)</span> <span class="token number">1</span> <span class="token punctuation">)</span></span></span>
</code></pre> 
<p>含义：任务正在等待通知的状态。<br> 当任务调用 ulTaskNotifyTake 等待通知时，它的状态将变为等待通知状态。任务会一直保持在这个状态，直到它收到通知或者等待超时。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">taskNOTIFICATION_RECEIVED</span>                 <span class="token expression"><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token class-name">uint8_t</span> <span class="token punctuation">)</span> <span class="token number">2</span> <span class="token punctuation">)</span></span></span>
</code></pre> 
<p>含义：任务已经收到通知的状态。<br> 当任务成功接收到通知时，其状态将从等待通知状态切换到通知已接收状态。任务可以通过调用 ulTaskNotifyTake 函数获取通知的值，并执行相应的操作。<br> <code>一个是uint32 t类型，用来表示通知值。</code></p> 
<pre><code class="prism language-c"><span class="token keyword">volatile</span> <span class="token class-name">uint32_t</span> ulNotifiedValue<span class="token punctuation">[</span> configTASK_NOTIFICATION_ARRAY_ENTRIES <span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>ulNotifiedValue[] 数组：</p> 
<p>类型：volatile uint32_t<br> 作用：通常用于存储任务接收到的通知值。<br> 每个任务都可以使用 ulTaskNotifyTake 函数等待通知，并在接收到通知时获得相应的值。这个数组可能被设计为记录多个任务接收到的通知值。数组的每个元素对应一个任务。</p> 
<h2><a id="_120"></a>五、任务通知相关的函数</h2> 
<h3><a id="_121"></a>发出通知</h3> 
<p><code>发出通知有两个函数可以使用，分别是xTaskNotifyGive和xTaskNotify。</code></p> 
<pre><code class="prism language-c"><span class="token function">xTaskNotifyGive</span><span class="token punctuation">(</span>TaskHandle_t xTaskToNotify<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>功能：向指定的任务发送一个通知。<br> 参数：xTaskToNotify 是要通知的任务的句柄（handle）。<br> 返回值：无。<br> 详细说明：这个函数用于向另一个任务发送通知。通知的具体内容可以是一个比特位或者一个32位的值，取决于任务通知的类型。被通知的任务可以通过 ulTaskNotifyTake 函数获取通知的值。</p> 
<pre><code class="prism language-c"><span class="token function">xTaskNotify</span><span class="token punctuation">(</span>TaskHandle_t xTaskToNotify<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> ulValue<span class="token punctuation">,</span> eNotifyAction eAction<span class="token punctuation">)</span>
</code></pre> 
<p>功能：向指定的任务发送一个通知，可以指定通知的值和通知的行为。<br> 参数：<br> xTaskToNotify：要通知的任务的句柄（handle）。<br> ulValue：通知的值，可以是一个比特位或者32位的值。<br> eAction：通知的行为，例如覆盖之前的通知值或者增加到之前的通知值。<br> 返回值：无。<br> 详细说明：这个函数允许发送带有值的通知，并且可以选择通知的行为。同样，被通知的任务可以通过 ulTaskNotifyTake 函数获取通知的值。</p> 
<p><code>xTaskNotifyGive和xTaskNotify区别：</code></p> 
<p><code>xTaskNotifyGive：</code><br> 用途：向指定的任务发送一个通知，但不提供通知的具体值。<br> 示例用法：xTaskNotifyGive(xTaskHandle);<br> 适用情况：当通知的具体值不关键，只是为了触发目标任务执行某个操作时，使用此函数。</p> 
<p><code>xTaskNotify：</code><br> 用途：向指定的任务发送一个通知，可以指定通知的具体值和通知的行为。<br> 示例用法：xTaskNotify(xTaskHandle, ulValue, eAction);<br> 适用情况：当通知的具体值对于目标任务的操作非常重要时，或者需要更精细的控制通知的行为时，使用此函数。</p> 
<h3><a id="_153"></a>取出通知</h3> 
<p><code>取出通知有两个函数可以使用，分别是ulTaskNotifyTake和xTaskNotifyWait。</code></p> 
<pre><code class="prism language-c"><span class="token function">ulTaskNotifyTake</span><span class="token punctuation">(</span>BaseType_t xClearCountOnExit<span class="token punctuation">,</span> TickType_t xTicksToWait<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>功能：等待接收任务通知。<br> 参数：<br> xClearCountOnExit：标志是否在任务等待通知时清零通知计数。<br> xTicksToWait：等待通知的超时时间。<br> 返回值：接收到的通知的值。<br> 详细说明：任务调用这个函数等待接收通知。如果在超时时间内收到通知，任务将返回通知的值；否则，返回0。通知的具体值和行为由前面的 xTaskNotify 函数设置。</p> 
<pre><code class="prism language-c"><span class="token function">xTaskNotifyWait</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> ulBitsToClearOnEntry<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> ulBitsToClearOnExit<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> <span class="token operator">*</span>pulNotificationValue<span class="token punctuation">,</span> TickType_t xTicksToWait<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>功能：等待接收任务通知，并且可以设置在进入和退出时要清零的通知比特位。<br> 参数：<br> ulBitsToClearOnEntry：进入等待通知时要清零的通知比特位。<br> ulBitsToClearOnExit：退出等待通知时要清零的通知比特位。<br> pulNotificationValue：指向接收到的通知值的指针。<br> xTicksToWait：等待通知的超时时间。<br> 返回值：如果在超时时间内收到通知，返回 pdTRUE；否则，返回 pdFALSE。<br> 详细说明：这个函数允许更加细粒度的控制，可以在进入和退出等待通知的时候清零通知的比特位。同样，被通知的任务可以通过 ulTaskNotifyTake 函数获取通知的值。</p> 
<p><code>ulTaskNotifyTake和xTaskNotifyWait区别：</code></p> 
<p><code>ulTaskNotifyTake：</code><br> 用途：等待接收任务通知，返回接收到的通知的值。<br> 示例用法：ulNotifiedValue = ulTaskNotifyTake(pdFALSE, xTicksToWait);<br> 适用情况：当只需等待通知并获取其值时，使用此函数。通常用于轻量级的通知接收。</p> 
<p><code>xTaskNotifyWait：</code><br> 用途：等待接收任务通知，可以设置在进入和退出时要清零的通知比特位，返回是否在超时时间内收到通知。<br> 示例用法：xResult = xTaskNotifyWait(ulBitsToClearOnEntry, ulBitsToClearOnExit, &amp;ulNotificationValue, xTicksToWait);<br> 适用情况：当需要更灵活的通知等待，并且需要在等待前后清零通知比特位时，使用此函数。通常用于更复杂的通知场景。</p> 
<h2><a id="_187"></a>六、任务通知具体使用</h2> 
<h3><a id="1_189"></a>1.实现轻量级信号量</h3> 
<p>xTaskNotifyGive函数可以让通知值加1，ulTaskNotifyTake可以让通知值减1，而且可以设置ulTaskNotifyTake的第一个参数来决定，是否清除通知值，设置为pdTURE则清除通知值(实现二进制信号量)，设置为pdFALSE则不清除通知值(实现计数型信号量)。</p> 
<h4><a id="_192"></a>二进制信号量</h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">Task1Function</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> param<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">volatile</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			sum<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token comment">//printf("1");</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// xSemaphoreGive(xSemCalc);</span>
			<span class="token function">xTaskNotifyGive</span><span class="token punctuation">(</span>xHandleTask2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">vTaskDelete</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Task2Function</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> param<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//if (flagCalcEnd)</span>
		flagCalcEnd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">//xSemaphoreTake(xSemCalc, portMAX_DELAY);</span>
		val <span class="token operator">=</span> <span class="token function">ulTaskNotifyTake</span><span class="token punctuation">(</span>pdTURE<span class="token punctuation">,</span> portMAX_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
		flagCalcEnd <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d, NotifyVal = %d, i = %d\r\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_228"></a>计数型信号量</h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">Task1Function</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> param<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">volatile</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			sum<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">xTaskNotifyGive</span><span class="token punctuation">(</span>xHandleTask2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">vTaskDelete</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Task2Function</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> param<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		val <span class="token operator">=</span> <span class="token function">ulTaskNotifyTake</span><span class="token punctuation">(</span>pdFALSE<span class="token punctuation">,</span> portMAX_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d, NotifyVal = %d, i = %d\r\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2_258"></a>2.实现轻量级队列</h3> 
<p><code>xTaskNotify和xTaskNotifyWait可以实现轻量级队列，用于传输一个uint32_t类型的数值。</code></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">Task1Function</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> param<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">volatile</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			sum<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">xTaskNotify</span><span class="token punctuation">(</span>xHandleTask2<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> eSetValueWithOverwrite<span class="token punctuation">)</span><span class="token punctuation">;</span>
			sum<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">vTaskDelete</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Task2Function</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> param<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">xTaskNotifyWait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>val<span class="token punctuation">,</span> portMAX_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d, i = %d\r\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_290"></a>总结</h2> 
<p>本篇文章就讲解到这里，下篇文章继续讲解FreeRTOS中的内容。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d805d8a8a18e10767a85704a5bfb13c1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">rk3588 repo 更新代码是报错：ModuleNotFoundError: No module named ‘formatter‘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b03dd10181dbcb3eb16df0cf3e9bc385/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue经典面试题：声明式导航和编程式导航</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>