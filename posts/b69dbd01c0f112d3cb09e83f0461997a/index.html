<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>visual C&#43;&#43; 项目和解决方案的区别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="visual C&#43;&#43; 项目和解决方案的区别" />
<meta property="og:description" content="项目：
项目是构成某个程序的全部组件的容器，该程序可能是控制台程序、基于窗口的程序或某种别的程序。程序通常由一个或多个包含用户代码的源文件，可能还要加上包含其它辅助数据的文件组成。某个项目的所有文件都存储在相应的项目文件夹中，关于项目的详细信息存储在一个扩展名为.vcproj的xml文件中，该文件同样存储在相应的项目文件夹中。项目文件夹还包括其它文件夹，它们用来存储编译及链接项目时所产生的输出。
解决方案：
顾名思义，解决方案的含义是一种将所有程序和其它资源（它们是某个具体的数据处理问题的解决方案）聚集到一起的机制。例如，用于企业经营的分布式订单录入系统可能由若干个不同的程序组成，而各个程序是作为同一个解决方案内的项目开发的，因此，解决方案就是存储与一个或多个项目有关的所有信息的文件夹，这样就有一个或多个项目文件夹是解决方案文件夹的子文件夹。与解决方案中项目有关的信息存储在扩展名为.sln和.suo的两个文件中。当创建某个项目时，如果没有选择在现有的解决方案中添加该项目，那么系统将自动创建一个新的解决方案。
当创建项目及解决方案时，可以在同一个解决方案中添加更多的项目。我们可以在现有的解决方案中添加任意种类的项目，但通常只添加与该解决方案内现有项目相关的项目。一般来说，各个项目都应该有自己的解决方案，除非我们有很好的理由不这样做。
VS2010创建项目时，默认的项目文件夹的名称与项目名称相同，该文件夹还将容纳构成该项目定义的文件。如果不修改的话，解决方案文件夹具有与项目文件夹相同的名称，其中包含了项目文件夹、定义解决方案内容的文件。解决方案文件夹内包含如下四个文件：
扩展名为.sln的文件，记录着关于解决方案中项目的信息。扩展名为.suo的文件，其中记录着应用于该解决方案的用户选项。扩展名为.sdf的文件，记录着与解决方案的Intellisense有关的数据。Intellisense是在Editor窗口中输入代码时提供自动完成和提示功能的工具。扩展名为.opensdf的文件，记录着关于项目状态的信息，此文件只在项目处于打开状态时才有。 项目文件夹中的Readme.txt文件包含已经为该项目创建的所有文件的内容摘要。 构建项目时创建的文件： 构建项目完成后将看到解决方案文件夹中出现了一个新的子文件夹Debug。该文件夹包含刚才构建项目时产生的输出，这个文件夹包含三个文件。 .exe文件：可执行文件.ilk文件：在重新构建项目时被链接器使用，它使链接器能够根据修改的源代码生成的目标文件增量的链接到现有的.exe文件，从而避免每次修改程序时都重新链接所有文件。.pdb文件：包含调试信息，在调试模式中执行程序要使用该调试信息。在调试模式中，可以动态检查程序执行过程中所生成的信息。 在项目文件夹中也有一个Debug目录，它包含在构建过程中生成的很多文件，从Windows Explorer的Type描述中可以看到它们包含何种信息。 ipch文件夹和.sdf文件是什么？ ipch的文件夹，和一个与工程同名的.sdf文件，而且ipch下面的文件和.sdf文件都很大，这些文件是Visual Studio用来保存预编译的头文件和Intellisense用的，删除这些文件对于工程的开发完全没有影响。那如果我既想使用预编译的头文件和Intellisense，又不想看到这些无聊的文件该怎么办呢？ 工具-&gt;选项-&gt;文本编辑器-&gt;C/C&#43;&#43; -&gt;高级-&gt;回退位置 那里，两个都设成true
如果你设置了回退位置，那么IPCH等就会到那里去，否则会在系统TEMP里，有个VC&#43;&#43;文件夹下。
VS2010解决方案和工程文件的另一种解释：
将所有文件分为6个部分：解决方案相关文件、工程相关文件、应用程序头文件和源文件、资源文件、预编译头文件和编译链接生成文件。
1.解决方案相关文件
解决方案相关文件包括解决方案文件夹下的.sdf文件、.sln文件、.suo文件和ipch文件夹。
.sdf文件和ipch目录一般占用空间比较大，几十兆甚至上百兆，与智能提示、错误提示、代码恢复、团队本地仓库等相关。如果你觉得不需要则可以设置不生成它们，方法是点击菜单栏Tools-&gt;Options，弹出Options对话框，选择左侧面板中Text Editor-&gt;C/C&#43;&#43;-&gt;Advanced，右侧列表中第一项Disable Database由False改为True就可以了，最后关闭VS2010再删除.sdf文件和ipch目录以后就不会再产生了。但关闭此选项以后也会有很多不便，例如写程序时的智能提示没有了。
.sln文件和.suo文件为MFC自动生成的解决方案文件，它包含当前解决方案中的工程信息，存储解决方案的设置。
2.工程相关文件
工程相关文件包括工程文件夹下的.vcxproj文件和.vcxproj.filters文件。
.vcxproj文件是MFC生成的工程文件，它包含当前工程的设置和工程所包含的文件等信息。.vcxproj.filters文件存放工程的虚拟目录信息，也就是在解决方案浏览器中的目录结构信息。
3.应用程序头文件和源文件
应用程序向导会根据应用程序的类型（单文档、多文档或基于对话框的程序）自动生成一些头文件和源文件，这些文件是工程的主体部分，用于实现主框架、文档、视图等。
下面分别简单介绍下各个文件：
HelloWorld.h：应用程序的主头文件。主要包含由CWinAppEx类派生的CHelloWorldApp类的声明，以及CHelloWorldApp类的全局对象theApp的声明。
HelloWorld.cpp：应用程序的主源文件。主要包含CHelloWorldApp类的实现，CHelloWorldApp类的全局对象theApp的定义等。
MainFrm.h和MainFrm.cpp：通过这两个文件从CFrameWndEx类派生出CMainFrame类，用于创建主框架、菜单栏、工具栏和状态栏等。
HelloWorldDoc.h和HelloWorldDoc.cpp：这两个文件从CDocument类派生出文档类CHelloWorldDoc，包含一些用来初始化文档、串行化（保存和装入）文档和调试的成员函数。
HelloWorldView.h和HelloWorldView.cpp：它们从CView类派生出名为CHelloWorldView的视图类，用来显示和打印文档数据，包含了一些绘图和用于调试的成员函数。
ClassView.h和ClassView.cpp：由CDockablePane类派生出CClassView类，用于实现应用程序界面左侧面板上的Class View。
FileView.h和FileView.cpp：由CDockablePane类派生出CFileView类，用于实现应用程序界面左侧面板上的File View。
OutputWnd.h和OutputWnd.cpp：由CDockablePane类派生出COutputWnd类，用于实现应用程序界面下侧面板Output。
PropertiesWnd.h和PropertiesWnd.cpp：由CDockablePane类派生出CPropertiesWnd类，用于实现应用程序界面右侧面板Properties。
ViewTree.h和ViewTree.cpp：由CTreeCtrl类派生出CViewTree类，用于实现出现在ClassView和FileView等中的树视图。
4.资源文件
一般我们使用MFC生成窗口程序都会有对话框、图标、菜单等资源，应用程序向导会生成资源相关文件：res目录、HelloWorld.rc文件和Resource.h文件。
res目录：工程文件夹下的res目录中含有应用程序默认图标、工具栏使用图标等图标文件。
HelloWorld.rc：包含默认菜单定义、字符串表和加速键表，指定了默认的About对话框和应用程序默认图标文件等。
Resource.h：含有各种资源的ID定义。
5.预编译头文件
几乎所有的MFC程序的文件都要包含afxwin.h等文件，如果每次编译都要编译一次则会大大减慢编译速度。所以把常用的MFC头文件都放到了stdafx.h文件中，然后由stdafx.cpp包含stdafx.h文件，编译器对stdafx.cpp只编译一次，并生成编译之后的预编译头HelloWorld.pch，大大提高了编译效率。
6.编译链接生成文件
如果是Debug方式编译，则会在解决方案文件夹和工程文件夹下都生成Debug子文件夹，而如果是Release方式编译则生成Release子文件夹。
工程文件夹下的Debug或Release子文件夹中包含了编译链接时产生的中间文件，解决方案文件夹下的Debug或Release子文件夹中主要包含有应用程序的可执行文件。
关于应用程序工程文件的组成结构就先讲到这了。其中包含了很多专有名词，以后大家会慢慢熟悉的
学习C&#43;&#43;学的是什么？
C&#43;&#43;是很复杂的一门语言，因为要实现在其它语言中很简单的任务，在C&#43;&#43;中通常需要跟多的代码和时间，例如：创建一个窗口，其它语言有内置的支持，而在纯粹的C&#43;&#43;环境中是做不到的。因为C&#43;&#43;没有提供GUI的内置支持，如果要用C&#43;&#43;创建一个窗口，我们需要使用系统API或者使用封装了系统API的一些库，前者如Win32系统API后者如MFC、wxWidgets等。
但是这不代表C&#43;&#43;不好，反而C&#43;&#43;是很强大的，我们学习C&#43;&#43;学的不仅仅是C&#43;&#43;的语法，因为仅仅懂C&#43;&#43;的语法有什么用呢？演示算法吗？当然不是了。我认为，学习C&#43;&#43;初期当然是熟悉C&#43;&#43;的语法，中期是学习STL库、系统API以及C&#43;&#43;面向对象的思想和一般的设计方法，后者是伴随你C&#43;&#43;生涯一生的，因为它没有终点。
除了加深对C&#43;&#43;的理解之外，你还得需要各种各样的基于C&#43;&#43;的库去实现更具体的东西。如果你想做GUI，那你得学习QT、wxWidgets等。如果想做游戏方面的那么Ogre、Unreal、Bigworld等库是你需要学习的。网络方面的库ASIO、RakNet、ACE等。这些库都是基于C&#43;&#43;的，其封装了底层的API，似的我们可以不必每次去使用繁杂的API来实现我们想要的功能。当然你也可以使用C&#43;&#43;去封装这些API，让自己成为一个库作者，方便他人。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b69dbd01c0f112d3cb09e83f0461997a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-03-04T17:15:26+08:00" />
<meta property="article:modified_time" content="2015-03-04T17:15:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">visual C&#43;&#43; 项目和解决方案的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><span style="color:#ff0000">项目：</span></strong></p> 
<p><strong>        </strong>项目是构成某个程序的全部组件的容器，该程序可能是控制台程序、基于窗口的程序或某种别的程序。程序通常由一个或多个包含用户代码的源文件，可能还要加上包含其它辅助数据的文件组成。某个项目的所有文件都存储在相应的项目文件夹中，关于<strong><span style="color:#ff0000">项目的详细信息存储在一个扩展名为.vcproj的xml文件中，该文件同样存储在相应的项目文件夹中。</span></strong>项目文件夹还包括其它文件夹，它们用来存储编译及链接项目时所产生的输出。</p> 
<p><strong><span style="color:#ff0000">解决方案：</span></strong></p> 
<p>        顾名思义，解决方案的含义是一种将所有程序和其它资源（它们是某个具体的数据处理问题的解决方案）聚集到一起的机制。例如，用于企业经营的分布式订单录入系统可能由若干个不同的程序组成，而各个程序是作为同一个解决方案内的项目开发的，因此，解决方案就是存储与一个或多个项目有关的所有信息的文件夹，这样就有一个或多个项目文件夹是解决方案文件夹的子文件夹。<span style="color:#ff0000"><strong>与解决方案中项目有关的信息存储在扩展名为.sln和.suo的两个文件中。</strong></span>当创建某个项目时，如果没有选择在现有的解决方案中添加该项目，那么系统将自动创建一个新的解决方案。</p> 
<p>        当创建项目及解决方案时，可以在同一个解决方案中添加更多的项目。我们可以在现有的解决方案中添加任意种类的项目，但通常只添加与该解决方案内现有项目相关的项目。一般来说，各个项目都应该有自己的解决方案，除非我们有很好的理由不这样做。</p> 
<p>     </p> 
<p>        VS2010创建项目时，默认的项目文件夹的名称与项目名称相同，该文件夹还将容纳构成该项目定义的文件。如果不修改的话，解决方案文件夹具有与项目文件夹相同的名称，其中包含了项目文件夹、定义解决方案内容的文件。解决方案文件夹内包含如下四个文件：</p> 
<p></p> 
<ul><li><span style="font-size:12px">扩展名为.sln的文件，<strong>记录着关于解决方案中项目的信息</strong>。</span></li><li><span style="font-size:12px">扩展名为.suo的文件，其中<strong>记录着应用于该解决方案的用户选项</strong>。</span></li><li><span style="font-size:12px">扩展名为.sdf的文件，记录着与解决方案的Intellisense有关的数据。Intellisense是在Editor窗口中输入代码时提供自动完成和提示功能的工具。</span></li><li><span style="font-size:12px">扩展名为.opensdf的文件，<strong>记录着关于项目状态的信息，此文件只在项目处于打开状态时才有。</strong></span></li></ul> 
<div>
  项目文件夹中的Readme.txt文件包含已经为该项目创建的所有文件的内容摘要。 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <strong><span style="color:#ff0000">        构建项目时创建的文件：</span></strong> 
</div> 
<div>
          构建项目完成后将看到解决方案文件夹中出现了一个新的子文件夹Debug。该文件夹包含刚才构建项目时产生的输出，这个文件夹包含三个文件。 
</div> 
<div> 
 <ul><li><span style="font-size:12px">.exe文件：可执行文件</span></li><li>.ilk文件：在重新构建项目时被链接器使用，它使链接器能够根据修改的源代码生成的目标文件增量的链接到现有的.exe文件，从而避免每次修改程序时都重新链接所有文件。</li><li>.pdb文件：包含调试信息，在调试模式中执行程序要使用该调试信息。在调试模式中，可以动态检查程序执行过程中所生成的信息。</li></ul> 
 <div>
           在项目文件夹中也有一个Debug目录，它包含在构建过程中生成的很多文件，从Windows Explorer的Type描述中可以看到它们包含何种信息。 
 </div> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <strong><span style="color:#ff0000">ipch文件夹和.sdf文件是什么？</span></strong> 
 <br> 
</div> 
<div>
          ipch的文件夹，和一个与工程同名的.sdf文件，而且ipch下面的文件和.sdf文件都很大，这些文件是Visual Studio用来保存预编译的头文件和Intellisense用的，删除这些文件对于工程的开发完全没有影响。那如果我既想使用预编译的头文件和Intellisense，又不想看到这些无聊的文件该怎么办呢？ 
 <br> 
</div> 
<p>        工具-&gt;选项-&gt;文本编辑器-&gt;C/C++ -&gt;高级-&gt;回退位置 那里，两个都设成true</p> 
<p>        如果你设置了回退位置，那么IPCH等就会到那里去，否则会在系统TEMP里，有个VC++文件夹下。</p> 
<p><br> </p> 
<p>VS2010解决方案和工程文件的另一种解释：</p> 
<p>将所有文件分为6个部分：解决方案相关文件、工程相关文件、应用程序头文件和源文件、资源文件、预编译头文件和编译链接生成文件。<br> <br> <strong><span style="color:#3333ff">1.解决方案相关文件</span></strong><br> <br> 解决方案相关文件包括解决方案文件夹下的.sdf文件、.sln文件、.suo文件和ipch文件夹。<br> <br> .sdf文件和ipch目录一般占用空间比较大，几十兆甚至上百兆，与智能提示、错误提示、代码恢复、团队本地仓库等相关。如果你觉得不需要则可以设置不生成它们，方法是点击菜单栏Tools-&gt;Options，弹出Options对话框，选择左侧面板中Text Editor-&gt;C/C++-&gt;Advanced，右侧列表中第一项Disable Database由False改为True就可以了，最后关闭VS2010再删除.sdf文件和ipch目录以后就不会再产生了。但关闭此选项以后也会有很多不便，例如写程序时的智能提示没有了。<br> <br> .sln文件和.suo文件为MFC自动生成的解决方案文件，它包含当前解决方案中的工程信息，存储解决方案的设置。<br> <br> <strong><span style="color:#3333ff">2.工程相关文件</span></strong><br> <br> 工程相关文件包括工程文件夹下的.vcxproj文件和.vcxproj.filters文件。<br> <br> .vcxproj文件是MFC生成的工程文件，它包含当前工程的设置和工程所包含的文件等信息。.vcxproj.filters文件存放工程的虚拟目录信息，也就是在解决方案浏览器中的目录结构信息。<br> </p> 
<p><strong><span style="color:#3333ff">3.应用程序头文件和源文件</span></strong><br> <br> 应用程序向导会根据应用程序的类型（单文档、多文档或基于对话框的程序）自动生成一些头文件和源文件，这些文件是工程的主体部分，用于实现主框架、文档、视图等。</p> 
<p>下面分别简单介绍下各个文件：<br> <br> HelloWorld.h：应用程序的主头文件。主要包含由CWinAppEx类派生的CHelloWorldApp类的声明，以及CHelloWorldApp类的全局对象theApp的声明。<br> <br> HelloWorld.cpp：应用程序的主源文件。主要包含CHelloWorldApp类的实现，CHelloWorldApp类的全局对象theApp的定义等。<br> <br> MainFrm.h和MainFrm.cpp：通过这两个文件从CFrameWndEx类派生出CMainFrame类，用于创建主框架、菜单栏、工具栏和状态栏等。<br> <br> HelloWorldDoc.h和HelloWorldDoc.cpp：这两个文件从CDocument类派生出文档类CHelloWorldDoc，包含一些用来初始化文档、串行化（保存和装入）文档和调试的成员函数。<br> <br> HelloWorldView.h和HelloWorldView.cpp：它们从CView类派生出名为CHelloWorldView的视图类，用来显示和打印文档数据，包含了一些绘图和用于调试的成员函数。<br> <br> ClassView.h和ClassView.cpp：由CDockablePane类派生出CClassView类，用于实现应用程序界面左侧面板上的Class View。<br> <br> FileView.h和FileView.cpp：由CDockablePane类派生出CFileView类，用于实现应用程序界面左侧面板上的File View。<br> <br> OutputWnd.h和OutputWnd.cpp：由CDockablePane类派生出COutputWnd类，用于实现应用程序界面下侧面板Output。<br> <br> PropertiesWnd.h和PropertiesWnd.cpp：由CDockablePane类派生出CPropertiesWnd类，用于实现应用程序界面右侧面板Properties。<br> <br> ViewTree.h和ViewTree.cpp：由CTreeCtrl类派生出CViewTree类，用于实现出现在ClassView和FileView等中的树视图。<br> <br> <strong><span style="color:#3333ff">4.资源文件</span></strong><br> <br> 一般我们使用MFC生成窗口程序都会有对话框、图标、菜单等资源，应用程序向导会生成资源相关文件：res目录、HelloWorld.rc文件和Resource.h文件。<br> <br> res目录：工程文件夹下的res目录中含有应用程序默认图标、工具栏使用图标等图标文件。<br> <br> HelloWorld.rc：包含默认菜单定义、字符串表和加速键表，指定了默认的About对话框和应用程序默认图标文件等。<br> <br> Resource.h：含有各种资源的ID定义。<br> <br> <span style="color:#3333ff"><strong>5.预编译头文件</strong></span><br> <br> 几乎所有的MFC程序的文件都要包含afxwin.h等文件，如果每次编译都要编译一次则会大大减慢编译速度。所以把常用的MFC头文件都放到了stdafx.h文件中，然后由stdafx.cpp包含stdafx.h文件，编译器对stdafx.cpp只编译一次，并生成编译之后的预编译头HelloWorld.pch，大大提高了编译效率。<br> <br> <strong><span style="color:#3333ff">6.编译链接生成文件</span></strong><br> <br> 如果是Debug方式编译，则会在解决方案文件夹和工程文件夹下都生成Debug子文件夹，而如果是Release方式编译则生成Release子文件夹。<br> <br> 工程文件夹下的Debug或Release子文件夹中包含了编译链接时产生的中间文件，解决方案文件夹下的Debug或Release子文件夹中主要包含有应用程序的可执行文件。<br> <br> 关于应用程序工程文件的组成结构就先讲到这了。其中包含了很多专有名词，以后大家会慢慢熟悉的<br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><span style="color:#ff0000"><strong>学习C++学的是什么？</strong></span></p> 
<p>        C++是很复杂的一门语言，因为要实现在其它语言中很简单的任务，在C++中通常需要跟多的代码和时间，例如：创建一个窗口，其它语言有内置的支持，而在纯粹的C++环境中是做不到的。因为C++没有提供GUI的内置支持，如果要用C++创建一个窗口，我们需要使用系统API或者使用封装了系统API的一些库，前者如Win32系统API后者如MFC、wxWidgets等。</p> 
<p>        但是这不代表C++不好，反而C++是很强大的，我们学习C++学的不仅仅是C++的语法，因为仅仅懂C++的语法有什么用呢？演示算法吗？当然不是了。我认为，学习C++初期当然是熟悉C++的语法，中期是学习STL库、系统API以及C++面向对象的思想和一般的设计方法，后者是伴随你C++生涯一生的，因为它没有终点。</p> 
<p>        除了加深对C++的理解之外，你还得需要各种各样的基于C++的库去实现更具体的东西。如果你想做GUI，那你得学习QT、wxWidgets等。如果想做游戏方面的那么Ogre、Unreal、Bigworld等库是你需要学习的。网络方面的库ASIO、RakNet、ACE等。这些库都是基于C++的，其封装了底层的API，似的我们可以不必每次去使用繁杂的API来实现我们想要的功能。当然你也可以使用C++去封装这些API，让自己成为一个库作者，方便他人。</p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0086a7b279ec109c1e3873ba68f0850f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">eclipse中配置的tomcat 启动正常 但是访问报404错误</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/423e4ee33a08e62cee06fcba1bda0cb5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在CentOS安装pptpd以及部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>