<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;çš„optionalè§£æ - èœé¸Ÿç¨‹åºå‘˜åšå®¢</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;çš„optionalè§£æ" />
<meta property="og:description" content="optionalç”¨æ³• 1 é—®é¢˜å¼•å‡º ç¼–ç¨‹ä¸­æˆ‘ä»¬å¯èƒ½ä¼šé‡åˆ°è¦å¤„ç†å¯èƒ½ä¸ºç©ºçš„å˜é‡ï¼Œæ¯”å¦‚è¯´å®¹å™¨ï¼ŒåŸºæœ¬ç±»å‹ï¼Œæˆ–è€…è¯´å¯¹è±¡å®ä¾‹ï¼Œæˆ‘ä»¬ç®€å•çœ‹ä¸ªä¾‹å­ï¼š
#include &lt;string&gt; #include &lt;vector&gt; #include &lt;memory&gt; struct Some { int some_i_ = 0; std::string some_str_; }; Some getSome(const std::vector&lt;Some&gt;&amp; svec, int i) { auto iter = std::find_if(svec.begin(), svec.end(), [i](const Some&amp; s) { return s.some_i_ == i; } ); if (iter != svec.end()) { return *iter; } return Some(); } int main() { std::vector&lt;Some&gt; someVec; someVec.push_back({1, &#34;1&#34;}); Some s = getSome(someVec, 1); s = getSome(someVec, 2); return 0; } è¿™é‡Œä»£ç å¾ˆç®€å•ï¼Œæˆ‘ä»¬æ ¹æ®æ¡ä»¶è·å–vectorä¸­ä¸€ä¸ªå…ƒç´ ï¼Œè¿™ä¸ªå…ƒç´ æ˜¯ä¸ªç»“æ„ä½“ï¼Œå½“æ»¡è¶³æ¡ä»¶æ—¶å¯ä»¥è¿”å›ï¼Œä½†æ˜¯æ²¡æœ‰æ‰¾åˆ°æ—¶ä»ç„¶è¦è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œåˆ°æˆ‘ä»¬mainå‡½æ•°ç”šè‡³è¦èŠ±ä¸€äº›åŠ›æ°”æ¥åˆ¤æ–­æœ‰æ²¡æœ‰æ‰¾åˆ°ã€‚å¦‚æœæ²¡æœ‰æ‰¾åˆ°åœ¨getSomeè¿”å›ç©ºå°±å¥½äº†ï¼Œè¿™æ ·æˆ‘ä»¬å°±æ¥ä»‹ç»optional" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/78c13cd5596cd5b59b9f929f4d5e5450/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-16T23:02:20+08:00" />
<meta property="article:modified_time" content="2020-08-16T23:02:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="èœé¸Ÿç¨‹åºå‘˜åšå®¢" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">èœé¸Ÿç¨‹åºå‘˜åšå®¢</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;çš„optionalè§£æ</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="optional_0"></a>optionalç”¨æ³•</h2> 
<h3><a id="1__1"></a>1 é—®é¢˜å¼•å‡º</h3> 
<p>ç¼–ç¨‹ä¸­æˆ‘ä»¬å¯èƒ½ä¼šé‡åˆ°è¦å¤„ç†å¯èƒ½ä¸ºç©ºçš„å˜é‡ï¼Œæ¯”å¦‚è¯´å®¹å™¨ï¼ŒåŸºæœ¬ç±»å‹ï¼Œæˆ–è€…è¯´å¯¹è±¡å®ä¾‹ï¼Œæˆ‘ä»¬ç®€å•çœ‹ä¸ªä¾‹å­ï¼š</p> 
<pre><code class="prism language-C++">#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

struct Some
{
    int some_i_ = 0;
    std::string some_str_;
};

Some
getSome(const std::vector&lt;Some&gt;&amp; svec, 
        int i)
{
    auto iter = 
      std::find_if(svec.begin(), svec.end(), 
        [i](const Some&amp; s) {
          return s.some_i_ == i;
        }
      );

    if (iter != svec.end()) {
        return *iter;
    }

    return Some();
}

int main()
{
    std::vector&lt;Some&gt; someVec;
    someVec.push_back({1, "1"});
    Some s = getSome(someVec, 1);
    s = getSome(someVec, 2);
    return 0;
}
</code></pre> 
<p>è¿™é‡Œä»£ç å¾ˆç®€å•ï¼Œæˆ‘ä»¬æ ¹æ®æ¡ä»¶è·å–vectorä¸­ä¸€ä¸ªå…ƒç´ ï¼Œè¿™ä¸ªå…ƒç´ æ˜¯ä¸ªç»“æ„ä½“ï¼Œå½“æ»¡è¶³æ¡ä»¶æ—¶å¯ä»¥è¿”å›ï¼Œä½†æ˜¯æ²¡æœ‰æ‰¾åˆ°æ—¶ä»ç„¶è¦è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œåˆ°æˆ‘ä»¬mainå‡½æ•°ç”šè‡³è¦èŠ±ä¸€äº›åŠ›æ°”æ¥åˆ¤æ–­æœ‰æ²¡æœ‰æ‰¾åˆ°ã€‚å¦‚æœæ²¡æœ‰æ‰¾åˆ°åœ¨getSomeè¿”å›ç©ºå°±å¥½äº†ï¼Œè¿™æ ·æˆ‘ä»¬å°±æ¥ä»‹ç»optional</p> 
<h3><a id="2__44"></a>2 ç®€ä»‹</h3> 
<p>ä½¿ç”¨std::optionalèƒ½å¤Ÿè¾¾åˆ°ä¸Šè¾¹çš„æ•ˆæœï¼Œæˆ‘ä»¬ç®€å•äº†è§£ä¸‹ï¼Œé¦–å…ˆoptionalæ˜¯åœ¨c++17å¼•å…¥ï¼Œå¯ä»¥çœ‹ä½œæ˜¯Tç±»å‹å’Œä¸€ä¸ªboolå€¼çš„åŒ…è£…ã€‚<br> å…³äºstd::optionalå¯ä»¥æ¥å—å¯¹è±¡æˆ–è€…nullopt(è¡¨ç¤ºä¸ºç©ºå€¼)ï¼Œå‚è€ƒä¸€æ®µä¾‹å­ï¼š</p> 
<pre><code class="prism language-C++">#include &lt;iostream&gt;
#include &lt;optional&gt;
using namespace std;

int main()
{
  std::optional&lt;int&gt; pp = 1;
  if (pp) {
      cout &lt;&lt; *pp &lt;&lt; endl; // 1
  }

  pp = nullopt;
  if (pp) {
      cout &lt;&lt; *pp &lt;&lt; endl; // ä¸è¾“å‡º
  }
}
</code></pre> 
<p>æˆ‘ä»¬çœ‹è¿™ä¸ªç®€å•çš„ä¾‹å­ï¼Œppç”¨æ¥å­˜æ”¾intçš„å¯¹è±¡ï¼Œåˆå§‹åŒ–ä¸º1ï¼Œåˆ¤æ–­ppæ˜¯å¦åŒ…å«å€¼ï¼Œå¯ä»¥è¾“å‡º1ï¼Œå°†nulloptèµ‹å€¼åï¼Œåˆ¤æ–­æ—¶ä¸ºfalseï¼Œè‡ªç„¶ä¹Ÿä¸ä¼šè¾“å‡ºã€‚æˆ‘ä»¬æŠŠä¸Šè¾¹é—ç•™çš„é‚£ä¸ªä¾‹å­é‡æ–°å†™ä¸€ä¸‹ï¼š</p> 
<pre><code class="prism language-C++">// snip...

#include &lt;iostream&gt;
using namespace std;

optional&lt;Some&gt; 
getSome(const std::vector&lt;Some&gt;&amp; svec, int i)
{
  auto iter = std::find_if(svec.begin(), svec.end(), [i](const Some&amp; s) {
      return s.some_i_ == i;
  });

  if (iter != svec.end()) {
      return *iter;
  }

  return nullopt;
}

int main()
{
  vector&lt;Some&gt; someVec;
  someVec.push_back({1, "11"});
  auto s_ptr = getSome(someVec, 1);
  if (s_ptr) {
      cout &lt;&lt; s_ptr-&gt;some_str_ &lt;&lt; endl; // â€œ11â€
  }

  s_ptr = getSome(someVec, 2);
  if (s_ptr) {
      cout &lt;&lt; s_ptr-&gt;some_str_ &lt;&lt; endl; // ä¸è¾“å‡º
  }
  return 0;
}
</code></pre> 
<p>æˆ‘ä»¬æŠŠgetSomeçš„è¿”å›å€¼çš„ç±»å‹æ”¹ä¸ºç”¨optionalåŒ…è£…ï¼Œå¦‚æœæ»¡è¶³æ¡ä»¶ç”¨Someå¯¹è±¡å¡«å……ï¼Œæ²¡æœ‰æ—¶ç”¨nulloptå¡«å……ï¼Œåœ¨mainå‡½æ•°é‡Œåˆ¤æ–­ä½¿ç”¨å³å¯ã€‚</p> 
<h2><a id="optional_105"></a>optionalç»†åˆ™</h2> 
<h3><a id="optinal_106"></a>åˆ›å»ºoptinal</h3> 
<p>æœ‰å‡ ç§æ–¹å¼åˆ›å»ºoptionalï¼Œæˆ‘ä»¬å…·ä½“çœ‹ä¸‹ä¾‹å­ï¼š</p> 
<ul><li>ç›´æ¥åˆ›å»ºæˆ–è€…ç”¨nulloptèµ‹å€¼</li></ul> 
<pre><code class="prism language-C++">std::optional&lt;int&gt; empty;
std::optional&lt;int&gt; opt = std::nullopt; 
</code></pre> 
<ul><li>ä½¿ç”¨å¯¹è±¡åˆå§‹åŒ–</li></ul> 
<pre><code class="prism language-C++">std::optional&lt;int&gt; opt = 1;

struct Some
{
  int some_i_ = 0;
  std::string some_str_;
};
Some s;
std::optional&lt;Some&gt; opt = s;
</code></pre> 
<ul><li>ä½¿ç”¨ std::make_optionalæ„é€ ,ç±»ä¼¼std::make_sharedå¯ä»¥ä¼ é€’å‚æ•°åŸåœ°æ„é€ optionalåŒ…å«çš„å¯¹è±¡</li></ul> 
<pre><code class="prism language-C++">struct Some
{
  Some(int i, std::string str):
          some_i_(i),
          some_str_(std::move(str)) {}

  int some_i_ = 0;
  std::string some_str_;
};
using namespace std;
optional&lt;Some&gt; opt = make_optional&lt;Some&gt;(1, "1");
auto opt = make_optional(1); // optional&lt;int&gt;
</code></pre> 
<ul><li>ä½¿ç”¨std::in_placeæ„é€ ï¼š<br> å…¶å®ä½¿ç”¨std::in_placeå’Œä½¿ç”¨std::make_optionalÂ ç”¨æ³•ç›¸è¿‘ï¼Œéƒ½æ˜¯åŸåœ°æ„é€ å¯¹è±¡ï¼Œé¿å…ä½¿ç”¨å¯¹è±¡åˆå§‹åŒ–è¿›è¡Œçš„ä¸€æ¬¡æ‹·è´ç­‰ã€‚std::in_placeåªæ˜¯ä¸€ä¸ªtagï¼Œç”¨æ¥è¡¨ç¤ºæˆ‘ä»¬ä½¿ç”¨std::optionalçš„é‚£ä¸ªæ„é€ å‡½æ•°ã€‚<br> optionalçš„æ„é€ å‡½æ•°æ˜¯è¿™æ ·ï¼š</li></ul> 
<pre><code class="prism language-C++">//
template &lt;class... _Args, class = enable_if_t&lt;
      is_constructible_v&lt;value_type, _Args...&gt;&gt;&gt;
constexpr explicit 
optional(in_place_t, _Args&amp;&amp;... __args)
      : __base(in_place, _VSTD::forward&lt;_Args&gt;(__args)...) {}

//
template &lt;class _Up, class... _Args, class = enable_if_t&lt;
      is_constructible_v&lt;value_type, initializer_list&lt;_Up&gt;&amp;, _Args...&gt;&gt;&gt;
constexpr explicit 
optional(in_place_t, initializer_list&lt;_Up&gt; __il, _Args&amp;&amp;... __args)
      : __base(in_place, __il, _VSTD::forward&lt;_Args&gt;(__args)...) {}
</code></pre> 
<p>è¿™é‡Œä¸¤ä¸ªæ„é€ å‡½æ•°å‚æ•°éƒ½æ˜¯ä»¥in_place_tç±»å‹ä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå°±æ˜¯è¡¨ç¤ºä¸€ä¸ªå ä½ç¬¦ï¼Œåè¾¹æˆ‘ä»¬ä¼ å…¥è¦æ„é€ å¯¹è±¡çš„å‚æ•°ã€‚æˆ‘ä»¬å‚è€ƒä¾‹å­ï¼š</p> 
<pre><code class="prism language-C++">struct Some
{
  Some(int i, std::string str):
          some_i_(i),
          some_str_(std::move(str)) {}

  int some_i_ = 0;
  std::string some_str_;
};
using namespace std;
optional&lt;Some&gt; opt {in_place, 1, "1"};
</code></pre> 
<p>å†™èµ·æ¥è¦æ¯”std::make_optionalç®€ä¾¿å¾ˆå¤š</p> 
<h3><a id="optional_174"></a>optionalçš„å…¶ä»–æ“ä½œ</h3> 
<pre><code class="prism language-C++">/// 1
optional&lt;int&gt; opt {1};
opt.value(); // 1
*opt // 1

/// 2
optional&lt;int&gt; opt;
opt.value(); // æŠ›å‡ºå¼‚å¸¸
*opt // ä¸ºå®šä¹‰
opt.value_or(2); // 2(æ²¡æœ‰å€¼æ—¶ä½¿ç”¨é»˜è®¤å€¼)

///3
optional&lt;int&gt; opt{2};
opt.emplace(4); // é‡æ–°æ„é€ 4çš„å¯¹è±¡
opt.reset(); // é‡Šæ”¾æ‰åŸæ¥çš„å¯¹è±¡ï¼Œnullopt
</code></pre> 
<h2><a id="optional_194"></a>optionalæ¯”è¾ƒ</h2> 
<h3><a id="_195"></a>å’ŒæŒ‡é’ˆæ¯”è¾ƒ</h3> 
<p>å¤§å®¶æ˜¯å¦åœ¨æƒ³æŒ‡é’ˆæ˜¯ä¸æ˜¯ä¹Ÿå¯ä»¥è¾¾åˆ°è¿™æ ·çš„æ•ˆæœï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ï¼š</p> 
<ul><li>å¦‚æœæˆ‘ä»¬å’Œæ™®é€šçš„æŒ‡é’ˆç›¸æ¯”ï¼Œå³ç”¨æŒ‡é’ˆæŒ‡å‘å¯¹è±¡ï¼Œå¦‚æœä¸ºç©ºçš„æ—¶å€™ä½¿ç”¨nullptræ¥ä»£æ›¿ï¼Œå¯¹äºæˆ‘ä»¬ç¬¬ä¸€ä¸ªä¾‹å­å¯ä»¥è¾¾åˆ°ç›¸ä¼¼çš„æ•ˆæœï¼Œå› ä¸ºæˆ‘ä»¬çš„vectorçš„ç”Ÿå‘½å‘¨æœŸæ—¶åœ¨ä½¿ç”¨æŒ‡é’ˆä¹‹åé”€æ¯ï¼Œå› ä¸ºæŒ‡é’ˆåªæ˜¯ç®€å•æŒ‡å‘ï¼Œå¯¹äºæŒ‡å‘å·²ç»ææ„çš„å¯¹è±¡ï¼Œæ— ç–‘æ˜¯ä¸€åœºç¾éš¾ã€‚</li><li>å¦‚æœå’Œæˆ‘ä»¬æ™ºèƒ½æŒ‡é’ˆæ¯”è¾ƒï¼Œä¾‹å¦‚ç¬¬ä¸€ä¸ªä¾‹å­ä¸­ï¼Œ<br> ç¬¬ä¸€ç§å®ç°æˆ‘ä»¬éœ€è¦vectorå­˜æ”¾shared_ptræ‰èƒ½è¿›è¡Œæ‹·è´ï¼š</li></ul> 
<pre><code class="prism language-C++">shared_ptr&lt;Some&gt; getSome(
    const vector&lt;shared_ptr&lt;Some&gt;&gt;&amp; svec, 
    int i)
{
    auto iter = std::find_if(svec.begin(), svec.end(), [i](const Some&amp; s) {
        return s.some_i_ == i;
    });

    if (iter != svec.end()) {
        return *iter;
    }

    return nullptr;
}
</code></pre> 
<p>å®ç°èµ·æ¥æœ‰ç‚¹ç¹çï¼Œå¹¶ä¸”è¿˜éœ€è¦æ”¹åŠ¨svecï¼Œè¿™ä¸å¦¥ã€‚æˆ–è€…çœ‹èµ·æ¥è¿™æ ·ï¼š</p> 
<pre><code class="prism language-C++">shared_ptr&lt;Some&gt; 
getSome(const vector&lt;Some&gt;&amp; svec, int i)
{
    auto iter = std::find_if(svec.begin(), svec.end(), [i](const Some&amp; s) {
        return s.some_i_ == i;
    });

    if (iter != svec.end()) {
        Some s = *iter;
        return shared_ptr&lt;Some&gt;{&amp;s};
    }

    return nullptr;
}
</code></pre> 
<p>è¿™æ ·å°±å’Œæˆ‘ä»¬ä½¿ç”¨æ™®é€šæŒ‡é’ˆæ˜¯ä¸€æ ·çš„ï¼Œå¹¶ä¸”shared_ptrå¼•ç”¨è®¡æ•°ä¸º0çš„æ—¶å€™è¿˜æ˜¯ä¼šåšé”€æ¯ï¼Œè¿™æ ·æ˜¯é”™è¯¯çš„ã€‚<br> æœ€åä¸€ç§å°±æ˜¯é‡æ–°æ„é€ ä¸€ä¸ªSomeå¯¹è±¡ï¼Œæ™®é€šæŒ‡é’ˆå’Œæ™ºèƒ½éƒ½å¯ä»¥å®ç°ã€‚æ™®é€šæŒ‡é’ˆéœ€è¦åšdeleteæ“ä½œï¼Œå¦‚æœç”¨æ™ºèƒ½æŒ‡é’ˆå®ç°ä¹Ÿå¯ä»¥ï¼š</p> 
<pre><code class="prism language-C++">shared_ptr&lt;Some&gt;
getSome(const vector&lt;Some&gt;&amp; svec, int i)
{
    auto iter = std::find_if(svec.begin(), svec.end(), 
    [i](const Some&amp; s) {
        return s.some_i_ == i;
    });

    if (iter != svec.end()) {
        return std::make_shared&lt;Some&gt;(*iter);
    }

    return nullptr;
}
</code></pre> 
<p>æˆ‘ä»¬å‘ç°æ™ºèƒ½æŒ‡é’ˆä¹Ÿå¯ä»¥å……å½“è¿™æ ·çš„è§’è‰²ï¼Œå¦‚ä½•ä½¿ç”¨è¦çœ‹å¤§å®¶äº†ï¼Œä¸è¿‡æ—¢ç„¶æ¨å‡ºäº†æ–°çš„æ ‡å‡†ï¼Œè€Œä¸”å¦‚æœè¦å®ç°å¦‚æ­¤åŠŸèƒ½æ„Ÿè§‰è¿˜æ˜¯optionalä½¿ç”¨èµ·æ¥æ–¹ä¾¿ä¸€ç‚¹ï¼Œè¯­ä¹‰æ˜ç¡®ï¼Œè€Œä¸”ä»£ç å¯è¯»æ€§è¾ƒå¥½ã€‚</p> 
<h3><a id="rustoption_253"></a>å’Œrustçš„optionæ¯”è¾ƒ</h3> 
<p>é¦–å…ˆrustçš„optionæ˜¯ä¸€ä¸ªæšä¸¾ï¼š</p> 
<pre><code class="prism language-rust">enum Option&lt;T&gt; {
  Some(T),
  None,
} 
</code></pre> 
<p>è¿™ä¸ªæšä¸¾æ˜¯ä¸ªæ¨¡ç‰ˆï¼Œæšä¸¾ä¸­æ¯ä¸ªå…ƒç´ å¯ä»¥å­˜æ”¾å¯¹è±¡æˆ–è€…ä¸å­˜æ”¾ï¼Œç±»ä¼¼ä¹‹å‰ä¾‹å­çš„rustçš„ç®€å•å®ç°ï¼š</p> 
<pre><code class="prism language-rust">fn getSome(b: bool) -&gt; Option&lt;i32&gt; {
    if b {
        return Some(3);
    }

    return None;
}

fn main() {
    let b = false;
    if let Some(s) = getSome(b) {
        println!("hello.. {}", s);
    }
    else {
        println!("hello.. null");
    }
}
</code></pre> 
<p>getSomeå¦‚æœæ»¡è¶³æ¡ä»¶è¿”å›Some,ä¸æ»¡è¶³è¿”å›Noneã€‚<br> rustè‡´åŠ›äºä¸€ä¸ªå®‰å…¨çš„è¯­è¨€ï¼Œoptionæ˜¯preludeï¼Œä¸éœ€è¦æ˜¾ç¤ºå¼•å…¥ä½œç”¨åŸŸï¼ŒåŒæ ·ä¸éœ€è¦Option::å‰ç¼€æ¥ç›´æ¥ä½¿ç”¨Someå’ŒNoneï¼ŒåŒæ—¶è¿˜é…å¥—å’Œä¸€äº›ç›¸å…³å®‰å…¨çš„å‡½æ•°ï¼Œçœ‹èµ·æ¥æ¯”C++çš„ç®€ä¾¿ä¸€äº›ï¼Œæˆ‘ä»¬è¿™é‡Œå°±åšä¸€ä¸ªå¯¹æ¯”ã€‚ğŸ˜Š</p> 
<h2><a id="_284"></a>å‚è€ƒ</h2> 
<p>https://en.cppreference.com/w/cpp/utility/optional/optional <br><br> https://kaisery.gitbooks.io/trpl-zh-cn/content/ch06-01-defining-an-enum.html<br><br> ç­‰</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47519a0aaa0f931f00ef8f36b4ff4018/" rel="prev">
			<span class="pager__subtitle">Â«&thinsp;Previous</span>
			<p class="pager__title">leetcode_56_åˆå¹¶åŒºé—´_57_æ’å…¥åŒºé—´</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6c8f6667ac91feb30ea69f3d6e4f7150/" rel="next">
			<span class="pager__subtitle">Next&thinsp;Â»</span>
			<p class="pager__title">è½»é‡åŒ–ç¥ç»ç½‘ç»œä¸“é¢˜æ–‡çŒ®ç»¼è¿°</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 èœé¸Ÿç¨‹åºå‘˜åšå®¢.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>