<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux三大根文件系统移植 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux三大根文件系统移植" />
<meta property="og:description" content="文章目录 前言一、buildroot1、buildroot 下载2、buildroot 构建根文件系统配置 buildroot编译 buildroot偶遇BUG 3、根文件系统测试第三方软件和库的配置 4、buildroot 下的 busybox 配置busybox 配置busybox 中文字符的支持编译 busybox遇到问题 二、Yocto1、在线构建根文件系统安装与配置git获取 yocto 项目 2、离线构建根文件系统构建根文件系统构建 SDK 工具 三、Ubuntu-base1、ubuntu-base 获取2、ubuntu 根文件系统构建解压缩 ubuntu base 根文件系统安装 qemu设置软件源在主机挂载并配置根文件系统 3、ubuntu 根文件系统测试nfs 挂载测试buntu 根文件系统烧写 4、ubuntu 根文件系统继续添加部分添加新用户网络 DHCP 配置安装软件FTP 服务器搭建 总结 前言 文章主要来自正点原子的教学文档，本文将驱动开发篇中的根文件系统和yocto构建篇合并起来，部分内容加入自己的理解和补充自己遇到的问题以及解决方法。
首先，busybox 构建的根文件系统不齐全，很多东西需要我们自行添加，比如 lib 库文件。
如果自己纯手工去移植过一个第三方软件，就会发现这个软件会依赖很多库，而移植其中某一个库又需要依赖其他库，一连串的连锁反应会导致移植过程十分艰难！！！
所以 buildroot 就为此而生，只需要在 makefile 中添加这么一句：
DEPENDS:=&#43;aaa &#43;bbb &#43;ccc buildroot 就会帮你自动编译 aaa库、bbb库、ccc库，不够可以再加。
即使本地没有这些包，也会自动从它们的开源网站上下载。
再次批评一下 busybox，busybox 仅仅只是帮我们构建好了一些常用的命令和文件，像 lib 库、/etc 目录下的一些文件都需要我们自己手动创建，而且 busybox 构建的根文件系统默认没有用户名和密码设置。
而 buildroot 不仅集成了 busybox，而且还集成了各种常见的第三方库和软件！！！
前置知识：文章所有提到的 nfs 目录，实际上是使用 nfs 文件系统，将开发板根目录挂载到虚拟机的 nfs 目录中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/83d8bcde73b1a945351db580b664ad8e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-23T17:34:47+08:00" />
<meta property="article:modified_time" content="2023-08-23T17:34:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux三大根文件系统移植</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_5" rel="nofollow">前言</a></li><li><a href="#buildroot_24" rel="nofollow">一、buildroot</a></li><li><ul><li><a href="#1buildroot__26" rel="nofollow">1、buildroot 下载</a></li><li><a href="#2buildroot__29" rel="nofollow">2、buildroot 构建根文件系统</a></li><li><ul><li><a href="#_buildroot_30" rel="nofollow">配置 buildroot</a></li><li><a href="#_buildroot_109" rel="nofollow">编译 buildroot</a></li><li><a href="#BUG_122" rel="nofollow">偶遇BUG</a></li></ul> 
   </li><li><a href="#3_140" rel="nofollow">3、根文件系统测试</a></li><li><ul><li><a href="#_155" rel="nofollow">第三方软件和库的配置</a></li></ul> 
   </li><li><a href="#4buildroot__busybox__176" rel="nofollow">4、buildroot 下的 busybox 配置</a></li><li><ul><li><a href="#busybox__177" rel="nofollow">busybox 配置</a></li><li><a href="#busybox__244" rel="nofollow">busybox 中文字符的支持</a></li><li><a href="#_busybox_340" rel="nofollow">编译 busybox</a></li><li><a href="#_357" rel="nofollow">遇到问题</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Yocto_410" rel="nofollow">二、Yocto</a></li><li><ul><li><a href="#1_420" rel="nofollow">1、在线构建根文件系统</a></li><li><ul><li><a href="#git_422" rel="nofollow">安装与配置git</a></li><li><a href="#_yocto__439" rel="nofollow">获取 yocto 项目</a></li></ul> 
   </li><li><a href="#2_632" rel="nofollow">2、离线构建根文件系统</a></li><li><ul><li><a href="#_634" rel="nofollow">构建根文件系统</a></li><li><a href="#_SDK__657" rel="nofollow">构建 SDK 工具</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Ubuntubase_661" rel="nofollow">三、Ubuntu-base</a></li><li><ul><li><a href="#1ubuntubase__663" rel="nofollow">1、ubuntu-base 获取</a></li><li><a href="#2ubuntu__678" rel="nofollow">2、ubuntu 根文件系统构建</a></li><li><ul><li><a href="#_ubuntu_base__679" rel="nofollow">解压缩 ubuntu base 根文件系统</a></li><li><a href="#_qemu_695" rel="nofollow">安装 qemu</a></li><li><a href="#_706" rel="nofollow">设置软件源</a></li><li><a href="#_732" rel="nofollow">在主机挂载并配置根文件系统</a></li></ul> 
   </li><li><a href="#3ubuntu__806" rel="nofollow">3、ubuntu 根文件系统测试</a></li><li><ul><li><a href="#nfs__807" rel="nofollow">nfs 挂载测试</a></li><li><a href="#buntu__820" rel="nofollow">buntu 根文件系统烧写</a></li></ul> 
   </li><li><a href="#4ubuntu__831" rel="nofollow">4、ubuntu 根文件系统继续添加部分</a></li><li><ul><li><a href="#_832" rel="nofollow">添加新用户</a></li><li><a href="#_DHCP__872" rel="nofollow">网络 DHCP 配置</a></li><li><a href="#_884" rel="nofollow">安装软件</a></li><li><a href="#FTP__892" rel="nofollow">FTP 服务器搭建</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_900" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_5"></a>前言</h2> 
<p><font color="red">文章主要来自正点原子的教学文档，本文将驱动开发篇中的根文件系统和yocto构建篇合并起来，部分内容加入自己的理解和补充自己遇到的问题以及解决方法。</font></p> 
<p>首先，busybox 构建的根文件系统不齐全，很多东西需要我们自行添加，比如 lib 库文件。<br> 如果自己纯手工去移植过一个第三方软件，就会发现这个软件会依赖很多库，而移植其中某一个库又需要依赖其他库，一连串的连锁反应会导致移植过程十分艰难！！！<br> 所以 buildroot 就为此而生，只需要在 makefile 中添加这么一句：</p> 
<pre><code class="prism language-powershell">DEPENDS:=<span class="token operator">+</span>aaa <span class="token operator">+</span>bbb <span class="token operator">+</span>ccc
</code></pre> 
<p>buildroot 就会帮你自动编译 aaa库、bbb库、ccc库，不够可以再加。<br> 即使本地没有这些包，也会自动从它们的开源网站上下载。</p> 
<p>再次批评一下 busybox，busybox 仅仅只是帮我们构建好了一些常用的命令和文件，像 lib 库、/etc 目录下的一些文件都需要我们自己手动创建，而且 busybox 构建的根文件系统默认没有用户名和密码设置。<br> 而 buildroot 不仅<strong>集成了 busybox</strong>，而且还集成了各种常见的第三方库和软件！！！</p> 
<p>前置知识：文章所有提到的 nfs 目录，实际上是使用 nfs 文件系统，将开发板根目录挂载到虚拟机的 nfs 目录中。</p> 
<h2><a id="buildroot_24"></a>一、buildroot</h2> 
<h3><a id="1buildroot__26"></a>1、buildroot 下载</h3> 
<p>https://buildroot.org/，略…<br> （因为这玩意一般都是平台装到 SDK 里面的，直接用 SDK 装好的那个就好）</p> 
<h3><a id="2buildroot__29"></a>2、buildroot 构建根文件系统</h3> 
<h4><a id="_buildroot_30"></a>配置 buildroot</h4> 
<p>源码的顶层目录输入：make menuconfig<br> <img src="https://images2.imgbox.com/17/5c/34uV6usb_o.png" alt="在这里插入图片描述"><br> 接下来我们就依次配置 buildroot，配置完成以后就可以进行编译了。<br> （1）配置 Target options<br> 首先配置 Target options 选项，需要配置的项目和其对应的内容如下(“=”号后面是配置项要选择的内容！)：</p> 
<pre><code class="prism language-powershell">Target options
    <span class="token operator">-</span>&gt; Target Architecture              = ARM <span class="token punctuation">(</span>little endian<span class="token punctuation">)</span> 
    <span class="token operator">-</span>&gt; Target Binary Format             = ELF
    <span class="token operator">-</span>&gt; Target Architecture Variant      = cortex-A7
    <span class="token operator">-</span>&gt; Target ABI                       = EABIhf
    <span class="token operator">-</span>&gt; Floating point strategy          = NEON/VFPv4
    <span class="token operator">-</span>&gt; ARM instruction <span class="token function">set</span>              = ARM
</code></pre> 
<p>配置完成以后如下图所示：<br> <img src="https://images2.imgbox.com/62/7e/PUF5mGu9_o.png" alt="在这里插入图片描述"><br> （2）配置 Toolchain<br> 此配置项用于配置交叉编译工具链，也就是交叉编译器。<br> buildroot 其实是可以自动下载交叉编译器的，但是都是从国外服务器下载的，鉴于国内的网络环境，还是用现成的吧。需要配置的项目和其对应的内容如下：</p> 
<pre><code class="prism language-powershell">Toolchain
    <span class="token operator">-</span>&gt; Toolchain <span class="token function">type</span>   = External toolchain
    <span class="token operator">-</span>&gt; Toolchain        = Custom toolchain <span class="token operator">/</span><span class="token operator">/</span>用户自己的交叉编译器
    <span class="token operator">-</span>&gt; Toolchain origin = Pre-installed toolchain <span class="token operator">/</span><span class="token operator">/</span>预装的编译器
    <span class="token operator">-</span>&gt; Toolchain path   =<span class="token operator">/</span>usr/local/arm/gcc-linaro-4<span class="token punctuation">.</span>9<span class="token punctuation">.</span>4-2017<span class="token punctuation">.</span>01-x86_64_arm-linux-gnueabihf 
    <span class="token operator">-</span>&gt; Toolchain prefix = $<span class="token punctuation">(</span>ARCH<span class="token punctuation">)</span><span class="token operator">-</span>linux-gnueabihf <span class="token operator">/</span><span class="token operator">/</span>前缀
    <span class="token operator">-</span>&gt; External toolchain gcc version = 4<span class="token punctuation">.</span>9<span class="token punctuation">.</span>x
    <span class="token operator">-</span>&gt; External toolchain kernel headers series = 4<span class="token punctuation">.</span>1<span class="token punctuation">.</span>x
    <span class="token operator">-</span>&gt; External toolchain C library = glibc/eglibc 
    <span class="token operator">-</span>&gt; <span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Toolchain has SSP support? <span class="token punctuation">(</span>NEW<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span>选中
    <span class="token operator">-</span>&gt; <span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Toolchain has RPC support? <span class="token punctuation">(</span>NEW<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span>选中
    <span class="token operator">-</span>&gt; <span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Toolchain has C+<span class="token operator">+</span> support?       <span class="token operator">/</span><span class="token operator">/</span>选中
    <span class="token operator">-</span>&gt; <span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Enable MMU support <span class="token punctuation">(</span>NEW<span class="token punctuation">)</span>         <span class="token operator">/</span><span class="token operator">/</span>选中
</code></pre> 
<p>Toolchain：设置为 Custom toolchain，表示使用用户自己的交叉编译器。<br> Toolchain origin：设置为 Pre-installed toolchain，表示使用预装的交叉编译器。<br> Toolchain path：设置自己安装的交叉编译器绝对路径！buildroot 要用到。<br> Toolchain prefix：设置交叉编译器前缀，要根据自己实际所使用的交叉编译器来设置，比<br> 如我们使用的是 arm-linux-gnueabihf-gcc，因此前缀就是$(ARCH)-linux-gnueabihf，其中 ARCH 我们前面已经设置为了 arm。<br> （3）配置 System configuration<br> 此选项用于设置一些系统配置，比如开发板名字、欢迎语、用户名、密码等。需要配置的项目和其对应的内容如下：</p> 
<pre><code class="prism language-powershell">System configuration
    <span class="token operator">-</span>&gt; System hostname = alpha_imx6ull             <span class="token operator">/</span><span class="token operator">/</span>平台名字，自行设置
    <span class="token operator">-</span>&gt; System banner = Welcome to alpha i<span class="token punctuation">.</span>mx6ull   <span class="token operator">/</span><span class="token operator">/</span>欢迎语
    <span class="token operator">-</span>&gt; Init system = BusyBox                       <span class="token operator">/</span><span class="token operator">/</span>使用 busybox
    <span class="token operator">-</span>&gt; <span class="token operator">/</span>dev management = Dynamic <span class="token keyword">using</span> devtmpfs <span class="token operator">+</span> mdev <span class="token operator">/</span><span class="token operator">/</span>使用 mdev
    <span class="token operator">-</span>&gt; <span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Enable root login with password <span class="token punctuation">(</span>NEW<span class="token punctuation">)</span>       <span class="token operator">/</span><span class="token operator">/</span>使能登录密码
    <span class="token operator">-</span>&gt; Root password = 123456 <span class="token operator">/</span><span class="token operator">/</span>登录密码为 123456
</code></pre> 
<p>（4）配置 Filesystem images<br> 此选项配置我们最终制作的根文件系统为什么格式的，配置如下：</p> 
<pre><code class="prism language-powershell"><span class="token operator">-</span>&gt; Filesystem images
    <span class="token operator">-</span>&gt; <span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> ext2/3/4 root filesystem     <span class="token operator">/</span><span class="token operator">/</span>如果是 EMMC 或 SD 卡的话就用 ext3/ext4
        <span class="token operator">-</span>&gt; ext2/3/4 variant = ext4      <span class="token operator">/</span><span class="token operator">/</span>选择 ext4 格式
    <span class="token operator">-</span>&gt; <span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> ubi image containing an ubifs root filesystem <span class="token operator">/</span><span class="token operator">/</span>如果使用 NAND 的话就用 ubifs
</code></pre> 
<p>先说一下啊，根文件系统的打包方式有很多。linux系统也提供了很多工具可以打包，这个后期会继续讲。<br> （5）禁止编译 Linux 内核和 uboot<br> buildroot 也可以编译 linux 内核和 uboot。当配置 buildroot，但是会自动下载最新的 linux 内核和 uboot 源码并编译。<br> 那就太可怕了。</p> 
<pre><code class="prism language-powershell"><span class="token operator">-</span>&gt; Kernel 
    <span class="token operator">-</span>&gt; <span class="token punctuation">[</span> <span class="token punctuation">]</span> Linux Kernel <span class="token operator">/</span><span class="token operator">/</span>不要选择编译 Linux Kernel 选项！
</code></pre> 
<p><img src="https://images2.imgbox.com/91/13/ZFxaSEXa_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-powershell"><span class="token operator">-</span>&gt; Bootloaders 
<span class="token operator">-</span>&gt; <span class="token punctuation">[</span> <span class="token punctuation">]</span> U-Boot <span class="token operator">/</span><span class="token operator">/</span>不要选择编译 U-Boot 选项！
</code></pre> 
<p><img src="https://images2.imgbox.com/9b/e0/KJD1mPdI_o.png" alt="在这里插入图片描述"><br> （6）配置 Target packages<br> 此选项用于配置要选择的第三方库或软件、比如 alsa-utils、ffmpeg、iperf 等工具，但是现<br> 在我们先不选择第三方库，防止编译不下去！先编译一下最基本的根文件系统，如果没有问题<br> 的话再重新配置选择第三方库和软件。</p> 
<h4><a id="_buildroot_109"></a>编译 buildroot</h4> 
<pre><code class="prism language-powershell">sudo make <span class="token operator">/</span><span class="token operator">/</span>注意，一定要加 sudo，而且不能通过<span class="token operator">-</span>jx 来指定多核编译！！！
</code></pre> 
<p>编译完成以后 buildroot 就会生成编译出来的根文件<br> 系统压缩包。<br> 如果编译过程中，buildroot 需要自己下载一些源码包，从而它要在国外网站下载很久很久，emmm……<br> 那我们可以自己添加源码包呀！<br> 例如：cmake-3.8.2.tar.gz<br> 我 们可以自行到<br> https://cmake.org/files/v3.8/cmake-3.8.2.tar.gz 这个网站上去将 cmake-3.8.2.tar.gz 这个源码下载下来，然后拷贝到buildroot 源码目录下的 dl 文件夹中，dl 文件夹专用用于存放下载下来的源码。<br> 这样，在需要这个第三方软件编进系统的时候，buildroot 就会用 dl/ 目录下的 cmake-3.8.2.tar.gz。</p> 
<h4><a id="BUG_122"></a>偶遇BUG</h4> 
<p>但是我遇到过一个问题，就是明明有源码包了，而且哈希校验也可以通过，但是 buildroot 就是会去下载源码包！！！<br> TMD，关键是国内这个网络限制，最后都会下载失败。<br> 然后我就把这个软件包给解压了，把软件包里的 makefile 的源码地址给注释掉。buildroot 就会去用下载好的源码包。</p> 
<p>最后等待编译完成，编译完成以后就会在buildroot 最外层的 output/images/ 目录下生成根文件系统。</p> 
<p>buildroot 会编译出来了多种格式的 rootfs，比如 ext2、ext4、ubi 等。其中<br> rootfs.tar 就是打包好的根文件系统，我们就使用 rootfs.tar 进行测试。<br> 在 nfs 目录下新建一个名<br> 为 buildrootfs 的文件夹，然后将 rootfs.tar 拷贝到 buildrootfs 目录下并解压，命令如下：</p> 
<pre><code class="prism language-powershell"><span class="token function">cp</span> rootfs<span class="token punctuation">.</span>tar <span class="token punctuation">.</span><span class="token operator">/</span>                   <span class="token operator">/</span><span class="token operator">/</span>拷贝到根目录
tar
tar <span class="token operator">-</span>vxf rootfs<span class="token punctuation">.</span>tar                <span class="token operator">/</span><span class="token operator">/</span>解压缩 rootfs<span class="token punctuation">.</span>tar
</code></pre> 
<p>解压缩完成以后的 buildrootfs/ 目录如图所示：（注意是目录，这个目录要挂载到系统的）<br> <img src="https://images2.imgbox.com/24/c8/Hy59gRxb_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_140"></a>3、根文件系统测试</h3> 
<p>首先得先挂载根文件系统，启动uboot，修改 bootargs 环境变量，设置 nfsroot 目录为 buildrootfs 目录。</p> 
<pre><code class="prism language-powershell">setenv bootargs <span class="token string">'console=tty1 console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.253:
../../nfs/buildrootfs rw ip=192.168.1.251:192.168.1.253:192.168.1.1:255.255.
255.0::eth0:off'</span>
<span class="token operator">/</span><span class="token operator">*</span> 不同的板子设置不一样，看着改 <span class="token operator">*</span><span class="token operator">/</span>
</code></pre> 
<p>emmm……学过设备树的同学肯定知道这个 bootargs 参数肯定也可以通过设备树的 chosen 节点修改。<br> 设置好以后启动系统，进入根文件系统以后如图：<br> <img src="https://images2.imgbox.com/42/ee/AT1IkKIg_o.png" alt="在这里插入图片描述"><br> 提示没有 /lib/modules/ 目录，这个目录是存放模块驱动的目录，既然它提示了，就说明了这个目录的重要性。既然没有，那就先自己创建吧。<br> 其实在把模块编进内核的时候，就可以通过修改 makefile 来创建。<br> 进入根文件目录：<br> <img src="https://images2.imgbox.com/85/05/TEStmfQc_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_155"></a>第三方软件和库的配置</h4> 
<p>先说好一件事！！！buildroot能配置的都是 linux 系统支持的第三方软件包，如果自己写的模块怎么编进内核？？？那就要和驱动一样，写 makefile ，在 makefile 中写好编译路径和放置的路径。<br> 回到正题，以移植 alsa 为例：<br> （1）使能 alsa-lib<br> 输入 make menuconfig，打开 buildroot 配置界面，配置路径如下：</p> 
<pre><code class="prism language-powershell">Target packages
    <span class="token operator">-</span>&gt; Libraries
        <span class="token operator">-</span>&gt; Audio/Sound 
            <span class="token operator">-</span>&gt; <span class="token operator">-</span><span class="token operator">*</span><span class="token operator">-</span> alsa-lib <span class="token operator">--</span><span class="token operator">-</span>&gt; 此配置项下的文件全部选中
</code></pre> 
<p><img src="https://images2.imgbox.com/e0/7e/T2yuApb3_o.png" alt="在这里插入图片描述"><br> （2）使能 alsa-utils</p> 
<pre><code class="prism language-powershell">Target packages 
    <span class="token operator">-</span>&gt; Audio and video applications 
        <span class="token operator">-</span>&gt; alsa-utils                 <span class="token operator">/</span><span class="token operator">/</span>此目录下的软件全部选中
</code></pre> 
<p><img src="https://images2.imgbox.com/14/b4/vXKemTUr_o.png" alt="在这里插入图片描述"><br> 然后重新编译 buildroot，使用新的 /rootfs.tar 就可以使用 alsa 这个软件了。</p> 
<h3><a id="4buildroot__busybox__176"></a>4、buildroot 下的 busybox 配置</h3> 
<h4><a id="busybox__177"></a>busybox 配置</h4> 
<p>emmm……怎么说好呢，buildroot 其实也是用了 busybox 来制作的，只不过加了很多便携性的包装。<br> 在 dl 目录下就有一个 busybox 压缩包。buildroot 将所有解压缩后的软件保存在/output/build 软件中，我们可以在找到/output/build/busybox-1.29.3 这个文件夹，此文件夹就是解压后的 busybox 源码。<br> <img src="https://images2.imgbox.com/d2/6e/JaxPQvQh_o.png" alt="在这里插入图片描述"><br> 除非我们删除了解压后的源码，不然 buildroot 就会一直使用解压出来源码，不会重新再解压一次。<br> 如果想在 busybox 中添加或者修改代码，emmm……可以但是不要在这里作si，写几个 patch 在编译时运行才是最优的。</p> 
<p>busybox 有几种默认的配置选项：</p> 
<ul><li>defconfig，缺省配置，也就是默认配置选项</li><li>allyesconfig，全选配置，也就是选中 busybox 的所有功能</li><li>allnoconfig，最小配置</li></ul> 
<p>一般使用默认配置即可，在 busybox 目录运行命令配置一下 busybox：</p> 
<pre><code class="prism language-powershell">make defconfig
</code></pre> 
<p>要配置 buildroot 下的 busybox，肯定要打开 busybox 的配置界面，在 buildroot<br> 下打开 busybox 的配置界面输入如下命令：</p> 
<pre><code class="prism language-powershell">sudo make busybox-menuconfig
</code></pre> 
<p><img src="https://images2.imgbox.com/5c/f2/SxBLUKAp_o.png" alt="在这里插入图片描述"><br> 配置路径如下：</p> 
<pre><code class="prism language-powershell">Location: 
 <span class="token operator">-</span>&gt; Settings 
     <span class="token operator">-</span>&gt; Build static binary <span class="token punctuation">(</span>no shared libs<span class="token punctuation">)</span>
</code></pre> 
<p>Build static binary (no shared libs) 用来决定是静态编译 busybox 还是动态编译，静态编译的话就不需要库文件，但是编译出来的库会很大。动态编译的话要求根文件系统中有库文件，但是编译出来的 busybox 会小很多。<br> 这里我们不能采用静态编译！因为采用静态编译的话 DNS 会出问题！无法进行域名解析，配置如图：<br> <img src="https://images2.imgbox.com/d5/06/oIph6CCy_o.png" alt="在这里插入图片描述"><br> 继续配置如下路径配置项：</p> 
<pre><code class="prism language-powershell">Location: 
<span class="token operator">-</span>&gt; Settings 
    <span class="token operator">-</span>&gt; vi-style line editing commands
</code></pre> 
<p>结果如图所示：<br> <img src="https://images2.imgbox.com/fd/fe/UKtG6Fjo_o.png" alt="在这里插入图片描述"><br> 继续配置如下路径配置项：</p> 
<pre><code class="prism language-powershell">Location: 
<span class="token operator">-</span>&gt; Linux Module Utilities
    <span class="token operator">-</span>&gt; Simplified modutils
</code></pre> 
<p>默认会选中“Simplified modutils”，这里我们要取消勾选！！结果如图所示：<br> <img src="https://images2.imgbox.com/de/80/JnmpRmSx_o.png" alt="在这里插入图片描述"><br> 继续配置如下路径配置项：</p> 
<pre><code class="prism language-powershell">Location: 
<span class="token operator">-</span>&gt; Linux System Utilities 
 <span class="token operator">-</span>&gt; mdev <span class="token punctuation">(</span>16 kb<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span>确保下面的全部选中，默认都是选中的
</code></pre> 
<p>结果如图所示：<br> <img src="https://images2.imgbox.com/49/55/8Bub7BPN_o.png" alt="在这里插入图片描述"><br> 最后就是使能 busybox 的 unicode 编码以支持中文，配置路径如下：</p> 
<pre><code class="prism language-powershell">Location: 
 <span class="token operator">-</span>&gt; Settings
     <span class="token operator">-</span>&gt; Support Unicode <span class="token operator">/</span><span class="token operator">/</span>选中
         <span class="token operator">-</span>&gt; Check <span class="token variable">$LC_ALL</span><span class="token punctuation">,</span> <span class="token variable">$LC_CTYPE</span> and <span class="token variable">$LANG</span> environment variables <span class="token operator">/</span><span class="token operator">/</span>选中
</code></pre> 
<p>结果如图所示：<br> <img src="https://images2.imgbox.com/e2/e4/n6D4xtxf_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="busybox__244"></a>busybox 中文字符的支持</h4> 
<p>如果默认直接编译 busybox 的话，在使用 SecureCRT 的时候中文字符是显示不正常的，中文字<br> 符会显示为 ?，比如你的中文目录，中文文件都显示为“?”。不知道从哪个版本开始 busybox<br> 中的 shell 命令对中文输入即显示做了限制，即使内核支持中文但在 shell 下也依然无法正确显<br> 示。<br> 所以我们需要修改 busybox 源码，取消 busybox 对中文显示的限制，打开文件 busybox-<br> 1.29.0/libbb/printable_string.c，找到函数 printable_string，缩减后的函数内容如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> FAST_FUNC <span class="token function">printable_string</span><span class="token punctuation">(</span><span class="token class-name">uni_stat_t</span> <span class="token operator">*</span>stats<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span>
<span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">char</span> <span class="token operator">*</span>dst<span class="token punctuation">;</span>
 <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>

 s <span class="token operator">=</span> str<span class="token punctuation">;</span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">unsigned</span> <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token char">' '</span><span class="token punctuation">)</span>
         <span class="token keyword">break</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&gt;=</span> <span class="token number">0x7f</span><span class="token punctuation">)</span>    <span class="token comment">//当字符大于 0X7F 以后就跳出去了。</span>
         <span class="token keyword">break</span><span class="token punctuation">;</span>
     s<span class="token operator">++</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">ENABLE_UNICODE_SUPPORT</span></span>
 dst <span class="token operator">=</span> <span class="token function">unicode_conv_to_printable</span><span class="token punctuation">(</span>stats<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
 <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">char</span> <span class="token operator">*</span>d <span class="token operator">=</span> dst <span class="token operator">=</span> <span class="token function">xstrdup</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">unsigned</span> <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token operator">*</span>d<span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
 <span class="token keyword">break</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token char">' '</span> <span class="token operator">||</span> c <span class="token operator">&gt;=</span> <span class="token number">0x7f</span><span class="token punctuation">)</span>    <span class="token comment">//如果支持 UNICODE 码的话，当字符大于 0X7F 就直接输出 ?</span>
     <span class="token operator">*</span>d <span class="token operator">=</span> <span class="token char">'?'</span><span class="token punctuation">;</span>
 d<span class="token operator">++</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
 <span class="token keyword">return</span> <span class="token function">auto_string</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注释部分修改为以下代码：</p> 
<pre><code class="prism language-c"><span class="token comment">/* if (c &gt;= 0x7f)
        break; */</span>
<span class="token comment">/* if (c &lt; ' ' || c &gt;= 0x7f) */</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span> c <span class="token operator">&lt;</span> <span class="token char">' '</span><span class="token punctuation">)</span>
</code></pre> 
<p>接着打开文件 busybox-1.29.0/libbb/unicode.c，找到如下内容：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">char</span><span class="token operator">*</span> FAST_FUNC <span class="token function">unicode_conv_to_printable2</span><span class="token punctuation">(</span><span class="token class-name">uni_stat_t</span> 
<span class="token operator">*</span>stats<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">char</span> <span class="token operator">*</span>dst<span class="token punctuation">;</span>
 <span class="token keyword">unsigned</span> dst_len<span class="token punctuation">;</span>
 <span class="token keyword">unsigned</span> uni_count<span class="token punctuation">;</span>
 <span class="token keyword">unsigned</span> uni_width<span class="token punctuation">;</span>

 <span class="token keyword">if</span> <span class="token punctuation">(</span>unicode_status <span class="token operator">!=</span> UNICODE_ON<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">char</span> <span class="token operator">*</span>d<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> UNI_FLAG_PAD<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         d <span class="token operator">=</span> dst <span class="token operator">=</span> <span class="token function">xmalloc</span><span class="token punctuation">(</span>width <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token operator">*</span>d<span class="token operator">++</span> <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">&gt;=</span> <span class="token char">' '</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token operator">?</span> c <span class="token operator">:</span> <span class="token char">'?'</span><span class="token punctuation">;</span>    <span class="token comment">//当字符大于 0X7F 以后，*d++就为 ?</span>
         src<span class="token operator">++</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token operator">*</span>d <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
     d <span class="token operator">=</span> dst <span class="token operator">=</span> <span class="token function">xstrndup</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> width<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>d<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         <span class="token keyword">unsigned</span> <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token operator">*</span>d<span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token char">' '</span> <span class="token operator">||</span> c <span class="token operator">&gt;=</span> <span class="token number">0x7f</span><span class="token punctuation">)</span>    <span class="token comment">//当字符大于 0X7F 以后，*d 也为 ?</span>
             <span class="token operator">*</span>d <span class="token operator">=</span> <span class="token char">'?'</span><span class="token punctuation">;</span>
         d<span class="token operator">++</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 <span class="token keyword">return</span> dst<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

 <span class="token keyword">return</span> dst<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注释部分修改为：</p> 
<pre><code class="prism language-c"><span class="token comment">/* *d++ = (c &gt;= ' ' &amp;&amp; c &lt; 0x7f) ? c : '?'; */</span>
 <span class="token operator">*</span>d<span class="token operator">++</span> <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">&gt;=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token operator">?</span> c <span class="token operator">:</span> <span class="token char">'?'</span><span class="token punctuation">;</span>
 
 <span class="token comment">/* if (c &lt; ' ' || c &gt;= 0x7f) */</span>
 <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token char">' '</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_busybox_340"></a>编译 busybox</h4> 
<p>配置好后，重新编译 buildroot 下的 busybox，进入到 buildroot 源码目录下，输入如<br> 下命令查看当前 buildroot 所有配置了的目标软件包，也就是 packages：</p> 
<pre><code class="prism language-powershell">sudo make <span class="token function">show-targets</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ee/1e/uVOPqUS2_o.png" alt="在这里插入图片描述"><br> 列出了当前 buildroot 中所有使能了的 packages 包，其中就包括 busybox，如<br> 果我们想单独编译并安装 busybox 的话执行下面命令即可：</p> 
<pre><code class="prism language-powershell">sudo make busybox
</code></pre> 
<p>上述命令就会重新编译 busybox。<br> 注意！！！编译完成后，要重新编译 buildroot，主要是对其进行打包，输入如下命令：sudo make</p> 
<h4><a id="_357"></a>遇到问题</h4> 
<p>但是挂载根文件系统之后发现了一个问题：进入某个目录后，并不会显示当前目录路径<br> <img src="https://images2.imgbox.com/2a/99/XiHgoUXj_o.png" alt="在这里插入图片描述"><br> 我们要先了解一下 “PS1” 这个环境变量，PS1 用于设置命令提示符格式，格式如下：</p> 
<pre><code class="prism language-powershell">PS1 = ‘命令列表’
</code></pre> 
<p>命令列表中可选的参数如下：</p> 
<pre><code class="prism language-powershell">\<span class="token operator">!</span>     显示该命令的历史记录编号。
 \<span class="token comment">#     显示当前命令的命令编号。</span>
 \$     显示$符作为提示符，如果用户是 root 的话，则显示<span class="token comment">#号。</span>
 \\     显示反斜杠。
 \d     显示当前日期。
 \h     显示主机名。
 \n     打印新行。
 \nnn   显示 nnn 的八进制值。
 \s     显示当前运行的 shell 的名字。
 \t     显示当前时间。
 \u     显示当前用户的用户名。
 \W     显示当前工作目录的名字。
 \w     显示当前工作目录的路径
</code></pre> 
<p>我们打开/etc/profile 文件，找到如下所示内容，然后将其屏蔽掉：</p> 
<pre><code class="prism language-powershell"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$PS1</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then
    <span class="token keyword">if</span> <span class="token punctuation">[</span> "`id <span class="token operator">-</span>u`" <span class="token operator">-eq</span> 0 <span class="token punctuation">]</span><span class="token punctuation">;</span> then 
        export PS1=<span class="token string">'# '</span>
    <span class="token keyword">else</span>
        export PS1=<span class="token string">'$ '</span>
    fi
fi
</code></pre> 
<p>上述代码就是原始的设置 PS1 环境变量的配置代码，就是它将命令提示符设置为了固定<br> 的“#”，我们将其屏蔽掉，然后输入如下所示内容：</p> 
<pre><code class="prism language-powershell">PS1=<span class="token string">'[\u@\h]:\w$:'</span>
export PS1
</code></pre> 
<p>第 2 行就是设置 PS1 环境变量，格式就是：</p> 
<pre><code class="prism language-powershell"><span class="token namespace">[user@hostname]</span>:currentpath$:
</code></pre> 
<p>设置好以后的/etc/profile 文件内容如图 A1.5.3 所示：<br> <img src="https://images2.imgbox.com/db/4f/GklhADSP_o.png" alt="在这里插入图片描述"><br> /etc/profile 文件修改完成以后重启开发板，这个时候我们就如到某个目录的时候命令行就<br> 会有提示，如图 A1.5.4 所示：<br> <img src="https://images2.imgbox.com/9f/95/AsMlRVfM_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Yocto_410"></a>二、Yocto</h2> 
<p>Yocto 简直就是我的噩梦！因为我的电脑配置中规中矩，跑个 Yocto 都要半天。而且 Yocto 提供的很多链接都是外网的，国内根本下载不了，除非可以翻墙，不然就需要我们自己一个一个去找源码包。</p> 
<p>以 NXP 为例，freescale 和 NXP 已经合并了。说 freescale 就是指 NXP。<br> <strong>注意事项：</strong></p> 
<ul><li>yocto 构建根文件系统需要预留足够的硬盘空间，I.MX yocto 手册上标明至少要留 120G 的空间。</li><li>yocto 构建根文件系统需要非常长的时间，不建议用低配置的电脑进行构建。否则可能需要一两天的构建时间。</li><li>yocto 构建的根文件系统包括了官方评估板所用的一切东西，文件系统十分巨大，需要读者自行裁剪。</li><li>建议分配虚拟机的内存越大越好！要想编译时间缩短，Ubuntu 分配的核心数要足够多才可以，可以在虚拟机》设置，将核心总数选择为16。分配多少个核心数就代表可以每次最多能跑多少个任务！低配置的电脑请根据个人电脑情况来分配核心数。</li></ul> 
<h3><a id="1_420"></a>1、在线构建根文件系统</h3> 
<h4><a id="git_422"></a>安装与配置git</h4> 
<p>（1）安装git<br> yocto 需要 git 来控制软件版本。</p> 
<pre><code class="prism language-powershell">sudo apt-get install git
</code></pre> 
<p>（2）配置 git 用户信息</p> 
<pre><code class="prism language-powershell">git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"Your Name"</span>
git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"Your Email"</span>
git config <span class="token operator">--</span>list
</code></pre> 
<p>参数解释：</p> 
<ul><li>–global user.name ：添加用户名</li><li>–global user.email ：添加用户的 email</li><li>–list ：查看列表信息</li></ul> 
<h4><a id="_yocto__439"></a>获取 yocto 项目</h4> 
<p>（1）下载 repo<br> repo 是一个构建在 Git 之上的工具，它可以更容易地管理包含多个存储库的项目，而这些存储库不需要位于同一台服务器上。repo 很好地补充了 yocto 项目的分层特性，使用户可以更容易地将自己的层添加到 BSP 中。<br> 简单来说，repo 用来管理多个 git 工程。<br> 首先立工程项目文件夹：</p> 
<pre><code class="prism language-powershell">mkdir fsl-release-bsp
cd fsl-release-bsp
</code></pre> 
<p>由于国内外网络环境的原因，官方手册里下载 repo 的链接需要翻墙。<br> 网上下载的 repo<br> 有很多种，经过作者实验网上有很多 repo 在 init 时会出错，需要修改 repo 里面的 REPO_URL<br> 地址才能用！<br> 方法一，官方提供的下载地址，需要翻墙<br> http://commondatastorage.googleapis.com/git-repo-downloads/repo<br> 方法二，下载国内修改好的工具，例如：正点原子<br> https://raw.githubusercontent.com/dzm2018/alientek-git-repo-downloads/master/repo<br> 那么开始下载：</p> 
<pre><code class="prism language-powershell">curl https:<span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com/dzm2018/alientek-git-repo-downloads/master/repo &gt; <span class="token punctuation">.</span><span class="token operator">/</span>repo
</code></pre> 
<p>若上面网址失效，我们直接在 Ubuntu 下使用 git clone 指令从 github 上把 repo 下载下来。<br> 下载完成，repo 就在 alientek-git-repo-downloads 这个文件夹里。</p> 
<pre><code class="prism language-powershell">git clone https:<span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com/dzm2018/alientek-git-repo-downloads<span class="token punctuation">.</span>git （备用链接）
</code></pre> 
<p><img src="https://images2.imgbox.com/a3/17/hmwpUhZu_o.png" alt="在这里插入图片描述"><br> 修改 repo 文件的权限，注意不要使用 root 用户！（注：官方文档这里将 repo 导出环境变量里，这里并不这样做。）</p> 
<pre><code class="prism language-powershell">hmod u+x repo
</code></pre> 
<p>（2）获取yocto项目<br> 这里教大家选择 yocto 的分支，可以用浏览器打开网址（网址有可能失效）<br> http://git.freesc<br> ale.com/git/cgit.cgi/imx/fsl-arm-yocto-bsp.git/<br> 查看 freescale 的 yocto 项目的分支。根据我们源码内<br> 核发布的版本号是 4.1.15-2.10，可以从下图看出 imx-4.1-krogoth 分支就是对应内核 4.1.15-2.1.<br> 0 的版本，所以我们选择 imx-4.1-krogoth 分支。<br> <img src="https://images2.imgbox.com/f8/ed/OQI1wNPp_o.png" alt="在这里插入图片描述"><br> 获取 freescale yocto 项目的 imx-4.1-krogoth 分支，在当前目录下执行下面的指令，执行过<br> 程如下。过程中还会确认您的 git 用户信息是否是您在 1.1 节中配置的信息。</p> 
<pre><code class="prism language-powershell"><span class="token punctuation">.</span><span class="token operator">/</span>repo init <span class="token operator">-</span>u git:<span class="token operator">/</span><span class="token operator">/</span>git<span class="token punctuation">.</span>freescale<span class="token punctuation">.</span>com/imx/fsl-arm-yocto-bsp<span class="token punctuation">.</span>git <span class="token operator">-</span>b imx-4<span class="token punctuation">.</span>1-krogoth
</code></pre> 
<p>上面 freescale 仓库可能会失效。备用下面的链接，从别外一个地方下载。（备用链接）</p> 
<pre><code class="prism language-powershell"><span class="token punctuation">.</span><span class="token operator">/</span>repo init <span class="token operator">-</span>u https:<span class="token operator">/</span><span class="token operator">/</span>source<span class="token punctuation">.</span>codeaurora<span class="token punctuation">.</span>org/external/imx/fsl-arm-yocto-bsp <span class="token operator">-</span>b imx-4<span class="token punctuation">.</span>1-krogoth
</code></pre> 
<p><img src="https://images2.imgbox.com/05/26/gAdxrvDc_o.png" alt="在这里插入图片描述"><br> 连续输入三次 y，完成后可以看到 repo 初始化在当前目录下，使用 ls 指令可以查看隐藏文件夹.repo。<br> <img src="https://images2.imgbox.com/9e/8c/d3LmQO46_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-powershell"><span class="token function">ls</span> <span class="token operator">-</span>a
</code></pre> 
<p><img src="https://images2.imgbox.com/54/a6/uKbSvrSw_o.png" alt="在这里插入图片描述"><br> 下载过瑞芯微的SDK的同学肯定有种似曾相识的感觉了。<br> 使用 repo sync 指令同步数据，同步的过程中会克隆 NXP 官方 fsl-arm-yocto-bsp.git 项目的 imx-4.1-krogoth 分支。</p> 
<pre><code class="prism language-powershell">repo sync
</code></pre> 
<p><img src="https://images2.imgbox.com/6f/e2/IDlS2lCi_o.png" alt="在这里插入图片描述"><br> 同步完成如下图，可以看到目录下多了几个文件，其中 sources 文件夹是项目源文件。<br> <img src="https://images2.imgbox.com/f9/32/k4HziurI_o.png" alt="在这里插入图片描述"><br> （3）构建根文件系统<br> 下面是发行版（DISTRO）的四种配置：<br> fsl-imx-x11 -只有 X11 图形<br> fsl-imx-wayland - Wayland weston graphics<br> fsl-imx-xwayland - Wayland graphics and X11。不支持使用 EGL 的 X11 应用程序<br> fsl-imx-fb -帧缓冲图形-没有 X11 或 Wayland<br> 支持的 machine 有很多种，以下是按官方文档列出的几种。<br> imx6qpsabreauto<br> imx6qpsabresd<br> imx6ulevk<br> imx6ull14x14evk<br> imx6ull9x9evk<br> imx6dlsabreauto<br> imx6dlsabresd<br> imx6qsabreauto<br> imx6qsabresd<br> imx6slevk<br> imx6solosabreauto<br> imx6solosabresd<br> imx6sxsabresd<br> imx6sxsabreauto<br> imx7dsabresd<br> 更多 machine 支持，可以进入 sources/meta-fsl-bsp-release/imx/meta-bsp/conf/machine 查看，<br> 或者直接用 ls 指令查看</p> 
<pre><code class="prism language-powershell"><span class="token function">ls</span> sources/meta-fsl-bsp-release/imx/meta-bsp/conf/machine
</code></pre> 
<p>构建 yocto 的文件系统镜像，freescale（NXP）提供了几种镜像供读者构建，文件系统镜像<br> 支持的功能越多，文件系统就越大，读者可自行选择一个来构建。<br> 如下表格简单介绍了几种镜像：</p> 
<table><thead><tr><th>镜像</th><th>功能</th></tr></thead><tbody><tr><td>core-image-minimal</td><td>仅支持设备启动的小镜像</td></tr><tr><td>core-image-base</td><td>目标设备硬件的只支持控制台的镜像</td></tr><tr><td>core-image-sato</td><td>镜像支持 X11 与 Sato 主题和使用 Pimlico 应用程序。它包含一个终端、一个编辑器和一个文件管理器</td></tr><tr><td>fsl-image-machine-test FSL</td><td>社区的核心镜像，支持控制台环境，没有</td></tr><tr><td>GUI 界面</td><td></td></tr><tr><td>fsl-image-gui</td><td>一个支持 GUI 但没有 Qt5 的镜像</td></tr><tr><td>fsl-image-qt5</td><td>一个开源 Qt 5 的镜像</td></tr></tbody></table> 
<p>官方提供了 fsl-setup-release.sh 脚本来构建项目，脚本语法如下：</p> 
<pre><code class="prism language-powershell">DISTRO=&lt;distro name&gt; MACHINE=&lt;machine name&gt; source fsl-setup-release<span class="token punctuation">.</span>sh <span class="token operator">-</span>b &lt;build <span class="token function">dir</span>&gt;
</code></pre> 
<p>参数解释：</p> 
<ul><li>DISTRO：发行版类型</li><li>MACHINE：机器类型</li><li>-b:指定工程构建输出的目录</li></ul> 
<p>发行版我们选择 fsl-imx-x11，正点原子的发布的系统需要运行 Qt5 程序，所以选择 fsl-image-qt5 这个文件系统镜像来构建。我们开发板是 IMX6ULL 芯片，所以 MACHINE 选择是 imx6ull14x14evk。<br> fsl-setup-release.sh 这个脚本会解释用户配置的参数。<br> 所以我们最终的指令是：</p> 
<pre><code class="prism language-powershell">DISTRO=fsl-imx-x11 MACHINE=imx6ull14x14evk source fsl-setup-release<span class="token punctuation">.</span>sh <span class="token operator">-</span>b build
</code></pre> 
<p><img src="https://images2.imgbox.com/11/de/8tvn0lCx_o.png" alt="在这里插入图片描述"><br> **特别注意：**构建 yocto 时不要加载任何工具链的环境变量，因为构建时会使用 yocto 项目的编译器进行编译。<br> 如果您在/etc/profile 下导出了与 gcc 相关的环境变量，请把它注释掉后重启或者注销 Ubuntu 再执行上面的指令，因为/etc/profile 下的环境变量会开机就加载，并且在新的 shell 或者终端里始终生效！<br> 配置过程中请你阅读 EULA 内容，输入 q 退出阅读内容后再按 y 确认已经阅读，再继续下一步。<br> <img src="https://images2.imgbox.com/7a/9a/IdTscj1M_o.png" alt="在这里插入图片描述"><br> 配置完成后会直接进入 build 目录<br> <img src="https://images2.imgbox.com/a5/28/OLUibDJi_o.png" alt="在这里插入图片描述"><br> 输入 bitbake fsl-image-qt5 开始构建根文件系统，看到下面报错的内容，这是因为构建 yocto 项目时需要安装一些软件。</p> 
<pre><code class="prism language-powershell">bitbake fsl-image-qt5
</code></pre> 
<p><img src="https://images2.imgbox.com/27/40/ARjC1Grb_o.png" alt="在这里插入图片描述"><br> 执行下面的指令安装构建项目所需要的软件（这里与官方的构建 yocto 项目的顺序不一样，官方的是先安装软件包，作者的是遇到需要安装软件包时再去安装这些软件包）</p> 
<pre><code class="prism language-powershell">sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat libsdl1<span class="token punctuation">.</span>2-dev curl
</code></pre> 
<p><img src="https://images2.imgbox.com/92/8a/OA2I8WRW_o.png" alt="在这里插入图片描述"><br> 安装完成以上的软件后，再执行一次 bitbake fsl-image-qt5 指令重新构建。如下图：</p> 
<pre><code class="prism language-powershell">bitbake fsl-image-qt5
</code></pre> 
<p><img src="https://images2.imgbox.com/2f/21/J0oKmytc_o.png" alt="在这里插入图片描述"><br> 构建的时长的因素与以下几点有关：计算机的性能（硬盘写入速度，CPU 的核心数），网络下载速度，还与您的 Ubuntu 虚拟机在安装时分配的核心数与分配的内存有关！构建过程中可能会出错，可按 Ctrl +c 终止，再次输入 bitbake fsl-image-qt5 构建。yocto 支持从断点处重新构建。因为构建过程中已经生成缓存文件，重复构建时会跳过已经构建过的任务。<br> 可以看我们配置的信息如下图<br> <img src="https://images2.imgbox.com/3e/4b/1tulPc3B_o.png" alt="在这里插入图片描述"><br> 构建过程中会下载很多软件包，下载目录为…/downloads。也就是 build 目录的前一级目录下。第一次构建时需要下载这些软件包，所以耗时很长。如果再次构建，那么无需重复下载，所以再次构建项目时速度会快很多。下图黄色的警告是构建任务中下载软件包失败时所提示的，并不会影响构建过程。<br> 请读者耐心等待文件系统的构建完成，下图的任务总数为 7756 个，不同的构建内容，任务总数可能是不相同的。<br> <img src="https://images2.imgbox.com/c3/ad/rgd5PtJ1_o.png" alt="在这里插入图片描述"><br> 构建成功如下图，没有打印错误信息。<br> 备注：作者 Ubuntu 分配 16GB 内存（用户虚拟机能尽量分大内存就分大内存，否则可能出现编译不通过的情况），16 个核心数，网速为 100M，大约构建了 9 个小时！<br> <img src="https://images2.imgbox.com/cc/37/U5Lebo3D_o.png" alt="在这里插入图片描述"><br> 构建完成后进入…/build/tmp/deploy/images/imx6ull14x14evk 目录下用 ls 指令查看生成的文件。<br> <img src="https://images2.imgbox.com/39/e8/6wcGlfKp_o.png" alt="在这里插入图片描述"><br> 生成的文件解释：<br> 生成的文件中，其中蓝色文字内容的是链接文件，这里就不列出了。</p> 
<table><thead><tr><th>文件名</th><th>用途</th></tr></thead><tbody><tr><td>*.rootfs.manifest</td><td>文件系统内的软件列表</td></tr><tr><td>*.rootfs.ext4 ext4</td><td>格式的文件系统压缩包</td></tr><tr><td>*.rootfs.sdcard</td><td>可直接写入 SD 卡，从 SD 卡启动的镜像</td></tr><tr><td>*.rootfs.tar.bz2 tar.bz2</td><td>格式的文件系统压缩包</td></tr><tr><td>modules*.tgz ttgz</td><td>格式的内核模块压缩包</td></tr><tr><td>u-boot*.imx</td><td>官方多版本类型 u-boot 镜像</td></tr><tr><td>zImgae*/zImage*.bin</td><td>内核设备树与 bin 文件</td></tr></tbody></table> 
<p>我们需要的文件系统镜像压缩包是 fsl-image-qt5-imx6ull14x14evk-20190904030729.rootfs.tar.bz2，文件系统比较大，读者按需裁剪，或者按需修改 yocto 项目源文件再构建。<br> 备注：因存储设备的大小限制，正点原子还构建了 fsl-image-gui 这个不含 Qt5 但含 GUI 的镜像。<br> （4）构建 SDK 工具<br> 构建完成我们含 Qt5 的文件系统后，还需要构建 SDK 工具。SDK 工具里面含交叉编译工具链，我们需要含 Qt5 的交叉编译工具链。<br> 在 build 目录下执行下面的指令（注：请在构建根文件系统后不要退出当前终端，否则还需要重新输入 DISTRO=fsl-imx-x11 MACHINE=imx6ull14x14evk source fsl-setup-release.sh -b<br> build 来使用环境变量才能使用 bitbake 指令）</p> 
<pre><code class="prism language-powershell">bitbake meta-toolchain-qt5
</code></pre> 
<p><img src="https://images2.imgbox.com/68/f2/HUUy61fi_o.png" alt="在这里插入图片描述"><br> 下图为构建过程截图，可以看到构建的速度快了很多，因为我们已经构建过文件系统，已经下载过软件包，同时在构建时生成了缓存文件。<br> <img src="https://images2.imgbox.com/6e/84/io7pyPU1_o.png" alt="在这里插入图片描述"><br> 构建成功如下图<br> <img src="https://images2.imgbox.com/31/6a/XbWp11iS_o.png" alt="在这里插入图片描述"><br> 构建成功后，进入…/build/tmp/deploy/sdk 目录，查看生成的文件。<br> 其中 fsl-imx-x11-glibc-x8<br> 6_64-meta-toolchain-qt5-cortexa7hf-neon-toolchain-4.1.15-2.1.0.sh 是我们需要的文件，如下图<br> <img src="https://images2.imgbox.com/88/0f/RmDaNE1K_o.png" alt="在这里插入图片描述"><br> 编译出来的 fsl-imx-x11-glibc-x86_64-meta-toolchain-qt5-cortexa7hf-neon-toolchain-4.1.15-2.1.0.sh 的文件可直接执行安装，默认安装在/opt 目录下。使能工具链后可用于编译内核、uboot、c文件与 Qt 应用程序。<br> 使用方法请参考《【正点原子】I.MX6U 用户快速体验》第四章节来搭建交叉编译环境。</p> 
<h3><a id="2_632"></a>2、离线构建根文件系统</h3> 
<h4><a id="_634"></a>构建根文件系统</h4> 
<p>正点原子提供了下载的软件包，百度云的下载链接地址<br> https://pan.baidu.com/s/1vRrFTPRlpxhw56F02purNQ。下载后，直接解压使用。<br> 构建前准备，请 fsl-release-bsp.tar.xz 拷贝到 ubuntu 虚拟机，本文拷贝到~（家目录）。如下图：<br> <img src="https://images2.imgbox.com/de/89/SwAH7BxF_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-powershell">tar <span class="token operator">-</span>Jvxf fsl-release-bsp<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>xz
</code></pre> 
<p>使用 cd 指令进入 fsl-release-bsp 文件夹用 ls 查看有如下文件<br> <img src="https://images2.imgbox.com/df/66/poBhmV2a_o.png" alt="在这里插入图片描述"><br> 方法与在线构建根文件系统的方法一样。<br> 有些用户直接用离线包就可以编译通过，有些用户离线包编译有出现如下错<br> 误且错误都是报 tslib.h 没有找到。<br> 在下载的 source 文件夹里用 vi 指令打开这个文件把 tslib 不编译就可以解决这个错误，编<br> 译完成后可自己移植 tslib，正点原子驱动教程文档里有写怎么移植，或者正点原子 Qt 移植文档<br> 里有写怎么移植。把 201 这一行整行删除，注意是整一行，不要留下空格或者空行！</p> 
<pre><code class="prism language-powershell">vi sources/meta-qt5/recipes-qt/qt5/qtbase_git<span class="token punctuation">.</span>bb
</code></pre> 
<p><img src="https://images2.imgbox.com/35/84/PtzPqW3x_o.png" alt="在这里插入图片描述"><br> 修改后，再一次执行 bitbake 指令重新构建即可。</p> 
<h4><a id="_SDK__657"></a>构建 SDK 工具</h4> 
<p>方法与在线构建 SDK 工具的方法一样。</p> 
<h2><a id="Ubuntubase_661"></a>三、Ubuntu-base</h2> 
<p>首先 Ubuntu 也是一个根文件系统。但是整个 ubuntu 对于处理器的要求就很高了。</p> 
<h3><a id="1ubuntubase__663"></a>1、ubuntu-base 获取</h3> 
<p>Ubuntu 的移植不需要我们编译任何东西，因为 Ubuntu 官方已经将根文件系统制作好了，我们只需要配置 Ubuntu 官方提供的 base 根文件系统。<br> 根文件系统下载地址为 http://cdimage.ubuntu.com/，下载界面如图所示：<br> <img src="https://images2.imgbox.com/24/d1/jOwTuLlb_o.png" alt="在这里插入图片描述"><br> 点击 ubuntu-base，进入到 ubuntu-base 下载界面，如图所示：<br> <img src="https://images2.imgbox.com/59/69/RAxDZuc0_o.png" alt="在这里插入图片描述"><br> 点击 releases，下载 releases 版本的根文件系统，进去以后如图所示：<br> <img src="https://images2.imgbox.com/86/48/2j60BrfB_o.png" alt="在这里插入图片描述"><br> 从图可以看出，Ubuntu 提供了从 12.04 开始，一直到最新的 19.10 版本的 ubuntu base 供大家下载。<br> 我们选择 16.04.5，点击以后进入如图所示界面：<br> <img src="https://images2.imgbox.com/52/2a/EwJ11Vuk_o.png" alt="在这里插入图片描述"><br> 点击图release，进入 16.04.5 的下载界面，如图所示：<br> <img src="https://images2.imgbox.com/e0/96/lnYLdRu6_o.png" alt="在这里插入图片描述"><br> I.MX6ULL 是 Cortex-A 内核的 CPU，并且有硬件浮点运算单元，因此选择 armhf 版本。</p> 
<h3><a id="2ubuntu__678"></a>2、ubuntu 根文件系统构建</h3> 
<h4><a id="_ubuntu_base__679"></a>解压缩 ubuntu base 根文件系统</h4> 
<p>在 Ubuntu 虚拟机中的 nfs 目录下创建一个名为<br> ubuntu_rootfs 的目录，命令如下：</p> 
<pre><code class="prism language-powershell">cd <span class="token operator">/</span>home/nfs                       <span class="token operator">/</span><span class="token operator">/</span>进入到 nfs 目录下
mkdir ubuntu_rootfs                <span class="token operator">/</span><span class="token operator">/</span>创建ubuntu_rootfs目录
</code></pre> 
<p>将上一小节下载得到的“ ubuntu-base-16.04.5-base-armhf.tar.gz ”拷贝到 ubuntu_rootfs 目录，然后解压：</p> 
<pre><code class="prism language-powershell">sudo tar <span class="token operator">-</span>vzxf ubuntu-base-16<span class="token punctuation">.</span>04<span class="token punctuation">.</span>5-base-armhf<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
</code></pre> 
<p>解压完成以后如图所示：<br> <img src="https://images2.imgbox.com/5a/01/idJGOSKy_o.png" alt="在这里插入图片描述"><br> 可以看出，ubuntu base 解压以后就是大家最常见的 linux 根文件系统，但是目前还不能直接使用，还需要对其做一些其他的配置。</p> 
<h4><a id="_qemu_695"></a>安装 qemu</h4> 
<p>需要在 Ubuntu 虚拟机安装 qemu 工具，命令如下：</p> 
<pre><code class="prism language-powershell">sudo apt-get install qemu-user-static
</code></pre> 
<p>将刚刚安装的 qemu-user-static 拷贝到 ubuntu_rootfs/usr/bin 目录下</p> 
<pre><code class="prism language-powershell">sudo <span class="token function">cp</span> <span class="token operator">/</span>usr/bin/qemu-arm-static <span class="token operator">/</span>home/ubuntu_rootfs/usr/bin/
</code></pre> 
<h4><a id="_706"></a>设置软件源</h4> 
<p>apt-get 安装的软件，都是从网上下载软件并安装的，因此需要指定软件源。<br> 在设置软件源之前，先进入到 ubuntu_rootfs/ 目录，将 Ubuntu 主机下的 DNS 配置文件 /etc/resolv.conf 拷贝到根文件系统中，命令如下：</p> 
<pre><code class="prism language-powershell">sudo <span class="token function">cp</span> <span class="token operator">/</span>etc/resolv<span class="token punctuation">.</span>conf <span class="token punctuation">.</span><span class="token operator">/</span>etc/resolv<span class="token punctuation">.</span>conf
</code></pre> 
<p>设置软件源，打开根文件系统中的 ubuntu_rootfs/etc/apt/sources.list 文件，在此文件最后面<br> 添加软件源，比如国内常用的清华源、中科大源等等。<br> 注意：要用 ubuntu16.04 的 ARM 源，不能找成了 X86 的源。</p> 
<pre><code class="prism language-powershell"><span class="token comment">#中科大源</span>
deb http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>ustc<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn/ubuntu-ports/ xenial main multiverse restricted universe
deb http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>ustc<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn/ubuntu-ports/ xenial-backports main multiverse restricted universe
deb http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>ustc<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn/ubuntu-ports/ xenial-proposed main multiverse restricted universe
deb http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>ustc<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn/ubuntu-ports/ xenial-security main multiverse restricted universe
deb http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>ustc<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn/ubuntu-ports/ xenial-updates main multiverse restricted universe
deb-src http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>ustc<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn/ubuntu-ports/ xenial main multiverse restricted universe
deb-src http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>ustc<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn/ubuntu-ports/ xenial-backports main multiverse restricted universe
deb-src http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>ustc<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn/ubuntu-ports/ xenial-proposed main multiverse restricted universe
deb-src http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>ustc<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn/ubuntu-ports/ xenial-security main multiverse restricted universe
deb-src http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>ustc<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn/ubuntu-ports/ xenial-updates main multiverse restricted universe
</code></pre> 
<p>将示例代码添加到 sources.list 文件中即可。</p> 
<h4><a id="_732"></a>在主机挂载并配置根文件系统</h4> 
<p>（1）在主机挂载根文件系统<br> 接下来将上面制作的根文件系统挂载到主机上，需要挂载 proc、sys、dev、dev/pts 等文件系统，最后使用 chroot 将主机的根文件系统切换到我们前面制作的根文件系统中。这里我们通过两个脚本文件来完成挂载和卸载操作，首先是挂载脚本 mount.sh，在 ubuntu_rootfs 目录下创建一个名为 mount.sh 的 shell 脚本，然后在里面输入如下所示内容：</p> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>
<span class="token function">echo</span> <span class="token string">"MOUNTING"</span>
sudo <span class="token function">mount</span> <span class="token operator">-</span>t proc <span class="token operator">/</span>proc <span class="token operator">/</span>home/nfs/ubuntu_rootfs/proc
sudo <span class="token function">mount</span> <span class="token operator">-</span>t sysfs <span class="token operator">/</span>sys <span class="token operator">/</span>home/zuozhongkai/linux/nfs/ubuntu_rootfs/sys
sudo <span class="token function">mount</span> <span class="token operator">-</span>o bind <span class="token operator">/</span>dev <span class="token operator">/</span>home/zuozhongkai/linux/nfs/ubuntu_rootfs/dev 
sudo <span class="token function">mount</span> <span class="token operator">-</span>o bind <span class="token operator">/</span>dev/pts <span class="token operator">/</span>home/zuozhongkai/linux/nfs/ubuntu_rootfs/dev/pts
sudo chroot <span class="token operator">/</span>home/zuozhongkai/linux/nfs/ubuntu_rootfs
</code></pre> 
<p>再编写一个卸载的脚本文件，新建名为 unmount.sh 的 shell 脚本，在里面输入如下所示内容：</p> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>
<span class="token function">echo</span> <span class="token string">"UNMOUNTING"</span>
sudo umount <span class="token operator">/</span>home/zuozhongkai/linux/nfs/ubuntu_rootfs/proc
sudo umount <span class="token operator">/</span>home/zuozhongkai/linux/nfs/ubuntu_rootfs/sys
sudo umount <span class="token operator">/</span>home/zuozhongkai/linux/nfs/ubuntu_rootfs/dev/pts
sudo umount <span class="token operator">/</span>home/zuozhongkai/linux/nfs/ubuntu_rootfs/dev
</code></pre> 
<p>最后给予 mount.sh 和 unmount.sh 这两个 shell 脚本可执行权限，命令如下：</p> 
<pre><code class="prism language-powershell">sudo chmod 777 <span class="token function">mount</span><span class="token punctuation">.</span>sh unmount<span class="token punctuation">.</span>sh
</code></pre> 
<p>执行 mount.sh 脚本，将制作的根文件系统挂载到主机，挂载成功以后如图所示：<br> <img src="https://images2.imgbox.com/19/c2/4WXHxDWM_o.png" alt="在这里插入图片描述"><br> 挂载之后，当前终端已经将根文件系统切换到了 ubuntu_rootfs 根文件系统中了。<br> （2）安装常用的命令和软件<br> ubuntu base 是一个最小根文件系统，很多命令和软件都没有，因此我们需要先安装一下常用的命令和软件。<br> <strong>注意：是在电脑的 Ubuntu 下输入这些命令，因为现在电脑的 Ubuntu 正挂载着我们移植的 Ubuntu-base 根文件系统。</strong></p> 
<pre><code class="prism language-powershell">apt update
apt install sudo
apt install vim
apt install kmod
apt install net-tools
apt install ethtool
apt install ifupdown
apt install language-pack-en-base
apt install rsyslog
apt install htop
apt install iputils-ping
</code></pre> 
<p>保证 ubuntu base 根文件系统能够在开发板上正常启动即可，启动后再根据需要继续安装其他的命令和软件。<br> （3）设置 root 用户密码</p> 
<pre><code class="prism language-powershell">passwd root     <span class="token operator">/</span><span class="token operator">/</span>设置 root 用户密码
</code></pre> 
<p>输入“passwd root”以后会让你输入 root 用户密码，输入两次。<br> <img src="https://images2.imgbox.com/73/2a/rXfxN9EF_o.png" alt="在这里插入图片描述"><br> （4）设置本机名称和 IP 地址</p> 
<pre><code class="prism language-powershell"><span class="token function">echo</span> <span class="token string">"alientek_imx6ul"</span> &gt; <span class="token operator">/</span>etc/hostname
<span class="token function">echo</span> <span class="token string">"127.0.0.1 localhost"</span> &gt;&gt; <span class="token operator">/</span>etc/hosts
<span class="token function">echo</span> <span class="token string">"127.0.0.1 alientek_imx6ul"</span> &gt;&gt; <span class="token operator">/</span>etc/hosts
</code></pre> 
<p>（5）设置串口终端<br> 首先确定自己所使用的串口设备文件，比如正点原子的 ALPHA 开发 板 使 用 的 UART1 对 应 的 串 口 设 备 文 件 为 ttymxc0 ， 我 们 需 要 添 加 一 个 名 为 getty@ttymxc0.service 的链接，链接到 getty@.service 服务上，输入如下命令：</p> 
<pre><code class="prism language-powershell">ln <span class="token operator">-</span>s <span class="token operator">/</span>lib/systemd/system/getty@<span class="token punctuation">.</span>service/etc/systemd/system/getty<span class="token punctuation">.</span>target<span class="token punctuation">.</span>wants/getty@ttymxc0<span class="token punctuation">.</span>service
</code></pre> 
<p>设置好以后就可以退出根文件系统了，输入 exit 退出。<br> 退出以后再执行一下 unmount.sh 脚本取消挂载。</p> 
<p>至此，ubuntu base 根文件系统就已经制作好了。</p> 
<h3><a id="3ubuntu__806"></a>3、ubuntu 根文件系统测试</h3> 
<h4><a id="nfs__807"></a>nfs 挂载测试</h4> 
<p>先用 nfs 挂载根文件系统，在 uboot 里面设置 bootargs 环境变量的值如下：</p> 
<pre><code class="prism language-powershell"><span class="token operator">/</span><span class="token operator">/</span> 根据自己的目录和开发板确定要修改的参数
setenv bootargs <span class="token string">'console=tty1 console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.253:/home/nfs/ubuntu_rootfs rw ip=192.168.1.251:192.168.1.253:192.168.1.1:255.255.255.0::eth0:off'</span>
saveenv     <span class="token operator">/</span><span class="token operator">/</span>保存环境变量
</code></pre> 
<p>设置完成以后重启开发板，这个时候就会进入到 ubuntu 根文件系统中，如图所示：<br> <img src="https://images2.imgbox.com/6b/a5/RIiJmmfg_o.png" alt="在这里插入图片描述"><br> 可以看出，16.04.5 版本的 ubuntu 根文件系统启动成功，并且要求我们输入用户名和密码。<br> 进入根文件系统后：<br> <img src="https://images2.imgbox.com/e3/b3/M0nv1cKg_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="buntu__820"></a>buntu 根文件系统烧写</h4> 
<p>通过 nfs 挂载根文件系统测试成功，接下来就可以将 ubuntu 根文件系统烧写<br> 到开发板上的 EMMC 或者 NAND 中，不同的处理器烧写方法不一样，不同的厂家都有各自的烧写工具，这里借鉴就可以了。<br> （1）打包 ubuntu 根文件系统</p> 
<pre><code class="prism language-powershell">tar <span class="token operator">-</span>vcjf ubuntu_rootfs<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>bz2 <span class="token operator">*</span> 
</code></pre> 
<p>（2）烧写 ubuntu 根文件系统<br> NXP的处理器厂家提供了 MfgTool 工具将 ubuntu 根文件系统烧写到开发板的 EMMC 或 NAND 中。</p> 
<h3><a id="4ubuntu__831"></a>4、ubuntu 根文件系统继续添加部分</h3> 
<h4><a id="_832"></a>添加新用户</h4> 
<p>（1）添加新用户<br> 制作的 ubuntu 根文件系统默认只有一个 root 用户，默认都是用 root 用户登录的，和我们在 PC 上使用 Ubuntu 系统一样，默认使用 root 用户的话可能会因为操作失误导致系统被破坏。因此最好创建一个普通用户，默认使用普通用户，当需要 root 权限的时候就使用 sudo 命令即可。<br> 使用 adduser 命令添加普通用户：</p> 
<pre><code class="prism language-powershell">adduser username     <span class="token operator">/</span><span class="token operator">/</span>添加普通用户
</code></pre> 
<p>添加新用户的时候需要设置新用户密码，根据自己的实际情况设置即可，用户添加过程如图所示：<br> <img src="https://images2.imgbox.com/32/48/ksyJdwFt_o.png" alt="在这里插入图片描述"><br> 新用户添加完成以后就可以重启开发板，然后使用新用户登录。<br> （2）设置新用户可以使用 sudo 命令<br> 默认情况下新用户是不能使用 sudo 命令的，即使你输入了密码也不能使用 sudo，会提示 “xxx is not in the sudoers file. This incident will be reported.”错误。<br> 我们需要修改/etc/sudoers 文件，首先使用如下命令切换回 root 用户：</p> 
<pre><code class="prism language-powershell">su         <span class="token operator">/</span><span class="token operator">/</span>切换回 root 用户
</code></pre> 
<p>/etc/sudoers 文件默认是只读的，因此需要先修改此文件的写权限，使用如下命令：</p> 
<pre><code class="prism language-powershell">chmod u+w <span class="token operator">/</span>etc/sudoers
</code></pre> 
<p>然后使用 vi 打开/etc/sudoers，找到“root ALL=(ALL:ALL) ALL”这一行，在这一行下面添加：</p> 
<pre><code class="prism language-powershell">xxx ALL=<span class="token punctuation">(</span>ALL:ALL<span class="token punctuation">)</span> ALL
</code></pre> 
<p>表示 xxx 这个用户可以执行 sudo 命令，但是要输入密码。<br> 修改完成以后保存退出，重新恢复/etc/sudoers 的只读属性，使用如下命令：</p> 
<pre><code class="prism language-powershell">chmod u-w <span class="token operator">/</span>etc/sudoers
</code></pre> 
<p>设置完成以后重启切换到 xxx 用户，这个时候 sudo 命令就运行正常了，可以使用 fdsik 命令测试一下，fdisk 需要 root 权限：</p> 
<pre><code class="prism language-powershell">sudo fdisk <span class="token operator">-</span>l
</code></pre> 
<p>如果 sudo 运行正常的话就会打印出当前开发板的所有存储信息。</p> 
<h4><a id="_DHCP__872"></a>网络 DHCP 配置</h4> 
<p>我们默认没有配置 DHCP，因为 ubuntu 启动以后不能直接联网，需要手动启动网卡并设置 IP 地址。<br> 这里我们配置一下网络 DHCP，这样系统启动以后就会自动设置好网络。<br> 正点原子的 ALPHA 开发板有两个网卡，在 linux 系统下的网卡名字为 eth0 和 eth1，以 eth0 为例，讲如何配置其 DHCP，输入如下命令：</p> 
<pre><code class="prism language-powershell">su <span class="token operator">/</span><span class="token operator">/</span>切换到 root 用户
<span class="token function">echo</span> auto eth0 &gt; <span class="token operator">/</span>etc/network/interfaces<span class="token punctuation">.</span>d/eth0
<span class="token function">echo</span> iface eth0 inet dhcp &gt;&gt; <span class="token operator">/</span>etc/network/interfaces<span class="token punctuation">.</span>d/eth0
<span class="token operator">/</span>etc/init<span class="token punctuation">.</span>d/networking restart
</code></pre> 
<p>设置好以后重启开发板，eth0 网卡就会默认打开，可以直接上网。eth1 网卡同理，支持将上述命令中的 eth0 换为 eth1 即可。</p> 
<h4><a id="_884"></a>安装软件</h4> 
<p>至此，ubuntu 根文件系统已经完全在开发板上运行起来了，如果要安装什么软件的话直接使用 apt 工具即可，和我们在 PC 下使用 ubuntu 一样。比如我们安装 mplayer，那么就可以直接输入：</p> 
<pre><code class="prism language-powershell">sudo apt-get install mplayer <span class="token operator">/</span><span class="token operator">/</span>安装 mplayer
</code></pre> 
<p>等待安装完成，完成以后就可以使用 mplayer 了，非常的方便。</p> 
<h4><a id="FTP__892"></a>FTP 服务器搭建</h4> 
<p>主要是在开发板上安装 vsftpd，vsftpd 可以在编译根文件系统的时候就移植。<br> 开发板上的 vsftpd 部署好以后就可以使用 FileZilla 来访问了，站点设置如图所示：<br> <img src="https://images2.imgbox.com/df/e4/k94npqSb_o.png" alt="在这里插入图片描述"><br> 站点设置好以后就可以进行连接了，默认进入到 zuozhongkai 用户目录下，如图所示：<br> <img src="https://images2.imgbox.com/a4/fa/FjoMEKZS_o.png" alt="在这里插入图片描述"><br> 向开发板里面上传一个文件：<br> <img src="https://images2.imgbox.com/8a/96/O8MDMllN_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_900"></a>总结</h2> 
<p>这些方法只是在没有官方提供 SDK 包的情况下使用，有官方 SDK 包肯定是直接用的啊，例如：瑞芯微、高通、MTK、TI……都有 SDK 包可以直接生成完整的系统镜像。这种时候，熟悉公司所使用的 SDK 包就更加重要。</p> 
<p>文章篇幅有点长了，下一期是根文件系统的构建后期的移植库和软件的过程。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/61fed2f6e7b1caae6bf8a46bf4807845/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用免费WAF雷池社区版解决「爬虫占用网络带宽问题」</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1956691d41b8c9358a8d2f63a411607/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java如何操作Excel并保存于原文档</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>