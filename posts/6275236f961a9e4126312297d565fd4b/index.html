<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java数据校验spring数据校验hibernate-validator一篇文章搞懂 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java数据校验spring数据校验hibernate-validator一篇文章搞懂" />
<meta property="og:description" content="1、为什么后台也需要校验呢？
虽然我们在前台js进行了拦截，比如submit总体校验一遍，或者每个form控件blur失去焦点的时候进行了校验，但是
我们服务器接口可能被服务器通过代码（http-client)访问，或者其他的方式跳过浏览器js的校验逻辑，如果后台不进行
校验，那么可能会带来严重的安全问题：比如sql注入，XXS攻击等等安全漏洞。
2、使用Hibernate-validator校验。
这个校验框架可不是我们通常所说的Hibernate数据访问层（dao）框架，它只是一个实现JSR-303标准的一个校验框架。
所谓JSR-303其实就是一个校验api定义，而Hibernate-validator是其标准的实现。就像jdbc是java访问数据库的标准api，
而具体的实现由数据库厂商自己去实现。
废话不多说，直接写个demo：
（1）引入相应的jar包
&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.3.4.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; 关于el的jar包引入是因为Hibernate-validator需要使用到el表达式的功能，至少上述版本是这样的，否则运行时会报错。
如果是在web环境，上述el表达式可以设置&lt;scope&gt;provided&lt;scope&gt;。
（2）写好我们需要校验的javaBean
PersonDto.java和Address.java
package normal.test.spring.bootstrap.validator; import org.hibernate.validator.constraints.Email; import org.hibernate.validator.constraints.Length; import javax.validation.Valid; import javax.validation.constraints.Max; import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; public class PersonDto { @NotNull @Length(max = 10,min = 1,message = &#34;姓名必须在1-10个字符之间&#34;) private String name; @Min(value = 18,message = &#34;年龄不能小于18&#34;) @Max(value = 100,message = &#34;年龄不能大于100&#34;) private Integer age; @Valid private Address address; @Email private String email; public void setEmail(String email) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6275236f961a9e4126312297d565fd4b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-01T22:51:15+08:00" />
<meta property="article:modified_time" content="2023-05-01T22:51:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java数据校验spring数据校验hibernate-validator一篇文章搞懂</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、为什么后台也需要校验呢？</p> 
<p>虽然我们在前台js进行了拦截，比如submit总体校验一遍，或者每个form控件blur失去焦点的时候进行了校验，但是</p> 
<p>我们服务器接口可能被服务器通过代码（http-client)访问，或者其他的方式跳过浏览器js的校验逻辑，如果后台不进行</p> 
<p>校验，那么可能会带来严重的安全问题：比如sql注入，XXS攻击等等安全漏洞。</p> 
<p>2、使用Hibernate-validator校验。</p> 
<p>这个校验框架可不是我们通常所说的Hibernate数据访问层（dao）框架，它只是一个实现JSR-303标准的一个校验框架。</p> 
<p>所谓JSR-303其实就是一个校验api定义，而Hibernate-validator是其标准的实现。就像jdbc是java访问数据库的标准api，</p> 
<p>而具体的实现由数据库厂商自己去实现。</p> 
<p>废话不多说，直接写个demo：</p> 
<p>（1）引入相应的jar包</p> 
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
   &lt;version&gt;5.3.4.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;javax.el&lt;/groupId&gt;
   &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt;
   &lt;version&gt;2.2.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;
   &lt;artifactId&gt;javax.el&lt;/artifactId&gt;
   &lt;version&gt;2.2.4&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>关于el的jar包引入是因为Hibernate-validator需要使用到el表达式的功能，至少上述版本是这样的，否则运行时会报错。</p> 
<p>如果是在web环境，上述el表达式可以设置&lt;scope&gt;provided&lt;scope&gt;。</p> 
<p>（2）写好我们需要校验的javaBean</p> 
<p>PersonDto.java和Address.java</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7f/a0/pGnHWbTd_o.gif"></p> 
<pre>package normal.test.spring.bootstrap.validator;

import org.hibernate.validator.constraints.Email;
import org.hibernate.validator.constraints.Length;

import javax.validation.Valid;
import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;

public class PersonDto {
    @NotNull
    @Length(max = 10,min = 1,message = "姓名必须在1-10个字符之间")
    private String name;
    @Min(value = 18,message = "年龄不能小于18")
    @Max(value = 100,message = "年龄不能大于100")
    private Integer age;
    @Valid
    private Address address;
    @Email
    private String email;

    public void setEmail(String email) {
        this.email = email;
    }

    public String getEmail() {
        return email;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public Address getAddress() {
        return address;
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c8/4b/p7lZVhkp_o.gif"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/37/d2/ht68CCeC_o.gif"></p> 
<pre>package normal.test.spring.bootstrap.validator;

import javax.validation.constraints.NotNull;

public class Address {
    @NotNull
    private String country;
    @NotNull
    private String province;
    private String city;
    private String cityDetail;

    public void setCity(String city) {
        this.city = city;
    }

    public String getCity() {
        return city;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public String getCountry() {
        return country;
    }

    public void setProvince(String province) {
        this.province = province;
    }

    public String getProvince() {
        return province;
    }

    public void setCityDetail(String cityDetail) {
        this.cityDetail = cityDetail;
    }

    public String getCityDetail() {
        return cityDetail;
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/de/cb/PcXHWx2n_o.gif"></p> 
<p>其实上述类就是简单java类，只是将JSR-303定义的一些约束类（Constraint）的注解加入到了各个属性而已。</p> 
<p>（3）使用Validator</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1d/9b/9blHhHyW_o.gif"></p> 
<pre>package normal.test.spring.bootstrap.validator;

import org.junit.Test;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import java.util.Set;

public class HibernateValidatorTest {
    @Test
    public void test01(){
        // 首先获取ValidatorFactory
        ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();
        // 然后获取validator实例
        Validator validator = validatorFactory.getValidator();
        // 进行校验
        PersonDto personDto = new PersonDto();
        personDto.setName("1111111111111111111111111");
        personDto.setAge(111);
        Address address = new Address();
        address.setCountry("中国");
        personDto.setAddress(address);
        personDto.setEmail("111111@com");
        Set&lt;ConstraintViolation&lt;PersonDto&gt;&gt; constraintViolationSet = validator.validate(personDto);
        // 如果constraintViolationSet为空说明没有任务错误
        for (ConstraintViolation&lt;PersonDto&gt; personDtoConstraintViolation : constraintViolationSet) {
            System.out.println(personDtoConstraintViolation.toString());
            System.out.println(personDtoConstraintViolation.getMessage());
        }
        // 关闭factory
        validatorFactory.close();

    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/64/Db0Shyf7_o.gif"></p> 
<p>运行截图如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f1/f6/CA0m3PXy_o.png"></p> 
<p></p> 
<p> 由此可见，我们@Valid注解提供了递归校验，这样我们只要在对应的javaBean中写上注解，那么校验起来是非常有效的。</p> 
<p>（4）总结各个注解的作用：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5b/51/4dQgm5Wb_o.png"></p> 
<p></p> 
<p> 这些注解有些是Hibernate-validator自定义的，当然上述描述自己要去实践才行。</p> 
<p></p> 
<p>3、上述两点只是描述了java开发进行数据校验的标准方式，但是我们开发中往往都会使用spring，那么spring其实也是有自己的校验接口的。</p> 
<p>org.springframework.validation.Validator就是spring自己提供的接口，换句话说我们可以使用实现该接口来对某个bean进行校验。</p> 
<p>关于spring的文档，我推荐<a href="https://www.docs4dev.com/docs/zh/spring-framework/4.3.21.RELEASE/reference/validation.html#validator" rel="nofollow" title="Spring Framework 中文文档 - 9. 验证，数据绑定和类型转换 | Docs4dev">Spring Framework 中文文档 - 9. 验证，数据绑定和类型转换 | Docs4dev</a></p> 
<p> 下面是借鉴过来的描述：</p> 
<p>Spring 具有<code>Validator</code>接口，可用于验证对象。 <code>Validator</code>接口使用<code>Errors</code>对象工作，因此验证器可以将验证失败报告给<code>Errors</code>对象。</p> 
<p> 让我们考虑一个小的数据对象：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/aa/25/jaVI7YBO_o.gif"></p> 
<pre>public class Person {

    private String name;
    private int age;

    // the usual getters and setters...
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/81/df/KRcAOIbF_o.gif"></p> 
<p>我们将通过实现<code>org.springframework.validation.Validator</code>接口的以下两种方法来提供<code>Person</code>类的验证行为：</p> 
<ul><li> <p><code>supports(Class)</code>-此<code>Validator</code>可以验证提供的<code>Class</code>的实例吗？</p> </li><li> <p><code>validate(Object, org.springframework.validation.Errors)</code>-验证给定的对象，如果发生验证错误，请向给定的<code>Errors</code>对象注册</p> </li></ul> 
<p> 实现<code>Validator</code>非常简单，尤其是当您知道 Spring 框架还提供的<code>ValidationUtils</code> 类时。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b4/24/0Nd9ZEaX_o.gif"></p> 
<pre>public class PersonValidator implements Validator {

    /**
     * This Validator validates *just* Person instances
     */
    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }

    public void validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
        Person p = (Person) obj;
        if (p.getAge() &lt; 0) {
            e.rejectValue("age", "negativevalue");
        } else if (p.getAge() &gt; 110) {
            e.rejectValue("age", "too.darn.old");
        }
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f5/17/VyQAvtzg_o.gif"></p> 
<p>如您所见，<code>ValidationUtils</code>类上的<code>static</code> <code>rejectIfEmpty(..)</code>方法用于拒绝<code>'name'</code>属性(如果它是<code>null</code>或空字符串)。看看<code>ValidationUtils</code> javadocs，看看它提供了什么功能，除了前面显示的示例。</p> 
<p>虽然可以实现单个<code>Validator</code>类来验证丰富对象中的每个嵌套对象，但是最好将每个嵌套类的验证逻辑封装在自己的<code>Validator</code>实现中。 *'rich'*对象的一个简单示例是<code>Customer</code>，它由两个<code>String</code>属性(名字和名字)和一个复杂的<code>Address</code>对象组成。 <code>Address</code>对象可以独立于<code>Customer</code>对象使用，因此已实现了不同的<code>AddressValidator</code>。如果您希望<code>CustomerValidator</code>重用<code>AddressValidator</code>类中包含的逻辑而不求助于复制粘贴，则可以在<code>CustomerValidator</code>中依赖注入或实例化<code>AddressValidator</code>，并按如下方式使用它：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e2/b4/a6nVySwx_o.gif"></p> 
<pre>public class CustomerValidator implements Validator {

    private final Validator addressValidator;

    public CustomerValidator(Validator addressValidator) {
        if (addressValidator == null) {
            throw new IllegalArgumentException("The supplied [Validator] is " +
                "required and must not be null.");
        }
        if (!addressValidator.supports(Address.class)) {
            throw new IllegalArgumentException("The supplied [Validator] must " +
                "support the validation of [Address] instances.");
        }
        this.addressValidator = addressValidator;
    }

    /**
     * This Validator validates Customer instances, and any subclasses of Customer too
     */
    public boolean supports(Class clazz) {
        return Customer.class.isAssignableFrom(clazz);
    }

    public void validate(Object target, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
        Customer customer = (Customer) target;
        try {
            errors.pushNestedPath("address");
            ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
        } finally {
            errors.popNestedPath();
        }
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/30/FMJW1hsM_o.gif"></p> 
<p>其实我们经常写在Controller中的方法参数BindingResult就是Errors的扩展。</p> 
<p>下面是我的观点了哈：</p> 
<p>上述这种spring的校验接口，相当于每个javaBean都要去写对应的XxxValidator接口，其实是非常不方便的。</p> 
<p>于是spring中有一个类就整合了第1点和第2点描述的内容，这个类是<strong>LocalValidatorFactoryBean</strong></p> 
<p></p> 
<p>4、重点了，重点了，重点了 。。。。<strong>LocalValidatorFactoryBean</strong></p> 
<p>该类其实虽然叫FactoryBean但却不是FactoryBean&lt;T&gt;接口的实例。</p> 
<p>它准确来讲是javax.validator.Validator的装饰器，同时又将校验功能适配到org.springframework.validation.Validator接口。</p> 
<p>所以，我们在代码中可以@Autowire上述两种校验接口。</p> 
<p>但是为何我们会对<strong>LocalValidatorFactoryBean</strong>如何陌生呢？</p> 
<p> 是因为：</p> 
<p>（1）如果在基于xml配置容器元数据时，xml中配置了&lt;mvc:annotation-driven&gt;，那么spring会默认给我们将<strong>LocalValidatorFactoryBean</strong>注入到容器中。</p> 
<p> 而且该实例会跟WebDataBinder关联起来，至于WebDataBinder是啥，这里就不多说了。</p> 
<p>（2）基于javaCode的方式配置元数据时。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d3/b5/Wj6X09XQ_o.gif"></p> 
<pre>@Configuration
@EnableWebMvc
public class WebConfig extends WebMvcConfigurerAdapter {

    @Override
    public Validator getValidator(); {
        // return "global" validator
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ed/ac/t9wl5245_o.gif"></p> 
<p>也就是说往往都是容器替我们配置了<strong>LocalValidatorFactoryBean</strong>，当然我们也可以自行配置。</p> 
<p>那么在具体的controller中我们需要怎么做呢？</p> 
<p>如下copy的图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7d/81/z52LfytD_o.png"></p> 
<p></p> 
<p> 我们需要在入参中对javaBean标上@Valid注解，然后紧接其后加入BindingResult参数，这样WebDataBinder会将</p> 
<p>校验的错误结果放入到上图的result中。</p> 
<p>当然，往往我们都是通过异常解析器统一处理BindingException。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2c/9f/qNIt7iFu_o.gif"></p> 
<pre>@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BindException.class)
    @ResponseBody
    public ResultBean validationErrorHandler(BindException ex) throws JsonProcessingException {
        //1.此处先获取BindingResult
        BindingResult bindingResult = ex.getBindingResult();
        //2.获取错误信息
        List&lt;FieldError&gt; fieldErrors = bindingResult.getFieldErrors();
        //3.组装异常信息
        Map&lt;String,String&gt; message = new HashMap&lt;&gt;();
        for (FieldError fieldError : fieldErrors) {
            message.put(fieldError.getField(),fieldError.getDefaultMessage());
        }
        //4.将map转换为JSON
        ObjectMapper objectMapper = new ObjectMapper();
        String json = objectMapper.writeValueAsString(message);
        //5.返回错误信息
        return new ResultBean("400",json);
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/52/b0/VS3WUHwD_o.gif"></p> 
<p></p> 
<p>写到这里，我不知道你搞懂了吗？</p> 
<p>总结一下：</p> 
<p>在我们项目中，往往需要引入Hibernate-validator的jar包，当然spring-boot由starter引入。</p> 
<p>目的是为了引入JSR-303的实现。</p> 
<p>我们往往不需要配置自己的org.springframework.validation.Validator实例，是因为我们</p> 
<p>通过&lt;mvc:annotation-driven&gt;或者@EnableWebMvc的配置告诉spring做了默认注册，当然</p> 
<p>该配置，不止是验证那么简单，还有其他的东西。</p> 
<p>如果，标准的注解满足不了我们，可以自己实现对应的org.springframework.validation.Validator或者</p> 
<p>扩展@Constraint（具体怎么扩展，不在这里提了）。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eeab80ecb0ccc5572b4ef8e99f43d59f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【机器学习】图像语义分割常用指标Dice系数 敏感性 特异性 IOU及python代码实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/725ae32d448815ff8738bbc34e4ab36a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023年全国职业技能大赛软件测试之自动化测试题目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>