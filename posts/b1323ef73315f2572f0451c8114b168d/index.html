<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>工程中uint8变量文件比uint32变量文件大4字节的问题排查 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="工程中uint8变量文件比uint32变量文件大4字节的问题排查" />
<meta property="og:description" content="前言 （1）如果有嵌入式企业需要招聘湖南区域日常实习生，任何区域的暑假Linux驱动实习岗位，可C站直接私聊，或者邮件：zhangyixu02@gmail.com，此消息至2025年1月1日前均有效
（2）今天在一个交流群看到一个有意思的问题，网友问：开发32位单片机，能够使用unsigned char 就不使用unsigned int，这样是否可以节约内存呢？
（3）当时我看到这个问题是懵的，uint8怎么会比uint32更节省空间呢？
（4）学习本文之前，需要先了解数据的内存分配知识，所以需要各位先了解这篇博客：
RAM明明断电会丢失数据，为什么初始化的全局变量存储在RAM？详细分析程序的存储
网友问题解决思路 （1）首先申明一下这位网友的测试环境，是在STM32F103中进行的相关测试。
问题 （1）这位网友在测试代码工程的时候，发现将unsigned char修改为unsigned int的时候，工程代码会减少4字节。
解决思路 （1）对于这个问题，很容易知道大体问题是在哪里。
&lt;1&gt;首先，这个是局部变量，他不会占用实际的空间，因此我们发现，实际变化的内存大小是在code段。
&lt;2&gt;其次，在32位的机器中，CPU寄存器都是32位的，因此在处理数据的时候，低于4字节数据会被提升到4字节再进行处理。
（2）那么，我们就可以大致的推断出，这个地方大概率是需要汇编指令进行字节提升，新增加的汇编指令导致code段增多了。
（3）既然有了上述的基础概念之后，就开始定位问题。
&lt;1&gt;第一步，查看map文件。我们需要知道，这个增加的汇编指令具体是在那个文件中。
&lt;2&gt;对比uint8和uint32的map文件中Image component sizes部分，我们能够发现，提升的4字节果然是在main.o中，因此此时就知道是在main.c中的在汇编阶段导致的汇编代码不同的问题。
&lt;3&gt;查看汇编，使用keil的Debug功能，能够帮我们看到汇编内容，直接在mian.c中开断点，对比汇编代码。我们能够发现，如果是uint32，只有一个BCC的指令，但是如果是uint8就是UXTB和BLT。
&lt;4&gt;既然知道的区别之后，开始研读这几条汇编代码，进行对比分析。因为这里是无符号数据的对比，所以说，BCC和BLT其实是等效的。如果是有符号数据比较，那么就需要使用BLT。（这是arm汇编的内容，简单了解即可，不会的时候查谷歌、百度、chatgpt）
# uint8 UXTB r4 , r0 ;将一个8位无符号字节零扩展为32位无符号整数，高位的24位填充为零 CMP r4 , 0x64 ;将寄存器r4的值和0x64（十进制就是100）对比 BLT 0x0800aA8C ; 如果CMP指令的比较结果是负数（即r4&lt;0x64），则跳转到0x0800aA8C 地址 # uint32 CMP r4 , 0x64 ;将寄存器r4的值和0x64（十进制就是100）对比 BCC 0x0800aA8C ; 如果前一条CMP指令的比较结果没有产生进位（即r4&gt;=0x64），则执行分支 &lt;5&gt;知道汇编代码的大致意思之后，此时就要考虑汇编代码的大小问题。通过询问chatgpt可知，这三条指令都是4字节，因此，当我们main.c中汇编之后多了一条汇编指令，code段就会增加4字节。
扩展测试1 问题 （1）我们发现，上面测试的都是局部变量，我们要不试试全局变量看看结果如何？
（2）我们能够发现两个有意思的问题：
&lt;1&gt;对比两个全局变量，我们会发现，生成的代码一模一样。
&lt;2&gt;对比全局变量和局部变量：code段增加了，rodata不变，rw增加4字节，zi段减少了4字节。（这个我也不会，苦笑。查了很久资料，也调了很久，不知道为啥怎么是这样的结果。应该是工程中某些细节影响，具体细节没排查到）
解决思路 （1）首先我们先看两个全局变量工程怎么会一模一样的。还是直接看map文件，通过对比map文件知道内存布局信息。
（2）我们能够发现main.o的RW-data确实少了3字节数据，但是呢，在(incl. Padding)，RW-data却多了3字节数据。
（3）为什么在(incl. Padding)，RW-data却多了3字节数据呢？查阅资料可知，编译器为了满足对齐要求而在数据或代码之间插入额外的填充字节。一般来说，字节对齐只有两种可能：
&lt;1&gt;硬件要求： 许多计算机体系结构对于某些数据类型的访问有硬件对齐的要求。例如，一些处理器可能要求访问特定大小的数据类型的变量时，其地址必须是该数据类型大小的倍数。如果不满足这些要求，可能导致性能下降或者引发硬件异常。如果是采用的冯诺依曼结构，不进行字节对齐，可能导致指令和数据弄混淆。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b1323ef73315f2572f0451c8114b168d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T12:28:21+08:00" />
<meta property="article:modified_time" content="2024-01-03T12:28:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">工程中uint8变量文件比uint32变量文件大4字节的问题排查</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<blockquote> 
 <p>（1）<mark>如果有嵌入式企业需要招聘湖南区域日常实习生，任何区域的暑假Linux驱动实习岗位，可C站直接私聊，或者邮件：zhangyixu02@gmail.com，此消息至2025年1月1日前均有效</mark><br> （2）今天在一个交流群看到一个有意思的问题，网友问：开发32位单片机，能够使用unsigned char 就不使用unsigned int，这样是否可以节约内存呢？<br> （3）当时我看到这个问题是懵的，uint8怎么会比uint32更节省空间呢？<br> （4）学习本文之前，需要先了解数据的内存分配知识，所以需要各位先了解这篇博客：<br> <a href="https://blog.csdn.net/qq_63922192/article/details/131945593">RAM明明断电会丢失数据，为什么初始化的全局变量存储在RAM？详细分析程序的存储</a></p> 
</blockquote> 
<h2><a id="_6"></a>网友问题解决思路</h2> 
<blockquote> 
 <p>（1）首先申明一下这位网友的测试环境，是在STM32F103中进行的相关测试。</p> 
</blockquote> 
<h3><a id="_8"></a>问题</h3> 
<blockquote> 
 <p>（1）这位网友在测试代码工程的时候，发现将<code>unsigned char</code>修改为<code>unsigned int</code>的时候，工程代码会减少4字节。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/2d/50/vktPZnyY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/17/39/FIY0VvRw_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_13"></a>解决思路</h3> 
<blockquote> 
 <p>（1）对于这个问题，很容易知道大体问题是在哪里。<br> &lt;1&gt;首先，这个是局部变量，他不会占用实际的空间，因此我们发现，实际变化的内存大小是在code段。<br> &lt;2&gt;其次，在32位的机器中，CPU寄存器都是32位的，因此在处理数据的时候，低于4字节数据会被提升到4字节再进行处理。<br> （2）那么，我们就可以大致的推断出，这个地方大概率是需要汇编指令进行字节提升，新增加的汇编指令导致<code>code</code>段增多了。<br> （3）既然有了上述的基础概念之后，就开始定位问题。<br> &lt;1&gt;第一步，查看<code>map</code>文件。我们需要知道，这个增加的汇编指令具体是在那个文件中。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8f/62/qN72Oak7_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>&lt;2&gt;对比<code>uint8</code>和<code>uint32</code>的<code>map</code>文件中<code>Image component sizes</code>部分，我们能够发现，提升的4字节果然是在<code>main.o</code>中，因此此时就知道是在<code>main.c</code>中的在汇编阶段导致的汇编代码不同的问题。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a3/b4/gFiNtLkc_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>&lt;3&gt;查看汇编，使用keil的Debug功能，能够帮我们看到汇编内容，直接在mian.c中开断点，对比汇编代码。我们能够发现，如果是<code>uint32</code>，只有一个<code>BCC</code>的指令，但是如果是<code>uint8</code>就是<code>UXTB</code>和<code>BLT</code>。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/0b/59/73lcDvnt_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>&lt;4&gt;既然知道的区别之后，开始研读这几条汇编代码，进行对比分析。因为这里是无符号数据的对比，所以说，<code>BCC</code>和<code>BLT</code>其实是等效的。如果是有符号数据比较，那么就需要使用<code>BLT</code>。（这是arm汇编的内容，简单了解即可，不会的时候查谷歌、百度、chatgpt）</p> 
</blockquote> 
<pre><code class="prism language-asm"># uint8
UXTB   r4 , r0 ;将一个8位无符号字节零扩展为32位无符号整数，高位的24位填充为零
CMP    r4 , 0x64 ;将寄存器r4的值和0x64（十进制就是100）对比
BLT    0x0800aA8C ; 如果CMP指令的比较结果是负数（即r4&lt;0x64），则跳转到0x0800aA8C 地址
# uint32
CMP    r4 , 0x64 ;将寄存器r4的值和0x64（十进制就是100）对比
BCC    0x0800aA8C ; 如果前一条CMP指令的比较结果没有产生进位（即r4&gt;=0x64），则执行分支
</code></pre> 
<blockquote> 
 <p>&lt;5&gt;知道汇编代码的大致意思之后，此时就要考虑汇编代码的大小问题。通过询问chatgpt可知，这三条指令都是4字节，因此，当我们main.c中汇编之后多了一条汇编指令，code段就会增加4字节。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/7c/e7/6DhWiC7b_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="1_43"></a>扩展测试1</h2> 
<h3><a id="_44"></a>问题</h3> 
<blockquote> 
 <p>（1）我们发现，上面测试的都是局部变量，我们要不试试全局变量看看结果如何？<br> （2）我们能够发现两个有意思的问题：<br> &lt;1&gt;对比两个全局变量，我们会发现，生成的代码一模一样。<br> &lt;2&gt;对比全局变量和局部变量：code段增加了，rodata不变，rw增加4字节，zi段减少了4字节。（这个我也不会，苦笑。查了很久资料，也调了很久，不知道为啥怎么是这样的结果。应该是工程中某些细节影响，具体细节没排查到）</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/26/b3/bF0FSToU_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_52"></a>解决思路</h3> 
<blockquote> 
 <p>（1）首先我们先看两个全局变量工程怎么会一模一样的。还是直接看map文件，通过对比<code>map</code>文件知道内存布局信息。<br> （2）我们能够发现main.o的RW-data确实少了3字节数据，但是呢，在(incl. Padding)，RW-data却多了3字节数据。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/55/23/Bee2Dp6O_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>（3）为什么在<code>(incl. Padding</code>)，<code>RW-data</code>却多了3字节数据呢？查阅资料可知，编译器为了满足对齐要求而在数据或代码之间插入额外的填充字节。一般来说，字节对齐只有两种可能：<br> &lt;1&gt;<strong>硬件要求：</strong> 许多计算机体系结构对于某些数据类型的访问有硬件对齐的要求。例如，一些处理器可能要求访问特定大小的数据类型的变量时，其地址必须是该数据类型大小的倍数。如果不满足这些要求，可能导致性能下降或者引发硬件异常。如果是采用的冯诺依曼结构，不进行字节对齐，可能导致指令和数据弄混淆。<br> &lt;2&gt;<strong>性能优化：</strong> 计算机系统通常会将数据加载到寄存器中进行处理，而寄存器的大小通常是2的幂。如果数据类型的大小是寄存器大小的倍数，那么从内存加载数据到寄存器的操作就更为高效。字节对齐可以确保数据在内存中的地址是寄存器大小的倍数，提高访问速度。<br> （4）因为这里的测试平台是<code>STM32F103</code>，采用的是<code>CM3</code>内核，因此我打开<code>CM3</code>内核手册可知，寄存器的<code>PUSH</code>和<code>POP</code>永远是4字节对齐的。因此，这里是硬件层面要求进行字节对齐操作。因此，<code>uint8</code>和<code>uint32</code>的全局变量产生的代码工程是一样的效果。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/1e/6a/tifFZyY2_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2_66"></a>扩展测试2</h2> 
<h3><a id="_67"></a>问题</h3> 
<blockquote> 
 <p>（1）上面我们发现，uint8和uint32的全局变量结果一模一样。那么我们尝试创建两个全局变量试试呢？<br> （2）结果发现，RW-data增加了4字节，ZI-data增加4字节。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/43/aa/czGOJCZM_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_73"></a>解决思路</h3> 
<blockquote> 
 <p>（1）依旧是看<code>map</code>文件，我们发现main.o的RW-data确实是从2字节变成了8字节，但是同时也少了2字节的字节对齐。因此RW-data是增加了4字节。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/7d/7c/r3QwfTbu_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>（2）看ZI-data，发现这里会增加4字节对齐，具体原因不清楚</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/de/e9/BpieEGUc_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_80"></a>总结</h2> 
<blockquote> 
 <p>（1）关于<code>uint8</code>占用空间更多，还是<code>uint32</code>占用空间更多，这个取决于<strong>编译器的编译策略</strong>，<strong>硬件特性</strong>，<strong>性能优化</strong>。我们无法一概而论。正因如此，在目前内存不那么紧张的时代，不要过分的纠结于这个问题。什么时候用那个数据，就用那个，不要抱有心理负担。否则只会适得其反，拖慢研发速度。</p> 
</blockquote> 
<h2><a id="_83"></a>参考</h2> 
<blockquote> 
 <p>（1）CM3权威指南<br> （2）<a href="https://www.cnblogs.com/hangzhe/p/6916502.html" rel="nofollow">关于ARM中的tst、cmp、bne、beq指令</a><br> （3）<a href="https://blog.51cto.com/u_15091060/2665644" rel="nofollow">用Keil生成bin、汇编、C与汇编混合文件，再也不想debug了！</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e4e385c415c508abdcb754313c17b49/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在Milk-V duo的小核FreeRTOS中跑i2c</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1be0440a91c37b5feba92110f3cb7c03/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024三掌柜赠书活动第一期：TVM编译器原理与实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>