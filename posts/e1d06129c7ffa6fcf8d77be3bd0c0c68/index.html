<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Opencv实现的三次样条曲线(Cubic Spline)插值 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Opencv实现的三次样条曲线(Cubic Spline)插值" />
<meta property="og:description" content="1.样条曲线简介 样条曲线(Spline)本质是分段多项式实函数，在实数范围内有： S:[a,b]→R ，在区间 [a,b] 上包含 k 个子区间[ti−1,ti]，且有：
a=t0&lt;t1&lt;⋯&lt;tk−1&lt;tk=b(1)
对应每一段区间 i 的存在多项式： Pi:[ti−1,ti]→R，且满足于：
S(t)=P1(t) , t0≤t&lt;t1,S(t)=P2(t) , t1≤t&lt;t2,⋮S(t)=Pk(t) , tk−1≤t≤tk.(2)
其中， Pi(t) 多项式中最高次项的幂，视为样条的阶数或次数（Order of spline），根据子区间 [ti−1,ti] 的区间长度是否一致分为均匀（Uniform）样条和非均匀（Non-uniform）样条。
满足了公式 (2) 的多项式有很多，为了保证曲线在 S 区间内具有据够的平滑度，一条n次样条，同时应具备处处连续且可微的性质：
P(j)i(ti)=P(j)i&#43;1(ti);(3)
其中 i=1,…,k−1;j=0,…,n−1 。
2.三次样条曲线 2.1曲线条件 按照上述的定义，给定节点：
t:z:a=t0z0&lt;t1z1&lt;⋯⋯&lt;tk−1zk−1&lt;tkzk=b(4)
三次样条曲线满足三个条件：
在每段分段区间 [ti,ti&#43;1],i=0,1,…,k−1 上， S(t)=Si(t) 都是一个三次多项式；满足 S(ti)=zi,i=1,…,k−1 ;S(t) 的一阶导函数 S′(t) 和二阶导函数 S′′(t) 在区间 [a,b] 上都是连续的，从而曲线具有光滑性。 则三次样条的方程可以写为：
Si(t)=ai&#43;bi(t−ti)&#43;ci(t−ti)2&#43;di(t−ti)3,(5)
其中， ai,bi,ci,di 分别代表 n 个未知系数。
曲线的连续性表示为： Si(ti)=zi,(6)
Si(ti&#43;1)=zi&#43;1,(7)
其中 i=0,1,…,k−1 。
曲线微分连续性： S′i(ti&#43;1)=S′i&#43;1(ti&#43;1),(8)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e1d06129c7ffa6fcf8d77be3bd0c0c68/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-01T22:32:06+08:00" />
<meta property="article:modified_time" content="2023-11-01T22:32:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Opencv实现的三次样条曲线(Cubic Spline)插值</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="1样条曲线简介" style="background-color:transparent;"><strong>1.样条曲线简介</strong></h4> 
<p>样条曲线(<a href="https://en.wikipedia.org/wiki/Spline_%28mathematics%29" rel="nofollow" title="Spline">Spline</a>)本质是分段多项式实函数，在实数范围内有： S:[a,b]→R ，在区间 [a,b] 上包含 k 个子区间[ti−1,ti]，且有：</p> 
<p>a=t0&lt;t1&lt;⋯&lt;tk−1&lt;tk=b(1)</p> 
<p>对应每一段区间 i 的存在多项式： Pi:[ti−1,ti]→R，且满足于：</p> 
<p>S(t)=P1(t) , t0≤t&lt;t1,S(t)=P2(t) , t1≤t&lt;t2,⋮S(t)=Pk(t) , tk−1≤t≤tk.(2)</p> 
<p>其中， Pi(t) 多项式中最高次项的幂，视为样条的阶数或次数（Order of spline），根据子区间 [ti−1,ti] 的区间长度是否一致分为均匀（Uniform）样条和非均匀（Non-uniform）样条。</p> 
<p>满足了公式 (2) 的多项式有很多，为了保证曲线在 S 区间内具有据够的平滑度，一条n次样条，同时应具备处处连续且可微的性质：</p> 
<p>P(j)i(ti)=P(j)i+1(ti);(3)</p> 
<p>其中 i=1,…,k−1;j=0,…,n−1 。</p> 
<h4 id="2三次样条曲线"><strong>2.三次样条曲线</strong></h4> 
<h5 id="21曲线条件"><strong>2.1曲线条件</strong></h5> 
<p>按照上述的定义，给定节点：</p> 
<p>t:z:a=t0z0&lt;t1z1&lt;⋯⋯&lt;tk−1zk−1&lt;tkzk=b(4)</p> 
<p>三次样条曲线满足三个条件：</p> 
<ol><li>在每段分段区间 [ti,ti+1],i=0,1,…,k−1 上， S(t)=Si(t) 都是一个三次多项式；</li><li>满足 S(ti)=zi,i=1,…,k−1 ;</li><li>S(t) 的一阶导函数 S′(t) 和二阶导函数 S′′(t) 在区间 [a,b] 上都是连续的，从而曲线具有光滑性。</li></ol> 
<p>则三次样条的方程可以写为：</p> 
<p>Si(t)=ai+bi(t−ti)+ci(t−ti)2+di(t−ti)3,(5)</p> 
<p>其中， ai,bi,ci,di 分别代表 n 个未知系数。</p> 
<ul><li>曲线的连续性表示为：</li></ul> 
<p>Si(ti)=zi,(6)</p> 
<p>Si(ti+1)=zi+1,(7)</p> 
<p>其中 i=0,1,…,k−1 。</p> 
<ul><li>曲线微分连续性：</li></ul> 
<p>S′i(ti+1)=S′i+1(ti+1),(8)</p> 
<p>S′′i(ti+1)=S′′i+1(ti+1),(9)</p> 
<p>其中 i=0,1,…,k−2 。</p> 
<ul><li>曲线的导函数表达式：</li></ul> 
<p>S′i=bi+2ci(t−ti)+3di(t−ti)2,(10)</p> 
<p>S′′i(x)=2ci+6di(t−ti),(11)</p> 
<p>令区间长度 hi=ti+1−ti ，则有：</p> 
<ol><li> <p>由公式 (6) ，可得： ai=zi ；</p> </li><li> <p>由公式 (7) ，可得： ai+bihi+cih2i+dih3i=zi+1 ；</p> </li><li> <p>由公式 (8) ，可得：<br> S′i(ti+1)=bi+2cihi+3dih2i ;<br> S′i+1(ti+1)=bi+1 ；<br> ⇒bi+2cihi+3dih2i−bi+1=0 ；</p> </li><li> <p>由公式 (9) ，可得：<br> S′′i(ti+1)=2ci+6dihi ；<br> S′′i+1(ti+1)=2ci+1 ；<br> ⇒2ci+6dihi=2ci+1 ；</p> <p>设 mi=S′′i(xi)=2ci ，则：</p> <p><strong>A.</strong> mi+6dihi−mi+1=0⇒<br> di=mi+1−mi6hi ；</p> <p><strong>B.</strong>将 ci,di 代入 zi+bihi+cih2i+dih3i=zi+1⇒<br> bi=zi+1−zihi−hi2mi−hi6(mi+1−mi) ；</p> <p><strong>C.</strong>将 bi,ci,di 代入 bi+2cihi+3dih2i=bi+1⇒</p> <p>himi+2(hi+hi+1)mi+1+hi+1mi+2=6[zi+2−zi+1hi+1−zi+1−zihi].(12)</p> </li></ol> 
<h5 id="22端点条件"><strong>2.2端点条件</strong></h5> 
<p>在上述分析中，曲线段的两个端点 t0 和 tk 是不适用的，有一些常用的端点限制条件，这里只讲解自然边界。<br> 在自然边界下，首尾两端的二阶导函数满足 S′′=0 ，即 m0=0 和 mk=0 。</p> 
<h4>3.三次样条插值类的实现</h4> 
<h5>头文件</h5> 
<pre><code class="hljs">/*
  *Cubic spline interpolation class.
  *
*/

#ifndef CUBICSPLINEINTERPOLATION_H
#pragma once
#define CUBICSPLINEINTERPOLATION_H

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;math.h&gt;

#include &lt;opencv2/opencv.hpp&gt;

using namespace std;
using namespace cv;

/* Cubic spline interpolation coefficients */
class CubicSplineCoeffs
{
public:
    CubicSplineCoeffs( const int &amp;count )
    {
        a = std::vector&lt;double&gt;(count);
        b = std::vector&lt;double&gt;(count);
        c = std::vector&lt;double&gt;(count);
        d = std::vector&lt;double&gt;(count);
    }
    ~CubicSplineCoeffs()
    {
        std::vector&lt;double&gt;().swap(a);
        std::vector&lt;double&gt;().swap(b);
        std::vector&lt;double&gt;().swap(c);
        std::vector&lt;double&gt;().swap(d);
    }

public:
    std::vector&lt;double&gt; a, b, c, d;
};

enum CubicSplineMode
{
    CUBIC_NATURAL,    // Natural
    CUBIC_CLAMPED,    // TODO: Clamped
    CUBIC_NOT_A_KNOT  // TODO: Not a knot
};

enum SplineFilterMode
{
    CUBIC_WITHOUT_FILTER, // without filter
    CUBIC_MEDIAN_FILTER  // median filter
};

/* Cubic spline interpolation */
class CubicSplineInterpolation
{
public:
    CubicSplineInterpolation() {}
    ~CubicSplineInterpolation() {}

public:
    /*
        Calculate cubic spline coefficients.
          - node list x (input_x);
          - node list y (input_y);
          - output coefficients (cubicCoeffs);
          - ends mode (splineMode).
    */
    void calCubicSplineCoeffs( std::vector&lt;double&gt; &amp;input_x,
                std::vector&lt;double&gt; &amp;input_y, CubicSplineCoeffs *&amp;cubicCoeffs,
                CubicSplineMode splineMode = CUBIC_NATURAL,
                SplineFilterMode filterMode = CUBIC_MEDIAN_FILTER );

    /*
        Cubic spline interpolation for a list.
          - input coefficients (cubicCoeffs);
          - input node list x (input_x);
          - output node list x (output_x);
          - output node list y (output_y);
          - interpolation step (interStep).
    */
    void cubicSplineInterpolation( CubicSplineCoeffs *&amp;cubicCoeffs,
                std::vector&lt;double&gt; &amp;input_x, std::vector&lt;double&gt; &amp;output_x,
                std::vector&lt;double&gt; &amp;output_y, const double interStep = 0.5 );

    /*
        Cubic spline interpolation for a value.
          - input coefficients (cubicCoeffs);
          - input a value(x);
          - output interpolation value(y);
    */
    void cubicSplineInterpolation2( CubicSplineCoeffs *&amp;cubicCoeffs,
            std::vector&lt;double&gt; input_x, double x, double &amp;y );

    /*
        calculate  tridiagonal matrices with Thomas Algorithm(TDMA) :

        example:
        | b1 c1 0  0  0  0  |  |x1 |   |d1 |
        | a2 b2 c2 0  0  0  |  |x2 |   |d2 |
        | 0  a3 b3 c3 0  0  |  |x3 | = |d3 |
        | ...         ...   |  |...|   |...|
        | 0  0  0  0  an bn |  |xn |   |dn |

        Ci = ci/bi , i=1; ci / (bi - Ci-1 * ai) , i = 2, 3, ... n-1;
        Di = di/bi , i=1; ( di - Di-1 * ai )/(bi - Ci-1 * ai) , i = 2, 3, ..., n-1

        xi = Di - Ci*xi+1 , i = n-1, n-2, 1;
    */
    bool caltridiagonalMatrices( cv::Mat_&lt;double&gt; &amp;input_a,
        cv::Mat_&lt;double&gt; &amp;input_b, cv::Mat_&lt;double&gt; &amp;input_c,
        cv::Mat_&lt;double&gt; &amp;input_d, cv::Mat_&lt;double&gt; &amp;output_x );

    /* Calculate the curve index interpolation belongs to */
    int calInterpolationIndex( double &amp;pt, std::vector&lt;double&gt; &amp;input_x );

    /* median filtering */
    void cubicMedianFilter( std::vector&lt;double&gt; &amp;input, const int filterSize = 5 );

    double cubicSort( std::vector&lt;double&gt; &amp;input );
    // double cubicNearestValue( std::vector );
};

#endif // CUBICSPLINEINTERPOLATION_H
</code></pre> 
<h5>实现文件（cpp）</h5> 
<pre><code class="hljs">/*
 * CubicSplineInterpolation.cpp
 */

#include "cubicsplineinterpolation.h"

void CubicSplineInterpolation::calCubicSplineCoeffs(
    std::vector&lt;double&gt; &amp;input_x,
    std::vector&lt;double&gt; &amp;input_y,
    CubicSplineCoeffs *&amp;cubicCoeffs,
    CubicSplineMode splineMode /* = CUBIC_NATURAL */,
    SplineFilterMode filterMode /*= CUBIC_MEDIAN_FILTER*/ )
{
    int sizeOfx = input_x.size();
    int sizeOfy = input_y.size();

    if ( sizeOfx != sizeOfy )
    {
        std::cout &lt;&lt; "Data input error!" &lt;&lt; std::endl &lt;&lt;
            "Location: CubicSplineInterpolation.cpp" &lt;&lt;
            " -&gt; calCubicSplineCoeffs()" &lt;&lt; std::endl;

        return;
    }

    /*
        hi*mi + 2*(hi + hi+1)*mi+1 + hi+1*mi+2
        =  6{ (yi+2 - yi+1)/hi+1 - (yi+1 - yi)/hi }

        so, ignore the both ends:
        | -     -     -        0           ...             0     |  |m0 |
        | h0 2(h0+h1) h1       0           ...             0     |  |m1 |
        | 0     h1    2(h1+h2) h2 0        ...                   |  |m2 |
        |         ...                      ...             0     |  |...|
        | 0       ...           0 h(n-2) 2(h(n-2)+h(n-1)) h(n-1) |  |   |
        | 0       ...                      ...             -     |  |mn |

    */

    std::vector&lt;double&gt; copy_y = input_y;

    if ( filterMode == CUBIC_MEDIAN_FILTER )
    {
        cubicMedianFilter(copy_y, 5);
    }

    const int count  = sizeOfx;
    const int count1 = sizeOfx - 1;
    const int count2 = sizeOfx - 2;
    const int count3 = sizeOfx - 3;

    cubicCoeffs = new CubicSplineCoeffs( count1 );

    std::vector&lt;double&gt; step_h( count1, 0.0 );

    // for m matrix
    cv::Mat_&lt;double&gt; m_a(1, count2, 0.0);
    cv::Mat_&lt;double&gt; m_b(1, count2, 0.0);
    cv::Mat_&lt;double&gt; m_c(1, count2, 0.0);
    cv::Mat_&lt;double&gt; m_d(1, count2, 0.0);
    cv::Mat_&lt;double&gt; m_part(1, count2, 0.0);

    cv::Mat_&lt;double&gt; m_all(1, count, 0.0);

    // initial step hi
    for ( int idx=0; idx &lt; count1; idx ++ )
    {
        step_h[idx] = input_x[idx+1] - input_x[idx];
    }
    // initial coefficients
    for ( int idx=0; idx &lt; count3; idx ++ )
    {
        m_a(idx) = step_h[idx];
        m_b(idx) = 2 * (step_h[idx] + step_h[idx+1]);
        m_c(idx) = step_h[idx+1];
    }
    // initial d
    for ( int idx =0; idx &lt; count3; idx ++ )
    {
        m_d(idx) = 6 * (
            (copy_y[idx+2] - copy_y[idx+1]) / step_h[idx+1] -
            (copy_y[idx+1] - copy_y[idx]) / step_h[idx] );
    }

     //cv::Mat_&lt;double&gt; matOfm( count2,  )
    bool isSucceed = caltridiagonalMatrices(m_a, m_b, m_c, m_d, m_part);
    if ( !isSucceed )
    {
        std::cout&lt;&lt;"Calculate tridiagonal matrices failed!"&lt;&lt;std::endl&lt;&lt;
            "Location: CubicSplineInterpolation.cpp -&gt; " &lt;&lt;
            "caltridiagonalMatrices()"&lt;&lt;std::endl;

        return;
    }

    if ( splineMode == CUBIC_NATURAL )
    {
        m_all(0)      = 0.0;
        m_all(count1) = 0.0;

        for ( int i=1; i&lt;count1; i++ )
        {
            m_all(i) = m_part(i-1);
        }

        for ( int i=0; i&lt;count1; i++ )
        {
            cubicCoeffs-&gt;a[i] = copy_y[i];
            cubicCoeffs-&gt;b[i] = ( copy_y[i+1] - copy_y[i] ) / step_h[i] -
                step_h[i]*( 2*m_all(i) + m_all(i+1) ) / 6;
            cubicCoeffs-&gt;c[i] = m_all(i) / 2.0;
            cubicCoeffs-&gt;d[i] = ( m_all(i+1) - m_all(i) ) / ( 6.0 * step_h[i] );
        }
    }
    else
    {
        std::cout&lt;&lt;"Not define the interpolation mode!"&lt;&lt;std::endl;
    }
}

void CubicSplineInterpolation::cubicSplineInterpolation(
    CubicSplineCoeffs *&amp;cubicCoeffs,
    std::vector&lt;double&gt; &amp;input_x,
    std::vector&lt;double&gt; &amp;output_x,
    std::vector&lt;double&gt; &amp;output_y,
    const double interStep )
{
    const int count = input_x.size();

    double low  = input_x[0];
    double high = input_x[count-1];

    double interBegin = low;
    for ( ; interBegin &lt; high; interBegin += interStep )
    {
        int index = calInterpolationIndex(interBegin, input_x);
        if ( index &gt;= 0 )
        {
            double dertx = interBegin - input_x[index];
            double y = cubicCoeffs-&gt;a[index] + cubicCoeffs-&gt;b[index] * dertx +
                cubicCoeffs-&gt;c[index] * dertx * dertx +
                cubicCoeffs-&gt;d[index] * dertx * dertx * dertx;
            output_x.push_back(interBegin);
            output_y.push_back(y);
        }
    }
}

void CubicSplineInterpolation::cubicSplineInterpolation2(
    CubicSplineCoeffs *&amp;cubicCoeffs,
    std::vector&lt;double&gt; input_x, double x, double &amp;y)
{
    const int count = input_x.size();

    double low  = input_x[0];
    double high = input_x[count-1];

    if ( x&lt;low || x&gt;high )
    {
        std::cout&lt;&lt;"The interpolation value is out of range!"&lt;&lt;std::endl;
    }
    else
    {
        int index = calInterpolationIndex(x, input_x);
        if ( index &gt;= 0 )
        {
            double dertx = x - input_x[index];
            y = cubicCoeffs-&gt;a[index] + cubicCoeffs-&gt;b[index] * dertx +
                cubicCoeffs-&gt;c[index] * dertx * dertx +
                cubicCoeffs-&gt;d[index] * dertx * dertx * dertx;
        }
        else
        {
            std::cout&lt;&lt;"Can't find the interpolation range!"&lt;&lt;std::endl;
        }
    }
}

bool CubicSplineInterpolation::caltridiagonalMatrices(
    cv::Mat_&lt;double&gt; &amp;input_a,
    cv::Mat_&lt;double&gt; &amp;input_b,
    cv::Mat_&lt;double&gt; &amp;input_c,
    cv::Mat_&lt;double&gt; &amp;input_d,
    cv::Mat_&lt;double&gt; &amp;output_x )
{
    int rows = input_a.rows;
    int cols = input_a.cols;

    if ( ( rows == 1 &amp;&amp; cols &gt; rows ) ||
        (cols == 1 &amp;&amp; rows &gt; cols ) )
    {
        const int count = ( rows &gt; cols ? rows : cols ) - 1;

        output_x = cv::Mat_&lt;double&gt;::zeros(rows, cols);

        cv::Mat_&lt;double&gt; cCopy, dCopy;
        input_c.copyTo(cCopy);
        input_d.copyTo(dCopy);

        if ( input_b(0) != 0 )
        {
            cCopy(0) /= input_b(0);
            dCopy(0) /= input_b(0);
        }
        else
        {
            return false;
        }

        for ( int i=1; i &lt; count; i++ )
        {
            double temp = input_b(i) - input_a(i) * cCopy(i-1);
            if ( temp == 0.0 )
            {
                return false;
            }

            cCopy(i) /= temp;
            dCopy(i) = ( dCopy(i) - dCopy(i-1)*input_a(i) ) / temp;
        }

        output_x(count) = dCopy(count);
        for ( int i=count-2; i &gt; 0; i-- )
        {
            output_x(i) = dCopy(i) - cCopy(i)*output_x(i+1);
        }
        return true;
    }
    else
    {
        return false;
    }
}

int CubicSplineInterpolation::calInterpolationIndex(
    double &amp;pt, std::vector&lt;double&gt; &amp;input_x )
{
    const int count = input_x.size()-1;
    int index = -1;
    for ( int i=0; i&lt;count; i++ )
    {
        if ( pt &gt; input_x[i] &amp;&amp; pt &lt;= input_x[i+1] )
        {
            index = i;
            return index;
        }
    }
    return index;
}

void CubicSplineInterpolation::cubicMedianFilter(
    std::vector&lt;double&gt; &amp;input, const int filterSize /* = 5 */ )
{
    const int count = input.size();
    for ( int i=filterSize/2; i&lt;count-filterSize/2; i++ )
    {
        std::vector&lt;double&gt; temp(filterSize, 0.0);
        for ( int j=0; j&lt;filterSize; j++ )
        {
            temp[j] = input[i+j - filterSize/2];
        }

        input[i] = cubicSort(temp);

        std::vector&lt;double&gt;().swap(temp);
    }

    for ( int i=0; i&lt;filterSize/2; i++ )
    {
        std::vector&lt;double&gt; temp(filterSize, 0.0);
        for ( int j=0; j&lt;filterSize; j++ )
        {
            temp[j] = input[j];
        }

        input[i] = cubicSort(temp);
        std::vector&lt;double&gt;().swap(temp);
    }

    for ( int i=count-filterSize/2; i&lt;count; i++ )
    {
        std::vector&lt;double&gt; temp(filterSize, 0.0);
        for ( int j=0; j&lt;filterSize; j++ )
        {
            temp[j] = input[j];
        }

        input[i] = cubicSort(temp);
        std::vector&lt;double&gt;().swap(temp);
    }
}

double CubicSplineInterpolation::cubicSort( std::vector&lt;double&gt; &amp;input )
{
    int iCount = input.size();
    for ( int j=0; j&lt;iCount-1; j++ )
    {
        for ( int k=iCount-1; k&gt;j; k-- )
        {
            if ( input[k-1] &gt; input[k] )
            {
                double tp  = input[k];
                input[k]   = input[k-1];
                input[k-1] = tp;
            }
        }
    }
    return input[iCount/2];
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f789eb07ec91e9a02043ce027feb35ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">与云栖的浪漫邂逅：记一段寻找云端之美的旅程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09e7605c30ff5299971399ce5d7eb80d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C# 使用Thread类建线程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>