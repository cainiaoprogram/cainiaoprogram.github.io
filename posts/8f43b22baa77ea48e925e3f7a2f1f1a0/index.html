<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43; Primer】第10章 泛型算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43; Primer】第10章 泛型算法" />
<meta property="og:description" content="第10章 泛型算法 不同容器都能用的算法
经典算法的公共接口：如排序，搜索
10.1 概述 大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数组泛型算法。
int val = 42; auto res = find(vec.cbegin(), vec.end(), val); cout &lt;&lt; &#34;The value &#34; &lt;&lt; val &lt;&lt; (res == vec.cend() ? &#34;找到&#34; : &#34;未找到&#34;) &lt;&lt;endl; string val = &#34;a value&#34;; auto res = find(lst.cbegin(), lst.cend(), val); int ia[] = {27,210,12,47,109,83}; int val = 83; int* res = find(begin(ia), end(ia), val); auto res = find(ia&#43;1, ia&#43;4, val); 只需要传入迭代器，但不依赖容器类型；但算法依赖于元素类型的操作
习题10.1
class Solution{ public: int targetNum(vector&lt;int&gt;&amp; v, int target){ int num = count(v." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8f43b22baa77ea48e925e3f7a2f1f1a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-22T11:03:53+08:00" />
<meta property="article:modified_time" content="2022-02-22T11:03:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43; Primer】第10章 泛型算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="10__0"></a>第10章 泛型算法</h2> 
<p>不同容器都能用的算法</p> 
<p>经典算法的公共接口：如排序，搜索</p> 
<h3><a id="101__6"></a>10.1 概述</h3> 
<p>大多数算法都定义在头文件<strong>algorithm</strong>中。标准库还在头文件<strong>numeric</strong>中定义了一组数组泛型算法。</p> 
<pre><code class="prism language-c++">int val = 42;
auto res = find(vec.cbegin(), vec.end(), val);
cout &lt;&lt; "The value " &lt;&lt; val 
     &lt;&lt; (res == vec.cend() ? "找到" : "未找到") &lt;&lt;endl;
</code></pre> 
<pre><code class="prism language-c++">string val = "a value";
auto res = find(lst.cbegin(), lst.cend(), val);
</code></pre> 
<pre><code class="prism language-c++">int ia[] = {27,210,12,47,109,83};
int val = 83;
int* res = find(begin(ia), end(ia), val);

auto res = find(ia+1, ia+4, val);
</code></pre> 
<p>只需要传入迭代器，但不依赖容器类型；但算法依赖于元素类型的操作</p> 
<p>习题10.1</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">targetNum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> targetNum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h3><a id="102__54"></a>10.2 初识泛型算法</h3> 
<h4><a id="1021__56"></a>10.2.1 只读算法</h4> 
<p>只会读取其输入范围内的元素，而从不改变元素。</p> 
<h5><a id="accumulate_62"></a>accumulate</h5> 
<pre><code class="prism language-c++">int sum = accumulate(vec.cbegin(), vec.cend(), 0);  //第三个参数为求和初值
</code></pre> 
<blockquote> 
 <p>accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型</p> 
</blockquote> 
<pre><code class="prism language-c++">//元素拼接
string num =accumulate(v.cbegin(), v.cend(), string("")); 

string num =accumulate(v.cbegin(), v.cend(), "");   //错误：const char*上没有定义+运算符 
</code></pre> 
<h5><a id="equal_79"></a>equal</h5> 
<p>判断两个序列是否保存相同的值</p> 
<p>接收三个迭代器参数：前两个参数表示第一个序列的范围，第三个参数表示第二个序列的首元素</p> 
<pre><code class="prism language-c++">equal(v1.cbegin(), v1.cend(), v2.cbegin());
</code></pre> 
<p>基于一个假设：第二个序列至少与第一个序列一样长</p> 
<p><strong>小节练习</strong></p> 
<p>10.3</p> 
<pre><code class="prism language-c++">int sum = (v.cbegin(), v.cend(), 0);
</code></pre> 
<p>10.4</p> 
<p>存在类型转换，损失精度</p> 
<p>10.5</p> 
<p>可以比较两个string对象，但比较两个c风格字符串时，实际比较的是指针而非字符串本身。书109页</p> 
<h4><a id="1022__111"></a>10.2.2 写容器元素的算法</h4> 
<p>一些算法将新值赋予序列中的元素</p> 
<h5><a id="fill_117"></a>fill</h5> 
<pre><code class="prism language-c++">fill(vec.begin(), vec.end(), 0);                //将每个元素重置为0
fill(vec.begin(), vec.begin()+vec.size()/2, 10) //一部分置为10
</code></pre> 
<h5><a id="fill_n_126"></a>fill_n</h5> 
<p>接受一个单迭代器，一个计数器，一个值</p> 
<pre><code class="prism language-c++">fill_n(dest, n, val);  //迭代器dest开始的n个数 置为val
</code></pre> 
<p>作用：从迭代器开始的n个数赋值</p> 
<pre><code class="prism language-c++">vector&lt;int&gt; vec; //空vector
fill_n(vec.begin(), vec.size(), 0);   //所有元素置0
</code></pre> 
<h5><a id="back_inserter_143"></a>back_inserter</h5> 
<pre><code class="prism language-c++">vector&lt;int&gt; vec;
auto it = back_inserter(vec);
*it = 42;   //vec中现在有一个元素，值为42
</code></pre> 
<pre><code class="prism language-c++">vector&lt;int&gt; vec;
fill_n(back_inserter(vec), 10, 0);  //vec中添加10个0
</code></pre> 
<h5><a id="copy_160"></a>copy</h5> 
<p>接受三个迭代器，前两个表示输入范围，第三个表示目的序列的起始位置</p> 
<pre><code class="prism language-c++">int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];  //大小一样
//ret指向拷贝到a2的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2);   //a1赋值给a2
</code></pre> 
<h5><a id="replace_173"></a>replace</h5> 
<pre><code class="prism language-c++">replace(lst.begin(), lst.end(), 0, 42);  //lst中所有0替换成42
</code></pre> 
<h5><a id="replace_copy_181"></a>replace_copy</h5> 
<p>如果需要原序列保持不变，生成新的序列</p> 
<pre><code class="prism language-c++">replace_copy(lst.cbegin(), lst.cend(), back_inserter(newLst), 0, 42);
</code></pre> 
<p>lst保持不变，newLst发生为lst的拷贝，不过所有的0改为42</p> 
<h4><a id="1023___195"></a>10.2.3 重排容器元素的算法</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">elimDups</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> end_unqiue <span class="token operator">=</span> <span class="token function">unique</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//返回迭代器</span>
    words<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>end_unique<span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//传入待删除的起始和终止迭代器</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>排序前：</p> 
<p><img src="https://images2.imgbox.com/fd/b2/Z0kv83hh_o.png" alt="image-20220221195359702"></p> 
<p>排序后：</p> 
<p><img src="https://images2.imgbox.com/08/1b/G65lB8BM_o.png" alt="image-20220221195430248"></p> 
<p>使用unique：</p> 
<p><img src="https://images2.imgbox.com/2f/30/wpTa74yA_o.png" alt="image-20220221195454669"></p> 
<br> 
<br> 
<h3><a id="103__223"></a>10.3 定制操作</h3> 
<h4><a id="1031__225"></a>10.3.1 向算法传递函数</h4> 
<p>一元谓词：接受一个参数</p> 
<p>二元谓词：接受两个参数</p> 
<p>排序算法：</p> 
<ul><li><strong>sort</strong></li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">isShorter</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">//二元谓词</span>
    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//按照长度：短-&gt;长</span>
<span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> isShorter<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li><strong>stable_sort</strong></li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">//按长度重新排序，长度相同的单词维持字典序</span>
<span class="token function">stable_sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> isShorter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> s <span class="token operator">:</span> words<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">//无拷贝字符串</span>
    cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token comment">//打印，以空格分割</span>
<span class="token punctuation">}</span>
cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> 
<p>练习10.12</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">compareIsbn</span><span class="token punctuation">(</span>Sales_item data1<span class="token punctuation">,</span>Sales_item data2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> data1<span class="token punctuation">.</span>isbn <span class="token operator">&lt;</span> data2<span class="token punctuation">.</span>isbn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	vector<span class="token operator">&lt;</span>Sales_item<span class="token operator">&gt;</span> vec<span class="token punctuation">{<!-- --></span> <span class="token function">Sales_item</span><span class="token punctuation">(</span><span class="token string">"623"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Sales_item</span><span class="token punctuation">(</span><span class="token string">"524"</span><span class="token punctuation">)</span> <span class="token punctuation">,</span><span class="token function">Sales_item</span><span class="token punctuation">(</span><span class="token string">"185"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Sales_item</span><span class="token punctuation">(</span><span class="token string">"126"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token function">Sales_item</span><span class="token punctuation">(</span><span class="token string">"332"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Sales_item</span><span class="token punctuation">(</span><span class="token string">"456"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Sales_item</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Sales_item</span><span class="token punctuation">(</span><span class="token string">"753"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	
    std<span class="token operator">::</span><span class="token function">stable_sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> compareIsbn<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i <span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">.</span>isbn <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
	
    <span class="token punctuation">}</span>
	<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="1032_lambda_285"></a>10.3.2 lambda表达式</h4> 
<pre><code class="prism language-cpp"><span class="token punctuation">[</span>capture list<span class="token punctuation">]</span> <span class="token punctuation">(</span>parameter list<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">return</span> type <span class="token punctuation">{<!-- --></span>function body<span class="token punctuation">}</span>
</code></pre> 
<ul><li>capture list：是一个lambda所在函数中定义的局部变量的列表，通常为空</li><li>return type：返回类型</li><li>parameter：参数列表</li><li>function body：函数体</li></ul> 
<p>可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">//不接受参数，返回42</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      <span class="token comment">//输出42</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token function">stable_sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
           <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
           <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token punctuation">[</span>sz<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> s2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//使用局部变量sz</span>
</code></pre> 
<p><br><br></p> 
<h3><a id="104__325"></a>10.4 再探迭代器</h3> 
<ul><li><strong>插入迭代器</strong>：这些迭代器被绑定到一个容器上，可用来向容器插入元素</li><li><strong>流迭代器</strong>：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流</li><li><strong>反向迭代器</strong>：这些迭代器向后而不是向前移动。除了forword_list之外的标准库容器都有反向迭代器</li><li><strong>移动迭代器</strong>：这些专用的迭代器不是拷贝其中的元素，而是移动它们</li></ul> 
<h4><a id="1041__334"></a>10.4.1 插入迭代器</h4> 
<p><img src="https://images2.imgbox.com/99/87/rdfe8qvL_o.png" alt="image-20220222103927686"></p> 
<p>插入迭代器有三种：</p> 
<ol><li><strong>back_inserter</strong>：创建一个使用push_back的迭代器</li><li><strong>front_inserter</strong>：创建一个使用push_front的迭代器</li><li><strong>inserter</strong>：创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。</li></ol> 
<pre><code class="prism language-cpp">list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lst <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lst2<span class="token punctuation">,</span> lst3<span class="token punctuation">;</span>  <span class="token comment">//空lst</span>
<span class="token function">copy</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lst<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">front_inserter</span><span class="token punctuation">(</span>lst2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//lst2={4,3,2,1}</span>
<span class="token function">copy</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lst<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">inserter</span><span class="token punctuation">(</span>lst3<span class="token punctuation">,</span> lst3<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//lst3={1,2,3,4}</span>
</code></pre> 
<p>练习10.27</p> 
<pre><code class="prism language-cpp"><span class="token function">unqiue_copy</span><span class="token punctuation">(</span>vec1<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="1042_iostream_363"></a>10.4.2 iostream迭代器</h4> 
<ul><li>istream_iterator：读取输入流</li><li>ostream_iterator：向一个输出流写数据</li></ul> 
<h4><a id="1043__372"></a>10.4.3 反向迭代器</h4> 
<ul><li> <p>递增一个反向迭代器（++it）会移动到前一个元素</p> </li><li> <p>递减一个反向迭代器（–it）会移动到下一个元素</p> </li><li> <p>除forword_list之外，其他容器都支持反向迭代器</p> </li></ul> 
<p><img src="https://images2.imgbox.com/94/41/UT8yfSQz_o.png" alt="image-20220222105308771"></p> 
<p><img src="https://images2.imgbox.com/f1/09/0WxOvAvy_o.png" alt="image-20220222105344928"></p> 
<pre><code class="prism language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//正序</span>
<span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//反序</span>
</code></pre> 
<p><br><br></p> 
<h3><a id="105__399"></a>10.5 泛型算法结构</h3> 
<p><img src="https://images2.imgbox.com/39/3f/hKObSRe3_o.png" alt="image-20220222105641462"></p> 
<h4><a id="1051_5_403"></a>10.5.1 5类迭代器</h4> 
<h4><a id="1052__409"></a>10.5.2 算法形参模式</h4> 
<p>大多数算法具有如下4种形式之一：</p> 
<pre><code>alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
</code></pre> 
<ul><li>alg：算法名字</li><li>dest：表示算法可以写入的目的位置的迭代器</li><li>other args：额外的、非迭代器的特定参数</li></ul> 
<h4><a id="1053__426"></a>10.5.3 算法命名规范</h4> 
<p><img src="https://images2.imgbox.com/c7/39/CHUMhZvk_o.png" alt="image-20220222110156447"></p> 
<p><img src="https://images2.imgbox.com/eb/38/9cKb7pqz_o.png" alt="image-20220222110203826"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f813ddae1e1aa716735aebaf78f0871a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">寻找两个正序数组的中位数(python)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d144ac9961bfcc38a555bfa4fe2307c2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JAVA8 lambda表达式中Collectors.toMap()方法/List转Map</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>