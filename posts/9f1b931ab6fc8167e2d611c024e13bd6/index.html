<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>评分卡模型的思想和数理推导 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="评分卡模型的思想和数理推导" />
<meta property="og:description" content="目录
前言
一、数据准备
二、特征工程
2.1 WOE和IV公式
2.2 WOE实例：
2.3 WOE的意义及单调性
2.4 特征选择
三、数据建模
四、模型评估
五、生成评分卡
本文主要介绍评分卡模型的概念及背后的思想体系，模型如何创建，以及在创建模型过程中遇到的问题和思考。
前言 为什么要做评分卡模型？
《巴赛尔协议》中明确对银行的系统性风险进行定义和划分，主要分为：信用风险、市场风险、操作风险、流动性风险、国家风险、声誉风险、法律风险、合规风险、战略风险。其中信用风险指授信方拒绝或无力按时、全额支付所欠债务时，给信用方带来的损失。
银行、消费金融等各种贷款机构，为了控制信用风险，期望通过客户历史的行为信息判断客户违约的可能性，由此决定是否授信以及授信的额度，从而减少在金融交易中存在的风险。评分卡模型在这种大背景下应运而生。
评分卡分为ABC卡三类：
A卡（Application score card）申请评分卡
B卡（Behavior score card）行为评分卡
C卡（Collection score card）催收评分卡
评分机制的区别在于：
1.使用的时间不同。分别侧重贷前、贷中、贷后；
2.数据要求不同。A卡一般可做贷款0-1年的信用分析，B卡则是在申请人有了一定行为后，有了较大数据进行的分析，一般为3-5年，C卡则对数据要求更大，需加入催收后客户反应等属性数据。
3.每种评分卡的模型会不一样。在A卡中常用的有逻辑回归，AHP等，而在后面两种卡中，常使用多因素逻辑回归，精度等方面更好。
除此之外，评分卡模型还适用于其他关于信用风险行为识别，如芝麻信用分、它可以提高花呗的额度，可以消费贷，可以不缴押金直接租车等。
信用评分模型是将模型变量WOE编码方式离散化之后运用logistic回归模型进行的一种二分类变量的广义线性模型。利用信用评分模型得到的客户信用评分，可作为是否准予授信或为授信额度和利率提供参考。接下来介绍如何创建评分卡及遇到的问题。
一、数据准备 因为不同评级模型所需要的数据也是不同的，所以在开发信用评级模型之前，要先明确我们需要解决的问题。
1.1 排除一些特定的建模客户
用于建模的客户或者申请者必须是日常审批过程中接触到的，需要排除异常情况。如 欺诈，特殊客户。
1.2 明确客户属性
根据不同的数据来源，可以分为以下几类：
人口统计特征：客户的基本特征，如性别，年龄、居住情况、年收入等征信机构数据和外部评分:如人行征信报告、芝麻分等。其他数据来源。 1.3 目标变量的确立
预测模型的一个基本原理是用历史数据来预测未来，申请者评分模型需要解决的问题是未来一段时间（如12个月）客户出现违约（如至少一次90天或90天以上逾期）的概率。先将客户标签定义为二分类，不良/逾期：观察窗口内，观察窗口内，60/90/120天算逾期日期；良好:从未或截止逾期；从未或在观察期内截止逾期
其中关于不良/逾期需要界定以下两项内容：确定违约日期时长、观察窗口期设置。
定违约日期时长，违约时长的确定可以使用逾期转移矩阵来确定，也可以按客户规则确定：
通过上图可以看出来，M3客户变坏的概率为93%.也就是说当客户逾期超过60天后，被催回的几率为7%。因此，可以定义逾期超过60天的客户为坏客户。
二、特征工程 数据准备和数据预处理阶段消耗大量的时间，主要的工作包括数据获取、探索性数据分析、缺失值处理、数据校准、数据抽样、数据转换、离散变量降维、连续变量优先分段等工作。
在评分卡模型中特别要做的是变量分箱和自变量WOE编码。
变量分箱主要指的是连续型变量化为离散型变量，为WOE编码做准备。这样做会有信息损失，但相比信息损失，过拟合带来的影响更大。
2.1 WOE和IV公式 Q1：什么是IV和WOE编码？
WOE全称是Weight of Evidence，即证据权重，也叫作自变量的一种编码。
IV全称是Information value，可通过woe加权求和得到，衡量自变量对因变量的预测能力。
要对一个变量进行WOE编码，需要首先把这个变量进行分组处理（也叫离散化、分箱等等，说的都是一个意思）。分组后，对于第i组，WOE的计算公式如下：
其中，pyi是这个组中响应客户（风险模型中，对应的是违约客户，总之，指的是模型中预测变量取值为“是”或者说1的个体）占所有样本中所有响应客户的比例，pni是这个组中未响应客户占样本中所有未响应客户的比例，#yi是这个组中响应客户的数量，#ni是这个组中未响应客户的数量，#yT是样本中所有响应客户的数量，#nT是样本中所有未响应客户的数量。
从这个公式中我们可以体会到，WOE表示的实际上是“当前分组中响应客户占所有响应客户的比例”和“当前分组中没有响应的客户占所有没有响应的客户的比例”的差异。
对这个公式做一个简单变换，可以得到：
变换以后我们可以看出，WOE也可以这么理解，他表示的是当前这个组中响应的客户和未响应客户的比值，和所有样本中这个比值的差异。这个差异是用这两个比值的比值，再取对数来表示的。WOE越大，这种差异越大，这个分组里的样本响应的可能性就越大，WOE越小，差异越小，这个分组里的样本响应的可能性就越小。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9f1b931ab6fc8167e2d611c024e13bd6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-24T16:58:37+08:00" />
<meta property="article:modified_time" content="2020-03-24T16:58:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">评分卡模型的思想和数理推导</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87" rel="nofollow">一、数据准备</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B" rel="nofollow">二、特征工程</a></p> 
<p id="2.1%20WOE%E5%92%8CIV%E5%85%AC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2.1%20WOE%E5%92%8CIV%E5%85%AC%E5%BC%8F" rel="nofollow">2.1 WOE和IV公式</a></p> 
<p id="2.2%20WOE%E5%AE%9E%E4%BE%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.2%20WOE%E5%AE%9E%E4%BE%8B%EF%BC%9A" rel="nofollow">2.2 WOE实例：</a></p> 
<p id="2.3%20WOE%E7%9A%84%E6%84%8F%E4%B9%89%E5%8F%8A%E5%8D%95%E8%B0%83%E6%80%A7-toc" style="margin-left:40px;"><a href="#2.3%20WOE%E7%9A%84%E6%84%8F%E4%B9%89%E5%8F%8A%E5%8D%95%E8%B0%83%E6%80%A7" rel="nofollow">2.3 WOE的意义及单调性</a></p> 
<p id="2.4%20%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9-toc" style="margin-left:40px;"><a href="#2.4%20%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9" rel="nofollow">2.4 特征选择</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1" rel="nofollow">三、数据建模</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0" rel="nofollow">四、模型评估</a></p> 
<p id="%E4%BA%94%E3%80%81%E7%94%9F%E6%88%90%E8%AF%84%E5%88%86%E5%8D%A1-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E7%94%9F%E6%88%90%E8%AF%84%E5%88%86%E5%8D%A1" rel="nofollow">五、生成评分卡</a></p> 
<hr id="hr-toc"> 
<p style="margin-left:0in;"><span style="color:#000000;">本文主要介绍评分卡模型的概念及背后的思想体系，模型如何创建，以及在创建模型过程中遇到的问题和思考。</span></p> 
<h2 id="%E5%89%8D%E8%A8%80" style="margin-left:0in;">前言</h2> 
<p>为什么要做评分卡模型？</p> 
<p>《巴赛尔协议》中明确对银行的系统性风险进行定义和划分，主要分为：信用风险、市场风险、操作风险、流动性风险、国家风险、声誉风险、法律风险、合规风险、战略风险。其中信用风险指授信方拒绝或无力按时、全额支付所欠债务时，给信用方带来的损失。</p> 
<p>银行、消费金融等各种贷款机构，为了控制信用风险，期望通过客户历史的行为信息判断客户违约的可能性，由此决定是否授信以及授信的额度，从而减少在金融交易中存在的风险。评分卡模型在这种大背景下应运而生。</p> 
<p>评分卡分为ABC卡三类：</p> 
<p><strong>A卡（Application score card）申请评分卡</strong></p> 
<p><strong>B卡（Behavior score card）行为评分卡</strong></p> 
<p><strong>C卡（Collection score card）催收评分卡</strong></p> 
<p>评分机制的区别在于：</p> 
<p>1.使用的时间不同。分别侧重贷前、贷中、贷后；</p> 
<p>2.数据要求不同。A卡一般可做贷款0-1年的信用分析，B卡则是在申请人有了一定行为后，有了较大数据进行的分析，一般为3-5年，C卡则对数据要求更大，需加入催收后客户反应等属性数据。</p> 
<p>3.每种评分卡的模型会不一样。在A卡中常用的有逻辑回归，AHP等，而在后面两种卡中，常使用多因素逻辑回归，精度等方面更好。</p> 
<p>除此之外，评分卡模型还适用于其他关于信用风险行为识别，如芝麻信用分、它可以提高花呗的额度，可以消费贷，可以不缴押金直接租车等。</p> 
<p>信用评分模型是将模型变量<span style="color:#3399ea;"><strong>WOE编码</strong></span>方式离散化之后运用<span style="color:#3399ea;"><strong>logistic回归</strong></span>模型进行的一种二分类变量的广义线性模型。利用信用评分模型得到的客户信用评分，可作为是否准予授信或为授信额度和利率提供参考。接下来介绍如何创建评分卡及遇到的问题。</p> 
<h2 id="%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">一、数据准备</h2> 
<p>因为不同评级模型所需要的数据也是不同的，所以在开发信用评级模型之前，要先明确我们需要解决的问题。<br> 1.1 排除一些特定的建模客户<br> 用于建模的客户或者申请者必须是日常审批过程中接触到的，需要排除异常情况。如 欺诈，特殊客户。</p> 
<p>1.2 明确客户属性<br> 根据不同的数据来源，可以分为以下几类：</p> 
<ol><li>人口统计特征：客户的基本特征，如性别，年龄、居住情况、年收入等</li><li>征信机构数据和外部评分:如人行征信报告、芝麻分等。</li><li>其他数据来源。</li></ol> 
<p>1.3 目标变量的确立<br> 预测模型的一个基本原理是用历史数据来预测未来，申请者评分模型需要解决的问题是未来一段时间（如12个月）客户出现违约（如至少一次90天或90天以上逾期）的概率。先将客户标签定义为二分类，不良/逾期：观察窗口内，观察窗口内，60/90/120天算逾期日期；良好:从未或截止逾期；从未或在观察期内截止逾期<br> 其中关于不良/逾期需要界定以下两项内容：确定违约日期时长、观察窗口期设置。</p> 
<p><br> 定违约日期时长，违约时长的确定可以使用逾期转移矩阵来确定，也可以按客户规则确定：<br><img alt="" src="https://images2.imgbox.com/d5/0b/2wylZW7o_o.png"></p> 
<p>通过上图可以看出来，M3客户变坏的概率为93%.也就是说当客户逾期超过60天后，被催回的几率为7%。因此，可以定义逾期超过60天的客户为坏客户。</p> 
<p> </p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B">二、特征工程</h2> 
<p>数据准备和数据预处理阶段消耗大量的时间，主要的工作包括数据获取、探索性数据分析、缺失值处理、数据校准、数据抽样、数据转换、离散变量降维、连续变量优先分段等工作。</p> 
<p><strong>在评分卡模型中特别要做的是变量分箱和自变量WOE编码。</strong></p> 
<p>变量分箱主要指的是连续型变量化为离散型变量，为WOE编码做准备。这样做会有信息损失，但相比信息损失，过拟合带来的影响更大。</p> 
<h3 id="2.1%20WOE%E5%92%8CIV%E5%85%AC%E5%BC%8F">2.1 WOE和IV公式</h3> 
<p><span style="color:#7c79e5;">Q1：什么是IV和WOE编码？</span></p> 
<p>WOE全称是Weight of Evidence，即证据权重，也叫作自变量的一种编码。</p> 
<p>IV全称是Information value，可通过woe加权求和得到，衡量自变量对因变量的预测能力。</p> 
<p>要对一个变量进行WOE编码，需要首先把这个变量进行分组处理（也叫离散化、分箱等等，说的都是一个意思）。分组后，对于第i组，WOE的计算公式如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/4f/fa/dbMhV42d_o.jpg"></p> 
<p>其中，pyi是这个组中响应客户（风险模型中，对应的是违约客户，总之，指的是模型中预测变量取值为“是”或者说1的个体）占所有样本中所有响应客户的比例，pni是这个组中未响应客户占样本中所有未响应客户的比例，#yi是这个组中响应客户的数量，#ni是这个组中未响应客户的数量，#yT是样本中所有响应客户的数量，#nT是样本中所有未响应客户的数量。</p> 
<p>从这个公式中我们可以体会到，WOE表示的实际上是“当前分组中响应客户占所有响应客户的比例”和“当前分组中没有响应的客户占所有没有响应的客户的比例”的差异。</p> 
<p>对这个公式做一个简单变换，可以得到：</p> 
<p><img alt="" src="https://images2.imgbox.com/58/c0/fHR34FP6_o.jpg"></p> 
<p>变换以后我们可以看出，WOE也可以这么理解，他表示的是当前这个组中响应的客户和未响应客户的比值，和所有样本中这个比值的差异。这个差异是用这两个比值的比值，再取对数来表示的。WOE越大，这种差异越大，这个分组里的样本响应的可能性就越大，WOE越小，差异越小，这个分组里的样本响应的可能性就越小。</p> 
<p> </p> 
<p>IV的计算：</p> 
<p>有了前面的介绍，我们可以正式给出IV的计算公式。对于一个分组后的变量，第i 组的WOE前面已经介绍过，是这样计算的：</p> 
<p><img alt="" src="https://images2.imgbox.com/c2/ad/tj5h644d_o.jpg"></p> 
<p>同样，对于分组i，也会有一个对应的IV值，计算公式如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/39/30/yFOUe1fE_o.jpg"></p> 
<p>有了一个变量各分组的IV值，我们就可以计算整个变量的IV值，方法很简单，就是把各分组的IV相加：</p> 
<p><img alt="" src="https://images2.imgbox.com/80/28/35vt11Za_o.jpg"></p> 
<p>其中，n为变量分组个数。</p> 
<p> </p> 
<p> </p> 
<h3 id="2.2%20WOE%E5%AE%9E%E4%BE%8B%EF%BC%9A">2.2 WOE实例：</h3> 
<p>假设我们需要构建一个预测模型，这个模型是为了预测公司的客户集合中的每个客户对于我们的某项营销活动是否能够响应，或者说我们要预测的是客户对我们的这项营销活动响应的可能性有多大。假设我们已经从公司客户列表中随机抽取了100000个客户进行了营销活动测试，收集了这些客户的响应结果，作为我们的建模数据集，其中响应的客户有10000个。另外假设我们也已经提取到了这些客户的一些变量，作为我们模型的候选变量集，这些变量包括以下这些（实际情况中，我们拥有的变量可能比这些多得多，这里列出的变量仅仅是为了说明我们的问题）：</p> 
<p>我们以其中的一个变量“最近一次购买金额”变量为例：</p> 
<p><img alt="" src="https://images2.imgbox.com/66/c8/9IzTohn9_o.jpg"></p> 
<p><img alt="" src="https://images2.imgbox.com/86/83/oOx4FkuX_o.jpg"></p> 
<p>我们把这个变量离散化为了4个分段：&lt;100元，[100,200)，[200,500)，&gt;=500元。首先，根据WOE计算公式，这四个分段的WOE分别为：</p> 
<p><img alt="" src="https://images2.imgbox.com/47/cf/YsjcJvz5_o.jpg"></p> 
<p>插播一段，从上面的计算结果中我们可以看一下WOE的基本特点：</p> 
<ul><li>当前分组中，响应的比例越大，WOE值越大；（<span style="color:#7c79e5;">为什么会这样？推导在2.3WOE意义及单调性</span>）</li><li>当前分组WOE的正负，由当前分组响应和未响应的比例，与样本整体响应和未响应的比例的大小关系决定，当前分组的比例小于样本整体比例时，WOE为负，当前分组的比例大于整体比例时，WOE为正，当前分组的比例和整体比例相等时，WOE为0。</li><li>WOE的取值范围是全体实数。</li></ul> 
<p>我们进一步理解一下WOE，会发现，WOE其实描述了变量当前这个分组，对判断个体是否会响应（或者说属于哪个类）所起到影响方向和大小，当WOE为正时，变量当前取值对判断个体是否会响应起到的正向的影响，当WOE为负时，起到了负向影响。而WOE值的大小，则是这个影响的大小的体现。</p> 
<p>计算完WOE，我们分别计算四个分组的IV值：</p> 
<p><img alt="" src="https://images2.imgbox.com/bf/18/wkp5ku6S_o.jpg"></p> 
<p>再插播一段，从上面IV的计算结果我们可以看出IV的以下特点：</p> 
<ul><li>对于变量的一个分组，这个分组的响应和未响应的比例与样本整体响应和未响应的比例相差越大，IV值越大，否则，IV值越小；</li><li>极端情况下，当前分组的响应和未响应的比例和样本整体的响应和未响应的比例相等时，IV值为0；</li><li>IV值的取值范围是[0,+∞)，且，当当前分组中只包含响应客户或者未响应客户时，IV = +∞。</li></ul> 
<p> </p> 
<p>OK，再次回到正题。最后，我们计算变量总IV值：</p> 
<p><img alt="" src="https://images2.imgbox.com/70/12/7m5Yc8b7_o.jpg"></p> 
<p> </p> 
<p>假设我们已经计算过四个变量WOE和IV值：</p> 
<p>最近一个月是否有过购买：0.250224725</p> 
<p>最近一笔购买的商品类别：0.615275563</p> 
<p>是否是公司VIP客户：1.56550367</p> 
<p>最近一次购买金额的IV为0.49270645</p> 
<p>这四个变量IV排序结果是这样的：是否是公司VIP客户 &gt; 最近一笔购买的商品类别 &gt; 最近一次购买金额 &gt; 最近一个月是否有过购买。我们发现“是否是公司VIP客户”是预测能力最高的变量，“最近一个月是否有过购买”是预测能力最低的变量。如果我们需要在这四个变量中去挑选变量，就可以根据IV从高到低去挑选了。</p> 
<p> </p> 
<p>若只考虑模型实现，请直接跳到 三、模型训练；</p> 
<p>（<span style="color:#7c79e5;">思考：还可以用其他挑选变量的方法吗？==可以，详见2.4特征选择</span>）</p> 
<p> </p> 
<h3 id="2.3%20WOE%E7%9A%84%E6%84%8F%E4%B9%89%E5%8F%8A%E5%8D%95%E8%B0%83%E6%80%A7">2.3 WOE的意义及单调性</h3> 
<p>计算woe（以及IV）的意义我所知的有以下几点：</p> 
<ul><li>IV值可以衡量各变量对y的预测能力，用于筛选变量。</li><li>对离散型变量，woe可以观察各个level间的跳转对<span style="color:#3399ea;">odds的提升</span>，而IV可以衡量变量整体（而不是每个level）的预测能力。</li><li>对连续型变量，woe和IV值为分箱的合理性提供了一定的依据。分箱处理连续型变量会有信息损失，但由于绝大多数情况下<span style="color:#3399ea;"><strong>连续型变量对odds的提升都不是线性</strong></span>的，这里能产生的负面影响远比信息损失要大，因此<span style="color:#f33b45;">一般都需要做分箱处理，然后做WOE编码</span>。</li></ul> 
<p><span style="color:#7c79e5;">Q2：为什么怎么理解WOE单调性？</span></p> 
<p>WOE单调性是指随着WOE值的增加（减小），优势比也越大（越小），对应事件响应的概率越大（越小）；</p> 
<p>在证明之前先介绍Odds Ratio（优势比）：</p> 
<p>首先要知道<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Odds" rel="nofollow">Odds</a>（优势），指的是事件发生和不发生的比例，即：</p> 
<p><img alt="" height="89" src="https://images2.imgbox.com/cf/f0/ZkRU49nS_o.png" width="199"></p> 
<p>下面我们设定这个事件响应即取值为1，即Y=1。那么 Age=Age1时的Odds为：</p> 
<p><img alt="" height="105" src="https://images2.imgbox.com/7f/a4/k0WViSRp_o.png" width="417"></p> 
<p>而Odds Ratio则是两组odds的比值，比如Age1和Age2之间的Odds Ratio为：</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/45/a3/Ta1z8KHK_o.png" width="721"></p> 
<p>介绍了优势比的概念之后，再来证明WOE的单调性：</p> 
<p>为了研究它的单调性是什么，我尝试着将WOE做差，发现得到的结果跟Odds Ratio的形式很像</p> 
<p><img alt="" height="595" src="https://images2.imgbox.com/f7/cf/ITyRef3Z_o.png" width="809"></p> 
<p><img alt="" height="901" src="https://images2.imgbox.com/d1/54/PqGYBz1M_o.png" width="965"></p> 
<p> </p> 
<p><span style="color:#7c79e5;">Q3：怎么理解</span><span style="color:#3399ea;"><strong>连续型变量对odds的提升都不是线性，</strong></span><span style="color:#7c79e5;">需要做WOE编码？</span></p> 
<p>先来看为什么WOE可以对odds的影响是线性的（这里也是为什么WOE编码用到logidtic回归的原因），就可以理解为什么连续型变量对odds的提升不是线性的。</p> 
<p>逻辑回归的本质是多元线性回归，但线性回归输出的是实数域，无法做分类处理，所以引用了sigmod函数，将实数域上的值映射到（0,1）区间。</p> 
<p>sigmod函数,函数如下：</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/6e/40/4DcQ4ths_o.png" width="315"></p> 
<p>对函数进行变形就得到logistic回归的另一种表达方式：</p> 
<p><img alt="" height="90" src="https://images2.imgbox.com/e3/7f/47K5GE7y_o.png" width="433"></p> 
<p>logistic公式的左边和odds很像，接下来说明为什么WOE对odds的提升是线性的：</p> 
<p><img alt="" height="710" src="https://images2.imgbox.com/a4/05/1AjAXtGR_o.png" width="849"></p> 
<p>由此可知，WOE对odds的影响是线性的，同理可知，连续型变量不具有此特征。</p> 
<p> </p> 
<p><span style="color:#7c79e5;">Q4：为什么进行WOE编码，能否选择其他编码方式？</span></p> 
<p>WOE编码只是对变量的一种编码方式，将字符型的离散型变量变为入模变量，除了WOE编码方式还有one_hot,dumpy等编码方式。之所以提起评分卡模型大家都联想到WOE编码考虑出于以下原因：</p> 
<ul><li>由于woe和logistic的特性决定的，两者的定义完美契合</li><li>业务好解释，因为WOE编码后，可以计算出每个水平下的评分值，便于数据解释</li><li>实验效果也比较好，经验使得模型的效果比较好</li></ul> 
<p>当然评分卡模型也可以，采用其他编码方式，也可以选择其他模型，只不过需要判断所在的场景，以及约束条件。</p> 
<p>例如：当变量维度很多，出现像地址这类变量时，不适合用one_hot和dumpy编码，会造成维度爆炸。</p> 
<p>变量值少并且业务不需要解释的情况下，可以进行one_hot和dumpy编码。</p> 
<p>其他编码方法参考：<a href="https://blog.csdn.net/zhenteliu/article/details/103002872">https://blog.csdn.net/zhenteliu/article/details/103002872</a></p> 
<p>同理，对于IV也是类似，IV的作用的选出对因变量影响大的变量，除了IV也可以用主成分分析、VIF（方差膨胀因子）、线性相关等方式选择变量。</p> 
<p>综上，不管是WOE还IV都是变量处理和变量选择的一种方式，只是这种方式在评分卡模型中更匹配，但不是这个模型专用。同理，评分卡模型也不是必须WOE和IV才能得到，到后面你会发现，评分卡归根结底是预测客户响应概率，和其他预测概率的模型一样，只不过大家习惯用解释性较高的引入WOE和IV的logistic模型。</p> 
<p>WOE还可以用到树模型中。</p> 
<p> </p> 
<p><span style="color:#7c79e5;">Q5：怎么控制分箱的标准，有哪些分箱方法？</span></p> 
<p>对连续型变量分箱的结果会影响WOE，继而影响变量的预测能力，变量分箱的标准是选择合理的分箱能体现变量对因变量的预测能力。</p> 
<p>连续变量的分段方法通常分为等距分箱、等频分箱、最优分箱。等距分段是指将连续变量分为等距离的若干区间。最优分段是指根据变量的分布属性，并结合该变量对违约状态变量预测能力的变化，按照一定的规则将属性接近的数值聚在一起，形成距离不相等的若干区间，最终得到对违约状态变量预测能力最强的最优分段。<br><strong>等距分箱 </strong>：<br> 　　      从min到max之间,均分为 N 等份, 这样, 如果 A,B 为最小最大值, 则每个区间的长度为 W=(B−A)/N , 区间边界值为A+W,A+2W,….A+(N−1)W 。这里只考虑边界，每个等份里面的实例数量可能不等。 <br><strong>等频分箱 :</strong><br> 　　        区间的边界值要经过选择,使得每个区间包含大致相等的实例数量。比如说 N=10 ,每个区间应该包含大约10%的实例。 <br><strong>最优分箱：</strong><br>       根据变量的分布属性，并结合该变量对违约状态变量预测能力的变化，按照一定的规则将属性接近的数值聚在一起，形成距离不相等的若干区间，最终得到对违约状态变量预测能力最强的最优分段。<br>  </p> 
<p>如果我们使用等频或者等距的分箱模式，过拟合概率将会大大降低。众所周知，分布不合理的情况下用等距会导致过拟合，分箱过多的时候会导致过拟合，这个都可以避免。但是这两种分箱模式都有缺点，等距受分布影响，等频对离散值不友好。分箱多过拟合，分箱少太稀疏，所以现在很多分箱的算法都会引入目标变量，通过计算互信息等方式来指导分箱。看上去用了目标变量，但是其实这个和集成学习的思想是一致的。所谓集成学习就是把第一层多模型的结果做为第二层模型的输入，两层模型都是以目标变量为目标的。只不过这里第一层模型很简单，只是一个分箱而已。</p> 
<p>其他变量分箱方法：</p> 
<p><img alt="" src="https://images2.imgbox.com/8e/4f/I9HW6dhe_o.png"></p> 
<p><strong>卡方分箱（ChiMerge）：</strong></p> 
<p>自底向上的(即基于合并的)数据离散化方法。它依赖于卡方检验:具有最小卡方值的相邻区间合并在一起,直到满足确定的停止准则。</p> 
<p>基本思想:对于精确的离散化，相对类频率在一个区间内应当完全一致。因此,如果两个相邻的区间具有非常类似的类分布，则这两个区间可以合并；否则，它们应当保持分开。而低卡方值表明它们具有相似的类分布。</p> 
<p>详细的分箱算法如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/75/63/egirB2al_o.png"></p> 
<h3 id="2.4%20%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9">2.4 特征选择</h3> 
<p>按照计算出来的IV选择变量，并对变量进行WOE转换。</p> 
<p>经验法则：</p> 
<p><img alt="" height="239" src="https://images2.imgbox.com/c9/e9/zklNPyRW_o.png" width="747"></p> 
<p>WOE转换其实很简单，就是对筛选出来并且已经完成分组的变量，使用计算出来的每组的WOE值替换变量取值。<br> 需要注意的是，对于不同的变量类型有点不同的要求。对于类别型变量，因为类别型变量之间不存在任何序列关系，所以不同类型的WOE值可以任意排序。然而，对于连续变量，WOE值必须按照分组的自然序列排序，以保持连续原始变量中所包含的顺序关系。<strong>IV属于过滤法</strong></p> 
<p> </p> 
<p><strong>其他特征选择方法：</strong></p> 
<p>特征选择的标准是该特征与目标的相关性，与目标相关性高的特征，应当优选择。按照选择形式可以将特征选择的方法分为三种：</p> 
<ul><li><strong>过滤法</strong>，按照相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。</li><li><strong>包装法</strong>，根据目标函数（通常是预测效果评分），每次选择若干特征，或者排除若干特征。</li><li><strong>嵌入法</strong>，先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。类似于Filter方法，但是是通过训练来确定特征的优劣。</li></ul> 
<p>除此之外，还有一个需要处理的是共线性问题。</p> 
<p><strong> Filter：卡方统计量</strong></p> 
<p>卡方检验常用于两个变量之间的显著性检验，假定fo、fe分别为观察频数和期望频数，则卡方统计量的计算公式为：</p> 
<p><img alt="" height="91" src="https://images2.imgbox.com/46/fe/ZzeqAFkJ_o.png" width="271"></p> 
<p>当我们计算了所有变量的卡方统计量后，可以用p值来筛选变量，也可以用衍生的V相关系数来筛选：</p> 
<p><img alt="" height="97" src="https://images2.imgbox.com/73/58/Fimi1p4F_o.png" width="380"></p> 
<p>其中R代表列联表的行数，C代表列联表的列数。</p> 
<p> </p> 
<p><strong>Wrapper：递归特征消除法</strong></p> 
<p>递归消除特征法使用一个基模型来进行多轮训练，每轮训练后，消除若干权值系数的特征，再基于新的特征集进行下一轮训练。使用feature_selection库的RFE类来选择特征的代码如下：</p> 
<pre><code class="language-python">from sklearn.feature_selection import RFE
from sklearn.linear_model import LogisticRegression
rfe=RFE(estimator=LogisticRegression(),n_features_to_select=2)
rfe.fit_transform(X, y)</code></pre> 
<p> </p> 
<p><strong>Embedded: 基于分类模型的特征选择法</strong></p> 
<p>使用基模型，除了筛选出特征外，同时也进行了降维。这里我们用sklearn中的SelectFromModel来完成。</p> 
<pre><code class="language-python">from sklearn.feature_selection import SelectFromModel
from sklearn.linear_model import LogisticRegression

#带L1惩罚项的逻辑回归作为基模型的特征选择
sf=SelectFromModel(LogisticRegression(penalty="l1",C=0.1))
sf.fit_transform(X, y)

#树模型中GBDT也可用来作为基模型进行特征选择，
from sklearn.ensemble import GradientBoostingClassifier
sf=SelectFromModel(GradientBoostingClassifier())
sf.fit_transform(X,y)</code></pre> 
<p><strong>共线性问题</strong></p> 
<p> </p> 
<h2 id="%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1">三、数据建模</h2> 
<p>将原始指标用WOE进行替换后，用logistic回归估计参数，并剔除参数估计为负的变量。因为出现负值意味着有共线性的变量存在。</p> 
<p>信用评分卡模型所依赖的Logistic回归算法。何为“回归”呢？当有一些数据点，用一条直线对这些点进行拟合（该直线称为最佳拟合直线），这个拟合过程就叫回归。那么，利用Logistic回归进行分类的主要思想就是根据现有数据对分类边界线建立回归公式，以此进行分类。“回归”源于最佳拟合，即使用最优化算法，找到最佳拟合参数集。</p> 
<ul><li>Logistic回归的实现：对于输入特征，每个特征乘以一个回归系数，将所有结果值相加带入Sigmoid函数中，从而得到一个0~1之间的数值，根据实际情况设定相关阈值，从而达到预测的目的。</li><li>最优化算法：如何找到最优回归系数，是Logistic回归的关键问题。</li></ul> 
<p>机器学习中常用的最优化算法有：梯度下降法（GradientDescent）、牛顿法和拟牛顿法（Newton's method &amp; Quasi-NewtonMethods）、共轭梯度法（Conjugate Gradient）等等，接下来简单介绍梯度下降法。</p> 
<ul><li>梯度下降法（Gradient Descent）：梯度下降即沿着某函数的梯度方向，找到该函数的最小值，如果梯度记为▽，则函数f(x,y)的梯度为:</li></ul> 
<p><img alt="" src="https://images2.imgbox.com/e3/7d/m0NRMWHH_o.png" width="148"></p> 
<p>则梯度下降算法的迭代公式为：</p> 
<p><img alt="" src="https://images2.imgbox.com/ba/f7/LVhrOdNA_o.png" width="335"></p> 
<p><strong>人工干预，</strong>根据指标的业务意义、上下限、人数占比、违约比例调整分箱规则，即业务干预。<br><strong>WOE更新，</strong>人工干预后，得到新的分箱，根据新分箱，更新WOE。</p> 
<p><strong>模型更新，</strong>更新完WOE之后，利用新的WOE值估计回归参数。</p> 
<p>逻辑回归模型有天然的特性：</p> 
<p><img alt="" height="573" src="https://images2.imgbox.com/5b/86/QQIqQnI1_o.png" width="728"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<h2 id="%E5%9B%9B%E3%80%81%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0">四、模型评估</h2> 
<p>通常一个二值分类器可以通过ROC（Receiver Operating Characteristic）曲线和AUC值来评价优劣。</p> 
<p>很多二元分类器会产生一个概率预测值，而非仅仅是0-1预测值。我们可以使用某个临界点（例如0.5），以划分哪些预测为1，哪些预测为0。得到二元预测值后，可以构建一个混淆矩阵来评价二元分类器的预测效果。所有的训练数据都会落入这个矩阵中，而主对角线上的数字代表了预测正确的数目，即true positive + true nagetive。同时可以相应算出TPR（真正率或称为灵敏度）和TNR（真负率或称为特异度）。我们主观上希望这两个指标越大越好，但可惜二者是一个此消彼涨的关系。除了分类器的训练参数，临界点的选择，也会大大的影响TPR和TNR。有时可以根据具体问题和需要，来选择具体的临界点。</p> 
<p>如果我们选择一系列的临界点，就会得到一系列的TPR和TNR，将这些值对应的点连接起来，就构成了ROC曲线。ROC曲线可以帮助我们清楚的了解到这个分类器的性能表现，还能方便比较不同分类器的性能。在绘制ROC曲线的时候，习惯上是使用1-TNR作为横坐标即FPR（false positive rate），TPR作为纵坐标。这是就形成了ROC曲线。</p> 
<p>而AUC（Area Under Curve）被定义为ROC曲线下的面积，显然这个面积的数值不会大于1。又由于ROC曲线一般都处于y=x这条直线的上方，所以AUC的取值范围在0.5和1之间。使用AUC值作为评价标准是因为很多时候ROC曲线并不能清晰的说明哪个分类器的效果更好，而作为一个数值，对应AUC更大的分类器效果更好。ROC曲线反映了分类器的分类能力，结合考虑了分类器输出概率的准确性，AUC量化了ROC曲线的分类能力，越大分类效果越好，输出概率越合理。</p> 
<p><img alt="" src="https://images2.imgbox.com/c5/9d/NGAMEpQe_o.png"></p> 
<p> </p> 
<p>K-S统计量被应用于信用评级模型主要是为了验证模型对违约对象的区分能力，是表现模型区分能力的验证指标；通常，如果模型的K-S统计量越大，表明模型区分正常客户和违约客户的能力越强。</p> 
<p>其他评估模型标准：<a href="https://www.cnblogs.com/gasongjian/p/8284229.html" rel="nofollow">https://www.cnblogs.com/gasongjian/p/8284229.html</a></p> 
<p> </p> 
<h2 id="%E4%BA%94%E3%80%81%E7%94%9F%E6%88%90%E8%AF%84%E5%88%86%E5%8D%A1">五、生成评分卡</h2> 
<p>根据Logistic回归估计的参数、分箱的WOE来确定每个区间的得分。</p> 
<p>标准评分卡采用的格式是评分卡中的每一个变量都遵循一系列IF-THEN法则，变量的值决定了该变量所分配的分值，总分就是各变量分值的和。</p> 
<p><img alt="" height="98" src="https://images2.imgbox.com/59/32/SjsHAExU_o.png" width="336"></p> 
<p>评分卡设定的分值刻度可以通过将分值表示为比率对数的现行表达式来定义。公式如下：</p> 
<p><img alt="" height="64" src="https://images2.imgbox.com/01/18/3NYzxLpm_o.png" width="335"></p> 
<p>注：违约率p或者响应率越高，分数越大，或者<strong>odds应取倒数</strong>，得分越高违约率越小。</p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/c4/d9/hlKa9Wjh_o.png" width="795"></p> 
<p><img alt="" height="69" src="https://images2.imgbox.com/82/2f/1Km3Bxp6_o.png" width="489"></p> 
<p>这里带入评分卡公式：</p> 
<p><img alt="" height="234" src="https://images2.imgbox.com/eb/d3/91YUYlGm_o.png" width="788"></p> 
<p><br>  </p> 
<p> </p> 
<p>下面的小示例，简单为大家展示评分卡及其计分模式：</p> 
<p><img alt="" height="384" src="https://images2.imgbox.com/bc/ad/YZFOLDxy_o.png" width="400"></p> 
<p>如果该模型的基础分是50分，比如有个客户，大专毕业，男性，拥有自有住房，工作10年以上，那么他的分数就应该是：Score=50+14+9+24+12=109。</p> 
<p>基于Logistic的评分卡给予每个变量的每个分箱一个特定的分数，其目的是对评分卡做出一个合理的解释，例如，如果客户想提高自己的评分，可以通过提高评分卡中的某些指标的值，使之对应的分数提高就可以了。</p> 
<p>当然，还有其它一些算法可以帮助我们构建评分卡，比如：RandomForest， GBDT等。这些算法可以给出客户的违约概率，但是构建的评分卡不能像Logistic那样计算每个变量的分箱或类型得分，我们只能根据这个违约概率计算客户的总评分。但依然要依据上面定义的评分刻度。</p> 
<p> </p> 
<p> </p> 
<p><strong>模型稳定性PSI（Population Stability Index）</strong></p> 
<p>模型上线之后，要对实际运行情况进行监测，主要为两个方面：</p> 
<p><strong>用户在模型中得分分布的稳定性</strong>：模型上线之后的真实数据得分分布（real data）和建模时训练数据（train data）的得分分布比较；</p> 
<p><strong>变量稳定性</strong>：模型上线之后的实际变量分布（real data）和建模时训练数据分布（train data）比较。</p> 
<p>首先对样本A和样本B得分按照同一标准分为几个区间（类别型变量按类别分），计算样本在每个区间上的占比。在每个区间上，将两个样本各自占比相除再取对数，然后乘以各自占比之差，最后将各个区间的计算值相加，最终得到PSI（类似于IV计算），如下：</p> 
<p><img alt="" height="413" src="https://images2.imgbox.com/7e/ea/P9DbdgQw_o.png" width="637"></p> 
<ul><li>PSI &lt; 0.1 样本分布有微小变化</li><li>PSI 在 0.1 和 0.2 之间， 样本分布有变化</li><li>PSI &gt; 0.2 样本分布有显著变化</li></ul> 
<p>重点关注 PSI &gt; 0.2 的变量，说明此变量的分布在建模时与现在已经发生了显著的变化，查找PSI变动的原因，并重新调整模型。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>参考资料：</p> 
<p><a href="https://blog.csdn.net/varyall/article/details/81173326">https://blog.csdn.net/varyall/article/details/81173326</a></p> 
<p><a href="https://blog.csdn.net/q337100/article/details/80693548">https://blog.csdn.net/q337100/article/details/80693548</a></p> 
<p><a href="https://www.cnblogs.com/gasongjian/p/8159501.html" rel="nofollow">https://www.cnblogs.com/gasongjian/p/8159501.html</a></p> 
<p><a href="https://www.cnblogs.com/gasongjian/p/8284229.html" rel="nofollow">https://www.cnblogs.com/gasongjian/p/8284229.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85325649d7ffe274a13ccef3f175c425/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【深度学习】介绍六大类损失函数（九）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c578942769b0ecc4c85256498fad4971/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js转换金额，元，万元</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>