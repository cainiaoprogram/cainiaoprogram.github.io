<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>到底什么是线程？线程与进程有哪些区别？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="到底什么是线程？线程与进程有哪些区别？" />
<meta property="og:description" content="上一篇文章我们讲述了什么是进程，进程的基本调度
http://t.csdn.cn/ybiwThttp://t.csdn.cn/ybiwT 那么本篇文章我们将了解一下什么是线程？线程与进程有哪些区别？线程应该怎么去编程？
目录
http://t.csdn.cn/ybiwThttp://t.csdn.cn/ybiwT
一、什么是线程&#43;线程的概念
二、为什么要有线程？
三、进程和线程的区别
3.1 java线程和操作系统线程的关系
四、线程的创建
五、需要主要的几个地方
六、Thread类里面的一些其他方法
6.1Thread几个常见属性
一、什么是线程&#43;线程的概念 进程，是比较“重量的”速度慢/消耗资源多的，那么创建一个进程，成本比较高；销毁一个进程，成本也比较高；调度一个进程，成本也挺高的。进程包含线程，一个进程里可以有多个线程，多个线程之间也是并发执行的。
那么线程，则是更轻量的进程（轻量级进程），一个进程中可以包含多个线程，此时这多个线程每个线程都是一个独立可以调度执行的“执行流”，同时这些进程共用一份进程的系统资源，（意味着，对于线程而言，系统资源是已经分配好了的，创建线程就省下了分配资源开销）。一个线程就是一个 &#34;执行流&#34;. 每个线程之间都可以按照顺讯执行自己的代码. 多个线程之间 &#34;同时&#34; 执行着多份代码。
一个进程中的多个线程之间，共用同一份系统资源：
1.（内存空间）
2.（文件描述符表）
操作系统，真正调度的是在调度线程，而不是进程。
线程是操作系统调度运行的基本单位
进程是操作系统资源分配的基本单位
举例：滑稽老铁吃鸡
多进程吃鸡：
多线程吃鸡：
并不是线程越多越好，如果线程过多会影响系统的效率，如果一个线程出现了异常，可能会导致此进程中的所有线程全部崩溃！！！
二、为什么要有线程？ 首先, &#34;并发编程&#34; 成为 &#34;刚需&#34;.
单核 CPU 的发展遇到了瓶颈. 要想提高算力, 就需要多核 CPU. 而并发编程能更充分利用多核 CPU资源.有些任务场景需要 &#34;等待 IO&#34;, 为了让等待 IO 的时间能够去做一些其他的工作, 也需要用到并发编程. 其次, 虽然多进程也能实现 并发编程, 但是线程比进程更轻量.
创建线程比创建进程更快.销毁线程比销毁进程更快.调度线程比调度进程更快. 最后, 线程虽然比进程轻量, 但是人们还不满足, 于是又有了 &#34;线程池&#34;(ThreadPool) 和 &#34;协程&#34;
(Coroutine)
三、进程和线程的区别 1.进程包含线程
2.进程有自己独立的内存空间和文件描述符表，同一个进程中的多个线程之间，共用同一份地址空间和文件描述符表
3.进程是操作系统资源分配的基本单位，线程是操作系统调度执行的基本单位
4.进程之间具有独立性，一个进程挂了，不会影响其他的进程；同一个进程里面的线程挂了，可能会有全部的线程都挂掉" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8e05849b3edc840f7d14f069297daa5b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-02T22:39:11+08:00" />
<meta property="article:modified_time" content="2023-05-02T22:39:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">到底什么是线程？线程与进程有哪些区别？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a id="_0"></a>上一篇文章我们讲述了什么是进程，进程的基本调度</p> 
<h2 id="http%3A%2F%2Ft.csdn.cn%2FybiwThttp%3A%2F%2Ft.csdn.cn%2FybiwT"><a class="has-card" href="http://t.csdn.cn/ybiwT" rel="nofollow" title="http://t.csdn.cn/ybiwT"><span class="link-card-box"><span class="link-title">http://t.csdn.cn/ybiwT</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/84/38/gVpdPUIX_o.png">http://t.csdn.cn/ybiwT</span></span></a></h2> 
<p>那么本篇文章我们将了解一下什么是线程？线程与进程有哪些区别？线程应该怎么去编程？</p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="http%3A%2F%2Ft.csdn.cn%2FybiwThttp%3A%2F%2Ft.csdn.cn%2FybiwT-toc" style="margin-left:0px;"><a href="#http%3A%2F%2Ft.csdn.cn%2FybiwThttp%3A%2F%2Ft.csdn.cn%2FybiwT" rel="nofollow">http://t.csdn.cn/ybiwThttp://t.csdn.cn/ybiwT</a></p> 
<p style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%2B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%2B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">一、什么是线程+线程的概念</a></p> 
<p style="margin-left:0px;"></p> 
<p id="%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BA%BF%E7%A8%8B%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BA%BF%E7%A8%8B%EF%BC%9F" rel="nofollow">二、为什么要有线程？</a></p> 
<p style="margin-left:0px;"></p> 
<p id="%E4%B8%89%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">三、进程和线程的区别</a></p> 
<p style="margin-left:0px;"></p> 
<p id="%C2%A03.1%20java%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:80px;"><a href="#%C2%A03.1%20java%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow"> 3.1 java线程和操作系统线程的关系</a></p> 
<p style="margin-left:80px;"></p> 
<p id="%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">四、线程的创建</a></p> 
<p style="margin-left:0px;"></p> 
<p id="%E4%BA%94%E3%80%81%E9%9C%80%E8%A6%81%E4%B8%BB%E8%A6%81%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9C%B0%E6%96%B9-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E9%9C%80%E8%A6%81%E4%B8%BB%E8%A6%81%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9C%B0%E6%96%B9" rel="nofollow">五、需要主要的几个地方</a></p> 
<p style="margin-left:0px;"></p> 
<p id="%E5%85%AD%E3%80%81Thread%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81Thread%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95" rel="nofollow">六、Thread类里面的一些其他方法</a></p> 
<p style="margin-left:0px;"></p> 
<p id="6.1Thread%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#6.1Thread%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7" rel="nofollow">6.1Thread几个常见属性</a></p> 
<p id="6.1Thread%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%2B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><a id="pandas_22"></a>一、什么是线程+线程的概念</h2> 
<blockquote> 
 <p>进程，是比较“重量的”速度慢/消耗资源多的，那么创建一个进程，成本比较高；销毁一个进程，成本也比较高；调度一个进程，成本也挺高的。进程包含线程，一个进程里可以有多个线程，多个线程之间也是并发执行的。</p> 
 <p></p> 
 <p><span style="color:#956fe7;">那么线程，则是更轻量的进程（轻量级进程），一个进程中可以包含多个线程，此时这多个线程每个线程都是一个独立可以调度执行的“执行流”，同时这些进程共用一份进程的系统资源，（意味着，对于线程而言，系统资源是已经分配好了的，创建线程就省下了分配资源开销）。一个线程就是一个 "执行流". 每个线程之间都可以按照顺讯执行自己的代码. 多个线程之间 "同时" 执行着多份代码。</span></p> 
</blockquote> 
<blockquote> 
 <p><strong>一个进程中的多个线程之间，共用同一份系统资源：</strong></p> 
 <p><strong>1.（内存空间）</strong></p> 
 <p><strong>2.（文件描述符表）</strong></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;">操作系统，真正调度的是在调度线程，而不是进程。</span></p> 
 <p><span style="color:#fe2c24;">线程是操作系统调度运行的基本单位</span></p> 
 <p><span style="color:#fe2c24;">进程是操作系统资源分配的基本单位</span></p> 
</blockquote> 
<p>举例：滑稽老铁吃鸡</p> 
<p>多进程吃鸡：</p> 
<p><img alt="" height="341" src="https://images2.imgbox.com/f9/d5/7uSNiu1v_o.png" width="1072"></p> 
<p> 多线程吃鸡：</p> 
<p><img alt="" height="344" src="https://images2.imgbox.com/be/5c/o1IqTaTW_o.png" width="509"></p> 
<blockquote> 
 <p><strong> 并不是线程越多越好，如果线程过多会影响系统的效率，如果一个线程出现了异常，可能会导致此进程中的所有线程全部崩溃！！！</strong></p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BA%BF%E7%A8%8B%EF%BC%9F"><strong>二、为什么要有线程？</strong></h2> 
<blockquote> 
 <p><a id="1_27"></a>首先, "并发编程" 成为 "刚需".</p> 
 <ul><li>单核 CPU 的发展遇到了瓶颈. 要想提高算力, 就需要多核 CPU. 而并发编程能更充分利用多核 CPU资源.</li><li>有些任务场景需要 "等待 IO", 为了让等待 IO 的时间能够去做一些其他的工作, 也需要用到并发编程.</li></ul> 
 <p>其次, 虽然多进程也能实现 并发编程, 但是线程比进程更轻量.</p> 
 <ul><li>创建线程比创建进程更快.</li><li>销毁线程比销毁进程更快.</li><li>调度线程比调度进程更快.</li></ul> 
 <p>最后, 线程虽然比进程轻量, 但是人们还不满足, 于是又有了 "线程池"(ThreadPool) 和 "协程"<br> (Coroutine)</p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">三、进程和线程的区别</h2> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">1.进程包含线程</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">2.进程有自己独立的内存空间和文件描述符表，同一个进程中的多个线程之间，共用同一份地址空间和文件描述符表</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">3.进程是操作系统资源分配的基本单位，线程是操作系统调度执行的基本单位</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">4.进程之间具有独立性，一个进程挂了，不会影响其他的进程；同一个进程里面的线程挂了，可能会有全部的线程都挂掉</span></strong></p> 
</blockquote> 
<p><img alt="" height="269" src="https://images2.imgbox.com/77/7f/eZPilUMo_o.png" width="639"></p> 
<h4 id="%C2%A03.1%20java%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"> 3.1 java线程和操作系统线程的关系</h4> 
<blockquote> 
 <p>线程是操作系统中的概念. 操作系统内核实现了线程这样的机制, 并且对用户层提供了一些 API 供用户使用(例如 Linux 的 pthread 库).</p> 
 <p></p> 
 <p>Java 标准库中 Thread 类可以视为是对操作系统提供的 API 进行了进一步的抽象和封装.</p> 
</blockquote> 
<h2 id="%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA">四、线程的创建</h2> 
<blockquote> 
 <p><strong>方法1：继承Thread类</strong></p> 
 <p>1) 继承 Thread 来创建一个线程类.</p> 
 <pre><code class="language-java">class MyThread extends Thread {
@Override
public void run() {
System.out.println("hello world");
   }
}</code></pre> 
 <p>2) 创建 MyThread 类的实例<br>  </p> 
 <pre><code class="language-java">MyThread t = new MyThread();</code></pre> 
 <p>3) 调用 start 方法启动线程<br>  </p> 
 <pre><code class="language-java">t.start(); // 线程开始运行</code></pre> 
 <p><span style="color:#fe2c24;">上述代码涉及俩个线程：</span></p> 
 <p><span style="color:#fe2c24;">1.main方法所对应的线程（一个进程里面至少得有一个线程）也可以成为主线程</span></p> 
 <p><span style="color:#fe2c24;">2.通过t.start()创建的新的线程</span></p> 
 <p><img alt="" height="359" src="https://images2.imgbox.com/11/da/S5xbFIC8_o.png" width="523"></p> 
 <p></p> 
 <p><img alt="" height="326" src="https://images2.imgbox.com/14/3e/PKFCpFer_o.png" width="870"></p> 
 <p></p> 
</blockquote> 
<blockquote> 
 <p><strong>方法二：实现Runnable接口</strong></p> 
 <p>1) 实现 Runnable 接口</p> 
 <pre><code class="language-java">class MyRunnable implements Runnable {
@Override
public void run() {
System.out.println("这里是线程运行的代码");
    }
}</code></pre> 
 <p>2) 创建 Thread 类实例, 调用 Thread 的构造方法时将 Runnable 对象作为 target 参数.</p> 
 <pre><code class="language-java">Thread t = new Thread(new MyRunnable());</code></pre> 
 <p>3) 调用 start 方法</p> 
 <pre><code class="language-java">t.start(); // 线程开始运行</code></pre> 
 <p><img alt="" height="338" src="https://images2.imgbox.com/5c/16/EhjGyFAd_o.png" width="580"></p> 
 <p> <img alt="" height="271" src="https://images2.imgbox.com/6a/ba/fRgtdo9p_o.png" width="891"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;">第一种写法是使用Thread的run描述线程入口</span></p> 
 <p><span style="color:#fe2c24;">第二章写法是使用Runnable interface 来描述线程入口</span></p> 
 <p><span style="color:#fe2c24;">没有本质区别</span></p> 
</blockquote> 
<blockquote> 
 <p><strong>方法三：继承Thread，使用匿名内部类</strong></p> 
 <pre><code class="language-java">public class ThreadDemo1 {
    public static void main(String[] args) {
        Thread t = new Thread(){
            @Override
            public void run(){
                while (true){
                    System.out.println("hello t"+ Thread.currentThread().getName());
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t.start();
    }
}</code></pre> 
 <p><img alt="" height="342" src="https://images2.imgbox.com/86/8c/hGOAuJ5S_o.png" width="917"></p> 
 <p></p> 
</blockquote> 
<blockquote> 
 <p><strong>第四种：实现Runnable，使用匿名内部类，内部类（定义在类里面的类）</strong></p> 
 <pre><code class="language-java">public class MyRunnable2 {
    public static void main(String[] args) {
        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("hello t");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t.start();
    }
}</code></pre> 
 <p><img alt="" height="342" src="https://images2.imgbox.com/55/74/w7ewNjKN_o.png" width="884"></p> 
 <p><span style="color:#fe2c24;"> { 放到哪里就是针对哪个类创建的匿名内部类</span></p> 
</blockquote> 
<blockquote> 
 <p><strong>第五种：使用Lambda表达式，最简单直观的方法</strong></p> 
 <p><strong>lambda表达式的基本写法：（）-&gt;{ }</strong></p> 
 <pre><code class="language-java">public class MyThreadDemo3 {
    public static void main(String[] args) {
        Thread t = new Thread(() -&gt; {
            while (true){
                System.out.println("hello t"+Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t.start();
    }
}</code></pre> 
 <p><img alt="" height="322" src="https://images2.imgbox.com/92/40/LtGG2KCj_o.png" width="878"></p> 
 <p></p> 
</blockquote> 
<h2 id="%E4%BA%94%E3%80%81%E9%9C%80%E8%A6%81%E4%B8%BB%E8%A6%81%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9C%B0%E6%96%B9">五、需要主要的几个地方</h2> 
<blockquote> 
 <p><span style="color:#fe2c24;">1.sleep是Thread的静态方法，参数单位是ms，1s = 1000ms。</span></p> 
 <p><span style="color:#fe2c24;">2.t.strat()是调用操作系统的api，创建新线程，新的线程里调用t.run，另外启动了一个执行流，新的线程来执行另一个while循环。</span></p> 
 <p><span style="color:#fe2c24;">3.如果调用的是t.run(),而不是t.start(),那么只会有一个线程来执行，也就是只有一个循环，进入第一个死循环就出不去了，如下图：</span></p> 
 <p><img alt="" height="248" src="https://images2.imgbox.com/0c/d4/FAdzK7OM_o.png" width="541"></p> 
 <p> <img alt="" height="191" src="https://images2.imgbox.com/2e/20/xdxaZ8FX_o.png" width="542"></p> 
 <p> <img alt="" height="335" src="https://images2.imgbox.com/02/f2/vqFD7jOA_o.png" width="885"></p> 
 <p><span style="color:#fe2c24;"> 4.run叫入口方法，是一个特殊的方法，只是重写了父类的方法，然后这个方法就被Java自动执行到了。</span></p> 
</blockquote> 
<p>当我们的代码在运行时，可以使用JDK自身带的软件去查看线程</p> 
<p><img alt="" height="49" src="https://images2.imgbox.com/3a/65/9I1TZXTq_o.png" width="583"></p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/93/b5/bkxa2if1_o.png" width="760"></p> 
<p> <img alt="" height="742" src="https://images2.imgbox.com/58/e4/CP2vD9CM_o.png" width="884"></p> 
<p> <img alt="" height="742" src="https://images2.imgbox.com/84/c8/p2brttHe_o.png" width="884"></p> 
<p> 描述线程中的代码执行到哪里了</p> 
<h2 id="%E5%85%AD%E3%80%81Thread%E7%B1%BB%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95">六、Thread类里面的一些其他方法</h2> 
<blockquote> 
 <p>Thread 类是 JVM 用来管理线程的一个类，换句话说，每个线程都有一个唯一的 Thread 对象与之关联。<br> 用我们上面的例子来看，每个执行流，也需要有一个对象来描述，类似下图所示，而 Thread 类的对象就是用来描述一个线程执行流的，JVM 会将这些 Thread 对象组织起来，用于线程调度，线程管理。</p> 
</blockquote> 
<p></p> 
<table><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>Thread()</td><td>创建线程对象</td></tr><tr><td>Thread(Runnable target)</td><td>使用 Runnable 对象创建线程对象</td></tr><tr><td>Thread(String name)</td><td>创建线程对象，并命名</td></tr><tr><td>Thread(Runnable target, String name)</td><td>使用 Runnable 对象创建线程对象，并命名</td></tr><tr><td>【了解】Thread(ThreadGroup group,<br> Runnable target)</td><td>线程可以被用来分组管理，分好的组即为线程组，这<br> 个目前我们了解即可</td></tr></tbody></table> 
<h4 id="6.1Thread%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7">6.1Thread几个常见属性</h4> 
<table><tbody><tr><td>属性</td><td>获取方法</td></tr><tr><td>ID</td><td>getId()</td></tr><tr><td>名称</td><td>getName()</td></tr><tr><td>状态</td><td>getState()</td></tr><tr><td>优先级</td><td>getPriority()</td></tr><tr><td>是否后台线程</td><td>isDaemon()</td></tr><tr><td>是否存活</td><td>isAlive()</td></tr><tr><td>是否被中断</td><td>isInterrupted()</td></tr></tbody></table> 
<blockquote> 
 <p><span style="color:#fe2c24;">关于后台线程，需要记住一点：JVM会在一个进程的所有非后台线程结束后，才会结束运行。<br> isDaemon（）设置为true表示是后台线程，false是前台线程，前台线程会阻止java进程结束，必须得java进程中所有得前台线程都执行完，java进程才能结束，创建的线程默认是前台的。</span></p> 
</blockquote> 
<hr> 
<h2><a id="_55"></a></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e6060a3b03b5efcd3baa130228b80109/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python可视化神器——pyecharts(词云图&amp;雷达图&amp;极坐标系)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdfc02f02203b70f8437072d26be7dab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">必学AI绘图技巧，如何用Midjourney实现连续性人物的创作，SEED功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>