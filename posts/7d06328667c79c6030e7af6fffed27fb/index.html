<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spring data JPA 学习 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spring data JPA 学习" />
<meta property="og:description" content="参考学习视频：哔哩哔哩中的图灵课堂中的徐庶老师。
本篇博客是自己学习jpa的笔记记录，笔记主要来源是视频中老师的讲解和加上个人的一些理解，仅供参考。
目录
jpa学习前言
为什么要用spring data
什么是jpa
jpa与jdbc对比
mybatis与hibernate的对比
hibernate搭建与测试(hibernate原始的操作)
spring data jpa基本入门
CrudRepository接口提供的常用方法
基本的分页与排序演示
jpa的自定义操作
使用jpql进行自定义
使用原生sql进行自定义
按照规定的方法名来进行操作
jpa的动态条件查询（重难点）
Query by Example
Specifications
Querydsl
jpa学习前言 为什么要用spring data spring data主要是用来实现数据存储的，那么我们使用mybatis，jdbc不行吗？为什么还要去学一门新技术？因为随着互联网业务的发展，业务的场景越来越复杂，单一的关系型数据库不再是最优的选择，但是随着数据库种类与数据库中间技术的变多，开发人员的学习成本和企业的招聘成本都会加剧上升，但是spring data可以对多种数据库进行操作，这样就大大减少了我们的学习成本。spring data帮我们统一了数据访问层，减低了学习成本，提升了开发效率。
什么是jpa JPA全称Java Persistence API（2019年重新命名为 Jakarta Persistence API ），是Sun官方提出的一种ORM规范。 O:Object R: Relational M:mapping
该规范为我们提供了：
① ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对 象持久化到数据库表中； 如：@Entity 、 @Table 、@Id 与 @Column等注解。
② JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和 SQL代码中解脱出来。 如：entityManager.merge(T t)；
③ JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 如：from Student s where s.name = ? （注意这个查询语句中的Student是类对象，name是该对象的属性）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7d06328667c79c6030e7af6fffed27fb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-02T08:00:00+08:00" />
<meta property="article:modified_time" content="2022-08-02T08:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spring data JPA 学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#fe2c24;"><strong>参考学习视频：哔哩哔哩中的图灵课堂中的徐庶老师。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>本篇博客是自己学习jpa的笔记记录，笔记主要来源是视频中老师的讲解和加上个人的一些理解，仅供参考。</strong></span></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="jpa%E5%AD%A6%E4%B9%A0%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#jpa%E5%AD%A6%E4%B9%A0%E5%89%8D%E8%A8%80" rel="nofollow">jpa学习前言</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8spring%20data-toc" style="margin-left:40px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8spring%20data" rel="nofollow">为什么要用spring data</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AFjpa-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFjpa" rel="nofollow">什么是jpa</a></p> 
<p id="jpa%E4%B8%8Ejdbc%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#jpa%E4%B8%8Ejdbc%E5%AF%B9%E6%AF%94" rel="nofollow">jpa与jdbc对比</a></p> 
<p id="mybatis%E4%B8%8Ehibernate%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#mybatis%E4%B8%8Ehibernate%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">mybatis与hibernate的对比</a></p> 
<p id="hibernate%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%B5%8B%E8%AF%95(hibernate%E5%8E%9F%E5%A7%8B%E7%9A%84%E6%93%8D%E4%BD%9C)-toc" style="margin-left:0px;"><a href="#hibernate%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%B5%8B%E8%AF%95%28hibernate%E5%8E%9F%E5%A7%8B%E7%9A%84%E6%93%8D%E4%BD%9C%29" rel="nofollow">hibernate搭建与测试(hibernate原始的操作)</a></p> 
<p id="spring%20data%20jpa%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8-toc" style="margin-left:0px;"><a href="#spring%20data%20jpa%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8" rel="nofollow">spring data jpa基本入门</a></p> 
<p id="CrudRepository%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#CrudRepository%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">CrudRepository接口提供的常用方法</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%88%86%E9%A1%B5%E4%B8%8E%E6%8E%92%E5%BA%8F%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%88%86%E9%A1%B5%E4%B8%8E%E6%8E%92%E5%BA%8F%E6%BC%94%E7%A4%BA" rel="nofollow">基本的分页与排序演示</a></p> 
<p id="jpa%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#jpa%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C" rel="nofollow">jpa的自定义操作</a></p> 
<p id="%E4%BD%BF%E7%94%A8jpql%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8jpql%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89" rel="nofollow">使用jpql进行自定义</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fsql%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fsql%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89" rel="nofollow">使用原生sql进行自定义</a></p> 
<p id="%E6%8C%89%E7%85%A7%E8%A7%84%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%E6%8C%89%E7%85%A7%E8%A7%84%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C" rel="nofollow">按照规定的方法名来进行操作</a></p> 
<p id="jpa%E7%9A%84%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2%EF%BC%88%E9%87%8D%E9%9A%BE%E7%82%B9%EF%BC%89-toc" style="margin-left:40px;"><a href="#jpa%E7%9A%84%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2%EF%BC%88%E9%87%8D%E9%9A%BE%E7%82%B9%EF%BC%89" rel="nofollow">jpa的动态条件查询（重难点）</a></p> 
<p id="Query%20by%20Example-toc" style="margin-left:80px;"><a href="#Query%20by%20Example" rel="nofollow">Query by Example</a></p> 
<p id="Specifications-toc" style="margin-left:80px;"><a href="#Specifications" rel="nofollow">Specifications</a></p> 
<p id="Querydsl-toc" style="margin-left:80px;"><a href="#Querydsl" rel="nofollow">Querydsl</a></p> 
<hr id="hr-toc"> 
<h2>jpa学习前言</h2> 
<h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8spring%20data">为什么要用spring data</h3> 
<p>spring data主要是用来实现数据存储的，那么我们使用mybatis，jdbc不行吗？为什么还要去学一门新技术？因为随着互联网业务的发展，业务的场景越来越复杂，<strong>单一的关系型数据库不再是最优的选择，但是随着数据库种类与数据库中间技术的变多</strong>，开发人员的学习成本和企业的招聘成本都会加剧上升，但是spring data可以对多种数据库进行操作，这样就大大减少了我们的学习成本。<strong>spring data帮我们统一了数据访问层，减低了学习成本，提升了开发效率。</strong></p> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AFjpa">什么是jpa</h3> 
<p>JPA全称Java Persistence API（2019年重新命名为 Jakarta Persistence API ），<strong>是</strong>Sun官方提出的<strong>一种ORM规范</strong>。 <strong>O:Object R: Relational M:mapping</strong></p> 
<p>该规范为我们提供了：</p> 
<p>① ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对 象持久化到数据库表中； 如：@Entity 、 @Table 、@Id 与 @Column等注解。</p> 
<p>② JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和 SQL代码中解脱出来。 如：entityManager.merge(T t)；</p> 
<p>③ JPQL查询语言：<span style="color:#fe2c24;"><strong>通过面向对象</strong></span>而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 如：from Student s where s.name = ? （注意这个查询语句中的Student是类对象，name是该对象的属性）</p> 
<h3 id="jpa%E4%B8%8Ejdbc%E5%AF%B9%E6%AF%94">jpa与jdbc对比</h3> 
<p>与jdbc的相同处：</p> 
<p>1、都跟数据∙库操作有关，JPA 是JDBC 的升华，升级版。</p> 
<p>2、JDBC和JPA都<strong>是一组规范接口</strong></p> 
<p>3、都是由SUN官方推出的</p> 
<p></p> 
<p>与jdbc的不同处：</p> 
<p>1、JDBC是由各个关系型数据库实现的， JPA 是由ORM框架实现</p> 
<p>2、JDBC 使用SQL语句和数据库通信。 <strong>【JPA用面向对象方式】， 通过ORM框架来生成SQL</strong>，进行操作。</p> 
<p>3、JPA在JDBC之上的， <span style="color:#fe2c24;"><strong>JPA也要依赖JDBC才能操作数据库</strong></span>。</p> 
<p></p> 
<p>jpa的作用：</p> 
<p>1、简化持久化操作的开发工作：让开发者从繁琐的 JDBC 和 SQL 代码中解脱出来，<span style="color:#fe2c24;"><strong>直接面向对象持久化操作</strong>。</span></p> 
<p>2、Sun希望持久化技术能够统一，实现天下归一：如果你是基于JPA进行持久化你可以随意切换数据库。</p> 
<p>Hibernate与JPA：Hibernate就是实现了JPA接口的ORM框架。<span style="color:#fe2c24;"><strong>JPA是一套ORM规范，Hibernate实现了JPA规范！</strong></span></p> 
<p></p> 
<h3 id="mybatis%E4%B8%8Ehibernate%E7%9A%84%E5%AF%B9%E6%AF%94">mybatis与hibernate的对比</h3> 
<p>mybatis：小巧、方便？、高效、简单、直接、半自动 半自动的ORM框架</p> 
<p>小巧： mybatis就是jdbc封装 在国内更流行。</p> 
<p><strong>场景： 在业务比较复杂系统进行使用</strong></p> 
<p></p> 
<p>hibernate：强大、方便、高效、（简单）复杂、绕弯子、全自动 全自动的ORM框架</p> 
<p>强大：根据ORM映射生成不同SQL 在国外更流。</p> 
<p>场景： 在业务相对简单的系统进行使用，随着微服务的流行。（<strong>适用于普通的增删改查</strong>）</p> 
<p>一个技术好不好用主要是看它在什么应用场景中使用，在实际的开发中技术选型是非常重要的，选择合适的技术来进行开发，可以大大的提高开发效率。</p> 
<p></p> 
<h2 id="hibernate%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%B5%8B%E8%AF%95(hibernate%E5%8E%9F%E5%A7%8B%E7%9A%84%E6%93%8D%E4%BD%9C)">hibernate搭建与测试(hibernate原始的操作)</h2> 
<p>1、创建数据库</p> 
<p>可以先不创建表，<span style="color:#fe2c24;"><strong>只要我们在数据库中创建一个数据库就行</strong></span>（配置文件中要写这个数据库名的名称的），然后在编写的Java实体的时候使用注解<strong>配置好Java实体类与数据库中表的映射关系</strong>就行，在执行代码的时候这个hibernate会自动帮我们去创建这个表，这个自动创建的表是根据我们编写的映射来生成的。</p> 
<p><img alt="" height="443" src="https://images2.imgbox.com/03/44/DGJuwZpU_o.png" width="1140"></p> 
<p>2、引入pom配置依赖</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;springdata&lt;/artifactId&gt;
        &lt;groupId&gt;com.tuling.springdata&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;01-jpa-hibernate&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!-- junit4 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!-- hibernate对jpa的支持包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
            &lt;version&gt;5.4.32.Final&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 注意驱动包的版本 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--openjpa--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.openjpa&lt;/groupId&gt;
            &lt;artifactId&gt;openjpa-all&lt;/artifactId&gt;
            &lt;version&gt;3.2.0&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;</code></pre> 
<p>3、编写Java对应的实体类</p> 
<pre><code class="language-java">@Entity     // 该注解是表示该类是作为hibernate的实体类
@Table(name = "tb_customer")       // 映射的表名，就是自动生成的表对应的表名
public class Customer {

    /**
     * @Id：声明主键的配置
     * @GeneratedValue:配置主键的生成策略
     *      strategy
     *          GenerationType.IDENTITY ：自增，mysql
     *                 * 底层数据库必须支持自动增长（底层数据库支持的自动增长方式，对id自增）
     *          GenerationType.SEQUENCE : 序列，oracle
     *                  * 底层数据库必须支持序列
     *          GenerationType.TABLE : jpa提供的一种机制，通过一张数据库表的形式帮助我们完成主键自增
     *          GenerationType.AUTO ： 由程序自动的帮助我们选择主键生成策略
     * @Column:配置属性和字段的映射关系
     *      name：数据库表中字段的名称
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long custId; //客户的主键

    @Column(name = "cust_name")
    private String custName;//客户名称

    @Column(name="cust_address")
    private String custAddress;//客户地址

    //对应属性的get,set,toString方法,这里就省略不在写出来了......
}</code></pre> 
<blockquote> 
 <p>     @Id：声明主键的配置<br>      @GeneratedValue:配置主键的生成策略<br>            strategy<br>                GenerationType.IDENTITY ：自增，mysql<br>                        底层数据库必须支持自动增长（底层数据库支持的自动增长方式，对id自增）<br>                GenerationType.SEQUENCE : 序列，oracle<br>                       底层数据库必须支持序列<br>                GenerationType.TABLE : jpa提供的一种机制，通过一张数据库表的形式帮助我们完成主键自增<br>                GenerationType.AUTO ： 由程序自动的帮助我们选择主键生成策略<br>       @Column:配置属性和字段的映射关系<br>            name：数据库表中字段的名称</p> 
</blockquote> 
<p>4、编写hibernate的配置文件：hibernate.cfg.xml  （下面也提供了使用注解的编程式配置）</p> 
<p><span style="color:#fe2c24;"><strong>注意：我的数据库环境是MySQL8以上，所以下面的配置文件要按照自己的数据库环境来配置；</strong></span></p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;
&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        &lt;!-- 配置数据库连接信息 --&gt;
        &lt;property name="connection.driver_class"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:mysql://localhost:3306/springdata_jpa?serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf-8&lt;/property&gt;
        &lt;property name="connection.username"&gt;root&lt;/property&gt;
        &lt;property name="connection.password"&gt;root&lt;/property&gt;

        &lt;!-- 会在日志中记录sql 默认false--&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;
        &lt;!--是否格式化sql(就是打印的sql的格式) 默认false--&gt;
        &lt;property name="format_sql"&gt;true&lt;/property&gt;
        &lt;!--表生成策略
            默认none   不自动生成
            update    如果没有表会创建，有会检查更新
            create    创建--&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;
        &lt;!-- 配置方言：选择数据库类型 --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQL8Dialect&lt;/property&gt;

        &lt;!--指定哪些(java类)pojo 需要进行ORM映射(帮我们生成数据库表的映射)--&gt;
        &lt;mapping class="com.tuling.pojo.Customer"&gt;&lt;/mapping&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</code></pre> 
<p>或者是使用java编程式进行配置：</p> 
<pre><code class="language-java">@Configuration          // 标记当前类为配置类
//@EnableJpaRepositories(basePackages="com.tuling.repositories")  // 启动jpa,这个包是自定义接口的的位置（实现repository或者是其子类 接口的位置），有点像dao/mapper
@EnableTransactionManagement    // 开启事务
public class SpringDataJPAConfig {

    
    //&lt;!--数据源--&gt;
    @Bean
    public DataSource dataSource() {

        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/springdata_jpa?serverTimezone=UTC&amp;characterEncoding=UTF-8");


        return  dataSource;
    }


    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
        vendorAdapter.setGenerateDdl(true);
        vendorAdapter.setShowSql(true);

        LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();
        factory.setJpaVendorAdapter(vendorAdapter);
        factory.setPackagesToScan("com.tuling.pojo");
        factory.setDataSource(dataSource());
        return factory;
    }


    @Bean
    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {

        JpaTransactionManager txManager = new JpaTransactionManager();
        txManager.setEntityManagerFactory(entityManagerFactory);
        return txManager;
    }

}
</code></pre> 
<p>5、编写和执行测试代码（这里使用的是简单的单元测试）</p> 
<pre><code class="language-java">public class HibernateTest {
// Session工厂  Session:数据库会话  代码和数据库的一个桥梁
    private SessionFactory sf;

    @Before
    public void init() {
        StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure("/hibernate.cfg.xml").build();

        //2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂

        sf = new MetadataSources(registry).buildMetadata().buildSessionFactory();
    }

    //进行数据插入的操作
    @Test
    public void testC(){
        // session进行持久化操作
        try(Session session = sf.openSession()){
            Transaction tx = session.beginTransaction();

            Customer customer = new Customer();
            customer.setCustName("徐庶");

            session.save(customer);

            tx.commit();
        }

    }
    
}    </code></pre> 
<p>执行结果：控制台会打印的sql执行流程（也可以关闭这个功能）</p> 
<p><img alt="" height="1097" src="https://images2.imgbox.com/10/70/72HsvpRH_o.png" width="1200"></p> 
<p> 数据库自动生成的表：</p> 
<p><img alt="" height="307" src="https://images2.imgbox.com/74/e0/JzxYHSFb_o.png" width="1200"></p> 
<p><strong>其他相关的测试操作：<span style="color:#fe2c24;">自己按需测试</span></strong><span style="color:#fe2c24;">  </span></p> 
<pre><code class="language-java">// Session工厂  Session:数据库会话  代码和数据库的一个桥梁
    private SessionFactory sf;

    @Before
    public void init() {
        StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure("/hibernate.cfg.xml").build();

        //2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂

        sf = new MetadataSources(registry).buildMetadata().buildSessionFactory();
    }


//查询操作
	@Test
    public void testR(){
        // session进行持久化操作
        try(Session session = sf.openSession()){
            Transaction tx = session.beginTransaction();

            Customer customer = session.find(Customer.class, 1L);
            System.out.println("=====================");
            System.out.println(customer);

            tx.commit();
        }

    }


//保存操作
    @Test
    public void testU(){
        // session进行持久化操作
        try(Session session = sf.openSession()){
            Transaction tx = session.beginTransaction();

            Customer customer = new Customer();
            //customer.setCustId(1L);
            customer.setCustName("徐庶");

            // 插入session.save()
            // 更新session.update();
            session.saveOrUpdate(customer);

            tx.commit();
        }

    }

//删除操作
    @Test
    public void testD(){
        // session进行持久化操作
        try(Session session = sf.openSession()){
            Transaction tx = session.beginTransaction();

            Customer customer = new Customer();
            customer.setCustId(2L);

            session.remove(customer);

            tx.commit();
        }
    }</code></pre> 
<h2 id="spring%20data%20jpa%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8">spring data jpa基本入门</h2> 
<p>spirng data jpa是spring提供的一套简化JPA开发的框架，<strong>按照约定好的规则进行【方法命名】去写dao层接口</strong>，就可以在不写接口实现的情况下，实现对数据库的访问和操作。同时提供了很多除了CRUD之外的功能，如分页、排序、复杂查询等等。</p> 
<p>Spring Data JPA 让我们解脱了DAO层的操作，<span style="color:#fe2c24;"><strong>基本上所有CRUD都可以依赖于它来实现,在实际的工作工程中</strong></span>，推荐使用Spring Data JPA + ORM（如：hibernate）完成操作，这样在切换不同的ORM框架时提供了极大的方便，同时也使数据库层操作更加简单，方便解耦。</p> 
<p>使用了SpringDataJpa，<span style="color:#fe2c24;"><strong>我们的dao层中只需要写接口，就【自动】具有了增删改查、分页查询等方法。</strong></span></p> 
<p><img alt="" height="1091" src="https://images2.imgbox.com/31/5e/G0stgDuG_o.png" width="1200"></p> 
<p>在dao层<span style="color:#fe2c24;"><strong>自己写一个接口继承这个CrudRepository&lt;T1,T2&gt;</strong></span> ，这个接口实现了基本的增删查改操作，里面的两个泛型，第一个代表要对那个实体类进行操作，第二个泛型表示进行删除，操作等操作的id是什么样的数据类型。我们自己定义的接口继承这个接口或者是其子接口（比如PagingAndSortingRepository, JpaRepository），那么<span style="color:#fe2c24;"><strong>我们自己定义的接口就有了基本的增删改查的功能了，就是这么简单！</strong></span></p> 
<pre><code class="language-java">public interface CustomerRepository extends CrudRepository&lt;User,Long&gt;  
//第一个泛型表示对user实体类进行操作
//第二个泛型表示在【对user实体类】进行增删改查操作的时候，像findById与 deleteById等操作的时候这个参数的数据类型就行long</code></pre> 
<p><img alt="" height="1039" src="https://images2.imgbox.com/e0/71/1UrvqYnT_o.png" width="1200"></p> 
<p>两个注意点：</p> 
<ul><li> <p><strong>使用这个接口提供的save方法的时候，如果我们指定了主键（一般是id）那这个save操作就是修改操作，如果没有指定主键那么这个save就是新增操作。</strong></p> </li><li> <p><strong>在使用这个接口提供的delete操作的时候，spring data jpa它会先帮我们去查找一次，然后再去删除，这样就可以不用担心删除的数据为null的情况。</strong></p> </li></ul> 
<h3 id="CrudRepository%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">CrudRepository接口提供的常用方法</h3> 
<p> </p> 
<pre><code class="language-java">// 用来插入和修改 有主键就是修改 没有就是新增
// 获得插入后自增id， 获得返回值
&lt;S extends T&gt; S save(S entity);

// 通过集合保存多个实体
&lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; entities);

// 通过主键查询实体
Optional&lt;T&gt; findById(ID id);

// 通过主键查询是否存在 返回boolean
boolean existsById(ID id);

// 查询所有
Iterable&lt;T&gt; findAll();

// 通过集合的主键 查询多个实体，， 返回集合
Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);

// 查询总数量
long count();

// 根据id进行删除
void deleteById(ID id);

// 根据实体进行删除
void delete(T entity);

// 删除多个
void deleteAllById(Iterable&lt;? extends ID&gt; ids);

// 删除多个传入集合实体
void deleteAll(Iterable&lt;? extends T&gt; entities);

// 删除所有
void deleteAll();</code></pre> 
<h3 id="%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%88%86%E9%A1%B5%E4%B8%8E%E6%8E%92%E5%BA%8F%E6%BC%94%E7%A4%BA">基本的分页与排序演示</h3> 
<p>源码中提供了CrudRepository这个接口的另一个子类：PagingAndSortingRepository</p> 
<pre><code class="language-java">@NoRepositoryBean
public interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; {
    //对查询的结果进行排序
    Iterable&lt;T&gt; findAll(Sort sort);

    //用来进行分页查询   这个Pageable可以通过PageRequest.of()方法来进行构建
    Page&lt;T&gt; findAll(Pageable pageable);
}</code></pre> 
<p>注意：这个findAll的分页操作后面还有其他的多种实现，这里只是先演示该方法最简单的分页。</p> 
<p>分页演示：</p> 
<pre><code class="language-java">    @Autowired
    CustomerRepository repository;  //这个CustomerRepository是自己定义的接口，继承了CrudRepository这个接口

    @Test
    public  void testPaging(){
        //这个PageRequest.of(0, 2)方法的两个参数，第一个代表分页的索引，就是当前查询是从第几页开始，这里的0是表示从第一页开始，第二个参数的意思是一页里面你要显示多少数据
        Page&lt;Customer&gt; all = repository.findAll(PageRequest.of(0, 2)); 
        //可以对分页查询的结果进行处理
        System.out.println(all.getTotalPages());
        System.out.println(all.getTotalElements());
        System.out.println(all.getContent());

    }</code></pre> 
<p>对属性进行硬编码排序演示：</p> 
<pre><code class="language-java">@Autowired
CustomerRepository repository;

@Test
public  void testSort(){

    Sort sort = Sort.by("id").descending(); 
//对查询的结果进行id(这个id是Java实体类与数据库中表对应的)降序排序，当然如果你想使用组合排序，是可以使用and进行排序规则的拼接的 ，这里直接使用固定的字段进行排序是不推荐的，因为万一以后这个字段名发生了变化那还要回来修改，，，

    Iterable&lt;Customer&gt; all = repository.findAll(sort);

    System.out.println(all);

}</code></pre> 
<p>对属性进行“安全的”排序：</p> 
<pre><code class="language-java">@Autowired
CustomerRepository repository;

@Test
public  void testSortTypeSafe(){

    //构建排序对象 这个Customer是我们自己写的实体类
    Sort.TypedSort&lt;Customer&gt; sortType = Sort.sort(Customer.class);

    //对指定的字段进行排序
    Sort sort = sortType.by(Customer::getCustId).descending();


    Iterable&lt;Customer&gt; all = repository.findAll(sort);

    System.out.println(all);

}</code></pre> 
<h3 id="jpa%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C">jpa的自定义操作</h3> 
<h4 id="%E4%BD%BF%E7%94%A8jpql%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89">使用jpql进行自定义</h4> 
<p>@Query 进行查询操作</p> 
<ul><li> <p>查询如果返回单个实体就用pojo接收 ， 如果是多个则需要通过集合。</p> </li><li> <p>参数设置方式：</p> 
  <ul><li> <p>索引 ： ?数字</p> </li><li> <p>具名： :参数名   必须要结合@Param注解指定参数名字</p> </li></ul></li></ul> 
<p>增删改操作：</p> 
<p>安装下面这个插件后，在query注解中书写sql就可以有提示了！ </p> 
<p><img alt="" height="413" src="https://images2.imgbox.com/1e/9d/SVJFNWcT_o.png" width="1200"></p> 
<ol><li> <p>要加上事务的支持； 在实际开发中这个事务的注解是写在业务层的！！！</p> </li><li> <p>如果是插入方法：一定只能在hibernate下才支持 （Insert into ..select )</p> </li></ol> 
<blockquote> 
 <p>@Transactional // 通常会放在业务逻辑层上面去声明<br> @Modifying // 通知springdatajpa 是增删改的操作</p> 
</blockquote> 
<pre><code class="language-java">public interface CustomerRepository extends PagingAndSortingRepository&lt;Customer,Long&gt;{

    // 自定义增删查改操作

    // 查询   
    //注意：使用这个注解书写查询语句的时候需要指定查询参数的位置或者是查询参数的属性名  下面这一种就是使用指定属性名来进行查询   也可以 FROM Customer where custName=?1   这个？表示占位符，这个问号后面的1表示参数的索引位置,这个索引是方法参数中参数的位置
    @Query("FROM Customer where custName=:custName ")  //推荐使用具名来完成参数的绑定
    List&lt;Customer&gt; findCustomerByCustName(@Param("custName") String custName);

    // 修改  返回的int是受影响的行数
    @Transactional
    @Modifying   // 通知springdatajpa 是增删改的操作，必须要加上这个注解
    @Query("UPDATE Customer c set c.custName=:custName where c.custId=:id")
    int updateCustomer(@Param("custName") String custName,@Param("id")Long id);


    @Transactional
    @Modifying   // 通知springdatajpa 是增删改的操作
    @Query("DELETE FROM Customer c where c.custId=?1")
    int deleteCustomer(Long id);

    // 新增  JPQL  注意jpa是不支持新增语句的，但是如果jpa的实现是使用hibernate的话，就可以使用hibernate提供的伪新增
    @Transactional
    @Modifying   // 通知springdatajpa 是增删改的操作
    @Query("INSERT INTO Customer (custName) SELECT c.custName FROM Customer c where c.custId=?1")
    int insertCustomerBySelect(Long id);

}
</code></pre> 
<h4 id="%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fsql%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89">使用原生sql进行自定义</h4> 
<pre><code class="language-java">@Query(value="select * FROM tb_customer where cust_name=:custName ",nativeQuery = true)  
//我们需要手动指定这个nativeQuery为true，它的默认是false，并且这个原生的sql要写在value属性中
List&lt;Customer&gt; findCustomerByCustNameBySql(@Param("custName") String custName);</code></pre> 
<h4 id="%E6%8C%89%E7%85%A7%E8%A7%84%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C">按照规定的方法名来进行操作</h4> 
<p>支持的查询方法主题关键字（前缀）：</p> 
<ul><li> <p>决定当前方法作用</p> </li><li> <p><span style="color:#fe2c24;"><strong>只支持查询和删除</strong></span></p> </li></ul> 
<p><img alt="" height="749" src="https://images2.imgbox.com/76/29/nFtlOREX_o.png" width="1200"></p> 
<p>支持的查询方法 <strong>谓词关键字</strong>和<strong>修饰符</strong>来决定查询条件：  </p> 
<p><img alt="" height="1109" src="https://images2.imgbox.com/26/41/Y2ATSGjH_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/cf/03/3KiMcgtr_o.png" width="1200"></p> 
<p> <strong>这些规定的方法命名都是不需要记忆的，只需要安装刚刚的jpa buddy 它就会有提示。</strong></p> 
<p><img alt="" height="936" src="https://images2.imgbox.com/25/f2/Nl7dMpXV_o.png" width="1200"></p> 
<p>代码演示： 没错，<span style="color:#fe2c24;"><strong>就是这样定义一下接口就行，就可以直接对数据库中的表进行操作了</strong></span>。   </p> 
<pre><code class="language-java">public interface CustomerMethodNameRepository extends PagingAndSortingRepository&lt;Customer,Long&gt; {

     //这个命名要特别注意，如果不按规范来的话就会导致失效的
     List&lt;Customer&gt; findByCustName(String custName);

     boolean existsByCustName(String custName);


     @Transactional
     @Modifying
     int deleteByCustId(Long custName);

	 //通过名字进行模糊查询操作
     List&lt;Customer&gt; findByCustNameLike(String custName);

}</code></pre> 
<h3 id="jpa%E7%9A%84%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2%EF%BC%88%E9%87%8D%E9%9A%BE%E7%82%B9%EF%BC%89">jpa的动态条件查询（重难点）</h3> 
<p>前面我们讲的自定义查询中，不管是使用jpql还是通过<strong>命名规范</strong>来进行查询，实际上查询语句都是已经被我们给写死的，<strong>不能达到动态查询的效果。</strong></p> 
<p>下面将介绍三种可以<span style="color:#fe2c24;"><strong>实现动态查询的方式</strong></span>，实际上<span style="color:#fe2c24;"><strong>它们各自都有自己的应用场景，每一种方法都有自己的局限</strong>。</span></p> 
<h4 id="Query%20by%20Example">Query by Example</h4> 
<p>使用步骤：</p> 
<p>1、将Repository继承QueryByExampleExecutor</p> 
<pre><code class="language-java">public interface CustomerQBERepository extends PagingAndSortingRepository&lt;Customer,Long&gt;, QueryByExampleExecutor&lt;Customer&gt; {  //这个泛型表示的是你要操作的Java实体类
    
}</code></pre> 
<p>我们看一下这个querybyexampleexecutor的源码定义了哪些方法：</p> 
<pre><code class="language-java">public interface QueryByExampleExecutor&lt;T&gt; {
    &lt;S extends T&gt; Optional&lt;S&gt; findOne(Example&lt;S&gt; example);

    &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; example);

    &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; example, Sort sort);

    &lt;S extends T&gt; Page&lt;S&gt; findAll(Example&lt;S&gt; example, Pageable pageable);

    &lt;S extends T&gt; long count(Example&lt;S&gt; example);

    &lt;S extends T&gt; boolean exists(Example&lt;S&gt; example);

    &lt;S extends T, R&gt; R findBy(Example&lt;S&gt; example, Function&lt;FetchableFluentQuery&lt;S&gt;, R&gt; queryFunction);
}</code></pre> 
<p>方法使用演示：</p> 
<pre><code class="language-java">    @Autowired
    CustomerQBERepository repository;  //把刚刚自己定义的接口注入到容器

 
   //根据客户名称  客户地址动态查询

    @Test
    public  void test01(){

        //构建实体类需要动态查询的条件  比如需要通过名字和地址进行动态查询
        Customer customer=new Customer();
        customer.setCustName("徐庶");  //在实际开发中这个查询的条件都是从前端传过来的，比如传了name和address过来，你需要使用对应的数据类型进行接收就行，这里是演示所以直接写死了查询条件
        customer.setCustAddress("BEIJING");

        // 通过Example构建查询条件  特别注意这个Example对象是spring data中的依赖，别引成了hibernate的
        Example&lt;Customer&gt; example = Example.of(customer);  

        List&lt;Customer&gt; list = (List&lt;Customer&gt;) repository.findAll(example);
        System.out.println(list);
    }



    /**
     * 通过匹配器进行条件的限制    客户名称  客户地址动态查询
     */
    @Test
    public  void test02(){

        // 查询条件
        Customer customer=new Customer();
        customer.setCustName("庶");
        customer.setCustAddress("JING");

        // 通过匹配器 对条件行为进行设置
        ExampleMatcher matcher = ExampleMatcher.matching()
                //.withIgnorePaths("custName")       // 设置忽略的属性
                //.withIgnoreCase("custAddress")      // 设置忽略大小写
                //.withStringMatcher(ExampleMatcher.StringMatcher.ENDING);    // 对所有条件字符串进行了结尾匹配
                .withMatcher("custAddress",m -&gt; m.endsWith().ignoreCase());      // 针对单个条件进行限制, 会使withIgnoreCase失效，需要单独设置，第一个参数是需要对那个属性进行匹配，第二个参数表示的是需要对属性使用什么样的匹配规则
                //.withMatcher("custAddress",ExampleMatcher.GenericPropertyMatchers.endsWith().ignoreCase());

        // 通过Example构建查询条件  加了匹配器的查询条件
        Example&lt;Customer&gt; example = Example.of(customer,matcher);

        List&lt;Customer&gt; list = (List&lt;Customer&gt;) repository.findAll(example);
        System.out.println(list);
    }
</code></pre> 
<p>匹配器提供的一些方法：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f3/19/vEdQmH4H_o.png" width="1082"></p> 
<p></p> 
<h4 id="Specifications">Specifications</h4> 
<p>之前使用Query by Example只能针对字符串进行条件设置，那如果希望对所有类型支持，可以使用Specifications。</p> 
<p>1、继承接口JpaSpecificationExecutor。</p> 
<pre><code class="language-java">public interface CustomerSpecificationsRepository
        extends PagingAndSortingRepository&lt;Customer,Long&gt;,
        JpaSpecificationExecutor&lt;Customer&gt; {  //这个泛型表示的是你要操作的Java实体类

}</code></pre> 
<p>2、传入Specification的实现： 结合lambda表达式</p> 
<ul><li> <p><span style="color:#fe2c24;"><strong>Root</strong></span>：查询哪个表（关联查询） = from</p> </li><li> <p><span style="color:#fe2c24;"><strong>CriteriaQuery</strong></span>：查询哪些字段，排序是什么 =组合(order by . where )</p> </li><li> <p><span style="color:#fe2c24;"><strong>CriteriaBuilder</strong></span>：条件之间是什么关系，如何生成一个查询条件，每一个查询条件都是什么类型（&gt; between in...) = where</p> </li><li> <p>Predicate（Expression）： 每一条查询条件的详细描述</p> </li></ul> 
<blockquote> 
 <p>root对象可以让我们从表中获取我们想要的列<br> CriteriaBuilder where 设置各种条件  (&gt; &lt; in between......)<br> query  组合（order by , where)</p> 
</blockquote> 
<pre><code class="language-java">    @Autowired
    CustomerSpecificationsRepository repository; //把刚刚自定义的接口注入到容器中


//--------------- 前面两个测试都是把查询条件写死的，后面两个测试是动态查询,更加符合实际开发
	//进行精确匹配，单一条件查询
    @Test
    public  void testR2(){

        List&lt;Customer&gt; customer = repository.findAll(new Specification&lt;Customer&gt;() {
            @Override
            public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {

                // root对象可以让我们从表中获取我们想要的列
                // CriteriaBuilder where 设置各种条件  (&gt; &lt; in ..)
                // query  组合（order by , where)
                Path&lt;Object&gt; custId = root.get("custId");  //获取对应的字段
                Path&lt;Object&gt; custName = root.get("custName");
                Path&lt;Object&gt; custAddress = root.get("custAddress");

                // 对字段进行精确匹配 参数1 ：为哪个字段设置条件   参数2：值
                Predicate predicate = cb.equal(custAddress, "BEIJING");

                return predicate;
            }
        });

        System.out.println(customer);
    }



	//进行多条件查询
    @Test
    public  void testR3(){

        List&lt;Customer&gt; customer = repository.findAll(new Specification&lt;Customer&gt;() {
            @Override
            public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {

                //root对象可以让我们从表中获取我们想要的列
                // CriteriaBuilder where 设置各种条件  (&gt; &lt; in ..)
                // query  组合（order by , where)
                Path&lt;Long&gt; custId = root.get("custId");
                Path&lt;String&gt; custName = root.get("custName");
                Path&lt;String&gt; custAddress = root.get("custAddress");

                // 参数1 ：为哪个字段设置条件   参数2：值 
                Predicate custAddressP = cb.equal(custAddress, "BEIJING"); //等于
                Predicate custIdP = cb.greaterThan(custId, 0L);   //大于
                CriteriaBuilder.In&lt;String&gt; in = cb.in(custName);  //in
                in.value("徐庶").value("王五");  //通过点value来进行in范围的拼接

				//对多个条件进行拼接
                Predicate and = cb.and(custAddressP, custIdP,in);

                return and;
            }
        });

        System.out.println(customer);
    }

//---------------------------------------------------------------------------------------------------------
//注意上面我们进行查询条件的构建的时候，是把查询条件给写死了，在实际开发中这个条件应该是动态的，我们需要根据前端传来的数据进行判断，然后通过判断的结果来进行查询条件的构建---主要是进行非空判断


	//模拟动态条件查询
    @Test
    public  void testR4(){

        //模拟前端传过来的数据
        Customer params=new Customer();
        //params.setCustAddress("BEIJING");
        params.setCustId(0L);
        params.setCustName("徐庶,王五");

        List&lt;Customer&gt; customer = repository.findAll(new Specification&lt;Customer&gt;() {
            @Override
            public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {


                //root对象可以让我们从表中获取我们想要的列
                // CriteriaBuilder where 设置各种条件  (&gt; &lt; in ..)
                // query  组合（order by , where)

                // 1. 通过root拿到需要设置条件的字段
                Path&lt;Long&gt; custId = root.get("custId");
                Path&lt;String&gt; custName = root.get("custName");
                Path&lt;String&gt; custAddress = root.get("custAddress");

                // 2. 通过CriteriaBuilder设置不同类型条件
                //2.1 因为动态查询的时候条件是变化的，不确定的，所以需要使用集合来进行条件的保存
                List&lt;Predicate&gt; list=new ArrayList&lt;&gt;();
                if(!StringUtils.isEmpty(params.getCustAddress())) {
                    // 参数1 ：为哪个字段设置条件   参数2：值
                    list.add(cb.equal(custAddress, "BEIJING")) ;
                }
                if(params.getCustId()&gt;-1){
                    list.add(cb.greaterThan(custId, 0L));
                }

                if(!StringUtils.isEmpty(params.getCustName())) {
                    CriteriaBuilder.In&lt;String&gt; in = cb.in(custName);
                    in.value("徐庶").value("王五");
                    list.add(in);
                }


                // 组合条件  因为涉及动态查询，这个拼接的查询条件个数在上面的判断中已经确定了，这里需要我们传一个数组过来，通过集合转数组的方法进行转换，不过需要的是Prediccate类型的定长数组
                Predicate and = cb.and(list.toArray(new Predicate[list.size()]));

                return and;
            }
        });

        System.out.println(customer);
    }


	//进行排序等多条件的操作
    @Test
    public  void testR5(){

        Customer params=new Customer();
        //params.setCustAddress("BEIJING");
        params.setCustId(0L);
        params.setCustName("徐庶,王五");

        List&lt;Customer&gt; customer = repository.findAll(new Specification&lt;Customer&gt;() {
            @Override
            public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {

                //root对象可以让我们从表中获取我们想要的列
                // CriteriaBuilder where 设置各种条件  (&gt; &lt; in ..)
                // query  组合（order by , where)
                Path&lt;Long&gt; custId = root.get("custId");
                Path&lt;String&gt; custName = root.get("custName");
                Path&lt;String&gt; custAddress = root.get("custAddress");

                // 参数1 ：为哪个字段设置条件   参数2：值
                List&lt;Predicate&gt; list=new ArrayList&lt;&gt;();
                if(!StringUtils.isEmpty(params.getCustAddress())) {
                    list.add(cb.equal(custAddress, "BEIJING")) ;
                }
                if(params.getCustId()&gt;-1){
                    list.add(cb.greaterThan(custId, 0L));
                }

                if(!StringUtils.isEmpty(params.getCustName())) {
                    CriteriaBuilder.In&lt;String&gt; in = cb.in(custName);
                    in.value("徐庶").value("王五");
                    list.add(in);
                }


                Predicate and = cb.and(list.toArray(new Predicate[list.size()]));

                //对id字段进行降序排序
                Order desc = cb.desc(custId);

                //使用呢query对象对条件和组合进行拼接
                return query.where(and).orderBy(desc).getRestriction();
            }
        });

        System.out.println(customer);
    }</code></pre> 
<p><strong>缺点：不支持分组等相关聚合函数的操作，但是支持排序。</strong> 如果你还是想要通过jpa实现分组等聚合函数的操作，那就需要通过原生的jpa，通过<strong>自己获取root对象，CriteriaQuery和CriteriaBuilder对象</strong>，然后再使用他们继续操作。因为重写toPredicate方法提供的数据库操作是定死的字段，你想要修改就只能提供原生的jpa操作来自己实现。</p> 
<p></p> 
<h4 id="Querydsl">Querydsl</h4> 
<p>QueryDSL是基于ORM框架或SQL平台上的一个<strong>通用查询框架</strong>。借助QueryDSL可以在任何支持的ORM框架或SQL平台上以通用API方式构建查询。 JPA是QueryDSL的主要集成技术，是JPQL和Criteria查询的代替方法。目前QueryDSL支持的平台包括JPA,JDO,SQL,Mongodb 等等。</p> 
<p>Querydsl扩展能让我们<strong>以链式方式代码编写查询方法</strong>。该扩展需要一个接口QueryDslPredicateExecutor，它定义了很多查询方法。</p> 
<p>我们<strong>自己定义的接口继承QueryDslPredicateExecutor该接口</strong>，那么我们就可以使用该接口提供的各种方法了。</p> 
<pre><code class="language-java">public interface CustomerQueryDSLRepository extends
        PagingAndSortingRepository&lt;Customer,Long&gt;
          , QuerydslPredicateExecutor&lt;Customer&gt; {  //这个泛型是我们需要操作的Java的实体类

}</code></pre> 
<p>需要引入单独的依赖：</p> 
<pre><code class="language-XML">&lt;querydsl.version&gt;4.4.0&lt;/querydsl.version&gt;

&lt;!‐‐ querydsl ‐‐&gt;
&lt;dependency&gt;
&lt;groupId&gt;com.querydsl&lt;/groupId&gt;
&lt;artifactId&gt;querydsl‐jpa&lt;/artifactId&gt;
&lt;version&gt;${querydsl.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>引入组件：<span style="color:#fe2c24;"><strong>用于构建q类</strong></span>，但是加入这个组件后它不会自动编译，所以需要我们在maven的组件那里点击进行编译。</p> 
<p><img alt="" height="272" src="https://images2.imgbox.com/7b/9b/tLjQ3OOX_o.png" width="699"></p> 
<p> 配置相关的maven插件：</p> 
<pre><code class="language-XML">&lt;apt.version&gt;1.1.3&lt;/apt.version&gt;


&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt;
        &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;${apt.version}&lt;/version&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.querydsl&lt;/groupId&gt;
                &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt;
                &lt;version&gt;${querydsl.version}&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
        &lt;executions&gt;
            &lt;execution&gt;
                &lt;phase&gt;generate-sources&lt;/phase&gt;
                &lt;goals&gt;
                    &lt;goal&gt;process&lt;/goal&gt;
                &lt;/goals&gt;
                &lt;configuration&gt;
                    &lt;outputDirectory&gt;target/generated-sources/queries&lt;/outputDirectory&gt;
                    &lt;processor&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;/processor&gt;
                    &lt;logOnlyOnError&gt;true&lt;/logOnlyOnError&gt;
                &lt;/configuration&gt;
            &lt;/execution&gt;
        &lt;/executions&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;</code></pre> 
<p>编译完成后会在我们的target目录下生成对应的class文件，这样我们就可以自己去构建q类去了？<span style="color:#fe2c24;"><strong>实际上还是不行</strong></span>，因为这个编译后的只是一个class文件，这个时候我们书写代码去用这个Q类还是会报错，应该是压根点不出来。这是因为我们编写代码是用source文件夹进行编写的，而字节码文件是被排除在source(可以进行编码的文件夹)目录下的，所以这个需要我们手动的把这个Q类所在的文件夹变成source文件夹。</p> 
<p><img alt="" height="263" src="https://images2.imgbox.com/e0/7e/gSwz6SjZ_o.png" width="1025"></p> 
<p><img alt="" height="841" src="https://images2.imgbox.com/44/8f/B37U07jA_o.png" width="1200"><img alt="" height="645" src="https://images2.imgbox.com/b9/a3/aRyiM1qp_o.png" width="1200"></p> 
<p><strong> 然后就可以进行编码测试了：</strong></p> 
<p> </p> 
<pre><code class="language-java">    @Autowired
    CustomerQueryDSLRepository repository;  //把刚刚自定义的接口注入容器中

    @Test
    public  void test01() {
        //拿到Q类对象
        QCustomer customer = QCustomer.customer;
        // 通过Id查找  这里的id我们写死为1了，但是实际开发中是会用一个变量来接收前端传输过来的id的
        BooleanExpression eq = customer.custId.eq(1L);
        System.out.println(repository.findOne(eq));
    }


    /**
     * 查询客户名称范围 (in)
     等于 EQ : equal .eq
	 不等于 NE : not equal .ne
	 小于 LT : less than .lt
	 大于 GT : greater than .gt
	 小于等于 LE : less than or equal .loe
	 大于等于 GE : greater than or equal .goe
     * id  &gt;大于
     * 地址  精确
     */
    @Test
    public  void test02() {
        QCustomer customer = QCustomer.customer;

        // 通过Id查找
        BooleanExpression and = customer.custName.in("徐庶", "王五")
                .and(customer.custId.gt(0L))  //id大于0
                .and(customer.custAddress.eq("BEIJING")); //地址为BEIJING

        System.out.println(repository.findOne(and));

    }



	//模拟动态查询
    @Test
    public  void test03() {

        Customer params=new Customer();
        params.setCustAddress("BEIJING");
        params.setCustId(0L);
        params.setCustName("徐庶,王五");


        QCustomer customer = QCustomer.customer;

        // 初始条件 类似于1=1 永远都成立的条件
        BooleanExpression expression = customer.isNotNull().or(customer.isNull());

        //这里是使用三目运算来进行判断了，当然也可以使用if来进行判断
        //注意：记得要使用and来进行拼接这个条件
        expression=params.getCustId()&gt;-1?
                expression.and(customer.custId.gt(params.getCustId())):expression;
        expression=!StringUtils.isEmpty( params.getCustName())?
                expression.and(customer.custName.in(params.getCustName().split(","))):expression;
        expression=!StringUtils.isEmpty( params.getCustAddress())?
                expression.and(customer.custAddress.eq(params.getCustAddress())):expression;


        System.out.println(repository.findAll(expression));

    }


    // 解决线程安全问题  如果使用@autowire来对EntityManager进行注入，那可能会出现线程安全问题，使用注解PersistenceContext可以为每一个线程单独绑定一个EntityManager，这样就可以解决线程不安全的问题了
    @PersistenceContext
    EntityManager em;

    /**
     * 自定义列查询、分组
     * 需要使用原生态的方式（Specification)
     * 通过Repository进行查询， 列、表都是固定
     */
    @Test
    public  void test04() {
        JPAQueryFactory factory = new JPAQueryFactory(em);

        QCustomer customer = QCustomer.customer;

        // 构建基于QueryDSL的查询  像写SQL一样来拼接条件    这个Tuple是一个自定义对象，主要是负责来接收你要查询信息，比如你只需要查一张表中的两个字段，实际上是没有对象来接收这个查询结果的两个字段的，而提供的Tuple这个对象就可以用来接收这种类型的数据
        JPAQuery&lt;Tuple&gt; tupleJPAQuery = factory.select(customer.custId, customer.custName)
                .from(customer)
                .where(customer.custId.eq(1L))
                .orderBy(customer.custId.desc());

        // 执行查询
        List&lt;Tuple&gt; fetch = tupleJPAQuery.fetch();

        // 处理返回数据  对结果集进行遍历
        for (Tuple tuple : fetch) {
            System.out.println(tuple.get(customer.custId));
            System.out.println(tuple.get(customer.custName));
        }

    }


	//结合聚合函数进行查询，注意结果集的返回值
    @Test
    public  void test05() {
        JPAQueryFactory factory = new JPAQueryFactory(em);
        QCustomer customer = QCustomer.customer;

        // 构建基于QueryDSL的查询
        JPAQuery&lt;Long&gt; longJPAQuery = factory.select(
                        customer.custId.sum())
                .from(customer)
                //.where(customer.custId.eq(1L))
                .orderBy(customer.custId.desc());

        // 执行查询
        List&lt;Long&gt; fetch = longJPAQuery.fetch();

        // 处理返回数据
        for (Long sum : fetch) {
            System.out.println(sum);
        }

    }</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/93a6a99435ca6a5e6ba343b19ce1e16e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">post请求返回403</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fa9a8e37e57a578960c255055e166bb6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Three.JS程序化建模入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>