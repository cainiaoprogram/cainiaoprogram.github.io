<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>make makefile cmake qmake都是什么，有什么区别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="make makefile cmake qmake都是什么，有什么区别" />
<meta property="og:description" content="列表一：
1.gcc是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C&#43;&#43;、Objective-C、Fortran、Java等等）。
2.当你的程序只有一个源文件时，直接就可以用gcc命令编译它。
3.但是当你的程序包含很多个源文件时，用gcc命令逐个去编译时，你就很容易混乱而且工作量大
4.所以出现了make工具
make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。
5.makefile是什么？简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。
6.makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。
7.makefile在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。
8.这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。
9.可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。
10.到最后CMakeLists.txt文件谁写啊？亲，是你自己手写的。
11.当然如果你用IDE，类似VS这些一般它都能帮你弄好了，你只需要按一下那个三角形
12.接着是qmake，qmake是什么，先说一下Qt这个东西。Qt是跨平台C&#43;&#43;图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。简单的说就是C&#43;&#43;的第三方库，使用这个库你可以很容易生成windows，Linux，MAC os等等平台的图形界面。现在的Qt还包含了开发各种软件一般需要用到的功能模块（网络，数据库，XML，多线程啊等等），比你直接用C&#43;&#43;（只带标准内裤那种）要方便和简单。
13.你可以用Qt简简单单就实现非常复杂的功能，是因为Qt对C&#43;&#43;进行了扩展，你写一行代码，Qt在背后帮你写了几百上千行，而这些多出来的代码就是靠Qt专有的moc编译器（The Meta-Object Compiler）和uic编译器（User Interface Complier）来重新翻译你那一行代码。问题来了，你在进行程序编译前就必须先调用moc和uic对Qt源文件进行预处理，然后再调用编译器进行编译。上面说的那种普通makefile文件是不适用的，它没办法对qt源文件进行预处理。所以qmake就产生了。
14.qmake工具就是Qt公司制造出来，用来生成Qt 专用makefile文件，这种makefile文件就能自动智能调用moc和uic对源程序进行预处理和编译。qmake当然必须也是跨平台的，跟cmake一样能对应各种平台生成对应makefile文件。
15.qmake是根据Qt 工程文件（.pro）来生成对应的makefile的。工程文件（.pro）相对来说比较简单，一般工程你都可以自己手写，但是一般都是由Qt的开发环境 Qt Creator自动生成的，你还是只需要按下那个邪恶三角形就完事了。
16.还没有完，由于qmake很简单很好用又支持跨平台，而且是可以独立于它的IDE，所以你也可以用在非Qt工程上面，照样可以生成普通的makefile，只要在pro文件中加入CONFIG -= qt 就可以了。
17. 这样qmake和cmake有什么区别？
不好意思，cmake也是同样支持Qt程序的，cmake也能生成针对qt 程序的那种特殊makefile，
只是cmake的CMakeLists.txt 写起来相对与qmake的pro文件复杂点。
qmake 是为 Qt 量身打造的，使用起来非常方便，但是cmake功能比qmake强大。
一般的Qt工程你就直接使用qmake就可以了，cmake的强大功能一般人是用不到的。
当你的工程非常大的时候，又有qt部分的子工程，又有其他语言的部分子工程，据说用cmake会 方便，我也没试过。
列表二:
1. make 是用来执行Makefile的
2. Makefile是类unix环境下(比如Linux)的类似于批处理的&#34;脚本&#34;文件。其基本语法是: 目标&#43;依赖&#43;命令，只有在目标文件不存在，或目标比依赖的文件更旧，命令才会被执行。由此可见，Makefile和make可适用于任意工作，不限于编程。比如，可以用来管理latex。
3. Makefile&#43;make可理解为类unix环境下的项目管理工具，但它太基础了，抽象程度不高，而且在windows下不太友好(针对visual studio用户)，于是就有了跨平台项目管理工具cmake
4. cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。虽然，仍然是目标，依赖之类的东西，但更为抽象和友好，比如你可用math表示数学库，而不需要再具体指定到底是math.dll还是libmath.so，在windows下它会支持生成visual studio的工程，在linux下它会生成Makefile，甚至它还能生成eclipse工程文件。也就是说，从同一个抽象规则出发，它为各个编译器定制工程文件。
5. cmake是抽象层次更高的项目管理工具，cmake命令执行的CMakeLists.txt文件
6. qmake是Qt专用的项目管理工具，对应的工程文件是*.pro，在Linux下面它也会生成Makefile，当然，在命令行下才会需要手动执行qmake，完全可以在qtcreator这个专用的IDE下面打开*.pro文件，使用qmake命令的繁琐细节不用你管了。
总结一下，make用来执行Makefile，cmake用来执行CMakeLists.txt，qmake用来处理*.pro工程文件。Makefile的抽象层次最低，cmake和qmake在Linux等环境下最后还是会生成一个Makefile。cmake和qmake支持跨平台，cmake的做法是生成指定编译器的工程文件，而qmake完全自成体系。
具体使用时，Linux下，小工程可手动写Makefile，大工程用automake来帮你生成Makefile，要想跨平台，就用cmake。如果GUI用了Qt，也可以用qmake&#43;*.pro来管理工程，这也是跨平台的。当然，cmake中也有针对Qt的一些规则，并代替qmake帮你将qt相关的命令整理好了。
另外，需要指出的是，make和cmake主要命令只有一条，make用于处理Makefile，cmake用来转译CMakeLists.txt，而qmake是一个体系，用于支撑一个编程环境，它还包含除qmake之外的其它多条命令(比如uic，rcc,moc)。
上个简图，其中cl表示visual studio的编译器，gcc表示linux下的编译器
那么qt中的moc rcc uic 又是什么呢？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/96c0a725b1f071780318498225492be5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-22T10:34:35+08:00" />
<meta property="article:modified_time" content="2021-02-22T10:34:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">make makefile cmake qmake都是什么，有什么区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>列表一：</p> 
<p>1.gcc是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。<br><br> 2.当你的程序只有一个源文件时，直接就可以用gcc命令编译它。<br><br> 3.但是当你的程序包含很多个源文件时，用gcc命令逐个去编译时，你就很容易混乱而且工作量大<br><br> 4.所以出现了make工具<br> make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。<br><br> 5.makefile是什么？简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。<br><br> 6.makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。<br><br> 7.makefile在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。<br><br> 8.这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。<br><br> 9.可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。<br><br> 10.到最后CMakeLists.txt文件谁写啊？亲，是你自己手写的。<br><br> 11.当然如果你用IDE，类似VS这些一般它都能帮你弄好了，你只需要按一下那个三角形<br><br> 12.接着是qmake，qmake是什么，先说一下Qt这个东西。Qt是跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。简单的说就是C++的第三方库，使用这个库你可以很容易生成windows，Linux，MAC os等等平台的图形界面。现在的Qt还包含了开发各种软件一般需要用到的功能模块（网络，数据库，XML，多线程啊等等），比你直接用C++（只带标准内裤那种）要方便和简单。<br><br> 13.你可以用Qt简简单单就实现非常复杂的功能，是因为Qt对C++进行了扩展，你写一行代码，Qt在背后帮你写了几百上千行，而这些多出来的代码就是靠Qt专有的moc编译器（The Meta-Object Compiler）和uic编译器（User Interface Complier）来重新翻译你那一行代码。问题来了，你在进行程序编译前就必须先调用moc和uic对Qt源文件进行预处理，然后再调用编译器进行编译。上面说的那种普通makefile文件是不适用的，它没办法对qt源文件进行预处理。所以qmake就产生了。<br><br> 14.qmake工具就是Qt公司制造出来，用来生成Qt 专用makefile文件，这种makefile文件就能自动智能调用moc和uic对源程序进行预处理和编译。qmake当然必须也是跨平台的，跟cmake一样能对应各种平台生成对应makefile文件。<br><br> 15.qmake是根据Qt 工程文件（.pro）来生成对应的makefile的。工程文件（.pro）相对来说比较简单，一般工程你都可以自己手写，但是一般都是由Qt的开发环境 Qt Creator自动生成的，你还是只需要按下那个邪恶三角形就完事了。<br><br> 16.还没有完，由于qmake很简单很好用又支持跨平台，而且是可以独立于它的IDE，所以你也可以用在非Qt工程上面，照样可以生成普通的makefile，只要在pro文件中加入CONFIG -= qt 就可以了。<br><br> 17. 这样qmake和cmake有什么区别？<br> 不好意思，cmake也是同样支持Qt程序的，cmake也能生成针对qt 程序的那种特殊makefile，<br> 只是cmake的CMakeLists.txt 写起来相对与qmake的pro文件复杂点。<br> qmake 是为 Qt 量身打造的，使用起来非常方便，但是cmake功能比qmake强大。<br> 一般的Qt工程你就直接使用qmake就可以了，cmake的强大功能一般人是用不到的。<br> 当你的工程非常大的时候，又有qt部分的子工程，又有其他语言的部分子工程，据说用cmake会 方便，我也没试过。</p> 
<p>列表二:</p> 
<p>1. make 是用来执行Makefile的<br> 2. Makefile是类unix环境下(比如Linux)的类似于批处理的"脚本"文件。其基本语法是: <strong>目标+依赖+命令</strong>，只有在<strong>目标</strong>文件不存在，或<strong>目标</strong>比<strong>依赖</strong>的文件更旧，<strong>命令</strong>才会被执行。由此可见，Makefile和make可适用于任意工作，不限于编程。比如，可以用来管理latex。<br> 3. Makefile+make可理解为类unix环境下的项目管理工具，但它太基础了，抽象程度不高，而且在windows下不太友好(针对visual studio用户)，于是就有了跨平台项目管理工具cmake<br> 4. cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。虽然，仍然是目标，依赖之类的东西，但更为抽象和友好，比如你可用math表示数学库，而不需要再具体指定到底是math.dll还是libmath.so，在windows下它会支持生成visual studio的工程，在linux下它会生成Makefile，甚至它还能生成eclipse工程文件。也就是说，从同一个抽象规则出发，它为各个编译器定制工程文件。<br> 5. cmake是抽象层次更高的项目管理工具，cmake命令执行的CMakeLists.txt文件<br> 6. qmake是Qt专用的项目管理工具，对应的工程文件是*.pro，在Linux下面它也会生成Makefile，当然，在命令行下才会需要手动执行qmake，完全可以在qtcreator这个专用的IDE下面打开*.pro文件，使用qmake命令的繁琐细节不用你管了。<br><br> 总结一下，make用来执行Makefile，cmake用来执行CMakeLists.txt，qmake用来处理*.pro工程文件。Makefile的抽象层次最低，cmake和qmake在Linux等环境下最后还是会生成一个Makefile。cmake和qmake支持跨平台，cmake的做法是生成指定编译器的工程文件，而qmake完全自成体系。<br><br> 具体使用时，Linux下，小工程可手动写Makefile，大工程用automake来帮你生成Makefile，要想跨平台，就用cmake。如果GUI用了Qt，也可以用qmake+*.pro来管理工程，这也是跨平台的。当然，cmake中也有针对Qt的一些规则，并代替qmake帮你将qt相关的命令整理好了。<br><br> 另外，需要指出的是，make和cmake主要命令只有一条，make用于处理Makefile，cmake用来转译CMakeLists.txt，而qmake是一个体系，用于支撑一个编程环境，它还包含除qmake之外的其它多条命令(比如uic，rcc,moc)。<br><br> 上个简图，其中cl表示visual studio的编译器，gcc表示linux下的编译器</p> 
<p><img alt="" src="https://images2.imgbox.com/fb/90/TOvOulQc_o.png" width="1056"></p> 
<p>那么qt中的moc rcc uic 又是什么呢？</p> 
<h3 id="blogTitle0"><a name="t0"></a>MOC</h3> 
<p><strong>从qt继承而来的类只要用了关键字 Q_OBJECT，都必须生成其对应的moc文件</strong>，命令如下</p> 
<pre>moc.exe myclass.h -o moc_myclass.cpp</pre> 
<p>其中myclass.h中有类有Q_OBJECT属性。在vs项目中只需要添加mac_myclass.cpp文件即可。</p> 
<h3 id="blogTitle1"><a name="t1"></a>UI</h3> 
<p>虽然不使用designer来设计界面，但<strong>在编译一个demo项目时都会用*.ui文件，这时得先将其用uic.exe进行转</strong>化</p> 
<pre>uic.exe app.ui -o ui_app.h</pre> 
<p>其中app.ui是用designer设计好的界面文件， ui_app.h是生成的头文件。然后在c++项目中#include "ui_app.h"即可。</p> 
<h3><a name="t2"></a>RCC</h3> 
<p> rcc 工具的两种用途：<br> （1）生成独立的二进制资源文件 *.rcc<br> 对于太大的图片、音频、视频等文件，不适合集成到目标程序内部，可以放到操作系统文件路径，或者单独编译成外挂资源 *.rcc 。举例来说，myresource.qrc 包含了很多图片和视频，没法编译成目标程序内嵌资源时，可以打开 Qt 命令行，进入 myresource.qrc 所在的文件夹，执行命令：</p> 
<p>rcc -binary myresource.qrc -o myresource.rcc</p> 
<p>rcc 会把 myresource.qrc 里面描述的所有图片、视频等文件，都压缩打包，生成一个二进制的 myresource.rcc 文件，这个 myresource.rcc 包含了所有的资源，这样程序发布时就不需要带一堆乱七八糟的碎文件了，一个 myresource.rcc 搞定。<br><br> 那么代码中如何使用 myresource.rcc 呢？需要在 main 函数开始的位置注册这个独立的二进制资源文件：</p> 
<p>QResource::registerResource("/path/myresource.rcc");<br> （2）应用程序内嵌资源<br> 如果希望一个资源描述文件 application.qrc 在程序编译时内嵌到目标程序里，需要在 *.pro 文件里加一句话：</p> 
<p>RESOURCES += application.qrc</p> 
<p>qmake 会自动根据这句话，为 application.qrc 添加编译脚本，其编译过程如下图所示：</p> 
<p><img alt="rcc" src="https://images2.imgbox.com/23/a4/TqVPcWbr_o.png"></p> 
<p>参考链接：</p> 
<p><a href="https://blog.csdn.net/qq_41399894/article/details/100651730">https://blog.csdn.net/qq_41399894/article/details/100651730</a></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d508c8b42e851cf699014a6ec8be11f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pyinstaller生成exe后，执行错误No module named ‘win32timezone‘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53c924f46fd5dd3bf18a6b32b251ee9b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL高可用探索之orchestrator</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>