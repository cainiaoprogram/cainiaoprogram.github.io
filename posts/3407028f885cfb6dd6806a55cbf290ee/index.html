<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity3D Http接口常用加密算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity3D Http接口常用加密算法" />
<meta property="og:description" content="HMAC-SHA1 算法 //HMAC-SHA1 算法1 public static object HMAC_SHA1(string content, string secretKey, bool raw_outut = false) { Encoding enc = Encoding.UTF8; HMACSHA1 hmacsha1 = new HMACSHA1(enc.GetBytes(secretKey)); byte[] bytes = enc.GetBytes(content); if (raw_outut) { return hmacsha1.ComputeHash(bytes); } else { return BitConverter.ToString(hmacsha1.ComputeHash(bytes)).Replace(&#34;-&#34;, string.Empty).ToLower(); } } //HMAC-SHA1 算法2 public static string ComputeHMAC_SHA1Base64(string data, string key) { System.Security.Cryptography.HMACSHA1 hmacsha1 = new System.Security.Cryptography.HMACSHA1(Encoding.UTF8.GetBytes(key), true); byte[] dataBuffer = Encoding.UTF8.GetBytes(data); byte[] hashBytes = hmacsha1.ComputeHash(dataBuffer); return Convert.ToBase64String(hashBytes); } MD5 算法 //md5 public static string Md5Sum(string strToEncrypt) { byte[] bs = Encoding." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3407028f885cfb6dd6806a55cbf290ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-30T15:00:55+08:00" />
<meta property="article:modified_time" content="2020-06-30T15:00:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity3D Http接口常用加密算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>        HMAC-SHA1 算法</strong></h2> 
<pre><code class="language-cs">    //HMAC-SHA1 算法1
    public static object HMAC_SHA1(string content, string secretKey, bool raw_outut = false)
    {
        Encoding enc = Encoding.UTF8;
        HMACSHA1 hmacsha1 = new HMACSHA1(enc.GetBytes(secretKey));
        byte[] bytes = enc.GetBytes(content);
        if (raw_outut)
        {
            return hmacsha1.ComputeHash(bytes);
        }
        else
        {
            return BitConverter.ToString(hmacsha1.ComputeHash(bytes)).Replace("-", string.Empty).ToLower();
        }
    }
    //HMAC-SHA1 算法2
    public static string ComputeHMAC_SHA1Base64(string data, string key)
    {
        System.Security.Cryptography.HMACSHA1 hmacsha1 = new System.Security.Cryptography.HMACSHA1(Encoding.UTF8.GetBytes(key), true);
        byte[] dataBuffer = Encoding.UTF8.GetBytes(data);
        byte[] hashBytes = hmacsha1.ComputeHash(dataBuffer);
        return Convert.ToBase64String(hashBytes);
    }</code></pre> 
<h2><strong>        MD5 算法</strong></h2> 
<pre><code class="language-cs">    //md5
    public static string Md5Sum(string strToEncrypt)
    {
        byte[] bs = Encoding.UTF8.GetBytes(strToEncrypt);
        MD5 md5 = MD5CryptoServiceProvider.Create();
        byte[] hashBytes = md5.ComputeHash(bs);
        string hashString = "";
        for (int i = 0; i &lt; hashBytes.Length; i++)
        {
            hashString += System.Convert.ToString(hashBytes[i], 16).PadLeft(2, '0');
        }
        return hashString.PadLeft(32, '0');
    }
    //16 md5    
    public static string GetMd5_16byte(string ConvertString)
    {
        string md5Pwd = string.Empty;

        //使用加密服务提供程序
        MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();

        //将指定的字节子数组的每个元素的数值转换为它的等效十六进制字符串表示形式。
        md5Pwd = BitConverter.ToString(md5.ComputeHash(UTF8Encoding.Default.GetBytes(ConvertString)), 4, 8);

        md5Pwd = md5Pwd.Replace("-", "");

        return md5Pwd;
    }
    //32 md5
    public static string GetMd5_32byte(string str)
    {
        string pwd = string.Empty;

        //实例化一个md5对像
        MD5 md5 = MD5.Create();

        // 加密后是一个字节类型的数组，这里要注意编码UTF8/Unicode等的选择　
        byte[] s = md5.ComputeHash(Encoding.UTF8.GetBytes(str));

        // 通过使用循环，将字节类型的数组转换为字符串，此字符串是常规字符格式化所得
        for (int i = 0; i &lt; s.Length; i++)
        {
            // 将得到的字符串使用十六进制类型格式。格式后的字符是小写的字母，如果使用大写（X）则格式后的字符是大写字符 
            pwd = pwd + s[i].ToString("X");
        }

        return pwd;
    }</code></pre> 
<h2><strong>        图片的MD5算法</strong></h2> 
<pre><code class="language-cs">    /// &lt;summary&gt;
    /// 图片数据的md5
    /// &lt;/summary&gt;
    /// &lt;param name="data"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static string ComputeMd5Hex(byte[] data)
    {
        MD5CryptoServiceProvider md5CSP = new MD5CryptoServiceProvider();
        byte[] dataEncrypt = data;
        byte[] resultEncrypt = md5CSP.ComputeHash(dataEncrypt);
        string result = string.Empty;
        char pad = '0';
        for (int i = 0; i &lt; resultEncrypt.Length; i++)
        {
            string hex = System.Convert.ToString(resultEncrypt[i], 16);
            hex = hex.PadLeft(2, pad);
            result += hex;
        }
        return result;
    }</code></pre> 
<h2><strong>        string Base64编码/解码</strong></h2> 
<pre><code class="language-cs">  //string Base64编码
    public static string ToBase64String(string value)
    {
        if (value == null || value == "")
        {
            return "";
        }
        byte[] bytes = Encoding.UTF8.GetBytes(value);
        return Convert.ToBase64String(bytes);
    }
    //string Base64 解码
    public static string UnBase64String(string value)
    {
        if (value == null || value == "")
        {
            return "";
        }
        byte[] bytes = Convert.FromBase64String(value);
        return Encoding.UTF8.GetString(bytes);
    }</code></pre> 
<h2><strong>        Guid</strong></h2> 
<pre><code class="language-cs">    /// &lt;summary&gt;
    /// 由连字符分隔的32位数字xxxx-xxxx-xxxx-xxxx
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static string GetGuid()
    {
        Guid guid = new Guid();
        guid = Guid.NewGuid();
        return guid.ToString();
    }
    /// &lt;summary&gt;  
    /// 根据GUID获取16位的唯一字符串  
    /// &lt;/summary&gt;  
    /// &lt;param name=\"guid\"&gt;&lt;/param&gt;  
    /// &lt;returns&gt;&lt;/returns&gt;  
    public static string GuidTo16String()
    {
        long i = 1;
        foreach (byte b in Guid.NewGuid().ToByteArray())
            i *= ((int)b + 1);
        return string.Format("{0:x}", i - DateTime.Now.Ticks);
    }
    /// &lt;summary&gt;  
    /// 根据GUID获取19位的唯一数字序列  
    /// &lt;/summary&gt;  
    /// &lt;returns&gt;&lt;/returns&gt;  
    public static long GuidToLongID()
    {
        byte[] buffer = Guid.NewGuid().ToByteArray();
        return BitConverter.ToInt64(buffer, 0);
    }   </code></pre> 
<h2><strong>        UrlEncode 编码</strong></h2> 
<pre><code class="language-cs">using System.Text;
using System.Collections;
public static class WebUtility
{
    // Fields
    private static char[] _htmlEntityEndingChars = new char[] { ';', '&amp;' };
    private const char HIGH_SURROGATE_START = '\ud800';
    private const char LOW_SURROGATE_END = '\udfff';
    private const char LOW_SURROGATE_START = '\udc00';
    private const int UNICODE_PLANE00_END = 0xffff;
    private const int UNICODE_PLANE01_START = 0x10000;
    private const int UNICODE_PLANE16_END = 0x10ffff;
    private const int UnicodeReplacementChar = 0xfffd;

    private static void ConvertSmpToUtf16(uint smpChar, out char leadingSurrogate, out char trailingSurrogate)
    {
        int num = ((int)smpChar) - 0x10000;
        leadingSurrogate = (char)((num / 0x400) + 0xd800);
        trailingSurrogate = (char)((num % 0x400) + 0xdc00);
    }

    private static int HexToInt(char h)
    {
        if ((h &gt;= '0') &amp;&amp; (h &lt;= '9'))
        {
            return (h - '0');
        }
        if ((h &gt;= 'a') &amp;&amp; (h &lt;= 'f'))
        {
            return ((h - 'a') + 10);
        }
        if ((h &gt;= 'A') &amp;&amp; (h &lt;= 'F'))
        {
            return ((h - 'A') + 10);
        }
        return -1;
    }

    private static char IntToHex(int n)
    {
        if (n &lt;= 9)
        {
            return (char)(n + 0x30);
        }
        return (char)((n - 10) + 0x41);
    }

    private static bool IsUrlSafeChar(char ch)
    {
        if ((((ch &gt;= 'a') &amp;&amp; (ch &lt;= 'z')) || ((ch &gt;= 'A') &amp;&amp; (ch &lt;= 'Z'))) || ((ch &gt;= '0') &amp;&amp; (ch &lt;= '9')))
        {
            return true;
        }
        switch (ch)
        {
            case '(':
            case ')':
            case '*':
            case '-':
            case '.':
            case '_':
            case '!':
                return true;
        }
        return false;
    }

    public static string UrlEncode(string value)
    {
        if (value == null)
        {
            return null;
        }
        byte[] bytes = Encoding.UTF8.GetBytes(value);
        return Encoding.UTF8.GetString(UrlEncode(bytes, 0, bytes.Length, false));
    }
    private static bool ValidateUrlEncodingParameters(byte[] bytes, int offset, int count)
    {
        if ((bytes == null) &amp;&amp; (count == 0))
        {
            return false;
        }
        if (bytes == null)
        {
            //throw new ArgumentNullException("bytes");
        }
        if ((offset &lt; 0) || (offset &gt; bytes.Length))
        {
            //throw new ArgumentOutOfRangeException("offset");
        }
        if ((count &lt; 0) || ((offset + count) &gt; bytes.Length))
        {
            //throw new ArgumentOutOfRangeException("count");
        }
        return true;
    }

    private static byte[] UrlEncode(byte[] bytes, int offset, int count)
    {
        if (!ValidateUrlEncodingParameters(bytes, offset, count))
        {
            return null;
        }
        int num = 0;
        int num2 = 0;
        for (int i = 0; i &lt; count; i++)
        {
            char ch = (char)bytes[offset + i];
            if (ch == ' ')
            {
                num++;
            }
            else if (!IsUrlSafeChar(ch))
            {
                num2++;
            }
        }
        if ((num == 0) &amp;&amp; (num2 == 0))
        {
            return bytes;
        }
        byte[] buffer = new byte[count + (num2 * 2)];
        int num4 = 0;
        for (int j = 0; j &lt; count; j++)
        {
            byte num6 = bytes[offset + j];
            char ch2 = (char)num6;
            if (IsUrlSafeChar(ch2))
            {
                buffer[num4++] = num6;
            }
            else if (ch2 == ' ')
            {
                buffer[num4++] = 0x2b;
            }
            else
            {
                buffer[num4++] = 0x25;
                buffer[num4++] = (byte)IntToHex((num6 &gt;&gt; 4) &amp; 15);
                buffer[num4++] = (byte)IntToHex(num6 &amp; 15);
            }
        }
        return buffer;
    }

    private static byte[] UrlEncode(byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue)
    {
        byte[] buffer = UrlEncode(bytes, offset, count);
        if ((alwaysCreateNewReturnValue &amp;&amp; (buffer != null)) &amp;&amp; (buffer == bytes))
        {
            return (byte[])buffer.Clone();
        }
        return buffer;
    }

    public static byte[] UrlEncodeToBytes(byte[] value, int offset, int count)
    {
        return UrlEncode(value, offset, count, true);
    }
}</code></pre> 
<p> </p> 
<p><strong>持续更新...</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07794b43a679e5292b3d3f571c92f674/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">moduleName is declared but its value is never read.ts(6133)报错解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f998a58bf41b4afec561a29a9b595ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java ListResourceBundle getContents（）方法与示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>