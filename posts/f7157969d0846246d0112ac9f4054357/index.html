<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>A2DP Source如何从android系统拿到音频数据 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="A2DP Source如何从android系统拿到音频数据" />
<meta property="og:description" content="Android 13
简单来说就是两条本地socket通道，分别使用文件：
#define A2DP_CTRL_PATH &#34;/data/misc/bluedroid/.a2dp_ctrl&#34;
#define A2DP_DATA_PATH &#34;/data/misc/bluedroid/.a2dp_data&#34;
A2DP_CTRL_PATH是控制通道，A2DP_DATA_PATH是数据通道。
packages\modules\Bluetooth\system\audio_a2dp_hw\include\audio_a2dp_hw.h
1、首先需要关注一个文件 btif_a2dp_control.cc
// packages\modules\Bluetooth\system\btif\src\btif_a2dp_control.cc void btif_a2dp_control_init(void) { a2dp_uipc = UIPC_Init(); UIPC_Open(*a2dp_uipc, UIPC_CH_ID_AV_CTRL, btif_a2dp_ctrl_cb, A2DP_CTRL_PATH); } 里面的函数UIPC_Init
// packages\modules\Bluetooth\system\udrv\ulinux\uipc.cc std::unique_ptr&lt;tUIPC_STATE&gt; UIPC_Init() { std::unique_ptr&lt;tUIPC_STATE&gt; uipc = std::make_unique&lt;tUIPC_STATE&gt;(); LOG_DEBUG(&#34;UIPC_Init&#34;); std::lock_guard&lt;std::recursive_mutex&gt; lock(uipc-&gt;mutex); uipc_main_init(*uipc); uipc_start_main_server_thread(*uipc); return uipc; } 初始化一些uipc的变量，然后启动主线程uipc_read_task
int uipc_start_main_server_thread(tUIPC_STATE&amp; uipc) { uipc.running = 1; if (pthread_create(&amp;uipc.tid, (const pthread_attr_t*)NULL, uipc_read_task, &amp;uipc) != 0) { LOG_ERROR(&#34;uipc_thread_create pthread_create failed:%d&#34;, errno); return -1; } return 0; } 这里面的实现不太需要关注。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f7157969d0846246d0112ac9f4054357/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T18:24:05+08:00" />
<meta property="article:modified_time" content="2024-01-06T18:24:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">A2DP Source如何从android系统拿到音频数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Android 13</p> 
<p>简单来说就是两条本地socket通道，分别使用文件：</p> 
<p>#define A2DP_CTRL_PATH "/data/misc/bluedroid/.a2dp_ctrl"</p> 
<p>#define A2DP_DATA_PATH "/data/misc/bluedroid/.a2dp_data"</p> 
<p>A2DP_CTRL_PATH是控制通道，A2DP_DATA_PATH是数据通道。</p> 
<p><strong>packages\modules\Bluetooth\system\audio_a2dp_hw\include\audio_a2dp_hw.h</strong></p> 
<p>1、首先需要关注一个文件 btif_a2dp_control.cc</p> 
<pre><code class="language-cpp">// packages\modules\Bluetooth\system\btif\src\btif_a2dp_control.cc
void btif_a2dp_control_init(void) {
  a2dp_uipc = UIPC_Init();
  UIPC_Open(*a2dp_uipc, UIPC_CH_ID_AV_CTRL, btif_a2dp_ctrl_cb, A2DP_CTRL_PATH);
}</code></pre> 
<p>里面的函数UIPC_Init</p> 
<pre><code class="language-cpp">// packages\modules\Bluetooth\system\udrv\ulinux\uipc.cc

std::unique_ptr&lt;tUIPC_STATE&gt; UIPC_Init() {
  std::unique_ptr&lt;tUIPC_STATE&gt; uipc = std::make_unique&lt;tUIPC_STATE&gt;();
  LOG_DEBUG("UIPC_Init");

  std::lock_guard&lt;std::recursive_mutex&gt; lock(uipc-&gt;mutex);

  uipc_main_init(*uipc);
  uipc_start_main_server_thread(*uipc);

  return uipc;
}</code></pre> 
<p>初始化一些uipc的变量，然后启动主线程uipc_read_task</p> 
<pre><code class="language-cpp">int uipc_start_main_server_thread(tUIPC_STATE&amp; uipc) {
  uipc.running = 1;

  if (pthread_create(&amp;uipc.tid, (const pthread_attr_t*)NULL, uipc_read_task,
                     &amp;uipc) != 0) {
    LOG_ERROR("uipc_thread_create pthread_create failed:%d", errno);
    return -1;
  }

  return 0;
}</code></pre> 
<p>这里面的实现不太需要关注。</p> 
<p>2、UIPC_Open(UIPC_CH_ID_AV_CTRL, btif_a2dp_ctrl_cb);启动控制通道。注册回调btif_a2dp_ctrl_cb</p> 
<p>packages\modules\Bluetooth\system\btif\src\btif_a2dp_control.cc</p> 
<pre><code class="language-cpp">static void btif_a2dp_ctrl_cb(UNUSED_ATTR tUIPC_CH_ID ch_id,
                              tUIPC_EVENT event) {
  // Don't log UIPC_RX_DATA_READY_EVT by default, because it
  // could be very chatty when audio is streaming.
  if (event == UIPC_RX_DATA_READY_EVT) {
    APPL_TRACE_DEBUG("%s: A2DP-CTRL-CHANNEL EVENT %s", __func__,
                     dump_uipc_event(event));
  } else {
    APPL_TRACE_WARNING("%s: A2DP-CTRL-CHANNEL EVENT %s", __func__,
                       dump_uipc_event(event));
  }

  switch (event) {
    case UIPC_OPEN_EVT:
      break;

    case UIPC_CLOSE_EVT:
      /* restart ctrl server unless we are shutting down */
      if (btif_a2dp_source_media_task_is_running())
        UIPC_Open(*a2dp_uipc, UIPC_CH_ID_AV_CTRL, btif_a2dp_ctrl_cb,
                  A2DP_CTRL_PATH);
      break;

    case UIPC_RX_DATA_READY_EVT:
      btif_a2dp_recv_ctrl_data();
      break;

    default:
      APPL_TRACE_ERROR("%s: ### A2DP-CTRL-CHANNEL EVENT %d NOT HANDLED ###",
                       __func__, event);
      break;
  }
}</code></pre> 
<p>3、btif_a2dp_recv_ctrl_data(); 这个函数就是处理收到的控制指令，例如get configure，set configure、stream start、stream suspend等。</p> 
<p>4、当收到stream start的时候就会启动数据通道</p> 
<pre><code class="language-cpp">static void btif_a2dp_recv_ctrl_data(void) {
  tA2DP_CTRL_CMD cmd = A2DP_CTRL_CMD_NONE;
  int n;
    ...

  a2dp_cmd_pending = cmd;
  switch (cmd) {
        ...

    case A2DP_CTRL_CMD_START:
      btif_a2dp_command_ack(btif_a2dp_control_on_start());
      break;

        ...
}
</code></pre> 
<p> </p> 
<pre><code class="language-cpp">static tA2DP_CTRL_ACK btif_a2dp_control_on_start() {
  /*
   * Don't send START request to stack while we are in a call.
   * Some headsets such as "Sony MW600", don't allow AVDTP START
   * while in a call, and respond with BAD_STATE.
   */
  if (!bluetooth::headset::IsCallIdle()) {
    APPL_TRACE_WARNING("%s: A2DP command start while call state is busy",
                       __func__);
    return A2DP_CTRL_ACK_INCALL_FAILURE;
  }

  if (btif_a2dp_source_is_streaming()) {
    APPL_TRACE_WARNING("%s: A2DP command start while source is streaming",
                       __func__);
    return A2DP_CTRL_ACK_FAILURE;
  }

  if (btif_av_stream_ready()) {
    /* Setup audio data channel listener */
    UIPC_Open(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, btif_a2dp_data_cb,
              A2DP_DATA_PATH);

    /*
     * Post start event and wait for audio path to open.
     * If we are the source, the ACK will be sent after the start
     * procedure is completed, othewise send it now.
     */
    btif_av_stream_start();
    if (btif_av_get_peer_sep() == AVDT_TSEP_SRC) return A2DP_CTRL_ACK_SUCCESS;
  }

  if (btif_av_stream_started_ready()) {
    /*
     * Already started, setup audio data channel listener and ACK
     * back immediately.
     */
    UIPC_Open(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, btif_a2dp_data_cb,
              A2DP_DATA_PATH);
    return A2DP_CTRL_ACK_SUCCESS;
  }
  APPL_TRACE_WARNING("%s: A2DP command start while AV stream is not ready",
                     __func__);
  return A2DP_CTRL_ACK_FAILURE;
}
</code></pre> 
<p>5、启动数据通道后，会通过回调btif_a2dp_data_cb通知，进行一些必要的操作后（具体参考原生代码btif_a2dp_data_cb的实现），就可以使用UIPC_Read(UIPC_CH_ID_AV_AUDIO, &amp;event, p_buf, len);读取到数据了。这里如果要使用自己的蓝牙可以建立线程读取数据，当stream stop或者stream suspend时cancel掉线程即可</p> 
<p>6、注意：如果静音模式audio manager不会向控制发送stream start，所以如果其他指令都收到了没有收到stream start可以调节下声音试试。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/374cd765f9bf4050674a92e76c537ce6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【网络技术】【Kali Linux】Wireshark嗅探（八）动态主机配置协议（DHCP）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92b5c816927acae6a7c3e7e03378864e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">idea中使用Lombok 失效，@Slf4j 找不到符号的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>