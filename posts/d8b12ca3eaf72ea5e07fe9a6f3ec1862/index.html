<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>POJ 3279 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="POJ 3279" />
<meta property="og:description" content="Time limit2000 msMemory limit65536 kB Description Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an M × N grid (1 ≤ M ≤ 15; 1 ≤ N ≤ 15) of square tiles, each of which is colored black on one side and white on the other side.
As one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d8b12ca3eaf72ea5e07fe9a6f3ec1862/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-15T17:43:27+08:00" />
<meta property="article:modified_time" content="2019-01-15T17:43:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">POJ 3279</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>Time limit</td><td>2000 ms</td></tr><tr><td>Memory limit</td><td>65536 kB</td></tr></tbody></table> 
<h3> Description</h3> 
<p>Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an <em>M</em> × <em>N</em> grid (1 ≤ <em>M</em> ≤ 15; 1 ≤ <em>N</em> ≤ 15) of square tiles, each of which is colored black on one side and white on the other side.</p> 
<p>As one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white. The cows are rewarded when they flip the tiles so that each tile has the white side face up. However, the cows have rather large hooves and when they try to flip a certain tile, they also flip all the adjacent tiles (tiles that share a full edge with the flipped tile). Since the flips are tiring, the cows want to minimize the number of flips they have to make.</p> 
<p>Help the cows determine the minimum number of flips required, and the locations to flip to achieve that minimum. If there are multiple ways to achieve the task with the minimum amount of flips, return the one with the least lexicographical ordering in the output when considered as a string. If the task is impossible, print one line with the word "IMPOSSIBLE".</p> 
<h3>Input</h3> 
<p>Line 1: Two space-separated integers: <em>M</em> and <em>N</em><br> Lines 2.. <em>M</em>+1: Line <em>i</em>+1 describes the colors (left to right) of row i of the grid with <em>N</em> space-separated integers which are 1 for black and 0 for white</p> 
<h3>Output</h3> 
<p>Lines 1.. <em>M</em>: Each line contains <em>N</em> space-separated integers, each specifying how many times to flip that particular location.</p> 
<h3>Sample Input</h3> 
<pre>4 4
1 0 0 1
0 1 1 0
0 1 1 0
1 0 0 1</pre> 
<h3>Sample Output</h3> 
<pre>0 0 0 0
1 0 0 1
1 0 0 1
0 0 0 0</pre> 
<h3>题目描述</h3> 
<p>      题目的意思是，给你一个地图，上面有白色的瓦块（用0表示）和黑色的瓦块（用1表示），现在可以对瓦块进行反转，我想了下，这不是黑白棋吗？不过这个和黑白棋还是不一样的，在这里，若对其中一块瓦块进行反转，那么它的四周的瓦块也会进行反转，题目需要我们用到最小反转次数去让整个地图的瓦片变成白色的，最终输出的是对应位置的瓦块反转的次数，而且存在多个最优解的时候，要求让由输出的图组成的字符串按逆字典序小的图输出。</p> 
<p>      试想一下，如果反转的时候会让它的四周的瓦块同时发生反转，那么对于第一行，它不能通过只对这一行进行反转得到全白色瓦块，它只能通过第二行和第一行的反转进行结合，来让第一行的黑色瓦块变成白色瓦块；而对于最后一行的黑色瓦块，也只能通过倒数第二行和本行的结合让其中的黑色瓦块全部变成白色瓦块。</p> 
<p>       所以我们的方法是，先将第一排的所有可能的反转情况全部逆字典序地进行枚举，这样我们就可以在同为最少步骤的时候，不需要再进行判断了，因为在同一反转次数下，逆字典序最小的先得出了。然后我们对第二行行进行枚举，若在某一列的上方，比如(2,4)和(1,4)，如果上方有黑色的瓦块，那么只有通过这个位置的瓦块（此处为（2，4））进行反转，才可以让上方的瓦块变成白色。那么倒数第二行就很关键了，因为这一行造成的反转不仅要让倒数第三行的黑色瓦块变成白色瓦块，同时也要让最后一行的黑色瓦块变成白色瓦块，所以当我们利用最后一行，让倒数第二行的黑色瓦块全部变成了白色瓦块之后，如果此时最后一行的瓦块不全是白色的，说明这一操作的不成功。</p> 
<p>       如果通过上面的操作让整个地图变成了白色的话，就说明这一反转的方法可以成功。</p> 
<p>       为了能够输出结果，我们需要对进行反转的瓦块进行标记，由于同一块瓦片反转2次和没反转一样，所以我们规定每一块瓦块最多主动反转一次（作为中心块进行的反转），这一标记同时也代表了对地图上每一块瓦块的操作次数，可以作为答案输出，不过在此之前，我们需要统计一共进行了多少次的主动反转，然后找出最少的那一次输出，具体实现请看代码。</p> 
<h3>代码区</h3> 
<pre class="has"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;

using namespace std;

//对于这个数组大小，我很无奈，我取个刚刚好的长度，结果和我说不够用，哎
int map[17][17];						//实际地图
int choose[17][17];						//表示反转的情况
int m, n;

int to[5][2] = { {0,0} , {1,0} , {-1,0} , {0,1} , {0,-1} };	//表示要反转的，包括自己

int solve();

int main()
{
	
	scanf("%d%d", &amp;m, &amp;n);
	for(int i = 1 ;i &lt;=  m ; i ++)
	{
		for(int j = 1 ; j &lt;= n ; j ++)
		{
			scanf("%d", *(map + i) + j);			//节省时间，使用指针
		}
	}
	int Min = -1;									//-1代表不能反转成功，将Min设为-1，是因为我们无法确定最大值
	int goal[17][17];								//存储最终方案
	for(int i = 0 ; i &lt; (1&lt;&lt;n) ; i++)				//枚举第一行的2^n种反转方式
	{
		memset(choose, 0, sizeof(choose));			//表示对应的瓦块是否进行反转， 0 表示不反转，1，表示反转

		for (int j = 1; j  &lt;= n; j++)				//将i对应的值转化为二进制，比如i 为3 就是 0011 ，一共n位,不过我们需要进行逆转这个，由于是按逆字典序排序，
													                                                        //所以我们只需要考虑第一行，因为第一行的情况是独一无二的，所以第一行在枚举的时候自成逆字典序的话，那么就不需要多判断了


			choose[1][j] = (i &gt;&gt; (j - 1)) &amp; 1;		//记录第一行的不同的情况,

		int temp = solve();							//返回反转次数，但是由于调用了这一个函数，我们已经将反转的具体操作储存在choose中
		if(temp &gt;= 0 &amp;&amp; (temp &lt; Min || Min &lt; 0) )	        //通过异或判断可以有效地利用Min = -1 这个条件
		{
			Min = temp;
			memcpy(goal, choose,sizeof(choose));	        //将数据存在goal中
		}
	}
	if(Min == -1)
	{
		printf("IMPOSSIBLE\n");
	}
	else
	{
		for(int i = 1 ;i &lt;= m ; i ++)
		{
			printf("%d", goal[i][1]);
			for(int j = 2; j &lt;= n ; j ++)
			{
				printf(" %d", goal[i][j]);
			}
			cout &lt;&lt; endl;
		}
	}
	return 0;
}

//判断坐标为(x,y)的点的颜色，用0和1表示
int col(int x,int y)
{
	int s = map[x][y];				//先记录初始颜色
	for(int i = 0 ;i &lt; 5 ; i++)
	{
		int tx = x + to[i][0];
		int ty = y + to[i][1];
		s += choose[tx][ty];		        //choose[tx][ty]代表(tx,ty)的瓦块是否被反转过，由于颜色只用0,1表示，那么只需要加一个 1 就代表反转，加0表示不变
						        //而对于这个瓦块是否被反转，主要取决于他邻近的4个瓦块以及自身是否进行了反转
	}
	return s % 2;					//由于每加一代表一次颜色的反转，但是我们需要的只是0,1，所以在这里我们将之转化会用0，1表示
}

int solve()
{
	int sum = 0;					//记录反转的总次数
	for(int i = 2 ;i &lt;=m ; i++)			//从第二行开始枚举
	{
		for(int j = 1 ; j &lt;= n ; j ++)
		{
			if(col(i-1,j) == 1)		//这一块的上一块是黑色的，那么就对当前这块进行反转，来让上面的那一块变成白色
			{
				choose[i][j] = 1;	//对这一块进行反转，从而让这一块上面的瓦块变成白色
				sum++;			//代表反转次数加一
			}
		}
	}

	for(int i = 1 ; i &lt;= n ; i ++)
	{
		if(col(m,i))				//若最后一行有黑色的瓦块，说明这种方法是失败的
		{
			return -1;			//失败返回-1
		}
		sum += choose[1][i];			//顺便将第一行所用的步数加上
	}

	return  sum;					//成功返回反转的次数

}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eccbac720551883c0372f0428c68606b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">curl获取数据乱码问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c7403185e23b1f590458d2e6c964dcce/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">javascript 生成器和promise总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>