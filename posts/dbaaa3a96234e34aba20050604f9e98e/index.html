<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用 Docker-compose 搭建lnmp - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用 Docker-compose 搭建lnmp" />
<meta property="og:description" content="服务编排： 应用编排：
单机环境下：shell/python脚本多机/集群环境下：ansible、saltstack、pubbet docker容器编排：
单机：docker-compose多机/集群：docker swarm，mesos&#43; marathon，kubernetes 一、Docker-Compose简介 1.1 为什么使用 Docker-compose 我们知道使用一个Dockerfile模板文件可以定义一个单独的应用容器，如果需要定义多个容器就需要服务编排。服务编排有很多种技术方案，今天给大家介绍Docker 官方产品Docker Compose。
Dockerfile可以让用户管理一个单独的应用容器；而Compose则 允许用户在一个模板(YAML格式) 中定义一组相关联的应用容器( 被称为一个project，即项目)，例如一个Web服务容器再加上后端的数据库服务容器等。
1.2 Docker-compose概述 Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。
Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service） 以及容器（container）。Docker-Compose运行目录下的所有文件(docker-compose.yml，extends文件或环境变量文件等)组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务 发现及负载均衡，比如Consul。
Docker-Compose的工程配置文件默认为docker-compose. yml，可通过环境变量COMPOSE_FILE 或 -f 参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。
使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个Web项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。
Compose允许用户通过一个单独的docker-compose. yml模板文件（YAML格式）来定义一组相关联的应用容器为一个项目 (project) 。
Docker-Compose项目由Python编写，调用Docker服 务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。
二、compose 部署 2.1 Docker Compose 环境安装 Docker Compose是 Docker 的独立产品，因此需要安装 Docker 之后再单独安装Docker Compose。
#方法一：下载。 curl -L https://github.com/docker/compose/releases/download/1.21.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose #安装，给予执行权限 chmod &#43;x /usr/local/bin/docker-compose #查看版本 docker-compose --version ​ #方法二：也可以提前下载好安装包，之后上传到系统中。 cd /opt/ ls chmod &#43;x docker-compose mv docker-compose /usr/local/bin/ docker-compose --version 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dbaaa3a96234e34aba20050604f9e98e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-12T08:36:07+08:00" />
<meta property="article:modified_time" content="2023-06-12T08:36:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用 Docker-compose 搭建lnmp</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>服务编排：</h3> 
<p><strong>应用编排</strong>：</p> 
<ul><li>单机环境下：shell/python脚本</li><li>多机/集群环境下：ansible、saltstack、pubbet</li></ul> 
<p><strong>docker容器编排：</strong></p> 
<ul><li>单机：docker-compose</li><li>多机/集群：docker swarm，mesos+ marathon，kubernetes</li></ul> 
<h2>一、Docker-Compose简介</h2> 
<h3>1.1 为什么使用 Docker-compose</h3> 
<p>我们知道使用一个Dockerfile模板文件可以定义一个单独的应用容器，如果需要定义多个容器就需要服务编排。服务编排有很多种技术方案，今天给大家介绍Docker 官方产品Docker Compose。</p> 
<p>Dockerfile可以让用户管理一个单独的应用容器；而Compose则 允许用户在一个模板(YAML格式) 中定义一组相关联的应用容器( 被称为一个project，即项目)，例如一个Web服务容器再加上后端的数据库服务容器等。</p> 
<h3>1.2 Docker-compose概述</h3> 
<p>Docker-Compose项目是Docker官方的开源项目，<strong>负责实现对Docker容器集群的快速编排</strong>。</p> 
<p>Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service） 以及容器（container）。Docker-Compose运行目录下的所有文件(docker-compose.yml，extends文件或环境变量文件等)组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务 发现及负载均衡，比如Consul。</p> 
<p>Docker-Compose的工程配置文件默认为docker-compose. yml，可通过环境变量COMPOSE_FILE 或 -f 参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。</p> 
<p>使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个Web项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p> 
<p>Compose允许用户通过一个单独的docker-compose. yml模板文件（YAML格式）来定义一组相关联的应用容器为一个项目 (project) 。</p> 
<p>Docker-Compose项目由Python编写，调用Docker服 务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。</p> 
<h2>二、compose 部署</h2> 
<h3>2.1 Docker Compose 环境安装</h3> 
<p>Docker Compose是 Docker 的独立产品，因此需要安装 Docker 之后再单独安装Docker Compose。</p> 
<pre><code> #方法一：下载。
 curl -L https://github.com/docker/compose/releases/download/1.21.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
 #安装，给予执行权限
 chmod +x /usr/local/bin/docker-compose
 #查看版本
 docker-compose --version
 ​
 #方法二：也可以提前下载好安装包，之后上传到系统中。
 cd /opt/
 ls
 chmod +x docker-compose
 mv docker-compose /usr/local/bin/
 docker-compose --version
</code></pre> 
<h3>2.2 YAML文件格式及编写注意事项</h3> 
<h4>2.2.1 YAML文件格式</h4> 
<p>YAML是一种标记语言，它可以很直观的展示数据序列化格式，可读性高。类似于 json 数据描述语言，语法比 json简单的很多。</p> 
<ul><li>YAML数据结构通过缩进来表示</li><li>连续的项目通过减号来表示</li><li>键值对用冒号分隔</li><li>数组用中括号 [ ] 括起来</li><li>hash 用花括号 { } 括起来</li></ul> 
<pre><code> #一个键如果有多个值。符号可以不缩进，但值要缩进。
 name:
 - zhangsan
 - lisi
 - wangwu
 ​
 name:
  - zhangsan
  - lisi
  - wangwu
  
 name: ["zhangsan", "lisi", "wangwu"]
</code></pre> 
<h4>2.2.2 使用YAML时需要注意下面事项</h4> 
<ul><li>大小写敏感</li><li>通过缩进表示层级关系</li><li>不支持制表符tab键缩进T只能使用空格缩进</li><li>缩进的空格数目不重要，只要相同层级左对齐，通常开头缩进2个空格</li><li>用 # 号注释</li><li>符号字符后缩进1个空格，如"冒号 : "、 "逗号 ，"、"横杠 - "</li><li>如果包含特殊字符用单引号(' ')引起来会作为普通字符串处理，双引号(" ")：特殊字符作为本身想表示的意思</li></ul> 
<pre><code> #双引号示例：
 name: "hello, \nworld"
 最后name值是两行内容
 name: hello,
       world
 ​
 #单引号示例：
 name: 'hello, \nworld'，只会作为普通字符 name: hello,\nworld</code></pre> 
<h4>2.2.3 数据结构</h4> 
<pre><code> #对象: 键值对的字典
 animal: pets
 ​
 #数组: 一组按次序排列的列表
 - cat
 - dog
 - goldfish
 ​
 #布尔值
 debug: "true"
 debug: "false"
 ​
 ​
 #Yaml示例
 languages:      #序列的映射
   - Java
   - Golang
   - Python
 websites:       #映射的映射（键的值，仍然是键值对）
   Baidu: www.baidu.com
   Wangyi: www.163.com
   Souhu: www.souhu.com
  
  
 #或者 
 languages: ["Java","Golong","Python"]
 websites: 
   Baidu: 
     www.baidu.com
   Wangyi: 
     www.163.com
   Souhu: 
     www.souhu.com
     
  
 #Json格式
 {
   languages: [
     'Java',
     'Golong',
     'Python',
   ],
   websites: [
     Baidu: 'www.baidu.com',
     Wangyi: 'www.163.com',
     Souhu: 'www.souhu.com',
   ]
 }
</code></pre> 
<h3>2.3 Docker Compose 配置常用字段</h3> 
<table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>build</td><td>使用Dockerfile构建镜像。指定Dockerfile 文件名，要指定Dockerfile文件需要在bui ld标签的子级标签中使用dockerfile标签指定</td></tr><tr><td>dockerfile</td><td>构建镜像上下文路径（指定Dockerfile文件）</td></tr><tr><td>context</td><td>可以是dockerfile 的路径，或者是指向git 仓库的url地址</td></tr><tr><td>image</td><td>指定镜像</td></tr><tr><td>command</td><td>执行命令，覆盖容器启动后默认执行的命令（类似于 docker run）</td></tr><tr><td>container_name</td><td>指定容器名称，由于容器名称是唯一的， 如果指定自定义名称，则无法scale指定容器数量（同一个镜像指定多个容器数量）</td></tr><tr><td>deploy</td><td>指定部署和运行服务相关的配置，只能在Swarm模式使用</td></tr><tr><td>environment</td><td>添加环境变量</td></tr><tr><td>networks</td><td>加入网络，引用顶级networks下条目</td></tr><tr><td>networks_mode</td><td>设置容器的网络模式，如 host，bridge</td></tr><tr><td>ports</td><td>暴露容器端口，与-p相同，但端口不能低于60</td></tr><tr><td>volumes</td><td>挂载一个宿主机目录或命令卷到容器中，命令卷要在顶级volumes定义卷名称</td></tr><tr><td>volumes_from</td><td>从另一个服务或容器挂载卷，可选参数:ro 和:rw。仅版本'2' 支持</td></tr><tr><td>hostname</td><td>容器主机名</td></tr><tr><td>sysctls</td><td>在容器内设置内核参数</td></tr><tr><td>links</td><td>连接到另外一个容器，- 服务名称[:服务别名] （类似于容器互联）</td></tr><tr><td>privileged</td><td>用来给容器root权限，注意是不安全的，只有两个值：true或false</td></tr><tr><td>restart</td><td>设置重启策略，never，always, no-failure， unless-stopped</td></tr><tr><td></td><td>never，默认策略，在容器退出时不重启容器。</td></tr><tr><td></td><td>on-failure，在容器非正常退出时(退出状态非0)，才会重启容器。</td></tr><tr><td></td><td>on-failure:3，在容器非正常退出时重启容器，最多重启3次。</td></tr><tr><td></td><td>always，在容器退出时总是重启容器。</td></tr><tr><td></td><td>unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器。</td></tr><tr><td>depends_on</td><td>在使用Compose时，最大的好处就是少打启动命令，但一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，可能会因为容器依赖问题而启动失败。例如在没启动数据库容器的时候启动应用容器，应用容器会因为找不到数据库而退出。depends_on标签用于解决容器的依赖、启动先后的问题。</td></tr></tbody></table> 
<p><strong>（1）depends_on 指定依赖关系和启动顺序</strong></p> 
<pre><code> php:
   depends_on:
     - apache
     - mysql</code></pre> 
<p><strong>（2）使用镜像</strong></p> 
<ul><li>如果想使用已存在的镜像，使用image。</li><li>如果想使用自己构建的镜像，使用build、dockerfile、context。</li></ul> 
<p><strong>（3）引用网络</strong></p> 
<p>在顶级层设置两个网络模式，在服务中引用不同的网络，可以实现网络的隔离，和网络的兼容。（可以理解为vlan）</p> 
<pre><code> networks:
   lnmp
   lamp
   
 service:
   nginx:
     networks:lnmp
     
   apache:
     networks:lamp
     
   mysql:
     networks:
       lnmp
       lamp
       
   php:
     networks:
       lnmp
       lamp 
</code></pre> 
<p><strong>（4）命令卷</strong></p> 
<p>在 <code>version 3</code>，可以在顶级层中定义一个命令卷（例如：db-data），db-data 作为一个中间件，实际并不存在，只是为了做数据同步。（可以理解为vlan）</p> 
<pre><code> version: "3"
 ​
 services:
 ​
   nginx:
     volumes:
     - db_data:/var/lib/db
     
   mysql:
     volumes:
     - db_data:/var/lib/backup/data
 ​
 volumes:       #在顶级层定义一个命令卷
   db_data:
</code></pre> 
<h3>2.4 Docker Compose 常用命令</h3> 
<table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>build</td><td>重新构建服务</td></tr><tr><td>ps</td><td>列出容器</td></tr><tr><td>up</td><td>创建和启动容器</td></tr><tr><td>exec</td><td>在容器里面执行命令</td></tr><tr><td>scale</td><td>指定一个服务容器启动数量</td></tr><tr><td>top</td><td>显示容器进程</td></tr><tr><td>logs</td><td>查看容器输出</td></tr><tr><td>down</td><td>删除容器、网络、数据卷和镜像</td></tr><tr><td>stop/start/restart</td><td>停止/启动/重启服务</td></tr></tbody></table> 
<p></p> 
<h2>三、使用Docker-compose 搭建lnmp</h2> 
<h3>3.1 Docker Compose 文件结构</h3> 
<pre><code> [root@zy7 compose_lnmp]# yum -y install tree
 ​
 [root@zy7 compose_lnmp]# tree /opt/compose_lnmp/ -L 2
 /opt/compose_lnmp/
 ├── docker-compose.yml
 ├── mysql                            #创建模板脚本
 │   ├── Dockerfile                   #创建容器脚本
 │   ├── my.cnf                       #复制配置文件
 │   └── mysql-boost-5.7.20.tar.gz    #复制源码包
 ├── nginx
 │   ├── Dockerfile
 │   └── nginx-1.12.0.tar.gz
 ├── php
 │   ├── Dockerfile
 │   └── php-7.1.10.tar.bz2
 └── wwwroot
     ├── index.html                   #站点网页
     ├── wordpress                          
     └── wordpress-4.9.4-zh_CN.tar.gz
</code></pre> 
<h3>3.2 准备依赖文件，配置nginx</h3> 
<pre><code> #创建项目目录 compose_lnmp; 
 #创建服务子目录
 [root@zy7 ~]# mkdir /opt/compose_lnmp/
 [root@zy7 ~]# cd /opt/compose_lnmp
 [root@zy7 compose_lnmp]# mkdir nginx mysql php wwwroot
 ​
 #上传wordpress软件包，准备测试页面
 [root@zy7 compose_lnmp]# cd /opt/compose_nginx/wwwroot/
 [root@zy7 wwwroot]# ls
 wordpress-4.9.4-zh_CN.tar.gz
 [root@zy7 wwwroot]# tar xf wordpress-4.9.4-zh_CN.tar.gz  
 [root@zy7 wwwroot]# echo "&lt;h1&gt;this is test web&lt;/h1&gt;" &gt; /opt/compose_lnmp/wwwroot/index.html
 ​
 ​
 #上传nginx软件包
 [root@zy7 compose_lnmp]# cd nginx/
 [root@zy7 nginx]# ls
 nginx-1.12.0.tar.gz 
 ​
 ​
 #编写nginx的Dockerfile文件
 [root@zy7 nginx]# vim Dockerfile
 #基于基础镜像
 FROM centos:7
 #用户信息
 MAINTAINER this is nginx image &lt;yuji&gt;
 #添加环境包
 RUN yum -y install pcre-devel zlib-devel gcc gcc-c++ make
 RUN useradd -M -s /sbin/nologin nginx
 #上传nginx软件压缩包，并解压
 ADD nginx-1.12.0.tar.gz /usr/local/src/
 #指定工作目录
 WORKDIR /usr/local/src/nginx-1.12.0
 RUN ./configure \
 --prefix=/usr/local/nginx \
 --user=nginx \
 --group=nginx \
 --with-http_stub_status_module &amp;&amp; make -j8&amp;&amp; make install
 ENV PATH /usr/local/nginx/sbin:$PATH
 #修改nginx配置文件
 RUN sed -i 's/#charset koi8-r;/charset utf-8;/' /usr/local/nginx/conf/nginx.conf \
 &amp;&amp; sed -i '45 s/index  index.html index.htm;/index  index.html index.php;/' /usr/local/nginx/conf/nginx.conf \
 &amp;&amp; sed -i '65,71 s/#//' /usr/local/nginx/conf/nginx.conf \
 &amp;&amp; sed -i 's/fastcgi_pass   127.0.0.1:9000;/fastcgi_pass   172.18.0.30:9000;/' /usr/local/nginx/conf/nginx.conf \
 &amp;&amp; sed -i 's#/scripts#/usr/local/nginx/html#' /usr/local/nginx/conf/nginx.conf
 #也可以提前将修改好nginx.conf，放入nginx目录下，之后使用ADD指令复制到镜像中。则可避免在镜像中修改。
 #暴露端口
 EXPOSE 80
 EXPOSE 443
 #前台启动nginx
 ENTRYPOINT [ "/usr/local/nginx/sbin/nginx", "-g", "daemon off;" ]
</code></pre> 
<h3>3.3 配置mysql</h3> 
<pre><code> #进入mysql子目录
 [root@zy7 ~]# cd /opt/compose_lnmp/mysql/
 #将mysql包上传到此目录
 [root@zy7 mysql]# ls
 mysql-boost-5.7.20.tar.gz
 ​
 #编写mysql的Dockerfile文件
 [root@zy7 mysql]# vim Dockerfile
 FROM centos:7
 MAINTAINER this is mysql image &lt;zhi&gt;
 RUN yum -y install gcc gcc-c++ ncurses ncurses-devel bison cmake make
 RUN useradd -M -s /sbin/nologin  mysql
 ADD mysql-boost-5.7.20.tar.gz /usr/local/src/
 WORKDIR /usr/local/src/mysql-5.7.20/
 RUN cmake \
 -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \
 -DMYSQL_UNIX_ADDR=/usr/local/mysql/mysql.sock \
 -DSYSCONFDIR=/etc \
 -DSYSTEMD_PID_DIR=/usr/local/mysql \
 -DDEFAULT_CHARSET=utf8  \
 -DDEFAULT_COLLATION=utf8_general_ci \
 -DWITH_INNOBASE_STORAGE_ENGINE=1 \
 -DWITH_ARCHIVE_STORAGE_ENGINE=1 \
 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \
 -DWITH_PERFSCHEMA_STORAGE_ENGINE=1 \
 -DMYSQL_DATADIR=/usr/local/mysql/data \
 -DWITH_BOOST=boost \
 -DWITH_SYSTEMD=1 &amp;&amp; make -j8 &amp;&amp; make install
 RUN chown -R mysql:mysql /usr/local/mysql/
 ADD my.cnf /etc/
 RUN chown mysql:mysql /etc/my.cnf
 ENV PATH /usr/local/mysql/bin:/usr/local/mysql/lib:$PATH
 WORKDIR /usr/local/mysql/
 RUN bin/mysqld \
 --initialize-insecure \
 --user=mysql \
 --basedir=/usr/local/mysql \
 --datadir=/usr/local/mysql/data
 RUN cp /usr/local/mysql/usr/lib/systemd/system/mysqld.service /usr/lib/systemd/system/
 EXPOSE 3306
 CMD /usr/local/mysql/bin/mysqld
</code></pre> 
<p><strong>编写myslq主配置文件my.cnf</strong></p> 
<pre><code> #配置myslq主配置文件my.cnf（用来复制到容器）
 [root@zy7 mysql]# vim my.cnf 
 [client]
 port = 3306
 socket = /usr/local/mysql/mysql.sock
 ​
 [mysql]
 port = 3306
 socket = /usr/local/mysql/mysql.sock
 ​
 [mysqld]
 user = mysql
 basedir = /usr/local/mysql
 datadir = /usr/local/mysql/data
 port = 3306
 character_set_server=utf8
 pid-file = /usr/local/mysql/mysqld.pid
 socket = /usr/local/mysql/mysql.sock
 server-id = 1
 ​
 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_AUTO_VALUE_ON_ZERO,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,PIPES_AS_CONCAT,ANSI_QUOTES
</code></pre> 
<h3>3.4 配置php</h3> 
<pre><code> [root@zy7 compose_lnmp]# cd /opt/compose_lnmp/php/
 #将php包上传
 [root@zy7 php]# ls
 php-7.1.10.tar.bz2
 ​
 #编写php的Dockerfile
 [root@zy7 php]# vim Dockerfile
 FROM centos:7
 MAINTAINER this is php image &lt;yuji&gt;
 RUN yum -y install gd \
 libjpeg libjpeg-devel \
 libpng libpng-devel \
 freetype freetype-devel \
 libxml2 libxml2-devel \
 zlib zlib-devel \
 curl curl-devel \
 openssl openssl-devel \
 gcc gcc-c++ make pcre-devel
 RUN useradd -M -s /sbin/nologin nginx
 ADD php-7.1.10.tar.bz2 /usr/local/src/
 WORKDIR /usr/local/src/php-7.1.10
 RUN ./configure \
 --prefix=/usr/local/php \
 --with-mysql-sock=/usr/local/mysql/mysql.sock \
 --with-mysqli \
 --with-zlib \
 --with-curl \
 --with-gd \
 --with-jpeg-dir \
 --with-png-dir \
 --with-freetype-dir \
 --with-openssl \
 --enable-fpm \
 --enable-mbstring \
 --enable-xml \
 --enable-session \
 --enable-ftp \
 --enable-pdo \
 --enable-tokenizer \
 --enable-zip &amp;&amp; make &amp;&amp; make install
 ENV PATH /usr/local/php/bin:/usr/local/php/sbin:$PATH
 ​
 RUN \cp /usr/local/src/php-7.1.10/php.ini-development /usr/local/php/lib/php.ini \
 &amp;&amp; sed -i 's#mysqli.default_socket =#mysqli.default_socket = /usr/local/mysql/mysql.sock#' /usr/local/php/lib/php.ini \
 &amp;&amp; sed -i '939 s#;date.timezone =#date.timezone = Asia/Shanghai#' /usr/local/php/lib/php.ini
 ​
 RUN \cp /usr/local/php/etc/php-fpm.conf.default  /usr/local/php/etc/php-fpm.conf \
 &amp;&amp; sed -i '17 s/^;//' /usr/local/php/etc/php-fpm.conf
 ​
 RUN \cp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf \
 &amp;&amp; sed -i 's#user = nobody#user = nginx#' /usr/local/php/etc/php-fpm.d/www.conf \
 &amp;&amp; sed -i 's#group = nobody#group = nginx#' /usr/local/php/etc/php-fpm.d/www.conf \  &amp;&amp; sed -i 's#listen = 127.0.0.1:9000#listen = 172.18.0.30:9000#' /usr/local/php/etc/php-fpm.d/www.conf
 ​
 #也可以提前准备好php.ini、php-fpm.conf、www.conf这三个文件，放入php目录下，之后使用ADD指令复制到镜像中
 ​
 EXPOSE 9000
 ENTRYPOINT [ "/usr/local/php/sbin/php-fpm", "-F" ]
</code></pre> 
<h3>3.5 编写docker-compose.yml</h3> 
<pre><code> #先拉取镜像centos:7
 [root@zy7 compose_lnmp]# docker pull centos:7
 ​
 [root@zy7 compose_lnmp]# vim /opt/compose_lnmp/docker-compose.yml
 #使用版本2（3版本不支持指令volumes_from)
 version: '2'
 ​
 #使用services定义服务
 services:
   #配置nginx服务
   nginx:
     #设置容器名
     container_name: nginx
     #设置主机名为nginx
     hostname: nginx
     #使用dockerfile创建镜像。Dockerfile文件在当前目录的nginx目录下，文件名为Dockerfile
     build:
       #指定Dockerfile文件所在位置
       context: ./nginx
       dockerfile: Dockerfile
     #映射端口
     ports:
       - 1315:80
       - 1316:443
     #加入到lnmp网络中，使用ip172.18.0.0.10
     networks:
       lnmp:
         ipv4_address: 172.18.0.10
     #将当前目录下的wwwroot目录挂载到容器的/usr/local/nginx/html目录
     volumes:
       - ./wwwroot/:/usr/local/nginx/html
   
   #配置服务mysql
   mysql:
     container_name: mysql
     hostname: mysql
     build:
       context: ./mysql
       dockerfile: Dockerfile
     ports:
       - 3306:3306
     networks:
       lnmp:
         ipv4_address: 172.18.0.20
     #设置/usr/local/mysql目录为数据卷
     volumes:
       - /usr/local/mysql
       
   #配置服务php    
   php:
     hostname: php
     build:
       context: ./php
       dockerfile: Dockerfile
     container_name: php
     ports:
       - 9000:9000
     networks:
       lnmp:
         ipv4_address: 172.18.0.30
     #从nginx容器和mysql容器获取数据卷    
     volumes_from:
       - nginx
       - mysql
     #php容器需要在nginx和mysql之后启动  
     depends_on:
       - nginx
       - mysql
     #php和容器nginx，容器mysql连接   
     links:
       - nginx
       - mysql
 
 #设置网络为自定义网络
 #配置网络模式和网络名      
 networks:
   #设置网络名lnmp
   lnmp:
     #网络模式为bridge桥接模式
     driver: bridge
     ipam:
       config:
         #使用的网段为172.18.0.0/16
         - subnet: 172.18.0.0/16
</code></pre> 
<p><strong>运行docker-compose</strong></p> 
<pre><code> #在工作目录使用此命令。
 #-f： --file-name, 指定模板文件。默认为docker-compose.yml
 #-p: --project-name NAME ，指定项目名称，默认使用目录名
 #-d： 在后台运行
 [root@zy7 compose_lnmp]# docker-compose -f docker-compose.yml up -d
 ​
 #在工作目录，使用 docker-compose ps 可以看到启动的容器状态
 [root@zy7 compose_lnmp]# docker-compose ps
</code></pre> 
<p><strong>进入mysql容器，进行用户授权</strong></p> 
<pre><code> #进入mysql容器，进行用户授权。
 [root@zy7 mysql]# docker exec -it mysql /bin/bash
 [root@mysql mysql]# mysql
 ​
 mysql&gt; create database wordpress;
 ​
 mysql&gt; grant all privileges on wordpress.* to 'wordpress'@'%' identified by 'abc123';
 ​
 mysql&gt; grant all privileges on *.* to 'root'@'%' identified by 'abc123';
 ​
 mysql&gt; flush privileges;
</code></pre> 
<h3>3.6 浏览器访问测试</h3> 
<pre><code> http://192.168.126.27:1315/wordpress/index.php   #在yaml文件中nginx端口映射为1315
 ​
 http://192.168.126.27:1315/    #直接访问，可以看见创建的测试网页</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee58ece49c675477e8ec6a813a25eb43/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32/51单片机实训day6（二）——Proteus8.6版本&#43;STM32F103驱动LCD128x64显示信息｜Keil5程序设计｜串行并行通信笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/804104399e1098b7f221c7ae61f85b61/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">轻量级网络MobileNeXt--改进MobileNet v2的逆残差结构</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>