<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OpenCV实践小项目(一): 信用卡数字识别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OpenCV实践小项目(一): 信用卡数字识别" />
<meta property="og:description" content="1. 写在前面 今天整理一个OpenCV实践的小项目， 前几天整理了一篇OpenCV处理图像的知识笔记，后面，就通过一些小项目把这些知识运用到实践中去，一个是加深理解，另一个是融会贯通，连成整体，因为我发现，如果这些东西不用的话，其实很快就会忘掉。 另外，就是我发现这些实践小项目非常使用，有些代码或者图像的处理技巧可以为以后所用，所以这也是我想整理下来的原因。
第一个实践项目是信用卡数字识别，就是给定一张信用卡， 做出下面的这种效果：
这个项目用到的知识其实在很多其他场景也会遇到，比如像车牌号识别检测，数字识别等，所以感觉还是比较实用的。 但其实， 本质上用到的知识并不复杂，完全是前面整理的OpenCV基本图像操作，那么究竟是如何做到的那？
下面首先分析这个项目的宏观实现逻辑，也就是拿到这样的一个小任务应该大致上怎么思考，然后给出具体的做法以及代码解释。
2. 实现逻辑 给定一个信用卡，最终要输出上面的卡号，且需要在原图中把卡号的位置圈出来。 本质上，这是一个模板匹配任务，如果想让计算机认识数字，我们需要给定一个模板，比如下面这个：
这样， 我们只要找到信用卡上的数字区域，然后拿着数字区域的数字一一与模板进行匹配，看看到底是啥数字，就能识别出来了。 但是，对于信用卡来说我们需要找到它的数字区域呀，对于给定的模板，我们虽然有它的数字区域，但是也得分割成一个个的数字，才能进行匹配工作呀，所以该任务，就转成了处理信用卡， 处理模板以及模板匹配三个子问题。 、
想起了小学学过的一篇课文《走一步，再走一步》。
如何处理信用卡，找到数字区域呢？ 大致上思路如下：
使用轮廓检测算法，找到每个对象的大致轮廓以及外接矩形，即先定位到各个对象找到对象轮廓之后，根据外接矩形的长宽比例，找到中间的这一长串数字部分，由于这个轮廓比较长比较窄，所以还是比较好找的对于这一长串数字，用形态学操作使其更加突出，让这部分更加精准接下来，对于这一部分，再次进行轮廓检测，分割成了四个小块，对于每个小块再进行轮廓检测，就能得到每个具体的数字了对于每个数字，与模板进行匹配(直接有函数可用)，就知道是几了。 如果处理模板呢？这个很简单。轮廓检测一次，就能找到这10个对象，然后给每个对象赋予值，然后建立成一个字典即可。
下面就一步一步的进行代码解释。
3. 处理模板图像 模板图像先进行三步操作： 读入 -&gt; 转成灰度图 -&gt; 二值化， 因为轮廓检测函数接收的是二值图。
# 读取模板图像 img = cv2.imread(&#34;images/ocr_a_reference.png&#34;) # 读取的时候转灰度 cv2.imread(&#34;images/ocr_a_reference.png&#34;, 0) # 转成灰度图 template = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 二值图像 template = cv2.threshold(template, 10, 255, cv2.THRESH_BINARY_INV)[1] 结果如下：
接下来，用cv2的轮廓检测函数拿到10个数字的轮廓
cv2.findContours()函数接受的参数为二值图， 即黑白图像(不是灰度图), cv2.RETR_EXTERNAL只检测外轮廓， cv2.CHAIN_APPROX_SIMPLE只保留终点坐标
# 最新版opencv只返回两个值了 3.2之后， 不会返回原来的二值图像了，直接返回轮廓信息和层级信息 contourss, hierarchy = cv2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f02d99728ad2b71ef88206da0e20139f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-28T16:34:11+08:00" />
<meta property="article:modified_time" content="2022-03-28T16:34:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenCV实践小项目(一): 信用卡数字识别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1__0"></a>1. 写在前面</h3> 
<p>今天整理一个OpenCV实践的小项目， 前几天整理了一篇<a href="https://blog.csdn.net/wuzhongqiang/article/details/123680343?spm=1001.2014.3001.5501">OpenCV处理图像的知识笔记</a>，后面，就通过一些小项目把这些知识运用到实践中去，一个是加深理解，另一个是融会贯通，连成整体，因为我发现，如果这些东西不用的话，其实很快就会忘掉。 另外，就是我发现这些实践小项目非常使用，有些代码或者图像的处理技巧可以为以后所用，所以这也是我想整理下来的原因。</p> 
<p>第一个实践项目是信用卡数字识别，就是给定一张信用卡， 做出下面的这种效果：</p> 
<p><img src="https://images2.imgbox.com/f6/81/1ibFFGyJ_o.png" alt="在这里插入图片描述"><br> 这个项目用到的知识其实在很多其他场景也会遇到，比如像车牌号识别检测，数字识别等，所以感觉还是比较实用的。 但其实， 本质上用到的知识并不复杂，完全是前面整理的OpenCV基本图像操作，那么究竟是如何做到的那？</p> 
<p>下面首先分析这个项目的宏观实现逻辑，也就是拿到这样的一个小任务应该大致上怎么思考，然后给出具体的做法以及代码解释。</p> 
<h3><a id="2__10"></a>2. 实现逻辑</h3> 
<p>给定一个信用卡，最终要输出上面的卡号，且需要在原图中把卡号的位置圈出来。 本质上，这是一个<strong>模板匹配任务</strong>，如果想让计算机认识数字，我们需要给定一个模板，比如下面这个：</p> 
<p><img src="https://images2.imgbox.com/dd/88/3UAvHP7l_o.png" alt="在这里插入图片描述"><br> 这样， 我们只要找到信用卡上的数字区域，然后拿着数字区域的数字一一与模板进行匹配，看看到底是啥数字，就能识别出来了。 但是，对于信用卡来说我们需要找到它的数字区域呀，对于给定的模板，我们虽然有它的数字区域，但是也得分割成一个个的数字，才能进行匹配工作呀，所以该任务，就转成了处理信用卡， 处理模板以及模板匹配三个子问题。 、</p> 
<p>想起了小学学过的一篇课文《走一步，再走一步》。</p> 
<p>如何处理信用卡，找到数字区域呢？ 大致上思路如下：</p> 
<ol><li>使用轮廓检测算法，找到每个对象的大致轮廓以及外接矩形，即先定位到各个对象</li><li>找到对象轮廓之后，根据外接矩形的长宽比例，找到中间的这一长串数字部分，由于这个轮廓比较长比较窄，所以还是比较好找的</li><li>对于这一长串数字，用形态学操作使其更加突出，让这部分更加精准</li><li>接下来，对于这一部分，再次进行轮廓检测，分割成了四个小块，对于每个小块再进行轮廓检测，就能得到每个具体的数字了</li><li>对于每个数字，与模板进行匹配(直接有函数可用)，就知道是几了。</li></ol> 
<p>如果处理模板呢？这个很简单。轮廓检测一次，就能找到这10个对象，然后给每个对象赋予值，然后建立成一个字典即可。</p> 
<p>下面就一步一步的进行代码解释。</p> 
<h3><a id="3__29"></a>3. 处理模板图像</h3> 
<p>模板图像先进行三步操作： <code>读入 -&gt; 转成灰度图 -&gt; 二值化</code>， 因为轮廓检测函数接收的是二值图。</p> 
<pre><code class="prism language-python"><span class="token comment"># 读取模板图像</span>
img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"images/ocr_a_reference.png"</span><span class="token punctuation">)</span>   <span class="token comment"># 读取的时候转灰度 cv2.imread("images/ocr_a_reference.png", 0)</span>
<span class="token comment"># 转成灰度图</span>
template <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>
<span class="token comment"># 二值图像</span>
template <span class="token operator">=</span> cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>template<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>THRESH_BINARY_INV<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre> 
<p>结果如下：<br> <img src="https://images2.imgbox.com/61/c3/ysgu3x1R_o.png" alt="在这里插入图片描述"></p> 
<p>接下来，用cv2的轮廓检测函数拿到10个数字的轮廓</p> 
<blockquote> 
 <p><code>cv2.findContours()</code>函数接受的参数为二值图， 即黑白图像(不是灰度图), <code>cv2.RETR_EXTERNAL</code>只检测外轮廓， <code>cv2.CHAIN_APPROX_SIMPLE</code>只保留终点坐标</p> 
</blockquote> 
<pre><code class="prism language-python"><span class="token comment"># 最新版opencv只返回两个值了 3.2之后， 不会返回原来的二值图像了，直接返回轮廓信息和层级信息</span>
contourss<span class="token punctuation">,</span> hierarchy <span class="token operator">=</span> cv2<span class="token punctuation">.</span>findContours<span class="token punctuation">(</span>template<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>RETR_EXTERNAL<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>CHAIN_APPROX_SIMPLE<span class="token punctuation">)</span>

<span class="token builtin">len</span><span class="token punctuation">(</span>contourss<span class="token punctuation">)</span>  <span class="token comment"># 10个轮廓</span>
</code></pre> 
<p>效果如下：<br> <img src="https://images2.imgbox.com/5b/d8/591FgB6O_o.png" alt="在这里插入图片描述"><br> 这样就找到了每个数字的外轮廓，一个10个，但是要注意下，这10个轮廓的排列顺序并不一定是按照上面这个0-9的轮廓对应着来的，所以为了保险起见，我们需要根据每个轮廓左上角的坐标值，先从小到大排序。</p> 
<pre><code class="prism language-python"><span class="token comment"># 下面将轮廓进行排序，这是因为必须保证轮廓的顺序是0-9的顺序排列着</span>
<span class="token keyword">def</span> <span class="token function">sort_contours</span><span class="token punctuation">(</span>cnts<span class="token punctuation">,</span> method<span class="token operator">=</span><span class="token string">'left-to-right'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    reverse <span class="token operator">=</span> <span class="token boolean">False</span>
    i <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">if</span> method <span class="token operator">==</span> <span class="token string">'right-to-left'</span> <span class="token keyword">or</span> method <span class="token operator">==</span> <span class="token string">'bottom-to-top'</span><span class="token punctuation">:</span>
        reverse <span class="token operator">=</span> <span class="token boolean">True</span>
    <span class="token keyword">if</span> method <span class="token operator">==</span> <span class="token string">'top-to-bottom'</span> <span class="token keyword">or</span> method <span class="token operator">==</span> <span class="token string">'bottom-to-top'</span><span class="token punctuation">:</span>
        i <span class="token operator">=</span> <span class="token number">1</span>
    
    boundingBoxes <span class="token operator">=</span> <span class="token punctuation">[</span>cv2<span class="token punctuation">.</span>boundingRect<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> cnts<span class="token punctuation">]</span>  <span class="token comment"># 用一个最小矩形，把找到的形状包起来x,y,h,w</span>
    
    <span class="token comment"># 根据每个轮廓左上角的点进行排序， 这样能保证轮廓的顺序就是0-9的数字排列顺序</span>
    <span class="token punctuation">(</span>cnts<span class="token punctuation">,</span> boundingBoxes<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">zip</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">sorted</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>cnts<span class="token punctuation">,</span> boundingBoxes<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span>reverse<span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    <span class="token keyword">return</span> cnts<span class="token punctuation">,</span> boundingBoxes 

refCnts <span class="token operator">=</span> sort_contours<span class="token punctuation">(</span>contourss<span class="token punctuation">,</span> method<span class="token operator">=</span><span class="token string">'left-to-right'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  
</code></pre> 
<p>这样每个轮廓就按照0-9排列好了， 那下面思路就很清晰了，遍历每个轮廓对象，给他附上真正的数字即可，即建立<code>数字-&gt;轮廓</code>的关联映射。</p> 
<pre><code class="prism language-python"><span class="token comment"># 每个轮廓进行数字编号</span>
digits2Cnt <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment"># 遍历每个轮廓</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> c <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>refCnts<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 计算外接矩形，并且resize成合适大小</span>
    <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token operator">=</span> cv2<span class="token punctuation">.</span>boundingRect<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    <span class="token comment"># 单独把每个数字框拿出来 坐标系竖着的是y， 横着的是x</span>
    roi <span class="token operator">=</span> template<span class="token punctuation">[</span>y<span class="token punctuation">:</span>y<span class="token operator">+</span>h<span class="token punctuation">,</span> x<span class="token punctuation">:</span>x<span class="token operator">+</span>w<span class="token punctuation">]</span> 
    <span class="token comment"># 重新改变大小</span>
    roi <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>roi<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    <span class="token comment"># 框与字典对应</span>
    digits2Cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> roi

<span class="token comment"># 把处理好的模板进行保存</span>
pickle<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>digits2Cnt<span class="token punctuation">,</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'digits2Cnt.pkl'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>这里有两个点，首先对于每个轮廓，先计算它的外接矩形，也就是先框起来，然后从原始的模板图像中，拿出这个框，这才是每个数字。 然后为了能和后面信用卡上的数字进行匹配，这里还需要resize下。</p> 
<p>这样模板图像处理完毕，拿到了<code>ditits2Cnt</code>字典，字典的键就是数字值，而值就是模板中的轮廓对象。</p> 
<h3><a id="4__99"></a>4. 处理信用卡并进行匹配</h3> 
<p>信用卡这部分要稍微复杂一些，因为我们还得先定位到信用卡上的数字区域，然后通过一些操作对这块区域增强等。</p> 
<p>第一步，读取图像，改变大小，并转成灰度图。</p> 
<pre><code class="prism language-python"><span class="token comment"># 读取图像</span>
base_path <span class="token operator">=</span> <span class="token string">'images'</span>
file_name <span class="token operator">=</span> <span class="token string">'credit_card_01.png'</span>
credit_card <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>base_path<span class="token punctuation">,</span> file_name<span class="token punctuation">)</span><span class="token punctuation">)</span>
credit_card <span class="token operator">=</span> resize<span class="token punctuation">(</span>credit_card<span class="token punctuation">,</span> width<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">)</span>
credit_gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>credit_card<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>
</code></pre> 
<p>效果如下：<br> <img src="https://images2.imgbox.com/97/bd/omRTvzJk_o.png" alt="在这里插入图片描述"><br> 接下来，进行顶帽操作， 这个操作可以突出更加明亮的区域，而黑帽操作可以突出更加黑暗的区域。</p> 
<pre><code class="prism language-python"><span class="token comment"># 顶帽操作，突出更明亮的区域</span>

<span class="token comment"># 初始化卷积核</span>
rectKernel <span class="token operator">=</span> cv2<span class="token punctuation">.</span>getStructuringElement<span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>MORPH_RECT<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 自定义卷积核的大小了</span>
sqKernel <span class="token operator">=</span> cv2<span class="token punctuation">.</span>getStructuringElement<span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>MORPH_RECT<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

tophat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>credit_gray<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>MORPH_TOPHAT<span class="token punctuation">,</span> rectKernel<span class="token punctuation">)</span>
</code></pre> 
<p>效果如下：<br> <img src="https://images2.imgbox.com/07/7d/k7NOJg9u_o.png" alt="在这里插入图片描述"><br> 接下来，要进行边缘检测， 把上面的各个对象的边缘给他突出出来。边缘检测那里我们学习了水平边缘检测，垂直边缘检测，以及两者的合并操作，往往效果较好。 但这里发现单独水平边缘检测就可以。</p> 
<pre><code class="prism language-python"><span class="token comment"># 水平边缘检测  </span>
gradX <span class="token operator">=</span> cv2<span class="token punctuation">.</span>Sobel<span class="token punctuation">(</span>tophat<span class="token punctuation">,</span> ddepth<span class="token operator">=</span>cv2<span class="token punctuation">.</span>CV_32F<span class="token punctuation">,</span> dx<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> dy<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> ksize<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 水平边缘检测</span>
<span class="token comment"># gradX = cv2.convertScaleAbs(gradX)    这个操作会把一些背景边缘也给检测出来，加了一些噪声</span>

<span class="token comment"># 所以下面手动归一化操作</span>
gradX <span class="token operator">=</span> np<span class="token punctuation">.</span>absolute<span class="token punctuation">(</span>gradX<span class="token punctuation">)</span>
<span class="token punctuation">(</span>minVal<span class="token punctuation">,</span> maxVal<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>gradX<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>gradX<span class="token punctuation">)</span><span class="token punctuation">)</span>
gradX <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">255</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>gradX<span class="token operator">-</span>minVal<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>maxVal<span class="token operator">-</span>minVal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
gradX <span class="token operator">=</span> gradX<span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token string">'uint8'</span><span class="token punctuation">)</span>

<span class="token comment"># 这里也可以按照之前的常规， 先水平，后垂直，然后合并，但是效果可能不如单独x的效果好</span>
</code></pre> 
<p>效果如下：<br> <img src="https://images2.imgbox.com/3a/6a/5tItyM8H_o.png" alt="在这里插入图片描述"><br> 目前确实能找到边缘了，但是想把数字挨着近的连接成片，就需要用到形态学相关操作了。</p> 
<pre><code class="prism language-python"><span class="token comment"># 闭操作: 先膨胀， 后腐蚀  膨胀就能连成一块了</span>
gradX <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>gradX<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>MORPH_CLOSE<span class="token punctuation">,</span> rectKernel<span class="token punctuation">)</span>
</code></pre> 
<p>效果如下：<br> <img src="https://images2.imgbox.com/d0/97/Jm6MII0L_o.png" alt="在这里插入图片描述"><br> 然后会发现，数字虽然大部分连成一块一块的了，但是有些地方有些黑洞，且颜色还不是特别命令和明显，所以下面转成二值图片，突出对象，阈值+闭操作增强。</p> 
<pre><code class="prism language-python"><span class="token comment">#THRESH_OTSU会自动寻找合适的阈值，适合双峰，需把阈值参数设置为0  让opencv自动的去做判断，找合适的阈值，这样就能自动找出哪些有用，哪些没用</span>
thresh <span class="token operator">=</span> cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>gradX<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>THRESH_BINARY <span class="token operator">|</span> cv2<span class="token punctuation">.</span>THRESH_OTSU<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> 
cv_show<span class="token punctuation">(</span><span class="token string">'thresh'</span><span class="token punctuation">,</span>thresh<span class="token punctuation">)</span>
<span class="token comment">#再来一个闭操作</span>
thresh <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>thresh<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>MORPH_CLOSE<span class="token punctuation">,</span> sqKernel<span class="token punctuation">)</span> <span class="token comment">#再来一个闭操作</span>
</code></pre> 
<p>效果如下：</p> 
<p><img src="https://images2.imgbox.com/21/26/PXbTrfQC_o.png" alt="在这里插入图片描述"><br> 接下来的话，就能很容易的通过轮廓检测算法找到轮廓，但是如果想拿到数字的轮廓，这里还需要根据长宽比例进行筛选。</p> 
<pre><code class="prism language-python">threshCnts<span class="token punctuation">,</span> hierarchy <span class="token operator">=</span> cv2<span class="token punctuation">.</span>findContours<span class="token punctuation">(</span>thresh<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>RETR_EXTERNAL<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>CHAIN_APPROX_SIMPLE<span class="token punctuation">)</span>
cnts <span class="token operator">=</span> threshCnts
cur_img <span class="token operator">=</span> credit_card<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 把轮廓画出来</span>
cv2<span class="token punctuation">.</span>drawContours<span class="token punctuation">(</span>cur_img<span class="token punctuation">,</span> cnts<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
cv_show<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span> cur_img<span class="token punctuation">)</span>
</code></pre> 
<p>算法找到的轮廓如下：<br> <img src="https://images2.imgbox.com/d6/ac/pvkRvREy_o.png" alt="在这里插入图片描述"><br> 接下来遍历每个轮廓，锁定住中间的四个数字轮廓：</p> 
<pre><code class="prism language-python"><span class="token comment"># 找到包围数字的那四个大轮廓</span>
locs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment"># 遍历轮廓</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> c <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>cnts<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 计算外接矩形</span>
    <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token operator">=</span> cv2<span class="token punctuation">.</span>boundingRect<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    ar <span class="token operator">=</span> w <span class="token operator">/</span> <span class="token builtin">float</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span>
    
    <span class="token comment"># 选择合适的区域， 这里的基本都是四个数字一组</span>
    <span class="token keyword">if</span> ar <span class="token operator">&gt;</span> <span class="token number">2.5</span> <span class="token keyword">and</span> ar <span class="token operator">&lt;</span> <span class="token number">4.0</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">&gt;</span> <span class="token number">40</span> <span class="token keyword">and</span> w <span class="token operator">&lt;</span> <span class="token number">55</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token keyword">and</span> h <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 符合</span>
            locs<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 轮廓从左到右排序</span>
locs <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>locs<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>这里的操作依然是先用外接矩形包起对象，然后再进行选择。这样就拿到了四个大轮廓。</p> 
<p>接下来就非常简单了：</p> 
<ol><li> <p>遍历每个大轮廓</p> 
  <ol><li>对于每个轮廓， 进行和处理模板一样的操作，就能拿到数字</li><li>对于每个数字，进行模板匹配即可</li></ol> <pre><code class="prism language-python">outputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token comment"># 遍历每一个轮廓中的的数字</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token punctuation">(</span>gX<span class="token punctuation">,</span> gY<span class="token punctuation">,</span> gW<span class="token punctuation">,</span> gH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>locs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 初始化组</span>
    groupOutput <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    
    <span class="token comment"># 根据坐标提取每一组</span>
    group <span class="token operator">=</span> credit_gray<span class="token punctuation">[</span>gY<span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">:</span>gY<span class="token operator">+</span>gH<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span> gX<span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">:</span>gX<span class="token operator">+</span>gW<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span>  <span class="token comment"># 有5的一个容错长度</span>
    
    <span class="token comment"># 对于这每一组，先预处理  </span>
    <span class="token comment"># 二值化，自动寻找合适阈值，增强对比，更突出有用的部分，即数字</span>
    group <span class="token operator">=</span> cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>group<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>THRESH_BINARY <span class="token operator">|</span> cv2<span class="token punctuation">.</span>THRESH_OTSU<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
    
    <span class="token comment"># 计算每一组的轮廓</span>
    digitCnts<span class="token punctuation">,</span> hierarchy <span class="token operator">=</span> cv2<span class="token punctuation">.</span>findContours<span class="token punctuation">(</span>group<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>RETR_EXTERNAL<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>CHAIN_APPROX_SIMPLE<span class="token punctuation">)</span>
    digitCnts <span class="token operator">=</span> sort_contours<span class="token punctuation">(</span>digitCnts<span class="token punctuation">,</span> method<span class="token operator">=</span><span class="token string">'left-to-right'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    
    <span class="token comment"># 拿到每一组的每一个数字，然后进行模板匹配</span>
    <span class="token keyword">for</span> c <span class="token keyword">in</span> digitCnts<span class="token punctuation">:</span>
        <span class="token comment"># 找到当前数值的轮廓，resize成合适的大小</span>
        <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token operator">=</span> cv2<span class="token punctuation">.</span>boundingRect<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
        roi <span class="token operator">=</span> group<span class="token punctuation">[</span>y<span class="token punctuation">:</span>y<span class="token operator">+</span>h<span class="token punctuation">,</span> x<span class="token punctuation">:</span>x<span class="token operator">+</span>w<span class="token punctuation">]</span>
        roi <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>roi<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        
        <span class="token comment"># 模板匹配</span>
        scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>digit<span class="token punctuation">,</span> digitROI<span class="token punctuation">)</span> <span class="token keyword">in</span> digits2Cnt<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            result <span class="token operator">=</span> cv2<span class="token punctuation">.</span>matchTemplate<span class="token punctuation">(</span>roi<span class="token punctuation">,</span> digitROI<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>TM_CCOEFF<span class="token punctuation">)</span>
            <span class="token punctuation">(</span>_<span class="token punctuation">,</span> score<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span> cv2<span class="token punctuation">.</span>minMaxLoc<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
            scores<span class="token punctuation">.</span>append<span class="token punctuation">(</span>score<span class="token punctuation">)</span>
        
        <span class="token comment"># 得到合适的数字</span>
        <span class="token comment"># 这是个列表，存储的每个小组里面的数字识别结果</span>
        groupOutput<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    <span class="token comment"># 画出来</span>
    cv2<span class="token punctuation">.</span>rectangle<span class="token punctuation">(</span>credit_card<span class="token punctuation">,</span> <span class="token punctuation">(</span>gX <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">,</span> gY <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>gX <span class="token operator">+</span> gW <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">,</span> gY <span class="token operator">+</span> gH <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    cv2<span class="token punctuation">.</span>putText<span class="token punctuation">(</span>credit_card<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>groupOutput<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>gX<span class="token punctuation">,</span> gY <span class="token operator">-</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>FONT_HERSHEY_SIMPLEX<span class="token punctuation">,</span> <span class="token number">0.65</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
    
    <span class="token comment"># 合并到最后的结果里面</span>
    outputs<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>groupOutput<span class="token punctuation">)</span>
</code></pre> </li><li> <p>输出结果</p> <pre><code class="prism language-python"><span class="token comment"># 打印结果</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Credit Card Type: {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>FIRST_NUMBER<span class="token punctuation">[</span>outputs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Credit Card #: {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>outputs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Image"</span><span class="token punctuation">,</span> credit_card<span class="token punctuation">)</span>
</code></pre> </li></ol> 
<h3><a id="5__257"></a>5. 小总</h3> 
<p>这个项目到这里就结束了，整体比较简单，但是这里面涉及到的很多知识点都比较常用。总结如下：</p> 
<ol><li><code>图像的读取 -&gt;转灰度-&gt;二值化</code>操作</li><li>找轮廓操作(<code>cv2.findContours</code>)</li><li>基本的形态学操作(顶帽，黑帽，开闭，膨胀腐蚀)</li><li>边缘检测操作(Sobel算子， Sharr算子等)</li><li>轮廓排序，一定要注意，找到的轮廓数组可能是乱序的</li><li>画外接矩形，然后拿出具体的某个对象</li></ol> 
<p>当然，并没有涉及到很复杂的逻辑，全是Opencv的基础函数以及python基础操作，算是图像处理的一个小入门项目吧。</p> 
<p>本次项目代码地址<a href="https://github.com/zhongqiangwu960812/OpenCVLearning">https://github.com/zhongqiangwu960812/OpenCVLearning</a>， 感兴趣的可以玩一下啦。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/527483f30757b11c9ee5ebeaf16a6fe5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python图像亮度自适应增强(图像自动调亮)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d8634f0b3ca1570eb1f2e38b674566f5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">centos 添加路由命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>