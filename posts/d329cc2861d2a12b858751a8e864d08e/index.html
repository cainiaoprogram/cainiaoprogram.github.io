<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【大数据】Zookeeper 集群及其选举机制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【大数据】Zookeeper 集群及其选举机制" />
<meta property="og:description" content="Zookeeper 集群及其选举机制 1.安装 Zookeeper 集群2.如何选取 Leader 1.安装 Zookeeper 集群 我们之前说了，Zookeeper 集群是由一个领导者（Leader）和多个追随者（Follower）组成，但这个领导者是怎么选出来的呢？我们貌似没有在配置文件中看到有关领导者和追随者的参数啊？
在此之前先来看看 Zookeeper 内部的一些机制：
半数机制：只要有半数以上的节点存活，则集群可用，所以 Zookeeper 集群的节点数量适合为奇数。虽然在配置文件中没有指定领导者和追随者，但 Zookeeper 在工作时，有一个节点为 Leader，其它则为 Follower，而 Leader 是通过内部的选举机制临时产生的。 那么领导者到底是怎么选出来的呢？很简单，每台服务器都有一个 id（这里的 id 后面说），当启动的服务器超过半数的时候，就会选择 id 最大的 Server 成为领导者。比如有五台服务器，半数就是 2.5 2.5 2.5，因此当启动三台的时候就可以选出领导者。至于剩余的两台，启动之后只能成为追随者，因为领导者已经选出来了。关于这里的细节，一会儿再详细聊。
那么怎么指定服务器的 id 呢？还记得配置文件中的 dataDir 参数吗，在该参数指定的目录下创建一个 myid 文件（文件必须叫这个名字），然后在里面写上服务器的 id 即可。
[root@satori zkData]# echo 2 &gt; myid 这里给 id 设置为 2，因为一会要搭建由三个节点组成的集群，而我希望当前节点成为 Leader，所以它的 id 应该为 2，其它的两个节点的 id 显然分别为 1 和 3。这样按着 id 从小到大的顺序启动时，该节点就会成为 Leader。
下面来我们来搭建 zookeeper 集群，总共三个节点：
IP：82.157.146.194，主机名：satoriIP：121.37.165.252，主机名：koishiIP：123.60.7.226，主机名：marisa satori 节点就是当前一直在用的节点，剩余的两个节点的 Zookeeper 也已经安装完毕。那么问题来了，我们要如何将这三个节点组成一个集群呢？显然还需要修改配置文件，先在 satori 节点进行修改。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d329cc2861d2a12b858751a8e864d08e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T13:53:16+08:00" />
<meta property="article:modified_time" content="2024-01-06T13:53:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【大数据】Zookeeper 集群及其选举机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4> 
  <center>
    Zookeeper 集群及其选举机制 
  </center></h4> 
 <ul><li><a href="#1_Zookeeper__2" rel="nofollow">1.安装 Zookeeper 集群</a></li><li><a href="#2_Leader_74" rel="nofollow">2.如何选取 Leader</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_Zookeeper__2"></a>1.安装 Zookeeper 集群</h2> 
<p>我们之前说了，Zookeeper 集群是由一个领导者（<code>Leader</code>）和多个追随者（<code>Follower</code>）组成，但这个领导者是怎么选出来的呢？我们貌似没有在配置文件中看到有关领导者和追随者的参数啊？</p> 
<p>在此之前先来看看 Zookeeper 内部的一些机制：</p> 
<ul><li>半数机制：只要有半数以上的节点存活，则集群可用，所以 Zookeeper 集群的节点数量适合为奇数。</li><li>虽然在配置文件中没有指定领导者和追随者，但 Zookeeper 在工作时，有一个节点为 Leader，其它则为 Follower，而 Leader 是通过内部的选举机制临时产生的。</li></ul> 
<p>那么领导者到底是怎么选出来的呢？很简单，每台服务器都有一个 <code>id</code>（这里的 <code>id</code> 后面说），当启动的服务器超过半数的时候，就会选择 <code>id</code> 最大的 Server 成为领导者。比如有五台服务器，半数就是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2.5 
        
       
      
        2.5 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2.5</span></span></span></span></span>，因此当启动三台的时候就可以选出领导者。至于剩余的两台，启动之后只能成为追随者，因为领导者已经选出来了。关于这里的细节，一会儿再详细聊。</p> 
<p>那么怎么指定服务器的 <code>id</code> 呢？还记得配置文件中的 <code>dataDir</code> 参数吗，在该参数指定的目录下创建一个 <code>myid</code> 文件（文件必须叫这个名字），然后在里面写上服务器的 <code>id</code> 即可。</p> 
<pre><code>[root@satori zkData]# echo 2 &gt; myid
</code></pre> 
<p>这里给 <code>id</code> 设置为 2，因为一会要搭建由三个节点组成的集群，而我希望当前节点成为 Leader，所以它的 id 应该为 2，其它的两个节点的 <code>id</code> 显然分别为 1 和 3。这样按着 <code>id</code> 从小到大的顺序启动时，该节点就会成为 Leader。</p> 
<p>下面来我们来搭建 zookeeper 集群，总共三个节点：</p> 
<ul><li>IP：<code>82.157.146.194</code>，主机名：<code>satori</code></li><li>IP：<code>121.37.165.252</code>，主机名：<code>koishi</code></li><li>IP：<code>123.60.7.226</code>，主机名：<code>marisa</code></li></ul> 
<p><code>satori</code> 节点就是当前一直在用的节点，剩余的两个节点的 Zookeeper 也已经安装完毕。那么问题来了，我们要如何将这三个节点组成一个集群呢？显然还需要修改配置文件，先在 <code>satori</code> 节点进行修改。</p> 
<pre><code class="prism language-powershell"><span class="token comment"># koishi 节点</span>
server<span class="token punctuation">.</span>1=121<span class="token punctuation">.</span>37<span class="token punctuation">.</span>165<span class="token punctuation">.</span>252:2888:3888
<span class="token comment"># satori 节点</span>
server<span class="token punctuation">.</span>2=0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:2888:3888
<span class="token comment"># marisa 节点</span>
server<span class="token punctuation">.</span>3=123<span class="token punctuation">.</span>60<span class="token punctuation">.</span>7<span class="token punctuation">.</span>226:2888:3888
</code></pre> 
<p>将集群中都有哪些节点写在 <code>zoo.cfg</code> 中，解释一下具体含义，首先两个冒号把等号右边分成了三部分，第一部分就不用说了，IP 地址或者主机名，用于定位节点；<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2888 
        
       
      
        2888 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2888</span></span></span></span></span> 是 Leader 和 Follower <font color="#e47542"><strong>交换信息</strong></font> 的端口，因为副本要进行同步；<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         3888 
        
       
      
        3888 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3888</span></span></span></span></span> 是 <font color="#e47542"><strong>交换选举信息</strong></font> 的端口，因为要选出 Leader。</p> 
<p>然后我们注意到 <code>satori</code> 节点的 IP 设置成了 <code>0.0.0.0</code>，这是因为当前的三个节点不在同一个网段，IP 用的都是公网 IP，而公网 IP 在绑定服务的时候会失败。所以在绑定的时候，其它节点的 IP 要写成公网 IP，自身节点的 IP 要写成 <code>0.0.0.0</code>。因此其它两个节点的 <code>zoo.cfg</code> 文件就应该这么改：</p> 
<pre><code class="prism language-powershell"><span class="token comment">########## koishi 节点配置 ##########</span>
<span class="token comment"># koishi 节点</span>
server<span class="token punctuation">.</span>1=0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:2888:3888
<span class="token comment"># satori 节点</span>
server<span class="token punctuation">.</span>2=82<span class="token punctuation">.</span>157<span class="token punctuation">.</span>146<span class="token punctuation">.</span>194:2888:3888
<span class="token comment"># marisa 节点</span>
server<span class="token punctuation">.</span>3=123<span class="token punctuation">.</span>60<span class="token punctuation">.</span>7<span class="token punctuation">.</span>226:2888:3888

<span class="token comment">########## marisa 节点配置 ##########</span>
<span class="token comment"># koishi 节点</span>
server<span class="token punctuation">.</span>1=121<span class="token punctuation">.</span>37<span class="token punctuation">.</span>165<span class="token punctuation">.</span>252:2888:3888
<span class="token comment"># satori 节点</span>
server<span class="token punctuation">.</span>2=82<span class="token punctuation">.</span>157<span class="token punctuation">.</span>146<span class="token punctuation">.</span>194:2888:3888
<span class="token comment"># marisa 节点</span>
server<span class="token punctuation">.</span>3=0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:2888:3888
</code></pre> 
<p>但是在 <font color="#e47542"><strong>生产中，一个集群内的节点应该都位于同一网段</strong></font>，然后将配置文件中的 IP 全部换成内网 IP 即可。这样彼此之间可以通过内网访问，而内网的访问速度要远远快于公网，并且还不需要走公网的流量。但我当前的三台云服务器不在同一个网段，所以只能用公网 IP，并且绑定的时候，将节点自身的 IP 换成 <code>0.0.0.0</code>。</p> 
<p>至于等号左边的 <code>server.</code> 是固定的，后面的数字表示节点的 <code>id</code>，而节点 <code>id</code> 我们说了，通过在 <code>myid</code> 文件中进行指定。而节点 <code>id</code> 决定了，最终由谁担任领导者。其中 <code>satori</code> 节点的 <code>id</code> 为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
      
        2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>，刚刚已经改过了，然后将 <code>koishi</code> 和 <code>marisa</code> 两个节点的 <code>id</code> 分别改为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         3 
        
       
      
        3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span>，然后就大功告成了。</p> 
<p>然后我们来启动 Zookeeper，由于 <code>satori</code> 节点的 Zookeeper 已经启动了，我们在修改完配置文件之后，需要重新启动。</p> 
<p><img src="https://images2.imgbox.com/d2/56/TH9hv5EZ_o.png" alt="在这里插入图片描述" width="600" height="130"></p> 
<p>但是我们查看状态的时候，发现出错了，相信原因很好想。因为配置文件中指定了三个节点，而剩余两个节点的 Zookeeper 还没启动。下面我们来启动一下，然后再次查看状态。</p> 
<p><img src="https://images2.imgbox.com/3f/69/fF4k2rBc_o.png" alt="在这里插入图片描述" width="600" height="135"></p> 
<p>当剩余的两个节点启动之后，再次查看状态，发现 Mode 变成了 Leader。显然集群已经启动成功，至于剩余的两个节点，显然就是 Follower。</p> 
<p><img src="https://images2.imgbox.com/b0/18/zV4h826f_o.png" alt="在这里插入图片描述" width="600" height="125"><br> <img src="https://images2.imgbox.com/ed/ff/fEQTFcrE_o.png" alt="在这里插入图片描述" width="600" height="125"><br> 此时集群就启动成功了，但是关于领导者和追随者的选举问题，我们还得再说一说。</p> 
<h2><a id="2_Leader_74"></a>2.如何选取 Leader</h2> 
<p>领导者选举分为两种情况：</p> 
<ul><li>集群第一次启动的时候，选举领导者。</li><li>运行过程中领导者挂了，从追随者当中选择一个作为领导者。</li></ul> 
<p>我们先来看第一种情况，假设集群当中有 5 个节点，<code>id</code> 分别为 1 到 5，来看看选举过程是怎样的？这里 5 个节点按照 <code>id</code> 从小到大顺序启动。<br> <img src="https://images2.imgbox.com/ef/3b/xp9jeg5L_o.png" alt="在这里插入图片描述"></p> 
<ul><li>首先 <font color="#e47542"><strong>server1</strong></font> 启动，发起一次选举，每个节点都有投票权，并且默认都会投给自己。此时 <font color="#e47542"><strong>server1</strong></font> 有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          1 
         
        
       
         1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 票，但还不够半数以上（<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          3 
         
        
       
         3 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span> 票)，选举无法完成，于是 <font color="#e47542"><strong>server1</strong></font> 将状态保持为 <code>LOOKING</code>；</li><li>然后 server2 启动，再发起一次选举，重新投票。<font color="#e47542"><strong>server1</strong></font> 和 <font color="#6a994e"><strong>server2</strong></font> 仍会把票投给自己，然后再交换选票信息。由于 <font color="#e47542"><strong>server1</strong></font> 发现 <font color="#6a994e"><strong>server2</strong></font> 的 <code>id</code> 比自己大，于是会将自己的票改投给 <font color="#6a994e"><strong>server2</strong></font>。此时 <font color="#e47542"><strong>server1</strong></font> 有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          0 
         
        
       
         0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span> 票，<font color="#6a994e"><strong>server2</strong></font> 有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          2 
         
        
       
         2 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span> 票，但仍然没有哪个节点拥有超过半数的票，选举无法完成，<font color="#e47542"><strong>server1</strong></font> 和 <font color="#6a994e"><strong>server2</strong></font> 状态都保持为 <code>LOOKING</code>；</li><li>接下来 <font color="#ef233c"><strong>server3</strong></font> 启动，再发起一次选举，相信整个过程不需要解释了。老规矩还是先投给自己，再交换选票信息，然后 <font color="#e47542"><strong>server1</strong></font> 和 <font color="#6a994e"><strong>server2</strong></font> 发现自己的 <code>id</code> 都没有 <font color="#ef233c"><strong>server3</strong></font> 大，于是都会将票改投给 <font color="#ef233c"><strong>server3</strong></font>。此时 <font color="#e47542"><strong>server1</strong></font> 和 <font color="#6a994e"><strong>server2</strong></font> 的票数为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          0 
         
        
       
         0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>，<font color="#ef233c"><strong>server3</strong></font> 的票数为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          3 
         
        
       
         3 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span>，由于 <font color="#ef233c"><strong>server3</strong></font> 的票数已超过半数，所以成功当选为 Leader，状态变为 <code>LEADING</code>。而 <font color="#e47542"><strong>server1</strong></font>、<font color="#6a994e"><strong>server2</strong></font> 则成为 Follower，状态改为 <code>FOLLOWING</code>。</li><li>所以 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          5 
         
        
       
         5 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span> 个节点，启动 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          3 
         
        
       
         3 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span> 个之后就能选择出 Leader。然后 <font color="#00afb9"><strong>server4</strong></font> 又启动了，于是也发起一次选举，并把票投给自己。但 <font color="#e47542"><strong>server1</strong></font>、<font color="#6a994e"><strong>server2</strong></font>、<font color="#ef233c"><strong>server3</strong></font> 已经不是 LOOKING 状态，所以它们不会更改自己的选票信息，最终结果 <font color="#ef233c"><strong>server3</strong></font> 仍有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          3 
         
        
       
         3 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span> 票，<font color="#00afb9"><strong>server4</strong></font> 只有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          1 
         
        
       
         1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 票。少数服从多数，于是会再将自己的选票交给 <font color="#ef233c"><strong>server3</strong></font>，成为 Follower，状态改为 <code>FOLLOWING</code>。</li><li>同理，最后 <font color="#6c584c"><strong>server5</strong></font> 启动，结果就是 <font color="#ef233c"><strong>server3</strong></font> 有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          4 
         
        
       
         4 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span> 票，自己只有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          1 
         
        
       
         1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 票。少数服从多数，于是将自己的选票交给 <font color="#ef233c"><strong>server3</strong></font>，成为 Follower。</li></ul> 
<p><strong>所以整个过程，关键点有两个</strong>：</p> 
<ul><li>每个 <code>server</code> 启动之后都会发起选举，并将票投给自己。然后交换选票信息，并将票投给 <code>id</code> 最大的 <code>server</code>。</li><li>一旦选择出 Leader，其它节点自动成为 Follower。而后启动的 <code>server</code>，不论 <code>id</code> 多大，也只能成为 Follower。</li></ul> 
<p>以上就是集群第一次启动的时候，选举领导者。</p> 
<p>但如果在运行过程中，领导者挂了该怎么办呢？显然要再选举出一个新的领导者。所以当集群中的追随者发现自己连接不上领导者的时候，就会开始进入 Leader 选举，但此时是存在两种可能的。</p> 
<ul><li>领导者真的挂了。</li><li>领导者没有挂，只是追随者因为某些原因无法和领导者建立连接。比如 <font color="#6c584c"><strong>server5</strong></font> 发现连接不上 <font color="#ef233c"><strong>server3</strong></font> 了，于是它认为领导者挂了，便开启 Leader 选举。但事实上 <font color="#ef233c"><strong>server3</strong></font> 并没有挂，其它追随者都能正常连接，只是 <font color="#6c584c"><strong>server5</strong></font> 因为某些原因连接不上罢了。</li></ul> 
<p>先来解释第二种情况，<font color="#6c584c"><strong>server5</strong></font> 认为 <font color="#ef233c"><strong>server3</strong></font> 挂了之后，便会发起 Leader 选举，呼吁其它追随者进行投票。但是其它追随者发现领导者并没有挂，于是会拒绝 <font color="#6c584c"><strong>server5</strong></font> 的选举申请，并告知它当前已存在的领导者信息。对于 <font color="#6c584c"><strong>server5</strong></font> 而言，只需要和已存在的领导者重新建立连接，并进行数据同步即可。</p> 
<blockquote> 
 <p><font color="#ef233c"><strong>server3</strong></font>：老子还没挂呢！！！😤</p> 
</blockquote> 
<p>但如果是第一种情况，领导者真的挂了，该怎么办？比如这里的领导者 <font color="#ef233c"><strong>server3</strong></font>，在运行的时候，节点突然宕机了。</p> 
<p>要解释这个问题，我们需要引入一些新的概念。</p> 
<ul><li><code>sid</code>：就是我们一直说的服务器 <code>id</code>，用于唯一标识集群中的节点。</li><li><code>zxid</code>：事务 <code>id</code>，客户端在发起一次写请求的时候，都会带有 <code>zxid</code>，用于标识一次服务器状态的变更。所以 Zookeeper 也是有事务的，保证每次写数据的时候，要么全部写完，要么不写，不会出现只写一半的情况。另外每个节点都有自己的 <code>zxid</code>，它们的值也不一定相同。</li><li><code>epoch</code>：Leader 任期的编号，就好比古代皇帝，每个皇帝在当政的时候都有自己的年号。并且每投完一次票，这个编号就会增加。</li></ul> 
<p>现在假设 <font color="#ef233c"><strong>server3</strong></font> 挂了，那么要重新选举 Leader，而选举规则如下：</p> 
<ul><li>先比较节点之间的 <code>epoch</code>，<code>epoch</code> 大的直接当选。</li><li><code>epoch</code> 相同，再比较 <code>zxid</code>，<code>zxid</code> 大的当选。</li><li><code>epoch</code> 和 <code>zxid</code> 都相同，则比较 <code>sid</code>，<code>sid</code> 大的当选。</li></ul> 
<p>关于这么做背后的原理，我们先暂且不表，等到后面介绍 Paxos 协议的时候再细说。而且这里的 <code>epoch</code> 具体是干什么用的，估计也有人不太清楚，这些我们也留到后面再说。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8ebc9e69195d5d16254d631a2841e8ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【大数据】分布式协调系统 Zookeeper</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/943ceedef2a99c745c5042430867d2f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">react：ffcreator中FFCreatorCenter视频队例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>