<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>stdafx.h和int _tmain(int argc, _TCHAR* argv[]) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="stdafx.h和int _tmain(int argc, _TCHAR* argv[])" />
<meta property="og:description" content="stdafx.h和int _tmain(int argc, _TCHAR* argv[]) 以下内容摘自百度知道：
stdafx.h = Standard Application Fram Extend
没有函数库，只是定义了一些环境参数，使得编译出来的程序能在32位的操作系统环境下运行。
Windows和MFC的include文件都非常大，即使有一个快速的处理程序，编译程序也要花费相当长的时间来完成工作。由于每个.CPP文件都包含相同的include文件，为每个.CPP文件都重复处理这些文件就显得很傻了。
为避免这种浪费，AppWizard和VisualC&#43;&#43;编译程序一起进行工作，如下所示：
◎AppWizard建立了文件stdafx.h，该文件包含了所有当前工程文件需要的MFCinclude文件。且这一文件可以随被选择的选项而变化。
◎AppWizard然后就建立stdafx.cpp。这个文件通常都是一样的。
◎然后AppWizard就建立起工程文件，这样第一个被编译的文件就是stdafx.cpp。
◎当VisualC&#43;&#43;编译stdafx.cpp文件时，它将结果保存在一个名为stdafx.pch的文件里。(扩展名pch表示预编译头文件。)
◎当VisualC&#43;&#43;编译随后的每个.cpp文件时，它阅读并使用它刚生成的.pch文件。VisualC&#43;&#43;不再分析Windowsinclude文件，除非你又编缉了stdafx.cpp或stdafx.h。
这个技术很精巧，你不这么认为吗？(还要说一句，Microsoft并非是首先采用这种技术的公司，Borland才是。)在这个过程中你必须遵守以下规则：
◎你编写的任何.cpp文件都必须首先包含stdafx.h。
◎如果你有工程文件里的大多数.cpp文件需要.h文件，顺便将它们加在stdafx.h(后部)上，然后预编译stdafx.cpp。
◎由于.pch文件具有大量的符号信息，它是你的工程文件里最大的文件。
如果你的磁盘空间有限，你就希望能将这个你从没使用过的工程文件中的.pch文件删除。执行程序时并不需要它们，且随着工程文件的重新建立，它们也自动地重新建立。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int _tmain(int argc, _TCHAR* argv[])
与 int main(int argc, char *argv[])
类似，可以接收命令行位置参数
_TCHAR 可以接收 中文等双字节编码字符书写的命令行。
_tmain 中文等双字节编码 编码 主程序名
当然兼容 单字节编码 ASCII码 程序. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
类似的答案：
int main( int argc[ , char *argv[ ] );
argc：
整型，指示随后的argv中参数的个数；
argv：
代表运行后接的参数 补充：argv[0]存的是文件本身名字字符串。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a59b1283c604c6452b9ecb3c8b8beebc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-03-07T15:30:38+08:00" />
<meta property="article:modified_time" content="2012-03-07T15:30:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">stdafx.h和int _tmain(int argc, _TCHAR* argv[])</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                     stdafx.h和int _tmain(int argc, _TCHAR* argv[]) 
<div id="appShareOpt"></div> 
<div id="app-share-content"> 
 <p><span style="font-size:13px">以下内容摘自百度知道：</span></p> 
 <p><span style="font-size:13px">stdafx.h = Standard Application Fram Extend<br> 没有函数库，只是定义了一些环境参数，使得编译出来的程序能在32位的操作系统环境下运行。</span></p> 
 <p><span style="font-size:13px">Windows和MFC的include文件都非常大，即使有一个快速的处理程序，编译程序也要花费相当长的时间来完成工作。由于每个.CPP文件都包含相同的include文件，为每个.CPP文件都重复处理这些文件就显得很傻了。<br> 为避免这种浪费，AppWizard和VisualC++编译程序一起进行工作，如下所示：<br> ◎AppWizard建立了文件stdafx.h，该文件包含了所有当前工程文件需要的MFCinclude文件。且这一文件可以随被选择的选项而变化。<br> ◎AppWizard然后就建立stdafx.cpp。这个文件通常都是一样的。<br> ◎然后AppWizard就建立起工程文件，这样第一个被编译的文件就是stdafx.cpp。<br> ◎当VisualC++编译stdafx.cpp文件时，它将结果保存在一个名为stdafx.pch的文件里。(扩展名pch表示预编译头文件。)<br> ◎当VisualC++编译随后的每个.cpp文件时，它阅读并使用它刚生成的.pch文件。VisualC++不再分析Windowsinclude文件，除非你又编缉了stdafx.cpp或stdafx.h。<br> 这个技术很精巧，你不这么认为吗？(还要说一句，Microsoft并非是首先采用这种技术的公司，Borland才是。)在这个过程中你必须遵守以下规则：<br> ◎你编写的任何.cpp文件都必须首先包含stdafx.h。<br> ◎如果你有工程文件里的大多数.cpp文件需要.h文件，顺便将它们加在stdafx.h(后部)上，然后预编译stdafx.cpp。<br> ◎由于.pch文件具有大量的符号信息，它是你的工程文件里最大的文件。<br> 如果你的磁盘空间有限，你就希望能将这个你从没使用过的工程文件中的.pch文件删除。执行程序时并不需要它们，且随着工程文件的重新建立，它们也自动地重新建立。 </span> </p> 
 <p><span style="font-size:13px">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></p> 
 <p><span style="font-size:13px">int _tmain(int argc, _TCHAR* argv[])<br> 与 <br> int main(int argc, char *argv[])<br> 类似，可以接收命令行位置参数</span></p> 
 <p><span style="font-size:13px">_TCHAR 可以接收 中文等双字节编码字符书写的命令行。<br> _tmain 中文等双字节编码 编码 主程序名<br> 当然兼容 单字节编码 ASCII码 程序. </span></p> 
 <p><span style="font-size:13px">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></p> 
 <p><span style="font-size:13px">类似的答案：</span></p> 
 <p><span style="font-size:13px">int main( int argc[ , char *argv[ ] );<br> argc：<br> 整型，指示随后的argv中参数的个数；<br> argv：<br> 代表运行后接的参数 </span></p> 
 <p> </p> 
 <p><span style="font-size:32px; color:#ff0000">补充：argv[0]存的是文件本身名字字符串。</span></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a66ff4e55a94542944f853e3fce51f24/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AFX_MANAGE_STATE(AfxGetStaticModuleState())讲解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c497341323637c3e1fed5026488d1e0f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CENTOS下搭建SVN服务器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>