<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring REST Docs 介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring REST Docs 介绍" />
<meta property="og:description" content="Spring REST Docs 是一个为 Spring 项目生成 API 文档的框架，它通过在单元测试中额外添加 API 信息描述，从而自动生成对应的文档片段。
本文会以一个最简单的示例介绍如何在一个 Spring Boot 应用中使用 Spring REST Docs，并在最后与目前最常见的 SpringFox 进行一些对比，分别介绍其特点和优劣。
基础准备 首先需要一个 Spring Boot 项目，并通过 MockMvc 编写一些简单的测试。
@RestController public class HelloController { @GetMapping(&#34;hello&#34;) public Result hello(@RequestParam(&#34;name&#34;) String name) { return new Result(200, String.format(&#34;Hello %s!&#34;, name)); } } 在上面代码中提供了一个最简单的 Controller，其接收请求参数中的 name 属性，并返回一个包含 code 和 msg 的 Result 对象。
接下来需要为其编写一个测试：
@WebMvcTest @ExtendWith(SpringExtension.class) public class HelloControllerTests { @Autowired private MockMvc mockMvc; @Test public void testHello() throws Exception { mockMvc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c4839927b5bbdf0e8dfdb17aea88797c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-26T14:38:27+08:00" />
<meta property="article:modified_time" content="2019-02-26T14:38:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring REST Docs 介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Spring REST Docs 是一个为 Spring 项目生成 API 文档的框架，它通过在单元测试中额外添加 API 信息描述，从而自动生成对应的文档片段。</p> 
<p>本文会以一个最简单的示例介绍如何在一个 Spring Boot 应用中使用 Spring REST Docs，并在最后与目前最常见的 SpringFox 进行一些对比，分别介绍其特点和优劣。</p> 
<p> </p> 
<h4 id="基础准备">基础准备</h4> 
<p>首先需要一个 Spring Boot 项目，并通过 MockMvc 编写一些简单的测试。</p> 
<table><tbody><tr><td> <pre>@RestController
public class HelloController {

    @GetMapping("hello")
    public Result hello(@RequestParam("name") String name) {
        return new Result(200, String.format("Hello %s!", name));
    }
}
</pre> </td></tr></tbody></table> 
<p>在上面代码中提供了一个最简单的 Controller，其接收请求参数中的 <code>name</code> 属性，并返回一个包含 <code>code</code> 和 <code>msg</code> 的 Result 对象。</p> 
<p>接下来需要为其编写一个测试：</p> 
<table><tbody><tr><td> <pre>@WebMvcTest
@ExtendWith(SpringExtension.class)
public class HelloControllerTests {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testHello() throws Exception {
        mockMvc.perform(get("/hello").param("name", "ScienJus"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("msg", "Hello ScienJus!").exists())
}
</pre> </td></tr></tbody></table> 
<p>在这里使用了 JUnit5 和 Spring 的 MockMvc 编写 API 测试，只是简单的请求这个 API 并校验返回值。</p> 
<p>完成以上工作，就可以开始通过修改测试代码，为这个 API 自动生成相关的描述文档了。</p> 
<h4 id="配置-Spring-REST-Docs">配置 Spring REST Docs</h4> 
<p>当使用 MockMvc 时，只需要添加 <code>spring-restdocs-mockmvc</code> 依赖：</p> 
<table><tbody><tr><td> <pre>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt;
    &lt;artifactId&gt;spring-restdocs-mockmvc&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre> </td></tr></tbody></table> 
<p>之后，需要修改测试代码，添加对应的文档支持：</p> 
<table><tbody><tr><td> <pre>@WebMvcTest
@ExtendWith({RestDocumentationExtension.class, SpringExtension.class}) &lt;1&gt;
public class HelloControllerTests {

    private MockMvc mockMvc;

    @BeforeEach &lt;2&gt;
    public void setUp(WebApplicationContext webApplicationContext,
                      RestDocumentationContextProvider restDocumentation) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext)
                .apply(documentationConfiguration(restDocumentation))
                .build();
    }

    @Test
    public void testHello() throws Exception {
        mockMvc.perform(get("/hello").param("name", "ScienJus"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("msg", "Hello ScienJus!").exists())
                .andDo(document("hello")); &lt;3&gt;
    }
}
</pre> </td></tr></tbody></table> 
<ol><li>在 <code>@ExtendWith</code> 中增加 <code>RestDocumentationExtension</code>（JUnit5 的 Extension 相当于 JUnit4 中的 Rule）。</li><li>将 <code>MockMvc</code> 由直接注入改为手动构建，增加 <code>documentationConfiguration(restDocumentation)</code> 配置。</li><li>在执行测试的最后，调用 <code>andDo(document("hello"))</code> 给测试调用所生成的文档命名。</li></ol> 
<h4 id="构建文档">构建文档</h4> 
<p>完成配置后，运行 <code>mvn clean package</code> 进行构建，当测试运行成功后查看 <code>target/generated-snippets</code> 下出现的一系列 adoc 文档：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/df/18/GYN5HL4F_o.jpg"></p> 
<p>其中 <code>curl/httpie-request.adoc</code> 记录了测试请求通过 curl 和 httpie 的调用方式， <code>http-request/response.adoc</code> 记录了测试请求和返回的 raw 信息，<code>request/response-body.adoc</code> 记录了请求和返回的 Payload。</p> 
<p>不过这些都只是一个个文档片段，还需要将其拼凑到一起才能成为一份完整的 API 文档，框架本身不提供直接生成完整文档的功能，所以需要编写一个文档主页并引入这些自动生成的文档片段。</p> 
<p>默认的文档主页可以放在 <code>src/main/asciidoc/index.adoc</code> 中，例如：</p> 
<table><tbody><tr><td> <pre>= Learn Spring REST Docs
:toc: left

Learn how to use Spring REST Docs based on Spring Boot2 and JUnit5.

== /hello: Say "Hello World!"

operation::hello[]
</pre> </td></tr></tbody></table> 
<p>其中最重要的一行是 <code>operation::hello[]</code>，它表示将 hello 下的所有片段都引入进入，或者也可以指定 <code>operation::hello[snippets='curl-request,http-request,http-response']</code> 的方式只引入部分代码片段。</p> 
<p>编写好文档主页后，需要使用 <code>asciidoctor-maven-plugin</code> 使其可以在打包时与片段整合起来，并生成最终的 HTML 文件：</p> 
<table><tbody><tr><td> <pre>&lt;plugin&gt;
    &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
    &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.5.3&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;generate-docs&lt;/id&gt;
            &lt;phase&gt;prepare-package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;process-asciidoc&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;backend&gt;html&lt;/backend&gt;
                &lt;doctype&gt;book&lt;/doctype&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt;
            &lt;artifactId&gt;spring-restdocs-asciidoctor&lt;/artifactId&gt;
            &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;
</pre> </td></tr></tbody></table> 
<p>此时再次运行 <code>mvn clean package</code> 之后，可以看到 <code>target/generated-docs</code> 下生成了最终的网页，其最终效果如下图所示。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/e1/6c/oN9UvHyo_o.jpg"></p> 
<p>至此，最简单的请求文档便构建完成了。</p> 
<p> </p> 
<p> </p> 
<h3 id="和-SpringFox-的对比">和 SpringFox 的对比</h3> 
<p>相较于传统且更流行的 SpringFox（Swagger），Spring REST Docs 的实现方式相当新颖，而且有着鲜明的区别，那么不妨在此列举一下两者的区别以及优劣，以便更好的根据实际需求和使用场景选择最合适的工具。</p> 
<p>首先，两者最大的区别就在于根本定位，SpringFox 的定位是和应用一起启动的在线文档，文档的浏览者可以很简单的填写表单并发起一个真实的请求，而 Spring REST Docs 更倾向于导出一份离线文档作为展示，并配合 curl、httpie 这种工具请求真实部署的服务。</p> 
<p>其次，SpringFox 最大的特点是使用简单，只需要在源码中增加一些描述性的注解即可完成整份文档，而使用 Spring REST Docs 的前提条件是需要在项目中对 API 进行单元测试，并且要保证测试是可以稳定执行的，这对于很多团队来说无疑增加了很高的门槛。</p> 
<p>但是对于已经有完整单元测试的团队来说，增加额外的文档描述几乎和 SpringFox 一样简单，并且还能完整的去除源码依赖。除此之外，依靠测试本身也正是 Spring REST Docs 的最大亮点：</p> 
<p>首先，每一次测试都是一个真实的请求（不追究 MockMvc 具体实现细节），它所对应的请求和返回都是真实的，可以轻松将其记录下来作为 Demo 展示。而 SpringFox 只是对 Controller 层的方法进行了扫描，却无法感知 Interceptor、MethodArgumentResolver 这类中间件的存在，只能通过一些全局配置进行额外的描述。</p> 
<p>其次，每一次测试也都是一个独立的请求，使得 Spring REST Docs 可以描述同一个 API 在不同请求参数中返回的不同结果的场景（例如成功或是各种失败情况），而 SpringFox 只能描述单一的方法签名和返回值 Model，却无法描述其具体可能出现的场景。</p> 
<p>最后，错误的文档比没有文档还要糟糕，所以 Spring REST Docs 不仅仅是做 API 文档化，同时也是在做 API 契约化，如果 API 的实现修改破坏了已有的测试，哪怕仅仅是字段定义，都会导致测试的失败。这可以督促 API 的制定者保证对外提供的契约，也可以让 API 的使用者更加放心。</p> 
<p>所以相比之下，如果一个技术氛围良好，对服务严格负责，且愿意尝试 API 单元测试和契约测试的团队来说，我更推荐使用 Spring REST Docs，而如果只是在已有的服务上增加描述性的文档，SpringFox 会是性价比更高的选择。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f49c21a979eca7d9a24fac08cdd2691e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">can&#39;t open! &#34;[Microsoft][ODBC 驱动程序管理器] 未发现数据源名称并且未指定默认驱动程序 QODBC3: Unable to connect&#34;</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/85f4e0d40d9ff1c0c118e3c4b2694802/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C/C&#43;&#43; — Socket通讯错误码解释</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>