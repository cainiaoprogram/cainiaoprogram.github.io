<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库备份和恢复以及配置优化 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库备份和恢复以及配置优化" />
<meta property="og:description" content="目录
备份方法
备份策略
完全备份
完全恢复
增量备份
断点恢复
MySQL配置优化
参数汇总：
1）连接请求的变量
2）缓冲区变量
3）配置Innodb的几个变量
参数汇总：
备份方法 物理备份：直接对数据库的物理文件（数据文件、日志文件等）进行备份
逻辑备份：对数据库的库和表对象以SQL语言的形式导出进行备份
备份策略 完全备份：每次备份都备份完整的库或者表数据
差异备份：只备份上一次完全备份后的更新数据
增量备份：每次备份只备份上一次完全备份或增量备份后的更新数据
数据库上云迁移 冷迁移 物理冷备 先关闭数据库，再打包备份&#43;恢复
热迁移 阿里云 DTS
完全备份 物理冷备：先关闭数据库，使用tar命令打包备份数据库的数据目录和文件 mysql/data/
mysqldump逻辑热备
mysqldump -uXXX -pXXX --databases 库1 [库2 ....] &gt; XXX.sql 备份一个或多个库及库中所有的表数据
mysqldump -uXXX -pXXX --all-databases &gt; XXX.sql 备份所有的库
mysqldump -uXXX -pXXX 库名 &gt; XXX.sql 备份指定库中的所有的表数据，不包含库对象
mysqldump -uXXX -pXXX 库名 表1 [表2 ....] &gt; XXX.sql 备份指定库中的一个或多个表数据，不包含库对象
xtrabackup物理热备
完全恢复 先登录到数据库，再执行 source XXX." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f3def03065f16b9073a8da39ec720dc5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T16:32:39+08:00" />
<meta property="article:modified_time" content="2024-01-09T16:32:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库备份和恢复以及配置优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%A4%87%E4%BB%BD%E6%96%B9%E6%B3%95-toc" style="margin-left:120px;"><a href="#%E5%A4%87%E4%BB%BD%E6%96%B9%E6%B3%95" rel="nofollow">备份方法</a></p> 
<p id="%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5-toc" style="margin-left:120px;"><a href="#%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5" rel="nofollow">备份策略</a></p> 
<p id="%E5%AE%8C%E5%85%A8%E5%A4%87%E4%BB%BD-toc" style="margin-left:120px;"><a href="#%E5%AE%8C%E5%85%A8%E5%A4%87%E4%BB%BD" rel="nofollow">完全备份</a></p> 
<p id="%E5%AE%8C%E5%85%A8%E6%81%A2%E5%A4%8D-toc" style="margin-left:120px;"><a href="#%E5%AE%8C%E5%85%A8%E6%81%A2%E5%A4%8D" rel="nofollow">完全恢复</a></p> 
<p id="%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD-toc" style="margin-left:120px;"><a href="#%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD" rel="nofollow">增量备份</a></p> 
<p id="%E6%96%AD%E7%82%B9%E6%81%A2%E5%A4%8D-toc" style="margin-left:120px;"><a href="#%E6%96%AD%E7%82%B9%E6%81%A2%E5%A4%8D" rel="nofollow">断点恢复</a></p> 
<p id="MySQL%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96-toc" style="margin-left:120px;"><a href="#MySQL%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96" rel="nofollow">MySQL配置优化</a></p> 
<p id="%E5%8F%82%E6%95%B0%E6%B1%87%E6%80%BB%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%8F%82%E6%95%B0%E6%B1%87%E6%80%BB%EF%BC%9A" rel="nofollow">参数汇总：</a></p> 
<p id="1%EF%BC%89%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8F%98%E9%87%8F-toc" style="margin-left:120px;"><a href="#1%EF%BC%89%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8F%98%E9%87%8F" rel="nofollow">1）连接请求的变量</a></p> 
<p id="2%EF%BC%89%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%98%E9%87%8F-toc" style="margin-left:120px;"><a href="#2%EF%BC%89%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%98%E9%87%8F" rel="nofollow">2）缓冲区变量</a></p> 
<p id="3%EF%BC%89%E9%85%8D%E7%BD%AEInnodb%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8F%98%E9%87%8F-toc" style="margin-left:120px;"><a href="#3%EF%BC%89%E9%85%8D%E7%BD%AEInnodb%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8F%98%E9%87%8F" rel="nofollow">3）配置Innodb的几个变量</a></p> 
<p id="%E5%8F%82%E6%95%B0%E6%B1%87%E6%80%BB%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E5%8F%82%E6%95%B0%E6%B1%87%E6%80%BB%EF%BC%9A" rel="nofollow">参数汇总：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h5 id="%E5%A4%87%E4%BB%BD%E6%96%B9%E6%B3%95">备份方法</h5> 
<p><br> 物理备份：直接对数据库的物理文件（数据文件、日志文件等）进行备份<br> 逻辑备份：对数据库的库和表对象以SQL语言的形式导出进行备份</p> 
<h5 id="%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5">备份策略</h5> 
<p><br> 完全备份：每次备份都备份完整的库或者表数据<br> 差异备份：只备份上一次完全备份后的更新数据<br> 增量备份：每次备份只备份上一次完全备份或增量备份后的更新数据</p> 
<p><br> 数据库上云迁移     冷迁移     物理冷备      先关闭数据库，再打包备份+恢复<br>                    热迁移     阿里云 DTS</p> 
<h5 id="%E5%AE%8C%E5%85%A8%E5%A4%87%E4%BB%BD">完全备份</h5> 
<p><br> 物理冷备：先关闭数据库，使用tar命令打包备份数据库的数据目录和文件  mysql/data/</p> 
<p>mysqldump逻辑热备<br> mysqldump -uXXX -pXXX  --databases 库1 [库2 ....] &gt; XXX.sql       备份一个或多个库及库中所有的表数据<br> mysqldump -uXXX -pXXX  --all-databases &gt; XXX.sql                  备份所有的库<br> mysqldump -uXXX -pXXX  库名 &gt; XXX.sql                             备份指定库中的所有的表数据，不包含库对象<br> mysqldump -uXXX -pXXX  库名 表1 [表2 ....] &gt; XXX.sql              备份指定库中的一个或多个表数据，不包含库对象</p> 
<p>xtrabackup物理热备</p> 
<h5 id="%E5%AE%8C%E5%85%A8%E6%81%A2%E5%A4%8D"><br> 完全恢复</h5> 
<p><br> 先登录到数据库，再执行 source XXX.sql （如果sql文件是只备份了表数据的文件，需要先创建库并 use 切换库后再执行）</p> 
<p>mysql -uXXX -pXXX &lt; XXX.sql         cat XXX.sql | mysql -uXXX -pXXX                          恢复库<br> mysql -uXXX -pXXX 库名 &lt; XXX.sql    cat XXX.sql | mysql -uXXX -pXXX 库名                     恢复表</p> 
<h5 id="%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD"><br> 增量备份</h5> 
<p><br> 通过刷新二进制日志间接实现增量备份<br> mysqladmin -uXXX -pXXX flush-logs</p> 
<p>查看二进制日志内容<br> mysqlbinlog --no-defaults --base64-output=decode-rows -v &lt;BINLOG&gt;</p> 
<p>使用二进制日志增量恢复<br> mysqlbinlog --no-defaults &lt;BINLOG&gt; | mysql -uXXX -pXXX</p> 
<h5 id="%E6%96%AD%E7%82%B9%E6%81%A2%E5%A4%8D">断点恢复</h5> 
<p><br> 基于位置点恢复<br> mysqlbinlog --no-defaults --start-position='开始位置点' --stop-position='结束位置点'  &lt;BINLOG&gt; | mysql -uXXX -pXXX</p> 
<p>基于时间点恢复<br> mysqlbinlog --no-defaults --start-datetime='YYYY-mm-dd HH:MM:SS' --stop-position='YYYY-mm-dd HH:MM:SS'  &lt;BINLOG&gt; | mysql -uXXX -pXXX</p> 
<p>如果需要恢复到某条sql语句之前的所有数据，就stop在这个语句的位置点或时间点之前<br> 如果需要恢复某条sql语句及其之后的所有数据，就从这个语句的位置点或时间点开始start</p> 
<p>MySQL是优化难度最大的一个部分，不但需要理解一些MySQL专业知识，同时还需要长时间的观察统计并且根据经验 进行判断，然后设置合理的参数。下面我们了解一下MySQL优化的一些基础。</p> 
<h5 id="MySQL%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96">MySQL配置优化</h5> 
<p>目录</p> 
<p>1）连接请求的变量<br> 1、max_connections<br> 2、back_log<br> 3、wait_timeout和interative_timeout<br> 2）缓冲区变量<br> 4、key_buffer_size<br> 5、query_cache_size（查询缓存简称QC)<br> 6、max_connect_errors：<br> 7、sort_buffer_size：<br> 8、max_allowed_packet=32M<br> 9、join_buffer_size=2M<br> 10、thread_cache_size=300<br> 3）配置Innodb的几个变量<br> 11、innodb_buffer_pool_size<br> 12、innodb_flush_log_at_trx_commit<br> 13、innodb_thread_concurrency=0<br> 14、innodb_log_buffer_size<br> 15、innodb_log_file_size=50M<br> 16、innodb_log_files_in_group=3<br> 17、read_buffer_size=1M<br> 18、read_rnd_buffer_size=16M<br> 19、bulk_insert_buffer_size=64M<br> 20、binary log</p> 
<h4 id="%E5%8F%82%E6%95%B0%E6%B1%87%E6%80%BB%EF%BC%9A">参数汇总：</h4> 
<p>MySQL参数优化对于不同的网站，及其在线量，访问量，帖子数量，网络情况，以及机器硬件配置都有关系，优化不可能一次性完成，需要不断的观察以及调试，才有可能得到最佳的效果。</p> 
<h5 id="1%EF%BC%89%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8F%98%E9%87%8F">1）连接请求的变量</h5> 
<p>1、max_connections<br> 　　MySQL的最大连接数，如果服务器的并发连接请求量较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，MySQL回味每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。</p> 
<p>    数值过小经常会出现ERROR 1040：Too mant connetcions错误，可以通过mysql&gt;show status like ‘connections'；通配符来查看当前状态的连接数量（试图连接到MySQL（不管是否连接成功）的连接数），以定夺该值的大小。<br>     show variables like ‘max_connections': 最大连接数<br>     show variables like ‘max_used_connection': 相应连接数<br>     (max_used_connection / max_connections) * 100 %（理想值约等于85%）<br>     如果max_used_connections和max_connections相同，那么就是max_connections值设置过低或者超过服务器的负载上限了，低于10%则设置过大了。</p> 
<p>2、back_log<br> 　　MySQL能够暂存的连接数量，默认值是50。当主要MySQL线程在一个很短时间内得到非常多的连接请求，他就会起作用。如果MySQL的连接数据达到max_connections时，新的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈数量即back_log，如果等待连接的数量超过back_log，将不被接受连接资源。</p> 
<p>3、wait_timeout和interative_timeout<br> 　　wait_timeout=120：应用连接mysql进行操作完毕后，空闲120秒后断开<br> 　　interative_timeout=120：指的是mysql client连接mysql进行操作完毕后，空闲120秒后断开</p> 
<p>　　对性能的影响<br> 　　wait_timeout<br>         （1）如果设置太小，那么连接关闭的很快，从而使一些持久的连接不起作用<br>         （2）如果设置太大容易造成连接打开时间过长，在show processlist时，能够看到太多的sleep状态的连接，从而造成too many connections错误。<br>         （3）一般希望wait_timeuot尽可能的低<br>     interative_timeout的设置将对你的web application没有多大的影响</p> 
<h5 id="2%EF%BC%89%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%98%E9%87%8F"><br> 2）缓冲区变量</h5> 
<p>全局缓冲<br> 4、key_buffer_size<br> 　　key_buffer_size指定索引缓冲区的大小，他决定索引的处理速度，尤其是索引读的速度。</p> 
<p>　　通过检查状态值 key_read_requests和key_reads，可以知道key_buffer_size设置是否合理。</p> 
<p>　　比例key_reads/key_read_requests应该尽可能的低，至少是1：100，1：1000更好（上述状态值可以使用show status like ‘key_read%'获得）</p> 
<p>    未命中缓存的概率：<br>     key_cache_miss_rate = key_reads/key_read_requests*100%<br>     key_buffer_size只对MAISAM表起作用。</p> 
<p>    如何调整key_buffer_size的值<br>     默认的配置数时8388608（8M），主机有4G内存可以调优值为268435456（256M）</p> 
<p>5、query_cache_size（查询缓存简称QC)<br>     使用查询缓存，MySQL将查询结果存放在缓冲区中，今后对同样的select语句（区分大小写），将直接从缓冲区中读取结果。<br>     一个SQL查询如果以select开头，那么MySQL服务器将尝试对其使用查询缓存。</p> 
<p>    注：两个SQL语句，只要相差哪怕是一个字符（例如 大小写不一样：多一个空格等），那么两个SQL将使用不同的cache</p> 
<p>    通过 show status like ‘Qcache%' 可以知道query_cache_size的设置是否合理</p> 
<p>    Qcache_free_blocks：缓存中相邻内存块的个数。如果该值显示过大，则说明Query Cache中的内存碎片较多了。<br>     注：当一个表被更新后，和他相关的cache block将被free。但是这个block依然可能存在队列中，除非是在队列的尾部。可以用 flush query cache语句来清空free blocks。</p> 
<p>    Qcache_free_memory:Query Cache 中目前剩余的内存大小。通过这个参数我们可以较为准确的观察当前系统中的Query Cache内存大小是否足够，是需要增多还是过多了。</p> 
<p>    Qcache_hits：表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询能缓存的效果。数字越大缓存效果越理想。</p> 
<p>    Qcache_inserts：表示多少次未命中而插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert带查询缓存中。这样的情况次数越多，表示查询缓存 应用到的比较少，效果也就不理想。</p> 
<p>    Qcache_lowmen_prunes：多少条Query因为内存不足而被清除出Query Cache，通过Qcache_lowmem_prunes和Qcache_free_memory 相互结合，能够更清楚的了解到我们系统中Query Cache的内存大小是否真的足够，是否非常频繁的出现因为内存不足而有Query被换出。这个数字最好是长时间来看，如果这个数字在不断增长，就表示可能碎片化非常严重，或者内存很少。</p> 
<p>    Qcache_queries_in_cache：当前Query Cache 中cache的Query数量<br>     Qcache_total_blocks：当前Query Cache中block的数量</p> 
<p>    Query Cache的限制<br>     a）所有子查询中的外部查询SQL 不能被Cache：<br>     b）在procedure，function以及trigger中的Query不能被Cache<br>     c）包含其他很多每次执行可能得到不一样的结果的函数的Query不能被Cache</p> 
<p>6、max_connect_errors：<br> 　　是一个MySQL中与安全有关的计数器值，他负责阻止过多尝试失败的客户端以防止暴力破解密码的情况，当超过指定次数，MySQL服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hotos命令清空此host的相关信息。（与性能并无太大的关系）</p> 
<p>7、sort_buffer_size：<br> 每个需要排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY 或 GROUP BY操作<br>     sort_buffer_size是一个connection级的参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。<br>     sort_buffer_size：并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统的内存资源。例如：500个连接将会消耗500*sort_buffer_size(2M)=1G</p> 
<p>8、max_allowed_packet=32M<br>     根据配置文件限制server接受的数据包大小。</p> 
<p>9、join_buffer_size=2M<br>     用于表示关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</p> 
<p>10、thread_cache_size=300<br> 　　服务器线程缓存，这个值表示可以重新利用保存在缓存中的线程数量，当断开连接时，那么客户端的线程将被放到缓存中以响应下一个客户而不是销毁（前提时缓存数未达上限）。</p> 
<p>　　1）如果线程重新被请求，那么请求将从缓存中读取；</p> 
<p>　　2）如果缓存中是空的或者是新的请求，这个线程将被重新请求，那么这个线程将被重新创建；</p> 
<p>　　3）如果有很多新的线程，增加这个值可以改善系统性能，通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。</p> 
<p>　　设置规则如下：1G内存配置为8，2G内存为16.  服务器处理此客户的线程将会缓存起来以响应下一个客户而不是被销毁（前提是缓存数未到达上限）</p> 
<p>　　Threads_cached：代表当前此时此刻线程缓存中有多少空闲线程。<br> 　　Threads_connected：代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。<br> 　　Threads_created：代表最近一次服务启动，已创建线程的数量，如果发现Threads_created值过大的话，说明MySQL服务器一直在创建线程，这也比较消耗资源，可以适当增加配置文件中thread_cache_size值<br> 　　Threads_running：代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态。</p> 
<h5 id="3%EF%BC%89%E9%85%8D%E7%BD%AEInnodb%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8F%98%E9%87%8F"><br> 3）配置Innodb的几个变量</h5> 
<p>11、innodb_buffer_pool_size<br> 　　对于innodb表来说，innodb_buffer_pool_size的作用相当于key_buffer_size对于MyISAM表的作用一样。Innodb使用该参数指定大小的内存来缓冲数据和索引。最大可以把该值设置成物理内存的80%。</p> 
<p>12、innodb_flush_log_at_trx_commit<br>     主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0，1，2.<br>     实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要两秒，设置为0时只需要一秒，设置为1时，则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅度提高速度。</p> 
<p>13、innodb_thread_concurrency=0<br>     此参数用来设置innodb线程的并发数，默认值为0表示不被限制，若要设置则与服务器的CPU核心数相同或是CPU的核心数的2倍。</p> 
<p>14、innodb_log_buffer_size<br>     此参数确定日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，对于较大的事务，可以增大缓存大小。</p> 
<p>15、innodb_log_file_size=50M<br>     此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能。</p> 
<p>16、innodb_log_files_in_group=3<br>     为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3</p> 
<p>17、read_buffer_size=1M<br>     MySQL 读入缓冲区大小。对表进行顺序扫描的请求将分配到一个读入缓冲区MySQL会为他分配一段内存缓冲区</p> 
<p>18、read_rnd_buffer_size=16M<br>     MySQL 的随机读（查询操作）缓冲区大小。当按任意顺序读取行时（例如，按照排序顺序），将分配到一个随机都缓冲区。进行排序查询时，MySQL会首先扫描一遍该缓冲区，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但是MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存消耗过大。<br>     注：顺序读是根据索引的叶节点数据就能顺序的读取所需要的行数据。随机读是指一般需要根据辅助索引叶节点中的主键寻找侍其巷进行数据，而辅助索引和主键所在的数据端不同，因此访问方式是随机的。</p> 
<p>19、bulk_insert_buffer_size=64M<br>     批量插入数据缓存大小，可以有效的提高插入效率，默认为8M</p> 
<p>20、binary log<br>     binlog_cache_size=2M   //为每个session分配的内存，在事务过程中用来存储二进制日志的缓存，提高记录bin-log的效率。</p> 
<p>    max_binlog_cache_size=8M //表示的是binlog能够使用的最大cache内存大小</p> 
<p>    max_binlog_size=512M  //指定binlog日志文件的大小。不能将变量设置为大于1G或小于4096字节。默认值为1G.在导入大容量的sql文件时，建议关闭，sql_log_bin，否则硬盘扛不住，而且建议定期做删除。</p> 
<p>    expire_logs_days=7  //定义了mysql清除过期日志的时间</p> 
<h5><br> 参数汇总：</h5> 
<p>[mysqld]<br> basedir = /usr/local/mysql<br> datadir = /usr/local/mysql/data<br> server_id = 1<br> socket = /usr/local/mysql/mysql.sock<br> log-error = /usr/local/mysql/data/mysqld.err<br> slow_query_log = 1<br> slow_query_log_file=/usr/local/mysql/data/slow-query.log<br> long_query_time = 1<br> log-queries-not-using-indexes<br> max_connections = 1024<br> back_log = 128<br> wait_timeout = 60<br> interactive_timeout = 7200<br> key_buffer_size = 256M<br> query_cache_size = 256M<br> query_cache_type = 1<br> query_cache_limit = 50M <br> max_connect_errors = 20<br> sort_buffer_size = 2M<br> max_allowed_packet = 32M<br> join_buffer_size = 2M<br> thread_cache_size = 200<br> innodb_buffer_pool_size = 2048M<br> innodb_flush_log_at_trx_commit = 1<br> innodb_log_buffer_size = 32M<br> innodb_log_file_size = 128M<br> innodb_log_files_in_group = 3<br> log-bin=/usr/local/mysql/data/mysqlbin<br> binlog_cache_size = 2M <br> max_binlog_cache_size = 8M<br> max_binlog_size = 512M<br> expire_logs_days = 7<br> read_buffer_size = 1M<br> read_rnd_buffer_size = 16M<br> bulk_insert_buffer_size = 64M</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb53dec7c7004194f2b3c2e96610251d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;qt-信号-信号槽</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4412897c8abf1a370a8e3761adec3a78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【RabbitMQ】3 RabbitMQ使用及交换机</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>