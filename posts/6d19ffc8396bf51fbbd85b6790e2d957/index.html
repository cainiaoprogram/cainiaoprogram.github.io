<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ArrayList的使用方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ArrayList的使用方法" />
<meta property="og:description" content="1、什么是ArrayList
ArrayList就是传说中的动态数组，用MSDN中的说法，就是Array的复杂版本，它提供了如下一些好处：
动态的增加和减少元素实现了ICollection和IList接口灵活的设置数组的大小 2、如何使用ArrayList
最简单的例子：
ArrayList List = new ArrayList();
for( int i=0;i&lt;10;i&#43;&#43; ) //给数组增加10个Int元素
List.Add(i); //..程序做一些处理
List.RemoveAt(5);//将第6个元素移除
for( int i=0;i&lt;3;i&#43;&#43; ) //再增加3个元素
List.Add(i&#43;20);
Int32[] values = (Int32[])List.ToArray(typeof(Int32));//返回ArrayList包含的数组
这是一个简单的例子，虽然没有包含ArrayList所有的方法，但是可以反映出ArrayList最常用的用法
3、ArrayList重要的方法和属性
（1）构造器
ArrayList提供了三个构造器：
public ArrayList();
默认的构造器，将会以默认（16）的大小来初始化内部的数组
public ArrayList(ICollection);
用一个ICollection对象来构造，并将该集合的元素添加到ArrayList
public ArrayList(int);
用指定的大小来初始化内部的数组
（2）IsSynchronized属性和ArrayList.Synchronized方法
IsSynchronized属性指示当前的ArrayList实例是否支持线程同步，而ArrayList.Synchronized静态方法则会返回一个ArrayList的线程同步的封装。
如果使用非线程同步的实例，那么在多线程访问的时候，需要自己手动调用lock来保持线程同步，例如：
ArrayList list = new ArrayList();
//...
lock( list.SyncRoot ) //当ArrayList为非线程包装的时候，SyncRoot属性其实就是它自己，但是为了满足ICollection的SyncRoot定义，这里还是使用SyncRoot来保持源代码的规范性
{
list.Add( “Add a Item” );
}
如果使用ArrayList.Synchronized方法返回的实例，那么就不用考虑线程同步的问题，这个实例本身就是线程安全的，实际上ArrayList内部实现了一个保证线程同步的内部类，ArrayList.Synchronized返回的就是这个类的实例，它里面的每个属性都是用了lock关键字来保证线程同步。
****
但是，使用这个方法（ArrayList.Synchronized）并不能保证枚举的同步，例如，一个线程正在删除或添加集合项，而另一个线程同时进行枚举，这时枚举将会抛出异常。所以，在枚举的时候，你必须明确使用 SyncRoot 锁定这个集合。
Hashtable与ArrayList关于线程安全性的使用方法类似。
****
（3）Count属性和Capacity属性" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6d19ffc8396bf51fbbd85b6790e2d957/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-08-11T21:47:41+08:00" />
<meta property="article:modified_time" content="2016-08-11T21:47:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ArrayList的使用方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px"><strong>1、什么是ArrayList<br> </strong>    ArrayList就是传说中的动态数组，用MSDN中的说法，就是Array的复杂版本，它提供了如下一些好处：</span></p> 
<ul type="disc"><li><span style="font-size:18px">动态的增加和减少元素</span></li><li><span style="font-size:18px">实现了ICollection和IList接口</span></li><li><span style="font-size:18px">灵活的设置数组的大小</span></li></ul> 
<p><span style="font-size:18px"><br> <strong>2、如何使用ArrayList<br> </strong>    最简单的例子：<br> ArrayList List = new ArrayList();<br> for( int i=0;i&lt;10;i++ ) //给数组增加10个Int元素<br> List.Add(i); <br> //..程序做一些处理<br> List.RemoveAt(5);//将第6个元素移除<br> for( int i=0;i&lt;3;i++ ) //再增加3个元素<br>   List.Add(i+20);<br> Int32[] values = (Int32[])List.ToArray(typeof(Int32));//返回ArrayList包含的数组<br> <br> 这是一个简单的例子，虽然没有包含ArrayList所有的方法，但是可以反映出ArrayList最常用的用法<br> <br> <strong>3、ArrayList重要的方法和属性<br> </strong>（1）构造器<br>     ArrayList提供了三个构造器：<br> public ArrayList();<br> 默认的构造器，将会以默认（16）的大小来初始化内部的数组<br> public ArrayList(ICollection);<br> 用一个ICollection对象来构造，并将该集合的元素添加到ArrayList<br> public ArrayList(int);<br> 用指定的大小来初始化内部的数组<br> <br> （2）IsSynchronized属性和ArrayList.Synchronized方法<br> <span style="color:rgb(255,102,0)">    IsSynchronized</span><span style="color:rgb(255,102,0)">属性指示当前的</span><span style="color:rgb(255,102,0)">ArrayList</span><span style="color:rgb(255,102,0)">实例是否支持线程同步，而</span><span style="color:rgb(255,102,0)">ArrayList.Synchronized</span><span style="color:rgb(255,102,0)">静态方法则会返回一个</span><span style="color:rgb(255,102,0)">ArrayList</span><span style="color:rgb(255,102,0)">的线程同步的封装。</span><span style="color:rgb(255,102,0)"><br> </span>    如果使用非线程同步的实例，那么在多线程访问的时候，需要自己手动调用lock来保持线程同步，例如：<br> ArrayList list = new ArrayList();<br> //...<br> lock( list.SyncRoot ) <span style="color:green">//</span><span style="color:green">当</span><span style="color:green">ArrayList</span><span style="color:green">为非线程包装的时候，</span><span style="color:green">SyncRoot</span><span style="color:green">属性其实就是它自己，但是为了满足</span><span style="color:green">ICollection</span><span style="color:green">的</span><span style="color:green">SyncRoot</span><span style="color:green">定义，这里还是使用</span><span style="color:green">SyncRoot</span><span style="color:green">来保持源代码的规范性</span><br> {<!-- --><br> list.Add( “Add a Item” );<br> }<br> <br> <span style="color:rgb(255,102,0)">     </span><span style="color:rgb(255,102,0)">如果使用</span><span style="color:rgb(255,102,0)">ArrayList.Synchronized</span><span style="color:rgb(255,102,0)">方法返回的实例，那么就不用考虑线程同步的问题，这个实例本身就是线程安全的，实际上</span><span style="color:rgb(255,102,0)">ArrayList</span><span style="color:rgb(255,102,0)">内部实现了一个保证线程同步的内部类，</span><span style="color:rgb(255,102,0)">ArrayList.Synchronized</span><span style="color:rgb(255,102,0)">返回的就是这个类的实例，它里面的每个属性都是用了</span><span style="color:rgb(255,102,0)">lock</span><span style="color:rgb(255,102,0)">关键字来保证线程同步。</span></span></p> 
<p><span style="color:rgb(255,102,0)"><span style="font-size:18px">****</span></span></p> 
<p><span style="font-size:18px"><span style="color:rgb(255,102,0)">但是，使用这个方法（</span><span style="color:rgb(255,102,0)">ArrayList.Synchronized</span><span style="color:rgb(255,102,0)">）并不能保证枚举的同步，例如，一个线程正在删除或添加集合项，而另一个线程同时进行枚举，这时枚举将会抛出异常。所以，在枚举的时候，你必须明确使用</span><span style="color:rgb(255,102,0)"> SyncRoot </span><span style="color:rgb(255,102,0)">锁定这个集合。</span></span></p> 
<p><span style="color:rgb(255,102,0)"><span style="font-size:18px"> </span></span></p> 
<p><span style="font-size:18px"><span style="color:rgb(255,102,0)">Hashtable</span><span style="color:rgb(255,102,0)">与</span><span style="color:rgb(255,102,0)">ArrayList</span><span style="color:rgb(255,102,0)">关于线程安全性的使用方法类似。</span></span></p> 
<p><span style="font-size:18px"><span style="color:rgb(255,102,0)">****<br> </span><br> （3）Count属性和Capacity属性<br>     Count属性是目前ArrayList包含的元素的数量，这个属性是只读的。<br> Capacity属性是目前ArrayList能够包含的最大数量，可以手动的设置这个属性，但是当设置为小于Count值的时候会引发一个异常。<br> <br> （4）Add、AddRange、Remove、RemoveAt、RemoveRange、Insert、InsertRange<br>     这几个方法比较类似<br> Add方法用于添加一个元素到当前列表的末尾<br> AddRange方法用于添加一批元素到当前列表的末尾<br> Remove方法用于删除一个元素，通过元素本身的引用来删除<br> RemoveAt方法用于删除一个元素，通过索引值来删除<br> RemoveRange用于删除一批元素，通过指定开始的索引和删除的数量来删除<br> Insert用于添加一个元素到指定位置，列表后面的元素依次往后移动<br> InsertRange用于从指定位置开始添加一批元素，列表后面的元素依次往后移动<br> <br>     另外，还有几个类似的方法：<br> Clear方法用于清除现有所有的元素<br> Contains方法用来查找某个对象在不在列表之中<br> <br>     其他的我就不一一累赘了，大家可以查看MSDN，上面讲的更仔细<br> （5）TrimSize方法<br>     这个方法用于将ArrayList固定到实际元素的大小，当动态数组元素确定不在添加的时候，可以调用这个方法来释放空余的内存。<br> （6）ToArray方法<br>     这个方法把ArrayList的元素Copy到一个新的数组中。</span></p> 
<p><span style="font-size:18px"><br> <strong>4、ArrayList与数组转换<br> </strong>    例1：<br> ArrayList List = new ArrayList();<br> List.Add(1);<br> List.Add(2);<br> List.Add(3);<br> <br> Int32[] values = (Int32[])List.ToArray(typeof(Int32));<br> <br>     例2：<br> ArrayList List = new ArrayList();<br> List.Add(1);<br> List.Add(2);<br> List.Add(3);<br> <br> Int32[] values = new Int32[List.Count];<br> List.CopyTo(values);<br> <br>     上面介绍了两种从ArrayList转换到数组的方法<br> <br>     例3：<br> ArrayList List = new ArrayList();<br> List.Add( “string” );<br> List.Add( 1 );<br> //往数组中添加不同类型的元素<br> <br> object[] values = List.ToArray(typeof(object)); //正确<br> string[] values = (string[])List.ToArray(typeof(string)); //错误<br> <br> 和数组不一样，因为可以转换为Object数组，所以往ArrayList里面添加不同类型的元素是不会出错的，但是当调用ArrayList方法的时候，要么传递所有元素都可以正确转型的类型或者Object类型，否则将会抛出无法转型的异常。<br> <br> <br> <strong>5、ArrayList最佳使用建议<br> </strong>    这一节我们来讨论ArrayList与数组的差别，以及ArrayList的效率问题<br>   （1）ArrayList是Array的复杂版本<br> ArrayList内部封装了一个Object类型的数组，从一般的意义来说，它和数组没有本质的差别，甚至于ArrayList的许多方法，如Index、IndexOf、Contains、Sort等都是在内部数组的基础上直接调用Array的对应方法。<br>   （2）内部的Object类型的影响<br>          对于一般的引用类型来说，这部分的影响不是很大，但是对于值类型来说，往ArrayList里面添加和修改元素，都会引起装箱和拆箱的操作，频繁的操作可能会影响一部分效率。<br> 但是恰恰对于大多数人，多数的应用都是使用值类型的数组。<br> 消除这个影响是没有办法的，除非你不用它，否则就要承担一部分的效率损失，不过这部分的损失不会很大。<br>   （3）数组扩容<br> 这是对ArrayList效率影响比较大的一个因素。<br> 每当执行Add、AddRange、Insert、InsertRange等添加元素的方法，都会检查内部数组的容量是否不够了，如果是，它就会以当前容量的两倍来重新构建一个数组，将旧元素Copy到新数组中，然后丢弃旧数组，在这个临界点的扩容操作，应该来说是比较影响效率的。<br>      例1：比如，一个可能有200个元素的数据动态添加到一个以默认16个元素大小创建的ArrayList中，将会经过：<br> 16*2*2*2*2 = 256<br> 四次的扩容才会满足最终的要求，那么如果一开始就以：<br> ArrayList List = new ArrayList( 210 );<br> 的方式创建ArrayList，不仅会减少4次数组创建和Copy的操作，还会减少内存使用。<br> <br>      例2：预计有30个元素而创建了一个ArrayList：<br> ArrayList List = new ArrayList(30);<br> 在执行过程中，加入了31个元素，那么数组会扩充到60个元素的大小，而这时候不会有新的元素再增加进来，而且有没有调用TrimSize方法，那么就有1次扩容的操作，并且浪费了29个元素大小的空间。如果这时候，用：<br> ArrayList List = new ArrayList(40);<br> 那么一切都解决了。<br> 所以说，正确的预估可能的元素，并且在适当的时候调用TrimSize方法是提高ArrayList使用效率的重要途径。<br>    （4）频繁的调用IndexOf、Contains等方法（Sort、BinarySearch等方法经过优化，不在此列）引起的效率损失<br> 首先，我们要明确一点，ArrayList是动态数组，它不包括通过Key或者Value快速访问的算法，所以实际上调用IndexOf、Contains等方法是执行的简单的循环来查找元素，所以频繁的调用此类方法并不比你自己写循环并且稍作优化来的快，如果有这方面的要求，建议使用Hashtable或SortedList等键值对的集合。<br> ArrayList al=new ArrayList();<br> <br> al.Add("How");<br> al.Add("are");<br> al.Add("you!");<br> <br> al.Add(100);<br> al.Add(200);<br> al.Add(300);<br> <br> al.Add(1.2);<br> al.Add(22.8);<br> <br> .........<br> <br> //第一种遍历 ArrayList 对象的方法<br> foreach(object o in al)<br> {<!-- --><br> Console.Write(o.ToString()+" ");<br> }<br> <br> //第二种遍历 ArrayList 对象的方法<br> IEnumerator ie=al.GetEnumerator();<br> while(ie.MoveNext())<br> {<!-- --><br> Console.Write(ie.Curret.ToString()+" ");<br> }<br> <br> //第三种遍历 ArrayList 对象的方法<br> 我忘记了,好象是 利用 ArrayList对象的一个属性,它返回一此对象中的元素个数.<br> <br> 然后在利用索引 <br> for(int i=0;i&lt;Count;i++)<br> {<!-- --><br> Console.Write(al[i].ToString()+" ");<br> }<br> <br> </span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><strong><span style="font-size:18px">***-------------------------------</span></strong></p> 
<p><span style="font-weight:bold"></span></p> 
<p><span style="font-size:18px">《<a target="_blank" href="http://www.cnblogs.com/rickie/articles/67978.html" rel="nofollow noopener noreferrer" style="color:navy">ArrayList的使用方法</a>》的文章，讲解得非常清楚，可以很好地解释下面的问题：</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="color:#000080"><strong><span style="font-size:18px">（<span style="font-family:Verdana">1</span>）<span style="font-family:Verdana"> If interacting with collections from multiple threads, you must make the collection thread safe.</span></span></strong></span></p> 
<p style="background:none 0% 0% repeat scroll transparent"><strong><span style="font-family:Verdana"><span style="font-size:18px">SAMPLE CODE:</span></span></strong></p> 
<p><span style="font-size:18px">ArrayList myAr = new ArrayList();</span></p> 
<p style="background:none 0% 0% repeat scroll transparent"><span style="font-family:Verdana"><span style="font-size:18px">// Creates a synchronized wrapper around the ArrayList.</span></span></p> 
<p><span style="font-size:18px">ArrayList mySyncedAr = <strong>ArrayList.Synchronized</strong>(myAr);</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">// To use collection from thread:</span></p> 
<p><span style="font-size:18px">ArrayList myCollection = new ArrayList();</span></p> 
<p><span style="font-size:18px">lock(myCollection.<strong>SyncRoot</strong>);</span></p> 
<p><span style="font-size:18px">foreach ( Object item in myCollection )</span></p> 
<p><span style="font-size:18px">{ // do work here }</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><strong><span style="font-size:18px">Please note the following remarks from MSDN:</span></strong></p> 
<p><span style="font-family:Verdana"><span style="font-size:18px">To guarantee the thread safety of the ArrayList, all operations must be done through this synchronized wrapper.</span></span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">Enumerating through a collection is intrinsically not a thread-safe procedure. Even when a collection is synchronized, other threads could still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><strong><span style="font-size:18px"><span style="color:navy">（</span><span style="color:navy">2</span><span style="color:navy">）</span><span style="color:navy">Initialize collection sizes at startup to speed up node creation.</span></span></strong></p> 
<p><span style="font-size:18px">ArrayList myAL = new ArrayList(); // Without initializing collection sizes</span></p> 
<p><span style="font-size:18px">ArrayList myAL = new ArrayList(1000); // With initializing collection sizes</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-weight:bold"><span style="font-size:18px"><span style="color:navy"><span style="font-family:Verdana">You can get more detailed information from the above article, </span></span><span style="text-decoration:underline"><span style="color:green"><a target="_blank" href="http://www.cnblogs.com/rickie/articles/67978.html" rel="nofollow noopener noreferrer" style="color:navy"><span style="color:green"><span style="font-family:Verdana">ArrayList</span></span><span style="color:green">的使用方法</span></a></span></span><span style="color:navy"><span style="font-family:Verdana">.</span></span></span></span></p> 
<p><span style="font-weight:bold"><span style="font-size:18px"><span style="color:navy"><span style="font-family:Verdana"><br> </span></span></span></span></p> 
<p><span style="font-weight:bold"><span style="font-size:18px"><span style="color:navy"><span style="font-family:Verdana"><br> </span></span></span></span></p> 
<p><span style="font-weight:bold"><span style="font-size:18px"><span style="color:navy"><span style="font-family:Verdana"></span></span></span></span></p> 
<h2 class="YaHei">JAVA ArrayList详细介绍(示例)</h2> 
<div class="art_desc mt10"> 
 <div id="art_demo">
   本文对JAVA ArrayList做了详细介绍，文中学到了ArrayList源码解析、ArrayList遍历方式、toArray()异常，最后给出了ArrayList示例。 
 </div> 
</div> 
<div class="lbd clearfix"></div> 
<div id="content"> 
 <p><strong>第1部分 ArrayList介绍<br> </strong>ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。<br> ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。<br> ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。<br> ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。<br> ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。<br> 和Vector不同，ArrayList中的操作不是线程安全的。所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。<br> <br> <strong>ArrayList的继承关系<br> </strong><img src="https://images2.imgbox.com/9f/7b/9ZTpDGJZ_o.jpg" alt=""><br> <strong>ArrayList与Collection关系如下图：<br> </strong><img src="https://images2.imgbox.com/c0/b0/fXcQjhzU_o.jpg" alt=""><br> <strong>ArrayList构造函数<br> </strong></p> 
 <div class="codetitle"> 
  <a target="_blank" id="copybut95695" class="copybut" style=""><u>复制代码</u></a> 代码如下: 
 </div> 
 <div id="code95695" class="codebody"> 
  <br> // 默认构造函数 
  <br> ArrayList() 
  <br> // capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。 
  <br> ArrayList(int capacity) 
  <br> // 创建一个包含collection的ArrayList 
  <br> ArrayList(Collection&lt;? extends E&gt; collection) 
  <br> 
 </div> 
 <br> 
 <br> ArrayList的API 
 <br> 
 <div class="codetitle"> 
  <a target="_blank" id="copybut87409" class="copybut" style=""><u>复制代码</u></a> 代码如下: 
 </div> 
 <div id="code87409" class="codebody"> 
  <br> // Collection中定义的API 
  <br> boolean             add(E object) 
  <br> boolean             addAll(Collection&lt;? extends E&gt; collection) 
  <br> void                clear() 
  <br> boolean             contains(Object object) 
  <br> boolean             containsAll(Collection&lt;?&gt; collection) 
  <br> boolean             equals(Object object) 
  <br> int                 hashCode() 
  <br> boolean             isEmpty() 
  <br> Iterator&lt;E&gt;         iterator() 
  <br> boolean             remove(Object object) 
  <br> boolean             removeAll(Collection&lt;?&gt; collection) 
  <br> boolean             retainAll(Collection&lt;?&gt; collection) 
  <br> int                 size() 
  <br> &lt;T&gt; T[]             toArray(T[] array) 
  <br> Object[]            toArray() 
  <br> // AbstractCollection中定义的API 
  <br> void                add(int location, E object) 
  <br> boolean             addAll(int location, Collection&lt;? extends E&gt; collection) 
  <br> E                   get(int location) 
  <br> int                 indexOf(Object object) 
  <br> int                 lastIndexOf(Object object) 
  <br> ListIterator&lt;E&gt;     listIterator(int location) 
  <br> ListIterator&lt;E&gt;     listIterator() 
  <br> E                   remove(int location) 
  <br> E                   set(int location, E object) 
  <br> List&lt;E&gt;             subList(int start, int end) 
  <br> // ArrayList新增的API 
  <br> Object               clone() 
  <br> void                 ensureCapacity(int minimumCapacity) 
  <br> void                 trimToSize() 
  <br> void                 removeRange(int fromIndex, int toIndex) 
  <br> 
 </div> 
 <br> 
 <br>   
 <br> 
 <strong>第2部分 ArrayList源码解析<br> </strong>为了更了解ArrayList的原理，下面对ArrayList源码代码作出分析。ArrayList是通过数组实现的，源码比较容易理解。 
 <br> 
 <div class="codetitle"> 
  <a target="_blank" id="copybut65382" class="copybut" style=""><u>复制代码</u></a> 代码如下: 
 </div> 
 <div id="code65382" class="codebody"> 
  <br> package java.util; 
  <br> public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; 
  <br>         implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 
  <br> { 
  <br>     // 序列版本号 
  <br>     private static final long serialVersionUID = 8683452581122892189L; 
  <br>     // 保存ArrayList中数据的数组 
  <br>     private transient Object[] elementData; 
  <br>     // ArrayList中实际数据的数量 
  <br>     private int size; 
  <br>     // ArrayList带容量大小的构造函数。 
  <br>     public ArrayList(int initialCapacity) { 
  <br>         super(); 
  <br>         if (initialCapacity &lt; 0) 
  <br>             throw new IllegalArgumentException("Illegal Capacity: "+ 
  <br>                                                initialCapacity); 
  <br>         // 新建一个数组 
  <br>         this.elementData = new Object[initialCapacity]; 
  <br>     } 
  <br>     // ArrayList构造函数。默认容量是10。 
  <br>     public ArrayList() { 
  <br>         this(10); 
  <br>     } 
  <br>     // 创建一个包含collection的ArrayList 
  <br>     public ArrayList(Collection&lt;? extends E&gt; c) { 
  <br>         elementData = c.toArray(); 
  <br>         size = elementData.length; 
  <br>         // c.toArray might (incorrectly) not return Object[] (see 6260652) 
  <br>         if (elementData.getClass() != Object[].class) 
  <br>             elementData = Arrays.copyOf(elementData, size, Object[].class); 
  <br>     } 
  <p></p> 
  <p>    // 将当前容量值设为 =实际元素个数<br>     public void trimToSize() {<!-- --><br>         modCount++;<br>         int oldCapacity = elementData.length;<br>         if (size &lt; oldCapacity) {<!-- --><br>             elementData = Arrays.copyOf(elementData, size);<br>         }<br>     }</p> 
  <p>    // 确定ArrarList的容量。<br>     // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1”<br>     public void ensureCapacity(int minCapacity) {<!-- --><br>         // 将“修改统计数”+1<br>         modCount++;<br>         int oldCapacity = elementData.length;<br>         // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1”<br>         if (minCapacity &gt; oldCapacity) {<!-- --><br>             Object oldData[] = elementData;<br>             int newCapacity = (oldCapacity * 3)/2 + 1;<br>             if (newCapacity &lt; minCapacity)<br>                 newCapacity = minCapacity;<br>             elementData = Arrays.copyOf(elementData, newCapacity);<br>         }<br>     }<br>     // 添加元素e<br>     public boolean add(E e) {<!-- --><br>         // 确定ArrayList的容量大小<br>         ensureCapacity(size + 1);  // Increments modCount!!<br>         // 添加e到ArrayList中<br>         elementData[size++] = e;<br>         return true;<br>     }<br>     // 返回ArrayList的实际大小<br>     public int size() {<!-- --><br>         return size;<br>     }<br>     // 返回ArrayList是否包含Object(o)<br>     public boolean contains(Object o) {<!-- --><br>         return indexOf(o) &gt;= 0;<br>     }<br>     // 返回ArrayList是否为空<br>     public boolean isEmpty() {<!-- --><br>         return size == 0;<br>     }<br>     // 正向查找，返回元素的索引值<br>     public int indexOf(Object o) {<!-- --><br>         if (o == null) {<!-- --><br>             for (int i = 0; i &lt; size; i++)<br>             if (elementData[i]==null)<br>                 return i;<br>             } else {<!-- --><br>                 for (int i = 0; i &lt; size; i++)<br>                 if (o.equals(elementData[i]))<br>                     return i;<br>             }<br>             return -1;<br>         }<br>         // 反向查找，返回元素的索引值<br>         public int lastIndexOf(Object o) {<!-- --><br>         if (o == null) {<!-- --><br>             for (int i = size-1; i &gt;= 0; i--)<br>             if (elementData[i]==null)<br>                 return i;<br>         } else {<!-- --><br>             for (int i = size-1; i &gt;= 0; i--)<br>             if (o.equals(elementData[i]))<br>                 return i;<br>         }<br>         return -1;<br>     }<br>     // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值<br>     public int lastIndexOf(Object o) {<!-- --><br>         if (o == null) {<!-- --><br>             for (int i = size-1; i &gt;= 0; i--)<br>             if (elementData[i]==null)<br>                 return i;<br>         } else {<!-- --><br>             for (int i = size-1; i &gt;= 0; i--)<br>             if (o.equals(elementData[i]))<br>                 return i;<br>         }<br>         return -1;<br>     }<br> <br>     // 返回ArrayList的Object数组<br>     public Object[] toArray() {<!-- --><br>         return Arrays.copyOf(elementData, size);<br>     }<br>     // 返回ArrayList的模板数组。所谓模板数组，即可以将T设为任意的数据类型<br>     public &lt;T&gt; T[] toArray(T[] a) {<!-- --><br>         // 若数组a的大小 &lt; ArrayList的元素个数；<br>         // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中<br>         if (a.length &lt; size)<br>             return (T[]) Arrays.copyOf(elementData, size, a.getClass());<br>         // 若数组a的大小 &gt;= ArrayList的元素个数；<br>         // 则将ArrayList的全部元素都拷贝到数组a中。<br>         System.arraycopy(elementData, 0, a, 0, size);<br>         if (a.length &gt; size)<br>             a[size] = null;<br>         return a;<br>     }<br>     // 获取index位置的元素值<br>     public E get(int index) {<!-- --><br>         RangeCheck(index);<br>         return (E) elementData[index];<br>     }<br>     // 设置index位置的值为element<br>     public E set(int index, E element) {<!-- --><br>         RangeCheck(index);<br>         E oldValue = (E) elementData[index];<br>         elementData[index] = element;<br>         return oldValue;<br>     }<br>     // 将e添加到ArrayList中<br>     public boolean add(E e) {<!-- --><br>         ensureCapacity(size + 1);  // Increments modCount!!<br>         elementData[size++] = e;<br>         return true;<br>     }<br>     // 将e添加到ArrayList的指定位置<br>     public void add(int index, E element) {<!-- --><br>         if (index &gt; size || index &lt; 0)<br>             throw new IndexOutOfBoundsException(<br>             "Index: "+index+", Size: "+size);<br>         ensureCapacity(size+1);  // Increments modCount!!<br>         System.arraycopy(elementData, index, elementData, index + 1,<br>              size - index);<br>         elementData[index] = element;<br>         size++;<br>     }<br>     // 删除ArrayList指定位置的元素<br>     public E remove(int index) {<!-- --><br>         RangeCheck(index);<br>         modCount++;<br>         E oldValue = (E) elementData[index];<br>         int numMoved = size - index - 1;<br>         if (numMoved &gt; 0)<br>             System.arraycopy(elementData, index+1, elementData, index,<br>                  numMoved);<br>         elementData[--size] = null; // Let gc do its work<br>         return oldValue;<br>     }<br>     // 删除ArrayList的指定元素<br>     public boolean remove(Object o) {<!-- --><br>         if (o == null) {<!-- --><br>                 for (int index = 0; index &lt; size; index++)<br>             if (elementData[index] == null) {<!-- --><br>                 fastRemove(index);<br>                 return true;<br>             }<br>         } else {<!-- --><br>             for (int index = 0; index &lt; size; index++)<br>             if (o.equals(elementData[index])) {<!-- --><br>                 fastRemove(index);<br>                 return true;<br>             }<br>         }<br>         return false;<br>     }</p> 
  <p>    // 快速删除第index个元素<br>     private void fastRemove(int index) {<!-- --><br>         modCount++;<br>         int numMoved = size - index - 1;<br>         // 从"index+1"开始，用后面的元素替换前面的元素。<br>         if (numMoved &gt; 0)<br>             System.arraycopy(elementData, index+1, elementData, index,<br>                              numMoved);<br>         // 将最后一个元素设为null<br>         elementData[--size] = null; // Let gc do its work<br>     }<br>     // 删除元素<br>     public boolean remove(Object o) {<!-- --><br>         if (o == null) {<!-- --><br>             for (int index = 0; index &lt; size; index++)<br>             if (elementData[index] == null) {<!-- --><br>                 fastRemove(index);<br>             return true;<br>             }<br>         } else {<!-- --><br>             // 便利ArrayList，找到“元素o”，则删除，并返回true。<br>             for (int index = 0; index &lt; size; index++)<br>             if (o.equals(elementData[index])) {<!-- --><br>                 fastRemove(index);<br>             return true;<br>             }<br>         }<br>         return false;<br>     }<br>     // 清空ArrayList，将全部的元素设为null<br>     public void clear() {<!-- --><br>         modCount++;<br>         for (int i = 0; i &lt; size; i++)<br>             elementData[i] = null;<br>         size = 0;<br>     }<br>     // 将集合c追加到ArrayList中<br>     public boolean addAll(Collection&lt;? extends E&gt; c) {<!-- --><br>         Object[] a = c.toArray();<br>         int numNew = a.length;<br>         ensureCapacity(size + numNew);  // Increments modCount<br>         System.arraycopy(a, 0, elementData, size, numNew);<br>         size += numNew;<br>         return numNew != 0;<br>     }<br>     // 从index位置开始，将集合c添加到ArrayList<br>     public boolean addAll(int index, Collection&lt;? extends E&gt; c) {<!-- --><br>         if (index &gt; size || index &lt; 0)<br>             throw new IndexOutOfBoundsException(<br>             "Index: " + index + ", Size: " + size);<br>         Object[] a = c.toArray();<br>         int numNew = a.length;<br>         ensureCapacity(size + numNew);  // Increments modCount<br>         int numMoved = size - index;<br>         if (numMoved &gt; 0)<br>             System.arraycopy(elementData, index, elementData, index + numNew,<br>                  numMoved);<br>         System.arraycopy(a, 0, elementData, index, numNew);<br>         size += numNew;<br>         return numNew != 0;<br>     }<br>     // 删除fromIndex到toIndex之间的全部元素。<br>     protected void removeRange(int fromIndex, int toIndex) {<!-- --><br>     modCount++;<br>     int numMoved = size - toIndex;<br>         System.arraycopy(elementData, toIndex, elementData, fromIndex,<br>                          numMoved);<br>     // Let gc do its work<br>     int newSize = size - (toIndex-fromIndex);<br>     while (size != newSize)<br>         elementData[--size] = null;<br>     }<br>     private void RangeCheck(int index) {<!-- --><br>     if (index &gt;= size)<br>         throw new IndexOutOfBoundsException(<br>         "Index: "+index+", Size: "+size);<br>     }</p> 
  <p>    // 克隆函数<br>     public Object clone() {<!-- --><br>         try {<!-- --><br>             ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone();<br>             // 将当前ArrayList的全部元素拷贝到v中<br>             v.elementData = Arrays.copyOf(elementData, size);<br>             v.modCount = 0;<br>             return v;<br>         } catch (CloneNotSupportedException e) {<!-- --><br>             // this shouldn't happen, since we are Cloneable<br>             throw new InternalError();<br>         }<br>     }</p> 
  <p>    // java.io.Serializable的写入函数<br>     // 将ArrayList的“容量，所有的元素值”都写入到输出流中<br>     private void writeObject(java.io.ObjectOutputStream s)<br>         throws java.io.IOException{<!-- --><br>     // Write out element count, and any hidden stuff<br>     int expectedModCount = modCount;<br>     s.defaultWriteObject();<br>         // 写入“数组的容量”<br>         s.writeInt(elementData.length);<br>     // 写入“数组的每一个元素”<br>     for (int i=0; i&lt;size; i++)<br>             s.writeObject(elementData[i]);<br>     if (modCount != expectedModCount) {<!-- --><br>             throw new ConcurrentModificationException();<br>         }<br>     }</p> 
  <p>    // java.io.Serializable的读取函数：根据写入方式读出<br>     // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出<br>     private void readObject(java.io.ObjectInputStream s)<br>         throws java.io.IOException, ClassNotFoundException {<!-- --><br>         // Read in size, and any hidden stuff<br>         s.defaultReadObject();<br>         // 从输入流中读取ArrayList的“容量”<br>         int arrayLength = s.readInt();<br>         Object[] a = elementData = new Object[arrayLength];<br>         // 从输入流中将“所有的元素值”读出<br>         for (int i=0; i&lt;size; i++)<br>             a[i] = s.readObject();<br>     }<br> }<br> </p> 
 </div> 
 <br> 总结： 
 <br> (01) ArrayList 实际上是通过一个数组去保存数据的。当我们构造ArrayList时；若使用默认构造函数，则ArrayList的默认容量大小是10。 
 <br> (02) 当ArrayList容量不足以容纳全部元素时，ArrayList会重新设置容量：新的容量=“(原始容量x3)/2 + 1”。 
 <br> (03) ArrayList的克隆函数，即是将全部元素克隆到一个数组中。 
 <br> (04) ArrayList实现java.io.Serializable的方式。当写入到输出流时，先写入“容量”，再依次写入“每一个元素”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。 
 <br> 
 <br>   
 <br> 
 <strong>第3部分 ArrayList遍历方式<br> </strong>ArrayList支持3种遍历方式 
 <br> (01) 第一种，通过迭代器遍历。即通过Iterator去遍历。 
 <br> 
 <div class="codetitle"> 
  <a target="_blank" id="copybut4903" class="copybut" style=""><u>复制代码</u></a> 代码如下: 
 </div> 
 <div id="code4903" class="codebody"> 
  <br> Integer value = null; 
  <br> Iterator iter = list.iterator(); 
  <br> while (iter.hasNext()) { 
  <br>     value = (Integer)iter.next(); 
  <br> } 
  <br> 
 </div> 
 <br> (02) 第二种，随机访问，通过索引值去遍历。 
 <br> 由于ArrayList实现了RandomAccess接口，它支持通过索引值去随机访问元素。 
 <br> 
 <div class="codetitle"> 
  <a target="_blank" id="copybut86341" class="copybut" style=""><u>复制代码</u></a> 代码如下: 
 </div> 
 <div id="code86341" class="codebody"> 
  <br> Integer value = null; 
  <br> int size = list.size(); 
  <br> for (int i=0; i&lt;size; i++) { 
  <br>     value = (Integer)list.get(i);        
  <br> } 
  <br> 
 </div> 
 <br> (03) 第三种，for循环遍历。如下： 
 <br> 
 <div class="codetitle"> 
  <a target="_blank" id="copybut68587" class="copybut" style=""><u>复制代码</u></a> 代码如下: 
 </div> 
 <div id="code68587" class="codebody"> 
  <br> Integer value = null; 
  <br> for (Integer integ:list) { 
  <br>     value = integ; 
  <br> } 
  <br>   
 </div> 
 <br> 下面通过一个实例，比较这3种方式的效率，实例代码(ArrayListRandomAccessTest.java)如下： 
 <br> 
 <div class="codetitle"> 
  <a target="_blank" id="copybut95290" class="copybut" style=""><u>复制代码</u></a> 代码如下: 
 </div> 
 <div id="code95290" class="codebody"> 
  <br> import java.util.*; 
  <br> import java.util.concurrent.*; 
  <br> /* 
  <br>  * @desc ArrayList遍历方式和效率的测试程序。 
  <br>  * 
  <br>  * @author skywang 
  <br>  */ 
  <br> public class ArrayListRandomAccessTest { 
  <br>     public static void main(String[] args) { 
  <br>         List list = new ArrayList(); 
  <br>         for (int i=0; i&lt;100000; i++) 
  <br>             list.add(i); 
  <br>         //isRandomAccessSupported(list); 
  <br>         iteratorThroughRandomAccess(list) ; 
  <br>         iteratorThroughIterator(list) ; 
  <br>         iteratorThroughFor2(list) ; 
  <br> 
  <br>     } 
  <br>     private static void isRandomAccessSupported(List list) { 
  <br>         if (list instanceof RandomAccess) { 
  <br>             System.out.println("RandomAccess implemented!"); 
  <br>         } else { 
  <br>             System.out.println("RandomAccess not implemented!"); 
  <br>         } 
  <br>     } 
  <br>     public static void iteratorThroughRandomAccess(List list) { 
  <br>         long startTime; 
  <br>         long endTime; 
  <br>         startTime = System.currentTimeMillis(); 
  <br>         for (int i=0; i&lt;list.size(); i++) { 
  <br>             list.get(i); 
  <br>         } 
  <br>         endTime = System.currentTimeMillis(); 
  <br>         long interval = endTime - startTime; 
  <br>         System.out.println("iteratorThroughRandomAccess：" + interval+" ms"); 
  <br>     } 
  <br>     public static void iteratorThroughIterator(List list) { 
  <br>         long startTime; 
  <br>         long endTime; 
  <br>         startTime = System.currentTimeMillis(); 
  <br>         for(Iterator iter = list.iterator(); iter.hasNext(); ) { 
  <br>             iter.next(); 
  <br>         } 
  <br>         endTime = System.currentTimeMillis(); 
  <br>         long interval = endTime - startTime; 
  <br>         System.out.println("iteratorThroughIterator：" + interval+" ms"); 
  <br>     } 
  <p></p> 
  <p>    public static void iteratorThroughFor2(List list) {<!-- --><br>         long startTime;<br>         long endTime;<br>         startTime = System.currentTimeMillis();<br>         for(Object obj:list)<br> <br>         endTime = System.currentTimeMillis();<br>         long interval = endTime - startTime;<br>         System.out.println("iteratorThroughFor2：" + interval+" ms");<br>     }<br> }<br> </p> 
 </div> 
 <br> 运行结果： 
 <br> iteratorThroughRandomAccess：3 ms 
 <br> iteratorThroughIterator：8 ms 
 <br> iteratorThroughFor2：5 ms 
 <br> 由此可见，遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用迭代器的效率最低！ 
 <br> 
 <br>   
 <br> 
 <strong>第4部分 toArray()异常<br> </strong>当我们调用ArrayList中的 toArray()，可能遇到过抛出“java.lang.ClassCastException”异常的情况。下面我们说说这是怎么回事。 
 <br> ArrayList提供了2个toArray()函数： 
 <br> Object[] toArray() 
 <br> &lt;T&gt; T[] toArray(T[] contents) 
 <br> 调用 toArray() 函数会抛出“java.lang.ClassCastException”异常，但是调用 toArray(T[] contents) 能正常返回 T[]。 
 <br> toArray() 会抛出异常是因为 toArray() 返回的是 Object[] 数组，将 Object[] 转换为其它类型(如如，将Object[]转换为的Integer[])则会抛出“java.lang.ClassCastException”异常，因为Java不支持向下转型。具体的可以参考前面ArrayList.java的源码介绍部分的toArray()。 
 <br> 解决该问题的办法是调用 &lt;T&gt; T[] toArray(T[] contents) ， 而不是 Object[] toArray()。 
 <br> 调用 toArray(T[] contents) 返回T[]的可以通过以下几种方式实现。 
 <br> 
 <div class="codetitle"> 
  <a target="_blank" id="copybut15180" class="copybut" style=""><u>复制代码</u></a> 代码如下: 
 </div> 
 <div id="code15180" class="codebody"> 
  <br> // toArray(T[] contents)调用方式一 
  <br> public static Integer[] vectorToArray1(ArrayList&lt;Integer&gt; v) { 
  <br>     Integer[] newText = new Integer[v.size()]; 
  <br>     v.toArray(newText); 
  <br>     return newText; 
  <br> } 
  <br> // toArray(T[] contents)调用方式二。最常用！ 
  <br> public static Integer[] vectorToArray2(ArrayList&lt;Integer&gt; v) { 
  <br>     Integer[] newText = (Integer[])v.toArray(new Integer[0]); 
  <br>     return newText; 
  <br> } 
  <br> // toArray(T[] contents)调用方式三 
  <br> public static Integer[] vectorToArray3(ArrayList&lt;Integer&gt; v) { 
  <br>     Integer[] newText = new Integer[v.size()]; 
  <br>     Integer[] newStrings = (Integer[])v.toArray(newText); 
  <br>     return newStrings; 
  <br> } 
  <br> 
 </div> 
 <br> 
 <br>   
 <br> 
 <strong>第5部分 ArrayList示例<br> </strong>本文通过一个实例(ArrayListTest.java)，介绍 ArrayList 的常用API。 
 <br> 
 <div class="codetitle"> 
  <a target="_blank" id="copybut82068" class="copybut" style=""><u>复制代码</u></a> 代码如下: 
 </div> 
 <div id="code82068" class="codebody"> 
  <br> import java.util.*; 
  <br> /* 
  <br>  * @desc ArrayList常用API的测试程序 
  <br>  * @author skywang 
  <br>  * @email kuiwu-wang@163.com 
  <br>  */ 
  <br> public class ArrayListTest { 
  <br>     public static void main(String[] args) { 
  <br> 
  <br>         // 创建ArrayList 
  <br>         ArrayList list = new ArrayList(); 
  <br>         // 将“” 
  <br>         list.add("1"); 
  <br>         list.add("2"); 
  <br>         list.add("3"); 
  <br>         list.add("4"); 
  <br>         // 将下面的元素添加到第1个位置 
  <br>         list.add(0, "5"); 
  <br>         // 获取第1个元素 
  <br>         System.out.println("the first element is: "+ list.get(0)); 
  <br>         // 删除“3” 
  <br>         list.remove("3"); 
  <br>         // 获取ArrayList的大小 
  <br>         System.out.println("Arraylist size=: "+ list.size()); 
  <br>         // 判断list中是否包含"3" 
  <br>         System.out.println("ArrayList contains 3 is: "+ list.contains(3)); 
  <br>         // 设置第2个元素为10 
  <br>         list.set(1, "10"); 
  <br>         // 通过Iterator遍历ArrayList 
  <br>         for(Iterator iter = list.iterator(); iter.hasNext(); ) { 
  <br>             System.out.println("next is: "+ iter.next()); 
  <br>         } 
  <br>         // 将ArrayList转换为数组 
  <br>         String[] arr = (String[])list.toArray(new String[0]); 
  <br>         for (String str:arr) 
  <br>             System.out.println("str: "+ str); 
  <br>         // 清空ArrayList 
  <br>         list.clear(); 
  <br>         // 判断ArrayList是否为空 
  <br>         System.out.println("ArrayList is empty: "+ list.isEmpty()); 
  <br>     } 
  <br> } 
  <br> 
 </div> 
</div> ----------------------------- 
<p></p> 
<p><span style="font-weight:bold"><span style="font-size:18px"><span style="color:navy"><span style="font-family:Verdana"><br> </span></span></span></span></p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/40cf79d5928bdde46236ca125c760932/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">to_number() ----函数的用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/95dbb4004c4373b4c3913b54c59cbb5b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu 修改 ssh远程端口号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>