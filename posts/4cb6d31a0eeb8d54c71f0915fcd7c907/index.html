<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spring boot拦截器中获取request post请求中的参数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spring boot拦截器中获取request post请求中的参数" />
<meta property="og:description" content="最近有一个需要从拦截器中获取post请求的参数的需求，这里记录一下处理过程中出现的问题。
首先想到的就是request.getParameter(String )方法，但是这个方法只能在get请求中取到参数，post是不行的，后来想到了使用流的方式，调用request.getInputStream()获取流，然后从流中读取参数，如下代码所示：
String body = &#34;&#34;; StringBuilder stringBuilder = new StringBuilder(); BufferedReader bufferedReader = null; InputStream inputStream = null; try { inputStream = request.getInputStream(); if (inputStream != null) { bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); char[] charBuffer = new char[128]; int bytesRead = -1; while ((bytesRead = bufferedReader.read(charBuffer)) &gt; 0) { stringBuilder.append(charBuffer, 0, bytesRead); } } else { stringBuilder.append(&#34;&#34;); } } catch (IOException ex) { e.printStackTrace(); } finally { if (inputStream !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4cb6d31a0eeb8d54c71f0915fcd7c907/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-15T14:54:26+08:00" />
<meta property="article:modified_time" content="2019-03-15T14:54:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spring boot拦截器中获取request post请求中的参数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最近有一个需要从拦截器中获取post请求的参数的需求，这里记录一下处理过程中出现的问题。<br> 首先想到的就是request.getParameter(String )方法，但是这个方法只能在get请求中取到参数，post是不行的，后来想到了使用流的方式，调用request.getInputStream()获取流，然后从流中读取参数，如下代码所示：</p> 
<pre class="has"><code>String body = "";
StringBuilder stringBuilder = new StringBuilder();
BufferedReader bufferedReader = null;
InputStream inputStream = null;
try {
    inputStream = request.getInputStream();
    if (inputStream != null) {
        bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        char[] charBuffer = new char[128];
        int bytesRead = -1;
        while ((bytesRead = bufferedReader.read(charBuffer)) &gt; 0) {
            stringBuilder.append(charBuffer, 0, bytesRead);
        }
    } else {
        stringBuilder.append("");
    }
} catch (IOException ex) {
    e.printStackTrace();
} finally {
    if (inputStream != null) {
        try {
            inputStream.close();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }
    if (bufferedReader != null) {
        try {
            bufferedReader.close();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }
}
body = stringBuilder.toString();
</code></pre> 
<p>代码中的body就是request中的参数，我这里传的是JSON数据：{"page": 1, "pageSize": 10}，那么body就是：body = "{"page": 1, "pageSize": 10}"，一个JSON字符串。这样是可以成功获取到post请求的body，但是，经过拦截器后，参数经过@RequestBody注解赋值给controller中的方法的时候，却抛出了一个这样的异常：</p> 
<blockquote> 
 <p>org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing</p> 
</blockquote> 
<p>在网上查找资料后发现，request的输入流只能读取一次，那么这是为什么呢？下面是答案：</p> 
<blockquote> 
 <p>那是因为流对应的是数据，数据放在内存中，有的是部分放在内存中。read 一次标记一次当前位置（mark position），第二次read就从标记位置继续读（从内存中copy）数据。 所以这就是为什么读了一次第二次是空了。 怎么让它不为空呢？只要inputstream 中的pos 变成0就可以重写读取当前内存中的数据。javaAPI中有一个方法public void reset() 这个方法就是可以重置pos为起始位置，但是不是所有的IO读取流都可以调用该方法！ServletInputStream是不能调用reset方法，这就导致了只能调用一次getInputStream()。</p> 
 <p>摘自：<a href="https://blog.csdn.net/sdut406/article/details/81369983">https://blog.csdn.net/sdut406/article/details/81369983</a></p> 
</blockquote> 
<p>那么有什么办法可以用户解决呢？上面这篇博客中提到了解决方案，就是重写HttpServletRequestWrapper把request保存下来，然后通过过滤器把保存下来的request再填充进去，这样就可以多次读取request了。步骤如下所示：</p> 
<p>①写一个类，继承HttpServletRequestWrapper</p> 
<pre class="has"><code>import javax.servlet.ReadListener;
import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import java.io.*;

public class RequestWrapper extends HttpServletRequestWrapper {
    private final String body;

    public RequestWrapper(HttpServletRequest request) {
        super(request);
        StringBuilder stringBuilder = new StringBuilder();
        BufferedReader bufferedReader = null;
        InputStream inputStream = null;
        try {
            inputStream = request.getInputStream();
            if (inputStream != null) {
                bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
                char[] charBuffer = new char[128];
                int bytesRead = -1;
                while ((bytesRead = bufferedReader.read(charBuffer)) &gt; 0) {
                    stringBuilder.append(charBuffer, 0, bytesRead);
                }
            } else {
                stringBuilder.append("");
            }
        } catch (IOException ex) {

        } finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                }
                catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (bufferedReader != null) {
                try {
                    bufferedReader.close();
                }
                catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        body = stringBuilder.toString();
    }

    @Override
    public ServletInputStream getInputStream() throws IOException {
        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(body.getBytes());
        ServletInputStream servletInputStream = new ServletInputStream() {
            @Override
            public boolean isFinished() {
                return false;
            }
            @Override
            public boolean isReady() {
                return false;
            }
            @Override
            public void setReadListener(ReadListener readListener) {
            }
            @Override
            public int read() throws IOException {
                return byteArrayInputStream.read();
            }
        };
        return servletInputStream;

    }

    @Override
    public BufferedReader getReader() throws IOException {
        return new BufferedReader(new InputStreamReader(this.getInputStream()));
    }

    public String getBody() {
        return this.body;
    }

}
</code></pre> 
<p>②拦截器层面</p> 
<pre class="has"><code>package com.miniprogram.web.douyin.interceptor;

import com.alibaba.fastjson.JSON;
import com.miniprogram.api.douyin.user.req.DyuserReq;
import com.miniprogram.common.auth.VisitLimitCount;
import com.miniprogram.common.cache.RedisCache;
import com.miniprogram.common.config.InterceptorConfigMap;
import com.miniprogram.common.config.InterceptorUrlConfig;
import com.miniprogram.common.douyin.SearchEngineMapConstants;
import com.miniprogram.common.response.Response;
import com.miniprogram.common.session.*;
import com.miniprogram.common.utils.DateUtil;
import com.miniprogram.dao.common.UserLoginEntity.Users;
import com.miniprogram.service.douyin.users.UsersService;
import com.miniprogram.web.douyin.config.RequestWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Component("authSecurityInterceptor")
public class AuthSecurityInterceptor extends HandlerInterceptorAdapter {
    private Logger logger = LoggerFactory.getLogger(AuthSecurityInterceptor.class);

    @Autowired
    private UsersService douYinUsersService;
    @Autowired
    private RedisCache redisCache;
    @Autowired
    private VisitLimitCount visitLimitCount;

    @Override
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
        try {
            RequestWrapper requestWrapper = new RequestWrapper(httpServletRequest);
            String body = requestWrapper.getBody();
            System.out.println(body);
            return true;
        }catch (Exception e){
            logger.error("权限判断出错",e);
        }
        return false;
    }

    @Override
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {
    }
}
</code></pre> 
<p>③过滤器Filter，用来把request传递下去</p> 
<pre class="has"><code>
import com.miniprogram.web.douyin.config.RequestWrapper;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

@WebFilter(urlPatterns = "/*",filterName = "channelFilter")
public class ChannelFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }
 
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        ServletRequest requestWrapper = null;
        if(servletRequest instanceof HttpServletRequest) {
            requestWrapper = new RequestWrapper((HttpServletRequest) servletRequest);
        }
        if(requestWrapper == null) {
            filterChain.doFilter(servletRequest, servletResponse);
        } else {
            filterChain.doFilter(requestWrapper, servletResponse);
        }
    }
 
    @Override
    public void destroy() {

    }
}
</code></pre> 
<p>④在启动类中注册拦截器</p> 
<pre class="has"><code>import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.MultipartConfigFactory;
import org.springframework.boot.web.servlet.ServletComponentScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@SpringBootApplication
@ServletComponentScan  //注册过滤器注解
@Configuration
public class WebApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebApplication.class, args);
    }
}
</code></pre> 
<p>经测试，问题解决</p> 
<p><br> 链接：https://www.jianshu.com/p/69c6fba08c92</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bbb8d5d91be6ea4f0bb06ae7254cc4ce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;常见崩溃问题分析处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4396dab4fab434f638d1d24fef62ca57/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">sql语句---用户权限设置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>