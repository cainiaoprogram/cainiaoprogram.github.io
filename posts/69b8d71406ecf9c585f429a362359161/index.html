<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅析C#的事件处理和自定义事件[object sender , EventArgs e] - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅析C#的事件处理和自定义事件[object sender , EventArgs e]" />
<meta property="og:description" content="浅析C#的事件处理和自定义事件 一、了解C#中的预定义事件处理机制
在写代码前我们先来熟悉.net框架中和事件有关的类和委托，了解C#中预定义事件的处理。
EventArgs是包含事件数据的类的基类,用于传递事件的细节。
EventHandler是一个委托声明如下
public delegate void EventHandler( object sender , EventArgs e )
注意这里的参数,前者是一个对象（其实这里传递的是对象的引用，如果是button1的click事件则sender就是button1），后面是包含事件数据的类的基类。
下面我们研究一下Button类看看其中的事件声明（使用WinCV工具查看），以Click事件为例。
public event EventHandler Click;
这里定义了一个EventHandler类型的事件Click
前面的内容都是C#在类库中已经为我们定义好了的。下面我们来看编程时产生的代码。
private void button1_Click(object sender, System.EventArgs e)
{
...
}
这是我们和button1_click事件所对应的方法。注意方法的参数符合委托中的签名（既参数列表）。那我们怎么把这个方法和事件联系起来呢，请看下面的代码。
this.button1.Click &#43;= new System.EventHandler(this.button1_Click);
把this.button1_Click方法绑定到this.button1.Click事件。
下面我们研究一下C#事件处理的工作流程，首先系统会在为我们创建一个在后台监听事件的对象(如果是 button1的事件那么监听事件的就是button1)，这个对象用来产生事件，如果有某个用户事件发生则产生对应的应用程序事件，然后执行订阅了事件 的所有方法。
二、简单的自定义事件(1)
首先我们需要定义一个类来监听客户端事件，这里我们监听键盘的输入。
定义一个委托。
public delegate void UserRequest(object sender,EventArgs e);
前面的object用来传递事件的发生者，后面的EventArgs用来传递事件的细节，现在暂时没什么用处，一会后面的例子中将使用。
下面定义一个此委托类型类型的事件
public event UserRequest OnUserRequest;
下面我们来做一个死循环
public void Run()
{
bool finished=false;
do
{
if (Console.ReadLine()==&#34;h&#34;)
{
OnUserRequest(this,new EventArgs());" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/69b8d71406ecf9c585f429a362359161/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2007-02-25T15:22:00+08:00" />
<meta property="article:modified_time" content="2007-02-25T15:22:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅析C#的事件处理和自定义事件[object sender , EventArgs e]</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                      
<h3 align="center">浅析C#的事件处理和自定义事件 </h3> 
<p class="style1"><strong>一、了解C#中的预定义事件处理机制</strong></p> 
<p class="style1">    在写代码前我们先来熟悉.net框架中和事件有关的类和委托，了解C#中预定义事件的处理。</p> 
<p class="style1"><strong>    EventArgs</strong>是包含事件数据的类的基类,用于传递事件的细节。</p> 
<p class="style1"><strong>    EventHandler</strong>是一个委托声明如下</p> 
<p class="style1">         public delegate void EventHandler( object <em>sender </em>, EventArgs e <strong>)</strong></p> 
<p class="style1">    注意这里的参数,前者是一个对象（其实这里传递的是对象的引用，如果是button1的click事件则sender就是button1），后面是包含事件数据的类的基类。</p> 
<p class="style1">    下面我们研究一下Button类看看其中的事件声明（使用WinCV工具查看），以Click事件为例。</p> 
<p class="style1">         public event EventHandler Click;</p> 
<p class="style1">    这里定义了一个EventHandler类型的事件Click</p> 
<p class="style1">    前面的内容都是C#在类库中已经为我们定义好了的。下面我们来看编程时产生的代码。</p> 
<p class="style1">        private void button1_Click(object sender, System.EventArgs e)<br>        {<!-- --><br>            ...<br>        }</p> 
<p class="style1">    这是我们和button1_click事件所对应的方法。注意方法的参数符合委托中的签名（既参数列表）。那我们怎么把这个方法和事件联系起来呢，请看下面的代码。</p> 
<p class="style1">        this.button1.Click += new System.EventHandler(this.button1_Click);</p> 
<p class="style1">    把this.button1_Click方法绑定到this.button1.Click事件。</p> 
<p class="style1">    下面我们研究一下C#事件处理的工作流程，首先系统会在为我们创建一个在后台监听事件的对象(如果是 button1的事件那么监听事件的就是button1)，这个对象用来产生事件，如果有某个用户事件发生则产生对应的应用程序事件，然后执行订阅了事件 的所有方法。</p> 
<p class="style1"><strong>二、简单的自定义事件(1)</strong></p> 
<p class="style1">    首先我们需要定义一个类来监听客户端事件，这里我们监听键盘的输入。</p> 
<p class="style1">    定义一个委托。</p> 
<p class="style1">        public delegate void UserRequest(object sender,EventArgs e);</p> 
<p class="style1">    前面的object用来传递事件的发生者，后面的EventArgs用来传递事件的细节，现在暂时没什么用处，一会后面的例子中将使用。</p> 
<p class="style1">    下面定义一个此委托类型类型的事件</p> 
<p class="style1">        public event UserRequest OnUserRequest;</p> 
<p class="style1">    下面我们来做一个死循环</p> 
<pre class="style1">        public void Run()<br>      {<!-- --><br>      bool finished=false;<br>      do<br>      {<!-- --><br>       if (Console.ReadLine()=="h")<br>       {<!-- --><br>        OnUserRequest(this,new EventArgs());<br>       }  <br>      }while(!finished);<br>      }<br><br></pre> 
<p class="style1">    此代码不断的要求用户输入字符，如果输入的结果是h,则触发OnUserRequest事件，事件的触发者是本身（this），事件细节无(没有传递任何参数的EventArgs实例)。我们给这个类取名为UserInputMonitor。</p> 
<pre class="style1">   下面我们要做的是定义客户端的类<br>    首先得实例化UserInputMonitor类</pre> 
<p class="style1">       UserInputMonitor monitor=new UserInputMonitor();</p> 
<p class="style1">    然后我们定义一个方法。</p> 
<p class="style1">       private void ShowMessage(object sender,EventArgs e)<br>      {<!-- --><br>          Console.WriteLine("HaHa!!");<br>      }</p> 
<p class="style1">     最后要做的是把这个方法和事件联系起来（订阅事件），我们把它写到库户端类的构造函数里。</p> 
<p class="style1">     Client(UserInputMonitor m)<br>     {<!-- --><br>      m.OnUserRequest+=new UserInputMonitor.UserRequest(this.ShowMessage);<br>      //m.OnUserRequest+=new m.UserRequest(this.ShowMessage);</p> 
<p class="style1">      //注意这种写法是错误的，因为委托是静态的<br><br>     }</p> 
<p class="style1">     下面创建客户端的实例。</p> 
<p class="style1">         new Client(monitor);</p> 
<p class="style1">     对了，别忘了让monitor开始监听事件。</p> 
<p class="style1">        monitor.run();</p> 
<p class="style1">     大功告成，代码如下：</p> 
<blockquote> 
 <blockquote> 
  <pre class="style1">using System;<br>class UserInputMonitor<br>{<!-- --><br> public delegate void UserRequest(object sender,EventArgs e);<br> //定义委托<br> public event UserRequest OnUserRequest;<br> //此委托类型类型的事件<br> public void Run()<br> {<!-- --><br>  bool finished=false;<br>  do<br>  {<!-- --><br>   if (Console.ReadLine()=="h")<br>   {<!-- --><br>    OnUserRequest(this,new EventArgs());<br>   }  <br>  }while(!finished);<br> }<br>}<br>    </pre> 
  <pre class="style1">public class Client<br>{<!-- --><br> public static void Main()<br> {<!-- --><br>  UserInputMonitor monitor=new UserInputMonitor();<br>  new Client(monitor);<br>  monitor.Run();<br> }<br> private void ShowMessage(object sender,EventArgs e)<br> {<!-- --><br>  Console.WriteLine("HaHa!!");<br> }<br> Client(UserInputMonitor m)<br> {<!-- --><br>  m.OnUserRequest+=new UserInputMonitor.UserRequest(this.ShowMessage);<br>  //m.OnUserRequest+=new m.UserRequest(this.ShowMessage);<br>  //注意这种写法是错误的，因为委托是静态的<br> }<br>}</pre> 
 </blockquote> 
</blockquote> 
<p class="style1"><strong>三、进一步研究C#中的预定义事件处理机制</strong></p> 
<p class="style1">    可能大家发现在C#中有些事件和前面的似乎不太一样。例如</p> 
<p class="style1">    <span class="style4">  private void textBox1_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)<br>      {<!-- --><br><br>      }</span></p> 
<p class="style3">      this.textBox1.KeyPress+=newSystem.Windows.Forms.KeyPressEventHandler(this.textBox1_KeyPress);</p> 
<p class="style1">    这里使用了<span class="style4">KeyPressEventArgs</span>而不是EventArgs作为参数。这里使用了KeyEventHandler委托，而不是EventHandler委托。 </p> 
<p class="style1">    <span class="style4">KeyPressEventArgs</span>是EventArgs的派生类，而KeyEventHandler的声明如下</p> 
<p class="style1">      public delegate void KeyEventHandler( object <em>sender </em><strong>, </strong>KeyEventArgs <em>e </em><strong>); </strong></p> 
<p class="style1">   是参数为KeyEventArgs的委托。那为什么<span class="style3">KeyPress</span>事件要这么做呢，我们可以从两个类的构造函数来找答案。</p> 
<p class="style1">       public EventArgs(); </p> 
<p class="style1">       public KeyPressEventArgs(char keyChar);</p> 
<p class="style1">    这里的keyData是什么，是用来传递我们按下了哪个键的，哈。</p> 
<p class="style1">    我在KeyEventArgs中又发现了属性</p> 
<p class="style1">       public char KeyChar { get; }</p> 
<p class="style1">    进一步证明了我的理论。下面我们来做一个类似的例子来帮助理解。</p> 
<p class="style1"><strong>四、简单的自定义事件(2)</strong></p> 
<p class="style1">    拿我们上面做的例子来改。</p> 
<p class="style1">    我们也定义一个EventArgs（类似KeyEventArgs）取名MyEventArgs,定义一个构造函数public MyEventArgs(char keyChar),同样我们也设置相应的属性。代码如下</p> 
<blockquote> 
 <pre class="style1">using System;<br>class MyMyEventArgs:EventArgs<br>{<!-- --><br> private char keyChar;<br> public MyMyEventArgs(char keyChar)<br> {<!-- --><br>  this.keychar=keychar;<br> }<br> public char KeyChar<br> {<!-- --><br>  get<br>  {<!-- --><br>   return keyChar;<br>  }<br> }<br>}<br></pre> 
</blockquote> 
<p>因为现在要监听多个键了，我们得改写监听器的类中的do...while部分。改写委托，改写客户端传递的参数。好了最终代码如下，好累</p> 
<blockquote> 
 <pre class="style1">using System;<br>class MyEventArgs:EventArgs<br>{<!-- --><br> private char keyChar;<br> public MyEventArgs(char keyChar)<br> {<!-- --><br>  this.keyChar=keyChar;<br> }<br> public char KeyChar<br> {<!-- --><br>  get<br>  {<!-- --><br>   return keyChar;<br>  }<br> }<br>}<br>  </pre> 
 <pre class="style1">class UserInputMonitor<br>{<!-- --><br> public delegate void UserRequest(object sender,MyEventArgs e);<br> //定义委托<br> public event UserRequest OnUserRequest;<br> //此委托类型类型的事件<br> public void Run()<br> {<!-- --><br>  bool finished=false;<br>  do<br>  {<!-- --><br>   string inputString= Console.ReadLine();<br>   if (inputString!="") <br>    OnUserRequest(this,new MyEventArgs(inputString[0]));<br>  }while(!finished);<br> }<br>}<br><br>  </pre> 
 <pre class="style1">public class Client<br>{<!-- --><br> public static void Main()<br> {<!-- --><br>  UserInputMonitor monitor=new UserInputMonitor();<br>  new Client(monitor);<br>  monitor.Run();<br> }<br> private void ShowMessage(object sender,MyEventArgs e)<br> {<!-- --><br>  Console.WriteLine("捕捉到：{0}",e.KeyChar);<br> }<br> Client(UserInputMonitor m)<br> {<!-- --><br>  m.OnUserRequest+=new UserInputMonitor.UserRequest(this.ShowMessage);<br>  //m.OnUserRequest+=new m.UserRequest(this.ShowMessage);<br>  //注意这种写法是错误的，因为委托是静态的<br> }<br>}</pre> 
 <p> </p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4909da2ddcf5717516115e0133de6542/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安装不上WINDOWS INSTALLER 3.1!!</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/69f6d928b8a72c7c4046e8f0e3c83338/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VC/.NET,SQL SERVER 2000/2005的选择</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>