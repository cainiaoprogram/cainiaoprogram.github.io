<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>异常处理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="异常处理" />
<meta property="og:description" content="1.相关概念的介绍 1）异常情形：是指阻止当前方法或作用域继续执行的问题。
2）监控区域：一段可能产生异常的代码，并且后面跟着处理这些异常的代码。
3）try块：如果在方法的内部或者在方法内部调用某个方法抛出异常，这个方法将在抛出异常的过程中结束，如果不希望该方法结束，可以在方法内设置一个特殊的块来捕获异常，这个块就叫做try块
4）异常处理程序：抛出的异常必须在某个地方进行处理，处理这个异常的地方就叫异常处理程序。
5）异常处理理论上有两种基本模型：java支持终止模型，还有一种是恢复模型
a)终止模型：将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行，一旦异常被抛出，就表明错误已经无法挽回，也不能回来继续执行。
b)恢复模型：异常处理程序的工作室修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功，恢复模型，通过希望异常被处理之后能继续执行程序。
注：恢复模型不实用的原因是它可能导致耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码，而且增大了代码的编写和维护的困难。
6）异常说明：java提供了相应的语法，使你能够以礼貌的方式告知客户端程序员某个方法 可能会抛出异常，然后客户端程序员就可以进行相应的处理。
7）被检查的异常：在编译时被强制检查的异常。
8）异常链：在捕获一个异常后抛出另外一个异常，并且希望把原始异常的信息保存下来。
9）一个类的子类只能抛出比基类异常更具体的异常，而不能抛出比基类所抛出异常范围更大的异常。
2.异常参数 1）用new在堆上创建异常对象，此时也有存储空间的分配和构造器的调用，所有标准异常类都有两个构造器：一个是默认的构造器，一个是接受字符串为参数，能把相关信息放入异常对象的构造器。
2）关键字throw,它是在使用new创建异常对象之后，然后将此对象的引用传给throw。
3）Throwable是异常的根类，它能够抛出任意类型的Throwable对象。
3.异常处理程序 1）每个要捕的异常，得准备相应的处理程序，异常处理程序紧跟在try块之后，用关键字catch表示。
2）每个catch子句只能接受一个且仅仅接受一个特殊类型的参数的方法，可以在处理程序的内部使用标识符。
3）异常处理程序catch块必须紧跟在try块之后，当有异常被抛出的时候，异常处理机制将负责搜寻参数与异常类型相匹配的第一个程序。然后进入相应的catch子句进行执行，此时认为异常得到了处理。一旦catch子句结束，则处理程序的查找过程也会结束。
注：只有匹配的catch子句才能得到执行。
4.关于自定义异常 有的时候可以不用异常体系中的异常，可以自己创建一个异常类型，如果要自定义异常，则必须从已有的异常类进行继承，最好是选择意思相近的异常类继承，建立新的异常类型最简单的方法就是让编译器为你产生默认的构造器。
5.throws关键字（异常说明） 异常说明是方法声明的一部分，紧跟在形式参数列表之后，异常说明使用了附加的关键字throws，后面接一个所有潜在异常类型的参数列表。
6.在进行异常处理的时候，最好把Exception异常放在异常处理程序的末尾，防止它在其他子异常进行捕获的时候抢先捕获异常，因为它是所有异常类的根基类。 7.JAVA标准异常 1）Throwable是用来表示任何可以作为异常抛出的类，Throwable对象可以分为两个类型：
a)Error类型：用来表示编译时和系统的错误（除了特殊情况以外，一般不用关心）
b)Exception类型：是可以被抛出的基本类型。
8.finally关键字 1）无论异常是否被抛出，finally子句总是可以被执行
2）JAVA在什么时候才能用到finally：
当要把除内存之外的资源恢复到它们的初试状态时，就要用到finally子句。这种需要清理的资源包括：已经打开的文件或者网络链接，在屏幕上画的图形等等
3）当涉及到break或者continue语句的时候，finally子句也会得到执行，如果把finally子句和带标签的break和continue子句配合使用，在java里就没有必要使用goto语句
4)在return中使用finally(笔试的时候这个题很常见在异常处理的读程序题中)
因为finally子句总是会执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍然会执行。
9.异常的匹配 在抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，他就认为异常将得到处理，然后就不会继续的查找。
10.异常处理的一个重要原则就是：只有在指导如何处理的情况下才捕获异常； 异常处理的一个重要目标就是把错误处理的代码同错误发生的地点相分离。
11.异常应该在这些情况下被使用： 1）再恰当的级别处理问题，前提是要知道该如何处理的情况下才可以捕获异常
2）解决问题并且重新调用产生异常的方法
3）进行少许的修补，然后绕过异常发生的地方继续执行
4）用别的数据进行计算，以代替方法预计会返回的值
5）把当前运行环境下能做的事尽量做完，然后把相同的异常抛到更高的层次
6）把当前运行环境下能做的事尽量做完，然后把相同的异常抛到更低的层次
7）终止程序
8）进行简化
9）让类库和程序更加安全。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e449cf10ae6de811f01f64c323cd596c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-11-08T12:03:07+08:00" />
<meta property="article:modified_time" content="2015-11-08T12:03:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">异常处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.相关概念的介绍</h2> 
<p>1）<strong>异常情形</strong>：是指阻止当前方法或作用域继续执行的问题。</p> 
<p>2）<strong>监控区域</strong>：一段可能产生异常的代码，并且后面跟着处理这些异常的代码。</p> 
<p>3）<strong>try块</strong>：如果在方法的内部或者在方法内部调用某个方法抛出异常，这个方法将在抛出异常的过程中结束，如果不希望该方法结束，可以在方法内设置一个特殊的块来捕获异常，这个块就叫做try块</p> 
<p>4）<strong>异常处理程序</strong>：抛出的异常必须在某个地方进行处理，处理这个异常的地方就叫异常处理程序。</p> 
<p>5）异常处理理论上有两种基本模型：<strong>java支持终止模型，还有一种是恢复模型</strong></p> 
<p>a)终止模型：将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行，一旦异常被抛出，就表明错误已经无法挽回，也不能回来继续执行。</p> 
<p>b)恢复模型：异常处理程序的工作室修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功，恢复模型，通过希望异常被处理之后能继续执行程序。</p> 
<p>注：恢复模型不实用的原因是它可能导致耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码，而且增大了代码的编写和维护的困难。</p> 
<p>6）<strong>异常说明</strong>：java提供了相应的语法，使你能够以礼貌的方式告知客户端程序员某个方法 可能会抛出异常，然后客户端程序员就可以进行相应的处理。</p> 
<p>7）<strong>被检查的异常</strong>：在编译时被强制检查的异常。</p> 
<p>8）<strong>异常链</strong>：在捕获一个异常后抛出另外一个异常，并且希望把原始异常的信息保存下来。</p> 
<p>9）一个类的子类只能抛出比基类异常更具体的异常，而不能抛出比基类所抛出异常范围更大的异常。</p> 
<h2>2.异常参数</h2> 
<p>1）用new在堆上创建异常对象，此时也有存储空间的分配和构造器的调用，所有标准异常类都有两个构造器：一个是默认的构造器，一个是接受字符串为参数，能把相关信息放入异常对象的构造器。</p> 
<p>2）<strong>关键字throw,它是在使用new创建异常对象之后，然后将此对象的引用传给throw。</strong></p> 
<p>3）Throwable是异常的根类，它能够抛出任意类型的Throwable对象。</p> 
<h2>3.异常处理程序</h2> 
<p>1）每个要捕的异常，得准备相应的处理程序，异常处理程序紧跟在try块之后，用关键字catch表示。</p> 
<p>2）每个catch子句只能接受一个且仅仅接受一个特殊类型的参数的方法，可以在处理程序的内部使用标识符。</p> 
<p>3）异常处理程序catch块必须紧跟在try块之后，当有异常被抛出的时候，异常处理机制将负责搜寻参数与异常类型相匹配的第一个程序。然后进入相应的catch子句进行执行，此时认为异常得到了处理。一旦catch子句结束，则处理程序的查找过程也会结束。</p> 
<p>注：只有匹配的catch子句才能得到执行。</p> 
<h2>4.关于自定义异常</h2> 
<p>有的时候可以不用异常体系中的异常，可以自己创建一个异常类型，如果要自定义异常，则必须从已有的异常类进行继承，最好是选择意思相近的异常类继承，建立新的异常类型最简单的方法就是让编译器为你产生默认的构造器。</p> 
<h2>5.throws关键字（异常说明）</h2> 
<p>异常说明是方法声明的一部分，紧跟在形式参数列表之后，异常说明使用了附加的关键字throws，后面接一个所有潜在异常类型的参数列表。</p> 
<h2>6.在进行异常处理的时候，最好把Exception异常放在异常处理程序的末尾，防止它在其他子异常进行捕获的时候抢先捕获异常，因为它是所有异常类的根基类。</h2> 
<h2>7.JAVA标准异常</h2> 
<p>1）<strong>Throwable</strong>是用来表示任何可以作为异常抛出的类，Throwable对象可以分为两个类型：</p> 
<p>a)<strong>Error类型</strong>：用来表示编译时和系统的错误（除了特殊情况以外，一般不用关心）</p> 
<p>b)<strong>Exception类型</strong>：是可以被抛出的基本类型。</p> 
<h2>8.finally关键字</h2> 
<p>1）<strong>无论异常是否被抛出，finally子句总是可以被执行</strong></p> 
<p>2）JAVA在什么时候才能用到finally：</p> 
<p>当要把除内存之外的资源恢复到它们的初试状态时，就要用到finally子句。这种需要清理的资源包括：已经打开的文件或者网络链接，在屏幕上画的图形等等</p> 
<p>3）当涉及到break或者continue语句的时候，finally子句也会得到执行，如果把finally子句和带标签的break和continue子句配合使用，在java里就没有必要使用goto语句</p> 
<p>4)<strong>在return中使用finally(笔试的时候这个题很常见在异常处理的读程序题中)</strong></p> 
<p>因为finally子句总是会执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍然会执行。</p> 
<h2>9.异常的匹配</h2> 
<p>在抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，他就认为异常将得到处理，然后就不会继续的查找。</p> 
<h2>10.异常处理的一个重要原则就是：只有在指导如何处理的情况下才捕获异常；</h2> 
<p>异常处理的一个重要目标就是把错误处理的代码同错误发生的地点相分离。</p> 
<h2>11.异常应该在这些情况下被使用：</h2> 
<p>1）再恰当的级别处理问题，前提是要知道该如何处理的情况下才可以捕获异常</p> 
<p>2）解决问题并且重新调用产生异常的方法</p> 
<p>3）进行少许的修补，然后绕过异常发生的地方继续执行</p> 
<p>4）用别的数据进行计算，以代替方法预计会返回的值</p> 
<p>5）把当前运行环境下能做的事尽量做完，然后把相同的异常抛到更高的层次</p> 
<p>6）把当前运行环境下能做的事尽量做完，然后把相同的异常抛到更低的层次</p> 
<p>7）终止程序</p> 
<p>8）进行简化</p> 
<p>9）让类库和程序更加安全。</p> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/2e/48/M2qUaqPO_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f51fad6c0401585d125998db2c8d10a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">scala与java的性能对比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dfc7109f45dc50a1ec8fb59f35f597a1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阶跃响应指标的matlab计算</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>