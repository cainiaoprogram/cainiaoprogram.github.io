<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>树莓派视觉小车 -- OpenCV巡线(HSL色彩空间、PID) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="树莓派视觉小车 -- OpenCV巡线(HSL色彩空间、PID)" />
<meta property="og:description" content="目录
试错
试错1：形态学处理
试错2：HSV色彩空间
基础理论
1、HSV与HSL色彩空间
2、PID调节
一、OpenCV图像处理
1、在HSL色彩空间下得到二值图
2、 对二值图形态学处理
3、找出线的轮廓和中心点坐标
二、PID
三、运动控制
总代码
试错 试错1：形态学处理 一开始用的形态学处理，自行改变阈值，调试之后，进行处理，发现效果不是太好，于是改成了HSV色彩空间。
试错2：HSV色彩空间 之前没注意到，HSV色彩空间很难识别白色：
HSV： 不难看出，如果寻白色线的话，HSV色彩空间不是一个很好的选择，下面引入HSL色彩空间：
HSL：
所以，如果是巡白色的话，建议用HSL色彩空间。
注意：巡线小车的摄像头不能太低，如果太低了，可能让小车自己的影子会阻碍光线。
hsv中的效果：
hsl中的效果：
可以看出，已经能大致找到白线了。
基础理论 1、HSV与HSL色彩空间 HSV： 不难看出，如果寻白色线的话，HSV色彩空间不是一个很好的选择，下面引入HSL色彩空间：
HSL：
所以，如果是巡白色的话，建议用HSL色彩空间。
2、PID调节 个人理解：
P：拉力
I：推动力
D：阻力 一、OpenCV图像处理 1、在HSL色彩空间下得到二值图 # 在HSV色彩空间下得到二值图 def Get_HSV(image): # 1 get trackbar&#39;s value hmin = cv2.getTrackbarPos(&#39;hmin&#39;, &#39;h_binary&#39;) hmax = cv2.getTrackbarPos(&#39;hmax&#39;, &#39;h_binary&#39;) smin = cv2.getTrackbarPos(&#39;smin&#39;, &#39;s_binary&#39;) smax = cv2.getTrackbarPos(&#39;smax&#39;, &#39;s_binary&#39;) lmin = cv2.getTrackbarPos(&#39;lmin&#39;, &#39;l_binary&#39;) lmax = cv2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b1e7facd71cdb20c2e0426b324c7502e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-26T19:43:35+08:00" />
<meta property="article:modified_time" content="2023-03-26T19:43:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">树莓派视觉小车 -- OpenCV巡线(HSL色彩空间、PID)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81%E8%AF%95%E9%94%99-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81%E8%AF%95%E9%94%99" rel="nofollow">试错</a></p> 
<p id="%E8%AF%95%E9%94%991%EF%BC%9A%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%94%991%EF%BC%9A%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86" rel="nofollow">试错1：形态学处理</a></p> 
<p id="%E8%AF%95%E9%94%992%EF%BC%9AHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%94%992%EF%BC%9AHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4" rel="nofollow">试错2：HSV色彩空间</a></p> 
<p id="%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA-toc" style="margin-left:0px;"><a href="#%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA" rel="nofollow">基础理论</a></p> 
<p id="1%E3%80%81HSV%E4%B8%8EHSL%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4-toc" style="margin-left:40px;"><a href="#1%E3%80%81HSV%E4%B8%8EHSL%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4" rel="nofollow">1、HSV与HSL色彩空间</a></p> 
<p id="2%E3%80%81PID%E8%B0%83%E8%8A%82-toc" style="margin-left:40px;"><a href="#2%E3%80%81PID%E8%B0%83%E8%8A%82" rel="nofollow">2、PID调节</a></p> 
<p id="%E4%B8%80%E3%80%81OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86" rel="nofollow">一、OpenCV图像处理</a></p> 
<p id="1%E3%80%81%E5%9C%A8HSL%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%B8%8B%E5%BE%97%E5%88%B0%E4%BA%8C%E5%80%BC%E5%9B%BE-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%9C%A8HSL%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%B8%8B%E5%BE%97%E5%88%B0%E4%BA%8C%E5%80%BC%E5%9B%BE" rel="nofollow">1、在HSL色彩空间下得到二值图</a></p> 
<p id="2%E3%80%81%20%E5%AF%B9%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#2%E3%80%81%20%E5%AF%B9%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86" rel="nofollow">2、 对二值图形态学处理</a></p> 
<p id="3%E3%80%81%E6%89%BE%E5%87%BA%E7%BA%BF%E7%9A%84%E8%BD%AE%E5%BB%93%E5%92%8C%E4%B8%AD%E5%BF%83%E7%82%B9%E5%9D%90%E6%A0%87-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%89%BE%E5%87%BA%E7%BA%BF%E7%9A%84%E8%BD%AE%E5%BB%93%E5%92%8C%E4%B8%AD%E5%BF%83%E7%82%B9%E5%9D%90%E6%A0%87" rel="nofollow">3、找出线的轮廓和中心点坐标</a></p> 
<p id="%E4%BA%8C%E3%80%81PID-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81PID" rel="nofollow">二、PID</a></p> 
<p id="%E4%B8%89%E3%80%81%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6" rel="nofollow">三、运动控制</a></p> 
<p id="%E6%80%BB%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E4%BB%A3%E7%A0%81" rel="nofollow">总代码</a></p> 
<hr id="hr-toc"> 
<h2 id="%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81%E8%AF%95%E9%94%99" style="margin-left:.0001pt;text-align:justify;">试错</h2> 
<h3 id="%E8%AF%95%E9%94%991%EF%BC%9A%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86">试错1：形态学处理</h3> 
<p><img alt="" height="143" src="https://images2.imgbox.com/2f/0a/h1UqzfVp_o.png" width="114"></p> 
<p>一开始用的形态学处理，自行改变阈值，调试之后，进行处理，发现效果不是太好，于是改成了HSV色彩空间。</p> 
<p></p> 
<h3 id="%E8%AF%95%E9%94%992%EF%BC%9AHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">试错2：HSV色彩空间</h3> 
<p>之前没注意到，HSV色彩空间很难识别白色：</p> 
<p><strong>HSV</strong>： </p> 
<p><img alt="" height="540" src="https://images2.imgbox.com/22/d4/rfHVe8Jb_o.png" width="999"> 不难看出，<strong>如果寻白色线的话，HSV色彩空间不是一个很好的选择，下面引入HSL色彩空间</strong>：</p> 
<p> <strong>HSL</strong>：</p> 
<p style="text-align:center;"><img alt="preview" src="https://images2.imgbox.com/8b/d0/JjAHDMod_o.png"></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/37/50/aSkElNn7_o.png" width="638"></p> 
<p>所以，<span style="color:#fe2c24;"><strong>如果是巡白色的话，建议用HSL色彩空间</strong></span>。</p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>注意：巡线小车的摄像头不能太低，如果太低了，可能让<span style="color:#0d0016;">小车自己的影子会阻碍光线</span></strong>。</p> 
<p></p> 
<p>hsv中的效果：</p> 
<p> <img alt="" height="667" src="https://images2.imgbox.com/b8/b0/V8nxDOtx_o.png" width="234"></p> 
<p></p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/88/9c/oOrsSD9V_o.png" width="109"></p> 
<p></p> 
<p>hsl中的效果：</p> 
<p><img alt="" height="597" src="https://images2.imgbox.com/0d/63/i6h9NkK7_o.png" width="119"></p> 
<p>可以看出，已经能大致找到白线了。</p> 
<p></p> 
<h2 id="%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA">基础理论</h2> 
<h3 id="1%E3%80%81HSV%E4%B8%8EHSL%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">1、HSV与HSL色彩空间</h3> 
<p><strong> HSV</strong>： </p> 
<p><img alt="" height="540" src="https://images2.imgbox.com/7f/19/GtiVvc6q_o.png" width="999"> 不难看出，<strong>如果寻白色线的话，HSV色彩空间不是一个很好的选择，下面引入HSL色彩空间</strong>：</p> 
<p> <strong>HSL</strong>：</p> 
<p style="text-align:center;"><img alt="preview" src="https://images2.imgbox.com/08/6c/kgPLGzRv_o.png"></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/96/8c/g1KU0KNf_o.png" width="638"></p> 
<p>所以，<span style="color:#fe2c24;"><strong>如果是巡白色的话，建议用HSL色彩空间</strong></span>。</p> 
<p></p> 
<h3 id="2%E3%80%81PID%E8%B0%83%E8%8A%82">2、PID调节</h3> 
<p>个人理解：</p> 
<blockquote> 
 <p><strong>P：拉力</strong></p> 
 <p><strong>I：推动力</strong></p> 
 <p><strong>D：阻力 </strong></p> 
</blockquote> 
<p><img alt="" height="201" src="https://images2.imgbox.com/44/db/4sEbWcsb_o.png" width="285"></p> 
<p></p> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86">一、OpenCV图像处理</h2> 
<p><img alt="" height="101" src="https://images2.imgbox.com/73/ca/5Uw4qUoN_o.png" width="100"></p> 
<h3 id="1%E3%80%81%E5%9C%A8HSL%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%B8%8B%E5%BE%97%E5%88%B0%E4%BA%8C%E5%80%BC%E5%9B%BE">1、在HSL色彩空间下得到二值图</h3> 
<p><img alt="" height="104" src="https://images2.imgbox.com/e8/e1/EaMxKCNO_o.png" width="109"></p> 
<p></p> 
<p> <img alt="" height="534" src="https://images2.imgbox.com/a0/d9/YeQzs1W3_o.png" width="109"><img alt="" height="91" src="https://images2.imgbox.com/b4/21/gI0amYGK_o.png" width="105"></p> 
<p></p> 
<pre><code class="language-python"># 在HSV色彩空间下得到二值图
def Get_HSV(image):
    # 1 get trackbar's value
    hmin = cv2.getTrackbarPos('hmin', 'h_binary')
    hmax = cv2.getTrackbarPos('hmax', 'h_binary')
    smin = cv2.getTrackbarPos('smin', 's_binary')
    smax = cv2.getTrackbarPos('smax', 's_binary')
    lmin = cv2.getTrackbarPos('lmin', 'l_binary')
    lmax = cv2.getTrackbarPos('lmax', 'l_binary')

    # 2 to HSV
    hls = cv2.cvtColor(image, cv2.COLOR_BGR2HLS)
    cv2.imshow('hls', hls)
    h, l, s = cv2.split(hls)

    # 3 set threshold (binary image)
    # if value in (min, max):white; otherwise:black
    h_binary = cv2.inRange(np.array(h), np.array(hmin), np.array(hmax))
    s_binary = cv2.inRange(np.array(s), np.array(smin), np.array(smax))
    l_binary = cv2.inRange(np.array(l), np.array(lmin), np.array(lmax))

    # 4 get binary（对H、S、V三个通道分别与操作）
    binary = 255 - cv2.bitwise_and(h_binary, cv2.bitwise_and(s_binary, l_binary))

    # 5 Show
    cv2.imshow('h_binary', h_binary)
    cv2.imshow('s_binary', s_binary)
    cv2.imshow('l_binary', l_binary)
    cv2.imshow('binary', binary)

    return binary</code></pre> 
<p></p> 
<h3 id="2%E3%80%81%20%E5%AF%B9%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86">2、 对二值图形态学处理</h3> 
<p> <img alt="" height="94" src="https://images2.imgbox.com/99/59/B4abOPoe_o.png" width="105"></p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/2d/a6/A10iNrnF_o.png" width="110"></p> 
<p></p> 
<pre><code class="language-python"># 图像处理
def Image_Processing():
    global frame, binary
    # Capture the frames
    ret, frame = camera.read()

    # to binary
    binary = Get_HSV(frame)

    blur = cv2.GaussianBlur(binary, (5, 5), 0)
    cv2.imshow('blur', blur)

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (35, 35))
    Open = cv2.morphologyEx(blur, cv2.MORPH_OPEN, kernel)
    cv2.imshow('Open', Open)

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 25))
    Erode = cv2.morphologyEx(Open, cv2.MORPH_ERODE, kernel)
    cv2.imshow('Erode', Erode)

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 25))
    Dilate = cv2.morphologyEx(Erode, cv2.MORPH_DILATE, kernel)
    cv2.imshow('Dilate', Dilate)

    binary = Erode#Dilate</code></pre> 
<p></p> 
<h3 id="3%E3%80%81%E6%89%BE%E5%87%BA%E7%BA%BF%E7%9A%84%E8%BD%AE%E5%BB%93%E5%92%8C%E4%B8%AD%E5%BF%83%E7%82%B9%E5%9D%90%E6%A0%87">3、找出线的轮廓和中心点坐标</h3> 
<p> <img alt="" height="100" src="https://images2.imgbox.com/d5/db/zrTGcRc6_o.png" width="103"></p> 
<p> <img alt="" height="48" src="https://images2.imgbox.com/a9/e4/H2513Siz_o.png" width="95"></p> 
<pre><code class="language-python"># 找线
def Find_Line():
    global x, y, image
    # 1 找出所有轮廓
    bin2, contours, hierarchy = cv2.findContours(binary, 1, cv2.CHAIN_APPROX_NONE)
    
    # 2 找出最大轮廓
    if len(contours) &gt; 0:
        # 最大轮廓
        c = max(contours, key=cv2.contourArea)
        M = cv2.moments(c)

        # 中心点坐标
        x = int(M['m10'] / M['m00'])
        y = int(M['m01'] / M['m00'])
        #print(x, y)

        # 显示
        image = frame.copy()
        # 标出中心位置
        cv2.line(image, (x, 0), (x, 720), (0, 0, 255), 1)
        cv2.line(image, (0, y), (1280, y), (0, 0, 255), 1)
        # 画出轮廓
        cv2.drawContours(image, contours, -1, (128, 0, 128), 2)
        cv2.imshow("image", image)

    else:
        print("not found the line")

        (x,y) = (0, 0)</code></pre> 
<p></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81PID">二、PID</h2> 
<pre><code class="language-python">def Pid():
    global turn_speed, x, y, speed
    global error, last_error, pre_error, out_pid

    error = abs(x - width / 2)

    out_pid = int(proportion * error - integral * last_error + derivative * pre_error)
    turn_speed = out_pid

    # 保存本次误差，以便下一次运算
    pre_error = last_error
    last_error = error

    # 限值
    if (turn_speed &lt; 30):
        turn_speed = 30
    elif (turn_speed &gt; 100):
        turn_speed = 100
    if (speed &lt; 0):
        speed = 0
    elif (speed &gt; 100):
        speed = 100

    print(error, out_pid, turn_speed, (x, y))</code></pre> 
<p></p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6">三、运动控制</h2> 
<pre><code class="language-python"># 巡线
def Follow_Line():
    global turn_speed, x, y,speed, back_speed
        
    '''if(x &lt; width / 2 and y&gt;2*height/3):
        Left(turn_speed)
    elif(x&gt;3*width/2 and y&gt;2*height/3):
        Right(turn_speed)'''
    if(0&lt;x&lt;width/4):
        Left(turn_speed)
        print("turn left")
    elif(3*width/4&lt;x&lt;width):
        Right(turn_speed)
        print("turn right")
    #直角拐弯
    elif(y&gt;3*height/4):
        if(x&lt;width/2):
            Left(turn_speed*2)
            print("turn left")
        elif(x&gt;=width/2):
            Right(turn_speed*2)
            print("turn right")
    elif(x&gt;=width/4 and x&lt;=3*width/4):
        Forward(speed)
    
    elif(x==0 and y==0):
        Back(back_speed)</code></pre> 
<p></p> 
<p></p> 
<h2 id="%E6%80%BB%E4%BB%A3%E7%A0%81">总代码</h2> 
<pre><code class="language-python">#!/usr/bin/env python2
# -*- coding: utf-8 -*-

import numpy as np
import cv2
import Adafruit_PCA9685
import RPi.GPIO as GPIO
import time

l_motor = 18
left_Forward = 22
left_back = 27

r_motor = 23
right_Forward = 25
right_back = 24

pwm_servo = Adafruit_PCA9685.PCA9685()

width, height = 160, 120
camera = cv2.VideoCapture(0)
camera.set(3, width)
camera.set(4, height)

# pid
error = 0  # 当前误差e[k]
last_error = 0  # 上一次误差e[k-1]
pre_error = 0  # 上上次误差e[k-2]
proportion = 1  # 比例系数3 0.2
integral = 0.5  # 积分系数1.2
derivative = 0  # 微分系数1.2

stop_flag = 1
control_flag = 1
turn_speed = 30
speed = 30
back_speed = 30


def Motor_Init():
    global L_Motor, R_Motor
    L_Motor = GPIO.PWM(l_motor, 100)
    R_Motor = GPIO.PWM(r_motor, 100)
    L_Motor.start(0)
    R_Motor.start(0)


def Direction_Init():
    GPIO.setup(left_back, GPIO.OUT)
    GPIO.setup(left_Forward, GPIO.OUT)
    GPIO.setup(l_motor, GPIO.OUT)

    GPIO.setup(right_Forward, GPIO.OUT)
    GPIO.setup(right_back, GPIO.OUT)
    GPIO.setup(r_motor, GPIO.OUT)


def set_servo_angle(channel, angle):
    angle = 4096 * ((angle * 11) + 500) / 20000
    pwm_servo.set_pwm_freq(50)  # frequency==50Hz (servo)
    pwm_servo.set_pwm(channel, 0, int(angle))


def TrackBar_Init():
    # 1 create windows
    cv2.namedWindow('h_binary')
    cv2.namedWindow('s_binary')
    cv2.namedWindow('l_binary')
    # 2 Create Trackbar
    cv2.createTrackbar('hmin', 'h_binary', 0, 179, call_back)
    cv2.createTrackbar('hmax', 'h_binary', 110, 179, call_back)
    cv2.createTrackbar('smin', 's_binary', 0, 255, call_back)
    cv2.createTrackbar('smax', 's_binary', 51, 255, call_back)  # 51
    cv2.createTrackbar('lmin', 'l_binary', 0, 255, call_back)
    cv2.createTrackbar('lmax', 'l_binary', 255, 255, call_back)
    '''cv2.namedWindow('binary')
    cv2.createTrackbar('thresh', 'binary', 154, 255, call_back)  '''
    #   创建滑动条     滑动条值名称 窗口名称   滑动条值 滑动条阈值 回调函数


def Init():
    GPIO.setwarnings(False)
    GPIO.setmode(GPIO.BCM)
    Direction_Init()
    Motor_Init()
    TrackBar_Init()


def Forward(turn_speed):
    L_Motor.ChangeDutyCycle(turn_speed)
    GPIO.output(left_Forward, 1)  # left_Forward
    GPIO.output(left_back, 0)  # left_back

    R_Motor.ChangeDutyCycle(turn_speed)
    GPIO.output(right_Forward, 1)  # right_Forward
    GPIO.output(right_back, 0)  # right_back


def Back(turn_speed):
    L_Motor.ChangeDutyCycle(turn_speed)
    GPIO.output(left_Forward, 0)  # left_Forward
    GPIO.output(left_back, 1)  # left_back

    R_Motor.ChangeDutyCycle(turn_speed)
    GPIO.output(right_Forward, 0)  # right_Forward
    GPIO.output(right_back, 1)  # right_back


def Left(turn_speed):
    L_Motor.ChangeDutyCycle(turn_speed)
    GPIO.output(left_Forward, 0)  # left_Forward
    GPIO.output(left_back, 1)  # left_back

    R_Motor.ChangeDutyCycle(turn_speed)
    GPIO.output(right_Forward, 1)  # right_Forward
    GPIO.output(right_back, 0)  # right_back


def Right(turn_speed):
    L_Motor.ChangeDutyCycle(turn_speed)
    GPIO.output(left_Forward, 1)  # left_Forward
    GPIO.output(left_back, 0)  # left_back

    R_Motor.ChangeDutyCycle(turn_speed)
    GPIO.output(right_Forward, 0)  # right_Forward
    GPIO.output(right_back, 1)  # right_back


def Stop():
    L_Motor.ChangeDutyCycle(0)
    GPIO.output(left_Forward, 0)  # left_Forward
    GPIO.output(left_back, 0)  # left_back

    R_Motor.ChangeDutyCycle(0)
    GPIO.output(right_Forward, 0)  # right_Forward
    GPIO.output(right_back, 0)  # right_back


# 回调函数
def call_back(*arg):
    pass


# 在HSV色彩空间下得到二值图
def Get_HSV(image):
    # 1 get trackbar's value
    hmin = cv2.getTrackbarPos('hmin', 'h_binary')
    hmax = cv2.getTrackbarPos('hmax', 'h_binary')
    smin = cv2.getTrackbarPos('smin', 's_binary')
    smax = cv2.getTrackbarPos('smax', 's_binary')
    lmin = cv2.getTrackbarPos('lmin', 'l_binary')
    lmax = cv2.getTrackbarPos('lmax', 'l_binary')

    # 2 to HSV
    hls = cv2.cvtColor(image, cv2.COLOR_BGR2HLS)
    cv2.imshow('hls', hls)
    h, l, s = cv2.split(hls)

    # 3 set threshold (binary image)
    # if value in (min, max):white; otherwise:black
    h_binary = cv2.inRange(np.array(h), np.array(hmin), np.array(hmax))
    s_binary = cv2.inRange(np.array(s), np.array(smin), np.array(smax))
    l_binary = cv2.inRange(np.array(l), np.array(lmin), np.array(lmax))

    # 4 get binary（对H、S、V三个通道分别与操作）
    binary = 255 - cv2.bitwise_and(h_binary, cv2.bitwise_and(s_binary, l_binary))

    # 5 Show
    cv2.imshow('h_binary', h_binary)
    cv2.imshow('s_binary', s_binary)
    cv2.imshow('l_binary', l_binary)
    cv2.imshow('binary', binary)

    return binary


# 手动控制小车（上下左右，案件事件判断）
# 控制方式：w、s、a、d分别表示：上、下、左、右
def Key_Control(keyboard):
    global stop_flag, control_flag
    if keyboard == ord("w"):
        Forward(50)
        time.sleep(0.1)
        Stop()
    elif keyboard == ord("s"):
        Back(50)
        time.sleep(0.1)
        Stop()
    elif keyboard == ord("a"):
        Left(50)
        time.sleep(0.1)
        Stop()
    elif keyboard == ord("d"):
        Right(50)
        time.sleep(0.1)
        Stop()


# 图像处理
def Image_Processing():
    global frame, binary
    # Capture the frames
    ret, frame = camera.read()

    # to binary
    binary = Get_HSV(frame)

    blur = cv2.GaussianBlur(binary, (5, 5), 0)
    cv2.imshow('blur', blur)

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (35, 35))
    Open = cv2.morphologyEx(blur, cv2.MORPH_OPEN, kernel)
    cv2.imshow('Open', Open)

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 25))
    Erode = cv2.morphologyEx(Open, cv2.MORPH_ERODE, kernel)
    cv2.imshow('Erode', Erode)

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 25))
    Dilate = cv2.morphologyEx(Erode, cv2.MORPH_DILATE, kernel)
    cv2.imshow('Dilate', Dilate)

    binary = Erode  # Dilate


# 找线
def Find_Line():
    global x, y, image
    # 1 找出所有轮廓
    bin2, contours, hierarchy = cv2.findContours(binary, 1, cv2.CHAIN_APPROX_NONE)

    # 2 找出最大轮廓
    if len(contours) &gt; 0:
        # 最大轮廓
        c = max(contours, key=cv2.contourArea)
        M = cv2.moments(c)

        # 中心点坐标
        x = int(M['m10'] / M['m00'])
        y = int(M['m01'] / M['m00'])
        # print(x, y)

        # 显示
        image = frame.copy()
        # 标出中心位置
        cv2.line(image, (x, 0), (x, 720), (0, 0, 255), 1)
        cv2.line(image, (0, y), (1280, y), (0, 0, 255), 1)
        # 画出轮廓
        cv2.drawContours(image, contours, -1, (128, 0, 128), 2)
        cv2.imshow("image", image)

    else:
        print("not found the line")

        (x, y) = (0, 0)


def Pid():
    global turn_speed, x, y, speed
    global error, last_error, pre_error, out_pid

    error = abs(x - width / 2)

    out_pid = int(proportion * error - integral * last_error + derivative * pre_error)
    turn_speed = out_pid

    # 保存本次误差，以便下一次运算
    pre_error = last_error
    last_error = error

    # 限值
    if (turn_speed &lt; 30):
        turn_speed = 30
    elif (turn_speed &gt; 100):
        turn_speed = 100
    if (speed &lt; 0):
        speed = 0
    elif (speed &gt; 100):
        speed = 100

    print(error, out_pid, turn_speed, (x, y))


# 巡线
def Follow_Line():
    global turn_speed, x, y, speed, back_speed

    '''if(x &lt; width / 2 and y&gt;2*height/3):
        Left(turn_speed)
    elif(x&gt;3*width/2 and y&gt;2*height/3):
        Right(turn_speed)'''
    if (0 &lt; x &lt; width / 4):
        Left(turn_speed)
        print("turn left")
    elif (3 * width / 4 &lt; x &lt; width):
        Right(turn_speed)
        print("turn right")
    # 直角拐弯
    elif (y &gt; 3 * height / 4):
        if (x &lt; width / 2):
            Left(turn_speed * 2)
            print("turn left")
        elif (x &gt;= width / 2):
            Right(turn_speed * 2)
            print("turn right")
    elif (x &gt;= width / 4 and x &lt;= 3 * width / 4):
        Forward(speed)

    elif (x == 0 and y == 0):
        Back(back_speed)


def Control():
    global control_flag, speed, proportion, integral
    keyboard = cv2.waitKey(1)
    # 加速减速
    if (keyboard == ord('k')):
        speed += 5
    elif (keyboard == ord('l')):
        speed -= 5
    print(speed)

    if keyboard == ord("n"):
        integral += 0.01
    elif keyboard == ord("m"):
        integral -= 0.01
    print(integral)

    if (control_flag == -1):
        Follow_Line()
        if keyboard == 32:
            control_flag *= -1
            Stop()

    else:
        Key_Control(keyboard)
        if keyboard == 32:
            control_flag *= -1
            Stop()

    print(control_flag)


if __name__ == '__main__':
    Init()
    set_servo_angle(4, 140)  # top servo     lengthwise
    # 0:back    180:front
    set_servo_angle(5, 90)  # bottom servo  crosswise
    # 0:left    180:right

    while True:
        Image_Processing()
        Find_Line()
        Pid()
        Control()
        if cv2.waitKey(1) == ord('q'):
            cv2.destroyAllWindows()
            break


</code></pre> 
<p> 其实一开始主要是想玩机器视觉，小车的运动控制研究的不算精细，PID研究的也不深（甚至可能有误）。</p> 
<p>有很多是自己的想法，有错误欢迎指正，有建议也欢迎交流，谢谢。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b65001f36a576e7ce78ce9471e1564e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2021 Oral CVPR : Exploring Simple Siamese Representation Learning</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f51e329481175b4254783e49a53f4ef5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python基础——字典</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>