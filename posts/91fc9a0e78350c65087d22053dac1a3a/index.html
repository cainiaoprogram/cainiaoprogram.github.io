<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux系统中socket错误码：EINTR和EAGAIN的处理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux系统中socket错误码：EINTR和EAGAIN的处理" />
<meta property="og:description" content="目录
人为重启被中断的系统调用
安装信号时设置 SA_RESTART属性
忽略信号
永远阻塞的系统调用，被信号中断，导致其不继续等待，转而去执行signal_handler
1、什么是慢系统调用？ 该术语适用于那些可能永远阻塞的系统调用。永远阻塞的系统调用是指调用永远无法返回，多数网络支持函数都属于这一类。如：若没有客户连接到服务器上，那么服务器的accept调用就会永远阻塞。
慢系统调用可以被永久阻塞，包括以下几个类别：
（1）读写‘慢’设备（包括pipe，终端设备，网络连接等）。读时，数据不存在，需要等待；写时，缓冲区满或其他原因，需要等待。
（2）当打开某些特殊文件时，需要等待某些条件，才能打开。例如：打开中断设备时，需要等到连接设备的modem响应才能完成。
（3）pause和wait函数。pause函数使调用进程睡眠，直到捕获到一个信号。wait等待子进程终止。
（4）某些ioctl操作。
（5）某些IPC操作。
2、EINTR错误产生的原因-（阻塞的系统调用、或者非阻塞的系统调用） 如果进程在一个慢系统调用(slow system call)中阻塞时，当捕获到某个信号且相应信号处理函数返回时，这个系统调用不再阻塞而是被中断，就会调用返回错误（一般为-1）&amp;&amp;设置errno为EINTR（相应的错误描述为“Interrupted system call”）。
如下表所示的系统调用就会产生EINTR错误，当然不同的函数意义也不同。
系统调用函数errno为EINTR表征的意义write由于信号中断，没写成功任何数据。The call was interrupted by a signal before any data was written.open由于信号中断，没读到任何数据。The call was interrupted by a signal before any data was read.recv sem_wait函数调用被信号处理函数中断。The call was interrupted by a signal handler. 3、解决办法 既然系统调用会被中断，那么别忘了要处理被中断的系统调用。有三种处理方式：
解决方法1：重启被中断的系统调用 当碰到EINTR错误的时候，有一些可以重启的系统调用要进行重启，而对于有一些系统调用是不能够重启的。例如：accept、read、write、select、和open之类的函数来说，是可以进行重启的。不过对于套接字编程中的connect函数是不能重启的，若connect函数返回一个EINTR错误的时候，我们不能再次调用它，否则将立即返回一个错误。针对connect不能重启的处理方法是，必须调用select来等待连接完成。
理解“重启”？一些IO系统调用执行时，如 read 等待输入期间，如果收到一个信号，系统将中断read， 转而执行信号处理函数. 当信号处理返回后， 系统遇到了一个问题： 是重新开始这个系统调用? 还是让系统调用失败?早期UNIX系统的做法是：中断系统调用，并让系统调用失败， 比如read返回 -1， 同时设置 errno 为EINTR中断了的系统调用是没有完成的调用，它的失败是临时性的，如果再次调用则可能成功，这并不是真正的失败，所以要对这种情况进行处理， 典型的方式为“重启”，采用accept函数为例子，代码如下" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/91fc9a0e78350c65087d22053dac1a3a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-03T14:15:40+08:00" />
<meta property="article:modified_time" content="2019-07-03T14:15:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux系统中socket错误码：EINTR和EAGAIN的处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BA%BA%E4%B8%BA%E9%87%8D%E5%90%AF%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-toc" style="margin-left:80px;"><a href="#%E4%BA%BA%E4%B8%BA%E9%87%8D%E5%90%AF%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" rel="nofollow">人为重启被中断的系统调用</a></p> 
<p id="%E5%AE%89%E8%A3%85%E4%BF%A1%E5%8F%B7%E6%97%B6%E8%AE%BE%E7%BD%AE%20SA_RESTART%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#%E5%AE%89%E8%A3%85%E4%BF%A1%E5%8F%B7%E6%97%B6%E8%AE%BE%E7%BD%AE%20SA_RESTART%E5%B1%9E%E6%80%A7" rel="nofollow">安装信号时设置 SA_RESTART属性</a></p> 
<p id="%E5%BF%BD%E7%95%A5%E4%BF%A1%E5%8F%B7-toc" style="margin-left:80px;"><a href="#%E5%BF%BD%E7%95%A5%E4%BF%A1%E5%8F%B7" rel="nofollow">忽略信号</a></p> 
<hr id="hr-toc"> 
<p style="margin-left:0px;"><span style="color:#555555;">永远阻塞的系统调用，被信号中断，导致其不继续等待，转而去执行signal_handler</span></p> 
<h2 style="margin-left:0px;"><span style="color:#555555;">1、什么是慢系统调用？</span></h2> 
<p style="margin-left:0px;"><span style="color:#555555;">该术语适用于那些可能<code>永远阻塞</code>的系统调用。永远阻塞的系统调用是指调用永远无法返回，多数网络支持函数都属于这一类。如：若没有客户连接到服务器上，那么服务器的accept调用就会永远阻塞。</span></p> 
<p style="margin-left:0px;"><span style="color:#555555;">慢系统调用可以被永久阻塞，包括以下几个类别：</span><br><span style="color:#f33b45;">（1）读写‘慢’设备（包括pipe，终端设备，网络连接等）。</span><span style="color:#3399ea;">读时，数据不存在，需要等待</span><span style="color:#f33b45;">；</span><span style="color:#3399ea;">写时，缓冲区满或其他原因，需要等待</span><span style="color:#f33b45;">。<br> （2）当打开某些特殊文件时，需要等待某些条件，才能打开。例如：打开中断设备时，需要等到连接设备的modem响应才能完成。<br> （3）pause和wait函数。pause函数使调用进程睡眠，直到捕获到一个信号。wait等待子进程终止。<br> （4）某些ioctl操作。<br> （5）某些IPC操作。</span></p> 
<h2 style="margin-left:0px;"><span style="color:#555555;">2、EINTR错误产生的原因-（阻塞的系统调用、或者非阻塞的系统调用）</span></h2> 
<p style="margin-left:0px;"><span style="color:#555555;">如果进程在一个慢系统调用(slow system call)中阻塞时，当捕获到某个信号且相应信号处理函数返回时，这个</span><span style="color:#f33b45;">系统调用不再阻塞而是被中断</span><span style="color:#555555;">，就会调用返回错误（一般为-1）&amp;&amp;设置errno为EINTR（相应的错误描述为“Interrupted system call”）。</span></p> 
<p style="margin-left:0px;"><span style="color:#555555;">如下表所示的系统调用就会产生EINTR错误，当然不同的函数意义也不同。</span></p> 
<table border="1" cellspacing="0"><thead><tr><th style="text-align:center;">系统调用函数</th><th style="text-align:center;">errno为EINTR表征的意义</th></tr></thead><tbody><tr><td>write</td><td>由于信号中断，没写成功任何数据。The call was interrupted by a signal before any data was written.</td></tr><tr><td>open</td><td>由于信号中断，没读到任何数据。The call was interrupted by a signal before any data was read.</td></tr><tr><td>recv</td><td> </td></tr><tr><td>sem_wait</td><td>函数调用被信号处理函数中断。The call was interrupted by a signal handler.</td></tr></tbody></table> 
<h2 style="margin-left:0px;"><span style="color:#555555;">3、解决办法</span></h2> 
<p style="margin-left:0px;"><span style="color:#555555;">既然系统调用会被中断，那么别忘了要处理被中断的系统调用。有三种处理方式：</span></p> 
<h3 style="margin-left:0px;"><span style="color:#555555;"><strong>解决方法1：<code>重启</code>被中断的系统调用</strong></span></h3> 
<p style="margin-left:0px;"><span style="color:#555555;">当碰到EINTR错误的时候，有一些可以重启的系统调用要进行重启，而对于有一些系统调用是不能够重启的。例如：<span style="color:#FF0000;">accept、read、write、select、和open</span>之类的函数来说，是可以进行重启的。不过对于套接字编程中的<span style="color:#FF0000;">connect</span>函数是不能重启的，若connect函数返回一个EINTR错误的时候，我们不能再次调用它，否则将立即返回一个错误。针对connect不能重启的处理方法是，必须调用select来等待连接完成。</span></p> 
<p style="margin-left:0px;"><span style="color:#555555;"><span style="color:#0000FF;"><strong>理解“重启”？</strong></span>一些IO系统调用执行时，如 read 等待输入期间，如果收到一个信号，系统将中断read， 转而执行信号处理函数. 当信号处理返回后， 系统遇到了一个问题： 是重新开始这个系统调用? 还是让系统调用失败?早期UNIX系统的做法是：中断系统调用，并让系统调用失败， 比如read返回 -1， 同时设置 errno 为EINTR中断了的系统调用是没有完成的调用，它的失败是临时性的，如果再次调用则可能成功，这并不是真正的失败，所以要对这种情况进行处理， 典型的方式为“重启”，采用accept函数为例子，代码如下</span></p> 
<pre class="has"><code class="hljs language-cpp">ACCEPT:
    clifd = accept(srvfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);
 
    if (clifd == -1) {
        if (errno == EINTR) {
            goto ACCEPT;
        } else {
            fprintf(stderr, "accept fail,error:%s\n", strerror(errno));
            return -1;
        }
    }</code></pre> 
<h3><strong>解决方法2：安装信号时设置 SA_RESTART属性（该方法对有的系统调用无效）</strong></h3> 
<pre class="has"><code class="hljs language-cpp">struct sigaction action;  
     
  action.sa_handler = handler_func;  
  sigemptyset(&amp;action.sa_mask);  
  action.sa_flags = 0;  
  /* 设置SA_RESTART属性 */  
  action.sa_flags |= SA_RESTART;  
     
  sigaction(SIGALRM, &amp;action, NULL); </code></pre> 
<h3><strong>解决方法3： 忽略信号（让系统不产生信号中断）</strong></h3> 
<pre class="has"><code class="hljs language-cpp">struct sigaction action;  
     
  action.sa_handler = SIG_IGN;  
  sigemptyset(&amp;action.sa_mask);  
     
  sigaction(SIGALRM, &amp;action, NULL); </code></pre> 
<h2 style="margin-left:0px;"><span style="color:#333333;">EAGAIN-（一般用于</span><span style="color:#555555;">非阻塞的系统调用</span><span style="color:#333333;">）</span></h2> 
<p style="margin-left:0px;"><span style="color:#555555;">非阻塞的系统调用，由于资源限制/不满足条件，导致返回值为EAGAIN</span></p> 
<p style="margin-left:0px;"><span style="color:#555555;">在Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。</span></p> 
<p style="margin-left:0px;"><span style="color:#555555;">如：首先是把套接字设置为异步的了，然后在使用write发送数据时采取的方式是循环发送大量的数据；由于是异步的，write\send将要发送的数据提交到发送缓冲区后是立即返回的，并不需要对端确认数据已接收。在这种情况下是很有可能出现<code>发送缓冲区被填满</code>，导致write\send无法再向缓冲区提交要发送的数据。<span style="color:#0000FF;">因此就产生了Resource temporarily unavailable的错误（资源暂时不可用），EAGAIN 的意思也很明显，就是要你再次尝试。</span></span></p> 
<p style="margin-left:0px;"><span style="color:#555555;"><span style="color:#0000FF;">从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</span></span></p> 
<p style="margin-left:0px;"><span style="color:#555555;">如：以 O_NONBLOCK的标志打开文件/socket/FIFO，如果连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br> 又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</span></p> 
<h3 style="margin-left:0px;"><span style="color:#555555;">Linux - 非阻塞socket编程处理EAGAIN错误</span></h3> 
<p style="margin-left:0px;"><span style="color:#555555;"><span style="color:#0000FF;">在linux进行非阻塞的socket接收数据时经常出现Resource temporarily unavailable，errno代码为11(EAGAIN)，这是什么意思？</span> ⇒ ⇒ ⇒ 这表明在</span><strong><span style="color:#f33b45;">非阻塞模式下调用了阻塞操作</span></strong><span style="color:#555555;">，在该操作没有完成就返回这个错误，<span style="color:#FF0000;">这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以</span>。对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。</span></p> 
<pre class="has"><code class="hljs language-cpp">iReadSizeOnce=read(iOpenCom,RxBuf+iReadSize,1024);
if (iReadSizeOnce != ZERO)
{
    if (iReadSizeOnce != EAGAIN)
    {
        continue;
    }
    else
    {
        //stCComApiLog.LogError("读串口操作错误");
        return(FUN_ERROR);
    }
}</code></pre> 
<p>借鉴于：</p> 
<p>1  http://blog.csdn.net/yanook/article/details/7226019  <a href="http://blog.csdn.net/yanook/article/details/7226019">慢系统调用函数如何处理中断信号EINTR</a><br> 2  http://blog.csdn.net/benkaoya/article/details/17262053 <a href="http://blog.csdn.net/benkaoya/article/details/17262053">信号中断 与 慢系统调用</a><br> 3  http://1.guotie.sinaapp.com/?p=235    socket,accept,connect出现EINTR错误的解决方法</p> 
<p>慢系统调用：可能永远阻塞的系统调用，这很关键，不适用于非诸塞的情况。永远阻塞的系统调用是指调用永远无法返回，多数网络支持函数都属于这一类。如：若没有客户连接到服务器上，那么服务器的accept调用就会一直阻塞。<br> (以下为抄袭2原文)<br> EINTR说明：如果进程在一个慢系统调用(slow system call)中阻塞时，当捕获到某个信号且相应信号处理函数返回时，这个系统调用被中断，调用返回错误，设置errno为EINTR（相应的错误描述为“Interrupted system call”）。</p> 
<p>怎么看哪些系统条用会产生EINTR错误呢？man 7 signal，在ubuntu 10.04上可以查看，哪些系统调用会产生 EINTR错误。<br><br> 如何处理被中断的系统调用</p> 
<p>既然系统调用会被中断，那么别忘了要处理被中断的系统调用。有三种处理方式：</p> 
<p>◆ 人为重启被中断的系统调用</p> 
<p>◆ 安装信号时设置 SA_RESTART属性（该方法对有的系统调用无效）</p> 
<p>◆  忽略信号（让系统不产生信号中断）</p> 
<h2 id="%E4%BA%BA%E4%B8%BA%E9%87%8D%E5%90%AF%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><a name="t0"></a>人为重启被中断的系统调用</h2> 
<p>人为当碰到EINTR错误的时候，有一些可以重启的系统调用要进行重启，而对于有一些系统调用是不能够重启的。例如：accept、read、write、select、和open之类的函数来说，是可以进行重启的。不过对于套接字编程中的connect函数我们是不能重启的，若connect函数返回一个EINTR错误的时候，我们不能再次调用它，否则将立即返回一个错误。针对connect不能重启的处理方法是，必须调用select来等待连接完成。</p> 
<p>这里的“重启”怎么理解？</p> 
<p>一些IO系统调用执行时，如 read 等待输入期间，如果收到一个信号，系统将中断read， 转而执行信号处理函数. 当信号处理返回后， 系统遇到了一个问题： 是重新开始这个系统调用， 还是让系统调用失败？早期UNIX系统的做法是， 中断系统调用，并让系统调用失败， 比如read返回 -1， 同时设置 errno 为EINTR中断了的系统调用是没有完成的调用，它的失败是临时性的，如果再次调用则可能成功，这并不是真正的失败，所以要对这种情况进行处理， 典型的方式为：</p> 
<p> </p> 
<p>connect处理方式，抄袭3原文，没有测试过，处理方法是对的。<br> connect的问题，当connect遇到EINTR错误时，不能向上面那样重新进入循环处理，原因是，connect的请求已经发送向对方，正在等待对方回应，这是如果重新调用connect，而对方已经接受了上次的connect请求，这一次的connect就会被拒绝，因此，需要使用select或poll调用来检查socket的状态，如果socket的状态就绪，则connect已经成功，否则，视错误原因，做对应的处理。<img alt="" class="has" height="582" src="https://images2.imgbox.com/b8/f5/V8f3kRox_o.png" width="997"></p> 
<p>connect处理方式，抄袭3原文，没有测试过，处理方法是对的。<br> connect的问题，当connect遇到EINTR错误时，不能向上面那样重新进入循环处理，原因是，connect的请求已经发送向对方，正在等待对方回应，这是如果重新调用connect，而对方已经接受了上次的connect请求，这一次的connect就会被拒绝，因此，需要使用select或poll调用来检查socket的状态，如果socket的状态就绪，则connect已经成功，否则，视错误原因，做对应的处理。</p> 
<pre class="has"><code class="language-cpp">#include poll.h

int check_conn_is_ok(socket_t sock) {
	struct pollfd fd;
	int ret = 0;
	socklen_t len = 0;

	fd.fd = sock;
	fd.events = POLLOUT;

	while ( poll (&amp;fd, 1, -1) == -1 ) {
		if( errno != EINTR ){
			perror("poll");
			return -1;
		}
	}

	len = sizeof(ret);
	if ( getsockopt (sock, SOL_SOCKET, SO_ERROR,
                     &amp;ret,
                     &amp;len) == -1 ) {
    	        perror("getsockopt");
		return -1;
	}

	if(ret != 0) {
		fprintf (stderr, "socket %d connect failed: %s\n",
                 sock, strerror (ret));
		return -1;
	}

	return 0;
}</code></pre> 
<p>在调用connect时，这样使用：</p> 
<pre class="has"><code class="language-cpp">#include erron.h

....
if(connnect()) {
    if(errno == EINTR) {
        if(check_conn_is_ok() &lt; 0) {
              perror();
              return -1;
        }
        else {
             printf("connect is success!\n");
        }
    }
    else {
         perror("connect");
         return -1;
    }
}</code></pre> 
<p>我一般使用continue或者goto来处理。</p> 
<h2 id="%E5%AE%89%E8%A3%85%E4%BF%A1%E5%8F%B7%E6%97%B6%E8%AE%BE%E7%BD%AE%20SA_RESTART%E5%B1%9E%E6%80%A7"><a name="t1"></a>安装信号时设置 SA_RESTART属性</h2> 
<p>我们还可以从信号的角度来解决这个问题，  安装信号的时候， 设置 SA_RESTART属性，那么当信号处理函数返回后， 不会让系统调用返回失败，而是让被该信号中断的系统调用将自动恢复。</p> 
<pre class="has"><code class="language-cpp">struct sigaction action;  
   
action.sa_handler = handler_func;  
sigemptyset(&amp;action.sa_mask);  
action.sa_flags = 0;  
/* 设置SA_RESTART属性 */  
action.sa_flags |= SA_RESTART;  
   
sigaction(SIGALRM, &amp;action, NULL);  </code></pre> 
<p>但注意，并不是所有的系统调用都可以自动恢复。如msgsnd喝msgrcv就是典型的例子，msgsnd/msgrcv以block方式发送/接收消息时，会因为进程收到了信号而中断。此时msgsnd/msgrcv将返回-1，errno被设置为EINTR。且即使在插入信号时设置了SA_RESTART，也无效。在man msgrcv中就有提到这点：</p> 
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;"> <p>msgsnd and msgrcv are never automatically restarted after being interrupted by a signal handler, regardless of the setting  of the SA_RESTART flag when establishing a signal  handler.</p> </td></tr></tbody></table> 
<p> </p> 
<h2 id="%E5%BF%BD%E7%95%A5%E4%BF%A1%E5%8F%B7"><a name="t2"></a>忽略信号</h2> 
<p>当然最简单的方法是忽略信号，在安装信号时，明确告诉系统不会产生该信号的中断。</p> 
<pre class="has"><code class="language-cpp">struct sigaction action;  
   
action.sa_handler = SIG_IGN;  
sigemptyset(&amp;action.sa_mask);  
   
sigaction(SIGALRM, &amp;action, NULL);  </code></pre> 
<pre class="has"><code class="language-cpp">#include   
#include   
#include   
#include   
#include   
#include   
   
void sig_handler(int signum)  
{  
    printf("in handler\n");  
    sleep(1);  
    printf("handler return\n");  
}  
   
int main(int argc, char **argv)  
{  
    char buf[100];  
    int ret;  
    struct sigaction action, old_action;  
   
    action.sa_handler = sig_handler;  
    sigemptyset(&amp;action.sa_mask);  
    action.sa_flags = 0;  
    /* 版本1:不设置SA_RESTART属性 
     * 版本2:设置SA_RESTART属性 */  
    //action.sa_flags |= SA_RESTART;  
   
    sigaction(SIGALRM, NULL, &amp;old_action);  
    if (old_action.sa_handler != SIG_IGN) {  
        sigaction(SIGALRM, &amp;action, NULL);  
    }  
    alarm(3);  
     
    bzero(buf, 100);  
   
    ret = read(0, buf, 100);  
    if (ret == -1) {  
        perror("read");  
    }  
   
    printf("read %d bytes:\n", ret);  
    printf("%s\n", buf);  
   
    return 0;  
}  </code></pre> 
<p>在ubuntu 10.04 上测试结果：<br> 不设置SA_RESTART，执行结果如下：<br><img alt="" class="has" height="74" src="https://images2.imgbox.com/50/d8/bLiNbQbO_o.jpg" width="293"></p> 
<p> </p> 
<p>说明接受信号处理完成以后，主函数收到EINTR信号，read函数返回-1，退出<br> 设置SA_RESTART，执行结果如下：<br><img alt="" class="has" height="36" src="https://images2.imgbox.com/da/1d/OxBFAYCt_o.jpg" width="228"><br> 说明设置SA_RESTART参数以后，自动重新调用read函数，没有体现在应用层代码中，在应用层看来，这个EINTR没有造成任何影响。<br><br> 个人认为下面的总结很重要：</p> 
<p>慢系统调用(slow system call)会被信号中断，系统调用函数返回失败，并且errno被置为EINTR（错误描述为“Interrupted system call”）。</p> 
<p>处理方法有以下三种：①人为重启被中断的系统调用；②安装信号时设置 SA_RESTART属性；③忽略信号（让系统不产生信号中断）。</p> 
<p>有时我们需要捕获信号，但又考虑到第②种方法的局限性（设置 SA_RESTART属性对有的系统无效，如msgrcv），所以在编写代码时，一定要“人为重启被中断的系统调用”。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/002181f10156c6277d763953d544b5a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL Server 数据库文件路径迁移步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e52a190bed8e4aeefdf9e1d07399d78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js继承优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>