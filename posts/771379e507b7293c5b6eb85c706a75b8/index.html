<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【笔记】CMake构建C&#43;&#43;工程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【笔记】CMake构建C&#43;&#43;工程" />
<meta property="og:description" content="一句话结论：本文归纳CMake构建c&#43;&#43;工程的基本用法，实现多依赖、多工程、多文件格式的工程编译构建。
1.简介 CMake(cross-platform make)是一个跨平台编译工具，它不能直接生成最终可执行程序，而是构建各平台标准的构建文档（如Linux的Makefile、Windows的sln）。
使用时，用户不再需要直接编写底层Makefile文件，而是编写语法简单的CMakeLists.txt文件，CMake在执行目录下查找CMakeLists.txt来生成Makefile、构建工程，大幅降低工程构建和编译的难度。
2.简单工程 - output - build - tests - test0 - main.cc - CMakeLists.txt cmake_minimum_required(VERSION 3.10) # set c&#43;&#43;11 set(CMAKE_CXX_FLAGS &#34;$GUN_FLAGS -std=c&#43;&#43;11&#34;) # set output dir set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../output) # based on current CMakeLists.txt set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../output) # .exe set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../output) # .a # build test0 aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/test0 SRC_TEST0) # collect all cxx files in $test0 add_executabel(test0 ${SRC_TEST0}) 在项目构建和编译过程中会生成大量中间文件，为保持源代码目录纯净，一般在其他目录新建一个build目
mkdir build cd build cmake ../tests/ make 3.生成并使用链接库 目的：在A工程下，生成动态链接库，在B工程下调用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/771379e507b7293c5b6eb85c706a75b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-06T21:31:02+08:00" />
<meta property="article:modified_time" content="2023-02-06T21:31:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【笔记】CMake构建C&#43;&#43;工程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>一句话结论：本文归纳CMake构建c++工程的基本用法，实现多依赖、多工程、多文件格式的工程编译构建。</p> 
<hr> 
<h4><a id="1_3"></a>1.简介</h4> 
<p>CMake(cross-platform make)是一个跨平台编译工具，它不能直接生成最终可执行程序，而是构建各平台标准的构建文档（如Linux的Makefile、Windows的sln）。<br> 使用时，用户不再需要直接编写底层Makefile文件，而是编写语法简单的CMakeLists.txt文件，CMake在执行目录下查找CMakeLists.txt来生成Makefile、构建工程，大幅降低工程构建和编译的难度。</p> 
<h4><a id="2_7"></a>2.简单工程</h4> 
<pre><code class="prism language-shell">- output
- build
- tests
	- test0
		- main.cc
	- CMakeLists.txt
</code></pre> 
<pre><code class="prism language-cmake">cmake_minimum_required(VERSION 3.10)

# set c++11 
set(CMAKE_CXX_FLAGS "$GUN_FLAGS -std=c++11")

# set output dir
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../output) # based on current CMakeLists.txt
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../output) # .exe
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../output) # .a

# build test0
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/test0 SRC_TEST0) # collect all cxx files in $test0
add_executabel(test0 ${SRC_TEST0})

</code></pre> 
<p>在项目构建和编译过程中会生成大量中间文件，为保持源代码目录纯净，一般在其他目录新建一个build目</p> 
<pre><code class="prism language-shell"><span class="token function">mkdir</span> build
<span class="token builtin class-name">cd</span> build
cmake <span class="token punctuation">..</span>/tests/ 
<span class="token function">make</span>
</code></pre> 
<h4><a id="3_42"></a>3.生成并使用链接库</h4> 
<p>目的：在A工程下，生成动态链接库，在B工程下调用。<br> 每个带cxx的模块下都需要有CMakeLists.txt来描述当前模块的编译配置。</p> 
<pre><code class="prism language-shell">- output
- build
- root 
	- libs
		- B 
			- B.h
			- B.cc 
			- CMakeLists.txt
    - tests
        - testA
            - main.cc
        - CMakeLists.txt
</code></pre> 
<p>libs/B下的CMakeLists.txt</p> 
<pre><code class="prism language-cmake">file(GLOB_RECURSE SRC_LIBS_B
	${CMAKE_CURRENT_SOURCE_DIR}/B/*.h
	${CMAKE_CURRENT_SOURCE_DIR}/B/*.cc
)
add_library(B SHARED ${SRC_LIBS_B}) # shared-&gt;.so  static-&gt;.a  object-&gt;.o
</code></pre> 
<p>tests下的CMakeLists</p> 
<pre><code class="prism language-cmake">... # "简单工程"中CMakeLists.txt的常规配置
include_libraries({CMAKE_CURRENT_SOURCE_DIR}/../libs/B)

aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/test0 SRC_TEST0) # collect all cxx files in $test0

# link B.so
add_executabel(testA ${SRC_TESTA})
target_link_libraries(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libB.so)

# link B.a
link_libraries(${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libB.a)
add_executable(testA ${SRC_TESTA})

# linke B/*.o
add_executable(testA ${SRC_TESTA} $&lt;TARGET_OBJECTS:B&gt;)
</code></pre> 
<h4><a id="4__89"></a>4. 超多依赖模块库</h4> 
<p>目的：<br> A -&gt; B.so -&gt;C.a-&gt;D.a<br> B.so-&gt;C.a B.so-&gt;D.a<br> C.a-&gt;D.a<br> A-&gt;C.a A-&gt;D.a<br> <img src="https://images2.imgbox.com/84/32/jaJlLWn6_o.png" alt="在这里插入图片描述" width="800" height="200"></p> 
<pre><code class="prism language-shell">- output
- build
- exlibs
	- D 
		- D.h
		- D.cc
		- CMakeLists.txt
- root
	- statics
		- C
			- C.h
			- C.cc
			- CMakeLists.txt   
	- libs
		- B 
			- B.h
			- B.cc 
			- CMakeLists.txt
    - tests
        - testA
            - main.cc
        - CMakeLists.txt
- CMakeLists.txt
</code></pre> 
<p>项目构建时，脚本从外往里调，从里往外构。最终依赖exlibs/D/CMakeLists.txt。</p> 
<pre><code class="prism language-cmake">include_directories(${CMAKE_CURRENT_SOURCE_DIR}/D)
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/D SRC_LIBD)
add_library(D STATIC ${SRC_LIBD}) # 最外层CMakeLists会定义libD的输出目录
</code></pre> 
<p>statics/C/CMakeLists.txt</p> 
<pre><code class="prism language-cmake">include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../../exlibs/D) # include D.header
include_libraries(${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libD.a) # 使用静态链接库

#include_directories(${CMAKE_CURRENT_SOURCE_DIR})
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR} SRC_LIBC)
add_library(C STATIC ${SRC_LIBD}) # 最外层CMakeLists会定义libC.a的输出目录
</code></pre> 
<p>libs/B/CMakeLists.txt</p> 
<pre><code class="prism language-cmake">include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../../exlibs/D) # include D.header
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../statics/C) # include C.header
include_directories(${CMAKE_CURRENT_SOURCE_DIR})
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR} SRC_LIBB)

link_libraries(${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libC.a ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libD.a) # 静态链接库，左边依赖右边

add_library(B SHARED ${SRC_LIBD})
</code></pre> 
<p>tests/CMakeLists.txt</p> 
<pre><code class="prism language-cmake">include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../../extlibs/D)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../statics/C)

# C&amp;D都是静态链接库的形式，这里还需要再次包含一遍
link_libraries(${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libC.a ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libD.a) # 静态链接库，左边依赖右边

file(GLOB_RECURSE SRC_TESTA
	${CMAKE_CURRENT_SOURCE_DIR/testA/*.h}
	${CMAKE_CURRENT_SOURCE_DIR/testA/*.cc}
)
add_executable(testA ${SRC_TESTA})
target_link_libraries(testA PUBLIC ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libB.so) # 使用动态链接库B
</code></pre> 
<p>最外层CMakeLists.txt</p> 
<pre><code class="prism language-cmake">cmake_minium_version(VERSION 3.10)

set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJEC_SOURCE_DIR}/output)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJEC_SOURCE_DIR}/output)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJEC_SOURCE_DIR}/output)

set(CMAKE_CXX_FALGS "${GUN_FLAGS} -std=c++11 -fPIC -Wl,--no-as-needed -ldl -lphread") # 使用c++11标准；-fPIC 动态库中使用静态库；-Wl,--no-as-needed 链接dlsym所需系统库；-lphread使用多线程库phread

add_subdirectory(exlibs/D)
add_subdirectory(root/statics/C)
add_subdirectory(root/libs/B)
add_subdirectory(root/tests)
</code></pre> 
<h4><a id="5II_182"></a>5.超多依赖库II</h4> 
<p>同样的依赖关系，不想把C构建成单独的静态库，而是直接使用C编译成的.o。此时只需要在构建B时将C/*.o链接。<br> 1.修改statics/C/CMakeLists.txt最后一行</p> 
<pre><code class="prism language-cmake"># add_library(staticC STATIC ${SRC_LIBD})
add_library(objC OBJECT ${SRC_LIBD}) # 将C直接编译成.o备用
</code></pre> 
<p>2.修改libs/B/CMakeLists.txt的最后2行</p> 
<pre><code class="prism language-cmake"># link_libraries(${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libC.a ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libD.a) # 静态链接库，左边依赖右边
# add_library(staticC SHARED ${SRC_LIBD})

link_libraries(${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libD.a) # 只链接静态库
add_library(B SHARED 
	${SRC_LIBD}
	$&lt;TARGET_OBJECTS:objC&gt;
) # 直接把C编到libB.so里，后续使用时，只需要链接libB.so就可以用C里的符号
</code></pre> 
<p>3.修改tests/CMakelists.txt，去除对libC.a的依赖</p> 
<pre><code class="prism language-cmake"># # C&amp;D都是静态链接库的形式，这里还需要再次包含一遍
# link_libraries(${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libC.a ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libD.a) # 静态链接库，左边依赖右边

# 去除对libC.a的依赖
link_libraries(${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libD.a}
</code></pre> 
<h4><a id="6_209"></a>6.总结</h4> 
<p>除此之外，还需要指定cmake_cxx_flag编译指令以实现链接系统库等个性化需求；也可以引入xxx.cmake美化cmake的CMakelists文件。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d63707897c4b580be94771c4c9da5d9d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">zerotier内网穿透功能简要介绍及简明设置方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/75aef66913b3ed98cd10507a3b7c19cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Spark平台的协同过滤实时电影推荐系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>