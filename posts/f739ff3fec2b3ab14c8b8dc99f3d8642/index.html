<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 数据结构之队列(Queue)详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 数据结构之队列(Queue)详解" />
<meta property="og:description" content="目录
1、在Java中有哪些常见的队列？
2、Queue 接口分析
3、Deque 接口分析
4、PriorityQueue 的实现原理详解
5、使用Java数组实现队列的简单示例
1、在Java中有哪些常见的队列？ 在Java中，有一些常见的队列实现。下面是其中一些的列举：//队列也是一种线性的数据结构
ArrayList：ArrayList可以被用作队列，通过在列表末尾添加元素，并使用remove(0)方法从列表的开头删除元素。但是，由于在列表的开头删除元素会导致后续元素的移动，因此对于大量的插入和删除操作来说，ArrayList的性能可能不是最佳选择。LinkedList：LinkedList也可以用作队列。LinkedList实现了Queue接口，可以使用offer()方法在队列的末尾添加元素，使用poll()方法从队列的开头删除并返回元素。LinkedList对于插入和删除操作具有较好的性能，因为它使用了指针来链接元素，而不需要移动其他元素。ArrayBlockingQueue：ArrayBlockingQueue是一个有界阻塞队列，底层使用数组实现。它有一个固定的容量，并且在插入或删除元素时可能会阻塞线程，直到满足特定的条件。LinkedBlockingQueue：LinkedBlockingQueue是一个可选有界或无界的阻塞队列，底层使用链表实现。它具有类似于ArrayBlockingQueue的功能，但在内部实现上略有不同。PriorityBlockingQueue：PriorityBlockingQueue是一个支持优先级的无界阻塞队列。元素按照它们的优先级顺序被插入和删除。ConcurrentLinkedQueue：ConcurrentLinkedQueue是一个非阻塞无界队列，它适用于多线程环境。它使用链表实现，并且提供了高效的并发操作。 以上是Java中的一些常见队列实现。具体选择哪种队列取决于你的需求和使用场景。
2、Queue 接口分析 Queue接口是Java集合框架中定义的一个接口，它代表了一个先进先出（FIFO）的队列。Queue接口继承自Collection接口，它定义了一组方法来操作队列中的元素。下面是Queue接口的一些主要方法和特性的详细解释：
（1）添加元素：
boolean add(E element): 将指定的元素添加到队列的末尾，如果成功则返回true，如果队列已满则抛出异常。boolean offer(E element): 将指定的元素添加到队列的末尾，如果成功则返回true，如果队列已满则返回false。 （2）移除元素：
E remove(): 移除并返回队列头部的元素，如果队列为空则抛出异常。E poll(): 移除并返回队列头部的元素，如果队列为空则返回null。 （3）获取头部元素：
E element(): 获取队列头部的元素，但不移除它，如果队列为空则抛出异常。E peek(): 获取队列头部的元素，但不移除它，如果队列为空则返回null。 （4）队列大小：
int size(): 返回队列中的元素个数。boolean isEmpty(): 判断队列是否为空。 Queue接口还有一些其他方法，如clear()用于清空队列中的所有元素，contains(Object o)用于判断队列是否包含指定元素等。
Queue接口的常见实现类包括LinkedList、ArrayDeque和PriorityQueue等。LinkedList实现了Queue接口，并且还可以作为栈使用，它是一个双向链表。ArrayDeque是一个双端队列，它同时实现了Queue和Deque接口。PriorityQueue是一个基于优先级的队列，它允许元素按照优先级顺序被插入和删除。
通过使用Queue接口，我们可以方便地进行队列操作，如入队、出队、查看队列头部元素等。它在处理任务调度、消息传递等场景中非常有用。
Java Queue接口使用示例：
当使用Java中的Queue接口时，我们需要选择具体的实现类来创建一个队列对象。下面是一个使用Queue接口的示例，以LinkedList实现类为例：
import java.util.Queue; import java.util.LinkedList; public class QueueExample { public static void main(String[] args) { // 创建一个Queue对象 Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); // 添加元素到队列 queue." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f739ff3fec2b3ab14c8b8dc99f3d8642/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-15T21:56:45+08:00" />
<meta property="article:modified_time" content="2023-05-15T21:56:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 数据结构之队列(Queue)详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc-toc" style="margin-left:80px;"><a href="#main-toc" rel="nofollow">1、在Java中有哪些常见的队列？</a></p> 
<p id="2%E3%80%81Queue%20%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2%E3%80%81Queue%20%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90" rel="nofollow">2、Queue 接口分析</a></p> 
<p id="%C2%A03%E3%80%81Deque%20%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#%C2%A03%E3%80%81Deque%20%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90" rel="nofollow">3、Deque 接口分析</a></p> 
<p id="4%E3%80%81PriorityQueue%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3-toc" style="margin-left:80px;"><a href="#4%E3%80%81PriorityQueue%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3" rel="nofollow">4、PriorityQueue 的实现原理详解</a></p> 
<p id="5%E3%80%81%E4%BD%BF%E7%94%A8Java%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E4%BD%BF%E7%94%A8Java%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B" rel="nofollow">5、使用Java数组实现队列的简单示例</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4>1、在Java中有哪些常见的队列？</h4> 
<p>        在Java中，有一些常见的队列实现。下面是其中一些的列举：<span style="color:#4da8ee;">//队列也是一种线性的数据结构</span></p> 
<ol><li><strong>ArrayList：</strong>ArrayList<span style="color:#fe2c24;">可以被用作队列</span>，通过在列表末尾添加元素，并使用<code>remove(0)</code>方法从列表的开头删除元素。但是，由于在列表的开头删除元素会导致后续元素的移动，因此对于大量的插入和删除操作来说，ArrayList的性能可能不是最佳选择。</li><li><strong>LinkedList：</strong>LinkedList也可以用作队列。LinkedList实现了<code>Queue</code>接口，可以使用<code>offer()</code>方法在队列的末尾添加元素，使用<code>poll()</code>方法从队列的开头删除并返回元素。LinkedList对于插入和删除操作具有较好的性能，因为它使用了指针来链接元素，而不需要移动其他元素。</li><li><strong>ArrayBlockingQueue：</strong>ArrayBlockingQueue是一个<span style="color:#fe2c24;">有界阻塞队列</span>，底层使用数组实现。它有一个固定的容量，并且在插入或删除元素时可能会阻塞线程，直到满足特定的条件。</li><li><strong>LinkedBlockingQueue：</strong>LinkedBlockingQueue是一个<span style="color:#fe2c24;">可选有界或无界的阻塞队列</span>，底层使用链表实现。它具有类似于ArrayBlockingQueue的功能，但在内部实现上略有不同。</li><li><strong>PriorityBlockingQueue：</strong>PriorityBlockingQueue是一个<span style="color:#fe2c24;">支持优先级的无界阻塞队列</span>。元素按照它们的优先级顺序被插入和删除。</li><li><strong>ConcurrentLinkedQueue：</strong>ConcurrentLinkedQueue是一个非阻塞无界队列，它适用于多线程环境。它使用链表实现，并且提供了高效的并发操作。</li></ol> 
<p>        以上是Java中的一些常见队列实现。具体选择哪种队列取决于你的需求和使用场景。</p> 
<h4 id="2%E3%80%81Queue%20%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90">2、Queue 接口分析</h4> 
<p>        <span style="color:#fe2c24;">Queue接口是Java集合框架中定义的一个接口，它代表了一个先进先出（FIFO）的队列</span>。Queue接口继承自Collection接口，它定义了一组方法来操作队列中的元素。下面是Queue接口的一些主要方法和特性的详细解释：</p> 
<p><strong>（1）添加元素：</strong></p> 
<ol><li>boolean add(E element): 将指定的元素添加到队列的末尾，如果成功则返回true，如果队列已满则抛出异常。</li><li>boolean offer(E element): 将指定的元素添加到队列的末尾，如果成功则返回true，如果队列已满则返回false。</li></ol> 
<p><strong>（2）移除元素：</strong></p> 
<ol><li>E remove(): 移除并返回队列头部的元素，如果队列为空则抛出异常。</li><li>E poll(): 移除并返回队列头部的元素，如果队列为空则返回null。</li></ol> 
<p><strong>（3）获取头部元素：</strong></p> 
<ol><li>E element(): 获取队列头部的元素，但不移除它，如果队列为空则抛出异常。</li><li>E peek(): 获取队列头部的元素，但不移除它，如果队列为空则返回null。</li></ol> 
<p><strong>（4）队列大小：</strong></p> 
<ol><li>int size(): 返回队列中的元素个数。</li><li>boolean isEmpty(): 判断队列是否为空。</li></ol> 
<p>        Queue接口还有一些其他方法，如<span style="color:#fe2c24;">clear()用于清空队列中的所有元素</span>，<span style="color:#fe2c24;">contains(Object o)用于判断队列是否包含指定元素</span>等。</p> 
<p>        Queue接口的常见实现类包括<span style="color:#fe2c24;">LinkedList、ArrayDeque</span>和<span style="color:#fe2c24;">PriorityQueue</span>等。LinkedList实现了Queue接口，并且还可以作为栈使用，它是一个双向链表。ArrayDeque是一个双端队列，它同时实现了Queue和Deque接口。PriorityQueue是一个基于优先级的队列，它允许元素按照优先级顺序被插入和删除。</p> 
<p>        通过使用Queue接口，我们可以方便地进行队列操作，如入队、出队、查看队列头部元素等。它<span style="color:#fe2c24;">在处理任务调度、消息传递等场景中非常有用</span>。</p> 
<p class="img-center"><img alt="" height="204" src="https://images2.imgbox.com/e6/9c/V6uEVIAw_o.png" width="600"></p> 
<p>    <strong>    Java Queue接口使用示例：</strong></p> 
<p>        当使用Java中的Queue接口时，我们需要选择具体的实现类来创建一个队列对象。下面是一个使用Queue接口的示例，以LinkedList实现类为例：</p> 
<pre><code>import java.util.Queue;
import java.util.LinkedList;

public class QueueExample {
    public static void main(String[] args) {
        // 创建一个Queue对象
        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

        // 添加元素到队列
        queue.add("Apple");
        queue.add("Banana");
        queue.add("Orange");

        // 获取队列头部元素
        String head = queue.peek();
        System.out.println("头部元素：" + head);

        // 遍历队列并输出元素
        System.out.println("队列元素：");
        for (String element : queue) {
            System.out.println(element);
        }

        // 移除队列头部元素
        String removedElement = queue.remove();
        System.out.println("移除的元素：" + removedElement);

        // 队列大小
        int size = queue.size();
        System.out.println("队列大小：" + size);

        // 判断队列是否为空
        boolean isEmpty = queue.isEmpty();
        System.out.println("队列是否为空：" + isEmpty);
    }
}
</code></pre> 
<p>        在这个示例中，我们使用LinkedList作为实现类创建了一个Queue对象。我们向队列中添加了三个元素："Apple"，"Banana"和"Orange"。然后，我们使用peek()方法获取队列的头部元素，并使用for-each循环遍历队列并输出每个元素。</p> 
<p>        接下来，我们使用remove()方法移除队列的头部元素，并使用size()方法获取队列的大小。最后，我们使用isEmpty()方法判断队列是否为空。</p> 
<h4 id="%C2%A03%E3%80%81Deque%20%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90">3、Deque 接口分析</h4> 
<p>        Deque接口是Java集合框架中定义的一个接口，它代表了一个双端队列（Double Ended Queue）。Deque是"双端队列"的缩写。<span style="color:#fe2c24;">Deque接口继承自Queue接口，并在其基础上提供了在队列两端进行添加、删除和检索元素的操作</span>。Deque可以在队列的头部和尾部同时进行元素的插入和删除，因此可以作为队列、栈或双向队列使用。</p> 
<p>        Deque接口定义了以下主要方法和特性：</p> 
<p><strong>（1）添加元素：</strong></p> 
<ol><li>void addFirst(E element): 将指定元素添加到双端队列的头部。</li><li>void addLast(E element): 将指定元素添加到双端队列的尾部。</li><li>boolean offerFirst(E element): 将指定元素添加到双端队列的头部，如果成功则返回true，如果队列已满则返回false。</li><li>boolean offerLast(E element): 将指定元素添加到双端队列的尾部，如果成功则返回true，如果队列已满则返回false。</li></ol> 
<p><strong>（2）移除元素：</strong></p> 
<ol><li>E removeFirst(): 移除并返回双端队列的头部元素，如果队列为空则抛出异常。</li><li>E removeLast(): 移除并返回双端队列的尾部元素，如果队列为空则抛出异常。</li><li>E pollFirst(): 移除并返回双端队列的头部元素，如果队列为空则返回null。</li><li>E pollLast(): 移除并返回双端队列的尾部元素，如果队列为空则返回null。</li></ol> 
<p><strong>（3）获取头部和尾部元素：</strong></p> 
<ol><li>E getFirst(): 获取双端队列的头部元素，但不移除它，如果队列为空则抛出异常。</li><li>E getLast(): 获取双端队列的尾部元素，但不移除它，如果队列为空则抛出异常。</li><li>E peekFirst(): 获取双端队列的头部元素，但不移除它，如果队列为空则返回null。</li><li>E peekLast(): 获取双端队列的尾部元素，但不移除它，如果队列为空则返回null。</li></ol> 
<p>        Deque接口还提供了一些其他方法，如size()用于返回双端队列中的元素个数，isEmpty()用于判断双端队列是否为空，clear()用于清空双端队列中的所有元素等。</p> 
<p>        <span style="color:#fe2c24;">Deque接口的常见实现类包括ArrayDeque和LinkedList</span>。ArrayDeque是一个基于数组实现的双端队列，支持高效的随机访问和动态扩展。LinkedList是一个基于链表实现的双端队列，支持高效的插入和删除操作。</p> 
<p>        通过使用Deque接口，我们可以方便地进行双端队列操作，如在队列的头部和尾部插入和删除元素，获取头部和尾部元素，以及判断队列是否为空。<span style="color:#fe2c24;">Deque在许多场景下都很有用，比如实现LRU缓存、实现任务调度等</span>。</p> 
<p>        另外，需要注意的是，<span style="color:#fe2c24;">Deque接口还可以用作栈（LIFO）的数据结构</span>。通过在队列头部执行插入和删除操作，可以实现栈的功能。常见的栈操作可以使用Deque接口中的以下方法来实现：</p> 
<ol><li>void push(E element): 将元素推入栈顶，等同于addFirst(E element)。</li><li>E pop(): 弹出并返回栈顶元素，等同于removeFirst()。</li><li>E peek(): 获取栈顶元素，等同于peekFirst()。</li></ol> 
<p>        所以，Deque接口是一个非常有用的接口，提供了双端队列的功能，既可以在队列的头部进行操作，也可以在尾部进行操作。它是Queue接口的扩展，可以方便地实现队列、栈和双向队列的功能，并提供了丰富的方法来操作和访问队列中的元素。</p> 
<p><strong>        Java Deque 接口使用示例</strong></p> 
<p>        当使用Java中的Deque接口时，我们同样需要选择具体的实现类来创建一个双端队列对象。下面是一个使用Deque接口的示例，以ArrayDeque实现类为例：</p> 
<pre><code>import java.util.Deque;
import java.util.ArrayDeque;

public class DequeExample {
    public static void main(String[] args) {
        // 创建一个Deque对象
        Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();

        // 添加元素到双端队列
        deque.addFirst("Apple");
        deque.addLast("Banana");
        deque.addLast("Orange");

        // 获取双端队列头部和尾部元素
        String first = deque.getFirst();
        String last = deque.getLast();
        System.out.println("头部元素：" + first);
        System.out.println("尾部元素：" + last);

        // 遍历双端队列并输出元素
        System.out.println("双端队列元素（从头到尾）：");
        for (String element : deque) {
            System.out.println(element);
        }

        // 移除双端队列头部和尾部元素
        String removedFirst = deque.removeFirst();
        String removedLast = deque.removeLast();
        System.out.println("移除的头部元素：" + removedFirst);
        System.out.println("移除的尾部元素：" + removedLast);

        // 双端队列大小
        int size = deque.size();
        System.out.println("双端队列大小：" + size);

        // 判断双端队列是否为空
        boolean isEmpty = deque.isEmpty();
        System.out.println("双端队列是否为空：" + isEmpty);
    }
}
</code></pre> 
<p>        在这个示例中，我们使用ArrayDeque作为实现类创建了一个Deque对象。我们向双端队列中添加了三个元素："Apple"、"Banana"和"Orange"。然后，我们使用getFirst()和getLast()方法分别获取双端队列的头部和尾部元素，并使用for-each循环遍历双端队列并输出每个元素。</p> 
<p>        接下来，我们使用removeFirst()和removeLast()方法移除双端队列的头部和尾部元素，并使用size()方法获取双端队列的大小。最后，我们使用isEmpty()方法判断双端队列是否为空。</p> 
<h4 id="4%E3%80%81PriorityQueue%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3">4、PriorityQueue 的实现原理详解</h4> 
<p>        PriorityQueue的实现原理是基于<span style="color:#fe2c24;">二叉堆（Binary Heap）</span>，它是一种特殊的<strong>完全二叉树结构</strong>，具有以下性质：</p> 
<ul><li><strong>最小堆性质：</strong>在最小堆中，每个节点的值都小于或等于其子节点的值。也就是说，堆的根节点是最小的元素。</li></ul> 
<p>        <span style="color:#fe2c24;">PriorityQueue使用一个数组来存储元素</span>，并通过二叉堆的形式来组织这些元素。数组中的元素按照特定的顺序排列，满足最小堆的性质。在数组中，根节点位于索引0处，而对于任意位置i的节点，它的左子节点位于索引2i+1处，右子节点位于索引2i+2处。</p> 
<p>        当<span style="color:#fe2c24;">元素被添加到PriorityQueue时</span>，它会被放置在数组的末尾，并按照以下步骤进行调整，以维护最小堆的性质：</p> 
<ul><li><strong>上滤（Up-Heap）操作</strong>：新插入的元素会与其父节点进行比较。如果新插入的元素的优先级比父节点的优先级低（或者更大），则它会与父节点进行交换，直到满足最小堆的性质。</li></ul> 
<p>        当<span style="color:#fe2c24;">从PriorityQueue中删除元素时</span>，队列头部的元素被移除，并将数组的最后一个元素移动到头部位置。然后，这个元素会与其子节点进行比较，以保持最小堆的性质。</p> 
<ul><li><strong>下滤（Down-Heap）操作：</strong>被移动到头部位置的元素会与其子节点进行比较。如果它的优先级比其中一个或两个子节点的优先级高（或者更小），则它会与较小的子节点进行交换。这个过程会递归地向下进行，直到满足最小堆的性质。</li></ul> 
<p>        通过上述的上滤和下滤操作，PriorityQueue可以保持最小堆的性质，使得具有最高优先级的元素总是位于队列的头部。</p> 
<p>        PriorityQueue的插入和删除操作的时间复杂度都是O(logN)，其中N是队列中的元素个数。这是因为这些操作涉及到堆的调整，需要按照树的高度来进行操作。同时，PriorityQueue还支持高效的查找具有最高优先级的元素，时间复杂度为O(1)。</p> 
<p>        需要注意的是，PriorityQueue允许元素具有相同的优先级，但它们的顺序不一定是确定的。在这种情况下，PriorityQueue的行为是不保证的，<span style="color:#fe2c24;">具有相同优先级的元素可能会以任意顺序被取出</span>。</p> 
<p>        优先队列(PriorityQueue)的使用示例：</p> 
<pre><code class="hljs">    public static void main(String[] args) {
        //默认采用的是最小堆实现的
        PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(10, new Comparator&lt;Integer&gt;() {
            public int compare(Integer a, Integer b) {
                return a - b; //if a&gt;b 则交换，so这是递增序列
            }
        });
        queue.offer(13);
        queue.offer(9);
        int len = queue.size();
        for (int i = 0; i &lt; len; i++) {
            System.out.println(queue.poll());
        }
        //输出 9  13
        //默认采用的是最小堆实现的
        PriorityQueue&lt;Integer&gt; queue2 = new PriorityQueue&lt;&gt;(10);
        queue2.offer(11);
        queue2.offer(9);
        len = queue2.size();
        for (int i = 0; i &lt; len; i++) {
            System.out.println(queue2.poll());
        }
        //输出 9， 11
    }</code></pre> 
<h4 id="5%E3%80%81%E4%BD%BF%E7%94%A8Java%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B">5、使用Java数组实现队列的简单示例</h4> 
<p>        下面是使用Java数组实现队列的简单示例代码：</p> 
<pre><code class="hljs">public class ArrayQueue {
    private int[] queue;  // 内部数组
    private int front;    // 队列头部指针
    private int rear;     // 队列尾部指针
    private int size;     // 队列当前元素个数
    private int capacity; // 队列容量

    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        queue = new int[capacity];
        front = 0;
        rear = -1;
        size = 0;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }

    public int size() {
        return size;
    }

    public void enqueue(int item) {
        if (isFull()) {
            System.out.println("Queue is full. Cannot enqueue.");
            return;
        }
        rear = (rear + 1) % capacity; // 循环队列，计算新的尾部位置
        queue[rear] = item;
        size++;
        System.out.println("Enqueued: " + item);
    }

    public int dequeue() {
        if (isEmpty()) {
            System.out.println("Queue is empty. Cannot dequeue.");
            return -1;
        }
        int item = queue[front];
        front = (front + 1) % capacity; // 循环队列，计算新的头部位置
        size--;
        System.out.println("Dequeued: " + item);
        return item;
    }

    public int peek() {
        if (isEmpty()) {
            System.out.println("Queue is empty.");
            return -1;
        }
        return queue[front];
    }

    public void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty.");
            return;
        }
        System.out.print("Queue: ");
        int index = front;
        for (int i = 0; i &lt; size; i++) {
            System.out.print(queue[index] + " ");
            index = (index + 1) % capacity; // 循环遍历队列
        }
        System.out.println();
    }

    public static void main(String[] args) {
        ArrayQueue queue = new ArrayQueue(5);
        queue.enqueue(10);
        queue.enqueue(20);
        queue.enqueue(30);
        queue.display(); // Queue: 10 20 30
        queue.dequeue();
        queue.display(); // Queue: 20 30
        queue.enqueue(40);
        queue.enqueue(50);
        queue.display(); // Queue: 20 30 40 50
        queue.dequeue();
        queue.dequeue();
        queue.display(); // Queue: 40 50
    }
}</code></pre> 
<p>        以上示例演示了使用Java数组实现的<span style="color:#fe2c24;">简单队列（循环队列）</span>。通过enqueue()方法将元素入队，dequeue()方法将元素出队，peek()方法返回队列头部元素，size()方法返回队列当前元素个数，isEmpty()方法和isFull()方法检查队列是否为空或已满。display()方法用于打印队列中的元素。</p> 
<p class="img-center"><img alt="" height="198" src="https://images2.imgbox.com/36/dc/GvEM9BxM_o.png" width="600"></p> 
<p>        上述循环队列实现的具体步骤总结如下：</p> 
<p><strong>（1）入队操作（enqueue）：</strong></p> 
<ol><li>首先，检查队列是否已满（isFull()方法）。如果已满，则无法入队，并输出相应的提示信息。</li><li>否则，<span style="color:#fe2c24;">计算新的尾部位置（rear = (rear + 1) % capacity）</span>，并将新元素存储到该位置。</li><li>增加队列的元素个数（size++）。</li><li>输出入队的元素信息。</li></ol> 
<p><strong>（2）出队操作（dequeue）：</strong></p> 
<ol><li>首先，检查队列是否为空（isEmpty()方法）。如果为空，则无法出队，并输出相应的提示信息。</li><li>否则，获取头部元素（queue[front]）并保存到临时变量中。</li><li><span style="color:#fe2c24;">计算新的头部位置（front = (front + 1) % capacity）</span>。</li><li>减少队列的元素个数（size--）。</li><li>输出出队的元素信息，并返回该元素的值。</li></ol> 
<p><strong>（3）查看头部元素（peek）：</strong></p> 
<ol><li>首先，检查队列是否为空（isEmpty()方法）。如果为空，则输出相应的提示信息并返回特定的值（如-1）。</li><li>否则，返回头部元素（queue[front]）的值。</li></ol> 
<p><strong>（4）判断队列是否为空（isEmpty）：</strong></p> 
<ul><li>根据队列的元素个数（size）是否为0来判断队列是否为空。</li></ul> 
<p><strong>（5）判断队列是否已满（isFull）：</strong></p> 
<ul><li>根据队列的元素个数（size）是否等于队列的容量（capacity）来判断队列是否已满。</li></ul> 
<p><strong>（6）遍历打印队列中的元素（display）：</strong></p> 
<ol><li>首先，检查队列是否为空（isEmpty()方法）。如果为空，则输出相应的提示信息。</li><li>否则，从头部位置（front）开始循环遍历队列中的元素，依次输出每个元素。</li><li><span style="color:#fe2c24;">注意使用循环变量（index）进行索引，并通过取余运算实现循环遍历</span>。</li></ol> 
<p>        这样，通过以上实现，我们可以使用Java数组来创建一个简单的队列，并进行入队、出队、查看头部元素以及遍历打印等操作。这种基于数组的实现方式可以满足队列的基本需求，并且具有较好的性能。但需要注意的是，由于数组的容量是固定的，当队列已满时，无法再添加新的元素，除非进行元素的出队操作。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f742857ca6f4ca62d1964d785c81eee1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">diffusion扩散/GAN~3D</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7d9fb976f414d65e43b21a8d701f29c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">rtl仿真器-iverilog icarus安装和测试</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>