<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kubernetes Pod Lifecycle生命周期与livenessProbe、 readinessProbe探测方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="kubernetes Pod Lifecycle生命周期与livenessProbe、 readinessProbe探测方法" />
<meta property="og:description" content="kuberenetes pod Liveness, Readiness and Startup Probes tags: Pod,探针,健康检测
文章目录 kuberenetes pod Liveness, Readiness and Startup Probes1. Pod 状态2. Ready 状态3. 为什么需要健康检查4. Pod 生命周期条件5. 容器探针5.1 ReadinessProbe5.2 LivenessProbe5.3 StartupProbe 6. 什么时候应该使用活动探针与就绪探针？7. 配置技巧7.1 使用命名端口7.2 使用启动探测器保护慢启动容器 8. 探测方法8.1 http 探测8.2 cmd 探测8.3 TCP 探测 1. Pod 状态 Pod 的生命周期是 PodStatus 对象，其中包含一个phase字段。
值描述Pending该Pod已被Kubernetes系统接受，但是尚未创建一个或多个Container映像。这包括计划之前的时间以及通过网络下载图像所花费的时间，这可能需要一段时间。RunningPod已绑定到节点，并且所有容器都已创建。至少一个容器仍在运行，或者正在启动或重新启动。SucceededPod中的所有容器已成功终止，并且不会重新启动。FailedPod中的所有容器均已终止，并且至少一个容器因故障而终止。也就是说，容器要么以非零状态退出，要么被系统终止。Unknown由于某些原因，通常由于与Pod主机通信时出错而无法获得Pod的状态。 我们最常接触到的 Pod 状态是 Pending 和 Running。Pending 代表 Pod 正在创建中，而 Running 状态则要求至少有一个容器正在启动中或者正在运行。而对于 Pod 中的容器，也有下面 3 种状态。
而对于 Pod 中的容器，也有下面 3 种状态：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1408b2b6f106e1eb808dd7f3b605a9bb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-07T00:42:22+08:00" />
<meta property="article:modified_time" content="2023-07-07T00:42:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kubernetes Pod Lifecycle生命周期与livenessProbe、 readinessProbe探测方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="kuberenetes_pod_Liveness_Readiness_and_Startup_Probes_0"></a>kuberenetes pod Liveness, Readiness and Startup Probes</h2> 
<p>tags: Pod,探针,健康检测</p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#kuberenetes_pod_Liveness_Readiness_and_Startup_Probes_0" rel="nofollow">kuberenetes pod Liveness, Readiness and Startup Probes</a></li><li><ul><li><a href="#1_Pod__11" rel="nofollow">1. Pod 状态</a></li><li><a href="#2_Ready__33" rel="nofollow">2. Ready 状态</a></li><li><a href="#3__50" rel="nofollow">3. 为什么需要健康检查</a></li><li><a href="#4_Pod__61" rel="nofollow">4. Pod 生命周期条件</a></li><li><a href="#5__78" rel="nofollow">5. 容器探针</a></li><li><ul><li><a href="#51_ReadinessProbe_99" rel="nofollow">5.1 ReadinessProbe</a></li><li><a href="#52_LivenessProbe_154" rel="nofollow">5.2 LivenessProbe</a></li><li><a href="#53_StartupProbe_180" rel="nofollow">5.3 StartupProbe</a></li></ul> 
   </li><li><a href="#6__228" rel="nofollow">6. 什么时候应该使用活动探针与就绪探针？</a></li><li><a href="#7__239" rel="nofollow">7. 配置技巧</a></li><li><ul><li><a href="#71__240" rel="nofollow">7.1 使用命名端口</a></li><li><a href="#72__254" rel="nofollow">7.2 使用启动探测器保护慢启动容器</a></li></ul> 
   </li><li><a href="#8__280" rel="nofollow">8. 探测方法</a></li><li><ul><li><a href="#81_http__281" rel="nofollow">8.1 http 探测</a></li><li><a href="#82_cmd__314" rel="nofollow">8.2 cmd 探测</a></li><li><a href="#83_TCP__340" rel="nofollow">8.3 TCP 探测</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p><a href="https://www.rottentomatoes.com/m/ex_machina" rel="nofollow"><br> <img src="https://images2.imgbox.com/30/c4/k3Y0tH3N_o.png" alt="在这里插入图片描述"></a></p> 
<h3><a id="1_Pod__11"></a>1. Pod 状态</h3> 
<p>Pod 的生命周期是 PodStatus 对象，其中包含一个phase字段。</p> 
<table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Pending</td><td>该Pod已被Kubernetes系统接受，但是尚未创建一个或多个Container映像。这包括计划之前的时间以及通过网络下载图像所花费的时间，这可能需要一段时间。</td></tr><tr><td>Running</td><td>Pod已绑定到节点，并且所有容器都已创建。至少一个容器仍在运行，或者正在启动或重新启动。</td></tr><tr><td>Succeeded</td><td>Pod中的所有容器已成功终止，并且不会重新启动。</td></tr><tr><td>Failed</td><td>Pod中的所有容器均已终止，并且至少一个容器因故障而终止。也就是说，容器要么以非零状态退出，要么被系统终止。</td></tr><tr><td>Unknown</td><td>由于某些原因，通常由于与Pod主机通信时出错而无法获得Pod的状态。</td></tr></tbody></table> 
<p>我们最常接触到的 Pod 状态是 <code>Pending</code> 和 <code>Running</code>。Pending 代表 Pod 正在创建中，而 Running 状态则要求至少有一个容器正在启动中或者正在运行。而对于 Pod 中的容器，也有下面 3 种状态。</p> 
<p>而对于 Pod 中的容器，也有下面 3 种状态：</p> 
<ul><li><code>Waiting</code>：容器等待中，例如正在拉取镜像。</li><li><code>Running</code>：容器运行中，PID=1 的业务进程正在启动或运行。</li><li><code>Terminated</code>：容器终止中，例如正在删除 Pod。</li></ul> 
<p>是不是感觉有点混乱？没关系，现在我们只需要关注 Pod 和容器同时处于 Running 的状态，其他的暂时忽略就可以。当 Pod 处于 Running 状态时，代表至少有一个容器处于启动或运行状态。所以，我们只需要关注容器的 Running 状态就可以间接决定 Pod 的状态。而当容器状态为 Running 时，代表 PID=1 的业务进程正在启动或运行。</p> 
<p>不过要注意的是，当业务进程还处于启动过程时，<strong>Pod 和容器都处于 Running 状态，但由于业务并没有完成启动，所以还不具备接收外部流量的条件。这时候，光有一个 Running 状态是不够的，我们还需要一个能够描述 Pod 是否已经就绪并准备好接收外部请求的标识，它就是 Pod 的 Ready 字段</strong>。</p> 
<h3><a id="2_Ready__33"></a>2. Ready 状态</h3> 
<p>在 K8s 中，Pod 的 Ready 字段用来标识是否已经就绪，它是由 kubelet 直接管理的， Ready 状态被记录在了 Pod Manifest 的 <code>status.conditions</code> 字段下。</p> 
<p><img src="https://images2.imgbox.com/c2/8b/UM6BxL1l_o.png" alt="在这里插入图片描述"><br> 你也可以通过 <code>kubectl get pods</code> 来查看 Pod 是否处于 Ready 状态。</p> 
<pre><code class="prism language-bash">$ kubectl get pods <span class="token parameter variable">-n</span> example
NAME                        READY   STATUS    RESTARTS        AGE
backend-5969f76d6c-jf9lq    <span class="token number">0</span>/1     Pending   <span class="token number">0</span>               102m
backend-86d76d8764-cl2pf    <span class="token number">1</span>/1     Running   <span class="token number">0</span>               109m
backend-86d76d8764-pgvhd    <span class="token number">1</span>/1     Running   <span class="token number">0</span>               109m
frontend-fc597b5d9-qcbfb    <span class="token number">1</span>/1     Running   <span class="token number">2</span> <span class="token punctuation">(</span>5h32m ago<span class="token punctuation">)</span>   19h
postgres-7745b57d5d-5lbzz   <span class="token number">1</span>/1     Running   <span class="token number">3</span> <span class="token punctuation">(</span>5h32m ago<span class="token punctuation">)</span>   15d
</code></pre> 
<p>在返回结果的 Ready 字段中，1/1 表示运行中的容器数量和总容器数量，当这两者数量相等时，代表 Pod 处于 Ready 状态，说明 Pod 已经就绪并准备好了接收外部流量。</p> 
<h3><a id="3__50"></a>3. 为什么需要健康检查</h3> 
<p>在生产环境，我们为某个业务配置了 CPU 限制，业务运行一段时间后，由于业务应用没有做好垃圾回收甚至产生死锁的情况，导致它的 CPU 占用率一直处在限制值附近。此时，虽然 Pod 的业务进程仍在运行，但实际上它已经无法得到更多的 CPU 时间片了。我的问题是，这时候它能正常处理业务请求吗？毫无疑问，它处理业务会非常缓慢，甚至会完全不可用。</p> 
<p>除了因为资源不足导致业务不可用以外，还有一类典型的场景：在进行水平扩容时，由于新创建的 Pod 的业务进程需要的启动时间较长（例如对于大型的 Java 应用，往往需要数分钟的启动时间），如果在业务启动时就将 Pod 标记为 Ready 状态并接收外部请求流量，将会有部分请求得到错误的返回，如下图所示。</p> 
<p><img src="https://images2.imgbox.com/88/4f/WVi1F1TR_o.png" alt="在这里插入图片描述"><br> 所以，这两种情况都引出了一个非常有意思的场景：因为业务进程处于运行状态，Pod 和容器也处于 Running 状态，所以 K8s 会认为当前 Pod 是就绪的。但实际上，业务可能正处于“** 启动中”或者出现“**资源不足”的情况，暂时无法对外提供服务。</p> 
<p>这两个例子告诉我们，在一般情况下，Pod 就绪（Ready）不等于业务健康。那么，如何才能让 K8s 感知到业务真实的健康状态呢？这时候我们就需要用到 K8s 探针。</p> 
<h3><a id="4_Pod__61"></a>4. Pod 生命周期条件</h3> 
<p>Pod具有PodStatus，该状态具有<code>PodConditions</code>数组 ，该Pod已通过或未通过。PodCondition数组的每个元素都有六个可能的字段：</p> 
<ul><li>该<code>lastProbeTime</code>字段提供上次探测Pod条件的时间戳。</li><li>该<code>lastTransitionTime</code>字段提供Pod上一次从一种状态转换为另一种状态的时间戳。</li><li>该<code>message</code>字段是人类可读的消息，指示有关过渡的详细信息。</li><li>该<code>reason</code>字段是条件最后一次转换的唯一单词CamelCase原因。</li><li>该<code>status</code>字段是一个字符串，可能的值为“ True”，“ False”和“ Unknown”。</li><li>该<code>type</code>字段是具有以下可能值的字符串：</li></ul> 
<pre><code class="prism language-bash">PodScheduled：Pod已调度到一个节点；
Ready：Pod能够处理请求，应将其添加到所有匹配服务的负载平衡池中；
Initialized：所有初始化容器 已成功启动；
Unschedulable：例如，由于缺乏资源或其他限制，调度程序无法立即调度Pod；
ContainersReady：Pod中的所有容器已准备就绪。
</code></pre> 
<h3><a id="5__78"></a>5. 容器探针</h3> 
<p>K8s 的健康检查类型一共有三种，分别是：</p> 
<ul><li><code>livenessProbe</code>：指示容器是否正在运行。如果活动探针失败，则kubelet将杀死Container，并且Container将接受其重新启动策略。如果容器未提供活动性探针，则默认状态为Success。</li><li><code>readinessProbe</code>：指示容器是否准备好服务请求。如果就绪探针失败，则端点控制器将从与Pod匹配的所有服务的端点中删除Pod的IP地址。初始延迟之前的默认就绪状态为Failure。如果容器未提供就绪探测器，则默认状态为Success。</li><li><code>StartupProbe</code>：</li></ul> 
<p>有三种类型的处理程序：</p> 
<ul><li><code>ExecAction</code>：在Container中执行指定的命令。如果命令以状态代码0退出，则认为诊断成功。</li><li><code>TCPSocketAction</code>：对指定端口上的容器的IP地址执行TCP检查。如果端口打开，则认为诊断成功。</li><li><code>HTTPGetAction</code>：对指定端口和路径上的容器的IP地址执行HTTP<br> Get请求。如果响应的状态码大于或等于200且小于400，则认为诊断成功。</li></ul> 
<p>每个探针具有以下三个结果之一：</p> 
<ul><li>成功：容器通过了诊断。</li><li>失败：容器无法通过诊断。</li><li>未知：诊断失败，因此不应采取任何措施。</li></ul> 
<h4><a id="51_ReadinessProbe_99"></a>5.1 ReadinessProbe</h4> 
<p>Readiness 又称为就绪探针，它用来确定 Pod 是否为就绪（Ready）状态，以及是否能够接收外部流量。例如，当某一些 Pod 出现短暂的延迟或不可用时，我们希望它不接收外部流量，这时候 Readiness 就非常有用。Readiness 探针能够识别业务的健康状态，并通过健康状态来控制 Pod 是否接受外部请求流量。</p> 
<p>我们以示例应用 Backend Deployment 服务为例，来看看怎么为工作负载配置 Readiness 探针。下面是 Backend Deployment Manifest 的部分内容。</p> 
<pre><code class="prism language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
spec:
  <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
    spec:
      containers:
      - name: flask-backend
        image: lyzhang1999/backend:latest
        <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
        readinessProbe: 
          httpGet:
            path: /healthy
            port: <span class="token number">5000</span>
            scheme: HTTP
          initialDelaySeconds: <span class="token number">10</span>
          failureThreshold: <span class="token number">5</span>
          periodSeconds: <span class="token number">10</span>
          successThreshold: <span class="token number">1</span>
          timeoutSeconds: <span class="token number">1</span>
</code></pre> 
<p>这里要重点关注 readinessProbe 字段，它为 K8s Readiness 探针提供了必要的信息。</p> 
<p>我们先来看第 14 行的 <code>httpGet</code> 下的几个字段，path 字段的含义是“通过请求 healthy 接口来判断”，Port 字段指定了 Python 后端服务的监听端口 5000，<code>scheme</code> 字段代表协议。探针请求的完整路径为：<code>http://PodIP:5000/healthy</code>，相当于以 Get 的方式主动访问业务接口，当接口返回 <code>200-399</code> 状态码时，则视为本次探针请求成功。</p> 
<ul><li><code>initialDelaySeconds</code> 的含义是在容器启动之后，延迟 10 秒钟再进行第一次探针检查。</li><li><code>failureThreshold</code> 的含义是，如果连续 5 次探针失败则代表 Readiness 探针失败，Pod 状态为 NotReady，此时 Pod 不会接收外部请求。</li><li><code>periodSeconds</code> 的含义是探针每 10 秒钟轮询检测 1 次。</li><li><code>successThreshold</code> 的含义是只要探针成功 1 次就代表探针成功了，Pod 状态为 Ready 表示可以接收外部请求。</li><li><code>timeoutSeconds</code> 代表探针的超时时间为 1 秒。</li></ul> 
<p><img src="https://images2.imgbox.com/60/77/LsCy0w0P_o.png" alt="在这里插入图片描述"></p> 
<p>综合这些配置信息，我们可以得出几个重要的数字。在 Pod 启动之后，如果在 60 秒内（<code>initialDelaySeconds + failureThreshold * periodSeconds</code>） 不能通过健康检查， Pod 将处于非就绪状态。</p> 
<p>当 Pod 处于正常的运行状态时，如果业务突然产生故障，健康检查会在 50 秒内（<code>failureThreshold * periodSeconds</code>） 识别出业务的不健康状态；当 Pod 业务恢复健康时，健康检查会在 10 秒内（<code>successThreshold * periodSeconds</code>） 识别出业务已恢复。</p> 
<p>Readiness 探针的一个非常重要的作用是，它负责找出业务状态不健康的 Pod，并且将它从 Service EndPoints 列表移除，使它无法接收到外部请求。如果 Pod 的 Readiness 探针一直无法通过，那么 Pod 将一直无法接收外部请求，如下图所示。<br> <img src="https://images2.imgbox.com/b6/57/ZrPlmZlU_o.png" alt="在这里插入图片描述"><br> 请注意，当 Readiness 探针向业务应用发出请求时，如果在超时时间内没有收到回复，或者收到的回复的状态码大于 400，那么认为本次探测失败。试想一下，如果这时候业务已经无法自行恢复了，比如产生了死锁，此时 Readiness 探针也已经感知到业务不可用了。</p> 
<p><img src="https://images2.imgbox.com/65/da/cT4g2nOX_o.png" alt="在这里插入图片描述"><br> 那我们能否更进一步，让 K8s 帮我们自动重启 Pod 来恢复业务呢？这就是我接下来要介绍的 Liveness 探针。</p> 
<h4><a id="52_LivenessProbe_154"></a>5.2 LivenessProbe</h4> 
<p>Liveness 又称为存活探针，相比 Readiness 探针，它还能够在检测到 Pod 处于不健康状态时自动将 Pod 重启。在示例应用 Backend Deployment 中，我们也定义了 Liveness 探针。</p> 
<pre><code class="prism language-bash">spec:
  <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
    spec:
      containers:
      - name: flask-backend
        image: lyzhang1999/backend:latest
        <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
        livenessProbe: 
          httpGet:
            path: /healthy
            port: <span class="token number">5000</span>
            scheme: HTTP
          failureThreshold: <span class="token number">5</span>
          periodSeconds: <span class="token number">10</span>
          successThreshold: <span class="token number">1</span>
          timeoutSeconds: <span class="token number">1</span>
</code></pre> 
<p>Liveness 探针和 Readiness 探针非常类似，Liveness 探针是通过 livenessProbe 字段来配置的，livenessProbe 字段下面的每个字段的作用和 Readiness 探针都几乎一致，这里就不再赘述了。当 Liveness 探针失败时，它将自动重启业务不健康的 Pod，如下图所示。</p> 
<p><img src="https://images2.imgbox.com/7a/90/4kFjHv35_o.png" alt="在这里插入图片描述"><br> 需要注意的是，Liveness 和 Readiness 探针是独立并行的，它们之间并没有相互等待关系。</p> 
<h4><a id="53_StartupProbe_180"></a>5.3 StartupProbe</h4> 
<p>相比较 Liveness 和 Readiness 探针在运行阶段的探测特性，StartupProbe 是一种专门针对业务在启动阶段设计的探针。还记得我在之前提到的一个场景吗？对于一些大型的 Java 应用来说，往往需要数分钟时间才能够完成启动。这意味着，对于启动非常慢的大型应用，如果我们按照上面的例子来配置 Readiness 和 Liveness 探针，Pod 将因为探针失败而永远无法启动。</p> 
<p>那么，怎么解决这个问题呢？你可能首先会想到，是不是调整探针第一次探测的延迟时间就可以了？比如将 <code>initialDelaySeconds</code> 字段的值从 10 秒钟修改到 120 秒。这当然是可以的，但如果启动时间不是 120 秒，或者你不太确定呢？那似乎可以在修改了 initialDelaySeconds 的基础上再将失败次数 <code>failureThreshold</code> 或者探测间隔 periodSeconds 加大。</p> 
<p>这种做法虽然能解决问题，但缺点也是明显的，为了兼容应用启动慢的问题，我们主动降低了 K8s 检测 Pod 健康状态的频率，这会延迟 K8s 感知故障的速度。</p> 
<p>其实，Readiness 和 Liveness 主要用来检查的是处于运行过程中业务，因为启动过慢的问题而去调整 Readiness 和 Liveness 参数并不是最佳实践。这类问题我们可以通过 StartupProbe 来解决。</p> 
<p>StartupProbe 探针特别适用于业务应用启动慢的场景。当 Pod 启动时，如果配置了 StartupProbe，那么 Readiness 和 Liveness 探针都将被临时禁用，直到 StartupProbe 探针返回成功才会启用 Readiness 和 Liveness 探针，这也就避免了 Readiness 和 Liveness 在应用启动阶段造成的干扰。也就是说，我们只要为业务配置合理的 StartupProbe 探针，就可以解决应用启动慢导致其他探针认为 Pod 不健康的问题。</p> 
<p>StartupProbe 探针的配置方法和 Readiness、Liveness 探针也非常类似，下面是示例应用 Backend Deployment Manifest 的部分内容。</p> 
<pre><code class="prism language-bash">spec:
  <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
    spec:
      containers:
      - name: flask-backend
        image: lyzhang1999/backend:latest
        <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
        startupProbe: 
          httpGet:
            path: /healthy
            port: <span class="token number">5000</span>
            scheme: HTTP
          initialDelaySeconds: <span class="token number">10</span>
          failureThreshold: <span class="token number">5</span>
          periodSeconds: <span class="token number">10</span>
          successThreshold: <span class="token number">1</span>
          timeoutSeconds: <span class="token number">1</span>
</code></pre> 
<p>StartupProbe 是通过 startupProbe 字段来配置的。在这个例子中，Pod 启动之后 10 秒会开始第一次探测，如果至少有 1 次探测成功，那么 StartupProbe 探针就成功，接下来才会继续启动 Readiness 和 Liveness 探针。在我们刚才提到的 Java 应用的例子中，我们可以为 StartupProbe 配置足够大的 <code>initialDelaySeconds</code> 来让业务有足够的时间完成启动过程。</p> 
<p>如果一个工作负载内同时定义了这三种探针，情况会变得有些复杂，你可以结合下面这张图来理解。<br> <img src="https://images2.imgbox.com/31/18/qOs0gqA7_o.png" alt="在这里插入图片描述"><br> Pod 启动时，三种探针的执行顺序主要可以分成三个阶段。</p> 
<ul><li>第一阶段：Pod 已启动，容器已启动，业务进程正在启动中，此时 StartupProbe 开始工作，由于 StartupProbe<br> 还未成功，当前 Pod 的容器处于 Not Ready(0/1) 的状态。<br> 第二阶段：随着时间推移，StartupProbe 探针成功，Readine 和 Liveness 探针开始并行工作，此时由于 Readine 探针还未成功，当前 Pod 的容器仍然处于 Not Ready(0/1) 的状态。<br> 第三阶段：随着 Readine 和 Liveness 的探测成功，当前 Pod 的容器转为 Ready(1/1) 的状态，Service EndPoints 将 Pod 加入到列表当中，Pod 开始接收外部请求。</li></ul> 
<p><img src="https://images2.imgbox.com/2f/38/9dGkjqSz_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/dd/ee/xhLCgGoM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fb/92/tXFtLp0y_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6__228"></a>6. 什么时候应该使用活动探针与就绪探针？</h3> 
<p>如果您的Container中的进程在遇到问题或变得不正常时能够自行崩溃，则不一定需要进行活动调查；kubelet将根据Pod的自动执行正确的操作<code>restartPolicy</code>。</p> 
<p>如果您希望在探测失败时杀死并重启容器，请指定活动探测，并指定<code>restartPolicy Always</code>或<code>OnFailure</code>。</p> 
<p>如果您仅想在探测成功后才开始向Pod发送流量，请指定就绪探测器。在这种情况下，就绪探针可能与活动探针相同，但是规范中存在就绪探针意味着Pod将在不接收任何流量的情况下启动，并且仅在探针开始成功之后才开始接收流量。如果您的容器需要在启动过程中加载大型数据，配置文件或迁移，请指定<code>StartupProbe</code>探针。</p> 
<p>如果希望您的Container能够自行进行维护，则可以指定一个就绪探针，以检查特定于与活跃探针不同的就绪端点。</p> 
<blockquote> 
 <p>请注意，如果您只想在删除Pod时便能够清空请求，则不一定需要准备就绪探测器；删除后，无论是否准备就绪探针，Pod都会自动将自己置于未就绪状态。等待Pod中的Container停止时，Pod仍处于未就绪状态。</p> 
</blockquote> 
<h3><a id="7__239"></a>7. 配置技巧</h3> 
<h4><a id="71__240"></a>7.1 使用命名端口</h4> 
<pre><code class="prism language-bash">ports:
- name: liveness-port
  containerPort: <span class="token number">8080</span>
  hostPort: <span class="token number">8080</span>

livenessProbe:
  httpGet:
    path: /healthz
    port: liveness-port
</code></pre> 
<h4><a id="72__254"></a>7.2 使用启动探测器保护慢启动容器</h4> 
<pre><code class="prism language-bash">ports:
- name: liveness-port
  containerPort: <span class="token number">8080</span>
  hostPort: <span class="token number">8080</span>

livenessProbe:
  httpGet:
    path: /healthz
    port: liveness-port
  failureThreshold: <span class="token number">1</span>
  periodSeconds: <span class="token number">10</span>

startupProbe:
  httpGet:
    path: /healthz
    port: liveness-port
  failureThreshold: <span class="token number">30</span>
  periodSeconds: <span class="token number">10</span>
</code></pre> 
<p>幸亏有启动探测，应用程序将会有最多 5 分钟(30 * 10 = 300s) 的时间来完成它的启动。 一旦启动探测成功一次，存活探测任务就会接管对容器的探测，对容器死锁可以快速响应。 如果启动探测一直没有成功，容器会在 300 秒后被杀死，并且根据 restartPolicy 来设置 Pod 状态。</p> 
<p><img src="https://images2.imgbox.com/d9/15/UsRgSDIM_o.gif" alt="在这里插入图片描述"></p> 
<h3><a id="8__280"></a>8. 探测方法</h3> 
<h4><a id="81_http__281"></a>8.1 http 探测</h4> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-http
spec:
  containers:
  - args:
    - /server
    image: k8s.gcr.io/liveness
    livenessProbe:
      httpGet:
        <span class="token comment"># when "host" is not defined, "PodIP" will be used</span>
        <span class="token comment"># host: my-host</span>
        <span class="token comment"># when "scheme" is not defined, "HTTP" scheme will be used. Only "HTTP" and "HTTPS" are allowed</span>
        <span class="token comment"># scheme: HTTPS</span>
        path: /healthz
        port: <span class="token number">8080</span>
        httpHeaders:
        - name: X-Custom-Header
          value: Awesome
      initialDelaySeconds: <span class="token number">15</span>
      periodSeconds: <span class="token number">3</span>
      timeoutSeconds: <span class="token number">1</span>
    name: liveness
</code></pre> 
<p><code>periodSeconds</code> 字段指定了 kubelet 每隔 3 秒执行一次存活探测。 <code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 3 秒。 kubelet 会向容器内运行的服务（服务会监听 8080 端口）发送一个 HTTP GET 请求来执行探测。 如果服务器上 /healthz 路径下的处理程序返回成功代码，则 kubelet 认为容器是健康存活的。 如果处理程序返回失败代码，则 kubelet 会杀死这个容器并且重新启动它。</p> 
<p>任何大于或等于 200 并且小于 400 的返回代码标示成功，其它返回代码都标示失败。</p> 
<h4><a id="82_cmd__314"></a>8.2 cmd 探测</h4> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-exec
spec:
  containers:
  - name: liveness
    image: k8s.gcr.io/busybox
    args:
    - /bin/sh
    - <span class="token parameter variable">-c</span>
    - <span class="token function">touch</span> /tmp/healthy<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /tmp/healthy<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">600</span>
    livenessProbe:
      exec:
        command:
        - <span class="token function">cat</span>
        - /tmp/healthy
      initialDelaySeconds: <span class="token number">5</span>
      periodSeconds: <span class="token number">5</span>
</code></pre> 
<p><code>periodSeconds</code> 字段指定了 kubelet 应该每 5 秒执行一次存活探测。 <code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 5 秒。 kubelet 在容器内执行命令 cat <code>/tmp/healthy</code> 来进行探测。 如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的。 如果这个命令返回非 0 值，kubelet 会杀死这个容器并重新启动它。</p> 
<h4><a id="83_TCP__340"></a>8.3 TCP 探测</h4> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
metadata:
  name: goproxy
  labels:
    app: goproxy
spec:
  containers:
  - name: goproxy
    image: k8s.gcr.io/goproxy:0.1
    ports:
    - containerPort: <span class="token number">8080</span>
    readinessProbe:
      tcpSocket:
        port: <span class="token number">8080</span>
      initialDelaySeconds: <span class="token number">5</span>
      periodSeconds: <span class="token number">10</span>
    livenessProbe:
      tcpSocket:
        port: <span class="token number">8080</span>
      initialDelaySeconds: <span class="token number">15</span>
      periodSeconds: <span class="token number">20</span>
</code></pre> 
<p>下面这个例子同时使用就绪和存活探测器。kubelet 会在容器启动 5 秒后发送第一个就绪探测。 这会尝试连接 goproxy 容器的 8080 端口。 如果探测成功，这个 Pod 会被标记为就绪状态，kubelet 将继续每隔 10 秒运行一次检测。</p> 
<p>除了就绪探测，这个配置包括了一个存活探测。 kubelet 会在容器启动 15 秒后进行第一次存活探测。 就像就绪探测一样，会尝试连接 goproxy 容器的 8080 端口。 如果存活探测失败，这个容器会被重新启动。</p> 
<p>参考：</p> 
<ul><li><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="nofollow">配置存活、就绪和启动探测器</a></li><li><a href="https://loft.sh/blog/kubernetes-startup-probes-examples-common-pitfalls/" rel="nofollow">Kubernetes Startup Probes - Examples &amp; Common Pitfalls</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e90c7a56dacdc6c9f7c75eb3165bdde3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Jupyter notebook安装教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47108ff28527e070ccb03bd1a0021cde/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue&#43;Springboot视频压缩&amp;清晰播放的前后端技术实现要点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>