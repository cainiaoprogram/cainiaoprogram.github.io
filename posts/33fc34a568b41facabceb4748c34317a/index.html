<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Spring】Spring AOP 初识及实现原理解析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Spring】Spring AOP 初识及实现原理解析" />
<meta property="og:description" content="博主简介：想进大厂的打工人博主主页：@xyk:所属专栏: JavaEE进阶 目录
文章目录
一、初识AOP
1.1 什么是AOP？
1.2 AOP的组成
1.2.1 切面（Aspect）
1.2.2 切点（Pointcut）
1.2.3 连接点（Join Point）
1.2.4 通知（Advice）
1.3 AOP的使用场景
二、Srping AOP 实现
2.1 添加Spring AOP 依赖
2.2 定义切面和切点
2.3 定义通知
三、Spring AOP 实现原理
3.1 什么是动态代理？
3.2 JDK 动态代理实现
3.3 CGLIB 动态代理实现
3.4 JDK 和 CGLIB 实现的区别
一、初识AOP 1.1 什么是AOP？ AOP（Aspect Oriented Programming）：面向切面编程，它是⼀种思想，它是对某⼀类事情的
集中处理。在我们想要对某一件事情进行集中处理，就可以使用到AOP，它提供一种将程序中的横切关注点模块化的方式。在 AOP 中，我们将这些横切关注点称为“切面”，它们独立于业务逻辑模块，但是可以在程序运行的不同阶段被织入到业务逻辑中。
简单来说，AOP 就是对某一件事进行集中处理的思想方式~
1.2 AOP的组成 1.2.1 切面（Aspect） 切⾯（Aspect）由切点（Pointcut）和通知（Advice）组成，它既包含了横切逻辑的定义，也包
括了连接点的定义。相当于处理某方面具体问题的一个类，包含多个方法，而这些方法就是切点和通知。
1.2.2 切点（Pointcut） Pointcut 的作⽤就是提供⼀组规则来匹配连接点（Join Point），给满足规则的连接点添加通知（Advice），可以理解为用来进行主动拦截的规则（配置）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/33fc34a568b41facabceb4748c34317a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-05T15:03:18+08:00" />
<meta property="article:modified_time" content="2023-08-05T15:03:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Spring】Spring AOP 初识及实现原理解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a id="_0"></a></h2> 
<p style="text-align:center;"><img alt="" height="288" src="https://images2.imgbox.com/d8/de/RTClSBNj_o.png" width="619"></p> 
<blockquote> 
 <ul><li><span style="color:#ed7976;"><strong>博主简介：想进大厂的打工人</strong></span></li><li><span style="color:#98c091;"><strong>博主主页：</strong><a href="https://blog.csdn.net/asad21654864?spm=1000.2115.3001.5343" title="@xyk:">@xyk:</a></span></li><li><strong><span style="color:#79c6cd;">所属专栏: <a href="http://t.csdn.cn/SpyLE" rel="nofollow" title="JavaEE进阶">JavaEE进阶</a></span></strong><span style="color:#79c6cd;"> </span></li></ul> 
</blockquote> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95-toc" style="margin-left:80px;"><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95" rel="nofollow">文章目录</a></p> 
<p id="%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86AOP-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86AOP" rel="nofollow">一、初识AOP</a></p> 
<p id="1.1%20%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.1%20%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9F" rel="nofollow">1.1 什么是AOP？</a></p> 
<p id="1.2%20AOP%E7%9A%84%E7%BB%84%E6%88%90-toc" style="margin-left:40px;"><a href="#1.2%20AOP%E7%9A%84%E7%BB%84%E6%88%90" rel="nofollow">1.2 AOP的组成</a></p> 
<p id="1.2.1%20%E5%88%87%E9%9D%A2%EF%BC%88Aspect%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.2.1%20%E5%88%87%E9%9D%A2%EF%BC%88Aspect%EF%BC%89" rel="nofollow">1.2.1 切面（Aspect）</a></p> 
<p id="1.2.2%20%E5%88%87%E7%82%B9%EF%BC%88Pointcut%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.2.2%20%E5%88%87%E7%82%B9%EF%BC%88Pointcut%EF%BC%89" rel="nofollow">1.2.2 切点（Pointcut）</a></p> 
<p id="1.2.3%C2%A0%E8%BF%9E%E6%8E%A5%E7%82%B9%EF%BC%88Join%20Point%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.2.3%C2%A0%E8%BF%9E%E6%8E%A5%E7%82%B9%EF%BC%88Join%20Point%EF%BC%89" rel="nofollow">1.2.3 连接点（Join Point）</a></p> 
<p id="1.2.4%20%E9%80%9A%E7%9F%A5%EF%BC%88Advice%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.2.4%20%E9%80%9A%E7%9F%A5%EF%BC%88Advice%EF%BC%89" rel="nofollow">1.2.4 通知（Advice）</a></p> 
<p id="1.3%20AOP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#1.3%20AOP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">1.3 AOP的使用场景</a></p> 
<p id="%E4%BA%8C%E3%80%81Srping%20AOP%20%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Srping%20AOP%20%E5%AE%9E%E7%8E%B0" rel="nofollow">二、Srping AOP 实现</a></p> 
<p id="2.1%20%E6%B7%BB%E5%8A%A0Spring%20AOP%20%E4%BE%9D%E8%B5%96-toc" style="margin-left:40px;"><a href="#2.1%20%E6%B7%BB%E5%8A%A0Spring%20AOP%20%E4%BE%9D%E8%B5%96" rel="nofollow">2.1 添加Spring AOP 依赖</a></p> 
<p id="2.2%20%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E5%92%8C%E5%88%87%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.2%20%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E5%92%8C%E5%88%87%E7%82%B9" rel="nofollow">2.2 定义切面和切点</a></p> 
<p id="2.3%20%E5%AE%9A%E4%B9%89%E9%80%9A%E7%9F%A5-toc" style="margin-left:40px;"><a href="#2.3%20%E5%AE%9A%E4%B9%89%E9%80%9A%E7%9F%A5" rel="nofollow">2.3 定义通知</a></p> 
<p id="%E4%B8%89%E3%80%81Spring%20AOP%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81Spring%20AOP%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow">三、Spring AOP 实现原理</a></p> 
<p id="3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F-toc" style="margin-left:40px;"><a href="#3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F" rel="nofollow">3.1 什么是动态代理？</a></p> 
<p id="3.2%20JDK%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#3.2%20JDK%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0" rel="nofollow">3.2 JDK 动态代理实现</a></p> 
<p id="3.3%C2%A0CGLIB%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#3.3%C2%A0CGLIB%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0" rel="nofollow">3.3 CGLIB 动态代理实现</a></p> 
<p id="3.4%C2%A0JDK%20%E5%92%8C%20CGLIB%20%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#3.4%C2%A0JDK%20%E5%92%8C%20CGLIB%20%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">3.4 JDK 和 CGLIB 实现的区别</a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86AOP"><a id="pandas_22"></a>一、初识AOP</h2> 
<h3 id="1.1%20%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9F">1.1 什么是AOP？</h3> 
<p><strong><span style="background-color:#fbd4d0;">AOP（Aspect Oriented Programming）：面向切面编程，它是⼀种思想，它是对某⼀类事情的</span><br><span style="background-color:#fbd4d0;">集中处理。</span></strong>在我们想要对某一件事情进行集中处理，就可以使用到AOP，它提供一种将程序中的横切关注点<a href="https://so.csdn.net/so/search?q=%E6%A8%A1%E5%9D%97%E5%8C%96&amp;spm=1001.2101.3001.7020" title="模块化">模块化</a>的方式。在 AOP 中，我们将这些横切关注点称为“切面”，它们独立于业务逻辑模块，但是可以在程序运行的不同阶段被织入到业务逻辑中。</p> 
<p>简单来说，AOP 就是对某一件事进行集中处理的思想方式~</p> 
<h3 id="1.2%20AOP%E7%9A%84%E7%BB%84%E6%88%90">1.2 AOP的组成</h3> 
<h4 id="1.2.1%20%E5%88%87%E9%9D%A2%EF%BC%88Aspect%EF%BC%89">1.2.1 切面（Aspect）</h4> 
<p>切⾯（Aspect）由切点（Pointcut）和通知（Advice）组成，它既包含了横切逻辑的定义，也包<br> 括了连接点的定义。相当于处理某方面具体问题的一个类，包含多个方法，而这些方法就是切点和通知。</p> 
<h4 id="1.2.2%20%E5%88%87%E7%82%B9%EF%BC%88Pointcut%EF%BC%89">1.2.2 切点（Pointcut）</h4> 
<p>Pointcut 的作⽤就是提供⼀组规则来匹配连接点（Join Point），给满足规则的连接点添加通知（Advice），可以理解为用来进行主动拦截的规则（配置）</p> 
<h4 id="1.2.3%C2%A0%E8%BF%9E%E6%8E%A5%E7%82%B9%EF%BC%88Join%20Point%EF%BC%89">1.2.3 连接点（Join Point）</h4> 
<p>应⽤执⾏过程中能够插⼊切⾯的⼀个点，<strong><span style="color:#FF0000;">连接点可以理解为可能会触发AOP规则的所有点。（所有请求）</span></strong></p> 
<h4 id="1.2.4%20%E9%80%9A%E7%9F%A5%EF%BC%88Advice%EF%BC%89">1.2.4 通知（Advice）</h4> 
<p><span style="color:#4d4d4d;"><span style="background-color:#ffffff;">在AOP术语中，</span></span><strong><span style="color:#FF0000;">切面的工作被称之为通知。</span></strong><span style="color:#4d4d4d;"><span style="background-color:#ffffff;">通知是切面在连接点上执行的动作。它定义了在何时（例如在方法调用之前或之后）以及如何（例如打印日志或进行性能监控）应用切面的行为。即，</span></span><strong><span style="color:#FF0000;">程序中被拦截请求触发的具体动作。</span></strong></p> 
<p>Spring 切⾯类中，可以在方法上使⽤以下注解，会设置⽅法为通知方法，在满⾜条件后会通知本<br> ⽅法进⾏调⽤：</p> 
<ol><li>前置通知使⽤ <span style="color:#fe2c24;">@Before</span>：通知⽅法会在⽬标⽅法调⽤之前执行。</li><li>后置通知使⽤ <span style="color:#fe2c24;">@After</span>：通知⽅法会在⽬标⽅法返回或者抛出异常后调⽤。</li><li>返回之后通知使⽤ <span style="color:#fe2c24;">@AfterReturning</span>：通知⽅法会在⽬标⽅法返回后调⽤。</li><li>抛异常后通知使⽤ <span style="color:#fe2c24;">@AfterThrowing</span>：通知⽅法会在⽬标⽅法抛出异常后调⽤。</li><li>环绕通知使⽤ <span style="color:#fe2c24;">@Around</span>：通知包裹了被通知的⽅法，在被通知的⽅法通知之前和调⽤之后执行⾃定义的行为。</li></ol> 
<h3 id="1.3%20AOP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">1.3 AOP的使用场景</h3> 
<p>在做任何一个系统都需要登录功能，那么几乎想要使用这个系统都需要我们进行验证用户登录状态，我们之前的处理⽅式是每个 Controller 都要写⼀遍⽤户登录验证，然⽽当你的功能越来越多，那么你要写的登录验证也越来越多，⽽这些⽅法⼜是相同的，这么多的⽅法就会代码修改和维护的成本。对于这种功能统⼀，且使⽤的地⽅较多的功能，就可以考虑 AOP来统⼀处理了。</p> 
<p><img alt="" height="370" src="https://images2.imgbox.com/11/a3/WWeo1KKT_o.png" width="737"></p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/9c/16/L2aePwf3_o.png" width="668"> </p> 
<p>除了统一登录判断外，使用AOP还可以实现：</p> 
<ul><li>用户登录验证</li><li>统⼀⽇志记录</li><li>统⼀⽅法执⾏时间统计</li><li>统⼀的返回格式设置</li><li>统⼀的异常处理</li><li>事务的开启和提交等</li></ul> 
<h2 id="%E4%BA%8C%E3%80%81Srping%20AOP%20%E5%AE%9E%E7%8E%B0"><a id="_26"></a>二、Srping AOP 实现</h2> 
<p>Spring AOP 的实现步骤如下：</p> 
<ol><li>添加 Spring AOP 框架⽀持</li><li>定义切⾯和切点：（1）创建切面类（2）配置拦截规则</li><li>定义通知</li></ol> 
<h3 id="2.1%20%E6%B7%BB%E5%8A%A0Spring%20AOP%20%E4%BE%9D%E8%B5%96">2.1 添加Spring AOP 依赖</h3> 
<pre><code class="language-XML">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-bo
ot-starter-aop --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre> 
<h3 id="2.2%20%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E5%92%8C%E5%88%87%E7%82%B9">2.2 定义切面和切点</h3> 
<p>使用<strong><span style="color:#fe2c24;"> <code>@Aspect</code> </span></strong>注解表明当前类为一个切面，而在切点中，我们要定义拦截的规则，具体实现如下：</p> 
<pre><code class="language-java">@Component // 随着框架的启动而启动
@Aspect // 告诉框架我是一个切面类
public class UserAspect {

    // 定义切点(配置拦截规则)
    @Pointcut("execution(* com.example.demo.controller.UserController.*(..))")
    public void pointcut(){

    }
}</code></pre> 
<p>在上述实现代码中，pointcut 为一个空方法，只是起到一个“标识”的作用，标识下面的通知方法具体指的是哪个切点，切点可以有多个。</p> 
<p>切点表达式由切点函数组成，其中 <span style="color:#fe2c24;"><strong><code>execution()</code></strong></span> 是最常⽤的切点函数，⽤来匹配⽅法，语法为：</p> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">execution(&lt;修饰符&gt;&lt;返回类型&gt;&lt;包.类.⽅法(参数)&gt;&lt;异常&gt;)<br> 修饰符和异常可以省略</span></strong></p> 
</blockquote> 
<p><strong>常见的切点表达式的示例：</strong></p> 
<ul><li>匹配特定类的所有方法：</li><li><span style="background-color:#fbd4d0;">execution(* com.example.MyClass.*(..))</span>：匹配 com.example.MyClass 类中的所有方法。</li><li>匹配特定包下的所有方法：</li><li><span style="background-color:#fbd4d0;">execution(* com.example.*.*(..))</span>：匹配 com.example 包及其子包下的所有方法。</li><li>匹配特定方法名的方法：</li><li><span style="background-color:#fbd4d0;">execution(* com.example.MyClass.myMethod(..))</span>：匹配 com.example.MyClass 类中名为 myMethod 的方法。</li><li>匹配特定方法参数类型的方法：</li><li><span style="background-color:#fbd4d0;">execution(* com.example.MyClass.myMethod(String, int))</span>：匹配 com.example.MyClass 类中具有一个 String 参数和一个 int 参数的 myMethod 方法。</li><li>匹配特定返回类型的方法：</li><li><span style="background-color:#fbd4d0;">execution(String com.example.MyClass.myMethod(..))</span>：匹配 com.example.MyClass 类中返回类型为 String 的 myMethod 方法。</li></ul> 
<pre><code class="language-java">package com.example.demo.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/user")
public class UserController {

    @RequestMapping("/hi")
    public String sayHi(String name){
        System.out.println("执行了Hi");
        return "Hi," + name;
    }

    @RequestMapping("/hello")
    public String sayHello(){
        System.out.println("执行了Hello");
        return "Hello,world";
    }
}
</code></pre> 
<h3 id="2.3%20%E5%AE%9A%E4%B9%89%E9%80%9A%E7%9F%A5">2.3 定义通知</h3> 
<p><strong><span style="color:#FF0000;">通知定义的是被拦截方法具体要执行的业务。我们上面列出了可以使用哪些通知~这里举出例子</span></strong></p> 
<pre><code class="language-java">package com.example.demo.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Component // 随着框架的启动而启动
@Aspect // 告诉框架我是一个切面类
public class UserAspect {


    // 定义切点(配置拦截规则)
    @Pointcut("execution(* com.example.demo.controller.UserController.*(..))")
    public void pointcut(){

    }

    @Before("pointcut()")
    public void beforeAdvice(){
        System.out.println("执行了前置通知~");
    }

    @After("pointcut()")
    public void AfterAdvice(){
        System.out.println("执行了后置通知~");
    }

    /**
     * 环绕通知
     * @param joinPoint
     * @return
     */
    @Around("pointcut()")
    public Object aroundAdvice(ProceedingJoinPoint joinPoint){
        System.out.println("进入了环绕通知~");
        Object obj = null;
        try {
        // 执⾏拦截⽅法
            obj = joinPoint.proceed();
        } catch (Throwable e) {
            e.printStackTrace();
        }
        System.out.println("退出了环绕通知~");
        return obj;
    }

}
</code></pre> 
<h3><a id="1_27"></a><code class="language-c"> </code></h3> 
<h3><a id="2_41"></a></h3> 
<p><strong><span style="color:#FF0000;">环绕通知是在前置通知之前和后置通知之后运行的~</span></strong></p> 
<p><img alt="" height="292" src="https://images2.imgbox.com/8e/7f/e9OomyHt_o.png" width="878">   </p> 
<h2 id="%E4%B8%89%E3%80%81Spring%20AOP%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">三、Spring AOP 实现原理</h2> 
<p>Spring AOP 是通过动态代理的⽅式，在运⾏期将 AOP 代码织⼊到程序中的，它的实现⽅式有两种：<strong><span style="color:#fe2c24;"><code>JDK Proxy</code> 和 <code>CGLIB</code>。</span></strong>因此，Spring 对 AOP 的支持局限于方法级别的拦截。</p> 
<ol><li>默认情况下，实现了接⼝的类，使⽤ AOP 会基于 JDK ⽣成代理类</li><li>没有实现接⼝的类，会基于 CGLIB ⽣成代理类<br>  </li></ol> 
<h3 id="3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F">3.1 什么是动态代理？</h3> 
<p>动态代理（Dynamic Proxy）是一种设计模式，它允许 在运行时创建代理对象，并将方法调用转发给实际的对象。 动态代理可以用于实现横切关注点（如日志记录、性能监控、事务管理等）的功能，而无需修改原始对象的代码。</p> 
<p>在Java中，动态代理通常使用 <span style="background-color:#fbd4d0;">java.lang.reflect.Proxy </span>类和<span style="background-color:#fbd4d0;"> java.lang.reflect.InvocationHandler</span> 接口来实现。</p> 
<p><strong><span style="color:#fe2c24;">调用者在调用方法时，会先转发给代理类创建的代理对象，随后再由代理对象转发给目标对象。</span></strong></p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/5b/cb/11IJwZ9I_o.png" width="1200"></p> 
<p><strong>以下是使用动态代理的一般步骤：</strong></p> 
<ol><li>创建一个实现InvocationHandler接口的类，该类将作为代理对象的调用处理程序。在InvocationHandler接口的invoke方法中，可以定义在方法调用前后执行的逻辑。</li><li>使用Proxy类的newProxyInstance方法创建代理对象。该方法接受三个参数：类加载器、代理接口数组和调用处理程序。它将返回一个实现指定接口的代理对象。</li><li>使用代理对象调用方法。当调用代理对象的方法时，实际上会调用调用处理程序的invoke方法，并将方法调用转发给实际的对象。<br>  </li></ol> 
<h3 id="3.2%20JDK%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0">3.2 JDK 动态代理实现</h3> 
<p>先通过实现 <strong>InvocationHandler</strong> 接⼝创建⽅法调⽤处理器，再通过 <strong>Proxy </strong>来创建代理类。</p> 
<pre><code class="language-java">import org.example.demo.service.AliPayService;
import org.example.demo.service.PayService;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
//动态代理：使⽤JDK提供的api（InvocationHandler、Proxy实现），此种⽅式实现，要求被代理类必须实现接⼝
public class PayServiceJDKInvocationHandler implements InvocationHandler {
    //⽬标对象即就是被代理对象
    private Object target;
    public PayServiceJDKInvocationHandler( Object target) {
        this.target = target;
    }
    //proxy代理对象
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    //1.安全检查
        System.out.println("安全检查");
    //2.记录⽇志
        System.out.println("记录⽇志");
    //3.时间统计开始
        System.out.println("记录开始时间");
    //通过反射调⽤被代理类的⽅法
        Object retVal = method.invoke(target, args);
    //4.时间统计结束
        System.out.println("记录结束时间");
        return retVal;
    }
    public static void main(String[] args) {
        PayService target= new AliPayService();
    //⽅法调⽤处理器
        InvocationHandler handler =
                new PayServiceJDKInvocationHandler(target);
    //创建⼀个代理类：通过被代理类、被代理实现的接⼝、⽅法调⽤处理器来创建
        PayService proxy = (PayService) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                new Class[]{PayService.class},
                handler
        );
        proxy.pay();
    }
}</code></pre> 
<h3 id="3.3%C2%A0CGLIB%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0">3.3 CGLIB 动态代理实现</h3> 
<pre><code class="language-java">import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;
import org.example.demo.service.AliPayService;
import org.example.demo.service.PayService;
import java.lang.reflect.Method;

public class PayServiceCGLIBInterceptor implements MethodInterceptor {
    //被代理对象
    private Object target;
    public PayServiceCGLIBInterceptor(Object target){
        this.target = target;
    }
    @Override
    public Object intercept(Object o, Method method, Object[] args, Method
            Proxy methodProxy) throws Throwable {
//1.安全检查
        System.out.println("安全检查");
//2.记录⽇志
        System.out.println("记录⽇志");
//3.时间统计开始
        System.out.println("记录开始时间");
//通过cglib的代理⽅法调⽤
        Object retVal = methodProxy.invoke(target, args);
//4.时间统计结束
        System.out.println("记录结束时间");
        return retVal;
    }
    public static void main(String[] args) {
        PayService target= new AliPayService();
        PayService proxy= (PayService) Enhancer.create(target.getClass(),n
                ew PayServiceCGLIBInterceptor(target));
        proxy.pay();
    }
}</code></pre> 
<h3 id="3.4%C2%A0JDK%20%E5%92%8C%20CGLIB%20%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB">3.4 <strong>JDK 和 CGLIB 实现的区别</strong></h3> 
<ol><li><strong><span style="color:#fe2c24;">JDK 实现，要求被代理类必须实现接口</span></strong>， 之后是通过 InvocationHandler 及 Proxy，在运⾏时动态的在内存中⽣成了代理类对象，该代理对象是通过实现同样的接⼝实现（类似静态代理接⼝实现的⽅式），只是该代理类是在运⾏期时，动态的织⼊统⼀的业务逻辑字节码来完成。</li><li><strong><span style="color:#fe2c24;">CGLIB 实现，被代理类可以不实现接口</span></strong>， 是通过继承被代理类，在运⾏时动态的⽣成代理类对象。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f515bc1d9928f21c205d14d5c67abdff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">BI技巧丨利用OFFSET计算同环比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6114f40d2aadd1c500cae1833bc2290e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue 项目 实现阻止浏览器记住密码功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>