<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实现 App 自动检测更新（Vue3 &#43; Ionic &#43; Cordova &#43; Capacitor） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="实现 App 自动检测更新（Vue3 &#43; Ionic &#43; Cordova &#43; Capacitor）" />
<meta property="og:description" content="目录
一. 实现 App 自动检测更新的原理
1. 效果
2. 原理
二. 实现 App 自动检测更新的实践
1. 需要安装的插件
1.1 capacitor
1.2 cordova
2. 封装 app-update-main.ts（应用检查更新 - 入口）
2.1 定义应用信息的全局变量
2.2 获取服务器上最新的应用信息
2.3 获取当前设备信息
2.4 获取当前应用信息
2.5 处理版本号
2.6 根据全局信息、当前平台，判断是否更新及所需方法
2.7 添加 询问用户是否更新 的提示框
3. 封装 app-update-auxiliary.ts（应用检查更新 - 辅助）
3.1 根据文件名，判断文件媒体类型
3.2 获取 存放下载文件 的基本路径
3.3 添加下载 安装包（.apk） 的方法
3.4 计算文件下载进度
3.5 添加下载进度提示框
3.6 添加文件是否打开的提示框
3.7 添加打开 安装包（.apk）的方法
4. App 自动检查更新 方法执行的位置
一. 实现 App 自动检测更新的原理 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/74253fd101f03b4b6cf8dcf911e62ea7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-19T21:39:36+08:00" />
<meta property="article:modified_time" content="2022-02-19T21:39:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实现 App 自动检测更新（Vue3 &#43; Ionic &#43; Cordova &#43; Capacitor）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc-toc" style="margin-left:0px;"><a href="#main-toc" rel="nofollow">一. 实现 App 自动检测更新的原理</a></p> 
<p id="1.%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA-toc" style="margin-left:40px;"><a href="#1.%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" rel="nofollow">1. 效果</a></p> 
<p id="2.%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#2.%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" rel="nofollow">2. 原理</a></p> 
<p id="%E4%BA%8C.%20app%20%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AE%9E%E8%B7%B5-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%20app%20%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AE%9E%E8%B7%B5" rel="nofollow">二. 实现 App 自动检测更新的实践</a></p> 
<p id="1.%20%E6%89%80%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%81%E6%B6%89%E5%8F%8A%E7%9A%84%E6%8F%92%E4%BB%B6-toc" style="margin-left:40px;"><a href="#1.%20%E6%89%80%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%81%E6%B6%89%E5%8F%8A%E7%9A%84%E6%8F%92%E4%BB%B6" rel="nofollow">1. 需要安装的插件</a></p> 
<p id="1.1%20capacitor-toc" style="margin-left:80px;"><a href="#1.1%20capacitor" rel="nofollow">1.1 capacitor</a></p> 
<p id="1.2%20cordova-toc" style="margin-left:80px;"><a href="#1.2%20cordova" rel="nofollow">1.2 cordova</a></p> 
<p id="2.%20%E5%B0%81%E8%A3%85%20app-update.ts-toc" style="margin-left:40px;"><a href="#2.%20%E5%B0%81%E8%A3%85%20app-update.ts" rel="nofollow">2. 封装 app-update-main.ts（应用检查更新 - 入口）</a></p> 
<p id="2.1%20%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#2.1%20%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" rel="nofollow">2.1 定义应用信息的全局变量</a></p> 
<p id="2.2%20%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%9C%80%E6%96%B0%E7%9A%84%E5%BA%94%E7%94%A8%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#2.2%20%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%9C%80%E6%96%B0%E7%9A%84%E5%BA%94%E7%94%A8%E4%BF%A1%E6%81%AF" rel="nofollow">2.2 获取服务器上最新的应用信息</a></p> 
<p id="2.3%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#2.3%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF" rel="nofollow">2.3 获取当前设备信息</a></p> 
<p id="2.4%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#2.4%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E4%BF%A1%E6%81%AF" rel="nofollow">2.4 获取当前应用信息</a></p> 
<p id="2.5%20%E5%A4%84%E7%90%86%E7%89%88%E6%9C%AC%E5%8F%B7-toc" style="margin-left:80px;"><a href="#2.5%20%E5%A4%84%E7%90%86%E7%89%88%E6%9C%AC%E5%8F%B7" rel="nofollow">2.5 处理版本号</a></p> 
<p id="2.6%20%E6%A0%B9%E6%8D%AE%E5%85%A8%E5%B1%80%E4%BF%A1%E6%81%AF%E3%80%81%E5%BD%93%E5%89%8D%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E5%8F%8A%E6%89%80%E9%9C%80%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.6%20%E6%A0%B9%E6%8D%AE%E5%85%A8%E5%B1%80%E4%BF%A1%E6%81%AF%E3%80%81%E5%BD%93%E5%89%8D%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E5%8F%8A%E6%89%80%E9%9C%80%E6%96%B9%E6%B3%95" rel="nofollow">2.6 根据全局信息、当前平台，判断是否更新及所需方法</a></p> 
<p id="2.7%20%E6%B7%BB%E5%8A%A0%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E7%9A%84%E6%8F%90%E7%A4%BA%E6%A1%86-toc" style="margin-left:80px;"><a href="#2.7%20%E6%B7%BB%E5%8A%A0%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E7%9A%84%E6%8F%90%E7%A4%BA%E6%A1%86" rel="nofollow">2.7 添加 询问用户是否更新 的提示框</a></p> 
<p id="3.%20%E5%B0%81%E8%A3%85%20apk-file-transfer.ts-toc" style="margin-left:40px;"><a href="#3.%20%E5%B0%81%E8%A3%85%20apk-file-transfer.ts" rel="nofollow">3. 封装 app-update-auxiliary.ts（应用检查更新 - 辅助）</a></p> 
<p id="3.1%20%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%8C%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#3.1%20%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%8C%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B" rel="nofollow">3.1 根据文件名，判断文件媒体类型</a></p> 
<p id="3.2%20%E8%8E%B7%E5%8F%96%E5%AD%98%E6%94%BE%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84-toc" style="margin-left:80px;"><a href="#3.2%20%E8%8E%B7%E5%8F%96%E5%AD%98%E6%94%BE%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84" rel="nofollow">3.2 获取 存放下载文件 的基本路径</a></p> 
<p id="3.3%20%E6%B7%BB%E5%8A%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#3.3%20%E6%B7%BB%E5%8A%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">3.3 添加下载 安装包（.apk） 的方法</a></p> 
<p id="3.4%20%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E8%BF%9B%E5%BA%A6-toc" style="margin-left:80px;"><a href="#3.4%20%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E8%BF%9B%E5%BA%A6" rel="nofollow">3.4 计算文件下载进度</a></p> 
<p id="3.5%20%E6%B7%BB%E5%8A%A0%E4%B8%8B%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%8F%90%E7%A4%BA%E6%A1%86-toc" style="margin-left:80px;"><a href="#3.5%20%E6%B7%BB%E5%8A%A0%E4%B8%8B%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%8F%90%E7%A4%BA%E6%A1%86" rel="nofollow">3.5 添加下载进度提示框</a></p> 
<p id="3.6%20%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E6%89%93%E5%BC%80%E7%9A%84%E6%8F%90%E7%A4%BA%E6%A1%86-toc" style="margin-left:80px;"><a href="#3.6%20%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E6%89%93%E5%BC%80%E7%9A%84%E6%8F%90%E7%A4%BA%E6%A1%86" rel="nofollow">3.6 添加文件是否打开的提示框</a></p> 
<p id="3.7%20%E6%B7%BB%E5%8A%A0%E6%89%93%E5%BC%80%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#3.7%20%E6%B7%BB%E5%8A%A0%E6%89%93%E5%BC%80%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">3.7 添加打开 安装包（.apk）的方法</a></p> 
<p id="4.%20%E8%B0%83%E7%94%A8%20app%20%E6%A3%80%E6%9F%A5%E6%9B%B4%E6%96%B0%E7%9A%84%E4%BD%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#4.%20%E8%B0%83%E7%94%A8%20app%20%E6%A3%80%E6%9F%A5%E6%9B%B4%E6%96%B0%E7%9A%84%E4%BD%8D%E7%BD%AE" rel="nofollow">4. App 自动检查更新 方法执行的位置</a></p> 
<hr id="hr-toc"> 
<h2>一. 实现 App 自动检测更新的原理</h2> 
<h3 id="1.%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA">1. 效果</h3> 
<p>自动检测更新的场景：</p> 
<ul><li>App 打开时，自动检测更新</li><li>在设置中，点击版本号时，自动检测更新</li></ul> 
<p><img alt="" height="727" src="https://images2.imgbox.com/e7/f8/Y1aKFQIk_o.png" width="1200"></p> 
<h3 id="2.%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">2. 原理</h3> 
<ul><li>检查当前应用信息（获取当前版本号、设备平台信息等等）</li><li>获取服务器应用信息（获取服务器最新版本号、下载地址等）</li><li>判断是否更新及如何更新（判断用户是否更新、判断需要下载的包、是否立即安装等）</li></ul> 
<p></p> 
<p>接口返回服务器上存储的应用信息示例（此处用 Rap2 模拟接口）：</p> 
<pre><code>{
  "data": {
    // Android 最新应用下载地址
    "androidUrl": "https://www.xxx.com.cn/Android/others/tongfu/tongfu-prod.apk",
    // Android 包名
    "apkName": "baoan.apk",
    // ios 最新应用下载地址
    "iosUrl": "itms-services://?action=download-manifest&amp;url=https://www.xxx.com.cn/iOS/others/tongfu/tongfu-prod.plist",
    // Android 最新应用版本号
    "verAndroid": "1.0.6",
    // ios 最新应用版本号
    "verIos": "1.0.6"
  }
}</code></pre> 
<h3></h3> 
<h2 id="%E4%BA%8C.%20app%20%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AE%9E%E8%B7%B5">二. 实现 App 自动检测更新的实践</h2> 
<h3 id="1.%20%E6%89%80%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%81%E6%B6%89%E5%8F%8A%E7%9A%84%E6%8F%92%E4%BB%B6">1. 需要安装的插件</h3> 
<h4 id="1.1%20capacitor">1.1 capacitor</h4> 
<blockquote> 
 <p>// @capacitor/app<br> npm install @capacitor/app<br> npx cap sync</p> 
 <p>// @capacitor/device<br> npm install @capacitor/device<br> npx cap sync</p> 
</blockquote> 
<h4 id="1.2%20cordova">1.2 cordova</h4> 
<blockquote> 
 <p>// File<br> npm install cordova-plugin-file<br> npm install @ionic-native/file<br> ionic cap sync</p> 
 <p>// File Transfer<br> npm install cordova-plugin-file-transfer<br> npm install @ionic-native/file-transfer<br> ionic cap sync</p> 
 <p>// File Opener<br> npm install cordova-plugin-file-opener2<br> npm install @ionic-native/file-opener<br> ionic cap sync</p> 
</blockquote> 
<h3></h3> 
<h3 id="2.%20%E5%B0%81%E8%A3%85%20app-update.ts">2. 封装 app-update-main.ts（应用检查更新 - 入口）</h3> 
<p><span style="color:#fe2c24;"><strong>此文件包含了 获取服务器 apk信息、获取当前 apk信息、判断是否执行 apk更新的相关方法</strong></span></p> 
<h4 id="2.1%20%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">2.1 定义应用信息的全局变量</h4> 
<p>用 <span style="color:#fe2c24;"><strong>const</strong></span> 定义 全局变量，否则 ts 会报错（比如使用 let）</p> 
<pre><code>// 全局变量 - 应用信息（默认）- 需要使用 const定义，否则会报错
const appInfomation = {
  currentPlatform: '', // 当前平台
  currentVersion: '', // 当前app版本
  serverAndroidVersion: '', // 服务器最新app版本 - Android
  serverAndroidAppUpdateUrl: '', // 服务器最新app下载地址 - Android
  serverIosVersion: '', // 服务器最新app版本 - IOS
  serverIosAppUpdateUrl: '', // 服务器最新app下载地址 - IOS
  apkName: '', // 服务器android安装包的名字
};</code></pre> 
<h4 id="2.2%20%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%9C%80%E6%96%B0%E7%9A%84%E5%BA%94%E7%94%A8%E4%BF%A1%E6%81%AF">2.2 获取服务器上最新的应用信息</h4> 
<p>此处省略了 获取服务器信息的 接口调用 过程，仅展示获取接口数据后，应该将 2.1 中的变量填充上什么信息</p> 
<pre><code>  // 获取服务器上的应用信息
  const serverAppInfo = await getServerAppInfo();
  console.log("获取服务器上的应用信息", serverAppInfo);

  // 服务器上的安卓应用版本
  appInfomation.serverAndroidVersion = serverAppInfo.data.verAndroid; 
  // 服务器上的安卓应用下载地址
  appInfomation.serverAndroidAppUpdateUrl = serverAppInfo.data.androidUrl; 
  // 服务器上的苹果应用版本
  appInfomation.serverIosVersion = serverAppInfo.data.verIos; 
  // 服务器上的苹果应用下载地址
  appInfomation.serverIosAppUpdateUrl = serverAppInfo.data.iosUrl; 
  // 服务器上的应用下载名
  appInfomation.apkName = serverAppInfo.data.apkName; </code></pre> 
<h4 id="2.3%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF">2.3 获取当前设备信息</h4> 
<p>需要获取设备信息的原因：</p> 
<ul><li>Android / Ios 的下载路径、安装过程等，都不太相同，需要根据设备平台进行定制</li></ul> 
<p>此处采用 capacitor 中的 <span style="color:#fe2c24;"><strong>Device插件</strong></span>，它可以返回当前设备平台是 android 还是 ios</p> 
<ul><li><img alt="" height="254" src="https://images2.imgbox.com/18/a1/QXBvrNL2_o.png" width="409"></li></ul> 
<pre><code>import { Device } from '@capacitor/device';

/**
 * 获取当前的设备所属平台
 */
const getDeviceInfo = async (): Promise&lt;string&gt; =&gt; {
  const info = await Device.getInfo();
  return info.platform;
};

  // 填充全局变量 - 应用信息
  appInfomation.currentPlatform = nowPlatform; // 当前设备平台</code></pre> 
<h4 id="2.4%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E4%BF%A1%E6%81%AF">2.4 获取当前应用信息</h4> 
<p>需要获取当前应用信息的原因：</p> 
<ul><li>是为了获取版本号，与服务器上最新的版本号进行对比，看看是否需要更新</li></ul> 
<p>此处使用 capacitor 中的 <span style="color:#fe2c24;"><strong>App插件</strong></span>，它可以返回当前应用的版本号</p> 
<ul><li><img alt="" height="106" src="https://images2.imgbox.com/8a/15/6SVrNots_o.png" width="367"></li></ul> 
<pre><code>/**
 * 获取用户当前正在使用的app版本
 */
async function getCurrentAppInfo(): Promise&lt;any&gt; {
  // 调用获取应用信息的API
  const appInfo: AppInfo = await App.getInfo();
  return appInfo;
}

// 填充全局变量 - 应用信息
appInfomation.currentVersion = currentAppInfo.version; // 当前应用版本号</code></pre> 
<h4 id="2.5%20%E5%A4%84%E7%90%86%E7%89%88%E6%9C%AC%E5%8F%B7">2.5 处理版本号</h4> 
<p>需要 处理版本号 的原因：</p> 
<ul><li>为了方便比较 当前应用版本号 和 服务器最新版本号</li></ul> 
<p>处理版本号的方法：</p> 
<ul><li>将版本号中的 . （1.0.0）替换成 0，这样就能直接比较 1.0.0 和 1.0.6 了</li></ul> 
<pre><code>/**
 * 处理版本号(1.0.0处理为10000)
 * @param num 版本号
 */
function handleVersion(num: string): number {
    console.log('处理后的版本号', num.split('.').join('0'));
    return Number(num.split('.').join('0'));
}</code></pre> 
<h4 id="2.6%20%E6%A0%B9%E6%8D%AE%E5%85%A8%E5%B1%80%E4%BF%A1%E6%81%AF%E3%80%81%E5%BD%93%E5%89%8D%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E5%8F%8A%E6%89%80%E9%9C%80%E6%96%B9%E6%B3%95">2.6 根据全局信息、当前平台，判断是否更新及所需方法</h4> 
<ul><li><strong><span style="color:#fe2c24;">如果是安卓平台更新，则需要传递服务器上的 apk包名，而 ios 不需要</span></strong></li><li>是否更新，就是对比处理过的版本号，如果不一致，就更新</li></ul> 
<pre><code>  if (appInfomation) {
    if (appInfomation.currentPlatform === 'android') {
      updateApp(appInfomation.currentVersion, appInfomation.serverAndroidVersion, appInfomation.serverAndroidAppUpdateUrl, appInfomation.currentPlatform, appInfomation.apkName);
    } else if (appInfomation.currentPlatform === 'ios') {
      updateApp(appInfomation.currentVersion, appInfomation.serverIosVersion, appInfomation.serverIosAppUpdateUrl, appInfomation.currentPlatform);
    } else {
      console.log('获取版本信息失败!');
    }
  }

/**
 * 判断是否进行更新，判断使用哪种平台提示
 * @param currentVersion 当前应用版本
 * @param serverVersion 服务器上的应用版本
 * @param serverAppUpdateUrl 服务器上的应用下载地址
 * @param currentPlatform 当前设备平台
 * @param apkName 服务器上 android 安装包的名字【可选】
 */
export function updateApp(currentVersion: string, serverVersion: string, serverAppUpdateUrl: string, currentPlatform: string, apkName?: string) {
  // 是否更新
  let ifUpdate = false;
  if (currentVersion &amp;&amp; serverVersion) {
    ifUpdate = handleVersion(currentVersion) &lt; handleVersion(serverVersion);
  }
  // 如果需要进行更新
  if (ifUpdate) {
    // this.platform.ready().then(() =&gt; {
    if (currentPlatform === 'android') {
      // 触发 Anroid 平台的提示
      presentAlert(currentVersion, serverVersion, serverAppUpdateUrl, currentPlatform, apkName);
    } else {
      // 触发 Ios 平台的提示
      presentAlert(currentVersion, serverVersion, serverAppUpdateUrl, currentPlatform);
    }
  }
}</code></pre> 
<h4 id="2.7%20%E6%B7%BB%E5%8A%A0%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E7%9A%84%E6%8F%90%E7%A4%BA%E6%A1%86">2.7 添加 询问用户是否更新 的提示框</h4> 
<p>提示框使用 Ionic 提供的<span style="color:#fe2c24;"><strong> alertController </strong></span></p> 
<p>提示框处理逻辑如下：</p> 
<ul><li>下载app 及 自动打开app 的方法，需要根据 <span style="color:#fe2c24;"><strong>平台</strong></span> 及是否包含 <span style="color:#fe2c24;"><strong>apk包名</strong></span> 进行判断传参</li><li>如果是更新安卓应用，是必须要使用 <span style="color:#fe2c24;"><strong>apkName</strong></span> 的哦</li></ul> 
<pre><code>import { alertController } from '@ionic/vue';
import { apkDownloadAndOpen } from '@/utils/apk-file-transfer'

/**
 * 更新提示、判断执行下载安装包的方法
 * @param currentVersion 当前应用版本
 * @param serverVersion 服务器上的应用版本
 * @param serverAppUpdateUrl 服务器上的应用下载地址
 * @param currentPlatform 当前设备平台
 * @param apkName 服务器上 android 安装包的名字【可选】
 */
async function presentAlert(currentVersion: string, serverVersion: string, serverAppUpdateUrl: string, currentPlatform: string, apkName?: string) {
  const alert = await alertController.create({
    header: '发现新版本, 是否更新?',
    cssClass: 'update-pop',
    message: '&lt;div class="versions"&gt;当前版本号：' + currentVersion + '&lt;/div&gt;&lt;div class="versions"&gt;待更新版本号：' + serverVersion + '&lt;/div&gt;',
    buttons: [
      {
        text: '取消',
        handler: () =&gt; {
          console.log('用户暂不更新应用');
        }
      },
      {
        text: '立即更新',
        handler: () =&gt; {
          if (currentPlatform === 'android' &amp;&amp; apkName) {
            // 下载app
            console.log('准备执行 android 下载')
            // window.open('serverAppUpdateUrl')
            apkDownloadAndOpen(serverAppUpdateUrl, apkName, currentPlatform, false, false);
            // this.fileTransferService.downloadFile(serverAppUpdateUrl, apkName, false, true);
          } else {
            console.log('准备执行 ios/web 下载')
            // // this.browser.create(serverAppUpdateUrl);
            // this.browser.create(serverAppUpdateUrl, '_system', { usewkwebview: 'no' });
          }
        }
      }
    ],
  });
  alert.present();
}</code></pre> 
<h3></h3> 
<h3 id="3.%20%E5%B0%81%E8%A3%85%20apk-file-transfer.ts">3. 封装 app-update-auxiliary.ts（应用检查更新 - 辅助）</h3> 
<p><span style="color:#fe2c24;"><strong>此文件包含了 apk下载、计算下载进度、下载完成后打开apk文件的相关方法</strong></span></p> 
<h4 id="3.1%20%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%8C%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B">3.1 根据文件名，判断文件媒体类型</h4> 
<p>所谓文件名，就是之前传的 apkName（形如 baoan.apk，要根据这个后缀，判断文件媒体类型）</p> 
<pre><code>/**
 * 根据文件名称获取文件媒体类型
 * @param fileName 文件名称
 */
export function getFileMimeType(fileName: string) {
  // 文件名后缀
  const fileSuffix = getFileSuffix(fileName);
  // 文件类型
  let mimeType = '';
  switch (fileSuffix) {
    case 'txt':
      mimeType = 'text/plain';
      break;
    case 'docx':
      mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
      break;
    case 'doc':
      mimeType = 'application/msword';
      break;
    case 'pptx':
      mimeType = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
      break;
    case 'ppt':
      mimeType = 'application/vnd.ms-powerpoint';
      break;
    case 'xlsx':
      mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
      break;
    case 'xls':
      mimeType = 'application/vnd.ms-excel';
      break;
    case 'zip':
      mimeType = 'application/x-zip-compressed';
      break;
    case 'rar':
      mimeType = 'application/octet-stream';
      break;
    case 'pdf':
      mimeType = 'application/pdf';
      break;
    case 'jpg':
      mimeType = 'image/jpeg';
      break;
    case 'png':
      mimeType = 'image/png';
      break;
    case 'apk':
      mimeType = 'application/vnd.android.package-archive';
      break;
    default:
      mimeType = 'application/' + fileSuffix;
      break;
  }
  return mimeType;
}</code></pre> 
<h4 id="3.2%20%E8%8E%B7%E5%8F%96%E5%AD%98%E6%94%BE%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84">3.2 获取 存放下载文件 的基本路径</h4> 
<p>Android 和 Ios 存放文件的基本路径是不一样的</p> 
<ul><li>以 Android 为例，像这样：file:///storage/emulated/0/Android/data/io.ionic.starter/files/tongfu.apk</li><li><span style="color:#fe2c24;"><strong>注意：路径是带 .apk 的</strong></span></li></ul> 
<p>获取基本路径需要通过 cordova 插件 —— <span style="color:#fe2c24;"><strong>File</strong></span></p> 
<ul><li>注意：TypeScript 语法中，获取 cordova 提供的全局变量，需这样获取：<span style="color:#fe2c24;"><strong>(window as any).cordova.file</strong></span></li></ul> 
<pre><code>/**
 * 获取存放文件的基础路径 android/ios
 * @param currentPlatform 当前平台
 */
export function getFileBasePath(currentPlatform: string) {
  let baseUrl = ''
  if (currentPlatform === 'android') {
    baseUrl = (window as any).cordova.file.externalDataDirectory;
    // baseUrl = 'files';
  } else if (currentPlatform === 'ios') {
    baseUrl = (window as any).cordova.file.dataDirectory;
    // baseUrl = 'NoCloud/';
  } else {
    return '';
  }
  return baseUrl;
}

  // 获取存放文件的基础路径 - 最后拼出来的路径是带 .apk 的
  const filePath = getFileBasePath(currentPlatform) + fileName;</code></pre> 
<h4 id="3.3%20%E6%B7%BB%E5%8A%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95">3.3 添加下载 安装包（.apk） 的方法</h4> 
<p>下载安装包（.apk）需要通过 cordova 插件 ——<span style="color:#fe2c24;"><strong> FileTransfer</strong></span></p> 
<ul><li>传入的下载路径，需要特殊编码 const url = <strong><span style="color:#fe2c24;">encodeURI</span></strong>(serverUrl);</li><li>实例化 FileTransfer 时，得这么写：<span style="color:#fe2c24;"><strong>const fileTransfer = new (window as any).FileTransfer();</strong></span></li></ul> 
<p>下载时，报错代码（Code3）：</p> 
<ul><li>理论上来讲，这是 连接失败 的报错</li><li>在 Android Studio 中的 <span style="color:#fe2c24;"><strong>插件源码部分</strong></span> 打断点调试，发现在 判定白名单 这块逻辑中报错了，下载路径不在应用白名单里，无法下载</li><li>因此，我把 FileTransfer 插件源码中，判断白名单的逻辑块 给注释了（...）</li></ul> 
<p><img alt="" height="367" src="https://images2.imgbox.com/5b/b2/mNY1MAjP_o.png" width="1200"></p> 
<pre><code>/**
 * 下载文件
 * @param fileTransfer 当前文件传输对象
 * @param url 下载地址
 * @param filePath 文件下载后的本地存放路径
 * @param mimeType 文件媒体类型
 */
export function fileDownload(fileTransfer: any, url: any, filePath: string, mimeType: string): any {
  fileTransfer.download(url, filePath, function(entry: any) {
    console.log("下载完成，文件位于: " + entry.toURL());
    // 关闭下载进度提示框
    closeProgressPop();
    // 打开询问用户是否打开刚下载的应用的提示框
    openFilePop(filePath, mimeType, '应用下载完成，是否立即更新？');
  }, function (err: any) {
    console.log('下载失败，报错信息：', err)
  }, true)
}</code></pre> 
<h4 id="3.4%20%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E8%BF%9B%E5%BA%A6">3.4 计算文件下载进度</h4> 
<p>计算文件下载进度 需要通过 cordova 插件 ——<span style="color:#fe2c24;"><strong> FileTransfer 中的 onprogress 属性</strong></span></p> 
<p>踩坑记录：</p> 
<ul><li>最好按照官网的写法来，比如 onprogress 直接 = function() {}，千万别写 () =&gt; {} 这种回调函数，可能会因此报错，最好参数也别改【0.0】</li></ul> 
<p>计算文件下载进度方法，添加在：</p> 
<ul><li>FileTransfer.download() 执行之前，new FileTransfer() 初始化之后</li></ul> 
<pre><code>/**
 * 计算文件下载进度
 */
export function calProgress(fileTransfer: any) {
  // 下载进度
  let progressValue = 0;
  // 计算下载进度，不可以用回调，会失去效果
  fileTransfer.onprogress = function(progressEvent: any) {
    if (progressEvent.lengthComputable) {
        progressValue = progressEvent.loaded / progressEvent.total;
    } else {
        progressValue++;
    }
    // 将 0.01321... 这种下载进度转换为整数
    const showNumber = Math.floor(progressValue * 100);
    // 填充已下载文字提示信息
    document.getElementsByClassName('downed')[0].innerHTML = `已完成：${showNumber}%`;
    // 填充进度条外框样式 - style会失效，因此在此处修改
    document.getElementsByClassName('progress')[0]['style'].width = '100%';
    document.getElementsByClassName('progress')[0]['style'].height = '4px';
    document.getElementsByClassName('progress')[0]['style'].background = '#eee';
    // 填充进度条进度样式 - style会失效，因此在此处修改
    document.getElementsByClassName('blue')[0]['style'].display = 'block';
    document.getElementsByClassName('blue')[0]['style'].width = `${showNumber}%`;
    document.getElementsByClassName('blue')[0]['style'].height = '100%';
    document.getElementsByClassName('blue')[0]['style'].background = '#1890ff';
  };
}</code></pre> 
<h4 id="3.5%20%E6%B7%BB%E5%8A%A0%E4%B8%8B%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%8F%90%E7%A4%BA%E6%A1%86">3.5 添加下载进度提示框</h4> 
<p>此进度框最好写在 <span style="color:#fe2c24;"><strong>全局变量</strong></span> 里，因为用他的地方比较杂，如下：</p> 
<ul><li>在 执行下载 / 计算进度 之前，需要创造一个下载进度提示框，也就是执行 createProgressPop();</li><li>在下载完成（成功）之后，需要关闭这个提示框，也就是执行 closeProgressPop();</li></ul> 
<pre><code>// 下载进度框
let alertPop: any;

/**
 * 初始化下载进度框
 */
export async function createProgressPop() {
  alertPop = await alertController.create({
    message: '&lt;p class="title"&gt;正在下载更新，请稍等...&lt;/p&gt;&lt;div class="progress"&gt;&lt;span class="blue"&gt;&lt;/span&gt;&lt;/div&gt;&lt;p class="downed"&gt;已完成：0%&lt;/p&gt;',
    backdropDismiss: false
  });
  await alertPop.present();
}

/**
 * 关闭下载进度框
 */
export function closeProgressPop() {
  if (alertPop) {
    alertPop.dismiss();
    alertPop = null;
  }
}</code></pre> 
<h4 id="3.6%20%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E6%89%93%E5%BC%80%E7%9A%84%E6%8F%90%E7%A4%BA%E6%A1%86">3.6 添加文件是否打开的提示框</h4> 
<p>显而易见，这个方法在下载成功之后执行</p> 
<pre><code>/**
 * 询问是否打开文件的提示框
 * @param filePath 文件本地路径
 * @param fileMimeType 文件媒体类型
 * @param msg 询问文本
 */
export async function openFilePop(filePath: string, fileMimeType: string, msg = '是否直接打开文件？') {
  const alert = await alertController.create({
    message: msg,
    buttons: [
      {
        text: '取消',
        role: 'cancel',
        handler: () =&gt; {
          console.log('用户暂不打开文件');
        }
      }, {
        text: '打开',
        handler: () =&gt; {
          // 打开文件
          openFile(filePath, fileMimeType);
        }
      }
    ]
  });
  await alert.present();
}</code></pre> 
<h4 id="3.7%20%E6%B7%BB%E5%8A%A0%E6%89%93%E5%BC%80%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95">3.7 添加打开 安装包（.apk）的方法</h4> 
<p>打开文件 需要通过 cordova 插件 ——<span style="color:#fe2c24;"><strong> FileOpen2</strong></span></p> 
<ul><li>此插件的 打开文件方法，需要传入的参数是：需要打开的文件路径、需要打开的文件媒体类型</li></ul> 
<pre><code>/**
 * 打开文件
 * @param filePath 文件本地路径
 * @param fileMimeType 文件媒体类型
 */
 export function openFile(filePath: string, fileMimeType: string) {
  (window as any).cordova.plugins.fileOpener2.open(filePath, fileMimeType).then(
    () =&gt; {
      console.log('文件打开成功！');
    }).catch(() =&gt; {
      alert('文件打开失败，请重试!');
    }
  );
}</code></pre> 
<p></p> 
<h3 id="4.%20%E8%B0%83%E7%94%A8%20app%20%E6%A3%80%E6%9F%A5%E6%9B%B4%E6%96%B0%E7%9A%84%E4%BD%8D%E7%BD%AE">4. App 自动检查更新 方法执行的位置</h3> 
<p>Android 系统：</p> 
<ul><li>在 app.vue 中引用并调用，可以在 setup() 里直接调用，也可以在 onMounted() 中调用</li></ul> 
<p><s>Ios 系统：</s></p> 
<ul><li><s>应该在 <span style="color:#fe2c24;"><strong>浏览器</strong></span> 中，下载并打开</s></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bcf7da98be51410e61c3dc9a705c8dd7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java之hashMap遍历方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/026ea6719d5854246d400e0238b4c301/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python 2D游戏项目开发日记——像素世界（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>