<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux/Android——Input系统之InputMapper 处理 (八) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux/Android——Input系统之InputMapper 处理 (八)" />
<meta property="og:description" content="前文Linux/Android——Input系统之InputReader (七)介绍到了inputreader的运作流程，如何获取events到初步的分发，依次分析到InputMapper做第一步的处理.
前文有解析Mapper类型的依赖规则，不做重述.,这里单以触摸屏input_device 对应的SingleTouchInputMapper 为例。
撰写不易,转载需注明出处：http://blog.csdn.net/jscese/article/details/43561773本博文来自【 jscese 】的博客！
SingleTouchInputMapper： 原型定义在InputReader.h 中：
class SingleTouchInputMapper : public TouchInputMapper { public: SingleTouchInputMapper(InputDevice* device); virtual ~SingleTouchInputMapper(); virtual void reset(nsecs_t when); virtual void process(const RawEvent* rawEvent); protected: virtual void syncTouch(nsecs_t when, bool* outHavePointerIds); virtual void configureRawPointerAxes(); virtual bool hasStylus() const; private: SingleTouchMotionAccumulator mSingleTouchMotionAccumulator; }; 继承自TouchInputMapper，函数实现全部放在InputReader.cpp中，先看首先调用进的process：
void SingleTouchInputMapper::process(const RawEvent* rawEvent) { TouchInputMapper::process(rawEvent); //调用父类的process mSingleTouchMotionAccumulator.process(rawEvent); //数据的同步 } 继续跟： void TouchInputMapper::process(const RawEvent* rawEvent) { mCursorButtonAccumulator.process(rawEvent); mCursorScrollAccumulator.process(rawEvent); mTouchButtonAccumulator.process(rawEvent); //这三个Accumulator 进一步处理rawEvent ，原型都在InputReader." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/804eb4201a9cfa575e9faa546217e9df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-02-09T16:06:15+08:00" />
<meta property="article:modified_time" content="2015-02-09T16:06:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux/Android——Input系统之InputMapper 处理 (八)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>   前文<a target="_blank" href="http://blog.csdn.net/jscese/article/details/42739197" rel="noopener noreferrer">Linux/Android——Input系统之InputReader (七)</a>介绍到了inputreader的运作流程，如何获取events到初步的分发，依次分析到InputMapper做第一步的处理.</p> 
<p>前文有解析Mapper类型的依赖规则，不做重述.,这里单以触摸屏input_device 对应的SingleTouchInputMapper 为例。</p> 
<p><br> </p> 
<p>                                    <br> </p> 
<p>                         撰写不易,转载需注明出处：<a target="_blank" href="http://blog.csdn.net/jscese/article/details/43561773" rel="noopener noreferrer">http://blog.csdn.net/jscese/article/details/43561773</a>本博文来自<a target="_blank" href="http://blog.csdn.net/jscese" rel="noopener noreferrer">【 jscese 】</a>的博客！</p> 
<p><br> </p> 
<h3>SingleTouchInputMapper：</h3> 
<p> 原型定义在InputReader.h 中：<br> </p> 
<p></p> 
<pre><code class="language-objc"> class SingleTouchInputMapper : public TouchInputMapper {
public:
    SingleTouchInputMapper(InputDevice* device);
    virtual ~SingleTouchInputMapper();

    virtual void reset(nsecs_t when);
    virtual void process(const RawEvent* rawEvent);

protected:
    virtual void syncTouch(nsecs_t when, bool* outHavePointerIds);
    virtual void configureRawPointerAxes();
    virtual bool hasStylus() const;

private:
    SingleTouchMotionAccumulator mSingleTouchMotionAccumulator;
};</code></pre> 
<br> 
<p></p> 
<p>继承自TouchInputMapper，函数实现全部放在InputReader.cpp中，先看首先调用进的process：</p> 
<p><br> </p> 
<p></p> 
<pre><code class="language-objc">void SingleTouchInputMapper::process(const RawEvent* rawEvent) {
    TouchInputMapper::process(rawEvent);  //调用父类的process
    mSingleTouchMotionAccumulator.process(rawEvent);  //数据的同步

}</code></pre> 
<br> 继续跟： 
<p></p> 
<p></p> 
<pre><code class="language-objc">void TouchInputMapper::process(const RawEvent* rawEvent) {
    mCursorButtonAccumulator.process(rawEvent);
    mCursorScrollAccumulator.process(rawEvent);
    mTouchButtonAccumulator.process(rawEvent);   //这三个Accumulator 进一步处理rawEvent ，原型都在InputReader.cpp中，根据rawEvent-&gt;code 取出对应信息

    ALOGW("jscese dsp TouchInputMapper::process event type==0x%x, code==0x%x, valude ==0x%x \n",rawEvent-&gt;type,rawEvent-&gt;code,rawEvent-&gt;value);

    if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) {
        sync(rawEvent-&gt;when); //同步
    }
}</code></pre> 
<br> 
<p></p> 
<p>上面的几个process 有兴趣可以看下，会依次根据code type抽取对应的信息保存，比如CursorMotionAccumulator 中的  mRelX ，mRelY 代表相对坐标值</p> 
<p>作为我调试的触摸框来说这里只在TouchButtonAccumulator中抽取了 BTN_TOUCH 一个按下或者抬起的事件值.  <strong>ABS_X. ABS_Y</strong> 并没有在这里读取。而是在后面的<strong>SingleTouchMotionAccumulator::process</strong>中.<br> </p> 
<p>其它的input 设备就需要看驱动具体上报的code type了.</p> 
<p><br> </p> 
<p><br> </p> 
<h3>TouchInputMapper::sync：<br> </h3> 
<p> 从上面分析可以看到。一个rawEvent过来的时候 都会先经过三个process去抽取信息，然后才会检测是否是一个同步sync的rawEent事件，</p> 
<p><strong>这也就是为什么 在驱动中 一次完整的事件上报，总是先report一些button res abs之类的，最后来一个sync！</strong><br> </p> 
<p>这个同步函数比较长只留意几个地方就可以了：</p> 
<p></p> 
<pre><code class="language-objc">void TouchInputMapper::sync(nsecs_t when) {
    ALOGW("TouchInputMapper::sync");
    // Sync button state.
    mCurrentButtonState = mTouchButtonAccumulator.getButtonState()
            | mCursorButtonAccumulator.getButtonState();

    // Sync scroll state.

...

    // Sync touch state.
    bool havePointerIds = true;
    mCurrentRawPointerData.clear();
    syncTouch(when, &amp;havePointerIds);//调用子类的syncTouch，这里自然调用的是我 触摸框的 SingleTouchMotionAccumulator的syncTouch，更新ABS 坐标值,我这里是把数据存入到mCurrentRawPointerData中供下面cook

...

    // Reset state that we will compute below.
    mCurrentFingerIdBits.clear();
    mCurrentStylusIdBits.clear();
    mCurrentMouseIdBits.clear();
    mCurrentCookedPointerData.clear();   // 先清掉

...

        // Cook pointer data.  This call populates the mCurrentCookedPointerData structure
        // with cooked pointer data that has the same ids and indices as the raw data.
        // The following code can use either the raw or cooked data, as needed.
        cookPointerData();  //这个函数不跟进去了，太庞大，cook数据，主要是生成 mCurrentCookedPointerData.pointerCoords，mCurrentCookedPointerData.pointerProperties和mCurrentCookedPointerData.idToIndex

...

  dispatchTouches(when, policyFlags);  //又进行分发

...

//一些数据保存之类的操作

}</code></pre> 
<br> 
<p></p> 
<p>这里正常的处理是调用<strong>dispatchTouches</strong> 函数 ，往里走是<strong>dispatchMotion</strong>：</p> 
<pre><code class="language-objc">void TouchInputMapper::dispatchMotion(nsecs_t when, uint32_t policyFlags, uint32_t source,
        int32_t action, int32_t flags, int32_t metaState, int32_t buttonState, int32_t edgeFlags,
        const PointerProperties* properties, const PointerCoords* coords,
        const uint32_t* idToIndex, BitSet32 idBits,
        int32_t changedId, float xPrecision, float yPrecision, nsecs_t downTime) {

    PointerCoords pointerCoords[MAX_POINTERS];
    PointerProperties pointerProperties[MAX_POINTERS];
    uint32_t pointerCount = 0;

...

    getListener()-&gt;notifyMotion(&amp;args);  //回调

}</code></pre> 
<br> 
<br> 
<p>这里是走的signeltouch的所以最终会调用getListener()-&gt;notifyMotion(&amp;args)，如果是Keydown事件。根据上面的逻辑会在cookPointerData 之前调用<strong>synthesizeButtonKeys</strong> 依次会调用到<strong>context-&gt;getListener()-&gt;notifyKey(&amp;args);</strong><br> </p> 
<p><br> </p> 
<p><br> </p> 
<h3>QueuedInputListener：<br> </h3> 
<p> 上面分析到的<strong>notifyMotion</strong>最后会调用到这个类中，这个作为inputreader环节的最后交接维护类，回顾一下InputRead的构建，可以看下：</p> 
<pre><code class="language-objc">// --- InputReader ---

InputReader::InputReader(const sp&lt;EventHubInterface&gt;&amp; eventHub,
        const sp&lt;InputReaderPolicyInterface&gt;&amp; policy,
        const sp&lt;InputListenerInterface&gt;&amp; listener)   //这里注意最后一个参数～

...

{

    mQueuedListener = new QueuedInputListener(listener); //构造了一个QueuedinputListener

...

}</code></pre> 
<br> 
<p>这里又要看下最开始的构造调用了/frameworks/base/services/input/InputManager.cpp中：</p> 
<pre><code class="language-objc">InputManager::InputManager(
...

    mDispatcher = new InputDispatcher(dispatcherPolicy);
    mReader = new InputReader(eventHub, readerPolicy, mDispatcher);  //可以看到这里传入的是InputDispatcher ，但是上面直接用的InputListenerInterface ，，直接强制转换成了 父类指针！  这里注意一下
...
}</code></pre> 
<br> 
<br> 所以在InputReader中构造QueuedInputListener的时候保存的是InputDispatcher的父类指针，保存在私有成员  
<strong>mInnerListener</strong>  
<p></p> 
<pre><code class="language-objc">// --- QueuedInputListener ---

QueuedInputListener::QueuedInputListener(const sp&lt;InputListenerInterface&gt;&amp; innerListener) :
        mInnerListener(innerListener) {
}</code></pre> 
<br> 
<p></p> 
<p>为什么这么做是应为 后续调用的纯虚函数。将会交由InputDispatcher 的函数来实现。实现了一个传递，C++ 就是这样，要整个看明白。才知道设计者写的代码到底跑到哪里去了～</p> 
<p>往下分析流程就知道我为什么这么说了.</p> 
<p>回到前面，调用<strong> QueuedInputListener::notifyMotion</strong>，将这个notifyMotion push进<strong>mArgsQueue</strong> 链表队列，然后在 <strong>loopOnce() </strong>中做完上述一次事件的获取以及分发处理之后将会调用 <strong> mQueuedListener-&gt;flush();</strong><br> </p> 
<p></p> 
<pre><code class="language-objc">void QueuedInputListener::flush() {
    size_t count = mArgsQueue.size();
    for (size_t i = 0; i &lt; count; i++) {
        NotifyArgs* args = mArgsQueue[i];
        args-&gt;notify(mInnerListener);  //这里依次调用上面push进来的不同种类notify的notify函数，NotifyConfigurationChangedArgs /  NotifyKeyArgs / NotifyMotionArgs / NotifySwitchArgs / NotifyDeviceResetArgs 这几种
        delete args;
    }
    mArgsQueue.clear();
}

</code></pre> 
<br> 这里还是单以我做的notifyMotion为例： 
<p></p> 
<p></p> 
<pre><code class="language-objc">void NotifyMotionArgs::notify(const sp&lt;InputListenerInterface&gt;&amp; listener) const {
    listener-&gt;notifyMotion(this);
}</code></pre> 
<br> 
<strong>就是这里。又来了一个 notifyMotion调用，这个纯虚函数 ，两个子类QueuedInputListener  InputDispatcher 中都有实现，就像上面分析到的，最终是调用到 InputDispatcher 中的notifyMotion ！</strong> 
<br> 
<p></p> 
<p><br> </p> 
<p>之后就是InputDispatcher 的处理了，这里不继续。后续再说～<br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/460fd8b6a3e7c1aae4b3fb9eea980587/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Setup Factory打包注册dll</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b5caa1ab7962f8ca1456f77f222d671/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;读书清单</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>