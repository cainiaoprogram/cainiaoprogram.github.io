<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>汇编指令--数据传输指令 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="汇编指令--数据传输指令" />
<meta property="og:description" content="一.数据传输指令 指令包括：MOV,XCHG,XLAT,LEA,LDS,LES,PUSH,POP,PUSHF,LAHF,SAHF,POPF,IN,OUT
重点掌握：MOV,XCHG,XLAT,LEA,PUSH,POP
1.MOV指令（move) 作用：把一个字或者字节的操作数从源地址传送到目标地址
;使用格式： ;mov target,source ;mem表示内存，imm表示立即数（数据），seg表示段寄存器 mov reg/mem,imm ;mov ax,0123H mov reg/mem/seg,reg ;mov bx,ax mov reg/seg,mem mov reg/mem,seg 注意事项：有source决定target的范围
1.target不能时CS（代码段寄存器）
2.target和source不能同时为内存数，段寄存器（CS/DS/ES/SS/FS/GS)
3.不能将立即数传送给段寄存器
4.target和source必须类型匹配，比如，要么都是字节，要么都是字或者都是双字等。
5.由于立即数没有明确的类型，所以将立即数传送到target时，系统会自动将立即数零扩展到与target数的位数相同，再进行传送。有时，需要用BYTE PTR,WORD PTR明确指出立即数的位数
图示解析：
REG可以和REG，MEM，段寄存器，进行数据交流
im可以和REG，MEM进行数据交路
CS可以和REG，MEM进行数据交流
段寄存器可以和REG，MEM进行数据交流
MEM可以和段寄存器，REG进行数据交流
示例：
mov al,4 ;将4以字节的形式传送给al寄存器，为字节传送 mov cx,00FFH ;将00FFH传送给CX寄存器，上述的4和00FF都为立即数，cx,al均为reg mov si,0200H ;将0200H传送给寄存器si，为字传送 mov ax,bx ;将bx中的内容传送给ax，属于寄存器之间的操作 mov byte ptr [si] , 0ah ;byte ptr说明是字节操作 mov ds,ax ;将ax中的内容传送给段寄存器ds，属于段寄存器（seg）和寄存器之间的传送 mov [si],al ;将al中的内容传递给段寄存器ds，属于段寄存器（seg）和寄存器之间的传送 ;说明： [bp]---&gt;ss:[bp] [si]---&gt;ds:[si] ds作为段地址，si作为偏移地址 [bx]---&gt;ds:[bx] 代码演示如下： 2.XCHG指令(exchange) 作用：将一个字节或者自己的源操作数和目的操作数相交换" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6a205f58175f2c87ea2193cf3ea2f307/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-26T21:18:05+08:00" />
<meta property="article:modified_time" content="2022-04-26T21:18:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">汇编指令--数据传输指令</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.数据传输指令</h2> 
<p>指令包括：MOV,XCHG,XLAT,LEA,LDS,LES,PUSH,POP,PUSHF,LAHF,SAHF,POPF,IN,OUT</p> 
<p>重点掌握：MOV,XCHG,XLAT,LEA,PUSH,POP</p> 
<h3>1.MOV指令（move)</h3> 
<p>作用：把一个字或者字节的操作数从源地址传送到目标地址</p> 
<pre><code>;使用格式：
;mov target,source
;mem表示内存，imm表示立即数（数据），seg表示段寄存器
mov reg/mem,imm        ;mov ax,0123H
mov reg/mem/seg,reg    ;mov bx,ax
mov reg/seg,mem        
mov reg/mem,seg</code></pre> 
<p>注意事项：有source决定target的范围</p> 
<p>1.target不能时CS（代码段寄存器）</p> 
<p>2.target和source不能同时为内存数，段寄存器（CS/DS/ES/SS/FS/GS)</p> 
<p>3.不能将立即数传送给段寄存器</p> 
<p>4.target和source必须类型匹配，比如，要么都是字节，要么都是字或者都是双字等。</p> 
<p>5.由于立即数没有明确的类型，所以将立即数传送到target时，系统会自动将立即数零扩展到与target数的位数相同，再进行传送。有时，需要用BYTE PTR,WORD PTR明确指出立即数的位数</p> 
<p>图示解析：</p> 
<p><img alt="" height="591" src="https://images2.imgbox.com/c1/5d/iVPhaC06_o.png" width="1076"></p> 
<p>REG可以和REG，MEM，段寄存器，进行数据交流</p> 
<p>im可以和REG，MEM进行数据交路</p> 
<p>CS可以和REG，MEM进行数据交流</p> 
<p>段寄存器可以和REG，MEM进行数据交流</p> 
<p>MEM可以和段寄存器，REG进行数据交流</p> 
<p>示例：</p> 
<pre><code>mov al,4    ;将4以字节的形式传送给al寄存器，为字节传送
mov cx,00FFH    ;将00FFH传送给CX寄存器，上述的4和00FF都为立即数，cx,al均为reg
mov si,0200H    ;将0200H传送给寄存器si，为字传送
mov ax,bx        ;将bx中的内容传送给ax，属于寄存器之间的操作
mov byte ptr [si] , 0ah      ;byte ptr说明是字节操作
mov ds,ax    ;将ax中的内容传送给段寄存器ds，属于段寄存器（seg）和寄存器之间的传送
mov [si],al    ;将al中的内容传递给段寄存器ds，属于段寄存器（seg）和寄存器之间的传送
;说明： 
[bp]---&gt;ss:[bp]
[si]---&gt;ds:[si]    ds作为段地址，si作为偏移地址
[bx]---&gt;ds:[bx]</code></pre> 
<p>代码演示如下： </p> 
<p> <img alt="" height="674" src="https://images2.imgbox.com/26/27/JGGBKtDV_o.png" width="1161"></p> 
<p> <img alt="" height="450" src="https://images2.imgbox.com/7d/09/U7y8mUp2_o.png" width="598"></p> 
<p> <img alt="" height="680" src="https://images2.imgbox.com/c0/05/6HoyGeON_o.png" width="1099"></p> 
<p> <img alt="" height="356" src="https://images2.imgbox.com/96/37/N2SpNpgp_o.png" width="1092"></p> 
<p> <img alt="" height="724" src="https://images2.imgbox.com/95/52/xVHw6b1E_o.png" width="1098"></p> 
<h3> 2.XCHG指令(exchange)</h3> 
<p>作用：将一个字节或者自己的源操作数和目的操作数相<strong>交换</strong></p> 
<pre><code>;使用格式
;XCHG OPRD1,OPRD2
;     目的    源
XCHG reg,reg
XCHG reg,mem
XCHG mem,reg
;XCHG指令可以交换两个寄存器，寄存器-&gt;寄存器中的数据</code></pre> 
<p>示例：</p> 
<pre><code>xchg al,cl
xchg ax,[bx]
xchg [bx],ax
xchg al,ah</code></pre> 
<h4>注意事项：</h4> 
<p>1.不能同时都为内存操作</p> 
<p>2.任何一个寄存器都不能为段寄存器</p> 
<p>3.任何一个操作不能是立即数</p> 
<p>4.两个操作数的长度必须相等</p> 
<h4>代码演示：</h4> 
<p><img alt="" height="359" src="https://images2.imgbox.com/09/b1/5KYOdePX_o.png" width="456"></p> 
<h3><img alt="" height="702" src="https://images2.imgbox.com/ab/b2/Fv0L99TG_o.png" width="1200"> 3.换码指令XLAT</h3> 
<p>作用：将bx指定的缓冲区，AL指定的位移处的一个字节数据取出赋值给AL</p> 
<pre><code>;使用格式
xlat     ;al&lt;-ds:[bx+al] [bx+al]:整体作为偏移地址,al作为地址位移</code></pre> 
<h4> 示例</h4> 
<pre><code>mov bx,0100H
mov al,03H
xlat   
;al&lt;-ds:[0100+03]H</code></pre> 
<p> <img alt="" height="825" src="https://images2.imgbox.com/b0/7c/po6DHmnn_o.png" width="1200"></p> 
<h3>4. 堆栈指令PUSH，POP</h3> 
<p>作用：将寄存器或者存储器中的数据按照堆栈操作的规则进行出入栈</p> 
<pre><code>;使用格式
;PUSH 源操作数
;POP    目的操作数
PUSH    reg/mem/seg
POP    reg/mem/seg</code></pre> 
<h4>示例： </h4> 
<pre><code>PUSH ax;    将ax寄存器中的数据压入栈中
POP ax;    将栈顶中的数据出栈到ax中</code></pre> 
<h4>注意事项：</h4> 
<p>1.当栈为空时不能进行出栈</p> 
<p>2.指令的操作数必须是16位，即不能使用al这种8位寄存器</p> 
<h4>演示</h4> 
<p>ss:sp指向栈顶</p> 
<p>未压栈</p> 
<p><img alt="" height="793" src="https://images2.imgbox.com/29/a8/hRW7BDCI_o.png" width="1200"></p> 
<p>压栈后</p> 
<p><img alt="" height="847" src="https://images2.imgbox.com/f2/8f/Ete3MAAN_o.png" width="1200"></p> 
<p>出栈</p> 
<p> <img alt="" height="745" src="https://images2.imgbox.com/24/0e/bDIRHsuB_o.png" width="1200"></p> 
<p></p> 
<h3>5.地址传送指令LEA LDS LES</h3> 
<p>作用：将对应的地址表示送入对应的寄存器中</p> 
<pre><code>;使用格式
LEA reg,mem
LDS reg,mem
LES reg,mem</code></pre> 
<h4>示例：</h4> 
<pre><code>mov bx,0400H
mov si,3CH
lea bx,[bx+si+0f62H]
;bx = 0400H + 003CH + 0f62H = 139EH</code></pre> 
<p>LDS:将mem指定的字送入指定的寄存器中，并且DS=mem+2</p> 
<p>LES:将mem指定的字送入指定的寄存器中，并且ES=mem+2</p> 
<h4>代码演示</h4> 
<p><img alt="" height="828" src="https://images2.imgbox.com/b4/2b/q0gwqPun_o.png" width="1200"></p> 
<h3> 6.标志寄存器传送指令 LAHF,SAHF,PUSHF,POPF</h3> 
<p>作用：标志寄存器传送指令用来传送标志寄存器FLAGS的内容，方便对各个标志位的直接操作，首先需要了解一下什么是<strong>标志寄存器</strong>：</p> 
<p>标志寄存器：用来存储相关指令的某些执行结果，用来为CPU执行相关指令提供依据并可以以此来控制CPU的相关行为。8086中标志寄存器PSW（程序状态字）。该寄存器并不是用来存放普通数据的，而是按位起作用，每一位都有专门的含义。</p> 
<p>SF：符号标志位，如果执行结果为负数，则SF=1，非负则SF=0；</p> 
<p>ZF:零标志位，如果执行结果为0，则ZF=1，否则ZF=0；</p> 
<p>PF：奇偶标志位，如果执行结果中所有二进制位中1的个数位偶数则PF=1，否则PF=0</p> 
<p>CF:进/借位标志符，一般来说，再进行有符号的运算时，如果数据最高位产生了进位或者借位，CF=1，否则CF=0;一般表示有符号数的溢出；</p> 
<p>OF:溢出标志位，运算结果超出了机器所能表示的范围称为溢出，溢出则OV=1</p> 
<p>一般表示无符号数的溢出；</p> 
<p>DF：方向标志位，在串处理指令操作后控制DI，SI的增减，如果DF=0，则前述寄存器递增，否则递减，注意DF的值由程序员通过CLD（0）和STD（1）指令设定；</p> 
<p>TF：调试标志位，当TF=1时，处理器每次只执行一条指令，即单步执行；</p> 
<p>IF：中断允许标志位，用来控制8086CPU是否可以接受外部中断请求。IF=1，则能相应外部中断，否则屏蔽外部中断；</p> 
<p>AF:辅助进位标志位，运算过程中看第三位，不论长度多少。如果最后四位向前进位/借位，AF=1，否则AF=0；</p> 
<p><img alt="" height="553" src="https://images2.imgbox.com/32/ed/lmC1l92A_o.png" width="1200"></p> 
<h4> 演示：</h4> 
<p><img alt="" height="682" src="https://images2.imgbox.com/f4/c3/LswgatkJ_o.png" width="1072"></p> 
<p> </p> 
<pre><code>;使用格式 直接输入即可
;低8位传送
LAHF ;将标志寄存器的低字节传送给寄存器AH
     ;SF/ZF/AF/PF/CF状态标志位分别送入AH的第7/6/4/2/0位，而AH的第5/3/1位任意
SAHF ;SAHF将寄存器内容送入FLAGS的低字节
     ;用AH的第7/6/4/2/0位相应设置SF/ZF/AF/PF/CF标志
;16位传送
PUSHF    ;PUSHF指令将标志寄存器的内容压入堆栈，同时栈顶指针SP减2
POPF     ;POPF指令将栈顶字单元内容送入标志寄存器，同时栈顶指针加2</code></pre> 
<p><img alt="" height="425" src="https://images2.imgbox.com/e3/e9/YQMPgMct_o.png" width="1200"></p> 
<h3>7.输入输出指令IN,OUT </h3> 
<p>8086通过输入输出指令与外设进行数据交换，呈现给<strong>程序员的外设是端口（Port）</strong>，即<strong>I/O地址</strong></p> 
<h4>8086的寻址方式</h4> 
<p>1.直接寻址：只用于寻址00H~FFH前256个端口，操作数i8表示端口号</p> 
<p>2.间接寻址：可用于寻址全部64K个端口，DX寄存器的值就是端口号</p> 
<p>对大于FFH的端口只能采用间接寻址方式</p> 
<pre><code>;使用格式
;字节输入
IN al,i8         ;AL&lt;-I/O端口（i8直接寻址）
IN al,DX         ;AL&lt;-I/O端口（DX间接寻址）
;字输入
IN ax,i8         ;AX&lt;-I/O端口（i8直接寻址）
IN ax,dx         ;AX&lt;-I/O端口（DX间接寻址）
;字节输出
OUT i8,al        ;I/O端口&lt;-AL(i8直接寻址）
OUT dx,al        ;I/O端口&lt;-AL(DX间接寻址）
;字输出
OUT i8,ax        ;I/O端口&lt;-AX(i8直接寻址）
OUT DX,ax        ;I/O端口&lt;-AX(DX间接寻址）</code></pre> 
<p>下列程序可以从CPU中的RAM中读取月份和日期（保存方式位BCD码）</p> 
<pre><code>mov al,8
out 70,al
in al,71        ;这三句可以将月份保存在al中
mov ah,7
mov al,7
out 70,al
in al,71        ;这三句可以将日期保存在al中</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a714cd4b364b90962ed7284fc7501aba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MybatisPlus多表连接查询 支持一对一、一对对、多对多查询</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6cca15328b9b8b3655b116b15f0c7e55/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【按键精灵】＜＜失落的方舟＞＞混沌地牢退场的逻辑记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>