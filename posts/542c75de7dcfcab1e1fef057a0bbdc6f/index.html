<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kotlin基础语法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kotlin基础语法" />
<meta property="og:description" content="Kotlin基础语法 Kotlin内置数据类型变量可读可写变量可读变量 自动类型推导机制when表达式range表达式字符串模版函数函数定义函数简写默认参数具名函数参数Unit函数反引号函数匿名函数隐式返回函数作为形参函数引用函数作为返回值 可空性高级函数 let非空断言空合并操作符 高级函数apply函数run函数with函数also函数takeIf函数takeUnless函数 集合List可变List Set可变Set 数组Map可变Map 类主构造函数次构造函数lateinit 延迟初始化lazy 惰性初始化继承和重载companion objec 伴生对象内部类嵌套类数据类 运算符重载枚举类代数数据类型密封类接口抽象类泛型类vararg 动态参数协变&amp;逆变协变逆变 扩展函数单例模式饿汉式懒汉式懒汉式-加锁懒汉式-双重校验 Kotlin内置数据类型 名称释义String字符串char字符Boolean布尔型Int整型Float单精度浮点型Double双精度浮点型List集合Set无重复元素集合Map键值对集合 变量 可读可写变量 var name: String = &#34;Kotlin&#34; name = &#34;C&#43;&#43;&#34; println(name) 可读变量 val name: String = &#34;Kotlin&#34; //下列变量不可修改，因为声明成val,只能进行读操作，不能进行写操作 //name = &#34;C&#43;&#43;&#34; println(name) 自动类型推导机制 根据定义变量时进行初始化，系统可以根据初始化值自动进行类型推导，进而可以省略类型声明
val name = &#34;Kotlin&#34; //String val age = 5 //Int val sex = m&#39; //char val score = 99.99 //Doble when表达式 val week = 5 val info = when(week){ 1-&gt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/542c75de7dcfcab1e1fef057a0bbdc6f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T18:16:23+08:00" />
<meta property="article:modified_time" content="2023-12-29T18:16:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kotlin基础语法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Kotlin基础语法</h4> 
 <ul><li><ul><li><a href="#Kotlin_1" rel="nofollow">Kotlin内置数据类型</a></li><li><a href="#_15" rel="nofollow">变量</a></li><li><ul><li><a href="#_17" rel="nofollow">可读可写变量</a></li><li><a href="#_25" rel="nofollow">可读变量</a></li></ul> 
   </li><li><a href="#_34" rel="nofollow">自动类型推导机制</a></li><li><a href="#when_45" rel="nofollow">when表达式</a></li><li><a href="#range_62" rel="nofollow">range表达式</a></li><li><a href="#_82" rel="nofollow">字符串模版</a></li><li><a href="#_92" rel="nofollow">函数</a></li><li><ul><li><a href="#_94" rel="nofollow">函数定义</a></li><li><a href="#_110" rel="nofollow">函数简写</a></li><li><a href="#_124" rel="nofollow">默认参数</a></li><li><a href="#_134" rel="nofollow">具名函数参数</a></li><li><a href="#Unit_144" rel="nofollow">Unit函数</a></li><li><a href="#_156" rel="nofollow">反引号函数</a></li><li><a href="#_166" rel="nofollow">匿名函数</a></li><li><a href="#_178" rel="nofollow">隐式返回</a></li><li><a href="#_201" rel="nofollow">函数作为形参</a></li><li><a href="#_221" rel="nofollow">函数引用</a></li><li><a href="#_241" rel="nofollow">函数作为返回值</a></li></ul> 
   </li><li><a href="#_258" rel="nofollow">可空性</a></li><li><ul><li><a href="#_let_278" rel="nofollow">高级函数 let</a></li><li><a href="#_289" rel="nofollow">非空断言</a></li><li><a href="#_298" rel="nofollow">空合并操作符</a></li></ul> 
   </li><li><a href="#_305" rel="nofollow">高级函数</a></li><li><ul><li><a href="#apply_307" rel="nofollow">apply函数</a></li><li><a href="#run_326" rel="nofollow">run函数</a></li><li><a href="#with_340" rel="nofollow">with函数</a></li><li><a href="#also_356" rel="nofollow">also函数</a></li><li><a href="#takeIf_372" rel="nofollow">takeIf函数</a></li><li><a href="#takeUnless_389" rel="nofollow">takeUnless函数</a></li></ul> 
   </li><li><a href="#_393" rel="nofollow">集合</a></li><li><ul><li><a href="#List_395" rel="nofollow">List</a></li><li><ul><li><a href="#List_421" rel="nofollow">可变List</a></li></ul> 
    </li><li><a href="#Set_480" rel="nofollow">Set</a></li><li><ul><li><a href="#Set_511" rel="nofollow">可变Set</a></li></ul> 
    </li><li><a href="#_522" rel="nofollow">数组</a></li><li><a href="#Map_548" rel="nofollow">Map</a></li><li><ul><li><a href="#Map_611" rel="nofollow">可变Map</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_623" rel="nofollow">类</a></li><li><ul><li><a href="#_650" rel="nofollow">主构造函数</a></li><li><a href="#_682" rel="nofollow">次构造函数</a></li><li><a href="#lateinit__712" rel="nofollow">lateinit 延迟初始化</a></li><li><a href="#lazy__736" rel="nofollow">lazy 惰性初始化</a></li><li><a href="#_757" rel="nofollow">继承和重载</a></li><li><a href="#companion_objec__779" rel="nofollow">companion objec 伴生对象</a></li><li><a href="#_800" rel="nofollow">内部类</a></li><li><a href="#_824" rel="nofollow">嵌套类</a></li><li><a href="#_846" rel="nofollow">数据类</a></li></ul> 
   </li><li><a href="#_942" rel="nofollow">运算符重载</a></li><li><a href="#_991" rel="nofollow">枚举类</a></li><li><a href="#_1018" rel="nofollow">代数数据类型</a></li><li><a href="#_1038" rel="nofollow">密封类</a></li><li><a href="#_1058" rel="nofollow">接口</a></li><li><a href="#_1084" rel="nofollow">抽象类</a></li><li><a href="#_1116" rel="nofollow">泛型类</a></li><li><a href="#vararg__1137" rel="nofollow">vararg 动态参数</a></li><li><a href="#_1160" rel="nofollow">协变&amp;逆变</a></li><li><ul><li><a href="#_1162" rel="nofollow">协变</a></li><li><a href="#_1173" rel="nofollow">逆变</a></li></ul> 
   </li><li><a href="#_1184" rel="nofollow">扩展函数</a></li><li><a href="#_1197" rel="nofollow">单例模式</a></li><li><ul><li><a href="#_1199" rel="nofollow">饿汉式</a></li><li><a href="#_1205" rel="nofollow">懒汉式</a></li><li><a href="#_1221" rel="nofollow">懒汉式-加锁</a></li><li><a href="#_1237" rel="nofollow">懒汉式-双重校验</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="Kotlin_1"></a>Kotlin内置数据类型</h3> 
<table><thead><tr><th align="center">名称</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">String</td><td align="center">字符串</td></tr><tr><td align="center">char</td><td align="center">字符</td></tr><tr><td align="center">Boolean</td><td align="center">布尔型</td></tr><tr><td align="center">Int</td><td align="center">整型</td></tr><tr><td align="center">Float</td><td align="center">单精度浮点型</td></tr><tr><td align="center">Double</td><td align="center">双精度浮点型</td></tr><tr><td align="center">List</td><td align="center">集合</td></tr><tr><td align="center">Set</td><td align="center">无重复元素集合</td></tr><tr><td align="center">Map</td><td align="center">键值对集合</td></tr></tbody></table> 
<h3><a id="_15"></a>变量</h3> 
<h4><a id="_17"></a>可读可写变量</h4> 
<pre><code>var name: String = "Kotlin"
name = "C++"
println(name)
</code></pre> 
<h4><a id="_25"></a>可读变量</h4> 
<pre><code>val name: String = "Kotlin"
//下列变量不可修改，因为声明成val,只能进行读操作，不能进行写操作
//name = "C++" 
println(name)
</code></pre> 
<h3><a id="_34"></a>自动类型推导机制</h3> 
<p>根据定义变量时进行初始化，系统可以根据初始化值自动进行类型推导，进而可以省略类型声明</p> 
<pre><code>val name = "Kotlin" //String
val age = 5 //Int
val sex = m' //char
val score = 99.99 //Doble
</code></pre> 
<h3><a id="when_45"></a>when表达式</h3> 
<pre><code>val week = 5
    val info = when(week){
        1-&gt; "星期一"
        2-&gt; "星期二"
        3-&gt; "星期三"
        4-&gt; "星期四"
        5-&gt; "星期五"
        6-&gt; "星期六"
        7-&gt; "星期天"
        else-&gt; "错误类型"
    }
    println(info)
</code></pre> 
<h3><a id="range_62"></a>range表达式</h3> 
<pre><code>  val score = 70
    when (score) {
        in 0..59 -&gt; {
            println("不及格")
        }
        in 60 ..79 -&gt; {
            println("及格")
        }
        in 80 .. 89 -&gt; {
            println("良好")
        }
        else -&gt; {
            println("优秀")
        }
    }
</code></pre> 
<h3><a id="_82"></a>字符串模版</h3> 
<pre><code> val name = "Kotlin"
    val age = 7
    val score = 32
    val detail = "I am $name and $age,I got ${score+10} in the last test."
    println(detail)
</code></pre> 
<h3><a id="_92"></a>函数</h3> 
<h4><a id="_94"></a>函数定义</h4> 
<ul><li>在Kotlin中函数默认访问类型为Public，此处我声明为private</li><li><code>fun</code>为声明函数关键字</li><li><code>add</code>为函数名</li><li><code>a:Int,b:Int</code>为函数形参</li><li>形参列表后面有一个<code>:Int</code>，代表函数返回Int</li></ul> 
<pre><code>private fun add(a:Int,b:Int):Int{
val result = a+b
println(result)
return result
}
</code></pre> 
<h4><a id="_110"></a>函数简写</h4> 
<p>当函数体只有一行代码时，可以不写括号，直接在等号后面接代码即可</p> 
<pre><code>private fun add(a:Int,b:Int) = println(a+b)
</code></pre> 
<p>若函数需要返回值，则直接将计算结果接在等号后面返回</p> 
<pre><code>private fun add(a:Int,b:Int):Int = a+b
</code></pre> 
<h4><a id="_124"></a>默认参数</h4> 
<pre><code>fun printfInfo(name:String,age:Int) = println("I am $name and $age")

fun printfInfo(name:String="Li",age:Int) = println("I am $name and $age")

fun printfInfo(name:String="Li",age:Int=20) = println("I am $name and $age")
</code></pre> 
<h4><a id="_134"></a>具名函数参数</h4> 
<p>具名参数可以任意调整实参的顺序</p> 
<pre><code>printfInfo(age = 10，name = "Kotlin")
...
fun printfInfo(name:String,age:Int) = println("I am $name and $age")
</code></pre> 
<h4><a id="Unit_144"></a>Unit函数</h4> 
<p>在JAVA中void为空返回类型，是一个关键字</p> 
<p>在Kotlin中Unit是一个类类型，为函数默认返回类型</p> 
<pre><code>private fun exe():Unit{
    return println()
}
</code></pre> 
<h4><a id="_156"></a>反引号函数</h4> 
<pre><code>打印分数(20.22)
...
private fun `打印分数`(score:Double){
    println("分数=$score")
}
</code></pre> 
<h4><a id="_166"></a>匿名函数</h4> 
<pre><code>  val len = "Kotlin".count()
    println("len=$len")

    val len1 = "Kotlin,in".count { it-&gt;
        it == 'i'
    }
    println("len1=$len1")
</code></pre> 
<h4><a id="_178"></a>隐式返回</h4> 
<p>函数声明</p> 
<pre><code>val printfScore:(score:Double)-&gt;String
</code></pre> 
<p>函数实现，匿名函数无需使用<code>return</code>返回结果，以最后一行作为返回值进行返回</p> 
<pre><code> printfScore = { it-&gt;
        println("score$it")
        "打印成功!"
    }
</code></pre> 
<p>函数调用</p> 
<pre><code> printfScore(50.50)
</code></pre> 
<h4><a id="_201"></a>函数作为形参</h4> 
<pre><code>const val NAME = "Kotlin"
const val AGE = 10
//...
JudgeInfo("Kotlin",10){ info,code-&gt;
    println("info=$info,code=$code")
 }
//...
fun JudgeInfo(name:String,age:Int,respond:(String,Int)-&gt;Unit){
    val result = name == NAME &amp;&amp; age == AGE
    if (result == true){
        respond("success",200)
    }else{
        respond("failed",404)
    }
}
</code></pre> 
<h4><a id="_221"></a>函数引用</h4> 
<pre><code>const val NAME = "Kotlin"
const val AGE = 10
//...
JudgeInfo("Kotlin",10,::printfInfo)
 
fun printfInfo(info:String,code:Int) = println("info=$info,code=$code")
//...
fun JudgeInfo(name:String,age:Int,respond:(String,Int)-&gt;Unit){
    val result = name == NAME &amp;&amp; age == AGE
    if (result == true){
        respond("success",200)
    }else{
        respond("failed",404)
    }
}
</code></pre> 
<h4><a id="_241"></a>函数作为返回值</h4> 
<pre><code>const val NAME = "Kotlin"
const val AGE = 10
//...
val exe = JudgeInfo()
println(exe("Kotlin",10))
 //...
fun JudgeInfo():(name:String,age:Int)-&gt;Boolean{
    return { name,age-&gt;
        val result = name ==NAME &amp;&amp; age ==AGE
        result
    }
}
</code></pre> 
<h3><a id="_258"></a>可空性</h3> 
<p>在Kotlin中不能直接给一个变量赋值<code>null</code>，这也极大减少了空异常频发问题</p> 
<p>如果需要给一个变量赋null，则需要在声明时，在变量类型后面加一个<code>?</code>,示意准许此变量在程序中为null</p> 
<pre><code>val name:String ? = null
println(name)//打印出null
</code></pre> 
<p>将一个可空类型字符串变量转为大写，需要在调用<code>uppercase</code>函数时前面加一个<code>？</code>，代表如果name不为空则执行<code>uppercase</code>函数，否则不执行<code>？</code>后面的函数</p> 
<pre><code>var name:String ? = null
name = "kotlin"
val msg = name?.uppercase()
println(msg)
</code></pre> 
<h4><a id="_let_278"></a>高级函数 let</h4> 
<pre><code>var name:String ? = null
name = "kotlin"
val msg = name?.let {
  it.uppercase()
}
println(msg)
</code></pre> 
<h4><a id="_289"></a>非空断言</h4> 
<pre><code>var name:String ? = null
name = "kotlin"
val msg = name!!.uppercase()
println(msg)
</code></pre> 
<h4><a id="_298"></a>空合并操作符</h4> 
<pre><code>var name:String ? = null
println(name ?: "name为空!")
</code></pre> 
<h3><a id="_305"></a>高级函数</h3> 
<h4><a id="apply_307"></a>apply函数</h4> 
<ul><li>apply函数始终返回对象本身</li><li>apply匿名函数在内部持有当前对象<code>this</code></li></ul> 
<pre><code>val languages = arrayOf("C++","JAVA","Kotlin","C")
    //apply函数始终返回对象本身，且apply匿名函数在内部持有当前对象this
    languages.apply {
        println("数组长度=${size}")
    }.apply {
     forEach {
         println(it)
     }
    }.apply { 
        println("遍历数组完毕")
    }
</code></pre> 
<h4><a id="run_326"></a>run函数</h4> 
<ul><li>以最后一行作为返回值返回</li><li>匿名函数内部持有当前对象<code>this</code></li></ul> 
<pre><code>val len = languages.run {
        filter {
            it.contains('C')
        }.size
    }
 println("包含字符C的元素个数=${len}")
</code></pre> 
<h4><a id="with_340"></a>with函数</h4> 
<ul><li>以最后一行作为返回值返回</li><li>匿名函数内部持有当前对象<code>this</code></li><li>不能以拓展函数形式调用，只能将当前对象以形参形式传递</li></ul> 
<pre><code> val languages = arrayOf("C++","JAVA","Kotlin","C")
 val len = with(languages){
   filter {
           it.contains('C')
       }.size
   }
println("包含字符C的元素个数=${len}")
</code></pre> 
<h4><a id="also_356"></a>also函数</h4> 
<ul><li>also函数始终返回对象本身</li><li>匿名函数内部持有<code>it</code></li></ul> 
<pre><code>  val languages = arrayOf("C++","JAVA","Kotlin","C")
    languages.also {
       println(it.first())
    }.also {
        println(it.last())
    }.also {
        println("元素个数=${it.size}")
    }
</code></pre> 
<h4><a id="takeIf_372"></a>takeIf函数</h4> 
<p>如果<code>takeIf</code>函数内部为<code>true</code>则返回对象本身，否则返回<code>null</code></p> 
<pre><code>const val NAME = "Kotlin"
const val AGE = 10
fun main() {
    val result = JudgeInfo("Kotlin",10)
    println(result)
}

fun JudgeInfo(name:String,age:Int):String{
    return name.takeIf { name`NAME&amp;&amp;AGE`age } ?: "信息不匹配!"
}
</code></pre> 
<h4><a id="takeUnless_389"></a>takeUnless函数</h4> 
<p>takeUnless函数与takeIf函数功能相反，如果<code>takeUnless</code>内部为true则返回null，否则返回对象本身</p> 
<h3><a id="_393"></a>集合</h3> 
<h4><a id="List_395"></a>List</h4> 
<pre><code>  val languages:List&lt;String&gt; = listOf&lt;String&gt;("C++","C","JAVA","Kotlin","Dart")
    // public operator fun get(index: Int): E
    //与C++的运算符重载类似
    println("第一个元素：${languages[0]}")
    languages.forEach {
        println(it)
    }
</code></pre> 
<p>列表越界处理</p> 
<pre><code>//方法一
val result = languages.getOrElse(5){
        "数组越界"
    }
println(result)

//方法二
val result1 = languages.getOrNull(1000) ?: "数组越界"
println(result1)
</code></pre> 
<h5><a id="List_421"></a>可变List</h5> 
<pre><code>val languages = mutableListOf("C++","C","JAVA","Kotlin","Dart")
</code></pre> 
<ul><li>删除List中包含字符C的元素</li></ul> 
<pre><code>    languages.removeIf {
        it.contains('C')
    }
    languages.forEach{
        println(it)
    }
</code></pre> 
<ul><li>添加元素</li></ul> 
<p>通过运算符重载函数为List添加新元素</p> 
<blockquote> 
 <p>public inline operator fun MutableCollection.plusAssign(element: T) {<!-- --><br> this.add(element)<br> }</p> 
</blockquote> 
<pre><code>    languages += "C#"
    languages += "Basic"
    languages.forEach{
        println(it)
    }
</code></pre> 
<ul><li>遍历List</li></ul> 
<p>forEach</p> 
<pre><code>languages.forEach{
    println(it)
}
</code></pre> 
<p>for-in</p> 
<pre><code> for(element in languages){
        println(element)
}
</code></pre> 
<p>forEachIndexed</p> 
<pre><code>languages.forEachIndexed { index, s -&gt;
        println("第${index+1}元素=$s")
    }
</code></pre> 
<h4><a id="Set_480"></a>Set</h4> 
<p>不允许存在重复元素，如果存在重复元素，会自动忽略</p> 
<p>下列输出<code>C++ C JAVA Kotlin Dart</code></p> 
<pre><code>val languages:Set&lt;String&gt; = setOf&lt;String&gt;("C++","C","JAVA","Kotlin","Dart","C++")
    languages.forEach {
        print("$it  ")
    }
println()
</code></pre> 
<p>元素读取</p> 
<pre><code>languages.elementAt(0)
</code></pre> 
<p>防止下标越界而导致程序崩溃</p> 
<pre><code>//法一
val result1 = languages.elementAtOrNull(1000) ?: "越界"
//法二
val result2 = languages.elementAtOrElse(1000){
        "越界"
 }
</code></pre> 
<h5><a id="Set_511"></a>可变Set</h5> 
<pre><code> val languages:MutableSet&lt;String&gt; = mutableSetOf&lt;String("C++","C","JAVA","Kotlin","Dart","C++")
    languages += "Basic"
    languages -= "C++"
    languages.forEach {
        print("$it  ")
    }
</code></pre> 
<h4><a id="_522"></a>数组</h4> 
<p>数组定义</p> 
<pre><code>val languages = arrayOf&lt;String&gt;("C++","C","JAVA","Kotlin","Dart","C++") //对象数组
val intNumbers = intArrayOf(1,2,3,4,5)
val doubleNumbers = doubleArrayOf(10.1,11.2,12.1)
val charArray = charArrayOf('a','b','c')
</code></pre> 
<p>读取数组元素</p> 
<pre><code> println(languages[0])

 val result1 = languages.elementAtOrElse(1000){
        "越界"
}

val result2 =languages.elementAtOrNull(1000) ?: "越界"

println(result1)
println(result2)
</code></pre> 
<h4><a id="Map_548"></a>Map</h4> 
<p>map定义</p> 
<pre><code>//法一
val map:Map&lt;String,Int&gt; = mapOf("C" to 1,"C++" to 2,"Kotlin" to 3) 
//法二
val map1:Map&lt;String,Int&gt; = mapOf(Pair("C",1),Pair("C++",2),Pair("Kotlin",3))
</code></pre> 
<p>读取map元素，如果读取map中没有的元素，则返回null</p> 
<pre><code>val value = map["C"]
println(value)
</code></pre> 
<p>定义默认值</p> 
<pre><code>val value = map.getOrDefault("Go",-1)
println(value)
</code></pre> 
<p>通过匿名函数定义错误读取</p> 
<pre><code>val value = map.getOrElse("Go"){
        "没有对应的值"
    }
 println(value)
</code></pre> 
<p>遍历map</p> 
<ul><li>法一</li></ul> 
<pre><code>val map:Map&lt;String,Int&gt; = mapOf("C" to 1,"C++" to 2,"Kotlin" to 3)
 map.forEach { (_, value) -&gt;
        print("$value  ")
}
</code></pre> 
<ul><li>法二</li></ul> 
<pre><code> val map:Map&lt;String,Int&gt; = mapOf("C" to 1,"C++" to 2,"Kotlin" to 3)
 map.forEach {
    print("${it.value}  ")
}
</code></pre> 
<ul><li>法三</li></ul> 
<pre><code>val map:Map&lt;String,Int&gt; = mapOf("C" to 1,"C++" to 2,"Kotlin" to 3) 
for (entry in map) {
    print("${entry.value}  ")
}
</code></pre> 
<h5><a id="Map_611"></a>可变Map</h5> 
<pre><code>val map:MutableMap&lt;String,Int&gt; = mutableMapOf("C" to 1,"C++" to 2,"Kotlin" to 3)
map += Pair("JAVA",4)
map += "Basic" to 5
map -= "C"
 map.forEach { (_, value) -&gt;
        print("$value  ")
}
</code></pre> 
<h3><a id="_623"></a>类</h3> 
<p>在Kotlin中，类的成员属性默认访问权限为public</p> 
<pre><code>class Student{
    var name:String = "Kotlin"
        //下列get和set默认存在
        get() = field
        set(value) {
            field = value
        }

    var sex:Char = 'm'
        get() = field.uppercaseChar()
        set(value) {
            field =value.lowercaseChar()
        }

   private var age:Int = 0
}
fun main() {
    val zhangsan = Student()
    println(zhangsan.name)
}
</code></pre> 
<h4><a id="_650"></a>主构造函数</h4> 
<pre><code>//主构造函数，下列形参为输入类型，不能直接使用，需要通过接收成为变量才能使用
class Student(name: String, age:Int){
    fun print(){
    //此处不能直接调用name
       // println(name)
    }
}
</code></pre> 
<p>通过下列两种方式，主构造函数的形参就可以在类中使用</p> 
<pre><code>//法一
class Student(var name: String, var age:Int){
    fun print(){
        println(name)
    }
}

//法二
class Student(name: String, age:Int){
    var name = name
    var age = age
    fun print(){
        println(name)
    }
}
</code></pre> 
<h4><a id="_682"></a>次构造函数</h4> 
<p>次构造函数必须调用主构造函数</p> 
<pre><code>class Student(name: String){
    var name:String = name
    var age:Int = 0
    var score:Double = 0.0

    //次构造函数必须调用主构造函数
    constructor(name: String,age:Int):this(name){
        this.name = name
        this.age = age
    }

    constructor(name: String,age:Int,score:Double):this(name){
        this.name = name
        this.age = age
        this.score = score
    }
}
fun main() {
    val lisi = Student("李四")
    val zhangsan = Student("张三",20)
    val wangwu = Student("王五",20,50.50)
    println(zhangsan.score)
}
</code></pre> 
<h4><a id="lateinit__712"></a>lateinit 延迟初始化</h4> 
<pre><code>class Student{
    lateinit var name:String

    fun initName(name:String){
        this.name = name
    }

    fun showName(){
        val flag = ::name.isInitialized//判断是否初始化
        if(flag){
            println(name)
        }else{
            println("未初始化name")
        }
    }
}
fun main() {
    println(Student().showName())
}
</code></pre> 
<h4><a id="lazy__736"></a>lazy 惰性初始化</h4> 
<pre><code>class Student{
   //当调用的时候才初始化
    val name:String by lazy { readName() }

    private fun readName(): String {
        println("loading...")
        println("loading...")
        println("loading...")
        return "FranzLiszt"
    }
}
fun main() {
    val zhangsan = Student()
    Thread.sleep(3000)
    println(zhangsan.name)
}
</code></pre> 
<h4><a id="_757"></a>继承和重载</h4> 
<p>在Kotlin中，类默认是final修饰，不能被继承；只有通过open修饰才能被继承</p> 
<pre><code>//类默认是final修饰，不能被继承；只有通过open修饰才能被继承
open class Person(val name:String){
    private fun printfName() = println("parent class name:$name")

    open fun showName() = println(printfName())
}
class Student(val subname:String): Person(subname){
    private fun printfName() = println("sub class name:$name")

    override fun showName()  = printfName()
}
fun main() {
    val person:Person = Student("张三")
    person.showName()
}
</code></pre> 
<h4><a id="companion_objec__779"></a>companion objec 伴生对象</h4> 
<p>伴生对象，与Java的Static类似,同样无论调用多少次，伴生对象只会初始化一次</p> 
<pre><code>class Student(){
    //伴生对象，与Java的Static类似
    companion object{
        private val name = "student"
        
        fun showName() = println(name)
    }
}

fun main() {
    println(Student.showName())
}
</code></pre> 
<h4><a id="_800"></a>内部类</h4> 
<p>内部的类不能访问外部类属性，通过添加inner修饰，成为内部类才能访问</p> 
<pre><code>class Person(name:String){
    val name = name

    //内部的类不能访问外部类属性，通过添加inner修饰，成为内部类才能访问
    inner class Male{
        fun show() = println("male $name")
    }

    inner class Female{
        fun show() = println("female $name")
    }
}

fun main() {
    val p = Person("zs")
    p.Male().show()
}
</code></pre> 
<h4><a id="_824"></a>嵌套类</h4> 
<p>嵌套类的内部的类不能访问外部类属性</p> 
<pre><code>class Person(name:String){
    val name = name
    class Male{
    //不能访问外部类属性
        //fun show() = println("male $name")
    }
    
    class Female{
        fun show() = println("嵌套类")
    }
}

fun main() {
    Person.Female().show()
}
</code></pre> 
<h4><a id="_846"></a>数据类</h4> 
<p>定义数据类</p> 
<pre><code>data class Student(var name:Student,var age:Int)
</code></pre> 
<p>反编译上面的数据类，可以看见除了成员变量的get()、set()函数外，还拓展了拷贝函数、toString()、equals()函数等；比起JAVA的JavaBean更加丰富；其中上述扩展的函数只会覆盖主构造函数的成员属性，不会覆盖次构造函数的成员属性</p> 
<pre><code>public final class Student {
   @NotNull
   private Student name;
   private int age;

   @NotNull
   public final Student getName() {
      return this.name;
   }

   public final void setName(@NotNull Student var1) {
      Intrinsics.checkNotNullParameter(var1, "&lt;set-?&gt;");
      this.name = var1;
   }

   public final int getAge() {
      return this.age;
   }

   public final void setAge(int var1) {
      this.age = var1;
   }

   public Student(@NotNull Student name, int age) {
      Intrinsics.checkNotNullParameter(name, "name");
      super();
      this.name = name;
      this.age = age;
   }

   @NotNull
   public final Student component1() {
      return this.name;
   }

   public final int component2() {
      return this.age;
   }

   @NotNull
   public final Student copy(@NotNull Student name, int age) {
      Intrinsics.checkNotNullParameter(name, "name");
      return new Student(name, age);
   }

   // $FF: synthetic method
   public static Student copy$default(Student var0, Student var1, int var2, int var3, Object var4) {
      if ((var3 &amp; 1) != 0) {
         var1 = var0.name;
      }

      if ((var3 &amp; 2) != 0) {
         var2 = var0.age;
      }

      return var0.copy(var1, var2);
   }

   @NotNull
   public String toString() {
      return "Student(name=" + this.name + ", age=" + this.age + ")";
   }

   public int hashCode() {
      Student var10000 = this.name;
      return (var10000 != null ? var10000.hashCode() : 0) * 31 + Integer.hashCode(this.age);
   }

   public boolean equals(@Nullable Object var1) {
      if (this != var1) {
         if (var1 instanceof Student) {
            Student var2 = (Student)var1;
            if (Intrinsics.areEqual(this.name, var2.name) &amp;&amp; this.age ` var2.age) {
               return true;
            }
         }

         return false;
      } else {
         return true;
      }
   }
}
</code></pre> 
<h3><a id="_942"></a>运算符重载</h3> 
<p>下列列出一些常用的重载运算符</p> 
<table><thead><tr><th align="center">表达式</th><th align="center">翻译为</th></tr></thead><tbody><tr><td align="center">a + b</td><td align="center">a.plus(b)</td></tr><tr><td align="center">a - b</td><td align="center">a.minus(b)</td></tr><tr><td align="center">a * b</td><td align="center">a.times(b)</td></tr><tr><td align="center">a / b</td><td align="center">a.div(b)</td></tr><tr><td align="center">a % b</td><td align="center">a.rem(b)</td></tr><tr><td align="center">a[i]</td><td align="center">a.get(i)</td></tr><tr><td align="center">a += b</td><td align="center">a.plusAssign(b)</td></tr><tr><td align="center">a &gt; b</td><td align="center">a.compareTo(b) &gt; 0</td></tr><tr><td align="center">a &lt; b</td><td align="center">a.compareTo(b) &lt; 0</td></tr><tr><td align="center">a++</td><td align="center">a.inc()</td></tr><tr><td align="center">a–</td><td align="center">a.dec()</td></tr></tbody></table> 
<p>下面重写了加减乘除四个运算符，可以与C++的运算符重载做对比，差异如下</p> 
<ul><li>C++直接对运算符进行重新标识，而Kotlin需要进行转化，例如重载加号运算符，需要改为<code>plus</code>函数</li></ul> 
<pre><code>class Calculation(private val num1:Int){
    //重载加号运算符
    operator fun plus(param:Calculation):Calculation = Calculation(num1+param.num1)

    //重载减号运算符
    operator fun minus(param:Calculation):Calculation = Calculation(num1-param.num1)

    //重载乘号号运算符
    operator fun times(param:Calculation):Calculation = Calculation(num1*param.num1)

    //重载除号运算符
    operator fun div(param:Calculation):Calculation{
        if (param.num1 ` 0 )return Calculation(0)
        return  Calculation(num1/param.num1)
    }

    fun printfNum() = println("num=$num1")
}
fun main(){
    val example1 = Calculation(5)
    val example2 = Calculation(10)
    val result = example1 + example2
    result.printfNum()
}
</code></pre> 
<h3><a id="_991"></a>枚举类</h3> 
<pre><code>data class WeekInfo(var info:String)
enum class Week(private val weekInfo: WeekInfo) {
    Sunday(WeekInfo("星期天")),
    Monday(WeekInfo("星期一")),
    Tuesday(WeekInfo("星期二")),
    Wednesday(WeekInfo("星期三")),
    Thursday(WeekInfo("星期四")),
    Friday(WeekInfo("星期五")),
    Saturday(WeekInfo("星期六"));

    fun show() = println("info = ${weekInfo.info}")

    fun update(weekInfo: WeekInfo){
        this.weekInfo.info = weekInfo.info
        println("info = ${weekInfo.info}")
    }
}
fun main(){
    Week.Friday.show()

    Week.Sunday.update(WeekInfo("XINGQITIAN"))
}
</code></pre> 
<h3><a id="_1018"></a>代数数据类型</h3> 
<pre><code>enum class Judge{
    Bad,
    Mid_Good,
    Superior
}
fun testScore(score: Judge): String =
    when (score) {
        Judge.Bad -&gt; "不及格"
        Judge.Mid_Good -&gt; "良好"
        Judge.Superior -&gt; "优秀"
    }

fun main(){
   println(testScore(Judge.Superior))
}
</code></pre> 
<h3><a id="_1038"></a>密封类</h3> 
<pre><code>sealed class Scores{
    object Fail:Scores()
    object Pass:Scores()
    object Superior:Scores()
}

fun testScore(score: Scores): String =
    when (score) {
        is Scores.Fail -&gt; "不及格"
        is Scores.Pass -&gt; "良好"
        is Scores.Superior -&gt; "优秀"
    }
fun main(){
   println(testScore(Scores.Pass))
}
</code></pre> 
<h3><a id="_1058"></a>接口</h3> 
<p>在Kotlin中，接口实现类不仅要实现其接口的函数，还需要重写其成员变量</p> 
<pre><code>interface Information{
    var name:String
    var age:Int
    fun showInfo()
}

class Student(stuName:String, stuAge:Int):Information{
    override var name: String = stuName
    override var age: Int = stuAge

    override fun showInfo() {
        println("name=$name,age=$age")
    }

}
fun main(){
   val zhangsan:Student = Student("张三",20)
    zhangsan.showInfo()
}
</code></pre> 
<h3><a id="_1084"></a>抽象类</h3> 
<pre><code>abstract class Base{
    fun run(){
        running(getAnimalName())
        eating(getAnimalName())
    }

    abstract fun getAnimalName():String
    abstract fun running(name:String)
    abstract fun eating(name:String)
}

class Cat:Base(){
    override fun getAnimalName(): String = "Cat"

    override fun running(name:String) = println("$name running")

    override fun eating(name:String) = println("$name eating")

    fun show(){
        super.run()
    }

}
fun main(){
   val cat:Cat = Cat()
    cat.show()
}
</code></pre> 
<h3><a id="_1116"></a>泛型类</h3> 
<pre><code>class BasePrintf&lt;T&gt; (private val obj:T){
    fun printf() = println("输出结果:$obj")
}

data class Student(val name:String,val age:Int)
data class Teacher(val name:String,val age:Int,val id:Int)


fun main() {
    val zhangsan = Student("张三",20)
    val lisi = Teacher("李四",30,111)
    BasePrintf(zhangsan).printf()
    BasePrintf(lisi).printf()
    BasePrintf(111).printf()
    BasePrintf("aaa").printf()
}
</code></pre> 
<h3><a id="vararg__1137"></a>vararg 动态参数</h3> 
<pre><code>class Person&lt;T&gt;(private vararg val params:T){
    //out的作用是T只能被读取，不能修改
    private val arrays: Array&lt;out T&gt; = params

    fun show(index:Int): T = arrays[index]

    fun&lt;o&gt; map(index:Int,action:(T)-&gt;o) = action(arrays[index])
}


fun main() {
   val param = Person("Kotlin",20,false,99.99)
    println(param.show(0))
    println(param.show(1))
    param.map(3){
        println(it)
    }
}
</code></pre> 
<h3><a id="_1160"></a>协变&amp;逆变</h3> 
<h4><a id="_1162"></a>协变</h4> 
<ul><li>在泛型前加out，代表此泛型只能被读取不能被修改</li><li>泛型的子类对象可以赋值给泛型的父类对象</li></ul> 
<pre><code>interface Producer&lt;out T&gt;{
    fun produce():T
}
</code></pre> 
<h4><a id="_1173"></a>逆变</h4> 
<ul><li>在泛型前加in，代表此泛型只能被修改不能被读取</li><li>泛型的具体父类可以赋值给泛型声明处的子类</li></ul> 
<pre><code>interface Consumer&lt;in T&gt;{
    fun consumer(param:T)
}
</code></pre> 
<h3><a id="_1184"></a>扩展函数</h3> 
<pre><code>class Student(val name:String,val age:Int)

fun Student.printf() = println("name=$name,age=$age")

fun main() {
   val zhangsan = Student("张三",20)
    zhangsan.printf()
}
</code></pre> 
<h3><a id="_1197"></a>单例模式</h3> 
<h4><a id="_1199"></a>饿汉式</h4> 
<pre><code>object Student
</code></pre> 
<h4><a id="_1205"></a>懒汉式</h4> 
<pre><code>class Student{
    companion object{
        private var instance:Student ? = null
            get() {
                if (field ` null) field = Student()
                return field
            }

        fun getInstanceAction():Student = instance!!
    }
}
</code></pre> 
<h4><a id="_1221"></a>懒汉式-加锁</h4> 
<pre><code>class Student{
    companion object{
        private var instance:Student ? = null
            get() {
                if (field ` null) field = Student()
                return field
            }
        @Synchronized
        fun getInstanceAction():Student = instance!!
    }
}
</code></pre> 
<h4><a id="_1237"></a>懒汉式-双重校验</h4> 
<pre><code>class Student private constructor(){
    companion object{
        val instance:Student by lazy (mode =  LazyThreadSafetyMode.SYNCHRONIZED){Student()}
    }
}

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0678dcead9746b5a7c027c8fc78c6460/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Fabric:使用GoLand&#43;Fabric-SDK-Go操作Fabric网络</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/39283e81ad2c164e0297d37a7eed0345/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023年人工智能行业总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>