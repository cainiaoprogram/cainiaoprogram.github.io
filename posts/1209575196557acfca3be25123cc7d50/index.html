<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TypeScript【可选属性、只读属性、额外的属性检查、函数类型、类类型、继承接口】(四)-全面详解（学习总结---从入门到深化） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TypeScript【可选属性、只读属性、额外的属性检查、函数类型、类类型、继承接口】(四)-全面详解（学习总结---从入门到深化）" />
<meta property="og:description" content="文章目录
接口_可选属性
接口_只读属性
接口_额外的属性检查 接口_ 函数类型 接口_类类型
接口_继承接口
接口_可选属性 接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用 “option bags” 模式时很常用，即给函数传入的参数对象中只有部分属性赋值了 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号 interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig) { let newSquare = { color: &#34;white&#34;, area: 100 } if (config.color) { newSquare.color = config.color; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare; } let mySquare = createSquare({ color: &#34;black&#34; }); console.log(mySquare) 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare 里的 color 属性名拼错，就会得到一个错误提示" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1209575196557acfca3be25123cc7d50/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-19T08:28:24+08:00" />
<meta property="article:modified_time" content="2023-12-19T08:28:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TypeScript【可选属性、只读属性、额外的属性检查、函数类型、类类型、继承接口】(四)-全面详解（学习总结---从入门到深化）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center;"><img alt="" src="https://images2.imgbox.com/85/ed/zMPW322r_o.gif"></h3> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%E6%8E%A5%E5%8F%A3_%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3_%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7" rel="nofollow">接口_可选属性</a></p> 
<p id="%C2%A0%E6%8E%A5%E5%8F%A3_%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%8E%A5%E5%8F%A3_%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7" rel="nofollow"> 接口_只读属性</a></p> 
<p id="%E6%8E%A5%E5%8F%A3_%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3_%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5%C2%A0" rel="nofollow">接口_额外的属性检查 </a></p> 
<p id="%E6%8E%A5%E5%8F%A3_%20%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3_%20%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%C2%A0" rel="nofollow">接口_ 函数类型 </a></p> 
<p id="%C2%A0%E6%8E%A5%E5%8F%A3_%E7%B1%BB%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%8E%A5%E5%8F%A3_%E7%B1%BB%E7%B1%BB%E5%9E%8B" rel="nofollow"> 接口_类类型</a></p> 
<p id="%E6%8E%A5%E5%8F%A3_%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3_%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3" rel="nofollow">接口_继承接口</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E6%8E%A5%E5%8F%A3_%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7">接口_可选属性</h3> 
<h3><img alt="" height="647" src="https://images2.imgbox.com/ec/ae/CGj7cI5N_o.png" width="1200"></h3> 
<p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用 “option bags” 模式时很常用，即给函数传入的参数对象中只有部分属性赋值了 </p> 
<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <span style="color:#fe2c24;"><strong>?</strong></span> 符号 </p> 
<pre><code class="language-TypeScript">interface SquareConfig {
  color?: string;
  width?: number;
}
function createSquare(config: SquareConfig)
{
  let newSquare = {
    color: "white",
    area: 100
 }
  if (config.color) {
    newSquare.color = config.color;
 }
  if (config.width) {
    newSquare.area = config.width * config.width;
 }
  return newSquare;
}
let mySquare = createSquare({ color: "black"
});
console.log(mySquare)</code></pre> 
<p> 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 <span style="color:#fe2c24;"><strong>createSquare</strong></span> 里的 <span style="color:#fe2c24;"><strong>color </strong></span>属性名拼错，就会得到一个错误提示</p> 
<pre><code class="language-TypeScript">interface SquareConfig {
  color?: string;
  width?: number;
}
function createSquare(config:SquareConfig){
  let newSquare = { color: "white", area: 100 };
  if (config.clor) {
    // Error: Property 'clor' does not exist on type 'SquareConfig'
    newSquare.color = config.clor;
 }
  if (config.width) {
    newSquare.area = config.width * config.width;
 }
  return newSquare;
}
let mySquare = createSquare({ color: "black"});</code></pre> 
<h3 id="%C2%A0%E6%8E%A5%E5%8F%A3_%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"> 接口_只读属性</h3> 
<p><img alt="" height="631" src="https://images2.imgbox.com/13/78/Fdy62bcb_o.png" width="1200"></p> 
<p>一些对象属性只能在对象刚刚创建的时候赋值。 你可以在属性名前用<span style="color:#fe2c24;"><strong> readonly</strong></span> 来指定只读属性 </p> 
<p><strong>对象操作 </strong></p> 
<pre><code class="language-TypeScript">interface Point {
  readonly x: number;
  readonly y: number;
}
let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!</code></pre> 
<p><strong> 函数操作</strong></p> 
<pre><code class="language-TypeScript">interface Point {
  readonly x: number;
  readonly y: number;
}
function MyPoint(ps:Point){
  const pt = {
    x:100,
    y:200
 }
  // Cannot assign to 'x' because it is a read-only property.
  ps.x = pt.x;
  ps.y = pt.y
  console.log(ps)
}
MyPoint({ x:100,y:200 })</code></pre> 
<p><span style="color:#fe2c24;"><strong> readonly</strong></span> vs <span style="color:#fe2c24;"><strong>const</strong></span></p> 
<p>最简单判断该用<span style="color:#fe2c24;"><strong> readonly</strong></span> 还是 <span style="color:#fe2c24;"><strong>const</strong></span> 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <span style="color:#fe2c24;"><strong>const </strong></span>，若做为属性则使用 <span style="color:#fe2c24;"><strong>readonly </strong></span></p> 
<h3></h3> 
<h3 id="%E6%8E%A5%E5%8F%A3_%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5%C2%A0">接口_额外的属性检查 </h3> 
<p class="img-center"><img alt="" height="627" src="https://images2.imgbox.com/2a/8a/qLOZdQo6_o.png" width="1200"></p> 
<p>我们知道。接口具有“option bags” 模式，那我们来看下面的例子 </p> 
<p></p> 
<pre><code class="language-TypeScript">interface SquareConfig {
  color?: string;
  width?: number;
}
function createSquare(config: SquareConfig) {
    console.log(config)
}
let mySquare = createSquare({width: 100 });</code></pre> 
<p>现在多了一个需求，在传入的参数中，可能会传入未知参数 <span style="color:#fe2c24;"><strong>colour</strong></span> 因为有“option bags” 模式，会不会允许我们传入未知参数呢？</p> 
<pre><code class="language-TypeScript">interface SquareConfig {
  color?: string;
  width?: number;
}
function createSquare(config: SquareConfig) { }
let mySquare = createSquare({ colour: "red",width: 100 });</code></pre> 
<p>然而，TypeScript 会认为这段代码可能存在 bug<br> 对象字面量会被特殊对待而且会经过“额外属性检查”，你会得到一个错误</p> 
<pre><code class="language-TypeScript">error: Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?</code></pre> 
<p> 我们可以通过添加额外属性的方式解决这个问题</p> 
<pre><code class="language-TypeScript">interface SquareConfig {
  color?: string;
  width?: number;
 [propName: string]: any;
}
function createSquare(config: SquareConfig)
{
  console.log(config)
}
let mySquare = createSquare({ colour: "red", width: 100 });</code></pre> 
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <span style="color:#fe2c24;"><strong>squareOptions </strong></span>不会经过额外属性检查，所以编译器不会报错</p> 
<p></p> 
<pre><code class="language-TypeScript">interface SquareConfig {
  color?: string;
  width?: number;
}
function createSquare(config: SquareConfig)
{
  console.log(config)
}
const squareObj = { colour: "red", width: 100 }
let mySquare = createSquare(squareObj);</code></pre> 
<p>要留意，在像上面一样的代码里，你可能不应该去绕开这些检查，这不利于代码可读性与纠错性</p> 
<p></p> 
<h3 id="%E6%8E%A5%E5%8F%A3_%20%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%C2%A0">接口_ 函数类型 </h3> 
<p><img alt="" height="643" src="https://images2.imgbox.com/69/cc/9W7WU4gZ_o.png" width="1200"></p> 
<p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型</p> 
<pre><code class="language-TypeScript">interface SearchFunc {
 (source: string, subString: string)
}</code></pre> 
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口</p> 
<pre><code class="language-TypeScript">let mySearch: SearchFunc;
mySearch = function (source: string, subString: string) {
  console.log(source,subString)
};
mySearch("Hello","World")</code></pre> 
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配</p> 
<pre><code class="language-TypeScript">interface SearchFunc {
 (source: string, subString: string)
}
let mySearch: SearchFunc;
mySearch = function (sou: string, sub: string) {
  console.log(sou,sub)
}
mySearch("Hello","World")</code></pre> 
<h3 id="%C2%A0%E6%8E%A5%E5%8F%A3_%E7%B1%BB%E7%B1%BB%E5%9E%8B"> 接口_类类型</h3> 
<p class="img-center"><img alt="" height="628" src="https://images2.imgbox.com/6d/cf/sG00wTqI_o.png" width="1200"></p> 
<p>与传统面向对象里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约 </p> 
<p></p> 
<pre><code class="language-TypeScript">interface UserInterface {
  job:string
}
class Teacher implements UserInterface {
  public job:string
  public name:string
  public age:string
  constructor(name,age){
    this.name = name;
    this.age = age
 }
}</code></pre> 
<p>你也可以在接口中描述一个方法，在类里实现它</p> 
<pre><code class="language-TypeScript">interface UserInterface {
  job:string
  sayHello(j:string):void
}
class Teacher implements UserInterface {
  public job:string
  public name:string
  public age:string
  constructor(name,age){
    this.name = name;
    this.age = age
 }
  sayHello(j: string) {
    this.job = j
    console.log(j,this.name,this.age)
 }
}
const t = new Teacher("张三","20");
t.sayHello("itxiaotong")</code></pre> 
<h3 id="%E6%8E%A5%E5%8F%A3_%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3">接口_继承接口</h3> 
<p class="img-center"><img alt="" height="637" src="https://images2.imgbox.com/4a/bc/aCnmfTKT_o.png" width="1200"></p> 
<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里 </p> 
<pre><code class="language-TypeScript">interface Info{
  name:string
  age:number
}
interface Job extends Info{
  job:string
}
function user(userInfo:Job){
  console.log(userInfo)
}
user({ name:"iwen",age:20,job:"itxiaotong" })</code></pre> 
<p> 一个接口可以继承多个接口，创建出多个接口的合成接口</p> 
<pre><code class="language-TypeScript">interface Info{ 
  name:string
  age:number
}
interface Num{
  num:number
}
interface Job extends Info,Num{
  job:string
}
function user(userInfo:Job){
  console.log(userInfo)
}
user({
    name:"iwen",age:20,job:"itbaizhan",num:1001
})</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/50b99c153a26f634df1c92dff20b3dda/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《十堂课学习 Flink》第五章：Table API 以及 Flink SQL 入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e06b8d0df8089ef887f01cafaebf41a5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">成功解决kaggle注册报错Captcha must be filled out.（Microsoft Edge浏览器）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>