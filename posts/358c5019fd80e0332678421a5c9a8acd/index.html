<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于C语言的malloc函数以及内存泄漏的问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于C语言的malloc函数以及内存泄漏的问题" />
<meta property="og:description" content="malloc函数
malloc函数的原型：
（void *）malloc（int size）
malloc函数的返回值是一个void类型的指针，参数为int类型的数据，即申请分配的内存大小，单位是字节。内存分配成功之后，malloc函数返回这块内存的首地址，你需要一个指针来接受这个地址。但是由于函数的返回值是void *类型，所以必须强制转换成你所接收的类型。也就是说这块内存将来要用来存储什么类型的数据，比如
char *p = (char *)malloc(100);
在堆上分配了100个字节的内存，返回这块内存的首地址，把地址强制转换成char *类型后，赋给char *类型的指针变量p;同时告诉我们这块内存将用来存储char类型的数据。也就是说你只能通过指针变量p来操作这块内存。这块内存本身没有名字，对它的访问是匿名访问
使用malloc函数同样要注意这点：如果所申请的内存块大于目前堆上剩余的内存块（整块），则内存分配就会失败，函数函数NULL。注意这里说的是“堆上剩余内存块”不是所有剩余内存块之和，因为malloc函数申请的是连续的一块内存。既然malloc函数申请内存又不成功的可能，那我们在使用指向这块内存的指针时，必须用if( NULL != p)语句上来验证内存分配确实成功了。
内存泄漏
在C语言程序设计中，内存泄漏几乎是很难避免的，C程序产生泄漏内存，则运行速度会逐渐变慢，并最终停止运行；如果产生覆盖内存，程序会变得非常脆弱，很容易受到恶意用户的攻击。内存泄漏是一种隐性危害，它们很难被发现，通常不能在相应的源代码中找到错误，需要仔细分析与专门的检测工具才能发现。
（1）内存泄漏的定义
通常我们所说的内存泄漏，是指分配出去的内存在使用之后没有释放掉，没有回收，长此以往，会造成没有足够的内存可以分配。一般表现为运行时间越长，占用的内存越多，最终导致系统奔溃。一般的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显式释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。
（2）内存泄漏的原因
2.1 C语言内存分配情况 在C语言中，根据数据在内存中存在的时间（生存周期）不同，将内存空间分为三个区：
1）程序区：用于存储程序的代码，即程序的二进制代码。
2）静态存储区：用于存储全局变量和静态变量，这些变量的空间在程序编译时就已经分配好了。
3）动态存储区：用于在程序执行时分配的内存，又分为：堆区（heap）和栈区（stack）。堆区:用于动态内存 分配，程序运行时由内存分配函数在堆上分配内存。在C语言中，只能使用指针才能动态的分配内存。栈区:在 函数执行时，函数内部的局部变量和函数参数的存储单元的内存区域，函数运行结束时，这些内存区域会自动释 放。 2.2 C语言动态内存分配 在C语言中用内存分配函数来实现内存的动态分配，这些函数有：malloc()和realloc()等函数。malloc():使用这个 函数时需要包含头文件。使用该函数需要指定要分配的内存字节数作为参数，例如： int *pNumber=（int *） malloc（100） 这条语句分配了100个字节的内存，并把这个内存块的地址赋给pNumber，这个内存块可以保存最大25个int值， 每个int占4个字节。如果不能分配请求的内存，malloc（）会返回一个null指针。 2.3 释放动态分配的内存 堆上分配的内存会在整个应用程序结束之后，由操作系统负责回收，但最好是在使用完这些内存后立即释放。如 果不释放，会引起内存泄漏，极大占用系统资源，可能会产生各种未知的错误。所以，必须使用free（）函数释 放内存，参数是内存地址（指针），例如：free（pNumber），依上例。 （3）内存泄漏避免的方法 3.1正确使用malloc函数分配内存 malloc是一个函数，专门用来从堆上分配内存。使用malloc函数需要几个要求：内存分配给谁？分配多大内存？ 是否还有足够内存分配？ 内存将用来存储什么格式的数据？分配好的内存在哪里？ 如果这5点都确定，那内存就 能分配。下面看看malloc的原型：（void *）malloc（int size） malloc函数的返回值是一个void类型的指针，参数为int类型的数据，即申请分配的内存大小，单位是字节。内存 分配成功之后，malloc函数返回这块内存的首地址，你需要一个指针来接受这个地址。也就是说这块内存将来要 用来存储什么类型的数据，如： char *p = （char *）malloc（100） 在堆内存分配了100个字节的内存，返回这块内存的首地址，把地址强制转换成char *类型后赋给char *类型的指 针变量p；同时告诉我们这块内存将用来存储char类型的数据。你只能通过指针变量p来操作这块内存，这块内存 本身没有名字，对它的访问是匿名访问。但是，不一定每次malloc函数都能成功分配到内存。既然malloc函数申 请内存存在不成功的可能，那我们在使用指向这块内存的指针时，必须用if（ NULL ！= p）语句上来验证内存分 配确实成功了。 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/358c5019fd80e0332678421a5c9a8acd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-02-25T11:43:51+08:00" />
<meta property="article:modified_time" content="2017-02-25T11:43:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于C语言的malloc函数以及内存泄漏的问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px; color:#ff0000"><strong>malloc函数</strong></span></p> 
<p><span style="font-size:18px"><strong><span style="color:#3333ff">malloc函数的原型：</span></strong></span></p> 
<p><span style="font-size:18px"><strong><span style="color:#3333ff">（void *）malloc（int size）</span><br> </strong></span></p> 
<p><span style="font-size:18px"> malloc函数的返回值是一个void类型的指针，参数为int类型的数据，即申请分配的内存大小，单位是字节。内存分配成功之后，malloc函数返回这块内存的首地址，你需要一个指针来接受这个地址。但是由于函数的返回值是void *类型，所以必须强制转换成你所接收的类型。也就是说这块内存将来要用来存储什么类型的数据，比如</span></p> 
<span style="font-size:18px"><span style="color:#33cc00"><strong>char *p = (char *)malloc(100);</strong></span><br> </span> 
<p><span style="font-size:18px">在堆上分配了100个字节的内存，返回这块内存的首地址，把地址强制转换成char *类型后，赋给char *类型的指针变量p;同时告诉我们这块内存将用来存储char类型的数据。也就是说你只能通过指针变量p来操作这块内存。这块内存本身没有名字，对它的访问是匿名访问</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">使用<span style="color:#ff0000">malloc</span>函数同样要注意这点：如果所申请的内存块<span style="color:#3366ff"><strong>大于</strong></span>目前堆上剩余的内存块（整块），则内存分配就会失败，函数函数NULL。注意这里说的是“堆上剩余内存块”不是所有剩余内存块之和，因为malloc函数申请的是<span style="color:#ff0000"><strong>连续</strong></span>的一块内存。既然malloc函数申请内存又不成功的可能，那我们在使用指向这块内存的指针时，必须用<span style="color:#006600"><strong>if( NULL != p)</strong></span>语句上来验证内存分配确实成功了。<br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px; color:#333333"><strong style="background-color:rgb(255,255,51)">内存泄漏</strong></span></p> 
<p><span style="font-size:18px; color:#333333"><strong style="background-color:rgb(255,255,255)">在C语言程序设计中，内存泄漏几乎是很难避免的，C程序产生泄漏内存，则运行速度会逐渐变慢，并最终停止运行；如果产生覆盖内存，程序会变得非常脆弱，很容易受到恶意用户的攻击。内存泄漏是一种隐性危害，它们很难被发现，通常不能在相应的源代码中找到错误，需要仔细分析与专门的检测工具才能发现。<br> </strong></span></p> 
<p><span style="font-size:18px; color:#3333ff"><strong style="background-color:rgb(255,255,255)">（1）内存泄漏的定义</strong></span></p> 
<p><span style="font-size:18px; color:#333333"><span style="background-color:rgb(255,255,255)">通常我们所说的内存泄漏，是指分配出去的内存在使用之后没有释放掉，没有回收，长此以往，会造成没有足够的内存可以分配。一般表现为运行时间越长，占用的内存越多，最终导致系统奔溃。一般的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显式释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。<br> </span></span></p> 
<p><span style="font-size:18px; color:#333333"><span style="background-color:rgb(255,255,255)"><br> </span></span></p> 
<p><span style="font-size:18px"><span style="background-color:rgb(255,255,255)"><span style="color:#3333ff"><strong>（2）内存泄漏的原因</strong></span></span></span></p> 
<p><span style="font-size:18px"><span style="white-space:pre"></span><span style="color:#ff0000">2.1 C语言内存分配情况</span> <br> 　　在C语言中，根据数据在内存中存在的时间（生存周期）不同，将内存空间分为三个区：</span></p> 
<p><span style="font-size:18px"><span style="white-space:pre"></span><span style="color:#009900"><strong>1）程序区</strong></span>：用于存储程序的代码，即程序的二进制代码。</span></p> 
<p><span style="font-size:18px"><span style="white-space:pre"></span><strong><span style="color:#009900">2）静态存储区</span></strong>：用于存储全局变量和静态变量，这些变量的空间在程序编译时就已经分配好了。</span></p> 
<p><span style="font-size:18px"><span style="white-space:pre"></span><strong><span style="color:#009900">3）动态存储区</span></strong>：用于在程序执行时分配的内存，又分为：堆区（heap）和栈区（stack）。堆区:用于动态内存<span style="white-space:pre"> </span>分配，程序运行时由内存分配函数在堆上分配内存。在C语言中，只能使用指针才能动态的分配内存。栈区:在<span style="white-space:pre"> </span>函数执行时，函数内部的局部变量和函数参数的存储单元的内存区域，函数运行结束时，这些内存区域会自动释<span style="white-space:pre"> </span>放。 <br> 　　<span style="color:#ff0000">2.2 C语言动态内存分配 </span><br> 　　在C语言中用内存分配函数来实现内存的动态分配，这些函数有：malloc()和realloc()等函数。malloc():使用这个<span style="white-space:pre"> </span>函数时需要包含头文件。使用该函数需要指定要分配的内存字节数作为参数，例如： <br> 　　int *pNumber=（int *） malloc（100） <br> 　　这条语句分配了100个字节的内存，并把这个内存块的地址赋给pNumber，这个内存块可以保存最大25个int值，<span style="white-space:pre"> </span>每个int占4个字节。如果不能分配请求的内存，malloc（）会返回一个null指针。 <br> 　　<span style="color:#ff0000">2.3 释放动态分配的内存 </span><br> 　　堆上分配的内存会在整个应用程序结束之后，由操作系统负责回收，但最好是在使用完这些内存后立即释放。如<span style="white-space:pre"> </span>果不释放，会引起内存泄漏，极大占用系统资源，可能会产生各种未知的错误。所以，必须使用free（）函数释<span style="white-space:pre"> </span>放内存，参数是内存地址（指针），例如：free（pNumber），依上例。 <br> </span></p> 
<p><span style="font-size:18px"><span style="color:#3333ff"><strong>（3）内存泄漏避免的方法 </strong></span></span></p> 
<p><span style="font-size:18px"><span style="color:rgb(102,51,102); white-space:pre"></span><span style="color:#cc33cc">3.1正确使用malloc函数分配内存 </span><br> 　　malloc是一个函数，专门用来从堆上分配内存。使用malloc函数需要几个要求：内存分配给谁？分配多大内存？<span style="white-space:pre"> </span>是否还有足够内存分配？ 内存将用来存储什么格式的数据？分配好的内存在哪里？ 如果这5点都确定，那内存就<span style="white-space:pre"> </span>能分配。下面看看malloc的原型：（void *）malloc（int size） <br> 　　malloc函数的返回值是一个void类型的指针，参数为int类型的数据，即申请分配的内存大小，单位是字节。内存<span style="white-space:pre"> </span>分配成功之后，malloc函数返回这块内存的首地址，你需要一个指针来接受这个地址。也就是说这块内存将来要<span style="white-space:pre"> </span>用来存储什么类型的数据，如： <br> 　　char *p = （char *）malloc（100） <br> 　　在堆内存分配了100个字节的内存，返回这块内存的首地址，把地址强制转换成char *类型后赋给char *类型的指<span style="white-space:pre"> </span>针变量p；同时告诉我们这块内存将用来存储char类型的数据。你只能通过指针变量p来操作这块内存，这块内存<span style="white-space:pre"> </span>本身没有名字，对它的访问是匿名访问。但是，不一定每次malloc函数都能成功分配到内存。既然malloc函数申<span style="white-space:pre"> </span>请内存存在不成功的可能，那我们在使用指向这块内存的指针时，必须用if（ NULL ！= p）语句上来验证内存分<span style="white-space:pre"> </span>配确实成功了。 </span></p> 
<p><span style="font-size:18px"><br> 　<span style="color:#6633ff">　</span><span style="color:#cc33cc">3.2 正确使用free函数释放内存 </span><br> 　　既然有分配，那就必须有释放，不然的话，有限的内存就会用光，而没有释放的内存却占用空间，与malloc对应<span style="white-space:pre"> </span>的就是free函数了。free函数只有一个参数，就是所要释放的内存块的首地址（指针）。按上例，则<span style="white-space:pre"> </span>为:free(p).free函数其实它就做了一件事：斩断指针变量和这块内存的对应关系。free函数就是把这块内存和p<span style="white-space:pre"> </span>之间的关系斩断；p本身的值并没有改变或者消失，即指针变量p本身保存的地址并没有改变，那块被释放的内存<span style="white-space:pre"> </span>里面保存的值也没有改变。这就是free函数的功能，一个malloc对应一个free，是一夫一妻制。在使用free（p）<span style="white-space:pre"> </span>函数内存释放后，指针变量p本身保存的地址并没有改变，那我们必须需重新把p的值变为NULL：p = NULL。如<span style="white-space:pre"> </span>果没有把该指针置NULL，这个指针就成为了“悬空指针”，这是很危险的，且也是经常出错的地方。 <br> </span></p> 
<p><span style="font-size:18px"></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c784df3157d8ac8ab06a4c0eceacb8b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mycat入门教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/436ca0c57e94e7df5a26cf0e555f2f7e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">最长单调递增子序列的三种解法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>