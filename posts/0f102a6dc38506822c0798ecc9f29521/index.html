<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件构造Lab2实验要求总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件构造Lab2实验要求总结" />
<meta property="og:description" content="Problem 1: Test Graph 现在只测试string类型的顶点，之后会测试更多的类型（泛型）。
在GraphStaticTest.java中写static Graph.empty()的测试策略和测试方法，由于这种方法是静态的，所以它只需要一次实现。而且测试用例已经提供了，可以不用改。
在GraphInstanceTest.java写所有的为instance methods（实例方法）实现的测试策略以及测试，在这些测试中，只能使用emptyInstance()方法来获得一个空图，就像testInitialVerticesEmpty()中写的那样。
GraphStaticTest和其他的junit test一样，但GraphInstanceTest不同，它是一个抽象类，而且你不能直接运行它，需要首先实现emptyInstance()方法，而在下一个问题中，会有GraphInstanceTest方法的两个子类，返回不同的空图。
在GraphInstanceTest中实现的test必须满足Graph的说明书，任何对应于相应实现的测试，在下一个问题中，都会进入GraphInstanceTest方法的两个子类。
Problem 2: Implement Graph 两次实现以string为顶点的带权有向图 ，对于每一个类，都要写AF, RI, how the type prevents rep exposure；同时实现checkRep来检查RI；实现toString，以人类可读的方式展示抽象变量。
今后的编程中，你写的每一个不可变类型，都应该重写equals和hashcode，以实现对象之间的契约，但是在这个问题中不要求。
每一个类都必须有清晰的类型说明书，这意味着每一个方法都有一个javadoc文档，除了当你用@override时，什么时候用@override呢：
当一个方法在接口中说明了，然后你在一个具体的类中实现了它，这个时候就用@override，不用再加说明。
ConcreteEdgesGraph和ConcreteVerticesGraph之间不应该有任何依赖关系和代码共享。
在ConcreteEdgesGraph中，必须使用
private final Set vertices = new HashSet&lt;&gt;();
private final List edges = new ArrayList&lt;&gt;();
不能加域，也不能减域。
在edge类中，需要定义specification 和 representation，同时，edge必须是不可变的。
一般来说，实现不可变类型意味着实现equals和hashcode，但在这个问题中不要求，当心！这意味着你不能用equals方法来比较edge的实例化对象，如果你需要比较edge的实例化对象的话，自己实现一个observer方法并对其进行说明。
在完成说明之后，在Concrete¬EdgesGraphTest.java中设计、写文档并实现对Edge的test。
然后紧接着实现Edge 和 ConcreteEdgesGraph，要保证在toString方法中使用@Override，应该对ConcreteEdgesGraph中的toString()方法实现更强的说明并且在Concrete¬EdgesGraphTest.java中对该方法实现测试，只能在Concrete-EdgesGraphTest.java中，不能在GraphInstanceTest中，GraphInstanceTest是用来测试Graph的。
Implement ConcreteVerticesGraph
必须使用如下表示（REP）：
private final List vertices = new ArrayList&lt;&gt;();不能在该REP中加其他的域，对于Vertex类，自己定义说明和REP，Vertex必须是可变的。
在决定了Vertex类的说明后，在Concrete¬VerticesGraphTest.java中设计、说明并实现对Vertex的test。
然后紧接着实现Vertex和ConcreteVerticesGraph。
你应该加强ConcreteVerticesGraph.toString()的说明，然后在Concrete-VerticesGraphTest中写它的测试，不要把测试写在GraphInstanceTest中，GraphInstanceTest是用来测试Graph的。
Problem 3: Implement generic Graph 说明只要求顶点是”不可变的”以及“用equals方法来比较”" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0f102a6dc38506822c0798ecc9f29521/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-20T23:25:46+08:00" />
<meta property="article:modified_time" content="2019-06-20T23:25:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件构造Lab2实验要求总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Problem_1_Test_GraphString_0"></a>Problem 1: Test Graph</h3> 
<p>现在只测试string类型的顶点，之后会测试更多的类型（泛型）。</p> 
<p>在GraphStaticTest.java中写static Graph.empty()的测试策略和测试方法，由于这种方法是静态的，所以它只需要一次实现。而且测试用例已经提供了，可以不用改。</p> 
<p>在GraphInstanceTest.java写所有的为instance methods（实例方法）实现的测试策略以及测试，在这些测试中，只能使用emptyInstance()方法来获得一个空图，就像testInitialVerticesEmpty()中写的那样。</p> 
<p>GraphStaticTest和其他的junit test一样，但GraphInstanceTest不同，它是一个抽象类，而且你不能直接运行它，需要首先实现emptyInstance()方法，而在下一个问题中，会有GraphInstanceTest方法的两个子类，返回不同的空图。</p> 
<p>在GraphInstanceTest中实现的test必须满足Graph的说明书，任何对应于相应实现的测试，在下一个问题中，都会进入GraphInstanceTest方法的两个子类。</p> 
<h3><a id="Problem_2_Implement_GraphString_12"></a>Problem 2: Implement Graph</h3> 
<p>两次实现以string为顶点的带权有向图 ，对于每一个类，都要写AF, RI, how the type prevents rep exposure；同时实现checkRep来检查RI；实现toString，以人类可读的方式展示抽象变量。</p> 
<p>今后的编程中，你写的每一个不可变类型，都应该重写equals和hashcode，以实现对象之间的契约，但是在这个问题中不要求。</p> 
<p>每一个类都必须有清晰的类型说明书，这意味着每一个方法都有一个javadoc文档，除了当你用@override时，什么时候用@override呢：</p> 
<p>当一个方法在接口中说明了，然后你在一个具体的类中实现了它，这个时候就用@override，不用再加说明。</p> 
<p>ConcreteEdgesGraph和ConcreteVerticesGraph之间不应该有任何依赖关系和代码共享。</p> 
<p>在ConcreteEdgesGraph中，必须使用<br> private final Set vertices = new HashSet&lt;&gt;();<br> private final List edges = new ArrayList&lt;&gt;();<br> 不能加域，也不能减域。</p> 
<p>在edge类中，需要定义specification 和 representation，同时，edge必须是不可变的。</p> 
<p>一般来说，实现不可变类型意味着实现equals和hashcode，但在这个问题中不要求，当心！这意味着你不能用equals方法来比较edge的实例化对象，如果你需要比较edge的实例化对象的话，自己实现一个observer方法并对其进行说明。</p> 
<p>在完成说明之后，在Concrete¬EdgesGraphTest.java中设计、写文档并实现对Edge的test。</p> 
<p>然后紧接着实现Edge 和 ConcreteEdgesGraph，要保证在toString方法中使用@Override，应该对ConcreteEdgesGraph中的toString()方法实现更强的说明并且在Concrete¬EdgesGraphTest.java中对该方法实现测试，只能在Concrete-EdgesGraphTest.java中，不能在GraphInstanceTest中，GraphInstanceTest是用来测试Graph的。</p> 
<p>Implement ConcreteVerticesGraph<br> 必须使用如下表示（REP）：<br> private final List vertices = new ArrayList&lt;&gt;();不能在该REP中加其他的域，对于Vertex类，自己定义说明和REP，Vertex必须是可变的。</p> 
<p>在决定了Vertex类的说明后，在Concrete¬VerticesGraphTest.java中设计、说明并实现对Vertex的test。</p> 
<p>然后紧接着实现Vertex和ConcreteVerticesGraph。</p> 
<p>你应该加强ConcreteVerticesGraph.toString()的说明，然后在Concrete-VerticesGraphTest中写它的测试，不要把测试写在GraphInstanceTest中，GraphInstanceTest是用来测试Graph的。</p> 
<h3><a id="Problem_3_Implement_generic_GraphL_45"></a>Problem 3: Implement generic Graph</h3> 
<p>说明只要求顶点是”不可变的”以及“用equals方法来比较”</p> 
<h4><a id="31_Make_the_implementations_generic_47"></a>3.1. Make the implementations generic（把它变成泛型）</h4> 
<p>a.将特定类的声明变成：<br> public class ConcreteEdgesGraph implements Graph { … }<br> class Edge { … }<br> 以及<br> public class ConcreteVerticesGraph implements Graph { … }<br> class Vertex { … }</p> 
<p>b.更新你的两个实现，来支持任意类型的顶点的类型，使用L作为占位符而不是String，粗劣的说，把代码中的所有String改成L。</p> 
<p>Edge 、List会变成Edge、 List&lt;Edge&gt;，<br> 根据说明，你可以使用&lt;&gt;来避免写两次类型参数。</p> 
<h4><a id="32_Implement_Graphempty_59"></a>3.2. Implement Graph.empty()</h4> 
<p>a.选择Graph其中一种的实现，来给客户使用，然后实现Graph.empty()，和ArrayList与 LinkedList不同，客户如果想要一个list，必须调用一个具体的构造方法，然后忍受一系列的表示泄露，Graph的客户不需要意识到我们是怎么去实现它的。</p> 
<p>b.由于Graph的实现并不在意顶点的确切类型，我们的测试只使用String类型的顶点就够了。<br> 由于这是第一次实现泛型，GraphStaticTest.java中需要加入一些其他类型的顶点类型（不可变）。</p> 
<p>以上几步都完成后，程序中应该没有warning的字样。</p> 
<h3><a id="Problem_4_Poetic_walks_69"></a>Problem 4: Poetic walks</h3> 
<p>图适合用来创作诗歌。<br> GraphPoet的说明书解释了诗歌是如何由一个文本文件初始化，然后，对于一段输入的文字，使用由文本文件生成的“单词邻接表”，将这段文字诗意的转化。<br> “单词邻接表”中的顶点：<br> 1.大小写不敏感。<br> 2.边权值是按顺序邻接计数。</p> 
<h4><a id="41_Test_GraphPoet_79"></a>4.1. Test GraphPoet</h4> 
<p>设计、写文档、并实现GraphPoet的test，可以在GraphPoet中添加额外的方法，但是不能改变已要求方法的签名。可以增强对已要求方法的说明，但是不能减弱它们。注意，这可能意味着您对GraphPoet的测试不能用于其他人的实现，因为您已经增强或添加了规范。</p> 
<p>你的测试需要用到一个或多个corpus files，把这些files放在test/poet目录下，引用它们的时候，使用new File(“test/poet/seven-words.txt”)。</p> 
<p>虽然您仍然必须测试和实现GraphPoet(File)，但请记住，您可能会向GraphPoet添加操作。例如，添加一个接受字符串的创建器，可能会简化对poem(…)的测试，而代价是为新创建器添加额外的测试。</p> 
<h4><a id="42_Implement_GraphPoet_87"></a>4.2. Implement GraphPoet</h4> 
<p>你必须使用Graph作为GraphPoet的表示，GraphPoet只应该依赖于Graph的说明书，而不是依赖于Graph某种特定实现的细节。除此之外，GraphPoet的实现完全取决于你。<br> 为了读入文件，至少有三种JAVA API可以考虑。</p> 
<h4><a id="43_Graph_poetry_slam_94"></a>4.3. Graph poetry slam</h4> 
<p>如果你想的话，用一个很酷的例子更新main方法，文本文件需要放在目录src/poet下。</p> 
<h3><a id="Before_youre_done_99"></a>Before you’re done</h3> 
<p>确保你已经写完了说明书，为所有的类型和方法，以正确的Javadoc注释的形式。</p> 
<p>对所有的实现，确保已经写完了AF和RI，同时根据RI说明怎样防止表示泄露。</p> 
<p>确保所有的类型都使用checkRep来检查RI，同时在ToString中通过人类可读的方式展现抽象变量。</p> 
<p>为了获得正确签名的静态检查，重写ToString时，使用@Override。</p> 
<p>某个类实现接口方法时，也要使用@Override，来提醒读者他们从哪里可以得到<br> 这个方法的说明书。</p> 
<p>确保为每种类型都有一个完整的、有原则的测试套件。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4208aa76840aa4a366aa6af38ae1a37c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">镭速——FTP服务器概念详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c67ef3f06cdb00ee7321f9c549aa9a6f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CPN:Cascaded Pyramid Network for Multi-Person Pose Estimation_及CPN实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>