<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FreeSwitch 使用keepalived进行主备切换高可用部署 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FreeSwitch 使用keepalived进行主备切换高可用部署" />
<meta property="og:description" content="FreeSWITCH的高可用部署方式有两种：主备切换和负载均衡，官方文档介绍的主备切换部署是采用Corosync &amp; Pacemaker，负载均衡采用前置opensips。但对使用keepalived进行主备切换的高可用方式没有介绍，同时网上对该种部署方式也没有介绍。
本人对Corosync &amp; Pacemaker不熟悉，目前在职的公司web应用大部分采用keepalived&#43;haproxy，所以对keepalived稍微熟悉一点，因此尝试使用keepalived进行freeswitch进行主备切换的高可用部署。
使用keepalived进行freeswitch进行主备切换的高可用部署比较简单，本文介绍的部署方案有两个亮点（自以为）：1、主节点不抢占VIP，否则可能导致主节点恢复后VIP切换导致正在交互的SIP信令处理失败；2、FS可用性检测脚本和主备切换后话务接管脚本。
一、前提 1、freeswicth和keepalived均能通过服务启动；
2、两个节点freeswitch连接同一个mysql数据库；
二、环境 OS：Red Hat Enterprise Linux Server release 7.9
A节点IP：100.207.104.77
B节点IP：100.207.104.78
VIP：100.207.104.89
freeswitch域名：callcenter.xxxxx.com ---域名也可以直接使用VIP ，---域名暂无启用。
三、配置 3.1、允许应用绑定非本机IP
在两个节点均执行以下命令：
echo &#39;net.ipv4.ip_nonlocal_bind=1&#39; &gt;&gt; /etc/sysctl.conf
cat &gt; /etc/sysctl.conf &lt;&lt; EOF # sysctl settings are defined through files in # /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/. # # Vendors settings live in /usr/lib/sysctl.d/. # To override a whole file, create a new file with the same in # /etc/sysctl." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/001614710e45c90a5c7d5c2987c51224/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-15T18:18:55+08:00" />
<meta property="article:modified_time" content="2023-08-15T18:18:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FreeSwitch 使用keepalived进行主备切换高可用部署</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>FreeSWITCH的高可用部署方式有两种：主备切换和负载均衡，官方文档介绍的主备切换部署是采用Corosync &amp; Pacemaker，负载均衡采用前置opensips。但对使用keepalived进行主备切换的高可用方式没有介绍，同时网上对该种部署方式也没有介绍。</p> 
<p>本人对Corosync &amp; Pacemaker不熟悉，目前在职的公司web应用大部分采用keepalived+haproxy，所以对keepalived稍微熟悉一点，因此尝试使用keepalived进行freeswitch进行主备切换的高可用部署。</p> 
<p>使用keepalived进行freeswitch进行主备切换的高可用部署比较简单，本文介绍的部署方案有两个亮点（自以为）：1、主节点不抢占VIP，否则可能导致主节点恢复后VIP切换导致正在交互的SIP信令处理失败；2、FS可用性检测脚本和主备切换后话务接管脚本。</p> 
<h4>一、前提</h4> 
<p>1、freeswicth和keepalived均能通过服务启动；</p> 
<p>2、两个节点freeswitch连接同一个mysql数据库；</p> 
<h4>二、环境</h4> 
<p>OS：Red Hat Enterprise Linux Server release 7.9</p> 
<p>A节点IP：100.207.104.77</p> 
<p>B节点IP：100.207.104.78</p> 
<p>VIP：100.207.104.89</p> 
<p>freeswitch域名：callcenter.xxxxx.com  ---域名也可以直接使用VIP ，---域名暂无启用。</p> 
<h4 style="background-color:transparent;">三、配置</h4> 
<p><strong>3.1、允许应用绑定非本机IP</strong></p> 
<p>在两个节点均执行以下命令：</p> 
<p>echo 'net.ipv4.ip_nonlocal_bind=1' &gt;&gt; /etc/sysctl.conf</p> 
<pre><code class="language-bash"> cat &gt; /etc/sysctl.conf &lt;&lt; EOF
# sysctl settings are defined through files in
# /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.
#
# Vendors settings live in /usr/lib/sysctl.d/.
# To override a whole file, create a new file with the same in
# /etc/sysctl.d/ and put new settings there. To override
# only specific settings, add a file with a lexically later
# name in /etc/sysctl.d/ and put new settings there.
#
# For more information, see sysctl.conf(5) and sysctl.d(5).
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
kernel.sysrq = 1
kernel.pid_max = 524288
fs.file-max = 6553600
kernel.sem = 500 256000 250 8192
net.ipv4.ip_local_port_range = 10000 65000
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 0
net.ipv4.tcp_timestamps = 0
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_keepalive_time = 1800
net.ipv4.tcp_retries2 = 5
net.core.rmem_default = 1048576
net.core.rmem_max = 1048576
net.core.wmem_default = 262144
net.core.wmem_max = 262144
net.core.somaxconn = 1024
vm.swappiness = 0
net.ipv4.ip_nonlocal_bind=1
net.ipv4.neigh.default.gc_thresh1 = 10240
net.ipv4.neigh.default.gc_thresh2 = 20480
net.ipv4.neigh.default.gc_thresh3 = 40960
EOF</code></pre> 
<p>sysctl -p</p> 
<p><strong>3.2 配置freeswitch</strong></p> 
<p>修改“/usr/local/freeswitch/conf/vars.xml ”   ---具体路径视实际情况</p> 
<p>将“local_ip_v4”的值修改为VIP：“100.207.104.89”</p> 
<p>将“domain”的值修改为：“callcenter.xxxxx.com” ---域名暂无启用。</p> 
<p><strong>freeswitch 使用systemctl 启用服务方法</strong></p> 
<pre><code class="language-bash">cat &gt;/lib/systemd/system/freeswitch.service&lt;&lt;EOF
[Unit]
Description=FreeSWITCH
After=syslog.target network.target
After=postgresql.service postgresql-9.3.service postgresql-9.4.service mysqld.service httpd.service
[Service]
User=appdeploy
EnvironmentFile=-/usr/local/freeswitch/etc/sysconfig/freeswitch
WorkingDirectory=/usr/local/freeswitch
ExecStart=/usr/local/freeswitch/bin/freeswitch -nc -nf $FREESWITCH_PARAMS
ExecReload=/usr/bin/kill -HUP $MAINPID
#ExecStop=/usr/local/freeswitch/bin/freeswitch -stop $FREESWITCH_PARAMS
ExecStop=/bin/kill -9 $MAINPID


[Install]
WantedBy=multi-user.target

EOF</code></pre> 
<p><strong>freeswitch启动、检查、停止、重启命令</strong></p> 
<p>systemctl start freeswitch</p> 
<p>systemctl status freeswitch</p> 
<p>systemctl stop freeswitch</p> 
<p>systemctl restart freeswitch</p> 
<p><strong>开机自启动</strong></p> 
<p>systemctl enable freeswitch</p> 
<p><strong>关闭开机自启动</strong></p> 
<p>systemctl disable freeswitch</p> 
<p><strong>加载配置</strong><br> systemctl daemon-reload</p> 
<p><strong>过滤查看启动项</strong><br> systemctl list-unit-files --type=service |grep enabled</p> 
<p></p> 
<p><strong>3.3 安装、配置keepalived</strong></p> 
<p>下载 keepalived-2.2.7.tar.gz<br> wget https://www.keepalived.org/software/keepalived-2.2.7.tar.gz  --no-check-certificate</p> 
<p>安装keepalived-2.2.7.tar.gz</p> 
<p>yum install curl gcc openssl-devel libnl3-devel net-snmp-devel</p> 
<p>解压：tar zxvf keepalived-2.2.7.tar.gz</p> 
<p>tar zxvf keepalived-2.2.7.tar.gz<br> cd keepalived-2.2.7<br> ./configure --prefix=/app/keepalived<br> make<br> make install</p> 
<p><br><strong>systemctl 启动 keepalived服务</strong></p> 
<pre><code class="language-bash">cat &gt; /lib/systemd/system/keepalived.service &lt;&lt;EOF

[Unit]
Description=keepalive
After=syslog.target network.target

[Service]
Type=forking
ExecStart=/app/keepalived/sbin/keepalived -f /app/keepalived/etc/keepalived/keepalived.conf -p /app/keepalived/run/keep.pid -r /app/keepalived/run/vrrp.pid
ExecStop=/bin/kill -HUP $MAINPID
Restart=always
User=appdeploy
Group=mwopr

[Install]
WantedBy=multi-user.target

EOF</code></pre> 
<p><strong>keepalived 要想使用普通用户运行，必须使用setcap授权</strong></p> 
<p>setcap cap_net_admin,cap_net_raw=eip /app/keepalived/sbin/keepalived</p> 
<p><span style="color:#fe2c24;">setcap 'CAP_SETUID+eip CAP_SETGID+eip CAP_NET_RAW+eip CAP_NET_ADMIN+eip cap_net_bind_service+eip'  /app/keepalived/sbin/keepalived</span></p> 
<p>CAP_NET_ADMIN:允许执行网络管理任务<br> CAP_NET_RAW:允许使用原始套接字</p> 
<p>CAP_SETGID: 允许改变进程的组ID</p> 
<p>CAP_SETUID: 允许改变进程的用户ID</p> 
<p>CAP_NET_BIND_SERVICE: 允许绑定到小于1024的端口</p> 
<p></p> 
<p><strong>A、B节点 创建日志和进程ID目录：</strong></p> 
<p>mkdir -p /app/keepalived/log</p> 
<p>mkdir -p /app/keepalived/run</p> 
<p><strong>keepalived启动、检查、停止、重启命令</strong></p> 
<p>systemctl start keepalived</p> 
<p>systemctl status keepalived</p> 
<p>systemctl stop keepalived</p> 
<p>systemctl restart keepalived</p> 
<p><strong>开机自启动</strong></p> 
<p>systemctl enable keepalived</p> 
<p><strong>关闭开机自启动</strong></p> 
<p>systemctl disable keepalived</p> 
<p><strong>加载配置</strong><br> systemctl daemon-reload</p> 
<p><strong>过滤查看启动项</strong><br> systemctl list-unit-files --type=service |grep enabled</p> 
<p><strong>配置keepalived</strong></p> 
<p>keepalived默认配置文件路径“/app/keepalived/etc/keepalived/keepalived.conf ”</p> 
<p>A节点keepalived配置：<span style="color:#fe2c24;">100.207.104.77</span></p> 
<pre><code class="language-bash">cat &gt; /app/keepalived/etc/keepalived/keepalived.conf &lt;&lt;EOF
! Configuration File for keepalived
global_defs {
    #每个keepalived取个不同名称
    router_id 40
}

vrrp_script check_fs {
    script "/app/keepalived/script/check_fs.sh"
    interval 1
    weight 2
}

vrrp_instance VI_1 {
    # MASTER为主实例,BACKUP 为从实例
    state MASTER
    # 网卡名称
    interface eth0
    # 主备这里要配置为同样的
    virtual_router_id 68
    # 优先级,主要高于备. 一般主配置为100  备配置为80
    priority 100
    advert_int 1
    # 主动抢占,主备都开启的话,服务器抢占过去后,要等这个服务器keepalived停掉才会漂移到另一台
    nopreempt
    authentication {
        # 主备必须配置成同样的
        auth_type PASS
        # 主备必须配置成同样的
        auth_pass 1111
    }

    track_script {
        check_fs
    }

    virtual_ipaddress {
      # vip,主备必须配置一样
      10.207.104.89
    }
    notify_master "/app/keepalived/script/fs_recover.sh"
}
EOF</code></pre> 
<p>添加普通用户启动权限</p> 
<p># 全局定义<br> global_defs {<!-- --><br>   # 路由id<br>   router_id LVS_DEVEL<br>   # 设置运行脚本默认用户和组。如果没有指定，则默认用户为keepalived_script(需要该用户存在)，否则为root用户。默认groupname同username<br>   <span style="color:#fe2c24;">script_user appdeploy</span><br>   # 如果脚本路径的任一部分对于非root用户来说，都具有可写权限，则不会以root身份运行脚本<br>   <span style="color:#fe2c24;">enable_script_security</span><br> }</p> 
<blockquote> 
 <pre><code class="language-bash"># 全局定义
global_defs {
  notification_email {
    acassen@firewall.loc
    failover@firewall.loc
    sysadmin@firewall.loc
  }
  notification_email_from Alexandre.Cassen@firewall.loc
  smtp_server 192.168.0.123
  smtp_connect_timeout 30
  # 路由id
  router_id LVS_DEVEL
  # 设置运行脚本默认用户和组。如果没有指定，则默认用户为keepalived_script(需要该用户存在)，否则为root用户。默认groupname同username
  script_user appdeploy
  # 如果脚本路径的任一部分对于非root用户来说，都具有可写权限，则不会以root身份运行脚本
  enable_script_security
}
# 检测Nginx是否还存活的脚本
vrrp_script check_nginx {
  # 脚本文件的位置
  script "/app/app/keepalived/etc/keepalived/check_nginx.sh"
  interval 2 # 检测脚本执行的间隔
  weight 2 # 设置当服务器的权重
}
# 虚拟IP的配置
vrrp_instance VI_1 {
  state BACKUP # 表示当前服务器是MASTER还是BACKUP
  interface eth0 # 绑定的网卡名称
  virtual_router_id 51 # 主、备机的virtual_router_id必须相同
  priority 80 # 主、备机取不同的优先级，主机值较大，备份机值较小
  advert_int 1 # 每隔多久发送一次心跳，默认是1秒
  # 权限校验
  authentication {
    auth_type PASS
    auth_pass 1111
  }
  # 虚拟IP地址
  virtual_ipaddress {
    192.168.3.20
  }
  # 指定监控脚本
  track_script {
    # 这里的check_nginx对应上面的vrrp_script的名字
    check_nginx
  }
}</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<p></p> 
<p>B节点keepalived配置：<span style="color:#fe2c24;">100.207.104.78</span></p> 
<pre><code class="language-bash">cat &gt; /app/keepalived/etc/keepalived/keepalived.conf &lt;&lt; EOF
! Configuration File for keepalived
global_defs {
    #每个keepalived取个不同名称
    router_id 40
}

vrrp_script check_fs {
    script "/app/keepalived/script/check_fs.sh"
    interval 1
    weight 2
}

vrrp_instance VI_1 {
    # MASTER为主实例,BACKUP 为从实例
    state BACKUP
    # 网卡名称
    interface eth0
    # 主备这里要配置为同样的
    virtual_router_id 68
    # 优先级,主要高于备. 一般主配置为100  备配置为80
    priority 80
    advert_int 1
    # 主动抢占,主备都开启的话,服务器抢占过去后,要等这个服务器keepalived停掉才会漂移到另一台
    nopreempt
    authentication {
        # 主备必须配置成同样的
        auth_type PASS
        # 主备必须配置成同样的
        auth_pass 1111
    }

    track_script {
        check_fs
    }

    virtual_ipaddress {
      # vip,主备必须配置一样
      10.207.104.89
    }
    notify_master "/app/keepalived/script/fs_recover.sh"
}
EOF</code></pre> 
<p></p> 
<p><strong>3.4 检测脚本</strong></p> 
<p>A、B节点 检测脚本路径：</p> 
<p>mkdir -p /app/keepalived/script/<br> 检测可用性脚本</p> 
<pre><code class="language-bash">cat &gt; /app/keepalived/script/check_fs.sh &lt;&lt; EOF
#!/bin/sh
FS_CLI_PROG='/usr/local/bin/fs_cli'
FS_CLI_HOST='127.0.0.1'
FS_CLI_PORT='8021'
FS_CLI_PASS='ClueCon'
PROFILES='10.207.104.89'
VIP='10.207.104.89'

fs_cli() {
   $FS_CLI_PROG -H $FS_CLI_HOST -P $FS_CLI_PORT -p $FS_CLI_PASS -x "$1"
}

sofia_profile_started() {
   fs_cli "sofia xmlstatus" | grep "&lt;name&gt;$1&lt;/name&gt;" | wc -l
}

save_log(){
   count=1
   str_tmp="`date +%Y-%m-%d_%H:%M:%S` "
   while [ $# -ge 1 ];do
        str_tmp="$str_tmp $1"
        count=count+1
        shift
   done
   echo $str_tmp &gt;&gt;/app/keepalived/log/check_fs_`date +%Y-%m-%d`.log
}

check_vrrp(){
   ip a|grep $VIP|wc -l
}

check_fs_service(){
   ps -ef |grep freeswitch.service|grep -v 'grep'|wc -l
}

# fs_cli "sofia recover"
for p in $PROFILES; do
if [ `sofia_profile_started "$p"` -eq 0 ]; then
# echo "$p DOWN"
      log_str="$p DOWN"
      save_log $log_str
   if [ `check_vrrp` -eq 1 ];then
      save_log "本机已经绑定VRRP，即将重启keepalived和FreeSWITCH。"
      #service keepalived restart
      systemctl restart keepalived
      save_log "vrrp切换完成！"
   if [ `check_fs_service` -eq 1 ];then
      save_log "freeswitch服务正在操作中。"
   else
      #service freeswitch restart
      systemctl restart keepalived
      save_log "freeswitch重启成功！"
   fi
else
   if [ `check_fs_service` -eq 1 ];then
      save_log "freeswitch服务正在操作中。 "
   else
      save_log "本机没有绑定VRRP，重启FreeSWITCH。"
      #service freeswitch restart
      systemctl restart keepalived
      save_log "freeswitch重启成功！"
   fi
fi
exit 1
fi
done
   save_log "freeswitch状态检测:OK!"
#echo "OK"
exit 0
EOF</code></pre> 
<p><strong>切换为主节点后恢复通话脚本</strong></p> 
<pre><code class="language-bash">cat &gt; /app/keepalived/script/fs_recover.sh &lt;&lt; EOF
#!/bin/sh
FS_CLI_PROG='/usr/local/bin/fs_cli'
FS_CLI_HOST='127.0.0.1'
FS_CLI_PORT='8021'
FS_CLI_PASS='ClueCon'
PROFILES='10.207.104.89'
VIP='10.207.104.89'

fs_cli() {
   $FS_CLI_PROG -H $FS_CLI_HOST -P $FS_CLI_PORT -p $FS_CLI_PASS -x "$1"
}

save_log(){
   counti=1
   str_tmp="`date +%Y-%m-%d_%H:%M:%S` "
   while [ $# -ge 1 ];do
      str_tmp="$str_tmp $1"
      count=count+1
      shift
   done
   echo $str_tmp &gt;&gt;/app/keepalived/log/check_fs_`date +%Y-%m-%d`.log
}
save_log "本节点切换为主用状态，开始接管切换前的通话。"
fs_cli "sofia recover"
fs_cli "raloadxml"
exit 0
EOF</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03b6d7baace7c31ad69cf5020a1c2081/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">你知道【查找附近的人】是怎么实现的吗</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/774b03117b35549788580235e392c41c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">less和scss的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>