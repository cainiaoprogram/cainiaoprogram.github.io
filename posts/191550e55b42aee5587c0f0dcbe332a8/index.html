<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>尚硅谷Docker笔记-高级篇 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="尚硅谷Docker笔记-高级篇" />
<meta property="og:description" content="1.Docker复杂安装 1.1安装mysql主从复制搭建步骤 1.新建主服务器容器实例3307
docker run -p 3307:3306 --name mysql-master \ -v /mydata/mysql-master/log:/var/log/mysql \ -v /mydata/mysql-master/data:/var/lib/mysql \ -v /mydata/mysql-master/conf:/etc/mysql \ -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 docker ps mysql8.0 记得多加上映射卷：
-v /MySql80Data/mysql-master/files:/var/lib/mysql-files/
2.进入/mydata/mysql-master/conf目录下新建my.cnf。
vim my.cnf（注意是cnf不是conf），粘贴以下内容
[mysqld]
##设置server_id,同一局域网中需要唯一
server_id=101
##指定不需要同步的数据库名称
binlog-ignore-db=mysql
##开启二进制日志功能
log-bin=mall-mysql-bin
##设置二进制日志使用内存大小（事务）
binlog_cache_size=1M
##设置使用的二进制日志格式（mixed,statement,row)
binlog_format=mixed
##二进制日志过期清理时间。默认值为0，表示不自动清理。
expire_logs_days=7
##跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。
##如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致
slave_skip_errors=1062
3.修改完配置后重启master实例
docker restart mysql-master docker ps 4.进入mysql-master容器
docker exec -it mysql-master /bin/bash mysql -uroot -proot &gt; show databases; 5.master容器实例内创建数据同步用户并授权
CREATE USER &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/191550e55b42aee5587c0f0dcbe332a8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-14T15:00:58+08:00" />
<meta property="article:modified_time" content="2023-12-14T15:00:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">尚硅谷Docker笔记-高级篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1Docker_0"></a>1.Docker复杂安装</h2> 
<h3><a id="11mysql_2"></a>1.1安装mysql主从复制搭建步骤</h3> 
<p>1.新建主服务器容器实例3307</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">3307</span>:3306 <span class="token parameter variable">--name</span> mysql-master <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /mydata/mysql-master/log:/var/log/mysql <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /mydata/mysql-master/data:/var/lib/mysql <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /mydata/mysql-master/conf:/etc/mysql <span class="token punctuation">\</span>
<span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root <span class="token parameter variable">-d</span> mysql:5.7

<span class="token function">docker</span> <span class="token function">ps</span>
</code></pre> 
<p>mysql8.0 记得多加上映射卷：</p> 
<p><code>-v /MySql80Data/mysql-master/files:/var/lib/mysql-files/</code></p> 
<p>2.进入/mydata/mysql-master/conf目录下新建my.cnf。</p> 
<p><code>vim my.cnf</code>（注意是cnf不是conf），粘贴以下内容</p> 
<blockquote> 
 <p>[mysqld]<br> ##设置server_id,同一局域网中需要唯一<br> server_id=101<br> ##指定不需要同步的数据库名称<br> binlog-ignore-db=mysql<br> ##开启二进制日志功能<br> log-bin=mall-mysql-bin<br> ##设置二进制日志使用内存大小（事务）<br> binlog_cache_size=1M<br> ##设置使用的二进制日志格式（mixed,statement,row)<br> binlog_format=mixed<br> ##二进制日志过期清理时间。默认值为0，表示不自动清理。<br> expire_logs_days=7<br> ##跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。<br> ##如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致<br> slave_skip_errors=1062</p> 
</blockquote> 
<p>3.修改完配置后重启master实例</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> restart mysql-master
<span class="token function">docker</span> <span class="token function">ps</span>
</code></pre> 
<p>4.进入mysql-master容器</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysql-master /bin/bash
mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-proot</span>
<span class="token operator">&gt;</span> show databases<span class="token punctuation">;</span>
</code></pre> 
<p>5.master容器实例内创建数据同步用户并授权</p> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'slave'</span><span class="token variable">@'%'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'123456'</span><span class="token punctuation">;</span>
<span class="token keyword">GRANT</span> <span class="token keyword">REPLICATION</span> SLAVE<span class="token punctuation">,</span> <span class="token keyword">REPLICATION</span> CLIENT <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'slave'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span>
</code></pre> 
<p>mysql8版本设置账号要加一步：</p> 
<pre><code class="prism language-sql"><span class="token comment"># 名为'slave'的用户在任何地址('%')访问时的密码为'123456'，并使用mysql_native_password身份验证插件来验证身份</span>
<span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'slave'</span><span class="token variable">@'%'</span> IDENTIFIED <span class="token keyword">WITH</span> mysql_native_password <span class="token keyword">BY</span> <span class="token string">'123456'</span><span class="token punctuation">;</span>
</code></pre> 
<p>6.新建从服务器容器实例3308</p> 
<p>跟第1步差不多，端口变为3308，名字变为slave</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">3308</span>:3306 <span class="token parameter variable">--name</span> mysql-slave <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /mydata/mysql-slave/log:/var/log/mysql <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /mydata/mysql-slave/data:/var/lib/mysql <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /mydata/mysql-slave/conf:/etc/mysql <span class="token punctuation">\</span>
<span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root <span class="token parameter variable">-d</span> mysql:5.7

<span class="token function">docker</span> <span class="token function">ps</span>
</code></pre> 
<p>7.进入/mydata/mysql-slave/conf目录下新建my.cnf</p> 
<p><code>vim my.cnf</code>（注意是cnf不是conf），粘贴以下内容</p> 
<blockquote> 
 <p>[mysqld]<br> ##设置server_id,同一局域网中需要唯一<br> server_id=102<br> ##指定不需要同步的数据库名称<br> binlog-ignore-db=mysql<br> ##开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用<br> log-bin=mall-mysql-slave1-bin<br> ##设置二进制日志使用内存大小（事务）<br> binlog_cache_size=1M<br> ##设置使用的二进制日志格式（mixed,statement,row)<br> binlog_format=mixed<br> ##二进制日志过期清理时间。默认值为0，表示不自动清理。<br> expire_logs_days=7<br> ##跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。<br> ##如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致<br> slave_skip_errors=1062<br> ##relay_log配置中继日志<br> relay_log=mall-mysql-relay-bin<br> ##log_slave_updates表示slave将复制事件写进自己的二进制日志<br> log_slave_updates=1<br> ##slave设置为只读（具有super权限的用户除外）<br> read_only=1</p> 
</blockquote> 
<p>centos 8，mysql 最新镜像，要在<code>/mysql-master/conf</code>、<code>/mysql-slave/conf</code> 两个目录下<code>mkdir conf.d</code>。否则启动后会立即退出。</p> 
<p>问题：log-bin=mall-mysql-slave1-bin是不是应该去掉1</p> 
<p>8.修改完配置后重启slave实例</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> restart mysql-slave
<span class="token function">docker</span> <span class="token function">ps</span>
</code></pre> 
<p>9.在主数据库中查看主从同步状态</p> 
<p>在master容器实例内部执行</p> 
<pre><code class="prism language-sql"><span class="token keyword">show</span> master <span class="token keyword">status</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/13/bd/FlzhRXJY_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>File和Position的值，在【第11步配置主从复制】要用到</p> 
<p>10.进入mysql-slave容器</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysql-slave /bin/bash
mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-proot</span>
</code></pre> 
<p>11.在从数据库中配置主从复制</p> 
<pre><code class="prism language-sql">change master <span class="token keyword">to</span> master_host<span class="token operator">=</span><span class="token string">'宿主机ip'</span><span class="token punctuation">,</span> master_user<span class="token operator">=</span><span class="token string">'slave'</span><span class="token punctuation">,</span> master_password<span class="token operator">=</span><span class="token string">'123456'</span><span class="token punctuation">,</span> master_port<span class="token operator">=</span><span class="token number">3307</span><span class="token punctuation">,</span> master_log_file<span class="token operator">=</span><span class="token string">'mall-mysql-bin.000001'</span><span class="token punctuation">,</span> master_log_pos<span class="token operator">=</span><span class="token number">617</span><span class="token punctuation">,</span> master_connect_retry<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">;</span>
</code></pre> 
<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>master_host</td><td>主数据库的IP地址</td></tr><tr><td>master_port</td><td>主数据库的运行端口</td></tr><tr><td>master_user</td><td>在主数据库创建的用于同步数据的用户账号</td></tr><tr><td>master_password</td><td>在主数据库创建的用于同步数据的用户密码</td></tr><tr><td>master_log_file</td><td>指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数</td></tr><tr><td>master_log_pos</td><td>指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数</td></tr><tr><td>master_connect_retry</td><td>连接失败重试的时间间隔，单位为秒</td></tr></tbody></table> 
<p>12.在从数据库中查看主从同步状态</p> 
<pre><code class="prism language-sql"><span class="token comment"># 可以像第9步一样执行show slave status;而\G是以kv键值对竖着显示</span>
<span class="token keyword">show</span> slave <span class="token keyword">status</span> \G<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a8/7a/lM9Z2B9u_o.png" alt="在这里插入图片描述" width="400"></p> 
<p>13.在从数据库中开启主从同步</p> 
<pre><code class="prism language-sql"><span class="token keyword">start</span> slave<span class="token punctuation">;</span>
</code></pre> 
<p>14.查看从数据库状态发现已经同步</p> 
<p><code>show slave status \G;</code>查看状态时Slave_IO_Running和Slave_SQL_Running变为YES。</p> 
<p>Slave_IO_Running如果是Connecting，在master容器中执行第5步追加的命令<code>ALTER USER 'slave'@'%' IDENTIFIED WITH mysql_native_password BY '123456';</code>，再重新启动（<code>stop slave; reset slave; start slave;</code>）即可为YES</p> 
<p>15.主从复制测试</p> 
<p>主机新建库-使用库-新建表-插入数据</p> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">database</span> db01<span class="token punctuation">;</span>
<span class="token keyword">use</span> db01<span class="token punctuation">;</span>
<span class="token keyword">create</span> <span class="token keyword">table</span> t1 <span class="token punctuation">(</span>id <span class="token keyword">int</span><span class="token punctuation">,</span> name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'z3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>
</code></pre> 
<p>从机使用库-查看记录</p> 
<pre><code class="prism language-sql"><span class="token keyword">use</span> db01<span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="12redis_199"></a>1.2安装redis集群</h3> 
<h4><a id="__201"></a>真题 三种哈希分区</h4> 
<p>大厂面试题第4季-分布式存储案例真题</p> 
<p>cluster(集群)模式-docker版：哈希槽分区进行亿级数据存储</p> 
<p>面试题：1~2亿条数据需要缓存，请问如何设计这个存储案例</p> 
<p>单机单台肯定不可能，肯定是分布式存储，用redis如何落地？</p> 
<p>上述问题阿里P6~P7工程案例和场景设计类必考题目，一般业界有3种解决方案</p> 
<h5><a id="1_213"></a>1.哈希取余分区</h5> 
<p><img src="https://images2.imgbox.com/c2/86/NsXVvgFp_o.png" alt="在这里插入图片描述" width="300"></p> 
<blockquote> 
 <p>2亿条记录就是2亿个k,v，我们单机不行，必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式<code>hash(key) % N</code>个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</p> 
 <p><strong>优点</strong><br> 简单粗暴，直接有效，只需预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请<br> 求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</p> 
 <p><strong>缺点</strong><br> 原来规划好的节点，在服务器个数固定不变时没有问题，但进行扩容、缩容（或故障停机）时就比较麻烦了。<br> 不管扩缩，每次数据变动导致节点有变动，映射关系需重新计算，原来的取模公式就会发生变化：<code>Hash（key）% 3</code>会变成<code>Hash（key）% ?</code>。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。<br> 某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</p> 
</blockquote> 
<h5><a id="2_229"></a>2.一致性哈希算法分区</h5> 
<blockquote> 
 <p><strong>一致性Hash算法背景</strong><br> 一致性哈希算法在1997年由麻省理工学院中提出的，设计目标是为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不OK了。</p> 
 <p><strong>提出一致性Hash解决方案</strong><br> 目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系</p> 
</blockquote> 
<h6><a id="_237"></a>三大步骤</h6> 
<p>①算法构建一致性哈希环</p> 
<blockquote> 
 <p>一致性哈希环<br> 一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间<br> [0, 2<sup>32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连（0=2</sup>32），这样让它逻辑上形成了一个环形空间。<br> 它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点(服务器)的数量进行取模。而一致性Hash算法是对2^32取模，简单来说，<br> 致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2<sup>32-1（即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2</sup>32-1，也就是说0点左侧的第一个点代表2<sup>32-1，0和2</sup>32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/74/1d/tV76pyPb_o.png" alt="在这里插入图片描述" width="300"></p> 
<p>②服务器IP节点映射</p> 
<blockquote> 
 <p>将集群中各个IP节点映射到环上的某一个位置。<br> 将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算(hash(ip))，使用IP地址哈希后在环空间的位置如下：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/56/af/HGPFoFcC_o.png" alt="在这里插入图片描述" width="400"></p> 
<p>③key落到服务器的落键规则</p> 
<blockquote> 
 <p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。<br> 如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/bd/fb/3WpFl7Tu_o.png" alt="在这里插入图片描述" width="400"></p> 
<h6><a id="_266"></a>优点</h6> 
<p>①一致性哈希算法的容错性</p> 
<blockquote> 
 <p>假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b7/4b/XKtjnbd2_o.png" alt="在这里插入图片描述" width="400"></p> 
<p>②一致性哈希算法的扩展性</p> 
<blockquote> 
 <p>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，不会导致hash取余全部数据重新洗牌。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/de/df/ccK237Mg_o.png" alt="在这里插入图片描述" width="400"></p> 
<h6><a id="_282"></a>缺点</h6> 
<p>一致性哈希算法的数据倾斜问题</p> 
<blockquote> 
 <p>一致性Hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f5/b2/sJkl7ztt_o.png" alt="在这里插入图片描述" width="400"></p> 
<h6><a id="_291"></a>总结</h6> 
<blockquote> 
 <p>为在节点数目发生改变时尽可能少的迁移数据<br> 将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。<br> <strong>优点</strong><br> 加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。<br> <strong>缺点</strong><br> 数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p> 
</blockquote> 
<h5><a id="3_300"></a>3.哈希槽分区</h5> 
<p><strong>为什么出现</strong></p> 
<p>一致性哈希算法的数据倾斜问题<br> 哈希槽实质就是一个数组，数组[0, 2^14-1]形成hash slot空间。</p> 
<p><strong>能干什么</strong></p> 
<p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。<br> 槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。<br> 哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。</p> 
<p><strong>多少个hash槽</strong></p> 
<p>一个集群只能有16384个槽（redis集群默认就是16384个槽），编号0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求哈希值，就是对16384取余，余数是几key就落入对应的槽里。 <code>slot=CRC16(key) % 16384</code>。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p> 
<p><img src="https://images2.imgbox.com/5b/14/3dLHyBqI_o.png" alt="在这里插入图片描述" width="300"></p> 
<blockquote> 
 <p>哈希槽计算</p> 
 <p>Redis集群中内置了16384个哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同的节点。<br> 当需要在Redis集群中放置一个key-value时，redis先对key使用crc16算法算出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，也就是映射到某个节点上。如下代码，key之A、B在Node2，key之C落在Node3上</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/2a/e7/dFqcsjaR_o.png" alt="在这里插入图片描述" width="400"></p> 
<h4><a id="33redis_328"></a>3主3从redis集群扩缩容配置案例</h4> 
<h5><a id="_330"></a>架构说明</h5> 
<p>主从机器分配以实际情况为准，1号不一定对应4号</p> 
<p><img src="https://images2.imgbox.com/f1/3e/lfiGr35B_o.png" alt="在这里插入图片描述" width="400"></p> 
<h5><a id="33redis_337"></a>3主3从redis集群配置</h5> 
<p>关闭防火墙+启动docker后台服务</p> 
<pre><code class="prism language-shell">systemctl start <span class="token function">docker</span>
</code></pre> 
<p>新建6个docker容器实例</p> 
<pre><code class="prism language-shell"><span class="token comment"># --net host 使用宿主机的ip和端口，默认</span>
<span class="token comment"># --cluster-enabled yes 开启redis集群</span>
<span class="token comment"># --appendonly yes 开启持久化</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-1 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6381</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-2 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6382</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-3 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6383</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-4 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6384</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-5 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6385</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-6 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6386</span>
</code></pre> 
<p>进入容器redis-node-1并为6台机器构建集群关系</p> 
<pre><code class="prism language-shell"><span class="token comment"># 进入容器</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis-node-1 /bin/bash
<span class="token comment"># 构建主从关系。进入docker容器后才能执行以下命令，且注意自己的真实ip地址</span>
<span class="token comment"># --cluster-replicas 1 表示为每个master创建一个slave节点，此参数会自动绑定好主从关系，具体可以看打印的日志</span>
redis-cli <span class="token parameter variable">--cluster</span> create 自己的ip:6381 自己的ip:6382 自己的ip:6383 自己的ip:6384 自己的ip:6385 自己的ip:6386 --cluster-replicas <span class="token number">1</span>
<span class="token comment"># 一切OK的话，3主3从已经搞定</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/56/f2/H14rPYH7_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>链接进入6381作为切入点，查看集群状态</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis-node-1 /bin/bash
<span class="token comment"># 端口号默认6379，此处链接我们的6381</span>
redis-cli <span class="token parameter variable">-p</span> <span class="token number">6381</span>
<span class="token comment"># info显示的 cluster_slots_ok:16384分配的槽位数量 cluster_konwn_nodes:6已经知道的节点数量</span>
cluster info
cluster nodes
</code></pre> 
<h5><a id="_384"></a>主从容错切换迁移案例</h5> 
<p><strong>1 数据读写存储</strong></p> 
<p>启动6机构成的集群并通过exec进入</p> 
<pre><code class="prism language-shell"><span class="token comment"># 不能用以下单机版的命令，需要链接的是集群</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis-node-1 /bin/bash
redis-cli <span class="token parameter variable">-p</span> <span class="token number">6381</span>
<span class="token comment"># 对6381新增两个key</span>
<span class="token builtin class-name">set</span> k1 v1 <span class="token comment"># 报错 (error) MOVED 12706 ip:6383</span>
<span class="token builtin class-name">set</span> k2 v2 <span class="token comment"># 不报错</span>
</code></pre> 
<p>防止路由失效加参数-c并新增两个key</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis-node-1 /bin/bash
redis-cli <span class="token parameter variable">-p</span> <span class="token number">6381</span> <span class="token parameter variable">-c</span>
<span class="token builtin class-name">set</span> k1 v1
<span class="token builtin class-name">set</span> k2 v2
</code></pre> 
<p><img src="https://images2.imgbox.com/92/df/5bU10RCQ_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>查看集群信息</p> 
<pre><code class="prism language-shell">redis-cli <span class="token parameter variable">--cluster</span> check 自己ip:6381
</code></pre> 
<p><strong>2 容错切换迁移</strong></p> 
<p>主6381和从机切换，先停止主机6381</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token function">ps</span>
<span class="token function">docker</span> stop redis-node-1
<span class="token function">docker</span> <span class="token function">ps</span>
<span class="token comment"># 这里建议在宿主机直接kill 6381对应容器的方式模拟，更加真实，通过在容器里停的方式，不能模仿主机宕机的场景</span>
</code></pre> 
<p>再次查看集群信息</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis-node-2 /bin/bash
redis-cli <span class="token parameter variable">-p</span> <span class="token number">6382</span> <span class="token parameter variable">-c</span>
cluster nodes
<span class="token comment"># 可以看到6381已经【master.fail】【disconnect】了，6384由以前的slave变为master了</span>
get k1
get k2
</code></pre> 
<p>先还原之前的3主3从</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> start redis-node-1
<span class="token function">docker</span> <span class="token function">ps</span>
<span class="token comment"># 在容器内部查看状态，会发现6384依然是master，新启动的6381变成slave</span>
cluster nodes
</code></pre> 
<p>查看集群状态</p> 
<pre><code class="prism language-shell">redis-cli <span class="token parameter variable">--cluster</span> check 自己ip:6381
</code></pre> 
<h5><a id="_454"></a>主从扩容案例</h5> 
<p><img src="https://images2.imgbox.com/cd/1e/nOoDWyvW_o.png" alt="在这里插入图片描述" width="500"></p> 
<p><img src="https://images2.imgbox.com/42/94/c9qkJd2Y_o.png" alt="在这里插入图片描述" width="500"></p> 
<p><img src="https://images2.imgbox.com/2d/ee/DOCfIvza_o.png" alt="在这里插入图片描述" width="500"></p> 
<p><img src="https://images2.imgbox.com/15/98/MtLO0mLp_o.png" alt="在这里插入图片描述" width="800"></p> 
<p>新建6387、6388两个节点+新建后启动+查看是否8节点</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-7 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span>
<span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6387</span>

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-8 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span>
<span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6388</span>

<span class="token function">docker</span> <span class="token function">ps</span>
</code></pre> 
<p>进入6387容器实例内部<code>docker exec -it redis-node-7 /bin/bash</code></p> 
<p>将新增的6387节点（空槽号）作为master节点加入原集群</p> 
<pre><code class="prism language-shell"><span class="token comment"># 将新增的6387作为master节点加入集群</span>
redis-cli <span class="token parameter variable">--cluster</span> add-node 自己实际IP:6387 自己实际IP地址:6381
<span class="token comment"># 6387就是将要作为master新增节点</span>
<span class="token comment"># 6381就是原来集群节点里面的领路人，相当于6387根据6381找到组织加入集群</span>
</code></pre> 
<p>检查集群情况第1次</p> 
<pre><code class="prism language-shell">redis-cli <span class="token parameter variable">--cluster</span> check 自己ip:6381
<span class="token comment"># 但6387会显示【0 slots | 0 slaves】，暂时没有槽号，也没有从节点</span>
</code></pre> 
<p>重新分派槽号</p> 
<pre><code class="prism language-shell">redis-cli <span class="token parameter variable">--cluster</span> reshard IP地址:端口号
redis-cli <span class="token parameter variable">--cluster</span> reshard <span class="token number">192.168</span>.111.147:6381
<span class="token comment"># 提示【How many slots do you want to move(from 1 to 16384)】时，输入4096（16384个槽位 ÷ 4个主节点 = 4096）</span>
<span class="token comment"># 提示【What is the receiving node ID】时，粘贴新加入的主节点的id</span>
<span class="token comment"># 提示【Source node #1】时，输入all</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/59/89/uHBiw6f4_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>检查集群情况第2次</p> 
<pre><code class="prism language-shell">redis-cli <span class="token parameter variable">--cluster</span> check 自己ip:6381
<span class="token comment"># 各个节点的槽位变化了</span>
</code></pre> 
<p>槽号分派说明</p> 
<blockquote> 
 <p>为什么6387是3个新的区间，以前的还是连续？</p> 
 <p>重新分配成本太高，所以前3家各自匀出来一部分，从6381/6382/6383三个旧节点分别匀出1364个坑位给新节点6387</p> 
</blockquote> 
<p>为主节点6387分配从节点6388</p> 
<pre><code class="prism language-shell">redis-cli <span class="token parameter variable">--cluster</span> add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID

redis-cli <span class="token parameter variable">--cluster</span> add-node <span class="token number">192.168</span>.111.147:6388 <span class="token number">192.168</span>.111.147:6387 --cluster-slave --cluster-master-id e4781f644d4a4e4d4b4d107157b9ba8144631451----这个是6387的编号，按照自己实际情况
</code></pre> 
<p>检查集群情况第3次</p> 
<pre><code class="prism language-shell">redis-cli <span class="token parameter variable">--cluster</span> check 自己ip:6382
<span class="token comment"># 端口号连谁都行，不用非得6381</span>
</code></pre> 
<h5><a id="_539"></a>主从缩容案例</h5> 
<p>目的：6387和6388下线</p> 
<p>检查集群情况1获得6388的节点ID<code>redis-cli --cluster check 自己ip:6382</code></p> 
<p>从集群中将4号从节点6388删除</p> 
<pre><code class="prism language-shell">redis-cli <span class="token parameter variable">--cluster</span> del-node ip:从节点端口 从节点6388节点ID

redis-cli <span class="token parameter variable">--cluster</span> del-node <span class="token number">192.168</span>.111.147:6388 5d149074b7e57b802287d1797a874ed7a1a284a8

<span class="token comment"># 检查节点个数</span>
redis-cli <span class="token parameter variable">--cluster</span> check 自己ip:6382
</code></pre> 
<p>将6387的槽号清空，重新分配，本例将清出来的槽号都给6381</p> 
<pre><code class="prism language-shell">redis-cli <span class="token parameter variable">--cluster</span> reshard IP地址:端口号
redis-cli <span class="token parameter variable">--cluster</span> reshard <span class="token number">192.168</span>.111.147:6381

<span class="token comment"># 补充 - 这个方法可以让槽位均匀：</span>
<span class="token comment"># redis-cli --cluster rebalance --cluster-use-empty-masters ip:端口号</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/81/54/0YwGyHDT_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>检查集群情况第二次</p> 
<pre><code class="prism language-shell">redis-cli <span class="token parameter variable">--cluster</span> check 自己ip:6381
<span class="token comment"># 会看到6387还在，但是槽位都空了（0 keys | 0 slots | 0 slaves）</span>
<span class="token comment"># 而6381的槽位变为了8192个，因为刚才设置6387的槽位全都给6381了</span>
</code></pre> 
<p>将6387删除<code>redis-cli --cluster del-node ip:节点端口 从节点6387节点ID</code></p> 
<p>一检查集群情况第三次<code>redis-cli --cluster check 自己ip:6381</code></p> 
<h2><a id="2DockerFile_581"></a>2.DockerFile解析</h2> 
<h3><a id="_583"></a>概述</h3> 
<p><a href="https://docs.docker.com/engine/reference/builder/" rel="nofollow">官网 Dockerfile reference | Docker Docs</a></p> 
<blockquote> 
 <p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ef/63/SWrKK4nh_o.png" alt="请添加图片描述" width="500"></p> 
<h3><a id="_593"></a>构建三步骤</h3> 
<blockquote> 
 <p>编写Dockerfile文件</p> 
 <p>docker build命令构建镜像</p> 
 <p>docker run以镜像运行容器实例</p> 
</blockquote> 
<h3><a id="DockerFile_601"></a>DockerFile构建过程解析</h3> 
<h4><a id="Dockerfile_603"></a>Dockerfile内容基础知识</h4> 
<blockquote> 
 <p>1.每条保留字指令都必须为<strong>大写字母</strong>且后面要跟随至少一个参数</p> 
 <p>2.指令按照从上到下，顺序执行</p> 
 <p>3.#表示注释</p> 
 <p>4.每条指令都会创建一个新的镜像层并对镜像进行提交</p> 
</blockquote> 
<h4><a id="DockerDockerfile_613"></a>Docker执行Dockerfile的大致流程</h4> 
<blockquote> 
 <p>1.docker从基础镜像运行一个容器</p> 
 <p>2.执行一条指令并对容器作出修改</p> 
 <p>3.执行类似<code>docker commit</code>的操作提交一个新的镜像层</p> 
 <p>4.docker再基于刚提交的镜像运行一个新容器</p> 
 <p>5.执行dockerfile中的下一条指令直到所有指令都执行完成</p> 
</blockquote> 
<h4><a id="_625"></a>小总结</h4> 
<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段：</p> 
<ul><li> <p>Dockerfile是软件的原材料</p> </li><li> <p>Docker镜像是软件的交付品</p> </li><li> <p>Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</p> </li></ul> 
<p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p> 
<p><img src="https://images2.imgbox.com/8b/67/FZubUOCb_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>1.<strong>Dockefile</strong>。需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制）等等；</p> 
<p>2.<strong>Docker镜像</strong>。在用Dockerfile定义一个文件之后，<code>docker build</code>时会产生一个Docker镜像，当运行Docker镜像时会真正开始提供服务；</p> 
<p>3.<strong>Docker容器</strong>。容器是直接提供服务的。</p> 
<h3><a id="DockerFile_647"></a>DockerFile常用保留字指令</h3> 
<p>参考tomcat8的dockerfile入门https://github.com/docker-library/tomcat</p> 
<p>https://github.com/docker-library/tomcat/blob/master/9.0/jdk8/corretto-al2/Dockerfile</p> 
<p><img src="https://images2.imgbox.com/0b/5b/8eKyP6U4_o.png" alt="在这里插入图片描述" width="500"></p> 
<h4><a id="FROM_656"></a>FROM</h4> 
<p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是FROM</p> 
<h4><a id="MAINTAINER_660"></a>MAINTAINER</h4> 
<p>镜像维护者的姓名和邮箱地址</p> 
<h4><a id="RUN_664"></a>RUN</h4> 
<p>容器构建时需要运行的命令，RUN是在docker build构建时运行，有两种格式</p> 
<p>shell格式</p> 
<blockquote> 
 <p>RUN &lt;命令行命令&gt;</p> 
 <p>#&lt;命令行命令&gt;等同于 在终端操作的shell命令</p> 
 <p>例：<code>RUN yum -y install vim</code></p> 
</blockquote> 
<p>exec格式</p> 
<blockquote> 
 <p>RUN [“可执行文件”，“参数1”，“参数2”]</p> 
 <p>#例：<code>RUN ["./test.php"，"dev"，"offline"]</code>等同于<code>RUN ./test.php dev offline</code></p> 
</blockquote> 
<h4><a id="EXPOSE_682"></a>EXPOSE</h4> 
<p>当前容器对外暴露出的端口</p> 
<h4><a id="WORKDIR_686"></a>WORKDIR</h4> 
<p>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p> 
<h4><a id="USER_690"></a>USER</h4> 
<p>指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p> 
<h4><a id="ENV_694"></a>ENV</h4> 
<p>用来在构建镜像过程中设置环境变量</p> 
<p><code>ENV MY_PATH /usr/mytest</code><br> 这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；<br> 也可以在其它指令中直接使用这些环境变量，比如：<code>WORKDIR $MY_PATH</code></p> 
<h4><a id="ADD_702"></a>ADD</h4> 
<p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p> 
<h4><a id="COPY_706"></a>COPY</h4> 
<p>类似ADD，拷贝文件和目录到镜像中。</p> 
<p>将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</p> 
<pre><code class="prism language-dockerfile">COPY src dest
COPY ["src", "dest"]
&lt;src源路径&gt;：源文件或者源目录
&lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好，若不存在会自动创建
</code></pre> 
<h4><a id="VOLUME_719"></a>VOLUME</h4> 
<p>容器数据卷，用来数据保存和持久化工作</p> 
<h4><a id="CMD_723"></a>CMD</h4> 
<p>指定容器启动后的要干的事情</p> 
<p>比如Tomcat的最后一行<code>CMD ["catalina.sh", "run"]</code>就是把catalina启动</p> 
<blockquote> 
 <p><strong>CMD容器启动命令</strong></p> 
 <p>CMD指令的格式和RUN相似，也是两种格式：</p> 
 <ul><li> <p>she11格式：CMD &lt;命令&gt;</p> </li><li> <p>exec格式：CMD [“可执行文件”，“参数1”，“参数2”.….]</p> </li><li> <p>参数列表格式：CMD [“参数1”，“参数2”….]。在指定了ENTRYPOINT指令后，月CMD指定具体的参数。</p> </li></ul> 
</blockquote> 
<p>注意</p> 
<blockquote> 
 <p>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换。</p> 
 <p>参考官网Tomcat的dockerfile演示讲解。官网最后一条命令：</p> 
 <blockquote> 
  <p>EXPOSE 8080<br> CMD [“catalina.sh”, “run”]</p> 
 </blockquote> 
 <p>假设现在在末尾加了些别的，CMD命令可能就不生效了。</p> 
 <p>比如若执行命令<code>docker run -it -p 8080:8080 tomcat容器id</code>，在tomcat启动后是能通过localhost:8080访问到页面的，<br> 而若执行命令<code>docker run -it -p 8080:8080 tomcat容器id /bin/bash</code>，docker ps也是能看到tomcat容器是成功启动了的，就类似于在dockerfile文件末尾追加了一句<code>CMD ["/bin/bash", "run"]</code>，会把上面原有的CMD覆盖掉，在tomcat启动后无法通过localhost:8080访问到页面。也就是，成功启动了容器，而tomcat服务由于没有执行<code>CMD ["catalina.sh", "run"]</code>是没有启动的。</p> 
</blockquote> 
<p>它和前面RUN命令的区别</p> 
<blockquote> 
 <p>CMD是在docker run时运行。</p> 
 <p>RUN是在docker build构建镜像时运行。</p> 
</blockquote> 
<h4><a id="ENTRYPOINT_760"></a>ENTRYPOINT</h4> 
<p>也是用来指定一个容器启动时要运行的命令</p> 
<p>类似于CMD指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序。</p> 
<p><strong>命令格式</strong></p> 
<p><code>ENTRYPOINT ["&lt;executeable&gt;", "&lt;param1&gt;", "&lt;param2&gt;", ... ]</code></p> 
<blockquote> 
 <p>ENTRYPOINT可以和CMD一起用，一般是<u><strong>变参</strong></u>（定参是参数个数固定，变参是参数个数可变）才会使用CMD，这里的CMD跟ENTRYPOINT一起用，相当于是在给ENTRYPOINT传参。</p> 
 <p>当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成<code>&lt;ENTRYPOINT&gt;"&lt;CMD&gt;"</code></p> 
</blockquote> 
<p><strong>案例</strong></p> 
<p>假设已通过Dockerfile 构建了nginx:test镜像</p> 
<pre><code class="prism language-dockerfile">FROM nginx

# 定参
ENTRYPOINT ["nginx", "-c"］
# 变参
CMD ["/etc/nginx/nginx.conf"]
</code></pre> 
<table><thead><tr><th>是否传参</th><th>按照dockerfile编写执行</th><th>传参运行</th></tr></thead><tbody><tr><td>Docker命令</td><td>docker run nginx:test</td><td>docker run nginx:test -c /etc/nginx/new.conf</td></tr><tr><td>衍生出的实际命令</td><td>nginx -c /etc/nginx/nginx.conf</td><td>nginx -c /etc/nginx/new.conf</td></tr></tbody></table> 
<h3><a id="_792"></a>案例</h3> 
<p>自定义镜像mycentosjava8，要求Centos7镜像具备vim+ifconfig+jdk8</p> 
<pre><code class="prism language-shell"><span class="token comment"># 先下载好centOS镜像</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> 镜像id /bin/bash
</code></pre> 
<p>JDK的下载镜像地址</p> 
<p>官网：https://www.oracle.com/java/technologies/downloads/#java8<br> 找到Linux版本的，tar.gz。<br> mirrors.yangxingzhen.com/jdk/</p> 
<p><strong>编写Dockerfile文件</strong></p> 
<p>字母D一定要大写。创建路径/myfile并将jdk8放在该路径下。<code>vim Dockerfile</code></p> 
<p>1.下面Dockerfile中RUN写的太多了，建议使用一个，多个命令用换行代替。</p> 
<p>多个run命令重复使用会导致镜像层数比较多，在构建镜像时会比较慢</p> 
<p>2.最新版的centos8用yum会报错（默认就是去拉取版本8），原因是软件源的位置变了。需要先改成7的源。若是报错可以下不用最新的centos，里面FROM centos可以改为例如: FROM centos:7.7.1908或者FROM centos:7等，再无用的话可以试试重启网络、关闭防火墙或者加一个参数 docker build --network host -t centosjava8:1.5 .</p> 
<p>3.Error: Failed to download metadata for repo ‘appstream’: Cannot prepare internal mirrorlist: No URLs。报appstream问题的请在安装vim之前添加额外两条指令<code>rm -rf /etc/yum.repos.d/CentOS-Linux*</code>,<code>COPY CentOS-Base.repo /etc/yum.repos.d/</code></p> 
<pre><code class="prism language-dockerfile">FROM centos
MAINTAINER zzyy&lt;zzyybs@126.com&gt;

ENV MYPATH /usr/local
WORKDIR $MYPATH

#安装vim编辑器
RUN yum -y install vim
#安装ifconfig命令查看网络IP
RUN yum -y install net-tools
#安装java8及lib库
RUN yum -y install glibc.i686
RUN mkdir /usr/local/java
#ADD是相对路径jar，把jdk-8u171-linux-x64.tar.gz添加到容器中，安装包必须要和Dockerfile文件在同一路径下
ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/
#配置java环境变量
ENV JAVA_HOME /usr/local/java/jdk1.8.0_171
ENV JRE_HOME $JAVA_HOME/jre
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH
ENV PATH $JAVA_HOME/bin:$PATH

EXPOSE 80

CMD echo $MYPATH
CMD echo "success---------------ok"
CMD /bin/bash
</code></pre> 
<p><strong>构建</strong></p> 
<pre><code class="prism language-shell"><span class="token comment"># 注意，TAG后面有个空格，有个点表示当前目录</span>
<span class="token function">docker</span> build <span class="token parameter variable">-t</span> 新镜像名字:TAG <span class="token builtin class-name">.</span>
<span class="token function">docker</span> build <span class="token parameter variable">-t</span> mycentosjava8:1.5 <span class="token builtin class-name">.</span>
</code></pre> 
<p><strong>运行</strong></p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> 新镜像名字:TAG
</code></pre> 
<p>再体会下UnionFS（联合文件系统）</p> 
<blockquote> 
 <p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p> 
 <p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p> 
</blockquote> 
<p>虚悬镜像</p> 
<p>仓库名、标签都是<code>&lt;none&gt;</code>的镜像，俗称dangling image</p> 
<p><code>vim Dockerfile</code></p> 
<pre><code class="prism language-dockerfile">FROM ubuntu
CMD echo 'action is success'
</code></pre> 
<p><code>docker build .</code></p> 
<p><img src="https://images2.imgbox.com/9b/52/K8mNpsY6_o.png" alt="在这里插入图片描述" width="300"></p> 
<p><img src="https://images2.imgbox.com/1a/90/i1QOHA33_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>构建或者删除镜像时，可能会出现一些错误导致出现虚悬镜像，它们没有存在的价值，建议删除。</p> 
<p>查看虚悬镜像命令：<code>docker image Is -f dangling=true</code></p> 
<p>删除虚悬镜像命令：<code>docker image prune</code></p> 
<p>作业-自定义镜像myubuntu</p> 
<pre><code class="prism language-dockerfile">FROM ubuntu
MAINTAINER zzyy&lt;zzyybs@126.com&gt;

ENV MYPATH /usr/local
WORKDIR $MYPATH

RUN apt-get update
RUN apt-get install net-tools
#RUN apt-get install -y iproute2
#RUN apt-get install -y inetutils-ping
EXPOSE 80

CMD echo $MYPATH
CMD echo "install inconfig cmd into ubuntu success----------ok"
CMD /bin/bash
</code></pre> 
<h3><a id="_913"></a>小总结</h3> 
<table><thead><tr><th>BUILD</th><th>Both</th><th>RUN</th></tr></thead><tbody><tr><td>FROM</td><td>WORKDIR</td><td>CMD</td></tr><tr><td>MAINTAINER</td><td>USER</td><td>ENV</td></tr><tr><td>COPY</td><td></td><td>EXPOSE</td></tr><tr><td>ADD</td><td></td><td>VOLUME</td></tr><tr><td>RUN</td><td></td><td>ENTRYPOINT</td></tr><tr><td>ONBUILD</td><td></td><td></td></tr><tr><td>.dockerignore</td><td></td><td></td></tr></tbody></table> 
<h2><a id="3Docker_925"></a>3.Docker微服务实战</h2> 
<p><strong>通过IDEA新建一个普通微服务模块</strong></p> 
<p>建Module<br> 改POM<br> 写YML<br> 主启动<br> 业务类</p> 
<p><strong>通过dockerfile发布微服务部署到docker容器</strong></p> 
<p>IDEA工具里面搞定微服务jar包：把package之后生成的服务的jar包（假设名字叫docker_boot_0.0.1-SNAPSHOT.jar）传到服务器的/mydocker路径下</p> 
<p>建议先关闭防火墙，关完后需重启Docker</p> 
<pre><code class="prism language-shell">systemctl stop firewalld
systemctl restart <span class="token function">docker</span>
</code></pre> 
<p>编写Dockerfile：将微服务jar包和Dockerfile文件上传到同一个目录下/mydocker</p> 
<pre><code class="prism language-dockerfile">#基础镜像使用java。SpringBoot项目打成的jar包内嵌的tomcat，此处只需要Java8
FROM java:8
#作者
MAINTAINER zzyy
#VOLUME指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp
VOLUME /tmp
#将jar包添加到容器中并更名为zzyy_docker.jar
ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar
#运行jar包
RUN bash -c 'touch /zzyy_docker.jar'
ENTRYPOINT ["java","-jar","/zzyy_docker.jar"]
#暴露6001端口作为微服务
EXPOSE 6001
</code></pre> 
<p>构建镜像，打包成镜像文件</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> zzyy_docker:1.6 <span class="token builtin class-name">.</span>
</code></pre> 
<p>运行容器</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> images
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">6001</span>:6001 镜像id或者tag
<span class="token comment"># 报错iptables faild则关闭防火墙，关完后需重启Docker。建议一开始就关掉防火墙，</span>
systemctl stop firewalld
systemctl restart <span class="token function">docker</span>
</code></pre> 
<p>访问测试</p> 
<pre><code class="prism language-shell"><span class="token function">curl</span> <span class="token number">127.0</span>.0.1:6001/order/docker
<span class="token function">curl</span> <span class="token number">127.0</span>.0.1:6001/order/index
<span class="token comment"># 以上是SpringBoot工程里做的两个接口，会return字符串。</span>
<span class="token comment"># 除了curl的方式，也可以在浏览器里直接访问[宿主机ip:6001/order/docker]进行测试</span>
</code></pre> 
<h2><a id="4Docker_989"></a>4.Docker网络</h2> 
<p>这一章节在日常工作中敲命令用得不多，但必须懂，为后续Docker-compose容器编排做准备。</p> 
<h3><a id="41Docker_993"></a>4.1Docker启动前后网络情况</h3> 
<p><strong>Docker不启动，默认网络情况</strong></p> 
<p>ens33：inet为192.168.111.167，是Linux宿主机的地址</p> 
<p>lo：local的简写，本地回环联络</p> 
<p>virbr0：</p> 
<blockquote> 
 <p>在CentOS7的安装过程中如果<u>选择相关虚拟化的的服务安装系统后</u>，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡（virbr0网卡：它还有一个固定的默认IP地址192.168.122.1），是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供NAT访问外网的功能。</p> 
 <p>我们之前学习Linux安装，勾选安装系统的时候附带了libvirt服务才会生成的一个东西，如果不需要可以直接将libvirtd服务卸载：<code>yum remove libvirt-libs.x86_64</code></p> 
</blockquote> 
<p><strong>Docker启动后，网络情况</strong></p> 
<p>会产生一个名为docker0的虚拟网桥。</p> 
<h3><a id="42_1011"></a>4.2常用基本命令</h3> 
<p>查看网络<code>docker network ls</code></p> 
<p><img src="https://images2.imgbox.com/5f/8d/47Wy0Nrv_o.png" alt="在这里插入图片描述" width="300"></p> 
<p>默认会创建三大网络模式，主要用的是bridge，其次是host，一般不会用none。</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> network <span class="token parameter variable">--help</span>
<span class="token comment"># 创建一个网络，默认是bridge模式</span>
<span class="token function">docker</span> network creat aa_network
<span class="token function">docker</span> network <span class="token function">ls</span>
<span class="token comment"># 删除网络</span>
<span class="token function">docker</span> network <span class="token function">rm</span> aa_network
<span class="token function">docker</span> network <span class="token function">ls</span>
</code></pre> 
<p>查看网络源数据<code>docker network inspect XXX网络名字</code></p> 
<h3><a id="43_1032"></a>4.3能干嘛</h3> 
<p>容器间的互联和通信以及端口映射</p> 
<p>容器IP变动时可通过服务名直接网络通信而不受到影响</p> 
<h3><a id="44_1038"></a>4.4网络模式</h3> 
<table><thead><tr><th>网络模式</th><th>简介</th></tr></thead><tbody><tr><td>bridge</td><td>为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，默认为该模式。使用<code>--network bridge</code>指定，默认使用docker0。</td></tr><tr><td>host</td><td>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。使用<code>--network host</code>指定。</td></tr><tr><td>none</td><td>容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，IP等。几乎不会用该模式。使用<code>--network none</code>指定。</td></tr><tr><td>container</td><td>新创建的容器不会创建自己的网卡和配置自己的IP。而是和一个指定的容器共享IP、端口范围等。使用<code>--network container:NAME</code>指定或者容器ID指定。</td></tr></tbody></table> 
<h3><a id="45IP_1047"></a>4.5容器实例内默认网络IP生产规则</h3> 
<pre><code class="prism language-shell"><span class="token comment"># 启动两个ubuntu</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> u1 ubuntu <span class="token function">bash</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> u2 ubuntu <span class="token function">bash</span>
<span class="token comment"># 查看u1的网络信息，IPAddress是172.17.0.2</span>
<span class="token function">docker</span> inspect u1 <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n</span> <span class="token number">20</span>
<span class="token comment"># 查看u1的网络信息，IPAddress是172.17.0.3</span>
<span class="token function">docker</span> inspect u2 <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n</span> <span class="token number">20</span>
<span class="token comment"># 删掉u2，创建u3，查看u3的ip是172.17.0.3</span>
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> u2
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> u3 ubuntu <span class="token function">bash</span>
<span class="token function">docker</span> inspect u3 <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n</span> <span class="token number">20</span>
</code></pre> 
<p>结论：docker容器内部的ip是有可能会发生改变的</p> 
<h3><a id="46_1065"></a>4.6案例说明</h3> 
<h4><a id="bridge_1067"></a>bridge</h4> 
<p>查看网络源数据<code>docker network inspect bridge</code></p> 
<blockquote> 
 <p>Docker服务默认会创建一个docker0网桥（其上有一个dockero内部接口），该桥接网络的名称为docker0。</p> 
 <p>它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到<u>同一个物理网络</u>。</p> 
 <p>Docker默认指定了docker0接口的IP 地址和子网掩码，<u>让主机和容器之间可以通过网桥相互通信</u>。</p> 
</blockquote> 
<pre><code class="prism language-shell"><span class="token comment"># 查看bridge网络的详细信息，并通过grep获取名称项</span>
<span class="token function">docker</span> network inspect bridge <span class="token operator">|</span> <span class="token function">grep</span> name
<span class="token comment"># 看docker0</span>
<span class="token function">ifconfig</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">docker</span>
</code></pre> 
<p>说明</p> 
<blockquote> 
 <ol><li> <p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥（docker0），Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p> </li><li> <p><code>docker run</code>时，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig，就可以看到docker0和自己create的network（后面讲）eth0,eth1,eth2……代表网卡一、二、三……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址</p> </li><li> <p>网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。</p> </li></ol> 
 <p>3.1 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair)；</p> 
 <p>3.2 每个容器实例内部也有一块网卡，每个接口叫eth0；</p> 
 <p>3.3 docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。</p> 
 <p>通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下，会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/22/20/dxlDp3TM_o.png" alt="在这里插入图片描述" width="400"></p> 
<p>代码</p> 
<pre><code class="prism language-shell"><span class="token comment"># 启动两个tomcat</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8081</span>:8080 <span class="token parameter variable">--name</span> tomcat81 billygoo/tomcat8-jdk8
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8082</span>:8080 <span class="token parameter variable">--name</span> tomcat81 billygoo/tomcat8-jdk8
<span class="token function">docker</span> <span class="token function">ps</span>
<span class="token comment"># 会发现多了几个类似【25：veth2844760@if24】。宿主机上是veth。</span>
<span class="token function">ip</span> addr
<span class="token comment"># 进入tomcat81</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> tomcat81 <span class="token function">bash</span>
<span class="token comment"># 在tomcat81里面查看，有【24：eth0@if25】，容器内部是eth。</span>
<span class="token comment"># 24和25，宿主机和容器内一一匹配。</span>
<span class="token function">ip</span> addr
</code></pre> 
<h4><a id="host_1120"></a>host</h4> 
<blockquote> 
 <p>直接使用宿主机的IP地址与外界进行通信，不再需要额外进行NAT转换。</p> 
 <p>容器将不会得一个独立的Network Namespace, 而是和宿主机共用一个Network Namespace。<u>容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口</u>。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a7/7e/EyL4nY9p_o.png" alt="在这里插入图片描述" width="400"></p> 
<p><strong>代码-警告</strong></p> 
<pre><code class="prism language-shell"><span class="token comment"># 以前redis三主三从用的就是【--network host】模式</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8083</span>:8080 <span class="token parameter variable">--network</span> <span class="token function">host</span> <span class="token parameter variable">--name</span> tomcat83 billygoo/tomcat8-jdk8
</code></pre> 
<p>问题：</p> 
<p>docker启动时遇见警告</p> 
<blockquote> 
 <p>WARNING: PubLished ports are discarded when using host network mode</p> 
</blockquote> 
<p>原因：</p> 
<p>docker启动时指定<code>--network=host</code>或<code>-net=host</code>，如果还指定了-p映射端口，此时就会有该警告，<br> 并且通过-p设置的参数将不会起到任何作用（<code>docker ps</code>查看该容器时PORTS列为空），端口号会以主机端口号为主，重复时则递增。</p> 
<p>解决：</p> 
<p>使用docker的其他网络模式，例如<code>--network=bridge</code>，这样就可以解决问题，或者直接无视</p> 
<p><strong>代码-正确</strong></p> 
<pre><code class="prism language-shell"><span class="token comment"># 启动tomcat83，以host模式</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--network</span> <span class="token function">host</span> <span class="token parameter variable">--name</span> tomcat83 billygoo/tomcat8-jdk8
<span class="token comment"># 在宿主机上查看tomcat83容器实例内部网络情况。由于跟宿主机共用一套，无之前的配对显示了，Gateway和IPAddress字段值是空的。</span>
<span class="token function">docker</span> inspect tomcat83
<span class="token comment"># 在容器内部查看tomcat83容器实例内部网络情况。</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> tomcat83 <span class="token function">bash</span>
<span class="token comment"># 跟外面宿主机执行【ip addr】的查看结果几乎一样。</span>
<span class="token function">ip</span> addr
</code></pre> 
<p>没有设置-p的端口映射了，如何访问启动的tomcat83：</p> 
<p>端口号会以主机端口号为主，重复时则递增。在浏览器访问【http://宿主机ip:8080/】<br> 在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的。<br> 所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</p> 
<h4><a id="none_1170"></a>none</h4> 
<blockquote> 
 <p>禁用网络功能，只有lo标识（就是127.0.0.1表示本地回环）</p> 
 <p>在none模式下，并不为Docker容器进行任何网络配置。<br> 也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo<br> 需要我们自己为Docker容器添加网卡、配置IP等。</p> 
</blockquote> 
<p>案例</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8084</span>:8080 <span class="token parameter variable">--network</span> none <span class="token parameter variable">--name</span> tomcat84 billygoo/tomcat8-jdk8
<span class="token comment"># Gateway和IPAddress字段值是空的。</span>
<span class="token function">docker</span> inspect tomcat84 <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n</span> <span class="token number">20</span>
<span class="token comment"># 查看该容器时PORTS列为空</span>
<span class="token function">docker</span> <span class="token function">ps</span>
<span class="token comment"># 在容器内部查看tomcat84容器实例内部网络情况。</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> tomcat84 <span class="token function">bash</span>
<span class="token comment"># 查询结果只有一个lo</span>
<span class="token function">ip</span> addr
</code></pre> 
<h4><a id="container_1192"></a>container</h4> 
<blockquote> 
 <p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。<br> 新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。<br> 同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/cd/f2/qxhy8S8T_o.png" alt="在这里插入图片描述" width="400"></p> 
<p>案例</p> 
<pre><code class="prism language-shell"><span class="token comment"># tomcat86和tomcat85共用同一个ip和同一个端口，导致端口冲突，用tomcat演示不合适。</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8085</span>:8080 <span class="token parameter variable">--name</span> tomcat85 billygoo/tomcat8-jdk8
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8086</span>:8080 <span class="token parameter variable">--network</span> container:tomcat85 ---name tomcat85 billygoo/tomcat8-jdk8
<span class="token comment"># 会报错：</span>
<span class="token comment"># docker: Error response from daemon: conflicting options: port publishing and the container type network mode.</span>
<span class="token comment"># See 'docker run … help)."vw wusmw. cw accay vpcavs. pw,. pwv</span>
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> tomcat85
</code></pre> 
<p>Alpine操作系统是一个面向安全的轻型Linux发行版</p> 
<blockquote> 
 <p>Alpine Linux是一款独立的、非商业的通用Linux发行版，专为追求安全性、简单性和资源效率的用户而设计。</p> 
 <p>可能很多人没听说过这个Linux发行版本，但是经常用Docker的朋友可能都用过，它以小、简单、安全而著称，所以作为基础镜像是非常好的一个选择，可谓是麻雀虽小但五脏俱全，镜像非常小巧，不到6M的大小，所以特别适合容器打包。</p> 
</blockquote> 
<pre><code class="prism language-shell"><span class="token comment"># 注意它是/bin/sh</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> alpine1 alpine /bin/sh
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--network</span> container:alpine1 <span class="token parameter variable">--name</span> alpine2 alpine /bin/sh
<span class="token comment"># 在两个容器内部各执行ip addr</span>
<span class="token comment"># alpine1和alpine1显示的都是【28：eth0@if29】，inet都是【172.17.0.2】</span>
<span class="token function">ip</span> addr
</code></pre> 
<p>假如此时关闭alpine1，再<code>ip addr</code>看看alpine2，就没有刚才alpine1的ip和端口了。</p> 
<h4><a id="_1230"></a>自定义网络</h4> 
<p>未使用自定义网络时的痛点：按照ip能ping通，而按照名字不能。</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8081</span>:8080 <span class="token parameter variable">--name</span> tomcat81 billygoo/tomcat8-jdk8
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8082</span>:8080 <span class="token parameter variable">--name</span> tomcat82 billygoo/tomcat8-jdk8
<span class="token comment"># 上述成功启动，进入各自容器实例内部</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> tomcat81 <span class="token function">bash</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> tomcat82 <span class="token function">bash</span>
<span class="token comment"># ip addr拿到各自ip，按照ip地址ping是OK的</span>
<span class="token function">ip</span> addr
<span class="token function">ping</span> 对方ip
<span class="token comment"># 按照服务名ping，会报错【ping：tomcatXX：Name or service not known】</span>
<span class="token function">ping</span> tomcat82
<span class="token function">ping</span> tomcat81
</code></pre> 
<blockquote> 
 <p>没有<code>ip addr</code>直接<code>apt update</code>然后<code>apt -y install iproute2</code></p> 
 <p>ping命令下载：<code>apt install iputils-ping</code></p> 
</blockquote> 
<p>自定义桥接网络，自定义网络默认使用的是桥接网络bridge</p> 
<p>新建自定义网络</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> network create zzyy_network
<span class="token function">docker</span> network <span class="token function">ls</span>
</code></pre> 
<p>新建容器加入上一步新建的自定义网络</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8081</span>:8080 <span class="token parameter variable">--network</span> zzyy_network <span class="token parameter variable">--name</span> tomcat81 billygoo/tomcat8-jdk8
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8082</span>:8080 <span class="token parameter variable">--network</span> zzyy_network <span class="token parameter variable">--name</span> tomcat82 billygoo/tomcat8-jdk8

<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> tomcat81 <span class="token function">bash</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> tomcat82 <span class="token function">bash</span>
<span class="token comment"># 此时可以用名字ping通了</span>
</code></pre> 
<p>结论：自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p> 
<h2><a id="5Dockercompose_1274"></a>5.Docker-compose容器编排</h2> 
<p>定义</p> 
<blockquote> 
 <p>Docker-Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</p> 
 <p>Compose是Docker公司指出的一个工具软件，可以管理多个Docker容器组成一个应用。你需要定义一个YAML格式的配置文件docker-compose.yml，<u>写好多个容器之间的调用关系</u>。然后，只要一个命令，就能同时启动/关闭这些容器</p> 
</blockquote> 
<p>作用</p> 
<blockquote> 
 <p>docker建议我们每一个容器中只运行一个服务，因为docker容器本身占用资源极少，所以最好是将每个服务单独的分割开来。但是这样我们又面临了一个问题：需要同时部署很多服务时，若每个服务单独写Dockerfile然后再构建镜像、构建容器，很麻烦，所以docker官方给我们提供了docker-compose多服务部署的工具。</p> 
 <p>例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器、redis服务器、注册中心，甚至<br> 还包括负载均衡容器……</p> 
 <p>Compose允许用户通过一个单独的<u>docker-compose.yml</u>模板文件（YAML格式）来<u>定义一组相关联的应用容器为一个项目（project）</u>。</p> 
 <p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose解决了容器与容器之间如何管理编排的问题。</p> 
</blockquote> 
<p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/" rel="nofollow">官网 Compose file version 3 reference | Docker Docs</a></p> 
<p><a href="https://docs.docker.com/compose/install/" rel="nofollow">官网下载 Overview of installing Docker Compose | Docker Docs</a></p> 
<p>docker18后面的版本自带compose了</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> compose version
</code></pre> 
<p><img src="https://images2.imgbox.com/ab/12/aOUgSl1g_o.png" alt="在这里插入图片描述" width="400"></p> 
<h3><a id="Compose_1306"></a>Compose核心概念</h3> 
<p><strong>一文件：</strong></p> 
<p>docker-compose.yml</p> 
<p><strong>两要素：</strong></p> 
<p>服务（service）- 一个个应用容器实例，比如订单微服务、库存微服务、MySQL容器、Nginx容器或者Redis容器等。</p> 
<p>工程（project）- 由一组关联的应用容器组成的一个<u>完整业务单元</u>，在docker-compose.yml文件中定义。</p> 
<h3><a id="Compose_1318"></a>Compose使用的三个步骤</h3> 
<p>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</p> 
<p>使用docker-compose.yml定义一个完整业务单元，安排好整体应用中的各个容器服务。</p> 
<p>最后，执行<code>docker-compose up</code>命令来启动并运行整个应用程序，完成一键部署上线</p> 
<h3><a id="Compose_1326"></a>Compose常用命令</h3> 
<p>新版命令由<code>docker-compose</code>变为<code>docker compose</code>，没有中间的连接符</p> 
<table><thead><tr><th>命令</th><th>释义</th></tr></thead><tbody><tr><td>docker-compose -h</td><td>查看帮助</td></tr><tr><td>docker-compose up</td><td>启动所有docker-compose服务</td></tr><tr><td>docker-compose up -d</td><td>启动所有docker-compose服务并后台运行</td></tr><tr><td>docker-compose down</td><td>停止并删除容器、网络、卷、镜像。</td></tr><tr><td>docker-compose exec yml里面的服务id</td><td>进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id /bin/bash</td></tr><tr><td>docker-compose ps</td><td>展示当前docker-compose编排过的运行的所有容器</td></tr><tr><td>docker-compose top</td><td>展示当前docker-compose编排过的容器进程</td></tr><tr><td>docker-compose logs yml里面的服务id</td><td>查看容器输出日志</td></tr><tr><td>dokcer-compose config</td><td>检查配置</td></tr><tr><td>dokcer-compose config -q</td><td>检查配置，有问题才有输出</td></tr><tr><td>docker-compose restart</td><td>重启服务</td></tr><tr><td>docker-compose start</td><td>启动服务</td></tr><tr><td>docker-compose stop</td><td>停止服务</td></tr></tbody></table> 
<h3><a id="Compose_1346"></a>Compose编排微服务</h3> 
<h4><a id="docker_boot_1348"></a>改造升级微服务工程docker_boot</h4> 
<p>以前的基础版docker_boot只是最基础的能启动的一个SpringBoot工程</p> 
<p>SQL建表建库</p> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t_user<span class="token punctuation">`</span></span><span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>username<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户名'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>password<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'密码'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>sex<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'性别 O=女 1=男'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>deleted<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'删除标志，默认0不删除，1删除 '</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'更新时间'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span></span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'用户表'</span>
</code></pre> 
<p>改POM：引入一些比如Guava、redisson、swagger、springCache、MySQL等依赖</p> 
<p>写YML：<code>server.port=6001</code>，以及其他引入依赖所需做的配置（Redis和MySQL等一些相关ip的配置目前都是固定写死的）</p> 
<p>主启动类和业务类，做一个增删改查的接口，且有将数据写入Redis的逻辑。</p> 
<p><code>mvn package</code>命令将微服务形成新的jar包，并上传到Linux服务器/mydocker目录下（详见【3.Docker微服务实战】，Dockerfile和构建镜像的也一样）</p> 
<p>编写Dockerfile</p> 
<p>构建镜像：<code>docker build -t zzyy_docker:1.6 .</code></p> 
<h4><a id="Compose_1379"></a>不用Compose</h4> 
<p>单独的mysql容器实例</p> 
<pre><code class="prism language-shell"><span class="token comment"># 新建mysql容器实例</span>
<span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 <span class="token parameter variable">--name</span> mysql57 <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /zzyyuse/mysql/conf:/etc/mysql/conf.d <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /zzyyuse/mysq/logs:/logs <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /zzyyuse/mysql/data:/var/lib/mysql <span class="token punctuation">\</span>
<span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token parameter variable">-d</span> mysql:5.7
</code></pre> 
<p>进入mysql容器实例</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysql57 <span class="token function">bash</span>
</code></pre> 
<p>新建库db2021+新建表t_user</p> 
<pre><code class="prism language-sql">mysql <span class="token operator">-</span>uroot <span class="token operator">-</span>p
creat <span class="token keyword">database</span> db2021<span class="token punctuation">;</span>
<span class="token keyword">use</span> db2021<span class="token punctuation">;</span>
<span class="token comment"># 拷贝上面的建t_user表的语句</span>
</code></pre> 
<p>单独的redis容器实例</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">6379</span>:6379 <span class="token parameter variable">--name</span> redis608 <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /app/redis/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /app/redis/data:/data <span class="token punctuation">\</span>
<span class="token parameter variable">-d</span> redis:6.0.8 <span class="token punctuation">\</span>
redis-server /etc/redis/redis.conf


<span class="token function">docker</span> <span class="token function">ps</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis608 <span class="token function">bash</span>
redis-cli <span class="token parameter variable">-p</span> <span class="token number">6379</span>
</code></pre> 
<p>微服务工程</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> images zzyy_docker:1.6
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">6001</span>:6001 上面镜像的ID
<span class="token function">docker</span> <span class="token function">ps</span>
</code></pre> 
<p>上面三个容器实例依次顺序启动成功</p> 
<h4><a id="swagger_1432"></a>swagger测试</h4> 
<p>http://localhost:微服务端口/swagger-ui.html#/</p> 
<p>调试接口插入和查询数据，查看容器内Redis和MySQL的读写数据情况。</p> 
<h4><a id="_1438"></a>上面成功了，有哪些问题？</h4> 
<p>先后顺序要求固定先mysql+redis才能微服务访问成功</p> 
<p>多个run命令</p> 
<p>容器间的启停或宕机，有可能导致IP地址对应的容器实例变化，映射出错，要么生产IP写死（可以但是不推荐），要么通过服务调用</p> 
<h4><a id="Compose_1446"></a>使用Compose</h4> 
<h5><a id="dockercomposeyml_1448"></a>编写docker-compose.yml文件</h5> 
<p>services：有几个服务容器实例</p> 
<p>microService：自己定义的服务名，不冲突就可以。</p> 
<p>container_name：容器名字。若不指定，则最终变成【当前路径_服务名字_1】，比如【mydocker_redis_1】</p> 
<pre><code class="prism language-shell"><span class="token comment"># yml中的第一大段相当于写了个docker run命令</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">6001</span>:6001 <span class="token parameter variable">--name</span> ms01 <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /app/microServ <span class="token punctuation">\</span>
<span class="token parameter variable">--network</span> atguigu_net <span class="token punctuation">\</span>
zzyy_docker:1.6
</code></pre> 
<pre><code class="prism language-yml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">microService</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> zzyy_docker<span class="token punctuation">:</span><span class="token number">1.6</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> ms01
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"6001:6001"</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> /app/microService<span class="token punctuation">:</span>/data
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> atguigu_net
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> redis
      <span class="token punctuation">-</span> mysql

  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>6.0.8
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"6379:6379"</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> /app/redis/redis.conf<span class="token punctuation">:</span>/etc/redis/redis.conf
      <span class="token punctuation">-</span> /app/redis/data<span class="token punctuation">:</span>/data
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> atguigu_net
    <span class="token key atrule">command</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>server /etc/redis/redis.conf

  <span class="token key atrule">mysql</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">MYSQL_RO0T_PASSWORD</span><span class="token punctuation">:</span> <span class="token string">'123456'</span>
      <span class="token key atrule">MYSQL_ALLOW_EMPTY_PASSWORD</span><span class="token punctuation">:</span> <span class="token string">'no'</span>
      <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> <span class="token string">'db2021'</span>
      <span class="token key atrule">MYSQL_USER</span><span class="token punctuation">:</span> <span class="token string">'zzyy'</span>
      <span class="token key atrule">MYSQL_PASSWORD</span><span class="token punctuation">:</span> <span class="token string">'zzyy123'</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"3306:3306"</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> /app/mysql/db<span class="token punctuation">:</span>/var/lib/mysql
      <span class="token punctuation">-</span> /app/mysql/conf/my.cnf<span class="token punctuation">:</span>/etc/my.cnf
      <span class="token punctuation">-</span> /app/mysql/init<span class="token punctuation">:</span>/docker<span class="token punctuation">-</span>entrypoint<span class="token punctuation">-</span>initdb.d
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> atguigu_net
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>default<span class="token punctuation">-</span>authentication<span class="token punctuation">-</span>plugin=mysql_native_password <span class="token comment">#解决外部无法访问</span>

<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">atguigu_net</span><span class="token punctuation">:</span>
</code></pre> 
<pre><code class="prism language-shell"><span class="token builtin class-name">cd</span> /mydocker
<span class="token function">vim</span> docker-compose.yml
<span class="token comment"># /mydocker路径下有Dockerfile、jar包、docker-compose.yml</span>
</code></pre> 
<h5><a id="docker_boot_1520"></a>第二次修改微服务工程docker boot</h5> 
<p>把SpringBoot工程中MySQL和Redis相关的配置，由ip改为docker-compose.yml文件中设置的容器名字</p> 
<p>比如</p> 
<pre><code class="prism language-properties">#spring.datasource.url=jdbc:mysql://192.168.111.169:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false
spring.datasource.url=jdbc:mysql://mysql:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false

#spring.redis.host=192.168.111.169
spring.redis.host=redis
</code></pre> 
<p><code>mvn package</code>命令将微服务形成新的jar包，并上传到Linux服务器/mydocker目录下。</p> 
<p>编写Dockerfile</p> 
<p>把之前的镜像zzyy_docker:1.6删掉，Redis容器和MySQL容器也可以都停掉。</p> 
<p>构建镜像<code>docker build -t zzyy_docker:1.6 .</code></p> 
<h5><a id="dockercompose_1542"></a>启动所有docker-compose服务</h5> 
<pre><code class="prism language-shell"><span class="token comment"># 检查编写的配置语法格式，有问题才有输出。</span>
<span class="token function">docker-compose</span> config <span class="token parameter variable">-q</span>
<span class="token function">docker</span> <span class="token function">ps</span>
<span class="token comment"># 执行docker-compose up（前台运行）或者docker-compose up -d（后台运行）</span>
<span class="token comment"># docker-compose up</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span>
<span class="token comment"># 会发现三个容器都启动好了，网络也创建了，网络名字叫mydocker_atguigu_net</span>
<span class="token function">docker</span> network <span class="token function">ls</span>
<span class="token function">docker</span> <span class="token function">ps</span>
</code></pre> 
<p>进入mysql容器实例并新建库db2021+新建表t_user（同上）</p> 
<p>swagger测试通过（同上）</p> 
<h5><a id="_1560"></a>关停</h5> 
<p><code>docker-compose stop</code></p> 
<h2><a id="6DockerPortainer_1564"></a>6.Docker轻量级可视化工具Portainer</h2> 
<blockquote> 
 <p>Portainer是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p> 
</blockquote> 
<p>安装</p> 
<p><a href="https://www.portainer.io/" rel="nofollow">官网首页 https://www.portainer.io/</a></p> 
<p><a href="https://www.portainer.io/install" rel="nofollow">官网安装 Install Portainer</a></p> 
<p><a href="https://docs.portainer.io/start/install-ce/server/docker/linux" rel="nofollow">Install Portainer CE with Docker on Linux - Portainer Documentation</a></p> 
<p>docker命令安装</p> 
<pre><code class="prism language-shell"><span class="token comment"># 可以先pull再run，但没必要</span>
<span class="token comment"># docker pull portainer/portainer-ce:latest</span>

<span class="token comment"># --restart=always表示若docker重启了，该容器也会跟着重启，保证随时在线</span>
<span class="token comment"># 视频教程给出的【9000:9000】，2023.12官网给出的是【9443:9443】</span>
<span class="token comment"># 官网映射的9443是https，若要用http访问就映射9000</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8000</span>:8000 <span class="token parameter variable">-p</span> <span class="token number">9000</span>:9000 <span class="token punctuation">\</span>
<span class="token parameter variable">--name</span> portainer <span class="token punctuation">\</span>
<span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /var/run/docker.sock:/var/run/docker.sock <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> portainer_data:/data <span class="token punctuation">\</span>
portainer/portainer-ce:latest
</code></pre> 
<p><img src="https://images2.imgbox.com/9d/57/u79Sa69W_o.png" alt="在这里插入图片描述" width="800"></p> 
<p>第一次登录需创建admin，访问地址：xxx.xxx.xxx.xxx:9000</p> 
<p>设置admin用户和密码后首次登陆</p> 
<p>选择local选项卡后本地docker详细信息展示</p> 
<p><img src="https://images2.imgbox.com/00/41/g7VmzMEa_o.png" alt="在这里插入图片描述" width="800"></p> 
<p>上一步的图形展示，对应命令是<code>docker system df</code></p> 
<p>可尝试使用Portainer安装Nginx：左侧菜单栏Container - 点击Add Container按钮</p> 
<p><img src="https://images2.imgbox.com/d2/4a/dsJPVos3_o.png" alt="在这里插入图片描述" width="800"></p> 
<h2><a id="7DockerCAdvisorInfluxDBGranfana_1612"></a>7.Docker容器监控之CAdvisor+InfluxDB+Granfana</h2> 
<p>通过<code>docker stats</code>命令可以很方便地看到当前宿主机上所有容器的CPU、内存、网络流量等数据，一般小公司够用了。</p> 
<p>但是，<code>docker stats</code>统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能.</p> 
<h3><a id="CIG_1618"></a>容器监控三剑客CIG</h3> 
<p>CAdvisor监控收集 + InfluxDB存储数据 + Granfana展示图表</p> 
<p><img src="https://images2.imgbox.com/63/21/TuqCva0M_o.png" alt="在这里插入图片描述" width="300"></p> 
<p>CAdvisor</p> 
<blockquote> 
 <p>CAdvisor是一个容器资源监控工具，包括容器的内存、CPU、网络IO、磁盘IO等监控，同时提供了一个WEB页面用于查看容器的实时运行状态，默认存储2分钟的数据，而且只是针对单物理机。</p> 
 <p>CAdvisor提供了很多数据集成接口，支持InfluxDB、Redis、Kafka、Elasticsearch等集成，可以加上对应配置将监控数据发往这些数据库存储起来。</p> 
 <p>CAdvisor功能主要有两点：</p> 
 <ul><li> <p>展示Host和容器两个层次的监控数据。</p> </li><li> <p>展示历史变化数据。</p> </li></ul> 
</blockquote> 
<p>InfluxDB</p> 
<blockquote> 
 <p>InfluxDB是用Go语言编写的一个开源分布式时序、事件和指标数据库，无需外部依赖。</p> 
 <p>CAdvisor默认只在本机保存最近2分钟的数据，为了持久化存储数据和统一收集展示监控数据，需要将数据存储到InfluxDB中。lnfluxDB是一个时序数据库，专门用于存储时序相关数据，很适合存储CAdvisor的数据。而且，CAdvisor本身已经提供了InfluxDB的集成方法，启动容器时指定配置即可。</p> 
 <p>InfluxDB主要功能：</p> 
 <ul><li> <p>基于时间序列，支持与时间有关的相关函数（如最大、最小、求和等）</p> </li><li> <p>可度量性：你可以实时对大量数据进行计算；</p> </li><li> <p>基于事件：它支持任意的事件数据；</p> </li></ul> 
</blockquote> 
<p>Granfana</p> 
<blockquote> 
 <p>Grafana是一个开源的数据监控分析可视化平台，支持多种数据源配置（支持的数据源包括InfluxDB、MySQL、Elasticsearch、OpenTSDB、Graphite等）和丰富的插件及模板功能，支持图表权限控制和报警。</p> 
 <p>Grafan主要特性：</p> 
 <ul><li> <p>灵活丰富的图形化选项</p> </li><li> <p>可以混合多种风格</p> </li><li> <p>支持白天和夜间模式</p> </li><li> <p>多个数据源</p> </li></ul> 
</blockquote> 
<p>总结</p> 
<blockquote> 
 <p><strong>cAdvisor</strong> - Collects, aggregates, processes, and exports information about running containers（收集、聚合、处理和导出有关正在运行的容器的信息）</p> 
 <p><strong>InfluxDB</strong> - Time Series Database stores all the metrics（时间序列数据库存储所有指标）</p> 
 <p><strong>Grafana</strong> - Metrics Dashboard（指标仪表板）</p> 
</blockquote> 
<h3><a id="ComposeCIG_1676"></a>Compose容器编排CIG</h3> 
<p>新建目录<code>mkdir /mydocker/cig</code>并进入</p> 
<p>新建3件套组合的<code>vim docker-compose.yml</code></p> 
<pre><code class="prism language-yml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.1'</span>

<span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token key atrule">grafana_data</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">influxdb</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> tutum/influxdb<span class="token punctuation">:</span><span class="token number">0.9</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> PRE_CREATE_DB=cadvisor
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"8083:8083"</span>
      <span class="token punctuation">-</span> <span class="token string">"8086:8086"</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./data/influxdb<span class="token punctuation">:</span>/data

  <span class="token key atrule">cadvisor</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> google/cadvisor
    <span class="token key atrule">links</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> influxdb<span class="token punctuation">:</span>influxsrv
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>storage_driver=influxdb <span class="token punctuation">-</span>storage_driver_db=cadvisor <span class="token punctuation">-</span>storage_driver_host=influxsrv<span class="token punctuation">:</span><span class="token number">8086</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"8080:8080"</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> /<span class="token punctuation">:</span>/rootfs<span class="token punctuation">:</span>ro
      <span class="token punctuation">-</span> /var/run<span class="token punctuation">:</span>/var/run<span class="token punctuation">:</span>rw
      <span class="token punctuation">-</span> /sys<span class="token punctuation">:</span>/syS<span class="token punctuation">:</span>ro
      <span class="token punctuation">-</span> /var/lib/docker/<span class="token punctuation">:</span>/var/lib/docker<span class="token punctuation">:</span>ro

  <span class="token key atrule">grafana</span><span class="token punctuation">:</span>
    <span class="token key atrule">user</span><span class="token punctuation">:</span> <span class="token string">"104"</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> grafana/grafana
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">links</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> influxdb<span class="token punctuation">:</span>influxsrv
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"3000:3000"</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> grafana_data<span class="token punctuation">:</span>/var/lib/grafana
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> HTTP_USER=admin
      <span class="token punctuation">-</span> HTTP_PASS=admin
      <span class="token punctuation">-</span> INFLUXDB_HOST=influxsrv
      <span class="token punctuation">-</span> INFLUXDB_PORT=8086
      <span class="token punctuation">-</span> INFLUXDB_NAME=cadvisor
      <span class="token punctuation">-</span> INFLUXDB_USER=root
      <span class="token punctuation">-</span> INFLUXDB_PASS=root
</code></pre> 
<pre><code class="prism language-shell"><span class="token comment"># 检查语法</span>
<span class="token function">docker</span> compose config <span class="token parameter variable">-q</span>
<span class="token comment"># 启动docker-compose文件</span>
<span class="token function">docker</span> compose up
<span class="token comment"># 查看三个服务容器是否启动</span>
<span class="token function">docker</span> <span class="token function">ps</span>
</code></pre> 
<p>浏览cAdvisor收集服务，http:/ip:8080/</p> 
<blockquote> 
 <p>第一次访问慢，请稍等<br> cadvisor也有基础的图形展现功能，这里主要用它来作数据采集</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/bd/f6/YBPRSWcF_o.png" alt="在这里插入图片描述" width="400"></p> 
<p>浏览influxdb存储服务，http://ip:8083/</p> 
<blockquote> 
 <p>8083端口是对外暴露的web界面</p> 
 <p>8086端口是数据连接的</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/fc/87/df11uIXX_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>浏览grafana展现服务，http://ip:3000</p> 
<blockquote> 
 <p>默认账户密码admin/admin</p> 
</blockquote> 
<p>grafana配置步骤</p> 
<p>配置数据源</p> 
<p>configuration - Data sources - 选择InfluxDB数据源</p> 
<p><img src="https://images2.imgbox.com/1d/35/Bil1g7qT_o.png" alt="在这里插入图片描述" width="200"></p> 
<p>配置细节</p> 
<p><img src="https://images2.imgbox.com/2a/10/N7gvSN1y_o.png" alt="在这里插入图片描述" width="400"></p> 
<p><img src="https://images2.imgbox.com/6a/34/Oc1sIYNJ_o.png" alt="在这里插入图片描述" width="400"></p> 
<p>配置面板panel</p> 
<p><img src="https://images2.imgbox.com/64/e2/LnZ38lsZ_o.png" alt="在这里插入图片描述" width="200"></p> 
<p><img src="https://images2.imgbox.com/4f/3a/aFIjFrVk_o.png" alt="在这里插入图片描述" width="500"></p> 
<p><img src="https://images2.imgbox.com/23/75/AkBkXnnj_o.png" alt="在这里插入图片描述" width="300"></p> 
<p><img src="https://images2.imgbox.com/6a/af/So5XQJPX_o.png" alt="在这里插入图片描述" width="300"></p> 
<p><img src="https://images2.imgbox.com/e4/f0/70BOO1Af_o.png" alt="在这里插入图片描述" width="300"></p> 
<p><img src="https://images2.imgbox.com/e2/46/aPpIcZVZ_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>若要监控多个维度，可以【+Query】，比如一个监控CPU，一个监控内存之类的</p> 
<p><img src="https://images2.imgbox.com/9d/d7/3K17ahTV_o.png" alt="在这里插入图片描述" width="500"></p> 
<p><img src="https://images2.imgbox.com/d1/7d/I1W2apjM_o.png" alt="在这里插入图片描述" width="800"></p> 
<p><img src="https://images2.imgbox.com/85/de/GoE56HWW_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>到这里cAdvisor+InfluxDB+Grafana容器监控系统就部署完成了</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fc7301d6ebe0781864f2f9e8e3288315/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">记一次gorm连接池打满，连接不释放的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b34c40d1fba014dbe86542e6546f16a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【ELEC362 】APPLICATION DEVELOPMENT WITH</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>