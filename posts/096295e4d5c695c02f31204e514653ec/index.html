<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>自定义QGraphicsItem - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="自定义QGraphicsItem" />
<meta property="og:description" content="文章目录 前言：简述自定义 QGraphicsItemBoundingRect() 和 Shape()的区别参照模型使用示例效果源码 前言： 本文参考https://blog.csdn.net/liang19890820/article/details/53132180
简述 继承 QGraphicsItem，自定义item。
自定义 QGraphicsItem 要实现自定义 item，需要覆盖 QGraphicsItem 的两个纯虚函数：
void paint()
QRectF boundingRect()
​ 注意：坐标为item坐标系
tips：关于信号/槽、事件、算法相关的内容，本节暂时不做讲解，放到后面章节。
BoundingRect() 和 Shape()的区别 参照模型 要实现这个效果很简单，可以逐步分解：
整体（最外侧的圆）眼睛（左眼/右眼）嘴（笑容） 分别计算出各部分的区域坐标、大小，然后根据形状进行绘制。
上述图案标识的是绝对位置，为了适应各种大小， 可以进行比例及相对位置换算，将各部分进行逐一转换。
使用示例 效果 下图显示了 3 个不同大小的笑脸：（不好意思，为了简便，没画眼球，成了柯大侠了，哈哈。）
源码 SmileItem.h：
#pragma once #include &lt;QGraphicsItem&gt; #include &lt;QRectF&gt; class SmileItem : public QGraphicsItem { public: explicit SmileItem(QGraphicsItem* parent = NULL); explicit SmileItem(const QRectF &amp; rect, QGraphicsItem * parent); explicit SmileItem(qreal x, qreal y, qreal w, qreal h, QGraphicsItem * parent); QRectF rect() const; void setRect(const QRectF &amp; rect); ~SmileItem(); protected: QRectF boundingRect() const; //override void paint(QPainter * painter, const QStyleOptionGraphicsItem * option, QWidget * widget); //override private: QRectF m_rect; mutable QRectF m_boundingRect; void updateRect(); inline void setRect(qreal ax, qreal ay, qreal w, qreal h); // 缩放比例 double m_dScale; // 左眼、右眼、嘴的中点 QPointF m_leftEyeCenter; QPointF m_rightEyecenter; QPointF m_smileCenter; // 眼睛的宽度、高度 double m_dEyeWidth; double m_dEyeHeight; // 嘴的高度、宽度 double m_dSmileWidth; double m_dSmileHeight; }; SmileItem." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/096295e4d5c695c02f31204e514653ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-14T16:38:29+08:00" />
<meta property="article:modified_time" content="2020-06-14T16:38:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">自定义QGraphicsItem</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言：</a></li><li><a href="#_5" rel="nofollow">简述</a></li><li><a href="#_QGraphicsItem_9" rel="nofollow">自定义 QGraphicsItem</a></li><li><a href="#BoundingRect__Shape_23" rel="nofollow">BoundingRect() 和 Shape()的区别</a></li><li><a href="#_25" rel="nofollow">参照模型</a></li><li><a href="#_39" rel="nofollow">使用示例</a></li><li><ul><li><a href="#_41" rel="nofollow">效果</a></li><li><a href="#_47" rel="nofollow">源码</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言：</h2> 
<p>本文参考<a href="https://blog.csdn.net/liang19890820/article/details/53132180">https://blog.csdn.net/liang19890820/article/details/53132180</a></p> 
<h2><a id="_5"></a>简述</h2> 
<p>继承 QGraphicsItem，自定义item。</p> 
<h2><a id="_QGraphicsItem_9"></a>自定义 QGraphicsItem</h2> 
<p>要实现自定义 item，需要覆盖 QGraphicsItem 的两个纯虚函数：</p> 
<p>void paint()</p> 
<p>QRectF boundingRect()</p> 
<p>​ 注意：坐标为item坐标系</p> 
<p><u>tips：关于信号/槽、事件、算法相关的内容，本节暂时不做讲解，放到后面章节。</u></p> 
<h2><a id="BoundingRect__Shape_23"></a>BoundingRect() 和 Shape()的区别</h2> 
<h2><a id="_25"></a>参照模型</h2> 
<p><img src="https://images2.imgbox.com/d2/d3/88bxaHxs_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iBI6X7CX-1592123801128)(E:\csdn博客备份%5CUsers%5CWGJ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1592121226979.png)]"></p> 
<p>要实现这个效果很简单，可以逐步分解：</p> 
<ul><li>整体（最外侧的圆）</li><li>眼睛（左眼/右眼）</li><li>嘴（笑容）</li></ul> 
<p>分别计算出各部分的区域坐标、大小，然后根据形状进行绘制。</p> 
<p>上述图案标识的是绝对位置，为了适应各种大小， 可以进行比例及相对位置换算，将各部分进行逐一转换。</p> 
<h2><a id="_39"></a>使用示例</h2> 
<h3><a id="_41"></a>效果</h3> 
<p>下图显示了 3 个不同大小的笑脸：（不好意思，为了简便，没画眼球，成了柯大侠了，哈哈。）</p> 
<p><img src="https://images2.imgbox.com/cf/a6/yqvwmDdt_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_47"></a>源码</h3> 
<p>SmileItem.h：</p> 
<pre><code class="prism language-c++">#pragma once

#include &lt;QGraphicsItem&gt;
#include &lt;QRectF&gt;

class SmileItem : public QGraphicsItem
{
public:
	explicit SmileItem(QGraphicsItem* parent = NULL);
	explicit SmileItem(const QRectF &amp; rect, QGraphicsItem * parent);
	explicit SmileItem(qreal x, qreal y, qreal w, qreal h, QGraphicsItem * parent);

	QRectF rect() const;

	void setRect(const QRectF &amp; rect);

	~SmileItem();

protected:
	QRectF boundingRect() const; //override
	void paint(QPainter * painter, const QStyleOptionGraphicsItem * option, QWidget * widget); //override


private:
	QRectF m_rect;

	mutable QRectF m_boundingRect;

	void updateRect();

	inline void setRect(qreal ax, qreal ay, qreal w, qreal h);


	// 缩放比例
	double m_dScale;

	// 左眼、右眼、嘴的中点
	QPointF m_leftEyeCenter;
	QPointF m_rightEyecenter;
	QPointF m_smileCenter;

	// 眼睛的宽度、高度
	double m_dEyeWidth;
	double m_dEyeHeight;
	
	// 嘴的高度、宽度
	double m_dSmileWidth;
	double m_dSmileHeight;
};

</code></pre> 
<p>SmileItem.cpp：</p> 
<pre><code class="prism language-c++">#include "SmileItem.h"
#include &lt;QPainter&gt;

SmileItem::SmileItem(QGraphicsItem  *parent)
	: QGraphicsItem(parent)
{
	setRect(QRect(-50,-50,100,100));
}

SmileItem::~SmileItem()
{
}
SmileItem::SmileItem(const QRectF &amp;rect, QGraphicsItem *parent)
	: QGraphicsItem(parent)
{
	setRect(rect);
}
SmileItem::SmileItem(qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent)
	: QGraphicsItem(parent)
{
	setRect(x, y, w, h);
}

QRectF SmileItem::rect() const
{
	return m_rect;
}

void SmileItem::setRect(const QRectF &amp;rect)
{
	if (m_rect == rect)
		return;

	prepareGeometryChange(); //正如 setRect()，无论以任何方式更改 item 的几何形状，必须首先调用prepareGeometryChange()，以保证 QGraphicsScene 中的索引是最新的。
	m_rect = rect;
	m_boundingRect = QRectF(); //m_boundingRect为空
	updateRect();
	
	update(); //调用paintEvent重绘
}

QRectF SmileItem::boundingRect() const
{
	if (m_boundingRect.isNull())
		m_boundingRect = m_rect;

	return m_boundingRect;
}

//则会调用 updateRect() 来重新计算笑脸中各个部位的坐标、大小
void SmileItem::updateRect()
{
	// 缩放比例
	m_dScale = m_rect.width() / 100.0;
	//m_dScale = 1;

	// 左眼的中点
	m_leftEyeCenter.setX(-15 * m_dScale);
	m_leftEyeCenter.setY(-25 * m_dScale);

	// 右眼的中点
	m_rightEyecenter.setX(15 * m_dScale);
	m_rightEyecenter.setY(-25 * m_dScale);

	// 嘴的中点
	m_smileCenter.setX(0);
	m_smileCenter.setY(10 * m_dScale);

	// 眼睛的宽度、高度（宽度的 2 倍）
	m_dEyeWidth = m_rect.width() / (100.0 / 12);
	m_dEyeHeight = m_dEyeWidth * 2;

	// 嘴的高度、宽度
	m_dSmileWidth = m_rect.width() / (100.0 / 66);
	m_dSmileHeight = m_rect.height() / (100.0 / 50);
	
}

inline void SmileItem::setRect(qreal ax, qreal ay, qreal w, qreal h)
{
	setRect(QRectF(ax, ay, w, h));
}

void SmileItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
	Q_UNUSED(option);
	Q_UNUSED(widget);

	// 反走样
	painter-&gt;setRenderHint(QPainter::Antialiasing, true);

	// 脸
	painter-&gt;setPen(Qt::NoPen);
	painter-&gt;setBrush(Qt::yellow);
	painter-&gt;drawEllipse(m_rect);

	// 左眼
	painter-&gt;setPen(QPen(Qt::black));
	painter-&gt;setBrush(Qt::white);
	painter-&gt;drawEllipse(
		QRectF(m_leftEyeCenter.x() - m_dEyeWidth / 2, 
			m_leftEyeCenter.y() - m_dEyeHeight / 2,
			m_dEyeWidth, m_dEyeHeight));	

	// 右眼
	painter-&gt;setPen(QPen(Qt::black));
	painter-&gt;setBrush(Qt::white);
	painter-&gt;drawEllipse(
		QRectF(m_rightEyecenter.x() - m_dEyeWidth / 2, 
			m_rightEyecenter.y() - m_dEyeHeight / 2, 
			m_dEyeWidth, m_dEyeHeight));	

	// 嘴 - 笑容
	painter-&gt;setPen(QPen(Qt::red));
	painter-&gt;setBrush(Qt::NoBrush);

	//QPainterPath
	QPainterPath path;
	path.arcMoveTo(
		QRectF(-m_dSmileWidth / 2,
			-(m_dSmileHeight / 2 - m_smileCenter.y()),
			m_dSmileWidth, m_dSmileHeight), 
		0);
	path.arcTo(QRectF(-m_dSmileWidth / 2,
		-(m_dSmileHeight / 2 - m_smileCenter.y()), 
		m_dSmileWidth, m_dSmileHeight), 0, -180);
	painter-&gt;drawPath(path);
}

</code></pre> 
<p>main.cpp</p> 
<pre><code class="prism language-c++">#include "QtWidgetsApplication1.h"
#include &lt;QtWidgets/QApplication&gt;
#include &lt;QGraphicsSimpleTextItem&gt;
#include &lt;QGraphicsScene&gt;
#include &lt;QGraphicsView&gt;
#include "SmileItem.h"


int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

	SmileItem *pItem = new SmileItem();
	pItem-&gt;setRect(QRect(-25, -25, 50, 50));
	pItem-&gt;setPos(10, 50); //项在场景中的位置

	SmileItem *pItem2 = new SmileItem();
	pItem2-&gt;setRect(QRect(-50, -50, 100, 100));
	pItem2-&gt;setPos(100, 50);

	SmileItem *pItem3 = new SmileItem();
	pItem3-&gt;setRect(QRect(-75, -75, 150, 150));
	pItem3-&gt;setPos(250, 50);

	// 将笑脸添加至场景中
	QGraphicsScene *pScene = new QGraphicsScene();
	pScene-&gt;addItem(pItem);
	pScene-&gt;addItem(pItem2);
	pScene-&gt;addItem(pItem3);

	// 为视图设置场景
	QGraphicsView *pView = new QGraphicsView();
	pView-&gt;setScene(pScene);
	pView-&gt;show();

    return a.exec();
}

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/757a51ec79b96055ca96447632a4449d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">顺序消息分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a49ef05bc2b652978b0fd0d619e6a59/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iview 动态实现增减输入框</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>