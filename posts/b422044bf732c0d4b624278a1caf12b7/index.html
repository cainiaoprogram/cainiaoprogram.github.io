<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>g_main_loop_new (NULL, FALSE) 原理分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="g_main_loop_new (NULL, FALSE) 原理分析" />
<meta property="og:description" content="gtk_main，g_main_loop_new原理分析
我们知道GUI应用程序都是事件驱动的。这些事件大部分都来自于用户，比如键盘事件、鼠标事件或笔点事件。还有一些事件来自于系统内部，比如定时事件、socket事件和其它文件事件等等。在没有任何事件的情况下，应用程序处于睡眠状态。 因为这种事件驱动机制，GUI应用程序都毫无例外的需要一个主循环(main loop)。主循环(main loop)控制应用程序什么时候进入睡眠状态，什么时候被唤醒。主循环实现得好，应用程序才能工作正常又省电。 在GTK&#43;应用程序中，其主循环(main loop)非常简单，但是也非常的不明了： gtk_main (); 不少人用GTK&#43;写了很长时间的程序，还是觉得这行代码很神秘，不知道里面到底干了什么。
本文试图分析一下gtk_main的工作原理： gtk_main主要是对glib的main loop的包装，基本上分为三步：
1. 调用初始化函数。 2. 进入glib main loop 3. 调用~初始化函数。 所以弄清楚glib main loop之后，gtk_main的实现也就尽收眼底了，本文重点分析glib的main loop的实现。main loop使用模式大致如下：
loop = g_main_loop_new (NULL, TRUE); g_main_loop_run (loop); g_main_loop_new创建一个main loop对象，一个main loop对象只能被一个线程使用，但一个线程可以有多个main loop对象。在GTK&#43;应用中，一个线程使用多个main loop的主要用途是实现模态对话框，它在gtk_dialog_run函数里创建一个新的main loop，通过该main loop分发消息，直到对话框关闭为止。 g_main_loop_run则是进入主循环，它会一直阻塞在这里，直到让它退出为止。有事件时，它就处理事件，没事件时就睡眠。 g_main_loop_quit则是用于退出主循环，相当于Win32下的PostQuitMessage函数。 Glib main loop的最大特点就是支持多事件源，使用非常方便。来自用户的键盘和鼠标事件、来自系统的定时事件和socket事件等等，还支持一个称为idle的事件源，其主要用途是实现异步事件。
从最简单的例子开始：
//mainloop0.c #include&lt;glib.h&gt; GMainLoop* loop; int main(int argc, char* argv[]) { //g_thread_init是必需的，GMainLoop需要gthread库的支持。 if(g_thread_supported() == 0) g_thread_init(NULL); //创建一个循环体，先不管参数的意思。 g_print(&#34;g_main_loop_new/n&#34;); loop = g_main_loop_new(NULL, FALSE); //让这个循环体跑起来 g_print(&#34;g_main_loop_run/n&#34;); g_main_loop_run(loop); //循环运行完成后，计数器减一 //glib的很多结构类型和c&#43;&#43;的智能指针相似，拥有一个计数器 //当计数器为0时，自动释放资源。 g_print(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b422044bf732c0d4b624278a1caf12b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-12-03T14:48:37+08:00" />
<meta property="article:modified_time" content="2013-12-03T14:48:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">g_main_loop_new (NULL, FALSE) 原理分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-family:Arial; color:#333333"><span style="line-height:26px"><span style="white-space:pre"><span style="font-size:15px"></span><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px"><span style="font-size:18px"><strong><span style="white-space:pre"></span>gtk_main，g_main_loop_new原理分析</strong></span></span></span></span></span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:15px; line-height:26px"><span style="white-space:pre"></span>我们知道GUI应用程序都是事件驱动的。这些事件大部分都来自于用户，比如键盘事件、鼠标事件或笔点事件。还有一些事件来自于系统内部，比如定时事件、socket事件和其它文件事件等等。在没有任何事件的情况下，应用程序处于睡眠状态。 因为这种事件驱动机制，GUI应用程序都毫无例外的需要一个主循环(main loop)。主循环(main loop)控制应用程序什么时候进入睡眠状态，什么时候被唤醒。主循环实现得好，应用程序才能工作正常又省电。 </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:15px; line-height:26px"> 在GTK+应用程序中，其主循环(main loop)非常简单，但是也非常的不明了： gtk_main (); 不少人用GTK+写了很长时间的程序，还是觉得这行代码很神秘，不知道里面到底干了什么。</span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:15px; line-height:26px"><span style="white-space:pre"></span>本文试图分析一下gtk_main的工作原理： gtk_main主要是对glib的main loop的包装，基本上分为三步：<br> 1. 调用初始化函数。 <br> 2. 进入glib main loop <br> 3. 调用~初始化函数。 <br> 所以弄清楚glib main loop之后，gtk_main的实现也就尽收眼底了，本文重点分析glib的main loop的实现。main loop使用模式大致如下：<br> loop = g_main_loop_new (NULL, TRUE); <br> g_main_loop_run (loop); <br> g_main_loop_new创建一个main loop对象，一个main loop对象只能被一个线程使用，但一个线程可以有多个main loop对象。在GTK+应用中，一个线程使用多个main loop的主要用途是实现模态对话框，它在gtk_dialog_run函数里创建一个新的main loop，通过该main loop分发消息，直到对话框关闭为止。 g_main_loop_run则是进入主循环，它会一直阻塞在这里，直到让它退出为止。有事件时，它就处理事件，没事件时就睡眠。 g_main_loop_quit则是用于退出主循环，相当于Win32下的PostQuitMessage函数。 Glib main loop的最大特点就是支持多事件源，使用非常方便。来自用户的键盘和鼠标事件、来自系统的定时事件和socket事件等等，还支持一个称为idle的事件源，其主要用途是实现异步事件。</span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:15px; line-height:26px"><span style="font-family:Arial; font-size:15px; line-height:26px"></span></span></p> 
<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"> 从最简单的例子开始：<br> </p> 
<pre><code class="language-cpp">//mainloop0.c
#include&lt;glib.h&gt; 
GMainLoop* loop;
int main(int argc, char* argv[])
{
    //g_thread_init是必需的，GMainLoop需要gthread库的支持。
    if(g_thread_supported() == 0)
        g_thread_init(NULL);
    //创建一个循环体，先不管参数的意思。
    g_print("g_main_loop_new/n");
    loop = g_main_loop_new(NULL, FALSE);
    //让这个循环体跑起来
    g_print("g_main_loop_run/n");
    g_main_loop_run(loop);
    //循环运行完成后，计数器减一
    //glib的很多结构类型和c++的智能指针相似，拥有一个计数器
    //当计数器为0时，自动释放资源。
    g_print("g_main_loop_unref/n");
    g_main_loop_unref(loop);
    return 0;
}</code></pre>编译: 
<br> gcc -g `pkg-config --cflags --libs glib-2.0 gthread-2.0` mainloop0.c -o mainloop0 
<br> 然后运行： 
<br> ./mainloop0 
<br> 你会发现程序会在g_main_loop_run函数阻塞，这就是glib main loop了，如果没有人通知它退出，它是不会退出的。 
<br> 通知循环退出的函数是g_main_loop_quit。 
<br> 怎么通知呢？主线程被g_main_loop_run阻塞了，没办法运行quit。本来我准备开一个线程，sleep一秒钟，然后调用g_main_loop_quit。不过一想我们都在学习高精尖武器了，还用土枪土炮干啥。使用glib的定时器吧～ 
<br> //mainloop1.c 
<br> 
<pre><code class="language-cpp">#include&lt;glib.h&gt; 
GMainLoop* loop;

gint counter = 10;
gboolean callback(gpointer arg)
{
    g_print(".");
    if(--counter ==0){
        g_print("/n");
        //退出循环
        g_main_loop_quit(loop);
        //注销定时器
        return FALSE;
    }
    //定时器继续运行
    return TRUE;
}

int main(int argc, char* argv[])
{
    if(g_thread_supported() == 0)
        g_thread_init(NULL);
    g_print("g_main_loop_new/n");
    loop = g_main_loop_new(NULL, FALSE);
    //增加一个定时器，100毫秒运行一次callback
    g_timeout_add(100,callback,NULL);
    g_print("g_main_loop_run/n");
    g_main_loop_run(loop);
    g_print("g_main_loop_unref/n");
    g_main_loop_unref(loop);
    return 0;
}</code></pre>编译运行: 
<br> gcc -g `pkg-config --cflags --libs glib-2.0 gthread-2.0` mainloop1.c -o mainloop1 
<br> ./mainloop1 
<br> Yeah！一秒钟后，程序正常退出了！定时器好简单！ 
<br> 今天到此为止。最后思考一个问题，glib的main loop主要提供给gtk使用，是gtk界面事件循环的基础，这是无可非议的。但是，在别的地方，比如我们普通的console、service程序中，有必要用main loop么？main loop还能够应用在哪些场合？ 
<p></p> 
<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"> <br> </p> 
<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"> -----------------------</p> 
<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"> 除了交互性界面程序，还有哪些地方适合使用glib的event loop呢？我认为答案应该是，所有需要异步操作的地方都可以用event loop。像文件、管道、设备、socket、timer、idle和其他自定义的事件都可以产生event.<br> 要让GMainLoop能够处理这些类型的event，首先就必须把它们加到GMainLoop去。<br> 首先我们需要了解event loop的这三个基本结构：GMainLoop, GMainContext和GSource。<br> 它们之间的关系是这样的：<br> GMainLoop -&gt; GMainContext -&gt; {GSource1, GSource2, GSource3......}<br> 每个GmainLoop都包含一个GMainContext成员，而这个GMainContext成员可以装各种各样的GSource，GSource则是具体的各种Event处理逻辑了。在这里，可以把GMainContext理解为GSource的容器。（不过它的用处不只是装GSource）<br> 创建GMainLoop使用函数g_main_loop_new, 它的第一个参数就是需要关联的GMainContext，如果这个值为空，程序会分配一个默认的Context给GMainLoop。<br> 把GSource加到GMainContext呢，则使用函数g_source_attach。</p> 
<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"> 接下来看这个例子，它的作用是从stdin读取字符串，然后反转字符串并输出到屏幕。</p> 
<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"> //mainloop2.c</p> 
<pre><code class="language-cpp">#include &lt;glib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;
GMainLoop* loop;
//当stdin有数据可读时被GSource调用的回调函数
gboolean callback(GIOChannel *channel)
{
    gchar* str;
    gsize len;
    //从stdin读取一行字符串
    g_io_channel_read_line(channel, &amp;str, &amp;len, NULL, NULL);
    //去掉回车键()
    while(len &gt; 0 &amp;&amp; (str[len-1] == '/r' || str[len-1] == '/n'))
        str[--len]='/0';
    //反转字符串
    for(;len;len--)
        g_print("%c",str[len-1]);
    g_print("/n");
    //判断结束符
    if(strcasecmp(str, "q") == 0){
        g_main_loop_quit(loop);
    }
    g_free(str);
}
void add_source(GMainContext *context)
{
    GIOChannel* channel;
    GSource* source;
    //这里我们监视stdin是否可读， stdin的fd默认等于1
    channel = g_io_channel_unix_new(1);
    //g_io_create_watch创建一个默认的io监视作用的GSource，下次再研究自定义GSource。参数G_IO_IN表示监视stdin的读取状态。
    source = g_io_create_watch(channel, G_IO_IN);
    g_io_channel_unref(channel);
    //设置stdin可读的时候调用的回调函数
    g_source_set_callback(source, (GSourceFunc)callback, channel, NULL);
    //把GSource附加到GMainContext
    g_source_attach(source, context);
    g_source_unref(source);
}
int main(int argc, char* argv[])
{
    GMainContext *context;
    if(g_thread_supported() == 0)
        g_thread_init(NULL);
    //新建一个GMainContext
    context = g_main_context_new();
    //然后把GSource附到这个Context上
    add_source(context);
    //把Context赋给GMainLoop
    loop = g_main_loop_new(context, FALSE);
    g_print("input string('q' to quit)/n");
    g_main_loop_run(loop);
    g_main_loop_unref(loop);
    //Context用完计数器减1
    g_main_context_unref(context);
    return 0;
}</code></pre> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f80540087c63e44ad50ccd04e83ef03/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">setupfactory  操作 注册表例子</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8178fb9bded613ef9467416e024a66e5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CF卡技术详解——笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>