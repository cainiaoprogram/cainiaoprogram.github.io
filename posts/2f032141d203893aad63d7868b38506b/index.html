<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>fuzz测试libmodbus | AFL篇 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="fuzz测试libmodbus | AFL篇" />
<meta property="og:description" content="目录 下载编译libmodbus安装Preeny库为什么需要Preeny安装Preeny的前置条件编译安装 创建测试程序与样例编译测试程序生成测试用例 开始测试关于测试用例测试过程 测试结果过程图表覆盖率分析编译副本启动afl-cov实时分析遇到错误结束测试 下载编译libmodbus 首先在github上下载libmodbus库的源码
git clone https://github.com/stephane/libmodbus/ 下载好之后进入到文件夹中，在编译过程中选择使用afl-gcc而不是默认的gcc
cd libmodbus/ ./autogen.sh CC=afl-gcc CXX=afl-g&#43;&#43; ./configure --enable-static make -j8 这里在我第一次运行./autogen.sh时，报错提示autoreconf not found
查了一下README里面提示说需要autoconf和libtool，新装的虚拟机上好像没安装，装上之后问题就解决了，正常情况下运行autogen.sh后会有如下提示，最后会告诉你可以运行./configure了
另外注意在./configure之前一定要更改环境变量的CC和CXX为afl的编译器，以便对libmodbus进行插桩。
如果过程顺利，最终会看到如下图所示的界面，很多afl插桩提示
安装Preeny库 为什么需要Preeny Modbus协议依托socket实现进程间的通信，而AFL本身并未提供对socket通信的支持。使用AFL对其进行fuzzing时，需要将其输入输出重定向stdio中。纵然可以修改部分代码使其socket通信转移到stdio，但这一过程可能会对fuzz的结果造成影响，同时工作量可能也较为繁杂。若是直接修改系统的socket.h，可能会对其他的程序造成难以估量的影响。
而Preeny提供了一系列有趣的模块，其中就包括了一个可以将socket通信重定向至console的desock模块。这个模块，原本的socket函数实现
安装Preeny的前置条件 在Preeny的README中，明确提示了preeny需要使用libini_config来实现相关功能，在安装preeny之前需要先装好，否则在make时会报错。
此外，在编译过程中还需要用到seccomp/h头文件，需要安装libseccomp
sudo apt-get install libseccomp-dev -y 编译安装 在满足了上述前置条件后，直接到preeny目录下make即可自动完成编译，编译过程中可能会有些warning，不影响正常功能。
安装成功后，可以在preeny目录下的src/中找到desock.so，可以通过一个简单的测试小程序确认desock模块是否正确工作
#include &lt;sys/socket.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; int main() { int sock; char send_buf[] = &#34;hello, world! \n&#34;; char recv_buf[100] = {&#39;\0&#39;}; sock = socket(AF_INET, SOCK_STREAM, 0); send(sock, send_buf, strlen(send_buf), 0); recv(sock, recv_buf, 100, 0); printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2f032141d203893aad63d7868b38506b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-12T13:51:43+08:00" />
<meta property="article:modified_time" content="2021-07-12T13:51:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">fuzz测试libmodbus | AFL篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#libmodbus_3" rel="nofollow">下载编译libmodbus</a></li><li><a href="#Preeny_26" rel="nofollow">安装Preeny库</a></li><li><ul><li><a href="#Preeny_27" rel="nofollow">为什么需要Preeny</a></li><li><a href="#Preeny_32" rel="nofollow">安装Preeny的前置条件</a></li><li><a href="#_41" rel="nofollow">编译安装</a></li></ul> 
  </li><li><a href="#_67" rel="nofollow">创建测试程序与样例</a></li><li><ul><li><a href="#_68" rel="nofollow">编译测试程序</a></li><li><a href="#_78" rel="nofollow">生成测试用例</a></li></ul> 
  </li><li><a href="#_83" rel="nofollow">开始测试</a></li><li><ul><li><a href="#_89" rel="nofollow">关于测试用例</a></li><li><a href="#_94" rel="nofollow">测试过程</a></li></ul> 
  </li><li><a href="#_98" rel="nofollow">测试结果</a></li><li><ul><li><a href="#_99" rel="nofollow">过程图表</a></li><li><a href="#_111" rel="nofollow">覆盖率分析</a></li><li><ul><li><a href="#_119" rel="nofollow">编译副本</a></li><li><a href="#aflcov_126" rel="nofollow">启动afl-cov</a></li><li><a href="#_134" rel="nofollow">实时分析</a></li><li><a href="#_138" rel="nofollow">遇到错误</a></li><li><a href="#_148" rel="nofollow">结束测试</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="libmodbus_3"></a>下载编译libmodbus</h2> 
<p>首先在github上下载libmodbus库的源码</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> clone https://github.com/stephane/libmodbus/
</code></pre> 
<p>下载好之后进入到文件夹中，在编译过程中选择使用afl-gcc而不是默认的gcc</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> libmodbus/
./autogen.sh
<span class="token assign-left variable">CC</span><span class="token operator">=</span>afl-gcc <span class="token assign-left variable">CXX</span><span class="token operator">=</span>afl-g++ 
./configure --enable-static
<span class="token function">make</span> -j8
</code></pre> 
<p>这里在我第一次运行<code>./autogen.sh</code>时，报错提示autoreconf not found<br> <img src="https://images2.imgbox.com/ed/1a/5bwxpbPj_o.png" alt="在这里插入图片描述"><br> 查了一下README里面提示说需要autoconf和libtool，新装的虚拟机上好像没安装，装上之后问题就解决了，正常情况下运行<code>autogen.sh</code>后会有如下提示，最后会告诉你可以运行./configure了<br> <img src="https://images2.imgbox.com/0e/b2/OlVt78rt_o.png" alt="在这里插入图片描述"><br> 另外注意在<code>./configure</code>之前一定要更改环境变量的CC和CXX为afl的编译器，以便对libmodbus进行插桩。<br> 如果过程顺利，最终会看到如下图所示的界面，很多afl插桩提示<br> <img src="https://images2.imgbox.com/af/01/PH9rLQb0_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Preeny_26"></a>安装Preeny库</h2> 
<h3><a id="Preeny_27"></a>为什么需要Preeny</h3> 
<p>Modbus协议依托socket实现进程间的通信，而AFL本身并未提供对socket通信的支持。使用AFL对其进行fuzzing时，需要将其输入输出重定向stdio中。纵然可以修改部分代码使其socket通信转移到stdio，但这一过程可能会对fuzz的结果造成影响，同时工作量可能也较为繁杂。若是直接修改系统的<code>socket.h</code>，可能会对其他的程序造成难以估量的影响。<br> 而Preeny提供了一系列有趣的模块，其中就包括了一个可以将socket通信重定向至console的<code>desock</code>模块。这个模块，原本的socket函数实现<br> <img src="https://images2.imgbox.com/ac/49/ZYOXIvIa_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Preeny_32"></a>安装Preeny的前置条件</h3> 
<p>在Preeny的README中，明确提示了preeny需要使用<code>libini_config</code>来实现相关功能，在安装preeny之前需要先装好，否则在<code>make</code>时会报错。<br> <img src="https://images2.imgbox.com/c3/26/5xl5ZXGK_o.png" alt="在这里插入图片描述"><br> 此外，在编译过程中还需要用到seccomp/h头文件，需要安装<code>libseccomp</code></p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libseccomp-dev -y
</code></pre> 
<h3><a id="_41"></a>编译安装</h3> 
<p>在满足了上述前置条件后，直接到preeny目录下<code>make</code>即可自动完成编译，编译过程中可能会有些warning，不影响正常功能。<br> 安装成功后，可以在preeny目录下的<code>src/</code>中找到<code>desock.so</code>，可以通过一个简单的测试小程序确认desock模块是否正确工作</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> sock<span class="token punctuation">;</span>
        <span class="token keyword">char</span> send_buf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello, world! \n"</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span> recv_buf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">send</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> send_buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">recv</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> recv_buf<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The following msg is recvd:\n %s \n"</span><span class="token punctuation">,</span> recv_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/38/9d/O8e3rVaS_o.png" alt="在这里插入图片描述"><br> 可以看到，send函数成功将消息发往了stdout，而recv函数也成功从stdin中接收了消息，说明本部分工作已经完成</p> 
<h2><a id="_67"></a>创建测试程序与样例</h2> 
<h3><a id="_68"></a>编译测试程序</h3> 
<p>在libmodbus目录下有一个tests文件夹，包含几个官方提供的测试样例，可以通过afl-gcc对其进行插桩编译，作为被测程序。此处值得注意的是，在编译时要注意<strong>手动指定modbus库和头文件</strong><br> 如：</p> 
<pre><code class="prism language-bash">afl-gcc bandwidth-server-many-up.c -o server -I libmodbus/src/ libmodbus/src/.libs/libmodbus.a

</code></pre> 
<p>-I后面两个参数分别指定了<code>modbus.h</code>和<code>libmodbus.a</code>的路径，两者<strong>缺一不可</strong></p> 
<h3><a id="_78"></a>生成测试用例</h3> 
<p>在AFL的文档中，建议为fuzzing测试提供一些“<mark>特别</mark>”（<em>interesting</em>）的测试用例作为种子。显然，如果直接用一串随机字母数字组合作为modbus测试程序的输入并不够interesting。好在libmodbus提供的测试用例中，random-test一对就可以为我们提供不错的测试数据，这是tests/README.md中对于他们的描述<br> <img src="https://images2.imgbox.com/71/66/VZov6hG7_o.png" alt="在这里插入图片描述"><br> 在本地运行这一对程序，然后通过tcp将数据包保存至本地，然后再随机挑选几个数据包出来作为输入样例。</p> 
<h2><a id="_83"></a>开始测试</h2> 
<p>使用afl-fuzz命令即可开始fuzzing测试，需要通过<code>-i</code>参数给出存放测试用例的目录 <code>-o</code>参数给出用于输出测试结果的目录，如果目录不为空会报错 最后直接给出被测程序的路径即可。<br> 注意为了将socket输入输出重定向到stdio，我们需要在运行的同时指定<code>LD_PRELOAD=desock.so</code>。完成操作即如下所示：</p> 
<pre><code class="prism language-bash"><span class="token assign-left variable">LD_PRELOAD</span><span class="token operator">=</span>./desock.so afl-fuzz -i inputs/ -o outputs/ ./server
</code></pre> 
<h3><a id="_89"></a>关于测试用例</h3> 
<p>测试用例一次不要给太多，按照afl官方所给的建议（<code>/usr/local/doc/afl/perf-tips.txt</code>），第一条就指出要让测试用例尽量小。第一次没注意到这个问题，把抓到的近一千个包一口气全放到了测试用例目录中，结果如下图所示：<br> <img src="https://images2.imgbox.com/64/3f/T3dBmbH7_o.png" alt="在这里插入图片描述"><br> 除了第一个case之外，后面的都提示“may be useless"<br> <img src="https://images2.imgbox.com/14/34/ltuFRFgp_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_94"></a>测试过程</h3> 
<p>正确配置各项参数后，AFL的运行界面如下：<br> <img src="https://images2.imgbox.com/b7/0a/ZWYHTVAH_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_98"></a>测试结果</h2> 
<h3><a id="_99"></a>过程图表</h3> 
<p>使用AFL自带的afl-plot可以将测试过程中的一些数据变化绘制成基于html的图表，使用方法为“</p> 
<pre><code class="prism language-bash">afl-plot /path/to/fuzz/outputs /path/to/plot
</code></pre> 
<p>正确执行后会有简单的提示，然后就可以在指定plot输出的文件夹中找到index.html<br> <img src="https://images2.imgbox.com/8e/3d/n2liB1Zz_o.png" alt="在这里插入图片描述"><br> 图表结果如下：<br> <img src="https://images2.imgbox.com/52/33/iHlfDBWM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/29/70/wTc6G7Ic_o.png" alt="在这里插入图片描述"></p> 
<p>从中可以看到测试过程中的的执行路径、运行速度等数据。但是对于<strong>覆盖率</strong>，在这个分析图表中并没有体现。</p> 
<h3><a id="_111"></a>覆盖率分析</h3> 
<p>afl-cov是一款针对afl-fuzzer的覆盖率分析工具，可以非常方便的从github上下载</p> 
<blockquote> 
 <p>https://github.com/mrash/afl-cov</p> 
</blockquote> 
<p>下载得到的afl-cov本身不需要编译安装，直接就可以使用，但是在使用前需要确保本地已经安装了gcov和lcov<br> <img src="https://images2.imgbox.com/be/92/mBgjfMvb_o.png" alt="在这里插入图片描述"><br> afl-cov可以解析已经执行完毕的afl-fuzz输出结果，也可以与afl-fuzz同时运行，实时监控每次测试的覆盖率，这里我采用的是实时的方法。</p> 
<h4><a id="_119"></a>编译副本</h4> 
<p>根据afl-cov的README， 使用afl-cov前需要重新对目标程序编译一个副本，并且在编译过程中加入gcov。另外注意重新编译的和被测程序是同样的源码，由于我这里是对modbus程序进行测试的，所以仍然需要像之前afl-gcc插桩编译时一样的手动指定modbus头文件和库文件的位置。<br> 综上，编译命令为：</p> 
<pre><code class="prism language-bash">gcc server.c -o server_copy -I libmodbus/src/ libmodbus/src/.libs/libmodbus.a -fprofile-arcs -ftest-coverage 
</code></pre> 
<p>编译成功后，除了会出现server_copy.o之外，还会有一个同名的.gcno文件。</p> 
<h4><a id="aflcov_126"></a>启动afl-cov</h4> 
<p>接下来，根据文档启动afl-cov，执行如下命令</p> 
<pre><code class="prism language-bash">./afl-cov -d <span class="token punctuation">..</span>/fuzz_713 --live -c ./ -e <span class="token string">"cat AFL_FILE | ./server_copy"</span>
</code></pre> 
<p>其中，-d参数指明了afl-fuzz输出结果的目录，–live表示afl-cov与fuzzer同时运行， -c参数是存放了目标文件副本的目录，即包含了.gcno文件的目录， -e表示执行后面给出的命令行代码。在运行过程中，afl-cov会自动将AFL_FILE替换为fuzzer输出结果的文件名（也就是id:0000开头的文件）。</p> 
<p>启动afl-cov后，会提示<code>[-] Sleep for 60 seconds for AFL fuzzing directory to be created...</code> 这时就可以运行afl-fuzz并保持输出目录与刚刚指定的目录一致即可。</p> 
<h4><a id="_134"></a>实时分析</h4> 
<p>在afl-fuzz开始运行并生成测试结果后，afl-cov将自动从目录中读取，并在命令行中展示实时的代码覆盖率<br> <img src="https://images2.imgbox.com/ad/87/eimjIg5F_o.png" alt="在这里插入图片描述"><br> 可能是由于我的被测程序运行较慢的原因，cov偶尔会提示没有新的测试用例，等待60秒后继续。</p> 
<h4><a id="_138"></a>遇到错误</h4> 
<p>在测试<em>某些程序</em>时，可能会发现afl-cov无法正确启动覆盖率分析，而是疯狂刷出错误信息，像这样:<br> <img src="https://images2.imgbox.com/c5/93/zdpqkv7L_o.png" alt="在这里插入图片描述"><br> 在afl-cov的github页面中，有一个issue指出了这个问题</p> 
<p><img src="https://images2.imgbox.com/cd/94/SwsdHzL6_o.png" alt="在这里插入图片描述"><br> 如何对gcc降级，参考<a href="https://blog.csdn.net/u013862444/article/details/98629581">这篇文章</a>。降级后重新编译，然后运行afl-cov，发现错误仍然存在……<strong>目前这个错误仍然没有被解决</strong>，在StackOverflow上面也有人遇到类似的问题，一样是未解决状态……</p> 
<h4><a id="_148"></a>结束测试</h4> 
<p>在afl-fuzz测试终止后，afl-cov会随之自动停止，并给出一系列分析结果<br> <img src="https://images2.imgbox.com/9b/27/MEkAlXAw_o.png" alt="在这里插入图片描述"><br> 分析结果保存在afl-fuzz测试结果目录下的<code>cov/</code>文件夹中，其中<code>zero-cov</code>中保存了在运行过程中从未被执行到的代码或是函数，<code>pos-cov</code>中保存了在运行过程中被执行过至少一次的内容。同时，在<code>cov/</code>目录下的web文件夹中有一个<code>index.html</code>文件，即根据分析结果给出的可视化页面。<br> <img src="https://images2.imgbox.com/7b/29/0rsfnJ7M_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4238ee180b842ab461f0c7dfbf703a0b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">联想计算机电源风扇怎样清理,电脑风扇怎么拆开清洗_电脑风扇的三根线的作用...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/959511899450b6b32186abc55dd64b84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">移植open BMC到ARM处理器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>