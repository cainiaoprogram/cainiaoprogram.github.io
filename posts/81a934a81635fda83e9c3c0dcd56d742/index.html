<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深度学习核心技术与实践之深度学习基础篇 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深度学习核心技术与实践之深度学习基础篇" />
<meta property="og:description" content="非书中全部内容，只是写了些自认为有收获的部分
神经网络 生物神经元的特点 （1）人体各种神经元本身的构成很相似
（2）早期的大脑损伤，其功能可能是以其他部位的神经元来代替实现的
（3）神经元具有稀疏激活性，尽管大脑具有高达五百万亿个神经元，但真正同时被激活的仅有1%~4%
神经元模型 （1）ReLu是一种特殊的Maxout函数
（2）理论上可以多种激活函数混用，但在实践中较少这样应用
感知机困境 （1）对于非线性问题，感知机只有通过人工提取特定的特征——在这些特征中将非线性的因素包含进来——使得特征仅用线性关系就可判别，才能达到目标。但这意味着非线性的引入需要靠人工完成，感知机完全帮不上忙
目标函数的选取 交叉熵的损失函数的偏导数结果简介、漂亮
初始化模型 2006年Hinton发表的Science论文提出了一种深度模型的可行训练方法，其基本思想是利用生成模型受限玻尔兹曼机一层一层地进行初始化训练，然后再利用真实数据进行参数微调
受限玻尔兹曼机(RBM) （1）受限玻尔兹曼机由可视层和隐层构成
（2）RBM属于生成模型，用于建模观察数据和输出标签之间的联合概率分布
能量模型(EBM) （1）系统越杂乱无序或概率分布越趋近于均匀分布，系统对应的能量越大
（2）当E(x) = -wx，EBM就是Softmax
带隐藏单元的能量模型 （1）在很多情况下，并不能直接观测到所有的x值，这时候往往需要引入隐藏变量
（2）
受限玻尔兹曼机基本原理 （1）玻尔兹曼机是一种特殊的对数线性马尔可夫随机场，因为其能量函数是参数的线性形式.。其隐藏单元既要依赖于观察单元，也要依赖于其他隐藏单元；观察单元可能既依赖于隐藏单元，也依赖于同层的其他观察单元
（2）受限玻尔兹曼机：同层之间不存在相互依赖关系，只有观察层和隐藏层之间存在关系
（3）能量函数：
（4）从概率图的角度来看，给定所有观察变量的值时隐藏变量之间相互独立；对称的，给定所有隐藏变量的值时观察变量之间相互独立
二值RBM （1）规定所有的观察变量v和隐藏变量h的取值范围都为(0,1)
对比散度 （1）由于隐层未知且v,h的组合空间很大，联合概率分布p(v,h)是很难计算的，因而&lt;vh&gt;model往往采用采样的方法
（2）一般MCMC方法需要较多的采样步数，而针对RBM训练的对比散度(CD)算法只需要较少的步数
Q：why？
A：RBM通过最大化输入数据的对数似然来进行训练，这需要计算数据的概率分布，而在高维空间中直接计算这个概率分布是非常困难的。
传统的MCMC方法在高维空间中采样时会遇到困难，因为随着维度的增加，采样点的数量呈指数增长，这使得采样过程变得非常低效。
而对比散度算法是一种高效的替代方法，它不需要进行大量的采样步骤，原因如下：
（1）高效的能量梯度估计：CD算法通过在RBM中引入一个相对简单的对比能量函数来估计能量梯度的期望值。这个能量函数是基于模型在训练数据上的表现，而不是基于模型在未标记数据上的整体概率分布。因此，CD算法可以直接利用训练数据进行高效的能量梯度估计，而不需要进行耗时的MCMC采样。
（2）快速的迭代更新：由于CD算法避免了复杂的MCMC采样过程，它可以在每个训练迭代中快速地计算和更新模型参数。这使得训练过程更加高效，减少了所需的迭代步数。
（3）适应性采样：CD算法中包含了一种适应性采样技术，这种技术可以在训练过程中动态地调整采样步骤，以适应模型的学习速度。这种适应性采样确保了在训练的不同阶段都能够进行有效的采样，而不需要固定的较大采样步数。
（3）k步对比散度以训练样本为起点，执行k步吉布斯采样
自动编码器 （1）自动编码器一般由编码器网络和解码器网络组成
降噪自动编码器 （1）编码器的输入是包含噪声的，而用作解码目标的输入是去除了噪声的
（2）人为添加噪声的方法包括：添加高斯噪声、添加二维码噪声，类似于Dropout，将部分输入神经元直接置为0
栈式自动编码器 （1）叠加的自动编码器，使得第n个隐层最大程度保留第n-1个隐层的信息
（2）最后一个隐层会得到足够有效的特征
（3）可以用梯度下降之类的优化算法微调参数
深度信念网络 （1）又被称为贝叶斯网络，是一种有向无环图
（2）可以在任意叶子节点生成无偏的样本集合
（3）通过不断积累RBM形成。每当一个RBM被训练完成时，其隐藏单元又可以作为后一层RBM的输入
（4）DBN的基本思想是允许每一次RBM模型接收数据的不同表示
卷积神经网络 卷积算子 （1）在统计学中，加权的滑动平均是一种卷积
（2）在声学中，回声可以用原声与一个反映各种反射效应的函数相卷积来表示
（3）在电子工程与信号处理中，任意一个线性系统的输出都可以通过将输入信号与系统函数做卷积获得
（4）在物理学中，任何一个线性系统都存在卷积
（5）卷积核在自变量为负的区间取值为0，否则将会使用未来的读数对当前值进行加权，这种情况是超越了现实系统能力的
Q：这里找了很久都没找到为什么会时间穿越
卷积的特征 稀疏连接、参数共享、等价表达
（1）越高层的卷积层“可视野”对应到原始输入图像上的区域越大，也为提取到更高层的语义信息提供了可能" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/81a934a81635fda83e9c3c0dcd56d742/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-31T18:28:18+08:00" />
<meta property="article:modified_time" content="2023-12-31T18:28:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深度学习核心技术与实践之深度学习基础篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>非书中全部内容，只是写了些自认为有收获的部分</p> 
<h2>神经网络</h2> 
<h3>生物神经元的特点</h3> 
<p>（1）人体各种神经元本身的构成很相似</p> 
<p>（2）早期的大脑损伤，其功能可能是以其他部位的神经元来代替实现的</p> 
<p>（3）神经元具有稀疏激活性，尽管大脑具有高达五百万亿个神经元，但真正同时被激活的仅有1%~4%</p> 
<h3>神经元模型</h3> 
<p>（1）ReLu是一种特殊的Maxout函数</p> 
<p>（2）理论上可以多种激活函数混用，但在实践中较少这样应用</p> 
<h3>感知机困境</h3> 
<p>（1）对于非线性问题，感知机只有通过人工提取特定的特征——在这些特征中将非线性的因素包含进来——使得特征仅用线性关系就可判别，才能达到目标。但这意味着非线性的引入需要靠人工完成，感知机完全帮不上忙</p> 
<h3>目标函数的选取</h3> 
<p>交叉熵的损失函数的偏导数结果简介、漂亮</p> 
<h2>初始化模型</h2> 
<p>2006年Hinton发表的Science论文提出了一种深度模型的可行训练方法，其基本思想是利用生成模型受限玻尔兹曼机一层一层地进行初始化训练，然后再利用真实数据进行参数微调</p> 
<h3>受限玻尔兹曼机(RBM)</h3> 
<p>（1）受限玻尔兹曼机由可视层和隐层构成</p> 
<p>（2）RBM属于生成模型，用于建模观察数据和输出标签之间的联合概率分布</p> 
<h4>能量模型(EBM)</h4> 
<p>（1）系统越杂乱无序或概率分布越趋近于均匀分布，系统对应的能量越大</p> 
<p><img alt="" height="269" src="https://images2.imgbox.com/8d/dd/pPDMrusE_o.png" width="1006"></p> 
<p>（2）当E(x) = -wx，EBM就是Softmax</p> 
<h4>带隐藏单元的能量模型</h4> 
<p>（1）在很多情况下，并不能直接观测到所有的x值，这时候往往需要引入隐藏变量</p> 
<p><img alt="" height="531" src="https://images2.imgbox.com/64/18/76hNzTmB_o.png" width="1102"></p> 
<p>（2）<img alt="" height="276" src="https://images2.imgbox.com/bc/bf/EyPUY8b0_o.png" width="1200"></p> 
<h4>受限玻尔兹曼机基本原理</h4> 
<p><img alt="" height="401" src="https://images2.imgbox.com/d8/47/iXCe5NWd_o.png" width="674"></p> 
<p>（1）玻尔兹曼机是一种特殊的对数线性马尔可夫随机场，因为其能量函数是参数的线性形式.。其隐藏单元既要依赖于观察单元，也要依赖于其他隐藏单元；观察单元可能既依赖于隐藏单元，也依赖于同层的其他观察单元</p> 
<p>（2）受限玻尔兹曼机：同层之间不存在相互依赖关系，只有观察层和隐藏层之间存在关系</p> 
<p>（3）能量函数：</p> 
<p><img alt="" height="152" src="https://images2.imgbox.com/ae/4f/MptUOEE5_o.png" width="1200"></p> 
<p>（4）从概率图的角度来看，给定所有观察变量的值时隐藏变量之间相互独立；对称的，给定所有隐藏变量的值时观察变量之间相互独立</p> 
<h4>二值RBM</h4> 
<p>（1）规定所有的观察变量v和隐藏变量h的取值范围都为(0,1)</p> 
<h4>对比散度</h4> 
<p>（1）由于隐层未知且v,h的组合空间很大，联合概率分布p(v,h)是很难计算的，因而&lt;vh&gt;model往往采用采样的方法</p> 
<p>（2）一般MCMC方法需要较多的采样步数，而针对RBM训练的对比散度(CD)算法只需要较少的步数</p> 
<blockquote> 
 <p>Q：why？</p> 
 <p>A：RBM通过最大化输入数据的对数似然来进行训练，这需要计算数据的概率分布，而在高维空间中直接计算这个概率分布是非常困难的。<br> 传统的MCMC方法在高维空间中采样时会遇到困难，因为随着维度的增加，采样点的数量呈指数增长，这使得采样过程变得非常低效。</p> 
 <p>而对比散度算法是一种高效的替代方法，它不需要进行大量的采样步骤，原因如下：<br> （1）高效的能量梯度估计：CD算法通过在RBM中引入一个相对简单的对比能量函数来估计能量梯度的期望值。这个能量函数是基于模型在训练数据上的表现，而不是基于模型在未标记数据上的整体概率分布。因此，CD算法可以直接利用训练数据进行高效的能量梯度估计，而不需要进行耗时的MCMC采样。<br> （2）快速的迭代更新：由于CD算法避免了复杂的MCMC采样过程，它可以在每个训练迭代中快速地计算和更新模型参数。这使得训练过程更加高效，减少了所需的迭代步数。<br> （3）适应性采样：CD算法中包含了一种适应性采样技术，这种技术可以在训练过程中动态地调整采样步骤，以适应模型的学习速度。这种适应性采样确保了在训练的不同阶段都能够进行有效的采样，而不需要固定的较大采样步数。</p> 
</blockquote> 
<p>（3）k步对比散度以训练样本为起点，执行k步吉布斯采样</p> 
<p><img alt="" height="715" src="https://images2.imgbox.com/99/c4/FbFFBvHM_o.png" width="1200"></p> 
<h3>自动编码器</h3> 
<p> （1）自动编码器一般由编码器网络和解码器网络组成</p> 
<h4>降噪自动编码器</h4> 
<p>（1）编码器的输入是包含噪声的，而用作解码目标的输入是去除了噪声的</p> 
<p>（2）人为添加噪声的方法包括：添加高斯噪声、添加二维码噪声，类似于Dropout，将部分输入神经元直接置为0</p> 
<h4>栈式自动编码器</h4> 
<p>（1）叠加的自动编码器，使得第n个隐层最大程度保留第n-1个隐层的信息</p> 
<p>（2）最后一个隐层会得到足够有效的特征</p> 
<p>（3）可以用梯度下降之类的优化算法微调参数</p> 
<h3>深度信念网络</h3> 
<p>（1）又被称为贝叶斯网络，是一种有向无环图</p> 
<p>（2）可以在任意叶子节点生成无偏的样本集合</p> 
<p>（3）通过不断积累RBM形成。每当一个RBM被训练完成时，其隐藏单元又可以作为后一层RBM的输入</p> 
<p>（4）DBN的基本思想是允许每一次RBM模型接收数据的不同表示</p> 
<h2>卷积神经网络</h2> 
<h3>卷积算子</h3> 
<p>（1）在统计学中，加权的滑动平均是一种卷积</p> 
<p>（2）在声学中，回声可以用原声与一个反映各种反射效应的函数相卷积来表示</p> 
<p>（3）在电子工程与信号处理中，任意一个线性系统的输出都可以通过将输入信号与系统函数做卷积获得</p> 
<p>（4）在物理学中，任何一个线性系统都存在卷积</p> 
<p>（5）卷积核在自变量为负的区间取值为0，否则将会使用未来的读数对当前值进行加权，这种情况是超越了现实系统能力的</p> 
<blockquote> 
 <p>Q：这里找了很久都没找到为什么会时间穿越</p> 
</blockquote> 
<h3>卷积的特征</h3> 
<p>稀疏连接、参数共享、等价表达</p> 
<p>（1）越高层的卷积层“可视野”对应到原始输入图像上的区域越大，也为提取到更高层的语义信息提供了可能</p> 
<p>（2）虽然卷积网络单层只能看到局部信息，但是深层的卷积网络其感受野还是可以涉及全图的</p> 
<p>（3）一个卷积核内的参数会被应用于输入的所有位置</p> 
<p>（4）参数共享的特殊形式使得卷积层具有变换等价性——如果输入发生变化，输出会随之发生同样的变化。例如：先对图像I施以变换，再进行卷积f，结果等同于对图像I的卷积施以变换</p> 
<p>（5）卷积网络的另一个优势在于以一种更符合逻辑的方式，利用并保持输入图像数据的三维结构：宽度、高度、深度</p> 
<h3>卷积层</h3> 
<p>（1）每个卷积核在空间中都是小尺寸的(沿宽和高)，但会穿过输入集的整个深度</p> 
<p>（2）深度对应于我们希望使用的卷积核的数量</p> 
<p>（3）为了使用更深的卷积网络，但不希望特征图在卷积过程中尺寸下降得太快，可以做padding</p> 
<h3>池化层</h3> 
<p>（1）最大池化的超参数一般有两种选择：F=3，S=2或F=2，S=2。一般更大的池化窗口会给特征图信息带来严重的破坏</p> 
<p>（2）平均池化被最大池化替代</p> 
<p>（3）池化层的正向传递通常会保留最大激活单元的下标，作为反向传播时梯度的传递路径</p> 
<h2>循环神经网络</h2> 
<h3>简介</h3> 
<p>（1）大脑可以处理连续的输入是因为脑神经元之间的连接允许环的存在</p> 
<p>（2）h0通常设置为全0向量，或把h0作为一种参数，在训练过程中学习</p> 
<h3>RNN、LSTM、GRU</h3> 
<p>（1）RNN隐藏层共享同一套参数</p> 
<p>（2）反向传播时δt+1=0，这是因为在最后一个时刻没有从下一时刻传过来的梯度</p> 
<p>（3）梯度很多出现nan，说明很可能出现了梯度爆炸</p> 
<p>（4）LSTM的输入门、遗忘门、输出门有形式一样的公式、共同的输入，只是参数不一样</p> 
<p>（5）LSTM就可以自主决定当前时刻的输出是依赖于前面的较早时刻，还是前面的较晚时刻，抑或是当前时刻的输入</p> 
<p>（6）GRU没有输出门，输出不用经过激活函数，参数更少</p> 
<p>（7）(1-z)h'中的1-z代替了LSTM中的输入门，zht-1中的z代替了LSTM的遗忘门</p> 
<p>（8）如果训练数据较少，推荐使用GRU</p> 
<h3>RNN语言模型</h3> 
<p>（1）n-gram，假设句子中的每个词只与其前n-1个词有关</p> 
<p>（2）Softmax必须要加和所有词汇表的得分来计算归一化系数，会非常占内存，并且计算非常慢。我们通常采用NCE替代Softmax</p> 
<h2>深度学习优化算法</h2> 
<h3>SGD</h3> 
<p>（1）有时可以用于在线学习系统，可使系统快速学到新的变化</p> 
<blockquote> 
 <p>在线学习系统是一种机器学习系统，能够在接收到新数据时动态地进行学习和更新，而不需要重新使用之前的所有数据进行训练。这种系统能够实时地从连续的数据流中学习，并随着时间的推移逐步改进自身的性能。</p> 
</blockquote> 
<p>（2）BGD相比于SGD，不那么容易震荡，但是因为每次都需要更新整个数据集，所以BGD非常慢且无法放在内存中计算</p> 
<h3>NAG</h3> 
<p>（1）先使用动量mt计算参数θ下一个位置的近似值θ+ηmt，然后在近似位置计算梯度</p> 
<p>（2）NAG算法会计算本轮迭代时动量到达位置的梯度，可以说它计算的是未来的梯度</p> 
<blockquote> 
 <p>NAG算法会根据此次梯度（i-1）和上一次梯度（i-2）的差值对Momentum算法得到的梯度进行修正，如果两次梯度的差值为正，证明梯度再增加，我们有理由相信下一个梯度会继续变大；相反两次梯度的差值为负，我们有理由相信下一个梯度会继续变小。</p> 
 <p>如果说Momentum算法是用一阶指数平滑，那么NGA算法则是使用了二阶指数平滑；Momentum算法类似用已得到的前一个梯度数据对当前梯度进行修正（类似一阶马尔科夫假设），NGA算法类似用已得到的前两个梯度对当前梯度进行修正（类似二阶马尔科夫假设），无疑后者得到的梯度更加准确，因此提高了算法的优化速度。</p> 
 <p>文章链接：<a href="https://zhuanlan.zhihu.com/p/351134007" rel="nofollow" title="深度解析Momentum、NAG、Adagrad、Adadelta、RMSprop、Adam等优化器 - 知乎 (zhihu.com)">深度解析Momentum、NAG、Adagrad、Adadelta、RMSprop、Adam等优化器 - 知乎 (zhihu.com)</a></p> 
</blockquote> 
<h3>Adagrad</h3> 
<p>（1）对更新频繁且更新量大的参数，适当减小它们的步长；对不频繁的增大步长</p> 
<p>（2）Gt是所有轮迭代的梯度平方和</p> 
<p>（3）如果模型参数保持稳定，而分母上的Gt一直在累积，会导致梯度总体上会不断变小</p> 
<h3>RMSProp</h3> 
<p>（1）让梯度累积量G不要一直变大，而是按照一定的比率衰减</p> 
<p>（2）此时的G更像是梯度的平均值甚至期望值</p> 
<h3>Adadelta</h3> 
<p>（1）Adagrad算法和梯度下降法相比多出来一个项目，这样更新量的“单位”就和之前不同了。为了让“单位”匹配，Adadelta选择在分子上再增加一个项目</p> 
<blockquote> 
 <p>在传统的梯度下降算法中，参数更新量通常是由当前的梯度决定的</p> 
 <p>由于Adagrad考虑了历史梯度，它的“单位”不再是单纯的梯度，而是梯度与累积历史梯度的平方根的比值</p> 
 <p>Adadelta算法在分子上增加了一个项目，即当前梯度的平方，这是为了在更新规则中同时考虑当前梯度和之前梯度的累积。这样的设计使得Adadelta可以看作是Adagrad的一种“截断”版本。</p> 
</blockquote> 
<h3>Adam</h3> 
<p>（1）基于动量的算法和基于自适应学习率的算法</p> 
<p>（2）记录了梯度的一阶矩（梯度的期望值）和二阶矩（梯度平方的期望值）</p> 
<blockquote> 
 <p>具体来说，梯度的一阶矩和二阶矩的作用包括：<br> 1.偏差校正：通过计算梯度的一阶矩和二阶矩，可以对梯度进行偏差校正。这种校正有助于减少梯度估计的方差，从而提高学习率的稳定性。<br> 2.方差估计：二阶矩提供了方差估计，这有助于识别和调整那些具有较大波动性的参数。通过这种方式，Adam可以更好地适应不同参数的学习速率。<br> 3.自适应学习率：Adam结合了RMSprop（Root Mean Square Propagation）和Momentum的方法，它使用梯度的一阶矩来近似RMSprop的累积梯度，并使用二阶矩来近似Momentum的累积梯度平方。这样，Adam能够在不同的情况下为不同的参数提供合适的学习率。<br> 4.减少计算量：与直接计算每个参数的梯度相比，使用一阶矩和二阶矩可以减少计算量，因为它们是在累积的历史梯度上操作的。<br> 5.改善训练动态：通过跟踪梯度的一阶矩和二阶矩，Adam可以更好地理解参数更新的历史，这有助于改善训练过程，尤其是在面对复杂的目标函数和非线性优化问题时。</p> 
</blockquote> 
<p>（3）为了确保两个梯度积累量能够良好地估计梯度的一阶矩和二阶矩，两个积累量还需要乘一个偏置纠正系数</p> 
<blockquote> 
 <p>具体来说，偏置纠正系数的设计和作用如下：<br> 1.偏置问题：在原始的Adam算法中，由于指数加权平均的初始化通常为0，这可能导致在早期迭代中估计的梯度矩受到偏差的影响，因为它们会被初始值拉向0。这个问题在动量和RMSprop算法中也很常见。<br> 2.偏置纠正系数：为了解决这个问题，Adam引入了偏置纠正系数，它是对每个梯度积累量进行缩放，以消除这种偏差。偏置纠正系数通常是累积梯度平方的平方根的倒数<br> 3.设计原因：这种设计的原因是基于数学上的推导，它确保了在算法的整个运行过程中，累积的梯度矩能够无偏差地估计实际梯度的一阶矩和二阶矩。通过这种方式，Adam能够更准确地捕捉到梯度的动态变化，从而更有效地调整学习率。<br> 4.数值稳定性：偏置纠正系数还提高了数值稳定性，因为它避免了大梯度值对累积量的影响，从而减少了在更新过程中可能出现的数值问题。<br> 5.算法改进：随着对Adam算法的进一步研究和改进，偏置纠正系数的引入和设计可能会有所变化，以适应不同的优化场景和提高算法的效率。</p> 
</blockquote> 
<h3>AdaMax</h3> 
<p>（1）将Adam的二阶矩修改为无穷矩</p> 
<blockquote> 
 <p>这种修改的原因和动机包括：<br> 1.数值稳定性：在Adam算法中，二阶矩的估计是通过计算梯度平方的指数移动平均来实现的。在某些情况下，特别是当梯度非常小时，这可能导致数值不稳定，因为极小的梯度平方可能会对整体的二阶矩估计产生较大影响。无穷范数对这种数值不稳定性更为鲁棒，因为它不会对小于1的数进行平方，从而减少了梯度为零或接近零时对二阶矩估计的影响。<br> 2.更好的泛化能力：在某些任务中，例如目标检测或机器翻译，Adam算法可能无法收敛到最优解，或者其性能可能不如传统的带有动量的SGD。这种情况下，Adamax通过使用无穷范数来估计二阶矩，可以提供更好的泛化能力和收敛性。<br> 3.减少计算量：无穷范数通常比L2范数更容易计算，因为它不需要进行平方运算。这可以减少计算量，尤其是在处理大规模数据集时。</p> 
</blockquote> 
<h3>Nadam</h3> 
<p>（1）修改Adam的一阶矩估计值，将Nesterov算法和Adam算法结合起来</p> 
<blockquote> 
 <p>在传统的Adam算法中，梯度的一阶矩（即梯度的期望值）是通过计算梯度的一阶矩的指数移动平均来估计的。在Nadam中，这个估计值被修改为使用Nesterov预测来计算。这意味着在每个迭代中，首先根据当前的速度（动量）和之前的梯度来预测参数的更新，然后在这个预测的参数更新上计算实际的梯度。</p> 
</blockquote> 
<h3>小结</h3> 
<p>（1）优化算法分为两类，其中一类是以动量为核心的算法；另一类是以自适应为核心的算法</p> 
<p>（2）自适应类算法在不是很复杂的优化场景下效果不是特别突出</p> 
<h2>深度学习训练技巧</h2> 
<h3>数据预处理</h3> 
<p>（1）减均值适合那些各维度分布相同的数据</p> 
<p>（2）由于各维度之间的协方差矩阵是半正定的，因此可以利用矩阵分解的方法将协方差矩阵分解，得到特征向量和对应的特征值，再将特征值从大到小排列，忽略特征值较小的维度，从而达到降维的效果。如果利用特征值进一步对特征空间的数据进行缩放，就是白化操作</p> 
<h3>权重初始化</h3> 
<p>（1）全零初始化没有打破神经元之间的对称性</p> 
<p>（2）随机初始化将权重初始化为0附件的随机值</p> 
<p>（3）方差校准将每个初始化值都除以根号n，其中n是输入的维度</p> 
<p>（4）针对ReLU的方差校准应除以根号(n/2)</p> 
<p>（5）bias占比不大，初始化一般直接采用全0或很小的数字，或者和权重向量同等对待</p> 
<h3>L1/L2参数正则化</h3> 
<p>（1）λ越小，正则化所起的作用越小，模型主要在优化原来的损失函数；λ越大，正则化越重要，参数趋向于0附近</p> 
<p>（2）L1/L2是添加一个参数w取0附近的先验，同心圆的圆心表示数据上的最优点，等高线表示到最优点距离相同的点。先验希望参数保持在零点附近</p> 
<p>（3）L2相当于为参数w增加了协方差的1/λ的零均值高斯分布先验；L1相当于为参数w增加了拉普拉斯先验</p> 
<h3>集成</h3> 
<p>（1）Bagging对数据进行放回重采样</p> 
<p>（2）Boosting先针对原始数据训练一个比随机分类器性能要好一点的模型，然后用该分类器对训练数据进行预测，对预测错误的数据进行加权，从而组成一个新的训练集</p> 
<h3>Dropout</h3> 
<p>（1）Dropconnect不去掉结点，只随机放弃连接边</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0fb231a84142a1b9baf4808edb681c23/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue2与vue3数组的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/851a55ba01a0e1bd9bcb1ca58f17ae1f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">详解Med-PaLM 2，基于PaLM 2的专家级医疗问答大语言模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>