<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中100==100为true，而1000==1000为false？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中100==100为true，而1000==1000为false？" />
<meta property="og:description" content="前言 今天跟大家聊一个有趣的话题，在Java中两个Integer对象做比较时，会产生意想不到的结果。
例如：
Integer a = 100; Integer b = 100; System.out.println(a==b); 其运行结果是：true。
而如果改成下面这样：
Integer a = 1000; Integer b = 1000; System.out.println(a==b); 其运行结果是：false。
看到这里，懵了没有？
为什么会产生这样的结果呢？
1 Integer对象 上面例子中的a和b，是两个Integer对象。
而非Java中的8种基本类型。
8种基本类型包括：
byte
short
int
long
float
double
boolean
char
Integer其实是int的包装类型。
在Java中，除了上面的这8种类型，其他的类型都是对象，保存的是引用，而非数据本身。
Integer a = 1000; Integer b = 1000; 可能有些人认为是下面的简写：
Integer a = new Integer(1000); Integer b = new Integer(1000); 这个想法表面上看起来是对的，但实际上有问题。
在JVM中的内存分布情况是下面这样的：
在栈中创建了两个局部变量a和b，同时在堆上new了两块内存区域，他们存放的值都是1000。
变量a的引用指向第一个1000的地址。
而变量b的引用指向第二个1000的地址。
很显然变量a和b的引用不相等。
既然两个Integer对象用==号，比较的是引用是否相等，但下面的这个例子为什么又会返回true呢？
Integer a = 100; Integer b = 100; System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f68cce2442b6172651167f6b7d357afa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T10:13:49+08:00" />
<meta property="article:modified_time" content="2024-01-03T10:13:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中100==100为true，而1000==1000为false？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>今天跟大家聊一个有趣的话题，在Java中两个Integer对象做比较时，会产生意想不到的结果。</p> 
<p>例如：</p> 
<pre><code>Integer a = 100;
Integer b = 100;
System.out.println(a==b);
</code></pre> 
<p>其运行结果是：true。</p> 
<p>而如果改成下面这样：</p> 
<pre><code>Integer a = 1000;
Integer b = 1000;
System.out.println(a==b);
</code></pre> 
<p>其运行结果是：false。</p> 
<p>看到这里，懵了没有？</p> 
<p>为什么会产生这样的结果呢？</p> 
<h3>1 Integer对象</h3> 
<p>上面例子中的a和b，是两个Integer对象。</p> 
<p>而非Java中的8种基本类型。</p> 
<p>8种基本类型包括：</p> 
<ul><li> <p>byte</p> </li><li> <p>short</p> </li><li> <p>int</p> </li><li> <p>long</p> </li><li> <p>float</p> </li><li> <p>double</p> </li><li> <p>boolean</p> </li><li> <p>char</p> </li></ul> 
<p>Integer其实是int的包装类型。</p> 
<p>在Java中，除了上面的这8种类型，其他的类型都是对象，保存的是引用，而非数据本身。</p> 
<pre><code>Integer a = 1000;
Integer b = 1000;
</code></pre> 
<p>可能有些人认为是下面的简写：</p> 
<pre><code>Integer a = new Integer(1000);
Integer b = new Integer(1000);
</code></pre> 
<p>这个想法表面上看起来是对的，但实际上有问题。</p> 
<p>在JVM中的内存分布情况是下面这样的：</p> 
<p class="img-center"><img alt="图片" height="440" src="https://images2.imgbox.com/ca/4c/zdRFG7j7_o.png" width="846"></p> 
<p>在栈中创建了两个局部变量a和b，同时在堆上new了两块内存区域，他们存放的值都是1000。</p> 
<p>变量a的<code>引用</code>指向第一个1000的地址。</p> 
<p>而变量b的<code>引用</code>指向第二个1000的地址。</p> 
<p>很显然变量a和b的引用不相等。</p> 
<p>既然两个Integer对象用==号，比较的是引用是否相等，但下面的这个例子为什么又会返回true呢？</p> 
<pre><code>Integer a = 100;
Integer b = 100;
System.out.println(a==b);
</code></pre> 
<p>不应该也返回false吗？</p> 
<p>对象a和b的引用不一样。</p> 
<pre><code>Integer a = 1000;
Integer b = 1000;
</code></pre> 
<p>其实正确的简写是下面这样的：</p> 
<pre><code>Integer a = Integer.valueOf(1000);
Integer b = Integer.valueOf(1000);
</code></pre> 
<p>在定义对象a和b时，Java自动调用了<code>Integer.valueOf</code>将数字封装成对象。</p> 
<p class="img-center"><img alt="图片" height="194" src="https://images2.imgbox.com/1f/12/d1DYyfP1_o.png" width="874"></p> 
<p>而如果数字在low和high之间的话，是直接从<code>IntegerCache</code>缓存中获取的数据。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="1044" src="https://images2.imgbox.com/7d/c6/i3vr9xNO_o.png" width="1080"></p> 
<p>Integer类的内部，将-128~127之间的数字缓存起来了。</p> 
<p>也就是说，如果数字在-128~127，是直接从<code>缓存</code>中获取的Integer对象。如果数字超过了这个范围，则是<code>new</code>出来的新对象。</p> 
<p>文章示例中的1000，超出了-128~127的范围，所以对象a和b的引用指向了两个不同的地址。</p> 
<p>而示例中的100，在-128~127的范围内，对象a和b的引用指向了同一个地址。</p> 
<p>所以会产生文章开头的运行结果。</p> 
<p>为什么Integer类会加这个缓存呢？</p> 
<p>答：-128~127是使用最频繁的数字，如果不做缓存，会在内存中产生大量指向相同数据的对象，有点浪费内存空间。</p> 
<pre><code>Integer a = 1000;
Integer b = 1000;
</code></pre> 
<p>如果想要上面的对象a和b相等，我们该怎么判断呢？</p> 
<p>当用户打开指定页面时，在缓存中每次都设置成count = count+1即可。</p> 
<p>用户第一次访问页面时，redis中的count值设置成1。用户以后每访问一次页面，都让count加1，最后重新设置到redis中。</p> 
<p class="img-center"><img alt="图片" height="572" src="https://images2.imgbox.com/52/ea/gnb0qFjM_o.png" width="626"></p> 
<p>这样在需要展示数量的地方，从redis中查出count值返回即可。</p> 
<p>该场景无需从数据埋点表中使用count(*)实时统计数据，性能将会得到极大的提升。</p> 
<p>不过在高并发的情况下，可能会存在缓存和数据库的数据不一致的问题。</p> 
<p>但对于统计浏览总次数或者浏览总人数这种业务场景，对数据的准确性要求并不高，容忍数据不一致的情况存在。</p> 
<h4>2.2 加二级缓存</h4> 
<p>对于有些业务场景，新增数据很少，大部分是统计数量操作，而且查询条件很多。这时候使用传统的count(*)实时统计数据，性能肯定不会好。</p> 
<p>假如在页面中可以通过id、name、状态、时间、来源等，一个或多个条件，统计品牌数量。</p> 
<p>这种情况下用户的组合条件比较多，增加联合索引也没用，用户可以选择其中一个或者多个查询条件，有时候联合索引也会失效，只能尽量满足用户使用频率最高的条件增加索引。</p> 
<p>也就是有些组合条件可以走索引，有些组合条件没法走索引，这些没法走索引的场景，该如何优化呢？</p> 
<p>答：使用<code>二级缓存</code>。</p> 
<p>二级缓存其实就是内存缓存。</p> 
<p>我们可以使用<code>caffine</code>或者<code>guava</code>实现二级缓存的功能。</p> 
<p>目前<code>SpringBoot</code>已经集成了caffine，使用起来非常方便。</p> 
<p>只需在需要增加二级缓存的查询方法中，使用<code>@Cacheable</code>注解即可。</p> 
<pre><code> @Cacheable(value = "brand", , keyGenerator = "cacheKeyGenerator")
   public BrandModel getBrand(Condition condition) {
       return getBrandByCondition(condition);
   }
</code></pre> 
<p>然后自定义cacheKeyGenerator，用于指定缓存的key。</p> 
<pre><code>public class CacheKeyGenerator implements KeyGenerator {
    @Override
    public Object generate(Object target, Method method, Object... params) {
        return target.getClass().getSimpleName() + UNDERLINE
                + method.getName() + ","
                + StringUtils.arrayToDelimitedString(params, ",");
    }
}
</code></pre> 
<p>这个key是由各个条件组合而成。</p> 
<p>这样通过某个条件组合查询出品牌的数据之后，会把结果缓存到内存中，设置过期时间为5分钟。</p> 
<p>后面用户在5分钟内，使用相同的条件，重新查询数据时，可以直接从二级缓存中查出数据，直接返回了。</p> 
<p>这样能够极大的提示count(*)的查询效率。</p> 
<p>但是如果使用二级缓存，可能存在不同的服务器上，数据不一样的情况。我们需要根据实际业务场景来选择，没法适用于所有业务场景。</p> 
<h4>2.3 多线程执行</h4> 
<p>不知道你有没有做过这样的需求：统计有效订单有多少，无效订单有多少。</p> 
<p>这种情况一般需要写两条sql，统计有效订单的sql如下：</p> 
<pre><code>select count(*) from order where status=1;
</code></pre> 
<p>统计无效订单的sql如下：</p> 
<pre><code>select count(*) from order where status=0;
</code></pre> 
<p>但如果在一个接口中，同步执行这两条sql效率会非常低。</p> 
<p>这时候，可以改成成一条sql：</p> 
<pre><code>select count(*),status from order
group by status;
</code></pre> 
<p>使用<code>group by</code>关键字分组统计相同status的数量，只会产生两条记录，一条记录是有效订单数量，另外一条记录是无效订单数量。</p> 
<p>但有个问题：status字段只有1和0两个值，重复度很高，区分度非常低，不能走索引，会全表扫描，效率也不高。</p> 
<p>还有其他的解决方案不？</p> 
<p>答：使用多线程处理。</p> 
<p>我们可以使用<code>CompleteFuture</code>使用两个<code>线程</code>异步调用统计有效订单的sql和统计无效订单的sql，最后汇总数据，这样能够提升查询接口的性能。</p> 
<p>最近我建了新的技术交流群，打算将它打造成高质量的活跃群，欢迎小伙伴们加入。</p> 
<p><strong>我以往的技术群里技术氛围非常不错，大佬很多。</strong></p> 
<p></p> 
<p class="img-center"><img alt="image.png" height="1200" src="https://images2.imgbox.com/d4/bc/xj2Nx7yq_o.png" width="828"></p> 
<p>加微信：su_san_java，备注：加群，即可加入该群。</p> 
<h3>2 判断相等</h3> 
<p>在Java中，如果使用<code>==</code>号比较两个对象是否相等，比如：a==b，其实比较的是两个对象的引用是否相等。</p> 
<p>很显然变量a和b的引用，指向的是两个不同的地址，引用肯定是不相等的。</p> 
<p>因此下面的执行结果是：false。</p> 
<pre><code>Integer a =  Integer.valueOf(1000);
Integer b = Integer.valueOf(1000);
System.out.println(a==b);
</code></pre> 
<p>由于1000在Integer缓存的范围之外，因此上面的代码最终会变成这样：</p> 
<pre><code>Integer a =  new Integer(1000);
Integer b = new Integer(1000);
System.out.println(a==b);
</code></pre> 
<p>如果想要a和b比较时返回true，该怎么办呢？</p> 
<p>答：调用<code>equals</code>方法。</p> 
<p>当用户打开指定页面时，在缓存中每次都设置成count = count+1即可。</p> 
<p>用户第一次访问页面时，redis中的count值设置成1。用户以后每访问一次页面，都让count加1，最后重新设置到redis中。</p> 
<p class="img-center"><img alt="图片" height="572" src="https://images2.imgbox.com/5c/d8/ou3AtDTn_o.png" width="626"></p> 
<p>这样在需要展示数量的地方，从redis中查出count值返回即可。</p> 
<p>该场景无需从数据埋点表中使用count(*)实时统计数据，性能将会得到极大的提升。</p> 
<p>不过在高并发的情况下，可能会存在缓存和数据库的数据不一致的问题。</p> 
<p>但对于统计浏览总次数或者浏览总人数这种业务场景，对数据的准确性要求并不高，容忍数据不一致的情况存在。</p> 
<h4>2.2 加二级缓存</h4> 
<p>对于有些业务场景，新增数据很少，大部分是统计数量操作，而且查询条件很多。这时候使用传统的count(*)实时统计数据，性能肯定不会好。</p> 
<p>假如在页面中可以通过id、name、状态、时间、来源等，一个或多个条件，统计品牌数量。</p> 
<p>这种情况下用户的组合条件比较多，增加联合索引也没用，用户可以选择其中一个或者多个查询条件，有时候联合索引也会失效，只能尽量满足用户使用频率最高的条件增加索引。</p> 
<p>也就是有些组合条件可以走索引，有些组合条件没法走索引，这些没法走索引的场景，该如何优化呢？</p> 
<p>答：使用<code>二级缓存</code>。</p> 
<p>二级缓存其实就是内存缓存。</p> 
<p>我们可以使用<code>caffine</code>或者<code>guava</code>实现二级缓存的功能。</p> 
<p>目前<code>SpringBoot</code>已经集成了caffine，使用起来非常方便。</p> 
<p>只需在需要增加二级缓存的查询方法中，使用<code>@Cacheable</code>注解即可。</p> 
<pre><code> @Cacheable(value = "brand", , keyGenerator = "cacheKeyGenerator")
   public BrandModel getBrand(Condition condition) {
       return getBrandByCondition(condition);
   }
</code></pre> 
<p>然后自定义cacheKeyGenerator，用于指定缓存的key。</p> 
<pre><code>public class CacheKeyGenerator implements KeyGenerator {
    @Override
    public Object generate(Object target, Method method, Object... params) {
        return target.getClass().getSimpleName() + UNDERLINE
                + method.getName() + ","
                + StringUtils.arrayToDelimitedString(params, ",");
    }
}
</code></pre> 
<p>这个key是由各个条件组合而成。</p> 
<p>这样通过某个条件组合查询出品牌的数据之后，会把结果缓存到内存中，设置过期时间为5分钟。</p> 
<p>后面用户在5分钟内，使用相同的条件，重新查询数据时，可以直接从二级缓存中查出数据，直接返回了。</p> 
<p>这样能够极大的提示count(*)的查询效率。</p> 
<p>但是如果使用二级缓存，可能存在不同的服务器上，数据不一样的情况。我们需要根据实际业务场景来选择，没法适用于所有业务场景。</p> 
<h4>2.3 多线程执行</h4> 
<p>不知道你有没有做过这样的需求：统计有效订单有多少，无效订单有多少。</p> 
<p>这种情况一般需要写两条sql，统计有效订单的sql如下：</p> 
<pre><code>select count(*) from order where status=1;
</code></pre> 
<p>统计无效订单的sql如下：</p> 
<pre><code>select count(*) from order where status=0;
</code></pre> 
<p>但如果在一个接口中，同步执行这两条sql效率会非常低。</p> 
<p>这时候，可以改成成一条sql：</p> 
<pre><code>select count(*),status from order
group by status;
</code></pre> 
<p>使用<code>group by</code>关键字分组统计相同status的数量，只会产生两条记录，一条记录是有效订单数量，另外一条记录是无效订单数量。</p> 
<p>但有个问题：status字段只有1和0两个值，重复度很高，区分度非常低，不能走索引，会全表扫描，效率也不高。</p> 
<p>还有其他的解决方案不？</p> 
<p>答：使用多线程处理。</p> 
<p>我们可以使用<code>CompleteFuture</code>使用两个<code>线程</code>异步调用统计有效订单的sql和统计无效订单的sql，最后汇总数据，这样能够提升查询接口的性能。</p> 
<p>最近我建了新的技术交流群，打算将它打造成高质量的活跃群，欢迎小伙伴们加入。</p> 
<p><strong>我以往的技术群里技术氛围非常不错，大佬很多。</strong></p> 
<p></p> 
<p class="img-center"><img alt="image.png" height="1200" src="https://images2.imgbox.com/e8/5d/vuM7lyRP_o.png" width="828"></p> 
<p>加微信：su_san_java，备注：加群，即可加入该群。</p> 
<p>代码改成这样的：</p> 
<pre><code>Integer a = Integer.valueOf(1000);
Integer b = Integer.valueOf(1000);
System.out.println(a.equals(b));
</code></pre> 
<p>执行结果是：true。</p> 
<p>其实equals方法是Object类的方法，所有对象都有这个方法。</p> 
<p class="img-center"><img alt="图片" height="705" src="https://images2.imgbox.com/ff/c7/s18aUzul_o.png" width="1080"></p> 
<p>它的底层也是用的==号判断两个Object类型的对象是否相等。</p> 
<p>不过Integer类对该方法进行了重写：</p> 
<p class="img-center"><img alt="图片" height="629" src="https://images2.imgbox.com/14/08/ZBIoVfig_o.png" width="1080"></p> 
<p>它的底层会先调用Integer类的intValue方法获取int类型的数据，然后再通过==号进行比较。</p> 
<p>此时，比较的不是两个对象的引用是否相等，而且比较的具体的数据是否相等。</p> 
<p>我们使用equals方法，可以判断两个Integer对象的值是否相等，而不是判断引用是否相等。</p> 
<h3>总结</h3> 
<p>Integer类中有缓存，范围是：<code>-128~127</code>。</p> 
<pre><code>Integer a = 1000;
</code></pre> 
<p>其实默认调用了<code>Integer.valueOf</code>方法，将数字转换成Integer类型：</p> 
<pre><code>Integer a = Integer.valueOf(1000);
</code></pre> 
<p>如果数字在-128~127之间，则直接从缓存中获取Integer对象。</p> 
<p>如果数字在-128~127之外，则该方法会new一个新的Integer对象。</p> 
<p>我们在判断两个对象是否相等时，一定要多注意：</p> 
<ol><li> <p>判断两个对象的引用是否相等，用==号判断。</p> </li><li> <p>判断两个对象的值是否相等，调用equals方法判断。</p> </li></ol> 
<p></p> 
<h4>最后说一句(求关注，别白嫖我)</h4> 
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。</p> 
<p>求一键三连：点赞、转发、在看。</p> 
<p>关注公众号：【苏三说技术】，在公众号中回复：面试、代码神器、开发手册、时间管理有超赞的粉丝福利，另外回复：加群，可以跟很多BAT大厂的前辈交流和学习。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6476de785d3d6c84788fa095dbc59d96/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于HAL库外部中断的开关流程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3369e526a083b3c15a493db4c862cba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">明明加了唯一索引，为什么还是产生重复数据？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>