<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;学习笔记（8）继承 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;学习笔记（8）继承" />
<meta property="og:description" content="目录
继承
基本语法
继承方式
继承中构造和析构顺序
继承同名成员处理方式：
继承同名静态成员处理方式
多继承语法
菱形继承
继承 基本语法 面向对象三大特性之一
一些类除了有上级别类的共性之外，还有自己的特性
可以利用继承，减少重复代码
语法：
class 子类 : 继承方式 父类
class Python :public BasePage 子类：派生类
父类：基类
#include&lt;iostream&gt; using namespace std; #include &lt;string&gt; //模拟网页 class BasePage { public: void header() { cout &lt;&lt; &#34;公共头部&#34; &lt;&lt; endl; } void footer() { cout &lt;&lt; &#34;公共底部&#34; &lt;&lt; endl; } }; //Java页面 class Java :public BasePage { public: void content() { cout &lt;&lt; &#34;java学科内容&#34; &lt;&lt; endl; } }; class Python :public BasePage { public: void content() { cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/55a1456a54db0fde8a12ebc8027c059c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-29T19:54:37+08:00" />
<meta property="article:modified_time" content="2023-05-29T19:54:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;学习笔记（8）继承</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#%E7%BB%A7%E6%89%BF" rel="nofollow">继承</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" rel="nofollow">基本语法</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F" rel="nofollow">继承方式</a></p> 
<p id="%C2%A0%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%C2%A0%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F" rel="nofollow"> 继承中构造和析构顺序</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9A" rel="nofollow">继承同名成员处理方式：</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F" rel="nofollow">继承同名静态成员处理方式</a></p> 
<p id="%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95" rel="nofollow">多继承语法</a></p> 
<p id="%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF" rel="nofollow">菱形继承</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>继承</h2> 
<p></p> 
<h3 id="%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</h3> 
<p>面向对象三大特性之一</p> 
<p>一些类除了有上级别类的共性之外，还有自己的特性</p> 
<p>可以利用继承，减少重复代码</p> 
<p><img alt="" height="437" src="https://images2.imgbox.com/8b/bc/wrsETsEP_o.png" width="1012"></p> 
<p> 语法：</p> 
<p>class 子类 : 继承方式 父类</p> 
<p>class Python :public BasePage </p> 
<p>子类：派生类</p> 
<p>父类：基类</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#include &lt;string&gt;
//模拟网页
class BasePage {
public:
	void header() {
		cout &lt;&lt; "公共头部" &lt;&lt; endl;
	}
	void footer() {
		cout &lt;&lt; "公共底部" &lt;&lt; endl;
	}
};
//Java页面
class Java :public BasePage {
public:
	void content() {
		cout &lt;&lt; "java学科内容" &lt;&lt; endl;
	}
};
class Python :public BasePage {
public:
	void content() {
		cout &lt;&lt; "python学科内容" &lt;&lt; endl;
	}
};
void test01() {
	cout &lt;&lt; "java内容如下：" &lt;&lt; endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.content();


	cout &lt;&lt; "python内容如下：" &lt;&lt; endl;
	Python py;
	py.header();
	py.footer();
	py.content();
}
int main() {
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h3 id="%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F">继承方式</h3> 
<p>共有三种：</p> 
<p>公共继承</p> 
<p>保护继承</p> 
<p>私有继承</p> 
<p><img alt="" height="557" src="https://images2.imgbox.com/cd/8f/R2VIbDDo_o.png" width="893"></p> 
<p> 父类中所有非静态成员属性都会被子类继承</p> 
<p>父类中私有成员属性是被编译器隐藏了，因此访问不到，但是确实继承了</p> 
<p><strong>查看类： </strong></p> 
<p>利用开发人员命令提示工具查看工具</p> 
<p>跳转盘符 F：</p> 
<p>跳转文件路径 cd 具体路径</p> 
<p>查看类cl /d1 reportSingleClassLayout类名 文件名</p> 
<p>cl /d1 reportSingleClassLayoutJava 赋值运算符重载.cpp<img alt="" height="607" src="https://images2.imgbox.com/3a/ba/6tCelsmu_o.png" width="885"></p> 
<p><img alt="" height="599" src="https://images2.imgbox.com/c3/3c/Rue44j5t_o.png" width="1158"></p> 
<h3 id="%C2%A0%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"> 继承中构造和析构顺序</h3> 
<p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p> 
<p>先构造父类，再构造子类，</p> 
<p>先析构子类，再析构父类</p> 
<p></p> 
<h3 id="%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9A">继承同名成员处理方式：</h3> 
<p>通过子类访问子类同名成员，直接访问即可；通过子类访问父类同名成员，需加作用域</p> 
<p>    son.func();  //直接调用，调用的是子类中的同名函数<br>     son.Base::func();//加作用域 调用父类中的同名函数</p> 
<p>如果子类中出现和父类同名的函数，子类中同名成员函数会隐藏父类中所有的同名成员函数，不能访问，加上作用域则可以访问。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#include &lt;string&gt;
class Base {
public:
	Base() {
		m_a = 100;
	}
	int m_a;
	void func() {
		cout &lt;&lt; "父类func" &lt;&lt; endl;
	}
};
class Son :public Base {
public:
	Son() {
		m_a = 200;
	}
	void func() {
		cout &lt;&lt; "子类func" &lt;&lt; endl;
	}
	int m_a;
};
//同名成员属性处理
void test01() {
	Son son;
	cout &lt;&lt; "son" &lt;&lt; son.m_a &lt;&lt; endl;
	cout &lt;&lt; "base" &lt;&lt; son.Base::m_a &lt;&lt; endl;  //需要加作用域
}
//同名成员函数处理
void test02() {
	Son son;
	son.func();  //直接调用，调用的是子类中的同名函数
	son.Base::func();//加作用域 调用父类中的同名函数
}
int main() {
	test01();
	test02();
	system("pause");
	return 0;
}</code></pre> 
<h3 id="%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">继承同名静态成员处理方式</h3> 
<p>同非静态成员，但多一种通过类名访问的方式</p> 
<p> Son::Base::m_a </p> 
<p>Son::Base::func();</p> 
<p>访问子类中的同名成员，直接访问</p> 
<p>访问父类中的同名成员，加作用域</p> 
<p>如果子类中出现和父类同名的函数，子类中同名成员函数会隐藏父类中所有的同名成员函数，不能访问，加上作用域则可以访问</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#include &lt;string&gt;
class Base {
public:
	static int m_a;//类内声明，类外初始化
	static void func() {
		cout &lt;&lt; "base static func" &lt;&lt; endl;
	}
	
};
int Base::m_a = 100;
class Son :public Base {
public:
	static int m_a;
	static void func() {
		cout &lt;&lt; "son static func" &lt;&lt; endl;
	}
};
int Son::m_a = 200;
//同名成员属性处理
void test01() {
	//通过对象访问
	cout &lt;&lt; "通过对象访问" &lt;&lt; endl;
	Son son;
	cout &lt;&lt; "son" &lt;&lt; son.m_a &lt;&lt; endl;
	cout &lt;&lt; "base" &lt;&lt; son.Base::m_a &lt;&lt; endl;  //需要加作用域
	//通过类名访问
	cout &lt;&lt; "son" &lt;&lt; Son::m_a &lt;&lt; endl;
	//第一个::表示通过类名访问，第二个::表示访问父类作用域下
	cout &lt;&lt; "base" &lt;&lt; Son::Base::m_a &lt;&lt; endl;
}
//同名成员函数处理
void test02() {
	//通过对象
	Son s;
	s.func();
	s.Base::func();
	//通过类名
	Son::func();
	Son::Base::func();
}
int main() {
	test01();
	test02();
	system("pause");
	return 0;
}</code></pre> 
<h3 id="%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95">多继承语法</h3> 
<p>c++中允许一个类继承多个类</p> 
<p>语法：class 子类 : 继承方式 父类1，继承方式 父类2.......</p> 
<p>多继承可能会引发父类中有同名成员，需要加作用域区分</p> 
<p>不建议使用多继承</p> 
<h3 id="%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF">菱形继承</h3> 
<p>两个派生类继承同一个基类，又有某个类同时继承着两个派生类，这种继承称为菱形继承或者钻石继承</p> 
<p><img alt="" height="323" src="https://images2.imgbox.com/0a/70/HsYtgGnV_o.png" width="397"></p> 
<p>菱形继承问题：</p> 
<p>羊和驼都继承了动物的数据，羊驼在进行继承时会产生二义性</p> 
<p>羊驼继承了两份动物的数据，重复 ,导致资源浪费，使用virtual关键字</p> 
<p>继承指针而不是数据，通过指针偏移量找到数据</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
// 动物类
class Animal{
public:
	int m_age;
};
// 羊类
// 利用虚继承解决菱形继承问题  继承指针而不是数据，通过指针偏移量找到数据
// 关键字：virtual
// animal：虚基类
class Sheep:virtual public Animal{};
// 驼类
class Tuo:virtual public Animal{};
// 羊驼类
class YT :public Sheep,public Tuo {

};
void test01() {
	YT yt;
	// 菱形继承需要加作用域区分相同数据（不使用虚继承时）
	yt.Sheep::m_age = 19;
	yt.Tuo::m_age = 20;
	cout &lt;&lt; yt.Sheep::m_age &lt;&lt; endl;
	cout &lt;&lt; yt.Tuo::m_age &lt;&lt; endl;
	// 相同数据只需要一份 虚继承
	cout &lt;&lt; yt.m_age &lt;&lt; endl;

}
int main() {
	test01();
	system("pause");
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65ac23ba31741115fa5d047415bfa52f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">markdown编辑器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30da8d740517cb41c30b0a44b4e931a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SSM整合中的配置详情</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>