<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>R数据可视化：如何绘制条形图？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="R数据可视化：如何绘制条形图？" />
<meta property="og:description" content="条形图也许是最常用的数据可视化工具，通常用来展示不同的分类下（在x轴上）某个数值型变量的取值（在y轴上）。例如，条形图可以用来形象地展示4种不同商品的价格，但不适宜用来展示商品价格随时间的变动趋势，因为这里的时间是一个连续变量——尽管我们也可以这么做，后面会看到这种情形。
绘制条形图时需特别注意一个重要的细节：有时条形图的条形高度表示的是数据集中变量的频数，有时则表示变量取值本身。牢记这个区别——这里极易混淆，因为两者与数据集的对应关系不同，但又对应同样的术语。本章将对此进行深入讨论，并分别介绍这两类条形图的绘图技巧。
从本章开始，本书将重点介绍使用ggplot2而不是R基础绘图系统。用ggplot2绘图更简便，并且可以绘制更复杂的图形。
3.1　绘制基本条形图 问题 你有一个包含了两列数据的数据框，其中一列数据表示条形在x轴上的位置，另一列表示每个条形在y轴上对应的高度，基于此，如何绘制条形图？
方法 使用ggplot()函数和geom_col()绘制上述条形图，并分别指定与x轴和y轴对应的变量（见图3-1）。
library(gcookbook) # 加载gcookbook是为了使用其中的pg_mean数据集 ggplot(pg_mean, aes(x = group, y = weight)) &#43; geom_col() 图3-1：当x是离散变量时绘制的条形图
在之前版本的ggplot2中，建议用geom_bar(stat =&#34;identity&#34;)来绘制针对变量值的条形图。在ggplot2 2.2.0版中，用geom_col()函数可以执行相同的操作。
讨论 当x是连续（数值型）变量时，条形图的结果与上图会略有不同。此时，ggplot不是只在实际取值处绘制条形，也会在x轴上介于最大值和最小值之间所有可能的取值处绘制条形，如图3-2所示。我们可以使用factor()函数将连续变量转化为离散变量。
# 没有Time == 6的输入 BOD #&gt; Time demand #&gt; 1 1 8.3 #&gt; 2 2 10.3 #&gt; 3 3 19.0 #&gt; 4 4 16.0 #&gt; 5 5 15.6 #&gt; 6 7 19.8 # Time是数值型（连续）变量 str(BOD) #&gt; &#39;data.frame&#39;: 6 obs. of 2 variables: #&gt; $ Time : num 1 2 3 4 5 7 #&gt; $ demand: num 8." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/eda387be9a2722a73b7cec2bc32d5109/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-17T20:59:10+08:00" />
<meta property="article:modified_time" content="2021-07-17T20:59:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">R数据可视化：如何绘制条形图？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>条形图也许是最常用的数据可视化工具，通常用来展示不同的分类下（在<em>x</em>轴上）某个数值型变量的取值（在<em>y</em>轴上）。例如，条形图可以用来形象地展示4种不同商品的价格，但不适宜用来展示商品价格随时间的变动趋势，因为这里的时间是一个连续变量——尽管我们也可以这么做，后面会看到这种情形。</p> 
<p>绘制条形图时需特别注意一个重要的细节：有时条形图的条形高度表示的是数据集中变量的频数，有时则表示变量取值本身。牢记这个区别——这里极易混淆，因为两者与数据集的对应关系不同，但又对应同样的术语。本章将对此进行深入讨论，并分别介绍这两类条形图的绘图技巧。</p> 
<p>从本章开始，本书将重点介绍使用ggplot2而不是R基础绘图系统。用ggplot2绘图更简便，并且可以绘制更复杂的图形。</p> 
<h2>3.1　绘制基本条形图</h2> 
<h2>问题</h2> 
<p>你有一个包含了两列数据的数据框，其中一列数据表示条形在<em>x</em>轴上的位置，另一列表示每个条形在<em>y</em>轴上对应的高度，基于此，如何绘制条形图？</p> 
<h2>方法</h2> 
<p>使用ggplot()函数和geom_col()绘制上述条形图，并分别指定与<em>x</em>轴和<em>y</em>轴对应的变量（见图3-1）。</p> 
<pre><code>library(gcookbook) # 加载gcookbook是为了使用其中的pg_mean数据集
ggplot(pg_mean, aes(x = group, y = weight)) + 
  geom_col()</code></pre> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/dd/6e/CnRZKHAm_o.png"></p> 
<p></p> 
<p>图3-1：当<strong>x</strong>是离散变量时绘制的条形图</p> 
<blockquote> 
 <p>在之前版本的ggplot2中，建议用geom_bar(stat ="identity")来绘制针对变量值的条形图。在ggplot2 2.2.0版中，用geom_col()函数可以执行相同的操作。</p> 
</blockquote> 
<h2>讨论</h2> 
<p>当x是连续（数值型）变量时，条形图的结果与上图会略有不同。此时，ggplot不是只在实际取值处绘制条形，也会在<em>x</em>轴上介于最大值和最小值之间所有可能的取值处绘制条形，如图3-2所示。我们可以使用factor()函数将连续变量转化为离散变量。</p> 
<pre><code># 没有Time == 6的输入
BOD
#&gt;  Time demand
#&gt; 1   1    8.3
#&gt; 2   2   10.3
#&gt; 3   3   19.0
#&gt; 4   4   16.0
#&gt; 5   5   15.6
#&gt; 6   7   19.8

# Time是数值型（连续）变量
str(BOD)
#&gt; 'data.frame':    6 obs. of 2 variables:
#&gt;  $ Time  : num  1 2 3 4 5 7
#&gt;  $ demand: num  8.3 10.3 19 16 15.6 19.8
#&gt;  - attr(*, "reference")= chr "A1.4, p. 270"

ggplot(BOD, aes(x = Time, y = demand)) + 
  geom_col()

# 使用factor()函数将Time转化为离散（分类）变量
ggplot(BOD, aes(x = factor(Time), y = demand)) + 
  geom_col()</code></pre> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/64/54/Pqlsfuun_o.png"></p> 
<p></p> 
<p>图3-2：针对变量值绘制的条形图，<em>x</em>轴对应的是连续变量（左图）；将x转化为因子型变量之后绘制的条形图（注意此处缺失了取值为6的条形，右图）</p> 
<p>值得注意的是，BOD中没有对应Time = 6的行。当x是连续变量时，ggplot2将使用数值坐标轴，该坐标轴在该范围内具有所有数值的空间，因此在图中会出现数值为6的空区域。当Time被转化成因子时，ggplot2会把它作为离散变量处理，其中的值被视为任意标签而不是数值，因此它不会在<em>x</em>轴上为最小值和最大值之间的所有可能的数值分配空间。</p> 
<p>在本例中，数据集中有两列值分别对应于变量x和y。如果想让条形图的高度与每组变量的频数相对应，可参见3.3节的内容。</p> 
<p>默认设置下，条形图的填充色为深灰色且条形图没有边框线，我们可通过调整fill参数的值来改变条形图的填充色；可通过colour参数为条形图添加边框线。在图3-3中，我们将填充色和边框线的颜色分别指定为浅蓝色和黑色。</p> 
<pre><code>ggplot(pg_mean, aes(x = group, y = weight)) + 
  geom_col(fill = "lightblue", colour = "black")</code></pre> 
<blockquote> 
 <p>在ggplot2中，颜色参数默认使用的是英式拼写colour，而非美式拼写color。然而，ggplot2会在底层将美式拼写重映射为英式拼写，因此输入美式拼写的参数并不影响函数的运行。</p> 
</blockquote> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/cc/b3/oCZERCoJ_o.png"></p> 
<p></p> 
<p>图3-3：所有条形的填充色和边框线颜色均为单色</p> 
<h2>另见</h2> 
<p>如果想让条形图的高度对应于每组变量的频数，参见3.3节。</p> 
<p>要根据另一个变量的值重排因子水平顺序，参见15.9节。要手动更改因子水平顺序，参见15.8节。</p> 
<p>关于图形着色的更多内容，参见第12章。</p> 
<h2>3.2　绘制簇状条形图</h2> 
<h2>问题</h2> 
<p>如何绘制基于某些分类变量的簇状条形图？</p> 
<h2>方法</h2> 
<p>将分类变量映射到fill参数上，并运行命令geom_col(position = "dodge")。</p> 
<p>下面以cabbage_exp数据集为例演示一下绘图过程，该数据集包含两个分类变量Cultivar和Date及一个连续变量Weight。</p> 
<pre><code>library(gcookbook) # 加载gcookbook是为了使用cabbage_exp数据集
cabbage_exp
#&gt;   Cultivar Date Weight         sd  n         se
#&gt; 1      c39  d16   3.18  0.9566144 10 0.30250803
#&gt; 2      c39  d20   2.80  0.2788867 10 0.08819171
#&gt; 3      c39  d21   2.74  0.9834181 10 0.31098410
#&gt; 4      c52  d16   2.26  0.4452215 10 0.14079141
#&gt; 5      c52  d20   3.11  0.7908505 10 0.25008887
#&gt; 6      c52  d21   1.47  0.2110819 10 0.06674995</code></pre> 
<p>我们分别将Date和Cultivar映射到x和fill（见图3-4）。</p> 
<pre><code>ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
  geom_col(position = "dodge")</code></pre> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/83/d6/Cfd3tibY_o.png"></p> 
<p></p> 
<p>图3-4：簇状条形图</p> 
<h2>讨论</h2> 
<p>最基本的条形图通常只对应一个绘制在<em>x</em>轴上的分类变量和一个绘制在<em>y</em>轴上的连续变量。有时我们想额外添加一个分类变量跟<em>x</em>轴上的分类变量一起对数据进行分组。此时，可通过将该分类变量映射到fill参数来绘制簇状条形图，这里的fill参数用来指定条形的填充色。在这一过程中必须令参数position = "dodge"以使得两组条形在水平方向上错开排列，否则，系统会输出堆积条形图（参见3.7节）。</p> 
<p>与映射到条形图<em>x</em>轴上的变量类似，映射到条形填充色参数上的变量应该是分类变量而不是连续变量。</p> 
<p>我们可以通过将geom_col()中的参数指定为colour = "black"为条形添加黑色边框线；可以通过scale_fill_brewer()或者scale_fill_manual()函数对图形颜色进行设置。在图3-5中，我们使用RColorBrewer包中的Pastel1调色盘对图形进行调色。</p> 
<pre><code>ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) + 
  geom_col(position = "dodge", colour = "black") + 
  scale_fill_brewer(palette = "Pastel1")</code></pre> 
<p>其他图形属性诸如颜色colour（指定条形图的边框线颜色）和线型（linestyle）也能用来对变量进行分组，不过，填充色（fill）也许是最合人心意的图形属性。</p> 
<p>注意，如果分类变量各水平的组合中有缺失项，那么，绘图结果中的条形则相应地略去不绘，同时，临近的条形将自动扩充到相应位置。删去上例数据中的最后一行后，可得到图3-6。</p> 
<pre><code>ce &lt;- cabbage_exp[1:5, ]
ce
#&gt;   Cultivar Date  Weight        sd  n         se
#&gt; 1      c39  d16    3.18 0.9566144 10 0.30250803
#&gt; 2      c39  d20    2.80 0.2788867 10 0.08819171
#&gt; 3      c39  d21    2.74 0.9834181 10 0.31098410
#&gt; 4      c52  d16    2.26 0.4452215 10 0.14079141
#&gt; 5      c52  d20    3.11 0.7908505 10 0.25008887

ggplot(ce, aes(x = Date, y = Weight, fill = Cultivar)) + 
  geom_col(position = "dodge", colour = "black") + 
  scale_fill_brewer(palette = "Pastel1")</code></pre> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/eb/59/D3fbWeAC_o.png"></p> 
<p></p> 
<p>图3-5：添加了黑色边框线和不同配色的簇状条形图</p> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/a0/33/7OkzhOx3_o.png"></p> 
<p></p> 
<p>图3-6：缺失条形的簇状条形图——临近的条形自动扩充到相应位置</p> 
<p>如果你的数据与上面类似，那么可以在分类变量组合缺失的那一项为变量y手动输入一个NA值。</p> 
<h2>另见</h2> 
<p>关于条形图着色的更多内容，参见3.4节。</p> 
<p>要根据另一个变量的值重排因子水平顺序，参见15.9节。</p> 
<h2>3.3　绘制频数条形图</h2> 
<h2>问题</h2> 
<p>如果数据集中每行数据对应于一个样本，如何针对样本频数绘制条形图？</p> 
<h2>方法</h2> 
<p>使用函数goem_bar()，同时不要映射任何变量到y参数（见图3-7）：</p> 
<pre><code># 等价于使用geom_bar(stat = "bin")
ggplot(diamonds, aes(x = cut)) + 
  geom_bar()</code></pre> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/3a/72/HAX7JvTK_o.png"></p> 
<p></p> 
<p>图3-7：频数条形图</p> 
<h2>讨论</h2> 
<p>diamonds数据集共有53 940行数据，每行数据对应于一颗钻石的品质信息：</p> 
<pre><code>diamonds
#&gt; # A tibble: 53,940 x 10
#&gt;   carat  cut      color clarity depth table price     x     y     z
#&gt;   &lt;dbl&gt;  &lt;ord&gt;    &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 0.23  Ideal     E      SI2     61.5    55   326  3.95  3.98  2.43
#&gt; 2 0.21  Premium   E      SI1     59.8    61   326  3.89  3.84  2.31
#&gt; 3 0.23  Good      E      VS1     56.9    65   327  4.05  4.07  2.31
#&gt; 4 0.290 Premium   I      VS2     62.4    58   334  4.2   4.23  2.63
#&gt; 5 0.31  Good      J      SI2     63.3    58   335  4.34  4.35  2.75
#&gt; 6 0.24  Very Good J      VVS2    62.8    57   336  3.94  3.96  2.48
#&gt; # ... with 5.393e+04 more rows</code></pre> 
<p>geom_bar()函数在默认情况下将参数设定为stat = "bin"，该操作会自动计算每组（根据<em>x</em>轴上面的变量进行分组）变量对应的观测数。从图3-7可以看到，切工精美（Ideal）的钻石大概有23 000颗。</p> 
<p>在本例中，<em>x</em>轴对应的是离散变量。当<em>x</em>轴对应于连续变量时，我们会在每一个x值处得到一个条形，如图3-8上图所示。</p> 
<p><em>x</em>轴对应连续变量的条形图与直方图类似，但不完全相同。直方图如图3-8下图所示。在此类条形图中，每个条形表示唯一的x值，而在直方图中，每个条形表示一定范围内的x值。</p> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/16/de/1qw5Q7bd_o.png"></p> 
<p></p> 
<p>图3-8：<em>x</em>轴对应于连续变量的频数条形图（上图）；直方图（下图）</p> 
<h2>另见</h2> 
<p>如果不想让ggplot()函数自动计算每组数据的行数绘制频数条形图，而是想通过数据框中的某列来指定y参数的话，使用geom_col()函数，可以参见3.1节的内容。</p> 
<p>当然，也可以通过先计算出每组数据的行数，再将计算结果传递给ggplot()函数来绘制上图。关于数据汇总的更多内容，参见15.17节。</p> 
<p>关于直方图的更多内容，参见6.1节。</p> 
<h2>3.4　条形图着色</h2> 
<h2>问题</h2> 
<p>如何将条形图中的条形设定为不同的颜色？</p> 
<h2>方法</h2> 
<p>将合适的变量映射到填充色（fill）上即可。</p> 
<p>这里以数据集uspopchange为例。该数据集描述了美国各州人口自2000年到2010年的变化情况。我们选取出人口增长最快的10个州进行绘图。图中会根据地区信息（东北部、南部、中北部、西部）对条形进行着色。</p> 
<p>首先，选取出人口增长最快的10个州：</p> 
<pre><code>library(gcookbook) # 加载gcookbook是为了使用uspopchange数据集
library(dplyr)

upc &lt;- uspopchange %&gt;% 
  arrange(desc(Change)) %&gt;% 
  slice(1:10)

upc
#&gt;             State Abb  Region  Change
#&gt; 1          Nevada  NV    West    35.1
#&gt; 2         Arizona  AZ    West    24.6
#&gt; 3            Utah  UT    West    23.8
#&gt;  ...&lt;4 more rows&gt;...
#&gt; 8         Florida  FL    South   17.6
#&gt; 9        Colorado  CO     West   16.9
#&gt; 10 South Carolina  SC    South   15.3</code></pre> 
<p>接下来，将Region映射到fill上并绘制条形图（见图3-9）：</p> 
<pre><code>ggplot(upc, aes(x = Abb, y = Change, fill = Region)) + 
  geom_col()</code></pre> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/bf/9f/Udu8D9jI_o.png"></p> 
<p></p> 
<p>图3-9：将分类变量映射到fill参数</p> 
<h2>讨论</h2> 
<p>条形图的默认颜色不是最吸引眼球的，因此，可能需要借助函数scale_fill_brewer()或scale_fill_manual()重新设定图形颜色。这里我们调用后者。我们通过设置colour = "black"将条形的边框线设定为黑色（见图3-10）。注意：颜色的映射设定是在aes()内部完成的，而颜色的设定是在aes()外部完成的：</p> 
<pre><code>ggplot(upc, aes(x = reorder(Abb, Change), y = Change, fill = Region)) + 
  geom_col(colour = "black") + 
  scale_fill_manual(values = c("#669933", "#FFCC66")) + 
  xlab("State")</code></pre> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/a5/81/YNkFbZH3_o.png"></p> 
<p></p> 
<p>图3-10：分类着色、具有黑色边框线的簇状条形图，条形根据人口变动百分比排序</p> 
<p>本例用reorder()函数将Abb的因子水平根据Change变量的值重新排序。在本例中，根据条形图的高度进行排序比按照字母顺序对分类变量排序更有意义。</p> 
<h2>另见</h2> 
<p>关于reorder()函数的更多用法，参见15.9节。</p> 
<p>关于图形着色的更多内容，参见第12章。</p> 
<h2>3.5　对正负条形图分别着色</h2> 
<h2>问题</h2> 
<p>如何根据条形对应的正负取值分别对其进行着色？</p> 
<h2>方法</h2> 
<p>下面以climate数据集的一个子集为例。首先，创建一个对取值正负性进行标示的变量pos：</p> 
<pre><code>library(gcookbook) # 加载gcookbook是为了使用climate数据集
library(dplyr)

climate_sub &lt;- climate %&gt;% 
  filter(Source == "Berkeley" &amp; Year &gt;= 1900) %&gt;% 
  mutate(pos = Anomaly10y &gt;= 0)

climate_sub
#&gt;       Source Year Anomaly1y Anomaly5y Anomaly10y Unc10y   pos
#&gt; 1   Berkeley 1900        NA        NA     -0.171  0.108 FALSE
#&gt; 2   Berkeley 1901        NA        NA     -0.162  0.109 FALSE
#&gt; 3   Berkeley 1902        NA        NA     -0.177  0.108 FALSE
#&gt;  ...&lt;99 more rows&gt;...
#&gt; 103 Berkeley 2002        NA        NA      0.856  0.028  TRUE
#&gt; 104 Berkeley 2003        NA        NA      0.869  0.028  TRUE
#&gt; 105 Berkeley 2004        NA        NA      0.884  0.029  TRUE</code></pre> 
<p>上述过程准备完毕后，将pos映射到填充色参数（fill）并绘制条形图（见图3-11）。注意：这里条形图的参数设定为position = "identity"，可以避免系统因对负值绘制堆积条形而发出的警告消息。</p> 
<pre><code>ggplot(climate_sub, aes(x = Year, y = Anomaly10y, fill = pos)) +
  geom_col(position = "identity")</code></pre> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/c4/6a/0I4g08eT_o.png"></p> 
<p></p> 
<p>图3-11：对正负取值的条形分别着色</p> 
<h2>讨论</h2> 
<p>上面的绘图过程存在一些问题。首先，图形着色效果可能跟我们想要的相反：蓝色是冷色，通常对应于负值；红色是暖色，通常对应于正值。其次，图例显得多余且扰乱视觉。</p> 
<p>我们可以通过scale_fill_manual()参数对图形颜色进行调整，设定参数guide = FALSE可以删除图例，如图3-12所示。同时，我们通过设定边框颜色（colour）和边框线宽度（size）为图形填加了一个细黑色边框。其中，边框线宽度（size）是用来控制边框线宽度的参数（单位是毫米）：</p> 
<pre><code>ggplot(climate_sub, aes(x = Year, y = Anomaly10y, fill = pos)) + 
  geom_col(position = "identity", colour = "black", size = 0.25) + 
  scale_fill_manual(values = c("#CCEEFF", "#FFDDDD"), guide = FALSE)</code></pre> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/b9/5b/yyzjUZu0_o.png"></p> 
<p></p> 
<p>图3-12：重新设定颜色并移除了图例的条形图</p> 
<h2>另见</h2> 
<p>要更改所用的颜色，参见12.4节和12.5节。</p> 
<p>要隐藏图例，参见10.1节。</p> 
<h2>3.6　调整条形宽度和条形间距</h2> 
<h2>问题</h2> 
<p>如何调整条形图的条形宽度和条形间距？</p> 
<h2>方法</h2> 
<p>通过设定geom_bar()函数的参数width可以使条形变得更宽或者更窄。该参数的默认值为0.9，更大的值将使绘制的条形更宽，反之则更窄（见图3-13）。</p> 
<p>例如，标准宽度的条形图如下：</p> 
<p> </p> 
<pre><code>library(gcookbook) # 加载gcookbook是为了使用pg_mean数据集

ggplot(pg_mean, aes(x = group, y = weight)) + 
  geom_col()</code></pre> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/8b/2a/Dz0n9qN9_o.png"></p> 
<p></p> 
<p>图3-13：不同条形宽度的条形图</p> 
<p>窄些的条形图如下：</p> 
<pre><code>ggplot(pg_mean, aes(x = group, y = weight)) + 
  geom_col(width = 0.5)</code></pre> 
<p>宽些的条形图（条形图的最大宽度为1）如下：</p> 
<pre><code>ggplot(pg_mean, aes(x = group, y = weight)) + 
  geom_col(width = 1)</code></pre> 
<p>簇状条形图默认组内的条形间距为0。如果希望增加组内条形的间距，则可以将width设定得小一些，并令position_dodge的取值大于width（见图3-14）。</p> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/eb/d5/TEZVsVks_o.png"></p> 
<p></p> 
<p>图3-14：条形更窄的簇状条形图（左图）；具有条形间距的簇状条形图（右图）</p> 
<p>要得到更窄的簇状条形图，可运行：</p> 
<pre><code>ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) + 
  geom_col(width = 0.5, position = "dodge")</code></pre> 
<p>要添加条形间距，可运行：</p> 
<pre><code>ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) + 
  geom_col(width = 0.5, position = position_dodge(0.7))</code></pre> 
<p>左图的绘图命令中用到了参数position = "dodge"，右图的绘图命令中用到了参数position = position_dodge()。这是因为position = "dodge"是参数默认为0.9的position = position_dodge()的简写。当我们需要单独指定该参数的时候，必须输入完整的格式。</p> 
<h2>讨论</h2> 
<p>width参数的默认值是0.9，position_dodge()函数中width参数的默认值也是0.9。更确切地说，position_dodge()函数中width参数的默认值为NULL，和geom_bar()函数中的width参数的取值是一样的。</p> 
<p>下面的4条命令是等价的：</p> 
<pre><code>geom_bar(position = "dodge")
geom_bar(width = 0.9, position = position_dodge())
geom_bar(position = position_dodge(0.9))
geom_bar(width = 0.9, position = position_dodge(width = 0.9))</code></pre> 
<p>条形图中，条形中心对应的<em>x</em>轴坐标分别是1、2、3等，但通常我们用不上这些数值。当用户运行命令geom_bar(width = 0.9)时，每组条形将在<em>x</em>轴上占据0.9个单位宽度。运行命令position_dodge(width = 0.9)时，ggplot2会自动调整条形位置，以使每个条形的中心恰好位于当每组条形宽度为0.9，且组内条形紧贴在一起时的位置，如图3-15所示。图中左右两部分的条形间距都为0.9，只是左图对应于0.9的条形宽度，右图对应于0.2的条形宽度。虽然左右两部分对应的条形宽度不同，但两图的条形中心是保持一致的。</p> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/f7/ff/BkAnmlfa_o.png"></p> 
<p></p> 
<p>图3-15：条形间距均为0.9，条形宽度分别为0.9（左图）和0.2（右图）的簇状条形图</p> 
<p>如果做整幅图形的伸缩，那么条形图也会依照相应的比例进行伸缩。要了解图形是怎样变化的，只需改变图形所在窗口的大小，然后观察图形的变化即可。关于在输出图形文件时控制图片大小的更多内容，参见第14章。</p> 
<p>本文摘自：《<strong>R数据可视化手册 第2版</strong>》</p> 
<p><img alt="R数据可视化：如何绘制条形图？" src="https://images2.imgbox.com/f6/d8/SjP5NZEh_o.png"></p> 
<p></p> 
<p>[美] 温斯顿·常（Winston Chang） 著，王佳，林枫，王祎帆，张晔 译</p> 
<p>R语言数据可视化经典书籍全新升级，第2版中的大部分技巧使用的是新版的ggplot2包，精选快速绘制高质量图形的150多个技巧，全彩印刷。</p> 
<p>1.R语言数据可视化经典书籍全新升级，第2版中的大部分技巧使用的是新版的ggplot2包，这是R中非常强大且灵活的绘图工具。<br><br> 2.本书提供了150多个技巧，借助这些技巧，科学家、工程师、程序员和数据分析师无须梳理出R绘图系统的全部细节就可以快速绘制出高质量的图形。每个技巧解决一个特定的问题，读者可以将这些技巧应用到自己的项目中。<br><br> 3.书中还包含图可视化设计的扩展内容。读者只要对R语言有基本的了解，就可以开始使用这本简单易用的参考书。<br> ■ 用R中的默认图形来快速探索数据。<br> ■ 绘制各种条形图、折线图和散点图。<br> ■ 用直方图、密度曲线、箱形图和其他图形来描述数据分布。<br> ■ 提供注解来帮助读图者理解数据。<br> ■ 控制图形的整体外观。<br> ■ 探索配色的选择。<br> ■ 绘制网络图、热图和三维散点图。<br> ■ 用tidyverse中的包对数据塑形。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c00f4738dcb2b83e55043425869f381/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nacos服务的注册与发现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/52aee3f6567fa8019be24732fa7ea70f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">50 天学习 50 个项目 - HTML/CSS and JavaScript</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>