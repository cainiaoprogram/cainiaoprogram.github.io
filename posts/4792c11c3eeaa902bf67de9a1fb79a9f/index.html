<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详讲js中的模块和导入导出 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="详讲js中的模块和导入导出" />
<meta property="og:description" content="目录
模块
对于浏览器：
模块核心功能
始终使用 “use strict”
模块级作用域
模块代码仅在第一次导入时被解析
import.meta
在一个模块中，“this” 是 undefined
浏览器特定功能
模块脚本是延迟的,常规脚本是立即进行的
Async 适用于内联脚本（inline script）
外部脚本
不允许裸模块（“bare” module）
兼容性，“nomodule”
构建工具
导入导出
导出 export
导入 import *
Export default
重新导出
重新导出默认导出
动态导入
import() 表达式
模块 模块:一个模块（module）就是一个文件。一个脚本就是一个模块
模块可以相互加载，并可以使用特殊的指令 export 和 import 来交换功能，从另一个模块调用一个模块的函数：
export 关键字标记了可以从当前模块外部访问的变量和函数。import 关键字允许从其他模块导入功能。 对于浏览器： 由于模块支持特殊的关键字和功能，因此我们必须通过使用 &lt;script type=&#34;module&#34;&gt; 特性（attribute）来告诉浏览器，此脚本应该被当作模块（module）来对待。
&lt;!doctype html&gt; &lt;script type=&#34;module&#34;&gt; import {sayHi} from &#39;./say.js&#39;; document.body.innerHTML = sayHi(&#39;John&#39;); &lt;/script&gt; 浏览器会自动获取并解析（evaluate）导入的模块（如果需要，还可以分析该模块的导入），然后运行该脚本。模块只通过 HTTP(s) 工作，而非本地 如果你尝试通过 file:// 协议在本地打开一个网页，你会发现 import/export 指令不起作用。你可以使用本地 Web 服务器，例如 static-server，或者使用编辑器的“实时服务器”功能，例如 VS Code 的 Live Server Extension 来测试模块。 模块核心功能 始终使用 “use strict” 模块始终在严格模式下运行。例如，对一个未声明的变量赋值将产生错误（译注：在浏览器控制台可以看到 error 信息） &lt;script type=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4792c11c3eeaa902bf67de9a1fb79a9f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-21T14:42:34+08:00" />
<meta property="article:modified_time" content="2023-08-21T14:42:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详讲js中的模块和导入导出</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="lEHUH-toc" style="margin-left:0px;"><a href="#lEHUH" rel="nofollow">模块</a></p> 
<p id="JQjkY-toc" style="margin-left:120px;"><a href="#JQjkY" rel="nofollow">对于浏览器：</a></p> 
<p id="HhShZ-toc" style="margin-left:40px;"><a href="#HhShZ" rel="nofollow">模块核心功能</a></p> 
<p id="GN7O6-toc" style="margin-left:120px;"><a href="#GN7O6" rel="nofollow">始终使用 “use strict”</a></p> 
<p id="UUMWi-toc" style="margin-left:120px;"><a href="#UUMWi" rel="nofollow">模块级作用域</a></p> 
<p id="WcqOO-toc" style="margin-left:120px;"><a href="#WcqOO" rel="nofollow">模块代码仅在第一次导入时被解析</a></p> 
<p id="r0vW7-toc" style="margin-left:120px;"><a href="#r0vW7" rel="nofollow">import.meta</a></p> 
<p id="u2Apv-toc" style="margin-left:120px;"><a href="#u2Apv" rel="nofollow">在一个模块中，“this” 是 undefined</a></p> 
<p id="IsOkg-toc" style="margin-left:40px;"><a href="#IsOkg" rel="nofollow">浏览器特定功能</a></p> 
<p id="MShK2-toc" style="margin-left:120px;"><a href="#MShK2" rel="nofollow">模块脚本是延迟的,常规脚本是立即进行的</a></p> 
<p id="Fncw0-toc" style="margin-left:120px;"><a href="#Fncw0" rel="nofollow">Async 适用于内联脚本（inline script）</a></p> 
<p id="Xkvtr-toc" style="margin-left:120px;"><a href="#Xkvtr" rel="nofollow">外部脚本</a></p> 
<p id="SUD6e-toc" style="margin-left:120px;"><a href="#SUD6e" rel="nofollow">不允许裸模块（“bare” module）</a></p> 
<p id="kx6uv-toc" style="margin-left:120px;"><a href="#kx6uv" rel="nofollow">兼容性，“nomodule”</a></p> 
<p id="HB6vS-toc" style="margin-left:40px;"><a href="#HB6vS" rel="nofollow">构建工具</a></p> 
<p id="FeETV-toc" style="margin-left:0px;"><a href="#FeETV" rel="nofollow">导入导出</a></p> 
<p id="CqOfX-toc" style="margin-left:80px;"><a href="#CqOfX" rel="nofollow">导出 export</a></p> 
<p id="OvAdK-toc" style="margin-left:80px;"><a href="#OvAdK" rel="nofollow">导入 import *</a></p> 
<p id="MvL8E-toc" style="margin-left:80px;"><a href="#MvL8E" rel="nofollow">Export default</a></p> 
<p id="HqMtO-toc" style="margin-left:80px;"><a href="#HqMtO" rel="nofollow">重新导出</a></p> 
<p id="nPbUP-toc" style="margin-left:80px;"><a href="#nPbUP" rel="nofollow">重新导出默认导出</a></p> 
<p id="N7IS1-toc" style="margin-left:0px;"><a href="#N7IS1" rel="nofollow">动态导入</a></p> 
<p id="ag3E9-toc" style="margin-left:80px;"><a href="#ag3E9" rel="nofollow">import() 表达式</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>模块</h2> 
<p id="ue71e00e6">模块:一个模块（module）就是一个文件。一个脚本就是一个模块</p> 
<p id="u9a3250ba">模块可以相互加载，并可以使用特殊的指令 export 和 import 来交换功能，从另一个模块调用一个模块的函数：</p> 
<ul><li id="ue571d60e">export 关键字标记了可以从当前模块外部访问的变量和函数。</li><li id="u6b12eb00">import 关键字允许从其他模块导入功能。</li></ul> 
<h5 id="JQjkY">对于浏览器：</h5> 
<p id="u62f28e76">由于模块支持特殊的关键字和功能，因此我们必须通过使用 &lt;script type="module"&gt; 特性（attribute）来告诉浏览器，此脚本应该被当作模块（module）来对待。</p> 
<pre id="jGG5g"><code>&lt;!doctype html&gt;
&lt;script type="module"&gt;
  import {sayHi} from './say.js';
  document.body.innerHTML = sayHi('John');
&lt;/script&gt;</code></pre> 
<ul><li id="u6e67e352">浏览器会自动获取并解析（evaluate）导入的模块（如果需要，还可以分析该模块的导入），然后运行该脚本。</li><li id="u32f8d9f8">模块只通过 HTTP(s) 工作，而非本地</li></ul> 
<ul><li> 
  <ul><li id="u1b92455b">如果你尝试通过 file:// 协议在本地打开一个网页，你会发现 import/export 指令不起作用。你可以使用本地 Web 服务器，例如 static-server，或者使用编辑器的“实时服务器”功能，例如 VS Code 的 Live Server Extension 来测试模块。</li></ul></li></ul> 
<p id="u7b771d91"></p> 
<p id="u7e15ada4"></p> 
<h3 id="HhShZ">模块核心功能</h3> 
<h5 id="GN7O6">始终使用 “use strict”</h5> 
<ul><li id="uaa51a8c8">模块始终在严格模式下运行。例如，对一个未声明的变量赋值将产生错误（译注：在浏览器控制台可以看到 error 信息）</li></ul> 
<pre id="QGEv2"><code>&lt;script type="module"&gt;
  a = 5; // error
&lt;/script&gt;</code></pre> 
<p id="ud5e69322"></p> 
<h5 id="UUMWi">模块级作用域</h5> 
<p id="u2de7dfab">每个模块都有自己的顶级作用域（top-level scope）。换句话说，一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。</p> 
<ul><li id="u29c61289">同一页面上的两个脚本，都是 type="module"。它们看不到彼此的顶级变量：</li></ul> 
<pre id="O69Ob"><code>&lt;script type="module"&gt;
  // 变量仅在这个 module script 内可见
  let user = "John";
&lt;/script&gt;

&lt;script type="module"&gt;
  console.log(user); // Error: user is not defined
&lt;/script&gt;</code></pre> 
<p id="u98418205"><strong>注意：在浏览器中，我们可以通过将变量显式地分配给 window 的一个属性，使其成为窗口级别的全局变量。这样所有脚本都会看到它，无论脚本是否带有 type="module"，请避免这样做。</strong></p> 
<p id="u2b7119fe"></p> 
<h5 id="WcqOO">模块代码仅在第一次导入时被解析</h5> 
<p id="ub70681ac">如果同一个模块被导入到多个其他位置，那么它的代码只会执行一次，即在第一次被导入时。然后将其导出（export）的内容提供给进一步的导入（importer）</p> 
<ul><li id="u0665ef96">顶层模块代码应该用于初始化，创建模块特定的内部数据结构。如果我们需要多次调用某些东西 —— 我们应该将其以函数的形式导出</li></ul> 
<ul><li> 
  <ul><li id="u0266edef">这种行为实际上非常方便，因为它允许我们“配置”模块。</li></ul></li></ul> 
<pre id="LVmj0"><code>// 📁 admin.js
export let admin = {
  name: "John"
};</code></pre> 
<pre id="pQHRs"><code>// 📁 1.js
import { admin } from './admin.js';
admin.name = "Pete";
// 📁 2.js
import { admin } from './admin.js';
alert(admin.name); // Pete

// 1.js 和 2.js 引用的是同一个 admin 对象
// 在 1.js 中对对象做的更改，在 2.js 中也是可见的</code></pre> 
<h5 id="r0vW7">import.meta</h5> 
<p id="u8d72afa9">import.meta 对象包含关于当前模块的信息。它的内容取决于其所在的环境。在浏览器环境中，它包含当前脚本的 URL，或者如果它是在 HTML 中的话，则包含当前页面的 URL。</p> 
<pre id="jJQXg"><code>&lt;script type="module"&gt;
  console.log(import.meta.url); // 脚本的 URL
  // 对于内联脚本来说，则是当前 HTML 页面的 URL
&lt;/script&gt;</code></pre> 
<p id="u17c079b0"></p> 
<p id="uc124ef5f"></p> 
<p id="u5136dd3d"></p> 
<h5 id="u2Apv">在一个模块中，“this” 是 undefined</h5> 
<p id="u5542a0b7">在一个模块中，顶级 this 是 undefined。</p> 
<pre id="PYNRL"><code>&lt;script&gt;
  alert(this); // window
&lt;/script&gt;

&lt;script type="module"&gt;
  alert(this); // undefined
&lt;/script&gt;</code></pre> 
<h3 id="IsOkg">浏览器特定功能</h3> 
<h5 id="MShK2">模块脚本是延迟的,常规脚本是立即进行的</h5> 
<ul><li id="u3cf8f609">模块脚本 总是 被延迟的，与 defer 特性（在 脚本：async，defer 一章中描述的）对外部脚本和内联脚本（inline script）的影响相同。</li></ul> 
<p id="uc896448c">也就是说：</p> 
<ul><li id="u16711491">下载外部模块脚本 &lt;script type="module" src="..."&gt; 不会阻塞 HTML 的处理，它们会与其他资源并行加载。</li><li id="u2f620639">模块脚本会等到 HTML 文档完全准备就绪（即使它们很小并且比 HTML 加载速度更快），然后才会运行。</li><li id="u1cd4812a">保持脚本的相对顺序：在文档中排在前面的脚本先执行。</li></ul> 
<p id="ua4322056">它的一个副作用是，模块脚本总是会“看到”已完全加载的 HTML 页面，包括在它们下方的 HTML 元素。</p> 
<pre id="HlcBb"><code>&lt;script type="module"&gt;
  alert(typeof button); // object：脚本可以“看见”下面的 button
  // 因为模块是被延迟的（deferred，所以模块脚本会在整个页面加载完成后才运行
&lt;/script&gt;
//相较于下面这个常规脚本：
&lt;script&gt;
  alert(typeof button); // button 为 undefined，脚本看不到下面的元素
  // 常规脚本会立即运行，常规脚本的运行是在在处理页面的其余部分之前进行的
&lt;/script&gt;
&lt;button id="button"&gt;Button&lt;/button&gt;</code></pre> 
<ul><li id="u39ab8237">上面的第二个脚本实际上要先于前一个脚本运行！所以我们会先看到 undefined，然后才是 object</li><li id="u4761aec4">为了避免用户疑惑，可以放置加载指示器或者其他方式来解决这个问题</li></ul> 
<h5 id="Fncw0">Async 适用于内联脚本（inline script）</h5> 
<p id="u41ad6f1c">对于非模块脚本，async 特性（attribute）仅适用于外部脚本。异步脚本会在准备好后立即运行，独立于其他脚本或 HTML 文档。</p> 
<p id="u8fac8a9b">对于模块脚本，它也适用内联脚本。</p> 
<ul><li id="u2b1d79a3">下面的内联脚本具有 async 特性，因此它不会等待任何东西。</li></ul> 
<pre id="oUpFH"><code>&lt;!-- 所有依赖都获取完成（analytics.js）然后脚本开始运行 --&gt;
&lt;!-- 不会等待 HTML 文档或者其他 &lt;script&gt; 标签 --&gt;
&lt;script async type="module"&gt;
  import {counter} from './analytics.js';
  counter.count();
&lt;/script&gt;</code></pre> 
<h5 id="Xkvtr">外部脚本</h5> 
<p id="ud9d46902">具有 type="module" 的外部脚本（external script）在两个方面有所不同：</p> 
<ul><li id="u56602559">具有相同 src 的外部脚本仅运行一次：</li><li id="u3da6861d">从另一个源（例如另一个网站）获取的外部脚本需要 CORS header，换句话说，如果一个模块脚本是从另一个源获取的，则远程服务器必须提供表示允许获取的 header Access-Control-Allow-Origin。默认这样做可以确保更好的安全性。</li></ul> 
<pre id="vTcBR"><code>&lt;!-- another-site.com 必须提供 Access-Control-Allow-Origin --&gt;
&lt;!-- 否则，脚本将无法执行 --&gt;
&lt;script type="module" src="http://another-site.com/their.js"&gt;&lt;/script&gt;</code></pre> 
<h5 id="SUD6e">不允许裸模块（“bare” module）</h5> 
<p id="u5e83c088">在浏览器中，import 必须给出相对或绝对的 URL 路径。没有任何路径的模块被称为“裸（bare）”模块。在 import 中不允许这种模块。</p> 
<pre id="pPeVC"><code>import {sayHi} from 'sayHi'; // Error，“裸”模块
// 模块必须有一个路径，例如 './sayHi.js' 或者其他任何路径</code></pre> 
<p id="ue0596017">某些环境，像 Node.js 或者打包工具（bundle tool）允许没有任何路径的裸模块，因为它们有自己的查找模块的方法和钩子（hook）来对它们进行微调。但是浏览器尚不支持裸模块</p> 
<h5 id="kx6uv">兼容性，“nomodule”</h5> 
<p id="u2e75f968">旧时的浏览器不理解 type="module"。未知类型的脚本会被忽略。对此，我们可以使用 nomodule 特性来提供一个后备：</p> 
<pre id="H8zsN"><code>&lt;script type="module"&gt;
  alert("Runs in modern browsers");
&lt;/script&gt;

&lt;script nomodule&gt;
  alert("Modern browsers know both type=module and nomodule, so skip this")
  alert("Old browsers ignore script with unknown type=module, but execute this.");
&lt;/script&gt;</code></pre> 
<h3 id="HB6vS">构建工具</h3> 
<p id="u8b3d0591">在实际开发中，浏览器模块很少被以“原始”形式进行使用。通常，我们会使用一些特殊工具，例如 <a href="https://webpack.js.org/" rel="nofollow" title="Webpack">Webpack</a>，将它们打包在一起，然后部署到生产环境的服务器。</p> 
<p id="u55579888">使用打包工具的一个好处是 —— 它们可以更好地控制模块的解析方式，允许我们使用裸模块和更多的功能，例如 CSS/HTML 模块等。</p> 
<p id="ufd747079">构建工具做以下这些事儿：</p> 
<ol><li id="u08df4847">从一个打算放在 HTML 中的 &lt;script type="module"&gt; “主”模块开始。</li><li id="u9ab5d48a">分析它的依赖：它的导入，以及它的导入的导入等。</li><li id="uc4f96af4">使用所有模块构建一个文件（或者多个文件，这是可调的），并用打包函数（bundler function）替代原生的 import 调用，以使其正常工作。还支持像 HTML/CSS 模块等“特殊”的模块类型。</li><li id="u1a2f4791">在处理过程中，可能会应用其他转换和优化：</li></ol> 
<ul><li id="u71e31bce">删除无法访问的代码。</li><li id="ua47d4573">删除未使用的导出（“tree-shaking”）。</li><li id="u3b710050">删除特定于开发的像 console 和 debugger 这样的语句。</li><li id="ue55354f8">可以使用 Babel 将前沿的现代的 JavaScript 语法转换为具有类似功能的旧的 JavaScript 语法。</li><li id="ud31d0d2f">压缩生成的文件（删除空格，用短的名字替换变量等）。</li></ul> 
<p id="ud66fb823">如果我们使用打包工具，那么脚本会被打包进一个单一文件（或者几个文件），在这些脚本中的 import/export 语句会被替换成特殊的打包函数（bundler function）。因此，最终打包好的脚本中不包含任何 import/export，它也不需要 type="module"，我们可以将其放入常规的 &lt;script&gt;：</p> 
<pre id="LpKMR"><code>&lt;!-- 假设我们从诸如 Webpack 这类的打包工具中获得了 "bundle.js" 脚本 --&gt;
&lt;script src="bundle.js"&gt;&lt;/script&gt;</code></pre> 
<h2 id="FeETV">导入导出</h2> 
<h4 id="CqOfX">导出 export</h4> 
<ul><li id="u9ef160e7">导出 class/function 后没有分号</li></ul> 
<ul><li> 
  <ul><li id="u49036396">在类或者函数前的 export 不会让它们变成 函数表达式。尽管被导出了，但它仍然是一个函数声明</li></ul></li></ul> 
<pre id="uuJhw"><code>//声明导出
export const  a = 1

//声明导出分开
const  a = 1
const  b = 1
export {a ,b}

//导入另外命名为
export {a as a1, b as b1};
import {b1} from 'module';
b1()</code></pre> 
<h4 id="OvAdK">导入 import *</h4> 
<pre id="eaxTh"><code>import {xxx, xxx} from 'module';
xxx();
// 导入一个对象
import * as utils from 'module';
utils.xxx();

//import “as” 另命名为
import {xxx as bas} from 'module';
bas()</code></pre> 
<p id="u11660a47">明确列入的好处：</p> 
<ul><li id="u5617fee3">现代的构建工具（webpack 和其他工具）将模块打包到一起并对其进行优化，以加快加载速度并删除未使用的代码。</li><li id="uc5101f02">明确列出要导入的内容会使得名称较短：xxx() 而不是 utils.xxx()。</li><li id="u378722e6">导入的显式列表可以更好地概述代码结构：使用的内容和位置。它使得代码支持重构，并且重构起来更容易</li></ul> 
<h4 id="MvL8E">Export default</h4> 
<p id="u63882e55">在实际中，主要有两种模块。</p> 
<ul><li id="uf3795f3b">包含库或函数包的模块</li><li id="ud38a8884">声明单个实体的模块，例如模块 user.js 仅导出 class User</li></ul> 
<p id="u056987af">开发者倾向于使用第二种方式，以便每个“东西”都存在于它自己的模块中,模块提供了一个特殊的默认导出 export default 语法，以使“一个模块只做一件事”的方式看起来更好。</p> 
<ul><li id="u24d6af4c">import 命名的导出时需要花括号，而 import 默认的导出时不需要花括号</li></ul> 
<pre id="tUUzC"><code>//导出
export default class User { // 只需要添加 "default" 即可
  constructor(name) {
    this.name = name;
  }
}
//引入
import User from './user.js'; // 不需要花括号 {User}，只需要写成 User 即可
new User('John');

// contants.js 导出单个值，而不使用变量
export default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
//可以自定义命名
import common from  './contants'
import utils from  './contants'
console.log('common:', common)

// 没有函数名 同变量
export default function(user) { 
  alert(`Hello, ${user}!`);
}

//导出
const detail = ()=&gt;{
    return &lt;div&gt;detail&lt;/div&gt;
}
export default detail
import detail from './detail.js'; // 不需要花括号 {User}，只需要写成 User 即可</code></pre> 
<ul><li id="ub106b575">每个文件应该只有一个 export default：</li></ul> 
<h4 id="HqMtO">重新导出</h4> 
<p id="ud14e6f67">“重新导出（Re-export）”语法 export ... from ... 允许导入内容，并立即将其导出（可能是用的是其他的名字），比如：希望想要使用我们的包的人，应该只从“主文件” auth/index.js 导入</p> 
<ul><li id="uf1f6e3e7">“主文件”，auth/index.js 导出了我们希望在包中提供的所有功能。</li><li id="u902f71fb">其他使用我们包的开发者不应该干预其内部结构，不应该搜索我们包的文件夹中的文件。我们只在 auth/index.js 中导出必要的部分，并保持其他内容“不可见”</li></ul> 
<pre id="AcXio"><code>// 📁 auth/index.js
// 导入 login/logout 然后立即导出它们
import {login, logout} from './helpers.js';
export {login, logout};
// 将默认导出导入为 User，然后导出它
import User from './user.js';
export {User};
...</code></pre> 
<pre><code class="language-vb">
<code>// 📁 auth/index.js
// 重新导出 login/logout
export {login, logout} from './helpers.js';

// 将默认导出重新导出为 User
export {default as User} from './user.js';
...</code></code></pre> 
<pre id="pSucy"><code>import {login} from "auth/index.js"</code></pre> 
<p id="u885df162"><strong>区别：</strong>export ... from 与 import/export 相比的显着区别是重新导出的模块在当前文件中不可用</p> 
<h4 id="nPbUP">重新导出默认导出</h4> 
<p id="u9c2eb4de">重新导出时，默认导出需要单独处理。</p> 
<ul><li id="u9f251e74">export User from './user.js' 无效。这会导致一个语法错误。</li></ul> 
<ul><li> 
  <ul><li id="u4820682c">要重新导出默认导出，我们必须明确写出 export {default as User}，就像上面的例子中那样。</li></ul></li></ul> 
<ul><li id="u7c09b6a0">export * from './user.js' 重新导出只导出了命名的导出，但是忽略了默认的导出。</li></ul> 
<pre id="SocYP"><code>export * from './user.js'; // 重新导出命名的导出
export {default} from './user.js'; // 重新导出默认的导出</code></pre> 
<p id="ubcbe640e"></p> 
<h2 id="N7IS1">动态导入</h2> 
<p id="u1a040529">静态导入的限制：</p> 
<ul><li id="uecfb2ae0">不能动态生成inport的任何参数</li><li id="uf12b5f11">模块路径必须是原始类型字符串，不能是函数调用</li><li id="uc9ae39d3">无法根据条件或者在运行时导入</li></ul> 
<h4 id="ag3E9">import() 表达式</h4> 
<p id="ubc6057d9">import(module) 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。我们可以在代码中的任意位置调用这个表达式</p> 
<ul><li id="ub70794b4">动态导入在常规脚本中工作时，它们不需要 script type="module".</li><li id="u11bb56d1">不能将 import 复制到一个变量中，或者对其使用 call/apply。因为它不是一个函数</li></ul> 
<ul><li> 
  <ul><li id="u33c65503">尽管 import() 看起来像一个函数调用，但它只是一种特殊语法，只是恰好使用了括号（类似于 super()）。</li></ul></li></ul> 
<pre id="A9EV7"><code>let modulePath = prompt("Which module to load?");
import(modulePath)
  .then(obj =&gt; &lt;module object&gt;)
  .catch(err =&gt; &lt;loading error, e.g. if no such module&gt;)


//在异步函数中，我们可以使用 
let module = await import(modulePath)</code></pre> 
<pre id="POFQZ"><code>//contants
export default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

export  const  a = 1;

// index
const  {a} = await import('./contants')
const  {a,...rest} = await import('./contants')

const common = await import('./contants')
console.log('common:', common)</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0c3382546c359f124e0720fd4ba62a44/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用python实现京东商品详细信息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/734b66558886f94e017ea1801095a982/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">嵌入式教程_数字信号处理：2-18 模数转换（AD）实验（采集波形）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>