<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Data JPA 学习 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Data JPA 学习" />
<meta property="og:description" content="Spring Data JPA是个非常强大的ORM持久化解决方案，免去了mybatis或spring jdbcTemplate的开发人员编写脚本的无趣工作。
Spring Data JPA官方文档
https://docs.spring.io/spring-data/jpa/docs/2.0.9.RELEASE/reference/html/
目录
一、首先了解下Spring Data JPA 的继承结构
二、首先了解下Spring Data JPA 的运行原理（简单说下）
三、Repository接口
方法名称命名规则查询
@Query注解查询
@Query注解完成修改
四、CrudRepository接口
五、PagingAndSortingRepository接口
六、JpaRepository接口
七、JpaSpecificationExecutor接口
八、自定义Repository接口
一、首先了解下Spring Data JPA 的继承结构 Repository:标识接口
CrudRepository:用于CRUD操作（修改的方法和添加一样都是save，至于什么时候是修改，什么时候是添加后面会说）
PagingAndSortingRepository:用于分页和排序操作
JpaRepository:将其他接口的方法的返回值做适配处理
除了图中的内容，还必须掌握JpaSpecificationExecutor,该接口不在图中的关系中，起作用是多条件查询且支持分页和查询。
如果说有什么关系，请看下图
二、首先了解下Spring Data JPA 的运行原理（简单说下） 我们知道使用Spring Data JPA是不需要接口实现类的，但我们在测试类中自动注入的UsersDao到底是什么呢？
UsersDao接口
package com.zxw.dao; import com.zxw.pojo.Users; import org.springframework.data.jpa.repository.JpaRepository; public interface UsersDao extends JpaRepository&lt;Users,Integer&gt; { } 测试类
package com.zxw.test; import com.zxw.dao.UsersDao; import com.zxw.pojo.Users; import org.junit.Test; import org.junit.runner.RunWith; import org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6ac71c78c6afb831c9890d32db2d25e9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-13T20:18:41+08:00" />
<meta property="article:modified_time" content="2019-11-13T20:18:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Data JPA 学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>Spring Data JPA是个非常强大的ORM持久化解决方案，免去了mybatis或spring jdbcTemplate的开发人员编写脚本的无趣工作。</p> 
 <p>Spring Data JPA官方文档</p> 
 <p><a href="https://docs.spring.io/spring-data/jpa/docs/2.0.9.RELEASE/reference/html/" rel="nofollow">https://docs.spring.io/spring-data/jpa/docs/2.0.9.RELEASE/reference/html/</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"> </p> 
<p id="%E4%B8%80%E3%80%81%E9%A6%96%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%8BSpring%20Data%20JPA%20%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E9%A6%96%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%8BSpring%20Data%20JPA%20%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84" rel="nofollow">一、首先了解下Spring Data JPA 的继承结构</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%A6%96%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%8BSpring%20Data%20JPA%20%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E9%A6%96%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%8BSpring%20Data%20JPA%20%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B%EF%BC%89" rel="nofollow">二、首先了解下Spring Data JPA 的运行原理（简单说下）</a></p> 
<p id="%E4%B8%89%E3%80%81Repository%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81Repository%E6%8E%A5%E5%8F%A3" rel="nofollow">三、Repository接口</a></p> 
<p id="%C2%A0%20%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%9F%A5%E8%AF%A2-toc" style="margin-left:80px;"><a href="#%C2%A0%20%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%9F%A5%E8%AF%A2" rel="nofollow">  方法名称命名规则查询</a></p> 
<p id="%C2%A0%20%C2%A0%40Query%E6%B3%A8%E8%A7%A3%E6%9F%A5%E8%AF%A2-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%40Query%E6%B3%A8%E8%A7%A3%E6%9F%A5%E8%AF%A2" rel="nofollow">   @Query注解查询</a></p> 
<p id="%C2%A0%20%C2%A0%40Query%E6%B3%A8%E8%A7%A3%E5%AE%8C%E6%88%90%E4%BF%AE%E6%94%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%40Query%E6%B3%A8%E8%A7%A3%E5%AE%8C%E6%88%90%E4%BF%AE%E6%94%B9" rel="nofollow">   @Query注解完成修改</a></p> 
<p id="%E5%9B%9B%E3%80%81CrudRepository%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81CrudRepository%E6%8E%A5%E5%8F%A3" rel="nofollow">四、CrudRepository接口</a></p> 
<p id="%E4%BA%94%E3%80%81PagingAndSortingRepository%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81PagingAndSortingRepository%E6%8E%A5%E5%8F%A3" rel="nofollow">五、PagingAndSortingRepository接口</a></p> 
<p id="%E5%85%AD%E3%80%81JpaRepository%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81JpaRepository%E6%8E%A5%E5%8F%A3" rel="nofollow">六、JpaRepository接口</a></p> 
<p id="%E4%B8%83%E3%80%81JpaSpecificationExecutor%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E4%B8%83%E3%80%81JpaSpecificationExecutor%E6%8E%A5%E5%8F%A3" rel="nofollow">七、JpaSpecificationExecutor接口</a></p> 
<p style="margin-left:40px;"><a href="#%E5%85%AB%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89Repository%E6%8E%A5%E5%8F%A3" rel="nofollow">八、自定义Repository接口</a></p> 
<hr id="hr-toc"> 
<h3 id="%E4%B8%80%E3%80%81%E9%A6%96%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%8BSpring%20Data%20JPA%20%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84">一、首先了解下Spring Data JPA 的继承结构</h3> 
<p>Repository:标识接口</p> 
<p>CrudRepository:用于CRUD操作（修改的方法和添加一样都是save，至于什么时候是修改，什么时候是添加后面会说）</p> 
<p>PagingAndSortingRepository:用于分页和排序操作</p> 
<p>JpaRepository:将其他接口的方法的返回值做适配处理</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/ec/32/oV8vcLi0_o.jpg"></p> 
<p>除了图中的内容，还必须掌握JpaSpecificationExecutor,该接口不在图中的关系中，起作用是多条件查询且支持分页和查询。</p> 
<p>如果说有什么关系，请看下图</p> 
<p><img alt="" class="has" height="440" src="https://images2.imgbox.com/1d/1c/q8NqXgrB_o.png" width="751"></p> 
<h3 id="%E4%BA%8C%E3%80%81%E9%A6%96%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%8BSpring%20Data%20JPA%20%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B%EF%BC%89">二、首先了解下Spring Data JPA 的运行原理（简单说下）</h3> 
<p>我们知道使用Spring Data JPA是不需要接口实现类的，但我们在测试类中自动注入的UsersDao到底是什么呢？</p> 
<p>UsersDao接口</p> 
<pre class="has"><code class="language-java">package com.zxw.dao;

import com.zxw.pojo.Users;
import org.springframework.data.jpa.repository.JpaRepository;


public interface UsersDao extends JpaRepository&lt;Users,Integer&gt; {

}
</code></pre> 
<p>测试类</p> 
<pre class="has"><code class="language-java">package com.zxw.test;

import com.zxw.dao.UsersDao;
import com.zxw.pojo.Users;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;


@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class UsersDaoImplTest {

    @Autowired
    private UsersDao usersDao;

    @Test
    public void test() {
        System.out.println(usersDao);
        System.out.println(usersDao.getClass());
    }

}
</code></pre> 
<p>我们通过简单输出看下UserDao到底是什么</p> 
<p><img alt="" class="has" height="59" src="https://images2.imgbox.com/a6/3f/a3vFkUvU_o.png" width="796"></p> 
<p>从结果可以看出usersDao的类型是个代理类，usersDao是个SimpleJpaRepository对象。</p> 
<p>我们看看SimpleJpaRepository是何方神圣？</p> 
<p><img alt="" class="has" height="291" src="https://images2.imgbox.com/89/32/TLuxZAnJ_o.png" width="1200"></p> 
<p>可以看到SimpleJpaRepository实现了JpaRepository,JpaSpecificationExecutor接口，再看看有什么方法</p> 
<p><img alt="" class="has" height="391" src="https://images2.imgbox.com/98/b2/fWWYYkAf_o.png" width="1185"></p> 
<p>这里只截取一部分，可以看出SimpleJpaRepository实现了相应的CURD操作。</p> 
<p>其实我们自己也可以产生个代理对象：</p> 
<pre class="has"><code class="language-java">@PersistenceContext(name="entityManagerFactory") 
    private EntityManager em; 
    @Test 
    public void test1(){ 
       
        JpaRepositoryFactory factory = new JpaRepositoryFactory(em); 
        //getRepository(UsersDao.class);可以帮助我们为接口生成实现类。而这个实现类是 SimpleJpaRepository 的对象 
        // 要求：该接口必须要是继承 Repository 接口 
        UsersDao ud = factory.getRepository(UsersDao.class); 
        System.out.println(ud); 
        System.out.println(ud.getClass()); 
        
    }</code></pre> 
<h3 id="%E4%B8%89%E3%80%81Repository%E6%8E%A5%E5%8F%A3">三、Repository接口</h3> 
<p>Repository接口是Spring Data JPA 中提供的所有接口的顶层接口</p> 
<p>Repository提供了两种查询方式：</p> 
<ul><li>基于方法名称命名规则查询</li><li>基于@Query注解查询</li></ul> 
<h4 id="%C2%A0%20%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%9F%A5%E8%AF%A2">  方法名称命名规则查询</h4> 
<div> 
 <span style="color:#000000;">   规则：</span> 
 <span style="color:#000000;">findBy(</span> 
 <span style="color:#000000;">关键字</span> 
 <span style="color:#000000;">)+</span> 
 <span style="color:#000000;">属性名称</span> 
 <span style="color:#000000;">(</span> 
 <span style="color:#000000;">属性名称的首字母大写</span> 
 <span style="color:#000000;">)+</span> 
 <span style="color:#000000;">查询条件</span> 
 <span style="color:#000000;">(</span> 
 <span style="color:#000000;">首字母大写</span> 
 <span style="color:#000000;">)</span> 
</div> 
<div>
    
</div> 
<div> 
 <img alt="" class="has" height="494" src="https://images2.imgbox.com/65/56/f3OC5vCn_o.png" width="967"> 
</div> 
<div> 
 <img alt="" class="has" height="585" src="https://images2.imgbox.com/84/04/hLFuxs7S_o.png" width="973"> 
</div> 
<div> 
 <img alt="" class="has" height="178" src="https://images2.imgbox.com/81/3b/q3sv0m9o_o.png" width="973"> 
</div> 
<div>
    
</div> 
<div> 
 <pre class="has"><code class="language-java">public interface UsersDao extends Repository&lt;Users,Integer&gt; {
    //findBy关键字   Username属性名称   Is查询条件
    List&lt;Users&gt; findByUsernameIs(String username);
 
}
</code></pre> 
 <p> </p> 
 <h4 id="%C2%A0%20%C2%A0%40Query%E6%B3%A8%E8%A7%A3%E6%9F%A5%E8%AF%A2">   @Query注解查询</h4> 
 <ul><li>     通过JPQL语句查询</li></ul> 
 <p><span style="color:#000000;">            JPQL</span><span style="color:#000000;">：通过 </span><span style="color:#000000;">Hibernate </span><span style="color:#000000;">的 </span><span style="color:#000000;">HQL </span><span style="color:#000000;">演变过来的。他和 </span><span style="color:#000000;">HQL </span><span style="color:#000000;">语法及其相似。</span></p> 
 <pre class="has"><code class="language-java">public interface UsersDao extends Repository&lt;Users,Integer&gt; {

    //JPQL
    @Query("from Users where username like ?")
    List&lt;Users&gt; selByLikeName(String username);

    @Query("from Users where userage &gt; ?")
    List&lt;Users&gt; selByAge(Integer userage);

    @Query("from Users where username = ? and userage &lt;= ?")
    List&lt;Users&gt; selNameAndAge(String username,Integer userage);

}
</code></pre> 
 <ul><li>     通过SQL语句查询</li></ul> 
 <p>            （前面没有写nativeQuery是因为我们所写的语句需要变成可以查询的sql语句，这里我们写的本身就是sql语句所以要开启nativeQuery）</p> 
</div> 
<div> 
 <pre class="has"><code class="language-java">public interface UsersDao extends Repository&lt;Users,Integer&gt; {

    //SQL
    //nativeQuery:默认的是 false.表示不开启 sql 查询。是否对 value 中的语句 做转义。

    @Query(value = "select * from t_users where username like ?",nativeQuery = true)
    List&lt;Users&gt; selByLikeNameSQL(String username);

    @Query(value = "select * from t_users where userage &gt; ?",nativeQuery = true)
    List&lt;Users&gt; selByAgeSQL(Integer userage);

    @Query(value = "select * from t_users where username = ? and userage &lt;=?",nativeQuery = true)
    List&lt;Users&gt; selNameAndAgeSQL(String username,Integer userage);
}
</code></pre> 
 <h4 id="%C2%A0%20%C2%A0%40Query%E6%B3%A8%E8%A7%A3%E5%AE%8C%E6%88%90%E4%BF%AE%E6%94%B9">   @Query注解完成修改</h4> 
 <p>     （一定要写@Modifying）</p> 
 <pre class="has"><code class="language-java">public interface UsersDao extends Repository&lt;Users,Integer&gt; {

    //修改
    @Query("update Users set userage = ? where userid = ?")
    @Modifying //代表这是更新
    void updUserageById(Integer userage,Integer userid);
}
</code></pre> 
 <h3 id="%E5%9B%9B%E3%80%81CrudRepository%E6%8E%A5%E5%8F%A3">四、CrudRepository接口</h3> 
 <pre class="has"><code class="language-java">package com.zxw.dao;

import com.zxw.pojo.Users;

import org.springframework.data.repository.CrudRepository;


public interface UsersDao extends CrudRepository&lt;Users,Integer&gt; {

}
</code></pre> 
 <p>  测试代码</p> 
 <pre class="has"><code class="language-java">package com.zxw.test;

import com.zxw.dao.UsersDao;
import com.zxw.pojo.Users;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.annotation.Rollback;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class UsersDaoImplTest {
    @Autowired
    private UsersDao usersDao;

    /**
     * 插入单条数据
     */
    @Test
    public void save(){
        Users users=new Users();
        users.setUsername("金泰妍");
        users.setUserage(20);
        this.usersDao.save(users);
    }
    /**
     * 插入多条数据
     */
    @Test
    public void saveMany(){
        Users users1=new Users();
        users1.setUsername("林允儿");
        users1.setUserage(30);

        Users users2=new Users();
        users2.setUsername("徐珠贤");
        users2.setUserage(25);

        List&lt;Users&gt; list=new ArrayList&lt;&gt;();
        list.add(users1);
        list.add(users2);

        this.usersDao.save(list);
    }
    /**
     * 查询所有
     */
    @Test
    public void findAll(){
        List&lt;Users&gt; all = (List&lt;Users&gt;) this.usersDao.findAll();
        for (Users u:all) {
            System.out.println(u);
        }
    }

    /**
     * 查询单个
     */
    @Test
    public void findOne(){
        Users one = this.usersDao.findOne(3);
        System.out.println(one);
    }

    /**
     * 修改 方式一 
     */
    @Test
    public void updOne(){
        Users one = this.usersDao.findOne(3);
        one.setUsername("Vivian");
        this.usersDao.save(one);
    }
    /**
     * 修改 方式二  事务依赖本方法
     */
    @Test
    @Transactional
    @Rollback(false)
    public void updTwo(){
        Users one = this.usersDao.findOne(3);//持久化
        one.setUsername("Snow");

    }
    /**
     * 删除
     */
    @Test
    public void del(){
        this.usersDao.delete(8);
    }
}
</code></pre> 
 <h3 id="%E4%BA%94%E3%80%81PagingAndSortingRepository%E6%8E%A5%E5%8F%A3">五、PagingAndSortingRepository接口</h3> 
 <pre class="has"><code class="language-java">package com.zxw.dao;

import com.zxw.pojo.Users;

import org.springframework.data.repository.PagingAndSortingRepository;


public interface UsersDao extends PagingAndSortingRepository&lt;Users,Integer&gt; {

}
</code></pre> 
 <p>测试类</p> 
 <pre class="has"><code class="language-java">package com.zxw.test;

import com.zxw.dao.UsersDao;
import com.zxw.pojo.Users;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.util.List;


@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class UsersDaoImplTest {
    @Autowired
    private UsersDao usersDao;
    /**
     * 分页
     */
    @Test
    public void page(){
        int page=0;//页数索引  从0开始
        int size=2;//一页几条数据

        //分页
        Pageable pageable=new PageRequest(page,size);
        Page&lt;Users&gt; usersPage = this.usersDao.findAll(pageable);

        System.out.println("总条数："+usersPage.getTotalElements());
        System.out.println("总页数："+usersPage.getTotalPages());
        List&lt;Users&gt; users = usersPage.getContent();
        for (Users u:users) {
            System.out.println(u);
        }
    }
    /**
     * 分页+排序
     */
    @Test
    public void pageAndSort(){
        int page=0;//页数索引  从0开始
        int size=2;//一页几条数据

        //排序
        Sort sort=new Sort(Sort.Direction.DESC,"userage");
        //分页
        Pageable pageable=new PageRequest(page,size,sort);
        Page&lt;Users&gt; usersPage = this.usersDao.findAll(pageable);

        System.out.println("总条数："+usersPage.getTotalElements());
        System.out.println("总页数："+usersPage.getTotalPages());
        List&lt;Users&gt; users = usersPage.getContent();
        for (Users u:users) {
            System.out.println(u);
        }
    }
    /**
     * 排序 单条件
     */
    @Test
    public void sortTest(){
        //Sort:该对象封装了排序规则以及指定的排序字段(对象的属性来表示)
        // direction:排序规则
        // properties:指定做排序的属性
        Sort sort = new Sort(Sort.Direction.DESC,"userage");
        List&lt;Users&gt; list = (List&lt;Users&gt;)this.usersDao.findAll(sort);
        for (Users users : list) {
            System.out.println(users);
        }
    }

    /**
     * 排序 多条件
     */
    @Test
    public void sort2Test(){
        //Sort:该对象封装了排序规则以及指定的排序字段(对象的属性来表示)
        // direction:排序规则
        // properties:指定做排序的属性
        //多条件查询时使用，一个order代表一个条件
        Sort.Order order=new Sort.Order(Sort.Direction.DESC,"userage");
        Sort.Order order1=new Sort.Order(Sort.Direction.ASC,"username");
        Sort sort = new Sort(order,order1);
        List&lt;Users&gt; list = (List&lt;Users&gt;)this.usersDao.findAll(sort);
        for (Users users : list) {
            System.out.println(users);
        }
    }


}
</code></pre> 
 <h3 id="%E5%85%AD%E3%80%81JpaRepository%E6%8E%A5%E5%8F%A3">六、JpaRepository接口</h3> 
 <pre class="has"><code class="language-java">package com.zxw.dao;

import com.zxw.pojo.Users;
import org.springframework.data.jpa.repository.JpaRepository;


public interface UsersDao extends JpaRepository&lt;Users,Integer&gt; {

}
</code></pre> 
 <p>测试类</p> 
 <pre class="has"><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class UsersDaoImplTest {
    @Autowired
    private UsersDao usersDao;


    /*** 添加用户 */
    @Test
    @Transactional
    // 在测试类对于事务提交方式默认的是回滚。
    @Rollback(false)//取消自动回滚
    public void testInsertUsers() {
        Users users = new Users();
        users.setUserage(18);
        users.setUsername("凑崎纱夏");
        this.usersDao.save(users);
    }

}
</code></pre> 
 <h3 id="%E4%B8%83%E3%80%81JpaSpecificationExecutor%E6%8E%A5%E5%8F%A3">七、JpaSpecificationExecutor接口</h3> 
 <pre class="has"><code class="language-java">package com.zxw.dao;

import com.zxw.pojo.Users;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.repository.PagingAndSortingRepository;

/**
 * JpaSpecificationExecutor不能单独使用
 */
public interface UsersDao extends JpaRepository&lt;Users,Integer&gt;, JpaSpecificationExecutor&lt;Users&gt; {

}
</code></pre> 
 <p>测试类</p> 
 <pre class="has"><code class="language-java">package com.zxw.test;

import com.zxw.dao.UsersDao;
import com.zxw.pojo.Users;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.sound.midi.Soundbank;
import java.util.ArrayList;
import java.util.List;


@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class UsersDaoImplTest {
    @Autowired
    private UsersDao usersDao;

    /**
     * 单条件查询
     */
    @Test
    public void test1(){

        Specification&lt;Users&gt; spec=new Specification&lt;Users&gt;() {
            @Override
            public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) {
                /**
                 * @return Predicate:定义了查询条件
                 * @param Root&lt;Users&gt; root:封装查询条件的对象
                 * @param CriteriaQuery&lt;?&gt; query:定义了一个基本的查询.一般不使用
                 * @param CriteriaBuilder cb:创建一个查询条件
                 */
                Predicate predicate = criteriaBuilder.equal(root.get("username"), "金泰妍");
                return predicate;
            }
        };
        List&lt;Users&gt; list = this.usersDao.findAll(spec);
        for (Users u:list) {
            System.out.println(u);
        }
    }

    /**
     * 多条件查询  方式一
     * 需求：使用用户姓名以及年龄查询数据
     */
    @Test
    public void test2(){

        Specification&lt;Users&gt; spec=new Specification&lt;Users&gt;() {
            @Override
            public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) {
                List&lt;Predicate&gt; list=new ArrayList&lt;&gt;();
                list.add(criteriaBuilder.equal(root.get("username"),"金泰妍"));
                list.add(criteriaBuilder.equal(root.get("userage"),20));

                Predicate[] arr=new Predicate[list.size()];
                return criteriaBuilder.or(list.toArray(arr));
            }
        };
        List&lt;Users&gt; list = this.usersDao.findAll(spec);
        for (Users u:list) {
            System.out.println(u);
        }
    }

    /**
     * 多条件查询  方式二
     */
    @Test
    public void test3(){

        Specification&lt;Users&gt; spec=new Specification&lt;Users&gt;() {
            @Override
            public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) {
                return criteriaBuilder.or(criteriaBuilder.equal(root.get("username"),"金泰妍"),criteriaBuilder.equal(root.get("userage"),20));
            }
        };
        List&lt;Users&gt; list = this.usersDao.findAll(spec);
        for (Users u:list) {
            System.out.println(u);
        }
    }

    /**
     * 多条件查询  方式二加分页
     */
    @Test
    public void test4(){

        Specification&lt;Users&gt; specification = new Specification&lt;Users&gt;() {
            @Override
            public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) {
                return criteriaBuilder.like(root.get("username").as(String.class),"金%");
            }
        };
        //分页
        Pageable pageable=new PageRequest(0,2);
        Page&lt;Users&gt; all = this.usersDao.findAll(specification, pageable);

        List&lt;Users&gt; list = all.getContent();
        System.out.println(all.getTotalElements());
        System.out.println(all.getTotalPages());

        for (Users u:list) {
            System.out.println(u);
        }
    }

    /**
     * 多条件查询  方式二加排序
     */
    @Test
    public void test5(){

        Specification&lt;Users&gt; specification = new Specification&lt;Users&gt;() {
            @Override
            public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) {
                return criteriaBuilder.like(root.get("username").as(String.class),"金%");
            }
        };
        //排序
        Sort sort=new Sort(Sort.Direction.DESC,"userage");
        List&lt;Users&gt; all = this.usersDao.findAll(specification, sort);
        for (Users u:all) {
            System.out.println(u);
        }
    }

    /**
     * 多条件查询  方式二 排序+分页
     *   排序放入分页中
     */
    @Test
    public void test6(){

        //排序
        Sort sort=new Sort(Sort.Direction.ASC,"userage");
        //分页
        Pageable pageable=new PageRequest(0,2,sort);
        //多条件查询
        Specification&lt;Users&gt; specification=new Specification&lt;Users&gt;() {
            @Override
            public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) {
                return criteriaBuilder.like(root.get("username").as(String.class),"金%");
            }
        };

        Page&lt;Users&gt; all = this.usersDao.findAll(specification, pageable);
        for (Users u:all) {
            System.out.println(u);
        }
    }
}
</code></pre> 
 <h4 id="%E5%85%AB%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89Repository%E6%8E%A5%E5%8F%A3">八、自定义Repository接口</h4> 
 <p style="text-indent:33px;">当Spring Data JPA提供的5种接口都不能满足我们的需求时，我们可以自定义repository接口。</p> 
 <p style="text-indent:33px;">首先创建一个我们自定义的接口，里面写上我们需要完成的功能的方法</p> 
 <pre class="has"><code class="language-java">package com.zxw.dao;

import com.zxw.pojo.Users;

public interface MyRepository {
    public Users findById(Integer userid);
}
</code></pre> 
 <p style="text-indent:33px;">之后把原先的UsersDao也继承我们的自定义接口MyRepository</p> 
 <pre class="has"><code class="language-java">package com.zxw.dao;

import com.zxw.pojo.Users;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.repository.PagingAndSortingRepository;


public interface UsersDao extends JpaRepository&lt;Users,Integer&gt;, JpaSpecificationExecutor&lt;Users&gt;,MyRepository {

}
</code></pre> 
 <p style="text-indent:33px;">此时我们自定义接口中的方法并没有谁去实现它，所以我们写个接口实现类去实现，接口类为UsersDaoImpl</p> 
 <pre class="has"><code class="language-java">package com.zxw.dao;

import com.zxw.pojo.Users;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

public class UsersDaoImpl implements MyRepository {
    @PersistenceContext(name = "entityManagerFactory")
    private EntityManager entityManager;
    @Override
    public Users findById(Integer userid) {
        return this.entityManager.find(Users.class,userid);
    }
}
</code></pre> 
 <p style="text-indent:33px;">测试类</p> 
 <pre class="has"><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class UsersDaoImplTest {
    @Autowired
    private UsersDao usersDao;

    @Test
    public void test1(){
        Users users = this.usersDao.findById(7);
        System.out.println(users);
    }
}
</code></pre> 
 <p> </p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2e5eeb7886da77acb38c0c104ab01de2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Keras】数据自动生成器，继承keras.utils.Sequence</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df693801c60d03d2a858920d4a2362cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android资源管理框架-------之Bag资源信息的获取(七)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>