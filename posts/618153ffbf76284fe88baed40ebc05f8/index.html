<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flutter-渲染原理&amp;三棵树详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Flutter-渲染原理&amp;三棵树详解" />
<meta property="og:description" content="一. 渲染原理 WidgetTree:存放渲染内容、它只是一个配置数据结构，创建是非常轻量的，在页面刷新的过程中随时会重建
Element 是分离 WidgetTree 和真正的渲染对象的中间层， WidgetTree 用来描述对应的Element 属性,同时持有Widget和RenderObject，存放上下文信息，通过它来遍历视图树，支撑UI结构。
RenderObject (渲染树)用于应用界面的布局和绘制，负责真正的渲染，保存了元素的大小，布局等信息，实例化一个 RenderObject 是非常耗能的
当应用启动时 Flutter 会遍历并创建所有的 Widget 形成 Widget Tree，通过调用 Widget 上的 createElement() 方法创建每个 Element 对象，形成 Element Tree。最后调用 Element 的 createRenderObject() 方法创建每个渲染对象，形成一个 Render Tree。
那么，flutter为什么要设计成这样呢？为什么要弄成复杂的三层结构？
答案是性能优化。如果每一点细微的操作就去完全重绘一遍UI，将带来极大的性能开销。flutter的三棵树型模式设计可以有效地带来性能提升。
widget的重建开销非常小，所以可以随意的重建，因为它不一会导致页面重绘，并且它也不一定会常常变化。 而renderObject如果频繁创建和销毁成本就很高了，对性能的影响比较大，因此它会缓存所有页面元素，只是当这些元素有变化时才去重绘页面。
而判断页面有无变化就依靠element了，每次widget变化时element会比较前后两个widget，只有当某一个位置的Widget和新Widget不一致，才会重新创建Element和widget；其他时候则只会修改renderObject的配置而不会进行耗费性能的RenderObject的实例化工作了。
课题笔记
Widget的渲染原理
所有的Widget都会创建一个Element对象
并不是所有的Widget都会被独立渲染！只有继承RenderObjectWidget的才会创建RenderObject对象！（Container就不会创建RenderObject、column和padding这些可以创建RenderObject）
在Flutter渲染的流程中，有三颗重要的树！Flutter引擎是针对Render树进行渲染！
Widget树、Element树、Render树
每一个Widget都会创建一个Element对象
隐式调用createElement方法。Element加入Element树中，它会创建RenderElement、ComponentElement（又分为StatefulElement和StatelessElement）。
RenderElement主要是创建RenderObject对象， 继承RenderObjectWidget的Widget会创建RenderElement
创建RanderElementFlutter会调用mount方法，调用createRanderObject方法 StatefulElement继承ComponentElement，StatefulWidget会创建StatefulElement
调用createState方法，创建State将Widget赋值给state调用state的build方法 并且将自己（Element）传出去,build里面的context 就是Widget的Element ！ StatelessElement继承ComponentElement,StatelessWidget会创建StatelessElement
mount方法 -&gt; firstBuild -&gt; rebuild -&gt; performBuild -&gt; build -&gt; _widget.build-主要就是调用build方法 并且将自己（Element）传出去" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/618153ffbf76284fe88baed40ebc05f8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-07T12:44:39+08:00" />
<meta property="article:modified_time" content="2023-03-07T12:44:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flutter-渲染原理&amp;三棵树详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一. 渲染原理</h3> 
<p><strong>WidgetTree</strong>:存放渲染内容、它只是一个配置数据结构，创建是非常轻量的，在页面刷新的过程中随时会重建</p> 
<p><strong>Element</strong> 是分离 WidgetTree 和真正的渲染对象的中间层， WidgetTree 用来描述对应的Element 属性,同时持有Widget和RenderObject，存放上下文信息，通过它来遍历视图树，支撑UI结构。</p> 
<p><strong>RenderObject</strong> (渲染树)用于应用界面的布局和绘制，负责真正的渲染，保存了元素的大小，布局等信息，实例化一个 RenderObject 是非常耗能的</p> 
<p>当应用启动时 Flutter 会遍历并创建所有的 Widget 形成 Widget Tree，通过调用 Widget 上的 createElement() 方法创建每个 Element 对象，形成 Element Tree。最后调用 Element 的 createRenderObject() 方法创建每个渲染对象，形成一个 Render Tree。</p> 
<p><strong>那么，flutter为什么要设计成这样呢？为什么要弄成复杂的三层结构？</strong></p> 
<p>答案是性能优化。如果每一点细微的操作就去完全重绘一遍UI，将带来极大的性能开销。flutter的三棵树型模式设计可以有效地带来性能提升。</p> 
<p>widget的重建开销非常小，所以可以随意的重建，因为它不一会导致页面重绘，并且它也不一定会常常变化。 而renderObject如果频繁创建和销毁成本就很高了，对性能的影响比较大，因此它会缓存所有页面元素，只是当这些元素有变化时才去重绘页面。</p> 
<p>而判断页面有无变化就依靠element了，每次widget变化时element会比较前后两个widget，只有当某一个位置的Widget和新Widget不一致，才会重新创建Element和widget；其他时候则只会修改renderObject的配置而不会进行耗费性能的RenderObject的实例化工作了。</p> 
<p><img alt="" height="630" src="https://images2.imgbox.com/b2/85/HTCyIcea_o.png" width="1200"></p> 
<p> 课题笔记</p> 
<p><strong>Widget的渲染原理</strong></p> 
<ul><li> <p>所有的Widget都会创建一个Element对象</p> </li><li> <p>并不是所有的Widget都会被独立渲染！只有继承RenderObjectWidget的才会创建RenderObject对象！（Container就不会创建RenderObject、column和padding这些可以创建RenderObject）</p> </li><li> <p>在Flutter渲染的流程中，有三颗重要的树！Flutter引擎是针对Render树进行渲染！</p> 
  <ul><li> <p>Widget树、Element树、Render树</p> 
    <ul><li> <p>每一个Widget都会创建一个Element对象</p> 
      <ul><li> <p>隐式调用createElement方法。Element加入Element树中，它会创建RenderElement、ComponentElement（又分为StatefulElement和StatelessElement）。</p> </li><li> <p>RenderElement主要是创建RenderObject对象， 继承RenderObjectWidget的Widget会创建RenderElement</p> 
        <ul><li>创建RanderElement</li><li>Flutter会调用mount方法，调用createRanderObject方法</li></ul></li><li> <p>StatefulElement继承<strong>ComponentElement</strong>，StatefulWidget会创建StatefulElement</p> 
        <ul><li>调用createState方法，创建State</li><li>将Widget赋值给state</li><li>调用state的build方法 并且将自己（Element）传出去,build里面的context 就是Widget的Element ！</li></ul></li><li> <p>StatelessElement继承<strong>ComponentElement</strong>,StatelessWidget会创建StatelessElement</p> 
        <ul><li>mount方法 -&gt; firstBuild -&gt; rebuild -&gt; performBuild -&gt; build -&gt; _widget.build</li></ul><p>-主要就是调用build方法 并且将自己（Element）传出去</p> </li></ul></li></ul></li></ul></li></ul> 
<h4>1. widget</h4> 
<p><em>Widget</em>从功能上看，可以分为三大类：</p> 
<ul><li>Component Widget</li></ul> 
<p>组合类<em>Widget</em>。这类Widget主要用来组合其他更基础的<em>Widget</em>，得到功能更加复杂的<em>Widget</em>。平常的业务开发一般用的就是此类<em>Widget</em>。</p> 
<ul><li>Render Widget</li></ul> 
<p>渲染类<em>Widget</em>，这类Widget是框架最核心的<em>Widget</em>，会参与后面的布局和渲染流程；只有这种类型的<em>Widget</em>会绘制到屏幕上。</p> 
<ul><li>Proxy Widget</li></ul> 
<p>代理类<em>Widget</em>，其本身并不涉及<em>Widget</em>内部逻辑，只是为子<em>Widget</em>提供一些附加的中间功能。例如：<em>InheritedWidget</em>用于将一些状态信息传递给子孙<em>Widget</em>。</p> 
<h4>2.Element</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e6/ce/OI1azrEL_o.png"></p> 
<p><em>Element</em>从功能上看，可以分为两大类：</p> 
<ul><li>ComponentElement</li></ul> 
<p>组合类<em>Element</em>。这类<em>Element</em>主要用来组合其他更基础的<em>Element</em>，得到功能更加复杂的<em>Element</em>。开发时常用到的<em>StatelessWidget</em>和<em>StatefulWidget</em>相对应的<em>Element</em>：<em>StatelessElement</em>和<em>StatefulElement</em>，即属于<em>ComponentElement</em>。</p> 
<ul><li>RenderObjectElement</li></ul> 
<p>渲染类<em>Element</em>，对应<em>Renderer Widget</em>，是框架最核心的<em>Element</em>。<em>RenderObjectElement</em>主要包括<em>LeafRenderObjectElement</em>，<em>SingleChildRenderObjectElement</em>，和<em>MultiChildRenderObjectElement</em>。其中，<em>LeafRenderObjectElement</em>对应的<em>Widget</em>是<em>LeafRenderObjectWidget</em>，没有子节点；<em>SingleChildRenderObjectElement</em>对应的<em>Widget</em>是<em>SingleChildRenderObjectWidget</em>，有一个子节点；<em>MultiChildRenderObjectElement</em>对应的<em>Widget</em>是<em>MultiChildRenderObjecWidget</em>，有多个子节点。</p> 
<p>2.1 ComponentElement</p> 
<p>2.1.1 与核心元素关系</p> 
<p>如上文所述，<em>ComponentElement</em>分为<em>StatelessElement</em>和<em>StatefulElement</em>，这两种<em>Element</em>同核心元素<em>Widget</em>以及<em>State</em>之间的关系如下图所示。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/29/0e/1gIWlrE3_o.png"></p> 
<p>如图：</p> 
<ul><li><em>ComponentElement</em>持有<em>Parent Element</em>及<em>Child Element</em>，由此构成<em>Element Tree</em>.</li><li><em>ComponentElement</em>持有其对应的<em>Widget</em>,对于<em>StatefulElement</em>，其还持有对应的<em>State</em>，以此实现<em>Element</em>和<em>Widget</em>之间的绑定。</li><li><em>State</em>是被<em>StatefulElement</em>持有，而不是被<em>StatefulWidget</em>持有，便于<em>State</em>的复用。事实上，<em>State</em>和<em>StatefulElement</em>是一一对应的，只有在初始化<em>StatefulElement</em>时，才会初始化对应的<em>State</em>并将其绑定到<em>StatefulElement</em>上。</li></ul> 
<p>2.1.2 ComponentElement核心流程</p> 
<p>一个<em>Element</em>的核心操作流程有，创建、更新、销毁三种，下面将分别介绍这三个流程。</p> 
<ul><li>创建</li></ul> 
<p><em>ComponentElement</em>的创建起源与父<em>Widget</em>调用inflateWidget，然后通过mount将该<em>Element</em>挂载至<em>Element Tree</em>，并递归创建子节点。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f9/f1/wFzMHiTK_o.png"></p> 
<ul><li>更新</li></ul> 
<p>由父<em>Element</em>执行更新子节点的操作（updateChild），由于新旧<em>Widget</em>的类型和<em>Key</em>均未发生变化，因此触发了<em>Element</em>的更新操作，并通过performRebuild将更新操作传递下去。其核心函数updateChild之后会详细介绍。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/26/a0/AP8q9nbD_o.png"></p> 
<ul><li>销毁</li></ul> 
<p>由父<em>Element</em>或更上级的节点执行更新子节点的操作（updateChild），由于新旧<em>Widget</em>的类型或者<em>Key</em>发生变化，或者新<em>Widget</em>被移除，因此导致该<em>Element</em>被转为未激活状态，并被加入未激活列表，并在下一帧被失效。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0c/d6/ir4yqqPP_o.png"></p> 
<p>2.1.3 ComponentElement核心函数</p> 
<p>下面对<em>ComponentElement</em>中的核心方法进行介绍。</p> 
<ul><li>inflateWidget</li></ul> 
<pre><code class="language-Kotlin">Element inflateWidget(Widget newWidget, dynamic newSlot) {
  final Key key = newWidget.key;
//复用GlobalKey对应的Element
  if (key is GlobalKey) {
    final Element newChild = _retakeInactiveElement(key, newWidget);
    if (newChild != null) {
      newChild._activateWithParent(this, newSlot);
      final Element updatedChild = updateChild(newChild, newWidget, newSlot);
      return updatedChild;
    }
  }
//创建Element，并挂载至Element Tree
  final Element newChild = newWidget.createElement();
  newChild.mount(this, newSlot);
  return newChild;
}
</code></pre> 
<p>inflateWidget的主要职责如下：</p> 
<ol><li>判断新<em>Widget</em>是否有<em>GlobalKey</em>，如果有<em>GlobalKey</em>，则从<em>Inactive Elements</em>列表中找到对应的<em>Element</em>并进行复用。</li><li>无可复用<em>Element</em>，则根据新<em>Widget</em>创建对应的<em>Element</em>，并将其挂载至<em>Element Tree</em>。</li></ol> 
<ul><li>mount</li></ul> 
<pre><code class="language-Kotlin">void mount(Element parent, dynamic newSlot) {
//更新_parent等属性，将元素加入Element Tree
  _parent = parent;
  _slot = newSlot;
  _depth = _parent != null ? _parent.depth + 1 : 1;
  _active = true;
  if (parent != null) // Only assign ownership if the parent is non-null
    _owner = parent.owner;
//注册GlobalKey
  final Key key = widget.key;
  if (key is GlobalKey) {
    key._register(this);
  }
  _updateInheritance();
}
</code></pre> 
<p>当<em>Element</em>第一次被插入<em>Element Tree</em>的时候，该方法被调用。其主要职责如下：</p> 
<ol><li>将给<em>Element</em>加入<em>Element Tree</em>，更新_parent，_slot等树相关的属性。</li><li>如果新<em>Widget</em>有<em>GlobalKey</em>，将该<em>Element</em>注册进<em>GlobalKey</em>中，其作用下文会详细分析。</li><li><em>ComponentElement</em>的mount函数会调用_firstBuild函数，触发子<em>Widget</em>的创建和更新。</li></ol> 
<ul><li>performRebuild</li></ul> 
<pre><code>@override
void performRebuild() {
//调用build函数，生成子Widget
  Widget built;
  built = build();
//根据新的子Widget更新子Element
  _child = updateChild(_child, built, slot);
}
</code></pre> 
<p>performRebuild的主要职责如下：</p> 
<ol><li>调用build函数，生成子<em>Widget</em>。</li><li>根据新的子<em>Widget</em>更新子<em>Element</em>。</li></ol> 
<ul><li>update</li></ul> 
<pre><code>@mustCallSuper
void update(covariant Widget newWidget) {
  _widget = newWidget;
}
</code></pre> 
<p>此函数主要职责为：</p> 
<ol><li>将对应的Widget更新为新的<em>Widget</em>。</li><li>在<em>ComponentElement</em>的各种子类中，还会调用rebuild函数触发对子<em>Widget</em>的重建。</li></ol> 
<ul><li>updateChild</li></ul> 
<pre><code class="language-Kotlin">@protected
Element updateChild(Element child, Widget newWidget, dynamic newSlot) {
  if (newWidget == null) {
//新的Child Widget为null，则返回null；如果旧Child Widget，使其未激活
    if (child != null)
      deactivateChild(child);
    return null;
  }
  Element newChild;
  if (child != null) {
//新的Child Widget不为null，旧的Child Widget也不为null
    bool hasSameSuperclass = true;
    if (hasSameSuperclass &amp;&amp; child.widget == newWidget) {
      if (child.slot != newSlot)
        updateSlotForChild(child, newSlot);
      newChild = child;
    } else if (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget)){
//Key和RuntimeType相同，使用update更新
      if (child.slot != newSlot)
        updateSlotForChild(child, newSlot);
      child.update(newWidget);
      newChild = child;
    } else {
//Key或RuntimeType不相同，使旧的Child Widget未激活，并对新的Child Widget使用inflateWidget
      deactivateChild(child);
      newChild = inflateWidget(newWidget, newSlot);
    }
  } else {
//新的Child Widget不为null，旧的Child Widget为null，对新的Child Widget使用inflateWidget
    newChild = inflateWidget(newWidget, newSlot);
  }

  return newChild;
}
</code></pre> 
<p>该方法的主要职责为：</p> 
<p>根据新的子<em>Widget</em>，更新旧的子<em>Element</em>，或者得到新的子<em>Element</em>。其核心逻辑可以用表格表示：</p> 
<table><thead><tr><th></th><th>newWidget == null</th><th>newWidget != null</th></tr></thead><tbody><tr><td>Child == null</td><td>返回null</td><td>返回新Element</td></tr><tr><td>Child != null</td><td>移除旧的子Element，返回null</td><td>如果Widget能更新，更新旧的子Element，并返回之；否则创建新的子Element并返回。</td></tr></tbody></table> 
<p>该逻辑概括如下：</p> 
<ul><li>如果newWidget为null，则返回null，同时如果有旧的子<em>Element</em>则移除之。</li><li>如果newWidget不为null，旧<em>Child</em>为null，则创建新的子<em>Element</em>，并返回之。</li><li>如果newWidget不为null，旧<em>Child</em>不为null，新旧子<em>Widget</em>的<em>Key</em>和<em>RuntimeType</em>等都相同，则调用update方法更新子<em>Element</em>并返回之。</li><li>如果newWidget不为null，旧<em>Child</em>不为null，新旧子<em>Widget</em>的<em>Key</em>和<em>RuntimeType</em>等不完全相同，则说明<em>Widget Tree</em>有变动，此时移除旧的子<em>Element</em>，并创建新的子<em>Element</em>，并返回之。</li></ul> 
<p>2.2 RenderObjectElement</p> 
<p>2.2.1 RenderObjectElement与核心元素关系</p> 
<p><em>RenderObjectElement</em>同核心元素<em>Widget</em>及<em>RenderObject</em>之间的关系如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/21/82/Yg7tc11m_o.png"></p> 
<p>如图：</p> 
<ul><li><em>RenderObjectElement</em>持有<em>Parent Element</em>，但是不一定持有<em>Child Element</em>，有可能无<em>Child Element</em>，有可能持有一个<em>Child Element</em>（<em>Child</em>），有可能持有多个<em>Child Element</em>(<em>Children</em>)。</li><li><em>RenderObjectElement</em>持有对应的<em>Widget</em>和<em>RenderObject</em>，将<em>Widget</em>、<em>RenderObject</em>串联起来，实现了<em>Widget</em>、<em>Element</em>、<em>RenderObject</em>之间的绑定。</li></ul> 
<p>2.2.2 RenderObjectElement核心流程</p> 
<p>如<em>ComponentElement</em>一样，<em>RenderObjectElement</em>的核心操作流程有，创建、更新、销毁三种，接下来会详细介绍这三种流程。</p> 
<ul><li>创建</li></ul> 
<p><em>RenderObjectElement</em>的创建流程和<em>ComponentElement</em>的创建流程基本一致，其最大的区别是<em>ComponentElement</em>在mount后，会调用build来创建子<em>Widget</em>，而<em>RenderObjectElement</em>则是create和attach其<em>RenderObject</em>。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9e/e2/UNWBitHl_o.png"></p> 
<ul><li>更新</li></ul> 
<p><em>RenderObjectElement</em>的更新流程和<em>ComponentElement</em>的更新流程也基本一致，其最大的区别是<em>ComponentElement</em>的update函数会调用build函数，重新触发子Widget的构建，而<em>RenderObjectElement</em>则是调用updateRenderObject对绑定的<em>RenderObject</em>进行更新。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ab/7c/xEjfNvdi_o.png"></p> 
<ul><li>销毁</li></ul> 
<p><em>RenderObjectElement</em>的销毁流程和<em>ComponentElement</em>的销毁流程也基本一致。也是由父<em>Element</em>或更上级的节点执行更新子节点的操作（updateChild），导致该<em>Element</em>被停用，并被加入未激活列表，并在下一帧被失效。其不一样的地方是在unmount <em>Element</em>的时候，会调用didUnmountRenderObject失效对应的<em>RenderObject</em>。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/39/bd/rC3xcDIK_o.png"></p> 
<p>2.2.3 RenderObjectElement核心函数</p> 
<p>下面对<em>RenderObjectElement</em>中的核心方法进行介绍。</p> 
<ul><li>inflateWidget</li></ul> 
<p>该函数和ComponentElement的inflateWidget函数完全一致，此处不再复述。</p> 
<ul><li>mount</li></ul> 
<pre><code>void mount(Element parent, dynamic newSlot) {
  super.mount(parent, newSlot);
  _renderObject = widget.createRenderObject(this);
  attachRenderObject(newSlot);
  _dirty = false;
}
</code></pre> 
<p>该函数的调用时机和<em>ComponentElement</em>的一致，当<em>Element</em>第一次被插入<em>Element Tree</em>的时候，该方法被调用。其主要职责也和<em>ComponentElement</em>的一致，此处只列举不一样的职责，职责如下：</p> 
<ol><li>调用createRenderObject创建<em>RenderObject</em>，并使用attachRenderObject将<em>RenderObject</em>关联到<em>Element</em>上。</li><li><em>SingleChildRenderObjectElement</em>会调用updateChild更新子节点，<em>MultiChildRenderObjectElement</em>会调用每个子节点的inflateWidget重建所有子<em>Widget</em>。</li></ol> 
<ul><li>performRebuild</li></ul> 
<pre><code>@override
void performRebuild() {
//更新renderObject
  widget.updateRenderObject(this, renderObject);
  _dirty = false;
}
</code></pre> 
<p>performRebuild的主要职责如下：</p> 
<p>调用updateRenderObject更新对应的<em>RenderObject</em>。</p> 
<ul><li>update</li></ul> 
<pre><code>@override
void update(covariant RenderObjectWidget newWidget) {
  super.update(newWidget);
  widget.updateRenderObject(this, renderObject);
  _dirty = false;
}
</code></pre> 
<p>update的主要职责如下：</p> 
<ol><li>将对应的<em>Widget</em>更新为新的<em>Widget</em>。</li><li>调用updateRenderObject更新对应的<em>RenderObject</em>。</li></ol> 
<ul><li>updateChild</li></ul> 
<p>该函数和<em>ComponentElement</em>的inflateWidget函数完全一致，此处不再复述。</p> 
<ul><li>updateChildren</li></ul> 
<pre><code class="language-Kotlin">@protected
List&lt;Element&gt; updateChildren(List&lt;Element&gt; oldChildren, List&lt;Widget&gt; newWidgets, { Set&lt;Element&gt; forgottenChildren }) {
  int newChildrenTop = 0;
  int oldChildrenTop = 0;
  int newChildrenBottom = newWidgets.length - 1;
  int oldChildrenBottom = oldChildren.length - 1;

  final List&lt;Element&gt; newChildren = oldChildren.length == newWidgets.length ?
      oldChildren : List&lt;Element&gt;(newWidgets.length);

  Element previousChild;

// 从顶部向下更新子Element
  // Update the top of the list.
  while ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) {
    final Element oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]);
    final Widget newWidget = newWidgets[newChildrenTop];
    if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget))
      break;
    final Element newChild = updateChild(oldChild, newWidget, IndexedSlot&lt;Element&gt;(newChildrenTop, previousChild));
    newChildren[newChildrenTop] = newChild;
    previousChild = newChild;
    newChildrenTop += 1;
    oldChildrenTop += 1;
  }

// 从底部向上扫描子Element
  // Scan the bottom of the list.
  while ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) {
    final Element oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenBottom]);
    final Widget newWidget = newWidgets[newChildrenBottom];
    if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget))
      break;
    oldChildrenBottom -= 1;
    newChildrenBottom -= 1;
  }

// 扫描旧的子Element列表里面中间的子Element，保存Widget有Key的Element到oldKeyChildren，其他的失效
  // Scan the old children in the middle of the list.
  final bool haveOldChildren = oldChildrenTop &lt;= oldChildrenBottom;
  Map&lt;Key, Element&gt; oldKeyedChildren;
  if (haveOldChildren) {
    oldKeyedChildren = &lt;Key, Element&gt;{};
    while (oldChildrenTop &lt;= oldChildrenBottom) {
      final Element oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]);
      if (oldChild != null) {
        if (oldChild.widget.key != null)
          oldKeyedChildren[oldChild.widget.key] = oldChild;
        else
          deactivateChild(oldChild);
      }
      oldChildrenTop += 1;
    }
  }

// 根据Widget的Key更新oldKeyChildren中的Element。
  // Update the middle of the list.
  while (newChildrenTop &lt;= newChildrenBottom) {
    Element oldChild;
    final Widget newWidget = newWidgets[newChildrenTop];
    if (haveOldChildren) {
      final Key key = newWidget.key;
      if (key != null) {
        oldChild = oldKeyedChildren[key];
        if (oldChild != null) {
          if (Widget.canUpdate(oldChild.widget, newWidget)) {
            // we found a match!
            // remove it from oldKeyedChildren so we don't unsync it later
            oldKeyedChildren.remove(key);
          } else {
            // Not a match, let's pretend we didn't see it for now.
            oldChild = null;
          }
        }
      }
    }

    final Element newChild = updateChild(oldChild, newWidget, IndexedSlot&lt;Element&gt;(newChildrenTop, previousChild));
    newChildren[newChildrenTop] = newChild;
    previousChild = newChild;
    newChildrenTop += 1;
  }

  newChildrenBottom = newWidgets.length - 1;
  oldChildrenBottom = oldChildren.length - 1;

  // 从下到上更新底部的Element。.
  while ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) {
    final Element oldChild = oldChildren[oldChildrenTop];
    final Widget newWidget = newWidgets[newChildrenTop];
    final Element newChild = updateChild(oldChild, newWidget, IndexedSlot&lt;Element&gt;(newChildrenTop, previousChild));
    newChildren[newChildrenTop] = newChild;
    previousChild = newChild;
    newChildrenTop += 1;
    oldChildrenTop += 1;
  }

// 清除旧子Element列表中其他所有剩余Element
  // Clean up any of the remaining middle nodes from the old list.
  if (haveOldChildren &amp;&amp; oldKeyedChildren.isNotEmpty) {
    for (final Element oldChild in oldKeyedChildren.values) {
      if (forgottenChildren == null || !forgottenChildren.contains(oldChild))
        deactivateChild(oldChild);
    }
  }

  return newChildren;
}
</code></pre> 
<p>该函数的主要职责如下：</p> 
<ol><li>复用能复用的子节点，并调用updateChild对子节点进行更新。</li><li>对不能更新的子节点，调用deactivateChild对该子节点进行失效。</li></ol> 
<p>其步骤如下：</p> 
<ol><li>从顶部向下更新子<em>Element</em>。</li><li>从底部向上扫描子<em>Element</em>。</li><li>扫描旧的子<em>Element</em>列表里面中间的子<em>Element</em>，保存<em>Widget</em>有<em>Key</em>的<em>Element</em>到oldKeyChildren，其他的失效。</li><li>对于新的子<em>Element</em>列表，如果其对应的<em>Widget</em>的<em>Key</em>和oldKeyChildren中的<em>Key</em>相同，更新oldKeyChildren中的<em>Element</em>。</li><li>从下到上更新底部的<em>Element</em>。</li><li>清除旧子<em>Element</em>列表中其他所有剩余<em>Element</em>。</li></ol> 
<p>2.1.3 Element小结</p> 
<p>本文主要介绍了<em>Element</em>相关知识，重点介绍了其分类，生命周期，和核心函数。重点如下：</p> 
<ul><li>维护<em>Element Tree</em>，根据<em>Widget Tree</em>的变化来更新<em>Element Tree</em>，包括：节点的插入、更新、删除、移动等；并起到纽带的作用，将<em>Widget</em>以及<em>RenderObject</em>关联到<em>Element Tree</em>上。</li><li><em>Element</em>分为<em>ComponentElement</em>和<em>RenderObjectElement</em>，前者负责组合子<em>Element</em>，后者负责渲染。</li><li><strong><em>Element</em>的主要复用和更新逻辑由其核心函数updateChild实现</strong>，具体逻辑见上文。</li></ul> 
<h4>3. RenderObject</h4> 
<p>通过上篇文章介绍的<em>Element Tree</em>，<em>Flutter Framework</em>会生成一棵<em>RenderObject Tree</em>. 其主要功能如下：</p> 
<ul><li>布局，从<em>RenderBox</em>开始，对<em>RenderObject Tree</em>从上至下进行布局。</li><li>绘制，通过<em>Canvas</em>对象，<em>RenderObject</em>可以绘制自身以及其在<em>RenderObject Tree</em>中的子节点。</li><li>点击测试，<em>RenderObject</em>从上至下传递点击事件，并通过其位置和<em>behavior</em>来控制是否响应点击事件。</li></ul> 
<p><em>RenderObject Tree</em>是底层的布局和绘制系统。大多数<em>Flutter</em>开发者并不需要直接和<em>RenderObject Tree</em>交互，而是使用<em>Widget</em>，然后<em>Flutter Framework</em>会自动构建<em>RenderObject Tree</em>。</p> 
<p>3.1 RenderObject分类</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d3/fa/T6T0TBBa_o.png"></p> 
<p>如上图所示，RenderObject主要分为四类：</p> 
<ul><li>RenderView</li></ul> 
<p><em>RenderView</em>是整个<em>RenderObject Tree</em>的根节点，代表了整个输出界面。</p> 
<ul><li>RenderAbstractViewport</li></ul> 
<p><em>RenderAbstractViewport</em>是一类接口，此类接口为只展示其部分内容的<em>RenderObject</em>设计。</p> 
<ul><li>RenderSliver</li></ul> 
<p><em>RenderSliver</em>是所有实现了滑动效果的<em>RenderObject</em>基类，其常用子类有<em>RenderSliverSingleBoxAdapter</em>等。</p> 
<ul><li>RenderBox</li></ul> 
<p><em>RenderBox</em>是一个采用2D笛卡尔坐标系的<em>RenderObject</em>的基类，一般的<em>RenderOBject</em>都是继承自<em>RenderBox</em>，例如<em>RenderStack</em>等，它也是一般自定义<em>RenderObject</em>的基类。</p> 
<p>3.2 RenderObject核心流程</p> 
<p><em>RenderObject</em>主要负责布局，绘制，及命中测试，下面会对这几个核心流程分别进行讲解。</p> 
<ul><li>布局</li></ul> 
<p>布局对应的函数是<em>layout</em>，该函数主要作用是通过上级节点传过来的<em>Constraints</em>和<em>parentUsesSize</em>等控制参数，对本节点和其子节点进行布局。<em>Constraints</em>是对于节点布局的约束，其原则是，<em>Constraints</em>向下，<em>Sizes</em>向上，父节点设置本节点的位置。即：</p> 
<ol><li>一个<em>Widget</em>从它的父节点获取<em>Constraints</em>，并将其传递给子节点。</li><li>该<em>Widget</em>对其子节点进行布局。</li><li>最终，该节点告诉其父节点它的<em>Sizes</em>。</li></ol> 
<p>在接下来的文章中，我们将对该流程进行详细介绍，当前我们只需要记住该原则。</p> 
<p>当本节点的布局依赖于其子节点的布局时，<em>parentUsesSize</em>的值是true，此时，子节点被标记为需要布局时，本节点也将被标记为需要布局。这样当下一帧绘制时本节点和子节点都将被重新布局。反之，如果<em>parentUsesSize</em>的值是false，子节点被重新布局时不需要通知本节点。</p> 
<p><em>RenderObject</em>的子类不应该直接重写<em>RenderObject</em>的layout函数，而是重写<em>performResize</em>和<em>performLayout</em>函数，这两个函数才是真正负责具体布局的函数。</p> 
<p><em>RenderObject</em>中<em>layout</em>函数的源码如下：</p> 
<pre><code class="language-Kotlin">void layout(Constraints constraints, { bool parentUsesSize = false }) {
//1. 根据relayoutBoundary判断是否需要重新布局
  RenderObject relayoutBoundary;
  if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) {
    relayoutBoundary = this;
  } else {
    relayoutBoundary = (parent as RenderObject)._relayoutBoundary;
  }
  if (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) {
    return;
  }
  _constraints = constraints;
//2. 更新子节点的relayout boundary	
  if (_relayoutBoundary != null &amp;&amp; relayoutBoundary != _relayoutBoundary) {
    // The local relayout boundary has changed, must notify children in case
    // they also need updating. Otherwise, they will be confused about what
    // their actual relayout boundary is later.
    visitChildren(_cleanChildRelayoutBoundary);
  }
  _relayoutBoundary = relayoutBoundary;
//3. 重新计算大小，重新布局
  if (sizedByParent) {
    try {
      performResize();
    } catch (e, stack) {
      _debugReportException('performResize', e, stack);
    }
  }
  try {
    performLayout();
    markNeedsSemanticsUpdate();
  } catch (e, stack) {
    _debugReportException('performLayout', e, stack);
  }
  _needsLayout = false;
  markNeedsPaint();
}
</code></pre> 
<p>从源码可以看到，<em>relayoutBoundary</em>是<em>layout</em>函数中一个重要参数。当一个组件的大小被改变时，其<em>parent</em>的大小可能也会被影响，因此需要通知其父节点。如果这样迭代上去，需要通知整棵<em>RenderObject Tree</em>重新布局，必然会影响布局效率。因此，<em>Flutter</em>通过<em>relayoutBoundary</em>将<em>RenderObject Tree</em>分段，如果遇到了<em>relayoutBoundary</em>，则不去通知其父节点重新布局，因为其大小不会影响父节点的大小。这样就只需要对<em>RenderObject Tree</em>中的一段重新布局，提高了布局效率。关于<em>relayoutBoundary</em>将在之后的文章中详细讲解，目前只需要了解<em>relayoutBoundary</em>会将<em>RenderObject Tree</em>分段，提高布局效率。</p> 
<ul><li>绘制</li></ul> 
<p>绘制对应的函数是<em>paint</em>，其主要作用是将本<em>RenderObject</em>和子<em>RenderObject</em>绘制在<em>Canvas</em>上。<em>RenderObject</em>的子类应该重写这个函数，在该函数中添加绘制的逻辑。</p> 
<p><em>RenderObject</em>的子类<em>RenderFlex</em>的<em>paint</em>函数源码如下：</p> 
<pre><code class="language-Kotlin">void paint(PaintingContext context, Offset offset) {
//1. 未溢出，直接绘制
  if (!_hasOverflow) {
    defaultPaint(context, offset);
    return;
  }

//2. 空的，不需要绘制
  // There's no point in drawing the children if we're empty.
  if (size.isEmpty)
    return;

//3. 根据clipBehavior判断是否需要对溢出边界部分进行裁剪
  if (clipBehavior == Clip.none) {
    defaultPaint(context, offset);
  } else {
    // We have overflow and the clipBehavior isn't none. Clip it.
    context.pushClipRect(needsCompositing, offset, Offset.zero &amp; size, defaultPaint, clipBehavior: clipBehavior);
  }

//4. 绘制溢出错误提示
  assert(() {
    // Only set this if it's null to save work. It gets reset to null if the
    // _direction changes.
    final List&lt;DiagnosticsNode&gt; debugOverflowHints = &lt;DiagnosticsNode&gt;[
      ErrorDescription(
        'The overflowing $runtimeType has an orientation of $_direction.'
      ),
      ErrorDescription(
        'The edge of the $runtimeType that is overflowing has been marked '
        'in the rendering with a yellow and black striped pattern. This is '
        'usually caused by the contents being too big for the $runtimeType.'
      ),
      ErrorHint(
        'Consider applying a flex factor (e.g. using an Expanded widget) to '
        'force the children of the $runtimeType to fit within the available '
        'space instead of being sized to their natural size.'
      ),
      ErrorHint(
        'This is considered an error condition because it indicates that there '
        'is content that cannot be seen. If the content is legitimately bigger '
        'than the available space, consider clipping it with a ClipRect widget '
        'before putting it in the flex, or using a scrollable container rather '
        'than a Flex, like a ListView.'
      ),
    ];

    // Simulate a child rect that overflows by the right amount. This child
    // rect is never used for drawing, just for determining the overflow
    // location and amount.
    Rect overflowChildRect;
    switch (_direction) {
      case Axis.horizontal:
        overflowChildRect = Rect.fromLTWH(0.0, 0.0, size.width + _overflow, 0.0);
        break;
      case Axis.vertical:
        overflowChildRect = Rect.fromLTWH(0.0, 0.0, 0.0, size.height + _overflow);
        break;
    }
    paintOverflowIndicator(context, offset, Offset.zero &amp; size, overflowChildRect, overflowHints: debugOverflowHints);
    return true;
  }());
}
</code></pre> 
<p>这部分代码逻辑为，先判断是否溢出，没有溢出则调用<em>defaultPaint</em>完成绘制，再看是否为空，<em>size</em>是空的话直接返回，最后绘制溢出信息。</p> 
<p>其中<em>defaultPaint</em>的源码如下：</p> 
<pre><code class="language-Kotlin">void defaultPaint(PaintingContext context, Offset offset) {
  ChildType child = firstChild;
  while (child != null) {
    final ParentDataType childParentData = child.parentData as ParentDataType;
    context.paintChild(child, childParentData.offset + offset);
    child = childParentData.nextSibling;
  }
}
</code></pre> 
<p>可见<em>defaultPaint</em>会调用<em>paintChild</em>绘制子节点，而如果子节点还有子节点，则<em>paintChild</em>最终又会调用到其<em>paint</em>然后调用到<em>defaultPaint</em>，从而形成循环递归调用，绘制整棵<em>RenderObject Tree</em>。</p> 
<ul><li>命中测试</li></ul> 
<p>命中测试是为了判断某个组件是否需要响应一个点击事件，其入口是R<em>enderObject Tree</em>的根节点<em>RenderView</em>的<em>hitTest</em>函数。下面是该函数的源码：</p> 
<pre><code class="language-Kotlin">bool hitTest(HitTestResult result, { Offset position }) {
  if (child != null)
    child.hitTest(BoxHitTestResult.wrap(result), position: position);
  result.add(HitTestEntry(this));
  return true;
}
</code></pre> 
<p>从<em>RenderView</em>的构造函数可以看出，<em>child</em>是<em>RenderBox</em>类，因此我们再看<em>RenderBox</em>的<em>hitTest</em>函数。</p> 
<pre><code class="language-Kotlin">bool hitTest(BoxHitTestResult result, { @required Offset position }) {
  if (_size.contains(position)) {
    if (hitTestChildren(result, position: position) || hitTestSelf(position)) {
      result.add(BoxHitTestEntry(this, position));
      return true;
    }
  }
  return false;
}
</code></pre> 
<p>代码逻辑很简单，如果点击事件位置处于<em>RenderObject</em>之内，如果在其内，并且<em>hitTestSelf</em>或者<em>hitTestChildren</em>返回true，则表示该<em>RenderObject</em>通过了命中测试，需要响应事件，此时需要将被点击的<em>RenderObject</em>加入<em>BoxHitTestResult</em>列表，同时点击事件不再向下传递。否则认为没有通过命中测试，事件继续向下传递。其中，<em>hitTestSelf</em>函数表示本节点是否通过命中测试，<em>hitTestChildren</em>表示子节点是否通过命中测试。</p> 
<p>3.3 RenderObject核心函数</p> 
<p><em>RenderObject</em>的核心函数有很多，难以一一列举，在核心流程中已经详细讲解了<em>RenderObject</em>三个核心函数。为了便于理解各个核心函数的作用，这里将<em>RenderObject</em>的核心函数和<em>Android View</em>的核心函数进行比较。以下是比较的表格。</p> 
<table><thead><tr><th>作用</th><th>Flutter RenderObject</th><th>Android View</th></tr></thead><tbody><tr><td>绘制</td><td>paint()</td><td>draw()/onDraw()</td></tr><tr><td>布局</td><td>performLayout()/layout()</td><td>measure()/onMeasure(), layout()/onLayout()</td></tr><tr><td>布局约束</td><td>Constraints</td><td>MeasureSpec</td></tr><tr><td>布局协议1</td><td>performLayout() 的 Constraints 参数表示父节点对子节点的布局限制</td><td>measure() 的两个参数表示父节点对子节点的布局限制</td></tr><tr><td>布局协议2</td><td>performLayout() 应调用各子节点的 layout()</td><td>onLayout() 应调用各子节点的 layout()</td></tr><tr><td>布局参数</td><td>parentData</td><td>mLayoutParams</td></tr><tr><td>请求布局</td><td>markNeedsLayout()</td><td>requestLayout()</td></tr><tr><td>请求绘制</td><td>markNeedsPaint()</td><td>invalidate()</td></tr><tr><td>添加 child</td><td>adoptChild()</td><td>addView()</td></tr><tr><td>移除 child</td><td>dropChild()</td><td>removeView()</td></tr><tr><td>关联到窗口/树</td><td>attach()</td><td>onAttachedToWindow()</td></tr><tr><td>从窗口/树取消关联</td><td>detach()</td><td>onDetachedFromWindow()</td></tr><tr><td>获取 parent</td><td>parent</td><td>getParent()</td></tr><tr><td>触摸事件</td><td>hitTest()</td><td>onTouch()</td></tr><tr><td>用户输入事件</td><td>handleEvent()</td><td>onKey()</td></tr><tr><td>旋转事件</td><td>rotate()</td><td>onConfigurationChanged()</td></tr></tbody></table> 
<p>可见，<em>RenderObject</em>和<em>Android View</em>有很多函数是对应起来的，<em>RenderObject</em>相对于将<em>Android View</em>中的布局渲染等功能单独拆了出来，简化了<em>View</em>的逻辑。</p> 
<p>3.4. 小结</p> 
<p>本文主要介绍了<em>RenderObject</em>相关知识，重点介绍了其分类，核心流程，和核心函数。重点如下：</p> 
<ul><li><em>RenderObject</em>主要负责绘制，布局，命中测试等。</li><li><em>RenderObject</em>布局的原则是，<em>Constraints</em>向下，<em>Sizes</em>向上，父节点设置本节点的位置。</li><li><em>RenderView</em>是整个<em>RenderObject Tree</em>的根节点，其<em>child</em>是一个<em>RenderBox</em>类型的<em>RenderObject</em>。</li></ul> 
<h3>二、Flutter绘制流程及原理</h3> 
<p>系统启动时，runApp方法会被调用，flutter会从最外层的widget去遍历创建一颗widget树；每一个widget创建后会调用createElement()创建相应的element，形成一颗element树；element创建后会通过createRenderObject()创建相应的renderObject树，如此就形成了三棵树。</p> 
<p>在渲染树种完成布局排列和绘制。最后合并层级，通过Skia引擎渲染为GPU数据，然后GPU接着将数据交给显示器显示。</p> 
<p>而渲染对象树在Flutter的展示过程分为三个阶段：布局、绘制、合成和渲染。</p> 
<p>布局：</p> 
<p>Flutter采用深度优先机制遍历渲染对象树，决定渲染对象树中各渲染对象在屏幕上的位置和尺寸。在布局过程中，渲染对象树中的每个渲染对象都会接收父对象的布局约束参数，决定自己的大小，然后父对象按照控件逻辑决定各个子对象的位置，完成布局过程。</p> 
<p>绘制：</p> 
<p>布局完成后，渲染对象树中的每个节点都有了明确的尺寸和位置。Flutter会把所有的渲染对象绘制到不同的图层上。与布局过程一样，绘制过程也是深度优先遍历，而且总是先绘制自身，再绘制子节点。</p> 
<p>图层合成：</p> 
<p>终端设备的页面越来越复杂，因此Flutter的渲染树层级通常很多，直接交付给渲染引擎进行多图层渲染，可能会出现大量渲染内容的重复绘制，所以还需要先进行一次图层合成，即将所有的图层根据大小、层级、透明度等规则计算出最终的显示效果，将相同的图层归类合并，简化渲染树，提高渲染效率。</p> 
<p>合并完成后，Flutter会将几何图层数据交由Skia引擎加工成二维图像数据，最终交由GPU进行渲染，完成界面的展示。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a6/7f/4LTi5FwW_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ec/4d/r8mzaD08_o.png"></p> 
<h3>三. 对象的创建过程【参考内容】</h3> 
<p>上面已经介绍了三棵树的运作流程，这部分为参考内容（视频教程里边学的）</p> 
<p>我们这里以Padding为例，Padding用来设置内边距</p> 
<h4>3.1. Widget</h4> 
<p>Padding是一个Widget，并且继承自SingleChildRenderObjectWidget</p> 
<p>继承关系如下：</p> 
<pre><code>Padding -&gt; SingleChildRenderObjectWidget -&gt; RenderObjectWidget -&gt; Widget
</code></pre> 
<p>我们之前在创建Widget时，经常使用StatelessWidget和StatefulWidget，这种Widget只是将其他的Widget在build方法中组装起来，并不是一个真正可以渲染的Widget（在之前的课程中其实有提到）。</p> 
<p>在Padding的类中，我们找不到任何和渲染相关的代码，这是因为Padding仅仅作为一个配置信息，这个配置信息会随着我们设置的属性不同，频繁的销毁和创建。</p> 
<p><strong>问题：频繁的销毁和创建会不会影响Flutter的性能呢？</strong></p> 
<ul><li>并不会，答案在我的另一篇文章中；</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FJ4XoXJHJSmn8VaMoz3BZJQ" rel="nofollow" title="mp.weixin.qq.com/s/J4XoXJHJS…">mp.weixin.qq.com/s/J4XoXJHJS…</a></li></ul> 
<p>那么真正的渲染相关的代码在哪里执行呢？</p> 
<ul><li>RenderObject</li></ul> 
<h4>3.2. RenderObject</h4> 
<p>我们来看Padding里面的代码，有一个非常重要的方法：</p> 
<ul><li>这个方法其实是来自RenderObjectWidget的类，在这个类中它是一个抽象方法；</li><li>抽象方法是必须被子类实现的，但是它的子类SingleChildRenderObjectWidget也是一个抽象类，所以可以不实现父类的抽象方法</li><li>但是Padding不是一个抽象类，必须在这里实现对应的抽象方法，而它的实现就是下面的实现</li></ul> 
<pre><code>@override
RenderPadding createRenderObject(BuildContext context) {
  return RenderPadding(
    padding: padding,
    textDirection: Directionality.of(context),
  );
}
</code></pre> 
<p><strong>上面的代码创建了什么呢？RenderPadding</strong></p> 
<p>RenderPadding的继承关系是什么呢？</p> 
<pre><code>RenderPadding -&gt; RenderShiftedBox -&gt; RenderBox -&gt; RenderObject
</code></pre> 
<p>我们来具体查看一下RenderPadding的源代码：</p> 
<ul><li>如果传入的_padding和原来保存的value一样，那么直接return；</li><li>如果不一致，调用_markNeedResolution，而_markNeedResolution内部调用了markNeedsLayout；</li><li>而markNeedsLayout的目的就是标记在下一帧绘制时，需要重新布局performLayout；</li><li>如果我们找的是Opacity，那么RenderOpacity是调用markNeedsPaint，RenderOpacity中是有一个paint方法的；</li></ul> 
<pre><code>  set padding(EdgeInsetsGeometry value) {
    assert(value != null);
    assert(value.isNonNegative);
    if (_padding == value)
      return;
    _padding = value;
    _markNeedResolution();
  }
</code></pre> 
<h4>3.3. Element</h4> 
<p><strong>我们来思考一个问题：</strong></p> 
<ul><li>之前我们写的大量的Widget在树结构中存在引用关系，但是Widget会被不断的销毁和重建，那么意味着这棵树非常不稳定；</li><li>那么由谁来维系整个Flutter应用程序的树形结构的稳定呢？</li><li>答案就是Element。</li><li>官方的描述：Element是一个Widget的实例，在树中详细的位置。</li></ul> 
<p><strong>Element什么时候创建？</strong></p> 
<p>在每一次创建Widget的时候，会创建一个对应的Element，然后将该元素插入树中。</p> 
<ul><li>Element保存着对Widget的引用；</li></ul> 
<p>在SingleChildRenderObjectWidget中，我们可以找到如下代码：</p> 
<ul><li>在Widget中，Element被创建，并且在创建时，将this（Widget）传入了；</li><li>Element就保存了对Widget的应用；</li></ul> 
<pre><code>  @override
  SingleChildRenderObjectElement createElement() =&gt; SingleChildRenderObjectElement(this);
</code></pre> 
<p>在创建完一个Element之后，Framework会调用mount方法来将Element插入到树中具体的位置：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/70/7e/Pi5xSBmL_o.png"></p> 
<p>mount方法</p> 
<p>在调用mount方法时，会同时使用Widget来创建RenderObject，并且保持对RenderObject的引用：</p> 
<ul><li>_renderObject = widget.createRenderObject(this);</li></ul> 
<pre><code class="language-Kotlin">  @override
  void mount(Element parent, dynamic newSlot) {
    super.mount(parent, newSlot);
    _renderObject = widget.createRenderObject(this);
    assert(() {
      _debugUpdateRenderObjectOwner();
      return true;
    }());
    assert(_slot == newSlot);
    attachRenderObject(newSlot);
    _dirty = false;
  }
</code></pre> 
<p>但是，如果你去看类似于Text这种组合类的Widget，它也会执行mount方法，但是mount方法中并没有调用createRenderObject这样的方法。</p> 
<ul><li>我们发现ComponentElement最主要的目的是挂载之后，调用_firstBuild方法</li></ul> 
<pre><code class="language-Kotlin">  @override
  void mount(Element parent, dynamic newSlot) {
    super.mount(parent, newSlot);
    assert(_child == null);
    assert(_active);
    _firstBuild();
    assert(_child != null);
  }

  void _firstBuild() {
    rebuild();
  }
</code></pre> 
<p><strong>如果是一个StatefulWidget，则创建出来的是一个StatefulElement</strong></p> 
<p>我们来看一下StatefulElement的构造器：</p> 
<ul><li>调用widget的createState()</li><li>所以StatefulElement对创建出来的State是有一个引用的</li><li>而_state又对widget有一个引用</li></ul> 
<pre><code>  StatefulElement(StatefulWidget widget)
      : _state = widget.createState(),
  ....省略代码
  _state._widget = widget;
</code></pre> 
<p>而调用build的时候，本质上调用的是_state中的build方法：</p> 
<pre><code>Widget build() =&gt; state.build(this);
</code></pre> 
<h4>3.4. build的context是什么</h4> 
<p>在StatelessElement中，我们发现是将this传入，所以本质上BuildContext就是当前的Element</p> 
<pre><code>Widget build() =&gt; widget.build(this);
</code></pre> 
<p>我们来看一下继承关系图：</p> 
<ul><li>Element是实现了BuildContext类（隐式接口）</li></ul> 
<pre><code>abstract class Element extends DiagnosticableTree implements BuildContext
</code></pre> 
<p>在StatefulElement中，build方法也是类似，调用state的build方式时，传入的是this</p> 
<pre><code>Widget build() =&gt; state.build(this);
</code></pre> 
<h4>3.5. 创建过程小结</h4> 
<p>Widget只是描述了配置信息：</p> 
<ul><li>其中包含createElement方法用于创建Element</li><li>也包含createRenderObject，但是不是自己在调用</li></ul> 
<p>Element是真正保存树结构的对象：</p> 
<ul><li>创建出来后会由framework调用mount方法；</li><li>在mount方法中会调用widget的createRenderObject对象；</li><li>并且Element对widget和RenderObject都有引用；</li></ul> 
<p>RenderObject是真正渲染的对象：</p> 
<ul><li>其中有<code>markNeedsLayout</code> <code>performLayout</code> <code>markNeedsPaint</code> <code>paint</code>等方法</li></ul> 
<hr> 
<h4>一文读懂Flutter的三棵树渲染机制和原理</h4> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/b4/11/Dhyrjc3M_o.png"><br> Flutter是一个优秀的UI框架，借助它开箱即用的Widgets我们能够构建出漂亮和高性能的用户界面。那这些Widgets到底是如何工作的又是如何完成渲染的。</p> 
<p> 在本文中呢，我们就来探析Widgets背后的故事-Flutter渲染机制之三棵树。</p> 
<p>什么是三棵树？</p> 
<p>在Flutter中和Widgets一起协同工作的还有另外两个伙伴：Elements和RenderObjects；由于它们都是有着树形结构，所以经常会称它们为三棵树。</p> 
<p>Widget：Widget是Flutter的核心部分，是用户界面的不可变描述。做Flutter开发接触最多的就是Widget，可以说Widget撑起了Flutter的半边天；<br> Element：Element是实例化的 Widget 对象，通过 Widget 的 createElement() 方法，是在特定位置使用 Widget配置数据生成；<br> RenderObject：用于应用界面的布局和绘制，保存了元素的大小，布局等信息；<br> 初次运行时的三棵树的<br> 初步认识了三棵树之后，那Flutter是如何创建布局的？以及三棵树之间他们是如何协同的呢？接下来就让我们通过一个简单的例子来剖析下它们内在的协同关系：</p> 
<pre><code class="language-Dart">class ThreeTree extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.red,
      child: Container(color: Colors.blue)
    );
  }
}</code></pre> 
<p><br> 上面这个例子很简单，它由三个Widget组成：ThreeTree、Container、Text。那么当Flutter的runApp()方法被调用时会发生什么呢？</p> 
<p>当runApp()被调用时，第一时间会在后台发生以下事件：</p> 
<p>Flutter会构建包含这三个Widget的Widgets树；<br> Flutter遍历Widget树，然后根据其中的Widget调用createElement()来创建相应的Element对象，最后将这些对象组建成Element树；<br> 接下来会创建第三个树，这个树中包含了与Widget对应的Element通过createRenderObject()创建的RenderObject；<br> 下图是Flutter经过这三个步骤后的状态：</p> 
<p><img alt="Flutter三棵树" src="https://images2.imgbox.com/65/ae/jkAEQCli_o.png"></p> 
<p> 从图中可以看出Flutter创建了三个不同的树，一个对应着Widget，一个对应着Element，一个对应着RenderObject。每一个Element中都有着相对应的Widget和RenderObject的引用。可以说Element是存在于可变Widget树和不可变RenderObject树之间的桥梁。Element擅长比较两个Object，在Flutter里面就是Widget和RenderObject。它的作用是配置好Widget在树中的位置，并且保持对于相对应的RenderObject和Widget的引用。</p> 
<p>三棵树的作用</p> 
<p><br> 简而言之是为了性能，为了复用Element从而减少频繁创建和销毁RenderObject。因为实例化一个RenderObject的成本是很高的，频繁的实例化和销毁RenderObject对性能的影响比较大，所以当Widget树改变的时候，Flutter使用Element树来比较新的Widget树和原来的Widget树：</p> 
<pre><code class="language-Dart">//framework.dart
 @protected
  Element updateChild(Element child, Widget newWidget, dynamic newSlot) {
    if (newWidget == null) {
      if (child != null)
        deactivateChild(child);
      return null;
    }
    Element newChild;
    if (child != null) {
      assert(() {
        final int oldElementClass = Element._debugConcreteSubtype(child);
        final int newWidgetClass = Widget._debugConcreteSubtype(newWidget);
        hasSameSuperclass = oldElementClass == newWidgetClass;
        return true;
      }());
      if (hasSameSuperclass &amp;&amp; child.widget == newWidget) {
        if (child.slot != newSlot)
          updateSlotForChild(child, newSlot);
        newChild = child;
      } else if (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget)) {
        if (child.slot != newSlot)
          updateSlotForChild(child, newSlot);
        child.update(newWidget);
        assert(child.widget == newWidget);
        assert(() {
          child.owner._debugElementWasRebuilt(child);
          return true;
        }());
        newChild = child;
      } else {
        deactivateChild(child);
        assert(child._parent == null);
        newChild = inflateWidget(newWidget, newSlot);
      }
    } else {
      newChild = inflateWidget(newWidget, newSlot);
    }

    assert(() {
      if (child != null)
        _debugRemoveGlobalKeyReservation(child);
      final Key key = newWidget?.key;
      if (key is GlobalKey) {
        key._debugReserveFor(this, newChild);
      }
      return true;
    }());

    return newChild;
  }
...
  static bool canUpdate(Widget oldWidget, Widget newWidget) {
    return oldWidget.runtimeType == newWidget.runtimeType
        &amp;&amp; oldWidget.key == newWidget.key;
  }</code></pre> 
<p><br><br> 如果某一个位置的Widget和新Widget不一致，才需要重新创建Element；<br> 如果某一个位置的Widget和新Widget一致时(两个widget相等或runtimeType与key相等)，则只需要修改RenderObject的配置，不用进行耗费性能的RenderObject的实例化工作了；<br> 因为Widget是非常轻量级的，实例化耗费的性能很少，所以它是描述APP的状态（也就是configuration）的最好工具；<br> 重量级的RenderObject（创建十分耗费性能）则需要尽可能少的创建，并尽可能的复用；<br> 看到这里你是否会觉得整个Flutter APP就像是一个RecycleView呢？</p> 
<p>因为在框架中，Element是被抽离开来的，所以你不需要经常和它们打交道。每个Widget的build（BuildContext context）方法中传递的context就是实现了BuildContext接口的Element。</p> 
<p>更新时的三棵树<br> 因为Widget是不可变的，当某个Widget的配置改变的时候，整个Widget树都需要被重建。例如当我们改变一个Container的颜色为橙色的时候，框架就会触发一个重建整个Widget树的动作。因为有了Element的存在，Flutter会比较新的Widget树中的第一个Widget和之前的Widget。接下来比较Widget树中第二个Widget和之前Widget，以此类推，直到Widget树比较完成。</p> 
<pre><code class="language-Dart">class ThreeTree extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.orange,
      child: Container(color: Colors.blue,),
    );
  }
}</code></pre> 
<p>Flutter遵循一个最基本的原则：判断新的Widget和老的Widget是否是同一个类型：</p> 
<p>如果不是同一个类型，那就把Widget、Element、RenderObject分别从它们的树（包括它们的子树）上移除，然后创建新的对象；<br> 如果是一个类型，那就仅仅修改RenderObject中的配置，然后继续向下遍历；<br> 在我们的例子中，ThreeTree Widget是和原来一样的类型，它的配置也是和原来的ThreeTreeRender一样的，所以什么都不会发生。下一个节点在Widget树中是Container Widget，它的类型和原来是一样的，但是它的颜色变化了，所以RenderObject的配置也会发生对应的变化，然后它会重新渲染，其他的对象都保持不变。</p> 
<p><img alt="Flutter三棵树" src="https://images2.imgbox.com/a1/10/bEwUSI4b_o.png"> </p> 
<p>注意这三个树，配置发生改变之后，Element和RenderObject实例没有发生变化。</p> 
<p>上面这个过程是非常快的，因为Widget的不变性和轻量级使得他能快速的创建，这个过程中那些重量级的RenderObject则是保持不变的，直到与其相对应类型的Widget从Widget树中被移除。</p> 
<p>当Widget的类型发生改变时</p> 
<pre><code class="language-Dart">class ThreeTree extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.orange,
      child: FlatButton(
        onPressed: () {},
        child: Text('三棵树'),
      ),
    );
  }
}</code></pre> 
<p>和刚才流程一样，Flutter会从新Widget树的顶端向下遍历，与原有树中的Widget类型进行对比。</p> 
<p><img alt="Flutter三棵树" src="https://images2.imgbox.com/21/87/HCaV4yQY_o.png"></p> 
<p> 因为FlatButton的类型与Element树中相对应位置的Element的类型不同，Flutter将会从各自的树上删除这个Element和相对应的ContainerRender，然后Flutter将会重建与FlatButton相对应的Element和RenderObject。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c5/f0/SW5P1KDF_o.jpg"></p> 
<p>当新的RenderObject树被重建后将会计算布局，然后绘制在屏幕上面。Flutter内部使用了很多优化方法和缓存策略来处理，所以你不需要手动来处理这些。</p> 
<p>以上便是Flutter的整体渲染机制，可以看出Flutter利用了三棵树很巧妙的解决的性能的问题。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad9fd55fc58662902df7a4e4e6ebdeba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 几种设置ImageView的图片的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90ef048cb9bd354f49f5c56d1d2aa07c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL server下载 2023年3月7日最新教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>