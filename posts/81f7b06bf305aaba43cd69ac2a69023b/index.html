<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>模型选择&amp;&amp;模型评估 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="模型选择&amp;&amp;模型评估" />
<meta property="og:description" content="文章目录 一、为什么要进行模型选择？二、模型选择1.正则化2.交叉验证 三、模型评估 一、为什么要进行模型选择？ 机器学习的三要素是模型、策略、算法。模型的训练也是尤为重要的一环。应用某种策略、使用某种算法对假设空间里的模型进行优化后，如果我们得到了不止一个模型，应该选择哪一个模型作为最终使用的模型？选择了最终模型后，其效果究竟如何？这就是模型选择和模型评估的内容。
二、模型选择 模型选择(model selection)有两层含义：一是在假设空间上训练得到的模型可能不止一个，需要从中进行选择；二是对于一个具体问题，我们可能希望尝试不同方法，于是就有了不同的模型，在这些模型训练结束后，我们需要决定使用哪一个，但这种模型选择往往需要结合模型评估方法，因为对于某种归纳偏好，不同方法下的不同模型的实现各不相同，只能根据在测试集上的最终表现效果来选择。
机器学习方法的三要素与第一层模型选择的关系：
多种机器学习方法的模型选择示意图：
也就是说，对于每一种方法，都要经历三要素及内部的模型选择，再进行模型评估和最终选择。
下面介绍监督学习中两大类模型选择的方法：正则化和交叉验证。
1.正则化 正则化(regularization)它与结构风险最小化等价，用于规避模型过拟合的问题，在模型选择中，正则化方法也同样被用来对模型复杂度进行惩罚，避免模型由于过度追求训练集上的效果而过度偏向复杂模型，导致过拟合，降低泛化能力。下图说明了模型复杂度和泛化能力之间的关系：
2.交叉验证 在样本量足够大的理想情况下，应当把数据集分割为三部分：训练集(training set)、验证集(validation set)和测试集(testing set)，分别用于模型训练、模型选择和模型评估，用于评估模型泛化能力的测试集只出现在最后的模型评估环节。但很多时候数据不够充足，这种时候可以取消验证集，采用交叉验证方法，通过反复划分训练集和测试集来避免用同一批数据训练和评估一个模型，相当于将验证集和测试集合二为一了。
交叉验证(cross validation)指的是对有限的数据集进行随机划分，利用分割后的部分组成训练集和测试集，进而重复进行模型的训练、选择和评估。常用的交叉验证法有三种：
简单交叉验证/留出法(hold-out)：将数据集按一定比例随机分为两部分：训练集和测试集，分别在其上训练和测试所有备选模型，选出测试结果最好的，这相当于用模型评估代替了模型选择，直接砍掉验证集来增加其余两个集合的样本量，简单粗暴；
K折交叉验证(k-fold cross validation)：将数据集随机划分为K个大小相同或基本相同的子集，分别把每一个子集作为测试集，其余 K-1个子集作为训练集，就得到了K 组不同的训练、测试集，在这K组训练、测试集上训练并测试每一种模型，选择平均测试误差最小的模型；有时为了避免单次随机划分的特殊性，还会进行多次随机划分，将多个交叉验证的结果再进行一次平均；
留一交叉验证(leave-one-out cross
validation)：K折交叉验证的特例，将K取为样本量N，也即把每个样本单独作为测试集，其余样本作为训练集。这种方法的计算量较大，一般仅用于数据稀少的情况。
当样本量实在过小时，可以考虑采用有放回抽样，抽取次数和原数据集样本量相等，形成一个新的样本作为训练集，而将未被抽到过的样本全体作为测试集，这种在样本量较小的情况下构造样本的想法来源于统计学中的自助法(bootstrapping)。
三、模型评估 模型评估(model assessment)是指对于一种具体方法输出的最终模型，使用一些指标和方法来评价它的泛化能力。这一步骤通常在模型训练和模型选择之后，正式部署模型之前。模型评估方法不针对模型本身，只针对问题和数据，因此可以用来评价来自不同方法的模型的泛化能力，进行用于部署的最终模型的选择。
我们评估一个模型，最关心的是它的泛化能力，对于监督学习问题，泛化能力可以用泛化误差(generalization error)来衡量，泛化误差指的是模型在训练集以外的数据上的风险函数，用数学语言表示为：
，其中 f^表示一个具体的模型，x*y表示整个样本空间或者排除训练集的整个样本空间。泛化误差越小意味着模型在样本空间上的期望损失越小，模型的泛化能力越强。
需要注意的一点是，模型评估使用的损失函数不一定是训练时的策略中使用的损失函数，但对于许多模型，两者是相同的。 但很显然，我们没法获得样本空间的总体概率分布，所以泛化误差不可实际获得，实际应用中是通过如下定义的测试误差来衡量模型的泛化能力的：
测试误差(testing error)：训练好的模型在测试集上的经验损失；训练误差(training error)：模型在训练集上的经验损失； 如果采用0-1损失函数，即 [公式]，则测试误差就变为了常用的错误率(error rate)，即 [公式]，这是分类问题常用的评估指标之一，表示模型错分的测试样本的比例，一个相应的指标是准确率/精度(accuracy)，表示模型正确分类的测试样本的比例，即 [公式]，很显然，错误率 &#43; 准确率 = 1.
如果采用平方损失函数，即 [公式]，则测试误差就变为了样本的均方误差(mean squared error)，这是回归问题常用的评估指标之一。
理论上，对于一种机器学习方法，可以估计其能得到的模型的泛化误差上界，从而对其泛化能力有一个整体的认识，但这个界的估计非常复杂，机器学习的理论研究还在探索阶段。 下面介绍机器学习中一个重要的关系：偏差—方差权衡。
偏差—方差权衡
在统计学中，估计的均方误差可以分解为方差和偏差平方的和，对于形如 [公式] 的监督学习问题，也可以进行类似的分解，假设我们得到了 [公式] 的一个估计 [公式]，注意到 [公式]，以及随机误差与解释变量独立、与训练集的选择独立，则预测的均方误差[公式] 可以进行如下分解：
[公式]
进一步地，考虑到 [公式] 是在一个特定的训练集上训练得到的，记训练集为 [公式]，则 [公式] 还应是 [公式] 的函数，因此应记作 [公式]，因此有 [公式]，对于固定的 [公式]，可以证明有分解式：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/81f7b06bf305aaba43cd69ac2a69023b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-06T08:38:01+08:00" />
<meta property="article:modified_time" content="2022-05-06T08:38:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">模型选择&amp;&amp;模型评估</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_8" rel="nofollow">一、为什么要进行模型选择？</a></li><li><a href="#_12" rel="nofollow">二、模型选择</a></li><li><ul><li><a href="#1_25" rel="nofollow">1.正则化</a></li><li><a href="#2_34" rel="nofollow">2.交叉验证</a></li></ul> 
  </li><li><a href="#_55" rel="nofollow">三、模型评估</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_8"></a>一、为什么要进行模型选择？</h2> 
<p>机器学习的三要素是模型、策略、算法。模型的训练也是尤为重要的一环。应用某种策略、使用某种算法对假设空间里的模型进行优化后，如果我们得到了不止一个模型，应该选择哪一个模型作为最终使用的模型？选择了最终模型后，其效果究竟如何？这就是模型选择和模型评估的内容。</p> 
<h2><a id="_12"></a>二、模型选择</h2> 
<p>模型选择(model selection)有两层含义：一是在假设空间上训练得到的模型可能不止一个，需要从中进行选择；二是对于一个具体问题，我们可能希望尝试不同方法，于是就有了不同的模型，在这些模型训练结束后，我们需要决定使用哪一个，但这种模型选择往往需要结合模型评估方法，因为对于某种归纳偏好，不同方法下的不同模型的实现各不相同，只能根据在测试集上的最终表现效果来选择。<br> 机器学习方法的三要素与第一层模型选择的关系：</p> 
<p><img src="https://images2.imgbox.com/16/03/I756uRKB_o.jpg" alt="在这里插入图片描述">多种机器学习方法的模型选择示意图：</p> 
<p><img src="https://images2.imgbox.com/e6/18/wBQM7oVt_o.jpg" alt="在这里插入图片描述"></p> 
<p>也就是说，对于每一种方法，都要经历三要素及内部的模型选择，再进行模型评估和最终选择。</p> 
<p>下面介绍监督学习中两大类模型选择的方法：正则化和交叉验证。</p> 
<h3><a id="1_25"></a>1.正则化</h3> 
<p>正则化(regularization)它与结构风险最小化等价，用于规避模型过拟合的问题，在模型选择中，正则化方法也同样被用来对模型复杂度进行惩罚，避免模型由于过度追求训练集上的效果而过度偏向复杂模型，导致过拟合，降低泛化能力。下图说明了模型复杂度和泛化能力之间的关系：<br> <img src="https://images2.imgbox.com/cb/cf/hlNb41ho_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="2_34"></a>2.交叉验证</h3> 
<p>在样本量足够大的理想情况下，应当把数据集分割为三部分：训练集(training set)、验证集(validation set)和测试集(testing set)，分别用于模型训练、模型选择和模型评估，用于评估模型泛化能力的测试集只出现在最后的模型评估环节。但很多时候数据不够充足，这种时候可以取消验证集，采用交叉验证方法，通过反复划分训练集和测试集来避免用同一批数据训练和评估一个模型，相当于将验证集和测试集合二为一了。</p> 
<p>交叉验证(cross validation)指的是对有限的数据集进行随机划分，利用分割后的部分组成训练集和测试集，进而重复进行模型的训练、选择和评估。常用的交叉验证法有三种：</p> 
<ol><li> <p>简单交叉验证/留出法(hold-out)：将数据集按一定比例随机分为两部分：训练集和测试集，分别在其上训练和测试所有备选模型，选出测试结果最好的，这相当于用模型评估代替了模型选择，直接砍掉验证集来增加其余两个集合的样本量，简单粗暴；</p> </li><li> <p>K折交叉验证(k-fold cross validation)：将数据集随机划分为K个大小相同或基本相同的子集，分别把每一个子集作为测试集，其余 K-1个子集作为训练集，就得到了K 组不同的训练、测试集，在这K组训练、测试集上训练并测试每一种模型，选择平均测试误差最小的模型；有时为了避免单次随机划分的特殊性，还会进行多次随机划分，将多个交叉验证的结果再进行一次平均；</p> </li><li> <p>留一交叉验证(leave-one-out cross<br> validation)：K折交叉验证的特例，将K取为样本量N，也即把每个样本单独作为测试集，其余样本作为训练集。这种方法的计算量较大，一般仅用于数据稀少的情况。</p> </li></ol> 
<p>当样本量实在过小时，可以考虑采用有放回抽样，抽取次数和原数据集样本量相等，形成一个新的样本作为训练集，而将未被抽到过的样本全体作为测试集，这种在样本量较小的情况下构造样本的想法来源于统计学中的自助法(bootstrapping)。</p> 
<h2><a id="_55"></a>三、模型评估</h2> 
<p>模型评估(model assessment)是指对于一种具体方法输出的最终模型，使用一些指标和方法来评价它的泛化能力。这一步骤通常在模型训练和模型选择之后，正式部署模型之前。模型评估方法不针对模型本身，只针对问题和数据，因此可以用来评价来自不同方法的模型的泛化能力，进行用于部署的最终模型的选择。</p> 
<p>我们评估一个模型，最关心的是它的泛化能力，对于监督学习问题，泛化能力可以用泛化误差(generalization error)来衡量，泛化误差指的是模型在训练集以外的数据上的风险函数，用数学语言表示为：<br> <img src="https://images2.imgbox.com/f9/f9/9YihZmuf_o.jpg" alt="在这里插入图片描述"></p> 
<p>，其中 f^表示一个具体的模型，x*y表示整个样本空间或者排除训练集的整个样本空间。泛化误差越小意味着模型在样本空间上的期望损失越小，模型的泛化能力越强。</p> 
<pre><code>需要注意的一点是，模型评估使用的损失函数不一定是训练时的策略中使用的损失函数，但对于许多模型，两者是相同的。
</code></pre> 
<p>但很显然，我们没法获得样本空间的总体概率分布，所以泛化误差不可实际获得，实际应用中是通过如下定义的测试误差来衡量模型的泛化能力的：</p> 
<pre><code>测试误差(testing error)：训练好的模型在测试集上的经验损失；训练误差(training error)：模型在训练集上的经验损失；
</code></pre> 
<p>如果采用0-1损失函数，即 [公式]，则测试误差就变为了常用的错误率(error rate)，即 [公式]，这是分类问题常用的评估指标之一，表示模型错分的测试样本的比例，一个相应的指标是准确率/精度(accuracy)，表示模型正确分类的测试样本的比例，即 [公式]，很显然，错误率 + 准确率 = 1.</p> 
<p>如果采用平方损失函数，即 [公式]，则测试误差就变为了样本的均方误差(mean squared error)，这是回归问题常用的评估指标之一。</p> 
<pre><code>理论上，对于一种机器学习方法，可以估计其能得到的模型的泛化误差上界，从而对其泛化能力有一个整体的认识，但这个界的估计非常复杂，机器学习的理论研究还在探索阶段。 
</code></pre> 
<p>下面介绍机器学习中一个重要的关系：偏差—方差权衡。<br> 偏差—方差权衡</p> 
<p>在统计学中，估计的均方误差可以分解为方差和偏差平方的和，对于形如 [公式] 的监督学习问题，也可以进行类似的分解，假设我们得到了 [公式] 的一个估计 [公式]，注意到 [公式]，以及随机误差与解释变量独立、与训练集的选择独立，则预测的均方误差[公式] 可以进行如下分解：</p> 
<p>[公式]</p> 
<p>进一步地，考虑到 [公式] 是在一个特定的训练集上训练得到的，记训练集为 [公式]，则 [公式] 还应是 [公式] 的函数，因此应记作 [公式]，因此有 [公式]，对于固定的 [公式]，可以证明有分解式：</p> 
<p>[公式]</p> 
<pre><code>由于 [公式] 与 [公式] 无关，故容易得到交叉项的期望等于0，且最后一个平方项为常数。
</code></pre> 
<p>故 [公式] 可以分解为：</p> 
<p>[公式]</p> 
<p>而如果对于固定的 [公式]，[公式] 的观测值为 [公式]，随机误差为 [公式]，则分解更加清晰：</p> 
<p>[公式]</p> 
<p>这就是所谓的偏差—方差分解(bias-variance decomposition)。其中随机误差的方差与观测值无关，可以简化为 [公式]。</p> 
<p>由这个分解式可以看出，对于任何一种机器学习方法，预测的均方误差都不可能低于系统随机误差的方差。</p> 
<p>在什上面的偏差—方差分解中，偏差和方差都不是针对随机变量，而是针对训练集的选取而言的，偏差意味着在所有可能的训练集上预测值的平均偏差，它度量了模型预测的精确度；方差意味着所有可能的训练集上预测值的方差，它度量了方法在不同训练集上的稳定性。我们当然希望得到既稳定又精确的模型，但遗憾的是，实验表明，两者的变化方向往往是相反的，随着模型复杂度的提升，模型能学到越来越多的训练集的特点，在每个训练集上都能预测得更准确，从而降低偏差，但也会变得更加依赖训练集，偏向过拟合，对不同训练集的差异过于敏感，导致方差上升；而若使用太简单的模型，又无法学习充分的规律，这样一来在所有训练集上都倾向于有较低的预测准确率，方差自然较低，但偏差会较大。这一现象被称为偏差—方差困境(bias-variance dilemma)，如下图所示。由于这种现象的存在，我们需要在偏差和方差之间进行一个权衡，这就是所谓的偏差—方差权衡(bias-variance trade-off)。</p> 
<p>在实际问题中，由于 [公式] 未知，模型的均方误差、偏差和方差不可能精确获得，但熟悉三者之间的关系，可以时刻提醒我们不要一味追求低偏差而忽略了可能带来的过拟合现象，这对于模型评估和选择有重要的参考价值，对模型性能的解释更是具有重要意义。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56c1f37dca1fe8eb931eca6214aa24cf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[c&#43;&#43;11] using用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cacf0799bfa47c3372035f8ec4cd6c82/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">主流浏览器的内核</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>