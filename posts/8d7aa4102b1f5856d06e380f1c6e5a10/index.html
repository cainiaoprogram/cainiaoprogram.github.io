<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>因 Redis Key 命令不规范，导致熬了一个通宵才把Key删完了！ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="因 Redis Key 命令不规范，导致熬了一个通宵才把Key删完了！" />
<meta property="og:description" content="点击蓝色“架构文摘”关注我哟
加个“星标”，每天上午 09:25，干货推送！
来源：http://dwz.date/cmSG
前言 由于有一条业务线不理想，高层决定下架业务。对于我们技术团队而言，其对应的所有服务器资源和其他相关资源都要释放。释放了8台应用服务器；
1台es服务器；
删除分布式定时任务中心相关的业务任务；
备份并删除MySQL数据库；
删除Redis中相关的业务缓存数据。
CTO指名点姓让我带头冲锋，才扣了我绩效……好吧，冲~
其他都还好，不多时就解决了。唯独这删除Redis中的数据，害得我又熬了一个通宵，真是折煞我也！
难点分析 共用Redis服务集群 由于这条业务线的数据在Redis大概在3G左右，完全没必要单独建一个Redis服务集群，本着能节约就节约的态度，当初就决定和其他项目共享一个集群（这个集群配置：16个节点，128G内存，还算豪华吧~）集群配置如下：
在这种共用集群的情况下，导致无法简单粗暴的释放。因此只能选择删除Key的方式。
Key命名不规范 要删除Key，首先就要精准的定位出哪些Key需要删除，如果勿删Key，会影响到其他服务正常运转！如果Key本身设置了过期时间，但有些数据需是持久化的。然而那该死的项目经理一直催项目进度，导致开发人员在开发过程中很多地方都没有设计到位，比如Redis
Key散落在项目代码的每个角落；比如命名不是很规范。真不知道是怎么review代码！哦，想必是没有时间review，那该死的项目经理…… 我随便截个支付服务中的Key命名：
怎么样？是不是觉得我们开发人员写的代码很low~别笑，在实际工作中，还有比这更low的！希望你别遇到，不然真的很痛苦~
解决思路 经过以上的分析，我们简单归纳如下：
我们真正关心的是那些未设置过期时间的Key
不能误删除Key，否则下个月绩效也没了
由于Key的命名及使用及其不规范，导致Key的定位难度很大
看来，通过scan命令扫描匹配Key的方式行不通了。只能通过人肉搜索了~ 幸而Idea的搜索大法好，这个项目中使用的是spring-boot-starter-data-redis.因此我通过搜索RedisTemplate和StringRedisTemplate定位所有操作redis的代码，具体步骤如下：
通过这些代码统计出Key的前缀并录入到文本中； 通过python脚本把载入文中中的的Key并在后面加上“*”通配符； 通过python脚本通过scan命令扫描出这些key； 为了便于检查，我们并没有直接使用del命令删除key，在删除key之前，先通过debug object
key的方式得到其序列化的长度，再执行删除并返回序列化长度。这样，我们就可以统计出所有key的序列化长度来得到我们释放的空间大小。关键代码如下：
def get_key(rdbConn,start): try: keys_list = rdbConn.scan(start,count=2000) return keys_list except Exception,e: print e &#39;&#39;&#39; Redis DEBUG OBJECT command got key info &#39;&#39;&#39; def get_key_info(rdbConn,keyName): try: rpiple = rdbConn.pipeline() rpiple.type(keyName) rpiple.debug_object(keyName) rpiple.ttl(keyName) key_info_list = rpiple.execute() return key_info_list except Exception,e: print &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8d7aa4102b1f5856d06e380f1c6e5a10/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-29T08:49:40+08:00" />
<meta property="article:modified_time" content="2020-08-29T08:49:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">因 Redis Key 命令不规范，导致熬了一个通宵才把Key删完了！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align: center">点击蓝色“架构文摘”关注我哟</p> 
 <p style="text-align: center">加个“星标”，每天上午 09:25，干货推送！</p> 
 <p style="text-align: center"><img width="100%" src="https://images2.imgbox.com/e7/f2/fD5XNccm_o.png"></p> 
 <p style="text-align: left">来源：http://dwz.date/cmSG</p> 
 <h4>前言</h4> 
 <p>由于有一条业务线不理想，高层决定下架业务。对于我们技术团队而言，其对应的所有服务器资源和其他相关资源都要释放。释放了8台应用服务器；</p> 
 <ul><li><p>1台es服务器；</p></li><li><p>删除分布式定时任务中心相关的业务任务；</p></li><li><p>备份并删除MySQL数据库；</p></li><li><p>删除Redis中相关的业务缓存数据。</p></li></ul> 
 <p>CTO指名点姓让我带头冲锋，才扣了我绩效……好吧，冲~</p> 
 <p>其他都还好，不多时就解决了。唯独这删除Redis中的数据，害得我又熬了一个通宵，真是折煞我也！</p> 
 <h4>难点分析</h4> 
 <h5>共用Redis服务集群</h5> 
 <p>由于这条业务线的数据在Redis大概在3G左右，完全没必要单独建一个Redis服务集群，本着能节约就节约的态度，当初就决定和其他项目共享一个集群（这个集群配置：16个节点，128G内存，还算豪华吧~）集群配置如下：</p> 
 <img src="https://images2.imgbox.com/cd/12/wNIAz4Pf_o.png" title=""> 
 <p>在这种共用集群的情况下，导致无法简单粗暴的释放。因此只能选择删除Key的方式。</p> 
 <h5>Key命名不规范</h5> 
 <p>要删除Key，首先就要精准的定位出哪些Key需要删除，如果勿删Key，会影响到其他服务正常运转！如果Key本身设置了过期时间，但有些数据需是持久化的。然而那该死的项目经理一直催项目进度，导致开发人员在开发过程中很多地方都没有设计到位，比如Redis<br>Key散落在项目代码的每个角落；比如命名不是很规范。真不知道是怎么review代码！哦，想必是没有时间review，那该死的项目经理……  <br>我随便截个支付服务中的Key命名：</p> 
 <img src="https://images2.imgbox.com/28/c8/Rv6vaYXP_o.png" title=""> 
 <p>怎么样？是不是觉得我们开发人员写的代码很low~别笑，在实际工作中，还有比这更low的！希望你别遇到，不然真的很痛苦~</p> 
 <h4>解决思路</h4> 
 <p>经过以上的分析，我们简单归纳如下：</p> 
 <ul><li><p>我们真正关心的是那些未设置过期时间的Key</p></li><li><p>不能误删除Key，否则下个月绩效也没了</p></li><li><p>由于Key的命名及使用及其不规范，导致Key的定位难度很大</p></li></ul> 
 <p>看来，通过scan命令扫描匹配Key的方式行不通了。只能通过人肉搜索了~  <br>幸而Idea的搜索大法好，这个项目中使用的是spring-boot-starter-data-redis.因此我通过搜索RedisTemplate和StringRedisTemplate定位所有操作redis的代码，具体步骤如下：</p> 
 <ol><li><p>通过这些代码统计出Key的前缀并录入到文本中； </p></li><li><p>通过python脚本把载入文中中的的Key并在后面加上“*”通配符； </p></li><li><p>通过python脚本通过scan命令扫描出这些key； </p></li><li><p>为了便于检查，我们并没有直接使用del命令删除key，在删除key之前，先通过debug object</p></li></ol> 
 <p>key的方式得到其序列化的长度，再执行删除并返回序列化长度。这样，我们就可以统计出所有key的序列化长度来得到我们释放的空间大小。关键代码如下：</p> 
 <pre class="has"><code class="language-go">    def get_key(rdbConn,start):
        try:
        keys_list = rdbConn.scan(start,count=2000)
        return keys_list
        except Exception,e:
        print e

    ''' Redis DEBUG OBJECT command got key info '''
    def get_key_info(rdbConn,keyName):
        try:
        rpiple = rdbConn.pipeline()
        rpiple.type(keyName)
        rpiple.debug_object(keyName)
        rpiple.ttl(keyName)
        key_info_list = rpiple.execute()
        return key_info_list
        except Exception,e:
        print "INFO : ",e

    def redis_key_static(key_info_list):
        keyType = key_info_list[0]
        keySize = key_info_list[1]['serializedlength']
        keyTtl = key_info_list[2]
        key_size_static(keyType,keySize,keyTtl)
</code></pre> 
 <p>通过以上方式，能够统计出究竟释放了多少内存了。</p> 
 <p>由于这个集群是有这么接近7千万个key：</p> 
 <img src="https://images2.imgbox.com/f5/ac/TbtBDbU6_o.png" title=""> 
 <p>因此，等到了第二天天亮，我睡眼朦胧的看了一下，终于删除完毕了，时间07:13…早高峰即将来临……</p> 
 <h4>知耻而后勇</h4> 
 <p>从来没有经历过因业务下线而清除资源的经验。这次事情真心让我觉得细微之处见真功夫的道理。如果一开始我们就能够遵循开发规范来使用和设计redis key，也不至于浪费这么多时间。为了让key的命名和使用更加规范，以及今后避免再次遇到这种情况，下午睡醒之后，我就在redis公共组件库里面添加了一个配置和自定义了key序列化，代码如下：</p> 
 <pre class="has"><code class="language-go">    @ConfigurationProperties(prefix = "spring.redis.prefix")
    public class RedisKeyPrefixProperties {
        private Boolean enable = Boolean.TRUE;
        private String key;
        public Boolean getEnable() {
            return enable;
        }
        public void setEnable(Boolean enable) {
            this.enable = enable;
        }
        public String getKey() {
            return key;
        }
        public void setKey(String key) {
            this.key = key;
        }
    }
</code></pre> 
 <pre class="has"><code class="language-go">    /**
     * @desc 对字符串序列化新增前缀
     * @author create by liming sun on 2020-07-21 14:09:51
     */
    public class PrefixStringKeySerializer extends StringRedisSerializer {
        private Charset charset = StandardCharsets.UTF_8;
        private RedisKeyPrefixProperties prefix;

        public PrefixStringKeySerializer(RedisKeyPrefixProperties prefix) {
            super();
            this.prefix = prefix;
        }

        @Override
        public String deserialize(@Nullable byte[] bytes) {
            String saveKey = new String(bytes, charset);
            if (prefix.getEnable() != null &amp;&amp; prefix.getEnable()) {
                String prefixKey = spliceKey(prefix.getKey());
                int indexOf = saveKey.indexOf(prefixKey);
                if (indexOf &gt; 0) {
                    saveKey = saveKey.substring(indexOf);
                }
            }
            return (saveKey.getBytes() == null ? null : saveKey);
        }

        @Override
        public byte[] serialize(@Nullable String key) {
            if (prefix.getEnable() != null &amp;&amp; prefix.getEnable()) {
                key = spliceKey(prefix.getKey()) + key;
            }
            return (key == null ? null : key.getBytes(charset));
        }

        private String spliceKey(String prefixKey) {
            if (StringUtils.isNotBlank(prefixKey) &amp;&amp; !prefixKey.endsWith(":")) {
                prefixKey = prefixKey + "::";
            }
            return prefixKey;
        }
    }
</code></pre> 
 <h4>使用效果</h4> 
 <p>为了避免再次发生这种工作低效而又不得不做的事情，我们在开发规范中规定，新项目中redis的使用必须设置此配置，前缀就设置为：项目编号。另外，一个模块中的key必须统一定义在二方库的RedisKeyConstant类中。配置如下：</p> 
 <pre class="has"><code class="language-go">    spring: 
        redis: 
            prefix:
                enable: true
                key: E00P01
</code></pre> 
 <pre class="has"><code class="language-go">    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        // 支持key前缀设置的key Serializer
        redisTemplate.setKeySerializer(new PrefixStringKeySerializer());
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return redisTemplate;
    }
</code></pre> 
 <p>通过以上方式，我们至少可以从项目维度来区分出key，避免了多个项目之间共用同一个集群时而导致重复key的问题。从项目维度对key进行了划分。更方便管理和运维。如果对于key的管理粒度要求更细，我们甚至可以细化到具体业务维度。我们在测试环境进行了压测，增加key前缀对redis性能几乎没有影响。性能方面能接受。</p> 
 <h4>总结</h4> 
 <p>通过本次事情，我发现对于大多数开发者而言，差距其实不在于智力，而是在于态度。比如这次事件暴露出来的问题：大家都知道要遵循开发规范，然而到了真正“打仗”的时候，负责这个项目的开发者却没有几个人能始终如一的做好这些细微之事。另外，reviewer的工作其实是极其重要的，他就像那“纪检委”，如果“纪检委”都放水睁一只眼闭一只眼，那麻烦可就大了！千里之提，毁于日常的点滴松懈啊~~~</p> 
 <p>经过这次事件之后，如果上天再给一次这样的机会，我一定会对项目经理说：接着奏乐，接着舞~</p> 
 <p>end</p> 
 <p>推荐阅读：</p> 
 <ul><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODIxNjYxNQ%3D%3D&amp;chksm=9f4773bda830faabd33c804a833275ffa33824bf7c99338392d2a1aaa73ea0c0d3626083ded6&amp;idx=1&amp;mid=2247491445&amp;scene=21&amp;sn=1ee24183530f36382423111d05de706a#wechat_redirect" rel="nofollow">如何保证缓存与数据库的双写一致性？</a><br></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODIxNjYxNQ%3D%3D&amp;chksm=9f47724fa830fb5929049327c3c5fc72f72bdf202706582a0791433bf2223209e6e798b69791&amp;idx=1&amp;mid=2247491207&amp;scene=21&amp;sn=243f42629345a5a6121a7fbc594d9625#wechat_redirect" rel="nofollow">亿级数据从 MySQL 到 Hbase 的三种同步方案与实践！</a><br></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODIxNjYxNQ%3D%3D&amp;chksm=9f4772b1a830fba79ca6e136e45ed5e8bba822934747ef09d8c3ffe2fc8fb80116ee717b5111&amp;idx=1&amp;mid=2247491193&amp;scene=21&amp;sn=780ee5479d8eec22dbd3f573589ae80e#wechat_redirect" rel="nofollow">终于有人把 Docker 讲清楚了，别再说不会 Docker 了！</a><br></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODIxNjYxNQ%3D%3D&amp;chksm=9f477a52a830f344a6e9cd916706c5bb9e88064baba787345feb076d70fd7a9fbfb16873fa9a&amp;idx=1&amp;mid=2247489178&amp;scene=21&amp;sn=7f7f730d290e8d09f1d83af674655f41#wechat_redirect" rel="nofollow">前后端分离模式下的权限设计方案</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODIxNjYxNQ%3D%3D&amp;chksm=9f477b63a830f275f4c3d1ddee3b352e67348069f142ecb3e1cf479c13054869f3a7e405cc5b&amp;idx=1&amp;mid=2247489451&amp;scene=21&amp;sn=ce18154070fc3d868750bfca5dd6e5ba#wechat_redirect" rel="nofollow">究竟什么是图数据库，它有哪些应用场景？</a></p></li></ul> 
 <p style="text-align: right"><img src="https://images2.imgbox.com/9b/62/cClUq3ay_o.png">如有收获，点个在看，诚挚感谢<img src="https://images2.imgbox.com/94/93/9wjLOjmX_o.png"></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/687fd19c42468d1d02026e556aeb9f8f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python爬虫：github自动登录，ctfhub自动签到(带验证码)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00f1becf86e27283c2ee4fcf6c0a0a1e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">information_schema.columns字段说明，获取数据库表所有列信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>