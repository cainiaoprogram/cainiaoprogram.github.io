<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>8 计算机组成原理第五章  中央处理器  控制器   硬布线控制器  微程序控制器 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="8 计算机组成原理第五章  中央处理器  控制器   硬布线控制器  微程序控制器" />
<meta property="og:description" content="文章目录 1 控制器的功能和工作原理1.1 控制器的结构和功能1.2 控制单元的输入和输出1.2.1 控制单元输入1.2.2 控制单元输出 2 硬布线控制器2.1 CPU的控制方式2.2 安排微操作时序的原则（最短时间完成，参考）2.2.1 安排微操作时序-取指周期2.2.2 安排微操作时序-间址周期2.2.3 安排微操作时序-执行周期2.2.4 安排微操作时序-中断周期 2.3 组合逻辑设计2.4 硬布线控制器小结 3 微程序控制器3.1 微程序的基本思想3.2 微程序控制器的基本结构3.2.1 控制寄存器 3.3 微指令格式3.4 微指令的编码方式（重点）3.4.1 直接编码（直接控制）方式3.4.2 字段直接编码方式（最重）3.4.3 字段间接编码方式 3.5 微指令的地址形成方式3.5.1 微指令的地址形成方式-断定方式 3.6 微程序控制的基本概念3.7 微程序控制单元的设计3.8 微程序设计分类3.9 硬布线与微程序的比较3.10 微程序控制器小结 1 控制器的功能和工作原理 1.1 控制器的结构和功能 以上过程控制器无非就是取指令、分析指令、以及产生响应的控制信号执行指令的过程
控制器是计算机系统的指挥中心，控制器的主要功能有：
从主存中取出一条指令，并指出下一条指令在主存中的位置。对指令进行译码域测试，产生相应的操作控制信号，以便启动规定的动作。指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。 1.2 控制单元的输入和输出 1.2.1 控制单元输入 指令寄存器
OP（IR）→CU
控制信号的产生与操作码有关时钟
一个时钟脉冲发一个操作命令或一组需要同时执行的操作命令标志
如条件转移指令，根据相应的标志位决定下一步操作外来信号
如：中断请求信号INTR
总线请求信号HRQ 1.2.2 控制单元输出 CPU内部的控制信号
寄存器之间的数据传输、PC的修改、控制ALU进行相应的运算到控制总线的控制信号 到存储器：访存控制信号MREQ、读命令RD、写命令WR
到I/O设备：访问I/O设备的控制信号IO
中断响应信号INTA、总线响应信号HLDA
2 硬布线控制器 时钟通过节拍发生器产生的多个有先后顺序的节拍信号：
关于机器周期：机器周期可看做所有指令执行过程中的一个基准时间。通常以存取周期作为基准时间，即机器周期。在存储字长等于指令字长的前提下，取指周期也可看做机器周期。 硬布线控制器设计步骤：
分析每个阶段的微操作序列选择CPU的控制方式安排微操作时序电路设计 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8d1057200b110b05fcdf88cb086a1739/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-11T17:33:20+08:00" />
<meta property="article:modified_time" content="2020-07-11T17:33:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">8 计算机组成原理第五章  中央处理器  控制器   硬布线控制器  微程序控制器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1__1" rel="nofollow">1 控制器的功能和工作原理</a></li><li><ul><li><a href="#11__2" rel="nofollow">1.1 控制器的结构和功能</a></li><li><a href="#12__12" rel="nofollow">1.2 控制单元的输入和输出</a></li><li><ul><li><ul><li><a href="#121__16" rel="nofollow">1.2.1 控制单元输入</a></li><li><a href="#122__28" rel="nofollow">1.2.2 控制单元输出</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#2__36" rel="nofollow">2 硬布线控制器</a></li><li><ul><li><a href="#21_CPU_51" rel="nofollow">2.1 CPU的控制方式</a></li><li><a href="#22__68" rel="nofollow">2.2 安排微操作时序的原则（最短时间完成，参考）</a></li><li><ul><li><ul><li><a href="#221__73" rel="nofollow">2.2.1 安排微操作时序-取指周期</a></li><li><a href="#222__92" rel="nofollow">2.2.2 安排微操作时序-间址周期</a></li><li><a href="#223__103" rel="nofollow">2.2.3 安排微操作时序-执行周期</a></li><li><a href="#224__112" rel="nofollow">2.2.4 安排微操作时序-中断周期</a></li></ul> 
     </li></ul> 
     </li><li><a href="#23__136" rel="nofollow">2.3 组合逻辑设计</a></li><li><a href="#24__167" rel="nofollow">2.4 硬布线控制器小结</a></li></ul> 
    </li><li><a href="#3__178" rel="nofollow">3 微程序控制器</a></li><li><ul><li><a href="#31__183" rel="nofollow">3.1 微程序的基本思想</a></li><li><a href="#32__196" rel="nofollow">3.2 微程序控制器的基本结构</a></li><li><ul><li><ul><li><a href="#321__199" rel="nofollow">3.2.1 控制寄存器</a></li></ul> 
     </li></ul> 
     </li><li><a href="#33__206" rel="nofollow">3.3 微指令格式</a></li><li><a href="#34__223" rel="nofollow">3.4 微指令的编码方式（重点）</a></li><li><ul><li><ul><li><a href="#341__226" rel="nofollow">3.4.1 直接编码（直接控制）方式</a></li><li><a href="#342___233" rel="nofollow">3.4.2 字段直接编码方式（最重）</a></li><li><a href="#343___251" rel="nofollow">3.4.3 字段间接编码方式</a></li></ul> 
     </li></ul> 
     </li><li><a href="#35__258" rel="nofollow">3.5 微指令的地址形成方式</a></li><li><ul><li><ul><li><a href="#351__277" rel="nofollow">3.5.1 微指令的地址形成方式-断定方式</a></li></ul> 
     </li></ul> 
     </li><li><a href="#36__287" rel="nofollow">3.6 微程序控制的基本概念</a></li><li><a href="#37__311" rel="nofollow">3.7 微程序控制单元的设计</a></li><li><a href="#38__345" rel="nofollow">3.8 微程序设计分类</a></li><li><a href="#39__355" rel="nofollow">3.9 硬布线与微程序的比较</a></li><li><a href="#310__357" rel="nofollow">3.10 微程序控制器小结</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="1__1"></a>1 控制器的功能和工作原理</h4> 
<h5><a id="11__2"></a>1.1 控制器的结构和功能</h5> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/fe/e1/pCh4TcJf_o.png" alt="在这里插入图片描述"><br> 以上过程控制器无非就是取指令、分析指令、以及产生响应的控制信号执行指令的过程</p> 
</blockquote> 
<p>控制器是计算机系统的指挥中心，控制器的主要功能有：</p> 
<blockquote> 
 <ol><li>从主存中取出一条指令，并指出下一条指令在主存中的位置。</li><li>对指令进行译码域测试，产生相应的操作控制信号，以便启动规定的动作。</li><li>指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。</li></ol> 
</blockquote> 
<h5><a id="12__12"></a>1.2 控制单元的输入和输出</h5> 
<p><img src="https://images2.imgbox.com/87/b5/IkxS1l6O_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="121__16"></a>1.2.1 控制单元输入</h6> 
<blockquote> 
 <ol><li>指令寄存器<br> <code>OP（IR）→CU</code><br> 控制信号的产生与操作码有关</li><li>时钟<br> 一个时钟脉冲发一个操作命令或一组需要同时执行的操作命令</li><li>标志<br> 如条件转移指令，根据相应的标志位决定下一步操作</li><li>外来信号<br> 如：中断请求信号<code>INTR</code><br> 总线请求信号<code>HRQ</code></li></ol> 
</blockquote> 
<h6><a id="122__28"></a>1.2.2 控制单元输出</h6> 
<blockquote> 
 <ol><li>CPU内部的控制信号<br> 寄存器之间的数据传输、<code>PC</code>的修改、控制<code>ALU</code>进行相应的运算</li><li>到控制总线的控制信号</li></ol> 
 <blockquote> 
  <blockquote> 
   <p>到存储器：访存控制信号<code>MREQ</code>、读命令<code>RD</code>、写命令<code>WR</code><br> 到<code>I/O</code>设备：访问<code>I/O</code>设备的控制信号<code>IO</code><br> 中断响应信号<code>INTA</code>、总线响应信号<code>HLDA</code></p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<h4><a id="2__36"></a>2 硬布线控制器</h4> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/4a/5a/K7ZLoNQq_o.png" alt="在这里插入图片描述"><br> 时钟通过节拍发生器产生的多个有先后顺序的节拍信号：<br> <img src="https://images2.imgbox.com/33/af/VqPKY0CS_o.png" alt="在这里插入图片描述"></p> 
 <ul><li>关于机器周期：机器周期可看做所有指令执行过程中的一个基准时间。</li><li>通常以存取周期作为基准时间，即机器周期。</li><li>在存储字长等于指令字长的前提下，取指周期也可看做机器周期。</li></ul> 
</blockquote> 
<p>硬布线控制器设计步骤：</p> 
<blockquote> 
 <ol><li>分析每个阶段的微操作序列</li><li>选择CPU的控制方式</li><li>安排微操作时序</li><li>电路设计</li></ol> 
</blockquote> 
<h5><a id="21_CPU_51"></a>2.1 CPU的控制方式</h5> 
<p>CPU的控制方式：产生不同微操作命令序列所用的时序控制方式。</p> 
<ol><li>同步控制方式</li></ol> 
<blockquote> 
 <ul><li>整个系统所有的控制信号均来自一个<strong>统一的时钟信号</strong>。</li><li>通常以最长的微操作序列和最烦琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。</li><li>同步控制方式的优点是控制电路简单，缺点是运行速度慢。<br> <img src="https://images2.imgbox.com/71/46/SABBj2Oh_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<ol start="2"><li>异步控制方式</li></ol> 
<blockquote> 
 <ul><li>异步控制方式<strong>不存在基准时标信号</strong>。</li><li>各部件按自身固有的速度工作，通过应答方式进行联络。</li><li>异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。</li></ul> 
</blockquote> 
<ol start="3"><li>联合控制方式</li></ol> 
<blockquote> 
 <ul><li>对各种不同的指令的微操作实行<strong>大部分采用同步控制、小部分采用异步控制</strong>的办法。</li></ul> 
</blockquote> 
<p>现在我们假设采用同步控制方式，一个机器周期内安排3个节拍（时钟周期）来实现设计</p> 
<h5><a id="22__68"></a>2.2 安排微操作时序的原则（最短时间完成，参考）</h5> 
<blockquote> 
 <ol><li>原则一 微操作的<strong>先后顺序不得险意更改</strong></li><li>原则二 <strong>被控对象不同</strong>的微操作尽量安排在一个节拍内完成</li><li>原则三 占用<strong>时间较短</strong>的微操作尽量安排在<strong>一个节拍</strong>内完成并<strong>允许有先后顺序</strong></li></ol> 
</blockquote> 
<h6><a id="221__73"></a>2.2.1 安排微操作时序-取指周期</h6> 
<p>（1）PC→MAR</p> 
<p>（2）1→R 存储器空闲即可</p> 
<p>（3）M（MAR）→MDR 在（1）之后</p> 
<p>（4）MDR→IR 在（3）之后</p> 
<p>（5）OP（IR）→ID 在（4）之后</p> 
<p>（6）（PC）+1&gt;→PC 在（1）之后</p> 
<blockquote> 
 <p>根据三个原则，可以以下安排：<br> <img src="https://images2.imgbox.com/fc/da/O0ghScfD_o.png" alt="在这里插入图片描述"><br> （4）（5）两个微操作占用时间较短，根据原则三安排在一个节拍</p> 
</blockquote> 
<p>没有相关性的微操作，可以安排在同一个时钟周期内完成</p> 
<h6><a id="222__92"></a>2.2.2 安排微操作时序-间址周期</h6> 
<p>（1）Ad(IR)→MAR</p> 
<p>（2） 1→R</p> 
<p>（3）M(MAR)→MDR</p> 
<p>（4） MDR→Ad(IR)</p> 
<blockquote> 
 <p>根据三个原则，可以以下安排：<br> <img src="https://images2.imgbox.com/21/98/wm8CilGi_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h6><a id="223__103"></a>2.2.3 安排微操作时序-执行周期</h6> 
<ol><li>五条非访存指令</li></ol> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/07/c9/73MxSt2n_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ol start="2"><li>三条常见的访存指令</li></ol> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/f3/c6/YlumG3nq_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ol start="3"><li>两条转移指令</li></ol> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/f0/ee/1pCGZLFL_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h6><a id="224__112"></a>2.2.4 安排微操作时序-中断周期</h6> 
<p>（1）a→MAR</p> 
<p>（2）1→W 存储器空闲即可</p> 
<p>（3）0→EINT 硬件关中断</p> 
<p>（4）（PC）→MDR 保存断点内部数据通路空闲即可</p> 
<p>（5）MDR→M（MAR） 在（4）之后</p> 
<p>（6）向量地址→PC 在（4）之后</p> 
<blockquote> 
 <p>根据三个原则，可以以下安排：<br> <img src="https://images2.imgbox.com/a4/48/nCLKRCWp_o.png" alt="在这里插入图片描述"><br> 这些操作由中断隐指令完成</p> 
 <blockquote> 
  <p><strong>注</strong>：中断隐指令不是一条指令，而是指一条指令的中断周期由硬件完成的一系列操作。</p> 
 </blockquote> 
 <blockquote> 
  <p>中断周期的三个任务：</p> 
  <ol><li>保存断点（PC放某存储单元）</li><li>形成中断服务程序的入口地址</li><li>关中断</li></ol> 
 </blockquote> 
</blockquote> 
<h5><a id="23__136"></a>2.3 组合逻辑设计</h5> 
<p>设计步骤：</p> 
<ol><li>列出操作时间表</li><li>写出微操作命令的最简表达式</li><li>画出逻辑图</li></ol> 
<hr> 
<ol><li>列出操作时间表</li></ol> 
<blockquote> 
 <p><strong>取指周期操作时间表</strong>：<img src="https://images2.imgbox.com/e0/f9/nC3T5qnr_o.png" alt="在这里插入图片描述"></p> 
 <blockquote> 
  <p>需要微操作命令信号的指令，填1<br> 1→IND：表示进入间指周期（非访存指令不需要进入间指周期）<br> 1→EX：表示进入执行周期（所有指令都需要进入执行周期）</p> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <p><strong>间址周期操作时间表</strong>：<br> <img src="https://images2.imgbox.com/f4/81/2X1auLkM_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p><strong>执行周期操作时间表</strong>：<br> <img src="https://images2.imgbox.com/75/d9/jC1YUxM1_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ol start="2"><li>依据上述三个表，写出微操作命令的最简表达式</li></ol> 
<blockquote> 
 <p>以M（MAR）→MDR为例：<br> <img src="https://images2.imgbox.com/e7/dc/ezLimadl_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<pre><code class="prism language-c">M（MAR）→MDR微操作命令的逻辑表达式：
FE·T1<span class="token operator">+</span>IND·T1（ADD<span class="token operator">+</span>STA<span class="token operator">+</span>LDA<span class="token operator">+</span>JMP<span class="token operator">+</span>BAN）<span class="token operator">+</span>EX·T1（ADD<span class="token operator">+</span>LDA）
<span class="token operator">=</span>T1<span class="token punctuation">{<!-- --></span>FE<span class="token operator">+</span>IND（ADD<span class="token operator">+</span>STA<span class="token operator">+</span>LDA<span class="token operator">+</span>JMP<span class="token operator">+</span>BAN）<span class="token operator">+</span>EX（ADD<span class="token operator">+</span>LDA）<span class="token punctuation">}</span>  <span class="token comment">//提取公因式T1</span>
</code></pre> 
<ol start="3"><li>根据逻辑表达式画出逻辑图<br> <img src="https://images2.imgbox.com/ba/2d/EwT2p8Dc_o.png" alt="在这里插入图片描述"></li></ol> 
<h5><a id="24__167"></a>2.4 硬布线控制器小结</h5> 
<p>设计步骤：</p> 
<blockquote> 
 <ol><li>分析每个阶段的微操作序列 （<strong>重点</strong>）</li><li>选择CPU的控制方式</li><li>安排微操作时序</li><li>电路设计</li></ol> 
 <blockquote> 
  <blockquote> 
   <p>（1）列出操作时间表<br> （2）写出微操作命令的最简表达式<br> （3）画出逻辑图</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<h4><a id="3__178"></a>3 微程序控制器</h4> 
<blockquote> 
 <ul><li><strong>硬布线工作原理</strong>：微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生</li><li><strong>微程序工作原理</strong>：事先把微操作控制信号存储在一个专门的存储器（控制存储器）中，将每一条机器指令编写成一个微程序，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。</li></ul> 
</blockquote> 
<h5><a id="31__183"></a>3.1 微程序的基本思想</h5> 
<p><img src="https://images2.imgbox.com/35/9c/hk8KvE7P_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/5b/fd/WcWppeqL_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>一个机器指令对应一个微程序思想：每条指令取指周期的操作是相同的，所以将取指令操作的微命令统一编成一个微程序，而每条机器指令所对应的具体操作再单独编写一个与之对应的微程序。</p> 
</blockquote> 
<p>微指令基本格式：</p> 
<p><img src="https://images2.imgbox.com/9d/74/Fc3KDdpV_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="32__196"></a>3.2 微程序控制器的基本结构</h5> 
<p><img src="https://images2.imgbox.com/cb/ff/xSHtearG_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="321__199"></a>3.2.1 控制寄存器</h6> 
<p><img src="https://images2.imgbox.com/7e/38/ksRvkoSt_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>取指周期微程序：默认是公共的，故如果某指令系统中有<code>n</code>条机器指令，则<code>CM</code>中微程序的个数至少是<code>n+1</code>个</li><li>间址周期微程序和中断周期微程序：不一定是公共的。<br> 此处做成公共的，故如果这台计算机指令系统中有<code>n</code>条机器指令，则CM中微程序的个数是<code>n+3</code>个。</li></ul> 
</blockquote> 
<h5><a id="33__206"></a>3.3 微指令格式</h5> 
<ol><li>水平型微指令 ：一次能定义并执行多个并行操作。</li></ol> 
<blockquote> 
 <p>基本格式：<br> <img src="https://images2.imgbox.com/0a/29/LvMqqwCP_o.png" alt="在这里插入图片描述"></p> 
 <blockquote> 
  <p>优点：微程序短，执行速度快；<br> 缺点：微指令长，编写微程序较麻烦。</p> 
 </blockquote> 
</blockquote> 
<ol start="2"><li>垂直型微指令：类似机器指令操作码的方式，由微操作码字段规定微指令的功能。</li></ol> 
<blockquote> 
 <p>基本格式：<br> <img src="https://images2.imgbox.com/21/10/3k27diyQ_o.png" alt="在这里插入图片描述"></p> 
 <blockquote> 
  <p>优点：微指令短、简单、规整，便于编写微程序；<br> 缺点：微程序长，执行速度慢，工作效率低。</p> 
 </blockquote> 
</blockquote> 
<ol start="3"><li>混合型微指令：在垂直型的基础上增加一些不太复杂的并行操作。</li></ol> 
<blockquote> 
 <p>微指令较短，仍便于编写；微程序也不长，执行速度加快。</p> 
</blockquote> 
<h5><a id="34__223"></a>3.4 微指令的编码方式（重点）</h5> 
<blockquote> 
 <p>微指令的编码方式又称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。</p> 
</blockquote> 
<h6><a id="341__226"></a>3.4.1 直接编码（直接控制）方式</h6> 
<p>在微指令的操作控制字段中，<strong>每一位代表一个微操作命令</strong><br> 某位为“1”表示该控制信号有效<br> <img src="https://images2.imgbox.com/89/78/bN7tEWkw_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <blockquote> 
  <p>优点：简单、直观，执行速度快，操作并行性好。<br> 缺点：微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存容量极大。</p> 
 </blockquote> 
</blockquote> 
<h6><a id="342___233"></a>3.4.2 字段直接编码方式（最重）</h6> 
<p>将微指令的控制字段分成若干“段”，每段经译码后发出控制信号<br> <img src="https://images2.imgbox.com/1d/06/cj1ubKpJ_o.png" alt="在这里插入图片描述"><br> <strong>微命令字段分段的原则：</strong></p> 
<blockquote> 
 <p>（1）<mark>互斥性微命令分在同一段内，相容性微命令分在不同段内。</mark><br> （2）每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。<br> （3）一般<mark>每个小段还要留出一个状态</mark>，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，<mark>通常用000表示不操作。</mark><br> <img src="https://images2.imgbox.com/57/67/Q4Atw0TK_o.png" alt="在这里插入图片描述"></p> 
 <blockquote> 
  <p>优点：可以缩短微指令字长。<br> 缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢。</p> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <p><strong>例题</strong>：某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有多少位？</p> 
</blockquote> 
<blockquote> 
 <p><strong>解答</strong>：第1个互斥类有7个微命令，要留出1个状态表示不操作，所以需要表示8种不同的状态，故需要3个二进制位。<br> 以此类推，后面4个互斥类各需要表示4、13、6、7种不同的状态，分别对应2、4、3、3个二进制位。<br> 故操作控制字段的总位数为3+2+4+3+3=15位</p> 
</blockquote> 
<h6><a id="343___251"></a>3.4.3 字段间接编码方式</h6> 
<p>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/20/c1/90ZRvgv6_o.png" alt="在这里插入图片描述"></p> 
 <blockquote> 
  <p>优点：可进一步缩短微指令字长。<br> 缺点：削弱了微指令的并行控制能力，故通常作为字段直接编码方式的一种辅助手段。</p> 
 </blockquote> 
</blockquote> 
<h5><a id="35__258"></a>3.5 微指令的地址形成方式</h5> 
<ol><li>微指令的<strong>下地址字段</strong>指出</li></ol> 
<blockquote> 
 <p>微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称为<strong>断定方式</strong>。</p> 
</blockquote> 
<ol start="2"><li>根据机器指令的<strong>操作码</strong>形成</li></ol> 
<blockquote> 
 <p>当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。</p> 
</blockquote> 
<ol start="3"><li>增量计数器法（CMAR）+1→CMAR</li><li>分支转移转移方式：指明判别条件；转移地址：指明转移成功后的去向。</li></ol> 
<table><thead><tr><th>操作控制字段</th><th>转移方式</th><th>转移地址</th></tr></thead><tbody></tbody></table> 
<ol start="5"><li>通过测试网络<br> <img src="https://images2.imgbox.com/a5/70/B9t6Qi59_o.png" alt="在这里插入图片描述"></li><li>由硬件产生微程序入口地址</li></ol> 
<blockquote> 
 <p>第一条微指令地址由专门硬件产生<br> 中断周期由硬件产生中断周期微程序首地址</p> 
</blockquote> 
<p><strong>（1）（2）掌握，（3）（4）（5）（6）了解</strong></p> 
<h6><a id="351__277"></a>3.5.1 微指令的地址形成方式-断定方式</h6> 
<blockquote> 
 <p><strong>例题</strong>：某计算机采用微程序控制器，共有32条指令，公共的取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定法（下地址字段法）确定下条微指令地址，则微指令中下地址字段的位数至少是多少位？</p> 
</blockquote> 
<blockquote> 
 <p><strong>解答</strong>：总共需要存储多少条微指令？<br> 32×4+2=130条<br> 标注出130个不同的位置至少需要多少个二进制位？<br> 2<sup>7</sup>=128，2<sup>8</sup>=256<br> 下地址字段的位数至少是8位</p> 
</blockquote> 
<h5><a id="36__287"></a>3.6 微程序控制的基本概念</h5> 
<p><img src="https://images2.imgbox.com/23/3d/i0l90E9L_o.png" alt="在这里插入图片描述"></p> 
<ol><li>微命令与微操作</li></ol> 
<blockquote> 
 <p><strong>微命令</strong>是微操作的控制信号<br> <strong>微操作</strong>是微命令的执行过程。</p> 
</blockquote> 
<ol start="2"><li>微指令与微周期</li></ol> 
<blockquote> 
 <p><strong>微指令</strong>是若干微命令的集合。<br> <strong>微周期</strong>通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。</p> 
</blockquote> 
<ol start="3"><li>主存储器与控制存储器</li></ol> 
<blockquote> 
 <p><strong>主存储器</strong>用于存放程序和数据，在CPU外部，用RAM实现；<br> <strong>控制存储器</strong>（CM）用于存放微程序，在CPU内部，用ROM实现。</p> 
</blockquote> 
<ol start="4"><li>程序与微程序</li></ol> 
<blockquote> 
 <p><strong>程序</strong>是指令的有序集合，用于完成特定的功能；<br> <strong>微程序</strong>是微指令的有序集合，一条指令的功能由一段微程序来实现。</p> 
</blockquote> 
<ol start="5"><li>地址寄存器（MAR）与微地址寄存器（CMAR）</li></ol> 
<blockquote> 
 <p>MAR存放要访问的存储器的地址<br> CMAR在CU内部，存放控制存储器的地址</p> 
</blockquote> 
<ol start="6"><li>指令寄存器（IR）与微指令寄存器（CMDR或uIR）</li></ol> 
<blockquote> 
 <p>IR在CPU内部，CU外部，存放指令<br> CMDR在CU内部，存放微指令</p> 
</blockquote> 
<h5><a id="37__311"></a>3.7 微程序控制单元的设计</h5> 
<p>设计步骤：</p> 
<blockquote> 
 <ol><li>分析每个阶段的微操作序列</li><li>写出对应机器指令的微操作命令及节拍安排</li><li>确定微指令格式</li><li>编写微指令码点</li></ol> 
</blockquote> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/02/4b/lxggsHEO_o.png" alt="在这里插入图片描述"><br> 两者仅仅最后一步略有差别，硬布线交给一个硬件，是指令译码器，具有译码作用；<br> 微程序交给微地址形成部件，用来定位微程序首地址</p> 
</blockquote> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/0b/e0/Xp1spwkF_o.png" alt="在这里插入图片描述"><br> Ad（CMDR）→CMAR<br> OP（IR）→微地址形成部件→CMAR</p> 
</blockquote> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/c6/16/HqP2ISUd_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>设计步骤：</p> 
<blockquote> 
 <ol><li>分析每个阶段的微操作序列</li><li>写出对应机器指令的微操作命令及节拍安排<br> （1）写出每个周期所需要的微操作（参照硬布线）<br> （2）补充微程序控制器特有的微操作：</li></ol> 
 <blockquote> 
  <blockquote> 
   <blockquote> 
    <blockquote> 
     <p>a.取指周期：<br> <code>Ad（CMDR）→CMAR</code><br> <code>OP（IR）→CMAR</code><br> b.执行周期：<br> <code>Ad（CMDR）→CMAR</code></p> 
    </blockquote> 
   </blockquote> 
  </blockquote> 
 </blockquote> 
 <ol start="3"><li>确定微指令格式</li></ol> 
 <blockquote> 
  <p>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。<br> 由微指令数确定微指令的顺序控制字段的位数。<br> 最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。</p> 
 </blockquote> 
 <ol start="4"><li>编写微指令码点<br> 根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。</li></ol> 
</blockquote> 
<h5><a id="38__345"></a>3.8 微程序设计分类</h5> 
<ol><li>静态微程序设计和动态微程序设计</li></ol> 
<blockquote> 
 <ul><li>静态微程序无需改变，采用<code>ROM</code></li><li>动态通过改变微指令和微程序改变机器指令有利于仿真，采用<code>EPROM</code></li></ul> 
</blockquote> 
<ol start="2"><li>毫微程序设计</li></ol> 
<blockquote> 
 <ul><li>微程序设计 用 微程序解释机器指令</li><li>毫微程序设计 用 毫微程序解释微程序</li><li><strong>毫微指令与微指令的关系好比微指令与机器指令的关系</strong></li></ul> 
</blockquote> 
<h5><a id="39__355"></a>3.9 硬布线与微程序的比较</h5> 
<p><img src="https://images2.imgbox.com/89/85/1zWBRy5E_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="310__357"></a>3.10 微程序控制器小结</h5> 
<p><img src="https://images2.imgbox.com/96/1f/cE5I09RA_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/557308ec4ef89f1003b3d550a286645d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">11.2、SR基本原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/10d69a09a7a3ae4bb3180e59da85efab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">手把手教你EMD算法原理与Python实现(更新)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>