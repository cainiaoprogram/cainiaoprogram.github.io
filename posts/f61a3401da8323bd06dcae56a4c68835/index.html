<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>高并发下防止库存超卖的解决方案 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="高并发下防止库存超卖的解决方案" />
<meta property="og:description" content="最近在看秒杀相关的项目，针对防止库存超卖的问题，查阅了很多资料，其解决方案可以分为悲观锁、乐观锁、分布式锁、Redis原子操作、队列串行化等等，这里进行浅显的记录总结。
首先我们来看下库存超卖问题是怎样产生的：
1
2
3
4
5
6
//1.查询出商品库存信息
select stock from t_goods where id=1;
//2.根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);
//3.修改商品库存
update t_goods set stock=stock-1 where id=1;
在高并发场景下，如果同时有两个线程a和b，同时查询到商品库存为1，他们都认为存库充足，于是开始下单减库存。如果线程a先完成减库存操作，库存为0，接着线程b也是减库存，于是库存就变成了-1，商品被超卖了。
下面让我们来看看针对库存超卖问题的解决方案；
解决方案一：悲观锁 所谓悲观锁，即悲观的认为自己在操作数据库时，会大几率出现并发，于是在操作前会先进行加锁，操作完成后再释放锁。如果加锁失败说明该记录正在被修改，那么当前操作可以等待后尝试。
以我们常用的MySQL为例，行锁、表锁、排他锁等都是悲观锁，为避免冲突，会在操作时先加锁，其他线程必须等待它的完成。
这里我们通过使用select...for update语句，在查询商品表库存时将该条记录加锁，待下单减库存完成后，再释放锁。
1
2
3
4
5
6
7
8
9
10
//0.开始事务
begin;/begin work;/start transaction; (三者选一就可以)
//1.查询出商品信息
select stock from t_goods where id=1 for update;
//2.根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);
//3.修改商品stock减一
update t_goods set stock=stock-1 where id=1;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f61a3401da8323bd06dcae56a4c68835/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-29T20:56:41+08:00" />
<meta property="article:modified_time" content="2020-02-29T20:56:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">高并发下防止库存超卖的解决方案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0pt;">最近在看秒杀相关的项目，针对防止库存超卖的问题，查阅了很多资料，其解决方案可以分为悲观锁、乐观锁、分布式锁、Redis原子操作、队列串行化等等，这里进行浅显的记录总结。</p> 
<p style="margin-left:0pt;">首先我们来看下库存超卖问题是怎样产生的：</p> 
<table border="1" cellspacing="0" style="margin-left:-5.1pt;"><tbody><tr><td style="vertical-align:top;width:36px;"> <p style="margin-left:0pt;"><span style="color:#afafaf;">1</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">2</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">3</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">4</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">5</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">6</span></p> </td><td style="vertical-align:top;"> <p style="margin-left:0pt;"><span style="color:#000000;">//1.查询出商品</span><span style="color:#000000;">库存</span><span style="color:#000000;">信息</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">select</span> <span style="color:#000000;">stock</span> <span style="color:#0000ff;">from</span> <span style="color:#000000;">t_goods </span><span style="color:#0000ff;">where</span> <span style="color:#000000;">id=1;</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">//2.根据商品信息生成订单</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">insert</span> <span style="color:#0000ff;">into</span> <span style="color:#000000;">t_orders (id,goods_id) </span><span style="color:#0000ff;">values</span> <span style="color:#000000;">(</span><span style="color:#808080;">null</span><span style="color:#000000;">,1);</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">//3.修改商品</span><span style="color:#000000;">库存</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">update</span> <span style="color:#000000;">t_goods </span><span style="color:#0000ff;">set</span> <span style="color:#000000;">stock</span><span style="color:#000000;">=</span><span style="color:#000000;">stock-1 </span><span style="color:#0000ff;">where</span> <span style="color:#000000;">id=1</span><span style="color:#000000;">;</span></p> </td></tr></tbody></table> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">在高并发场景下，如果同时有两个线程a和b，同时查询到商品库存为1，他们都认为存库充足，于是开始下单减库存。如果线程a先完成减库存操作，库存为0，接着线程b也是减库存，于是库存就变成了-1，商品被超卖了。</p> 
<p style="margin-left:0pt;">下面让我们来看看针对库存超卖问题的解决方案；</p> 
<h4><strong><strong><strong>解决方案一：悲观锁</strong></strong></strong></h4> 
<p style="margin-left:0pt;">所谓悲观锁，即悲观的认为自己在操作数据库时，会大几率出现并发，于是在操作前会先进行加锁，操作完成后再释放锁。如果加锁失败说明该记录正在被修改，那么当前操作可以等待后尝试。</p> 
<p style="margin-left:0pt;">以我们常用的MySQL为例，行锁、表锁、排他锁等都是悲观锁，为避免冲突，会在操作时先加锁，其他线程必须等待它的完成。</p> 
<p style="margin-left:0pt;">这里我们通过使用select...for update语句，在查询商品表库存时将该条记录加锁，待下单减库存完成后，再释放锁。</p> 
<table border="1" cellspacing="0" style="margin-left:-5.1pt;"><tbody><tr><td style="vertical-align:top;width:45px;"> <p style="margin-left:0pt;"><span style="color:#afafaf;">1</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">2</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">3</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">4</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">5</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">6</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">7</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">8</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">9</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">10</span></p> </td><td style="vertical-align:top;"> <p style="margin-left:0pt;"><span style="color:#000000;">//0.开始事务</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">begin</span><span style="color:#000000;">;/</span><span style="color:#0000ff;">begin</span> <span style="color:#0000ff;">work</span><span style="color:#000000;">;/start </span><span style="color:#0000ff;">transaction</span><span style="color:#000000;">; (三者选一就可以)</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">//1.查询出商品信息</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">select</span> <span style="color:#000000;">stock</span> <span style="color:#0000ff;">from</span> <span style="color:#000000;">t_goods </span><span style="color:#0000ff;">where</span> <span style="color:#000000;">id=1 </span><span style="color:#0000ff;">for</span> <span style="color:#0000ff;">update</span><span style="color:#000000;">;</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">//2.根据商品信息生成订单</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">insert</span> <span style="color:#0000ff;">into</span> <span style="color:#000000;">t_orders (id,goods_id) </span><span style="color:#0000ff;">values</span> <span style="color:#000000;">(</span><span style="color:#808080;">null</span><span style="color:#000000;">,1);</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">//3.修改商品</span><span style="color:#000000;">stock减一</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">update</span> <span style="color:#000000;">t_goods </span><span style="color:#0000ff;">set</span> <span style="color:#000000;">stock</span><span style="color:#000000;">=</span><span style="color:#000000;">stock-1 </span><span style="color:#0000ff;">where</span> <span style="color:#000000;">id=1</span><span style="color:#000000;">;</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">//4.提交事务</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">commit</span><span style="color:#000000;">;</span></p> </td></tr></tbody></table> 
<p style="margin-left:0pt;">这样可以解决并发时库存超卖的问题，然而高并发时，所有的操作都被串行化了，效率很低，将严重影响系统的吞吐量。而且使用悲观锁还有可能造成死锁问题。</p> 
<h4><strong><strong><strong>解决方案二：乐观锁</strong></strong></strong></h4> 
<p style="margin-left:0pt;">现在我们尝试下使用乐观锁，所谓乐观锁，是相对于悲观锁而言的，它假设数据一般情况下不会发生并发，因此不会对数据进行加锁，操作完成提交时才对数据是否冲突进行检测，如果发现冲突则返回错误。</p> 
<p style="margin-left:0pt;">比较常见的实现方式是，在表中增加一个version字段，操作前先查询version信息，在数据提交时检查version字段是否被修改，如果没有被修改则进行提交，否则认为是过期数据。</p> 
<table border="1" cellspacing="0" style="margin-left:-5.1pt;width:453.85pt;"><tbody><tr><td style="vertical-align:top;width:39.7pt;"> <p style="margin-left:0pt;"><span style="color:#afafaf;">1</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">2</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">3</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">4</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">5</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">6</span></p> </td><td style="vertical-align:top;width:414.15pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">//1.查询出商品信息</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">select</span> <span style="color:#000000;">stock</span><span style="color:#000000;">, version</span> <span style="color:#0000ff;">from</span> <span style="color:#000000;">t_goods </span><span style="color:#0000ff;">where</span> <span style="color:#000000;">id=1;</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">//2.根据商品信息生成订单</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">insert</span> <span style="color:#0000ff;">into</span> <span style="color:#000000;">t_orders (id,goods_id) </span><span style="color:#0000ff;">values</span> <span style="color:#000000;">(</span><span style="color:#808080;">null</span><span style="color:#000000;">,1);</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">//3.修改商品</span><span style="color:#000000;">库存</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">update</span> <span style="color:#000000;">t_goods </span><span style="color:#0000ff;">set</span> <span style="color:#000000;">stock</span><span style="color:#000000;">=</span><span style="color:#000000;">stock-1</span><span style="color:#000000;">, version = version+1</span> <span style="color:#0000ff;">where</span> <span style="color:#000000;">id=1</span><span style="color:#000000;">, version=version</span><span style="color:#000000;">;</span></p> </td></tr></tbody></table> 
<p style="margin-left:0pt;">这样，在并发时，如果线程a尝试修改商品库存时，发现版本号已经被线程b修改了，线程a执行update语句条件不满足便不再执行了，库存也不会被超卖。</p> 
<p style="margin-left:0pt;">但是这种乐观锁的方式，在高并发时，只有一个线程能执行成功，会造成大量的失败，这给用户的体验显然是很不好的。</p> 
<p style="margin-left:0pt;">这里我们可以减小锁的颗粒度，最大程度提升系统的吞吐量，提高并发能力：</p> 
<table border="1" cellspacing="0" style="margin-left:-5.1pt;width:453.85pt;"><tbody><tr><td style="vertical-align:top;width:39.7pt;"> <p style="margin-left:0pt;"><span style="color:#afafaf;">1</span></p> <p style="margin-left:0pt;"><span style="color:#afafaf;">2</span></p> </td><td style="vertical-align:top;width:414.15pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">//修改商品</span><span style="color:#000000;">库存时判断库存是否大于0</span></p> <p style="margin-left:0pt;"><span style="color:#0000ff;">update</span> <span style="color:#000000;">t_goods </span><span style="color:#0000ff;">set</span> <span style="color:#000000;">stock</span><span style="color:#000000;">=</span><span style="color:#000000;">stock-1 </span><span style="color:#0000ff;">where</span> <span style="color:#000000;">id=1</span> <span style="color:#0000ff;">and</span><span style="color:#000000;"> stock&gt;0</span><span style="color:#000000;">;</span></p> </td></tr></tbody></table> 
<p style="margin-left:0pt;">上面的update语句通过stock&gt;0进行乐观锁的控制，在执行时，会在一次原子操作中查询stock的值，并扣减一。</p> 
<h4><strong><strong><strong>解决方案三：分布式锁</strong></strong></strong></h4> 
<p style="margin-left:0pt;">除了在数据库层面加锁，我们还可以通过在内存中加锁，实现分布式锁。例如我们可以在Redis中设置一个锁，拿到锁的线程抢购成功，拿不到锁的抢购失败。</p> 
<p style="margin-left:0pt;">Redis的setnx方法可以实现锁机制，key不存在时创建，并设置value，返回值为1；key存在时直接返回0。线程调用setnx方法成功返回1认为加锁成功，其他线程要等到当前线程业务操作完成释放锁后，才能再次调用setnx加锁成功。</p> 
<table border="1" cellspacing="0" style="margin-left:-5.1pt;"><tbody><tr><td style="vertical-align:top;width:415pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">Long TIMEOUT_SECOUND = 120000L;</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">Jedis</span> <span style="color:#000000;">client = </span><span style="color:#000000;">jedisPool</span><span style="color:#000000;">.getResource();</span></p> <p style="margin-left:0pt;"><span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">线程设置</span><span style="color:#3f7f5f;">lock锁成功</span></p> <p style="margin-left:0pt;"><strong><span style="color:#7f0055;"><strong>while</strong></span></strong><span style="color:#000000;">(client.setnx(</span><span style="color:#2a00ff;">"lock"</span><span style="color:#000000;">,String.valueOf(System.</span><span style="color:#000000;">currentTimeMillis</span><span style="color:#000000;">())) == 1){<!-- --></span></p> <p style="margin-left:0pt;"><span style="color:#000000;">Long lockTime = Long.valueOf(client.get(</span><span style="color:#2a00ff;">"lock"</span><span style="color:#000000;">));</span></p> <p style="margin-left:0pt;"><span style="color:#3f7f5f;">//持有锁超时后自动释放锁</span></p> <p style="margin-left:0pt;"><strong><span style="color:#7f0055;"><strong>if</strong></span></strong><span style="color:#000000;"> (lockTime!=</span><strong><span style="color:#7f0055;"><strong>null</strong></span></strong><span style="color:#000000;"> &amp;&amp; System.</span><span style="color:#000000;">currentTimeMillis</span><span style="color:#000000;">() &gt; lockTime+TIMEOUT_SECOUND){<!-- --></span></p> <p style="margin-left:0pt;"><span style="color:#000000;">client.del(</span><span style="color:#2a00ff;">"lock"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">}</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">Thread.sleep(10000);</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">}</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">......</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">......</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">client.del(</span><span style="color:#2a00ff;">"lock"</span><span style="color:#000000;">);</span></p> </td></tr></tbody></table> 
<h4><strong><strong><strong>解决方案四：Redis原子操作</strong></strong></strong></h4> 
<p style="margin-left:0pt;">虽然通过以上方按可以防止库存超卖，但是高并发情况下对数据库进行频繁操作，会造成严重的性能问题。因此我们必须在前端对请求进行限制。</p> 
<p style="margin-left:0pt;">我们可以在Redis中设置一个队列key为商品的id，队列的长度为商品库存量。每次请求到达时pop出一个元素，这样拿到元素的请求即认为秒杀成功，后续通过MQ发送消息异步完成数据库减库存操作。没有拿到元素的请求即认为秒杀失败。</p> 
<p style="margin-left:0pt;">由于Redis是工作线程是单线程的，而list的pop操作是原子性的，因此并发的请求都被串行化了，库存就不会超卖了。</p> 
<table border="1" cellspacing="0" style="margin-left:-5.1pt;"><tbody><tr><td style="vertical-align:top;width:415pt;"> <p style="margin-left:0pt;"><span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">获取商品库存</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">String </span><span style="color:#6a3e3e;">token</span><span style="color:#000000;"> =</span> <span style="color:#6a3e3e;">redisTemplate</span><span style="color:#000000;">.</span><span style="color:#000000;">opsForList().leftPop(</span><span style="color:#6a3e3e;">goodsStock</span><span style="color:#000000;">)</span><span style="color:#000000;">;</span></p> <p style="margin-left:0pt;"><strong><span style="color:#7f0055;"><strong>if</strong></span></strong><span style="color:#000000;">(</span><span style="color:#6a3e3e;">token</span><span style="color:#000000;"> == </span><strong><span style="color:#7f0055;"><strong>null</strong></span></strong><span style="color:#000000;">){<!-- --></span></p> <p style="margin-left:0pt;"><span style="color:#6a3e3e;">log</span><span style="color:#000000;">.info(</span><span style="color:#2a00ff;">"&gt;&gt;&gt;商品已售空"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0pt;"><strong><span style="color:#7f0055;"><strong>return</strong></span></strong><span style="color:#000000;"> setResultError(</span><span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">亲，该秒杀已经售空，请下次再来!")</span><span style="color:#000000;">;</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">}</span></p> <p style="margin-left:0pt;"><span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">异步发送</span><span style="color:#3f7f5f;">MQ消息，执行数据库操作</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">sendSecondKillMsg(</span><span style="color:#6a3e3e;">goodsId, userId</span><span style="color:#000000;">);</span></p> <p style="margin-left:0pt;"><span style="color:#000000;">...</span></p> </td></tr></tbody></table> 
<p style="margin-left:0pt;">当然除此之外还有很多其他解决方案，也有很多可以优化的地方，继续学习吧~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/add2d78b6f33a03a9b3d82e65a2123f8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kubernetes：3步排查K8S Deployment故障</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c1ad26823190c9bb25299e925485e64f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UNICODE和UTF-8的相互转换（C&#43;&#43;）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>