<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue3 &#43; Ant Design Vue Modal 对话框拖拽&#43;缩放指令 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue3 &#43; Ant Design Vue Modal 对话框拖拽&#43;缩放指令" />
<meta property="og:description" content="这篇文章是继上篇文章的优化 增加了左右和底部拖拽控制弹窗大小功能的实现
1、html部分
&lt;div v-dialogDrag=&#34;true&#34; id=&#34;modalBox&#34;&gt; &lt;a-modal v-model:visible=&#34;visible&#34; title=&#34;我要拖拽&#34; :getContainer=&#34;getContainer&#34; :force-render=&#34;true&#34; // 强制渲染 不管有没有开启modal 页面都进行DOM加载 &gt; &lt;div class=&#34;overflow-y modal scrollbar&#34; // 滚动样式 自行编写 &gt; &lt;/div&gt; &lt;/a-modal&gt; &lt;/div&gt; 2、ts部分
说明：modal默认挂载到body下，getContainer 函数是为了让modal挂载到父盒子modalBox下，不然指令中 el 获取不到modal的DOM节点
const visible = ref&lt;boolean&gt;(false); const getContainer = () =&gt; { return document.getElementById(&#34;modalBox&#34;); }; 3、指令代码部分
3.1 index.ts文件
import dialogDrag from &#34;./modules/dialogDrag&#34; // 统一入口 export default function directive(app: any) { app.directive(&#39;dialogDrag&#39;, dialogDrag) } 3.2 dialogDrag.ts (核心代码)
说明：必须使用 nextTick 不然获取DOM元素会为空" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/58557637d965f5b4265f802afcf38161/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-18T13:12:34+08:00" />
<meta property="article:modified_time" content="2022-11-18T13:12:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue3 &#43; Ant Design Vue Modal 对话框拖拽&#43;缩放指令</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>这篇文章是继上篇文章的优化 增加了左右和底部拖拽控制弹窗大小功能的实现</p> 
<p>1、html部分</p> 
<pre><code class="language-html">    &lt;div v-dialogDrag="true" id="modalBox"&gt;
      &lt;a-modal
        v-model:visible="visible"
        title="我要拖拽"
        :getContainer="getContainer"
        :force-render="true" // 强制渲染 不管有没有开启modal 页面都进行DOM加载
      &gt;
        &lt;div
          class="overflow-y modal scrollbar" // 滚动样式 自行编写
        &gt;
        &lt;/div&gt;
      &lt;/a-modal&gt;
    &lt;/div&gt;</code></pre> 
<p>2、ts部分</p> 
<p>说明：modal默认挂载到body下，getContainer  函数是为了让modal挂载到父盒子modalBox下，不然指令中 el 获取不到modal的DOM节点</p> 
<pre><code class="language-html">const visible = ref&lt;boolean&gt;(false);
const getContainer = () =&gt; {
  return document.getElementById("modalBox");
};</code></pre> 
<p>3、指令代码部分</p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/02/f6/AvOF9hWp_o.png" width="198"></p> 
<p>3.1 index.ts文件</p> 
<pre><code class="language-html">import dialogDrag from "./modules/dialogDrag"
// 统一入口
export default function directive(app: any) {
    app.directive('dialogDrag', dialogDrag)
}</code></pre> 
<p>3.2 dialogDrag.ts (核心代码)</p> 
<p>说明：必须使用 nextTick 不然获取DOM元素会为空</p> 
<pre><code class="language-TypeScript">import { nextTick } from "vue";
export default {
    mounted(el: any, binding?: any) {
        nextTick(() =&gt; {
            const minWidth = 400;
            const minHeight = 300;
            // 自定义属性，判断是否可拖拽
            const dialogHeaderEl = el.querySelector('.xz-modal-header')
            const dragDom = el.querySelector('.xz-modal')
            const dragDomBody = el.querySelector('.xz-modal-body') // 获取body antd 必须插入此DOM元素下
            // dragDom.style.position='relative'
            dialogHeaderEl.style.cssText += ';cursor:move;'
            // 是否开启左右拖拽功能
            if (binding.value) {
                // 此部分的样式为单独编写 根据自己需求
                const leftDiv = document.createElement("div");
                leftDiv.id = 'leftdiv'
                leftDiv.onmousedown = (e: any) =&gt; {
                    Drag(e)
                }
                dragDomBody.appendChild(leftDiv)
                const rightDiv = document.createElement("div");
                rightDiv.id = 'rightdiv'
                rightDiv.onmousedown = (e: any) =&gt; {
                    Drag(e)
                }
                dragDomBody.appendChild(rightDiv)
                const bottomtDiv = document.createElement("div");
                bottomtDiv.id = 'bottomtdiv'
                bottomtDiv.onmousedown = (e: any) =&gt; {
                    Drag(e)
                }
                dragDomBody.appendChild(bottomtDiv)
            }

            // dragDom.style.cssText += ';bottom:0px;'
            // 获取原有属性 火狐谷歌 window.getComputedStyle(dom元素, null);
            const sty = (function () {
                return (dom: any, attr: any) =&gt; getComputedStyle(dom, null)[attr]
            })()
            // 拖拉函数
            function Drag(ev: any) {
                // dragDom.style.userSelect = 'none';
                const clientX = ev.clientX;
                const clientY = ev.clientY;
                const elW = dragDom.clientWidth;
                const elH = dragDom.clientHeight;
                const EloffsetLeft = dragDom.offsetLeft;
                const EloffsetTop = dragDom.offsetTop;
                dragDom.style.userSelect = 'none'; // 禁止内容被选中
                const ELscrollTop = el.scrollTop;
                document.onmousemove = function (e) {
                    const modalContent = el.querySelector('.modal')
                    console.log('modalContent',modalContent);

                    e.stopPropagation(); // 移动时禁用默认事件
                    // 左侧鼠标拖拽位置
                    if (clientX &gt; EloffsetLeft &amp;&amp; clientX &lt; EloffsetLeft + 10) {
                        // 往左拖拽
                        if (clientX &gt; e.clientX) {
                            dragDom.style.width = elW + (clientX - e.clientX) * 2 + 'px';
                        }
                        // 往右拖拽
                        if (clientX &lt; e.clientX) {
                            if (dragDom.clientWidth &lt; minWidth) {
                            } else {
                                dragDom.style.width = elW - (e.clientX - clientX) * 2 + 'px';
                            }
                        }
                    }
                    // 右侧鼠标拖拽位置
                    if (clientX &gt; EloffsetLeft + elW - 10 &amp;&amp; clientX &lt; EloffsetLeft + elW) {
                        // 往左拖拽
                        if (clientX &gt; e.clientX) {
                            // eslint-disable-next-line no-empty
                            if (dragDom.clientWidth &lt; minWidth) {
                            } else {
                                dragDom.style.width = elW - (clientX - e.clientX) * 2 + 'px';
                            }
                        }
                        // 往右拖拽
                        if (clientX &lt; e.clientX) {
                            dragDom.style.width = elW + (e.clientX - clientX) * 2 + 'px';
                        }
                    }
                    // 底部鼠标拖拽位置
                    if (ELscrollTop + clientY &gt; EloffsetTop + elH - 20 &amp;&amp; ELscrollTop + clientY &lt; EloffsetTop + elH) {
                        // 往上拖拽

                        if (clientY &gt; e.clientY) {
                            if (dragDom.clientHeight &gt;= minHeight) {
                                dragDom.style.height = elH - (clientY - e.clientY) * 2 + 'px';
                                modalContent.style.maxHeight = elH - (clientY - e.clientY) * 2 - 100 + 'px'
                            }
                        }
                        // 往下拖拽
                        if (clientY &lt; e.clientY) {
                            dragDom.style.height = elH + (e.clientY - clientY) * 2 + 'px';
                            modalContent.style.maxHeight = elH + (e.clientY - clientY) * 2 - 100 + 'px'
                        }
                    }
                };

                // 拉伸结束
                document.onmouseup = function (e) {
                    document.onmousemove = null;
                    document.onmouseup = null;
                };
            }

            // 头部移动
            dialogHeaderEl.onmousedown = (e: any) =&gt; {
                // 鼠标按下，计算当前元素距离可视区的距离
                const disX = e.clientX - dialogHeaderEl.offsetLeft
                const disY = e.clientY - dialogHeaderEl.offsetTop
                const screenWidth = document.body.clientWidth // body 当前宽度
                const screenHeight = document.documentElement.clientHeight // 可见区域高度(应为body高度，可某些环境下无法获取)

                const dragDomWidth = dragDom.offsetWidth // 对话框宽度
                const dragDomheight = dragDom.offsetHeight // 对话框高度

                const minDragDomLeft = dragDom.offsetLeft
                const maxDragDomLeft = screenWidth - dragDom.offsetLeft - dragDomWidth

                const minDragDomTop = dragDom.offsetTop
                const maxDragDomTop = screenHeight - dragDom.offsetTop - dragDomheight

                // 获取到的值带px 正则匹配替换
                let styL: any = sty(dragDom, 'left')
                // 为兼容ie
                if (styL === 'auto') styL = '0px'
                let styT: any = sty(dragDom, 'top')

                // console.log(styL)
                // 注意在ie中 第一次获取到的值为组件自带50% 移动之后赋值为px
                if (styL.includes('%')) {
                    styL = +document.body.clientWidth * (+styL.replace(/%/g, '') / 100)
                    styT = +document.body.clientHeight * (+styT.replace(/%/g, '') / 100)
                } else {
                    styL = +styL.replace(/px/g, '')
                    styT = +styT.replace(/px/g, '')
                }

                document.onmousemove = function (e) {
                    // 通过事件委托，计算移动的距离
                    let left = e.clientX - disX
                    let top = e.clientY - disY
                    // 边界处理
                    if (-(left) &gt; minDragDomLeft) {
                        left = -(minDragDomLeft)
                    } else if (left &gt; maxDragDomLeft) {
                        left = maxDragDomLeft
                    }

                    if (-(top) &gt; minDragDomTop) {
                        top = -(minDragDomTop)
                    } else if (top &gt; maxDragDomTop) {
                        top = maxDragDomTop
                    }

                    // 移动当前元素
                    dragDom.style.cssText += `;left:${left + styL}px;top:${top + styT}px;`
                }

                document.onmouseup = function (e: any) {
                    document.onmousemove = null
                    document.onmouseup = null
                }
                return false
            }
        })
    }
}
</code></pre> 
<p><img alt="" height="526" src="https://images2.imgbox.com/8b/e3/IYt0BA6W_o.png" width="426"></p> 
<p></p> 
<p>main.ts中引入 全局使用</p> 
<pre><code class="language-TypeScript">const app = createApp(App);
import App from "./App.vue";
import directive from './common/Directive/index'; // 统一自定义指令入口
directive(app)</code></pre> 
<p>参考文章</p> 
<p><a href="https://blog.csdn.net/weixin_50651687/article/details/127808389" title="Vue3 + Ant Design Vue Modal 对话框可拖拽指令_无恙คิดถึง的博客-CSDN博客">Vue3 + Ant Design Vue Modal 对话框可拖拽指令_无恙คิดถึง的博客-CSDN博客</a></p> 
<p><a href="https://yhc555.blog.csdn.net/article/details/125993616" rel="nofollow" title="Antdesign a-modal自定义指令实现拖拽放大缩小_温柔的风归功于带笑的你的博客-CSDN博客">Antdesign a-modal自定义指令实现拖拽放大缩小_温柔的风归功于带笑的你的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/297c52cfc7d17490a9ccc6951159b108/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VUE3 中实现拖拽和缩放自定义看板 vue-grid-layout</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f5575a473bdf34378de73c089394531d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android App手势冲突处理中上下左右滑动的处理以及侧滑边缘菜单的讲解及实战（附源码 可直接使用）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>