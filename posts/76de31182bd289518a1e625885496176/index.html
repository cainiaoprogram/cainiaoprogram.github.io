<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件安全内存区域详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件安全内存区域详解" />
<meta property="og:description" content="知识回顾 编制程序的四个步骤：编辑、编译、链接和运行
编译：检查语法并对单个文件产生可执行程序
链接：多个可执行文件进行关联（函数调用信息），增加启动程序等如何认识BUG和漏洞
BUG就是缺陷，一种表现就是用户部分操作导致程序崩溃，比如输入超长、除以0等
程序崩溃就意味着用户的输入会影响程序正常执行，意味着可能通过BUG提供的入口输入构造的恶意程序让程序做非法的事情，因此在安全人眼里，BUG是一种软件漏洞 知识点一：内存区域 内存区域：一个进程可能被分配到不同的内存区域去执行
代码区：通常是指用来存放程序执行代码的一块内存区域。这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指并执行。静态数据区：通常是指用来存放程序运行时的全局变量、静态变量等的内存区域。通常，静态数据区包括初始化数据区（Data Segment）和未初始化数据区（BSS Segment）两部分。未初始化数据区BSS区存放的是未初始化的全局变量和静态变量，特点是可读写，在程序执行之前BSS段会自动清0。堆区：用于动态地分配进程内存。进程可以在堆区动态地请求一定大小的内存（给代码区的代码使用），并在用完之后归还给堆区。动态分配和回收是堆区的特点。栈区：用于支持进程的执行，动态地存储函数之间的调用关系、局部变量等，以保证被调用函数在返回时恢复到母函数中继续执行。
程序在执行的过程需要两种不同类型的内存来协同配合，即栈区和堆区。
堆区和栈区的区别
申请方式： 栈：由系统自动分配。例如，声明一个局部变量int b，系统自动在栈中为b开辟空间。堆：需要程序员自己申请，并指明大小，在c中malloc函数，如 p 1 = ( c h a r ∗ ) m a l l o c ( 10 ) p1 = (char^*)malloc(10) p1=(char∗)malloc(10) 。 申请效率： 栈由系统自动分配，速度较快，但程序员是无法控制的。堆是由程序员分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来方便。
**注意：指向堆块的指针或者句柄，指向的是块身的首地址。**也就是，我们使用函数申请得到的地址指针都会越过8字节(32位系统)的块首，直接指向数据区(块身)。
堆块的大小包括块首在内，如果申请32字节，实际会分配40字节，8字节的块首&#43;32字节的块身。
堆块的单位是8字节，不足8字节按8字节分配。
在Windows系统中，占有态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。其中，最重要的堆表有两种：空闲双向链表freelist（简称空表）和快速单向链表lookaside（简称快表）。快表是为了加速堆块分配而采用的堆表，从来不发生堆块合并。由于堆溢出一般不利用快表，故不作详述。
空表包含空表索引(Freelist array)和空闲链块两个部分。空表索引也叫空表表头，是一个大小为128的指针数组，该数组的每一项包括两个指针，用于标识一条空表。
堆块释放。堆块的释放操作包括将堆块状态由占用态改为空闲态、链入相应的堆表。所有释放的堆块都链入相应的表尾。
堆块合并。堆块的分配和释放操作可能引发堆块合并，即当堆管理系统发现两个空闲堆块相邻时，就会进行堆块合并操作。
堆块的合并包括几个动作：将堆块从空表中卸下、合并堆块、修改合并后的块首、链接入新的链表（合并的时候还有一种操作叫内存紧缩）。
知识点二：函数调用 函数调用时候将借助系统栈来完成函数状态的保存和恢复。代码区中精确的跳转都是在与系统栈巧妙地配合过程中完成的。当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。**每个栈帧对应着一个未运行完的函数。**栈帧中保存了该函数的返回地址和局部变量。从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。当函数返回时，系统栈会弹出该函数所对应的栈帧。函数调用的步骤： 参数入栈：将参数从右向左依次压入系统栈中。返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行。代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。栈帧调整： 保存当前栈帧状态值，已备后面恢复本栈帧时使用。将当前栈帧切换到新栈帧。 知识点三：常见寄存器 寄存器（register）是中央处理器CPU的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。我们常常看到32位CPU、64位CPU这样的名称，其实指的就是寄存器的大小。32位CPU的寄存器大小就是4个字节。
CPU本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU要用的时候就去内存读写数据。但是，CPU的运算速度远高于内存的读写速度，为了避免被拖慢，CPU都自带一级缓存和二级缓存。基本上，CPU缓存可以看作是读写速度较快的内存。但是，CPU缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU使用寄存器来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU优先读写寄存器，再由寄存器跟内存交换数据。
每一个函数独占自己的栈帧空间。当前正在运行的函数的栈帧总是在栈顶。
ESP：栈指针寄存器（extended stack pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。
EBP：基址指针寄存器（extended base pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。
ESP和EBP之间的内存空间为当前栈帧，EBP标识了当前栈帧的底部，ESP标识了当前栈帧的顶部。
EIP：指令寄存器（extended instruction pointer），其内存放着一个指针，该指针永远指向下一条等待执行的指令地址。可以说如果控制了EIP寄存器的内容，就控制了进程——我们让EIP指向哪里，CPU就会去执行哪里的指令。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/76de31182bd289518a1e625885496176/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-08T18:40:14+08:00" />
<meta property="article:modified_time" content="2022-08-08T18:40:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件安全内存区域详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>知识回顾</h3> 
<ul><li>编制程序的四个步骤：编辑、编译、链接和运行<br> 编译：检查语法并对单个文件产生可执行程序<br> 链接：多个可执行文件进行关联（函数调用信息），增加启动程序等</li><li>如何认识BUG和漏洞<br> BUG就是缺陷，一种表现就是用户部分操作导致程序崩溃，比如输入超长、除以0等<br> 程序崩溃就意味着用户的输入会影响程序正常执行，意味着可能通过BUG提供的入口输入构造的恶意程序让程序做非法的事情，因此在安全人眼里，BUG是一种软件漏洞</li></ul> 
<h3><a id="_8"></a>知识点一：内存区域</h3> 
<ul><li> <p>内存区域：一个进程可能被分配到不同的内存区域去执行</p> 
  <ol><li>代码区：通常是指用来存放程序执行代码的一块内存区域。<strong>这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指并执行</strong>。</li><li>静态数据区：通常是指用来存放程序运行时的全局变量、静态变量等的内存区域。通常，静态数据区包括初始化数据区（Data Segment）和未初始化数据区（BSS Segment）两部分。未初始化数据区BSS区存放的是未初始化的全局变量和静态变量，特点是可读写，在程序执行之前BSS段会自动清0。</li><li>堆区：用于动态地分配进程内存。进程可以在堆区动态地请求一定大小的内存（给代码区的代码使用），并在用完之后归还给堆区。<strong>动态分配和回收是堆区的特点。</strong></li><li>栈区：用于支持进程的执行，<strong>动态地存储函数之间的调用关系、局部变量等</strong>，以保证被调用函数在返回时恢复到母函数中继续执行。<br> <img src="https://images2.imgbox.com/30/d9/0HqR4Xdl_o.png" alt="在这里插入图片描述"></li></ol> </li><li> <p>程序在执行的过程需要两种不同类型的内存来协同配合，即栈区和堆区。<br> <img src="https://images2.imgbox.com/4d/e1/KUOuIhIh_o.png" alt="在这里插入图片描述"></p> </li><li> <p>堆区和栈区的区别</p> 
  <ol><li>申请方式：</li></ol> 
  <ul><li>栈：由系统自动分配。例如，声明一个局部变量int b，系统自动在栈中为b开辟空间。</li><li>堆：需要程序员自己申请，并指明大小，在c中malloc函数，如<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            p 
           
          
            1 
           
          
            = 
           
          
            ( 
           
          
            c 
           
          
            h 
           
          
            a 
           
           
           
             r 
            
           
             ∗ 
            
           
          
            ) 
           
          
            m 
           
          
            a 
           
          
            l 
           
          
            l 
           
          
            o 
           
          
            c 
           
          
            ( 
           
          
            10 
           
          
            ) 
           
          
         
           p1 = (char^*)malloc(10) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8389em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord"><span style="margin-right: 0.0278em;" class="mord mathnormal">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6887em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">ma</span><span style="margin-right: 0.0197em;" class="mord mathnormal">ll</span><span class="mord mathnormal">oc</span><span class="mopen">(</span><span class="mord">10</span><span class="mclose">)</span></span></span></span></span> 。</li></ul> 
  <ol start="2"><li>申请效率：</li></ol> 
  <ul><li>栈由系统自动分配，速度较快，但程序员是无法控制的。</li><li>堆是由程序员分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来方便。<br> <img src="https://images2.imgbox.com/45/4f/RjOa0p9D_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/a0/e5/htZDOvuZ_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>**注意：指向堆块的指针或者句柄，指向的是块身的首地址。**也就是，我们使用函数申请得到的地址指针都会越过8字节(32位系统)的块首，直接指向数据区(块身)。</p> </li><li> <p><strong>堆块的大小包括块首在内，如果申请32字节，实际会分配40字节，8字节的块首+32字节的块身。</strong></p> </li><li> <p><strong>堆块的单位是8字节，不足8字节按8字节分配。</strong></p> </li><li> <p>在Windows系统中，占有态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。其中，最重要的堆表有两种：空闲双向链表freelist（简称空表）和快速单向链表lookaside（简称快表）。快表是为了加速堆块分配而采用的堆表，从来不发生堆块合并。由于堆溢出一般不利用快表，故不作详述。</p> </li><li> <p>空表包含空表索引(Freelist array)和空闲链块两个部分。空表索引也叫空表表头，是一个大小为128的指针数组，该数组的每一项包括两个指针，用于标识一条空表。<br> <img src="https://images2.imgbox.com/df/27/3Jlu34Ls_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/e6/4c/O3ya0NcD_o.png" alt="在这里插入图片描述"></p> </li><li> <p>堆块释放。堆块的释放操作包括将堆块状态由占用态改为空闲态、链入相应的堆表。所有释放的堆块都链入相应的表尾。</p> </li><li> <p>堆块合并。堆块的分配和释放操作可能引发堆块合并，即当堆管理系统发现两个空闲堆块相邻时，就会进行堆块合并操作。</p> </li><li> <p>堆块的合并包括几个动作：将堆块从空表中卸下、合并堆块、修改合并后的块首、链接入新的链表（合并的时候还有一种操作叫内存紧缩）。</p> </li></ul> 
<h3><a id="_43"></a>知识点二：函数调用</h3> 
<ul><li>函数调用时候将借助系统栈来完成函数状态的保存和恢复。</li><li>代码区中精确的跳转都是在与系统栈巧妙地配合过程中完成的。</li><li>当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。</li><li>**每个栈帧对应着一个未运行完的函数。**栈帧中保存了该函数的返回地址和局部变量。从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。</li><li>当函数返回时，系统栈会弹出该函数所对应的栈帧。</li><li><strong>函数调用的步骤：</strong> 
  <ol><li>参数入栈：将参数从右向左依次压入系统栈中。</li><li>返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行。</li><li>代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。</li><li>栈帧调整：</li></ol> 
  <ul><li>保存当前栈帧状态值，已备后面恢复本栈帧时使用。</li><li>将当前栈帧切换到新栈帧。</li></ul> </li></ul> 
<h3><a id="_57"></a>知识点三：常见寄存器</h3> 
<p>寄存器（register）是中央处理器CPU的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。我们常常看到32位CPU、64位CPU这样的名称，其实指的就是寄存器的大小。32位CPU的寄存器大小就是4个字节。<br> <em><strong>CPU本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU要用的时候就去内存读写数据。但是，CPU的运算速度远高于内存的读写速度，为了避免被拖慢，CPU都自带一级缓存和二级缓存。基本上，CPU缓存可以看作是读写速度较快的内存。但是，CPU缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU使用寄存器来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU优先读写寄存器，再由寄存器跟内存交换数据。</strong></em></p> 
<ul><li> <p>每一个函数独占自己的栈帧空间。当前正在运行的函数的栈帧总是在栈顶。</p> </li><li> <p>ESP：栈指针寄存器（extended stack pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</p> </li><li> <p>EBP：基址指针寄存器（extended base pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p> </li><li> <p><strong>ESP和EBP之间的内存空间为当前栈帧，EBP标识了当前栈帧的底部，ESP标识了当前栈帧的顶部。</strong><br> <img src="https://images2.imgbox.com/8c/a8/98l6Q144_o.png" alt="在这里插入图片描述"></p> </li><li> <p>EIP：指令寄存器（extended instruction pointer），其内存放着一个指针，该指针永远指向下一条等待执行的指令地址。可以说如果控制了EIP寄存器的内容，就控制了进程——我们让EIP指向哪里，CPU就会去执行哪里的指令。</p> </li><li> <p>在函数调用过程中，结合寄存器看一下如何实现栈帧调整：</p> 
  <ol><li>保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP入栈）。</li><li>将当前栈帧切换到新栈帧（将ESP值赋值EBP，更新栈帧底部）。</li></ol> </li></ul> 
<h3><a id="_71"></a>知识点四：主要寄存器</h3> 
<ul><li> <p>2个变址寄存器(ESI和EDI) ：变址寄存器主要用来存放操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。</p> 
  <ul><li>ESI通常在内存操作指令中作为“源地址指针”使用</li><li>而EDI通常在内存操作指令中作为“目的地址指针”使用。</li></ul> </li><li> <p>2个指针寄存器(ESP和EBP)：寄存器EBP、ESP称为指针寄存器(Pointer Register)，<strong>主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式</strong>，为以不同的地址形式访问存储单元提供方便。**指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。**EBP为基指针(Base Pointer)寄存器，通过它减去一定的偏移值，来访问栈中的元素；</p> </li><li> <p>4个数据寄存器(EAX、EBX、ECX和EDX)：主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。</p> </li><li> <p>6个段寄存器(ES、CS、SS、DS、FS和GS)</p> </li><li> <p>1个指令指针寄存器(EIP)</p> </li><li> <p>1个标志寄存器(EFlags)</p> </li><li> <p>EAX通常称为累加器(Accumulator)：可用于乘、 除、输入/输出等操作，它们的使用频率很高。<strong>EAX还通常用于存储函数的返回值。</strong></p> </li><li> <p>EBX称为基地址寄存器(Base Register)：它可作为存储器指针来使用，用来访问存储器。</p> </li><li> <p><strong>ECX称为计数寄存器(Count Register)：在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数。</strong></p> </li><li> <p>EDX称为数据寄存器(Data Register)：在进行乘、除运算时，可作为默认操作数参与运算，也可用于存放I/O的端口地址。<br> <img src="https://images2.imgbox.com/72/b1/szb86Rae_o.png" alt="在这里插入图片描述"></p> </li><li> <p>指令寄存器（IR，Instruction Register），是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一条指令。当执行一条指令时，先把它从内存取到数据寄存器（DR，Data Register）中，然后再传送至IR。指令划分为操作码和地址码字段，由二进制数字组成。</p> </li><li> <p>标志寄存器在32位操作系统中大小是32位的，也就是说，它可以存32个标志。实际上标志寄存器并没有完全被使用，重点认识三个标志寄存器：ZF (零标志)、OF(溢出标志)、CF(进位标志)。</p> </li><li> <p>Z-Flag(零标志)：它可以设成0或者1。</p> </li><li> <p>O-Flag(溢出标志)：反映有符号数加减运算是否溢出。如果运算结果超过了有符号数的表示范围，则OF置1，否则置0。例如：EAX的值为7FFFFFFFF，如果你此时再给EAX加1，OF寄存器就会被设置成1，因为此时EAX寄存器的最高有效位改变了。</p> </li><li> <p>C-Flag(进位标志)：用于反映运算是否产生进位或借位。如果运算结果的最高位产生一个进位或借位，则CF置1，否则置0。例，假如某寄存器值为FFFFFFFF，再加上1就会产生进位</p> </li></ul> 
<h2><a id="_92"></a>参考书籍</h2> 
<p>《软件安全:漏洞利用及渗透测试》刘哲理老师主编</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4450d6b19df6921b7f8874a40639d13/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">缓存穿透、击穿、雪崩</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e6687b24ec83c5124bdb095b5f816968/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机病毒，蠕虫，木马三者之间的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>