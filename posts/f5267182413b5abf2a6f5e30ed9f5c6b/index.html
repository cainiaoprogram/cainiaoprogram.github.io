<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android短彩信源码解析-短信发送流程（三） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android短彩信源码解析-短信发送流程（三）" />
<meta property="og:description" content="3、短信pdu的压缩与封装
相关文章:
-------------------------------------------------------------
1、短信发送上层逻辑
2、短信发送framework层逻辑
-------------------------------------------------------------
一直很逃避对这一部分做一个总结。因为这部分有些超出我能力范围之外，关于段彩信的3GPP协议，也看过一些，但总归觉得自己并非专业。对协议的学习仅仅停留在使用层面。刚开始了解这部分的时候，下过许多功夫，也走了不少弯路，为了截取pdu数据包，给10086/10010发了无数的短信（截取pdu数据log包需要发短信，给他们发短信测试不花钱，虽然通信费公司报销一部分，为公司省钱的娃），最后对pdu使用豁然开朗还是在看了网上一位大神写的帖子之后。（在文章之后会贴出来）
ps：强烈建议大家做几遍pdu的压缩与解析，对学习pdu的使用有很大帮助。大家可以参照文章最后贴出来的大神的解析过程，结合代码进行分析。
以下是从代码实现的角度来总结一下，为那些“挣扎”在pdu问题的娃抛个砖，引个路。如有错误，敬请批评指正，不胜感激。
ps：每条短信可容纳多少字符啊？
答：看代码。
SmsSingleReceipientSender.java
if ((MmsConfig.getEmailGateway() != null) &amp;&amp; (Mms.isEmailAddress(mDest) || MessageUtils.isAlias(mDest))) { String msgText; msgText = mDest &#43; &#34; &#34; &#43; mMessageText; mDest = MmsConfig.getEmailGateway(); messages = smsManager.divideMessage(msgText); } else { messages = smsManager.divideMessage(mMessageText); // remove spaces from destination number (e.g. &#34;801 555 1212&#34; -&gt; &#34;8015551212&#34;) mDest = mDest.replaceAll(&#34; &#34;, &#34;&#34;); mDest = Conversation.verifySingleRecipient(mContext, mThreadId, mDest); } 最终调用：
SmsMessage.java
会执行：fragmentText（）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f5267182413b5abf2a6f5e30ed9f5c6b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-11-18T19:56:30+08:00" />
<meta property="article:modified_time" content="2013-11-18T19:56:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android短彩信源码解析-短信发送流程（三）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>3、短信pdu的压缩与封装</p> 
<p>相关文章:</p> 
<p>-------------------------------------------------------------</p> 
<p><span style="font-size:18px">1、</span><a target="_blank" href="http://blog.csdn.net/droyon/article/details/10194591" rel="noopener noreferrer"><span style="font-size:18px">短信发送上层逻辑</span></a></p> 
<p><span style="font-size:18px">2、</span><a target="_blank" href="http://blog.csdn.net/droyon/article/details/11699935" rel="noopener noreferrer"><span style="font-size:18px">短信发送framework层逻辑</span></a></p> 
<p>-------------------------------------------------------------</p> 
<p>一直很逃避对这一部分做一个总结。因为这部分有些超出我能力范围之外，关于段彩信的3GPP协议，也看过一些，但总归觉得自己并非专业。对协议的学习仅仅停留在使用层面。刚开始了解这部分的时候，下过许多功夫，也走了不少弯路，为了截取pdu数据包，给10086/10010发了无数的短信（截取pdu数据log包需要发短信，给他们发短信测试不花钱，虽然通信费公司报销一部分，为公司省钱的娃），最后对pdu使用豁然开朗还是在看了网上一位大神写的帖子之后。（在文章之后会贴出来）</p> 
<p>ps：强烈建议大家做几遍pdu的压缩与解析，对学习pdu的使用有很大帮助。大家可以参照文章最后贴出来的大神的解析过程，结合代码进行分析。</p> 
<p> </p> 
<p>以下是从代码实现的角度来总结一下，为那些“挣扎”在pdu问题的娃抛个砖，引个路。如有错误，敬请批评指正，不胜感激。</p> 
<p>ps：每条短信可容纳多少字符啊？</p> 
<p>答：看代码。</p> 
<p>SmsSingleReceipientSender.java</p> 
<pre><code class="language-java">if ((MmsConfig.getEmailGateway() != null) &amp;&amp;
                (Mms.isEmailAddress(mDest) || MessageUtils.isAlias(mDest))) {
            String msgText;
            msgText = mDest + " " + mMessageText;
            mDest = MmsConfig.getEmailGateway();
            messages = smsManager.divideMessage(msgText);
        } else {
            messages = smsManager.divideMessage(mMessageText);
            // remove spaces from destination number (e.g. "801 555 1212" -&gt; "8015551212")
            mDest = mDest.replaceAll(" ", "");
            mDest = Conversation.verifySingleRecipient(mContext, mThreadId, mDest);
        }</code></pre> 
<p>最终调用：</p> 
<p>SmsMessage.java</p> 
<p>会执行：fragmentText（）</p> 
<pre><code class="language-java">TextEncodingDetails ted = (PHONE_TYPE_CDMA == activePhone) ?
            com.android.internal.telephony.cdma.SmsMessage.calculateLength(text, false) :
            com.android.internal.telephony.gsm.SmsMessage.calculateLength(text, false);</code></pre> 
<p>往下追一下代码就可以找到答案。这里附上几个参考值：</p> 
<pre><code class="language-java"> /** The maximum number of payload bytes per message */
    public static final int MAX_USER_DATA_BYTES = 140;

    /**
     * The maximum number of payload bytes per message if a user data header
     * is present.  This assumes the header only contains the
     * CONCATENATED_8_BIT_REFERENCE element.
     */
    public static final int MAX_USER_DATA_BYTES_WITH_HEADER = 134;

    /** The maximum number of payload septets per message */
    public static final int MAX_USER_DATA_SEPTETS = 160;

    /**
     * The maximum number of payload septets per message if a user data header
     * is present.  This assumes the header only contains the
     * CONCATENATED_8_BIT_REFERENCE element.
     */
    public static final int MAX_USER_DATA_SEPTETS_WITH_HEADER = 153;</code></pre> 
<p><br>  </p> 
<p>下面进入正题：</p> 
<p>1、在我们调用SmsDispatcher.java进行发送短信，会执行sendText方法,具体的方法实现，在子类中：</p> 
<p>GsmSmsDispatcher.java</p> 
<pre><code class="language-java">protected void sendText(String destAddr, String scAddr, String text,
            PendingIntent sentIntent, PendingIntent deliveryIntent) {
        SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(
                scAddr, destAddr, text, (deliveryIntent != null));
        if (pdu != null) {
            sendRawPdu(pdu.encodedScAddress, pdu.encodedMessage, sentIntent, deliveryIntent);
        } else {
            Log.e(TAG, "GsmSMSDispatcher.sendText(): getSubmitPdu() returned null");
        }
    }</code></pre> 
<p>CdmaSmsDispatcher.java</p> 
<pre><code class="language-java">protected void sendText(String destAddr, String scAddr, String text,
            PendingIntent sentIntent, PendingIntent deliveryIntent) {
        SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(
                scAddr, destAddr, text, (deliveryIntent != null), null);
        sendSubmitPdu(pdu, sentIntent, deliveryIntent);
    }</code></pre> 
<p><br> Gsm与Cdma大体的流程是类似的，都为：构建pdu对象、进入信息头部标识、编码收件人地址（短信中心号码等）、编码信息内容、编码信息时间内容等。</p> 
<p>具体的差别存在于编码信息内容，Gsm采用7bit，CMDA可以说是采用4bit。</p> 
<p>我们以CDMA为例：</p> 
<p>2、com.android.internal.telephony.cdma.SmsMessage.java<br> getSubmitPdu（）方法：</p> 
<pre><code class="language-java">public static SubmitPdu getSubmitPdu(String scAddr, String destAddr, String message,
            boolean statusReportRequested, SmsHeader smsHeader) {

        /**
         * TODO(cleanup): Do we really want silent failure like this?
         * Would it not be much more reasonable to make sure we don't
         * call this function if we really want nothing done?
         */
        if (message == null || destAddr == null) {
            return null;
        }

        UserData uData = new UserData();
        uData.payloadStr = message;
        uData.userDataHeader = smsHeader;
        return privateGetSubmitPdu(destAddr, statusReportRequested, uData);
    }</code></pre> 
<p>在这个方法中，new了一个UserData对象，其中信息内容message放在了payloadStr变量中，smsHeader放在了userDataHeader中。这里smsHeader可忽略。</p> 
<p>我们继续看一下privateGetSubmitPdu方法：</p> 
<p>3、privateGetSubmitPdu：</p> 
<pre><code class="language-java">private static SubmitPdu privateGetSubmitPdu(String destAddrStr, boolean statusReportRequested,
            UserData userData) {

        /**
         * TODO(cleanup): give this function a more meaningful name.
         */

        /**
         * TODO(cleanup): Make returning null from the getSubmitPdu
         * variations meaningful -- clean up the error feedback
         * mechanism, and avoid null pointer exceptions.
         */

        /**
         * North America Plus Code :
         * Convert + code to 011 and dial out for international SMS
         */
        CdmaSmsAddress destAddr = CdmaSmsAddress.parse(
                PhoneNumberUtils.cdmaCheckAndProcessPlusCode(destAddrStr));
        if (destAddr == null) return null;

        BearerData bearerData = new BearerData();
        bearerData.messageType = BearerData.MESSAGE_TYPE_SUBMIT;

        bearerData.messageId = getNextMessageId();

        bearerData.deliveryAckReq = statusReportRequested;
        bearerData.userAckReq = false;
        bearerData.readAckReq = false;
        bearerData.reportReq = false;

        bearerData.userData = userData;

        byte[] encodedBearerData = BearerData.encode(bearerData);
        if (Log.isLoggable(LOGGABLE_TAG, Log.VERBOSE)) {
            Log.d(LOG_TAG, "MO (encoded) BearerData = " + bearerData);
            Log.d(LOG_TAG, "MO raw BearerData = '" + HexDump.toHexString(encodedBearerData) + "'");
        }
        if (encodedBearerData == null) return null;

        int teleservice = bearerData.hasUserDataHeader ?
                SmsEnvelope.TELESERVICE_WEMT : SmsEnvelope.TELESERVICE_WMT;

        SmsEnvelope envelope = new SmsEnvelope();
        envelope.messageType = SmsEnvelope.MESSAGE_TYPE_POINT_TO_POINT;
        envelope.teleService = teleservice;
        envelope.destAddress = destAddr;
        envelope.bearerReply = RETURN_ACK;
        envelope.bearerData = encodedBearerData;

        /**
         * TODO(cleanup): envelope looks to be a pointless class, get
         * rid of it.  Also -- most of the envelope fields set here
         * are ignored, why?
         */

        try {
            /**
             * TODO(cleanup): reference a spec and get rid of the ugly comments
             */
            ByteArrayOutputStream baos = new ByteArrayOutputStream(100);
            DataOutputStream dos = new DataOutputStream(baos);
            dos.writeInt(envelope.teleService);
            dos.writeInt(0); //servicePresent
            dos.writeInt(0); //serviceCategory
            dos.write(destAddr.digitMode);
            dos.write(destAddr.numberMode);
            dos.write(destAddr.ton); // number_type
            dos.write(destAddr.numberPlan);
            dos.write(destAddr.numberOfDigits);
            dos.write(destAddr.origBytes, 0, destAddr.origBytes.length); // digits
            // Subaddress is not supported.
            dos.write(0); //subaddressType
            dos.write(0); //subaddr_odd
            dos.write(0); //subaddr_nbr_of_digits
            dos.write(encodedBearerData.length);
            dos.write(encodedBearerData, 0, encodedBearerData.length);
            dos.close();

            SubmitPdu pdu = new SubmitPdu();
            pdu.encodedMessage = baos.toByteArray();
            pdu.encodedScAddress = null;
            return pdu;
        } catch(IOException ex) {
            Log.e(LOG_TAG, "creating SubmitPdu failed: " + ex);
        }
        return null;
    }

</code></pre> 
<p>3.1、在这个方法中，首先进行了信息Address的编码</p> 
<pre><code class="language-java">public static CdmaSmsAddress parse(String address) {
        CdmaSmsAddress addr = new CdmaSmsAddress();
        addr.address = address;
        addr.ton = CdmaSmsAddress.TON_UNKNOWN;
        byte[] origBytes = null;
        String filteredAddr = filterNumericSugar(address);
        if (filteredAddr != null) {
            origBytes = parseToDtmf(filteredAddr);
        }
        if (origBytes != null) {
            addr.digitMode = DIGIT_MODE_4BIT_DTMF;
            addr.numberMode = NUMBER_MODE_NOT_DATA_NETWORK;
            if (address.indexOf('+') != -1) {
                addr.ton = TON_INTERNATIONAL_OR_IP;
            }
        } else {
            filteredAddr = filterWhitespace(address);
            origBytes = UserData.stringToAscii(filteredAddr);
            if (origBytes == null) {
                return null;
            }
            addr.digitMode = DIGIT_MODE_8BIT_CHAR;
            addr.numberMode = NUMBER_MODE_DATA_NETWORK;
            if (address.indexOf('@') != -1) {
                addr.ton = TON_NATIONAL_OR_EMAIL;
            }
        }
        addr.origBytes = origBytes;
        addr.numberOfDigits = origBytes.length;
        return addr;
    }</code></pre> 
<p>在这个方法内会依据号码格式做一下调整，比如头部含有“+”号怎么处理，然后调用4bit或者8bit压缩电话号码，具体流程以及压缩过程感兴趣的可以打log进行追一下。</p> 
<p>3.2、接下来初始化一个BearerData对象，并执行encode进行编码，此处主要是对信息内容进行编码。<br> </p> 
<pre><code class="language-java">BearerData bearerData = new BearerData();
        bearerData.messageType = BearerData.MESSAGE_TYPE_SUBMIT;

        bearerData.messageId = getNextMessageId();

        bearerData.deliveryAckReq = statusReportRequested;
        bearerData.userAckReq = false;
        bearerData.readAckReq = false;
        bearerData.reportReq = false;</code></pre> 
<p>信息的MessageType，MessageId等信息加入到bearerData对象中。</p> 
<pre><code class="language-java">bearerData.userData = userData;</code></pre> 
<p>将userData对象赋给bearerData对象的userData变量中，我们找到bearerData对象内部包含了信息的内容msg信息。<br> 下面调用encode进行编码</p> 
<pre><code class="language-java">public static byte[] encode(BearerData bData) {
        bData.hasUserDataHeader = ((bData.userData != null) &amp;&amp;
                (bData.userData.userDataHeader != null));
        try {
            BitwiseOutputStream outStream = new BitwiseOutputStream(200);
            outStream.write(8, SUBPARAM_MESSAGE_IDENTIFIER);
            encodeMessageId(bData, outStream);
            if (bData.userData != null) {
                outStream.write(8, SUBPARAM_USER_DATA);
                encodeUserData(bData, outStream);//编码信息内容
            }
            if (bData.callbackNumber != null) {
                outStream.write(8, SUBPARAM_CALLBACK_NUMBER);
                encodeCallbackNumber(bData, outStream);
            }
            if (bData.userAckReq || bData.deliveryAckReq || bData.readAckReq || bData.reportReq) {
                outStream.write(8, SUBPARAM_REPLY_OPTION);
                encodeReplyOption(bData, outStream);//编码ackReq（信息确认相关），deliveryAckReq（发送报告相关），readAckReq（读取报告相关）等
            }
            if (bData.numberOfMessages != 0) {
                outStream.write(8, SUBPARAM_NUMBER_OF_MESSAGES);
                encodeMsgCount(bData, outStream);//编码信息数目
            }
            if (bData.validityPeriodRelativeSet) {
                outStream.write(8, SUBPARAM_VALIDITY_PERIOD_RELATIVE);
                encodeValidityPeriodRel(bData, outStream);
            }
            if (bData.privacyIndicatorSet) {
                outStream.write(8, SUBPARAM_PRIVACY_INDICATOR);
                encodePrivacyIndicator(bData, outStream);
            }
            if (bData.languageIndicatorSet) {
                outStream.write(8, SUBPARAM_LANGUAGE_INDICATOR);
                encodeLanguageIndicator(bData, outStream);//编码语言
            }
            if (bData.displayModeSet) {
                outStream.write(8, SUBPARAM_MESSAGE_DISPLAY_MODE);
                encodeDisplayMode(bData, outStream);//编码显示模式
            }
            if (bData.priorityIndicatorSet) {
                outStream.write(8, SUBPARAM_PRIORITY_INDICATOR);
                encodePriorityIndicator(bData, outStream);
            }
            if (bData.alertIndicatorSet) {
                outStream.write(8, SUBPARAM_ALERT_ON_MESSAGE_DELIVERY);
                encodeMsgDeliveryAlert(bData, outStream);
            }
            if (bData.messageStatusSet) {
                outStream.write(8, SUBPARAM_MESSAGE_STATUS);
                encodeMsgStatus(bData, outStream);//编码信息状态
            }
            return outStream.toByteArray();
        } catch (BitwiseOutputStream.AccessException ex) {
            Log.e(LOG_TAG, "BearerData encode failed: " + ex);
        } catch (CodingException ex) {
            Log.e(LOG_TAG, "BearerData encode failed: " + ex);
        }
        return null;
   }</code></pre> 
<p>首先判断信息是否包含userDataHeader，接着初始化一个BitwiseOutputStream对象，注意：此处已经开始将信息内容写入byte数组了，只不过信息内容变成了byte数组，还没有写入pdu对象中。</p> 
<p>关于信息内容的编码：</p> 
<pre><code class="language-java">private static void encodeUserDataPayload(UserData uData)
        throws CodingException
    {
        if ((uData.payloadStr == null) &amp;&amp; (uData.msgEncoding != UserData.ENCODING_OCTET)) {
            Log.e(LOG_TAG, "user data with null payloadStr");
            uData.payloadStr = "";
        }

        if (uData.userDataHeader != null) {
            encodeEmsUserDataPayload(uData);
            return;
        }

        if (uData.msgEncodingSet) {
            if (uData.msgEncoding == UserData.ENCODING_OCTET) {
                if (uData.payload == null) {
                    Log.e(LOG_TAG, "user data with octet encoding but null payload");
                    uData.payload = new byte[0];
                    uData.numFields = 0;
                } else {
                    uData.numFields = uData.payload.length;
                }
            } else {
                if (uData.payloadStr == null) {
                    Log.e(LOG_TAG, "non-octet user data with null payloadStr");
                    uData.payloadStr = "";
                }
                if (uData.msgEncoding == UserData.ENCODING_GSM_7BIT_ALPHABET) {
                    Gsm7bitCodingResult gcr = encode7bitGsm(uData.payloadStr, 0, true);
                    uData.payload = gcr.data;
                    uData.numFields = gcr.septets;
                } else if (uData.msgEncoding == UserData.ENCODING_7BIT_ASCII) {
                    uData.payload = encode7bitAscii(uData.payloadStr, true);
                    uData.numFields = uData.payloadStr.length();
                } else if (uData.msgEncoding == UserData.ENCODING_UNICODE_16) {
                    uData.payload = encodeUtf16(uData.payloadStr);
                    uData.numFields = uData.payloadStr.length();
                } else {
                    throw new CodingException("unsupported user data encoding (" +
                                              uData.msgEncoding + ")");
                }
            }
        } else {
            try {
                uData.payload = encode7bitAscii(uData.payloadStr, false);
                uData.msgEncoding = UserData.ENCODING_7BIT_ASCII;
            } catch (CodingException ex) {
                uData.payload = encodeUtf16(uData.payloadStr);
                uData.msgEncoding = UserData.ENCODING_UNICODE_16;
            }
            uData.numFields = uData.payloadStr.length();
            uData.msgEncodingSet = true;
        }
    }</code></pre> 
<p><br> 系统有许多编码方式，像octet，7bit_ascii,7bit_alphabet，16bit等。具体的流程以实际代码为准。</p> 
<p> </p> 
<p>总结：此部分编码完成之后会生成一个byte数组</p> 
<pre><code class="language-java">byte[] encodedBearerData = BearerData.encode(bearerData);</code></pre> 
<p><br> 这个数组内包含了信息内容以及信息内容相关的一些属性的值。数值编码格式大体如：[类别][长度][内容][类别][长度][内容][类别][长度][内容]<br> </p> 
<p>3.3、初始化SmsEnvelope对象，并加入pdu信息头部属性标识<br> </p> 
<pre><code class="language-java">int teleservice = bearerData.hasUserDataHeader ?
                SmsEnvelope.TELESERVICE_WEMT : SmsEnvelope.TELESERVICE_WMT;

        SmsEnvelope envelope = new SmsEnvelope();
        envelope.messageType = SmsEnvelope.MESSAGE_TYPE_POINT_TO_POINT;
        envelope.teleService = teleservice;
        envelope.destAddress = destAddr;
        envelope.bearerReply = RETURN_ACK;
        envelope.bearerData = encodedBearerData;</code></pre> 
<p>pdu的信息头部包含着：messageType，teleService等信息。我们看到我们之前的destAddr对象，以及encodeBearerData数组也被加入到这个对象中。</p> 
<p>3.4、以上可以说是pdu构建的准备阶段，接下来就是pdu数组构建的实施阶段了</p> 
<pre><code class="language-java">/*1、初始化对象*/
            ByteArrayOutputStream baos = new ByteArrayOutputStream(100);
            DataOutputStream dos = new DataOutputStream(baos);
            /*2、写入头部标识属性信息*/
            dos.writeInt(envelope.teleService);
            dos.writeInt(0); //servicePresent
            dos.writeInt(0); //serviceCategory
            /*3、写入收件人地址信息*/
            dos.write(destAddr.digitMode);
            dos.write(destAddr.numberMode);
            dos.write(destAddr.ton); // number_type
            dos.write(destAddr.numberPlan);
            dos.write(destAddr.numberOfDigits);
            dos.write(destAddr.origBytes, 0, destAddr.origBytes.length); // digits
            // Subaddress is not supported.
            /*4、写入信息内容正文信息内容*/
            dos.write(0); //subaddressType
            dos.write(0); //subaddr_odd
            dos.write(0); //subaddr_nbr_of_digits
            dos.write(encodedBearerData.length);
            dos.write(encodedBearerData, 0, encodedBearerData.length);
            dos.close();
            /*5、初始化pdu对象*/
            SubmitPdu pdu = new SubmitPdu();
            /*6、将pdu数组内容赋给初始化的pdu的encodedMessage变量中*/
            pdu.encodedMessage = baos.toByteArray();
            pdu.encodedScAddress = null;</code></pre> 
<p>代码比较简单，具体每步大体干什么标在注释上了。</p> 
<p>最后将pdu对象返回。</p> 
<p> </p> 
<p>4、总结：</p> 
<p>cdma的短信pdu压缩过程大体就是这样子了，Gsm短信pdu压缩与之类似。</p> 
<p>pdu解码也就是pdu压缩的逆过程。</p> 
<p>解析的过程在此就不介绍了，解析的方法也在本类中，parsePdu。</p> 
<p>解析短信的入口在RIL.java中，在RIL.java接收到来自moderm的信息上报，将上报的数组（pdu），加入parsePdu方法内，进行解析。</p> 
<pre><code class="language-java">private void parsePdu(byte[] pdu) {
        ByteArrayInputStream bais = new ByteArrayInputStream(pdu);
        DataInputStream dis = new DataInputStream(bais);
        byte length;
        int bearerDataLength;
        SmsEnvelope env = new SmsEnvelope();
        CdmaSmsAddress addr = new CdmaSmsAddress();

        try {
            env.messageType = dis.readInt();
            env.teleService = dis.readInt();
            env.serviceCategory = dis.readInt();

            addr.digitMode = dis.readByte();
            addr.numberMode = dis.readByte();
            addr.ton = dis.readByte();
            addr.numberPlan = dis.readByte();

            length = dis.readByte();
            addr.numberOfDigits = length;
            addr.origBytes = new byte[length];
            dis.read(addr.origBytes, 0, length); // digits

            env.bearerReply = dis.readInt();
            // CauseCode values:
            env.replySeqNo = dis.readByte();
            env.errorClass = dis.readByte();
            env.causeCode = dis.readByte();

            //encoded BearerData:
            bearerDataLength = dis.readInt();
            env.bearerData = new byte[bearerDataLength];
            dis.read(env.bearerData, 0, bearerDataLength);
            dis.close();
        } catch (Exception ex) {
            Log.e(LOG_TAG, "createFromPdu: conversion from byte array to object failed: " + ex);
        }

        // link the filled objects to this SMS
        originatingAddress = addr;
        env.origAddress = addr;
        mEnvelope = env;
        mPdu = pdu;

        parseSms();
    }</code></pre> 
<p><br> <br> ===================================================================================================================================</p> 
<p> </p> 
<p>大神的pdu解析之路：</p> 
<p><span style="font-family:Calibri; font-size:14px">CDMA SMS pdu</span>解码</p> 
<p><span style="font-family:Calibri; font-size:14px">Posted on June 28, 2010 by deli</span>去年玩过<span style="font-family:Calibri">via cdma</span>模组，刚开始对<span style="font-family:Calibri">cdmasms pdu</span>真是一脸茫然，意识到我也可能不会长时间做这个，网上这类帖子少之又少，体会初学者的辛苦，重新翻尸体，记录下来。</p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">收到两条短信，现在用<span style="font-family:Calibri">AT</span>把它们读取出来。</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-family:Calibri; font-size:14px">at+cmgr=5</span></p> 
<p><span style="font-family:Calibri; font-size:14px">+CMGR:5,</span>”<span style="font-family:Calibri">REC UNREAD</span>”<span style="font-family:Calibri">,</span>”<span style="font-family:Calibri">15338896020</span>″<span style="font-family:Calibri">,</span>”<span style="font-family:Calibri">UNKNOWNNUMBER</span>”<span style="font-family:Calibri">,</span>”<span style="font-family:Calibri">N/A</span>”<span style="font-family:Calibri">,176</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">“<span style="font-family:Calibri">0000021002020702c54ce225a8a80601c0089d00031001e801</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px">8e2230018801780193108b09fb087b317b012b6a080162e38c8e6</span></p> 
<p><span style="font-family:Calibri; font-size:14px">3b422e07b65980162b942e872e4b3b4246f7a70500162e54bbf9a7</span></p> 
<p><span style="font-family:Calibri; font-size:14px">053f67c7e3801729f544c0b108bb423918a75d00163317a70033b0</span></p> 
<p><span style="font-family:Calibri; font-size:14px">ae07ce3e00162b943108bb4236b54158a71680162ff5a7283b423</span></p> 
<p><span style="font-family:Calibri; font-size:14px">71c33b2b71c29dd80173108b09fb087b317c1a933cb80162b943659</span></p> 
<p><span style="font-family:Calibri; font-size:14px">b6a0bb4227122e5c00306081229192611</span>″</p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-family:Calibri; font-size:14px">at+cmgr=21</span></p> 
<p><span style="font-family:Calibri; font-size:14px">+CMGR:21,</span>”<span style="font-family:Calibri">REC UNREAD</span>”<span style="font-family:Calibri">,</span>”<span style="font-family:Calibri">15338896020</span>″<span style="font-family:Calibri">,</span>”<span style="font-family:Calibri">UNKNOWNNUMBER</span>”<span style="font-family:Calibri">,</span>”<span style="font-family:Calibri">N/A</span>”<span style="font-family:Calibri">,96</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">“<span style="font-family:Calibri">0000021002020702c54ce225a8a806014c084d00031001f8013</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px">e20f00190017801900162dfca7004b1acb1abb4239614c67001629</span></p> 
<p><span style="font-family:Calibri; font-size:14px">63b2b12b9827ae310c001729f544c0b108bb423918a75d00163317</span></p> 
<p><span style="font-family:Calibri; font-size:14px">a70029f52e07cf0f80306081229192616</span>″</p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-family:Calibri; font-size:14px">[deli@deli example]$ ./test_pdu_decode</span></p> 
<p><span style="font-family:Calibri; font-size:14px">0000021002020702c54ce225a8a80601c0089d00031001e8018e22</span></p> 
<p><span style="font-family:Calibri; font-size:14px">30018801780193108b09fb087b317b012b6a080162e38c8e63b422</span></p> 
<p><span style="font-family:Calibri; font-size:14px">e07b65980162b942e872e4b3b4246f7a70500162e54bbf9a7053f67</span></p> 
<p><span style="font-family:Calibri; font-size:14px">c7e3801729f544c0b108bb423918a75d00163317a70033b0ae07ce3</span></p> 
<p><span style="font-family:Calibri; font-size:14px">e00162b943108bb4236b54158a71680162ff5a7283b42371c33b2b7</span></p> 
<p><span style="font-family:Calibri; font-size:14px">1c29dd80173108b09fb087b317c1a933cb80162b943659b6a0bb422</span></p> 
<p><span style="font-family:Calibri; font-size:14px">7122e5c00306081229192611</span></p> 
<p><span style="font-family:Calibri; font-size:14px">sms context == 1/2</span>我愿意是急流<span style="font-family:Calibri">,</span>山里的小河<span style="font-family:Calibri">,</span>在崎岖的路上<span style="font-family:Calibri">,</span>岩石上经过<span style="font-family:Calibri">.</span>只要我的爱人<span style="font-family:Calibri">,</span>是一条小鱼<span style="font-family:Calibri">,</span>在我的浪花中<span style="font-family:Calibri">,</span>快乐的游来游去<span style="font-family:Calibri">.</span>我愿意是荒林<span style="font-family:Calibri">,</span>在河流的两岸</p> 
<p><span style="font-family:Calibri; font-size:14px">SM_ENCODING == 4</span></p> 
<p><span style="font-family:Calibri; font-size:14px">TPA == 15338896020</span></p> 
<p><span style="font-family:Calibri; font-size:14px">SCTS == 19:26:11 12/29/08</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-family:Calibri; font-size:14px">[deli@deli example]$ ./test_pdu_decode</span></p> 
<p><span style="font-family:Calibri; font-size:14px">0000021002020702c54ce225a8a806014c084d00031001f8013e20f</span></p> 
<p><span style="font-family:Calibri; font-size:14px">00190017801900162dfca7004b1acb1abb4239614c6700162963b2</span></p> 
<p><span style="font-family:Calibri; font-size:14px">b12b9827ae310c001729f544c0b108bb423918a75d00163317a700</span></p> 
<p><span style="font-family:Calibri; font-size:14px">29f52e07cf0f80306081229192616</span></p> 
<p><span style="font-family:Calibri; font-size:14px">sms context == 2/2,</span>对一阵阵的狂风<span style="font-family:Calibri">,</span>勇敢地作战<span style="font-family:Calibri">.</span>只要我的爱人<span style="font-family:Calibri">,</span>是一只小鸟</p> 
<p><span style="font-family:Calibri; font-size:14px">SM_ENCODING == 4</span></p> 
<p><span style="font-family:Calibri; font-size:14px">TPA == 15338896020</span></p> 
<p><span style="font-family:Calibri; font-size:14px">SCTS == 19:26:16 12/29/08</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-family:Calibri; font-size:14px">PDU</span>串解析</p> 
<p><span style="font-family:Calibri; font-size:14px">CDMA</span>的<span style="font-family:Calibri">pdu</span>格式与<span style="font-family:Calibri">GSM</span>的相差很多，不能直接用肉眼看出来。第一条内容比较长，就拿第二条<span style="font-family:Calibri">pdu</span>串来分析吧。</p> 
<p><span style="font-family:Calibri; font-size:14px">1.</span>首先将<span style="font-family:Calibri">PDU</span>串打成<span style="font-family:Calibri">PDU</span>包</p> 
<p><span style="font-size:14px">将<span style="font-family:Calibri">PDU</span>串相邻的两个<span style="font-family:Calibri">ascii</span>字符拼凑成一个<span style="font-family:Calibri">8bit</span>数据</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">如下<span style="font-family:Calibri">:</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px">00 00 02 10 02 02 07 02 c5 4c e2 25 a8 a806 01 4c 08 4d 00 03 10 01 f8 01 3e 20 f0 01 90 01 78 01 90 01 62 df ca 70 04b1 ac b1 ab b4 23 96 14 c6 70 01 62 96 3b 2b 12 b9 82 7a e3 10 c0 01 72 9f 544c 0b 10 8b b4 23 91 8a 75 d0 01 63 31 7a 70 02 9f 52 e0 7c f0 f8 03 06 08 1229 19 26 16</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">消息传送类型<span style="font-family:Calibri">: 0</span>×<span style="font-family:Calibri">00 point to point message(</span>表示点对点消息<span style="font-family:Calibri">)</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">下面的内容为短消息的各个字段每个字段分为三个部分：字段类型（<span style="font-family:Calibri">ID</span>）（<span style="font-family:Calibri">8bit</span>）、字段长度（<span style="font-family:Calibri">Length</span>）（<span style="font-family:Calibri">8bit</span>）和字段内容<span style="font-family:Calibri">.</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">第一个字段<span style="font-family:Calibri">: 00 02 10 02</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px">0</span>×<span style="font-family:Calibri">00,</span>表示<span style="font-family:Calibri">uTeleserviceID</span>字段</p> 
<p><span style="font-family:Calibri; font-size:14px">0</span>×<span style="font-family:Calibri">02,</span>字段长度，该长度必须为<span style="font-family:Calibri">2</span>，否则为错误的<span style="font-family:Calibri">pdu</span>信息</p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">字段内容为：<span style="font-family:Calibri">0</span>×<span style="font-family:Calibri">1002,</span>十进制是<span style="font-family:Calibri">4098,</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">第二个字段<span style="font-family:Calibri">: 02 07 02 c5 4c e2 25 a8 a8</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px">0</span>×<span style="font-family:Calibri">02, SMS_TL_ORIG_ADDR</span>表示<span style="font-family:Calibri"> (</span>短信发送地址<span style="font-family:Calibri">)</span></p> 
<p><span style="font-family:Calibri; font-size:14px">0</span>×<span style="font-family:Calibri">07,</span>字段长度为<span style="font-family:Calibri">7</span></p> 
<p><span style="font-size:14px">字段内容<span style="font-family:Calibri">: 02 c5 4c e2 25 a8 a8</span></span></p> 
<p><span style="font-size:14px">只看前面几个<span style="font-family:Calibri"> 02 c5 4c e2</span>的：</span></p> 
<p><span style="font-family:Calibri; font-size:14px">0000 0010 1100 0101 0100 1100 1110 00100010</span></p> 
<p><span style="font-size:14px">取第一个<span style="font-family:Calibri">bit 0 </span> 表示<span style="font-family:Calibri"> RIL_CDMA_SMS_DIGIT_MODE_4_BIT </span>是<span style="font-family:Calibri">4bit</span>压缩</span></p> 
<p><span style="font-size:14px">第二个<span style="font-family:Calibri">bit 0 </span> 表示<span style="font-family:Calibri"> RIL_CDMA_SMS_NUMBER_MODE_NOT_DATA_NETWORK</span></span></p> 
<p><span style="font-size:14px">下来<span style="font-family:Calibri">8</span>个<span style="font-family:Calibri">bit</span>是<span style="font-family:Calibri"> 00 0010 11 = 11</span>，表示号码长度为<span style="font-family:Calibri">11</span></span></p> 
<p><span style="font-size:14px">由于是<span style="font-family:Calibri">4bit</span>压缩，后面<span style="font-family:Calibri">44</span>个<span style="font-family:Calibri">bit</span>（<span style="font-family:Calibri">4*11</span>）表示号码，解析出来是<span style="font-family:Calibri">15338896020</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">第三个字段<span style="font-family:Calibri">: 06 01 4c</span></span></p> 
<p><span style="font-size:14px">表示<span style="font-family:Calibri">SMS_TL_BEARER_RPLY_OPT</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">第四个字段：<span style="font-family:Calibri">08 4d 00 03 10 01 f8 01 3e 20 f0 01 90 01 78 01 90 01 62 df ca 70 04b1 ac b1 ab b4 23 96 14 c6 70 01 62 96 3b 2b 12 b9 82 7a e3 10 c0 01 72 9f 544c 0b 10 8b b4 23 91 8a 75 d0 01 63 31 7a 70 02 9f 52 e0 7c f0 f8 03 06 08 1229 19 26 16</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-family:Calibri; font-size:14px">0</span>×<span style="font-family:Calibri">08,</span>表示<span style="font-family:Calibri">SMS_TL_BEARER_DATA</span>字段（短信内容）</p> 
<p><span style="font-family:Calibri; font-size:14px">0x4d</span>，字段长度为<span style="font-family:Calibri">77</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">这个字段也分成各个子字段<span style="font-family:Calibri">:</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">第一子字段<span style="font-family:Calibri">: 00 03 10 01 f8</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px">0×00 Mesage Id</span></p> 
<p><span style="font-family:Calibri; font-size:14px">0</span>×<span style="font-family:Calibri">03</span>内容长度</p> 
<p><span style="font-family:Calibri; font-size:14px">10 01 f8 === 0001 0000 0000 0001 1111 1000</span></p> 
<p><span style="font-family:Calibri; font-size:14px">0001 </span>表示<span style="font-family:Calibri"> DELIVER</span>短信</p> 
<p><span style="font-family:Calibri; font-size:14px">0000 0000 0001 1111</span>表示<span style="font-family:Calibri"> messageid.</span></p> 
<p><span style="font-size:14px">紧接后面的<span style="font-family:Calibri"> 1, </span> 表示<span style="font-family:Calibri">HEADER_IND</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">第二个子字段：<span style="font-family:Calibri">01 3e 20 f0 01 90 01 78 01 90 01 62 df ca 70 04 b1 ac b1 ab b4 23 9614 c6 70 01 62 96 3b 2b 12 b9 82 7a e3 10 c0 01 72 9f 54 4c 0b 10 8b b4 23 918a 75 d0 01 63 31 7a 70 02 9f 52 e0 7c f0 f8</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px">0</span>×<span style="font-family:Calibri">01,</span>字段类型</p> 
<p><span style="font-family:Calibri; font-size:14px">0x3e(62),</span>字段长度</p> 
<p><span style="font-family:Calibri; font-size:14px">20 f0 01 === 0010 0000 1111 0000 0000 0001</span></p> 
<p><span style="font-family:Calibri; font-size:14px">0</span>×<span style="font-family:Calibri">20</span>的前<span style="font-family:Calibri">5</span>个<span style="font-family:Calibri">bit</span>为<span style="font-family:Calibri">00100,</span>为<span style="font-family:Calibri">0</span>×<span style="font-family:Calibri">04,</span>表示短信编码方式为<span style="font-family:Calibri">RIL_CDMA_SMS_ENCODING_UNICODE(UNICODE)</span></p> 
<p><span style="font-family:Calibri; font-size:14px">0</span>×<span style="font-family:Calibri">20</span>的后<span style="font-family:Calibri">3</span>个<span style="font-family:Calibri">bit, 0xf0</span>的前<span style="font-family:Calibri">5</span>个<span style="font-family:Calibri">bit,</span>为<span style="font-family:Calibri"> 000 1111 0,</span>即<span style="font-family:Calibri">0x1e (30),</span>表示有<span style="font-family:Calibri">30</span>个<span style="font-family:Calibri">UNICODE</span>字符。<span style="font-family:Calibri">0xf0</span>的后<span style="font-family:Calibri">3</span>个<span style="font-family:Calibri">bit</span>，<span style="font-family:Calibri">0</span>×<span style="font-family:Calibri">01</span>的<span style="font-family:Calibri">8</span>个<span style="font-family:Calibri">bit</span>，再加上<span style="font-family:Calibri">0</span>×<span style="font-family:Calibri">90</span>的前<span style="font-family:Calibri">5</span>个<span style="font-family:Calibri">bit,</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-family:Calibri; font-size:14px">0000 0000 0011 0010 </span>拼成一个<span style="font-family:Calibri">16</span>位数是<span style="font-family:Calibri"> 0</span>×<span style="font-family:Calibri">0032</span>表示字符：<span style="font-family:Calibri">2</span>，在<span style="font-family:Calibri">vim</span>下了解一个字符的<span style="font-family:Calibri">16</span>进制码很简单，光标在该字符，按<span style="font-family:Calibri">ga</span>，底端显示结果如下：</p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-family:Calibri; font-size:14px">&lt;2&gt; 50,  Hex 32,  Octal 062                                  2,1           All</span></p> 
<p><span style="font-size:14px">依次下去，内容就是上面运行<span style="font-family:Calibri">./test_pdu_decode</span>的结果<span style="font-family:Calibri">: 2/2,</span>对一阵阵的狂风<span style="font-family:Calibri">,</span>勇敢地作战<span style="font-family:Calibri">.</span>只要我的爱人<span style="font-family:Calibri">,</span>是一只小鸟</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">第三个子字段：<span style="font-family:Calibri"> 03 06 08 12 29 19 26 16</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">这是一个时间戳字段<span style="font-family:Calibri">: 08</span>年<span style="font-family:Calibri">12</span>月<span style="font-family:Calibri">29</span>号<span style="font-family:Calibri">19</span>时<span style="font-family:Calibri">26</span>分<span style="font-family:Calibri">16</span>秒（短消息发送时间）</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">字符串分析结束。当然，还有很多可选项在这条短信没有加上，更完整的<span style="font-family:Calibri">SMS</span>格式，请参考<span style="font-family:Calibri">CDMA SMS standard on 3GPP2 website.</span></span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">实际编码时，一个<span style="font-family:Calibri">while</span>循环遍历，再加上<span style="font-family:Calibri">switch</span>简单的状态机即可。</span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-family:Calibri; font-size:14px"> </span></p> 
<p><span style="font-size:14px">长短信何在？</span></p> 
<p><span style="font-size:14px">用的这个模组，不支持长短信，厂家回答“作了预处理，把<span style="font-family:Calibri">User Data Header</span>去掉了，因为客户一般不愿意自行处理这个<span style="font-family:Calibri">User Data Header</span>，他们只要内容、号码等其它信息。所以，模块送出的<span style="font-family:Calibri">PDU</span>中不含有<span style="font-family:Calibri">User Data Header</span>。”</span></p> 
<p><span style="font-family:Calibri; font-size:14px"></span> </p> 
<p><span style="font-size:14px">为实现长短信的拆分和组合功能<span style="font-family:Calibri">,</span>终端应支持<span style="font-family:Calibri"> IS637C</span>协议中关于长短消息处理的参数<span style="font-family:Calibri"> HEADER_IND,</span>以及在短消息数据中增加对<span style="font-family:Calibri"> User Data Subparameter</span>参数增加用户数据消息头<span style="font-family:Calibri">(User DataHeader)</span>和短信拆分、组合的处理。<span style="font-family:Calibri">HEADER_IND</span>为消息头标识位<span style="font-family:Calibri">,</span>用于指示<span style="font-family:Calibri"> User Data Header</span>是否包含消息头<span style="font-family:Calibri">,</span>若包含消息头则<span style="font-family:Calibri"> HEADER_IND</span>设置为’<span style="font-family:Calibri">1</span>’<span style="font-family:Calibri">,</span>否则设置为’<span style="font-family:Calibri">0</span>’。具体的拆分与组合，请参考<span style="font-family:Calibri">IS637C</span>，或《中国电信<span style="font-family:Calibri">CDMA</span>终端需求规范<span style="font-family:Calibri">-SMS</span>分册<span style="font-family:Calibri">-V1.0</span>》。需要说明的是，对长短信的处理，有的<span style="font-family:Calibri">CDMA</span>模组厂家为了让用户省事，帮你处理了用户数据头，正如前面所看到的，自动加上<span style="font-family:Calibri">(1/2), (2/2)</span>等，若想自己手动解析，务必跟模组厂家沟通确认好。</span></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2203ec8d4f9385f2328a7d57de80dea9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[总结]FFMPEG视音频编解码零基础学习方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e81912b187fb5bb145dc7cc904d44f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AH协议与ESP协议简析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>