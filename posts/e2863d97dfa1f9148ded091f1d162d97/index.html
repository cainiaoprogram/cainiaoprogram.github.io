<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>八皇后问题汇总（C&#43;&#43;版） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="八皇后问题汇总（C&#43;&#43;版）" />
<meta property="og:description" content="八皇后问题汇总（C&#43;&#43;版） 八皇后问题八皇后问题（来源：openjudge）八皇后（来源：openjudge）[P1219 [USACO1.5]八皇后 Checker Challenge（来源：洛古）](https://www.luogu.com.cn/problem/P1219) 八皇后问题 八皇后问题（英文：Eight queens），是由国际象棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。
问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。如果经过±90度、±180度旋转，和对角线对称变换的摆法看成一类，共有42类。
放置第i个（行）皇后的算法为：
int search(int i){ int j; for(j=1;j&lt;=8;j&#43;&#43;){ if(本行本列允许放置皇后) 放置第i个皇后； 对放置皇后的位置进行标记； if(i==8)输出//已经放完8个皇后 else search(i&#43;1);//放置第i&#43;1个皇后 释放标记，尝试下一个位置是否可行； } } 【算法分析】
显然问题的关键在于如何判定某个皇后所在的行、列、斜线上是否有别的皇后。
可以从矩阵的特点上找到规律，如果在同一行，则行号相同；如果在同一列，则列号相同；
如果在/斜线上，则行列值之和相同，如果在\斜线上，则行列值之差相同。
考虑到每行有且只有一个皇后，设一维数组a[1…8]表示皇后的放置：第i行皇后放在第j列，用a[i]=j来表示，即下标是行数，内容是列数。例如：a[3]=5就表示第3个皇后在第3行第5列上。
判断皇后是否安全，即检查同一列、同一对角线是否已有皇后，建立标志数组b[1…8]控制同一列只能有一个皇后，若两皇后在同一对角线上，则其行列坐标之和或行列坐标之差相等，故亦可建立标志数组c[1…16],d[-7…7]控制同一对角线上只能有一个皇后。
【参考程序】
#include&lt;bits/stdc&#43;&#43;.h&gt; using namespace std; bool d[17]={0},b[9]={0},c[17]={0}; int sum=0,a[9]; int search(int); int print(); int main(){ search(1); cout&lt;&lt;sum&lt;&lt;endl; return 0; } int search(int i){ int j; for(j=1;j&lt;=8;j&#43;&#43;){ if((!b[j])&amp;&amp;(!c[i&#43;j])&amp;&amp;(!d[i-j&#43;7])){//!b[j]---&gt;表示不能在同一列 //!c[i&#43;j]---&gt;表示不能在正对角线上 //!d[i-j&#43;7]---&gt;表示不能在反对角线上 a[i]=j; b[j]=1; c[i&#43;j]=1; d[i-j&#43;7]=1; if(i==8)print(); else search(i&#43;1); b[j]=0; c[i&#43;j]=0; d[i-j&#43;7]=0; } } } int print() {	int i; sum&#43;&#43;; for(int i=1;i&lt;=8;i&#43;&#43;) cout&lt;&lt;a[i]&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e2863d97dfa1f9148ded091f1d162d97/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-14T17:04:44+08:00" />
<meta property="article:modified_time" content="2023-02-14T17:04:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">八皇后问题汇总（C&#43;&#43;版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>八皇后问题汇总（C++版）</h4> 
 <ul><li><a href="#_1" rel="nofollow">八皇后问题</a></li><li><ul><li><ul><li><a href="#openjudgehttpnoiopenjudgecnch02051700_74" rel="nofollow">八皇后问题（来源：openjudge）</a></li><li><a href="#openjudgehttpnoiopenjudgecnch02051756_240" rel="nofollow">八皇后（来源：openjudge）</a></li><li><a href="#P1219_USACO15_Checker_ChallengehttpswwwluogucomcnproblemP1219_323" rel="nofollow">[P1219 [USACO1.5]八皇后 Checker Challenge（来源：洛古）](https://www.luogu.com.cn/problem/P1219)</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>八皇后问题</h2> 
<p><img src="https://images2.imgbox.com/d4/1f/0DxPwPKK_o.png" alt="在这里插入图片描述" width="200"><br> 八皇后问题（英文：Eight queens），是由国际象棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。</p> 
<p>问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。如果经过±90度、±180度旋转，和对角线对称变换的摆法看成一类，共有42类。</p> 
<p>放置第i个（行）皇后的算法为：</p> 
<pre><code class="prism language-C++">int search(int i){
	int j;
    for(j=1;j&lt;=8;j++){
        if(本行本列允许放置皇后)
            放置第i个皇后；
            对放置皇后的位置进行标记；
            if(i==8)输出//已经放完8个皇后
            else search(i+1);//放置第i+1个皇后
        	释放标记，尝试下一个位置是否可行；
    }
}
</code></pre> 
<p>【算法分析】</p> 
<p>显然问题的关键在于如何判定某个皇后所在的行、列、斜线上是否有别的皇后。</p> 
<p>可以从矩阵的特点上找到规律，如果在同一行，则行号相同；如果在同一列，则列号相同；</p> 
<p>如果在/斜线上，则行列值之和相同，如果在\斜线上，则行列值之差相同。</p> 
<p>考虑到每行有且只有一个皇后，设一维数组a[1…8]表示皇后的放置：第i行皇后放在第j列，用a[i]=j来表示，即下标是行数，内容是列数。例如：a[3]=5就表示第3个皇后在第3行第5列上。</p> 
<p>判断皇后是否安全，即检查同一列、同一对角线是否已有皇后，建立标志数组b[1…8]控制同一列只能有一个皇后，若两皇后在同一对角线上，则其行列坐标之和或行列坐标之差相等，故亦可建立标志数组c[1…16],d[-7…7]控制同一对角线上只能有一个皇后。<br> 【参考程序】</p> 
<pre><code class="prism language-C++">#include&lt;bits/stdc++.h&gt;
using namespace std;
bool d[17]={0},b[9]={0},c[17]={0};
int sum=0,a[9];
int search(int);
int print();
int main(){
	search(1);
	cout&lt;&lt;sum&lt;&lt;endl;
	return 0;
}
int search(int i){
	
	int j;
	for(j=1;j&lt;=8;j++){
		if((!b[j])&amp;&amp;(!c[i+j])&amp;&amp;(!d[i-j+7])){//!b[j]---&gt;表示不能在同一列
		//!c[i+j]---&gt;表示不能在正对角线上
		//!d[i-j+7]---&gt;表示不能在反对角线上
			a[i]=j;
			b[j]=1;
			c[i+j]=1;
			d[i-j+7]=1;
			if(i==8)print();
			else search(i+1);
			b[j]=0;
			c[i+j]=0;
			d[i-j+7]=0;
		}
	}
}
int print()
{	
	int i;
	sum++;
	for(int i=1;i&lt;=8;i++)
		cout&lt;&lt;a[i]&lt;&lt;" ";
	cout&lt;&lt;endl;	
}
</code></pre> 
<h4><a id="openjudgehttpnoiopenjudgecnch02051700_74"></a><a href="http://noi.openjudge.cn/ch0205/1700/" rel="nofollow">八皇后问题（来源：openjudge）</a></h4> 
<p>1700:八皇后问题</p> 
<p>总时间限制: 10000ms 内存限制: 65536kB</p> 
<p>描述</p> 
<p>在国际象棋棋盘上放置八个皇后，要求每两个皇后之间不能直接吃掉对方。</p> 
<p>输入</p> 
<p>无输入。</p> 
<p>输出</p> 
<p>按给定顺序和格式输出所有八皇后问题的解（见Sample Output）。</p> 
<p>【算法分析】</p> 
<p>本题依旧可以使用上面的代码去完成，但是会出现超时问题。此时需要注意：（1）把不需要返回值的函数重新定义为void；（2）使用printf编写输出。</p> 
<p>这样时间上会加快不少。</p> 
<p>scanf和printf比cin和cout要快很多，有时候会因为这个超时，所以虽然不知道为什么，但以后还是尽量用scanf和printf吧（还是要根据情况，如果数据比较大比较多就用省时的）（各有各的优势）</p> 
<p>【参考程序】</p> 
<p>深搜从0开始</p> 
<p>参考地址</p> 
<pre><code class="prism language-C++">    #include&lt;iostream&gt;
    using namespace std;
    int cnt = 1;//方案计数器
    int chess[8][8];//棋盘情况
    bool judge(int row, int col);//判断某个位置是否可放
    void print();//输出函数
    void dfs(int row) {
    	if (row &gt;= 8) {//深搜结束条件
    		print();
    		cnt++;
    		return;
    	}
    	for (int j = 0; j &lt;= 7; j++) {
    		if (judge(row, j)) {
    			chess[row][j] = 1;
    			dfs(row + 1);//深搜
    			chess[row][j] = 0;//回溯，表示换个位置试试，之前的位置就当作没走咯
    		}
    	}
    }
    int main() {
    	dfs(0);
    	return 0;
    }
    bool judge(int row, int col) {
    	for (int i = 0; i &lt;= 7; i++)//判断列
    		if (chess[i][col] == 1) return false;
    	for (int i = row, j = col; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {//判断左上对角线
    		if (chess[i][j] == 1) return false;
    	}
    	for (int i = row, j = col; i &gt;= 0 &amp;&amp; j &lt;= 7; i--, j++) {//判断右上对角线
    		if (chess[i][j] == 1) return false;
    	}
    	return true;
    }
    void print() {
    	cout &lt;&lt; "No. " &lt;&lt; cnt &lt;&lt; endl;
    	for (int j = 0; j &lt;= 7; j++) {//!!!按列输出!!!
    		for (int i = 0; i &lt;= 7; i++) {
    			if (chess[i][j] == 1) cout &lt;&lt; "1" &lt;&lt; " ";
    			else cout &lt;&lt; "0" &lt;&lt; " ";
    		}
    		cout &lt;&lt; endl;
    	}
    }
</code></pre> 
<p>深搜从1开始</p> 
<pre><code class="prism language-C++">    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    bool a[9][9],b[9],c[17],d[17];
    int tot=0;
    void search(int);
    
    int main(){
    	search(1);
    	return 0;
    }
    void search(int i){//i代表皇后所在的行
    	int j;//代表皇后所在的列
    	for(j=1;j&lt;=8;j++){//放置8个皇后
    		if((!b[j])&amp;&amp;(!c[i+j])&amp;&amp;(!d[j-i+7])){//!b[j]---&gt;表示不能在同一列
    		//!c[i+j]---&gt;表示不能在正对角线上
    		//!d[i-j+7]---&gt;表示不能在反对角线上
    			a[i][j]=1;
    			b[j]=1;
    			c[i+j]=1;
    			d[j-i+7]=1;
    			if(i==8){
    				tot++;
    				cout&lt;&lt;"No. "&lt;&lt;tot&lt;&lt;endl;
    				for(int x=1;x&lt;=8;x++){//按列输出皇后
    					for(int y=1;y&lt;=8;y++)
    							cout&lt;&lt;a[y][x]&lt;&lt;" ";	
    					cout&lt;&lt;endl;
    				}
    			}
    			else search(i+1);
    			b[j]=0;//回溯
    			c[i+j]=0;
    			d[j-i+7]=0;
    			a[i][j]=0;
    		}
    	}
    	
    }
</code></pre> 
<p>第三种解法（与上面第一个案例相似）</p> 
<pre><code class="prism language-C++">	#include&lt;bits/stdc++.h&gt;
    using namespace std;
    int a[9],b[9],c[17],d[17],tot=0;
    void search(int);
    int print();
    int main(){
    	search(1);
    	return 0;
    }
    void search(int i){
    	int j;
    	for(j=1;j&lt;=8;j++){
    		if((!b[j])&amp;&amp;(!c[i+j])&amp;&amp;(!d[j-i+7])){//!b[j]---&gt;表示不能在同一列
    		//!c[i+j]---&gt;表示不能在正对角线上
    		//!d[i-j+7]---&gt;表示不能在反对角线上
    			a[i]=j;
    			b[j]=1;
    			c[i+j]=1;
    			d[j-i+7]=1;
    			if(i==8){
    				tot++;
    				printf("No. %d\n",tot);
    				for(int x=1;x&lt;=8;x++){//按列输出皇后
    					for(int y=1;y&lt;=8;y++)
    							if(a[y]==x){
    							printf("1 ");
    							}	
    							else printf("0 ");
    					printf("\n");}
    			}
    			else search(i+1);
    			b[j]=0;
    			c[i+j]=0;
    			d[j-i+7]=0;
    		}
    	}
    }
    
</code></pre> 
<h4><a id="openjudgehttpnoiopenjudgecnch02051756_240"></a><a href="http://noi.openjudge.cn/ch0205/1756/" rel="nofollow">八皇后（来源：openjudge）</a></h4> 
<p>1756:八皇后</p> 
<p>总时间限制: 1000ms 内存限制: 65536kB</p> 
<p>描述</p> 
<p>会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2…b8，其中bi为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。</p> 
<p>输入</p> 
<p>第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数b(1 &lt;= b &lt;= 92)</p> 
<p>输出</p> 
<p>输出有n行，每行输出对应一个输入。输出应是一个正整数，是对应于b的皇后串。</p> 
<p>样例输入</p> 
<pre><code>2192
</code></pre> 
<p>样例输出</p> 
<pre><code>1586372484136275
</code></pre> 
<p>【算法分析】</p> 
<p>提示：可以使用最上面案例的解法完成。</p> 
<p>首先，如果每一次都去进行深搜的话一定会出现超时问题，所以最好的办法是先进行一次深搜，然后在深搜的过程中存储每一种方案，这样在进行输出是只需要从保存的方案中拿出来就可以了，时间复杂度为O(1)。</p> 
<p>如果在保存过程中直接保存为八位数字，可以在输出时直接按位取数，这样就不再需要去进行八次循环输出了。</p> 
<p>【参考程序】</p> 
<pre><code class="prism language-C++">    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    bool d[17]={0},b[9]={0},c[17]={0};
    int sum=0,a[9],queen[95][9];
    void search(int);
    void print();
    int n,x;
    int main(){
    	cin&gt;&gt;n;
    	search(1);
    	for(int i=1;i&lt;=n;i++){
    		cin&gt;&gt;x;
    		for(int j=1;j&lt;=8;j++)
    			cout&lt;&lt;queen[x][j];
    		cout&lt;&lt;endl;
    	}
    	return 0;
    }
    void search(int i){//i代表皇后所在的行
    	int j;
    	for(j=1;j&lt;=8;j++){
    		if((!b[j])&amp;&amp;(!c[i+j])&amp;&amp;(!d[i-j+7])){//!b[j]---&gt;表示不能在同一列
    		//!c[i+j]---&gt;表示不能在正对角线上
    		//!d[i-j+7]---&gt;表示不能在反对角线上
    			a[i]=j;
    			b[j]=1;
    			c[i+j]=1;
    			d[i-j+7]=1;
    			if(i==8)print();
    			else search(i+1);
    			b[j]=0;
    			c[i+j]=0;
    			d[i-j+7]=0;
    		}
    	}
    	
    }
    
    	
    void print()
    {	
    	int i;
    	sum++;
    	for(int i=1;i&lt;=8;i++)
    		queen[sum][i]=a[i];
    }	
</code></pre> 
<h4><a id="P1219_USACO15_Checker_ChallengehttpswwwluogucomcnproblemP1219_323"></a><a href="https://www.luogu.com.cn/problem/P1219" rel="nofollow">P1219 [USACO1.5]八皇后 Checker Challenge（来源：洛古）</a></h4> 
<p><strong>题目描述</strong></p> 
<p>一个如下的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         6 
        
       
         × 
        
       
         6 
        
       
      
        6 \times 6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">6</span></span></span></span></span> 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。</p> 
<p><img src="https://images2.imgbox.com/7a/f7/KRjhrqap_o.png" alt=""></p> 
<p>上面的布局可以用序列 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
           
        
       
         4 
        
       
           
        
       
         6 
        
       
           
        
       
         1 
        
       
           
        
       
         3 
        
       
           
        
       
         5 
        
       
      
        2\ 4\ 6\ 1\ 3\ 5 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">6</span><span class="mspace"> </span><span class="mord">1</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">5</span></span></span></span></span> 来描述，第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> 个数字表示在第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> 行的相应位置有一个棋子，如下：</p> 
<p>行号 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
           
        
       
         2 
        
       
           
        
       
         3 
        
       
           
        
       
         4 
        
       
           
        
       
         5 
        
       
           
        
       
         6 
        
       
      
        1\ 2\ 3\ 4\ 5\ 6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord">2</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">5</span><span class="mspace"> </span><span class="mord">6</span></span></span></span></span></p> 
<p>列号 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
           
        
       
         4 
        
       
           
        
       
         6 
        
       
           
        
       
         1 
        
       
           
        
       
         3 
        
       
           
        
       
         5 
        
       
      
        2\ 4\ 6\ 1\ 3\ 5 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">6</span><span class="mspace"> </span><span class="mord">1</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">5</span></span></span></span></span></p> 
<p>这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。<br> 并把它们以上面的序列方法输出，解按字典顺序排列。<br> 请输出前 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         3 
        
       
      
        3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span> 个解。最后一行是解的总个数。</p> 
<p><strong>输入格式</strong></p> 
<p>一行一个正整数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>，表示棋盘是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         × 
        
       
         n 
        
       
      
        n \times n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 大小的。</p> 
<p><strong>输出格式</strong></p> 
<p>前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。</p> 
<p><strong>样例 #1</strong></p> 
<p><strong>样例输入 #1</strong></p> 
<pre><code>6
</code></pre> 
<p><strong>样例输出 #1</strong></p> 
<pre><code>2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
</code></pre> 
<p><strong>提示</strong></p> 
<p>【数据范围】<br> 对于 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         100 
        
       
         % 
        
       
      
        100\% 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8056em; vertical-align: -0.0556em;"></span><span class="mord">100%</span></span></span></span></span> 的数据，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         6 
        
       
         ≤ 
        
       
         n 
        
       
         ≤ 
        
       
         13 
        
       
      
        6 \le n \le 13 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7804em; vertical-align: -0.136em;"></span><span class="mord">6</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7719em; vertical-align: -0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">13</span></span></span></span></span>。</p> 
<p>题目翻译来自NOCOW。</p> 
<p>USACO Training Section 1.5</p> 
<p>【算法分析】</p> 
<p>与之前的八皇后问题相似，把棋盘从<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         8 
        
       
         x 
        
       
         8 
        
       
      
        8x8 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">8</span><span class="mord mathnormal">x</span><span class="mord">8</span></span></span></span></span>大小换成<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         x 
        
       
         n 
        
       
      
        nxn 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">x</span><span class="mord mathnormal">n</span></span></span></span></span>大小，算法相同，需要注意的是<strong>必须修改数组空间大小，适应题目要求的数据范围</strong></p> 
<p>【参考程序】</p> 
<pre><code class="prism language-C++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[15],b[15],c[30],d[30],tot=0;
void search(int);int n;
int print();
int main(){
	
	cin&gt;&gt;n;
	search(1);
	cout&lt;&lt;tot;
	return 0;
}
void search(int i){
	int j;
	for(j=1;j&lt;=n;j++){
		if((!b[j])&amp;&amp;(!c[i+j])&amp;&amp;(!d[j-i+7])){//!b[j]---&gt;表示不能在同一列
		//!c[i+j]---&gt;表示不能在正对角线上
		//!d[i-j+7]---&gt;表示不能在反对角线上
			a[i]=j;
			b[j]=1;
			c[i+j]=1;
			d[j-i+7]=1;
			if(i==n){
				tot++;
				if(tot&lt;=3){
					for(int x=1;x&lt;=n;x++){//按列输出皇后
						printf("%d ",a[x]);
                    	}printf("\n");
				}
				}
			else search(i+1);
			b[j]=0;
			c[i+j]=0;
			d[j-i+7]=0;
		}
	}
}

</code></pre> 
<p><s>未待完续</s></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0307cb7b48d8323b7045922eea21e47f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;算法——搜索与回溯算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d69683b5ec36fa12bcfb56fb3809ab87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数字图像处理（4）- 图像增强</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>