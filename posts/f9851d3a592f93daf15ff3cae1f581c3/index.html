<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入剖析Redis客户端Jedis的特性和原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入剖析Redis客户端Jedis的特性和原理" />
<meta property="og:description" content="一、开篇
Redis作为目前通用的缓存选型，因其高性能而倍受欢迎。Redis的2.x版本仅支持单机模式，从3.0版本开始引入集群模式。
Redis的Java生态的客户端当中包含Jedis、Redisson、Lettuce，不同的客户端具备不同的能力是使用方式，本文主要分析Jedis客户端。
Jedis客户端同时支持单机模式、分片模式、集群模式的访问模式，通过构建Jedis类对象实现单机模式下的数据访问，通过构建ShardedJedis类对象实现分片模式的数据访问，通过构建JedisCluster类对象实现集群模式下的数据访问。
Jedis客户端支持单命令和Pipeline方式访问Redis集群，通过Pipeline的方式能够提高集群访问的效率。
本文的整体分析基于Jedis的3.5.0版本进行分析，相关源码均参考此版本。
二、Jedis访问模式对比
Jedis客户端操作Redis主要分为三种模式，分表是单机模式、分片模式、集群模式。
单机模式主要是创建Jedis对象来操作单节点的Redis，只适用于访问单个Redis节点。
分片模式（ShardedJedis）主要是通过创建ShardedJedisPool对象来访问分片模式的多个Redis节点，是Redis没有集群功能之前客户端实现的一个数据分布式方案，本质上是客户端通过一致性哈希来实现数据分布式存储。
集群模式（JedisCluster）主要是通过创建JedisCluster对象来访问集群模式下的多个Redis节点，是Redis3.0引入集群模式后客户端实现的集群访问访问，本质上是通过引入槽（slot）概念以及通过CRC16哈希槽算法来实现数据分布式存储。
单机模式不涉及任何分片的思想，所以我们着重分析分片模式和集群模式的理念。
2.1 分片模式
分片模式本质属于基于客户端的分片，在客户端实现如何根据一个key找到Redis集群中对应的节点的方案。
Jedis的客户端分片模式采用一致性Hash来实现，一致性Hash算法的好处是当Redis节点进行增减时只会影响新增或删除节点前后的小部分数据，相对于取模等算法来说对数据的影响范围较小。
Redis在大部分场景下作为缓存进行使用，所以不用考虑数据丢失致使缓存穿透造成的影响，在Redis节点增减时可以不用考虑部分数据无法命中的问题。
分片模式的整体应用如下图所示，核心在于客户端的一致性Hash策略。
2.2 集群模式 集群模式本质属于服务器分片技术，由Redis集群本身提供分片功能，从Redis 3.0版本开始正式提供。
集群的原理是：一个 Redis 集群包含16384 个哈希槽（Hash slot）， Redis保存的每个键都属于这16384个哈希槽的其中一个， 集群使用公式CRC16(key)%16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键key的CRC16校验和 。
集群中的每个节点负责处理一部分哈希槽。举个例子， 一个集群可以有三个哈希槽， 其中：
节点 A 负责处理 0 号至 5500 号哈希槽。
节点 B 负责处理 5501 号至 11000 号哈希槽。
节点 C 负责处理 11001 号至 16383 号哈希槽。
Redis在集群模式下对于key的读写过程首先将对应的key值进行CRC16计算得到对应的哈希值，将哈希值对槽位总数取模映射到对应的槽位，最终映射到对应的节点进行读写。以命令set(&#34;key&#34;, &#34;value&#34;)为例子，它会使用CRC16算法对key进行计算得到哈希值28989，然后对16384进行取模得到12605，最后找到12605对应的Redis节点，最终跳转到该节点执行set命令。
集群模式的整体应用如下图所示，核心在于集群哈希槽的设计以及重定向命令。
三、Jedis的基础用法 // Jedis单机模式的访问
public void main(String[] args) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f9851d3a592f93daf15ff3cae1f581c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-14T17:23:39+08:00" />
<meta property="article:modified_time" content="2022-10-14T17:23:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入剖析Redis客户端Jedis的特性和原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、开篇</p> 
<p>Redis作为目前通用的缓存选型，因其高性能而倍受欢迎。Redis的2.x版本仅支持单机模式，从3.0版本开始引入集群模式。</p> 
<p>Redis的Java生态的客户端当中包含Jedis、Redisson、Lettuce，不同的客户端具备不同的能力是使用方式，本文主要分析Jedis客户端。</p> 
<p>Jedis客户端同时支持单机模式、分片模式、集群模式的访问模式，通过构建Jedis类对象实现单机模式下的数据访问，通过构建ShardedJedis类对象实现分片模式的数据访问，通过构建JedisCluster类对象实现集群模式下的数据访问。</p> 
<p>Jedis客户端支持单命令和Pipeline方式访问Redis集群，通过Pipeline的方式能够提高集群访问的效率。</p> 
<p>本文的整体分析基于Jedis的3.5.0版本进行分析，相关源码均参考此版本。</p> 
<p>二、Jedis访问模式对比</p> 
<p>Jedis客户端操作Redis主要分为三种模式，分表是单机模式、分片模式、集群模式。</p> 
<p>单机模式主要是创建Jedis对象来操作单节点的Redis，只适用于访问单个Redis节点。<br> 分片模式（ShardedJedis）主要是通过创建ShardedJedisPool对象来访问分片模式的多个Redis节点，是Redis没有集群功能之前客户端实现的一个数据分布式方案，本质上是客户端通过一致性哈希来实现数据分布式存储。<br> 集群模式（JedisCluster）主要是通过创建JedisCluster对象来访问集群模式下的多个Redis节点，是Redis3.0引入集群模式后客户端实现的集群访问访问，本质上是通过引入槽（slot）概念以及通过CRC16哈希槽算法来实现数据分布式存储。<br> 单机模式不涉及任何分片的思想，所以我们着重分析分片模式和集群模式的理念。</p> 
<p>2.1 分片模式</p> 
<p>分片模式本质属于基于客户端的分片，在客户端实现如何根据一个key找到Redis集群中对应的节点的方案。<br> Jedis的客户端分片模式采用一致性Hash来实现，一致性Hash算法的好处是当Redis节点进行增减时只会影响新增或删除节点前后的小部分数据，相对于取模等算法来说对数据的影响范围较小。<br> Redis在大部分场景下作为缓存进行使用，所以不用考虑数据丢失致使缓存穿透造成的影响，在Redis节点增减时可以不用考虑部分数据无法命中的问题。<br> 分片模式的整体应用如下图所示，核心在于客户端的一致性Hash策略。</p> 
<p><img src="https://images2.imgbox.com/3f/5c/tQwAyrhK_o.png" alt="3bae1d5f1f8047d38fa98c6e1a6f0265.png"></p> 
<p><br> 2.2 集群模式 </p> 
<p>集群模式本质属于服务器分片技术，由Redis集群本身提供分片功能，从Redis 3.0版本开始正式提供。</p> 
<p>集群的原理是：一个 Redis 集群包含16384 个哈希槽（Hash slot）， Redis保存的每个键都属于这16384个哈希槽的其中一个， 集群使用公式CRC16(key)%16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键key的CRC16校验和 。</p> 
<p>集群中的每个节点负责处理一部分哈希槽。举个例子， 一个集群可以有三个哈希槽， 其中：</p> 
<p>节点 A 负责处理 0 号至 5500 号哈希槽。<br> 节点 B 负责处理 5501 号至 11000 号哈希槽。<br> 节点 C 负责处理 11001 号至 16383 号哈希槽。<br> Redis在集群模式下对于key的读写过程首先将对应的key值进行CRC16计算得到对应的哈希值，将哈希值对槽位总数取模映射到对应的槽位，最终映射到对应的节点进行读写。以命令set("key", "value")为例子，它会使用CRC16算法对key进行计算得到哈希值28989，然后对16384进行取模得到12605，最后找到12605对应的Redis节点，最终跳转到该节点执行set命令。</p> 
<p>集群模式的整体应用如下图所示，核心在于集群哈希槽的设计以及重定向命令。</p> 
<p><img src="https://images2.imgbox.com/f6/9a/YAFrnjBL_o.png" alt="6fb939e31dd446f0bc4acefbed841722.png"></p> 
<p><br> 三、Jedis的基础用法 </p> 
<p>// Jedis单机模式的访问<br> public void main(String[] args) {<!-- --><br>     // 创建Jedis对象<br>     jedis = new Jedis("localhost", 6379);<br>     // 执行hmget操作<br>     jedis.hmget("foobar", "foo");<br>     // 关闭Jedis对象<br>     jedis.close();<br> }<br>  <br> // Jedis分片模式的访问<br> public void main(String[] args) {<!-- --><br>     HostAndPort redis1 = HostAndPortUtil.getRedisServers().get(0);<br>     HostAndPort redis2 = HostAndPortUtil.getRedisServers().get(1);<br>     List&lt;JedisShardInfo&gt; shards = new ArrayList&lt;JedisShardInfo&gt;(2);<br>     JedisShardInfo shard1 = new JedisShardInfo(redis1);<br>     JedisShardInfo shard2 = new JedisShardInfo(redis2);<br>     // 创建ShardedJedis对象<br>     ShardedJedis shardedJedis = new ShardedJedis(shards);<br>     // 通过ShardedJedis对象执行set操作<br>     shardedJedis.set("a", "bar");<br> }<br>  <br> // Jedis集群模式的访问<br> public void main(String[] args) {<!-- --><br>     // 构建redis的集群池<br>     Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();<br>     nodes.add(new HostAndPort("127.0.0.1", 7001));<br>     nodes.add(new HostAndPort("127.0.0.1", 7002));<br>     nodes.add(new HostAndPort("127.0.0.1", 7003));<br>  <br>     // 创建JedisCluster<br>     JedisCluster cluster = new JedisCluster(nodes);<br>  <br>     // 执行JedisCluster对象中的方法<br>     cluster.set("cluster-test", "my jedis cluster test");<br>     String result = cluster.get("cluster-test");<br> }<br> Jedis通过创建Jedis的类对象来实现单机模式下的数据访问，通过构建JedisCluster类对象来实现集群模式下的数据访问。</p> 
<p>要理解Jedis的访问Redis的整个过程，可以通过先理解单机模式下的访问流程，在这个基础上再分析集群模式的访问流程会比较合适。</p> 
<p>四、Jedis单机模式的访问</p> 
<p>Jedis访问单机模式Redis的整体流程图如下所示，从图中可以看出核心的流程包含Jedis对象的创建以及通过Jedis对象实现Redis的访问。</p> 
<p>熟悉Jedis访问单机Redis的过程，本身就是需要了解Jedis的创建过程以及执行Redis命令的过程。</p> 
<p>Jedis的创建过程核心在于创建Jedis对象以及Jedis内部变量Client对象。<br> Jedis访问Redis的过程在于通过Jedis内部的Client对象访问Redis。<br><img src="https://images2.imgbox.com/41/8c/lDgUrqSD_o.png" alt="1cd6642f82724714a2e7a90a03b22616.png"> </p> 
<p>4.1 创建过程</p> 
<p>Jedis本身的类关系图如下图所示，从图中我们能够看到Jedis继承自BinaryJedis类。</p> 
<p>在BinaryJedis类中存在和Redis对接的Client类对象，Jedis通过父类的BinaryJedis的Client对象实现Redis的读写。</p> 
<p><img src="https://images2.imgbox.com/93/1f/UNk8rzrw_o.png" alt="7793f08c11e3490598c2a0ee3834cc74.png"><br> Jedis类在创建过程中通过父类BinaryJedis创建了Client对象，而了解Client对象是进一步理解访问过程的关键。 </p> 
<p>public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands,<br>     AdvancedJedisCommands, ScriptingCommands, BasicCommands, ClusterCommands, SentinelCommands, ModuleCommands {<!-- --><br>  <br>   protected JedisPoolAbstract dataSource = null;<br>  <br>   public Jedis(final String host, final int port) {<!-- --><br>     // 创建父类BinaryJedis对象<br>     super(host, port);<br>   }<br> }<br>  <br> public class BinaryJedis implements BasicCommands, BinaryJedisCommands, MultiKeyBinaryCommands,<br>     AdvancedBinaryJedisCommands, BinaryScriptingCommands, Closeable {<!-- --><br>  <br>   // 访问redis的Client对象<br>   protected Client client = null;<br>  <br>   public BinaryJedis(final String host, final int port) {<!-- --><br>     // 创建Client对象访问redis<br>     client = new Client(host, port);<br>   }<br> }<br> Client类的类关系图如下图所示，Client对象继承自BinaryClient和Connection类。在BinaryClient类中存在Redis访问密码等相关参数，在Connection类在存在访问Redis的socket对象以及对应的输入输出流。本质上Connection是和Redis进行通信的核心类。</p> 
<p><img src="https://images2.imgbox.com/30/ed/eNm9XZpy_o.png" alt="87de106ecf6e44389c9e04b88684466e.png"><br> Client类在创建过程中初始化核心父类Connection对象，而Connection是负责和Redis直接进行通信。 </p> 
<p>public class Client extends BinaryClient implements Commands {<!-- --><br>   public Client(final String host, final int port) {<!-- --><br>     super(host, port);<br>   }<br> }<br>  <br> public class BinaryClient extends Connection {<!-- --><br>   // 存储和Redis连接的相关信息<br>   private boolean isInMulti;<br>   private String user;<br>   private String password;<br>   private int db;<br>   private boolean isInWatch;<br>  <br>   public BinaryClient(final String host, final int port) {<!-- --><br>     super(host, port);<br>   }<br> }<br>  <br> public class Connection implements Closeable {<!-- --><br>   // 管理和Redis连接的socket信息及对应的输入输出流<br>   private JedisSocketFactory jedisSocketFactory;<br>   private Socket socket;<br>   private RedisOutputStream outputStream;<br>   private RedisInputStream inputStream;<br>   private int infiniteSoTimeout = 0;<br>   private boolean broken = false;<br>  <br>   public Connection(final String host, final int port, final boolean ssl,<br>       SSLSocketFactory sslSocketFactory, SSLParameters sslParameters,<br>       HostnameVerifier hostnameVerifier) {<!-- --><br>     // 构建DefaultJedisSocketFactory来创建和Redis连接的Socket对象<br>     this(new DefaultJedisSocketFactory(host, port, Protocol.DEFAULT_TIMEOUT,<br>         Protocol.DEFAULT_TIMEOUT, ssl, sslSocketFactory, sslParameters, hostnameVerifier));<br>   }<br> }<br> 4.2 访问过程</p> 
<p>以Jedis执行set命令为例，整个过程如下：</p> 
<p>Jedis的set操作是通过Client的set操作来实现的。<br> Client的set操作是通过父类Connection的sendCommand来实现。<br> public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands,<br>     AdvancedJedisCommands, ScriptingCommands, BasicCommands, ClusterCommands, SentinelCommands, ModuleCommands {<!-- --><br>   @Override<br>   public String set(final String key, final String value) {<!-- --><br>     checkIsInMultiOrPipeline();<br>     // client执行set操作<br>     client.set(key, value);<br>     return client.getStatusCodeReply();<br>   }<br> }<br>  <br> public class Client extends BinaryClient implements Commands {<!-- --><br>   @Override<br>   public void set(final String key, final String value) {<!-- --><br>     // 执行set命令<br>     set(SafeEncoder.encode(key), SafeEncoder.encode(value));<br>   }<br> }<br>  <br> public class BinaryClient extends Connection {<!-- --><br>   public void set(final byte[] key, final byte[] value) {<!-- --><br>     // 发送set指令<br>     sendCommand(SET, key, value);<br>   }<br> }<br>  <br> public class Connection implements Closeable {<!-- --><br>   public void sendCommand(final ProtocolCommand cmd, final byte[]... args) {<!-- --><br>     try {<!-- --><br>       // socket连接redis<br>       connect();<br>       // 按照redis的协议发送命令<br>       Protocol.sendCommand(outputStream, cmd, args);<br>     } catch (JedisConnectionException ex) {<!-- --><br>     }<br>   }<br> }<br> 五、Jedis分片模式的访问</p> 
<p>基于前面已经介绍的Redis分片模式的一致性Hash的原理来理解Jedis的分片模式的访问。</p> 
<p>关于Redis分片模式的概念：Redis在3.0版本之前没有集群模式的概念，这导致单节点能够存储的数据有限，通过Redis的客户端如Jedis在客户端通过一致性Hash算法来实现数据的分片存储。</p> 
<p>本质上Redis的分片模式跟Redis本身没有任何关系，只是通过客户端来解决单节点数据有限存储的问题。</p> 
<p>ShardedJedis访问Redis的核心在于构建对象的时候初始化一致性Hash对象，构建一致性Hash经典的Hash值和node的映射关系。构建完映射关系后执行set等操作就是Hash值到node的寻址过程，寻址完成后直接进行单节点的操作。</p> 
<p><img src="https://images2.imgbox.com/16/3c/wwAl4sLy_o.png" alt="eef92abc110c498bbb311afc41aa3110.png"></p> 
<p><br> 5.1 创建过程 </p> 
<p>ShardedJedis的创建过程在于父类的Sharded中关于一致性Hash相关的初始化过程，核心在于构建一致性的虚拟节点以及虚拟节点和Redis节点的映射关系。</p> 
<p>源码中最核心的部分代码在于根据根据权重映射成未160个虚拟节点，通过虚拟节点来定位到具体的Redis节点。</p> 
<p>public class Sharded&lt;R, S extends ShardInfo&lt;R&gt;&gt; {<!-- --><br>  <br>   public static final int DEFAULT_WEIGHT = 1;<br>   // 保存虚拟节点和redis的node节点的映射关系<br>   private TreeMap&lt;Long, S&gt; nodes;<br>   // hash算法<br>   private final Hashing algo;<br>   // 保存redis节点和访问该节点的Jedis的连接信息<br>   private final Map&lt;ShardInfo&lt;R&gt;, R&gt; resources = new LinkedHashMap&lt;&gt;();<br>  <br>   public Sharded(List&lt;S&gt; shards, Hashing algo) {<!-- --><br>     this.algo = algo;<br>     initialize(shards);<br>   }<br>  <br>   private void initialize(List&lt;S&gt; shards) {<!-- --><br>     nodes = new TreeMap&lt;&gt;();<br>     // 遍历每个redis的节点并设置hash值到节点的映射关系<br>     for (int i = 0; i != shards.size(); ++i) {<!-- --><br>       final S shardInfo = shards.get(i);<br>       // 根据权重映射成未160个虚拟节点<br>       int N =  160 * shardInfo.getWeight();<br>       if (shardInfo.getName() == null) for (int n = 0; n &lt; N; n++) {<!-- --><br>         // 构建hash值和节点映射关系<br>         nodes.put(this.algo.hash("SHARD-" + i + "-NODE-" + n), shardInfo);<br>       }<br>       else for (int n = 0; n &lt; N; n++) {<!-- --><br>         nodes.put(this.algo.hash(shardInfo.getName() + "*" + n), shardInfo);<br>       }<br>       // 保存每个节点的访问对象<br>       resources.put(shardInfo, shardInfo.createResource());<br>     }<br>   }<br> }<br> 5.2 访问过程</p> 
<p>ShardedJedis的访问过程就是一致性Hash的计算过程，核心的逻辑就是：通过Hash算法对访问的key进行Hash计算生成Hash值，根据Hash值获取对应Redis节点，根据对应的Redis节点获取对应的访问对象Jedis。</p> 
<p>获取访问对象Jedis之后就可以直接进行命令操作。</p> 
<p>public class Sharded&lt;R, S extends ShardInfo&lt;R&gt;&gt; {<!-- --><br>  <br>   public static final int DEFAULT_WEIGHT = 1;<br>   private TreeMap&lt;Long, S&gt; nodes;<br>   private final Hashing algo;<br>   // 保存redis节点和访问该节点的Jedis的连接信息<br>   private final Map&lt;ShardInfo&lt;R&gt;, R&gt; resources = new LinkedHashMap&lt;&gt;();<br>  <br>   public R getShard(String key) {<!-- --><br>     // 根据redis节点找到对应的访问对象Jedis<br>     return resources.get(getShardInfo(key));<br>   }<br>  <br>   public S getShardInfo(String key) {<!-- --><br>     return getShardInfo(SafeEncoder.encode(getKeyTag(key)));<br>   }<br>  <br>   public S getShardInfo(byte[] key) {<!-- --><br>     // 针对访问的key生成对应的hash值<br>     // 根据hash值找到对应的redis节点<br>     SortedMap&lt;Long, S&gt; tail = nodes.tailMap(algo.hash(key));<br>     if (tail.isEmpty()) {<!-- --><br>       return nodes.get(nodes.firstKey());<br>     }<br>     return tail.get(tail.firstKey());<br>   }<br> }<br> 六、Jedis集群模式的访问</p> 
<p>基于前面介绍的Redis的集群原理来理解Jedis的集群模式的访问。</p> 
<p>Jedis能够实现key和哈希槽的定位的核心机制在于哈希槽和Redis节点的映射，而这个发现过程基于Redis的cluster slot命令。</p> 
<p>关于Redis集群操作的命令：Redis通过cluster slots会返回Redis集群的整体状况。返回每一个Redis节点的信息包含：</p> 
<p>哈希槽起始编号<br> 哈希槽结束编号<br> 哈希槽对应master节点，节点使用IP/Port表示<br> master节点的第一个副本<br> master节点的第二个副本<br> 127.0.0.1:30001&gt; cluster slots<br> 1) 1) (integer) 0 // 开始槽位<br>    2) (integer) 5460 // 结束槽位<br>    3) 1) "127.0.0.1" // master节点的host<br>       2) (integer) 30001 // master节点的port<br>       3) "09dbe9720cda62f7865eabc5fd8857c5d2678366" // 节点的编码<br>    4) 1) "127.0.0.1" // slave节点的host<br>       2) (integer) 30004 // slave节点的port<br>       3) "821d8ca00d7ccf931ed3ffc7e3db0599d2271abf" // 节点的编码<br> 2) 1) (integer) 5461<br>    2) (integer) 10922<br>    3) 1) "127.0.0.1"<br>       2) (integer) 30002<br>       3) "c9d93d9f2c0c524ff34cc11838c2003d8c29e013"<br>    4) 1) "127.0.0.1"<br>       2) (integer) 30005<br>       3) "faadb3eb99009de4ab72ad6b6ed87634c7ee410f"<br> 3) 1) (integer) 10923<br>    2) (integer) 16383<br>    3) 1) "127.0.0.1"<br>       2) (integer) 30003<br>       3) "044ec91f325b7595e76dbcb18cc688b6a5b434a1"<br>    4) 1) "127.0.0.1"<br>       2) (integer) 30006<br>       3) "58e6e48d41228013e5d9c1c37c5060693925e97e"<br> Jedis访问集群模式Redis的整体流程图如下所示，从图中可以看出核心的流程包含JedisCluster对象的创建以及通过JedisCluster对象实现Redis的访问。</p> 
<p>JedisCluster对象的创建核心在于创建JedisClusterInfoCache对象并通过集群发现来建立slot和集群节点的映射关系。</p> 
<p>JedisCluster对Redis集群的访问在于获取key所在的Redis节点并通过Jedis对象进行访问。</p> 
<p><img src="https://images2.imgbox.com/d6/64/FTP6kJlj_o.png" alt="cc646eda12ea49d5b3a4620743472152.png"></p> 
<p><br> 6.1 创建过程 </p> 
<p>JedisCluster的类关系如下图所示，在图中可以看到核心变量JedisSlotBasedConnectionHandler对象。</p> 
<p><img src="https://images2.imgbox.com/cb/a0/QnIX27DP_o.png" alt="30cca2d868b6421b94b66e48c97153b5.png"><br> JedisCluster的父类BinaryJedisCluster创建了JedisSlotBasedConnectionHandler对象，该对象负责和Redis的集群进行通信。 </p> 
<p>public class JedisCluster extends BinaryJedisCluster implements JedisClusterCommands,<br>     MultiKeyJedisClusterCommands, JedisClusterScriptingCommands {<!-- --><br>   public JedisCluster(Set&lt;HostAndPort&gt; jedisClusterNode, int connectionTimeout, int soTimeout,<br>       int maxAttempts, String password, String clientName, final GenericObjectPoolConfig poolConfig,<br>       boolean ssl, SSLSocketFactory sslSocketFactory, SSLParameters sslParameters,<br>       HostnameVerifier hostnameVerifier, JedisClusterHostAndPortMap hostAndPortMap) {<!-- --><br>  <br>     // 访问父类BinaryJedisCluster<br>     super(jedisClusterNode, connectionTimeout, soTimeout, maxAttempts, password, clientName, poolConfig,<br>         ssl, sslSocketFactory, sslParameters, hostnameVerifier, hostAndPortMap);<br>   }<br> }<br>  <br> public class BinaryJedisCluster implements BinaryJedisClusterCommands,<br>     MultiKeyBinaryJedisClusterCommands, JedisClusterBinaryScriptingCommands, Closeable {<!-- --><br>   public BinaryJedisCluster(Set&lt;HostAndPort&gt; jedisClusterNode, int connectionTimeout, int soTimeout,<br>       int maxAttempts, String user, String password, String clientName, GenericObjectPoolConfig poolConfig,<br>       boolean ssl, SSLSocketFactory sslSocketFactory, SSLParameters sslParameters,<br>       HostnameVerifier hostnameVerifier, JedisClusterHostAndPortMap hostAndPortMap) {<!-- --><br>  <br>     // 创建JedisSlotBasedConnectionHandler对象<br>     this.connectionHandler = new JedisSlotBasedConnectionHandler(jedisClusterNode, poolConfig,<br>         connectionTimeout, soTimeout, user, password, clientName, ssl, sslSocketFactory, sslParameters, hostnameVerifier, hostAndPortMap);<br>  <br>     this.maxAttempts = maxAttempts;<br>   }<br> }<br> JedisSlotBasedConnectionHandler的核心在于创建并初始化JedisClusterInfoCache对象，该对象缓存了Redis集群的信息。</p> 
<p>JedisClusterInfoCache对象的初始化过程通过initializeSlotsCache来完成，主要目的用于实现集群节点和槽位发现。</p> 
<p>public class JedisSlotBasedConnectionHandler extends JedisClusterConnectionHandler {<!-- --><br>   public JedisSlotBasedConnectionHandler(Set&lt;HostAndPort&gt; nodes, GenericObjectPoolConfig poolConfig,<br>       int connectionTimeout, int soTimeout, String user, String password, String clientName,<br>       boolean ssl, SSLSocketFactory sslSocketFactory, SSLParameters sslParameters,<br>       HostnameVerifier hostnameVerifier, JedisClusterHostAndPortMap portMap) {<!-- --><br>  <br>     super(nodes, poolConfig, connectionTimeout, soTimeout, user, password, clientName,<br>         ssl, sslSocketFactory, sslParameters, hostnameVerifier, portMap);<br>   }<br> }<br>  <br> public abstract class JedisClusterConnectionHandler implements Closeable {<!-- --><br>   public JedisClusterConnectionHandler(Set&lt;HostAndPort&gt; nodes, final GenericObjectPoolConfig poolConfig,<br>       int connectionTimeout, int soTimeout, int infiniteSoTimeout, String user, String password, String clientName,<br>       boolean ssl, SSLSocketFactory sslSocketFactory, SSLParameters sslParameters,<br>       HostnameVerifier hostnameVerifier, JedisClusterHostAndPortMap portMap) {<!-- --><br>  <br>     // 创建JedisClusterInfoCache对象<br>     this.cache = new JedisClusterInfoCache(poolConfig, connectionTimeout, soTimeout, infiniteSoTimeout,<br>         user, password, clientName, ssl, sslSocketFactory, sslParameters, hostnameVerifier, portMap);<br>  <br>     // 初始化jedis的Slot信息<br>     initializeSlotsCache(nodes, connectionTimeout, soTimeout, infiniteSoTimeout,<br>         user, password, clientName, ssl, sslSocketFactory, sslParameters, hostnameVerifier);<br>   }<br>  <br>  <br>   private void initializeSlotsCache(Set&lt;HostAndPort&gt; startNodes,<br>       int connectionTimeout, int soTimeout, int infiniteSoTimeout, String user, String password, String clientName,<br>       boolean ssl, SSLSocketFactory sslSocketFactory, SSLParameters sslParameters, HostnameVerifier hostnameVerifier) {<!-- --><br>     for (HostAndPort hostAndPort : startNodes) {<!-- --><br>  <br>       try (Jedis jedis = new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), connectionTimeout,<br>           soTimeout, infiniteSoTimeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier)) {<!-- --><br>  <br>         // 通过discoverClusterNodesAndSlots进行集群发现<br>         cache.discoverClusterNodesAndSlots(jedis);<br>         return;<br>       } catch (JedisConnectionException e) {<!-- --><br>       }<br>     }<br>   }<br> }<br> JedisClusterInfoCache的nodes用来保存Redis集群的节点信息，slots用来保存槽位和集群节点的信息。</p> 
<p>nodes和slots维持的对象都是JedisPool对象，该对象维持了和Redis的连接信息。集群的发现过程由discoverClusterNodesAndSlots来实现，本质是执行Redis的集群发现命令cluster slots实现的。</p> 
<p>public class JedisClusterInfoCache {<!-- --><br>   // 负责保存redis集群的节点信息<br>   private final Map&lt;String, JedisPool&gt; nodes = new HashMap&lt;&gt;();<br>   // 负责保存redis的槽位和redis节点的映射关系<br>   private final Map&lt;Integer, JedisPool&gt; slots = new HashMap&lt;&gt;();<br>  <br>   // 负责集群的发现逻辑<br>   public void discoverClusterNodesAndSlots(Jedis jedis) {<!-- --><br>     w.lock();<br>  <br>     try {<!-- --><br>       reset();<br>       List&lt;Object&gt; slots = jedis.clusterSlots();<br>  <br>       for (Object slotInfoObj : slots) {<!-- --><br>         List&lt;Object&gt; slotInfo = (List&lt;Object&gt;) slotInfoObj;<br>  <br>         if (slotInfo.size() &lt;= MASTER_NODE_INDEX) {<!-- --><br>           continue;<br>         }<br>         // 获取redis节点对应的槽位信息<br>         List&lt;Integer&gt; slotNums = getAssignedSlotArray(slotInfo);<br>  <br>         // hostInfos<br>         int size = slotInfo.size();<br>         for (int i = MASTER_NODE_INDEX; i &lt; size; i++) {<!-- --><br>           List&lt;Object&gt; hostInfos = (List&lt;Object&gt;) slotInfo.get(i);<br>           if (hostInfos.isEmpty()) {<!-- --><br>             continue;<br>           }<br>  <br>           HostAndPort targetNode = generateHostAndPort(hostInfos);<br>           // 负责保存redis节点信息<br>           setupNodeIfNotExist(targetNode);<br>           if (i == MASTER_NODE_INDEX) {<!-- --><br>             // 负责保存槽位和redis节点的映射关系<br>             assignSlotsToNode(slotNums, targetNode);<br>           }<br>         }<br>       }<br>     } finally {<!-- --><br>       w.unlock();<br>     }<br>   }<br>  <br>   public void assignSlotsToNode(List&lt;Integer&gt; targetSlots, HostAndPort targetNode) {<!-- --><br>     w.lock();<br>     try {<!-- --><br>       JedisPool targetPool = setupNodeIfNotExist(targetNode);<br>       // 保存槽位和对应的JedisPool对象<br>       for (Integer slot : targetSlots) {<!-- --><br>         slots.put(slot, targetPool);<br>       }<br>     } finally {<!-- --><br>       w.unlock();<br>     }<br>   }<br>  <br>   public JedisPool setupNodeIfNotExist(HostAndPort node) {<!-- --><br>     w.lock();<br>     try {<!-- --><br>       // 生产redis节点对应的nodeKey<br>       String nodeKey = getNodeKey(node);<br>       JedisPool existingPool = nodes.get(nodeKey);<br>       if (existingPool != null) return existingPool;<br>       // 生产redis节点对应的JedisPool<br>       JedisPool nodePool = new JedisPool(poolConfig, node.getHost(), node.getPort(),<br>           connectionTimeout, soTimeout, infiniteSoTimeout, user, password, 0, clientName,<br>           ssl, sslSocketFactory, sslParameters, hostnameVerifier);<br>       // 保存redis节点的key和对应的JedisPool对象<br>       nodes.put(nodeKey, nodePool);<br>       return nodePool;<br>     } finally {<!-- --><br>       w.unlock();<br>     }<br>   }<br> }<br> JedisPool的类关系如下图所示，其中内部internalPool是通过apache common pool来实现的池化。</p> 
<p><img src="https://images2.imgbox.com/e8/69/fMeHgjf7_o.png" alt="40351b2b52d64c31bc5e3008d651f421.png"><br> JedisPool内部的internalPool通过JedisFactory的makeObject来创建Jedis对象。 </p> 
<p>每个Redis节点都会对应一个JedisPool对象，通过JedisPool来管理Jedis的申请释放复用等。</p> 
<p>public class JedisPool extends JedisPoolAbstract {<!-- --><br>  <br>   public JedisPool() {<!-- --><br>     this(Protocol.DEFAULT_HOST, Protocol.DEFAULT_PORT);<br>   }<br> }<br>  <br> public class JedisPoolAbstract extends Pool&lt;Jedis&gt; {<!-- --><br>  <br>   public JedisPoolAbstract() {<!-- --><br>     super();<br>   }<br> }<br>  <br> public abstract class Pool&lt;T&gt; implements Closeable {<!-- --><br>   protected GenericObjectPool&lt;T&gt; internalPool;<br>  <br>   public void initPool(final GenericObjectPoolConfig poolConfig, PooledObjectFactory&lt;T&gt; factory) {<!-- --><br>     if (this.internalPool != null) {<!-- --><br>       try {<!-- --><br>         closeInternalPool();<br>       } catch (Exception e) {<!-- --><br>       }<br>     }<br>     this.internalPool = new GenericObjectPool&lt;&gt;(factory, poolConfig);<br>   }<br> }<br>  <br> class JedisFactory implements PooledObjectFactory&lt;Jedis&gt; {<!-- --><br>    <br>   @Override<br>   public PooledObject&lt;Jedis&gt; makeObject() throws Exception {<!-- --><br>     // 创建Jedis对象<br>     final HostAndPort hp = this.hostAndPort.get();<br>     final Jedis jedis = new Jedis(hp.getHost(), hp.getPort(), connectionTimeout, soTimeout,<br>         infiniteSoTimeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);<br>  <br>     try {<!-- --><br>       // Jedis对象连接<br>       jedis.connect();<br>       if (user != null) {<!-- --><br>         jedis.auth(user, password);<br>       } else if (password != null) {<!-- --><br>         jedis.auth(password);<br>       }<br>       if (database != 0) {<!-- --><br>         jedis.select(database);<br>       }<br>       if (clientName != null) {<!-- --><br>         jedis.clientSetname(clientName);<br>       }<br>     } catch (JedisException je) {<!-- --><br>       jedis.close();<br>       throw je;<br>     }<br>     // 将Jedis对象包装成DefaultPooledObject进行返回<br>     return new DefaultPooledObject&lt;&gt;(jedis);<br>   }<br> }<br> 6.2 访问过程</p> 
<p>JedisCluster访问Redis的过程通过JedisClusterCommand来实现重试机制，最终通过Jedis对象来实现访问。从实现的角度来说JedisCluster是在Jedis之上封装了一层，进行集群节点定位以及重试机制等。</p> 
<p>以set命令为例，整个访问通过JedisClusterCommand实现如下：</p> 
<p>计算key所在的Redis节点。<br> 获取Redis节点对应的Jedis对象。<br> 通过Jedis对象进行set操作。<br> public class JedisCluster extends BinaryJedisCluster implements JedisClusterCommands,<br>     MultiKeyJedisClusterCommands, JedisClusterScriptingCommands {<!-- --><br>  <br>   @Override<br>   public String set(final String key, final String value, final SetParams params) {<!-- --><br>     return new JedisClusterCommand&lt;String&gt;(connectionHandler, maxAttempts) {<!-- --><br>       @Override<br>       public String execute(Jedis connection) {<!-- --><br>         return connection.set(key, value, params);<br>       }<br>     }.run(key);<br>   }<br> }<br> JedisClusterCommand的run方法核心主要定位Redis的key所在的Redis节点，然后获取与该节点对应的Jedis对象进行访问。</p> 
<p>在Jedis对象访问异常后，JedisClusterCommand会进行重试操作并按照一定策略执行renewSlotCache方法进行重集群节点重发现动作。</p> 
<p>public abstract class JedisClusterCommand&lt;T&gt; {<!-- --><br>   public T run(String key) {<!-- --><br>     // 针对key进行槽位的计算<br>     return runWithRetries(JedisClusterCRC16.getSlot(key), this.maxAttempts, false, null);<br>   }<br>    <br>   private T runWithRetries(final int slot, int attempts, boolean tryRandomNode, JedisRedirectionException redirect) {<!-- --><br>  <br>     Jedis connection = null;<br>     try {<!-- --><br>  <br>       if (redirect != null) {<!-- --><br>         connection = this.connectionHandler.getConnectionFromNode(redirect.getTargetNode());<br>         if (redirect instanceof JedisAskDataException) {<!-- --><br>           connection.asking();<br>         }<br>       } else {<!-- --><br>         if (tryRandomNode) {<!-- --><br>           connection = connectionHandler.getConnection();<br>         } else {<!-- --><br>           // 根据slot去获取Jedis对象<br>           connection = connectionHandler.getConnectionFromSlot(slot);<br>         }<br>       }<br>       // 执行真正的Redis的命令<br>       return execute(connection);<br>     } catch (JedisNoReachableClusterNodeException jnrcne) {<!-- --><br>       throw jnrcne;<br>     } catch (JedisConnectionException jce) {<!-- --><br>  <br>       releaseConnection(connection);<br>       connection = null;<br>  <br>       if (attempts &lt;= 1) {<!-- --><br>         // 保证最后两次机会去重新刷新槽位和节点的对应的信息<br>         this.connectionHandler.renewSlotCache();<br>       }<br>       // 按照重试次数进行重试操作<br>       return runWithRetries(slot, attempts - 1, tryRandomNode, redirect);<br>     } catch (JedisRedirectionException jre) {<!-- --><br>       // 针对返回Move命令立即触发重新刷新槽位和节点的对应信息<br>       if (jre instanceof JedisMovedDataException) {<!-- --><br>         // it rebuilds cluster's slot cache recommended by Redis cluster specification<br>         this.connectionHandler.renewSlotCache(connection);<br>       }<br>  <br>       releaseConnection(connection);<br>       connection = null;<br>  <br>       return runWithRetries(slot, attempts - 1, false, jre);<br>     } finally {<!-- --><br>       releaseConnection(connection);<br>     }<br>   }<br> }<br> JedisSlotBasedConnectionHandler的cache对象维持了slot和node的映射关系，通过getConnectionFromSlot方法来获取该slot对应的Jedis对象。</p> 
<p>public class JedisSlotBasedConnectionHandler extends JedisClusterConnectionHandler {<!-- --><br>  <br>   protected final JedisClusterInfoCache cache;<br>  <br>   @Override<br>   public Jedis getConnectionFromSlot(int slot) {<!-- --><br>     // 获取槽位对应的JedisPool对象<br>     JedisPool connectionPool = cache.getSlotPool(slot);<br>     if (connectionPool != null) {<!-- --><br>       // 从JedisPool对象中获取Jedis对象<br>       return connectionPool.getResource();<br>     } else {<!-- --><br>       // 获取失败就重新刷新槽位信息<br>       renewSlotCache();<br>       connectionPool = cache.getSlotPool(slot);<br>       if (connectionPool != null) {<!-- --><br>         return connectionPool.getResource();<br>       } else {<!-- --><br>         //no choice, fallback to new connection to random node<br>         return getConnection();<br>       }<br>     }<br>   }<br> }<br> 七、Jedis的Pipeline实现</p> 
<p>Pipeline的技术核心思想是将多个命令发送到服务器而不用等待回复，最后在一个步骤中读取该答复。这种模式的好处在于节省了请求响应这种模式的网络开销。</p> 
<p>Redis的普通命令如set和Pipeline批量操作的核心的差别在于set命令的操作会直接发送请求到Redis并同步等待结果返回，而Pipeline的操作会发送请求但不立即同步等待结果返回，具体的实现可以从Jedis的源码一探究竟。</p> 
<p>原生的Pipeline在集群模式下相关的key必须Hash到同一个节点才能生效，原因在于Pipeline下的Client对象只能其中的一个节点建立了连接。</p> 
<p>在集群模式下归属于不同节点的key能够使用Pipeline就需要针对每个key保存对应的节点的client对象，在最后执行获取数据的时候一并获取。本质上可以认为在单节点的Pipeline的基础上封装成一个集群式的Pipeline。</p> 
<p>7.1 Pipeline用法分析</p> 
<p>Pipeline访问单节点的Redis的时候，通过Jedis对象的Pipeline方法返回Pipeline对象，其他的命令操作通过该Pipeline对象进行访问。</p> 
<p>Pipeline从使用角度来分析，会批量发送多个命令并最后统一使用syncAndReturnAll来一次性返回结果。</p> 
<p>public void pipeline() {<!-- --><br>     jedis = new Jedis(hnp.getHost(), hnp.getPort(), 500);<br>     Pipeline p = jedis.pipelined();<br>     // 批量发送命令到redis<br>     p.set("foo", "bar");<br>     p.get("foo");<br>     // 同步等待响应结果<br>     List&lt;Object&gt; results = p.syncAndReturnAll();<br>  <br>     assertEquals(2, results.size());<br>     assertEquals("OK", results.get(0));<br>     assertEquals("bar", results.get(1));<br>  }<br>  <br>  <br> public abstract class PipelineBase extends Queable implements BinaryRedisPipeline, RedisPipeline {<!-- --><br>  <br>   @Override<br>   public Response&lt;String&gt; set(final String key, final String value) {<!-- --><br>     // 发送命令<br>     getClient(key).set(key, value);<br>     // pipeline的getResponse只是把待响应的请求聚合到pipelinedResponses对象当中<br>     return getResponse(BuilderFactory.STRING);<br>   }<br> }<br>  <br>  <br> public class Queable {<!-- --><br>  <br>   private Queue&lt;Response&lt;?&gt;&gt; pipelinedResponses = new LinkedList&lt;&gt;();<br>   protected &lt;T&gt; Response&lt;T&gt; getResponse(Builder&lt;T&gt; builder) {<!-- --><br>     Response&lt;T&gt; lr = new Response&lt;&gt;(builder);<br>     // 统一保存到响应队列当中<br>     pipelinedResponses.add(lr);<br>     return lr;<br>   }<br> }<br>  <br>  <br> public class Pipeline extends MultiKeyPipelineBase implements Closeable {<!-- --><br>  <br>   public List&lt;Object&gt; syncAndReturnAll() {<!-- --><br>     if (getPipelinedResponseLength() &gt; 0) {<!-- --><br>       // 根据批量发送命令的个数即需要批量返回命令的个数，通过client对象进行批量读取<br>       List&lt;Object&gt; unformatted = client.getMany(getPipelinedResponseLength());<br>       List&lt;Object&gt; formatted = new ArrayList&lt;&gt;();<br>       for (Object o : unformatted) {<!-- --><br>         try {<!-- --><br>           // 格式化每个返回的结果并最终保存在列表中进行返回<br>           formatted.add(generateResponse(o).get());<br>         } catch (JedisDataException e) {<!-- --><br>           formatted.add(e);<br>         }<br>       }<br>       return formatted;<br>     } else {<!-- --><br>       return java.util.Collections.&lt;Object&gt; emptyList();<br>     }<br>   }<br> }<br> 普通set命令发送请求给Redis后立即通过getStatusCodeReply来获取响应结果，所以这是一种请求响应的模式。</p> 
<p>getStatusCodeReply在获取响应结果的时候会通过flush()命令强制发送报文到Redis服务端然后通过读取响应结果。</p> 
<p>public class BinaryJedis implements BasicCommands, BinaryJedisCommands, MultiKeyBinaryCommands,<br>     AdvancedBinaryJedisCommands, BinaryScriptingCommands, Closeable {<!-- --><br>  <br>   @Override<br>   public String set(final byte[] key, final byte[] value) {<!-- --><br>     checkIsInMultiOrPipeline();<br>     // 发送命令<br>     client.set(key, value);<br>     // 等待请求响应<br>     return client.getStatusCodeReply();<br>   }<br> }<br>  <br>  <br> public class Connection implements Closeable {<!-- --><br>   public String getStatusCodeReply() {<!-- --><br>     // 通过flush立即发送请求<br>     flush();<br>     // 处理响应请求<br>     final byte[] resp = (byte[]) readProtocolWithCheckingBroken();<br>     if (null == resp) {<!-- --><br>       return null;<br>     } else {<!-- --><br>       return SafeEncoder.encode(resp);<br>     }<br>   }<br> }<br>  <br>  <br> public class Connection implements Closeable {<!-- --><br>   protected void flush() {<!-- --><br>     try {<!-- --><br>       // 针对输出流进行flush操作保证报文的发出<br>       outputStream.flush();<br>     } catch (IOException ex) {<!-- --><br>       broken = true;<br>       throw new JedisConnectionException(ex);<br>     }<br>   }<br> }<br> 八、结束语</p> 
<p>Jedis作为Redis官方首选的Java客户端开发包，支持绝大部分的Redis的命令，也是日常中使用较多的Redis客户端。</p> 
<p>了解了Jedis的实现原理，除了能够支持Redis的日常操作外，还能更好的应对Redis的额外操作诸如扩容时的技术选型。</p> 
<p>通过介绍Jedis针对单机模式、分配模式、集群模式三种场景访问方式，让大家有个从宏观到微观的理解过程，掌握Jedis的核心思想并更好的应用到实践当中。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/36d0ffbf740043d04ade96bf1da58e57/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Quartz&#43;SpringBoot实现一个任务对应多个触发器的添加、暂停、恢复、删除、查询所有，每个方法都有解释</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38c3c8cde7bb8eb242e9fe6dc539086d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在docker 训练新环境中mmclassification装包遇见的一些问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>