<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ActiveMQ消息中间件使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ActiveMQ消息中间件使用" />
<meta property="og:description" content="ActiveMQ介绍 ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。
jms介绍 JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。
JMS是一种与厂商无关的 API，用来访问消息收发系统消息，它类似于JDBC(Java Database Connectivity)。这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。
ActivcMQ在linux下的安装 1.解压ActiveMQ安装包 tar -xvf apache-activemq-5.12.0-bin.tar.gz -C /usr/local/
2.进入bin目录,运行activemq ./activemq start
3.到页面访问 ip&#43;8161端口号,点击下图箭头所指位置进入管理页面,默认用户名密码为admin
补充: 如果页面无法访问可能存在如下情况:
1.主机名没有映射,8161端口没有被监听
netstat -tnlp查看端口监听
若没有监听查看主机名是否映射
(1)vim /etc/sysconfig/network
(2)vim /etc/hosts
若没有则添加映射,重启activemq。
2.8161端口正常监听,页面仍然无法访问,检查防火墙是否关闭。
activemq使用java代码实现 对于消息的传递有两种类型,1点对点(一个provider一个consumer),2.发布/订阅(一个消息可被多个consumer消费,注意:consumer端需在provider端前面开启,否则无法接收到发送的消息)
使用jms实现消息的发送与接收 在maven工程的pom文件中加入activemq依赖
&lt;dependency&gt;
&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
&lt;artifactId&gt;activemq-client&lt;/artifactId&gt;
&lt;version&gt;5.13.4&lt;/version&gt;
&lt;/dependency&gt;
1.点对点(queue)java代码实现
producer端
public static void main(String[] args) throws JMSException { //1.创建练连接工厂 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&#34;tcp://192.168.219.128:61616&#34;); //2.创建连接 Connection connection = connectionFactory." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/57012bf9104a69c66ade1e1813fed778/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-18T00:49:08+08:00" />
<meta property="article:modified_time" content="2018-09-18T00:49:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ActiveMQ消息中间件使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li>ActiveMQ介绍</li></ul> 
<p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p> 
<ul><li>jms介绍</li></ul> 
<p>JMS即<a href="https://baike.baidu.com/item/Java%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1" rel="nofollow">Java消息服务</a>（Java Message Service）应用程序接口，是一个<a href="https://baike.baidu.com/item/Java%E5%B9%B3%E5%8F%B0" rel="nofollow">Java平台</a>中关于面向<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/5899771" rel="nofollow">消息中间件</a>（MOM）的<a href="https://baike.baidu.com/item/API/10154" rel="nofollow">API</a>，用于在两个应用程序之间，或<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336" rel="nofollow">分布式系统</a>中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p> 
<p>JMS是一种与厂商无关的 API，用来访问消息收发系统消息，它类似于<a href="https://baike.baidu.com/item/JDBC" rel="nofollow">JDBC</a>(Java Database Connectivity)。这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。</p> 
<ul><li>ActivcMQ在linux下的安装</li></ul> 
<p>1.解压ActiveMQ安装包 tar -xvf apache-activemq-5.12.0-bin.tar.gz -C /usr/local/</p> 
<p><img alt="" class="has" height="28" src="https://images2.imgbox.com/9a/6a/hPMu5kxV_o.png" width="840"></p> 
<p>2.进入bin目录,运行activemq  ./activemq start</p> 
<p>3.到页面访问  ip+8161端口号,点击下图箭头所指位置进入管理页面,默认用户名密码为admin</p> 
<p><img alt="" class="has" height="435" src="https://images2.imgbox.com/b5/aa/La7hvMPr_o.png" width="584"></p> 
<p>补充: 如果页面无法访问可能存在如下情况:</p> 
<p>1.主机名没有映射,8161端口没有被监听</p> 
<p>netstat -tnlp查看端口监听</p> 
<p><img alt="" class="has" height="157" src="https://images2.imgbox.com/36/1a/n6bFHBfm_o.png" width="802"></p> 
<p>若没有监听查看主机名是否映射</p> 
<p>(1)vim /etc/sysconfig/network</p> 
<p><img alt="" class="has" height="43" src="https://images2.imgbox.com/e5/25/iTo2g3OH_o.png" width="184"></p> 
<p>(2)vim  /etc/hosts</p> 
<p><img alt="" class="has" height="44" src="https://images2.imgbox.com/1b/c9/nbu4U6bU_o.png" width="635"></p> 
<p>若没有则添加映射,重启activemq。</p> 
<p>2.8161端口正常监听,页面仍然无法访问,检查防火墙是否关闭。</p> 
<ul><li>activemq使用java代码实现</li></ul> 
<p>对于消息的传递有两种类型,1点对点(一个provider一个consumer),2.发布/订阅(一个消息可被多个consumer消费,注意:consumer端需在provider端前面开启,否则无法接收到发送的消息)</p> 
<ul><li>使用jms实现消息的发送与接收</li></ul> 
<p>在maven工程的pom文件中加入activemq依赖</p> 
<p>      &lt;dependency&gt;<br>             &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;<br>             &lt;artifactId&gt;activemq-client&lt;/artifactId&gt;<br>             &lt;version&gt;5.13.4&lt;/version&gt;<br>         &lt;/dependency&gt;</p> 
<p>1.点对点(queue)java代码实现</p> 
<p>producer端</p> 
<pre class="has"><code class="language-java">public static void main(String[] args) throws JMSException {
		//1.创建练连接工厂
		ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.219.128:61616");
		//2.创建连接
		Connection connection = connectionFactory.createConnection();
		//3.启动连接
		connection.start();
		//4.获取会话(参数1:是否开启事务,参数2:消息确认方式)
		Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
		//5.创建消息队列
		Queue queue = session.createQueue("myQueue");
		//6.创建消息生产者对象
		MessageProducer producer = session.createProducer(queue);
		//7.创建消息对象
		TextMessage message = session.createTextMessage("日你仙人板板");
		//8.发送消息
		producer.send(message);
		//9.关闭资源
		producer.close();
		session.close();
		connection.close();
	}</code></pre> 
<p>consumer端</p> 
<pre class="has"><code class="language-java">public static void main(String[] args) throws JMSException, IOException {
		//1.创建连接工厂
		ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.219.128:61616");
		//2.创建连接
		Connection connection = connectionFactory.createConnection();
		//3.启动连接
		connection.start();
		//4.获取session(会话对象)  参数1：是否启动事务  参数2：消息确认方式
		Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
		//5.创建队列对象
		Queue queue = session.createQueue("myQueue");
		//6.创建消息消费者对象
		MessageConsumer consumer = session.createConsumer(queue);
		//7.设置监听
		consumer.setMessageListener(new MessageListener() {
			
			public void onMessage(Message message) {
				TextMessage textMessage=(TextMessage)message;
				try {
					System.out.println("提取消息为"+textMessage.getText());
				} catch (JMSException e) {
					e.printStackTrace();
				}
			}  		});
		//8.等待键盘输入
		System.in.read();
		
		//9.关闭资源
		consumer.close();
		session.close();
		connection.close();

	}</code></pre> 
<p>实现效果</p> 
<p><img alt="" class="has" height="259" src="https://images2.imgbox.com/26/bc/eYs80f7Q_o.png" width="1057"></p> 
<p><a href="http://192.168.219.128:8161/admin/queues.jsp#" rel="nofollow">Number Of Pending Messages</a>  为未消费数量,<a href="http://192.168.219.128:8161/admin/queues.jsp#" rel="nofollow">Number Of Consumers</a>  为consumer连接数,<a href="http://192.168.219.128:8161/admin/queues.jsp#" rel="nofollow">Messages Enqueued</a>  为发送消息数量, <a href="http://192.168.219.128:8161/admin/queues.jsp#" rel="nofollow">Messages Dequeued</a>  为接收消息数量,views中的atom查看消息详情。queue模式中发送消息数量=接收消息数量+未消费数量。</p> 
<p>2.发布/订阅(topic)java代码实现</p> 
<p>producer端</p> 
<pre class="has"><code class="language-java">public static void main(String[] args) throws JMSException {
		// 1.创建练连接工厂
		ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.219.128:61616");
		// 2.创建连接
		Connection connection = connectionFactory.createConnection();
		// 3.启动连接
		connection.start();
		// 4.获取会话(参数1:是否开启事务,参数2:消息确认方式)
		Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
		// 5.创建消息队列
		Topic topic = session.createTopic("myTopic");
		// 6.创建消息生产者对象
		MessageProducer producer = session.createProducer(topic);
		// 7.创建消息对象
		TextMessage message = session.createTextMessage("日你仙人板板");
		// 8.发送消息
		producer.send(message);
		// 9.关闭资源
		producer.close();
		session.close();
		connection.close();
	}</code></pre> 
<p>consumer端</p> 
<pre class="has"><code class="language-java">public static void main(String[] args) throws JMSException, IOException {
	//1.创建连接工厂
			ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.219.128:61616");
			//2.创建连接
			Connection connection = connectionFactory.createConnection();
			//3.启动连接
			connection.start();
			//4.获取session(会话对象)  参数1：是否启动事务  参数2：消息确认方式
			Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
			//5.创建队列对象
			Topic topic = session.createTopic("myTopic");
			//6.创建消息消费者对象
			MessageConsumer consumer = session.createConsumer(topic);
			//7.设置监听
			consumer.setMessageListener(new MessageListener() {
				
				public void onMessage(Message message) {
					TextMessage textMessage=(TextMessage)message;
					try {
						System.out.println("提取消息为"+textMessage.getText());
					} catch (JMSException e) {
						e.printStackTrace();
					}
				}  		});
			//8.等待键盘输入
			System.in.read();
			
			//9.关闭资源
			consumer.close();
			session.close();
			connection.close();
}</code></pre> 
<p>与queue模式相比,代码中只需要修改创建队列对象,将createQueue改为createTopic。</p> 
<ul><li>使用jms与spring整合实现activemq</li></ul> 
<p>添加依赖</p> 
<pre class="has"><code>
   &lt;properties&gt;
  	&lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;
  &lt;/properties&gt;
  
  &lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework&lt;/groupId&gt;
		&lt;artifactId&gt;spring-jms&lt;/artifactId&gt;
		&lt;version&gt;${spring.version}&lt;/version&gt;
	&lt;/dependency&gt;
  	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework&lt;/groupId&gt;
		&lt;artifactId&gt;spring-test&lt;/artifactId&gt;
		&lt;version&gt;${spring.version}&lt;/version&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;junit&lt;/groupId&gt;
		&lt;artifactId&gt;junit&lt;/artifactId&gt;
		&lt;version&gt;4.9&lt;/version&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
		&lt;artifactId&gt;activemq-client&lt;/artifactId&gt;
		&lt;version&gt;5.13.4&lt;/version&gt;
	 &lt;/dependency&gt;
  &lt;/dependencies&gt;  </code></pre> 
<ul><li>producer端配置文件</li></ul> 
<p>applicationContext-producer</p> 
<pre class="has"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:amq="http://activemq.apache.org/schema/core"
	xmlns:jms="http://www.springframework.org/schema/jms"
	xsi:schemaLocation="http://www.springframework.org/schema/beans   
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context   
		http://www.springframework.org/schema/context/spring-context.xsd"&gt;
		
		
	&lt;context:component-scan base-package="com.semptian.activemq"&gt;&lt;/context:component-scan&gt;     
	
	   
    &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;  
	&lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;  
	    &lt;property name="brokerURL" value="tcp://192.168.219.128:61616"/&gt;  
	&lt;/bean&gt;
	   
    &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;  
	&lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt;  
	&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;  
	    &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;  
	&lt;/bean&gt;  
		   
    &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;  
	&lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;  
	    &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;  
	    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;  
	&lt;/bean&gt;      
    &lt;!--这个是队列目的地，点对点的  文本信息--&gt;  
	&lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt;  
	    &lt;constructor-arg value="myQueue2"/&gt;  
	&lt;/bean&gt;    
	
	&lt;!--这个是订阅模式  文本信息--&gt;  
	&lt;bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt;  
	    &lt;constructor-arg value="myTopic2"/&gt;  
	&lt;/bean&gt;  
	
&lt;/beans&gt;</code></pre> 
<ul><li>producer端java代码:</li></ul> 
<p>queue模式</p> 
<pre class="has"><code class="language-java">package com.semptian.activemq;

import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.MessageCreator;
import org.springframework.stereotype.Component;

@Component
public class QueueProducer {

	@Autowired
	private JmsTemplate jmsTemplate;
	
	@Autowired
	private Destination queueTextDestination;
	
	/**
	 * 发送文本消息
	 */
	public void sendTextMessage(final String text){
		jmsTemplate.send(queueTextDestination, new MessageCreator() {
			
			public Message createMessage(Session session) throws JMSException {
				
				return session.createTextMessage(text);
			}
		});
		
	}
	
}</code></pre> 
<p>topic模式</p> 
<pre class="has"><code class="language-java">package com.semptian.activemq;

import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.MessageCreator;
import org.springframework.stereotype.Component;

@Component
public class TopicProducer {

	@Autowired
	private JmsTemplate jmsTemplate;
	
	@Autowired
	private Destination topicTextDestination;
	
	/**
	 * 发送文本消息
	 * @param text
	 */
	public void sendTextMessage(final String text){
		jmsTemplate.send(topicTextDestination, new MessageCreator() {
			
			public Message createMessage(Session session) throws JMSException {
				
				return session.createTextMessage(text);
			}
		});
		
	}
	
}</code></pre> 
<p>consumer端配置文件</p> 
<p>(1)applicationContext-queue</p> 
<pre class="has"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:amq="http://activemq.apache.org/schema/core"
	xmlns:jms="http://www.springframework.org/schema/jms"
	xsi:schemaLocation="http://www.springframework.org/schema/beans   
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context   
		http://www.springframework.org/schema/context/spring-context.xsd"&gt;
	
    &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;  
	&lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;  
	    &lt;property name="brokerURL" value="tcp://192.168.219.128:61616"/&gt;  
	&lt;/bean&gt;
	   
    &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;  
	&lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt;  
	&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;  
	    &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;  
	&lt;/bean&gt;  
	
    &lt;!--这个是队列目的地，点对点的  文本信息--&gt;  
	&lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt;  
	    &lt;constructor-arg value="myQueue2"/&gt;  
	&lt;/bean&gt;    
	
	&lt;!-- 我的监听类 --&gt;
	&lt;bean id="myMessageListener" class="com.semptian.activemq.MyMessageListener"&gt;&lt;/bean&gt;
	
	
	&lt;!-- 消息监听容器 --&gt;
	&lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
		&lt;property name="connectionFactory" ref="connectionFactory" /&gt;
		&lt;property name="destination" ref="queueTextDestination" /&gt;
		&lt;property name="messageListener" ref="myMessageListener" /&gt;
	&lt;/bean&gt;
	
&lt;/beans&gt;</code></pre> 
<p>(2)applicationContext-topic</p> 
<pre class="has"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:amq="http://activemq.apache.org/schema/core"
	xmlns:jms="http://www.springframework.org/schema/jms"
	xsi:schemaLocation="http://www.springframework.org/schema/beans   
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context   
		http://www.springframework.org/schema/context/spring-context.xsd"&gt;
	
    &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;  
	&lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;  
	    &lt;property name="brokerURL" value="tcp://192.168.219.128:61616"/&gt;  
	&lt;/bean&gt;
	   
    &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;  
	&lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt;  
	&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;  
	    &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;  
	&lt;/bean&gt;  
	
    &lt;!--这个是队列目的地，点对点的  文本信息--&gt;  
	&lt;bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt;  
	    &lt;constructor-arg value="myTopic2"/&gt;  
	&lt;/bean&gt;    
	
	&lt;!-- 我的监听类 --&gt;
	&lt;bean id="myMessageListener" class="com.semptian.activemq.MyMessageListener"&gt;&lt;/bean&gt;
	
	
	&lt;!-- 消息监听容器 --&gt;
	&lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
		&lt;property name="connectionFactory" ref="connectionFactory" /&gt;
		&lt;property name="destination" ref="topicTextDestination" /&gt;
		&lt;property name="messageListener" ref="myMessageListener" /&gt;
	&lt;/bean&gt;
	
&lt;/beans&gt;</code></pre> 
<p>consumer端java代码</p> 
<pre class="has"><code class="language-java">package com.semptian.activemq;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

public class MyMessageListener implements MessageListener {

	public void onMessage(Message message) {
		
		TextMessage textMessage=(TextMessage)message;
		try {
			System.out.println("接收到消息："+textMessage.getText());
		} catch (JMSException e) {
		
			e.printStackTrace();
		}
		

	}

}</code></pre> 
<ul><li>最后测试代码</li><li>queue模式</li></ul> 
<p>producer端</p> 
<pre class="has"><code class="language-java">package com.semptian.activemq;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.semptian.activemq.QueueProducer;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="classpath:applicationContext-producer.xml")
public class TestQueue {

	@Autowired
	private  QueueProducer queueProducer;
	
	@Test
	public void testSend(){
		queueProducer.sendTextMessage("spring JMS 点对点");
		
	}
	
}
</code></pre> 
<p>consumer端</p> 
<pre class="has"><code class="language-java">package com.semptian.activemq;

import java.io.IOException;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="classpath:applicationContext-queue.xml")
public class TestQueue {

	@Test
	public void testQueue(){
		try {
			System.in.read();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
}
</code></pre> 
<p>界面效果</p> 
<p><img alt="" class="has" height="87" src="https://images2.imgbox.com/e3/8d/Q1q1U7MO_o.png" width="1029"></p> 
<ul><li> topic模式</li></ul> 
<p>producer端</p> 
<pre class="has"><code class="language-java">package com.semptian.activemq;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.semptian.activemq.QueueProducer;
import com.semptian.activemq.TopicProducer;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="classpath:applicationContext-producer.xml")
public class TestTopic {

	@Autowired
	private  TopicProducer topicProducer;
	
	@Test
	public void testSend(){
		topicProducer.sendTextMessage("spring JMS 发布订阅");
		
	}
	
}
</code></pre> 
<p>consumer端</p> 
<pre class="has"><code class="language-java">package com.semptian.activemq;

import java.io.IOException;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="classpath:applicationContext-topic.xml")
public class TestTopic {

	@Test
	public void testTopic(){
		try {
			System.in.read();
		} catch (IOException e) {
			
			e.printStackTrace();
		}
	}
	
}
</code></pre> 
<p>界面效果(注意:topic模式中consumer端需要比producer端先启动)</p> 
<p><img alt="" class="has" height="50" src="https://images2.imgbox.com/ee/f3/kiTU2c2Z_o.png" width="987"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e86f1e2107d33664fa79d3496c327c50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python字典更新时出现value为None的情况</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92e794388ed87fdd7ea8d9e403fc8389/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">#面试--主线程与子线程的执行顺序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>