<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>oracle资源管理计划 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="oracle资源管理计划" />
<meta property="og:description" content="2011-05-06 15:10 Oracle资源管理器 Oracle资源管理器简介
Oracle资源管理器（Oracle Database Resource Manager，以下简称DBRM）管理数据库资源，为不同的会话分配不同的数据库资源。DBRM管理的资源主要包括CPU时间。下面分以下几个章节介绍：
•Oracle DBRM帮你处理哪些问题
•Oracle DBRM是怎样处理这些问题的
•Oracle DBRM包含的内容
•Oracle DBRM资源分配方法
•Oracle DBRM的权限管理
Oracle DBRM帮你处理哪些问题
当数据库服务器资源由操作系统来分配时，你可能会遇到以下问题：
•过多的资源开销
当服务器进程数很多时，操作系统进程和数据库服务进程间的来回切换会导致CPU占用率或内存使用率高。
•低效的调度
操作系统调度数据库服务时占用寄存器，这样做效率很低。
•资源分配的不合理
操作系统平均分配系统资源给活动的进程（对数据库进程来说），不能判断它们的优先级高低。
•不能管理数据库特有的资源，例如：并行执行的服务数和活动的会话数。
Oracle RMDB是如何解决这些问题的
Oracle RMDB把硬件等资源的分配交给数据库服务器本身来解决以上问题。在某个数据库环境中，可能同时存在着多个用户请求数据库服务，并且他们所要完成的任务优先级不同，那么我们就应该区别对待这些会话请求。Oracle RMDB能让你根据各个会话的应用属性，将它们分组，然后为每组分配不同的数据库资源，最大化提高你的数据库应用性能。
Oracle RMDB的具体功能：
•RMDB可以在系统启动时，限制某些会话请求只分配到最少的进程资源和用户使用上限。
•为不同的用户或应用分配不同的CPU时间。在一个数据仓库应用中，ROLAP(relational online analytical processing)应用分配到的比例就应该比批处理任务高。
•限制同一组内用户对数据库操作的并行度。
•建立一个活动的会话池。会话池由一组用户活动会话组成，对某一组用户来说，同一时间活动的会话数有特别的数量上限。如果会话池满了，新的会话请求会被放入等待队列，而且你还可以设置一个时间上限，超过这个上限，等待队列会被停止。会话池限制了同一时间活动的会话请求数量，保证了活动的会话请求更快的完成任务。
•管理长时间未响应的会话或请求，这些会话或请求往往占用了很多的CPU或I/O资源。这些会话能被自动的结束掉，或者将它们换到其他低级的组去。
•优化器会估算请求的运行时间，如果超出了某个显示，RMDB会阻止它的请求。
•限制一个会话的空闲等待时间。
•根据不同的资源分配需求，配置不同的模式。你可以动态的改变这些模式，例如，从白天运行模式变到夜间运行模式，而不用重启数据库服务。你还可以通过Oracle调度器来管理模式的改变。详细内容请见： Chapter 26, &#34;Oracle Scheduler Concepts&#34;。
Oracle RDMB的组成元素
下表介绍了Oracle RDMB的组成元素。
元素 描述 资源使用组 根据会话的资源请求将它们分为一组。RDMB按组管理会话的资源分配，而不是按单个的会话。
资源计划 资源计划包含一系列指令，这些指令就决定了给每个组的资源分配配置。要执行资源的分配，你只需执行相应的资源计划。
资源计划指令 资源计划指令指定了资源计划和组之间的映射关系。
Oracle是通过存储过程来实现这些功能的，你可以在以下包里找到这些存储过程：DBMS_RESOURCE_MANAGER.
资源使用组
资源使用组由许多用户会话组成，这些会话有相同的资源使用请求。新创建一个会话时，RDMB会根据你的设定自动把它分配到某个组。数据库管理员还可以手动的调整某个会话所属的组。
下面三类特别的组是系统组，它们不能被修改或删除。
•SYS_GROUP
•DEFAULT_CONSUMER_GROUP" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3f93e0416c50e49bb7f14c107f7af1de/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-07-22T16:52:14+08:00" />
<meta property="article:modified_time" content="2012-07-22T16:52:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">oracle资源管理计划</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="artical-content-bak main-content editor-side-new"> 
 <div class="con editor-preview-side" id="result"> 
  <div class="content-other-info"> 
   2011-05-06 15:10 
  </div> 
  <h3 class="title content-title">Oracle资源管理器</h3> 
  <div id="content" class="content text-content clearfix"> 
   <p><strong>Oracle资源管理器简介</strong></p> 
   <p>      Oracle资源管理器（Oracle Database Resource Manager，以下简称DBRM）管理数据库资源，为不同的会话分配不同的数据库资源。DBRM管理的资源主要包括CPU时间。下面分以下几个章节介绍：</p> 
   <p>•Oracle DBRM帮你处理哪些问题<br> •Oracle DBRM是怎样处理这些问题的<br> •Oracle DBRM包含的内容<br> •Oracle DBRM资源分配方法<br> •Oracle DBRM的权限管理</p> 
   <p>Oracle DBRM帮你处理哪些问题</p> 
   <p>      当数据库服务器资源由操作系统来分配时，你可能会遇到以下问题：</p> 
   <p>•过多的资源开销<br> 当服务器进程数很多时，操作系统进程和数据库服务进程间的来回切换会导致CPU占用率或内存使用率高。</p> 
   <p> </p> 
   <p>•低效的调度<br> 操作系统调度数据库服务时占用寄存器，这样做效率很低。</p> 
   <p> </p> 
   <p>•资源分配的不合理<br> 操作系统平均分配系统资源给活动的进程（对数据库进程来说），不能判断它们的优先级高低。</p> 
   <p> </p> 
   <p>•不能管理数据库特有的资源，例如：并行执行的服务数和活动的会话数。</p> 
   <p>Oracle RMDB是如何解决这些问题的</p> 
   <p> </p> 
   <p>      Oracle RMDB把硬件等资源的分配交给数据库服务器本身来解决以上问题。在某个数据库环境中，可能同时存在着多个用户请求数据库服务，并且他们所要完成的任务优先级不同，那么我们就应该区别对待这些会话请求。Oracle RMDB能让你根据各个会话的应用属性，将它们分组，然后为每组分配不同的数据库资源，最大化提高你的数据库应用性能。</p> 
   <p>      Oracle RMDB的具体功能：</p> 
   <p>•RMDB可以在系统启动时，限制某些会话请求只分配到最少的进程资源和用户使用上限。<br> •为不同的用户或应用分配不同的CPU时间。在一个数据仓库应用中，ROLAP(relational online analytical processing)应用分配到的比例就应该比批处理任务高。<br> •限制同一组内用户对数据库操作的并行度。<br> •建立一个活动的会话池。会话池由一组用户活动会话组成，对某一组用户来说，同一时间活动的会话数有特别的数量上限。如果会话池满了，新的会话请求会被放入等待队列，而且你还可以设置一个时间上限，超过这个上限，等待队列会被停止。会话池限制了同一时间活动的会话请求数量，保证了活动的会话请求更快的完成任务。<br> •管理长时间未响应的会话或请求，这些会话或请求往往占用了很多的CPU或I/O资源。这些会话能被自动的结束掉，或者将它们换到其他低级的组去。<br> •优化器会估算请求的运行时间，如果超出了某个显示，RMDB会阻止它的请求。<br> •限制一个会话的空闲等待时间。<br> •根据不同的资源分配需求，配置不同的模式。你可以动态的改变这些模式，例如，从白天运行模式变到夜间运行模式，而不用重启数据库服务。你还可以通过Oracle调度器来管理模式的改变。详细内容请见： Chapter 26, "Oracle Scheduler Concepts"。<br> Oracle RDMB的组成元素</p> 
   <p>下表介绍了Oracle RDMB的组成元素。</p> 
   <p><strong>元素</strong>                 <strong>描述</strong> <br> 资源使用组       根据会话的资源请求将它们分为一组。RDMB按组管理会话的资源分配，而不是按单个的会话。<br> 资源计划          资源计划包含一系列指令，这些指令就决定了给每个组的资源分配配置。要执行资源的分配，你只需执行相应的资源计划。<br> 资源计划指令   资源计划指令指定了资源计划和组之间的映射关系。</p> 
   <p>       Oracle是通过存储过程来实现这些功能的，你可以在以下包里找到这些存储过程：DBMS_RESOURCE_MANAGER.</p> 
   <p>资源使用组</p> 
   <p>    资源使用组由许多用户会话组成，这些会话有相同的资源使用请求。新创建一个会话时，RDMB会根据你的设定自动把它分配到某个组。数据库管理员还可以手动的调整某个会话所属的组。</p> 
   <p>    下面三类特别的组是系统组，它们不能被修改或删除。</p> 
   <p>•SYS_GROUP<br> •DEFAULT_CONSUMER_GROUP<br> •OTHER_GROUP <br> 资源计划指令</p> 
   <p>   RDMB根据当前活动资源计划中的一系列资源计划指令为资源使用组分配资源。<strong>资源计划和指令间有着一对多的关系</strong>，资源计划中不能包含两条相同的指令。</p> 
   <p>   有很多种不同分配资源的指令，例如给某个组分配一定百分比的总的CPU时间，或者限制一个组内最大活动的会话数。</p> 
   <p>资源计划</p> 
   <p>   <strong>在一个数据库中同一时间只有一个资源计划起作用</strong>。一个资源计划还可以包含子资源计划。每个资源计划都必须包含给OTHER_GROUP分配支援的指令。</p> 
   <p>例子：一个简单的资源计划</p> 
   <p>   下图显示的是包含OLTP（online transaction processing）应用和报表系统数据库系统的白天的资源分配计划。</p> 
   <p>它为OLTP应用分配75%的CPU时间，为报表系统分配15%的CPU时间，剩下的是为OTHER_GROUPS分配的。<br><br><strong>子资源计划</strong></p> 
   <p>       资源指令除了给组分配资源，还可以为其他资源计划分配资源，被分配资源的计划成为子计划。下图是一个包含子计划的资源计划的例子。</p> 
   <p><strong>DBRM管理的内容</strong></p> 
   <p>       资源分配方法指定资源分配给组或子计划的百分比。DBRM管理的资源包括以下内容：</p> 
   <p>CPU Time</p> 
   <p>Active Session Pool With Queuing</p> 
   <p>       你可以设定某组的最大活动会话数，会话池满后，新的会话会被放入等待队列。</p> 
   <p>Degree Of Parallelism Limit</p> 
   <p>       限制并行运行的会话数。</p> 
   <p>Automatic Consumer Group Switching</p> 
   <p>       此功能类似于触发器机制，当某个会话满足设定的条件，它会自动被分配到其他组中去。</p> 
   <p>Cancelling SQL and Terminating Sessions</p> 
   <p>       DBRM可以取消那些长时间运行的SQL查询或会话活动。</p> 
   <p>Excution Time Limit</p> 
   <p>       DMRM可以估算某个操作的运行时间，如果超过了设定的值，数据库不会执行它。</p> 
   <p>Undo Pool </p> 
   <p>Idle Time Limit</p> 
   <p>      设定一个会话的最长未响应时间。</p> 
   <p>================================================================</p> 
   <p><img src="https://images2.imgbox.com/48/22/WzX5B7L0_o.jpg" alt=""><br>  </p> 
   <p><strong>oracle 资源管理器</strong></p> 
   <p> 一、资源管理器（DRM）由三个要素组成：<br> 资源消费群（resource_consumer_group)<br> 资源计划（resource_plan）<br> 资源计划指令（resource_plan_directive）<br>  <br> 执行与DRM有关的操作，必须具有 administer_resource_manager 系统权限。<br>  <br> 二、未决域（pending area）<br> DRM的三个要素都必须创建在未决域中，然后提交。<br>  <br> 1、创建未决域<br> exec dbms_resource_manager.create_pending_area;<br>  <br> 2、验证未决域<br> exec dbms_resource_manager.validate_pending_area;<br> 验证域中的内容是否合法。<br>  <br> 3、清除未决域<br> exec dbms_resource_manager.clear_pending_area;<br> 执行此命令后，未决域以及未决域中的内容一起被删除。<br>  <br> 4、提交未决域<br> exec dbms_resource_manager.submit_pending_area;<br> 执行此命令后，相当于执行了验证、提交、清除三个命令。未决域中的内容会被存储在数据字典中，等待启用。<br>  <br> 三、资源消费群<br> 一个用户可以隶属于多个消费群，但一个会话同一时间只能隶属于一个消费群。<br> ORACLE 已经预定义了4个消费群：<br>  default_consumer_group ：未分配消费群的用户和会话。<br> other_groups ：当前的资源计划中没有明确指定资源分配所有消费群。任何一个资源计划中都必须包含此群。<br> sys_group 和 low_group ：用于执行系统计划的消费群。<br>  <br> 1、创建、更新、删除消费群（）<br>  创建：<br> exec dbms_resource_manager.create_cosumer_group('群名','注释');<br>  <br> 更新：<br> exec dbms_resource_manager.update_consumer_group('群名','注释');<br>  <br> 删除：<br> exec dbms_resource_manager.delete_consumer_group('群名');<br> 执行此命令后，隶属于此群的用户和会话将自动转到 default_consumer_group.<br>  <br>  2、将用户会话分配给消费群（消费群映射）<br> 可以基于会话的属性将会话动态分配给消费群，成为消费群映射。<br>  <br> （1）设定映射：<br> dbms_resource_manager.set_consumer_group_mapping（<br> attribute =&gt; oracle_user,<br> value =&gt; 'user1,<br> consumer_group =&gt; 'low_group'）；<br>  <br> 如上，当会话的oracle用户属性值为user1时，就将之分配给消费群low_group。<br>  <br> （2）设定映射优先权：<br> 由于可能会出现某会话的两个属性分别满足两个不同的映射规则，那么该服从哪个规则呢？——可以设定各个属性的优先权，服从优先级高的属性。<br> dbms_resource_manager.set_mapping_priority(<br> oracle_user =&gt; 1,<br> client_os_user =&gt; 2);<br>  <br> （3）动态转换会话的消费群<br>  基于会话的唯一标识转换消费群：（会话唯一标识由 session_id 和 session_serial 共同组成，这两个参数的值在 v$session 视图中）。<br> dbms_resource_manager.switch_consumer_group_for_sess(<br> session_id =&gt; '56',<br> session_serial =&gt; '106',<br> consumer_group =&gt; 'low_group');<br>  <br> 基于会话所属的用户转换消费群：（将用户下的所有会话转换消费群）<br> dbms_resource_manager.switch_consumer_group_for_user(<br> user =&gt; 'user1',<br> consumer_group =&gt; 'low_group');<br>  <br> 用户转换自己当前会话的消费群：（使用 dbms_session 包）<br> dbms_session.switch_current_consumer_group(<br> new_consumer_group =&gt; 'low_group');<br>  <br> 转换自己当前会话的消费群需要特定权限：<br> dbms_resource_manager_privs.grant_switch_consumer_group(<br> grantee_name =&gt; 'user1',<br> consumer_group =&gt; 'low_group',<br> grant_option =&gt; 'false');<br>  <br> 撤销此权限：<br> dbms_resource_manager_privs.revoke_switch_consumer_group(<br> grantee_name =&gt; 'user1',<br> consumer_group =&gt; 'low_group');<br>  <br> 四、资源计划<br> 分为简单资源计划和复杂资源计划。<br>  <br> 1、简单资源计划<br> 有如下特点：<br> （1）三要素在一个过程中定义。<br> （2）只能分配cpu资源。<br> （3）只能使用emphasis方式分配cpu资源（即百分比）。<br> （4）分配的消费群最大数为8个。<br>  <br> 创建：<br> dbms_resource_manager.create_simple_plan(<br> simple_plan =&gt; '计划名',<br> consumer_group1 =&gt; '消费群1',<br> group1_cpu =&gt; 50,<br> consumer_group2 =&gt; '消费群2',<br> group2_cpu =&gt; 50);<br>  <br>  <br> 2、复杂资源计划<br> 特点：<br> （1）三要素必须单独创建。<br> （2）可以嵌套子计划。<br>  <br> 创建：<br> dbms_resource_manager.create_plan(<br> plan =&gt; '计划名',<br> comment =&gt; '注释');<br>  <br> 3、修改资源计划：<br> dbms_resource_manager.update_plan(<br> plan =&gt; '计划名',<br> new_属性 =&gt; '新值');<br>  <br> 4、删除资源计划：<br> dbms_resource_manager.delete_plan('计划名'）;<br> 或<br> dbms_resource_manager.delete_plan_cascade('计划名');<br> 加上cascade参数，删除计划内的要素。<br>  <br> 五、计划指令<br>  创建：<br> dbms_resource_manager.create_plan_directive(<br> plan =&gt; '计划名',<br> group_or_subplan =&gt; '消费群或子计划',<br> 资源限制参数);<br>  <br> 注：可以为子计划创建指令，但只能分配cpu资源。<br>  <br> 更新：<br> dbms_resource_manager.update_plan_directive(<br> 两个必需参数,<br> new_属性 =&gt; '新值');<br>  <br> 删除：<br> dbms_resource_manager.delete_plan_directive(<br> 两个必需参数);<br> =================================================================<br><strong>Oracle 11g R1中资源管理器增强-性能调优</strong></p> 
   <p><br>     本文概述了Oracle 11g R1中资源管理器的所有增强内容，包括：</p> 
   <p>    （1） I/O校准</p> 
   <p>    （2） 每会话I/O限制</p> 
   <p>    （3） AWR中的资源管理器统计</p> 
   <p>    （4） 内置资源计划</p> 
   <p>    I/O校准</p> 
   <p>    DBMS_RESOURCE_MANAGER包包括一个CALIBRATE_IO存储过程，它通过执行一个I/O密集的只读工作量来评估数据库服务器的存储系统的I/O性能，这个评估操作应该在非业务高峰期间执行，以确保校准不影响生产的工作量，以及生产的工作量对校准结果的影响。</p> 
   <p>    只有开启了异步I/O时才能使用该存储过程，否则会报下面的错误：</p> 
   <p><br> DECLARE</p> 
   <p>　　*</p> 
   <p>　　ERROR at line 1:</p> 
   <p>　　ORA-56708: Could not find any datafiles with asynchronous i/o capability</p> 
   <p>　　ORA-06512: at "SYS.DBMS_RMIN", line 453</p> 
   <p>　　ORA-06512: at "SYS.DBMS_RESOURCE_MANAGER", line 1153</p> 
   <p>　　ORA-06512: at line 6</p> 
   <p>　　SQL&gt;</p> 
   <p><br>     通过设置参数FILESYSTEMIO_OPTIONS为ASYNC或SETALL来启用异步I/O.</p> 
   <p><br> SQL&gt;SHOW PARAMETER FILESYSTEMIO_OPTIONS</p> 
   <p>　　NAME TYPE VALUE</p> 
   <p>　　----------------------------------------------- -----------------------</p> 
   <p>　　filesystemio_options string none</p> 
   <p>　　SQL&gt;</p> 
   <p>　　SQL&gt;ALTER SYSTEM SET FILESYSTEMIO_OPTIONS=SETALL SCOPE=SPFILE;</p> 
   <p>　　SQL&gt;SHUTDOWN IMMEDIATE;</p> 
   <p>　　SQL&gt;STARTUP;</p> 
   <p>    该CALIBRATE_IO存储过程接受两个参数来指定物理磁盘（默认1）和可承受的最大延迟（默认20ms）的数目，它返回每秒最大数量I/O请求，每秒最大Mb数和真实的延迟。</p> 
   <p><br> SET SERVEROUTPUT ON</p> 
   <p>　　DECLARE</p> 
   <p>　　l_max_iops PLS_INTEGER;</p> 
   <p>　　l_max_mbps PLS_INTEGER;</p> 
   <p>　　l_actual_latency PLS_INTEGER;</p> 
   <p>　　BEGIN</p> 
   <p>　　DBMS_RESOURCE_MANAGER.calibrate_io (</p> 
   <p>　　num_physical_disks =&gt; 1,</p> 
   <p>　　max_latency =&gt; 20,</p> 
   <p>　　max_iops =&gt; l_max_iops,</p> 
   <p>　　max_mbps =&gt; l_max_mbps,</p> 
   <p>　　actual_latency =&gt; l_actual_latency);</p> 
   <p>　　DBMS_OUTPUT.put_line ('l_max_iops = ' || l_max_iops);</p> 
   <p>　　DBMS_OUTPUT.put_line ('l_max_mbps = ' || l_max_mbps);</p> 
   <p>　　DBMS_OUTPUT.put_line ('l_actual_latency = ' || l_actual_latency);</p> 
   <p>　　END;</p> 
   <p>　　/</p> 
   <p>　　l_max_iops = 556</p> 
   <p>　　l_max_mbps = 48</p> 
   <p>　　l_actual_latency = 17</p> 
   <p>　　PL/SQL procedure successfully completed.</p> 
   <p>　　SQL&gt;<br>  </p> 
   <p><br>     同一时间只能执行一个校准操作，在RAC环境中，工作量发起的所有节点都可以执行。</p> 
   <p>    [G]V$IO_CALIBRATION_STATUS视图显示了当前校准运行的状况。在运行过程中，会显示一个'IN PROGRESS' 的状态'.一旦运行完成状态切换到'READY'，并且会显示校准时间。</p> 
   <p><br> SQL&gt; SELECT * FROM v$io_calibration_status;</p> 
   <p>　　STATUS CALIBRATION_TIME</p> 
   <p>　　------------- -------------------------------</p> 
   <p>　　IN PROGRESS</p> 
   <p>　　SQL&gt; SELECT * FROM v$io_calibration_status;</p> 
   <p>　　STATUS CALIBRATION_TIME</p> 
   <p>　　---------------------------------------------------------------------------</p> 
   <p>　　READY 28-JUL-2008 14:37:38.410</p> 
   <p>　　1 row selected.</p> 
   <p>　　SQL&gt;<br>  </p> 
   <p><br>     通过DBA_RSRC_IO_CALIBRATE视图可以显示校准信息。</p> 
   <p><br> SET LINESIZE 150</p> 
   <p>　　COLUMN start_time FORMAT A30</p> 
   <p>　　COLUMN end_time FORMAT A30</p> 
   <p>　　SELECT * FROM dba_rsrc_io_calibrate;</p> 
   <p>　　START_TIME END_TIME MAX_IOPS MAX_MBPS MAX_PMBPS LATENCY NUM_PHYSICAL_DISKS</p> 
   <p>　　----------------- ---------- ---------- ---------- ------------------</p> 
   <p>　　28-JUL-2008 14:32:33.68 28-JUL-2008 14:37:38.40 556 48 48 17 1</p> 
   <p>　　1 row selected.</p> 
   <p>　　SQL&gt;</p> 
   <p><br>     每会话I/O限制</p> 
   <p>    在Oracle之前的版本中，资源组自动切换完全基于单个会话的时间或单个调用的时间，Oracle 11g现在可以基于I/O阀值（最大请求数或M字节）进行资源组自动切换，新的阀值通过CREATE_PLAN_DIRECTIVE存储过程执行，其中包含了大量的改变。</p> 
   <p>    （1） CPU_P1-CPU_P8参数已经废弃，改为使用MGMT_P1-MGMT_P8参数。</p> 
   <p>    （2） SWITCH_TIME_IN_CALL参数已被汰，换作了SWITCH_FOR_CALL参数。</p> 
   <p>    （3） SWITCH_IO_MEGABYTES和SWITCH_IO_REQS参数现在已经可用，此外还有SWITCH_TIME参数，这三个参数默认为NULL，意味着无限制。</p> 
   <p>    新的I/O参数意味着可以切换资源组了，可以基于消耗时间、I/O请求和I/O数量的任何组合来取消SQL或杀死会话，下面的例子显示如果消耗时间超过120秒、I/O请求数量超过5000或I/O请求超过1024M，会将当前会话从资源消耗组oltp_group切换到batch_group组。</p> 
   <p><br> BEGIN</p> 
   <p>　　DBMS_RESOURCE_MANAGER.create_plan_directive (</p> 
   <p>　　plan =&gt; 'my_plan',</p> 
   <p>　　group_or_subplan =&gt; 'oltp_group',</p> 
   <p>　　comment =&gt; 'OLTP Group',</p> 
   <p>　　mgmt_p1 =&gt; 70,</p> 
   <p>　　switch_group =&gt; 'batch_group',</p> 
   <p>　　switch_time =&gt; 120,</p> 
   <p>　　switch_io_reqs =&gt; 5000,</p> 
   <p>　　switch_io_megabytes =&gt; 1024,</p> 
   <p>　　switch_for_call =&gt; TRUE);</p> 
   <p>　　END;</p> 
   <p>　　/</p> 
   <p><br>     下面的例子显示如果I/O资源消耗超过了4096M，会话将会被杀掉。</p> 
   <p><br> BEGIN</p> 
   <p>　　DBMS_RESOURCE_MANAGER.create_plan_directive (</p> 
   <p>　　plan =&gt; 'my_plan',</p> 
   <p>　　group_or_subplan =&gt; 'oltp_group',</p> 
   <p>　　comment =&gt; 'OLTP Group',</p> 
   <p>　　mgmt_p1 =&gt; 70,</p> 
   <p>　　switch_group =&gt; 'KILL_SESSION',</p> 
   <p>　　switch_io_megabytes =&gt; 4096);</p> 
   <p>　　END;</p> 
   <p>　　/</p> 
   <p><br>     AWR中的资源管理器统计</p> 
   <p>    新DBA_HIST_RSRC_PLAN和DBA_HIST_RSRC_CONSUMER_GROUP视图已加入到V$ RSRC_PLAN_HISTORY和V$RSRC_CONS_GROUP_HISTORY视图中，提供了一个历史数据的查看。</p> 
   <p>    V$RSRCMGRMETRIC_HISTORY视图显示取自V$RSRCMGRMETRIC视图的一个小时的数据。</p> 
   <p>    在<a href="http://download.oracle.com/docs/cd/B28359_01/server.111/b28310/dbrm011.htm#ADMIN11916" rel="nofollow">http://download.oracle.com/docs/cd/B28359_01/server.111/b28310/dbrm011.htm#ADMIN11916</a>有完整的资源管理视图介绍。</p> 
   <p><br>     内置资源计划</p> 
   <p>    Oracle 11g包括一个内置的MIXED_WORKLOAD_PLAN资源计划，旨在给的OLTP业务批量操作优先权，这个计划包括两个资源消耗组（INTERACTIVE_GROUP和BATCH_GROUP），如果分配给INTERACTIVE_GROUP组时超过60秒，就会自动切换到BATCH_GROUP组。</p> 
   <p>    RESOURCE_MANAGER_PLAN参数用来告诉实例使用哪个资源计划。</p> 
   <p>    ALTER SYSTEM SET RESOURCE_MANAGER_PLAN = MIXED_WORKLOAD_PLAN；</p> 
   <p>    然后你必须将资源消耗组授权给单个用户，下面的例子显示将两个资源消耗组授权给TEST用户，并指定默认的资源消耗组是INTERACTIVE_GROUP.查询DBA_USERS视图可以获得已经设置好的默认设置。</p> 
   <p><br> BEGIN</p> 
   <p>　　-- Assign users to consumer groups</p> 
   <p>　　DBMS_RESOURCE_MANAGER_PRIVS.grant_switch_consumer_group(</p> 
   <p>　　grantee_name =&gt; 'test',</p> 
   <p>　　consumer_group =&gt; 'interactive_group',</p> 
   <p>　　grant_option =&gt; FALSE);</p> 
   <p>　　DBMS_RESOURCE_MANAGER_PRIVS.grant_switch_consumer_group(</p> 
   <p>　　grantee_name =&gt; 'test',</p> 
   <p>　　consumer_group =&gt; 'batch_group',</p> 
   <p>　　grant_option =&gt; FALSE);</p> 
   <p>　　DBMS_RESOURCE_MANAGER.set_initial_consumer_group('test', 'interactive_group');</p> 
   <p>　　END;</p> 
   <p>　　/</p> 
   <p>　　SELECT initial_rsrc_consumer_group FROM dba_users WHERE username = 'TEST';</p> 
   <p>　　INITIAL_RSRC_CONSUMER_GROUP</p> 
   <p>　　------------------------------</p> 
   <p>　　INTERACTIVE_GROUP</p> 
   <p>　　1 row selected.</p> 
   <p>　　SQL&gt;</p> 
   <p><br>     以TEST用户连接到数据库，查询v$session视图正在工作的资源消耗组。</p> 
   <p><br> CONN test/test</p> 
   <p>　　SELECT resource_consumer_group</p> 
   <p>　　FROM v$session</p> 
   <p>　　WHERE audsid = SYS_CONTEXT('USERENV', 'SESSIONID');</p> 
   <p>　　RESOURCE_CONSUMER_GROUP</p> 
   <p>　　--------------------------------</p> 
   <p>　　INTERACTIVE_GROUP</p> 
   <p>　　1 row selected.</p> 
   <p>　　SQL&gt;</p> 
   <p><br>     如果我们创建一个长时间的调用，可以看到资源消耗组的切换。</p> 
   <p><br> CONN test/test</p> 
   <p>　　SET SERVEROUTPUT ON</p> 
   <p>　　DECLARE</p> 
   <p>　　l_cg v$session.resource_consumer_group%TYPE;</p> 
   <p>　　BEGIN</p> 
   <p>　　SELECT resource_consumer_group</p> 
   <p>　　INTO l_cg</p> 
   <p>　　FROM v$session</p> 
   <p>　　WHERE audsid = SYS_CONTEXT('USERENV', 'SESSIONID');</p> 
   <p>　　DBMS_OUTPUT.put_line('Current Consumer Group: ' || l_cg);</p> 
   <p>　　-- Sleep to cause switch based on time.</p> 
   <p>　　DBMS_LOCK.sleep(65);</p> 
   <p>　　SELECT resource_consumer_group</p> 
   <p>　　INTO l_cg</p> 
   <p>　　FROM v$session</p> 
   <p>　　WHERE audsid = SYS_CONTEXT('USERENV', 'SESSIONID');</p> 
   <p>　　DBMS_OUTPUT.put_line('Current Consumer Group: ' || l_cg);</p> 
   <p>　　END;</p> 
   <p>　　/</p> 
   <p>　　Current Consumer Group: INTERACTIVE_GROUP</p> 
   <p>　　Current Consumer Group: BATCH_GROUP</p> 
   <p>　　PL/SQL procedure successfully completed.</p> 
   <p>　　SQL&gt;</p> 
   <p><br>     正如我们所期望的，调用最初分配的是INTERACTIVE_GROUP资源组，当调用超过60秒时就切换到BATCH_GROUP组了</p> 
  </div> 
 </div> 
</div> 
<p>转载于:https://blog.51cto.com/ccchencheng/938588</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb7dba6e73ab311ac28dca2edabf4e7b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PL/SQL 别名时用中文字符报错ora-00911 或中文乱码解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1708b9f70077146d609db9b22248a92/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ffmpeg安装第三方编码器（encoder）库，ffmpeg编码h264（完）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>