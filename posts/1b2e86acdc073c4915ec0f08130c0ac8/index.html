<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>傅里叶变换及低通滤波再反变换（C&#43;&#43;&amp;&amp;opencv） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="傅里叶变换及低通滤波再反变换（C&#43;&#43;&amp;&amp;opencv）" />
<meta property="og:description" content="对灰度图像做傅里叶变换并进行低通滤波再做傅里叶逆变换。 结果及代码如下： 如上图：mag图表示幅度谱，亮处为低频部分，暗处为高频部分。 #include &lt;iostream&gt; #include &lt;opencv.hpp&gt; #include &lt;opencv2\opencv.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui_c.h&gt; using namespace cv; using namespace std; void FourierTransform(cv::Mat&amp; image) { image.convertTo(image, CV_32F); vector&lt;Mat&gt; channels; split(image, channels); //分离RGB通道 Mat image_B = channels[0]; //选取最适合做fft的宽和高 int m1 = getOptimalDFTSize(image_B.rows); int n1 = getOptimalDFTSize(image_B.cols); Mat padded; //填充 copyMakeBorder(image_B, padded, 0, m1 - image_B.rows, 0, n1 - image_B.cols, BORDER_CONSTANT, Scalar::all(0)); Mat planes[] = { Mat_&lt;float&gt;(padded), Mat::zeros(padded.size(), CV_32F) }; Mat complexI; merge(planes, 2, complexI); //planes[0], planes[1]是实部和虚部 dft(complexI, complexI, DFT_SCALE | DFT_COMPLEX_OUTPUT); split(complexI, planes); //定义幅度谱和相位谱 Mat ph, mag, idft; phase(planes[0], planes[1], ph); magnitude(planes[0], planes[1], mag); //由实部planes[0]和虚部planes[1]得到幅度谱mag和相位谱ph //重新排列傅里叶图像中的象限，使得原点位于图像中心 int cx = mag." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1b2e86acdc073c4915ec0f08130c0ac8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-15T21:37:46+08:00" />
<meta property="article:modified_time" content="2022-04-15T21:37:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">傅里叶变换及低通滤波再反变换（C&#43;&#43;&amp;&amp;opencv）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>对灰度图像做傅里叶变换并进行低通滤波再做傅里叶逆变换。</h2> 
<h4>结果及代码如下：</h4> 
<p><img alt="" height="468" src="https://images2.imgbox.com/bb/83/LEmUXGtT_o.png" width="723"></p> 
<h4> 如上图：mag图表示幅度谱，亮处为低频部分，暗处为高频部分。</h4> 
<pre><code>#include &lt;iostream&gt;
#include &lt;opencv.hpp&gt;
#include &lt;opencv2\opencv.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;    
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui_c.h&gt;

using namespace cv;
using namespace std;

void FourierTransform(cv::Mat&amp; image)
{
	image.convertTo(image, CV_32F);
	vector&lt;Mat&gt; channels;
	split(image, channels);  //分离RGB通道
	Mat image_B = channels[0];
	//选取最适合做fft的宽和高
	int m1 = getOptimalDFTSize(image_B.rows);  
	int n1 = getOptimalDFTSize(image_B.cols);
	Mat padded;
	//填充
	copyMakeBorder(image_B, padded, 0, m1 - image_B.rows, 0, n1 - image_B.cols, BORDER_CONSTANT, Scalar::all(0));
	Mat planes[] = { Mat_&lt;float&gt;(padded), Mat::zeros(padded.size(), CV_32F) };
	Mat complexI;
	merge(planes, 2, complexI);  //planes[0], planes[1]是实部和虚部

	dft(complexI, complexI, DFT_SCALE | DFT_COMPLEX_OUTPUT);
	split(complexI, planes);

	//定义幅度谱和相位谱
	Mat ph, mag, idft;
	phase(planes[0], planes[1], ph);
	magnitude(planes[0], planes[1], mag);  //由实部planes[0]和虚部planes[1]得到幅度谱mag和相位谱ph

	//重新排列傅里叶图像中的象限，使得原点位于图像中心
	int cx = mag.cols / 2;
	int cy = mag.rows / 2;
	Mat q0(mag, Rect(0, 0, cx, cy));       //左上角图像划定ROI区域
	Mat q1(mag, Rect(cx, 0, cx, cy));      //右上角图像
	Mat q2(mag, Rect(0, cy, cx, cy));      //左下角图像
	Mat q3(mag, Rect(cx, cy, cx, cy));     //右下角图像

	//变换左上角和右下角象限
	Mat tmp;
	q0.copyTo(tmp);
	q3.copyTo(q0);
	tmp.copyTo(q3);

	//变换右上角和左下角象限
	q1.copyTo(tmp);
	q2.copyTo(q1);
	tmp.copyTo(q2);

	imshow("mag", mag);

	//低通滤波
	for (int i = 0; i &lt; mag.cols;i++){
		for (int j = 0; j &lt; mag.rows; j++){
			if (abs(i - mag.cols / 2) &gt; mag.cols / 10 || abs(j - mag.rows / 2) &gt; mag.rows / 10)
				mag.at&lt;float&gt;(j, i) = 0;
		}
	}

	imshow("mag2", mag);
	q0.copyTo(tmp);
	q3.copyTo(q0);
	tmp.copyTo(q3);

	//变换右上角和左下角象限
	q1.copyTo(tmp);
	q2.copyTo(q1);
	tmp.copyTo(q2);

	//傅里叶逆变换
	polarToCart(mag, ph, planes[0], planes[1]);  //由幅度谱mag和相位谱ph恢复实部planes[0]和虚部planes[1]
	merge(planes, 2, idft);
	dft(idft, idft, DFT_INVERSE | DFT_REAL_OUTPUT);
	image_B = idft(Rect(0, 0, image.cols &amp; -2, image.rows &amp; -2));
	image_B.copyTo(channels[0]);
	
	merge(channels, image);
	image.convertTo(image, CV_8U);
}


void main()
{
	Mat img = imread("E://dx.jpg");
	cvtColor(img, img, COLOR_BGR2GRAY);
	imshow("src", img);
	FourierTransform(img);
	imshow("DFT img", img);
	waitKey();
	system("pause");
	return ;
}</code></pre> 
<p></p> 
<h4>附鼠标响应的傅里叶变换并滤波代码</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b3/2a/qjsEIZdB_o.gif"></p> 
<p> </p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;opencv.hpp&gt;
#include &lt;opencv2\opencv.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;    
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui_c.h&gt;

using namespace cv;
using namespace std;

struct fft 
{
	Mat img;
	vector&lt;Point2i&gt; filt_points;
	Point2i thisPoint;
	int filt_step;
	Mat src_mag, ph, dst;
	Mat planes[2];
};

void IDFTtransform(Mat&amp; image,Mat&amp; src_mag, Mat&amp; ph, Mat planes[])
{
	imshow("src_mag", src_mag);

	vector&lt;Mat&gt; channels;
	split(image, channels);  //分离RGB通道
	Mat image_B = channels[0];

	int cx = src_mag.cols / 2;
	int cy = src_mag.rows / 2;
	Mat q0(src_mag, Rect(0, 0, cx, cy));       //左上角图像划定ROI区域
	Mat q1(src_mag, Rect(cx, 0, cx, cy));      //右上角图像
	Mat q2(src_mag, Rect(0, cy, cx, cy));      //左下角图像
	Mat q3(src_mag, Rect(cx, cy, cx, cy));     //右下角图像

	//变换左上角和右下角象限
	Mat tmp,idft;
	q0.copyTo(tmp);
	q3.copyTo(q0);
	tmp.copyTo(q3);

	//变换右上角和左下角象限
	q1.copyTo(tmp);
	q2.copyTo(q1);
	tmp.copyTo(q2);

	polarToCart(src_mag, ph, planes[0], planes[1]);  //由幅度谱mag和相位谱ph恢复实部planes[0]和虚部planes[1]
	merge(planes, 2, idft);
	dft(idft, idft, DFT_INVERSE | DFT_REAL_OUTPUT);
	image_B = idft(Rect(0, 0, image.cols &amp; -2, image.rows &amp; -2));
	image_B.copyTo(channels[0]);

	merge(channels, image);
	image.convertTo(image, CV_8U);

	q0.copyTo(tmp);
	q3.copyTo(q0);
	tmp.copyTo(q3);

	//变换右上角和左下角象限
	q1.copyTo(tmp);
	q2.copyTo(q1);
	tmp.copyTo(q2);
	imshow("dst", image);
}

//DFTtransform实现
vector&lt;Mat&gt; DFTtransform(Mat&amp; image, Mat&amp; src_mag, Mat&amp; ph, Mat&amp; dst)
{
	image.convertTo(image, CV_32F);
	vector&lt;Mat&gt; channels;
	split(image, channels);  //分离RGB通道
	Mat image_B = channels[0];
	//expand input image to optimal size
	int m1 = getOptimalDFTSize(image_B.rows);  //选取最适合做fft的宽和高
	int n1 = getOptimalDFTSize(image_B.cols);
	Mat padded;
	//填充0
	copyMakeBorder(image_B, padded, 0, m1 - image_B.rows, 0, n1 - image_B.cols, BORDER_CONSTANT, Scalar::all(0));
	Mat planes[] = { Mat_&lt;float&gt;(padded), Mat::zeros(padded.size(), CV_32F) };
	Mat complexI;
	merge(planes, 2, complexI);  //planes[0], planes[1]是实部和虚部

	dft(complexI, complexI, DFT_SCALE | DFT_COMPLEX_OUTPUT);
	split(complexI, planes);

	//定义幅度谱和相位谱
	Mat  mag, idft;
	phase(planes[0], planes[1], ph);
	magnitude(planes[0], planes[1], src_mag);  //由实部planes[0]和虚部planes[1]得到幅度谱mag和相位谱ph

	//重新排列傅里叶图像中的象限，使得原点位于图像中心
	int cx = src_mag.cols / 2;
	int cy = src_mag.rows / 2;
	Mat q0(src_mag, Rect(0, 0, cx, cy));       //左上角图像划定ROI区域
	Mat q1(src_mag, Rect(cx, 0, cx, cy));      //右上角图像
	Mat q2(src_mag, Rect(0, cy, cx, cy));      //左下角图像
	Mat q3(src_mag, Rect(cx, cy, cx, cy));     //右下角图像

	//变换左上角和右下角象限
	Mat tmp;
	q0.copyTo(tmp);
	q3.copyTo(q0);
	tmp.copyTo(q3);

	//变换右上角和左下角象限
	q1.copyTo(tmp);
	q2.copyTo(q1);
	tmp.copyTo(q2);

	vector&lt;Mat&gt; plane12;
	plane12.push_back(planes[0]);
	plane12.push_back(planes[1]);
	return (plane12);
}

void on_mouse(int event, int x, int y, int flags, void* lst)
{
	fft* temp = (fft*)lst;
	if (event == CV_EVENT_LBUTTONDOWN){
		cout &lt;&lt; "x:" &lt;&lt; x &lt;&lt; " y:" &lt;&lt; y &lt;&lt; endl;
		temp-&gt;thisPoint.x = x;
		temp-&gt;thisPoint.y = y;
		temp-&gt;filt_points.push_back(temp-&gt;thisPoint);
		for (int i = x - 5; i &lt; x + 6;i++){
			for (int j = y - 5; j &lt; y + 6; j++){
				temp-&gt;src_mag.at&lt;float&gt;(j, i) = 0;
			}
		}
		IDFTtransform(temp-&gt;img, temp-&gt;src_mag, temp-&gt;ph, temp-&gt;planes);
		temp-&gt;filt_step++;
	}
}

void main(int event, int x, int y, int flags, void *ustc)
{
	fft lst;
	lst.filt_step=0;
	lst.img = imread("E://dx.jpg");
	cvtColor(lst.img, lst.img, COLOR_BGR2GRAY);
	imshow("src", lst.img);
	vector&lt;Mat&gt; planes12;

	planes12 = DFTtransform(lst.img, lst.src_mag, lst.ph, lst.dst);
	lst.planes[0] = planes12[0]; 
	lst.planes[1] = planes12[1];
	IDFTtransform(lst.img, lst.src_mag, lst.ph, lst.planes);

	Point2i thisPoint;
	setMouseCallback("src_mag", on_mouse, (void*)&amp;lst);

	waitKey();
	system("pause");
	return ;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee129e26da7b54f3256b430969e04aad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">批处理脚本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cbabf68d46be71274696e80d886afb01/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Vivado工具使用技巧】如何快速查看一个工程的器件型号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>