<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【分布式锁】---简单明了 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【分布式锁】---简单明了" />
<meta property="og:description" content="文章目录 介绍分布式锁一、 redis-分布式锁1、redis1.1、处理死锁1.2、处理误删 2、可重入锁3、阶段总结3.1、升级阶段3.2、加锁操作3.3、解锁操作 3、redLock(红锁)4、Redisson4.1、配置4.2、可重入锁4.3、公平锁4.4、连锁、红锁4.5、读写锁4.6、semaphore（信号量）4.7、CountDownLatch（闭锁） 二、zookeeper-分布式锁2.1、实现思路2.2、相关问题2.2.1、防死锁2.2.2、阻塞锁2.2.3、可重入 2.3、Curator2.3.1、可重入锁InterProcessMutex2.3.2、不可重入锁InterProcessSemaphoreMutex2.3.3、可重入读写锁InterProcessReadWriteLock2.3.4、 联锁InterProcessMultiLock2.3.5、信号量InterProcessSemaphoreV2 三、mysql-分布式锁 介绍分布式锁 单机多线程： 在传统的单机服务中，涉及到并发相关的场景，通常使用的 ReetrantLock 类、synchronized 关键字来控制并发，或者是在特殊的场景的，可能会使用Semaphore、CountDownLatch、ReadWriteLock等锁来控制并发访问。
分布式系统： 在分布式系统，如果继续使用传统的锁，不可以满足自己的想要的结果，因为不同的服务/客户端通常运行在独立的 各自的JVM 进程上，多个 JVM 进程共享同一份资源的话，此时就考虑分布式锁。
在一个最基本的分布式锁需要同时满足：
互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了。 分布式锁的常用实现方式
基于 redis 缓存实现分布式锁基于 zookeeper 实现分布式锁基于 mysql 实现分布式锁 三种方式的进行比对：
考虑在性能方面： redis &gt; zookeeper &gt; 数据库
考虑复杂性或者难度： Zookeeper &gt; redis &gt; 数据库
考虑可靠性： Zookeeper &gt; redis = 数据库
一、 redis-分布式锁 1、redis 客户端借助 redis 中的命令 setnx(key value) 该命令作用在创建的值会进行判断，如果该值存在则忽略，不存在则创建。运用到分布式中，多个客户端发送setnx命令，只用一个客户端可以执行成功
存在问题：
死锁 ： 当一个客户端设置成功后，宕机无法释放key，则存在死锁问题；误删 ： 因为锁得名称是一样，就会存在一个客户端执行完，刚好自己设置锁到期了，仍要执行delete操作，此时就会把其他客户端的锁删除掉 1.1、处理死锁 在使用redis客户端 setnx 值的同时可额外添加参数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cbef94b173e53e36c8392680601e102f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-22T22:19:03+08:00" />
<meta property="article:modified_time" content="2023-11-22T22:19:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【分布式锁】---简单明了</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_6" rel="nofollow">介绍分布式锁</a></li><li><a href="#_redis_32" rel="nofollow">一、 redis-分布式锁</a></li><li><ul><li><a href="#1redis_33" rel="nofollow">1、redis</a></li><li><ul><li><a href="#11_43" rel="nofollow">1.1、处理死锁</a></li><li><a href="#12_53" rel="nofollow">1.2、处理误删</a></li></ul> 
   </li><li><a href="#2_90" rel="nofollow">2、可重入锁</a></li><li><a href="#3_137" rel="nofollow">3、阶段总结</a></li><li><ul><li><a href="#31_139" rel="nofollow">3.1、升级阶段</a></li><li><a href="#32_149" rel="nofollow">3.2、加锁操作</a></li><li><a href="#33_160" rel="nofollow">3.3、解锁操作</a></li></ul> 
   </li><li><a href="#3redLock_170" rel="nofollow">3、redLock(红锁)</a></li><li><a href="#4Redisson_184" rel="nofollow">4、Redisson</a></li><li><ul><li><a href="#41_189" rel="nofollow">4.1、配置</a></li><li><a href="#42_207" rel="nofollow">4.2、可重入锁</a></li><li><a href="#43_231" rel="nofollow">4.3、公平锁</a></li><li><a href="#44_250" rel="nofollow">4.4、连锁、红锁</a></li><li><a href="#45_286" rel="nofollow">4.5、读写锁</a></li><li><a href="#46semaphore_309" rel="nofollow">4.6、semaphore（信号量）</a></li><li><a href="#47CountDownLatch_322" rel="nofollow">4.7、CountDownLatch（闭锁）</a></li></ul> 
  </li></ul> 
  </li><li><a href="#zookeeper_336" rel="nofollow">二、zookeeper-分布式锁</a></li><li><ul><li><a href="#21_360" rel="nofollow">2.1、实现思路</a></li><li><a href="#22_369" rel="nofollow">2.2、相关问题</a></li><li><ul><li><a href="#221_370" rel="nofollow">2.2.1、防死锁</a></li><li><a href="#222_372" rel="nofollow">2.2.2、阻塞锁</a></li><li><a href="#223_380" rel="nofollow">2.2.3、可重入</a></li></ul> 
   </li><li><a href="#23Curator_386" rel="nofollow">2.3、Curator</a></li><li><ul><li><a href="#231InterProcessMutex_416" rel="nofollow">2.3.1、可重入锁InterProcessMutex</a></li><li><a href="#232InterProcessSemaphoreMutex_439" rel="nofollow">2.3.2、不可重入锁InterProcessSemaphoreMutex</a></li><li><a href="#233InterProcessReadWriteLock_464" rel="nofollow">2.3.3、可重入读写锁InterProcessReadWriteLock</a></li><li><a href="#234_InterProcessMultiLock_479" rel="nofollow">2.3.4、 联锁InterProcessMultiLock</a></li><li><a href="#235InterProcessSemaphoreV2_495" rel="nofollow">2.3.5、信号量InterProcessSemaphoreV2</a></li></ul> 
  </li></ul> 
  </li><li><a href="#mysql_516" rel="nofollow">三、mysql-分布式锁</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_6"></a>介绍分布式锁</h2> 
<p><strong>单机多线程：</strong> 在传统的单机服务中，涉及到并发相关的场景，通常使用的 ReetrantLock 类、synchronized 关键字来控制并发，或者是在特殊的场景的，可能会使用Semaphore、CountDownLatch、ReadWriteLock等锁来控制并发访问。</p> 
<p><strong>分布式系统</strong>： 在分布式系统，如果继续使用传统的锁，不可以满足自己的想要的结果，因为不同的服务/客户端通常运行在独立的 各自的JVM 进程上，多个 JVM 进程共享同一份资源的话，此时就考虑分布式锁。</p> 
<p>在一个最基本的分布式锁需要同时满足：</p> 
<ul><li>互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；</li><li>高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；</li><li>防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；</li><li>独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了。</li></ul> 
<p><strong>分布式锁的常用实现方式</strong></p> 
<ol><li>基于 redis 缓存实现分布式锁</li><li>基于 zookeeper 实现分布式锁</li><li>基于 mysql 实现分布式锁</li></ol> 
<p>三种方式的进行比对：</p> 
<p>考虑在性能方面： redis &gt; zookeeper &gt; 数据库<br> 考虑复杂性或者难度： Zookeeper &gt; redis &gt; 数据库<br> 考虑可靠性： Zookeeper &gt; redis = 数据库</p> 
<h2><a id="_redis_32"></a>一、 redis-分布式锁</h2> 
<h3><a id="1redis_33"></a>1、redis</h3> 
<p>客户端借助 redis 中的命令 <strong>setnx(key value)</strong> 该命令作用在创建的值会进行判断，如果该值存在则忽略，不存在则创建。运用到分布式中，多个客户端发送setnx命令，只用一个客户端可以执行成功</p> 
<p><img src="https://images2.imgbox.com/cd/dd/zxGKyGET_o.png" alt="在这里插入图片描述"><br> <strong>存在问题：</strong></p> 
<ul><li>死锁 ： 当一个客户端设置成功后，宕机无法释放key，则存在死锁问题；</li><li>误删 ： 因为锁得名称是一样，就会存在一个客户端执行完，刚好自己设置锁到期了，仍要执行delete操作，此时就会把其他客户端的锁删除掉</li></ul> 
<h4><a id="11_43"></a>1.1、处理死锁</h4> 
<p>在使用redis客户端 setnx 值的同时可额外添加参数</p> 
<ul><li>参数一：key</li><li>参数二：value</li><li>参数三：过期时间</li><li>参数四：：时间单位</li></ul> 
<p>此时我们可以原子性的在设置的同时，设置值的过期时间的来防止死锁的问题<br> <img src="https://images2.imgbox.com/85/df/670dKFdX_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f3/93/ys0djFZH_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="12_53"></a>1.2、处理误删</h4> 
<p>存在原因： 因为锁得名称是一样，就会存在一个客户端执行完，刚好自己设置锁到期了，仍要执行delete操作，此时就会把其他客户端的锁删除掉。<br> <img src="https://images2.imgbox.com/f3/75/4Rn73eHD_o.png" alt="在这里插入图片描述"></p> 
<p>处理办法： setnx设置值获取锁的同时，设置的一个当前线程的唯一的值，比如uuid，在释放锁的之前，先进行判断是否释放的是自己的锁。但是存在新的问题，判断和删除锁，无法同时进行，因为redis采用单线程架构，可以保证单个命令的原子性，但是无法保证一组命令在高并发场景下的原子性。总的来说，中间可能存在问题。<br> 只能借助与 lua脚本 进行实现。本文章不介绍，语法相对而言，比较容易理解<br> 在redis中需要通过eval命令执行lua脚本。</p> 
<ul><li>参数一：lua脚本语句</li><li>参数二：值得数量</li><li>参数key： 获取使用 KEYS[1]</li><li>参数arg： 获取使用 ARGV[1]</li></ul> 
<p>EVAL script numkeys key [key …] arg [arg …]</p> 
<pre><code class="prism language-lua">EVAL <span class="token string">"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}"</span> <span class="token number">5</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">30</span> <span class="token number">40</span> <span class="token number">50</span> <span class="token number">60</span> <span class="token number">70</span> <span class="token number">80</span> <span class="token number">90</span>
<span class="token operator">#</span> 输出：<span class="token number">10</span> <span class="token number">20</span> <span class="token number">60</span> <span class="token number">70</span>
</code></pre> 
<p>在代码中使用 redis.call() 来执行lua脚本。</p> 
<pre><code class="prism language-java">        <span class="token comment">//脚本解读：</span>
            <span class="token comment">//获取当前锁:KEYS[1] 是否等于ARGV[1]</span>
            <span class="token comment">//成立，则进行删除 key为 KEYS[1] 得值（锁）</span>
            <span class="token comment">//反之 返回0</span>
            <span class="token comment">//脚本if语句的结束end</span>
        <span class="token class-name">String</span> script <span class="token operator">=</span> <span class="token string">"if redis.call('get', KEYS[1]) == ARGV[1] "</span> <span class="token operator">+</span>
                <span class="token string">"then return redis.call('del', KEYS[1]) "</span> <span class="token operator">+</span>
                <span class="token string">"else return 0 "</span> <span class="token operator">+</span>
                <span class="token string">"end"</span><span class="token punctuation">;</span>
        <span class="token comment">//参数一：lua脚本的，执行结束返回是boolean类型</span>
        <span class="token comment">//参数二：锁的key,用来比对的key为lock的值是否等于 uuid</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>script<span class="token punctuation">,</span><span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Lock"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="2_90"></a>2、可重入锁</h3> 
<p>以上功能实现的是基于redis提供的 SETNX ，一旦键存在就无法再设置成功，无法实现在单机服务中重入锁的功能，一个客户端可以重复获取锁来执行代码逻辑。<br> 解决办法，利用 redis 提供给数据类型 hash（哈希表） 来进行实现可重入功能，通过设置redis hash 存储的重入次数，利用 lua脚本进行实现。<br> ###2.1、加锁代码：</p> 
<pre><code class="prism language-java">        <span class="token comment">//脚本解读</span>
            <span class="token comment">//判断hash是否存在，或者hash值是否等1</span>
            <span class="token comment">//成立则，进行的值+1，同时更新的过期时间</span>
        <span class="token class-name">String</span> script <span class="token operator">=</span> <span class="token string">"if redis.call('exists', KEYS[1]) == 0 or redis.call('hexists', KEYS[1], ARGV[1]) == 1 "</span> <span class="token operator">+</span>
                <span class="token string">"then "</span> <span class="token operator">+</span>
                <span class="token string">"   redis.call('hincrby', KEYS[1], ARGV[1], 1) "</span> <span class="token operator">+</span>
                <span class="token string">"   redis.call('expire', KEYS[1], ARGV[2]) "</span> <span class="token operator">+</span>
                <span class="token string">"   return 1 "</span> <span class="token operator">+</span>
                <span class="token string">"else "</span> <span class="token operator">+</span>
                <span class="token string">"   return 0 "</span> <span class="token operator">+</span>
                <span class="token string">"end"</span><span class="token punctuation">;</span>
        <span class="token comment">//参数一：lua脚本</span>
        <span class="token comment">//参数二：锁名称</span>
        <span class="token comment">//参数key：hash的值</span>
        <span class="token comment">//参数ary：重新设置的过期时间的单位</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>script<span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>lockName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>expire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p>###2.2、解锁代码：</p> 
<pre><code class="prism language-java">        <span class="token comment">//脚本解读</span>
            <span class="token comment">//判断hash是否存在，不存在得返回nil</span>
            <span class="token comment">//判断减1操作后的，值是否等于0，成立则直接删除hash</span>
        <span class="token class-name">String</span> script <span class="token operator">=</span> <span class="token string">"if redis.call('hexists', KEYS[1], ARGV[1]) == 0 "</span> <span class="token operator">+</span>
                <span class="token string">"then "</span> <span class="token operator">+</span>
                <span class="token string">"   return nil "</span> <span class="token operator">+</span>
                <span class="token string">"elseif redis.call('hincrby', KEYS[1], ARGV[1], -1) == 0 "</span> <span class="token operator">+</span>
                <span class="token string">"then "</span> <span class="token operator">+</span>
                <span class="token string">"   return redis.call('del', KEYS[1]) "</span> <span class="token operator">+</span>
                <span class="token string">"else "</span> <span class="token operator">+</span>
                <span class="token string">"   return 0 "</span> <span class="token operator">+</span>
                <span class="token string">"end"</span><span class="token punctuation">;</span>
        <span class="token class-name">Long</span> flag <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>script<span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>lockName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这把锁不是你，乱搞"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3_137"></a>3、阶段总结</h3> 
<h4><a id="31_139"></a>3.1、升级阶段</h4> 
<ol><li>独占排他使用 SETNX</li><li>防死锁发生 ： 如果reids客户端从redis获取到锁之后立马宕机<br> 处理办法：原子性操作，在设置值的同时，设置过期时间</li><li>防误删 ： 删除不是自己锁，导致其他客户端的异常<br> 处理办法：先判断是否自己的锁，才能删除，使用 lua脚本进行实现</li><li>可重入锁：hash + lua脚本</li><li>自动续期： 定时器 + lua脚本</li></ol> 
<h4><a id="32_149"></a>3.2、加锁操作</h4> 
<ol><li>setnx：存在问题 ： 独占排他、死锁、不可重入、原子性</li><li>set key value ex 30 nx ： 存在问题 ： 独占排他、死锁 不可重入</li><li>hash + lua脚本 ： 可重入锁<br> 判断锁是否被占用（exists），如果没有被占用则直接获取锁（hset/hincrby），并设置过期时间（expire）<br> 如果锁占用 ，则判断是否当前线程占用，如果是则重入（hexests）（hincrby）并重置过期时间（expire）<br> 否则获取锁失败，返回标识</li><li>定时器 + lua脚本: 实现锁的自动续期<br> 判断当前锁的，是否是自己的锁（hexists == 1）,如果是自己的锁，expire重置过期时间</li></ol> 
<h4><a id="33_160"></a>3.3、解锁操作</h4> 
<ol><li>delete ： 可以能够造成误删其他客户端的锁</li><li>先判断在删除同时保证原子性：lua脚本</li><li>hash + lua 脚本：可重入<br> 判断当前线程的锁是否存在，不存在则返回nil，将来抛出异常<br> 存在则直接减1（hincrby-1）,判断减1后是否为0，为0则释放锁（del）并返回1<br> 不为0,则返回0</li></ol> 
<p>重试：递归 循环</p> 
<h3><a id="3redLock_170"></a>3、redLock(红锁)</h3> 
<p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在这个样例中，我们假设有5个Redis master节点，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。<br> 为了取到锁，客户端应该执行以下操作:</p> 
<ol><li>获取当前Unix时间，以毫秒为单位。</li><li>应用程序使用相同的kv值，从多个redis实力中获取锁，在获取的同时设置有超时间，如果当前节点超过一定的超时时间依然没有获取到锁，则直接放弃，尽快尝试从下一个健康的redis节点获取锁，以避免被一个宕机的节点阻塞</li><li>计算获取的锁的时间 = 客户端程序的系统当前时间 - step1中的时间。获取锁的消耗时间小于总的锁定时间（30s）并且半数以上节点获取锁成功，认为获取锁成功</li><li>计算剩余锁定时间 = 总的锁定时间 - 第三步的消耗时间</li><li>如果获取锁失败了，针对所有节点进行释放锁操作</li></ol> 
<p>文章暂不重点介绍红锁的实现步骤，知道起作用足以，在开发环境很少使用到的红锁。</p> 
<h3><a id="4Redisson_184"></a>4、Redisson</h3> 
<p>官方文档地址：https://github.com/redisson/redisson/wiki<br> ​ Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务…<br> 详细看官方文档，文章重点使用到的 redisson 中提供的分布式锁</p> 
<h4><a id="41_189"></a>4.1、配置</h4> 
<pre><code class="prism language-java">    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">RedissonClient</span> <span class="token function">redissonConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Config</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"redis://192.168.200.250:6379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//redis 服务地址</span>
<span class="token comment">//                .setDatabase(0)                                             //指定redis数据库编号</span>
<span class="token comment">//                .setUsername("").setPassword("")                            //redis用户名、密码</span>
<span class="token comment">//                .setConnectionMinimumIdleSize(10)                           //线程池最小空闲连接数</span>
<span class="token comment">//                .setConnectionPoolSize(50)                                 //线程池最大连接数</span>
<span class="token comment">//                .setIdleConnectionTimeout(60000)                           //线程超时时间</span>
<span class="token comment">//                .setConnectTimeout(6000)                                   //客户端程序获取redis连接的超时时间</span>
<span class="token comment">//                .setTimeout(6000);                                         //响应超时时间</span>
        <span class="token keyword">return</span> <span class="token class-name">Redisson</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="42_207"></a>4.2、可重入锁</h4> 
<p>基于Redis的Redisson分布式可重入锁RLock 类 实现了 java.util.concurrent.locks.Lock 接口。<br> 如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的<strong>看门狗</strong>，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。</p> 
<p>代码层使用</p> 
<pre><code class="prism language-java">    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">RedissonClient</span> redissonClient<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">void</span> <span class="token function">redisClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 加锁，获取锁失败重试</span>
        <span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//可选参数来指定加锁的时间。超过这个时间后锁便自动解开了。</span>
        
        <span class="token comment">//代码一系列操作........</span>
        
        <span class="token comment">// 释放锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="43_231"></a>4.3、公平锁</h4> 
<p>类似 ReentrantLock 机制，可实现公平和非公平的 锁的设置<br> 它保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待一段时间后才能执行后面线程，以此类推</p> 
<pre><code class="prism language-java">    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">void</span> <span class="token function">redisClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 加锁，获取锁失败重试</span>
        <span class="token class-name">RLock</span> failLock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getFairLock</span><span class="token punctuation">(</span><span class="token string">"failLock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        failLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//代码一系列操作........</span>

        <span class="token comment">// 释放锁</span>
        failLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="44_250"></a>4.4、连锁、红锁</h4> 
<p>连锁 - 基于Redis的Redisson分布式联锁RedissonMultiLock对象可以将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。</p> 
<pre><code class="prism language-java"><span class="token class-name">RLock</span> lock1 <span class="token operator">=</span> redissonInstance1<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">RLock</span> lock2 <span class="token operator">=</span> redissonInstance2<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">RLock</span> lock3 <span class="token operator">=</span> redissonInstance3<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">RedissonMultiLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedissonMultiLock</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">,</span> lock3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 同时加锁：lock1 lock2 lock3</span>
<span class="token comment">// 所有的锁都上锁成功才算成功。</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//代码一系列操作........</span>
 
lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>基于Redis的Redisson红锁RedissonRedLock对象实现了Redlock介绍的加锁算法。该对象也可以用来将多个RLock对象关联为一个红锁，每个RLock对象实例可以来自于不同的Redisson实例</p> 
<pre><code class="prism language-java"><span class="token class-name">RLock</span> lock1 <span class="token operator">=</span> redissonInstance1<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">RLock</span> lock2 <span class="token operator">=</span> redissonInstance2<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">RLock</span> lock3 <span class="token operator">=</span> redissonInstance3<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">RedissonRedLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedissonRedLock</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">,</span> lock3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 同时加锁：lock1 lock2 lock3</span>
<span class="token comment">// 红锁在大部分节点上加锁成功就算成功。</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//代码一系列操作........</span>
 
lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="45_286"></a>4.5、读写锁</h4> 
<p>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。<br> 几种场景：</p> 
<ul><li>A 和 B 同时进行写操作，A抢到锁开始写操作，B需要等待A结束</li><li>A 和 B 同时进行读操作，无需等待，直接读</li><li>A 和 B 前写后读，读需要等待写操作后，才能进行读操作</li><li>A 和 B 前读后写，写需要等待读操作后，才能进行写操作</li></ul> 
<pre><code class="prism language-java">        <span class="token class-name">RReadWriteLock</span> rReadWriteLock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getReadWriteLock</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//读加锁</span>
        rReadWriteLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//读解锁</span>
        rReadWriteLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//写加锁</span>
        rReadWriteLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//写解锁</span>
        rReadWriteLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="46semaphore_309"></a>4.6、semaphore（信号量）</h4> 
<p>限制同时访问的线程数量：通过指定许可证数量来控制同一时间内可以访问某个资源的线程数量。</p> 
<pre><code class="prism language-java">        <span class="token class-name">RSemaphore</span> semaphore <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getSemaphore</span><span class="token punctuation">(</span><span class="token string">"semaphore"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        semaphore<span class="token punctuation">.</span><span class="token function">trySetPermits</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//执行1次</span>
        semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//当 acquire 执行3次后，才能进行加锁</span>
        semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>举一个简单例子，有一个的5车位的停车场，在场地未满之前，任何车辆都可以停用，一旦五个车位被占满的时候，停车场大门关闭，场外车辆无法再次进入，只有等到的场地内的车辆的出来一辆，大门打开，而且只能进来的一辆车，进来后大门再次关闭。以此类推！！</p> 
<h4><a id="47CountDownLatch_322"></a>4.7、CountDownLatch（闭锁）</h4> 
<p>使一个或多个线程等待其他线程完成某个操作后再继续执行。</p> 
<pre><code class="prism language-java">        <span class="token class-name">RCountDownLatch</span> countDownLatch <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getCountDownLatch</span><span class="token punctuation">(</span><span class="token string">"countDownLatch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        countDownLatch<span class="token punctuation">.</span><span class="token function">trySetCount</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//执行1次</span>
        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//当 await 执行3次后，才能进行加锁</span>
        countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>举一个简单例子，路标小摊，买烤冷面，就买5份，买完手工回家，手工等于加锁</p> 
<h2><a id="zookeeper_336"></a>二、zookeeper-分布式锁</h2> 
<p>Zookeeper提供一个多层级的节点命名空间（节点称为znode），每个节点都用一个以斜杠（/）分隔的路径表示，而且每个节点都有父节点（根节点除外），非常类似于文件系统。并且每个节点都是<strong>唯一的</strong>。<br> zookeeper中提供的节点有四种类型，区分： 永久/临时 和 序列化/非序列化</p> 
<ol><li>PERSISTENT： 永久节点，一旦创建成功，出现断开连接情况，节点仍存在； <br> 创建方式： create /lock “Hello Zookeeper”</li><li>EPHEMERAL： 临界节点，创建成功后，出现断开连接情况，节点将会消失；<br> 创建方式： create -e /lock “Hello Zookeeper”</li><li>PERSISTENT_SEQUENTIAL： 永久序列化节点，断开连接仍在，并在创建节点的同时进行顺序编号；<br> 创建方式： create -s /lock “Hello Zookeeper”</li><li>EPHEMERAL_SEQUENTIAL： 临时序列化节点，断开连接消息，并在创建节点的同时进行顺序编号；<br> 创建方式： create -s -e /lock “Hello Zookeeper”</li></ol> 
<p>在Zookeeper分布式锁，同样也使用到了事件的监听，类型Vue中的watch中的监听函数的，但是在的zookeeper中的使用的关键字是 stat 。</p> 
<ul><li>节点创建：stat -w /xx ----&gt;&gt;&gt;&gt; 当监听的/xxx触发时—NodeCreated</li><li>节点删除：stat -w /xx ----&gt;&gt;&gt;&gt; 当监听/xx节点删除时—NodeDelete</li><li>节点数据修改：get -w /xx ----&gt;&gt;&gt;&gt; 当监听/xx节点数据发生变化时—NodeDataChanged</li><li>子节点变更：ls -w /xx ----&gt;&gt;&gt;&gt; 当监听/xx节点的子节点创建或者删除时–NodeChildChanged</li></ul> 
<p>同样Zookeeper也提供了：原生客户端、ZkClient、Curator框架</p> 
<p>代码不再进行编写，类似reids 客户端，进行命令操作客户端的提供的接口，实现zookeeper的特性，</p> 
<h3><a id="21_360"></a>2.1、实现思路</h3> 
<ol><li>获取锁：多个客户端争抢去创建zookeeper节点，创建成功则获取锁</li><li>释放锁：delete节点即可。</li><li>如果没有抢到锁，进行循环重试</li></ol> 
<p>同样需要考虑redis中的出现的各种问题，防死锁、重入问题、防误删、原子性等</p> 
<h3><a id="22_369"></a>2.2、相关问题</h3> 
<h4><a id="221_370"></a>2.2.1、防死锁</h4> 
<p>可以利用的zookeeper提供的 <strong>临时节点</strong> 的特性，当节点的创建成功后，一定那出现的客户点宕机，过一段时间后zookeeper没有收到客户端的心跳则会判断该端会话失效，从而将临时节点进删除。</p> 
<h4><a id="222_372"></a>2.2.2、阻塞锁</h4> 
<p>采用临时序列化节点</p> 
<ul><li>所有请求要求获取锁的同时，给每一个请求创建一个临时序列化节点，</li><li>获取到当前节点的前一个节点，如果前一个节点为空的话，则说明该节点最小，则有限获取锁，否则利用监听机制监听前一个节点的变化</li><li>获取锁成功执行业务操作后，释放当前的节点，此时后一个节点正在监听该节点，则后一个节点开始执行他的相关业务操作<br> 这样操作的同时，同样也实现了公平锁的特征</li></ul> 
<h4><a id="223_380"></a>2.2.3、可重入</h4> 
<ol><li>可以利用在创建节点的同时，利用节点内容存储 标志数据，比如 服务器信息、线程信息、以及重入次数的信息</li><li>借助ThreadLocal，线程的局部，隔离线程间的影响，线程私有记录相关信息</li></ol> 
<h3><a id="23Curator_386"></a>2.3、Curator</h3> 
<p>Curator简化了Zookeeper客户端的开发量。</p> 
<p>通过查看官方文档，可以发现Curator主要解决了三类问题：</p> 
<ol><li>封装ZooKeeper client与ZooKeeper server之间的连接处理</li><li>提供了一套Fluent风格的操作API</li><li>提供ZooKeeper各种应用场景(recipe， 比如：分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等)的抽象封装，这些实现都遵循了zk的最佳实践，并考虑了各种极端情况<br> Curator由一系列的模块构成<br> 常用的是curator-framework和curator-recipes：</li></ol> 
<ul><li>curator-framework：提供了常见的zk相关的底层操作</li><li>curator-recipes：提供了一些zk的典型使用场景的参考。本节重点关注的分布式锁就是该包提供的</li></ul> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CuratorConfig</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">CuratorFramework</span> <span class="token function">curatorFramework</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 重试策略，这里使用的是指数补偿重试策略，重试3次，初始重试间隔1000ms，每次重试之后重试间隔递增。</span>
        <span class="token class-name">RetryPolicy</span> retry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExponentialBackoffRetry</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 初始化Curator客户端：指定链接信息 及 重试策略</span>
        <span class="token class-name">CuratorFramework</span> client <span class="token operator">=</span> <span class="token class-name">CuratorFrameworkFactory</span><span class="token punctuation">.</span><span class="token function">newClient</span><span class="token punctuation">(</span><span class="token string">"172.16.116.100:2181"</span><span class="token punctuation">,</span> retry<span class="token punctuation">)</span><span class="token punctuation">;</span>
        client<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开始链接，如果不调用该方法，很多方法无法工作</span>
        <span class="token keyword">return</span> client<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="231InterProcessMutex_416"></a>2.3.1、可重入锁InterProcessMutex</h4> 
<p>Reentrant和JDK的ReentrantLock类似， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。它是由类InterProcessMutex来实现。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">CuratorFramework</span> curatorFramework<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">checkAndLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token class-name">InterProcessMutex</span> mutex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessMutex</span><span class="token punctuation">(</span>curatorFramework<span class="token punctuation">,</span> <span class="token string">"/locks/lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 加锁</span>
        mutex<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//业务代码逻辑。。。。。。</span>

        <span class="token comment">// 释放锁</span>
        mutex<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="232InterProcessSemaphoreMutex_439"></a>2.3.2、不可重入锁InterProcessSemaphoreMutex</h4> 
<p>具体实现：InterProcessSemaphoreMutex。与InterProcessMutex调用方法类似，区别在于该锁是不可重入的，在同一个线程中不可重入。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">CuratorFramework</span> curatorFramework<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

<span class="token class-name">InterProcessSemaphoreMutex</span> mutex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessSemaphoreMutex</span><span class="token punctuation">(</span>curatorFramework<span class="token punctuation">,</span> <span class="token string">"/locks/lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//加锁</span>
        mutex<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//业务代码逻辑。。。。。。</span>
        
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">//解锁</span>
            mutex<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="233InterProcessReadWriteLock_464"></a>2.3.3、可重入读写锁InterProcessReadWriteLock</h4> 
<p>类似JDK的ReentrantReadWriteLock。一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁。这也意味着写锁可以降级成读锁。从读锁升级成写锁是不成的。主要实现类InterProcessReadWriteLock：</p> 
<pre><code class="prism language-java"><span class="token comment">// 构造方法</span>
<span class="token class-name">InterProcessReadWriteLock</span> rwlock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessReadWriteLock</span><span class="token punctuation">(</span>curatorFramework<span class="token punctuation">,</span> <span class="token string">"/locks/rwlock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取读锁对象</span>
<span class="token class-name">InterProcessMutex</span> <span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 获取写锁对象</span>
<span class="token class-name">InterProcessMutex</span> <span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> 
<h4><a id="234_InterProcessMultiLock_479"></a>2.3.4、 联锁InterProcessMultiLock</h4> 
<p>Multi Shared Lock是一个锁的容器。当调用acquire， 所有的锁都会被acquire，如果请求失败，所有的锁都会被release。同样调用release时所有的锁都被release(失败被忽略)。基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。实现类InterProcessMultiLock</p> 
<pre><code class="prism language-java"><span class="token comment">// 构造函数需要包含的锁的集合，或者一组ZooKeeper的path</span>
<span class="token keyword">public</span> <span class="token class-name">InterProcessMultiLock</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">InterProcessLock</span><span class="token punctuation">&gt;</span></span> locks<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">InterProcessMultiLock</span><span class="token punctuation">(</span><span class="token class-name">CuratorFramework</span> client<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> paths<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取锁</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 释放锁</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="235InterProcessSemaphoreV2_495"></a>2.3.5、信号量InterProcessSemaphoreV2</h4> 
<p>一个计数的信号量类似JDK的Semaphore。JDK中Semaphore维护的一组许可(permits)，而Cubator中称之为租约(Lease)。注意，所有的实例必须使用相同的numberOfLeases值。调用acquire会返回一个租约对象。客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。主要实现类InterProcessSemaphoreV2：</p> 
<pre><code class="prism language-java"><span class="token comment">// 构造方法</span>
<span class="token keyword">public</span> <span class="token class-name">InterProcessSemaphoreV2</span><span class="token punctuation">(</span><span class="token class-name">CuratorFramework</span> client<span class="token punctuation">,</span> <span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token keyword">int</span> maxLeases<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 注意一次你可以请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。</span>
<span class="token comment">// 同时还提供了超时的重载方法</span>
<span class="token keyword">public</span> <span class="token class-name">Lease</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Lease</span><span class="token punctuation">&gt;</span></span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> qty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Lease</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Lease</span><span class="token punctuation">&gt;</span></span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> qty<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>

<span class="token comment">// 租约还可以通过下面的方式返还</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">returnAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Lease</span><span class="token punctuation">&gt;</span></span> leases<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">returnLease</span><span class="token punctuation">(</span><span class="token class-name">Lease</span> lease<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> 
<h2><a id="mysql_516"></a>三、mysql-分布式锁</h2> 
<p>mysql实现分布式锁主要是利用了<strong>唯一键索引</strong>不能重复插入的特点实现。创建一个表后</p> 
<p>实现思路：</p> 
<ol><li>多个客户端执行insert语句，只有一个客户端插入功能，表示获取到锁，进行相关逻辑代码操作</li><li>当业务逻辑执行完毕后，delelte删除该条记录，即为释放锁</li><li>重试，递归</li></ol> 
<p>解决死锁，重入，误删、重入等相关问题<br> 给表中添加对应的字段，每次进行操作的都会进行比对，成功后，则开始执行相关业务逻辑代码</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2adb7f38470dcfa52f0fe28d38eb881d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">I.MX6ULL开发笔记（一）——环境搭建、镜像烧录、网络连接</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/84162bcb89dc386e3891630854a293c0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RK3568平台（环境篇） ubuntu18.04环境搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>