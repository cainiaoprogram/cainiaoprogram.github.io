<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flex, version 2.5 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Flex, version 2.5" />
<meta property="og:description" content="Flex, version 2.5 A fast scanner generator Edition 2.5, March 1995 Vern Paxson Copyright (C) 1990 The Regents of the University of California.All rights reserved.
This code is derived from software contributed to Berkeley byVern Paxson.
The United States Government has rights in this work pursuantto contract no. DE-AC03-76SF00098 between the United StatesDepartment of Energy and the University of California.
Redistribution and use in source and binary forms are permittedprovided that: (1) source distributions retain this entirecopyright notice and comment, and (2) distributions includingbinaries display the following acknowledgement: &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/95d6e82cd154c9214047a8e0dda2b1f6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-04-24T23:05:16+08:00" />
<meta property="article:modified_time" content="2013-04-24T23:05:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flex, version 2.5</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>Flex, version 2.5</h2> 
<h3>A fast scanner generator</h3> 
<h3>Edition 2.5, March 1995</h3> 
<address>Vern Paxson</address> 
<p></p> 
<hr> 
<p></p> 
<p>Copyright (C) 1990 The Regents of the University of California.All rights reserved.</p> 
<p>This code is derived from software contributed to Berkeley byVern Paxson.</p> 
<p>The United States Government has rights in this work pursuantto contract no. DE-AC03-76SF00098 between the United StatesDepartment of Energy and the University of California.</p> 
<p>Redistribution and use in source and binary forms are permittedprovided that: (1) source distributions retain this entirecopyright notice and comment, and (2) distributions includingbinaries display the following acknowledgement: "This productincludes software developed by the University of California,Berkeley and its contributors" in the documentation or othermaterials provided with the distribution and in all advertisingmaterials mentioning features or use of this software. Neither thename of the University nor the names of its contributors may beused to endorse or promote products derived from this softwarewithout specific prior written permission.</p> 
<p>THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS ORIMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIEDWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULARPURPOSE.</p> 
<h3><a name="SEC1" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC1" rel="nofollow">Name</a></h3> 
<p>flex - fast lexical analyzer generator</p> 
<h3><a name="SEC2" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC2" rel="nofollow">Synopsis</a></h3> 
<pre>flex [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]
[--help --version] [<var>filename</var> ...]
</pre> 
<h3><a name="SEC3" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC3" rel="nofollow">Overview</a></h3> 
<p>This manual describes <code>flex</code>, a tool for generating programsthat perform pattern-matching on text. The manualincludes both tutorial and reference sections:</p> 
<dl> 
 
   Description 
  
 <dd>
   a brief overview of the tool 
 </dd> 
 
   Some Simple Examples 
  
 <dd> 
  <br> 
 </dd> 
 
   Format Of The Input File 
  
 <dd> 
  <br> 
 </dd> 
 
   Patterns 
  
 <dd>
   the extended regular expressions used by flex 
 </dd> 
 
   How The Input Is Matched 
  
 <dd>
   the rules for determining what has been matched 
 </dd> 
 
   Actions 
  
 <dd>
   how to specify what to do when a pattern is matched 
 </dd> 
 
   The Generated Scanner 
  
 <dd>
   details regarding the scanner that flex produces;how to control the input source 
 </dd> 
 
   Start Conditions 
  
 <dd>
   introducing context into your scanners, andmanaging "mini-scanners" 
 </dd> 
 
   Multiple Input Buffers 
  
 <dd>
   how to manipulate multiple input sources; how toscan from strings instead of files 
 </dd> 
 
   End-of-file Rules 
  
 <dd>
   special rules for matching the end of the input 
 </dd> 
 
   Miscellaneous Macros 
  
 <dd>
   a summary of macros available to the actions 
 </dd> 
 
   Values Available To The User 
  
 <dd>
   a summary of values available to the actions 
 </dd> 
 
   Interfacing With Yacc 
  
 <dd>
   connecting flex scanners together with yacc parsers 
 </dd> 
 
   Options 
  
 <dd>
   flex command-line options, and the "%option"directive 
 </dd> 
 
   Performance Considerations 
  
 <dd>
   how to make your scanner go as fast as possible 
 </dd> 
 
   Generating C++ Scanners 
  
 <dd>
   the (experimental) facility for generating C++scanner classes 
 </dd> 
 
   Incompatibilities With Lex And POSIX 
  
 <dd>
   how flex differs from AT&amp;T lex and the POSIX lexstandard 
 </dd> 
 
   Diagnostics 
  
 <dd>
   those error messages produced by flex (or scannersit generates) whose meanings might not be apparent 
 </dd> 
 
   Files 
  
 <dd>
   files used by flex 
 </dd> 
 
   Deficiencies / Bugs 
  
 <dd>
   known problems with flex 
 </dd> 
 
   See Also 
  
 <dd>
   other documentation, related tools 
 </dd> 
 
   Author 
  
 <dd>
   includes contact information 
 </dd> 
</dl> 
<h3><a name="SEC4" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC4" rel="nofollow">Description</a></h3> 
<p><code>flex</code> is a tool for generating <strong>scanners</strong>: programs whichrecognized lexical patterns in text. <code>flex</code> reads the giveninput files, or its standard input if no file names aregiven, for a description of a scanner to generate. Thedescription is in the form of pairs of regular expressionsand C code, called <strong>rules</strong>. <code>flex</code> generates as output a Csource file, <tt> `lex.yy.c'</tt>, which defines a routine <samp>`yylex()'</samp>.This file is compiled and linked with the <samp>`-lfl'</samp> library toproduce an executable. When the executable is run, itanalyzes its input for occurrences of the regularexpressions. Whenever it finds one, it executes thecorresponding C code.</p> 
<h3><a name="SEC5" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC5" rel="nofollow">Some simple examples</a></h3> 
<p>First some simple examples to get the flavor of how oneuses <code>flex</code>. The following <code>flex</code> input specifies a scannerwhich whenever it encounters the string "username" willreplace it with the user's login name:</p> 
<pre>%%
username    printf( "%s", getlogin() );
</pre> 
<p>By default, any text not matched by a <code>flex</code> scanner iscopied to the output, so the net effect of this scanner isto copy its input file to its output with each occurrenceof "username" expanded. In this input, there is just onerule. "username" is the <var>pattern</var> and the "printf" is the<var>action</var>. The "%%" marks the beginning of the rules.</p> 
<p>Here's another simple example:</p> 
<pre>        int num_lines = 0, num_chars = 0;

%%
\n      ++num_lines; ++num_chars;
.       ++num_chars;

%%
main()
        {
        yylex();
        printf( "# of lines = %d, # of chars = %d\n",
                num_lines, num_chars );
        }
</pre> 
<p>This scanner counts the number of characters and thenumber of lines in its input (it produces no output otherthan the final report on the counts). The first linedeclares two globals, "num_lines" and "num_chars", whichare accessible both inside <samp>`yylex()'</samp> and in the <samp>`main()'</samp>routine declared after the second "%%". There are two rules,one which matches a newline ("\n") and increments both theline count and the character count, and one which matchesany character other than a newline (indicated by the "."regular expression).</p> 
<p>A somewhat more complicated example:</p> 
<pre>/* scanner for a toy Pascal-like language */

%{
/* need this for the call to atof() below */
#include &lt;math.h&gt;
%}

DIGIT    [0-9]
ID       [a-z][a-z0-9]*

%%

{DIGIT}+    {
            printf( "An integer: %s (%d)\n", yytext,
                    atoi( yytext ) );
            }

{DIGIT}+"."{DIGIT}*        {
            printf( "A float: %s (%g)\n", yytext,
                    atof( yytext ) );
            }

if|then|begin|end|procedure|function        {
            printf( "A keyword: %s\n", yytext );
            }

{ID}        printf( "An identifier: %s\n", yytext );

"+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );

"{"[^}\n]*"}"     /* eat up one-line comments */

[ \t\n]+          /* eat up whitespace */

.           printf( "Unrecognized character: %s\n", yytext );

%%

main( argc, argv )
int argc;
char **argv;
    {
    ++argv, --argc;  /* skip over program name */
    if ( argc &gt; 0 )
            yyin = fopen( argv[0], "r" );
    else
            yyin = stdin;

    yylex();
    }
</pre> 
<p>This is the beginnings of a simple scanner for a languagelike Pascal. It identifies different types of <var>tokens</var> andreports on what it has seen.</p> 
<p>The details of this example will be explained in thefollowing sections.</p> 
<h3><a name="SEC6" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC6" rel="nofollow">Format of the input file</a></h3> 
<p>The <code>flex</code> input file consists of three sections, separatedby a line with just <samp>`%%'</samp> in it:</p> 
<pre>definitions
%%
rules
%%
user code
</pre> 
<p>The <strong>definitions</strong> section contains declarations of simple<strong>name</strong> definitions to simplify the scanner specification,and declarations of <strong>start conditions</strong>, which are explainedin a later section.Name definitions have the form:</p> 
<pre>name definition
</pre> 
<p>The "name" is a word beginning with a letter or anunderscore ('_') followed by zero or more letters, digits, '_',or '-' (dash). The definition is taken to begin at thefirst non-white-space character following the name andcontinuing to the end of the line. The definition cansubsequently be referred to using "{name}", which willexpand to "(definition)". For example,</p> 
<pre>DIGIT    [0-9]
ID       [a-z][a-z0-9]*
</pre> 
<p>defines "DIGIT" to be a regular expression which matches asingle digit, and "ID" to be a regular expression whichmatches a letter followed by zero-or-moreletters-or-digits. A subsequent reference to</p> 
<pre>{DIGIT}+"."{DIGIT}*
</pre> 
<p>is identical to</p> 
<pre>([0-9])+"."([0-9])*
</pre> 
<p>and matches one-or-more digits followed by a '.' followedby zero-or-more digits.</p> 
<p>The <var>rules</var> section of the <code>flex</code> input contains a series ofrules of the form:</p> 
<pre>pattern   action
</pre> 
<p>where the pattern must be unindented and the action mustbegin on the same line.</p> 
<p>See below for a further description of patterns andactions.</p> 
<p>Finally, the user code section is simply copied to<tt>`lex.yy.c'</tt> verbatim. It is used for companion routineswhich call or are called by the scanner. The presence ofthis section is optional; if it is missing, the second <samp>`%%'</samp>in the input file may be skipped, too.</p> 
<p>In the definitions and rules sections, any <em>indented</em> text ortext enclosed in <samp>`%{'</samp> and <samp>`%}'</samp> is copied verbatim to theoutput (with the <samp>`%{}'</samp>'s removed). The <samp>`%{}'</samp>'s mustappear unindented on lines by themselves.</p> 
<p>In the rules section, any indented or %{} text appearingbefore the first rule may be used to declare variableswhich are local to the scanning routine and (after thedeclarations) code which is to be executed whenever thescanning routine is entered. Other indented or %{} textin the rule section is still copied to the output, but itsmeaning is not well-defined and it may well causecompile-time errors (this feature is present for <code>POSIX</code> compliance;see below for other such features).</p> 
<p>In the definitions section (but not in the rules section),an unindented comment (i.e., a line beginning with "/*")is also copied verbatim to the output up to the next "*/".</p> 
<h3><a name="SEC7" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC7" rel="nofollow">Patterns</a></h3> 
<p>The patterns in the input are written using an extendedset of regular expressions. These are:</p> 
<dl> 
  
  <samp>`x'</samp> 
  
 <dd>
   match the character 
  <samp>`x'</samp> 
 </dd> 
  
  <samp>`.'</samp> 
  
 <dd>
   any character (byte) except newline 
 </dd> 
  
  <samp>`[xyz]'</samp> 
  
 <dd>
   a "character class"; in this case, the patternmatches either an 
  <samp>`x'</samp>, a 
  <samp>`y'</samp>, or a 
  <samp>`z'</samp> 
 </dd> 
  
  <samp>`[abj-oZ]'</samp> 
  
 <dd>
   a "character class" with a range in it; matchesan 
  <samp>`a'</samp>, a 
  <samp>`b'</samp>, any letter from 
  <samp>`j'</samp> through 
  <samp>`o'</samp>,or a 
  <samp>`Z'</samp> 
 </dd> 
  
  <samp>`[^A-Z]'</samp> 
  
 <dd>
   a "negated character class", i.e., any characterbut those in the class. In this case, anycharacter EXCEPT an uppercase letter. 
 </dd> 
  
  <samp>`[^A-Z\n]'</samp> 
  
 <dd>
   any character EXCEPT an uppercase letter ora newline 
 </dd> 
  
  <samp>`<var>r</var>*'</samp> 
  
 <dd>
   zero or more 
  <var>r</var>'s, where 
  <var>r</var> is any regular expression 
 </dd> 
  
  <samp>`<var>r</var>+'</samp> 
  
 <dd>
   one or more 
  <var>r</var>'s 
 </dd> 
  
  <samp>`<var>r</var>?'</samp> 
  
 <dd>
   zero or one 
  <var>r</var>'s (that is, "an optional 
  <var>r</var>") 
 </dd> 
  
  <samp>`<var>r</var>{2,5}'</samp> 
  
 <dd>
   anywhere from two to five 
  <var>r</var>'s 
 </dd> 
  
  <samp>`<var>r</var>{2,}'</samp> 
  
 <dd>
   two or more 
  <var>r</var>'s 
 </dd> 
  
  <samp>`<var>r</var>{4}'</samp> 
  
 <dd>
   exactly 4 
  <var>r</var>'s 
 </dd> 
  
  <samp>`{<!-- --><var>name</var>}'</samp> 
  
 <dd>
   the expansion of the " 
  <var>name</var>" definition(see above) 
 </dd> 
  
  <samp>`"[xyz]\"foo"'</samp> 
  
 <dd>
   the literal string: 
  <samp>`[xyz]"foo'</samp> 
 </dd> 
  
  <samp>`\<var>x</var>'</samp> 
  
 <dd>
   if 
  <var>x</var> is an 
  <samp>`a'</samp>, 
  <samp>`b'</samp>, 
  <samp>`f'</samp>, 
  <samp> `n'</samp>, 
  <samp>`r'</samp>, 
  <samp>`t'</samp>, or 
  <samp>`v'</samp>,then the ANSI-C interpretation of \ 
  <var>x</var>.Otherwise, a literal 
  <samp>`<var>x</var>'</samp> (used to escapeoperators such as 
  <samp>`*'</samp>) 
 </dd> 
  
  <samp>`\0'</samp> 
  
 <dd>
   a NUL character (ASCII code 0) 
 </dd> 
  
  <samp>`\123'</samp> 
  
 <dd>
   the character with octal value 123 
 </dd> 
  
  <samp>`\x2a'</samp> 
  
 <dd>
   the character with hexadecimal value 
  <code>2a</code> 
 </dd> 
  
  <samp>`(<var>r</var>)'</samp> 
  
 <dd>
   match an 
  <var>r</var>; parentheses are used to overrideprecedence (see below) 
 </dd> 
  
  <samp>`<var>r</var><var>s</var>'</samp> 
  
 <dd>
   the regular expression 
  <var>r</var> followed by theregular expression 
  <var>s</var>; called "concatenation" 
 </dd> 
  
  <samp>`<var>r</var>|<var>s</var>'</samp> 
  
 <dd>
   either an 
  <var>r</var> or an 
  <var>s</var> 
 </dd> 
  
  <samp>`<var>r</var>/<var>s</var>'</samp> 
  
 <dd>
   an 
  <var>r</var> but only if it is followed by an 
  <var>s</var>. The textmatched by 
  <var>s</var> is included when determining whether this rule isthe 
  <strong>longest match</strong>, but is then returned to the input beforethe action is executed. So the action only sees the text matchedby 
  <var>r</var>. This type of pattern is called 
  <strong>trailing context</strong>.(There are some combinations of 
  <samp>`<var>r</var>/<var>s</var>'</samp> that 
  <code>flex</code>cannot match correctly; see notes in the Deficiencies / Bugs sectionbelow regarding "dangerous trailing context".) 
 </dd> 
  
  <samp>`^<var>r</var>'</samp> 
  
 <dd>
   an 
  <var>r</var>, but only at the beginning of a line (i.e.,which just starting to scan, or right after anewline has been scanned). 
 </dd> 
  
  <samp>`<var>r</var>$'</samp> 
  
 <dd>
   an 
  <var>r</var>, but only at the end of a line (i.e., justbefore a newline). Equivalent to " 
  <var>r</var>/\n".Note that flex's notion of "newline" is exactlywhatever the C compiler used to compile flexinterprets '\n' as; in particular, on some DOSsystems you must either filter out \r's in theinput yourself, or explicitly use 
  <var>r</var>/\r\n for "r$". 
 </dd> 
  
  <samp>`&lt;<var>s</var>&gt;<var>r</var>'</samp> 
  
 <dd>
   an 
  <var>r</var>, but only in start condition 
  <var>s</var> (seebelow for discussion of start conditions)&lt; 
  <var>s1</var>, 
  <var>s2</var>, 
  <var>s3</var>&gt; 
  <var>r</var>same, but in any of start conditions 
  <var>s1</var>, 
  <var>s2</var>, or 
  <var>s3</var> 
 </dd> 
  
  <samp>`&lt;*&gt;<var>r</var>'</samp> 
  
 <dd>
   an 
  <var>r</var> in any start condition, even an exclusive one. 
 </dd> 
  
  <samp>`&lt;&lt;EOF&gt;&gt;'</samp> 
  
 <dd>
   an end-of-file&lt; 
  <var>s1</var>, 
  <var>s2</var>&gt;&lt;&lt;EOF&gt;&gt;an end-of-file when in start condition 
  <var>s1</var> or 
  <var>s2</var> 
 </dd> 
</dl> 
<p>Note that inside of a character class, all regularexpression operators lose their special meaning except escape('\') and the character class operators, '-', ']', and, atthe beginning of the class, '^'.</p> 
<p>The regular expressions listed above are grouped accordingto precedence, from highest precedence at the top tolowest at the bottom. Those grouped together have equalprecedence. For example,</p> 
<pre>foo|bar*
</pre> 
<p>is the same as</p> 
<pre>(foo)|(ba(r*))
</pre> 
<p>since the '*' operator has higher precedence thanconcatenation, and concatenation higher than alternation ('|').This pattern therefore matches <em>either</em> the string "foo" <em>or</em>the string "ba" followed by zero-or-more r's. To match"foo" or zero-or-more "bar"'s, use:</p> 
<pre>foo|(bar)*
</pre> 
<p>and to match zero-or-more "foo"'s-or-"bar"'s:</p> 
<pre>(foo|bar)*
</pre> 
<p>In addition to characters and ranges of characters,character classes can also contain character class<strong>expressions</strong>. These are expressions enclosed inside <samp>`['</samp>: and <samp>`:'</samp>]delimiters (which themselves must appear between the '['and ']' of the character class; other elements may occurinside the character class, too). The valid expressionsare:</p> 
<pre>[:alnum:] [:alpha:] [:blank:]
[:cntrl:] [:digit:] [:graph:]
[:lower:] [:print:] [:punct:]
[:space:] [:upper:] [:xdigit:]
</pre> 
<p>These expressions all designate a set of charactersequivalent to the corresponding standard C <samp>`isXXX'</samp> function. Forexample, <samp>`[:alnum:]'</samp> designates those characters for which<samp>`isalnum()'</samp> returns true - i.e., any alphabetic or numeric.Some systems don't provide <samp>`isblank()'</samp>, so flex defines<samp>`[:blank:]'</samp> as a blank or a tab.</p> 
<p>For example, the following character classes are allequivalent:</p> 
<pre>[[:alnum:]]
[[:alpha:][:digit:]
[[:alpha:]0-9]
[a-zA-Z0-9]
</pre> 
<p>If your scanner is case-insensitive (the <samp>`-i'</samp> flag), then<samp>`[:upper:]'</samp> and <samp>`[:lower:]'</samp> are equivalent to <samp>`[:alpha:]'</samp>.</p> 
<p>Some notes on patterns:</p> 
<ul><li>A negated character class such as the example"[^A-Z]" above <em>will match a newline</em> unless "\n" (or anequivalent escape sequence) is one of thecharacters explicitly present in the negated characterclass (e.g., "[^A-Z\n]"). This is unlike how manyother regular expression tools treat negatedcharacter classes, but unfortunately the inconsistencyis historically entrenched. Matching newlinesmeans that a pattern like [^"]* can match theentire input unless there's another quote in theinput.</li><li>A rule can have at most one instance of trailingcontext (the '/' operator or the '$' operator).The start condition, '^', and "&lt;&lt;EOF&gt;&gt;" patternscan only occur at the beginning of a pattern, and,as well as with '/' and '$', cannot be groupedinside parentheses. A '^' which does not occur atthe beginning of a rule or a '$' which does notoccur at the end of a rule loses its specialproperties and is treated as a normal character.The following are illegal: <pre>foo/bar$
&lt;sc1&gt;foo&lt;sc2&gt;bar
</pre> Note that the first of these, can be written"foo/bar\n".The following will result in '$' or '^' beingtreated as a normal character: <pre>foo|(bar$)
foo|^bar
</pre> If what's wanted is a "foo" or abar-followed-by-a-newline, the following could be used (the special'|' action is explained below): <pre>foo      |
bar$     /* action goes here */
</pre> A similar trick will work for matching a foo or abar-at-the-beginning-of-a-line.</li></ul> 
<h3><a name="SEC8" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC8" rel="nofollow">How the input is matched</a></h3> 
<p>When the generated scanner is run, it analyzes its inputlooking for strings which match any of its patterns. Ifit finds more than one match, it takes the one matchingthe most text (for trailing context rules, this includesthe length of the trailing part, even though it will thenbe returned to the input). If it finds two or morematches of the same length, the rule listed first in the<code>flex</code> input file is chosen.</p> 
<p>Once the match is determined, the text corresponding tothe match (called the <var> token</var>) is made available in theglobal character pointer <code>yytext</code>, and its length in theglobal integer <code>yyleng</code>. The <var>action</var> corresponding to thematched pattern is then executed (a more detaileddescription of actions follows), and then the remaining input isscanned for another match.</p> 
<p>If no match is found, then the <strong>default rule</strong> is executed:the next character in the input is considered matched andcopied to the standard output. Thus, the simplest legal<code>flex</code> input is:</p> 
<pre>%%
</pre> 
<p>which generates a scanner that simply copies its input(one character at a time) to its output.</p> 
<p>Note that <code>yytext</code> can be defined in two different ways:either as a character <em>pointer</em> or as a character <em>array</em>.You can control which definition <code>flex</code> uses by includingone of the special directives <samp>`%pointer'</samp> or <samp>`%array'</samp> in thefirst (definitions) section of your flex input. Thedefault is <samp>`%pointer'</samp>, unless you use the <samp>`-l'</samp> lexcompatibility option, in which case <code>yytext</code> will be an array. Theadvantage of using <samp>`%pointer'</samp> is substantially fasterscanning and no buffer overflow when matching very largetokens (unless you run out of dynamic memory). Thedisadvantage is that you are restricted in how your actions canmodify <code>yytext</code> (see the next section), and calls to the<samp>`unput()'</samp> function destroys the present contents of <code>yytext</code>,which can be a considerable porting headache when movingbetween different <code>lex</code> versions.</p> 
<p>The advantage of <samp>`%array'</samp> is that you can then modify <code>yytext</code>to your heart's content, and calls to <samp>`unput()'</samp> do notdestroy <code>yytext</code> (see below). Furthermore, existing <code>lex</code>programs sometimes access <code>yytext</code> externally usingdeclarations of the form:</p> 
<pre>extern char yytext[];
</pre> 
<p>This definition is erroneous when used with <samp>`%pointer'</samp>, butcorrect for <samp>`%array'</samp>.</p> 
<p><samp>`%array'</samp> defines <code>yytext</code> to be an array of <code>YYLMAX</code> characters,which defaults to a fairly large value. You can changethe size by simply #define'ing <code>YYLMAX</code> to a different valuein the first section of your <code>flex</code> input. As mentionedabove, with <samp>`%pointer'</samp> yytext grows dynamically toaccommodate large tokens. While this means your <samp>`%pointer'</samp> scannercan accommodate very large tokens (such as matching entireblocks of comments), bear in mind that each time thescanner must resize <code>yytext</code> it also must rescan the entiretoken from the beginning, so matching such tokens canprove slow. <code>yytext</code> presently does <em>not</em> dynamically grow ifa call to <samp> `unput()'</samp> results in too much text being pushedback; instead, a run-time error results.</p> 
<p>Also note that you cannot use <samp>`%array'</samp> with C++ scannerclasses (the <code>c++</code> option; see below).</p> 
<h3><a name="SEC9" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC9" rel="nofollow">Actions</a></h3> 
<p>Each pattern in a rule has a corresponding action, whichcan be any arbitrary C statement. The pattern ends at thefirst non-escaped whitespace character; the remainder ofthe line is its action. If the action is empty, then whenthe pattern is matched the input token is simplydiscarded. For example, here is the specification for aprogram which deletes all occurrences of "zap me" from itsinput:</p> 
<pre>%%
"zap me"
</pre> 
<p>(It will copy all other characters in the input to theoutput since they will be matched by the default rule.)</p> 
<p>Here is a program which compresses multiple blanks andtabs down to a single blank, and throws away whitespacefound at the end of a line:</p> 
<pre>%%
[ \t]+        putchar( ' ' );
[ \t]+$       /* ignore this token */
</pre> 
<p>If the action contains a '{', then the action spans tillthe balancing '}' is found, and the action may crossmultiple lines. <code>flex</code> knows about C strings and comments andwon't be fooled by braces found within them, but alsoallows actions to begin with <samp>`%{'</samp> and will consider theaction to be all the text up to the next <samp> `%}'</samp> (regardless ofordinary braces inside the action).</p> 
<p>An action consisting solely of a vertical bar ('|') means"same as the action for the next rule." See below for anillustration.</p> 
<p>Actions can include arbitrary C code, including <code>return</code>statements to return a value to whatever routine called<samp>`yylex()'</samp>. Each time <samp>`yylex()'</samp> is called it continuesprocessing tokens from where it last left off until it eitherreaches the end of the file or executes a return.</p> 
<p>Actions are free to modify <code>yytext</code> except for lengtheningit (adding characters to its end--these will overwritelater characters in the input stream). This however doesnot apply when using <samp>`%array'</samp> (see above); in that case,<code>yytext</code> may be freely modified in any way.</p> 
<p>Actions are free to modify <code>yyleng</code> except they should notdo so if the action also includes use of <samp>`yymore()'</samp> (seebelow).</p> 
<p>There are a number of special directives which can beincluded within an action:</p> 
<ul><li><samp>`ECHO'</samp> copies yytext to the scanner's output.</li><li><code>BEGIN</code> followed by the name of a start conditionplaces the scanner in the corresponding startcondition (see below).</li><li><code>REJECT</code> directs the scanner to proceed on to the"second best" rule which matched the input (or aprefix of the input). The rule is chosen asdescribed above in "How the Input is Matched", and<code>yytext</code> and <code>yyleng</code> set up appropriately. It mayeither be one which matched as much text as theoriginally chosen rule but came later in the <code>flex</code>input file, or one which matched less text. Forexample, the following will both count the words inthe input and call the routine special() whenever"frob" is seen: <pre>        int word_count = 0;
%%

frob        special(); REJECT;
[^ \t\n]+   ++word_count;
</pre> Without the <code>REJECT</code>, any "frob"'s in the input wouldnot be counted as words, since the scanner normallyexecutes only one action per token. Multiple<code>REJECT's</code> are allowed, each one finding the nextbest choice to the currently active rule. Forexample, when the following scanner scans the token"abcd", it will write "abcdabcaba" to the output: <pre>%%
a        |
ab       |
abc      |
abcd     ECHO; REJECT;
.|\n     /* eat up any unmatched character */
</pre> (The first three rules share the fourth's actionsince they use the special '|' action.) <code>REJECT</code> isa particularly expensive feature in terms ofscanner performance; if it is used in <em>any</em> of thescanner's actions it will slow down <em>all</em> of thescanner's matching. Furthermore, <code>REJECT</code> cannot be usedwith the <samp>`-Cf'</samp> or <samp>`-CF'</samp> options (see below).Note also that unlike the other special actions,<code>REJECT</code> is a <em>branch</em>; code immediately following itin the action will <em>not</em> be executed.</li><li><samp>`yymore()'</samp> tells the scanner that the next time itmatches a rule, the corresponding token should be<em>appended</em> onto the current value of <code>yytext</code> ratherthan replacing it. For example, given the input"mega-kludge" the following will write"mega-mega-kludge" to the output: <pre>%%
mega-    ECHO; yymore();
kludge   ECHO;
</pre> First "mega-" is matched and echoed to the output.Then "kludge" is matched, but the previous "mega-"is still hanging around at the beginning of <code>yytext</code>so the <samp>`ECHO'</samp> for the "kludge" rule will actuallywrite "mega-kludge".</li></ul> 
<p>Two notes regarding use of <samp>`yymore()'</samp>. First, <samp>`yymore()'</samp>depends on the value of <code>yyleng</code> correctly reflecting thesize of the current token, so you must not modify <code>yyleng</code>if you are using <samp>`yymore()'</samp>. Second, the presence of<samp>`yymore()'</samp> in the scanner's action entails a minorperformance penalty in the scanner's matching speed.</p> 
<ul><li><samp>`yyless(n)'</samp> returns all but the first <var>n</var> characters ofthe current token back to the input stream, wherethey will be rescanned when the scanner looks forthe next match. <code>yytext</code> and <code>yyleng</code> are adjustedappropriately (e.g., <code> yyleng</code> will now be equal to <var>n</var>). For example, on the input "foobar" thefollowing will write out "foobarbar": <pre>%%
foobar    ECHO; yyless(3);
[a-z]+    ECHO;
</pre> An argument of 0 to <code>yyless</code> will cause the entirecurrent input string to be scanned again. Unlessyou've changed how the scanner will subsequentlyprocess its input (using <code>BEGIN</code>, for example), thiswill result in an endless loop.Note that <code> yyless</code> is a macro and can only be used in theflex input file, not from other source files.</li><li><samp>`unput(c)'</samp> puts the character <code>c</code> back onto the inputstream. It will be the next character scanned.The following action will take the current tokenand cause it to be rescanned enclosed inparentheses. <pre>{
int i;
/* Copy yytext because unput() trashes yytext */
char *yycopy = strdup( yytext );
unput( ')' );
for ( i = yyleng - 1; i &gt;= 0; --i )
    unput( yycopy[i] );
unput( '(' );
free( yycopy );
}
</pre> Note that since each <samp>`unput()'</samp> puts the givencharacter back at the <em> beginning</em> of the input stream,pushing back strings must be done back-to-front.An important potential problem when using <samp>`unput()'</samp> is thatif you are using <samp>`%pointer'</samp> (the default), a call to <samp>`unput()'</samp><em>destroys</em> the contents of <code>yytext</code>, starting with itsrightmost character and devouring one character to the leftwith each call. If you need the value of yytext preservedafter a call to <samp>`unput()'</samp> (as in the above example), youmust either first copy it elsewhere, or build your scannerusing <samp>`%array'</samp> instead (see How The Input Is Matched).Finally, note that you cannot put back <code>EOF</code> to attempt tomark the input stream with an end-of-file.</li><li><samp>`input()'</samp> reads the next character from the inputstream. For example, the following is one way toeat up C comments: <pre>%%
"/*"        {
            register int c;

            for ( ; ; )
                {
                while ( (c = input()) != '*' &amp;&amp;
                        c != EOF )
                    ;    /* eat up text of comment */

                if ( c == '*' )
                    {
                    while ( (c = input()) == '*' )
                        ;
                    if ( c == '/' )
                        break;    /* found the end */
                    }

                if ( c == EOF )
                    {
                    error( "EOF in comment" );
                    break;
                    }
                }
            }
</pre> (Note that if the scanner is compiled using <samp>`C++'</samp>,then <samp>`input()'</samp> is instead referred to as <samp>`yyinput()'</samp>,in order to avoid a name clash with the <samp>`C++'</samp> streamby the name of <code>input</code>.)</li><li>YY_FLUSH_BUFFERflushes the scanner's internal buffer so that the next time the scannerattempts to match a token, it will first refill the buffer using<code>YY_INPUT</code> (see The Generated Scanner, below). This action isa special case of the more general <samp>`yy_flush_buffer()'</samp> function,described below in the section Multiple Input Buffers.</li><li><samp>`yyterminate()'</samp> can be used in lieu of a returnstatement in an action. It terminates the scannerand returns a 0 to the scanner's caller, indicating"all done". By default, <samp>`yyterminate()'</samp> is alsocalled when an end-of-file is encountered. It is amacro and may be redefined.</li></ul> 
<h3><a name="SEC10" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC10" rel="nofollow">The generated scanner</a></h3> 
<p>The output of <code>flex</code> is the file <tt>`lex.yy.c'</tt>, which containsthe scanning routine <samp>`yylex()'</samp>, a number of tables used byit for matching tokens, and a number of auxiliary routinesand macros. By default, <samp>`yylex()'</samp> is declared as follows:</p> 
<pre>int yylex()
    {
    ... various definitions and the actions in here ...
    }
</pre> 
<p>(If your environment supports function prototypes, then itwill be "int yylex( void )".) This definition may bechanged by defining the "YY_DECL" macro. For example, youcould use:</p> 
<pre>#define YY_DECL float lexscan( a, b ) float a, b;
</pre> 
<p>to give the scanning routine the name <code>lexscan</code>, returning afloat, and taking two floats as arguments. Note that ifyou give arguments to the scanning routine using aK&amp;R-style/non-prototyped function declaration, you mustterminate the definition with a semi-colon (<samp>`;'</samp>).</p> 
<p>Whenever <samp>`yylex()'</samp> is called, it scans tokens from theglobal input file <code>yyin</code> (which defaults to stdin). Itcontinues until it either reaches an end-of-file (at whichpoint it returns the value 0) or one of its actionsexecutes a <code>return</code> statement.</p> 
<p>If the scanner reaches an end-of-file, subsequent calls are undefinedunless either <code>yyin</code> is pointed at a new input file (in which casescanning continues from that file), or <samp>`yyrestart()'</samp> is called.<samp>`yyrestart()'</samp> takes one argument, a <samp>`FILE *'</samp> pointer (whichcan be nil, if you've set up <code>YY_INPUT</code> to scan from a sourceother than <code>yyin</code>), and initializes <code>yyin</code> for scanning fromthat file. Essentially there is no difference between just assigning<code>yyin</code> to a new input file or using <samp>`yyrestart()'</samp> to do so;the latter is available for compatibility with previous versions of<code>flex</code>, and because it can be used to switch input files in themiddle of scanning. It can also be used to throw away the currentinput buffer, by calling it with an argument of <code>yyin</code>; butbetter is to use <code>YY_FLUSH_BUFFER</code> (see above). Note that<samp>`yyrestart()'</samp> does <em>not</em> reset the start condition to<code>INITIAL</code> (see Start Conditions, below).</p> 
<p>If <samp>`yylex()'</samp> stops scanning due to executing a <code>return</code>statement in one of the actions, the scanner may then be calledagain and it will resume scanning where it left off.</p> 
<p>By default (and for purposes of efficiency), the scanneruses block-reads rather than simple <samp>`getc()'</samp> calls to readcharacters from <code>yyin</code>. The nature of how it gets its inputcan be controlled by defining the <code>YY_INPUT</code> macro.YY_INPUT's calling sequence is"YY_INPUT(buf,result,max_size)". Its action is to placeup to <var>max_size</var> characters in the character array <var>buf</var> andreturn in the integer variable <var>result</var> either the number ofcharacters read or the constant YY_NULL (0 on Unixsystems) to indicate EOF. The default YY_INPUT reads fromthe global file-pointer "yyin".</p> 
<p>A sample definition of YY_INPUT (in the definitionssection of the input file):</p> 
<pre>%{
#define YY_INPUT(buf,result,max_size) \
    { \
    int c = getchar(); \
    result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
    }
%}
</pre> 
<p>This definition will change the input processing to occurone character at a time.</p> 
<p>When the scanner receives an end-of-file indication fromYY_INPUT, it then checks the <samp>`yywrap()'</samp> function. If<samp>`yywrap()'</samp> returns false (zero), then it is assumed that thefunction has gone ahead and set up <code>yyin</code> to point toanother input file, and scanning continues. If it returnstrue (non-zero), then the scanner terminates, returning 0to its caller. Note that in either case, the startcondition remains unchanged; it does <em>not</em> revert to <code>INITIAL</code>.</p> 
<p>If you do not supply your own version of <samp>`yywrap()'</samp>, then youmust either use <samp>`%option noyywrap'</samp> (in which case the scannerbehaves as though <samp> `yywrap()'</samp> returned 1), or you must link with<samp>`-lfl'</samp> to obtain the default version of the routine, which alwaysreturns 1.</p> 
<p>Three routines are available for scanning from in-memorybuffers rather than files: <samp>`yy_scan_string()'</samp>,<samp>`yy_scan_bytes()'</samp>, and <samp>`yy_scan_buffer()'</samp>. See the discussionof them below in the section Multiple Input Buffers.</p> 
<p>The scanner writes its <samp>`ECHO'</samp> output to the <code>yyout</code> global(default, stdout), which may be redefined by the usersimply by assigning it to some other <code>FILE</code> pointer.</p> 
<h3><a name="SEC11" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC11" rel="nofollow">Start conditions</a></h3> 
<p><code>flex</code> provides a mechanism for conditionally activatingrules. Any rule whose pattern is prefixed with "&lt;sc&gt;"will only be active when the scanner is in the startcondition named "sc". For example,</p> 
<pre>&lt;STRING&gt;[^"]*        { /* eat up the string body ... */
            ...
            }
</pre> 
<p>will be active only when the scanner is in the "STRING"start condition, and</p> 
<pre>&lt;INITIAL,STRING,QUOTE&gt;\.        { /* handle an escape ... */
            ...
            }
</pre> 
<p>will be active only when the current start condition iseither "INITIAL", "STRING", or "QUOTE".</p> 
<p>Start conditions are declared in the definitions (first)section of the input using unindented lines beginning witheither <samp>`%s'</samp> or <samp>`%x'</samp> followed by a list of names. The formerdeclares <em>inclusive</em> start conditions, the latter <em>exclusive</em>start conditions. A start condition is activated usingthe <code>BEGIN</code> action. Until the next <code>BEGIN</code> action isexecuted, rules with the given start condition will be activeand rules with other start conditions will be inactive.If the start condition is <em>inclusive</em>, then rules with nostart conditions at all will also be active. If it is<em>exclusive</em>, then <em>only</em> rules qualified with the startcondition will be active. A set of rules contingent on thesame exclusive start condition describe a scanner which isindependent of any of the other rules in the <code>flex</code> input.Because of this, exclusive start conditions make it easyto specify "mini-scanners" which scan portions of theinput that are syntactically different from the rest(e.g., comments).</p> 
<p>If the distinction between inclusive and exclusive startconditions is still a little vague, here's a simpleexample illustrating the connection between the two. The setof rules:</p> 
<pre>%s example
%%

&lt;example&gt;foo   do_something();

bar            something_else();
</pre> 
<p>is equivalent to</p> 
<pre>%x example
%%

&lt;example&gt;foo   do_something();

&lt;INITIAL,example&gt;bar    something_else();
</pre> 
<p>Without the <samp>`&lt;INITIAL,example&gt;'</samp> qualifier, the <samp>`bar'</samp> patternin the second example wouldn't be active (i.e., couldn't match) whenin start condition <samp>`example'</samp>. If we just used <samp>`&lt;example&gt;'</samp>to qualify <samp> `bar'</samp>, though, then it would only be active in<samp>`example'</samp> and not in <code>INITIAL</code>, while in the first exampleit's active in both, because in the first example the <samp>`example'</samp>starting condition is an <em>inclusive</em> (<samp>`%s'</samp>) start condition.</p> 
<p>Also note that the special start-condition specifier <samp>`&lt;*&gt;'</samp>matches every start condition. Thus, the above examplecould also have been written;</p> 
<pre>%x example
%%

&lt;example&gt;foo   do_something();

&lt;*&gt;bar    something_else();
</pre> 
<p>The default rule (to <samp>`ECHO'</samp> any unmatched character) remainsactive in start conditions. It is equivalent to:</p> 
<pre>&lt;*&gt;.|\\n     ECHO;
</pre> 
<p><samp>`BEGIN(0)'</samp> returns to the original state where only therules with no start conditions are active. This state canalso be referred to as the start-condition "INITIAL", so<samp>`BEGIN(INITIAL)'</samp> is equivalent to <samp>`BEGIN(0)'</samp>. (Theparentheses around the start condition name are not required butare considered good style.)</p> 
<p><code>BEGIN</code> actions can also be given as indented code at thebeginning of the rules section. For example, thefollowing will cause the scanner to enter the "SPECIAL" startcondition whenever <samp>`yylex()'</samp> is called and the globalvariable <code>enter_special</code> is true:</p> 
<pre>        int enter_special;

%x SPECIAL
%%
        if ( enter_special )
            BEGIN(SPECIAL);

&lt;SPECIAL&gt;blahblahblah
...more rules follow...
</pre> 
<p>To illustrate the uses of start conditions, here is ascanner which provides two different interpretations of astring like "123.456". By default it will treat it as asthree tokens, the integer "123", a dot ('.'), and theinteger "456". But if the string is preceded earlier inthe line by the string "expect-floats" it will treat it asa single token, the floating-point number 123.456:</p> 
<pre>%{
#include &lt;math.h&gt;
%}
%s expect

%%
expect-floats        BEGIN(expect);

&lt;expect&gt;[0-9]+"."[0-9]+      {
            printf( "found a float, = %f\n",
                    atof( yytext ) );
            }
&lt;expect&gt;\n           {
            /* that's the end of the line, so
             * we need another "expect-number"
             * before we'll recognize any more
             * numbers
             */
            BEGIN(INITIAL);
            }

[0-9]+      {

Version 2.5               December 1994                        18

            printf( "found an integer, = %d\n",
                    atoi( yytext ) );
            }

"."         printf( "found a dot\n" );
</pre> 
<p>Here is a scanner which recognizes (and discards) Ccomments while maintaining a count of the current input line.</p> 
<pre>%x comment
%%
        int line_num = 1;

"/*"         BEGIN(comment);

&lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
&lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
&lt;comment&gt;\n             ++line_num;
&lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
</pre> 
<p>This scanner goes to a bit of trouble to match as muchtext as possible with each rule. In general, whenattempting to write a high-speed scanner try to match asmuch possible in each rule, as it's a big win.</p> 
<p>Note that start-conditions names are really integer valuesand can be stored as such. Thus, the above could beextended in the following fashion:</p> 
<pre>%x comment foo
%%
        int line_num = 1;
        int comment_caller;

"/*"         {
             comment_caller = INITIAL;
             BEGIN(comment);
             }

...

&lt;foo&gt;"/*"    {
             comment_caller = foo;
             BEGIN(comment);
             }

&lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
&lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
&lt;comment&gt;\n             ++line_num;
&lt;comment&gt;"*"+"/"        BEGIN(comment_caller);
</pre> 
<p>Furthermore, you can access the current start conditionusing the integer-valued <code>YY_START</code> macro. For example, theabove assignments to <code>comment_caller</code> could instead bewritten</p> 
<pre>comment_caller = YY_START;
</pre> 
<p>Flex provides <code>YYSTATE</code> as an alias for <code>YY_START</code> (since thatis what's used by AT&amp;T <code>lex</code>).</p> 
<p>Note that start conditions do not have their ownname-space; %s's and %x's declare names in the same fashion as#define's.</p> 
<p>Finally, here's an example of how to match C-style quotedstrings using exclusive start conditions, includingexpanded escape sequences (but not including checking fora string that's too long):</p> 
<pre>%x str

%%
        char string_buf[MAX_STR_CONST];
        char *string_buf_ptr;

\"      string_buf_ptr = string_buf; BEGIN(str);

&lt;str&gt;\"        { /* saw closing quote - all done */
        BEGIN(INITIAL);
        *string_buf_ptr = '\0';
        /* return string constant token type and
         * value to parser
         */
        }

&lt;str&gt;\n        {
        /* error - unterminated string constant */
        /* generate error message */
        }

&lt;str&gt;\\[0-7]{1,3} {
        /* octal escape sequence */
        int result;

        (void) sscanf( yytext + 1, "%o", &amp;result );

        if ( result &gt; 0xff )
                /* error, constant is out-of-bounds */

        *string_buf_ptr++ = result;
        }

&lt;str&gt;\\[0-9]+ {
        /* generate error - bad escape sequence; something
         * like '\48' or '\0777777'
         */
        }

&lt;str&gt;\\n  *string_buf_ptr++ = '\n';
&lt;str&gt;\\t  *string_buf_ptr++ = '\t';
&lt;str&gt;\\r  *string_buf_ptr++ = '\r';
&lt;str&gt;\\b  *string_buf_ptr++ = '\b';
&lt;str&gt;\\f  *string_buf_ptr++ = '\f';

&lt;str&gt;\\(.|\n)  *string_buf_ptr++ = yytext[1];

&lt;str&gt;[^\\\n\"]+        {
        char *yptr = yytext;

        while ( *yptr )
                *string_buf_ptr++ = *yptr++;
        }
</pre> 
<p>Often, such as in some of the examples above, you wind upwriting a whole bunch of rules all preceded by the samestart condition(s). Flex makes this a little easier andcleaner by introducing a notion of start condition <strong>scope</strong>.A start condition scope is begun with:</p> 
<pre>&lt;SCs&gt;{
</pre> 
<p>where SCs is a list of one or more start conditions.Inside the start condition scope, every rule automaticallyhas the prefix <samp>`&lt;SCs&gt;'</samp> applied to it, until a <samp>`}'</samp> whichmatches the initial <samp>`{'</samp>. So, for example,</p> 
<pre>&lt;ESC&gt;{
    "\\n"   return '\n';
    "\\r"   return '\r';
    "\\f"   return '\f';
    "\\0"   return '\0';
}
</pre> 
<p>is equivalent to:</p> 
<pre>&lt;ESC&gt;"\\n"  return '\n';
&lt;ESC&gt;"\\r"  return '\r';
&lt;ESC&gt;"\\f"  return '\f';
&lt;ESC&gt;"\\0"  return '\0';
</pre> 
<p>Start condition scopes may be nested.</p> 
<p>Three routines are available for manipulating stacks ofstart conditions:</p> 
<dl> 
  
  <samp>`void yy_push_state(int new_state)'</samp> 
  
 <dd>
   pushes the current start condition onto the top ofthe start condition stack and switches to 
  <var>new_state</var>as though you had used 
  <samp>`BEGIN new_state'</samp> (recall thatstart condition names are also integers). 
 </dd> 
  
  <samp>`void yy_pop_state()'</samp> 
  
 <dd>
   pops the top of the stack and switches to it via 
  <code>BEGIN</code>. 
 </dd> 
  
  <samp>`int yy_top_state()'</samp> 
  
 <dd>
   returns the top of the stack without altering thestack's contents. 
 </dd> 
</dl> 
<p>The start condition stack grows dynamically and so has nobuilt-in size limitation. If memory is exhausted, programexecution aborts.</p> 
<p>To use start condition stacks, your scanner must include a<samp>`%option stack'</samp> directive (see Options below).</p> 
<h3><a name="SEC12" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC12" rel="nofollow">Multiple input buffers</a></h3> 
<p>Some scanners (such as those which support "include"files) require reading from several input streams. As<code>flex</code> scanners do a large amount of buffering, one cannotcontrol where the next input will be read from by simplywriting a <code>YY_INPUT</code> which is sensitive to the scanningcontext. <code>YY_INPUT</code> is only called when the scanner reachesthe end of its buffer, which may be a long time afterscanning a statement such as an "include" which requiresswitching the input source.</p> 
<p>To negotiate these sorts of problems, <code>flex</code> provides amechanism for creating and switching between multipleinput buffers. An input buffer is created by using:</p> 
<pre>YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
</pre> 
<p>which takes a <code>FILE</code> pointer and a size and creates a bufferassociated with the given file and large enough to hold<var>size</var> characters (when in doubt, use <code>YY_BUF_SIZE</code> for thesize). It returns a <code>YY_BUFFER_STATE</code> handle, which maythen be passed to other routines (see below). The<code>YY_BUFFER_STATE</code> type is a pointer to an opaque <code>struct</code><code>yy_buffer_state</code> structure, so you may safely initializeYY_BUFFER_STATE variables to <samp>`((YY_BUFFER_STATE) 0)'</samp> if youwish, and also refer to the opaque structure in order tocorrectly declare input buffers in source files other thanthat of your scanner. Note that the <code>FILE</code> pointer in thecall to <code>yy_create_buffer</code> is only used as the value of <code>yyin</code>seen by <code>YY_INPUT</code>; if you redefine <code>YY_INPUT</code> so it no longeruses <code>yyin</code>, then you can safely pass a nil <code>FILE</code> pointer to<code>yy_create_buffer</code>. You select a particular buffer to scanfrom using:</p> 
<pre>void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
</pre> 
<p>switches the scanner's input buffer so subsequent tokenswill come from <var>new_buffer</var>. Note that<samp>`yy_switch_to_buffer()'</samp> may be used by <samp>`yywrap()'</samp> to setthings up for continued scanning, instead of opening a newfile and pointing <code>yyin</code> at it. Note also that switchinginput sources via either <samp>`yy_switch_to_buffer()'</samp> or <samp>`yywrap()'</samp>does <em>not</em> change the start condition.</p> 
<pre>void yy_delete_buffer( YY_BUFFER_STATE buffer )
</pre> 
<p>is used to reclaim the storage associated with a buffer.You can also clear the current contents of a buffer using:</p> 
<pre>void yy_flush_buffer( YY_BUFFER_STATE buffer )
</pre> 
<p>This function discards the buffer's contents, so the next time thescanner attempts to match a token from the buffer, it will first fillthe buffer anew using <code>YY_INPUT</code>.</p> 
<p><samp>`yy_new_buffer()'</samp> is an alias for <samp>`yy_create_buffer()'</samp>,provided for compatibility with the C++ use of <code>new</code> and <code>delete</code>for creating and destroying dynamic objects.</p> 
<p>Finally, the <code>YY_CURRENT_BUFFER</code> macro returns a<code>YY_BUFFER_STATE</code> handle to the current buffer.</p> 
<p>Here is an example of using these features for writing ascanner which expands include files (the <samp>`&lt;&lt;EOF&gt;&gt;'</samp> featureis discussed below):</p> 
<pre>/* the "incl" state is used for picking up the name
 * of an include file
 */
%x incl

%{
#define MAX_INCLUDE_DEPTH 10
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
int include_stack_ptr = 0;
%}

%%
include             BEGIN(incl);

[a-z]+              ECHO;
[^a-z\n]*\n?        ECHO;

&lt;incl&gt;[ \t]*      /* eat the whitespace */
&lt;incl&gt;[^ \t\n]+   { /* got the include file name */
        if ( include_stack_ptr &gt;= MAX_INCLUDE_DEPTH )
            {
            fprintf( stderr, "Includes nested too deeply" );
            exit( 1 );
            }

        include_stack[include_stack_ptr++] =
            YY_CURRENT_BUFFER;

        yyin = fopen( yytext, "r" );

        if ( ! yyin )
            error( ... );

        yy_switch_to_buffer(
            yy_create_buffer( yyin, YY_BUF_SIZE ) );

        BEGIN(INITIAL);
        }

&lt;&lt;EOF&gt;&gt; {
        if ( --include_stack_ptr &lt; 0 )
            {
            yyterminate();
            }

        else
            {
            yy_delete_buffer( YY_CURRENT_BUFFER );
            yy_switch_to_buffer(
                 include_stack[include_stack_ptr] );
            }
        }
</pre> 
<p>Three routines are available for setting up input buffersfor scanning in-memory strings instead of files. All ofthem create a new input buffer for scanning the string,and return a corresponding <code>YY_BUFFER_STATE</code> handle (whichyou should delete with <samp>`yy_delete_buffer()'</samp> when done withit). They also switch to the new buffer using<samp>`yy_switch_to_buffer()'</samp>, so the next call to <samp>`yylex()'</samp> willstart scanning the string.</p> 
<dl> 
  
  <samp>`yy_scan_string(const char *str)'</samp> 
  
 <dd>
   scans a NUL-terminated string. 
 </dd> 
  
  <samp>`yy_scan_bytes(const char *bytes, int len)'</samp> 
  
 <dd>
   scans 
  <code>len</code> bytes (including possibly NUL's) startingat location 
  <var> bytes</var>. 
 </dd> 
</dl> 
<p>Note that both of these functions create and scan a <em>copy</em>of the string or bytes. (This may be desirable, since<samp>`yylex()'</samp> modifies the contents of the buffer it isscanning.) You can avoid the copy by using:</p> 
<dl> 
  
  <samp>`yy_scan_buffer(char *base, yy_size_t size)'</samp> 
  
 <dd>
   which scans in place the buffer starting at 
  <var>base</var>,consisting of 
  <var> size</var> bytes, the last two bytes ofwhich 
  <em>must</em> be 
  <code>YY_END_OF_BUFFER_CHAR</code> (ASCII NUL).These last two bytes are not scanned; thus,scanning consists of 
  <samp>`base[0]'</samp> through 
  <samp>`base[size-2]'</samp>,inclusive.If you fail to set up 
  <var>base</var> in this manner (i.e.,forget the final two 
  <code>YY_END_OF_BUFFER_CHAR</code> bytes),then 
  <samp>`yy_scan_buffer()'</samp> returns a nil pointer insteadof creating a new input buffer.The type 
  <code>yy_size_t</code> is an integral type to which youcan cast an integer expression reflecting the sizeof the buffer. 
 </dd> 
</dl> 
<h3><a name="SEC13" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC13" rel="nofollow">End-of-file rules</a></h3> 
<p>The special rule "&lt;&lt;EOF&gt;&gt;" indicates actions which are tobe taken when an end-of-file is encountered and yywrap()returns non-zero (i.e., indicates no further files toprocess). The action must finish by doing one of fourthings:</p> 
<ul><li>assigning <code>yyin</code> to a new input file (in previousversions of flex, after doing the assignment youhad to call the special action <code>YY_NEW_FILE</code>; this isno longer necessary);</li><li>executing a <code>return</code> statement;</li><li>executing the special <samp>`yyterminate()'</samp> action;</li><li>or, switching to a new buffer using<samp>`yy_switch_to_buffer()'</samp> as shown in the exampleabove.</li></ul> 
<p>&lt;&lt;EOF&gt;&gt; rules may not be used with other patterns; theymay only be qualified with a list of start conditions. Ifan unqualified &lt;&lt;EOF&gt;&gt; rule is given, it applies to <em>all</em>start conditions which do not already have &lt;&lt;EOF&gt;&gt;actions. To specify an &lt;&lt;EOF&gt;&gt; rule for only the initialstart condition, use</p> 
<pre>&lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;
</pre> 
<p>These rules are useful for catching things like unclosedcomments. An example:</p> 
<pre>%x quote
%%

...other rules for dealing with quotes...

&lt;quote&gt;&lt;&lt;EOF&gt;&gt;   {
         error( "unterminated quote" );
         yyterminate();
         }
&lt;&lt;EOF&gt;&gt;  {
         if ( *++filelist )
             yyin = fopen( *filelist, "r" );
         else
            yyterminate();
         }
</pre> 
<h3><a name="SEC14" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC14" rel="nofollow">Miscellaneous macros</a></h3> 
<p>The macro <code>YY_USER_ACTION</code> can be defined to provide anaction which is always executed prior to the matchedrule's action. For example, it could be #define'd to calla routine to convert yytext to lower-case. When<code>YY_USER_ACTION</code> is invoked, the variable <code>yy_act</code> gives thenumber of the matched rule (rules are numbered startingwith 1). Suppose you want to profile how often each ofyour rules is matched. The following would do the trick:</p> 
<pre>#define YY_USER_ACTION ++ctr[yy_act]
</pre> 
<p>where <code>ctr</code> is an array to hold the counts for the differentrules. Note that the macro <code>YY_NUM_RULES</code> gives the total numberof rules (including the default rule, even if you use <samp>`-s'</samp>, soa correct declaration for <code>ctr</code> is:</p> 
<pre>int ctr[YY_NUM_RULES];
</pre> 
<p>The macro <code>YY_USER_INIT</code> may be defined to provide an actionwhich is always executed before the first scan (and beforethe scanner's internal initializations are done). Forexample, it could be used to call a routine to read in adata table or open a logging file.</p> 
<p>The macro <samp>`yy_set_interactive(is_interactive)'</samp> can be usedto control whether the current buffer is considered<em>interactive</em>. An interactive buffer is processed more slowly,but must be used when the scanner's input source is indeedinteractive to avoid problems due to waiting to fillbuffers (see the discussion of the <samp> `-I'</samp> flag below). Anon-zero value in the macro invocation marks the buffer asinteractive, a zero value as non-interactive. Note thatuse of this macro overrides <samp>`%option always-interactive'</samp> or<samp>`%option never-interactive'</samp> (see Options below).<samp>`yy_set_interactive()'</samp> must be invoked prior to beginning toscan the buffer that is (or is not) to be consideredinteractive.</p> 
<p>The macro <samp>`yy_set_bol(at_bol)'</samp> can be used to controlwhether the current buffer's scanning context for the nexttoken match is done as though at the beginning of a line.A non-zero macro argument makes rules anchored with</p> 
<p>The macro <samp>`YY_AT_BOL()'</samp> returns true if the next tokenscanned from the current buffer will have '^' rulesactive, false otherwise.</p> 
<p>In the generated scanner, the actions are all gathered inone large switch statement and separated using <code>YY_BREAK</code>,which may be redefined. By default, it is simply a"break", to separate each rule's action from the followingrule's. Redefining <code>YY_BREAK</code> allows, for example, C++users to #define YY_BREAK to do nothing (while being verycareful that every rule ends with a "break" or a"return"!) to avoid suffering from unreachable statementwarnings where because a rule's action ends with "return",the <code>YY_BREAK</code> is inaccessible.</p> 
<h3><a name="SEC15" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC15" rel="nofollow">Values available to the user</a></h3> 
<p>This section summarizes the various values available tothe user in the rule actions.</p> 
<ul><li><samp>`char *yytext'</samp> holds the text of the current token.It may be modified but not lengthened (you cannotappend characters to the end).If the special directive <samp>`%array'</samp> appears in thefirst section of the scanner description, then<code>yytext</code> is instead declared <samp>`char yytext[YYLMAX]'</samp>,where <code>YYLMAX</code> is a macro definition that you canredefine in the first section if you don't like thedefault value (generally 8KB). Using <samp>`%array'</samp>results in somewhat slower scanners, but the valueof <code>yytext</code> becomes immune to calls to <samp>`input()'</samp> and<samp>`unput()'</samp>, which potentially destroy its value when<code>yytext</code> is a character pointer. The opposite of<samp>`%array'</samp> is <samp>`%pointer'</samp>, which is the default.You cannot use <samp>`%array'</samp> when generating C++ scannerclasses (the <samp>`-+'</samp> flag).</li><li><samp>`int yyleng'</samp> holds the length of the current token.</li><li><samp>`FILE *yyin'</samp> is the file which by default <code>flex</code> readsfrom. It may be redefined but doing so only makessense before scanning begins or after an EOF hasbeen encountered. Changing it in the midst ofscanning will have unexpected results since <code>flex</code>buffers its input; use <samp>`yyrestart()'</samp> instead. Oncescanning terminates because an end-of-file has beenseen, you can assign <code>yyin</code> at the new input file andthen call the scanner again to continue scanning.</li><li><samp>`void yyrestart( FILE *new_file )'</samp> may be called topoint <code>yyin</code> at the new input file. The switch-overto the new file is immediate (any previouslybuffered-up input is lost). Note that calling<samp>`yyrestart()'</samp> with <code>yyin</code> as an argument thus throwsaway the current input buffer and continuesscanning the same input file.</li><li><samp>`FILE *yyout'</samp> is the file to which <samp>`ECHO'</samp> actions aredone. It can be reassigned by the user.</li><li><code>YY_CURRENT_BUFFER</code> returns a <code>YY_BUFFER_STATE</code> handleto the current buffer.</li><li><code>YY_START</code> returns an integer value corresponding tothe current start condition. You can subsequentlyuse this value with <code>BEGIN</code> to return to that startcondition.</li></ul> 
<h3><a name="SEC16" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC16" rel="nofollow">Interfacing with <code>yacc</code></a></h3> 
<p>One of the main uses of <code>flex</code> is as a companion to the <code>yacc</code>parser-generator. <code>yacc</code> parsers expect to call a routinenamed <samp>`yylex()'</samp> to find the next input token. The routineis supposed to return the type of the next token as wellas putting any associated value in the global <code>yylval</code>. Touse <code>flex</code> with <code>yacc</code>, one specifies the <samp>`-d'</samp> option to <code>yacc</code> toinstruct it to generate the file <tt> `y.tab.h'</tt> containingdefinitions of all the <samp>`%tokens'</samp> appearing in the <code>yacc</code> input.This file is then included in the <code>flex</code> scanner. Forexample, if one of the tokens is "TOK_NUMBER", part of thescanner might look like:</p> 
<pre>%{
#include "y.tab.h"
%}

%%

[0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;
</pre> 
<h3><a name="SEC17" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC17" rel="nofollow">Options</a></h3> 
<p><code>flex</code> has the following options:</p> 
<dl> 
  
  <samp>`-b'</samp> 
  
 <dd>
   Generate backing-up information to 
  <tt>`lex.backup'</tt>.This is a list of scanner states which requirebacking up and the input characters on which theydo so. By adding rules one can remove backing-upstates. If 
  <em>all</em> backing-up states are eliminatedand 
  <samp>`-Cf'</samp> or 
  <samp>`-CF'</samp> is used, the generated scanner willrun faster (see the 
  <samp>`-p'</samp> flag). Only users who wishto squeeze every last cycle out of their scannersneed worry about this option. (See the section onPerformance Considerations below.) 
 </dd> 
  
  <samp>`-c'</samp> 
  
 <dd>
   is a do-nothing, deprecated option included forPOSIX compliance. 
 </dd> 
  
  <samp>`-d'</samp> 
  
 <dd>
   makes the generated scanner run in 
  <strong>debug</strong> mode.Whenever a pattern is recognized and the global 
  <code>yy_flex_debug</code> is non-zero (which is the default),the scanner will write to 
  <code>stderr</code> a line of theform: 
  <pre>--accepting rule at line 53 ("the matched text")
</pre> The line number refers to the location of the rulein the file defining the scanner (i.e., the filethat was fed to flex). Messages are also generatedwhen the scanner backs up, accepts the defaultrule, reaches the end of its input buffer (orencounters a NUL; at this point, the two look thesame as far as the scanner's concerned), or reachesan end-of-file. 
 </dd> 
  
  <samp>`-f'</samp> 
  
 <dd>
   specifies 
  <strong>fast scanner</strong>. No table compression isdone and stdio is bypassed. The result is largebut fast. This option is equivalent to 
  <samp>`-Cfr'</samp> (seebelow). 
 </dd> 
  
  <samp>`-h'</samp> 
  
 <dd>
   generates a "help" summary of 
  <code>flex's</code> options to 
  <code>stdout</code> and then exits. 
  <samp>`-?'</samp> and 
  <samp>`--help'</samp> are synonymsfor 
  <samp>`-h'</samp>. 
 </dd> 
  
  <samp>`-i'</samp> 
  
 <dd>
   instructs 
  <code>flex</code> to generate a 
  <em>case-insensitive</em>scanner. The case of letters given in the 
  <code>flex</code> inputpatterns will be ignored, and tokens in the inputwill be matched regardless of case. The matchedtext given in 
  <code>yytext</code> will have the preserved case(i.e., it will not be folded). 
 </dd> 
  
  <samp>`-l'</samp> 
  
 <dd>
   turns on maximum compatibility with the originalAT&amp;T 
  <code>lex</code> implementation. Note that this does notmean 
  <em>full</em> compatibility. Use of this option costsa considerable amount of performance, and it cannotbe used with the 
  <samp>`-+, -f, -F, -Cf'</samp>, or 
  <samp>`-CF'</samp> options.For details on the compatibilities it provides, seethe section "Incompatibilities With Lex And POSIX"below. This option also results in the name 
  <code>YY_FLEX_LEX_COMPAT</code> being #define'd in the generatedscanner. 
 </dd> 
  
  <samp>`-n'</samp> 
  
 <dd>
   is another do-nothing, deprecated option includedonly for POSIX compliance. 
 </dd> 
  
  <samp>`-p'</samp> 
  
 <dd>
   generates a performance report to stderr. Thereport consists of comments regarding features ofthe 
  <code>flex</code> input file which will cause a serious lossof performance in the resulting scanner. If yougive the flag twice, you will also get commentsregarding features that lead to minor performancelosses.Note that the use of 
  <code>REJECT</code>, 
  <samp>`%option yylineno'</samp> andvariable trailing context (see the Deficiencies / Bugs section below)entails a substantial performance penalty; use of 
  <samp>`yymore()'</samp>,the 
  <samp>`^'</samp> operator, and the 
  <samp>`-I'</samp> flag entail minor performancepenalties. 
 </dd> 
  
  <samp>`-s'</samp> 
  
 <dd>
   causes the 
  <strong>default rule</strong> (that unmatched scannerinput is echoed to 
  <code>stdout</code>) to be suppressed. Ifthe scanner encounters input that does not matchany of its rules, it aborts with an error. Thisoption is useful for finding holes in a scanner'srule set. 
 </dd> 
  
  <samp>`-t'</samp> 
  
 <dd>
   instructs 
  <code>flex</code> to write the scanner it generates tostandard output instead of 
  <tt>`lex.yy.c'</tt>. 
 </dd> 
  
  <samp>`-v'</samp> 
  
 <dd>
   specifies that 
  <code>flex</code> should write to 
  <code>stderr</code> asummary of statistics regarding the scanner itgenerates. Most of the statistics are meaningless tothe casual 
  <code>flex</code> user, but the first line identifiesthe version of 
  <code>flex</code> (same as reported by 
  <samp>`-V'</samp>), andthe next line the flags used when generating thescanner, including those that are on by default. 
 </dd> 
  
  <samp>`-w'</samp> 
  
 <dd>
   suppresses warning messages. 
 </dd> 
  
  <samp>`-B'</samp> 
  
 <dd>
   instructs 
  <code>flex</code> to generate a 
  <em>batch</em> scanner, theopposite of 
  <em>interactive</em> scanners generated by 
  <samp>`-I'</samp>(see below). In general, you use 
  <samp>`-B'</samp> when you are 
  <em>certain</em> that your scanner will never be usedinteractively, and you want to squeeze a 
  <em>little</em> moreperformance out of it. If your goal is instead tosqueeze out a 
  <em>lot</em> more performance, you should beusing the 
  <samp>`-Cf'</samp> or 
  <samp> `-CF'</samp> options (discussed below),which turn on 
  <samp>`-B'</samp> automatically anyway. 
 </dd> 
  
  <samp>`-F'</samp> 
  
 <dd>
   specifies that the 
  <strong>fast</strong> scanner tablerepresentation should be used (and stdio bypassed). Thisrepresentation is about as fast as the full tablerepresentation 
  <samp>`(-f)'</samp>, and for some sets of patternswill be considerably smaller (and for others,larger). In general, if the pattern set containsboth "keywords" and a catch-all, "identifier" rule,such as in the set: 
  <pre>"case"    return TOK_CASE;
"switch"  return TOK_SWITCH;
...
"default" return TOK_DEFAULT;
[a-z]+    return TOK_ID;
</pre> then you're better off using the full tablerepresentation. If only the "identifier" rule ispresent and you then use a hash table or some such todetect the keywords, you're better off using 
  <samp>`-F'</samp>.This option is equivalent to 
  <samp>`-CFr'</samp> (see below). Itcannot be used with 
  <samp>`-+'</samp>. 
 </dd> 
  
  <samp>`-I'</samp> 
  
 <dd>
   instructs 
  <code>flex</code> to generate an 
  <em>interactive</em> scanner.An interactive scanner is one that only looks aheadto decide what token has been matched if itabsolutely must. It turns out that always looking oneextra character ahead, even if the scanner hasalready seen enough text to disambiguate thecurrent token, is a bit faster than only looking aheadwhen necessary. But scanners that always lookahead give dreadful interactive performance; forexample, when a user types a newline, it is notrecognized as a newline token until they enter 
  <em>another</em> token, which often means typing in anotherwhole line. 
  <code>Flex</code> scanners default to 
  <em>interactive</em> unless you usethe 
  <samp>`-Cf'</samp> or 
  <samp>`-CF'</samp> table-compression options (seebelow). That's because if you're looking forhigh-performance you should be using one of theseoptions, so if you didn't, 
  <code>flex</code> assumes you'drather trade off a bit of run-time performance forintuitive interactive behavior. Note also that you 
  <em>cannot</em> use 
  <samp>`-I'</samp> in conjunction with 
  <samp>`-Cf'</samp> or 
  <samp>`-CF'</samp>.Thus, this option is not really needed; it is on bydefault for all those cases in which it is allowed.You can force a scanner to 
  <em>not</em> be interactive byusing 
  <samp>`-B'</samp> (see above). 
 </dd> 
  
  <samp>`-L'</samp> 
  
 <dd>
   instructs 
  <code>flex</code> not to generate 
  <samp>`#line'</samp> directives.Without this option, 
  <code>flex</code> peppers the generatedscanner with #line directives so error messages inthe actions will be correctly located with respectto either the original 
  <code>flex</code> input file (if theerrors are due to code in the input file), or 
  <tt>`lex.yy.c'</tt> (if the errors are 
  <code>flex's</code> fault -- youshould report these sorts of errors to the emailaddress given below). 
 </dd> 
  
  <samp>`-T'</samp> 
  
 <dd>
   makes 
  <code>flex</code> run in 
  <code>trace</code> mode. It will generate alot of messages to 
  <code>stderr</code> concerning the form ofthe input and the resultant non-deterministic anddeterministic finite automata. This option ismostly for use in maintaining 
  <code>flex</code>. 
 </dd> 
  
  <samp>`-V'</samp> 
  
 <dd>
   prints the version number to 
  <code>stdout</code> and exits. 
  <samp>`--version'</samp> is a synonym for 
  <samp>`-V'</samp>. 
 </dd> 
  
  <samp>`-7'</samp> 
  
 <dd>
   instructs 
  <code>flex</code> to generate a 7-bit scanner, i.e.,one which can only recognized 7-bit characters inits input. The advantage of using 
  <samp>`-7'</samp> is that thescanner's tables can be up to half the size ofthose generated using the 
  <samp>`-8'</samp> option (see below).The disadvantage is that such scanners often hangor crash if their input contains an 8-bitcharacter.Note, however, that unless you generate yourscanner using the 
  <samp>`-Cf'</samp> or 
  <samp>`-CF'</samp> table compression options,use of 
  <samp>`-7'</samp> will save only a small amount of tablespace, and make your scanner considerably lessportable. 
  <code>Flex's</code> default behavior is to generatean 8-bit scanner unless you use the 
  <samp>`-Cf'</samp> or 
  <samp>`-CF'</samp>, inwhich case 
  <code>flex</code> defaults to generating 7-bitscanners unless your site was always configured togenerate 8-bit scanners (as will often be the casewith non-USA sites). You can tell whether flexgenerated a 7-bit or an 8-bit scanner by inspectingthe flag summary in the 
  <samp>`-v'</samp> output as describedabove.Note that if you use 
  <samp>`-Cfe'</samp> or 
  <samp>`-CFe'</samp> (those tablecompression options, but also using equivalenceclasses as discussed see below), flex stilldefaults to generating an 8-bit scanner, sinceusually with these compression options full 8-bittables are not much more expensive than 7-bittables. 
 </dd> 
  
  <samp>`-8'</samp> 
  
 <dd>
   instructs 
  <code>flex</code> to generate an 8-bit scanner, i.e.,one which can recognize 8-bit characters. Thisflag is only needed for scanners generated using 
  <samp>`-Cf'</samp> or 
  <samp>`-CF'</samp>, as otherwise flex defaults togenerating an 8-bit scanner anyway.See the discussion of 
  <samp>`-7'</samp> above for flex's defaultbehavior and the tradeoffs between 7-bit and 8-bitscanners. 
 </dd> 
  
  <samp>`-+'</samp> 
  
 <dd>
   specifies that you want flex to generate a C++scanner class. See the section on Generating C++Scanners below for details. 
 </dd> 
  
  <samp>`-C[aefFmr]'</samp> 
  
 <dd>
   controls the degree of table compression and, moregenerally, trade-offs between small scanners andfast scanners. 
  <samp>`-Ca'</samp> ("align") instructs flex to trade off largertables in the generated scanner for fasterperformance because the elements of the tables are betteraligned for memory access and computation. On someRISC architectures, fetching and manipulatinglong-words is more efficient than with smaller-sizedunits such as shortwords. This option can doublethe size of the tables used by your scanner. 
  <samp>`-Ce'</samp> directs 
  <code>flex</code> to construct 
  <strong>equivalence classes</strong>,i.e., sets of characters which have identicallexical properties (for example, if the only appearanceof digits in the 
  <code>flex</code> input is in the characterclass "[0-9]" then the digits '0', '1', ..., '9'will all be put in the same equivalence class).Equivalence classes usually give dramaticreductions in the final table/object file sizes(typically a factor of 2-5) and are pretty cheapperformance-wise (one array look-up per characterscanned). 
  <samp>`-Cf'</samp> specifies that the 
  <em>full</em> scanner tables shouldbe generated - 
  <code>flex</code> should not compress the tablesby taking advantages of similar transitionfunctions for different states. 
  <samp>`-CF'</samp> specifies that the alternate fast scannerrepresentation (described above under the 
  <samp>`-F'</samp> flag)should be used. This option cannot be used with 
  <samp>`-+'</samp>. 
  <samp>`-Cm'</samp> directs 
  <code>flex</code> to construct 
  <strong>meta-equivalenceclasses</strong>, which are sets of equivalence classes (orcharacters, if equivalence classes are not beingused) that are commonly used together.Meta-equivalence classes are often a big win when usingcompressed tables, but they have a moderateperformance impact (one or two "if" tests and one arraylook-up per character scanned). 
  <samp>`-Cr'</samp> causes the generated scanner to 
  <em>bypass</em> use ofthe standard I/O library (stdio) for input.Instead of calling 
  <samp>`fread()'</samp> or 
  <samp>`getc()'</samp>, the scannerwill use the 
  <samp>`read()'</samp> system call, resulting in aperformance gain which varies from system tosystem, but in general is probably negligible unlessyou are also using 
  <samp>`-Cf'</samp> or 
  <samp>`-CF'</samp>. Using 
  <samp>`-Cr'</samp> can causestrange behavior if, for example, you read from 
  <code>yyin</code> using stdio prior to calling the scanner(because the scanner will miss whatever text yourprevious reads left in the stdio input buffer). 
  <samp>`-Cr'</samp> has no effect if you define 
  <code>YY_INPUT</code> (see TheGenerated Scanner above).A lone 
  <samp>`-C'</samp> specifies that the scanner tables shouldbe compressed but neither equivalence classes normeta-equivalence classes should be used.The options 
  <samp>`-Cf'</samp> or 
  <samp>`-CF'</samp> and 
  <samp>`-Cm'</samp> do not make sensetogether - there is no opportunity formeta-equivalence classes if the table is not beingcompressed. Otherwise the options may be freelymixed, and are cumulative.The default setting is 
  <samp>`-Cem'</samp>, which specifies that 
  <code>flex</code> should generate equivalence classes andmeta-equivalence classes. This setting provides thehighest degree of table compression. You can tradeoff faster-executing scanners at the cost of largertables with the following generally being true: 
  <pre>slowest &amp; smallest
      -Cem
      -Cm
      -Ce
      -C
      -C{f,F}e
      -C{f,F}
      -C{f,F}a
fastest &amp; largest
</pre> Note that scanners with the smallest tables areusually generated and compiled the quickest, soduring development you will usually want to use thedefault, maximal compression. 
  <samp>`-Cfe'</samp> is often a good compromise between speed andsize for production scanners. 
 </dd> 
  
  <samp>`-ooutput'</samp> 
  
 <dd>
   directs flex to write the scanner to the file 
  <samp>`out-'</samp> 
  <code>put</code> instead of 
  <tt>`lex.yy.c'</tt>. If you combine 
  <samp>`-o'</samp> withthe 
  <samp>`-t'</samp> option, then the scanner is written to 
  <code>stdout</code> but its 
  <samp>`#line'</samp> directives (see the 
  <samp>`-L'</samp> optionabove) refer to the file 
  <code>output</code>. 
 </dd> 
  
  <samp>`-Pprefix'</samp> 
  
 <dd>
   changes the default 
  <samp>`yy'</samp> prefix used by 
  <code>flex</code> for allglobally-visible variable and function names toinstead be 
  <var>prefix</var>. For example, 
  <samp>`-Pfoo'</samp> changes thename of 
  <code>yytext</code> to 
  <tt>`footext'</tt>. It also changes thename of the default output file from 
  <tt>`lex.yy.c'</tt> to 
  <tt>`lex.foo.c'</tt>. Here are all of the names affected: 
  <pre>yy_create_buffer
yy_delete_buffer
yy_flex_debug
yy_init_buffer
yy_flush_buffer
yy_load_buffer_state
yy_switch_to_buffer
yyin
yyleng
yylex
yylineno
yyout
yyrestart
yytext
yywrap
</pre> (If you are using a C++ scanner, then only 
  <code>yywrap</code>and 
  <code>yyFlexLexer</code> are affected.) Within your scanneritself, you can still refer to the global variablesand functions using either version of their name;but externally, they have the modified name.This option lets you easily link together multiple 
  <code>flex</code> programs into the same executable. Note,though, that using this option also renames 
  <samp>`yywrap()'</samp>, so you now 
  <em>must</em> either provide your own(appropriately-named) version of the routine foryour scanner, or use 
  <samp>`%option noyywrap'</samp>, as linkingwith 
  <samp>`-lfl'</samp> no longer provides one for you bydefault. 
 </dd> 
  
  <samp>`-Sskeleton_file'</samp> 
  
 <dd>
   overrides the default skeleton file from which 
  <code>flex</code>constructs its scanners. You'll never need thisoption unless you are doing 
  <code>flex</code> maintenance ordevelopment. 
 </dd> 
</dl> 
<p><code>flex</code> also provides a mechanism for controlling optionswithin the scanner specification itself, rather than fromthe flex command-line. This is done by including <samp>`%option'</samp>directives in the first section of the scannerspecification. You can specify multiple options with a single<samp>`%option'</samp> directive, and multiple directives in the firstsection of your flex input file. Most options are givensimply as names, optionally preceded by the word "no"(with no intervening whitespace) to negate their meaning.A number are equivalent to flex flags or their negation:</p> 
<pre>7bit            -7 option
8bit            -8 option
align           -Ca option
backup          -b option
batch           -B option
c++             -+ option

caseful or
case-sensitive  opposite of -i (default)

case-insensitive or
caseless        -i option

debug           -d option
default         opposite of -s option
ecs             -Ce option
fast            -F option
full            -f option
interactive     -I option
lex-compat      -l option
meta-ecs        -Cm option
perf-report     -p option
read            -Cr option
stdout          -t option
verbose         -v option
warn            opposite of -w option
                (use "%option nowarn" for -w)

array           equivalent to "%array"
pointer         equivalent to "%pointer" (default)
</pre> 
<p>Some <samp>`%option's'</samp> provide features otherwise not available:</p> 
<dl> 
  
  <samp>`always-interactive'</samp> 
  
 <dd>
   instructs flex to generate a scanner which alwaysconsiders its input "interactive". Normally, oneach new input file the scanner calls 
  <samp>`isatty()'</samp> inan attempt to determine whether the scanner's inputsource is interactive and thus should be read acharacter at a time. When this option is used,however, then no such call is made. 
 </dd> 
  
  <samp>`main'</samp> 
  
 <dd>
   directs flex to provide a default 
  <samp>`main()'</samp> programfor the scanner, which simply calls 
  <samp>`yylex()'</samp>. Thisoption implies 
  <code>noyywrap</code> (see below). 
 </dd> 
  
  <samp>`never-interactive'</samp> 
  
 <dd>
   instructs flex to generate a scanner which neverconsiders its input "interactive" (again, no callmade to 
  <samp>`isatty())'</samp>. This is the opposite of 
  <samp>`always-'</samp> 
  <em>interactive</em>. 
 </dd> 
  
  <samp>`stack'</samp> 
  
 <dd>
   enables the use of start condition stacks (seeStart Conditions above). 
 </dd> 
  
  <samp>`stdinit'</samp> 
  
 <dd>
   if unset (i.e., 
  <samp>`%option nostdinit'</samp>) initializes 
  <code>yyin</code>and 
  <code>yyout</code> to nil 
  <code>FILE</code> pointers, instead of 
  <code>stdin</code>and 
  <code>stdout</code>. 
 </dd> 
  
  <samp>`yylineno'</samp> 
  
 <dd>
   directs 
  <code>flex</code> to generate a scanner that maintains the numberof the current line read from its input in the global variable 
  <code>yylineno</code>. This option is implied by 
  <samp>`%option lex-compat'</samp>. 
 </dd> 
  
  <samp>`yywrap'</samp> 
  
 <dd>
   if unset (i.e., 
  <samp>`%option noyywrap'</samp>), makes thescanner not call 
  <samp> `yywrap()'</samp> upon an end-of-file, butsimply assume that there are no more files to scan(until the user points 
  <code>yyin</code> at a new file and calls 
  <samp>`yylex()'</samp> again). 
 </dd> 
</dl> 
<p><code>flex</code> scans your rule actions to determine whether you usethe <code> REJECT</code> or <samp>`yymore()'</samp> features. The <code>reject</code> and <code> yymore</code>options are available to override its decision as towhether you use the options, either by setting them (e.g.,<samp>`%option reject'</samp>) to indicate the feature is indeed used, orunsetting them to indicate it actually is not used (e.g.,<samp>`%option noyymore'</samp>).</p> 
<p>Three options take string-delimited values, offset with '=':</p> 
<pre>%option outfile="ABC"
</pre> 
<p>is equivalent to <samp>`-oABC'</samp>, and</p> 
<pre>%option prefix="XYZ"
</pre> 
<p>is equivalent to <samp>`-PXYZ'</samp>.</p> 
<p>Finally,</p> 
<pre>%option yyclass="foo"
</pre> 
<p>only applies when generating a C++ scanner (<samp>`-+'</samp> option). Itinforms <code>flex</code> that you have derived <samp>`foo'</samp> as a subclass of<code>yyFlexLexer</code> so <code>flex</code> will place your actions in the memberfunction <samp>`foo::yylex()'</samp> instead of <samp>`yyFlexLexer::yylex()'</samp>.It also generates a <samp>`yyFlexLexer::yylex()'</samp> member function thatemits a run-time error (by invoking <samp>`yyFlexLexer::LexerError()'</samp>)if called. See Generating C++ Scanners, below, for additionalinformation.</p> 
<p>A number of options are available for lint purists whowant to suppress the appearance of unneeded routines inthe generated scanner. Each of the following, if unset,results in the corresponding routine not appearing in thegenerated scanner:</p> 
<pre>input, unput
yy_push_state, yy_pop_state, yy_top_state
yy_scan_buffer, yy_scan_bytes, yy_scan_string
</pre> 
<p>(though <samp>`yy_push_state()'</samp> and friends won't appear anywayunless you use <samp>`%option stack'</samp>).</p> 
<h3><a name="SEC18" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC18" rel="nofollow">Performance considerations</a></h3> 
<p>The main design goal of <code>flex</code> is that it generatehigh-performance scanners. It has been optimized for dealingwell with large sets of rules. Aside from the effects onscanner speed of the table compression <samp>`-C'</samp> options outlinedabove, there are a number of options/actions which degradeperformance. These are, from most expensive to least:</p> 
<pre>REJECT
%option yylineno
arbitrary trailing context

pattern sets that require backing up
%array
%option interactive
%option always-interactive

'^' beginning-of-line operator
yymore()
</pre> 
<p>with the first three all being quite expensive and thelast two being quite cheap. Note also that <samp>`unput()'</samp> isimplemented as a routine call that potentially does quitea bit of work, while <samp>`yyless()'</samp> is a quite-cheap macro; soif just putting back some excess text you scanned, use<samp>`yyless()'</samp>.</p> 
<p><code>REJECT</code> should be avoided at all costs when performance isimportant. It is a particularly expensive option.</p> 
<p>Getting rid of backing up is messy and often may be anenormous amount of work for a complicated scanner. Inprincipal, one begins by using the <samp>`-b'</samp> flag to generate a<tt>`lex.backup'</tt> file. For example, on the input</p> 
<pre>%%
foo        return TOK_KEYWORD;
foobar     return TOK_KEYWORD;
</pre> 
<p>the file looks like:</p> 
<pre>State #6 is non-accepting -
 associated rule line numbers:
       2       3
 out-transitions: [ o ]
 jam-transitions: EOF [ \001-n  p-\177 ]

State #8 is non-accepting -
 associated rule line numbers:
       3
 out-transitions: [ a ]
 jam-transitions: EOF [ \001-`  b-\177 ]

State #9 is non-accepting -
 associated rule line numbers:
       3
 out-transitions: [ r ]
 jam-transitions: EOF [ \001-q  s-\177 ]

Compressed tables always back up.
</pre> 
<p>The first few lines tell us that there's a scanner statein which it can make a transition on an 'o' but not on anyother character, and that in that state the currentlyscanned text does not match any rule. The state occurswhen trying to match the rules found at lines 2 and 3 inthe input file. If the scanner is in that state and thenreads something other than an 'o', it will have to back upto find a rule which is matched. With a bit ofhead-scratching one can see that this must be the state it's inwhen it has seen "fo". When this has happened, ifanything other than another 'o' is seen, the scanner willhave to back up to simply match the 'f' (by the defaultrule).</p> 
<p>The comment regarding State #8 indicates there's a problemwhen "foob" has been scanned. Indeed, on any characterother than an 'a', the scanner will have to back up toaccept "foo". Similarly, the comment for State #9concerns when "fooba" has been scanned and an 'r' does notfollow.</p> 
<p>The final comment reminds us that there's no point goingto all the trouble of removing backing up from the rulesunless we're using <samp>`-Cf'</samp> or <samp>`-CF'</samp>, since there's noperformance gain doing so with compressed scanners.</p> 
<p>The way to remove the backing up is to add "error" rules:</p> 
<pre>%%
foo         return TOK_KEYWORD;
foobar      return TOK_KEYWORD;

fooba       |
foob        |
fo          {
            /* false alarm, not really a keyword */
            return TOK_ID;
            }
</pre> 
<p>Eliminating backing up among a list of keywords can alsobe done using a "catch-all" rule:</p> 
<pre>%%
foo         return TOK_KEYWORD;
foobar      return TOK_KEYWORD;

[a-z]+      return TOK_ID;
</pre> 
<p>This is usually the best solution when appropriate.</p> 
<p>Backing up messages tend to cascade. With a complicatedset of rules it's not uncommon to get hundreds ofmessages. If one can decipher them, though, it often onlytakes a dozen or so rules to eliminate the backing up(though it's easy to make a mistake and have an error ruleaccidentally match a valid token. A possible future <code>flex</code>feature will be to automatically add rules to eliminatebacking up).</p> 
<p>It's important to keep in mind that you gain the benefitsof eliminating backing up only if you eliminate <em>every</em>instance of backing up. Leaving just one means you gainnothing.</p> 
<p><var>Variable</var> trailing context (where both the leading andtrailing parts do not have a fixed length) entails almostthe same performance loss as <code>REJECT</code> (i.e., substantial).So when possible a rule like:</p> 
<pre>%%
mouse|rat/(cat|dog)   run();
</pre> 
<p>is better written:</p> 
<pre>%%
mouse/cat|dog         run();
rat/cat|dog           run();
</pre> 
<p>or as</p> 
<pre>%%
mouse|rat/cat         run();
mouse|rat/dog         run();
</pre> 
<p>Note that here the special '|' action does <em>not</em> provide anysavings, and can even make things worse (see Deficiencies/ Bugs below).</p> 
<p>Another area where the user can increase a scanner'sperformance (and one that's easier to implement) arises fromthe fact that the longer the tokens matched, the fasterthe scanner will run. This is because with long tokensthe processing of most input characters takes place in the(short) inner scanning loop, and does not often have to gothrough the additional work of setting up the scanningenvironment (e.g., <code>yytext</code>) for the action. Recall thescanner for C comments:</p> 
<pre>%x comment
%%
        int line_num = 1;

"/*"         BEGIN(comment);

&lt;comment&gt;[^*\n]*
&lt;comment&gt;"*"+[^*/\n]*
&lt;comment&gt;\n             ++line_num;
&lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
</pre> 
<p>This could be sped up by writing it as:</p> 
<pre>%x comment
%%
        int line_num = 1;

"/*"         BEGIN(comment);

&lt;comment&gt;[^*\n]*
&lt;comment&gt;[^*\n]*\n      ++line_num;
&lt;comment&gt;"*"+[^*/\n]*
&lt;comment&gt;"*"+[^*/\n]*\n ++line_num;
&lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
</pre> 
<p>Now instead of each newline requiring the processing ofanother action, recognizing the newlines is "distributed"over the other rules to keep the matched text as long aspossible. Note that <em>adding</em> rules does <em>not</em> slow down thescanner! The speed of the scanner is independent of thenumber of rules or (modulo the considerations given at thebeginning of this section) how complicated the rules arewith regard to operators such as '*' and '|'.</p> 
<p>A final example in speeding up a scanner: suppose you wantto scan through a file containing identifiers andkeywords, one per line and with no other extraneouscharacters, and recognize all the keywords. A natural firstapproach is:</p> 
<pre>%%
asm      |
auto     |
break    |
... etc ...
volatile |
while    /* it's a keyword */

.|\n     /* it's not a keyword */
</pre> 
<p>To eliminate the back-tracking, introduce a catch-allrule:</p> 
<pre>%%
asm      |
auto     |
break    |
... etc ...
volatile |
while    /* it's a keyword */

[a-z]+   |
.|\n     /* it's not a keyword */
</pre> 
<p>Now, if it's guaranteed that there's exactly one word perline, then we can reduce the total number of matches by ahalf by merging in the recognition of newlines with thatof the other tokens:</p> 
<pre>%%
asm\n    |
auto\n   |
break\n  |
... etc ...
volatile\n |
while\n  /* it's a keyword */

[a-z]+\n |
.|\n     /* it's not a keyword */
</pre> 
<p>One has to be careful here, as we have now reintroducedbacking up into the scanner. In particular, while <em>we</em> knowthat there will never be any characters in the inputstream other than letters or newlines, <code>flex</code> can't figurethis out, and it will plan for possibly needing to back upwhen it has scanned a token like "auto" and then the nextcharacter is something other than a newline or a letter.Previously it would then just match the "auto" rule and bedone, but now it has no "auto" rule, only a "auto\n" rule.To eliminate the possibility of backing up, we couldeither duplicate all rules but without final newlines, or,since we never expect to encounter such an input andtherefore don't how it's classified, we can introduce onemore catch-all rule, this one which doesn't include anewline:</p> 
<pre>%%
asm\n    |
auto\n   |
break\n  |
... etc ...
volatile\n |
while\n  /* it's a keyword */

[a-z]+\n |
[a-z]+   |
.|\n     /* it's not a keyword */
</pre> 
<p>Compiled with <samp>`-Cf'</samp>, this is about as fast as one can get a<code>flex</code> scanner to go for this particular problem.</p> 
<p>A final note: <code>flex</code> is slow when matching NUL's,particularly when a token contains multiple NUL's. It's best towrite rules which match <em>short</em> amounts of text if it'santicipated that the text will often include NUL's.</p> 
<p>Another final note regarding performance: as mentionedabove in the section How the Input is Matched, dynamicallyresizing <code>yytext</code> to accommodate huge tokens is a slowprocess because it presently requires that the (huge) tokenbe rescanned from the beginning. Thus if performance isvital, you should attempt to match "large" quantities oftext but not "huge" quantities, where the cutoff betweenthe two is at about 8K characters/token.</p> 
<h3><a name="SEC19" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC19" rel="nofollow">Generating C++ scanners</a></h3> 
<p><code>flex</code> provides two different ways to generate scanners foruse with C++. The first way is to simply compile ascanner generated by <code>flex</code> using a C++ compiler instead of a Ccompiler. You should not encounter any compilationserrors (please report any you find to the email addressgiven in the Author section below). You can then use C++code in your rule actions instead of C code. Note thatthe default input source for your scanner remains <code>yyin</code>,and default echoing is still done to <code>yyout</code>. Both of theseremain <samp>`FILE *'</samp> variables and not C++ <code>streams</code>.</p> 
<p>You can also use <code>flex</code> to generate a C++ scanner class, usingthe <samp> `-+'</samp> option, (or, equivalently, <samp>`%option c++'</samp>), whichis automatically specified if the name of the flex executable endsin a <samp>`+'</samp>, such as <code>flex++</code>. When using this option, flexdefaults to generating the scanner to the file <tt>`lex.yy.cc'</tt> insteadof <tt>`lex.yy.c'</tt>. The generated scanner includes the header file<tt>`FlexLexer.h'</tt>, which defines the interface to two C++ classes.</p> 
<p>The first class, <code>FlexLexer</code>, provides an abstract baseclass defining the general scanner class interface. Itprovides the following member functions:</p> 
<dl> 
  
  <samp>`const char* YYText()'</samp> 
  
 <dd>
   returns the text of the most recently matchedtoken, the equivalent of 
  <code>yytext</code>. 
 </dd> 
  
  <samp>`int YYLeng()'</samp> 
  
 <dd>
   returns the length of the most recently matchedtoken, the equivalent of 
  <code> yyleng</code>. 
 </dd> 
  
  <samp>`int lineno() const'</samp> 
  
 <dd>
   returns the current input line number (see 
  <samp>`%option yylineno'</samp>),or 1 if 
  <samp>`%option yylineno'</samp> was not used. 
 </dd> 
  
  <samp>`void set_debug( int flag )'</samp> 
  
 <dd>
   sets the debugging flag for the scanner, equivalent to assigning to 
  <code>yy_flex_debug</code> (see the Options section above). Note that youmust build the scanner using 
  <samp>`%option debug'</samp> to include debugginginformation in it. 
 </dd> 
  
  <samp>`int debug() const'</samp> 
  
 <dd>
   returns the current setting of the debugging flag. 
 </dd> 
</dl> 
<p>Also provided are member functions equivalent to<samp>`yy_switch_to_buffer(), yy_create_buffer()'</samp> (though thefirst argument is an <samp>`istream*'</samp> object pointer and not a<samp>`FILE*'</samp>, <samp>`yy_flush_buffer()'</samp>, <samp>`yy_delete_buffer()'</samp>,and <samp>`yyrestart()'</samp> (again, the first argument is a <samp>`istream*'</samp>object pointer).</p> 
<p>The second class defined in <tt>`FlexLexer.h'</tt> is <code>yyFlexLexer</code>,which is derived from <code>FlexLexer</code>. It defines the followingadditional member functions:</p> 
<dl> 
  
  <samp>`yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )'</samp> 
  
 <dd>
   constructs a 
  <code>yyFlexLexer</code> object using the givenstreams for input and output. If not specified,the streams default to 
  <code>cin</code> and 
  <code>cout</code>, respectively. 
 </dd> 
  
  <samp>`virtual int yylex()'</samp> 
  
 <dd>
   performs the same role is 
  <samp>`yylex()'</samp> does for ordinaryflex scanners: it scans the input stream, consumingtokens, until a rule's action returns a value. If you derive a subclass 
  <var>S</var>from 
  <code>yyFlexLexer</code>and want to access the member functions and variables of 
  <var>S</var>inside 
  <samp>`yylex()'</samp>,then you need to use 
  <samp>`%option yyclass="<var>S</var>"'</samp>to inform 
  <code>flex</code>that you will be using that subclass instead of 
  <code>yyFlexLexer</code>.In this case, rather than generating 
  <samp>`yyFlexLexer::yylex()'</samp>, 
  <code>flex</code> generates 
  <samp>`<var>S</var>::yylex()'</samp>(and also generates a dummy 
  <samp>`yyFlexLexer::yylex()'</samp>that calls 
  <samp>`yyFlexLexer::LexerError()'</samp>if called). 
 </dd> 
  
  <samp>`virtual void switch_streams(istream* new_in = 0, ostream* new_out = 0)'</samp> 
  
 <dd>
   reassigns 
  <code>yyin</code> to 
  <code>new_in</code>(if non-nil)and 
  <code>yyout</code> to 
  <code>new_out</code>(ditto), deleting the previous input buffer if 
  <code>yyin</code>is reassigned. 
 </dd> 
  
  <samp>`int yylex( istream* new_in = 0, ostream* new_out = 0 )'</samp> 
  
 <dd>
   first switches the input streams via 
  <samp>`switch_streams( new_in, new_out )'</samp>and then returns the value of 
  <samp>`yylex()'</samp>. 
 </dd> 
</dl> 
<p>In addition, <code>yyFlexLexer</code> defines the following protectedvirtual functions which you can redefine in derivedclasses to tailor the scanner:</p> 
<dl> 
  
  <samp>`virtual int LexerInput( char* buf, int max_size )'</samp> 
  
 <dd>
   reads up to 
  <samp>`max_size'</samp> characters into 
  <var>buf</var> andreturns the number of characters read. To indicateend-of-input, return 0 characters. Note that"interactive" scanners (see the 
  <samp>`-B'</samp> and 
  <samp>`-I'</samp> flags)define the macro 
  <code>YY_INTERACTIVE</code>. If you redefine 
  <code>LexerInput()</code> and need to take different actionsdepending on whether or not the scanner might bescanning an interactive input source, you can testfor the presence of this name via 
  <samp>`#ifdef'</samp>. 
 </dd> 
  
  <samp>`virtual void LexerOutput( const char* buf, int size )'</samp> 
  
 <dd>
   writes out 
  <var>size</var> characters from the buffer 
  <var>buf</var>,which, while NUL-terminated, may also contain"internal" NUL's if the scanner's rules can matchtext with NUL's in them. 
 </dd> 
  
  <samp>`virtual void LexerError( const char* msg )'</samp> 
  
 <dd>
   reports a fatal error message. The default versionof this function writes the message to the stream 
  <code>cerr</code> and exits. 
 </dd> 
</dl> 
<p>Note that a <code>yyFlexLexer</code> object contains its <em>entire</em>scanning state. Thus you can use such objects to createreentrant scanners. You can instantiate multiple instances ofthe same <code>yyFlexLexer</code> class, and you can also combinemultiple C++ scanner classes together in the same programusing the <samp>`-P'</samp> option discussed above.Finally, note that the <samp>`%array'</samp> feature is not available toC++ scanner classes; you must use <samp>`%pointer'</samp> (the default).</p> 
<p>Here is an example of a simple C++ scanner:</p> 
<pre>    // An example of using the flex C++ scanner class.

%{
int mylineno = 0;
%}

string  \"[^\n"]+\"

ws      [ \t]+

alpha   [A-Za-z]
dig     [0-9]
name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
number  {num1}|{num2}

%%

{ws}    /* skip blanks and tabs */

"/*"    {
        int c;

        while((c = yyinput()) != 0)
            {
            if(c == '\n')
                ++mylineno;

            else if(c == '*')
                {
                if((c = yyinput()) == '/')
                    break;
                else
                    unput(c);
                }
            }
        }

{number}  cout &lt;&lt; "number " &lt;&lt; YYText() &lt;&lt; '\n';

\n        mylineno++;

{name}    cout &lt;&lt; "name " &lt;&lt; YYText() &lt;&lt; '\n';

{string}  cout &lt;&lt; "string " &lt;&lt; YYText() &lt;&lt; '\n';

%%

Version 2.5               December 1994                        44

int main( int /* argc */, char** /* argv */ )
    {
    FlexLexer* lexer = new yyFlexLexer;
    while(lexer-&gt;yylex() != 0)
        ;
    return 0;
    }
</pre> 
<p>If you want to create multiple (different) lexer classes,you use the <samp>`-P'</samp> flag (or the <samp>`prefix='</samp> option) to rename each<code>yyFlexLexer</code> to some other <code>xxFlexLexer</code>. You then caninclude <samp>`&lt;FlexLexer.h&gt;'</samp> in your other sources once per lexerclass, first renaming <code>yyFlexLexer</code> as follows:</p> 
<pre>#undef yyFlexLexer
#define yyFlexLexer xxFlexLexer
#include &lt;FlexLexer.h&gt;

#undef yyFlexLexer
#define yyFlexLexer zzFlexLexer
#include &lt;FlexLexer.h&gt;
</pre> 
<p>if, for example, you used <samp>`%option prefix="xx"'</samp> for one ofyour scanners and <samp>`%option prefix="zz"'</samp> for the other.</p> 
<p>IMPORTANT: the present form of the scanning class is<em>experimental</em> and may change considerably between majorreleases.</p> 
<h3><a name="SEC20" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC20" rel="nofollow">Incompatibilities with <code>lex</code> and POSIX</a></h3> 
<p><code>flex</code> is a rewrite of the AT&amp;T Unix <code>lex</code> tool (the twoimplementations do not share any code, though), with someextensions and incompatibilities, both of which are ofconcern to those who wish to write scanners acceptable toeither implementation. Flex is fully compliant with thePOSIX <code>lex</code> specification, except that when using <samp>`%pointer'</samp>(the default), a call to <samp>`unput()'</samp> destroys the contents of<code>yytext</code>, which is counter to the POSIX specification.</p> 
<p>In this section we discuss all of the known areas ofincompatibility between flex, AT&amp;T lex, and the POSIXspecification.</p> 
<p><code>flex's</code> <samp>`-l'</samp> option turns on maximum compatibility with theoriginal AT&amp;T <code>lex</code> implementation, at the cost of a majorloss in the generated scanner's performance. We notebelow which incompatibilities can be overcome using the <samp>`-l'</samp>option.</p> 
<p><code>flex</code> is fully compatible with <code>lex</code> with the followingexceptions:</p> 
<ul><li>The undocumented <code>lex</code> scanner internal variable <code>yylineno</code>is not supported unless <samp>`-l'</samp> or <samp>`%option yylineno'</samp> is used.<code>yylineno</code> should be maintained on a per-buffer basis, ratherthan a per-scanner (single global variable) basis. <code>yylineno</code> isnot part of the POSIX specification.</li><li>The <samp>`input()'</samp> routine is not redefinable, though itmay be called to read characters following whateverhas been matched by a rule. If <samp>`input()'</samp> encountersan end-of-file the normal <samp>`yywrap()'</samp> processing isdone. A "real" end-of-file is returned by<samp>`input()'</samp> as <code>EOF</code>.Input is instead controlled by defining the<code>YY_INPUT</code> macro.The <code>flex</code> restriction that <samp>`input()'</samp> cannot beredefined is in accordance with the POSIXspecification, which simply does not specify any way ofcontrolling the scanner's input other than by makingan initial assignment to <code>yyin</code>.</li><li>The <samp>`unput()'</samp> routine is not redefinable. Thisrestriction is in accordance with POSIX.</li><li><code>flex</code> scanners are not as reentrant as <code>lex</code> scanners.In particular, if you have an interactive scannerand an interrupt handler which long-jumps out ofthe scanner, and the scanner is subsequently calledagain, you may get the following message: <pre>fatal flex scanner internal error--end of buffer missed
</pre> To reenter the scanner, first use <pre>yyrestart( yyin );
</pre> Note that this call will throw away any bufferedinput; usually this isn't a problem with aninteractive scanner.Also note that flex C++ scanner classes <em>are</em>reentrant, so if using C++ is an option for you, youshould use them instead. See "Generating C++Scanners" above for details.</li><li><samp>`output()'</samp> is not supported. Output from the <samp>`ECHO'</samp>macro is done to the file-pointer <code>yyout</code> (default<code>stdout</code>).<samp>`output()'</samp> is not part of the POSIX specification.</li><li><code>lex</code> does not support exclusive start conditions(%x), though they are in the POSIX specification.</li><li>When definitions are expanded, <code>flex</code> encloses themin parentheses. With lex, the following: <pre>NAME    [A-Z][A-Z0-9]*
%%
foo{NAME}?      printf( "Found it\n" );
%%
</pre> will not match the string "foo" because when themacro is expanded the rule is equivalent to"foo[A-Z][A-Z0-9]*?" and the precedence is such that the'?' is associated with "[A-Z0-9]*". With <code>flex</code>, therule will be expanded to "foo([A-Z][A-Z0-9]*)?" andso the string "foo" will match.Note that if the definition begins with <samp>`^'</samp> or endswith <samp>`$'</samp> then it is <em>not</em> expanded with parentheses, toallow these operators to appear in definitionswithout losing their special meanings. But the<samp>`&lt;s&gt;, /'</samp>, and <samp>`&lt;&lt;EOF&gt;&gt;'</samp> operators cannot be used in a<code>flex</code> definition.Using <samp>`-l'</samp> results in the <code>lex</code> behavior of noparentheses around the definition.The POSIX specification is that the definition be enclosed inparentheses.</li><li>Some implementations of <code>lex</code> allow a rule's action to begin ona separate line, if the rule's pattern has trailing whitespace: <pre>%%
foo|bar&lt;space here&gt;
  { foobar_action(); }
</pre> <code>flex</code> does not support this feature.</li><li>The <code>lex</code> <samp>`%r'</samp> (generate a Ratfor scanner) option isnot supported. It is not part of the POSIXspecification.</li><li>After a call to <samp>`unput()'</samp>, <code>yytext</code> is undefined untilthe next token is matched, unless the scanner wasbuilt using <samp>`%array'</samp>. This is not the case with <code>lex</code>or the POSIX specification. The <samp>`-l'</samp> option doesaway with this incompatibility.</li><li>The precedence of the <samp>`{}'</samp> (numeric range) operatoris different. <code>lex</code> interprets "abc{1,3}" as "matchone, two, or three occurrences of 'abc'", whereas<code>flex</code> interprets it as "match 'ab' followed by one,two, or three occurrences of 'c'". The latter isin agreement with the POSIX specification.</li><li>The precedence of the <samp>`^'</samp> operator is different. <code>lex</code>interprets "^foo|bar" as "match either 'foo' at thebeginning of a line, or 'bar' anywhere", whereas<code>flex</code> interprets it as "match either 'foo' or 'bar'if they come at the beginning of a line". Thelatter is in agreement with the POSIX specification.</li><li>The special table-size declarations such as <samp>`%a'</samp>supported by <code> lex</code> are not required by <code>flex</code> scanners;<code>flex</code> ignores them.</li><li>The name FLEX_SCANNER is #define'd so scanners maybe written for use with either <code>flex</code> or <code>lex</code>.Scanners also include <code>YY_FLEX_MAJOR_VERSION</code> and<code>YY_FLEX_MINOR_VERSION</code> indicating which version of<code>flex</code> generated the scanner (for example, for the2.5 release, these defines would be 2 and 5respectively).</li></ul> 
<p>The following <code>flex</code> features are not included in <code>lex</code> or thePOSIX specification:</p> 
<pre>C++ scanners
%option
start condition scopes
start condition stacks
interactive/non-interactive scanners
yy_scan_string() and friends
yyterminate()
yy_set_interactive()
yy_set_bol()
YY_AT_BOL()
&lt;&lt;EOF&gt;&gt;
&lt;*&gt;
YY_DECL
YY_START
YY_USER_ACTION
YY_USER_INIT
#line directives
%{}'s around actions
multiple actions on a line
</pre> 
<p>plus almost all of the flex flags. The last feature inthe list refers to the fact that with <code>flex</code> you can putmultiple actions on the same line, separated withsemicolons, while with <code>lex</code>, the following</p> 
<pre>foo    handle_foo(); ++num_foos_seen;
</pre> 
<p>is (rather surprisingly) truncated to</p> 
<pre>foo    handle_foo();
</pre> 
<p><code>flex</code> does not truncate the action. Actions that are notenclosed in braces are simply terminated at the end of theline.</p> 
<h3><a name="SEC21" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC21" rel="nofollow">Diagnostics</a></h3> 
<dl> 
  
  <samp>`warning, rule cannot be matched'</samp> 
  
 <dd>
   indicates that the givenrule cannot be matched because it follows other rules thatwill always match the same text as it. For example, inthe following "foo" cannot be matched because it comesafter an identifier "catch-all" rule: 
  <pre>[a-z]+    got_identifier();
foo       got_foo();
</pre> Using 
  <code>REJECT</code> in a scanner suppresses this warning. 
 </dd> 
  
  <samp>`warning, -s option given but default rule can be matched'</samp> 
  
 <dd>
   means that it is possible (perhaps only in a particularstart condition) that the default rule (match any singlecharacter) is the only one that will match a particularinput. Since 
  <samp>`-s'</samp> was given, presumably this is notintended. 
 </dd> 
  
  <samp>`reject_used_but_not_detected undefined'</samp> 
  
 <dd> 
  <br> 
 </dd> 
  
  <samp>`yymore_used_but_not_detected undefined'</samp> 
  
 <dd>
   These errors canoccur at compile time. They indicate that the scanneruses 
  <code> REJECT</code> or 
  <samp>`yymore()'</samp> but that 
  <code>flex</code> failed to notice thefact, meaning that 
  <code>flex</code> scanned the first two sectionslooking for occurrences of these actions and failed tofind any, but somehow you snuck some in (via a #includefile, for example). Use 
  <samp>`%option reject'</samp> or 
  <samp>`%option yymore'</samp>to indicate to flex that you really do use these features. 
 </dd> 
  
  <samp>`flex scanner jammed'</samp> 
  
 <dd>
   a scanner compiled with 
  <samp>`-s'</samp> hasencountered an input string which wasn't matched by any ofits rules. This error can also occur due to internalproblems. 
 </dd> 
  
  <samp>`token too large, exceeds YYLMAX'</samp> 
  
 <dd>
   your scanner uses 
  <samp>`%array'</samp>and one of its rules matched a string longer than the 
  <samp>`YYL-'</samp> 
  <code>MAX</code> constant (8K bytes by default). You can increase thevalue by #define'ing 
  <code>YYLMAX</code> in the definitions section ofyour 
  <code>flex</code> input. 
 </dd> 
  
  <samp>`scanner requires -8 flag to use the character '<var>x</var>''</samp> 
  
 <dd>
   Yourscanner specification includes recognizing the 8-bitcharacter 
  <var>x</var> and you did not specify the -8 flag, and yourscanner defaulted to 7-bit because you used the 
  <samp>`-Cf'</samp> or 
  <samp>`-CF'</samp>table compression options. See the discussion of the 
  <samp>`-7'</samp>flag for details. 
 </dd> 
  
  <samp>`flex scanner push-back overflow'</samp> 
  
 <dd>
   you used 
  <samp>`unput()'</samp> to pushback so much text that the scanner's buffer could not holdboth the pushed-back text and the current token in 
  <code>yytext</code>.Ideally the scanner should dynamically resize the bufferin this case, but at present it does not. 
 </dd> 
  
  <samp>`input buffer overflow, can't enlarge buffer because scanner uses REJECT'</samp> 
  
 <dd>
   the scanner was working on matching anextremely large token and needed to expand the inputbuffer. This doesn't work with scanners that use 
  <code>REJECT</code>. 
 </dd> 
  
  <samp>`fatal flex scanner internal error--end of buffer missed'</samp> 
  
 <dd>
   This can occur in an scanner which is reentered after along-jump has jumped out (or over) the scanner'sactivation frame. Before reentering the scanner, use: 
  <pre>yyrestart( yyin );
</pre> or, as noted above, switch to using the C++ scanner class. 
 </dd> 
  
  <samp>`too many start conditions in &lt;&gt; construct!'</samp> 
  
 <dd>
   you listedmore start conditions in a &lt;&gt; construct than exist (so youmust have listed at least one of them twice). 
 </dd> 
</dl> 
<h3><a name="SEC22" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC22" rel="nofollow">Files</a></h3> 
<dl> 
  
  <tt>`-lfl'</tt> 
  
 <dd>
   library with which scanners must be linked. 
 </dd> 
  
  <tt>`lex.yy.c'</tt> 
  
 <dd>
   generated scanner (called 
  <tt>`lexyy.c'</tt> on some systems). 
 </dd> 
  
  <tt>`lex.yy.cc'</tt> 
  
 <dd>
   generated C++ scanner class, when using 
  <samp>`-+'</samp>. 
 </dd> 
  
  <tt>`&lt;FlexLexer.h&gt;'</tt> 
  
 <dd>
   header file defining the C++ scanner base class, 
  <code>FlexLexer</code>, and its derived class, 
  <code>yyFlexLexer</code>. 
 </dd> 
  
  <tt>`flex.skl'</tt> 
  
 <dd>
   skeleton scanner. This file is only used whenbuilding flex, not when flex executes. 
 </dd> 
  
  <tt>`lex.backup'</tt> 
  
 <dd>
   backing-up information for 
  <samp>`-b'</samp> flag (called 
  <tt>`lex.bck'</tt>on some systems). 
 </dd> 
</dl> 
<h3><a name="SEC23" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC23" rel="nofollow">Deficiencies / Bugs</a></h3> 
<p>Some trailing context patterns cannot be properly matchedand generate warning messages ("dangerous trailingcontext"). These are patterns where the ending of the firstpart of the rule matches the beginning of the second part,such as "zx*/xy*", where the 'x*' matches the 'x' at thebeginning of the trailing context. (Note that the POSIXdraft states that the text matched by such patterns isundefined.)</p> 
<p>For some trailing context rules, parts which are actuallyfixed-length are not recognized as such, leading to theabovementioned performance loss. In particular, partsusing '|' or {n} (such as "foo{3}") are always consideredvariable-length.</p> 
<p>Combining trailing context with the special '|' action canresult in <em>fixed</em> trailing context being turned into themore expensive <var>variable</var> trailing context. For example, inthe following:</p> 
<pre>%%
abc      |
xyz/def
</pre> 
<p>Use of <samp>`unput()'</samp> invalidates yytext and yyleng, unless the<samp>`%array'</samp> directive or the <samp>`-l'</samp> option has been used.</p> 
<p>Pattern-matching of NUL's is substantially slower thanmatching other characters.</p> 
<p>Dynamic resizing of the input buffer is slow, as itentails rescanning all the text matched so far by thecurrent (generally huge) token.</p> 
<p>Due to both buffering of input and read-ahead, you cannotintermix calls to &lt;stdio.h&gt; routines, such as, forexample, <samp>`getchar()'</samp>, with <code>flex</code> rules and expect it to work.Call <samp>`input()'</samp> instead.</p> 
<p>The total table entries listed by the <samp>`-v'</samp> flag excludes thenumber of table entries needed to determine what rule hasbeen matched. The number of entries is equal to thenumber of DFA states if the scanner does not use <code>REJECT</code>, andsomewhat greater than the number of states if it does.</p> 
<p><code>REJECT</code> cannot be used with the <samp>`-f'</samp> or <samp>`-F'</samp> options.</p> 
<p>The <code>flex</code> internal algorithms need documentation.</p> 
<h3><a name="SEC24" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC24" rel="nofollow">See also</a></h3> 
<p><code>lex</code>(1), <code>yacc</code>(1), <code>sed</code>(1), <code>awk</code>(1).</p> 
<p>John Levine, Tony Mason, and Doug Brown: Lex &amp; Yacc;O'Reilly and Associates. Be sure to get the 2nd edition.</p> 
<p>M. E. Lesk and E. Schmidt, LEX - Lexical Analyzer Generator.</p> 
<p>Alfred Aho, Ravi Sethi and Jeffrey Ullman: Compilers:Principles, Techniques and Tools; Addison-Wesley (1986).Describes the pattern-matching techniques used by <code>flex</code>(deterministic finite automata).</p> 
<h3><a name="SEC25" href="http://www.cs.princeton.edu/%7Eappel/modern/c/software/flex/flex_toc.html#TOC25" rel="nofollow">Author</a></h3> 
<p>Vern Paxson, with the help of many ideas and much inspiration fromVan Jacobson. Original version by Jef Poskanzer. The fast tablerepresentation is a partial implementation of a design done by VanJacobson. The implementation was done by Kevin Gong and Vern Paxson.</p> 
<p>Thanks to the many <code>flex</code> beta-testers, feedbackers, andcontributors, especially Francois Pinard, Casey Leedom, StanAdermann, Terry Allen, David Barker-Plummer, John Basrai, NelsonH.F. Beebe, <samp>`benson@odi.com'</samp>, Karl Berry, Peter A. Bigot,Simon Blanchard, Keith Bostic, Frederic Brehm, Ian Brockbank, KinCho, Nick Christopher, Brian Clapper, J.T. Conklin, Jason Coughlin,Bill Cox, Nick Cropper, Dave Curtis, Scott David Daniels, ChrisG. Demetriou, Theo Deraadt, Mike Donahue, Chuck Doucette, Tom Epperly,Leo Eskin, Chris Faylor, Chris Flatters, Jon Forrest, Joe Gayda, KavehR. Ghazi, Eric Goldman, Christopher M. Gould, Ulrich Grepel, PeerGriebel, Jan Hajic, Charles Hemphill, NORO Hideo, Jarkko Hietaniemi,Scott Hofmann, Jeff Honig, Dana Hudes, Eric Hughes, John Interrante,Ceriel Jacobs, Michal Jaegermann, Sakari Jalovaara, Jeffrey R. Jones,Henry Juengst, Klaus Kaempf, Jonathan I. Kamens, Terrence O Kane,Amir Katz, <samp>`ken@ken.hilco.com'</samp>, Kevin B. Kenny, Steve Kirsch,Winfried Koenig, Marq Kole, Ronald Lamprecht, Greg Lee, Rohan Lenard,Craig Leres, John Levine, Steve Liddle, Mike Long, Mohamed el Lozy,Brian Madsen, Malte, Joe Marshall, Bengt Martensson, Chris Metcalf,Luke Mewburn, Jim Meyering, R. Alexander Milowski, Erik Naggum,G.T. Nicol, Landon Noll, James Nordby, Marc Nozell, Richard Ohnemus,Karsten Pahnke, Sven Panne, Roland Pesch, Walter Pelissero, GaumondPierre, Esmond Pitt, Jef Poskanzer, Joe Rahmeh, Jarmo Raiha, FredericRaimbault, Pat Rankin, Rick Richardson, Kevin Rodgers, Kai Uwe Rommel,Jim Roskind, Alberto Santini, Andreas Scherer, Darrell Schiebel, RafSchietekat, Doug Schmidt, Philippe Schnoebelen, Andreas Schwab, AlexSiegel, Eckehard Stolz, Jan-Erik Strvmquist, Mike Stump, Paul Stuart,Dave Tallman, Ian Lance Taylor, Chris Thewalt, Richard M. Timoney,Jodi Tsai, Paul Tuinenga, Gary Weik, Frank Whaley, Gerhard Wilhelms,Kent Williams, Ken Yap, Ron Zellar, Nathan Zelle, David Zuhn, andthose whose names have slipped my marginal mail-archiving skills butwhose contributions are appreciated all the same.</p> 
<p>Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John Gilmore,Craig Leres, John Levine, Bob Mulcahy, G.T. Nicol, Francois Pinard,Rich Salz, and Richard Stallman for help with various distributionheadaches.</p> 
<p>Thanks to Esmond Pitt and Earle Horton for 8-bit character support;to Benson Margulies and Fred Burke for C++ support; to Kent Williamsand Tom Epperly for C++ class support; to Ove Ewerlid for support ofNUL's; and to Eric Hughes for support of multiple buffers.</p> 
<p>This work was primarily done when I was with the Real Time SystemsGroup at the Lawrence Berkeley Laboratory in Berkeley, CA. Many thanksto all there for the support I received.</p> 
<p>Send comments to <samp>`vern@ee.lbl.gov'</samp>.</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f6053a59d72464472a2bcc5948c625af/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Deployment Procces by Rowan Simpson</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da71411c1ca356b7ae85ee43e12d86e5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器安全狗怎么样?好用吗?【转载】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>