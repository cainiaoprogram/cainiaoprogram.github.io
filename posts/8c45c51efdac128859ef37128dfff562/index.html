<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>EFCore 通过实体Model生成创建SQL Server数据库表脚本 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="EFCore 通过实体Model生成创建SQL Server数据库表脚本" />
<meta property="og:description" content="在我们的项目中经常采用Model First这种方式先来设计数据库Model,然后通过Migration来生成数据库表结构，有些时候我们需要动态通过实体Model来创建数据库的表结构，特别是在创建像临时表这一类型的时候，我们直接通过代码来进行创建就可以了不用通过创建实体然后迁移这种方式来进行，其实原理也很简单就是通过便利当前Model然后获取每一个属性并以此来生成部分创建脚本，然后将这些创建的脚本拼接成一个完整的脚本到数据库中去执行就可以了，只不过这里有一些需要注意的地方，下面我们来通过代码来一步步分析怎么进行这些代码规范编写以及需要注意些什么问题。
一 代码分析
/// &lt;summary&gt; /// Model 生成数据库表脚本 /// &lt;/summary&gt; public class TableGenerator : ITableGenerator { private static Dictionary&lt;Type, string&gt; DataMapper { get { var dataMapper = new Dictionary&lt;Type, string&gt; { {typeof(int), &#34;NUMBER(10) NOT NULL&#34;}, {typeof(int?), &#34;NUMBER(10)&#34;}, {typeof(string), &#34;VARCHAR2({0} CHAR)&#34;}, {typeof(bool), &#34;NUMBER(1)&#34;}, {typeof(DateTime), &#34;DATE&#34;}, {typeof(DateTime?), &#34;DATE&#34;}, {typeof(float), &#34;FLOAT&#34;}, {typeof(float?), &#34;FLOAT&#34;}, {typeof(decimal), &#34;DECIMAL(16,4)&#34;}, {typeof(decimal?), &#34;DECIMAL(16,4)&#34;}, {typeof(Guid), &#34;CHAR(36)&#34;}, {typeof(Guid?), &#34;CHAR(36)&#34;} }; return dataMapper; } } private readonly List&lt;KeyValuePair&lt;string, PropertyInfo&gt;&gt; _fields = new List&lt;KeyValuePair&lt;string, PropertyInfo&gt;&gt;(); /// &lt;summary&gt; /// /// &lt;/summary&gt; private string _tableName; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private string GetTableName(MemberInfo entityType) { if (_tableName !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8c45c51efdac128859ef37128dfff562/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-24T17:16:00+08:00" />
<meta property="article:modified_time" content="2019-06-24T17:16:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">EFCore 通过实体Model生成创建SQL Server数据库表脚本</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>　　在我们的项目中经常采用Model First这种方式先来设计数据库Model,然后通过Migration来生成数据库表结构，有些时候我们需要动态通过实体Model来创建数据库的表结构，特别是在创建像临时表这一类型的时候，我们直接通过代码来进行创建就可以了不用通过创建实体然后迁移这种方式来进行，其实原理也很简单就是通过便利当前Model然后获取每一个属性并以此来生成部分创建脚本，然后将这些创建的脚本拼接成一个完整的脚本到数据库中去执行就可以了，只不过这里有一些需要注意的地方，下面我们来通过代码来一步步分析怎么进行这些代码规范编写以及需要注意些什么问题。</p> 
 <p>　　<strong>一 代码分析</strong></p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-csharp">/// &lt;summary&gt;
    /// Model 生成数据库表脚本
    /// &lt;/summary&gt;
    public class TableGenerator : ITableGenerator {
        private static Dictionary&lt;Type, string&gt; DataMapper {
            get {
                var dataMapper = new Dictionary&lt;Type, string&gt; {
                    {typeof(int), "NUMBER(10) NOT NULL"},
                    {typeof(int?), "NUMBER(10)"},
                    {typeof(string), "VARCHAR2({0} CHAR)"},
                    {typeof(bool), "NUMBER(1)"},
                    {typeof(DateTime), "DATE"},
                    {typeof(DateTime?), "DATE"},
                    {typeof(float), "FLOAT"},
                    {typeof(float?), "FLOAT"},
                    {typeof(decimal), "DECIMAL(16,4)"},
                    {typeof(decimal?), "DECIMAL(16,4)"},
                    {typeof(Guid), "CHAR(36)"},
                    {typeof(Guid?), "CHAR(36)"}
                };

                return dataMapper;
            }
        }

        private readonly List&lt;KeyValuePair&lt;string, PropertyInfo&gt;&gt; _fields = new List&lt;KeyValuePair&lt;string, PropertyInfo&gt;&gt;();

        /// &lt;summary&gt;
        ///
        /// &lt;/summary&gt;
        private string _tableName;

        /// &lt;summary&gt;
        ///
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private string GetTableName(MemberInfo entityType) {
            if (_tableName != null)
                return _tableName;
            var prefix = entityType.GetCustomAttribute&lt;TempTableAttribute&gt;() != null ? "#" : string.Empty;
            return _tableName = $"{prefix}{entityType.GetCustomAttribute&lt;TableAttribute&gt;()?.Name ?? entityType.Name}";
        }

        /// &lt;summary&gt;
        /// 生成创建表的脚本
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public string GenerateTableScript(Type entityType) {
            if (entityType == null)
                throw new ArgumentNullException(nameof(entityType));

            GenerateFields(entityType);

            const int DefaultColumnLength = 500;
            var script = new StringBuilder();

            script.AppendLine($"CREATE TABLE {GetTableName(entityType)} (");
            foreach (var (propName, propertyInfo) in _fields) {
                if (!DataMapper.ContainsKey(propertyInfo.PropertyType))
                    throw new NotSupportedException($"尚不支持 {propertyInfo.PropertyType}, 请联系开发人员.");
                if (propertyInfo.PropertyType == typeof(string)) {
                    var maxLengthAttribute = propertyInfo.GetCustomAttribute&lt;MaxLengthAttribute&gt;();
                    script.Append($"\t {propName} {string.Format(DataMapper[propertyInfo.PropertyType], maxLengthAttribute?.Length ?? DefaultColumnLength)}");
                    if (propertyInfo.GetCustomAttribute&lt;RequiredAttribute&gt;() != null)
                        script.Append(" NOT NULL");
                    script.AppendLine(",");
                } else {
                    script.AppendLine($"\t {propName} {DataMapper[propertyInfo.PropertyType]},");
                }
            }

            script.Remove(script.Length - 1, 1);

            script.AppendLine(")");

            return script.ToString();
        }

        private void GenerateFields(Type entityType) {
            foreach (var p in entityType.GetProperties()) {
                if (p.GetCustomAttribute&lt;NotMappedAttribute&gt;() != null)
                    continue;
                var columnName = p.GetCustomAttribute&lt;ColumnAttribute&gt;()?.Name ?? p.Name;
                var field = new KeyValuePair&lt;string, PropertyInfo&gt;(columnName, p);
                _fields.Add(field);
            }
        }
    }
</code></pre> 
 </div> 
 <p>　　这里的TableGenerator继承自接口ITableGenerator，在这个接口内部只定义了一个 string GenerateTableScript(Type entityType) 方法。</p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-csharp">/// &lt;summary&gt;
    /// Model 生成数据库表脚本
    /// &lt;/summary&gt;
    public interface ITableGenerator {
        /// &lt;summary&gt;
        /// 生成创建表的脚本
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        string GenerateTableScript(Type entityType);
    }
</code></pre> 
 </div> 
 <p>　　这里我们来一步步分析这些部分的含义，这个里面DataMapper主要是用来定义一些C#基础数据类型和数据库生成脚本之间的映射关系。</p> 
 <p>　　<strong>1 GetTableName</strong></p> 
 <p>　　接下来我们看看GetTableName这个函数，这里首先来当前Model是否定义了TempTableAttribute，这个看名字就清楚了就是用来定义当前Model是否是用来生成一张临时表的。</p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-csharp">/// &lt;summary&gt;
    /// 是否临时表, 仅限 Dapper 生成 数据库表结构时使用
    /// &lt;/summary&gt;
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public class TempTableAttribute : Attribute {

    }
</code></pre> 
 </div> 
 <p>　　具体我们来看看怎样在实体Model中定义TempTableAttribute这个自定义属性。</p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-csharp">  [TempTable]
        class StringTable {
            public string DefaultString { get; set; }
            [MaxLength(30)]
            public string LengthString { get; set; }
            [Required]
            public string NotNullString { get; set; }
        }
</code></pre> 
 </div> 
 <p>　　就像这样定义的话，我们就知道当前Model会生成一张SQL Server的临时表。</p> 
 <p>　　当然如果是生成临时表，则会在生成的表名称前面加一个‘#’标志，在这段代码中我们还会去判断当前实体是否定义了TableAttribute，如果定义过就去取这个TableAttribute的名称，否则就去当前Model的名称，这里也举一个实例。</p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-csharp"> [Table("Test")]
        class IntTable {
            public int IntProperty { get; set; }
            public int? NullableIntProperty { get; set; }
        }
</code></pre> 
 </div> 
 <p>　　这样我们通过代码创建的数据库名称就是Test啦。</p> 
 <p>　　<strong>2 GenerateFields</strong></p> 
 <p>　　这个主要是用来一个个读取Model中的属性，并将每一个实体属性整理成一个KeyValuePair&lt;string, PropertyInfo&gt;的对象从而方便最后一步来生成整个表完整的脚本，这里也有些内容需要注意，如果当前属性定义了NotMappedAttribute标签，那么我们可以直接跳过当前属性，另外还需要注意的地方就是当前属性的名称首先看当前属性是否定义了ColumnAttribute的如果定义了，那么数据库中字段名称就取自ColumnAttribute定义的名称，否则才是取自当前属性的名称，通过这样一步操作我们就能够将所有的属性读取到一个自定义的数据结构List&lt;KeyValuePair&lt;string, PropertyInfo&gt;&gt;里面去了。</p> 
 <p>　　<strong>3 GenerateTableScript</strong></p> 
 <p>　　有了前面的两步准备工作，后面就是进入到生成整个创建表脚本的部分了，其实这里也比较简单，就是通过循环来一个个生成每一个属性对应的脚本，然后通过StringBuilder来拼接到一起形成一个完整的整体。这里面有一点需要我们注意的地方就是当前字段是否可为空还取决于当前属性是否定义过RequiredAttribute标签，如果定义过那么就需要在创建的脚本后面添加Not Null,最后一个重点就是对于string类型的属性我们需要读取其定义的MaxLength属性从而确定数据库中的字段长度，如果没有定义则取默认长度500。</p> 
 <p>　　当然一个完整的代码怎么能少得了单元测试呢？下面我们来看看单元测试。</p> 
 <p><strong>　　二 单元测试　　</strong></p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-csharp"> public class SqlServerTableGenerator_Tests {
        [Table("Test")]
        class IntTable {
            public int IntProperty { get; set; }
            public int? NullableIntProperty { get; set; }
        }

        [Fact]
        public void GenerateTableScript_Int_Number10() {
            // Act
            var sql = new TableGenerator().GenerateTableScript(typeof(IntTable));
            // Assert
            sql.ShouldContain("IntProperty NUMBER(10) NOT NULL");
            sql.ShouldContain("NullableIntProperty NUMBER(10)");
        }

        [Fact]
        public void GenerateTableScript_TestTableName_Test() {
            // Act
            var sql = new TableGenerator().GenerateTableScript(typeof(IntTable));
            // Assert
            sql.ShouldContain("CREATE TABLE Test");
        }

        [TempTable]
        class StringTable {
            public string DefaultString { get; set; }
            [MaxLength(30)]
            public string LengthString { get; set; }
            [Required]
            public string NotNullString { get; set; }
        }

        [Fact]
        public void GenerateTableScript_TempTable_TableNameWithSharp() {
            // Act
            var sql = new TableGenerator().GenerateTableScript(typeof(StringTable));
            // Assert
            sql.ShouldContain("Create Table #StringTable");
        }

        [Fact]
        public void GenerateTableScript_String_Varchar() {
            // Act
            var sql = new TableGenerator().GenerateTableScript(typeof(StringTable));
            // Assert
            sql.ShouldContain("DefaultString VARCHAR2(500 CHAR)");
            sql.ShouldContain("LengthString VARCHAR2(30 CHAR)");
            sql.ShouldContain("NotNullString VARCHAR2(500 CHAR) NOT NULL");
        }

        class ColumnTable {
            [Column("Test")]
            public int IntProperty { get; set; }
            [NotMapped]
            public int Ingored {get; set; }
        }

        [Fact]
        public void GenerateTableScript_ColumnName_NewName() {
            // Act
            var sql = new TableGenerator().GenerateTableScript(typeof(ColumnTable));
            // Assert
            sql.ShouldContain("Test NUMBER(10) NOT NULL");
        }

        [Fact]
        public void GenerateTableScript_NotMapped_Ignore() {
            // Act
            var sql = new TableGenerator().GenerateTableScript(typeof(ColumnTable));
            // Assert
            sql.ShouldNotContain("Ingored NUMBER(10) NOT NULL");
        }

        class NotSupportedTable {
            public dynamic Ingored {get; set; }
        }

        [Fact]
        public void GenerateTableScript_NotSupported_ThrowException() {
            // Act
            Assert.Throws&lt;NotSupportedException&gt;(() =&gt; {
                new TableGenerator().GenerateTableScript(typeof(NotSupportedTable));
            });
        }
    }
</code></pre> 
 </div> 
 <p>　　最后我们来看看最终生成的创建表的脚本。</p> 
 <p>　　1 定义过TableAttribute的脚本。</p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-csharp">CREATE TABLE Test (
	 IntProperty NUMBER(10) NOT NULL,
	 NullableIntProperty NUMBER(10),
)
</code></pre> 
 </div> 
 <p>　　2 生成的临时表的脚本。</p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-csharp">CREATE TABLE #StringTable (
	 DefaultString VARCHAR2(500 CHAR),
	 LengthString VARCHAR2(30 CHAR),
	 NotNullString VARCHAR2(500 CHAR) NOT NULL,
)
</code></pre> 
 </div> 
 <p>　　通过这种方式我们就能够在代码中去动态生成数据库表结构了。</p> 
</div> 
<p>转载于:https://www.cnblogs.com/seekdream/p/11078231.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be78a981b33a92800b18b133f782e6da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信小程序侧边栏二级联动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7678555339c7f5604b0b526311e795a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MTK平台camera驱动架构分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>