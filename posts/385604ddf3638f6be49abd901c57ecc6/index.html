<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>K8S概述 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="K8S概述" />
<meta property="og:description" content="K8S概述 文章目录 K8S概述1.K8S是什么2.为什么用K8S3.K8S的特性4.K8S集群架构与组件4.1Master组件4.2Node组件4.3K8S架构 5.K8S核心概念5.1Pod5.2Pod控制器5.3Label5.4Label选择器（Label selector）5.5Service5.6Ingress5.7Name5.8Namespace 6.常见的K8S按照部署方式 1.K8S是什么 K8S 的全称为Kubernetes
作用：
用于自动部署、扩展和管理“容器化(containerized）应用程序”的开源系统。
可以理解成K8S是负责自动化运维管理多个容器化程序（比如 Docker）的集群，是一个生态极其丰富的容器编排框架工具。
由来：
K8S由google的Borg系统（博格系统，google内部使用的大规模容器编排工具）作为原型，后经GO语言延用Borg的思路重写并捐献给CNCF基金会开源。
含义：
词根源于希腊语的舵手、飞行员
2.为什么用K8S 试想下传统的后端部署办法：把程序包（包括可执行二进制文件、配置文件等）放到服务器上，接着运行启动脚本把程序跑起来，同时启动守护脚本定期检查程序运行状态、必要的话重新拉起程序。
设想一下，如果服务的请求量上来，已部署的服务响应不过来怎么办。传统的做法往往是，如果请求量、内存、CPU超过阈值做了告警，运维人员马上再加几台服务器，部署好服务之后，接入负载均衡来分担已有服务的压力。
这样问题就出现了：从监控告警到部署服务，中间需要人力介入。那么，有没有办法自动完成服务的部署、更新、卸载和扩容、缩容呢？
而这就是K8S要做的事情：自动化运维管理容器化(Docker) 程序。
K8S的目标是让部署容器化应用简单高效。
K8S解决了裸跑Docker的若干痛点：
单机使用，无法有效集群随着容器数量的上升，管理成本攀升没有有效的容灾、自愈机制没有预设编排模板，无法实现快速、大规模容器调度没有统一的配置管理中心工具没有容器生命周期的管理工具没有图形化运维管理工具 K8S是Google开源的容器集群管理系统，在Docker等容器技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。其主要功能如下：
使用Docker等容器技术对应用程序包装(package)、实例化（instantiate)、运行（run)以集群的方式运行、管理跨机器的容器。解决Docker 跨机器容器之间的通讯问题。K8S的自我修复机制使得容器集群总是运行在用户期望的状态。 3.K8S的特性 弹性伸缩
使用命令、UI或者基于CPU使用情况自动快速扩容和缩容程序实例，保证应用业务高峰并发时的高可用性；业务低峰时回收资源，以最小成本运行服务
自我修复
在节点故障时重新启动失败的容器，替换和重新部署，保证预期的副本数量（3台容器运行）；杀死健康检查失败的容器，并且在未准备好之前不会处理客户端的请求，确保线上服务不中断
服务发现和负载均衡
K8S为多个容器提供一个统一的访问入口（内部IP地址和一个DNS名称），并且负载均衡关联的所有容器，使得用户无需考虑容器IP问题
自动发布（默认滚动发布模式）和回滚
K8S采用滚动更新策略更新应用，一次更新一个Pod，而不是同时删除所有的Pod，如果更新过程中出现问题，将回滚更改，确保升级业务不受影响
集中化配置管理和密钥管理
管理机密数据和应用程序配置，而不需要把敏感数据暴露在镜像里，提高敏感数据安全性。并可以将一些常用的配置存储在K8S中，方便应用程序使用
存储编排，支持外挂存储并对外挂存储资源进行编排
挂载外部存储系统，无论是来自本地存储，公有云（如AWS），还是网络存储（如NFS、Glisterfs、Ceph）都作为集群资源的一部分使用，极大提高存储使用灵活性
任务批处理运行
提供一次性任务，定时任务；满足批量数据处理和分析的场景
4.K8S集群架构与组件 K8S是属于主从设备模型（Master-Slave 架构），即有Master 节点负责集群的调度、管理和运维，slave 节点是集群中的运算工作负载节点。
在K8S中，主节点一般被称为Master节点，而从节点则被称为Worker Node节点，每个Node都会被Master分配一些工作负载。
Master组件可以在群集中的任何计算机上运行，但建议Master节点占据一个独立的服务器。因为Master 是整个集群的大脑，如果Master所在节点宕机或不可用，那么所有的控制命令都将失效。除了Master,在K8S集群中的其他机器被称为Worker Node节点，当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上去。
4.1Master组件 Kube-apiserver
用于暴露Kubernetes API，任何资源请求或调用操作都是通过kube-apiserver 提供的接口进行。以HTTP Restful API提供接口服务，所有对象资源的增删改查和监听操作都交给API Server 处理后再提交给Etcd 存储（相当于分布式数据库，以键值对方式存储）。
可以理解成API Server 是K8S的请求入口服务。API server 负责接收K8S所有请求（来自UI界面或者CLI 命令行工具），然后根据用户的具体请求，去通知其他组件干活。可以说API server 是K8S集群架构的大脑。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/385604ddf3638f6be49abd901c57ecc6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-21T17:06:43+08:00" />
<meta property="article:modified_time" content="2022-09-21T17:06:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">K8S概述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="K8S_0"></a>K8S概述</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#K8S_0" rel="nofollow">K8S概述</a></li><li><ul><li><a href="#1K8S_3" rel="nofollow">1.K8S是什么</a></li><li><a href="#2K8S_19" rel="nofollow">2.为什么用K8S</a></li><li><a href="#3K8S_44" rel="nofollow">3.K8S的特性</a></li><li><a href="#4K8S_69" rel="nofollow">4.K8S集群架构与组件</a></li><li><ul><li><a href="#41Master_83" rel="nofollow">4.1Master组件</a></li><li><a href="#42Node_140" rel="nofollow">4.2Node组件</a></li><li><a href="#43K8S_158" rel="nofollow">4.3K8S架构</a></li></ul> 
   </li><li><a href="#5K8S_179" rel="nofollow">5.K8S核心概念</a></li><li><ul><li><a href="#51Pod_185" rel="nofollow">5.1Pod</a></li><li><a href="#52Pod_200" rel="nofollow">5.2Pod控制器</a></li><li><a href="#53Label_217" rel="nofollow">5.3Label</a></li><li><a href="#54LabelLabel_selector_228" rel="nofollow">5.4Label选择器（Label selector）</a></li><li><a href="#55Service_236" rel="nofollow">5.5Service</a></li><li><a href="#56Ingress_252" rel="nofollow">5.6Ingress</a></li><li><a href="#57Name_269" rel="nofollow">5.7Name</a></li><li><a href="#58Namespace_275" rel="nofollow">5.8Namespace</a></li></ul> 
   </li><li><a href="#6K8S_286" rel="nofollow">6.常见的K8S按照部署方式</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1K8S_3"></a>1.K8S是什么</h3> 
<p>K8S 的全称为Kubernetes</p> 
<p><strong>作用：</strong><br> 用于自动部署、扩展和管理“容器化(containerized）应用程序”的开源系统。<br> 可以理解成K8S是负责自动化运维管理多个容器化程序（比如 Docker）的集群，是一个生态极其丰富的容器编排框架工具。</p> 
<p><strong>由来：</strong><br> K8S由google的Borg系统（博格系统，google内部使用的大规模容器编排工具）作为原型，后经GO语言延用Borg的思路重写并捐献给CNCF基金会开源。</p> 
<p><strong>含义：</strong><br> 词根源于希腊语的舵手、飞行员</p> 
<h3><a id="2K8S_19"></a>2.为什么用K8S</h3> 
<p>试想下传统的后端部署办法：把程序包（包括可执行二进制文件、配置文件等）放到服务器上，接着运行启动脚本把程序跑起来，同时启动守护脚本定期检查程序运行状态、必要的话重新拉起程序。<br> 设想一下，如果服务的请求量上来，已部署的服务响应不过来怎么办。传统的做法往往是，如果请求量、内存、CPU超过阈值做了告警，运维人员马上再加几台服务器，部署好服务之后，接入负载均衡来分担已有服务的压力。<br> 这样问题就出现了：从监控告警到部署服务，中间需要人力介入。那么，有没有办法自动完成服务的部署、更新、卸载和扩容、缩容呢？<br> 而这就是K8S要做的事情：自动化运维管理容器化(Docker) 程序。</p> 
<p>K8S的目标是让部署容器化应用简单高效。<br> <strong>K8S解决了裸跑Docker的若干痛点：</strong></p> 
<ul><li>单机使用，无法有效集群</li><li>随着容器数量的上升，管理成本攀升</li><li>没有有效的容灾、自愈机制</li><li>没有预设编排模板，无法实现快速、大规模容器调度</li><li>没有统一的配置管理中心工具</li><li>没有容器生命周期的管理工具</li><li>没有图形化运维管理工具</li></ul> 
<p>K8S是Google开源的容器集群管理系统，在Docker等容器技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。<strong>其主要功能如下：</strong></p> 
<ul><li>使用Docker等容器技术对应用程序包装(package)、实例化（instantiate)、运行（run)</li><li>以集群的方式运行、管理跨机器的容器。</li><li>解决Docker 跨机器容器之间的通讯问题。</li><li>K8S的自我修复机制使得容器集群总是运行在用户期望的状态。</li></ul> 
<h3><a id="3K8S_44"></a>3.K8S的特性</h3> 
<ul><li> <p>弹性伸缩<br> 使用命令、UI或者基于CPU使用情况自动快速扩容和缩容程序实例，保证应用业务高峰并发时的高可用性；业务低峰时回收资源，以最小成本运行服务</p> </li><li> <p>自我修复<br> 在节点故障时重新启动失败的容器，替换和重新部署，保证预期的副本数量（3台容器运行）；杀死健康检查失败的容器，并且在未准备好之前不会处理客户端的请求，确保线上服务不中断</p> </li><li> <p>服务发现和负载均衡<br> K8S为多个容器提供一个统一的访问入口（内部IP地址和一个DNS名称），并且负载均衡关联的所有容器，使得用户无需考虑容器IP问题</p> </li><li> <p>自动发布（默认滚动发布模式）和回滚<br> K8S采用滚动更新策略更新应用，一次更新一个Pod，而不是同时删除所有的Pod，如果更新过程中出现问题，将回滚更改，确保升级业务不受影响</p> </li><li> <p>集中化配置管理和密钥管理<br> 管理机密数据和应用程序配置，而不需要把敏感数据暴露在镜像里，提高敏感数据安全性。并可以将一些常用的配置存储在K8S中，方便应用程序使用</p> </li><li> <p>存储编排，支持外挂存储并对外挂存储资源进行编排<br> 挂载外部存储系统，无论是来自本地存储，公有云（如AWS），还是网络存储（如NFS、Glisterfs、Ceph）都作为集群资源的一部分使用，极大提高存储使用灵活性</p> </li><li> <p>任务批处理运行<br> 提供一次性任务，定时任务；满足批量数据处理和分析的场景</p> </li></ul> 
<h3><a id="4K8S_69"></a>4.K8S集群架构与组件</h3> 
<p>K8S是属于主从设备模型（Master-Slave 架构），即有Master 节点负责集群的调度、管理和运维，slave 节点是集群中的运算工作负载节点。</p> 
<p>在K8S中，主节点一般被称为Master节点，而从节点则被称为Worker Node节点，每个Node都会被Master分配一些工作负载。</p> 
<p>Master组件可以在群集中的任何计算机上运行，但建议Master节点占据一个独立的服务器。因为Master 是整个集群的大脑，如果Master所在节点宕机或不可用，那么所有的控制命令都将失效。除了Master,在K8S集群中的其他机器被称为Worker Node节点，当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上去。</p> 
<p><img src="https://images2.imgbox.com/ae/70/CywGPc6k_o.png" alt="请添加图片描述"></p> 
<h4><a id="41Master_83"></a>4.1Master组件</h4> 
<p><strong>Kube-apiserver</strong><br> 用于暴露Kubernetes API，任何资源请求或调用操作都是通过kube-apiserver 提供的接口进行。以HTTP Restful API提供接口服务，所有对象资源的增删改查和监听操作都交给API Server 处理后再提交给Etcd 存储（相当于分布式数据库，以键值对方式存储）。<br> 可以理解成API Server 是K8S的请求入口服务。API server 负责接收K8S所有请求（来自UI界面或者CLI 命令行工具），然后根据用户的具体请求，去通知其他组件干活。可以说API server 是K8S集群架构的大脑。</p> 
<p><strong>Kube-controller-manager</strong><br> 运行管理控制器，是K8S集群中处理常规任务的后台线程，是K8S集群里所有资源对象的自动化控制中心。<br> 在K8S集群中，一个资源对应一个控制器，而Controller manager 就是负责管理这些控制器的。<br> 由一系列控制器组成，通过API Server监控整个集群的状态，并确保集群处于预期的工作状态，比如当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。</p> 
<p><strong>控制器包括：</strong></p> 
<pre><code>NodeContrpller(节点控制器)
负责在节点出现故障时发现和响应

Replication Controller(副本控制器)
负责保证集群中一个RC(资源对象Replication Controller) 所关联的Pod副本数始终保持预设值。可以理解成确保集群中有且仅有N个Pod实例，N是RC中定义的Pod副本数量

Endpoints Controller(端点控制器)
填充端点对象(即连接Services 和Pods) ，负责监听Service 和对应的Pod 副本的变化。可以理解端点是一个服务暴露出来的访问点，如果需要访问一个服务，则必须知道它的endpoint

Service Account &amp; Token Controllers(服务帐户和令牌控制器)
为新的命名空间创建默认帐户和API访问令牌

ResourceQuotaController(资源配额控制器)
确保指定的资源对象在任何时候都不会超量占用系统物理资源

Namespace Controller(命名空间控制器)
管理namespace的生命周期

Service Controller(服务控制器)
属于K8S集群与外部的云平台之间的一个接口控制器
</code></pre> 
<p><strong>Kube- scheduler</strong><br> 是负责资源调度的进程，根据调度算法为新创建的Pod选择一个合适的Node节点。<br> 可以理解成K8S所有Node 节点的调度器。当用户要部署服务时，scheduler 会根据调度算法选择最合适的Node 节点来部署Pod。</p> 
<ul><li>预算策略（predicate）</li><li>优选策略（priorities）</li></ul> 
<p>API Server 接收到请求创建一批Pod，API Server 会让 Controller-manager 按照所预设的模板去创建Pod，Controller-manager会通过 API Server 去找Scheduler为新创建的 Pod 选择最适合的Node节点。比如运行这个 Pod需要 2C4G的资源，Scheduler 会通过预选策略过滤掉不满足策略的Node节点。Node节点中还剩多少资源是通过汇报给API Server存储在 etcd里，API Server 会调用一个方法找到etcd里所有Node 节点的剩余资源，再对比 Pod 所需要的资源，如果某个 Node节点的资源不足或者不满足<br> 预选策略的条件则无法通过预选。预选阶段筛选出的节点，在优选阶段会根据优先策略为通过预选的 Node节点进行打分排名，选择得分最高的 Node。例如，资源越富裕、负载越小的Node 可能具有越高的排名。</p> 
<p><strong>配置存储中心</strong></p> 
<p><strong>etcd</strong><br> K8S的存储服务。etcd是分布式键值存储系统，存储了K8S的关键配置和用户配置，K8S中仅API Server 才具备读写权限，其他组件必须通过API Server 的接口才能读写数据。</p> 
<h4><a id="42Node_140"></a>4.2Node组件</h4> 
<p><strong>Kubelet</strong><br> Node 节点的监视器，以及与Master 节点的通讯器。Kubelet 是Master 节点安插在Node 节点上的“眼线”，它会定时向API Server汇报自己Node节点上运行的服务的状态，并接受来自Master节点的指示采取调整措施。<br> 从Master节点获取自己节点上Pod的期望状态（比如运行什么容器、运行的副本数量、网络或者存储如何配置等），直接跟容器引擎交互实现容器的生命周期管理，如果自己节点上Pod的状态与期望状态不一致，则调用对应的容器平台接口（即docker的接口）达到这个状态。<br> 管理镜像和容器的清理工作，保证节点上镜像不会占满磁盘空间，退出的容器不会占用太多资源。</p> 
<p><strong>Kube-Proxy</strong><br> 在每个Node节点上实现Pod网络代理，是Kubernetes Service 资源的载体，负责维护网络规则和四层负载均衡工作。负责写入规则至iptables、 ipvs实现服务映射访问的。<br> Kube-Proxy本身不是直接给Pod提供网络，Pod 的网络是由Kubelet 提供的，Kube-Proxy 实际上维护的是虚拟的Pod集群网络。<br> Kube-apiserver通过监控Kube-Proxy 进行对Kubernetes Service的更新和端点的维护。<br> 在K8S集群中微服务的负载均衡是由Kube-proxy实现的。Kube-proxy是K8S集群内部的负载均衡器。它是一个分布式代理服务器，在K8S的每个节点上都会运行一个Kube-proxy 组件。</p> 
<p><strong>docker或rocket</strong><br> 容器引擎，运行容器，负责本机的容器创建和管理工作。</p> 
<h4><a id="43K8S_158"></a>4.3K8S架构</h4> 
<p><img src="https://images2.imgbox.com/78/16/p4qTRteP_o.png" alt="请添加图片描述"></p> 
<p>个人小结：</p> 
<p>kubectl是客户端命令行管理工具，比如创建一个pod<br> 1.首先请求会经过Auth认证，然后传递给API-Server进行处理<br> 2.API-Server是所有请求的统一入口，API-Server会把请求的数据存储在Etcd中<br> 3.然后到controller-manager ，controller-manager会按照指令模板创建副本<br> 4.Controller-manager 会通过 API Server 去找 Scheduler 为新创建的 Pod 选择最适合的 Node 节点<br> 5.API-Server从etcd获取node节点信息，先通过scheduler的预算策略进行简单的筛选，筛选符合条件的node节点，再通过优选策略进行比较打分，选择优先级最高的node，通过scheduler进行调度<br> 6.Controller-manager通过API-Server到node节点去创建pod，kubelet收到信息后会和docker进行交互，告知docker如何创建，docker接到指令之后进行创建，创建完之后信息返回给kubelet<br> 7.kubelet会实时将信息通过API-Server存储在etcd中<br> 8.如果需要对外，要通过kube-proxy创建网络规则，通过ipvs的方式实现4层负载均衡功能，实现服务的映射访问</p> 
<h3><a id="5K8S_179"></a>5.K8S核心概念</h3> 
<p>Kubernetes包含多种类型的资源对象: Pod、 Label、 Service、 Replication Controller等。<br> 所有的资源对象都可以通过Kubernetes 提供的kubectl 工具进行增、删、改、查等操作，并将其保存在etcd中持久化存储。<br> Kubernets其实是一个高度自动化的资源控制系统，通过跟踪对比etcd存储里保存的资源期望状态与当前环境中的实际资源状态的差异，来实现自动控制和自动纠错等高级功能</p> 
<h4><a id="51Pod_185"></a>5.1Pod</h4> 
<p>Pod是Kubernetes 创建或部署的最小/最简单的基本单位，一个Pod 代表集群上正在运行的一个进程。<br> 可以把Pod理解成豌豆荚，而同一Pod内的每个容器是一颗颗豌豆。<br> 一个Pod由一个或多个容器组成，Pod 中容器共享网络、存储和计算资源，在同一台Docker 主机上运行。<br> 一个Pod 里可以运行多个容器，又叫边车模式（sideCara）模式。而在生产环境中一般都是单个容器或者具有强关联互补的多个容器组成一个Pod。<br> 同一个Pod之间的容器可以通过localhost 互相访问，并且可以挂载Pod内所有的数据卷;但是不同的Pod之间的容器不能用localhost访问，也不能挂载其他Pod的数据卷。</p> 
<p><img src="https://images2.imgbox.com/ac/e5/jZOz77Nq_o.png" alt="请添加图片描述"></p> 
<h4><a id="52Pod_200"></a>5.2Pod控制器</h4> 
<p>Pod控制器是Pod 启动的一种模版，用来保证在K8S里启动的Pod 应始终按照用户的预期运行(副本数、生命周期、健康状态检查等)</p> 
<p>K8S内提供了众多的Pod 控制器，常用的有以下几种:</p> 
<table><thead><tr><th align="left">控制器</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Deployment</td><td align="left">无状态应用部署。Deployment 的作用是管理和控制Pod 和ReplicaSet, 管控它们运行在用户期望的状态中</td></tr><tr><td align="left">Replicaset</td><td align="left">确保预期的Pod 副本数量。ReplicaSet 的作用就是管理和控制Pod, 管控他们好好干活。但是，Replicaset 受控于Deployment</td></tr><tr><td align="left">Daemonset</td><td align="left">确保所有节点运行同一类Pod，保证每个节点上都有一个此类Pod运行，通常用于实现系统级后台任务</td></tr><tr><td align="left">Statefulset</td><td align="left">有状态应用部署一次性任务</td></tr><tr><td align="left">Job</td><td align="left">一次性任务。根据用户的设置，Job 管理的Pod把任务成功完成就自动退出了</td></tr><tr><td align="left">Cronjob</td><td align="left">周期性计划性任务</td></tr></tbody></table> 
<h4><a id="53Label_217"></a>5.3Label</h4> 
<p>标签，是K8S特色的管理方式，便于分类管理资源对象。<br> Label可以附加到各种资源对象上，例如Node、Pod、Service、RC等，用于关联对象、查询和筛选。<br> 一个Label是一个key-value 的键值对，其中key与value 由用户自己指定。<br> 一个资源对象可以定义任意数量的Label，同一个Label也可以被添加到任意数量的资源对象中，也可以在对象创建后动态添加或者删除。<br> 可以通过给指定的资源对象捆绑一个或多个不同的Label，来实现多维度的资源分组管理功能。</p> 
<p>与Label 类似的，还有Annotation （注释）<br> 区别在于有效的标签值必须为63个字符或更少，并且必须为空或以字母数字字符( [a-z0-9A-Z])开头和结尾，中间可以包含横杠(-)、下划线(_)、点(.)和字母或数字。注释值则没有字符长度限制。</p> 
<h4><a id="54LabelLabel_selector_228"></a>5.4Label选择器（Label selector）</h4> 
<p>给某个资源对象定义一个Label，就相当于给它打了一个标签；随后可以通过标签选择器(Label selector)查询和筛选拥有某些Label的资源对象。</p> 
<p>标签选择器目前有两种:基于等值关系(等于、不等于)和基于集合关系(属于、不属于、存在)。</p> 
<h4><a id="55Service_236"></a>5.5Service</h4> 
<p>在K8S的集群里，虽然每个Pod会被分配一个单独的IP地址，但由于pod是有生命周期的(它们可以被创建，而且销毁之后不会再启动)，随时可能会因为业务的变更，导致这个IP地址也会随着Pod的销毁而消失。</p> 
<p>Service就是用来解决这个问题的核心概念</p> 
<p>K8S 中的Service 并不是我们常说的“服务”的含义，而更像是网关层，可以看作一组提供相同服务的Pod的对外访问接口、流量均衡器。<br> Service作用于哪些Pod 是通过标签选择器来定义的。<br> 在K8S集群中，Service 可以看作一组提供相同服务的Pod的对外访问接口。客户端需要访问的服务就是Service 对象。每个Service都有一个固定的虚拟ip（这个ip也被称为Cluster IP），自动并且动态地绑定后端的Pod,所有的网络请求直接访问Service 的虚拟ip，Service会自动向后端做转发。<br> Service除了提供稳定的对外访问方式之外，还能起到负载均衡（Load Balance）的功能，自动把请求流量分布到后端所有的服务上，Service可以做到对客户透明地进行水平扩展（scale）。<br> 而实现service 这一功能的关键，就是kube-proxy。kube-proxy 运行在每个节点上，监听API server 中服务对象的变化，<br> 可通过以下三种流量调度模式：userspace （废弃）、iptables （濒临废弃）、ipvs （推荐，性能最好）来实现网络的转发。<br> Service是K8S 服务的核心，屏蔽了服务细节，统一对外暴露服务接口，真正做到了“微服务”。比如我们的一个服务A，部署了3个副本，也就是3个Pod；<br> 对于用户来说，只需要关注一个Service的入口就可以，而不需要操心究竞应该请求哪一 个Pod。<br> 优势非常明显：一方面外部用户不需要感知因为Pod上服务的意外崩溃、K8S重新拉起Pod 而造成的IP变更，外部用户也不需要感知因升级、变更服务带来的Pod替换而造成的IP变化。</p> 
<h4><a id="56Ingress_252"></a>5.6Ingress</h4> 
<p>Service主要负责K8S集群内部的网络拓扑，那么集群外部怎么访问集群内部呢？这个时候就需要Ingress 了。<br> Ingress 是整个K8S集群的接入层，负责集群内外通讯。<br> Ingress是K8S集群里工作在OSI网络参考模型下，第7层的应用，对外暴露的接口，典型的访问方式是http/https 。<br> Service只能进行第四层的流量调度，表现形式是ip+port。 Ingress 则可以调度不同业务域、不同URL访问路径的业务流量。<br> 比如：客户端请求http://www . lwb. com: port—&gt; Ingress —&gt; Service —&gt; Pod</p> 
<p><img src="https://images2.imgbox.com/ba/5d/wUcE6tE0_o.png" alt="请添加图片描述"></p> 
<h4><a id="57Name_269"></a>5.7Name</h4> 
<p>由于K8S 内部，使用“资源”来定义每一种逻辑概念(功能)，所以每种“资源”，都应该有自己的“名称”。<br> “资源”有api 版本（apiversion） 、类别（kind）、元数据（metadata）、定义清单（spec）、状态（status） 等配置信息。<br> “名称”通常定义在“资源”的“元数据”信息里。在同一个namespace 空间中必须是唯一 的。</p> 
<h4><a id="58Namespace_275"></a>5.8Namespace</h4> 
<p>随着项目增多、人员增加、集群规模的扩大，需要一种能够逻辑上隔离K8S内各种“资源”的方法，这就是Namespace。<br> Namespace是为了把一个K8S集群划分为若千个资源不可共享的虛拟集群组而诞生的。<br> 不同Namespace 内的“资源”名称可以相同，相同Namespace 内的同种“资源”，“名称”不能相同。<br> 合理的使用K8S的Namespace，可以使得集群管理员能够更好的对交付到K8S里的服务进行分类管理和浏览。<br> K8S里默认存在的Namespace 有: default、 kube-system、 kube-public 等。<br> 查询R8S里特定“资源”要带上相应的Namespace</p> 
<h3><a id="6K8S_286"></a>6.常见的K8S按照部署方式</h3> 
<p><strong>1.Mini kube</strong><br> Minikube是一个工具，可以在本地快速运行一个单节点微型K8S，仅用于学习、预览K8S的一些特性使用。<br> 部署地址： https://kubernetes.io/docs/setup/minikube<br> <strong>2.Kubeadmin</strong><br> Kubeadmin也是一个工具，提供kubeadm init和kubeadm join， 用于快速部署K8S集群，相对简单。<br> https://kubernetes.io/docs/setup/minikube<br> <strong>3.二进制安装部署</strong><br> 生产首选，从官方下载发行版的二进制包，手动部署每个组件和自签TLS证书，组成K8S集群，新手推荐。<br> https://kubernetes.io/docs/setup/minikube</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13d653d1a944d7c364a67b64c4e4278f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android地图集成以及基础功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6018e0596fc5afffa64c2929b2a7d2b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第二章 学生指导(04 小学德育 05 小学美育 06 小学生安全与心理健康教育 07 学校与家庭、社会的协调)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>