<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>认识和学习orchestrator之基本使用篇 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="认识和学习orchestrator之基本使用篇" />
<meta property="og:description" content="01
介绍
orchestrator目前GitHub上star 4.5k&#43;，非常适用于有多个数据中心MySQL集群的管理。该工具使用起来很简单，但能用好却不容易，其配置参数将近200个，后端存储表47张，下面将介绍orchestrator以及它的使用方法。
02
orchestrator是什么
2.1 功能
其是一个管理MySQL复制拓扑的高可用、管理、可视化的工具。会定时采集探测到的各个实例的元数据信息，并将其存储在后端的DB库中。后端库支持的DB类型有SQLite和MySQL两种。
相比较于MHA等常用管理工具，其支持高可用部署，并对故障进行一个完整的探测分析后才会做相应的故障转移，探测更精准、全面。
依赖于采集的各个实例的元数据信息，其具有如下功能和特色：
发现实例
通过指定复制集集群里任意一个节点实例，其可以主动遍历该复制集的拓扑结构，还能读取MySQL的相关信息，如复制信息、配置、状态信息等；
重构拓扑结构
对已经发现的复制集集群，其可以通过命令、图形化的拖拽等方式，对现有复制集的关系进行重构；
故障恢复
orchestrator通过一个整体的方式来探测Master或者中间库的故障，支持优雅切换、自动故障切换、手动强制切换等多种故障切换方式；
2.2 部署架构
测试环境中，使用单点即可。orchestrator本身基于 Raft 实现高可用，避免了单点故障问题。部署架构支持单点、半高可用、高可用等多种方式。关于部署架构，后面会单独介绍下。
生产推荐的部署架构
共享后端库架构
raft部署架构
03
相关配置
3.1 orchestrator后端库的配置和权限
orchestrator对各个实例的采集信息会存储在后端库中，后端库只供orchestrator自己本身使用，可做如下的配置：
MySQL 由于orchestrator会在后端创建一些表，且创建的库是由orchestrator自身使用，可以直接赋权库的all权限；
CREATE DATABASE IF NOT EXISTS orchestrator; CREATE USER &#39;orch_backend&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;orch_backend_password&#39;; GRANT ALL PRIVILEGES ON `orchestrator`.* TO &#39;orch_backend&#39;@&#39;127.0.0.1&#39;; orchestrator.conf.json的配置
针对后端库的认证配置，使用如下参数进行配置
{ &#34;MySQLOrchestratorHost&#34;: &#34;127.0.0.1&#34;, &#34;MySQLOrchestratorPort&#34;: 3306, &#34;MySQLOrchestratorMaxPoolConnections&#34;: 4, &#34;MySQLOrchestratorDatabase&#34;: &#34;orchestrator&#34;, &#34;MySQLOrchestratorUser&#34;: &#34;orch_backend&#34;, &#34;MySQLOrchestratorPassword&#34;: &#34;orch_backend_password&#34;, &#34;MySQLOrchestratorUseMutualTLS&#34;: false, } 还可以使用MySQLOrchestratorCredentialsConfigFile参数，指定一个类似." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/371eda0cfaea2278472c65ce9bc7c70e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-21T19:54:06+08:00" />
<meta property="article:modified_time" content="2022-04-21T19:54:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">认识和学习orchestrator之基本使用篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p><strong>01</strong></p> 
 <p><strong>介绍</strong></p> 
 <p style="text-align:justify;">orchestrator目前GitHub上star 4.5k+，非常适用于有多个数据中心MySQL集群的管理。该工具使用起来很简单，但能用好却不容易，其配置参数将近200个，后端存储表47张，下面将介绍orchestrator以及它的使用方法。</p> 
 <p><strong>02</strong></p> 
 <p><strong>orchestrator是什么</strong></p> 
 <p><strong>2.1 </strong><strong>功能</strong></p> 
 <p style="text-align:justify;">其是一个管理MySQL复制拓扑的高可用、管理、可视化的工具。会定时采集探测到的各个实例的元数据信息，并将其存储在后端的DB库中。后端库支持的DB类型有SQLite和MySQL两种。<br></p> 
 <p style="text-align:justify;">相比较于MHA等常用管理工具，其支持高可用部署，并对故障进行一个完整的探测分析后才会做相应的故障转移，探测更精准、全面。</p> 
 <p style="text-align:justify;">依赖于采集的各个实例的元数据信息，其具有如下功能和特色：</p> 
 <p style="text-align:left;"><strong>发现实例</strong></p> 
 <p style="text-align:justify;">通过指定复制集集群里任意一个节点实例，其可以主动遍历该复制集的拓扑结构，还能读取MySQL的相关信息，如复制信息、配置、状态信息等；</p> 
 <p style="text-align:justify;"><strong>重构拓扑结构</strong></p> 
 <p style="text-align:justify;">对已经发现的复制集集群，其可以通过命令、图形化的拖拽等方式，对现有复制集的关系进行重构；</p> 
 <p style="text-align:justify;"><strong>故障恢复</strong></p> 
 <p style="text-align:justify;">orchestrator通过一个整体的方式来探测Master或者中间库的故障，支持优雅切换、自动故障切换、手动强制切换等多种故障切换方式；</p> 
 <p><strong>2.2 部署架构</strong></p> 
 <p style="text-align:justify;">测试环境中，使用单点即可。orchestrator本身基于 Raft 实现高可用，避免了单点故障问题。部署架构支持单点、半高可用、高可用等多种方式。关于部署架构，后面会单独介绍下。<br></p> 
 <p style="text-align:justify;"><strong>生产推荐的部署架构</strong></p> 
 <p style="text-align:justify;"><strong>共享后端库架构</strong></p> 
 <p style="text-align:justify;"><img src="https://images2.imgbox.com/ff/41/S1wL7NDO_o.png" alt="7bf3dc6119200973a321cdc0c56fb215.png"></p> 
 <p><strong></strong><strong>raft部署架构</strong></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/18/ac/IOfpxjPk_o.png" alt="ec92dd8d1ebdab952eb7d140947847bb.png"></p> 
 <p><strong>03</strong></p> 
 <p><strong>相关配置</strong></p> 
 <p><strong>3.1</strong><strong> </strong><strong>orchestrator后端库的配置和权限</strong></p> 
 <p style="text-align:justify;">orchestrator对各个实例的采集信息会存储在后端库中，后端库只供orchestrator自己本身使用，可做如下的配置：</p> 
 <h5><strong>MySQL</strong></h5> 
 <p style="text-align:justify;">由于orchestrator会在后端创建一些表，且创建的库是由orchestrator自身使用，可以直接赋权库的all权限；</p> 
 <pre class="has"><code class="language-sql">CREATE DATABASE IF NOT EXISTS orchestrator;
CREATE USER 'orch_backend'@'127.0.0.1' IDENTIFIED BY 'orch_backend_password';
GRANT ALL PRIVILEGES ON `orchestrator`.* TO 'orch_backend'@'127.0.0.1';</code></pre> 
 <p style="text-align:justify;"><strong>orchestrator.conf.json的配置</strong></p> 
 <p style="text-align:justify;">针对后端库的认证配置，使用如下参数进行配置</p> 
 <pre class="has"><code class="language-json">{
  "MySQLOrchestratorHost": "127.0.0.1",
  "MySQLOrchestratorPort": 3306,
  "MySQLOrchestratorMaxPoolConnections": 4,
  "MySQLOrchestratorDatabase": "orchestrator",
  "MySQLOrchestratorUser": "orch_backend",
  "MySQLOrchestratorPassword": "orch_backend_password",


  "MySQLOrchestratorUseMutualTLS": false,
}</code></pre> 
 <p style="text-align:left;">还可以使用MySQLOrchestratorCredentialsConfigFile参数，指定一个类似.my.cnf文件格式的配置文件</p> 
 <pre class="has"><code class="language-makefile">{
  "MySQLOrchestratorCredentialsConfigFile": "/etc/mysql/orchestrator-backend.cnf",
}


## 配置文件格式
cat /etc/mysql/orchestrator-backend.cnf
[client]
user=orch_backend
password=orch_backend_password
host=127.0.0.1
port=3306</code></pre> 
 <h5>‍<strong>SQLite</strong></h5> 
 <p style="text-align:justify;">orchestrator后端库还支持SQLite，SQLite默认已经嵌入到orchestrator，只需在配置参数中指定即可运行。</p> 
 <pre class="has"><code class="language-json">{
  "BackendDB": "sqlite",
  "SQLite3DataFile": "/var/lib/orchestrator/orchestrator.db",  
}</code></pre> 
 <p>‍</p> 
 <p><strong>3.2 </strong>配置要管理的MySQL库</p> 
 <p style="text-align:justify;">orchestrator在指定的探测间隔内，会对每一个管理的MySQL实例进行探测来收集相关信息，需要创建相应的账号</p> 
 <pre class="has"><code class="language-json">{
  "MySQLTopologyUser": "orch",
  "MySQLTopologyPassword": "orch",
  "MySQLTopologyCredentialsConfigFile": "",
  "MySQLTopologyUseMixedTLS": false,
}</code></pre> 
 <p style="text-align:justify;">‍<strong>MySQLTopologyCredentialsConfigFile参数</strong></p> 
 <p style="text-align:left;">用法同MySQLOrchestratorCredentialsConfigFile参数</p> 
 <p style="text-align:justify;"><strong>MySQLTopologyUseMixedTLS参数</strong></p> 
 <p style="text-align:justify;">如果在实例发现时，报如下错误，则因为启用了TLS，该参数默认值为true，且默认并没有在orchestrator.conf.json文件中配置，需要手动添加下并设置其为false</p> 
 <pre class="has"><code class="language-sql">ERROR ReadTopologyInstance(xxxx:3306) show global status like 'Uptime': TLS requested but server does not support TLS</code></pre> 
 <p style="text-align:justify;"><strong>对应的权限</strong></p> 
 <pre class="has"><code class="language-sql">CREATE USER 'orch'@'orch_host' IDENTIFIED BY 'orch_topology_password';
GRANT SUPER, PROCESS, REPLICATION SLAVE, RELOAD ON *.* TO 'orch'@'orch_host';
GRANT SELECT ON mysql.slave_master_info TO 'orch'@'orch_host';


-- Only for NDB Cluster
GRANT SELECT ON ndbinfo.processes TO 'orch'@'orch_host';</code></pre> 
 <p style="text-align:justify;">‍<strong>关于mysql.slave_master_info表的查询权限</strong></p> 
 <p style="text-align:justify;">在基于MySQL社区版本的MySQL实例中，通过读取该表的信息，获取用户名和密码，以此来重构主从关系。</p> 
 <p style="text-align:justify;">但该权限不是必须的，如果生产环境中的主从账号比较固定，还可以通过ReplicationCredentialsQuery参数来配置一个查询参数，来获取用户名和密码等信息；</p> 
 <p style="text-align:justify;">该参数需要返回一个单行5列的查询值，分别对应User、Password、SSLCaCert、SSLCert、SSLKey；</p> 
 <p style="text-align:justify;">如果db中没有mysql.slave_master_info表或者不想给该表的select权限，则可以按照如下方式进行配置</p> 
 <pre class="has"><code class="language-json">{
    "ReplicationCredentialsQuery": "select 'rep','rep','','','';",
}</code></pre> 
 <p><strong>3.3 主从复制</strong></p> 
 <p style="text-align:justify;">故障探测使用MySQL拓扑本身作为信息来源，所以还需要对MySQL的复制做一些配置，以便能快速的判断。</p> 
 <pre class="has"><code class="language-sql">-- 设置从库等待主库发送数据或者心跳的超时时间
set global slave_net_timeout = 4;


-- change master to 设置尝试连接的间隔秒数和尝试连接的次数
CHANGE MASTER TO MASTER_CONNECT_RETRY=1, MASTER_RETRY_COUNT=86400;</code></pre> 
 <h4><br></h4> 
 <p><strong>04</strong></p> 
 <p><strong>安装和启动</strong></p> 
 <p style="text-align:justify;">orchestrator采用golang进行编写，可以直接在官网上下载二进制包进行部署即可。</p> 
 <p><strong>4.1 下载和安装</strong></p> 
 <pre class="has"><code class="language-bash">sudo mkdir -p /usr/local
sudo cd /usr/local
sudo tar xzfv orchestrator-3.2.6-linux-amd64.tar.gz</code></pre> 
 <p>‍</p> 
 <p><strong>4.2 配置文件</strong></p> 
 <p style="text-align:justify;">orchestrator启动时，会读取一个json格式的配置文件，可以通过-config参数来指定具体的配置文件，如果不指定该参数，则orchestrator默认读取配置文件的路径依次为：</p> 
 <ul><li><p>/etc/orchestrator.conf.json</p></li><li><p>orchestrator家目录下的conf/orchestrator.conf.json</p></li><li><p>orchestrator家目录下的orchestrator.conf.json</p></li></ul> 
 <p style="text-align:justify;">orchestrator的参数将近200个，大部分的配置参数可以先忽略，可以先使用orchestrator-sample.conf.json示例配置文件，并做一些简单的更改。</p> 
 <p><strong>4.3 运行和启动</strong></p> 
 <p style="text-align:justify;">orchestrator是已编译的二进制文件，可以直接运行。</p> 
 <pre class="has"><code class="language-shell">## 二进制直接运行
nohup ./orchestrator http &amp;


## 指定配置文件运行
nohup ./orchestrator -config ./orchestrator.conf.json http &amp;


## systemd方式运行
systemctl start orchestrator</code></pre> 
 <p>‍<strong>05</strong></p> 
 <p><strong>故障探测</strong></p> 
 <p style="text-align:justify;">orchestrator使用整体的比较全面的方法来检测master或者intermediate master是否故障，并对故障类型做相应的分析分类。</p> 
 <p style="text-align:justify;">其充分利用复制拓扑，不仅观察master本身，还观察它的replicas，如要针对一个dead master类型的判定，必须同时满足以下情况，才会将集群判定为DeadMaster：</p> 
 <ul><li><p>连不上master；</p></li><li><p>能够连上master的副本，并且所有的副本均不能连接到master；</p></li></ul> 
 <p><strong>5.1 常见的故障分析类型</strong></p> 
 <p style="text-align:justify;">orchestrator通过分析后端采集信息，来对故障探测的类型做分析，实例采集间隔由InstancePollSeconds参数控制。</p> 
 <p style="text-align:justify;">常见的故障类型分析：</p> 
 <p style="text-align:justify;"><strong>DeadMasterWithoutReplicas</strong></p> 
 <p style="text-align:justify;">最近一次检查master为不可达，且没有从库；这种情况说明master是一个故障单点。</p> 
 <p style="text-align:justify;"><strong>DeadMaster</strong></p> 
 <p style="text-align:justify;">最近一次检查master为不可达、且其所有的从库最近一次检查都可达、从库全无复制；这种情况说明master故障，如果配置了自动故障转移，则会执行。</p> 
 <p style="text-align:justify;"><strong>DeadMasterAndReplicas</strong></p> 
 <p style="text-align:justify;">最近一次检查master为不可达、且其所有的从库最近一次检查都不可达、从库全无复制；这种情况可能是orchestrator自身的问题；</p> 
 <p style="text-align:justify;"><strong>DeadMasterAndSomeReplicas</strong></p> 
 <p style="text-align:justify;">最近一次检查master为不可达、且其部分从库可达，从库全无复制；当master所在的数据中心有问题时则可能出现这种情况，如果配置了自动故障转移，则会执行；</p> 
 <p style="text-align:justify;"><strong>UnreachableMasterWithLaggingReplicas</strong></p> 
 <p style="text-align:justify;">最近一次检查master为不可达、且所有的从库都有延迟；部分从库有复制；这种情况说明master可能处于濒死的边缘，等待下一个轮询的判定；</p> 
 <p style="text-align:justify;"><strong>UnreachableMaster</strong></p> 
 <p style="text-align:justify;">以下两种情况均判定为该类型：</p> 
 <p style="text-align:justify;">最近一次检查master为不可达、且其部分从库可达、部分从库有复制；</p> 
 <p style="text-align:justify;">最近一次检查master为不可达，但部分检查有效，部分从库可达，部分从库有复制；</p> 
 <p style="text-align:justify;">这种情况说明master可能处于濒死的边缘，等待下一个轮询的判定；</p> 
 <p style="text-align:justify;"><strong>NoWriteableMasterStructureWarning</strong></p> 
 <p style="text-align:justify;">检查master可达，且处于只读状态，并且其有从库可达，同时配置了RecoverNonWriteableMaster参数；</p> 
 <p style="text-align:justify;">这种情况很明显主库设置了只读属性，如果配置RecoverNonWriteableMaster参数为true，则orchestrator会将master的只读属性摘除；</p> 
 <p style="text-align:justify;"><strong>MasterSingleReplicaNotReplicating</strong></p> 
 <p style="text-align:justify;">检查master可达，且其唯一的一个从库可达，但停止了复制；这种情况说明唯一的从库复制线程有问题；</p> 
 <p style="text-align:justify;"><strong>MasterSingleReplicaDead</strong></p> 
 <p style="text-align:justify;">检查master可达，且其唯一的一个从库不可达；这种情况说明唯一的从库有问题；</p> 
 <p style="text-align:justify;"><strong>AllMasterReplicasNotReplicating</strong></p> 
 <p style="text-align:justify;">检查master可达，且所有的从库可达，但都停止了复制；这种情况说明主从的复制线程有问题；</p> 
 <p style="text-align:justify;"><strong>其他类型</strong></p> 
 <p style="text-align:justify;">除此以外，还有很多其他的类型，如关于半同步的、级联复制拓扑结构中的中间库状态的等等，详细的其他类型可在GetReplicationAnalysis函数中查看；</p> 
 <h4><br></h4> 
 <p><strong>06</strong></p> 
 <p><strong>检查和恢复</strong></p> 
 <p style="text-align:justify;">在分析完当前MySQL的故障类型后，orchestrator会对不同的场景分析做不同的处理：</p> 
 <p style="text-align:justify;"><strong>checkAndRecoverDeadMaster</strong></p> 
 <p style="text-align:left;">针对DeadMaster、DeadMasterAndSomeReplicas场景的分析，则可能会执行checkAndRecoverDeadMaster函数，来决定是否要采取恢复流程；</p> 
 <p style="text-align:justify;"><strong>checkAndRecoverNonWriteableMaster</strong></p> 
 <p style="text-align:left;">针对NoWriteableMasterStructureWarning场景的分析，尝试使用该流程进行恢复；</p> 
 <p style="text-align:justify;"><strong>checkAndRecoverGenericProblem</strong></p> 
 <p style="text-align:left;">是一个通用的问题检查恢复，不做具体动作。针对DeadMasterAndReplicas、UnreachableMaster、UnreachableMasterWithLaggingReplicas、AllMasterReplicasNotReplicating、AllMasterReplicasNotReplicatingOrDead这些场景的分析，会使用该恢复流程做处理；</p> 
 <h6>其他场景类型</h6> 
 <p style="text-align:justify;">除以上外，针对半同步、级联中间库、双主、MGR等场景，都会有不同的恢复流程来处理。</p> 
 <p><strong>07</strong></p> 
 <p><strong>故障切换</strong></p> 
 <p style="text-align:justify;">orchestrator支持优雅切换、自动故障切换、手动强制切换等多种故障切换方式。</p> 
 <p><strong>7.1 自动恢复</strong></p> 
 <p style="text-align:justify;">在满足故障探测、相关分析、和设置切换的条件后，orchestrator会对主库所有的从库做一个全面的综合考量，如考虑从库执行的位置点、数据中心、版本的兼容、binlog格式、是否满足相应的参数、promotion_rule规则的判定等等，来寻找一个符合设定条件的候选节点并尝试提升其为新的主库，从而完成自动故障恢复；</p> 
 <p style="text-align:justify;">关于候选节点的选取流程，后面会单独介绍。</p> 
 <p><strong>7.2 优雅的、有计划的恢复</strong></p> 
 <p style="text-align:justify;">在计划范围内的，可以通过graceful-master-takeover和graceful-master-takeover-auto这两个命令来做恢复；</p> 
 <p style="text-align:justify;">graceful-master-takeover与graceful-master-takeover-auto的区别在于老主库作为新主库的从库，是否会开启复制，前者不会开启，后者会自动开启；</p> 
 <p><strong>7.3 手动恢复</strong></p> 
 <p style="text-align:justify;">使用recover和recover-lite命令来做恢复,自动恢复也是使用该命令；</p> 
 <p style="text-align:justify;">两者的区别在于recover-lite不会执行hooks定义的脚本;</p> 
 <p><strong>7.4 手动强制恢复、故障转移</strong></p> 
 <p style="text-align:justify;">使用force-master-failover和force-master-takeover命令来强制故障恢复；</p> 
 <p style="text-align:justify;"><strong>force-master-failover</strong></p> 
 <p style="text-align:justify;">丢弃master并强制启动一个故障转移，该操作是让orchestrator自己选择一个合适的从库来替换master；</p> 
 <p style="text-align:justify;"><strong>force-master-takeover</strong></p> 
 <p style="text-align:justify;">丢弃master并强制启动故障转移，该操作是将人为指定的从库作为新master,区别于force-master-failover；</p> 
 <p><strong>7.5 防止摇摆</strong></p> 
 <p style="text-align:left;">在一些场景下，当完成一次故障恢复后，可能短时间内又发生了一次相同的故障，orchestrator通过RecoveryPeriodBlockSeconds参数来阻止下一次恢复的发生，该参数默认设置为3600秒。</p> 
 <p><strong>7.6 故障后的ack</strong></p> 
 <p style="text-align:justify;">针对一次自动恢复后的，还可以通过ack方式确认后，让其继续执行故障恢复。</p> 
 <p style="text-align:justify;">ack-all-recoveries表示ack全部的故障恢复；</p> 
 <p style="text-align:justify;">ack-cluster-recoveries表示ack指定的集群故障恢复；</p> 
 <p style="text-align:justify;">ack-instance-recoveries表示ack指定的实例故障恢复；</p> 
 <p><strong>08</strong></p> 
 <p><strong>hooks</strong></p> 
 <p style="text-align:justify;">orchestrator支持在故障检测、故障切换之前、故障切换后等阶段自定义脚本，以通过hooks的方式来做一些额外的处理动作；</p> 
 <p style="text-align:justify;">hooks支持一个数组参数，即可以在任意一个hooks中，可以定义多个脚本；</p> 
 <p><strong>8.1 脚本处理说明</strong></p> 
 <ul><li><p>如果process数组中的脚本以&amp;结尾，则脚本将会被异步执行，执行状态会被忽略，不影响整体流程；</p></li><li><p>如果process数组中的搅拌不以&amp;结尾，则执行时脚本任意一步退出状态码不为0，则会终止整个流程；</p></li><li><p>hooks中指定多个脚本时，orchestrator将按照脚本定义的顺序来执行；</p></li><li><p>orchestrator同时也支持一些参数和执行变量，以便供自定义的脚本引用，具体可参考官方文档；</p></li></ul> 
 <p><strong>8.2 支持的hooks有如下几种</strong></p> 
 <p style="text-align:justify;"><strong>PreGracefulTakeoverProcesses</strong></p> 
 <p style="text-align:justify;">在执行graceful master takeover切换前被调用；</p> 
 <p style="text-align:justify;"><strong>PreFailoverProcesses</strong></p> 
 <p style="text-align:justify;">在执行恢复动作之前被调用；</p> 
 <p style="text-align:justify;"><strong>PostMasterFailoverProcesses</strong></p> 
 <p style="text-align:justify;">在Master故障成功恢复后调用；</p> 
 <p style="text-align:justify;"><strong>PostIntermediateMasterFailoverProcesses</strong></p> 
 <p style="text-align:justify;">在中间master或者replication group的成员成功恢复后调用；</p> 
 <p style="text-align:justify;"><strong>PostFailoverProcesses</strong></p> 
 <p style="text-align:justify;">在任意恢复成功之后调用(包括PostMasterFailoverProcesses和PostIntermediateMasterFailoverProcesses)；</p> 
 <p style="text-align:justify;"><strong>PostUnsuccessfulFailoverProcesses</strong></p> 
 <p style="text-align:justify;">在任意未完全成功恢复之后调用；</p> 
 <p style="text-align:justify;"><strong>PostGracefulTakeoverProcesses</strong></p> 
 <p style="text-align:justify;">在执行graceful master takeover切换后被调用；</p> 
 <p style="text-align:justify;">在成功执行take-master之后，执行的动作</p> 
 <p style="text-align:justify;">在探测到故障时被调用；</p> 
 <p style="text-align:justify;"><strong>PostTakeMasterProcesses</strong></p> 
 <p style="text-align:justify;">在成功执行take-master之后，被调用；</p> 
 <p><strong>8.3 </strong><strong>Hooks的参数和环境</strong></p> 
 <p style="text-align:justify;">orchestrator为所有的hooks提供failure/recovery(故障/恢复)相关信息变量，如认证失败的实例、认证提升master的实例、影响的副本、故障的类型、集群的名称等；</p> 
 <p style="text-align:justify;"><strong>简单举例</strong></p> 
 <pre class="has"><code class="language-cs">## 以下为提供的部分参数，可以在脚本中以占位符的方式进行引用
{failureType}
// 失败的类型


{instanceType}
// 实例的类型,输出的值有("master", "co-master", "intermediate-master")


{isMaster} 
// 是否为master 输出的值有：(true/false)


{isCoMaster} (true/false)


{failureDescription}
// 输出故障描述


{failedHost}
// 输出失败的主机


{failedPort}
// 输出失败的端口


{failureCluster}
// 失败的集群名


{failureClusterAlias}
// 失败的集群别名


{failureClusterDomain}
// 失败的集群域名


{countReplicas} (replaces {countSlaves})
// 副本的数量,替代countSlaves</code></pre> 
 <p>‍</p> 
 <p style="text-align:justify;"><strong>引用示例</strong></p> 
 <p style="text-align:justify;">这些信息变量可以通过环境变量或脚本中特殊引用两种方式被引用：</p> 
 <pre class="has"><code class="language-json">{
  "PreGracefulTakeoverProcesses": [
    "echo 'Planned takeover about to take place on {failureCluster}. Master will switch to read_only' &gt;&gt; /tmp/recovery.log",
    "scripts/send_alarm.sh &amp;",
  ],   
}</code></pre> 
 <h4>‍<br></h4> 
 <p><strong>09</strong></p> 
 <p><strong>简单使用</strong></p> 
 <p style="text-align:justify;">orchestrator默认监听的端口是3000，启动后，可以通过web界面进行访问。</p> 
 <p><strong>9.1 web上的样子</strong></p> 
 <p style="text-align:justify;">通过给定一个实例后，orchestrator会根据该实例进行拓扑发现，并将拓扑架构在web界面上展示。如下图，通过给定任意一个要发现的实例，则一段时间后，orchestrator会自动探测出该实例所在集群的整个拓扑结构：</p> 
 <p style="text-align:justify;"><img src="https://images2.imgbox.com/0e/2c/qjMC00V9_o.png" alt="f68e37f4945e29b0e542f231f7b266f2.png"></p> 
 <p style="text-align:left;">通过访问web界面的Clusters下的Discover，如url路径如下：http://localhost:3000/web/discover，指定主从关系的任意一个实例，则orchestrator会自动发现其主从关系，并在Dashboard下展示。</p> 
 <p style="text-align:justify;"><img src="https://images2.imgbox.com/17/66/vbfXWq9e_o.png" alt="f796bb4718d0b78812b0964a826da701.png"></p> 
 <p><strong>9.2 管理和操作方式</strong></p> 
 <p style="text-align:justify;">orchestrator相关命令的操作，有多种方式，可以通过如下来进行管理。</p> 
 <p style="text-align:justify;"><strong>使用orchestrator二进制文件管理</strong></p> 
 <p style="text-align:justify;">orchestrator二进制文件本身也具有客户端命令操作的功能</p> 
 <p style="text-align:justify;"><strong>使用orchestrator-client来管理</strong></p> 
 <p style="text-align:justify;">该文件是一个包裹api操作的shell脚本，其特点是不用到处部署orchestrator，其本质上是调用orchestrator提供的api来访问；</p> 
 <pre class="has"><code class="language-objectivec">## 设置orchestrator的api环境变量
export ORCHESTRATOR_API=https://orchestrator.myservice.com:3000/api


## 部署了多个orchestrator节点(如生产环境3个节点组成raft)
export ORCHESTRATOR_API="https://orchestrator.host1:3000/api https://orchestrator.host2:3000/api https://orchestrator.host3:3000/api"</code></pre> 
 <p style="text-align:justify;"><strong>使用API方式来管理</strong></p> 
 <p style="text-align:justify;">api操作通过url的方式进行访问;</p> 
 <p style="text-align:justify;"><strong>使用Web 界面来管理</strong></p> 
 <p style="text-align:justify;">通过界面的拖拽等方式来进行管理(功能有限)。</p> 
 <p><strong>9.3 示例</strong></p> 
 <p style="text-align:justify;">查看当前所有集群的相关信息<br></p> 
 <pre class="has"><code class="language-shell">## 使用orchestrator命令 
./orchestrator -c clusters


## orchestrator-client命令 
./orchestrator-client -c clusters 


## 调用api的方式 
curl -s http://orchestrator.myservice.com:3000/api/clusters-info|jq 


## 浏览器中使用web界面查看 
http://orchestrator.myservice.com:3000/web/clusters/</code></pre> 
 <p>‍<br></p> 
 <p><strong>10</strong></p> 
 <p><strong>orchestrator常用命令</strong></p> 
 <p style="text-align:justify;">需要说明的是：</p> 
 <p style="text-align:justify;">虽然大部分的命令都可以通过orchestrator、api方式进行调用，但个别命令可能只能通过orchestrator或api方式进行调用，具体可参见命令帮助文档；</p> 
 <p><strong>10.1 查询信息相关</strong></p> 
 <p style="text-align:justify;">orchestrator提供了很多查询的命令，很多见名知意，以下只列出常用的一些命令</p> 
 <p style="text-align:justify;"><strong>clusters</strong></p> 
 <p style="text-align:justify;">查询出当前orchestrator探测到的所有MySQL集群；</p> 
 <p style="text-align:justify;"><strong>clusters-alias</strong></p> 
 <p style="text-align:justify;">列出当前orchestrator探测到的所有MySQL集群和别名；</p> 
 <p style="text-align:justify;"><strong>all-clusters-masters</strong></p> 
 <p style="text-align:justify;">列出当前探测到的所有集群可写的master实例；</p> 
 <p style="text-align:justify;"><strong>topology</strong></p> 
 <p style="text-align:justify;">通过给定的任意一个实例或集群别名，显示其整个集群的拓扑结构；</p> 
 <p style="text-align:justify;"><strong>命令对应的API</strong></p> 
 <pre class="has"><code class="language-shell">## clusters
 clusters-info
 
 ## clusters-alias
 clusters-info
 
 ## all-clusters-masters
 masters
 
 ## topology
 topology/:clusterHint
 topology/:host/:port</code></pre> 
 <p style="text-align:justify;"><strong>相关示例</strong><strong></strong></p> 
 <pre class="has"><code class="language-shell">## 列出当前探测的所有MySQL集群
./orchestrator-client -c clusters


## 列出当前orchestrator探测到的所有MySQL集群别名
./orchestrator-client -c clusters-alias


## 列出当前探测到的所有集群可写的master实例
./orchestrator-client -c all-clusters-masters


## 通过给定的任意一个实例，显示其整个集群的拓扑结构
./orchestrator-client -c topology -i instance.belonging.to.a.topology.com


## 通过给定集群的别名,显示整个集群的拓扑结构
./orchestrator-client -c topology -alias cluster_3306</code></pre> 
 <p><strong>10.2 实例的发现和移除管理</strong></p> 
 <p style="text-align:justify;"><strong>discover</strong></p> 
 <p style="text-align:justify;">通过给定的一个实例，来发现它并探测其所在MySQL的集群拓扑结构；</p> 
 <p style="text-align:justify;"><strong>forget</strong></p> 
 <p style="text-align:justify;">忘记一个指定的实例；说明：</p> 
 <ul><li><p>如果忘记的实例，仍然在主从拓扑结构中存在，则会在下一次探测时再次被发现；</p></li><li><p>忘记实例操作，只是将实例的相关信息从orchestrator的后端库中移除，并不影响MySQL集群实际的主从关系；</p></li></ul> 
 <p style="text-align:justify;"><strong>forget-cluster</strong></p> 
 <p style="text-align:justify;">忘记指定的集群。该命令只在api中支持，可以将整个集群中所有实例全部忘记。同forget一样，只是删除存储在orchestrator后端库的信息，并不影响MySQL集群实际的主从关系；</p> 
 <p style="text-align:justify;"><strong>命令对应的API</strong></p> 
 <pre class="has"><code class="language-ruby">## discover
discover/:host/:port


## forget
forget/:host/:port


## forget-cluster
forget-cluster/:clusterHint</code></pre> 
 <p style="text-align:justify;"><strong>相关示例</strong></p> 
 <pre class="has"><code class="language-shell">## 发现一个实例并拓扑其所在的MySQL集群拓扑结构;
./orchestrator-client -c discover -i instance.to.discover.com:3306


## 忘记某个实例
./orchestrator-client -c forget -i instance.to.forget.com:3306


## 忘记整个集群
./orchestrator-client -c forget-cluster -alias cluster_for_forget</code></pre> 
 <p><strong>10.3 拓扑重构</strong></p> 
 <p style="text-align:justify;">orchestrator支持基于Oracle GTID、MariaDB GTID、Pseudo GTID等多种类型的MySQL拓扑结构，针对每一种其都提供了相应的拓扑重构命令，但最常用的还是smart重构命令，smart重构命令会根据当前拓扑结构的具体类型，调用不同的重构命令进行拓扑重构。</p> 
 <p style="text-align:justify;"><strong>relocate</strong></p> 
 <p style="text-align:justify;">将一个实例重构于另一个(目标)实例之下，其目标实例几乎可以是任意一个。</p> 
 <p style="text-align:justify;"><strong>relocate-replicas</strong></p> 
 <p style="text-align:justify;">将指定实例的所有或者部分副本重构于另一个(目标)实例之下，可以通过-pattern 正则来指定要匹配的部分副本(如果不指定,则影响全部)，通常这样比一个个relocate重构要快。</p> 
 <p style="text-align:justify;">需要说明的是：</p> 
 <ul><li><p>该操作并不影响指定的实例，只影响其副本或部分副本；</p></li><li><p>orchestrator会分多步骤来处理该指令,并不保证原子性，重构后可能有的会成功有的会失败；</p></li></ul> 
 <p style="text-align:justify;"><strong>take-siblings</strong></p> 
 <p style="text-align:justify;">将指定副本的所有兄弟副本重构为自己的子副本。</p> 
 <p style="text-align:justify;"><strong>regroup-replicas</strong></p> 
 <p style="text-align:justify;">给定一个实例(可能是已经crashed的),挑选一个它的副本,并将其提升为master；</p> 
 <p style="text-align:justify;">说明：</p> 
 <ul><li><p>给定的实例只能是master，且无法指定副本具体是哪一个(指定也是忽略),orchestrator会自己判断选取合适的副本来完成重构；</p></li><li><p>该操作实际上是执行了RegroupReplicas函数，对当前master的所有副本依据一定的规则排序后，选出一个候选节点，并对其他剩余副本做change master操作，这在故障转移章节会介绍；</p></li><li><p>该命令只支持在orchestrator中使用；</p></li></ul> 
 <p style="text-align:justify;"><strong>take-master</strong></p> 
 <p style="text-align:justify;">将一个副本变成其master的master，就是将主从互换下角色；</p> 
 <p style="text-align:justify;">说明：</p> 
 <ul><li><p>该操作只影响切换的两个实例，这两个实例上的其他实例结构并不会改变；</p></li><li><p>要操作实例的master必须也是一个副本；</p></li></ul> 
 <p style="text-align:justify;"><strong>命令对应的API</strong></p> 
 <pre class="has"><code class="language-ruby">## relocate
relocate/:host/:port/:belowHost/:belowPort


## relocate-replicas
relocate-slaves/:host/:port/:belowHost/:belowPort


## take-siblings
enslave-siblings/:host/:port


## regroup-replicas
regroup-slaves/:host/:port


## take-master
enslave-master/:host/:port</code></pre> 
 <p style="text-align:justify;"><strong>相关示例</strong></p> 
 <p style="text-align:justify;"><strong>relocate示例</strong></p> 
 <pre class="has"><code class="language-shell">## relocate
./orchestrator-client -c relocate -i replica.to.relocate.com -d instance.that.becomes.its.master</code></pre> 
 <p style="text-align:justify;"><strong>relocate-replicas示例</strong></p> 
 <pre class="has"><code class="language-ruby">## 现有拓扑结构
# ./orchestrator-client -c topology -alias 3200_cluster
db84.add.dbserver.com:3200 (3200_db84)     [0s,ok,5.6.51-91.0-log,rw,ROW,&gt;&gt;,GTID]
+ db85.add.dbserver.com:3300 (3300_db85)   [0s,ok,8.0.20-11,rw,ROW,&gt;&gt;,GTID]
  + db86.add.dbserver.com:3200 (3200_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
  + db86.add.dbserver.com:3300 (3300_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
  + db86.add.dbserver.com:3400 (3400_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]


## 执行relocate-replicas操作,将db85下的所有副本全部挂到db84下
# ./orchestrator-client -c relocate-replicas -i db85.add.dbserver.com:3300 -d db84.add.dbserver.com:3200      
db86.add.dbserver.com:3300
db86.add.dbserver.com:3400
db86.add.dbserver.com:3200


## 查看新的拓扑结构
# ./orchestrator-client -c topology -alias 3200_cluster
db84.add.dbserver.com:3200 (3200_db84)   [0s,ok,5.6.51-91.0-log,rw,ROW,&gt;&gt;,GTID]
+ db85.add.dbserver.com:3300 (3300_db85) [0s,ok,8.0.20-11,rw,ROW,&gt;&gt;,GTID]
+ db86.add.dbserver.com:3200 (3200_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
+ db86.add.dbserver.com:3300 (3300_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
+ db86.add.dbserver.com:3400 (3400_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]</code></pre> 
 <p style="text-align:justify;"><strong>take-siblings示例</strong></p> 
 <pre class="has"><code class="language-go">## 现有拓扑结构
# ./orchestrator-client -c topology -alias 3200_cluster
db84.add.dbserver.com:3200 (3200_db84)   [0s,ok,5.6.51-91.0-log,rw,ROW,&gt;&gt;,GTID]
+ db85.add.dbserver.com:3300 (3300_db85) [0s,ok,8.0.20-11,rw,ROW,&gt;&gt;,GTID]
+ db86.add.dbserver.com:3200 (3200_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
+ db86.add.dbserver.com:3300 (3300_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
+ db86.add.dbserver.com:3400 (3400_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]

## 执行take-siblings操作(将db85下的所有兄弟副本,都挂载到db85下)
# ./orchestrator-client -c take-siblings -i db85.add.dbserver.com:3300
db85.add.dbserver.com:3300&lt;db84.add.dbserver.com:3200

## 查看重构后的拓扑结构
# ./orchestrator-client -c topology -alias 3200_cluster                              
db84.add.dbserver.com:3200 (3200_db84)     [0s,ok,5.6.51-91.0-log,rw,ROW,&gt;&gt;,GTID]
+ db85.add.dbserver.com:3300 (3300_db85)   [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
  + db86.add.dbserver.com:3200 (3200_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
  + db86.add.dbserver.com:3300 (3300_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
  + db86.add.dbserver.com:3400 (3400_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]</code></pre> 
 <p style="text-align:justify;"><strong>regroup-replicas示例</strong></p> 
 <pre class="has"><code class="language-ruby">## 现有拓扑结构
# ./orchestrator-client -c topology -alias 3200_cluster
db84.add.dbserver.com:3200 (3200_db84)   [0s,ok,5.6.51-91.0-log,rw,ROW,&gt;&gt;,GTID]
+ db85.add.dbserver.com:3300 (3300_db85) [0s,ok,8.0.20-11,rw,ROW,&gt;&gt;,GTID]
+ db86.add.dbserver.com:3200 (3200_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
+ db86.add.dbserver.com:3300 (3300_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
+ db86.add.dbserver.com:3400 (3400_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]


## 执行regroup-replicas操作(该命令只支持使用orchestrator来操作)
# ./orchestrator -c regroup-replicas -i db85.add.dbserver.com:3300


## 查看重构后的拓扑结构
# ./orchestrator-client -c topology -alias 3200_cluster                              
db84.add.dbserver.com:3200 (3200_db84)     [0s,ok,5.6.51-91.0-log,rw,ROW,&gt;&gt;,GTID]
+ db85.add.dbserver.com:3300 (3300_db85)   [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
  + db86.add.dbserver.com:3200 (3200_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
  + db86.add.dbserver.com:3300 (3300_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]
  + db86.add.dbserver.com:3400 (3400_db86) [0s,ok,8.0.20-11,ro,ROW,&gt;&gt;,GTID]</code></pre> 
 <p style="text-align:justify;"><strong>take-master示例</strong></p> 
 <pre class="has"><code class="language-ruby">## 查看当前拓扑(db162是一个中间主库，其包含2个从库db163和db165)
./orchestrator-client -c topology -i db161.add.dbserver.com:3000
db161.add.dbserver.com:3000     [0s,ok,5.6.36-log,rw,ROW,&gt;&gt;,GTID]
+ db162.add.dbserver.com:3000   [0s,ok,5.6.36-log,ro,ROW,&gt;&gt;,GTID]
  + db163.add.dbserver.com:3000 [0s,ok,5.6.36-log,ro,ROW,&gt;&gt;,GTID]
  + db165.add.dbserver.com:3000 [0s,ok,5.6.36-log,rw,ROW,&gt;&gt;,GTID]


## 对db163执行take-master操作(实际调换db163和db162)
## 即将dbpnew163作为db162的master -i指定要操作的实例
# ./orchestrator-client -c take-master -i db163.add.dbserver.com:3000
db163.add.dbserver.com:3000&lt;db161.add.dbserver.com:3000


## 执行后的拓扑结构(这两个实例上的其他副本结构不变,db165实例依然还是db162的副本)
# ./orchestrator-client -c topology -i db161.add.dbserver.com:3000
db161.add.dbserver.com:3000       [0s,ok,5.6.36-log,rw,ROW,&gt;&gt;,GTID]
+ db163.add.dbserver.com:3000     [0s,ok,5.6.36-log,ro,ROW,&gt;&gt;,GTID]
  + db162.add.dbserver.com:3000   [0s,ok,5.6.36-log,ro,ROW,&gt;&gt;,GTID]
    + db165.add.dbserver.com:3000 [0s,ok,5.6.36-log,rw,ROW,&gt;&gt;,GTID]</code></pre> 
 <p><strong>10.4 命令的帮助</strong></p> 
 <p style="text-align:justify;">可通过以下方式获取帮助。</p> 
 <pre class="has"><code class="language-bash">## 输出orchestrator命令行常用命令帮助
./orchestrator -h


## 输出orchestrator操作相关命令帮助
./orchestrator help


## 查看orchestrator某个具体命令的帮助
./orchestrator help &lt;command&gt;
Detailed help for a given command (e.g. "relocate")
orchestrator help relocate</code></pre> 
 <p>‍<br></p> 
 <p><strong>11</strong></p> 
 <p><strong>认证与安全</strong></p> 
 <p style="text-align:justify;">当通过web或api的方式访问orchestrator时，可以通过以下方式来进行安全认证。</p> 
 <p><strong>11.1 基本认证（basic）</strong></p> 
 <p style="text-align:justify;">指定AuthenticationMethod类型为basic，配置用户名和密码即可；</p> 
 <pre class="has"><code class="language-json">{
 "AuthenticationMethod": "basic",
 "HTTPAuthUser":         "orch",
 "HTTPAuthPassword":     "orch"
}</code></pre> 
 <p>‍</p> 
 <p><strong>11.2 </strong><strong>基本认证扩展(multi)</strong></p> 
 <p style="text-align:justify;">该认证方式同basic工作模式，但其还配置了一个用户名为readonly的用户，其密码可以是任意的；readonly用户只能查看，不能操作；</p> 
 <pre class="has"><code class="language-go">{
 "AuthenticationMethod": "multi",
 "HTTPAuthUser":         "orch",
 "HTTPAuthPassword":     "orch"
}</code></pre> 
 <p><strong>11.3</strong><strong> orchestrator-client的认证配置</strong></p> 
 <p style="text-align:justify;">如果orchestrator启用了认证，则客户端可以通过以下方式进行访问。</p> 
 <p style="text-align:justify;"><strong>配置参数</strong></p> 
 <pre class="has"><code class="language-go">## 添加配置认证的参数
export ORCHESTRATOR_AUTH_USER=username
export ORCHESTRATOR_AUTH_PASSWORD=password</code></pre> 
 <p style="text-align:justify;"><strong>执行时使用-b参数</strong></p> 
 <pre class="has"><code class="language-go">./orchestrator-client -b username:password -c &lt;command&gt;</code></pre> 
 <p style="text-align:justify;"><strong>api的配置</strong></p> 
 <p style="text-align:justify;">curl时添加认证即可；</p> 
 <pre class="has"><code class="language-go">curl -u username:password -s http://orchestrator.myservice.com:3000/api/clusters-info|jq</code></pre> 
 <p><strong>12</strong></p> 
 <p><strong>总结</strong></p> 
 <p style="text-align:justify;">orchestrator通过一个整体全面的分析，对MySQL集群进行管理，支持MySQL主从复制拓扑关系的调整、主库故障切换、手动切换等，还提供了web界面展示拓扑关系图和通过拖拽的方式来操作MySQL集群。另外提供了Restful API便于集成在别的系统中，同时相比于MHA等其他管理工具，避免了单点故障等，是一个值得推荐的MySQL高可用管理和复制拓补显示工具。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd11560b5dfd3339c66fe4f65566dfce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VisionTransformer（一）—— Embedding Patched与Word embedding及其实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8cf4cdef424c79bca30edaf3da1b9af0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">五分钟写一个VUE结合SpringBoot的单表增删改查带JWT登录功能界面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>