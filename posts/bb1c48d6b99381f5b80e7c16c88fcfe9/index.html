<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>free -h详解与内存swap理解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="free -h详解与内存swap理解" />
<meta property="og:description" content="一、free -h解析 [root@harbor-host ~]# free -h total used free shared buff/cache available Mem: 7.6G 3.8G 447M 368M 2.0G 1.7G Swap: 8.0G 1.2G 6.8G total：#服务器内存总大小：7.6G used：#已经使用了多少内存：3.8G，已用内存总量(used = total-free-buffers-cache,这里没减去shared，我理解是shared是used的其中一部分) free：#未被任何应用使用的真实空闲内存,也叫未被分配出去的内存，(真正尚未被使用的物理内存数) shared：#表示多个进程共享的内存总额。 buff/cache： #表示buffers和cache所用总量的总和(buffers为内核缓冲区所用的内存，cache为页缓存和slabs所用的内存容量)，也有人说是表示磁盘缓存的大小。 page cache，即缓存文件内容&#43;slab。slab也分可回收和不可回收部分，可手动回收，但是会在回收缓存这段时间影响主机性能，并且不是有所的slab和page cache都能被回收，正在使用的这些缓存不能被回收，否则系统的性能会很低，
所以最后可能的内存是多少，就得评估能够回收的有多少，就有了下面这个参数available
buffers是用来缓冲文件属性和目录内容的（其实就是inode信息）
cached是用来缓冲文件内容的（其实就是data block数据）
为了提高磁盘存取效率，Linux做了一些精心的设计，除了对dentry进行缓存（用于VFS，加速文件路径名到inode的转换），还采取了两种主要Cache方式：Buffer Cache和Page Cache。
前者针对磁盘块的读写，后者针对文件inode的读写。
这些Cache有效缩短了 I/O系统调用（比如read，write，getdents）的时间。
available：真正剩余的可被程序应用的内存数；是系统的一个估计值，不是谁减比较准确 注意：看一个内存可用多少，看available参数，但是你要理解available的意义，不是简单数字相减；有时候 也看free表示没有未被分配出去的内存。
free -h -s 2 -c 3 #2秒执行下free -h命令，执行3次。
二、swap虚拟内存 2.1 总结 ​ 当Linux的物理内存快要被耗尽时，系统会把一些进程占用的内存转移到 swap 区，当物理内存被释放一部分时，swap 区的一些内存占用又慢慢回到 mem 区，但是 mem 区却不再是之前的满负荷状态，而是有一部分 free 的内存！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bb1c48d6b99381f5b80e7c16c88fcfe9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-22T23:41:36+08:00" />
<meta property="article:modified_time" content="2023-10-22T23:41:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">free -h详解与内存swap理解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 style="background-color:transparent;">一、free -h解析</h3> 
<pre><code class="language-bash">[root@harbor-host ~]# free -h
              total        used        free      shared  buff/cache   available
Mem:           7.6G        3.8G        447M        368M        2.0G        1.7G
Swap:          8.0G        1.2G        6.8G</code></pre> 
<ul><li><strong>    total：#服务器内存总大小：7.6G</strong></li><li><strong>    used：#已经使用了多少内存：3.8G，已用内存总量(used = total-free-buffers-cache,这里没减去shared，我理解是shared是used的其中一部分)</strong></li><li><strong>    free：#未被任何应用使用的真实空闲内存,也叫未被分配出去的内存，(真正尚未被使用的物理内存数)</strong></li><li><strong>    shared：#表示多个进程共享的内存总额。</strong></li><li><strong>    buff/cache： #表示buffers和cache所用总量的总和(buffers为内核缓冲区所用的内存，cache为页缓存和slabs所用的内存容量)，也有人说是表示磁盘缓存的大小。</strong></li></ul> 
<blockquote> 
 <p>       page cache，即缓存文件内容+slab。slab也分可回收和不可回收部分，可手动回收，但是会在回收缓存这段时间影响主机性能，并且不是有所的slab和page cache都能被回收，正在使用的这些缓存不能被回收，否则系统的性能会很低，<br> 所以最后可能的内存是多少，就得评估能够回收的有多少，就有了下面这个参数available<br>      buffers是用来缓冲文件属性和目录内容的（其实就是inode信息）<br>      cached是用来缓冲文件内容的（其实就是data block数据）<br>      为了提高磁盘存取效率，Linux做了一些精心的设计，除了对dentry进行缓存（用于VFS，加速文件路径名到inode的转换），还采取了两种主要Cache方式：Buffer Cache和Page Cache。<br> 前者针对磁盘块的读写，后者针对文件inode的读写。</p> 
 <p>这些Cache有效缩短了 I/O系统调用（比如read，write，getdents）的时间。</p> 
</blockquote> 
<ul><li><strong>    available：真正剩余的可被程序应用的内存数；是系统的一个估计值，不是谁减比较准确</strong></li></ul> 
<p><span style="color:#fe2c24;"><strong>注意：看一个内存可用多少，看available参数，但是你要理解available的意义，不是简单数字相减；有时候 也看free表示没有未被分配出去的内存。</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>free -h -s 2 -c 3  #2秒执行下free -h命令，执行3次。</strong></span></p> 
<p></p> 
<p></p> 
<p></p> 
<h3>二、swap虚拟内存</h3> 
<h4 style="background-color:transparent;">2.1 总结</h4> 
<p>​        当Linux的物理内存快要被耗尽时，系统会把一些进程占用的内存转移到 swap 区，当物理内存被释放一部分时，swap 区的一些内存占用又慢慢回到 mem 区，但是 mem 区却不再是之前的满负荷状态，而是有一部分 free 的内存！</p> 
<p>【总结1】</p> 
<ul><li>1）当物理内存快被耗尽时，系统并没有崩溃，而是拿 swap 做临时内存，当两者都耗尽，系统 OutofMemory</li><li>2）物理内存达到峰值，系统中一些不常用的进程内存占用被提到 swap 区</li><li>3）当 Men 区的资源进行释放时，被挪到 swap 的内存并不会全部回来，随着系统或者程序的唤醒才会慢慢回到 men 区</li><li>4）swap 是内存不够时，磁盘虚拟出来的内存，磁盘主要是 I/O 级别的操作，并不是系统内核级别的操作，处理速度跟 mem 区不是一个等级</li></ul> 
<p>【总结2】</p> 
<p>        其实swap是可以关闭的（比如swapon，swapoff命令），有些时候为了追求高性能会这么做，通常为了性能设置在10-30之间比较多。<br> 通常使Swap负载保持在30%以下，这样才能保证系统的良好性能，这是一个参考值。</p> 
<ul><li>swap可以是磁盘划分的分区，因此有人叫做交换分区；也可以是某个文件，有方法教如何扩展swap空间。</li><li>swap可以设置多个的。</li></ul> 
<p>        Linux系统的内存管理必须使用交换区来建立虚拟内存（是不是必须有时间测），安装好系统后可以把它关闭掉的。<br>         交换分区(Swap)被频繁使用的情况，将被视作物理内存不足而造成的，此时考虑扩展物理内存，或排查什么程序如此占用内存了；或者服务器很久没有重启，过swap占用过大。</p> 
<h4>2.2 概述</h4> 
<p>​         Swap空间的作用可简单描述为：当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap空间中，等到那些程序要运行时，再从Swap中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换。</p> 
<p>​         计算机用户会经常遇这种现象。例如，在使用Windows系统时，可以同时运行多个程序，当你切换到一个很长时间没有理会的程序时，会听到硬盘“哗哗”直响。这是因为这个程序的内存被那些频繁运行的程序给“偷走”了，放到了Swap区中。因此，一旦此程序被放置到前端，它就会从Swap区取回自己的数据，将其放进内存，然后接着运行。</p> 
<p>​         需要说明一点，并不是所有从物理内存中交换出来的数据都会被放到Swap中(如果这样的话，Swap就会不堪重负)，有相当一部分数据被直接交换到文件系统。例如，有的程序会打开一些文件，对文件进行读写(其实每个程序都至少要打开一个文件，那就是运行程序本身)，当需要将这些程序的内存空间交换出去时，就没有必要将文件部分的数据放到Swap空间中了，而可以直接将其放到文件里去。如果是读文件操作，那么内存数据被直接释放，不需要交换出来，因为下次需要时，可直接从文件系统恢复;如果是写文件，只需要将变化的数据保存到文件中，以便恢复。但是那些用malloc和new函数生成的对象的数据则不同，它们需要Swap空间，因为它们在文件系统中没有相应的“储备”文件，因此被称作“匿名”(Anonymous)内存数据。这类数据还包括堆栈中的一些状态和变量数据等。所以说，Swap空间是“匿名”数据的交换空间。</p> 
<p>​ 　　另外，Swap分区的数量对性能也有很大的影响。因为Swap交换的操作是磁盘IO的操作，如果有多个Swap交换区，Swap空间的分配会以轮流的方式操作于所有的Swap，这样会大大均衡IO的负载，加快Swap交换的速度。如果只有一个交换区，所有的交换操作会使交换区变得很忙，使系统大多数时间处于等待状态，效率很低。用性能监视工具就会发现，此时的CPU并不很忙，而系统却慢。这说明，瓶颈在IO上，依靠提高CPU的速度是解决不了问题的。</p> 
<h4>2.3 物理内存剩余多少的时候，会使用虚拟内存呢？</h4> 
<p><strong>swappiness参数介绍</strong></p> 
<blockquote> 
 <p>        linux下的swap分区触发是由参数控制的，swappiness参数将控制在剩余多少物理内存的时候使用虚拟内存，当然，虚拟内存是在迫不得已的情况就才使用的，否则会大大降低系统性能。<br>         centos7结果通常是30，30的意思表示在物理内存已经使用了70%的时候（也就是100-30），剩余30%没使用，会开始使用swap虚拟内存。<br>      （个人记忆：swappiness=30表示物理内存只有最后30%可用了，就开始使用swap）。<br> [root@localhost ~]# cat /proc/sys/vm/swappiness<br> 30</p> 
</blockquote> 
<p><strong>#如何设置合理的swap交换触发点。</strong></p> 
<blockquote> 
 <p>  #swappiness的值的大小对如何使用swap分区是有着很大的联系的。<br>     swappiness=0 的时候表示最大限度使用物理内存，然后才是swap空间。在配置k8s或者其它一些追求高性能的情况，你可能看到关闭swap的分区。<br>     swappiness＝100 的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。<br>     swappiness 这个值应该低一点，系统的性能就比较好，通常为了性能设置在10-30之间比较多。<br>     <br> 方式一：临时<br> sysctl vm.swappiness=10<br> 这种方式是临时修改，重启后将自动还原。<br> 执行下面的命令，使立即生效：<br> sysctl -p</p> 
 <p></p> 
 <p>方式二（永久）：<br> 编辑文件 /etc/sysctl.conf，在最下面添加：<br> kernel.shmall = 4294967296<br> vm.swappiness=10</p> 
</blockquote> 
<h4>2.4 如何查看swap是哪些进程暂用</h4> 
<blockquote> 
 <p>top--&gt;f--&gt;然后选中SWAP= Swapped Size (KiB)--&gt;q  这样可以看到每个进程占用swap大小。</p> 
 <p>#如果要写自动化去判定，可以有其它命令显示，自己去找https://blog.csdn.net/jiang_chuang/article/details/6540869</p> 
</blockquote> 
<h4 style="background-color:transparent;">2.5 swap满了如何关闭？</h4> 
<blockquote> 
 <p>#如果swap满了，如何清空泥，大部分人可能想到的是重启机器，其实这里关闭swap，重新打开swap也可以清空的。</p> 
 <p>swapoff -a #关闭</p> 
 <p>swapon -a #打开。这个执行原理是重新执行/etc/fstab文件，如果文件里面swap行的内容注释掉了，你是无法开启swap的；--help 也可以看得到-a原理。<br> 从fstab文件可以看出来，其实swap是挂载个分区。</p> 
</blockquote> 
<h3><br> 三、查看进程占用内存的命令</h3> 
<h4>3.1 top命令实时显示</h4> 
<p>top命令是常用的，里面有很多用法，多去用，显示的字段也有很多，多去了解其意思，</p> 
<p>​ 再多的命令原理都是一样的，用一个精通了，其它都很简单。</p> 
<p><strong>执行top命令后的可进行的操作:   翻页用PgUp，PgDn</strong></p> 
<blockquote> 
 <p><br> P - 以CPU占用率大小的顺序排列进程列表  #常用<br> M - 以内存占用率大小的顺序排列进程列表  #常用<br> N - 以 PID 的从大到小的顺序排列  <br> L  Locate string 查询某个字符串,在所有页查询，翻页用PgUp，PgDn。  #常用<br> c小写 - 显示进程的绝对路径的快捷键<br> e，则是显示进程的单位，E是显示标题的单位。<br> f — 从当前显示中添加或删除显示的字段，列出所有字段，然后你可以选择哪些需要显示的。<br> l - 关闭或开启第一部分第一行 top 信息的表示  <br> t - 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示  <br> m - 关闭或开启第一部分第四行Mem 和 第五行 Swap 信息的表示  <br> n - 设置在进程列表所显示进程的数量，表示当前页面你想显示几行进程<br> s - 改变画面更新时间周期，默认3s刷新一次 #常用<br> k -  kill某个进程  #常用<br> h - 显示帮助   #常用<br> q - 退出 top<br> z -高亮显示正在运行的进程的快捷键</p> 
</blockquote> 
<h4><br> 3.2 ps aux命令</h4> 
<p><br> ​ 常用的方法，必须掌握</p> 
<ul><li><strong>1.按内存升序排列: ps aux --sort=+rss</strong></li><li><strong>2.按内存降序排列: ps aux --sort=-rss #可以看到按照内存使用从高到低降序排列</strong>                    <strong>                ps aux --sort=-%mem | head  #和上面一个意思，mem不能写大写。</strong></li><li><strong>3.按cpu升序排列: ps aux --sort=+%cpu</strong></li><li><strong>4.按cpu降序排列: ps aux --sort=-%cpu</strong></li></ul> 
<h4>3.3 ps_mem命令</h4> 
<blockquote> 
 <p>root@xxx-03:~# yum -y install ps_mem  #要安装包才可以使用</p> 
 <p>[root@harbor-host ~]# man ps_mem<br> NAME<br>        ps_mem - Memory profiling tool #内存资料收集工具<br> SYNOPSIS<br>        ps_mem [-h|--help] [-s|--show-cmdline] [-p PID] [-w N]<br> DESCRIPTION<br>        The ps_mem tool can determine how much RAM is used per program (not per process).<br>        In detail it reports:<br>               sum(private RAM for program processes) + sum(Shared RAM for program processes).  #私有进程总和+共享进程总和。这个很有用，可以看这个进程单独占用进程总和</p> 
 <p>       The shared RAM is problematic to calculate, and the tool automatically selects the most accurate method available for the running kernel.<br> OPTIONS<br>        -h --help<br>               Show this help<br>        -s --show-cmdline<br>               Show complete program path with options<br>        -p &lt;pid&gt;[,pid2,...pidN]<br>               Only show memory usage PIDs in the specified list<br>        -w N   Measure and show process memory every N seconds</p> 
 <p>[root@harbor-host ~]# ps_mem -w 2 -p 1  #2秒执行一次，进程id等于1<br> ^C[root@harbor-host ~]# ps aux|grep mysql    <br> mysql     1688  0.2  5.7 1919308 224808 ?      Ssl   2021 960:47 /usr/sbin/mysqld<br> [root@harbor-host ~]# ps_mem -p 1688 -w 2  #查看mysql占用进程总和，2秒执行一次<br>  Private  +   Shared  =  RAM used       Program </p> 
 <p>219.6 MiB + 248.0 KiB = 219.8 MiB       mysqld<br> ---------------------------------<br>                         219.8 MiB<br> =================================<br> 219.6 MiB + 248.0 KiB = 219.8 MiB       mysqld<br> ---------------------------------<br>                         219.8 MiB<br>  </p> 
</blockquote> 
<h4>3.4 pmap</h4> 
<p><br> pmap命令查看详细进程的内存占用情况<br> pmap - report memory map of a process(查看进程的内存映像信息)pmap命令用于报告进程的内存映射关系，是Linux调试及运维一个很好的工具。<br> 可以根据进程查看进程相关信息占用的内存情况，如下所示：  &gt; pmap -d pid</p> 
<p><br> 参考：<a href="https://blog.51cto.com/luckyshiliang/5215116" rel="nofollow" title="free -h详解与内存swap理解_51CTO博客_free swap">free -h详解与内存swap理解_51CTO博客_free swap</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4286644b7c815ae98371d58bbdc77006/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">腾讯云标准型S5服务器4核8G配置S5.LARGE8性能评测</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae6d17190d585d153fca45a60b9c3939/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">快速拿下 AI Prompt 工程师证书攻略！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>