<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Faster R-CNN最全讲解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Faster R-CNN最全讲解" />
<meta property="og:description" content="文章目录 一：Faster R-CNN的改进二：网络架构三：Conv layers模块四：Region Proposal Networks(RPN)模块【Module 1】step1: generate_anchor_basestep2: AnchorTargetCreatorstep3：训练RPN 【Module 2】 五：Semi-Fast R-CNN（RoiHead）【训练阶段】step1：RP中标注训练样本step2: 正式训练 【测试阶段】 六：Faster R-CNN训练方法七：Faster R-CNN测试方法step1：输入图像经过卷积层得到feature mapstep2：feature map经过RPN得到300个RPstep3：将RP输入到RoiHead网络中step4：得出每个RP的类别得分和bbox位置参数step5：由得分阈值选出最终的ROIstep6：结合位置参数微调ROI的bbox框step7：经过NMS后画出最终检测框 八：总结 一：Faster R-CNN的改进 想要更好地了解Faster R-CNN，需先了解传统R-CNN和Fast R-CNN原理，可参考本人呕心撰写的两篇博文 R-CNN史上最全讲解 和 Fast R-CNN讲解。
回到正题，经过R-CNN和Fast RCNN的积淀，Ross B. Girshick在2016年提出了新的Faster RCNN。从网络命名上看就很直白，那么相较于Faster R-CNN到底Faster在哪儿里呢？答案就是：region proposal的提取方式的改变。
Fast R-CNN虽然提出了ROI Pooling的特征提取方式，很好地解决了传统R-CNN中将Region Proposal区域分别输入CNN网络中的弊端。但是！！！始终都是用的传统Selective Search搜索方式确定Region Proposal，训练和测试时消耗了大量时间在RP搜索上。而Faster R-CNN突破性地使用了RPN网络直接提取出RP，并将其融入进整体网络中，使得综合性能有较大提高，在检测速度方面尤为明显。
二：网络架构 上图展示了python版本中的VGG16模型中的faster_rcnn_test.pt的网络结构，可以清晰的看到该网络架构分为以下几个模块：
Conv layers
该Backbone层主要用来提取输入图像中的特征，生成Feature Map以供后两个模块使用。Region Proposal Networks(RPN)
RPN模块用来训练提取出原图中的Region Proposal区域，是整个网络模型中最重要的一个模块。Semi-Fast R-CNN
Semi-Fast R-CNN是我自创的命名，因为和Fast R-CNN的head层几乎一模一样，更多叫法是RoiHead层。当通过RPN模块确定了RP后，就可以训练Fast R-CNN网络了，完成对RP区域的分类与bbox框的微调。 综上述可见，细心的人会发现，Conv layers＋Semi-Fast R-CNN不就是Fast R-CNN嘛！所以，Faster R-CNN网络实际上就是RPN &#43; Fast R-CNN，也就是two-stage，训练时也是对两个模块分开训练，测试时先由RPN生成RP，再将带有RP的Feature Map输入进Fast R-CNN中完成分类和预测框回归任务。下面，我将依次对三个模块进行详细讲解。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a09cf43ca1da4949b43dee0820a0df26/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-08T10:17:04+08:00" />
<meta property="article:modified_time" content="2022-09-08T10:17:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Faster R-CNN最全讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Faster_RCNN_1" rel="nofollow">一：Faster R-CNN的改进</a></li><li><a href="#_8" rel="nofollow">二：网络架构</a></li><li><a href="#Conv_layers_21" rel="nofollow">三：Conv layers模块</a></li><li><a href="#Region_Proposal_NetworksRPN_30" rel="nofollow">四：Region Proposal Networks(RPN)模块</a></li><li><ul><li><a href="#Module_1_34" rel="nofollow">【Module 1】</a></li><li><ul><li><a href="#step1_generate_anchor_base_36" rel="nofollow">step1: generate_anchor_base</a></li><li><a href="#step2_AnchorTargetCreator_148" rel="nofollow">step2: AnchorTargetCreator</a></li><li><a href="#step3RPN_202" rel="nofollow">step3：训练RPN</a></li></ul> 
   </li><li><a href="#Module_2_210" rel="nofollow">【Module 2】</a></li></ul> 
  </li><li><a href="#SemiFast_RCNNRoiHead_252" rel="nofollow">五：Semi-Fast R-CNN（RoiHead）</a></li><li><ul><li><a href="#_254" rel="nofollow">【训练阶段】</a></li><li><ul><li><a href="#step1RP_255" rel="nofollow">step1：RP中标注训练样本</a></li><li><a href="#step2%09_305" rel="nofollow">step2: 正式训练</a></li></ul> 
   </li><li><a href="#_325" rel="nofollow">【测试阶段】</a></li></ul> 
  </li><li><a href="#Faster_RCNN_328" rel="nofollow">六：Faster R-CNN训练方法</a></li><li><a href="#Faster_RCNN_339" rel="nofollow">七：Faster R-CNN测试方法</a></li><li><ul><li><ul><li><a href="#step1feature_map_341" rel="nofollow">step1：输入图像经过卷积层得到feature map</a></li><li><a href="#step2feature_mapRPN300RP_342" rel="nofollow">step2：feature map经过RPN得到300个RP</a></li><li><a href="#step3RPRoiHead_343" rel="nofollow">step3：将RP输入到RoiHead网络中</a></li><li><a href="#step4RPbbox_344" rel="nofollow">step4：得出每个RP的类别得分和bbox位置参数</a></li><li><a href="#step5ROI_345" rel="nofollow">step5：由得分阈值选出最终的ROI</a></li><li><a href="#step6ROIbbox_346" rel="nofollow">step6：结合位置参数微调ROI的bbox框</a></li><li><a href="#step7NMS_347" rel="nofollow">step7：经过NMS后画出最终检测框</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_349" rel="nofollow">八：总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="Faster_RCNN_1"></a>一：Faster R-CNN的改进</h2> 
<p>想要更好地了解Faster R-CNN，需先了解传统R-CNN和Fast R-CNN原理，可参考本人呕心撰写的两篇博文 <a href="https://blog.csdn.net/weixin_43702653/article/details/123973629?spm=1001.2014.3001.5501">R-CNN史上最全讲解</a> 和 <a href="https://blog.csdn.net/weixin_43702653/article/details/124002054?spm=1001.2014.3001.5501">Fast R-CNN讲解</a>。</p> 
<p>回到正题，经过R-CNN和Fast RCNN的积淀，Ross B. Girshick在2016年提出了新的Faster RCNN。从网络命名上看就很直白，那么相较于Faster R-CNN到底Faster在哪儿里呢？<mark>答案就是：region proposal的提取方式的改变</mark>。</p> 
<p>Fast R-CNN虽然提出了ROI Pooling的特征提取方式，很好地解决了传统R-CNN中将<code>Region Proposal</code>区域分别输入CNN网络中的弊端。<strong>但是！！！始终都是用的传统Selective Search搜索方式确定Region Proposal</strong>，训练和测试时消耗了大量时间在RP搜索上。<mark>而Faster R-CNN突破性地使用了RPN网络直接提取出RP，并将其融入进整体网络中</mark>，使得综合性能有较大提高，在检测速度方面尤为明显。</p> 
<h2><a id="_8"></a>二：网络架构</h2> 
<p><img src="https://images2.imgbox.com/80/ba/T82tU8Kz_o.png" alt="在这里插入图片描述"><br> 上图展示了python版本中的VGG16模型中的<code>faster_rcnn_test.pt</code>的网络结构，可以清晰的看到该网络架构分为以下几个模块：</p> 
<ul><li><strong>Conv layers</strong><br> 该Backbone层主要用来提取输入图像中的特征，生成Feature Map以供后两个模块使用。</li><li><strong>Region Proposal Networks(RPN)</strong><br> RPN模块用来训练提取出原图中的Region Proposal区域，是整个网络模型中最重要的一个模块。</li><li><strong>Semi-Fast R-CNN</strong><br> Semi-Fast R-CNN是我自创的命名，因为和Fast R-CNN的head层几乎一模一样，更多叫法是RoiHead层。当通过RPN模块确定了RP后，就可以训练Fast R-CNN网络了，完成对RP区域的分类与bbox框的微调。</li></ul> 
<p>综上述可见，<strong>细心的人会发现，Conv layers＋Semi-Fast R-CNN不就是Fast R-CNN嘛</strong>！所以，<mark>Faster R-CNN网络实际上就是RPN + Fast R-CNN</mark>，也就是<code>two-stage</code>，训练时也是对两个模块分开训练，<strong>测试时先由RPN生成RP，再将带有RP的Feature Map输入进Fast R-CNN中完成分类和预测框回归任务</strong>。下面，我将依次对三个模块进行详细讲解。</p> 
<h2><a id="Conv_layers_21"></a>三：Conv layers模块</h2> 
<p><img src="https://images2.imgbox.com/47/84/mjbKaMOa_o.png" alt="在这里插入图片描述"></p> 
<p>Conv layers包含了conv，pooling，relu三种层。以python版本中的VGG16模型中<code>faster_rcnn_test.pt</code>的网络结构为例。Conv layers部分共有13个conv层，13个relu层，4个pooling层。不太熟悉VGG16的小伙伴们要注意一下<strong>两个细节</strong>：</p> 
<ul><li>所有的conv层都是：kernel_size=3，pad=1，stride=1</li><li>所有的pooling层都是：kernel_size=2，pad=0，stride=2</li></ul> 
<p>经过Conv layers模块后，一个MxN<code>（800×600）</code>大小的输入图像就变为了(M/16)x(N/16)的Feature Map！<strong>这样Conv layers生成的feature map中都可以和原图对应起来。</strong></p> 
<h2><a id="Region_Proposal_NetworksRPN_30"></a>四：Region Proposal Networks(RPN)模块</h2> 
<p><img src="https://images2.imgbox.com/2e/92/u23nqGqC_o.png" alt="在这里插入图片描述"><br> 终于迎来了最重要的RPN模块，大家提起精神，和我一起分析！RPN说到底就是两个功能模块，<strong>第一个功能模块</strong>是利用二分类给每个anchor打出前景得分，并利用回归计算出每个anchor与其对应的GT间的四个微调参数。<strong>第二个功能模块</strong>则是根据第一个功能模块输出的得分和四个微调参数，得出ROI并选出合适的RP。<br> <mark>其实RPN只有第一个功能模块需要训练，第二个模块都是基本的选择运算</mark>，没有参数需要训练，只是为RoiHead选出训练和测试要用到的region proposal。下面我从这两个功能模块依次讲解：</p> 
<h3><a id="Module_1_34"></a>【Module 1】</h3> 
<p>在第一模块中，将讲解如何在原图中生成anchors并进行标注，又是如何利用标注好的anchors训练RPN对每个anchor进行前景与背景的二分类与anchor位置的回归微调。下面分步骤进行讲解：</p> 
<h4><a id="step1_generate_anchor_base_36"></a>step1: generate_anchor_base</h4> 
<p>首先，我们需要使用<code>generate_anchor_base</code>函数生成anchors。代码的主要实现思想：首先以特征图<code>feature map</code>的左上角点为基准产生<code>9个</code>anchor，三种尺度，每个尺度再对应三种比例。接着，将特征图左上角的9个anchors乘上原图的缩放比例base_size，也就是经过4个池化层后的<code>16倍</code>。锚点由特征图中的<code>(0.5,0.5)</code>变为了原图上的<code>(8,8)</code>，原图上的9个anchors的w和h也变为16倍。然后以原图左上角的anchors为基准，每隔base_size个像素，画9个anchors。画完之后，原图上大概有20000个anchors。<br> 具体实现方法，见如下代码并附手写图：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">generate_anchor_base</span><span class="token punctuation">(</span>base_size<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">,</span> ratios<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">#</span>
                         anchor_scales<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#对特征图features以基准长度为16、选择合适的ratios和scales取基准锚点anchor_base。（选择长度为16的原因是图片大小为600*800左右，基准长度16对应的原图区域是256*256，考虑放缩后的大小有128*128，512*512比较合适）</span>
<span class="token comment">#根据基准点生成9个基本的anchor的功能，ratios=[0.5,1,2],anchor_scales=[8,16,32]是长宽比和缩放比例,anchor_scales也就是在base_size的基础上再增加的量，本代码中对应着三种面积的大小(16*8)^2 ,(16*16)^2  (16*32)^2  也就是128,256,512的平方大小</span>
    py <span class="token operator">=</span> base_size <span class="token operator">/</span> <span class="token number">2.</span>
    px <span class="token operator">=</span> base_size <span class="token operator">/</span> <span class="token number">2.</span>   

    anchor_base <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>ratios<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>anchor_scales<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     
                           dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>  <span class="token comment">#（9，4），注意：这里只是以特征图的左上角点为基准产生的9个anchor,</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> six<span class="token punctuation">.</span>moves<span class="token punctuation">.</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>ratios<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#six.moves 是用来处理那些在python2 和 3里面函数的位置有变化的，直接用six.moves就可以屏蔽掉这些变化</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> six<span class="token punctuation">.</span>moves<span class="token punctuation">.</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>anchor_scales<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            h <span class="token operator">=</span> base_size <span class="token operator">*</span> anchor_scales<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>ratios<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            w <span class="token operator">=</span> base_size <span class="token operator">*</span> anchor_scales<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token number">1.</span> <span class="token operator">/</span> ratios<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">#生成9种不同比例的h和w</span>
 <span class="token triple-quoted-string string">'''
这9个anchor形状应为：
90.50967 *181.01933    = 128^2
181.01933 * 362.03867 = 256^2
362.03867 * 724.07733 = 512^2
128.0 * 128.0 = 128^2
256.0 * 256.0 = 256^2
512.0 * 512.0 = 512^2
181.01933 * 90.50967   = 128^2
362.03867 * 181.01933 = 256^2
724.07733 * 362.03867 = 512^2
该函数返回值为anchor_base，形状9*4，是9个anchor的左上右下坐标：
-37.2548 -82.5097 53.2548 98.5097
-82.5097	-173.019	98.5097	189.019
-173.019	-354.039	189.019	370.039
-56	-56	72	72
-120	-120	136	136
-248	-248	264	264
-82.5097	-37.2548	98.5097	53.2548
-173.019	-82.5097	189.019	98.5097
-354.039	-173.019	370.039	189.019
'''</span>
            index <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>anchor_scales<span class="token punctuation">)</span> <span class="token operator">+</span> j
            anchor_base<span class="token punctuation">[</span>index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> py <span class="token operator">-</span> h <span class="token operator">/</span> <span class="token number">2.</span>
            anchor_base<span class="token punctuation">[</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> px <span class="token operator">-</span> w <span class="token operator">/</span> <span class="token number">2.</span>
            anchor_base<span class="token punctuation">[</span>index<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> py <span class="token operator">+</span> h <span class="token operator">/</span> <span class="token number">2.</span>
            anchor_base<span class="token punctuation">[</span>index<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> px <span class="token operator">+</span> w <span class="token operator">/</span> <span class="token number">2.</span>  <span class="token comment">#计算出anchor_base画的9个框的左下角和右上角的4个anchor坐标值</span>
    <span class="token keyword">return</span> anchor_base 

</code></pre> 
<p><img src="https://images2.imgbox.com/b8/de/BOh5kqQX_o.jpg" alt="在这里插入图片描述"></p> 
<p>由于后面讲解中有一些转换函数的运用，在这里先贴上，大家可以根据注释先行理解：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">loc2bbox</span><span class="token punctuation">(</span>src_bbox<span class="token punctuation">,</span> loc<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#已知源bbox 和位置偏差dx，dy，dh，dw，求目标框G</span>
    <span class="token keyword">if</span> src_bbox<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> xp<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>loc<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>        <span class="token comment">#src_bbox：（R，4），R为bbox个数，4为左下角和右上角四个坐标(这里有误，按照标准坐标系中y轴向下，应该为左上和右下角坐标)</span>
    src_bbox <span class="token operator">=</span> src_bbox<span class="token punctuation">.</span>astype<span class="token punctuation">(</span>src_bbox<span class="token punctuation">.</span>dtype<span class="token punctuation">,</span> copy<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> 
    src_height <span class="token operator">=</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>      <span class="token comment">#ymax-ymin</span>
    src_width <span class="token operator">=</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>     <span class="token comment">#xmax-xmin</span>
    src_ctr_y <span class="token operator">=</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token operator">*</span> src_height    y0<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">.</span>5h
    src_ctr_x <span class="token operator">=</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token operator">*</span> src_width   <span class="token comment">#x0+0.5w,计算出中心点坐标</span>
<span class="token comment">#src_height为Ph,src_width为Pw，src_ctr_y为Py，src_ctr_x为Px</span>
    dy <span class="token operator">=</span> loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>      <span class="token comment">#python [start:stop:step] </span>
    dx <span class="token operator">=</span> loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>
    dh <span class="token operator">=</span> loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>
    dw <span class="token operator">=</span> loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>
RCNN中提出的边框回归：寻找原始proposal与近似目标框G之间的映射关系，公式在上面
    ctr_y <span class="token operator">=</span> dy <span class="token operator">*</span> src_height<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> xp<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span> <span class="token operator">+</span> src_ctr_y<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> xp<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span>  <span class="token comment">#ctr_y为Gy</span>
    ctr_x <span class="token operator">=</span> dx <span class="token operator">*</span> src_width<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> xp<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span> <span class="token operator">+</span> src_ctr_x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> xp<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span> <span class="token comment"># ctr_x为Gx</span>
    h <span class="token operator">=</span> xp<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>dh<span class="token punctuation">)</span> <span class="token operator">*</span> src_height<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> xp<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span> <span class="token comment">#h为Gh</span>
    w <span class="token operator">=</span> xp<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>dw<span class="token punctuation">)</span> <span class="token operator">*</span> src_width<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> xp<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span> <span class="token comment">#w为Gw</span>
<span class="token comment">#上面四行得到了回归后的目标框（Gx,Gy,Gh,Gw）</span>
    dst_bbox <span class="token operator">=</span> xp<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>loc<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> dtype<span class="token operator">=</span>loc<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>  <span class="token comment">#loc.shape：（R，4），同src_bbox</span>
    dst_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> ctr_y <span class="token operator">-</span> <span class="token number">0.5</span> <span class="token operator">*</span> h
    dst_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> ctr_x <span class="token operator">-</span> <span class="token number">0.5</span> <span class="token operator">*</span> w
    dst_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> ctr_y <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token operator">*</span> h
    dst_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> ctr_x <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token operator">*</span> w   <span class="token comment">#由中心点转换为左上角和右下角坐标</span>
    <span class="token keyword">return</span> dst_bbox
    
<span class="token keyword">def</span> <span class="token function">bbox2loc</span><span class="token punctuation">(</span>src_bbox<span class="token punctuation">,</span> dst_bbox<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#已知源框和目标框求出其位置偏差</span>
    height <span class="token operator">=</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
    width <span class="token operator">=</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
    ctr_y <span class="token operator">=</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token operator">*</span> height
    ctr_x <span class="token operator">=</span> src_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token operator">*</span> width <span class="token comment">#计算出源框中心点坐标</span>

    base_height <span class="token operator">=</span> dst_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> dst_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
    base_width <span class="token operator">=</span> dst_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> dst_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
    base_ctr_y <span class="token operator">=</span> dst_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token operator">*</span> base_height
    base_ctr_x <span class="token operator">=</span> dst_bbox<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token operator">*</span> base_width <span class="token comment">##计算出目标框中心点坐标</span>

    eps <span class="token operator">=</span> xp<span class="token punctuation">.</span>finfo<span class="token punctuation">(</span>height<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token punctuation">.</span>eps  <span class="token comment">#求出最小的正数</span>
    height <span class="token operator">=</span> xp<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>height<span class="token punctuation">,</span> eps<span class="token punctuation">)</span> 
    width <span class="token operator">=</span> xp<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>width<span class="token punctuation">,</span> eps<span class="token punctuation">)</span>  <span class="token comment">#将height,width与其比较保证全部是非负</span>

    dy <span class="token operator">=</span> <span class="token punctuation">(</span>base_ctr_y <span class="token operator">-</span> ctr_y<span class="token punctuation">)</span> <span class="token operator">/</span> height
    dx <span class="token operator">=</span> <span class="token punctuation">(</span>base_ctr_x <span class="token operator">-</span> ctr_x<span class="token punctuation">)</span> <span class="token operator">/</span> width
    dh <span class="token operator">=</span> xp<span class="token punctuation">.</span>log<span class="token punctuation">(</span>base_height <span class="token operator">/</span> height<span class="token punctuation">)</span>
    dw <span class="token operator">=</span> xp<span class="token punctuation">.</span>log<span class="token punctuation">(</span>base_width <span class="token operator">/</span> width<span class="token punctuation">)</span>  <span class="token comment">#根据上面的公式二计算dx，dy，dh，dw</span>

    loc <span class="token operator">=</span> xp<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">(</span>dy<span class="token punctuation">,</span> dx<span class="token punctuation">,</span> dh<span class="token punctuation">,</span> dw<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#np.vstack按照行的顺序把数组给堆叠起来</span>
    <span class="token keyword">return</span> loc

<span class="token keyword">def</span> <span class="token function">bbox_iou</span><span class="token punctuation">(</span>bbox_a<span class="token punctuation">,</span> bbox_b<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#求两个bbox的相交的交并比</span>
    <span class="token keyword">if</span> bbox_a<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">4</span> <span class="token keyword">or</span> bbox_b<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">4</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> IndexError  <span class="token comment">#确保bbox第二维为bbox的四个坐标（ymin，xmin，ymax，xmax）</span>
    tl <span class="token operator">=</span> xp<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>bbox_a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bbox_b<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">#tl为交叉部分框左上角坐标最大值，为了利用numpy的广播性质，bbox_a[:, None, :2]的shape是(N,1,2)，bbox_b[:, :2]shape是(K,2),由numpy的广播性质，两个数组shape都变成(N,K,2)，也就是对a里每个bbox都分别和b里的每个bbox求左上角点坐标最大值</span>
    br <span class="token operator">=</span> xp<span class="token punctuation">.</span>minimum<span class="token punctuation">(</span>bbox_a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bbox_b<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">#br为交叉部分框右下角坐标最小值</span>
    area_i <span class="token operator">=</span> xp<span class="token punctuation">.</span>prod<span class="token punctuation">(</span>br <span class="token operator">-</span> tl<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>tl <span class="token operator">&lt;</span> br<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">#所有坐标轴上tl&lt;br时，返回数组元素的乘积(y1max-yimin)X(x1max-x1min)，bboxa与bboxb相交区域的面积</span>
    area_a <span class="token operator">=</span> xp<span class="token punctuation">.</span>prod<span class="token punctuation">(</span>bbox_a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">-</span> bbox_a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">#计算bboxa的面积</span>
    area_b <span class="token operator">=</span> xp<span class="token punctuation">.</span>prod<span class="token punctuation">(</span>bbox_b<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">-</span> bbox_b<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#计算bboxb的面积</span>
    <span class="token keyword">return</span> area_i <span class="token operator">/</span> <span class="token punctuation">(</span>area_a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">+</span> area_b <span class="token operator">-</span> area_i<span class="token punctuation">)</span> <span class="token comment">#计算IOU</span>
</code></pre> 
<h4><a id="step2_AnchorTargetCreator_148"></a>step2: AnchorTargetCreator</h4> 
<p>在原图中生成了近乎<code>20000个</code>anchors后，使用<code>AnchorTargetCreator</code>函数对它们进行标注以用于训练。代码的主要实现思想：<strong>针对于label的标注</strong>，首先剔除掉超过原图边界的anchors，剩下将近15000个。接着，计算每一个anchor与哪个bbox的iou最大以及这个iou值，<code>IOU＞0.7</code>的anchor为pos_anchor，<code>IOU＜0.3</code>的anchor为neg_anchor。同时，还需计算每个bbox与哪个anchor的iou最大（其实就是矩阵中行最大和列最大的区别），每个bbox对应的最大IOU的anchors也直接设为pos_anchor。但是最后还需要在pos和neg中各随机选<code>128个</code>，也就是<code>128个正样本和128个负样本</code>，将128个正样本的label设置为1，将128个负样本的label设置为0，剩下的（20000-256）个anchors的labels都设为0。<strong>针对4个回归框的参数标注</strong>，首先对超框的都设为（0，0，0，0），框内的近乎15000个anchors的4个参数就是它们与最大IOU对应的bbox的实际偏移量。具体代码见下：</p> 
<pre><code class="prism language-python"><span class="token comment"># 下面是AnchorTargetCreator（）代码，作用是生成训练要用的anchor(与对应框iou值最大或者最小的各128个框的坐标和256个label（0或者1）)</span>
<span class="token keyword">class</span> <span class="token class-name">AnchorTargetCreator</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 利用每张图中bbox的真实标签来为所有任务分配ground truth！</span>
    <span class="token comment"># 为Faster-RCNN专有的RPN网络提供自我训练的样本，RPN网络正是利用AnchorTargetCreator产生的样本作为数据进行网络的训练和学习的，这样产生的预测anchor的类别和位置才更加精确，anchor变成真正的ROIS需要进行位置修正，而AnchorTargetCreator产生的带标签的样本就是给RPN网络进行训练学习用哒</span>
    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> bbox<span class="token punctuation">,</span> anchor<span class="token punctuation">,</span> img_size<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># anchor:(S,4),S为anchor数</span>
        img_H<span class="token punctuation">,</span> img_W <span class="token operator">=</span> img_size
        n_anchor <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>anchor<span class="token punctuation">)</span>  <span class="token comment"># 一般对应20000个左右anchor</span>
        inside_index <span class="token operator">=</span> _get_inside_index<span class="token punctuation">(</span>anchor<span class="token punctuation">,</span> img_H<span class="token punctuation">,</span> img_W<span class="token punctuation">)</span>  <span class="token comment"># 将那些超出图片范围的anchor全部去掉,只保留位于图片内部的序号</span>
        anchor <span class="token operator">=</span> anchor<span class="token punctuation">[</span>inside_index<span class="token punctuation">]</span>  <span class="token comment"># 保留位于图片内部的anchor</span>
        argmax_ious<span class="token punctuation">,</span> label <span class="token operator">=</span> self<span class="token punctuation">.</span>_create_label<span class="token punctuation">(</span>inside_index<span class="token punctuation">,</span> anchor<span class="token punctuation">,</span> bbox<span class="token punctuation">)</span>  <span class="token comment"># 筛选出符合条件的正例128个负例128并给它们附上相应的label</span>
        loc <span class="token operator">=</span> bbox2loc<span class="token punctuation">(</span>anchor<span class="token punctuation">,</span> bbox<span class="token punctuation">[</span>argmax_ious<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 计算每一个anchor与对应bbox求得iou最大的bbox计算偏移量（注意这里是位于图片内部的每一个）</span>
        label <span class="token operator">=</span> _unmap<span class="token punctuation">(</span>label<span class="token punctuation">,</span> n_anchor<span class="token punctuation">,</span> inside_index<span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 将位于图片内部的框的label对应到所有生成的20000个框中（label原本为所有在图片中的框的）</span>
        loc <span class="token operator">=</span> _unmap<span class="token punctuation">(</span>loc<span class="token punctuation">,</span> n_anchor<span class="token punctuation">,</span> inside_index<span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 将回归的框对应到所有生成的20000个框中（label原本为所有在图片中的框的）</span>
        <span class="token keyword">return</span> loc<span class="token punctuation">,</span> label

        <span class="token comment"># 下面为调用的_creat_label（） 函数</span>

    <span class="token keyword">def</span> <span class="token function">_create_label</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inside_index<span class="token punctuation">,</span> anchor<span class="token punctuation">,</span> bbox<span class="token punctuation">)</span><span class="token punctuation">:</span>
        label <span class="token operator">=</span> np<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>inside_index<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>int32<span class="token punctuation">)</span>  <span class="token comment"># inside_index为所有在图片范围内的anchor序号</span>
        label<span class="token punctuation">.</span>fill<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 全部填充-1</span>
        argmax_ious<span class="token punctuation">,</span> max_ious<span class="token punctuation">,</span> gt_argmax_ious <span class="token operator">=</span> self<span class="token punctuation">.</span>_calc_ious<span class="token punctuation">(</span>anchor<span class="token punctuation">,</span> bbox<span class="token punctuation">,</span> inside_index<span class="token punctuation">)</span>
        调用_calc_ious（）函数得到每个anchor与哪个bbox的iou最大以及这个iou值、每个bbox与哪个anchor的iou最大<span class="token punctuation">(</span>需要体会从行和列取最大值的区别<span class="token punctuation">)</span>
        label<span class="token punctuation">[</span>
            max_ious <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>neg_iou_thresh<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 把每个anchor与对应的框求得的iou值与负样本阈值比较，若小于负样本阈值，则label设为0，pos_iou_thresh=0.7, neg_iou_thresh=0.3</span>
        label<span class="token punctuation">[</span>gt_argmax_ious<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 把与每个bbox求得iou值最大的anchor的label设为1</span>
        label<span class="token punctuation">[</span>max_ious <span class="token operator">&gt;=</span> self<span class="token punctuation">.</span>pos_iou_thresh<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment">##把每个anchor与对应的框求得的iou值与正样本阈值比较，若大于正样本阈值，则label设为1</span>
        n_pos <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>pos_ratio <span class="token operator">*</span> self<span class="token punctuation">.</span>n_sample<span class="token punctuation">)</span>  <span class="token comment"># 按照比例计算出正样本数量，pos_ratio=0.5，n_sample=256</span>
        pos_index <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>label <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 得到所有正样本的索引</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pos_index<span class="token punctuation">)</span> <span class="token operator">&gt;</span> n_pos<span class="token punctuation">:</span>  <span class="token comment"># 如果选取出来的正样本数多于预设定的正样本数，则随机抛弃，将那些抛弃的样本的label设为-1</span>
            disable_index <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>
                pos_index<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>pos_index<span class="token punctuation">)</span> <span class="token operator">-</span> n_pos<span class="token punctuation">)</span><span class="token punctuation">,</span> replace<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
            label<span class="token punctuation">[</span>disable_index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
        n_neg <span class="token operator">=</span> self<span class="token punctuation">.</span>n_sample <span class="token operator">-</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>label <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 设定的负样本的数量</span>
        neg_index <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>label <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 负样本的索引</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>neg_index<span class="token punctuation">)</span> <span class="token operator">&gt;</span> n_neg<span class="token punctuation">:</span>
            disable_index <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>
                neg_index<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>neg_index<span class="token punctuation">)</span> <span class="token operator">-</span> n_neg<span class="token punctuation">)</span><span class="token punctuation">,</span>
                replace<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment"># 随机选择不要的负样本，个数为len(neg_index)-neg_index，label值设为-1</span>
            label<span class="token punctuation">[</span>disable_index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">return</span> argmax_ious<span class="token punctuation">,</span> label

    <span class="token comment"># 下面为调用的_calc_ious（）函数</span>
    <span class="token keyword">def</span> <span class="token function">_calc_ious</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> anchor<span class="token punctuation">,</span> bbox<span class="token punctuation">,</span> inside_index<span class="token punctuation">)</span><span class="token punctuation">:</span>
        ious <span class="token operator">=</span> bbox_iou<span class="token punctuation">(</span>anchor<span class="token punctuation">,</span> bbox<span class="token punctuation">)</span>  <span class="token comment"># 调用bbox_iou函数计算anchor与bbox的IOU， ious：（N,K），N为anchor中第N个，K为bbox中第K个，N大概有15000个</span>
        argmax_ious <span class="token operator">=</span> ious<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 1代表行，0代表列</span>
        max_ious <span class="token operator">=</span> ious<span class="token punctuation">[</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>inside_index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> argmax_ious<span class="token punctuation">]</span>  <span class="token comment"># 求出每个anchor与哪个bbox的iou最大，以及最大值，max_ious:[1,N]</span>
        gt_argmax_ious <span class="token operator">=</span> ious<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
        gt_max_ious <span class="token operator">=</span> ious<span class="token punctuation">[</span>gt_argmax_ious<span class="token punctuation">,</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>ious<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment"># 求出每个bbox与哪个anchor的iou最大，以及最大值,gt_max_ious:[1,K]</span>
        gt_argmax_ious <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>ious <span class="token operator">==</span> gt_max_ious<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 然后返回最大iou的索引（每个bbox与哪个anchor的iou最大),有K个</span>
        <span class="token keyword">return</span> argmax_ious<span class="token punctuation">,</span> max_ious<span class="token punctuation">,</span> gt_argmax_ious
</code></pre> 
<h4><a id="step3RPN_202"></a>step3：训练RPN</h4> 
<p>生成并标注完了训练样本，终于来到了第一功能模块的训练环节。<strong>首先</strong>对Feature Map进行<code>3×3卷积</code>操作，而后分为两个分支，每一分支都先进行<code>1×1卷积</code>操作，目的是压缩channel。<strong>第一个分支</strong>的通道数压缩成<code>9×2</code>，9代表每一个锚点的9个anchors，2代表每一个anchor是前景或后景的概率。<strong>第二个分支</strong>的通道数压缩成<code>9×4</code>，9代表每一个锚点的9个anchors，4代表每一个anchor的4个位置参数预测值。<strong>每一个min-batch，只对128个负样本和128个正样本计算分类损失和回归损失</strong>（ 实际上只对正样本进行回归损失计算）。损失函数如下：<br> <img src="https://images2.imgbox.com/7d/cf/JXH94REK_o.png" alt="在这里插入图片描述"><br> 分类损失函数选择的是传统的交叉熵损失函数，分类损失函数选择的是Smooth L1 Loss回归损失函数，如下：<br> <img src="https://images2.imgbox.com/20/de/ZqN0YHDB_o.png" alt="在这里插入图片描述"><br> 由于在实际过程中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          N 
         
        
          c 
         
        
       
      
        N_c 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.109em;" class="mord mathnormal">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.109em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> = min_batch ，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          N 
         
        
          r 
         
        
       
      
        N_r 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.109em;" class="mord mathnormal">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.109em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span style="margin-right: 0.0278em;" class="mord mathnormal mtight">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> = feature map的大小，两者差距过大，用参数λ平衡二者，使总的网络Loss计算过程中能够均匀考虑2种Loss。</p> 
<h3><a id="Module_2_210"></a>【Module 2】</h3> 
<p>第二个模块则是根据第一个功能模块输出的得分和四个位置参数，得出ROI并选出合适的RP。该模块在<code>ProposalCreator</code>函数中完成，代码的核心思想：通过训练好的第一个模块输出的约<code>20000个</code>anchor的4个位置参数，微调原图中所有anchor，生成<code>20000个</code>ROI。接着，对ROI进行裁剪，并且剔除掉裁剪后长和宽小于设定阈值的ROI。然后，根据前景score对剩余ROI进行由大到小的排序，<strong>若用于RoiHead训练</strong>，则取<code>前12000个</code>ROI，经过NMS二次筛选后只取<code>前2000个</code>ROI作为最终的region proposals。<strong>若用于RoiHead测试</strong>，则取<code>前2000个</code>ROI，经过NMS二次筛选后只取<code>前300个</code>ROI作为最终的region proposals。具体代码实现如下：</p> 
<pre><code class="prism language-python"><span class="token comment"># 下面是ProposalCreator的代码： 这部分的操作不需要进行反向传播，因此可以利用numpy/tensor实现</span>
<span class="token keyword">class</span> <span class="token class-name">ProposalCreator</span><span class="token punctuation">:</span>  <span class="token comment"># 对于每张图片，利用它的feature map，计算（H/16）x(W/16)x9(大概20000)个anchor属于前景的概率，然后从中选取概率较大的12000张，利用位置回归参数，修正这12000个anchor的位置， 利用非极大值抑制，选出2000个ROIS以及对应的位置参数。</span>
    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> loc<span class="token punctuation">,</span> score<span class="token punctuation">,</span> anchor<span class="token punctuation">,</span> img_size<span class="token punctuation">,</span>
                 scale<span class="token operator">=</span><span class="token number">1.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 这里的loc和score是经过region_proposal_network中经过1x1卷积分类和回归得到的</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>parent_model<span class="token punctuation">.</span>training<span class="token punctuation">:</span>
            n_pre_nms <span class="token operator">=</span> self<span class="token punctuation">.</span>n_train_pre_nms  <span class="token comment"># 12000</span>
            n_post_nms <span class="token operator">=</span> self<span class="token punctuation">.</span>n_train_post_nms  <span class="token comment"># 经过NMS后有2000个</span>

        <span class="token keyword">else</span><span class="token punctuation">:</span>
            n_pre_nms <span class="token operator">=</span> self<span class="token punctuation">.</span>n_test_pre_nms  <span class="token comment"># 6000</span>
            n_post_nms <span class="token operator">=</span> self<span class="token punctuation">.</span>n_test_post_nms  <span class="token comment"># 经过NMS后有300个</span>


        roi <span class="token operator">=</span> loc2bbox<span class="token punctuation">(</span>anchor<span class="token punctuation">,</span> loc<span class="token punctuation">)</span>  <span class="token comment"># 将bbox转换为近似groudtruth的anchor(即rois)</span>
        roi<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token builtin">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>clip<span class="token punctuation">(</span>roi<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token builtin">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> img_size<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 裁剪将rois的ymin,ymax限定在[0,H]</span>
        roi<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token builtin">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>clip<span class="token punctuation">(</span>roi<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token builtin">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> img_size<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 裁剪将rois的xmin,xmax限定在[0,W]</span>

        min_size <span class="token operator">=</span> self<span class="token punctuation">.</span>min_size <span class="token operator">*</span> scale  <span class="token comment"># 16</span>
        hs <span class="token operator">=</span> roi<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> roi<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># rois的宽</span>
        ws <span class="token operator">=</span> roi<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> roi<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># rois的长</span>
        keep <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span><span class="token punctuation">(</span>hs <span class="token operator">&gt;=</span> min_size<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ws <span class="token operator">&gt;=</span> min_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 确保rois的长宽大于最小阈值</span>
        roi <span class="token operator">=</span> roi<span class="token punctuation">[</span>keep<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>

        score <span class="token operator">=</span> score<span class="token punctuation">[</span>keep<span class="token punctuation">]</span>  <span class="token comment"># 对剩下的ROIs进行打分（根据region_proposal_network中rois的预测前景概率）</span>
        order <span class="token operator">=</span> score<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>argsort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 将score拉伸并逆序（从高到低）排序</span>
        <span class="token keyword">if</span> n_pre_nms <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
            order <span class="token operator">=</span> order<span class="token punctuation">[</span><span class="token punctuation">:</span>n_pre_nms<span class="token punctuation">]</span>  <span class="token comment"># train时从20000中取前12000个rois，test取前6000个</span>
        roi <span class="token operator">=</span> roi<span class="token punctuation">[</span>order<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>

        keep <span class="token operator">=</span> non_maximum_suppression<span class="token punctuation">(</span>
        cp<span class="token punctuation">.</span>ascontiguousarray<span class="token punctuation">(</span>cp<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span>roi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            thresh<span class="token operator">=</span>self<span class="token punctuation">.</span>nms_thresh<span class="token punctuation">)</span>  <span class="token comment"># （具体需要看NMS的原理以及输入参数的作用）调用非极大值抑制函数，将重复的抑制掉，就可以将筛选后ROIS进行返回。经过NMS处理后Train数据集得到2000个框，Test数据集得到300个框</span>
        <span class="token keyword">if</span> n_post_nms <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
            keep <span class="token operator">=</span> keep<span class="token punctuation">[</span><span class="token punctuation">:</span>n_post_nms<span class="token punctuation">]</span>
        roi <span class="token operator">=</span> roi<span class="token punctuation">[</span>keep<span class="token punctuation">]</span>
        <span class="token keyword">return</span> roi
</code></pre> 
<h2><a id="SemiFast_RCNNRoiHead_252"></a>五：Semi-Fast R-CNN（RoiHead）</h2> 
<p>介绍完了RPN模块后，最重要的RP提取任务已经完成。接下来RoiHead只要将RPN输出的RP结果作为输入，来训练和测试。我将训练阶段和测试模块分开讲解：</p> 
<h3><a id="_254"></a>【训练阶段】</h3> 
<h4><a id="step1RP_255"></a>step1：RP中标注训练样本</h4> 
<p>如果是在训练阶段，RPN会输出大约2000个region proposals。那么如何从中选取样本并标注呢？<code>ProposalTargetCreator</code>函数实现了这一任务，代码的核心思想是：首先，将<code>2000个</code>RP和<code>M个</code>Ground Truth拼接起来，<strong>也就是把所有的GT也都作为RP。为什么呢</strong>？</p> 
<p><mark>前方核能</mark>：其实答案很简单，现在是RoiHead的训练阶段，训练RoiHead的分类和二次回归能力。也就是说，需要给该网络输入带有类别标注和实际位置参数的训练数据，经过RPN选出的大范围包括实物的ROI可以作为训练数据，说实话也都是歪歪扭扭的，拿它们训练RoiHead其实主要是出于测试阶段的实际情况出发的，毕竟要从任务实际需要适应的情况出发，实际测试的时候都是RPN找出RP，RoiHead再对它们进行分类和bbox修正的，这些RP都是歪歪扭扭的。所以也就是说，拿这些样本进行分类本身就是不严谨的，不是说完完全全包裹住实物合格的类别样本。<strong>毕竟现在是训练阶段嘛，稍微偷偷喂给网络一点”优质碳水“，未尝不可，直接把最优质的GT给它训练去，货真价实的分类样本，舒不舒服，白用白不用。</strong></p> 
<p>回到正题，拼接好了RP和GT后，计算它们的最大IOU所对应的那个GT的label，将（label+1）作为每一个RP的类别标注（1~20）。然后将IOU＞0.5的RP中选<code>64</code>个作为正样本，将<code>IOU＜0.5</code>的RP中选出<code>64</code>个作为负样本并将负样本的label设为0，<strong>最后将共128个正负样本打包出来，作为RoiHead的训练输入</strong>。具体的实现代码如下：</p> 
<pre><code class="prism language-python"><span class="token comment"># 下面是ProposalTargetCreator代码：ProposalCreator产生2000个ROIS，但是这些ROIS并不都用于训练，经过本ProposalTargetCreator的筛选产生128个用于自身的训练</span>
    <span class="token keyword">class</span> <span class="token class-name">ProposalTargetCreator</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 为2000个rois赋予ground truth！（严格讲挑出128个赋予ground truth！）</span>
        <span class="token comment"># 输入：2000个rois、一个batch（一张图）中所有的bbox ground truth（R，4）、对应bbox所包含的label（R，1）（VOC2007来说20类0-19）</span>
        <span class="token comment"># 输出：128个sample roi（128，4）、128个gt_roi_loc（128，4）、128个gt_roi_label（128，1）</span>
        <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> roi<span class="token punctuation">,</span> bbox<span class="token punctuation">,</span> label<span class="token punctuation">,</span> loc_normalize_mean<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.</span><span class="token punctuation">,</span> <span class="token number">0.</span><span class="token punctuation">,</span> <span class="token number">0.</span><span class="token punctuation">,</span> <span class="token number">0.</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                     loc_normalize_std<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 因为这些数据是要放入到整个大网络里进行训练的，比如说位置数据，所以要对其位置坐标进行数据增强处理(归一化处理)</span>
            n_bbox<span class="token punctuation">,</span> _ <span class="token operator">=</span> bbox<span class="token punctuation">.</span>shape
            roi <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>roi<span class="token punctuation">,</span> bbox<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 首先将2000个roi和m个bbox给concatenate了一下成为新的roi（2000+m，4）。</span>
            pos_roi_per_image <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">round</span><span class="token punctuation">(</span>
                self<span class="token punctuation">.</span>n_sample <span class="token operator">*</span> self<span class="token punctuation">.</span>pos_ratio<span class="token punctuation">)</span>  <span class="token comment"># n_sample = 128,pos_ratio=0.5，round 对传入的数据进行四舍五入</span>
            iou <span class="token operator">=</span> bbox_iou<span class="token punctuation">(</span>roi<span class="token punctuation">,</span> bbox<span class="token punctuation">)</span>  <span class="token comment"># 计算每一个roi与每一个bbox的iou  (2000+m,m)</span>
            gt_assignment <span class="token operator">=</span> iou<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 按行找到最大值，返回最大值对应的序号以及其真正的IOU。返回的是每个roi与**哪个**bbox的最大，以及最大的iou值</span>
            max_iou <span class="token operator">=</span> iou<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 每个roi与对应bbox最大的iou</span>
            gt_roi_label <span class="token operator">=</span> label<span class="token punctuation">[</span>gt_assignment<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># 从1开始的类别序号，给每个类得到真正的label(将0-19变为1-20)</span>
            pos_index <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>max_iou <span class="token operator">&gt;=</span> self<span class="token punctuation">.</span>pos_iou_thresh<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 同样的根据iou的最大值将正负样本找出来，pos_iou_thresh=0.5</span>
            pos_roi_per_this_image <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>
                <span class="token builtin">min</span><span class="token punctuation">(</span>pos_roi_per_image<span class="token punctuation">,</span> pos_index<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 需要保留的roi个数（满足大于pos_iou_thresh条件的roi与64之间较小的一个）</span>
            <span class="token keyword">if</span> pos_index<span class="token punctuation">.</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                pos_index <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>
                    pos_index<span class="token punctuation">,</span> size<span class="token operator">=</span>pos_roi_per_this_image<span class="token punctuation">,</span> replace<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment"># 找出的样本数目过多就随机丢掉一些</span>

            neg_index <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span><span class="token punctuation">(</span>max_iou <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>neg_iou_thresh_hi<span class="token punctuation">)</span> <span class="token operator">&amp;</span>
                                 <span class="token punctuation">(</span>max_iou <span class="token operator">&gt;=</span> self<span class="token punctuation">.</span>neg_iou_thresh_lo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># neg_iou_thresh_hi=0.5，neg_iou_thresh_lo=0.0</span>
            neg_roi_per_this_image <span class="token operator">=</span> self<span class="token punctuation">.</span>n_sample <span class="token operator">-</span> pos_roi_per_this_image  <span class="token comment"># #需要保留的roi个数（满足大于0小于neg_iou_thresh_hi条件的roi与64之间较小的一个）</span>
            neg_roi_per_this_image <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">min</span><span class="token punctuation">(</span>neg_roi_per_this_image<span class="token punctuation">,</span>
                                             neg_index<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> neg_index<span class="token punctuation">.</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                neg_index <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>
                    neg_index<span class="token punctuation">,</span> size<span class="token operator">=</span>neg_roi_per_this_image<span class="token punctuation">,</span> replace<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment"># 找出的样本数目过多就随机丢掉一些</span>

            keep_index <span class="token operator">=</span> np<span class="token punctuation">.</span>append<span class="token punctuation">(</span>pos_index<span class="token punctuation">,</span> neg_index<span class="token punctuation">)</span>
            gt_roi_label <span class="token operator">=</span> gt_roi_label<span class="token punctuation">[</span>keep_index<span class="token punctuation">]</span>
            gt_roi_label<span class="token punctuation">[</span>pos_roi_per_this_image<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 负样本label 设为0</span>
            sample_roi <span class="token operator">=</span> roi<span class="token punctuation">[</span>keep_index<span class="token punctuation">]</span>
            <span class="token comment"># 那么此时输出的128*4的sample_roi就可以去扔到 RoIHead网络里去进行分类与回归了。同样， RoIHead网络利用这sample_roi+featue为输入，输出是分类（21类）和回归（进一步微调bbox）的预测值，那么分类回归的groud truth就是ProposalTargetCreator输出的gt_roi_label和gt_roi_loc。</span>
            gt_roi_loc <span class="token operator">=</span> bbox2loc<span class="token punctuation">(</span>sample_roi<span class="token punctuation">,</span> bbox<span class="token punctuation">[</span>gt_assignment<span class="token punctuation">[</span>keep_index<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 求这128个样本的groundtruth</span>
            gt_roi_loc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>gt_roi_loc <span class="token operator">-</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>loc_normalize_mean<span class="token punctuation">,</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>
                           <span class="token punctuation">)</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>loc_normalize_std<span class="token punctuation">,</span>
                                        np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># ProposalTargetCreator首次用到了真实的21个类的label,且该类最后对loc进行了归一化处理，所以预测时要进行均值方差处理</span>
            <span class="token keyword">return</span> sample_roi<span class="token punctuation">,</span> gt_roi_loc<span class="token punctuation">,</span> gt_roi_label
</code></pre> 
<h4><a id="step2%09_305"></a>step2: 正式训练</h4> 
<p>将这128个标注好的训练样本，从原图中投影到Feature Map中对应的ROI区域中，然后进入RoiPooling层，将这些大小不一的ROI区域变为同一长度的向量，再经过两层 <code>4096</code> FC层，分别得到softmax21分类打分和bbox的<code>84</code>个参数<code>(21 * 4)</code>的预测结果，放入损失函数中进行反向传播更新网络权重，其中只计算正样本的回归框损失。损失函数和RPN的类似，这里就不再赘述了，贴上损失函数核心代码：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">_fast_rcnn_loc_loss</span><span class="token punctuation">(</span>pred_loc<span class="token punctuation">,</span> gt_loc<span class="token punctuation">,</span> gt_label<span class="token punctuation">,</span> sigma<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#输入分别为rpn回归框的偏移量与anchor与bbox的偏移量以及label</span>
    in_weight <span class="token operator">=</span> t<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>gt_loc<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># Localization loss is calculated only for positive rois.</span>
    <span class="token comment"># NOTE:  unlike origin implementation, </span>
    <span class="token comment"># we don't need inside_weight and outside_weight, they can calculate by gt_label</span>
    in_weight<span class="token punctuation">[</span><span class="token punctuation">(</span>gt_label <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>expand_as<span class="token punctuation">(</span>in_weight<span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    loc_loss <span class="token operator">=</span> _smooth_l1_loss<span class="token punctuation">(</span>pred_loc<span class="token punctuation">,</span> gt_loc<span class="token punctuation">,</span> in_weight<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sigma<span class="token punctuation">)</span> <span class="token comment">#sigma设置为1</span>
    <span class="token comment"># Normalize by total number of negtive and positive rois.</span>
    loc_loss <span class="token operator">/=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>gt_label <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># ignore gt_label==-1 for rpn_loss #除去背景类</span>
    <span class="token keyword">return</span> loc_loss
</code></pre> 
<pre><code class="prism language-python">roi_cls_loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>roi_score<span class="token punctuation">,</span> gt_roi_label<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#求交叉熵损失</span>
</code></pre> 
<h3><a id="_325"></a>【测试阶段】</h3> 
<p>RoiHead的测试阶段就是将RPN中输出的300个RP，输入进网络中，最后会输出每个RP的类和4个回归框微调参数。剔除掉高于背景（0）阈值和最大类别（1~20）得分低于阈值的RP，最后根据回归参数，对筛选后剩下的RP框进行微调，得到最终的bounding box！至此，大功告成。</p> 
<h2><a id="Faster_RCNN_328"></a>六：Faster R-CNN训练方法</h2> 
<p>Faster-RCNN有两种训练方式：<strong>四步交替迭代</strong>训练和联合训练。本文主要讲解四步交替迭代的训练方式，如下所示：</p> 
<p>1、训练RPN，使用大型数据集预训练模型初始化共享卷积和RPN权重，端到端训练RPN，用于生成Region Proposals；<br> 2、训练Fast R-CNN，使用相同的预训练模型初始化共享卷积【注意此处是初始化一个新的与第1步结构相同的共享卷积网络，而不是第1步中训练得到的】，锁住第1步训练好的RPN权重，结合RPN得到的Proposals训练RCNN网络；<br> 3、调优RPN，使用第2步训练好的共享卷积和RCNN，固定共享卷积层，继续训练RPN，我认为这一步相当于对第1步训练好的RPN进行微调；<br> 4、调优Fast R-CNN，使用第3步训练好的共享卷积和RPN（固定住共享卷积层），继续对RCNN进行训练微调<br> 5、重复上述步骤3、4，进行迭代。（一般到步骤四其实已经够了，后面迭代训练后的效果几乎无提升）</p> 
<p><strong>下面是一张训练过程流程图，应该更加清晰：</strong><br> <img src="https://images2.imgbox.com/55/2a/oPM4hbiN_o.jpg" alt="在这里插入图片描述"></p> 
<h2><a id="Faster_RCNN_339"></a>七：Faster R-CNN测试方法</h2> 
<p>接下面讲解整个网络的测试过程，<mark>即将大功告成啦！</mark></p> 
<h4><a id="step1feature_map_341"></a>step1：输入图像经过卷积层得到feature map</h4> 
<h4><a id="step2feature_mapRPN300RP_342"></a>step2：feature map经过RPN得到300个RP</h4> 
<h4><a id="step3RPRoiHead_343"></a>step3：将RP输入到RoiHead网络中</h4> 
<h4><a id="step4RPbbox_344"></a>step4：得出每个RP的类别得分和bbox位置参数</h4> 
<h4><a id="step5ROI_345"></a>step5：由得分阈值选出最终的ROI</h4> 
<h4><a id="step6ROIbbox_346"></a>step6：结合位置参数微调ROI的bbox框</h4> 
<h4><a id="step7NMS_347"></a>step7：经过NMS后画出最终检测框</h4> 
<h2><a id="_349"></a>八：总结</h2> 
<p>Fast R-CNN尽管速度和精度上都有了很大的提升，但仍然<strong>未能实现端到端(end-to-end)的目标检测</strong>，比如候选区域的获得不能同步进行，速度上还有提升空间。</p> 
<p>最后附上一个<mark>超大原理流程图收尾</mark>，供大家参考：</p> 
<p><img src="https://images2.imgbox.com/cd/16/nPXK3CJt_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>  至此我对Faster R-CNN全部流程与细节，进行了深度讲解，希望对大家有所帮助，有不懂的地方或者建议，欢迎大家在下方留言评论。（码字不易，各位看官<mark>点个赞，手留余香</mark>~谢谢！）</p> 
<p>我是努力在CV泥潭中摸爬滚打的江南咸鱼，我们一起努力，不留遗憾！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/429f8715b542a02e90f805943e68425b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mask R-CNN讲解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a06b429c0cabd77c3b154a34013f2810/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GNN的理解与研究</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>