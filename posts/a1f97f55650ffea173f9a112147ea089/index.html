<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据挖掘算法基础（一） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据挖掘算法基础（一）" />
<meta property="og:description" content="文章目录 机器学习算法基础引言分类算法朴素贝叶斯模型决策树模型支持向量机模型逻辑回归模型 聚类算法原型聚类——k-means算法密度聚类——DBSCAN算法层次聚类 模型的评估与选择经验误差与过拟合评估方法留一法交叉验证法自助法 性能度量错误率和精度查准率、查全率和F1ROC和AUC曲线 机器学习算法基础 引言 引入NLP的算法体系，当前的主流算法可以分为两类：
传统的基于统计学的机器学习算法体系。人工神经网络算法体系。
很多机器学习算法经常应用到NLP相关的任务中，例如用朴素贝叶斯、支持向量机、逻辑回归等方法进行文本分类，用k-means方法进行文本聚类等。
近几年，人们对大脑和语言的内在机制了解的越来越多，也能够从更高的层次上观察和认知思维现象，由此形成了一套人工神经网络的算法体系。
本章将介绍机器学习算法和人工神经网络算法的概念、原理和方法。 分类算法 分类算法就是根据对象的特征或属性，将其划分到已有的类别中。比如邮件分类，网页内容分类等。常用的算法如决策树、朴素贝叶斯以及支持向量机SVM等分类算法。
朴素贝叶斯模型 朴素贝叶斯方法是基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的训练集合，首先基于特征条件独立学习输入、输出的联合概率分布；然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。朴素贝叶斯方法简单，学习与预测的效率都很高，是常用的方法。
基本方法如下：
（1）确定特征属性，获取训练样本集合。
（2）计算各类别的先验概率。
（3）计算各类别下各特征属性的条件概率。
（4）计算各类别的后验概率
（5）以后验概率的最大项作为样本所属类别。
决策树模型 决策树算法是一种逼近离散函数值的方法。它是一种典型的分类方法，首先对数据进行处理，利用归纳算法生成可读的规则和决策树，然后使用决策对新数据进行分析。本质上决策树是通过一系列规则对数据进行分类的过程。由于这种决策分支画成图形很像一棵树的枝干，故称为决策树。决策树的生成算法主要有ID3、C4.5和C5.0生成树算法。
决策树是一个树结构，每个非叶节点表示一个特征属性，每个分支边表示这个特征属性在值域上的取值，叶节点存放一个类别。
决策过程：从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，知道达到叶子节点，将叶子节点存放的类别作为决策结果。
ID3算法生成决策树过程：
（1）从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征，由该特征的不同值建立子节点；
（2）对子节点递归地调用以上方法，构建决策树；
（3）直到所有特征的信息增益很小或则没有特征可选择为止，最后得到一颗决策树；
信息熵是接收的每条信息中所包含信息的平均量，是不确定性的度量。香农将随机变量X的熵值定义H(X)如下：
信息增益：用来衡量一个属性区分样本的能力。当使用某一个属性作为一颗决策树的根节点时，该属性的信息增益越大，这颗决策树也就越简洁。信息增益是信息熵H的变形，定义如下：
支持向量机模型 支持向量机（SVM）是用来解决分类问题的。作为数据挖掘领域中一项非常重要的任务，分类目前在商业上应用最多。而分类的目的是构造一个分类任务或分类模型，该模型能把数据库中的数据项映射到给定类别中的某一个，从而可以用于预测未知类别。
通俗的说，支持向量机的最终目的是在特征空间中寻找到一个尽可能将两个数据集合分开的超级平面。之所以名字里面加上了前缀“超级”，是因为我们的数据特征空间很有可能是高维度空间，而且我们希望这个超级平面能够尽可能大的将两类数据分开。
支持向量机可以分为线性可分支持向量机（硬间隔支持向量机）和非线性可分支持向量机（软间隔支持向量机）。支持向量机算法已经应用在很多领域，例如文本分类、图像分类、数据挖掘、手写数字识别、行人检测等，且其可应用的领域还远远不止这些。
支持向量机是一种监督学习方法，主要思想是建立一个最优决策超平面，使得该平面的两侧距离该平面最近的两类样本之间的距离最大化，从而对分类问题提供良好的泛化能力。
SVM算法的优点：可用于线性可分，也可用于回归；低泛化误差；推导过程优美，容易理解；计算复杂度低。
SVM算法的缺点：对参数选择比较敏感；原始的SVM只擅长处理二分类问题。
以上的方法只能解决线性可分的问题，遇到线性不可分的问题需要引入核函数，将问题转化的高维空间。
逻辑回归模型 逻辑回归算法常用于数据挖掘、疾病自动诊断、经济预测等领域。逻辑回归算法是一种广义的线性回归方法，其仅在线性回归算法的基础上套用了一个逻辑函数，从而对事件发生的概率进行预测。
逻辑回归算法的步骤如下所示：
加载数据文件。数据预处理，生成多项式特征。由于最简单的二分类问题只有一阶特征，决策边界为一条直线，可以不考虑本步骤。而现实中的样本，往往需要拟合一条曲线来划分数据，即多项式拟合。多边形边界需要将特征转换为多项式，进而更改样本的分布状态，使之能拟合更复杂的边界，例如圆或者其它不规则图形。初始化参数，构建代价函数。
用梯度下降法优化代价函数，确定参数。
构建预测函数，求概率值。根据概率值画决策边界。 聚类算法 聚类算法是无监督学习的典型算法，不需要标签。试图探索和发现一定的模式，用于发现共同的群体，按照内在相似性将数据划分为多个类别使得类内相似性大，类间相似性小。应用场景包括新闻聚类、用户购买模式、图像与基因技术等。
常见的聚类算法包括：
原型聚类：原型聚类亦称为“基于原型的聚类”，此类算法假设聚类结构能通过一组原型刻画，在现实聚类任务中极为常用。密度聚类：密度聚类亦称为“基于密度的聚类”，此类算法假设聚类结构能通过样本分布的紧密程度确定。层次聚类：层次聚类算法试图在不同层次对数据集进行划分，从而形成树形的聚类结构。数据集的划分可采用“自底向上”的聚合策略，也可采用“自顶向下”的分拆策略。 原型聚类——k-means算法 原型聚类亦称为“基于原型的聚类”，此类算法假设聚类结构能通过一组原型刻画，在现实聚类任务中极为常用。通常情形下，算法先对原型进行初始化，然后对原型进行迭代更新求解。采用不同的原型表示、不同的求解方式，将产生不同的算法。下面介绍经典的原型聚类算法k-means也称为k均值法。下面介绍经典的原型聚类算法k-means也称为k均值法。
算法思想就是首先随机确定k个中心点作为聚类中心，然后把各个数据点分配给最邻近的中心点，分配完成后将中心点移动到所表示的聚类的平均中心位置处，然后重复迭代上述步骤，直到分配过程不再产生变化位置。
k-means算法采用距离作为相似性指标，认为簇由靠近的对象组成，因此两个对象的距离越近，则其相似度越高。而不同的距离度量会对聚类的结果产生影响，常见的距离度量如下：
K-means算法流程：
随机选择K个随机的点（称为聚类中心）；对与数据集中的每个数据点，按照距离K个中心点的距离，将其与距离最近的中心点关联起来，与同一中心点关联的所有点聚成一类；计算每一组的均值，将该组所关联的中心点移动到平均值的位置；重复执行2-3步，直至中心点不再变化； 密度聚类——DBSCAN算法 基于密度聚类的方法：
密度聚类假设聚类结构能通过样本的紧密程度确定，同一类别的样本，他们之间是紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。从样本密度出发考虑样本间的可连接性，然后基于可连接样本不断扩展聚类的簇实现聚类的目的。 DBSCAN算法流程：
给定包含 n 个对象的数据集 D ，邻域为 ϵ，密度阈值为 MinPts首先找到所有的核心对象根据 (ϵ,MinPts) 对 n 个对象进行搜索，寻找所有的核心对象，构成核心对象集合。根据上述的核心对象寻找 D 中所有密度相连的样本，构成簇，若上述核心对象已被访问，则剔除出去。重复上述过程，直至核心对象集合为空。 DBSCAN(Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法)：基于一组“邻域”参数 (ϵ,MinPts) 来刻画样本分布的紧密程度。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a1f97f55650ffea173f9a112147ea089/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-09T19:20:05+08:00" />
<meta property="article:modified_time" content="2023-05-09T19:20:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据挖掘算法基础（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">机器学习算法基础</a></li><li><ul><li><a href="#_2" rel="nofollow">引言</a></li><li><a href="#_9" rel="nofollow">分类算法</a></li><li><ul><li><a href="#_11" rel="nofollow">朴素贝叶斯模型</a></li><li><a href="#_27" rel="nofollow">决策树模型</a></li><li><a href="#_40" rel="nofollow">支持向量机模型</a></li><li><a href="#_48" rel="nofollow">逻辑回归模型</a></li></ul> 
   </li><li><a href="#_59" rel="nofollow">聚类算法</a></li><li><ul><li><a href="#kmeans_65" rel="nofollow">原型聚类——k-means算法</a></li><li><a href="#DBSCAN_77" rel="nofollow">密度聚类——DBSCAN算法</a></li><li><a href="#_97" rel="nofollow">层次聚类</a></li></ul> 
   </li><li><a href="#_106" rel="nofollow">模型的评估与选择</a></li><li><ul><li><a href="#_107" rel="nofollow">经验误差与过拟合</a></li><li><a href="#_113" rel="nofollow">评估方法</a></li><li><ul><li><a href="#_118" rel="nofollow">留一法</a></li><li><a href="#_122" rel="nofollow">交叉验证法</a></li><li><a href="#_129" rel="nofollow">自助法</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_132" rel="nofollow">性能度量</a></li><li><ul><li><a href="#_133" rel="nofollow">错误率和精度</a></li><li><a href="#F1_139" rel="nofollow">查准率、查全率和F1</a></li><li><a href="#ROCAUC_145" rel="nofollow">ROC和AUC曲线</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>机器学习算法基础</h2> 
<h3><a id="_2"></a>引言</h3> 
<p>引入NLP的算法体系，当前的主流算法可以分为两类：</p> 
<ol><li>传统的基于统计学的机器学习算法体系。</li><li>人工神经网络算法体系。<br> 很多机器学习算法经常应用到NLP相关的任务中，例如用朴素贝叶斯、支持向量机、逻辑回归等方法进行文本分类，用k-means方法进行文本聚类等。<br> 近几年，人们对大脑和语言的内在机制了解的越来越多，也能够从更高的层次上观察和认知思维现象，由此形成了一套人工神经网络的算法体系。<br> 本章将介绍机器学习算法和人工神经网络算法的概念、原理和方法。</li></ol> 
<h3><a id="_9"></a>分类算法</h3> 
<p>分类算法就是根据对象的特征或属性，将其划分到已有的类别中。比如邮件分类，网页内容分类等。常用的算法如决策树、朴素贝叶斯以及支持向量机SVM等分类算法。</p> 
<h4><a id="_11"></a>朴素贝叶斯模型</h4> 
<p>朴素贝叶斯方法是基于<strong>贝叶斯定理</strong>与<strong>特征条件独立</strong>假设的分类方法。对于给定的训练集合，首先基于特征条件独立学习输入、输出的联合概率分布；然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。朴素贝叶斯方法简单，学习与预测的效率都很高，是常用的方法。<br> 基本方法如下：<br> （1）确定特征属性，获取训练样本集合。<br> <img src="https://images2.imgbox.com/cc/dc/HQL8uuob_o.png" alt="在这里插入图片描述"><br> （2）计算各类别的先验概率。<br> <img src="https://images2.imgbox.com/0f/73/iKY1HphL_o.png" alt="在这里插入图片描述"><br> （3）计算各类别下各特征属性的条件概率。<br> <img src="https://images2.imgbox.com/66/c9/CZVF76q9_o.png" alt="在这里插入图片描述"><br> （4）计算各类别的后验概率<br> <img src="https://images2.imgbox.com/2e/06/sTrQXgvF_o.png" alt="在这里插入图片描述"><br> （5）以后验概率的最大项作为样本所属类别。<br> <img src="https://images2.imgbox.com/3a/a3/E45lDMqd_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/07/c9/y9tr1LPA_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/96/82/cd68SRPW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/82/df/os8aID0l_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_27"></a>决策树模型</h4> 
<p>决策树算法是一种逼近离散函数值的方法。它是一种典型的分类方法，首先对数据进行处理，利用归纳算法生成可读的规则和决策树，然后使用决策对新数据进行分析。本质上决策树是通过一系列规则对数据进行分类的过程。由于这种决策分支画成图形很像一棵树的枝干，故称为决策树。决策树的生成算法主要有ID3、C4.5和C5.0生成树算法。<img src="https://images2.imgbox.com/93/6a/V4ue5wcL_o.png" alt="在这里插入图片描述"><br> 决策树是一个树结构，每个非叶节点表示一个特征属性，每个分支边表示这个特征属性在值域上的取值，叶节点存放一个类别。<br> <strong>决策过程</strong>：从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，知道达到叶子节点，将叶子节点存放的类别作为决策结果。<br> <strong>ID3算法</strong>生成决策树过程：<br> （1）从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征，由该特征的不同值建立子节点；<br> （2）对子节点递归地调用以上方法，构建决策树；<br> （3）直到所有特征的信息增益很小或则没有特征可选择为止，最后得到一颗决策树；<br> <strong>信息熵</strong>是接收的每条信息中所包含信息的平均量，是不确定性的度量。香农将随机变量X的熵值定义H(X)如下：<br> <img src="https://images2.imgbox.com/76/5f/Hz4NQcPE_o.png" alt="在这里插入图片描述"><br> <strong>信息增益</strong>：用来衡量一个属性区分样本的能力。当使用某一个属性作为一颗决策树的根节点时，该属性的信息增益越大，这颗决策树也就越简洁。信息增益是信息熵H的变形，定义如下：<br> <img src="https://images2.imgbox.com/5b/1c/TRHhUEKr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9e/82/0UrAA2fD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_40"></a>支持向量机模型</h4> 
<p><strong>支持向量机（SVM）<strong>是用来解决分类问题的。作为数据挖掘领域中一项非常重要的任务，分类目前在商业上应用最多。而分类的目的是构造一个分类任务或分类模型，该模型能把数据库中的数据项映射到给定类别中的某一个，从而可以用于预测未知类别。<br> 通俗的说，支持向量机的最终目的是在特征空间中寻找到一个尽可能将两个数据集合分开的超级平面。之所以名字里面加上了前缀“超级”，是因为我们的数据特征空间很有可能是高维度空间，而且我们希望这个超级平面能够尽可能大的将两类数据分开。<br> 支持向量机可以分为</strong>线性可分支持向量机</strong>（硬间隔支持向量机）和<strong>非线性可分支持向量机</strong>（软间隔支持向量机）。支持向量机算法已经应用在很多领域，例如文本分类、图像分类、数据挖掘、手写数字识别、行人检测等，且其可应用的领域还远远不止这些。<br> 支持向量机是一种监督学习方法，主要思想是建立一个最优决策超平面，使得该平面的两侧距离该平面最近的两类样本之间的距离最大化，从而对分类问题提供良好的泛化能力。<br> <strong>SVM算法的优点</strong>：可用于线性可分，也可用于回归；低泛化误差；推导过程优美，容易理解；计算复杂度低。<br> <strong>SVM算法的缺点</strong>：对参数选择比较敏感；原始的SVM只擅长处理二分类问题。<br> 以上的方法只能解决线性可分的问题，遇到线性不可分的问题需要<strong>引入核函数，将问题转化的高维空间。</strong></p> 
<h4><a id="_48"></a>逻辑回归模型</h4> 
<p>逻辑回归算法常用于数据挖掘、疾病自动诊断、经济预测等领域。逻辑回归算法是一种广义的线性回归方法，其仅在线性回归算法的基础上套用了一个逻辑函数，从而对事件发生的概率进行预测。<br> 逻辑回归算法的步骤如下所示：</p> 
<ol><li>加载数据文件。</li><li>数据预处理，生成多项式特征。由于最简单的二分类问题只有一阶特征，决策边界为一条直线，可以不考虑本步骤。而现实中的样本，往往需要拟合一条曲线来划分数据，即多项式拟合。多边形边界需要将特征转换为多项式，进而更改样本的分布状态，使之能拟合更复杂的边界，例如圆或者其它不规则图形。</li><li>初始化参数，构建代价函数。<br> <img src="https://images2.imgbox.com/bb/d4/Y4PbPiIt_o.png" alt="在这里插入图片描述"></li><li>用梯度下降法优化代价函数，确定参数。<br> <img src="https://images2.imgbox.com/7b/c1/cB5hj6Ex_o.png" alt="在这里插入图片描述"></li><li>构建预测函数，求概率值。</li><li>根据概率值画决策边界。</li></ol> 
<h3><a id="_59"></a>聚类算法</h3> 
<p>聚类算法是无监督学习的典型算法，不需要标签。试图探索和发现一定的模式，用于发现共同的群体，按照内在相似性将数据划分为多个类别使得<strong>类内相似性大，类间相似性小</strong>。应用场景包括新闻聚类、用户购买模式、图像与基因技术等。<br> 常见的聚类算法包括：</p> 
<ol><li>原型聚类：原型聚类亦称为“基于原型的聚类”，此类算法假设聚类结构能通过一组原型刻画，在现实聚类任务中极为常用。</li><li>密度聚类：密度聚类亦称为“基于密度的聚类”，此类算法假设聚类结构能通过样本分布的紧密程度确定。</li><li>层次聚类：层次聚类算法试图在不同层次对数据集进行划分，从而形成树形的聚类结构。数据集的划分可采用“自底向上”的聚合策略，也可采用“自顶向下”的分拆策略。</li></ol> 
<h4><a id="kmeans_65"></a>原型聚类——k-means算法</h4> 
<p>原型聚类亦称为“基于原型的聚类”，此类算法假设聚类结构能通过一组原型刻画，在现实聚类任务中极为常用。通常情形下，算法先对原型进行初始化，然后对原型进行迭代更新求解。采用不同的原型表示、不同的求解方式，将产生不同的算法。下面介绍经典的原型聚类算法k-means也称为k均值法。下面介绍经典的原型聚类算法k-means也称为k均值法。<br> 算法思想就是首先随机确定k个中心点作为聚类中心，然后把各个数据点分配给最邻近的中心点，分配完成后将中心点移动到所表示的聚类的平均中心位置处，然后重复迭代上述步骤，直到分配过程不再产生变化位置。<br> k-means算法采用距离作为相似性指标，认为簇由靠近的对象组成，因此两个对象的距离越近，则其相似度越高。而不同的距离度量会对聚类的结果产生影响，常见的距离度量如下：<br> <img src="https://images2.imgbox.com/a3/1f/10id7MTB_o.png" alt="在这里插入图片描述"><br> <strong>K-means算法流程：</strong><br> <img src="https://images2.imgbox.com/69/e5/GyqcwvWR_o.png" alt="在这里插入图片描述"></p> 
<ol><li>随机选择K个随机的点（称为聚类中心）；</li><li>对与数据集中的每个数据点，按照距离K个中心点的距离，将其与距离最近的中心点关联起来，与同一中心点关联的所有点聚成一类；</li><li>计算每一组的均值，将该组所关联的中心点移动到平均值的位置；</li><li>重复执行2-3步，直至中心点不再变化；</li></ol> 
<h4><a id="DBSCAN_77"></a>密度聚类——DBSCAN算法</h4> 
<p>基于密度聚类的方法：</p> 
<ol><li>密度聚类假设聚类结构能通过样本的紧密程度确定，同一类别的样本，他们之间是紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</li><li>从样本密度出发考虑样本间的可连接性，然后基于可连接样本不断扩展聚类的簇实现聚类的目的。</li></ol> 
<p><strong>DBSCAN算法流程</strong>：</p> 
<ol><li>给定包含 n 个对象的数据集 D ，邻域为 ϵ，密度阈值为 MinPts</li><li>首先找到所有的核心对象</li><li>根据 (ϵ,MinPts) 对 n 个对象进行搜索，寻找所有的核心对象，构成核心对象集合。</li><li>根据上述的核心对象寻找 D 中所有密度相连的样本，构成簇，若上述核心对象已被访问，则剔除出去。</li><li>重复上述过程，直至核心对象集合为空。</li></ol> 
<p>DBSCAN(Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法)：基于一组“邻域”参数 (ϵ,MinPts) 来刻画样本分布的紧密程度。<br> 令 MinPts=3，且虚线显示出 ϵ 邻域。<br> x_1 为核心对象<br> x_2 由 x_1 密度直达<br> x_3 由 x_1 密度可达<br> x_3 与 x_4 密度相连<br> <img src="https://images2.imgbox.com/57/aa/KyVnyJ8y_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/79/b6/7De8JRAz_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_97"></a>层次聚类</h4> 
<p><strong>层次聚类</strong>算法试图在不同层次对数据集进行划分，从而形成树形的聚类结构。数据集的划分可采用“自底向上”的聚合策略，也可采用“自顶向下”的分拆策略。<br> <strong>AGNES</strong>是一种采用自底向上聚合策略的层次聚类算法。它先将数据集中的每个样本看做一个初始聚类簇，然后在算法运行的每一步中找出距离最近的两个聚类簇进行合并，该过程不断重复，直至达到预设的聚类簇个数。这里的关键是如何计算聚类簇之间的距离。实际上，每个簇是一个样本集合，因此，只需采用关于集合的某种距离即可。可通过下面的式子来计算距离：<br> <img src="https://images2.imgbox.com/77/b7/MrP5NLxO_o.png" alt="在这里插入图片描述"><br> AGNES算法流程：</p> 
<ol><li>AGNES（Agglomerative NESting）算法最初将每个对象做为一个簇，然后这些簇根据某些准则被一步步的合并，使用单链接方法；</li><li>两个簇间的相似度由这两个不同簇中距离最近的数据点对的相似度来确定。此外当两个簇最近距离超过用户给定的阈值时聚类过程就会终止；</li><li>聚类的合并过程反复进行直到所有的对象最终满足簇数据。AGNES算法生成的树状图如图所示：<br> <img src="https://images2.imgbox.com/38/b8/z4a5BCgj_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="_106"></a>模型的评估与选择</h3> 
<h4><a id="_107"></a>经验误差与过拟合</h4> 
<p>一般在分类问题中，我们把分类错误的样本数占样本总数的比例称作**“错误率”<strong>（error rate），（1-error rate）称作精度，即：<strong>精度=1-错误率</strong>。更一般地，我们把模型的预测输出与样本的真实输出之间的差异称作“误差”（error），模型在训练集上的误差称作</strong>训练误差**，也叫经验误差；在新样本上的误差称作<strong>泛化误差</strong>。<br> 当模型把训练样本学得“太好”时，很可能已经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样会致使<strong>泛化性能</strong>的下降，这种现象在机器学习中称作**“过拟合”（overfitting）<strong>，与过拟合相对的是</strong>“欠拟合”（underfitting）**，欠拟合是指对训练样本的一般性质尚未学好。<br> <strong>导致过拟合的原因</strong>：最常见的情况是由于学习能力过于强大，以至于把训练样本包含的不太一般的特性都学到了，而欠拟合通常是由于学习能力不足引起的。<br> <strong>欠拟合</strong>较为容易克服，例如在决策树学习中扩展分支、在神经网络学习中增加训练轮数等，而过拟合问题的解决较为麻烦，也是机器学习面临的关键障碍，各类学习算法都会有针对过拟合的措施，但是过拟合是无法完全避免的，我们能做的只是“缓解”。<br> <img src="https://images2.imgbox.com/f1/37/SGD3P6BF_o.png" alt="过拟合与欠拟合对比"></p> 
<h4><a id="_113"></a>评估方法</h4> 
<p>在这里我们通常将已有的数据集划分为训练集和测试集两部分，其中训练集用来训练模型，而测试集则是用来评估模型对于新样本的判别能力。对于数据集的划分，我们通常要保证满足以下两个条件：<br> （1）训练集和测试集的分布要与样本真实分布一致，即训练集和测试集都要保证是从样本真实分布中独立同分布采样而得；<br> （2） 训练集和测试集要互斥。<br> 基于以上两个条件主要有三种划分数据集的方式：<strong>留出法，交叉验证法和自助法</strong>。</p> 
<h5><a id="_118"></a>留一法</h5> 
<p>留出法”（hold-out）直接将数据集D划分为两个互斥集合，其中一个集合为训练集S，另一个作为测试集T，即：<br> 训练集和测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响。如数据集D包含1000个正样本，1000个负样本，数据集D划分为70%样本的训练集和30%样本的测试集，为了保证训练和测试正负样本的比例与数据D比例相同，采用分层抽样的方法，先从1000个正样本随机抽取700次，1000个负样本随机抽取700次，然后剩下的样本集作为测试集，分层抽样保证了训练集的正负样本的比例与数据集D的正负样本比例相同。<br> 留出法的另一个问题是训练集S和测试集T是从数据集D随机抽样得到的，因此偶然性较大，需要多次进出留出法计算每次的测试误差率，然后对每次的测试误差率求平均，减小偶然因素。</p> 
<h5><a id="_122"></a>交叉验证法</h5> 
<p>“交叉验证法”（cross validation）先将数据集D划分为k个大小相似的互斥子集。<br> 每个子集通过分层采样得到（如上节所述，为了保证正负样本的比例与数据集D的比例相同），然后用k-1个子集的并集作为训练集，余下的子集作为测试集；这样就获得k组训练/测试集，从而进行k次训练和测试，最后返回的是这k个测试结果的均值。通常把交叉验证法称为“k折交叉验证法”，k最常用的取值是10，此时称为10折交叉验证。<br> 初始数据集的概率分布：<br> <img src="https://images2.imgbox.com/b6/84/sn3l0leZ_o.png" alt="在这里插入图片描述"><br> 十折交叉验证的第一折的训练集的概率分布：<img src="https://images2.imgbox.com/46/1b/jJAiGlUR_o.png" alt="在这里插入图片描述"><br> 十折交叉验证的训练集只包含了初始数据集的90%，训练数据集和初始数据集的概率分布不一样，因此用十折交叉验证估计的模型存在估计偏差。</p> 
<h5><a id="_129"></a>自助法</h5> 
<p>我们希望评估的是用原始数据集D训练出的模型，但是留出法和交叉验证法训练的数据集比原始的数据集D小，这必然会引入因训练数据集不同导致的估计偏差，留一法受训练样本规模变化的影响较小，但是计算复杂度太高。<br> **“自助法”（bootstrapping）**是有放回抽样，给定包含m个样本的数据集D，我们对它进行采样产生数据集D’ ：每次随机从D中挑选一个样本，将该样本拷贝放入D’ ，然后再将该样本放回初始数据集D中，下次抽样时仍然有可能被采到；重复执行m次该过程，我们就得到了包含m个样本数据集D’ ,这就是自助采样的结果。初始数据集D中有一部分样本会在数据集 D’ 中多次出现，也有一部分样本不会在数据集 D’中出现。</p> 
<h3><a id="_132"></a>性能度量</h3> 
<h4><a id="_133"></a>错误率和精度</h4> 
<p>错误率和精度是分类任务中最常用的两种性能度量。错误率是指分类错误的样本数占样本总数的比例。精度是指分类正确的样本数占样本总数的比例。对样例集D，分类错误率定义为：<br> <img src="https://images2.imgbox.com/59/0b/0fyt329U_o.png" alt="在这里插入图片描述"><br> 精度定义为：<br> <img src="https://images2.imgbox.com/60/8e/FGae8akm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/32/cd/yMXRxnGo_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="F1_139"></a>查准率、查全率和F1</h4> 
<p>对于二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为真正例、假正例、真反例和假反例四种情形，令TP、FP、TN、FN分别表示其对应的样例数，则显然有TP+FP+TN+FN=样例总数。分类结果的混淆矩阵如下表所示。<br> <img src="https://images2.imgbox.com/ab/54/NGftuFpd_o.png" alt="在这里插入图片描述"><br> 查准率P和查全率R的定义：<br> <img src="https://images2.imgbox.com/da/24/HzIFRHDK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ed/3e/xFVBwaRO_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="ROCAUC_145"></a>ROC和AUC曲线</h4> 
<p>ROC曲线全称“受试者工作特征曲线”（Receiver Operation Characteristic Curve）。ROC曲线就是以TPR（true positive rate） 和FPR（false positive rate）为轴，取不同的阈值点画的。它源于“二战”中用于敌机检测的雷达信号分析技术，二十世纪六七十年代开始被用于一些心理学、医学检测中，此后被引入机器学习领域。<br> ROC：纵轴：真正例率TPR；横轴：假正例率FPR。<br> AUC是ROC曲线下的面积。一般来说，如果ROC是光滑的，那么基本可以判断没有太大的overfitting，这个时候调模型可以只看AUC，面积越大一般认为模型越好。<br> <img src="https://images2.imgbox.com/93/bf/jCxLx2Oi_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f0566dfc72dfc788dcc1e90a43bcaa8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">iphone死机屏幕没反应？可以用这2种办法解决！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cb74550c2a28668a77efb7872c80fbaa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DDR为什么需要DQS信号？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>