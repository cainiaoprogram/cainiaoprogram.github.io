<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【lombok】@Cleanup - 自动资源管理，安全的调用close方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【lombok】@Cleanup - 自动资源管理，安全的调用close方法" />
<meta property="og:description" content="版权声明：本文为博主原创文章，转载请注明出处。 https://blog.csdn.net/amoscn/article/details/86544468
@Cleanup
当在处理文件对象，或者数据库资源时，我们总是会忘记close，可能引发内存溢出。
如果手动去调用close方法，代码又会非常长，现在有了@Cleanup , 我们不再需要担心这些问题。
您可以使用@Cleanup确保在代码执行路径退出当前作用域之前自动清除给定资源。 您可以通过使用@Cleanup注释来注释任何局部变量声明来执行此操作，如下所示：
@Cleanup InputStream in = new FileInputStream（“some / file”）;
因此，在您所在范围的末尾，调用in.close（）。 保证通过try / finally构造运行此调用。 请看下面的示例，看看它是如何工作的。
如果要清理的对象类型没有close（）方法，而是其他一些无参数方法，则可以指定此方法的名称，如下所示：
@Cleanup（“dispose”）org.eclipse.swt.widgets.CoolBar bar = new CoolBar（parent，0）;
默认情况下，清除方法假定为close（）。 不能通过@Cleanup调用带有1个或多个参数的清理方法。
为了方便理解，我们假设该内存资源是一扇门。初始化的时候，这扇门默认是打开的，等于说允许你在房间里做一些事情（看书，打游戏，睡觉） - 方法调用。将内存资源回收当作把门关掉，也就是不再允许你再做上述动作。（也许有人说，我可以关门看书，打游戏，睡觉！！！只是示例而已，别杠！！！）
看代码！非常简单易懂！！
package com.amos.lombok;
import lombok.Cleanup;
/**
* @author chenjun
*/
public class Door {
/**
* 门是否打开
* true : 打开
* false : 关闭
*/
private boolean openStatus;
public Door(boolean openStatus) {
this.openStatus = openStatus;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3d7140208a83cd0dea12a2a54b3f48d4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-13T11:39:38+08:00" />
<meta property="article:modified_time" content="2019-08-13T11:39:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【lombok】@Cleanup - 自动资源管理，安全的调用close方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>版权声明：本文为博主原创文章，转载请注明出处。 <a href="https://blog.csdn.net/amoscn/article/details/86544468">https://blog.csdn.net/amoscn/article/details/86544468</a></p> 
<p> </p> 
<p>@Cleanup<br> 当在处理文件对象，或者数据库资源时，我们总是会忘记close，可能引发内存溢出。</p> 
<p>如果手动去调用close方法，代码又会非常长，现在有了@Cleanup , 我们不再需要担心这些问题。</p> 
<p>您可以使用@Cleanup确保在代码执行路径退出当前作用域之前自动清除给定资源。 您可以通过使用@Cleanup注释来注释任何局部变量声明来执行此操作，如下所示：<br> @Cleanup InputStream in = new FileInputStream（“some / file”）;<br> 因此，在您所在范围的末尾，调用in.close（）。 保证通过try / finally构造运行此调用。 请看下面的示例，看看它是如何工作的。</p> 
<p>如果要清理的对象类型没有close（）方法，而是其他一些无参数方法，则可以指定此方法的名称，如下所示：<br> @Cleanup（“dispose”）org.eclipse.swt.widgets.CoolBar bar = new CoolBar（parent，0）;<br> 默认情况下，清除方法假定为close（）。 不能通过@Cleanup调用带有1个或多个参数的清理方法。</p> 
<p>为了方便理解，我们假设该内存资源是一扇门。初始化的时候，这扇门默认是打开的，等于说允许你在房间里做一些事情（看书，打游戏，睡觉） - 方法调用。将内存资源回收当作把门关掉，也就是不再允许你再做上述动作。（也许有人说，我可以关门看书，打游戏，睡觉！！！只是示例而已，别杠！！！）</p> 
<p>看代码！非常简单易懂！！</p> 
<p>package com.amos.lombok;</p> 
<p>import lombok.Cleanup;</p> 
<p>/**<br>  * @author chenjun<br>  */<br> public class Door {<!-- --></p> 
<p>    /**<br>      * 门是否打开<br>      * true : 打开<br>      * false : 关闭<br>      */<br>     private boolean openStatus;</p> 
<p>    public Door(boolean openStatus) {<!-- --><br>         this.openStatus = openStatus;<br>     }</p> 
<p>    public Door() {<!-- --><br>         this.openStatus = true;<br>         System.out.println("初始化时，门的状态默认是-打开 ");<br>     }</p> 
<p>    public void function() {<!-- --><br>         System.out.println("调用该对象的某一个或者多个方法ing");<br>     }</p> 
<p>    public void close() {<!-- --><br>         System.out.println("关门之前，门的状态是-" + (this.openStatus ? "打开" : "关闭"));<br>         this.openStatus = false;<br>         System.out.println("关门之前，门的状态是-关闭");<br>     }</p> 
<p>    public static void main(String[] args) {<!-- --><br>         @Cleanup Door door = new Door();<br>         door.function();<br>     }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 37<br> 38<br> 39<br> 40<br> 执行main方式，打印数据如下：</p> 
<p>初始化时，门的状态默认是-打开<br> 调用该对象的某一个或者多个方法ing<br> 关门之前，门的状态是-打开<br> 关门之前，门的状态是-关闭</p> 
<p>可以看出，当在新建的door对象上加上@Cleanup注解后，它会在我们调用完function方法后，自动的帮我们调用close方法。希望你自己去试试看，看虽然能看懂，但是手动写一下加深印象</p> 
<p>编译完后，改main方法生成的class文件如下:</p> 
<p>public static void main(String[] args) {<!-- --><br>         Door door = new Door();</p> 
<p>        try {<!-- --><br>             door.function();<br>         } finally {<!-- --><br>             if (Collections.singletonList(door).get(0) != null) {<!-- --><br>                 door.close();<br>             }</p> 
<p>        }</p> 
<p>    }<br> --------------------- <br> 版权声明：本文为CSDN博主「吃菜不吃饭」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/amoscn/article/details/86544468</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p><a href="https://www.jianshu.com/p/f0b1b602d0c9" rel="nofollow">https://www.jianshu.com/p/f0b1b602d0c9</a></p> 
<p> </p> 
<h2>@Cleanup</h2> 
<p><a href="https://www.jianshu.com/u/db77d1884e8a" rel="nofollow"><img alt="96" class="has" src="https://images2.imgbox.com/6f/ce/tHLUhfZt_o.jpg"></a> <a href="https://www.jianshu.com/u/db77d1884e8a" rel="nofollow">eagle_king</a> 关注</p> 
<p>2019.01.13 15:10 字数 599 阅读 1193评论 0喜欢 0</p> 
<h2>@Cleanup</h2> 
<p>自动资源管理：没有麻烦和安全地调用您的<code>close()</code>方法。</p> 
<h3>Overview</h3> 
<p>您可以使用@<code>Cleanup</code>以确保在代码执行路径退出当前作用域之前自动清除给定资源。您可以通过使用<code>@Cleanup</code>注释任何局部变量声明来执行此操作：<br><code>@Cleanup InputStream in = new FileInputStream("some/file");</code><br> 结果，在您作用域范围的末尾调用<code>in.close()</code>。保证通过try / finally构造运行此调用。请看下面的示例，看看它是如何工作的。</p> 
<p>如果要清理的对象类型没有<code>close()</code>方法，但是有其他一些无参数方法，则可以指定此方法的名称，如下所示：<br><code>@Cleanup("dispose") org.eclipse.swt.widgets.CoolBar bar = new CoolBar(parent, 0);</code><br> 默认情况下，清除方法被假定为<code>close()</code>。<code>@Cleanup</code>无法调用带有1个或多个参数的清理方法。</p> 
<h3>With Lombok</h3> 
<pre class="has"><code>import lombok.Cleanup;
import java.io.*;

public class CleanupExample {
  public static void main(String[] args) throws IOException {
    @Cleanup InputStream in = new FileInputStream(args[0]);
    @Cleanup OutputStream out = new FileOutputStream(args[1]);
    byte[] b = new byte[10000];
    while (true) {
      int r = in.read(b);
      if (r == -1) break;
      out.write(b, 0, r);
    }
  }
}
</code></pre> 
<h3>Vanilla Java</h3> 
<pre class="has"><code>import java.io.*;

public class CleanupExample {
  public static void main(String[] args) throws IOException {
    InputStream in = new FileInputStream(args[0]);
    try {
      OutputStream out = new FileOutputStream(args[1]);
      try {
        byte[] b = new byte[10000];
        while (true) {
          int r = in.read(b);
          if (r == -1) break;
          out.write(b, 0, r);
        }
      } finally {
        if (out != null) {
          out.close();
        }
      }
    } finally {
      if (in != null) {
        in.close();
      }
    }
  }
}
</code></pre> 
<h3>Supported configuration keys:</h3> 
<p><code>lombok.cleanup.flagUsage = [warning | error] (default: not set)</code><br> 如果配置， Lombok会将任何<code>@Cleanup</code>用法标记为警告或错误。</p> 
<h3>Small print</h3> 
<p>在finally块中，只有在给定资源不是<code>null</code>的情况下才会调用cleanup方法。但是，如果您使用<code>delombok</code>在代码上，则插入<code>lombok.Lombok.preventNullAnalysis(Object o)</code>调用以防止警告，如果静态代码分析可以确定，则不需要进行 null-check。使用 lombok.jar 类路径进行编译会删除该方法调用，因此不存在运行时依赖性。</p> 
<p>如果您的代码抛出异常，并且随后触发的清理方法调用也会抛出异常，则清理调用抛出的异常将隐藏原始异常。你不应该依赖这个“功能”。最好是，lombok想生成代码，这样，如果主体抛出了异常，那么关闭调用抛出的任何异常都会被静默吞噬（但如果主体以任何其他方式退出，则关闭调用的异常将不会是吞咽）。lombok的作者目前不知道实现这个方案的可行方法，但是如果java更新允许它，或者我们找到了一种方法，我们将修复它。</p> 
<p>您仍然需要处理清理方法可以生成的任何异常！</p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07fe54d7490eb8d5224d270ecb6499d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">开机启动cmd程序并执行指令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed7ec847e7fe2f29ca7705351adb6d9e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java的lamada表达式常用例子</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>