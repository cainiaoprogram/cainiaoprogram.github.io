<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>为什么要用递归以及递归如何书写？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="为什么要用递归以及递归如何书写？" />
<meta property="og:description" content="一.为什么要用递归 一般情况下我们的程序是用递推，一步一步往下写，这样也符合我们思考问题的方式。那上面情况下要用递归呢？就是当数据或者问题不是线性而是树状或者图状的时候。
就拿我第一次遇见递归的爬楼梯问题举例，是一道非常经典的题目。
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例 1： 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 &#43; 1 阶 2. 2 阶 示例 2： 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 &#43; 1 阶 &#43; 1 阶 2. 1 阶 &#43; 2 阶 3. 2 阶 &#43; 1 阶 比如是3，我们每次爬有两种情况，爬一次，爬两次，然后每次爬完下次爬也会面临多次选择，有多少种情况我们是没办法事先知道的，所以这就是一种树的模型。
如果用递推并不是没法写，可以用队列模拟，先将对后序有影响的情况推入队列，等到与情况相关的子情况遍历完再排出队列。
但是这种树的问题，最适合的是用递归来解决。递归就是模拟我们画这颗树解决问题的过程，更加形象直观，便于理解。
当然，递归不是万能的，不要任何事情都用递归，如果是线性问题，就不要用递归。
解决线性问题的时候，首先递归通常伴有重复的计算加上很多的函数调用，所以时间复杂度通常比递推慢。就算加入动态规划，使得时间复杂度勉强达到一个层次，动态规划的数组与函数调用时需要保存的状态所需的空间复杂度肯定更高。最重要的是思路还变得更为麻烦。
综上所述，递归适用于树状或者图状的问题/数据。
二.递归怎么书写？ 例题：给定一棵树的前序遍历数组，判断这棵树是不是二叉搜索树。 第一步：首先你分析问题，要有递归的思路，知道要递归什么来解决问题。 比如上面这个通过前序遍历判断搜索二叉树，首先我们要清楚二叉搜索树的定义。
根据定义，我们不难得出思路，先判断这颗二叉树的左子树（不为空的话）的所有结点是不是小于它的根结点，再判断右子树（不为空的话）的所有结点是不是大于它的根结点。
然后递归判断其左右子树（如果有的话）是不是也满足这个条件。
另外的话你也要清楚前序遍历的特点，第一个结点一定为根节点，然后的话遍历顺序为根结点-&gt;左子树-&gt;右子树。
结合搜索二叉树，我们可以得出第一个点为根结点，然后往后找，第一个比根结点小的树为左子树的根结点，第一个比根节点大的为右子树的根节点，左子树根节点与右子树根结点之间为左子树的前序遍历序列，右子树之后为右子树的前序遍历序列。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2d1ce507697eef78e76475630a8a6a26/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T16:55:21+08:00" />
<meta property="article:modified_time" content="2023-12-28T16:55:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">为什么要用递归以及递归如何书写？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一.为什么要用递归</h3> 
<p>一般情况下我们的程序是用递推，一步一步往下写，这样也符合我们思考问题的方式。那上面情况下要用递归呢？就是当数据或者问题不是线性而是树状或者图状的时候。</p> 
<p>就拿我第一次遇见递归的爬楼梯问题举例，是一道非常经典的题目。</p> 
<pre><code>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶</code></pre> 
<p>比如是3，我们每次爬有两种情况，爬一次，爬两次，然后每次爬完下次爬也会面临多次选择，有多少种情况我们是没办法事先知道的，所以这就是一种树的模型。<br><img alt="" height="211" src="https://images2.imgbox.com/2d/af/RdDA8cZY_o.jpg" width="282"></p> 
<p>如果用递推并不是没法写，可以用队列模拟，先将对后序有影响的情况推入队列，等到与情况相关的子情况遍历完再排出队列。</p> 
<p><strong>但是这种树的问题，最适合的是用递归来解决。递归就是模拟我们画这颗树解决问题的过程，更加形象直观，便于理解。</strong></p> 
<p>当然，递归不是万能的，不要任何事情都用递归，<strong>如果是线性问题，就不要用递归。</strong></p> 
<p>解决线性问题的时候，首先递归通常伴有重复的计算加上很多的函数调用，所以时间复杂度通常比递推慢。就算加入动态规划，使得时间复杂度勉强达到一个层次，动态规划的数组与函数调用时需要保存的状态所需的空间复杂度肯定更高。最重要的是思路还变得更为麻烦。</p> 
<p><strong>综上所述，递归适用于树状或者图状的问题/数据。</strong></p> 
<h3>二.递归怎么书写？</h3> 
<h4 id="main-toc">例题：给定一棵树的前序遍历数组，判断这棵树是不是二叉搜索树。</h4> 
<h4 id="%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E9%A6%96%E5%85%88%E4%BD%A0%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98%EF%BC%8C%E8%A6%81%E6%9C%89%E9%80%92%E5%BD%92%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%8C%E7%9F%A5%E9%81%93%E8%A6%81%E9%80%92%E5%BD%92%E4%BB%80%E4%B9%88%E6%9D%A5%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E3%80%82">第一步：首先你分析问题，要有递归的思路，知道要递归什么来解决问题。</h4> 
<p>比如上面这个通过前序遍历判断搜索二叉树，首先我们要清楚二叉搜索树的定义。</p> 
<p><img alt="" height="143" src="https://images2.imgbox.com/f8/ec/cRpQzA0Z_o.png" width="1200">根据定义，我们不难得出思路，<strong>先判断这颗二叉树的左子树（不为空的话）的所有结点是不是小于它的根结点，再判断右子树（不为空的话）的所有结点是不是大于它的根结点。</strong></p> 
<p>然后递归判断其左右子树（如果有的话）是不是也满足这个条件。</p> 
<p>另外的话你也要清楚前序遍历的特点，第一个结点一定为根节点，然后的话遍历顺序为根结点-&gt;左子树-&gt;右子树。</p> 
<p><strong>结合搜索二叉树，我们可以得出第一个点为根结点，然后往后找，第一个比根结点小的树为左子树的根结点，第一个比根节点大的为右子树的根节点，左子树根节点与右子树根结点之间为左子树的前序遍历序列，右子树之后为右子树的前序遍历序列。</strong></p> 
<p><strong>我们只需要看左子树的序列是不是都比根结点的数据小，右子树的序列是不是都比根节点的数据大。然后的话递归遍历左右子树的前序遍历序列看看是不是符合这个特点。</strong></p> 
<h4 id="%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%85%88%E6%8C%89%E7%85%A7%E6%80%9D%E8%B7%AF%EF%BC%88%E7%AC%AC%E4%B8%80%E5%B1%82%EF%BC%89%E5%86%99%E5%87%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%87%BD%E6%95%B0%E4%BD%93">第二步：先按照思路（第一层）写出函数的定义与函数体</h4> 
<p>一般的话写函数都是先确定函数的定义与输入，然后按照思路写输出。</p> 
<p>而递归函数的话我认为要先写思路和定义再写输入,或者先写部分输入，然后写完思路后再过来修改。</p> 
<pre><code class="language-cpp">bool isBST() {
	int rootData=tree[leftBound].data;
	//寻找第一个比根结点小的数是左子树的根结点，
	//寻找第一个比根结点大与或等于的数即时右子树的根节点
	int leftRoot=-1,rightRoot=-1;
	for(int i=1; i&lt;=n-1; i++) {
		if(tree[i].data&lt;rootData&amp;&amp;leftRoot==-1) {
			leftRoot=i;
		} else if(tree[i].data&gt;=rootData&amp;&amp;rightRoot==-1) {
			rightRoot=i;
			break;
		}
	}
    bool haveLeft=(leftRoot!=-1);//是否存在左子树
	bool haveRight=(rightRoot!=-1);//是否存在右子树
    //	根据左子树根结点和右子树根结点即可划分出左右子树
    //	遍历左子树，看看是不是都比根结点小（如果有的话）
	if(haveLeft) {
		for(int i=leftRoot; i&lt;=rightRoot-1; i++) {
			if(rootData&lt;=tree[i].data) {
				return false;
			}
		}
	}
    //遍历右子树，看看是不是都比根结点大（如果有的话）
	if(haveRight) {
		for(int i=rightRoot; i&lt;=0; i++) {
			if(rootData&gt;tree[i].data) {
				return false;
			}
		}
	}

	//子树也要满足是二叉搜索树（如果有的话）
	if(haveLeft&amp;&amp;haveRight) {
        //左子树
		if(!isBST())
			return false;
        //右子树
		if(!isBST())
			return false;
	} else if(haveLeft&amp;&amp;!haveRight) {
		if(!isBST())
			return false;
	} else if(!haveLeft&amp;&amp;haveRight) {
		if(!isBST())
			return false;
	}

	return true;
}</code></pre> 
<h4 id="%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E6%A0%B9%E6%8D%AE%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%87%BD%E6%95%B0%E4%BD%93%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%A1%AE%E5%AE%9A%E9%9C%80%E8%A6%81%E7%9A%84%E5%8F%82%E6%95%B0">第三步：根据函数的定义与函数体进一步确定需要的参数，并修改原来的代码</h4> 
<p>上面的话我们的话我们肯定需要有一个tree数组代表数，另外的话我们上面的遍历是遍历整棵树，是从0到n-1，但是为了这个函数能够复用，所以我们需要传入leftBound和rightBound，即数组的左界和有界来确定一颗树。</p> 
<p>添加参数并修改代码：</p> 
<pre><code class="language-cpp">bool isBST(TreeNode tree[],int leftBound,int rightBound) {
	int rootData=tree[leftBound].data;
	//寻找第一个比根结点小的数是左子树的根结点，
	//寻找第一个比根结点大与或等于的数即时右子树的根节点
	int leftRoot=-1,rightRoot=-1;
	for(int i=leftBound+1; i&lt;=rightBound; i++) {
		if(tree[i].data&lt;rootData&amp;&amp;leftRoot==-1) {
			leftRoot=i;
		} else if(tree[i].data&gt;=rootData&amp;&amp;rightRoot==-1) {
			rightRoot=i;
			break;
		}
	}
//	根据左子树根结点和右子树根结点即可划分出左右子树
//	遍历左子树，看看是不是都比根结点小
	bool haveLeft=(leftRoot!=-1);
	bool haveRight=(rightRoot!=-1);
	if(haveLeft) {
		for(int i=leftRoot; i&lt;=rightRoot-1; i++) {
			if(rootData&lt;=tree[i].data) {
				return false;
			}
		}
	}
	if(haveRight) {
		//遍历右子树，看看是不是都比根结点大
		for(int i=rightRoot; i&lt;=rightBound; i++) {
			if(rootData&gt;tree[i].data) {
				return false;
			}
		}
	}

	//子树也要满足是二叉搜索树
	if(haveLeft&amp;&amp;haveRight) {
		if(!isBST(tree,leftRoot,rightRoot-1))
			return false;
		if(!isBST(tree,rightRoot,rightBound))
			return false;
	} else if(haveLeft&amp;&amp;!haveRight) {
		if(!isBST(tree,leftRoot,rightBound))
			return false;
	} else if(!haveLeft&amp;&amp;haveRight) {
		if(!isBST(tree,rightRoot,rightBound))
			return false;
	}

	return true;
}</code></pre> 
<h4 id="%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E8%AE%BE%E5%AE%9A%E6%9C%80%E5%90%8E%E4%B8%80%E5%B1%82%E9%80%92%E5%BD%92%E7%9A%84%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6%EF%BC%8C%E4%BB%A5%E5%85%8D%E4%B8%80%E7%9B%B4%E5%BE%AA%E7%8E%AF%E4%B8%8B%E5%8E%BB%E3%80%82">第四步：最后还要设定最后一层递归的终止条件，以免一直循环下去。</h4> 
<p>这题的话最终的话循环到最后的树一定就只剩下一个点，一个点的话肯定为搜索二叉树。</p> 
<p>添加终止条件完成程序。</p> 
<pre><code class="language-cpp">bool isBST(TreeNode tree[],int leftBound,int rightBound) {
	if(leftBound==rightBound) {
		return true;
	}
	int rootData=tree[leftBound].data;
	//寻找第一个比根结点小的数是左子树的根结点，
	//寻找第一个比根结点大与或等于的数即时右子树的根节点
	int leftRoot=-1,rightRoot=-1;
	for(int i=leftBound+1; i&lt;=rightBound; i++) {
		if(tree[i].data&lt;rootData&amp;&amp;leftRoot==-1) {
			leftRoot=i;
		} else if(tree[i].data&gt;=rootData&amp;&amp;rightRoot==-1) {
			rightRoot=i;
			break;
		}
	}
//	根据左子树根结点和右子树根结点即可划分出左右子树
//	遍历左子树，看看是不是都比根结点小
	bool haveLeft=(leftRoot!=-1);
	bool haveRight=(rightRoot!=-1);
	if(haveLeft) {
		for(int i=leftRoot; i&lt;=rightRoot-1; i++) {
			if(rootData&lt;=tree[i].data) {
				return false;
			}
		}
	}
	if(haveRight) {
		//遍历右子树，看看是不是都比根结点大
		for(int i=rightRoot; i&lt;=rightBound; i++) {
			if(rootData&gt;tree[i].data) {
				return false;
			}
		}
	}

	//子树也要满足是二叉搜索树
	if(haveLeft&amp;&amp;haveRight) {
		if(!isBST(tree,leftRoot,rightRoot-1))
			return false;
		if(!isBST(tree,rightRoot,rightBound))
			return false;
	} else if(haveLeft&amp;&amp;!haveRight) {
		if(!isBST(tree,leftRoot,rightBound))
			return false;
	} else if(!haveLeft&amp;&amp;haveRight) {
		if(!isBST(tree,rightRoot,rightBound))
			return false;
	}

	return true;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8183919ceafb1521e8b413df121cae0d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python】Python通过setup.py安装模块、卸载模块</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/847c4a83b1d2633915d041110d19a605/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">零知识证明（zk-SNARK）- groth16（二）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>