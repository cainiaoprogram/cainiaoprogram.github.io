<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue基础知识汇总 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue基础知识汇总" />
<meta property="og:description" content="目录
一.初识Vue
二.Vue模板语法
三.数据绑定
四.el与data的两种写法
五.MVVM模型
六.Vue中的数据代理
七.事件处理
事件的基本使用：
Vue中的事件修饰符：
键盘事件：
八.计算属性
九.监视属性
监视属性watch：
深度监视：
computed和watch之间的区别：
十.绑定样式
十一.条件渲染
十二.列表渲染
v-for指令:
react、vue中的key有什么作用？（key的内部原理）
Vue监视数据的原理：
十三.收集表单数据
十四.过滤器
十五.内置指令
我们学过的指令：
v-text指令：
v-html指令：
v-cloak指令（没有值）：
v-once指令：
v-pre指令：
十六.自定义指令
十七.生命周期
常用的生命周期钩子：
关于销毁Vue实例
十八.非单文件组件
Vue中使用组件的三大步骤：
几个注意点：
关于VueComponent：
一.初识Vue 1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；
2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；
3.root容器里的代码被称为【Vue模板】；
4.Vue实例和容器是一一对应的；
5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；
6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；
7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；
注意区分：js表达式 和 js代码(语句)
1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：
(1). a
(2). a&#43;b
(3). demo(1)
(4). x === y ? &#39;a&#39; : &#39;b&#39;
2.js代码(语句)
(1). if(){}
(2). for(){}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/aa4f0ec2822091aceb65119a90df6a93/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-17T15:47:50+08:00" />
<meta property="article:modified_time" content="2023-05-17T15:47:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue基础知识汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80.%E5%88%9D%E8%AF%86Vue-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%88%9D%E8%AF%86Vue" rel="nofollow">一.初识Vue</a></p> 
<p id="%E4%BA%8C.Vue%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.Vue%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95" rel="nofollow">二.Vue模板语法</a></p> 
<p id="%E4%B8%89.%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A" rel="nofollow">三.数据绑定</a></p> 
<p id="%E5%9B%9B.el%E4%B8%8Edata%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.el%E4%B8%8Edata%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95" rel="nofollow">四.el与data的两种写法</a></p> 
<p id="%E4%BA%94.MVVM%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%94.MVVM%E6%A8%A1%E5%9E%8B" rel="nofollow">五.MVVM模型</a></p> 
<p id="%E5%85%AD.Vue%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86-toc" style="margin-left:0px;"><a href="#%E5%85%AD.Vue%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86" rel="nofollow">六.Vue中的数据代理</a></p> 
<p id="%E4%B8%83.%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%B8%83.%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86" rel="nofollow">七.事件处理</a></p> 
<p id="%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A" rel="nofollow">事件的基本使用：</a></p> 
<p id="Vue%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A-toc" style="margin-left:80px;"><a href="#Vue%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A" rel="nofollow">Vue中的事件修饰符：</a></p> 
<p id="%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%EF%BC%9A" rel="nofollow">键盘事件：</a></p> 
<p id="%E5%85%AB.%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-toc" style="margin-left:0px;"><a href="#%E5%85%AB.%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7" rel="nofollow">八.计算属性</a></p> 
<p id="%E4%B9%9D.%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#%E4%B9%9D.%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7" rel="nofollow">九.监视属性</a></p> 
<p id="%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7watch%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7watch%EF%BC%9A" rel="nofollow">监视属性watch：</a></p> 
<p id="%E6%B7%B1%E5%BA%A6%E7%9B%91%E8%A7%86%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%B7%B1%E5%BA%A6%E7%9B%91%E8%A7%86%EF%BC%9A" rel="nofollow">深度监视：</a></p> 
<p id="computed%E5%92%8Cwatch%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A-toc" style="margin-left:80px;"><a href="#computed%E5%92%8Cwatch%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A" rel="nofollow">computed和watch之间的区别：</a></p> 
<p id="%E5%8D%81.%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E5%8D%81.%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F" rel="nofollow">十.绑定样式</a></p> 
<p id="%E5%8D%81%E4%B8%80.%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%80.%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93" rel="nofollow">十一.条件渲染</a></p> 
<p id="%E5%8D%81%E4%BA%8C.%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%BA%8C.%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93" rel="nofollow">十二.列表渲染</a></p> 
<p id="v-for%E6%8C%87%E4%BB%A4%3A-toc" style="margin-left:80px;"><a href="#v-for%E6%8C%87%E4%BB%A4%3A" rel="nofollow">v-for指令:</a></p> 
<p id="react%E3%80%81vue%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88key%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%EF%BC%89-toc" style="margin-left:80px;"><a href="#react%E3%80%81vue%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88key%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%EF%BC%89" rel="nofollow">react、vue中的key有什么作用？（key的内部原理）</a></p> 
<p id="Vue%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A-toc" style="margin-left:80px;"><a href="#Vue%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A" rel="nofollow">Vue监视数据的原理：</a></p> 
<p id="%E5%8D%81%E4%B8%89.%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%89.%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE" rel="nofollow">十三.收集表单数据</a></p> 
<p id="%E5%8D%81%E5%9B%9B.%E8%BF%87%E6%BB%A4%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E5%9B%9B.%E8%BF%87%E6%BB%A4%E5%99%A8" rel="nofollow">十四.过滤器</a></p> 
<p id="%E5%8D%81%E4%BA%94.%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%BA%94.%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4" rel="nofollow">十五.内置指令</a></p> 
<p id="%E6%88%91%E4%BB%AC%E5%AD%A6%E8%BF%87%E7%9A%84%E6%8C%87%E4%BB%A4%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%88%91%E4%BB%AC%E5%AD%A6%E8%BF%87%E7%9A%84%E6%8C%87%E4%BB%A4%EF%BC%9A" rel="nofollow">我们学过的指令：</a></p> 
<p id="v-text%E6%8C%87%E4%BB%A4%EF%BC%9A-toc" style="margin-left:80px;"><a href="#v-text%E6%8C%87%E4%BB%A4%EF%BC%9A" rel="nofollow">v-text指令：</a></p> 
<p id="v-html%E6%8C%87%E4%BB%A4%EF%BC%9A-toc" style="margin-left:80px;"><a href="#v-html%E6%8C%87%E4%BB%A4%EF%BC%9A" rel="nofollow">v-html指令：</a></p> 
<p id="v-cloak%E6%8C%87%E4%BB%A4%EF%BC%88%E6%B2%A1%E6%9C%89%E5%80%BC%EF%BC%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#v-cloak%E6%8C%87%E4%BB%A4%EF%BC%88%E6%B2%A1%E6%9C%89%E5%80%BC%EF%BC%89%EF%BC%9A" rel="nofollow">v-cloak指令（没有值）：</a></p> 
<p id="v-once%E6%8C%87%E4%BB%A4%EF%BC%9A-toc" style="margin-left:80px;"><a href="#v-once%E6%8C%87%E4%BB%A4%EF%BC%9A" rel="nofollow">v-once指令：</a></p> 
<p id="v-pre%E6%8C%87%E4%BB%A4%EF%BC%9A-toc" style="margin-left:80px;"><a href="#v-pre%E6%8C%87%E4%BB%A4%EF%BC%9A" rel="nofollow">v-pre指令：</a></p> 
<p id="%E5%8D%81%E5%85%AD.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E5%85%AD.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4" rel="nofollow">十六.自定义指令</a></p> 
<p id="%E5%8D%81%E4%B8%83.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%83.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">十七.生命周期</a></p> 
<p id="%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%EF%BC%9A" rel="nofollow">常用的生命周期钩子：</a></p> 
<p id="%E5%85%B3%E4%BA%8E%E9%94%80%E6%AF%81Vue%E5%AE%9E%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%E5%85%B3%E4%BA%8E%E9%94%80%E6%AF%81Vue%E5%AE%9E%E4%BE%8B" rel="nofollow">关于销毁Vue实例</a></p> 
<p id="%E5%8D%81%E5%85%AB.%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E5%85%AB.%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6" rel="nofollow">十八.非单文件组件</a></p> 
<p id="Vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E5%A4%A7%E6%AD%A5%E9%AA%A4%EF%BC%9A-toc" style="margin-left:80px;"><a href="#Vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E5%A4%A7%E6%AD%A5%E9%AA%A4%EF%BC%9A" rel="nofollow">Vue中使用组件的三大步骤：</a></p> 
<p id="%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A" rel="nofollow">几个注意点：</a></p> 
<p id="%E5%85%B3%E4%BA%8EVueComponent%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%85%B3%E4%BA%8EVueComponent%EF%BC%9A" rel="nofollow">关于VueComponent：</a></p> 
<hr> 
<h2 id="%E4%B8%80.%E5%88%9D%E8%AF%86Vue">一.初识Vue</h2> 
<p>1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</p> 
<p>2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；</p> 
<p>3.root容器里的代码被称为【Vue模板】；</p> 
<p>4.Vue实例和容器是一一对应的；</p> 
<p>5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；</p> 
<p>6.{<!-- -->{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；</p> 
<p>7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p> 
<p>注意区分：js表达式 和 js代码(语句)</p> 
<p>        1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：</p> 
<p>                      (1). a</p> 
<p>                      (2). a+b</p> 
<p>                      (3). demo(1)</p> 
<p>                      (4). x === y ? 'a' : 'b'</p> 
<p>          2.js代码(语句)</p> 
<p>                       (1). if(){}</p> 
<p>                       (2). for(){}</p> 
<hr> 
<h2 id="%E4%BA%8C.Vue%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95">二.Vue模板语法</h2> 
<p>Vue模板语法有2大类：</p> 
<p>        1.插值语法：</p> 
<p>                功能：用于解析标签体内容。</p> 
<p>                写法：{<!-- -->{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。</p> 
<p>        2.指令语法：</p> 
<p>                功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。</p> 
<p>                举例：v-bind:href="xxx" 或  简写为 :href="xxx"，xxx同样要写js表达式，且可以直接读取到data中的所有属性。</p> 
<p>                备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</p> 
<hr> 
<h2 id="%E4%B8%89.%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A">三.数据绑定</h2> 
<p>Vue中有2种数据绑定的方式：</p> 
<p>        1.单向绑定(v-bind)：数据只能从data流向页面。</p> 
<p>        2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</p> 
<p>        备注：</p> 
<p>        1.双向绑定一般都应用在表单类元素上（如：input、select等）</p> 
<p>        2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p> 
<hr> 
<h2 id="%E5%9B%9B.el%E4%B8%8Edata%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95">四.el与data的两种写法</h2> 
<p>data与el的2种写法</p> 
<p>        1.el有2种写法</p> 
<p>                (1).new Vue时候配置el属性。</p> 
<p>                (2).先创建Vue实例，随后再通过vm.$mount('#root')指定el的值。</p> 
<p>        2.data有2种写法</p> 
<p>                (1).对象式</p> 
<p>                (2).函数式</p> 
<p>                如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</p> 
<p>        3.一个重要的原则：</p> 
<p>                由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</p> 
<hr> 
<h2 id="%E4%BA%94.MVVM%E6%A8%A1%E5%9E%8B">五.MVVM模型</h2> 
<p>MVVM模型</p> 
<p>        1. M：模型(Model) ：data中的数据</p> 
<p>        2. V：视图(View) ：模板代码</p> 
<p>        3. VM：视图模型(ViewModel)：Vue实例</p> 
<p>        观察发现：</p> 
<p>        1.data中所有的属性，最后都出现在了vm身上。</p> 
<p>        2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p> 
<h2></h2> 
<hr> 
<h2 id="%E5%85%AD.Vue%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86">六.Vue中的数据代理</h2> 
<p>1.Vue中的数据代理：</p> 
<p>        通过vm对象来代理data对象中属性的操作（读/写）</p> 
<p>2.Vue中数据代理的好处：</p> 
<p>        更加方便的操作data中的数据</p> 
<p>3.基本原理：</p> 
<p>        通过Object.defineProperty()把data对象中所有属性添加到vm上。</p> 
<p>        为每一个添加到vm上的属性，都指定一个getter/setter。</p> 
<p>        在getter/setter内部去操作（读/写）data中对应的属性。</p> 
<hr> 
<h2 id="%E4%B8%83.%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86">七.事件处理</h2> 
<h4 id="%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A">事件的基本使用：</h4> 
<p>        1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</p> 
<p>        2.事件的回调需要配置在methods对象中，最终会在vm上；</p> 
<p>        3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；</p> 
<p>        4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</p> 
<p>        5.@click="demo" 和 @click="demo($event)" 效果一致，但后者可以传参；</p> 
<h4 id="Vue%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A">Vue中的事件修饰符：</h4> 
<p>        1.prevent：阻止默认事件（常用）；</p> 
<p>        2.stop：阻止事件冒泡（常用）；</p> 
<p>        3.once：事件只触发一次（常用）；</p> 
<p>        4.capture：使用事件的捕获模式；</p> 
<p>        5.self：只有event.target是当前操作的元素时才触发事件；</p> 
<p>        6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p> 
<h4 id="%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%EF%BC%9A">键盘事件：</h4> 
<p>        1.Vue中常用的按键别名：</p> 
<p>                回车 =&gt; enter</p> 
<p>                删除 =&gt; delete (捕获“删除”和“退格”键)</p> 
<p>                退出 =&gt; esc</p> 
<p>                空格 =&gt; space</p> 
<p>                换行 =&gt; tab (特殊，必须配合keydown去使用)</p> 
<p>                上 =&gt; up</p> 
<p>                下 =&gt; down</p> 
<p>                左 =&gt; left</p> 
<p>                右 =&gt; right</p> 
<p>        2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p> 
<p>        3.系统修饰键（用法特殊）：ctrl、alt、shift、meta</p> 
<p>                (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</p> 
<p>                (2).配合keydown使用：正常触发事件。</p> 
<p>        4.也可以使用keyCode去指定具体的按键（不推荐）</p> 
<p>        5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</p> 
<hr> 
<h2 id="%E5%85%AB.%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7">八.计算属性</h2> 
<p>计算属性：</p> 
<p>        1.定义：要用的属性不存在，要通过已有属性计算得来。</p> 
<p>        2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</p> 
<p>        3.get函数什么时候执行？</p> 
<p>                (1).初次读取时会执行一次。</p> 
<p>                (2).当依赖的数据发生改变时会被再次调用。</p> 
<p>        4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</p> 
<p>         5.备注：</p> 
<p>                1.计算属性最终会出现在vm上，直接读取使用即可。</p> 
<p>                2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p> 
<hr> 
<h4 id="%E4%B9%9D.%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7">九.监视属性</h4> 
<h4 id="%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7watch%EF%BC%9A">监视属性watch：</h4> 
<p>        1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作</p> 
<p>        2.监视的属性必须存在，才能进行监视！！</p> 
<p>        3.监视的两种写法：</p> 
<p>                (1).new Vue时传入watch配置</p> 
<p>                (2).通过vm.$watch监视</p> 
<h4 id="%E6%B7%B1%E5%BA%A6%E7%9B%91%E8%A7%86%EF%BC%9A">深度监视：</h4> 
<p>        (1).Vue中的watch默认不监测对象内部值的改变（一层）。</p> 
<p>        (2).配置deep:true可以监测对象内部值改变（多层）。</p> 
<p>        备注：</p> 
<p>                (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！</p> 
<p>                (2).使用watch时根据数据的具体结构，决定是否采用深度监视。</p> 
<h4 id="computed%E5%92%8Cwatch%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A">computed和watch之间的区别：</h4> 
<p>        1.computed能完成的功能，watch都可以完成。</p> 
<p>        2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p> 
<p>        两个重要的小原则：</p> 
<p>                1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</p> 
<p>                2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，</p> 
<p>                这样this的指向才是vm 或 组件实例对象。</p> 
<hr> 
<h2 id="%E5%8D%81.%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F">十.绑定样式</h2> 
<p>绑定样式：</p> 
<p>        1. class样式</p> 
<p>                写法:class="xxx" xxx可以是字符串、对象、数组。</p> 
<p>                字符串写法适用于：类名不确定，要动态获取。</p> 
<p>                对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p> 
<p>                数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p> 
<p>        2. style样式</p> 
<p>                :style="{fontSize: xxx}"其中xxx是动态值。</p> 
<p>                :style="[a,b]"其中a、b是样式对象。</p> 
<h2></h2> 
<hr> 
<h2 id="%E5%8D%81%E4%B8%80.%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93">十一.条件渲染</h2> 
<p>条件渲染：</p> 
<p>        1.v-if</p> 
<p>                写法：</p> 
<p>                (1).v-if="表达式"</p> 
<p>                (2).v-else-if="表达式"</p> 
<p>                (3).v-else="表达式"</p> 
<p>        适用于：切换频率较低的场景。</p> 
<p>        特点：不展示的DOM元素直接被移除。</p> 
<p>        注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p> 
<p>        2.v-show</p> 
<p>                 写法：v-show="表达式"</p> 
<p>                适用于：切换频率较高的场景。</p> 
<p>                特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉                         </p> 
<p>        3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p> 
<hr> 
<h2 id="%E5%8D%81%E4%BA%8C.%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93">十二.列表渲染</h2> 
<h4 id="v-for%E6%8C%87%E4%BB%A4%3A">v-for指令:</h4> 
<p>        1.用于展示列表数据</p> 
<p>        2.语法：v-for="(item, index) in xxx" :key="yyy"</p> 
<p>        3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p> 
<h4 id="react%E3%80%81vue%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88key%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%EF%BC%89">react、vue中的key有什么作用？（key的内部原理）</h4> 
<p>        1. 虚拟DOM中key的作用：</p> 
<p> key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,</p> 
<p>随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：                                       2.对比规则：</p> 
<p>        (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：</p> 
<p>                ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！</p> 
<p>                ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p> 
<p>        (2).旧虚拟DOM中未找到与新虚拟DOM相同的key</p> 
<p>                创建新的真实DOM，随后渲染到到页面。</p> 
<p>        3. 用index作为key可能会引发的问题：</p> 
<p>                1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:</p> 
<p>        会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</p> 
<p>                2. 如果结构中还包含输入类的DOM：</p> 
<p>        会产生错误DOM更新 ==&gt; 界面有问题。</p> 
<p>                 4. 开发中如何选择key?:</p> 
<p>        1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</p> 
<p>        2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，</p> 
<p>        3.使用index作为key是没有问题的。</p> 
<h4 id="Vue%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A">Vue监视数据的原理：</h4> 
<p>        1. vue会监视data中所有层次的数据。</p> 
<p>        2. 如何监测对象中的数据？</p> 
<p>                通过setter实现监视，且要在new Vue时就传入要监测的数据。</p> 
<p>                (1).对象中后追加的属性，Vue默认不做响应式处理</p> 
<p>                (2).如需给后添加的属性做响应式，请使用如下API：</p> 
<p>                Vue.set(target，propertyName/index，value) 或</p> 
<p>                vm.$set(target，propertyName/index，value)</p> 
<p>        3. 如何监测数组中的数据？</p> 
<p>                通过包裹数组更新元素的方法实现，本质就是做了两件事：</p> 
<p>                 (1).调用原生对应的方法对数组进行更新。</p> 
<p>                (2).重新解析模板，进而更新页面。</p> 
<p>        4.在Vue修改数组中的某个元素一定要用如下方法：</p> 
<p>                1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p> 
<p>                2.Vue.set() 或 vm.$set()           </p> 
<p>        特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</p> 
<h2></h2> 
<hr> 
<h2 id="%E5%8D%81%E4%B8%89.%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE">十三.收集表单数据</h2> 
<p>收集表单数据：</p> 
<p>        若：&lt;input type="text"/&gt;，则v-model收集的是value值，用户输入的就是value值。</p> 
<p>        若：&lt;input type="radio"/&gt;，则v-model收集的是value值，且要给标签配置value值。</p> 
<p>        若：&lt;input type="checkbox"/&gt;</p> 
<p>        1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p> 
<p>        2.配置input的value属性:</p> 
<p>                (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p> 
<p>                (2)v-model的初始值是数组，那么收集的的就是value组成的数组</p> 
<p>        备注：v-model的三个修饰符：</p> 
<p>                lazy：失去焦点再收集数据</p> 
<p>                number：输入字符串转为有效的数字</p> 
<p>                trim：输入首尾空格过滤</p> 
<hr> 
<h2 id="%E5%8D%81%E5%9B%9B.%E8%BF%87%E6%BB%A4%E5%99%A8">十四.过滤器</h2> 
<p>过滤器：</p> 
<p>        定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p> 
<p>        语法：</p> 
<p>                1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}</p> 
<p>                2.使用过滤器：{<!-- -->{ xxx | 过滤器名}}  或  v-bind:属性 = "xxx | 过滤器名"</p> 
<p>        备注：</p> 
<p>                1.过滤器也可以接收额外参数、多个过滤器也可以串联</p> 
<p>                2.并没有改变原本的数据, 是产生新的对应的数据</p> 
<hr> 
<h2 id="%E5%8D%81%E4%BA%94.%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4">十五.内置指令</h2> 
<h4 id="%E6%88%91%E4%BB%AC%E5%AD%A6%E8%BF%87%E7%9A%84%E6%8C%87%E4%BB%A4%EF%BC%9A">我们学过的指令：</h4> 
<p>        v-bind  : 单向绑定解析表达式, 可简写为 :xxx</p> 
<p>        v-model : 双向数据绑定</p> 
<p>        v-for   : 遍历数组/对象/字符串</p> 
<p>        v-on    : 绑定事件监听, 可简写为@</p> 
<p>        v-if        : 条件渲染（动态控制节点是否存存在）</p> 
<p>        v-else  : 条件渲染（动态控制节点是否存存在）</p> 
<p>        v-show  : 条件渲染 (动态控制节点是否展示)</p> 
<h4 id="v-text%E6%8C%87%E4%BB%A4%EF%BC%9A"><strong>v-text指令：</strong></h4> 
<p>        1.作用：向其所在的节点中渲染文本内容。</p> 
<p>        2.与插值语法的区别：v-text会替换掉节点中的内容，{<!-- -->{xx}}则不会。</p> 
<h4 id="v-html%E6%8C%87%E4%BB%A4%EF%BC%9A">v-html指令：</h4> 
<p>        1.作用：向指定节点中渲染包含html结构的内容。</p> 
<p>        2.与插值语法的区别：</p> 
<p>                (1).v-html会替换掉节点中所有的内容，{<!-- -->{xx}}则不会。</p> 
<p>                (2).v-html可以识别html结构。</p> 
<p>        3.严重注意：v-html有安全性问题！！！！</p> 
<p>                (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p> 
<p>                (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p> 
<h4 id="v-cloak%E6%8C%87%E4%BB%A4%EF%BC%88%E6%B2%A1%E6%9C%89%E5%80%BC%EF%BC%89%EF%BC%9A">v-cloak指令（没有值）：</h4> 
<p>        1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</p> 
<p>        2.使用css配合v-cloak可以解决网速慢时页面展示出{<!-- -->{xxx}}的问题。</p> 
<h4 id="v-once%E6%8C%87%E4%BB%A4%EF%BC%9A">v-once指令：</h4> 
<p>        1.v-once所在节点在初次动态渲染后，就视为静态内容了。</p> 
<p>        2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p> 
<h4 id="v-pre%E6%8C%87%E4%BB%A4%EF%BC%9A">v-pre指令：</h4> 
<p>        1.跳过其所在节点的编译过程。 </p> 
<p>        2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p> 
<hr> 
<h2 id="%E5%8D%81%E5%85%AD.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4">十六.自定义指令</h2> 
<p>自定义指令总结：</p> 
<p>        一、定义语法：</p> 
<p>                (1).局部指令：</p> 
<p>                new Vue({new Vue({directives:{指令名:配置对象}   或 directives{指令名:回调函数})})</p> 
<p>                (2).全局指令：</p> 
<p>                Vue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)</p> 
<p>        二、配置对象中常用的3个回调：</p> 
<p>                (1).bind：指令与元素成功绑定时调用。</p> 
<p>                (2).inserted：指令所在元素被插入页面时调用。</p> 
<p>                (3).update：指令所在模板结构被重新解析时调用。</p> 
<p>         三、备注：</p> 
<p>                1.指令定义时不加v-，但使用时要加v-；</p> 
<p>                2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。</p> 
<hr> 
<h2 id="%E5%8D%81%E4%B8%83.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">十七.生命周期</h2> 
<h4 id="%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%EF%BC%9A">常用的生命周期钩子：</h4> 
<p>        1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</p> 
<p>        2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p> 
<h4 id="%E5%85%B3%E4%BA%8E%E9%94%80%E6%AF%81Vue%E5%AE%9E%E4%BE%8B">关于销毁Vue实例</h4> 
<p>        1.销毁后借助Vue开发者工具看不到任何信息。</p> 
<p>        2.销毁后自定义事件会失效，但原生DOM事件依然有效。</p> 
<p>        3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p> 
<hr> 
<h2 id="%E5%8D%81%E5%85%AB.%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6">十八.非单文件组件</h2> 
<h4 id="Vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E5%A4%A7%E6%AD%A5%E9%AA%A4%EF%BC%9A">Vue中使用组件的三大步骤：</h4> 
<p>        一、定义组件(创建组件)</p> 
<p>        二、注册组件</p> 
<p>        三、使用组件(写组件标签)</p> 
<p>            一、如何定义一个组件？</p> 
<p>                使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；</p> 
<p>                区别如下：</p> 
<p>                        1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。</p> 
<p>                        2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。</p> 
<p>                        备注：使用template可以配置组件结构。</p> 
<p>            二、如何注册组件？</p> 
<p>                        1.局部注册：靠new Vue的时候传入components选项</p> 
<p>                        2.全局注册：靠Vue.component('组件名',组件)</p> 
<p>            三、编写组件标签：</p> 
<p>                        &lt;school&gt;&lt;/school&gt;</p> 
<h4 id="%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A">几个注意点：</h4> 
<p>                1.关于组件名:</p> 
<p>                        一个单词组成：</p> 
<p>                                第一种写法(首字母小写)：school</p> 
<p>                                第二种写法(首字母大写)：School</p> 
<p>                        多个单词组成：</p> 
<p>                                第一种写法(kebab-case命名)：my-school</p> 
<p>                                第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)</p> 
<p>                        备注：</p> 
<p>                                (1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。</p> 
<p>                                (2).可以使用name配置项指定组件在开发者工具中呈现的名字。</p> 
<p>                2.关于组件标签:</p> 
<p>                                第一种写法：&lt;school&gt;&lt;/school&gt;</p> 
<p>                                第二种写法：&lt;school/&gt;</p> 
<p>                                备注：不用使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染。</p> 
<p>                    3.一个简写方式：</p> 
<p>                                const school = Vue.extend(options) 可简写为：const school = options</p> 
<h4 id="%E5%85%B3%E4%BA%8EVueComponent%EF%BC%9A">关于VueComponent：</h4> 
<p>        1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。</p> 
<p>        2.我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;，Vue解析时会帮我们创建school组件的实例对象，</p> 
<p>        即Vue帮我们执行的：new VueComponent(options)。</p> 
<p>        3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！</p> 
<p>        4.关于this指向：</p> 
<p>                (1).组件配置中：</p> 
<p>                data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。</p> 
<p>                (2).new Vue(options)配置中：</p> 
<p>                data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</p> 
<p>        5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。</p> 
<p>        Vue的实例对象，以后简称vm。</p> 
<p></p> 
<p>1.一个重要的内置关系：VueComponent.prototype.__proto__ === Vue.prototype</p> 
<p>2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</p> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35c627759e8038646a73d388d9c126da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Chrome“喔唷，崩溃啦！”内存不足引起页面崩溃的原因和解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9877641f7ae4ea0d4efae06671a21357/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis缓存架构详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>