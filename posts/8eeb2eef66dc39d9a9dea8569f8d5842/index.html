<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【三】Vue之后端交互 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【三】Vue之后端交互" />
<meta property="og:description" content="【一】与后端交互 - ajax 【1】版本1 - 出现了跨域问题 (1)前端：index.html &lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;Vue与后端交互 - 出现了跨域问题&lt;/title&gt; &lt;script src=&#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js&#34;&gt;&lt;/script&gt; &lt;script src=&#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js&#34;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#34;box&#34;&gt; &lt;button @click=&#34;handleClick&#34;&gt;加载数据&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; let vm = new Vue({ el: &#39;#box&#39;, data: {}, methods: { handleClick() { $.ajax({ url: &#39;http://127.0.0.1:5000/&#39;, // 发送请求的url，本地的5000端口，是flask的默认端口 method: &#39;get&#39;, success: (data) =&gt; { console.log(data) } }) } } }) &lt;/script&gt; &lt;/html&gt; (2)后端：main.py from flask import Flask # 这里用轻量级的Flask框架来测试 app = Flask(__name__) @app." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8eeb2eef66dc39d9a9dea8569f8d5842/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-06T22:17:00+08:00" />
<meta property="article:modified_time" content="2023-08-06T22:17:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【三】Vue之后端交互</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown" style="font-size: 16px;"> 
 <h2 id="一与后端交互---ajax">【一】与后端交互 - ajax</h2> 
 <h3 id="1版本1---出现了跨域问题">【1】版本1 - 出现了跨域问题</h3> 
 <h4 id="1前端indexhtml">(1)前端：index.html</h4> 
 <pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Vue与后端交互 - 出现了跨域问题&lt;/title&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="box"&gt;
    &lt;button @click="handleClick"&gt;加载数据&lt;/button&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    let vm = new Vue({
        el: '#box',
        data: {},
        methods: {
            handleClick() {
                $.ajax({
                    url: 'http://127.0.0.1:5000/',    // 发送请求的url，本地的5000端口，是flask的默认端口
                    method: 'get',
                    success: (data) =&gt; {
                        console.log(data)
                    }
                })
            }
        }
    })
&lt;/script&gt;
&lt;/html&gt;</code></pre> 
 <h4 id="2后端mainpy">(2)后端：main.py</h4> 
 <pre class="has"><code class="language-python">from flask import Flask    # 这里用轻量级的Flask框架来测试

app = Flask(__name__)


@app.route('/')
def index():
    print('请求来了')
    return 'Hello World'


if __name__ == '__main__':
    app.run()</code></pre> 
 <p><img src="https://images2.imgbox.com/f8/fc/HUDAZCPG_o.gif" alt="" style="outline: none;"></p> 
 <blockquote> 
  <ul><li>这里可以看出：前端向后端成功发送了请求，后端也成功响应了，但是前端却报错了</li><li>这是因为：<code>跨域问题</code>的存在，浏览器检测到前端和后端不是来自同一个<code>域</code>，所以认为这是不安全的，所以就拦截了该资源的传递</li><li>想要解决这个问题，就要实现：<strong>CORS</strong>，也就是 <strong>跨域资源共享</strong></li></ul> 
 </blockquote> 
 <h3 id="2版本2---解决了跨域问题">【2】版本2 - 解决了跨域问题</h3> 
 <h4 id="1前端indexhtml-1">(1)前端：index.html</h4> 
 <pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Vue与后端交互 - 解决了跨域问题&lt;/title&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="box"&gt;
    &lt;button @click="handleClick"&gt;加载数据&lt;/button&gt;
    &lt;p&gt;加载的数据：{<!-- -->{myText}}&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    let vm = new Vue({
        el: '#box',
        data: {
            myText: ''
        },
        methods: {
            handleClick() {
                $.ajax({
                    url: 'http://127.0.0.1:5000/',
                    method: 'get',
                    success: (data) =&gt; {
                        console.log(data)
                        this.myText = data
                    }
                })
            }
        }
    })
&lt;/script&gt;
&lt;/html&gt;</code></pre> 
 <h4 id="2后端mainpy-1">(2)后端：main.py</h4> 
 <pre class="has"><code class="language-python">from flask import Flask, make_response

app = Flask(__name__)


@app.route('/')
def index():
    print('请求来了')
    res = make_response('Hello World')
    res.headers['Access-Control-Allow-Origin'] = '*'    # 访问控制允许的源 设置为全部
    return res


if __name__ == '__main__':
    app.run()</code></pre> 
 <p><img src="https://images2.imgbox.com/16/ab/FjxTz3Wl_o.gif" alt="" style="outline: none;"></p> 
 <h3 id="3版本3---后端读取json文件传到前端">【3】版本3 - 后端读取json文件传到前端</h3> 
 <h4 id="1json文件filejson">(1)json文件：file.json</h4> 
 <pre class="has"><code class="language-json">{
  "name": "Darker",
  "age": "18",
  "gender": "male"
}</code></pre> 
 <h4 id="2前端indexhtml">(2)前端：index.html</h4> 
 <pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Vue与后端交互 - json&lt;/title&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="box"&gt;
    &lt;button @click="handleClick"&gt;加载数据&lt;/button&gt;
    &lt;p&gt;加载的数据：{<!-- -->{myText}}&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    let vm = new Vue({
        el: '#box',
        data: {
            myText: ''
        },
        methods: {
            handleClick() {
                $.ajax({
                    url: 'http://127.0.0.1:5000/',
                    method: 'get',
                    success: (data) =&gt; {
                        console.log(data)
                        this.myText = data
                    }
                })
            }
        }
    })
&lt;/script&gt;
&lt;/html&gt;</code></pre> 
 <h4 id="3后端mainpy">(3)后端：main.py</h4> 
 <pre class="has"><code class="language-python">import json

from flask import Flask, jsonify

app = Flask(__name__)


@app.route('/')
def index():
    print('请求来了')
    with open('file.json', mode='rt', encoding='utf-8') as f:
        dic = json.load(f)
    res = jsonify(dic)
    res.headers['Access-Control-Allow-Origin'] = '*'
    return res


if __name__ == '__main__':
    app.run()</code></pre> 
 <p><img src="https://images2.imgbox.com/51/14/rXDkVEZP_o.gif" alt="" style="outline: none;"></p> 
 <h2 id="二fetch">【二】fetch</h2> 
 <h3 id="1简介">【1】简介</h3> 
 <h4 id="1fetch介绍">(1)fetch介绍</h4> 
 <blockquote> 
  <ul><li>提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应</li><li>它还提供了一个全局 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch" rel="noopener noopener noreferrer" target="_blank"><code>fetch()</code></a> 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源</li></ul> 
 </blockquote> 
 <ul><li>fetch 是一种在 JavaScript 中用于访问和操纵 HTTP 管道的接口。 
   <ul><li>它提供了一个全局的 <code>fetch()</code> 方法，该方法可以用来跨网络异步获取资源。</li></ul> </li></ul> 
 <h4 id="2fetch-方法的基本格式如下">(2)fetch 方法的基本格式如下：</h4> 
 <pre class="has"><code class="language-js">fetch(url [, options])
  .then(function(response) {
    // 对响应进行处理
    return response.json();
  })
  .then(function(data) {
    // 处理从响应中获取的数据
    console.log(data);
  });</code></pre> 
 <blockquote> 
  <ul><li><strong>url</strong>：表示要获取资源的路径或 URL。可以是绝对路径或相对路径。</li><li><strong>options</strong>(可选)：表示请求的配置项，例如请求方法(GET、POST等)、请求头等。</li></ul> 
 </blockquote> 
 <h4 id="3fetch-方法返回一个-promise-对象">(3)fetch 方法返回一个 Promise 对象</h4> 
 <ul><li> <p>fetch 方法返回一个 Promise 对象，通过使用 <code>.then()</code> 方法来处理响应。</p> 
   <ul><li>第一个 <code>.then()</code> 函数接收一个 <code>response</code> 参数，该参数代表从服务器端返回的响应。</li><li>可以在该函数中对响应进行处理，比如解析 JSON 数据、读取响应头信息等。</li><li>通常，我们使用 <code>response.json()</code> 方法来将响应转换为 JSON 格式的数据，并将其传递给下一个 <code>.then()</code> 函数。</li><li>在第二个 <code>.then()</code> 函数中，我们可以处理从响应中获取的数据。</li></ul> </li><li> <p>值得注意的是，由于 fetch 是异步的，因此可以链式调用多个 <code>.then()</code> 方法来处理多个操作。</p> </li><li> <p>除了 <code>.then()</code> 方法之外，还可以使用 <code>.catch()</code> 方法来捕获发生的错误，以及 <code>.finally()</code> 方法来执行无论成功或失败都要执行的操作。</p> </li></ul> 
 <h4 id="4常见的可配置项">(4)常见的可配置项</h4> 
 <ul><li> <p>fetch 在发送请求时还可以通过配置 options 参数来设置请求的详细信息，例如请求方法、请求头等。常见的可配置项包括：</p> 
   <ul><li> <p><strong>method</strong>：请求的方法，如 GET、POST 等，默认为 GET。</p> </li><li> <p><strong>headers</strong>：请求头信息，可以设置为一个 Headers 对象或普通对象。</p> </li><li> <p><strong>body</strong>：请求体，即要发送给服务器的数据，可以是 FormData、URLSearchParams、Blob、BufferSource、或者其他支持的类型。</p> </li><li> <p><strong>mode</strong>：确定是否允许跨域请求，可以设置为 same-origin(仅在同源下请求)、cors(跨域请求)或 no-cors(不允许跨域请求)。</p> </li><li> <p><strong>credentials</strong>：确定是否发送凭证(如 Cookie 或 HTTP 身份验证)，可以设置为 include(发送凭证)、same-origin(仅发送同源凭证)或 omit(不发送凭证)。</p> </li><li> <p><strong>cache</strong>：指定缓存模式，可以设置为 default(使用浏览器缓存)、no-store(禁止使用缓存)等。</p> </li><li> <p><strong>redirect</strong>：指定重定向模式，可以设置为 follow(自动处理重定向)、error(遇到重定向时抛出错误)等。</p> </li></ul> </li></ul> 
 <h4 id="5小结">(5)小结</h4> 
 <ul><li>fetch 是现代 JavaScript 中一种常用的发起网络请求的方式，它提供了简单、灵活的API，可以满足对获取和处理资源的需求，并且可以通过配置参数来满足各种不同的请求场景。</li></ul> 
 <h3 id="2实例">【2】实例</h3> 
 <h4 id="1json文件filejson-1">(1)json文件：file.json</h4> 
 <pre class="has"><code class="language-json">{
  "name": "Darker",
  "age": "18",
  "gender": "male"
}</code></pre> 
 <h4 id="2后端mainpy-2">(2)后端：main.py</h4> 
 <pre class="has"><code class="language-python">import json

from flask import Flask, jsonify

app = Flask(__name__)


@app.route('/')
def index():
    print('请求来了')
    with open('file.json', mode='rt', encoding='utf-8') as f:
        dic = json.load(f)
    res = jsonify(dic)
    res.headers['Access-Control-Allow-Origin'] = '*'
    return res


if __name__ == '__main__':
    app.run()</code></pre> 
 <h4 id="3前端indexhtml">(3)前端：index.html</h4> 
 <pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Vue与后端交互 - fetch&lt;/title&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="box"&gt;
    &lt;button @click="handleClick"&gt;加载数据&lt;/button&gt;
    &lt;p&gt;加载的数据：&lt;/p&gt;
    &lt;ul&gt;
        &lt;li &gt;姓名：{<!-- -->{name}}&lt;/li&gt;
        &lt;li &gt;年龄：{<!-- -->{age}}&lt;/li&gt;
        &lt;li &gt;性别：{<!-- -->{gender}}&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    let vm = new Vue({
        el: '#box',
        data: {
            name:'',
            age: '',
            gender: ''
        },
        methods: {
            handleClick() {
                fetch('http://127.0.0.1:5000/').then(response =&gt; {
                    return response.json()
                }).then(json =&gt; {
                    console.log('从后端获取的json数据', json)   // success 获取的数据
                    this.name = json.name
                    this.age = json.age
                    this.gender = json.gender
                }).catch(ex =&gt; {
                    console.log('出现了异常', ex)    // 抛出异常
                })
            }
        }
    })
&lt;/script&gt;
&lt;/html&gt;</code></pre> 
 <p><img src="https://images2.imgbox.com/07/2e/tT1nriRi_o.gif" alt="" style="outline: none;"></p> 
 <h2 id="二axios">【二】Axios</h2> 
 <h3 id="1简介-1">【1】简介</h3> 
 <blockquote> 
  <ul><li>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中</li><li>axios官网：<a href="http://www.axios-js.com/" rel="noopener noopener noreferrer" target="_blank">http://www.axios-js.com/</a></li></ul> 
 </blockquote> 
 <ul><li> <p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 Node.js 环境中进行数据请求和传输。</p> 
   <ul><li>它提供了一种简洁、直观的 API</li></ul> </li><li> <p>并且具备以下特性：</p> 
   <ul><li> <p>支持浏览器和 Node.js：</p> 
     <ul><li>Axios 可以在浏览器和 Node.js 环境中同时使用，使得前后端代码可以共用。</li></ul> </li><li> <p>Promise 库：</p> 
     <ul><li>Axios 使用 ES6 的 Promise 来处理异步操作，方便进行链式调用、错误处理等。</li></ul> </li><li> <p>支持拦截器：</p> 
     <ul><li> <p>通过拦截器，可以在发送请求之前和接收响应之前对请求进行全局的配置或者转换。</p> </li><li> <p>这样可以对请求或响应做统一的处理，例如添加请求头、请求参数校验、响应数据处理等。</p> </li></ul> </li><li> <p>提供并发请求的接口：</p> 
     <ul><li>Axios 提供了可以同时发送多个请求的接口，可以方便地管理多个请求，等待所有请求都完成后再进行处理。</li></ul> </li><li> <p>可以取消请求：</p> 
     <ul><li>Axios 允许通过取消请求的方式来停止正在进行的请求，减少不必要的流量和资源消耗。</li></ul> </li><li> <p>支持cookie的自动保存和发送：</p> 
     <ul><li>在浏览器环境下，Axios 可以自动保存从服务器接收的 cookie，并在后续的请求中自动发送，方便进行会话状态的维护。</li></ul> </li><li> <p>支持跨域请求：</p> 
     <ul><li>Axios 提供了简便的方法来处理跨域请求，可以通过配置跨域策略、发送跨域请求。</li></ul> </li><li> <p>提供丰富的错误处理机制：</p> 
     <ul><li>Axios 捕获请求过程中的错误，并提供了一些常见的错误处理方法，方便进行错误处理和异常信息的展示。</li></ul> </li></ul> </li><li> <p>Axios 的官方网站是 <a href="http://www.axios-js.com/" rel="noopener noopener noreferrer" target="_blank">http://www.axios-js.com/</a></p> 
   <ul><li>在该网站上可以找到 Axios 的详细文档、示例以及相关资源。</li><li>通过 Axios，开发人员可以快速简单地进行网络请求，并且具备灵活的配置和丰富的功能，使得与后端接口的交互更加高效和方便。</li></ul> </li></ul> 
 <h3 id="2实例-1">【2】实例</h3> 
 <h4 id="1json文件filmjson这里只是一部分原代码太多了">(1)json文件：film.json(这里只是一部分，原代码太多了...)</h4> 
 <pre class="has"><code class="language-json">https://m.maizuo.com/v5/?co=mzmovie#/films/nowPlaying</code></pre> 
 <h4 id="2后端mainpy-3">(2)后端：main.py</h4> 
 <pre class="has"><code class="language-python">import json

from flask import Flask, jsonify

app = Flask(__name__)


@app.route('/film')
def index():
    print('请求来了')
    with open('film.json', mode='rt', encoding='utf-8') as f:
        dic = json.load(f)
    res = jsonify(dic)
    res.headers['Access-Control-Allow-Origin'] = '*'
    return res


if __name__ == '__main__':
    app.run()</code></pre> 
 <h4 id="3前端indexhtml-1">(3)前端：index.html</h4> 
 <pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Vue与后端交互&lt;/title&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/axios/0.21.0/axios.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id="box"&gt;
    &lt;button @click="handleClick"&gt;加载电影数据&lt;/button&gt;
    &lt;p&gt;加载的数据：&lt;/p&gt;
    &lt;ul&gt;
        &lt;li v-for="item in dataList"&gt;
            &lt;p&gt;电影：{<!-- -->{item.name}}&lt;/p&gt;
            &lt;p&gt;导演：{<!-- -->{item.director}}&lt;/p&gt;
            &lt;img :src="item.poster" alt=""&gt;
        &lt;/li&gt;

    &lt;/ul&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;script&gt;
    let vm = new Vue({
        el: '#box',
        data: {
            dataList: []
        },
        methods: {
            handleClick() {
                axios.get("http://127.0.0.1:5000/film/").then(res =&gt; {
                    console.log(res.data.data.films) // axios 自动包装data属性 res.data
                    this.dataList = res.data.data.films
                }).catch(err =&gt; {
                    console.log(err);
                })
            }
        }
    })
&lt;/script&gt;
&lt;/html&gt;</code></pre> 
 <p><img src="https://images2.imgbox.com/1f/65/XIupsoLL_o.gif" alt="" style="outline: none;"></p> 
 <h2 id="三计算属性">【三】计算属性</h2> 
 <blockquote> 
  <p>计算属性是基于它们的依赖进行缓存的</p> 
  <p>计算属性只有在它的相关依赖发生改变时才会重新求值</p> 
  <p>计算属性就像<code>Python</code>中的<code>property</code>，可以把<code>方法/函数</code>伪装成<code>属性</code></p> 
 </blockquote> 
 <ul><li>计算属性(Computed Properties)是一种在编程中常见的概念，它允许我们根据依赖的数据进行动态计算，并将计算结果作为属性进行缓存。 
   <ul><li>计算属性只有在其相关依赖发生改变时才会重新求值，这也是它们与普通方法或函数的主要区别。</li></ul> </li><li>计算属性类似于Python中的property，通过将一个方法或函数伪装成属性来使用。 
   <ul><li>与普通的属性不同，计算属性的值是根据其他数据动态计算得出的，而不是直接存储的。</li></ul> </li><li>使用计算属性可以简化代码，并提高性能。 
   <ul><li>当我们需要基于现有数据进行复杂的计算或处理时，可以使用计算属性来动态获取计算结果，而不必每次都手动调用方法或函数进行计算。</li></ul> </li><li>在很多框架和库中，如Vue.js等，都提供了对计算属性的支持。 
   <ul><li>在Vue.js中，我们可以定义计算属性并在模板中进行引用，当计算属性的相关依赖发生改变时，模板会自动更新显示计算属性的最新值。</li></ul> </li><li>总结来说，计算属性是一种根据依赖动态计算结果并缓存的属性，可以简化代码、提高性能，并且给使用者提供了更加便捷的操作方式。</li></ul> 
 <h3 id="1通过计算属性实现名字首字母大写">【1】通过计算属性实现名字首字母大写</h3> 
 <h4 id="1案例一">(1)案例一</h4> 
 <ul><li>在Vue中，我们可以通过计算属性(Computed Property)来实现将名字的首字母大写。下面是一个示例代码：</li></ul> 
 <pre class="has"><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;原始名字：{<!-- -->{ firstName }}&lt;/p&gt;
    &lt;p&gt;首字母大写名字：{<!-- -->{ capitalizedFirstName }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      firstName: 'john',
      lastName: 'doe'
    };
  },
  computed: {
    fullName() {
      return this.firstName + ' ' + this.lastName;
    },
    capitalizedFirstName() {
      return this.firstName.charAt(0).toUpperCase() + this.firstName.slice(1);
    }
  }
};
&lt;/script&gt;</code></pre> 
 <ul><li> <p>在上面的代码中，我们定义了一个Vue组件，并在<code>computed</code>中定义了两个计算属性，分别是<code>fullName</code>和<code>capitalizedFirstName</code>。</p> 
   <ul><li> <p><code>fullNamefirstName</code>和<code>lastName</code>拼接而得到的。</p> </li><li> <p><code>capitalizedFirstName</code>计算属性是通过使用字符串的<code>charAt(0)</code>方法获取<code>firstName</code>的首字母，并调用<code>toUpperCase()</code>方法将首字母转换为大写，然后再使用<code>slice(1)</code>方法获取剩余部分组合而成。</p> </li></ul> </li><li> <p>在模板中，我们使用了插值表达式<code>{<!-- -->{ ... }}</code>来显示计算属性的值。</p> </li><li> <p>运行以上示例代码，你会看到通过计算属性实现名字首字母大写的效果。</p> </li><li> <p>这种方式可以让我们在模板中直接使用计算属性的值，使代码更清晰易读。</p> </li></ul> 
 <h4 id="2案例二">(2)案例二</h4> 
 <pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;首字母大写&lt;/title&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="box"&gt;
    &lt;!--大段的代码写在这里不好，使用计算属性--&gt;
    模板插值：
    {<!-- -->{myText.substring(0,1).toUpperCase()+myText.substring(1)}}
    &lt;p&gt;普通方法：{<!-- -->{getNameMethod()}}&lt;/p&gt;
    &lt;!--区别是在同一个页面中使用多次计算属性，不会多次执行--&gt;
    &lt;p&gt;计算属性：{<!-- -->{getName}}&lt;/p&gt;
    &lt;!--普通方法要加括号--&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    var vm = new Vue({
        el: '#box',
        data: {
            myText: 'darker',
        },
        computed: {
            getName() { // 依赖的状态改变了，会重新计算
                return this.myText.substring(0, 1).toUpperCase() + this.myText.substring(1)
            }
        },
        methods: {
            getNameMethod() {
                return this.myText.substring(0, 1).toUpperCase() + this.myText.substring(1)
            }
        }
    })
&lt;/script&gt;
&lt;/html&gt;</code></pre> 
 <p><img src="https://images2.imgbox.com/2d/58/Hf6tL6vM_o.png" alt="" style="outline: none;"></p> 
 <h3 id="2通过计算属性重写过滤案例">【2】通过计算属性重写过滤案例</h3> 
 <h4 id="1案例一-1">(1)案例一</h4> 
 <ul><li>当我们需要对数据进行筛选或过滤时，Vue的计算属性(Computed Property)是一种非常方便且优雅的方式。</li><li>下面是一个示例，展示了如何使用计算属性来重写一个过滤案例。</li><li>假设我们有一个包含学生信息的数组，我们想要筛选出年龄大于等于18岁的学生。</li><li>我们可以使用计算属性来实现这个功能。</li></ul> 
 <pre class="has"><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;学生列表：&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li v-for="student in filteredStudents" :key="student.id"&gt;
        {<!-- -->{ student.name }} - {<!-- -->{ student.age }}岁
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      students: [
        { id: 1, name: '张三', age: 17 },
        { id: 2, name: '李四', age: 19 },
        { id: 3, name: '王五', age: 20 },
        { id: 4, name: '赵六', age: 16 },
        { id: 5, name: '刘七', age: 18 }
      ]
    };
  },
  computed: {
    filteredStudents() {
      return this.students.filter(student =&gt; student.age &gt;= 18);
    }
  }
};
&lt;/script&gt;</code></pre> 
 <ul><li>在上面的示例代码中，我们定义了一个含有学生信息的数组<code>students</code>。 
   <ul><li>通过计算属性<code>filteredStudents</code>，我们对<code>students</code>数组进行筛选，只返回年龄大于等于18岁的学生。</li><li>然后，在模板中使用<code>v-for</code>指令遍历<code>filteredStudents</code>数组，并显示学生的姓名和年龄。</li></ul> </li><li>这样，我们就实现了一个简单的学生过滤案例。 
   <ul><li>当<code>students</code>数组中的数据发生变化时，计算属性会自动更新过滤结果，保持视图的同步。</li></ul> </li><li>通过使用计算属性来重写过滤案例，我们可以更加清晰地表达出我们的意图，并且能够轻松应对数据的变化。</li></ul> 
 <h4 id="2案例二-1">(2)案例二</h4> 
 <pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;通过计算属性重写过滤案例&lt;/title&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="box"&gt;
    &lt;p&gt;&lt;input type="text" v-model="myText" placeholder="请输入要筛选的内容："&gt;&lt;/p&gt;
    &lt;ul&gt;
        &lt;li v-for="data in newList"&gt;{<!-- -->{data}}&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    var vm = new Vue({
        el: '#box',
        data: {
            myText: '',
            dataList: ['a', 'at', 'atom', 'be', 'beyond', 'cs', 'csrf'],
        },
        computed: {
            newList() {
                return this.dataList.filter(item =&gt; {
                    return item.indexOf(this.myText) &gt; -1   // 返回索引大于1的元素：&gt;-1 就表示包含在其中
                })
            }
        }
    })
&lt;/script&gt;
&lt;/html&gt;</code></pre> 
 <p><img src="https://images2.imgbox.com/29/c0/ALZqUI3W_o.gif" alt="" style="outline: none;"></p> 
 <h2 id="四虚拟dom-与diff算法-key的作用">【四】虚拟DOM 与diff算法 key的作用</h2> 
 <h3 id="1vue20-v-for-中-key-有什么用呢">【1】Vue2.0 v-for 中 :key 有什么用呢？</h3> 
 <blockquote> 
  <ul><li> <p>其实呢不只是vue，react中在执行列表渲染时也会要求给每个组件添加key这个属性</p> </li><li> <p>key简单点来说就是唯一标识，就像ID一样唯一性</p> </li><li> <p>要知道，vue和react都实现了一套<strong>虚拟DOM</strong>，使我们可以<code>不直接操作DOM元素</code>，<code>只操作数据</code>便可以<code>重新渲染页面</code></p> </li><li> <p>而隐藏在背后的原理便是其高效的<strong>Diff算法</strong></p> 
    <ul><li> <p><strong>分层级比较</strong>：只做同层级的对比</p> </li><li> <p><strong>通过key值比较</strong>：出现新的key就插入同组(循环中，尽量加<code>key</code>，让key值唯一)</p> </li><li> <p><strong>通过组件/标签进行比较</strong>：然后进行替换</p> </li></ul> </li></ul> 
 </blockquote> 
 <ul><li> <p>当在 Vue 2.0 中使用 <code>v-for</code> 进行列表渲染时，为每个被渲染的元素添加 <code>:key</code> 属性是很重要的。</p> </li><li> <p>这是因为 <code>key</code> 属性在虚拟 DOM 中具有以下作用：</p> 
   <ul><li> <p><strong>唯一标识</strong>：</p> 
     <ul><li> <p><code>key</code> 属性用于给每个被渲染的元素分配一个唯一的标识符。</p> </li><li> <p>这样 Vue 可以根据 <code>key</code> 来区分每个元素，并在重新渲染时确定哪些元素是新增的、哪些元素是删除的或移动的。</p> </li></ul> </li><li> <p><strong>性能优化</strong>：</p> 
     <ul><li> <p>通过提供唯一的 <code>key</code> 值，Vue 可以进行更高效的列表更新。</p> </li><li> <p>当数据发生改变时，Vue 使用 <code>key</code> 来对比前后两个渲染状态，只对需要更新的部分进行重新渲染，而不是整个列表。这样可以节省大量的计算资源和时间，提高应用的性能。</p> </li></ul> </li><li> <p><strong>确保组件状态的正确性</strong>：</p> 
     <ul><li> <p>在列表中使用组件时，<code>key</code> 属性对于确保组件状态的正确性非常重要。</p> </li><li> <p>当列表发生改变时，Vue 会根据 <code>key</code> 来判断是复用已有组件还是创建新的组件。</p> </li><li> <p>如果没有提供 <code>key</code> 或者 <code>key</code> 值不唯一，可能会导致组件的状态出现混乱或错误的复用现象。</p> </li></ul> </li><li> <p><strong>过渡与动画</strong>：</p> 
     <ul><li>当在列表中使用过渡或动画效果时，<code>key</code> 属性也起到关键作用。</li><li>Vue 使用 <code>key</code> 来识别新增、删除和移动的元素，并为它们添加合适的过渡效果或动画。</li><li>这样可以提供更好的用户体验和视觉效果。</li></ul> </li></ul> </li><li> <p>总之</p> 
   <ul><li>通过在 <code>v-for</code> 中为每个元素添加唯一的 <code>key</code> 属性，可以提高渲染性能、保证组件状态的正确性，以及支持过渡与动画效果。</li><li>因此，在使用 <code>v-for</code> 进行列表渲染时，请务必为每个元素提供一个具有唯一性的 <code>key</code> 值。</li><li>通常情况下，可以使用列表项的唯一标识符，如数据库中的 ID，作为 <code>key</code> 的值。</li></ul> </li></ul> 
 <h3 id="2虚拟dom的diff算法">【2】虚拟DOM的diff算法</h3> 
 <ul><li>虚拟 DOM 的 Diff 算法是 Vue 和 React 中用于高效更新 DOM 树的核心算法之一。</li></ul> 
 <h4 id="1分层级比较">(1)<strong>分层级比较</strong>：</h4> 
 <ul><li> <p>Diff 算法首先会进行分层级的比较。它会通过调用每个节点的 <code>render</code> 方法来构建两个虚拟 DOM 树，分别是当前状态下的旧树和改变后的新树。</p> </li><li> <p>然后，Diff 算法只会在同层级进行比较，不会跨层级比较。</p> </li></ul> 
 <h4 id="2通过-key-值比较">(2)<strong>通过 key 值比较</strong>：</h4> 
 <ul><li> <p>在同一层级内，Diff 算法会通过比较每个节点的 <code>key</code> 值来确定哪些节点是新增的、哪些节点是删除的或者移动的。</p> </li><li> <p>如果遇到新的节点没有 <code>key</code> 值或者 <code>key</code> 值不唯一的情况，Diff 算法会按照一定的规则处理。</p> </li></ul> 
 <h4 id="3通过组件标签进行比较">(3)<strong>通过组件/标签进行比较</strong>：</h4> 
 <ul><li> <p>当比较两个节点时，Diff 算法会根据节点类型(组件或者标签)来进行不同的处理。</p> </li><li> <p>对于标签节点，Diff 算法会比较节点的标签名、属性和子节点，并更新或替换需要改变的部分。</p> </li><li> <p>对于组件节点，Diff 算法会比较组件类型、<code>props</code> 和子节点，并更新或替换需要改变的组件。</p> </li></ul> 
 <h4 id="4递归比较子节点">(4)<strong>递归比较子节点</strong>：</h4> 
 <ul><li> <p>如果两个节点的类型相同，Diff 算法会继续递归比较子节点。</p> </li><li> <p>这样可以确保整个虚拟 DOM 树的所有子节点都被遍历和比较。</p> </li></ul> 
 <h4 id="5列表优化">(5)<strong>列表优化</strong>：</h4> 
 <ul><li>在处理列表渲染时，Diff 算法会通过添加唯一的 <code>key</code> 值来进行优化。</li><li>当列表发生变化时，Diff 算法会尽量复用已有的节点，而不是重新创建节点。这样可以减少 DOM 操作和提高性能。</li></ul> 
 <h4 id="6总体来说">(6)总体来说:</h4> 
 <ul><li>虚拟 DOM 的 Diff 算法通过分层级比较、通过 key 值比较、通过组件/标签比较以及递归比较子节点等策略，只对需要改变的部分进行更新，大大减少了 DOM 操作的开销，提高了应用的性能。</li><li>通过这种方式，Vue 和 React 能够实现快速、高效的页面渲染和更新。</li></ul> 
 <p><img src="https://images2.imgbox.com/db/0c/rmIyR9no_o.png" alt="" style="outline: none;"></p> 
 <ul><li><strong>虚拟DOM数据渲染图示</strong></li></ul> 
 <p><img src="https://images2.imgbox.com/bd/d5/YFoNSAbf_o.png" alt="" style="outline: none;"></p> 
 <h3 id="3具体实现">【3】具体实现</h3> 
 <h4 id="1把树按照层级分解">(1)把树按照层级分解</h4> 
 <ul><li> <p>Diff 算法首先会进行分层级的比较。它会通过调用每个节点的 <code>render</code> 方法来构建两个虚拟 DOM 树，分别是当前状态下的旧树和改变后的新树。</p> </li><li> <p>然后，Diff 算法只会在同层级进行比较，不会跨层级比较。</p> </li></ul> 
 <p><img src="https://images2.imgbox.com/be/b7/KzPUXPLW_o.png" alt="" style="outline: none;"></p> 
 <h4 id="2按照key值比较">(2)按照key值比较</h4> 
 <ul><li> <p>在同一层级内，Diff 算法会通过比较每个节点的 <code>key</code> 值来确定哪些节点是新增的、哪些节点是删除的或者移动的。</p> </li><li> <p>如果遇到新的节点没有 <code>key</code> 值或者 <code>key</code> 值不唯一的情况，Diff 算法会按照一定的规则处理。</p> </li></ul> 
 <p><img src="https://images2.imgbox.com/3e/56/RNPsA35B_o.png" alt="" style="outline: none;"></p> 
 <h4 id="3通过组件进行比较">(3)通过组件进行比较</h4> 
 <ul><li> <p>当比较两个节点时，Diff 算法会根据节点类型(组件或者标签)来进行不同的处理。</p> </li><li> <p>对于标签节点，Diff 算法会比较节点的标签名、属性和子节点，并更新或替换需要改变的部分。</p> </li><li> <p>对于组件节点，Diff 算法会比较组件类型、<code>props</code> 和子节点，并更新或替换需要改变的组件。</p> </li></ul> 
 <p><img src="https://images2.imgbox.com/c1/04/Mrhynlpq_o.png" alt="" style="outline: none;"></p> 
 <pre class="has"><code class="language-html">&lt;div id="box"&gt;
    &lt;div v-if="isShow"&gt;111&lt;/div&gt;
    &lt;p v-else&gt;222&lt;/p&gt;
    &lt;!--    
    {tag:div,value:111}
    {tag:p,value:222}
    直接不比较，直接删除div，新增p
    --&gt;

    &lt;div v-if="isShow"&gt;111&lt;/div&gt;
    &lt;div v-else&gt;222&lt;/div&gt;
    &lt;!--    
    {tag:div,value:111}
    {tag:div,value:222}
    比较都是div，只替换文本内容
    --&gt;
&lt;/div&gt;</code></pre> 
 <h4 id="思考什么是跨域问题如何解决">思考：什么是跨域问题？如何解决？</h4> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6154aabe951ac1970a1296a898dc38e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql数据库的运算符优先级，常用的函数以及对mysql事务和索引</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec43236748a99626bd6a6d4ae12da7ef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Spring Boot】拦截器与统一功能处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>