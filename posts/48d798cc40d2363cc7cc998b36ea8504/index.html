<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FreeRTOS学习笔记（3、信号量、互斥量的使用） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FreeRTOS学习笔记（3、信号量、互斥量的使用）" />
<meta property="og:description" content="FreeRTOS学习笔记（3、信号量、互斥量的使用） 前言往期学习笔记链接学习工程信号量 semaphore两种信号量的对比信号量的使用1、创建信号量2、give3、take4、删除信号量使用计数型信号量实现同步功能使用二进制型信号量实现互斥功能 互斥量 mutex问题：优先级反转解决方法：优先级继承问题：递归上锁造成死锁解决方法：递归锁互斥量的基本使用1、创建互斥量2、获得互斥量 Take3、释放互斥量 Give 使用优先级继承来实现优先级反转二进制信号量优先级反转的过程分析互斥量使用优先级继承来解决优先级反转 互斥量和二进制信号量的区别和共同点互斥量的递归锁递归锁实现1、创建递归锁2、Give/Take 前言 这是第三弹，由于CSDN长度的限制，所以把FreeRTOS学习分为几部分来发，这是第三部分
主要包括信号量、互斥量使用等
往期学习笔记链接 第一弹：FreeRTOS学习笔记（1、FreeRTOS初识、任务的创建以及任务状态理论、调度算法等）
第二弹: FreeRTOS学习笔记（2、同步与互斥通信、队列、队列集的使用）
第三弹: FreeRTOS学习笔记（3、信号量、互斥量的使用）
第四弹: FreeRTOS学习笔记（4、事件组、任务通知）
第五弹: FreeRTOS学习笔记（5、定时器、中断管理、调试与优化）
学习工程 所有学习工程
oufen / FreeRTOS学习
都在我的Gitee工程当中，大家可以参考学习
信号量 semaphore 队列可以传送数据，队列可以传送不同的数据
有的时候只需要传递状态，并不需要传递具体的信息
这就是信号量，不去传送数据，而是传送状态,这样至起到了通知的作用，更加节省内存
信号量，不能传输数据，只有一个计数值，来表示资源的数量
信号起通知作用
量,表示资源的数量
左边是生产者，生产好一个商品后让计数值&#43;1
右边是消费者，取出一个商品后计数值-1
如何创建信号量
创建信号量生产者生产好后让计数值&#43;1 give消费者取出后让计数值-1 take 计数：事件产生give信号量，计数值加1，处理事件，take信号量，计数值减1
资源管理:想要访问资源时，首先需要take信号量，计数值减1，用完资源后，give信号量，计数值加1
两种信号量的对比 计数型信号量二进制信号量 计数型信号量，的取值范围为0-任意数
二进制信号量，的取值返回为0或者1 但是二进制信号量的初始值为0
除了取值不一样外，其他的操作都是完全一样的
信号量也相当于是一个队列
队列有一个结构体Queue,结构体中有一个指针，指向存放数据的一个buff
但是对于信号量，并不需要这个buffer,只需要这个结构体
对于信号量，核心是信号量的计数值
这个计数值保存在初始化信号量时传入的初始的计数值
创建完信号量后，就可以加减信号量的Value了
让信号量的计数值&#43;1,并且取出东西
一开始Value为0，调用take函数，使信号量减1，没有数据，那么信号量就没办法-1，进入阻塞状态，还可以指定阻塞多长时间
在阻塞状态中，如果有另一个task往里面放数据，那么就会从阻塞状态中唤醒，进入Ready状态
对于give,信号量加1 解锁 对于计数型信号量，可以让这个值累加，但是不能超过创建时指定的最大值
对于二进制信号量，取值就只有0和1，如果值为1，再次调用give也不会成功
可以判断give函数的返回值，看累加是否成功
不管哪种信号量，只要没有超过创建时指定的最大值，都可以累加成功
对于take，信号量-1 上锁 如果信号量的值为0，就没办法take成功，不成功的话可以指定阻塞时间
0 take不成功，返回errportMax_Delay 一直阻塞，直到成功 有多个task执行take，当其他task执行give时，唤醒哪个任务？ 优先级最高的task 优先执行take**优先级相同时，等待最久的task ** 优先执行take pdTRUE，表示Take成功" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/48d798cc40d2363cc7cc998b36ea8504/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-28T15:31:06+08:00" />
<meta property="article:modified_time" content="2023-08-28T15:31:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FreeRTOS学习笔记（3、信号量、互斥量的使用）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>FreeRTOS学习笔记（3、信号量、互斥量的使用）</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#_7" rel="nofollow">往期学习笔记链接</a></li><li><a href="#_15" rel="nofollow">学习工程</a></li><li><a href="#_semaphore_19" rel="nofollow">信号量 semaphore</a></li><li><ul><li><a href="#_51" rel="nofollow">两种信号量的对比</a></li><li><a href="#_115" rel="nofollow">信号量的使用</a></li><li><ul><li><a href="#1_129" rel="nofollow">1、创建信号量</a></li><li><a href="#2give_134" rel="nofollow">2、give</a></li><li><a href="#3take_139" rel="nofollow">3、take</a></li><li><a href="#4_144" rel="nofollow">4、删除信号量</a></li><li><a href="#_149" rel="nofollow">使用计数型信号量实现同步功能</a></li><li><a href="#_155" rel="nofollow">使用二进制型信号量实现互斥功能</a></li></ul> 
   </li></ul> 
   </li><li><a href="#__mutex_172" rel="nofollow">互斥量 mutex</a></li><li><ul><li><a href="#_217" rel="nofollow">问题：优先级反转</a></li><li><a href="#_233" rel="nofollow">解决方法：优先级继承</a></li><li><a href="#_250" rel="nofollow">问题：递归上锁造成死锁</a></li><li><a href="#_264" rel="nofollow">解决方法：递归锁</a></li><li><a href="#_283" rel="nofollow">互斥量的基本使用</a></li><li><ul><li><a href="#1_285" rel="nofollow">1、创建互斥量</a></li><li><a href="#2__Take_301" rel="nofollow">2、获得互斥量 Take</a></li><li><a href="#3%09Give_305" rel="nofollow">3、释放互斥量 Give</a></li></ul> 
    </li><li><a href="#_312" rel="nofollow">使用优先级继承来实现优先级反转</a></li><li><ul><li><a href="#_314" rel="nofollow">二进制信号量优先级反转的过程分析</a></li><li><a href="#_333" rel="nofollow">互斥量使用优先级继承来解决优先级反转</a></li></ul> 
    </li><li><a href="#_339" rel="nofollow">互斥量和二进制信号量的区别和共同点</a></li><li><a href="#_349" rel="nofollow">互斥量的递归锁</a></li><li><ul><li><a href="#_366" rel="nofollow">递归锁实现</a></li><li><ul><li><a href="#1_370" rel="nofollow">1、创建递归锁</a></li><li><a href="#2GiveTake_379" rel="nofollow">2、Give/Take</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>前言</h3> 
<blockquote> 
 <p>这是第三弹，由于CSDN长度的限制，所以把FreeRTOS学习分为几部分来发，这是第三部分<br> <br><br> 主要包括<code>信号量、互斥量使用</code>等</p> 
</blockquote> 
<h3><a id="_7"></a>往期学习笔记链接</h3> 
<blockquote> 
 <p><code>第一弹</code>：<a href="https://blog.csdn.net/cyaya6/article/details/132482017?spm=1001.2014.3001.5501">FreeRTOS学习笔记（1、FreeRTOS初识、任务的创建以及任务状态理论、调度算法等）</a><br> <code>第二弹</code>: <a href="https://blog.csdn.net/cyaya6/article/details/132507836?spm=1001.2014.3001.5501">FreeRTOS学习笔记（2、同步与互斥通信、队列、队列集的使用）</a><br> <code>第三弹</code>: <a href="https://blog.csdn.net/cyaya6/article/details/132507946?spm=1001.2014.3001.5501">FreeRTOS学习笔记（3、信号量、互斥量的使用）</a><br> <code>第四弹</code>: <a href="https://blog.csdn.net/cyaya6/article/details/132515584?spm=1001.2014.3001.5501">FreeRTOS学习笔记（4、事件组、任务通知）</a><br> <code>第五弹</code>: <a href="https://blog.csdn.net/cyaya6/article/details/132539520?spm=1001.2014.3001.5501">FreeRTOS学习笔记（5、定时器、中断管理、调试与优化）</a></p> 
</blockquote> 
<h3><a id="_15"></a>学习工程</h3> 
<blockquote> 
 <p><code>所有学习工程</code><br> <a href="https://gitee.com/cyaya6/free-rtos-learning" rel="nofollow">oufen / FreeRTOS学习</a><br> <code>都在我的Gitee工程当中，大家可以参考学习</code></p> 
</blockquote> 
<h3><a id="_semaphore_19"></a>信号量 semaphore</h3> 
<p>队列可以传送数据，队列可以传送不同的数据</p> 
<p><strong>有的时候只需要传递状态，并不需要传递具体的信息</strong></p> 
<blockquote> 
 <p>这就是信号量，不去传送数据，而是传送状态,这样至起到了通知的作用，更加节省内存</p> 
</blockquote> 
<blockquote> 
 <p><strong>信号量，不能传输数据，只有一个计数值，来表示资源的数量</strong></p> 
 <hr> 
 <p><strong>信号</strong>起通知作用</p> 
</blockquote> 
<blockquote> 
 <p><strong>量,表示资源的数量</strong></p> 
</blockquote> 
<p>左边是生产者，生产好一个商品后让计数值+1<br> 右边是消费者，取出一个商品后计数值-1</p> 
<p>如何创建信号量</p> 
<ul><li>创建信号量</li><li>生产者生产好后让计数值+1 give</li><li>消费者取出后让计数值-1 take</li></ul> 
<p><strong>计数</strong>：事件产生give信号量，计数值加1，处理事件，take信号量，计数值减1<br> <strong>资源管理</strong>:想要访问资源时，首先需要take信号量，计数值减1，用完资源后，give信号量，计数值加1</p> 
<p><img src="https://images2.imgbox.com/d9/1f/fPjIgaoI_o.png" alt="image.png"></p> 
<h4><a id="_51"></a>两种信号量的对比</h4> 
<ul><li>计数型信号量</li><li>二进制信号量</li></ul> 
<p><strong>计数型信号量</strong>，的<strong>取值范围为0-任意数</strong></p> 
<p><strong>二进制信号量</strong>，的<strong>取值返回为0或者1 但是二进制信号量的初始值为0</strong></p> 
<p>除了取值不一样外，其他的操作都是完全一样的</p> 
<p>信号量也相当于是一个队列</p> 
<p>队列有一个结构体Queue,结构体中有一个指针，指向存放数据的一个buff</p> 
<p>但是对于信号量，并不需要这个buffer,只需要这个结构体</p> 
<p>对于信号量，核心是信号量的计数值<br> 这个计数值保存在初始化信号量时传入的初始的计数值</p> 
<p><img src="https://images2.imgbox.com/dd/2a/LLGcD913_o.png" alt="image.png"></p> 
<p>创建完信号量后，就可以加减信号量的Value了<br> 让信号量的计数值+1,并且取出东西</p> 
<p>一开始Value为0，调用take函数，使信号量减1，没有数据，那么信号量就没办法-1，进入阻塞状态，还可以指定阻塞多长时间<br> 在阻塞状态中，如果有另一个task往里面放数据，那么就会从阻塞状态中唤醒，进入Ready状态</p> 
<ol><li><strong>对于give,信号量加1 解锁</strong></li></ol> 
<blockquote> 
 <p>对于计数型信号量，可以让这个值累加，但是不能超过创建时指定的最大值</p> 
</blockquote> 
<blockquote> 
 <p>对于二进制信号量，取值就只有0和1，如果值为1，再次调用give也不会成功<br> 可以判断give函数的返回值，看累加是否成功</p> 
</blockquote> 
<p><strong>不管哪种信号量，只要没有超过创建时指定的最大值，都可以累加成功</strong><br> <img src="https://images2.imgbox.com/d1/ba/DHlPKhSB_o.png" alt="image.png"></p> 
<ol start="2"><li><strong>对于take，信号量-1 上锁</strong></li></ol> 
<p>如果信号量的值为0，就没办法take成功，不成功的话可以指定阻塞时间</p> 
<ul><li>0 take不成功，返回err</li><li>portMax_Delay 一直阻塞，直到成功</li></ul> 
<ol start="3"><li><strong>有多个task执行take，当其他task执行give时，唤醒哪个任务？</strong></li></ol> 
<ul><li><strong>优先级最高的task</strong> 优先执行take</li><li>**优先级相同时，等待最久的task ** 优先执行take</li></ul> 
<p><img src="https://images2.imgbox.com/76/54/ecOROR3N_o.png" alt="image.png"><br> pdTRUE，表示Take成功</p> 
<p>小问题：<br> 使用队列也可以实现同步，为什么还要使用信号量呢？</p> 
<ul><li>使用队列可以传递数据，数据的保存需要空间</li><li>使用信号量时不需要传递数据，更加节省空间</li><li>使用信号量时不需要复制数据，效率更高</li></ul> 
<p><img src="https://images2.imgbox.com/0f/ed/R675Rkyw_o.png" alt="image.png"></p> 
<h4><a id="_115"></a>信号量的使用</h4> 
<p>使用信号量时，先创建，然后去添加资源，获得资源，使用句柄来表示一个信号量</p> 
<p>需要定义这两个宏</p> 
<pre><code>#define configSUPPORT_DYNAMIC_ALLOCATION 1 /*信号量相关宏*/
#define configUSE_COUNTING_SEMAPHORES 1
</code></pre> 
<p><img src="https://images2.imgbox.com/c1/d1/V5PkL1VC_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/f6/a1/p226S9Kl_o.png" alt="image.png"></p> 
<h5><a id="1_129"></a>1、创建信号量</h5> 
<p>初始值为0 信号量计数值 最大值为10<br> <img src="https://images2.imgbox.com/38/c4/scOxdtA4_o.png" alt="image.png"></p> 
<h5><a id="2give_134"></a>2、give</h5> 
<p><img src="https://images2.imgbox.com/56/a4/IjmdcWgw_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/07/e0/Xj4FBFjt_o.png" alt="image.png"></p> 
<h5><a id="3take_139"></a>3、take</h5> 
<p><img src="https://images2.imgbox.com/d4/5f/ldrTAcFE_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/4e/07/qheNuSIA_o.png" alt="image.png"></p> 
<h5><a id="4_144"></a>4、删除信号量</h5> 
<p>对于动态创建的信号量，如果不使用，不再需要时，可以删除他们以回收内存<br> <img src="https://images2.imgbox.com/2a/c5/afVzVsM9_o.png" alt="image.png"></p> 
<h5><a id="_149"></a>使用计数型信号量实现同步功能</h5> 
<p>虽然实现了同步功能，但是对于数据的完整性，需要我们自己来做<br> <img src="https://images2.imgbox.com/d3/08/Yc20n4ji_o.png" alt="image.png"></p> 
<h5><a id="_155"></a>使用二进制型信号量实现互斥功能</h5> 
<blockquote> 
 <p><strong>注意了二进制型信号量初始值为0</strong><br> 所以创建二进制信号量时需要，手动give一下，否则take时会一直卡在阻塞状态</p> 
</blockquote> 
<p>task3和task4独占的使用串口</p> 
<p>创建二进制信号量来实现互斥<br> <img src="https://images2.imgbox.com/74/2f/wtPVOGPY_o.png" alt="image.png"></p> 
<p><img src="https://images2.imgbox.com/c5/88/b7cKBH50_o.png" alt="image.png"></p> 
<p>task3和task4实现了串口的独占使用，即实现互斥功能<br> <img src="https://images2.imgbox.com/00/ef/TiGQfJTB_o.png" alt="image.png"></p> 
<h3><a id="__mutex_172"></a>互斥量 mutex</h3> 
<p>互斥量是一个特殊的二进制信号量</p> 
<p>**任务A访问这些全局变量、函数代码时，独占它，就是上个锁。这些全局变<br> 量、函数代码必须被独占地使用，它们被称为临界资源 **</p> 
<p>互斥量，就是用来保护临界资源，大家互斥的使用这些资源</p> 
<p><img src="https://images2.imgbox.com/54/61/SANAMkwB_o.png" alt="image.png"></p> 
<p>二进制信号量也能实现互斥<br> <img src="https://images2.imgbox.com/3c/64/KIhq6bky_o.png" alt="image.png"></p> 
<p>当出现一种情况</p> 
<p>TaskA获得信号量，计数值-1，此时二进制信号量为0<br> 打印数据<br> 此时TaskC运行另一个函数，give信号量，计数值+1，此时二进制信号量为1<br> 此时TaskB从阻塞状态，进入Ready态<br> 也能打印数据</p> 
<p>此时串口被两个Task使用，就不是独占关系，不是互斥，对临界资源进行使用</p> 
<p>本来应该是TaskA上锁(获得信号量，使信号量的计数值为0)<br> 打印完数据后，应该由TaskA自己解锁<br> 可是其他任务帮TaskA解锁，造成串口不是独占使用</p> 
<blockquote> 
 <p>要解决这样的问题，就应该是谁上锁，谁来解锁<br> <strong>二进制信号量并不能保证，谁上锁，谁解锁</strong><br> 虽然互斥量也不能保证</p> 
 <p>但是互斥量可以解决</p> 
 <ul><li>优先级反转</li><li>解决递归上锁/解锁的问题</li></ul> 
</blockquote> 
<p>如何实现谁上锁，谁解锁</p> 
<ul><li>上锁、解锁代码成对出现</li><li>在临界代码中(想要某种资源被独占使用)，不要解锁</li></ul> 
<h4><a id="_217"></a>问题：优先级反转</h4> 
<p>什么是优先级反转？<br> A/B/C的优先级分别是 1 2 3<br> A先运行，获得了锁，此时进入阻塞状态<br> B优先级比A高，抢占进入Running状态<br> 由于A已经使用了锁，所以进入阻塞状态<br> C的优先级比B高，此时C运行，也想获得锁，因为A已经使用了锁，所以C进入阻塞状态<br> 此时优先级高的Task优先执行，轮到B运行<br> 在B运行过程中，一直没有放弃CPU资源，此时A不能执行</p> 
<p>在这种情况下，C的优先级最高，A的优先级最低，结果优先级最高的C被B抢占了</p> 
<p>优先级高的程序反而不能执行，这就是优先级反转<br> <img src="https://images2.imgbox.com/27/a9/6ZneDnyU_o.png" alt="image.png"></p> 
<h4><a id="_233"></a>解决方法：优先级继承</h4> 
<p>解决优先级反转的方法就是使用优先级继承</p> 
<p><strong>什么是优先级继承？</strong></p> 
<blockquote> 
 <p><strong>在C获得锁Take，因为锁被A上锁了，所以进入阻塞状态，进入阻塞状态的同时会进行优先级继承</strong><br> 此时A的优先级变成了C的优先级，A继承了C的优先级<br> 此时A的优先级变为了3，所以C阻塞后，A开始运行<br> <strong>A对锁进行解锁，unlock，释放互斥量，A的优先级又变成了原来的优先级1</strong><br> 然后轮到C来执行</p> 
</blockquote> 
<p>这个过程中C的优先级并没有被B来反转，优先级继承解决了上述优先级反转的问题</p> 
<p><strong>优先级继承的好处在于提升优先级，如果C的优先级比A的还低，就没有继承的必要</strong></p> 
<h4><a id="_250"></a>问题：递归上锁造成死锁</h4> 
<p><img src="https://images2.imgbox.com/1e/78/fTTkV2SK_o.png" alt="image.png"></p> 
<p>这是自我死锁</p> 
<blockquote> 
 <p>TaskA运行，上锁后，信号量计数值为0，打印数据<br> 进入xxxlib函数，再次上锁，因为信号量计数值为0，无法继续上锁，所以进入阻塞状态<br> 进入阻塞状态，没有办法解锁，造成了死锁</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/9f/1f/glAaNPmx_o.png" alt="image.png"></p> 
<h4><a id="_264"></a>解决方法：递归锁</h4> 
<p>递归锁是互斥量的另外一种形式</p> 
<p>在上锁了之后，还可以二次上锁，但是二次上锁后要解锁，否则会进入阻塞状态<br> 一次上锁对应一次解锁</p> 
<p>此时B来上锁，就会进入阻塞状态<br> <img src="https://images2.imgbox.com/78/c0/QDDsEL5m_o.png" alt="image.png"></p> 
<p>互斥量分为两种</p> 
<ul><li>普通的互斥量 
  <ul><li>具有优先级继承的功能</li></ul> </li><li>递归锁 
  <ul><li>除了具有优先级继承的功能外</li><li>递归的功能</li></ul> </li></ul> 
<h4><a id="_283"></a>互斥量的基本使用</h4> 
<h5><a id="1_285"></a>1、创建互斥量</h5> 
<p>二进制型信号量的初始值为0，所以创建时需要手动give释放一下，计数值+1，否则take时，计数值无法减1，将会发生阻塞</p> 
<p>而互斥量的初始值为1，创建后不需要Give一次</p> 
<p><img src="https://images2.imgbox.com/fa/c1/GyClckRL_o.png" alt="image.png"><br> 创建互斥量时还需要配置宏<br> <img src="https://images2.imgbox.com/94/15/982LVUCD_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/14/40/vZXf0ffo_o.png" alt="image.png"></p> 
<pre><code>/*互斥量相关宏*/
#define configUSE_MUTEXES 1
</code></pre> 
<h5><a id="2__Take_301"></a>2、获得互斥量 Take</h5> 
<p><img src="https://images2.imgbox.com/b1/b5/MnXehpIX_o.png" alt="image.png"></p> 
<h5><a id="3%09Give_305"></a>3、释放互斥量 Give</h5> 
<p><img src="https://images2.imgbox.com/af/94/1gpYakIG_o.png" alt="image.png"></p> 
<p><img src="https://images2.imgbox.com/0b/0d/1Qvuxdfy_o.png" alt="image.png"></p> 
<h4><a id="_312"></a>使用优先级继承来实现优先级反转</h4> 
<h5><a id="_314"></a>二进制信号量优先级反转的过程分析</h5> 
<blockquote> 
 <p><strong>此时是二进制型信号量</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/1f/7a/qpl3bqaE_o.png" alt="image.png"><br> 下图就是优先级反转的例子<br> <img src="https://images2.imgbox.com/87/e9/QR5yMzRU_o.png" alt="image.png"></p> 
<p><img src="https://images2.imgbox.com/d9/89/0S9r60vu_o.png" alt="image.png"></p> 
<p><strong>根据波形图对</strong><br> <strong>优先级反转详细说明</strong><br> <img src="https://images2.imgbox.com/a3/77/PARm7ThR_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/c9/15/DgYkt8nk_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/38/ba/SAoRWcNK_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/ea/23/niT2fGaf_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/77/f9/39qkkQIx_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/24/74/rqtGcZH2_o.png" alt="image.png"></p> 
<h5><a id="_333"></a>互斥量使用优先级继承来解决优先级反转</h5> 
<p><img src="https://images2.imgbox.com/dd/41/7eaX1Q8b_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/aa/dc/MJ4QybTb_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/3c/69/OjrLtfUp_o.png" alt="image.png"></p> 
<h4><a id="_339"></a>互斥量和二进制信号量的区别和共同点</h4> 
<ol><li> <p>互斥量初始值为1</p> </li><li> <p>二进制信号量初始值为0</p> </li><li> <p>Give/Take函数完全一样</p> </li><li> <p>互斥量具有优先级继承的功能</p> </li></ol> 
<h4><a id="_349"></a>互斥量的递归锁</h4> 
<p>互斥量，本意是谁持有，谁释放</p> 
<p>但是FreeRTOS没有实现这一点</p> 
<p>A持有，B也可以释放</p> 
<p>但是互斥量的递归锁实现了</p> 
<blockquote> 
 <p>谁持有，就有谁释放<br> 递归上锁和解锁</p> 
</blockquote> 
<p>一般的互斥量，并没有实现，谁持有，就由谁释放<br> <img src="https://images2.imgbox.com/b8/4c/Fbe77DwO_o.png" alt="image.png"></p> 
<h5><a id="_366"></a>递归锁实现</h5> 
<p><img src="https://images2.imgbox.com/2a/cd/XSWOk6r2_o.png" alt="image.png"></p> 
<h6><a id="1_370"></a>1、创建递归锁</h6> 
<p><img src="https://images2.imgbox.com/3c/73/UHYwqb5Z_o.png" alt="image.png"></p> 
<p>递归锁实现，要首先配置相关宏<br> <img src="https://images2.imgbox.com/ee/41/jswhKc5T_o.png" alt="image.png"></p> 
<p>FreeRTOS为了减小程序的体积，使用某些功能时，首先需要配置</p> 
<h6><a id="2GiveTake_379"></a>2、Give/Take</h6> 
<p>和信号量不同的是Give/Take的函数发生改变</p> 
<p>同时递归锁能够实现谁上锁，谁解锁的功能</p> 
<p><img src="https://images2.imgbox.com/85/5e/RltmA2l6_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/57/59/PFxBUEje_o.png" alt="image.png"></p> 
<p>递归锁可以让task互斥使用串口</p> 
<p>递归锁实现了谁持有，就由谁来释放</p> 
<p>递归锁内部会记录持有者，对于持有递归锁的task，可以循环的使用上锁，开锁</p> 
<p><img src="https://images2.imgbox.com/a9/a8/hYxhFlQT_o.png" alt="image.png"></p> 
<p><img src="https://images2.imgbox.com/05/cc/D1CHA3at_o.png" alt="image.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53895f2d720124d199bed5698e95f9b8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FreeRTOS学习笔记（4、事件组、任务通知）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b64da2479737ef58aa5d90d4acee7b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何利用matlab自带的函数及工具箱对信号进行频谱分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>