<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UG/NX二次开发Siemens官方NXOPEN实例解析—2.1 AssemblyViewer（树列表） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UG/NX二次开发Siemens官方NXOPEN实例解析—2.1 AssemblyViewer（树列表）" />
<meta property="og:description" content="列文章目录 UG/NX二次开发Siemens官方NXOPEN实例解析—2.1 AssemblyViewer（树列表）UG/NX二次开发Siemens官方NXOPEN实例解析—2.2 Selection（选择过滤器）UG/NX二次开发Siemens官方NXOPEN实例解析—2.3 Selection_UIStyler（边倒角）UG/NX二次开发Siemens官方NXOPEN实例解析—2.4 File2Points（读取文本）UG/NX二次开发Siemens官方NXOPEN实例解析—2.5 QuickExtrude（拉伸）UG/NX二次开发Siemens官方NXOPEN实例解析—2.6 CreateNote（注释）UG/NX二次开发Siemens官方NXOPEN实例解析—2.7 DiameterSymbol（标注符号） UG/NX二次开发Siemens官方NXOPEN实例解析—2.8 DrawingCycle（图纸打印）UG/NX二次开发Siemens官方NXOPEN实例解析—2.9 InteropCallCFromDotNet(VB调用VC&#43;&#43; DLL实践)UG/NX二次开发Siemens官方NXOPEN实例解析—2.10 InteropNXOpenWithUFWrap（NXOPEN与Ufun混合使用） 前言 随着工业智能化的不断发展，UG二次开发的需求越来越多，也吸引了大批的二开从业人员，本人作为一名资深IT从业者（10年&#43;）也毅然加入二次开发大军。
然而，和流行IT行业（互联网、金融、医疗等）相比，工业智能化的门槛显得更高一点，专业的工业软件，相对封闭的开发理念和更小的开发圈子，让刚进入二开的从业者有点举步维艰。边学边整理，希望通过这系列文章的整理能给二开的生态增添一叶绿。
一、知识点提取汇总 1、树列表控件的初始化和数据加载
2、选择对象控件过滤器使用
3、对象颜色拾取器的使用
4、遍历组件方法的实现
5、树列表控件通过递归方法实现多层目录加载
二、案例需求分析 1、最终效果图 2、需求分解 本案的需求分解如下：
1）加载装配目录到树列表，通过选取树列表的方式，实现配件的选取
2）也可以通过组件选择器的方式，选取配件
3）为选取的配件设置颜色
三、程序分析 1、源码所在目录 UGOPEN\SampleNXOpenApplications\C&#43;&#43;\AssemblyViewer
2、主要功能分析 1）树列表控件的初始化和回调方法
treeList = dynamic_cast&lt;NXOpen::BlockStyler::Tree*&gt;(theDialog-&gt;TopBlock()-&gt;FindBlock(&#34;treeList&#34;)); //注册回调方法 treeList-&gt;SetOnSelectHandler(make_callback(this, &amp;AssemblyViewer::OnSelectCallback)); void AssemblyViewer::OnSelectCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *, int columnID, bool selected) { try { if(selected == true) { PartCleanup(); ComponentSelection(); } } catch(exception&amp; ex) { } } void AssemblyViewer::ComponentSelection() { try { bool singleComponent = IsSingleComponentSelection(); std::vector&lt;NXOpen::TaggedObject *&gt;selObjectData = GetSelectedObjects(); std::vector&lt;NXOpen::TaggedObject *&gt;selNodeComps = GetSelectedNodes(); // Create a DisplayModification object to set the color if (selObjectData." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4b19df67773be46435a208c1c3212882/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-29T11:11:47+08:00" />
<meta property="article:modified_time" content="2022-12-29T11:11:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UG/NX二次开发Siemens官方NXOPEN实例解析—2.1 AssemblyViewer（树列表）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"> 列文章目录</h2> 
<table cellspacing="0"><tbody><tr><td style="vertical-align:bottom;"><span style="color:#0000ff;"><u><a href="https://blog.csdn.net/MarcoPro/article/details/128370798" title="UG/NX二次开发Siemens官方NXOPEN实例解析—2.1 AssemblyViewer（树列表）">UG/NX二次开发Siemens官方NXOPEN实例解析—2.1 AssemblyViewer（树列表）</a></u></span></td></tr><tr><td style="vertical-align:bottom;"><span style="color:#0000ff;"><u><a href="https://blog.csdn.net/MarcoPro/article/details/128374385" title="UG/NX二次开发Siemens官方NXOPEN实例解析—2.2 Selection（选择过滤器）">UG/NX二次开发Siemens官方NXOPEN实例解析—2.2 Selection（选择过滤器）</a></u></span></td></tr><tr><td style="vertical-align:bottom;"><span style="color:#0000ff;"><u><a href="https://blog.csdn.net/MarcoPro/article/details/128385289" title="UG/NX二次开发Siemens官方NXOPEN实例解析—2.3 Selection_UIStyler（边倒角）">UG/NX二次开发Siemens官方NXOPEN实例解析—2.3 Selection_UIStyler（边倒角）</a></u></span></td></tr><tr><td style="vertical-align:bottom;"><span style="color:#0000ff;"><u><a href="https://blog.csdn.net/MarcoPro/article/details/128393135" title="UG/NX二次开发Siemens官方NXOPEN实例解析—2.4 File2Points（读取文本）">UG/NX二次开发Siemens官方NXOPEN实例解析—2.4 File2Points（读取文本）</a></u></span></td></tr><tr><td style="vertical-align:bottom;"><span style="color:#0000ff;"><u><a href="https://blog.csdn.net/MarcoPro/article/details/128397485" title="UG/NX二次开发Siemens官方NXOPEN实例解析—2.5 QuickExtrude（拉伸）">UG/NX二次开发Siemens官方NXOPEN实例解析—2.5 QuickExtrude（拉伸）</a></u></span></td></tr><tr><td style="vertical-align:bottom;"><span style="color:#0000ff;"><u><a href="https://blog.csdn.net/MarcoPro/article/details/128408900" title="UG/NX二次开发Siemens官方NXOPEN实例解析—2.6 CreateNote（注释）">UG/NX二次开发Siemens官方NXOPEN实例解析—2.6 CreateNote（注释）</a></u></span></td></tr><tr><td style="vertical-align:bottom;"><span style="color:#0000ff;"><u><a href="https://blog.csdn.net/MarcoPro/article/details/128410510" title="UG/NX二次开发Siemens官方NXOPEN实例解析—2.7 DiameterSymbol（标注符号） ">UG/NX二次开发Siemens官方NXOPEN实例解析—2.7 DiameterSymbol（标注符号） </a></u></span></td></tr><tr><td style="vertical-align:bottom;"><span style="color:#0000ff;"><u><a href="https://blog.csdn.net/MarcoPro/article/details/128464695" title="UG/NX二次开发Siemens官方NXOPEN实例解析—2.8 DrawingCycle（图纸打印）">UG/NX二次开发Siemens官方NXOPEN实例解析—2.8 DrawingCycle（图纸打印）</a></u></span></td></tr><tr><td style="vertical-align:bottom;"><span style="color:#0000ff;"><u><a href="https://blog.csdn.net/MarcoPro/article/details/128468560" title="UG/NX二次开发Siemens官方NXOPEN实例解析—2.9 InteropCallCFromDotNet(VB调用VC++ DLL实践)">UG/NX二次开发Siemens官方NXOPEN实例解析—2.9 InteropCallCFromDotNet(VB调用VC++ DLL实践)</a></u></span></td></tr><tr><td style="vertical-align:bottom;"><span style="color:#0000ff;"><u><a href="https://blog.csdn.net/MarcoPro/article/details/128471274" title="UG/NX二次开发Siemens官方NXOPEN实例解析—2.10 InteropNXOpenWithUFWrap（NXOPEN与Ufun混合使用）">UG/NX二次开发Siemens官方NXOPEN实例解析—2.10 InteropNXOpenWithUFWrap（NXOPEN与Ufun混合使用）</a></u></span></td></tr></tbody></table> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_12"></a>前言</h2> 
<p>        随着工业智能化的不断发展，UG二次开发的需求越来越多，也吸引了大批的二开从业人员，本人作为一名资深IT从业者（10年+）也毅然加入二次开发大军。</p> 
<p>        然而，和流行IT行业（互联网、金融、医疗等）相比，工业智能化的门槛显得更高一点，专业的工业软件，相对封闭的开发理念和更小的开发圈子，让刚进入二开的从业者有点举步维艰。边学边整理，希望通过这系列文章的整理能给二开的生态增添一叶绿。</p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81UI%E6%A0%B7%E5%BC%8F%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90"><strong>一、知识点提取汇总</strong></h2> 
<p id="1.%20%E6%A0%B7%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">1、树列表控件的初始化和数据加载</p> 
<p>2、选择对象控件过滤器使用</p> 
<p>3、对象颜色拾取器的使用</p> 
<p>4、遍历组件方法的实现</p> 
<p>5、树列表控件通过递归方法实现多层目录加载</p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90"><a id="_26"></a>二、案例需求分析</h2> 
<h4 id="1%E3%80%81%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C%E5%9B%BE">1、最终效果图</h4> 
<p><img alt="" height="481" src="https://images2.imgbox.com/8c/fd/Ft4fAqTW_o.png" width="1015"></p> 
<p></p> 
<h4 id="%C2%A02%E3%80%81%E9%9C%80%E6%B1%82%E5%88%86%E8%A7%A3"> 2、需求分解</h4> 
<p>本案的需求分解如下：</p> 
<p>1）加载装配目录到树列表，通过选取树列表的方式，实现配件的选取</p> 
<p>2）也可以通过组件选择器的方式，选取配件</p> 
<p>3）为选取的配件设置颜色</p> 
<h3 id="1.%E5%BC%95%E5%85%A5%E5%BA%93"><a id="1_27"></a></h3> 
<h2 id="%E4%B8%89%E3%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90">三、程序分析</h2> 
<h4 id="1%E3%80%81%E6%BA%90%E7%A0%81%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95">1、源码所在目录</h4> 
<blockquote> 
 <p>UGOPEN\SampleNXOpenApplications\C++\AssemblyViewer</p> 
</blockquote> 
<h4 id="%C2%A02%E3%80%81%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90"> 2、主要功能分析</h4> 
<p>1）树列表控件的初始化和回调方法</p> 
<pre><code class="language-cpp">treeList = dynamic_cast&lt;NXOpen::BlockStyler::Tree*&gt;(theDialog-&gt;TopBlock()-&gt;FindBlock("treeList"));
//注册回调方法
treeList-&gt;SetOnSelectHandler(make_callback(this, &amp;AssemblyViewer::OnSelectCallback));

void AssemblyViewer::OnSelectCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *, int columnID, bool selected)
{
    try
    {
        if(selected == true)
        {
            PartCleanup();
            ComponentSelection();
        }        
    }
    catch(exception&amp; ex)
    {
    }
}
void AssemblyViewer::ComponentSelection()
{
    try
    {
        bool singleComponent = IsSingleComponentSelection();       
        std::vector&lt;NXOpen::TaggedObject *&gt;selObjectData = GetSelectedObjects();
        std::vector&lt;NXOpen::TaggedObject *&gt;selNodeComps = GetSelectedNodes();    
        // Create a DisplayModification object to set the color
        if (selObjectData.size()&gt;0)
        {
            HighlightComponent(selObjectData,false);
            drawAll = singleComponent?false:true;
            HighlightComponent(selObjectData, true);
        }
        if (selNodeComps.size()&gt;0)
        {                
            HighlightComponent(selNodeComps,false);
            drawAll = singleComponent?false:true;
            HighlightComponent(selNodeComps, true);
        }        
    }
    catch(exception&amp; ex)
    {
    }
}</code></pre> 
<p>2） 树列表控件通过递归方法实现多层目录加载</p> 
<pre><code class="language-cpp">void AssemblyViewer::PopulateTree(NXOpen::Assemblies::Component *component)
{
    std::vector&lt;Component *&gt; childComponent = component-&gt;GetChildren();    
    int childComponentCount = childComponent.size();
    for(int i=0; i&lt;childComponentCount; ++i)
    {
        BlockStyler::Node *node = treeList-&gt;CreateNode(childComponent[i]-&gt;Name());
        NXOpen::DataContainer *nodeData = node-&gt;GetNodeData();
        nodeData-&gt;AddTaggedObject("Data",childComponent[i]);
        treeNodes.push_back(node);
        delete nodeData;
        nodeData = NULL;
        node-&gt;SetForegroundColor(198);
        treeList-&gt;InsertNode(node,parentNode,NULL,treeList-&gt;NodeInsertOptionLast);
        parentNode = node;
        PopulateTree(childComponent[i]);
        parentNode = node-&gt;ParentNode();    
    }
}</code></pre> 
<p>3） 选择对象控件过滤器使用</p> 
<pre><code class="language-cpp">selComponent = dynamic_cast&lt;NXOpen::BlockStyler::UIBlock*&gt;(theDialog-&gt;TopBlock()-&gt;FindBlock("selComponent"));
 NXOpen::Selection::SelectionAction action = Selection::SelectionActionClearAndEnableSpecific;
        std::vector&lt;NXOpen::Selection::MaskTriple&gt;selectionMask_array(2);
        selectionMask_array[0].Type = UF_component_type ;
        selectionMask_array[0].Subtype = UF_component_subtype  ;
        selectionMask_array[1].Type = UF_component_type;
        selectionMask_array[1].Subtype = UF_part_occurrence_subtype;
		NXOpen::BlockStyler::PropertyList *selComponentProps = selComponent-&gt;GetProperties();
        selComponentProps-&gt;SetSelectionFilter("SelectionFilter",action,selectionMask_array);
		delete selComponentProps;
		selComponentProps = NULL;</code></pre> 
<p>4） 对象颜色拾取器的使用</p> 
<blockquote> 
 <p> NXOpen::BlockStyler::PropertyList *selColorProps =selColor-&gt;GetProperties();<br> std::vector&lt;int &gt; colorValue = selColorProps-&gt;GetIntegerVector("Value");            </p> 
</blockquote> 
<p>5） 遍历组件方法的实现</p> 
<pre><code class="language-cpp">void AssemblyViewer::PopulateTree(NXOpen::Assemblies::Component *component)
{
    std::vector&lt;Component *&gt; childComponent = component-&gt;GetChildren();    
    int childComponentCount = childComponent.size();
    for(int i=0; i&lt;childComponentCount; ++i)
    {
        BlockStyler::Node *node = treeList-&gt;CreateNode(childComponent[i]-&gt;Name());
        NXOpen::DataContainer *nodeData = node-&gt;GetNodeData();
        nodeData-&gt;AddTaggedObject("Data",childComponent[i]);
        treeNodes.push_back(node);
        delete nodeData;
        nodeData = NULL;
        node-&gt;SetForegroundColor(198);
        treeList-&gt;InsertNode(node,parentNode,NULL,treeList-&gt;NodeInsertOptionLast);
        parentNode = node;
        PopulateTree(childComponent[i]);
        parentNode = node-&gt;ParentNode();    
    }
}</code></pre> 
<blockquote> 
 <p>遍历组件主要用了GetChildren()方法：</p> 
 <p>std::vector&lt;Component *&gt; childComponent = component-&gt;GetChildren();</p> 
 <p>然后通过PopulateTree递归的方式实现对组件的所有目录的遍历</p> 
</blockquote> 
<p>6）设置所选组件的颜色</p> 
<pre><code class="language-cpp">void AssemblyViewer::ApplyColor(std::vector&lt;NXOpen::TaggedObject *&gt;&amp;selObjectData)
{
    try
    {
        //---- Enter your callback code here -----
        NXOpen::BlockStyler::PropertyList *selColorProps =selColor-&gt;GetProperties();
        std::vector&lt;int &gt; colorValue = selColorProps-&gt;GetIntegerVector("Value");            
        delete selColorProps;
        selColorProps = NULL;      

        DisplayModification *displayModification1 = theSession-&gt;DisplayManager()-&gt;NewDisplayModification();       
        displayModification1-&gt;SetApplyToAllFaces(false);
        displayModification1-&gt;SetApplyToOwningParts(false);
        displayModification1-&gt;SetNewColor(colorValue[0]);
        std::vector&lt;DisplayableObject *&gt; objects1;
		int selObjectCount = selObjectData.size();
        for(int i=0; i&lt;selObjectCount; ++i)
        {
            objects1.push_back(dynamic_cast&lt;NXOpen::DisplayableObject *&gt;(selObjectData[i]));
        }
        displayModification1-&gt;Apply(objects1);
        objects1.clear();
        delete displayModification1;
        displayModification1 = NULL;

        PartCleanup();        
    }
    catch(exception&amp; ex)
    {
    }
}</code></pre> 
<blockquote> 
 <p> 使用displayModification类，实现了对所选对象的颜色设置</p> 
</blockquote> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_55"></a></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/946ad54dca3aa4d9d041e6fb502888bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Apache IoTDB下载与安装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0bacbbf6d4485d146520bacb9198f4f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于ESP32-CAM的RSTP协议网络摄像头</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>