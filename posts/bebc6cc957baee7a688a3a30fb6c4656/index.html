<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MTK camera启动流程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MTK camera启动流程" />
<meta property="og:description" content="和你一起终身学习，这里是程序员Android
经典好文推荐，通过阅读本文，您将收获以下知识点:
一、Camera 框架介绍： Camera的框架分为Kernel部分和hal部分，其中kernel部分主要有两块：
image sensor driver，负责具体型号的sensor的id检测，上电，以及在preview、capture、初始化、3A等等功能设定时的寄存器配置；
isp driver，通过DMA将sensor数据流上传；
HAL层部分主要有三部分组成：
imageio，主要负责数据buffer上传的pipe；
drv，包含imgsensor和isp的hal层控制；
feature io，包含各种3A等性能配置；
这篇内容主要介绍开机过程中search sensor以及上电流程等内容。
二、Camera 启动流程 1、CameraService是在开机时启动的，启动后进行searchSensor的操作，会search系统有多少camera，开机时的search操作，只进行camera支持数量的遍历，以及sensor ID的读取操作，如下是hal部分的ASTAH绘制调用流程图，对应的接口的文件路径：
HalSensorList：
vendor/mediatek/proprietary/hardware/mtkcam/drv/src/sensor/common/v1/HalSensorList.enumList.cpp
vendor/mediatek/proprietary/hardware/mtkcam/drv/src/sensor/common/v1/HalSensorList.cpp
SeninfDrv：
vendor/mediatek/proprietary/hardware/mtkcam/drv/src/sensor/mt6765/seninf_drv.cpp
SensorDrv：
vendor/mediatek/proprietary/hardware/mtkcam/drv/src/sensor/common/v1/imgsensor_drv.cpp
(1) 这里先看enumerateSensor_Locked完成的工作，直接看代码：
MUINT HalSensorList::searchSensors() { Mutex::Autolock _l(mEnumSensorMutex); MY_LOGD(&#34;searchSensors&#34;); return enumerateSensor_Locked(); } MUINT HalSensorList::enumerateSensor_Locked() { SensorDrv *const pSensorDrv = SensorDrv::get(); SeninfDrv *const pSeninfDrv = SeninfDrv::createInstance(); //初始化seninf,配置ISP相关内容 pSeninfDrv-&gt;init(); //将所有的clk全部打开 pSeninfDrv-&gt;setAllMclkOnOff(ISP_DRIVING_8MA, TRUE); pSensorDrv-&gt;init(); for (MUINT i = IMGSENSOR_SENSOR_IDX_MIN_NUM; i &lt;= max_index_of_camera; i&#43;&#43;) { if((ret = pSensorDrv-&gt;searchSensor((IMGSENSOR_SENSOR_IDX)i)) == SENSOR_NO_ERROR){ //query sensorinfo querySensorDrvInfo((IMGSENSOR_SENSOR_IDX)i); //fill in metadata buildSensorMetadata((IMGSENSOR_SENSOR_IDX)i); pSensorInfo = pSensorDrv-&gt;getSensorInfo((IMGSENSOR_SENSOR_IDX)i); addAndInitSensorEnumInfo_Locked( (IMGSENSOR_SENSOR_IDX)i, mapToSensorType(pSensorInfo-&gt;GetType()), pSensorInfo-&gt;getDrvMacroName()); } } } (２) 下面主要看下searchSensor的流程，这里有去获取sensorList的内容：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bebc6cc957baee7a688a3a30fb6c4656/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-26T07:53:15+08:00" />
<meta property="article:modified_time" content="2021-03-26T07:53:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MTK camera启动流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/e6/46/0Xnnzp4u_o.gif"></p> 
 <p style="text-align: left"><strong>和你一起终身学</strong><strong></strong><strong>习，这里是程序员Android</strong></p> 
 <p style="text-align: left">经典好文推荐，通过阅读本文，您将收获以下知识点:</p> 
 <h2>一、Camera 框架介绍：</h2> 
 <p><code>Camera</code>的框架分为<code>Kernel</code>部分和<code>hal</code>部分，其中<code>kernel</code>部分主要有两块：</p> 
 <ul><li><p><code>image sensor driver</code>，负责具体型号的<code>sensor</code>的<code>id</code>检测，上电，以及在<code>preview</code>、<code>capture</code>、<code>初始化</code>、<code>3A</code>等等功能设定时的寄存器配置；</p></li><li><p><code>isp driver</code>，通过<code>DMA</code>将<code>sensor</code>数据流上传；</p></li></ul> 
 <p><code>HAL</code>层部分主要有三部分组成：</p> 
 <ul><li><p><code>imageio</code>，主要负责数据<code>buffer</code>上传的<code>pipe</code>；</p></li><li><p><code>drv</code>，包含<code>imgsensor</code>和<code>isp</code>的<code>hal</code>层控制；</p></li><li><p><code>feature io</code>，包含各种<code>3A</code>等性能配置；</p></li></ul> 
 <p>这篇内容主要介绍开机过程中<code>search sensor</code>以及上电流程等内容。</p> 
 <h2>二、Camera 启动流程</h2> 
 <p>1、<code>CameraService</code>是在开机时启动的，启动后进行<code>searchSensor</code>的操作，会<code>search</code>系统有多少<code>camera</code>，开机时的<code>search</code>操作，只进行<code>camera</code>支持数量的遍历，以及<code>sensor ID</code>的读取操作，如下是<code>hal</code>部分的<code>ASTAH</code>绘制调用流程图，对应的接口的文件路径：</p> 
 <ul><li><p>HalSensorList：<br><code>vendor/mediatek/proprietary/hardware/mtkcam/drv/src/sensor/common/v1/HalSensorList.enumList.cpp</code><br><code>vendor/mediatek/proprietary/hardware/mtkcam/drv/src/sensor/common/v1/HalSensorList.cpp</code></p></li><li><p>SeninfDrv：<br><code>vendor/mediatek/proprietary/hardware/mtkcam/drv/src/sensor/mt6765/seninf_drv.cpp</code></p></li><li><p>SensorDrv：<br><code>vendor/mediatek/proprietary/hardware/mtkcam/drv/src/sensor/common/v1/imgsensor_drv.cpp</code></p></li></ul> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/41/ab/dw4tVEMj_o.png"></p> 
 <p>(1) 这里先看<code>enumerateSensor_Locked</code>完成的工作，直接看代码：</p> 
 <pre class="has"><code class="language-go">MUINT HalSensorList::searchSensors()
{
    Mutex::Autolock _l(mEnumSensorMutex);
    MY_LOGD("searchSensors");
    return  enumerateSensor_Locked();
}

MUINT HalSensorList::enumerateSensor_Locked()
{
    SensorDrv *const pSensorDrv = SensorDrv::get();
    SeninfDrv *const pSeninfDrv = SeninfDrv::createInstance();
    //初始化seninf,配置ISP相关内容
    pSeninfDrv-&gt;init();

    //将所有的clk全部打开
    pSeninfDrv-&gt;setAllMclkOnOff(ISP_DRIVING_8MA, TRUE);

    pSensorDrv-&gt;init();
    for (MUINT i = IMGSENSOR_SENSOR_IDX_MIN_NUM; i &lt;= max_index_of_camera; i++) {
        if((ret = pSensorDrv-&gt;searchSensor((IMGSENSOR_SENSOR_IDX)i)) == SENSOR_NO_ERROR){
            //query sensorinfo
           querySensorDrvInfo((IMGSENSOR_SENSOR_IDX)i);
           //fill in metadata
           buildSensorMetadata((IMGSENSOR_SENSOR_IDX)i);
           pSensorInfo = pSensorDrv-&gt;getSensorInfo((IMGSENSOR_SENSOR_IDX)i);
           addAndInitSensorEnumInfo_Locked(
                (IMGSENSOR_SENSOR_IDX)i,
                mapToSensorType(pSensorInfo-&gt;GetType()),
                pSensorInfo-&gt;getDrvMacroName());
        }
    }     
}

</code></pre> 
 <p>(２) 下面主要看下<code>searchSensor</code>的流程，这里有去获取<code>sensorList</code>的内容：</p> 
 <pre class="has"><code class="language-go">MINT32 ImgSensorDrv::searchSensor(IMGSENSOR_SENSOR_IDX sensorIdx)
{
    GetSensorInitFuncList(&amp;pSensorInitFunc);

    featureControl(sensorIdx, SENSOR_FEATURE_SET_DRIVER, (MUINT8 *)&amp;idx, &amp;featureParaLen);

    NSFeature::SensorInfoBase* pSensorInfo = pSensorInitFunc[idx].pSensorInfo;
}

</code></pre> 
 <p><code>GetSensorInitFuncList</code>是获取到配置<code>的sensorList</code>的内容，此<code>sensorList</code>需要与<code>kernel</code>层配置的一致，不一致的话在打开<code>camera</code>时会出现异常：<br>文件位置：<br><code>vendor/mediatek/proprietary/custom/mt6765/hal/imgsensor_src/sensorlist.cpp</code></p> 
 <pre class="has"><code class="language-go">MSDK_SENSOR_INIT_FUNCTION_STRUCT SensorList[] =
{
#if defined(IMX486_MIPI_RAW)
    RAW_INFO(IMX486_SENSOR_ID, SENSOR_DRVNAME_IMX486_MIPI_RAW, CAM_CALGetCalData),
#endif
//.....
}

UINT32 GetSensorInitFuncList(MSDK_SENSOR_INIT_FUNCTION_STRUCT **ppSensorList)
{
    if (NULL == ppSensorList) {
        ALOGE("ERROR: NULL pSensorList\n");
        return MHAL_UNKNOWN_ERROR;
    }
    *ppSensorList = &amp;SensorList[0];
    return MHAL_NO_ERROR;
}

</code></pre> 
 <p>对应的<code>MSDK_SENSOR_INIT_FUNCTION_STRUCT</code>的结构体如下：</p> 
 <pre class="has"><code class="language-go">typedef struct
{
    MUINT32 sensorType;
    MUINT32 SensorId;
    MUINT8  drvname[32];
    NSFeature::SensorInfoBase* pSensorInfo;
    MUINT32 (*getCameraIndexMgr)(CAMERA_DATA_TYPE_ENUM CameraDataType, MVOID *pDataBuf, MUINT32 size);
    MUINT32 (*getCameraCalData)(UINT32* pGetSensorCalData);
} MSDK_SENSOR_INIT_FUNCTION_STRUCT, *PMSDK_SENSOR_INIT_FUNCTION_STRUCT;

</code></pre> 
 <p>(3) <code>featureControl</code>的<code>setDriver</code>流程：<br>文件位置：<br><code>vendor/mediatek/proprietary/hardware/mtkcam/drv/src/sensor/common/v1/imgsensor_drv.cpp</code></p> 
 <pre class="has"><code class="language-go">MINT32  ImgSensorDrv::featureControl(
    IMGSENSOR_SENSOR_IDX sensorIdx,
    ACDK_SENSOR_FEATURE_ENUM FeatureId,
    MUINT8 *pFeaturePara,
    MUINT32 *pFeatureParaLen
)
{
    //结构ACDK_SENSOR_FEATURECONTROL_STRUCT和kernel中一致
    featureCtrl.InvokeCamera = sensorIdx;
    featureCtrl.FeatureId = FeatureId;//SENSOR_FEATURE_SET_DRIVER
    featureCtrl.pFeaturePara = pFeaturePara;
    featureCtrl.pFeatureParaLen = pFeatureParaLen;

    if (ioctl(m_fdSensor, KDIMGSENSORIOC_X_FEATURECONCTROL , &amp;featureCtrl) &lt; 0) {
        LOG_ERR("[featureControl] Err-ctrlCode (%s)", strerror(errno));
        return -errno;
    }

    return SENSOR_NO_ERROR;
}

</code></pre> 
 <h2>三、kernel 启动流程</h2> 
 <p>先来看整体的框架图如下：</p> 
 <p><img src="https://images2.imgbox.com/ed/90/DuhI91ZL_o.png"><br></p> 
 <p>  </p> 
 <h3>1、set clock 设置时钟</h3> 
 <pre class="has"><code class="language-go">static long imgsensor_ioctl(
    struct file *a_pstFile,
    unsigned int a_u4Command,
    unsigned long a_u4Param)
{
    case KDIMGSENSORIOC_X_SET_MCLK_PLL:
        i4RetValue = imgsensor_clk_set(
            &amp;pgimgsensor-&gt;clk,
            (struct ACDK_SENSOR_MCLK_STRUCT *)pBuff);
        break;
        //......
}

int imgsensor_clk_set(
    struct IMGSENSOR_CLK *pclk, struct ACDK_SENSOR_MCLK_STRUCT *pmclk)
{
    if (pmclk-&gt;on) {
        clk_prepare_enable(pclk-&gt;imgsensor_ccf[mclk_index])
        ret = clk_set_parent(
            pclk-&gt;imgsensor_ccf[pmclk-&gt;TG],
            pclk-&gt;imgsensor_ccf[mclk_index]);
    } else {
        clk_disable_unprepare(pclk-&gt;imgsensor_ccf[mclk_index]);
    }
}

</code></pre> 
 <h3>2、set driver</h3> 
 <pre class="has"><code class="language-go">static long imgsensor_ioctl(
    struct file *a_pstFile,
    unsigned int a_u4Command,
    unsigned long a_u4Param) 
{
    case KDIMGSENSORIOC_X_FEATURECONCTROL:
        i4RetValue = adopt_CAMERA_HW_FeatureControl(pBuff);
        break;
        //......
}

static inline int adopt_CAMERA_HW_FeatureControl(void *pBuf)
{
    /* copy from user */
    switch (pFeatureCtrl-&gt;FeatureId) {
        case SENSOR_FEATURE_SET_DRIVER:
        {
            MINT32 drv_idx;

            psensor-&gt;inst.sensor_idx = pFeatureCtrl-&gt;InvokeCamera;
            drv_idx = imgsensor_set_driver(psensor);

            memcpy(pFeaturePara, &amp;drv_idx, FeatureParaLen);
            break;
        }
    }
}

</code></pre> 
 <p>遍历<code>CONFIG_CUSTOM_KERNEL_IMGSENSOR</code>的内容，然后看<code>sensorList</code>是否对应，并获取对应的下标，调用<code>imgsensor_check_is_alive</code>进行上下电并读取ID 的操作：</p> 
 <pre class="has"><code class="language-go">struct IMGSENSOR_INIT_FUNC_LIST kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR] = {
#if defined(XXXXXX_MIPI_RAW)
        {XXXXXX_SENSOR_ID,
        SENSOR_DRVNAME_XXXXXX_MIPI_RAW,
        XXXXXX_MIPI_RAW_SensorInit},
#endif
    //......
}

int imgsensor_set_driver(struct IMGSENSOR_SENSOR *psensor)
{
    struct IMGSENSOR_SENSOR_INST    *psensor_inst = &amp;psensor-&gt;inst;
    struct IMGSENSOR_INIT_FUNC_LIST *pSensorList  = kdSensorList;
    //获取config的size
    char *sensor_configs = STRINGIZE(CONFIG_CUSTOM_KERNEL_IMGSENSOR);
    imgsensor_i2c_init(&amp;psensor_inst-&gt;i2c_cfg,
    imgsensor_custom_config[psensor-&gt;inst.sensor_idx].i2c_dev);

    memcpy(psensor_list_config, sensor_configs+1, strlen(sensor_configs)-2);
    //对应config字符串进行按空格进行拆解
    driver_name = strsep(&amp;psensor_list_config, " \0");

    while (driver_name != NULL) {
        for (j = 0; j &lt; MAX_NUM_OF_SUPPORT_SENSOR; j++) {
            //判断对应的init函数是否存在
            if (pSensorList[j].init == NULL)
                break;
            else if (!strcmp(driver_name, pSensorList[j].name)) {
                //如果在config中和sensorlist中同时有定义进行赋值
                orderedSearchList[i++] = j;
                break;
            }
        }
        driver_name = strsep(&amp;psensor_list_config, " \0");
    }

    for (i = 0; i &lt; MAX_NUM_OF_SUPPORT_SENSOR; i++) {
        //上面获取到的sensorlist的下标
        drv_idx = orderedSearchList[i];
        if (pSensorList[drv_idx].init) {
            //调用对应驱动的init函数
            pSensorList[drv_idx].init(&amp;psensor-&gt;pfunc);
            if (psensor-&gt;pfunc) {
                psensor_inst-&gt;psensor_name =
                    (char *)pSensorList[drv_idx].name;
                    //到这里是重点，进行上电读取ID的操作
                if (!imgsensor_check_is_alive(psensor)) {
                    ret = drv_idx;
                }
            }
        }
    }
}

</code></pre> 
 <p>下面看对应的上下电以及读取<code>ID</code>的操作：</p> 
 <pre class="has"><code class="language-go">static inline int imgsensor_check_is_alive(struct IMGSENSOR_SENSOR *psensor)
{
    struct IMGSENSOR_SENSOR_INST  *psensor_inst = &amp;psensor-&gt;inst;
    //上电
    err = imgsensor_hw_power(&amp;pgimgsensor-&gt;hw,
                psensor,
                psensor_inst-&gt;psensor_name,
                IMGSENSOR_HW_POWER_STATUS_ON);
    //读取ID
    imgsensor_sensor_feature_control(
            psensor,
            SENSOR_FEATURE_CHECK_SENSOR_ID,
            (MUINT8 *)&amp;sensorID,
            &amp;retLen);

    if (sensorID == 0 || sensorID == 0xFFFFFFFF) {
        pr_info("Fail to get sensor ID %x\n", sensorID);
        err = ERROR_SENSOR_CONNECT_FAIL;
    } else {
        pr_info(" Sensor found ID = 0x%x\n", sensorID);
        err = ERROR_NONE;
    }
    //下电
    imgsensor_hw_power(&amp;pgimgsensor-&gt;hw,
        psensor,
        psensor_inst-&gt;psensor_name,
        IMGSENSOR_HW_POWER_STATUS_OFF);

    return err ? -EIO:err;
}

</code></pre> 
 <h3>3、上电相关</h3> 
 <p>上电时序配置：</p> 
 <pre class="has"><code class="language-go">struct IMGSENSOR_HW_POWER_INFO {
    enum IMGSENSOR_HW_PIN       pin;
    enum IMGSENSOR_HW_PIN_STATE pin_state_on;
    u32  pin_on_delay;
    enum IMGSENSOR_HW_PIN_STATE pin_state_off;
    u32  pin_off_delay;
};

struct IMGSENSOR_HW_POWER_SEQ sensor_power_sequence[] = {
    //……
    #if defined(XXXXXX_MIPI_RAW)
        {
            SENSOR_DRVNAME_XXXXXX_MIPI_RAW,
            {
                {RST, Vol_Low, 0},
                {DVDD, Vol_1100, 1},
                {AVDD, Vol_2800, 1},
                {DOVDD, Vol_1800, 1},
                {RST, Vol_High, 1},
                {SensorMCLK, Vol_High, 0},
            },
        },
    #endif
}

</code></pre> 
 <p>对应的控制的流程如下：</p> 
 <pre class="has"><code class="language-go">static enum IMGSENSOR_RETURN imgsensor_hw_power_sequence(
    struct IMGSENSOR_HW             *phw,
    enum   IMGSENSOR_SENSOR_IDX      sensor_idx,
    enum   IMGSENSOR_HW_POWER_STATUS pwr_status,
    struct IMGSENSOR_HW_POWER_SEQ   *ppower_sequence,
    char *pcurr_idx)
{
    ppwr_info = ppwr_seq-&gt;pwr_info;
    // 上电
    while (ppwr_info-&gt;pin != IMGSENSOR_HW_PIN_NONE &amp;&amp;
        ppwr_info &lt; ppwr_seq-&gt;pwr_info + IMGSENSOR_HW_POWER_INFO_MAX) {

        if (pwr_status == IMGSENSOR_HW_POWER_STATUS_ON &amp;&amp;
           ppwr_info-&gt;pin != IMGSENSOR_HW_PIN_UNDEF) {
            pdev = phw-&gt;pdev[psensor_pwr-&gt;id[ppwr_info-&gt;pin]];
            if (pdev-&gt;set != NULL)
                //调用GPIO或者regulator的set 电压操作，这里的pdev在imgsensor_probe中已经设置
                pdev-&gt;set( 
                    pdev-&gt;pinstance,
                    sensor_idx,
                    ppwr_info-&gt;pin,
                    ppwr_info-&gt;pin_state_on);

            mdelay(ppwr_info-&gt;pin_on_delay);
        }
        // 从上到下依次上电
        ppwr_info++;
        pin_cnt++;
    }

    // 下电操作
    if (pwr_status == IMGSENSOR_HW_POWER_STATUS_OFF) {
        while (pin_cnt) {
            //从下到上依次下电
            ppwr_info--;
            pin_cnt--;

            if (ppwr_info-&gt;pin != IMGSENSOR_HW_PIN_UNDEF) {
                pdev =
                    phw-&gt;pdev[psensor_pwr-&gt;id[ppwr_info-&gt;pin]];
                mdelay(ppwr_info-&gt;pin_on_delay);

                if (pdev-&gt;set != NULL)
                    pdev-&gt;set(
                        pdev-&gt;pinstance,
                        sensor_idx,
                        ppwr_info-&gt;pin,
                        ppwr_info-&gt;pin_state_off);
            }
        }
    }

    /* wait for power stable */
    if (pwr_status == IMGSENSOR_HW_POWER_STATUS_ON)
        mdelay(5);
    return IMGSENSOR_RETURN_SUCCESS;
}

</code></pre> 
 <h2>四、总结</h2> 
 <p>通过上面的代码流程，可以知道上开机时，<code>camera</code>模块先会将所有的<code>MCLK</code>打开，然后对依次对对应的<code>sensor</code>进行上电，读取<code>ID</code>(判断<code>I2C</code>是否正常通讯)。这部分调试过程中遇到的问题总结如下：</p> 
 <h3>1、ID读取不到，I2C不通</h3> 
 <ul><li><p>检查上电时序，３项电压（<code>AVDD/DVDD/IOVDD</code>）是否正确；</p></li><li><p><code>I2C</code>地址及通道设置是否正确；</p></li><li><p>检查<code>cfg_setting_imgsensor.cpp</code>中<code>MCLK</code>和<code>HW</code>链接配置是否正确；</p></li></ul> 
 <h3>2、Camera 启动时间过长</h3> 
 <ul><li><p>检查<code>Sensor</code>上电时序要求的延时，是否有偏长的情况；</p></li><li><p>去掉多余的<code>I2C</code>地址，因为大部分驱动会多添加一些地址；</p></li><li><p><code>OTP</code>的加载调整到每次开机时第一次打开加载，之后不加载；</p></li><li><p><code>sensorInit</code>如果时间过长，可以调节<code>I2C speed(400-&gt;1000)</code>；</p></li></ul> 
 <h3>3、preview 阶段耗时</h3> 
 <ul><li><p>检查<code>streamOn/Off</code>的耗时；</p></li><li><p><code>preview_init</code>是否有较长时间的耗时</p></li><li><p>以及延时操作使用<code>mdelay</code>代替<code>msleep</code>；</p></li><li><p><code>pre_delay_frame/cap_delay_frame</code>丢帧操作是否合适；</p></li></ul> 
 <h3>4、低电流、功耗相关问题</h3> 
 <ul><li><p>检查电压是否都有下电成功，防止漏电；</p></li><li><p>对于共<code>pin</code>的<code>sensor</code>，在操作时是否有做好<code>workaround</code>；</p></li><li><p>将<code>I2C</code>寄存器单个读写，调整为连续读写的方式也有一定优化；</p></li><li><p><code>sensor</code>的<code>PIN</code>是否有被其他模块占用，异常操作的行为；</p></li></ul> 
 <p><strong>友情推荐：</strong></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzU4MTIzMjM3MA%3D%3D&amp;chksm=fd4be17bca3c686de751bdb16b9f2d5f4b1b349cb41aab5e907d24f50e73a74096ace8219b12&amp;idx=1&amp;mid=2247488230&amp;scene=21&amp;sn=6c70d9a7296e4a24ab81c0afeada65fb#wechat_redirect" rel="nofollow">Android 开发干货集锦</a></p> 
 <p>至此，本篇已结束。转载网络的文章，小编觉得很优秀，欢迎点击阅读原文，支持原创作者，如有侵权，恳请联系小编删除，欢迎您的建议与指正。同时期待您的关注，感谢您的阅读，谢谢！</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/b4/64/kUm9GG3C_o.png"></p> 
 <p style="text-align: right"><em>点个在看，方便您使用时快速查找！</em></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1efb4ebaf2b06a6dc4f95a3ba098e57c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">php通过js加载数据,ajax实现加载数据的步骤详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6597b1516d96096611e5c22c6402d06/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">php扩展配置动态链接库加载~,Linux下如何安装PHP扩展模块？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>