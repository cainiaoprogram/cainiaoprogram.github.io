<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>go源码阅读——malloc.go - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="go源码阅读——malloc.go" />
<meta property="og:description" content="【博文目录&gt;&gt;&gt;】 【项目地址&gt;&gt;&gt;】 内存分配器 golang内存分配最初是基于tcmalloc的，但是有很大的不同。tcmalloc文章：
参见：http://goog-perftools.sourceforge.net/doc/tcmalloc.html
翻译：https://blog.csdn.net/DERRANTCM/article/details/105342996
主分配器在大量页（runs of pages）中工作。将较小的分配大小（最大为32 kB，包括32 kB）舍入为大约70个大小类别之一，每个类别都有其自己的大小完全相同的空闲对象集。任何空闲的内存页都可以拆分为一个大小类别的对象集，然后使用空闲位图（free bitmap）进行管理。
分配器的数据结构为： fixalloc：用于固定大小的堆外对象的空闲列表分配器，用于管理分配器使用的存储。
mheap：malloc堆，以页（8192字节）粒度进行管理。
mspan：由mheap管理的一系列使用中的页面。
mcentral：收集给定大小类的所有跨度。
mcache：具有可用空间的mspans的每P个缓存。
mstats：分配统计信息。
分配一个小对象沿用了高速缓存的层次结构： 1、将大小四舍五入为一个较小的类别，然后在此P的mcache中查看相应的mspan。扫描mspan的空闲位图以找到空闲位置（slot）。如果有空闲位置，分配它。这都可以在不获取锁的情况下完成。2、如果mspan没有可用位置，则从mcentral的具有可用空间的所需size类的mspan列表中获取一个新的mspan。获得整个跨度（span）会摊销锁定mcentral的成本。3、如果mcentral的mspan列表为空，从mheap获取一系列页以用于mspan。4、如果mheap为空或没有足够大的页，则从操作系统中分配一组新的页（至少1MB）。分配大量页面将分摊与操作系统进行对话的成本。 清除mspan并释放对象沿用了类似的层次结构： 1、如果响应分配而清除了mspan，则将mspan返还到mcache以满足分配。2、否则，如果mspan仍有已分配的对象，则将其放在mspan的size类别的mcentral空闲列表上。3、否则，如果mspan中的所有对象都是空闲的，则mspan的页面将返回到mheap，并且mspan现在已失效。 分配和释放大对象直接使用mheap，而绕过mcache和mcentral。如果mspan.needzero为false，则mspan中的可用对象位置已被清零。否则，如果needzero为true，则在分配对象时将其清零。通过这种方式延迟归零有很多好处：
1、堆栈帧分配可以完全避免置零。2、它具有更好的时间局部性，因为该程序可能即将写入内存。3、我们不会将永远不会被重用的页面归零。 虚拟内存布局 堆由一组arena组成，这些arena在64位上为64MB，在32位（heapArenaBytes）上为4MB。每个arena的起始地址也与arena大小对齐。
每个arena都有一个关联的heapArena对象，该对象存储该arena的元数据：arena中所有字（word）的堆位图和arena中所有页的跨度（span）图。它们本身是堆外分配的。
由于arena是对齐的，因此可以将地址空间视为一系列arena帧（frame）。arena映射（mheap_.arenas）从arena帧号映射到*heapArena，对于不由Go堆支持的部分地址空间，映射为nil。arena映射的结构为两层数组，由“L1”arena映射和许多“ L2”arena映射组成；但是，由于arena很大，因此在许多体系结构上，arena映射都由一个大型L2映射组成。
arena地图覆盖了整个可用的地址空间，从而允许Go堆使用地址空间的任何部分。分配器尝试使arena保持连续，以便大跨度（以及大对象）可以跨越arena。
OS内存管理抽象层 在任何给定时间，运行时管理的地址空间区域可能处于四种状态之一：
1）无（None）——未保留和未映射，这是任何区域的默认状态。2）保留（Reserved）——运行时拥有，但是访问它会导致故障。不计入进程的内存占用。3）已准备（Prepared）——保留，意在不由物理内存支持（尽管OS可能会延迟实现）。可以有效过渡到就绪。在这样的区域中访问内存是不确定的（可能会出错，可能会返回意外的零等）。4）就绪（Ready）——可以安全地访问。 这组状态对于支持所有当前受支持的平台而言绝对不是必需的。只需一个“无”，“保留”和“就绪”就可以解决问题。但是，“已准备”状态为我们提供了用于性能目的的灵活性。例如，在POSIX-y操作系统上，“保留”通常是设置了PROT_NONE的私有匿名mmap’d区域，要转换到“就绪”状态，需要设置PROT_READ | PROT_WRITE。但是，Prepared的规格不足使我们仅使用MADV_FREE从Ready过渡到Prepared。因此，在“准备好”状态下，我们可以提早设置一次权限位，我们可以有效地告诉操作系统，当我们严格不需要它们时，可以自由地将页面从我们手中夺走。
对于每个操作系统，都有一组通用的帮助程序，这些帮助程序在这些状态之间转换内存区域。帮助程序如下：
sysAlloc sysAlloc将OS选择的内存区域从“无”转换为“就绪”。更具体地说，它从操作系统中获取大量的零位内存，通常大约为一百千字节或兆字节。该内存始终可以立即使用。
sysFree sysFree将内存区域从任何状态转换为“无（Ready）”。因此，它无条件返回内存。如果在分配过程中检测到内存不足错误，或用于划分出地址空间的对齐部分，则使用此方法。仅当sysReserve始终返回与堆分配器的对齐限制对齐的内存区域时，如果sysFree是无操作的，这是可以的。
sysReserve sysReserve将内存区域从“无（None）”转换为“保留（Reserved）”。它以这样一种方式保留地址空间，即在访问时（通过权限或未提交内存）会导致致命错误。因此，这种保留永远不会受到物理内存的支持。如果传递给它的指针为非nil，则调用者希望在那里保留，但是sysReserve仍然可以选择另一个位置（如果该位置不可用）。
注意：sysReserve返回OS对齐的内存，但是堆分配器可能使用更大的对齐方式，因此调用者必须小心地重新对齐sysReserve获得的内存。
sysMap sysMap将内存区域从“保留（Reserved）”状态转换为“已准备（Prepared）”状态。它确保可以将存储区域有效地转换为“就绪（Ready）”。
sysUsed sysUsed将内存区域从“已准备（Prepared）”过渡到“就绪（Ready）”。它通知操作系统需要内存区域，并确保可以安全地访问该区域。在没有明确的提交步骤和严格的过量提交限制的系统上，这通常是不操作的，例如，在Windows上至关重要。
sysUnused sysUnused将内存区域从“就绪（Ready）”转换为“已准备（Prepared）”。它通知操作系统，不再需要支持该内存区域的物理页，并且可以将其重新用于其他目的。 sysUnused内存区域的内容被认为是没用的，在调用sysUsed之前，不得再次访问该区域。
sysFault sysFault将内存区域从“就绪（Ready）”或“已准备（Prepared）”转换为“保留（Reserved）”。它标记了一个区域，以便在访问时总是会发生故障。仅用于调试运行时。
状态转换图 hint的选择 64位机器 在64位计算机上，我们选择以下hit因为：
1、从地址空间的中间开始，可以轻松扩展到连续范围，而无需运行其他映射。2、这使Go堆地址在调试时更容易识别。3、gccgo中的堆栈扫描仍然很保守，因此将地址与其他数据区分开很重要。 从0x00c0开始意味着有效的内存地址将从0x00c0、0x00c1 … n 小端开始，即c0 00，c1 00，…这些都不是有效的UTF-8序列，否则它们是尽可能远离ff（可能是一个公共字节）。如果失败，我们尝试其他0xXXc0地址。较早的尝试使用0x11f8导致线程分配期间OS X上的内存不足错误。 0x00c0导致与AddressSanitizer发生冲突，后者保留了最多0x0100的所有内存。这些选择减少了保守的垃圾收集器不收集内存的可能性，因为某些非指针内存块具有与内存地址匹配的位模式。
但是，在arm64上，我们忽略了上面的所有建议，并在0x40 &lt;&lt; 32处分配，因为当使用具有3级转换缓冲区的4k页面时，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5624c8eb8839a0f99b834436a1841f4a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-13T08:07:32+08:00" />
<meta property="article:modified_time" content="2020-04-13T08:07:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">go源码阅读——malloc.go</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="httpblogcsdnnetderrantcmarticledetails73456550_httpsgithubcomWangJunChaogosourceread_0"></a><a href="http://blog.csdn.net/derrantcm/article/details/73456550">【博文目录&gt;&gt;&gt;】</a> <a href="https://github.com/Wang-Jun-Chao/go-source-read">【项目地址&gt;&gt;&gt;】</a></h2> 
<hr> 
<h2><a id="_2"></a>内存分配器</h2> 
<p>golang内存分配最初是基于tcmalloc的，但是有很大的不同。tcmalloc文章：<br> 参见：http://goog-perftools.sourceforge.net/doc/tcmalloc.html<br> 翻译：https://blog.csdn.net/DERRANTCM/article/details/105342996</p> 
<p>主分配器在大量页（runs of pages）中工作。将较小的分配大小（最大为32 kB，包括32 kB）舍入为大约70个大小类别之一，每个类别都有其自己的大小完全相同的空闲对象集。任何空闲的内存页都可以拆分为一个大小类别的对象集，然后使用空闲位图（free bitmap）进行管理。</p> 
<h3><a id="_10"></a>分配器的数据结构为：</h3> 
<p>fixalloc：用于固定大小的堆外对象的空闲列表分配器，用于管理分配器使用的存储。<br> mheap：malloc堆，以页（8192字节）粒度进行管理。<br> mspan：由mheap管理的一系列使用中的页面。<br> mcentral：收集给定大小类的所有跨度。<br> mcache：具有可用空间的mspans的每P个缓存。<br> mstats：分配统计信息。</p> 
<h3><a id="_19"></a>分配一个小对象沿用了高速缓存的层次结构：</h3> 
<ul><li>1、将大小四舍五入为一个较小的类别，然后在此P的mcache中查看相应的mspan。扫描mspan的空闲位图以找到空闲位置（slot）。如果有空闲位置，分配它。这都可以在不获取锁的情况下完成。</li><li>2、如果mspan没有可用位置，则从mcentral的具有可用空间的所需size类的mspan列表中获取一个新的mspan。获得整个跨度（span）会摊销锁定mcentral的成本。</li><li>3、如果mcentral的mspan列表为空，从mheap获取一系列页以用于mspan。</li><li>4、如果mheap为空或没有足够大的页，则从操作系统中分配一组新的页（至少1MB）。分配大量页面将分摊与操作系统进行对话的成本。</li></ul> 
<h3><a id="mspan_26"></a>清除mspan并释放对象沿用了类似的层次结构：</h3> 
<ul><li>1、如果响应分配而清除了mspan，则将mspan返还到mcache以满足分配。</li><li>2、否则，如果mspan仍有已分配的对象，则将其放在mspan的size类别的mcentral空闲列表上。</li><li>3、否则，如果mspan中的所有对象都是空闲的，则mspan的页面将返回到mheap，并且mspan现在已失效。</li></ul> 
<p>分配和释放大对象直接使用mheap，而绕过mcache和mcentral。如果mspan.needzero为false，则mspan中的可用对象位置已被清零。否则，如果needzero为true，则在分配对象时将其清零。通过这种方式延迟归零有很多好处：</p> 
<ul><li>1、堆栈帧分配可以完全避免置零。</li><li>2、它具有更好的时间局部性，因为该程序可能即将写入内存。</li><li>3、我们不会将永远不会被重用的页面归零。</li></ul> 
<h3><a id="_38"></a>虚拟内存布局</h3> 
<p>堆由一组arena组成，这些arena在64位上为64MB，在32位（heapArenaBytes）上为4MB。每个arena的起始地址也与arena大小对齐。<br> 每个arena都有一个关联的heapArena对象，该对象存储该arena的元数据：arena中所有字（word）的堆位图和arena中所有页的跨度（span）图。它们本身是堆外分配的。<br> 由于arena是对齐的，因此可以将地址空间视为一系列arena帧（frame）。arena映射（mheap_.arenas）从arena帧号映射到*heapArena，对于不由Go堆支持的部分地址空间，映射为nil。arena映射的结构为两层数组，由“L1”arena映射和许多“ L2”arena映射组成；但是，由于arena很大，因此在许多体系结构上，arena映射都由一个大型L2映射组成。<br> arena地图覆盖了整个可用的地址空间，从而允许Go堆使用地址空间的任何部分。分配器尝试使arena保持连续，以便大跨度（以及大对象）可以跨越arena。</p> 
<h2><a id="OS_46"></a>OS内存管理抽象层</h2> 
<p>在任何给定时间，运行时管理的地址空间区域可能处于四种状态之一：</p> 
<ul><li>1）<strong>无（None）</strong>——未保留和未映射，这是任何区域的默认状态。</li><li>2）<strong>保留（Reserved）</strong>——运行时拥有，但是访问它会导致故障。不计入进程的内存占用。</li><li>3）<strong>已准备（Prepared）</strong>——保留，意在不由物理内存支持（尽管OS可能会延迟实现）。可以有效过渡到就绪。在这样的区域中访问内存是不确定的（可能会出错，可能会返回意外的零等）。</li><li>4）<strong>就绪（Ready）</strong>——可以安全地访问。</li></ul> 
<p>这组状态对于支持所有当前受支持的平台而言绝对不是必需的。只需一个“无”，“保留”和“就绪”就可以解决问题。但是，“已准备”状态为我们提供了用于性能目的的灵活性。例如，在POSIX-y操作系统上，“保留”通常是设置了PROT_NONE的私有匿名mmap’d区域，要转换到“就绪”状态，需要设置PROT_READ | PROT_WRITE。但是，Prepared的规格不足使我们仅使用MADV_FREE从Ready过渡到Prepared。因此，在“准备好”状态下，我们可以提早设置一次权限位，我们可以有效地告诉操作系统，当我们严格不需要它们时，可以自由地将页面从我们手中夺走。</p> 
<p>对于每个操作系统，都有一组通用的帮助程序，这些帮助程序在这些状态之间转换内存区域。帮助程序如下：</p> 
<h3><a id="sysAlloc_58"></a>sysAlloc</h3> 
<p>sysAlloc将OS选择的内存区域从“无”转换为“就绪”。更具体地说，它从操作系统中获取大量的零位内存，通常大约为一百千字节或兆字节。该内存始终可以立即使用。</p> 
<h3><a id="sysFree_61"></a>sysFree</h3> 
<p>sysFree将内存区域从任何状态转换为“无（Ready）”。因此，它无条件返回内存。如果在分配过程中检测到内存不足错误，或用于划分出地址空间的对齐部分，则使用此方法。仅当sysReserve始终返回与堆分配器的对齐限制对齐的内存区域时，如果sysFree是无操作的，这是可以的。</p> 
<h3><a id="sysReserve_64"></a>sysReserve</h3> 
<p>sysReserve将内存区域从“无（None）”转换为“保留（Reserved）”。它以这样一种方式保留地址空间，即在访问时（通过权限或未提交内存）会导致致命错误。因此，这种保留永远不会受到物理内存的支持。如果传递给它的指针为非nil，则调用者希望在那里保留，但是sysReserve仍然可以选择另一个位置（如果该位置不可用）。</p> 
<blockquote> 
 <p>注意：sysReserve返回OS对齐的内存，但是堆分配器可能使用更大的对齐方式，因此调用者必须小心地重新对齐sysReserve获得的内存。</p> 
</blockquote> 
<h3><a id="sysMap_69"></a>sysMap</h3> 
<p>sysMap将内存区域从“保留（Reserved）”状态转换为“已准备（Prepared）”状态。它确保可以将存储区域有效地转换为“就绪（Ready）”。</p> 
<h3><a id="sysUsed_72"></a>sysUsed</h3> 
<p>sysUsed将内存区域从“已准备（Prepared）”过渡到“就绪（Ready）”。它通知操作系统需要内存区域，并确保可以安全地访问该区域。在没有明确的提交步骤和严格的过量提交限制的系统上，这通常是不操作的，例如，在Windows上至关重要。</p> 
<h3><a id="sysUnused_75"></a>sysUnused</h3> 
<p>sysUnused将内存区域从“就绪（Ready）”转换为“已准备（Prepared）”。它通知操作系统，不再需要支持该内存区域的物理页，并且可以将其重新用于其他目的。 sysUnused内存区域的内容被认为是没用的，在调用sysUsed之前，不得再次访问该区域。</p> 
<h3><a id="sysFault_78"></a>sysFault</h3> 
<p>sysFault将内存区域从“就绪（Ready）”或“已准备（Prepared）”转换为“保留（Reserved）”。它标记了一个区域，以便在访问时总是会发生故障。仅用于调试运行时。</p> 
<h3><a id="_81"></a>状态转换图</h3> 
<p><img src="https://images2.imgbox.com/72/d4/vZQhJ8mz_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="hint_84"></a>hint的选择</h3> 
<h4><a id="64_85"></a>64位机器</h4> 
<p>在64位计算机上，我们选择以下hit因为：</p> 
<ul><li>1、从地址空间的中间开始，可以轻松扩展到连续范围，而无需运行其他映射。</li><li>2、这使Go堆地址在调试时更容易识别。</li><li>3、gccgo中的堆栈扫描仍然很保守，因此将地址与其他数据区分开很重要。</li></ul> 
<p>从0x00c0开始意味着有效的内存地址将从0x00c0、0x00c1 … n 小端开始，即c0 00，c1 00，…这些都不是有效的UTF-8序列，否则它们是尽可能远离ff（可能是一个公共字节）。如果失败，我们尝试其他0xXXc0地址。较早的尝试使用0x11f8导致线程分配期间OS X上的内存不足错误。 0x00c0导致与AddressSanitizer发生冲突，后者保留了最多0x0100的所有内存。这些选择减少了保守的垃圾收集器不收集内存的可能性，因为某些非指针内存块具有与内存地址匹配的位模式。</p> 
<p>但是，在arm64上，我们忽略了上面的所有建议，并在0x40 &lt;&lt; 32处分配，因为当使用具有3级转换缓冲区的4k页面时，<br> 用户地址空间在darwin/arm64上被限制为39位，地址空间更小。</p> 
<p>在AIX上，对于64位，mmaps从0x0A00000000000000开始。</p> 
<h4><a id="32_98"></a>32位机器</h4> 
<p>在32位计算机上，我们更加关注保持可用堆是连续的。<br> 因此：</p> 
<ul><li>1、我们为所有的heapArena保留空间，这样它们就不会与heap交错。 它们约为258MB，因此还算不错。（如果出现问题，我们可以在前面预留较小的空间。）</li><li>2、我们建议堆从二进制文件的末尾开始，因此我们有最大的机会保持其连续性。</li><li>3、我们尝试放出一个相当大的初始堆保留。</li></ul> 
<h3><a id="_106"></a>一些常量</h3> 
<ul><li>var zerobase uintptr：所有0字节分配的基地址</li></ul> 
<h2><a id="_109"></a>源码</h2> 
<pre><code class="prism language-go"><span class="token comment">// Memory allocator.</span>
<span class="token comment">//</span>
<span class="token comment">// This was originally based on tcmalloc, but has diverged quite a bit.</span>
<span class="token comment">// http://goog-perftools.sourceforge.net/doc/tcmalloc.html</span>

<span class="token comment">// The main allocator works in runs of pages.</span>
<span class="token comment">// Small allocation sizes (up to and including 32 kB) are</span>
<span class="token comment">// rounded to one of about 70 size classes, each of which</span>
<span class="token comment">// has its own free set of objects of exactly that size.</span>
<span class="token comment">// Any free page of memory can be split into a set of objects</span>
<span class="token comment">// of one size class, which are then managed using a free bitmap.</span>
<span class="token comment">//</span>
<span class="token comment">// The allocator's data structures are:</span>
<span class="token comment">//</span>
<span class="token comment">//    fixalloc: a free-list allocator for fixed-size off-heap objects,</span>
<span class="token comment">//        used to manage storage used by the allocator.</span>
<span class="token comment">//    mheap: the malloc heap, managed at page (8192-byte) granularity.</span>
<span class="token comment">//    mspan: a run of in-use pages managed by the mheap.</span>
<span class="token comment">//    mcentral: collects all spans of a given size class.</span>
<span class="token comment">//    mcache: a per-P cache of mspans with free space.</span>
<span class="token comment">//    mstats: allocation statistics.</span>
<span class="token comment">//</span>
<span class="token comment">// Allocating a small object proceeds up a hierarchy of caches:</span>
<span class="token comment">//</span>
<span class="token comment">//    1. Round the size up to one of the small size classes</span>
<span class="token comment">//       and look in the corresponding mspan in this P's mcache.</span>
<span class="token comment">//       Scan the mspan's free bitmap to find a free slot.</span>
<span class="token comment">//       If there is a free slot, allocate it.</span>
<span class="token comment">//       This can all be done without acquiring a lock.</span>
<span class="token comment">//</span>
<span class="token comment">//    2. If the mspan has no free slots, obtain a new mspan</span>
<span class="token comment">//       from the mcentral's list of mspans of the required size</span>
<span class="token comment">//       class that have free space.</span>
<span class="token comment">//       Obtaining a whole span amortizes the cost of locking</span>
<span class="token comment">//       the mcentral.</span>
<span class="token comment">//</span>
<span class="token comment">//    3. If the mcentral's mspan list is empty, obtain a run</span>
<span class="token comment">//       of pages from the mheap to use for the mspan.</span>
<span class="token comment">//</span>
<span class="token comment">//    4. If the mheap is empty or has no page runs large enough,</span>
<span class="token comment">//       allocate a new group of pages (at least 1MB) from the</span>
<span class="token comment">//       operating system. Allocating a large run of pages</span>
<span class="token comment">//       amortizes the cost of talking to the operating system.</span>
<span class="token comment">//</span>
<span class="token comment">// Sweeping an mspan and freeing objects on it proceeds up a similar</span>
<span class="token comment">// hierarchy:</span>
<span class="token comment">//</span>
<span class="token comment">//    1. If the mspan is being swept in response to allocation, it</span>
<span class="token comment">//       is returned to the mcache to satisfy the allocation.</span>
<span class="token comment">//</span>
<span class="token comment">//    2. Otherwise, if the mspan still has allocated objects in it,</span>
<span class="token comment">//       it is placed on the mcentral free list for the mspan's size</span>
<span class="token comment">//       class.</span>
<span class="token comment">//</span>
<span class="token comment">//    3. Otherwise, if all objects in the mspan are free, the mspan's</span>
<span class="token comment">//       pages are returned to the mheap and the mspan is now dead.</span>
<span class="token comment">//</span>
<span class="token comment">// Allocating and freeing a large object uses the mheap</span>
<span class="token comment">// directly, bypassing the mcache and mcentral.</span>
<span class="token comment">//</span>
<span class="token comment">// If mspan.needzero is false, then free object slots in the mspan are</span>
<span class="token comment">// already zeroed. Otherwise if needzero is true, objects are zeroed as</span>
<span class="token comment">// they are allocated. There are various benefits to delaying zeroing</span>
<span class="token comment">// this way:</span>
<span class="token comment">//</span>
<span class="token comment">//    1. Stack frame allocation can avoid zeroing altogether.</span>
<span class="token comment">//</span>
<span class="token comment">//    2. It exhibits better temporal locality, since the program is</span>
<span class="token comment">//       probably about to write to the memory.</span>
<span class="token comment">//</span>
<span class="token comment">//    3. We don't zero pages that never get reused.</span>

<span class="token comment">// Virtual memory layout</span>
<span class="token comment">//</span>
<span class="token comment">// The heap consists of a set of arenas, which are 64MB on 64-bit and</span>
<span class="token comment">// 4MB on 32-bit (heapArenaBytes). Each arena's start address is also</span>
<span class="token comment">// aligned to the arena size.</span>
<span class="token comment">//</span>
<span class="token comment">// Each arena has an associated heapArena object that stores the</span>
<span class="token comment">// metadata for that arena: the heap bitmap for all words in the arena</span>
<span class="token comment">// and the span map for all pages in the arena. heapArena objects are</span>
<span class="token comment">// themselves allocated off-heap.</span>
<span class="token comment">//</span>
<span class="token comment">// Since arenas are aligned, the address space can be viewed as a</span>
<span class="token comment">// series of arena frames. The arena map (mheap_.arenas) maps from</span>
<span class="token comment">// arena frame number to *heapArena, or nil for parts of the address</span>
<span class="token comment">// space not backed by the Go heap. The arena map is structured as a</span>
<span class="token comment">// two-level array consisting of a "L1" arena map and many "L2" arena</span>
<span class="token comment">// maps; however, since arenas are large, on many architectures, the</span>
<span class="token comment">// arena map consists of a single, large L2 map.</span>
<span class="token comment">//</span>
<span class="token comment">// The arena map covers the entire possible address space, allowing</span>
<span class="token comment">// the Go heap to use any part of the address space. The allocator</span>
<span class="token comment">// attempts to keep arenas contiguous so that large spans (and hence</span>
<span class="token comment">// large objects) can cross arenas.</span>
<span class="token comment">/**
 * 内存分配器
 *
 * 这最初是基于tcmalloc的，但是有很大的不同。
 * 参见：http://goog-perftools.sourceforge.net/doc/tcmalloc.html
 * 翻译：https://blog.csdn.net/DERRANTCM/article/details/105342996
 *
 * 主分配器在大量页（runs of pages）中工作。
 * 将较小的分配大小（最大为32 kB，包括32 kB）舍入为大约70个大小类别之一，每个类别都有其自己的大小完全相同的空闲对象集。
 * 任何空闲的内存页都可以拆分为一个大小类别的对象集，然后使用空闲位图（free bitmap）进行管理。
 *
 * 分配器的数据结构为：
 *
 * fixalloc：用于固定大小的堆外对象的空闲列表分配器，用于管理分配器使用的存储。
 * mheap：malloc堆，以页（8192字节）粒度进行管理。
 * mspan：由mheap管理的一系列使用中的页面。
 * mcentral：收集给定大小类的所有跨度。
 * mcache：具有可用空间的mspans的每P个缓存。
 * mstats：分配统计信息。
 *
 * 分配一个小对象沿用了高速缓存的层次结构：
 *
 * 1.将大小四舍五入为一个较小的类别，然后在此P的mcache中查看相应的mspan。
 * 扫描mspan的空闲位图以找到空闲位置（slot）。如果有空闲位置，分配它。这都可以在不获取锁的情况下完成。
 *
 * 2.如果mspan没有可用位置，则从mcentral的具有可用空间的所需size类的mspan列表中获取一个新的mspan。
 * 获得整个跨度（span）会摊销锁定mcentral的成本。
 *
 * 3.如果mcentral的mspan列表为空，从mheap获取一系列页以用于mspan。
 *
 * 4.如果mheap为空或没有足够大的页，则从操作系统中分配一组新的页（至少1MB）。
 * 分配大量页面将分摊与操作系统进行对话的成本。
 *
 * 清除mspan并释放对象沿用了类似的层次结构：
 *
 * 1.如果响应分配而清除了mspan，则将mspan返还到mcache以满足分配。
 *
 * 2.否则，如果mspan仍有已分配的对象，则将其放在mspan的size类别的mcentral空闲列表上。
 *
 * 3.否则，如果mspan中的所有对象都是空闲的，则mspan的页面将返回到mheap，并且mspan现在已失效。
 *
 * 分配和释放大对象直接使用mheap，而绕过mcache和mcentral。
 *
 * 如果mspan.needzero为false，则mspan中的可用对象位置已被清零。否则，如果needzero为true，
 * 则在分配对象时将其清零。通过这种方式延迟归零有很多好处：
 *
 * 1.堆栈帧分配可以完全避免置零。
 *
 * 2.它具有更好的时间局部性，因为该程序可能即将写入内存。
 *
 * 3.我们不会将永远不会被重用的页面归零。
 *
 * 虚拟内存布局
 *
 * 堆由一组arena组成，这些arena在64位上为64MB，在32位（heapArenaBytes）上为4MB。
 * 每个arena的起始地址也与arena大小对齐。
 *
 * 每个arena都有一个关联的heapArena对象，该对象存储该arena的元数据：arena中所有字（word）的堆位图
 * 和arena中所有页的跨度（span）图。它们本身是堆外分配的。
 *
 * 由于arena是对齐的，因此可以将地址空间视为一系列arena帧（frame）。arena映射（mheap_.arenas）
 * 从arena帧号映射到*heapArena，对于不由Go堆支持的部分地址空间，映射为nil。arena映射的结构为两层数组，
 * 由“L1”arena映射和许多“ L2”arena映射组成；但是，由于arena很大，因此在许多体系结构上，
 * arena映射都由一个大型L2映射组成。
 *
 * arena地图覆盖了整个可用的地址空间，从而允许Go堆使用地址空间的任何部分。分配器尝试使arena保持连续，
 * 以便大跨度（以及大对象）可以跨越arena。
 **/</span>

<span class="token keyword">package</span> runtime

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"runtime/internal/atomic"</span>
    <span class="token string">"runtime/internal/math"</span>
    <span class="token string">"runtime/internal/sys"</span>
    <span class="token string">"unsafe"</span>
<span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    debugMalloc <span class="token operator">=</span> <span class="token boolean">false</span>

    maxTinySize   <span class="token operator">=</span> _TinySize
    tinySizeClass <span class="token operator">=</span> _TinySizeClass
    maxSmallSize  <span class="token operator">=</span> _MaxSmallSize

    pageShift <span class="token operator">=</span> _PageShift
    pageSize  <span class="token operator">=</span> _PageSize
    pageMask  <span class="token operator">=</span> _PageMask
    <span class="token comment">// By construction, single page spans of the smallest object class</span>
    <span class="token comment">// have the most objects per span.</span>
    <span class="token comment">// 通过构造，对象类别最小的单个页面跨度在每个跨度中具有最多的对象。</span>
    <span class="token comment">// 每个跨度的最大多对象数</span>
    maxObjsPerSpan <span class="token operator">=</span> pageSize <span class="token operator">/</span> <span class="token number">8</span>

    concurrentSweep <span class="token operator">=</span> _ConcurrentSweep

    _PageSize <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> _PageShift
    _PageMask <span class="token operator">=</span> _PageSize <span class="token operator">-</span> <span class="token number">1</span>

    <span class="token comment">// _64bit = 1 on 64-bit systems, 0 on 32-bit systems</span>
    <span class="token comment">// _64bit = 1在64位系统上，0在32位系统上</span>
    _64bit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">63</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>

    <span class="token comment">// Tiny allocator parameters, see "Tiny allocator" comment in malloc.go.</span>
    <span class="token comment">// Tiny分配器参数，请参阅malloc.go中的“Tiny分配器”注释。在mallocgc方法中</span>
    _TinySize      <span class="token operator">=</span> <span class="token number">16</span>
    _TinySizeClass <span class="token operator">=</span> <span class="token function">int8</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    
    <span class="token comment">// FixAlloc的块大小</span>
    _FixAllocChunk <span class="token operator">=</span> <span class="token number">16</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span> <span class="token comment">// Chunk size for FixAlloc</span>

    <span class="token comment">// Per-P, per order stack segment cache size.</span>
    <span class="token comment">// 每个P，每个order堆栈段的缓存大小。</span>
    _StackCacheSize <span class="token operator">=</span> <span class="token number">32</span> <span class="token operator">*</span> <span class="token number">1024</span>

    <span class="token comment">// Number of orders that get caching. Order 0 is FixedStack</span>
    <span class="token comment">// and each successive order is twice as large.</span>
    <span class="token comment">// We want to cache 2KB, 4KB, 8KB, and 16KB stacks. Larger stacks</span>
    <span class="token comment">// will be allocated directly.</span>
    <span class="token comment">// Since FixedStack is different on different systems, we</span>
    <span class="token comment">// must vary NumStackOrders to keep the same maximum cached size.</span>
    <span class="token comment">// 获得缓存的order数。Order 0是FixedStack，每个连续的order是其两倍。</span>
    <span class="token comment">// 我们要缓存2KB，4KB，8KB和16KB堆栈。较大的堆栈将直接分配。</span>
    <span class="token comment">// 由于FixedStack在不同的系统上是不同的，因此我们必须改变NumStackOrders以保持相同的最大缓存大小。</span>
    <span class="token comment">// 下面是不同的操作系统对应的FixedStack和NumStackOrders的对应表</span>
    <span class="token comment">//   OS               | FixedStack | NumStackOrders</span>
    <span class="token comment">//   -----------------+------------+---------------</span>
    <span class="token comment">//   linux/darwin/bsd | 2KB        | 4</span>
    <span class="token comment">//   windows/32       | 4KB        | 3</span>
    <span class="token comment">//   windows/64       | 8KB        | 2</span>
    <span class="token comment">//   plan9            | 4KB        | 3</span>
    _NumStackOrders <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">-</span> sys<span class="token punctuation">.</span>PtrSize<span class="token operator">/</span><span class="token number">4</span><span class="token operator">*</span>sys<span class="token punctuation">.</span>GoosWindows <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">*</span>sys<span class="token punctuation">.</span>GoosPlan9

    <span class="token comment">// heapAddrBits is the number of bits in a heap address. On</span>
    <span class="token comment">// amd64, addresses are sign-extended beyond heapAddrBits. On</span>
    <span class="token comment">// other arches, they are zero-extended.</span>
    <span class="token comment">//</span>
    <span class="token comment">// On most 64-bit platforms, we limit this to 48 bits based on a</span>
    <span class="token comment">// combination of hardware and OS limitations.</span>
    <span class="token comment">//</span>
    <span class="token comment">// amd64 hardware limits addresses to 48 bits, sign-extended</span>
    <span class="token comment">// to 64 bits. Addresses where the top 16 bits are not either</span>
    <span class="token comment">// all 0 or all 1 are "non-canonical" and invalid. Because of</span>
    <span class="token comment">// these "negative" addresses, we offset addresses by 1&lt;&lt;47</span>
    <span class="token comment">// (arenaBaseOffset) on amd64 before computing indexes into</span>
    <span class="token comment">// the heap arenas index. In 2017, amd64 hardware added</span>
    <span class="token comment">// support for 57 bit addresses; however, currently only Linux</span>
    <span class="token comment">// supports this extension and the kernel will never choose an</span>
    <span class="token comment">// address above 1&lt;&lt;47 unless mmap is called with a hint</span>
    <span class="token comment">// address above 1&lt;&lt;47 (which we never do).</span>
    <span class="token comment">//</span>
    <span class="token comment">// arm64 hardware (as of ARMv8) limits user addresses to 48</span>
    <span class="token comment">// bits, in the range [0, 1&lt;&lt;48).</span>
    <span class="token comment">//</span>
    <span class="token comment">// ppc64, mips64, and s390x support arbitrary 64 bit addresses</span>
    <span class="token comment">// in hardware. On Linux, Go leans on stricter OS limits. Based</span>
    <span class="token comment">// on Linux's processor.h, the user address space is limited as</span>
    <span class="token comment">// follows on 64-bit architectures:</span>
    <span class="token comment">// heapAddrBits是堆地址中的位数。在amd64上，地址被符号扩展到heapAddrBits之外。在其他架构上，它们是零扩展的。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 在大多数64位平台上，基于硬件和操作系统限制的组合，我们将其限制为48位。</span>
    <span class="token comment">//</span>
    <span class="token comment">// amd64硬件将地址限制为48位，符号扩展为64位。前16位不全为0或全为1的地址是“非规范的”且无效。</span>
    <span class="token comment">// 由于存在这些“负”地址，因此在计算进入堆竞技场索引的索引之前，在amd64上将地址偏移1 &lt;&lt; 47（arenaBaseOffset）。</span>
    <span class="token comment">// 2017年，amd64硬件增加了对57位地址的支持;但是，当前只有Linux支持此扩展，内核将永远不会选择大于1 &lt;&lt; 47的地址，</span>
    <span class="token comment">// 除非调用mmap的提示地址大于1 &lt;&lt; 47（我们从未这样做）。</span>
    <span class="token comment">//</span>
    <span class="token comment">// arm64硬件（自ARMv8起）将用户地址限制为48位，范围为[0，1 &lt;&lt; 48）。</span>
    <span class="token comment">//</span>
    <span class="token comment">// ppc64，mips64和s390x在硬件中支持任意64位地址。在Linux上，Go依靠更严格的OS限制。</span>
    <span class="token comment">// 基于Linux的processor.h，在64位体系结构上，用户地址空间受到如下限制：</span>
    <span class="token comment">//</span>
    <span class="token comment">// Architecture  Name              Maximum Value (exclusive)</span>
    <span class="token comment">// ---------------------------------------------------------------------</span>
    <span class="token comment">// amd64         TASK_SIZE_MAX     0x007ffffffff000 (47 bit addresses)</span>
    <span class="token comment">// arm64         TASK_SIZE_64      0x01000000000000 (48 bit addresses)</span>
    <span class="token comment">// ppc64{,le}    TASK_SIZE_USER64  0x00400000000000 (46 bit addresses)</span>
    <span class="token comment">// mips64{,le}   TASK_SIZE64       0x00010000000000 (40 bit addresses)</span>
    <span class="token comment">// s390x         TASK_SIZE         1&lt;&lt;64 (64 bit addresses)</span>
    <span class="token comment">//</span>
    <span class="token comment">// These limits may increase over time, but are currently at</span>
    <span class="token comment">// most 48 bits except on s390x. On all architectures, Linux</span>
    <span class="token comment">// starts placing mmap'd regions at addresses that are</span>
    <span class="token comment">// significantly below 48 bits, so even if it's possible to</span>
    <span class="token comment">// exceed Go's 48 bit limit, it's extremely unlikely in</span>
    <span class="token comment">// practice.</span>
    <span class="token comment">//</span>
    <span class="token comment">// On 32-bit platforms, we accept the full 32-bit address</span>
    <span class="token comment">// space because doing so is cheap.</span>
    <span class="token comment">// mips32 only has access to the low 2GB of virtual memory, so</span>
    <span class="token comment">// we further limit it to 31 bits.</span>
    <span class="token comment">//</span>
    <span class="token comment">// On darwin/arm64, although 64-bit pointers are presumably</span>
    <span class="token comment">// available, pointers are truncated to 33 bits. Furthermore,</span>
    <span class="token comment">// only the top 4 GiB of the address space are actually available</span>
    <span class="token comment">// to the application, but we allow the whole 33 bits anyway for</span>
    <span class="token comment">// simplicity.</span>
    <span class="token comment">// TODO(mknyszek): Consider limiting it to 32 bits and using</span>
    <span class="token comment">// arenaBaseOffset to offset into the top 4 GiB.</span>
    <span class="token comment">//</span>
    <span class="token comment">// WebAssembly currently has a limit of 4GB linear memory.</span>
    <span class="token comment">// 这些限制可能会随时间增加，但目前最多为48位，但s390x除外。在所有体系结构上，</span>
    <span class="token comment">// Linux都开始将mmap'd区域放置在明显低于48位的地址上，因此，即使有可能超过Go的48位限制，在实践中也极不可能。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 在32位平台上，我们接受完整的32位地址空间，因为这样做很便宜。 mips32仅可以访问2GB的低虚拟内存，</span>
    <span class="token comment">// 因此我们进一步将其限制为31位。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 在darwin / arm64上，尽管大概可以使用64位指针，但指针会被截断为33位。此外，</span>
    <span class="token comment">// 只有地址空间的前4个GiB实际上可供应用程序使用，但是为了简单起见，我们还是允许全部33位。</span>
    <span class="token comment">// TODO（mknyszek）：考虑将其限制为32位，并使用arenaBaseOffset偏移到前4个GiB中。</span>
    <span class="token comment">//</span>
    <span class="token comment">// WebAssembly当前限制为4GB线性内存。</span>
    <span class="token comment">// heapAddrBits：堆空间地址位数，间接表示了他可以支持的最大的内存空间</span>
    heapAddrBits <span class="token operator">=</span> <span class="token punctuation">(</span>_64bit<span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>sys<span class="token punctuation">.</span>GoarchWasm<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>sys<span class="token punctuation">.</span>GoosDarwin<span class="token operator">*</span>sys<span class="token punctuation">.</span>GoarchArm64<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">48</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>_64bit<span class="token operator">+</span>sys<span class="token punctuation">.</span>GoarchWasm<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token operator">-</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>GoarchMips<span class="token operator">+</span>sys<span class="token punctuation">.</span>GoarchMipsle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">33</span><span class="token operator">*</span>sys<span class="token punctuation">.</span>GoosDarwin<span class="token operator">*</span>sys<span class="token punctuation">.</span>GoarchArm64

    <span class="token comment">// maxAlloc is the maximum size of an allocation. On 64-bit,</span>
    <span class="token comment">// it's theoretically possible to allocate 1&lt;&lt;heapAddrBits bytes. On</span>
    <span class="token comment">// 32-bit, however, this is one less than 1&lt;&lt;32 because the</span>
    <span class="token comment">// number of bytes in the address space doesn't actually fit</span>
    <span class="token comment">// in a uintptr.</span>
    <span class="token comment">// maxAlloc是分配的最大大小。在64位上，理论上可以分配1 &lt;&lt; heapAddrBits字节。</span>
    <span class="token comment">// 但是，在32位上，这比1&lt;&lt;32小1，因为地址空间中的字节数实际上不适合uintptr。</span>
    maxAlloc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> heapAddrBits<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>_64bit<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1</span>

    <span class="token comment">// The number of bits in a heap address, the size of heap</span>
    <span class="token comment">// arenas, and the L1 and L2 arena map sizes are related by</span>
    <span class="token comment">//</span>
    <span class="token comment">//   (1 &lt;&lt; addr bits) = arena size * L1 entries * L2 entries</span>
    <span class="token comment">//</span>
    <span class="token comment">// Currently, we balance these as follows:</span>
    <span class="token comment">// 堆地址中的位数，堆arena的大小以及L1和L2 arena映射的大小与</span>
    <span class="token comment">//</span>
    <span class="token comment">// 1 &lt;&lt; addr位）=arena大小* L1条目* L2条目</span>
    <span class="token comment">//</span>
    <span class="token comment">// 目前，我们将这些平衡如下：</span>
    <span class="token comment">//</span>
    <span class="token comment">//       Platform  Addr bits  Arena size  L1 entries   L2 entries</span>
    <span class="token comment">// --------------  ---------  ----------  ----------  -----------</span>
    <span class="token comment">//       */64-bit         48        64MB           1    4M (32MB)</span>
    <span class="token comment">// windows/64-bit         48         4MB          64    1M  (8MB)</span>
    <span class="token comment">//       */32-bit         32         4MB           1  1024  (4KB)</span>
    <span class="token comment">//     */mips(le)         31         4MB           1   512  (2KB)</span>

    <span class="token comment">// heapArenaBytes is the size of a heap arena. The heap</span>
    <span class="token comment">// consists of mappings of size heapArenaBytes, aligned to</span>
    <span class="token comment">// heapArenaBytes. The initial heap mapping is one arena.</span>
    <span class="token comment">//</span>
    <span class="token comment">// This is currently 64MB on 64-bit non-Windows and 4MB on</span>
    <span class="token comment">// 32-bit and on Windows. We use smaller arenas on Windows</span>
    <span class="token comment">// because all committed memory is charged to the process,</span>
    <span class="token comment">// even if it's not touched. Hence, for processes with small</span>
    <span class="token comment">// heaps, the mapped arena space needs to be commensurate.</span>
    <span class="token comment">// This is particularly important with the race detector,</span>
    <span class="token comment">// since it significantly amplifies the cost of committed</span>
    <span class="token comment">// memory.</span>
    <span class="token comment">// heapArenaBytes是堆arenas的大小。堆由大小为heapArenaBytes的映射组成，</span>
    <span class="token comment">// 并与heapArenaBytes对齐。最初的堆映射是一个arenas。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 当前在64位非Windows上为64MB，在32位和Windows上为4MB。我们在Windows上使用较小的arenas，</span>
    <span class="token comment">// 因为所有已提交的内存都由进程负责，即使未涉及也是如此。因此，对于具有小堆的进程，映射的arenas空间需要相对应。</span>
    <span class="token comment">// 这对于竞争检测器尤其重要，因为它会大大增加已提交内存的成本。</span>
    heapArenaBytes <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> logHeapArenaBytes

    <span class="token comment">// logHeapArenaBytes is log_2 of heapArenaBytes. For clarity,</span>
    <span class="token comment">// prefer using heapArenaBytes where possible (we need the</span>
    <span class="token comment">// constant to compute some other constants).</span>
    <span class="token comment">// logHeapArenaBytes是heapArenaBytes的log_2。为了清楚起见，</span>
    <span class="token comment">// 最好在可能的地方使用heapArenaBytes（我们需要使用常量来计算其他常量）。</span>
    logHeapArenaBytes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>_64bit<span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>sys<span class="token punctuation">.</span>GoosWindows<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>sys<span class="token punctuation">.</span>GoarchWasm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>_64bit<span class="token operator">*</span>sys<span class="token punctuation">.</span>GoosWindows<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>_64bit<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token operator">*</span>sys<span class="token punctuation">.</span>GoarchWasm

    <span class="token comment">// heapArenaBitmapBytes is the size of each heap arena's bitmap.</span>
    <span class="token comment">// heapArenaBitmapBytes是每个堆arena的位图大小。</span>
    heapArenaBitmapBytes <span class="token operator">=</span> heapArenaBytes <span class="token operator">/</span> <span class="token punctuation">(</span>sys<span class="token punctuation">.</span>PtrSize <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>

    <span class="token comment">// 每个arena所的页数</span>
    pagesPerArena <span class="token operator">=</span> heapArenaBytes <span class="token operator">/</span> pageSize

    <span class="token comment">// arenaL1Bits is the number of bits of the arena number</span>
    <span class="token comment">// covered by the first level arena map.</span>
    <span class="token comment">//</span>
    <span class="token comment">// This number should be small, since the first level arena</span>
    <span class="token comment">// map requires PtrSize*(1&lt;&lt;arenaL1Bits) of space in the</span>
    <span class="token comment">// binary's BSS. It can be zero, in which case the first level</span>
    <span class="token comment">// index is effectively unused. There is a performance benefit</span>
    <span class="token comment">// to this, since the generated code can be more efficient,</span>
    <span class="token comment">// but comes at the cost of having a large L2 mapping.</span>
    <span class="token comment">//</span>
    <span class="token comment">// We use the L1 map on 64-bit Windows because the arena size</span>
    <span class="token comment">// is small, but the address space is still 48 bits, and</span>
    <span class="token comment">// there's a high cost to having a large L2.</span>
    <span class="token comment">// arenaL1Bits是第一级arena映射覆盖的arena编号的位数。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 这个数字应该很小，因为第一级arena映射在二进制文件的BSS中需要PtrSize*(1&lt;&lt;arenaL1Bits)空间。</span>
    <span class="token comment">// 它可以为零，在这种情况下，第一级索引实际上未被使用。这会带来性能上的好处，</span>
    <span class="token comment">// 因为生成的代码可以更高效，但是以拥有较大的L2映射为代价。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 我们在64位Windows上使用L1映射，因为arena大小很小，但是地址空间仍然是48位，并且拥有大型L2的成本很高。</span>
    arenaL1Bits <span class="token operator">=</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token punctuation">(</span>_64bit <span class="token operator">*</span> sys<span class="token punctuation">.</span>GoosWindows<span class="token punctuation">)</span>

    <span class="token comment">// arenaL2Bits is the number of bits of the arena number</span>
    <span class="token comment">// covered by the second level arena index.</span>
    <span class="token comment">//</span>
    <span class="token comment">// The size of each arena map allocation is proportional to</span>
    <span class="token comment">// 1&lt;&lt;arenaL2Bits, so it's important that this not be too</span>
    <span class="token comment">// large. 48 bits leads to 32MB arena index allocations, which</span>
    <span class="token comment">// is about the practical threshold.</span>
    <span class="token comment">// arenaL2Bits是第二级arena索引覆盖的arena编号的位数。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 每个arena映射分配的大小与1&lt;&lt;arenaL2Bits成正比，因此，不要太大也很重要。</span>
    <span class="token comment">// 48位导致32MB arena索引分配，这大约是实际的阈值。</span>
    arenaL2Bits <span class="token operator">=</span> heapAddrBits <span class="token operator">-</span> logHeapArenaBytes <span class="token operator">-</span> arenaL1Bits

    <span class="token comment">// arenaL1Shift is the number of bits to shift an arena frame</span>
    <span class="token comment">// number by to compute an index into the first level arena map.</span>
    <span class="token comment">// arenaL1Shift是将arena帧号移位以计算进入第一级arena映射的索引的位数。</span>
    arenaL1Shift <span class="token operator">=</span> arenaL2Bits

    <span class="token comment">// arenaBits is the total bits in a combined arena map index.</span>
    <span class="token comment">// This is split between the index into the L1 arena map and</span>
    <span class="token comment">// the L2 arena map.</span>
    <span class="token comment">// arenaBits是组合的arena映射索引中的总位。这在进入L1 arena映射和L2 arena映射的索引之间进行划分。</span>
    arenaBits <span class="token operator">=</span> arenaL1Bits <span class="token operator">+</span> arenaL2Bits

    <span class="token comment">// arenaBaseOffset is the pointer value that corresponds to</span>
    <span class="token comment">// index 0 in the heap arena map.</span>
    <span class="token comment">//</span>
    <span class="token comment">// On amd64, the address space is 48 bits, sign extended to 64</span>
    <span class="token comment">// bits. This offset lets us handle "negative" addresses (or</span>
    <span class="token comment">// high addresses if viewed as unsigned).</span>
    <span class="token comment">//</span>
    <span class="token comment">// On aix/ppc64, this offset allows to keep the heapAddrBits to</span>
    <span class="token comment">// 48. Otherwize, it would be 60 in order to handle mmap addresses</span>
    <span class="token comment">// (in range 0x0a00000000000000 - 0x0afffffffffffff). But in this</span>
    <span class="token comment">// case, the memory reserved in (s *pageAlloc).init for chunks</span>
    <span class="token comment">// is causing important slowdowns.</span>
    <span class="token comment">//</span>
    <span class="token comment">// On other platforms, the user address space is contiguous</span>
    <span class="token comment">// and starts at 0, so no offset is necessary.</span>
    <span class="token comment">// arenaBaseOffset是与堆arena映射中的索引0对应的指针值。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 在amd64上，地址空间为48位，符号扩展为64位。此偏移量使我们可以处理“负”地址（如果视为无符号，则为高地址）。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 在aix/ppc64上，此偏移量允许将heapAddrBits保持为48。否则，为了处理mmap地址</span>
    <span class="token comment">//（范围为0x0a00000000000000-0x0afffffffffffffff），它将为60。但是在这种情况下，</span>
    <span class="token comment">// (s*pageAlloc).init中为块保留的内存会导致严重的速度下降。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 在其他平台上，用户地址空间是连续的，并且从0开始，因此不需要偏移量。</span>
    arenaBaseOffset <span class="token operator">=</span> sys<span class="token punctuation">.</span>GoarchAmd64<span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">47</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">0x0a00000000000000</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>uintptrMask<span class="token operator">*</span>sys<span class="token punctuation">.</span>GoosAix

    <span class="token comment">// Max number of threads to run garbage collection.</span>
    <span class="token comment">// 2, 3, and 4 are all plausible maximums depending</span>
    <span class="token comment">// on the hardware details of the machine. The garbage</span>
    <span class="token comment">// collector scales well to 32 cpus.</span>
    <span class="token comment">// 运行垃圾回收的最大线程数。 2、3和4都是合理的最大值，具体取决于机器的硬件细节。 垃圾收集器可以很好地扩展到32 cpus。</span>
    _MaxGcproc <span class="token operator">=</span> <span class="token number">32</span>

    <span class="token comment">// minLegalPointer is the smallest possible legal pointer.</span>
    <span class="token comment">// This is the smallest possible architectural page size,</span>
    <span class="token comment">// since we assume that the first page is never mapped.</span>
    <span class="token comment">//</span>
    <span class="token comment">// This should agree with minZeroPage in the compiler.</span>
    <span class="token comment">//</span>
    <span class="token comment">// minLegalPointer是最小的合法指针。 这是可能的最小体系架构页大小，因为我们假设第一页从未映射过。</span>
    <span class="token comment">//这应该与编译器中的minZeroPage一致。</span>
    minLegalPointer <span class="token builtin">uintptr</span> <span class="token operator">=</span> <span class="token number">4096</span>
<span class="token punctuation">)</span>

<span class="token comment">// physPageSize is the size in bytes of the OS's physical pages.</span>
<span class="token comment">// Mapping and unmapping operations must be done at multiples of</span>
<span class="token comment">// physPageSize.</span>
<span class="token comment">//</span>
<span class="token comment">// This must be set by the OS init code (typically in osinit) before</span>
<span class="token comment">// mallocinit.</span>
<span class="token comment">//</span>
<span class="token comment">// physPageSize是操作系统物理页面的大小（以字节为单位）。</span>
<span class="token comment">// 映射和取消映射操作必须以physPageSize的倍数完成。</span>
<span class="token comment">//</span>
<span class="token comment">// 必须在mallocinit之前通过OS初始化代码（通常在osinit中）进行设置。</span>
<span class="token keyword">var</span> physPageSize <span class="token builtin">uintptr</span>

<span class="token comment">// physHugePageSize is the size in bytes of the OS's default physical huge</span>
<span class="token comment">// page size whose allocation is opaque to the application. It is assumed</span>
<span class="token comment">// and verified to be a power of two.</span>
<span class="token comment">//</span>
<span class="token comment">// If set, this must be set by the OS init code (typically in osinit) before</span>
<span class="token comment">// mallocinit. However, setting it at all is optional, and leaving the default</span>
<span class="token comment">// value is always safe (though potentially less efficient).</span>
<span class="token comment">//</span>
<span class="token comment">// Since physHugePageSize is always assumed to be a power of two,</span>
<span class="token comment">// physHugePageShift is defined as physHugePageSize == 1 &lt;&lt; physHugePageShift.</span>
<span class="token comment">// The purpose of physHugePageShift is to avoid doing divisions in</span>
<span class="token comment">// performance critical functions.</span>
<span class="token comment">//</span>
<span class="token comment">// physHugePageSize是操作系统默认物理大页面大小的大小（以字节为单位），</span>
<span class="token comment">// 该大小对于应用程序是不透明的。 假定并验证为2的幂。</span>
<span class="token comment">//</span>
<span class="token comment">// 如果已设置，则必须在mallocinit之前通过OS初始化代码（通常在osinit中）进行设置。</span>
<span class="token comment">// 但是，完全设置它是可选的，并且保留默认值始终是安全的（尽管可能会降低效率）。</span>
<span class="token comment">//</span>
<span class="token comment">// 由于physHugePageSize始终假定为2的幂，因此physHugePageShift定义为physHugePageSize == 1 &lt;&lt; physHugePageShift。</span>
<span class="token comment">// physHugePageShift的目的是避免对性能至关重要的功能进行划分。</span>
<span class="token keyword">var</span> <span class="token punctuation">(</span>
    physHugePageSize  <span class="token builtin">uintptr</span>
    physHugePageShift <span class="token builtin">uint</span>
<span class="token punctuation">)</span>

<span class="token comment">// OS memory management abstraction layer</span>
<span class="token comment">//</span>
<span class="token comment">// Regions of the address space managed by the runtime may be in one of four</span>
<span class="token comment">// states at any given time:</span>
<span class="token comment">// 1) None - Unreserved and unmapped, the default state of any region.</span>
<span class="token comment">// 2) Reserved - Owned by the runtime, but accessing it would cause a fault.</span>
<span class="token comment">//               Does not count against the process' memory footprint.</span>
<span class="token comment">// 3) Prepared - Reserved, intended not to be backed by physical memory (though</span>
<span class="token comment">//               an OS may implement this lazily). Can transition efficiently to</span>
<span class="token comment">//               Ready. Accessing memory in such a region is undefined (may</span>
<span class="token comment">//               fault, may give back unexpected zeroes, etc.).</span>
<span class="token comment">// 4) Ready - may be accessed safely.</span>
<span class="token comment">//</span>
<span class="token comment">// This set of states is more than is strictly necessary to support all the</span>
<span class="token comment">// currently supported platforms. One could get by with just None, Reserved, and</span>
<span class="token comment">// Ready. However, the Prepared state gives us flexibility for performance</span>
<span class="token comment">// purposes. For example, on POSIX-y operating systems, Reserved is usually a</span>
<span class="token comment">// private anonymous mmap'd region with PROT_NONE set, and to transition</span>
<span class="token comment">// to Ready would require setting PROT_READ|PROT_WRITE. However the</span>
<span class="token comment">// underspecification of Prepared lets us use just MADV_FREE to transition from</span>
<span class="token comment">// Ready to Prepared. Thus with the Prepared state we can set the permission</span>
<span class="token comment">// bits just once early on, we can efficiently tell the OS that it's free to</span>
<span class="token comment">// take pages away from us when we don't strictly need them.</span>
<span class="token comment">//</span>
<span class="token comment">// For each OS there is a common set of helpers defined that transition</span>
<span class="token comment">// memory regions between these states. The helpers are as follows:</span>
<span class="token comment">//</span>
<span class="token comment">// sysAlloc transitions an OS-chosen region of memory from None to Ready.</span>
<span class="token comment">// More specifically, it obtains a large chunk of zeroed memory from the</span>
<span class="token comment">// operating system, typically on the order of a hundred kilobytes</span>
<span class="token comment">// or a megabyte. This memory is always immediately available for use.</span>
<span class="token comment">//</span>
<span class="token comment">// sysFree transitions a memory region from any state to None. Therefore, it</span>
<span class="token comment">// returns memory unconditionally. It is used if an out-of-memory error has been</span>
<span class="token comment">// detected midway through an allocation or to carve out an aligned section of</span>
<span class="token comment">// the address space. It is okay if sysFree is a no-op only if sysReserve always</span>
<span class="token comment">// returns a memory region aligned to the heap allocator's alignment</span>
<span class="token comment">// restrictions.</span>
<span class="token comment">//</span>
<span class="token comment">// sysReserve transitions a memory region from None to Reserved. It reserves</span>
<span class="token comment">// address space in such a way that it would cause a fatal fault upon access</span>
<span class="token comment">// (either via permissions or not committing the memory). Such a reservation is</span>
<span class="token comment">// thus never backed by physical memory.</span>
<span class="token comment">// If the pointer passed to it is non-nil, the caller wants the</span>
<span class="token comment">// reservation there, but sysReserve can still choose another</span>
<span class="token comment">// location if that one is unavailable.</span>
<span class="token comment">// NOTE: sysReserve returns OS-aligned memory, but the heap allocator</span>
<span class="token comment">// may use larger alignment, so the caller must be careful to realign the</span>
<span class="token comment">// memory obtained by sysReserve.</span>
<span class="token comment">//</span>
<span class="token comment">// sysMap transitions a memory region from Reserved to Prepared. It ensures the</span>
<span class="token comment">// memory region can be efficiently transitioned to Ready.</span>
<span class="token comment">//</span>
<span class="token comment">// sysUsed transitions a memory region from Prepared to Ready. It notifies the</span>
<span class="token comment">// operating system that the memory region is needed and ensures that the region</span>
<span class="token comment">// may be safely accessed. This is typically a no-op on systems that don't have</span>
<span class="token comment">// an explicit commit step and hard over-commit limits, but is critical on</span>
<span class="token comment">// Windows, for example.</span>
<span class="token comment">//</span>
<span class="token comment">// sysUnused transitions a memory region from Ready to Prepared. It notifies the</span>
<span class="token comment">// operating system that the physical pages backing this memory region are no</span>
<span class="token comment">// longer needed and can be reused for other purposes. The contents of a</span>
<span class="token comment">// sysUnused memory region are considered forfeit and the region must not be</span>
<span class="token comment">// accessed again until sysUsed is called.</span>
<span class="token comment">//</span>
<span class="token comment">// sysFault transitions a memory region from Ready or Prepared to Reserved. It</span>
<span class="token comment">// marks a region such that it will always fault if accessed. Used only for</span>
<span class="token comment">// debugging the runtime.</span>
<span class="token comment">/**
 * OS内存管理抽象层
 *
 * 在任何给定时间，运行时管理的地址空间区域可能处于四种状态之一：
 * - 1）无（None）——未保留和未映射，这是任何区域的默认状态。
 * - 2）保留（Reserved）——运行时拥有，但是访问它会导致故障。不计入进程的内存占用。
 * - 3）已准备（Prepared）——保留，意在不由物理内存支持（尽管OS可能会延迟实现）。
 *      可以有效过渡到就绪。在这样的区域中访问内存是不确定的（可能会出错，可能会返回意外的零等）。
 * - 4）就绪（Ready）——可以安全地访问。
 *
 * 这组状态对于支持所有当前受支持的平台而言绝对不是必需的。只需一个“无”，“保留”和“就绪”就可以解决问题。
 * 但是，“已准备”状态为我们提供了用于性能目的的灵活性。例如，在POSIX-y操作系统上，“保留”通常是设置了PROT_NONE的私有匿名mmap'd区域，
 * 要转换到“就绪”状态，需要设置PROT_READ | PROT_WRITE。但是，Prepared的规格不足使我们仅使用MADV_FREE从Ready过渡到Prepared。
 * 因此，在“准备好”状态下，我们可以提早设置一次权限位，我们可以有效地告诉操作系统，当我们严格不需要它们时，可以自由地将页面从我们手中夺走。
 *
 * 对于每个操作系统，都有一组通用的帮助程序，这些帮助程序在这些状态之间转换内存区域。帮助程序如下：
 *
 * sysAlloc
 * sysAlloc将OS选择的内存区域从“无”转换为“就绪”。更具体地说，它从操作系统中获取大量的零位内存，通常大约为一百千字节或兆字节。
 * 该内存始终可以立即使用。
 *
 * sysFree
 * sysFree将内存区域从任何状态转换为“无（Ready）”。因此，它无条件返回内存。如果在分配过程中检测到内存不足错误，
 * 或用于划分出地址空间的对齐部分，则使用此方法。仅当sysReserve始终返回与堆分配器的对齐限制对齐的内存区域时，
 * 如果sysFree是无操作的，这是可以的。
 *
 * sysReserve
 * sysReserve将内存区域从“无（None）”转换为“保留（Reserved）”。它以这样一种方式保留地址空间，
 * 即在访问时（通过权限或未提交内存）会导致致命错误。因此，这种保留永远不会受到物理内存的支持。如果传递给它的指针为非nil，
 * 则调用者希望在那里保留，但是sysReserve仍然可以选择另一个位置（如果该位置不可用）。
 *
 * 注意：sysReserve返回OS对齐的内存，但是堆分配器可能使用更大的对齐方式，因此调用者必须小心地重新对齐sysReserve获得的内存。
 *
 * sysMap
 * sysMap将内存区域从“保留（Reserved）”状态转换为“已准备（Prepared）”状态。它确保可以将存储区域有效地转换为“就绪（Ready）”。
 *
 * sysUsed
 * sysUsed将内存区域从“已准备（Prepared）”过渡到“就绪（Ready）”。它通知操作系统需要内存区域，并确保可以安全地访问该区域。
 * 在没有明确的提交步骤和严格的过量提交限制的系统上，这通常是不操作的，例如，在Windows上至关重要。
 *
 * sysUnused
 * sysUnused将内存区域从“就绪（Ready）”转换为“已准备（Prepared）”。它通知操作系统，不再需要支持该内存区域的物理页，
 * 并且可以将其重新用于其他目的。 sysUnused内存区域的内容被认为是没用的，在调用sysUsed之前，不得再次访问该区域。
 *
 * sysFault
 * sysFault将内存区域从“就绪（Ready）”或“已准备（Prepared）”转换为“保留（Reserved）”。它标记了一个区域，
 * 以便在访问时总是会发生故障。仅用于调试运行时。
 **/</span>
<span class="token keyword">func</span> <span class="token function">mallocinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 检查_TinySizeClass与_TinySize对应关系</span>
    <span class="token keyword">if</span> class_to_size<span class="token punctuation">[</span>_TinySizeClass<span class="token punctuation">]</span> <span class="token operator">!=</span> _TinySize <span class="token punctuation">{<!-- --></span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"bad TinySizeClass"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 确保映射到相同defer大小类别的defer arg大小也映射到相同的malloc大小类别。</span>
    <span class="token function">testdefersizes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 判断heapArenaBitmapBytes是否是2的指数次方</span>
    <span class="token keyword">if</span> heapArenaBitmapBytes<span class="token operator">&amp;</span><span class="token punctuation">(</span>heapArenaBitmapBytes<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// heapBits expects modular arithmetic on bitmap</span>
        <span class="token comment">// addresses to work.</span>
        <span class="token comment">// heapBits希望对位图地址进行模块化算术运算。</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"heapArenaBitmapBytes not a power of 2"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Copy class sizes out for statistics table.</span>
    <span class="token comment">// 将类别大小拷贝到统计表</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> class_to_size <span class="token punctuation">{<!-- --></span>
        memstats<span class="token punctuation">.</span>by_size<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>class_to_size<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Check physPageSize.</span>
    <span class="token comment">// 检查physPageSize。</span>
    <span class="token keyword">if</span> physPageSize <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// The OS init code failed to fetch the physical page size.</span>
        <span class="token comment">// 操作系统初始化代码无法获取物理页面大小。</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"failed to get system page size"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 物理页大小比最大物理页还大</span>
    <span class="token keyword">if</span> physPageSize <span class="token operator">&gt;</span> maxPhysPageSize <span class="token punctuation">{<!-- --></span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"system page size ("</span><span class="token punctuation">,</span> physPageSize<span class="token punctuation">,</span> <span class="token string">") is larger than maximum page size ("</span><span class="token punctuation">,</span> maxPhysPageSize<span class="token punctuation">,</span> <span class="token string">")\n"</span><span class="token punctuation">)</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"bad system page size"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 物理页大小比最小物理页还小</span>
    <span class="token keyword">if</span> physPageSize <span class="token operator">&lt;</span> minPhysPageSize <span class="token punctuation">{<!-- --></span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"system page size ("</span><span class="token punctuation">,</span> physPageSize<span class="token punctuation">,</span> <span class="token string">") is smaller than minimum page size ("</span><span class="token punctuation">,</span> minPhysPageSize<span class="token punctuation">,</span> <span class="token string">")\n"</span><span class="token punctuation">)</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"bad system page size"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 物理页必须是2的幂次方</span>
    <span class="token keyword">if</span> physPageSize<span class="token operator">&amp;</span><span class="token punctuation">(</span>physPageSize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"system page size ("</span><span class="token punctuation">,</span> physPageSize<span class="token punctuation">,</span> <span class="token string">") must be a power of 2\n"</span><span class="token punctuation">)</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"bad system page size"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 操作系统默认页大小，物理页必须是2的幂次方</span>
    <span class="token keyword">if</span> physHugePageSize<span class="token operator">&amp;</span><span class="token punctuation">(</span>physHugePageSize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"system huge page size ("</span><span class="token punctuation">,</span> physHugePageSize<span class="token punctuation">,</span> <span class="token string">") must be a power of 2\n"</span><span class="token punctuation">)</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"bad system huge page size"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 操作系统默认页大小大于操作系统最大的页大小</span>
    <span class="token keyword">if</span> physHugePageSize <span class="token operator">&gt;</span> maxPhysHugePageSize <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// physHugePageSize is greater than the maximum supported huge page size.</span>
        <span class="token comment">// Don't throw here, like in the other cases, since a system configured</span>
        <span class="token comment">// in this way isn't wrong, we just don't have the code to support them.</span>
        <span class="token comment">// Instead, silently set the huge page size to zero.</span>
        <span class="token comment">// physHugePageSize大于所支持的最大大页面大小。不要像其他情况那样在这里throw错误，</span>
        <span class="token comment">// 因为以这种方式配置的系统没有错，所以我们只是没有支持它们的代码。而是将巨大的页面大小静默设置为零。</span>
        physHugePageSize <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> physHugePageSize <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Since physHugePageSize is a power of 2, it suffices to increase</span>
        <span class="token comment">// physHugePageShift until 1&lt;&lt;physHugePageShift == physHugePageSize.</span>
        <span class="token comment">// 由于physHugePageSize为2的幂，因此足以将physHugePageShift增大到1&lt;&lt;physHugePageShift == physHugePageSize。</span>
        <span class="token keyword">for</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>physHugePageShift <span class="token operator">!=</span> physHugePageSize <span class="token punctuation">{<!-- --></span>
            physHugePageShift<span class="token operator">++</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Initialize the heap.</span>
    <span class="token comment">// 初始化堆</span>
    mheap_<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>mcache <span class="token operator">=</span> <span class="token function">allocmcache</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// Create initial arena growth hints.</span>
    <span class="token comment">// 创建初始arena增长提示。8表示字节数</span>
    <span class="token keyword">if</span> sys<span class="token punctuation">.</span>PtrSize <span class="token operator">==</span> <span class="token number">8</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// On a 64-bit machine, we pick the following hints</span>
        <span class="token comment">// because:</span>
        <span class="token comment">//</span>
        <span class="token comment">// 1. Starting from the middle of the address space</span>
        <span class="token comment">// makes it easier to grow out a contiguous range</span>
        <span class="token comment">// without running in to some other mapping.</span>
        <span class="token comment">//</span>
        <span class="token comment">// 2. This makes Go heap addresses more easily</span>
        <span class="token comment">// recognizable when debugging.</span>
        <span class="token comment">//</span>
        <span class="token comment">// 3. Stack scanning in gccgo is still conservative,</span>
        <span class="token comment">// so it's important that addresses be distinguishable</span>
        <span class="token comment">// from other data.</span>
        <span class="token comment">//</span>
        <span class="token comment">// Starting at 0x00c0 means that the valid memory addresses</span>
        <span class="token comment">// will begin 0x00c0, 0x00c1, ...</span>
        <span class="token comment">// In little-endian, that's c0 00, c1 00, ... None of those are valid</span>
        <span class="token comment">// UTF-8 sequences, and they are otherwise as far away from</span>
        <span class="token comment">// ff (likely a common byte) as possible. If that fails, we try other 0xXXc0</span>
        <span class="token comment">// addresses. An earlier attempt to use 0x11f8 caused out of memory errors</span>
        <span class="token comment">// on OS X during thread allocations.  0x00c0 causes conflicts with</span>
        <span class="token comment">// AddressSanitizer which reserves all memory up to 0x0100.</span>
        <span class="token comment">// These choices reduce the odds of a conservative garbage collector</span>
        <span class="token comment">// not collecting memory because some non-pointer block of memory</span>
        <span class="token comment">// had a bit pattern that matched a memory address.</span>
        <span class="token comment">//</span>
        <span class="token comment">// However, on arm64, we ignore all this advice above and slam the</span>
        <span class="token comment">// allocation at 0x40 &lt;&lt; 32 because when using 4k pages with 3-level</span>
        <span class="token comment">// translation buffers, the user address space is limited to 39 bits</span>
        <span class="token comment">// On darwin/arm64, the address space is even smaller.</span>
        <span class="token comment">//</span>
        <span class="token comment">// On AIX, mmaps starts at 0x0A00000000000000 for 64-bit.</span>
        <span class="token comment">// processes.</span>
        <span class="token comment">//</span>
        <span class="token comment">// 在64位计算机上，我们选择以下hit因为：</span>
        <span class="token comment">//</span>
        <span class="token comment">// 1.从地址空间的中间开始，可以轻松扩展到连续范围，而无需运行其他映射。</span>
        <span class="token comment">//</span>
        <span class="token comment">// 2.这使Go堆地址在调试时更容易识别。</span>
        <span class="token comment">//</span>
        <span class="token comment">// 3. gccgo中的堆栈扫描仍然很保守，因此将地址与其他数据区分开很重要。</span>
        <span class="token comment">//</span>
        <span class="token comment">// 从0x00c0开始意味着有效的内存地址将从0x00c0、0x00c1 ... n 小端开始，即c0 00，c1 00，...</span>
        <span class="token comment">// 这些都不是有效的UTF-8序列，否则它们是尽可能远离ff（可能是一个公共字节）。</span>
        <span class="token comment">// 如果失败，我们尝试其他0xXXc0地址。较早的尝试使用0x11f8导致线程分配期间OS X上的内存不足错误。</span>
        <span class="token comment">// 0x00c0导致与AddressSanitizer发生冲突，后者保留了最多0x0100的所有内存。</span>
        <span class="token comment">// 这些选择减少了保守的垃圾收集器不收集内存的可能性，因为某些非指针内存块具有与内存地址匹配的位模式。</span>
        <span class="token comment">//</span>
        <span class="token comment">// 但是，在arm64上，我们忽略了上面的所有建议，并在0x40 &lt;&lt; 32处分配，因为当使用具有3级转换缓冲区的4k页面时，</span>
        <span class="token comment">// 用户地址空间在darwin/arm64上被限制为39位，地址空间更小。</span>
        <span class="token comment">//</span>
        <span class="token comment">// 在AIX上，对于64位，mmaps从0x0A00000000000000开始。</span>
        <span class="token comment">// 预先进行内存分配，最多分配64次</span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0x7f</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// i=0b01111111</span>
            <span class="token keyword">var</span> p <span class="token builtin">uintptr</span>
            <span class="token keyword">switch</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">case</span> GOARCH <span class="token operator">==</span> <span class="token string">"arm64"</span> <span class="token operator">&amp;&amp;</span> GOOS <span class="token operator">==</span> <span class="token string">"darwin"</span><span class="token punctuation">:</span>
                p <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">40</span> <span class="token operator">|</span> uintptrMask<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">0x0013</span><span class="token operator">&lt;&lt;</span><span class="token number">28</span><span class="token punctuation">)</span>
            <span class="token keyword">case</span> GOARCH <span class="token operator">==</span> <span class="token string">"arm64"</span><span class="token punctuation">:</span>
                p <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">40</span> <span class="token operator">|</span> uintptrMask<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">0x0040</span><span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">)</span>
            <span class="token keyword">case</span> GOOS <span class="token operator">==</span> <span class="token string">"aix"</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// We don't use addresses directly after 0x0A00000000000000</span>
                    <span class="token comment">// to avoid collisions with others mmaps done by non-go programs.</span>
                    <span class="token comment">// 我们不会在0x0A00000000000000之后直接使用地址，以免与非执行程序造成的其他mmap冲突。</span>
                    <span class="token keyword">continue</span>
                <span class="token punctuation">}</span>
                p <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">40</span> <span class="token operator">|</span> uintptrMask<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">0xa0</span><span class="token operator">&lt;&lt;</span><span class="token number">52</span><span class="token punctuation">)</span>
            <span class="token keyword">case</span> raceenabled<span class="token punctuation">:</span> <span class="token comment">// 此值已为false</span>
                <span class="token comment">// The TSAN runtime requires the heap</span>
                <span class="token comment">// to be in the range [0x00c000000000,</span>
                <span class="token comment">// 0x00e000000000).</span>
                p <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">32</span> <span class="token operator">|</span> uintptrMask<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">0x00c0</span><span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> p <span class="token operator">&gt;=</span> uintptrMask<span class="token operator">&amp;</span><span class="token number">0x00e000000000</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">continue</span>
                <span class="token punctuation">}</span>
            <span class="token keyword">default</span><span class="token punctuation">:</span>
                p <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">40</span> <span class="token operator">|</span> uintptrMask<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">0x00c0</span><span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// p是所求的每个hint起始地址</span>
            <span class="token comment">// 采用头插法对hint块进行拉链，小端地址在前</span>
            <span class="token comment">// 最终所有的地址都分配在了mheap_.arenaHints上</span>
            hint <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>arenaHint<span class="token punctuation">)</span><span class="token punctuation">(</span>mheap_<span class="token punctuation">.</span>arenaHintAlloc<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            hint<span class="token punctuation">.</span>addr <span class="token operator">=</span> p
            hint<span class="token punctuation">.</span>next<span class="token punctuation">,</span> mheap_<span class="token punctuation">.</span>arenaHints <span class="token operator">=</span> mheap_<span class="token punctuation">.</span>arenaHints<span class="token punctuation">,</span> hint
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// On a 32-bit machine, we're much more concerned</span>
        <span class="token comment">// about keeping the usable heap contiguous.</span>
        <span class="token comment">// Hence:</span>
        <span class="token comment">//</span>
        <span class="token comment">// 1. We reserve space for all heapArenas up front so</span>
        <span class="token comment">// they don't get interleaved with the heap. They're</span>
        <span class="token comment">// ~258MB, so this isn't too bad. (We could reserve a</span>
        <span class="token comment">// smaller amount of space up front if this is a</span>
        <span class="token comment">// problem.)</span>
        <span class="token comment">//</span>
        <span class="token comment">// 2. We hint the heap to start right above the end of</span>
        <span class="token comment">// the binary so we have the best chance of keeping it</span>
        <span class="token comment">// contiguous.</span>
        <span class="token comment">//</span>
        <span class="token comment">// 3. We try to stake out a reasonably large initial</span>
        <span class="token comment">// heap reservation.</span>
        <span class="token comment">//</span>
        <span class="token comment">// 在32位计算机上，我们更加关注保持可用堆是连续的。</span>
        <span class="token comment">// 因此：</span>
        <span class="token comment">//</span>
        <span class="token comment">// 1.我们为所有的heapArena保留空间，这样它们就不会与heap交错。 它们约为258MB，因此还算不错。</span>
        <span class="token comment">// （如果出现问题，我们可以在前面预留较小的空间。）</span>
        <span class="token comment">//</span>
        <span class="token comment">// 2.我们建议堆从二进制文件的末尾开始，因此我们有最大的机会保持其连续性。</span>
        <span class="token comment">//</span>
        <span class="token comment">// 3.我们尝试放出一个相当大的初始堆保留。</span>
        <span class="token comment">// 计算arena元数据大小</span>
        <span class="token keyword">const</span> arenaMetaSize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> arenaBits<span class="token punctuation">)</span> <span class="token operator">*</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>heapArena<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token comment">// 保留内存</span>
        meta <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">sysReserve</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> arenaMetaSize<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> meta <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 保留成功，就进行初始化</span>
            mheap_<span class="token punctuation">.</span>heapArenaAlloc<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>meta<span class="token punctuation">,</span> arenaMetaSize<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// We want to start the arena low, but if we're linked</span>
        <span class="token comment">// against C code, it's possible global constructors</span>
        <span class="token comment">// have called malloc and adjusted the process' brk.</span>
        <span class="token comment">// Query the brk so we can avoid trying to map the</span>
        <span class="token comment">// region over it (which will cause the kernel to put</span>
        <span class="token comment">// the region somewhere else, likely at a high</span>
        <span class="token comment">// address).</span>
        <span class="token comment">// 我们想从低arena地址开始，但是如果我们与C代码链接，则可能全局构造函数调用了malloc并调整了进程的brk。</span>
        <span class="token comment">// 查询brk，以便我们避免尝试在其上映射区域（这将导致内核将区域放置在其他地方，可能位于高地址）。</span>
        <span class="token comment">// brk和sbrk相关文档</span>
        <span class="token comment">// https://blog.csdn.net/yusiguyuan/article/details/39496057</span>
        <span class="token comment">// https://blog.csdn.net/Apollon_krj/article/details/54565768</span>
        procBrk <span class="token operator">:=</span> <span class="token function">sbrk0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment">// If we ask for the end of the data segment but the</span>
        <span class="token comment">// operating system requires a little more space</span>
        <span class="token comment">// before we can start allocating, it will give out a</span>
        <span class="token comment">// slightly higher pointer. Except QEMU, which is</span>
        <span class="token comment">// buggy, as usual: it won't adjust the pointer</span>
        <span class="token comment">// upward. So adjust it upward a little bit ourselves:</span>
        <span class="token comment">// 1/4 MB to get away from the running binary image.</span>
        <span class="token comment">// 如果我们要求结束数据段，但是操作系统在开始分配之前需要更多空间，它将给出稍高的指针。</span>
        <span class="token comment">// 像往常一样，除了QEMU之外，它还有很多问题：它不会向上调整指针。 因此，我们自己向上调整一点：</span>
        <span class="token comment">// 1/4 MB以远离正在运行的二进制映像。</span>
        p <span class="token operator">:=</span> firstmoduledata<span class="token punctuation">.</span>end
        <span class="token keyword">if</span> p <span class="token operator">&lt;</span> procBrk <span class="token punctuation">{<!-- --></span>
            p <span class="token operator">=</span> procBrk
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> mheap_<span class="token punctuation">.</span>heapArenaAlloc<span class="token punctuation">.</span>next <span class="token operator">&lt;=</span> p <span class="token operator">&amp;&amp;</span> p <span class="token operator">&lt;</span> mheap_<span class="token punctuation">.</span>heapArenaAlloc<span class="token punctuation">.</span>end <span class="token punctuation">{<!-- --></span>
            p <span class="token operator">=</span> mheap_<span class="token punctuation">.</span>heapArenaAlloc<span class="token punctuation">.</span>end
        <span class="token punctuation">}</span>
        <span class="token comment">// alignUp(n, a) alignUp将n舍入为a的倍数。 a必须是2的幂。</span>
        p <span class="token operator">=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> heapArenaBytes<span class="token punctuation">)</span>
        <span class="token comment">// Because we're worried about fragmentation on</span>
        <span class="token comment">// 32-bit, we try to make a large initial reservation.</span>
        <span class="token comment">// 因为我们担心32位上的碎片，所以我们尝试进行较大的初始保留。</span>
        arenaSizes <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uintptr</span><span class="token punctuation">{<!-- --></span>
            <span class="token number">512</span> <span class="token operator">&lt;&lt;</span> <span class="token number">20</span><span class="token punctuation">,</span>
            <span class="token number">256</span> <span class="token operator">&lt;&lt;</span> <span class="token number">20</span><span class="token punctuation">,</span>
            <span class="token number">128</span> <span class="token operator">&lt;&lt;</span> <span class="token number">20</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 从在到小尝试分配，首次分配好就结束</span>
        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> arenaSize <span class="token operator">:=</span> <span class="token keyword">range</span> arenaSizes <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// sysReserveAligned类似于sysReserve，但是返回的指针字节对齐的。</span>
            <span class="token comment">// 它可以保留n个或n+align个字节，因此它返回保留的大小。</span>
            a<span class="token punctuation">,</span> size <span class="token operator">:=</span> <span class="token function">sysReserveAligned</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> arenaSize<span class="token punctuation">,</span> heapArenaBytes<span class="token punctuation">)</span>
            <span class="token keyword">if</span> a <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
                mheap_<span class="token punctuation">.</span>arena<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>
                p <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">+</span> size <span class="token comment">// For hint below</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        hint <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>arenaHint<span class="token punctuation">)</span><span class="token punctuation">(</span>mheap_<span class="token punctuation">.</span>arenaHintAlloc<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        hint<span class="token punctuation">.</span>addr <span class="token operator">=</span> p
        hint<span class="token punctuation">.</span>next<span class="token punctuation">,</span> mheap_<span class="token punctuation">.</span>arenaHints <span class="token operator">=</span> mheap_<span class="token punctuation">.</span>arenaHints<span class="token punctuation">,</span> hint
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// sysAlloc allocates heap arena space for at least n bytes. The</span>
<span class="token comment">// returned pointer is always heapArenaBytes-aligned and backed by</span>
<span class="token comment">// h.arenas metadata. The returned size is always a multiple of</span>
<span class="token comment">// heapArenaBytes. sysAlloc returns nil on failure.</span>
<span class="token comment">// There is no corresponding free function.</span>
<span class="token comment">//</span>
<span class="token comment">// sysAlloc returns a memory region in the Prepared state. This region must</span>
<span class="token comment">// be transitioned to Ready before use.</span>
<span class="token comment">//</span>
<span class="token comment">// h must be locked.</span>
<span class="token comment">/**
 * sysAlloc至少为n个字节分配堆arena空间。返回的指针始终是heapArenaBytes对齐的，
 * 并由h.arenas元数据支持。返回的大小始终是heapArenaBytes的倍数。 sysAlloc失败时返回nil。
 * 没有相应的free函数。
 *
 * sysAlloc返回处于Prepared状态的内存区域。使用前，该区域必须转换为“就绪”。
 *
 * h必须被锁定。
 * @param n 待分配的字节数
 * @return v 地址指针
 * @return size 分配的字节数
 **/</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>mheap<span class="token punctuation">)</span> <span class="token function">sysAlloc</span><span class="token punctuation">(</span>n <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>v unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> size <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 进行字节对齐</span>
    n <span class="token operator">=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> heapArenaBytes<span class="token punctuation">)</span>

    <span class="token comment">// First, try the arena pre-reservation.</span>
    <span class="token comment">// 首先，尝试arena预定。</span>
    v <span class="token operator">=</span> h<span class="token punctuation">.</span>arena<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> heapArenaBytes<span class="token punctuation">,</span> <span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>heap_sys<span class="token punctuation">)</span>
    <span class="token keyword">if</span> v <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        size <span class="token operator">=</span> n
        <span class="token keyword">goto</span> mapped
    <span class="token punctuation">}</span>

    <span class="token comment">// Try to grow the heap at a hint address.</span>
    <span class="token comment">// 尝试在hint地址处增加堆。</span>
    <span class="token keyword">for</span> h<span class="token punctuation">.</span>arenaHints <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        hint <span class="token operator">:=</span> h<span class="token punctuation">.</span>arenaHints
        p <span class="token operator">:=</span> hint<span class="token punctuation">.</span>addr
        <span class="token keyword">if</span> hint<span class="token punctuation">.</span>down <span class="token punctuation">{<!-- --></span>
            p <span class="token operator">-=</span> n
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> p<span class="token operator">+</span>n <span class="token operator">&lt;</span> p <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// We can't use this, so don't ask.</span>
            <span class="token comment">// 我们不能使用它，所以不回应。</span>
            v <span class="token operator">=</span> <span class="token boolean">nil</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token function">arenaIndex</span><span class="token punctuation">(</span>p<span class="token operator">+</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>arenaBits <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// Outside addressable heap. Can't use.</span>
            <span class="token comment">// 外部可寻址堆。无法使用。</span>
            v <span class="token operator">=</span> <span class="token boolean">nil</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            v <span class="token operator">=</span> <span class="token function">sysReserve</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> p <span class="token operator">==</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// Success. Update the hint.</span>
            <span class="token comment">// 成功。更新hint。</span>
            <span class="token keyword">if</span> <span class="token operator">!</span>hint<span class="token punctuation">.</span>down <span class="token punctuation">{<!-- --></span>
                p <span class="token operator">+=</span> n
            <span class="token punctuation">}</span>
            hint<span class="token punctuation">.</span>addr <span class="token operator">=</span> p
            size <span class="token operator">=</span> n
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// Failed. Discard this hint and try the next.</span>
        <span class="token comment">//</span>
        <span class="token comment">// TODO: This would be cleaner if sysReserve could be</span>
        <span class="token comment">// told to only return the requested address. In</span>
        <span class="token comment">// particular, this is already how Windows behaves, so</span>
        <span class="token comment">// it would simplify things there.</span>
        <span class="token comment">// 失败了放弃此hint，然后尝试下一个。</span>
        <span class="token comment">//</span>
        <span class="token comment">// TODO：如果可以告诉sysReserve仅返回所请求的地址，则这样做会更清洁。</span>
        <span class="token comment">// 特别是，这已经是Windows的处理方式，因此它将简化那里的事情。</span>
        <span class="token keyword">if</span> v <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">sysFree</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        h<span class="token punctuation">.</span>arenaHints <span class="token operator">=</span> hint<span class="token punctuation">.</span>next
        h<span class="token punctuation">.</span>arenaHintAlloc<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>hint<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span> <span class="token comment">// 此值已为false</span>
            <span class="token comment">// The race detector assumes the heap lives in</span>
            <span class="token comment">// [0x00c000000000, 0x00e000000000), but we</span>
            <span class="token comment">// just ran out of hints in this region. Give</span>
            <span class="token comment">// a nice failure.</span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"too many address space collisions for -race mode"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// All of the hints failed, so we'll take any</span>
        <span class="token comment">// (sufficiently aligned) address the kernel will give</span>
        <span class="token comment">// us.</span>
        <span class="token comment">// 所有hint均失败，因此我们将采用内核将提供给我们的任何地址（已充分对齐）。</span>
        v<span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token function">sysReserveAligned</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> heapArenaBytes<span class="token punctuation">)</span>
        <span class="token keyword">if</span> v <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token number">0</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Create new hints for extending this region.</span>
        <span class="token comment">// 创建用于扩展此区域的新hint。</span>
        hint <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>arenaHint<span class="token punctuation">)</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>arenaHintAlloc<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        hint<span class="token punctuation">.</span>addr<span class="token punctuation">,</span> hint<span class="token punctuation">.</span>down <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span>
        hint<span class="token punctuation">.</span>next<span class="token punctuation">,</span> mheap_<span class="token punctuation">.</span>arenaHints <span class="token operator">=</span> mheap_<span class="token punctuation">.</span>arenaHints<span class="token punctuation">,</span> hint
        hint <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>arenaHint<span class="token punctuation">)</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>arenaHintAlloc<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        hint<span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">+</span> size
        hint<span class="token punctuation">.</span>next<span class="token punctuation">,</span> mheap_<span class="token punctuation">.</span>arenaHints <span class="token operator">=</span> mheap_<span class="token punctuation">.</span>arenaHints<span class="token punctuation">,</span> hint
    <span class="token punctuation">}</span>

    <span class="token comment">// Check for bad pointers or pointers we can't use.</span>
    <span class="token comment">// 检查错误的指针或我们不能使用的指针。</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">var</span> bad <span class="token builtin">string</span>
        p <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
        <span class="token keyword">if</span> p<span class="token operator">+</span>size <span class="token operator">&lt;</span> p <span class="token punctuation">{<!-- --></span>
            bad <span class="token operator">=</span> <span class="token string">"region exceeds uintptr range"</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token function">arenaIndex</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>arenaBits <span class="token punctuation">{<!-- --></span>
            bad <span class="token operator">=</span> <span class="token string">"base outside usable address space"</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token function">arenaIndex</span><span class="token punctuation">(</span>p<span class="token operator">+</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>arenaBits <span class="token punctuation">{<!-- --></span>
            bad <span class="token operator">=</span> <span class="token string">"end outside usable address space"</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> bad <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// This should be impossible on most architectures,</span>
            <span class="token comment">// but it would be really confusing to debug.</span>
            <span class="token comment">// 在大多数体系结构上，这应该是不可能的，但是调试起来确实很混乱。</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"runtime: memory allocated by OS ["</span><span class="token punctuation">,</span> <span class="token function">hex</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">,</span> <span class="token function">hex</span><span class="token punctuation">(</span>p<span class="token operator">+</span>size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">") not in usable address space: "</span><span class="token punctuation">,</span> bad<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"memory reservation exceeds address space limit"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>heapArenaBytes<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"misrounded allocation in sysAlloc"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Transition from Reserved to Prepared.</span>
    <span class="token comment">// 转换状态将从预留到已准备。</span>
    <span class="token function">sysMap</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>heap_sys<span class="token punctuation">)</span>

mapped<span class="token punctuation">:</span>
    <span class="token comment">// Create arena metadata.</span>
    <span class="token comment">// 创建arena元数据。</span>
    <span class="token keyword">for</span> ri <span class="token operator">:=</span> <span class="token function">arenaIndex</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ri <span class="token operator">&lt;=</span> <span class="token function">arenaIndex</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token operator">+</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ri<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
        l2 <span class="token operator">:=</span> h<span class="token punctuation">.</span>arenas<span class="token punctuation">[</span>ri<span class="token punctuation">.</span><span class="token function">l1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> l2 <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// Allocate an L2 arena map.</span>
            <span class="token comment">// 分配L2arena映射。</span>
            l2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> arenaL2Bits<span class="token punctuation">]</span><span class="token operator">*</span>heapArena<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">persistentalloc</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>l2<span class="token punctuation">)</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> l2 <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"out of memory allocating heap arena map"</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            atomic<span class="token punctuation">.</span><span class="token function">StorepNoWB</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>h<span class="token punctuation">.</span>arenas<span class="token punctuation">[</span>ri<span class="token punctuation">.</span><span class="token function">l1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> l2<span class="token punctuation">[</span>ri<span class="token punctuation">.</span><span class="token function">l2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"arena already initialized"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">var</span> r <span class="token operator">*</span>heapArena
        r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>heapArena<span class="token punctuation">)</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>heapArenaAlloc<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">,</span> <span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>gc_sys<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> r <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>heapArena<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">persistentalloc</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">,</span> <span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>gc_sys<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> r <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"out of memory allocating heap arena metadata"</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Add the arena to the arenas list.</span>
        <span class="token comment">// 将arena添加到arena列表中。</span>
        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>allArenas<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">cap</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>allArenas<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            size <span class="token operator">:=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>allArenas<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> sys<span class="token punctuation">.</span>PtrSize
            <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                size <span class="token operator">=</span> physPageSize
            <span class="token punctuation">}</span>
            newArray <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>notInHeap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">persistentalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">,</span> <span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>gc_sys<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> newArray <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"out of memory allocating allArenas"</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            oldSlice <span class="token operator">:=</span> h<span class="token punctuation">.</span>allArenas
            <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>notInHeapSlice<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>h<span class="token punctuation">.</span>allArenas<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> notInHeapSlice<span class="token punctuation">{<!-- --></span>newArray<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>allArenas<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">int</span><span class="token punctuation">(</span>size <span class="token operator">/</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span><span class="token punctuation">}</span>
            <span class="token function">copy</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>allArenas<span class="token punctuation">,</span> oldSlice<span class="token punctuation">)</span>
            <span class="token comment">// Do not free the old backing array because</span>
            <span class="token comment">// there may be concurrent readers. Since we</span>
            <span class="token comment">// double the array each time, this can lead</span>
            <span class="token comment">// to at most 2x waste.</span>
            <span class="token comment">// 不要释放旧的后备阵列，因为可能有并发读取器。</span>
            <span class="token comment">// 由于我们每次将阵列加倍，因此最多可能导致2倍的浪费。</span>
        <span class="token punctuation">}</span>
        h<span class="token punctuation">.</span>allArenas <span class="token operator">=</span> h<span class="token punctuation">.</span>allArenas<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>allArenas<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
        h<span class="token punctuation">.</span>allArenas<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>allArenas<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ri

        <span class="token comment">// Store atomically just in case an object from the</span>
        <span class="token comment">// new heap arena becomes visible before the heap lock</span>
        <span class="token comment">// is released (which shouldn't happen, but there's</span>
        <span class="token comment">// little downside to this).</span>
        <span class="token comment">// 以原子方式存储，以防新的堆空间中的对象在释放堆锁之前可见（这不应该发生，但这没有什么坏处）。</span>
        atomic<span class="token punctuation">.</span><span class="token function">StorepNoWB</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>l2<span class="token punctuation">[</span>ri<span class="token punctuation">.</span><span class="token function">l2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Tell the race detector about the new heap memory.</span>
    <span class="token comment">// 告诉竞态检测器新的堆内存。</span>
    <span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
        <span class="token function">racemapshadow</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token comment">// sysReserveAligned is like sysReserve, but the returned pointer is</span>
<span class="token comment">// aligned to align bytes. It may reserve either n or n+align bytes,</span>
<span class="token comment">// so it returns the size that was reserved.</span>
<span class="token comment">/**
 * sysReserveAligned类似于sysReserve，但是返回的指针以字节对齐。
 * 它可以保留n个或n+align个字节，因此它返回保留的大小。
 * @param v 地址指针
 * @param size 待分配的字节数
 * @param align 对齐的字节数
 * @return unsafe.Pointer 新的地址指针
 * @return uintptr 分配的字节数
 **/</span>
<span class="token keyword">func</span> <span class="token function">sysReserveAligned</span><span class="token punctuation">(</span>v unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> size<span class="token punctuation">,</span> align <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Since the alignment is rather large in uses of this</span>
    <span class="token comment">// function, we're not likely to get it by chance, so we ask</span>
    <span class="token comment">// for a larger region and remove the parts we don't need.</span>
    <span class="token comment">// 由于在使用此功能时对齐方式相当大，因此我们不太可能偶然得到它，</span>
    <span class="token comment">// 因此我们要求更大的区域并删除不需要的部分。</span>
    retries <span class="token operator">:=</span> <span class="token number">0</span>
retry<span class="token punctuation">:</span>
    <span class="token comment">// 先进行未对齐内存保留</span>
    p <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">sysReserve</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> size<span class="token operator">+</span>align<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">switch</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">case</span> p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment">// 未分配成功</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token number">0</span>
    <span class="token keyword">case</span> p<span class="token operator">&amp;</span><span class="token punctuation">(</span>align<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token comment">// We got lucky and got an aligned region, so we can</span>
        <span class="token comment">// use the whole thing.</span>
        <span class="token comment">// 我们很幸运或取到一个对齐区域，所以我们可以使用整个分配的内存。</span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> size <span class="token operator">+</span> align
    <span class="token keyword">case</span> GOOS <span class="token operator">==</span> <span class="token string">"windows"</span><span class="token punctuation">:</span>
        <span class="token comment">// On Windows we can't release pieces of a</span>
        <span class="token comment">// reservation, so we release the whole thing and</span>
        <span class="token comment">// re-reserve the aligned sub-region. This may race,</span>
        <span class="token comment">// so we may have to try again.</span>
        <span class="token comment">// 在Windows上，我们无法释放部分保留内存，因此我们释放整个内容并重新保留对齐的子区域。</span>
        <span class="token comment">// 这可能会生产竞争，所以我们可能必须重试。</span>
        <span class="token function">sysFree</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token operator">+</span>align<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
        p <span class="token operator">=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> align<span class="token punctuation">)</span>
        p2 <span class="token operator">:=</span> <span class="token function">sysReserve</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>
        <span class="token keyword">if</span> p <span class="token operator">!=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// Must have raced. Try again.</span>
            <span class="token comment">// 必定竞争了，需要重试</span>
            <span class="token function">sysFree</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> retries<span class="token operator">++</span><span class="token punctuation">;</span> retries <span class="token operator">==</span> <span class="token number">100</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"failed to allocate aligned heap memory; too many retries"</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">goto</span> retry
        <span class="token punctuation">}</span>
        <span class="token comment">// Success.</span>
        <span class="token keyword">return</span> p2<span class="token punctuation">,</span> size
    <span class="token keyword">default</span><span class="token punctuation">:</span>
        <span class="token comment">// Trim off the unaligned parts.</span>
        <span class="token comment">// 修剪掉未对齐的部分。</span>
        pAligned <span class="token operator">:=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> align<span class="token punctuation">)</span>
        <span class="token comment">// 释放[p, pAligned-1]的内存</span>
        <span class="token function">sysFree</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> pAligned<span class="token operator">-</span>p<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
        end <span class="token operator">:=</span> pAligned <span class="token operator">+</span> size
        endLen <span class="token operator">:=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> size <span class="token operator">+</span> align<span class="token punctuation">)</span> <span class="token operator">-</span> end
        <span class="token keyword">if</span> endLen <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 释放[end, endLen-1]的内存</span>
            <span class="token function">sysFree</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">,</span> endLen<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 返回分配地址和分配大小</span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>pAligned<span class="token punctuation">)</span><span class="token punctuation">,</span> size
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// base address for all 0-byte allocations</span>
<span class="token comment">// 所有0字节分配的基地址</span>
<span class="token keyword">var</span> zerobase <span class="token builtin">uintptr</span>

<span class="token comment">// nextFreeFast returns the next free object if one is quickly available.</span>
<span class="token comment">// Otherwise it returns 0.</span>
<span class="token comment">/**
 * 如果一个可用的对象很快可用，则nextFreeFast返回下一个可用的对象。 否则返回0。
 * @param s 跨度对象
 * @return gclinkptr是指向gclink的指针，但对垃圾收集器不透明。
 **/</span>
<span class="token keyword">func</span> <span class="token function">nextFreeFast</span><span class="token punctuation">(</span>s <span class="token operator">*</span>mspan<span class="token punctuation">)</span> gclinkptr <span class="token punctuation">{<!-- --></span>
    theBit <span class="token operator">:=</span> sys<span class="token punctuation">.</span><span class="token function">Ctz64</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>allocCache<span class="token punctuation">)</span> <span class="token comment">// Is there a free object in the allocCache?</span>
    <span class="token keyword">if</span> theBit <span class="token operator">&lt;</span> <span class="token number">64</span> <span class="token punctuation">{<!-- --></span>
        result <span class="token operator">:=</span> s<span class="token punctuation">.</span>freeindex <span class="token operator">+</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>theBit<span class="token punctuation">)</span>
        <span class="token keyword">if</span> result <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>nelems <span class="token punctuation">{<!-- --></span>
            freeidx <span class="token operator">:=</span> result <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token keyword">if</span> freeidx<span class="token operator">%</span><span class="token number">64</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> freeidx <span class="token operator">!=</span> s<span class="token punctuation">.</span>nelems <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token number">0</span>
            <span class="token punctuation">}</span>
            s<span class="token punctuation">.</span>allocCache <span class="token operator">&gt;&gt;=</span> <span class="token function">uint</span><span class="token punctuation">(</span>theBit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
            s<span class="token punctuation">.</span>freeindex <span class="token operator">=</span> freeidx
            s<span class="token punctuation">.</span>allocCount<span class="token operator">++</span>
            <span class="token keyword">return</span> <span class="token function">gclinkptr</span><span class="token punctuation">(</span>result<span class="token operator">*</span>s<span class="token punctuation">.</span>elemsize <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token comment">// nextFree returns the next free object from the cached span if one is available.</span>
<span class="token comment">// Otherwise it refills the cache with a span with an available object and</span>
<span class="token comment">// returns that object along with a flag indicating that this was a heavy</span>
<span class="token comment">// weight allocation. If it is a heavy weight allocation the caller must</span>
<span class="token comment">// determine whether a new GC cycle needs to be started or if the GC is active</span>
<span class="token comment">// whether this goroutine needs to assist the GC.</span>
<span class="token comment">//</span>
<span class="token comment">// Must run in a non-preemptible context since otherwise the owner of</span>
<span class="token comment">// c could change.</span>
<span class="token comment">/**
 * nextFree从缓存范围中返回下一个空闲对象（如果有）。 否则，它将使用可用对象的跨度重新填充高速缓存，
 * 并返回该对象以及指示这是繁重分配的标志。 如果分配很重，则调用方必须确定是否需要启动新的GC周期，
 * 或者GC是否处于活动状态，因此该例行程序是否需要协助GC。
 *
 * 必须在不可抢占的上下文中运行，因为否则c的所有者可能会更改。
 * @param spc spanClass表示跨度的大小类别和noscan-ness
 * @return v gclinkptr指针
 * @return s 跨度指针
 * @return shouldhelpgc 是否需要gc帮助
 **/</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>mcache<span class="token punctuation">)</span> <span class="token function">nextFree</span><span class="token punctuation">(</span>spc spanClass<span class="token punctuation">)</span> <span class="token punctuation">(</span>v gclinkptr<span class="token punctuation">,</span> s <span class="token operator">*</span>mspan<span class="token punctuation">,</span> shouldhelpgc <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    s <span class="token operator">=</span> c<span class="token punctuation">.</span>alloc<span class="token punctuation">[</span>spc<span class="token punctuation">]</span>
    shouldhelpgc <span class="token operator">=</span> <span class="token boolean">false</span>
    freeIndex <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">nextFreeIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> freeIndex <span class="token operator">==</span> s<span class="token punctuation">.</span>nelems <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// The span is full.</span>
        <span class="token comment">// 跨度已满</span>
        <span class="token keyword">if</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>allocCount<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span>nelems <span class="token punctuation">{<!-- --></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"runtime: s.allocCount="</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>allocCount<span class="token punctuation">,</span> <span class="token string">"s.nelems="</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>nelems<span class="token punctuation">)</span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 重新填充跨度</span>
        c<span class="token punctuation">.</span><span class="token function">refill</span><span class="token punctuation">(</span>spc<span class="token punctuation">)</span>
        <span class="token comment">// 标记需要gc帮助</span>
        shouldhelpgc <span class="token operator">=</span> <span class="token boolean">true</span>
        s <span class="token operator">=</span> c<span class="token punctuation">.</span>alloc<span class="token punctuation">[</span>spc<span class="token punctuation">]</span>

        freeIndex <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">nextFreeIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> freeIndex <span class="token operator">&gt;=</span> s<span class="token punctuation">.</span>nelems <span class="token punctuation">{<!-- --></span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"freeIndex is not valid"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    v <span class="token operator">=</span> <span class="token function">gclinkptr</span><span class="token punctuation">(</span>freeIndex<span class="token operator">*</span>s<span class="token punctuation">.</span>elemsize <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    s<span class="token punctuation">.</span>allocCount<span class="token operator">++</span>
    <span class="token keyword">if</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>allocCount<span class="token punctuation">)</span> <span class="token operator">&gt;</span> s<span class="token punctuation">.</span>nelems <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"s.allocCount="</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>allocCount<span class="token punctuation">,</span> <span class="token string">"s.nelems="</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>nelems<span class="token punctuation">)</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"s.allocCount &gt; s.nelems"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token comment">// Allocate an object of size bytes.</span>
<span class="token comment">// Small objects are allocated from the per-P cache's free lists.</span>
<span class="token comment">// Large objects (&gt; 32 kB) are allocated straight from the heap.</span>
<span class="token comment">/**
 * 分配一个大小为size字节的对象。
 * 从每个P缓存的空闲列表中分配小对象。
 * 从堆直接分配大对象（&gt; 32 kB）。
 * @param size 分配的内存
 * @param needzero
 * @return 分配的地址指针
 **/</span>
<span class="token keyword">func</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>size <span class="token builtin">uintptr</span><span class="token punctuation">,</span> typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> needzero <span class="token builtin">bool</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> gcphase <span class="token operator">==</span> _GCmarktermination <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// _GCmarktermination: GC标记终止：分配黑色，P帮助GC，写屏障启用</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"mallocgc called with gcphase == _GCmarktermination"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 空地址</span>
    <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>zerobase<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> debug<span class="token punctuation">.</span>sbrk <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        align <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> typ <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// TODO(austin): This should be just</span>
            <span class="token comment">//   align = uintptr(typ.align)</span>
            <span class="token comment">// but that's only 4 on 32-bit platforms,</span>
            <span class="token comment">// even if there's a uint64 field in typ (see #599).</span>
            <span class="token comment">// This causes 64-bit atomic accesses to panic.</span>
            <span class="token comment">// Hence, we use stricter alignment that matches</span>
            <span class="token comment">// the normal allocator better.</span>
            <span class="token comment">// TODO(austin)）：这应该只是align = uintptr（typ.align），</span>
            <span class="token comment">// 但即使在typ中有uint64字段，它在32位平台上也只有4（请参阅#599）。</span>
            <span class="token comment">// 这会导致对64位原子访问出现panic。 因此，我们使用更严格的对齐方式来更好地匹配常规分配器。</span>
            <span class="token keyword">if</span> size<span class="token operator">&amp;</span><span class="token number">7</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                align <span class="token operator">=</span> <span class="token number">8</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> size<span class="token operator">&amp;</span><span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                align <span class="token operator">=</span> <span class="token number">4</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> size<span class="token operator">&amp;</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                align <span class="token operator">=</span> <span class="token number">2</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                align <span class="token operator">=</span> <span class="token number">1</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">persistentalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> align<span class="token punctuation">,</span> <span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>other_sys<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// assistG is the G to charge for this allocation, or nil if</span>
    <span class="token comment">// GC is not currently active.</span>
    <span class="token comment">// assistantG是负责此次分配的G，如果GC当前未处于活动状态，则为nil。</span>
    <span class="token keyword">var</span> assistG <span class="token operator">*</span>g
    <span class="token comment">// 如果允许增变辅助和后台标记工作程序将对象变黑，则gcBlackenEnabled为1。</span>
    <span class="token comment">// 仅当gcphase == _GCmark时才可以设置。</span>
    <span class="token keyword">if</span> gcBlackenEnabled <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Charge the current user G for this allocation.</span>
        <span class="token comment">// 获取负责此次分配的g</span>
        assistG <span class="token operator">=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> assistG<span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            assistG <span class="token operator">=</span> assistG<span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg
        <span class="token punctuation">}</span>
        <span class="token comment">// Charge the allocation against the G. We'll account</span>
        <span class="token comment">// for internal fragmentation at the end of mallocgc.</span>
        <span class="token comment">// 我们将在mallocgc末尾统计内部碎片。</span>
        assistG<span class="token punctuation">.</span>gcAssistBytes <span class="token operator">-=</span> <span class="token function">int64</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span>

        <span class="token keyword">if</span> assistG<span class="token punctuation">.</span>gcAssistBytes <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// This G is in debt. Assist the GC to correct</span>
            <span class="token comment">// this before allocating. This must happen</span>
            <span class="token comment">// before disabling preemption.</span>
            <span class="token comment">// 这个G负债中。 协助GC进行更正，然后再分配。 这必须在禁用抢占之前发生。</span>
            <span class="token function">gcAssistAlloc</span><span class="token punctuation">(</span>assistG<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Set mp.mallocing to keep from being preempted by GC.</span>
    <span class="token comment">// Set mp.mallocing to keep from being preempted by GC.</span>
    mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> mp<span class="token punctuation">.</span>mallocing <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 当前m已经在分配内容了</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"malloc deadlock"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 处理信号的g和当前的g是同一个</span>
    <span class="token keyword">if</span> mp<span class="token punctuation">.</span>gsignal <span class="token operator">==</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"malloc during signal"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    mp<span class="token punctuation">.</span>mallocing <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 设当前m正在分配内存</span>

    shouldhelpgc <span class="token operator">:=</span> <span class="token boolean">false</span>
    dataSize <span class="token operator">:=</span> size
    c <span class="token operator">:=</span> <span class="token function">gomcache</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> x unsafe<span class="token punctuation">.</span>Pointer
    noscan <span class="token operator">:=</span> typ <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> typ<span class="token punctuation">.</span>ptrdata <span class="token operator">==</span> <span class="token number">0</span>
    <span class="token keyword">if</span> size <span class="token operator">&lt;=</span> maxSmallSize <span class="token punctuation">{<!-- --></span> <span class="token comment">// 小分配</span>
        <span class="token keyword">if</span> noscan <span class="token operator">&amp;&amp;</span> size <span class="token operator">&lt;</span> maxTinySize <span class="token punctuation">{<!-- --></span> <span class="token comment">// 微小分配</span>
            <span class="token comment">// Tiny allocator.</span>
            <span class="token comment">//</span>
            <span class="token comment">// Tiny allocator combines several tiny allocation requests</span>
            <span class="token comment">// into a single memory block. The resulting memory block</span>
            <span class="token comment">// is freed when all subobjects are unreachable. The subobjects</span>
            <span class="token comment">// must be noscan (don't have pointers), this ensures that</span>
            <span class="token comment">// the amount of potentially wasted memory is bounded.</span>
            <span class="token comment">//</span>
            <span class="token comment">// Size of the memory block used for combining (maxTinySize) is tunable.</span>
            <span class="token comment">// Current setting is 16 bytes, which relates to 2x worst case memory</span>
            <span class="token comment">// wastage (when all but one subobjects are unreachable).</span>
            <span class="token comment">// 8 bytes would result in no wastage at all, but provides less</span>
            <span class="token comment">// opportunities for combining.</span>
            <span class="token comment">// 32 bytes provides more opportunities for combining,</span>
            <span class="token comment">// but can lead to 4x worst case wastage.</span>
            <span class="token comment">// The best case winning is 8x regardless of block size.</span>
            <span class="token comment">//</span>
            <span class="token comment">// Objects obtained from tiny allocator must not be freed explicitly.</span>
            <span class="token comment">// So when an object will be freed explicitly, we ensure that</span>
            <span class="token comment">// its size &gt;= maxTinySize.</span>
            <span class="token comment">//</span>
            <span class="token comment">// SetFinalizer has a special case for objects potentially coming</span>
            <span class="token comment">// from tiny allocator, it such case it allows to set finalizers</span>
            <span class="token comment">// for an inner byte of a memory block.</span>
            <span class="token comment">//</span>
            <span class="token comment">// The main targets of tiny allocator are small strings and</span>
            <span class="token comment">// standalone escaping variables. On a json benchmark</span>
            <span class="token comment">// the allocator reduces number of allocations by ~12% and</span>
            <span class="token comment">// reduces heap size by ~20%.</span>
            <span class="token comment">//</span>
            <span class="token comment">// 微小分配器</span>
            <span class="token comment">//</span>
            <span class="token comment">// 微小分配器 将几个微小的分配请求组合到一个内存块中。当所有子对象均不可访问时，将释放结果存储块。</span>
            <span class="token comment">// 子对象必须是noscan（没有指针），以确保限制可能浪费的内存量。</span>
            <span class="token comment">//</span>
            <span class="token comment">// 用于合并的存储块的大小（maxTinySize）是可调的。当前设置为16个字节，这涉及最坏情况下2倍的内存浪费</span>
            <span class="token comment">// （当除了一个子对象之外的所有其他对象均无法访问时）。8字节完全不会浪费，但是合并的机会更少。 3</span>
            <span class="token comment">// 2字节提供了更多的合并机会，但可能导致最坏情况下4倍浪费。无论块大小如何，最佳案例获胜都是8倍。</span>
            <span class="token comment">//</span>
            <span class="token comment">// 不能显式释放从微小分配器获得的对象。因此，当明确释放对象时，我们确保其大小&gt;=maxTinySize。</span>
            <span class="token comment">//</span>
            <span class="token comment">// SetFinalizer对于可能来自微小分配器的对象具有特殊情况，在这种情况下，它可以为内存块的内部字节设置终结器（finalizers）。</span>
            <span class="token comment">//</span>
            <span class="token comment">// 微小分配器的主要目标是小字符串和独立的转义变量。在json基准上，分配器将分配数量减少了约12％，并将堆大小减少了约20％。</span>
            off <span class="token operator">:=</span> c<span class="token punctuation">.</span>tinyoffset
            <span class="token comment">// Align tiny pointer for required (conservative) alignment.</span>
            <span class="token comment">// 对齐微型指针以进行必需的（保守的）对齐。</span>
            <span class="token keyword">if</span> size<span class="token operator">&amp;</span><span class="token number">7</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                off <span class="token operator">=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>off<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> size<span class="token operator">&amp;</span><span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                off <span class="token operator">=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>off<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> size<span class="token operator">&amp;</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                off <span class="token operator">=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>off<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> off<span class="token operator">+</span>size <span class="token operator">&lt;=</span> maxTinySize <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">.</span>tiny <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// The object fits into existing tiny block.</span>
                <span class="token comment">// 该对象适合现有的微小块。</span>
                x <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>tiny <span class="token operator">+</span> off<span class="token punctuation">)</span>
                c<span class="token punctuation">.</span>tinyoffset <span class="token operator">=</span> off <span class="token operator">+</span> size
                c<span class="token punctuation">.</span>local_tinyallocs<span class="token operator">++</span>
                mp<span class="token punctuation">.</span>mallocing <span class="token operator">=</span> <span class="token number">0</span>
                <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
                <span class="token keyword">return</span> x
            <span class="token punctuation">}</span>
            <span class="token comment">// Allocate a new maxTinySize block.</span>
            <span class="token comment">// 分配一个新的maxTinySize块。</span>
            span <span class="token operator">:=</span> c<span class="token punctuation">.</span>alloc<span class="token punctuation">[</span>tinySpanClass<span class="token punctuation">]</span>
            v <span class="token operator">:=</span> <span class="token function">nextFreeFast</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span>
            <span class="token keyword">if</span> v <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 快速分配没有成功，进行通常规分配</span>
                v<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> shouldhelpgc <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">nextFree</span><span class="token punctuation">(</span>tinySpanClass<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            x <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">uint64</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">uint64</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token comment">// See if we need to replace the existing tiny block with the new one</span>
            <span class="token comment">// based on amount of remaining free space.</span>
            <span class="token comment">// 根据剩余的可用空间量，看看是否需要用新的小块替换现有的小块。</span>
            <span class="token keyword">if</span> size <span class="token operator">&lt;</span> c<span class="token punctuation">.</span>tinyoffset <span class="token operator">||</span> c<span class="token punctuation">.</span>tiny <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                c<span class="token punctuation">.</span>tiny <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
                c<span class="token punctuation">.</span>tinyoffset <span class="token operator">=</span> size
            <span class="token punctuation">}</span>
            size <span class="token operator">=</span> maxTinySize
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 小分配置</span>
            <span class="token keyword">var</span> sizeclass <span class="token builtin">uint8</span>
            <span class="token comment">// 确定大小类别</span>
            <span class="token keyword">if</span> size <span class="token operator">&lt;=</span> smallSizeMax<span class="token operator">-</span><span class="token number">8</span> <span class="token punctuation">{<!-- --></span>
                sizeclass <span class="token operator">=</span> size_to_class8<span class="token punctuation">[</span><span class="token punctuation">(</span>size<span class="token operator">+</span>smallSizeDiv<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span>smallSizeDiv<span class="token punctuation">]</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                sizeclass <span class="token operator">=</span> size_to_class128<span class="token punctuation">[</span><span class="token punctuation">(</span>size<span class="token operator">-</span>smallSizeMax<span class="token operator">+</span>largeSizeDiv<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span>largeSizeDiv<span class="token punctuation">]</span>
            <span class="token punctuation">}</span>
            size <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>class_to_size<span class="token punctuation">[</span>sizeclass<span class="token punctuation">]</span><span class="token punctuation">)</span>
            spc <span class="token operator">:=</span> <span class="token function">makeSpanClass</span><span class="token punctuation">(</span>sizeclass<span class="token punctuation">,</span> noscan<span class="token punctuation">)</span>
            span <span class="token operator">:=</span> c<span class="token punctuation">.</span>alloc<span class="token punctuation">[</span>spc<span class="token punctuation">]</span>
            v <span class="token operator">:=</span> <span class="token function">nextFreeFast</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span>
            <span class="token keyword">if</span> v <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                v<span class="token punctuation">,</span> span<span class="token punctuation">,</span> shouldhelpgc <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">nextFree</span><span class="token punctuation">(</span>spc<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            x <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
            <span class="token keyword">if</span> needzero <span class="token operator">&amp;&amp;</span> span<span class="token punctuation">.</span>needzero <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 大分配</span>
        <span class="token keyword">var</span> s <span class="token operator">*</span>mspan
        shouldhelpgc <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 需要gc帮助</span>
        <span class="token comment">// systemstack在系统堆栈上运行fn。</span>
        <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            s <span class="token operator">=</span> <span class="token function">largeAlloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> needzero<span class="token punctuation">,</span> noscan<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        s<span class="token punctuation">.</span>freeindex <span class="token operator">=</span> <span class="token number">1</span>
        s<span class="token punctuation">.</span>allocCount <span class="token operator">=</span> <span class="token number">1</span>
        x <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        size <span class="token operator">=</span> s<span class="token punctuation">.</span>elemsize
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> scanSize <span class="token builtin">uintptr</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>noscan <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// If allocating a defer+arg block, now that we've picked a malloc size</span>
        <span class="token comment">// large enough to hold everything, cut the "asked for" size down to</span>
        <span class="token comment">// just the defer header, so that the GC bitmap will record the arg block</span>
        <span class="token comment">// as containing nothing at all (as if it were unused space at the end of</span>
        <span class="token comment">// a malloc block caused by size rounding).</span>
        <span class="token comment">// The defer arg areas are scanned as part of scanstack.</span>
        <span class="token comment">// 如果分配一个defer+arg块，现在我们已经选择了一个足够大的malloc大小来容纳所有内容，</span>
        <span class="token comment">// 请将“asked for”大小减小为defer头部，以便GC位图将arg块记录为不包含任何内容</span>
        <span class="token comment">// （好像是由于大小舍入导致的malloc块末尾的未使用空间）。</span>
        <span class="token comment">// 延迟arg区域将作为scanstack的一部分进行扫描。</span>
        <span class="token keyword">if</span> typ <span class="token operator">==</span> deferType <span class="token punctuation">{<!-- --></span>
            dataSize <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>_defer<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 记录数据类型</span>
        <span class="token function">heapBitsSetType</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> dataSize<span class="token punctuation">,</span> typ<span class="token punctuation">)</span>
        <span class="token keyword">if</span> dataSize <span class="token operator">&gt;</span> typ<span class="token punctuation">.</span>size <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// Array allocation. If there are any</span>
            <span class="token comment">// pointers, GC has to scan to the last</span>
            <span class="token comment">// element.</span>
            <span class="token comment">// 数组分配。 如果有任何指针，GC必须扫描到最后一个元素。</span>
            <span class="token keyword">if</span> typ<span class="token punctuation">.</span>ptrdata <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                scanSize <span class="token operator">=</span> dataSize <span class="token operator">-</span> typ<span class="token punctuation">.</span>size <span class="token operator">+</span> typ<span class="token punctuation">.</span>ptrdata
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            scanSize <span class="token operator">=</span> typ<span class="token punctuation">.</span>ptrdata
        <span class="token punctuation">}</span>
        c<span class="token punctuation">.</span>local_scan <span class="token operator">+=</span> scanSize
    <span class="token punctuation">}</span>

    <span class="token comment">// Ensure that the stores above that initialize x to</span>
    <span class="token comment">// type-safe memory and set the heap bits occur before</span>
    <span class="token comment">// the caller can make x observable to the garbage</span>
    <span class="token comment">// collector. Otherwise, on weakly ordered machines,</span>
    <span class="token comment">// the garbage collector could follow a pointer to x,</span>
    <span class="token comment">// but see uninitialized memory or stale heap bits.</span>
    <span class="token comment">// 确保在调用者使x对垃圾收集器可观察之前，将上面的x初始化为类型安全的内存并设置堆存储的位信息。</span>
    <span class="token comment">// 否则，在顺序较弱的计算机上，垃圾收集器可能会跟随指向x的指针，但会看到未初始化的内存或陈旧的堆位。</span>
    <span class="token function">publicationBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// Allocate black during GC.</span>
    <span class="token comment">// All slots hold nil so no scanning is needed.</span>
    <span class="token comment">// This may be racing with GC so do it atomically if there can be</span>
    <span class="token comment">// a race marking the bit.</span>
    <span class="token comment">// 在GC期间分配黑色。 所有槽位均为nill，因此无需扫描。这可能与GC发生争用，</span>
    <span class="token comment">// 因此如果可以进行争夺来标记该位，则可以自动进行。</span>
    <span class="token keyword">if</span> gcphase <span class="token operator">!=</span> _GCoff <span class="token punctuation">{<!-- --></span> <span class="token comment">// go未运行</span>
        <span class="token comment">// gcmarknewobject将新分配的对象标记为黑色。obj不得包含任何非nil指针。</span>
        <span class="token function">gcmarknewobject</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> scanSize<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
        <span class="token function">racemalloc</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> msanenabled <span class="token punctuation">{<!-- --></span>
        <span class="token function">msanmalloc</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    mp<span class="token punctuation">.</span>mallocing <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 标记分配已经完成</span>
    <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span> <span class="token comment">// 释放m</span>

    <span class="token keyword">if</span> debug<span class="token punctuation">.</span>allocfreetrace <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">tracealloc</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> size<span class="token punctuation">,</span> typ<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 设置内存采样</span>
    <span class="token keyword">if</span> rate <span class="token operator">:=</span> MemProfileRate<span class="token punctuation">;</span> rate <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> rate <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> size <span class="token operator">&lt;</span> c<span class="token punctuation">.</span>next_sample <span class="token punctuation">{<!-- --></span>
            c<span class="token punctuation">.</span>next_sample <span class="token operator">-=</span> size
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token function">profilealloc</span><span class="token punctuation">(</span>mp<span class="token punctuation">,</span> x<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
            <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> assistG <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Account for internal fragmentation in the assist</span>
        <span class="token comment">// debt now that we know it.</span>
        <span class="token comment">// 在assist debt中解决内部碎片化问题</span>
        assistG<span class="token punctuation">.</span>gcAssistBytes <span class="token operator">-=</span> <span class="token function">int64</span><span class="token punctuation">(</span>size <span class="token operator">-</span> dataSize<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> shouldhelpgc <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// gcTrigger是用于启动GC循环的动作（predicate）。 具体来说，它是_GCoff阶段的退出条件。</span>
        <span class="token keyword">if</span> t <span class="token operator">:=</span> <span class="token punctuation">(</span>gcTrigger<span class="token punctuation">{<!-- --></span>kind<span class="token punctuation">:</span> gcTriggerHeap<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">gcStart</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> x
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 大内存分配
 * @param
 * @return
 **/</span>
<span class="token keyword">func</span> <span class="token function">largeAlloc</span><span class="token punctuation">(</span>size <span class="token builtin">uintptr</span><span class="token punctuation">,</span> needzero <span class="token builtin">bool</span><span class="token punctuation">,</span> noscan <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token operator">*</span>mspan <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// print("largeAlloc size=", size, "\n")</span>
    <span class="token comment">// 判断是否内存溢出</span>
    <span class="token keyword">if</span> size<span class="token operator">+</span>_PageSize <span class="token operator">&lt;</span> size <span class="token punctuation">{<!-- --></span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"out of memory"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 计算需要分配的页数</span>
    npages <span class="token operator">:=</span> size <span class="token operator">&gt;&gt;</span> _PageShift
    <span class="token keyword">if</span> size<span class="token operator">&amp;</span>_PageMask <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        npages<span class="token operator">++</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Deduct credit for this span allocation and sweep if</span>
    <span class="token comment">// necessary. mHeap_Alloc will also sweep npages, so this only</span>
    <span class="token comment">// pays the debt down to npage pages.</span>
    <span class="token comment">// 扣除此跨度分配的信用，并在必要时进行扫描。 mHeap_Alloc还将清扫npages，因此这只会将债务减少到npage页。</span>
    <span class="token function">deductSweepCredit</span><span class="token punctuation">(</span>npages<span class="token operator">*</span>_PageSize<span class="token punctuation">,</span> npages<span class="token punctuation">)</span>

    <span class="token comment">// mheap_.alloc从GC的堆中分配新的npage页。</span>
    s <span class="token operator">:=</span> mheap_<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span>npages<span class="token punctuation">,</span> <span class="token function">makeSpanClass</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> noscan<span class="token punctuation">)</span><span class="token punctuation">,</span> needzero<span class="token punctuation">)</span>
    <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"out of memory"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    s<span class="token punctuation">.</span>limit <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> size
    <span class="token comment">// heapBitsForAddr返回地址addr的heapBits。</span>
    <span class="token function">heapBitsForAddr</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">initSpan</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token keyword">return</span> s
<span class="token punctuation">}</span>

<span class="token comment">// implementation of new builtin</span>
<span class="token comment">// compiler (both frontend and SSA backend) knows the signature</span>
<span class="token comment">// of this function</span>
<span class="token comment">/**
 * 内建函数new的实现，编译器（前端和SSA后端）都知道此函数的签名
 * @param 类型
 * @return 对象指针
 **/</span>
<span class="token keyword">func</span> <span class="token function">newobject</span><span class="token punctuation">(</span>typ <span class="token operator">*</span>_type<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>typ<span class="token punctuation">.</span>size<span class="token punctuation">,</span> typ<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * reflect包中的unsafe_New实现
 * @param
 * @return
 **/</span>
<span class="token comment">//go:linkname reflect_unsafe_New reflect.unsafe_New</span>
<span class="token keyword">func</span> <span class="token function">reflect_unsafe_New</span><span class="token punctuation">(</span>typ <span class="token operator">*</span>_type<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>typ<span class="token punctuation">.</span>size<span class="token punctuation">,</span> typ<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * internal/reflectlite包中的unsafe_New实现
 * @param
 * @return
 **/</span>
<span class="token comment">//go:linkname reflectlite_unsafe_New internal/reflectlite.unsafe_New</span>
<span class="token keyword">func</span> <span class="token function">reflectlite_unsafe_New</span><span class="token punctuation">(</span>typ <span class="token operator">*</span>_type<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>typ<span class="token punctuation">.</span>size<span class="token punctuation">,</span> typ<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * newarray分配一个类型为typ的n个元素组成的数组。
 * @param
 * @return
 **/</span>
<span class="token comment">// newarray allocates an array of n elements of type typ.</span>
<span class="token keyword">func</span> <span class="token function">newarray</span><span class="token punctuation">(</span>typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>typ<span class="token punctuation">.</span>size<span class="token punctuation">,</span> typ<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 计算数组创建需要分配的内存</span>
    mem<span class="token punctuation">,</span> overflow <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">MulUintptr</span><span class="token punctuation">(</span>typ<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> overflow <span class="token operator">||</span> mem <span class="token operator">&gt;</span> maxAlloc <span class="token operator">||</span> n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">plainError</span><span class="token punctuation">(</span><span class="token string">"runtime: allocation size out of range"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> typ<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * reflect包中的unsafe_NewArray实现
 * @param
 * @return
 **/</span>
<span class="token comment">//go:linkname reflect_unsafe_NewArray reflect.unsafe_NewArray</span>
<span class="token keyword">func</span> <span class="token function">reflect_unsafe_NewArray</span><span class="token punctuation">(</span>typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">newarray</span><span class="token punctuation">(</span>typ<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">profilealloc</span><span class="token punctuation">(</span>mp <span class="token operator">*</span>m<span class="token punctuation">,</span> x unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> size <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    mp<span class="token punctuation">.</span>mcache<span class="token punctuation">.</span>next_sample <span class="token operator">=</span> <span class="token function">nextSample</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">mProf_Malloc</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// nextSample returns the next sampling point for heap profiling. The goal is</span>
<span class="token comment">// to sample allocations on average every MemProfileRate bytes, but with a</span>
<span class="token comment">// completely random distribution over the allocation timeline; this</span>
<span class="token comment">// corresponds to a Poisson process with parameter MemProfileRate. In Poisson</span>
<span class="token comment">// processes, the distance between two samples follows the exponential</span>
<span class="token comment">// distribution (exp(MemProfileRate)), so the best return value is a random</span>
<span class="token comment">// number taken from an exponential distribution whose mean is MemProfileRate.</span>
<span class="token comment">/**
 * nextSample返回用于堆分析的下一个采样点。 目标是在每个MemProfileRate字节抽样平均分配，
 * 但在分配时间轴上具有完全随机的分配； 这对应于带有参数MemProfileRate的泊松过程。
 * 在泊松过程中，两个样本之间的距离遵循指数分布（exp(MemProfileRate)），
 * 因此最佳返回值是取自均值为MemProfileRate的指数分布的随机数。
 * @param
 * @return
 **/</span>
<span class="token keyword">func</span> <span class="token function">nextSample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">uintptr</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> GOOS <span class="token operator">==</span> <span class="token string">"plan9"</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Plan 9 doesn't support floating point in note handler.</span>
        <span class="token keyword">if</span> g <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> g <span class="token operator">==</span> g<span class="token punctuation">.</span>m<span class="token punctuation">.</span>gsignal <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token function">nextSampleNoFP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">fastexprand</span><span class="token punctuation">(</span>MemProfileRate<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// fastexprand returns a random number from an exponential distribution with</span>
<span class="token comment">// the specified mean.</span>
<span class="token comment">/**
 * fastexprand从具有指定平均值的指数分布中返回一个随机数。
 * @param
 * @return
 **/</span>
<span class="token keyword">func</span> <span class="token function">fastexprand</span><span class="token punctuation">(</span>mean <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int32</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Avoid overflow. Maximum possible step is</span>
    <span class="token comment">// -ln(1/(1&lt;&lt;randomBitCount)) * mean, approximately 20 * mean.</span>
    <span class="token comment">// 避免溢出。 最大可能步长为-ln(1/(1&lt;&lt;randomBitCount))*平均值，大约20*平均值。</span>
    <span class="token keyword">switch</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">case</span> mean <span class="token operator">&gt;</span> <span class="token number">0x7000000</span><span class="token punctuation">:</span>
        mean <span class="token operator">=</span> <span class="token number">0x7000000</span>
    <span class="token keyword">case</span> mean <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Take a random sample of the exponential distribution exp(-mean*x).</span>
    <span class="token comment">// The probability distribution function is mean*exp(-mean*x), so the CDF is</span>
    <span class="token comment">// p = 1 - exp(-mean*x), so</span>
    <span class="token comment">// q = 1 - p == exp(-mean*x)</span>
    <span class="token comment">// log_e(q) = -mean*x</span>
    <span class="token comment">// -log_e(q)/mean = x</span>
    <span class="token comment">// x = -log_e(q) * mean</span>
    <span class="token comment">// x = log_2(q) * (-log_e(2)) * mean    ; Using log_2 for efficiency</span>
    <span class="token keyword">const</span> randomBitCount <span class="token operator">=</span> <span class="token number">26</span>
    q <span class="token operator">:=</span> <span class="token function">fastrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>randomBitCount<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
    qlog <span class="token operator">:=</span> <span class="token function">fastlog2</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> randomBitCount
    <span class="token keyword">if</span> qlog <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        qlog <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> minusLog2 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0.6931471805599453</span> <span class="token comment">// -ln(2)</span>
    <span class="token keyword">return</span> <span class="token function">int32</span><span class="token punctuation">(</span>qlog<span class="token operator">*</span><span class="token punctuation">(</span>minusLog2<span class="token operator">*</span><span class="token function">float64</span><span class="token punctuation">(</span>mean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token comment">// nextSampleNoFP is similar to nextSample, but uses older,</span>
<span class="token comment">// simpler code to avoid floating point.</span>
<span class="token comment">/**
 * nextSampleNoFP与nextSample相似，但使用更旧，更简单的代码来避免浮点数。
 * @param
 * @return
 **/</span>
<span class="token keyword">func</span> <span class="token function">nextSampleNoFP</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">uintptr</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Set first allocation sample size.</span>
    rate <span class="token operator">:=</span> MemProfileRate
    <span class="token keyword">if</span> rate <span class="token operator">&gt;</span> <span class="token number">0x3fffffff</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// make 2*rate not overflow</span>
        rate <span class="token operator">=</span> <span class="token number">0x3fffffff</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> rate <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">fastrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token function">uint32</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>rate<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 持久化分配结构
 **/</span>
<span class="token keyword">type</span> persistentAlloc <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    base <span class="token operator">*</span>notInHeap
    off  <span class="token builtin">uintptr</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 全局分配结构
 **/</span>
<span class="token keyword">var</span> globalAlloc <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    mutex
    persistentAlloc
<span class="token punctuation">}</span>

<span class="token comment">// persistentChunkSize is the number of bytes we allocate when we grow</span>
<span class="token comment">// a persistentAlloc.</span>
<span class="token comment">// persistentChunkSize是我们增长persistentAlloc时分配的字节数。256KB</span>
<span class="token keyword">const</span> persistentChunkSize <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span>

<span class="token comment">// persistentChunks is a list of all the persistent chunks we have</span>
<span class="token comment">// allocated. The list is maintained through the first word in the</span>
<span class="token comment">// persistent chunk. This is updated atomically.</span>
<span class="token comment">// psistenceChunks是我们分配的所有持久性块的列表。</span>
<span class="token comment">// 该列表通过持久性块中的第一个字（word）进行维护。 这是原子更新的。</span>
<span class="token keyword">var</span> persistentChunks <span class="token operator">*</span>notInHeap

<span class="token comment">// Wrapper around sysAlloc that can allocate small chunks.</span>
<span class="token comment">// There is no associated free operation.</span>
<span class="token comment">// Intended for things like function/type/debug-related persistent data.</span>
<span class="token comment">// If align is 0, uses default align (currently 8).</span>
<span class="token comment">// The returned memory will be zeroed.</span>
<span class="token comment">//</span>
<span class="token comment">// Consider marking persistentalloc'd types go:notinheap.</span>
<span class="token comment">/**
 * 围绕sysAlloc的包装程序，可以分配小内存块。 没有相关的自由操作。
 * 用于函数/类型/调试相关的持久数据。 如果align为0，则使用默认的align（当前为8）。
 * 返回的内存将被清零。考虑标记为持久分配的类型go:notinheap。
 * @param 
 * @return 
 **/</span>
<span class="token keyword">func</span> <span class="token function">persistentalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> align <span class="token builtin">uintptr</span><span class="token punctuation">,</span> sysStat <span class="token operator">*</span><span class="token builtin">uint64</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> p <span class="token operator">*</span>notInHeap
    <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        p <span class="token operator">=</span> <span class="token function">persistentalloc1</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> align<span class="token punctuation">,</span> sysStat<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 必须在系统堆栈上运行，因为堆栈增长可以（重新）调用它。 请参阅问题9174。
 * @param
 * @return
 **/</span>
<span class="token comment">// Must run on system stack because stack growth can (re)invoke it.</span>
<span class="token comment">// See issue 9174.</span>
<span class="token comment">//go:systemstack</span>
<span class="token keyword">func</span> <span class="token function">persistentalloc1</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> align <span class="token builtin">uintptr</span><span class="token punctuation">,</span> sysStat <span class="token operator">*</span><span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token operator">*</span>notInHeap <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> <span class="token punctuation">(</span>
        <span class="token comment">// Windows上的VM预留粒度为64K</span>
        maxBlock <span class="token operator">=</span> <span class="token number">64</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span> <span class="token comment">// VM reservation granularity is 64K on windows</span>
    <span class="token punctuation">)</span>

    <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"persistentalloc: size == 0"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> align <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> align<span class="token operator">&amp;</span><span class="token punctuation">(</span>align<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"persistentalloc: align is not a power of 2"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> align <span class="token operator">&gt;</span> _PageSize <span class="token punctuation">{<!-- --></span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"persistentalloc: align is too large"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        align <span class="token operator">=</span> <span class="token number">8</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> size <span class="token operator">&gt;=</span> maxBlock <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>notInHeap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">sysAlloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> sysStat<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> persistent <span class="token operator">*</span>persistentAlloc
    <span class="token keyword">if</span> mp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> mp<span class="token punctuation">.</span>p <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        persistent <span class="token operator">=</span> <span class="token operator">&amp;</span>mp<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>palloc
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>globalAlloc<span class="token punctuation">.</span>mutex<span class="token punctuation">)</span>
        persistent <span class="token operator">=</span> <span class="token operator">&amp;</span>globalAlloc<span class="token punctuation">.</span>persistentAlloc
    <span class="token punctuation">}</span>
    persistent<span class="token punctuation">.</span>off <span class="token operator">=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>persistent<span class="token punctuation">.</span>off<span class="token punctuation">,</span> align<span class="token punctuation">)</span>
    <span class="token keyword">if</span> persistent<span class="token punctuation">.</span>off<span class="token operator">+</span>size <span class="token operator">&gt;</span> persistentChunkSize <span class="token operator">||</span> persistent<span class="token punctuation">.</span>base <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        persistent<span class="token punctuation">.</span>base <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>notInHeap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">sysAlloc</span><span class="token punctuation">(</span>persistentChunkSize<span class="token punctuation">,</span> <span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>other_sys<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> persistent<span class="token punctuation">.</span>base <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> persistent <span class="token operator">==</span> <span class="token operator">&amp;</span>globalAlloc<span class="token punctuation">.</span>persistentAlloc <span class="token punctuation">{<!-- --></span>
                <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>globalAlloc<span class="token punctuation">.</span>mutex<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"runtime: cannot allocate memory"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Add the new chunk to the persistentChunks list.</span>
        <span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
            chunks <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>persistentChunks<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>persistent<span class="token punctuation">.</span>base<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> chunks
            <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Casuintptr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>persistentChunks<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> chunks<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>persistent<span class="token punctuation">.</span>base<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">break</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        persistent<span class="token punctuation">.</span>off <span class="token operator">=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">,</span> align<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    p <span class="token operator">:=</span> persistent<span class="token punctuation">.</span>base<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>persistent<span class="token punctuation">.</span>off<span class="token punctuation">)</span>
    persistent<span class="token punctuation">.</span>off <span class="token operator">+=</span> size
    <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
    <span class="token keyword">if</span> persistent <span class="token operator">==</span> <span class="token operator">&amp;</span>globalAlloc<span class="token punctuation">.</span>persistentAlloc <span class="token punctuation">{<!-- --></span>
        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>globalAlloc<span class="token punctuation">.</span>mutex<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> sysStat <span class="token operator">!=</span> <span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>other_sys <span class="token punctuation">{<!-- --></span>
        <span class="token function">mSysStatInc</span><span class="token punctuation">(</span>sysStat<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
        <span class="token function">mSysStatDec</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>other_sys<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p
<span class="token punctuation">}</span>

<span class="token comment">/**
 * inPersistentAlloc报告p是否指向由persistentalloc分配的内存。
 * 由于它是由cgo检查器代码调用的，而后者由写屏障代码调用，因此必须不能拆分。
 * @param
 * @return
 **/</span>
<span class="token comment">// inPersistentAlloc reports whether p points to memory allocated by</span>
<span class="token comment">// persistentalloc. This must be nosplit because it is called by the</span>
<span class="token comment">// cgo checker code, which is called by the write barrier code.</span>
<span class="token comment">//go:nosplit</span>
<span class="token keyword">func</span> <span class="token function">inPersistentAlloc</span><span class="token punctuation">(</span>p <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{<!-- --></span>
    chunk <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Loaduintptr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>persistentChunks<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> chunk <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> p <span class="token operator">&gt;=</span> chunk <span class="token operator">&amp;&amp;</span> p <span class="token operator">&lt;</span> chunk<span class="token operator">+</span>persistentChunkSize <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
        chunk <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

<span class="token comment">// linearAlloc is a simple linear allocator that pre-reserves a region</span>
<span class="token comment">// of memory and then maps that region into the Ready state as needed. The</span>
<span class="token comment">// caller is responsible for locking.</span>
<span class="token comment">/**
 * linearAlloc是一个简单的线性分配器，它可以预先保留一个内存区域，
 * 然后根据需要将该区域映射到“就绪”状态。 调用方负责锁定。
 **/</span>
<span class="token keyword">type</span> linearAlloc <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    next   <span class="token builtin">uintptr</span> <span class="token comment">// next free byte // next free byte</span>
    mapped <span class="token builtin">uintptr</span> <span class="token comment">// one byte past end of mapped space // 映射空间的末尾一个字节</span>
    end    <span class="token builtin">uintptr</span> <span class="token comment">// end of reserved space // 保留空间的结尾</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 初始化线性分配器
 * @param
 * @return
 **/</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>linearAlloc<span class="token punctuation">)</span> <span class="token function">init</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    l<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l<span class="token punctuation">.</span>mapped <span class="token operator">=</span> base<span class="token punctuation">,</span> base
    l<span class="token punctuation">.</span>end <span class="token operator">=</span> base <span class="token operator">+</span> size
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 分配内存
 * @param
 * @return
 **/</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>linearAlloc<span class="token punctuation">)</span> <span class="token function">alloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> align <span class="token builtin">uintptr</span><span class="token punctuation">,</span> sysStat <span class="token operator">*</span><span class="token builtin">uint64</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{<!-- --></span>
    p <span class="token operator">:=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>next<span class="token punctuation">,</span> align<span class="token punctuation">)</span>
    <span class="token keyword">if</span> p<span class="token operator">+</span>size <span class="token operator">&gt;</span> l<span class="token punctuation">.</span>end <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span>
    <span class="token punctuation">}</span>
    l<span class="token punctuation">.</span>next <span class="token operator">=</span> p <span class="token operator">+</span> size
    <span class="token keyword">if</span> pEnd <span class="token operator">:=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>next<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> physPageSize<span class="token punctuation">)</span><span class="token punctuation">;</span> pEnd <span class="token operator">&gt;</span> l<span class="token punctuation">.</span>mapped <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Transition from Reserved to Prepared to Ready.</span>
        <span class="token function">sysMap</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>mapped<span class="token punctuation">)</span><span class="token punctuation">,</span> pEnd<span class="token operator">-</span>l<span class="token punctuation">.</span>mapped<span class="token punctuation">,</span> sysStat<span class="token punctuation">)</span>
        <span class="token function">sysUsed</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>mapped<span class="token punctuation">)</span><span class="token punctuation">,</span> pEnd<span class="token operator">-</span>l<span class="token punctuation">.</span>mapped<span class="token punctuation">)</span>
        l<span class="token punctuation">.</span>mapped <span class="token operator">=</span> pEnd
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * notInHeap是由sysAlloc或persistentAlloc之类的较低级分配器分配的堆外内存。
 *
 * 通常，最好使用标记为go:notinheap的实类型，但这在不可能的情况下（例如在分配器中）用作通用类型。
 *
 * TODO：使用它作为sysAlloc，persistentAlloc等的返回类型吗？
 **/</span>
<span class="token comment">// notInHeap is off-heap memory allocated by a lower-level allocator</span>
<span class="token comment">// like sysAlloc or persistentAlloc.</span>
<span class="token comment">//</span>
<span class="token comment">// In general, it's better to use real types marked as go:notinheap,</span>
<span class="token comment">// but this serves as a generic type for situations where that isn't</span>
<span class="token comment">// possible (like in the allocators).</span>
<span class="token comment">//</span>
<span class="token comment">// TODO: Use this as the return type of sysAlloc, persistentAlloc, etc?</span>
<span class="token comment">//</span>
<span class="token comment">//go:notinheap</span>
<span class="token keyword">type</span> notInHeap <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>notInHeap<span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>bytes <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token operator">*</span>notInHeap <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>notInHeap<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> bytes<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a66a0e8d8d24178330be3654956b66d1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PostGIS实现叠加分析之-Spatial Join (1)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2cd4412a46fc7741b1daa046d4863a3d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LeetCode - 787. K 站中转内最便宜的航班</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>