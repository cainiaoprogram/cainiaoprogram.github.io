<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android自定义View - 优惠卷 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android自定义View - 优惠卷" />
<meta property="og:description" content="前言 在写这个之前也是因为在项目中使用到了类似 优惠卷 的这个东西，然后呢我就在网上找了一些demo看，但是发现他们都存在一些缺陷而且比较单一功能太简单。为什么这么说呢，我给大家说明一下，请看下图：
我发现背景被白色半圆覆盖了，随后翻看了一下Api惊喜的发现有一个设置半圆颜色的，我果断设置了一个transparent，运行一看，连白色的圆角都不见了，变成了一整块 ■ 因为在demo中这个圆角是通过调用 canvas 的 drawCircle 方法被绘制出来的，并且绘制在图层之上，所以无法显示出下面的背景图。而且只提供了半圆这一种图形，所以我说相对比较单一。正因如此我来给大家介绍我的 CouponView 最好的Android优惠卷 。先放几张效果图，再讲解实现过程 1.特点 提供了4种边缘图案（圆形，椭圆，三角，正方）可自定义灵活的api支持以剪裁的方案切入，可展示覆盖在下面的背景图使用模板方法设计模式完成本例 2.效果图 已在 Github 开源：CouponView，欢迎 Star ！
3.实现过程讲解 3.1 类文件结构 DrawModel： CouponModel的父类定义一个绘制的框架控制行为，和初始化Paint等工作。
CouponModel： 实现父类的抽象方法，进行具体的绘制
CouponView： view 继承 FrameLayout 负责接收自定义的属性，和处理相关操作，通过调用 DrawModel的模板方法 drawing()实现边缘图形的绘制
3.2源码分析 先来看CouponView 步骤1： 初始化自定义属性 public CouponView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); if (attrs != null) { TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CouponView, 0, 0); //边缘图形类型 drawType = typedArray.getInt(R.styleable.CouponView_drawShapeType, CIRCLE); //图形与图形之间的间隙 dashGap = typedArray." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a55de226adadad05576d16f5a047b197/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-01T03:02:37+08:00" />
<meta property="article:modified_time" content="2018-06-01T03:02:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android自定义View - 优惠卷</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h2 class="heading">前言</h2> 
 <p>在写这个之前也是因为在项目中使用到了类似<font color="#FF502C"> 优惠卷 </font>的这个东西，然后呢我就在网上找了一些demo看，但是发现他们都存在一些<strong>缺陷</strong>而且比较<strong>单一</strong>功能太简单。为什么这么说呢，我给大家说明一下，请看下图：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 我发现背景被白色半圆覆盖了，随后翻看了一下Api惊喜的发现有一个设置半圆颜色的，我果断设置了一个transparent，运行一看，连白色的圆角都不见了，变成了一整块 
 <font color="#AD5A5A"> ■ </font>因为在demo中这个圆角是通过调用 
 <code><font color="#FF502C"> canvas </font></code> 的 
 <code> <font color="#FF502C"> drawCircle </font></code> 方法被绘制出来的，并且绘制在图层之上，所以无法显示出下面的背景图。而且只提供了半圆这一种图形，所以我说相对比较单一。正因如此我来给大家介绍我的 
 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxwc520%2FCouponView" rel="nofollow">CouponView</a> 最好的Android优惠卷 。先放几张效果图，再讲解实现过程 
 <p></p> 
 <h3 class="heading">1.特点</h3> 
 <ul><li>提供了4种边缘图案（<font color="#FF502C">圆形</font>，<font color="#FF502C">椭圆</font>，<font color="#FF502C">三角</font>，<font color="#FF502C">正方</font>）</li><li>可自定义灵活的api支持</li><li>以剪裁的方案切入，可展示覆盖在下面的背景图</li><li>使用模板方法设计模式完成本例</li></ul> 
 <h3 class="heading">2.效果图</h3> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <blockquote> 
  <p>已在<font color="#FF502C"> Github </font>开源：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxwc520%2FCouponView" rel="nofollow">CouponView</a>，欢迎<font color="#FF502C"> Star </font> ！</p> 
 </blockquote> 
 <h3 class="heading">3.实现过程讲解</h3> 
 <h4 class="heading">3.1 类文件结构</h4> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p><strong>DrawModel：</strong> CouponModel的父类定义一个绘制的框架控制行为，和初始化<code><font color="#FF502C">Paint</font></code>等工作。</p> 
 <p><strong>CouponModel：</strong> 实现父类的抽象方法，进行具体的绘制</p> 
 <p><strong>CouponView：</strong> <code><font color="#FF502C">view</font></code> 继承 FrameLayout 负责接收自定义的属性，和处理相关操作，通过调用 <code><font color="#FF502C">DrawModel</font></code>的模板方法 <code><font color="#FF502C">drawing()</font></code>实现边缘图形的绘制</p> 
 <h4 class="heading">3.2源码分析</h4> 
 <ul><li>先来看CouponView</li></ul> 
 <h5 class="heading">步骤1： 初始化自定义属性</h5> 
 <pre><code class="hljs bash copyable">    public CouponView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        <span class="hljs-keyword">if</span> (attrs != null) {
            TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CouponView, 0, 0);
            //边缘图形类型
            drawType = typedArray.getInt(R.styleable.CouponView_drawShapeType, CIRCLE);
            //图形与图形之间的间隙
            dashGap = typedArray.getDimensionPixelOffset(R.styleable.CouponView_dashGap, 5);
            //半径
            dashWidth = typedArray.getDimensionPixelOffset(R.styleable.CouponView_dashWidth, 10);
            //背景色
            bgc = typedArray.getColor(R.styleable.CouponView_bgc, bgc);

            //虚线的颜色
            lineColor = typedArray.getColor(R.styleable.CouponView_lineColor, Color.WHITE);
            //虚线的宽度
            lineWidth = typedArray.getDimensionPixelOffset(R.styleable.CouponView_lineWidth, dpToPx(2));

            //是否绘制左边边缘的虚线
            isDrawLeftLine = typedArray.getBoolean(R.styleable.CouponView_isDrawLeftLine, <span class="hljs-literal">false</span>);
            isDrawTopLine = typedArray.getBoolean(R.styleable.CouponView_isDrawTopLine, <span class="hljs-literal">false</span>);
            isDrawRightLine = typedArray.getBoolean(R.styleable.CouponView_isDrawRightLine, <span class="hljs-literal">false</span>);
            isDrawBottomLine = typedArray.getBoolean(R.styleable.CouponView_isDrawBottomLine, <span class="hljs-literal">false</span>);

            //是否绘制左边边缘的图形
            isDrawLeftShape = typedArray.getBoolean(R.styleable.CouponView_isDrawLeftShape, <span class="hljs-literal">false</span>);
            isDrawTopShape = typedArray.getBoolean(R.styleable.CouponView_isDrawTopShape, <span class="hljs-literal">false</span>);
            isDrawRightShape = typedArray.getBoolean(R.styleable.CouponView_isDrawRightShape, <span class="hljs-literal">false</span>);
            isDrawBottomShape = typedArray.getBoolean(R.styleable.CouponView_isDrawBottomShape, <span class="hljs-literal">false</span>);

            //虚线距离自身顶部距离
            lineMarginTop = typedArray.getDimensionPixelOffset(R.styleable.CouponView_lineMarginTop, dashWidth);
            lineMarginBottom = typedArray.getDimensionPixelOffset(R.styleable.CouponView_lineMarginBottom, dashWidth);
            lineMarginLeft = typedArray.getDimensionPixelOffset(R.styleable.CouponView_lineMarginLeft, dashWidth);
            lineMarginRight = typedArray.getDimensionPixelOffset(R.styleable.CouponView_lineMarginRight, dashWidth);

            typedArray.recycle();
        }
    }

<span class="copy-code-btn">复制代码</span></code></pre> 
 <h5 class="heading">步骤2：初始化绘制图层&amp;计算边缘图形的数量</h5> 
 <pre><code class="hljs bash copyable">    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);

        initDrawCanvas(w, h);
        calculateItemNum(w, h);
    }
    
   /**
     * 初始化绘制图层
     *
     * @param w
     * @param h
     */
    private void initDrawCanvas(int w, int h) {

        <span class="hljs-keyword">if</span> (getBackground() == null) {//背景为空，设置为透明
            <span class="hljs-built_in">set</span>BackgroundColor(Color.TRANSPARENT);
        }

        // 初始化遮盖图层
        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);

        //1.将Canvas指定区域转换为一个Bitmap对象，或者可以理解为将Bitmap保存到Canvas中
        //2.在onDraw方法里面Canvas将新建这个Bitmap对象，新建一个画布
        mCanvas = new Canvas(mBitmap);
        // 绘制图层颜色
        mCanvas.drawColor(bgc);

        //初始化DrawModel
        drawModel = new CouponModel(this);

        drawModel.setCanvas(mCanvas);
    }
    
    
      /**
     * item数量的 计算公式 ：
     * Num =  ( w - dashGap ) / ( 2 * dashWidth + dashGap);
     */
    public void calculateItemNum(int w, int h) {
        <span class="hljs-keyword">if</span> (isDrawLeftLine || isDrawRightLine || isDrawLeftShape || isDrawRightShape) {
            drawModel.measureVelNum(h);
        }
        <span class="hljs-keyword">if</span> (isDrawTopLine || isDrawBottomLine || isDrawTopShape || isDrawBottomShape) {
            drawModel.measureHorNum(w);
        }
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h5 class="heading">步骤3：绘制锯齿</h5> 
 <pre><code class="hljs bash copyable">    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        //新建一个bitmap进行绘制
        canvas.drawBitmap(mBitmap, 0, 0, null);
        //DrawModel处理绘制
        drawModel.drawing();
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>DrawModel</p> 
 <pre><code class="hljs bash copyable">public abstract class DrawModel {

    protected final CouponView view;

    //item数量
    protected int horItemSize;
    protected int verItemSize;

    //水平方向除item外多余的部分
    protected <span class="hljs-built_in">float</span> horRedundancy;
    //垂直方向除item外多余的部分
    protected <span class="hljs-built_in">float</span> verRedundancy;

    protected Paint shapePaint;
    protected Paint linePaint;

    protected Canvas mCanvas;


    private void <span class="hljs-function"><span class="hljs-title">initPaint</span></span>() {
        //初始化绘制边缘图形的paint
        shapePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        shapePaint.setDither(<span class="hljs-literal">true</span>);
        shapePaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));
        shapePaint.setStyle(Paint.Style.FILL);

        //初始化绘制虚线的paint
        linePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        linePaint.setStyle(Paint.Style.FILL);
        linePaint.setColor(view.getLineColor());
        linePaint.setStrokeWidth(view.getLineWidth());
    }

    public DrawModel(CouponView view) {
        this.view = view;
        initPaint();
    }

    public void <span class="hljs-built_in">set</span>Canvas(Canvas canvas) {
        this.mCanvas = canvas;
    }

    /**
     * 绘制的入口
     */
    public void <span class="hljs-function"><span class="hljs-title">drawing</span></span>() {//模板方法

        <span class="hljs-keyword">if</span> (view.getDrawType() == CIRCLE) {
            drawCircle();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (view.getDrawType() == OVAL) {
            drawOval();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (view.getDrawType() == TRIANGLE) {
            drawTriangle();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (view.getDrawType() == SQUARE) {
            drawSquare();
        }

        <span class="hljs-keyword">if</span> (view.isDrawLeftLine() || view.isDrawRightLine() || view.isDrawTopLine() || view.isDrawTopLine()) {
            drawLine();
        }
    }


    /**
     * 测量垂直item数目
     *
     * @param h
     */
    public void measureVelNum(int h) {
        <span class="hljs-keyword">if</span> (verRedundancy == 0) {
            verRedundancy = (h - view.getDashGap()) % (view.getDashWidth() * 2 + view.getDashGap());
        }
        verItemSize = (h - view.getDashGap()) / (view.getDashWidth() * 2 + view.getDashGap());
    }

    /**
     * 测量水平的item数目
     *
     * @param w
     */
    public void measureHorNum(int w) {
        <span class="hljs-keyword">if</span> (horRedundancy == 0) {
            horRedundancy = (w - view.getDashGap()) % (view.getDashWidth() * 2 + view.getDashGap());
        }
        horItemSize = (w - view.getDashGap()) / (view.getDashWidth() * 2 + view.getDashGap());
    }

    /**
     * 绘制正方形
     */
    protected abstract void drawSquare();

    /**
     * 绘制三角形
     */
    protected abstract void drawTriangle();

    /**
     * 绘制椭圆
     */
    protected abstract void drawOval();

    /**
     * 绘制三角形
     */
    protected abstract void drawCircle();

    /**
     * 绘制虚线
     */
    protected abstract void drawLine();
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>作为模板方法设计模式的父类提供了一个模板方法<code><font color="#FF502C"> drawing() </font></code>实现对基本方法的调度这也是这个设计模式的定义表现，以及初始化<code><font color="#FF502C"> Paint </font></code>和计算出水平方向垂直方向边缘图形的数量。关于设计模式可以参考我的这些文章<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fb0b13614642c" rel="nofollow">那些你要知道的设计模式</a></p> 
 <pre><code class="hljs bash copyable">public class CouponModel extends DrawModel {

    public CouponModel(CouponView view) {
        super(view);
    }

    @Override
    protected void <span class="hljs-function"><span class="hljs-title">drawCircle</span></span>() {

        //遍历垂直方向可绘制size
        <span class="hljs-keyword">for</span> (int i = 0; i &lt; verItemSize; i++) {
            //圆心位置 = 间隙 + item半径 + 垂直方向多余部分/2 + （间隙 + item半径*2） * i
            <span class="hljs-built_in">float</span> y = view.getDashGap() + view.getDashWidth() + verRedundancy / 2 + ((view.getDashGap() + view.getDashWidth() * 2) * i);
            <span class="hljs-keyword">if</span> (view.isDrawLeftShape()) {
                mCanvas.drawCircle(0, y, view.getDashWidth(), shapePaint);
            }
            <span class="hljs-keyword">if</span> (view.isDrawRightShape()) {
                mCanvas.drawCircle(view.getWidth(), y, view.getDashWidth(), shapePaint);
            }
        }

        //遍历水平方向可绘制size
        <span class="hljs-keyword">for</span> (int i = 0; i &lt; horItemSize; i++) {
            <span class="hljs-built_in">float</span> x = view.getDashGap() + view.getDashWidth() + horRedundancy / 2 + ((view.getDashGap() + view.getDashWidth() * 2) * i);
            <span class="hljs-keyword">if</span> (view.isDrawTopShape()) {
                mCanvas.drawCircle(x, 0, view.getDashWidth(), shapePaint);
            }
            <span class="hljs-keyword">if</span> (view.isDrawBottomShape()) {
                mCanvas.drawCircle(x, view.getHeight(), view.getDashWidth(), shapePaint);
            }
        }
    }

    @Override
    protected void <span class="hljs-function"><span class="hljs-title">drawOval</span></span>() {
        <span class="hljs-keyword">for</span> (int i = 0; i &lt; horItemSize; i++) {
            <span class="hljs-built_in">float</span> x = view.getDashGap() + view.getDashWidth() + horRedundancy / 2 + ((view.getDashGap() + view.getDashWidth() * 2) * i);

            RectF rectf = new RectF();
            // 设置椭圆大小
            rectf.left = x - view.getDashWidth();
            rectf.right = x + view.getDashWidth();
            // 绘制上面的椭圆
            <span class="hljs-keyword">if</span> (view.isDrawTopShape()) {
                rectf.top = 0;
                rectf.bottom = view.getDashWidth();
                mCanvas.drawOval(rectf, shapePaint);
            }
            // 绘制下面的椭圆
            <span class="hljs-keyword">if</span> (view.isDrawBottomShape()) {
                rectf.top = view.getHeight() - view.getDashWidth();
                rectf.bottom = view.getHeight();
                mCanvas.drawOval(rectf, shapePaint);
            }
        }

        <span class="hljs-keyword">for</span> (int i = 0; i &lt; verItemSize; i++) {
            <span class="hljs-built_in">float</span> y = view.getDashGap() + view.getDashWidth() + verRedundancy / 2 + ((view.getDashGap() + view.getDashWidth() * 2) * i);
            // 定义椭圆对象
            RectF rectf = new RectF();
            // 设置椭圆大小
            rectf.top = y - view.getDashWidth();
            rectf.bottom = y + view.getDashWidth();
            // 绘制椭圆
            <span class="hljs-keyword">if</span> (view.isDrawLeftShape()) {
                rectf.left = 0;
                rectf.right = view.getDashWidth();
                mCanvas.drawOval(rectf, shapePaint);
            }

            // 绘制椭圆
            <span class="hljs-keyword">if</span> (view.isDrawRightShape()) {
                rectf.left = view.getWidth() - view.getDashWidth();
                rectf.right = view.getWidth();
                mCanvas.drawOval(rectf, shapePaint);
            }
        }
    }

    @Override
    protected void <span class="hljs-function"><span class="hljs-title">drawSquare</span></span>() {

        <span class="hljs-keyword">for</span> (int i = 0; i &lt; verItemSize; i++) {
            <span class="hljs-built_in">float</span> y = view.getDashGap() + view.getDashWidth() + verRedundancy / 2 + ((view.getDashGap() + view.getDashWidth() * 2) * i);

            RectF rectf = new RectF();
            // 设置正方形大小
            rectf.top = y - view.getDashWidth() / 2;
            rectf.bottom = y + view.getDashWidth();

            // 如果isDrawLeftSide为<span class="hljs-literal">true</span>
            <span class="hljs-keyword">if</span> (view.isDrawLeftShape()) {
                rectf.left = 0;
                rectf.right = view.getDashWidth() ;
                mCanvas.drawRect(rectf, shapePaint);
            }

            <span class="hljs-keyword">if</span> (view.isDrawRightShape()) {
                rectf.left = view.getWidth() - view.getDashWidth();
                rectf.right = view.getWidth();
                mCanvas.drawRect(rectf, shapePaint);
            }
        }

        <span class="hljs-keyword">for</span> (int i = 0; i &lt; horItemSize; i++) {
            <span class="hljs-built_in">float</span> x = view.getDashGap() + view.getDashWidth() + horRedundancy / 2 + ((view.getDashGap() + view.getDashWidth() * 2) * i);
            mCanvas.drawRect(0, x, 0, view.getDashWidth(), shapePaint);

            RectF rectf = new RectF();
            // 设置正方形大小
            rectf.left = x - view.getDashWidth() / 2;
            rectf.right = x + view.getDashWidth() ;

            // 如果isDrawTopSide为<span class="hljs-literal">true</span>
            <span class="hljs-keyword">if</span> (view.isDrawTopShape()) {
                rectf.top = 0;
                rectf.bottom = view.getDashWidth();
                mCanvas.drawRect(rectf, shapePaint);
            }

            <span class="hljs-keyword">if</span> (view.isDrawBottomShape()) {
                rectf.top = view.getHeight() - view.getDashWidth();
                rectf.bottom = view.getHeight();
                mCanvas.drawRect(rectf, shapePaint);
            }
        }
    }

    @Override
    protected void <span class="hljs-function"><span class="hljs-title">drawTriangle</span></span>() {
        <span class="hljs-keyword">for</span> (int i = 0; i &lt; verItemSize; i++) {
            <span class="hljs-built_in">float</span> y = view.getDashGap() + view.getDashWidth() + verRedundancy / 2 + ((view.getDashGap() + view.getDashWidth() * 2) * i);

            Path path = new Path();
            //如果isDrawLeftSide为<span class="hljs-literal">true</span>
            <span class="hljs-keyword">if</span> (view.isDrawLeftShape()) {
                // 设置三角形的点
                path.moveTo(0, y - view.getDashWidth());
                path.lineTo(0, y + view.getDashWidth());
                path.lineTo(view.getDashWidth(), y);
                path.close();
                mCanvas.drawPath(path, shapePaint);
            }

            <span class="hljs-keyword">if</span> (view.isDrawRightShape()) {
                path.moveTo(view.getWidth(), y - view.getDashWidth());
                path.lineTo(view.getWidth(), y + view.getDashWidth());
                path.lineTo(view.getWidth() - view.getDashWidth(), y);
                path.close();
                mCanvas.drawPath(path, shapePaint);
            }
        }

        <span class="hljs-keyword">for</span> (int i = 0; i &lt; horItemSize; i++) {
            <span class="hljs-built_in">float</span> x = view.getDashGap() + view.getDashWidth() + horRedundancy / 2 + ((view.getDashGap() + view.getDashWidth() * 2) * i);

            Path path = new Path();
            //如果isDrawTopSide为<span class="hljs-literal">true</span>
            <span class="hljs-keyword">if</span> (view.isDrawTopShape()) {
                // 设置三角形的点
                path.moveTo(x - view.getDashWidth(), 0);
                path.lineTo(x + view.getDashWidth(), 0);
                path.lineTo(x, view.getDashWidth());
                path.close();
                mCanvas.drawPath(path, shapePaint);
            }

            <span class="hljs-keyword">if</span> (view.isDrawBottomShape()) {
                path.moveTo(x - view.getDashWidth(), view.getHeight());
                path.lineTo(x + view.getDashWidth(), view.getHeight());
                path.lineTo(x, view.getHeight() - view.getDashWidth());
                path.close();
                mCanvas.drawPath(path, shapePaint);
            }
        }
    }

    @Override
    protected void <span class="hljs-function"><span class="hljs-title">drawLine</span></span>() {

        //遍历垂直方向可绘制size
        <span class="hljs-keyword">for</span> (int i = 0; i &lt; verItemSize; i++) {
            //圆心位置 = 间隙 + item半径 + 垂直方向多余部分/2 + （间隙 + item半径*2） * i
            <span class="hljs-built_in">float</span> y = view.getDashGap() + view.getDashWidth() + verRedundancy / 2 + ((view.getDashGap() + view.getDashWidth() * 2) * i);
            <span class="hljs-keyword">if</span> (view.isDrawLeftLine()) {
                mCanvas.drawLine(view.getLineMarginLeft(), y - view.getDashWidth(), view.getLineMarginLeft(), y + view.getDashWidth(), linePaint);
            }
            <span class="hljs-keyword">if</span> (view.isDrawRightLine()) {
                mCanvas.drawLine(view.getWidth() - view.getLineMarginRight(), y - view.getDashWidth(), view.getWidth() - view.getLineMarginRight(), y + view.getDashWidth(), linePaint);
            }
        }

        //遍历水平方向可绘制size
        <span class="hljs-keyword">for</span> (int i = 0; i &lt; horItemSize; i++) {
            <span class="hljs-built_in">float</span> x = view.getDashGap() + view.getDashWidth() + horRedundancy / 2 + ((view.getDashGap() + view.getDashWidth() * 2) * i);
            <span class="hljs-keyword">if</span> (view.isDrawTopLine()) {
                mCanvas.drawLine(x - view.getDashWidth(), view.getLineMarginTop(), x + view.getDashWidth(), view.getLineMarginTop(), linePaint);
            }
            <span class="hljs-keyword">if</span> (view.isDrawBottomLine()) {
                mCanvas.drawLine(x - view.getDashWidth(), view.getHeight() - view.getLineMarginBottom(), x + view.getDashWidth(), view.getHeight() - view.getLineMarginBottom(), linePaint);
            }
        }
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>作为子类实现父类中定义的基本方法，绘制<strong>圆形</strong>，<strong>椭圆</strong>，<strong>三角</strong>，<strong>正方</strong>还有<strong>虚线</strong>。通过遍历边缘图形的数量size大小，结合自定义属性中的<code><font color="#FF502C"> dashGap </font></code>间隙，<code><font color="#FF502C"> dashWidthcode </font></code>半径，和在<code><font color="#FF502C"> CouponView </font></code>的<code><font color="#FF502C"> onSizeChanged </font></code>方法中计算得出冗余部分的宽度，确定每个边缘图形的坐标位置进行绘制。</p> 
 <hr> 
 <blockquote> 
  <p>至此，该优惠卷View控件源码分析完毕。感谢阅读！</p> 
 </blockquote> 
 <blockquote> 
  <p>完整源码地址：https://github.com/xwc520/CouponView</p> 
 </blockquote> 
 <blockquote> 
  <p>已在<font color="#FF502C"> Github </font>开源：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxwc520%2FCouponView" rel="nofollow">CouponView</a>，欢迎<font color="#FF502C"> 留言， Star </font> ！</p> 
 </blockquote> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba193ed061439aa3d8cb167065ca5d2f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">django 实现将本地图片存入数据库，并能显示在web上</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c9fdb95486f11bc0cb54a0ec2a66f6b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RecyclerView拖拽排序；</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>