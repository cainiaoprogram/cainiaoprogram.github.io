<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>轻松学懂图（下）——Dijkstra和Bellman-Ford算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="轻松学懂图（下）——Dijkstra和Bellman-Ford算法" />
<meta property="og:description" content="概述 ​ 在上一篇文章中讲述了Kruskal和Prim算法，用于得到最小生成树，今天将会介绍两种得到最短路径的算法——Dijlkstra和Bellman-Ford算法
Dijkstra算法 算法的特点： 属于单源最短路径算法，什么是单源呢，通俗的说也就是一个起点，该算法一次只能得到一个点到其他点的最短路径。限制条件：图中不能有负权边。也就是图中不能有权值为负数的边 上面的特点在我讲完这个算法的思想之后你就会明白为什么了。
算法思想：
这个算法的思想其实特别贴近生活，如果你把每个点都想象成一个小石头，每个边都想成一根绳子，边的权值表示绳长。然后，我们选择其中一个石头，作为第一个从地上被拉起来的，将其慢慢地从地上拿起来，之后肯定会有一个离它最近的小石头也会被拉起来，就这样不断往上提，最终所有石头都会被提起来。好了，说完了这个例子后，我想问你一个比较常识性的问题：除了第一块石头外，每块被拉起来的石头是否都是被前一个被拉起来的石头所拉起来的？当你相通了这个，后面当我解释过程的时候就好说了
​
我们先来看一下下面这个例子：我们以A为起点，按照我们之前的例子去挨个提起来:
​ 过程：
​ 上面是使用该算法的一个过程图，我们现在来对其进行一个解释，并且，为了方便记录最短路径，我会用一个表来记录最短路径
以A为源点，并且将A点所直接指向的顶点的路径信息记录到该表中。从图中不难看出提起来的第一块石头是B，它是被A提起来的，因此更新A到B的最短路径信息，我们发现和原来是一样的
终点最短路径长度BA -&gt; B10C∞DA -&gt; D30EA -&gt; E100 接下来，下一个被踢起来的是D，它是被A提起来的，更新其最短路径，更新后的路径信息也是和原来一样
终点最短路径长度BA -&gt; B10C∞DA -&gt; D30EA -&gt; E100 很明显，下一个被踢起来的是C，它是被谁提起来的呢？看一下图就知道，它是被D所提起来的。为什么我总是强调是被谁提起来的这个问题呢？还记得我之前在说思想的时候说过的问题吗？正是因为每个被提起来的石头都是被上一个已经被提起的石头所提起来的，所以他的最短路径就是，提起他的那块石头的最短路径再到达当前被提起的石头的最短路径就是当前石头的最短路径了。
如果听着有点蒙，我们用这一步的这个例子给你说明一下，当前C被D所提起来，因此A到C的最短路径就是A到D的最短路径加上D到C的最短路径，权值也是在上一条路径的基础上进行相加得到的。我们发现此时的路径信息50要小于一开始的路径长度∞，因此更新后最短路径信息就变成了下面这样了
终点最短路径长度BA -&gt; B10CA -&gt; D -&gt; C50DA -&gt; D30EA -&gt; E100 再往后就是最后一步了，E点被提起，它是被C所提起来的，并且此时的最短路径长度比表中的原来的路径长度要短，因此进行更新
终点最短路径长度BA -&gt; B10CA -&gt; D -&gt; C50DA -&gt; D30EA -&gt; D -&gt; C -&gt; E60 至此，就得到了以A为起点到达其他点的最短路径信息了
参考代码（部分）
- /** * Dijkstra算法，原理：每个节点当做石头，每个边当做绳子，然后把往上拉 * * 限制条件：图中不能有负权边，不然可能会出现，某个点被提起来之后，又发现了可以到达它的更短的边 * 也可以理解为，在选起点后，就存在某条权值为负数的路径，就是说已经被提起来了 * * @return V - PathInfo * PathInfo中存的是List&lt;EdgeInfo&lt;V, E&gt; 和 weight */ @Override public Map&lt;V, PathInfo&lt;V, E&gt;&gt; dijkstra(V begin) { // 拿到起点 Vertex&lt;V, E&gt; beginVertex = vertices." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3f582f76eb893098b004ecb9834a30d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-25T12:10:25+08:00" />
<meta property="article:modified_time" content="2021-04-25T12:10:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">轻松学懂图（下）——Dijkstra和Bellman-Ford算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <h4><a id="_2"></a>概述</h4> 
</blockquote> 
<p>​ 在上一篇文章中讲述了Kruskal和Prim算法，用于得到最小生成树，今天将会介绍两种得到最短路径的算法——Dijlkstra和Bellman-Ford算法</p> 
<blockquote> 
 <h4><a id="Dijkstra_8"></a>Dijkstra算法</h4> 
</blockquote> 
<ul><li><strong>算法的特点</strong>： 
  <ul><li>属于单源最短路径算法，什么是单源呢，通俗的说也就是一个起点，该算法一次只能得到一个点到其他点的最短路径。</li><li>限制条件：图中不能有负权边。也就是图中不能有权值为负数的边</li></ul> </li></ul> 
<p>上面的特点在我讲完这个算法的思想之后你就会明白为什么了。</p> 
<ul><li> <p><strong>算法思想</strong>：</p> <p>这个算法的思想其实特别贴近生活，如果你把每个点都想象成一个小石头，每个边都想成一根绳子，边的权值表示绳长。然后，我们选择其中一个石头，作为第一个从地上被拉起来的，将其慢慢地从地上拿起来，之后肯定会有一个离它最近的小石头也会被拉起来，就这样不断往上提，最终所有石头都会被提起来。好了，说完了这个例子后，我想问你一个比较常识性的问题：除了第一块石头外，每块被拉起来的石头是否都是被前一个被拉起来的石头所拉起来的？当你相通了这个，后面当我解释过程的时候就好说了</p> <p>​</p> <p>我们先来看一下下面这个例子：我们以A为起点，按照我们之前的例子去挨个提起来:</p> </li></ul> 
<p><img src="https://images2.imgbox.com/70/38/EtWyAi0W_o.png" alt="在这里插入图片描述"></p> 
<p>​ 过程：</p> 
<p>​ <img src="https://images2.imgbox.com/00/48/3sflNXCf_o.png" alt="在这里插入图片描述"></p> 
<p>上面是使用该算法的一个过程图，我们现在来对其进行一个解释，并且，为了方便记录最短路径，我会用一个表来记录最短路径</p> 
<ol><li> <p>以A为源点，并且将A点所直接指向的顶点的路径信息记录到该表中。从图中不难看出提起来的第一块石头是B，它是被A提起来的，因此更新A到B的最短路径信息，我们发现和原来是一样的</p> 
  <table><thead><tr><th align="center">终点</th><th align="center">最短路径</th><th align="center">长度</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">A -&gt; B</td><td align="center">10</td></tr><tr><td align="center">C</td><td align="center"></td><td align="center">∞</td></tr><tr><td align="center">D</td><td align="center">A -&gt; D</td><td align="center">30</td></tr><tr><td align="center">E</td><td align="center">A -&gt; E</td><td align="center">100</td></tr></tbody></table></li><li> <p>接下来，下一个被踢起来的是D，它是被A提起来的，更新其最短路径，更新后的路径信息也是和原来一样</p> 
  <table><thead><tr><th align="center">终点</th><th align="center">最短路径</th><th align="center">长度</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">A -&gt; B</td><td align="center">10</td></tr><tr><td align="center">C</td><td align="center"></td><td align="center">∞</td></tr><tr><td align="center">D</td><td align="center">A -&gt; D</td><td align="center">30</td></tr><tr><td align="center">E</td><td align="center">A -&gt; E</td><td align="center">100</td></tr></tbody></table></li><li> <p>很明显，下一个被踢起来的是C，它是被谁提起来的呢？看一下图就知道，它是被D所提起来的。为什么我总是强调是被谁提起来的这个问题呢？还记得我之前在说思想的时候说过的问题吗？正是因为每个被提起来的石头都是被上一个已经被提起的石头所提起来的，所以他的最短路径就是，提起他的那块石头的最短路径再到达当前被提起的石头的最短路径就是当前石头的最短路径了。</p> <p>如果听着有点蒙，我们用这一步的这个例子给你说明一下，当前C被D所提起来，因此A到C的最短路径就是A到D的最短路径加上D到C的最短路径，权值也是在上一条路径的基础上进行相加得到的。我们发现此时的路径信息50要小于一开始的路径长度∞，因此更新后最短路径信息就变成了下面这样了</p> 
  <table><thead><tr><th align="center">终点</th><th align="center">最短路径</th><th align="center">长度</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">A -&gt; B</td><td align="center">10</td></tr><tr><td align="center">C</td><td align="center">A -&gt; D -&gt; C</td><td align="center">50</td></tr><tr><td align="center">D</td><td align="center">A -&gt; D</td><td align="center">30</td></tr><tr><td align="center">E</td><td align="center">A -&gt; E</td><td align="center">100</td></tr></tbody></table></li><li> <p>再往后就是最后一步了，E点被提起，它是被C所提起来的，并且此时的最短路径长度比表中的原来的路径长度要短，因此进行更新</p> 
  <table><thead><tr><th align="center">终点</th><th align="center">最短路径</th><th align="center">长度</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">A -&gt; B</td><td align="center">10</td></tr><tr><td align="center">C</td><td align="center">A -&gt; D -&gt; C</td><td align="center">50</td></tr><tr><td align="center">D</td><td align="center">A -&gt; D</td><td align="center">30</td></tr><tr><td align="center">E</td><td align="center">A -&gt; D -&gt; C -&gt; E</td><td align="center">60</td></tr></tbody></table></li><li> <p>至此，就得到了以A为起点到达其他点的最短路径信息了</p> </li></ol> 
<ul><li> <p><strong>参考代码（部分）</strong></p> <pre><code class="prism language-java"><span class="token operator">-</span> 

    <span class="token comment">/**
         * Dijkstra算法，原理：每个节点当做石头，每个边当做绳子，然后把往上拉
         * 
         * 限制条件：图中不能有负权边，不然可能会出现，某个点被提起来之后，又发现了可以到达它的更短的边
         * 也可以理解为，在选起点后，就存在某条权值为负数的路径，就是说已经被提起来了
         *
         * @return V - PathInfo
         * PathInfo中存的是List&lt;EdgeInfo&lt;V, E&gt; 和 weight
         */</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> PathInfo<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span><span class="token operator">&gt;</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span>V begin<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 拿到起点</span>
            Vertex<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span> beginVertex <span class="token operator">=</span> vertices<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> null<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 返回结果</span>
            Map<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> PathInfo<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span><span class="token operator">&gt;</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 未拿起来的顶点</span>
            Map<span class="token operator">&lt;</span>Vertex<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> PathInfo<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span><span class="token operator">&gt;</span> paths <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
            <span class="token comment">// 初始化paths里面一开始只有A-&gt;A weight=0这样一条路劲，然后进入下面的循环进行松弛</span>
            paths<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">PathInfo</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>weightManager<span class="token punctuation">.</span><span class="token function">zero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>paths<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 选择一个最短路径所到达的顶点</span>
                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Vertex<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> PathInfo<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span><span class="token operator">&gt;</span> minEntry <span class="token operator">=</span> <span class="token function">getMinPath</span><span class="token punctuation">(</span>paths<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 松弛操作</span>
                <span class="token comment">// 拿到顶点，即一块“石头”被提起</span>
                Vertex<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span> minVertex <span class="token operator">=</span> minEntry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 拿到当前最短边的PathInfo</span>
                PathInfo<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span> minPathInfo <span class="token operator">=</span> minEntry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 加入到result中</span>
                result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>minVertex<span class="token punctuation">.</span>value<span class="token punctuation">,</span> minEntry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 从paths中删除</span>
                paths<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>minVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 遍历该顶点的outEdges并试着更新边的to，这里遍历不能用foreach，否则不能continue</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>Edge<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span> edge <span class="token operator">:</span> minVertex<span class="token punctuation">.</span>outEdges<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 为了适用于无向图，也要判断to指向的顶点是否已经被“提起”过，避免重复遍历</span>
                    <span class="token comment">// 如果是begin则跳过，不能加到result中，在此处判断或者在返回前将其删除</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token keyword">continue</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token function">relaxForDijkstra</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span> paths<span class="token punctuation">,</span> minPathInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 将起点从结果中移除</span>
            result<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

</code></pre> <p>代码中注释部分的<code>松弛操作</code>指的是提石头并更新最短路径信息。</p> </li><li> <p><strong>小结</strong></p> <p>回顾之前的算法特点，我们回答一下为什么不能有负权边这个问题，其实就利用这个算法的提石头思想就可以解释，提石头的时候绳子的长度不能肯定不能是负的，如果是负的，那该算法就解决不了了，因为</p> <p>​</p> </li></ul> 
<blockquote> 
 <h3><a id="BellmanFord_147"></a>Bellman-Ford算法</h3> 
</blockquote> 
<ul><li> <p><strong>算法特点</strong></p> 
  <ul><li>也属于单源最短路径算法，能检测负权环（指的是存在至少一条负权边的环）是否存在</li><li>支持负权边的存在</li></ul> </li><li> <p><strong>算法思想</strong></p> 
  <ul><li>和上面的提石头思想比起来，这个算法更像是把所有的路都走好几遍，走熟悉了也就知道怎么走最近了，这怎么理解呢？也可以理解为生活中的一类例子——见下图，比如，某人来到一个陌生的地方，他家住在A处，并且每周都会按照1、2、3、4、5的顺序座别人车经过某条路，并且在这个过程中它会留意从家出发到这里最近的路（一开始肯定是什么都不知道的），现在，他第一次来到这个陌生的地方，按照顺序，先座车从B到E，但是它现在都还不知道从家到B最近是多少，所以到E也就不知道，以此类推，直到第三次从A到C，它发现是从他家出发的，距离为5，此时他就知道了<strong>从A到C的最短路径是5</strong>，同理，到第五步的时候，他知道了<strong>从A到B的最短路径是9</strong>，接着到下一周，当经过从B到E这条路的时候，此时因为它知道从A到B的最短路径，所以，也就知道了<strong>从A到E的最短路径是17</strong>，接下来，同理，知道了<strong>从C到D的最短路径是8</strong>，，<strong>从A到E的最短路径是9</strong>，当走B到D这条路径的时候需要注意了，此时又发现了一条从A到B再到D的路径，长度是15，原来已经知道了从A到D的最短路径是8，因此最短路径不更新。就这样，<strong>直到有一周发现没有任何新的最短路径信息的时候，说明目前掌握的信息就是正确的最短路径信息了</strong>。这其实就是该算法的思想，通俗的说就是不断的去试</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/ea/f2/0nl8W9ZM_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>代码（部分）</p> <pre><code class="prism language-java"><span class="token keyword">public</span> Map<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> PathInfo<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span><span class="token operator">&gt;</span> <span class="token function">bellmanFord</span><span class="token punctuation">(</span>V begin<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 拿到起点</span>
        Vertex<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span> beginVertex <span class="token operator">=</span> vertices<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 初始化: 返回结果</span>
        Map<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> PathInfo<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span><span class="token operator">&gt;</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 初始化起点，并放入result中</span>
        PathInfo<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span> beginPathInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PathInfo</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        beginPathInfo<span class="token punctuation">.</span>weight <span class="token operator">=</span> weightManager<span class="token punctuation">.</span><span class="token function">zero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> beginPathInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 因为每次最少会找到一条，所以理论上最多循环V-1次就可以找到所有的</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        PathInfo<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span> fromPathInfo<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>Edge<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 松弛操作，最开始这里可能为空，因此需要初始化起点并放入result</span>
                fromPathInfo <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>from<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">relax</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span> result<span class="token punctuation">,</span> fromPathInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 再循环一次，判断是否有负权环，如果还有边可以进行松弛操作说明存在负权环</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Edge<span class="token generics function"><span class="token punctuation">&lt;</span>V<span class="token punctuation">,</span> E<span class="token punctuation">&gt;</span></span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 松弛操作，最开始这里可能为空，因此需要初始化起点并放入result</span>
            fromPathInfo <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>from<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">relax</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span> result<span class="token punctuation">,</span> fromPathInfo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"存在负权环"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> null<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 将起点从结果中移除</span>
        result<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <p>​ 解释： 该算法的原理就是按照一定的顺序将所有的路径不断的重复遍历，每次遍历都会通过搜对边进行松弛操作来发现最少一条最短路径，直到某次循环没有再发现新的最短路径的时候，这个时候说明最短路径已经都找到了，次时算法结束。也许你会对这个结束的条件有点疑惑，我们可以举个例子，假如某次循环更新了一条最短路径，那么是不是有可能该路径后面的路径也会发生变化呢？是不是要再次去遍历？当然要！</p> <p>和上面的Dijkstra算法相似的是，都会维护一个数据结构用于保存最短路径信息，并且都是不断地去遍历路径。不一样的是遍历的方式有所不同，对于前者，每次找确定的边的时候都是找最短的那一条，确定了的边下次不会再去循环。对于后者，就按照一定的顺序去进行松弛即可，实现起来相对较简单。</p> <p>还有一个问题还没有说，就是<strong>Bellman-Ford算法是如何检测负权环的？<strong>我们不妨先假设，有负权环 会怎么样：首先，负权环因为环路的总权值是负的，所以每走一圈，路径长度就会减少，每次松弛都会减 少，因此每次循环都会伴随着至少一次以上的最短路径信息更新操作。之前我们也说了，每次循环至少会 找到一条最短路径，那么如果要找到所有的最短路径，那么</strong>遍历的次数一定是有限的！</strong>，但是有负权环的 情况下就回无限循环，所以我们<strong>可根据循环次数来判断是否存在负权环！</strong></p> </li></ul> 
<blockquote> 
 <h3><a id="_215"></a>总结</h3> 
</blockquote> 
<p><strong>我们不妨先假设，有负权环 会怎么样：首先，负权环因为环路的总权值是负的，所以每走一圈，路径长度就会减少，每次松弛都会减 少，因此每次循环都会伴随着至少一次以上的最短路径信息更新操作。之前我们也说了，每次循环至少会 找到一条最短路径，那么如果要找到所有的最短路径，那么</strong>遍历的次数一定是有限的！<strong>，但是有负权环的 情况下就回无限循环，所以我们</strong>可根据循环次数来判断是否存在负权环！**</p> 
<blockquote> 
 <h3><a id="_221"></a>总结</h3> 
</blockquote> 
<p>​ 本次学习了Dijkstra算法和Bellman-Ford算法，两种算法各有各的特点，前者不能存在负权边，后者可以允许负权边，并且可以检测负权环。前者是提石头的思想，后者则是不断的去重复走，直至熟悉所有最短路径</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/17417ce5f7709f9713854dd175adca73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一款功能强大的开源excel在线表格</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c8ffeddf1f19bbbea5e514a7d79356e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">obs无法录屏或无法保存视频的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>