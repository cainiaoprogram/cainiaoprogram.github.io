<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue 父子组件传值&amp;自定义事件 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue 父子组件传值&amp;自定义事件" />
<meta property="og:description" content="因为vue 的数据是单向流动的，这是为了避免数据污染。在官方文档中也说到：所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
大致归纳一下：父传子--传值、子传父--传事件
父传子：父组件可以传递任何类型的数据给子组件
如果传递的数据是对象格式的，那么在子组件 内部监听 watch 的时候，需要使用深度监听，也就是添加 deep ： true ，也就是下面的子组件的监听方式，如果是别的格式的，例如，字符串、数字、布尔值、 数组格式等，那就是普通监听就好了
父组件代码：在父组件中 通过 v-bind 的缩写形式 :listData=&#39;listData&#39; 绑定了data 内部的数据，第一个 listData 只是一个名字，为了方便辨认，所以写的相同。 第二个 listData 则是 data 内部的数据
&lt;template&gt; &lt;div&gt; &lt;h3&gt;我是father&lt;/h3&gt; &lt;Children :listData=&#39;listData&#39; :xxx=&#39;xxx&#39; :listObj=&#39;listObj&#39;&gt;&lt;/Children&gt; //子组件传递了一个数组、一个字符串、一个对象 &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Children from &#39;./children&#39; //引入子组件 export default { data () { return { xxx:&#39;123&#39;, listData: [{ id: 1, name: &#34;TCL彩电&#34;, price: 1000, num: 1, img: &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f49418ca065fb5e2f70c00599a6b6e8a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-31T11:48:07+08:00" />
<meta property="article:modified_time" content="2023-07-31T11:48:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue 父子组件传值&amp;自定义事件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>因为vue 的数据是单向流动的，这是为了避免数据污染。在官方文档中也说到：所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p> 
<p><strong>大致归纳一下：父传子--传值、子传父--传事件</strong></p> 
<blockquote> 
 <p><strong>父传子：父组件可以传递任何类型的数据给子组件</strong></p> 
</blockquote> 
<p>如果传递的数据是对象格式的，那么在子组件 内部监听 watch  的时候，需要使用深度监听，也就是添加 deep ： true ，也就是下面的子组件的监听方式，如果是别的格式的，例如，字符串、数字、布尔值、 数组格式等，那就是普通监听就好了</p> 
<p>父组件代码：在父组件中 通过<span style="color:#0d0016;"><strong> v-bind </strong></span>的缩写形式<span style="color:#f33b45;">  :listData='listData'   </span>绑定了data 内部的数据，第一个  listData 只是一个名字，为了方便辨认，所以写的相同。 第二个 listData  则是 data 内部的数据</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;我是father&lt;/h3&gt;
    &lt;Children :listData='listData' :xxx='xxx' :listObj='listObj'&gt;&lt;/Children&gt; 
    //子组件传递了一个数组、一个字符串、一个对象
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Children from './children'  //引入子组件
export default {
  data () {
    return {
      xxx:'123',
      listData: [{
          id: 1,
          name: "TCL彩电",
          price: 1000,
          num: 1,
          img: "../../../assets/a.jpg"
        }],
      listObj: {
          name: "aaa",
          age: 18
      }
    }
  },
  components : {
    Children //注册子组件
  },
}
&lt;/script&gt;</code></pre> 
<p>子组件代码：</p> 
<p>1、通过 props  接收父组件传递过来的数据，规范要求写出数据的类型以及默认值，如果数据是数组或对象形式的，需要使用函数返回，不然控制台会报错。</p> 
<p>2、props 接收数据之后，需要使用数据，这个时候需要用到  watch  监听器。对象监听需要用到 deep 深度监听，如果需要组件第一次进来之后就开始监听数据，那么需要 添加 immediate: true </p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;我是children&lt;/h3&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: {
    listData: {
      type: Array,
      default: () =&gt; []
    },
    xxx:{
      type:String,
      default : ''
    },
    listObj:{
      type: Object,
      default: () =&gt; {}
    }
  },
  watch: {
    listData:{
      handler(n,o) {
        console.log(n,o)
      }
    }，
    xxx:{
      handler(n) {
        console.log(n)
      }
    },
    listObj:{
      handler(n,o) {
        console.log(n,o)
      },
      deep: true,
      immediate: true,
    }，
  }
};
&lt;/script&gt;</code></pre> 
<blockquote> 
 <p><strong>子传父--传事件：子组件传递数据给父组件时存在三种方式，但是都是通过事件传递</strong></p> 
</blockquote> 
<p><span style="color:#0d0016;"><strong>1、父组件传递 </strong></span><span style="color:#fe2c24;"><strong>函数类型的props </strong></span><span style="color:#0d0016;"><strong>给子组件，实现子组件向父组件传递数据    </strong>      </span> </p> 
<p>在父组件中引入子组件，向子组件中 通过<strong> v-bind( 简写为 : ) </strong>绑定一个 test 属性 ，该 test 属性对应的值则是 methods 中定义的方法。</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;School :test="test"/&gt;
  &lt;/div&gt;
&lt;/template&gt;

methods: {
  test(val) {
    console.log(val,'这是子组件传递过来的数据')
  },
},</code></pre> 
<p> 定义子组件，以及子组件事件</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p class="demo" @click="goto"&gt;School组件&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p>在子组件中接收该 test 属性，定义数据，定义组件方法。其实props 可以直接写成一个数组，不去定义类型，默认值以及是否必传，但是推荐还是写全一点，这样编译的时候会校验，提高代码质量</p> 
<pre><code class="language-javascript">export default ({
  // props:['test'],
  props: {
    test: {
      type: Function,
      default: () =&gt; {},
      required: true,
    }
  },
  data() {
    return {
      msg:'子组件数据'
    }
  },
  methods: {
    goto() {
      this.test(this.msg)
    }
  },
})</code></pre> 
<p>点击触发 goto 事件，找到当前 props 中接收的 test 函数 ( <strong>props 接收的参数，都被Vue 底层处理过之后放在了 当前组件实例对象上，</strong>所以可以直接通过 this.xxx 拿到 )</p> 
<p>控制台上打印了子组件数据。可以看到子组件传递的数据被打印了，表示父组件中绑定的 test 事件被执行了</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3b/45/GyQVtzwM_o.png"></p> 
<p><span style="color:#0d0016;"><strong>2、通过 </strong></span><span style="color:#fe2c24;"><strong>v-on( @ ) 与 $emit </strong></span><span style="color:#0d0016;"><strong> 实现子组件向父组件传递数据</strong></span></p> 
<p><span style="color:#0d0016;"><strong>App 组件中引入 School 子组件，且绑定 自定义事件 test。</strong></span></p> 
<pre><code class="language-javascript">&lt;School @test="test"/&gt;

test(val) {
    console.log(val,'这是子组件传递过来的数据')
},</code></pre> 
<p>子组件模板、数据、样式不变，只是 goto 方法内部逻辑变更</p> 
<pre><code class="language-javascript">methods: {
  goto() {
    this.$emit('test',this.msg)
  }
},</code></pre> 
<p> 点击触发 goto 事件，通过 $emit 触发 test 事件，根据名称找到 父组件中的 test 属性对应的方法，执行该方法。结果与 props 传递函数参数一致</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b5/4d/lGqWpZcc_o.png"></p> 
<p><strong>3、通过 ref 以及 $on、$emit 三个 api 实现 父组件通过 自定义事件接收子组件参数</strong></p> 
<p><strong><span style="color:#fe2c24;">$on ：</span>监听当前实例上的自定义事件。事件可以由 <code>vm.$emit</code> 触发。回调函数会接收所有传入事件触发函数的额外参数。</strong></p> 
<p><span style="color:#fe2c24;"><strong>$emit ：</strong></span><strong>触发当前实例上的事件。附加参数都会传给监听器回调。</strong></p> 
<p>App 组件中引入 Schoo 组件，且给 School 子组件添加了 ref 属性，定义 test 函数</p> 
<pre><code class="language-javascript">&lt;School ref='student'/&gt;

test(val) {
    console.log(val,'这是子组件传递过来的数据')
},</code></pre> 
<p> 如果想使用这个方法去获取子组件数据，就需要用到 $on() 这个方法。现在假设，当父组件挂载时，我就要获取到子组件的值，我就应该在 父组件 的 mounted 生命周期中 使用 this.$refs.xxx来获取当前组件的实例对象，至于 $on() 这个方法，则是 挂载到 Vue 实例对象的原型上的，所以 组件实例对象 和 Vue 实例对象 都能使用 $on() 。</p> 
<p><strong>在这里就是 通过 $on 注册或者叫创建了一个 qwe 的自定义事件，且该自定义事件的回调函数是写在 methods 中的 getname</strong></p> 
<pre><code class="language-javascript">mounted() {
  this.$refs.student.$on('qwe', this.test)
}</code></pre> 
<p>父组件的工作已经完了，现在该看看子组件了。子组件更简单了，和上面 第二种方法一样，通过 $emit() 这个方法来触发父组件定义的 qwe 方法，且将子组件 数据传递出去。</p> 
<pre><code class="language-javascript">goto() {
   this.$emit('test',this.msg)
}</code></pre> 
<p> 当我点击 School 组件时，执行 goto 方法，通过 $emit 触发父组件自定义的 qwe 方法，且将参数传递给父组件。</p> 
<p>父组件通过 $on 监听 qwe 方法，发现被触发了，执行其回调函数 this.test，且 $emit 传递的参数，都会当做形参传递到回调函数中</p> 
<blockquote> 
 <p><strong>$on 和 v-on 的区别</strong></p> 
</blockquote> 
<p> 这么一看哈，其实我在子组件上使用 v-on( @ ) 和我使用 $on 做到的事情是一样的啊，那为啥还要来个 $on 这个玩意。</p> 
<p>第一点：<strong>$on 只能监听当前实例上的自定义事件，而 v-on 用在普通元素上时，只能监听<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" rel="nofollow" title="原生 DOM 事件">原生 DOM 事件</a>。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。</strong></p> 
<p>第二点：<strong>$on 更加灵活</strong>，如果我想要我的自定义事件异步绑定，通过 v-on 是无法做到的，因为    v-on 指令在 模板编译的时候，就被Vue 底层处理过了，在渲染的时候直接就会绑定事件，但是 $on 的自由度更高。</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5a9d04fe683266fa28c49d5b3a6e099/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">对Autosar NM官方文档简单备注</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d46a94c32e4a5f677ce7731160ef6133/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">太狠了,Spring 全家桶笔记, 一站式通关全攻略, 已入职某厂涨薪 18K</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>