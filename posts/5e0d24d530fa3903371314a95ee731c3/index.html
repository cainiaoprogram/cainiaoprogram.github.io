<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>08.Stack和Queue - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="08.Stack和Queue" />
<meta property="og:description" content="栈：先进后出
队列：先进先出 JVM的栈就是平常所说的一块内存。
此处所说的栈是数据结构 1. 栈(Stack) 1.1 概念 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈 顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。 出栈：栈的删除操作叫做出栈。出数据在栈顶。
1.2 栈的使用 方法功能Stack()构造一个空的栈E push(E e)将e入栈，并返回eE pop()将栈顶元素出栈并返回E peek()获取栈顶元素（只是看看栈顶，并不删除）int size()获取栈中有效元素个数boolean empty()检测栈是否为空 public static void main(String[] args) { Stack&lt;Integer&gt; s = new Stack(); s.push(1); s.push(2); s.push(3); s.push(4); System.out.println(s.size()); // 获取栈中有效元素个数---&gt; 4 System.out.println(s.peek()); // 获取栈顶元素---&gt; 4 s.pop(); // 4出栈，栈中剩余1 2 3，栈顶元素为3 System.out.println(s.pop()); // 3出栈，栈中剩余1 2 栈顶元素为3 if(s.empty()){ System.out.println(&#34;栈空&#34;); }else{ System.out.println(s.size()); } } 1.3 栈的模拟实现 import StackEmptyException.StackEmptyException; import java.util.Arrays; public class MyStack { private int[] elem; private int usedSize; public MyStack() { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5e0d24d530fa3903371314a95ee731c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-29T22:43:43+08:00" />
<meta property="article:modified_time" content="2023-05-29T22:43:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">08.Stack和Queue</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>栈：先进后出</strong></p> 
 <p><strong>队列：先进先出 </strong></p> 
</blockquote> 
<blockquote> 
 <p>JVM的栈就是平常所说的一块内存。</p> 
 <p>此处所说的栈是数据结构 </p> 
</blockquote> 
<h2>1. 栈(Stack)</h2> 
<h3>1.1 概念</h3> 
<p>栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈 顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。</p> 
<p>压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。 出栈：栈的删除操作叫做出栈。出数据在栈顶。</p> 
<p><img alt="" height="583" src="https://images2.imgbox.com/a6/5c/IKzj8W78_o.png" width="1199"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/80/6d/ehMvnK97_o.png" width="1200"></p> 
<h3><span style="color:#333333;"><strong>1.2 </strong></span><span style="color:#333333;"><strong>栈的使用</strong></span> </h3> 
<table><tbody><tr><td>方法</td><td>功能</td></tr><tr><td>Stack()</td><td>构造一个空的栈</td></tr><tr><td>E push(E e)</td><td>将e入栈，并返回e</td></tr><tr><td>E pop()</td><td>将栈顶元素出栈并返回</td></tr><tr><td>E peek()</td><td>获取栈顶元素（只是看看栈顶，并不删除）</td></tr><tr><td>int size()</td><td>获取栈中有效元素个数</td></tr><tr><td>boolean empty()</td><td>检测栈是否为空</td></tr></tbody></table> 
<pre><code class="language-java">public static void main(String[] args) {
        Stack&lt;Integer&gt; s = new Stack();
        s.push(1);
        s.push(2);
        s.push(3);
        s.push(4);
        System.out.println(s.size()); // 获取栈中有效元素个数---&gt; 4
        System.out.println(s.peek()); // 获取栈顶元素---&gt; 4
        s.pop(); // 4出栈，栈中剩余1 2 3，栈顶元素为3
        System.out.println(s.pop()); // 3出栈，栈中剩余1 2 栈顶元素为3
        if(s.empty()){
        System.out.println("栈空");
        }else{
        System.out.println(s.size());
        }
        }</code></pre> 
<h3>1.3 栈的模拟实现</h3> 
<p><img alt="" height="894" src="https://images2.imgbox.com/a1/76/Wl6JyDnf_o.png" width="1200"></p> 
<pre><code class="language-java">import StackEmptyException.StackEmptyException;

import java.util.Arrays;


public class MyStack {
    private int[] elem;
    private int usedSize;

    public MyStack() {
        this.elem = new int[5];
    }

    public void push(int val) {
        if(isFull()) {
            elem = Arrays.copyOf(elem,2*elem.length);
        }
        elem[usedSize] = val;
        usedSize++;
    }

    public boolean isFull() {
        return usedSize == elem.length;
    }


    public int pop() {
        //1、判断栈不为空
        if(empty()) {
            //抛出异常！！
            throw new StackEmptyException("栈为空！");
        }
        //2、开始删除
        return elem[--usedSize];//只需要让usedsize--
    }

    public int peek() {
        //1、判断栈不为空
        if(empty()) {
            //抛出异常！！
            throw new StackEmptyException("栈为空！");
        }
        //2、开始删除
        return elem[usedSize-1];
    }

    public boolean empty() {
        return usedSize == 0;
    }
}</code></pre> 
<h3> 1.4 栈的应用场景</h3> 
<p>1. 将递归转化为循环 比如：逆序打印链表</p> 
<pre><code class="language-java">// 递归方式
        void printList(Node head){
            if(null != head){
            printList(head.next);
            System.out.print(head.val + " ");
        }
        }
// 循环方式
        void printList(Node head){
            if(null==head){
            return;
        }
        Stack&lt;Node&gt; s=new Stack&lt;&gt;();
// 将链表中的结点保存在栈中
        Node cur=head;
        while(null!=cur){
            s.push(cur);
            cur=cur.next;
        }
        // 将栈中的元素出栈
        while(!s.empty()){
            System.out.print(s.pop().val+" ");
        }
        }
        </code></pre> 
<pre><code class="language-java"> public void show3(ListNode head) {
        if(head == null) {
            return;
        }
        if(head.next == null) {
            System.out.println(head.val);
            return;
        }
        show3(head.next);
        System.out.println(head.val);
    }

    public void show4() {
        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();
        ListNode cur = head;
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
        //依次出栈
        while (!stack.empty()) {
            ListNode tmp = stack.pop();
            System.out.println(tmp.val);
        }
    }</code></pre> 
<p>2.中缀表达式转后缀表达式 </p> 
<p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" rel="nofollow" title="150. 逆波兰表达式求值 - 力扣（Leetcode）">150. 逆波兰表达式求值 - 力扣（Leetcode）</a></p> 
<p><a href="https://blog.csdn.net/sgbfblog/article/details/8001651" title="(10条消息) 中缀表达式转换为后缀表达式_中缀表达式转后缀表达式_石锅拌饭的博客-CSDN博客">(10条消息) 中缀表达式转换为后缀表达式_中缀表达式转后缀表达式_石锅拌饭的博客-CSDN博客</a></p> 
<p>//先弹出右操作数---后缀表达式</p> 
<pre><code class="language-java">class Solution {
    public int evalRPN(String[] tokens) {
        Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();
        for(String s:tokens){
            if(!isOpera(s)){
                //数字：放入栈当中
                stack.push(Integer.parseInt(s));//将字符串转成整数
            }
            else{
                //弹出栈顶的两个元素
                int num2=stack.pop();
                int num1=stack.pop();
                switch(s){
                    case "+":
                        stack.push(num1+num2);
                        break;
                    case "-":
                        stack.push(num1-num2);
                        break;
                    case "*":
                        stack.push(num1*num2);
                        break;
                    case "/":
                        stack.push(num1/num2);
                        break;
                }
            }
            
        }
        return stack.pop();
    }


    public boolean isOpera(String s){
        if(s.equals("+")||s.equals("-")||s.equals("*")||s.equals("/")){
            return true;
        }
        return false;
    }
}</code></pre> 
<p><strong>3.括号匹配(070243)</strong></p> 
<p><a href="https://leetcode.cn/problems/valid-parentheses/" rel="nofollow" title="20. 有效的括号 - 力扣（Leetcode）">20. 有效的括号 - 力扣（Leetcode）</a></p> 
<p>（1）闭合顺序不对([)]</p> 
<p>（2）左括号多了(()</p> 
<p>（3）右括号多了())</p> 
<p>结论：</p> 
<p>1.当括号是匹配的时候，最终i遍历完了字符串，并且栈为空</p> 
<p>2.遇到不匹配的就直接结束</p> 
<p>3.当i遍历完了字符串，但是栈当中仍然有括号，则必定是左括号多了（肯定不匹配）</p> 
<p>4.当栈空了，但是字符串还没有遍历完，则必定不匹配</p> 
<p>思考：如何判断匹配</p> 
<pre><code class="language-java">class Solution {
    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack=new Stack&lt;&gt;();
        for(int i=0;i&lt;s.length();i++){
            char ch=s.charAt(i);
            if(ch=='('||ch=='['||ch=='{'){
                //左括号入栈，因为左括号一定是符号最开始的部分
                stack.push(ch);
            }
            else{//是右括号的情况
                if(stack.empty()){
                    return false;
                }
                else{
                    char tmp=stack.peek();
                    if((tmp=='('&amp;&amp;ch==')')||(tmp=='['&amp;&amp;ch==']')||(tmp=='{'&amp;&amp;ch=='}')){
                        //括号匹配成功
                        stack.pop();
                    }
                    else{
                        return false;
                    }
                }

            }
        }
        if(!stack.empty()){
            return false;
        }
        return true;
    }
}</code></pre> 
<p>4.<a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow" title="栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)">栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)</a></p> 
<p>1)何时入栈---每次都入</p> 
<p>2）什么时候出栈</p> 
<p>栈不为空的时候并且栈顶元素和k下标的元素相同时可以出栈</p> 
<div> 
 <pre><code class="language-java">import java.util.*;

public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int j = 0;//变量popA这个数组
        for (int i = 0; i &lt; pushA.length; i++) {
            stack.push(pushA[i]);
            while (!stack.empty() &amp;&amp; j &lt; popA.length
                    &amp;&amp; stack.peek() == popA[j]) {
                stack.pop();
                j++;
            }
        }
        return stack.empty();
    }
}</code></pre> 
</div> 
<p>分析：栈当中的最小值是随时改变的，这个最小值拿的是当前栈中剩下元素的最小的值</p> 
<p>随着弹出数据，最小值也是发生改变的，类似于更新的最小值倒着往回取。</p> 
<blockquote> 
 <p><span style="color:#fe2c24;">1.当栈中第一次存放数据的时候，两个栈中都要存储数据</span></p> 
 <p><span style="color:#fe2c24;">2.第二次判断大小，看是否要放到min stack中。即第二次开始，每次入栈都需要和最小栈的栈顶元素进行比较，小于的时候才能入栈</span></p> 
 <p><span style="color:#fe2c24;">3.出栈的时候，每次出栈都要和栈顶元素进行比较，如果和栈顶元素一样，那么两个栈都得出。</span></p> 
</blockquote> 
<p><a href="https://leetcode.cn/problems/min-stack/" rel="nofollow" title="155. 最小栈 - 力扣（Leetcode）">155. 最小栈 - 力扣（Leetcode）</a></p> 
<div> 
 <pre><code class="language-java">import java.util.Stack;

class MinStack {
    private Stack&lt;Integer&gt; stack ;
    private Stack&lt;Integer&gt; minStack ;
    public MinStack() {
        stack = new Stack&lt;&gt;();
        minStack = new Stack&lt;&gt;();
    }
    
    public void push(int val) {
        stack.push(val);
        //第一次在最小栈当中存储元素
        if(minStack.empty()) {
            minStack.push(val);
        }else {
            if(val &lt;= minStack.peek()) {
                minStack.push(val);
            }
        }
    }
    
    public void pop() {
        //栈为空 则不能进行弹出元素
        if(stack.empty()) {
            return;
        }
        int val = stack.pop();
        if(val == minStack.peek()) {
            minStack.pop();
        }
    }
    //获取栈顶元素 和 最小栈没有关系
    public int top() {
        if(stack.empty()) {
            return -1;
        }
        return stack.peek();
    }

    //获取元素 不是删除元素
    public int getMin() {
        return minStack.peek();
    }
    
}
</code></pre> 
</div> 
<h2><span style="color:#333333;"><strong>2. </strong></span><span style="color:#333333;"><strong>队列</strong></span><span style="color:#333333;"><strong>(Queue) </strong></span></h2> 
<div> 
 <span style="color:#333333;"><strong>队列</strong></span> 
 <span style="color:#333333;">：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出</span> 
 <span style="color:#333333;">FIFO(First In First Out)</span> 
</div> 
<div> 
 <span style="color:#333333;">入队列：进行插入操作的一端称为</span> 
 <span style="color:#333333;"><strong>队尾</strong></span> 
 <span style="color:#333333;"><strong>（</strong></span> 
 <span style="color:#333333;"><strong>Tail/Rear</strong></span> 
 <span style="color:#333333;"><strong>） </strong></span> 
</div> 
<div> 
 <span style="color:#333333;">出队列：进行删除操作的一端称为</span> 
 <span style="color:#333333;"><strong>队头 </strong></span> 
 <span style="color:#333333;"><strong>（</strong></span> 
 <span style="color:#333333;"><strong>Head/Front</strong></span> 
 <span style="color:#333333;"><strong>）</strong></span> 
</div> 
<blockquote> 
 <p>//从队尾进，队头出</p> 
 <p>//可以用链表实现</p> 
 <p>//入栈和出栈操作都是O(1)</p> 
 <p>//双向链表不管从哪入栈出栈时间复杂度都是O(1)</p> 
 <p>//如果是单链表，可以考虑头插法进行入栈，出栈，此时时间复杂度为O(1)</p> 
 <p>//如果是双向链表，入队和出队都可以达到O(1)</p> 
 <p>//LinkedList也经常被当作栈来使用</p> 
</blockquote> 
<p><img alt="" height="313" src="https://images2.imgbox.com/89/f9/0VvYtyB1_o.png" width="1200">​</p> 
<h3><span style="color:#333333;"><strong>2.2 </strong></span><span style="color:#333333;"><strong>队列的使用（队头、队尾--队尾进、队头出 ）</strong></span></h3> 
<div> 
 <span style="color:#333333;">在</span> 
 <span style="color:#333333;">Java</span> 
 <span style="color:#333333;">中，</span> 
 <span style="color:#333333;"><strong>Queue</strong></span> 
 <span style="color:#333333;"><strong>是个接口，底层是通过链表实现</strong></span> 
 <span style="color:#333333;">的。</span> 
</div> 
<div> 
 <img alt="" height="596" src="https://images2.imgbox.com/79/26/6fVIup07_o.png" width="652">​ 
</div> 
<p></p> 
<p></p> 
<table><tbody><tr><td>方法</td><td>功能</td></tr><tr><td>boolean offer(E e)</td><td>入队列</td></tr><tr><td>E poll()</td><td>出队列</td></tr><tr><td>peek()</td><td>获取队头元素</td></tr><tr><td>int size()</td><td>获取队列中有效元素个数</td></tr><tr><td>boolean isEmpty()</td><td>检测队列是否为空</td></tr></tbody></table> 
<div> 
 <span style="color:#333333;">注意：</span> 
 <span style="color:#333333;">Queue</span> 
 <span style="color:#333333;">是个接口，在实例化时必须实例化</span> 
 <span style="color:#333333;">LinkedList</span> 
 <span style="color:#333333;">的对象，因为</span> 
 <span style="color:#333333;">LinkedList</span> 
 <span style="color:#333333;">实现了</span> 
 <span style="color:#333333;">Queue</span> 
 <span style="color:#333333;">接口。</span> 
</div> 
<div> 
 <pre><code class="language-java">public static void main(String[] args) {
        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        q.offer(1);
        q.offer(2);
        q.offer(3);
        q.offer(4);
        q.offer(5); // 从队尾入队列
        System.out.println(q.size());
        System.out.println(q.peek()); // 获取队头元素
        q.poll();
        System.out.println(q.poll()); // 从队头出队列，并将删除的元素返回
        if(q.isEmpty()){
            System.out.println("队列空");
        }else{
            System.out.println(q.size());
        }
    }</code></pre> 
 <h3>2.3 队列模拟实现</h3> 
 <p>队列中既然可以存储元素，那底层肯定要有能够保存元素的空间，通过前面线性表的学习了解到常见的空间类型有 两种：顺序结构 和 链式结构。</p> 
 <p><img alt="" height="964" src="https://images2.imgbox.com/17/0e/qYQwQogN_o.png" width="1200"></p> 
 <pre><code class="language-java">public class Queue {
    // 双向链表节点
    public static class ListNode{
        ListNode next;
        ListNode prev;
        int value;
        ListNode(int value){
            this.value = value;
        }
    }
    ListNode first; // 队头
    ListNode last; // 队尾
    int size = 0;
    // 入队列---向双向链表位置插入新节点
    public void offer(int e){
        ListNode newNode = new ListNode(e);
        if(first == null){
            first = newNode;
// last = newNode;
        }else{
            last.next = newNode;
            newNode.prev = last;
// last = newNode;
        }
        last = newNode;
        size++;
    }
    // 出队列---将双向链表第一个节点删除掉
    public int poll(){
// 1. 队列为空
// 2. 队列中只有一个元素----链表中只有一个节点---直接删除
// 3. 队列中有多个元素---链表中有多个节点----将第一个节点删除
        int value = 0;
        if(first == null){
            return null;
        }else if(first == last){
            last = null;
            first = null;
        }else{
            value = first.value;
            first = first.next;
            first.prev.next = null;
            first.prev = null;
        }
        --size;
        return value;
    }
    // 获取队头元素---获取链表中第一个节点的值域
    public int peek(){
        if(first == null){
            return null;
        }
        return first.value;
    }
    public int size() {
        return size;
    }
    public boolean isEmpty(){
        return first == null;
    }
}</code></pre> 
 <pre><code class="language-java">public class MyQueue {
    static class ListNode {
        public int val;
        public ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }
    public ListNode head;
    public ListNode last;

    private int usedSize;

    public void offer(int val) {
        ListNode node = new ListNode(val);
        if(head == null) {
            head = node;
            last = node;
        }else {
            last.next = node;
            last = last.next;
        }
        usedSize++;
    }

    public int getUsedSize() {
        return usedSize;
    }

    public int poll() {
        if(head == null) {
            return -1;
        }
        int val = -1;
        if(head.next == null) {
            val = head.val;
            head = null;
            last = null;
            return val;
        }
        val = head.val;
        head = head.next;
        usedSize--;
        return val;
    }

    public int peek() {
        if(head == null) {
            return -1;
        }
        return head.val;
    }

}</code></pre> 
 <h3>2.4 循环队列</h3> 
 <p>实际中我们有时还会使用一种队列叫循环队列。如操作系统课程讲解生产者消费者模型时可以就会使用循环队列。 环形队列通常使用数组实现。</p> 
 <p><img alt="" height="892" src="https://images2.imgbox.com/80/bb/sia3MVJZ_o.png" width="1200"></p> 
 <div> 
  <span style="color:#333333;"><strong>数组下标循环的小技巧 </strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;">下标最后再往后</span> 
  <span style="color:#333333;">(offffset </span> 
  <span style="color:#333333;">小于</span> 
  <span style="color:#333333;"> array.length): index = (index + offffset) % array.length</span> 
 </div> 
 <div> 
  <img alt="" height="640" src="https://images2.imgbox.com/f5/6d/IZHjL0PU_o.png" width="1200"> 
 </div> 
 <p><span style="color:#333333;">2. </span><span style="color:#333333;">下标最前再往前</span><span style="color:#333333;">(offffset </span><span style="color:#333333;">小于</span><span style="color:#333333;"> array.length): index = (index + array.length - offffset) % array.length </span></p> 
 <p><img alt="" height="641" src="https://images2.imgbox.com/bb/c6/DL1NxUt9_o.png" width="1200"></p> 
 <div> 
  <span style="color:#333333;"><strong>如何区分空与满 </strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;">通过添加</span> 
  <span style="color:#333333;"> size </span> 
  <span style="color:#333333;">属性记录 </span> 
 </div> 
 <div> 
  <strong><span style="color:#fe2c24;">定义一个usedsize.usedsize==len的时候为满</span></strong> 
 </div> 
 <div> 
  <span style="color:#333333;">2. 保留一个位置（浪费一个空间来表示当前满）</span> 
 </div> 
 <div> 
  <span style="color:#333333;">问：rear怎么从a7下标到a0下标？</span> 
 </div> 
 <div> 
  <span style="color:#333333;">（rear+1）%len</span> 
 </div> 
 <p> <img alt="" height="874" src="https://images2.imgbox.com/e7/18/JqbH6HHT_o.png" width="1200"></p> 
 <p> <a href="https://leetcode.cn/problems/design-circular-queue/" rel="nofollow" title="622. 设计循环队列 - 力扣（Leetcode）">622. 设计循环队列 - 力扣（Leetcode）</a></p> 
 <p></p> 
 <pre><code class="language-java">class MyCircularQueue {
    private int[] elem;
    private int front;//队头下标
    private int rear;//队尾下标

    public MyCircularQueue(int k) {
        this.elem = new int[k+1];
    }

    //入队
    public boolean enQueue(int value) {
        if(isFull()) {
            return false;
        }
        elem[rear] = value;
        rear = (rear+1) % elem.length;
        return true;
    }

    //出队
    public boolean deQueue() {
        if(isEmpty()) {
            return false;
        }
        front = (front+1) % elem.length;
        return true;
    }

    //得到队头元素
    public int Front() {
        if(isEmpty()) {
            return -1;
        }
        return elem[front];
    }
    //得到队尾元素
    public int Rear() {
        if(isEmpty()) {
            return -1;
        }
        int index = (rear == 0) ? elem.length-1 : rear-1;
        return elem[index];
    }
    
    public boolean isEmpty() {
        return rear == front;
    }
    
    public boolean isFull() {
        return (rear+1) % elem.length == front;
    }


    public static void main(String[] args) {
        MyCircularQueue myCircularQueue = new MyCircularQueue(3);
        System.out.println(myCircularQueue.enQueue(1));
        System.out.println(myCircularQueue.enQueue(2));
        System.out.println(myCircularQueue.enQueue(3));
        System.out.println(myCircularQueue.enQueue(4));
        System.out.println(myCircularQueue.Rear());//  2
        System.out.println(myCircularQueue.isFull());
        System.out.println(myCircularQueue.deQueue());
        System.out.println(myCircularQueue.enQueue(4));
        System.out.println(myCircularQueue.Rear());
    }
}</code></pre> 
 <h2><span style="color:#333333;"><strong>3. </strong></span><span style="color:#333333;"><strong>双端队列</strong></span><span style="color:#333333;"><strong> (Deque) </strong></span></h2> 
 <div> 
  <span style="color:#333333;">双端队列（</span> 
  <span style="color:#333333;">deque</span> 
  <span style="color:#333333;">）是指允许两端都可以进行入队和出队操作的队列，</span> 
  <span style="color:#333333;">deque </span> 
  <span style="color:#333333;">是</span> 
  <span style="color:#333333;"> “double ended queue” </span> 
  <span style="color:#333333;">的简称。 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">那就说明元素可以从队头出队和入队，也可以从队尾出队和入队。 </span> 
 </div> 
 <div></div> 
</div> 
<p><img alt="" height="355" src="https://images2.imgbox.com/a9/c6/d4ZMwr1n_o.png" width="1200"></p> 
<p><span style="color:#333333;">Deque</span><span style="color:#333333;">是一个接口，使用时必须创建</span><span style="color:#333333;">LinkedList</span><span style="color:#333333;">的对象。</span></p> 
<p><img alt="" height="943" src="https://images2.imgbox.com/e2/32/nK4iZm2c_o.png" width="1200"></p> 
<div> 
 <span style="color:#333333;">在实际工程中，使用</span> 
 <span style="color:#333333;">Deque</span> 
 <span style="color:#333333;">接口是比较多的，栈和队列均可以使用该接口。 </span> 
</div> 
<div> 
 <blockquote> 
  <div> 
   <span style="color:#333333;">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();//</span> 
   <span style="color:#333333;">双端队列的线性实现 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;();//</span> 
   <span style="color:#333333;">双端队列的链式实现</span> 
  </div> 
 </blockquote> 
</div> 
<div> 
 <span style="color:#333333;"><strong>4. </strong></span> 
 <span style="color:#333333;"><strong>面试题 </strong></span> 
</div> 
<div> 
 <span style="color:#333333;">1. </span> 
 <span style="color:#333333;">用队列实现栈。</span> 
 <a href="https://leetcode.cn/problems/implement-stack-using-queues/" rel="nofollow" title="225. 用队列实现栈 - 力扣（Leetcode）">225. 用队列实现栈 - 力扣（Leetcode）</a> 
 <span style="color:#4183c4;"> </span> 
</div> 
<p>1)push元素的时候应当放在那里？哪个队列不为空就放在哪里</p> 
<p>2）出栈的时候，出不为空的队列size-1元素，剩余元素是要出栈的元素</p> 
<pre><code class="language-java">import java.util.LinkedList;
import java.util.Queue;

class MyStack {

    private Queue&lt;Integer&gt; qu1;
    private Queue&lt;Integer&gt; qu2;

    public MyStack() {
        qu1 = new LinkedList&lt;&gt;();
        qu2 = new LinkedList&lt;&gt;();
    }
    
    public void push(int x) {
        //放到不为空的队列
        if(!qu1.isEmpty()) {
            qu1.offer(x);
        }else if(!qu2.isEmpty()) {
            qu2.offer(x);
        }else {
            //如果都是空的 放到第一个
            qu1.offer(x);
        }
    }
    
    public int pop() {
        //两个队列都是空的： 栈为空
        if(empty()) {
            return -1;
        }
        if(!qu1.isEmpty()) {
            int currentSize = qu1.size();
            for (int i = 0; i &lt; currentSize-1; i++) {
                int x = qu1.poll();
                qu2.offer(x);
            }
            return qu1.poll();//最后一个数据返回
        }
        if(!qu2.isEmpty()) {
            int currentSize = qu2.size();
            for (int i = 0; i &lt; currentSize-1; i++) {
                int x = qu2.poll();
                qu1.offer(x);
            }
            return qu2.poll();//最后一个数据返回
        }
        return -1;
    }
    //peek方法
    public int top() {
        if(empty()) {
            return -1;
        }
        if(!qu1.isEmpty()) {
            int currentSize = qu1.size();
            int x = -1;
            for (int i = 0; i &lt; currentSize; i++) {
                x = qu1.poll();
                qu2.offer(x);
            }
            return x;//最后一个数据返回
        }
        if(!qu2.isEmpty()) {
            int currentSize = qu2.size();
            int x = -1;
            for (int i = 0; i &lt; currentSize; i++) {
                x = qu2.poll();
                qu1.offer(x);
            }
            return x;//最后一个数据返回
        }
        return -1;
    }
    
    public boolean empty() {
        return qu1.isEmpty() &amp;&amp; qu2.isEmpty();
    }
}</code></pre> 
<p></p> 
<p></p> 
<div> 
 <span style="color:#333333;">2. </span> 
 <span style="color:#333333;">用栈实现队列。</span> 
</div> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a8bb253a31c2f4d2c7b9ed8628c63e66/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习AI编译器-TVM简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09f9cf8e61b93cd9db33b286b47de419/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用引用计数对C&#43;&#43;对象进行管理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>