<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HDU 4745 Two Rabbits - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HDU 4745 Two Rabbits" />
<meta property="og:description" content="题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=4745
题目分析 这个题目乍一看觉得很麻烦，不过仔细读题就会发现一个重要的条件：两个兔子不会相互穿过，也就是说，两个兔子始终在一个环里面走；而且在任意时刻，两个兔子所在的位置的权值一样，那么我们设想一下两个兔子都从终点出发，看他们最远可以走多少步，这样等价于两个兔子从任意位置出发最后聚集于同一个位置一样；
那么我们从终点走的时候，两个兔子走过的石子的权值恰好构成一个回文串。
这样一来我们所求的就变成了求给定的环中最长的回文子序列了。
现在讲一下下面代码的思想吧，我们记dp [ i ] [ j ] 为从 i - j 的最长回文子序列的长度，先求出了所有子序列的回文长度，具体做法：
首先说明一下代码： dp[i][j] = max(dp[i &#43; 1][j], dp[i][j - 1]);
现在我们需要求的是区间 [ i, j ] 的最长回文子序列，如图
那么这个区间的最长回文子串可能是由区间 [ i&#43;1 , j ] 的左边添加一个元素后形成的，为了不打乱 [ i &#43; 1 , j ] 中的最长回文子序列，我们把添加的元素不计入回文串的计算就好。
同理，这个区间的最长回文子串也可能是在区间 [ i , j - 1] 的右边添加一个元素后形成的，为了不打乱 [ i , j - 1 ] 中的最长回文子序列，我们把添加的元素不计入回文串的计算就好。
然后就是代码: if (w[i] == w[j]) dp[i][j] = max(dp[i][j], dp[i &#43; 1][j - 1] &#43; 2);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6626e0266f4290d791bd40db075e3023/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-24T11:37:42+08:00" />
<meta property="article:modified_time" content="2019-05-24T11:37:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HDU 4745 Two Rabbits</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4745" rel="nofollow">http://acm.hdu.edu.cn/showproblem.php?pid=4745</a></p> 
</blockquote> 
<h3>题目分析</h3> 
<p style="text-indent:50px;"> 这个题目乍一看觉得很麻烦，不过仔细读题就会发现一个重要的条件：两个兔子不会相互穿过，也就是说，两个兔子始终在一个环里面走；而且在任意时刻，两个兔子所在的位置的权值一样，那么我们设想一下两个兔子都从终点出发，看他们最远可以走多少步，这样等价于两个兔子从任意位置出发最后聚集于同一个位置一样；</p> 
<p style="text-indent:50px;">那么我们从终点走的时候，两个兔子走过的石子的权值恰好构成一个回文串。</p> 
<p style="text-indent:50px;">这样一来我们所求的就变成了求给定的环中最长的回文子序列了。</p> 
<p style="text-indent:50px;">现在讲一下下面代码的思想吧，我们记dp [ i ] [ j ] 为从 i - j 的最长回文子序列的长度，先求出了所有子序列的回文长度，具体做法：</p> 
<p style="text-indent:50px;">首先说明一下代码： dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</p> 
<p style="text-indent:50px;">现在我们需要求的是区间 [ i, j ] 的最长回文子序列，如图</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="74" src="https://images2.imgbox.com/c6/03/WJARlpbv_o.png" width="578"></p> 
<p style="text-indent:50px;">那么这个区间的最长回文子串可能是由区间 [ i+1 , j ] 的左边添加一个元素后形成的，为了不打乱 [ i + 1 , j ] 中的最长回文子序列，我们把添加的元素不计入回文串的计算就好。</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="72" src="https://images2.imgbox.com/5c/16/rh2LTw4U_o.png" width="578"></p> 
<p style="text-indent:50px;">同理，这个区间的最长回文子串也可能是在区间 [ i , j - 1] 的右边添加一个元素后形成的，为了不打乱 [ i , j - 1 ] 中的最长回文子序列，我们把添加的元素不计入回文串的计算就好。</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="72" src="https://images2.imgbox.com/ff/10/7XCvXLvC_o.png" width="578"></p> 
<p style="text-indent:50px;">然后就是代码: if (w[i] == w[j]) dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + 2);</p> 
<p style="text-indent:50px;">除去上面两种得到当前区间最长回文子串的方法外，还有一种情况，那就是当 w[i] == w[j] 的时候，我们可以在原区间 [ i + 1 , j -1 ] 的基础上使得区间 [ i+1, j -1 ] 的最长回文子串添加了 i,j 后 长度 加 2 得到了区间 [ i, j ] 的最长回文子串</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="71" src="https://images2.imgbox.com/54/83/nyikbRZC_o.png" width="578"></p> 
<p style="text-indent:50px;">这样，我们就求出了区间 [ 1 , n ] 所有子串的最长回文子串。</p> 
<p style="text-indent:50px;">下面解释一下代码：for (int i = 1; i &lt;= n; i++)  ans = max(dp[1][i] + dp[i + 1][n], ans);</p> 
<p style="text-indent:50px;">在这里我们枚举所有的石子作为两个区间的分隔点 i ，使得分隔点左边区间 [ 1,  i ] 的最长回文子串的长度加上右边区间        [ i +1 ,n ] 的最长回文子串的长度，求出这个和的最大值，即为我们所求的答案。我们来解释一下原理：</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="110" src="https://images2.imgbox.com/b3/82/1d3sH5vR_o.png" width="793"></p> 
<p style="text-indent:50px;">我们画出了这个的示意图，由图我们很清晰的看出来 ，兔子1 和兔子2走的路是一样的，而且他们所走的路程之和就是       区间[ 1, i ] 和 [ i+1, n ] 的最长回文串的长度之和，这里，其实理解了两只兔子是如何行走的，就可以理解这个代码的意思了</p> 
<h3>代码区</h3> 
<pre class="has"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
using namespace std;
typedef long long ll;
const int Max = 1e3 + 10;
const int inf = 0x3f3f3f3f;
using namespace std;

int dp[Max][Max];//dp[i][j]从i -&gt; j 的最长回文子序列长度
int w[Max];			//石子权值

int main()
{
	std::ios::sync_with_stdio(false);
	int n;
	while(cin&gt;&gt;n &amp;&amp; n)
	{
		for(int i = 1 ; i &lt;= n ; i++)
		{
			cin &gt;&gt; w[i];
		}
		for(int i = 1 ; i &lt;= n ; i++)
		{
			for(int j = 1;  j&lt;= n ; j++)
			{
				if(i == j)
				{
					dp[i][j] = 1;
				}
				else
				{
					dp[i][j] = 0;
				}
			}
		}
		for(int i = n-1 ; i &gt; 0 ; i--)
		{
			for(int j =i +1 ; j &lt;= n ; j++)
			{
				dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
				//从[i-j]的子区间[i+1,j] [i,j-1]转移而来

				if (w[i] == w[j]) dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + 2);
				//区间两边相同，判断区间[i+1,j] [i,j-1]的最大回文串子串和[i+1,j-1]+2的最大回文串子串的长度
			}
		}
		int ans = 0;
		for (int i = 1; i &lt;= n; i++) ans = max(dp[1][i] + dp[i + 1][n], ans);//两只兔子分别以[1,i]的中心位置出发，走到[i+1,n]的中心位置
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a8a3d62a9372edd1b301d03692c4af01/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Comparison method violates its general contract!</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ca4c50b905dc21ea17a10549a6f5944f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">bootstrap</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>