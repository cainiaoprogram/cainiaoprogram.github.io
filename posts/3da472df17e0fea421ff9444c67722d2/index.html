<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python 内建排序 HOW TO - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python 内建排序 HOW TO" />
<meta property="og:description" content="list.sort()与sorted() python 有两个内建排序函数：一个是list.sort(),对调用该函数的list进行原地排序；另一个是sorted()，可以对任意迭代器进行排序，返回list类型的序列。二者有两个区别。
第一,list.sort()没有返回值，只对list原地排序；而sorted()将排序后序列作为新list返回，如下实例：
&gt;&gt;&gt; sorted([5, 2, 3, 1, 4]) [1, 2, 3, 4, 5] &gt;&gt;&gt; a = [5, 2, 3, 1, 4] &gt;&gt;&gt; a.sort() &gt;&gt;&gt; a [1, 2, 3, 4, 5] 第二，list.sort()只应用于list，而sorted()可用于任意迭代器，如下实例：
&gt;&gt;&gt; sorted({1: &#39;D&#39;, 2: &#39;B&#39;, 3: &#39;B&#39;, 4: &#39;E&#39;, 5: &#39;A&#39;}) [1, 2, 3, 4, 5] 另外，二者都有相同参数：1.key 2.reverse 3.cmp，并且使用方法相同，下面通过sorted()进行详细说明
key参数的使用 基本说明：
key参数指定一个函数，这个函数的实参为每个迭代器的item，经过该函数运算，返回值为每个item中需要进行对比的项（key），如下实例：
&gt;&gt;&gt; sorted(&#34;This is a test string from Andrew&#34;.split(), key=str.lower) [&#39;a&#39;, &#39;Andrew&#39;, &#39;from&#39;, &#39;is&#39;, &#39;string&#39;, &#39;test&#39;, &#39;This&#39;] 简单说，key参数值必须是一个函数，且这个函数只有一个参数，并且返回一个key值，作为比较使用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3da472df17e0fea421ff9444c67722d2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-01-24T16:53:51+08:00" />
<meta property="article:modified_time" content="2013-01-24T16:53:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python 内建排序 HOW TO</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>list.sort()与sorted()</h4> 
<p></p> 
<p style="margin-left:40px"><br> </p> 
<p style="margin-left:40px">python 有两个内建排序函数：一个是<span style="font-weight:bold">list.sort()</span>,对调用该函数的list进行原地排序；另一个是<span style="font-weight:bold">sorted()</span>，可以对任意迭代器进行排序，返回list类型的序列。二者有两个区别。</p> 
<p style="margin-left:40px"><br> </p> 
<p style="margin-left:40px">第一,list.sort()没有返回值，只对list原地排序；而sorted()将排序后序列作为新list返回，如下实例：</p> 
<blockquote> 
 <blockquote> 
  <pre><code class="language-python">&gt;&gt;&gt; sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]

&gt;&gt;&gt; a = [5, 2, 3, 1, 4]
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
[1, 2, 3, 4, 5]</code></pre> 
 </blockquote> 
</blockquote> 
<p style="margin-left:80px"><span style="font-family:monospace"><br> </span></p> 
<p style="margin-left:40px">第二，list.sort()只应用于list，而sorted()可用于任意迭代器，如下实例：</p> 
<div style="margin-left:80px"> 
 <pre><code class="language-python">&gt;&gt;&gt; sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]</code></pre> 
 <br> 
 <br> 
</div> 
<p style="margin-left:40px">另外，二者都有相同参数：1.key  2.reverse  3.cmp，并且使用方法相同，下面通过<strong>sorted()</strong>进行详细说明</p> 
<p style="margin-left:40px"><br> </p> 
<p style="margin-left:40px"><br> </p> 
<p style="margin-left:40px"><br> </p> 
<h4>key参数的使用</h4> 
<blockquote> 
 <h5><br> </h5> 
 <h5>基本说明：<br> </h5> 
</blockquote> 
<blockquote> 
 <p>key参数指定一个函数，这个函数的实参为每个迭代器的item，经过该函数运算，返回值为每个item中需要进行对比的项（key），如下实例：</p> 
</blockquote> 
<blockquote> 
 <blockquote> 
  <p></p> 
  <pre><code class="language-python">&gt;&gt;&gt; sorted("This is a test string from Andrew".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']</code></pre> 
  <p></p> 
 </blockquote> 
 <p>简单说，key参数值必须是一个函数，且这个函数只有一个参数，并且返回一个key值，作为比较使用。</p> 
 <p><br> </p> 
 <p><br> </p> 
 <h5>使用实例说明：<br> </h5> 
 <p>通常情况下，对于复杂结构进行排序，通常使用索引作为比较的key，例如：</p> 
 <blockquote> 
  <p></p> 
  <pre><code class="language-python">&gt;&gt;&gt; student_tuples = [
    ('john', 'A', 15),
    ('jane', 'B', 12),
    ('dave', 'B', 10),
]
&gt;&gt;&gt; sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]</code></pre> 
  <p></p> 
 </blockquote> 
 <p>类似的排序方式，也可以用于类，例如：</p> 
 <blockquote> 
  <p></p> 
  <pre><code class="language-python">&gt;&gt;&gt; class Student:
        def __init__(self, name, grade, age):
            self.name = name
            self.grade = grade
            self.age = age
        def __repr__(self):
            return repr((self.name, self.grade, self.age))

&gt;&gt;&gt;

&gt;&gt;&gt; student_objects = [
    Student('john', 'A', 15),
    Student('jane', 'B', 12),
    Student('dave', 'B', 10),
]
&gt;&gt;&gt; sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

</code></pre> 
  <p></p> 
 </blockquote> 
 <blockquote> 
  <p><br> </p> 
  <p><br> </p> 
 </blockquote> 
 <h5>使用Operator模块</h5> 
</blockquote> 
<blockquote> 
 <p>由于以上使用key参数的方式十分普遍，python提供了相关函数，使以上方式的使用更加简单快捷。</p> 
 <p><br> </p> 
 <p>operator模块提供了 <a class="reference internal" href="http://docs.python.org/2/library/operator.html#operator.itemgetter" rel="nofollow" title="operator.itemgetter"> <tt class="xref py py-func docutils literal"><span class="pre">operator.itemgetter()</span></tt></a>,<a class="reference internal" href="http://docs.python.org/2/library/operator.html#operator.attrgetter" rel="nofollow" title="operator.attrgetter"><tt class="xref py py-func docutils literal"><span class="pre">operator.attrgetter()</span></tt></a>函数，在 Python 2.5以后还提供了<a class="reference internal" href="http://docs.python.org/2/library/operator.html#operator.methodcaller" rel="nofollow" title="operator.methodcaller"><tt class="xref py py-func docutils literal"><span class="pre">operator.methodcaller()</span></tt></a> 函数。使用这些函数可以让上节描述的排序方法更加快捷方便：</p> 
 <blockquote> 
  <p></p> 
  <pre><code class="language-python">&gt;&gt;&gt; from operator import itemgetter, attrgetter

&gt;&gt;&gt;

&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

&gt;&gt;&gt;

&gt;&gt;&gt; sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

</code></pre> 
  <br> 
  <p></p> 
 </blockquote> 
 <p>operater模块提供的函数，可以进行多级排序. 如下实例, 先以<em>grade</em>排序，再以 <em>age</em>排序：</p> 
 <blockquote> 
  <p></p> 
  <pre><code class="language-python">&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

&gt;&gt;&gt;

&gt;&gt;&gt; sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

</code></pre> 
  <p></p> 
 </blockquote> 
 <p><br> </p> 
 <p>operator.methodcaller()函数可以调用方法，操作需要比较的item后，然后对item进行比较。如下实例，str.count()方法对每个item的感叹号进行统计，按照包含感叹号的多少进行排序：<br> </p> 
 <blockquote> 
  <pre><code class="language-python">&gt;&gt;&gt; messages = ['critical!!!', 'hurry!', 'standby', 'immediate!!']
&gt;&gt;&gt; sorted(messages, key=methodcaller('count', '!'))
['standby', 'hurry!', 'immediate!!', 'critical!!!']
</code></pre> 
  <br> 
 </blockquote> 
</blockquote> 
<h4>reverse参数的使用</h4> 
<blockquote> 
 <p>reverse参数很好理解，如果reverse=True，将以降序排序，如下实例：<br> </p> 
 <blockquote> 
  <pre><code class="language-python">&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

&gt;&gt;&gt;

&gt;&gt;&gt; sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]</code></pre> 
  <br> 
 </blockquote> 
 <p><br> </p> 
</blockquote> 
<h4>cmp参数的使用（不推荐）</h4> 
<blockquote> 
 <p>在python2.4以前，排序没有key参数，所有进行自定义排序，使用的都是cmp参数。而在python 3开始，就没有cmp参数了，另外cmp参数没有key运行得快，所以这里只做简单说明，建议大家尽量使用key参数进行排序</p> 
 <p><br> </p> 
 <p>cmp参数值是一个有两个参数的函数，该函数参数的实参也是需要比较的item，通过该函数进行计算，返回的结果如果为负数，证明item1&lt;item2，若为0，证明item1=item2，为正数，证明item1&gt;item2。如下例子：</p> 
 <blockquote> 
  <p></p> 
  <pre><code class="language-python">&gt;&gt;&gt; def numeric_compare(x, y):
        return x - y
&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]</code></pre> 
  <br> 
  <p></p> 
 </blockquote> 
 <p>刚才说道python3.x不支持cmp参数，如何将python2.x程序迁移到python3.x呢？使用下述方法：</p> 
 <blockquote> 
  <p></p> 
  <pre><code class="language-python">def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) &lt; 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) &gt; 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) &lt;= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) &gt;= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return K


</code></pre> 
  <pre><code class="language-python">&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]</code></pre> 
  <br> 
  <p></p> 
 </blockquote> 
 <p>在python2.7以后，<a class="reference internal" href="http://docs.python.org/2/library/functools.html#functools.cmp_to_key" rel="nofollow" title="functools.cmp_to_key"><tt class="xref py py-func docutils literal"><span class="pre">functools.cmp_to_key()</span></tt></a> 可直接通过functools进行调用</p> 
 <p><br> </p> 
</blockquote> 
<p><br> </p> 
<h4>另外一些说明</h4> 
<blockquote> 
 <p>一、为类组成的列表，提供默认的排序方法</p> 
 <p>在类中将排序中作为key的属性，加入相关比较的方法中，如下：</p> 
 <blockquote> 
  <pre><code class="language-python">&gt;&gt;&gt; Student.__eq__ = lambda self, other: self.age == other.age
&gt;&gt;&gt; Student.__ne__ = lambda self, other: self.age != other.age
&gt;&gt;&gt; Student.__lt__ = lambda self, other: self.age &lt; other.age
&gt;&gt;&gt; Student.__le__ = lambda self, other: self.age &lt;= other.age
&gt;&gt;&gt; Student.__gt__ = lambda self, other: self.age &gt; other.age
&gt;&gt;&gt; Student.__ge__ = lambda self, other: self.age &gt;= other.age
&gt;&gt;&gt; sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]</code></pre> 
 </blockquote> 
 <p><br> 一般以实现这六种比较方法为佳，另外可以使用<a class="reference internal" href="http://docs.python.org/2/library/functools.html#functools.total_ordering" rel="nofollow" title="functools.total_ordering"><tt class="xref py py-func docutils literal"><span class="pre">functools.total_ordering()</span></tt></a>修饰，可以简化代码量</p> 
 <p><br> </p> 
 <p>二、key参数的另一种用法</p> 
 <p>key参数不只依赖被排序的实例，可以使用额外的实例作为key。如下例子：student 成绩存在一个字典中, 此字典可以用于给另一个包含student姓名的list排序:：</p> 
 <blockquote> 
  <pre><code class="language-python">&gt;&gt;&gt; students = ['dave', 'john', 'jane']
&gt;&gt;&gt; grades = {'john': 'F', 'jane':'A', 'dave': 'C'}
&gt;&gt;&gt; sorted(students, key=grades.__getitem__)
['jane', 'dave', 'john']
</code></pre> 
  <br> 
 </blockquote> 
</blockquote> 
<h4>参考：<br> </h4> 
<blockquote> 
 <p>http://docs.python.org/2/howto/sorting.html<br> </p> 
</blockquote> 
<blockquote> 
 <blockquote> 
  <p></p> 
 </blockquote> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c8837e5c06f5ddca5ab8361593a8a96b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jQuery实例--Ajax信息的增删改查等操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f9de7dd06f6326c4f488ebf1cfc6e4a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是图形加速卡（二）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>